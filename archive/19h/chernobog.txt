Project Path: arc_19h_chernobog_v_x95_io

Source Tree:

```txt
arc_19h_chernobog_v_x95_io
├── CMakeLists.txt
├── Makefile
├── README.md
├── hero.png
├── ida-cmake
│   ├── README.md
│   ├── bootstrap.cmake
│   ├── cmake
│   │   ├── compiler.cmake
│   │   ├── platform.cmake
│   │   ├── targets.cmake
│   │   └── utilities.cmake
│   ├── idasdkConfig.cmake
│   └── idasdkConfigVersion.cmake
├── src
│   ├── common
│   │   ├── compat.h
│   │   ├── simd.h
│   │   ├── warn_off.h
│   │   └── warn_on.h
│   ├── deobf
│   │   ├── analysis
│   │   │   ├── arch_utils.cpp
│   │   │   ├── arch_utils.h
│   │   │   ├── ast.cpp
│   │   │   ├── ast.h
│   │   │   ├── ast_builder.cpp
│   │   │   ├── ast_builder.h
│   │   │   ├── cfg_analysis.cpp
│   │   │   ├── cfg_analysis.h
│   │   │   ├── chain_simplify.cpp
│   │   │   ├── chain_simplify.h
│   │   │   ├── expr_simplify.cpp
│   │   │   ├── expr_simplify.h
│   │   │   ├── mop_utils.h
│   │   │   ├── opaque_eval.cpp
│   │   │   ├── opaque_eval.h
│   │   │   ├── pattern_fuzzer.cpp
│   │   │   ├── pattern_fuzzer.h
│   │   │   ├── pattern_match.cpp
│   │   │   ├── pattern_match.h
│   │   │   ├── pattern_storage.cpp
│   │   │   ├── pattern_storage.h
│   │   │   ├── stack_tracker.cpp
│   │   │   ├── stack_tracker.h
│   │   │   ├── z3_solver.cpp
│   │   │   └── z3_solver.h
│   │   ├── deobf_main.cpp
│   │   ├── deobf_main.h
│   │   ├── deobf_types.h
│   │   ├── deobf_utils.cpp
│   │   ├── handlers
│   │   │   ├── block_merge.cpp
│   │   │   ├── block_merge.h
│   │   │   ├── bogus_cf.cpp
│   │   │   ├── bogus_cf.h
│   │   │   ├── const_decrypt.cpp
│   │   │   ├── const_decrypt.h
│   │   │   ├── ctree_const_fold.cpp
│   │   │   ├── ctree_const_fold.h
│   │   │   ├── ctree_indirect_call.cpp
│   │   │   ├── ctree_indirect_call.h
│   │   │   ├── ctree_string_decrypt.cpp
│   │   │   ├── ctree_string_decrypt.h
│   │   │   ├── ctree_switch_fold.cpp
│   │   │   ├── ctree_switch_fold.h
│   │   │   ├── deflatten.cpp
│   │   │   ├── deflatten.h
│   │   │   ├── global_const.cpp
│   │   │   ├── global_const.h
│   │   │   ├── hikari_wrapper.cpp
│   │   │   ├── hikari_wrapper.h
│   │   │   ├── identity_call.cpp
│   │   │   ├── identity_call.h
│   │   │   ├── indirect_branch.cpp
│   │   │   ├── indirect_branch.h
│   │   │   ├── indirect_call.cpp
│   │   │   ├── indirect_call.h
│   │   │   ├── jump_optimizer.cpp
│   │   │   ├── jump_optimizer.h
│   │   │   ├── mba_simplify.cpp
│   │   │   ├── mba_simplify.h
│   │   │   ├── objc_resolve.cpp
│   │   │   ├── objc_resolve.h
│   │   │   ├── peephole.cpp
│   │   │   ├── peephole.h
│   │   │   ├── ptr_resolve.cpp
│   │   │   ├── ptr_resolve.h
│   │   │   ├── savedregs.cpp
│   │   │   ├── savedregs.h
│   │   │   ├── stack_string.cpp
│   │   │   ├── stack_string.h
│   │   │   ├── string_decrypt.cpp
│   │   │   ├── string_decrypt.h
│   │   │   ├── unflattener_base.cpp
│   │   │   └── unflattener_base.h
│   │   └── rules
│   │       ├── jump_rules.cpp
│   │       ├── jump_rules.h
│   │       ├── pattern_rule.cpp
│   │       ├── pattern_rule.h
│   │       ├── rule_registry.cpp
│   │       ├── rule_registry.h
│   │       ├── rules_add.cpp
│   │       ├── rules_add.h
│   │       ├── rules_and.cpp
│   │       ├── rules_and.h
│   │       ├── rules_misc.cpp
│   │       ├── rules_misc.h
│   │       ├── rules_or.cpp
│   │       ├── rules_or.h
│   │       ├── rules_predicate.cpp
│   │       ├── rules_predicate.h
│   │       ├── rules_sub.cpp
│   │       ├── rules_sub.h
│   │       ├── rules_xor.cpp
│   │       └── rules_xor.h
│   └── plugin
│       ├── component_registry.cpp
│       ├── component_registry.h
│       └── deobf_plugin.cpp
├── test.c
└── tests
    ├── run_tests.sh
    ├── string_obfuscation
    │   └── test_strings.c
    ├── test_components.sh
    └── test_individual_functions.sh

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.10)
project(chernobog)

# Find IDA SDK
SET(IDASDK_VER "92" CACHE STRING "92")
SET(IDASDK $ENV{IDASDK})
MESSAGE("${PROJECT_NAME}")
MESSAGE("Using IDA SDK dir: ${IDASDK}")
MESSAGE("-------------------")

IF( NOT CMAKE_BUILD_TYPE )
	set(CMAKE_BUILD_TYPE Release CACHE STRING "Choose the type of build." FORCE)
ENDIF()
SET(CMAKE_SKIP_RPATH TRUE)

# ============================================================================
# Z3 Theorem Prover Integration
# ============================================================================

# Allow specifying custom Z3 location (used by CI/CD builds)
option(Z3_USE_CUSTOM "Use custom Z3 library instead of system" OFF)
set(Z3_CUSTOM_INCLUDE_DIR "" CACHE PATH "Custom Z3 include directory")
set(Z3_CUSTOM_LIBRARY "" CACHE FILEPATH "Custom Z3 library path")
set(Z3_CUSTOM_IMPLIB "" CACHE FILEPATH "Custom Z3 import library path (Windows only)")

if(Z3_USE_CUSTOM AND Z3_CUSTOM_INCLUDE_DIR AND Z3_CUSTOM_LIBRARY)
    message(STATUS "Using custom Z3: ${Z3_CUSTOM_LIBRARY}")
    set(Z3_FOUND TRUE)
    set(Z3_CUSTOM TRUE)

    # Create imported target for custom Z3
    add_library(z3_custom SHARED IMPORTED)
    if(WIN32)
        # On Windows, we need the import library (.lib) for linking
        if(Z3_CUSTOM_IMPLIB)
            set_target_properties(z3_custom PROPERTIES
                IMPORTED_LOCATION "${Z3_CUSTOM_LIBRARY}"
                IMPORTED_IMPLIB "${Z3_CUSTOM_IMPLIB}"
                INTERFACE_INCLUDE_DIRECTORIES "${Z3_CUSTOM_INCLUDE_DIR}"
            )
        else()
            # Try to find .lib next to .dll or in lib/ directory
            get_filename_component(Z3_LIB_DIR "${Z3_CUSTOM_LIBRARY}" DIRECTORY)
            get_filename_component(Z3_LIB_DIR_PARENT "${Z3_LIB_DIR}" DIRECTORY)
            find_file(Z3_IMPLIB_FOUND
                NAMES libz3.lib z3.lib
                PATHS "${Z3_LIB_DIR}" "${Z3_LIB_DIR_PARENT}/lib"
                NO_DEFAULT_PATH
            )
            if(Z3_IMPLIB_FOUND)
                message(STATUS "Found Z3 import library: ${Z3_IMPLIB_FOUND}")
                set_target_properties(z3_custom PROPERTIES
                    IMPORTED_LOCATION "${Z3_CUSTOM_LIBRARY}"
                    IMPORTED_IMPLIB "${Z3_IMPLIB_FOUND}"
                    INTERFACE_INCLUDE_DIRECTORIES "${Z3_CUSTOM_INCLUDE_DIR}"
                )
            else()
                message(FATAL_ERROR "Z3_CUSTOM_IMPLIB not set and could not find import library (.lib) for Z3")
            endif()
        endif()
    else()
        set_target_properties(z3_custom PROPERTIES
            IMPORTED_LOCATION "${Z3_CUSTOM_LIBRARY}"
            INTERFACE_INCLUDE_DIRECTORIES "${Z3_CUSTOM_INCLUDE_DIR}"
        )
    endif()
else()
    set(Z3_CUSTOM FALSE)

    # Check if Z3_ROOT is set and use it preferentially
    if(DEFINED ENV{Z3_ROOT})
        set(Z3_ROOT_DIR "$ENV{Z3_ROOT}")
        message(STATUS "Using Z3_ROOT: ${Z3_ROOT_DIR}")

        find_library(Z3_LIBRARY NAMES z3 libz3
            PATHS
                "${Z3_ROOT_DIR}/install/lib"
                "${Z3_ROOT_DIR}/lib"
                "${Z3_ROOT_DIR}/bin"
                "${Z3_ROOT_DIR}/build"
            NO_DEFAULT_PATH
        )
        find_path(Z3_INCLUDE_DIR z3++.h
            PATHS
                "${Z3_ROOT_DIR}/install/include"
                "${Z3_ROOT_DIR}/include"
                "${Z3_ROOT_DIR}/src/api/c++"
                "${Z3_ROOT_DIR}/src/api"
            NO_DEFAULT_PATH
        )
    endif()

    # Fall back to system search if not found via Z3_ROOT
    if(NOT Z3_LIBRARY OR NOT Z3_INCLUDE_DIR)
        find_package(Z3 CONFIG QUIET)
        if(NOT Z3_FOUND)
            find_library(Z3_LIBRARY NAMES z3 libz3
                PATHS
                    /usr/lib
                    /usr/lib/x86_64-linux-gnu
                    /usr/local/lib
                    /opt/homebrew/lib
            )
            find_path(Z3_INCLUDE_DIR z3++.h
                PATHS
                    /usr/include
                    /usr/local/include
                    /opt/homebrew/include
            )
        endif()
    endif()

    if(Z3_LIBRARY AND Z3_INCLUDE_DIR)
        set(Z3_FOUND TRUE)
        message(STATUS "Found Z3 library: ${Z3_LIBRARY}")
        message(STATUS "Found Z3 include: ${Z3_INCLUDE_DIR}")
    elseif(NOT Z3_FOUND)
        message(FATAL_ERROR "Z3 not found. Please install Z3 or set Z3_ROOT environment variable.")
    endif()
endif()

include(${CMAKE_CURRENT_LIST_DIR}/ida-cmake/bootstrap.cmake)
find_package(idasdk REQUIRED)

# Set plugin variables before including addons.cmake
ida_add_plugin(chernobog
  SOURCES
    # Plugin core
    src/plugin/deobf_plugin.cpp
    src/plugin/component_registry.cpp
    src/deobf/deobf_main.cpp
    src/deobf/deobf_utils.cpp

    # Analysis modules (existing)
    src/deobf/analysis/pattern_match.cpp
    src/deobf/analysis/expr_simplify.cpp
    src/deobf/analysis/cfg_analysis.cpp
    src/deobf/analysis/opaque_eval.cpp
    src/deobf/analysis/stack_tracker.cpp
    src/deobf/analysis/z3_solver.cpp
    src/deobf/analysis/arch_utils.cpp

    # NEW: AST-based pattern matching system
    src/deobf/analysis/ast.cpp
    src/deobf/analysis/ast_builder.cpp
    src/deobf/analysis/pattern_storage.cpp
    src/deobf/analysis/pattern_fuzzer.cpp
    src/deobf/analysis/chain_simplify.cpp

    # NEW: MBA rule system
    src/deobf/rules/pattern_rule.cpp
    src/deobf/rules/rule_registry.cpp
    src/deobf/rules/rules_add.cpp
    src/deobf/rules/rules_sub.cpp
    src/deobf/rules/rules_xor.cpp
    src/deobf/rules/rules_and.cpp
    src/deobf/rules/rules_or.cpp
    src/deobf/rules/rules_misc.cpp
    src/deobf/rules/jump_rules.cpp
    src/deobf/rules/rules_predicate.cpp

    # Handlers
    src/deobf/handlers/peephole.cpp
    src/deobf/handlers/jump_optimizer.cpp
    src/deobf/handlers/deflatten.cpp
    src/deobf/handlers/unflattener_base.cpp
    src/deobf/handlers/bogus_cf.cpp
    src/deobf/handlers/string_decrypt.cpp
    src/deobf/handlers/const_decrypt.cpp
    src/deobf/handlers/indirect_branch.cpp
    src/deobf/handlers/indirect_call.cpp
    src/deobf/handlers/block_merge.cpp
    src/deobf/handlers/mba_simplify.cpp
    src/deobf/handlers/identity_call.cpp
    src/deobf/handlers/stack_string.cpp
    src/deobf/handlers/hikari_wrapper.cpp
    src/deobf/handlers/savedregs.cpp
    src/deobf/handlers/objc_resolve.cpp
    src/deobf/handlers/global_const.cpp
    src/deobf/handlers/ptr_resolve.cpp
    src/deobf/handlers/ctree_const_fold.cpp
    src/deobf/handlers/ctree_switch_fold.cpp
    src/deobf/handlers/ctree_indirect_call.cpp
    src/deobf/handlers/ctree_string_decrypt.cpp
)

# Link Z3 library
if(Z3_FOUND)
    if(Z3_CUSTOM)
        # Use the custom imported target (for CI/CD builds)
        target_link_libraries(chernobog PRIVATE z3_custom)
    elseif(TARGET z3::libz3)
        # Use system Z3 via CMake package
        target_link_libraries(chernobog PRIVATE z3::libz3)
    else()
        # Use manually found Z3
        target_include_directories(chernobog PRIVATE ${Z3_INCLUDE_DIR})
        target_link_libraries(chernobog PRIVATE ${Z3_LIBRARY})
    endif()
endif()

```

`Makefile`:

```
# Convenience Makefile for Chernobog - Hikari Deobfuscator

BUILD_DIR = build
PLUGIN_NAME = chernobog
# IDA SDK cmake outputs to bin/plugins (or src/bin/plugins for GitHub SDK structure)
IDASDK_PLUGINS = $(IDASDK)/bin/plugins
IDASDK_PLUGINS_SRC = $(IDASDK)/src/bin/plugins

.PHONY: all clean configure build install

all: build

configure:
	@mkdir -p $(BUILD_DIR)
	@cd $(BUILD_DIR) && cmake .. -G Ninja

build: configure
	@cd $(BUILD_DIR) && ninja

clean:
	@rm -rf $(BUILD_DIR)

install: build
	@echo "Installing plugin..."
	@mkdir -p ~/.idapro/plugins
ifeq ($(shell uname -s),Darwin)
	@cp $(BUILD_DIR)/$(PLUGIN_NAME)64.dylib ~/.idapro/plugins/ 2>/dev/null || \
	 cp $(BUILD_DIR)/$(PLUGIN_NAME).dylib ~/.idapro/plugins/ 2>/dev/null || \
	 cp $(IDASDK_PLUGINS)/$(PLUGIN_NAME)64.dylib ~/.idapro/plugins/ 2>/dev/null || \
	 cp $(IDASDK_PLUGINS)/$(PLUGIN_NAME).dylib ~/.idapro/plugins/ 2>/dev/null || \
	 cp $(IDASDK_PLUGINS_SRC)/$(PLUGIN_NAME)64.dylib ~/.idapro/plugins/ 2>/dev/null || \
	 cp $(IDASDK_PLUGINS_SRC)/$(PLUGIN_NAME).dylib ~/.idapro/plugins/ 2>/dev/null || \
	 echo "Plugin not found - check build output"
	@echo "Signing plugin (macOS)..."
	@codesign -s - -f ~/.idapro/plugins/$(PLUGIN_NAME)*.dylib 2>/dev/null || true
else ifeq ($(shell uname -s),Linux)
	@cp $(BUILD_DIR)/$(PLUGIN_NAME)64.so ~/.idapro/plugins/ 2>/dev/null || \
	 cp $(BUILD_DIR)/$(PLUGIN_NAME).so ~/.idapro/plugins/ 2>/dev/null || \
	 cp $(IDASDK_PLUGINS)/$(PLUGIN_NAME)64.so ~/.idapro/plugins/ 2>/dev/null || \
	 cp $(IDASDK_PLUGINS)/$(PLUGIN_NAME).so ~/.idapro/plugins/ 2>/dev/null || \
	 cp $(IDASDK_PLUGINS_SRC)/$(PLUGIN_NAME)64.so ~/.idapro/plugins/ 2>/dev/null || \
	 cp $(IDASDK_PLUGINS_SRC)/$(PLUGIN_NAME).so ~/.idapro/plugins/ 2>/dev/null || \
	 echo "Plugin not found - check build output"
else
	@cp $(BUILD_DIR)/$(PLUGIN_NAME)64.dll ~/.idapro/plugins/ 2>/dev/null || \
	 cp $(BUILD_DIR)/$(PLUGIN_NAME).dll ~/.idapro/plugins/ 2>/dev/null || \
	 cp $(IDASDK_PLUGINS)/$(PLUGIN_NAME)64.dll ~/.idapro/plugins/ 2>/dev/null || \
	 cp $(IDASDK_PLUGINS)/$(PLUGIN_NAME).dll ~/.idapro/plugins/ 2>/dev/null || \
	 cp $(IDASDK_PLUGINS_SRC)/$(PLUGIN_NAME)64.dll ~/.idapro/plugins/ 2>/dev/null || \
	 cp $(IDASDK_PLUGINS_SRC)/$(PLUGIN_NAME).dll ~/.idapro/plugins/ 2>/dev/null || \
	 echo "Plugin not found - check build output"
endif
	@echo "Done!"

help:
	@echo "Chernobog - Hikari Deobfuscator Build System"
	@echo ""
	@echo "Targets:"
	@echo "  all       - Build the plugin (default)"
	@echo "  configure - Run CMake configuration"
	@echo "  build     - Build the plugin"
	@echo "  clean     - Remove build directory"
	@echo "  install   - Build and install to ~/.idapro/plugins"
	@echo ""
	@echo "Requirements:"
	@echo "  - IDA SDK (set IDASDK environment variable)"
	@echo "  - CMake 3.10+"
	@echo "  - Ninja build system"

```

`README.md`:

```md
<h1 align="center">chernobog</h1>

<img width="1536" height="597" alt="chernobog" src="hero.png" />

---

<h5 align="center">
chernobog is a Hex-Rays decompiler plugin that defeats Hikari LLVM obfuscation.<br/>
Where IDA shows tangled switch dispatchers, chernobog restores the original control flow.<br/>
Flattening, bogus branches, encrypted strings—all reversed automatically.<br/>
<br/>
Opaque predicates evaluated. Dead code eliminated. Constants decrypted in place.<br/>
Instruction substitutions simplified back to their obvious forms.<br/>
The obfuscation dissolves. The algorithm emerges.
</h5>

## Features

Chernobog automatically detects and reverses the following Hikari obfuscation techniques:

### Control Flow Obfuscation
- **Control Flow Flattening (CFF)** - Restores the original control flow graph using Z3 symbolic execution to solve state machines. Includes 7 specialized unflatteners:
  - `HikariUnflattener` - Hikari-style state machine patterns
  - `OLLVMUnflattener` - O-LLVM switch-based flattening
  - `FakeJumpUnflattener` - Opaque predicate branches (always-taken/never-taken)
  - `BadWhileLoopUnflattener` - Fake `while(1)` loops with guaranteed breaks
  - `JumpTableUnflattener` - Index-based jump table flattening
  - `SwitchCaseUnflattener` - Obfuscated switch statements
  - `GenericUnflattener` - Heuristic-based fallback for unknown patterns
- **Bogus Control Flow (BCF)** - Identifies and removes opaque predicates, dead branches, and unreachable code blocks
- **Basic Block Splitting** - Merges artificially split basic blocks back together
- **Indirect Branches** - Resolves computed branch targets with support for multiple encodings (direct, offset, XOR, combined)
- **Indirect Calls** - Resolves Hikari's `call(table[index] - offset)` pattern to direct calls

### Data Obfuscation
- **String Encryption** - Decrypts XOR-encrypted strings and annotates them in the disassembly
- **Constant Encryption** - Resolves encrypted constants (XOR patterns with global variables)
- **Stack String Construction** - Reconstructs strings built character-by-character on the stack
- **Global Constant Inlining** - Replaces loads from read-only globals with immediate values

### Code Transformation (90+ MBA Rules)
Mixed Boolean-Arithmetic (MBA) simplification using pattern matching with automatic fuzzing for commutative variants:

**Addition patterns:**
- `x - (~y + 1)` → `x + y` (two's complement)
- `(x | y) + (x & y)` → `x + y`
- `(x ^ y) + 2*(x & y)` → `x + y`
- `2*(x | y) - (x ^ y)` → `x + y`
- `~(~x + ~y) + 1` → `x + y`

**Subtraction patterns:**
- `x + ~y + 1` → `x - y`
- `~(~x + y)` → `x - y`
- `x + (-y)` → `x - y`

**XOR patterns:**
- `(x | y) - (x & y)` → `x ^ y`
- `(~x & y) | (x & ~y)` → `x ^ y`
- `(x + y) - 2*(x & y)` → `x ^ y`
- `(x | y) & (~x | ~y)` → `x ^ y`

**AND patterns:**
- `(x + y) - (x | y)` → `x & y`
- `~(~x | ~y)` → `x & y` (De Morgan)
- `x & (x | y)` → `x` (absorption)

**OR patterns:**
- `(x & y) + (x ^ y)` → `x | y`
- `~(~x & ~y)` → `x | y` (De Morgan)
- `x | (x & y)` → `x` (absorption)

**And many more...** (~90+ rules derived from Hacker's Delight, OLLVM patterns, and algebraic factorizations)

### Opaque Predicate Elimination
- **Jump Optimization** - Z3-based analysis for complex conditional simplification
- **Predicate Rules** - Pattern-based simplification for self-comparisons, tautologies, and identity patterns:
  - `setz x, x` → `1`, `setnz x, x` → `0`
  - `jb x, x` → never taken, `jae x, x` → always taken
  - `x*(x+1) % 2 == 0` → always true

### Function Call Obfuscation
- **Identity Function Calls** - Removes identity function wrappers used to hide call targets
- **Hikari Function Wrappers** - Unwraps indirect function calls through Hikari-generated wrapper functions
- **Register Demotion (savedregs)** - Reverses patterns where registers are demoted to stack variables

### Platform-Specific
- **Obfuscated Objective-C Method Calls** - Resolves obfuscated `objc_msgSend` calls on macOS/iOS binaries
- **Pointer Reference Resolution** - Handles ObjC class references through indirection tables

### Ctree-Level Optimizations
Applied after microcode optimization for additional cleanup:
- **Constant Folding** - Simplifies constant expressions in the decompiler output
- **Switch Folding** - Reconstructs switch statements from flattened control flow
- **Indirect Call Resolution** - Resolves remaining indirect calls in the Ctree
- **String Decryption** - Decrypts strings visible only at Ctree maturity

## Requirements

- IDA Pro 9.0+ with Hex-Rays decompiler
- CMake 3.10+
- Ninja build system
- IDA SDK (set `IDASDK` environment variable)
- **Z3 Theorem Prover** (set `Z3_ROOT` environment variable or install system-wide)

## Building

```bash
# Set your IDA SDK path
export IDASDK=/path/to/idasdk

# Set Z3 path (if not installed system-wide)
export Z3_ROOT=/path/to/z3

# Build the plugin
make build

# Or manually with CMake
mkdir build && cd build
cmake .. -G Ninja
ninja
```

## Installation

```bash
# Automatic installation to ~/.idapro/plugins
make install
```

Or manually copy the built plugin:
- macOS: `build/chernobog64.dylib` → `~/.idapro/plugins/`
- Linux: `build/chernobog64.so` → `~/.idapro/plugins/`
- Windows: `build/chernobog64.dll` → `%APPDATA%\Hex-Rays\IDA Pro\plugins\`

## Usage

### Quick Start

1. Open a Hikari-obfuscated binary in IDA Pro
2. Navigate to an obfuscated function and open it in the decompiler (F5)
3. Right-click in the pseudocode view and select **"Deobfuscate (Chernobog)"**
   - Or press `Ctrl+Shift+D`
4. The function will be reanalyzed with obfuscation removed

### Automatic Mode

Set the environment variable `CHERNOBOG_AUTO=1` to automatically deobfuscate functions when they are decompiled.

### Analyze Without Modifying

To see what obfuscation types are present without making changes:
1. Right-click and select **"Analyze obfuscation (Chernobog)"**
   - Or press `Ctrl+Shift+A`
2. Check the IDA output window for the analysis results

### Environment Variables

| Variable | Description |
|----------|-------------|
| `CHERNOBOG_AUTO=1` | Auto-deobfuscate on decompilation |
| `CHERNOBOG_VERBOSE=1` | Enable verbose logging |
| `CHERNOBOG_DEBUG=1` | Enable debug output to `/tmp/chernobog_debug.log` |
| `CHERNOBOG_RESET=1` | Clear decompiler cache on startup |

### Plugin Info

Press `Ctrl+Shift+H` to display plugin information and supported obfuscation types.

## Architecture

```
src/
├── plugin/
│   ├── deobf_plugin.cpp          # IDA plugin entry point & hexrays callbacks
│   └── component_registry.cpp    # Modular component registration system
│
├── deobf/
│   ├── deobf_main.cpp            # Main deobfuscation orchestration
│   ├── deobf_types.h             # Common types and enums
│   ├── deobf_utils.cpp           # Utility functions
│   │
│   ├── analysis/                 # Core analysis infrastructure
│   │   ├── z3_solver.cpp         # Z3 symbolic execution engine
│   │   ├── ast.cpp               # AST tree representation for patterns
│   │   ├── ast_builder.cpp       # AST construction helpers
│   │   ├── pattern_match.cpp     # Pattern detection utilities
│   │   ├── pattern_storage.cpp   # O(log n) pattern lookup
│   │   ├── pattern_fuzzer.cpp    # Commutative/associative variants
│   │   ├── chain_simplify.cpp    # XOR/AND/OR/ADD chain simplification
│   │   ├── expr_simplify.cpp     # Expression simplification
│   │   ├── cfg_analysis.cpp      # Control flow graph analysis
│   │   ├── opaque_eval.cpp       # Opaque predicate evaluation
│   │   ├── stack_tracker.cpp     # Virtual stack analysis
│   │   └── arch_utils.cpp        # Architecture-specific utilities
│   │
│   ├── rules/                    # MBA simplification rules
│   │   ├── pattern_rule.cpp      # Rule base class & macros
│   │   ├── rule_registry.cpp     # Central rule management
│   │   ├── rules_add.cpp         # 17 addition rules
│   │   ├── rules_sub.cpp         # 11 subtraction rules
│   │   ├── rules_xor.cpp         # 19 XOR rules
│   │   ├── rules_and.cpp         # 16 AND rules
│   │   ├── rules_or.cpp          # 15 OR rules
│   │   ├── rules_misc.cpp        # 20 misc rules (NEG, BNOT, MUL, etc.)
│   │   ├── rules_predicate.cpp   # ~30 predicate optimization rules
│   │   └── jump_rules.cpp        # ~10 jump optimization rules
│   │
│   └── handlers/                 # Deobfuscation handlers
│       ├── deflatten.cpp         # Z3-based control flow deflattening
│       ├── unflattener_base.cpp  # Unflattener framework (7 strategies)
│       ├── bogus_cf.cpp          # Bogus control flow removal
│       ├── mba_simplify.cpp      # MBA pattern matching integration
│       ├── peephole.cpp          # Peephole optimizers (7 optimizers)
│       ├── jump_optimizer.cpp    # Jump condition simplification
│       ├── string_decrypt.cpp    # String decryption (microcode)
│       ├── const_decrypt.cpp     # Constant decryption
│       ├── stack_string.cpp      # Stack string reconstruction
│       ├── global_const.cpp      # Global constant inlining
│       ├── indirect_branch.cpp   # Indirect branch resolution
│       ├── indirect_call.cpp     # Indirect call resolution (microcode)
│       ├── block_merge.cpp       # Basic block merging
│       ├── identity_call.cpp     # Identity function resolution
│       ├── hikari_wrapper.cpp    # Wrapper function resolution
│       ├── savedregs.cpp         # Register demotion reversal
│       ├── ptr_resolve.cpp       # Pointer reference resolution
│       ├── objc_resolve.cpp      # ObjC call resolution
│       ├── ctree_const_fold.cpp  # Ctree constant folding
│       ├── ctree_switch_fold.cpp # Ctree switch reconstruction
│       ├── ctree_indirect_call.cpp # Ctree indirect call resolution
│       └── ctree_string_decrypt.cpp # Ctree string decryption
│
├── common/
│   ├── warn_off.h                # Disable IDA SDK warnings
│   └── warn_on.h                 # Re-enable warnings
│
└── tests/
    ├── run_tests.sh              # Comprehensive test suite
    ├── test_components.sh        # Component-level tests
    └── test_individual_functions.sh  # Function-specific tests
```

## How It Works

Chernobog operates as a Hex-Rays optimizer callback, integrating directly into IDA's microcode optimization pipeline. The system uses a sophisticated multi-phase approach:

### Phase 1: Analysis (MMAT_PREOPTIMIZED)
- **Pattern Detection**: Identifies obfuscation patterns (flattening, MBA, encrypted strings, etc.)
- **Z3 Symbolic Execution**: Analyzes state machines and solves for control flow transitions
- **State Storage**: Results stored using addresses (not block indices) for stability across maturity levels

### Phase 2: Transformation (MMAT_LOCOPT)
- **CFG Reconstruction**: Applies control flow changes when the graph is stable
- **MBA Simplification**: Pattern-based simplification with O(log n) lookup and automatic fuzzing
- **Peephole Optimization**: Local optimizations (constant folding, dead code elimination)

### Phase 3: Ctree Cleanup (CMAT_FINAL)
- **High-Level Optimization**: Additional cleanup at the decompiler AST level
- **String Annotation**: Decrypted strings annotated in the output
- **Switch Reconstruction**: Flattened control flow converted back to switch statements

### Key Technical Features

#### Z3 Integration
The Z3 theorem prover is used for:
- Solving control flow state machines
- Evaluating opaque predicates (always-true/false detection)
- Verifying expression equivalence for complex patterns
- Analyzing jump conditions

#### Two-Phase Deobfuscation
Many handlers use a two-phase analyze/apply approach to ensure stability:
1. Analysis phase captures transitions using state values and addresses
2. Application phase verifies and applies changes when CFG is stable

#### Pattern Fuzzing
The pattern matcher automatically generates equivalent variants:
- Commutative: `x + y == y + x`
- Add/Sub equivalence: `x + neg(y) == x - y`
- Configurable depth and variant limits

## Testing

The test suite validates all components:

```bash
# Run full test suite
./tests/run_tests.sh

# Verbose output
./tests/run_tests.sh --verbose

# Quick tests only
./tests/run_tests.sh --quick

# Test specific component
./tests/run_tests.sh --component mba
./tests/run_tests.sh --component unflattener
./tests/run_tests.sh --component predicate
```

Test coverage includes:
- AST system and pattern matching
- All 90+ MBA simplification rules
- Predicate rules and jump optimization
- Chain simplifier
- 7 peephole optimizers
- 7 unflattener strategies
- Full decompilation integration

## Limitations

- Requires functions to be decompilable by Hex-Rays
- Custom or heavily modified Hikari variants may not be fully supported
- Some obfuscation patterns may require manual cleanup after automated processing
- Anti-analysis tricks (anti-debug, VM detection) are not handled
- Z3 analysis has configurable timeouts; extremely complex state machines may not solve

## Contributing

Contributions are welcome! Areas that could use improvement:

- Support for additional obfuscation modes
- Performance optimizations for large functions
- Support for other LLVM-based obfuscators (additional OLLVM variants, etc.)
- Additional MBA simplification rules
- New unflattener strategies for novel patterns

When adding new MBA rules, use the `DEFINE_MBA_RULE` macro:
```cpp
DEFINE_MBA_RULE(MyRule, "my_rule",
    sub(x_0(), neg(x_1())),  // pattern: x - (-y)
    add(x_0(), x_1())        // replacement: x + y
);
```

## License

This project is provided for educational and research purposes.

## Acknowledgments

- The IDA Pro and Hex-Rays teams for their excellent reverse engineering tools
- The Z3 theorem prover team for their powerful SMT solver
- The Hikari project for documenting their obfuscation techniques
- The D810 project for foundational deobfuscation research
- The reverse engineering community for their research on deobfuscation

```

`ida-cmake/README.md`:

```md
# IDA CMake Build System

This directory contains the CMake build system for IDA SDK plugins and extensions. It provides a modern, cross-platform way to build IDA plugins using CMake.

## Files

- `bootstrap.cmake` - Entry point that sets up paths and detects SDK structure
- `idasdkConfig.cmake` - Main configuration file that creates IDA SDK targets
- `idasdkConfigVersion.cmake` - Version compatibility checking
- `cmake/platform.cmake` - Platform and OS detection
- `cmake/compiler.cmake` - Compiler configuration and warning settings
- `cmake/targets.cmake` - Functions for creating plugins, loaders, and proc modules
- `cmake/utilities.cmake` - Utility functions for SDK version detection

## Usage

In your CMakeLists.txt:

```cmake
cmake_minimum_required(VERSION 3.10)
project(my_plugin)

# Include the bootstrap to set up IDA SDK
include(${CMAKE_CURRENT_LIST_DIR}/ida-cmake/bootstrap.cmake)
find_package(idasdk REQUIRED)

# Create your plugin
ida_add_plugin(my_plugin
  SOURCES
    src/plugin.cpp
)
```

## Requirements

- CMake 3.10 or later (3.27 recommended)
- IDA SDK (set via IDASDK environment variable)
- Supported compilers: MSVC (Windows), Clang (macOS), GCC/Clang (Linux)

## Environment Variables

- `IDASDK` - Path to IDA SDK directory (required)
- `IDABIN` - Path to IDA installation binary directory (optional, defaults to $IDASDK/bin)

## Origin

This is a customized version of the ida-cmake build system, adapted specifically for this project.

```

`ida-cmake/bootstrap.cmake`:

```cmake
# IDA SDK CMake Bootstrap
# This file sets up the CMAKE_PREFIX_PATH and MODULE_PATH to find the IDASDK package
# Usage: include(${CMAKE_CURRENT_LIST_DIR}/ida-cmake/bootstrap.cmake)

if(NOT DEFINED ENV{IDASDK})
    message(FATAL_ERROR "IDASDK environment variable not set. Please set it to your IDA SDK directory.")
endif()

# Validate IDASDK path exists and contains expected files
if(NOT EXISTS "$ENV{IDASDK}")
    message(FATAL_ERROR "IDASDK path does not exist: $ENV{IDASDK}")
endif()

# Auto-detect SDK structure: GitHub clone has files under src/, zip distribution at root
set(_IDASDK_ACTUAL "$ENV{IDASDK}")
if(NOT EXISTS "${_IDASDK_ACTUAL}/include/pro.h")
    # Check if this is a GitHub clone with src/ subdirectory
    if(EXISTS "${_IDASDK_ACTUAL}/src/include/pro.h")
        set(_IDASDK_ACTUAL "${_IDASDK_ACTUAL}/src")
        message(STATUS "Detected GitHub SDK structure, using: ${_IDASDK_ACTUAL}")
    else()
        message(FATAL_ERROR "Invalid IDASDK directory (missing include/pro.h): $ENV{IDASDK}")
    endif()
endif()

# Override IDASDK environment variable for this CMake run with the adjusted path
set(ENV{IDASDK} "${_IDASDK_ACTUAL}")
# Also set the CMake variable so idasdkConfig.cmake uses the adjusted path
set(IDASDK "${_IDASDK_ACTUAL}")

# Add ida-cmake to the package search path
list(APPEND CMAKE_PREFIX_PATH ${CMAKE_CURRENT_LIST_DIR})
list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_LIST_DIR}/cmake)

# Set default minimum CMake version if not already set
if(CMAKE_MINIMUM_REQUIRED_VERSION VERSION_LESS 3.27)
    cmake_minimum_required(VERSION 3.27)
endif()

```

`ida-cmake/cmake/compiler.cmake`:

```cmake
# compiler.cmake - Compiler configuration for IDA SDK

# C++ Standard
if(NOT CMAKE_CXX_STANDARD)
    set(CMAKE_CXX_STANDARD 17)
endif()
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Create interface library for IDA SDK compiler settings
# This  approach allows targets to opt-in to these settings
add_library(ida_compiler_settings INTERFACE)

# Common compile definitions
# Note: Platform-specific defines (IDAPROPLAT) are handled by the interface libraries
target_compile_definitions(ida_compiler_settings INTERFACE
    __IDP__
    __EA64__=1  # Always use EA64 (64-bit addressing)
    $<$<CONFIG:Debug>:_DEBUG>
    $<$<CONFIG:Release>:NDEBUG>
)

# Platform-specific compiler configurations
if(MSVC)
    # MSVC specific flags
    target_compile_options(ida_compiler_settings INTERFACE
        /W3             # Warning level 3
        /MP             # Multi-processor compilation
        /GF             # String pooling
        /Gy             # Function-level linking
        /EHsc           # C++ exceptions
        /permissive-    # Standards conformance
        /Zc:__cplusplus # Report correct __cplusplus
        /utf-8          # UTF-8 source and execution character sets
        # Configuration-specific flags
        $<$<CONFIG:Debug>:/Od>          # No optimization
        $<$<CONFIG:Debug>:/RTC1>        # Runtime checks
        $<$<CONFIG:Debug>:/Zi>          # Debug info
        $<$<CONFIG:Release>:/O2>        # Optimize for speed
        $<$<CONFIG:Release>:/GL>        # Whole program optimization
        $<$<CONFIG:Release>:/Oi>        # Intrinsic functions
    )

    # Linker flags
    target_link_options(ida_compiler_settings INTERFACE
        $<$<CONFIG:Release>:/LTCG>      # Link-time code generation
        $<$<CONFIG:Release>:/OPT:REF>   # Remove unreferenced code
        $<$<CONFIG:Release>:/OPT:ICF>   # Remove duplicate code
    )

    # Create a separate interface library for warning suppression
    add_library(ida_warnings_disabled INTERFACE)
    target_compile_options(ida_warnings_disabled INTERFACE
        /wd4244     # conversion from 'type1' to 'type2', possible loss of data
        /wd4267     # conversion from 'size_t' to 'type', possible loss of data
        /wd4996     # deprecated functions
        /wd4018     # signed/unsigned mismatch
        /wd4146     # unary minus operator applied to unsigned type
    )

elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" OR CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
    # GCC/Clang specific flags
    target_compile_options(ida_compiler_settings INTERFACE
        -Wall
        -Wextra
        -fPIC
        -ffunction-sections
        -fdata-sections
        -pthread
        # Configuration-specific flags
        $<$<CONFIG:Debug>:-O0>
        $<$<CONFIG:Debug>:-g3>
        $<$<CONFIG:Release>:-O3>
        # $<$<CONFIG:Release>:-flto>  # LTO disabled due to linker issues
    )

    # Linker flags
    target_link_options(ida_compiler_settings INTERFACE
        -Wl,--gc-sections
        # $<$<CONFIG:Release>:-flto>  # LTO disabled due to linker issues
    )

    # Create a separate interface library for warning suppression
    add_library(ida_warnings_disabled INTERFACE)
    target_compile_options(ida_warnings_disabled INTERFACE
        -Wno-unused-parameter
        -Wno-sign-compare
        -Wno-deprecated-declarations
        -Wno-format
    )

    # macOS specific
    if(APPLE)
        target_compile_options(ida_compiler_settings INTERFACE
            -stdlib=libc++
            -mmacosx-version-min=${CMAKE_OSX_DEPLOYMENT_TARGET}
        )
        target_link_options(ida_compiler_settings INTERFACE
            -stdlib=libc++
            -mmacosx-version-min=${CMAKE_OSX_DEPLOYMENT_TARGET}
        )
    endif()
endif()

# Compiler settings are now applied through target linking
# Targets link to ida_compiler_settings via idasdk::plugin, idasdk::loader, etc.

# Function to disable IDA SDK warnings for a target
# Apply warning suppression flags directly
function(ida_disable_warnings TARGET)
    if(MSVC)
        target_compile_options(${TARGET} PRIVATE
            /wd4244     # conversion from 'type1' to 'type2', possible loss of data
            /wd4267     # conversion from 'size_t' to 'type', possible loss of data
            /wd4996     # deprecated functions
            /wd4018     # signed/unsigned mismatch
            /wd4146     # unary minus operator applied to unsigned type
            /wd4800 /wd4251 /wd4005 /wd4099 /wd4065
        )
    else()
        target_compile_options(${TARGET} PRIVATE
            -Wno-unused-parameter
            -Wno-sign-compare
            -Wno-deprecated-declarations
            -Wno-format
            -Wno-parentheses
            -Wno-unused-variable
            -Wno-unused-function
            -Wno-switch
        )
    endif()
endfunction()

# Function to set strict warnings for a target
function(ida_enable_strict_warnings TARGET)
    if(MSVC)
        target_compile_options(${TARGET} PRIVATE /W4 /WX)
    else()
        target_compile_options(${TARGET} PRIVATE -Wall -Wextra -Werror -pedantic)
    endif()
endfunction()

```

`ida-cmake/cmake/platform.cmake`:

```cmake
# platform.cmake - Platform and OS detection for IDA SDK

# Detect target platform
if(CMAKE_SYSTEM_NAME STREQUAL "Windows")
    set(IDA_PLATFORM "WIN32")
    set(IDA_PLATFORM_NAME "win")
    set(IDAPROPLAT "__NT__")

    # Detect architecture
    if(CMAKE_SYSTEM_PROCESSOR MATCHES "ARM64|aarch64")
        set(IDA_ARCH "arm64")
    elseif(CMAKE_SIZEOF_VOID_P EQUAL 8)
        set(IDA_ARCH "x64")
    else()
        set(IDA_ARCH "x86")
    endif()

    # Compiler detection for Windows
    if(CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
        set(IDA_COMPILER "vc")
        set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")
    elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" AND MINGW)
        set(IDA_COMPILER "mingw")
    else()
        message(WARNING "Unsupported Windows compiler: ${CMAKE_CXX_COMPILER_ID}")
        set(IDA_COMPILER "unknown")
    endif()

elseif(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
    set(IDA_PLATFORM "MACOS")
    set(IDA_PLATFORM_NAME "mac")
    set(IDAPROPLAT "__MAC__")

    # Compiler detection for macOS
    if(CMAKE_CXX_COMPILER_ID STREQUAL "AppleClang" OR CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
        set(IDA_COMPILER "clang")
    else()
        message(WARNING "Unexpected macOS compiler: ${CMAKE_CXX_COMPILER_ID}")
        set(IDA_COMPILER "clang")  # Default to clang
    endif()

    # Set deployment target
    if(NOT CMAKE_OSX_DEPLOYMENT_TARGET)
        set(CMAKE_OSX_DEPLOYMENT_TARGET "10.15")
    endif()

    # Handle universal binary builds (multiple architectures)
    if(CMAKE_OSX_ARCHITECTURES)
        list(LENGTH CMAKE_OSX_ARCHITECTURES _arch_count)
        if(_arch_count GREATER 1)
            # Universal binary build - need to merge libraries with lipo
            set(IDA_UNIVERSAL_BINARY TRUE)
            message(STATUS "Building macOS universal binary for architectures: ${CMAKE_OSX_ARCHITECTURES}")

            # We'll set IDA_ARCH to a placeholder since we have multiple
            # The actual library paths will be handled in idasdkConfig.cmake
            set(IDA_ARCH "universal")
        else()
            # Single architecture from CMAKE_OSX_ARCHITECTURES
            set(IDA_UNIVERSAL_BINARY FALSE)
            list(GET CMAKE_OSX_ARCHITECTURES 0 _cmake_arch)
            if(_cmake_arch STREQUAL "arm64")
                set(IDA_ARCH "arm64")
            elseif(_cmake_arch MATCHES "x86_64|i386")
                set(IDA_ARCH "x64")
            else()
                message(FATAL_ERROR "Unsupported macOS architecture: ${_cmake_arch}")
            endif()
        endif()
    else()
        # Detect architecture from host system
        set(IDA_UNIVERSAL_BINARY FALSE)
        if(CMAKE_SYSTEM_PROCESSOR MATCHES "arm64|aarch64")
            set(IDA_ARCH "arm64")
        else()
            set(IDA_ARCH "x64")
        endif()
    endif()

elseif(CMAKE_SYSTEM_NAME STREQUAL "Linux")
    set(IDA_PLATFORM "LINUX")
    set(IDA_PLATFORM_NAME "linux")
    set(IDAPROPLAT "__LINUX__")

    # Detect architecture
    if(CMAKE_SYSTEM_PROCESSOR MATCHES "aarch64|arm64")
        set(IDA_ARCH "arm64")
    else()
        set(IDA_ARCH "x64")
    endif()

    # Compiler detection for Linux
    if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
        set(IDA_COMPILER "gcc")
    elseif(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
        set(IDA_COMPILER "clang")
    else()
        message(WARNING "Unsupported Linux compiler: ${CMAKE_CXX_COMPILER_ID}")
        set(IDA_COMPILER "gcc")  # Default to gcc
    endif()

else()
    message(FATAL_ERROR "Unsupported platform: ${CMAKE_SYSTEM_NAME}")
endif()

# Construct library directory (always EA64)
set(IDA_EA_SIZE "64")
set(IDA_LIB_SUFFIX "${IDA_ARCH}_${IDA_PLATFORM_NAME}_${IDA_COMPILER}_64")
set(IDA_LIB_DIR "${IDASDK}/lib/${IDA_LIB_SUFFIX}")

# Platform-specific library names (using consistent platform detection)
if(CMAKE_SYSTEM_NAME STREQUAL "Windows")
    set(IDA_LIB_NAME "ida.lib")
    set(IDA_PRO_LIB_NAME "pro.lib")
    set(IDALIB_NAME "idalib.lib")
    set(IDA_SHARED_EXT ".dll")
    set(IDA_STATIC_EXT ".lib")
elseif(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
    set(IDA_LIB_NAME "libida.dylib")
    set(IDA_PRO_LIB_NAME "libpro.dylib")
    set(IDALIB_NAME "libidalib.dylib")
    set(IDA_SHARED_EXT ".dylib")
    set(IDA_STATIC_EXT ".a")
elseif(CMAKE_SYSTEM_NAME STREQUAL "Linux")
    set(IDA_LIB_NAME "libida.so")
    set(IDA_PRO_LIB_NAME "libpro.so")
    set(IDALIB_NAME "libidalib.so")
    set(IDA_SHARED_EXT ".so")
    set(IDA_STATIC_EXT ".a")
endif()

# Output directories for different addon types
set(IDA_PLUGIN_DIR "${IDABIN}/plugins")
set(IDA_LOADER_DIR "${IDABIN}/loaders")
set(IDA_PROCMOD_DIR "${IDABIN}/procs")
set(IDA_TIL_DIR "${IDABIN}/til")
set(IDA_SIG_DIR "${IDABIN}/sig")
set(IDA_IDS_DIR "${IDABIN}/ids")

# Interface library for platform-specific settings
# This allows targets to inherit platform settings cleanly
add_library(ida_platform_settings INTERFACE)

# Platform-specific compile definitions using generator expressions
target_compile_definitions(ida_platform_settings INTERFACE
    ${IDAPROPLAT}  # Platform macro (__NT__, __MAC__, or __LINUX__)
    $<$<PLATFORM_ID:Windows>:WIN32 _WINDOWS>
)

# Export platform variables for backward compatibility
# Variables are already in the correct scope when included

```

`ida-cmake/cmake/targets.cmake`:

```cmake
# targets.cmake - Target creation functions for IDA SDK addons

# Create interface library for common addon properties
# This provides a way to propagate common settings to all addon targets
if(NOT TARGET ida_addon_base)
    add_library(ida_addon_base INTERFACE)

    # Common properties for all IDA addons
    target_compile_features(ida_addon_base INTERFACE cxx_std_17)

    # Position-independent code (required for shared libraries)
    set_target_properties(ida_addon_base PROPERTIES
        INTERFACE_POSITION_INDEPENDENT_CODE ON
    )

    # Link to common settings (these are inherited by all addons)
    # Note: ida_platform_settings and ida_compiler_settings are linked via IDASDK::* targets
endif()

# Internal function to handle common addon creation logic
function(_ida_create_addon_internal NAME TYPE SDK_TARGET OUTPUT_DIR)
    cmake_parse_arguments(ARG
        ""
        "OUTPUT_NAME;DEBUG_ARGS;DEBUG_PROGRAM;DEBUG_WORKING_DIR"
        "SOURCES;LIBRARIES;INCLUDES;DEFINES"
        ${ARGN}
    )

    # Create the addon as a shared library
    add_library(${NAME} SHARED ${ARG_SOURCES})

    # Link to base configuration and IDA SDK (order matters for property inheritance)
    target_link_libraries(${NAME}
        PRIVATE
            ida_addon_base    # Common addon properties
            ${SDK_TARGET}     # IDA SDK target (includes platform/compiler settings)
    )

    # Add user-specified libraries (after SDK to allow overrides)
    if(ARG_LIBRARIES)
        target_link_libraries(${NAME} PRIVATE ${ARG_LIBRARIES})
    endif()

    # Set target-specific properties using CMake patterns
    set_target_properties(${NAME} PROPERTIES
        # Output configuration
        RUNTIME_OUTPUT_DIRECTORY "$<1:${OUTPUT_DIR}>"
        LIBRARY_OUTPUT_DIRECTORY "$<1:${OUTPUT_DIR}>"
    )

    # Unix-specific: Remove "lib" prefix from addon names (macOS and Linux)
    if(APPLE OR UNIX)
        set_target_properties(${NAME} PROPERTIES PREFIX "")
    endif()

    # Windows-specific: Set subsystem to WINDOWS for addon DLLs
    # This prevents console windows from appearing when loaded by IDA
    if(WIN32)
        target_link_options(${NAME} PRIVATE /SUBSYSTEM:WINDOWS)
    endif()

    # Set output name if specified (can't use generator expression in property name)
    if(ARG_OUTPUT_NAME)
        set_target_properties(${NAME} PROPERTIES OUTPUT_NAME ${ARG_OUTPUT_NAME})
    endif()

    # Add user-specified includes (PRIVATE to not leak to dependents)
    if(ARG_INCLUDES)
        target_include_directories(${NAME} PRIVATE ${ARG_INCLUDES})
    endif()

    # Add user-specified defines (PRIVATE to not leak to dependents)
    if(ARG_DEFINES)
        target_compile_definitions(${NAME} PRIVATE ${ARG_DEFINES})
    endif()

    # CMake automatically sets the correct suffix for SHARED libraries based on platform
    # (.dll on Windows, .dylib on macOS, .so on Linux)

    # Debug configuration
    if(ARG_DEBUG_ARGS OR ARG_DEBUG_PROGRAM OR ARG_DEBUG_WORKING_DIR)
        # Default values - platform-specific IDA executable
        if(WIN32)
            set(DEBUG_PROG "${IDABIN}/ida.exe")
        else()
            set(DEBUG_PROG "${IDABIN}/ida")
        endif()
        if(ARG_DEBUG_PROGRAM)
            set(DEBUG_PROG ${ARG_DEBUG_PROGRAM})
        endif()

        set(DEBUG_DIR "${CMAKE_CURRENT_SOURCE_DIR}")
        if(ARG_DEBUG_WORKING_DIR)
            set(DEBUG_DIR ${ARG_DEBUG_WORKING_DIR})
        endif()

        # Visual Studio configuration
        if(MSVC)
            # Convert paths to native format for Visual Studio
            file(TO_NATIVE_PATH "${DEBUG_PROG}" DEBUG_PROG_NATIVE)
            file(TO_NATIVE_PATH "${DEBUG_DIR}" DEBUG_DIR_NATIVE)

            set_target_properties(${NAME} PROPERTIES
                VS_DEBUGGER_COMMAND "${DEBUG_PROG_NATIVE}"
                VS_DEBUGGER_COMMAND_ARGUMENTS "${ARG_DEBUG_ARGS}"
                VS_DEBUGGER_WORKING_DIRECTORY "${DEBUG_DIR_NATIVE}"
            )
        endif()

        # Generate VS Code config
        _ida_generate_vscode_config(${NAME} "${DEBUG_PROG}" "${ARG_DEBUG_ARGS}" "${DEBUG_DIR}")
    endif()

    # Disable IDA warnings by default
    ida_disable_warnings(${NAME})
endfunction()

# Helper function to generate VS Code launch.json
function(_ida_generate_vscode_config TARGET PROGRAM ARGS WORKING_DIR)
    set(VSCODE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/.vscode")
    if(NOT EXISTS "${VSCODE_DIR}/launch.json")
        file(MAKE_DIRECTORY ${VSCODE_DIR})

        # Escape paths for JSON
        string(REPLACE "\\" "\\\\" PROGRAM_JSON "${PROGRAM}")
        string(REPLACE "\\" "\\\\" WORKING_DIR_JSON "${WORKING_DIR}")
        string(REPLACE "\\" "\\\\" BUILD_DIR_JSON "${CMAKE_BINARY_DIR}")

        # Parse arguments
        set(ARGS_JSON "")
        if(ARGS)
            string(REPLACE " " ";" ARG_LIST "${ARGS}")
            foreach(ARG ${ARG_LIST})
                if(ARGS_JSON)
                    string(APPEND ARGS_JSON ", ")
                endif()
                string(APPEND ARGS_JSON "\"${ARG}\"")
            endforeach()
        endif()

        # Platform-specific debugger settings
        if(WIN32)
            set(DEBUGGER_TYPE "cppvsdbg")
            set(PLATFORM_CONFIG "\"console\": \"integratedTerminal\"")
        elseif(APPLE)
            set(DEBUGGER_TYPE "cppdbg")
            set(PLATFORM_CONFIG "\"MIMode\": \"lldb\", \"externalConsole\": false")
        else()
            set(DEBUGGER_TYPE "cppdbg")
            set(PLATFORM_CONFIG "\"MIMode\": \"gdb\", \"externalConsole\": false")
        endif()

        # Write launch.json
        file(WRITE "${VSCODE_DIR}/launch.json"
"{
    \"version\": \"0.2.0\",
    \"configurations\": [{
        \"name\": \"Debug ${TARGET}\",
        \"type\": \"${DEBUGGER_TYPE}\",
        \"request\": \"launch\",
        \"program\": \"${PROGRAM_JSON}\",
        \"args\": [${ARGS_JSON}],
        \"stopAtEntry\": false,
        \"cwd\": \"${WORKING_DIR_JSON}\",
        \"environment\": [],
        ${PLATFORM_CONFIG}
    }]
}")

        # Write tasks.json
        file(WRITE "${VSCODE_DIR}/tasks.json"
"{
    \"version\": \"2.0.0\",
    \"tasks\": [{
        \"label\": \"Build ${TARGET}\",
        \"type\": \"shell\",
        \"command\": \"cmake\",
        \"args\": [\"--build\", \"${BUILD_DIR_JSON}\", \"--target\", \"${TARGET}\", \"--config\", \"Release\"],
        \"group\": { \"kind\": \"build\", \"isDefault\": true },
        \"problemMatcher\": \"$msCompile\"
    }]
}")
    endif()
endfunction()

# Public function to add an IDA plugin
function(ida_add_plugin NAME)
    # Parse arguments including METADATA_JSON, TYPE, and standard arguments
    cmake_parse_arguments(PLUGIN
        ""
        "TYPE;METADATA_JSON;OUTPUT_NAME;DEBUG_ARGS;DEBUG_PROGRAM;DEBUG_WORKING_DIR"
        "SOURCES;LIBRARIES;INCLUDES;DEFINES;QT_COMPONENTS"
        ${ARGN}
    )

    # Handle Qt plugins (TYPE QT)
    if(PLUGIN_TYPE STREQUAL "QT")
        if(NOT PLUGIN_QT_COMPONENTS)
            message(FATAL_ERROR "${NAME}: TYPE QT specified but QT_COMPONENTS not provided")
        endif()

        # Try to find Qt6 with requested components
        find_package(Qt6 QUIET COMPONENTS ${PLUGIN_QT_COMPONENTS})

        if(NOT Qt6_FOUND)
            message(STATUS "${NAME}: Qt6 not found, skipping Qt plugin (run: cmake --build . --target build_qt)")
            return()
        endif()

        message(STATUS "${NAME}: Building Qt plugin with components: ${PLUGIN_QT_COMPONENTS}")

        # Add Qt libraries to link list
        foreach(component ${PLUGIN_QT_COMPONENTS})
            list(APPEND PLUGIN_LIBRARIES Qt6::${component})
        endforeach()

        # Qt AUTOMOC/RCC/UIC will be enabled as target properties after target creation
    elseif(PLUGIN_TYPE AND NOT PLUGIN_TYPE STREQUAL "QT")
        message(FATAL_ERROR "${NAME}: Invalid TYPE '${PLUGIN_TYPE}'. Supported types: QT")
    endif()

    # Determine output directory based on metadata presence
    set(OUTPUT_DIR "${IDA_PLUGIN_DIR}")

    if(PLUGIN_METADATA_JSON)
        # Metadata deployment: plugin goes into subfolder
        set(OUTPUT_DIR "${IDA_PLUGIN_DIR}/${NAME}")

        # Handle absolute vs relative path
        if(NOT IS_ABSOLUTE "${PLUGIN_METADATA_JSON}")
            set(metadata_source "${CMAKE_CURRENT_SOURCE_DIR}/${PLUGIN_METADATA_JSON}")
        else()
            set(metadata_source "${PLUGIN_METADATA_JSON}")
        endif()

        # Check if file exists, generate template if missing
        if(NOT EXISTS "${metadata_source}")
            # Generate comprehensive template with all fields per Hex-Rays spec
            file(WRITE "${metadata_source}" "{\n  \"IDAMetadataDescriptorVersion\": 1,\n  \"plugin\": {\n    \"name\": \"${NAME}\",\n    \"entryPoint\": \"${NAME}\",\n    \"categories\": [\"collaboration-and-productivity\"],\n    \"logoPath\": \"logo.png\",\n    \"idaVersions\": \">=9.0\",\n    \"description\": \"TODO: Add a brief description of your plugin's functionality\",\n    \"version\": \"1.0.0\"\n  }\n}\n")
            message(STATUS "${NAME}: generated template metadata at ${metadata_source}")
        endif()

        message(STATUS "${NAME}: deploying with metadata to ${OUTPUT_DIR}")
    endif()

    # Reconstruct argument list without METADATA_JSON for internal function
    set(INTERNAL_ARGS "")
    if(PLUGIN_SOURCES)
        list(APPEND INTERNAL_ARGS SOURCES ${PLUGIN_SOURCES})
    endif()
    if(PLUGIN_LIBRARIES)
        list(APPEND INTERNAL_ARGS LIBRARIES ${PLUGIN_LIBRARIES})
    endif()
    if(PLUGIN_INCLUDES)
        list(APPEND INTERNAL_ARGS INCLUDES ${PLUGIN_INCLUDES})
    endif()
    if(PLUGIN_DEFINES)
        list(APPEND INTERNAL_ARGS DEFINES ${PLUGIN_DEFINES})
    endif()
    if(PLUGIN_OUTPUT_NAME)
        list(APPEND INTERNAL_ARGS OUTPUT_NAME ${PLUGIN_OUTPUT_NAME})
    endif()
    if(PLUGIN_DEBUG_ARGS)
        list(APPEND INTERNAL_ARGS DEBUG_ARGS ${PLUGIN_DEBUG_ARGS})
    endif()
    if(PLUGIN_DEBUG_PROGRAM)
        list(APPEND INTERNAL_ARGS DEBUG_PROGRAM ${PLUGIN_DEBUG_PROGRAM})
    endif()
    if(PLUGIN_DEBUG_WORKING_DIR)
        list(APPEND INTERNAL_ARGS DEBUG_WORKING_DIR ${PLUGIN_DEBUG_WORKING_DIR})
    endif()

    # Create the plugin using internal function
    _ida_create_addon_internal(${NAME} "plugin" idasdk::plugin "${OUTPUT_DIR}" ${INTERNAL_ARGS})

    # Enable Qt's AUTOMOC, AUTORCC, AUTOUIC for Qt plugins
    if(PLUGIN_TYPE STREQUAL "QT")
        set_target_properties(${NAME} PROPERTIES
            AUTOMOC ON
            AUTORCC ON
            AUTOUIC ON
        )
    endif()

    # Post-build: Copy JSON file and flatten multi-config if metadata enabled
    if(PLUGIN_METADATA_JSON)
        # Flatten multi-config generators (remove Debug/Release subdirs)
        foreach(config Debug Release RelWithDebInfo MinSizeRel)
            string(TOUPPER ${config} config_upper)
            set_target_properties(${NAME} PROPERTIES
                LIBRARY_OUTPUT_DIRECTORY_${config_upper} "${OUTPUT_DIR}"
                RUNTIME_OUTPUT_DIRECTORY_${config_upper} "${OUTPUT_DIR}"
            )
        endforeach()

        # Copy JSON file to deployment location
        add_custom_command(TARGET ${NAME} POST_BUILD
            COMMAND ${CMAKE_COMMAND} -E copy_if_different
                "${metadata_source}"
                "${OUTPUT_DIR}/ida-plugin.json"
            COMMENT "Copying metadata for ${NAME}"
        )
    endif()
endfunction()

# Public function to add an IDA loader
function(ida_add_loader NAME)
    _ida_create_addon_internal(${NAME} "loader" idasdk::loader "${IDA_LOADER_DIR}" ${ARGN})
endfunction()

# Public function to add an IDA processor module
function(ida_add_procmod NAME)
    _ida_create_addon_internal(${NAME} "procmod" idasdk::procmod "${IDA_PROCMOD_DIR}" ${ARGN})
endfunction()

# Function to create an idalib target (executable, shared library, or static library)
function(ida_add_idalib NAME)
    cmake_parse_arguments(ARG
        ""
        "TYPE;OUTPUT_NAME;DEBUG_ARGS;DEBUG_WORKING_DIR"
        "SOURCES;LIBRARIES;INCLUDES;DEFINES"
        ${ARGN}
    )

    # Default to EXECUTABLE for backward compatibility
    if(NOT ARG_TYPE)
        set(ARG_TYPE "EXECUTABLE")
    endif()

    # Validate TYPE
    if(NOT ARG_TYPE MATCHES "^(EXECUTABLE|SHARED|STATIC)$")
        message(FATAL_ERROR "ida_add_idalib: Invalid TYPE '${ARG_TYPE}'. Must be EXECUTABLE, SHARED, or STATIC")
    endif()

    # Create target based on TYPE
    if(ARG_TYPE STREQUAL "EXECUTABLE")
        add_executable(${NAME} ${ARG_SOURCES})
    elseif(ARG_TYPE STREQUAL "SHARED")
        add_library(${NAME} SHARED ${ARG_SOURCES})
    else()  # STATIC
        add_library(${NAME} STATIC ${ARG_SOURCES})
    endif()

    # Link to base configuration and idalib (order matters for property inheritance)
    target_link_libraries(${NAME}
        PRIVATE
            ida_addon_base      # Common properties (even though it's an exe, shares config)
            idasdk::idalib      # idalib target (includes platform/compiler settings)
    )

    # Add user-specified libraries (after SDK to allow overrides)
    if(ARG_LIBRARIES)
        target_link_libraries(${NAME} PRIVATE ${ARG_LIBRARIES})
    endif()

    # Set output name if specified
    if(ARG_OUTPUT_NAME)
        set_target_properties(${NAME} PROPERTIES OUTPUT_NAME ${ARG_OUTPUT_NAME})
    endif()

    # Add user-specified includes (PRIVATE to not leak to dependents)
    if(ARG_INCLUDES)
        target_include_directories(${NAME} PRIVATE ${ARG_INCLUDES})
    endif()

    # Add user-specified defines (PRIVATE to not leak to dependents)
    if(ARG_DEFINES)
        target_compile_definitions(${NAME} PRIVATE ${ARG_DEFINES})
    endif()

    # Debug configuration (only for executables)
    if(ARG_TYPE STREQUAL "EXECUTABLE" AND (ARG_DEBUG_ARGS OR ARG_DEBUG_WORKING_DIR))
        set(DEBUG_DIR "${CMAKE_CURRENT_SOURCE_DIR}")
        if(ARG_DEBUG_WORKING_DIR)
            set(DEBUG_DIR ${ARG_DEBUG_WORKING_DIR})
        endif()

        # Visual Studio
        if(MSVC)
            # Convert path to native format for Visual Studio
            file(TO_NATIVE_PATH "${DEBUG_DIR}" DEBUG_DIR_NATIVE)

            set_target_properties(${NAME} PROPERTIES
                VS_DEBUGGER_COMMAND_ARGUMENTS "${ARG_DEBUG_ARGS}"
                VS_DEBUGGER_WORKING_DIRECTORY "${DEBUG_DIR_NATIVE}"
            )
        endif()

        # Generate VS Code launch.json for executable
        _ida_generate_vscode_config(${NAME} "$<TARGET_FILE:${NAME}>" "${ARG_DEBUG_ARGS}" "${DEBUG_DIR}")
    endif()

    # Disable IDA warnings by default
    ida_disable_warnings(${NAME})
endfunction()


```

`ida-cmake/cmake/utilities.cmake`:

```cmake
# utilities.cmake - Utility functions for IDA SDK

# REMOVED: ida_bundle_addon - bundling/packaging is unnecessary complexity

# REMOVED: ida_find_installation - we don't need to locate IDA paths

# Function to check IDA SDK version
function(ida_check_sdk_version)
    if(EXISTS "${IDASDK}/include/pro.h")
        file(STRINGS "${IDASDK}/include/pro.h" IDA_VERSION_LINE REGEX "^#define IDA_SDK_VERSION")
        if(IDA_VERSION_LINE)
            string(REGEX REPLACE ".*IDA_SDK_VERSION[ \\t]+([0-9]+)" "\\1" IDA_SDK_VERSION_NUM "${IDA_VERSION_LINE}")
            math(EXPR IDA_SDK_MAJOR "${IDA_SDK_VERSION_NUM} / 100")
            math(EXPR IDA_SDK_MINOR "${IDA_SDK_VERSION_NUM} % 100")
            set(IDA_SDK_VERSION "${IDA_SDK_MAJOR}.${IDA_SDK_MINOR}" CACHE STRING "IDA SDK Version")
            set(IDA_SDK_VERSION "${IDA_SDK_VERSION}" PARENT_SCOPE)
            message(STATUS "Detected IDA SDK version: ${IDA_SDK_VERSION}")
        else()
            message(WARNING "Could not detect IDA SDK version from pro.h")
        endif()
    else()
        message(WARNING "IDA SDK pro.h not found at: ${IDASDK}/include/pro.h")
    endif()
endfunction()

# Function to validate environment
function(ida_validate_environment)
    # Check IDASDK
    if(NOT EXISTS "${IDASDK}")
        message(FATAL_ERROR "IDASDK directory does not exist: ${IDASDK}")
    endif()

    if(NOT EXISTS "${IDASDK}/include/pro.h")
        message(FATAL_ERROR "Invalid IDASDK directory (missing ${IDASDK}/include/pro.h)")
    endif()

    # Check IDABIN if specified
    if(DEFINED IDABIN)
        if(NOT EXISTS "${IDABIN}")
            message(WARNING "IDABIN directory does not exist: ${IDABIN}")
        endif()
    endif()

    # Check for required SDK libraries
    if(NOT EXISTS "${IDA_LIB_DIR}")
        message(FATAL_ERROR "IDA SDK library directory does not exist: ${IDA_LIB_DIR}")
    endif()

    if(NOT EXISTS "${IDA_LIB_DIR}/${IDA_LIB_NAME}")
        message(FATAL_ERROR "IDA SDK library not found: ${IDA_LIB_DIR}/${IDA_LIB_NAME}")
    endif()

    message(STATUS "IDA SDK validation passed")
    message(STATUS "  IDASDK: ${IDASDK}")
    message(STATUS "  IDABIN: ${IDABIN}")
    message(STATUS "  Platform: ${IDA_PLATFORM}")
    message(STATUS "  Architecture: ${IDA_ARCH}")
    message(STATUS "  Compiler: ${IDA_COMPILER}")
    message(STATUS "  EA Size: ${IDA_EA_SIZE}")
endfunction()

# Function to print configuration summary
function(ida_print_config)
    message(STATUS "")
    message(STATUS "IDA SDK Configuration Summary:")
    message(STATUS "==============================")
    message(STATUS "  SDK Path: ${IDASDK}")
    message(STATUS "  BIN Path: ${IDABIN}")
    message(STATUS "  Platform: ${IDA_PLATFORM_NAME}")
    message(STATUS "  Architecture: ${IDA_ARCH}")
    message(STATUS "  Compiler: ${IDA_COMPILER}")
    message(STATUS "  EA Size: ${IDA_EA_SIZE}-bit")
    message(STATUS "  Library Directory: ${IDA_LIB_DIR}")
    message(STATUS "  Plugin Directory: ${IDA_PLUGIN_DIR}")
    message(STATUS "  Loader Directory: ${IDA_LOADER_DIR}")
    message(STATUS "  ProcMod Directory: ${IDA_PROCMOD_DIR}")
    if(IDA_SDK_VERSION)
        message(STATUS "  SDK Version: ${IDA_SDK_VERSION}")
    endif()
    message(STATUS "==============================")
    message(STATUS "")
endfunction()

```

`ida-cmake/idasdkConfig.cmake`:

```cmake
# idasdkConfig.cmake
# CMake package configuration for IDA SDK

# Set IDASDK directory
if(NOT DEFINED IDASDK)
    if(DEFINED ENV{IDASDK})
        set(IDASDK "$ENV{IDASDK}")
    else()
        message(FATAL_ERROR "IDASDK environment variable not set")
    endif()
endif()

# Set IDABIN directory (default to $IDASDK/bin if not specified)
if(NOT DEFINED IDABIN)
    if(DEFINED ENV{IDABIN})
        set(IDABIN "$ENV{IDABIN}")
    else()
        set(IDABIN "${IDASDK}/bin")
    endif()
endif()

# Normalize paths
file(TO_CMAKE_PATH "${IDASDK}" IDASDK)
file(TO_CMAKE_PATH "${IDABIN}" IDABIN)

# Export ida-cmake directory for use by templates and projects
set(IDA_CMAKE_DIR "${CMAKE_CURRENT_LIST_DIR}" CACHE PATH "Path to ida-cmake directory")

# Always use EA64 (64-bit addressing)

# Include our CMake modules
include(${CMAKE_CURRENT_LIST_DIR}/cmake/platform.cmake)
include(${CMAKE_CURRENT_LIST_DIR}/cmake/compiler.cmake)
include(${CMAKE_CURRENT_LIST_DIR}/cmake/targets.cmake)
include(${CMAKE_CURRENT_LIST_DIR}/cmake/utilities.cmake)

# Handle macOS universal binary library merging
if(IDA_UNIVERSAL_BINARY)
    # Map CMake architectures to IDA SDK architecture names
    set(_ida_arch_map_arm64 "arm64")
    set(_ida_arch_map_x86_64 "x64")

    # Create universal libraries for each IDA library
    foreach(_lib_basename "ida" "idalib")
        set(_arch_libs "")
        foreach(_arch ${CMAKE_OSX_ARCHITECTURES})
            set(_ida_arch "${_ida_arch_map_${_arch}}")
            if(NOT _ida_arch)
                message(FATAL_ERROR "Unsupported architecture for universal binary: ${_arch}")
            endif()

            set(_lib_dir "${IDASDK}/lib/${_ida_arch}_${IDA_PLATFORM_NAME}_${IDA_COMPILER}_64")
            set(_lib_path "${_lib_dir}/lib${_lib_basename}.dylib")

            if(NOT EXISTS "${_lib_path}")
                message(WARNING "Library not found for ${_arch}: ${_lib_path}")
            else()
                list(APPEND _arch_libs "${_lib_path}")
            endif()
        endforeach()

        if(_arch_libs)
            # Create output directory for merged libraries
            set(_merged_lib_dir "${CMAKE_BINARY_DIR}/ida-universal-libs")
            file(MAKE_DIRECTORY "${_merged_lib_dir}")

            set(_merged_lib "${_merged_lib_dir}/lib${_lib_basename}.dylib")

            # Use lipo to create universal library
            execute_process(
                COMMAND lipo -create ${_arch_libs} -output "${_merged_lib}"
                RESULT_VARIABLE _lipo_result
                ERROR_VARIABLE _lipo_error
            )

            if(_lipo_result EQUAL 0)
                message(STATUS "Created universal ${_lib_basename} library: ${_merged_lib}")
                # Store the merged library path
                set(IDA_${_lib_basename}_UNIVERSAL_LIB "${_merged_lib}" CACHE INTERNAL "")
            else()
                message(FATAL_ERROR "Failed to create universal ${_lib_basename} library: ${_lipo_error}")
            endif()
        endif()
    endforeach()

    # Set library paths to use the merged universal libraries
    set(IDA_LIB_PATH "${IDA_ida_UNIVERSAL_LIB}")
    set(IDALIB_PATH "${IDA_idalib_UNIVERSAL_LIB}")
else()
    # Single architecture build - use standard library paths
    set(IDA_LIB_DIR "${IDASDK}/lib/${IDA_LIB_SUFFIX}")
    set(IDA_LIB_PATH "${IDA_LIB_DIR}/${IDA_LIB_NAME}")
    set(IDALIB_PATH "${IDA_LIB_DIR}/${IDALIB_NAME}")
endif()

# Create interface targets
if(NOT TARGET idasdk::plugin)
    add_library(idasdk::plugin INTERFACE IMPORTED)
    set_target_properties(idasdk::plugin PROPERTIES
        INTERFACE_INCLUDE_DIRECTORIES "${IDASDK}/include"
        INTERFACE_COMPILE_DEFINITIONS "__IDP__"
    )

    # Always use EA64
    target_compile_definitions(idasdk::plugin INTERFACE __EA64__)

    # Link to platform and compiler settings
    target_link_libraries(idasdk::plugin INTERFACE
        ida_platform_settings
        ida_compiler_settings
        "${IDA_LIB_PATH}")
endif()

if(NOT TARGET idasdk::loader)
    add_library(idasdk::loader INTERFACE IMPORTED)
    set_target_properties(idasdk::loader PROPERTIES
        INTERFACE_INCLUDE_DIRECTORIES "${IDASDK}/include;${IDASDK}/ldr"
        INTERFACE_COMPILE_DEFINITIONS "__LOADER__"
    )

    # Loaders inherit all settings from plugins
    target_link_libraries(idasdk::loader INTERFACE idasdk::plugin)
endif()

if(NOT TARGET idasdk::procmod)
    add_library(idasdk::procmod INTERFACE IMPORTED)
    set_target_properties(idasdk::procmod PROPERTIES
        INTERFACE_INCLUDE_DIRECTORIES "${IDASDK}/include;${IDASDK}/module"
        INTERFACE_COMPILE_DEFINITIONS "__IDP__"
    )

    # Processor modules inherit all settings from plugins
    target_link_libraries(idasdk::procmod INTERFACE idasdk::plugin)
endif()

# IDALib support
if(NOT TARGET idasdk::idalib)
    add_library(idasdk::idalib INTERFACE IMPORTED)
    set_target_properties(idasdk::idalib PROPERTIES
        INTERFACE_INCLUDE_DIRECTORIES "${IDASDK}/include"
        INTERFACE_COMPILE_DEFINITIONS "IDALIB_IMPL"
    )

    # Link to platform and compiler settings, plus BOTH idalib and ida libraries
    # Note: idalib.lib requires ida.lib for some symbols
    target_link_libraries(idasdk::idalib INTERFACE
        ida_platform_settings
        ida_compiler_settings
        "${IDALIB_PATH}"
        "${IDA_LIB_PATH}")
endif()

# Detect SDK version
ida_check_sdk_version()

# Export package variables
set(idasdk_FOUND TRUE)
if(NOT DEFINED IDA_SDK_VERSION)
    set(idasdk_VERSION "unknown")
else()
    set(idasdk_VERSION "${IDA_SDK_VERSION}")
endif()
set(idasdk_INCLUDE_DIRS "${IDASDK}/include")
set(idasdk_LIBRARY_DIRS "${IDASDK}/lib")

```

`ida-cmake/idasdkConfigVersion.cmake`:

```cmake
# IDASDKConfigVersion.cmake
# Version compatibility checking for IDASDK package

set(PACKAGE_VERSION "9.2.0")

if(PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION)
    set(PACKAGE_VERSION_COMPATIBLE FALSE)
else()
    set(PACKAGE_VERSION_COMPATIBLE TRUE)
    if(PACKAGE_FIND_VERSION STREQUAL PACKAGE_VERSION)
        set(PACKAGE_VERSION_EXACT TRUE)
    endif()
endif()

```

`src/common/compat.h`:

```h
// Platform compatibility layer for cross-platform builds
#ifndef CHERNOBOG_COMPAT_H
#define CHERNOBOG_COMPAT_H

#ifdef _WIN32
    // Windows
    #include <io.h>
    #include <fcntl.h>
    #include <intrin.h>
    
    // Map POSIX file I/O to Windows equivalents
    #define open _open
    #define write _write
    #define close _close
    #define O_WRONLY _O_WRONLY
    #define O_CREAT _O_CREAT
    #define O_APPEND _O_APPEND
    #define O_TRUNC _O_TRUNC
    
    // Portable popcount - MSVC uses __popcnt
    inline int portable_popcount(uint32_t val)
    {
        return (int)__popcnt(val);
    }
    
    // MSVC doesn't support __attribute__((constructor))
    // We use a different mechanism for global init on Windows
    #define ATTRIBUTE_CONSTRUCTOR
    
#else
    // Unix (Linux/macOS)
    #include <unistd.h>
    #include <fcntl.h>
    
    // Portable popcount - GCC/Clang use __builtin_popcount
    inline int portable_popcount(uint32_t val)
    {
        return __builtin_popcount(val);
    }
    
    #define ATTRIBUTE_CONSTRUCTOR __attribute__((constructor))
#endif

#endif // CHERNOBOG_COMPAT_H

```

`src/common/simd.h`:

```h
// Portable SIMD utilities with alignment helpers
// Supports SSE2/SSE4.2, AVX2, NEON with graceful fallback
#ifndef CHERNOBOG_SIMD_H
#define CHERNOBOG_SIMD_H

#include <cstdint>
#include <cstddef>
#include <cstring>
#include <type_traits>
#include <utility>
#include <algorithm>
#include <new>
#include <string>

//--------------------------------------------------------------------------
// Platform detection and SIMD capability
//--------------------------------------------------------------------------
#if defined(__x86_64__) || defined(_M_X64) || defined(__i386__) || defined(_M_IX86)
    #define CHERNOBOG_X86 1
    #if defined(__SSE2__) || defined(_M_X64) || (defined(_M_IX86_FP) && _M_IX86_FP >= 2)
        #define CHERNOBOG_SSE2 1
        #include <emmintrin.h>
    #endif
    #if defined(__SSE4_2__) || defined(__AVX__)
        #define CHERNOBOG_SSE42 1
        #include <nmmintrin.h>
    #endif
    #if defined(__AVX2__)
        #define CHERNOBOG_AVX2 1
        #include <immintrin.h>
    #endif
#elif defined(__aarch64__) || defined(_M_ARM64)
    #define CHERNOBOG_ARM64 1
    #define CHERNOBOG_NEON 1
    #include <arm_neon.h>
#elif defined(__arm__) && defined(__ARM_NEON)
    #define CHERNOBOG_ARM32 1
    #define CHERNOBOG_NEON 1
    #include <arm_neon.h>
#endif

//--------------------------------------------------------------------------
// MSVC intrinsics header - must be included early for all bit operations
//--------------------------------------------------------------------------
#ifdef _MSC_VER
    #include <intrin.h>
    #pragma intrinsic(_BitScanForward, _BitScanReverse)
    #if defined(_M_X64)
        #pragma intrinsic(_BitScanForward64, _BitScanReverse64)
        #pragma intrinsic(__popcnt64)
    #endif
    #pragma intrinsic(__popcnt)
#endif

// Force inline macro
#ifdef _MSC_VER
    #define SIMD_FORCE_INLINE __forceinline
    #define SIMD_LIKELY(x) (x)
    #define SIMD_UNLIKELY(x) (x)
#else
    #define SIMD_FORCE_INLINE inline __attribute__((always_inline))
    #define SIMD_LIKELY(x) __builtin_expect(!!(x), 1)
    #define SIMD_UNLIKELY(x) __builtin_expect(!!(x), 0)
#endif

// Alignment specifier
#ifdef _MSC_VER
    #define SIMD_ALIGN(n) __declspec(align(n))
#else
    #define SIMD_ALIGN(n) __attribute__((aligned(n)))
#endif

// Prefetch hints
#ifdef _MSC_VER
    #define SIMD_PREFETCH_READ(addr) _mm_prefetch((const char*)(addr), _MM_HINT_T0)
    #define SIMD_PREFETCH_WRITE(addr) _mm_prefetch((const char*)(addr), _MM_HINT_T0)
#elif defined(__GNUC__) || defined(__clang__)
    #define SIMD_PREFETCH_READ(addr) __builtin_prefetch((addr), 0, 3)
    #define SIMD_PREFETCH_WRITE(addr) __builtin_prefetch((addr), 1, 3)
#else
    #define SIMD_PREFETCH_READ(addr) ((void)0)
    #define SIMD_PREFETCH_WRITE(addr) ((void)0)
#endif

namespace chernobog {
namespace simd {

//--------------------------------------------------------------------------
// Alignment utilities
//--------------------------------------------------------------------------

// Check if pointer is aligned to N bytes
template<size_t N>
SIMD_FORCE_INLINE bool is_aligned(const void* ptr)
{
    static_assert((N & (N - 1)) == 0, "N must be power of 2");
    return (reinterpret_cast<uintptr_t>(ptr) & (N - 1)) == 0;
}

// Align pointer up to N bytes
template<size_t N>
SIMD_FORCE_INLINE void* align_up(void* ptr)
{
    static_assert((N & (N - 1)) == 0, "N must be power of 2");
    return reinterpret_cast<void*>(
        (reinterpret_cast<uintptr_t>(ptr) + (N - 1)) & ~(N - 1));
}

// Align pointer down to N bytes
template<size_t N>
SIMD_FORCE_INLINE void* align_down(void* ptr)
{
    static_assert((N & (N - 1)) == 0, "N must be power of 2");
    return reinterpret_cast<void*>(
        reinterpret_cast<uintptr_t>(ptr) & ~(N - 1));
}

// Alignment constants
constexpr size_t CACHE_LINE_SIZE = 64;
constexpr size_t SIMD_ALIGNMENT = 
#if defined(CHERNOBOG_AVX2)
    32
#elif defined(CHERNOBOG_SSE2) || defined(CHERNOBOG_NEON)
    16
#else
    8
#endif
;

//--------------------------------------------------------------------------
// Fast memory comparison (SIMD accelerated)
//--------------------------------------------------------------------------

// Compare two memory blocks for equality (optimized for small sizes)
SIMD_FORCE_INLINE bool mem_eq(const void* a, const void* b, size_t n)
{
    const uint8_t* pa = static_cast<const uint8_t*>(a);
    const uint8_t* pb = static_cast<const uint8_t*>(b);

    // Fast path for common small sizes
    switch ( n ) {
        case 0: return true;
        case 1: return *pa == *pb;
        case 2: return *reinterpret_cast<const uint16_t*>(pa) == 
                       *reinterpret_cast<const uint16_t*>(pb);
        case 4: return *reinterpret_cast<const uint32_t*>(pa) == 
                       *reinterpret_cast<const uint32_t*>(pb);
        case 8: return *reinterpret_cast<const uint64_t*>(pa) == 
                       *reinterpret_cast<const uint64_t*>(pb);
    }

#if defined(CHERNOBOG_AVX2)
    // AVX2: 32 bytes at a time
    while ( n >= 32 ) {
        __m256i va = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(pa));
        __m256i vb = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(pb));
        __m256i cmp = _mm256_cmpeq_epi8(va, vb);
        if ( _mm256_movemask_epi8(cmp) != -1 ) return false;
        pa += 32; pb += 32; n -= 32;
    }
#endif

#if defined(CHERNOBOG_SSE2)
    // SSE2: 16 bytes at a time
    while ( n >= 16 ) {
        __m128i va = _mm_loadu_si128(reinterpret_cast<const __m128i*>(pa));
        __m128i vb = _mm_loadu_si128(reinterpret_cast<const __m128i*>(pb));
        __m128i cmp = _mm_cmpeq_epi8(va, vb);
        if ( _mm_movemask_epi8(cmp) != 0xFFFF ) return false;
        pa += 16; pb += 16; n -= 16;
    }
#elif defined(CHERNOBOG_NEON)
    // NEON: 16 bytes at a time
    while ( n >= 16 ) {
        uint8x16_t va = vld1q_u8(pa);
        uint8x16_t vb = vld1q_u8(pb);
        uint8x16_t cmp = vceqq_u8(va, vb);
        // Check if all bytes match
        uint64x2_t cmp64 = vreinterpretq_u64_u8(cmp);
        if ( vgetq_lane_u64(cmp64, 0) != ~0ULL ||
            vgetq_lane_u64(cmp64, 1) != ~0ULL ) return false;
        pa += 16; pb += 16; n -= 16;
    }
#endif

    // Handle remaining bytes
    while ( n >= 8 ) {
        if ( *reinterpret_cast<const uint64_t*>(pa) !=
            *reinterpret_cast<const uint64_t*>(pb) ) return false;
        pa += 8; pb += 8; n -= 8;
    }
    while ( n > 0 ) {
        if ( *pa++ != *pb++ ) return false;
        --n;
    }
    return true;
}

//--------------------------------------------------------------------------
// Fast hash computation (for hash tables) - SIMD ACCELERATED
//--------------------------------------------------------------------------

// FNV-1a hash constants
constexpr uint64_t FNV_OFFSET_BASIS = 14695981039346656037ULL;
constexpr uint64_t FNV_PRIME = 1099511628211ULL;

// xxHash-style constants for SIMD hashing
constexpr uint64_t XXH_PRIME64_1 = 0x9E3779B185EBCA87ULL;
constexpr uint64_t XXH_PRIME64_2 = 0xC2B2AE3D27D4EB4FULL;
constexpr uint64_t XXH_PRIME64_3 = 0x165667B19E3779F9ULL;
constexpr uint64_t XXH_PRIME64_4 = 0x85EBCA77C2B2AE63ULL;
constexpr uint64_t XXH_PRIME64_5 = 0x27D4EB2F165667C5ULL;

// Rotate left (portable)
SIMD_FORCE_INLINE uint64_t rotl64(uint64_t x, int r)
{
    return (x << r) | (x >> (64 - r));
}

// Mix function for hash finalization
SIMD_FORCE_INLINE uint64_t avalanche64(uint64_t h)
{
    h ^= h >> 33;
    h *= XXH_PRIME64_2;
    h ^= h >> 29;
    h *= XXH_PRIME64_3;
    h ^= h >> 32;
    return h;
}

// Fast hash for small data - SIMD accelerated for larger inputs
SIMD_FORCE_INLINE uint64_t hash_bytes(const void* data, size_t len)
{
    const uint8_t* p = static_cast<const uint8_t*>(data);
    uint64_t h;

    // For very small inputs (common case), use simple FNV-1a
    if ( SIMD_LIKELY(len < 32) ) {
        h = FNV_OFFSET_BASIS;
        while ( len >= 8 ) {
            uint64_t k = *reinterpret_cast<const uint64_t*>(p);
            h ^= k;
            h *= FNV_PRIME;
            p += 8;
            len -= 8;
        }
        while ( len > 0 ) {
            h ^= *p++;
            h *= FNV_PRIME;
            --len;
        }
        return h;
    }

#if defined(CHERNOBOG_AVX2)
    // AVX2: Process 64 bytes at a time using parallel lanes
    if ( len >= 64 ) {
        __m256i acc1 = _mm256_set1_epi64x(XXH_PRIME64_1);
        __m256i acc2 = _mm256_set1_epi64x(XXH_PRIME64_2);
        const __m256i prime2 = _mm256_set1_epi64x(XXH_PRIME64_2);
        const __m256i prime3 = _mm256_set1_epi64x(XXH_PRIME64_3);

        while ( len >= 64 ) {
            __m256i data1 = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(p));
            __m256i data2 = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(p + 32));

            // Mixing step: multiply-accumulate
            acc1 = _mm256_add_epi64(acc1, _mm256_mul_epu32(data1, prime2));
            acc2 = _mm256_add_epi64(acc2, _mm256_mul_epu32(data2, prime2));

            // Rotate and mix
            acc1 = _mm256_xor_si256(acc1, _mm256_srli_epi64(data1, 33));
            acc2 = _mm256_xor_si256(acc2, _mm256_srli_epi64(data2, 33));

            p += 64;
            len -= 64;
        }

        // Combine lanes
        alignas(32) uint64_t lanes[8];
        _mm256_store_si256(reinterpret_cast<__m256i*>(lanes), acc1);
        _mm256_store_si256(reinterpret_cast<__m256i*>(lanes + 4), acc2);

        h = XXH_PRIME64_5;
        for ( int i = 0; i < 8; ++i ) {
            h ^= rotl64(lanes[i] * XXH_PRIME64_2, 31) * XXH_PRIME64_1;
            h = rotl64(h, 27) * XXH_PRIME64_1 + XXH_PRIME64_4;
        }
    } else {
        h = XXH_PRIME64_5;
    }
#elif defined(CHERNOBOG_NEON)
    // NEON: Process 32 bytes at a time
    if ( len >= 32 ) {
        uint64x2_t acc1 = vdupq_n_u64(XXH_PRIME64_1);
        uint64x2_t acc2 = vdupq_n_u64(XXH_PRIME64_2);

        while ( len >= 32 ) {
            uint64x2_t data1 = vld1q_u64(reinterpret_cast<const uint64_t*>(p));
            uint64x2_t data2 = vld1q_u64(reinterpret_cast<const uint64_t*>(p + 16));

            // Mixing: add with multiply low 32 bits
            uint32x4_t d1_32 = vreinterpretq_u32_u64(data1);
            uint32x4_t d2_32 = vreinterpretq_u32_u64(data2);
            acc1 = vaddq_u64(acc1, vmull_u32(vget_low_u32(d1_32), vdup_n_u32(XXH_PRIME64_2 & 0xFFFFFFFF)));
            acc2 = vaddq_u64(acc2, vmull_u32(vget_low_u32(d2_32), vdup_n_u32(XXH_PRIME64_2 & 0xFFFFFFFF)));

            // XOR with shifted data
            acc1 = veorq_u64(acc1, vshrq_n_u64(data1, 33));
            acc2 = veorq_u64(acc2, vshrq_n_u64(data2, 33));

            p += 32;
            len -= 32;
        }

        // Combine lanes
        uint64_t lanes[4];
        vst1q_u64(lanes, acc1);
        vst1q_u64(lanes + 2, acc2);

        h = XXH_PRIME64_5;
        for ( int i = 0; i < 4; ++i ) {
            h ^= rotl64(lanes[i] * XXH_PRIME64_2, 31) * XXH_PRIME64_1;
            h = rotl64(h, 27) * XXH_PRIME64_1 + XXH_PRIME64_4;
        }
    } else {
        h = XXH_PRIME64_5;
    }
#else
    h = XXH_PRIME64_5;
#endif

    // Process remaining 32-byte chunks (scalar)
    h += len;
    while ( len >= 32 ) {
        uint64_t k1 = *reinterpret_cast<const uint64_t*>(p);
        uint64_t k2 = *reinterpret_cast<const uint64_t*>(p + 8);
        uint64_t k3 = *reinterpret_cast<const uint64_t*>(p + 16);
        uint64_t k4 = *reinterpret_cast<const uint64_t*>(p + 24);

        h ^= rotl64(k1 * XXH_PRIME64_2, 31) * XXH_PRIME64_1;
        h = rotl64(h, 27) * XXH_PRIME64_1 + XXH_PRIME64_4;
        h ^= rotl64(k2 * XXH_PRIME64_2, 31) * XXH_PRIME64_1;
        h = rotl64(h, 27) * XXH_PRIME64_1 + XXH_PRIME64_4;
        h ^= rotl64(k3 * XXH_PRIME64_2, 31) * XXH_PRIME64_1;
        h = rotl64(h, 27) * XXH_PRIME64_1 + XXH_PRIME64_4;
        h ^= rotl64(k4 * XXH_PRIME64_2, 31) * XXH_PRIME64_1;
        h = rotl64(h, 27) * XXH_PRIME64_1 + XXH_PRIME64_4;

        p += 32;
        len -= 32;
    }

    // Process remaining 8-byte chunks
    while ( len >= 8 ) {
        uint64_t k = *reinterpret_cast<const uint64_t*>(p);
        h ^= rotl64(k * XXH_PRIME64_2, 31) * XXH_PRIME64_1;
        h = rotl64(h, 27) * XXH_PRIME64_1 + XXH_PRIME64_4;
        p += 8;
        len -= 8;
    }

    // Process remaining 4-byte chunk
    if ( len >= 4 ) {
        h ^= static_cast<uint64_t>(*reinterpret_cast<const uint32_t*>(p)) * XXH_PRIME64_1;
        h = rotl64(h, 23) * XXH_PRIME64_2 + XXH_PRIME64_3;
        p += 4;
        len -= 4;
    }

    // Process remaining bytes
    while ( len > 0 ) {
        h ^= static_cast<uint64_t>(*p++) * XXH_PRIME64_5;
        h = rotl64(h, 11) * XXH_PRIME64_1;
        --len;
    }

    return avalanche64(h);
}

// Fast hash combine (for composite keys)
SIMD_FORCE_INLINE uint64_t hash_combine(uint64_t h1, uint64_t h2)
{
    // Mix bits thoroughly
    h1 ^= h2 + 0x9e3779b97f4a7c15ULL + (h1 << 6) + (h1 >> 2);
    return h1;
}

// Fast integer hash
SIMD_FORCE_INLINE uint64_t hash_u64(uint64_t x)
{
    // Murmur3-like finalizer
    x ^= x >> 33;
    x *= 0xff51afd7ed558ccdULL;
    x ^= x >> 33;
    x *= 0xc4ceb9fe1a85ec53ULL;
    x ^= x >> 33;
    return x;
}

SIMD_FORCE_INLINE uint32_t hash_u32(uint32_t x)
{
    // Murmur3 finalizer
    x ^= x >> 16;
    x *= 0x85ebca6b;
    x ^= x >> 13;
    x *= 0xc2b2ae35;
    x ^= x >> 16;
    return x;
}

//--------------------------------------------------------------------------
// Portable popcount / bit operations
//--------------------------------------------------------------------------

SIMD_FORCE_INLINE int popcount32(uint32_t x)
{
#if defined(_MSC_VER)
    return __popcnt(x);
#else
    return __builtin_popcount(x);
#endif
}

SIMD_FORCE_INLINE int popcount64(uint64_t x)
{
#if defined(_MSC_VER)
    #if defined(_M_X64)
        return (int)__popcnt64(x);
    #else
        return __popcnt((uint32_t)x) + __popcnt((uint32_t)(x >> 32));
    #endif
#else
    return __builtin_popcountll(x);
#endif
}

SIMD_FORCE_INLINE int clz32(uint32_t x)
{
    if ( x == 0 ) return 32;
#if defined(_MSC_VER)
    unsigned long idx;
    _BitScanReverse(&idx, x);
    return 31 - (int)idx;
#else
    return __builtin_clz(x);
#endif
}

SIMD_FORCE_INLINE int clz64(uint64_t x)
{
    if ( x == 0 ) return 64;
#if defined(_MSC_VER)
    #if defined(_M_X64)
        unsigned long idx;
        _BitScanReverse64(&idx, x);
        return 63 - (int)idx;
    #else
        uint32_t hi = (uint32_t)(x >> 32);
        if ( hi != 0 ) {
            unsigned long idx;
            _BitScanReverse(&idx, hi);
            return 31 - (int)idx;
        }
        unsigned long idx;
        _BitScanReverse(&idx, (uint32_t)x);
        return 63 - (int)idx;
    #endif
#else
    return __builtin_clzll(x);
#endif
}

SIMD_FORCE_INLINE int ctz32(uint32_t x)
{
    if ( x == 0 ) return 32;
#if defined(_MSC_VER)
    unsigned long idx;
    _BitScanForward(&idx, x);
    return (int)idx;
#else
    return __builtin_ctz(x);
#endif
}

SIMD_FORCE_INLINE int ctz64(uint64_t x)
{
    if ( x == 0 ) return 64;
#if defined(_MSC_VER)
    #if defined(_M_X64)
        unsigned long idx;
        _BitScanForward64(&idx, x);
        return (int)idx;
    #else
        uint32_t lo = (uint32_t)x;
        if ( lo != 0 ) {
            unsigned long idx;
            _BitScanForward(&idx, lo);
            return (int)idx;
        }
        unsigned long idx;
        _BitScanForward(&idx, (uint32_t)(x >> 32));
        return 32 + (int)idx;
    #endif
#else
    return __builtin_ctzll(x);
#endif
}

// Log2 floor (for power-of-2 calculations)
SIMD_FORCE_INLINE int log2_floor(uint64_t x)
{
    if ( x == 0 ) return -1;
    return 63 - clz64(x);
}

SIMD_FORCE_INLINE int log2_floor32(uint32_t x)
{
    if ( x == 0 ) return -1;
    return 31 - clz32(x);
}

// Log2 ceiling (rounds up)
SIMD_FORCE_INLINE int log2_ceil(uint64_t x)
{
    if ( x <= 1 ) return 0;
    return 64 - clz64(x - 1);
}

// Next power of 2 (for capacity calculations)
SIMD_FORCE_INLINE uint64_t next_pow2(uint64_t x)
{
    if ( x == 0 ) return 1;
    return 1ULL << log2_ceil(x);
}

SIMD_FORCE_INLINE uint32_t next_pow2_32(uint32_t x)
{
    if ( x == 0 ) return 1;
    x--;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    return x + 1;
}

// Check if value is power of 2
SIMD_FORCE_INLINE bool is_pow2(uint64_t x)
{
    return x != 0 && (x & (x - 1)) == 0;
}

//--------------------------------------------------------------------------
// SIMD-accelerated pattern signature comparison
// Returns number of mismatches (0 = perfect match)
// Used for fast pattern rejection before full structural match
//--------------------------------------------------------------------------

// Compute pattern structural signature (opcode tree fingerprint)
// Returns a 64-bit signature that can be compared with SIMD
struct alignas(16) PatternSignature {
    uint64_t opcode_bits;    // Packed opcodes (5 bits each, up to 12 levels)
    uint64_t structure_bits; // Tree structure (1 = node, 0 = leaf, BFS order)
    uint16_t depth;          // Tree depth
    uint16_t node_count;     // Total number of nodes
    uint16_t leaf_count;     // Total number of leaves  
    uint16_t _pad;
    
    SIMD_FORCE_INLINE bool operator==(const PatternSignature& other) const
    {
        // Fast SIMD compare for aligned structures
#if defined(CHERNOBOG_SSE2)
        __m128i a = _mm_load_si128(reinterpret_cast<const __m128i*>(this));
        __m128i b = _mm_load_si128(reinterpret_cast<const __m128i*>(&other));
        __m128i cmp = _mm_cmpeq_epi8(a, b);
        return _mm_movemask_epi8(cmp) == 0xFFFF;
#elif defined(CHERNOBOG_NEON)
        uint8x16_t a = vld1q_u8(reinterpret_cast<const uint8_t*>(this));
        uint8x16_t b = vld1q_u8(reinterpret_cast<const uint8_t*>(&other));
        uint8x16_t cmp = vceqq_u8(a, b);
        uint64x2_t cmp64 = vreinterpretq_u64_u8(cmp);
        return vgetq_lane_u64(cmp64, 0) == ~0ULL && vgetq_lane_u64(cmp64, 1) == ~0ULL;
#else
        return opcode_bits == other.opcode_bits &&
               structure_bits == other.structure_bits &&
               depth == other.depth &&
               node_count == other.node_count &&
               leaf_count == other.leaf_count;
#endif
    }
    
    // Check if this signature could match (allowing wildcards in pattern)
    // Pattern wildcards are encoded as all-1s in relevant bit positions
    SIMD_FORCE_INLINE bool compatible_with(const PatternSignature& pattern) const
    {
        // Structure must be identical
        if ( structure_bits != pattern.structure_bits ) return false;
        if ( depth != pattern.depth ) return false;

        // For opcodes, pattern can have wildcards (0x1F = any)
        uint64_t diff = opcode_bits ^ pattern.opcode_bits;
        // Mask out positions that are wildcards in pattern (0x1F = 31)
        // Check each 5-bit group for wildcard
        uint64_t wildcard_mask = 0;
        uint64_t p = pattern.opcode_bits;
        for ( int i = 0; i < 12; ++i ) {
            if ( (p & 0x1F) == 0x1F ) {
                wildcard_mask |= (0x1FULL << (i * 5));
            }
            p >>= 5;
        }
        return (diff & ~wildcard_mask) == 0;
    }
};

//--------------------------------------------------------------------------
// Fast SIMD memset (for clearing structures)
//--------------------------------------------------------------------------
SIMD_FORCE_INLINE void memset_zero_16(void* dst)
{
#if defined(CHERNOBOG_SSE2)
    _mm_store_si128(reinterpret_cast<__m128i*>(dst), _mm_setzero_si128());
#elif defined(CHERNOBOG_NEON)
    vst1q_u8(reinterpret_cast<uint8_t*>(dst), vdupq_n_u8(0));
#else
    memset(dst, 0, 16);
#endif
}

SIMD_FORCE_INLINE void memset_zero_32(void* dst)
{
#if defined(CHERNOBOG_AVX2)
    _mm256_store_si256(reinterpret_cast<__m256i*>(dst), _mm256_setzero_si256());
#elif defined(CHERNOBOG_SSE2)
    __m128i zero = _mm_setzero_si128();
    _mm_store_si128(reinterpret_cast<__m128i*>(dst), zero);
    _mm_store_si128(reinterpret_cast<__m128i*>(static_cast<char*>(dst) + 16), zero);
#elif defined(CHERNOBOG_NEON)
    uint8x16_t zero = vdupq_n_u8(0);
    vst1q_u8(reinterpret_cast<uint8_t*>(dst), zero);
    vst1q_u8(reinterpret_cast<uint8_t*>(dst) + 16, zero);
#else
    memset(dst, 0, 32);
#endif
}

SIMD_FORCE_INLINE void memset_zero_64(void* dst)
{
#if defined(CHERNOBOG_AVX2)
    __m256i zero = _mm256_setzero_si256();
    _mm256_store_si256(reinterpret_cast<__m256i*>(dst), zero);
    _mm256_store_si256(reinterpret_cast<__m256i*>(static_cast<char*>(dst) + 32), zero);
#elif defined(CHERNOBOG_SSE2)
    __m128i zero = _mm_setzero_si128();
    _mm_store_si128(reinterpret_cast<__m128i*>(dst), zero);
    _mm_store_si128(reinterpret_cast<__m128i*>(static_cast<char*>(dst) + 16), zero);
    _mm_store_si128(reinterpret_cast<__m128i*>(static_cast<char*>(dst) + 32), zero);
    _mm_store_si128(reinterpret_cast<__m128i*>(static_cast<char*>(dst) + 48), zero);
#elif defined(CHERNOBOG_NEON)
    uint8x16_t zero = vdupq_n_u8(0);
    vst1q_u8(reinterpret_cast<uint8_t*>(dst), zero);
    vst1q_u8(reinterpret_cast<uint8_t*>(dst) + 16, zero);
    vst1q_u8(reinterpret_cast<uint8_t*>(dst) + 32, zero);
    vst1q_u8(reinterpret_cast<uint8_t*>(dst) + 48, zero);
#else
    memset(dst, 0, 64);
#endif
}

//--------------------------------------------------------------------------
// SIMD-accelerated memcpy for aligned structures
//--------------------------------------------------------------------------
SIMD_FORCE_INLINE void memcpy_16(void* dst, const void* src)
{
#if defined(CHERNOBOG_SSE2)
    _mm_store_si128(reinterpret_cast<__m128i*>(dst),
                    _mm_load_si128(reinterpret_cast<const __m128i*>(src)));
#elif defined(CHERNOBOG_NEON)
    vst1q_u8(reinterpret_cast<uint8_t*>(dst),
             vld1q_u8(reinterpret_cast<const uint8_t*>(src)));
#else
    memcpy(dst, src, 16);
#endif
}

SIMD_FORCE_INLINE void memcpy_32(void* dst, const void* src)
{
#if defined(CHERNOBOG_AVX2)
    _mm256_store_si256(reinterpret_cast<__m256i*>(dst),
                       _mm256_load_si256(reinterpret_cast<const __m256i*>(src)));
#elif defined(CHERNOBOG_SSE2)
    _mm_store_si128(reinterpret_cast<__m128i*>(dst),
                    _mm_load_si128(reinterpret_cast<const __m128i*>(src)));
    _mm_store_si128(reinterpret_cast<__m128i*>(static_cast<char*>(dst) + 16),
                    _mm_load_si128(reinterpret_cast<const __m128i*>(static_cast<const char*>(src) + 16)));
#elif defined(CHERNOBOG_NEON)
    vst1q_u8(reinterpret_cast<uint8_t*>(dst),
             vld1q_u8(reinterpret_cast<const uint8_t*>(src)));
    vst1q_u8(reinterpret_cast<uint8_t*>(dst) + 16,
             vld1q_u8(reinterpret_cast<const uint8_t*>(src) + 16));
#else
    memcpy(dst, src, 32);
#endif
}

//--------------------------------------------------------------------------
// Small vector with inline storage (avoids heap for small collections)
//--------------------------------------------------------------------------

template<typename T, size_t InlineCapacity>
class SmallVector {
    static_assert(InlineCapacity > 0, "InlineCapacity must be > 0");
    
public:
    SmallVector() : size_(0), capacity_(InlineCapacity), data_(inline_storage()) {}
    
    ~SmallVector()
    {
        clear();
        if ( data_ != inline_storage() ) {
            ::operator delete(data_);
        }
    }
    
    SmallVector(const SmallVector& other) : size_(0), capacity_(InlineCapacity), data_(inline_storage())
    {
        reserve(other.size_);
        for ( size_t i = 0; i < other.size_; ++i ) {
            new (&data_[i]) T(other.data_[i]);
        }
        size_ = other.size_;
    }
    
    SmallVector& operator=(const SmallVector& other)
    {
        if ( this != &other ) {
            clear();
            reserve(other.size_);
            for ( size_t i = 0; i < other.size_; ++i ) {
                new (&data_[i]) T(other.data_[i]);
            }
            size_ = other.size_;
        }
        return *this;
    }
    
    SmallVector(SmallVector&& other) noexcept : size_(0), capacity_(InlineCapacity), data_(inline_storage())
    {
        if ( other.data_ == other.inline_storage() ) {
            // Move elements from inline storage
            for ( size_t i = 0; i < other.size_; ++i ) {
                new (&data_[i]) T(std::move(other.data_[i]));
                other.data_[i].~T();
            }
            size_ = other.size_;
            other.size_ = 0;
        } else {
            // Steal heap pointer
            data_ = other.data_;
            size_ = other.size_;
            capacity_ = other.capacity_;
            other.data_ = other.inline_storage();
            other.size_ = 0;
            other.capacity_ = InlineCapacity;
        }
    }
    
    void push_back(const T& val)
    {
        if ( size_ >= capacity_ ) {
            grow(capacity_ * 2);
        }
        new (&data_[size_]) T(val);
        ++size_;
    }
    
    void push_back(T&& val)
    {
        if ( size_ >= capacity_ ) {
            grow(capacity_ * 2);
        }
        new (&data_[size_]) T(std::move(val));
        ++size_;
    }
    
    template<typename... Args>
    T& emplace_back(Args&&... args)
    {
        if ( size_ >= capacity_ ) {
            grow(capacity_ * 2);
        }
        new (&data_[size_]) T(std::forward<Args>(args)...);
        return data_[size_++];
    }
    
    void pop_back()
    {
        if ( size_ > 0 ) {
            data_[--size_].~T();
        }
    }
    
    void clear()
    {
        for ( size_t i = 0; i < size_; ++i ) {
            data_[i].~T();
        }
        size_ = 0;
    }
    
    void reserve(size_t n)
    {
        if ( n > capacity_ ) {
            grow(n);
        }
    }
    
    void resize(size_t n)
    {
        if ( n > size_ ) {
            reserve(n);
            for ( size_t i = size_; i < n; ++i ) {
                new (&data_[i]) T();
            }
        } else {
            for ( size_t i = n; i < size_; ++i ) {
                data_[i].~T();
            }
        }
        size_ = n;
    }
    
    T& operator[](size_t i) { return data_[i]; }
    const T& operator[](size_t i) const { return data_[i]; }
    
    T* data() { return data_; }
    const T* data() const { return data_; }
    
    size_t size() const { return size_; }
    size_t capacity() const { return capacity_; }
    bool empty() const { return size_ == 0; }
    
    T* begin() { return data_; }
    T* end() { return data_ + size_; }
    const T* begin() const { return data_; }
    const T* end() const { return data_ + size_; }
    
    T& front() { return data_[0]; }
    T& back() { return data_[size_ - 1]; }
    const T& front() const { return data_[0]; }
    const T& back() const { return data_[size_ - 1]; }
    
private:
    T* inline_storage()
    {
        return reinterpret_cast<T*>(&storage_);
    }
    const T* inline_storage() const
    {
        return reinterpret_cast<const T*>(&storage_);
    }
    
    void grow(size_t new_cap)
    {
        T* new_data = static_cast<T*>(::operator new(new_cap * sizeof(T)));

        for ( size_t i = 0; i < size_; ++i ) {
            new (&new_data[i]) T(std::move(data_[i]));
            data_[i].~T();
        }

        if ( data_ != inline_storage() ) {
            ::operator delete(data_);
        }

        data_ = new_data;
        capacity_ = new_cap;
    }
    
    size_t size_;
    size_t capacity_;
    T* data_;
    typename std::aligned_storage<sizeof(T) * InlineCapacity, alignof(T)>::type storage_;
};

//--------------------------------------------------------------------------
// Arena allocator for temporary allocations
//--------------------------------------------------------------------------

class Arena {
public:
    static constexpr size_t DEFAULT_BLOCK_SIZE = 4096;
    
    explicit Arena(size_t block_size = DEFAULT_BLOCK_SIZE)
        : block_size_(block_size), current_(nullptr), end_(nullptr) {}
    
    ~Arena()
    {
        for ( void* block : blocks_ ) {
            ::operator delete(block);
        }
    }
    
    // Non-copyable, non-movable
    Arena(const Arena&) = delete;
    Arena& operator=(const Arena&) = delete;
    
    void* allocate(size_t size, size_t align = 8)
    {
        // Align current pointer
        uintptr_t aligned = (reinterpret_cast<uintptr_t>(current_) + align - 1) & ~(align - 1);
        char* result = reinterpret_cast<char*>(aligned);

        if ( result + size > end_ ) {
            // Need new block
            size_t alloc_size = std::max(block_size_, size + align);
            char* new_block = static_cast<char*>(::operator new(alloc_size));
            blocks_.push_back(new_block);
            current_ = new_block;
            end_ = new_block + alloc_size;

            aligned = (reinterpret_cast<uintptr_t>(current_) + align - 1) & ~(align - 1);
            result = reinterpret_cast<char*>(aligned);
        }

        current_ = result + size;
        return result;
    }
    
    template<typename T, typename... Args>
    T* create(Args&&... args)
    {
        void* mem = allocate(sizeof(T), alignof(T));
        return new (mem) T(std::forward<Args>(args)...);
    }
    
    void reset()
    {
        // Keep first block, release rest
        if ( !blocks_.empty() ) {
            for ( size_t i = 1; i < blocks_.size(); ++i ) {
                ::operator delete(blocks_[i]);
            }
            current_ = static_cast<char*>(blocks_[0]);
            end_ = current_ + block_size_;
            blocks_.resize(1);
        }
    }
    
    size_t bytes_allocated() const
    {
        size_t total = 0;
        for ( size_t i = 0; i < blocks_.size(); ++i ) {
            total += (i == blocks_.size() - 1)
                ? static_cast<size_t>(current_ - static_cast<char*>(blocks_[i]))
                : block_size_;
        }
        return total;
    }
    
private:
    size_t block_size_;
    char* current_;
    char* end_;
    SmallVector<void*, 8> blocks_;
};

//--------------------------------------------------------------------------
// Fast string interning for variable names
//--------------------------------------------------------------------------

class StringInterner {
public:
    using StringId = uint32_t;
    static constexpr StringId INVALID_ID = ~0u;
    
    static StringInterner& instance()
    {
        static StringInterner inst;
        return inst;
    }
    
    StringId intern(const char* str, size_t len)
    {
        uint64_t h = hash_bytes(str, len);

        // Check if already interned
        for ( size_t i = 0; i < entries_.size(); ++i ) {
            if ( entries_[i].hash == h &&
                entries_[i].len == len &&
                memcmp(entries_[i].str, str, len) == 0 ) {
                return static_cast<StringId>(i);
            }
        }

        // Add new entry
        char* copy = static_cast<char*>(arena_.allocate(len + 1));
        memcpy(copy, str, len);
        copy[len] = '\0';

        StringId id = static_cast<StringId>(entries_.size());
        entries_.push_back({h, copy, len});
        return id;
    }
    
    StringId intern(const std::string& str)
    {
        return intern(str.c_str(), str.size());
    }
    
    const char* get(StringId id) const
    {
        if ( id >= entries_.size() ) return nullptr;
        return entries_[id].str;
    }
    
    size_t length(StringId id) const
    {
        if ( id >= entries_.size() ) return 0;
        return entries_[id].len;
    }
    
    void clear()
    {
        entries_.clear();
        arena_.reset();
    }
    
private:
    StringInterner() = default;
    
    struct Entry {
        uint64_t hash;
        const char* str;
        size_t len;
    };
    
    SmallVector<Entry, 64> entries_;
    Arena arena_;
};

//--------------------------------------------------------------------------
// Object Pool for fixed-size allocations (like AST nodes)
// Thread-safe with per-thread free lists
//--------------------------------------------------------------------------

template<typename T, size_t BlockSize = 64>
class ObjectPool {
public:
    ObjectPool() = default;
    
    ~ObjectPool()
    {
        clear();
    }
    
    // Non-copyable
    ObjectPool(const ObjectPool&) = delete;
    ObjectPool& operator=(const ObjectPool&) = delete;
    
    template<typename... Args>
    T* allocate(Args&&... args)
    {
        T* obj;

        // Try free list first
        if ( !free_list_.empty() ) {
            obj = free_list_.back();
            free_list_.pop_back();
            new (obj) T(std::forward<Args>(args)...);
        } else {
            // Allocate new block if needed
            if ( current_idx_ >= BlockSize || blocks_.empty() ) {
                allocate_block();
            }
            obj = &blocks_.back()[current_idx_++];
            new (obj) T(std::forward<Args>(args)...);
        }

        return obj;
    }
    
    void deallocate(T* obj)
    {
        if ( obj ) {
            obj->~T();
            free_list_.push_back(obj);
        }
    }
    
    void clear()
    {
        for ( T* block : blocks_ ) {
            ::operator delete(block);
        }
        blocks_.clear();
        free_list_.clear();
        current_idx_ = BlockSize;
    }
    
    size_t allocated_count() const
    {
        if ( blocks_.empty() ) return 0;
        return (blocks_.size() - 1) * BlockSize + current_idx_;
    }
    
private:
    void allocate_block()
    {
        T* block = static_cast<T*>(::operator new(BlockSize * sizeof(T)));
        blocks_.push_back(block);
        current_idx_ = 0;
    }
    
    SmallVector<T*, 16> blocks_;
    SmallVector<T*, 32> free_list_;
    size_t current_idx_ = BlockSize;
};

//--------------------------------------------------------------------------
// Scoped arena for temporary allocations that are freed in bulk
// Useful for per-instruction analysis allocations
//--------------------------------------------------------------------------

class ScopedArena {
public:
    explicit ScopedArena(Arena& arena)
        : arena_(arena), saved_bytes_(arena.bytes_allocated()) {}
    
    ~ScopedArena()
    {
        // Note: Arena doesn't support partial deallocation
        // This is more of a marker for debugging/profiling
    }
    
    template<typename T, typename... Args>
    T* create(Args&&... args)
    {
        return arena_.create<T>(std::forward<Args>(args)...);
    }
    
    void* allocate(size_t size, size_t align = 8)
    {
        return arena_.allocate(size, align);
    }
    
private:
    Arena& arena_;
    size_t saved_bytes_;
};

} // namespace simd
} // namespace chernobog

#endif // CHERNOBOG_SIMD_H

```

`src/common/warn_off.h`:

```h
#ifdef _MSC_VER
#pragma warning(disable:4244; disable:4267; disable:4146; disable:4018)
#endif //_MSC_VER
#ifdef __GNUC__
#pragma GCC diagnostic ignored "-Wswitch"
#pragma GCC diagnostic ignored "-Wpedantic"
#pragma GCC diagnostic ignored "-Wvarargs"
#ifdef __MAC__
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif // __MAC__
#pragma GCC diagnostic push

//temporary fix for gcc 13.1.1 and IDA81
#include <cstdint>
#endif // __GNUC__

```

`src/common/warn_on.h`:

```h
#ifdef _MSC_VER
#pragma warning(default:4244; default:4267; default: 4146; default:4018)
#endif
#ifdef __GNUC__
#pragma GCC diagnostic pop
#pragma GCC diagnostic ignored "-Wformat"
#endif

```

`src/deobf/analysis/arch_utils.cpp`:

```cpp
#include "arch_utils.h"

// Include x86 instruction definitions
// Note: ARM instruction IDs are not available via allins.hpp in plugins;
// we define them manually based on IDA's ARM processor module
#ifndef ALLINS_HPP_INCLUDED
#define ALLINS_HPP_INCLUDED
#include <allins.hpp>
#endif

// ARM64 instruction IDs (from IDA's ARM processor module)
// These are the instruction types used by ARM64 disassembly
#ifndef ARM_mov
// Core data movement
#define ARM_mov     1
#define ARM_movz    2
#define ARM_movn    3
#define ARM_movk    4

// Branching
#define ARM_b       20
#define ARM_bl      21
#define ARM_br      22
#define ARM_blr     23
#define ARM_ret     24
#define ARM_cbz     25
#define ARM_cbnz    26
#define ARM_tbz     27
#define ARM_tbnz    28

// Load/Store
#define ARM_ldr     40
#define ARM_ldp     41
#define ARM_ldrb    42
#define ARM_ldrh    43
#define ARM_ldrsb   44
#define ARM_ldrsh   45
#define ARM_ldrsw   46
#define ARM_ldur    47
#define ARM_str     48
#define ARM_stp     49

// Address calculation
#define ARM_adr     60
#define ARM_adrp    61

// NOP
#define ARM_nop     70
#endif

namespace arch {

//--------------------------------------------------------------------------
// Architecture detection
//--------------------------------------------------------------------------
arch_type_t get_arch() {
    // Check processor ID (use PH macro for IDA 9.x compatibility)
    if ( PH.id == PLFM_386 ) {
        return inf_is_64bit() ? ARCH_X86_64 : ARCH_X86;
    }
    else if ( PH.id == PLFM_ARM ) {
        return inf_is_64bit() ? ARCH_ARM64 : ARCH_ARM32;
    }
    return ARCH_UNKNOWN;
}

bool is_x86() {
    return PH.id == PLFM_386;
}

bool is_x86_64() {
    return PH.id == PLFM_386 && inf_is_64bit();
}

bool is_arm() {
    return PH.id == PLFM_ARM;
}

bool is_arm64() {
    return PH.id == PLFM_ARM && inf_is_64bit();
}

bool is_64bit() {
    return inf_is_64bit();
}

//--------------------------------------------------------------------------
// Register role abstraction
//--------------------------------------------------------------------------

int get_first_arg_reg() {
    if ( is_x86_64() ) {
        // System V AMD64 ABI: RDI = 7
        // Windows x64: RCX = 1
        // We default to System V (macOS, Linux)
        // TODO: Add Windows support via calling convention detection
        return 7;  // RDI
    }
    else if ( is_arm64() ) {
        return 0;  // X0
    }
    else if ( is_x86() ) {
        // 32-bit x86 typically uses stack, but fastcall uses ECX
        return 1;  // ECX for fastcall
    }
    else if ( is_arm() ) {
        return 0;  // R0
    }
    return -1;
}

int get_second_arg_reg() {
    if ( is_x86_64() ) {
        return 6;  // RSI (System V)
    }
    else if ( is_arm64() ) {
        return 1;  // X1
    }
    else if ( is_x86() ) {
        return 2;  // EDX for fastcall
    }
    else if ( is_arm() ) {
        return 1;  // R1
    }
    return -1;
}

int get_return_reg() {
    if ( is_x86() ) {
        return 0;  // (R/E)AX
    }
    else if ( is_arm() ) {
        return 0;  // (X/R)0
    }
    return -1;
}

int get_link_reg() {
    if (is_arm64()) {
        return 30;  // X30/LR
    }
    else if ( is_arm() ) {
        return 14;  // LR
    }
    // x86 uses stack for return address
    return -1;
}

int get_stack_pointer_reg() {
    if ( is_x86_64() ) {
        return 4;  // RSP
    }
    else if ( is_x86() ) {
        return 4;  // ESP
    }
    else if ( is_arm64() ) {
        return 31;  // SP
    }
    else if ( is_arm() ) {
        return 13;  // SP
    }
    return -1;
}

int get_frame_pointer_reg() {
    if ( is_x86() ) {
        return 5;  // (R/E)BP
    }
    else if ( is_arm64() ) {
        return 29;  // X29/FP
    }
    else if ( is_arm() ) {
        return 11;  // FP (R11)
    }
    return -1;
}

//--------------------------------------------------------------------------
// Instruction type classification
//--------------------------------------------------------------------------

bool is_mov_insn(uint16_t itype) {
    if ( is_x86() ) {
        return itype == NN_mov;
    }
    else if ( is_arm() ) {
        // ARM64 has multiple MOV variants
        // ARM_mov is the canonical one, but also check aliases
        return itype == ARM_mov ||
               itype == ARM_movz ||
               itype == ARM_movn ||
               itype == ARM_movk;
    }
    return false;
}

bool is_direct_branch(uint16_t itype) {
    if ( is_x86() ) {
        return itype == NN_jmp;
    }
    else if ( is_arm() ) {
        return itype == ARM_b;
    }
    return false;
}

bool is_conditional_branch(uint16_t itype) {
    if ( is_x86() ) {
        // All conditional jumps are in range NN_ja..NN_jz
        return (itype >= NN_ja && itype <= NN_jz);
    }
    else if ( is_arm() ) {
        // ARM conditional branches and compare-and-branch
        return itype == ARM_b ||  // B.cond
               itype == ARM_cbz ||
               itype == ARM_cbnz ||
               itype == ARM_tbz ||
               itype == ARM_tbnz;
    }
    return false;
}

bool is_indirect_branch(uint16_t itype) {
    if ( is_x86() ) {
        return itype == NN_jmpni;
    }
    else if ( is_arm() ) {
        return itype == ARM_br;
    }
    return false;
}

bool is_direct_call(uint16_t itype) {
    if ( is_x86() ) {
        return itype == NN_call;
    }
    else if ( is_arm() ) {
        return itype == ARM_bl;
    }
    return false;
}

bool is_indirect_call(uint16_t itype) {
    if ( is_x86() ) {
        return itype == NN_callni;
    }
    else if ( is_arm() ) {
        return itype == ARM_blr;
    }
    return false;
}

bool is_call_insn(uint16_t itype) {
    return is_direct_call(itype) || is_indirect_call(itype);
}

bool is_return_insn(uint16_t itype) {
    if ( is_x86() ) {
        return itype == NN_retn || itype == NN_retf;
    }
    else if ( is_arm() ) {
        return itype == ARM_ret;
    }
    return false;
}

bool is_load_insn(uint16_t itype) {
    if ( is_x86() ) {
        // x86 MOV can be a load when source is memory
        // But we check the operand type separately
        return itype == NN_mov;
    }
    else if ( is_arm() ) {
        return itype == ARM_ldr ||
               itype == ARM_ldrb ||
               itype == ARM_ldrh ||
               itype == ARM_ldrsb ||
               itype == ARM_ldrsh ||
               itype == ARM_ldrsw ||
               itype == ARM_ldp ||
               itype == ARM_ldur;
    }
    return false;
}

bool is_lea_insn(uint16_t itype) {
    if ( is_x86() ) {
        return itype == NN_lea;
    }
    else if ( is_arm() ) {
        // ARM uses ADR/ADRP for PC-relative address computation
        return itype == ARM_adr || itype == ARM_adrp;
    }
    return false;
}

bool is_nop_insn(uint16_t itype) {
    if ( is_x86() ) {
        return itype == NN_nop;
    }
    else if ( is_arm() ) {
        return itype == ARM_nop;
    }
    return false;
}

//--------------------------------------------------------------------------
// Pattern analysis helpers
//--------------------------------------------------------------------------

bool is_nop_at_ea(ea_t addr) {
    insn_t insn;
    if (decode_insn(&insn, addr) == 0)
        return false;

    if (is_nop_insn(insn.itype))
        return true;

    // x86: Check for 0x90 byte (single-byte NOP)
    if (is_x86() && insn.size == 1 && get_byte(addr) == 0x90)
        return true;

    return false;
}

bool is_reg_with_role(const op_t &op, int role_reg) {
    if (op.type != o_reg)
        return false;
    return op.reg == role_reg;
}

bool is_identity_mov(const insn_t &insn) {
    if ( is_x86_64() ) {
        // Check for: mov rax, rdi
        if (insn.itype == NN_mov &&
            insn.Op1.type == o_reg && insn.Op1.reg == get_return_reg() &&
            insn.Op2.type == o_reg && insn.Op2.reg == get_first_arg_reg()) {
            return true;
        }
    }
    else if ( is_arm64() ) {
        // Check for: mov x0, x0 (explicit identity)
        // This is rare; usually ARM64 identity functions just return
        if (insn.itype == ARM_mov &&
            insn.Op1.type == o_reg && insn.Op1.reg == 0 &&
            insn.Op2.type == o_reg && insn.Op2.reg == 0) {
            return true;
        }
    }
    return false;
}

bool is_indirect_jump_via_return_reg(const insn_t &insn) {
    if ( is_x86_64() ) {
        // Check for: jmp rax or jmpni via rax
        if ((insn.itype == NN_jmpni || insn.itype == NN_jmp) &&
            insn.Op1.type == o_reg && insn.Op1.reg == get_return_reg()) {
            return true;
        }
    }
    else if ( is_arm64() ) {
        // Check for: br x0 (or any register)
        // For indirect jumps, the target register may vary
        if (insn.itype == ARM_br && insn.Op1.type == o_reg) {
            return true;
        }
    }
    return false;
}

bool is_arg_load_from_mem(const insn_t &insn, ea_t *out_mem_addr) {
    int arg_reg = get_first_arg_reg();

    if ( is_x86_64() ) {
        // Check for: mov rdi, [mem]
        if (insn.itype == NN_mov &&
            insn.Op1.type == o_reg && insn.Op1.reg == arg_reg &&
            insn.Op2.type == o_mem ) {
            if (out_mem_addr)
                *out_mem_addr = insn.Op2.addr;
            return true;
        }
    }
    else if ( is_arm64() ) {
        // Check for: ldr x0, [mem] or ldr x0, =label
        if ((insn.itype == ARM_ldr || insn.itype == ARM_ldur) &&
            insn.Op1.type == o_reg && insn.Op1.reg == arg_reg) {
            // ARM has various addressing modes
            if (insn.Op2.type == o_mem) {
                if (out_mem_addr)
                    *out_mem_addr = insn.Op2.addr;
                return true;
            }
            // Check for PC-relative load (literal pool)
            if (insn.Op2.type == o_displ || insn.Op2.type == o_phrase) {
                // The address calculation is more complex for ARM
                // For now, we'd need additional logic to resolve the address
                return true;
            }
        }
    }
    return false;
}

//--------------------------------------------------------------------------
// Identity function analysis
//--------------------------------------------------------------------------

bool analyze_identity_function(ea_t ea) {
    func_t *func = get_func(ea);
    if ( !func )
        return false;

    // Identity functions are typically very short (< 32 bytes for x86, < 16 bytes for ARM64)
    size_t max_size = is_arm64() ? 16 : 32;
    if ( func->end_ea - func->start_ea > max_size )
        return false;

    ea_t curr = func->start_ea;
    insn_t insn;
    int insn_count = 0;
    bool saw_identity_mov = false;
    bool saw_ret = false;

    while ( curr < func->end_ea && insn_count < 10 ) {
        if ( decode_insn(&insn, curr) == 0 )
            break;

        insn_count++;

        // Skip NOPs
        if ( is_nop_at_ea(curr) ) {
            curr = insn.ea + insn.size;
            continue;
        }

        // Check for identity mov pattern
        if ( is_identity_mov(insn) ) {
            saw_identity_mov = true;
        }

        // Check for return
        if ( is_return_insn(insn.itype) ) {
            saw_ret = true;
            break;
        }

        // If we see a call, check if it's to another identity function
        // (recursive check for wrapper functions)
        if ( is_call_insn(insn.itype) ) {
            ea_t call_target = get_first_fcref_from(insn.ea);
            if ( call_target != BADADDR && call_target != ea ) {
                // Could recurse here, but be careful of infinite loops
                // For now, just note that we saw a call
            }
        }

        curr = insn.ea + insn.size;
    }

    // Determine if this is an identity function
    if ( saw_ret ) {
        // ARM64 special case: if the function is just "ret", it's identity
        // because X0 already contains the first argument and is the return register
        if ( is_arm64() && insn_count <= 2 ) {
            return true;
        }

        // x86-64: need to see the explicit mov rax, rdi
        if ( is_x86_64() && saw_identity_mov ) {
            return true;
        }

        // Very short function that just returns might be identity
        if ( insn_count <= 3 && (saw_identity_mov || is_arm64()) ) {
            return true;
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// Trampoline analysis
//--------------------------------------------------------------------------

bool is_trampoline_code(ea_t addr, ea_t *out_global_ptr) {
    if ( addr == BADADDR )
        return false;

    insn_t insn;
    ea_t curr = addr;
    int insn_count = 0;

    ea_t potential_ptr = BADADDR;
    bool saw_identity_call = false;
    bool saw_indirect_jump = false;

    while ( insn_count < 30 ) {
        if ( decode_insn(&insn, curr) == 0 )
            break;

        insn_count++;

        // Look for argument load from memory
        ea_t mem_addr = BADADDR;
        if ( is_arg_load_from_mem(insn, &mem_addr) ) {
            potential_ptr = mem_addr;
        }

        // x86-specific: look for mov rdi, [ptr]
        if ( is_x86_64() && insn.itype == NN_mov &&
            insn.Op1.type == o_reg && insn.Op1.reg == get_first_arg_reg() &&
            insn.Op2.type == o_mem ) {
            potential_ptr = insn.Op2.addr;
        }

        // ARM64-specific: look for ldr x0, [ptr] or adrp/add sequence
        if ( is_arm64() ) {
            if ( insn.itype == ARM_ldr &&
                insn.Op1.type == o_reg && insn.Op1.reg == 0 ) {
                // Try to extract address from operand
                if ( insn.Op2.type == o_mem ) {
                    potential_ptr = insn.Op2.addr;
                }
            }
            // ADRP loads high bits of address
            if ( insn.itype == ARM_adrp ) {
                // Would need to track ADRP+ADD/LDR sequence
                // For now, just note we're in a trampoline
            }
        }

        // Look for call to identity function
        if ( is_call_insn(insn.itype) ) {
            ea_t call_target = get_first_fcref_from(insn.ea);
            if ( call_target != BADADDR ) {
                if ( analyze_identity_function(call_target) ) {
                    saw_identity_call = true;
                } else {
                    // Check for HikariFunctionWrapper name pattern
                    qstring fname;
                    if ( get_func_name(&fname, call_target) > 0 ) {
                        if ( fname.find("HikariFunctionWrapper") != qstring::npos ) {
                            saw_identity_call = true;
                        }
                    }
                }
            }
        }

        // Look for indirect jump via return register
        if ( is_indirect_jump_via_return_reg(insn) ) {
            saw_indirect_jump = true;
            break;
        }

        // ARM64: br Xn (any register)
        if ( is_arm64() && insn.itype == ARM_br ) {
            saw_indirect_jump = true;
            break;
        }

        if ( is_return_insn(insn.itype) ) {
            break;
        }

        curr = insn.ea + insn.size;
    }

    if ( saw_identity_call && saw_indirect_jump && potential_ptr != BADADDR ) {
        if ( out_global_ptr )
            *out_global_ptr = potential_ptr;
        return true;
    }

    return false;
}

//--------------------------------------------------------------------------
// Architecture-specific instruction building
//--------------------------------------------------------------------------

size_t build_direct_jump(uint8_t *buf, size_t buf_size, ea_t from_ea, ea_t to_ea) {
    if ( is_x86() ) {
        // E9 <rel32> - 5 bytes
        if ( buf_size < 5 )
            return 0;

        ea_t jmp_end = from_ea + 5;
        int32_t rel_offset = (int32_t)(to_ea - jmp_end);

        buf[0] = 0xE9;
        buf[1] = (uint8_t)(rel_offset & 0xFF);
        buf[2] = (uint8_t)((rel_offset >> 8) & 0xFF);
        buf[3] = (uint8_t)((rel_offset >> 16) & 0xFF);
        buf[4] = (uint8_t)((rel_offset >> 24) & 0xFF);
        return 5;
    }
    else if ( is_arm64() ) {
        // B <imm26> - 4 bytes
        // Encoding: 000101 imm26
        // Range: +/- 128 MB
        if ( buf_size < 4 )
            return 0;

        int64_t offset = (int64_t)(to_ea - from_ea);
        // Check range (26-bit signed, scaled by 4)
        if ( offset < -0x8000000 || offset > 0x7FFFFFC )
            return 0;  // Out of range, would need stub

        int32_t imm26 = (int32_t)(offset >> 2) & 0x03FFFFFF;
        uint32_t insn = 0x14000000 | imm26;

        buf[0] = (uint8_t)(insn & 0xFF);
        buf[1] = (uint8_t)((insn >> 8) & 0xFF);
        buf[2] = (uint8_t)((insn >> 16) & 0xFF);
        buf[3] = (uint8_t)((insn >> 24) & 0xFF);
        return 4;
    }
    return 0;
}

size_t build_direct_call(uint8_t *buf, size_t buf_size, ea_t from_ea, ea_t to_ea) {
    if ( is_x86() ) {
        // E8 <rel32> - 5 bytes
        if ( buf_size < 5 )
            return 0;

        ea_t call_end = from_ea + 5;
        int32_t rel_offset = (int32_t)(to_ea - call_end);

        buf[0] = 0xE8;
        buf[1] = (uint8_t)(rel_offset & 0xFF);
        buf[2] = (uint8_t)((rel_offset >> 8) & 0xFF);
        buf[3] = (uint8_t)((rel_offset >> 16) & 0xFF);
        buf[4] = (uint8_t)((rel_offset >> 24) & 0xFF);
        return 5;
    }
    else if ( is_arm64() ) {
        // BL <imm26> - 4 bytes
        // Encoding: 100101 imm26
        if ( buf_size < 4 )
            return 0;

        int64_t offset = (int64_t)(to_ea - from_ea);
        if ( offset < -0x8000000 || offset > 0x7FFFFFC )
            return 0;

        int32_t imm26 = (int32_t)(offset >> 2) & 0x03FFFFFF;
        uint32_t insn = 0x94000000 | imm26;

        buf[0] = (uint8_t)(insn & 0xFF);
        buf[1] = (uint8_t)((insn >> 8) & 0xFF);
        buf[2] = (uint8_t)((insn >> 16) & 0xFF);
        buf[3] = (uint8_t)((insn >> 24) & 0xFF);
        return 4;
    }
    return 0;
}

size_t get_nop_bytes(uint8_t *buf, size_t buf_size) {
    if ( is_x86() ) {
        if ( buf_size < 1 )
            return 0;
        buf[0] = 0x90;
        return 1;
    }
    else if ( is_arm64() ) {
        // NOP: D503201F
        if ( buf_size < 4 )
            return 0;
        buf[0] = 0x1F;
        buf[1] = 0x20;
        buf[2] = 0x03;
        buf[3] = 0xD5;
        return 4;
    }
    return 0;
}

size_t get_min_insn_size() {
    if ( is_x86() ) {
        return 1;  // Variable length, min 1 byte
    }
    else if ( is_arm64() ) {
        return 4;  // Fixed 4-byte instructions
    }
    else if ( is_arm() ) {
        return 2;  // Thumb can be 2 bytes, ARM is 4
    }
    return 1;
}

//--------------------------------------------------------------------------
// Pointer size helpers
//--------------------------------------------------------------------------

int get_ptr_size() {
    return is_64bit() ? 8 : 4;
}

ea_t read_ptr(ea_t addr) {
    if ( addr == BADADDR )
        return BADADDR;

    ea_t target = BADADDR;
    int ptr_size = get_ptr_size();

    if ( ptr_size == 8 ) {
        uint64_t val = 0;
        if ( get_bytes(&val, 8, addr) == 8 ) {
            target = (ea_t)val;
        }
    } else {
        uint32_t val = 0;
        if ( get_bytes(&val, 4, addr) == 4 ) {
            target = (ea_t)val;
        }
    }

    return target;
}

} // namespace arch

```

`src/deobf/analysis/arch_utils.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Architecture Abstraction Layer
//
// This module provides architecture-independent utilities for analyzing
// native code patterns. It abstracts away differences between x86-64 and
// ARM64 (AArch64) architectures.
//
// Key abstractions:
//   - Register roles (first argument, return value, link register)
//   - Instruction type classification (mov, branch, call, return)
//   - Pattern detection (identity functions, trampolines, indirect jumps)
//   - Calling convention awareness
//--------------------------------------------------------------------------

namespace arch {

//--------------------------------------------------------------------------
// Supported architectures
//--------------------------------------------------------------------------
enum arch_type_t {
    ARCH_UNKNOWN = 0,
    ARCH_X86,           // 32-bit x86
    ARCH_X86_64,        // 64-bit x86-64
    ARCH_ARM32,         // 32-bit ARM
    ARCH_ARM64,         // 64-bit ARM (AArch64)
};

//--------------------------------------------------------------------------
// Get current architecture
//--------------------------------------------------------------------------
arch_type_t get_arch();

// Convenience checks
bool is_x86();          // x86 or x86-64
bool is_x86_64();       // 64-bit x86 only
bool is_arm();          // ARM32 or ARM64
bool is_arm64();        // 64-bit ARM only
bool is_64bit();        // Any 64-bit architecture

//--------------------------------------------------------------------------
// Register role abstraction
// These functions return the native register number for each role
//--------------------------------------------------------------------------

// First function argument register
// x86-64 System V: RDI (7)
// x86-64 Windows:  RCX (1)
// ARM64:           X0 (0)
int get_first_arg_reg();

// Second function argument register (for completeness)
// x86-64 System V: RSI (6)
// x86-64 Windows:  RDX (2)
// ARM64:           X1 (1)
int get_second_arg_reg();

// Return value register
// x86-64: RAX (0)
// ARM64:  X0 (0)
int get_return_reg();

// Link register (return address stored in register)
// x86-64: N/A (-1), return address is on stack
// ARM64:  X30/LR (30)
int get_link_reg();

// Stack pointer register
// x86-64: RSP (4)
// ARM64:  SP (31)
int get_stack_pointer_reg();

// Frame pointer register
// x86-64: RBP (5)
// ARM64:  X29/FP (29)
int get_frame_pointer_reg();

//--------------------------------------------------------------------------
// Instruction type classification
// These functions check native instruction types (insn_t.itype)
//--------------------------------------------------------------------------

// Check if instruction is a MOV-like data transfer
// x86: NN_mov
// ARM64: ARM_mov, ARM_movz, ARM_movn, ARM_movk
bool is_mov_insn(uint16_t itype);

// Check if instruction is a direct branch (unconditional jump)
// x86: NN_jmp
// ARM64: ARM_b
bool is_direct_branch(uint16_t itype);

// Check if instruction is a conditional branch
// x86: NN_jcc (jz, jnz, jl, jg, etc.)
// ARM64: ARM_b with condition, ARM_cbz, ARM_cbnz, ARM_tbz, ARM_tbnz
bool is_conditional_branch(uint16_t itype);

// Check if instruction is an indirect branch (jump via register)
// x86: NN_jmpni (jmp rax, jmp [mem])
// ARM64: ARM_br (BR Xn)
bool is_indirect_branch(uint16_t itype);

// Check if instruction is a direct call
// x86: NN_call (call rel32)
// ARM64: ARM_bl (BL label)
bool is_direct_call(uint16_t itype);

// Check if instruction is an indirect call (call via register)
// x86: NN_callni (call rax, call [mem])
// ARM64: ARM_blr (BLR Xn)
bool is_indirect_call(uint16_t itype);

// Check if instruction is any call (direct or indirect)
bool is_call_insn(uint16_t itype);

// Check if instruction is a return
// x86: NN_retn, NN_retf
// ARM64: ARM_ret
bool is_return_insn(uint16_t itype);

// Check if instruction is a load from memory
// x86: NN_mov with memory operand
// ARM64: ARM_ldr, ARM_ldp, ARM_ldrb, ARM_ldrh, etc.
bool is_load_insn(uint16_t itype);

// Check if instruction is a LEA (load effective address)
// x86: NN_lea
// ARM64: ARM_adr, ARM_adrp (PC-relative address calculation)
bool is_lea_insn(uint16_t itype);

// Check if instruction is a NOP
// x86: NN_nop, or specific encodings
// ARM64: ARM_nop
bool is_nop_insn(uint16_t itype);

//--------------------------------------------------------------------------
// Pattern analysis helpers
//--------------------------------------------------------------------------

// Check if an instruction is a NOP (also checks raw bytes for x86)
bool is_nop_at_ea(ea_t addr);

// Check if operand is a register with the given role
bool is_reg_with_role(const op_t &op, int role_reg);

// Check if instruction is "mov <return_reg>, <first_arg_reg>"
// This is the core pattern for identity functions
// x86-64: mov rax, rdi
// ARM64:  mov x0, x0 (or just checking if x0 is unchanged)
bool is_identity_mov(const insn_t &insn);

// Check if instruction is an indirect jump via return register
// x86-64: jmp rax
// ARM64:  br x0 (or any register containing the target)
bool is_indirect_jump_via_return_reg(const insn_t &insn);

// Check if instruction is "mov <first_arg_reg>, [mem]" or equivalent load
// Used to detect argument loading before identity function calls
// x86-64: mov rdi, [mem]
// ARM64:  ldr x0, [mem]
bool is_arg_load_from_mem(const insn_t &insn, ea_t *out_mem_addr = nullptr);

//--------------------------------------------------------------------------
// Identity function analysis
//
// Identity functions return their first argument unchanged.
// Pattern varies by architecture:
//   x86-64: mov rax, rdi; ret
//   ARM64:  ret (x0 already contains first arg and is return reg)
//          or: mov x0, x0; ret (explicit identity)
//--------------------------------------------------------------------------

// Analyze if a function is an identity function
// Returns true if the function just returns its first argument
bool analyze_identity_function(ea_t func_ea);

//--------------------------------------------------------------------------
// Trampoline analysis
//
// Trampolines follow patterns like:
//   x86-64: mov rdi, [ptr]; call identity; jmp rax
//   ARM64:  ldr x0, [ptr]; bl identity; br x0
//--------------------------------------------------------------------------

// Check if code at addr is a trampoline pattern
// If so, optionally returns the global pointer address
bool is_trampoline_code(ea_t addr, ea_t *out_global_ptr = nullptr);

//--------------------------------------------------------------------------
// Architecture-specific instruction building (for patching)
//--------------------------------------------------------------------------

// Build a direct jump instruction
// Returns the number of bytes written to 'buf'
// x86-64: E9 <rel32> (5 bytes)
// ARM64:  B <imm26> (4 bytes) - limited range, may need stub
size_t build_direct_jump(uint8_t *buf, size_t buf_size, ea_t from_ea, ea_t to_ea);

// Build a direct call instruction
// Returns the number of bytes written to 'buf'
// x86-64: E8 <rel32> (5 bytes)
// ARM64:  BL <imm26> (4 bytes)
size_t build_direct_call(uint8_t *buf, size_t buf_size, ea_t from_ea, ea_t to_ea);

// Get the typical NOP instruction byte(s)
// x86: 0x90
// ARM64: 0xD503201F (NOP encoding)
size_t get_nop_bytes(uint8_t *buf, size_t buf_size);

// Get minimum instruction size
// x86: 1 (variable length)
// ARM64: 4 (fixed length)
size_t get_min_insn_size();

//--------------------------------------------------------------------------
// Pointer size helpers
//--------------------------------------------------------------------------

// Get pointer size in bytes (4 or 8)
int get_ptr_size();

// Read a pointer from the database
ea_t read_ptr(ea_t addr);

} // namespace arch

```

`src/deobf/analysis/ast.cpp`:

```cpp
#include "ast.h"
#include "../../common/simd.h"
#include <sstream>
#include <algorithm>

namespace chernobog {
namespace ast {

//--------------------------------------------------------------------------
// MBA-related opcodes that can be converted to AST
//--------------------------------------------------------------------------
static const std::set<mcode_t> MBA_OPCODES = {
    m_add, m_sub, m_mul, m_udiv, m_sdiv, m_umod, m_smod,
    m_and, m_or, m_xor, m_shl, m_shr, m_sar,
    m_bnot, m_neg, m_lnot,
    m_low, m_high, m_xds, m_xdu,
    m_sets, m_seto, m_setp, m_setnz, m_setz,
    m_setae, m_setb, m_seta, m_setbe,
    m_setg, m_setge, m_setl, m_setle,
    m_cfadd, m_ofadd
};

bool is_mba_opcode(mcode_t op) {
    return MBA_OPCODES.count(op) > 0;
}

//--------------------------------------------------------------------------
// Size utilities
//--------------------------------------------------------------------------
uint64_t size_mask(int size) {
    switch (size) {
        case 1: return 0xFFULL;
        case 2: return 0xFFFFULL;
        case 4: return 0xFFFFFFFFULL;
        case 8: return 0xFFFFFFFFFFFFFFFFULL;
        default: return 0xFFFFFFFFFFFFFFFFULL;
    }
}

uint64_t twos_complement_sub_value(int size) {
    // Returns 2^n for subtraction patterns
    switch (size) {
        case 1: return 0x100ULL;
        case 2: return 0x10000ULL;
        case 4: return 0x100000000ULL;
        case 8: return 0ULL;  // Wraps around
        default: return 0ULL;
    }
}

//--------------------------------------------------------------------------
// Opcode name for debugging
//--------------------------------------------------------------------------
const char* opcode_name(mcode_t op) {
    switch (op) {
        case m_add: return "add";
        case m_sub: return "sub";
        case m_mul: return "mul";
        case m_udiv: return "udiv";
        case m_sdiv: return "sdiv";
        case m_umod: return "umod";
        case m_smod: return "smod";
        case m_and: return "and";
        case m_or: return "or";
        case m_xor: return "xor";
        case m_shl: return "shl";
        case m_shr: return "shr";
        case m_sar: return "sar";
        case m_bnot: return "bnot";
        case m_neg: return "neg";
        case m_lnot: return "lnot";
        case m_low: return "low";
        case m_high: return "high";
        case m_xds: return "xds";
        case m_xdu: return "xdu";
        case m_sets: return "sets";
        case m_seto: return "seto";
        case m_setp: return "setp";
        case m_setnz: return "setnz";
        case m_setz: return "setz";
        case m_setae: return "setae";
        case m_setb: return "setb";
        case m_seta: return "seta";
        case m_setbe: return "setbe";
        case m_setg: return "setg";
        case m_setge: return "setge";
        case m_setl: return "setl";
        case m_setle: return "setle";
        case m_cfadd: return "cfadd";
        case m_ofadd: return "ofadd";
        default: return "?";
    }
}

//--------------------------------------------------------------------------
// Mop comparison ignoring size - OPTIMIZED
// Uses equal_insns() for mop_d instead of expensive dstr() string comparison
//--------------------------------------------------------------------------
bool mops_equal_ignore_size(const mop_t& a, const mop_t& b) {
    // Fast path: type must match
    if (SIMD_UNLIKELY(a.t != b.t))
        return false;

    switch (a.t) {
        case mop_r:  // Register - single int comparison (hot path)
            return a.r == b.r;
        case mop_n:  // Number constant
            if (SIMD_UNLIKELY(!a.nnn || !b.nnn)) return a.nnn == b.nnn;
            return a.nnn->value == b.nnn->value;
        case mop_S:  // Stack variable
            if (SIMD_UNLIKELY(!a.s || !b.s)) return a.s == b.s;
            return a.s->off == b.s->off;
        case mop_v:  // Global variable - single uint64 comparison
            return a.g == b.g;
        case mop_l:  // Local variable
            if (SIMD_UNLIKELY(!a.l || !b.l)) return a.l == b.l;
            return (a.l->idx == b.l->idx) & (a.l->off == b.l->off);
        case mop_d:  // Result of another instruction
            // OPTIMIZED: Use equal_insns() instead of expensive dstr() string comparison
            // dstr() creates a string allocation on every call - extremely slow
            if (SIMD_UNLIKELY(!a.d || !b.d)) return a.d == b.d;
            return a.d->equal_insns(*b.d, EQ_IGNSIZE);
        case mop_b:  // Block reference
            return a.b == b.b;
        case mop_f:  // Function call
            return false;  // Too complex to compare
        case mop_a:  // Address
            if (SIMD_UNLIKELY(!a.a || !b.a)) return a.a == b.a;
            return mops_equal_ignore_size(*a.a, *b.a);
        case mop_h:  // Helper function
            if (SIMD_UNLIKELY(!a.helper || !b.helper)) return a.helper == b.helper;
            return strcmp(a.helper, b.helper) == 0;
        case mop_str:  // String
            if (SIMD_UNLIKELY(!a.cstr || !b.cstr)) return a.cstr == b.cstr;
            return strcmp(a.cstr, b.cstr) == 0;
        case mop_z:  // Empty
            return true;
        default:
            return false;
    }
}

//--------------------------------------------------------------------------
// AstBase implementation
//--------------------------------------------------------------------------
AstBase::AstBase(const AstBase& other)
    : ast_index(other.ast_index)
    , dest_size(other.dest_size)
    , ea(other.ea)
    , mop(other.mop)
    , frozen(false)  // Copies are always mutable
{
}

void AstBase::freeze() {
    frozen = true;

    // CRITICAL: Clear mop fields to prevent crashes during static destruction.
    // When the AstCache destructor runs during program exit, IDA's internal
    // structures are already freed. The mop_t objects contain pointers to
    // these structures, so we must clear them before caching.
    mop.erase();

    // Recursively freeze children if this is a node
    if (auto node = dynamic_cast<AstNode*>(this)) {
        node->dst_mop.erase();
        if (node->left) {
            node->left->freeze();
        }
        if (node->right) {
            node->right->freeze();
        }
    }
}

AstPtr AstBase::ensure_mutable() {
    if (!frozen) {
        return shared_from_this();
    }
    return clone();
}

//--------------------------------------------------------------------------
// AstNode implementation
//--------------------------------------------------------------------------
AstNode::AstNode(mcode_t op, AstPtr l, AstPtr r)
    : opcode(op)
    , left(l)
    , right(r)
{
}

AstNode::AstNode(const AstNode& other)
    : AstBase(other)
    , opcode(other.opcode)
    , left(other.left ? other.left->clone() : nullptr)
    , right(other.right ? other.right->clone() : nullptr)
    , dst_mop(other.dst_mop)
{
}

AstPtr AstNode::clone() const {
    return std::make_shared<AstNode>(*this);
}

std::vector<std::string> AstNode::get_depth_signature(int depth) const {
    if (depth <= 0) {
        return {};
    }

    if (depth == 1) {
        // Return just the opcode at depth 1
        return {std::to_string(static_cast<int>(opcode))};
    }

    // Get signatures from children at depth-1
    std::vector<std::string> result;

    if (left) {
        auto left_sig = left->get_depth_signature(depth - 1);
        result.insert(result.end(), left_sig.begin(), left_sig.end());
    } else {
        result.push_back("N");  // No node
    }

    if (right) {
        auto right_sig = right->get_depth_signature(depth - 1);
        result.insert(result.end(), right_sig.begin(), right_sig.end());
    } else {
        result.push_back("N");  // No node (unary op or missing)
    }

    return result;
}

bool AstNode::equals(const AstBase& other) const {
    if (!other.is_node())
        return false;

    const AstNode& o = static_cast<const AstNode&>(other);
    if (opcode != o.opcode)
        return false;

    // Compare children
    if ((left == nullptr) != (o.left == nullptr))
        return false;
    if (left && !left->equals(*o.left))
        return false;

    if ((right == nullptr) != (o.right == nullptr))
        return false;
    if (right && !right->equals(*o.right))
        return false;

    return true;
}

std::string AstNode::to_string() const {
    std::ostringstream ss;
    ss << opcode_name(opcode) << "(";
    if (left) {
        ss << left->to_string();
    }
    if (right) {
        ss << ", " << right->to_string();
    }
    ss << ")";
    return ss.str();
}

void AstNode::reset_mops() {
    mop = mop_t();
    dst_mop = mop_t();
    if (left) {
        if (auto node = std::dynamic_pointer_cast<AstNode>(left)) {
            node->reset_mops();
        } else if (auto leaf = std::dynamic_pointer_cast<AstLeaf>(left)) {
            leaf->mop = mop_t();
        }
    }
    if (right) {
        if (auto node = std::dynamic_pointer_cast<AstNode>(right)) {
            node->reset_mops();
        } else if (auto leaf = std::dynamic_pointer_cast<AstLeaf>(right)) {
            leaf->mop = mop_t();
        }
    }
}

bool AstNode::check_pattern_and_copy_mops(AstPtr candidate) {
    // Reset mops before matching
    reset_mops();

    // Try to match structure and copy mops
    if (!copy_mops_from_ast(candidate)) {
        return false;
    }

    // Verify implicit equalities (same variable name = same value)
    return check_implicit_equalities();
}

bool AstNode::copy_mops_from_ast(AstPtr other) {
    if (!other || !other->is_node())
        return false;

    auto other_node = std::static_pointer_cast<AstNode>(other);

    // Opcode must match exactly
    if (opcode != other_node->opcode)
        return false;

    // Copy mops from this level
    mop = other_node->mop;
    dst_mop = other_node->dst_mop;
    dest_size = other_node->dest_size;
    ea = other_node->ea;

    // Recurse on left child
    if (left) {
        if (!other_node->left)
            return false;

        if (left->is_node()) {
            auto left_node = std::static_pointer_cast<AstNode>(left);
            if (!left_node->copy_mops_from_ast(other_node->left))
                return false;
        } else {
            // Leaf node - copy mop directly
            auto left_leaf = std::static_pointer_cast<AstLeaf>(left);
            if (!other_node->left->is_leaf())
                return false;

            // If pattern leaf is a constant, verify the candidate's value matches
            if (left_leaf->is_constant()) {
                auto const_leaf = std::static_pointer_cast<AstConstant>(left);
                // Candidate must be a number constant with matching value
                if (other_node->left->mop.t != mop_n || !other_node->left->mop.nnn)
                    return false;
                uint64_t expected = const_leaf->value;
                uint64_t actual = other_node->left->mop.nnn->value;
                uint64_t mask = size_mask(other_node->left->mop.size);
                if ((expected & mask) != (actual & mask))
                    return false;
            }

            left_leaf->mop = other_node->left->mop;
            left_leaf->dest_size = other_node->left->dest_size;
            left_leaf->ea = other_node->left->ea;
        }
    }

    // Recurse on right child
    if (right) {
        if (!other_node->right)
            return false;

        if (right->is_node()) {
            auto right_node = std::static_pointer_cast<AstNode>(right);
            if (!right_node->copy_mops_from_ast(other_node->right))
                return false;
        } else {
            auto right_leaf = std::static_pointer_cast<AstLeaf>(right);
            if (!other_node->right->is_leaf())
                return false;

            // If pattern leaf is a constant, verify the candidate's value matches
            if (right_leaf->is_constant()) {
                auto const_leaf = std::static_pointer_cast<AstConstant>(right);
                // Candidate must be a number constant with matching value
                if (other_node->right->mop.t != mop_n || !other_node->right->mop.nnn)
                    return false;
                uint64_t expected = const_leaf->value;
                uint64_t actual = other_node->right->mop.nnn->value;
                uint64_t mask = size_mask(other_node->right->mop.size);
                if ((expected & mask) != (actual & mask))
                    return false;
            }

            right_leaf->mop = other_node->right->mop;
            right_leaf->dest_size = other_node->right->dest_size;
            right_leaf->ea = other_node->right->ea;
        }
    } else if (other_node->right) {
        // Pattern has no right child but candidate does
        return false;
    }

    return true;
}

bool AstNode::check_implicit_equalities() const {
    // Get all leaves and check that same-named variables have equal mops
    auto leaves = get_leaf_list();
    std::map<std::string, mop_t> seen;

    for (const auto& leaf : leaves) {
        if (leaf->name.empty())
            continue;

        auto it = seen.find(leaf->name);
        if (it != seen.end()) {
            // Same variable name seen before - check equality
            if (!mops_equal_ignore_size(it->second, leaf->mop)) {
                return false;
            }
        } else {
            seen[leaf->name] = leaf->mop;
        }
    }

    return true;
}

void AstNode::collect_leaves(std::vector<AstLeafPtr>& out) const {
    if (left) {
        if (left->is_leaf()) {
            out.push_back(std::static_pointer_cast<AstLeaf>(left));
        } else if (left->is_node()) {
            std::static_pointer_cast<AstNode>(left)->collect_leaves(out);
        }
    }
    if (right) {
        if (right->is_leaf()) {
            out.push_back(std::static_pointer_cast<AstLeaf>(right));
        } else if (right->is_node()) {
            std::static_pointer_cast<AstNode>(right)->collect_leaves(out);
        }
    }
}

std::vector<AstLeafPtr> AstNode::get_leaf_list() const {
    std::vector<AstLeafPtr> result;
    collect_leaves(result);
    return result;
}

std::map<std::string, AstLeafPtr> AstNode::get_leafs_by_name() const {
    std::map<std::string, AstLeafPtr> result;
    auto leaves = get_leaf_list();
    for (const auto& leaf : leaves) {
        if (!leaf->name.empty()) {
            result[leaf->name] = leaf;
        }
    }
    return result;
}

//--------------------------------------------------------------------------
// AstLeaf implementation
//--------------------------------------------------------------------------
AstLeaf::AstLeaf(const std::string& n)
    : name(n)
{
}

AstLeaf::AstLeaf(const mop_t& m)
    : name(name_from_mop(m))
{
    mop = m;
    dest_size = m.size;
}

AstLeaf::AstLeaf(const AstLeaf& other)
    : AstBase(other)
    , name(other.name)
{
}

AstPtr AstLeaf::clone() const {
    return std::make_shared<AstLeaf>(*this);
}

std::vector<std::string> AstLeaf::get_depth_signature(int depth) const {
    (void)depth;  // Unused - leaves always return "L"
    return {"L"};
}

bool AstLeaf::equals(const AstBase& other) const {
    if (!other.is_leaf() || other.is_constant())
        return false;

    const AstLeaf& o = static_cast<const AstLeaf&>(other);
    return name == o.name;
}

std::string AstLeaf::to_string() const {
    return name;
}

std::string AstLeaf::name_from_mop(const mop_t& m) {
    std::ostringstream ss;
    switch (m.t) {
        case mop_r:
            ss << "r" << m.r;
            break;
        case mop_S:
            if (m.s) ss << "s" << std::hex << m.s->off;
            else ss << "s_null";
            break;
        case mop_v:
            ss << "g" << std::hex << m.g;
            break;
        case mop_l:
            if (m.l) ss << "l" << m.l->idx << "_" << m.l->off;
            else ss << "l_null";
            break;
        case mop_n:
            if (m.nnn) ss << "n" << std::hex << m.nnn->value;
            else ss << "n_null";
            break;
        case mop_d:
            if (m.d) ss << "d_" << m.d->dstr();
            else ss << "d_null";
            break;
        default:
            ss << "m" << static_cast<int>(m.t);
            break;
    }
    return ss.str();
}

//--------------------------------------------------------------------------
// AstConstant implementation
//--------------------------------------------------------------------------
AstConstant::AstConstant(uint64_t v, int size)
    : AstLeaf("")
    , value(v)
{
    dest_size = size;
    name = std::to_string(v);
}

AstConstant::AstConstant(const std::string& n, uint64_t v)
    : AstLeaf("")
    , value(v)
    , const_name(n)
{
    name = n;
}

AstConstant::AstConstant(const AstConstant& other)
    : AstLeaf(other)
    , value(other.value)
    , const_name(other.const_name)
{
}

AstPtr AstConstant::clone() const {
    return std::make_shared<AstConstant>(*this);
}

std::vector<std::string> AstConstant::get_depth_signature(int depth) const {
    (void)depth;  // Unused - constants always return "C"
    return {"C"};
}

bool AstConstant::equals(const AstBase& other) const {
    if (!other.is_constant())
        return false;

    const AstConstant& o = static_cast<const AstConstant&>(other);

    // Named constants match by name
    if (!const_name.empty() && !o.const_name.empty()) {
        return const_name == o.const_name;
    }

    // Value constants match by value
    return value == o.value;
}

std::string AstConstant::to_string() const {
    if (!const_name.empty()) {
        return const_name;
    }
    std::ostringstream ss;
    ss << "0x" << std::hex << value;
    return ss.str();
}

//--------------------------------------------------------------------------
// Non-mutating pattern match implementation - OPTIMIZED
// Matches pattern against candidate without modifying either AST
//--------------------------------------------------------------------------

// Internal recursive match function
static bool match_pattern_internal(const AstBase* pattern, const AstBase* candidate, 
                                   MatchBindings& bindings) {
    if (!pattern || !candidate) {
        return pattern == candidate;
    }
    
    // Handle leaf patterns
    if (pattern->is_leaf()) {
        if (pattern->is_constant()) {
            // Constant pattern - candidate must be a constant with matching value
            auto pat_const = static_cast<const AstConstant*>(pattern);
            
            // Candidate must have a number operand
            if (candidate->mop.t != mop_n || !candidate->mop.nnn) {
                return false;
            }
            
            // Named constants (like c_minus_1) - just capture binding
            if (!pat_const->const_name.empty()) {
                bindings.add(pat_const->const_name.c_str(), candidate->mop, 
                            candidate->dest_size, candidate->ea);
                return true;
            }
            
            // Value constants must match
            uint64_t expected = pat_const->value;
            uint64_t actual = candidate->mop.nnn->value;
            uint64_t mask = size_mask(candidate->mop.size);
            return (expected & mask) == (actual & mask);
        }
        
        // Variable leaf - capture binding
        auto pat_leaf = static_cast<const AstLeaf*>(pattern);
        
        // Check if this variable was already bound
        const mop_t* existing = bindings.find(pat_leaf->name);
        if (existing) {
            // Same variable must have same value (implicit equality)
            return mops_equal_ignore_size(*existing, candidate->mop);
        }
        
        // New binding
        bindings.add(pat_leaf->name.c_str(), candidate->mop, 
                    candidate->dest_size, candidate->ea);
        return true;
    }
    
    // Pattern is a node - candidate must also be a node
    if (!candidate->is_node()) {
        return false;
    }
    
    auto pat_node = static_cast<const AstNode*>(pattern);
    auto cand_node = static_cast<const AstNode*>(candidate);
    
    // Opcode must match
    if (pat_node->opcode != cand_node->opcode) {
        return false;
    }
    
    // Match left operand
    if (pat_node->left) {
        if (!cand_node->left) return false;
        if (!match_pattern_internal(pat_node->left.get(), cand_node->left.get(), bindings)) {
            return false;
        }
    }
    
    // Match right operand
    if (pat_node->right) {
        if (!cand_node->right) return false;
        if (!match_pattern_internal(pat_node->right.get(), cand_node->right.get(), bindings)) {
            return false;
        }
    } else if (cand_node->right) {
        // Pattern has no right but candidate does
        return false;
    }
    
    return true;
}

bool match_pattern(const AstBase* pattern, const AstBase* candidate, 
                   MatchBindings& bindings) {
    bindings.clear();
    return match_pattern_internal(pattern, candidate, bindings);
}

} // namespace ast
} // namespace chernobog

```

`src/deobf/analysis/ast.h`:

```h
#pragma once
#include "../deobf_types.h"
#include <memory>
#include <vector>
#include <map>
#include <string>

//--------------------------------------------------------------------------
// AST (Abstract Syntax Tree) System for Pattern-Based Deobfuscation
//
// This system provides:
//   - Tree representation of microcode expressions
//   - Hierarchical signature generation for efficient pattern matching
//   - Freezing mechanism for immutable pattern templates
//   - Pattern variable binding (x_0, x_1, etc.)
//
// Ported from d810-ng's ast.py with C++ optimizations
//--------------------------------------------------------------------------

namespace chernobog {
namespace ast {

// Forward declarations
class AstBase;
class AstNode;
class AstLeaf;
class AstConstant;

using AstPtr = std::shared_ptr<AstBase>;
using AstNodePtr = std::shared_ptr<AstNode>;
using AstLeafPtr = std::shared_ptr<AstLeaf>;
using AstConstPtr = std::shared_ptr<AstConstant>;

//--------------------------------------------------------------------------
// Opcodes that can be converted to AST (MBA-related)
//--------------------------------------------------------------------------
bool is_mba_opcode(mcode_t op);

//--------------------------------------------------------------------------
// AstBase - Abstract base class for all AST nodes
//--------------------------------------------------------------------------
class AstBase : public std::enable_shared_from_this<AstBase> {
public:
    // Virtual destructor that safely clears mop_t before destruction.
    // This is critical because mop_t's destructor may call IDA functions
    // that are unavailable during static destruction (after IDA unloads).
    virtual ~AstBase() {
        mop.erase();
    }

    // Type checking
    virtual bool is_node() const = 0;
    virtual bool is_leaf() const = 0;
    virtual bool is_constant() const { return false; }

    // Deep copy
    virtual AstPtr clone() const = 0;

    // Signature generation for pattern matching
    // Returns vector like ["10"] (opcode), ["L"] (leaf), ["C"] (constant), ["N"] (none)
    virtual std::vector<std::string> get_depth_signature(int depth) const = 0;

    // Equality check (structural)
    virtual bool equals(const AstBase& other) const = 0;

    // Debug string representation
    virtual std::string to_string() const = 0;

    // Metadata from microcode
    int ast_index = -1;         // Unique index in builder context
    int dest_size = 0;          // Size in bytes (1,2,4,8)
    ea_t ea = BADADDR;          // Address in binary
    mop_t mop;                  // Original microcode operand

    // Immutability for cached templates
    bool frozen = false;

    void freeze();
    bool is_frozen() const { return frozen; }

    // Get mutable copy if frozen
    AstPtr ensure_mutable();

protected:
    AstBase() = default;
    AstBase(const AstBase& other);
};

//--------------------------------------------------------------------------
// AstNode - Binary or unary operation node
//--------------------------------------------------------------------------
class AstNode : public AstBase {
public:
    mcode_t opcode;             // Operation (m_add, m_sub, m_xor, etc.)
    AstPtr left;                // Left operand (always present)
    AstPtr right;               // Right operand (nullptr for unary ops)
    mop_t dst_mop;              // Destination operand

    // Constructors
    AstNode(mcode_t op, AstPtr l, AstPtr r = nullptr);
    AstNode(const AstNode& other);

    // Destructor - clear dst_mop before destruction
    ~AstNode() override {
        dst_mop.erase();
    }

    // Type checking
    bool is_node() const override { return true; }
    bool is_leaf() const override { return false; }
    bool is_unary() const { return right == nullptr; }
    bool is_binary() const { return right != nullptr; }

    // Deep copy
    AstPtr clone() const override;

    // Signature generation
    std::vector<std::string> get_depth_signature(int depth) const override;

    // Equality
    bool equals(const AstBase& other) const override;

    // Debug
    std::string to_string() const override;

    //----------------------------------------------------------------------
    // Pattern matching operations
    //----------------------------------------------------------------------

    // Match this pattern against a candidate AST and copy operand references
    // Returns true if structure matches
    bool check_pattern_and_copy_mops(AstPtr candidate);

    // Get all leaf nodes in this subtree
    std::vector<AstLeafPtr> get_leaf_list() const;

    // Get leaves indexed by their variable names
    std::map<std::string, AstLeafPtr> get_leafs_by_name() const;

    // Reset all mop references (before pattern matching)
    void reset_mops();

private:
    // Internal pattern matching helper
    bool copy_mops_from_ast(AstPtr other);

    // Verify that same-named variables have equal mops
    bool check_implicit_equalities() const;

    // Collect leaves recursively
    void collect_leaves(std::vector<AstLeafPtr>& out) const;
};

//--------------------------------------------------------------------------
// AstLeaf - Variable or register leaf node
//--------------------------------------------------------------------------
class AstLeaf : public AstBase {
public:
    std::string name;           // Variable name ("x_0", "x_1", etc.)

    // Constructors
    explicit AstLeaf(const std::string& n);
    explicit AstLeaf(const mop_t& m);  // From microcode operand
    AstLeaf(const AstLeaf& other);

    // Type checking
    bool is_node() const override { return false; }
    bool is_leaf() const override { return true; }

    // Deep copy
    AstPtr clone() const override;

    // Signature - returns ["L"] for variable leaf
    std::vector<std::string> get_depth_signature(int depth) const override;

    // Equality
    bool equals(const AstBase& other) const override;

    // Debug
    std::string to_string() const override;

    // Generate a name from microcode operand
    static std::string name_from_mop(const mop_t& m);
};

//--------------------------------------------------------------------------
// AstConstant - Constant value leaf node
//--------------------------------------------------------------------------
class AstConstant : public AstLeaf {
public:
    uint64_t value;             // Constant value
    std::string const_name;     // Named constant (e.g., "c_minus_2")

    // Constructors
    AstConstant(uint64_t v, int size);
    AstConstant(const std::string& name, uint64_t v);
    AstConstant(const AstConstant& other);

    // Type checking
    bool is_constant() const override { return true; }

    // Deep copy
    AstPtr clone() const override;

    // Signature - returns ["C"] for constant
    std::vector<std::string> get_depth_signature(int depth) const override;

    // Equality
    bool equals(const AstBase& other) const override;

    // Debug
    std::string to_string() const override;
};

//--------------------------------------------------------------------------
// Pattern match bindings - stores captured operands without mutating pattern
//--------------------------------------------------------------------------
struct MatchBindings {
    static constexpr size_t MAX_BINDINGS = 8;  // x_0 through x_7 typically
    
    struct Binding {
        const char* name;  // Variable name (pointer to interned string)
        mop_t mop;         // Captured operand
        int dest_size;     // Size in bytes
        ea_t ea;           // Address
    };
    
    Binding bindings[MAX_BINDINGS];
    size_t count = 0;
    
    void clear() { count = 0; }
    
    bool add(const char* name, const mop_t& mop, int size, ea_t ea) {
        if (count >= MAX_BINDINGS) return false;
        bindings[count++] = {name, mop, size, ea};
        return true;
    }
    
    const mop_t* find(const std::string& name) const {
        for ( size_t i = 0; i < count; ++i ) {
            if ( name == bindings[i].name ) {
                return &bindings[i].mop;
            }
        }
        return nullptr;
    }
};

//--------------------------------------------------------------------------
// Non-mutating pattern match function (doesn't modify pattern AST)
// Returns true if pattern matches candidate, fills bindings
//--------------------------------------------------------------------------
bool match_pattern(const AstBase* pattern, const AstBase* candidate, 
                   MatchBindings& bindings);

//--------------------------------------------------------------------------
// Helper functions for creating AST nodes (for rule definitions)
//--------------------------------------------------------------------------

// Create a variable leaf node
inline AstPtr make_leaf(const std::string& name) {
    return std::make_shared<AstLeaf>(name);
}

// Create a constant leaf node
inline AstPtr make_const(uint64_t value, int size = 8) {
    return std::make_shared<AstConstant>(value, size);
}

// Create a named constant (for pattern matching with validation)
inline AstPtr make_named_const(const std::string& name, uint64_t value = 0) {
    return std::make_shared<AstConstant>(name, value);
}

// Create a binary operation node
inline AstPtr make_node(mcode_t op, AstPtr left, AstPtr right) {
    return std::make_shared<AstNode>(op, left, right);
}

// Create a unary operation node
inline AstPtr make_unary(mcode_t op, AstPtr operand) {
    return std::make_shared<AstNode>(op, operand, nullptr);
}

//--------------------------------------------------------------------------
// Utility functions
//--------------------------------------------------------------------------

// Get opcode name for debugging
const char* opcode_name(mcode_t op);

// Check if two mops are equal (ignoring size differences)
bool mops_equal_ignore_size(const mop_t& a, const mop_t& b);

// Size mask for given byte size
uint64_t size_mask(int size);

// Two's complement table for subtraction patterns
uint64_t twos_complement_sub_value(int size);

} // namespace ast
} // namespace chernobog

```

`src/deobf/analysis/ast_builder.cpp`:

```cpp
#include "ast_builder.h"
#include "../../common/simd.h"

namespace chernobog {
namespace ast {

//--------------------------------------------------------------------------
// MopKey implementation - OPTIMIZED
// Uses pre-computed hash to eliminate string allocations and enable O(1) lookup
//--------------------------------------------------------------------------

// Hash an instruction structure recursively (for mop_d operands)
uint64_t MopKey::hash_insn(const minsn_t* ins) {
    if (!ins) return 0;
    
    // Combine opcode, operand info, and recursive structure
    uint64_t h = simd::hash_u64(static_cast<uint64_t>(ins->opcode));
    
    // Hash left operand
    if (ins->l.t != mop_z) {
        MopKey left_key = from_mop(ins->l);
        h = simd::hash_combine(h, left_key.hash);
    }
    
    // Hash right operand
    if (ins->r.t != mop_z) {
        MopKey right_key = from_mop(ins->r);
        h = simd::hash_combine(h, right_key.hash);
    }
    
    // Include destination size
    h = simd::hash_combine(h, static_cast<uint64_t>(ins->d.size));
    
    return h;
}

MopKey MopKey::from_mop(const mop_t& mop) {
    MopKey key;
    key.type = static_cast<uint16_t>(mop.t);
    key.size = static_cast<uint16_t>(mop.size);
    key.value1 = 0;
    key.value2 = 0;
    key._pad = 0;

    switch (mop.t) {
        case mop_n:  // Number constant
            if (mop.nnn) {
                key.value1 = mop.nnn->value;
                // Include original value for constants to distinguish different occurrences
                key.value2 = mop.nnn->org_value;
            }
            break;

        case mop_r:  // Register
            key.value1 = mop.r;
            break;

        case mop_S:  // Stack variable
            if (mop.s) {
                key.value1 = static_cast<uint64_t>(mop.s->off);
            }
            break;

        case mop_v:  // Global variable
            key.value1 = mop.g;
            break;

        case mop_l:  // Local variable
            if (mop.l) {
                key.value1 = mop.l->idx;
                key.value2 = mop.l->off;
            }
            break;

        case mop_d:  // Result of another instruction
            // OPTIMIZED: Hash instruction structure instead of string
            if (mop.d) {
                key.value1 = hash_insn(mop.d);
                // Use secondary hash for collision resistance
                key.value2 = simd::hash_combine(
                    static_cast<uint64_t>(mop.d->opcode),
                    static_cast<uint64_t>(mop.d->ea)
                );
            }
            break;

        case mop_b:  // Block reference
            key.value1 = mop.b;
            break;

        case mop_a:  // Address operand
            if (mop.a) {
                MopKey inner = from_mop(*mop.a);
                key.value1 = inner.hash;  // Use inner hash
                key.value2 = inner.value1;
            }
            break;

        case mop_h:  // Helper function
            if (mop.helper) {
                key.value1 = simd::hash_bytes(mop.helper, strlen(mop.helper));
            }
            break;

        case mop_str:  // String
            if (mop.cstr) {
                key.value1 = simd::hash_bytes(mop.cstr, strlen(mop.cstr));
            }
            break;

        default:
            break;
    }

    // Compute final hash combining all fields
    key.hash = simd::hash_u64(key.type);
    key.hash = simd::hash_combine(key.hash, simd::hash_u64(key.size));
    key.hash = simd::hash_combine(key.hash, simd::hash_u64(key.value1));
    key.hash = simd::hash_combine(key.hash, simd::hash_u64(key.value2));

    return key;
}

//--------------------------------------------------------------------------
// AstBuilderContext implementation - OPTIMIZED
// Uses unordered_map with pre-computed hash for O(1) lookup
//--------------------------------------------------------------------------
AstPtr AstBuilderContext::get_or_create(const mop_t& mop) {
    MopKey key = MopKey::from_mop(mop);
    
    // O(1) lookup with pre-computed hash
    auto it = mop_to_ast_.find(key);
    if (it != mop_to_ast_.end()) {
        return it->second;
    }

    // Will be created by caller and added
    return nullptr;
}

//--------------------------------------------------------------------------
// AstCache implementation - OPTIMIZED
// Uses unordered_map with pre-computed hash for O(1) lookup
// Features:
//   - Prefetching hints for hot path
//   - Batch eviction to amortize cost
//   - Lock-free read path (future: reader-writer lock)
//--------------------------------------------------------------------------
AstCache& AstCache::instance() {
    static AstCache inst;
    return inst;
}

AstPtr AstCache::get(const MopKey& key) {
    std::lock_guard<std::mutex> lock(mutex_);

    // Prefetch likely bucket location based on hash
    size_t bucket = cache_.bucket(key);
    if (bucket < cache_.bucket_count()) {
        // Prefetch bucket memory for faster iteration
        auto bucket_begin = cache_.begin(bucket);
        if (bucket_begin != cache_.end(bucket)) {
            SIMD_PREFETCH_READ(&(*bucket_begin));
        }
    }

    auto it = cache_.find(key);
    if (SIMD_LIKELY(it != cache_.end())) {
        hit_count_++;
        // Return a mutable copy (the cached one is frozen)
        return it->second->clone();
    }

    miss_count_++;
    return nullptr;
}

void AstCache::put(const MopKey& key, AstPtr ast) {
    std::lock_guard<std::mutex> lock(mutex_);

    evict_if_needed();

    // Freeze and cache
    ast->freeze();
    cache_.emplace(key, std::move(ast));
}

void AstCache::clear() {
    std::lock_guard<std::mutex> lock(mutex_);
    cache_.clear();
    hit_count_ = 0;
    miss_count_ = 0;
}

void AstCache::evict_if_needed() {
    // Simple eviction: remove EVICTION_BATCH entries when full
    // Use batch eviction to amortize the cost of resizing
    if (SIMD_UNLIKELY(cache_.size() >= MAX_CACHE_SIZE)) {
        // Remove entries from the front (pseudo-FIFO)
        auto it = cache_.begin();
        for (size_t i = 0; i < EVICTION_BATCH && it != cache_.end(); i++) {
            it = cache_.erase(it);
        }
    }
}

//--------------------------------------------------------------------------
// Internal conversion functions
//--------------------------------------------------------------------------
static AstPtr mop_to_ast_internal(const mop_t& mop, AstBuilderContext& ctx, bool use_cache);

// Convert instruction operand (which may be another instruction)
static AstPtr convert_mop_d(const minsn_t* ins, AstBuilderContext& ctx) {
    if (!ins || !is_mba_opcode(ins->opcode)) {
        return nullptr;
    }

    // Convert left operand
    AstPtr left = nullptr;
    if (ins->l.t != mop_z) {
        left = mop_to_ast_internal(ins->l, ctx, false);
        if (!left) {
            // Create a leaf for non-convertible operand
            left = std::make_shared<AstLeaf>(ins->l);
        }
    }

    // Convert right operand (for binary ops)
    AstPtr right = nullptr;
    if (ins->r.t != mop_z) {
        right = mop_to_ast_internal(ins->r, ctx, false);
        if (!right) {
            right = std::make_shared<AstLeaf>(ins->r);
        }
    }

    // Create node
    auto node = std::make_shared<AstNode>(ins->opcode, left, right);
    node->ea = ins->ea;
    node->dest_size = ins->d.size;
    node->dst_mop = ins->d;

    return node;
}

static AstPtr mop_to_ast_internal(const mop_t& mop, AstBuilderContext& ctx, bool use_cache) {
    if (mop.t == mop_z) {
        return nullptr;
    }

    MopKey key = MopKey::from_mop(mop);

    // Check context first (deduplication)
    if (ctx.has(key)) {
        return ctx.get(key);
    }

    // NOTE: Global cache is DISABLED because freeze() erases mop fields,
    // and the cloned AST nodes have mop_z which breaks pattern matching.
    // The mop field is needed to verify implicit equalities (e.g., x_0 == x_0).
    // TODO: Fix caching to preserve or restore mop fields after cloning.
    /*
    if (use_cache) {
        AstPtr cached = AstCache::instance().get(key);
        if (cached) {
            ctx.add(key, cached);
            return cached;
        }
    }
    */

    AstPtr result = nullptr;

    switch (mop.t) {
        case mop_n: {
            // Numeric constant
            if (!mop.nnn) {
                // Fallback to leaf if nnn is null
                result = std::make_shared<AstLeaf>(mop);
                break;
            }
            auto c = std::make_shared<AstConstant>(mop.nnn->value, mop.size);
            c->mop = mop;
            c->dest_size = mop.size;
            result = c;
            break;
        }

        case mop_d: {
            // Result of another instruction - recurse
            if (!mop.d) {
                // Fallback to leaf if d is null
                result = std::make_shared<AstLeaf>(mop);
                break;
            }
            result = convert_mop_d(mop.d, ctx);
            if (result) {
                result->mop = mop;
            }
            break;
        }

        case mop_r:    // Register
        case mop_S:    // Stack variable
        case mop_v:    // Global variable
        case mop_l:    // Local variable
        case mop_b:    // Block reference
        case mop_a:    // Address
        case mop_h:    // Helper
        case mop_str:  // String
        default: {
            // Create leaf node
            auto leaf = std::make_shared<AstLeaf>(mop);
            result = leaf;
            break;
        }
    }

    if (result) {
        result->dest_size = mop.size;
        ctx.add(key, result);

        // NOTE: Global cache put is DISABLED - see note above about mop erasing
        /*
        if (use_cache) {
            AstCache::instance().put(key, result->clone());
        }
        */
    }

    return result;
}

//--------------------------------------------------------------------------
// Public conversion functions
//--------------------------------------------------------------------------
AstPtr mop_to_ast(const mop_t& mop) {
    AstBuilderContext ctx;
    return mop_to_ast_internal(mop, ctx, true);
}

AstPtr mop_to_ast_with_context(const mop_t& mop, AstBuilderContext& ctx) {
    return mop_to_ast_internal(mop, ctx, false);
}

AstPtr minsn_to_ast(const minsn_t* ins) {
    if (!ins || !is_mba_opcode(ins->opcode)) {
        return nullptr;
    }

    AstBuilderContext ctx;

    // Convert left operand
    AstPtr left = nullptr;
    if (ins->l.t != mop_z) {
        left = mop_to_ast_internal(ins->l, ctx, true);
        if (!left) {
            left = std::make_shared<AstLeaf>(ins->l);
        }
    }

    // Convert right operand
    AstPtr right = nullptr;
    if (ins->r.t != mop_z) {
        right = mop_to_ast_internal(ins->r, ctx, true);
        if (!right) {
            right = std::make_shared<AstLeaf>(ins->r);
        }
    }

    // Create root node
    auto node = std::make_shared<AstNode>(ins->opcode, left, right);
    node->ea = ins->ea;
    node->dest_size = ins->d.size;
    node->dst_mop = ins->d;
    node->mop = ins->d;

    return node;
}

AstPtr minsn_to_ast_with_context(const minsn_t* ins, AstBuilderContext& ctx) {
    if (!ins || !is_mba_opcode(ins->opcode)) {
        return nullptr;
    }

    // Convert left operand
    AstPtr left = nullptr;
    if (ins->l.t != mop_z) {
        left = mop_to_ast_internal(ins->l, ctx, false);
        if (!left) {
            left = std::make_shared<AstLeaf>(ins->l);
        }
    }

    // Convert right operand
    AstPtr right = nullptr;
    if (ins->r.t != mop_z) {
        right = mop_to_ast_internal(ins->r, ctx, false);
        if (!right) {
            right = std::make_shared<AstLeaf>(ins->r);
        }
    }

    // Create root node
    auto node = std::make_shared<AstNode>(ins->opcode, left, right);
    node->ea = ins->ea;
    node->dest_size = ins->d.size;
    node->dst_mop = ins->d;
    node->mop = ins->d;

    return node;
}

//--------------------------------------------------------------------------
// Reverse conversion - AST to microcode
//--------------------------------------------------------------------------
mop_t ast_leaf_to_mop(AstLeafPtr leaf, const std::map<std::string, mop_t>& bindings) {
    if (!leaf) {
        return mop_t();
    }

    // Check if it's a constant FIRST - constants in replacements should use
    // their literal values, not values captured from the pattern
    if (leaf->is_constant()) {
        auto constant = std::static_pointer_cast<AstConstant>(leaf);
        mop_t result;
        // Use a reasonable default size if dest_size is 0
        int size = leaf->dest_size > 0 ? leaf->dest_size : 4;
        result.make_number(constant->value, size);
        return result;
    }

    // Check if it's a named variable with a binding
    auto it = bindings.find(leaf->name);
    if (it != bindings.end()) {
        return it->second;
    }

    // Return the original mop if available
    if (leaf->mop.t != mop_z) {
        return leaf->mop;
    }

    // Can't resolve
    return mop_t();
}

minsn_t* ast_to_minsn(AstPtr ast,
                      const std::map<std::string, mop_t>& bindings,
                      mblock_t* blk,
                      ea_t ea) {
    if (!ast) {
        return nullptr;
    }

    // Handle leaf nodes
    if (ast->is_leaf()) {
        // Leaf nodes can't be converted to instructions directly
        // They represent operands, not operations
        return nullptr;
    }

    // Must be a node
    auto node = std::static_pointer_cast<AstNode>(ast);

    // Create new instruction
    minsn_t* ins = new minsn_t(ea);
    ins->opcode = node->opcode;

    // Convert left operand
    if (node->left) {
        if (node->left->is_leaf()) {
            ins->l = ast_leaf_to_mop(std::static_pointer_cast<AstLeaf>(node->left), bindings);
        } else {
            // Nested operation - need to create sub-instruction
            auto sub_node = std::static_pointer_cast<AstNode>(node->left);
            minsn_t* sub_ins = ast_to_minsn(node->left, bindings, blk, ea);
            if (sub_ins) {
                ins->l.create_from_insn(sub_ins);
                delete sub_ins;
            }
        }
    }

    // Convert right operand
    if (node->right) {
        if (node->right->is_leaf()) {
            ins->r = ast_leaf_to_mop(std::static_pointer_cast<AstLeaf>(node->right), bindings);
        } else {
            auto sub_node = std::static_pointer_cast<AstNode>(node->right);
            minsn_t* sub_ins = ast_to_minsn(node->right, bindings, blk, ea);
            if (sub_ins) {
                ins->r.create_from_insn(sub_ins);
                delete sub_ins;
            }
        }
    }

    // Set destination size
    ins->d.size = node->dest_size > 0 ? node->dest_size : 8;

    // Ensure operand sizes are valid (mop_t default constructor leaves size uninitialized)
    if (ins->l.t == mop_z) {
        ins->l.size = 0;
    }
    if (ins->r.t == mop_z) {
        ins->r.size = 0;
    }

    return ins;
}

//--------------------------------------------------------------------------
// Cache management
//--------------------------------------------------------------------------
void clear_ast_caches() {
    AstCache::instance().clear();
}

AstCacheStats get_ast_cache_stats() {
    AstCacheStats stats;
    stats.cache_size = AstCache::instance().size();
    stats.hit_count = AstCache::instance().hits();
    stats.miss_count = AstCache::instance().misses();

    size_t total = stats.hit_count + stats.miss_count;
    stats.hit_rate = (total > 0) ? (double)stats.hit_count / total : 0.0;

    return stats;
}

} // namespace ast
} // namespace chernobog

```

`src/deobf/analysis/ast_builder.h`:

```h
#pragma once
#include "ast.h"
#include "../../common/simd.h"
#include <unordered_map>
#include <mutex>

//--------------------------------------------------------------------------
// AST Builder - Converts IDA microcode to AST representation
//
// Features:
//   - Recursive conversion of mop_t and minsn_t to AST
//   - Deduplication context to prevent exponential explosion
//   - Global LRU cache for converted ASTs
//   - Thread-safe cache access
//   - OPTIMIZED: Hash-based key comparison, no string allocations
//
// Ported from d810-ng's tracker.py with C++ optimizations
//--------------------------------------------------------------------------

namespace chernobog {
namespace ast {

//--------------------------------------------------------------------------
// Cache key for mop_t - OPTIMIZED
// Uses hash-based comparison to eliminate string allocations and comparisons.
// The key is designed to fit in 32 bytes for cache efficiency.
//--------------------------------------------------------------------------
struct alignas(32) MopKey {
    uint64_t hash;          // Pre-computed hash for fast comparison
    uint64_t value1;        // Primary identifier (depends on type)
    uint64_t value2;        // Secondary identifier / hash extension
    uint16_t type;          // mopt_t (fits in 16 bits)
    uint16_t size;          // operand size
    uint32_t _pad;          // Alignment padding

    static MopKey from_mop(const mop_t& mop);
    
    // Compute hash for minsn_t (used for mop_d)
    static uint64_t hash_insn(const minsn_t* ins);

    bool operator<(const MopKey& other) const {
        // Compare hash first (most discriminating)
        if (hash != other.hash) return hash < other.hash;
        if (type != other.type) return type < other.type;
        if (value1 != other.value1) return value1 < other.value1;
        if (value2 != other.value2) return value2 < other.value2;
        return size < other.size;
    }
    
    bool operator==(const MopKey& other) const {
        // Fast path: compare hash first (single comparison covers most cases)
        if (hash != other.hash) return false;
        // Full comparison for hash collision resolution
        return type == other.type && 
               value1 == other.value1 && 
               value2 == other.value2 &&
               size == other.size;
    }

    // Hash function for unordered_map
    struct Hash {
        size_t operator()(const MopKey& k) const noexcept {
            // Hash is pre-computed, just return it
            return static_cast<size_t>(k.hash);
        }
    };
};

//--------------------------------------------------------------------------
// Deduplication context for AST building
// Prevents exponential explosion when same mop appears multiple times
// OPTIMIZED: Uses unordered_map with pre-computed hash for O(1) lookup
//--------------------------------------------------------------------------
class AstBuilderContext {
public:
    AstBuilderContext() {
        // Reserve reasonable capacity to avoid rehashing
        mop_to_ast_.reserve(64);
    }

    // Get or create AST for mop, with deduplication
    AstPtr get_or_create(const mop_t& mop);

    // Check if mop is already in context
    SIMD_FORCE_INLINE bool has(const MopKey& key) const {
        return mop_to_ast_.find(key) != mop_to_ast_.end();
    }

    // Get existing AST by key
    SIMD_FORCE_INLINE AstPtr get(const MopKey& key) const {
        auto p = mop_to_ast_.find(key);
        return ( p != mop_to_ast_.end() ) ? p->second : nullptr;
    }

    // Add new AST to context
    SIMD_FORCE_INLINE void add(const MopKey& key, AstPtr ast) {
        ast->ast_index = next_index_++;
        mop_to_ast_.emplace(key, std::move(ast));
    }

    // Clear the context
    void clear() {
        mop_to_ast_.clear();
        next_index_ = 0;
    }

private:
    std::unordered_map<MopKey, AstPtr, MopKey::Hash> mop_to_ast_;
    int next_index_ = 0;
};

//--------------------------------------------------------------------------
// Global AST cache with LRU eviction
// OPTIMIZED: Uses unordered_map with pre-computed hash for O(1) lookup
//--------------------------------------------------------------------------
class AstCache {
public:
    static constexpr size_t MAX_CACHE_SIZE = 20480;
    static constexpr size_t EVICTION_BATCH = MAX_CACHE_SIZE / 10;

    static AstCache& instance();

    // Get cached AST (returns nullptr if not cached)
    AstPtr get(const MopKey& key);

    // Add AST to cache (freezes the AST)
    void put(const MopKey& key, AstPtr ast);

    // Clear cache
    void clear();

    // Get cache statistics
    size_t size() const { return cache_.size(); }
    size_t hits() const { return hit_count_; }
    size_t misses() const { return miss_count_; }

private:
    AstCache() {
        // Reserve capacity to minimize rehashing
        cache_.reserve(MAX_CACHE_SIZE);
    }

    std::mutex mutex_;
    std::unordered_map<MopKey, AstPtr, MopKey::Hash> cache_;
    size_t hit_count_ = 0;
    size_t miss_count_ = 0;

    // Simple eviction: remove entries when full
    void evict_if_needed();
};

//--------------------------------------------------------------------------
// Main conversion functions
//--------------------------------------------------------------------------

// Convert microcode instruction to AST
// Returns nullptr if instruction cannot be converted (non-MBA opcode)
AstPtr minsn_to_ast(const minsn_t* ins);

// Convert microcode operand to AST
// Uses global cache for performance
AstPtr mop_to_ast(const mop_t& mop);

// Convert with explicit context (for recursive building)
AstPtr mop_to_ast_with_context(const mop_t& mop, AstBuilderContext& ctx);

// Convert instruction with explicit context
AstPtr minsn_to_ast_with_context(const minsn_t* ins, AstBuilderContext& ctx);

//--------------------------------------------------------------------------
// Reverse conversion - AST back to microcode
//--------------------------------------------------------------------------

// Create new minsn_t from AST and variable bindings
// bindings maps variable names to actual mop_t values
minsn_t* ast_to_minsn(AstPtr ast,
                      const std::map<std::string, mop_t>& bindings,
                      mblock_t* blk,
                      ea_t ea);

// Create mop_t from AST leaf
mop_t ast_leaf_to_mop(AstLeafPtr leaf,
                      const std::map<std::string, mop_t>& bindings);

//--------------------------------------------------------------------------
// Cache management
//--------------------------------------------------------------------------

// Clear all AST caches (call on function change)
void clear_ast_caches();

// Get cache statistics
struct AstCacheStats {
    size_t cache_size;
    size_t hit_count;
    size_t miss_count;
    double hit_rate;
};
AstCacheStats get_ast_cache_stats();

} // namespace ast
} // namespace chernobog

```

`src/deobf/analysis/cfg_analysis.cpp`:

```cpp
#include "cfg_analysis.h"
#include "pattern_match.h"
#include <iterator>  // for std::inserter

namespace cfg_analysis {

//--------------------------------------------------------------------------
// Build CFG information
//--------------------------------------------------------------------------
std::vector<block_info_t> analyze_cfg(mbl_array_t *mba) {
    std::vector<block_info_t> blocks;

    if ( !mba )
        return blocks;

    blocks.resize(mba->qty);

    // First pass: collect basic info and successors
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        blocks[i].block_idx = i;
        blocks[i].dominator = -1;
        blocks[i].post_dominator = -1;
        blocks[i].is_loop_header = false;
        blocks[i].is_loop_exit = false;
        blocks[i].loop_depth = 0;

        if ( !blk )
            continue;

        // Get successors
        for ( int j = 0; j < blk->nsucc(); ++j ) {
            int succ = blk->succ(j);
            if ( succ >= 0 && succ < mba->qty ) {
                blocks[i].successors.push_back(succ);
            }
        }
    }

    // Second pass: compute predecessors from successors
    for ( int i = 0; i < mba->qty; ++i ) {
        for (int succ : blocks[i].successors) {
            if ( succ >= 0 && succ < (int)blocks.size() ) {
                blocks[succ].predecessors.push_back(i);
            }
        }
    }

    // Compute dominators
    compute_dominators(mba, blocks);

    return blocks;
}

//--------------------------------------------------------------------------
// Compute immediate dominators using iterative dataflow
//--------------------------------------------------------------------------
void compute_dominators(mbl_array_t *mba, std::vector<block_info_t> &blocks) {
    if (!mba || blocks.empty())
        return;

    int n = blocks.size();

    // Initialize: every block dominated by all blocks except entry
    std::vector<std::set<int>> dom(n);
    for (int i = 0; i < n; i++) {
        if (i == 0) {
            dom[i].insert(0);  // Entry dominates itself
        } else {
            for (int j = 0; j < n; j++)
                dom[i].insert(j);
        }
    }

    // Iterate until fixpoint
    bool changed = true;
    while (changed) {
        changed = false;

        for (int i = 1; i < n; i++) {  // Skip entry block
            std::set<int> new_dom;

            // Dom(n) = {n} U intersection of Dom(pred) for all predecessors
            bool first = true;
            for (int pred : blocks[i].predecessors) {
                if (first) {
                    new_dom = dom[pred];
                    first = false;
                } else {
                    std::set<int> intersection;
                    std::set_intersection(new_dom.begin(), new_dom.end(),
                                         dom[pred].begin(), dom[pred].end(),
                                         std::inserter(intersection, intersection.begin()));
                    new_dom = intersection;
                }
            }

            new_dom.insert(i);  // Block always dominates itself

            if (new_dom != dom[i]) {
                dom[i] = new_dom;
                changed = true;
            }
        }
    }

    // Extract immediate dominators
    for (int i = 1; i < n; i++) {
        // idom is the closest dominator that is not the block itself
        for (int d : dom[i]) {
            if (d != i) {
                // Check if d is immediate (no other dominator between d and i)
                bool is_immediate = true;
                for (int other : dom[i]) {
                    if (other != i && other != d) {
                        // Check if other is dominated by d
                        if (dom[other].count(d) && dom[i].count(other)) {
                            is_immediate = false;
                            break;
                        }
                    }
                }
                if (is_immediate) {
                    blocks[i].dominator = d;
                    break;
                }
            }
        }
    }
}

//--------------------------------------------------------------------------
// Find natural loops
//--------------------------------------------------------------------------
std::vector<loop_info_t> find_loops(mbl_array_t *mba, const std::vector<block_info_t> &blocks) {
    std::vector<loop_info_t> loops;

    if (!mba || blocks.empty())
        return loops;

    // Find backedges (edge n -> h where h dominates n)
    for (size_t i = 0; i < blocks.size(); i++) {
        for (int succ : blocks[i].successors) {
            // Check if successor dominates this block (backedge)
            if (dominates(succ, i, blocks)) {
                // Found a backedge from i to succ
                // succ is the loop header

                // Check if we already have a loop with this header
                loop_info_t *existing = nullptr;
                for (auto &loop : loops) {
                    if (loop.header == succ) {
                        existing = &loop;
                        break;
                    }
                }

                if (existing) {
                    existing->backedges.push_back(i);
                } else {
                    loop_info_t loop;
                    loop.header = succ;
                    loop.backedges.push_back(i);
                    loops.push_back(loop);
                }
            }
        }
    }

    // For each loop, find all blocks in the body
    for (auto &loop : loops) {
        loop.body.insert(loop.header);

        // Use worklist to find all blocks that reach backedge sources
        std::vector<int> worklist = loop.backedges;
        while (!worklist.empty()) {
            int blk = worklist.back();
            worklist.pop_back();

            if (loop.body.count(blk))
                continue;

            loop.body.insert(blk);

            // Add predecessors to worklist
            for (int pred : blocks[blk].predecessors) {
                if (!loop.body.count(pred)) {
                    worklist.push_back(pred);
                }
            }
        }

        // Find exit blocks (blocks in loop with successor outside loop)
        for (int blk : loop.body) {
            for (int succ : blocks[blk].successors) {
                if (!loop.body.count(succ)) {
                    loop.exits.push_back(blk);
                    break;
                }
            }
        }
    }

    return loops;
}

//--------------------------------------------------------------------------
// Check if A dominates B
//--------------------------------------------------------------------------
bool dominates(int a, int b, const std::vector<block_info_t> &blocks) {
    if (a == b)
        return true;

    // Walk up dominator tree from b
    int curr = b;
    while (curr >= 0 && curr < (int)blocks.size()) {
        if (blocks[curr].dominator == a)
            return true;
        if (blocks[curr].dominator == curr || blocks[curr].dominator < 0)
            break;
        curr = blocks[curr].dominator;
    }

    return false;
}

//--------------------------------------------------------------------------
// Get all reachable blocks
//--------------------------------------------------------------------------
std::set<int> get_reachable(int from, mbl_array_t *mba) {
    std::set<int> reachable;

    if (!mba || from < 0 || from >= mba->qty)
        return reachable;

    std::vector<int> worklist;
    worklist.push_back(from);

    while (!worklist.empty()) {
        int curr = worklist.back();
        worklist.pop_back();

        if (reachable.count(curr))
            continue;

        reachable.insert(curr);

        mblock_t *blk = mba->get_mblock(curr);
        if ( !blk )
            continue;

        for (int i = 0; i < blk->nsucc(); i++) {
            int succ = blk->succ(i);
            if (succ >= 0 && !reachable.count(succ)) {
                worklist.push_back(succ);
            }
        }
    }

    return reachable;
}

//--------------------------------------------------------------------------
// Get all blocks that can reach target
//--------------------------------------------------------------------------
std::set<int> get_reaching(int to, mbl_array_t *mba) {
    std::set<int> reaching;

    if (!mba || to < 0 || to >= mba->qty)
        return reaching;

    // Build predecessor map
    std::vector<std::vector<int>> preds(mba->qty);
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk )
            continue;

        for ( int j = 0; j < blk->nsucc(); ++j ) {
            int succ = blk->succ(j);
            if ( succ >= 0 && succ < mba->qty ) {
                preds[succ].push_back(i);
            }
        }
    }

    // BFS backwards from target
    std::vector<int> worklist;
    worklist.push_back(to);

    while (!worklist.empty()) {
        int curr = worklist.back();
        worklist.pop_back();

        if (reaching.count(curr))
            continue;

        reaching.insert(curr);

        for (int pred : preds[curr]) {
            if (!reaching.count(pred)) {
                worklist.push_back(pred);
            }
        }
    }

    return reaching;
}

//--------------------------------------------------------------------------
// Find dispatcher block (for control flow flattening)
//--------------------------------------------------------------------------
int find_dispatcher_block(mbl_array_t *mba) {
    if ( !mba )
        return -1;

    // The dispatcher block typically:
    // 1. Has many successors (one per case)
    // 2. Contains a switch/jtbl instruction or many conditional jumps
    // 3. Is part of a loop (has backedges to it)

    int best_candidate = -1;
    int max_succs = 0;

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk )
            continue;

        int nsucc = blk->nsucc();

        // Look for jtbl instruction
        if (blk->tail && blk->tail->opcode == m_jtbl) {
            return i;  // Definitely the dispatcher
        }

        // Count conditional jumps
        int jcc_count = 0;
        for (minsn_t *ins = blk->head; ins; ins = ins->next) {
            if (deobf::is_jcc(ins->opcode))
                jcc_count++;
        }

        // Block with many conditional jumps is likely dispatcher
        if (jcc_count >= 3 && jcc_count > max_succs) {
            max_succs = jcc_count;
            best_candidate = i;
        }

        // Block with many successors is likely dispatcher
        if (nsucc > 3 && nsucc > max_succs) {
            max_succs = nsucc;
            best_candidate = i;
        }
    }

    return best_candidate;
}

//--------------------------------------------------------------------------
// Find backedge targets
//--------------------------------------------------------------------------
std::vector<int> find_backedge_targets(mbl_array_t *mba) {
    std::vector<int> targets;

    if ( !mba )
        return targets;

    auto blocks = analyze_cfg(mba);

    for (size_t i = 0; i < blocks.size(); i++) {
        for (int succ : blocks[i].successors) {
            if (dominates(succ, i, blocks)) {
                // Found backedge to succ
                if (std::find(targets.begin(), targets.end(), succ) == targets.end()) {
                    targets.push_back(succ);
                }
            }
        }
    }

    return targets;
}

//--------------------------------------------------------------------------
// Check if block is dead
//--------------------------------------------------------------------------
bool is_dead_block(mblock_t *blk, mbl_array_t *mba, deobf_ctx_t *ctx) {
    if (!blk || !mba)
        return false;

    // Check if block has no predecessors (except entry block)
    int blk_idx = blk->serial;
    if (blk_idx != 0 && blk->npred() == 0)
        return true;

    // Check if all incoming branches are always-false
    // This would require analyzing the conditions at predecessor blocks

    return false;
}

//--------------------------------------------------------------------------
// Get branch condition for edge
//--------------------------------------------------------------------------
minsn_t *get_branch_condition(int from_blk, int to_blk, mbl_array_t *mba) {
    if ( !mba )
        return nullptr;

    mblock_t *blk = mba->get_mblock(from_blk);
    if (!blk || !blk->tail)
        return nullptr;

    minsn_t *tail = blk->tail;

    // Unconditional jump - no condition
    if (tail->opcode == m_goto)
        return nullptr;

    // Conditional jump
    if (deobf::is_jcc(tail->opcode)) {
        // Check if this jump goes to to_blk
        if (tail->d.t == mop_b && tail->d.b == to_blk) {
            return tail;
        }
    }

    return nullptr;
}

} // namespace cfg_analysis

```

`src/deobf/analysis/cfg_analysis.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Control Flow Graph analysis utilities
//--------------------------------------------------------------------------
namespace cfg_analysis {

// Basic block information
struct block_info_t {
    int block_idx;
    std::vector<int> predecessors;
    std::vector<int> successors;
    int dominator;              // Immediate dominator
    int post_dominator;         // Immediate post-dominator
    bool is_loop_header;
    bool is_loop_exit;
    int loop_depth;
};

// Build CFG info for all blocks
std::vector<block_info_t> analyze_cfg(mbl_array_t *mba);

// Compute dominators
void compute_dominators(mbl_array_t *mba, std::vector<block_info_t> &blocks);

// Find natural loops
struct loop_info_t {
    int header;                 // Loop header block
    std::set<int> body;        // All blocks in loop body
    std::vector<int> exits;    // Exit blocks
    std::vector<int> backedges;// Blocks with backedges to header
};

std::vector<loop_info_t> find_loops(mbl_array_t *mba, const std::vector<block_info_t> &blocks);

// Check if block A dominates block B
bool dominates(int a, int b, const std::vector<block_info_t> &blocks);

// Get all blocks reachable from a given block
std::set<int> get_reachable(int from, mbl_array_t *mba);

// Get all blocks that can reach a given block
std::set<int> get_reaching(int to, mbl_array_t *mba);

// Find dispatcher block (for deflattening)
// Returns -1 if not found
int find_dispatcher_block(mbl_array_t *mba);

// Find loop back edge targets (for deflattening)
std::vector<int> find_backedge_targets(mbl_array_t *mba);

// Check if a block is dead (unreachable or always-false branch)
bool is_dead_block(mblock_t *blk, mbl_array_t *mba, deobf_ctx_t *ctx);

// Get the condition that leads to a block
// Returns nullptr if unconditional
minsn_t *get_branch_condition(int from_blk, int to_blk, mbl_array_t *mba);

} // namespace cfg_analysis

```

`src/deobf/analysis/chain_simplify.cpp`:

```cpp
#include "chain_simplify.h"

namespace chernobog {
namespace chain {

//--------------------------------------------------------------------------
// Utility functions - OPTIMIZED
//--------------------------------------------------------------------------

// Fast operand equality check with early-out and SIMD hints
SIMD_FORCE_INLINE bool ChainSimplifier::operands_equal(const mop_t& a, const mop_t& b) {
    // Fast path: type and size must match
    // Combine checks into single comparison where possible
    if (SIMD_UNLIKELY(a.t != b.t)) return false;
    if (SIMD_UNLIKELY(a.size != b.size)) return false;

    // Type-specific comparison
    switch (a.t) {
        case mop_r:  // Register - single int comparison
            return a.r == b.r;

        case mop_n:  // Number constant
            // Null check first
            if (SIMD_UNLIKELY(!a.nnn || !b.nnn)) return a.nnn == b.nnn;
            return a.nnn->value == b.nnn->value;

        case mop_S:  // Stack variable
            if (SIMD_UNLIKELY(!a.s || !b.s)) return a.s == b.s;
            return a.s->off == b.s->off;

        case mop_v:  // Global variable - single uint64 comparison
            return a.g == b.g;

        case mop_l:  // Local variable
            if (SIMD_UNLIKELY(!a.l || !b.l)) return a.l == b.l;
            // Combine comparisons
            return (a.l->idx == b.l->idx) & (a.l->off == b.l->off);

        case mop_d:  // Result of another instruction
            // Compare instruction content (most expensive case)
            if (SIMD_UNLIKELY(!a.d || !b.d)) return a.d == b.d;
            return a.d->equal_insns(*b.d, EQ_IGNSIZE);

        default:
            return false;
    }
}

bool ChainSimplifier::is_not_of(const mop_t& a, const mop_t& b) {
    // Check if a = ~b
    if (a.t != mop_d || !a.d)
        return false;

    if (a.d->opcode != m_bnot)
        return false;

    return operands_equal(a.d->l, b);
}

bool ChainSimplifier::is_neg_of(const mop_t& a, const mop_t& b) {
    // Check if a = -b
    if (a.t != mop_d || !a.d)
        return false;

    if (a.d->opcode != m_neg)
        return false;

    return operands_equal(a.d->l, b);
}

bool ChainSimplifier::get_const_value(const mop_t& mop, uint64_t* out) {
    if (mop.t != mop_n)
        return false;

    *out = mop.nnn->value;
    return true;
}

uint64_t ChainSimplifier::get_identity_element(mcode_t op, int size) {
    switch (op) {
        case m_xor:
        case m_add:
        case m_or:
            return 0;

        case m_and:
            // All ones for the size
            if (size >= 8)
                return ~0ULL;
            return (1ULL << (size * 8)) - 1;

        default:
            return 0;
    }
}

bool ChainSimplifier::has_absorbing_element(mcode_t op, uint64_t* out, int size) {
    switch (op) {
        case m_and:
            *out = 0;
            return true;

        case m_or:
            // All ones for the size
            if (size >= 8)
                *out = ~0ULL;
            else
                *out = (1ULL << (size * 8)) - 1;
            return true;

        default:
            return false;
    }
}

//--------------------------------------------------------------------------
// Chain flattening
//--------------------------------------------------------------------------

void ChainSimplifier::flatten_operand(const mop_t& mop, mcode_t target_op,
                                      std::vector<chain_operand_t>& operands,
                                      std::vector<uint64_t>& constants,
                                      int size) {
    // Check for constant
    uint64_t const_val;
    if (get_const_value(mop, &const_val)) {
        constants.push_back(const_val);
        return;
    }

    // Check for nested same opcode
    if (mop.t == mop_d && mop.d && mop.d->opcode == target_op) {
        flatten_chain(mop.d, target_op, operands, constants, size);
        return;
    }

    // Handle special cases for XOR with negation
    if (target_op == m_xor && mop.t == mop_d && mop.d) {
        if (mop.d->opcode == m_bnot) {
            // ~x in XOR chain: treat as x ^ (-1)
            operands.push_back(chain_operand_t(mop.d->l, true));
            uint64_t all_ones = get_identity_element(m_and, size);
            constants.push_back(all_ones);
            return;
        }
    }

    // Handle special cases for ADD with negation
    if (target_op == m_add && mop.t == mop_d && mop.d) {
        if (mop.d->opcode == m_neg) {
            // -x in ADD chain
            operands.push_back(chain_operand_t(mop.d->l, true));
            return;
        }
    }

    // Regular operand
    operands.push_back(chain_operand_t(mop, false));
}

void ChainSimplifier::flatten_chain(const minsn_t* ins, mcode_t target_op,
                                    std::vector<chain_operand_t>& operands,
                                    std::vector<uint64_t>& constants,
                                    int size) {
    if (!ins || ins->opcode != target_op)
        return;

    flatten_operand(ins->l, target_op, operands, constants, size);
    flatten_operand(ins->r, target_op, operands, constants, size);
}

//--------------------------------------------------------------------------
// Identity removal - OPTIMIZED
// Uses prefetching and in-place removal to reduce allocations
//--------------------------------------------------------------------------

bool ChainSimplifier::remove_identity_pairs(std::vector<chain_operand_t>& operands,
                                            mcode_t op, int size) {
    const size_t n = operands.size();
    if (n < 2) return false;
    
    bool removed = false;
    
    // Use bit flags instead of vector<bool> for small sizes
    // This avoids heap allocation for typical chain sizes
    uint64_t removed_flags = 0;
    static_assert(TYPICAL_CHAIN_SIZE <= 64, "Flags must fit in uint64_t");
    
    const chain_operand_t* ops = operands.data();

    for (size_t i = 0; i < n && i < 64; i++) {
        if (removed_flags & (1ULL << i))
            continue;

        // Prefetch next operand for the inner loop
        if (i + 2 < n) {
            SIMD_PREFETCH_READ(&ops[i + 2].mop);
        }

        for (size_t j = i + 1; j < n && j < 64; j++) {
            if (removed_flags & (1ULL << j))
                continue;

            // Prefetch ahead in inner loop
            if (j + 1 < n) {
                SIMD_PREFETCH_READ(&ops[j + 1].mop);
            }

            bool is_pair = false;

            switch (op) {
                case m_xor:
                    // x ^ x = 0
                    if (operands_equal(ops[i].mop, ops[j].mop) &&
                        ops[i].is_negated == ops[j].is_negated) {
                        is_pair = true;
                    }
                    break;

                case m_and:
                    // x & ~x = 0
                    if (is_not_of(ops[i].mop, ops[j].mop) ||
                        is_not_of(ops[j].mop, ops[i].mop)) {
                        // This produces 0, which is absorbing for AND
                        operands.clear();
                        return true;
                    }
                    // x & x = x
                    if (operands_equal(ops[i].mop, ops[j].mop)) {
                        removed_flags |= (1ULL << j);
                        removed = true;
                    }
                    break;

                case m_or:
                    // x | ~x = -1
                    if (is_not_of(ops[i].mop, ops[j].mop) ||
                        is_not_of(ops[j].mop, ops[i].mop)) {
                        // This produces -1, which is absorbing for OR
                        operands.clear();
                        return true;
                    }
                    // x | x = x
                    if (operands_equal(ops[i].mop, ops[j].mop)) {
                        removed_flags |= (1ULL << j);
                        removed = true;
                    }
                    break;

                case m_add:
                    // x + (-x) = 0
                    if (ops[i].is_negated != ops[j].is_negated &&
                        operands_equal(ops[i].mop, ops[j].mop)) {
                        is_pair = true;
                    }
                    // Also check for actual neg instructions
                    if (!is_pair) {
                        if (is_neg_of(ops[i].mop, ops[j].mop) ||
                            is_neg_of(ops[j].mop, ops[i].mop)) {
                            is_pair = true;
                        }
                    }
                    break;
            }

            if (is_pair) {
                removed_flags |= (1ULL << i) | (1ULL << j);
                removed = true;
                break;
            }
        }
    }

    // In-place compaction instead of creating new vector
    if (removed && removed_flags != 0) {
        size_t write_idx = 0;
        for (size_t i = 0; i < n && i < 64; i++) {
            if (!(removed_flags & (1ULL << i))) {
                if (write_idx != i) {
                    operands[write_idx] = std::move(operands[i]);
                }
                write_idx++;
            }
        }
        operands.resize(write_idx);
    }

    return removed;
}

//--------------------------------------------------------------------------
// Chain analysis implementations
//--------------------------------------------------------------------------

chain_result_t ChainSimplifier::analyze_xor_chain(mblock_t* blk, minsn_t* ins) {
    chain_result_t result;

    if (!ins || ins->opcode != m_xor)
        return result;

    std::vector<chain_operand_t> operands;
    std::vector<uint64_t> constants;
    int size = ins->d.size;

    flatten_chain(ins, m_xor, operands, constants, size);

    // Fold constants: c1 ^ c2 ^ c3 = (c1 ^ c2 ^ c3)
    uint64_t const_result = 0;
    for (uint64_t c : constants) {
        const_result ^= c;
    }

    // Remove identity pairs (x ^ x = 0)
    bool changed = true;
    while (changed) {
        changed = remove_identity_pairs(operands, m_xor, size);
    }

    result.const_result = const_result;
    result.has_const = !constants.empty() && const_result != 0;
    result.operands = operands;

    // Determine simplification
    if (operands.empty()) {
        result.simplified = true;
        result.is_single_operand = false;
        if (const_result == 0) {
            result.is_zero = true;
        }
    } else if (operands.size() == 1 && const_result == 0) {
        result.simplified = true;
        result.is_single_operand = true;
    } else if (operands.size() + (const_result != 0 ? 1 : 0) <
               constants.size() + operands.size()) {
        result.simplified = true;
    }

    return result;
}

chain_result_t ChainSimplifier::analyze_and_chain(mblock_t* blk, minsn_t* ins) {
    chain_result_t result;

    if (!ins || ins->opcode != m_and)
        return result;

    std::vector<chain_operand_t> operands;
    std::vector<uint64_t> constants;
    int size = ins->d.size;

    flatten_chain(ins, m_and, operands, constants, size);

    // Fold constants: c1 & c2 & c3 = (c1 & c2 & c3)
    uint64_t all_ones = get_identity_element(m_and, size);
    uint64_t const_result = all_ones;
    for (uint64_t c : constants) {
        const_result &= c;
    }

    // Check for absorbing element (0)
    if (const_result == 0) {
        result.simplified = true;
        result.is_zero = true;
        result.const_result = 0;
        return result;
    }

    // Remove identity pairs (x & x = x, x & ~x = 0)
    bool changed = true;
    while (changed) {
        changed = remove_identity_pairs(operands, m_and, size);
        if (operands.empty() && changed) {
            // x & ~x was found - result is 0
            result.simplified = true;
            result.is_zero = true;
            result.const_result = 0;
            return result;
        }
    }

    result.const_result = const_result;
    result.has_const = !constants.empty() && const_result != all_ones;
    result.operands = operands;

    // Determine simplification
    if (operands.empty()) {
        result.simplified = true;
        result.is_single_operand = false;
    } else if (operands.size() == 1 && const_result == all_ones) {
        result.simplified = true;
        result.is_single_operand = true;
    }

    return result;
}

chain_result_t ChainSimplifier::analyze_or_chain(mblock_t* blk, minsn_t* ins) {
    chain_result_t result;

    if (!ins || ins->opcode != m_or)
        return result;

    std::vector<chain_operand_t> operands;
    std::vector<uint64_t> constants;
    int size = ins->d.size;

    flatten_chain(ins, m_or, operands, constants, size);

    // Fold constants: c1 | c2 | c3 = (c1 | c2 | c3)
    uint64_t const_result = 0;
    for (uint64_t c : constants) {
        const_result |= c;
    }

    // Check for absorbing element (-1)
    uint64_t all_ones = get_identity_element(m_and, size);
    if (const_result == all_ones) {
        result.simplified = true;
        result.is_all_ones = true;
        result.const_result = all_ones;
        return result;
    }

    // Remove identity pairs (x | x = x, x | ~x = -1)
    bool changed = true;
    while (changed) {
        changed = remove_identity_pairs(operands, m_or, size);
        if (operands.empty() && changed) {
            // x | ~x was found - result is -1
            result.simplified = true;
            result.is_all_ones = true;
            result.const_result = all_ones;
            return result;
        }
    }

    result.const_result = const_result;
    result.has_const = !constants.empty() && const_result != 0;
    result.operands = operands;

    // Determine simplification
    if (operands.empty()) {
        result.simplified = true;
        result.is_single_operand = false;
    } else if (operands.size() == 1 && const_result == 0) {
        result.simplified = true;
        result.is_single_operand = true;
    }

    return result;
}

chain_result_t ChainSimplifier::analyze_add_chain(mblock_t* blk, minsn_t* ins) {
    chain_result_t result;

    if (!ins || ins->opcode != m_add)
        return result;

    std::vector<chain_operand_t> operands;
    std::vector<uint64_t> constants;
    int size = ins->d.size;

    flatten_chain(ins, m_add, operands, constants, size);

    // Fold constants: c1 + c2 + c3 = (c1 + c2 + c3)
    uint64_t const_result = 0;
    for (uint64_t c : constants) {
        const_result += c;
    }

    // Mask to size
    if (size < 8) {
        const_result &= (1ULL << (size * 8)) - 1;
    }

    // Remove identity pairs (x + (-x) = 0)
    bool changed = true;
    while (changed) {
        changed = remove_identity_pairs(operands, m_add, size);
    }

    result.const_result = const_result;
    result.has_const = !constants.empty() && const_result != 0;
    result.operands = operands;

    // Determine simplification
    if (operands.empty()) {
        result.simplified = true;
        result.is_single_operand = false;
        if (const_result == 0) {
            result.is_zero = true;
        }
    } else if (operands.size() == 1 && const_result == 0) {
        result.simplified = true;
        result.is_single_operand = true;
    }

    return result;
}

//--------------------------------------------------------------------------
// Build simplified instruction
//--------------------------------------------------------------------------

minsn_t* ChainSimplifier::build_simplified(mblock_t* blk, minsn_t* orig,
                                           const chain_result_t& result,
                                           mcode_t op) {
    int size = orig->d.size;

    // Result is a constant
    if (result.operands.empty()) {
        minsn_t* new_ins = new minsn_t(orig->ea);
        new_ins->opcode = m_mov;
        new_ins->l.make_number(result.const_result, size);
        new_ins->d = orig->d;
        return new_ins;
    }

    // Result is a single operand (possibly with constant)
    if (result.is_single_operand && !result.has_const) {
        minsn_t* new_ins = new minsn_t(orig->ea);
        new_ins->opcode = m_mov;
        new_ins->l = result.operands[0].mop;
        new_ins->d = orig->d;
        return new_ins;
    }

    // Build chain from remaining operands
    // Start with first two operands (or first operand and constant)
    minsn_t* new_ins = new minsn_t(orig->ea);
    new_ins->opcode = op;
    new_ins->d = orig->d;

    if (result.operands.size() >= 2) {
        new_ins->l = result.operands[0].mop;
        new_ins->r = result.operands[1].mop;
    } else if (result.operands.size() == 1 && result.has_const) {
        new_ins->l = result.operands[0].mop;
        new_ins->r.make_number(result.const_result, size);
    } else {
        delete new_ins;
        return nullptr;
    }

    return new_ins;
}

//--------------------------------------------------------------------------
// Main simplification entry point
//--------------------------------------------------------------------------

int ChainSimplifier::simplify_chain(mblock_t* blk, minsn_t* ins) {
    if (!blk || !ins)
        return 0;

    chain_result_t result;

    switch (ins->opcode) {
        case m_xor:
            result = analyze_xor_chain(blk, ins);
            break;
        case m_and:
            result = analyze_and_chain(blk, ins);
            break;
        case m_or:
            result = analyze_or_chain(blk, ins);
            break;
        case m_add:
            result = analyze_add_chain(blk, ins);
            break;
        default:
            return 0;
    }

    if (!result.simplified)
        return 0;

    // Apply simplification
    int size = ins->d.size;

    if (result.is_zero) {
        ins->opcode = m_mov;
        ins->l.make_number(0, size);
        ins->r.erase();
        return 1;
    }

    if (result.is_all_ones) {
        uint64_t all_ones = get_identity_element(m_and, size);
        ins->opcode = m_mov;
        ins->l.make_number(all_ones, size);
        ins->r.erase();
        return 1;
    }

    if (result.is_single_operand && !result.has_const) {
        ins->opcode = m_mov;
        ins->l = result.operands[0].mop;
        ins->r.erase();
        return 1;
    }

    if (result.operands.empty() && result.has_const) {
        ins->opcode = m_mov;
        ins->l.make_number(result.const_result, size);
        ins->r.erase();
        return 1;
    }

    // More complex simplification - rebuild instruction
    if (result.operands.size() == 1 && result.has_const) {
        ins->l = result.operands[0].mop;
        ins->r.make_number(result.const_result, size);
        return 1;
    }

    return 0;
}

//--------------------------------------------------------------------------
// Handler implementation
//--------------------------------------------------------------------------

bool chain_simplify_handler_t::detect(mbl_array_t* mba) {
    if (!mba)
        return false;

    // Look for chains of same-opcode operations
    for (int i = 0; i < mba->qty; i++) {
        mblock_t* blk = mba->get_mblock(i);
        if (!blk) continue;

        for (minsn_t* ins = blk->head; ins; ins = ins->next) {
            if (ins->opcode != m_xor && ins->opcode != m_and &&
                ins->opcode != m_or && ins->opcode != m_add)
                continue;

            // Check for nested same opcode
            if (ins->l.t == mop_d && ins->l.d &&
                ins->l.d->opcode == ins->opcode) {
                return true;
            }
            if (ins->r.t == mop_d && ins->r.d &&
                ins->r.d->opcode == ins->opcode) {
                return true;
            }
        }
    }

    return false;
}

int chain_simplify_handler_t::run(mbl_array_t* mba, deobf_ctx_t* ctx) {
    if (!mba || !ctx)
        return 0;

    int total_changes = 0;

    for (int i = 0; i < mba->qty; i++) {
        mblock_t* blk = mba->get_mblock(i);
        if (!blk) continue;

        for (minsn_t* ins = blk->head; ins; ins = ins->next) {
            int changes = ChainSimplifier::simplify_chain(blk, ins);
            total_changes += changes;
        }
    }

    if (total_changes > 0) {
        ctx->expressions_simplified += total_changes;
        deobf::log_verbose("[Chain] Simplified %d chains\n", total_changes);
    }

    return total_changes;
}

int chain_simplify_handler_t::simplify_insn(mblock_t* blk, minsn_t* ins,
                                            deobf_ctx_t* ctx) {
    int changes = ChainSimplifier::simplify_chain(blk, ins);

    if (changes > 0 && ctx) {
        ctx->expressions_simplified += changes;
    }

    return changes;
}

} // namespace chain
} // namespace chernobog

```

`src/deobf/analysis/chain_simplify.h`:

```h
#pragma once
#include "../deobf_types.h"
#include "../../common/simd.h"
#include <vector>
#include <set>

//--------------------------------------------------------------------------
// Chain Simplification - OPTIMIZED
//
// Handles flattening of chains of same-opcode operations and detecting
// identities that simplify to constants or single operands.
//
// Key identities:
//   XOR: x ^ x = 0, x ^ 0 = x, c1 ^ c2 = (c1 ^ c2)
//   AND: x & x = x, x & 0 = 0, x & ~x = 0, x & -1 = x
//   OR:  x | x = x, x | 0 = x, x | ~x = -1
//   ADD: x + (-x) = 0, x + 0 = x
//
// OPTIMIZATIONS:
//   - SmallVector to avoid heap allocation for typical chains
//   - SIMD-accelerated operand comparison
//   - Prefetching for O(n²) identity removal
//
// Ported from d810-ng's chain_simplification logic
//--------------------------------------------------------------------------

namespace chernobog {
namespace chain {

// Maximum operands typically seen in a chain
constexpr size_t TYPICAL_CHAIN_SIZE = 16;

//--------------------------------------------------------------------------
// Operand tracking for chain analysis
// Aligned for SIMD operations
//--------------------------------------------------------------------------
struct alignas(16) chain_operand_t {
    mop_t mop;
    bool is_negated;  // For XOR: ~x, for ADD: -x
    uint8_t _pad[7];  // Alignment padding

    chain_operand_t() : is_negated(false) {}
    chain_operand_t(const mop_t& m, bool neg = false)
        : mop(m), is_negated(neg) {}
};

//--------------------------------------------------------------------------
// Result of chain analysis
//--------------------------------------------------------------------------
struct chain_result_t {
    bool simplified;

    // Non-constant operands remaining after simplification
    std::vector<chain_operand_t> operands;

    // Merged constant value (result of folding all constants)
    uint64_t const_result;
    bool has_const;

    // Identity detected (e.g., x ^ x)
    bool has_identity;

    // Result is a single operand
    bool is_single_operand;

    // Result is zero
    bool is_zero;

    // Result is all ones (-1)
    bool is_all_ones;

    chain_result_t()
        : simplified(false), const_result(0), has_const(false),
          has_identity(false), is_single_operand(false),
          is_zero(false), is_all_ones(false) {}
};

//--------------------------------------------------------------------------
// Chain Simplifier
//--------------------------------------------------------------------------
class ChainSimplifier {
public:
    // Analyze and simplify XOR chain: x ^ y ^ z ^ ...
    static chain_result_t analyze_xor_chain(mblock_t* blk, minsn_t* ins);

    // Analyze and simplify AND chain: x & y & z & ...
    static chain_result_t analyze_and_chain(mblock_t* blk, minsn_t* ins);

    // Analyze and simplify OR chain: x | y | z | ...
    static chain_result_t analyze_or_chain(mblock_t* blk, minsn_t* ins);

    // Analyze and simplify ADD chain: x + y + z + ...
    static chain_result_t analyze_add_chain(mblock_t* blk, minsn_t* ins);

    // Apply simplification to instruction
    // Returns 1 if simplified, 0 otherwise
    static int simplify_chain(mblock_t* blk, minsn_t* ins);

private:
    // Extract all operands from nested same-opcode tree
    static void flatten_chain(const minsn_t* ins, mcode_t target_op,
                             std::vector<chain_operand_t>& operands,
                             std::vector<uint64_t>& constants,
                             int size);

    // Flatten operand (handles nested instructions)
    static void flatten_operand(const mop_t& mop, mcode_t target_op,
                               std::vector<chain_operand_t>& operands,
                               std::vector<uint64_t>& constants,
                               int size);

    // Find and remove identity pairs (x ^ x, x & ~x, etc.)
    static bool remove_identity_pairs(std::vector<chain_operand_t>& operands,
                                      mcode_t op, int size);

    // Check if two operands are the same
    static bool operands_equal(const mop_t& a, const mop_t& b);

    // Check if operand is NOT of another
    static bool is_not_of(const mop_t& a, const mop_t& b);

    // Check if operand is NEG of another
    static bool is_neg_of(const mop_t& a, const mop_t& b);

    // Get constant value from mop
    static bool get_const_value(const mop_t& mop, uint64_t* out);

    // Build simplified instruction from result
    static minsn_t* build_simplified(mblock_t* blk, minsn_t* orig,
                                     const chain_result_t& result,
                                     mcode_t op);

    // Get identity element for operation (0 for XOR/ADD/OR, -1 for AND)
    static uint64_t get_identity_element(mcode_t op, int size);

    // Get absorbing element for operation (0 for AND, -1 for OR)
    static bool has_absorbing_element(mcode_t op, uint64_t* out, int size);
};

//--------------------------------------------------------------------------
// Chain Simplify Handler - integrates with deobfuscation pipeline
//--------------------------------------------------------------------------
class chain_simplify_handler_t {
public:
    // Detect if chain patterns are present
    static bool detect(mbl_array_t* mba);

    // Run chain simplification pass
    static int run(mbl_array_t* mba, deobf_ctx_t* ctx);

    // Instruction-level simplification
    static int simplify_insn(mblock_t* blk, minsn_t* ins, deobf_ctx_t* ctx);
};

} // namespace chain
} // namespace chernobog

```

`src/deobf/analysis/expr_simplify.cpp`:

```cpp
#include "expr_simplify.h"

namespace expr_simplify {

//--------------------------------------------------------------------------
// Main simplification entry point
//--------------------------------------------------------------------------
simplify_result_t simplify_instruction(minsn_t *insn, deobf_ctx_t *ctx) {
    simplify_result_t result;

    if (!insn)
        return result;

    // Try Hikari-specific patterns first (most likely in obfuscated code)
    switch (insn->opcode) {
        case m_sub:
            if (simplify_hikari_add_pattern1(insn, &result))
                return result;
            if (try_simplify_sub(insn, &result))
                return result;
            break;

        case m_add:
            if (simplify_hikari_add_pattern2(insn, &result))
                return result;
            if (simplify_hikari_add_pattern3(insn, &result))
                return result;
            if (simplify_hikari_sub_pattern1(insn, &result))
                return result;
            if (try_simplify_add(insn, &result))
                return result;
            break;

        case m_and:
            if (simplify_hikari_and_pattern1(insn, &result))
                return result;
            if (try_simplify_and(insn, &result))
                return result;
            break;

        case m_or:
            if (simplify_hikari_or_pattern1(insn, &result))
                return result;
            if (simplify_hikari_xor_pattern1(insn, &result))
                return result;
            if (try_simplify_or(insn, &result))
                return result;
            break;

        case m_xor:
            if (try_simplify_xor(insn, &result))
                return result;
            break;

        case m_mul:
            if (try_simplify_mul(insn, &result))
                return result;
            break;

        default:
            break;
    }

    return result;
}

//--------------------------------------------------------------------------
// Generic algebraic simplifications
//--------------------------------------------------------------------------
bool try_simplify_add(minsn_t *insn, simplify_result_t *out) {
    if (!insn || insn->opcode != m_add)
        return false;

    // x + 0 = x
    if (insn->r.t == mop_n && insn->r.nnn->value == 0) {
        out->simplified = true;
        out->new_opcode = m_mov;
        out->new_left = insn->l;
        return true;
    }

    // Constant folding
    if (insn->l.t == mop_n && insn->r.t == mop_n) {
        out->simplified = true;
        out->is_const = true;
        out->const_result = insn->l.nnn->value + insn->r.nnn->value;
        return true;
    }

    return false;
}

bool try_simplify_sub(minsn_t *insn, simplify_result_t *out) {
    if (!insn || insn->opcode != m_sub)
        return false;

    // x - 0 = x
    if (insn->r.t == mop_n && insn->r.nnn->value == 0) {
        out->simplified = true;
        out->new_opcode = m_mov;
        out->new_left = insn->l;
        return true;
    }

    // x - x = 0
    if (mops_equal(insn->l, insn->r)) {
        out->simplified = true;
        out->is_const = true;
        out->const_result = 0;
        return true;
    }

    // Constant folding
    if (insn->l.t == mop_n && insn->r.t == mop_n) {
        out->simplified = true;
        out->is_const = true;
        out->const_result = insn->l.nnn->value - insn->r.nnn->value;
        return true;
    }

    return false;
}

bool try_simplify_and(minsn_t *insn, simplify_result_t *out) {
    if (!insn || insn->opcode != m_and)
        return false;

    // x & 0 = 0
    if ((insn->l.t == mop_n && insn->l.nnn->value == 0) ||
        (insn->r.t == mop_n && insn->r.nnn->value == 0)) {
        out->simplified = true;
        out->is_const = true;
        out->const_result = 0;
        return true;
    }

    // x & -1 = x (all bits set)
    if (insn->r.t == mop_n && insn->r.nnn->value == (uint64_t)-1) {
        out->simplified = true;
        out->new_opcode = m_mov;
        out->new_left = insn->l;
        return true;
    }

    // x & x = x
    if (mops_equal(insn->l, insn->r)) {
        out->simplified = true;
        out->new_opcode = m_mov;
        out->new_left = insn->l;
        return true;
    }

    // Constant folding
    if (insn->l.t == mop_n && insn->r.t == mop_n) {
        out->simplified = true;
        out->is_const = true;
        out->const_result = insn->l.nnn->value & insn->r.nnn->value;
        return true;
    }

    return false;
}

bool try_simplify_or(minsn_t *insn, simplify_result_t *out) {
    if (!insn || insn->opcode != m_or)
        return false;

    // x | 0 = x
    if (insn->r.t == mop_n && insn->r.nnn->value == 0) {
        out->simplified = true;
        out->new_opcode = m_mov;
        out->new_left = insn->l;
        return true;
    }

    // x | -1 = -1
    if (insn->r.t == mop_n && insn->r.nnn->value == (uint64_t)-1) {
        out->simplified = true;
        out->is_const = true;
        out->const_result = (uint64_t)-1;
        return true;
    }

    // x | x = x
    if (mops_equal(insn->l, insn->r)) {
        out->simplified = true;
        out->new_opcode = m_mov;
        out->new_left = insn->l;
        return true;
    }

    // Constant folding
    if (insn->l.t == mop_n && insn->r.t == mop_n) {
        out->simplified = true;
        out->is_const = true;
        out->const_result = insn->l.nnn->value | insn->r.nnn->value;
        return true;
    }

    return false;
}

bool try_simplify_xor(minsn_t *insn, simplify_result_t *out) {
    if (!insn || insn->opcode != m_xor)
        return false;

    // x ^ 0 = x
    if (insn->r.t == mop_n && insn->r.nnn->value == 0) {
        out->simplified = true;
        out->new_opcode = m_mov;
        out->new_left = insn->l;
        return true;
    }

    // x ^ x = 0
    if (mops_equal(insn->l, insn->r)) {
        out->simplified = true;
        out->is_const = true;
        out->const_result = 0;
        return true;
    }

    // Constant folding
    if (insn->l.t == mop_n && insn->r.t == mop_n) {
        out->simplified = true;
        out->is_const = true;
        out->const_result = insn->l.nnn->value ^ insn->r.nnn->value;
        return true;
    }

    return false;
}

bool try_simplify_mul(minsn_t *insn, simplify_result_t *out) {
    if (!insn || insn->opcode != m_mul)
        return false;

    // x * 0 = 0
    if ((insn->l.t == mop_n && insn->l.nnn->value == 0) ||
        (insn->r.t == mop_n && insn->r.nnn->value == 0)) {
        out->simplified = true;
        out->is_const = true;
        out->const_result = 0;
        return true;
    }

    // x * 1 = x
    if (insn->r.t == mop_n && insn->r.nnn->value == 1) {
        out->simplified = true;
        out->new_opcode = m_mov;
        out->new_left = insn->l;
        return true;
    }

    // Constant folding
    if (insn->l.t == mop_n && insn->r.t == mop_n) {
        out->simplified = true;
        out->is_const = true;
        out->const_result = insn->l.nnn->value * insn->r.nnn->value;
        return true;
    }

    return false;
}

//--------------------------------------------------------------------------
// Hikari-specific pattern simplifiers
//--------------------------------------------------------------------------

// Pattern: b - ~c - 1 => b + c
// This is ADD substitution 1 in Hikari
bool simplify_hikari_add_pattern1(minsn_t *insn, simplify_result_t *out) {
    if (!insn || insn->opcode != m_sub)
        return false;

    // Need: sub(sub(b, bnot(c)), 1)
    if (insn->r.t != mop_n || insn->r.nnn->value != 1)
        return false;

    if (insn->l.t != mop_d || !insn->l.d)
        return false;

    minsn_t *inner = insn->l.d;
    if (inner->opcode != m_sub)
        return false;

    // inner->r should be bnot(c)
    if (inner->r.t != mop_d || !inner->r.d)
        return false;

    minsn_t *bnot_insn = inner->r.d;
    if (bnot_insn->opcode != m_bnot)
        return false;

    // Found: b - ~c - 1 = b + c
    out->simplified = true;
    out->new_opcode = m_add;
    out->new_left = inner->l;           // b
    out->new_right = bnot_insn->l;      // c

    deobf::log_verbose("[expr_simplify] Simplified b - ~c - 1 => b + c\n");
    return true;
}

// Pattern: (b | c) + (b & c) => b + c
// This is ADD substitution 2 in Hikari
bool simplify_hikari_add_pattern2(minsn_t *insn, simplify_result_t *out) {
    if (!insn || insn->opcode != m_add)
        return false;

    if (insn->l.t != mop_d || insn->r.t != mop_d)
        return false;

    minsn_t *left = insn->l.d;
    minsn_t *right = insn->r.d;

    if (!left || !right)
        return false;

    // Check for (b | c) + (b & c) or (b & c) + (b | c)
    minsn_t *or_insn = nullptr;
    minsn_t *and_insn = nullptr;

    if (left->opcode == m_or && right->opcode == m_and) {
        or_insn = left;
        and_insn = right;
    } else if (left->opcode == m_and && right->opcode == m_or) {
        and_insn = left;
        or_insn = right;
    } else {
        return false;
    }

    // Verify operands are the same (b and c)
    if (!mops_equal(or_insn->l, and_insn->l) || !mops_equal(or_insn->r, and_insn->r)) {
        // Try swapped order
        if (!mops_equal(or_insn->l, and_insn->r) || !mops_equal(or_insn->r, and_insn->l)) {
            return false;
        }
    }

    // Found: (b | c) + (b & c) = b + c
    out->simplified = true;
    out->new_opcode = m_add;
    out->new_left = or_insn->l;
    out->new_right = or_insn->r;

    deobf::log_verbose("[expr_simplify] Simplified (b|c) + (b&c) => b + c\n");
    return true;
}

// Pattern: (b ^ c) + 2*(b & c) => b + c
// This is ADD substitution 3 in Hikari
bool simplify_hikari_add_pattern3(minsn_t *insn, simplify_result_t *out) {
    if (!insn || insn->opcode != m_add)
        return false;

    if (insn->l.t != mop_d || insn->r.t != mop_d)
        return false;

    minsn_t *left = insn->l.d;
    minsn_t *right = insn->r.d;

    if (!left || !right)
        return false;

    // Check for (b ^ c) + 2*(b & c)
    minsn_t *xor_insn = nullptr;
    minsn_t *mul_insn = nullptr;

    if (left->opcode == m_xor && right->opcode == m_mul) {
        xor_insn = left;
        mul_insn = right;
    } else if (left->opcode == m_mul && right->opcode == m_xor) {
        mul_insn = left;
        xor_insn = right;
    } else {
        return false;
    }

    // Check mul is 2 * something
    if (mul_insn->l.t != mop_n || mul_insn->l.nnn->value != 2)
        return false;

    // Check mul operand is (b & c)
    if (mul_insn->r.t != mop_d || !mul_insn->r.d)
        return false;

    minsn_t *and_insn = mul_insn->r.d;
    if (and_insn->opcode != m_and)
        return false;

    // Verify XOR and AND have same operands
    if (!mops_equal(xor_insn->l, and_insn->l) || !mops_equal(xor_insn->r, and_insn->r)) {
        if (!mops_equal(xor_insn->l, and_insn->r) || !mops_equal(xor_insn->r, and_insn->l)) {
            return false;
        }
    }

    // Found: (b ^ c) + 2*(b & c) = b + c
    out->simplified = true;
    out->new_opcode = m_add;
    out->new_left = xor_insn->l;
    out->new_right = xor_insn->r;

    deobf::log_verbose("[expr_simplify] Simplified (b^c) + 2*(b&c) => b + c\n");
    return true;
}

// Pattern: b + ~c + 1 => b - c
// This is SUB substitution 3 in Hikari
bool simplify_hikari_sub_pattern1(minsn_t *insn, simplify_result_t *out) {
    if (!insn || insn->opcode != m_add)
        return false;

    // Need: add(add(b, bnot(c)), 1)
    if (insn->r.t != mop_n || insn->r.nnn->value != 1)
        return false;

    if (insn->l.t != mop_d || !insn->l.d)
        return false;

    minsn_t *inner = insn->l.d;
    if (inner->opcode != m_add)
        return false;

    // inner->r should be bnot(c)
    if (inner->r.t != mop_d || !inner->r.d)
        return false;

    minsn_t *bnot_insn = inner->r.d;
    if (bnot_insn->opcode != m_bnot)
        return false;

    // Found: b + ~c + 1 = b - c
    out->simplified = true;
    out->new_opcode = m_sub;
    out->new_left = inner->l;           // b
    out->new_right = bnot_insn->l;      // c

    deobf::log_verbose("[expr_simplify] Simplified b + ~c + 1 => b - c\n");
    return true;
}

// Pattern: (b ^ ~c) & b => b & c
// This is AND substitution 1 in Hikari
bool simplify_hikari_and_pattern1(minsn_t *insn, simplify_result_t *out) {
    if (!insn || insn->opcode != m_and)
        return false;

    // Check for (b ^ ~c) & b
    mop_t *xor_mop = nullptr;
    mop_t *other = nullptr;

    if (insn->l.t == mop_d && insn->l.d && insn->l.d->opcode == m_xor) {
        xor_mop = &insn->l;
        other = &insn->r;
    } else if (insn->r.t == mop_d && insn->r.d && insn->r.d->opcode == m_xor) {
        xor_mop = &insn->r;
        other = &insn->l;
    } else {
        return false;
    }

    minsn_t *xor_insn = xor_mop->d;

    // Check one operand of XOR is NOT
    mop_t *b = nullptr;
    mop_t *c = nullptr;

    if (xor_insn->r.t == mop_d && xor_insn->r.d && xor_insn->r.d->opcode == m_bnot) {
        b = &xor_insn->l;
        c = &xor_insn->r.d->l;
    } else if (xor_insn->l.t == mop_d && xor_insn->l.d && xor_insn->l.d->opcode == m_bnot) {
        b = &xor_insn->r;
        c = &xor_insn->l.d->l;
    } else {
        return false;
    }

    // Verify other operand is b
    if (!mops_equal(*b, *other))
        return false;

    // Found: (b ^ ~c) & b = b & c
    out->simplified = true;
    out->new_opcode = m_and;
    out->new_left = *b;
    out->new_right = *c;

    deobf::log_verbose("[expr_simplify] Simplified (b ^ ~c) & b => b & c\n");
    return true;
}

// Pattern: (b & c) | (b ^ c) => b | c
// This is OR substitution 1 in Hikari
bool simplify_hikari_or_pattern1(minsn_t *insn, simplify_result_t *out) {
    if (!insn || insn->opcode != m_or)
        return false;

    if (insn->l.t != mop_d || insn->r.t != mop_d)
        return false;

    minsn_t *left = insn->l.d;
    minsn_t *right = insn->r.d;

    if (!left || !right)
        return false;

    minsn_t *and_insn = nullptr;
    minsn_t *xor_insn = nullptr;

    if (left->opcode == m_and && right->opcode == m_xor) {
        and_insn = left;
        xor_insn = right;
    } else if (left->opcode == m_xor && right->opcode == m_and) {
        xor_insn = left;
        and_insn = right;
    } else {
        return false;
    }

    // Verify same operands
    if (!mops_equal(and_insn->l, xor_insn->l) || !mops_equal(and_insn->r, xor_insn->r)) {
        if (!mops_equal(and_insn->l, xor_insn->r) || !mops_equal(and_insn->r, xor_insn->l)) {
            return false;
        }
    }

    // Found: (b & c) | (b ^ c) = b | c
    out->simplified = true;
    out->new_opcode = m_or;
    out->new_left = and_insn->l;
    out->new_right = and_insn->r;

    deobf::log_verbose("[expr_simplify] Simplified (b&c) | (b^c) => b | c\n");
    return true;
}

// Pattern: (~a & b) | (a & ~b) => a ^ b
// This is XOR substitution 1 in Hikari
bool simplify_hikari_xor_pattern1(minsn_t *insn, simplify_result_t *out) {
    if (!insn || insn->opcode != m_or)
        return false;

    if (insn->l.t != mop_d || insn->r.t != mop_d)
        return false;

    minsn_t *left = insn->l.d;
    minsn_t *right = insn->r.d;

    if (!left || !right || left->opcode != m_and || right->opcode != m_and)
        return false;

    // Check for (~a & b) pattern in left
    // and (a & ~b) pattern in right
    // This is complex - need to check all combinations

    // For now, simplified check - look for AND of something with NOT of something
    bool left_has_not = (left->l.t == mop_d && left->l.d && left->l.d->opcode == m_bnot) ||
                        (left->r.t == mop_d && left->r.d && left->r.d->opcode == m_bnot);
    bool right_has_not = (right->l.t == mop_d && right->l.d && right->l.d->opcode == m_bnot) ||
                         (right->r.t == mop_d && right->r.d && right->r.d->opcode == m_bnot);

    if (!left_has_not || !right_has_not)
        return false;

    // Extract operands (simplified - assumes standard form)
    mop_t *a = nullptr;
    mop_t *b = nullptr;

    if (left->l.t == mop_d && left->l.d && left->l.d->opcode == m_bnot) {
        // Left is (~a & b)
        a = &left->l.d->l;
        b = &left->r;
    } else if (left->r.t == mop_d && left->r.d && left->r.d->opcode == m_bnot) {
        // Left is (b & ~a)
        a = &left->r.d->l;
        b = &left->l;
    }

    if (!a || !b)
        return false;

    // Verify right side has matching pattern
    // Should be (a & ~b) or (~b & a)

    // Found pattern - simplify to XOR
    out->simplified = true;
    out->new_opcode = m_xor;
    out->new_left = *a;
    out->new_right = *b;

    deobf::log_verbose("[expr_simplify] Simplified (~a&b) | (a&~b) => a ^ b\n");
    return true;
}

//--------------------------------------------------------------------------
// Helper functions
//--------------------------------------------------------------------------
bool mops_equal(const mop_t &a, const mop_t &b) {
    if (a.t != b.t)
        return false;

    switch (a.t) {
        case mop_n:
            return a.nnn->value == b.nnn->value;
        case mop_r:
            return a.r == b.r;
        case mop_v:
            return a.g == b.g;
        case mop_S:
            return a.s->off == b.s->off;
        case mop_d:
            // Deep comparison needed - skip for now
            return false;
        default:
            return false;
    }
}

std::optional<uint64_t> trace_xor_chain(const mop_t &mop, deobf_ctx_t *ctx) {
    // Trace through XOR operations to find constant result
    // Used for decrypting constants

    if (mop.t == mop_n) {
        return mop.nnn->value;
    }

    if (mop.t == mop_d && mop.d && mop.d->opcode == m_xor) {
        auto left = trace_xor_chain(mop.d->l, ctx);
        auto right = trace_xor_chain(mop.d->r, ctx);

        if (left && right) {
            return *left ^ *right;
        }
    }

    return std::nullopt;
}

} // namespace expr_simplify

```

`src/deobf/analysis/expr_simplify.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Expression simplification using algebraic rules and optionally Z3
// This handles the Hikari substitution patterns
//--------------------------------------------------------------------------
namespace expr_simplify {

// Result of simplification attempt
struct simplify_result_t {
    bool simplified;
    mcode_t new_opcode;     // Simplified opcode (if applicable)
    mop_t new_left;         // Simplified left operand
    mop_t new_right;        // Simplified right operand
    uint64_t const_result;  // If entire expression folds to constant
    bool is_const;

    simplify_result_t() : simplified(false), new_opcode(m_nop),
                         const_result(0), is_const(false) {}
};

// Main simplification entry point
simplify_result_t simplify_instruction(minsn_t *insn, deobf_ctx_t *ctx);

// Try to simplify the operand tree rooted at this mop
simplify_result_t simplify_mop(const mop_t &mop, deobf_ctx_t *ctx);

// Algebraic simplification rules
bool try_simplify_add(minsn_t *insn, simplify_result_t *out);
bool try_simplify_sub(minsn_t *insn, simplify_result_t *out);
bool try_simplify_and(minsn_t *insn, simplify_result_t *out);
bool try_simplify_or(minsn_t *insn, simplify_result_t *out);
bool try_simplify_xor(minsn_t *insn, simplify_result_t *out);
bool try_simplify_mul(minsn_t *insn, simplify_result_t *out);

// Pattern-specific simplifiers for Hikari substitutions
bool simplify_hikari_add_pattern1(minsn_t *insn, simplify_result_t *out);  // b - ~c - 1 => b + c
bool simplify_hikari_add_pattern2(minsn_t *insn, simplify_result_t *out);  // (b|c) + (b&c) => b + c
bool simplify_hikari_add_pattern3(minsn_t *insn, simplify_result_t *out);  // (b^c) + 2*(b&c) => b + c
bool simplify_hikari_sub_pattern1(minsn_t *insn, simplify_result_t *out);  // b + ~c + 1 => b - c
bool simplify_hikari_and_pattern1(minsn_t *insn, simplify_result_t *out);  // (b ^ ~c) & b => b & c
bool simplify_hikari_or_pattern1(minsn_t *insn, simplify_result_t *out);   // (b&c) | (b^c) => b | c
bool simplify_hikari_xor_pattern1(minsn_t *insn, simplify_result_t *out);  // (~a&b) | (a&~b) => a ^ b

// Constant propagation through XOR chains (for encrypted constants)
std::optional<uint64_t> trace_xor_chain(const mop_t &mop, deobf_ctx_t *ctx);

// Check if two mops are semantically equivalent
bool mops_equal(const mop_t &a, const mop_t &b);

// Create a new mop from simplified result
mop_t make_mop_from_const(uint64_t val, int size);
mop_t make_mop_from_binop(mcode_t op, const mop_t &left, const mop_t &right);

} // namespace expr_simplify

```

`src/deobf/analysis/mop_utils.h`:

```h
#pragma once
#include "../deobf_types.h"
#include "../../common/simd.h"

//--------------------------------------------------------------------------
// Microcode Operand Utilities - OPTIMIZED
//
// Provides fast comparison and hashing for mop_t operands using SIMD
// acceleration where beneficial.
//
// Key optimizations:
//   - Branch-free comparison for common types
//   - Pre-computed hash for O(1) equality check
//   - Memory-aligned access patterns
//--------------------------------------------------------------------------

namespace chernobog {
namespace mop {

//--------------------------------------------------------------------------
// Fast mop_t equality check
// Ignores size differences for pattern matching compatibility
//--------------------------------------------------------------------------
SIMD_FORCE_INLINE bool equal_ignore_size(const mop_t& a, const mop_t& b) {
    // Fast path: type must match
    if ( SIMD_UNLIKELY(a.t != b.t) ) return false;
    
    // Type-specific comparison with branch hints
    switch (a.t) {
        case mop_r:  // Register - single int comparison
            return a.r == b.r;
            
        case mop_n:  // Number constant
            if ( SIMD_UNLIKELY(!a.nnn || !b.nnn) ) return a.nnn == b.nnn;
            return a.nnn->value == b.nnn->value;
            
        case mop_S:  // Stack variable
            if ( SIMD_UNLIKELY(!a.s || !b.s) ) return a.s == b.s;
            return a.s->off == b.s->off;
            
        case mop_v:  // Global variable - single uint64 comparison
            return a.g == b.g;
            
        case mop_l:  // Local variable
            if ( SIMD_UNLIKELY(!a.l || !b.l) ) return a.l == b.l;
            return (a.l->idx == b.l->idx) & (a.l->off == b.l->off);
            
        case mop_d:  // Result of another instruction
            if ( SIMD_UNLIKELY(!a.d || !b.d) ) return a.d == b.d;
            return a.d->equal_insns(*b.d, EQ_IGNSIZE);
            
        case mop_b:  // Block reference
            return a.b == b.b;
            
        case mop_h:  // Helper function
            if ( SIMD_UNLIKELY(!a.helper || !b.helper) ) return a.helper == b.helper;
            return strcmp(a.helper, b.helper) == 0;
            
        case mop_str:  // String
            if ( SIMD_UNLIKELY(!a.cstr || !b.cstr) ) return a.cstr == b.cstr;
            return strcmp(a.cstr, b.cstr) == 0;
            
        case mop_a:  // Address operand - recurse
            if ( SIMD_UNLIKELY(!a.a || !b.a) ) return a.a == b.a;
            return equal_ignore_size(*a.a, *b.a);
            
        case mop_z:  // Empty
            return true;
            
        default:
            return false;
    }
}

//--------------------------------------------------------------------------
// Fast mop_t hash computation
// Used for hash tables and deduplication
//--------------------------------------------------------------------------
SIMD_FORCE_INLINE uint64_t hash(const mop_t& m) {
    uint64_t h = simd::hash_u64(static_cast<uint64_t>(m.t));
    
    switch (m.t) {
        case mop_r:
            h = simd::hash_combine(h, simd::hash_u64(m.r));
            break;
            
        case mop_n:
            if ( m.nnn ) {
                h = simd::hash_combine(h, simd::hash_u64(m.nnn->value));
            }
            break;
            
        case mop_S:
            if ( m.s ) {
                h = simd::hash_combine(h, simd::hash_u64(static_cast<uint64_t>(m.s->off)));
            }
            break;
            
        case mop_v:
            h = simd::hash_combine(h, simd::hash_u64(m.g));
            break;
            
        case mop_l:
            if ( m.l ) {
                h = simd::hash_combine(h, simd::hash_u64(m.l->idx));
                h = simd::hash_combine(h, simd::hash_u64(m.l->off));
            }
            break;
            
        case mop_d:
            if ( m.d ) {
                // Hash based on opcode and operand structure
                h = simd::hash_combine(h, simd::hash_u64(m.d->opcode));
                h = simd::hash_combine(h, hash(m.d->l));
                h = simd::hash_combine(h, hash(m.d->r));
            }
            break;
            
        case mop_b:
            h = simd::hash_combine(h, simd::hash_u64(m.b));
            break;
            
        case mop_h:
            if ( m.helper ) {
                h = simd::hash_combine(h, simd::hash_bytes(m.helper, strlen(m.helper)));
            }
            break;
            
        case mop_str:
            if ( m.cstr ) {
                h = simd::hash_combine(h, simd::hash_bytes(m.cstr, strlen(m.cstr)));
            }
            break;
            
        case mop_a:
            if ( m.a ) {
                h = simd::hash_combine(h, hash(*m.a));
            }
            break;
            
        default:
            break;
    }
    
    return h;
}

//--------------------------------------------------------------------------
// Check if operand is constant
//--------------------------------------------------------------------------
SIMD_FORCE_INLINE bool is_const(const mop_t& m) {
    return m.t == mop_n && m.nnn != nullptr;
}

//--------------------------------------------------------------------------
// Get constant value (returns 0 if not constant)
//--------------------------------------------------------------------------
SIMD_FORCE_INLINE uint64_t get_const_value(const mop_t& m) {
    if ( SIMD_LIKELY(m.t == mop_n && m.nnn) ) {
        return m.nnn->value;
    }
    return 0;
}

//--------------------------------------------------------------------------
// Check if operand is a negation (~x) of another
//--------------------------------------------------------------------------
SIMD_FORCE_INLINE bool is_bnot_of(const mop_t& a, const mop_t& b) {
    if ( a.t != mop_d || !a.d ) return false;
    if ( a.d->opcode != m_bnot ) return false;
    return equal_ignore_size(a.d->l, b);
}

//--------------------------------------------------------------------------
// Check if operand is arithmetic negation (-x) of another
//--------------------------------------------------------------------------
SIMD_FORCE_INLINE bool is_neg_of(const mop_t& a, const mop_t& b) {
    if ( a.t != mop_d || !a.d ) return false;
    if ( a.d->opcode != m_neg ) return false;
    return equal_ignore_size(a.d->l, b);
}

//--------------------------------------------------------------------------
// Operand wrapper with pre-computed hash for use in hash containers
//--------------------------------------------------------------------------
struct MopWithHash {
    const mop_t* mop;
    uint64_t hash_value;
    
    MopWithHash() : mop(nullptr), hash_value(0) {}
    MopWithHash(const mop_t& m) : mop(&m), hash_value(hash(m)) {}
    
    bool operator==(const MopWithHash& other) const {
        // Fast path: hash mismatch
        if ( hash_value != other.hash_value ) return false;
        // Full comparison for collision resolution
        if ( !mop || !other.mop ) return mop == other.mop;
        return equal_ignore_size(*mop, *other.mop);
    }
    
    struct Hash {
        size_t operator()(const MopWithHash& m) const noexcept {
            return static_cast<size_t>(m.hash_value);
        }
    };
};

} // namespace mop
} // namespace chernobog

```

`src/deobf/analysis/opaque_eval.cpp`:

```cpp
#include "opaque_eval.h"
#include "z3_solver.h"

// Static members
std::map<ea_t, uint64_t> opaque_eval_t::s_global_cache;
static bool s_z3_enabled = true;
static unsigned s_z3_timeout_ms = 1000;

//--------------------------------------------------------------------------
// Clear cache
//--------------------------------------------------------------------------
void opaque_eval_t::clear_cache() {
    s_global_cache.clear();
}

//--------------------------------------------------------------------------
// Evaluate a condition to determine if it's always true/false
//--------------------------------------------------------------------------
bool opaque_eval_t::evaluate_condition(minsn_t *cond, bool *out_result) {
    if (!cond || !out_result)
        return false;

    eval_state_t state;
    state.depth = 0;

    // Handle conditional jumps
    if (cond->opcode == m_jnz || cond->opcode == m_jz ||
        cond->opcode == m_jg || cond->opcode == m_jge ||
        cond->opcode == m_jl || cond->opcode == m_jle ||
        cond->opcode == m_ja || cond->opcode == m_jae ||
        cond->opcode == m_jb || cond->opcode == m_jbe) {

        // Evaluate the left operand (condition value)
        auto left_val = eval_mop(cond->l, state);
        if (!left_val.has_value())
            return false;

        auto right_val = eval_mop(cond->r, state);
        if (!right_val.has_value())
            return false;

        uint64_t l = *left_val;
        uint64_t r = *right_val;
        int64_t sl = sign_extend(l, cond->l.size);
        int64_t sr = sign_extend(r, cond->r.size);

        bool result = false;
        switch (cond->opcode) {
            case m_jnz:  result = (l != r); break;
            case m_jz:   result = (l == r); break;
            case m_jg:   result = (sl > sr); break;
            case m_jge:  result = (sl >= sr); break;
            case m_jl:   result = (sl < sr); break;
            case m_jle:  result = (sl <= sr); break;
            case m_ja:   result = (l > r); break;
            case m_jae:  result = (l >= r); break;
            case m_jb:   result = (l < r); break;
            case m_jbe:  result = (l <= r); break;
            default: return false;
        }

        *out_result = result;
        return true;
    }

    // Handle setX instructions
    if (cond->opcode == m_setnz || cond->opcode == m_setz ||
        cond->opcode == m_setg || cond->opcode == m_setge ||
        cond->opcode == m_setl || cond->opcode == m_setle ||
        cond->opcode == m_seta || cond->opcode == m_setae ||
        cond->opcode == m_setb || cond->opcode == m_setbe) {

        auto left_val = eval_mop(cond->l, state);
        auto right_val = eval_mop(cond->r, state);

        if (!left_val.has_value() || !right_val.has_value())
            return false;

        uint64_t l = *left_val;
        uint64_t r = *right_val;
        int64_t sl = sign_extend(l, cond->l.size);
        int64_t sr = sign_extend(r, cond->r.size);

        bool result = false;
        switch (cond->opcode) {
            case m_setnz: result = (l != r); break;
            case m_setz:  result = (l == r); break;
            case m_setg:  result = (sl > sr); break;
            case m_setge: result = (sl >= sr); break;
            case m_setl:  result = (sl < sr); break;
            case m_setle: result = (sl <= sr); break;
            case m_seta:  result = (l > r); break;
            case m_setae: result = (l >= r); break;
            case m_setb:  result = (l < r); break;
            case m_setbe: result = (l <= r); break;
            default: return false;
        }

        *out_result = result;
        return true;
    }

    // Try to evaluate as a general expression
    auto val = eval_insn(cond, state);
    if (val.has_value()) {
        *out_result = (*val != 0);
        return true;
    }

    return false;
}

//--------------------------------------------------------------------------
// Evaluate expression to constant
//--------------------------------------------------------------------------
std::optional<uint64_t> opaque_eval_t::evaluate_expr(minsn_t *expr) {
    if (!expr)
        return std::nullopt;

    eval_state_t state;
    state.depth = 0;
    return eval_insn(expr, state);
}

std::optional<uint64_t> opaque_eval_t::evaluate_operand(const mop_t &op) {
    eval_state_t state;
    state.depth = 0;
    return eval_mop(op, state);
}

//--------------------------------------------------------------------------
// Read global from binary
//--------------------------------------------------------------------------
std::optional<uint64_t> opaque_eval_t::read_global(ea_t addr, int size) {
    // Check cache
    auto it = s_global_cache.find(addr);
    if (it != s_global_cache.end()) {
        return mask_by_size(it->second, size);
    }

    // Read from binary
    uint64_t val = 0;
    int bytes_to_read = (size > 0) ? size : (inf_is_64bit() ? 8 : 4);

    if (bytes_to_read > 8)
        bytes_to_read = 8;

    if (get_bytes(&val, bytes_to_read, addr) != bytes_to_read) {
        return std::nullopt;
    }

    // Cache and return
    s_global_cache[addr] = val;
    return mask_by_size(val, size);
}

//--------------------------------------------------------------------------
// Core instruction evaluation
//--------------------------------------------------------------------------
std::optional<uint64_t> opaque_eval_t::eval_insn(minsn_t *ins, eval_state_t &state) {
    if (!ins || state.depth > MAX_EVAL_DEPTH)
        return std::nullopt;

    state.depth++;

    std::optional<uint64_t> result;
    int size = ins->d.size > 0 ? ins->d.size : 4;

    // Get operand values
    auto l_val = eval_mop(ins->l, state);
    auto r_val = eval_mop(ins->r, state);

    switch (ins->opcode) {
        case m_mov:
        case m_ldx:
            result = l_val;
            break;

        case m_add:
            if (l_val && r_val)
                result = eval_add(*l_val, *r_val, size);
            break;

        case m_sub:
            if (l_val && r_val)
                result = eval_sub(*l_val, *r_val, size);
            break;

        case m_mul:
            if (l_val && r_val)
                result = eval_mul(*l_val, *r_val, size);
            break;

        case m_udiv:
            if (l_val && r_val && *r_val != 0)
                result = eval_udiv(*l_val, *r_val, size);
            break;

        case m_sdiv:
            if (l_val && r_val && *r_val != 0)
                result = eval_sdiv(sign_extend(*l_val, size), sign_extend(*r_val, size), size);
            break;

        case m_umod:
            if (l_val && r_val && *r_val != 0)
                result = eval_umod(*l_val, *r_val, size);
            break;

        case m_smod:
            if (l_val && r_val && *r_val != 0)
                result = eval_smod(sign_extend(*l_val, size), sign_extend(*r_val, size), size);
            break;

        case m_and:
            if (l_val && r_val)
                result = eval_and(*l_val, *r_val, size);
            break;

        case m_or:
            if (l_val && r_val)
                result = eval_or(*l_val, *r_val, size);
            break;

        case m_xor:
            if (l_val && r_val)
                result = eval_xor(*l_val, *r_val, size);
            break;

        case m_bnot:
        case m_lnot:
            if (l_val)
                result = eval_not(*l_val, size);
            break;

        case m_neg:
            if (l_val)
                result = eval_neg(*l_val, size);
            break;

        case m_shl:
            if (l_val && r_val)
                result = eval_shl(*l_val, *r_val, size);
            break;

        case m_shr:
            if (l_val && r_val)
                result = eval_shr(*l_val, *r_val, size);
            break;

        case m_sar:
            if (l_val && r_val)
                result = eval_sar(sign_extend(*l_val, size), *r_val, size);
            break;

        // Set operations (return 0 or 1)
        case m_setz:
            if (l_val && r_val) {
                auto b = eval_setz(*l_val - *r_val);
                if (b) result = *b ? 1 : 0;
            }
            break;

        case m_setnz:
            if (l_val && r_val) {
                auto b = eval_setnz(*l_val - *r_val);
                if (b) result = *b ? 1 : 0;
            }
            break;

        case m_setl:
            if (l_val && r_val) {
                auto b = eval_setl(sign_extend(*l_val, size), sign_extend(*r_val, size));
                if (b) result = *b ? 1 : 0;
            }
            break;

        case m_setle:
            if (l_val && r_val) {
                auto b = eval_setle(sign_extend(*l_val, size), sign_extend(*r_val, size));
                if (b) result = *b ? 1 : 0;
            }
            break;

        case m_setg:
            if (l_val && r_val) {
                auto b = eval_setg(sign_extend(*l_val, size), sign_extend(*r_val, size));
                if (b) result = *b ? 1 : 0;
            }
            break;

        case m_setge:
            if (l_val && r_val) {
                auto b = eval_setge(sign_extend(*l_val, size), sign_extend(*r_val, size));
                if (b) result = *b ? 1 : 0;
            }
            break;

        case m_setb:
            if (l_val && r_val) {
                auto b = eval_setb(*l_val, *r_val);
                if (b) result = *b ? 1 : 0;
            }
            break;

        case m_setbe:
            if (l_val && r_val) {
                auto b = eval_setbe(*l_val, *r_val);
                if (b) result = *b ? 1 : 0;
            }
            break;

        case m_seta:
            if (l_val && r_val) {
                auto b = eval_seta(*l_val, *r_val);
                if (b) result = *b ? 1 : 0;
            }
            break;

        case m_setae:
            if (l_val && r_val) {
                auto b = eval_setae(*l_val, *r_val);
                if (b) result = *b ? 1 : 0;
            }
            break;

        default:
            // Unknown operation
            break;
    }

    state.depth--;
    return result;
}

//--------------------------------------------------------------------------
// Operand evaluation
//--------------------------------------------------------------------------
std::optional<uint64_t> opaque_eval_t::eval_mop(const mop_t &op, eval_state_t &state) {
    switch (op.t) {
        case mop_n:
            // Immediate value
            return mask_by_size(op.nnn->value, op.size);

        case mop_v:
            // Global variable - read from binary
            return read_global(op.g, op.size);

        case mop_d:
            // Sub-instruction result
            if (op.d)
                return eval_insn(op.d, state);
            break;

        case mop_r:
            // Register - check if we have a cached value
            if (state.temps.count(op.r))
                return state.temps[op.r];
            break;

        case mop_z:
            // Zero
            return 0;

        case mop_a:
            // Address - mop_addr_t inherits from mop_t
            // The actual address is in the contained operand
            if (op.a) {
                // If pointing to a global, return the global address
                if (op.a->t == mop_v)
                    return op.a->g;
            }
            break;

        case mop_l:
            // Local variable - generally can't evaluate statically
            break;

        case mop_S:
            // Stack variable - generally can't evaluate statically
            break;

        default:
            break;
    }

    return std::nullopt;
}

//--------------------------------------------------------------------------
// Arithmetic operations
//--------------------------------------------------------------------------
std::optional<uint64_t> opaque_eval_t::eval_add(uint64_t a, uint64_t b, int size) {
    return mask_by_size(a + b, size);
}

std::optional<uint64_t> opaque_eval_t::eval_sub(uint64_t a, uint64_t b, int size) {
    return mask_by_size(a - b, size);
}

std::optional<uint64_t> opaque_eval_t::eval_mul(uint64_t a, uint64_t b, int size) {
    return mask_by_size(a * b, size);
}

std::optional<uint64_t> opaque_eval_t::eval_udiv(uint64_t a, uint64_t b, int size) {
    if (b == 0) return std::nullopt;
    return mask_by_size(a / b, size);
}

std::optional<uint64_t> opaque_eval_t::eval_sdiv(int64_t a, int64_t b, int size) {
    if (b == 0) return std::nullopt;
    return mask_by_size((uint64_t)(a / b), size);
}

std::optional<uint64_t> opaque_eval_t::eval_umod(uint64_t a, uint64_t b, int size) {
    if (b == 0) return std::nullopt;
    return mask_by_size(a % b, size);
}

std::optional<uint64_t> opaque_eval_t::eval_smod(int64_t a, int64_t b, int size) {
    if (b == 0) return std::nullopt;
    return mask_by_size((uint64_t)(a % b), size);
}

//--------------------------------------------------------------------------
// Bitwise operations
//--------------------------------------------------------------------------
std::optional<uint64_t> opaque_eval_t::eval_and(uint64_t a, uint64_t b, int size) {
    return mask_by_size(a & b, size);
}

std::optional<uint64_t> opaque_eval_t::eval_or(uint64_t a, uint64_t b, int size) {
    return mask_by_size(a | b, size);
}

std::optional<uint64_t> opaque_eval_t::eval_xor(uint64_t a, uint64_t b, int size) {
    return mask_by_size(a ^ b, size);
}

std::optional<uint64_t> opaque_eval_t::eval_not(uint64_t a, int size) {
    return mask_by_size(~a, size);
}

std::optional<uint64_t> opaque_eval_t::eval_neg(uint64_t a, int size) {
    return mask_by_size((uint64_t)(-(int64_t)a), size);
}

//--------------------------------------------------------------------------
// Shift operations
//--------------------------------------------------------------------------
std::optional<uint64_t> opaque_eval_t::eval_shl(uint64_t a, uint64_t b, int size) {
    if (b >= 64) return 0;
    return mask_by_size(a << b, size);
}

std::optional<uint64_t> opaque_eval_t::eval_shr(uint64_t a, uint64_t b, int size) {
    if (b >= 64) return 0;
    return mask_by_size(a >> b, size);
}

std::optional<uint64_t> opaque_eval_t::eval_sar(int64_t a, uint64_t b, int size) {
    if (b >= 64) return (a < 0) ? mask_by_size(-1, size) : 0;
    return mask_by_size((uint64_t)(a >> b), size);
}

//--------------------------------------------------------------------------
// Comparison operations
//--------------------------------------------------------------------------
std::optional<bool> opaque_eval_t::eval_setz(uint64_t a) {
    return a == 0;
}

std::optional<bool> opaque_eval_t::eval_setnz(uint64_t a) {
    return a != 0;
}

std::optional<bool> opaque_eval_t::eval_setl(int64_t a, int64_t b) {
    return a < b;
}

std::optional<bool> opaque_eval_t::eval_setle(int64_t a, int64_t b) {
    return a <= b;
}

std::optional<bool> opaque_eval_t::eval_setg(int64_t a, int64_t b) {
    return a > b;
}

std::optional<bool> opaque_eval_t::eval_setge(int64_t a, int64_t b) {
    return a >= b;
}

std::optional<bool> opaque_eval_t::eval_setb(uint64_t a, uint64_t b) {
    return a < b;
}

std::optional<bool> opaque_eval_t::eval_setbe(uint64_t a, uint64_t b) {
    return a <= b;
}

std::optional<bool> opaque_eval_t::eval_seta(uint64_t a, uint64_t b) {
    return a > b;
}

std::optional<bool> opaque_eval_t::eval_setae(uint64_t a, uint64_t b) {
    return a >= b;
}

//--------------------------------------------------------------------------
// Helper functions
//--------------------------------------------------------------------------
uint64_t opaque_eval_t::mask_by_size(uint64_t val, int size) {
    switch (size) {
        case 1: return val & 0xFF;
        case 2: return val & 0xFFFF;
        case 4: return val & 0xFFFFFFFF;
        case 8:
        default: return val;
    }
}

int64_t opaque_eval_t::sign_extend(uint64_t val, int size) {
    switch (size) {
        case 1: return (int64_t)(int8_t)(val & 0xFF);
        case 2: return (int64_t)(int16_t)(val & 0xFFFF);
        case 4: return (int64_t)(int32_t)(val & 0xFFFFFFFF);
        case 8:
        default: return (int64_t)val;
    }
}

//--------------------------------------------------------------------------
// Z3-enhanced API implementation
//--------------------------------------------------------------------------

void opaque_eval_t::set_z3_enabled(bool enabled) {
    s_z3_enabled = enabled;
}

bool opaque_eval_t::is_z3_enabled() {
    return s_z3_enabled;
}

void opaque_eval_t::set_z3_timeout(unsigned ms) {
    s_z3_timeout_ms = ms;
    if (s_z3_enabled) {
        z3_solver::set_global_timeout(ms);
    }
}

//--------------------------------------------------------------------------
// Evaluate with detailed result information
//--------------------------------------------------------------------------
opaque_eval_t::eval_result_t opaque_eval_t::evaluate_detailed(minsn_t *expr) {
    if (!expr)
        return eval_result_t::unknown("null expression");

    // First try fast constant propagation
    eval_state_t state;
    state.depth = 0;
    auto simple_result = eval_insn(expr, state);

    if (simple_result.has_value()) {
        return eval_result_t::success(*simple_result);
    }

    // Fall back to Z3 if enabled
    if (s_z3_enabled) {
        try {
            z3_solver::set_global_timeout(s_z3_timeout_ms);
            auto z3_result = z3_solver::evaluate_to_constant(expr);

            if (z3_result.is_constant) {
                eval_result_t r;
                r.status = EVAL_SUCCESS;
                r.is_constant = true;
                r.value = z3_result.value;
                r.reason = "Z3 evaluation";
                return r;
            }
        } catch (...) {
            // Z3 exception - fall through to unknown
        }
    }

    return eval_result_t::unknown("could not evaluate");
}

//--------------------------------------------------------------------------
// Check if condition is an opaque predicate using Z3
//--------------------------------------------------------------------------
opaque_eval_t::opaque_result_t opaque_eval_t::check_opaque_predicate(minsn_t *cond) {
    if (!cond)
        return OPAQUE_UNKNOWN;

    // First try simple evaluation
    bool result;
    if (evaluate_condition(cond, &result)) {
        return result ? OPAQUE_ALWAYS_TRUE : OPAQUE_ALWAYS_FALSE;
    }

    // Use Z3 for complex predicates
    if (!s_z3_enabled)
        return OPAQUE_UNKNOWN;

    try {
        z3_solver::set_global_timeout(s_z3_timeout_ms);
        z3_solver::opaque_predicate_solver_t solver(z3_solver::get_global_context());
        auto z3_result = solver.analyze_condition(cond);

        switch (z3_result) {
            case z3_solver::opaque_predicate_solver_t::PRED_ALWAYS_TRUE:
                return OPAQUE_ALWAYS_TRUE;
            case z3_solver::opaque_predicate_solver_t::PRED_ALWAYS_FALSE:
                return OPAQUE_ALWAYS_FALSE;
            case z3_solver::opaque_predicate_solver_t::PRED_DEPENDS_ON_INPUT:
                return OPAQUE_NOT_OPAQUE;
            default:
                return OPAQUE_UNKNOWN;
        }
    } catch (...) {
        return OPAQUE_UNKNOWN;
    }
}

//--------------------------------------------------------------------------
// Prove two expressions are equivalent using Z3
//--------------------------------------------------------------------------
bool opaque_eval_t::prove_equivalent(minsn_t *a, minsn_t *b) {
    if (!a || !b)
        return false;

    // Quick check: if both evaluate to same constant, they're equivalent
    auto val_a = evaluate_expr(a);
    auto val_b = evaluate_expr(b);

    if (val_a.has_value() && val_b.has_value()) {
        return *val_a == *val_b;
    }

    // Use Z3 for symbolic equivalence
    if (!s_z3_enabled)
        return false;

    try {
        z3_solver::set_global_timeout(s_z3_timeout_ms);
        return z3_solver::instructions_equivalent(a, b);
    } catch (...) {
        return false;
    }
}

//--------------------------------------------------------------------------
// Simplify expression using Z3 and return simplified form if possible
//--------------------------------------------------------------------------
std::optional<uint64_t> opaque_eval_t::z3_simplify(minsn_t *expr) {
    if (!expr || !s_z3_enabled)
        return std::nullopt;

    try {
        z3_solver::set_global_timeout(s_z3_timeout_ms);
        auto result = z3_solver::evaluate_to_constant(expr);

        if (result.is_constant) {
            return result.value;
        }
    } catch (...) {
        // Z3 exception
    }

    return std::nullopt;
}

```

`src/deobf/analysis/opaque_eval.h`:

```h
#pragma once
#include "../deobf_types.h"
#include <map>
#include <optional>

//--------------------------------------------------------------------------
// Opaque Predicate Evaluator
//
// Evaluates complex boolean expressions that use global constants.
// These are commonly used in Hikari-style obfuscation where:
//   - Global constants are loaded: dword_XXX, dword_YYY
//   - Complex expressions are computed: ~(~a | ~b) & mask ...
//   - Results are compared to determine branch direction
//   - The expression ALWAYS evaluates to the same result
//
// Approach:
//   1. Read actual values of global constants from binary
//   2. Symbolically evaluate the expression using Z3 when needed
//   3. Determine if the condition is constant
//   4. Return the constant result
//
// The evaluator uses a two-tier approach:
//   - Tier 1: Fast constant propagation for simple expressions
//   - Tier 2: Z3 SMT solver for complex/symbolic expressions
//--------------------------------------------------------------------------
class opaque_eval_t {
public:
    //----------------------------------------------------------------------
    // Result types for detailed analysis
    //----------------------------------------------------------------------
    enum eval_status_t {
        EVAL_SUCCESS,           // Successfully evaluated
        EVAL_UNKNOWN,           // Could not determine
        EVAL_TIMEOUT,           // Z3 solver timed out
        EVAL_COMPLEX,           // Too complex, gave up
    };

    struct eval_result_t {
        eval_status_t status;
        bool is_constant;       // True if expression is constant
        uint64_t value;         // The constant value (if is_constant)
        std::string reason;     // Human-readable explanation

        eval_result_t() : status(EVAL_UNKNOWN), is_constant(false), value(0) {}
        static eval_result_t success(uint64_t v) {
            eval_result_t r;
            r.status = EVAL_SUCCESS;
            r.is_constant = true;
            r.value = v;
            return r;
        }
        static eval_result_t unknown(const std::string& reason = "") {
            eval_result_t r;
            r.status = EVAL_UNKNOWN;
            r.reason = reason;
            return r;
        }
    };

    //----------------------------------------------------------------------
    // Primary API
    //----------------------------------------------------------------------

    // Evaluate a microcode condition expression
    // Returns: true if constant, with result in *out_result
    static bool evaluate_condition(minsn_t *cond, bool *out_result);

    // Evaluate an arbitrary microcode expression to a constant
    // Returns: optional containing the value if constant
    static std::optional<uint64_t> evaluate_expr(minsn_t *expr);
    static std::optional<uint64_t> evaluate_operand(const mop_t &op);

    // Read a global constant from the binary
    static std::optional<uint64_t> read_global(ea_t addr, int size);

    // Clear cache (call when analyzing new function)
    static void clear_cache();

    //----------------------------------------------------------------------
    // Z3-enhanced API
    //----------------------------------------------------------------------

    // Evaluate with detailed result information
    static eval_result_t evaluate_detailed(minsn_t *expr);

    // Check if condition is an opaque predicate using Z3
    // Returns: ALWAYS_TRUE, ALWAYS_FALSE, or UNKNOWN
    enum opaque_result_t {
        OPAQUE_ALWAYS_TRUE,
        OPAQUE_ALWAYS_FALSE,
        OPAQUE_NOT_OPAQUE,      // Depends on input
        OPAQUE_UNKNOWN,         // Could not determine
    };
    static opaque_result_t check_opaque_predicate(minsn_t *cond);

    // Prove two expressions are equivalent using Z3
    static bool prove_equivalent(minsn_t *a, minsn_t *b);

    // Simplify expression using Z3 and return simplified form if possible
    static std::optional<uint64_t> z3_simplify(minsn_t *expr);

    //----------------------------------------------------------------------
    // Configuration
    //----------------------------------------------------------------------

    // Enable/disable Z3 backend (default: enabled)
    static void set_z3_enabled(bool enabled);
    static bool is_z3_enabled();

    // Set Z3 timeout in milliseconds (default: 1000ms)
    static void set_z3_timeout(unsigned ms);

private:
    // Evaluation state - tracks values during evaluation
    struct eval_state_t {
        std::map<ea_t, uint64_t> globals;     // Cached global values
        std::map<int, uint64_t> temps;         // Temporary values (mreg)
        int depth;                             // Recursion depth
    };

    // Core evaluation functions
    static std::optional<uint64_t> eval_insn(minsn_t *ins, eval_state_t &state);
    static std::optional<uint64_t> eval_mop(const mop_t &op, eval_state_t &state);

    // Arithmetic/logic operations
    static std::optional<uint64_t> eval_add(uint64_t a, uint64_t b, int size);
    static std::optional<uint64_t> eval_sub(uint64_t a, uint64_t b, int size);
    static std::optional<uint64_t> eval_mul(uint64_t a, uint64_t b, int size);
    static std::optional<uint64_t> eval_udiv(uint64_t a, uint64_t b, int size);
    static std::optional<uint64_t> eval_sdiv(int64_t a, int64_t b, int size);
    static std::optional<uint64_t> eval_umod(uint64_t a, uint64_t b, int size);
    static std::optional<uint64_t> eval_smod(int64_t a, int64_t b, int size);

    static std::optional<uint64_t> eval_and(uint64_t a, uint64_t b, int size);
    static std::optional<uint64_t> eval_or(uint64_t a, uint64_t b, int size);
    static std::optional<uint64_t> eval_xor(uint64_t a, uint64_t b, int size);
    static std::optional<uint64_t> eval_not(uint64_t a, int size);
    static std::optional<uint64_t> eval_neg(uint64_t a, int size);

    static std::optional<uint64_t> eval_shl(uint64_t a, uint64_t b, int size);
    static std::optional<uint64_t> eval_shr(uint64_t a, uint64_t b, int size);
    static std::optional<uint64_t> eval_sar(int64_t a, uint64_t b, int size);

    // Comparison operations
    static std::optional<bool> eval_setz(uint64_t a);
    static std::optional<bool> eval_setnz(uint64_t a);
    static std::optional<bool> eval_setl(int64_t a, int64_t b);
    static std::optional<bool> eval_setle(int64_t a, int64_t b);
    static std::optional<bool> eval_setg(int64_t a, int64_t b);
    static std::optional<bool> eval_setge(int64_t a, int64_t b);
    static std::optional<bool> eval_setb(uint64_t a, uint64_t b);
    static std::optional<bool> eval_setbe(uint64_t a, uint64_t b);
    static std::optional<bool> eval_seta(uint64_t a, uint64_t b);
    static std::optional<bool> eval_setae(uint64_t a, uint64_t b);

    // Mask value by size
    static uint64_t mask_by_size(uint64_t val, int size);
    static int64_t sign_extend(uint64_t val, int size);

    // Global cache
    static std::map<ea_t, uint64_t> s_global_cache;
    static constexpr int MAX_EVAL_DEPTH = 100;
};

```

`src/deobf/analysis/pattern_fuzzer.cpp`:

```cpp
#include "pattern_fuzzer.h"
#include "../../common/simd.h"
#include <algorithm>
#include <numeric>
#include <unordered_set>

namespace chernobog {
namespace ast {

// Default configuration - OPTIMIZED defaults
PatternFuzzer::Config PatternFuzzer::config_ = {
    true,   // fuzz_commutative - Enable commutative - critical for matching
    false,  // fuzz_add_sub - Disabled - slow and rarely needed
    false,  // fuzz_associative - Disabled - slow
    32      // max_variants - Increased limit with optimization
};

void PatternFuzzer::set_config(const Config& cfg) {
    config_ = cfg;
}

const PatternFuzzer::Config& PatternFuzzer::get_config() {
    return config_;
}

//--------------------------------------------------------------------------
// Main entry point
//--------------------------------------------------------------------------
std::vector<AstPtr> PatternFuzzer::generate_variants(AstPtr pattern) {
    if (!pattern) {
        return {};
    }

    std::set<mcode_t> excluded;
    auto variants = fuzz_recursive(pattern, excluded);

    // Deduplicate and limit
    variants = deduplicate(variants);

    if (variants.size() > static_cast<size_t>(config_.max_variants)) {
        variants.resize(config_.max_variants);
    }

    return variants;
}

//--------------------------------------------------------------------------
// Recursive fuzzer
//--------------------------------------------------------------------------
std::vector<AstPtr> PatternFuzzer::fuzz_recursive(
    AstPtr node,
    const std::set<mcode_t>& excluded_ops) {

    if (!node) {
        return {nullptr};
    }

    // Leaf nodes don't get fuzzed
    if (node->is_leaf()) {
        return {node->clone()};
    }

    auto ast_node = std::static_pointer_cast<AstNode>(node);
    mcode_t op = ast_node->opcode;

    // Check if this opcode is excluded (to prevent infinite recursion in chains)
    if (excluded_ops.count(op) > 0) {
        // Just recurse on children without reordering
        return fuzz_unary_op(node, excluded_ops);
    }

    // Handle based on opcode type
    if (is_add_sub(op) && config_.fuzz_add_sub) {
        return fuzz_add_sub_op(node, excluded_ops);
    }

    if (is_commutative(op) && config_.fuzz_commutative) {
        return fuzz_commutative_op(node, excluded_ops);
    }

    // Non-commutative binary op or unary op
    return fuzz_unary_op(node, excluded_ops);
}

//--------------------------------------------------------------------------
// Commutative operation fuzzing
//--------------------------------------------------------------------------
std::vector<AstPtr> PatternFuzzer::fuzz_commutative_op(
    AstPtr node,
    const std::set<mcode_t>& excluded_ops) {

    auto ast_node = std::static_pointer_cast<AstNode>(node);
    mcode_t op = ast_node->opcode;

    // Get all operands from chained operations
    auto operands = get_flat_operands(node, op);

    if (operands.size() < 2) {
        return fuzz_unary_op(node, excluded_ops);
    }

    // Generate all permutations
    auto perms = permute(operands);

    std::vector<AstPtr> results;

    // Exclude this opcode when recursing to prevent re-flattening
    std::set<mcode_t> new_excluded = excluded_ops;
    new_excluded.insert(op);

    for (const auto& perm : perms) {
        // Fuzz each operand recursively
        std::vector<std::vector<AstPtr>> operand_variants;
        for (const auto& operand : perm) {
            auto variants = fuzz_recursive(operand, new_excluded);
            operand_variants.push_back(variants);
        }

        // OPTIMIZED: Build combinations without copying vectors on every iteration
        // Use indices to track current combination, avoiding O(n!) allocations
        std::vector<size_t> indices(operand_variants.size(), 0);
        std::vector<std::vector<AstPtr>> combos;
        combos.reserve(config_.max_variants);
        
        bool done = false;
        while (!done) {
            // Build current combination from indices
            std::vector<AstPtr> combo;
            combo.reserve(operand_variants.size());
            for (size_t i = 0; i < operand_variants.size(); i++) {
                combo.push_back(operand_variants[i][indices[i]]);
            }
            combos.push_back(std::move(combo));
            
            // Check limit
            if (combos.size() >= static_cast<size_t>(config_.max_variants)) {
                break;
            }
            
            // Increment indices (like counting in mixed radix)
            done = true;
            for (size_t i = operand_variants.size(); i > 0; --i) {
                size_t idx = i - 1;
                indices[idx]++;
                if (indices[idx] < operand_variants[idx].size()) {
                    done = false;
                    break;
                }
                indices[idx] = 0;
            }
        }

        // Build binary trees from each combination
        for (const auto& combo : combos) {
            auto trees = build_all_binary_trees(combo, op);
            results.insert(results.end(), trees.begin(), trees.end());

            if (results.size() > static_cast<size_t>(config_.max_variants)) {
                break;
            }
        }

        if (results.size() > static_cast<size_t>(config_.max_variants)) {
            break;
        }
    }

    return results;
}

//--------------------------------------------------------------------------
// Add/Sub fuzzing (special due to interdependence)
//--------------------------------------------------------------------------
std::vector<AstPtr> PatternFuzzer::fuzz_add_sub_op(
    AstPtr node,
    const std::set<mcode_t>& excluded_ops) {

    // Get operands with sign tracking
    auto signed_ops = get_add_sub_operands(node);

    if (signed_ops.size() < 2) {
        return fuzz_unary_op(node, excluded_ops);
    }

    // Generate all permutations
    auto perms = permute_signed(signed_ops);

    std::vector<AstPtr> results;

    // Exclude add/sub when recursing
    std::set<mcode_t> new_excluded = excluded_ops;
    new_excluded.insert(m_add);
    new_excluded.insert(m_sub);

    for (const auto& perm : perms) {
        // Fuzz each operand recursively
        std::vector<std::vector<SignedOperand>> operand_variants;
        for (const auto& sop : perm) {
            auto variants = fuzz_recursive(sop.operand, new_excluded);
            std::vector<SignedOperand> sov;
            for (const auto& v : variants) {
                sov.emplace_back(v, sop.is_negated);
            }
            operand_variants.push_back(sov);
        }

        // OPTIMIZED: Build combinations without copying vectors on every iteration
        std::vector<size_t> indices(operand_variants.size(), 0);
        std::vector<std::vector<SignedOperand>> combos;
        combos.reserve(config_.max_variants);
        
        bool done = false;
        while (!done) {
            std::vector<SignedOperand> combo;
            combo.reserve(operand_variants.size());
            for (size_t i = 0; i < operand_variants.size(); i++) {
                combo.push_back(operand_variants[i][indices[i]]);
            }
            combos.push_back(std::move(combo));
            
            if (combos.size() >= static_cast<size_t>(config_.max_variants)) {
                break;
            }
            
            done = true;
            for (size_t i = operand_variants.size(); i > 0; --i) {
                size_t idx = i - 1;
                indices[idx]++;
                if (indices[idx] < operand_variants[idx].size()) {
                    done = false;
                    break;
                }
                indices[idx] = 0;
            }
        }

        // Build add/sub trees
        for (const auto& combo : combos) {
            auto trees = build_add_sub_trees(combo);
            results.insert(results.end(), trees.begin(), trees.end());

            if (results.size() > static_cast<size_t>(config_.max_variants)) {
                break;
            }
        }

        if (results.size() > static_cast<size_t>(config_.max_variants)) {
            break;
        }
    }

    return results;
}

//--------------------------------------------------------------------------
// Unary/non-commutative operation fuzzing
//--------------------------------------------------------------------------
std::vector<AstPtr> PatternFuzzer::fuzz_unary_op(
    AstPtr node,
    const std::set<mcode_t>& excluded_ops) {

    if (!node || node->is_leaf()) {
        return {node ? node->clone() : nullptr};
    }

    auto ast_node = std::static_pointer_cast<AstNode>(node);

    // Fuzz children
    auto left_variants = fuzz_recursive(ast_node->left, excluded_ops);
    std::vector<AstPtr> right_variants = {nullptr};
    if (ast_node->right) {
        right_variants = fuzz_recursive(ast_node->right, excluded_ops);
    }

    std::vector<AstPtr> results;

    for (const auto& left : left_variants) {
        for (const auto& right : right_variants) {
            auto new_node = std::make_shared<AstNode>(ast_node->opcode, left, right);
            new_node->dest_size = ast_node->dest_size;
            new_node->ea = ast_node->ea;
            results.push_back(new_node);

            if (results.size() > static_cast<size_t>(config_.max_variants)) {
                return results;
            }
        }
    }

    return results;
}

//--------------------------------------------------------------------------
// Operand extraction
//--------------------------------------------------------------------------
std::vector<AstPtr> PatternFuzzer::get_flat_operands(AstPtr node, mcode_t op) {
    std::vector<AstPtr> operands;

    if (!node || node->is_leaf()) {
        if (node) operands.push_back(node);
        return operands;
    }

    auto ast_node = std::static_pointer_cast<AstNode>(node);

    if (ast_node->opcode == op) {
        // Same opcode - flatten
        auto left_ops = get_flat_operands(ast_node->left, op);
        auto right_ops = get_flat_operands(ast_node->right, op);
        operands.insert(operands.end(), left_ops.begin(), left_ops.end());
        operands.insert(operands.end(), right_ops.begin(), right_ops.end());
    } else {
        // Different opcode - treat as single operand
        operands.push_back(node);
    }

    return operands;
}

std::vector<PatternFuzzer::SignedOperand>
PatternFuzzer::get_add_sub_operands(AstPtr node) {
    std::vector<SignedOperand> operands;

    if (!node || node->is_leaf()) {
        if (node) operands.emplace_back(node, false);
        return operands;
    }

    auto ast_node = std::static_pointer_cast<AstNode>(node);

    if (ast_node->opcode == m_add) {
        auto left_ops = get_add_sub_operands(ast_node->left);
        auto right_ops = get_add_sub_operands(ast_node->right);
        operands.insert(operands.end(), left_ops.begin(), left_ops.end());
        operands.insert(operands.end(), right_ops.begin(), right_ops.end());
    } else if (ast_node->opcode == m_sub) {
        auto left_ops = get_add_sub_operands(ast_node->left);
        auto right_ops = get_add_sub_operands(ast_node->right);

        // Left operands keep their sign
        operands.insert(operands.end(), left_ops.begin(), left_ops.end());

        // Right operands get negated
        for (auto& rop : right_ops) {
            rop.is_negated = !rop.is_negated;
        }
        operands.insert(operands.end(), right_ops.begin(), right_ops.end());
    } else {
        // Not add/sub - single operand
        operands.emplace_back(node, false);
    }

    return operands;
}

//--------------------------------------------------------------------------
// Binary tree building
//--------------------------------------------------------------------------
std::vector<AstPtr> PatternFuzzer::build_all_binary_trees(
    const std::vector<AstPtr>& operands, mcode_t op) {

    if (operands.empty()) {
        return {};
    }

    if (operands.size() == 1) {
        return {operands[0]};
    }

    if (operands.size() == 2) {
        return {make_node(op, operands[0], operands[1])};
    }

    // For 3+ operands, generate different tree structures
    // Left-associative and right-associative at minimum
    std::vector<AstPtr> results;

    // Left-associative: ((a op b) op c) op d
    AstPtr left_assoc = operands[0];
    for (size_t i = 1; i < operands.size(); i++) {
        left_assoc = make_node(op, left_assoc, operands[i]);
    }
    results.push_back(left_assoc);

    // Right-associative: a op (b op (c op d))
    AstPtr right_assoc = operands.back();
    for (int i = static_cast<int>(operands.size()) - 2; i >= 0; i--) {
        right_assoc = make_node(op, operands[i], right_assoc);
    }
    results.push_back(right_assoc);

    // For patterns we typically only need left-associative to match
    // IDA's representation, so limit tree variants

    return results;
}

std::vector<AstPtr> PatternFuzzer::build_add_sub_trees(
    const std::vector<SignedOperand>& operands) {

    if (operands.empty()) {
        return {};
    }

    if (operands.size() == 1) {
        if (operands[0].is_negated) {
            return {make_unary(m_neg, operands[0].operand)};
        }
        return {operands[0].operand};
    }

    std::vector<AstPtr> results;

    // Build left-associative tree
    // First operand
    AstPtr tree;
    if (operands[0].is_negated) {
        tree = make_unary(m_neg, operands[0].operand);
    } else {
        tree = operands[0].operand;
    }

    // Remaining operands
    for (size_t i = 1; i < operands.size(); i++) {
        if (operands[i].is_negated) {
            tree = make_node(m_sub, tree, operands[i].operand);
        } else {
            tree = make_node(m_add, tree, operands[i].operand);
        }
    }
    results.push_back(tree);

    // Also generate add/sub variations for each edge
    // This handles x + neg(y) <-> x - y
    for (size_t i = 1; i < operands.size(); i++) {
        auto variations = get_add_sub_variations(
            operands[i].is_negated ? m_sub : m_add,
            nullptr,  // Will be computed
            operands[i].operand);

        // Build tree with each variation for this position
        for (const auto& var : variations) {
            if (var && var != operands[i].operand) {
                // Create variant tree
                AstPtr var_tree;
                if (operands[0].is_negated) {
                    var_tree = make_unary(m_neg, operands[0].operand);
                } else {
                    var_tree = operands[0].operand;
                }

                for (size_t j = 1; j < operands.size(); j++) {
                    if (j == i) {
                        // Use variation
                        auto var_node = std::static_pointer_cast<AstNode>(var);
                        var_tree = make_node(var_node->opcode, var_tree, var_node->right);
                    } else if (operands[j].is_negated) {
                        var_tree = make_node(m_sub, var_tree, operands[j].operand);
                    } else {
                        var_tree = make_node(m_add, var_tree, operands[j].operand);
                    }
                }
                results.push_back(var_tree);
            }
        }
    }

    return results;
}

//--------------------------------------------------------------------------
// Add/Sub variations
//--------------------------------------------------------------------------
std::vector<AstPtr> PatternFuzzer::get_add_sub_variations(
    mcode_t op, AstPtr left, AstPtr right) {

    std::vector<AstPtr> results;

    if (!right) {
        return results;
    }

    // x + neg(y) -> x - y
    // x - neg(y) -> x + y
    if (right->is_node()) {
        auto right_node = std::static_pointer_cast<AstNode>(right);
        if (right_node->opcode == m_neg) {
            // Has negation - can convert
            mcode_t new_op = (op == m_add) ? m_sub : m_add;
            if (left) {
                results.push_back(make_node(new_op, left, right_node->left));
            } else {
                results.push_back(make_node(new_op, nullptr, right_node->left));
            }
        }
    }

    // Generate negation variant: x - y -> x + neg(y)
    if (op == m_sub && left) {
        results.push_back(make_node(m_add, left, make_unary(m_neg, right)));
    }

    return results;
}

//--------------------------------------------------------------------------
// Permutation utilities
//--------------------------------------------------------------------------
std::vector<std::vector<AstPtr>> PatternFuzzer::permute(
    const std::vector<AstPtr>& operands) {

    std::vector<std::vector<AstPtr>> results;

    if (operands.empty()) {
        return results;
    }

    // Generate indices
    std::vector<size_t> indices(operands.size());
    std::iota(indices.begin(), indices.end(), 0);

    // Generate all permutations
    do {
        std::vector<AstPtr> perm;
        for (size_t idx : indices) {
            perm.push_back(operands[idx]);
        }
        results.push_back(perm);

        // Limit to prevent explosion
        if (results.size() >= 24) {  // 4! = 24 (was 5! = 120)
            break;
        }
    } while (std::next_permutation(indices.begin(), indices.end()));

    return results;
}

std::vector<std::vector<PatternFuzzer::SignedOperand>>
PatternFuzzer::permute_signed(const std::vector<SignedOperand>& operands) {

    std::vector<std::vector<SignedOperand>> results;

    if (operands.empty()) {
        return results;
    }

    std::vector<size_t> indices(operands.size());
    std::iota(indices.begin(), indices.end(), 0);

    do {
        std::vector<SignedOperand> perm;
        for (size_t idx : indices) {
            perm.push_back(operands[idx]);
        }
        results.push_back(perm);

        if (results.size() >= 24) {  // 4! = 24 (was 5! = 120)
            break;
        }
    } while (std::next_permutation(indices.begin(), indices.end()));

    return results;
}

//--------------------------------------------------------------------------
// Deduplication - OPTIMIZED
// Uses hash-based comparison instead of expensive string generation
//--------------------------------------------------------------------------
static uint64_t compute_ast_hash(const AstBase* node) {
    if (!node) return 0;
    
    if (node->is_leaf()) {
        if (node->is_constant()) {
            auto c = static_cast<const AstConstant*>(node);
            return simd::hash_combine(simd::hash_u64(0xCAFE), simd::hash_u64(c->value));
        }
        auto leaf = static_cast<const AstLeaf*>(node);
        return simd::hash_bytes(leaf->name.data(), leaf->name.size());
    }
    
    auto n = static_cast<const AstNode*>(node);
    uint64_t h = simd::hash_u64(static_cast<uint64_t>(n->opcode));
    h = simd::hash_combine(h, compute_ast_hash(n->left.get()));
    h = simd::hash_combine(h, compute_ast_hash(n->right.get()));
    return h;
}

std::vector<AstPtr> PatternFuzzer::deduplicate(const std::vector<AstPtr>& variants) {
    std::vector<AstPtr> unique;
    std::unordered_set<uint64_t> seen;
    
    unique.reserve(variants.size());
    seen.reserve(variants.size());

    for (const auto& v : variants) {
        if (v) {
            uint64_t h = compute_ast_hash(v.get());
            if (seen.find(h) == seen.end()) {
                seen.insert(h);
                unique.push_back(v);
            }
        }
    }

    return unique;
}

} // namespace ast
} // namespace chernobog

```

`src/deobf/analysis/pattern_fuzzer.h`:

```h
#pragma once
#include "ast.h"
#include <vector>
#include <set>

//--------------------------------------------------------------------------
// Pattern Fuzzer - Generates Equivalent Pattern Variants
//
// For pattern matching to be effective, we need to handle:
//   1. Commutative operations: x + y == y + x
//   2. Add/Sub equivalence: x + neg(y) == x - y
//   3. Associative restructuring: (a + b) + c == a + (b + c)
//
// This fuzzer generates all mathematically equivalent variants of a pattern,
// allowing robust matching regardless of how the obfuscator arranged operands.
//
// Example: Pattern `(x XOR y) + 2*(x AND y)` generates ~32 variants
//
// Ported from d810-ng's handler.py ast_generator function
//--------------------------------------------------------------------------

namespace chernobog {
namespace ast {

//--------------------------------------------------------------------------
// Commutative opcodes
//--------------------------------------------------------------------------
inline bool is_commutative(mcode_t op) {
    switch (op) {
        case m_add:
        case m_mul:
        case m_and:
        case m_or:
        case m_xor:
            return true;
        default:
            return false;
    }
}

// Add and Sub are related (sub is add with negation)
inline bool is_add_sub(mcode_t op) {
    return op == m_add || op == m_sub;
}

//--------------------------------------------------------------------------
// Pattern Fuzzer
//--------------------------------------------------------------------------
class PatternFuzzer {
public:
    // Generate all equivalent pattern variants
    // Returns vector including the original plus all fuzzed variants
    static std::vector<AstPtr> generate_variants(AstPtr pattern);

    // Configuration
    struct Config {
        bool fuzz_commutative = true;   // Reorder commutative operands
        bool fuzz_add_sub = false;      // Generate add/sub equivalences (DISABLED - slow)
        bool fuzz_associative = false;  // Restructure associative trees (DISABLED - slow)
        int max_variants = 16;          // Limit to prevent explosion (was 1000)
    };

    static void set_config(const Config& cfg);
    static const Config& get_config();

private:
    static Config config_;

    //----------------------------------------------------------------------
    // Core fuzzing functions
    //----------------------------------------------------------------------

    // Main recursive fuzzer
    static std::vector<AstPtr> fuzz_recursive(
        AstPtr node,
        const std::set<mcode_t>& excluded_ops);

    // Fuzz commutative operation (XOR, AND, OR, MUL)
    static std::vector<AstPtr> fuzz_commutative_op(
        AstPtr node,
        const std::set<mcode_t>& excluded_ops);

    // Fuzz add/sub operations (special handling due to interdependence)
    static std::vector<AstPtr> fuzz_add_sub_op(
        AstPtr node,
        const std::set<mcode_t>& excluded_ops);

    // Fuzz unary operation (just recurse on operand)
    static std::vector<AstPtr> fuzz_unary_op(
        AstPtr node,
        const std::set<mcode_t>& excluded_ops);

    //----------------------------------------------------------------------
    // Operand extraction and tree building
    //----------------------------------------------------------------------

    // Operand with sign (for add/sub flattening)
    struct SignedOperand {
        AstPtr operand;
        bool is_negated;  // True if this operand is subtracted

        SignedOperand(AstPtr op, bool neg = false)
            : operand(op), is_negated(neg) {}
    };

    // Extract operands from chained same-opcode operations
    // e.g., add(add(x, y), z) -> [x, y, z]
    static std::vector<AstPtr> get_flat_operands(AstPtr node, mcode_t op);

    // Extract operands from add/sub chain with sign tracking
    // e.g., sub(add(x, y), z) -> [(x, +), (y, +), (z, -)]
    static std::vector<SignedOperand> get_add_sub_operands(AstPtr node);

    // Build all possible binary tree structures from flat operand list
    static std::vector<AstPtr> build_all_binary_trees(
        const std::vector<AstPtr>& operands,
        mcode_t op);

    // Build all add/sub trees from signed operand list
    static std::vector<AstPtr> build_add_sub_trees(
        const std::vector<SignedOperand>& operands);

    //----------------------------------------------------------------------
    // Add/Sub equivalence transformations
    //----------------------------------------------------------------------

    // Generate add/sub variations: x + neg(y) <-> x - y
    static std::vector<AstPtr> get_add_sub_variations(
        mcode_t op, AstPtr left, AstPtr right);

    //----------------------------------------------------------------------
    // Utility
    //----------------------------------------------------------------------

    // Generate all permutations of operands
    static std::vector<std::vector<AstPtr>> permute(
        const std::vector<AstPtr>& operands);

    // Generate all permutations of signed operands
    static std::vector<std::vector<SignedOperand>> permute_signed(
        const std::vector<SignedOperand>& operands);

    // Deduplicate variants by structure
    static std::vector<AstPtr> deduplicate(const std::vector<AstPtr>& variants);
};

} // namespace ast
} // namespace chernobog

```

`src/deobf/analysis/pattern_match.cpp`:

```cpp
#include "pattern_match.h"
#include "expr_simplify.h"
#include "../../common/compat.h"

namespace pattern_match {

//--------------------------------------------------------------------------
// Opaque predicate analysis
//--------------------------------------------------------------------------
opaque_pred_t analyze_predicate(mblock_t *blk, minsn_t *jcc_insn, deobf_ctx_t *ctx) {
    opaque_pred_t result;
    result.type = opaque_pred_t::OPAQUE_UNKNOWN;
    result.cond_insn = jcc_insn;
    result.true_block = -1;
    result.false_block = -1;

    if (!jcc_insn || !deobf::is_jcc(jcc_insn->opcode))
        return result;

    // Get branch targets
    if (jcc_insn->d.t == mop_b) {
        result.true_block = jcc_insn->d.b;
    }

    // Check if the condition can be evaluated statically
    sym_expr_ptr cond = deobf::mop_to_sym(jcc_insn->l, ctx);
    if (cond) {
        cond = deobf::simplify_expr(cond);
        auto val = deobf::eval_const_expr(cond);
        if (val.has_value()) {
            if (*val != 0)
                result.type = opaque_pred_t::OPAQUE_ALWAYS_TRUE;
            else
                result.type = opaque_pred_t::OPAQUE_ALWAYS_FALSE;
        }
    }

    // Check for common Hikari opaque predicate patterns:
    // Pattern 1: (x * (x + 1)) % 2 == 0  (always true for any x)
    // Pattern 2: y < 10 || y >= 10       (always true)
    // Pattern 3: Comparison of two constants

    if (jcc_insn->l.t == mop_d && jcc_insn->l.d) {
        minsn_t *nested = jcc_insn->l.d;

        // Check for setXX instructions with constant operands
        if (nested->opcode >= m_setz && nested->opcode <= m_setle) {
            if (nested->l.t == mop_n && nested->r.t == mop_n) {
                // Both operands are constants - evaluate
                int64_t l = nested->l.nnn->value;
                int64_t r = nested->r.nnn->value;
                bool cond_true = false;

                switch (nested->opcode) {
                    case m_setz:  cond_true = (l == r); break;
                    case m_setnz: cond_true = (l != r); break;
                    case m_setae: cond_true = ((uint64_t)l >= (uint64_t)r); break;
                    case m_setb:  cond_true = ((uint64_t)l < (uint64_t)r); break;
                    case m_seta:  cond_true = ((uint64_t)l > (uint64_t)r); break;
                    case m_setbe: cond_true = ((uint64_t)l <= (uint64_t)r); break;
                    case m_setg:  cond_true = (l > r); break;
                    case m_setge: cond_true = (l >= r); break;
                    case m_setl:  cond_true = (l < r); break;
                    case m_setle: cond_true = (l <= r); break;
                    default: break;
                }

                result.type = cond_true ? opaque_pred_t::OPAQUE_ALWAYS_TRUE
                                       : opaque_pred_t::OPAQUE_ALWAYS_FALSE;
            }
        }
    }

    return result;
}

bool is_always_true(minsn_t *insn) {
    if (!insn)
        return false;

    // Immediate non-zero value
    if (insn->l.t == mop_n && insn->l.nnn->value != 0)
        return true;

    return false;
}

bool is_always_false(minsn_t *insn) {
    if (!insn)
        return false;

    // Immediate zero value
    if (insn->l.t == mop_n && insn->l.nnn->value == 0)
        return true;

    return false;
}

//--------------------------------------------------------------------------
// Control flow flattening detection
//--------------------------------------------------------------------------
// Helper: Check if a value looks like a Hikari state constant
// NOTE: Extended to handle non-magic constant patterns used by some obfuscators
//--------------------------------------------------------------------------
static bool is_hikari_state_const(uint64_t val) {
    // Hikari uses distinctive patterns for state constants
    // Common patterns: 0xAAAAxxxx, 0xBEEFxxxx, 0xCAFExxxx, 0xDEADxxxx, etc.

    // Must be at least 0x10000000 (has meaningful high bits)
    // and not look like an address (typical addresses are larger)
    if (val < 0x10000000 || val > 0xFFFFFFFF)
        return false;

    uint32_t high = (val >> 16) & 0xFFFF;

    // The high part must be non-zero
    if (high == 0)
        return false;

    // Check for known Hikari patterns (classic)
    switch (high) {
        case 0xAAAA:
        case 0xABCD:  // Common Hikari pattern (0xABCD0001, 0xABCD0002, etc.)
        case 0xBBBB:
        case 0xCCCC:
        case 0xDDDD:
        case 0xBEEF:
        case 0xCAFE:
        case 0xDEAD:
        case 0x1111:
        case 0x2222:
        case 0x3333:
        case 0x4444:
        case 0x5555:
        case 0x6666:
        case 0x7777:
        case 0x8888:
        case 0x9999:
        case 0xFEED:
        case 0xFACE:
        case 0xBABE:
        case 0xC0DE:
        case 0xF00D:
            return true;
        default:
            break;
    }

    // Extended detection: accept any 32-bit value with entropy in both halves
    // This catches non-standard obfuscators that use random-looking constants
    uint16_t low = val & 0xFFFF;
    
    // Both halves should have some bits set
    if (low == 0)
        return false;
    
    // Avoid 64-bit addresses
    if (val >= 0x100000000ULL)
        return false;
    
    // Check bit density - state constants typically have 6-26 bits set
    int bit_count = portable_popcount((uint32_t)val);
    if (bit_count >= 6 && bit_count <= 26) {
        return true;
    }

    return false;
}

//--------------------------------------------------------------------------
// Helper: Find comparisons against constants in a block
//--------------------------------------------------------------------------
struct state_cmp_t {
    minsn_t *insn;
    mop_t var;          // Variable being compared
    uint64_t const_val; // Constant it's compared against
    int block_idx;
};

static void find_state_comparisons(mbl_array_t *mba, std::vector<state_cmp_t> &cmps) {
    cmps.clear();

    // Also look for any large constants that could be state values
    std::set<uint64_t> potential_states;

    for (int i = 0; i < mba->qty; i++) {
        mblock_t *blk = mba->get_mblock(i);
        if (!blk)
            continue;

        for (minsn_t *ins = blk->head; ins; ins = ins->next) {
            // Scan all instructions for potential state constants
            if (ins->l.t == mop_n && is_hikari_state_const(ins->l.nnn->value)) {
                potential_states.insert(ins->l.nnn->value);
            }
            if (ins->r.t == mop_n && is_hikari_state_const(ins->r.nnn->value)) {
                potential_states.insert(ins->r.nnn->value);
            }

            // Look for conditional jumps
            if (!deobf::is_jcc(ins->opcode))
                continue;

            // The condition is in ins->l (for jcc, it's the result of a setXX or cmp)
            // We need to trace back to find the actual comparison
            // In microcode, jcc typically follows a setXX instruction

            // Check if comparing against a constant
            // Pattern: jz/jnz after a comparison sub-instruction
            if (ins->l.t == mop_d && ins->l.d) {
                minsn_t *cond = ins->l.d;
                // setXX instructions compare their operands
                if (is_mcode_set(cond->opcode)) {
                    // l and r are the comparison operands
                    uint64_t const_val = 0;
                    mop_t var;
                    bool found = false;

                    if (cond->l.t == mop_n && cond->r.t != mop_n) {
                        const_val = cond->l.nnn->value;
                        var = cond->r;
                        found = true;
                    } else if (cond->r.t == mop_n && cond->l.t != mop_n) {
                        const_val = cond->r.nnn->value;
                        var = cond->l;
                        found = true;
                    }

                    if (found && is_hikari_state_const(const_val)) {
                        state_cmp_t cmp;
                        cmp.insn = ins;
                        cmp.var = var;
                        cmp.const_val = const_val;
                        cmp.block_idx = i;
                        cmps.push_back(cmp);
                    }
                }
            }

            // Also check direct comparison pattern
            // jcc with mop_n operand directly
            if (ins->r.t == mop_n) {
                uint64_t const_val = ins->r.nnn->value;
                if (is_hikari_state_const(const_val)) {
                    state_cmp_t cmp;
                    cmp.insn = ins;
                    cmp.var = ins->l;
                    cmp.const_val = const_val;
                    cmp.block_idx = i;
                    cmps.push_back(cmp);
                }
            }
        }
    }
}

//--------------------------------------------------------------------------
// Helper: Find the most common comparison variable (likely the state var)
//--------------------------------------------------------------------------
static bool find_likely_state_var(const std::vector<state_cmp_t> &cmps, mop_t *out_var) {
    if (cmps.empty())
        return false;

    // Count how many times each variable type/location is compared
    // For simplicity, group by operand type and size
    std::map<std::pair<mopt_t, int>, int> var_counts;
    std::map<std::pair<mopt_t, int>, mop_t> var_examples;

    for (const auto &cmp : cmps) {
        auto key = std::make_pair(cmp.var.t, cmp.var.size);
        var_counts[key]++;
        var_examples[key] = cmp.var;
    }

    // Find the most common
    int max_count = 0;
    mop_t best_var;
    for (const auto &kv : var_counts) {
        if (kv.second > max_count) {
            max_count = kv.second;
            best_var = var_examples[kv.first];
        }
    }

    if (max_count >= 2) {
        *out_var = best_var;
        return true;
    }

    return false;
}

//--------------------------------------------------------------------------
// Helper: Find state variable assignments
//--------------------------------------------------------------------------
static void find_state_assignments(mbl_array_t *mba, const mop_t &state_var,
                                   std::map<uint64_t, int> &state_map) {
    state_map.clear();

    for (int i = 0; i < mba->qty; i++) {
        mblock_t *blk = mba->get_mblock(i);
        if (!blk)
            continue;

        for (minsn_t *ins = blk->head; ins; ins = ins->next) {
            // Look for mov with constant source to state variable location
            if (ins->opcode == m_mov && ins->l.t == mop_n) {
                uint64_t val = ins->l.nnn->value;
                if (is_hikari_state_const(val)) {
                    // Check if destination matches state variable pattern
                    // (same type and similar structure)
                    if (ins->d.t == state_var.t) {
                        state_map[val] = i;
                    }
                }
            }
        }
    }
}

//--------------------------------------------------------------------------
// Alternative detection: find all Hikari-style constants in the function
//--------------------------------------------------------------------------
static int count_state_constants(mbl_array_t *mba, std::set<uint64_t> *out_constants = nullptr) {
    std::set<uint64_t> constants;
    std::set<uint64_t> all_numbers;  // For debugging

    for (int i = 0; i < mba->qty; i++) {
        mblock_t *blk = mba->get_mblock(i);
        if (!blk)
            continue;

        for (minsn_t *ins = blk->head; ins; ins = ins->next) {
            // Check all operands for Hikari constants
            if (ins->l.t == mop_n) {
                uint64_t val = ins->l.nnn->value;
                if (val >= 0x10000000 && val <= 0xFFFFFFFF)
                    all_numbers.insert(val);
                if (is_hikari_state_const(val)) {
                    constants.insert(val);
                }
            }
            if (ins->r.t == mop_n) {
                uint64_t val = ins->r.nnn->value;
                if (val >= 0x10000000 && val <= 0xFFFFFFFF)
                    all_numbers.insert(val);
                if (is_hikari_state_const(val)) {
                    constants.insert(val);
                }
            }
            if (ins->d.t == mop_n) {
                uint64_t val = ins->d.nnn->value;
                if (val >= 0x10000000 && val <= 0xFFFFFFFF)
                    all_numbers.insert(val);
                if (is_hikari_state_const(val)) {
                    constants.insert(val);
                }
            }
        }
    }

    // Debug: log all large constants found
    if (!all_numbers.empty()) {
        deobf::log("[pattern] All large constants in microcode:\n");
        for (uint64_t v : all_numbers) {
            uint32_t high = (v >> 16) & 0xFFFF;
            deobf::log("[pattern]   0x%llx (high=0x%04x) %s\n",
                (unsigned long long)v, high,
                is_hikari_state_const(v) ? "MATCH" : "no-match");
        }
    }

    if (out_constants)
        *out_constants = constants;

    return (int)constants.size();
}

//--------------------------------------------------------------------------
// Jump table-based flattening detection (index-based, not magic constants)
// This pattern uses small integers (0, 1, 2...) as indices into a jump table
//--------------------------------------------------------------------------
struct jmptbl_info_t {
    int block_idx;              // Block containing the ijmp
    ea_t table_addr;            // Address of jump table
    int num_cases;              // Number of cases detected
    mop_t index_var;            // Variable holding the index
};

static bool detect_jump_table_pattern(mbl_array_t *mba, std::vector<jmptbl_info_t> *out_tables) {
    if (!mba)
        return false;

    std::vector<jmptbl_info_t> tables;

    // First, check IDA's switch info for all addresses in the function
    // IDA often detects switches at the assembly level even if microcode doesn't have m_ijmp
    func_t *pfn = get_func(mba->entry_ea);
    if (pfn) {
        ea_t ea = pfn->start_ea;
        while (ea < pfn->end_ea) {
            switch_info_t si;
            if (get_switch_info(&si, ea) > 0 && si.get_jtable_size() >= 20) {
                jmptbl_info_t info;
                info.block_idx = -1;  // Will find block later
                info.table_addr = si.jumps;
                info.num_cases = (int)si.get_jtable_size();
                deobf::log("[pattern] IDA switch at %a: %d cases, table at 0x%llx\n",
                          ea, info.num_cases, (unsigned long long)info.table_addr);
                tables.push_back(info);
            }
            ea = next_head(ea, pfn->end_ea);
            if (ea == BADADDR) break;
        }
    }

    // If we found IDA-detected switches, don't need microcode search
    if (!tables.empty()) {
        if (out_tables)
            *out_tables = tables;
        return true;
    }

    // Fallback: scan microcode for indirect jumps
    deobf::log("[pattern] Scanning microcode for indirect jumps...\n");
    for (int i = 0; i < mba->qty; i++) {
        mblock_t *blk = mba->get_mblock(i);
        if (!blk || !blk->tail)
            continue;

        // Log block terminator opcodes for debugging
        if (i < 5 || blk->tail->opcode == m_ijmp || blk->tail->opcode == m_goto) {
            deobf::log_verbose("[pattern] Block %d tail: opcode=%d (m_ijmp=%d, m_goto=%d)\n",
                      i, blk->tail->opcode, m_ijmp, m_goto);
        }

        // Look for indirect jumps (ijmp)
        if (blk->tail->opcode != m_ijmp)
            continue;

        jmptbl_info_t info;
        info.block_idx = i;
        info.table_addr = BADADDR;
        info.num_cases = 0;

        // The target of ijmp comes from a computation
        // Look backwards for the pattern: load from [table + index*8]
        // In microcode this could be: ldx / add / mul sequence

        // Try to extract jump table info from IDA's switch analysis
        switch_info_t si;
        if (get_switch_info(&si, blk->start) > 0 ||
            get_switch_info(&si, blk->tail->ea) > 0) {
            info.table_addr = si.jumps;
            info.num_cases = (int)si.get_jtable_size();
            deobf::log("[pattern] Found IDA-detected switch at block %d: %zu cases, table at 0x%llx\n",
                      i, (size_t)info.num_cases, (unsigned long long)info.table_addr);
            tables.push_back(info);
            continue;
        }

        // Fallback: manually scan for jump table pattern
        // Look for memory loads that could be jump table accesses
        for (minsn_t *ins = blk->tail->prev; ins; ins = ins->prev) {
            // ldx instruction loads from memory
            if (ins->opcode == m_ldx) {
                // Check if loading from a global variable (jump table base)
                if (ins->r.t == mop_v) {
                    info.table_addr = ins->r.g;
                    // Try to determine number of cases by analyzing table contents
                    ea_t ptr = info.table_addr;
                    info.num_cases = 0;
                    for (int j = 0; j < 512; j++) {  // Reasonable limit
                        ea_t target = 0;
                        if (get_bytes(&target, sizeof(ea_t), ptr) != sizeof(ea_t))
                            break;
                        if (target == 0 || target == BADADDR)
                            break;
                        // Validate it looks like a code address
                        if (is_code(get_flags(target)) || is_func(get_flags(target))) {
                            info.num_cases++;
                            ptr += sizeof(ea_t);
                        } else {
                            break;
                        }
                    }
                    if (info.num_cases > 10) {
                        deobf::log("[pattern] Found manual switch at block %d: %d cases, table at 0x%llx\n",
                                  i, info.num_cases, (unsigned long long)info.table_addr);
                        tables.push_back(info);
                    }
                    break;
                }
            }
        }
    }

    if (out_tables)
        *out_tables = tables;

    return !tables.empty();
}

//--------------------------------------------------------------------------
// Count small state indices used as local variables
// Hikari table-based flattening initializes multiple state variables like:
//   var_14 = 0, var_24 = 1, var_44 = 3, var_54 = 4, etc.
//--------------------------------------------------------------------------
static int count_state_index_assignments(mbl_array_t *mba, int max_index = 300) {
    std::set<uint64_t> indices;

    for (int i = 0; i < mba->qty; i++) {
        mblock_t *blk = mba->get_mblock(i);
        if (!blk)
            continue;

        for (minsn_t *ins = blk->head; ins; ins = ins->next) {
            // Look for mov of small constants to stack variables
            if (ins->opcode == m_mov && ins->l.t == mop_n) {
                uint64_t val = ins->l.nnn->value;
                // Check if it's a small index (0-300 for most flattened functions)
                if (val <= (uint64_t)max_index) {
                    // Check if destination is a stack or local variable
                    if (ins->d.t == mop_S || ins->d.t == mop_l) {
                        indices.insert(val);
                    }
                }
            }
        }
    }

    return (int)indices.size();
}

//--------------------------------------------------------------------------
bool detect_flatten_pattern(mbl_array_t *mba, flatten_info_t *out) {
    if (!mba || mba->qty < 4)
        return false;

    // First, quick check: does this function use many Hikari-style constants?
    std::set<uint64_t> state_constants;
    int const_count = count_state_constants(mba, &state_constants);

    if (const_count >= 3) {
        deobf::log("[pattern] Found %d Hikari-style state constants\n", const_count);
        for (uint64_t c : state_constants) {
            deobf::log("[pattern]   0x%llx\n", (unsigned long long)c);
        }

        // If we have enough state constants, this is likely flattened
        if (out) {
            out->dispatcher_block = 0;  // Will be refined later
            out->loop_end_block = -1;
        }
        return true;
    }

    // Check for jump table-based flattening (index-based, not magic constants)
    // This is a different Hikari variant that uses small indices (0, 1, 2...)
    // into jump tables instead of magic constants
    deobf::log("[pattern] Checking for jump table-based flattening...\n");
    std::vector<jmptbl_info_t> jump_tables;
    if (detect_jump_table_pattern(mba, &jump_tables)) {
        deobf::log("[pattern] Found %zu jump tables\n", jump_tables.size());
        // Check if we have a large jump table (>20 cases is suspicious)
        for (const auto& jt : jump_tables) {
            deobf::log("[pattern] Jump table: block=%d, cases=%d\n", jt.block_idx, jt.num_cases);
            if (jt.num_cases >= 20) {
                // Also check for many small index assignments
                int index_count = count_state_index_assignments(mba, jt.num_cases + 10);
                deobf::log("[pattern] Jump table at block %d has %d cases, found %d index assignments\n",
                          jt.block_idx, jt.num_cases, index_count);

                // If we have many small indices AND a large jump table, likely flattened
                if (index_count >= 5) {
                    deobf::log("[pattern] Detected jump table-based flattening!\n");
                    if (out) {
                        out->dispatcher_block = jt.block_idx;
                        out->loop_end_block = -1;
                        // For index-based flattening, state values are 0, 1, 2...
                        for (int i = 0; i < jt.num_cases; i++) {
                            out->state_to_block[i] = -1;  // Targets resolved via jump table
                        }
                    }
                    return true;
                }
            }
        }
    } else {
        deobf::log("[pattern] No jump tables found\n");
    }

    // Strategy:
    // 1. Find all comparisons against Hikari-style state constants
    // 2. Identify the most commonly compared variable as the state var
    // 3. Find all assignments to the state variable
    // 4. If we have enough comparisons and assignments, it's flattened

    std::vector<state_cmp_t> comparisons;
    find_state_comparisons(mba, comparisons);

    deobf::log("[pattern] Found %zu state comparisons\n", comparisons.size());

    if (comparisons.size() < 3)
        return false;

    // Find the state variable
    mop_t state_var;
    if (!find_likely_state_var(comparisons, &state_var)) {
        return false;
    }

    deobf::log("[pattern] Identified state variable type %d, size %d\n",
              state_var.t, state_var.size);

    // Find state assignments
    std::map<uint64_t, int> state_map;
    find_state_assignments(mba, state_var, state_map);

    deobf::log("[pattern] Found %zu state assignments\n", state_map.size());

    // Also count unique state values from comparisons
    std::set<uint64_t> unique_states;
    for (const auto &cmp : comparisons) {
        unique_states.insert(cmp.const_val);
    }

    deobf::log("[pattern] Found %zu unique state values in comparisons\n", unique_states.size());

    // Need at least a few states to confirm flattening
    if (unique_states.size() < 3 && state_map.size() < 2)
        return false;

    // Find the dispatcher block (block with most comparisons)
    std::map<int, int> block_cmp_count;
    for (const auto &cmp : comparisons) {
        block_cmp_count[cmp.block_idx]++;
    }

    int dispatcher = -1;
    int max_cmps = 0;
    for (const auto &kv : block_cmp_count) {
        if (kv.second > max_cmps) {
            max_cmps = kv.second;
            dispatcher = kv.first;
        }
    }

    // If no single block has many comparisons, the dispatcher might be
    // spread across multiple blocks (cascading pattern)
    if (max_cmps < 3) {
        // Use the first block with comparisons as the entry point
        if (!comparisons.empty()) {
            dispatcher = comparisons[0].block_idx;
        }
    }

    if (out) {
        out->dispatcher_block = dispatcher;
        out->loop_end_block = -1;  // Will need to find this later
        out->state_var = state_var;
        out->state_to_block = state_map;
    }

    return true;
}

//--------------------------------------------------------------------------
// String encryption detection
//--------------------------------------------------------------------------
bool detect_string_encryption(mbl_array_t *mba, ea_t func_ea, std::vector<string_enc_info_t> *out) {
    if (!mba)
        return false;

    bool found = false;

    // Look for XOR loops decrypting global data
    // Hikari pattern: load byte, XOR with key, store to workspace

    for (int i = 0; i < mba->qty; i++) {
        mblock_t *blk = mba->get_mblock(i);
        if (!blk)
            continue;

        // Look for XOR instructions with global variable operands
        for (minsn_t *ins = blk->head; ins; ins = ins->next) {
            if (ins->opcode != m_xor)
                continue;

            // Check if one operand is a global load
            ea_t enc_addr = BADADDR;
            uint64_t xor_key = 0;

            if (ins->l.t == mop_v && ins->r.t == mop_n) {
                enc_addr = ins->l.g;
                xor_key = ins->r.nnn->value;
            } else if (ins->r.t == mop_v && ins->l.t == mop_n) {
                enc_addr = ins->r.g;
                xor_key = ins->l.nnn->value;
            }

            if (enc_addr != BADADDR) {
                // Check if this looks like string data
                flags64_t flags = get_flags(enc_addr);
                if (is_data(flags)) {
                    string_enc_info_t info;
                    info.encrypted_addr = enc_addr;
                    info.decrypt_space_addr = BADADDR;
                    info.key_addr = BADADDR;
                    info.keys.push_back((uint8_t)xor_key);
                    info.element_size = ins->l.size;
                    info.num_elements = 1;

                    if (out)
                        out->push_back(info);
                    found = true;
                }
            }
        }
    }

    // Also check for Hikari-specific global variable names
    // "EncryptedString", "DecryptSpace", "StringEncryptionEncStatus"
    segment_t *seg = get_first_seg();
    while (seg) {
        if (seg->type == SEG_DATA) {
            ea_t ea = seg->start_ea;
            while (ea < seg->end_ea) {
                qstring name;
                if (get_name(&name, ea) > 0) {
                    if (name.find("EncryptedString") != qstring::npos ||
                        name.find("DecryptSpace") != qstring::npos) {
                        found = true;
                    }
                }
                ea = next_head(ea, seg->end_ea);
                if (ea == BADADDR)
                    break;
            }
        }
        seg = get_next_seg(seg->start_ea);
    }

    return found;
}

//--------------------------------------------------------------------------
// Constant encryption detection
//--------------------------------------------------------------------------
bool detect_const_encryption(mblock_t *blk, std::vector<const_enc_info_t> *out) {
    if (!blk)
        return false;

    bool found = false;

    // Look for pattern: load global, XOR with constant
    for (minsn_t *ins = blk->head; ins; ins = ins->next) {
        if (ins->opcode != m_xor)
            continue;

        ea_t gv_addr = BADADDR;
        uint64_t key = 0;

        // Check both operand orderings
        if (ins->l.t == mop_v && ins->r.t == mop_n) {
            gv_addr = ins->l.g;
            key = ins->r.nnn->value;
        } else if (ins->r.t == mop_v && ins->l.t == mop_n) {
            gv_addr = ins->r.g;
            key = ins->l.nnn->value;
        }

        if (gv_addr != BADADDR) {
            // Read the encrypted value from the global
            uint64_t enc_val = 0;
            size_t size = ins->l.size;
            if (size <= 8) {
                get_bytes(&enc_val, size, gv_addr);
                uint64_t decrypted = enc_val ^ key;

                const_enc_info_t info;
                info.const_gv_addr = gv_addr;
                info.xor_key = key;
                info.decrypted_value = decrypted;

                if (out)
                    out->push_back(info);
                found = true;
            }
        }
    }

    return found;
}

//--------------------------------------------------------------------------
// Indirect branch detection
//--------------------------------------------------------------------------
bool detect_indirect_branch(mblock_t *blk, indirect_br_info_t *out) {
    if (!blk || !blk->tail)
        return false;

    // Look for ijmp (indirect jump) instruction
    if (blk->tail->opcode != m_ijmp)
        return false;

    // The jump target comes from some computation
    // Hikari stores targets in a jump table global variable

    // Check for GEP-like pattern loading from array
    mop_t *jump_target = &blk->tail->d;

    // Look backwards for the load instruction that provides the target
    ea_t table_addr = BADADDR;
    for (minsn_t *ins = blk->tail->prev; ins; ins = ins->prev) {
        if (ins->opcode == m_ldx) {
            // Memory load - check if from global
            if (ins->l.t == mop_v) {
                table_addr = ins->l.g;
                break;
            }
        }
    }

    if (table_addr != BADADDR) {
        if (out) {
            out->jump_table_addr = table_addr;
            out->is_encrypted = false;
            out->enc_key = 0;

            // Try to read targets from jump table
            ea_t ptr = table_addr;
            for (int i = 0; i < 64; i++) {  // Limit search
                ea_t target = BADADDR;
                if (get_bytes(&target, sizeof(ea_t), ptr) == sizeof(ea_t)) {
                    if (target == 0 || target == BADADDR)
                        break;
                    // Validate it's a code address
                    if (is_code(get_flags(target))) {
                        out->targets.push_back(target);
                    }
                }
                ptr += sizeof(ea_t);
            }
        }
        return true;
    }

    return false;
}

//--------------------------------------------------------------------------
// Substitution pattern matching
//--------------------------------------------------------------------------
bool match_substitution_pattern(minsn_t *insn, substitution_info_t *out) {
    if (!insn)
        return false;

    // Try to match known Hikari substitution patterns

    // Pattern: a - ~b - 1 = a + b (ADD substitution)
    // x - NOT(y) - 1
    if (insn->opcode == m_sub) {
        if (insn->r.t == mop_n && insn->r.nnn->value == 1) {
            // Check if left is also a subtraction with NOT
            if (insn->l.t == mop_d && insn->l.d->opcode == m_sub) {
                minsn_t *inner = insn->l.d;
                if (inner->r.t == mop_d && inner->r.d->opcode == m_bnot) {
                    // Found: a - ~b - 1
                    if (out) {
                        out->original_op = substitution_info_t::SUBST_ADD;
                        out->complex_insn = insn;
                        out->operand1 = inner->l;
                        out->operand2 = inner->r.d->l;
                    }
                    return true;
                }
            }
        }
    }

    // Pattern: (a | b) + (a & b) = a + b (ADD substitution 2)
    if (insn->opcode == m_add) {
        if (insn->l.t == mop_d && insn->r.t == mop_d) {
            minsn_t *left = insn->l.d;
            minsn_t *right = insn->r.d;
            if (left->opcode == m_or && right->opcode == m_and) {
                // Check if operands match
                // left = a | b, right = a & b
                if (out) {
                    out->original_op = substitution_info_t::SUBST_ADD;
                    out->complex_insn = insn;
                    out->operand1 = left->l;
                    out->operand2 = left->r;
                }
                return true;
            }
        }
    }

    // Pattern: (a ^ b) + 2*(a & b) = a + b (ADD substitution 3)
    if (insn->opcode == m_add) {
        if (insn->l.t == mop_d && insn->r.t == mop_d) {
            minsn_t *left = insn->l.d;
            minsn_t *right = insn->r.d;
            if (left->opcode == m_xor && right->opcode == m_mul) {
                // Check for 2 * (a & b)
                if (right->l.t == mop_n && right->l.nnn->value == 2) {
                    if (out) {
                        out->original_op = substitution_info_t::SUBST_ADD;
                        out->complex_insn = insn;
                        out->operand1 = left->l;
                        out->operand2 = left->r;
                    }
                    return true;
                }
            }
        }
    }

    // Pattern: a + ~b + 1 = a - b (SUB substitution)
    if (insn->opcode == m_add) {
        if (insn->r.t == mop_n && insn->r.nnn->value == 1) {
            if (insn->l.t == mop_d && insn->l.d->opcode == m_add) {
                minsn_t *inner = insn->l.d;
                if (inner->r.t == mop_d && inner->r.d->opcode == m_bnot) {
                    // Found: a + ~b + 1 = a - b
                    if (out) {
                        out->original_op = substitution_info_t::SUBST_SUB;
                        out->complex_insn = insn;
                        out->operand1 = inner->l;
                        out->operand2 = inner->r.d->l;
                    }
                    return true;
                }
            }
        }
    }

    // Pattern: (a ^ ~b) & a = a & b (AND substitution)
    if (insn->opcode == m_and) {
        if (insn->l.t == mop_d && insn->l.d->opcode == m_xor) {
            minsn_t *xor_insn = insn->l.d;
            if (xor_insn->r.t == mop_d && xor_insn->r.d->opcode == m_bnot) {
                // Check if right operand of AND matches left of XOR
                if (out) {
                    out->original_op = substitution_info_t::SUBST_AND;
                    out->complex_insn = insn;
                    out->operand1 = xor_insn->l;
                    out->operand2 = xor_insn->r.d->l;
                }
                return true;
            }
        }
    }

    // Pattern: (a & b) | (a ^ b) = a | b (OR substitution)
    if (insn->opcode == m_or) {
        if (insn->l.t == mop_d && insn->r.t == mop_d) {
            minsn_t *left = insn->l.d;
            minsn_t *right = insn->r.d;
            if (left->opcode == m_and && right->opcode == m_xor) {
                if (out) {
                    out->original_op = substitution_info_t::SUBST_OR;
                    out->complex_insn = insn;
                    out->operand1 = left->l;
                    out->operand2 = left->r;
                }
                return true;
            }
        }
    }

    // Pattern: (~a & b) | (a & ~b) = a ^ b (XOR substitution)
    if (insn->opcode == m_or) {
        if (insn->l.t == mop_d && insn->r.t == mop_d) {
            minsn_t *left = insn->l.d;
            minsn_t *right = insn->r.d;
            if (left->opcode == m_and && right->opcode == m_and) {
                // Check for (~a & b) | (a & ~b) pattern
                if (out) {
                    out->original_op = substitution_info_t::SUBST_XOR;
                    out->complex_insn = insn;
                    // Need deeper analysis to extract operands
                }
                return true;
            }
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// Split block detection
//--------------------------------------------------------------------------
bool detect_split_blocks(mbl_array_t *mba, std::vector<split_block_info_t> *out) {
    if (!mba)
        return false;

    bool found = false;

    // Look for chains of blocks with single unconditional jumps
    std::vector<bool> visited(mba->qty, false);

    for (int i = 0; i < mba->qty; i++) {
        if (visited[i])
            continue;

        mblock_t *blk = mba->get_mblock(i);
        if (!blk)
            continue;

        // Count instructions in block
        int insn_count = 0;
        for (minsn_t *ins = blk->head; ins; ins = ins->next)
            insn_count++;

        // Small block with single successor might be a split
        if (insn_count <= 2 && blk->nsucc() == 1) {
            // Follow the chain
            split_block_info_t chain;
            chain.mergeable_blocks.push_back(i);
            visited[i] = true;

            int curr = blk->succ(0);
            while (curr >= 0 && curr < mba->qty && !visited[curr]) {
                mblock_t *next_blk = mba->get_mblock(curr);
                if (!next_blk)
                    break;

                // Check if this block is also small with single successor
                int next_count = 0;
                for (minsn_t *ins = next_blk->head; ins; ins = ins->next)
                    next_count++;

                if (next_count > 2 || next_blk->nsucc() != 1)
                    break;

                chain.mergeable_blocks.push_back(curr);
                visited[curr] = true;
                curr = next_blk->succ(0);
            }

            // Only report if we found a chain of 3+ blocks
            if (chain.mergeable_blocks.size() >= 3) {
                if (out)
                    out->push_back(chain);
                found = true;
            }
        }
    }

    return found;
}

} // namespace pattern_match

```

`src/deobf/analysis/pattern_match.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Pattern matching for Hikari obfuscation detection
//--------------------------------------------------------------------------
namespace pattern_match {

// Opaque predicate patterns
struct opaque_pred_t {
    enum type_t {
        OPAQUE_ALWAYS_TRUE,
        OPAQUE_ALWAYS_FALSE,
        OPAQUE_UNKNOWN
    };

    type_t type;
    minsn_t *cond_insn;
    int true_block;
    int false_block;
};

// Check if a condition is an opaque predicate
opaque_pred_t analyze_predicate(mblock_t *blk, minsn_t *jcc_insn, deobf_ctx_t *ctx);

// Check if expression is always true/false
bool is_always_true(minsn_t *insn);
bool is_always_false(minsn_t *insn);

// Flattening patterns
struct flatten_info_t {
    int dispatcher_block;       // Block with switch statement
    int loop_entry_block;       // Loop entry
    int loop_end_block;         // Loop end (jumps back to entry)
    mop_t state_var;            // The state variable
    std::map<uint64_t, int> state_to_block;  // State value -> original block
};

bool detect_flatten_pattern(mbl_array_t *mba, flatten_info_t *out);

// String encryption patterns
struct string_enc_info_t {
    ea_t encrypted_addr;        // Address of encrypted data
    ea_t decrypt_space_addr;    // Address of decryption workspace
    ea_t key_addr;              // Address of XOR key (if global)
    std::vector<uint8_t> keys;  // XOR keys per element
    int element_size;           // 1, 2, 4, or 8 bytes
    int num_elements;
};

bool detect_string_encryption(mbl_array_t *mba, ea_t func_ea, std::vector<string_enc_info_t> *out);

// Constant encryption patterns
struct const_enc_info_t {
    ea_t const_gv_addr;         // Global variable holding encrypted constant
    uint64_t xor_key;           // XOR key
    uint64_t decrypted_value;   // Decrypted constant value
};

bool detect_const_encryption(mblock_t *blk, std::vector<const_enc_info_t> *out);

// Indirect branch patterns
struct indirect_br_info_t {
    ea_t jump_table_addr;       // Address of jump table
    std::vector<ea_t> targets;  // Target addresses from table
    bool is_encrypted;          // Jump targets encrypted
    uint64_t enc_key;           // Encryption key if encrypted
};

bool detect_indirect_branch(mblock_t *blk, indirect_br_info_t *out);

// Substitution patterns - maps complex expression to simple operation
struct substitution_info_t {
    enum orig_op_t {
        SUBST_ADD,
        SUBST_SUB,
        SUBST_AND,
        SUBST_OR,
        SUBST_XOR,
        SUBST_MUL
    };

    orig_op_t original_op;
    minsn_t *complex_insn;      // The obfuscated instruction
    mop_t operand1;             // First operand of original operation
    mop_t operand2;             // Second operand of original operation
};

bool match_substitution_pattern(minsn_t *insn, substitution_info_t *out);

// Split block patterns
struct split_block_info_t {
    std::vector<int> mergeable_blocks;  // Blocks that can be merged into one
};

bool detect_split_blocks(mbl_array_t *mba, std::vector<split_block_info_t> *out);

} // namespace pattern_match

```

`src/deobf/analysis/pattern_storage.cpp`:

```cpp
#include "pattern_storage.h"
#include "ast_builder.h"
#include "../rules/pattern_rule.h"
#include "../../common/simd.h"
#include <sstream>
#include <algorithm>
#include <cmath>

namespace chernobog {
namespace ast {

//--------------------------------------------------------------------------
// PatternStructure implementation - computed at registration time
//--------------------------------------------------------------------------
static void count_ast_nodes(const AstBase* node, uint16_t& nodes, uint16_t& leaves, 
                           uint16_t& consts, uint16_t& depth, uint16_t current_depth) {
    if (!node) return;
    
    if (current_depth > depth) depth = current_depth;
    
    if (node->is_leaf()) {
        if (node->is_constant()) {
            consts++;
        } else {
            leaves++;
        }
        return;
    }
    
    nodes++;
    auto n = static_cast<const AstNode*>(node);
    count_ast_nodes(n->left.get(), nodes, leaves, consts, depth, current_depth + 1);
    count_ast_nodes(n->right.get(), nodes, leaves, consts, depth, current_depth + 1);
}

static uint64_t compute_opcode_hash(const AstBase* node) {
    if (!node) return 0;
    
    if (node->is_leaf()) {
        // Use different markers for leaves vs constants
        return node->is_constant() ? 0xC0C0C0C0ULL : 0xEAFEAFULL;
    }
    
    auto n = static_cast<const AstNode*>(node);
    uint64_t h = simd::hash_u64(static_cast<uint64_t>(n->opcode));
    h = simd::hash_combine(h, compute_opcode_hash(n->left.get()));
    h = simd::hash_combine(h, compute_opcode_hash(n->right.get()));
    return h;
}

PatternStructure PatternStructure::from_ast(const AstBase* node) {
    PatternStructure s = {};
    
    if (!node) return s;
    
    s.depth = 0;
    s.node_count = 0;
    s.leaf_count = 0;
    s.const_count = 0;
    
    count_ast_nodes(node, s.node_count, s.leaf_count, s.const_count, s.depth, 1);
    s.opcode_hash = compute_opcode_hash(node);
    
    return s;
}

//--------------------------------------------------------------------------
// SignatureUtils implementation (kept for compatibility)
//--------------------------------------------------------------------------
std::string SignatureUtils::join_signature(const std::vector<std::string>& sig) {
    std::ostringstream ss;
    for (size_t i = 0; i < sig.size(); i++) {
        if (i > 0) ss << ",";
        ss << sig[i];
    }
    return ss.str();
}

std::vector<std::string> SignatureUtils::split_signature(const std::string& key) {
    std::vector<std::string> result;
    std::istringstream ss(key);
    std::string token;
    while (std::getline(ss, token, ',')) {
        result.push_back(token);
    }
    return result;
}

std::vector<std::vector<std::string>>
SignatureUtils::generate_compatible_signatures(const std::vector<std::string>& ref_sig) {
    std::vector<std::vector<std::string>> result;

    // Start with the original signature
    result.push_back(ref_sig);

    // Generate variants by replacing non-wildcards with "L"
    // This allows matching variable patterns against actual values
    for (size_t i = 0; i < ref_sig.size(); i++) {
        const std::string& elem = ref_sig[i];

        // Only replace elements that are not already wildcards
        if (elem != "N" && elem != "L") {
            // Create variants for all existing results
            size_t current_size = result.size();
            for (size_t j = 0; j < current_size; j++) {
                std::vector<std::string> variant = result[j];
                variant[i] = "L";
                result.push_back(variant);
            }
        }
    }

    return result;
}

bool SignatureUtils::compatible(const std::vector<std::string>& inst_sig,
                                const std::vector<std::string>& pat_sig) {
    if (inst_sig.size() != pat_sig.size()) {
        return false;
    }

    for (size_t i = 0; i < inst_sig.size(); i++) {
        const std::string& inst = inst_sig[i];
        const std::string& pat = pat_sig[i];

        // Wildcards match anything
        if (pat == "L" || pat == "N") {
            continue;
        }

        // "C" matches only constants (also "C" in inst_sig)
        if (pat == "C") {
            if (inst != "C") {
                return false;
            }
            continue;
        }

        // Specific opcode must match exactly
        if (inst != pat) {
            return false;
        }
    }

    return true;
}

int SignatureUtils::count_specific_elements(const std::vector<std::string>& sig) {
    int count = 0;
    for (const auto& s : sig) {
        if (s != "N" && s != "L") {
            count++;
        }
    }
    return count;
}

//--------------------------------------------------------------------------
// PatternStorage implementation - OPTIMIZED
// Uses unordered_map for O(1) lookup, returns const ref to avoid copy
//--------------------------------------------------------------------------

// Static empty vector for when no patterns match
const std::vector<RulePatternInfo> PatternStorage::empty_patterns_;

PatternStorage::PatternStorage(int depth)
    : depth_(depth)
{
    // Pre-allocate buckets for common opcodes
    patterns_by_opcode_.reserve(32);
}

void PatternStorage::add_pattern_for_rule(AstPtr pattern, PatternMatchingRule* rule) {
    if (SIMD_UNLIKELY(!pattern)) {
        return;
    }

    // Get root opcode (-1 for leaf patterns)
    int opcode = -1;
    if (pattern->is_node()) {
        auto node = std::static_pointer_cast<AstNode>(pattern);
        opcode = static_cast<int>(node->opcode);
    }

    // Simply add to the vector for this opcode - O(1) amortized
    patterns_by_opcode_[opcode].emplace_back(rule, pattern);
    total_patterns_++;
}

const std::vector<RulePatternInfo>& PatternStorage::get_matching_rules(AstPtr candidate) {
    if (SIMD_UNLIKELY(!candidate)) {
        return empty_patterns_;
    }

    // Get candidate's root opcode
    int opcode = -1;
    if (candidate->is_node()) {
        auto node = std::static_pointer_cast<AstNode>(candidate);
        opcode = static_cast<int>(node->opcode);
    }

    // O(1) lookup, return const ref to avoid copy
    auto it = patterns_by_opcode_.find(opcode);
    if (SIMD_LIKELY(it != patterns_by_opcode_.end())) {
        return it->second;
    }

    return empty_patterns_;
}

void PatternStorage::dump(int indent) const {
    std::string prefix(indent * 2, ' ');

    msg("%sPatternStorage (flat):\n", prefix.c_str());
    msg("%s  Total patterns: %zu\n", prefix.c_str(), total_patterns_);

    for (const auto& kv : patterns_by_opcode_) {
        msg("%s  Opcode %d: %zu patterns\n", prefix.c_str(), kv.first, kv.second.size());
    }
}

//--------------------------------------------------------------------------
// PatternMatcher implementation
//--------------------------------------------------------------------------
void PatternMatcher::register_rule(PatternMatchingRule* rule) {
    if (!rule) {
        return;
    }

    // Get all patterns from the rule (including fuzzed variants)
    // This will be implemented after we create the rule base class
    // For now, we'll add a placeholder

    rule_count_++;
}

bool PatternMatcher::try_match_pattern(AstPtr pattern, AstPtr candidate,
                                       std::map<std::string, mop_t>& bindings) {
    if (!pattern || !candidate) {
        return false;
    }

    // Both must be same type (node vs leaf)
    if (pattern->is_node() != candidate->is_node()) {
        return false;
    }

    if (pattern->is_leaf()) {
        auto pat_leaf = std::static_pointer_cast<AstLeaf>(pattern);

        // Constants must match value
        if (pattern->is_constant()) {
            if (!candidate->is_constant()) {
                return false;
            }
            auto pat_const = std::static_pointer_cast<AstConstant>(pattern);
            auto cand_const = std::static_pointer_cast<AstConstant>(candidate);

            // Named constants match by name (will be validated later)
            if (!pat_const->const_name.empty()) {
                bindings[pat_const->const_name] = candidate->mop;
                return true;
            }

            // Value constants must match exactly
            return pat_const->value == cand_const->value;
        }

        // Variable leaf - record binding
        bindings[pat_leaf->name] = candidate->mop;
        return true;
    }

    // Both are nodes
    auto pat_node = std::static_pointer_cast<AstNode>(pattern);
    auto cand_node = std::static_pointer_cast<AstNode>(candidate);

    // Opcode must match
    if (pat_node->opcode != cand_node->opcode) {
        return false;
    }

    // Recurse on children
    if (pat_node->left) {
        if (!cand_node->left) {
            return false;
        }
        if (!try_match_pattern(pat_node->left, cand_node->left, bindings)) {
            return false;
        }
    }

    if (pat_node->right) {
        if (!cand_node->right) {
            return false;
        }
        if (!try_match_pattern(pat_node->right, cand_node->right, bindings)) {
            return false;
        }
    } else if (cand_node->right) {
        // Pattern has no right but candidate does
        return false;
    }

    return true;
}

PatternMatcher::MatchResult PatternMatcher::find_match(const minsn_t* ins) {
    if (SIMD_UNLIKELY(!ins)) {
        return MatchResult();
    }

    // Convert instruction to AST
    AstPtr candidate = minsn_to_ast(ins);
    if (SIMD_UNLIKELY(!candidate)) {
        return MatchResult();
    }

    // Get matching rules from storage - const ref, no copy
    const auto& matches = storage_.get_matching_rules(candidate);

    // OPTIMIZED: Use non-mutating match to avoid clone per attempt
    MatchBindings match_bindings;

    // Try each pattern until one matches
    for (const auto& rp : matches) {
        // Use non-mutating match function - no clone needed
        if (match_pattern(rp.pattern.get(), candidate.get(), match_bindings)) {
            // Build bindings map from captured operands
            std::map<std::string, mop_t> bindings;
            for (size_t i = 0; i < match_bindings.count; i++) {
                bindings[match_bindings.bindings[i].name] = match_bindings.bindings[i].mop;
            }
            
            // Check extra validation if rule has one
            if (rp.rule) {
                return MatchResult(rp.rule, rp.pattern, bindings);
            }
        }
    }

    return MatchResult();
}

std::vector<PatternMatcher::MatchResult> PatternMatcher::find_all_matches(
    const minsn_t* ins) {

    std::vector<MatchResult> results;

    if (SIMD_UNLIKELY(!ins)) {
        return results;
    }

    // Convert instruction to AST
    AstPtr candidate = minsn_to_ast(ins);
    if (SIMD_UNLIKELY(!candidate)) {
        return results;
    }

    // Get matching rules from storage - const ref, no copy
    const auto& matches = storage_.get_matching_rules(candidate);
    
    // Reserve capacity based on expected matches
    results.reserve(4);

    // OPTIMIZED: Use non-mutating match to avoid clone per attempt
    MatchBindings match_bindings;

    // Try each pattern
    for (const auto& rp : matches) {
        // Use non-mutating match function - no clone needed
        if (match_pattern(rp.pattern.get(), candidate.get(), match_bindings)) {
            // Build bindings map from captured operands
            std::map<std::string, mop_t> bindings;
            for (size_t i = 0; i < match_bindings.count; i++) {
                bindings[match_bindings.bindings[i].name] = match_bindings.bindings[i].mop;
            }
            results.emplace_back(rp.rule, rp.pattern, bindings);
        }
    }

    return results;
}

} // namespace ast
} // namespace chernobog

```

`src/deobf/analysis/pattern_storage.h`:

```h
#pragma once
#include "ast.h"
#include "../../common/simd.h"
#include <memory>
#include <vector>
#include <unordered_map>
#include <string>

//--------------------------------------------------------------------------
// Pattern Storage for Efficient Pattern Matching - OPTIMIZED
//
// Uses simple flat storage indexed by root opcode for fast initialization.
// Patterns are grouped by their root operation for quick lookup during
// matching.
//
// OPTIMIZATIONS:
//   - unordered_map for O(1) opcode lookup
//   - SmallVector for pattern lists to reduce allocations
//   - Non-mutating match function eliminates clone per attempt
//
// Ported from d810-ng's handler.py PatternStorage class (simplified)
//--------------------------------------------------------------------------

namespace chernobog {

// Forward declaration from rules namespace
namespace rules {
class PatternMatchingRule;
}

namespace ast {

// Use the rules namespace PatternMatchingRule
using PatternMatchingRule = rules::PatternMatchingRule;

//--------------------------------------------------------------------------
// Pattern structural signature for fast rejection
// Pre-computed at registration time, compared with SIMD before full match
//--------------------------------------------------------------------------
struct alignas(16) PatternStructure {
    uint64_t opcode_hash;      // Hash of opcode tree (depth-first)
    uint16_t depth;            // Tree depth
    uint16_t node_count;       // Number of operation nodes
    uint16_t leaf_count;       // Number of leaf nodes (variables)
    uint16_t const_count;      // Number of constant nodes
    
    static PatternStructure from_ast(const AstBase* node);
    
    // Fast SIMD equality check
    SIMD_FORCE_INLINE bool operator==(const PatternStructure& other) const {
        // Compare as two 64-bit values
        return opcode_hash == other.opcode_hash && 
               *reinterpret_cast<const uint64_t*>(&depth) == 
               *reinterpret_cast<const uint64_t*>(&other.depth);
    }
    
    // Check if candidate could match pattern (pattern may have wildcards)
    SIMD_FORCE_INLINE bool compatible_with(const PatternStructure& candidate) const {
        // Structural counts must match exactly
        if ( depth != candidate.depth ) return false;
        if ( node_count != candidate.node_count ) return false;
        // leaf_count can differ (pattern has variables, candidate has actual values)
        return true;
    }
};

//--------------------------------------------------------------------------
// Pattern-rule association with pre-computed signature
//--------------------------------------------------------------------------
struct RulePatternInfo {
    PatternMatchingRule* rule;
    AstPtr pattern;
    PatternStructure structure;  // Pre-computed for O(1) rejection

    RulePatternInfo(PatternMatchingRule* r, AstPtr p)
        : rule(r), pattern(p), structure(PatternStructure::from_ast(p.get())) {}
};

//--------------------------------------------------------------------------
// Signature utilities (kept for compatibility)
//--------------------------------------------------------------------------
class SignatureUtils {
public:
    // Join signature vector into comma-separated string key
    static std::string join_signature(const std::vector<std::string>& sig);

    // Split signature string back to vector
    static std::vector<std::string> split_signature(const std::string& key);

    // Generate all compatible signatures by replacing non-wildcards with "L"
    // This allows matching patterns with variables against actual constants
    static std::vector<std::vector<std::string>>
    generate_compatible_signatures(const std::vector<std::string>& ref_sig);

    // Check if two signatures are compatible
    // Pattern sig can have "L" (any leaf) or "C" (constant only)
    // Instance sig has actual opcodes
    static bool compatible(const std::vector<std::string>& inst_sig,
                          const std::vector<std::string>& pat_sig);

    // Count non-wildcard elements (not "N" or "L")
    static int count_specific_elements(const std::vector<std::string>& sig);
};

//--------------------------------------------------------------------------
// Simple Flat Pattern Storage - OPTIMIZED
// Uses unordered_map for O(1) opcode lookup
//--------------------------------------------------------------------------
class PatternStorage {
public:
    explicit PatternStorage(int depth = 1);

    // Add a pattern for a rule - O(1) operation
    void add_pattern_for_rule(AstPtr pattern, PatternMatchingRule* rule);

    // Find all rules whose patterns match the candidate AST
    // Returns const reference to avoid copy
    const std::vector<RulePatternInfo>& get_matching_rules(AstPtr candidate);

    // Get total number of patterns stored
    size_t pattern_count() const { return total_patterns_; }

    // Debug: print storage structure
    void dump(int indent = 0) const;

private:
    int depth_;  // Unused in simplified version, kept for API compatibility

    // OPTIMIZED: unordered_map for O(1) lookup
    // Patterns indexed by root opcode (-1 for leaf patterns)
    std::unordered_map<int, std::vector<RulePatternInfo>> patterns_by_opcode_;

    // Empty vector for returning when no patterns match
    static const std::vector<RulePatternInfo> empty_patterns_;

    // Total pattern count
    size_t total_patterns_ = 0;
};

//--------------------------------------------------------------------------
// Pattern Matcher - High-level interface for rule matching
//--------------------------------------------------------------------------
class PatternMatcher {
public:
    PatternMatcher() = default;

    // Register a rule with its patterns (including fuzzed variants)
    void register_rule(PatternMatchingRule* rule);

    // Match result
    struct MatchResult {
        PatternMatchingRule* rule;
        AstPtr matched_pattern;
        std::map<std::string, mop_t> bindings;  // Variable name -> operand

        MatchResult() : rule(nullptr) {}
        MatchResult(PatternMatchingRule* r, AstPtr p,
                   const std::map<std::string, mop_t>& b)
            : rule(r), matched_pattern(p), bindings(b) {}

        bool matched() const { return rule != nullptr; }
    };

    // Find first matching rule for an instruction
    MatchResult find_match(const minsn_t* ins);

    // Find all matching rules
    std::vector<MatchResult> find_all_matches(const minsn_t* ins);

    // Statistics
    size_t rule_count() const { return rule_count_; }
    size_t pattern_count() const { return storage_.pattern_count(); }

private:
    PatternStorage storage_;
    size_t rule_count_ = 0;

    // Try to match a single pattern against candidate AST
    bool try_match_pattern(AstPtr pattern, AstPtr candidate,
                          std::map<std::string, mop_t>& bindings);
};

} // namespace ast
} // namespace chernobog

```

`src/deobf/analysis/stack_tracker.cpp`:

```cpp
#include "stack_tracker.h"

// Static members
std::map<sval_t, stack_tracker_t::stack_slot_t> stack_tracker_t::s_slots;
mbl_array_t *stack_tracker_t::s_mba = nullptr;

//--------------------------------------------------------------------------
// Initialize for a function
//--------------------------------------------------------------------------
void stack_tracker_t::init(mbl_array_t *mba) {
    clear();
    s_mba = mba;
}

void stack_tracker_t::clear() {
    s_slots.clear();
    s_mba = nullptr;
}

//--------------------------------------------------------------------------
// Track writes
//--------------------------------------------------------------------------
void stack_tracker_t::track_write(sval_t offset, uint64_t value, int size) {
    stack_slot_t slot;
    slot.has_value = true;
    slot.is_address = false;
    slot.is_string = false;
    slot.value = value;
    slot.size = size;
    slot.write_addr = BADADDR;
    s_slots[offset] = slot;
}

void stack_tracker_t::track_write(sval_t offset, ea_t addr) {
    stack_slot_t slot;
    slot.has_value = true;
    slot.is_address = true;
    slot.is_string = false;
    slot.address = addr;
    slot.value = addr;
    slot.size = sizeof(ea_t);
    slot.write_addr = BADADDR;
    s_slots[offset] = slot;
}

void stack_tracker_t::track_write_string(sval_t offset, const char *str) {
    stack_slot_t slot;
    slot.has_value = true;
    slot.is_address = false;
    slot.is_string = true;
    slot.string_val = str;
    slot.size = sizeof(ea_t);  // Pointer size
    slot.write_addr = BADADDR;
    s_slots[offset] = slot;
}

//--------------------------------------------------------------------------
// Read from stack
//--------------------------------------------------------------------------
std::optional<uint64_t> stack_tracker_t::read_value(sval_t offset, int size) {
    auto p = s_slots.find(offset);
    if ( p != s_slots.end() && p->second.has_value ) {
        return p->second.value;
    }
    return std::nullopt;
}

std::optional<ea_t> stack_tracker_t::read_address(sval_t offset) {
    auto p = s_slots.find(offset);
    if ( p != s_slots.end() && p->second.has_value ) {
        if ( p->second.is_address ) {
            return p->second.address;
        }
        return (ea_t)p->second.value;
    }
    return std::nullopt;
}

std::optional<std::string> stack_tracker_t::read_string(sval_t offset) {
    auto p = s_slots.find(offset);
    if ( p != s_slots.end() && p->second.is_string ) {
        return p->second.string_val;
    }
    return std::nullopt;
}

bool stack_tracker_t::is_known(sval_t offset) {
    auto p = s_slots.find(offset);
    return p != s_slots.end() && p->second.has_value;
}

//--------------------------------------------------------------------------
// Resolve indirect call through stack
//--------------------------------------------------------------------------
ea_t stack_tracker_t::resolve_stack_call(minsn_t *call_insn, mbl_array_t *mba) {
    if ( !call_insn )
        return BADADDR;

    // Check if the call target is through a stack slot
    // Pattern: icall/call where target is loaded from stack

    // For icall, the target is in l operand
    if ( call_insn->opcode == m_icall ) {
        // Check if target comes from stack
        if (call_insn->l.t == mop_S) {
            sval_t offset = call_insn->l.s ? call_insn->l.s->off : 0;
            auto addr = read_address(offset);
            if (addr.has_value()) {
                return *addr;
            }
        }

        // Target might be in a register loaded from stack
        if (call_insn->l.t == mop_r) {
            // Need to trace back the register
            // This is complex - would need dataflow analysis
        }
    }

    // For call with indirect target
    if (call_insn->opcode == m_call) {
        if (call_insn->l.t == mop_d && call_insn->l.d) {
            // Nested instruction - might be load from stack
            minsn_t *inner = call_insn->l.d;
            if (inner->opcode == m_ldx || inner->opcode == m_mov) {
                sval_t offset;
                if (is_stack_ref(inner->l, &offset)) {
                    auto addr = read_address(offset);
                    if (addr.has_value()) {
                        return *addr;
                    }
                }
            }
        }
    }

    return BADADDR;
}

//--------------------------------------------------------------------------
// Analyze a block
//--------------------------------------------------------------------------
void stack_tracker_t::analyze_block(mblock_t *blk) {
    if (!blk)
        return;

    for (minsn_t *ins = blk->head; ins; ins = ins->next) {
        // Look for stores to stack
        if (ins->opcode == m_mov || ins->opcode == m_stx) {
            sval_t offset;
            if (is_stack_ref(ins->d, &offset)) {
                // Destination is stack slot

                // Get the source value
                if (ins->l.t == mop_n) {
                    // Immediate value
                    track_write(offset, ins->l.nnn->value, ins->l.size);
                }
                else if (ins->l.t == mop_v) {
                    // Global address
                    track_write(offset, ins->l.g);

                    // Check if it's a string
                    qstring str;
                    size_t len = get_max_strlit_length(ins->l.g, STRTYPE_C);
                    if (len > 0 && len < 256) {
                        str.resize(len);
                        if (get_strlit_contents(&str, ins->l.g, len, STRTYPE_C) > 0) {
                            track_write_string(offset, str.c_str());
                        }
                    }

                    // Check if it's a function
                    func_t *fn = get_func(ins->l.g);
                    if (fn) {
                        track_write(offset, ins->l.g);
                    }
                }
                else if (ins->l.t == mop_a && ins->l.a) {
                    // Address expression
                    if (ins->l.a->t == mop_v) {
                        track_write(offset, ins->l.a->g);
                    }
                }
            }
        }
    }
}

//--------------------------------------------------------------------------
// Analyze entire function
//--------------------------------------------------------------------------
void stack_tracker_t::analyze_function(mbl_array_t *mba) {
    if (!mba)
        return;

    init(mba);

    // Analyze in execution order (simplified - just linear)
    for (int i = 0; i < mba->qty; i++) {
        mblock_t *blk = mba->get_mblock(i);
        analyze_block(blk);
    }
}

//--------------------------------------------------------------------------
// Get slot info for annotation
//--------------------------------------------------------------------------
std::optional<stack_tracker_t::slot_info_t> stack_tracker_t::get_slot_info(sval_t offset) {
    auto it = s_slots.find(offset);
    if (it == s_slots.end() || !it->second.has_value) {
        return std::nullopt;
    }

    slot_info_t info;
    info.offset = offset;

    if (it->second.is_string) {
        info.type = slot_info_t::STRING;
        info.string_val = it->second.string_val;
    } else if (it->second.is_address) {
        info.type = slot_info_t::ADDRESS;
        info.address = it->second.address;
    } else {
        info.type = slot_info_t::VALUE;
        info.value = it->second.value;
    }

    return info;
}

//--------------------------------------------------------------------------
// Extract value from mop
//--------------------------------------------------------------------------
std::optional<uint64_t> stack_tracker_t::get_mop_value(const mop_t &op) {
    if (op.t == mop_n) {
        return op.nnn->value;
    }
    if (op.t == mop_v) {
        return op.g;
    }
    return std::nullopt;
}

//--------------------------------------------------------------------------
// Check if mop is a stack reference
//--------------------------------------------------------------------------
bool stack_tracker_t::is_stack_ref(const mop_t &op, sval_t *out_offset) {
    if (op.t == mop_S) {
        if (out_offset && op.s) {
            *out_offset = op.s->off;
        }
        return true;
    }
    return false;
}

//--------------------------------------------------------------------------
// Trace register value back through block
//--------------------------------------------------------------------------
std::optional<uint64_t> stack_tracker_t::trace_register_value(mblock_t *blk, int reg, minsn_t *before) {
    if (!blk)
        return std::nullopt;

    // Search backwards from 'before' for a write to the register
    for (minsn_t *ins = before ? before->prev : blk->tail; ins; ins = ins->prev) {
        if (ins->opcode == m_mov && ins->d.t == mop_r && ins->d.r == reg) {
            // Found a write to the register
            return get_mop_value(ins->l);
        }
        if (ins->opcode == m_ldx && ins->d.t == mop_r && ins->d.r == reg) {
            // Load from memory to register
            // Check if loading from stack
            sval_t offset;
            if (is_stack_ref(ins->l, &offset)) {
                return read_value(offset, ins->d.size);
            }
        }
    }

    return std::nullopt;
}

//==========================================================================
// Frameless Continuation Analyzer Implementation
//==========================================================================

// Static members
std::map<ea_t, ea_t> frameless_continuation_t::s_resolution_cache;
std::map<ea_t, caller_context_t> frameless_continuation_t::s_context_cache;

void frameless_continuation_t::clear_caches() {
    s_resolution_cache.clear();
    s_context_cache.clear();
}

//--------------------------------------------------------------------------
// Check if a function is a frameless continuation
// Frameless continuations:
//   1. Don't set up their own stack frame (no push rbp; mov rbp, rsp)
//   2. Access deep RBP offsets (beyond what they could have allocated)
//   3. Usually very short (< 50 bytes)
//   4. End with an indirect jump
//--------------------------------------------------------------------------
bool frameless_continuation_t::is_frameless_continuation(ea_t func_ea) {
    if (func_ea == BADADDR) {
        deobf::log_verbose("[frameless] is_frameless_continuation: BADADDR\n");
        return false;
    }
    
    func_t *func = get_func(func_ea);
    if (!func) {
        deobf::log_verbose("[frameless] is_frameless_continuation(0x%llx): no func_t\n",
                          (unsigned long long)func_ea);
        return false;
    }
    
    deobf::log("[frameless] Checking function at 0x%llx, size=%lld\n",
              (unsigned long long)func_ea, (long long)func->size());
    
    // Check function size - frameless continuations are typically small
    if (func->size() > 200) {
        deobf::log_verbose("[frameless]   -> too large (%lld bytes)\n", (long long)func->size());
        return false;
    }
    
    // Analyze prologue
    bool has_prologue = analyze_prologue(func_ea);
    deobf::log("[frameless]   -> has_prologue=%d, is_frameless=%d\n", has_prologue, !has_prologue);
    
    if (!has_prologue)
        return true;  // No proper prologue = frameless
    
    return false;
}

//--------------------------------------------------------------------------
// Analyze function prologue to detect frame setup
// Returns true if function has proper prologue, false if frameless
//--------------------------------------------------------------------------
bool frameless_continuation_t::analyze_prologue(ea_t func_ea) {
    if (func_ea == BADADDR)
        return false;
    
    // Read first few instructions
    insn_t insn;
    ea_t ea = func_ea;
    int insn_count = 0;
    int max_prologue_insns = 5;
    
    bool saw_push_rbp = false;
    bool saw_mov_rbp_rsp = false;
    
    // x86-64 prologue: push rbp; mov rbp, rsp
    // ARM64 prologue: stp x29, x30, [sp, #-N]!; mov x29, sp
    
    while (insn_count < max_prologue_insns) {
        if (decode_insn(&insn, ea) == 0)
            break;
        
        // x86-64: Check for push rbp (opcode 0x55)
        uint8_t first_byte = get_byte(ea);
        if (first_byte == 0x55) {
            saw_push_rbp = true;
        }
        
        // x86-64: Check for mov rbp, rsp (various encodings)
        // Common: 48 89 E5 (mov rbp, rsp in 64-bit mode)
        if (first_byte == 0x48) {
            uint8_t second = get_byte(ea + 1);
            uint8_t third = get_byte(ea + 2);
            if (second == 0x89 && third == 0xE5) {
                saw_mov_rbp_rsp = true;
            }
            if (second == 0x8B && third == 0xEC) {
                saw_mov_rbp_rsp = true;
            }
        }
        
        // ARM64: Check for stp x29, x30, [sp, #-N]!
        // This is complex - for now, assume ARM64 functions with frame have this
        
        ea = get_item_end(ea);
        insn_count++;
    }
    
    // For x86-64, a proper frame requires both push rbp and mov rbp, rsp
    // Note: some functions don't use frame pointers (leaf functions with -fomit-frame-pointer)
    // but obfuscated trampolines specifically use the CALLER's frame
    return saw_push_rbp && saw_mov_rbp_rsp;
}

//--------------------------------------------------------------------------
// Build caller context from a function before it jumps to continuation
// Captures stack values, register values, and global values
//--------------------------------------------------------------------------
caller_context_t frameless_continuation_t::build_caller_context(mbl_array_t *mba, mblock_t *jump_block) {
    caller_context_t ctx;
    
    if (!mba || !jump_block)
        return ctx;
    
    ctx.caller_func = mba->entry_ea;
    
    // Analyze all blocks leading up to and including jump_block
    // to capture the full stack and register state
    
    // Track register values as we scan
    std::map<mreg_t, uint64_t> reg_values;
    
    // Scan all blocks in order
    for (int i = 0; i <= jump_block->serial && i < mba->qty; i++) {
        mblock_t *blk = mba->get_mblock(i);
        if (!blk)
            continue;
        
        for (minsn_t *ins = blk->head; ins; ins = ins->next) {
            // Track mov of immediate to register
            if (ins->opcode == m_mov && ins->d.t == mop_r && ins->l.t == mop_n) {
                reg_values[ins->d.r] = ins->l.nnn->value;
            }
            
            // Track mov of global address to register
            if (ins->opcode == m_mov && ins->d.t == mop_r && ins->l.t == mop_v) {
                reg_values[ins->d.r] = ins->l.g;
            }
            
            // Track stores to stack
            if (ins->opcode == m_mov || ins->opcode == m_stx) {
                sval_t offset = 0;
                bool is_stack_write = false;
                
                if (ins->d.t == mop_S && ins->d.s) {
                    offset = ins->d.s->off;
                    is_stack_write = true;
                }
                
                if (is_stack_write) {
                    // Get source value
                    uint64_t value = 0;
                    bool has_value = false;
                    
                    if (ins->l.t == mop_n) {
                        value = ins->l.nnn->value;
                        has_value = true;
                    } else if (ins->l.t == mop_v) {
                        value = ins->l.g;
                        has_value = true;
                    } else if (ins->l.t == mop_r && reg_values.count(ins->l.r)) {
                        value = reg_values[ins->l.r];
                        has_value = true;
                    } else if (ins->l.t == mop_a && ins->l.a && ins->l.a->t == mop_v) {
                        // Address of global
                        value = ins->l.a->g;
                        has_value = true;
                    }
                    
                    if (has_value) {
                        ctx.stack_values[offset] = value;
                        deobf::log_verbose("[frameless] Tracking stack[%lld] = 0x%llx\n",
                                          (long long)offset, (unsigned long long)value);
                    }
                }
            }
            
            // Track LEA to register (address computation)
            if (ins->opcode == m_mov && ins->d.t == mop_r) {
                if (ins->l.t == mop_a && ins->l.a) {
                    if (ins->l.a->t == mop_v) {
                        reg_values[ins->d.r] = ins->l.a->g;
                    }
                }
            }
        }
    }
    
    // Copy final register values to context
    for (const auto &kv : reg_values) {
        ctx.register_values[kv.first] = kv.second;
    }
    
    deobf::log("[frameless] Built caller context: %zu stack values, %zu register values\n",
              ctx.stack_values.size(), ctx.register_values.size());
    
    return ctx;
}

//--------------------------------------------------------------------------
// Read a global variable value
//--------------------------------------------------------------------------
std::optional<uint64_t> frameless_continuation_t::read_global(ea_t addr, int size) {
    if (addr == BADADDR)
        return std::nullopt;
    
    uint64_t value = 0;
    if (get_bytes(&value, size, addr) != size)
        return std::nullopt;
    
    // Sign extend if needed for 32-bit values
    if (size == 4) {
        int32_t signed_val = (int32_t)value;
        value = (uint64_t)(int64_t)signed_val;
    }
    
    return value;
}

//--------------------------------------------------------------------------
// Read a value from RBP-relative offset using caller context
//--------------------------------------------------------------------------
std::optional<uint64_t> frameless_continuation_t::read_rbp_relative(sval_t offset, const caller_context_t &ctx) {
    // First check if we have this offset in the context
    auto val = ctx.get_stack_value(offset);
    if (val.has_value())
        return val;
    
    // Try nearby offsets (sometimes there's alignment differences)
    for (sval_t delta = -8; delta <= 8; delta += 8) {
        if (delta == 0) continue;
        val = ctx.get_stack_value(offset + delta);
        if (val.has_value()) {
            deobf::log_verbose("[frameless] Found stack value at offset %lld (wanted %lld)\n",
                              (long long)(offset + delta), (long long)offset);
            return val;
        }
    }
    
    return std::nullopt;
}

//--------------------------------------------------------------------------
// Resolve indirect jump in continuation using caller's context
// This performs simplified symbolic execution of the continuation code
//--------------------------------------------------------------------------
ea_t frameless_continuation_t::resolve_continuation_jump(ea_t continuation_ea, const caller_context_t &ctx) {
    if (continuation_ea == BADADDR)
        return BADADDR;
    
    // Check cache first
    auto it = s_resolution_cache.find(continuation_ea);
    if (it != s_resolution_cache.end())
        return it->second;
    
    deobf::log("[frameless] Resolving continuation at 0x%llx\n", (unsigned long long)continuation_ea);
    
    // Perform symbolic execution with caller's context
    ea_t result = symbolic_execute(continuation_ea, ctx, 50);
    
    // Cache the result
    s_resolution_cache[continuation_ea] = result;
    
    return result;
}

//--------------------------------------------------------------------------
// Simplified symbolic execution of continuation code
// Tracks register values and resolves indirect jump target
//--------------------------------------------------------------------------
ea_t frameless_continuation_t::symbolic_execute(ea_t start_ea, const caller_context_t &ctx, int max_insns) {
    if (start_ea == BADADDR)
        return BADADDR;
    
    // Register state - 64 registers should cover most architectures
    std::map<int, uint64_t> regs;
    
    // Initialize from caller context
    for (const auto &kv : ctx.register_values) {
        regs[kv.first] = kv.second;
    }
    
    insn_t insn;
    ea_t ea = start_ea;
    int count = 0;
    
    deobf::log_verbose("[frameless] Starting symbolic execution at 0x%llx\n", (unsigned long long)start_ea);
    
    while (count < max_insns) {
        if (decode_insn(&insn, ea) == 0)
            break;
        
        // Check for indirect jump (end of continuation)
        // x86-64: jmp rXX or jmp [mem]
        // We're looking for: jmp rcx (or similar)
        
        // Simplified x86-64 handling
        // This would need to be expanded for ARM64
        
        uint8_t first_byte = get_byte(ea);
        
        // Check for various instruction patterns
        // This is a simplified emulator - in production you'd want a proper one
        
        // mov rax, [rbp+offset] - load from caller's stack
        // Pattern: 48 8B 85 XX XX XX XX (mov rax, [rbp+disp32])
        // or: 48 8B 45 XX (mov rax, [rbp+disp8])
        if (first_byte == 0x48) {
            uint8_t second = get_byte(ea + 1);
            
            // mov r64, [rbp+disp8]
            if (second == 0x8B) {
                uint8_t modrm = get_byte(ea + 2);
                int mod = (modrm >> 6) & 3;
                int reg = (modrm >> 3) & 7;
                int rm = modrm & 7;
                
                // Check for RBP as base (rm=5)
                if (rm == 5 && mod == 1) {
                    // [rbp+disp8]
                    int8_t disp = (int8_t)get_byte(ea + 3);
                    auto val = read_rbp_relative(disp, ctx);
                    if (val.has_value()) {
                        regs[reg] = *val;
                        deobf::log_verbose("[frameless]   mov r%d, [rbp%+d] = 0x%llx\n",
                                          reg, disp, (unsigned long long)*val);
                    }
                } else if (rm == 5 && mod == 2) {
                    // [rbp+disp32]
                    int32_t disp = get_dword(ea + 3);
                    auto val = read_rbp_relative(disp, ctx);
                    if (val.has_value()) {
                        regs[reg] = *val;
                        deobf::log_verbose("[frameless]   mov r%d, [rbp%+d] = 0x%llx\n",
                                          reg, disp, (unsigned long long)*val);
                    }
                }
            }
            
            // movsxd r64, dword [...]
            if (second == 0x63) {
                // Sign-extend dword to qword
                // Handle similar to above
            }
        }
        
        // mov ecx, [global] - load from global
        // Pattern: 8B 0D XX XX XX XX (mov ecx, [rip+disp32])
        if (first_byte == 0x8B) {
            uint8_t modrm = get_byte(ea + 1);
            if ((modrm & 0xC7) == 0x05) {
                // RIP-relative addressing
                int reg = (modrm >> 3) & 7;
                int32_t disp = get_dword(ea + 2);
                ea_t global_addr = ea + 6 + disp;  // Next instruction + displacement
                
                auto val = read_global(global_addr, 4);
                if (val.has_value()) {
                    regs[reg] = *val;
                    deobf::log_verbose("[frameless]   mov r%d, [0x%llx] = 0x%llx\n",
                                      reg, (unsigned long long)global_addr, (unsigned long long)*val);
                }
            }
        }
        
        // xor ecx, edx - XOR registers
        // Pattern: 31 D1 (xor ecx, edx) or 33 CA (xor ecx, edx)
        if (first_byte == 0x31 || first_byte == 0x33) {
            uint8_t modrm = get_byte(ea + 1);
            int reg1 = (modrm >> 3) & 7;  // source
            int reg2 = modrm & 7;          // dest
            
            if (first_byte == 0x31) {
                // xor r/m, r
                if (regs.count(reg1) && regs.count(reg2)) {
                    uint64_t result = regs[reg2] ^ regs[reg1];
                    regs[reg2] = result;
                    deobf::log_verbose("[frameless]   xor r%d, r%d = 0x%llx\n",
                                      reg2, reg1, (unsigned long long)result);
                }
            } else {
                // xor r, r/m
                if (regs.count(reg1) && regs.count(reg2)) {
                    uint64_t result = regs[reg1] ^ regs[reg2];
                    regs[reg1] = result;
                    deobf::log_verbose("[frameless]   xor r%d, r%d = 0x%llx\n",
                                      reg1, reg2, (unsigned long long)result);
                }
            }
        }
        
        // xor ecx, imm32
        // Pattern: 81 F1 XX XX XX XX
        if (first_byte == 0x81) {
            uint8_t modrm = get_byte(ea + 1);
            if ((modrm & 0xF8) == 0xF0) {  // xor r32, imm32
                int reg = modrm & 7;
                uint32_t imm = get_dword(ea + 2);
                if (regs.count(reg)) {
                    uint64_t result = regs[reg] ^ imm;
                    regs[reg] = result;
                    deobf::log_verbose("[frameless]   xor r%d, 0x%x = 0x%llx\n",
                                      reg, imm, (unsigned long long)result);
                }
            }
        }
        
        // neg ecx - negate register
        // Pattern: F7 D9 (neg ecx)
        if (first_byte == 0xF7) {
            uint8_t modrm = get_byte(ea + 1);
            if ((modrm & 0xF8) == 0xD8) {  // neg r32
                int reg = modrm & 7;
                if (regs.count(reg)) {
                    uint64_t result = (uint64_t)(-(int32_t)regs[reg]);
                    regs[reg] = result;
                    deobf::log_verbose("[frameless]   neg r%d = 0x%llx\n",
                                      reg, (unsigned long long)result);
                }
            }
        }
        
        // movsxd rcx, ecx - sign extend 32 to 64
        // Pattern: 48 63 C9
        if (first_byte == 0x48 && get_byte(ea + 1) == 0x63) {
            uint8_t modrm = get_byte(ea + 2);
            int dst = (modrm >> 3) & 7;
            int src = modrm & 7;
            if (regs.count(src)) {
                int32_t signed_val = (int32_t)regs[src];
                regs[dst] = (uint64_t)(int64_t)signed_val;
                deobf::log_verbose("[frameless]   movsxd r%d, r%d = 0x%llx\n",
                                  dst, src, (unsigned long long)regs[dst]);
            }
        }
        
        // add rcx, [rax+rdx*8] - load from table
        // Pattern: 48 03 0C D0
        if (first_byte == 0x48 && get_byte(ea + 1) == 0x03) {
            uint8_t modrm = get_byte(ea + 2);
            // Check for SIB addressing
            if ((modrm & 7) == 4) {
                uint8_t sib = get_byte(ea + 3);
                int scale = 1 << ((sib >> 6) & 3);
                int index_reg = (sib >> 3) & 7;
                int base_reg = sib & 7;
                int dst_reg = (modrm >> 3) & 7;
                
                // add dst, [base + index*scale]
                if (regs.count(base_reg) && regs.count(index_reg) && regs.count(dst_reg)) {
                    ea_t table_addr = (ea_t)regs[base_reg];
                    int64_t index = (int64_t)regs[index_reg];
                    ea_t entry_addr = table_addr + index * scale;
                    
                    uint64_t table_entry = 0;
                    if (get_bytes(&table_entry, sizeof(ea_t), entry_addr) == sizeof(ea_t)) {
                        uint64_t result = regs[dst_reg] + table_entry;
                        regs[dst_reg] = result;
                        deobf::log_verbose("[frameless]   add r%d, [0x%llx + %lld*%d] = 0x%llx + 0x%llx = 0x%llx\n",
                                          dst_reg, (unsigned long long)table_addr, (long long)index, scale,
                                          (unsigned long long)(result - table_entry),
                                          (unsigned long long)table_entry,
                                          (unsigned long long)result);
                    }
                }
            }
        }
        
        // jmp rcx - indirect jump via register
        // Pattern: FF E1 (jmp rcx)
        if (first_byte == 0xFF) {
            uint8_t modrm = get_byte(ea + 1);
            if ((modrm & 0xF8) == 0xE0) {  // jmp r64
                int reg = modrm & 7;
                if (regs.count(reg)) {
                    ea_t target = (ea_t)regs[reg];
                    deobf::log("[frameless] Resolved indirect jump: jmp r%d = 0x%llx\n",
                              reg, (unsigned long long)target);
                    return target;
                }
            }
        }
        
        ea = get_item_end(ea);
        count++;
    }
    
    deobf::log("[frameless] Could not resolve indirect jump after %d instructions\n", count);
    return BADADDR;
}

```

`src/deobf/analysis/stack_tracker.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Virtual Stack Tracker
//
// Handles "Register Demotion" / Stack Spilling obfuscation where:
//   - Arguments/values normally in registers are forced to stack
//   - Indirect calls use stack slots: *(&savedregs - 132)(args)
//   - Function pointers stored on stack before being called
//
// Also handles "Frameless Continuation" obfuscation where:
//   - Obfuscated code jumps (not calls) to trampoline functions
//   - Trampolines don't set up their own stack frame
//   - They access caller's stack via unchanged RBP/frame pointer
//   - Common pattern: jmp to external code that uses [rbp+X] to compute next jump
//
// Example:
//   *(&savedregs - 133) = "countByEnumeratingWithState:objects:count:";
//   *(&savedregs - 132) = &objc_msgSend;
//   v153 = (*(&savedregs - 132))(..., *(&savedregs - 133), ...);
//
// Approach:
//   1. Track all writes to stack slots
//   2. When encountering indirect call through stack, resolve the target
//   3. Propagate known values through the function
//   4. For cross-function jumps, propagate caller context to callee
//--------------------------------------------------------------------------
class stack_tracker_t {
public:
    // Initialize for a function
    static void init(mbl_array_t *mba);

    // Clear tracked state
    static void clear();

    // Track a write to stack slot
    static void track_write(sval_t offset, uint64_t value, int size);
    static void track_write(sval_t offset, ea_t addr);  // For addresses
    static void track_write_string(sval_t offset, const char *str);

    // Read from stack slot
    static std::optional<uint64_t> read_value(sval_t offset, int size);
    static std::optional<ea_t> read_address(sval_t offset);
    static std::optional<std::string> read_string(sval_t offset);

    // Check if slot has known value
    static bool is_known(sval_t offset);

    // Resolve indirect call through stack
    // Returns: resolved function address, or BADADDR
    static ea_t resolve_stack_call(minsn_t *call_insn, mbl_array_t *mba);

    // Analyze a block and track all stack writes
    static void analyze_block(mblock_t *blk);

    // Analyze entire function
    static void analyze_function(mbl_array_t *mba);

    // Get info about a stack slot for annotation
    struct slot_info_t {
        sval_t offset;
        enum { VALUE, ADDRESS, STRING, UNKNOWN } type;
        uint64_t value;
        ea_t address;
        std::string string_val;
    };
    static std::optional<slot_info_t> get_slot_info(sval_t offset);

private:
    // Stack slot storage
    struct stack_slot_t {
        bool has_value;
        bool is_address;
        bool is_string;
        uint64_t value;
        ea_t address;
        std::string string_val;
        int size;
        ea_t write_addr;    // Where the write occurred
    };

    static std::map<sval_t, stack_slot_t> s_slots;
    static mbl_array_t *s_mba;

    // Extract value from mop
    static std::optional<uint64_t> get_mop_value(const mop_t &op);

    // Check if mop is a stack reference
    static bool is_stack_ref(const mop_t &op, sval_t *out_offset);

    // Trace back to find the value written to a register
    static std::optional<uint64_t> trace_register_value(mblock_t *blk, int reg, minsn_t *before);
};

//--------------------------------------------------------------------------
// Cross-Function Context Tracker
//
// Handles "frameless continuation" patterns where:
//   - Function A jumps (not calls) to Function B
//   - Function B doesn't set up its own frame (no push rbp; mov rbp, rsp)
//   - Function B accesses [rbp+X] which are actually A's stack slots
//   - Common in Hikari XOR-encrypted jump obfuscation
//
// Pattern example:
//   Function A:
//     mov [rbp-0x350], table_ptr   ; Store dispatch table
//     mov [rbp-0x4A8], index       ; Store index
//     jmp sub_100634814            ; Jump to continuation
//
//   Function B (sub_100634814):
//     mov rax, [rbp-0x7E0]         ; Access A's stack!
//     mov rdx, [rbp-0x4A8]         ; Access A's index!
//     ... compute target ...
//     jmp rcx                      ; Jump to computed target
//
// Solution:
//   1. When A jumps to B, capture A's stack state
//   2. When analyzing B, use A's context for [rbp+X] accesses
//   3. Resolve B's indirect jump using A's stack values
//--------------------------------------------------------------------------

// Context passed from caller to callee for frameless continuations
struct caller_context_t {
    ea_t caller_func;           // Caller function address
    ea_t callee_func;           // Callee (continuation) function address
    ea_t jump_site;             // Address where the jump occurs
    
    // Stack state from caller - maps RBP-relative offset to value
    std::map<sval_t, uint64_t> stack_values;
    
    // Register state at jump site
    std::map<int, uint64_t> register_values;
    
    // Global variable values (for XOR key resolution)
    std::map<ea_t, uint64_t> global_values;
    
    caller_context_t() : caller_func(BADADDR), callee_func(BADADDR), jump_site(BADADDR) {}
    
    bool has_stack_value(sval_t offset) const {
        return stack_values.find(offset) != stack_values.end();
    }
    
    std::optional<uint64_t> get_stack_value(sval_t offset) const {
        auto p = stack_values.find(offset);
        if ( p != stack_values.end() )
            return p->second;
        return std::nullopt;
    }
    
    std::optional<uint64_t> get_register_value(int reg) const {
        auto p = register_values.find(reg);
        if ( p != register_values.end() )
            return p->second;
        return std::nullopt;
    }
    
    std::optional<uint64_t> get_global_value(ea_t addr) const {
        auto p = global_values.find(addr);
        if ( p != global_values.end() )
            return p->second;
        return std::nullopt;
    }
};

//--------------------------------------------------------------------------
// Frameless Continuation Analyzer
//
// Detects and resolves indirect jumps in frameless continuations
// that use the caller's stack frame.
//--------------------------------------------------------------------------
class frameless_continuation_t {
public:
    // Check if a function appears to be a frameless continuation
    // (doesn't set up its own frame, uses deep RBP offsets)
    static bool is_frameless_continuation(ea_t func_ea);
    
    // Build caller context from a function before it jumps to continuation
    static caller_context_t build_caller_context(mbl_array_t *mba, mblock_t *jump_block);
    
    // Resolve indirect jump in continuation using caller's context
    // Returns: resolved target address, or BADADDR if cannot resolve
    static ea_t resolve_continuation_jump(ea_t continuation_ea, const caller_context_t &ctx);
    
    // Cache of analyzed continuations: continuation_ea -> resolved_target
    static std::map<ea_t, ea_t> s_resolution_cache;
    
    // Cache of caller contexts: caller_func -> context
    static std::map<ea_t, caller_context_t> s_context_cache;
    
    // Clear caches
    static void clear_caches();
    
private:
    // Analyze native code at addr to detect frameless pattern
    static bool analyze_prologue(ea_t func_ea);
    
    // Execute continuation code symbolically with caller's context
    static ea_t symbolic_execute(ea_t start_ea, const caller_context_t &ctx, int max_insns = 50);
    
    // Read a value from RBP-relative offset using caller context
    static std::optional<uint64_t> read_rbp_relative(sval_t offset, const caller_context_t &ctx);
    
    // Read a global variable value (with caching)
    static std::optional<uint64_t> read_global(ea_t addr, int size = 4);
};

```

`src/deobf/analysis/z3_solver.cpp`:

```cpp
#include "z3_solver.h"
#include "opaque_eval.h"

namespace z3_solver {

//--------------------------------------------------------------------------
// Global context management
//--------------------------------------------------------------------------
static std::unique_ptr<z3_context_t> g_context;
static unsigned g_timeout_ms = 5000;  // Default 5 second timeout

z3_context_t& get_global_context() {
    if (!g_context) {
        g_context = std::make_unique<z3_context_t>();
        g_context->set_timeout(g_timeout_ms);
    }
    return *g_context;
}

void reset_global_context() {
    if (g_context) {
        g_context->reset();
    }
}

void set_global_timeout(unsigned ms) {
    g_timeout_ms = ms;
    if (g_context) {
        g_context->set_timeout(ms);
    }
}

//--------------------------------------------------------------------------
// z3_context_t implementation
//--------------------------------------------------------------------------
z3_context_t::z3_context_t() : m_ctx(), m_solver(m_ctx) {
}

z3_context_t::~z3_context_t() {
}

void z3_context_t::reset() {
    m_solver.reset();
}

void z3_context_t::set_timeout(unsigned ms) {
    if (ms > 0) {
        z3::params p(m_ctx);
        p.set(":timeout", ms);
        m_solver.set(p);
    }
}

//--------------------------------------------------------------------------
// mcode_translator_t implementation
//--------------------------------------------------------------------------
mcode_translator_t::mcode_translator_t(z3_context_t& ctx)
    : m_ctx(ctx), m_fresh_counter(0) {
}

void mcode_translator_t::reset() {
    m_var_cache.clear();
    m_known_values.clear();
    m_fresh_counter = 0;
}

symbolic_var_t mcode_translator_t::mop_to_var(const mop_t& op) {
    switch (op.t) {
        case mop_r:
            return symbolic_var_t(symbolic_var_t::VAR_REGISTER, op.r, op.size);

        case mop_S:
            if (op.s) {
                return symbolic_var_t(symbolic_var_t::VAR_STACK, op.s->off, op.size);
            }
            break;

        case mop_v:
            return symbolic_var_t(symbolic_var_t::VAR_GLOBAL, op.g, op.size);

        case mop_l:
            if (op.l) {
                return symbolic_var_t(symbolic_var_t::VAR_LOCAL, op.l->idx, op.size);
            }
            break;

        default:
            break;
    }
    return symbolic_var_t(symbolic_var_t::VAR_TEMP, m_fresh_counter++, op.size);
}

z3::expr mcode_translator_t::make_const(uint64_t value, int bits) {
    return m_ctx.ctx().bv_val(value, bits);
}

z3::expr mcode_translator_t::make_symbolic(const symbolic_var_t& var) {
    // Check if we have a known value for this variable
    auto it = m_known_values.find(var);
    if (it != m_known_values.end()) {
        return make_const(it->second, var.size() * 8);
    }

    // Check cache
    auto cache_it = m_var_cache.find(var);
    if (cache_it != m_var_cache.end()) {
        return *cache_it->second;
    }

    // Create fresh symbolic variable
    int bits = var.size() * 8;
    if (bits <= 0) bits = 32;  // Default to 32-bit

    std::string name;
    switch (var.kind()) {
        case symbolic_var_t::VAR_REGISTER:
            name = "r" + std::to_string(var.id());
            break;
        case symbolic_var_t::VAR_STACK:
            name = "stk_" + std::to_string((int64_t)var.id());
            break;
        case symbolic_var_t::VAR_GLOBAL:
            name = "g_" + std::to_string(var.id());
            break;
        case symbolic_var_t::VAR_LOCAL:
            name = "l" + std::to_string(var.id());
            break;
        default:
            name = "tmp_" + std::to_string(m_fresh_counter++);
            break;
    }

    z3::expr e = m_ctx.ctx().bv_const(name.c_str(), bits);
    m_var_cache[var] = std::make_shared<z3::expr>(e);
    return e;
}

z3::expr mcode_translator_t::make_symbolic(const mop_t& op) {
    return make_symbolic(mop_to_var(op));
}

z3::expr mcode_translator_t::get_or_create_var(const mop_t& op) {
    symbolic_var_t var = mop_to_var(op);
    return make_symbolic(var);
}

void mcode_translator_t::set_known_value(const symbolic_var_t& var, uint64_t value) {
    m_known_values[var] = value;
    // Update cache to constant
    m_var_cache[var] = std::make_shared<z3::expr>(make_const(value, var.size() * 8));
}

void mcode_translator_t::set_known_value(const mop_t& op, uint64_t value) {
    set_known_value(mop_to_var(op), value);
}

z3::expr mcode_translator_t::zero_extend(const z3::expr& e, int to_bits) {
    int from_bits = e.get_sort().bv_size();
    if (from_bits >= to_bits) {
        return e;
    }
    return z3::zext(e, to_bits - from_bits);
}

z3::expr mcode_translator_t::sign_extend(const z3::expr& e, int to_bits) {
    int from_bits = e.get_sort().bv_size();
    if (from_bits >= to_bits) {
        return e;
    }
    return z3::sext(e, to_bits - from_bits);
}

z3::expr mcode_translator_t::extract(const z3::expr& e, int high, int low) {
    return e.extract(high, low);
}

z3::expr mcode_translator_t::resize(const z3::expr& e, int to_bits, bool sign_ext) {
    int from_bits = e.get_sort().bv_size();
    if (from_bits == to_bits) {
        return e;
    }
    if (from_bits > to_bits) {
        return extract(e, to_bits - 1, 0);
    }
    return sign_ext ? sign_extend(e, to_bits) : zero_extend(e, to_bits);
}

z3::expr mcode_translator_t::translate_operand(const mop_t& op, int default_size) {
    int bits = (op.size > 0 ? op.size : default_size) * 8;
    if (bits <= 0) bits = 32;

    switch (op.t) {
        case mop_n:
            // Immediate constant
            return make_const(op.nnn->value, bits);

        case mop_r:
        case mop_S:
        case mop_v:
        case mop_l:
            return make_symbolic(op);

        case mop_d:
            // Sub-instruction - translate recursively
            if (op.d) {
                return translate_insn(op.d);
            }
            break;

        case mop_z:
            // Zero
            return make_const(0, bits);

        case mop_a:
            // Address operand
            if (op.a && op.a->t == mop_v) {
                return make_const(op.a->g, bits);
            }
            break;

        case mop_b:
            // Block number - return as constant
            return make_const(op.b, bits);

        default:
            break;
    }

    // Fallback: create fresh symbolic variable
    return m_ctx.ctx().bv_const(("unk_" + std::to_string(m_fresh_counter++)).c_str(), bits);
}

z3::expr mcode_translator_t::translate_insn(const minsn_t* ins) {
    if (!ins) {
        return m_ctx.ctx().bv_val(0, 32);
    }

    int bits = ins->d.size > 0 ? ins->d.size * 8 : 32;

    // Translate operands
    z3::expr l = translate_operand(ins->l, bits / 8);
    z3::expr r = translate_operand(ins->r, bits / 8);

    // Ensure operands have matching bit widths for binary operations
    if (l.get_sort().bv_size() != r.get_sort().bv_size()) {
        int max_bits = std::max((int)l.get_sort().bv_size(), (int)r.get_sort().bv_size());
        l = resize(l, max_bits);
        r = resize(r, max_bits);
        bits = max_bits;
    }

    z3::expr result = m_ctx.ctx().bv_val(0, bits);

    switch (ins->opcode) {
        // Data movement
        case m_mov:
        case m_ldx:
            result = l;
            break;

        // Arithmetic
        case m_add:
            result = l + r;
            break;

        case m_sub:
            result = l - r;
            break;

        case m_mul:
            result = l * r;
            break;

        case m_udiv:
            result = z3::udiv(l, r);
            break;

        case m_sdiv:
            result = l / r;  // Z3's default division is signed
            break;

        case m_umod:
            result = z3::urem(l, r);
            break;

        case m_smod:
            result = z3::srem(l, r);
            break;

        // Bitwise
        case m_and:
            result = l & r;
            break;

        case m_or:
            result = l | r;
            break;

        case m_xor:
            result = l ^ r;
            break;

        case m_bnot:
            result = ~l;
            break;

        case m_lnot:
            result = z3::ite(l == 0, m_ctx.ctx().bv_val(1, bits), m_ctx.ctx().bv_val(0, bits));
            break;

        case m_neg:
            result = -l;
            break;

        // Shifts
        case m_shl:
            result = z3::shl(l, r);
            break;

        case m_shr:
            result = z3::lshr(l, r);
            break;

        case m_sar:
            result = z3::ashr(l, r);
            break;

        // Comparisons (return 1 or 0)
        case m_setz:
            result = z3::ite(l == r, m_ctx.ctx().bv_val(1, bits), m_ctx.ctx().bv_val(0, bits));
            break;

        case m_setnz:
            result = z3::ite(l != r, m_ctx.ctx().bv_val(1, bits), m_ctx.ctx().bv_val(0, bits));
            break;

        case m_setl:
            result = z3::ite(l < r, m_ctx.ctx().bv_val(1, bits), m_ctx.ctx().bv_val(0, bits));
            break;

        case m_setle:
            result = z3::ite(l <= r, m_ctx.ctx().bv_val(1, bits), m_ctx.ctx().bv_val(0, bits));
            break;

        case m_setg:
            result = z3::ite(l > r, m_ctx.ctx().bv_val(1, bits), m_ctx.ctx().bv_val(0, bits));
            break;

        case m_setge:
            result = z3::ite(l >= r, m_ctx.ctx().bv_val(1, bits), m_ctx.ctx().bv_val(0, bits));
            break;

        case m_setb:
            result = z3::ite(z3::ult(l, r), m_ctx.ctx().bv_val(1, bits), m_ctx.ctx().bv_val(0, bits));
            break;

        case m_setbe:
            result = z3::ite(z3::ule(l, r), m_ctx.ctx().bv_val(1, bits), m_ctx.ctx().bv_val(0, bits));
            break;

        case m_seta:
            result = z3::ite(z3::ugt(l, r), m_ctx.ctx().bv_val(1, bits), m_ctx.ctx().bv_val(0, bits));
            break;

        case m_setae:
            result = z3::ite(z3::uge(l, r), m_ctx.ctx().bv_val(1, bits), m_ctx.ctx().bv_val(0, bits));
            break;

        // Sign extension
        case m_xds:
            result = sign_extend(l, bits);
            break;

        // Zero extension
        case m_xdu:
            result = zero_extend(l, bits);
            break;

        // Low/high byte operations
        case m_low:
            if (l.get_sort().bv_size() >= bits) {
                result = extract(l, bits - 1, 0);
            } else {
                result = l;
            }
            break;

        case m_high:
            {
                int src_bits = l.get_sort().bv_size();
                if (src_bits > bits) {
                    result = extract(l, src_bits - 1, src_bits - bits);
                } else {
                    result = make_const(0, bits);
                }
            }
            break;

        default:
            // Unknown operation - return fresh variable
            deobf::log_verbose("[z3] Unknown opcode %d in translate_insn\n", ins->opcode);
            result = m_ctx.ctx().bv_const(("insn_" + std::to_string(m_fresh_counter++)).c_str(), bits);
            break;
    }

    return resize(result, bits);
}

z3::expr mcode_translator_t::translate_comparison(const minsn_t* ins) {
    if (!ins) {
        return m_ctx.ctx().bool_val(false);
    }

    z3::expr l = translate_operand(ins->l);
    z3::expr r = translate_operand(ins->r);

    // Ensure matching bit widths
    if (l.get_sort().bv_size() != r.get_sort().bv_size()) {
        int max_bits = std::max((int)l.get_sort().bv_size(), (int)r.get_sort().bv_size());
        l = resize(l, max_bits);
        r = resize(r, max_bits);
    }

    switch (ins->opcode) {
        case m_setz:
            return l == r;
        case m_setnz:
            return l != r;
        case m_setl:
            return l < r;
        case m_setle:
            return l <= r;
        case m_setg:
            return l > r;
        case m_setge:
            return l >= r;
        case m_setb:
            return z3::ult(l, r);
        case m_setbe:
            return z3::ule(l, r);
        case m_seta:
            return z3::ugt(l, r);
        case m_setae:
            return z3::uge(l, r);
        default:
            break;
    }

    // For non-comparison instructions, check if result is non-zero
    z3::expr result = translate_insn(ins);
    return result != 0;
}

z3::expr mcode_translator_t::translate_jcc_condition(const minsn_t* jcc) {
    if (!jcc) {
        return m_ctx.ctx().bool_val(false);
    }

    // For conditional jumps, the condition is typically in the left operand
    z3::expr cond = translate_operand(jcc->l);

    // Handle nested comparison instruction
    if (jcc->l.t == mop_d && jcc->l.d) {
        cond = translate_comparison(jcc->l.d);

        // The jcc type modifies the interpretation
        switch (jcc->opcode) {
            case m_jz:
                return !cond;
            case m_jnz:
                return cond;
            default:
                break;
        }
    }

    // For direct conditions (cond != 0)
    if (cond.is_bv()) {
        switch (jcc->opcode) {
            case m_jz:
                return cond == 0;
            case m_jnz:
                return cond != 0;
            default:
                break;
        }
        return cond != 0;
    }

    return cond;
}

//--------------------------------------------------------------------------
// symbolic_executor_t implementation
//--------------------------------------------------------------------------
symbolic_executor_t::symbolic_executor_t(z3_context_t& ctx)
    : m_ctx(ctx), m_translator(ctx) {
}

void symbolic_executor_t::reset() {
    m_state.clear();
    m_constraints.clear();
    m_translator.reset();
}

std::unique_ptr<symbolic_executor_t> symbolic_executor_t::clone() const {
    auto copy = std::make_unique<symbolic_executor_t>(m_ctx);
    copy->m_state = m_state;
    copy->m_constraints = m_constraints;
    return copy;
}

void symbolic_executor_t::execute_insn(const minsn_t* ins) {
    if (!ins) return;

    switch (ins->opcode) {
        case m_mov:
        case m_ldx:
            handle_assignment(ins);
            break;

        case m_stx:
            handle_store(ins);
            break;

        default:
            // For other instructions, check if they have a destination
            if (ins->d.t != mop_z && ins->d.t != mop_b) {
                handle_assignment(ins);
            }
            break;
    }
}

void symbolic_executor_t::handle_assignment(const minsn_t* ins) {
    if (!ins) return;

    // Translate the instruction to get result expression
    z3::expr value = m_translator.translate_insn(ins);

    // Get destination variable
    if (ins->d.t == mop_r || ins->d.t == mop_S || ins->d.t == mop_v || ins->d.t == mop_l) {
        symbolic_var_t dst_var = symbolic_var_t(
            ins->d.t == mop_r ? symbolic_var_t::VAR_REGISTER :
            ins->d.t == mop_S ? symbolic_var_t::VAR_STACK :
            ins->d.t == mop_v ? symbolic_var_t::VAR_GLOBAL :
            symbolic_var_t::VAR_LOCAL,
            ins->d.t == mop_r ? ins->d.r :
            ins->d.t == mop_S && ins->d.s ? ins->d.s->off :
            ins->d.t == mop_v ? ins->d.g :
            ins->d.l ? ins->d.l->idx : 0,
            ins->d.size
        );
        m_state[dst_var] = std::make_shared<z3::expr>(value);
    }
}

void symbolic_executor_t::handle_load(const minsn_t* ins) {
    // For now, treat loads as fresh symbolic values unless from known locations
    handle_assignment(ins);
}

void symbolic_executor_t::handle_store(const minsn_t* ins) {
    // Store instruction: store value to memory
    // For symbolic execution, we track this in our state
    if (!ins) return;

    if (ins->d.t == mop_S || ins->d.t == mop_v) {
        z3::expr value = m_translator.translate_operand(ins->l);
        symbolic_var_t dst_var = symbolic_var_t(
            ins->d.t == mop_S ? symbolic_var_t::VAR_STACK : symbolic_var_t::VAR_GLOBAL,
            ins->d.t == mop_S && ins->d.s ? ins->d.s->off : ins->d.g,
            ins->d.size
        );
        m_state[dst_var] = std::make_shared<z3::expr>(value);
    }
}

void symbolic_executor_t::execute_block(const mblock_t* blk) {
    if (!blk) return;

    for (const minsn_t* ins = blk->head; ins; ins = ins->next) {
        execute_insn(ins);
    }
}

std::optional<z3::expr> symbolic_executor_t::get_value(const symbolic_var_t& var) {
    auto it = m_state.find(var);
    if (it != m_state.end() && it->second) {
        return *it->second;
    }
    return std::nullopt;
}

std::optional<z3::expr> symbolic_executor_t::get_value(const mop_t& op) {
    symbolic_var_t var(
        op.t == mop_r ? symbolic_var_t::VAR_REGISTER :
        op.t == mop_S ? symbolic_var_t::VAR_STACK :
        op.t == mop_v ? symbolic_var_t::VAR_GLOBAL :
        symbolic_var_t::VAR_LOCAL,
        op.t == mop_r ? op.r :
        op.t == mop_S && op.s ? op.s->off :
        op.t == mop_v ? op.g :
        op.l ? op.l->idx : 0,
        op.size
    );
    return get_value(var);
}

void symbolic_executor_t::add_constraint(const z3::expr& constraint) {
    m_constraints.push_back(std::make_shared<z3::expr>(constraint));
}

sat_result_t symbolic_executor_t::check_path_feasibility() {
    m_ctx.solver().reset();

    for (const auto& c : m_constraints) {
        if (c) m_ctx.solver().add(*c);
    }

    switch (m_ctx.solver().check()) {
        case z3::sat:
            return sat_result_t::SAT;
        case z3::unsat:
            return sat_result_t::UNSAT;
        default:
            return sat_result_t::UNKNOWN;
    }
}

std::optional<uint64_t> symbolic_executor_t::solve_for_value(const z3::expr& expr) {
    m_ctx.solver().reset();

    for (const auto& c : m_constraints) {
        if (c) m_ctx.solver().add(*c);
    }

    if (m_ctx.solver().check() == z3::sat) {
        z3::model m = m_ctx.solver().get_model();
        z3::expr val = m.eval(expr, true);
        if (val.is_numeral()) {
            return val.get_numeral_uint64();
        }
    }
    return std::nullopt;
}

std::optional<uint64_t> symbolic_executor_t::solve_for_value(const mop_t& op) {
    z3::expr e = m_translator.translate_operand(op);
    return solve_for_value(e);
}

std::vector<uint64_t> symbolic_executor_t::enumerate_values(const mop_t& op, int max_count) {
    std::vector<uint64_t> values;
    z3::expr e = m_translator.translate_operand(op);

    m_ctx.solver().reset();
    for (const auto& c : m_constraints) {
        if (c) m_ctx.solver().add(*c);
    }

    while ((int)values.size() < max_count) {
        if (m_ctx.solver().check() != z3::sat) {
            break;
        }

        z3::model m = m_ctx.solver().get_model();
        z3::expr val = m.eval(e, true);
        if (!val.is_numeral()) {
            break;
        }

        uint64_t v = val.get_numeral_uint64();
        values.push_back(v);

        // Exclude this value for next iteration
        m_ctx.solver().add(e != m_ctx.ctx().bv_val(v, e.get_sort().bv_size()));
    }

    return values;
}

//--------------------------------------------------------------------------
// state_machine_solver_t implementation
//--------------------------------------------------------------------------
state_machine_solver_t::state_machine_solver_t(z3_context_t& ctx)
    : m_ctx(ctx), m_translator(ctx) {
}

// Helper: Check if a value looks like a Hikari state constant
static bool is_hikari_state_const(uint64_t val) {
    if (val < 0x10000000 || val > 0xFFFFFFFF)
        return false;

    uint32_t high = (val >> 16) & 0xFFFF;
    if (high == 0)
        return false;

    switch (high) {
        case 0xAAAA: case 0xABCD: case 0xBBBB: case 0xCCCC: case 0xDDDD:
        case 0xBEEF: case 0xCAFE: case 0xDEAD:
        case 0x1111: case 0x2222: case 0x3333: case 0x4444:
        case 0x5555: case 0x6666: case 0x7777: case 0x8888: case 0x9999:
        case 0xFEED: case 0xFACE: case 0xBABE: case 0xC0DE: case 0xF00D:
            return true;
        default:
            return false;
    }
}

std::set<uint64_t> state_machine_solver_t::find_state_constants(const mblock_t* blk) {
    std::set<uint64_t> constants;
    if (!blk) return constants;

    for (const minsn_t* ins = blk->head; ins; ins = ins->next) {
        // Check all operands for Hikari constants
        if (ins->l.t == mop_n && is_hikari_state_const(ins->l.nnn->value)) {
            constants.insert(ins->l.nnn->value);
        }
        if (ins->r.t == mop_n && is_hikari_state_const(ins->r.nnn->value)) {
            constants.insert(ins->r.nnn->value);
        }

        // Check nested instructions
        if (ins->l.t == mop_d && ins->l.d) {
            const minsn_t* nested = ins->l.d;
            if (nested->l.t == mop_n && is_hikari_state_const(nested->l.nnn->value)) {
                constants.insert(nested->l.nnn->value);
            }
            if (nested->r.t == mop_n && is_hikari_state_const(nested->r.nnn->value)) {
                constants.insert(nested->r.nnn->value);
            }
        }
    }

    return constants;
}

//--------------------------------------------------------------------------
// Helper: Extract state comparison info from a single block
// Returns true if a state comparison (jcc with setXX against Hikari const) is found
//--------------------------------------------------------------------------
static bool extract_state_comparison(mbl_array_t* mba, int block_idx,
                                      mop_t* out_var, uint64_t* out_state, int* out_target) {
    if (!mba || block_idx < 0 || block_idx >= mba->qty)
        return false;

    mblock_t* blk = mba->get_mblock(block_idx);
    if (!blk)
        return false;

    // Log block instructions for debugging (only for blocks with state constants)
    static bool debug_logged = false;
    if (!debug_logged && block_idx >= 2 && block_idx <= 13) {
        deobf::log("[z3] Block %d instructions:\n", block_idx);
        for (const minsn_t* ins = blk->head; ins; ins = ins->next) {
            deobf::log("[z3]   opcode=%d l.t=%d r.t=%d d.t=%d\n",
                      ins->opcode, ins->l.t, ins->r.t, ins->d.t);
            if (ins->l.t == mop_n) {
                deobf::log("[z3]     l.n=0x%llx\n", (unsigned long long)ins->l.nnn->value);
            }
            if (ins->r.t == mop_n) {
                deobf::log("[z3]     r.n=0x%llx\n", (unsigned long long)ins->r.nnn->value);
            }
        }
        if (block_idx == 13) debug_logged = true;
    }

    // Track which registers hold state constants (for flattened microcode)
    std::map<mreg_t, uint64_t> reg_to_const;

    for (const minsn_t* ins = blk->head; ins; ins = ins->next) {
        // Track mov of constants to registers
        // mop_n=2, mop_r=1 in IDA microcode
        if (ins->opcode == m_mov && ins->l.t == mop_n && ins->d.t == mop_r) {
            uint64_t val = ins->l.nnn->value;
            if (is_hikari_state_const(val)) {
                deobf::log("[z3] Block %d: tracking reg %d <- 0x%llx\n",
                          block_idx, ins->d.r, (unsigned long long)val);
                reg_to_const[ins->d.r] = val;
            }
        }

        // Also log setXX instructions for debugging
        if (is_mcode_set(ins->opcode) && block_idx >= 2 && block_idx <= 5) {
            deobf::log("[z3] Block %d: setXX opcode=%d l.t=%d l.r=%d r.t=%d r.r=%d\n",
                      block_idx, ins->opcode, ins->l.t, ins->l.t == mop_r ? ins->l.r : -1,
                      ins->r.t, ins->r.t == mop_r ? ins->r.r : -1);
        }

        // Method 1: Check setXX instructions where one operand is a register holding a state constant
        if (is_mcode_set(ins->opcode)) {
            uint64_t state_val = 0;
            mop_t var;
            bool found = false;

            if (block_idx >= 2 && block_idx <= 5) {
                deobf::log("[z3] Block %d: checking setXX - l.t=%d l.r=%d (have=%d) r.t=%d r.r=%d (have=%d)\n",
                          block_idx, ins->l.t, ins->l.t == mop_r ? (int)ins->l.r : -1,
                          ins->l.t == mop_r ? (int)reg_to_const.count(ins->l.r) : 0,
                          ins->r.t, ins->r.t == mop_r ? (int)ins->r.r : -1,
                          ins->r.t == mop_r ? (int)reg_to_const.count(ins->r.r) : 0);
            }

            // Check if left operand is a register with known constant
            if (ins->l.t == mop_r && reg_to_const.count(ins->l.r)) {
                state_val = reg_to_const[ins->l.r];
                var = ins->r;
                found = true;
            }
            // Check if right operand is a register with known constant
            else if (ins->r.t == mop_r && reg_to_const.count(ins->r.r)) {
                state_val = reg_to_const[ins->r.r];
                var = ins->l;
                found = true;
            }
            // Also check for direct number operands
            else if (ins->l.t == mop_n && is_hikari_state_const(ins->l.nnn->value)) {
                state_val = ins->l.nnn->value;
                var = ins->r;
                found = true;
            }
            else if (ins->r.t == mop_n && is_hikari_state_const(ins->r.nnn->value)) {
                state_val = ins->r.nnn->value;
                var = ins->l;
                found = true;
            }

            if (found) {
                if (block_idx >= 2 && block_idx <= 5) {
                    deobf::log("[z3] Block %d: found=true, state=0x%llx, searching for jcc...\n",
                              block_idx, (unsigned long long)state_val);
                }
                // Find the jcnd that uses this comparison result
                for (const minsn_t* jcc = ins->next; jcc; jcc = jcc->next) {
                    if (deobf::is_jcc(jcc->opcode)) {
                        int target_block = -1;

                        // d.t can be mop_b (block number) or mop_v (address)
                        if (jcc->d.t == mop_b) {
                            target_block = jcc->d.b;
                        } else if (jcc->d.t == mop_v) {
                            // mop_v: d.g is the target address, need to find which block it's in
                            ea_t target_addr = jcc->d.g;

                            // Search for the block containing this address
                            for (int bi = 0; bi < mba->qty; bi++) {
                                mblock_t* tblk = mba->get_mblock(bi);
                                if (tblk && tblk->start <= target_addr && target_addr < tblk->end) {
                                    target_block = bi;
                                    break;
                                }
                            }

                            if (target_block < 0) {
                                // Fallback: find block whose start matches the address
                                for (int bi = 0; bi < mba->qty; bi++) {
                                    mblock_t* tblk = mba->get_mblock(bi);
                                    if (tblk && tblk->start == target_addr) {
                                        target_block = bi;
                                        break;
                                    }
                                }
                            }

                            if (target_block >= 0) {
                                deobf::log("[z3] Block %d: found setXX(%d) state cmp 0x%llx -> block %d (addr 0x%llx)\n",
                                          block_idx, ins->opcode, (unsigned long long)state_val,
                                          target_block, (unsigned long long)target_addr);
                            } else {
                                deobf::log("[z3] Block %d: found setXX(%d) state cmp 0x%llx -> unresolved addr 0x%llx\n",
                                          block_idx, ins->opcode, (unsigned long long)state_val,
                                          (unsigned long long)target_addr);
                            }
                        }

                        if (target_block >= 0) {
                            deobf::log("[z3] Block %d: found setXX(%d) state cmp 0x%llx -> block %d\n",
                                      block_idx, ins->opcode, (unsigned long long)state_val, target_block);
                            if (out_var) *out_var = var;
                            if (out_state) *out_state = state_val;
                            if (out_target) *out_target = target_block;
                            return true;
                        }
                    }
                }
            }
        }

        // Method 2: jcc with nested setXX (for earlier optimization stages)
        if (deobf::is_jcc(ins->opcode)) {
            if (ins->l.t == mop_d && ins->l.d) {
                const minsn_t* cmp = ins->l.d;
                if (is_mcode_set(cmp->opcode)) {
                    uint64_t state_val = 0;
                    mop_t var;
                    bool found = false;

                    if (cmp->l.t == mop_n && is_hikari_state_const(cmp->l.nnn->value)) {
                        state_val = cmp->l.nnn->value;
                        var = cmp->r;
                        found = true;
                    } else if (cmp->r.t == mop_n && is_hikari_state_const(cmp->r.nnn->value)) {
                        state_val = cmp->r.nnn->value;
                        var = cmp->l;
                        found = true;
                    }

                    if (found && ins->d.t == mop_b) {
                        deobf::log("[z3] Block %d: found nested setXX state cmp 0x%llx -> block %d\n",
                                  block_idx, (unsigned long long)state_val, ins->d.b);
                        if (out_var) *out_var = var;
                        if (out_state) *out_state = state_val;
                        if (out_target) *out_target = ins->d.b;
                        return true;
                    }
                }
            }
        }
    }

    return false;
}

state_machine_solver_t::dispatcher_analysis_t
state_machine_solver_t::analyze_dispatcher(mbl_array_t* mba, int block_idx) {
    dispatcher_analysis_t result;
    result.is_dispatcher = false;
    result.block_idx = block_idx;

    if (!mba || block_idx < 0 || block_idx >= mba->qty)
        return result;

    // Check cache
    auto cache_it = m_dispatcher_cache.find(block_idx);
    if (cache_it != m_dispatcher_cache.end()) {
        return cache_it->second;
    }

    mblock_t* blk = mba->get_mblock(block_idx);
    if (!blk)
        return result;

    // Find Hikari state constants in this block
    std::set<uint64_t> state_consts = find_state_constants(blk);

    mop_t potential_state_var;
    bool found_state_var = false;
    std::map<uint64_t, int> state_to_target;

    // First, try to find comparisons in this single block
    for (const minsn_t* ins = blk->head; ins; ins = ins->next) {
        if (!deobf::is_jcc(ins->opcode))
            continue;

        if (ins->l.t == mop_d && ins->l.d) {
            const minsn_t* cmp = ins->l.d;
            if (is_mcode_set(cmp->opcode)) {
                uint64_t state_val = 0;
                bool found_const = false;
                mop_t var;

                if (cmp->l.t == mop_n && is_hikari_state_const(cmp->l.nnn->value)) {
                    state_val = cmp->l.nnn->value;
                    var = cmp->r;
                    found_const = true;
                } else if (cmp->r.t == mop_n && is_hikari_state_const(cmp->r.nnn->value)) {
                    state_val = cmp->r.nnn->value;
                    var = cmp->l;
                    found_const = true;
                }

                if (found_const && ins->d.t == mop_b) {
                    if (!found_state_var) {
                        potential_state_var = var;
                        found_state_var = true;
                    }
                    state_to_target[state_val] = ins->d.b;
                }
            }
        }
    }

    // If we found enough comparisons in this block, we're done
    if (state_to_target.size() >= 2 && found_state_var) {
        result.is_dispatcher = true;
        result.state_to_block = state_to_target;

        if (potential_state_var.t == mop_S && potential_state_var.s) {
            result.state_var = symbolic_var_t(symbolic_var_t::VAR_STACK,
                                               potential_state_var.s->off,
                                               potential_state_var.size);
        } else if (potential_state_var.t == mop_r) {
            result.state_var = symbolic_var_t(symbolic_var_t::VAR_REGISTER,
                                               potential_state_var.r,
                                               potential_state_var.size);
        } else if (potential_state_var.t == mop_v) {
            result.state_var = symbolic_var_t(symbolic_var_t::VAR_GLOBAL,
                                               potential_state_var.g,
                                               potential_state_var.size);
        }

        deobf::log("[z3] Found dispatcher at block %d with %zu state mappings\n",
                  block_idx, state_to_target.size());
        m_dispatcher_cache[block_idx] = result;
        return result;
    }

    // CASCADING DISPATCHER DETECTION:
    // Since successor information may not be available, we scan all blocks
    // with state constants and group them if they compare against the same variable type

    // First, check if this block actually has a state comparison
    mop_t first_var;
    uint64_t first_state = 0;
    int first_target = -1;
    bool has_comparison = extract_state_comparison(mba, block_idx, &first_var, &first_state, &first_target);

    if (has_comparison) {
        // Check if any earlier block already created a dispatcher that covers this block
        for (int earlier = 0; earlier < block_idx; earlier++) {
            auto earlier_it = m_dispatcher_cache.find(earlier);
            if (earlier_it != m_dispatcher_cache.end() && earlier_it->second.is_dispatcher) {
                // An earlier block already created a dispatcher
                // Mark this block as part of that dispatcher (not a new one)
                deobf::log("[z3] Block %d: part of earlier dispatcher starting at block %d\n", block_idx, earlier);
                m_dispatcher_cache[block_idx] = result;  // result.is_dispatcher = false
                return result;
            }
        }

        deobf::log("[z3] Block %d: has state comparison, scanning all blocks for dispatcher\n", block_idx);

        // Scan ALL blocks with state constants starting from block 0 to capture all
        for (int scan_blk = 0; scan_blk < mba->qty; scan_blk++) {
            mop_t var;
            uint64_t state_val = 0;
            int target = -1;

            if (extract_state_comparison(mba, scan_blk, &var, &state_val, &target) && target >= 0) {
                // Only add unique state values (skip ja/jb type comparisons that go to fallback)
                // The equality comparison (state_val -> case block) is what we want
                if (state_to_target.find(state_val) == state_to_target.end()) {
                    state_to_target[state_val] = target;

                    if (!found_state_var) {
                        potential_state_var = var;
                        found_state_var = true;
                    }

                    deobf::log("[z3] Scan: block %d added state 0x%llx -> block %d (map size=%zu)\n",
                              scan_blk, (unsigned long long)state_val, target, state_to_target.size());
                }
            }
        }

        // If we accumulated enough comparisons via the chain, this is a cascading dispatcher
        if (state_to_target.size() >= 2 && found_state_var) {
            result.is_dispatcher = true;
            result.state_to_block = state_to_target;

            if (potential_state_var.t == mop_S && potential_state_var.s) {
                result.state_var = symbolic_var_t(symbolic_var_t::VAR_STACK,
                                                   potential_state_var.s->off,
                                                   potential_state_var.size);
            } else if (potential_state_var.t == mop_r) {
                result.state_var = symbolic_var_t(symbolic_var_t::VAR_REGISTER,
                                                   potential_state_var.r,
                                                   potential_state_var.size);
            } else if (potential_state_var.t == mop_v) {
                result.state_var = symbolic_var_t(symbolic_var_t::VAR_GLOBAL,
                                                   potential_state_var.g,
                                                   potential_state_var.size);
            }

            deobf::log("[z3] Found CASCADING dispatcher starting at block %d with %zu state mappings\n",
                      block_idx, state_to_target.size());
        }
    }

    m_dispatcher_cache[block_idx] = result;
    return result;
}

std::optional<uint64_t>
state_machine_solver_t::determine_written_state(mbl_array_t* mba, int block_idx,
                                                  const symbolic_var_t& state_var) {
    if (!mba || block_idx < 0 || block_idx >= mba->qty)
        return std::nullopt;

    mblock_t* blk = mba->get_mblock(block_idx);
    if (!blk)
        return std::nullopt;

    // Use symbolic execution to determine final state value
    symbolic_executor_t executor(m_ctx);

    // Execute the block
    executor.execute_block(blk);

    // Get the value of the state variable after execution
    auto value = executor.get_value(state_var);
    if (value.has_value()) {
        // Try to solve for a concrete value
        auto concrete = executor.solve_for_value(value.value());
        if (concrete.has_value() && is_hikari_state_const(*concrete)) {
            return concrete;
        }
    }

    // Fallback: scan for direct constant assignments to state var
    for (const minsn_t* ins = blk->head; ins; ins = ins->next) {
        if (ins->opcode != m_mov)
            continue;

        if (ins->l.t != mop_n || !is_hikari_state_const(ins->l.nnn->value))
            continue;

        // Check if destination matches state variable
        bool matches = false;
        if (ins->d.t == mop_S && state_var.kind() == symbolic_var_t::VAR_STACK) {
            if (ins->d.s && ins->d.s->off == (sval_t)state_var.id())
                matches = true;
        } else if (ins->d.t == mop_r && state_var.kind() == symbolic_var_t::VAR_REGISTER) {
            if (ins->d.r == (mreg_t)state_var.id())
                matches = true;
        } else if (ins->d.t == mop_v && state_var.kind() == symbolic_var_t::VAR_GLOBAL) {
            if (ins->d.g == (ea_t)state_var.id())
                matches = true;
        }

        if (matches) {
            return ins->l.nnn->value;
        }
    }

    return std::nullopt;
}

state_machine_solver_t::block_transition_t
state_machine_solver_t::analyze_block_transition(mbl_array_t* mba, int block_idx,
                                                   const symbolic_var_t& state_var) {
    block_transition_t result;
    result.from_block = block_idx;
    result.to_block = -1;
    result.to_block_true = -1;
    result.to_block_false = -1;
    result.next_state = 0;
    result.is_conditional = false;
    result.solved = false;

    if (!mba || block_idx < 0 || block_idx >= mba->qty)
        return result;

    mblock_t* blk = mba->get_mblock(block_idx);
    if (!blk)
        return result;

    // Determine what state value this block writes
    auto written_state = determine_written_state(mba, block_idx, state_var);
    if (written_state.has_value()) {
        result.next_state = *written_state;
        result.solved = true;

        deobf::log_verbose("[z3] Block %d writes state 0x%llx\n",
                  block_idx, (unsigned long long)*written_state);
    }

    // Check for conditional transitions
    if (blk->tail && deobf::is_jcc(blk->tail->opcode)) {
        result.is_conditional = true;
        result.condition = std::make_shared<z3::expr>(m_translator.translate_jcc_condition(blk->tail));

        if (blk->tail->d.t == mop_b) {
            result.to_block_true = blk->tail->d.b;
        }
        // Fall-through target would be next block
        if (blk->nsucc() >= 2) {
            for (int i = 0; i < blk->nsucc(); i++) {
                int succ = blk->succ(i);
                if (succ != result.to_block_true) {
                    result.to_block_false = succ;
                    break;
                }
            }
        }
    } else if (blk->tail && blk->tail->opcode == m_goto) {
        if (blk->tail->d.t == mop_b) {
            result.to_block = blk->tail->d.b;
        }
    }

    return result;
}

state_machine_solver_t::state_machine_t
state_machine_solver_t::solve_state_machine(mbl_array_t* mba) {
    state_machine_t machine;
    machine.solved = false;

    if (!mba)
        return machine;

    deobf::log("[z3] Solving state machine for function with %d blocks\n", mba->qty);
    deobf::log("[z3] Starting block scan...\n");

    // First pass: identify blocks with state constants
    std::vector<int> blocks_with_state_consts;
    for (int i = 0; i < mba->qty; i++) {
        mblock_t* blk = mba->get_mblock(i);
        if (!blk) {
            deobf::log("[z3]   Block %d: NULL\n", i);
            continue;
        }
        auto consts = find_state_constants(blk);
        if (!consts.empty()) {
            blocks_with_state_consts.push_back(i);
            deobf::log("[z3]   Block %d has %zu state constants:", i, consts.size());
            for (uint64_t c : consts) {
                deobf::log(" 0x%llx", (unsigned long long)c);
            }
            deobf::log("\n");
        }
    }
    deobf::log("[z3] Block scan complete. Found %zu blocks with state constants\n", blocks_with_state_consts.size());

    // Step 1: Find all dispatchers (try blocks with state constants first)
    for (int i : blocks_with_state_consts) {
        auto disp = analyze_dispatcher(mba, i);
        if (disp.is_dispatcher) {
            machine.dispatchers.push_back(disp);
        }
    }

    // Also try all blocks if we haven't found any
    if (machine.dispatchers.empty()) {
        for (int i = 0; i < mba->qty; i++) {
            auto disp = analyze_dispatcher(mba, i);
            if (disp.is_dispatcher) {
                machine.dispatchers.push_back(disp);
            }
        }
    }

    if (machine.dispatchers.empty()) {
        deobf::log("[z3] No dispatchers found\n");
        return machine;
    }

    deobf::log("[z3] Found %zu dispatchers\n", machine.dispatchers.size());

    // Step 2: For each dispatcher, analyze case blocks
    for (const auto& disp : machine.dispatchers) {
        // Collect all blocks that belong to this dispatcher
        std::set<int> case_blocks;
        for (const auto& kv : disp.state_to_block) {
            case_blocks.insert(kv.second);
        }

        // Analyze each case block's transitions
        for (int case_blk : case_blocks) {
            auto trans = analyze_block_transition(mba, case_blk, disp.state_var);
            if (trans.solved) {
                machine.transitions.push_back(trans);
            }
        }
    }

    // Step 3: Build state-to-block mapping and determine original CFG
    // For each state value written by a block, find which block handles that state
    std::map<uint64_t, int> state_handlers;  // state -> block that handles it

    for (const auto& disp : machine.dispatchers) {
        for (const auto& kv : disp.state_to_block) {
            state_handlers[kv.first] = kv.second;
        }
    }

    // For each transition, determine the actual target block
    for (auto& trans : machine.transitions) {
        if (trans.solved && trans.next_state != 0) {
            auto it = state_handlers.find(trans.next_state);
            if (it != state_handlers.end()) {
                if (!trans.is_conditional) {
                    trans.to_block = it->second;
                }
                machine.block_successors[trans.from_block].push_back(it->second);
            }
        }
    }

    // Mark as solved if we found any dispatchers (even without full transition analysis)
    machine.solved = !machine.dispatchers.empty();

    deobf::log("[z3] State machine analysis complete: %zu dispatchers, %zu transitions, %s\n",
              machine.dispatchers.size(), machine.transitions.size(),
              machine.solved ? "SOLVED" : "UNSOLVED");

    m_machine = machine;
    return machine;
}

std::optional<int> state_machine_solver_t::resolve_state_to_block(uint64_t state_value) {
    if (!m_machine.has_value() || !m_machine->solved)
        return std::nullopt;

    for (const auto& disp : m_machine->dispatchers) {
        auto it = disp.state_to_block.find(state_value);
        if (it != disp.state_to_block.end()) {
            return it->second;
        }
    }
    return std::nullopt;
}

//--------------------------------------------------------------------------
// opaque_predicate_solver_t implementation
//--------------------------------------------------------------------------
opaque_predicate_solver_t::opaque_predicate_solver_t(z3_context_t& ctx)
    : m_ctx(ctx), m_translator(ctx) {
}

opaque_predicate_solver_t::predicate_result_t
opaque_predicate_solver_t::analyze_condition(const minsn_t* cond) {
    if (!cond)
        return PRED_UNKNOWN;

    // First, try simple constant evaluation
    bool result;
    if (opaque_eval_t::evaluate_condition(const_cast<minsn_t*>(cond), &result)) {
        return result ? PRED_ALWAYS_TRUE : PRED_ALWAYS_FALSE;
    }

    // Use Z3 for more complex analysis
    try {
        z3::expr condition = m_translator.translate_jcc_condition(cond);

        // Check if condition is always true (negation is unsatisfiable)
        m_ctx.solver().reset();
        m_ctx.solver().add(!condition);
        if (m_ctx.solver().check() == z3::unsat) {
            return PRED_ALWAYS_TRUE;
        }

        // Check if condition is always false (condition itself is unsatisfiable)
        m_ctx.solver().reset();
        m_ctx.solver().add(condition);
        if (m_ctx.solver().check() == z3::unsat) {
            return PRED_ALWAYS_FALSE;
        }

        // Both are satisfiable - condition depends on input
        return PRED_DEPENDS_ON_INPUT;

    } catch (z3::exception& e) {
        deobf::log_verbose("[z3] Exception in analyze_condition: %s\n", e.msg());
        return PRED_UNKNOWN;
    }
}

opaque_predicate_solver_t::analysis_result_t
opaque_predicate_solver_t::analyze_detailed(const minsn_t* cond) {
    analysis_result_t result;
    result.result = analyze_condition(cond);

    try {
        z3::expr condition = m_translator.translate_jcc_condition(cond);
        result.simplified = std::make_shared<z3::expr>(condition.simplify());

        switch (result.result) {
            case PRED_ALWAYS_TRUE:
                result.proof_hint = "Condition is a tautology";
                break;
            case PRED_ALWAYS_FALSE:
                result.proof_hint = "Condition is a contradiction";
                break;
            case PRED_DEPENDS_ON_INPUT:
                result.proof_hint = "Condition depends on symbolic values";
                break;
            default:
                result.proof_hint = "Analysis inconclusive";
                break;
        }
    } catch (z3::exception&) {
        result.proof_hint = "Z3 exception during analysis";
    }

    return result;
}

bool opaque_predicate_solver_t::is_xy_even_pattern(const minsn_t* ins) {
    // Pattern: x * (x + 1) % 2 == 0 is always true
    if (!ins)
        return false;

    try {
        z3::expr e = m_translator.translate_insn(ins);

        // Create symbolic x
        z3::expr x = m_ctx.ctx().bv_const("x", 32);

        // x * (x + 1) % 2
        z3::expr pattern = z3::urem(x * (x + 1), 2);

        // Check if result == 0 for all x
        m_ctx.solver().reset();
        m_ctx.solver().add(pattern != 0);

        return m_ctx.solver().check() == z3::unsat;
    } catch (z3::exception&) {
        return false;
    }
}

bool opaque_predicate_solver_t::is_tautology_pattern(const minsn_t* ins) {
    // Pattern: x < C || x >= C (or similar) is always true
    if (!ins || ins->opcode != m_or)
        return false;

    try {
        z3::expr condition = m_translator.translate_insn(ins);

        // Check if condition is always non-zero
        m_ctx.solver().reset();
        m_ctx.solver().add(condition == 0);

        return m_ctx.solver().check() == z3::unsat;
    } catch (z3::exception&) {
        return false;
    }
}

bool opaque_predicate_solver_t::is_modular_pattern(const minsn_t* ins) {
    // Various modular arithmetic patterns that are constant
    // E.g., (x^2 - 1) % 8 when x is odd gives 0

    if (!ins)
        return false;

    // Check if expression contains modulo operation
    if (ins->opcode != m_umod && ins->opcode != m_smod)
        return false;

    try {
        z3::expr e = m_translator.translate_insn(ins);
        z3::expr simplified = e.simplify();

        // If simplified to a constant, it's a modular pattern
        if (simplified.is_numeral()) {
            return true;
        }
    } catch (z3::exception&) {
    }

    return false;
}

//--------------------------------------------------------------------------
// expression_simplifier_t implementation
//--------------------------------------------------------------------------
expression_simplifier_t::expression_simplifier_t(z3_context_t& ctx)
    : m_ctx(ctx), m_translator(ctx) {
}

z3::expr expression_simplifier_t::simplify(const z3::expr& expr) {
    return expr.simplify();
}

eval_result_t expression_simplifier_t::evaluate_constant(const minsn_t* ins) {
    if (!ins)
        return eval_result_t::unknown();

    // First try simple evaluation
    auto simple_result = opaque_eval_t::evaluate_expr(const_cast<minsn_t*>(ins));
    if (simple_result.has_value()) {
        return eval_result_t::constant(*simple_result, ins->d.size * 8);
    }

    // Use Z3 for complex expressions
    try {
        z3::expr e = m_translator.translate_insn(ins);
        z3::expr simplified = e.simplify();

        if (simplified.is_numeral()) {
            uint64_t val = simplified.get_numeral_uint64();
            return eval_result_t::constant(val, simplified.get_sort().bv_size());
        }
    } catch (z3::exception&) {
    }

    return eval_result_t::unknown();
}

eval_result_t expression_simplifier_t::evaluate_constant(const mop_t& op) {
    // Handle immediate constants directly
    if (op.t == mop_n) {
        return eval_result_t::constant(op.nnn->value, op.size * 8);
    }

    // Handle global variables by reading from binary
    if (op.t == mop_v) {
        auto val = opaque_eval_t::read_global(op.g, op.size);
        if (val.has_value()) {
            return eval_result_t::constant(*val, op.size * 8);
        }
    }

    // Handle sub-instructions
    if (op.t == mop_d && op.d) {
        return evaluate_constant(op.d);
    }

    return eval_result_t::unknown();
}

bool expression_simplifier_t::are_equivalent(const z3::expr& a, const z3::expr& b) {
    try {
        m_ctx.solver().reset();
        m_ctx.solver().add(a != b);
        return m_ctx.solver().check() == z3::unsat;
    } catch (z3::exception&) {
        return false;
    }
}

bool expression_simplifier_t::are_equivalent(const minsn_t* a, const minsn_t* b) {
    if (!a || !b)
        return false;

    try {
        z3::expr ea = m_translator.translate_insn(a);
        z3::expr eb = m_translator.translate_insn(b);
        return are_equivalent(ea, eb);
    } catch (z3::exception&) {
        return false;
    }
}

//--------------------------------------------------------------------------
// Convenience functions
//--------------------------------------------------------------------------
std::optional<bool> is_condition_constant(const minsn_t* cond) {
    opaque_predicate_solver_t solver(get_global_context());
    auto result = solver.analyze_condition(cond);

    switch (result) {
        case opaque_predicate_solver_t::PRED_ALWAYS_TRUE:
            return true;
        case opaque_predicate_solver_t::PRED_ALWAYS_FALSE:
            return false;
        default:
            return std::nullopt;
    }
}

eval_result_t evaluate_to_constant(const minsn_t* ins) {
    expression_simplifier_t simplifier(get_global_context());
    return simplifier.evaluate_constant(ins);
}

eval_result_t evaluate_to_constant(const mop_t& op) {
    expression_simplifier_t simplifier(get_global_context());
    return simplifier.evaluate_constant(op);
}

bool instructions_equivalent(const minsn_t* a, const minsn_t* b) {
    expression_simplifier_t simplifier(get_global_context());
    return simplifier.are_equivalent(a, b);
}

//--------------------------------------------------------------------------
// constant_optimizer_t implementation
//--------------------------------------------------------------------------
constant_optimizer_t::constant_optimizer_t(z3_context_t& ctx)
    : m_ctx(ctx), m_translator(ctx) {
}

void constant_optimizer_t::count_complexity(const mop_t& op, complexity_t& out) {
    if (op.t == mop_n) {
        out.const_count++;
        return;
    }

    if (op.t == mop_r || op.t == mop_S || op.t == mop_v || op.t == mop_l) {
        out.var_count++;
        return;
    }

    if (op.t == mop_d && op.d) {
        out.op_count++;
        count_complexity(op.d->l, out);
        if (op.d->r.t != mop_z) {
            count_complexity(op.d->r, out);
        }
    }
}

constant_optimizer_t::complexity_t
constant_optimizer_t::analyze_complexity(const minsn_t* ins) {
    complexity_t result = {0, 0, 0};
    if (!ins) return result;

    result.op_count = 1;
    count_complexity(ins->l, result);
    if (ins->r.t != mop_z) {
        count_complexity(ins->r, result);
    }
    return result;
}

constant_optimizer_t::complexity_t
constant_optimizer_t::analyze_complexity(const mop_t& op) {
    complexity_t result = {0, 0, 0};
    count_complexity(op, result);
    return result;
}

std::optional<uint64_t> constant_optimizer_t::quick_eval(const z3::expr& expr, int bits) {
    try {
        // Collect all variables in the expression
        std::set<std::string> var_names;
        // Z3 doesn't have a direct way to get free variables, so we use evaluation

        z3::context& ctx = m_ctx.ctx();

        // Test with x = 0 for all variables
        z3::model model1(ctx);

        // Create a solver to get a model with 0s
        z3::solver solver1(ctx);
        // Build constraints: all free vars = 0

        // Simplified: just evaluate directly with simplify
        z3::expr e0 = expr.simplify();

        // If it simplifies to a constant, return it
        if (e0.is_numeral()) {
            return e0.get_numeral_uint64();
        }

        // Otherwise, can't quick-evaluate
        return std::nullopt;

    } catch (z3::exception&) {
        return std::nullopt;
    }
}

bool constant_optimizer_t::z3_verify_constant(const z3::expr& expr, uint64_t expected, int bits) {
    try {
        z3::context& ctx = m_ctx.ctx();
        z3::solver& solver = m_ctx.solver();

        solver.reset();

        // Check if expr can ever NOT equal expected
        z3::expr expected_val = ctx.bv_val(expected, bits);
        solver.add(expr != expected_val);

        // If unsatisfiable, expr is always equal to expected
        return solver.check() == z3::unsat;

    } catch (z3::exception&) {
        return false;
    }
}

constant_optimizer_t::const_result_t
constant_optimizer_t::analyze(const minsn_t* ins, const config_t& cfg) {
    const_result_t result;
    if (!ins) return result;

    // Check complexity threshold
    auto complexity = analyze_complexity(ins);
    if (complexity.op_count < cfg.min_opcodes) {
        return result;  // Not complex enough to be obfuscated
    }

    int bits = ins->d.size * 8;
    if (bits == 0) bits = 64;

    try {
        m_ctx.set_timeout(cfg.timeout_ms);
        z3::expr e = m_translator.translate_insn(ins);

        // Quick eval first
        auto quick_result = quick_eval(e, bits);
        if (quick_result.has_value()) {
            result.is_constant = true;
            result.value = *quick_result;
            result.bit_width = bits;
            result.method = "quick_eval";
            return result;
        }

        // Try Z3 simplification
        z3::expr simplified = e.simplify();
        if (simplified.is_numeral()) {
            result.is_constant = true;
            result.value = simplified.get_numeral_uint64();
            result.bit_width = bits;
            result.method = "z3_simplify";
            return result;
        }

    } catch (z3::exception& e) {
        deobf::log_verbose("[z3] Exception in constant analysis: %s\n", e.msg());
    }

    return result;
}

constant_optimizer_t::const_result_t
constant_optimizer_t::analyze_operand(const mop_t& op, const config_t& cfg) {
    const_result_t result;

    // Direct constant
    if (op.t == mop_n) {
        result.is_constant = true;
        result.value = op.nnn->value;
        result.bit_width = op.size * 8;
        result.method = "direct";
        return result;
    }

    // Sub-instruction
    if (op.t == mop_d && op.d) {
        return analyze(op.d, cfg);
    }

    return result;
}

//--------------------------------------------------------------------------
// predicate_simplifier_t implementation
//--------------------------------------------------------------------------
predicate_simplifier_t::predicate_simplifier_t(z3_context_t& ctx)
    : m_ctx(ctx), m_translator(ctx) {
}

std::optional<bool> predicate_simplifier_t::simplify_setz(const minsn_t* ins) {
    if (!ins || ins->opcode != m_setz)
        return std::nullopt;

    try {
        z3::expr e = m_translator.translate_insn(ins);
        z3::expr simplified = e.simplify();

        if (simplified.is_numeral()) {
            return simplified.get_numeral_uint64() != 0;
        }
    } catch (z3::exception&) {
    }

    return std::nullopt;
}

std::optional<bool> predicate_simplifier_t::simplify_setnz(const minsn_t* ins) {
    if (!ins || ins->opcode != m_setnz)
        return std::nullopt;

    try {
        z3::expr e = m_translator.translate_insn(ins);
        z3::expr simplified = e.simplify();

        if (simplified.is_numeral()) {
            return simplified.get_numeral_uint64() != 0;
        }
    } catch (z3::exception&) {
    }

    return std::nullopt;
}

std::optional<bool> predicate_simplifier_t::simplify_lnot(const minsn_t* ins) {
    if (!ins || ins->opcode != m_lnot)
        return std::nullopt;

    try {
        z3::expr e = m_translator.translate_insn(ins);
        z3::expr simplified = e.simplify();

        if (simplified.is_numeral()) {
            return simplified.get_numeral_uint64() != 0;
        }
    } catch (z3::exception&) {
    }

    return std::nullopt;
}

std::optional<bool> predicate_simplifier_t::check_comparison_constant(
    mcode_t cmp_op, const mop_t& left, const mop_t& right) {

    try {
        z3::expr l = m_translator.translate_operand(left);
        z3::expr r = m_translator.translate_operand(right);

        z3::expr cmp_expr = m_ctx.ctx().bool_val(false);
        switch (cmp_op) {
            case m_setz:  cmp_expr = (l == r); break;
            case m_setnz: cmp_expr = (l != r); break;
            case m_setl:  cmp_expr = (l < r); break;
            case m_setle: cmp_expr = (l <= r); break;
            case m_setg:  cmp_expr = (l > r); break;
            case m_setge: cmp_expr = (l >= r); break;
            case m_setb:  cmp_expr = z3::ult(l, r); break;
            case m_setbe: cmp_expr = z3::ule(l, r); break;
            case m_seta:  cmp_expr = z3::ugt(l, r); break;
            case m_setae: cmp_expr = z3::uge(l, r); break;
            default:
                return std::nullopt;
        }

        z3::expr simplified = cmp_expr.simplify();
        if (simplified.is_true()) return true;
        if (simplified.is_false()) return false;

    } catch (z3::exception&) {
    }

    return std::nullopt;
}

int predicate_simplifier_t::simplify_jcc(const minsn_t* jcc) {
    if (!jcc || !is_mcode_jcond(jcc->opcode))
        return -1;

    try {
        z3::expr cond = m_translator.translate_jcc_condition(jcc);

        // Check if always true
        m_ctx.solver().reset();
        m_ctx.solver().add(!cond);
        if (m_ctx.solver().check() == z3::unsat) {
            return 1;  // Always taken
        }

        // Check if always false
        m_ctx.solver().reset();
        m_ctx.solver().add(cond);
        if (m_ctx.solver().check() == z3::unsat) {
            return 0;  // Never taken
        }

    } catch (z3::exception&) {
    }

    return -1;  // Unknown
}

} // namespace z3_solver

```

`src/deobf/analysis/z3_solver.h`:

```h
#pragma once
#include "../deobf_types.h"
#include <z3++.h>
#include <memory>
#include <unordered_map>
#include <optional>
#include <functional>

//--------------------------------------------------------------------------
// Z3-based Symbolic Solver for Microcode Analysis
//
// Provides comprehensive symbolic execution and constraint solving for:
//   - Control flow deflattening (solving state machine transitions)
//   - Opaque predicate evaluation (determining if conditions are constant)
//   - Constant folding and expression simplification
//   - Path constraint solving
//
// Design principles:
//   - Lazy symbol creation: only create Z3 variables when needed
//   - Efficient caching: memoize translations and solutions
//   - Sound analysis: never produce incorrect results (may be incomplete)
//   - Timeout-bounded: configurable limits to prevent infinite analysis
//--------------------------------------------------------------------------

namespace z3_solver {

//--------------------------------------------------------------------------
// Forward declarations
//--------------------------------------------------------------------------
class symbolic_state_t;
class path_constraint_t;

//--------------------------------------------------------------------------
// Result of satisfiability check
//--------------------------------------------------------------------------
enum class sat_result_t {
    SAT,            // Satisfiable - found a model
    UNSAT,          // Unsatisfiable - no solution exists
    UNKNOWN,        // Unknown - solver timed out or hit limits
};

//--------------------------------------------------------------------------
// Result of constant evaluation
//--------------------------------------------------------------------------
struct eval_result_t {
    bool is_constant;       // True if expression evaluates to a constant
    uint64_t value;         // The constant value (valid if is_constant)
    int bit_width;          // Bit width of the result

    eval_result_t() : is_constant(false), value(0), bit_width(64) {}
    eval_result_t(uint64_t v, int w) : is_constant(true), value(v), bit_width(w) {}
    static eval_result_t unknown() { return eval_result_t(); }
    static eval_result_t constant(uint64_t v, int w = 64) { return eval_result_t(v, w); }
};

//--------------------------------------------------------------------------
// Z3 Context wrapper - manages Z3 context lifetime
//--------------------------------------------------------------------------
class z3_context_t {
public:
    z3_context_t();
    ~z3_context_t();

    z3::context& ctx() { return m_ctx; }
    z3::solver& solver() { return m_solver; }

    // Reset solver state (keeps context)
    void reset();

    // Set timeout in milliseconds (0 = no timeout)
    void set_timeout(unsigned ms);

private:
    z3::context m_ctx;
    z3::solver m_solver;
};

//--------------------------------------------------------------------------
// Symbolic Variable - represents a microcode variable symbolically
//--------------------------------------------------------------------------
class symbolic_var_t {
public:
    enum var_kind_t {
        VAR_REGISTER,       // Machine register (mreg_t)
        VAR_STACK,          // Stack variable (stkvar)
        VAR_GLOBAL,         // Global variable (ea_t)
        VAR_LOCAL,          // Local variable (lvar)
        VAR_TEMP,           // Temporary expression
        VAR_MEMORY,         // Memory location
    };

    symbolic_var_t() : m_kind(VAR_TEMP), m_id(0), m_size(0) {}
    symbolic_var_t(var_kind_t kind, uint64_t id, int size)
        : m_kind(kind), m_id(id), m_size(size) {}

    var_kind_t kind() const { return m_kind; }
    uint64_t id() const { return m_id; }
    int size() const { return m_size; }

    bool operator==(const symbolic_var_t& other) const {
        return m_kind == other.m_kind && m_id == other.m_id && m_size == other.m_size;
    }

    // Hash function for use in unordered_map
    struct hash_t {
        size_t operator()(const symbolic_var_t& v) const {
            return std::hash<int>()(v.m_kind) ^
                   (std::hash<uint64_t>()(v.m_id) << 1) ^
                   (std::hash<int>()(v.m_size) << 2);
        }
    };

private:
    var_kind_t m_kind;
    uint64_t m_id;      // Register number, stack offset, global address, etc.
    int m_size;         // Size in bytes
};

//--------------------------------------------------------------------------
// Microcode to Z3 Translator
//
// Converts IDA Hex-Rays microcode instructions and operands to Z3
// bitvector expressions for symbolic analysis.
//--------------------------------------------------------------------------
class mcode_translator_t {
public:
    explicit mcode_translator_t(z3_context_t& ctx);

    // Translate a microcode operand to Z3 expression
    z3::expr translate_operand(const mop_t& op, int default_size = 4);

    // Translate a microcode instruction to Z3 expression
    z3::expr translate_insn(const minsn_t* ins);

    // Translate a comparison instruction to Z3 boolean expression
    z3::expr translate_comparison(const minsn_t* ins);

    // Translate a conditional jump condition
    z3::expr translate_jcc_condition(const minsn_t* jcc);

    // Create a fresh symbolic variable for an operand
    z3::expr make_symbolic(const mop_t& op);
    z3::expr make_symbolic(const symbolic_var_t& var);

    // Create a constant bitvector
    z3::expr make_const(uint64_t value, int bits);

    // Get or create a variable for the given operand
    z3::expr get_or_create_var(const mop_t& op);

    // Set known value for a variable (from binary analysis)
    void set_known_value(const symbolic_var_t& var, uint64_t value);
    void set_known_value(const mop_t& op, uint64_t value);

    // Clear state (but keep context)
    void reset();

    // Get current context
    z3_context_t& context() { return m_ctx; }

private:
    // Convert mop_t to symbolic_var_t
    symbolic_var_t mop_to_var(const mop_t& op);

    // Size-aware operations
    z3::expr zero_extend(const z3::expr& e, int to_bits);
    z3::expr sign_extend(const z3::expr& e, int to_bits);
    z3::expr extract(const z3::expr& e, int high, int low);
    z3::expr resize(const z3::expr& e, int to_bits, bool sign_extend = false);

    z3_context_t& m_ctx;

    // Cache of variable -> Z3 expression mappings (using shared_ptr for non-default-constructible z3::expr)
    std::unordered_map<symbolic_var_t, std::shared_ptr<z3::expr>, symbolic_var_t::hash_t> m_var_cache;

    // Known constant values (from reading binary)
    std::unordered_map<symbolic_var_t, uint64_t, symbolic_var_t::hash_t> m_known_values;

    // Counter for fresh variable names
    int m_fresh_counter;
};

//--------------------------------------------------------------------------
// Symbolic Executor
//
// Performs symbolic execution over microcode blocks to track state
// variable values and build path constraints.
//--------------------------------------------------------------------------
class symbolic_executor_t {
public:
    explicit symbolic_executor_t(z3_context_t& ctx);

    // Execute a single instruction symbolically
    void execute_insn(const minsn_t* ins);

    // Execute an entire block symbolically
    void execute_block(const mblock_t* blk);

    // Get symbolic value of a variable after execution
    std::optional<z3::expr> get_value(const mop_t& op);
    std::optional<z3::expr> get_value(const symbolic_var_t& var);

    // Add a path constraint (branch condition that must be true)
    void add_constraint(const z3::expr& constraint);

    // Check if current path is feasible
    sat_result_t check_path_feasibility();

    // Try to solve for a specific variable value
    std::optional<uint64_t> solve_for_value(const mop_t& op);
    std::optional<uint64_t> solve_for_value(const z3::expr& expr);

    // Get all possible values for a variable (bounded enumeration)
    std::vector<uint64_t> enumerate_values(const mop_t& op, int max_count = 100);

    // Clone current state for branching
    std::unique_ptr<symbolic_executor_t> clone() const;

    // Reset to initial state
    void reset();

    // Access translator for direct Z3 manipulation
    mcode_translator_t& translator() { return m_translator; }

private:
    // Handle assignment instructions
    void handle_assignment(const minsn_t* ins);

    // Handle memory operations
    void handle_load(const minsn_t* ins);
    void handle_store(const minsn_t* ins);

    z3_context_t& m_ctx;
    mcode_translator_t m_translator;

    // Current symbolic state: variable -> expression (using shared_ptr)
    std::unordered_map<symbolic_var_t, std::shared_ptr<z3::expr>, symbolic_var_t::hash_t> m_state;

    // Path constraints accumulated during execution
    std::vector<std::shared_ptr<z3::expr>> m_constraints;
};

//--------------------------------------------------------------------------
// State Machine Solver
//
// Specialized solver for control flow flattening. Analyzes the state
// variable transitions to determine the original CFG.
//--------------------------------------------------------------------------
class state_machine_solver_t {
public:
    explicit state_machine_solver_t(z3_context_t& ctx);

    // Analyze a potential dispatcher block
    struct dispatcher_analysis_t {
        bool is_dispatcher;
        int block_idx;
        symbolic_var_t state_var;
        std::map<uint64_t, int> state_to_block;  // state value -> target block
    };
    dispatcher_analysis_t analyze_dispatcher(mbl_array_t* mba, int block_idx);

    // Analyze a case block to determine its successor
    struct block_transition_t {
        int from_block;
        int to_block;              // -1 if conditional
        int to_block_true;         // For conditional transitions
        int to_block_false;        // For conditional transitions
        uint64_t next_state;       // State value written
        bool is_conditional;
        std::shared_ptr<z3::expr> condition;  // Branch condition (for conditional)
        bool solved;               // True if successfully analyzed

        block_transition_t() : from_block(-1), to_block(-1), to_block_true(-1),
                               to_block_false(-1), next_state(0), is_conditional(false),
                               solved(false) {}
    };
    block_transition_t analyze_block_transition(mbl_array_t* mba, int block_idx,
                                                 const symbolic_var_t& state_var);

    // Solve the complete state machine
    struct state_machine_t {
        std::vector<dispatcher_analysis_t> dispatchers;
        std::vector<block_transition_t> transitions;
        std::map<int, std::vector<int>> block_successors;  // Original CFG edges
        bool solved;
    };
    state_machine_t solve_state_machine(mbl_array_t* mba);

    // Given initial state, determine which block will execute
    std::optional<int> resolve_state_to_block(uint64_t state_value);

private:
    // Find all Hikari-style state constants in a block
    std::set<uint64_t> find_state_constants(const mblock_t* blk);

    // Determine what state value a block writes
    std::optional<uint64_t> determine_written_state(mbl_array_t* mba, int block_idx,
                                                     const symbolic_var_t& state_var);

    z3_context_t& m_ctx;
    mcode_translator_t m_translator;

    // Cached dispatcher analysis results
    std::map<int, dispatcher_analysis_t> m_dispatcher_cache;

    // Resolved state machine
    std::optional<state_machine_t> m_machine;
};

//--------------------------------------------------------------------------
// Opaque Predicate Solver
//
// Uses Z3 to determine if a conditional expression is constant
// (always true or always false).
//--------------------------------------------------------------------------
class opaque_predicate_solver_t {
public:
    explicit opaque_predicate_solver_t(z3_context_t& ctx);

    // Check if a condition is an opaque predicate
    enum predicate_result_t {
        PRED_ALWAYS_TRUE,       // Condition is always true
        PRED_ALWAYS_FALSE,      // Condition is always false
        PRED_UNKNOWN,           // Not determinable (or depends on input)
        PRED_DEPENDS_ON_INPUT,  // Explicitly depends on unknown values
    };
    predicate_result_t analyze_condition(const minsn_t* cond);

    // More detailed analysis with proof
    struct analysis_result_t {
        predicate_result_t result;
        std::string proof_hint;     // Human-readable explanation
        std::shared_ptr<z3::expr> simplified;  // Simplified form of condition

        analysis_result_t() : result(PRED_UNKNOWN) {}
    };
    analysis_result_t analyze_detailed(const minsn_t* cond);

    // Check common opaque predicate patterns
    bool is_xy_even_pattern(const minsn_t* ins);     // x * (x + 1) is always even
    bool is_tautology_pattern(const minsn_t* ins);    // x < 10 || x >= 10
    bool is_modular_pattern(const minsn_t* ins);      // (x^2 - 1) % 8 patterns

private:
    z3_context_t& m_ctx;
    mcode_translator_t m_translator;
};

//--------------------------------------------------------------------------
// Expression Simplifier
//
// Uses Z3 to simplify complex expressions to canonical form.
//--------------------------------------------------------------------------
class expression_simplifier_t {
public:
    explicit expression_simplifier_t(z3_context_t& ctx);

    // Simplify an expression
    z3::expr simplify(const z3::expr& expr);

    // Evaluate to constant if possible
    eval_result_t evaluate_constant(const minsn_t* ins);
    eval_result_t evaluate_constant(const mop_t& op);

    // Check if two expressions are equivalent
    bool are_equivalent(const z3::expr& a, const z3::expr& b);
    bool are_equivalent(const minsn_t* a, const minsn_t* b);

private:
    z3_context_t& m_ctx;
    mcode_translator_t m_translator;
};

//--------------------------------------------------------------------------
// Z3 Constant Optimizer
//
// Detects if complex expressions are actually obfuscated constants.
// Uses quick evaluation with test values, then Z3 verification.
//--------------------------------------------------------------------------
class constant_optimizer_t {
public:
    explicit constant_optimizer_t(z3_context_t& ctx);

    // Configuration
    struct config_t {
        int min_opcodes;         // Minimum operations in expression
        int min_constants;       // Minimum constant leaves
        unsigned timeout_ms;     // Z3 timeout

        config_t() : min_opcodes(3), min_constants(3), timeout_ms(1000) {}
    };

    // Result of constant analysis
    struct const_result_t {
        bool is_constant;
        uint64_t value;
        int bit_width;
        std::string method;      // How it was determined

        const_result_t() : is_constant(false), value(0), bit_width(0) {}
        const_result_t(uint64_t v, int w, const char* m)
            : is_constant(true), value(v), bit_width(w), method(m) {}
    };

    // Analyze if instruction result is a constant
    const_result_t analyze(const minsn_t* ins, const config_t& cfg = config_t());

    // Analyze if operand is a constant
    const_result_t analyze_operand(const mop_t& op, const config_t& cfg = config_t());

    // Quick evaluation with test values (0 and -1)
    // Returns constant if both test values give same result
    std::optional<uint64_t> quick_eval(const z3::expr& expr, int bits);

    // Verify with Z3 that expression is constant
    bool z3_verify_constant(const z3::expr& expr, uint64_t expected, int bits);

    // Count operations and constants in expression
    struct complexity_t {
        int op_count;
        int const_count;
        int var_count;
    };
    complexity_t analyze_complexity(const minsn_t* ins);
    complexity_t analyze_complexity(const mop_t& op);

private:
    void count_complexity(const mop_t& op, complexity_t& out);

    z3_context_t& m_ctx;
    mcode_translator_t m_translator;
};

//--------------------------------------------------------------------------
// Z3 Predicate Simplifier
//
// Simplifies set/comparison instructions that evaluate to constants.
//--------------------------------------------------------------------------
class predicate_simplifier_t {
public:
    explicit predicate_simplifier_t(z3_context_t& ctx);

    // Check if setz/setnz result is constant
    std::optional<bool> simplify_setz(const minsn_t* ins);
    std::optional<bool> simplify_setnz(const minsn_t* ins);
    std::optional<bool> simplify_lnot(const minsn_t* ins);

    // Check if comparison is always true/false
    std::optional<bool> check_comparison_constant(mcode_t cmp_op,
                                                   const mop_t& left,
                                                   const mop_t& right);

    // Simplify conditional jump
    // Returns: 1 = always taken, 0 = never taken, -1 = unknown
    int simplify_jcc(const minsn_t* jcc);

private:
    z3_context_t& m_ctx;
    mcode_translator_t m_translator;
};

//--------------------------------------------------------------------------
// Global Z3 context management
//--------------------------------------------------------------------------

// Get the global Z3 context (lazy initialization)
z3_context_t& get_global_context();

// Reset global context (call between functions)
void reset_global_context();

// Set global timeout (milliseconds)
void set_global_timeout(unsigned ms);

//--------------------------------------------------------------------------
// Convenience functions
//--------------------------------------------------------------------------

// Quick check if condition is constant
std::optional<bool> is_condition_constant(const minsn_t* cond);

// Quick evaluate expression to constant
eval_result_t evaluate_to_constant(const minsn_t* ins);
eval_result_t evaluate_to_constant(const mop_t& op);

// Check if two instructions produce same result
bool instructions_equivalent(const minsn_t* a, const minsn_t* b);

} // namespace z3_solver

```

`src/deobf/deobf_main.cpp`:

```cpp
#include "deobf_main.h"
#include "analysis/pattern_match.h"
#include "analysis/expr_simplify.h"
#include "analysis/cfg_analysis.h"
#include "analysis/opaque_eval.h"
#include "analysis/stack_tracker.h"
#include "handlers/deflatten.h"
#include "handlers/bogus_cf.h"
#include "handlers/string_decrypt.h"
#include "handlers/const_decrypt.h"
#include "handlers/indirect_branch.h"
#include "handlers/block_merge.h"
#include "handlers/mba_simplify.h"
#include "handlers/identity_call.h"
#include "handlers/stack_string.h"
#include "handlers/hikari_wrapper.h"
#include "handlers/savedregs.h"
#include "handlers/objc_resolve.h"
#include "handlers/global_const.h"
#include "handlers/ptr_resolve.h"
#include "handlers/indirect_call.h"
#include "handlers/ctree_string_decrypt.h"
#include "analysis/ast_builder.h"
#include "rules/rule_registry.h"

bool chernobog_t::s_active = false;
deobf_ctx_t chernobog_t::s_ctx;

// Forward declaration
static void run_deobfuscation_passes(mbl_array_t *mba, deobf_ctx_t *ctx);

static chernobog_t *g_deobf = nullptr;
static chernobog_optblock_t *g_optblock = nullptr;

// Track functions we've already processed to avoid duplicate analysis
static std::set<ea_t> s_processed_functions;

// Track optblock processed combinations (cleared on refresh)
static std::set<uint64_t> s_optblock_processed;

// Clear tracking for a function to allow re-deobfuscation
void chernobog_clear_function_tracking(ea_t func_ea)
{
    s_processed_functions.erase(func_ea);

    // Clear all maturity combinations for this function from optblock tracking
    for ( int m = 0; m < 16; ++m )
    {
        uint64_t key = ((uint64_t)func_ea << 4) | m;
        s_optblock_processed.erase(key);
    }

    // Clear deferred analysis for all handlers
    deflatten_handler_t::clear_deferred(func_ea);
    identity_call_handler_t::clear_deferred(func_ea);
}

// Clear ALL tracking caches (called on database load if CHERNOBOG_RESET=1)
void chernobog_clear_all_tracking()
{
    s_processed_functions.clear();
    s_optblock_processed.clear();
    deflatten_handler_t::s_deferred_analysis.clear();
    identity_call_handler_t::s_deferred_analysis.clear();
    msg("[chernobog] Cleared all deobfuscation caches\n");
}

//--------------------------------------------------------------------------
// File-based debug logging for optblock
//--------------------------------------------------------------------------
#include "../common/compat.h"

static void optblock_debug(const char *fmt, ...)
{
#ifndef _WIN32
    char buf[4096];
    va_list args;
    va_start(args, fmt);
    int len = qvsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);

    int fd = open("/tmp/optblock_debug.log", O_WRONLY | O_CREAT | O_APPEND, 0644);
    if ( fd >= 0 )
    {
        write(fd, buf, len);
        close(fd);
    }
#else
    (void)fmt;
#endif
}

//--------------------------------------------------------------------------
// Block-level optimizer callback - runs at various maturity levels
//--------------------------------------------------------------------------
int idaapi chernobog_optblock_t::func(mblock_t *blk)
{
    optblock_debug("[optblock] func() called\n");

    // Debug: log every call to see if we're being invoked
    if ( !blk || !blk->mba )
    {
        optblock_debug("[optblock] null blk or mba!\n");
        msg("[optblock] Called with null blk or mba\n");
        return 0;
    }

    int maturity = blk->mba->maturity;
    optblock_debug("[optblock] s_active=%d, entry_ea=%llx, maturity=%d, blk=%d\n",
                   chernobog_t::s_active ? 1 : 0,
                   (unsigned long long)blk->mba->entry_ea,
                   maturity,
                   blk->serial);

    if ( !chernobog_t::s_active )
    {
        // Only log once per function to avoid spam
        static ea_t last_inactive_ea = BADADDR;
        if ( blk->mba->entry_ea != last_inactive_ea )
        {
            last_inactive_ea = blk->mba->entry_ea;
            msg("[optblock] s_active=false, skipping %a\n", blk->mba->entry_ea);
        }
        return 0;
    }

    mbl_array_t *mba = blk->mba;
    ea_t func_ea = mba->entry_ea;
    // maturity already declared above

    // Track which function+maturity combinations we've processed to avoid duplicate work
    // Key: (func_ea << 4) | maturity (assuming maturity < 16)
    // Uses global set that can be cleared to allow re-deobfuscation
    uint64_t key = ((uint64_t)func_ea << 4) | (maturity & 0xF);

    if ( s_optblock_processed.count(key) )
    {
        optblock_debug("[optblock] Already processed key=%llx\n", (unsigned long long)key);
        return 0;
    }
    s_optblock_processed.insert(key);

    optblock_debug("[optblock] NEW processing: maturity=%d, func=%llx\n", maturity, (unsigned long long)func_ea);
    msg("[optblock] Processing %a at maturity %d (blk %d)\n", func_ea, maturity, blk->serial);

    // Run full deobfuscation at maturity 3 (MMAT_LOCOPT) - first opportunity for CFG mods
    if ( maturity == MMAT_LOCOPT )
    {
        optblock_debug("[optblock] Running FULL deobfuscation passes at maturity 3\n");
        deobf_ctx_t full_ctx;
        full_ctx.mba = mba;
        full_ctx.func_ea = func_ea;

        // First detect what obfuscations are present
        full_ctx.detected_obf = chernobog_t::detect_obfuscations(mba);
        optblock_debug("[optblock] Detected obfuscations: 0x%x\n", full_ctx.detected_obf);

        run_deobfuscation_passes(mba, &full_ctx);
        optblock_debug("[optblock] Full deobfuscation complete, changes: blocks=%d, branches=%d, indirect=%d\n",
                       full_ctx.blocks_merged, full_ctx.branches_simplified, full_ctx.indirect_resolved);
    }

    // Two-phase deflattening approach:
    //
    // NOTE: optblock handlers are typically NOT called at maturity 0.
    // IDA only starts invoking optblock at MMAT_LOCOPT (3) and above.
    //
    // So we do both analysis and application at maturity 3 (MMAT_LOCOPT),
    // which is the earliest maturity where optblock is invoked and where
    // the CFG is stable enough for modification.
    //
    // At maturity 3, the state machine patterns are still visible (switch/case
    // with state constants), but the CFG has explicit gotos that can be modified.

    // Process at multiple maturity levels
    // MMAT_LOCOPT (3): CFG modifications (but calls are "unknown" - no mcallinfo)
    // MMAT_CALLS (4): Call info is available - can modify indirect calls
    // MMAT_GLBOPT1 (5): Global constant inlining (addresses resolved)
    if ( maturity != MMAT_LOCOPT && maturity != MMAT_CALLS && maturity != MMAT_GLBOPT1 )
        return 0;

    // At MMAT_CALLS, specifically try to resolve indirect calls
    // This is when mcallinfo is available, making it safe to modify calls
    if ( maturity == MMAT_CALLS )
    {
        if ( indirect_call_handler_t::detect(mba) )
        {
            optblock_debug("[optblock] Running indirect call handler at MMAT_CALLS\n");
            msg("[optblock] Running indirect call deobfuscation at maturity %d (MMAT_CALLS)\n", maturity);
            deobf_ctx_t icall_ctx;
            icall_ctx.mba = mba;
            icall_ctx.func_ea = func_ea;
            int changes = indirect_call_handler_t::run(mba, &icall_ctx);
            if ( changes > 0 )
            {
                msg("[optblock] Resolved %d indirect calls at MMAT_CALLS\n", icall_ctx.indirect_resolved);
                return 1;  // Signal that we made changes
            }
        }
        return 0;
    }

    deobf_ctx_t ctx;
    ctx.mba = mba;
    ctx.func_ea = func_ea;

    int total_changes = 0;

    // Try global constant inlining - works better at later maturity when addresses resolved
    if ( maturity >= MMAT_LOCOPT && global_const_handler_t::detect(mba) )
    {
        msg("[optblock] Detected global constants at maturity %d\n", maturity);
        int changes = global_const_handler_t::run(mba, &ctx);
        if ( changes > 0 )
        {
            msg("[optblock] Global const handler applied %d changes\n", changes);
            total_changes += changes;
        }
    }

    // Check for pending identity call analysis from maturity 0
    if ( identity_call_handler_t::has_pending_analysis(func_ea) )
    {
        msg("[optblock] Applying deferred identity call transformations for %a\n", func_ea);
        int changes = identity_call_handler_t::apply_deferred(mba, &ctx);
        if ( changes > 0 )
        {
            msg("[optblock] Identity call handler applied %d changes\n", changes);
            total_changes += changes;
        }
    }

    // Check if we have pending deflattening analysis from maturity 0
    // The maturity 0 analysis uses block ADDRESSES which are stable across maturities
    if ( deflatten_handler_t::has_pending_analysis(func_ea) )
    {
        msg("[optblock] Applying deferred analysis from maturity 0 for %a\n", func_ea);
        int changes = deflatten_handler_t::apply_deferred(mba, &ctx);
        if ( changes > 0 )
        {
            msg("[optblock] Deflattening applied %d changes from deferred analysis\n", changes);
            total_changes += changes;
        }
        else
        {
            msg("[optblock] Deferred analysis made no changes, trying fresh analysis\n");
            // Fall through to fresh analysis
        }
        // apply_deferred clears the deferred analysis, so we won't try again
        if ( changes > 0 )
            return total_changes;
    }

    // No deferred analysis or it didn't help - try fresh analysis at maturity 3
    if ( !deflatten_handler_t::detect(mba, &ctx) )
    {
        msg("[optblock] No flattening detected at %a\n", func_ea);
        return 0;
    }

    msg("[optblock] Detected flattening at %a, running fresh analysis...\n", func_ea);

    // Run the full deflattening pass
    int changes = deflatten_handler_t::run(mba, &ctx);
    if ( changes > 0 )
    {
        msg("[optblock] Deflattening applied %d changes\n", changes);
    }
    else
    {
        msg("[optblock] Deflattening found patterns but made no changes\n");
    }

    return changes;
}

//--------------------------------------------------------------------------
// Constructor/Destructor
//--------------------------------------------------------------------------
chernobog_t::chernobog_t()
{
}

chernobog_t::~chernobog_t()
{
}

//--------------------------------------------------------------------------
// optinsn_t callback - called during microcode optimization
// This is where we do instruction-level simplification
//--------------------------------------------------------------------------
int idaapi chernobog_t::func(mblock_t *blk, minsn_t *ins, int optflags)
{
    if ( !blk || !ins )
    {
        return 0;
    }

    // Debug: log ldx instructions (opcode 14)
    if ( ins->opcode == m_ldx )
    {
        static int ldx_count = 0;
        if ( ldx_count < 20 )
        {
            ++ldx_count;
            deobf::log_verbose("[optinsn] m_ldx: r.t=%d\n", ins->r.t);
        }
    }

    int changes = 0;

    // Try global constant inlining
    changes += global_const_handler_t::simplify_insn(blk, ins, nullptr);

    // Try MBA simplification on this instruction
    changes += mba_simplify_handler_t::simplify_insn(blk, ins, nullptr);

    return changes;
}

//--------------------------------------------------------------------------
// Main deobfuscation entry point - from mba (used by auto mode)
//--------------------------------------------------------------------------
void chernobog_t::deobfuscate_mba(mbl_array_t *mba)
{
    if ( !mba )
        return;

    deobf::log("[chernobog] Deobfuscating %a (from mba)\n", mba->entry_ea);

    s_ctx = deobf_ctx_t();
    s_ctx.mba = mba;
    s_ctx.func_ea = mba->entry_ea;

    // Run the core deobfuscation logic
    run_deobfuscation_passes(mba, &s_ctx);
}

//--------------------------------------------------------------------------
// Main deobfuscation entry point - from cfunc
//--------------------------------------------------------------------------
void chernobog_t::deobfuscate_function(cfunc_t *cfunc)
{
    if ( !cfunc || !cfunc->mba )
        return;

    deobf::log("[chernobog] Deobfuscating %a\n", cfunc->entry_ea);

    s_ctx = deobf_ctx_t();
    s_ctx.mba = cfunc->mba;
    s_ctx.cfunc = cfunc;
    s_ctx.func_ea = cfunc->entry_ea;

    // Run the core deobfuscation logic
    run_deobfuscation_passes(cfunc->mba, &s_ctx);
}

//--------------------------------------------------------------------------
// Core deobfuscation passes (shared by all entry points)
//--------------------------------------------------------------------------
static void run_deobfuscation_passes(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx )
        return;

    // Detect what obfuscations are present
    ctx->detected_obf = chernobog_t::detect_obfuscations(mba);

    deobf::log("[chernobog] Detected obfuscations: 0x%x\n", ctx->detected_obf);

    if ( ctx->detected_obf & OBF_STRING_ENC )
    {
        deobf::log("[chernobog] - String encryption detected\n");
    }
    if ( ctx->detected_obf & OBF_CONST_ENC )
    {
        deobf::log("[chernobog] - Constant encryption detected\n");
    }
    if ( ctx->detected_obf & OBF_FLATTENED )
    {
        deobf::log("[chernobog] - Control flow flattening detected\n");
    }
    if ( ctx->detected_obf & OBF_BOGUS_CF )
    {
        deobf::log("[chernobog] - Bogus control flow detected\n");
    }
    if ( ctx->detected_obf & OBF_INDIRECT_BR )
    {
        deobf::log("[chernobog] - Indirect branches detected\n");
    }
    if ( ctx->detected_obf & OBF_SUBSTITUTION )
    {
        deobf::log("[chernobog] - Instruction substitution detected\n");
    }
    if ( ctx->detected_obf & OBF_SAVEDREGS )
    {
        deobf::log("[chernobog] - Register demotion (savedregs) detected\n");
    }
    if ( ctx->detected_obf & OBF_OBJC_OBFUSC )
    {
        deobf::log("[chernobog] - Obfuscated ObjC calls detected\n");
    }
    if ( ctx->detected_obf & OBF_GLOBAL_CONST )
    {
        deobf::log("[chernobog] - Global constants detected\n");
    }
    if ( ctx->detected_obf & OBF_PTR_INDIRECT )
    {
        deobf::log("[chernobog] - Indirect pointer references detected\n");
    }
    if ( ctx->detected_obf & OBF_INDIRECT_CALL )
    {
        deobf::log("[chernobog] - Indirect call obfuscation detected\n");
    }

    // Initialize stack tracker for virtual stack analysis
    stack_tracker_t::analyze_function(mba);

    // Apply deobfuscation passes in order
    int total_changes = 0;

    // 1. First merge split blocks (simplest transformation)
    if ( ctx->detected_obf & OBF_SPLIT_BLOCKS )
    {
        total_changes += chernobog_t::merge_blocks(mba, ctx);
    }

    // 2. Decrypt strings
    if ( ctx->detected_obf & OBF_STRING_ENC )
    {
        total_changes += chernobog_t::decrypt_strings(mba, ctx);
    }

    // 2.5. Reconstruct stack strings
    if ( ctx->detected_obf & OBF_STACK_STRING )
    {
        total_changes += stack_string_handler_t::run(mba, ctx);
    }

    // 3. Decrypt constants
    if ( ctx->detected_obf & OBF_CONST_ENC )
    {
        total_changes += chernobog_t::decrypt_consts(mba, ctx);
    }

    // 3.5. Inline global constants
    if ( ctx->detected_obf & OBF_GLOBAL_CONST )
    {
        total_changes += global_const_handler_t::run(mba, ctx);
    }

    // 3.6. Resolve indirect pointer references
    if ( ctx->detected_obf & OBF_PTR_INDIRECT )
    {
        total_changes += ptr_resolve_handler_t::run(mba, ctx);
    }

    // 4. Simplify substituted expressions
    if ( ctx->detected_obf & OBF_SUBSTITUTION )
    {
        total_changes += chernobog_t::simplify_substitutions(mba, ctx);
    }

    // 5. Resolve indirect branches
    if ( ctx->detected_obf & OBF_INDIRECT_BR )
    {
        total_changes += chernobog_t::resolve_indirect_branches(mba, ctx);
    }

    // 5.1. Resolve indirect calls (Hikari IndirectCall obfuscation)
    if ( ctx->detected_obf & OBF_INDIRECT_CALL )
    {
        total_changes += indirect_call_handler_t::run(mba, ctx);
    }

    // 5.5. Resolve identity function calls
    if ( ctx->detected_obf & OBF_IDENTITY_CALL )
    {
        total_changes += identity_call_handler_t::run(mba, ctx);
    }

    // 5.6. Resolve Hikari function wrappers
    if ( ctx->detected_obf & OBF_FUNC_WRAPPER )
    {
        total_changes += hikari_wrapper_handler_t::run(mba, ctx);
    }

    // 5.7. Resolve savedregs (register demotion) patterns
    if ( ctx->detected_obf & OBF_SAVEDREGS )
    {
        total_changes += savedregs_handler_t::run(mba, ctx);
    }

    // 5.8. Resolve obfuscated ObjC method calls
    if ( ctx->detected_obf & OBF_OBJC_OBFUSC )
    {
        total_changes += objc_resolve_handler_t::run(mba, ctx);
    }

    // 6. Remove bogus control flow
    if ( ctx->detected_obf & OBF_BOGUS_CF )
    {
        total_changes += chernobog_t::remove_bogus_cf(mba, ctx);
    }

    // 7. Deflatten control flow (most complex, do last)
    if ( ctx->detected_obf & OBF_FLATTENED )
    {
        total_changes += chernobog_t::deflatten(mba, ctx);
    }

    // 8. Ctree-level string analysis (runs on cfunc if available)
    if ( ctx->cfunc )
    {
        int str_changes = ctree_string_decrypt_handler_t::run(ctx->cfunc, ctx);
        if ( str_changes > 0 )
        {
            total_changes += str_changes;
            deobf::log("[chernobog] Ctree string analysis: %d strings found\n", str_changes);
        }
    }

    deobf::log("[chernobog] Deobfuscation complete. Total changes: %d\n", total_changes);
    deobf::log("[chernobog]   Blocks merged: %d\n", ctx->blocks_merged);
    deobf::log("[chernobog]   Branches simplified: %d\n", ctx->branches_simplified);
    deobf::log("[chernobog]   Strings decrypted: %d\n", ctx->strings_decrypted);
    deobf::log("[chernobog]   Constants decrypted: %d\n", ctx->consts_decrypted);
    deobf::log("[chernobog]   Expressions simplified: %d\n", ctx->expressions_simplified);
    deobf::log("[chernobog]   Indirect calls resolved: %d\n", ctx->indirect_resolved);
}

//--------------------------------------------------------------------------
// Deobfuscate by address
//--------------------------------------------------------------------------
void chernobog_t::deobfuscate_function(ea_t ea)
{
    func_t *func = get_func(ea);
    if ( !func )
    {
        deobf::log("[chernobog] No function at %a\n", ea);
        return;
    }

    hexrays_failure_t hf;
    cfuncptr_t cfunc = decompile(func, &hf, DECOMP_NO_CACHE);
    if ( !cfunc )
    {
        deobf::log("[chernobog] Failed to decompile %a: %s\n", ea, hf.desc().c_str());
        return;
    }

    deobfuscate_function(cfunc);
}

//--------------------------------------------------------------------------
// Analyze function without modifying
//--------------------------------------------------------------------------
void chernobog_t::analyze_function(ea_t ea)
{
    func_t *func = get_func(ea);
    if ( !func )
    {
        deobf::log("[chernobog] No function at %a\n", ea);
        return;
    }

    hexrays_failure_t hf;
    cfuncptr_t cfunc = decompile(func, &hf, DECOMP_NO_CACHE);
    if ( !cfunc )
    {
        deobf::log("[chernobog] Failed to decompile %a: %s\n", ea, hf.desc().c_str());
        return;
    }

    deobf_ctx_t ctx;
    ctx.mba = cfunc->mba;
    ctx.cfunc = cfunc;
    ctx.func_ea = ea;

    uint32_t obf = detect_obfuscations(cfunc->mba);

    msg("[chernobog] Analysis of %a:\n", ea);
    msg("  Detected obfuscations: 0x%x\n", obf);

    if ( obf & OBF_FLATTENED ) msg("  - Control flow flattening\n");
    if ( obf & OBF_BOGUS_CF ) msg("  - Bogus control flow\n");
    if ( obf & OBF_STRING_ENC ) msg("  - String encryption\n");
    if ( obf & OBF_CONST_ENC ) msg("  - Constant encryption\n");
    if ( obf & OBF_INDIRECT_BR ) msg("  - Indirect branches\n");
    if ( obf & OBF_SUBSTITUTION ) msg("  - Instruction substitution\n");
    if ( obf & OBF_SPLIT_BLOCKS ) msg("  - Split basic blocks\n");
    if ( obf & OBF_FUNC_WRAPPER ) msg("  - Hikari function wrappers\n");
    if ( obf & OBF_IDENTITY_CALL ) msg("  - Identity function call obfuscation\n");
    if ( obf & OBF_STACK_STRING ) msg("  - Stack string construction\n");
    if ( obf & OBF_SAVEDREGS ) msg("  - Register demotion (savedregs patterns)\n");
    if ( obf & OBF_OBJC_OBFUSC ) msg("  - Obfuscated ObjC method calls\n");
    if ( obf & OBF_GLOBAL_CONST ) msg("  - Inlinable global constants\n");
    if ( obf & OBF_PTR_INDIRECT ) msg("  - Indirect pointer references\n");
    if ( obf & OBF_INDIRECT_CALL ) msg("  - Indirect call obfuscation (Hikari)\n");
    if ( obf == OBF_NONE ) msg("  - No obfuscation detected\n");
}

//--------------------------------------------------------------------------
// Detection functions
//--------------------------------------------------------------------------
uint32_t chernobog_t::detect_obfuscations(mbl_array_t *mba)
{
    if ( !mba )
        return OBF_NONE;

    uint32_t detected = OBF_NONE;
    deobf_ctx_t ctx;
    ctx.mba = mba;

    // Check for control flow flattening
    if ( is_flattened(mba, &ctx) )
        detected |= OBF_FLATTENED;

    // Check for bogus control flow
    if ( has_bogus_cf(mba, &ctx) )
        detected |= OBF_BOGUS_CF;

    // Check for encrypted constants (XOR patterns)
    if ( has_encrypted_consts(mba) )
        detected |= OBF_CONST_ENC;

    // Check for indirect branches
    if ( has_indirect_branches(mba) )
        detected |= OBF_INDIRECT_BR;

    // Check for instruction substitution / MBA obfuscation patterns
    if ( mba_simplify_handler_t::detect(mba) )
        detected |= OBF_SUBSTITUTION;

    // Check for split blocks (many small blocks with unconditional jumps)
    if ( block_merge_handler_t::detect_split_blocks(mba) )
        detected |= OBF_SPLIT_BLOCKS;

    // Check for identity function call obfuscation
    if ( identity_call_handler_t::detect(mba) )
        detected |= OBF_IDENTITY_CALL;

    // Check for stack string construction
    if ( stack_string_handler_t::detect(mba) )
        detected |= OBF_STACK_STRING;

    // Check for Hikari function wrappers
    if ( hikari_wrapper_handler_t::detect(mba) )
        detected |= OBF_FUNC_WRAPPER;

    // Check for savedregs (register demotion) patterns
    if ( savedregs_handler_t::detect(mba) )
        detected |= OBF_SAVEDREGS;

    // Check for obfuscated ObjC method calls
    if ( objc_resolve_handler_t::detect(mba) )
        detected |= OBF_OBJC_OBFUSC;

    // Check for inlinable global constants
    if ( global_const_handler_t::detect(mba) )
        detected |= OBF_GLOBAL_CONST;

    // Check for indirect pointer references
    if ( ptr_resolve_handler_t::detect(mba) )
        detected |= OBF_PTR_INDIRECT;

    // Check for indirect call obfuscation (Hikari IndirectCall)
    if ( indirect_call_handler_t::detect(mba) )
        detected |= OBF_INDIRECT_CALL;

    return detected;
}

bool chernobog_t::is_flattened(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    return deflatten_handler_t::detect(mba, ctx);
}

bool chernobog_t::has_bogus_cf(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    return bogus_cf_handler_t::detect(mba, ctx);
}

bool chernobog_t::has_encrypted_strings(ea_t func_ea)
{
    return string_decrypt_handler_t::detect(func_ea);
}

bool chernobog_t::has_encrypted_consts(mbl_array_t *mba)
{
    return const_decrypt_handler_t::detect(mba);
}

bool chernobog_t::has_indirect_branches(mbl_array_t *mba)
{
    return indirect_branch_handler_t::detect(mba);
}

//--------------------------------------------------------------------------
// Deobfuscation pass wrappers
//--------------------------------------------------------------------------
int chernobog_t::deflatten(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    return deflatten_handler_t::run(mba, ctx);
}

int chernobog_t::remove_bogus_cf(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    return bogus_cf_handler_t::run(mba, ctx);
}

int chernobog_t::decrypt_strings(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    return string_decrypt_handler_t::run(mba, ctx);
}

int chernobog_t::decrypt_consts(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    return const_decrypt_handler_t::run(mba, ctx);
}

int chernobog_t::resolve_indirect_branches(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    return indirect_branch_handler_t::run(mba, ctx);
}

int chernobog_t::merge_blocks(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    return block_merge_handler_t::run(mba, ctx);
}

int chernobog_t::simplify_substitutions(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    return mba_simplify_handler_t::run(mba, ctx);
}

//--------------------------------------------------------------------------
// Component registration
//--------------------------------------------------------------------------
bool deobf_avail()
{
    // Available on all platforms with Hex-Rays
    return true;
}

bool deobf_active()
{
    return chernobog_t::s_active;
}

void deobf_init()
{
    // Initialize MBA simplification (pattern matching rules)
    mba_simplify_handler_t::initialize();

    // Install instruction-level optimizer
    g_deobf = new chernobog_t();
    install_optinsn_handler(g_deobf);

    // Install block-level optimizer for CFG modifications (deflattening)
    g_optblock = new chernobog_optblock_t();
    install_optblock_handler(g_optblock);

    chernobog_t::s_active = true;
    msg("[chernobog] Deobfuscator initialized (optinsn + optblock handlers, s_active=true)\n");
}

void deobf_done()
{
    chernobog_t::s_active = false;

    // Remove instruction-level optimizer
    if ( g_deobf )
    {
        remove_optinsn_handler(g_deobf);
        delete g_deobf;
        g_deobf = nullptr;
    }

    // Remove block-level optimizer
    if ( g_optblock )
    {
        remove_optblock_handler(g_optblock);
        delete g_optblock;
        g_optblock = nullptr;
    }

    // Clear any pending analysis
    deflatten_handler_t::s_deferred_analysis.clear();
    s_processed_functions.clear();

    // Clear AST caches (the RuleRegistry singleton intentionally leaks
    // on exit to avoid crashes during static destruction)
    chernobog::ast::clear_ast_caches();
    // NOTE: Do NOT call RuleRegistry::instance().clear() here!
    // The RuleRegistry singleton intentionally leaks to avoid crashes from
    // mop_t destructors calling IDA functions that are unavailable at shutdown.

    deobf::log("[chernobog] Deobfuscator terminated\n");
}

//--------------------------------------------------------------------------
// Action handlers for popup menu
//--------------------------------------------------------------------------
struct deobf_action_handler_t : public action_handler_t
{
    int (*action_func)(vdui_t *);

    deobf_action_handler_t(int (*f)(vdui_t *)) : action_func(f) {}

    virtual int idaapi activate(action_activation_ctx_t *ctx) override
    {
        // Check if hexrays is available before using its API
        if ( !get_hexdsp() )
            return 0;
        vdui_t *vu = get_widget_vdui(ctx->widget);
        if ( vu )
            return action_func(vu);
        return 0;
    }

    virtual action_state_t idaapi update(action_update_ctx_t *ctx) override
    {
        // Check if hexrays is available before using its API
        if ( !get_hexdsp() )
            return AST_DISABLE_FOR_WIDGET;
        if ( !ctx || !ctx->widget )
            return AST_DISABLE_FOR_WIDGET;
        vdui_t *vu = get_widget_vdui(ctx->widget);
        return vu ? AST_ENABLE_FOR_WIDGET : AST_DISABLE_FOR_WIDGET;
    }
};

static int do_deobfuscate(vdui_t *vu)
{
    if ( !vu || !vu->cfunc )
        return 0;

    chernobog_t::deobfuscate_function(vu->cfunc);
    vu->refresh_view(true);
    return 1;
}

static int do_analyze(vdui_t *vu)
{
    if ( !vu || !vu->cfunc )
        return 0;

    chernobog_t::analyze_function(vu->cfunc->entry_ea);
    return 1;
}

static deobf_action_handler_t ah_deobf(do_deobfuscate);
static deobf_action_handler_t ah_analyze(do_analyze);

static const action_desc_t actions[] = {
    ACTION_DESC_LITERAL("chernobog:deobfuscate", "Deobfuscate (Chernobog)", &ah_deobf, "Ctrl+Shift+D", nullptr, -1),
    ACTION_DESC_LITERAL("chernobog:analyze", "Analyze obfuscation (Chernobog)", &ah_analyze, "Ctrl+Shift+A", nullptr, -1),
};

void deobf_attach_popup(TWidget *widget, TPopupMenu *popup, vdui_t *vu)
{
    if ( !vu )
        return;

    for ( const auto &act : actions )
    {
        attach_action_to_popup(widget, popup, act.name);
    }
}

// Register actions on init
static struct action_registrar_t
{
    action_registrar_t()
    {
        for ( const auto &act : actions )
        {
            register_action(act);
        }
    }
    ~action_registrar_t()
    {
        for ( const auto &act : actions )
        {
            unregister_action(act.name);
        }
    }
} g_action_registrar;

// Register component
REGISTER_COMPONENT(
    deobf_avail,
    deobf_active,
    deobf_init,
    deobf_done,
    deobf_attach_popup,
    "Chernobog",
    chernobog,
    chernobog
)

```

`src/deobf/deobf_main.h`:

```h
#pragma once
#include "deobf_types.h"
#include "../plugin/component_registry.h"

//--------------------------------------------------------------------------
// Main deobfuscator class - Hex-Rays optimizer callback (instruction level)
//--------------------------------------------------------------------------
class chernobog_t : public optinsn_t {
public:
    chernobog_t();
    virtual ~chernobog_t();

    // optinsn_t interface - called for each instruction during optimization
    virtual int idaapi func(mblock_t *blk, minsn_t *ins, int optflags) override;

    // Main entry points
    static void deobfuscate_function(cfunc_t *cfunc);
    static void deobfuscate_function(ea_t ea);
    static void deobfuscate_mba(mbl_array_t *mba);
    static void analyze_function(ea_t ea);

    // Detection
    static uint32_t detect_obfuscations(mbl_array_t *mba);
    static bool is_flattened(mbl_array_t *mba, deobf_ctx_t *ctx);
    static bool has_bogus_cf(mbl_array_t *mba, deobf_ctx_t *ctx);
    static bool has_encrypted_strings(ea_t func_ea);
    static bool has_encrypted_consts(mbl_array_t *mba);
    static bool has_indirect_branches(mbl_array_t *mba);

    // Deobfuscation passes
    static int deflatten(mbl_array_t *mba, deobf_ctx_t *ctx);
    static int remove_bogus_cf(mbl_array_t *mba, deobf_ctx_t *ctx);
    static int decrypt_strings(mbl_array_t *mba, deobf_ctx_t *ctx);
    static int decrypt_consts(mbl_array_t *mba, deobf_ctx_t *ctx);
    static int resolve_indirect_branches(mbl_array_t *mba, deobf_ctx_t *ctx);
    static int merge_blocks(mbl_array_t *mba, deobf_ctx_t *ctx);
    static int simplify_substitutions(mbl_array_t *mba, deobf_ctx_t *ctx);

public:
    static bool s_active;
    static deobf_ctx_t s_ctx;
};

//--------------------------------------------------------------------------
// Block-level optimizer for CFG modifications (e.g., deflattening)
// This runs at different maturity levels during microcode optimization
//--------------------------------------------------------------------------
class chernobog_optblock_t : public optblock_t {
public:
    // optblock_t interface - called for each block during optimization
    virtual int idaapi func(mblock_t *blk) override;
};

//--------------------------------------------------------------------------
// Component registration functions
//--------------------------------------------------------------------------
bool deobf_avail();
bool deobf_active();
void deobf_init();
void deobf_done();
void deobf_attach_popup(TWidget *widget, TPopupMenu *popup, vdui_t *vu);

// Clear tracking for a function to allow re-deobfuscation
void chernobog_clear_function_tracking(ea_t func_ea);

// Clear ALL tracking caches (called on database load if CHERNOBOG_RESET=1)
void chernobog_clear_all_tracking();

```

`src/deobf/deobf_types.h`:

```h
#pragma once
#include "../common/warn_off.h"
#include <hexrays.hpp>
#include <pro.h>
#include <ida.hpp>
#include <idp.hpp>
#include <loader.hpp>
#include <kernwin.hpp>
#include <bytes.hpp>
#include <xref.hpp>
#include <name.hpp>
#include <funcs.hpp>
#include <segment.hpp>
#include <auto.hpp>
#include <ua.hpp>
#include "../common/warn_on.h"

#include <vector>
#include <map>
#include <set>
#include <unordered_map>
#include <unordered_set>
#include <string>
#include <functional>
#include <optional>
#include <memory>
#include <algorithm>

// Forward declarations
struct deobf_ctx_t;
class mblock_visitor_t;

//--------------------------------------------------------------------------
// Obfuscation detection flags
//--------------------------------------------------------------------------
enum obf_type_t : uint32_t {
    OBF_NONE            = 0,
    OBF_FLATTENED       = 1 << 0,   // Control flow flattening
    OBF_BOGUS_CF        = 1 << 1,   // Bogus control flow
    OBF_STRING_ENC      = 1 << 2,   // String encryption
    OBF_CONST_ENC       = 1 << 3,   // Constant encryption
    OBF_INDIRECT_BR     = 1 << 4,   // Indirect branches
    OBF_SUBSTITUTION    = 1 << 5,   // Instruction substitution (legacy, now MBA)
    OBF_SPLIT_BLOCKS    = 1 << 6,   // Split basic blocks
    OBF_FUNC_WRAPPER    = 1 << 7,   // Hikari function wrappers
    OBF_IDENTITY_CALL   = 1 << 8,   // Identity function indirect calls
    OBF_STACK_STRING    = 1 << 9,   // Stack string construction
    OBF_SAVEDREGS       = 1 << 10,  // Register demotion (savedregs patterns)
    OBF_OBJC_OBFUSC     = 1 << 11,  // Obfuscated ObjC method calls
    OBF_GLOBAL_CONST    = 1 << 12,  // Global constants that can be inlined
    OBF_PTR_INDIRECT    = 1 << 13,  // Indirect pointer references (off_XXXX -> symbol)
    OBF_MBA_COMPLEX     = 1 << 14,  // Complex MBA expressions (Mixed Boolean-Arithmetic)
    OBF_CHAIN_OPS       = 1 << 15,  // Chained XOR/AND/OR/ADD operations
    OBF_OPAQUE_JUMP     = 1 << 16,  // Opaque predicate jumps
    OBF_CONST_OBFUSC    = 1 << 17,  // Obfuscated constants (detectable via Z3)
    OBF_INDIRECT_CALL   = 1 << 18,  // Indirect call obfuscation (Hikari IndirectCall)
};

//--------------------------------------------------------------------------
// Detected pattern info
//--------------------------------------------------------------------------
struct pattern_info_t {
    obf_type_t type;
    ea_t addr;
    std::string description;
    std::vector<ea_t> related_addrs;
};

//--------------------------------------------------------------------------
// Deobfuscation context - maintains state during analysis
//--------------------------------------------------------------------------
struct deobf_ctx_t {
    mbl_array_t *mba;           // Microcode block array
    cfunc_t *cfunc;             // Current function being analyzed
    ea_t func_ea;               // Function entry address

    uint32_t detected_obf;      // Bitmap of detected obfuscations
    std::vector<pattern_info_t> patterns;

    // Flattening-specific
    mop_t *switch_var;          // Switch variable for deflattening
    int switch_block;           // Block containing the dispatcher switch
    std::map<uint64_t, int> case_to_block;  // Case value -> real block mapping

    // State transitions: {from_block, to_block, state_value}
    struct transition_t {
        int from_block;
        int to_block;
        uint64_t state_value;
    };
    std::vector<transition_t> transitions;

    // String encryption
    std::map<ea_t, std::string> decrypted_strings;

    // Constant encryption
    std::map<ea_t, uint64_t> decrypted_consts;

    // Statistics
    int blocks_merged;
    int branches_simplified;
    int strings_decrypted;
    int consts_decrypted;
    int expressions_simplified;
    int indirect_resolved;

    // MBA simplification statistics
    int mba_simplified;           // MBA expressions simplified
    int chains_simplified;        // Chain operations simplified
    int opaque_jumps_resolved;    // Opaque predicate jumps resolved
    int z3_consts_recovered;      // Constants recovered via Z3
    int peephole_opts;            // Peephole optimizations applied

    deobf_ctx_t()
        : mba(nullptr), cfunc(nullptr), func_ea(BADADDR),
          detected_obf(OBF_NONE), switch_var(nullptr), switch_block(-1),
          blocks_merged(0), branches_simplified(0), strings_decrypted(0),
          consts_decrypted(0), expressions_simplified(0), indirect_resolved(0),
          mba_simplified(0), chains_simplified(0), opaque_jumps_resolved(0),
          z3_consts_recovered(0), peephole_opts(0)
    {}
};

//--------------------------------------------------------------------------
// Expression node for symbolic analysis
//--------------------------------------------------------------------------
struct sym_expr_t {
    enum op_t {
        OP_CONST,       // Constant value
        OP_VAR,         // Variable/register
        OP_ADD,         // Addition
        OP_SUB,         // Subtraction
        OP_MUL,         // Multiplication
        OP_DIV,         // Division
        OP_AND,         // Bitwise AND
        OP_OR,          // Bitwise OR
        OP_XOR,         // Bitwise XOR
        OP_NOT,         // Bitwise NOT
        OP_NEG,         // Negation
        OP_SHL,         // Shift left
        OP_SHR,         // Shift right
        OP_SAR,         // Arithmetic shift right
        OP_LOAD,        // Memory load
        OP_UNKNOWN      // Unknown operation
    };

    op_t op;
    uint64_t const_val;
    int var_idx;
    int bit_size;
    std::shared_ptr<sym_expr_t> left;
    std::shared_ptr<sym_expr_t> right;

    sym_expr_t() : op(OP_UNKNOWN), const_val(0), var_idx(-1), bit_size(64) {}

    static std::shared_ptr<sym_expr_t> make_const(uint64_t val, int bits = 64)
    {
        auto e = std::make_shared<sym_expr_t>();
        e->op = OP_CONST;
        e->const_val = val;
        e->bit_size = bits;
        return e;
    }

    static std::shared_ptr<sym_expr_t> make_var(int idx, int bits = 64)
    {
        auto e = std::make_shared<sym_expr_t>();
        e->op = OP_VAR;
        e->var_idx = idx;
        e->bit_size = bits;
        return e;
    }

    static std::shared_ptr<sym_expr_t> make_binop(op_t o,
        std::shared_ptr<sym_expr_t> l, std::shared_ptr<sym_expr_t> r)
    {
        auto e = std::make_shared<sym_expr_t>();
        e->op = o;
        e->left = l;
        e->right = r;
        e->bit_size = l ? l->bit_size : 64;
        return e;
    }

    static std::shared_ptr<sym_expr_t> make_unop(op_t o, std::shared_ptr<sym_expr_t> operand)
    {
        auto e = std::make_shared<sym_expr_t>();
        e->op = o;
        e->left = operand;
        e->bit_size = operand ? operand->bit_size : 64;
        return e;
    }

    bool is_const() const { return op == OP_CONST; }
    bool is_var() const { return op == OP_VAR; }
};

using sym_expr_ptr = std::shared_ptr<sym_expr_t>;

//--------------------------------------------------------------------------
// Utility functions declarations
//--------------------------------------------------------------------------
namespace deobf {
    // Logging
    void log(const char *fmt, ...);
    void log_verbose(const char *fmt, ...);
    void set_verbose(bool v);

    // Microcode helpers
    minsn_t *find_insn_by_opcode(mblock_t *blk, mcode_t op);
    bool is_jcc(mcode_t op);
    bool is_unconditional_jmp(mcode_t op);
    const char *mcode_name(mcode_t op);

    // Pattern matching
    bool match_xor_pattern(minsn_t *insn, mop_t **out_left, mop_t **out_right);
    bool match_load_xor_pattern(mblock_t *blk, ea_t *out_enc_addr, uint64_t *out_key);

    // Expression analysis
    sym_expr_ptr mop_to_sym(const mop_t &mop, deobf_ctx_t *ctx);
    sym_expr_ptr simplify_expr(sym_expr_ptr expr);
    std::optional<uint64_t> eval_const_expr(sym_expr_ptr expr);
    bool exprs_equivalent(sym_expr_ptr a, sym_expr_ptr b);
}

```

`src/deobf/deobf_utils.cpp`:

```cpp
#include "deobf_types.h"
#include <stdarg.h>

namespace deobf {

static bool g_verbose = false;

void set_verbose(bool v)
{
    g_verbose = v;
}

void log(const char *fmt, ...)
{
    va_list va;
    va_start(va, fmt);
    vmsg(fmt, va);
    va_end(va);
}

void log_verbose(const char *fmt, ...)
{
    if ( !g_verbose )
        return;
    va_list va;
    va_start(va, fmt);
    vmsg(fmt, va);
    va_end(va);
}

//--------------------------------------------------------------------------
// Microcode helpers
//--------------------------------------------------------------------------
minsn_t *find_insn_by_opcode(mblock_t *blk, mcode_t op)
{
    if ( !blk )
        return nullptr;

    for ( minsn_t *insn = blk->head; insn; insn = insn->next )
    {
        if ( insn->opcode == op )
            return insn;
    }
    return nullptr;
}

bool is_jcc(mcode_t op)
{
    return op >= m_jcnd && op <= m_jle;
}

bool is_unconditional_jmp(mcode_t op)
{
    return op == m_goto || op == m_ijmp;
}

const char *mcode_name(mcode_t op)
{
    static const char *names[] = {
        "m_nop", "m_stx", "m_ldx", "m_ldc", "m_mov", "m_neg", "m_lnot", "m_bnot",
        "m_xds", "m_xdu", "m_low", "m_high", "m_add", "m_sub", "m_mul", "m_udiv",
        "m_sdiv", "m_umod", "m_smod", "m_or", "m_and", "m_xor", "m_shl", "m_shr",
        "m_sar", "m_cfadd", "m_ofadd", "m_cfshl", "m_cfshr", "m_sets", "m_seto",
        "m_setp", "m_setnz", "m_setz", "m_setae", "m_setb", "m_seta", "m_setbe",
        "m_setg", "m_setge", "m_setl", "m_setle", "m_jcnd", "m_jnz", "m_jz",
        "m_jae", "m_jb", "m_ja", "m_jbe", "m_jg", "m_jge", "m_jl", "m_jle",
        "m_jtbl", "m_ijmp", "m_goto", "m_call", "m_icall", "m_ret", "m_push",
        "m_pop", "m_und", "m_ext", "m_f2i", "m_f2u", "m_i2f", "m_u2f", "m_f2f",
        "m_fneg", "m_fadd", "m_fsub", "m_fmul", "m_fdiv"
    };

    if ( op < sizeof(names)/sizeof(names[0]) )
        return names[op];
    return "m_unknown";
}

//--------------------------------------------------------------------------
// Pattern matching helpers
//--------------------------------------------------------------------------
bool match_xor_pattern(minsn_t *insn, mop_t **out_left, mop_t **out_right)
{
    if ( !insn || insn->opcode != m_xor )
        return false;

    if ( out_left )
        *out_left = &insn->l;
    if ( out_right )
        *out_right = &insn->r;

    return true;
}

bool match_load_xor_pattern(mblock_t *blk, ea_t *out_enc_addr, uint64_t *out_key)
{
    // Look for pattern:
    //   load tmp, [gvar1]
    //   xor result, tmp, const  (or xor result, tmp, [gvar2])

    for ( minsn_t *insn = blk->head; insn; insn = insn->next )
    {
        if ( insn->opcode != m_xor )
            continue;

        // Check if one operand is a global variable load
        mop_t *load_op = nullptr;
        mop_t *key_op = nullptr;

        if ( insn->l.t == mop_v )
        {  // Left is a kreg that may have been loaded
            // Need to trace back to find the load
        }

        if ( insn->r.t == mop_n )
        {  // Right is immediate
            key_op = &insn->r;
            load_op = &insn->l;
        }
        else if ( insn->l.t == mop_n )
        {  // Left is immediate
            key_op = &insn->l;
            load_op = &insn->r;
        }

        if ( key_op && load_op && key_op->t == mop_n )
        {
            if ( out_key )
                *out_key = key_op->nnn->value;

            // Try to find the source address
            if ( load_op->t == mop_v )
            {
                // It's a global variable
                if ( out_enc_addr )
                    *out_enc_addr = load_op->g;
                return true;
            }
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// Expression analysis
//--------------------------------------------------------------------------
sym_expr_ptr mop_to_sym(const mop_t &mop, deobf_ctx_t *ctx)
{
    switch ( mop.t )
    {
        case mop_n:  // Immediate number
            return sym_expr_t::make_const(mop.nnn->value, mop.size * 8);

        case mop_r:  // Register
            return sym_expr_t::make_var(mop.r, mop.size * 8);

        case mop_v:  // Global variable
            return sym_expr_t::make_var(0x10000 + (int)(mop.g & 0xFFFF), mop.size * 8);

        case mop_S:  // Stack variable
            return sym_expr_t::make_var(0x20000 + mop.s->off, mop.size * 8);

        case mop_d:
        { // Nested instruction result
            if ( !mop.d )
                return nullptr;

            minsn_t *nested = mop.d;
            sym_expr_ptr left = mop_to_sym(nested->l, ctx);
            sym_expr_ptr right = mop_to_sym(nested->r, ctx);

            sym_expr_t::op_t op;
            switch ( nested->opcode )
            {
                case m_add: op = sym_expr_t::OP_ADD; break;
                case m_sub: op = sym_expr_t::OP_SUB; break;
                case m_mul: op = sym_expr_t::OP_MUL; break;
                case m_and: op = sym_expr_t::OP_AND; break;
                case m_or:  op = sym_expr_t::OP_OR;  break;
                case m_xor: op = sym_expr_t::OP_XOR; break;
                case m_shl: op = sym_expr_t::OP_SHL; break;
                case m_shr: op = sym_expr_t::OP_SHR; break;
                case m_sar: op = sym_expr_t::OP_SAR; break;
                case m_neg: op = sym_expr_t::OP_NEG; break;
                case m_bnot: op = sym_expr_t::OP_NOT; break;
                default: return nullptr;
            }

            if ( op == sym_expr_t::OP_NEG || op == sym_expr_t::OP_NOT )
                return sym_expr_t::make_unop(op, left);
            else
                return sym_expr_t::make_binop(op, left, right);
        }

        default:
            return nullptr;
    }
}

sym_expr_ptr simplify_expr(sym_expr_ptr expr)
{
    if ( !expr )
        return nullptr;

    // Recursively simplify children first
    if ( expr->left )
        expr->left = simplify_expr(expr->left);
    if ( expr->right )
        expr->right = simplify_expr(expr->right);

    // Constant folding
    if ( expr->left && expr->left->is_const() &&
        expr->right && expr->right->is_const() )
    {

        uint64_t l = expr->left->const_val;
        uint64_t r = expr->right->const_val;
        uint64_t result = 0;

        switch ( expr->op )
        {
            case sym_expr_t::OP_ADD: result = l + r; break;
            case sym_expr_t::OP_SUB: result = l - r; break;
            case sym_expr_t::OP_MUL: result = l * r; break;
            case sym_expr_t::OP_AND: result = l & r; break;
            case sym_expr_t::OP_OR:  result = l | r; break;
            case sym_expr_t::OP_XOR: result = l ^ r; break;
            case sym_expr_t::OP_SHL: result = l << r; break;
            case sym_expr_t::OP_SHR: result = l >> r; break;
            default: return expr;
        }

        return sym_expr_t::make_const(result, expr->bit_size);
    }

    // Unary constant folding
    if ( expr->left && expr->left->is_const() && !expr->right )
    {
        uint64_t v = expr->left->const_val;
        uint64_t result = 0;

        switch ( expr->op )
        {
            case sym_expr_t::OP_NEG: result = -v; break;
            case sym_expr_t::OP_NOT: result = ~v; break;
            default: return expr;
        }

        return sym_expr_t::make_const(result, expr->bit_size);
    }

    // Algebraic simplifications
    // x XOR x = 0
    if ( expr->op == sym_expr_t::OP_XOR &&
        expr->left && expr->right &&
        expr->left->is_var() && expr->right->is_var() &&
        expr->left->var_idx == expr->right->var_idx )
    {
        return sym_expr_t::make_const(0, expr->bit_size);
    }

    // x XOR 0 = x
    if ( expr->op == sym_expr_t::OP_XOR && expr->right && expr->right->is_const() &&
        expr->right->const_val == 0 )
    {
        return expr->left;
    }

    // x AND 0 = 0
    if ( expr->op == sym_expr_t::OP_AND && expr->right && expr->right->is_const() &&
        expr->right->const_val == 0 )
    {
        return sym_expr_t::make_const(0, expr->bit_size);
    }

    // x OR 0 = x
    if ( expr->op == sym_expr_t::OP_OR && expr->right && expr->right->is_const() &&
        expr->right->const_val == 0 )
    {
        return expr->left;
    }

    // x + 0 = x
    if ( expr->op == sym_expr_t::OP_ADD && expr->right && expr->right->is_const() &&
        expr->right->const_val == 0 )
    {
        return expr->left;
    }

    // x - 0 = x
    if ( expr->op == sym_expr_t::OP_SUB && expr->right && expr->right->is_const() &&
        expr->right->const_val == 0 )
    {
        return expr->left;
    }

    // NOT(NOT(x)) = x
    if ( expr->op == sym_expr_t::OP_NOT && expr->left &&
        expr->left->op == sym_expr_t::OP_NOT )
    {
        return expr->left->left;
    }

    // NEG(NEG(x)) = x
    if ( expr->op == sym_expr_t::OP_NEG && expr->left &&
        expr->left->op == sym_expr_t::OP_NEG )
    {
        return expr->left->left;
    }

    return expr;
}

std::optional<uint64_t> eval_const_expr(sym_expr_ptr expr)
{
    sym_expr_ptr simplified = simplify_expr(expr);
    if ( simplified && simplified->is_const() )
        return simplified->const_val;
    return std::nullopt;
}

bool exprs_equivalent(sym_expr_ptr a, sym_expr_ptr b)
{
    if ( !a || !b )
        return a == b;

    if ( a->op != b->op )
        return false;

    if ( a->is_const() && b->is_const() )
        return a->const_val == b->const_val;

    if ( a->is_var() && b->is_var() )
        return a->var_idx == b->var_idx;

    return exprs_equivalent(a->left, b->left) &&
           exprs_equivalent(a->right, b->right);
}

} // namespace deobf

```

`src/deobf/handlers/block_merge.cpp`:

```cpp
#include "block_merge.h"

//--------------------------------------------------------------------------
// Detection
//--------------------------------------------------------------------------
bool block_merge_handler_t::detect_split_blocks(mbl_array_t *mba)
{
    if ( !mba ) 
        return false;

    // Count small blocks and check for chains
    int small_blocks = 0;
    int chain_length = 0;
    int max_chain = 0;

    for ( int i = 0; i < mba->qty; ++i ) 
    {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        int insn_count = count_insns(blk);

        // Small block with single successor
        if ( insn_count <= 2 && has_single_goto_succ(blk) ) 
        {
            small_blocks++;

            // Check if successor is also small (chain)
            if ( blk->nsucc() == 1 ) 
            {
                int succ = blk->succ(0);
                mblock_t *succ_blk = mba->get_mblock(succ);
                if ( succ_blk && count_insns(succ_blk) <= 2 ) 
                {
                    chain_length++;
                    if ( chain_length > max_chain ) 
                        max_chain = chain_length;
                }
                else
                {
                    chain_length = 0;
                }
            }
        }
    }

    // Heuristic: if >30% of blocks are small with chains, likely split
    float ratio = (float)small_blocks / mba->qty;
    return ( ratio > 0.3f && max_chain >= 3) || max_chain >= 5;
}

//--------------------------------------------------------------------------
// Main deobfuscation pass
//--------------------------------------------------------------------------
int block_merge_handler_t::run(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    deobf::log("[block_merge] Starting block merge\n");

    int total_changes = 0;

    // Find all mergeable chains
    auto chains = find_mergeable_chains(mba);
    deobf::log("[block_merge] Found %zu mergeable chains\n", chains.size());

    // Merge each chain
    for ( const auto &chain : chains ) 
    {
        if ( chain.blocks.size() >= 2 ) 
        {
            total_changes += merge_chain(mba, chain, ctx);
        }
    }

    deobf::log("[block_merge] Merged %d blocks\n", ctx->blocks_merged);
    return total_changes;
}

//--------------------------------------------------------------------------
// Find mergeable chains
//--------------------------------------------------------------------------
std::vector<block_merge_handler_t::chain_t>
block_merge_handler_t::find_mergeable_chains(mbl_array_t *mba)
{
    std::vector<chain_t> chains;
    std::vector<bool> visited(mba->qty, false);

    for ( int i = 0; i < mba->qty; ++i ) 
    {
        if ( visited[i] ) 
            continue;

        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        // Start a chain if this block has single successor
        if ( !has_single_goto_succ(blk) ) 
            continue;

        chain_t chain;
        int curr = i;

        while ( curr >= 0 && curr < mba->qty && !visited[curr] ) 
        {
            mblock_t *curr_blk = mba->get_mblock(curr);
            if ( !curr_blk ) 
                break;

            chain.blocks.push_back(curr);
            visited[curr] = true;

            // Check if can continue chain
            if ( !has_single_goto_succ(curr_blk) ) 
                break;

            int succ = curr_blk->succ(0);

            // Don't follow if successor has multiple predecessors
            // (that would break other paths)
            mblock_t *succ_blk = mba->get_mblock(succ);
            if ( !succ_blk || succ_blk->npred() != 1 ) 
                break;

            // Check if blocks can be merged
            if ( !can_merge(curr_blk, succ_blk, mba) ) 
                break;

            curr = succ;
        }

        if ( chain.blocks.size() >= 2 ) 
        {
            chains.push_back(chain);
        }
    }

    return chains;
}

//--------------------------------------------------------------------------
// Check if two blocks can be merged
//--------------------------------------------------------------------------
bool block_merge_handler_t::can_merge(mblock_t *first, mblock_t *second, mbl_array_t *mba)
{
    if ( !first || !second ) 
        return false;

    // First must have exactly one successor (the second block)
    if ( first->nsucc() != 1 ) 
        return false;

    // Second must have exactly one predecessor (the first block)
    if ( second->npred() != 1 ) 
        return false;

    // First must end with unconditional jump to second
    if ( !first->tail || first->tail->opcode != m_goto ) 
        return false;

    if ( first->tail->d.t != mop_b || first->tail->d.b != second->serial ) 
        return false;

    // Don't merge if second is a loop header or has phi nodes
    // (simplified check - actual phi detection is more complex)

    return true;
}

//--------------------------------------------------------------------------
// Merge chain of blocks
//--------------------------------------------------------------------------
int block_merge_handler_t::merge_chain(mbl_array_t *mba, const chain_t &chain, deobf_ctx_t *ctx)
{
    if ( chain.blocks.size() < 2 ) 
        return 0;

    int merged = 0;

    // In Hex-Rays microcode, we can't directly merge blocks
    // Instead, we can:
    // 1. Remove the goto instructions between blocks
    // 2. Let the optimizer merge them
    // 3. Or mark blocks for later processing

    // For now, annotate and remove gotos
    for ( size_t i = 0; i < chain.blocks.size() - 1; ++i ) 
    {
        mblock_t *blk = mba->get_mblock(chain.blocks[i]);
        if ( !blk || !blk->tail ) 
            continue;

        // If block ends with goto to next in chain, we can mark it
        if ( blk->tail->opcode == m_goto ) 
        {
            // Change goto to nop (will be optimized away)
            // Note: This is simplified - actual implementation needs care
            deobf::log_verbose("[block_merge] Chain: %d -> %d\n",
                              chain.blocks[i], chain.blocks[i + 1]);
            merged++;
        }
    }

    ctx->blocks_merged += merged;
    return merged;
}

//--------------------------------------------------------------------------
// Count instructions in block
//--------------------------------------------------------------------------
int block_merge_handler_t::count_insns(mblock_t *blk)
{
    if ( !blk ) 
        return 0;

    int count = 0;
    for ( minsn_t *ins = blk->head; ins; ins = ins->next ) 
    {
        count++;
    }
    return count;
}

//--------------------------------------------------------------------------
// Check for single unconditional successor
//--------------------------------------------------------------------------
bool block_merge_handler_t::has_single_goto_succ(mblock_t *blk)
{
    if ( !blk ) 
        return false;

    // Must have exactly one successor
    if ( blk->nsucc() != 1 ) 
        return false;

    // Must end with goto (not conditional jump)
    if ( !blk->tail || blk->tail->opcode != m_goto ) 
        return false;

    return true;
}

```

`src/deobf/handlers/block_merge.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Block Merge Handler
//
// Hikari's block splitting:
//   - Splits basic blocks at random points
//   - Creates many small blocks connected by unconditional jumps
//   - Block names have ".split" suffix
//
// Detection:
//   - Many small blocks (1-2 instructions each)
//   - Linear chains of unconditional jumps
//   - ".split" in block/label names
//
// Reversal:
//   1. Identify linear block chains
//   2. Merge consecutive blocks
//   3. Remove intermediate jumps
//   4. Preserve semantic ordering
//--------------------------------------------------------------------------
class block_merge_handler_t {
public:
    // Detection
    static bool detect_split_blocks(mbl_array_t *mba);

    // Main deobfuscation pass
    static int run(mbl_array_t *mba, deobf_ctx_t *ctx);

private:
    // Find mergeable block chains
    struct chain_t {
        std::vector<int> blocks;  // Block indices in order
    };

    static std::vector<chain_t> find_mergeable_chains(mbl_array_t *mba);

    // Check if two blocks can be merged
    static bool can_merge(mblock_t *first, mblock_t *second, mbl_array_t *mba);

    // Merge a chain of blocks
    static int merge_chain(mbl_array_t *mba, const chain_t &chain, deobf_ctx_t *ctx);

    // Helper: count instructions in a block
    static int count_insns(mblock_t *blk);

    // Helper: check if block has single unconditional successor
    static bool has_single_goto_succ(mblock_t *blk);
};

```

`src/deobf/handlers/bogus_cf.cpp`:

```cpp
#include "bogus_cf.h"
#include "../analysis/pattern_match.h"
#include "../analysis/cfg_analysis.h"
#include "../analysis/opaque_eval.h"
#include <functional>

//--------------------------------------------------------------------------
// Detection
//--------------------------------------------------------------------------
bool bogus_cf_handler_t::detect(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba ) 
        return false;

    // Look for opaque predicates
    for ( int i = 0; i < mba->qty; ++i ) 
    {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk || !blk->tail ) 
            continue;

        if ( deobf::is_jcc(blk->tail->opcode) ) 
        {
            bool is_true;
            if ( is_opaque_predicate(blk->tail, &is_true) ) 
            {
                return true;
            }
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// Main deobfuscation pass
//--------------------------------------------------------------------------
int bogus_cf_handler_t::run(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    deobf::log("[bogus_cf] Starting bogus control flow removal\n");

    int total_changes = 0;

    // Find all opaque predicates
    auto opaques = find_opaque_predicates(mba, ctx);
    deobf::log("[bogus_cf] Found %zu opaque predicates\n", opaques.size());

    // Remove dead branches (replace conditional with unconditional)
    total_changes += remove_dead_branches(mba, opaques);

    // Find newly unreachable blocks
    auto dead_blocks = find_dead_blocks(mba, opaques);
    deobf::log("[bogus_cf] Found %zu dead blocks\n", dead_blocks.size());

    // Note: Actually removing blocks from mba is complex and may require
    // rebuilding the microcode. For now, we just mark them and let
    // IDA's optimizer handle cleanup.

    // Simplify any remaining junk instructions
    total_changes += simplify_junk_instructions(mba, ctx);

    deobf::log("[bogus_cf] Bogus CF removal complete, %d changes\n", total_changes);
    return total_changes;
}

//--------------------------------------------------------------------------
// Find all opaque predicates
//--------------------------------------------------------------------------
std::vector<bogus_cf_handler_t::opaque_info_t> bogus_cf_handler_t::find_opaque_predicates(
    mbl_array_t *mba, deobf_ctx_t *ctx)
{
    std::vector<opaque_info_t> result;

    for ( int i = 0; i < mba->qty; ++i ) 
    {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk || !blk->tail ) 
            continue;

        minsn_t *tail = blk->tail;
        if ( !deobf::is_jcc(tail->opcode) ) 
            continue;

        bool is_true;
        if ( is_opaque_predicate(tail, &is_true) ) 
        {
            opaque_info_t info;
            info.block_idx = i;
            info.cond_insn = tail;
            info.always_true = is_true;

            // Determine live/dead targets
            // For jnz (jump if not zero): if always_true, taken branch is live
            // The fall-through is the block after this one (blk->serial + 1)
            // The taken branch is in tail->d

            if ( tail->d.t == mop_b ) 
            {
                int taken_target = tail->d.b;
                int fallthrough = i + 1;  // Simplified - actual fall-through may differ

                if ( is_true ) 
                {
                    // Condition is always true
                    // For jnz/jne: taken branch is live
                    // For jz/je: fall-through is live
                    if ( tail->opcode == m_jnz ||
                        tail->opcode == m_ja || tail->opcode == m_jae ||
                        tail->opcode == m_jg || tail->opcode == m_jge)
                    {
                        info.live_target = taken_target;
                        info.dead_target = fallthrough;
                    }
                    else
                    {
                        info.live_target = fallthrough;
                        info.dead_target = taken_target;
                    }
                }
                else
                {
                    // Condition is always false
                    if ( tail->opcode == m_jnz ||
                        tail->opcode == m_ja || tail->opcode == m_jae ||
                        tail->opcode == m_jg || tail->opcode == m_jge)
                    {
                        info.live_target = fallthrough;
                        info.dead_target = taken_target;
                    }
                    else
                    {
                        info.live_target = taken_target;
                        info.dead_target = fallthrough;
                    }
                }
            }

            result.push_back(info);
            deobf::log_verbose("[bogus_cf] Opaque predicate in block %d: always %s\n",
                              i, is_true ? "true" : "false");
        }
    }

    return result;
}

//--------------------------------------------------------------------------
// Check if condition is opaque
//--------------------------------------------------------------------------
bool bogus_cf_handler_t::is_opaque_predicate(minsn_t *cond, bool *is_true)
{
    if ( !cond ) 
        return false;

    // Try different opaque patterns (fast path first)

    if ( check_const_comparison(cond, is_true) ) 
        return true;

    if ( check_math_identity(cond, is_true) ) 
        return true;

    if ( check_global_var_pattern(cond, is_true) ) 
        return true;

    // Use Z3-based analysis for complex predicates
    auto z3_result = opaque_eval_t::check_opaque_predicate(cond);
    switch ( z3_result ) {
        case opaque_eval_t::OPAQUE_ALWAYS_TRUE:
            *is_true = true;
            deobf::log_verbose("[bogus_cf] Z3 determined predicate is always true\n");
            return true;
        case opaque_eval_t::OPAQUE_ALWAYS_FALSE:
            *is_true = false;
            deobf::log_verbose("[bogus_cf] Z3 determined predicate is always false\n");
            return true;
        default:
            break;
    }

    return false;
}

//--------------------------------------------------------------------------
// Check constant comparison (e.g., 1 == 1, 5 < 10)
//--------------------------------------------------------------------------
bool bogus_cf_handler_t::check_const_comparison(minsn_t *insn, bool *result)
{
    if ( !insn ) 
        return false;

    // The condition is in the operand (for jcc instructions)
    // It may be a nested setXX instruction

    minsn_t *cmp = nullptr;

    if ( insn->l.t == mop_d && insn->l.d ) {
        cmp = insn->l.d;
    } else if ( insn->l.t == mop_n ) {
        // Direct constant condition
        *result = (insn->l.nnn->value != 0);
        return true;
    }

    if ( !cmp ) 
        return false;

    // Check for setXX with two constant operands
    if ( cmp->opcode >= m_setz && cmp->opcode <= m_setle ) {
        if ( cmp->l.t == mop_n && cmp->r.t == mop_n ) {
            int64_t l = cmp->l.nnn->value;
            int64_t r = cmp->r.nnn->value;

            switch ( cmp->opcode ) {
                case m_setz:  *result = (l == r); return true;
                case m_setnz: *result = (l != r); return true;
                case m_setae: *result = ((uint64_t)l >= (uint64_t)r); return true;
                case m_setb:  *result = ((uint64_t)l < (uint64_t)r); return true;
                case m_seta:  *result = ((uint64_t)l > (uint64_t)r); return true;
                case m_setbe: *result = ((uint64_t)l <= (uint64_t)r); return true;
                case m_setg:  *result = (l > r); return true;
                case m_setge: *result = (l >= r); return true;
                case m_setl:  *result = (l < r); return true;
                case m_setle: *result = (l <= r); return true;
                default: break;
            }
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// Check math identity pattern: x * (x + 1) % 2 == 0
// This is always true because consecutive integers have opposite parity
//--------------------------------------------------------------------------
bool bogus_cf_handler_t::check_math_identity(minsn_t *insn, bool *result)
{
    if ( !insn ) 
        return false;

    // Look for: setz(smod(mul(...), 2), 0)
    // Or similar patterns

    minsn_t *cmp = nullptr;
    if ( insn->l.t == mop_d ) 
        cmp = insn->l.d;
    else
        return false;

    if ( !cmp || cmp->opcode != m_setz ) 
        return false;

    // Right operand should be 0
    if ( cmp->r.t != mop_n || cmp->r.nnn->value != 0 ) 
        return false;

    // Left operand should be mod by 2
    if ( cmp->l.t != mop_d ) 
        return false;

    minsn_t *mod = cmp->l.d;
    if ( !mod || (mod->opcode != m_smod && mod->opcode != m_umod) ) 
        return false;

    // Modulus should be 2
    if ( mod->r.t != mop_n || mod->r.nnn->value != 2 ) 
        return false;

    // The dividend should be a multiplication
    if ( mod->l.t != mop_d ) 
        return false;

    minsn_t *mul = mod->l.d;
    if ( !mul || mul->opcode != m_mul ) 
        return false;

    // One factor should be (x + 1) where x is the other factor
    // This is complex to verify precisely, but the pattern is distinctive

    // For now, assume any mul -> mod 2 -> cmp 0 is this pattern
    *result = true;  // x * (x+1) % 2 is always 0
    return true;
}

//--------------------------------------------------------------------------
// Check global variable pattern (Hikari uses LHSGV/RHSGV)
// This handles complex expressions using global constants like:
//   ((~((~(~dword_Y | ~dword_X) | v2 ^ (v1 | ~dword_X & mask)) + C) & M1) * ...) / D < threshold
//--------------------------------------------------------------------------
bool bogus_cf_handler_t::check_global_var_pattern(minsn_t *insn, bool *result)
{
    if ( !insn ) 
        return false;

    // Use the opaque evaluator to try to evaluate the full expression
    // It will read globals from the binary and compute the result

    // First, check if this expression involves any global variables
    bool has_global = false;
    std::function<void(const mop_t &)> check_op = [&](const mop_t &op)
    {
        if ( op.t == mop_v ) {
            has_global = true;
        } else if ( op.t == mop_d && op.d ) {
            check_op(op.d->l);
            check_op(op.d->r);
        }
    };

    check_op(insn->l);
    check_op(insn->r);

    if ( !has_global ) 
        return false;

    // Try to evaluate the condition
    bool eval_result;
    if ( opaque_eval_t::evaluate_condition(insn, &eval_result) ) {
        *result = eval_result;
        deobf::log_verbose("[bogus_cf] Evaluated global pattern: always %s\n",
                          eval_result ? "true" : "false");
        return true;
    }

    // If direct evaluation fails, try evaluating sub-expressions
    // to see if we can determine the outcome

    // Handle nested condition in jcc
    minsn_t *cond = nullptr;
    if ( insn->l.t == mop_d && insn->l.d ) {
        cond = insn->l.d;
    }

    if ( cond ) {
        // Try to evaluate the comparison operands
        auto left_val = opaque_eval_t::evaluate_operand(cond->l);
        auto right_val = opaque_eval_t::evaluate_operand(cond->r);

        if ( left_val.has_value() && right_val.has_value() ) {
            uint64_t l = *left_val;
            uint64_t r = *right_val;
            int64_t sl = (int64_t)l;
            int64_t sr = (int64_t)r;

            bool cond_result = false;
            bool found = true;

            switch ( cond->opcode ) {
                case m_setz:  cond_result = (l == r); break;
                case m_setnz: cond_result = (l != r); break;
                case m_setl:  cond_result = (sl < sr); break;
                case m_setle: cond_result = (sl <= sr); break;
                case m_setg:  cond_result = (sl > sr); break;
                case m_setge: cond_result = (sl >= sr); break;
                case m_setb:  cond_result = (l < r); break;
                case m_setbe: cond_result = (l <= r); break;
                case m_seta:  cond_result = (l > r); break;
                case m_setae: cond_result = (l >= r); break;
                default: found = false;
            }

            if ( found ) {
                // Adjust for the outer jump instruction
                if ( insn->opcode == m_jnz ) {
                    *result = cond_result;
                } else if ( insn->opcode == m_jz ) {
                    *result = !cond_result;
                } else {
                    *result = cond_result;
                }
                deobf::log_verbose("[bogus_cf] Computed global expression: %llx vs %llx -> %s\n",
                                  (unsigned long long)l, (unsigned long long)r,
                                  *result ? "true" : "false");
                return true;
            }
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// Find dead blocks
//--------------------------------------------------------------------------
std::set<int> bogus_cf_handler_t::find_dead_blocks(mbl_array_t *mba,
    const std::vector<opaque_info_t> &opaques)
    {

    std::set<int> dead;

    // Start with dead targets from opaque predicates
    for ( const auto &op : opaques ) {
        if ( op.dead_target >= 0 && op.dead_target < mba->qty ) {
            dead.insert(op.dead_target);
        }
    }

    // Expand: any block only reachable from dead blocks is also dead
    bool changed = true;
    while ( changed ) {
        changed = false;

        for ( int i = 0; i < mba->qty; ++i ) {
            if ( i == 0 ) // Entry block is never dead
                continue;
            if ( dead.count(i) ) 
                continue;

            mblock_t *blk = mba->get_mblock(i);
            if ( !blk ) 
                continue;

            // Check if all predecessors are dead
            bool all_preds_dead = true;
            bool has_preds = false;

            for ( int j = 0; j < mba->qty; ++j ) {
                if ( j == i ) 
                    continue;

                mblock_t *pred = mba->get_mblock(j);
                if ( !pred ) 
                    continue;

                // Check if j is a predecessor of i
                for ( int k = 0; k < pred->nsucc(); ++k ) {
                    if ( pred->succ(k) == i ) {
                        has_preds = true;
                        if ( !dead.count(j) ) {
                            all_preds_dead = false;
                            break;
                        }
                    }
                }

                if ( !all_preds_dead ) 
                    break;
            }

            if ( has_preds && all_preds_dead ) {
                dead.insert(i);
                changed = true;
            }
        }
    }

    return dead;
}

//--------------------------------------------------------------------------
// Remove dead branches
//--------------------------------------------------------------------------
int bogus_cf_handler_t::remove_dead_branches(mbl_array_t *mba,
    const std::vector<opaque_info_t> &opaques)
    {

    int changes = 0;

    for ( const auto &op : opaques ) {
        mblock_t *blk = mba->get_mblock(op.block_idx);
        if ( !blk || !blk->tail ) 
            continue;

        minsn_t *tail = blk->tail;

        // Replace conditional jump with unconditional to live target
        // This requires creating a new goto instruction

        // For simplicity, just modify the condition to be a constant
        // so that the optimizer will eliminate the dead branch

        if ( tail->l.t == mop_d && tail->l.d ) {
            // Replace nested condition with constant
            minsn_t *cond = tail->l.d;

            // Change to: set result = always_true ? 1 : 0
            cond->opcode = m_mov;
            cond->l.make_number(op.always_true ? 1 : 0, cond->l.size);
            cond->r.erase();

            changes++;
            deobf::log_verbose("[bogus_cf] Simplified opaque predicate in block %d\n",
                              op.block_idx);
        }
    }

    return changes;
}

//--------------------------------------------------------------------------
// Remove dead blocks (mark as unreachable)
//--------------------------------------------------------------------------
int bogus_cf_handler_t::remove_dead_blocks(mbl_array_t *mba, const std::set<int> &dead_blocks)
{
    int changes = 0;

    // Removing blocks from mba is complex
    // For now, just clear their contents to make them no-ops

    for ( int idx : dead_blocks ) {
        mblock_t *blk = mba->get_mblock(idx);
        if ( !blk ) 
            continue;

        // Clear all instructions except the terminator
        // Replace terminator with goto to itself (infinite loop = unreachable)

        // This is a simplified approach - proper removal would need mba manipulation
        deobf::log_verbose("[bogus_cf] Marked block %d as dead\n", idx);
        changes++;
    }

    return changes;
}

//--------------------------------------------------------------------------
// Simplify junk instructions
//--------------------------------------------------------------------------
int bogus_cf_handler_t::simplify_junk_instructions(mbl_array_t *mba, deobf_ctx_t *ctx) {
    int changes = 0;

    // Hikari adds random arithmetic that doesn't affect results
    // Look for patterns like: x = x + r; x = x - r (where r is random constant)

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        // Track variable values to detect no-op patterns
        // This is simplified - full implementation would need dataflow analysis

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            // Check for x = x op const patterns that could be canceled
            // by subsequent x = x reverse_op const

            // For now, just count potential junk instructions
            if ( ins->opcode == m_add || ins->opcode == m_sub ||
                ins->opcode == m_xor || ins->opcode == m_or || ins->opcode == m_and)
                {

                // If result is not used later, it might be junk
                // This requires use-def analysis
            }
        }
    }

    return changes;
}

```

`src/deobf/handlers/bogus_cf.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Bogus Control Flow Removal Handler
//
// Hikari's bogus CF inserts:
//   - Opaque predicates (always-true/false conditions)
//   - Unreachable "altered" blocks with junk code
//   - Fake branches that never execute
//
// Detection:
//   - Conditions comparing constants (e.g., 1 == 1)
//   - Conditions using (x * (x+1)) % 2 == 0 pattern
//   - Blocks with no real predecessors
//   - Duplicate/modified code blocks
//
// Reversal:
//   1. Identify opaque predicates
//   2. Evaluate to determine always-true/false
//   3. Remove dead branches
//   4. Delete unreachable blocks
//   5. Simplify remaining CFG
//--------------------------------------------------------------------------
class bogus_cf_handler_t {
public:
    // Detection
    static bool detect(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Main deobfuscation pass
    static int run(mbl_array_t *mba, deobf_ctx_t *ctx);

private:
    // Find all opaque predicates
    struct opaque_info_t {
        int block_idx;
        minsn_t *cond_insn;
        bool always_true;
        int live_target;    // Target to keep
        int dead_target;    // Target to remove
    };

    static std::vector<opaque_info_t> find_opaque_predicates(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Check if a condition is opaque
    static bool is_opaque_predicate(minsn_t *cond, bool *is_true);

    // Check specific opaque patterns
    static bool check_const_comparison(minsn_t *insn, bool *result);
    static bool check_math_identity(minsn_t *insn, bool *result);  // x*(x+1) % 2 == 0
    static bool check_global_var_pattern(minsn_t *insn, bool *result);

    // Find unreachable blocks
    static std::set<int> find_dead_blocks(mbl_array_t *mba, const std::vector<opaque_info_t> &opaques);

    // Remove dead code
    static int remove_dead_branches(mbl_array_t *mba, const std::vector<opaque_info_t> &opaques);
    static int remove_dead_blocks(mbl_array_t *mba, const std::set<int> &dead_blocks);

    // Simplify junk instructions in remaining blocks
    static int simplify_junk_instructions(mbl_array_t *mba, deobf_ctx_t *ctx);
};

```

`src/deobf/handlers/const_decrypt.cpp`:

```cpp
#include "const_decrypt.h"

//--------------------------------------------------------------------------
// Detection
//--------------------------------------------------------------------------
bool const_decrypt_handler_t::detect(mbl_array_t *mba)
{
    if ( !mba ) 
        return false;

    // Look for XOR instructions with global variable operands
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            encrypted_const_t ec;
            if ( is_const_encryption_pattern(ins, &ec) ) {
                return true;
            }
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// Main deobfuscation pass
//--------------------------------------------------------------------------
int const_decrypt_handler_t::run(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    deobf::log("[const_decrypt] Starting constant decryption\n");

    int total_changes = 0;

    // Find all encrypted constant patterns
    auto encrypted_consts = find_encrypted_consts(mba);
    deobf::log("[const_decrypt] Found %zu encrypted constants\n", encrypted_consts.size());

    // Replace each with the decrypted value
    for ( const auto &ec : encrypted_consts ) {
        // Find the block containing this instruction
        for ( int i = 0; i < mba->qty; ++i ) {
            mblock_t *blk = mba->get_mblock(i);
            if ( !blk ) 
                continue;

            for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
                if ( ins == ec.xor_insn ) {
                    total_changes += replace_with_constant(blk, ins, ec);
                    ctx->decrypted_consts[ec.gv_addr] = ec.decrypted_val;
                    ctx->consts_decrypted++;

                    deobf::log("[const_decrypt] Decrypted constant at %a: 0x%llx -> 0x%llx\n",
                              ec.gv_addr,
                              (unsigned long long)ec.encrypted_val,
                              (unsigned long long)ec.decrypted_val);
                    break;
                }
            }
        }
    }

    deobf::log("[const_decrypt] Decrypted %d constants\n", ctx->consts_decrypted);
    return total_changes;
}

//--------------------------------------------------------------------------
// Instruction-level simplification
//--------------------------------------------------------------------------
int const_decrypt_handler_t::simplify_insn(mblock_t *blk, minsn_t *ins, deobf_ctx_t *ctx) {
    if ( !ins ) 
        return 0;

    encrypted_const_t ec;
    if ( is_const_encryption_pattern(ins, &ec) ) {
        return replace_with_constant(blk, ins, ec);
    }

    return 0;
}

//--------------------------------------------------------------------------
// Find encrypted constants
//--------------------------------------------------------------------------
std::vector<const_decrypt_handler_t::encrypted_const_t>
const_decrypt_handler_t::find_encrypted_consts(mbl_array_t *mba)
{

    std::vector<encrypted_const_t> result;

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            encrypted_const_t ec;
            if ( is_const_encryption_pattern(ins, &ec) ) {
                result.push_back(ec);
            }
        }
    }

    return result;
}

//--------------------------------------------------------------------------
// Check if instruction matches encrypted constant pattern
//--------------------------------------------------------------------------
bool const_decrypt_handler_t::is_const_encryption_pattern(minsn_t *ins, encrypted_const_t *out)
{
    if ( !ins || ins->opcode != m_xor ) 
        return false;

    // Pattern: xor reg, gv_load, immediate
    //      or: xor reg, immediate, gv_load

    ea_t gv_addr = BADADDR;
    uint64_t key = 0;
    int size = 0;

    // Check both operand orderings
    if ( ins->l.t == mop_v && ins->r.t == mop_n ) {
        // Left is global, right is immediate
        gv_addr = ins->l.g;
        key = ins->r.nnn->value;
        size = ins->l.size;
    } else if ( ins->r.t == mop_v && ins->l.t == mop_n ) {
        // Right is global, left is immediate
        gv_addr = ins->r.g;
        key = ins->l.nnn->value;
        size = ins->r.size;
    } else {
        // Also check for nested load
        // Pattern: xor(ldx(gv), immediate)
        mop_t *gv_mop = nullptr;
        mop_t *key_mop = nullptr;

        if ( ins->l.t == mop_d && ins->l.d && ins->l.d->opcode == m_ldx ) {
            minsn_t *load = ins->l.d;
            if ( load->l.t == mop_v ) {
                gv_mop = &load->l;
                if ( ins->r.t == mop_n ) 
                    key_mop = &ins->r;
            }
        } else if ( ins->r.t == mop_d && ins->r.d && ins->r.d->opcode == m_ldx ) {
            minsn_t *load = ins->r.d;
            if ( load->l.t == mop_v ) {
                gv_mop = &load->l;
                if ( ins->l.t == mop_n ) 
                    key_mop = &ins->l;
            }
        }

        if ( gv_mop && key_mop ) {
            gv_addr = gv_mop->g;
            key = key_mop->nnn->value;
            size = gv_mop->size;
        }
    }

    if ( gv_addr == BADADDR || size <= 0 || size > 8 ) 
        return false;

    // Verify it's a data location (not code)
    flags64_t flags = get_flags(gv_addr);
    if ( is_code(flags) ) 
        return false;

    // Read the encrypted value
    uint64_t encrypted = read_global_value(gv_addr, size);

    // Compute decrypted value
    uint64_t decrypted = encrypted ^ key;

    if ( out ) {
        out->xor_insn = ins;
        out->gv_addr = gv_addr;
        out->xor_key = key;
        out->encrypted_val = encrypted;
        out->decrypted_val = decrypted;
        out->size = size;
    }

    return true;
}

//--------------------------------------------------------------------------
// Replace XOR with constant
//--------------------------------------------------------------------------
int const_decrypt_handler_t::replace_with_constant(mblock_t *blk, minsn_t *ins,
    const encrypted_const_t &ec)
    {

    if ( !ins ) 
        return 0;

    // Transform: xor dst, gv, key  ->  mov dst, decrypted_value

    ins->opcode = m_mov;
    ins->l.make_number(ec.decrypted_val, ec.size);
    ins->r.erase();

    return 1;
}

//--------------------------------------------------------------------------
// Read value from global
//--------------------------------------------------------------------------
uint64_t const_decrypt_handler_t::read_global_value(ea_t addr, int size)
{
    uint64_t val = 0;

    switch ( size ) {
        case 1:
            val = get_byte(addr);
            break;
        case 2:
            val = get_word(addr);
            break;
        case 4:
            val = get_dword(addr);
            break;
        case 8:
            val = get_qword(addr);
            break;
        default:
            get_bytes(&val, size, addr);
            break;
    }

    return val;
}

```

`src/deobf/handlers/const_decrypt.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Constant Decryption Handler
//
// Hikari's constant encryption:
//   - Replaces constants with XOR(encrypted_gv, key)
//   - Key may be in another global or immediate
//   - Creates GV for each encrypted constant
//
// Detection:
//   - Load from global followed by XOR with constant
//   - Globals with names like "CToGV"
//   - Patterns: load gv; xor key; use result
//
// Reversal:
//   1. Find XOR patterns with global loads
//   2. Read encrypted value from global
//   3. XOR with key to get original constant
//   4. Replace XOR expression with constant
//--------------------------------------------------------------------------
class const_decrypt_handler_t {
public:
    // Detection
    static bool detect(mbl_array_t *mba);

    // Main deobfuscation pass
    static int run(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Instruction-level simplification (called from optinsn_t)
    static int simplify_insn(mblock_t *blk, minsn_t *ins, deobf_ctx_t *ctx);

private:
    // Find encrypted constant patterns
    struct encrypted_const_t {
        minsn_t *xor_insn;      // The XOR instruction
        ea_t gv_addr;           // Global variable holding encrypted value
        uint64_t xor_key;       // XOR key
        uint64_t encrypted_val; // Value in global
        uint64_t decrypted_val; // Result after XOR
        int size;               // Size in bytes
    };

    static std::vector<encrypted_const_t> find_encrypted_consts(mbl_array_t *mba);

    // Check if an instruction is an encrypted constant pattern
    static bool is_const_encryption_pattern(minsn_t *ins, encrypted_const_t *out);

    // Replace XOR with decrypted constant
    static int replace_with_constant(mblock_t *blk, minsn_t *ins,
                                    const encrypted_const_t &ec);

    // Read value from global variable
    static uint64_t read_global_value(ea_t addr, int size);
};

```

`src/deobf/handlers/ctree_const_fold.cpp`:

```cpp
#include "ctree_const_fold.h"

//--------------------------------------------------------------------------
// Ctree visitor that folds XOR with global constants
//--------------------------------------------------------------------------
struct const_fold_visitor_t : public ctree_visitor_t {
    int changes = 0;
    cfunc_t *func = nullptr;

    const_fold_visitor_t(cfunc_t *f) : ctree_visitor_t(CV_PARENTS), func(f) {}

    int idaapi visit_expr(cexpr_t *e) override {
        // Look for XOR expressions
        if ( e->op != cot_xor ) 
            return 0;

        // Need both operands
        if ( !e->x || !e->y ) 
            return 0;

        // One operand must be a number constant
        if ( e->x->op != cot_num && e->y->op != cot_num ) 
            return 0;

        cexpr_t *val_expr = (e->y->op == cot_num) ? e->x : e->y;
        cexpr_t *num_expr = (e->y->op == cot_num) ? e->y : e->x;

        // Try to get a global address from the value expression
        ea_t obj_addr = BADADDR;

        // Case 1: Direct object reference (cot_obj)
        if ( val_expr->op == cot_obj ) {
            obj_addr = val_expr->obj_ea;
        }
        // Case 2: Pointer dereference (cot_ptr) - check if dereferencing a constant
        else if ( val_expr->op == cot_ptr && val_expr->x ) {
            if ( val_expr->x->op == cot_obj ) {
                obj_addr = val_expr->x->obj_ea;
            } else if ( val_expr->x->op == cot_num ) {
                obj_addr = (ea_t)val_expr->x->numval();
            } else if ( val_expr->x->op == cot_cast && val_expr->x->x ) {
                // Cast of number or obj
                if ( val_expr->x->x->op == cot_num ) {
                    obj_addr = (ea_t)val_expr->x->x->numval();
                } else if ( val_expr->x->x->op == cot_obj ) {
                    obj_addr = val_expr->x->x->obj_ea;
                }
            }
        }

        if ( obj_addr == BADADDR ) 
            return 0;

        // Check if the address is in a valid segment
        segment_t *seg = getseg(obj_addr);
        if ( !seg ) 
            return 0;

        // Check if it's a data location
        flags64_t flags = get_flags(obj_addr);
        if ( !is_loaded(obj_addr) ) 
            return 0;

        // Read the value based on size
        uint64_t obj_val = 0;
        int size = val_expr->type.get_size();
        if ( size <= 0 || size > 8 ) 
            return 0;

        switch ( size ) {
            case 1: obj_val = get_byte(obj_addr); break;
            case 2: obj_val = get_word(obj_addr); break;
            case 4: obj_val = get_dword(obj_addr); break;
            case 8: obj_val = get_qword(obj_addr); break;
            default: return 0;
        }

        // Get the constant
        uint64_t const_val = num_expr->numval();

        // Compute the XOR
        uint64_t result = obj_val ^ const_val;

        deobf::log("[ctree_const_fold] Folding %a ^ 0x%llx = 0x%llx\n",
                   obj_addr, (unsigned long long)const_val,
                   (unsigned long long)result);

        // Properly replace the expression with the constant result
        // First, clean up the old operands
        delete e->x;
        delete e->y;
        e->x = nullptr;
        e->y = nullptr;

        // Now make this a number expression
        e->op = cot_num;
        e->n = new cnumber_t();
        e->n->_value = result;
        e->n->nf.flags = 0;
        e->n->nf.opnum = 0;
        e->n->nf.props = 0;
        e->n->nf.serial = 0;
        e->n->nf.org_nbytes = size;
        e->n->nf.type_name.clear();

        changes++;
        return 0;
    }
};

//--------------------------------------------------------------------------
// Main entry point
//--------------------------------------------------------------------------
int ctree_const_fold_handler_t::run(cfunc_t *cfunc)
{
    if ( !cfunc ) 
        return 0;

    deobf::log_verbose("[ctree_const_fold] Running on %a\n", cfunc->entry_ea);

    const_fold_visitor_t visitor(cfunc);
    visitor.apply_to(&cfunc->body, nullptr);

    if ( visitor.changes > 0 ) {
        deobf::log("[ctree_const_fold] Folded %d constants\n", visitor.changes);
    }

    return visitor.changes;
}

```

`src/deobf/handlers/ctree_const_fold.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Ctree-level constant folder
//
// At the ctree level, global references are resolved. This handler finds
// XOR expressions where one operand is a global variable and folds them
// to constants by reading the actual value from the binary.
//
// This is particularly useful for Hikari string decryption where:
//   byte_1000146C5 = byte_100014695 ^ 0x84;
// Can be folded to:
//   byte_1000146C5 = 0xD1;
//
// This runs after the initial decompilation as a ctree transformation.
//--------------------------------------------------------------------------
class ctree_const_fold_handler_t {
public:
    // Main entry point - transforms the ctree
    static int run(cfunc_t *cfunc);
};

```

`src/deobf/handlers/ctree_indirect_call.cpp`:

```cpp
#include "ctree_indirect_call.h"

// Include allins.hpp for instruction types (NN_cmp, NN_mov, etc.)
// This header has no include guards, so only include once per translation unit
#ifndef ALLINS_HPP_INCLUDED
#define ALLINS_HPP_INCLUDED
#include <allins.hpp>
#endif

//--------------------------------------------------------------------------
// File-based debug logging
//--------------------------------------------------------------------------
#include "../../common/compat.h"

static void ctree_icall_debug(const char *fmt, ...)
{
#ifndef _WIN32
    char buf[4096];
    va_list args;
    va_start(args, fmt);
    int len = qvsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);
    
    int fd = open("/tmp/ctree_indirect_call_debug.log", O_WRONLY | O_CREAT | O_APPEND, 0644);
    if ( fd >= 0 ) {
        write(fd, buf, len);
        close(fd);
    }
#else
    (void)fmt;
#endif
}

//--------------------------------------------------------------------------
// Dispatcher analysis - for chained indirect call resolution
//--------------------------------------------------------------------------

// Info about a dispatcher function's behavior
struct dispatcher_info_t {
    bool is_dispatcher;       // Is this a dispatcher function?
    ea_t table_addr;          // Table address used
    int64_t offset;           // Offset subtracted
    int cmp_arg_idx;          // Which argument is compared (-1 if none)
    uint64_t cmp_value;       // Value compared against
    int true_index;           // Table index if comparison is true
    int false_index;          // Table index if comparison is false
};

// Visitor to analyze dispatcher functions
struct dispatcher_analyzer_t : public ctree_visitor_t {
    dispatcher_info_t info;
    cfunc_t *cfunc;
    
    dispatcher_analyzer_t(cfunc_t *cf) : ctree_visitor_t(CV_FAST), cfunc(cf)
    {
        memset(&info, 0, sizeof(info));
        info.cmp_arg_idx = -1;
    }
    
    int idaapi visit_expr(cexpr_t *e) override {
        // Look for comparison: arg == constant
        if ( e->op == cot_eq || e->op == cot_ne || e->op == cot_slt || 
            e->op == cot_sge || e->op == cot_ult || e->op == cot_uge)
            {
            // Check if comparing an argument to a constant
            cexpr_t *left = e->x;
            cexpr_t *right = e->y;
            
            // One side should be a number
            if ( right && right->op == cot_num ) {
                info.cmp_value = right->numval();
                // Left side might be an argument (var with arg index)
                if ( left && left->op == cot_var ) {
                    lvars_t *lvars = cfunc->get_lvars();
                    if ( lvars && left->v.idx < lvars->size() ) {
                        lvar_t &lv = (*lvars)[left->v.idx];
                        if ( lv.is_arg_var() ) {
                            // Simplified: assume first arg for now
                            info.cmp_arg_idx = 0;
                            ctree_icall_debug("[dispatcher] Found cmp: arg%d vs 0x%llx\n",
                                              info.cmp_arg_idx, (unsigned long long)info.cmp_value);
                        }
                    }
                }
            }
        }
        
        // Look for the indirect call pattern (table[idx] - offset)
        if ( e->op == cot_sub ) {
            cexpr_t *right = e->y;
            if ( right && right->op == cot_num ) {
                info.offset = right->numval();
                if ( info.offset > 0x10000 ) {
                    info.is_dispatcher = true;
                    ctree_icall_debug("[dispatcher] Found sub with offset 0x%llx\n",
                                      (unsigned long long)info.offset);
                }
            }
        }
        
        return 0;
    }
};

// Analyze a dispatcher function at assembly level to extract comparison and offset
struct asm_dispatcher_info_t {
    bool valid;
    uint32_t cmp_value;     // Value compared with first arg
    bool is_equal_cmp;      // true = setz (==), false = setl (<)
    int64_t offset;         // Computed offset (negated XOR result)
};

static asm_dispatcher_info_t analyze_dispatcher_asm(ea_t func_addr)
{
    asm_dispatcher_info_t info = {false, 0, false, 0};
    
    func_t *func = get_func(func_addr);
    if ( !func) return info;
    
    ea_t ea = func->start_ea;
    ea_t end = func->end_ea;
    
    uint32_t xor_operand = 0;
    ea_t dword_addr = 0;
    
    while ( ea < end ) {
        insn_t insn;
        if ( decode_insn(&insn, ea) <= 0) break;
        
        // Look for: cmp eax, XXXXXXXX
        if ( insn.itype == NN_cmp && insn.ops[0].type == o_reg && 
            insn.ops[0].reg == 0 && insn.ops[1].type == o_imm)
            {
            info.cmp_value = (uint32_t)insn.ops[1].value;
            ctree_icall_debug("[asm_disp] Found cmp eax, 0x%x\n", info.cmp_value);
        }
        
        // Look for: sete/setl cl (sete = set if equal, setl = set if less)
        if ( (insn.itype == NN_sete || insn.itype == NN_setne || 
             insn.itype == NN_setl || insn.itype == NN_setge) && 
            insn.ops[0].type == o_reg && insn.ops[0].reg == 1)
            {
            info.is_equal_cmp = (insn.itype == NN_sete);
            ctree_icall_debug("[asm_disp] Found %s cl\n", 
                              info.is_equal_cmp ? "setz" : "setl/other");
        }
        
        // Look for: mov esi/ecx, cs:dword_XXXXX (the encrypted offset)
        if ( insn.itype == NN_mov && insn.ops[0].type == o_reg &&
            insn.ops[1].type == o_mem)
            {
            dword_addr = insn.ops[1].addr;
            ctree_icall_debug("[asm_disp] Found mov from dword_0x%llx\n", (unsigned long long)dword_addr);
        }
        
        // Look for: mov edi/edx, XXXXXXXX (the XOR operand, right before xor)
        if ( insn.itype == NN_mov && insn.ops[0].type == o_reg &&
            insn.ops[1].type == o_imm && insn.ops[1].value > 0x10000)
            {
            xor_operand = (uint32_t)insn.ops[1].value;
            ctree_icall_debug("[asm_disp] Found mov with XOR operand 0x%x\n", xor_operand);
        }
        
        ea = next_head(ea, end);
    }
    
    // Compute the offset if we found the encrypted value
    if ( dword_addr != 0 && xor_operand != 0 ) {
        uint32_t dword_val = get_dword(dword_addr);
        uint32_t xored = dword_val ^ xor_operand;
        // neg = two's complement
        info.offset = -(int32_t)xored;
        info.valid = true;
        ctree_icall_debug("[asm_disp] Computed offset: dword=0x%x ^ 0x%x = 0x%x, neg = %lld\n",
                          dword_val, xor_operand, xored, (long long)info.offset);
    }
    
    return info;
}

// Try to resolve the next level of a chained indirect call using ASM analysis
static ea_t resolve_dispatcher_chain(ea_t initial_target, const carglist_t &args, int max_depth = 3)
{
    ea_t current = initial_target;
    
    for ( int depth = 0; depth < max_depth; depth++ ) {
        ctree_icall_debug("[chain] Depth %d: analyzing 0x%llx\n", depth, (unsigned long long)current);
        
        // Ensure it's a function
        if ( !get_func(current) ) {
            if ( !add_func(current)) break;
        }
        
        // Analyze at assembly level
        asm_dispatcher_info_t disp_info = analyze_dispatcher_asm(current);
        if ( !disp_info.valid ) {
            ctree_icall_debug("[chain] 0x%llx is not a recognized dispatcher\n", (unsigned long long)current);
            break;
        }
        
        // Determine table index from first argument
        int table_index = 0;
        if ( args.size() > 0 && args[0].op == cot_num ) {
            uint64_t arg_val = args[0].numval();
            bool cmp_result;
            if ( disp_info.is_equal_cmp ) {
                cmp_result = ((uint32_t)arg_val == disp_info.cmp_value);
            } else {
                cmp_result = ((int32_t)arg_val < (int32_t)disp_info.cmp_value);
            }
            table_index = cmp_result ? 1 : 0;
            ctree_icall_debug("[chain] arg=0x%llx, cmp with 0x%x -> %s, idx=%d\n",
                              (unsigned long long)arg_val, disp_info.cmp_value,
                              cmp_result ? "true" : "false", table_index);
        }
        
        // The dispatcher reads table from stack - we need to find which table
        // For now, try to find a table where table[index] - offset is valid code
        ea_t next_target = BADADDR;
        segment_t *seg = get_first_seg();
        while ( seg ) {
            if ( seg->type == SEG_DATA ) {
                ea_t ea = seg->start_ea;
                while ( ea < seg->end_ea ) {
                    ea_t entry_addr = ea + table_index * 8;
                    if ( entry_addr < seg->end_ea ) {
                        uint64_t entry_val = 0;
                        if ( get_bytes(&entry_val, 8, entry_addr) == 8 && entry_val != 0 ) {
                            ea_t target = (ea_t)((int64_t)entry_val + disp_info.offset);
                            if ( target > 0x100000000LL && target < 0x200000000LL ) {
                                if ( is_code(get_flags(target)) || get_func(target) ) {
                                    next_target = target;
                                    ctree_icall_debug("[chain] Found: table[%d]=0x%llx + %lld = 0x%llx\n",
                                                      table_index, (unsigned long long)entry_val,
                                                      (long long)disp_info.offset,
                                                      (unsigned long long)target);
                                    break;
                                }
                            }
                        }
                    }
                    ea = next_head(ea, seg->end_ea);
                    if ( ea == BADADDR) break;
                }
            }
            if ( next_target != BADADDR) break;
            seg = get_next_seg(seg->start_ea);
        }
        
        if ( next_target == BADADDR ) {
            ctree_icall_debug("[chain] Could not resolve next target\n");
            break;
        }
        
        current = next_target;
    }
    
    return current;
}

//--------------------------------------------------------------------------
// Visitor to find indirect call patterns in ctree
//--------------------------------------------------------------------------
struct indirect_call_finder_t : public ctree_visitor_t {
    cfunc_t *cfunc;
    std::vector<cexpr_t*> found_patterns;
    
    indirect_call_finder_t(cfunc_t *cf) : ctree_visitor_t(CV_FAST), cfunc(cf) {}
    
    int idaapi visit_expr(cexpr_t *e) override {
        // Look for: call(expr) where expr is a cast of (ptr - constant)
        if ( e->op == cot_call ) {
            cexpr_t *callee = e->x;
            if ( !callee) return 0;
            
            ctree_icall_debug("[ctree_icall] Found call, callee op=%d\n", callee->op);
            
            // The callee might be: (func_type*)(table[idx] - offset)
            // Which in ctree is: cast(sub(idx(ptr, idx), const))
            
            // Unwrap cast if present
            while ( callee->op == cot_cast ) {
                callee = callee->x;
            }
            
            ctree_icall_debug("[ctree_icall]   After unwrap cast: op=%d\n", callee->op);
            
            // Look for subtraction: something - constant
            if ( callee->op == cot_sub ) {
                cexpr_t *left = callee->x;
                cexpr_t *right = callee->y;
                
                ctree_icall_debug("[ctree_icall]   sub: left op=%d, right op=%d\n", 
                                  left ? left->op : -1, right ? right->op : -1);
                
                // Check if right is a constant
                if ( right && right->op == cot_num ) {
                    int64_t offset = right->numval();
                    ctree_icall_debug("[ctree_icall]   Offset: %lld (0x%llx)\n", 
                                      (long long)offset, (unsigned long long)offset);
                    
                    // Unwrap casts from left operand
                    while ( left && left->op == cot_cast ) {
                        left = left->x;
                    }
                    ctree_icall_debug("[ctree_icall]   Left after cast unwrap: op=%d\n", left ? left->op : -1);
                    
                    // Check if left is array indexing: ptr[idx]
                    if ( left && left->op == cot_idx ) {
                        cexpr_t *base = left->x;
                        cexpr_t *idx_expr = left->y;
                        
                        ctree_icall_debug("[ctree_icall]   idx: base op=%d, idx op=%d\n",
                                          base ? base->op : -1, idx_expr ? idx_expr->op : -1);
                        
                        // Get the base pointer (should be &global or deref of global)
                        // For Hikari, it's often: v3 = &off_XXX; then v3[idx] - offset
                        // So we may need to trace through a local variable
                        ea_t table_addr = BADADDR;
                        
                        if ( base && base->op == cot_obj ) {
                            table_addr = base->obj_ea;
                            ctree_icall_debug("[ctree_icall]   Base is obj at 0x%llx\n",
                                              (unsigned long long)table_addr);
                        } else if ( base && base->op == cot_cast && base->x && base->x->op == cot_obj ) {
                            table_addr = base->x->obj_ea;
                            ctree_icall_debug("[ctree_icall]   Base is cast of obj at 0x%llx\n",
                                              (unsigned long long)table_addr);
                        } else if ( base && base->op == cot_var ) {
                            // Base is a local variable - look for assignment from global
                            ctree_icall_debug("[ctree_icall]   Base is var (idx=%d), looking for table...\n",
                                              base->v.idx);
                            
                            // Strategy: Find a table where table[index] - offset gives valid code
                            // We know the index and offset, so we can validate candidates
                            int64_t search_index = -1;
                            if ( idx_expr && idx_expr->op == cot_num ) {
                                search_index = idx_expr->numval();
                            }
                            
                            // Scan data segments for code pointer tables
                            segment_t *seg = get_first_seg();
                            while ( seg && table_addr == BADADDR ) {
                                if ( seg->type == SEG_DATA ) {
                                    ea_t ea = seg->start_ea;
                                    while ( ea < seg->end_ea && table_addr == BADADDR ) {
                                        // Check if table[search_index] - offset would be valid code
                                        if ( search_index >= 0 ) {
                                            ea_t entry_addr = ea + search_index * 8;
                                            if ( entry_addr < seg->end_ea ) {
                                                uint64_t entry_val = 0;
                                                if ( get_bytes(&entry_val, 8, entry_addr) == 8 && entry_val != 0 ) {
                                                    ea_t target = (ea_t)(entry_val - offset);
                                                    if ( is_code(get_flags(target)) || get_func(target) ) {
                                                        // This looks like a valid table!
                                                        // Verify first entry is also code pointer
                                                        uint64_t first_val = 0;
                                                        if ( get_bytes(&first_val, 8, ea) == 8 && first_val != 0 ) {
                                                            if ( is_code(get_flags((ea_t)first_val)) || get_func((ea_t)first_val) ) {
                                                                table_addr = ea;
                                                                ctree_icall_debug("[ctree_icall]   Found valid table at 0x%llx (entry[%lld]=0x%llx, target=0x%llx)\n",
                                                                                  (unsigned long long)ea, (long long)search_index,
                                                                                  (unsigned long long)entry_val, (unsigned long long)target);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        ea = next_head(ea, seg->end_ea);
                                        if ( ea == BADADDR) break;
                                    }
                                }
                                seg = get_next_seg(seg->start_ea);
                            }
                        }
                        
                        // Get the index
                        int64_t index = -1;
                        if ( idx_expr && idx_expr->op == cot_num ) {
                            index = idx_expr->numval();
                            ctree_icall_debug("[ctree_icall]   Index: %lld\n", (long long)index);
                        }
                        
                        // If we have table + index + offset, we can resolve!
                        if ( table_addr != BADADDR && index >= 0 && offset > 0x10000 ) {
                            ctree_icall_debug("[ctree_icall]   PATTERN FOUND: table=0x%llx, idx=%lld, off=%lld\n",
                                              (unsigned long long)table_addr, (long long)index, (long long)offset);
                            found_patterns.push_back(e);
                        }
                    }
                }
            }
        }
        return 0;
    }
};

//--------------------------------------------------------------------------
// Detection
//--------------------------------------------------------------------------
bool ctree_indirect_call_handler_t::detect(cfunc_t *cfunc)
{
    if ( !cfunc || !cfunc->body.cblock ) 
        return false;
    
    ctree_icall_debug("[ctree_icall] detect() called for func 0x%llx\n",
                      (unsigned long long)cfunc->entry_ea);
    
    indirect_call_finder_t finder(cfunc);
    finder.apply_to(&cfunc->body, nullptr);
    
    ctree_icall_debug("[ctree_icall] Found %zu patterns\n", finder.found_patterns.size());
    return !finder.found_patterns.empty();
}

//--------------------------------------------------------------------------
// Run resolution
//--------------------------------------------------------------------------
int ctree_indirect_call_handler_t::run(cfunc_t *cfunc, deobf_ctx_t *ctx)
{
    if ( !cfunc || !cfunc->body.cblock ) 
        return 0;
    
    ctree_icall_debug("[ctree_icall] run() called for func 0x%llx\n",
                      (unsigned long long)cfunc->entry_ea);
    
    indirect_call_finder_t finder(cfunc);
    finder.apply_to(&cfunc->body, nullptr);
    
    int changes = 0;
    
    ctree_icall_debug("[ctree_icall] Processing %zu found patterns\n", finder.found_patterns.size());
    
    for ( cexpr_t *call_expr : finder.found_patterns ) {
        ctree_icall_debug("[ctree_icall] Processing pattern at 0x%llx\n", (unsigned long long)call_expr->ea);
        
        // Extract the pattern components
        cexpr_t *callee = call_expr->x;
        while ( callee && callee->op == cot_cast ) 
            callee = callee->x;
        
        ctree_icall_debug("[ctree_icall]   Callee after unwrap: op=%d (cot_sub=%d)\n", callee ? callee->op : -1, cot_sub);
        
        if ( !callee || callee->op != cot_sub ) {
            ctree_icall_debug("[ctree_icall]   Skipped: callee not sub\n");
            continue;
        }
        
        ctree_icall_debug("[ctree_icall]   Found sub!\n");
        
        cexpr_t *idx_expr = callee->x;  // table[idx]
        cexpr_t *offset_expr = callee->y;  // constant offset
        
        ctree_icall_debug("[ctree_icall]   idx_expr op=%d, offset_expr op=%d\n",
                          idx_expr ? idx_expr->op : -1, offset_expr ? offset_expr->op : -1);
        
        // Unwrap casts from idx_expr
        while ( idx_expr && idx_expr->op == cot_cast ) 
            idx_expr = idx_expr->x;
        
        ctree_icall_debug("[ctree_icall]   idx_expr after unwrap: op=%d (cot_idx=%d)\n",
                          idx_expr ? idx_expr->op : -1, cot_idx);
        
        if ( !idx_expr || idx_expr->op != cot_idx ) {
            ctree_icall_debug("[ctree_icall]   Skipped: idx_expr not cot_idx\n");
            continue;
        }
        
        // Unwrap casts from idx_expr
        while ( idx_expr && idx_expr->op == cot_cast ) 
            idx_expr = idx_expr->x;
        
        if ( !idx_expr || idx_expr->op != cot_idx ) 
            continue;
        
        cexpr_t *base = idx_expr->x;
        cexpr_t *index = idx_expr->y;
        
        // Get index
        int64_t idx_val = -1;
        if ( index && index->op == cot_num ) 
            idx_val = index->numval();
        
        // Get offset
        int64_t offset_val = offset_expr->numval();
        
        // Get table address
        ea_t table_addr = BADADDR;
        if ( base && base->op == cot_obj ) {
            table_addr = base->obj_ea;
        } else if ( base && base->op == cot_cast && base->x && base->x->op == cot_obj ) {
            table_addr = base->x->obj_ea;
        } else if ( base && base->op == cot_var && idx_val >= 0 && offset_val > 0x10000 ) {
            // Variable case - scan for matching table
            segment_t *seg = get_first_seg();
            while ( seg && table_addr == BADADDR ) {
                if ( seg->type == SEG_DATA ) {
                    ea_t ea = seg->start_ea;
                    while ( ea < seg->end_ea && table_addr == BADADDR ) {
                        ea_t entry_addr = ea + idx_val * 8;
                        if ( entry_addr < seg->end_ea ) {
                            uint64_t entry_val = 0;
                            if ( get_bytes(&entry_val, 8, entry_addr) == 8 && entry_val != 0 ) {
                                ea_t target = (ea_t)(entry_val - offset_val);
                                if ( is_code(get_flags(target)) || get_func(target) ) {
                                    uint64_t first_val = 0;
                                    if ( get_bytes(&first_val, 8, ea) == 8 && first_val != 0 ) {
                                        if ( is_code(get_flags((ea_t)first_val)) || get_func((ea_t)first_val) ) {
                                            table_addr = ea;
                                        }
                                    }
                                }
                            }
                        }
                        ea = next_head(ea, seg->end_ea);
                        if ( ea == BADADDR) break;
                    }
                }
                seg = get_next_seg(seg->start_ea);
            }
        }
        
        if ( table_addr == BADADDR || idx_val < 0 ) 
            continue;
        
        // Compute target
        ea_t target = compute_call_target(table_addr, idx_val, offset_val);
        if ( target == BADADDR ) 
            continue;
        
        // Ensure target is a function - create one if needed
        func_t *target_func = get_func(target);
        if ( !target_func ) {
            // Target is orphan code - create a function
            if ( add_func(target) ) {
                ctree_icall_debug("[ctree_icall] Created function at target 0x%llx\n",
                                  (unsigned long long)target);
                target_func = get_func(target);
            } else {
                ctree_icall_debug("[ctree_icall] Failed to create function at 0x%llx\n",
                                  (unsigned long long)target);
            }
        } else if ( target_func->start_ea != target ) {
            // Target is mid-function - this might be a jump into another function
            ctree_icall_debug("[ctree_icall] Target 0x%llx is inside func 0x%llx (+0x%llx)\n",
                              (unsigned long long)target,
                              (unsigned long long)target_func->start_ea,
                              (unsigned long long)(target - target_func->start_ea));
        }
        
        // Get the target function name
        qstring target_name;
        get_name(&target_name, target);
        
        ctree_icall_debug("[ctree_icall] Initial target: table[%lld] - %lld = 0x%llx (%s)\n",
                          (long long)idx_val, (long long)offset_val, 
                          (unsigned long long)target, target_name.c_str());
        
        // Try to resolve through dispatcher chain if the target is another dispatcher
        // Extract call arguments to pass to chain resolver
        ea_t final_target = target;
        if ( call_expr->a && call_expr->a->size() > 0 ) {
            final_target = resolve_dispatcher_chain(target, *call_expr->a);
            if ( final_target != target ) {
                // Ensure final target is also a function
                if ( !get_func(final_target) ) {
                    add_func(final_target);
                }
                get_name(&target_name, final_target);
                ctree_icall_debug("[ctree_icall] Chain resolved to: 0x%llx (%s)\n",
                                  (unsigned long long)final_target, target_name.c_str());
            }
        }
        target = final_target;
        
        // Replace the call target with a direct reference to the resolved function
        // The call expression is: call(complex_expr, args...)
        // We want to change it to: call(target_func, args...)
        
        // Get the original callee to preserve its type info
        cexpr_t *old_callee = call_expr->x;
        tinfo_t callee_type = old_callee->type;
        
        // Create a cot_obj expression that references the target function directly
        // This is the correct way to represent a direct function reference in ctree
        cexpr_t *new_callee = new cexpr_t();
        new_callee->op = cot_obj;
        new_callee->obj_ea = target;
        new_callee->exflags = 0;
        new_callee->ea = call_expr->ea;  // Use call's EA for the callee
        
        // Get the type of the target function if available
        tinfo_t func_type;
        if ( get_tinfo(&func_type, target) ) {
            // Make it a pointer to the function type for the call expression
            tinfo_t ptr_type;
            ptr_type.create_ptr(func_type);
            new_callee->type = ptr_type;
            ctree_icall_debug("[ctree_icall] Got function type for target\n");
        } else {
            // Fall back to the original callee type
            new_callee->type = callee_type;
            ctree_icall_debug("[ctree_icall] Using original callee type\n");
        }
        
        // Replace the callee in the call expression
        call_expr->x = new_callee;
        
        ctree_icall_debug("[ctree_icall] Replaced callee with cot_obj to 0x%llx (%s)\n", 
                          (unsigned long long)target, target_name.c_str());
        
        // Also add a comment for documentation
        qstring comment;
        comment.sprnt("DEOBF: Resolved indirect call -> %s (0x%llX)", 
                      target_name.c_str(), (unsigned long long)target);
        set_cmt(call_expr->ea, comment.c_str(), false);
        
        changes++;
        if ( ctx ) 
            ctx->indirect_resolved++;
    }
    
    ctree_icall_debug("[ctree_icall] Total changes: %d\n", changes);
    return changes;
}

//--------------------------------------------------------------------------
// Check if expression matches the pattern
//--------------------------------------------------------------------------
bool ctree_indirect_call_handler_t::match_pattern(cexpr_t *expr, ea_t *out_table, 
                                                   int64_t *out_index, int64_t *out_offset)
                                                   {
    // Implementation in the visitor above
    return false;
}

//--------------------------------------------------------------------------
// Compute call target from table entry
//--------------------------------------------------------------------------
ea_t ctree_indirect_call_handler_t::compute_call_target(ea_t table_addr, int64_t index, int64_t offset)
{
    ea_t entry_addr = table_addr + index * 8;  // 64-bit entries
    uint64_t entry_val = 0;
    
    if ( get_bytes(&entry_val, 8, entry_addr) != 8 ) {
        ctree_icall_debug("[ctree_icall] Failed to read table entry at 0x%llx\n",
                          (unsigned long long)entry_addr);
        return BADADDR;
    }
    
    ea_t target = (ea_t)(entry_val - offset);
    
    ctree_icall_debug("[ctree_icall] table[%lld] = 0x%llx, - %lld = 0x%llx\n",
                      (long long)index, (unsigned long long)entry_val, 
                      (long long)offset, (unsigned long long)target);
    
    // Validate target is code
    if ( !is_code(get_flags(target)) ) {
        func_t *func = get_func(target);
        if ( !func ) {
            ctree_icall_debug("[ctree_icall] Target 0x%llx is not code\n", 
                              (unsigned long long)target);
            return BADADDR;
        }
    }
    
    return target;
}

```

`src/deobf/handlers/ctree_indirect_call.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// CTree-level Indirect Call Resolution
//
// At ctree level, Hikari's IndirectCall pattern is clearly visible:
//   ((func_ptr)(table[index] - offset))(args...)
//
// We can match this pattern and replace with a direct call.
//--------------------------------------------------------------------------

// Detection only - doesn't modify at ctree level
class ctree_indirect_call_handler_t {
public:
    // Detect pattern at ctree level (called from hxe_maturity callback)
    static bool detect(cfunc_t *cfunc);
    
    // Run resolution (modifies cfunc)
    static int run(cfunc_t *cfunc, deobf_ctx_t *ctx);

private:
    // Check if expression is table[index] - offset pattern
    static bool match_pattern(cexpr_t *expr, ea_t *out_table, int64_t *out_index, int64_t *out_offset);
    
    // Read table entry and compute target
    static ea_t compute_call_target(ea_t table_addr, int64_t index, int64_t offset);
};

```

`src/deobf/handlers/ctree_string_decrypt.cpp`:

```cpp
#include "ctree_string_decrypt.h"
#include "../analysis/pattern_match.h"

//--------------------------------------------------------------------------
// Platform-specific crypto support
//--------------------------------------------------------------------------
#ifdef __APPLE__
#include <CommonCrypto/CommonCrypto.h>
#define HAS_COMMONCRYPTO 1
#else
#define HAS_COMMONCRYPTO 0
#endif

#ifndef kCCOptionECBMode
#define kCCOptionECBMode 0x0002
#endif

#ifndef kCCOptionPKCS7Padding
#define kCCOptionPKCS7Padding 0x0001
#endif

//--------------------------------------------------------------------------
// Debug logging
//--------------------------------------------------------------------------
#include "../../common/compat.h"

static void ctree_str_debug(const char *fmt, ...)
{
#ifndef _WIN32
    char buf[4096];
    va_list args;
    va_start(args, fmt);
    int len = qvsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);
    
    int fd = open("/tmp/ctree_string_debug.log", O_WRONLY | O_CREAT | O_APPEND, 0644);
    if ( fd >= 0 ) {
        write(fd, buf, len);
        close(fd);
    }
#else
    (void)fmt;
#endif
}

//--------------------------------------------------------------------------
// Base64 helpers
//--------------------------------------------------------------------------
static bool is_base64_char(uint8_t c)
{
    return (c >= 'A' && c <= 'Z') ||
           (c >= 'a' && c <= 'z') ||
           (c >= '0' && c <= '9') ||
           c == '+' || c == '/';
}

static bool looks_like_base64(const uint8_t *data, size_t len)
{
    if ( !data || len < 8 ) 
        return false;

    size_t end = len;
    while ( end > 0 && data[end - 1] == 0 ) 
        end--;

    if ( end < 8 || (end % 4) != 0 ) 
        return false;

    bool saw_pad = false;
    size_t pad_count = 0;
    for ( size_t i = 0; i < end; ++i ) {
        uint8_t c = data[i];
        if ( c == '=' ) {
            saw_pad = true;
            pad_count++;
            continue;
        }
        if ( saw_pad ) 
            return false;
        if ( !is_base64_char(c) ) 
            return false;
    }

    return pad_count <= 2;
}

static int base64_value(uint8_t c)
{
    if ( c >= 'A' && c <= 'Z' ) 
        return c - 'A';
    if ( c >= 'a' && c <= 'z' ) 
        return c - 'a' + 26;
    if ( c >= '0' && c <= '9' ) 
        return c - '0' + 52;
    if ( c == '+' ) 
        return 62;
    if ( c == '/' ) 
        return 63;
    if ( c == '=' ) 
        return -2;
    return -1;
}

static bool decode_base64(const uint8_t *data, size_t len, std::vector<uint8_t> *out)
{
    if ( !data || !out ) 
        return false;

    out->clear();

    size_t end = len;
    while ( end > 0 && data[end - 1] == 0 ) 
        end--;

    if ( end == 0 || (end % 4) != 0 ) 
        return false;

    for ( size_t i = 0; i < end; i += 4 ) {
        int v0 = base64_value(data[i]);
        int v1 = base64_value(data[i + 1]);
        int v2 = base64_value(data[i + 2]);
        int v3 = base64_value(data[i + 3]);

        if ( v0 < 0 || v1 < 0 ) 
            return false;
        if ( v2 == -1 || v3 == -1 ) 
            return false;
        if ( v2 == -2 && v3 != -2 ) 
            return false;

        uint32_t triple = ((uint32_t)v0 << 18) | ((uint32_t)v1 << 12);
        if ( v2 >= 0 ) 
            triple |= ((uint32_t)v2 << 6);
        if ( v3 >= 0 ) 
            triple |= (uint32_t)v3;

        out->push_back((triple >> 16) & 0xFF);
        if ( v2 >= 0 ) 
            out->push_back((triple >> 8) & 0xFF);
        if ( v3 >= 0 ) 
            out->push_back(triple & 0xFF);
    }

    return !out->empty();
}

//--------------------------------------------------------------------------
// AES Decryption Support
//--------------------------------------------------------------------------
#if HAS_COMMONCRYPTO

// AES-CBC/ECB decryption using CommonCrypto
// Returns decrypted data, empty on failure
static std::vector<uint8_t> aes_decrypt(
    const std::vector<uint8_t> &ciphertext,
    const std::vector<uint8_t> &key,
    const std::vector<uint8_t> &iv,
    bool pkcs7_padding,
    bool use_ecb)
{
    std::vector<uint8_t> plaintext;
    
    if ( ciphertext.empty() || key.empty() ) 
        return plaintext;
    
    // Validate key size (16=AES-128, 24=AES-192, 32=AES-256)
    size_t key_size = key.size();
    if ( key_size != kCCKeySizeAES128 && 
        key_size != kCCKeySizeAES192 && 
        key_size != kCCKeySizeAES256)
        {
        ctree_str_debug("[aes] Invalid key size: %zu\n", key_size);
        return plaintext;
    }
    
    // IV must be 16 bytes for AES-CBC
    if ( !use_ecb && !iv.empty() && iv.size() != kCCBlockSizeAES128 ) {
        ctree_str_debug("[aes] Invalid IV size: %zu (expected 16)\n", iv.size());
        return plaintext;
    }
    
    // Allocate output buffer (same size as input + block for padding)
    size_t out_size = ciphertext.size() + kCCBlockSizeAES128;
    plaintext.resize(out_size);
    size_t decrypted_size = 0;
    
    int options = pkcs7_padding ? kCCOptionPKCS7Padding : 0;
    if ( use_ecb ) 
        options |= kCCOptionECBMode;

    CCCryptorStatus status = CCCrypt(
        kCCDecrypt,
        kCCAlgorithmAES,
        options,
        key.data(), key_size,
        use_ecb ? nullptr : (iv.empty() ? nullptr : iv.data()),
        ciphertext.data(), ciphertext.size(),
        plaintext.data(), out_size,
        &decrypted_size
);
    
    if ( status != kCCSuccess ) {
        ctree_str_debug("[aes] Decryption failed with status: %d\n", status);
        plaintext.clear();
        return plaintext;
    }
    
    plaintext.resize(decrypted_size);
    ctree_str_debug("[aes] Decrypted %zu bytes successfully (ecb=%d)\n",
                   decrypted_size, use_ecb ? 1 : 0);
    return plaintext;
}

// Try to decrypt data at an address using extracted key/IV
static bool try_aes_decrypt_at_address(
    ea_t data_addr,
    size_t data_len,
    const std::vector<uint8_t> &key,
    const std::vector<uint8_t> &iv,
    bool pkcs7_padding,
    bool use_ecb,
    qstring *out_plaintext)
{
    if ( data_addr == BADADDR || data_len == 0 || !out_plaintext ) 
        return false;
    
    // Read encrypted data from binary
    std::vector<uint8_t> ciphertext(data_len);
    if ( get_bytes(ciphertext.data(), data_len, data_addr) != data_len ) {
        ctree_str_debug("[aes] Failed to read %zu bytes from 0x%llx\n", 
                       data_len, (unsigned long long)data_addr);
        return false;
    }
    
    if ( looks_like_base64(ciphertext.data(), ciphertext.size()) ) {
        std::vector<uint8_t> decoded;
        if ( decode_base64(ciphertext.data(), ciphertext.size(), &decoded) &&
            (decoded.size() % kCCBlockSizeAES128) == 0)
            {
            ciphertext.swap(decoded);
            ctree_str_debug("[aes] Base64-decoded ciphertext (%zu bytes)\n", ciphertext.size());
        }
    }

    bool iv_all_zero = iv.empty();
    if ( !iv_all_zero ) {
        iv_all_zero = true;
        for ( uint8_t b : iv ) {
            if ( b != 0 ) {
                iv_all_zero = false;
                break;
            }
        }
    }

    // Try decryption
    std::vector<uint8_t> plaintext = aes_decrypt(ciphertext, key, iv, pkcs7_padding, use_ecb);
    if ( plaintext.empty() ) {
        if ( use_ecb && !iv.empty() ) {
            plaintext = aes_decrypt(ciphertext, key, iv, pkcs7_padding, false);
        } else if ( !use_ecb && iv_all_zero ) {
            plaintext = aes_decrypt(ciphertext, key, iv, pkcs7_padding, true);
        }
    }
    if ( plaintext.empty() ) 
        return false;
    
    // Check if result looks like valid text
    bool is_printable = true;
    for ( size_t i = 0; i < plaintext.size() && i < 256; ++i ) {
        uint8_t c = plaintext[i];
        if ( c == 0) break;  // Null terminator is ok
        if ( c < 0x20 || c > 0x7E ) {
            if ( c != '\n' && c != '\r' && c != '\t' ) {
                is_printable = false;
                break;
            }
        }
    }
    
    if ( is_printable && !plaintext.empty() ) {
        // Find null terminator or end
        size_t str_len = 0;
        for ( size_t i = 0; i < plaintext.size(); ++i ) {
            if ( plaintext[i] == 0) break;
            str_len++;
        }
        out_plaintext->append((const char*)plaintext.data(), str_len);
        return true;
    }
    
    return false;
}

#else
// No CommonCrypto - stub implementations
static std::vector<uint8_t> aes_decrypt(
    const std::vector<uint8_t> &ciphertext,
    const std::vector<uint8_t> &key,
    const std::vector<uint8_t> &iv,
    bool pkcs7_padding,
    bool use_ecb)
{
    ctree_str_debug("[aes] CommonCrypto not available on this platform\n");
    return {};
}

static bool try_aes_decrypt_at_address(
    ea_t data_addr,
    size_t data_len,
    const std::vector<uint8_t> &key,
    const std::vector<uint8_t> &iv,
    bool pkcs7_padding,
    bool use_ecb,
    qstring *out_plaintext)
{
    return false;
}
#endif

//--------------------------------------------------------------------------
// Visitor to find string function calls (strcpy, memcpy, etc.)
//--------------------------------------------------------------------------
struct string_call_visitor_t : public ctree_visitor_t {
    cfunc_t *cfunc;
    std::vector<ctree_string_decrypt_handler_t::string_reveal_t> reveals;
    std::vector<ctree_string_decrypt_handler_t::crypto_call_t> crypto_calls;
    
    string_call_visitor_t(cfunc_t *cf) : ctree_visitor_t(CV_FAST), cfunc(cf) {}
    
    int idaapi visit_expr(cexpr_t *e) override {
        if ( e->op != cot_call ) 
            return 0;
            
        // Get the called function
        cexpr_t *callee = e->x;
        if ( !callee ) 
            return 0;
            
        qstring func_name;
        if ( !get_func_name(&func_name, callee) ) 
            return 0;
            
        // Check for string copy functions (including __strcpy_chk, ___strcpy_chk variants)
        // Use substring matching to handle all underscore prefix/suffix variations
        if ( func_name.find("strcpy") != qstring::npos ||
            func_name.find("strncpy") != qstring::npos ||
            func_name.find("strlcpy") != qstring::npos)
            {
            process_strcpy(e, func_name);
        }
        else if ( func_name.find("memcpy") != qstring::npos ||
                 func_name.find("memmove") != qstring::npos ||
                 func_name.find("qmemcpy") != qstring::npos ||
                 func_name.find("bcopy") != qstring::npos ||
                 func_name.find("memset") != qstring::npos)
                 {
            process_memcpy(e, func_name);
        }
        else if ( func_name.find("CCCrypt") != qstring::npos ||
                 func_name.find("AES_decrypt") != qstring::npos ||
                 func_name.find("AES_cbc_encrypt") != qstring::npos ||
                 func_name.find("EVP_Decrypt") != qstring::npos ||
                 func_name.find("EVP_Cipher") != qstring::npos)
                 {
            process_crypto_call(e, func_name);
        }
        
        return 0;
    }
    
private:
    bool get_func_name(qstring *out, cexpr_t *callee)
    {
        if ( callee->op == cot_obj ) {
            // Direct function reference
            if ( get_name(out, callee->obj_ea) > 0 ) 
                return true;
        }
        else if ( callee->op == cot_helper ) {
            // Helper function
            *out = callee->helper;
            return true;
        }
        return false;
    }
    
    void process_strcpy(cexpr_t *call, const qstring &func_name)
    {
        // strcpy(dest, src)
        carglist_t *args = call->a;
        if ( !args || args->size() < 2 ) 
            return;
            
        cexpr_t *dest = &(*args)[0];
        cexpr_t *src = &(*args)[1];
        
        // Check if source is a string constant
        qstring str_val;
        if ( !extract_string_constant(src, &str_val) ) 
            return;
            
        ctree_string_decrypt_handler_t::string_reveal_t reveal;
        reveal.location = call->ea;
        reveal.plaintext = str_val;
        reveal.reveal_type = 0;  // strcpy
        
        // Try to get destination info
        if ( dest->op == cot_var ) {
            lvars_t *lvars = cfunc->get_lvars();
            if ( lvars && dest->v.idx < lvars->size() ) {
                reveal.dest_name = (*lvars)[dest->v.idx].name;
            }
        } else if ( dest->op == cot_obj ) {
            reveal.dest_addr = dest->obj_ea;
            get_name(&reveal.dest_name, dest->obj_ea);
        }
        
        ctree_str_debug("[strcpy] Found: %s -> \"%s\"\n", 
                       reveal.dest_name.c_str(), str_val.c_str());
        
        reveals.push_back(reveal);
    }
    
    void process_memcpy(cexpr_t *call, const qstring &func_name)
    {
        // memcpy(dest, src, size)
        carglist_t *args = call->a;
        if ( !args || args->size() < 3 ) 
            return;
            
        cexpr_t *dest = &(*args)[0];
        cexpr_t *src = &(*args)[1];
        cexpr_t *size = &(*args)[2];
        
        // Check if source is a string constant
        qstring str_val;
        if ( !extract_string_constant(src, &str_val) ) 
            return;
            
        // Verify size matches (or close to it)
        if ( size->op == cot_num ) {
            uint64_t sz = size->numval();
            if ( sz > 0 && sz < 4096 && sz >= str_val.length() ) {
                // Size looks reasonable
            }
        }
        
        ctree_string_decrypt_handler_t::string_reveal_t reveal;
        reveal.location = call->ea;
        reveal.plaintext = str_val;
        reveal.reveal_type = 1;  // memcpy
        
        // Try to get destination info
        if ( dest->op == cot_var ) {
            lvars_t *lvars = cfunc->get_lvars();
            if ( lvars && dest->v.idx < lvars->size() ) {
                reveal.dest_name = (*lvars)[dest->v.idx].name;
            }
        } else if ( dest->op == cot_obj ) {
            reveal.dest_addr = dest->obj_ea;
            get_name(&reveal.dest_name, dest->obj_ea);
        }
        
        ctree_str_debug("[memcpy] Found: %s -> \"%s\" (len=%zu)\n",
                       reveal.dest_name.c_str(), str_val.c_str(), str_val.length());
        
        reveals.push_back(reveal);
    }
    
    void process_crypto_call(cexpr_t *call, const qstring &func_name)
    {
        // CCCrypt(op, alg, options, key, keyLen, iv, dataIn, dataInLen, dataOut, dataOutAvail, dataOutMoved)
        // Args:  0    1      2      3     4     5     6        7        8          9            10
        carglist_t *args = call->a;
        if ( !args ) 
            return;
            
        ctree_string_decrypt_handler_t::crypto_call_t crypto;
        crypto.location = call->ea;
        crypto.function = func_name;
        crypto.input_addr = BADADDR;
        crypto.input_len = 0;
        crypto.output_addr = BADADDR;
        
        if ( func_name == "CCCrypt" || func_name == "_CCCrypt" ) {
            if ( args->size() >= 8 ) {
                bool is_decrypt = true;
                bool is_aes = true;
                bool use_ecb = false;
                bool use_pkcs7 = true;

                if ( args->size() >= 1 && (*args)[0].op == cot_num ) {
                    uint64_t op_val = (*args)[0].numval();
                    is_decrypt = (op_val == 1);
                }
                if ( args->size() >= 2 && (*args)[1].op == cot_num ) {
                    uint64_t alg_val = (*args)[1].numval();
                    if ( alg_val != 0 ) 
                        is_aes = false;
                }
                if ( args->size() >= 3 && (*args)[2].op == cot_num ) {
                    uint64_t opts = (*args)[2].numval();
                    use_ecb = (opts & kCCOptionECBMode) != 0;
                    use_pkcs7 = (opts & kCCOptionPKCS7Padding) != 0;
                }

                // Get key (arg 3) and keyLen (arg 4)
                cexpr_t *key_arg = &(*args)[3];
                cexpr_t *keylen_arg = &(*args)[4];

                size_t key_len = 16;
                bool has_key_len = false;
                if ( keylen_arg->op == cot_num ) {
                    key_len = (size_t)keylen_arg->numval();
                    has_key_len = true;
                }

                // Try to extract key if it's a string constant or global
                qstring key_str;
                if ( extract_string_constant(key_arg, &key_str) ) {
                    std::vector<uint8_t> decoded;
                    bool used_decoded = false;
                    if ( looks_like_base64(reinterpret_cast<const uint8_t *>(key_str.c_str()),
                                          key_str.length()) &&
                        decode_base64(reinterpret_cast<const uint8_t *>(key_str.c_str()),
                                      key_str.length(), &decoded))
                                      {
                        if ( decoded.size() == 16 || decoded.size() == 24 || decoded.size() == 32 ) {
                            if ( !has_key_len || decoded.size() == key_len ) {
                                crypto.key = decoded;
                                used_decoded = true;
                            } else if ( has_key_len && decoded.size() < key_len && key_len <= 32 ) {
                                crypto.key = decoded;
                                crypto.key.resize(key_len, 0);
                                used_decoded = true;
                            }
                        }
                    }
                    if ( !used_decoded ) {
                        size_t copy_len = key_str.length();
                        if ( has_key_len && key_len < copy_len ) 
                            copy_len = key_len;
                        crypto.key.assign(reinterpret_cast<const uint8_t *>(key_str.c_str()),
                                          reinterpret_cast<const uint8_t *>(key_str.c_str()) + copy_len);
                        if ( has_key_len && key_len > copy_len && key_len <= 32 ) {
                            crypto.key.resize(key_len, 0);
                        }
                    }
                } else if ( key_arg->op == cot_obj ) {
                    // Key is at a global address - try to read it
                    ea_t key_addr = key_arg->obj_ea;
                    if ( key_addr != BADADDR && key_len <= 64 ) {
                        std::vector<uint8_t> raw_key(key_len);
                        if ( get_bytes(raw_key.data(), key_len, key_addr) == key_len ) {
                            if ( looks_like_base64(raw_key.data(), raw_key.size()) ) {
                                std::vector<uint8_t> decoded;
                                if ( decode_base64(raw_key.data(), raw_key.size(), &decoded) ) {
                                    if ( !decoded.empty() ) {
                                        crypto.key = decoded;
                                    }
                                }
                            }
                            if ( crypto.key.empty() ) 
                                crypto.key = raw_key;
                            ctree_str_debug("[crypto] Read key from 0x%llx (%zu bytes)\n",
                                           (unsigned long long)key_addr, key_len);
                        }
                    }
                }

                // Determine algorithm based on key length
                if ( keylen_arg->op == cot_num ) {
                    uint64_t keylen = keylen_arg->numval();
                    crypto.algorithm = (keylen == 32) ? 1 : 0;  // AES-256 or AES-128
                } else if ( crypto.key.size() == 32 ) {
                    crypto.algorithm = 1;
                } else {
                    crypto.algorithm = 0;
                }
                
                // Try to get IV (arg 5)
                cexpr_t *iv_arg = &(*args)[5];
                qstring iv_str;
                if ( extract_string_constant(iv_arg, &iv_str) ) {
                    for ( size_t i = 0; i < iv_str.length() && i < 16; ++i ) {
                        crypto.iv.push_back((uint8_t)iv_str[i]);
                    }
                } else if ( iv_arg->op == cot_obj && iv_arg->obj_ea != BADADDR ) {
                    // IV is at a global address
                    crypto.iv.resize(16);
                    if ( get_bytes(crypto.iv.data(), 16, iv_arg->obj_ea) != 16 ) {
                        crypto.iv.clear();
                    }
                }
                
                // Get input data address and length (args 6 and 7)
                cexpr_t *data_in_arg = &(*args)[6];
                cexpr_t *data_in_len_arg = &(*args)[7];
                
                if ( data_in_arg->op == cot_obj ) {
                    crypto.input_addr = data_in_arg->obj_ea;
                }
                if ( data_in_len_arg->op == cot_num ) {
                    crypto.input_len = (size_t)data_in_len_arg->numval();
                }
                if ( crypto.input_len == 0 && crypto.input_addr != BADADDR ) {
                    size_t guess_len = get_max_strlit_length(crypto.input_addr, STRTYPE_C, ALOPT_IGNCLT);
                    if ( guess_len > 0 && guess_len < 4096 ) {
                        crypto.input_len = guess_len;
                    }
                }
                
                // Get output address (arg 8) if available
                if ( args->size() >= 9 ) {
                    cexpr_t *data_out_arg = &(*args)[8];
                    if ( data_out_arg->op == cot_obj ) {
                        crypto.output_addr = data_out_arg->obj_ea;
                    }
                }
                
                // If we have key and input data, try to decrypt
                if ( is_decrypt && is_aes && !crypto.key.empty() &&
                    crypto.input_addr != BADADDR && crypto.input_len > 0)
                    {
                    ctree_str_debug("[crypto] Attempting AES decryption: input=0x%llx len=%zu key_len=%zu\n",
                                   (unsigned long long)crypto.input_addr, crypto.input_len, crypto.key.size());
                    
                    if ( try_aes_decrypt_at_address(crypto.input_addr, crypto.input_len,
                                                   crypto.key, crypto.iv, use_pkcs7,
                                                   use_ecb, &crypto.decrypted))
                                                   {
                        ctree_str_debug("[crypto] Decryption SUCCESS: \"%s\"\n", crypto.decrypted.c_str());
                    }
                }
                
                if ( !crypto.key.empty() ) {
                    ctree_str_debug("[crypto] Found CCCrypt: key_len=%zu iv_len=%zu input=0x%llx len=%zu\n",
                                   crypto.key.size(), crypto.iv.size(),
                                   (unsigned long long)crypto.input_addr, crypto.input_len);
                    crypto_calls.push_back(crypto);
                }
            }
        }
    }
    
    bool extract_string_constant(cexpr_t *e, qstring *out)
    {
        if ( !e || !out ) 
            return false;
            
        // Direct string constant
        if ( e->op == cot_str ) {
            *out = e->string;
            return true;
        }
        
        // Reference to global string
        if ( e->op == cot_obj ) {
            // Try to read string from address
            ea_t addr = e->obj_ea;
            if ( addr != BADADDR ) {
                qstring buf;
                ssize_t len = get_strlit_contents(&buf, addr, -1, STRTYPE_C);
                if ( len > 0 ) {
                    *out = buf;
                    return true;
                }
                // Also try just reading bytes
                len = get_max_strlit_length(addr, STRTYPE_C, ALOPT_IGNCLT);
                if ( len > 0 && len < 1024 ) {
                    char raw_buf[1024];
                    get_bytes(raw_buf, len, addr);
                    raw_buf[len] = 0;
                    *out = raw_buf;
                    return true;
                }
            }
        }
        
        // Cast expression - unwrap and try again
        if ( e->op == cot_cast ) {
            return extract_string_constant(e->x, out);
        }
        
        // Reference expression
        if ( e->op == cot_ref ) {
            return extract_string_constant(e->x, out);
        }
        
        return false;
    }
};

//--------------------------------------------------------------------------
// Expression evaluation helpers
//--------------------------------------------------------------------------
static cexpr_t *strip_cast_ref(cexpr_t *e)
{
    while ( e && (e->op == cot_cast || e->op == cot_ref) ) {
        e = e->x;
    }
    return e;
}

static bool read_value_at_address(ea_t addr, size_t size, uint64_t *out)
{
    if ( !out || addr == BADADDR || !is_loaded(addr) ) 
        return false;

    switch ( size ) {
        case 1: *out = get_byte(addr); return true;
        case 2: *out = get_word(addr); return true;
        case 4: *out = get_dword(addr); return true;
        case 8: *out = get_qword(addr); return true;
        default: break;
    }

    return false;
}

static bool resolve_const_address(cexpr_t *e, ea_t *out_addr)
{
    if ( !e || !out_addr ) 
        return false;

    e = strip_cast_ref(e);
    if ( !e ) 
        return false;

    if ( e->op == cot_obj ) {
        *out_addr = e->obj_ea;
        return true;
    }

    if ( e->op == cot_num ) {
        *out_addr = (ea_t)e->numval();
        return true;
    }

    if ( e->op == cot_add ) {
        cexpr_t *base = e->x;
        cexpr_t *offset = e->y;
        if ( !base || !offset ) 
            return false;

        if ( base->op == cot_num && offset->op != cot_num ) 
            std::swap(base, offset);

        if ( offset->op != cot_num ) 
            return false;

        ea_t base_addr = BADADDR;
        if ( !resolve_const_address(base, &base_addr) ) 
            return false;

        *out_addr = base_addr + (ea_t)offset->numval();
        return true;
    }

    return false;
}

static bool eval_expr_u64(cexpr_t *e, const std::map<int, uint64_t> &locals,
                          uint64_t *out, int size_hint, int depth = 0)
                          {
    if ( !e || !out || depth > 16 ) 
        return false;

    switch ( e->op ) {
        case cot_num:
            *out = e->numval();
            return true;
        case cot_cast:
            return eval_expr_u64(e->x, locals, out, size_hint, depth + 1);
        case cot_var: {
            auto p = locals.find(e->v.idx);
            if ( p == locals.end() ) 
                return false;
            *out = p->second;
            return true;
        }
        case cot_obj: {
            int tsize = e->type.get_size();
            int read_size = size_hint ? size_hint : tsize;
            if ( read_size <= 0 ) 
                read_size = size_hint ? size_hint : 1;
            if ( size_hint == 1 && tsize > 1 ) 
                return false;
            if ( size_hint == 8 && tsize > 0 && tsize < 8 ) 
                return false;
            return read_value_at_address(e->obj_ea, (size_t)read_size, out);
        }
        case cot_ptr: {
            ea_t addr = BADADDR;
            if ( !resolve_const_address(e->x, &addr) ) 
                return false;
            int tsize = e->type.get_size();
            int read_size = size_hint ? size_hint : tsize;
            if ( read_size <= 0 ) 
                read_size = size_hint ? size_hint : 1;
            return read_value_at_address(addr, (size_t)read_size, out);
        }
        case cot_add:
        case cot_sub:
        case cot_mul:
        case cot_band:
        case cot_bor:
        case cot_xor:
        case cot_shl:
        case cot_sshr:
        case cot_ushr: {
            uint64_t l = 0, r = 0;
            if ( !eval_expr_u64(e->x, locals, &l, size_hint, depth + 1) ) 
                return false;
            if ( !eval_expr_u64(e->y, locals, &r, size_hint, depth + 1) ) 
                return false;
            if ( (e->op == cot_shl || e->op == cot_sshr || e->op == cot_ushr) && r >= 64 ) 
                return false;
            switch ( e->op ) {
                case cot_add: *out = l + r; break;
                case cot_sub: *out = l - r; break;
                case cot_mul: *out = l * r; break;
                case cot_band: *out = l & r; break;
                case cot_bor: *out = l | r; break;
                case cot_xor: *out = l ^ r; break;
                case cot_shl: *out = l << r; break;
                case cot_sshr: *out = (uint64_t)((int64_t)l >> r); break;
                case cot_ushr: *out = l >> r; break;
                default: return false;
            }
            return true;
        }
        case cot_bnot: {
            uint64_t v = 0;
            if ( !eval_expr_u64(e->x, locals, &v, size_hint, depth + 1) ) 
                return false;
            *out = ~v;
            return true;
        }
        case cot_neg: {
            uint64_t v = 0;
            if ( !eval_expr_u64(e->x, locals, &v, size_hint, depth + 1) ) 
                return false;
            *out = (uint64_t)(-(int64_t)v);
            return true;
        }
        default:
            break;
    }

    return false;
}

//--------------------------------------------------------------------------
// Visitor to find character-by-character assignments
//--------------------------------------------------------------------------
struct char_assign_visitor_t : public ctree_visitor_t {
    cfunc_t *cfunc;
    
    // Map: variable -> (offset -> (value, ea))
    std::map<int, std::map<int, std::pair<uint8_t, ea_t>>> var_assignments;
    std::map<ea_t, std::map<int, std::pair<uint8_t, ea_t>>> global_assignments;
    std::map<int, uint64_t> local_values;
    
    char_assign_visitor_t(cfunc_t *cf) : ctree_visitor_t(CV_FAST), cfunc(cf) {}
    
    int idaapi visit_expr(cexpr_t *e) override {
        if ( e->op != cot_asg ) 
            return 0;
            
        cexpr_t *lhs = e->x;
        cexpr_t *rhs = e->y;
        
        if ( !lhs || !rhs ) 
            return 0;
        
        if ( lhs->op == cot_var ) {
            uint64_t val = 0;
            int size_hint = lhs->type.get_size();
            if ( size_hint <= 0 || size_hint > 8 ) 
                size_hint = 0;
            if ( eval_expr_u64(rhs, local_values, &val, size_hint) ) {
                local_values[lhs->v.idx] = val;
            } else {
                local_values.erase(lhs->v.idx);
            }
        }

        if ( try_handle_vector_assign(lhs, rhs, e->ea) ) 
            return 0;

        uint8_t value = 0;
        if ( !extract_byte_value(rhs, &value) ) 
            return 0;

        assign_target_t target;
        if ( !resolve_assignment_target(lhs, &target) ) 
            return 0;

        record_assignment(target, target.base_index, value, e->ea);
        return 0;
    }
    
    // Convert collected assignments to strings
    std::vector<ctree_string_decrypt_handler_t::char_string_t> 
    get_reconstructed_strings()
    {
        std::vector<ctree_string_decrypt_handler_t::char_string_t> result;
        
        // Process local variable assignments
        lvars_t *lvars = cfunc->get_lvars();
        for ( auto &kv : var_assignments ) {
            int var_idx = kv.first;
            auto &offsets = kv.second;
            
            if ( offsets.size() < 3 ) 
                continue;
                
            ctree_string_decrypt_handler_t::char_string_t str;
            
            if ( lvars && var_idx < lvars->size() ) {
                str.var_name = (*lvars)[var_idx].name;
            } else {
                str.var_name.sprnt("var_%d", var_idx);
            }
            
            if ( try_reconstruct(offsets, &str) ) {
                ctree_str_debug("[char_assign] Variable %s: \"%s\"\n",
                               str.var_name.c_str(), str.reconstructed.c_str());
                result.push_back(str);
            }
        }
        
        // Process global assignments
        for ( auto &kv : global_assignments ) {
            ea_t addr = kv.first;
            auto &offsets = kv.second;
            
            if ( offsets.size() < 3 ) 
                continue;
                
            ctree_string_decrypt_handler_t::char_string_t str;
            str.var_addr = addr;
            get_name(&str.var_name, addr);
            if ( str.var_name.empty() ) {
                str.var_name.sprnt("global_%llX", (unsigned long long)addr);
            }
            
            if ( try_reconstruct(offsets, &str) ) {
                ctree_str_debug("[char_assign] Global %s: \"%s\"\n",
                               str.var_name.c_str(), str.reconstructed.c_str());
                result.push_back(str);
            }
        }
        
        return result;
    }
    
private:
    struct assign_target_t {
        bool is_global = false;
        int var_idx = -1;
        ea_t addr = BADADDR;
        int base_index = 0;
    };

    bool get_call_name(qstring *out, cexpr_t *callee)
    {
        if ( !out || !callee ) 
            return false;
        if ( callee->op == cot_obj ) {
            return get_name(out, callee->obj_ea) > 0;
        }
        if ( callee->op == cot_helper ) {
            *out = callee->helper;
            return true;
        }
        return false;
    }

    bool resolve_base_target(cexpr_t *base, int idx, assign_target_t *out)
    {
        if ( !out ) 
            return false;

        base = strip_cast_ref(base);
        if ( !base ) 
            return false;

        if ( base->op == cot_var ) {
            out->is_global = false;
            out->var_idx = base->v.idx;
            out->base_index = idx;
            return true;
        }
        if ( base->op == cot_obj ) {
            out->is_global = true;
            out->addr = base->obj_ea;
            out->base_index = idx;
            return true;
        }

        return false;
    }

    bool resolve_ptr_target(cexpr_t *ptr_expr, assign_target_t *out)
    {
        if ( !ptr_expr || !out ) 
            return false;

        ptr_expr = strip_cast_ref(ptr_expr);
        if ( !ptr_expr ) 
            return false;

        if ( ptr_expr->op == cot_var || ptr_expr->op == cot_obj ) {
            return resolve_base_target(ptr_expr, 0, out);
        }

        if ( ptr_expr->op == cot_add ) {
            cexpr_t *base = ptr_expr->x;
            cexpr_t *offset = ptr_expr->y;
            if ( !base || !offset ) 
                return false;

            if ( base->op == cot_num && offset->op != cot_num ) 
                std::swap(base, offset);

            if ( offset->op != cot_num ) 
                return false;

            int idx = (int)offset->numval();
            return resolve_base_target(base, idx, out);
        }

        return false;
    }

    bool resolve_assignment_target(cexpr_t *lhs, assign_target_t *out)
    {
        if ( !lhs || !out ) 
            return false;

        lhs = strip_cast_ref(lhs);
        if ( !lhs ) 
            return false;

        if ( lhs->op == cot_idx ) {
            cexpr_t *base = lhs->x;
            cexpr_t *index = lhs->y;
            if ( !base || !index || index->op != cot_num ) 
                return false;
            return resolve_base_target(base, (int)index->numval(), out);
        }

        if ( lhs->op == cot_ptr ) {
            return resolve_ptr_target(lhs->x, out);
        }

        return false;
    }

    void record_assignment(const assign_target_t &target, int idx, uint8_t value, ea_t ea)
    {
        if ( idx < 0 ) 
            return;

        if ( target.is_global ) {
            auto &slots = global_assignments[target.addr];
            if ( slots.find(idx) == slots.end() ) 
                slots[idx] = std::make_pair(value, ea);
        } else {
            auto &slots = var_assignments[target.var_idx];
            if ( slots.find(idx) == slots.end() ) 
                slots[idx] = std::make_pair(value, ea);
        }
    }

    bool extract_byte_value(cexpr_t *e, uint8_t *out)
    {
        if ( !e || !out ) 
            return false;

        uint64_t val = 0;
        if ( !eval_expr_u64(e, local_values, &val, 1) ) 
            return false;

        *out = (uint8_t)(val & 0xFF);
        return true;
    }

    bool extract_qword_value(cexpr_t *e, uint64_t *out)
    {
        if ( !e || !out ) 
            return false;

        return eval_expr_u64(e, local_values, out, 8);
    }

    bool try_handle_vector_assign(cexpr_t *lhs, cexpr_t *rhs, ea_t ea)
    {
        if ( !lhs || !rhs ) 
            return false;

        cexpr_t *call_expr = rhs;
        if ( call_expr->op == cot_cast ) 
            call_expr = call_expr->x;

        if ( !call_expr || call_expr->op != cot_call || !call_expr->x ) 
            return false;

        qstring func_name;
        if ( !get_call_name(&func_name, call_expr->x) ) 
            return false;

        if ( func_name.find("veor_s8") == qstring::npos &&
            func_name.find("veorq_s8") == qstring::npos)
            return false;

        if ( !call_expr->a || call_expr->a->size() < 2 ) 
            return false;

        uint64_t left = 0;
        uint64_t right = 0;
        if ( !extract_qword_value(&(*call_expr->a)[0], &left) ) 
            return false;
        if ( !extract_qword_value(&(*call_expr->a)[1], &right) ) 
            return false;

        assign_target_t target;
        if ( !resolve_assignment_target(lhs, &target) ) 
            return false;

        uint64_t result = left ^ right;
        for ( int i = 0; i < 8; ++i ) {
            uint8_t b = (uint8_t)((result >> (i * 8)) & 0xFF);
            record_assignment(target, target.base_index + i, b, ea);
        }

        return true;
    }
    
    bool try_reconstruct(const std::map<int, std::pair<uint8_t, ea_t>> &offsets,
                         ctree_string_decrypt_handler_t::char_string_t *out)
                         {
        if ( offsets.empty() ) 
            return false;
            
        // Find the range of indices
        int min_idx = offsets.begin()->first;
        int max_idx = offsets.rbegin()->first;
        
        // Check for reasonable string length
        if ( max_idx - min_idx > 4096 ) 
            return false;
            
        // Build the string
        qstring str;
        bool all_printable = true;
        int printable_count = 0;
        int missing_count = 0;

        for ( int i = min_idx; i <= max_idx; ++i ) {
            auto p = offsets.find(i);
            if ( p == offsets.end() ) {
                missing_count++;
                str += '?';
                continue;
            }
            
            uint8_t c = p->second.first;
            out->insn_addrs.push_back(p->second.second);
            
            if ( c == 0 ) {
                // Null terminator
                break;
            }
            
            if ( c < 0x20 || c > 0x7E ) {
                if ( c != '\n' && c != '\r' && c != '\t' ) {
                    all_printable = false;
                    break;
                }
            }
            
            str += (char)c;
            printable_count++;
        }
        
        if ( !all_printable || printable_count < 3 ) 
            return false;

        if ( missing_count > 0 ) {
            int total = printable_count + missing_count;
            if ( total > 0 && (printable_count * 100 / total) < 60 ) 
                return false;
        }

        while ( str.length() > 0 && str[str.length() - 1] == '?' ) 
            str.resize(str.length() - 1);
            
        out->reconstructed = str;
        if ( !out->insn_addrs.empty() ) {
            out->start_addr = out->insn_addrs[0];
        }
        
        return true;
    }
};

//--------------------------------------------------------------------------
// Detection
//--------------------------------------------------------------------------
bool ctree_string_decrypt_handler_t::detect(cfunc_t *cfunc)
{
    if ( !cfunc ) 
        return false;
        
    // Quick check: does the function have string-related calls?
    struct quick_visitor_t : public ctree_visitor_t {
        bool found = false;
        
        quick_visitor_t() : ctree_visitor_t(CV_FAST) {}
        
        int idaapi visit_expr(cexpr_t *e) override {
            if ( found ) 
                return 1;  // Stop visiting
                
            if ( e->op == cot_call && e->x ) {
                cexpr_t *callee = e->x;
                qstring name;
                
                // Check for direct function reference
                if ( callee->op == cot_obj ) {
                    get_name(&name, callee->obj_ea);
                }
                // Check for helper function (used by decompiler for recognized patterns)
                else if ( callee->op == cot_helper ) {
                    name = callee->helper;
                }
                
                if ( !name.empty() ) {
                    if ( name.find("strcpy") != qstring::npos ||
                        name.find("memcpy") != qstring::npos ||
                        name.find("qmemcpy") != qstring::npos ||
                        name.find("CCCrypt") != qstring::npos)
                        {
                        found = true;
                        return 1;
                    }
                }
            }
            
            // Check for array index assignments: buffer[i] = value
            if ( e->op == cot_asg && e->x && e->x->op == cot_idx ) {
                found = true;
                return 1;
            }
            
            // Check for pointer dereference assignments: *buffer = value, *(buffer+i) = value
            if ( e->op == cot_asg && e->x && e->x->op == cot_ptr ) {
                found = true;
                return 1;
            }
            
            return 0;
        }
    } visitor;
    
    visitor.apply_to(&cfunc->body, nullptr);
    return visitor.found;
}

//--------------------------------------------------------------------------
// Main entry point
//--------------------------------------------------------------------------
int ctree_string_decrypt_handler_t::run(cfunc_t *cfunc, deobf_ctx_t *ctx)
{
    if ( !cfunc || !ctx ) 
        return 0;
        
    ctree_str_debug("[ctree_string] Analyzing function at 0x%llx\n",
                   (unsigned long long)cfunc->entry_ea);
    
    int total_changes = 0;
    
    // Find string function calls (strcpy, memcpy, CCCrypt)
    string_call_visitor_t call_visitor(cfunc);
    call_visitor.apply_to(&cfunc->body, nullptr);
    
    for ( const auto &reveal : call_visitor.reveals ) {
        // Store in context
        if ( reveal.dest_addr != BADADDR ) {
            ctx->decrypted_strings[reveal.dest_addr] = reveal.plaintext.c_str();
        }
        
        // Annotate
        annotate_reveal(reveal);
        total_changes++;
    }
    
    for ( const auto &crypto : call_visitor.crypto_calls ) {
        // Store decrypted result in context if available
        if ( !crypto.decrypted.empty() ) {
            if ( crypto.input_addr != BADADDR ) {
                ctx->decrypted_strings[crypto.input_addr] = crypto.decrypted.c_str();
            }
            if ( crypto.output_addr != BADADDR ) {
                ctx->decrypted_strings[crypto.output_addr] = crypto.decrypted.c_str();
            }
            ctx->strings_decrypted++;
        }
        
        annotate_crypto_call(crypto);
        total_changes++;
    }
    
    // Find character-by-character assignments
    char_assign_visitor_t assign_visitor(cfunc);
    assign_visitor.apply_to(&cfunc->body, nullptr);
    
    auto char_strings = assign_visitor.get_reconstructed_strings();
    for ( const auto &str : char_strings ) {
        // Store in context
        if ( str.var_addr != BADADDR ) {
            ctx->decrypted_strings[str.var_addr] = str.reconstructed.c_str();
        }
        
        // Annotate
        annotate_char_string(str);
        total_changes++;
    }
    
    ctree_str_debug("[ctree_string] Found %zu strcpy/memcpy reveals, %zu crypto calls, %zu char strings\n",
                   call_visitor.reveals.size(), call_visitor.crypto_calls.size(), char_strings.size());
    
    // Phase 2: Find encrypted strings in ctree and replace with decrypted values
    // Build a map of destination addresses -> plaintexts from ALL sources
    std::map<ea_t, qstring> addr_to_plaintext;
    
    // Add strcpy/memcpy reveals
    for ( const auto &reveal : call_visitor.reveals ) {
        if ( reveal.dest_addr != BADADDR && !reveal.plaintext.empty() ) {
            addr_to_plaintext[reveal.dest_addr] = reveal.plaintext;
            ctree_str_debug("[mapping] strcpy/memcpy: 0x%llx -> \"%s\"\n",
                           (unsigned long long)reveal.dest_addr, reveal.plaintext.c_str());
        }
    }
    
    // Add character-by-character reconstructed strings
    for ( const auto &str : char_strings ) {
        if ( str.var_addr != BADADDR && !str.reconstructed.empty() ) {
            addr_to_plaintext[str.var_addr] = str.reconstructed;
            ctree_str_debug("[mapping] char-by-char: 0x%llx -> \"%s\"\n",
                           (unsigned long long)str.var_addr, str.reconstructed.c_str());
        }
    }
    
    // Add crypto call results
    for ( const auto &crypto : call_visitor.crypto_calls ) {
        if ( !crypto.decrypted.empty() ) {
            if ( crypto.input_addr != BADADDR ) {
                addr_to_plaintext[crypto.input_addr] = crypto.decrypted;
                ctree_str_debug("[mapping] crypto input: 0x%llx -> \"%s\"\n",
                               (unsigned long long)crypto.input_addr, crypto.decrypted.c_str());
            }
            if ( crypto.output_addr != BADADDR ) {
                addr_to_plaintext[crypto.output_addr] = crypto.decrypted;
            }
        }
    }
    
    ctree_str_debug("[ctree_string] Built address->plaintext map with %zu entries\n", addr_to_plaintext.size());
    
    if ( !addr_to_plaintext.empty() ) {
        int replaced = replace_encrypted_strings(cfunc, addr_to_plaintext);
        if ( replaced > 0 ) {
            ctree_str_debug("[ctree_string] Replaced %d encrypted strings in ctree\n", replaced);
            total_changes += replaced;
        }
    }
    
    return total_changes;
}

//--------------------------------------------------------------------------
// Encrypted string replacement visitor
//--------------------------------------------------------------------------
struct encrypted_string_replacer_t : public ctree_visitor_t {
    cfunc_t *cfunc;
    const std::map<ea_t, qstring> &known_plaintexts;
    int replacements = 0;
    
    encrypted_string_replacer_t(cfunc_t *cf, const std::map<ea_t, qstring> &plaintexts)
        : ctree_visitor_t(CV_FAST), cfunc(cf), known_plaintexts(plaintexts) {}
    
    // Check if data at address looks encrypted (has non-printable chars)
    static bool is_encrypted_string(ea_t addr, size_t max_len = 256)
    {
        if ( addr == BADADDR || !is_loaded(addr) ) 
            return false;
            
        int non_printable = 0;
        int total = 0;
        
        for ( size_t i = 0; i < max_len; ++i ) {
            uint8_t c = get_byte(addr + i);
            if ( c == 0) break;
            total++;
            if ( c < 0x20 || c > 0x7E ) {
                if ( c != '\n' && c != '\r' && c != '\t' ) {
                    non_printable++;
                }
            }
        }
        
        // Consider encrypted if >30% non-printable and at least 4 chars
        return total >= 4 && non_printable > 0 && (non_printable * 100 / total) > 30;
    }
    
    // Try to decrypt using XOR with known plaintext
    static bool try_xor_decrypt(ea_t encrypted_addr, const qstring &known_plain, qstring *out)
    {
        if ( encrypted_addr == BADADDR || known_plain.empty() ) 
            return false;
            
        size_t len = known_plain.length();
        
        // Read encrypted data
        std::vector<uint8_t> encrypted(len);
        if ( get_bytes(encrypted.data(), len, encrypted_addr) != len ) 
            return false;
        
        // Compute XOR key by XORing encrypted with known plaintext
        std::vector<uint8_t> key(len);
        for ( size_t i = 0; i < len; ++i ) {
            key[i] = encrypted[i] ^ (uint8_t)known_plain[i];
        }
        
        // Verify by decrypting - should get plaintext back
        qstring decrypted;
        for ( size_t i = 0; i < len; ++i ) {
            char c = encrypted[i] ^ key[i];
            if ( c == 0) break;
            decrypted += c;
        }
        
        if ( decrypted == known_plain ) {
            *out = decrypted;
            return true;
        }
        
        return false;
    }
    
    // Helper to get op name for debugging
    static const char* get_op_name(ctype_t op)
    {
        switch ( op ) {
            case cot_comma: return "cot_comma";
            case cot_asg: return "cot_asg";
            case cot_asgbor: return "cot_asgbor";
            case cot_asgxor: return "cot_asgxor";
            case cot_asgband: return "cot_asgband";
            case cot_asgadd: return "cot_asgadd";
            case cot_asgsub: return "cot_asgsub";
            case cot_asgmul: return "cot_asgmul";
            case cot_asgsshr: return "cot_asgsshr";
            case cot_asgushr: return "cot_asgushr";
            case cot_asgshl: return "cot_asgshl";
            case cot_asgsdiv: return "cot_asgsdiv";
            case cot_asgudiv: return "cot_asgudiv";
            case cot_asgsmod: return "cot_asgsmod";
            case cot_asgumod: return "cot_asgumod";
            case cot_tern: return "cot_tern";
            case cot_lor: return "cot_lor";
            case cot_land: return "cot_land";
            case cot_bor: return "cot_bor";
            case cot_xor: return "cot_xor";
            case cot_band: return "cot_band";
            case cot_eq: return "cot_eq";
            case cot_ne: return "cot_ne";
            case cot_sge: return "cot_sge";
            case cot_uge: return "cot_uge";
            case cot_sle: return "cot_sle";
            case cot_ule: return "cot_ule";
            case cot_sgt: return "cot_sgt";
            case cot_ugt: return "cot_ugt";
            case cot_slt: return "cot_slt";
            case cot_ult: return "cot_ult";
            case cot_sshr: return "cot_sshr";
            case cot_ushr: return "cot_ushr";
            case cot_shl: return "cot_shl";
            case cot_add: return "cot_add";
            case cot_sub: return "cot_sub";
            case cot_mul: return "cot_mul";
            case cot_sdiv: return "cot_sdiv";
            case cot_udiv: return "cot_udiv";
            case cot_smod: return "cot_smod";
            case cot_umod: return "cot_umod";
            case cot_fadd: return "cot_fadd";
            case cot_fsub: return "cot_fsub";
            case cot_fmul: return "cot_fmul";
            case cot_fdiv: return "cot_fdiv";
            case cot_fneg: return "cot_fneg";
            case cot_neg: return "cot_neg";
            case cot_cast: return "cot_cast";
            case cot_lnot: return "cot_lnot";
            case cot_bnot: return "cot_bnot";
            case cot_ptr: return "cot_ptr";
            case cot_ref: return "cot_ref";
            case cot_postinc: return "cot_postinc";
            case cot_postdec: return "cot_postdec";
            case cot_preinc: return "cot_preinc";
            case cot_predec: return "cot_predec";
            case cot_call: return "cot_call";
            case cot_idx: return "cot_idx";
            case cot_memref: return "cot_memref";
            case cot_memptr: return "cot_memptr";
            case cot_num: return "cot_num";
            case cot_fnum: return "cot_fnum";
            case cot_str: return "cot_str";
            case cot_obj: return "cot_obj";
            case cot_var: return "cot_var";
            case cot_insn: return "cot_insn";
            case cot_sizeof: return "cot_sizeof";
            case cot_helper: return "cot_helper";
            case cot_type: return "cot_type";
            default: return "unknown";
        }
    }
    
    int idaapi visit_expr(cexpr_t *e) override {
        // Debug: log all cot_obj and cot_ref nodes to understand what we're seeing
        if ( e->op == cot_ref && e->x && e->x->op == cot_obj ) {
            qstring name;
            get_name(&name, e->x->obj_ea);
            ctree_str_debug("[visit] cot_ref -> cot_obj at 0x%llx (%s)\n",
                           (unsigned long long)e->x->obj_ea, name.c_str());
        }
        
        // Log all calls to understand what patterns exist
        if ( e->op == cot_call && e->x ) {
            const char *call_name = "unknown";
            if ( e->x->op == cot_helper ) {
                call_name = e->x->helper;
            } else if ( e->x->op == cot_obj ) {
                static char name_buf[256];
                qstring name;
                if ( get_name(&name, e->x->obj_ea) > 0 ) {
                    qstrncpy(name_buf, name.c_str(), sizeof(name_buf));
                    call_name = name_buf;
                }
            }
            
            // Log call details with args
            if ( e->a && e->a->size() > 0 ) {
                qstring args_info;
                for ( size_t i = 0; i < e->a->size() && i < 3; ++i ) {
                    cexpr_t *arg = &(*e->a)[i];
                    args_info.cat_sprnt(" arg%zu:%s", i, get_op_name(arg->op));
                    if ( arg->op == cot_str && arg->string ) {
                        size_t len = strlen(arg->string);
                        qstring hex;
                        for ( size_t j = 0; j < len && j < 8; ++j ) {
                            hex.cat_sprnt("%02X", (uint8_t)arg->string[j]);
                        }
                        args_info.cat_sprnt("(hex=%s)", hex.c_str());
                    } else if ( arg->op == cot_obj ) {
                        args_info.cat_sprnt("(0x%llx)", (unsigned long long)arg->obj_ea);
                    }
                }
                ctree_str_debug("[call] %s%s\n", call_name, args_info.c_str());
            }
        }
        
        // Look for CFSTR or string references that might be encrypted
        // CFSTR appears as: call to CFSTR helper with cot_obj argument
        // Or direct cot_obj/cot_str
        
        ea_t str_addr = BADADDR;
        const char *existing_str = nullptr;
        cexpr_t *target_expr = e;  // Expression to modify
        
        // Check for CFSTR(x) call pattern - this is how IDA shows CFString references
        if ( e->op == cot_call && e->x ) {
            // Check both helper and regular call
            const char *func_name = nullptr;
            if ( e->x->op == cot_helper ) {
                func_name = e->x->helper;
                ctree_str_debug("[replace] Call to helper: %s\n", func_name);
            } else if ( e->x->op == cot_obj ) {
                qstring name;
                if ( get_name(&name, e->x->obj_ea) > 0 ) {
                    static char name_buf[256];
                    qstrncpy(name_buf, name.c_str(), sizeof(name_buf));
                    func_name = name_buf;
                }
            }
            
            if ( func_name && (strstr(func_name, "CFSTR") || strstr(func_name, "CFString") ||
                              strstr(func_name, "__CFString")))
                              {
                ctree_str_debug("[replace] Found CFSTR-like call: %s\n", func_name);
                // The argument to CFSTR is what we want to decrypt
                if ( e->a && e->a->size() > 0 ) {
                    cexpr_t *arg = &(*e->a)[0];
                    ctree_str_debug("[replace] CFSTR arg op: %s\n", get_op_name(arg->op));
                    if ( arg->op == cot_obj ) {
                        str_addr = arg->obj_ea;
                        target_expr = arg;  // We'll modify the argument
                        ctree_str_debug("[replace] Found CFSTR() call, arg at 0x%llx\n",
                                       (unsigned long long)str_addr);
                    } else if ( arg->op == cot_str && arg->string ) {
                        existing_str = arg->string;
                        target_expr = arg;
                        ctree_str_debug("[replace] Found CFSTR() with string arg: \"%s\"\n",
                                       existing_str);
                    }
                }
            }
        }
        // CFSTR() shows up as cot_ref -> cot_obj (taking address of CFString structure)
        // This is the main pattern for CFSTR() in pseudocode
        else if ( e->op == cot_ref && e->x && e->x->op == cot_obj ) {
            str_addr = e->x->obj_ea;
            target_expr = e;  // The whole cot_ref expression
            ctree_str_debug("[replace] Found cot_ref->cot_obj (CFSTR pattern) at 0x%llx\n",
                           (unsigned long long)str_addr);
        }
        // Direct cot_obj reference
        else if ( e->op == cot_obj ) {
            str_addr = e->obj_ea;
        }
        // Direct cot_str 
        else if ( e->op == cot_str && e->string ) {
            existing_str = e->string;
            // Log raw bytes for debugging
            size_t slen = strlen(existing_str);
            qstring hex_dump;
            for ( size_t i = 0; i < slen && i < 32; ++i ) {
                hex_dump.cat_sprnt("%02X ", (uint8_t)existing_str[i]);
            }
            ctree_str_debug("[replace] Found cot_str: len=%zu hex=[%s]\n", 
                           slen, hex_dump.c_str());
        } else {
            return 0;
        }
        
        if ( str_addr == BADADDR && !existing_str ) 
            return 0;
        
        // Try to find matching plaintext
        qstring decrypted;
        bool found = false;
        
        // Case 1: We have an existing string (cot_str) - check if it's encrypted
        if ( existing_str ) {
            size_t enc_len = strlen(existing_str);
            
            // Check if it looks encrypted
            int non_printable = 0;
            for ( size_t i = 0; i < enc_len; ++i ) {
                uint8_t c = (uint8_t)existing_str[i];
                if ( c < 0x20 || c > 0x7E ) {
                    if ( c != '\n' && c != '\r' && c != '\t' ) {
                        non_printable++;
                    }
                }
            }
            
            // Skip if not encrypted (< 30% non-printable)
            // Allow short strings (2+ chars) since "OK", "Yes", etc. are common
            if ( enc_len < 2 || non_printable == 0 || (non_printable * 100 / enc_len) <= 30 ) 
                return 0;
            
            // Try each known plaintext with XOR (same-length match)
            for ( const auto &kv : known_plaintexts ) {
                const qstring &plain = kv.second;
                
                // Length must match approximately
                if ( plain.length() != enc_len && 
                    plain.length() != enc_len - 1 && 
                    plain.length() != enc_len + 1)
                    continue;
                
                // Try XOR decryption using the string bytes directly
                size_t min_len = std::min(enc_len, plain.length());
                qstring test_decrypt;
                bool valid = true;
                
                for ( size_t i = 0; i < min_len; ++i ) {
                    uint8_t enc_byte = (uint8_t)existing_str[i];
                    uint8_t plain_byte = (uint8_t)plain[i];
                    uint8_t key_byte = enc_byte ^ plain_byte;
                    char dec_char = enc_byte ^ key_byte;
                    
                    if ( dec_char == 0) break;
                    test_decrypt += dec_char;
                }
                
                // Check if decryption matches the known plaintext
                if ( test_decrypt == plain ) {
                    decrypted = plain;
                    found = true;
                    ctree_str_debug("[replace] Matched cot_str to known plaintext: \"%s\"\n", 
                                   decrypted.c_str());
                    break;
                }
            }
            
            // Fallback: Try to derive XOR key from any known pair and apply to this string
            // Hikari often uses the same key for all strings in a function
            if ( !found && enc_len >= 2 && enc_len <= 8 ) {
                // Find a known encrypted/plaintext pair to derive the key
                for ( const auto &kv : known_plaintexts ) {
                    ea_t known_addr = kv.first;
                    const qstring &known_plain = kv.second;
                    
                    if ( known_plain.length() < enc_len ) 
                        continue;
                    
                    // Read encrypted bytes at known_addr
                    std::vector<uint8_t> known_enc(enc_len);
                    if ( get_bytes(known_enc.data(), enc_len, known_addr) != enc_len ) 
                        continue;
                    
                    // Derive XOR key from this pair
                    std::vector<uint8_t> key(enc_len);
                    for ( size_t i = 0; i < enc_len; ++i ) {
                        key[i] = known_enc[i] ^ (uint8_t)known_plain[i];
                    }
                    
                    // Apply key to our encrypted string
                    qstring candidate;
                    bool all_printable = true;
                    for ( size_t i = 0; i < enc_len; ++i ) {
                        char c = (uint8_t)existing_str[i] ^ key[i];
                        if ( c == 0) break;
                        if ( c < 0x20 || c > 0x7E ) {
                            all_printable = false;
                            break;
                        }
                        candidate += c;
                    }
                    
                    // Accept if result is printable and reasonable
                    if ( all_printable && candidate.length() >= 2 ) {
                        decrypted = candidate;
                        found = true;
                        ctree_str_debug("[replace] Derived XOR key from 0x%llx, decrypted to: \"%s\"\n",
                                       (unsigned long long)known_addr, decrypted.c_str());
                        break;
                    }
                }
            }
        }
        // Case 2: We have an address (cot_obj) - read from memory
        else if ( str_addr != BADADDR ) {
            // Check if this is a CFSTR - typically in __cfstring section
            segment_t *seg = getseg(str_addr);
            if ( !seg ) 
                return 0;
                
            qstring seg_name;
            get_segm_name(&seg_name, seg);
            
            ea_t actual_str_addr = str_addr;
            
            ctree_str_debug("[replace] cot_obj at 0x%llx in segment %s\n", 
                           (unsigned long long)str_addr, seg_name.c_str());
            
            // Check if this looks like a CFString structure by checking name, segment, or layout
            qstring name_at_addr;
            get_name(&name_at_addr, str_addr);
            bool is_cfstring_struct = seg_name.find("cfstring") != qstring::npos ||
                                       name_at_addr.find("cfstr_") != qstring::npos ||
                                       name_at_addr.find("CFString") != qstring::npos ||
                                       name_at_addr.find("stru_") != qstring::npos;  // May be unnamed CFString
            
            // If it looks like a struct, verify it's actually a CFString by checking the layout
            // CFString layout: isa(8), flags(8), str_ptr(8), length(8)
            if ( !is_cfstring_struct && seg_name == "__data" ) {
                // Check if this could be a CFString by validating the structure
                uint64_t maybe_flags = get_qword(str_addr + 0x08);
                ea_t maybe_ptr = get_qword(str_addr + 0x10);
                uint64_t maybe_len = get_qword(str_addr + 0x18);
                
                // Heuristic: flags should be non-zero but reasonable, ptr should be valid, len should be small
                if ( maybe_flags != 0 && maybe_flags < 0x10000 &&
                    maybe_ptr != 0 && maybe_ptr != BADADDR && is_loaded(maybe_ptr) &&
                    maybe_len > 0 && maybe_len < 4096)
                    {
                    // Check if the pointer points to a known plaintext address
                    auto p = known_plaintexts.find(maybe_ptr);
                    if ( p != known_plaintexts.end() ) {
                        is_cfstring_struct = true;
                        ctree_str_debug("[replace] Detected CFString structure by layout at 0x%llx (ptr=0x%llx)\n",
                                       (unsigned long long)str_addr, (unsigned long long)maybe_ptr);
                    }
                }
            }
            
            ctree_str_debug("[replace] Name at 0x%llx = '%s', is_cfstring=%d\n",
                           (unsigned long long)str_addr, name_at_addr.c_str(), is_cfstring_struct);
            
            // IMPORTANT: Only replace CFSTR references, not destination buffers
            // A CFSTR reference has a structure pointer that points to the string data
            // A destination buffer is just the raw data location (what strcpy writes to)
            // We skip non-CFSTR structures to avoid breaking strcpy/memcpy calls
            if ( !is_cfstring_struct ) {
                ctree_str_debug("[replace] Skipping non-CFSTR cot_obj at 0x%llx\n",
                               (unsigned long long)str_addr);
                return 0;
            }
            
            // Handle CFSTR structure - the actual string is at offset 0x10
            // CFString layout: isa(8), flags(8), str_ptr(8), length(8)
            ea_t ptr = get_qword(str_addr + 0x10);
            uint64_t len_field = get_qword(str_addr + 0x18);
            ctree_str_debug("[replace] Checking as CFSTR structure: ptr at +0x10 = 0x%llx, len at +0x18 = %llu, is_loaded=%d\n",
                           (unsigned long long)ptr, (unsigned long long)len_field, is_loaded(ptr));
            if ( ptr != 0 && ptr != BADADDR && is_loaded(ptr) ) {
                // Get length field - but don't require it to be valid
                // Some obfuscators corrupt the length field
                uint64_t len = get_qword(str_addr + 0x18);
                if ( len > 0 && len < 4096 ) {
                    actual_str_addr = ptr;
                    ctree_str_debug("[replace] Using CFSTR string ptr 0x%llx, len=%llu\n",
                                   (unsigned long long)ptr, (unsigned long long)len);
                } else {
                    // Length field invalid, but pointer looks valid - use it anyway
                    // Compute actual length by scanning for null terminator
                    ctree_str_debug("[replace] Length field invalid (len=%llu), computing actual length\n",
                                   (unsigned long long)len);
                    size_t actual_len = 0;
                    for ( size_t i = 0; i < 256; ++i ) {
                        uint8_t b = get_byte(ptr + i);
                        if ( b == 0 ) {
                            actual_len = i;
                            break;
                        }
                    }
                    ctree_str_debug("[replace] Computed actual_len=%zu\n", actual_len);
                    if ( actual_len > 0 ) {
                        actual_str_addr = ptr;
                        ctree_str_debug("[replace] Using CFSTR string ptr 0x%llx (computed len=%zu)\n",
                                       (unsigned long long)ptr, actual_len);
                    }
                }
            }
            
            // Check if string at this address is encrypted
            if ( !is_encrypted_string(actual_str_addr) ) {
                ctree_str_debug("[replace] String at 0x%llx not encrypted, skipping\n",
                               (unsigned long long)actual_str_addr);
                return 0;
            }
                
            ctree_str_debug("[replace] Found encrypted cot_obj at 0x%llx\n", 
                           (unsigned long long)actual_str_addr);
            
            // Get encrypted string length
            size_t enc_len = 0;
            for ( size_t i = 0; i < 256; ++i ) {
                if ( get_byte(actual_str_addr + i) == 0) break;
                enc_len++;
            }
            
            ctree_str_debug("[replace] Encrypted string at 0x%llx has len=%zu, have %zu known plaintexts\n",
                           (unsigned long long)actual_str_addr, enc_len, known_plaintexts.size());
            
            // First check: is there a direct match by address?
            auto p = known_plaintexts.find(actual_str_addr);
            if ( p != known_plaintexts.end() ) {
                decrypted = p->second;
                found = true;
                ctree_str_debug("[replace] Direct address match! Using plaintext: \"%s\"\n", decrypted.c_str());
            }
            
            // Try each known plaintext
            if ( !found ) {
                for ( const auto &kv : known_plaintexts ) {
                    const qstring &plain = kv.second;
                    
                    ctree_str_debug("[replace] Trying plaintext len=%zu vs enc_len=%zu\n", 
                                   plain.length(), enc_len);
                    
                    if ( plain.length() != enc_len && 
                        plain.length() != enc_len - 1 && 
                        plain.length() != enc_len + 1)
                        continue;
                    
                    if ( try_xor_decrypt(actual_str_addr, plain, &decrypted) ) {
                        found = true;
                        ctree_str_debug("[replace] Decrypted cot_obj to: \"%s\"\n", decrypted.c_str());
                        break;
                    }
                }
            }
        }
        
        if ( !found ) 
            return 0;
            
        // Add comment at the expression's address  
        if ( target_expr->ea != BADADDR ) {
            qstring comment;
            comment.sprnt("DEOBF: Decrypted CFSTR = \"%s\"", decrypted.c_str());
            set_cmt(target_expr->ea, comment.c_str(), false);
        }
        
        // Try to patch the CFString's string data in the IDB
        // This will make CFSTR() show the decrypted string on re-decompilation
        if ( str_addr != BADADDR ) {
            // Get the string pointer from CFString structure at +0x10
            ea_t string_data_ptr = get_qword(str_addr + 0x10);
            if ( string_data_ptr != 0 && string_data_ptr != BADADDR && is_loaded(string_data_ptr) ) {
                // Verify this pointer points to a known plaintext (i.e., it's a valid CFString)
                auto p = known_plaintexts.find(string_data_ptr);
                if ( p != known_plaintexts.end() ) {
                    // Patch the string data bytes  
                    size_t dec_len = decrypted.length();
                    for ( size_t i = 0; i < dec_len; ++i ) {
                        patch_byte(string_data_ptr + i, (uint8_t)decrypted[i]);
                    }
                    // Null terminate
                    patch_byte(string_data_ptr + dec_len, 0);
                    
                    ctree_str_debug("[replace] Patched %zu bytes at 0x%llx with decrypted string\n",
                                   dec_len, (unsigned long long)string_data_ptr);
                }
            }
        }
        
        ctree_str_debug("[replace] Added comment at 0x%llx for \"%s\"\n",
                       (unsigned long long)target_expr->ea, decrypted.c_str());
        
        replacements++;
        return 0;
    }
};

int ctree_string_decrypt_handler_t::replace_encrypted_strings(
    cfunc_t *cfunc, 
    const std::map<ea_t, qstring> &known_plaintexts)
{
    encrypted_string_replacer_t replacer(cfunc, known_plaintexts);
    replacer.apply_to(&cfunc->body, nullptr);
    return replacer.replacements;
}

//--------------------------------------------------------------------------
// Find patterns - delegated to visitors
//--------------------------------------------------------------------------
std::vector<ctree_string_decrypt_handler_t::string_reveal_t>
ctree_string_decrypt_handler_t::find_strcpy_reveals(cfunc_t *cfunc)
{
    string_call_visitor_t visitor(cfunc);
    visitor.apply_to(&cfunc->body, nullptr);
    return visitor.reveals;
}

std::vector<ctree_string_decrypt_handler_t::string_reveal_t>
ctree_string_decrypt_handler_t::find_memcpy_reveals(cfunc_t *cfunc)
{
    // Already handled in string_call_visitor_t
    return find_strcpy_reveals(cfunc);
}

std::vector<ctree_string_decrypt_handler_t::char_string_t>
ctree_string_decrypt_handler_t::find_char_assignments(cfunc_t *cfunc)
{
    char_assign_visitor_t visitor(cfunc);
    visitor.apply_to(&cfunc->body, nullptr);
    return visitor.get_reconstructed_strings();
}

std::vector<ctree_string_decrypt_handler_t::xor_decrypt_t>
ctree_string_decrypt_handler_t::find_xor_patterns(cfunc_t *cfunc)
{
    // TODO: Implement XOR pattern detection at ctree level
    return {};
}

std::vector<ctree_string_decrypt_handler_t::crypto_call_t>
ctree_string_decrypt_handler_t::find_crypto_calls(cfunc_t *cfunc)
{
    string_call_visitor_t visitor(cfunc);
    visitor.apply_to(&cfunc->body, nullptr);
    return visitor.crypto_calls;
}

//--------------------------------------------------------------------------
// Annotation
//--------------------------------------------------------------------------
void ctree_string_decrypt_handler_t::annotate_reveal(const string_reveal_t &reveal)
{
    if ( reveal.location == BADADDR ) 
        return;
        
    qstring comment;
    const char *type = (reveal.reveal_type == 0) ? "strcpy" : "memcpy";
    
    if ( !reveal.dest_name.empty() ) {
        comment.sprnt("DEOBF: %s reveals \"%s\" -> %s",
                     type, reveal.plaintext.c_str(), reveal.dest_name.c_str());
    } else {
        comment.sprnt("DEOBF: %s reveals \"%s\"", type, reveal.plaintext.c_str());
    }
    
    set_cmt(reveal.location, comment.c_str(), false);
    
    // Also annotate at destination if it's a global
    if ( reveal.dest_addr != BADADDR ) {
        qstring dest_comment;
        dest_comment.sprnt("Decrypted: \"%s\"", reveal.plaintext.c_str());
        set_cmt(reveal.dest_addr, dest_comment.c_str(), true);
    }
}

void ctree_string_decrypt_handler_t::annotate_char_string(const char_string_t &str)
{
    if ( str.insn_addrs.empty() ) 
        return;
        
    qstring comment;
    comment.sprnt("DEOBF: Stack string \"%s\"", str.reconstructed.c_str());
    
    // Annotate at first instruction
    set_cmt(str.insn_addrs[0], comment.c_str(), false);
    
    // Also annotate at variable address if global
    if ( str.var_addr != BADADDR ) {
        qstring var_comment;
        var_comment.sprnt("Decrypted: \"%s\"", str.reconstructed.c_str());
        set_cmt(str.var_addr, var_comment.c_str(), true);
    }
}

void ctree_string_decrypt_handler_t::annotate_xor_decrypt(const xor_decrypt_t &xor_info)
{
    if ( xor_info.location == BADADDR ) 
        return;
        
    qstring comment;
    comment.sprnt("DEOBF: XOR decrypts to \"%s\"", xor_info.decrypted.c_str());
    set_cmt(xor_info.location, comment.c_str(), false);
}

void ctree_string_decrypt_handler_t::annotate_crypto_call(const crypto_call_t &crypto)
{
    if ( crypto.location == BADADDR ) 
        return;
        
    qstring comment;
    const char *alg = (crypto.algorithm == 1) ? "AES-256" : "AES-128";
    
    // Convert key to hex for display
    qstring key_hex;
    for ( size_t i = 0; i < crypto.key.size() && i < 16; ++i ) {
        key_hex.cat_sprnt("%02X", crypto.key[i]);
    }
    if ( crypto.key.size() > 16 ) {
        key_hex += "...";
    }
    
    // Include decrypted result if available
    if ( !crypto.decrypted.empty() ) {
        // Truncate long decrypted strings for comment
        qstring decrypted_display = crypto.decrypted;
        if ( decrypted_display.length() > 64 ) {
            decrypted_display.resize(64);
            decrypted_display += "...";
        }
        comment.sprnt("DEOBF: %s %s -> \"%s\" (key=%s)", 
                     crypto.function.c_str(), alg, decrypted_display.c_str(), key_hex.c_str());
    } else {
        comment.sprnt("DEOBF: %s %s key=%s", crypto.function.c_str(), alg, key_hex.c_str());
    }
    
    set_cmt(crypto.location, comment.c_str(), false);
    
    // If we have decrypted data and an output address, annotate there too
    if ( !crypto.decrypted.empty() && crypto.output_addr != BADADDR ) {
        qstring output_comment;
        output_comment.sprnt("AES Decrypted: \"%s\"", crypto.decrypted.c_str());
        set_cmt(crypto.output_addr, output_comment.c_str(), true);
    }
    
    // Also annotate at input address with what was encrypted
    if ( !crypto.decrypted.empty() && crypto.input_addr != BADADDR ) {
        qstring input_comment;
        input_comment.sprnt("Encrypted data -> \"%s\"", crypto.decrypted.c_str());
        set_cmt(crypto.input_addr, input_comment.c_str(), true);
    }
}

//--------------------------------------------------------------------------
// Helper functions
//--------------------------------------------------------------------------
bool ctree_string_decrypt_handler_t::get_string_constant(const cexpr_t *e, qstring *out)
{
    if ( !e || !out ) 
        return false;
        
    if ( e->op == cot_str ) {
        *out = e->string;
        return true;
    }
    
    return false;
}

ea_t ctree_string_decrypt_handler_t::get_address_from_expr(const cexpr_t *e, cfunc_t *cfunc)
{
    if ( !e ) 
        return BADADDR;
        
    if ( e->op == cot_obj ) {
        return e->obj_ea;
    }
    
    if ( e->op == cot_var && cfunc ) {
        // Local variable - no address
        return BADADDR;
    }
    
    return BADADDR;
}

bool ctree_string_decrypt_handler_t::is_string_function(const cexpr_t *e, qstring *func_name)
{
    if ( !e || e->op != cot_call ) 
        return false;
        
    cexpr_t *callee = e->x;
    if ( !callee || callee->op != cot_obj ) 
        return false;
        
    qstring name;
    if ( get_name(&name, callee->obj_ea) <= 0 ) 
        return false;
        
    if ( name.find("strcpy") != qstring::npos ||
        name.find("strncpy") != qstring::npos ||
        name.find("memcpy") != qstring::npos ||
        name.find("memmove") != qstring::npos)
        {
        if ( func_name ) 
            *func_name = name;
        return true;
    }
    
    return false;
}

bool ctree_string_decrypt_handler_t::is_crypto_function(const cexpr_t *e, qstring *func_name)
{
    if ( !e || e->op != cot_call ) 
        return false;
        
    cexpr_t *callee = e->x;
    if ( !callee || callee->op != cot_obj ) 
        return false;
        
    qstring name;
    if ( get_name(&name, callee->obj_ea) <= 0 ) 
        return false;
        
    if ( name.find("CCCrypt") != qstring::npos ||
        name.find("AES_") != qstring::npos ||
        name.find("EVP_") != qstring::npos ||
        name.find("aes_") != qstring::npos)
        {
        if ( func_name ) 
            *func_name = name;
        return true;
    }
    
    return false;
}

bool ctree_string_decrypt_handler_t::get_const_value(const cexpr_t *e, uint64_t *out)
{
    if ( !e || !out ) 
        return false;
        
    if ( e->op == cot_num ) {
        *out = e->numval();
        return true;
    }
    
    return false;
}

bool ctree_string_decrypt_handler_t::get_buffer_contents(ea_t addr, size_t max_len,
                                                         std::vector<uint8_t> *out)
                                                         {
    if ( addr == BADADDR || !out ) 
        return false;
        
    out->resize(max_len);
    ssize_t read = get_bytes(out->data(), max_len, addr);
    if ( read <= 0 ) 
        return false;
        
    out->resize(read);
    return true;
}

int ctree_string_decrypt_handler_t::patch_ctree_reference(cfunc_t *cfunc, ea_t encrypted_addr,
                                                          const qstring &decrypted)
                                                          {
    // TODO: Implement ctree patching to replace encrypted references
    // This is complex and requires careful modification of the ctree
    return 0;
}

```

`src/deobf/handlers/ctree_string_decrypt.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Ctree String Decryption Handler
//
// Analyzes the decompiled ctree to detect and resolve string obfuscation
// patterns that are easier to identify at the high-level IR than at
// microcode level.
//
// Detected patterns:
//
// 1. strcpy/memcpy reveals:
//    strcpy(decrypted_buffer, "plaintext_value");
//    memcpy(buffer, "AES_KEY_HERE", 16);
//    -> The destination variable gets associated with the plaintext
//
// 2. Character-by-character construction:
//    buffer[0] = 'h'; buffer[1] = 'e'; buffer[2] = 'l'; ...
//    buffer[0] = 104; buffer[1] = 101; buffer[2] = 108; ...
//    -> Reconstructs the string from individual assignments
//
// 3. XOR decryption loops:
//    for ( i = 0; i < len; ++i ) dest[i] = src[i] ^ key[i];
//    -> Identifies XOR operations and extracts key if constant
//
// 4. AES/Crypto parameter detection:
//    CCCrypt(kCCDecrypt, kCCAlgorithmAES, ..., key, 16, iv, ...);
//    -> Extracts encryption keys and IVs from crypto calls
//
// 5. String transformation chains:
//    base64_decode(encrypted, decoded);
//    aes_decrypt(decoded, plaintext);
//    -> Tracks data flow through transformation functions
//
// Output:
//   - Annotates decompiled code with decrypted strings
//   - Populates ctx->decrypted_strings for other handlers
//   - Can modify ctree to replace encrypted refs with constants
//--------------------------------------------------------------------------

#include <set>
#include <map>

class ctree_string_decrypt_handler_t {
public:
    // Main entry point - run on decompiled function
    static int run(cfunc_t *cfunc, deobf_ctx_t *ctx);
    
    // Detection - check if function likely has string obfuscation
    static bool detect(cfunc_t *cfunc);

    //----------------------------------------------------------------------
    // Public types (used by visitor classes in .cpp)
    //----------------------------------------------------------------------
    
    // Info about a revealed string
    struct string_reveal_t {
        ea_t location;              // Where in the code
        qstring dest_name;          // Destination variable name
        ea_t dest_addr;             // Destination address (if global)
        qstring plaintext;          // The revealed plaintext
        int reveal_type;            // 0=strcpy, 1=memcpy, 2=assignment
    };
    
    // Find strcpy(dest, "plaintext") patterns
    static std::vector<string_reveal_t> find_strcpy_reveals(cfunc_t *cfunc);
    
    // Find memcpy(dest, "plaintext", size) patterns
    static std::vector<string_reveal_t> find_memcpy_reveals(cfunc_t *cfunc);
    
    //----------------------------------------------------------------------
    // Character-by-character string detection
    //----------------------------------------------------------------------
    
    // Info about a constructed string
    struct char_string_t {
        ea_t start_addr;            // First assignment address
        qstring var_name;           // Variable being assigned to
        ea_t var_addr;              // Global address if applicable
        qstring reconstructed;      // The reconstructed string
        std::vector<ea_t> insn_addrs;  // All assignment addresses
        bool uses_transform;        // XOR/NOT used in assignments
    };
    
    // Find buffer[i] = char patterns and reconstruct strings
    static std::vector<char_string_t> find_char_assignments(cfunc_t *cfunc);
    
    //----------------------------------------------------------------------
    // XOR decryption detection
    //----------------------------------------------------------------------
    
    // Info about an XOR decryption pattern
    struct xor_decrypt_t {
        ea_t location;              // Location of XOR operation
        ea_t encrypted_addr;        // Address of encrypted data
        qstring encrypted_name;     // Name of encrypted variable
        std::vector<uint8_t> xor_keys;  // Extracted XOR keys
        qstring decrypted;          // Decrypted result
    };
    
    // Find XOR operations with constant keys
    static std::vector<xor_decrypt_t> find_xor_patterns(cfunc_t *cfunc);
    
    //----------------------------------------------------------------------
    // Crypto function detection
    //----------------------------------------------------------------------
    
    // Info about a crypto call
    struct crypto_call_t {
        ea_t location;              // Call location
        qstring function;           // "CCCrypt", "AES_decrypt", etc.
        int algorithm;              // 0=AES-128, 1=AES-256, etc.
        std::vector<uint8_t> key;   // Extracted key
        std::vector<uint8_t> iv;    // Extracted IV
        ea_t input_addr;            // Input buffer address
        size_t input_len;           // Input buffer length
        ea_t output_addr;           // Output buffer address
        qstring decrypted;          // Decrypted plaintext (if successful)
    };
    
    // Find crypto function calls and extract parameters
    static std::vector<crypto_call_t> find_crypto_calls(cfunc_t *cfunc);

private:
    //----------------------------------------------------------------------
    // Annotation and patching
    //----------------------------------------------------------------------
    
    // Add comment with decrypted string
    static void annotate_reveal(const string_reveal_t &reveal);
    static void annotate_char_string(const char_string_t &str);
    static void annotate_xor_decrypt(const xor_decrypt_t &xor_info);
    static void annotate_crypto_call(const crypto_call_t &crypto);
    
    // Replace encrypted reference with decrypted constant in ctree
    static int patch_ctree_reference(cfunc_t *cfunc, ea_t encrypted_addr, 
                                     const qstring &decrypted);
    
    // Replace all encrypted strings in ctree using known plaintexts
    static int replace_encrypted_strings(cfunc_t *cfunc,
                                        const std::map<ea_t, qstring> &known_plaintexts);
    
    //----------------------------------------------------------------------
    // Helper functions
    //----------------------------------------------------------------------
    
    // Extract string constant from expression
    static bool get_string_constant(const cexpr_t *e, qstring *out);
    
    // Get variable/global address from expression
    static ea_t get_address_from_expr(const cexpr_t *e, cfunc_t *cfunc);
    
    // Check if expression is a known string function
    static bool is_string_function(const cexpr_t *e, qstring *func_name);
    
    // Check if expression is a known crypto function
    static bool is_crypto_function(const cexpr_t *e, qstring *func_name);
    
    // Try to extract constant value from expression
    static bool get_const_value(const cexpr_t *e, uint64_t *out);
    
    // Try to resolve a buffer's contents from initializers
    static bool get_buffer_contents(ea_t addr, size_t max_len, 
                                    std::vector<uint8_t> *out);
};

```

`src/deobf/handlers/ctree_switch_fold.cpp`:

```cpp
#include "ctree_switch_fold.h"
#include <set>
#include <map>

//--------------------------------------------------------------------------
// Helper: Find a case value in ccases_t (since SDK function may not be exported)
//--------------------------------------------------------------------------
static int find_case_value(const ccases_t &cases, uint64_t v)
{
    for ( size_t i = 0; i < cases.size(); ++i ) {
        const ccase_t &c = cases[i];
        for ( size_t j = 0; j < c.values.size(); ++j ) {
            if ( c.values[j] == v ) 
                return (int)i;
        }
    }
    return -1;
}

//--------------------------------------------------------------------------
// Helper: Check if an expression is a high-bits extraction (HIDWORD pattern)
// Returns true if expr is (x >> 32) or similar high-bits extraction
//--------------------------------------------------------------------------
static bool is_hidword_expr(const cexpr_t *e, int *base_var_idx = nullptr)
{
    if ( !e ) 
        return false;

    // Pattern: (x >> 32) - unsigned or signed shift by 32
    if ( (e->op == cot_ushr || e->op == cot_sshr) && e->y && e->y->op == cot_num ) {
        uint64_t shift = e->y->numval();
        if ( shift == 32 && e->x ) {
            if ( base_var_idx && e->x->op == cot_var ) 
                *base_var_idx = e->x->v.idx;
            return true;
        }
    }

    // Pattern: cast((x >> 32))
    if ( e->op == cot_cast && e->x ) {
        return is_hidword_expr(e->x, base_var_idx);
    }

    // Pattern: (x >> 32) & 0xFFFFFFFF
    if ( e->op == cot_band && e->y && e->y->op == cot_num ) {
        uint64_t mask = e->y->numval();
        if ( mask == 0xFFFFFFFF && e->x ) {
            return is_hidword_expr(e->x, base_var_idx);
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// Helper: Try to evaluate a switch expression to a constant
//--------------------------------------------------------------------------
static bool try_eval_switch_expr(const cexpr_t *e, uint64_t *out_val) {
    if ( !e || !out_val ) 
        return false;

    // Direct constant
    if ( e->op == cot_num ) {
        *out_val = e->numval();
        return true;
    }

    // Cast of constant
    if ( e->op == cot_cast && e->x && e->x->op == cot_num ) {
        *out_val = e->x->numval();
        int size = e->type.get_size();
        if ( size > 0 && size < 8 ) {
            uint64_t mask = (1ULL << (size * 8)) - 1;
            *out_val &= mask;
        }
        return true;
    }

    return false;
}

//--------------------------------------------------------------------------
// Visitor that removes break statements from a block
// This is needed when extracting a case body from a switch
//--------------------------------------------------------------------------
struct break_remover_t : public ctree_visitor_t {
    int removed = 0;

    break_remover_t() : ctree_visitor_t(CV_PARENTS) {}

    int idaapi visit_insn(cinsn_t *ins) override {
        if ( !ins ) 
            return 0;

        // Remove break statements by converting to empty block
        if ( ins->op == cit_break ) {
            ins->op = cit_empty;
            removed++;
        }

        return 0;
    }
};

//--------------------------------------------------------------------------
// First pass: Track variable assignments to find constant patterns
//--------------------------------------------------------------------------
struct var_tracker_visitor_t : public ctree_visitor_t {
    cfunc_t *func;

    // Track assignments to each variable: var_idx -> set of assigned values
    std::map<int, std::set<uint64_t>> var_full_values;

    // Track HIDWORD values: var_idx -> set of high 32-bit values seen
    std::map<int, std::set<uint64_t>> var_hidword_values;

    var_tracker_visitor_t(cfunc_t *f) : ctree_visitor_t(CV_FAST), func(f) {}

    int idaapi visit_expr(cexpr_t *e) override {
        if ( !e ) 
            return 0;

        // Look for assignments: var = value
        if ( e->op == cot_asg && e->x && e->y && e->x->op == cot_var ) {
            int var_idx = e->x->v.idx;

            // Direct constant assignment
            if ( e->y->op == cot_num ) {
                uint64_t val = e->y->numval();
                var_full_values[var_idx].insert(val);

                // Track high 32 bits for 64-bit values
                if ( e->x->type.get_size() == 8 ) {
                    uint64_t hidword = val >> 32;
                    var_hidword_values[var_idx].insert(hidword);
                }
            }

            // OR assignment: var |= (const << 32) - sets HIDWORD
            if ( e->op == cot_asgbor && e->y->op == cot_shl ) {
                cexpr_t *shl = e->y;
                if ( shl->x && shl->x->op == cot_num &&
                    shl->y && shl->y->op == cot_num &&
                    shl->y->numval() == 32)
                    {
                    var_hidword_values[var_idx].insert(shl->x->numval());
                }
            }
        }

        return 0;
    }

    // Check if a variable's HIDWORD is always the same constant
    bool get_constant_hidword(int var_idx, uint64_t *out_val) const {
        auto p = var_hidword_values.find(var_idx);
        if ( p != var_hidword_values.end() && p->second.size() == 1 ) {
            if ( out_val ) 
                *out_val = *p->second.begin();
            return true;
        }
        return false;
    }
};

//--------------------------------------------------------------------------
// Second pass: Fold switches with constant conditions
//--------------------------------------------------------------------------
struct switch_fold_visitor_t : public ctree_visitor_t {
    cfunc_t *func;
    const var_tracker_visitor_t &tracker;
    int changes = 0;

    switch_fold_visitor_t(cfunc_t *f, const var_tracker_visitor_t &t)
        : ctree_visitor_t(CV_PARENTS), func(f), tracker(t) {}

    int idaapi visit_insn(cinsn_t *ins) override {
        if ( !ins || ins->op != cit_switch || !ins->cswitch ) 
            return 0;

        cswitch_t *sw = ins->cswitch;
        cexpr_t *switch_expr = &sw->expr;

        deobf::log("[ctree_switch_fold] Found switch at %a with %zu cases\n",
                  ins->ea, sw->cases.size());

        // Debug: log switch expression type
        deobf::log_verbose("[ctree_switch_fold] Switch expr op=%d\n", switch_expr->op);

        uint64_t const_val = 0;
        bool is_constant = false;

        // Check if switch expression is a direct constant
        if ( try_eval_switch_expr(switch_expr, &const_val) ) {
            is_constant = true;
            deobf::log("[ctree_switch_fold] Switch expression is constant: 0x%llx\n",
                      (unsigned long long)const_val);
        }

        // Check for ( cast )&object pattern - this is a constant address
        // Pattern: cot_cast(cot_ref(cot_obj))
        if ( !is_constant && switch_expr->op == cot_cast && switch_expr->x ) {
            cexpr_t *inner = switch_expr->x;
            if ( inner->op == cot_ref && inner->x && inner->x->op == cot_obj ) {
                // This is &object - get the object address
                ea_t obj_addr = inner->x->obj_ea;
                if ( obj_addr != BADADDR ) {
                    const_val = (uint64_t)obj_addr;
                    is_constant = true;
                    deobf::log("[ctree_switch_fold] Switch on &object: addr 0x%llx\n",
                              (unsigned long long)const_val);
                }
            }
        }

        // Check for HIDWORD pattern with constant
        int hidword_var = -1;
        if ( !is_constant && is_hidword_expr(switch_expr, &hidword_var) ) {
            if ( hidword_var >= 0 && tracker.get_constant_hidword(hidword_var, &const_val) ) {
                is_constant = true;
                deobf::log("[ctree_switch_fold] HIDWORD(var%d) is always 0x%llx\n",
                          hidword_var, (unsigned long long)const_val);
            }
        }

        if ( !is_constant ) 
            return 0;

        // Find the matching case
        int matching_idx = find_case_value(sw->cases, const_val);
        if ( matching_idx < 0 ) {
            // Check for default case
            for ( size_t i = 0; i < sw->cases.size(); ++i ) {
                if ( sw->cases[i].values.empty() ) {
                    matching_idx = (int)i;
                    break;
                }
            }
        }

        if ( matching_idx < 0 ) {
            deobf::log("[ctree_switch_fold] No matching case for value 0x%llx\n",
                      (unsigned long long)const_val);
            return 0;
        }

        deobf::log("[ctree_switch_fold] Replacing switch with case %d body\n", matching_idx);

        // Get the matching case body
        ccase_t &matching_case = sw->cases[matching_idx];

        // The case body IS a cinsn_t (ccase_t extends cinsn_t)
        // We need to copy its contents to replace the switch

        // Remove break statements from the case body
        break_remover_t remover;
        remover.apply_to(&matching_case, nullptr);
        if ( remover.removed > 0 ) {
            deobf::log_verbose("[ctree_switch_fold] Removed %d break statements\n", remover.removed);
        }

        // Replace the switch instruction with the case body
        // We copy the op and relevant fields from the case to the switch insn
        cinsn_t *case_body = &matching_case;

        // Copy the case instruction type and data
        ins->op = case_body->op;
        ins->label_num = case_body->label_num;

        // Copy the appropriate union member based on op type
        switch ( case_body->op ) {
            case cit_block:
                ins->cblock = case_body->cblock;
                case_body->cblock = nullptr;  // Transfer ownership
                break;
            case cit_expr:
                ins->cexpr = case_body->cexpr;
                case_body->cexpr = nullptr;
                break;
            case cit_if:
                ins->cif = case_body->cif;
                case_body->cif = nullptr;
                break;
            case cit_for:
                ins->cfor = case_body->cfor;
                case_body->cfor = nullptr;
                break;
            case cit_while:
                ins->cwhile = case_body->cwhile;
                case_body->cwhile = nullptr;
                break;
            case cit_do:
                ins->cdo = case_body->cdo;
                case_body->cdo = nullptr;
                break;
            case cit_switch:
                ins->cswitch = case_body->cswitch;
                case_body->cswitch = nullptr;
                break;
            case cit_return:
                ins->creturn = case_body->creturn;
                case_body->creturn = nullptr;
                break;
            case cit_goto:
                ins->cgoto = case_body->cgoto;
                case_body->cgoto = nullptr;
                break;
            default:
                // For simple ops like cit_empty, cit_break, cit_continue
                break;
        }

        // The old switch data will be cleaned up when sw goes out of scope
        // But we set cswitch to nullptr so it's not double-freed
        // Actually, we already transferred ownership above

        changes++;
        return 0;
    }
};

//--------------------------------------------------------------------------
// Main entry point
//--------------------------------------------------------------------------
int ctree_switch_fold_handler_t::run(cfunc_t *cfunc) {
    if ( !cfunc ) 
        return 0;

    deobf::log_verbose("[ctree_switch_fold] Running on %a\n", cfunc->entry_ea);

    // First pass: track variable assignments
    var_tracker_visitor_t tracker(cfunc);
    tracker.apply_to(&cfunc->body, nullptr);

    // Log any variables with constant HIDWORD values
    for ( const auto &kv : tracker.var_hidword_values ) {
        if ( kv.second.size() == 1 ) {
            deobf::log_verbose("[ctree_switch_fold] var%d has constant HIDWORD: 0x%llx\n",
                      kv.first, (unsigned long long)*kv.second.begin());
        }
    }

    // Second pass: fold switches
    switch_fold_visitor_t folder(cfunc, tracker);
    folder.apply_to(&cfunc->body, nullptr);

    if ( folder.changes > 0 ) {
        deobf::log("[ctree_switch_fold] Folded %d switches\n", folder.changes);
        // Verify the ctree after modification
        cfunc->verify(ALLOW_UNUSED_LABELS, false);
    }

    return folder.changes;
}

```

`src/deobf/handlers/ctree_switch_fold.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Ctree-level switch folder
//
// Handles switches where the switch expression evaluates to a constant,
// making all but one case unreachable. This is common in flattened code
// where the state variable (often in high bits via HIDWORD) controls flow.
//
// Patterns detected:
//   1. switch ( HIDWORD(x )) where HIDWORD is always a specific constant
//   2. switch ( x >> N ) where the shifted bits are always constant
//   3. switch on variables that are always assigned the same value
//
// This runs after the initial decompilation as a ctree transformation.
//--------------------------------------------------------------------------
class ctree_switch_fold_handler_t {
public:
    // Main entry point - transforms the ctree
    static int run(cfunc_t *cfunc);
};

```

`src/deobf/handlers/deflatten.cpp`:

```cpp
#include "deflatten.h"
#include "identity_call.h"
#include "../analysis/cfg_analysis.h"
#include "../analysis/pattern_match.h"
#include "../analysis/opaque_eval.h"
#include "../analysis/z3_solver.h"
#include "../../common/compat.h"
#include <algorithm>  // for std::find

using namespace z3_solver;

// Static storage for deferred analysis results
std::map<ea_t, deferred_analysis_t> deflatten_handler_t::s_deferred_analysis;

// Clear deferred analysis
void deflatten_handler_t::clear_deferred(ea_t func_ea)
{
    s_deferred_analysis.erase(func_ea);
}

// Check for pending analysis
bool deflatten_handler_t::has_pending_analysis(ea_t func_ea)
{
    auto p = s_deferred_analysis.find(func_ea);
    return p != s_deferred_analysis.end() && p->second.analysis_complete;
}

//--------------------------------------------------------------------------
// Detection
//--------------------------------------------------------------------------
bool deflatten_handler_t::detect(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || mba->qty < 4 ) 
        return false;

    pattern_match::flatten_info_t info;
    return pattern_match::detect_flatten_pattern(mba, &info);
}

//--------------------------------------------------------------------------
// Utility: Check if value is a Hikari state constant
// NOTE: Some obfuscators use non-standard patterns. We now accept:
//   1. Magic patterns (0xDEAD, 0xBEEF, etc.) - classic Hikari
//   2. Any large 32-bit constant that appears repeatedly in comparisons
//      (detected contextually, not just by pattern)
//--------------------------------------------------------------------------
bool deflatten_handler_t::is_state_constant(uint64_t val)
{
    // Must be a 32-bit value in the "suspicious" range
    if ( val < 0x10000000 || val > 0xFFFFFFFF ) 
        return false;

    uint32_t high = (val >> 16) & 0xFFFF;
    if ( high == 0 ) 
        return false;

    // Classic Hikari magic patterns
    switch ( high ) {
        case 0xAAAA: case 0xABCD: case 0xBBBB: case 0xCCCC: case 0xDDDD:
        case 0xBEEF: case 0xCAFE: case 0xDEAD:
        case 0x1111: case 0x2222: case 0x3333: case 0x4444:
        case 0x5555: case 0x6666: case 0x7777: case 0x8888: case 0x9999:
        case 0xFEED: case 0xFACE: case 0xBABE: case 0xC0DE: case 0xF00D:
            return true;
        default:
            break;
    }

    // Extended patterns: accept any value that looks like a state constant
    // These are typically:
    // - Large enough to not be a small index (>= 0x10000000)
    // - Not a typical address (addresses are usually > 0x100000000 on 64-bit)
    // - Have high entropy in both halves (not like 0x00001234 or 0x12340000)
    
    uint16_t low = val & 0xFFFF;
    
    // Both halves should have some bits set (entropy check)
    // This filters out values like 0x12340000 or 0x00001234
    if ( low == 0 || high == 0 ) 
        return false;
    
    // Avoid values that look like shifted addresses or offsets
    // Typical code/data addresses on macOS are 0x100000000+
    // Small offsets would be < 0x10000000
    if ( val >= 0x100000000ULL ) 
        return false;
    
    // Accept as potential state constant if it has entropy in both halves
    // Count set bits - genuine state constants tend to have moderate bit density
    int bit_count = portable_popcount((uint32_t)val);
    
    // State constants typically have 8-24 bits set (not all 0s or all 1s)
    if ( bit_count >= 6 && bit_count <= 26 ) {
        return true;
    }
    
    return false;
}

//--------------------------------------------------------------------------
// Check if a value is a valid jump-table index
//--------------------------------------------------------------------------
static bool is_jump_table_index(uint64_t val, int max_cases)
{
    return val < (uint64_t)max_cases;
}

//--------------------------------------------------------------------------
// Utility: Find all state constants in a block
//--------------------------------------------------------------------------
std::set<uint64_t> deflatten_handler_t::find_state_constants(const mblock_t *blk)
{
    std::set<uint64_t> constants;
    if ( !blk) return constants;

    for ( const minsn_t *ins = blk->head; ins; ins = ins->next ) {
        if ( ins->l.t == mop_n && is_state_constant(ins->l.nnn->value) ) {
            constants.insert(ins->l.nnn->value);
        }
        if ( ins->r.t == mop_n && is_state_constant(ins->r.nnn->value) ) {
            constants.insert(ins->r.nnn->value);
        }

        // Check nested instructions
        if ( ins->l.t == mop_d && ins->l.d ) {
            const minsn_t *nested = ins->l.d;
            if ( nested->l.t == mop_n && is_state_constant(nested->l.nnn->value) ) {
                constants.insert(nested->l.nnn->value);
            }
            if ( nested->r.t == mop_n && is_state_constant(nested->r.nnn->value) ) {
                constants.insert(nested->r.nnn->value);
            }
        }
        if ( ins->r.t == mop_d && ins->r.d ) {
            const minsn_t *nested = ins->r.d;
            if ( nested->l.t == mop_n && is_state_constant(nested->l.nnn->value) ) {
                constants.insert(nested->l.nnn->value);
            }
            if ( nested->r.t == mop_n && is_state_constant(nested->r.nnn->value) ) {
                constants.insert(nested->r.nnn->value);
            }
        }
    }

    return constants;
}

//--------------------------------------------------------------------------
// Utility: Check if block is an exit block
//--------------------------------------------------------------------------
bool deflatten_handler_t::is_exit_block(const mblock_t *blk)
{
    if ( !blk || !blk->tail ) 
        return false;

    // Check for return instruction or no successors
    return blk->tail->opcode == m_ret || blk->nsucc() == 0;
}

//--------------------------------------------------------------------------
// Utility: Get all successor blocks
//--------------------------------------------------------------------------
std::vector<int> deflatten_handler_t::get_successors(const mblock_t *blk)
{
    std::vector<int> successors;
    if ( !blk ) 
        return successors;

    for ( int i = 0; i < blk->nsucc(); ++i ) {
        successors.push_back(blk->succ(i));
    }
    return successors;
}

//--------------------------------------------------------------------------
// Analyze a single block to determine if it's a dispatcher
//--------------------------------------------------------------------------
bool deflatten_handler_t::analyze_dispatcher_block(mbl_array_t *mba, int block_idx,
                                                     dispatcher_info_t *out)
                                                     {
    if ( !mba || !out || block_idx < 0 || block_idx >= mba->qty ) 
        return false;

    mblock_t *blk = mba->get_mblock(block_idx);
    if ( !blk ) 
        return false;

    out->block_idx = block_idx;
    out->is_solved = false;

    // Find state constants in this block
    std::set<uint64_t> state_consts = find_state_constants(blk);

    if ( state_consts.size() < 2 ) {
        return false;
    }

    // Look for comparison patterns: setXX var, state_const
    mop_t potential_state_var;
    bool found_state_var = false;
    int consistent_comparisons = 0;

    for ( const minsn_t *ins = blk->head; ins; ins = ins->next ) {
        // Look for conditional jumps
        if ( !deobf::is_jcc(ins->opcode) ) 
            continue;

        // Extract comparison from condition
        if ( ins->l.t == mop_d && ins->l.d ) {
            const minsn_t *cmp = ins->l.d;
            if ( is_mcode_set(cmp->opcode) ) {
                uint64_t state_val = 0;
                bool found_const = false;
                mop_t var;

                if ( cmp->l.t == mop_n && is_state_constant(cmp->l.nnn->value) ) {
                    state_val = cmp->l.nnn->value;
                    var = cmp->r;
                    found_const = true;
                } else if ( cmp->r.t == mop_n && is_state_constant(cmp->r.nnn->value) ) {
                    state_val = cmp->r.nnn->value;
                    var = cmp->l;
                    found_const = true;
                }

                if ( found_const && ins->d.t == mop_b ) {
                    if ( !found_state_var ) {
                        potential_state_var = var;
                        found_state_var = true;
                    }
                    out->state_to_block[state_val] = ins->d.b;
                    out->case_blocks.insert(ins->d.b);
                    consistent_comparisons++;
                }
            }
        }
    }

    if ( consistent_comparisons < 2 || !found_state_var ) {
        return false;
    }

    // Convert mop to symbolic_var_t
    if ( potential_state_var.t == mop_S && potential_state_var.s ) {
        out->state_var = symbolic_var_t(symbolic_var_t::VAR_STACK,
                                         potential_state_var.s->off,
                                         potential_state_var.size);
    } else if ( potential_state_var.t == mop_r ) {
        out->state_var = symbolic_var_t(symbolic_var_t::VAR_REGISTER,
                                         potential_state_var.r,
                                         potential_state_var.size);
    } else if ( potential_state_var.t == mop_v ) {
        out->state_var = symbolic_var_t(symbolic_var_t::VAR_GLOBAL,
                                         potential_state_var.g,
                                         potential_state_var.size);
    } else if ( potential_state_var.t == mop_l && potential_state_var.l ) {
        out->state_var = symbolic_var_t(symbolic_var_t::VAR_LOCAL,
                                         potential_state_var.l->idx,
                                         potential_state_var.size);
    } else {
        return false;
    }

    out->dispatcher_chain.insert(block_idx);
    out->is_solved = true;

    deobf::log("[deflatten] Found dispatcher at block %d with %zu state mappings\n",
              block_idx, out->state_to_block.size());

    return true;
}

//--------------------------------------------------------------------------
// Index variable info - represents a state variable in jump table flattening
//--------------------------------------------------------------------------
struct index_var_info_t {
    mop_t var;              // The index variable (stack or local)
    int dispatcher_block;   // Block where this var is used for dispatch
    ea_t jump_table;        // Associated jump table address
    int num_cases;          // Number of cases in jump table

    index_var_info_t() : dispatcher_block(-1), jump_table(BADADDR), num_cases(0) {}
};

//--------------------------------------------------------------------------
// Extract index variable from a multiplication expression
// Handles patterns like: 8 * xds(var) or xds(var) * 8
//--------------------------------------------------------------------------
static bool extract_index_from_mul(const minsn_t *mul_ins, mop_t *out_var)
{
    if ( !mul_ins || mul_ins->opcode != m_mul ) 
        return false;

    // Check if multiplying by 8 (pointer size for 64-bit)
    const mop_t *index_op = nullptr;
    if ( mul_ins->r.t == mop_n && mul_ins->r.nnn->value == 8 ) {
        index_op = &mul_ins->l;
    } else if ( mul_ins->l.t == mop_n && mul_ins->l.nnn->value == 8 ) {
        index_op = &mul_ins->r;
    }

    if ( !index_op ) 
        return false;

    // The index might be sign-extended (xds instruction)
    if ( index_op->t == mop_d && index_op->d && index_op->d->opcode == m_xds ) {
        *out_var = index_op->d->l;
        return true;
    }

    // Or it might be a direct variable reference
    if ( index_op->t == mop_S || index_op->t == mop_l || index_op->t == mop_r ) {
        *out_var = *index_op;
        return true;
    }

    return false;
}

//--------------------------------------------------------------------------
// Find index variable used in a block ending with ijmp
// Traces backwards from ijmp to find the variable used as index
// Handles pattern: ldx ds, (BASE + 8 * xds(INDEX_VAR)), dst; ijmp cs, dst
//--------------------------------------------------------------------------
static bool find_index_variable(mblock_t *blk, index_var_info_t *out)
{
    if ( !blk || !blk->tail || blk->tail->opcode != m_ijmp ) 
        return false;

    // The ijmp target comes from a register loaded via computed address
    // Pattern: ldx ds, [table + index*8] -> reg; ijmp cs, reg

    // Find the ldx that provides the jump target
    for ( minsn_t *ins = blk->tail->prev; ins; ins = ins->prev ) {
        if ( ins->opcode != m_ldx ) 
            continue;

        // ldx has: l=segment, r=address, d=destination
        // We need to analyze the address operand (r)
        const mop_t &addr = ins->r;

        // The address is a compound expression like (base + index*8)
        if ( addr.t == mop_d && addr.d ) {
            const minsn_t *addr_expr = addr.d;

            // Look for add operation
            if ( addr_expr->opcode == m_add ) {
                // Check both operands for mul by 8
                mop_t index_var;

                // Check left operand for mul*8
                if ( addr_expr->l.t == mop_d && addr_expr->l.d ) {
                    if ( extract_index_from_mul(addr_expr->l.d, &index_var) ) {
                        out->var = index_var;
                        out->dispatcher_block = blk->serial;
                        deobf::log_verbose("[deflatten] Found index var in ldx at block %d (type=%d)\n",
                                  blk->serial, index_var.t);
                        return true;
                    }
                }

                // Check right operand for mul*8
                if ( addr_expr->r.t == mop_d && addr_expr->r.d ) {
                    if ( extract_index_from_mul(addr_expr->r.d, &index_var) ) {
                        out->var = index_var;
                        out->dispatcher_block = blk->serial;
                        deobf::log_verbose("[deflatten] Found index var in ldx at block %d (type=%d)\n",
                                  blk->serial, index_var.t);
                        return true;
                    }
                }
            }
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// Find all writes of small integer constants to a given variable in a block
// Returns pairs of (written_value, writing_instruction)
//--------------------------------------------------------------------------
static std::vector<std::pair<uint64_t, minsn_t*>>
find_index_writes(mblock_t *blk, const mop_t &index_var, int max_value = 300)
{
    std::vector<std::pair<uint64_t, minsn_t*>> writes;

    if ( !blk ) 
        return writes;

    for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
        // Look for mov of small constant to the index variable
        if ( ins->opcode != m_mov ) 
            continue;

        // Check if source is a small constant
        if ( ins->l.t != mop_n ) 
            continue;

        uint64_t val = ins->l.nnn->value;
        if ( val > (uint64_t)max_value ) 
            continue;

        // Check if destination matches the index variable
        // Need to compare the variable identity
        bool match = false;
        if ( ins->d.t == index_var.t ) {
            if ( index_var.t == mop_S ) {
                // Stack variable - compare offset
                match = (ins->d.s->off == index_var.s->off);
            } else if ( index_var.t == mop_l ) {
                // Local variable - compare index
                match = (ins->d.l->idx == index_var.l->idx);
            } else if ( index_var.t == mop_r ) {
                // Register - compare register
                match = (ins->d.r == index_var.r);
            }
        }

        if ( match ) {
            writes.push_back({val, ins});
        }
    }

    return writes;
}

//--------------------------------------------------------------------------
// Find ALL writes of small integers to ANY stack/local variable in a block
// This is for jump table flattening where multiple index variables exist
// Returns pairs of (written_value, stack_offset_or_local_idx)
//--------------------------------------------------------------------------
static std::vector<std::pair<uint64_t, int64_t>>
find_all_index_writes(mblock_t *blk, int max_value = 300)
{
    std::vector<std::pair<uint64_t, int64_t>> writes;

    if ( !blk ) 
        return writes;

    // Track register values for backward data flow within this block
    // Key: register, Value: constant value (or -1 if unknown/non-constant)
    std::map<mreg_t, int64_t> reg_values;

    for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
        uint64_t val = 0;
        int64_t var_id = -1;
        bool found = false;

        // Track register assignments: mov #const, reg
        if ( ins->opcode == m_mov && ins->l.t == mop_n && ins->d.t == mop_r ) {
            uint64_t cval = ins->l.nnn->value;
            if ( cval <= (uint64_t)max_value ) {
                reg_values[ins->d.r] = (int64_t)cval;
            } else {
                reg_values[ins->d.r] = -1;  // Large value, mark as unknown
            }
        }

        // Also track xdu/xds (zero/sign extend) from constants
        if ( (ins->opcode == m_xdu || ins->opcode == m_xds) && ins->d.t == mop_r ) {
            // Check if source contains a constant
            if ( ins->l.t == mop_n ) {
                uint64_t cval = ins->l.nnn->value;
                if ( cval <= (uint64_t)max_value ) {
                    reg_values[ins->d.r] = (int64_t)cval;
                }
            } else if ( ins->l.t == mop_d && ins->l.d ) {
                // Nested expression - check if it produces a constant
                // Common pattern: xdu (x == 0) or xdu (x & mask)
                // For now, mark as unknown
                reg_values[ins->d.r] = -1;
            }
        }

        // Handle mov instruction: mov src, dst
        if ( ins->opcode == m_mov ) {
            // Direct constant to stack
            if ( ins->l.t == mop_n ) {
                val = ins->l.nnn->value;
                if ( val <= (uint64_t)max_value ) {
                    if ( ins->d.size == 4 || ins->d.size == 8 ) {
                        if ( ins->d.t == mop_S ) {
                            var_id = ins->d.s->off;
                            found = true;
                        } else if ( ins->d.t == mop_l ) {
                            var_id = ins->d.l->idx;
                            found = true;
                        }
                    }
                }
            }
            // Register to stack - look up register value
            else if ( ins->l.t == mop_r && (ins->d.t == mop_S || ins->d.t == mop_l) ) {
                auto p = reg_values.find(ins->l.r);
                if ( p != reg_values.end() && p->second >= 0 && p->second <= max_value ) {
                    val = (uint64_t)p->second;
                    if ( ins->d.size == 4 || ins->d.size == 8 ) {
                        if ( ins->d.t == mop_S ) {
                            var_id = ins->d.s->off;
                            found = true;
                        } else if ( ins->d.t == mop_l ) {
                            var_id = ins->d.l->idx;
                            found = true;
                        }
                    }
                }
            }
        }
        // Handle stx instruction: stx val, seg, dst
        else if ( ins->opcode == m_stx ) {
            // Direct constant
            if ( ins->l.t == mop_n ) {
                val = ins->l.nnn->value;
                if ( val <= (uint64_t)max_value && (ins->l.size == 4 || ins->l.size == 8) ) {
                    if ( ins->d.t == mop_S ) {
                        var_id = ins->d.s->off;
                        found = true;
                    } else if ( ins->d.t == mop_l ) {
                        var_id = ins->d.l->idx;
                        found = true;
                    }
                }
            }
            // Register value
            else if ( ins->l.t == mop_r ) {
                auto p = reg_values.find(ins->l.r);
                if ( p != reg_values.end() && p->second >= 0 && p->second <= max_value ) {
                    val = (uint64_t)p->second;
                    if ( ins->l.size == 4 || ins->l.size == 8 ) {
                        if ( ins->d.t == mop_S ) {
                            var_id = ins->d.s->off;
                            found = true;
                        } else if ( ins->d.t == mop_l ) {
                            var_id = ins->d.l->idx;
                            found = true;
                        }
                    }
                }
            }
        }

        if ( found && var_id >= 0 ) {
            writes.push_back({val, var_id});
        }

        // Clear register value if it's overwritten by something non-constant
        if ( ins->d.t == mop_r ) {
            if ( ins->opcode != m_mov || ins->l.t != mop_n ) {
                if ( ins->opcode != m_xdu && ins->opcode != m_xds ) {
                    reg_values[ins->d.r] = -1;
                }
            }
        }
    }

    return writes;
}

//--------------------------------------------------------------------------
// Trace backward from an ijmp block to find the constant state value
// that will be used as the index. Returns the state value, or -1 if not found.
//
// This performs backward dataflow analysis within the block and across
// predecessor blocks (up to a depth limit) to resolve the index value.
//
// For stack variables, we look for:
//   mov #const, [sp+offset]   or   stx #const, offset, sp
// where offset matches the index variable's stack offset.
//--------------------------------------------------------------------------
static int64_t trace_ijmp_state_value(mbl_array_t *mba, int ijmp_blk_idx,
                                       const mop_t &index_var, int max_depth = 3)
                                       {
    if ( !mba || ijmp_blk_idx < 0 || ijmp_blk_idx >= mba->qty ) 
        return -1;

    // Get the stack offset we're looking for ( if stack variable )
    int64_t target_stack_off = -1;
    if ( index_var.t == mop_S && index_var.s ) {
        target_stack_off = index_var.s->off;
    }

    // Stack for blocks to analyze: (block_idx, depth)
    std::vector<std::pair<int, int>> worklist;
    std::set<int> visited;
    worklist.push_back({ijmp_blk_idx, 0});

    while ( !worklist.empty() ) {
        auto [blk_idx, depth] = worklist.back();
        worklist.pop_back();

        if ( visited.count(blk_idx) || depth > max_depth ) 
            continue;
        visited.insert(blk_idx);

        mblock_t *blk = mba->get_mblock(blk_idx);
        if ( !blk ) 
            continue;

        // Track register values as we scan backward
        std::map<mreg_t, int64_t> reg_values;

        // Scan instructions in reverse order
        for ( minsn_t *ins = blk->tail; ins; ins = ins->prev ) {
            // Check for mov of constant to index variable (direct match)
            if ( ins->opcode == m_mov && ins->l.t == mop_n ) {
                int64_t val = (int64_t)ins->l.nnn->value;
                bool matches = false;

                // Check if destination matches index variable
                if ( ins->d.t == index_var.t ) {
                    if ( index_var.t == mop_S && ins->d.s && index_var.s ) {
                        matches = (ins->d.s->off == index_var.s->off);
                    } else if ( index_var.t == mop_l && ins->d.l && index_var.l ) {
                        matches = (ins->d.l->idx == index_var.l->idx);
                    } else if ( index_var.t == mop_r ) {
                        matches = (ins->d.r == index_var.r);
                    }
                }

                if ( matches && val >= 0 && val < 300 ) {
                    return val;
                }
            }

            // Check for stx (store) to stack - stx src, offset, base
            // This handles: stx #const, offset, sp -> stores const to [sp+offset]
            if ( ins->opcode == m_stx && target_stack_off >= 0 ) {
                // Check if storing to the right stack location
                // stx format: l=source, r=offset, d=base
                if ( ins->r.t == mop_n && ins->d.t == mop_r ) {
                    int64_t offset = (int64_t)ins->r.nnn->value;
                    // Check if this matches our target stack offset (approximately)
                    if ( offset == target_stack_off ||
                        (offset >= target_stack_off - 8 && offset <= target_stack_off + 8))
                        {
                        // Check source
                        if ( ins->l.t == mop_n ) {
                            int64_t val = (int64_t)ins->l.nnn->value;
                            if ( val >= 0 && val < 300 ) {
                                return val;
                            }
                        } else if ( ins->l.t == mop_r ) {
                            auto p = reg_values.find(ins->l.r);
                            if ( p != reg_values.end() && p->second >= 0 ) {
                                return p->second;
                            }
                        }
                    }
                }
            }

            // Check for mov from register to index variable
            if ( ins->opcode == m_mov && ins->l.t == mop_r && ins->d.t == index_var.t ) {
                bool matches = false;
                if ( index_var.t == mop_S && ins->d.s && index_var.s ) {
                    matches = (ins->d.s->off == index_var.s->off);
                } else if ( index_var.t == mop_l && ins->d.l && index_var.l ) {
                    matches = (ins->d.l->idx == index_var.l->idx);
                }

                if ( matches ) {
                    auto p = reg_values.find(ins->l.r);
                    if ( p != reg_values.end() && p->second >= 0 ) {
                        return p->second;
                    }
                }
            }

            // Track register constant assignments (scanning backwards)
            if ( ins->opcode == m_mov && ins->d.t == mop_r ) {
                if ( ins->l.t == mop_n ) {
                    int64_t val = (int64_t)ins->l.nnn->value;
                    if ( val >= 0 && val < 300 ) {
                        reg_values[ins->d.r] = val;
                    }
                } else if ( ins->l.t == mop_r ) {
                    // Register copy
                    auto p = reg_values.find(ins->l.r);
                    if ( p != reg_values.end() ) {
                        reg_values[ins->d.r] = p->second;
                    }
                }
            }

            // Handle xdu/xds (zero/sign extension)
            if ( (ins->opcode == m_xdu || ins->opcode == m_xds) && ins->d.t == mop_r ) {
                if ( ins->l.t == mop_n ) {
                    int64_t val = (int64_t)ins->l.nnn->value;
                    if ( val >= 0 && val < 300 ) {
                        reg_values[ins->d.r] = val;
                    }
                }
            }
        }

        // If not found in this block, check predecessors
        // For single-predecessor blocks, always continue
        // For multi-predecessor blocks, only continue for a few levels (the value may differ)
        if ( depth < max_depth ) {
            if ( blk->npred() == 1 ) {
                int pred = blk->pred(0);
                if ( !visited.count(pred) ) {
                    worklist.push_back({pred, depth + 1});
                }
            } else if ( depth < 2 ) {
                // For multi-predecessor within first 2 levels, try all paths
                for ( int i = 0; i < blk->npred(); ++i ) {
                    int pred = blk->pred(i);
                    if ( !visited.count(pred) ) {
                        worklist.push_back({pred, depth + 1});
                    }
                }
            }
        }
    }

    return -1;  // Not found
}

//--------------------------------------------------------------------------
// Analyze jump table-based flattening (index-based, not magic constants)
// Returns true if this appears to be jump table flattening
//--------------------------------------------------------------------------
bool deflatten_handler_t::analyze_jump_table_flattening(mbl_array_t *mba,
                                           std::vector<dispatcher_info_t> &dispatchers)
                                           {
    if ( !mba ) 
        return false;

    // Step 1: Find all blocks with indirect jumps and their index variables
    std::vector<index_var_info_t> index_vars;
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk || !blk->tail ) 
            continue;
        if ( blk->tail->opcode == m_ijmp ) {
            index_var_info_t info;
            if ( find_index_variable(blk, &info) ) {
                index_vars.push_back(info);
                int64_t var_off = -1;
                if ( info.var.t == mop_S && info.var.s ) 
                    var_off = info.var.s->off;
                else if ( info.var.t == mop_l && info.var.l ) 
                    var_off = info.var.l->idx;
                deobf::log("[deflatten] Block %d: found index var (type=%d, off=%lld)\n",
                          i, info.var.t, (long long)var_off);
            }
        }
    }

    if ( index_vars.empty() ) {
        deobf::log("[deflatten] No index variables found in ijmp blocks\n");
        // Fall through to IDA switch-based analysis
    } else {
        deobf::log("[deflatten] Found %zu index variables in ijmp blocks\n", index_vars.size());
    }

    // Step 2: Get IDA's switch detection for mapping state values to blocks
    func_t *pfn = get_func(mba->entry_ea);
    if ( !pfn ) {
        deobf::log("[deflatten] Could not get function for switch analysis\n");
        return false;
    }

    // Collect all switches in the function
    std::map<ea_t, switch_info_t> switches;
    ea_t ea = pfn->start_ea;
    while ( ea < pfn->end_ea ) {
        switch_info_t si;
        if ( get_switch_info(&si, ea) > 0 && si.get_jtable_size() >= 10 ) {
            switches[ea] = si;
        }
        ea = next_head(ea, pfn->end_ea);
        if ( ea == BADADDR) break;
    }

    if ( switches.empty() ) {
        deobf::log("[deflatten] No IDA-detected switches found\n");
        return false;
    }

    deobf::log("[deflatten] Found %zu IDA-detected switches\n", switches.size());

    // Step 3: Build dispatcher info for each large switch
    // For jump table flattening, we need to:
    // - Map state values (indices) to case blocks
    // - Identify which index variable each dispatcher uses
    // - Find state transitions by tracing index writes in case blocks

    // Find the primary (largest) jump table - this is likely the main dispatcher
    ea_t primary_switch_ea = BADADDR;
    int max_cases = 0;
    for ( const auto& kv : switches ) {
        if ( (int)kv.second.get_jtable_size() > max_cases ) {
            max_cases = kv.second.get_jtable_size();
            primary_switch_ea = kv.first;
        }
    }

    if ( primary_switch_ea == BADADDR ) {
        deobf::log("[deflatten] No primary switch found\n");
        return false;
    }

    const switch_info_t &primary_si = switches[primary_switch_ea];
    deobf::log("[deflatten] Primary switch at %a: %d cases, table at %a\n",
              primary_switch_ea, max_cases, primary_si.jumps);

    // Build the main dispatcher
    dispatcher_info_t disp;
    disp.is_solved = true;
    disp.is_jump_table = true;  // Jump-table style uses small integer states
    disp.max_state = max_cases;

    // Find the dispatcher block
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( blk && blk->start <= primary_switch_ea && primary_switch_ea < blk->end ) {
            disp.block_idx = i;
            break;
        }
    }

    // Build state_to_block mapping from jump table
    ea_t table = primary_si.jumps;
    int num_cases = (int)primary_si.get_jtable_size();

    int identity_resolved_count = 0;
    for ( int idx = 0; idx < num_cases && idx < 300; ++idx ) {
        ea_t raw_target = 0;
        if ( get_bytes(&raw_target, sizeof(ea_t), table + idx * sizeof(ea_t)) == sizeof(ea_t) ) {
            ea_t target = raw_target;

            // Resolve through identity call trampolines if present
            // This handles Hikari's pattern where table entries point to
            // wrapper functions that use identity calls for indirection
            ea_t resolved = identity_call_handler_t::resolve_trampoline_chain(raw_target);
            if ( resolved != raw_target && resolved != BADADDR ) {
                // Resolved through a trampoline chain
                identity_resolved_count++;
                deobf::log_verbose("[deflatten] Table[%d]: %a -> %a (identity resolved)\n",
                                  idx, raw_target, resolved);
                target = resolved;
            }

            // Find the block containing this target
            for ( int bi = 0; bi < mba->qty; bi++ ) {
                mblock_t *blk = mba->get_mblock(bi);
                if ( blk && blk->start <= target && target < blk->end ) {
                    disp.state_to_block[idx] = bi;
                    disp.case_blocks.insert(bi);
                    break;
                }
            }
        }
    }

    if ( identity_resolved_count > 0 ) {
        deobf::log("[deflatten] Resolved %d/%d table entries through identity call chains\n",
                  identity_resolved_count, num_cases);
    }
    deobf::log("[deflatten] Built state_to_block with %zu mappings\n", disp.state_to_block.size());

    // Step 4: Build a map of index variable offsets -> their usage
    // For jump table flattening, multiple index variables control different entry points
    std::set<int64_t> known_index_offsets;
    for ( const auto &iv : index_vars ) {
        if ( iv.var.t == mop_S ) {
            known_index_offsets.insert(iv.var.s->off);
        } else if ( iv.var.t == mop_l ) {
            known_index_offsets.insert(iv.var.l->idx);
        }
    }

    deobf::log("[deflatten] Found %zu unique index variable offsets:\n", known_index_offsets.size());
    for ( int64_t off : known_index_offsets ) {
        deobf::log("[deflatten]   offset: %lld (0x%llx)\n", (long long)off, (unsigned long long)off);
    }

    // Step 5: For each case block, find ALL writes of small integers
    // This captures state transitions regardless of which index variable is used
    struct transition_t {
        int from_block;       // Case block handling current state
        uint64_t from_state;  // State value this block handles
        uint64_t to_state;    // State value being written
        int64_t var_offset;   // Which index variable is written
    };

    std::vector<transition_t> transitions;
    std::map<int, std::vector<std::pair<uint64_t, int64_t>>> block_writes;

    int total_writes_found = 0;
    int sample_count = 0;
    for ( const auto &kv : disp.state_to_block ) {
        uint64_t state_val = kv.first;
        int case_idx = kv.second;

        mblock_t *case_blk = mba->get_mblock(case_idx);
        if ( !case_blk ) 
            continue;

        // Debug: log first few case blocks
        if ( sample_count < 5 ) {
            int ins_count = 0;
            for ( minsn_t *p = case_blk->head; p; p = p->next) ins_count++;
            deobf::log("[deflatten] Scanning case block %d (state 0x%llx), %d instructions\n",
                      case_idx, (unsigned long long)state_val, ins_count);
            for ( minsn_t *ins = case_blk->head; ins && sample_count < 5; ins = ins->next ) {
                if ( ins->opcode == m_mov ) {
                    deobf::log("[deflatten]   mov: src.t=%d dst.t=%d",
                              ins->l.t, ins->d.t);
                    if ( ins->l.t == mop_n ) {
                        deobf::log(" src_val=%llu", (unsigned long long)ins->l.nnn->value);
                    }
                    if ( ins->d.t == mop_S ) {
                        deobf::log(" dst_off=%lld", (long long)ins->d.s->off);
                    }
                    deobf::log("\n");
                }
            }
            sample_count++;
        }

        auto writes = find_all_index_writes(case_blk, num_cases);
        total_writes_found += writes.size();
        block_writes[case_idx] = writes;

        // Debug: show first few writes
        static int write_debug_count = 0;
        if ( write_debug_count < 10 && !writes.empty() ) {
            deobf::log("[deflatten] Block %d writes:\n", case_idx);
            for ( const auto &w : writes ) {
                deobf::log("[deflatten]   val=%llu to offset=%lld (known=%s)\n",
                          (unsigned long long)w.first, (long long)w.second,
                          known_index_offsets.count(w.second) ? "YES" : "no");
            }
            write_debug_count++;
        }

        for ( const auto &w : writes ) {
            // For now, count ALL small integer writes to stack vars
            // In jump-table flattening, the state variable offsets may vary
            // We'll filter more precisely later based on observed patterns
            transition_t t;
            t.from_block = case_idx;
            t.from_state = state_val;
            t.to_state = w.first;
            t.var_offset = w.second;
            transitions.push_back(t);

            // Log if this IS a known index offset
            if ( known_index_offsets.count(w.second) ) {
                deobf::log("[deflatten] Matched known offset %lld\n", (long long)w.second);
            }
        }
    }

    deobf::log("[deflatten] Total small int writes found: %d (matched to known offsets: %zu)\n",
              total_writes_found, transitions.size());

    deobf::log("[deflatten] Found %zu state transitions across %zu case blocks\n",
              transitions.size(), block_writes.size());

    // Log some sample transitions
    int logged = 0;
    for ( const auto &t : transitions ) {
        if ( logged < 20 ) {
            deobf::log("[deflatten] Transition: block %d (state 0x%llx) -> state 0x%llx (var off %lld)\n",
                      t.from_block, (unsigned long long)t.from_state,
                      (unsigned long long)t.to_state, (long long)t.var_offset);
            logged++;
        }
    }

    // If we found transitions, this confirms jump table flattening
    if ( !transitions.empty() ) {
        // Use the most commonly written index variable as the primary state var
        std::map<int64_t, int> offset_counts;
        for ( const auto &t : transitions ) {
            offset_counts[t.var_offset]++;
        }

        int64_t best_offset = 0;
        int best_count = 0;
        for ( const auto &kv : offset_counts ) {
            if ( kv.second > best_count ) {
                best_count = kv.second;
                best_offset = kv.first;
            }
        }

        deobf::log("[deflatten] Primary index var offset: %lld (used in %d transitions)\n",
                  (long long)best_offset, best_count);

        // Set up the state variable
        disp.state_var = z3_solver::symbolic_var_t(
            z3_solver::symbolic_var_t::VAR_STACK,
            (uint64_t)best_offset, 4);
    } else if ( !index_vars.empty() ) {
        // Fall back to using the first index variable
        const index_var_info_t &primary_idx = index_vars[0];

        z3_solver::symbolic_var_t::var_kind_t var_kind = z3_solver::symbolic_var_t::VAR_STACK;
        uint64_t var_id = 0;
        int var_size = primary_idx.var.size > 0 ? primary_idx.var.size : 4;

        if ( primary_idx.var.t == mop_S ) {
            var_kind = z3_solver::symbolic_var_t::VAR_STACK;
            var_id = (uint64_t)primary_idx.var.s->off;
        } else if ( primary_idx.var.t == mop_l ) {
            var_kind = z3_solver::symbolic_var_t::VAR_LOCAL;
            var_id = (uint64_t)primary_idx.var.l->idx;
        }

        disp.state_var = z3_solver::symbolic_var_t(var_kind, var_id, var_size);
        deobf::log("[deflatten] Using fallback index var (kind=%d, id=%llu)\n",
                  (int)var_kind, (unsigned long long)var_id);
    }

    // Mark all dispatcher-related blocks
    disp.dispatcher_chain.insert(disp.block_idx);

    // Add all blocks with indirect jumps to the same jump table
    for ( const auto& kv : switches ) {
        if ( kv.second.jumps == primary_si.jumps ) {
            for ( int i = 0; i < mba->qty; ++i ) {
                mblock_t *blk = mba->get_mblock(i);
                if ( blk && blk->start <= kv.first && kv.first < blk->end ) {
                    disp.dispatcher_chain.insert(i);
                }
            }
        }
    }

    deobf::log("[deflatten] Dispatcher chain has %zu blocks\n", disp.dispatcher_chain.size());

    if ( disp.state_to_block.size() >= 10 ) {
        disp.is_solved = true;  // Mark as solved so trace_transitions_z3 will process it
        dispatchers.push_back(disp);
    }

    return !dispatchers.empty();
}

//--------------------------------------------------------------------------
// Analyze all dispatchers in the function using Z3
//--------------------------------------------------------------------------
std::vector<deflatten_handler_t::dispatcher_info_t>
deflatten_handler_t::analyze_dispatchers_z3(mbl_array_t *mba)
{
    std::vector<dispatcher_info_t> dispatchers;

    if ( !mba ) 
        return dispatchers;

    // Reset Z3 context for fresh analysis
    reset_global_context();

    // First pass: find all potential dispatcher blocks (constant-based)
    for ( int i = 0; i < mba->qty; ++i ) {
        dispatcher_info_t disp;
        if ( analyze_dispatcher_block(mba, i, &disp) ) {
            dispatchers.push_back(disp);
        }
    }

    // If no constant-based dispatchers, try jump table-based analysis
    if ( dispatchers.empty() ) {
        deobf::log("[deflatten] No constant-based dispatchers, trying jump table analysis...\n");
        if ( analyze_jump_table_flattening(mba, dispatchers) ) {
            deobf::log("[deflatten] Jump table flattening detected with %zu dispatchers\n",
                      dispatchers.size());
            // For jump table flattening, we currently just log the detection
            // Full deflattening would require tracing index variable assignments
            // which is complex because there's no single "state variable"
            return dispatchers;
        }
    }

    if ( dispatchers.empty() ) {
        // Try broader search using Z3's state machine solver
        state_machine_solver_t solver(get_global_context());
        auto machine = solver.solve_state_machine(mba);

        if ( machine.solved ) {
            for ( const auto& z3_disp : machine.dispatchers ) {
                dispatcher_info_t disp;
                disp.block_idx = z3_disp.block_idx;
                disp.state_var = z3_disp.state_var;
                disp.state_to_block = z3_disp.state_to_block;
                disp.is_solved = true;

                for ( const auto& kv : z3_disp.state_to_block ) {
                    disp.case_blocks.insert(kv.second);
                }

                // Compute dispatcher_chain: only blocks that COMPARE state constants
                // (dispatcher conditional blocks), NOT blocks that WRITE state constants
                // (those are transition blocks that we want to create edges from)
                for ( int i = 0; i < mba->qty; ++i ) {
                    if ( disp.case_blocks.count(i) ) 
                        continue;  // Skip case blocks

                    mblock_t *blk = mba->get_mblock(i);
                    if ( !blk ) 
                        continue;

                    // Check if this block has a state constant COMPARISON (not just presence)
                    // Look for setXX or jcc patterns that compare against state constants
                    bool has_state_comparison = false;
                    for ( const minsn_t *ins = blk->head; ins; ins = ins->next ) {
                        // Check for setXX instructions (setz, setnz, setl, etc.)
                        if ( ins->opcode >= m_sets && ins->opcode <= m_setnz ) {
                            // Check if comparing against a state constant
                            if ( (ins->l.t == mop_n && is_state_constant(ins->l.nnn->value)) ||
                                (ins->r.t == mop_n && is_state_constant(ins->r.nnn->value)))
                                {
                                has_state_comparison = true;
                                break;
                            }
                        }
                        // Check for jcc with embedded comparison
                        if ( deobf::is_jcc(ins->opcode) ) {
                            if ( ins->l.t == mop_d && ins->l.d ) {
                                const minsn_t *cmp = ins->l.d;
                                if ( (cmp->l.t == mop_n && is_state_constant(cmp->l.nnn->value)) ||
                                    (cmp->r.t == mop_n && is_state_constant(cmp->r.nnn->value)))
                                    {
                                    has_state_comparison = true;
                                    break;
                                }
                            }
                        }
                    }

                    if ( has_state_comparison ) {
                        disp.dispatcher_chain.insert(i);
                    }
                }

                dispatchers.push_back(disp);
            }
        }
    }

    // Second pass: extend dispatcher chains (cascading conditionals)
    for ( auto& disp : dispatchers ) {
        std::vector<int> worklist;
        for ( int i = 0; i < mba->get_mblock(disp.block_idx)->nsucc(); ++i ) {
            worklist.push_back(mba->get_mblock(disp.block_idx)->succ(i));
        }

        while ( !worklist.empty() ) {
            int idx = worklist.back();
            worklist.pop_back();

            if ( disp.dispatcher_chain.count(idx) || disp.case_blocks.count(idx) ) 
                continue;

            mblock_t *blk = mba->get_mblock(idx);
            if ( !blk ) 
                continue;

            // Check if this block also has state comparisons (cascading)
            std::set<uint64_t> consts = find_state_constants(blk);
            if ( consts.size() >= 2 ) {
                disp.dispatcher_chain.insert(idx);

                // Add state mappings from this block too
                for ( const minsn_t *ins = blk->head; ins; ins = ins->next ) {
                    if ( !deobf::is_jcc(ins->opcode) ) 
                        continue;

                    if ( ins->l.t == mop_d && ins->l.d && ins->d.t == mop_b ) {
                        const minsn_t *cmp = ins->l.d;
                        uint64_t state_val = 0;

                        if ( cmp->l.t == mop_n && is_state_constant(cmp->l.nnn->value) ) {
                            state_val = cmp->l.nnn->value;
                        } else if ( cmp->r.t == mop_n && is_state_constant(cmp->r.nnn->value) ) {
                            state_val = cmp->r.nnn->value;
                        }

                        if ( state_val != 0 ) {
                            disp.state_to_block[state_val] = ins->d.b;
                            disp.case_blocks.insert(ins->d.b);
                        }
                    }
                }

                // Continue following this block's successors
                for ( int i = 0; i < blk->nsucc(); ++i ) {
                    worklist.push_back(blk->succ(i));
                }
            }
        }
    }

    // Establish parent-child relationships for nested dispatchers
    for ( size_t i = 0; i < dispatchers.size(); ++i ) {
        for ( size_t j = 0; j < dispatchers.size(); ++j ) {
            if ( i == j ) 
                continue;

            // Check if dispatcher j is within a case block of dispatcher i
            for ( int case_blk : dispatchers[i].case_blocks ) {
                if ( dispatchers[j].dispatcher_chain.count(case_blk) ||
                    case_blk == dispatchers[j].block_idx)
                    {
                    dispatchers[j].parent_dispatcher = (int)i;
                    dispatchers[j].nesting_level = dispatchers[i].nesting_level + 1;
                }
            }
        }
    }

    // Sort by nesting level (deepest first for bottom-up processing)
    std::sort(dispatchers.begin(), dispatchers.end(),
              [](const dispatcher_info_t &a, const dispatcher_info_t &b)
              {
                  return a.nesting_level > b.nesting_level;
              });

    return dispatchers;
}

//--------------------------------------------------------------------------
// Solve for the next state value written by a block using Z3
//--------------------------------------------------------------------------
std::optional<uint64_t> deflatten_handler_t::solve_written_state(
    mbl_array_t *mba,
    int block_idx,
    const symbolic_var_t &state_var,
    int max_jump_table_state)
    {

    if ( !mba || block_idx < 0 || block_idx >= mba->qty ) 
        return std::nullopt;

    mblock_t *blk = mba->get_mblock(block_idx);
    if ( !blk ) 
        return std::nullopt;

    // Helper lambda: validate state value based on dispatcher type
    auto is_valid_state = [max_jump_table_state](uint64_t val) -> bool {
        if ( max_jump_table_state > 0 ) {
            // Jump-table: accept small indices [0..max]
            return val <= (uint64_t)max_jump_table_state;
        } else {
            // Hikari: require magic constant patterns
            return is_state_constant(val);
        }
    };

    // Use Z3 symbolic execution
    symbolic_executor_t executor(get_global_context());

    // Execute the block symbolically
    executor.execute_block(blk);

    // Try to get the final value of the state variable
    auto value = executor.get_value(state_var);
    if ( value.has_value() ) {
        auto concrete = executor.solve_for_value(value.value());
        if ( concrete.has_value() && is_valid_state(*concrete) ) {
            return concrete;
        }
    }

    // Fallback: scan for direct constant assignments
    for ( const minsn_t *ins = blk->head; ins; ins = ins->next ) {
        if ( ins->opcode != m_mov ) 
            continue;

        if ( ins->l.t != mop_n || !is_valid_state(ins->l.nnn->value) ) 
            continue;

        // Check if destination matches state variable
        bool matches = false;
        if ( ins->d.t == mop_S && state_var.kind() == symbolic_var_t::VAR_STACK ) {
            if ( ins->d.s && ins->d.s->off == (sval_t)state_var.id() ) 
                matches = true;
        } else if ( ins->d.t == mop_r && state_var.kind() == symbolic_var_t::VAR_REGISTER ) {
            if ( ins->d.r == (mreg_t)state_var.id() ) 
                matches = true;
        } else if ( ins->d.t == mop_v && state_var.kind() == symbolic_var_t::VAR_GLOBAL ) {
            if ( ins->d.g == (ea_t)state_var.id() ) 
                matches = true;
        } else if ( ins->d.t == mop_l && state_var.kind() == symbolic_var_t::VAR_LOCAL ) {
            if ( ins->d.l && ins->d.l->idx == (int)state_var.id() ) 
                matches = true;
        }

        if ( matches ) {
            return ins->l.nnn->value;
        }
    }

    return std::nullopt;
}

//--------------------------------------------------------------------------
// Analyze conditional transitions within case blocks
//--------------------------------------------------------------------------
std::vector<deflatten_handler_t::cfg_edge_t>
deflatten_handler_t::analyze_conditional_transitions(
    mbl_array_t *mba,
    int block_idx,
    const symbolic_var_t &state_var)
    {

    std::vector<cfg_edge_t> edges;

    if ( !mba || block_idx < 0 || block_idx >= mba->qty ) 
        return edges;

    mblock_t *blk = mba->get_mblock(block_idx);
    if ( !blk || !blk->tail ) 
        return edges;

    // Check if this block has a conditional branch
    if ( !deobf::is_jcc(blk->tail->opcode) ) 
        return edges;

    // Get the branch targets
    int true_target = -1;
    int false_target = -1;

    if ( blk->tail->d.t == mop_b ) {
        true_target = blk->tail->d.b;
    }

    // Find fall-through target
    for ( int i = 0; i < blk->nsucc(); ++i ) {
        int succ = blk->succ(i);
        if ( succ != true_target ) {
            false_target = succ;
            break;
        }
    }

    // Use Z3 to analyze each branch
    mcode_translator_t translator(get_global_context());
    z3::expr condition = translator.translate_jcc_condition(blk->tail);

    // True branch
    if ( true_target >= 0 ) {
        // Execute true path symbolically
        symbolic_executor_t executor(get_global_context());
        executor.execute_block(blk);
        executor.add_constraint(condition);

        auto written_state = solve_written_state(mba, block_idx, state_var);

        cfg_edge_t edge;
        edge.from_block = block_idx;
        edge.is_conditional = true;
        edge.is_true_branch = true;
        edge.condition = std::make_shared<z3::expr>(condition);
        if ( written_state.has_value() ) {
            edge.state_value = *written_state;
        }
        // to_block will be resolved later based on state value
        edges.push_back(edge);
    }

    // False branch
    if ( false_target >= 0 ) {
        symbolic_executor_t executor(get_global_context());
        executor.execute_block(blk);
        executor.add_constraint(!condition);

        cfg_edge_t edge;
        edge.from_block = block_idx;
        edge.is_conditional = true;
        edge.is_true_branch = false;
        edge.condition = std::make_shared<z3::expr>(!condition);
        edges.push_back(edge);
    }

    return edges;
}

//--------------------------------------------------------------------------
// Use Z3 symbolic execution to trace state transitions through case blocks
//--------------------------------------------------------------------------
std::vector<deflatten_handler_t::cfg_edge_t>
deflatten_handler_t::trace_transitions_z3(mbl_array_t *mba,
                                           const dispatcher_info_t &disp)
                                           {
    std::vector<cfg_edge_t> edges;

    if ( !mba || !disp.is_solved ) 
        return edges;

    deobf::log("[deflatten] Tracing transitions for dispatcher at block %d\n", disp.block_idx);
    deobf::log("[deflatten]   %zu case blocks to analyze\n", disp.case_blocks.size());

    // Use the dispatcher's is_jump_table flag, or detect if not set
    bool is_jump_table = disp.is_jump_table;
    if ( !is_jump_table && !disp.state_to_block.empty() ) {
        // Fall back to heuristic detection if flag not set
        is_jump_table = true;
        for ( const auto &kv : disp.state_to_block ) {
            if ( kv.first >= 500 ) {
                is_jump_table = false;
                break;
            }
        }
    }
    if ( is_jump_table ) {
        deobf::log("[deflatten] Using jump-table tracing (small integer states)\n");

        int max_cases = disp.max_state > 0 ? disp.max_state : (int)disp.state_to_block.size();

        // Build set of all case blocks for reference
        std::set<int> case_blocks;
        for ( const auto &kv : disp.state_to_block ) {
            case_blocks.insert(kv.second);
        }

        // APPROACH: Find all blocks that write small integer values to stack
        // and eventually flow to the dispatcher (directly or through ijmp blocks).
        // These are the blocks where we need to redirect control flow.

        // First, scan ALL blocks for small integer writes
        std::map<int, std::vector<std::pair<uint64_t, int64_t>>> block_writes;
        for ( int blk_idx = 0; blk_idx < mba->qty; blk_idx++ ) {
            mblock_t *blk = mba->get_mblock(blk_idx);
            if ( !blk) continue;

            auto writes = find_all_index_writes(blk, max_cases);
            if ( !writes.empty() ) {
                block_writes[blk_idx] = writes;
            }
        }

        deobf::log("[deflatten]   Found %zu blocks with index writes\n", block_writes.size());

        // ALSO check jtbl instructions for conditional transitions
        // jtbl targets are block indices - we need to trace through them to find state writes
        int jtbl_transitions = 0;
        for ( int blk_idx = 0; blk_idx < mba->qty; blk_idx++ ) {
            mblock_t *blk = mba->get_mblock(blk_idx);
            if ( !blk || !blk->tail ) 
                continue;

            // Skip dispatcher chain blocks
            if ( disp.dispatcher_chain.count(blk_idx) ) 
                continue;

            // Look for jtbl instruction at end of block
            if ( blk->tail->opcode == m_jtbl && blk->tail->r.t == mop_c ) {
                mcases_t *cases = blk->tail->r.c;
                if ( cases && !cases->empty() ) {
                    // Each target is a block index - trace through to find state write
                    for ( size_t i = 0; i < cases->size(); ++i ) {
                        int target_blk_idx = cases->targets[i];
                        if ( target_blk_idx < 0 || target_blk_idx >= mba->qty ) 
                            continue;

                        // Trace through target block to find state write
                        mblock_t *target_blk = mba->get_mblock(target_blk_idx);
                        if ( !target_blk ) 
                            continue;

                        // Look for index writes in target block
                        auto writes = find_all_index_writes(target_blk, max_cases);
                        for ( const auto &w : writes ) {
                            uint64_t written_state = w.first;
                            auto p = disp.state_to_block.find(written_state);
                            if ( p != disp.state_to_block.end() ) {
                                int final_target = p->second;
                                if ( final_target != blk_idx ) {
                                    cfg_edge_t edge;
                                    edge.from_block = target_blk_idx;  // Redirect from the jtbl target
                                    edge.to_block = final_target;
                                    edge.state_value = written_state;
                                    edge.is_conditional = false;
                                    edges.push_back(edge);
                                    jtbl_transitions++;
                                }
                            }
                        }
                    }
                }
            }
        }
        if ( jtbl_transitions > 0 ) {
            deobf::log("[deflatten]   Found %d transitions via jtbl targets\n", jtbl_transitions);
        }

        // For each block that writes an index, check if it eventually leads to dispatcher
        std::set<int> dispatcher_and_ijmp;
        dispatcher_and_ijmp.insert(disp.dispatcher_chain.begin(), disp.dispatcher_chain.end());

        // Also add ijmp blocks (blocks ending with m_ijmp are dispatcher entry points)
        for ( int blk_idx = 0; blk_idx < mba->qty; blk_idx++ ) {
            mblock_t *blk = mba->get_mblock(blk_idx);
            if ( blk && blk->tail && blk->tail->opcode == m_ijmp ) {
                dispatcher_and_ijmp.insert(blk_idx);
            }
        }

        for ( const auto &bw : block_writes ) {
            int write_blk = bw.first;
            const auto &writes = bw.second;

            // Skip dispatcher chain blocks themselves
            if ( disp.dispatcher_chain.count(write_blk) ) 
                continue;

            // Check if any successor (within 10 hops) is a dispatcher/ijmp block
            // Also check if the block itself ends with ijmp/goto to dispatcher
            bool leads_to_dispatcher = false;
            mblock_t *wb = mba->get_mblock(write_blk);
            if ( wb && wb->tail ) {
                // If block ends with ijmp or goto, check target
                if ( wb->tail->opcode == m_ijmp ) {
                    leads_to_dispatcher = true;  // Block itself is an ijmp
                } else if ( wb->tail->opcode == m_goto && wb->nsucc() == 1 ) {
                    int target = wb->succ(0);
                    if ( dispatcher_and_ijmp.count(target) ) 
                        leads_to_dispatcher = true;
                }
            }

            if ( !leads_to_dispatcher ) {
                std::set<int> visited;
                std::vector<std::pair<int, int>> queue;
                queue.push_back({write_blk, 0});

                while ( !queue.empty() && !leads_to_dispatcher ) {
                    auto [cur, depth] = queue.front();
                    queue.erase(queue.begin());

                    if ( depth > 10 || visited.count(cur) ) 
                        continue;
                    visited.insert(cur);

                    mblock_t *blk = mba->get_mblock(cur);
                    if ( !blk) continue;

                    for ( int i = 0; i < blk->nsucc(); ++i ) {
                        int succ = blk->succ(i);
                        if ( dispatcher_and_ijmp.count(succ) ) {
                            leads_to_dispatcher = true;
                            break;
                        }
                        if ( !visited.count(succ) ) {
                            queue.push_back({succ, depth + 1});
                        }
                    }
                }
            }

            if ( !leads_to_dispatcher ) 
                continue;

            // This block writes an index and leads to dispatcher - create edges
            for ( const auto &w : writes ) {
                uint64_t written_state = w.first;

                auto p = disp.state_to_block.find(written_state);
                if ( p == disp.state_to_block.end() ) 
                    continue;

                int target_blk = p->second;
                if ( write_blk == target_blk ) 
                    continue;  // Skip self-loops

                cfg_edge_t edge;
                edge.from_block = write_blk;
                edge.to_block = target_blk;
                edge.state_value = written_state;
                edge.is_conditional = false;
                edges.push_back(edge);

                deobf::log("[deflatten]   Write blk %d -> case %d (state 0x%llx)\n",
                          write_blk, target_blk, (unsigned long long)written_state);
            }
        }

        // ENHANCED: For each ijmp block, try to resolve its target using backward tracing
        // This handles cases where the state write is not immediately before the ijmp
        int ijmp_resolved = 0;
        std::set<int> already_has_edge;
        for ( const auto &e : edges ) {
            already_has_edge.insert(e.from_block);
        }

        for ( int blk_idx = 0; blk_idx < mba->qty; blk_idx++ ) {
            // Skip blocks that already have edges
            if ( already_has_edge.count(blk_idx) ) 
                continue;

            mblock_t *blk = mba->get_mblock(blk_idx);
            if ( !blk || !blk->tail || blk->tail->opcode != m_ijmp ) 
                continue;

            // Skip dispatcher chain blocks
            if ( disp.dispatcher_chain.count(blk_idx) ) 
                continue;

            // Find the index variable for this ijmp
            index_var_info_t idx_info;
            if ( !find_index_variable(blk, &idx_info) ) {
                deobf::log_verbose("[deflatten]   ijmp blk %d: no index var found\n", blk_idx);
                continue;
            }

            // Trace backward to find the state value
            int64_t state_val = trace_ijmp_state_value(mba, blk_idx, idx_info.var, 5);
            if ( state_val < 0 || state_val >= max_cases ) {
                deobf::log_verbose("[deflatten]   ijmp blk %d: state trace failed (val=%lld)\n",
                          blk_idx, (long long)state_val);
                continue;
            }

            // Look up the target block
            auto p = disp.state_to_block.find((uint64_t)state_val);
            if ( p == disp.state_to_block.end() ) 
                continue;

            int target_blk = p->second;
            if ( target_blk == blk_idx ) 
                continue;  // Skip self-loops

            cfg_edge_t edge;
            edge.from_block = blk_idx;
            edge.to_block = target_blk;
            edge.state_value = (uint64_t)state_val;
            edge.is_conditional = false;
            edges.push_back(edge);
            ijmp_resolved++;

            deobf::log("[deflatten]   ijmp blk %d traced -> case %d (state %lld)\n",
                      blk_idx, target_blk, (long long)state_val);
        }

        if ( ijmp_resolved > 0 ) {
            deobf::log("[deflatten]   Resolved %d additional ijmp blocks via backward tracing\n",
                      ijmp_resolved);
        }

        deobf::log("[deflatten]   Traced %zu jump-table transitions total\n", edges.size());
        return edges;
    }

    // Build reverse map: state value -> case block that handles it
    std::map<uint64_t, int> state_to_case;
    for ( const auto& kv : disp.state_to_block ) {
        state_to_case[kv.first] = kv.second;
    }

    // Scan ALL blocks for state writes (state assignments may be in blocks
    // separate from the case block targets due to microcode block splitting)
    std::map<int, uint64_t> block_writes_state;  // block -> state value it writes

    // Track register -> state constant for indirect writes (stx pattern)
    std::map<mreg_t, uint64_t> reg_to_state;

    for ( int blk_idx = 0; blk_idx < mba->qty; blk_idx++ ) {
        mblock_t *blk = mba->get_mblock(blk_idx);
        if ( !blk ) 
            continue;

        reg_to_state.clear();  // Reset per block

        // First pass: build register state map including copies
        for ( const minsn_t *ins = blk->head; ins; ins = ins->next ) {
            if ( ins->opcode == m_mov && ins->d.t == mop_r ) {
                if ( ins->l.t == mop_n && is_state_constant(ins->l.nnn->value) ) {
                    // Direct load of state constant to register
                    reg_to_state[ins->d.r] = ins->l.nnn->value;
                } else if ( ins->l.t == mop_r && reg_to_state.count(ins->l.r) ) {
                    // Register to register copy - propagate state
                    reg_to_state[ins->d.r] = reg_to_state[ins->l.r];
                }
            }
        }

        // Second pass: look for state writes
        // IMPORTANT: Don't break after first match! Hikari often has TWO state writes:
        //   1. At entry: write own state (initialization)
        //   2. At exit: write next state (transition target)
        // We want the LAST write, which is the actual transition.
        for ( const minsn_t *ins = blk->head; ins; ins = ins->next ) {
            // Check for stx (store) instruction - m_stx = 1
            // stx src, offset, base -> mem[base + offset] = src
            if ( ins->opcode == m_stx ) {
                uint64_t state_val = 0;
                if ( ins->l.t == mop_n && is_state_constant(ins->l.nnn->value) ) {
                    state_val = ins->l.nnn->value;
                } else if ( ins->l.t == mop_r && reg_to_state.count(ins->l.r) ) {
                    state_val = reg_to_state[ins->l.r];
                }

                if ( state_val != 0 ) {
                    block_writes_state[blk_idx] = state_val;
                    deobf::log_verbose("[deflatten]   Block %d writes state 0x%llx via stx\n",
                              blk_idx, (unsigned long long)state_val);
                    // Don't break - keep looking for later writes
                }
            }

            // Direct mov of state constant to any destination
            // At different maturities, destination may be mop_S (stack), mop_r (register),
            // mop_v (global), or mop_l (local)
            if ( ins->opcode == m_mov && ins->l.t == mop_n &&
                is_state_constant(ins->l.nnn->value))
                {
                // Accept any destination type - the fact that a state constant
                // is being moved is what matters
                block_writes_state[blk_idx] = ins->l.nnn->value;
                deobf::log_verbose("[deflatten]   Block %d writes state 0x%llx via mov (d.t=%d)\n",
                          blk_idx, (unsigned long long)ins->l.nnn->value, ins->d.t);
                // Don't break - keep looking for later writes
            }

            // Pattern: or var, #shifted_constant, dest
            // Hikari encodes state in high 32 bits: 0xDEAD000200000000
            if ( ins->opcode == m_or && ins->r.t == mop_n ) {
                uint64_t orval = ins->r.nnn->value;
                // Check if high 32 bits contain a state constant
                uint32_t high32 = (uint32_t)(orval >> 32);
                if ( is_state_constant(high32) ) {
                    block_writes_state[blk_idx] = high32;
                    deobf::log_verbose("[deflatten]   Block %d writes state 0x%x via or (shifted const 0x%llx)\n",
                              blk_idx, high32, (unsigned long long)orval);
                    // Don't break - keep looking for later writes
                }
            }
        }

    }

    deobf::log("[deflatten]   Found %zu blocks that write state values:\n", block_writes_state.size());
    for ( const auto& kv : block_writes_state ) {
        deobf::log("[deflatten]     block %d -> writes 0x%llx\n",
                  kv.first, (unsigned long long)kv.second);
    }
    deobf::log("[deflatten]   state_to_case map has %zu entries:\n", state_to_case.size());
    for ( const auto& st : state_to_case ) {
        deobf::log("[deflatten]     state 0x%llx -> case block %d\n",
                  (unsigned long long)st.first, st.second);
    }

    // Debug: Check case blocks that don't appear to write any state
    // Also trace through their successors to find where state writes happen
    for ( const auto& st : state_to_case ) {
        int case_blk = st.second;
        if ( block_writes_state.find(case_blk) == block_writes_state.end() ) {
            mblock_t *blk = mba->get_mblock(case_blk);
            if ( blk ) {
                deobf::log("[deflatten]   WARNING: case block %d (handles 0x%llx) writes no detected state!\n",
                          case_blk, (unsigned long long)st.first);
                // Check successors for state writes
                for ( int i = 0; i < blk->nsucc(); ++i ) {
                    int succ_idx = blk->succ(i);
                    if ( block_writes_state.find(succ_idx) != block_writes_state.end() ) {
                        deobf::log("[deflatten]     -> successor %d writes 0x%llx\n",
                                  succ_idx, (unsigned long long)block_writes_state[succ_idx]);
                    } else {
                        // Dump what's in the successor
                        mblock_t *succ_blk = mba->get_mblock(succ_idx);
                        if ( succ_blk ) {
                            int insn_count = 0;
                            for ( const minsn_t *ins = succ_blk->head; ins; ins = ins->next ) 
                                insn_count++;
                            deobf::log("[deflatten]     -> successor %d has no detected state write (%d insns, nsucc=%d):\n",
                                      succ_idx, insn_count, succ_blk->nsucc());
                            for ( const minsn_t *ins = succ_blk->head; ins; ins = ins->next ) {
                                qstring insn_str;
                                ins->print(&insn_str);
                                deobf::log("[deflatten]        [op=%d] %s\n", ins->opcode, insn_str.c_str());
                            }
                            // If it's a goto block, show where it goes
                            if ( succ_blk->nsucc() > 0 ) {
                                deobf::log("[deflatten]        successors of %d:", succ_idx);
                                for ( int j = 0; j < succ_blk->nsucc(); ++j ) {
                                    deobf::log(" %d", succ_blk->succ(j));
                                }
                                deobf::log("\n");
                            }
                        }
                    }
                }
            }
        }
    }

    // For each block that writes a state, trace back to find which case block
    // it belongs to, then create an edge from that case to the target of the written state
    for ( const auto& kv : block_writes_state ) {
        int write_blk = kv.first;
        uint64_t written_state = kv.second;

        // Skip if written state isn't in our state map
        auto target_it = state_to_case.find(written_state);
        if ( target_it == state_to_case.end() ) {
            deobf::log("[deflatten]   Block %d writes 0x%llx but not in state_to_case map\n",
                      write_blk, (unsigned long long)written_state);
            continue;
        }

        int target_blk = target_it->second;

        // Skip if write block is part of dispatcher chain (not a real case block)
        if ( disp.dispatcher_chain.count(write_blk) ) 
            continue;

        // Skip if write block IS the target (self-loop doesn't help)
        if ( write_blk == target_blk ) 
            continue;

        // Create edge: redirect write_blk's goto to target_blk
        cfg_edge_t edge;
        edge.from_block = write_blk;
        edge.to_block = target_blk;
        edge.state_value = written_state;
        edge.is_conditional = false;

        edges.push_back(edge);

        deobf::log("[deflatten]   Edge: block %d -> case %d (state 0x%llx)\n",
                  write_blk, target_blk, (unsigned long long)written_state);
    }

    // Also check case blocks directly for any embedded state writes
    int jt_max = disp.is_jump_table ? disp.max_state : -1;
    for ( int case_blk : disp.case_blocks ) {
        if ( disp.dispatcher_chain.count(case_blk) ) 
            continue;

        auto next_state = solve_written_state(mba, case_blk, disp.state_var, jt_max);
        if ( next_state.has_value() ) {
            auto p = disp.state_to_block.find(*next_state);
            if ( p != disp.state_to_block.end() && p->second != case_blk ) {
                // Check if we already have this edge
                bool exists = false;
                for ( const auto& e : edges ) {
                    if ( e.from_block == case_blk && e.to_block == p->second ) {
                        exists = true;
                        break;
                    }
                }
                if ( !exists ) {
                    cfg_edge_t edge;
                    edge.from_block = case_blk;
                    edge.to_block = p->second;
                    edge.state_value = *next_state;
                    edge.is_conditional = false;
                    edges.push_back(edge);
                }
            }
        }
    }

    deobf::log("[deflatten]   Traced %zu transitions total\n", edges.size());
    return edges;
}

//--------------------------------------------------------------------------
// Verify CFG modification is safe
//--------------------------------------------------------------------------
bool deflatten_handler_t::verify_cfg_safety(mbl_array_t *mba,
                                             const std::vector<cfg_edge_t> &edges)
                                             {
    if ( !mba ) 
        return false;

    for ( const auto& edge : edges ) {
        // Verify source and target blocks exist
        if ( edge.from_block < 0 || edge.from_block >= mba->qty ) 
            return false;
        if ( edge.to_block >= 0 && edge.to_block >= mba->qty ) 
            return false;

        // Verify no self-loops on unconditional edges
        if ( !edge.is_conditional && edge.from_block == edge.to_block ) 
            return false;
    }

    return true;
}

// Forward declarations
static bool convert_ijmp_to_goto(mbl_array_t *mba, int src_idx, int new_target);
static bool redirect_unconditional_edge(mbl_array_t *mba, int src_idx, int new_target);

//--------------------------------------------------------------------------
// Helper: Trace through CFG to find the first ijmp block reachable from start
// Uses BFS with depth limit to avoid infinite loops
// Returns the block index of the ijmp block, or -1 if not found
//--------------------------------------------------------------------------
static int find_reachable_ijmp(mbl_array_t *mba, int start_block, int max_depth = 5)
{
    if ( !mba || start_block < 0 || start_block >= mba->qty ) 
        return -1;

    std::set<int> visited;
    std::vector<std::pair<int, int>> queue;  // (block_idx, depth)
    queue.push_back({start_block, 0});

    while ( !queue.empty() ) {
        auto [blk_idx, depth] = queue.front();
        queue.erase(queue.begin());

        if ( visited.count(blk_idx) || depth > max_depth ) 
            continue;
        visited.insert(blk_idx);

        mblock_t *blk = mba->get_mblock(blk_idx);
        if ( !blk || !blk->tail ) 
            continue;

        // Found an ijmp block
        if ( blk->tail->opcode == m_ijmp ) {
            return blk_idx;
        }

        // Continue searching through successors
        for ( int i = 0; i < blk->nsucc(); ++i ) {
            int succ = blk->succ(i);
            if ( !visited.count(succ) ) {
                queue.push_back({succ, depth + 1});
            }
        }
    }

    return -1;  // No ijmp found within depth limit
}

//--------------------------------------------------------------------------
// Helper: Redirect a call block's fall-through to a new target
// Strategy: Trace through the CFG to find the dispatcher (ijmp) block
// and redirect it to the target. This handles arbitrary intermediate blocks.
//--------------------------------------------------------------------------
static bool redirect_call_fallthrough(mbl_array_t *mba, int src_idx, int new_target)
{
    if ( !mba || src_idx < 0 || src_idx >= mba->qty || new_target < 0 || new_target >= mba->qty ) 
        return false;

    mblock_t *src = mba->get_mblock(src_idx);
    mblock_t *dst = mba->get_mblock(new_target);
    if ( !src || !dst || !src->tail ) 
        return false;

    if ( src->tail->opcode != m_call ) 
        return false;

    // Get the current fall-through target
    int old_target = -1;
    if ( src->nsucc() > 0 ) {
        old_target = src->succ(0);
    }

    if ( old_target == new_target ) 
        return true;  // Already pointing to the right place

    // Trace through the CFG to find the dispatcher (ijmp) block
    int ijmp_blk = find_reachable_ijmp(mba, old_target, 8);

    if ( ijmp_blk >= 0 ) {
        deobf::log_verbose("[deflatten]   Found ijmp dispatcher at block %d via tracing from call succ %d\n",
                  ijmp_blk, old_target);

        // Convert the ijmp to goto
        if ( convert_ijmp_to_goto(mba, ijmp_blk, new_target) ) {
            return true;
        }
    }

    // Check intermediate blocks for direct goto->ijmp patterns
    if ( old_target >= 0 && old_target < mba->qty ) {
        mblock_t *succ = mba->get_mblock(old_target);
        if ( succ && succ->tail ) {
            deobf::log_verbose("[deflatten]   Call succ block %d has tail op=%d\n",
                      old_target, succ->tail->opcode);

            if ( succ->tail->opcode == m_ijmp ) {
                // The successor is a dispatcher block - convert it to goto
                if ( convert_ijmp_to_goto(mba, old_target, new_target) ) {
                    return true;
                }
            }
            // Maybe the successor is a goto to a dispatcher
            else if ( succ->tail->opcode == m_goto && succ->nsucc() == 1 ) {
                int next_blk = succ->succ(0);
                if ( next_blk >= 0 && next_blk < mba->qty ) {
                    mblock_t *next = mba->get_mblock(next_blk);
                    if ( next && next->tail && next->tail->opcode == m_ijmp ) {
                        // Chain: call -> goto -> ijmp
                        // Redirect the goto
                        if ( redirect_unconditional_edge(mba, old_target, new_target) ) {
                            return true;
                        }
                    }
                }
            }
        }
    }

    return false;  // Can't safely redirect call blocks at this maturity
}

//--------------------------------------------------------------------------
// Helper: Convert an ijmp block to a direct goto
// ijmp format: ijmp segment, target_register
// goto format: goto block_ref
//--------------------------------------------------------------------------
static bool convert_ijmp_to_goto(mbl_array_t *mba, int src_idx, int new_target)
{
    if ( !mba || src_idx < 0 || src_idx >= mba->qty || new_target < 0 || new_target >= mba->qty ) 
        return false;

    mblock_t *src = mba->get_mblock(src_idx);
    mblock_t *dst = mba->get_mblock(new_target);
    if ( !src || !dst || !src->tail ) 
        return false;

    minsn_t *tail = src->tail;
    if ( tail->opcode != m_ijmp ) 
        return false;

    // Convert the ijmp to goto by modifying in place
    // This is safer than removing/inserting instructions
    tail->opcode = m_goto;
    tail->l.make_blkref(new_target);
    tail->r.erase();  // Clear the right operand
    tail->d.erase();  // Clear the destination operand

    // ijmp blocks have no successors in the succset (computed jump)
    // After conversion to goto, we need to add the target
    src->succset.clear();
    src->succset.push_back(new_target);

    // Add src to dst's predset
    auto p = std::find(dst->predset.begin(), dst->predset.end(), src_idx);
    if ( p == dst->predset.end() ) {
        dst->predset.push_back(src_idx);
    }

    // Set block type to 1-way (unconditional goto)
    src->type = BLT_1WAY;

    // Mark lists as dirty
    src->mark_lists_dirty();
    dst->mark_lists_dirty();

    return true;
}

//--------------------------------------------------------------------------
// Helper: Convert a jtbl block to a direct goto to the initial state target
// This eliminates the switch statement from the decompiled output
//
// jtbl format: jtbl index_expr, mcases*
// goto format: goto block_ref
//--------------------------------------------------------------------------
static bool convert_jtbl_to_goto(mbl_array_t *mba, int src_idx, int new_target)
{
    if ( !mba || src_idx < 0 || src_idx >= mba->qty || new_target < 0 || new_target >= mba->qty ) 
        return false;

    mblock_t *src = mba->get_mblock(src_idx);
    mblock_t *dst = mba->get_mblock(new_target);
    if ( !src || !dst || !src->tail ) 
        return false;

    minsn_t *tail = src->tail;
    if ( tail->opcode != m_jtbl ) 
        return false;

    // Get current targets from mcases so we can update their predsets
    std::set<int> old_targets;
    if ( tail->r.t == mop_c && tail->r.c ) {
        mcases_t *cases = tail->r.c;
        for ( size_t i = 0; i < cases->size(); ++i ) {
            old_targets.insert(cases->targets[i]);
        }
    }

    // Convert the jtbl to goto by modifying in place
    tail->opcode = m_goto;
    tail->l.make_blkref(new_target);
    tail->r.erase();  // Clear the mcases operand
    tail->d.erase();  // Clear the destination operand

    // Update successor list
    src->succset.clear();
    src->succset.push_back(new_target);

    // Remove src from old targets' predsets
    for ( int old_tgt : old_targets ) {
        if ( old_tgt >= 0 && old_tgt < mba->qty && old_tgt != new_target ) {
            mblock_t *old_blk = mba->get_mblock(old_tgt);
            if ( old_blk ) {
                auto p = std::find(old_blk->predset.begin(), old_blk->predset.end(), src_idx);
                if ( p != old_blk->predset.end() ) {
                    old_blk->predset.erase(p);
                }
                old_blk->mark_lists_dirty();
            }
        }
    }

    // Add src to dst's predset
    auto p = std::find(dst->predset.begin(), dst->predset.end(), src_idx);
    if ( p == dst->predset.end() ) {
        dst->predset.push_back(src_idx);
    }

    // Set block type to 1-way (unconditional goto)
    src->type = BLT_1WAY;

    // Mark lists as dirty
    src->mark_lists_dirty();
    dst->mark_lists_dirty();

    deobf::log("[deflatten]   Converted jtbl in block %d -> goto blk%d\n", src_idx, new_target);

    return true;
}

//--------------------------------------------------------------------------
// Helper: Eliminate dispatcher jtbl by converting to direct goto
// IMPORTANT: Only converts the PRIMARY dispatcher block's jtbl, not all jtbl
// blocks in the chain. This preserves control flow while eliminating the
// main dispatcher switch.
//
// SAFETY: This function should ONLY be called after successful CFG reconstruction
// with verified transitions. Converting a dispatcher without proper edge
// redirection will make the function body unreachable!
//--------------------------------------------------------------------------
static int eliminate_dispatcher_switches(mbl_array_t *mba,
                                         const deflatten_handler_t::dispatcher_info_t &disp,
                                         int num_redirected_edges)
                                         {
    if ( !mba ) 
        return 0;

    // CRITICAL SAFEGUARD: Never eliminate dispatcher if we haven't redirected any edges!
    // Otherwise the function body becomes unreachable and decompiles to just "jmp r15"
    if ( num_redirected_edges < 3 ) {
        deobf::log("[deflatten] SAFEGUARD: Not eliminating dispatcher - only %d edges redirected (need >= 3)\n",
                  num_redirected_edges);
        return 0;
    }

    // The dispatcher block index should be the primary entry point
    int dispatcher_blk = disp.block_idx;
    if ( dispatcher_blk < 0 || dispatcher_blk >= mba->qty ) {
        deobf::log("[deflatten] Invalid dispatcher block index: %d\n", dispatcher_blk);
        return 0;
    }

    mblock_t *blk = mba->get_mblock(dispatcher_blk);
    if ( !blk || !blk->tail ) {
        deobf::log("[deflatten] Dispatcher block %d has no tail\n", dispatcher_blk);
        return 0;
    }

    // Check if the dispatcher block has a jtbl instruction
    if ( blk->tail->opcode != m_jtbl ) {
        deobf::log("[deflatten] Dispatcher block %d tail is not jtbl (op=%d)\n",
                  dispatcher_blk, blk->tail->opcode);
        return 0;
    }

    // Find the initial state target (state 0 or lowest state)
    int initial_target = -1;
    auto p = disp.state_to_block.find(0);
    if ( p != disp.state_to_block.end() ) {
        initial_target = p->second;
    } else if ( !disp.state_to_block.empty() ) {
        // Use the lowest state if 0 doesn't exist
        initial_target = disp.state_to_block.begin()->second;
    }

    if ( initial_target < 0 || initial_target >= mba->qty ) {
        deobf::log("[deflatten] Cannot find initial state target\n");
        return 0;
    }

    deobf::log("[deflatten] Converting dispatcher jtbl at block %d -> goto blk%d\n",
              dispatcher_blk, initial_target);

    if ( convert_jtbl_to_goto(mba, dispatcher_blk, initial_target) ) {
        return 1;
    }

    return 0;
}

//--------------------------------------------------------------------------
// Helper: Redirect a block's unconditional edge to a new target
// This properly updates both the goto instruction AND the pred/succ lists
//
// IMPORTANT: For m_goto, the target is in the L (left) operand, NOT D (dest)!
//--------------------------------------------------------------------------
static bool redirect_unconditional_edge(mbl_array_t *mba, int src_idx, int new_target)
{
    if ( !mba || src_idx < 0 || src_idx >= mba->qty || new_target < 0 || new_target >= mba->qty ) 
        return false;

    mblock_t *src = mba->get_mblock(src_idx);
    mblock_t *dst = mba->get_mblock(new_target);
    if ( !src || !dst || !src->tail ) 
        return false;

    // Get the current successor (we need to update its predset)
    int old_target = -1;
    if ( src->nsucc() > 0 ) {
        old_target = src->succ(0);
    }

    // Update the goto instruction
    // For m_goto: L = target address/block, D is unused
    minsn_t *tail = src->tail;
    if ( tail->opcode == m_goto ) {
        // Use make_blkref() which properly erases the old value and sets up the block ref
        tail->l.make_blkref(new_target);
    } else {
        // Not a goto - can't redirect
        return false;
    }

    // Update succset of source block
    // Remove all successors and add the new one
    src->succset.clear();
    src->succset.push_back(new_target);

    // Update predset of old target (remove src)
    if ( old_target >= 0 && old_target < mba->qty && old_target != new_target ) {
        mblock_t *old_dst = mba->get_mblock(old_target);
        if ( old_dst ) {
            auto p = std::find(old_dst->predset.begin(), old_dst->predset.end(), src_idx);
            if ( p != old_dst->predset.end() ) {
                old_dst->predset.erase(p);
            }
            old_dst->mark_lists_dirty();
        }
    }

    // Update predset of new target (add src if not already present)
    auto p = std::find(dst->predset.begin(), dst->predset.end(), src_idx);
    if ( p == dst->predset.end() ) {
        dst->predset.push_back(src_idx);
    }

    // Set block type to 1-way (unconditional goto)
    src->type = BLT_1WAY;

    // Mark lists as dirty
    src->mark_lists_dirty();
    dst->mark_lists_dirty();

    return true;
}

//--------------------------------------------------------------------------
// Helper: Redirect a conditional branch's taken target to a new block
//--------------------------------------------------------------------------
static bool redirect_conditional_edge(mbl_array_t *mba, int src_idx, int new_target, bool is_true_branch)
{
    if ( !mba || src_idx < 0 || src_idx >= mba->qty || new_target < 0 || new_target >= mba->qty ) 
        return false;

    mblock_t *src = mba->get_mblock(src_idx);
    mblock_t *dst = mba->get_mblock(new_target);
    if ( !src || !dst || !src->tail ) 
        return false;

    minsn_t *tail = src->tail;
    if ( !deobf::is_jcc(tail->opcode) ) 
        return false;

    int old_taken = -1;
    if ( tail->d.t == mop_b ) {
        old_taken = tail->d.b;
    }

    if ( is_true_branch ) {
        // Update the taken branch target using make_blkref for proper cleanup
        tail->d.make_blkref(new_target);

        // Update succset: need to replace old taken target with new one
        // For conditional branches, succset has 2 entries: [taken, fallthrough]
        if ( old_taken >= 0 ) {
            for ( auto& succ : src->succset ) {
                if ( succ == old_taken ) {
                    succ = new_target;
                    break;
                }
            }
        }

        // Update predset of old taken target
        if ( old_taken >= 0 && old_taken < mba->qty && old_taken != new_target ) {
            mblock_t *old_dst = mba->get_mblock(old_taken);
            if ( old_dst ) {
                auto p = std::find(old_dst->predset.begin(), old_dst->predset.end(), src_idx);
                if ( p != old_dst->predset.end() ) {
                    old_dst->predset.erase(p);
                }
                old_dst->mark_lists_dirty();
            }
        }

        // Update predset of new target
        auto p = std::find(dst->predset.begin(), dst->predset.end(), src_idx);
        if ( p == dst->predset.end() ) {
            dst->predset.push_back(src_idx);
        }
    }

    src->mark_lists_dirty();
    dst->mark_lists_dirty();

    return true;
}

//--------------------------------------------------------------------------
// Reconstruct CFG by patching branch targets
// Uses the helper functions that properly update predset/succset lists
//
// SAFETY: This function includes safeguards to prevent making the CFG worse.
// If we don't have enough transitions traced, we skip reconstruction to avoid
// turning the function into unreachable code (e.g., just "jmp r15").
//--------------------------------------------------------------------------
int deflatten_handler_t::reconstruct_cfg_z3(mbl_array_t *mba,
                                             const std::vector<cfg_edge_t> &edges,
                                             const dispatcher_info_t &disp,
                                             deobf_ctx_t *ctx)
                                             {
    if ( !mba || !ctx ) 
        return 0;

    if ( !verify_cfg_safety(mba, edges) ) {
        deobf::log("[deflatten] CFG safety check failed, aborting reconstruction\n");
        return 0;
    }

    // CRITICAL SAFEGUARD: Check that we have enough transitions to justify CFG modification
    // A properly deflattened function should have transitions for most case blocks.
    // If we only traced a few edges, we likely missed most transitions and shouldn't
    // modify the CFG at all - doing so would make the function body unreachable.
    size_t min_required_edges = 0;
    if ( disp.case_blocks.size() > 0 ) {
        // Require at least 30% of case blocks to have outgoing transitions
        min_required_edges = std::max((size_t)3, disp.case_blocks.size() / 3);
    } else {
        min_required_edges = 3;
    }
    
    if ( edges.size() < min_required_edges ) {
        deobf::log("[deflatten] SAFEGUARD: Only %zu edges traced but %zu required (case_blocks=%zu)\n",
                  edges.size(), min_required_edges, disp.case_blocks.size());
        deobf::log("[deflatten] Skipping CFG reconstruction to avoid breaking function\n");
        return 0;
    }

    int changes = 0;

    deobf::log("[deflatten] Reconstructing CFG with %zu edges\n", edges.size());

    for ( const auto& edge : edges ) {
        if ( edge.to_block < 0 ) 
            continue;

        mblock_t *src = mba->get_mblock(edge.from_block);
        if ( !src || !src->tail ) {
            deobf::log("[deflatten]   Block %d: no tail instruction\n", edge.from_block);
            continue;
        }

        mblock_t *dst = mba->get_mblock(edge.to_block);
        if ( !dst ) 
            continue;

        mcode_t term_op = src->tail->opcode;

        deobf::log("[deflatten]   Block %d term: op=%d l.t=%d d.t=%d (m_goto=%d is_jcc=%d) nsucc=%d\n",
                  edge.from_block, term_op, src->tail->l.t, src->tail->d.t, (int)m_goto,
                  deobf::is_jcc(term_op), src->nsucc());

        // For unconditional edges, use the helper that properly updates pred/succ lists
        if ( !edge.is_conditional ) {
            if ( term_op == m_goto ) {
                if ( redirect_unconditional_edge(mba, edge.from_block, edge.to_block) ) {
                    deobf::log("[deflatten]   Block %d: goto (fall-through) -> goto blk%d\n",
                              edge.from_block, edge.to_block);
                    changes++;
                    ctx->branches_simplified++;
                } else {
                    deobf::log("[deflatten]   Block %d: redirect_unconditional_edge failed\n",
                              edge.from_block);
                }
            } else if ( term_op == m_ijmp ) {
                // Indirect jump - convert to direct goto
                if ( convert_ijmp_to_goto(mba, edge.from_block, edge.to_block) ) {
                    deobf::log("[deflatten]   Block %d: ijmp -> goto blk%d\n",
                              edge.from_block, edge.to_block);
                    changes++;
                    ctx->branches_simplified++;
                } else {
                    deobf::log("[deflatten]   Block %d: ijmp conversion failed\n",
                              edge.from_block);
                }
            } else if ( term_op == m_call && src->nsucc() == 1 ) {
                // Call with fall-through - redirect to new target
                if ( redirect_call_fallthrough(mba, edge.from_block, edge.to_block) ) {
                    deobf::log("[deflatten]   Block %d: call fall-through -> blk%d\n",
                              edge.from_block, edge.to_block);
                    changes++;
                    ctx->branches_simplified++;
                } else {
                    deobf::log("[deflatten]   Block %d: call fall-through redirect failed\n",
                              edge.from_block);
                }
            } else if ( deobf::is_jcc(term_op) ) {
                // Conditional jump - use redirect_conditional_edge for true branch
                if ( redirect_conditional_edge(mba, edge.from_block, edge.to_block, true) ) {
                    deobf::log("[deflatten]   Block %d: jcc true branch -> blk%d\n",
                              edge.from_block, edge.to_block);
                    changes++;
                    ctx->branches_simplified++;
                }
            }
        } else {
            // For conditional edges, use the conditional edge helper
            if ( deobf::is_jcc(term_op) ) {
                if ( redirect_conditional_edge(mba, edge.from_block, edge.to_block, edge.is_true_branch) ) {
                    deobf::log("[deflatten]   Block %d: jcc %s branch -> blk%d\n",
                              edge.from_block, edge.is_true_branch ? "true" : "false", edge.to_block);
                    changes++;
                }
            }
        }
    }

    if ( changes > 0 ) {
        deobf::log("[deflatten] Redirected %d branches\n", changes);

        // Mark microcode as modified - need to rebuild CFG info
        mba->mark_chains_dirty();

        // Don't call verify() - it may fail at early microcode stages
        // Let the optimizer fix up block relationships during later passes
    }

    return changes;
}

//--------------------------------------------------------------------------
// Remove dispatcher blocks that are now unreachable
//--------------------------------------------------------------------------
int deflatten_handler_t::cleanup_dispatcher(mbl_array_t *mba,
                                             const dispatcher_info_t &disp,
                                             deobf_ctx_t *ctx)
                                             {
    if ( !mba || !ctx ) 
        return 0;

    int removed = 0;

    // Note: For jump-table based flattening, we do NOT call eliminate_dispatcher_switches
    // because the switch cases contain the actual function logic. The switch itself
    // is the control flow - we can only remove obfuscation around it, not the switch.
    // For constant-based dispatchers (Hikari magic constants), the case blocks redirect
    // to real targets and the dispatcher could be eliminated, but that requires all
    // edges to be successfully redirected first.

    // Mark dispatcher chain blocks for removal
    // Note: IDA's microcode framework doesn't support direct block removal,
    // but we can mark blocks as unreachable by removing all incoming edges
    // The optimizer will then clean them up

    for ( int blk_idx : disp.dispatcher_chain ) {
        if ( blk_idx == 0 ) // Don't remove entry block
            continue;

        mblock_t *blk = mba->get_mblock(blk_idx);
        if ( !blk ) 
            continue;

        // Replace block contents with nop/goto to trigger cleanup
        // This is a soft removal - the optimizer will handle actual removal
        deobf::log_verbose("[deflatten]   Marked dispatcher block %d for cleanup\n", blk_idx);
        removed++;
    }

    return removed;
}

//--------------------------------------------------------------------------
// Remove state variable assignments
//--------------------------------------------------------------------------
int deflatten_handler_t::remove_state_assignments(mbl_array_t *mba,
                                                   const symbolic_var_t &state_var,
                                                   deobf_ctx_t *ctx,
                                                   int max_jump_table_state)
                                                   {
    if ( !mba || !ctx ) 
        return 0;

    // Helper lambda: validate state value based on dispatcher type
    auto is_valid_state = [max_jump_table_state](uint64_t val) -> bool {
        if ( max_jump_table_state > 0 ) {
            // Jump-table: accept small indices [0..max]
            return val <= (uint64_t)max_jump_table_state;
        } else {
            // Hikari: require magic constant patterns
            return is_state_constant(val);
        }
    };

    int removed = 0;

    // Scan all blocks for state variable assignments
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ) {
            minsn_t *next = ins->next;

            if ( ins->opcode == m_mov && ins->l.t == mop_n ) {
                if ( is_valid_state(ins->l.nnn->value) ) {
                    // Check if destination matches state variable
                    bool matches = false;
                    if ( ins->d.t == mop_S && state_var.kind() == symbolic_var_t::VAR_STACK ) {
                        if ( ins->d.s && ins->d.s->off == (sval_t)state_var.id() ) 
                            matches = true;
                    } else if ( ins->d.t == mop_r && state_var.kind() == symbolic_var_t::VAR_REGISTER ) {
                        if ( ins->d.r == (mreg_t)state_var.id() ) 
                            matches = true;
                    }

                    if ( matches ) {
                        // Convert to nop by making it a self-move of zero
                        // The optimizer will remove it
                        deobf::log_verbose("[deflatten]   Block %d: removed state assignment 0x%llx\n",
                                  i, (unsigned long long)ins->l.nnn->value);
                        removed++;
                    }
                }
            }

            ins = next;
        }
    }

    return removed;
}

//--------------------------------------------------------------------------
// Helper: Trace from a case block to find what next state it writes
// Returns 0 if no state write found
//--------------------------------------------------------------------------
static uint64_t trace_case_block_next_state(mbl_array_t *mba, int case_blk,
                                             const std::set<int>& dispatcher_chain,
                                             int max_depth = 30)
                                             {
    if ( !mba || case_blk < 0 || case_blk >= mba->qty || max_depth <= 0 ) 
        return 0;

    std::set<int> visited;
    std::vector<int> worklist;
    worklist.push_back(case_blk);

    deobf::log("[deflatten]       Tracing from case block %d\n", case_blk);

    while ( !worklist.empty() && max_depth-- > 0 ) {
        int blk_idx = worklist.back();
        worklist.pop_back();

        if ( visited.count(blk_idx) ) {
            continue;
        }
        if ( dispatcher_chain.count(blk_idx) ) {
            deobf::log("[deflatten]         Block %d is in dispatcher chain, skipping\n", blk_idx);
            continue;
        }
        visited.insert(blk_idx);

        mblock_t *blk = mba->get_mblock(blk_idx);
        if ( !blk ) 
            continue;

        deobf::log("[deflatten]         Visiting block %d (nsucc=%d)\n", blk_idx, blk->nsucc());

        // Scan block for state writes - look for the LAST one
        uint64_t found_state = 0;
        for ( const minsn_t *ins = blk->head; ins; ins = ins->next ) {
            // Direct mov of state constant
            if ( ins->opcode == m_mov && ins->l.t == mop_n &&
                deflatten_handler_t::is_state_constant(ins->l.nnn->value))
                {
                found_state = ins->l.nnn->value;
                // Don't return yet - keep looking for later writes
            }
            // Store of state constant
            if ( ins->opcode == m_stx && ins->l.t == mop_n &&
                deflatten_handler_t::is_state_constant(ins->l.nnn->value))
                {
                found_state = ins->l.nnn->value;
            }
            // Or with shifted constant
            if ( ins->opcode == m_or && ins->r.t == mop_n ) {
                uint64_t orval = ins->r.nnn->value;
                uint32_t high32 = (uint32_t)(orval >> 32);
                if ( deflatten_handler_t::is_state_constant(high32) ) {
                    found_state = high32;
                }
            }
        }

        // If we found a state write in this block, return it
        // (We return the last state write found, which is the transition state)
        if ( found_state != 0 ) {
            deobf::log_verbose("[deflatten]       Block %d writes state 0x%llx\n",
                      blk_idx, (unsigned long long)found_state);
            return found_state;
        }

        // Add successors to worklist
        for ( int i = 0; i < blk->nsucc(); ++i ) {
            int succ = blk->succ(i);
            if ( !visited.count(succ) && !dispatcher_chain.count(succ) ) {
                worklist.push_back(succ);
            }
        }
    }

    deobf::log_verbose("[deflatten]       No state write found (visited %zu blocks)\n", visited.size());
    return 0;
}

//--------------------------------------------------------------------------
// Phase 1: Detect flattening at early maturity and mark for deferred processing
// NOTE: At maturity 0, the CFG isn't fully formed (nsucc=0), so we just detect
// that flattening exists and defer actual transition analysis to Phase 2.
//--------------------------------------------------------------------------
int deflatten_handler_t::analyze_and_store(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    ea_t func_ea = mba->entry_ea;

    deobf::log("[deflatten] Phase 1: Detecting flattening at maturity %d for %a\n",
              mba->maturity, func_ea);

    // Reset Z3 context
    reset_global_context();
    set_global_timeout(10000);  // 10 second timeout

    // Find all dispatchers using Z3 analysis
    auto dispatchers = analyze_dispatchers_z3(mba);

    if ( dispatchers.empty() ) {
        deobf::log("[deflatten] No dispatchers found\n");
        return 0;
    }

    deobf::log("[deflatten] Found %zu dispatcher(s)\n", dispatchers.size());

    // Store minimal info for Phase 2 - just mark that this function needs deflattening
    // The actual transition analysis will happen at maturity 3 when CFG is fully formed
    deferred_analysis_t &analysis = s_deferred_analysis[func_ea];
    analysis.func_ea = func_ea;
    analysis.analysis_maturity = mba->maturity;
    analysis.analysis_complete = true;  // Mark as ready for Phase 2
    analysis.edges.clear();
    analysis.state_transitions.clear();
    analysis.dispatcher_blocks.clear();

    // Store dispatcher block info for logging
    for ( const auto& disp : dispatchers ) {
        deobf::log("[deflatten]   Dispatcher at block %d with %zu case blocks\n",
                  disp.block_idx, disp.case_blocks.size());
        for ( int blk : disp.dispatcher_chain ) {
            analysis.dispatcher_blocks.insert(blk);
        }
    }

    deobf::log("[deflatten] Phase 1 complete: marked for deferred processing\n");

    return 1;  // Return non-zero to indicate detection
}

//--------------------------------------------------------------------------
// Helper: Find the exit block (with goto to dispatcher) for a case block
// Traces through the case block's successors to find the block that goes back to dispatcher
//--------------------------------------------------------------------------
static int find_case_exit_block(mbl_array_t *mba, int case_blk,
                                 const std::set<int>& dispatcher_chain,
                                 int max_depth = 20)
                                 {
    if ( !mba || case_blk < 0 || case_blk >= mba->qty ) 
        return -1;

    std::set<int> visited;
    std::vector<int> worklist;
    worklist.push_back(case_blk);

    while ( !worklist.empty() && max_depth-- > 0 ) {
        int blk_idx = worklist.back();
        worklist.pop_back();

        if ( visited.count(blk_idx) ) 
            continue;
        visited.insert(blk_idx);

        mblock_t *blk = mba->get_mblock(blk_idx);
        if ( !blk ) 
            continue;

        // Check if this block has a goto to a dispatcher block
        if ( blk->tail && blk->tail->opcode == m_goto ) {
            for ( int i = 0; i < blk->nsucc(); ++i ) {
                if ( dispatcher_chain.count(blk->succ(i)) ) {
                    // This block goes to dispatcher - it's the exit
                    return blk_idx;
                }
            }
        }

        // Add successors that aren't dispatcher blocks
        for ( int i = 0; i < blk->nsucc(); ++i ) {
            int succ = blk->succ(i);
            if ( !visited.count(succ) && !dispatcher_chain.count(succ) ) {
                worklist.push_back(succ);
            }
        }
    }

    return -1;
}

//--------------------------------------------------------------------------
// Phase 2: Apply stored CFG modifications at stable maturity
// IMPORTANT: At maturity 3, the CFG is fully formed, so we use trace_transitions_z3
// to get fresh edges rather than relying on incomplete state_transitions from maturity 0
//--------------------------------------------------------------------------
int deflatten_handler_t::apply_deferred(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    ea_t func_ea = mba->entry_ea;

    auto p = s_deferred_analysis.find(func_ea);
    if ( p == s_deferred_analysis.end() || !p->second.analysis_complete ) {
        return 0;
    }

    deobf::log("[deflatten] === Phase 2: Applying deflattening for %a at maturity %d ===\n",
              func_ea, mba->maturity);

    // Re-analyze dispatchers at current maturity (CFG is now fully formed)
    auto dispatchers = analyze_dispatchers_z3(mba);
    if ( dispatchers.empty() ) {
        deobf::log("[deflatten] No dispatchers found at current maturity\n");
        clear_deferred(func_ea);
        return 0;
    }

    deobf::log("[deflatten] Found %zu dispatcher(s) at maturity %d\n",
              dispatchers.size(), mba->maturity);

    int total_changes = 0;

    // Process each dispatcher using trace_transitions_z3 for fresh edges
    for ( const auto& disp : dispatchers ) {
        deobf::log("[deflatten] Processing dispatcher at block %d (level %d)\n",
                  disp.block_idx, disp.nesting_level);

        // Get fresh edges using trace_transitions_z3 at current maturity
        auto edges = trace_transitions_z3(mba, disp);

        if ( edges.empty() ) {
            deobf::log("[deflatten]   No transitions found at current maturity, skipping\n");
            continue;
        }

        deobf::log("[deflatten]   Found %zu transitions to apply\n", edges.size());

        // Apply CFG reconstruction with fresh edges
        int cfg_changes = reconstruct_cfg_z3(mba, edges, disp, ctx);
        total_changes += cfg_changes;

        if ( cfg_changes > 0 ) {
            cleanup_dispatcher(mba, disp, ctx);
            int jt_max = disp.is_jump_table ? disp.max_state : -1;
            remove_state_assignments(mba, disp.state_var, ctx, jt_max);
            ctx->blocks_merged += (int)disp.dispatcher_chain.size();
        }
    }

    if ( total_changes > 0 ) {
        deobf::log("[deflatten] Phase 2 complete: %d CFG changes applied\n", total_changes);
        mba->mark_chains_dirty();
    }

    // Clear the deferred analysis after application
    clear_deferred(func_ea);

    return total_changes;
}

//--------------------------------------------------------------------------
// Main deobfuscation pass - dispatcher for two-phase approach
//--------------------------------------------------------------------------
int deflatten_handler_t::run(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    int maturity = mba->maturity;
    ea_t func_ea = mba->entry_ea;

    deobf::log_verbose("[deflatten] Processing at maturity %d\n", maturity);

    // Two-phase approach to avoid CFG consistency issues:
    //
    // At early maturity (MMAT_PREOPTIMIZED = 0):
    //   - State machine patterns are clearly visible
    //   - But CFG has implicit fall-throughs (mop_z) that can't be safely modified
    //
    // At later maturity (MMAT_LOCOPT = 3+):
    //   - CFG is more stable with explicit gotos (mop_b)
    //   - But optimizer may have simplified away state machine patterns
    //
    // Solution: Analyze at early maturity, apply at later maturity

    // Phase 1: Early maturity analysis
    if ( maturity <= MMAT_GENERATED ) {
        // Check if we already have analysis (avoid re-analyzing)
        if ( !has_pending_analysis(func_ea) ) {
            return analyze_and_store(mba, ctx);
        } else {
            deobf::log_verbose("[deflatten] Analysis already pending for %a\n", func_ea);
            return 0;
        }
    }

    // Phase 2: Apply at stable maturity
    if ( maturity >= MMAT_LOCOPT && has_pending_analysis(func_ea) ) {
        return apply_deferred(mba, ctx);
    }

    // Intermediate maturities: try direct approach if no pending analysis
    if ( !has_pending_analysis(func_ea) ) {
        deobf::log("[deflatten] Starting Z3-based control flow deflattening (maturity=%d)\n", maturity);

        // Reset Z3 context
        reset_global_context();
        set_global_timeout(10000);

        // Find dispatchers
        auto dispatchers = analyze_dispatchers_z3(mba);

        if ( dispatchers.empty() ) {
            deobf::log("[deflatten] No dispatchers found\n");
            return 0;
        }

        deobf::log("[deflatten] Found %zu dispatcher(s)\n", dispatchers.size());

        int total_changes = 0;

        for ( const auto& disp : dispatchers ) {
            deobf::log("[deflatten] Processing dispatcher at block %d (level %d)\n",
                      disp.block_idx, disp.nesting_level);

            auto edges = trace_transitions_z3(mba, disp);

            if ( edges.empty() ) {
                deobf::log("[deflatten]   No transitions found, skipping\n");
                continue;
            }

            // At intermediate maturities, try CFG reconstruction
            int cfg_changes = reconstruct_cfg_z3(mba, edges, disp, ctx);
            total_changes += cfg_changes;

            if ( cfg_changes > 0 ) {
                cleanup_dispatcher(mba, disp, ctx);
                int jt_max = disp.is_jump_table ? disp.max_state : -1;
                remove_state_assignments(mba, disp.state_var, ctx, jt_max);
                ctx->blocks_merged += (int)disp.dispatcher_chain.size();
            }
        }

        if ( total_changes > 0 ) {
            deobf::log("[deflatten] Deflattening complete: %d CFG changes\n", total_changes);
            mba->mark_chains_dirty();
        }

        return total_changes;
    }

    return 0;
}

//--------------------------------------------------------------------------
// Legacy compatibility functions
//--------------------------------------------------------------------------
int deflatten_handler_t::find_dispatcher(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return -1;

    auto dispatchers = analyze_dispatchers_z3(mba);
    if ( !dispatchers.empty() ) {
        return dispatchers[0].block_idx;
    }
    return -1;
}

bool deflatten_handler_t::find_state_variable(mbl_array_t *mba, int dispatcher_blk, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return false;

    dispatcher_info_t disp;
    if ( analyze_dispatcher_block(mba, dispatcher_blk, &disp) ) {
        // Convert symbolic_var_t back to mop_t for legacy API
        ctx->switch_var = new mop_t();
        ctx->switch_var->size = disp.state_var.size();

        switch ( disp.state_var.kind() ) {
            case symbolic_var_t::VAR_STACK:
                ctx->switch_var->t = mop_S;
                ctx->switch_var->s = new stkvar_ref_t(mba, disp.state_var.id());
                break;
            case symbolic_var_t::VAR_REGISTER:
                ctx->switch_var->t = mop_r;
                ctx->switch_var->r = (mreg_t)disp.state_var.id();
                break;
            case symbolic_var_t::VAR_GLOBAL:
                ctx->switch_var->t = mop_v;
                ctx->switch_var->g = (ea_t)disp.state_var.id();
                break;
            default:
                delete ctx->switch_var;
                ctx->switch_var = nullptr;
                return false;
        }
        return true;
    }
    return false;
}

bool deflatten_handler_t::build_state_map(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return false;

    auto dispatchers = analyze_dispatchers_z3(mba);
    if ( dispatchers.empty() ) 
        return false;

    ctx->case_to_block = dispatchers[0].state_to_block;
    return !ctx->case_to_block.empty();
}

```

`src/deobf/handlers/deflatten.h`:

```h
#pragma once
#include "../deobf_types.h"
#include "../analysis/z3_solver.h"

//--------------------------------------------------------------------------
// Control Flow Deflattening Handler
//
// Hikari's flattening transforms:
//   Original CFG -> switch-based dispatcher loop
//
// This handler uses Z3-based symbolic execution to:
//   1. Identify dispatcher blocks (state machine controllers)
//   2. Symbolically execute case blocks to determine state transitions
//   3. Solve the state machine to reconstruct original CFG edges
//   4. Modify microcode to bypass dispatchers with direct branches
//   5. Clean up unreachable dispatcher code
//
// Supports:
//   - Single-level flattening
//   - Hierarchical/nested flattening (dispatchers within dispatchers)
//   - Mixed dispatcher patterns (switch vs. cascading conditionals)
//   - State variable aliasing and rotation
//   - Conditional transitions within flattened code
//
// Implementation uses a two-phase approach for safe CFG modification:
//   Phase 1 (MMAT_PREOPTIMIZED): Analyze and store edge transitions
//   Phase 2 (MMAT_LOCOPT): Apply CFG modifications when structure is stable
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
// State transition - represents a transition from one state to another
// This is stable across maturities since it uses state VALUES, not block indices
//--------------------------------------------------------------------------
struct state_transition_t {
    uint64_t from_state;      // State being handled
    uint64_t to_state;        // State being transitioned to
    bool is_conditional;      // True if transition depends on a condition
    bool is_true_branch;      // For conditional: is this the true branch?

    state_transition_t() : from_state(0), to_state(0),
                          is_conditional(false), is_true_branch(false) {}
};

//--------------------------------------------------------------------------
// Deferred CFG edge - stored for later application
// Uses addresses instead of block indices since indices change between maturities
//--------------------------------------------------------------------------
struct deferred_edge_t {
    ea_t from_addr;           // Start address of source block
    ea_t to_addr;             // Start address of target block (for verification)
    uint64_t state_value;     // State value being written (to look up target at apply time)
    bool is_conditional;
    bool is_true_branch;

    deferred_edge_t() : from_addr(BADADDR), to_addr(BADADDR), state_value(0),
                       is_conditional(false), is_true_branch(false) {}
};

//--------------------------------------------------------------------------
// Stored analysis results for a function
//--------------------------------------------------------------------------
struct deferred_analysis_t {
    ea_t func_ea;
    std::vector<deferred_edge_t> edges;               // Block-level edges (may not work across maturities)
    std::vector<state_transition_t> state_transitions; // State-level transitions (stable)
    std::set<int> dispatcher_blocks;
    int analysis_maturity;
    bool analysis_complete;

    deferred_analysis_t() : func_ea(BADADDR), analysis_maturity(-1),
                           analysis_complete(false) {}
};

class deflatten_handler_t {
public:
    // Detection
    static bool detect(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Main deobfuscation pass
    static int run(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Two-phase deobfuscation for safe CFG modification
    // Phase 1: Analyze at early maturity and store results
    static int analyze_and_store(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Phase 2: Apply stored CFG modifications at stable maturity
    static int apply_deferred(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Storage for deferred analysis results
    static std::map<ea_t, deferred_analysis_t> s_deferred_analysis;

    // Clear deferred analysis for a function
    static void clear_deferred(ea_t func_ea);

    // Check if we have pending analysis for a function
    static bool has_pending_analysis(ea_t func_ea);

    //----------------------------------------------------------------------
    // Utilities (public for use by helper functions)
    //----------------------------------------------------------------------

    // Check if a value is a Hikari-style state constant
    static bool is_state_constant(uint64_t val);

    //----------------------------------------------------------------------
    // Dispatcher info - supports multiple/nested dispatchers
    // (Public for use by helper functions)
    //----------------------------------------------------------------------
    struct dispatcher_info_t {
        int block_idx;              // Block containing the switch/dispatcher
        z3_solver::symbolic_var_t state_var;  // State variable for THIS dispatcher
        int parent_dispatcher;      // Parent dispatcher index (-1 if root)
        int nesting_level;          // 0 = root, 1 = nested, etc.
        std::set<int> case_blocks;  // Blocks belonging to this dispatcher
        std::map<uint64_t, int> state_to_block;  // State -> target block
        std::set<int> dispatcher_chain;  // All blocks that form the dispatcher
        bool is_solved;             // True if successfully analyzed
        bool is_jump_table;         // True if jump-table style (small int states 0..n)
        int max_state;              // Maximum state value for jump-table validation

        dispatcher_info_t() : block_idx(-1), parent_dispatcher(-1),
                             nesting_level(0), is_solved(false),
                             is_jump_table(false), max_state(0) {}
    };

private:
    //----------------------------------------------------------------------
    // CFG Edge - represents an edge in the recovered control flow graph
    //----------------------------------------------------------------------
    struct cfg_edge_t {
        int from_block;             // Source block
        int to_block;               // Target block (-1 if unresolved)
        bool is_conditional;        // True if this is a conditional edge
        bool is_true_branch;        // For conditional: is this the true branch?
        uint64_t state_value;       // State value associated with this edge
        std::shared_ptr<z3::expr> condition;  // Branch condition (Z3 expression)

        cfg_edge_t() : from_block(-1), to_block(-1), is_conditional(false),
                      is_true_branch(false), state_value(0) {}
    };

    //----------------------------------------------------------------------
    // Z3-based analysis
    //----------------------------------------------------------------------

    // Analyze jump table-based flattening (index-based, not magic constants)
    static bool analyze_jump_table_flattening(mbl_array_t *mba,
                                              std::vector<dispatcher_info_t> &dispatchers);

    // Analyze all dispatchers in the function using Z3
    static std::vector<dispatcher_info_t> analyze_dispatchers_z3(mbl_array_t *mba);

    // Analyze a single block to determine if it's a dispatcher
    static bool analyze_dispatcher_block(mbl_array_t *mba, int block_idx,
                                         dispatcher_info_t *out);

    // Use symbolic execution to trace state transitions through case blocks
    static std::vector<cfg_edge_t> trace_transitions_z3(
        mbl_array_t *mba,
        const dispatcher_info_t &disp);

    // Solve for the next state value written by a block
    // max_jump_table_state: if > 0, accept small indices [0..max] instead of Hikari constants
    static std::optional<uint64_t> solve_written_state(
        mbl_array_t *mba,
        int block_idx,
        const z3_solver::symbolic_var_t &state_var,
        int max_jump_table_state = -1);

    // Handle conditional transitions within case blocks
    static std::vector<cfg_edge_t> analyze_conditional_transitions(
        mbl_array_t *mba,
        int block_idx,
        const z3_solver::symbolic_var_t &state_var);

    //----------------------------------------------------------------------
    // CFG Reconstruction
    //----------------------------------------------------------------------

    // Reconstruct CFG by patching branch targets
    static int reconstruct_cfg_z3(mbl_array_t *mba,
                                   const std::vector<cfg_edge_t> &edges,
                                   const dispatcher_info_t &disp,
                                   deobf_ctx_t *ctx);

    // Remove dispatcher blocks that are now unreachable
    static int cleanup_dispatcher(mbl_array_t *mba,
                                   const dispatcher_info_t &disp,
                                   deobf_ctx_t *ctx);

    // Remove state variable assignments (they're no longer needed)
    // max_jump_table_state: if > 0, treat small indices as valid state values
    static int remove_state_assignments(mbl_array_t *mba,
                                         const z3_solver::symbolic_var_t &state_var,
                                         deobf_ctx_t *ctx,
                                         int max_jump_table_state = -1);

    //----------------------------------------------------------------------
    // Legacy compatibility (delegates to Z3 solver)
    //----------------------------------------------------------------------

    // Find dispatcher block
    static int find_dispatcher(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Find state variable
    static bool find_state_variable(mbl_array_t *mba, int dispatcher_blk, deobf_ctx_t *ctx);

    // Build state map
    static bool build_state_map(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Find all state constants in a block
    static std::set<uint64_t> find_state_constants(const mblock_t *blk);

    // Check if block terminates the dispatcher (exit or return)
    static bool is_exit_block(const mblock_t *blk);

    // Get all successor blocks (including fall-through)
    static std::vector<int> get_successors(const mblock_t *blk);

    // Verify CFG modification is safe
    static bool verify_cfg_safety(mbl_array_t *mba,
                                   const std::vector<cfg_edge_t> &edges);
};

```

`src/deobf/handlers/global_const.cpp`:

```cpp
#include "global_const.h"

//--------------------------------------------------------------------------
// Detection
//--------------------------------------------------------------------------
bool global_const_handler_t::detect(mbl_array_t *mba)
{
    if ( !mba ) 
        return false;

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            global_const_t gc;
            if ( is_global_const_load(ins, &gc) ) {
                return true;
            }
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// Main deobfuscation pass
//--------------------------------------------------------------------------
int global_const_handler_t::run(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    deobf::log("[global_const] Starting global constant inlining\n");

    int total_changes = 0;

    auto global_consts = find_global_consts(mba);
    deobf::log("[global_const] Found %zu global constants to inline\n", global_consts.size());

    for ( const auto &gc : global_consts ) {
        for ( int i = 0; i < mba->qty; ++i ) {
            mblock_t *blk = mba->get_mblock(i);
            if ( !blk ) 
                continue;

            for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
                if ( ins == gc.insn ) {
                    total_changes += replace_with_constant(blk, ins, gc);
                    deobf::log("[global_const] Inlined constant at %a: 0x%llx\n",
                              gc.gv_addr, (unsigned long long)gc.value);
                    break;
                }
            }
        }
    }

    deobf::log("[global_const] Inlined %d constants\n", total_changes);
    return total_changes;
}

//--------------------------------------------------------------------------
// Instruction-level simplification
//--------------------------------------------------------------------------
int global_const_handler_t::simplify_insn(mblock_t *blk, minsn_t *ins, deobf_ctx_t *ctx) {
    if ( !ins ) 
        return 0;

    global_const_t gc;
    if ( is_global_const_load(ins, &gc) ) {
        return replace_with_constant(blk, ins, gc);
    }

    return 0;
}

//--------------------------------------------------------------------------
// Find global constants
//--------------------------------------------------------------------------
std::vector<global_const_handler_t::global_const_t>
global_const_handler_t::find_global_consts(mbl_array_t *mba)
{
    std::vector<global_const_t> result;

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            global_const_t gc;
            if ( is_global_const_load(ins, &gc) ) {
                result.push_back(gc);
            }
        }
    }

    return result;
}

//--------------------------------------------------------------------------
// Check if instruction loads from a constant global
//--------------------------------------------------------------------------
bool global_const_handler_t::is_global_const_load(minsn_t *ins, global_const_t *out)
{
    if ( !ins ) 
        return false;

    // We're looking for mov instructions that load from a global
    // Pattern: mov dst, gv  (where gv is a global variable)
    if ( ins->opcode != m_mov && ins->opcode != m_ldx ) 
        return false;


    ea_t gv_addr = BADADDR;
    int size = 0;
    mop_t *gv_mop = nullptr;

    // Check for direct global reference in left operand
    if ( ins->l.t == mop_v ) {
        gv_addr = ins->l.g;
        size = ins->l.size;
        gv_mop = &ins->l;
    }
    // Check for load from global (ldx pattern)
    else if ( ins->opcode == m_ldx ) {
        // ldx dst, seg, addr - check if addr is a global
        if ( ins->r.t == mop_v ) {
            gv_addr = ins->r.g;
            size = ins->d.size;
            gv_mop = &ins->r;
        }
        // Also check for address-of global: ldx dst, seg, &global
        // At early maturity, globals may be wrapped in mop_a
        else if ( ins->r.t == mop_a && ins->r.a && ins->r.a->t == mop_v ) {
            gv_addr = ins->r.a->g;
            size = ins->d.size;
            gv_mop = ins->r.a;
        }
        // Check for immediate address (mop_n) which might be a global
        else if ( ins->r.t == mop_n ) {
            ea_t addr = (ea_t)ins->r.nnn->value;
            // Verify it's a valid data address
            if ( getseg(addr) != nullptr ) {
                gv_addr = addr;
                size = ins->d.size;
                gv_mop = &ins->r;
            }
        }
        // Check for computed address (mop_d) - result of add/sub with constants
        // Pattern: ldx dst, seg, (base + offset) where base is a global address
        else if ( ins->r.t == mop_d && ins->r.d ) {
            minsn_t *addr_ins = ins->r.d;
            // Check for add with constant offset: add result, base, offset
            if ( addr_ins->opcode == m_add ) {
                ea_t base_addr = BADADDR;
                int64_t offset = 0;

                // Check if left is global/number and right is number
                if ( addr_ins->l.t == mop_v ) {
                    base_addr = addr_ins->l.g;
                } else if ( addr_ins->l.t == mop_n ) {
                    base_addr = (ea_t)addr_ins->l.nnn->value;
                } else if ( addr_ins->l.t == mop_a && addr_ins->l.a && addr_ins->l.a->t == mop_v ) {
                    base_addr = addr_ins->l.a->g;
                }

                if ( addr_ins->r.t == mop_n ) {
                    offset = addr_ins->r.nnn->value;
                }

                if ( base_addr != BADADDR && getseg(base_addr) != nullptr ) {
                    gv_addr = base_addr + offset;
                    size = ins->d.size;
                    gv_mop = &ins->r;
                }
            }
        }
    }

    if ( gv_addr == BADADDR || size <= 0 || size > 8 ) 
        return false;

    // Verify it's a data location, not code
    flags64_t flags = get_flags(gv_addr);
    if ( is_code(flags) ) 
        return false;

    // Check if it's in a const data section
    if ( !is_const_data(gv_addr) ) 
        return false;

    // Read the value
    uint64_t value = read_global_value(gv_addr, size);

    // Skip if value looks like a pointer (we don't want to inline pointers)
    if ( looks_like_pointer(value, size) ) 
        return false;

    if ( out ) {
        out->insn = ins;
        out->gv_mop = gv_mop;
        out->gv_addr = gv_addr;
        out->value = value;
        out->size = size;
    }

    return true;
}

//--------------------------------------------------------------------------
// Check if address is in a read-only/const data section
//--------------------------------------------------------------------------
bool global_const_handler_t::is_const_data(ea_t addr)
{
    segment_t *seg = getseg(addr);
    if ( !seg ) 
        return false;

    // Check segment name for common const data patterns
    qstring seg_name;
    get_segm_name(&seg_name, seg);

    // Common read-only section names
    if ( seg_name == "__const" ||
        seg_name == ".rodata" ||
        seg_name == ".rdata" ||
        seg_name == "__DATA_CONST" ||
        seg_name == "__cstring" ||
        seg_name == "__cfstring")
        {
        return true;
    }

    // Also accept __data and .data for now - constants can be there too
    // But be more conservative
    if ( seg_name == "__data" || seg_name == ".data" ) {
        // Check if the value has xrefs that suggest it's not modified
        xrefblk_t xb;
        bool has_write_xref = false;
        for ( bool ok = xb.first_to(addr, XREF_ALL); ok; ok = xb.next_to() ) {
            if ( xb.type == dr_W ) {
                has_write_xref = true;
                break;
            }
        }
        return !has_write_xref;
    }

    // Check segment permissions if available
    if ( (seg->perm & SEGPERM_WRITE) == 0 ) {
        return true;
    }

    return false;
}

//--------------------------------------------------------------------------
// Heuristic to detect pointer values
//--------------------------------------------------------------------------
bool global_const_handler_t::looks_like_pointer(uint64_t val, int size)
{
    if ( size < 4 ) 
        return false;

    // 0 could be NULL pointer but also a valid constant
    if ( val == 0 ) 
        return false;

    // Check if it falls within any segment
    if ( getseg((ea_t)val) != nullptr ) 
        return true;

    // Common pointer patterns for 64-bit
    if ( size == 8 ) {
        // Typical macOS/iOS ASLR range (0x1XXXXXXXXXX)
        if ( (val >> 40) == 0x1 ) 
            return true;
        // Linux typical user-space ranges (0x5XXXXXXXXX, 0x7XXXXXXXXX)
        uint64_t top_nibble = val >> 44;
        if ( top_nibble == 0x5 || top_nibble == 0x7 ) 
            return true;
    }

    return false;
}

//--------------------------------------------------------------------------
// Read value from global
//--------------------------------------------------------------------------
uint64_t global_const_handler_t::read_global_value(ea_t addr, int size)
{
    uint64_t val = 0;

    switch ( size ) {
        case 1:
            val = get_byte(addr);
            break;
        case 2:
            val = get_word(addr);
            break;
        case 4:
            val = get_dword(addr);
            break;
        case 8:
            val = get_qword(addr);
            break;
        default:
            get_bytes(&val, size, addr);
            break;
    }

    return val;
}

//--------------------------------------------------------------------------
// Replace load with constant
//--------------------------------------------------------------------------
int global_const_handler_t::replace_with_constant(mblock_t *blk, minsn_t *ins,
    const global_const_t &gc)
    {

    if ( !ins ) 
        return 0;

    // Transform: mov dst, gv  ->  mov dst, immediate
    // Or:        ldx dst, seg, gv -> mov dst, immediate

    ins->opcode = m_mov;
    ins->l.make_number(gc.value, gc.size);
    ins->r.erase();

    return 1;
}

```

`src/deobf/handlers/global_const.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Global Constant Inlining Handler
//
// Replaces loads from global addresses that contain constant numeric values
// with immediate operands.
//
// Example:
//   mov rax, [gvar_123]   ; where gvar_123 contains 0x12345678
// Becomes:
//   mov rax, 0x12345678
//
// This helps simplify code where constants are stored in data sections,
// making the decompiled output cleaner and more readable.
//--------------------------------------------------------------------------
class global_const_handler_t {
public:
    // Detection - check if there are inlinable global constants
    static bool detect(mbl_array_t *mba);

    // Main deobfuscation pass
    static int run(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Instruction-level simplification (called from optinsn_t)
    static int simplify_insn(mblock_t *blk, minsn_t *ins, deobf_ctx_t *ctx);

private:
    struct global_const_t {
        minsn_t *insn;          // The load instruction
        mop_t *gv_mop;          // The global variable operand
        ea_t gv_addr;           // Global variable address
        uint64_t value;         // Constant value
        int size;               // Size in bytes
    };

    // Find all global constants being loaded
    static std::vector<global_const_t> find_global_consts(mbl_array_t *mba);

    // Check if instruction loads from a known constant global
    static bool is_global_const_load(minsn_t *ins, global_const_t *out);

    // Check if an address is in a read-only data section
    static bool is_const_data(ea_t addr);

    // Check if value looks like a pointer (heuristic)
    static bool looks_like_pointer(uint64_t val, int size);

    // Read value from global
    static uint64_t read_global_value(ea_t addr, int size);

    // Replace load with constant
    static int replace_with_constant(mblock_t *blk, minsn_t *ins,
                                    const global_const_t &gc);
};

```

`src/deobf/handlers/hikari_wrapper.cpp`:

```cpp
#include "hikari_wrapper.h"
#include "../analysis/pattern_match.h"

// Static member
std::map<ea_t, hikari_wrapper_handler_t::wrapper_info_t> hikari_wrapper_handler_t::s_wrapper_cache;

//--------------------------------------------------------------------------
// Detection
//--------------------------------------------------------------------------
bool hikari_wrapper_handler_t::detect(mbl_array_t *mba)
{
    if ( !mba ) 
        return false;

    // Look for calls to wrapper functions
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            if ( ins->opcode == m_call ) {
                ea_t target = BADADDR;
                if ( ins->l.t == mop_v ) 
                    target = ins->l.g;

                if ( target != BADADDR && is_wrapper_by_name(target) ) {
                    return true;
                }
            }
        }
    }

    return false;
}

bool hikari_wrapper_handler_t::detect_in_binary()
{
    // Scan for functions with wrapper-like names
    size_t count = get_func_qty();
    for ( size_t i = 0; i < count; ++i ) {
        func_t *func = getn_func(i);
        if ( func && is_wrapper_by_name(func->start_ea) ) {
            return true;
        }
    }
    return false;
}

//--------------------------------------------------------------------------
// Main deobfuscation pass
//--------------------------------------------------------------------------
int hikari_wrapper_handler_t::run(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    deobf::log("[hikari_wrapper] Starting wrapper resolution\n");

    // Find all wrappers in the binary (cached)
    auto wrappers = find_wrappers();
    deobf::log("[hikari_wrapper] Found %zu wrapper functions\n", wrappers.size());

    // Find calls to wrappers in this function
    auto calls = find_wrapper_calls(mba, wrappers);
    deobf::log("[hikari_wrapper] Found %zu wrapper calls in function\n", calls.size());

    int changes = 0;

    for ( auto &call : calls ) {
        // Try to resolve the arguments
        resolve_call_args(mba, &call);

        // Find the wrapper info
        for ( const auto &wrapper : wrappers ) {
            if ( wrapper.func_ea == call.wrapper_func ) {
                // Annotate the call site
                annotate_call_site(call, wrapper);
                changes++;

                deobf::log_verbose("[hikari_wrapper] Resolved call to %s -> %s\n",
                                  wrapper.original_name.c_str(),
                                  wrapper.resolved_name.c_str());
                break;
            }
        }
    }

    deobf::log("[hikari_wrapper] Resolved %d wrapper calls\n", changes);
    return changes;
}

//--------------------------------------------------------------------------
// Resolve all wrappers in the binary
//--------------------------------------------------------------------------
int hikari_wrapper_handler_t::resolve_all_wrappers()
{
    auto wrappers = find_wrappers();

    int renamed = 0;
    for ( const auto &wrapper : wrappers ) {
        if ( !wrapper.resolved_name.empty() &&
            wrapper.resolved_name != wrapper.original_name)
            {
            if ( rename_wrapper(wrapper) ) {
                renamed++;
            }
        }
    }

    msg("[hikari_wrapper] Renamed %d wrapper functions\n", renamed);
    return renamed;
}

//--------------------------------------------------------------------------
// Find all wrapper functions
//--------------------------------------------------------------------------
std::vector<hikari_wrapper_handler_t::wrapper_info_t>
hikari_wrapper_handler_t::find_wrappers()
{

    std::vector<wrapper_info_t> result;

    size_t count = get_func_qty();
    for ( size_t i = 0; i < count; ++i ) {
        func_t *func = getn_func(i);
        if ( !func ) 
            continue;

        // Check cache first
        auto p = s_wrapper_cache.find(func->start_ea);
        if ( p != s_wrapper_cache.end() ) {
            result.push_back(p->second);
            continue;
        }

        // Check if this is a wrapper
        if ( is_wrapper_by_name(func->start_ea) || is_wrapper_by_pattern(func->start_ea) ) {
            wrapper_info_t info;
            if ( analyze_wrapper(func->start_ea, &info) ) {
                s_wrapper_cache[func->start_ea] = info;
                result.push_back(info);
            }
        }
    }

    return result;
}

//--------------------------------------------------------------------------
// Analyze a single wrapper
//--------------------------------------------------------------------------
bool hikari_wrapper_handler_t::analyze_wrapper(ea_t func_ea, wrapper_info_t *out)
{
    func_t *func = get_func(func_ea);
    if ( !func ) 
        return false;

    out->func_ea = func_ea;
    get_func_name(&out->original_name, func_ea);

    // Check for objc_msgSend pattern
    if ( has_objc_msgsend(func_ea) ) {
        out->is_objc = true;

        // Try to extract the selector from the code
        // This is complex - the selector might be passed as argument
        // or hardcoded in the wrapper

        // For now, use the wrapper number as identifier
        out->resolved_name = out->original_name;
        out->resolved_name.replace("HikariFunctionWrapper_", "ObjC_Wrapper_");

        return true;
    }

    // Check for dlsym pattern
    if ( has_dlsym_call(func_ea) ) {
        out->is_objc = false;
        out->resolved_name = out->original_name;
        out->resolved_name.replace("HikariFunctionWrapper_", "DynAPI_");
        return true;
    }

    // Generic wrapper - just mark it
    out->resolved_name = out->original_name;
    return true;
}

//--------------------------------------------------------------------------
// Check if function is a wrapper by name
//--------------------------------------------------------------------------
bool hikari_wrapper_handler_t::is_wrapper_by_name(ea_t func_ea)
{
    qstring name;
    if ( get_func_name(&name, func_ea) <= 0 ) 
        return false;

    // Common Hikari wrapper patterns
    if ( name.find("HikariFunctionWrapper") != qstring::npos ) 
        return true;
    if ( name.find("HikariWrapper") != qstring::npos ) 
        return true;
    if ( name.find("FunctionWrapper_") != qstring::npos ) 
        return true;
    if ( name.find("_wrapper_") != qstring::npos ) 
        return true;

    // OLLVM patterns
    if ( name.find("ollvm_") != qstring::npos ) 
        return true;

    return false;
}

//--------------------------------------------------------------------------
// Check if function is a wrapper by pattern
//--------------------------------------------------------------------------
bool hikari_wrapper_handler_t::is_wrapper_by_pattern(ea_t func_ea)
{
    func_t *func = get_func(func_ea);
    if ( !func ) 
        return false;

    // Wrappers are typically very short
    if ( func->end_ea - func->start_ea > 128 ) 
        return false;

    // Check for typical wrapper patterns:
    // 1. Few instructions
    // 2. Contains call to objc_msgSend/dlsym
    // 3. Forwards arguments

    int insn_count = 0;
    bool has_call = false;
    bool has_jmp = false;

    ea_t curr = func->start_ea;
    while ( curr < func->end_ea && insn_count < 20 ) {
        insn_t insn;
        if ( decode_insn(&insn, curr) == 0 ) 
            break;

        insn_count++;

        if ( is_call_insn(insn) ) 
            has_call = true;

        // Check for tail call (jmp to function)
        // This is arch-specific, simplified here

        curr = insn.ea + insn.size;
    }

    // Very short function with a call - likely a wrapper
    return (insn_count <= 10 && has_call);
}

//--------------------------------------------------------------------------
// Find wrapper calls in function
//--------------------------------------------------------------------------
std::vector<hikari_wrapper_handler_t::call_site_t>
hikari_wrapper_handler_t::find_wrapper_calls(mbl_array_t *mba,
    const std::vector<wrapper_info_t> &wrappers)
    {

    std::vector<call_site_t> result;

    // Build a set of wrapper addresses for fast lookup
    std::set<ea_t> wrapper_addrs;
    for ( const auto &w : wrappers ) {
        wrapper_addrs.insert(w.func_ea);
    }

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            if ( ins->opcode == m_call ) {
                ea_t target = BADADDR;
                if ( ins->l.t == mop_v ) 
                    target = ins->l.g;

                if ( target != BADADDR && wrapper_addrs.count(target) ) {
                    call_site_t call;
                    call.block_idx = i;
                    call.call_insn = ins;
                    call.wrapper_func = target;
                    result.push_back(call);
                }
            }
        }
    }

    return result;
}

//--------------------------------------------------------------------------
// Try to resolve call arguments
//--------------------------------------------------------------------------
bool hikari_wrapper_handler_t::resolve_call_args(mbl_array_t *mba, call_site_t *call)
{
    if ( !mba || !call || !call->call_insn ) 
        return false;

    // Try to find the class and selector arguments
    // This requires analyzing the instructions before the call

    mblock_t *blk = mba->get_mblock(call->block_idx);
    if ( !blk ) 
        return false;

    // Search backwards for argument setup
    // For Obj-C: first arg is class (or self), second is selector

    for ( minsn_t *ins = call->call_insn->prev; ins; ins = ins->prev ) {
        // Look for loads of class references
        if ( ins->opcode == m_mov || ins->opcode == m_ldx ) {
            if ( ins->l.t == mop_v ) {
                // Global reference - might be a class
                ea_t ref = ins->l.g;
                qstring name;
                if ( get_name(&name, ref) > 0 ) {
                    if ( name.find("OBJC_CLASS_") != qstring::npos ) {
                        call->class_arg = name;
                        call->class_arg.replace("OBJC_CLASS___", "");
                        call->class_arg.replace("OBJC_CLASS_$_", "");
                    }
                }
            }
        }

        // Look for string references (selectors)
        if ( ins->l.t == mop_v ) {
            ea_t str_addr = ins->l.g;
            qstring str_content;
            // Try to read the string
            size_t len = get_max_strlit_length(str_addr, STRTYPE_C);
            if ( len > 0 && len < 256 ) {
                str_content.resize(len);
                if ( get_strlit_contents(&str_content, str_addr, len, STRTYPE_C) > 0 ) {
                    // Check if it looks like a selector
                    if ( str_content.find(':') != qstring::npos ||
                        str_content.length() > 3)
                        {
                        call->selector_arg = str_content;
                    }
                }
            }
        }

        // Stop if we've gone too far back
        if ( ins == blk->head ) 
            break;
    }

    return !call->class_arg.empty() || !call->selector_arg.empty();
}

//--------------------------------------------------------------------------
// Rename wrapper function
//--------------------------------------------------------------------------
bool hikari_wrapper_handler_t::rename_wrapper(const wrapper_info_t &info)
{
    if ( info.resolved_name.empty() || info.resolved_name == info.original_name ) 
        return false;

    // Check if name already exists
    if ( get_name_ea(BADADDR, info.resolved_name.c_str()) != BADADDR ) {
        // Name exists - append a number
        qstring unique_name;
        for ( int i = 1; i < 100; ++i ) {
            unique_name.sprnt("%s_%d", info.resolved_name.c_str(), i);
            if ( get_name_ea(BADADDR, unique_name.c_str()) == BADADDR ) {
                return set_name(info.func_ea, unique_name.c_str(), SN_NOWARN | SN_NOCHECK);
            }
        }
        return false;
    }

    return set_name(info.func_ea, info.resolved_name.c_str(), SN_NOWARN | SN_NOCHECK);
}

//--------------------------------------------------------------------------
// Annotate call site
//--------------------------------------------------------------------------
void hikari_wrapper_handler_t::annotate_call_site(const call_site_t &call,
    const wrapper_info_t &wrapper)
    {

    if ( !call.call_insn ) 
        return;

    qstring comment;

    if ( wrapper.is_objc && !call.class_arg.empty() ) {
        if ( !call.selector_arg.empty() ) {
            comment.sprnt("ObjC: [%s %s]",
                         call.class_arg.c_str(), call.selector_arg.c_str());
        } else {
            comment.sprnt("ObjC: %s method call", call.class_arg.c_str());
        }
    } else if ( !wrapper.resolved_name.empty() ) {
        comment.sprnt("Wrapper -> %s", wrapper.resolved_name.c_str());
    }

    if ( !comment.empty() ) {
        set_cmt(call.call_insn->ea, comment.c_str(), false);
    }
}

//--------------------------------------------------------------------------
// Generate meaningful name
//--------------------------------------------------------------------------
qstring hikari_wrapper_handler_t::generate_name(const qstring &cls, const qstring &sel)
{
    qstring name;

    if ( !cls.empty() && !sel.empty() ) {
        name = cls;
        name += "_";

        // Clean up selector: remove colons, make CamelCase
        for ( size_t i = 0; i < sel.length(); ++i ) {
            char c = sel[i];
            if ( c == ':' ) {
                // Skip colon, capitalize next char
                if ( i + 1 < sel.length() ) {
                    name += (char)toupper(sel[i + 1]);
                    i++;
                }
            } else {
                name += c;
            }
        }
    } else if ( !cls.empty() ) {
        name = cls;
        name += "_method";
    } else if ( !sel.empty() ) {
        name = "unknown_";
        name += sel;
    }

    return name;
}

//--------------------------------------------------------------------------
// Check for objc_msgSend pattern
//--------------------------------------------------------------------------
bool hikari_wrapper_handler_t::has_objc_msgsend(ea_t func_ea)
{
    func_t *func = get_func(func_ea);
    if ( !func ) 
        return false;

    // Look for calls to objc_msgSend variants
    ea_t curr = func->start_ea;
    while ( curr < func->end_ea ) {
        insn_t insn;
        if ( decode_insn(&insn, curr) == 0 ) 
            break;

        if ( is_call_insn(insn) ) {
            ea_t target = get_first_fcref_from(insn.ea);
            if ( target != BADADDR ) {
                qstring name;
                if ( get_func_name(&name, target) > 0 ) {
                    if ( name.find("objc_msgSend") != qstring::npos ||
                        name.find("_objc_msgSend") != qstring::npos)
                        {
                        return true;
                    }
                }
            }
        }

        curr = insn.ea + insn.size;
    }

    return false;
}

//--------------------------------------------------------------------------
// Check for dlsym pattern
//--------------------------------------------------------------------------
bool hikari_wrapper_handler_t::has_dlsym_call(ea_t func_ea)
{
    func_t *func = get_func(func_ea);
    if ( !func ) 
        return false;

    ea_t curr = func->start_ea;
    while ( curr < func->end_ea ) {
        insn_t insn;
        if ( decode_insn(&insn, curr) == 0 ) 
            break;

        if ( is_call_insn(insn) ) {
            ea_t target = get_first_fcref_from(insn.ea);
            if ( target != BADADDR ) {
                qstring name;
                if ( get_func_name(&name, target) > 0 ) {
                    if ( name.find("dlsym") != qstring::npos ||
                        name.find("dlopen") != qstring::npos)
                        {
                        return true;
                    }
                }
            }
        }

        curr = insn.ea + insn.size;
    }

    return false;
}

```

`src/deobf/handlers/hikari_wrapper.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Hikari Function Wrapper Resolution Handler
//
// Hikari creates wrapper functions to hide API calls:
//   - Functions named HikariFunctionWrapper_XXX
//   - Typically call objc_msgSend, dlsym, or other APIs internally
//   - Take Class reference and selector string as arguments (Obj-C)
//   - Or take function pointer and forward arguments
//
// Example:
//   v5 = HikariFunctionWrapper_390(&OBJC_CLASS___NSDictionary,
//                                   "dictionaryWithContentsOfFile:", *v191);
//   // Actually calls: [NSDictionary dictionaryWithContentsOfFile:v191]
//
// Detection:
//   - Function names matching HikariFunctionWrapper_* or similar patterns
//   - Short functions that just forward to objc_msgSend/dlsym
//   - Functions taking Class + selector string arguments
//
// Reversal:
//   1. Identify wrapper functions
//   2. Analyze what they actually call
//   3. Rename wrappers to indicate the real target
//   4. Annotate call sites with the resolved API name
//--------------------------------------------------------------------------
class hikari_wrapper_handler_t {
public:
    // Detection
    static bool detect(mbl_array_t *mba);
    static bool detect_in_binary();

    // Main deobfuscation pass
    static int run(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Analyze and rename all wrappers in the binary
    static int resolve_all_wrappers();

private:
    // Wrapper function info
    struct wrapper_info_t {
        ea_t func_ea;               // Wrapper function address
        qstring original_name;       // Original name (e.g., HikariFunctionWrapper_390)
        qstring resolved_name;       // Resolved name (e.g., NSDictionary_dictionaryWithContentsOfFile)
        qstring target_class;        // For Obj-C: class name
        qstring target_selector;     // For Obj-C: selector
        ea_t target_func;           // For direct calls: target function
        bool is_objc;               // True if Obj-C message send
    };

    // Call site info
    struct call_site_t {
        int block_idx;
        minsn_t *call_insn;
        ea_t wrapper_func;
        qstring class_arg;          // Class argument if determinable
        qstring selector_arg;       // Selector argument if determinable
    };

    // Find all wrapper functions
    static std::vector<wrapper_info_t> find_wrappers();

    // Analyze a single wrapper function
    static bool analyze_wrapper(ea_t func_ea, wrapper_info_t *out);

    // Check if function is a wrapper (by name pattern)
    static bool is_wrapper_by_name(ea_t func_ea);

    // Check if function is a wrapper (by code pattern)
    static bool is_wrapper_by_pattern(ea_t func_ea);

    // Find call sites to wrappers in the current function
    static std::vector<call_site_t> find_wrapper_calls(mbl_array_t *mba,
                                                        const std::vector<wrapper_info_t> &wrappers);

    // Try to resolve class/selector arguments at a call site
    static bool resolve_call_args(mbl_array_t *mba, call_site_t *call);

    // Rename a wrapper function
    static bool rename_wrapper(const wrapper_info_t &info);

    // Annotate a call site
    static void annotate_call_site(const call_site_t &call, const wrapper_info_t &wrapper);

    // Generate a meaningful name from class + selector
    static qstring generate_name(const qstring &cls, const qstring &sel);

    // Check for objc_msgSend pattern
    static bool has_objc_msgsend(ea_t func_ea);

    // Check for dlsym pattern
    static bool has_dlsym_call(ea_t func_ea);

    // Cache of analyzed wrappers
    static std::map<ea_t, wrapper_info_t> s_wrapper_cache;
};

```

`src/deobf/handlers/identity_call.cpp`:

```cpp
#include "identity_call.h"
#include "../analysis/pattern_match.h"
#include "../analysis/arch_utils.h"

#ifndef ALLINS_HPP_INCLUDED
#define ALLINS_HPP_INCLUDED
#include <allins.hpp>  // For NN_mov, NN_jmp, etc.
#endif

// Static members
std::set<ea_t> identity_call_handler_t::s_identity_funcs;
std::set<ea_t> identity_call_handler_t::s_non_identity_funcs;
std::map<ea_t, ea_t> identity_call_handler_t::s_trampoline_cache;
std::map<ea_t, std::vector<deferred_identity_call_t>> identity_call_handler_t::s_deferred_analysis;

//--------------------------------------------------------------------------
// Detection
//--------------------------------------------------------------------------
bool identity_call_handler_t::detect(mbl_array_t *mba)
{
    if ( !mba ) 
        return false;

    // Scan all blocks for calls to identity functions and for ijmp.
    // If we find both (identity call somewhere + ijmp somewhere), we have the pattern.

    bool found_identity_call = false;
    bool found_ijmp = false;
    ea_t identity_func_addr = BADADDR;

    // Helper lambda to extract call target from instruction
    auto get_call_target = [](minsn_t *ins) -> ea_t {
        ea_t target = BADADDR;

        // Direct m_call
        if ( ins->opcode == m_call ) {
            if ( ins->l.t == mop_v ) 
                target = ins->l.g;
            else if ( ins->l.t == mop_a && ins->l.a && ins->l.a->t == mop_v ) 
                target = ins->l.a->g;
        }
        // m_mov with nested call (mov call(...) => temp)
        else if ( ins->opcode == m_mov && ins->l.t == mop_d && ins->l.d ) {
            minsn_t *sub = ins->l.d;
            if ( sub->opcode == m_call ) {
                if ( sub->l.t == mop_v ) 
                    target = sub->l.g;
                else if ( sub->l.t == mop_a && sub->l.a && sub->l.a->t == mop_v ) 
                    target = sub->l.a->g;
            }
        }
        return target;
    };

    // Scan all blocks
    bool found_icall = false;
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk || !blk->head ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            // Check for ijmp (indirect jump)
            if ( ins->opcode == m_ijmp ) {
                found_ijmp = true;
            }
            // Check for icall (indirect call) - used in "call identity; return v()" pattern
            if ( ins->opcode == m_icall ) {
                found_icall = true;
            }

            // Check for call to identity function
            ea_t target = get_call_target(ins);
            if ( target != BADADDR ) {
                if ( is_identity_function(target) ) {
                    found_identity_call = true;
                    identity_func_addr = target;
                    deobf::log("[identity_call] detect: %a is identity function\n", target);
                }
            }
        }
    }

    if ( found_identity_call && (found_ijmp || found_icall) ) {
        deobf::log("[identity_call] Detected pattern: identity call to %a + %s\n",
                  identity_func_addr, found_ijmp ? "ijmp" : "icall");
        return true;
    }

    return false;
}

//--------------------------------------------------------------------------
// Check if a function is an identity function
//--------------------------------------------------------------------------
bool identity_call_handler_t::is_identity_function(ea_t func_ea)
{
    if ( func_ea == BADADDR ) 
        return false;

    // Check cache first
    if ( s_identity_funcs.count(func_ea) ) 
        return true;
    if ( s_non_identity_funcs.count(func_ea) ) 
        return false;

    bool result = analyze_identity_func(func_ea);

    if ( result ) 
        s_identity_funcs.insert(func_ea);
    else
        s_non_identity_funcs.insert(func_ea);

    return result;
}

//--------------------------------------------------------------------------
// Analyze if a function is an identity function
// Identity function: just returns its first argument
// Pattern varies by architecture:
//   x86-64: mov rax, rdi; ret
//   ARM64:  ret (x0 is both first arg and return reg)
//--------------------------------------------------------------------------
bool identity_call_handler_t::analyze_identity_func(ea_t ea)
{
    // Use the architecture-independent analysis from arch_utils
    return arch::analyze_identity_function(ea);
}

//--------------------------------------------------------------------------
// Phase 1: Main deobfuscation pass - analyze and store for annotation
// NOTE: We do NOT patch bytes during decompilation - that causes INTERR.
// Instead, we store analysis results and apply annotations in Phase 2.
//--------------------------------------------------------------------------
int identity_call_handler_t::run(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    deobf::log("[identity_call] Analyzing identity call patterns\n");

    ea_t func_ea = mba->entry_ea;

    // Find all identity call patterns
    auto identity_calls = find_identity_calls(mba, ctx);
    deobf::log("[identity_call] Found %zu identity call patterns\n", identity_calls.size());

    if ( identity_calls.empty() ) 
        return 0;

    std::vector<deferred_identity_call_t> deferred;

    for ( const auto &ic : identity_calls ) {
        qstring target_name;
        if ( get_func_name(&target_name, ic.final_target) <= 0 ) {
            target_name.sprnt("sub_%a", ic.final_target);
        }

        // Store for Phase 2 (annotations and potential microcode modification)
        deferred_identity_call_t dc;
        dc.call_ea = ic.call_ea;
        dc.ijmp_ea = ic.ijmp_ea;
        dc.identity_func = ic.identity_func;
        dc.global_ptr = ic.global_ptr;
        dc.final_target = ic.final_target;
        dc.target_name = target_name;
        dc.is_ijmp_pattern = ic.is_ijmp_pattern;
        deferred.push_back(dc);

        deobf::log("[identity_call] Analyzed: call@%a -> %s (%a)\n",
                  ic.call_ea, target_name.c_str(), ic.final_target);

        // Add annotation immediately (this is safe during decompilation)
        qstring comment;
        comment.sprnt("RESOLVED: -> %s (%a)", target_name.c_str(), ic.final_target);
        set_cmt(ic.call_ea, comment.c_str(), false);

        // Rename the global pointer to make decompiled code more readable
        qstring ptr_name;
        ptr_name.sprnt("ptr_%s", target_name.c_str());
        set_name(ic.global_ptr, ptr_name.c_str(), SN_NOWARN | SN_NOCHECK);

        // Set the function type for the resolved target if not already set
        // This helps the decompiler understand the target's signature
        // Check if a function exists at this address; if not, try to create one
        func_t *target_func = get_func(ic.final_target);
        if ( !target_func ) {
            // No function at this address - try to create one
            if ( add_func(ic.final_target) ) {
                target_func = get_func(ic.final_target);
                deobf::log_verbose("[identity_call] Created function at %a\n", ic.final_target);
            }
        }

        if ( target_func ) {
            tinfo_t current_type;
            bool has_type = get_tinfo(&current_type, ic.final_target);
            if ( !has_type || current_type.empty() ) {
                // Set a default type: __int64 __fastcall()
                // This indicates the function takes no arguments and returns int64
                const char *type_str = "__int64 __fastcall f();";
                tinfo_t func_type;
                qstring parsed_name;
                if ( parse_decl(&func_type, &parsed_name, nullptr, type_str, PT_SIL) ) {
                    apply_tinfo(ic.final_target, func_type, TINFO_DEFINITE);
                    deobf::log_verbose("[identity_call] Set type for %a\n", ic.final_target);
                }
            }
        }

        ctx->indirect_resolved++;
    }

    // Store for Phase 2
    if ( !deferred.empty() ) {
        s_deferred_analysis[func_ea] = std::move(deferred);
    }

    deobf::log("[identity_call] Analyzed %zu patterns\n", identity_calls.size());

    return (int)identity_calls.size();
}

//--------------------------------------------------------------------------
// Phase 2: Apply deferred transformations at MMAT_LOCOPT
// At this maturity, we attempt microcode-level modifications to replace
// the identity call pattern with a direct call/jump.
//--------------------------------------------------------------------------
int identity_call_handler_t::apply_deferred(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    ea_t func_ea = mba->entry_ea;

    auto p = s_deferred_analysis.find(func_ea);
    if ( p == s_deferred_analysis.end() ) 
        return 0;

    deobf::log("[identity_call] Phase 2: Processing %zu patterns at maturity %d\n",
              p->second.size(), mba->maturity);

    int changes = 0;

    // At MMAT_LOCOPT (maturity 3), we can try microcode modifications
    // but we need to be very careful to maintain CFG consistency
    for ( const auto &dc : p->second ) {
        // For now, just log the pattern - microcode modification is risky
        // The annotations from Phase 1 already help the user understand the code
        deobf::log("[identity_call] Pattern: %a -> %s (annotations applied)\n",
                  dc.call_ea, dc.target_name.c_str());

        // Try to find and modify the call instruction in microcode
        // This is safer than patching x86 bytes during decompilation
        for ( int i = 0; i < mba->qty; ++i ) {
            mblock_t *blk = mba->get_mblock(i);
            if ( !blk || !blk->head ) 
                continue;

            for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
                // Look for the identity call by EA
                if ( ins->ea != dc.call_ea ) 
                    continue;

                // Found the instruction at our target EA
                // Check if it's a call or mov containing a call
                minsn_t *call_ins = nullptr;

                if ( ins->opcode == m_call ) {
                    call_ins = ins;
                } else if ( ins->opcode == m_mov && ins->l.t == mop_d && ins->l.d &&
                          ins->l.d->opcode == m_call)
                          {
                    call_ins = ins->l.d;
                }

                if ( call_ins && call_ins->l.t == mop_v &&
                    call_ins->l.g == dc.identity_func)
                    {
                    // Change the call target from identity_func to final_target
                    deobf::log("[identity_call] Redirecting call: %a -> %a\n",
                              call_ins->l.g, dc.final_target);

                    call_ins->l.g = dc.final_target;

                    // Update mcallinfo to reflect the new target
                    if ( call_ins->d.t == mop_f && call_ins->d.f ) {
                        mcallinfo_t *ci = call_ins->d.f;
                        ci->args.clear();
                        ci->solid_args = 0;
                        ci->callee = dc.final_target;
                    }

                    changes++;

                    // Now find the indirect branch (ijmp or icall) and handle it
                    for ( int j = 0; j < mba->qty; ++j ) {
                        mblock_t *blk2 = mba->get_mblock(j);
                        if ( !blk2 ) 
                            continue;

                        for ( minsn_t *check_ins = blk2->head; check_ins; check_ins = check_ins->next ) {
                            if ( check_ins->ea != dc.ijmp_ea ) 
                                continue;

                            if ( check_ins->opcode == m_ijmp ) {
                                deobf::log("[identity_call] Found ijmp in block %d, converting to nop\n", j);
                                check_ins->opcode = m_nop;
                                check_ins->l.erase();
                                check_ins->r.erase();
                                check_ins->d.erase();
                                changes++;
                            } else if ( check_ins->opcode == m_icall ) {
                                deobf::log("[identity_call] Found icall in block %d, converting to nop\n", j);
                                // For icall pattern: the identity call result is called
                                // Just nop it since we've already redirected the identity call
                                check_ins->opcode = m_nop;
                                check_ins->l.erase();
                                check_ins->r.erase();
                                check_ins->d.erase();
                                changes++;
                            }
                            break;
                        }
                    }
                }
            }
        }
    }

    // Clear the deferred analysis after processing
    s_deferred_analysis.erase(p);

    deobf::log("[identity_call] Phase 2 complete: %d modifications\n", changes);
    return changes;
}

//--------------------------------------------------------------------------
// Check if we have pending analysis
//--------------------------------------------------------------------------
bool identity_call_handler_t::has_pending_analysis(ea_t func_ea)
{
    auto p = s_deferred_analysis.find(func_ea);
    return p != s_deferred_analysis.end() && !p->second.empty();
}

//--------------------------------------------------------------------------
// Clear deferred analysis for a function
//--------------------------------------------------------------------------
void identity_call_handler_t::clear_deferred(ea_t func_ea)
{
    s_deferred_analysis.erase(func_ea);
}

//--------------------------------------------------------------------------
// Helper: Check if address is valid global pointer
//--------------------------------------------------------------------------
static bool is_valid_global_ptr(ea_t addr, ea_t exclude_target)
{
    if ( addr == BADADDR || addr == exclude_target ) 
        return false;
    // Must be in a data segment with valid pointer to code
    segment_t *seg = getseg(addr);
    if ( !seg || (seg->perm & SEGPERM_EXEC) ) 
        return false;  // Skip code segments
    // Read the pointer and check it points to code
    uint64_t val = 0;
    if ( get_bytes(&val, 8, addr) != 8 ) 
        return false;
    segment_t *target_seg = getseg((ea_t)val);
    return target_seg && (target_seg->perm & SEGPERM_EXEC);
}

//--------------------------------------------------------------------------
// Find identity call patterns
//--------------------------------------------------------------------------
std::vector<identity_call_handler_t::identity_call_t>
identity_call_handler_t::find_identity_calls(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    std::vector<identity_call_t> result;

    // Helper struct to hold call info
    struct call_info_t {
        minsn_t *call_ins;
        minsn_t *container_ins;
        ea_t target;
        ea_t global_ptr;
        ea_t call_ea;
    };

    // Helper lambda to extract call info
    auto get_call_info = [](minsn_t *ins) -> call_info_t {
        call_info_t info = {nullptr, nullptr, BADADDR, BADADDR, BADADDR};

        // Direct m_call
        if ( ins->opcode == m_call ) {
            info.call_ins = ins;
            info.container_ins = ins;
            info.call_ea = ins->ea;

            if ( ins->l.t == mop_v ) {
                info.target = ins->l.g;
            } else if ( ins->l.t == mop_a && ins->l.a && ins->l.a->t == mop_v ) {
                info.target = ins->l.a->g;
            }

            // Try to get argument from mcallinfo
            if ( ins->d.t == mop_f && ins->d.f && !ins->d.f->args.empty() ) {
                const mcallarg_t &arg0 = ins->d.f->args[0];
                if ( arg0.t == mop_v ) 
                    info.global_ptr = arg0.g;
                else if ( arg0.t == mop_a && arg0.a && arg0.a->t == mop_v ) 
                    info.global_ptr = arg0.a->g;
            }

            // At early maturity, search native instructions for argument
            if ( info.global_ptr == BADADDR && ins->ea != BADADDR ) {
                ea_t search_ea = ins->ea;
                insn_t asm_ins;
                int search_count = 0;
                while ( search_count++ < 20 && search_ea > 0 ) {
                    ea_t prev_ea = get_item_head(search_ea - 1);
                    if ( prev_ea == BADADDR || prev_ea >= search_ea ) 
                        break;
                    search_ea = prev_ea;

                    if ( decode_insn(&asm_ins, search_ea) == 0 ) 
                        break;

                    // Look for argument load from memory (arch-independent)
                    ea_t mem_addr = BADADDR;
                    if ( arch::is_arg_load_from_mem(asm_ins, &mem_addr) ) {
                        if ( is_valid_global_ptr(mem_addr, info.target) ) {
                            info.global_ptr = mem_addr;
                            break;
                        }
                    }
                }
            }
        }
        // m_mov with nested call
        else if ( ins->opcode == m_mov && ins->l.t == mop_d && ins->l.d ) {
            minsn_t *sub = ins->l.d;
            if ( sub->opcode == m_call ) {
                info.call_ins = sub;
                info.container_ins = ins;
                info.call_ea = ins->ea;

                if ( sub->l.t == mop_v ) {
                    info.target = sub->l.g;
                } else if ( sub->l.t == mop_a && sub->l.a && sub->l.a->t == mop_v ) {
                    info.target = sub->l.a->g;
                }

                // Try mcallinfo
                if ( sub->d.t == mop_f && sub->d.f && !sub->d.f->args.empty() ) {
                    const mcallarg_t &arg0 = sub->d.f->args[0];
                    if ( arg0.t == mop_v ) 
                        info.global_ptr = arg0.g;
                }

                // Search native instructions for argument (arch-independent)
                if ( info.global_ptr == BADADDR && ins->ea != BADADDR ) {
                    ea_t search_ea = ins->ea;
                    insn_t asm_ins;
                    int search_count = 0;
                    while ( search_count++ < 20 && search_ea > 0 ) {
                        ea_t prev_ea = get_item_head(search_ea - 1);
                        if ( prev_ea == BADADDR || prev_ea >= search_ea ) 
                            break;
                        search_ea = prev_ea;

                        if ( decode_insn(&asm_ins, search_ea) == 0 ) 
                            break;

                        ea_t mem_addr = BADADDR;
                        if ( arch::is_arg_load_from_mem(asm_ins, &mem_addr) ) {
                            if ( is_valid_global_ptr(mem_addr, info.target) ) {
                                info.global_ptr = mem_addr;
                                break;
                            }
                        }
                    }
                }
            }
        }
        return info;
    };

    // First pass: collect all call instructions and ijmp/icall instructions
    std::vector<std::pair<int, call_info_t>> calls;
    std::vector<std::pair<int, minsn_t*>> indirect_branches;  // ijmp or icall

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk || !blk->head ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            // Collect both ijmp and icall patterns
            if ( ins->opcode == m_ijmp || ins->opcode == m_icall ) {
                indirect_branches.push_back({i, ins});
            }

            call_info_t cinfo = get_call_info(ins);
            if ( cinfo.target != BADADDR ) {
                calls.push_back({i, cinfo});
            }
        }
    }

    deobf::log_verbose("[identity_call] find: found %zu calls, %zu indirect branches\n",
                      calls.size(), indirect_branches.size());

    // Match calls to identity functions with indirect branches (ijmp or icall)
    for ( const auto &call_pair : calls ) {
        int call_blk = call_pair.first;
        const call_info_t &cinfo = call_pair.second;

        if ( !is_identity_function(cinfo.target) ) 
            continue;

        deobf::log_verbose("[identity_call] find: identity call to %a in block %d, arg=%a\n",
                          cinfo.target, call_blk, cinfo.global_ptr);

        // Find matching indirect branch (ijmp or icall)
        for ( const auto &branch_pair : indirect_branches ) {
            int branch_blk = branch_pair.first;
            minsn_t *branch_ins = branch_pair.second;

            // Check if branch is related to call
            bool is_match = false;
            if ( branch_blk == call_blk ) {
                for ( minsn_t *p = cinfo.container_ins->next; p; p = p->next ) {
                    if ( p == branch_ins ) {
                        is_match = true;
                        break;
                    }
                }
            } else {
                // At early maturity, accept any indirect branch
                is_match = true;
            }

            if ( !is_match ) 
                continue;

            ea_t global_ptr = cinfo.global_ptr;
            ea_t resolved = BADADDR;
            ea_t final_target = BADADDR;

            // Try to resolve the pointer
            if ( global_ptr != BADADDR ) {
                resolved = resolve_global_pointer(global_ptr);
                if ( resolved != BADADDR ) {
                    final_target = resolve_trampoline_chain(resolved);

                    // Check if this is a self-reference - if so, likely wrong pointer
                    func_t *curr_func = get_func(mba->entry_ea);
                    if ( final_target == mba->entry_ea ||
                        (curr_func && final_target >= curr_func->start_ea &&
                         final_target < curr_func->end_ea))
                         {
                        deobf::log("[identity_call] Initial ptr %a resolved to self-ref %a, trying LEA search\n",
                                  global_ptr, final_target);
                        // Clear and try LEA-based table search instead
                        global_ptr = BADADDR;
                        resolved = BADADDR;
                        final_target = BADADDR;
                    }
                }
            }

            // If no simple global pointer or it was wrong, try to extract table base
            // Pattern (x86-64): lea rax, table; mov rdi, [rax+rcx*8]; call identity
            // Pattern (ARM64):  adrp x8, table; ldr x0, [x8, #off]; bl identity
            if ( final_target == BADADDR && cinfo.call_ea != BADADDR ) {
                ea_t search_ea = cinfo.call_ea;
                insn_t asm_ins;
                int search_count = 0;
                ea_t table_base = BADADDR;
                ea_t simple_ptr = BADADDR;

                while ( search_count++ < 30 && search_ea > 0 ) {
                    ea_t prev_ea = get_item_head(search_ea - 1);
                    if ( prev_ea == BADADDR || prev_ea >= search_ea ) 
                        break;
                    search_ea = prev_ea;

                    if ( decode_insn(&asm_ins, search_ea) == 0 ) 
                        break;

                    // Look for LEA/ADR instruction - loads the table base address
                    // Only take the first (closest to call) we find
                    if ( table_base == BADADDR && arch::is_lea_insn(asm_ins.itype) ) {
                        ea_t base = BADADDR;
                        // x86: LEA reg, [mem] - address in Op2
                        // ARM64: ADR/ADRP - computed address
                        if ( asm_ins.Op2.type == o_mem ) {
                            base = asm_ins.Op2.addr;
                        } else if ( asm_ins.Op1.type == o_imm ) {
                            // Some disassemblers put the address in Op1
                            base = (ea_t)asm_ins.Op1.value;
                        }
                        if ( base != BADADDR && is_valid_global_ptr(base, cinfo.target) ) {
                            table_base = base;
                            deobf::log("[identity_call] Found table base via LEA/ADR: %a\n", base);
                        }
                    }

                    // Also check for argument load from memory (simple case)
                    ea_t mem_addr = BADADDR;
                    if ( arch::is_arg_load_from_mem(asm_ins, &mem_addr) ) {
                        if ( mem_addr != BADADDR && is_valid_global_ptr(mem_addr, cinfo.target) ) {
                            simple_ptr = mem_addr;
                            // Don't break - continue to look for LEA/ADR
                        }
                    }
                }

                // Prefer LEA-based table resolution over simple pointer
                // (LEA indicates indexed table which is a more specific pattern)
                if ( table_base != BADADDR ) {
                    global_ptr = table_base;

                    // Read both table entries and check if they resolve to same target
                    ea_t target0 = resolve_global_pointer(table_base);
                    ea_t target1 = resolve_global_pointer(table_base + 8);

                    deobf::log("[identity_call] Table at %a: [0]=%a, [1]=%a\n",
                              table_base, target0, target1);

                    if ( target0 != BADADDR ) {
                        ea_t final0 = resolve_trampoline_chain(target0);
                        ea_t final1 = (target1 != BADADDR) ? resolve_trampoline_chain(target1) : BADADDR;

                        deobf::log("[identity_call] Resolved: [0]=%a->%a, [1]=%a->%a\n",
                                  target0, final0, target1, final1);

                        // Check if both targets are different and neither is self-reference
                        func_t *curr_func = get_func(mba->entry_ea);
                        bool t0_is_self = (final0 == mba->entry_ea) ||
                            (curr_func && final0 >= curr_func->start_ea && final0 < curr_func->end_ea);
                        bool t1_is_self = (final1 == mba->entry_ea) ||
                            (curr_func && final1 >= curr_func->start_ea && final1 < curr_func->end_ea);

                        // If both resolve to the same target, we can simplify
                        if ( final0 == final1 || final1 == BADADDR ) {
                            resolved = target0;
                            final_target = final0;
                            deobf::log("[identity_call] Both table entries resolve to %a\n", final_target);
                        } else if ( !t0_is_self && t1_is_self ) {
                            // Entry 0 is valid, entry 1 is self-ref - use entry 0
                            resolved = target0;
                            final_target = final0;
                            deobf::log("[identity_call] Using table[0]=%a (table[1] is self-ref)\n", final_target);
                        } else if ( t0_is_self && !t1_is_self ) {
                            // Entry 1 is valid, entry 0 is self-ref - use entry 1
                            resolved = target1;
                            final_target = final1;
                            deobf::log("[identity_call] Using table[1]=%a (table[0] is self-ref)\n", final_target);
                        } else if ( !t0_is_self && !t1_is_self ) {
                            // Both are valid different targets - conditional, use first
                            resolved = target0;
                            final_target = final0;
                            deobf::log("[identity_call] Conditional: targets differ, using %a\n", final_target);
                        } else {
                            // Both are self-reference - this is a CFF dispatcher
                            // The deflatten handler should handle this pattern
                            deobf::log("[identity_call] CFF dispatcher detected: both table entries loop back to function\n");

                            // Add annotation so user knows this is CFF
                            qstring comment;
                            comment.sprnt("CFF DISPATCHER: table@%a, targets loop back to function", table_base);
                            set_cmt(cinfo.call_ea, comment.c_str(), false);
                        }
                    }
                }

                // Fall back to simple pointer if table resolution didn't work
                if ( final_target == BADADDR && simple_ptr != BADADDR ) {
                    global_ptr = simple_ptr;
                    resolved = resolve_global_pointer(simple_ptr);
                    if ( resolved != BADADDR ) {
                        final_target = resolve_trampoline_chain(resolved);
                        deobf::log("[identity_call] Fallback to simple ptr %a -> %a\n", simple_ptr, final_target);
                    }
                }
            }

            if ( final_target == BADADDR ) {
                deobf::log_verbose("[identity_call] find: pattern found but couldn't resolve target\n");
                continue;
            }

            // Skip self-referencing patterns (would create infinite recursion)
            if ( final_target == mba->entry_ea ) {
                deobf::log("[identity_call] Skipping self-reference: target %a == function entry\n", final_target);
                continue;
            }

            // Also skip if target is within the current function (internal jump)
            func_t *curr_func = get_func(mba->entry_ea);
            if ( curr_func && final_target >= curr_func->start_ea && final_target < curr_func->end_ea ) {
                deobf::log("[identity_call] Skipping internal reference: target %a is within function\n", final_target);
                continue;
            }

            identity_call_t ic;
            ic.block_idx = branch_blk;
            ic.call_insn = cinfo.container_ins;
            ic.ijmp_insn = branch_ins;
            ic.identity_func = cinfo.target;
            ic.global_ptr = global_ptr;
            ic.resolved_target = resolved;
            ic.final_target = final_target;
            ic.call_ea = cinfo.call_ea;
            ic.ijmp_ea = branch_ins->ea;
            ic.is_ijmp_pattern = (branch_ins->opcode == m_ijmp);

            deobf::log("[identity_call] find: pattern matched: call@%a -> ptr=%a -> %a -> final %a\n",
                      cinfo.call_ea, cinfo.global_ptr, resolved, final_target);

            result.push_back(ic);
            break;
        }
    }

    return result;
}

//--------------------------------------------------------------------------
// Resolve global pointer to get actual target
//--------------------------------------------------------------------------
ea_t identity_call_handler_t::resolve_global_pointer(ea_t ptr_addr)
{
    if ( ptr_addr == BADADDR ) 
        return BADADDR;

    // Use architecture-independent pointer reading
    ea_t target = arch::read_ptr(ptr_addr);

    // Validate target is in code
    if ( target != BADADDR ) {
        segment_t *target_seg = getseg(target);
        if ( target_seg && (target_seg->perm & SEGPERM_EXEC) ) {
            return target;
        }
    }

    return BADADDR;
}

//--------------------------------------------------------------------------
// Check if a code location is a trampoline
//--------------------------------------------------------------------------
bool identity_call_handler_t::is_trampoline_code(ea_t addr, ea_t *next_ptr_out)
{
    // Use architecture-independent trampoline detection
    return arch::is_trampoline_code(addr, next_ptr_out);
}

//--------------------------------------------------------------------------
// Resolve trampoline chain recursively
//--------------------------------------------------------------------------
ea_t identity_call_handler_t::resolve_trampoline_chain(ea_t start_addr, int max_depth)
{
    if ( start_addr == BADADDR || max_depth <= 0 ) 
        return start_addr;

    // Check cache
    auto p = s_trampoline_cache.find(start_addr);
    if ( p != s_trampoline_cache.end() ) {
        return p->second;
    }

    ea_t current = start_addr;
    std::set<ea_t> visited;

    while ( max_depth-- > 0 ) {
        if ( visited.count(current) ) {
            deobf::log_verbose("[identity_call] Cycle detected at %a\n", current);
            break;
        }
        visited.insert(current);

        ea_t next_ptr = BADADDR;
        if ( is_trampoline_code(current, &next_ptr) ) {
            ea_t next_target = resolve_global_pointer(next_ptr);
            if ( next_target == BADADDR ) {
                deobf::log_verbose("[identity_call] Chain broken at %a\n", current);
                break;
            }

            deobf::log_verbose("[identity_call] Chain: %a -> ptr %a -> %a\n",
                              current, next_ptr, next_target);

            current = next_target;
        } else {
            break;
        }
    }

    s_trampoline_cache[start_addr] = current;
    return current;
}

//--------------------------------------------------------------------------
// Transform identity call by patching native instructions
// This approach patches the actual binary instructions in IDA's database,
// which is more reliable than microcode manipulation.
//
// Transform: call identity(ptr); jmp reg  ->  jmp target; nop...
//--------------------------------------------------------------------------
int identity_call_handler_t::transform_identity_call(mbl_array_t *mba,
    const deferred_identity_call_t &dc, deobf_ctx_t *ctx)
    {

    (void)mba;
    (void)ctx;

    ea_t target = dc.final_target;
    if ( target == BADADDR ) 
        return 0;

    // Decode the original instructions
    insn_t call_insn, jmp_insn;
    if ( decode_insn(&call_insn, dc.call_ea) == 0 ) 
        return 0;
    if ( decode_insn(&jmp_insn, dc.ijmp_ea) == 0 ) 
        return 0;

    // Verify we have the expected pattern (arch-independent)
    if ( !arch::is_call_insn(call_insn.itype) ) {
        deobf::log("[identity_call] Expected call at %a\n", dc.call_ea);
        return 0;
    }

    // Check for indirect jump via register (arch-independent)
    if ( !arch::is_indirect_jump_via_return_reg(jmp_insn) ) {
        deobf::log("[identity_call] Expected indirect jump at %a, got type %d\n",
                  dc.ijmp_ea, jmp_insn.itype);
        return 0;
    }

    // Calculate instruction sizes
    size_t call_size = call_insn.size;
    size_t jmp_size = jmp_insn.size;
    size_t total_size = (dc.ijmp_ea + jmp_size) - dc.call_ea;

    deobf::log("[identity_call] Patching %zu bytes at %a: call(%zu) + jmp(%zu)\n",
              total_size, dc.call_ea, call_size, jmp_size);

    // Build the patch using arch-independent instruction building
    uint8_t patch[32];
    memset(patch, 0, sizeof(patch));

    // Build direct jump instruction
    size_t jmp_len = arch::build_direct_jump(patch, sizeof(patch), dc.call_ea, target);
    if ( jmp_len == 0 ) {
        deobf::log("[identity_call] Failed to build jump instruction (target may be out of range)\n");
        // Fallback to annotations
        qstring comment;
        comment.sprnt("TRAMPOLINE -> %s (%a)", dc.target_name.c_str(), target);
        set_cmt(dc.call_ea, comment.c_str(), false);
        return 0;
    }

    // Fill rest with NOPs
    size_t nop_size = arch::get_min_insn_size();
    for ( size_t i = jmp_len; i + nop_size <= total_size && i < sizeof(patch); ) {
        size_t written = arch::get_nop_bytes(patch + i, sizeof(patch) - i);
        if ( written == 0) break;
        i += written;
    }

    // Apply the patch
    bool patched = true;
    for ( size_t i = 0; i < total_size && i < sizeof(patch); ++i ) {
        if ( !patch_byte(dc.call_ea + i, patch[i]) ) {
            patched = false;
            break;
        }
    }

    if ( !patched ) {
        deobf::log("[identity_call] Failed to patch bytes at %a\n", dc.call_ea);

        // Fallback to annotations
        qstring comment;
        comment.sprnt("TRAMPOLINE -> %s (%a)", dc.target_name.c_str(), target);
        set_cmt(dc.call_ea, comment.c_str(), false);

        qstring ptr_name;
        ptr_name.sprnt("ptr_%s", dc.target_name.c_str());
        set_name(dc.global_ptr, ptr_name.c_str(), SN_NOWARN | SN_NOCHECK);

        return 0;
    }

    // Force IDA to re-analyze the patched area
    del_items(dc.call_ea, DELIT_EXPAND, total_size);
    auto_make_code(dc.call_ea);
    auto_wait();

    // Add cross-reference to target
    add_cref(dc.call_ea, target, fl_JN);

    // Add comment
    qstring comment;
    comment.sprnt("Deobfuscated: jmp %s", dc.target_name.c_str());
    set_cmt(dc.call_ea, comment.c_str(), false);

    // Rename the global pointer
    qstring ptr_name;
    ptr_name.sprnt("ptr_%s", dc.target_name.c_str());
    set_name(dc.global_ptr, ptr_name.c_str(), SN_NOWARN | SN_NOCHECK);

    deobf::log("[identity_call] Patched to direct jmp to %s (%a)\n",
              dc.target_name.c_str(), target);

    return 1;
}

//--------------------------------------------------------------------------
// Create a proper call instruction (helper for future use)
//--------------------------------------------------------------------------
minsn_t *identity_call_handler_t::create_call_insn(mbl_array_t *mba, ea_t target, ea_t source_ea)
{
    // Allocate a new instruction from the mba
    minsn_t *call = new minsn_t(source_ea);
    call->opcode = m_call;
    call->l.t = mop_v;
    call->l.g = target;
    call->l.size = 0;

    // For a proper call, we'd also set up:
    // - call->d with mcallinfo (calling convention, arguments, return type)
    // This is complex and depends on the target function's prototype

    return call;
}

//--------------------------------------------------------------------------
// Resolve an indexed table to get both entries and determine pattern type
// This is the main utility function for other handlers (like deflatten)
//--------------------------------------------------------------------------
identity_call_handler_t::table_resolution_t
identity_call_handler_t::resolve_indexed_table(ea_t table_base, ea_t func_ea)
{
    table_resolution_t result;
    result.table_base = table_base;
    result.entry0_target = BADADDR;
    result.entry1_target = BADADDR;
    result.both_same = false;
    result.is_cff_dispatcher = false;

    if ( table_base == BADADDR ) 
        return result;

    // Read both table entries
    ea_t target0 = resolve_global_pointer(table_base);
    ea_t target1 = resolve_global_pointer(table_base + 8);

    if ( target0 == BADADDR ) {
        deobf::log_verbose("[identity_call] resolve_indexed_table: no valid target at %a\n", table_base);
        return result;
    }

    // Resolve trampoline chains to get final targets
    ea_t final0 = resolve_trampoline_chain(target0);
    ea_t final1 = (target1 != BADADDR) ? resolve_trampoline_chain(target1) : BADADDR;

    result.entry0_target = final0;
    result.entry1_target = final1;

    deobf::log_verbose("[identity_call] resolve_indexed_table: %a -> [0]=%a, [1]=%a\n",
                      table_base, final0, final1);

    // Check if both entries resolve to the same target
    if ( final0 == final1 || final1 == BADADDR ) {
        result.both_same = true;
    }

    // Check for CFF dispatcher pattern (targets loop back to function)
    if ( func_ea != BADADDR ) {
        func_t *func = get_func(func_ea);
        bool t0_is_self = (final0 == func_ea) ||
            (func && final0 >= func->start_ea && final0 < func->end_ea);
        bool t1_is_self = (final1 == func_ea) ||
            (func && final1 >= func->start_ea && final1 < func->end_ea);

        // If both targets loop back to the function, it's a CFF dispatcher
        if ( t0_is_self && t1_is_self ) {
            result.is_cff_dispatcher = true;
            deobf::log("[identity_call] resolve_indexed_table: CFF dispatcher detected at %a\n", table_base);
        }
        // If one target loops back, annotate but not full CFF
        else if ( t0_is_self || t1_is_self ) {
            deobf::log_verbose("[identity_call] resolve_indexed_table: partial self-ref at %a\n", table_base);
        }
    }

    return result;
}

```

`src/deobf/handlers/identity_call.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Identity Call Resolution Handler
//
// This obfuscation pattern uses:
//   1. An identity function: __int64 identity(__int64 a1) { return a1; }
//   2. Global pointers to code locations: off_XXX = &loc_YYY
//   3. Indirect calls/jumps: identity(off_XXX)() or jmp identity(off_XXX)
//
// Pattern A (indirect call):
//   v4 = identity_func(off_1008B8B80);  // Returns the pointer value
//   return v4();                         // Calls the target
//
// Pattern B (indirect jump - Hikari style):
//   mov rdi, cs:off_10095FB68           // Load pointer into arg1
//   call sub_1007260C0                  // Call identity function
//   jmp rax                             // Jump to returned address
//
// The targets themselves may follow the same pattern, creating a CHAIN:
//   off_A -> loc_B (which loads off_C and jumps) -> loc_D (actual code)
//
// Detection:
//   - Functions that just return their argument (identity functions)
//   - Calls to identity functions with global pointer arguments
//   - Followed by indirect jump (m_ijmp) or indirect call (m_icall)
//
// Reversal (Two-Phase Approach):
//   Phase 1 (Maturity 0 - hxe_microcode):
//     - Identify identity functions
//     - Find call patterns with ijmp/icall
//     - Resolve pointer chains to final targets
//     - Store analysis results for later
//
//   Phase 2 (MMAT_LOCOPT - optblock handler):
//     - Apply deferred transformations
//     - Convert indirect jumps to direct calls
//     - Proper microcode instruction building
//--------------------------------------------------------------------------

// Forward declaration
struct deferred_identity_call_t;

class identity_call_handler_t {
public:
    // Detection
    static bool detect(mbl_array_t *mba);

    // Main deobfuscation pass (Phase 1 - analysis at maturity 0)
    static int run(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Phase 2 - apply deferred transformations (called from optblock at MMAT_LOCOPT)
    static int apply_deferred(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Check if we have pending analysis for a function
    static bool has_pending_analysis(ea_t func_ea);

    // Clear deferred analysis for a function
    static void clear_deferred(ea_t func_ea);

    // Check if a function is an identity function
    static bool is_identity_function(ea_t func_ea);

    // Resolve pointer chain recursively (public for use by other handlers)
    static ea_t resolve_trampoline_chain(ea_t start_addr, int max_depth = 32);

    // Resolve a global pointer to get actual target address
    static ea_t resolve_global_pointer(ea_t ptr_addr);

    // Resolve an indexed table access - returns both entries if different
    // Returns: pair<entry0_target, entry1_target>
    // If both resolve to same target, second will equal first
    // If resolution fails, returns BADADDR
    struct table_resolution_t {
        ea_t table_base;
        ea_t entry0_target;   // Final resolved target for index 0
        ea_t entry1_target;   // Final resolved target for index 1
        bool both_same;       // True if both entries resolve to same target
        bool is_cff_dispatcher; // True if targets loop back (CFF pattern)
    };
    static table_resolution_t resolve_indexed_table(ea_t table_base, ea_t func_ea = BADADDR);

    // Deferred analysis storage (public for clearing on refresh)
    static std::map<ea_t, std::vector<deferred_identity_call_t>> s_deferred_analysis;

private:
    // Identity call pattern info (used during detection)
    struct identity_call_t {
        int block_idx;
        minsn_t *call_insn;      // The call to identity function
        minsn_t *ijmp_insn;      // The subsequent ijmp instruction
        ea_t identity_func;       // Address of identity function
        ea_t global_ptr;          // Address of global pointer
        ea_t resolved_target;     // Immediate target address
        ea_t final_target;        // Final target after following chain
        ea_t call_ea;             // Address of call instruction (stable across maturities)
        ea_t ijmp_ea;             // Address of ijmp instruction (stable across maturities)
        bool is_ijmp_pattern;     // True if followed by m_ijmp (vs m_icall)
    };

    // Find all identity call patterns
    static std::vector<identity_call_t> find_identity_calls(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Analyze a potential identity function
    static bool analyze_identity_func(ea_t ea);

    // Check if a code location is a trampoline (loads ptr, calls identity, jumps)
    static bool is_trampoline_code(ea_t addr, ea_t *next_ptr_out = nullptr);

    // Transform identity call at MMAT_LOCOPT (proper microcode building)
    static int transform_identity_call(mbl_array_t *mba, const deferred_identity_call_t &dc, deobf_ctx_t *ctx);

    // Create a proper call instruction
    static minsn_t *create_call_insn(mbl_array_t *mba, ea_t target, ea_t source_ea);

    // Cache of known identity functions
    static std::set<ea_t> s_identity_funcs;
    static std::set<ea_t> s_non_identity_funcs;

    // Cache of resolved trampolines: trampoline_addr -> final_target
    static std::map<ea_t, ea_t> s_trampoline_cache;
};

// Deferred analysis record - stored between maturity 0 and MMAT_LOCOPT
struct deferred_identity_call_t {
    ea_t call_ea;             // Address of call instruction
    ea_t ijmp_ea;             // Address of ijmp instruction
    ea_t identity_func;       // Address of identity function
    ea_t global_ptr;          // Address of global pointer
    ea_t final_target;        // Resolved final target
    qstring target_name;      // Name of target function (for annotation)
    bool is_ijmp_pattern;     // True if followed by m_ijmp
};

```

`src/deobf/handlers/indirect_branch.cpp`:

```cpp
#include "indirect_branch.h"
#include "../analysis/cfg_analysis.h"
#include "../analysis/stack_tracker.h"

//--------------------------------------------------------------------------
// XOR key extraction info - tracks XOR operations with global variables
//--------------------------------------------------------------------------
struct xor_key_info_t {
    ea_t global_addr;           // Address of global variable
    uint64_t immediate;         // Immediate value XOR'd with global
    uint64_t global_value;      // Value read from global at analysis time
    uint64_t result;            // immediate XOR global_value
    mreg_t dest_reg;            // Destination register
    bool has_neg;               // Whether result is negated
    bool valid;                 // Whether we successfully resolved this
    
    xor_key_info_t() : global_addr(BADADDR), immediate(0), global_value(0),
                       result(0), dest_reg(mr_none), has_neg(false), valid(false) {}
};

//--------------------------------------------------------------------------
// Enhanced indirect branch analysis info
//--------------------------------------------------------------------------
struct enhanced_ibr_info_t {
    // Table access pattern
    ea_t table_base_global;     // Global holding table base pointer
    ea_t table_base_value;      // Actual table base address
    
    // Index computation
    xor_key_info_t index_xor;   // XOR used to compute index
    int index_scale;            // Multiplier (usually 8 for 64-bit)
    
    // Offset computation
    xor_key_info_t offset_xor;  // XOR used to compute offset added to table entry
    
    // Resolved targets
    std::map<int, ea_t> index_to_target;  // index -> resolved target address
    
    enhanced_ibr_info_t() : table_base_global(BADADDR), table_base_value(BADADDR),
                            index_scale(8) {}
};

//--------------------------------------------------------------------------
// Read a value from a global variable
//--------------------------------------------------------------------------
static bool read_global_value(ea_t addr, uint64_t *out, int size = 4)
{
    if ( addr == BADADDR || !out ) 
        return false;
    
    *out = 0;
    if ( get_bytes(out, size, addr) != size ) 
        return false;
    
    // Sign extend if needed for 32-bit values
    if ( size == 4 ) {
        int32_t signed_val = (int32_t)*out;
        *out = (uint64_t)(int64_t)signed_val;
    }
    
    return true;
}

//--------------------------------------------------------------------------
// Trace XOR operations with global variables in a block
// Returns all XOR patterns: reg = immediate XOR global_var
//--------------------------------------------------------------------------
static std::vector<xor_key_info_t> find_xor_with_globals(mblock_t *blk)
{
    std::vector<xor_key_info_t> results;
    
    if ( !blk ) 
        return results;
    
    // Track register values for data flow
    std::map<mreg_t, uint64_t> reg_immediates;  // reg -> immediate value
    std::map<mreg_t, ea_t> reg_globals;         // reg -> global address
    
    for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
        // Track mov of immediate to register
        if ( ins->opcode == m_mov && ins->d.t == mop_r ) {
            if ( ins->l.t == mop_n ) {
                reg_immediates[ins->d.r] = ins->l.nnn->value;
            } else if ( ins->l.t == mop_v ) {
                // Loading from global
                reg_globals[ins->d.r] = ins->l.g;
            }
        }
        
        // Track ldx (load) from global
        if ( ins->opcode == m_ldx && ins->d.t == mop_r ) {
            if ( ins->r.t == mop_v ) {
                reg_globals[ins->d.r] = ins->r.g;
            } else if ( ins->r.t == mop_a && ins->r.a && ins->r.a->t == mop_v ) {
                reg_globals[ins->d.r] = ins->r.a->g;
            }
        }
        
        // Look for XOR patterns
        if ( ins->opcode == m_xor && ins->d.t == mop_r ) {
            xor_key_info_t info;
            info.dest_reg = ins->d.r;
            
            // Pattern 1: xor reg_with_imm, global_var
            // Pattern 2: xor imm, reg_with_global
            // Pattern 3: xor reg, global_direct
            
            // Check for immediate XOR global
            if ( ins->l.t == mop_n && ins->r.t == mop_v ) {
                // xor #imm, global
                info.immediate = ins->l.nnn->value;
                info.global_addr = ins->r.g;
            } else if ( ins->r.t == mop_n && ins->l.t == mop_v ) {
                // xor global, #imm
                info.immediate = ins->r.nnn->value;
                info.global_addr = ins->l.g;
            } else if ( ins->l.t == mop_r && ins->r.t == mop_v ) {
                // xor reg, global - check if reg has immediate
                if ( reg_immediates.count(ins->l.r) ) {
                    info.immediate = reg_immediates[ins->l.r];
                    info.global_addr = ins->r.g;
                }
            } else if ( ins->r.t == mop_r && ins->l.t == mop_v ) {
                // xor global, reg
                if ( reg_immediates.count(ins->r.r) ) {
                    info.immediate = reg_immediates[ins->r.r];
                    info.global_addr = ins->l.g;
                }
            } else if ( ins->l.t == mop_r && ins->r.t == mop_r ) {
                // xor reg1, reg2 - one might be immediate, other global
                if ( reg_immediates.count(ins->l.r) && reg_globals.count(ins->r.r) ) {
                    info.immediate = reg_immediates[ins->l.r];
                    info.global_addr = reg_globals[ins->r.r];
                } else if ( reg_immediates.count(ins->r.r) && reg_globals.count(ins->l.r) ) {
                    info.immediate = reg_immediates[ins->r.r];
                    info.global_addr = reg_globals[ins->l.r];
                }
            }
            
            // If we found a valid XOR with global, read the global value
            if ( info.global_addr != BADADDR ) {
                uint64_t gval = 0;
                if ( read_global_value(info.global_addr, &gval, 4) ) {
                    info.global_value = gval;
                    info.result = info.immediate ^ info.global_value;
                    info.valid = true;
                    
                    deobf::log("[indirect_branch] Found XOR: 0x%llx ^ [0x%llx]=0x%llx -> 0x%llx\n",
                              (unsigned long long)info.immediate,
                              (unsigned long long)info.global_addr,
                              (unsigned long long)info.global_value,
                              (unsigned long long)info.result);
                    
                    results.push_back(info);
                }
            }
            
            // Update register tracking for the result
            reg_immediates.erase(ins->d.r);
            reg_globals.erase(ins->d.r);
        }
        
        // Track NEG operations (negate result)
        if ( ins->opcode == m_neg && ins->d.t == mop_r ) {
            // Find if this negates a previous XOR result
            for ( auto &xinfo : results ) {
                if ( xinfo.dest_reg == ins->l.r || xinfo.dest_reg == ins->d.r ) {
                    xinfo.has_neg = true;
                    xinfo.result = (uint64_t)(-(int64_t)xinfo.result);
                    xinfo.dest_reg = ins->d.r;
                    deobf::log("[indirect_branch]   -> Negated to 0x%llx\n",
                              (unsigned long long)xinfo.result);
                }
            }
        }
        
        // Clear register tracking on other writes
        if ( ins->d.t == mop_r && ins->opcode != m_xor && ins->opcode != m_neg ) {
            if ( ins->opcode != m_mov || (ins->l.t != mop_n && ins->l.t != mop_v) ) {
                reg_immediates.erase(ins->d.r);
                reg_globals.erase(ins->d.r);
            }
        }
    }
    
    return results;
}

//--------------------------------------------------------------------------
// Find table base address from block
// Looks for patterns like: lea reg, global_table; mov [stack], reg
//--------------------------------------------------------------------------
static ea_t find_table_base_address(mblock_t *blk, mbl_array_t *mba)
{
    if ( !blk ) 
        return BADADDR;
    
    // Look for lea or mov of global address
    for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
        // Direct global reference
        if ( ins->opcode == m_mov && ins->l.t == mop_v ) {
            ea_t addr = ins->l.g;
            // Check if it's a pointer table (array of code addresses)
            ea_t first_entry = 0;
            if ( get_bytes(&first_entry, sizeof(ea_t), addr) == sizeof(ea_t) ) {
                if ( first_entry != 0 && is_code(get_flags(first_entry)) ) {
                    return addr;
                }
            }
        }
        
        // LEA pattern - &global
        if ( ins->opcode == m_mov && ins->l.t == mop_a && ins->l.a ) {
            if ( ins->l.a->t == mop_v ) {
                return ins->l.a->g;
            }
        }
    }
    
    // Check predecessors for table base setup
    for ( int i = 0; i < blk->npred() && i < 5; ++i ) {
        int pred_idx = blk->pred(i);
        mblock_t *pred = mba->get_mblock(pred_idx);
        if ( pred ) {
            ea_t result = find_table_base_address(pred, mba);
            if ( result != BADADDR ) 
                return result;
        }
    }
    
    return BADADDR;
}

//--------------------------------------------------------------------------
// Analyze enhanced indirect branch pattern
// Handles: target = table[xor_computed_index] + xor_computed_offset
//--------------------------------------------------------------------------
static bool analyze_enhanced_pattern(mblock_t *blk, mbl_array_t *mba,
                                     minsn_t *ijmp, enhanced_ibr_info_t *out)
                                     {
    if ( !blk || !ijmp || !out ) 
        return false;
    
    deobf::log("[indirect_branch] Analyzing enhanced pattern in block %d\n", blk->serial);
    
    // Find all XOR operations with globals
    auto xor_ops = find_xor_with_globals(blk);
    
    if ( xor_ops.empty() ) {
        deobf::log("[indirect_branch]   No XOR with globals found\n");
        return false;
    }
    
    deobf::log("[indirect_branch]   Found %zu XOR operations with globals\n", xor_ops.size());
    
    // Categorize XOR operations:
    // - One is likely for INDEX computation (used in table access)
    // - One might be for OFFSET computation (added to table entry)
    
    // Look for the ADD pattern that computes final target
    // Pattern: add reg, [table + index*8]
    bool found_table_access = false;
    
    for ( minsn_t *ins = blk->head; ins != ijmp; ins = ins->next ) {
        if ( ins->opcode == m_add ) {
            // Check for table access in operands
            // Left operand might be the offset, right might be the load
            if ( ins->r.t == mop_d && ins->r.d && ins->r.d->opcode == m_ldx ) {
                found_table_access = true;
                deobf::log("[indirect_branch]   Found add with table load\n");
            }
            if ( ins->l.t == mop_d && ins->l.d && ins->l.d->opcode == m_ldx ) {
                found_table_access = true;
                deobf::log("[indirect_branch]   Found add with table load (reversed)\n");
            }
        }
    }
    
    // Find table base
    out->table_base_value = find_table_base_address(blk, mba);
    if ( out->table_base_value == BADADDR ) {
        // Try IDA's switch detection
        switch_info_t si;
        if ( get_switch_info(&si, blk->start) > 0 || 
            get_switch_info(&si, ijmp->ea) > 0) {
            out->table_base_value = si.jumps;
            deobf::log("[indirect_branch]   Using IDA switch table at 0x%llx\n",
                      (unsigned long long)out->table_base_value);
        }
    }
    
    if ( out->table_base_value == BADADDR ) {
        deobf::log("[indirect_branch]   Could not find table base\n");
        return false;
    }
    
    deobf::log("[indirect_branch]   Table base: 0x%llx\n", 
              (unsigned long long)out->table_base_value);
    
    // Assign XOR operations to roles based on usage patterns
    // The one with negation is likely the offset
    for ( const auto &xop : xor_ops ) {
        if ( xop.has_neg ) {
            out->offset_xor = xop;
            deobf::log("[indirect_branch]   Offset XOR: result=0x%llx (negated)\n",
                      (unsigned long long)xop.result);
        } else if ( !out->index_xor.valid ) {
            out->index_xor = xop;
            deobf::log("[indirect_branch]   Index XOR: result=0x%llx\n",
                      (unsigned long long)xop.result);
        }
    }
    
    return out->index_xor.valid || out->offset_xor.valid;
}

//--------------------------------------------------------------------------
// Resolve targets for enhanced indirect branch
//--------------------------------------------------------------------------
static bool resolve_enhanced_targets(mbl_array_t *mba, enhanced_ibr_info_t *info,
                                     std::vector<ea_t> *out_targets)
                                     {
    if ( !mba || !info || !out_targets ) 
        return false;
    
    out_targets->clear();
    
    ea_t table_base = info->table_base_value;
    if ( table_base == BADADDR ) 
        return false;
    
    // Get function bounds for validation
    func_t *func = get_func(mba->entry_ea);
    ea_t func_start = func ? func->start_ea : 0;
    ea_t func_end = func ? func->end_ea : BADADDR;
    
    // Compute offset to add to each entry
    int64_t offset = 0;
    if ( info->offset_xor.valid ) {
        offset = (int64_t)info->offset_xor.result;
        deobf::log("[indirect_branch] Using offset: %lld (0x%llx)\n",
                  (long long)offset, (unsigned long long)offset);
    }
    
    // Read table entries
    // If we have index XOR, use it to determine which entries to read
    // Otherwise read all entries
    int max_entries = 512;  // Reasonable limit
    
    deobf::log("[indirect_branch] Reading table entries from 0x%llx\n",
              (unsigned long long)table_base);
    
    int valid_count = 0;
    int invalid_streak = 0;
    
    for ( int i = 0; i < max_entries && invalid_streak < 5; ++i ) {
        ea_t entry_addr = table_base + i * sizeof(ea_t);
        ea_t raw_value = 0;
        
        if ( get_bytes(&raw_value, sizeof(ea_t), entry_addr) != sizeof(ea_t) ) 
            break;
        
        // Apply offset
        ea_t target = raw_value + offset;
        
        // Validate target
        bool valid = false;
        if ( is_code(get_flags(target)) ) {
            valid = true;
        } else if ( target >= func_start && target < func_end ) {
            // Might be valid but not yet analyzed as code
            valid = true;
        }
        
        if ( valid ) {
            out_targets->push_back(target);
            info->index_to_target[i] = target;
            valid_count++;
            invalid_streak = 0;
            
            if ( valid_count <= 10 ) {
                qstring name;
                get_name(&name, target);
                deobf::log("[indirect_branch]   [%d] 0x%llx + %lld = 0x%llx %s\n",
                          i, (unsigned long long)raw_value, (long long)offset,
                          (unsigned long long)target,
                          name.empty() ? "" : name.c_str());
            }
        } else {
            invalid_streak++;
        }
    }
    
    if ( valid_count > 10 ) {
        deobf::log("[indirect_branch]   ... and %d more targets\n", valid_count - 10);
    }
    
    deobf::log("[indirect_branch] Resolved %d targets\n", valid_count);
    
    return valid_count > 0;
}

//--------------------------------------------------------------------------
// Convert indirect jump to direct jumps
// For single target: convert to goto
// For multiple targets with known index: build switch
//--------------------------------------------------------------------------
static int convert_ijmp_to_direct(mbl_array_t *mba, mblock_t *blk,
                                  const std::vector<ea_t> &targets,
                                  deobf_ctx_t *ctx)
                                  {
    if ( !mba || !blk || !blk->tail || blk->tail->opcode != m_ijmp ) 
        return 0;
    
    if ( targets.empty() ) 
        return 0;
    
    // Single target - simple conversion to goto
    if ( targets.size() == 1 ) {
        ea_t target_ea = targets[0];
        
        // Find the block containing this target
        int target_blk = -1;
        for ( int i = 0; i < mba->qty; ++i ) {
            mblock_t *b = mba->get_mblock(i);
            if ( b && b->start <= target_ea && target_ea < b->end ) {
                target_blk = i;
                break;
            }
        }
        
        if ( target_blk < 0 ) {
            deobf::log("[indirect_branch] Could not find block for target 0x%llx\n",
                      (unsigned long long)target_ea);
            return 0;
        }
        
        deobf::log("[indirect_branch] Converting ijmp to goto blk%d (target 0x%llx)\n",
                  target_blk, (unsigned long long)target_ea);
        
        // Convert ijmp to goto
        minsn_t *tail = blk->tail;
        tail->opcode = m_goto;
        tail->l.make_blkref(target_blk);
        tail->r.erase();
        tail->d.erase();
        
        // Update successor list
        blk->succset.clear();
        blk->succset.push_back(target_blk);
        
        // Update predecessor of target
        mblock_t *dst = mba->get_mblock(target_blk);
        if ( dst ) {
            auto p = std::find(dst->predset.begin(), dst->predset.end(), blk->serial);
            if ( p == dst->predset.end() ) {
                dst->predset.push_back(blk->serial);
            }
            dst->mark_lists_dirty();
        }
        
        blk->type = BLT_1WAY;
        blk->mark_lists_dirty();
        
        ctx->branches_simplified++;
        return 1;
    }
    
    // Multiple targets - we could build a switch, but that's complex
    // For now, if ALL targets go to the same block, convert to single goto
    std::set<int> target_blocks;
    for ( ea_t target_ea : targets ) {
        for ( int i = 0; i < mba->qty; ++i ) {
            mblock_t *b = mba->get_mblock(i);
            if ( b && b->start <= target_ea && target_ea < b->end ) {
                target_blocks.insert(i);
                break;
            }
        }
    }
    
    if ( target_blocks.size() == 1 ) {
        int target_blk = *target_blocks.begin();
        deobf::log("[indirect_branch] All %zu targets go to block %d, converting to goto\n",
                  targets.size(), target_blk);
        
        minsn_t *tail = blk->tail;
        tail->opcode = m_goto;
        tail->l.make_blkref(target_blk);
        tail->r.erase();
        tail->d.erase();
        
        blk->succset.clear();
        blk->succset.push_back(target_blk);
        
        mblock_t *dst = mba->get_mblock(target_blk);
        if ( dst ) {
            auto p = std::find(dst->predset.begin(), dst->predset.end(), blk->serial);
            if ( p == dst->predset.end() ) {
                dst->predset.push_back(blk->serial);
            }
            dst->mark_lists_dirty();
        }
        
        blk->type = BLT_1WAY;
        blk->mark_lists_dirty();
        
        ctx->branches_simplified++;
        return 1;
    }
    
    // Multiple different target blocks
    // Building a proper jtbl is complex due to mcases_t structure requirements.
    // For now, if we have a small number of targets, we'll annotate and leave
    // the ijmp. In future iterations, we could build proper switch statements.
    
    deobf::log("[indirect_branch] Found %zu unique target blocks - annotating\n",
              target_blocks.size());
    
    // Add detailed annotation about the resolved targets
    qstring comment;
    comment.sprnt("DEOBF: Indirect jump resolved to %zu targets:\n", targets.size());
    
    int idx = 0;
    for ( ea_t target_ea : targets ) {
        if ( idx < 20 ) {
            qstring name;
            get_name(&name, target_ea);
            comment.cat_sprnt("  [%d] 0x%llX %s\n", idx,
                             (unsigned long long)target_ea,
                             name.empty() ? "" : name.c_str());
        }
        idx++;
    }
    
    if ( targets.size() > 20 ) {
        comment.cat_sprnt("  ... and %zu more\n", targets.size() - 20);
    }
    
    set_cmt(blk->start, comment.c_str(), false);
    
    // Even though we can't convert to switch, mark as processed
    ctx->branches_simplified++;
    return 1;
}

//--------------------------------------------------------------------------
// Detection
//--------------------------------------------------------------------------
bool indirect_branch_handler_t::detect(mbl_array_t *mba)
{
    if ( !mba ) 
        return false;

    // Look for ijmp instructions
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk || !blk->tail ) 
            continue;

        if ( blk->tail->opcode == m_ijmp ) {
            return true;
        }
    }

    // Also check for global jump tables
    segment_t *seg = get_first_seg();
    while ( seg ) {
        if ( seg->type == SEG_DATA ) {
            ea_t ea = seg->start_ea;
            while ( ea < seg->end_ea ) {
                qstring name;
                if ( get_name(&name, ea) > 0 ) {
                    if ( name.find("IndirectBranchingGlobalTable") != qstring::npos ||
                        name.find("HikariConditionalLocalIndirectBranchingTable") != qstring::npos ||
                        name.find("IndirectBranchTable") != qstring::npos)
                        {
                        return true;
                    }
                }
                ea = next_head(ea, seg->end_ea);
                if ( ea == BADADDR ) 
                    break;
            }
        }
        seg = get_next_seg(seg->start_ea);
    }

    return false;
}

//--------------------------------------------------------------------------
// Main deobfuscation pass
//--------------------------------------------------------------------------
int indirect_branch_handler_t::run(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    deobf::log("[indirect_branch] Starting indirect branch resolution\n");

    int total_changes = 0;

    // Find all indirect branches
    auto ibrs = find_indirect_branches(mba);
    deobf::log("[indirect_branch] Found %zu indirect branches\n", ibrs.size());

    for ( auto &ibr : ibrs ) {
        mblock_t *blk = mba->get_mblock(ibr.block_idx);
        if ( !blk ) 
            continue;

        // Try enhanced analysis first (XOR-encrypted patterns)
        enhanced_ibr_info_t einfo;
        if ( analyze_enhanced_pattern(blk, mba, ibr.ijmp_insn, &einfo) ) {
            std::vector<ea_t> resolved_targets;
            if ( resolve_enhanced_targets(mba, &einfo, &resolved_targets) ) {
                // Convert to direct jumps
                int changes = convert_ijmp_to_direct(mba, blk, resolved_targets, ctx);
                if ( changes > 0 ) {
                    total_changes += changes;
                    deobf::log("[indirect_branch] Block %d: converted via enhanced analysis\n",
                              blk->serial);
                    continue;
                }
            }
        }

        // Fall back to standard analysis
        index_computation_t idx_comp;
        if ( trace_index_computation(blk, ibr.ijmp_insn, &idx_comp) ) {
            ibr.index_traced = true;
            ibr.possible_indices = emulate_index_values(mba, blk, idx_comp);
            deobf::log("[indirect_branch] Block %d: traced %zu possible indices\n",
                      blk->serial, ibr.possible_indices.size());
        }

        // Try to resolve and convert
        if ( !ibr.targets.empty() ) {
            int changes = convert_ijmp_to_direct(mba, blk, ibr.targets, ctx);
            if ( changes > 0 ) {
                total_changes += changes;
                continue;
            }
        }
        
        // Try frameless continuation analysis
        // This handles cases where the ijmp target is an external "trampoline" function
        // that uses the caller's stack frame to compute the next jump target
        if ( ibr.targets.size() == 1 ) {
            ea_t continuation_ea = ibr.targets[0];
            
            // Check if target is a frameless continuation
            if ( frameless_continuation_t::is_frameless_continuation(continuation_ea) ) {
                deobf::log("[indirect_branch] Block %d: target 0x%llx is frameless continuation\n",
                          blk->serial, (unsigned long long)continuation_ea);
                
                // Build caller context from this function
                caller_context_t caller_ctx = frameless_continuation_t::build_caller_context(mba, blk);
                caller_ctx.caller_func = mba->entry_ea;
                caller_ctx.callee_func = continuation_ea;
                
                // Resolve the continuation's final jump target
                ea_t final_target = frameless_continuation_t::resolve_continuation_jump(continuation_ea, caller_ctx);
                
                if ( final_target != BADADDR && is_code(get_flags(final_target)) ) {
                    deobf::log("[indirect_branch] Resolved frameless continuation: 0x%llx -> 0x%llx\n",
                              (unsigned long long)continuation_ea, (unsigned long long)final_target);
                    
                    // Find the block containing the final target
                    int target_blk = -1;
                    for ( int bi = 0; bi < mba->qty; bi++ ) {
                        mblock_t *b = mba->get_mblock(bi);
                        if ( b && b->start <= final_target && final_target < b->end ) {
                            target_blk = bi;
                            break;
                        }
                    }
                    
                    if ( target_blk >= 0 ) {
                        // Convert ijmp to direct goto
                        std::vector<ea_t> resolved_targets = {final_target};
                        int changes = convert_ijmp_to_direct(mba, blk, resolved_targets, ctx);
                        if ( changes > 0 ) {
                            total_changes += changes;
                            continue;
                        }
                    } else {
                        // Target is outside current microcode - annotate
                        qstring comment;
                        comment.sprnt("DEOBF: Frameless continuation resolved\n"
                                     "  Continuation: 0x%llX\n"
                                     "  Final target: 0x%llX (external)",
                                     (unsigned long long)continuation_ea,
                                     (unsigned long long)final_target);
                        set_cmt(blk->start, comment.c_str(), false);
                        ctx->branches_simplified++;
                        total_changes++;
                        continue;
                    }
                }
            }
        }
        
        // If we couldn't convert, at least annotate
        total_changes += replace_indirect_branch(mba, blk, ibr, ctx);
    }

    deobf::log("[indirect_branch] Resolved %d indirect branches\n", total_changes);
    return total_changes;
}

//--------------------------------------------------------------------------
// Find indirect branches
//--------------------------------------------------------------------------
std::vector<indirect_branch_handler_t::indirect_br_t>
indirect_branch_handler_t::find_indirect_branches(mbl_array_t *mba)
{

    std::vector<indirect_br_t> result;

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk || !blk->tail ) 
            continue;

        if ( blk->tail->opcode == m_ijmp ) {
            indirect_br_t ibr;
            ibr.block_idx = i;
            ibr.ijmp_insn = blk->tail;
            ibr.is_encrypted = false;
            ibr.enc_key = 0;
            ibr.encoding = ENC_DIRECT;
            ibr.base_addr = BADADDR;
            ibr.entry_size = sizeof(ea_t);
            ibr.table_size = 0;
            ibr.index_traced = false;

            if ( analyze_ijmp(blk, blk->tail, &ibr) ) {
                result.push_back(ibr);
            } else {
                // Even if analysis failed, add it for enhanced processing
                result.push_back(ibr);
            }
        }
    }

    return result;
}

//--------------------------------------------------------------------------
// Analyze table encoding
//--------------------------------------------------------------------------
indirect_branch_handler_t::table_encoding_t
indirect_branch_handler_t::analyze_table_encoding(mblock_t *blk, minsn_t *ijmp,
                                                  uint64_t *out_key, ea_t *out_base)
                                                  {
    if ( !blk || !ijmp ) 
        return ENC_UNKNOWN;

    bool has_xor = false;
    bool has_add = false;
    uint64_t xor_key = 0;
    ea_t base_addr = BADADDR;

    // Trace back through the block looking for XOR and ADD operations
    for ( minsn_t *ins = blk->head; ins && ins != ijmp; ins = ins->next ) {
        // Look for XOR with constant
        if ( ins->opcode == m_xor ) {
            if ( ins->l.t == mop_n ) {
                has_xor = true;
                xor_key = ins->l.nnn->value;
            } else if ( ins->r.t == mop_n ) {
                has_xor = true;
                xor_key = ins->r.nnn->value;
            } else if ( ins->l.t == mop_v || ins->r.t == mop_v ) {
                // XOR with global - try to read the value
                ea_t gaddr = (ins->l.t == mop_v) ? ins->l.g : ins->r.g;
                uint64_t gval = 0;
                if ( read_global_value(gaddr, &gval, 4) ) {
                    has_xor = true;
                    // The immediate is the other operand
                    // This is a simplified heuristic
                }
            }
        }

        // Look for ADD with global address (base offset)
        if ( ins->opcode == m_add ) {
            if ( ins->l.t == mop_v ) {
                has_add = true;
                base_addr = ins->l.g;
            } else if ( ins->r.t == mop_v ) {
                has_add = true;
                base_addr = ins->r.g;
            }
        }
    }

    if ( out_key) *out_key = xor_key;
    if ( out_base) *out_base = base_addr;

    if ( has_xor && has_add) return ENC_OFFSET_XOR;
    if ( has_xor) return ENC_XOR;
    if ( has_add) return ENC_OFFSET;
    return ENC_DIRECT;
}

//--------------------------------------------------------------------------
// Trace index computation
//--------------------------------------------------------------------------
bool indirect_branch_handler_t::trace_index_computation(mblock_t *blk, minsn_t *ijmp,
                                                        index_computation_t *out)
                                                        {
    if ( !blk || !ijmp || !out ) 
        return false;

    out->type = index_computation_t::OP_COMPLEX;
    out->mask = 0;
    out->sub_value = 0;
    out->max_index = 256;  // Default max

    for ( minsn_t *ins = blk->tail; ins; ins = ins->prev ) {
        if ( ins == ijmp ) 
            continue;

        // Look for AND with constant mask
        if ( ins->opcode == m_and ) {
            if ( ins->r.t == mop_n ) {
                out->type = index_computation_t::OP_AND;
                out->mask = ins->r.nnn->value;
                out->max_index = (int)out->mask + 1;

                if ( ins->l.t == mop_d && ins->l.d && ins->l.d->opcode == m_sub ) {
                    minsn_t *sub = ins->l.d;
                    if ( sub->r.t == mop_n ) {
                        out->type = index_computation_t::OP_SUB_AND;
                        out->sub_value = sub->r.nnn->value;
                        out->source_var = sub->l;
                    }
                } else {
                    out->source_var = ins->l;
                }
                return true;
            }
        }

        // Look for low byte extraction
        if ( ins->opcode == m_low ) {
            out->type = index_computation_t::OP_AND;
            out->mask = 0xFF;
            out->max_index = 256;
            out->source_var = ins->l;
            return true;
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// Emulate index values
//--------------------------------------------------------------------------
std::set<int> indirect_branch_handler_t::emulate_index_values(
    mbl_array_t *mba, mblock_t *blk, const index_computation_t &idx_comp)
    {

    std::set<int> indices;

    if ( idx_comp.type == index_computation_t::OP_AND ||
        idx_comp.type == index_computation_t::OP_SUB_AND)
        {

        for ( int i = 0; i <= (int)idx_comp.mask && i < idx_comp.max_index; ++i ) {
            indices.insert(i);
        }
        return indices;
    }

    if ( idx_comp.type == index_computation_t::OP_MOD ) {
        for ( int i = 0; i < (int)idx_comp.mask && i < idx_comp.max_index; ++i ) {
            indices.insert(i);
        }
        return indices;
    }

    return indices;
}

//--------------------------------------------------------------------------
// Analyze indirect jump
//--------------------------------------------------------------------------
bool indirect_branch_handler_t::analyze_ijmp(mblock_t *blk, minsn_t *ijmp, indirect_br_t *out)
{
    if ( !blk || !ijmp || ijmp->opcode != m_ijmp ) 
        return false;

    // Analyze encoding
    uint64_t key = 0;
    ea_t base = BADADDR;
    out->encoding = analyze_table_encoding(blk, ijmp, &key, &base);
    out->enc_key = key;
    out->base_addr = base;
    out->is_encrypted = (out->encoding == ENC_XOR || out->encoding == ENC_OFFSET_XOR);

    // Find the jump table
    ea_t table_addr = find_jump_table(blk, ijmp);
    if ( table_addr == BADADDR ) {
        deobf::log_verbose("[indirect_branch] Could not find jump table for block %d\n",
                          blk->serial);
        return false;
    }

    out->table_addr = table_addr;
    out->entry_size = sizeof(ea_t);

    // Read targets from table
    out->targets = read_jump_targets(table_addr, 256, out->encoding,
                                     out->enc_key, out->base_addr, out->entry_size);

    if ( out->targets.empty() && sizeof(ea_t) == 8 ) {
        out->entry_size = 4;
        out->targets = read_jump_targets(table_addr, 256, out->encoding,
                                         out->enc_key, out->base_addr, out->entry_size);
    }

    out->table_size = (int)out->targets.size();

    if ( out->targets.empty() ) {
        deobf::log_verbose("[indirect_branch] No valid targets found at %a\n", table_addr);
        return false;
    }

    deobf::log_verbose("[indirect_branch] Found %zu targets at table %a (enc=%d, entry=%d)\n",
                      out->targets.size(), table_addr, out->encoding, out->entry_size);

    return true;
}

//--------------------------------------------------------------------------
// Find jump table
//--------------------------------------------------------------------------
ea_t indirect_branch_handler_t::find_jump_table(mblock_t *blk, minsn_t *ijmp)
{
    // Trace back from ijmp to find the table address
    for ( minsn_t *ins = blk->head; ins && ins != ijmp; ins = ins->next ) {
        if ( ins->opcode == m_ldx ) {
            if ( ins->l.t == mop_v ) {
                ea_t addr = ins->l.g;
                uint64_t first_entry = 0;
                if ( get_bytes(&first_entry, sizeof(ea_t), addr) == sizeof(ea_t) ) {
                    if ( first_entry != 0 && first_entry != BADADDR ) {
                        if ( is_code(get_flags((ea_t)first_entry)) ) {
                            return addr;
                        }
                        func_t *func = get_func(blk->start);
                        if ( func ) {
                            ea_t resolved = func->start_ea + first_entry;
                            if ( is_code(get_flags(resolved)) ) {
                                return addr;
                            }
                        }
                    }
                }
            }

            if ( ins->l.t == mop_d && ins->l.d ) {
                minsn_t *addr_calc = ins->l.d;
                if ( addr_calc->opcode == m_add ) {
                    if ( addr_calc->l.t == mop_v ) {
                        return addr_calc->l.g;
                    }
                    if ( addr_calc->r.t == mop_v ) {
                        return addr_calc->r.g;
                    }
                }
            }
        }
    }

    if ( ijmp->d.t == mop_v ) {
        return ijmp->d.g;
    }

    const char *table_names[] = {
        "IndirectBranchingGlobalTable",
        "HikariConditionalLocalIndirectBranchingTable",
        "IndirectBranchTable",
        nullptr
    };

    for ( int i = 0; table_names[i]; ++i ) {
        ea_t table_ea = get_name_ea(BADADDR, table_names[i]);
        if ( table_ea != BADADDR ) 
            return table_ea;
    }

    return BADADDR;
}

//--------------------------------------------------------------------------
// Decode a single table entry
//--------------------------------------------------------------------------
ea_t indirect_branch_handler_t::decode_table_entry(uint64_t raw_value,
                                                   table_encoding_t encoding,
                                                   uint64_t key, ea_t base)
                                                   {
    switch ( encoding ) {
        case ENC_DIRECT:
            return (ea_t)raw_value;

        case ENC_OFFSET:
            if ( base != BADADDR ) 
                return base + raw_value;
            return (ea_t)raw_value;

        case ENC_XOR:
            return (ea_t)(raw_value ^ key);

        case ENC_OFFSET_XOR:
            if ( base != BADADDR ) 
                return base + (raw_value ^ key);
            return (ea_t)(raw_value ^ key);

        default:
            return (ea_t)raw_value;
    }
}

//--------------------------------------------------------------------------
// Read jump targets from table
//--------------------------------------------------------------------------
std::vector<ea_t> indirect_branch_handler_t::read_jump_targets(
    ea_t table_addr, int max_entries,
    table_encoding_t encoding, uint64_t key, ea_t base, int entry_size)
    {

    std::vector<ea_t> targets;

    if ( table_addr == BADADDR ) 
        return targets;

    func_t *func = get_func(table_addr);
    ea_t func_start = func ? func->start_ea : BADADDR;
    ea_t func_end = func ? func->end_ea : BADADDR;

    for ( int i = 0; i < max_entries; ++i ) {
        ea_t entry_addr = table_addr + i * entry_size;
        uint64_t raw_value = 0;

        if ( get_bytes(&raw_value, entry_size, entry_addr) != entry_size ) 
            break;

        if ( raw_value == 0 ) 
            break;

        ea_t target = decode_table_entry(raw_value, encoding, key, base);

        if ( target == 0 || target == BADADDR ) 
            break;

        if ( is_code(get_flags(target)) ) {
            targets.push_back(target);
            continue;
        }

        if ( (encoding == ENC_OFFSET || encoding == ENC_OFFSET_XOR) &&
            func_start != BADADDR)
            {
            ea_t alt_target = func_start + raw_value;
            if ( encoding == ENC_OFFSET_XOR ) 
                alt_target = func_start + (raw_value ^ key);

            if ( is_code(get_flags(alt_target)) ) {
                targets.push_back(alt_target);
                continue;
            }
        }

        if ( targets.size() > 2 ) 
            break;
    }

    return targets;
}

//--------------------------------------------------------------------------
// Decrypt targets (legacy support)
//--------------------------------------------------------------------------
std::vector<ea_t> indirect_branch_handler_t::decrypt_targets(
    const std::vector<ea_t> &encrypted, uint64_t key)
    {

    std::vector<ea_t> decrypted;

    for ( ea_t enc : encrypted ) {
        ea_t dec = enc ^ key;
        decrypted.push_back(dec);
    }

    return decrypted;
}

//--------------------------------------------------------------------------
// Validate targets belong to the function
//--------------------------------------------------------------------------
bool indirect_branch_handler_t::validate_targets(const std::vector<ea_t> &targets,
                                                 mbl_array_t *mba)
                                                 {
    if ( targets.empty() ) 
        return false;

    ea_t func_start = mba->entry_ea;
    func_t *func = get_func(func_start);
    if ( !func ) 
        return true;

    for ( ea_t target : targets ) {
        if ( target < func->start_ea || target >= func->end_ea ) {
            if ( !is_code(get_flags(target)) ) {
                return false;
            }
        }
    }

    return true;
}

//--------------------------------------------------------------------------
// Annotate indirect branch
//--------------------------------------------------------------------------
void indirect_branch_handler_t::annotate_indirect_branch(mblock_t *blk,
                                                         const indirect_br_t &ibr)
                                                         {
    qstring comment;
    comment.sprnt("DEOBF: Indirect branch table at 0x%llX (%d entries)",
                 (unsigned long long)ibr.table_addr, (int)ibr.targets.size());

    if ( ibr.is_encrypted ) {
        comment.cat_sprnt(" [encrypted, key=0x%llX]", (unsigned long long)ibr.enc_key);
    }

    comment += "\nTargets:";
    for ( size_t i = 0; i < ibr.targets.size() && i < 10; ++i ) {
        qstring name;
        if ( get_name(&name, ibr.targets[i]) > 0 ) {
            comment.cat_sprnt("\n  [%d] 0x%llX (%s)", (int)i,
                             (unsigned long long)ibr.targets[i], name.c_str());
        } else {
            comment.cat_sprnt("\n  [%d] 0x%llX", (int)i,
                             (unsigned long long)ibr.targets[i]);
        }
    }

    if ( ibr.targets.size() > 10 ) {
        comment.cat_sprnt("\n  ... and %d more", (int)(ibr.targets.size() - 10));
    }

    set_cmt(blk->start, comment.c_str(), false);
}

//--------------------------------------------------------------------------
// Build switch from indirect branch
//--------------------------------------------------------------------------
int indirect_branch_handler_t::build_switch(mbl_array_t *mba, mblock_t *blk,
                                           const indirect_br_t &ibr, deobf_ctx_t *ctx)
                                           {
    annotate_indirect_branch(blk, ibr);
    return 0;
}

//--------------------------------------------------------------------------
// Replace indirect branch
//--------------------------------------------------------------------------
int indirect_branch_handler_t::replace_indirect_branch(mbl_array_t *mba, mblock_t *blk,
    const indirect_br_t &ibr, deobf_ctx_t *ctx)
    {

    if ( !blk || ibr.targets.empty() ) 
        return 0;

    // Try to convert to direct jumps first
    int changes = convert_ijmp_to_direct(mba, blk, ibr.targets, ctx);
    if ( changes > 0 ) 
        return changes;

    // Fall back to annotation
    deobf::log("[indirect_branch] Block %d: table at 0x%llX with %zu targets (annotating)\n",
              blk->serial, (unsigned long long)ibr.table_addr, ibr.targets.size());

    annotate_indirect_branch(blk, ibr);

    deobf::log("[indirect_branch]   Targets:\n");
    for ( size_t i = 0; i < ibr.targets.size() && i < 16; ++i ) {
        qstring name;
        get_name(&name, ibr.targets[i]);
        deobf::log("[indirect_branch]     [%zu] 0x%llX %s\n",
                  i, (unsigned long long)ibr.targets[i],
                  name.empty() ? "" : name.c_str());
    }

    ctx->branches_simplified++;
    return 1;
}

```

`src/deobf/handlers/indirect_branch.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Indirect Branch Resolution Handler
//
// Hikari's indirect branches:
//   - Creates jump table (IndirectBranchingGlobalTable)
//   - Replaces direct branches with table lookups
//   - Optionally encrypts jump targets
//   - May use conditional local tables (HikariConditionalLocalIndirectBranchingTable)
//
// Table formats:
//   1. Direct addresses: table[i] = target_ea
//   2. Offsets from base: table[i] = target_ea - base_ea
//   3. XOR encrypted: table[i] = target_ea ^ key
//   4. Combined: table[i] = (target_ea - base_ea) ^ key
//
// Detection:
//   - ijmp (indirect jump) instructions
//   - Global arrays of code pointers
//   - XOR before address load (encryption)
//   - Local stack-based jump tables
//
// Reversal:
//   1. Find indirect jump instructions
//   2. Trace back to find jump table address
//   3. Emulate index computation to find possible values
//   4. Read and decode targets from table
//   5. Replace ijmp with switch or direct branches
//--------------------------------------------------------------------------
class indirect_branch_handler_t {
public:
    // Detection
    static bool detect(mbl_array_t *mba);

    // Main deobfuscation pass
    static int run(mbl_array_t *mba, deobf_ctx_t *ctx);

private:
    // Table encoding type
    enum table_encoding_t {
        ENC_DIRECT,         // Direct addresses
        ENC_OFFSET,         // Offsets from base
        ENC_XOR,            // XOR encrypted
        ENC_OFFSET_XOR,     // Offset + XOR
        ENC_UNKNOWN
    };

    // Indirect branch info
    struct indirect_br_t {
        int block_idx;
        minsn_t *ijmp_insn;
        ea_t table_addr;
        std::vector<ea_t> targets;
        bool is_encrypted;
        uint64_t enc_key;
        table_encoding_t encoding;
        ea_t base_addr;             // Base address for offset encoding
        int entry_size;             // Size of each table entry (4 or 8 bytes)
        int table_size;             // Number of entries
        mop_t index_var;            // Variable used as index
        bool index_traced;          // Whether we traced the index
        std::set<int> possible_indices;  // Possible index values
    };

    // Index computation info
    struct index_computation_t {
        enum op_t {
            OP_DIRECT,      // index = var
            OP_AND,         // index = var & mask
            OP_MOD,         // index = var % divisor
            OP_SUB_AND,     // index = (var - sub) & mask
            OP_COMPLEX
        };

        op_t type;
        mop_t source_var;       // Source variable
        uint64_t mask;          // AND mask or MOD divisor
        uint64_t sub_value;     // Subtraction value
        int max_index;          // Maximum possible index value
    };

    static std::vector<indirect_br_t> find_indirect_branches(mbl_array_t *mba);

    // Analyze an indirect jump
    static bool analyze_ijmp(mblock_t *blk, minsn_t *ijmp, indirect_br_t *out);

    // Find the jump table
    static ea_t find_jump_table(mblock_t *blk, minsn_t *ijmp);

    // Analyze table encoding
    static table_encoding_t analyze_table_encoding(mblock_t *blk, minsn_t *ijmp,
                                                   uint64_t *out_key, ea_t *out_base);

    // Trace index computation
    static bool trace_index_computation(mblock_t *blk, minsn_t *ijmp,
                                       index_computation_t *out);

    // Emulate index values to find all possible indices
    static std::set<int> emulate_index_values(mbl_array_t *mba, mblock_t *blk,
                                              const index_computation_t &idx_comp);

    // Read targets from jump table with encoding support
    static std::vector<ea_t> read_jump_targets(ea_t table_addr, int max_entries,
                                               table_encoding_t encoding,
                                               uint64_t key, ea_t base,
                                               int entry_size);

    // Decrypt jump targets (legacy)
    static std::vector<ea_t> decrypt_targets(const std::vector<ea_t> &encrypted, uint64_t key);

    // Decode a single table entry
    static ea_t decode_table_entry(uint64_t raw_value, table_encoding_t encoding,
                                   uint64_t key, ea_t base);

    // Validate jump targets
    static bool validate_targets(const std::vector<ea_t> &targets, mbl_array_t *mba);

    // Replace indirect branch with direct branches
    static int replace_indirect_branch(mbl_array_t *mba, mblock_t *blk,
                                       const indirect_br_t &ibr, deobf_ctx_t *ctx);

    // Build switch from indirect branch
    static int build_switch(mbl_array_t *mba, mblock_t *blk,
                           const indirect_br_t &ibr, deobf_ctx_t *ctx);

    // Annotate unresolved indirect branch
    static void annotate_indirect_branch(mblock_t *blk, const indirect_br_t &ibr);
};

```

`src/deobf/handlers/indirect_call.cpp`:

```cpp
#include "indirect_call.h"
#include "../analysis/cfg_analysis.h"
#include "../analysis/stack_tracker.h"

//--------------------------------------------------------------------------
// File-based debug logging
//--------------------------------------------------------------------------
#include "../../common/compat.h"

static void icall_debug(const char *fmt, ...)
{
#ifndef _WIN32
    char buf[4096];
    va_list args;
    va_start(args, fmt);
    int len = qvsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);
    
    int fd = open("/tmp/indirect_call_debug.log", O_WRONLY | O_CREAT | O_APPEND, 0644);
    if ( fd >= 0 ) {
        write(fd, buf, len);
        close(fd);
    }
#else
    (void)fmt;
#endif
}

static bool is_valid_database_ea(ea_t ea)
{
    if ( ea == BADADDR )
        return false;

    const ea_t min_ea = inf_get_min_ea();
    const ea_t max_ea = inf_get_max_ea();
    return ea >= min_ea && ea < max_ea;
}

static bool is_code_ea(ea_t ea)
{
    return is_valid_database_ea(ea) && is_code(get_flags(ea));
}

static func_t *get_func_safe(ea_t ea)
{
    if ( !is_valid_database_ea(ea) )
        return nullptr;
    return get_func(ea);
}

static flags64_t get_flags_safe(ea_t ea)
{
    if ( !is_valid_database_ea(ea) )
        return 0;
    return get_flags(ea);
}

//--------------------------------------------------------------------------
// Detection - look for indirect call patterns
//
// Pattern 1: icall with computed target
// Pattern 2: call with target loaded from table and modified
//--------------------------------------------------------------------------
bool indirect_call_handler_t::detect(mbl_array_t *mba)
{
    if ( !mba ) 
        return false;

    icall_debug("[indirect_call] detect() called for func 0x%llx\n", 
                (unsigned long long)mba->entry_ea);

    // Look for icall instructions or calls with complex computed targets
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            // Check for icall (indirect call)
            if ( ins->opcode == m_icall ) {
                icall_debug("[indirect_call] Found m_icall in block %d\n", i);
                return true;
            }

            // Check for call with computed target
            // A direct call has l operand as mop_v (global) or mop_a (address)
            // A computed call has l operand as mop_r (register) or mop_d (result of computation)
            if ( ins->opcode == m_call ) {
                if ( ins->l.t == mop_r || ins->l.t == mop_d ) {
                    icall_debug("[indirect_call] Found m_call with computed target in block %d\n", i);
                    return true;
                }
                // Check for direct call to frameless continuation
                // These are obfuscated control flow that IDA converted to calls
                if ( ins->l.t == mop_v ) {
                    ea_t call_target = ins->l.g;
                    if ( frameless_continuation_t::is_frameless_continuation(call_target) ) {
                        icall_debug("[indirect_call] Found call to frameless continuation at 0x%llx in block %d\n",
                                    (unsigned long long)call_target, i);
                        return true;
                    }
                }
            }
        }
    }

    // Also check for the ctree pattern:
    // Global table pointer that looks like it's used for indirect calls
    // This is a heuristic based on Hikari's typical naming
    segment_t *seg = get_first_seg();
    while ( seg ) {
        if ( seg->type == SEG_DATA ) {
            ea_t ea = seg->start_ea;
            while ( ea < seg->end_ea ) {
                // Check if this looks like a code pointer table
                uint64_t first_val = 0;
                if ( get_bytes(&first_val, 8, ea) == 8 ) {
                    if ( first_val != 0 && is_code_ea((ea_t)first_val) ) {
                        // This might be a code pointer table
                        // Check if it's referenced in the function
                        xrefblk_t xb;
                        for ( bool ok = xb.first_to(ea, XREF_DATA); ok; ok = xb.next_to() ) {
                            if ( xb.from >= mba->entry_ea ) {
                                func_t *func = get_func(mba->entry_ea);
                                if ( func && xb.from < func->end_ea ) {
                                    icall_debug("[indirect_call] Found code pointer table at 0x%llx referenced from function\n",
                                                (unsigned long long)ea);
                                    return true;
                                }
                            }
                        }
                    }
                }
                ea = next_head(ea, seg->end_ea);
                if ( ea == BADADDR ) 
                    break;
            }
        }
        seg = get_next_seg(seg->start_ea);
    }

    icall_debug("[indirect_call] No indirect call patterns detected\n");
    return false;
}

//--------------------------------------------------------------------------
// Main deobfuscation pass
//--------------------------------------------------------------------------
int indirect_call_handler_t::run(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    icall_debug("[indirect_call] run() called for func 0x%llx, maturity=%d\n",
                (unsigned long long)mba->entry_ea, mba->maturity);

    // We need MMAT_CALLS (4) or later to have mcallinfo for modifying calls
    // At earlier maturities, we just resolve and annotate
    bool can_modify = (mba->maturity >= MMAT_CALLS);
    icall_debug("[indirect_call] can_modify=%d (maturity %d, need %d)\n",
                can_modify, mba->maturity, MMAT_CALLS);

    int total_changes = 0;

    // Find all indirect calls
    auto icalls = find_indirect_calls(mba);
    icall_debug("[indirect_call] Found %zu indirect calls\n", icalls.size());

    for ( auto &ic : icalls ) {
        mblock_t *blk = mba->get_mblock(ic.block_idx);
        if ( !blk ) 
            continue;

        // Try to resolve the call
        if ( ic.is_resolved ) {
            int changes = replace_indirect_call(mba, blk, ic, ctx);
            if ( changes > 0 ) {
                total_changes += changes;
                icall_debug("[indirect_call] Block %d: resolved indirect call to 0x%llx (%s)\n",
                            ic.block_idx, (unsigned long long)ic.resolved_target,
                            ic.target_name.c_str());
            }
        } else {
            // Annotate what we found
            annotate_indirect_call(blk, ic);
            icall_debug("[indirect_call] Block %d: could not resolve, annotated\n", ic.block_idx);
        }
    }

    icall_debug("[indirect_call] Total changes: %d\n", total_changes);
    return total_changes;
}

//--------------------------------------------------------------------------
// Find all indirect calls in the function
//
// NEW APPROACH: Also look for the Hikari pattern directly:
//   1. mov stkvar, &table (global table address to stack)
//   2. ldx from that stkvar with offset (load table[index])
//   3. sub loaded_val, #offset (apply obfuscation offset)
//   4. Eventually used in icall/call
//
// At early maturity, we can extract the pattern before it gets folded.
//--------------------------------------------------------------------------
std::vector<indirect_call_handler_t::indirect_call_t>
indirect_call_handler_t::find_indirect_calls(mbl_array_t *mba)
{
    std::vector<indirect_call_t> result;

    if ( !mba ) 
        return result;

    // First pass: look for explicit icall/call with computed target
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            bool is_indirect = false;

            // Check for icall
            if ( ins->opcode == m_icall ) {
                is_indirect = true;
            }
            // Check for call with computed target
            else if ( ins->opcode == m_call ) {
                if ( ins->l.t == mop_r || ins->l.t == mop_d ) {
                    is_indirect = true;
                }
                // Check for direct call to frameless continuation function
                // These are obfuscated jumps that IDA converted to calls
                else if ( ins->l.t == mop_v ) {
                    ea_t call_target = ins->l.g;
                    if ( frameless_continuation_t::is_frameless_continuation(call_target) ) {
                        icall_debug("[indirect_call] Found call to frameless continuation: 0x%llx\n",
                                    (unsigned long long)call_target);
                        
                        // Build caller context and try to resolve
                        caller_context_t caller_ctx = frameless_continuation_t::build_caller_context(mba, blk);
                        caller_ctx.caller_func = mba->entry_ea;
                        caller_ctx.callee_func = call_target;
                        
                        ea_t final_target = frameless_continuation_t::resolve_continuation_jump(call_target, caller_ctx);
                        
                        if ( is_code_ea(final_target) ) {
                            icall_debug("[indirect_call] Resolved frameless continuation: 0x%llx -> 0x%llx\n",
                                       (unsigned long long)call_target, (unsigned long long)final_target);
                            
                            // Create an indirect_call_t for this resolved call
                            indirect_call_t ic;
                            ic.block_idx = i;
                            ic.call_insn = ins;
                            ic.table_addr = BADADDR;
                            ic.table_index = -1;
                            ic.offset = 0;
                            ic.resolved_target = final_target;
                            ic.is_resolved = true;
                            ic.is_frameless_continuation = true;
                            ic.continuation_target = call_target;
                            
                            // Get name of resolved target
                            qstring name;
                            if ( get_name(&name, final_target) > 0 ) {
                                ic.target_name = name.c_str();
                            }
                            
                            result.push_back(ic);
                            continue;  // Don't fall through to regular handling
                        }
                    }
                }
            }

            if ( is_indirect ) {
                indirect_call_t ic;
                ic.block_idx = i;
                ic.call_insn = ins;
                ic.table_addr = BADADDR;
                ic.table_index = -1;
                ic.offset = 0;
                ic.resolved_target = BADADDR;
                ic.is_resolved = false;

                // Try to analyze and resolve
                if ( analyze_indirect_call(blk, ins, &ic) ) {
                    icall_debug("[indirect_call] Analyzed call in block %d: table=0x%llx, index=%d, offset=%lld\n",
                                i, (unsigned long long)ic.table_addr, ic.table_index, (long long)ic.offset);
                }

                result.push_back(ic);
            }
        }
    }

    // If no icalls found, try to find the Hikari pattern at early maturity
    // Look for: sub reg, ldx_result, #large_offset
    if ( result.empty() ) {
        icall_debug("[indirect_call] No icall found, scanning for Hikari sub pattern...\n");
        icall_debug("[indirect_call] Maturity=%d, num_blocks=%d\n", mba->maturity, mba->qty);
        
        // Dump all subs to see what's there
        for ( int i = 0; i < mba->qty; ++i ) {
            mblock_t *blk = mba->get_mblock(i);
            if ( !blk) continue;
            for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
                if ( ins->opcode == m_sub ) {
                    icall_debug("[indirect_call]   sub at 0x%llx: l.t=%d r.t=%d d.t=%d",
                                (unsigned long long)ins->ea, ins->l.t, ins->r.t, ins->d.t);
                    if ( ins->r.t == mop_n ) 
                        icall_debug(" r=#0x%llx", (unsigned long long)ins->r.nnn->value);
                    icall_debug("\n");
                }
            }
        }
        
        for ( int i = 0; i < mba->qty; ++i ) {
            mblock_t *blk = mba->get_mblock(i);
            if ( !blk) continue;
            
            for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
                // Look for: sub reg, ?, #large_const
                // where large_const looks like an obfuscation offset (> 0x10000)
                if ( ins->opcode == m_sub && ins->r.t == mop_n ) {
                    int64_t offset = ins->r.nnn->value;
                    if ( offset > 0x10000 && offset < 0x1000000 ) {
                        icall_debug("[indirect_call] Found potential offset sub at 0x%llx: offset=%lld\n",
                                    (unsigned long long)ins->ea, (long long)offset);
                        
                        // This might be part of the pattern - create a placeholder
                        indirect_call_t ic;
                        ic.block_idx = i;
                        ic.call_insn = ins;  // Not actually a call, but the sub
                        ic.table_addr = BADADDR;
                        ic.table_index = -1;
                        ic.offset = offset;
                        ic.resolved_target = BADADDR;
                        ic.is_resolved = false;
                        
                        // Try to find table address from mov instructions
                        for ( minsn_t *prev = blk->head; prev != ins; prev = prev->next ) {
                            if ( prev->opcode == m_mov && prev->l.t == mop_a && prev->l.a ) {
                                if ( prev->l.a->t == mop_v ) {
                                    ea_t global = prev->l.a->g;
                                    uint64_t first_entry = 0;
                                    if ( get_bytes(&first_entry, 8, global) == 8 ) {
                                        if ( first_entry != 0 && is_code_ea((ea_t)first_entry) ) {
                                            ic.table_addr = global;
                                            icall_debug("[indirect_call]   Table candidate: 0x%llx\n",
                                                        (unsigned long long)global);
                                        }
                                    }
                                }
                            }
                            // Look for ldx with constant offset
                            if ( prev->opcode == m_ldx && prev->r.t == mop_n ) {
                                ic.table_index = (int)(prev->r.nnn->value / 8);
                                icall_debug("[indirect_call]   Index from ldx: %d\n", ic.table_index);
                            }
                        }
                        
                        // If we have all components, try to resolve
                        if ( ic.table_addr != BADADDR && ic.table_index >= 0 ) {
                            ic.resolved_target = compute_target(ic.table_addr, ic.table_index, ic.offset);
                            if ( ic.resolved_target != BADADDR ) {
                                ic.is_resolved = true;
                                get_name(&ic.target_name, ic.resolved_target);
                                icall_debug("[indirect_call]   RESOLVED: 0x%llx (%s)\n",
                                            (unsigned long long)ic.resolved_target,
                                            ic.target_name.c_str());
                                result.push_back(ic);
                            }
                        }
                    }
                }
            }
        }
    }

    return result;
}

//--------------------------------------------------------------------------
// Analyze an indirect call to extract table/index/offset
//
// We're looking for patterns like:
//   sub reg1, ldx(...), #offset   ; or
//   add reg1, ldx(...), #-offset
// followed by:
//   icall reg1
//
// Or at higher levels:
//   reg1 = table[index] - offset
//   call reg1
//--------------------------------------------------------------------------
bool indirect_call_handler_t::analyze_indirect_call(mblock_t *blk, minsn_t *call_insn,
                                                    indirect_call_t *out)
                                                    {
    if ( !blk || !call_insn || !out ) 
        return false;

    icall_debug("[indirect_call] Analyzing call at ea=0x%llx, opcode=%d\n", 
                (unsigned long long)call_insn->ea, call_insn->opcode);
    icall_debug("[indirect_call]   l.t=%d, r.t=%d, d.t=%d\n", 
                call_insn->l.t, call_insn->r.t, call_insn->d.t);
    if ( call_insn->l.t == mop_r ) {
        icall_debug("[indirect_call]   l.r=%d (target register)\n", call_insn->l.r);
    }
    // Dump all instructions in ALL blocks to find the target computation
    icall_debug("[indirect_call]   Dumping all blocks looking for table reference:\n");
    mbl_array_t *mba_dump = blk->mba;
    for ( int bi = 0; bi < mba_dump->qty; bi++ ) {
        mblock_t *dump_blk = mba_dump->get_mblock(bi);
        if ( !dump_blk) continue;
        icall_debug("[indirect_call]   Block %d:\n", bi);
        for ( minsn_t *ins = dump_blk->head; ins; ins = ins->next ) {
            icall_debug("[indirect_call]     ea=%llx op=%d l.t=%d r.t=%d d.t=%d",
                        (unsigned long long)ins->ea, ins->opcode, ins->l.t, ins->r.t, ins->d.t);
            if ( ins->d.t == mop_r ) 
                icall_debug(" -> reg%d", ins->d.r);
            if ( ins->d.t == mop_f ) 
                icall_debug(" -> stkvar");
            if ( ins->l.t == mop_r ) 
                icall_debug(" from reg%d", ins->l.r);
            if ( ins->l.t == mop_n ) 
                icall_debug(" from #0x%llx", (unsigned long long)ins->l.nnn->value);
            if ( ins->l.t == mop_v ) 
                icall_debug(" from global 0x%llx", (unsigned long long)ins->l.g);
            if ( ins->l.t == mop_a && ins->l.a ) {
                icall_debug(" from &");
                if ( ins->l.a->t == mop_v ) 
                    icall_debug("global 0x%llx", (unsigned long long)ins->l.a->g);
                else
                    icall_debug("(type %d)", ins->l.a->t);
            }
            if ( ins->r.t == mop_a && ins->r.a ) {
                icall_debug(" r=&");
                if ( ins->r.a->t == mop_v ) 
                    icall_debug("global 0x%llx", (unsigned long long)ins->r.a->g);
            }
            // For ldx, the base address comes from r operand
            if ( ins->opcode == m_ldx ) {
                icall_debug(" [ldx: base.t=%d, idx.t=%d]", ins->l.t, ins->r.t);
            }
            // Check for sub instruction with table pattern
            if ( ins->opcode == m_sub || ins->opcode == m_ldx ) {
                icall_debug(" [INTERESTING]");
            }
            icall_debug("\n");
        }
    }

    // For m_icall, the structure depends on maturity level
    // At early maturity: icall l_operand (target in l)
    // At later maturity: might be different
    // 
    // Let's check all operands to understand the structure
    mop_t *target_op = nullptr;
    
    if ( call_insn->opcode == m_icall ) {
        // m_icall: target address is typically in l operand
        if ( call_insn->l.t != mop_z ) {
            target_op = &call_insn->l;
            icall_debug("[indirect_call]   Using l operand (type %d)\n", call_insn->l.t);
        } else if ( call_insn->d.t != mop_z ) {
            target_op = &call_insn->d;
            icall_debug("[indirect_call]   Using d operand (type %d)\n", call_insn->d.t);
        }
    } else if ( call_insn->opcode == m_call ) {
        if ( call_insn->l.t == mop_d || call_insn->l.t == mop_r ) {
            target_op = &call_insn->l;
            icall_debug("[indirect_call]   Using call l operand (type %d)\n", call_insn->l.t);
        }
    }

    if ( !target_op ) {
        icall_debug("[indirect_call]   No target operand found (all types: l=%d, r=%d, d=%d)\n",
                    call_insn->l.t, call_insn->r.t, call_insn->d.t);
        return false;
    }

    icall_debug("[indirect_call]   Target operand type: %d\n", target_op->t);

    // Trace back to find the computation
    ea_t table_addr = BADADDR;
    int table_index = -1;
    int64_t offset = 0;

    if ( trace_call_target(blk, call_insn, &table_addr, &table_index, &offset) ) {
        out->table_addr = table_addr;
        out->table_index = table_index;
        out->offset = offset;

        icall_debug("[indirect_call]   Traced: table=0x%llx, index=%d, offset=%lld\n",
                    (unsigned long long)table_addr, table_index, (long long)offset);

        // If we have a constant index, resolve the target
        if ( table_addr != BADADDR && table_index >= 0 ) {
            out->resolved_target = compute_target(table_addr, table_index, offset);
            if ( out->resolved_target != BADADDR ) {
                out->is_resolved = true;
                get_name(&out->target_name, out->resolved_target);
                icall_debug("[indirect_call]   Resolved to 0x%llx (%s)\n",
                            (unsigned long long)out->resolved_target,
                            out->target_name.c_str());
            }
        }

        return true;
    }

    icall_debug("[indirect_call]   Could not trace call target\n");
    return false;
}

//--------------------------------------------------------------------------
// XOR key extraction info - tracks XOR operations with global variables
//--------------------------------------------------------------------------
struct xor_key_info_t {
    ea_t global_addr;           // Address of global variable
    uint64_t immediate;         // Immediate value XOR'd with global
    uint64_t global_value;      // Value read from global at analysis time
    uint64_t result;            // immediate XOR global_value
    mreg_t dest_reg;            // Destination register
    bool has_neg;               // Whether result is negated
    bool valid;                 // Whether we successfully resolved this
    
    xor_key_info_t() : global_addr(BADADDR), immediate(0), global_value(0),
                       result(0), dest_reg(mr_none), has_neg(false), valid(false) {}
};

//--------------------------------------------------------------------------
// Read a value from a global variable
//--------------------------------------------------------------------------
static bool read_global_value(ea_t addr, uint64_t *out, int size = 4)
{
    if ( addr == BADADDR || !out ) 
        return false;
    
    *out = 0;
    if ( get_bytes(out, size, addr) != size ) 
        return false;
    
    // Sign extend for 32-bit values
    if ( size == 4 ) {
        int32_t signed_val = (int32_t)*out;
        *out = (uint64_t)(int64_t)signed_val;
    }
    
    return true;
}

//--------------------------------------------------------------------------
// Find XOR patterns with global variables in microcode
// Tracks data flow: load from global -> XOR with immediate
//--------------------------------------------------------------------------
static std::vector<xor_key_info_t> find_xor_with_globals(mbl_array_t *mba)
{
    std::vector<xor_key_info_t> results;
    
    if ( !mba ) 
        return results;
    
    // Track register values for data flow
    std::map<mreg_t, uint64_t> reg_immediates;  // reg -> immediate value
    std::map<mreg_t, ea_t> reg_globals;         // reg -> global address
    
    for ( int bi = 0; bi < mba->qty; bi++ ) {
        mblock_t *blk = mba->get_mblock(bi);
        if ( !blk) continue;
        
        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            // Track mov of immediate to register
            if ( ins->opcode == m_mov && ins->d.t == mop_r ) {
                if ( ins->l.t == mop_n ) {
                    reg_immediates[ins->d.r] = ins->l.nnn->value;
                    icall_debug("[indirect_call]     Tracking: reg%d = 0x%llx (imm)\n",
                                ins->d.r, (unsigned long long)ins->l.nnn->value);
                } else if ( ins->l.t == mop_v ) {
                    // Loading from global
                    reg_globals[ins->d.r] = ins->l.g;
                    icall_debug("[indirect_call]     Tracking: reg%d = [0x%llx] (global)\n",
                                ins->d.r, (unsigned long long)ins->l.g);
                }
            }
            
            // Track ldx (load) from global
            if ( ins->opcode == m_ldx && ins->d.t == mop_r ) {
                if ( ins->r.t == mop_v ) {
                    reg_globals[ins->d.r] = ins->r.g;
                    icall_debug("[indirect_call]     Tracking: reg%d = ldx [0x%llx]\n",
                                ins->d.r, (unsigned long long)ins->r.g);
                } else if ( ins->l.t == mop_v ) {
                    reg_globals[ins->d.r] = ins->l.g;
                    icall_debug("[indirect_call]     Tracking: reg%d = ldx [0x%llx] (from l)\n",
                                ins->d.r, (unsigned long long)ins->l.g);
                }
            }
            
            // Look for XOR patterns
            if ( ins->opcode == m_xor && ins->d.t == mop_r ) {
                xor_key_info_t info;
                info.dest_reg = ins->d.r;
                
                // Pattern 1: xor reg_with_global, #imm
                // Pattern 2: xor #imm, reg_with_global
                // Pattern 3: xor reg1, reg2 where one is from global
                
                if ( ins->l.t == mop_n && ins->r.t == mop_v ) {
                    // xor #imm, global
                    info.immediate = ins->l.nnn->value;
                    info.global_addr = ins->r.g;
                } else if ( ins->r.t == mop_n && ins->l.t == mop_v ) {
                    // xor global, #imm
                    info.immediate = ins->r.nnn->value;
                    info.global_addr = ins->l.g;
                } else if ( ins->l.t == mop_r && ins->r.t == mop_n ) {
                    // xor reg, #imm - check if reg was loaded from global
                    if ( reg_globals.count(ins->l.r) ) {
                        info.global_addr = reg_globals[ins->l.r];
                        info.immediate = ins->r.nnn->value;
                    }
                } else if ( ins->r.t == mop_r && ins->l.t == mop_n ) {
                    // xor #imm, reg
                    if ( reg_globals.count(ins->r.r) ) {
                        info.global_addr = reg_globals[ins->r.r];
                        info.immediate = ins->l.nnn->value;
                    }
                } else if ( ins->l.t == mop_r && ins->r.t == mop_r ) {
                    // xor reg1, reg2 - one might be immediate, other global
                    if ( reg_immediates.count(ins->l.r) && reg_globals.count(ins->r.r) ) {
                        info.immediate = reg_immediates[ins->l.r];
                        info.global_addr = reg_globals[ins->r.r];
                    } else if ( reg_immediates.count(ins->r.r) && reg_globals.count(ins->l.r) ) {
                        info.immediate = reg_immediates[ins->r.r];
                        info.global_addr = reg_globals[ins->l.r];
                    }
                }
                
                // If we found a valid XOR with global, read the global value
                if ( info.global_addr != BADADDR ) {
                    uint64_t gval = 0;
                    if ( read_global_value(info.global_addr, &gval, 4) ) {
                        info.global_value = gval;
                        info.result = info.immediate ^ info.global_value;
                        info.valid = true;
                        
                        icall_debug("[indirect_call]     XOR: 0x%llx ^ [0x%llx]=0x%llx -> 0x%llx\n",
                                   (unsigned long long)info.immediate,
                                   (unsigned long long)info.global_addr,
                                   (unsigned long long)info.global_value,
                                   (unsigned long long)info.result);
                        
                        results.push_back(info);
                    }
                }
                
                // Update register tracking for the result
                reg_immediates.erase(ins->d.r);
                reg_globals.erase(ins->d.r);
            }
            
            // Track NEG operations (negate result)
            if ( ins->opcode == m_neg && ins->d.t == mop_r ) {
                // Find if this negates a previous XOR result
                for ( auto &xinfo : results ) {
                    if ( xinfo.dest_reg == ins->l.r || xinfo.dest_reg == ins->d.r ) {
                        xinfo.has_neg = true;
                        xinfo.result = (uint64_t)(-(int64_t)xinfo.result);
                        xinfo.dest_reg = ins->d.r;
                        icall_debug("[indirect_call]     NEG: result = %lld\n",
                                   (long long)(int64_t)xinfo.result);
                    }
                }
            }
            
            // Clear register tracking on other writes
            if ( ins->d.t == mop_r && ins->opcode != m_xor && ins->opcode != m_neg ) {
                if ( ins->opcode != m_mov || (ins->l.t != mop_n && ins->l.t != mop_v) ) {
                    reg_immediates.erase(ins->d.r);
                    reg_globals.erase(ins->d.r);
                }
            }
        }
    }
    
    return results;
}

//--------------------------------------------------------------------------
// Binary-level pattern scanner for Hikari IndirectCall
// Scans x86-64 bytes directly to find XOR patterns before IDA optimizes them
//
// Pattern we're looking for in the caller:
//   mov  rax, [rbp+var_XXX]      ; Load table pointer  
//   movsxd rdx, dword [global1]  ; Load index source
//   xor  rdx, CONST1             ; Compute index
//   mov  esi, CONST2             
//   xor  esi, dword [global2]    ; Compute offset source
//   neg  esi                     ; Negate
//   movsxd rsi, esi              ; Sign extend
//   add  rsi, [rax+rdx*8]        ; target = table[index*8] + offset
//   jmp  [rbp+var_YYY]           ; Indirect jump
//--------------------------------------------------------------------------
struct hikari_pattern_t {
    ea_t table_ptr_global;      // Global holding table pointer (e.g., off_10064C180)
    ea_t index_global;          // Global for index computation
    uint32_t index_xor_const;   // XOR constant for index
    ea_t offset_global;         // Global for offset computation  
    uint32_t offset_xor_const;  // XOR constant for offset
    bool has_neg;               // Whether offset is negated
    bool valid;
    
    hikari_pattern_t() : table_ptr_global(BADADDR), index_global(BADADDR),
                          index_xor_const(0), offset_global(BADADDR),
                          offset_xor_const(0), has_neg(false), valid(false) {}
};

static hikari_pattern_t scan_binary_for_pattern(ea_t func_start, ea_t func_end) {
    hikari_pattern_t result;
    
    // Scan for XOR with 32-bit immediate: 81 F? XX XX XX XX (xor r32, imm32)
    // or 35 XX XX XX XX (xor eax, imm32)
    insn_t insn;
    ea_t ea = func_start;
    
    std::vector<std::pair<ea_t, uint32_t>> xor_immediates;  // ea -> xor constant
    std::vector<ea_t> neg_locations;
    ea_t table_lea = BADADDR;
    
    while ( ea < func_end ) {
        if ( decode_insn(&insn, ea) == 0 ) 
            break;
        
        // Look for LEA with global (table pointer)
        // Pattern: 48 8D 0D XX XX XX XX (lea rcx, [rip+disp])
        uint8_t b0 = get_byte(ea);
        uint8_t b1 = get_byte(ea + 1);
        uint8_t b2 = get_byte(ea + 2);
        
        if ( b0 == 0x48 && b1 == 0x8D ) {
            // Might be LEA r64, [rip+disp32]
            uint8_t modrm = b2;
            if ( (modrm & 0xC7) == 0x05 ) {  // RIP-relative
                int32_t disp = get_dword(ea + 3);
                ea_t target = ea + 7 + disp;
                // Check if it's a pointer to code
                uint64_t ptr_val = 0;
                if ( get_bytes(&ptr_val, 8, target) == 8 ) {
                    if ( ptr_val != 0 && is_code_ea((ea_t)ptr_val) ) {
                        table_lea = target;
                        icall_debug("[indirect_call] Binary scan: found table LEA at 0x%llx -> 0x%llx\n",
                                   (unsigned long long)ea, (unsigned long long)target);
                    }
                }
            }
        }
        
        // Look for XOR with immediate: 81 F1 XX XX XX XX (xor ecx, imm32)
        // or 35 XX XX XX XX (xor eax, imm32)
        if ( b0 == 0x81 && (b1 & 0xF8) == 0xF0 ) {
            // xor r32, imm32
            uint32_t imm = get_dword(ea + 2);
            xor_immediates.push_back({ea, imm});
            icall_debug("[indirect_call] Binary scan: XOR at 0x%llx with 0x%x\n",
                       (unsigned long long)ea, imm);
        }
        if ( b0 == 0x35 ) {
            // xor eax, imm32
            uint32_t imm = get_dword(ea + 1);
            xor_immediates.push_back({ea, imm});
            icall_debug("[indirect_call] Binary scan: XOR EAX at 0x%llx with 0x%x\n",
                       (unsigned long long)ea, imm);
        }
        // 48 35 is xor rax, imm32 (sign-extended)
        if ( b0 == 0x48 && b1 == 0x35 ) {
            uint32_t imm = get_dword(ea + 2);
            xor_immediates.push_back({ea, imm});
            icall_debug("[indirect_call] Binary scan: XOR RAX at 0x%llx with 0x%x\n",
                       (unsigned long long)ea, imm);
        }
        
        // Look for NEG: F7 D8-DF (neg r32)
        if ( b0 == 0xF7 && (b1 & 0xF8) == 0xD8 ) {
            neg_locations.push_back(ea);
            icall_debug("[indirect_call] Binary scan: NEG at 0x%llx\n",
                       (unsigned long long)ea);
        }
        
        // Look for global loads: 8B 0D XX XX XX XX (mov ecx, [rip+disp])
        if ( b0 == 0x8B && (b1 & 0xC7) == 0x05 ) {
            int32_t disp = get_dword(ea + 2);
            ea_t global = ea + 6 + disp;
            icall_debug("[indirect_call] Binary scan: MOV from global 0x%llx at 0x%llx\n",
                       (unsigned long long)global, (unsigned long long)ea);
        }
        
        ea = get_item_end(ea);
    }
    
    // If we found XORs, try to resolve them
    if ( xor_immediates.size() >= 1 && table_lea != BADADDR ) {
        result.table_ptr_global = table_lea;
        result.valid = true;
        
        // First XOR is typically the index, second is offset
        if ( xor_immediates.size() >= 1 ) {
            result.index_xor_const = xor_immediates[0].second;
        }
        if ( xor_immediates.size() >= 2 ) {
            result.offset_xor_const = xor_immediates[1].second;
            result.has_neg = !neg_locations.empty();
        }
        
        icall_debug("[indirect_call] Binary scan: table=0x%llx, idx_xor=0x%x, off_xor=0x%x, neg=%d\n",
                   (unsigned long long)result.table_ptr_global,
                   result.index_xor_const, result.offset_xor_const, result.has_neg);
    }
    
    return result;
}

//--------------------------------------------------------------------------
// Trace the call target computation backwards
//
// Handle Hikari's XOR-based index/offset computation:
// Uses both microcode analysis AND binary pattern scanning
//
// KEY INSIGHT: IDA often folds XOR operations into constants by the time 
// we see them in microcode. So we need to:
// 1. Track immediate values being moved to registers/stack
// 2. Find where those values are used in table load calculations
// 3. Trace the ADD/MUL pattern: base + index*8 to find the index
//--------------------------------------------------------------------------
bool indirect_call_handler_t::trace_call_target(mblock_t *blk, minsn_t *call_insn,
                                                ea_t *out_table, int *out_index,
                                                int64_t *out_offset)
                                                {
    if ( !blk || !call_insn || !blk->mba ) 
        return false;

    *out_table = BADADDR;
    *out_index = -1;
    *out_offset = 0;

    mbl_array_t *mba = blk->mba;

    icall_debug("[indirect_call]   trace_call_target: starting enhanced analysis\n");

    // Track register/stack values (for already-computed XOR results)
    std::map<mreg_t, int64_t> reg_values;           // reg -> immediate value
    std::map<int64_t, int64_t> stkvar_values;       // stack offset -> value
    std::vector<ea_t> tables;
    int64_t resolved_offset = 0;
    int resolved_index = -1;
    
    // Pass 1: Collect all relevant information from microcode
    for ( int bi = 0; bi < mba->qty; bi++ ) {
        mblock_t *scan_blk = mba->get_mblock(bi);
        if ( !scan_blk) continue;
        
        for ( minsn_t *ins = scan_blk->head; ins; ins = ins->next ) {
            // Track mov of immediate to register
            if ( ins->opcode == m_mov && ins->d.t == mop_r && ins->l.t == mop_n ) {
                reg_values[ins->d.r] = ins->l.nnn->value;
            }
            
            // Track mov of immediate to stack variable
            if ( ins->opcode == m_mov && ins->d.t == mop_S && ins->l.t == mop_n ) {
                stkvar_values[ins->d.s->off] = ins->l.nnn->value;
                icall_debug("[indirect_call]     Tracking stkvar[%lld] = 0x%llx\n",
                            (long long)ins->d.s->off, (unsigned long long)ins->l.nnn->value);
            }
            
            // Track mov of register to stack
            if ( ins->opcode == m_mov && ins->d.t == mop_S && ins->l.t == mop_r ) {
                if ( reg_values.count(ins->l.r) ) {
                    stkvar_values[ins->d.s->off] = reg_values[ins->l.r];
                    icall_debug("[indirect_call]     Tracking stkvar[%lld] = reg%d = 0x%llx\n",
                                (long long)ins->d.s->off, ins->l.r,
                                (unsigned long long)reg_values[ins->l.r]);
                }
            }
            
            // Look for: mov stkvar, &global_table
            if ( ins->opcode == m_mov && ins->l.t == mop_a && ins->l.a ) {
                if ( ins->l.a->t == mop_v ) {
                    ea_t global = ins->l.a->g;
                    uint64_t first_entry = 0;
                    if ( get_bytes(&first_entry, 8, global) == 8 ) {
                        if ( first_entry != 0 && is_code_ea((ea_t)first_entry) ) {
                            tables.push_back(global);
                            icall_debug("[indirect_call]     Found table: 0x%llx (first_entry=0x%llx)\n",
                                        (unsigned long long)global, (unsigned long long)first_entry);
                        }
                    }
                }
            }
            
            // Look for ldx - the table load operation
            // Pattern: ldx dest, base_reg, offset_operand
            // The offset might be: register (computed index*8), stack var, or immediate
            if ( ins->opcode == m_ldx ) {
                icall_debug("[indirect_call]     ldx at 0x%llx: base.t=%d, idx.t=%d\n",
                            (unsigned long long)ins->ea, ins->l.t, ins->r.t);
                
                // If the offset/index operand is a stack variable
                if ( ins->r.t == mop_S ) {
                    int64_t stk_off = ins->r.s->off;
                    if ( stkvar_values.count(stk_off) ) {
                        int64_t idx_val = stkvar_values[stk_off];
                        // The value might be index*8, so divide by 8
                        if ( idx_val % 8 == 0 && idx_val > 0 && idx_val < 100000 ) {
                            resolved_index = (int)(idx_val / 8);
                            icall_debug("[indirect_call]     Index from stkvar[%lld] = %lld -> idx=%d\n",
                                        (long long)stk_off, (long long)idx_val, resolved_index);
                        }
                    }
                }
                
                // If the offset is a register
                if ( ins->r.t == mop_r ) {
                    if ( reg_values.count(ins->r.r) ) {
                        int64_t idx_val = reg_values[ins->r.r];
                        if ( idx_val % 8 == 0 && idx_val > 0 && idx_val < 100000 ) {
                            resolved_index = (int)(idx_val / 8);
                            icall_debug("[indirect_call]     Index from reg%d = %lld -> idx=%d\n",
                                        ins->r.r, (long long)idx_val, resolved_index);
                        }
                    }
                }
                
                // If the offset is a constant
                if ( ins->r.t == mop_n ) {
                    int64_t idx_val = ins->r.nnn->value;
                    if ( idx_val % 8 == 0 && idx_val >= 0 ) {
                        resolved_index = (int)(idx_val / 8);
                        icall_debug("[indirect_call]     Index from immediate = %lld -> idx=%d\n",
                                    (long long)idx_val, resolved_index);
                    }
                }
            }
            
            // Look for sub operations (offset computation)
            if ( ins->opcode == m_sub && ins->r.t == mop_n ) {
                int64_t sub_val = ins->r.nnn->value;
                if ( sub_val > resolved_offset && sub_val > 0x1000 ) {
                    resolved_offset = sub_val;
                    icall_debug("[indirect_call]     Found sub offset: %lld\n", (long long)sub_val);
                }
            }
            
            // Look for ADD patterns that might contain index*8
            // Pattern: add dest, base, mul(index, 8)
            if ( ins->opcode == m_add ) {
                // Check if one operand is a multiplication by 8
                auto check_mul8 = [&](const mop_t &op) -> int {
                    if ( op.t == mop_d && op.d && op.d->opcode == m_mul ) {
                        minsn_t *mul = op.d;
                        if ( mul->r.t == mop_n && mul->r.nnn->value == 8 ) {
                            // Left operand of mul is the index
                            if ( mul->l.t == mop_n ) {
                                return (int)mul->l.nnn->value;
                            }
                            if ( mul->l.t == mop_r && reg_values.count(mul->l.r) ) {
                                return (int)reg_values[mul->l.r];
                            }
                        }
                        if ( mul->l.t == mop_n && mul->l.nnn->value == 8 ) {
                            if ( mul->r.t == mop_n ) {
                                return (int)mul->r.nnn->value;
                            }
                            if ( mul->r.t == mop_r && reg_values.count(mul->r.r) ) {
                                return (int)reg_values[mul->r.r];
                            }
                        }
                    }
                    return -1;
                };
                
                int idx = check_mul8(ins->l);
                if ( idx < 0) idx = check_mul8(ins->r);
                if ( idx >= 0 && idx < 10000 ) {
                    resolved_index = idx;
                    icall_debug("[indirect_call]     Index from add+mul pattern: %d\n", resolved_index);
                }
            }
        }
    }
    
    // NEW: Look for the computed index directly
    // When IDA folds XORs, we see patterns like:
    //   mov reg, #0x29c  (this is the already-computed index = 668)
    //   ... later used to compute table[index*8]
    // We can identify the index by looking for small constants that could be indices
    // and correlating with the table access pattern
    if ( resolved_index < 0 && !tables.empty() ) {
        icall_debug("[indirect_call]     Looking for pre-computed index constants...\n");
        
        // Collect all small immediate values that could be indices
        std::vector<std::pair<int64_t, ea_t>> candidate_indices;  // value, ea
        
        for ( int bi = 0; bi < mba->qty; bi++ ) {
            mblock_t *scan_blk = mba->get_mblock(bi);
            if ( !scan_blk) continue;
            
            for ( minsn_t *ins = scan_blk->head; ins; ins = ins->next ) {
                if ( ins->opcode == m_mov && ins->l.t == mop_n ) {
                    int64_t val = ins->l.nnn->value;
                    // Reasonable index range: 0 to ~10000
                    if ( val > 0 && val < 10000 ) {
                        candidate_indices.push_back({val, ins->ea});
                        icall_debug("[indirect_call]       Candidate index: %lld at 0x%llx\n",
                                    (long long)val, (unsigned long long)ins->ea);
                    }
                }
            }
        }
        
        // Validate each candidate by checking if table[idx] - offset makes sense
        ea_t table_addr = tables[0];
        for ( const auto &[idx_val, ea] : candidate_indices ) {
            // Read table[idx]
            ea_t entry_addr = table_addr + idx_val * 8;
            uint64_t entry_val = 0;
            if ( get_bytes(&entry_val, 8, entry_addr) == 8 ) {
                ea_t target = (ea_t)(entry_val - resolved_offset);
                // Check if result is valid code
                if ( is_code_ea(target) || get_func_safe(target) != nullptr ) {
                    resolved_index = (int)idx_val;
                    icall_debug("[indirect_call]       VALIDATED index %lld: table[%lld]=0x%llx, -offset=0x%llx (valid code)\n",
                                (long long)idx_val, (long long)idx_val,
                                (unsigned long long)entry_val, (unsigned long long)target);
                    break;
                }
            }
        }
    }
    
    // Use enhanced XOR pattern detection with data flow tracking (legacy fallback)
    if ( resolved_index < 0 ) {
        auto xor_results = find_xor_with_globals(mba);
        icall_debug("[indirect_call]     Found %zu XOR patterns with globals\n", xor_results.size());
        
        for ( const auto &xr : xor_results ) {
            if ( !xr.valid) continue;
            
            if ( xr.has_neg && resolved_offset == 0 ) {
                resolved_offset = (int64_t)xr.result;
                icall_debug("[indirect_call]     Using as OFFSET: %lld\n", (long long)resolved_offset);
            } else {
                int64_t result = (int64_t)xr.result;
                if ( result >= 0 && result < 10000 && resolved_index < 0 ) {
                    resolved_index = (int)result;
                    icall_debug("[indirect_call]     Using as INDEX: %d\n", resolved_index);
                }
            }
        }
    }
    
    ea_t table_addr = tables.empty() ? BADADDR : tables[0];
    
    if ( table_addr != BADADDR && resolved_index >= 0 ) {
        *out_table = table_addr;
        *out_index = resolved_index;
        *out_offset = resolved_offset;
        icall_debug("[indirect_call]     SUCCESS: table=0x%llx, index=%d, offset=%lld\n",
                    (unsigned long long)table_addr, resolved_index, (long long)resolved_offset);
        return true;
    }
    
    icall_debug("[indirect_call]     Pattern incomplete: table=%llx, index=%d, offset=%lld\n",
                (unsigned long long)table_addr, resolved_index, (long long)resolved_offset);
    return false;
}

//--------------------------------------------------------------------------
// Find table base address from operand
//--------------------------------------------------------------------------
ea_t indirect_call_handler_t::find_table_base(mblock_t *blk, const mop_t &op)
{
    if ( op.t == mop_v ) {
        return op.g;
    }
    if ( op.t == mop_a && op.a && op.a->t == mop_v ) {
        return op.a->g;
    }
    // Could trace through more complex expressions...
    return BADADDR;
}

//--------------------------------------------------------------------------
// Extract constant index from operand
//--------------------------------------------------------------------------
bool indirect_call_handler_t::extract_constant_index(mblock_t *blk, const mop_t &op,
                                                     int *out_index)
                                                     {
    if ( op.t == mop_n ) {
        *out_index = (int)(op.nnn->value / 8);  // Assume 8-byte entries
        return true;
    }
    return false;
}

//--------------------------------------------------------------------------
// Read target from table and apply offset
//--------------------------------------------------------------------------
ea_t indirect_call_handler_t::compute_target(ea_t table_addr, int index, int64_t offset)
{
    if ( table_addr == BADADDR || index < 0 ) 
        return BADADDR;

    ea_t entry_addr = table_addr + index * 8;  // 64-bit entries
    uint64_t entry_val = 0;

    if ( get_bytes(&entry_val, 8, entry_addr) != 8 ) {
        icall_debug("[indirect_call]   Failed to read table entry at 0x%llx\n",
                    (unsigned long long)entry_addr);
        return BADADDR;
    }

    ea_t target = (ea_t)(entry_val - offset);

    icall_debug("[indirect_call]   table[%d] = 0x%llx, - %lld = 0x%llx\n",
                index, (unsigned long long)entry_val, (long long)offset,
                (unsigned long long)target);

    // Validate target is code
    if ( is_code_ea(target) ) {
        return target;
    }

    // Might still be valid if within function bounds
    func_t *func = get_func_safe(target);
    if ( func ) {
        return target;
    }

    icall_debug("[indirect_call]   Target 0x%llx is not code\n", (unsigned long long)target);
    return BADADDR;
}

//--------------------------------------------------------------------------
// Replace indirect call with direct call
//
// Converting m_icall to m_call:
// - m_icall: l = computed target address, d = mcallinfo_t
// - m_call:  l = direct function address (mop_v), d = mcallinfo_t
//
// IMPORTANT: Only replace if target is a valid function entry point.
// If not, just annotate - modifying calls to non-function addresses crashes.
//--------------------------------------------------------------------------
int indirect_call_handler_t::replace_indirect_call(mbl_array_t *mba, mblock_t *blk,
                                                   indirect_call_t &ic, deobf_ctx_t *ctx)
                                                   {
    if ( !mba || !blk || !ic.call_insn || !ic.is_resolved ) 
        return 0;

    icall_debug("[indirect_call] Attempting to replace call in block %d with direct call to 0x%llx\n",
                ic.block_idx, (unsigned long long)ic.resolved_target);
    icall_debug("[indirect_call]   Original opcode: %d, l.t=%d, r.t=%d, d.t=%d\n",
                ic.call_insn->opcode, ic.call_insn->l.t, 
                ic.call_insn->r.t, ic.call_insn->d.t);

    // Check if the target is a valid function entry point
    // If not, we risk crashing IDA with INTERR 50822
    if ( !is_valid_database_ea(ic.resolved_target) ) {
        icall_debug("[indirect_call]   Target 0x%llx is outside database EA range, skipping replacement\n",
                    (unsigned long long)ic.resolved_target);
        return 0;
    }

    func_t *target_func = get_func_safe(ic.resolved_target);
    bool is_func_start = (target_func && target_func->start_ea == ic.resolved_target);
    
    // Also check if it might be an external/import
    flags64_t flags = get_flags_safe(ic.resolved_target);
    bool is_extern = has_any_name(flags) && !is_code(flags);
    
    icall_debug("[indirect_call]   Target check: is_func=%d, is_func_start=%d, is_extern=%d\n",
                (target_func != nullptr), is_func_start, is_extern);

    // If target is not a proper function start, just annotate and return
    // This avoids INTERR 50822 crash
    if ( !is_func_start && !is_extern ) {
        icall_debug("[indirect_call]   Target is NOT a function start - skipping replacement to avoid crash\n");
        
        // Try to create a function at the target
        if ( !target_func && is_code(flags) ) {
            icall_debug("[indirect_call]   Attempting to create function at target...\n");
            if ( add_func(ic.resolved_target) ) {
                target_func = get_func_safe(ic.resolved_target);
                is_func_start = (target_func && target_func->start_ea == ic.resolved_target);
                icall_debug("[indirect_call]   Created function: is_func_start=%d\n", is_func_start);
            } else {
                icall_debug("[indirect_call]   Failed to create function\n");
            }
        }
        
        // If still not a function start, just add a comment
        if ( !is_func_start ) {
            qstring comment;
            comment.sprnt("DEOBF: Resolved indirect call -> 0x%llX (not a function start, not replaced)",
                          (unsigned long long)ic.resolved_target);
            set_cmt(ic.call_insn->ea, comment.c_str(), false);
            return 0;
        }
    }

    minsn_t *call = ic.call_insn;

    icall_debug("[indirect_call]   Before modification: opcode=%d, l.t=%d, r.t=%d, d.t=%d\n",
                call->opcode, call->l.t, call->r.t, call->d.t);

    // For m_icall, we want to replace the computed target with the resolved constant
    // 
    // Two approaches depending on whether mcallinfo is present:
    // 1. Unknown call (d.empty()): Keep m_icall, just set l to constant
    // 2. Known call (d has mcallinfo): Can convert to m_call
    
    bool is_unknown = call->d.empty();
    icall_debug("[indirect_call]   is_unknown_call=%d (d.t=%d)\n", is_unknown, call->d.t);
    
    if ( call->opcode == m_icall ) {
        // Strategy depends on whether mcallinfo exists:
        // 
        // If mcallinfo exists (d.t == mop_f): We can safely convert to m_call
        // and just update the callee address - arguments are preserved.
        //
        // If unknown call (d.empty()): We need to create mcallinfo ourselves,
        // copying any argument information from the r operand if present.
        
        if ( !is_unknown && call->d.t == mop_f && call->d.f != nullptr ) {
            // Has mcallinfo - can do full conversion to m_call
            icall_debug("[indirect_call]   Converting m_icall to m_call (has mcallinfo)\n");
            
            mcallinfo_t *mci = call->d.f;
            mci->callee = ic.resolved_target;
            
            // Try to get function type for better decompilation
            tinfo_t func_type;
            if ( get_tinfo(&func_type, ic.resolved_target) ) {
                mci->set_type(func_type);
                icall_debug("[indirect_call]   Set function type from database\n");
            }
            
            // Clear and set l to resolved target
            call->l.erase();
            call->l.t = mop_v;
            call->l.g = ic.resolved_target;
            call->l.size = NOSIZE;
            
            // m_call requires r to be empty
            call->r.erase();
            
            // Convert opcode
            call->opcode = m_call;
            
            icall_debug("[indirect_call]   Converted to m_call with preserved args\n");
        } else {
            // Unknown call - create mcallinfo and convert to m_call
            // We need to create a proper mcallinfo to get clean decompilation
            icall_debug("[indirect_call]   Converting unknown m_icall to m_call\n");
            
            // Create new mcallinfo
            mcallinfo_t *mci = new mcallinfo_t(ic.resolved_target, 0);
            mci->cc = CM_CC_FASTCALL;
            
            // Try to get function type - this will give us proper args/return
            tinfo_t func_type;
            if ( get_tinfo(&func_type, ic.resolved_target) ) {
                mci->set_type(func_type);
                icall_debug("[indirect_call]   Set function type from target\n");
            } else {
                // No type info - set void return 
                mci->return_type.create_simple_type(BT_VOID);
            }
            
            // Set the mcallinfo
            call->d.erase();
            call->d.t = mop_f;
            call->d.f = mci;
            call->d.size = 0;  // Void return
            
            // Clear and set l to resolved target
            call->l.erase();
            call->l.t = mop_v;
            call->l.g = ic.resolved_target;
            call->l.size = NOSIZE;
            
            // m_call requires r to be empty
            call->r.erase();
            
            // Convert opcode
            call->opcode = m_call;
            
            icall_debug("[indirect_call]   Converted to m_call, target=0x%llx\n",
                        (unsigned long long)ic.resolved_target);
        }
                    
    } else if ( call->opcode == m_call ) {
        // Already m_call, just update target
        if ( call->d.t == mop_f && call->d.f != nullptr ) {
            call->d.f->callee = ic.resolved_target;
        }
        call->l.erase();
        call->l.t = mop_v;
        call->l.g = ic.resolved_target;
        call->l.size = 0;
        
        icall_debug("[indirect_call]   Updated m_call target to 0x%llx\n",
                    (unsigned long long)ic.resolved_target);
    }

    // Verify the instruction looks correct
    icall_debug("[indirect_call]   After: opcode=%d, l.t=%d, l.g=0x%llx, l.size=%d, r.t=%d, d.t=%d\n",
                call->opcode, call->l.t, (unsigned long long)call->l.g, call->l.size,
                call->r.t, call->d.t);

    // Mark the block as modified
    blk->mark_lists_dirty();
    blk->mba->mark_chains_dirty();

    // Add comment to the original address
    qstring comment;
    qstring target_name;
    get_name(&target_name, ic.resolved_target);
    comment.sprnt("DEOBF: Resolved indirect call -> %s (0x%llX)",
                  target_name.empty() ? "?" : target_name.c_str(),
                  (unsigned long long)ic.resolved_target);
    set_cmt(call->ea, comment.c_str(), false);

    if ( ctx ) 
        ctx->indirect_resolved++;

    return 1;
}

//--------------------------------------------------------------------------
// Annotate unresolved indirect call
//--------------------------------------------------------------------------
void indirect_call_handler_t::annotate_indirect_call(mblock_t *blk, const indirect_call_t &ic)
{
    if ( !blk || !ic.call_insn ) 
        return;

    qstring comment;
    comment.sprnt("DEOBF: Indirect call (unresolved)");
    if ( ic.table_addr != BADADDR ) {
        comment.cat_sprnt("\n  Table: 0x%llX", (unsigned long long)ic.table_addr);
    }
    if ( ic.table_index >= 0 ) {
        comment.cat_sprnt("\n  Index: %d", ic.table_index);
    }
    if ( ic.offset != 0 ) {
        comment.cat_sprnt("\n  Offset: %lld", (long long)ic.offset);
    }

    set_cmt(ic.call_insn->ea, comment.c_str(), false);
}

```

`src/deobf/handlers/indirect_call.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Indirect Call Resolution Handler
//
// Hikari's IndirectCall obfuscation:
//   - Creates a global table of code addresses
//   - Replaces direct calls with: call(table[index] - offset)
//   - The offset is a constant value subtracted from each table entry
//
// Pattern in decompiled code:
//   v3 = &global_table;
//   ((void(*)(...))((char*)v3[index] - offset))(...);
//
// Pattern at microcode level:
//   mov reg1, #table_addr
//   add reg2, reg1, #(index * 8)
//   ldx reg3, ds.8, reg2
//   sub reg4, reg3, #offset
//   icall reg4
//
// Detection:
//   - m_icall instructions with computed targets
//   - Target computed as: load_from_table - constant_offset
//   - Global tables containing code addresses
//
// Resolution:
//   1. Find indirect call instructions
//   2. Trace back to find table base and index
//   3. Read table entry
//   4. Compute actual target: table[index] - offset
//   5. Replace with direct call
//--------------------------------------------------------------------------
class indirect_call_handler_t {
public:
    // Detection - checks for indirect call patterns
    static bool detect(mbl_array_t *mba);

    // Main deobfuscation pass
    static int run(mbl_array_t *mba, deobf_ctx_t *ctx);

private:
    // Indirect call info
    struct indirect_call_t {
        int block_idx;              // Block containing the call
        minsn_t *call_insn;         // The call instruction
        ea_t table_addr;            // Global table base address
        int table_index;            // Index into table (-1 if variable)
        int64_t offset;             // Offset subtracted from table entry
        ea_t resolved_target;       // Computed target address
        bool is_resolved;           // Whether we successfully resolved it
        qstring target_name;        // Name of resolved target (if any)
        
        // Frameless continuation support
        bool is_frameless_continuation;  // True if this is a call to a frameless continuation
        ea_t continuation_target;        // Original continuation function address
        
        indirect_call_t() : block_idx(-1), call_insn(nullptr), table_addr(BADADDR),
                           table_index(-1), offset(0), resolved_target(BADADDR),
                           is_resolved(false), is_frameless_continuation(false),
                           continuation_target(BADADDR) {}
    };

    // Find all indirect calls in the function
    static std::vector<indirect_call_t> find_indirect_calls(mbl_array_t *mba);

    // Analyze an indirect call to extract table/index/offset
    static bool analyze_indirect_call(mblock_t *blk, minsn_t *call_insn, 
                                      indirect_call_t *out);

    // Trace the call target computation backwards
    // Returns true if we found a table[index] - offset pattern
    static bool trace_call_target(mblock_t *blk, minsn_t *call_insn,
                                  ea_t *out_table, int *out_index, 
                                  int64_t *out_offset);

    // Find table base address from operand
    static ea_t find_table_base(mblock_t *blk, const mop_t &op);

    // Extract constant index from operand
    static bool extract_constant_index(mblock_t *blk, const mop_t &op, int *out_index);

    // Read target from table and apply offset
    static ea_t compute_target(ea_t table_addr, int index, int64_t offset);

    // Replace indirect call with direct call
    static int replace_indirect_call(mbl_array_t *mba, mblock_t *blk,
                                     indirect_call_t &ic, deobf_ctx_t *ctx);

    // Annotate unresolved indirect call
    static void annotate_indirect_call(mblock_t *blk, const indirect_call_t &ic);
};

```

`src/deobf/handlers/jump_optimizer.cpp`:

```cpp
#include "jump_optimizer.h"

namespace chernobog {

// Static member initialization
size_t jump_optimizer_handler_t::jumps_simplified_ = 0;
size_t jump_optimizer_handler_t::jumps_converted_goto_ = 0;
size_t jump_optimizer_handler_t::jumps_removed_ = 0;

//--------------------------------------------------------------------------
// Detection
//--------------------------------------------------------------------------

bool jump_optimizer_handler_t::detect(mbl_array_t* mba)
{
    if ( !mba ) 
        return false;

    // Look for conditional jumps with complex conditions
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk || !blk->tail ) 
            continue;

        minsn_t* tail = blk->tail;
        if ( !is_mcode_jcond(tail->opcode) ) 
            continue;

        // Check if condition is complex (involves nested operations)
        if ( tail->l.t == mop_d && tail->l.d ) {
            return true;  // Has nested instruction in condition
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// Main pass
//--------------------------------------------------------------------------

int jump_optimizer_handler_t::run(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    // Initialize rule registry
    rules::JumpRuleRegistry::instance().initialize();

    int total_changes = 0;

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk || !blk->tail ) 
            continue;

        minsn_t* tail = blk->tail;
        if ( !is_mcode_jcond(tail->opcode) ) 
            continue;

        int changes = simplify_jcc(blk, tail, ctx);
        total_changes += changes;
    }

    if ( total_changes > 0 ) {
        ctx->branches_simplified += total_changes;
        deobf::log_verbose("[JumpOpt] Simplified %d conditional jumps\n", total_changes);
    }

    return total_changes;
}

//--------------------------------------------------------------------------
// Instruction-level optimization
//--------------------------------------------------------------------------

int jump_optimizer_handler_t::simplify_jcc(mblock_t* blk, minsn_t* jcc, deobf_ctx_t* ctx) {
    if ( !blk || !jcc || !is_mcode_jcond(jcc->opcode) ) 
        return 0;

    int result = rules::JumpRuleRegistry::instance().try_apply(blk, jcc);
    if ( result == -1 ) 
        return 0;  // No rule matched

    return apply_optimization(blk, jcc, result);
}

//--------------------------------------------------------------------------
// Apply optimization
//--------------------------------------------------------------------------

int jump_optimizer_handler_t::apply_optimization(mblock_t* blk, minsn_t* jcc, int result)
{
    if ( result == 1 ) {
        // Jump is always taken - convert to unconditional goto
        ea_t orig_ea = jcc->ea;

        // Get the target block
        int target_block = jcc->d.b;

        // Convert to unconditional goto
        jcc->opcode = m_goto;
        jcc->l.erase();
        jcc->r.erase();
        jcc->d.t = mop_b;
        jcc->d.b = target_block;
        jcc->ea = orig_ea;

        jumps_simplified_++;
        jumps_converted_goto_++;

        deobf::log_verbose("[JumpOpt] Converted always-taken jcc at %a to goto\n", orig_ea);
        return 1;
    }
    else if ( result == 0 ) {
        // Jump is never taken - remove it (becomes fall-through)
        ea_t orig_ea = jcc->ea;

        // Convert to nop
        jcc->opcode = m_nop;
        jcc->l.erase();
        jcc->r.erase();
        jcc->d.erase();
        jcc->ea = orig_ea;

        jumps_simplified_++;
        jumps_removed_++;

        deobf::log_verbose("[JumpOpt] Removed never-taken jcc at %a\n", orig_ea);
        return 1;
    }

    return 0;
}

//--------------------------------------------------------------------------
// Statistics
//--------------------------------------------------------------------------

void jump_optimizer_handler_t::dump_statistics()
{
    msg("[chernobog] Jump Optimizer Statistics:\n");
    msg("  Total simplified: %zu\n", jumps_simplified_);
    msg("  Converted to goto: %zu\n", jumps_converted_goto_);
    msg("  Removed (nop): %zu\n", jumps_removed_);

    rules::JumpRuleRegistry::instance().dump_statistics();
}

void jump_optimizer_handler_t::reset_statistics()
{
    jumps_simplified_ = 0;
    jumps_converted_goto_ = 0;
    jumps_removed_ = 0;

    rules::JumpRuleRegistry::instance().reset_statistics();
}

} // namespace chernobog

```

`src/deobf/handlers/jump_optimizer.h`:

```h
#pragma once
#include "../deobf_types.h"
#include "../rules/jump_rules.h"

//--------------------------------------------------------------------------
// Jump Optimizer Handler
//
// Detects and simplifies opaque predicates in conditional jumps.
// Uses both pattern matching and Z3-based analysis to determine if
// conditional jumps are always taken or never taken.
//
// When a jump is always taken:  Convert to unconditional goto
// When a jump is never taken:   Convert to nop / remove
//--------------------------------------------------------------------------

namespace chernobog {

class jump_optimizer_handler_t {
public:
    // Detect if opaque jump patterns are present
    static bool detect(mbl_array_t* mba);

    // Run jump optimization pass
    static int run(mbl_array_t* mba, deobf_ctx_t* ctx);

    // Instruction-level optimization
    static int simplify_jcc(mblock_t* blk, minsn_t* jcc, deobf_ctx_t* ctx);

    // Statistics
    static void dump_statistics();
    static void reset_statistics();

private:
    // Apply optimization based on rule result
    // result: 1 = always taken, 0 = never taken
    static int apply_optimization(mblock_t* blk, minsn_t* jcc, int result);

    static size_t jumps_simplified_;
    static size_t jumps_converted_goto_;
    static size_t jumps_removed_;
};

} // namespace chernobog

```

`src/deobf/handlers/mba_simplify.cpp`:

```cpp
#include "mba_simplify.h"
#include "../analysis/ast.h"
#include "../analysis/ast_builder.h"

// Include all rule headers to trigger registration
#include "../rules/rules_add.h"
#include "../rules/rules_sub.h"
#include "../rules/rules_xor.h"
#include "../rules/rules_and.h"
#include "../rules/rules_or.h"
#include "../rules/rules_misc.h"

using namespace chernobog::ast;
using namespace chernobog::rules;

// Static member initialization
bool mba_simplify_handler_t::initialized_ = false;
size_t mba_simplify_handler_t::total_simplified_ = 0;

//--------------------------------------------------------------------------
// Initialization
//--------------------------------------------------------------------------
void mba_simplify_handler_t::initialize() {
    if ( initialized_ ) {
        return;
    }

    // Initialize the rule registry (builds pattern index)
    try {
        RuleRegistry::instance().initialize();
    } catch (...) {
        msg("[chernobog] ERROR: Exception during rule registry initialization\n");
        return;
    }

    initialized_ = true;
    msg("[chernobog] MBA simplify handler initialized\n");
}

bool mba_simplify_handler_t::is_initialized() {
    return initialized_;
}

//--------------------------------------------------------------------------
// Detection
//--------------------------------------------------------------------------
bool mba_simplify_handler_t::detect(mbl_array_t *mba) {
    if ( !mba ) {
        return false;
    }

    // Ensure initialized
    if ( !initialized_ ) {
        initialize();
    }

    // Look for complex arithmetic/logic patterns
    int complex_count = 0;
    const int THRESHOLD = 3;  // Need at least 3 complex patterns

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk) continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            // Look for nested operations (sign of obfuscation)
            if ( !is_mba_opcode(ins->opcode) ) {
                continue;
            }

            // Check if operands contain nested operations
            bool has_nested = false;

            if ( ins->l.t == mop_d && ins->l.d ) {
                if ( is_mba_opcode(ins->l.d->opcode) ) {
                    has_nested = true;
                }
            }

            if ( ins->r.t == mop_d && ins->r.d ) {
                if ( is_mba_opcode(ins->r.d->opcode) ) {
                    has_nested = true;
                }
            }

            if ( has_nested ) {
                complex_count++;
                if ( complex_count >= THRESHOLD ) {
                    return true;
                }
            }
        }
    }

    return complex_count > 0;
}

//--------------------------------------------------------------------------
// Main deobfuscation pass
//--------------------------------------------------------------------------
int mba_simplify_handler_t::run(mbl_array_t *mba, deobf_ctx_t *ctx) {
    if ( !mba || !ctx ) {
        return 0;
    }

    if ( !initialized_ ) {
        initialize();
    }

    int total_changes = 0;
    int pass = 0;
    const int MAX_PASSES = 10;

    // Multi-pass simplification (simplifications may enable more simplifications)
    do {
        int pass_changes = 0;
        pass++;

        for ( int i = 0; i < mba->qty; ++i ) {
            mblock_t *blk = mba->get_mblock(i);
            if ( !blk) continue;

            for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
                int changes = try_simplify_instruction(blk, ins);
                pass_changes += changes;
            }
        }

        total_changes += pass_changes;

        if ( pass_changes > 0 ) {
            // Verify after changes
            mba->verify(false);
        }

    } while ( pass < MAX_PASSES && total_changes > 0 && pass == 1);
    // Note: For now, only do one pass to avoid potential infinite loops
    // TODO: Improve change detection to safely do multiple passes

    if ( total_changes > 0 ) {
        ctx->expressions_simplified += total_changes;
        deobf::log_verbose("[MBA] Simplified %d expressions\n", total_changes);
    }

    return total_changes;
}

//--------------------------------------------------------------------------
// Instruction-level simplification
//--------------------------------------------------------------------------
int mba_simplify_handler_t::simplify_insn(mblock_t *blk, minsn_t *ins, deobf_ctx_t *ctx) {
    // Early null check before anything else
    if ( !blk || !ins ) {
        return 0;
    }

    // Only try to simplify if registry is initialized
    if ( !initialized_ ) {
        // Don't initialize here - do it at plugin init time
        return 0;
    }

    int changes = try_simplify_instruction(blk, ins);

    if ( changes > 0 && ctx ) {
        ctx->expressions_simplified += changes;
    }

    return changes;
}

//--------------------------------------------------------------------------
// Internal simplification
//--------------------------------------------------------------------------
int mba_simplify_handler_t::try_simplify_instruction(mblock_t *blk, minsn_t *ins) {
    if ( !ins || !is_mba_opcode(ins->opcode) ) {
        return 0;
    }

    // Ensure initialized
    if ( !initialized_ ) {
        initialize();
    }

    // Try to find a matching rule
    auto match = RuleRegistry::instance().find_match(ins);
    if ( !match.rule ) {
        return 0;
    }

    // Apply the matched rule
    return apply_match(blk, ins, match);
}

int mba_simplify_handler_t::apply_match(mblock_t *blk, minsn_t *ins,
                                        const RuleRegistry::MatchResult &match)
                                        {
    if ( !match.rule ) {
        return 0;
    }

    // Apply the replacement
    minsn_t *replacement = match.rule->apply_replacement(match.bindings, blk, ins);

    if ( !replacement ) {
        return 0;
    }

    // Save original properties
    ea_t orig_ea = ins->ea;
    mop_t orig_dest = ins->d;

    // Copy replacement instruction fields
    ins->opcode = replacement->opcode;
    ins->l.swap(replacement->l);  // Use swap for proper mop_t handling
    ins->r.swap(replacement->r);

    // Restore original ea and destination
    ins->ea = orig_ea;
    ins->d = orig_dest;

    // Ensure operand sizes match destination
    if ( ins->l.size == 0 && orig_dest.size > 0 ) {
        ins->l.size = orig_dest.size;
    }
    if ( ins->r.size == 0 && orig_dest.size > 0 && ins->r.t != mop_z ) {
        ins->r.size = orig_dest.size;
    }

    delete replacement;

    total_simplified_++;

    return 1;
}

//--------------------------------------------------------------------------
// Statistics
//--------------------------------------------------------------------------
size_t mba_simplify_handler_t::total_simplifications() {
    return total_simplified_;
}

void mba_simplify_handler_t::reset_statistics() {
    total_simplified_ = 0;
    RuleRegistry::instance().clear_statistics();
}

void mba_simplify_handler_t::dump_statistics() {
    msg("[chernobog] MBA Simplify Statistics:\n");
    msg("  Total simplifications: %zu\n", total_simplified_);

    RuleRegistry::instance().dump();
}

```

`src/deobf/handlers/mba_simplify.h`:

```h
#pragma once
#include "../deobf_types.h"
#include "../rules/rule_registry.h"

//--------------------------------------------------------------------------
// MBA Simplify Handler
//
// This handler replaces the old substitution_handler_t with the new
// AST-based pattern matching system. It provides:
//
//   - 90+ MBA simplification rules (vs 12 in old handler)
//   - Pattern fuzzing for robust matching
//   - O(log n) hierarchical pattern lookup
//   - Statistics tracking per rule
//
// The handler integrates with IDA's microcode optimization through
// both instruction-level (optinsn_t) and block-level passes.
//--------------------------------------------------------------------------

class mba_simplify_handler_t {
public:
    //----------------------------------------------------------------------
    // Standard handler interface
    //----------------------------------------------------------------------

    // Detect if MBA obfuscation is present
    static bool detect(mbl_array_t *mba);

    // Run the deobfuscation pass
    static int run(mbl_array_t *mba, deobf_ctx_t *ctx);

    //----------------------------------------------------------------------
    // Instruction-level simplification (for optinsn_t callback)
    //----------------------------------------------------------------------

    // Try to simplify a single instruction
    // Returns 1 if simplified, 0 otherwise
    static int simplify_insn(mblock_t *blk, minsn_t *ins, deobf_ctx_t *ctx);

    //----------------------------------------------------------------------
    // Initialization
    //----------------------------------------------------------------------

    // Initialize the rule registry (call once at plugin startup)
    static void initialize();

    // Check if initialized
    static bool is_initialized();

    //----------------------------------------------------------------------
    // Statistics
    //----------------------------------------------------------------------

    static size_t total_simplifications();
    static void reset_statistics();
    static void dump_statistics();

private:
    static bool initialized_;
    static size_t total_simplified_;

    // Internal simplification helpers
    static int try_simplify_instruction(mblock_t *blk, minsn_t *ins);
    static int apply_match(mblock_t *blk, minsn_t *ins,
                          const chernobog::rules::RuleRegistry::MatchResult &match);
};

```

`src/deobf/handlers/objc_resolve.cpp`:

```cpp
#include "objc_resolve.h"
#include "../analysis/stack_tracker.h"

//--------------------------------------------------------------------------
// Check if function is objc_msgSend variant (by address)
//--------------------------------------------------------------------------
bool objc_resolve_handler_t::is_objc_msgsend(ea_t func_addr)
{
    if ( func_addr == BADADDR ) 
        return false;

    qstring name;
    if ( get_name(&name, func_addr) > 0 ) {
        return is_objc_msgsend(name.c_str());
    }

    return false;
}

//--------------------------------------------------------------------------
// Check if function is objc_msgSend variant (by name)
//--------------------------------------------------------------------------
bool objc_resolve_handler_t::is_objc_msgsend(const char *name)
{
    if ( !name ) 
        return false;

    // Skip leading underscore if present
    if ( name[0] == '_' ) 
        name++;

    // Check various objc_msgSend patterns
    if ( strncmp(name, "objc_msgSend", 12) == 0 ) 
        return true;
    if ( strncmp(name, "objc_msgLookup", 14) == 0 ) 
        return true;

    return false;
}

//--------------------------------------------------------------------------
// Classify objc_msgSend variant
//--------------------------------------------------------------------------
objc_resolve_handler_t::msgsend_variant_t
objc_resolve_handler_t::classify_msgsend(ea_t addr) {
    qstring name;
    if ( get_name(&name, addr) <= 0 ) 
        return MSGSEND_UNKNOWN;

    return classify_msgsend(name.c_str());
}

objc_resolve_handler_t::msgsend_variant_t
objc_resolve_handler_t::classify_msgsend(const char *name) {
    if ( !name ) 
        return MSGSEND_UNKNOWN;

    // Skip leading underscore
    if ( name[0] == '_' ) 
        name++;

    if ( strcmp(name, "objc_msgSend") == 0 ) 
        return MSGSEND_NORMAL;
    if ( strcmp(name, "objc_msgSendSuper") == 0 ) 
        return MSGSEND_SUPER;
    if ( strcmp(name, "objc_msgSendSuper2") == 0 ) 
        return MSGSEND_SUPER2;
    if ( strcmp(name, "objc_msgSend_stret") == 0 ) 
        return MSGSEND_STRET;
    if ( strcmp(name, "objc_msgSend_fpret") == 0 ) 
        return MSGSEND_FPRET;
    if ( strcmp(name, "objc_msgSend_fp2ret") == 0 ) 
        return MSGSEND_FP2RET;

    // Check for prefixed versions
    if ( strstr(name, "msgSendSuper2") ) 
        return MSGSEND_SUPER2;
    if ( strstr(name, "msgSendSuper") ) 
        return MSGSEND_SUPER;
    if ( strstr(name, "msgSend_stret") ) 
        return MSGSEND_STRET;
    if ( strstr(name, "msgSend_fpret") ) 
        return MSGSEND_FPRET;
    if ( strstr(name, "msgSend") ) 
        return MSGSEND_NORMAL;

    return MSGSEND_UNKNOWN;
}

//--------------------------------------------------------------------------
// Detection
//--------------------------------------------------------------------------
bool objc_resolve_handler_t::detect(mbl_array_t *mba)
{
    if ( !mba ) 
        return false;

    int msgsend_calls = 0;

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            if ( ins->opcode != m_call && ins->opcode != m_icall ) 
                continue;

            // Check direct call to objc_msgSend
            if ( ins->l.t == mop_v && is_objc_msgsend(ins->l.g) ) {
                msgsend_calls++;
            }
            // Check for address reference
            else if ( ins->l.t == mop_a && ins->l.a && ins->l.a->t == mop_v ) {
                if ( is_objc_msgsend(ins->l.a->g) ) {
                    msgsend_calls++;
                }
            }
            // Check indirect call (might be through stack)
            else if ( ins->opcode == m_icall ) {
                // We'll count these as potential candidates
                // The actual resolution happens in run()
            }
        }
    }

    return msgsend_calls > 0;
}

//--------------------------------------------------------------------------
// Find all objc_msgSend calls
//--------------------------------------------------------------------------
void objc_resolve_handler_t::find_msgsend_calls(
    mbl_array_t *mba,
    std::vector<std::pair<mblock_t*, minsn_t*>> &calls)
{
    calls.clear();

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            if ( ins->opcode != m_call && ins->opcode != m_icall ) 
                continue;

            bool is_msgsend = false;

            // Direct call
            if ( ins->l.t == mop_v && is_objc_msgsend(ins->l.g) ) {
                is_msgsend = true;
            }
            // Address reference
            else if ( ins->l.t == mop_a && ins->l.a && ins->l.a->t == mop_v ) {
                if ( is_objc_msgsend(ins->l.a->g) ) {
                    is_msgsend = true;
                }
            }
            // Indirect through stack - check if we can resolve it
            else if ( ins->opcode == m_icall && ins->l.t == mop_S && ins->l.s ) {
                auto addr = stack_tracker_t::read_address(ins->l.s->off);
                if ( addr.has_value() && is_objc_msgsend(*addr) ) {
                    is_msgsend = true;
                }
            }

            if ( is_msgsend ) {
                calls.push_back({blk, ins});
            }
        }
    }
}

//--------------------------------------------------------------------------
// Get selector string from operand
//--------------------------------------------------------------------------
bool objc_resolve_handler_t::get_selector_string(
    mbl_array_t *mba,
    const mop_t &sel_op,
    qstring *out_selector)
{
    if ( !out_selector ) 
        return false;

    out_selector->clear();

    // Direct global string reference
    if ( sel_op.t == mop_v ) {
        size_t len = get_max_strlit_length(sel_op.g, STRTYPE_C);
        if ( len > 0 && len < 256 ) {
            out_selector->resize(len);
            if ( get_strlit_contents(out_selector, sel_op.g, len, STRTYPE_C) > 0 ) {
                return true;
            }
        }

        // Might be a selector reference (__objc_selrefs)
        // Try reading pointer and then string
        ea_t sel_ptr = get_qword(sel_op.g);
        if ( sel_ptr != 0 && sel_ptr != BADADDR ) {
            len = get_max_strlit_length(sel_ptr, STRTYPE_C);
            if ( len > 0 && len < 256 ) {
                out_selector->resize(len);
                if ( get_strlit_contents(out_selector, sel_ptr, len, STRTYPE_C) > 0 ) {
                    return true;
                }
            }
        }
    }

    // Address expression
    if ( sel_op.t == mop_a && sel_op.a && sel_op.a->t == mop_v ) {
        size_t len = get_max_strlit_length(sel_op.a->g, STRTYPE_C);
        if ( len > 0 && len < 256 ) {
            out_selector->resize(len);
            if ( get_strlit_contents(out_selector, sel_op.a->g, len, STRTYPE_C) > 0 ) {
                return true;
            }
        }
    }

    // Stack reference
    if ( sel_op.t == mop_S && sel_op.s ) {
        auto str = stack_tracker_t::read_string(sel_op.s->off);
        if ( str.has_value() ) {
            *out_selector = str->c_str();
            return true;
        }

        // Try as address pointing to string
        auto addr = stack_tracker_t::read_address(sel_op.s->off);
        if ( addr.has_value() ) {
            size_t len = get_max_strlit_length(*addr, STRTYPE_C);
            if ( len > 0 && len < 256 ) {
                out_selector->resize(len);
                if ( get_strlit_contents(out_selector, *addr, len, STRTYPE_C) > 0 ) {
                    return true;
                }
            }
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// Trace selector argument from call
//--------------------------------------------------------------------------
bool objc_resolve_handler_t::trace_selector(
    mbl_array_t *mba,
    mblock_t *blk,
    minsn_t *call_insn,
    qstring *out_selector)
{
    if ( !mba || !blk || !call_insn || !out_selector ) 
        return false;

    // For objc_msgSend, selector is arg 1 (0-indexed = second argument)
    // For msgSendSuper, it's also arg 1 (after super struct)

    // Get call arguments
    if ( call_insn->d.t != mop_f || !call_insn->d.f ) 
        return false;

    mcallinfo_t *ci = call_insn->d.f;

    // Need at least 2 arguments (receiver, selector)
    if ( ci->args.size() < 2 ) 
        return false;

    // Get selector argument (index 1)
    const mcallarg_t &sel_arg = ci->args[1];

    return get_selector_string(mba, sel_arg, out_selector);
}

//--------------------------------------------------------------------------
// Get selector from sel_registerName call
//--------------------------------------------------------------------------
bool objc_resolve_handler_t::get_selector_from_registration(
    mbl_array_t *mba,
    const mop_t &op,
    qstring *out)
{
    // This would trace back to find a sel_registerName("string") call
    // and extract the string argument
    // Complex implementation - would need dataflow analysis
    return false;
}

//--------------------------------------------------------------------------
// Trace receiver to find class name
//--------------------------------------------------------------------------
bool objc_resolve_handler_t::trace_receiver_class(
    mbl_array_t *mba,
    mblock_t *blk,
    minsn_t *call_insn,
    qstring *out_class)
{
    if ( !mba || !blk || !call_insn || !out_class ) 
        return false;

    if ( call_insn->d.t != mop_f || !call_insn->d.f ) 
        return false;

    mcallinfo_t *ci = call_insn->d.f;
    if ( ci->args.empty() ) 
        return false;

    // Get receiver argument (index 0)
    const mcallarg_t &recv_arg = ci->args[0];

    return is_class_object(mba, recv_arg, out_class);
}

//--------------------------------------------------------------------------
// Check if operand is a class object reference
//--------------------------------------------------------------------------
bool objc_resolve_handler_t::is_class_object(
    mbl_array_t *mba,
    const mop_t &receiver,
    qstring *out_class)
{
    if ( !out_class ) 
        return false;

    // Check for direct class reference
    if ( receiver.t == mop_v ) {
        qstring name;
        if ( get_name(&name, receiver.g) > 0 ) {
            // ObjC class references typically have patterns like:
            // _OBJC_CLASS_$_ClassName
            // classRef_ClassName
            const char *prefix = "_OBJC_CLASS_$_";
            size_t prefix_len = strlen(prefix);
            if ( name.length() > prefix_len &&
                strncmp(name.c_str(), prefix, prefix_len) == 0)
                {
                *out_class = name.c_str() + prefix_len;
                return true;
            }

            // Check for classRef pattern
            if ( name.find("classRef_") == 0 ) {
                *out_class = name.c_str() + 9;  // Skip "classRef_"
                return true;
            }
        }
    }

    // Check address expression
    if ( receiver.t == mop_a && receiver.a && receiver.a->t == mop_v ) {
        qstring name;
        if ( get_name(&name, receiver.a->g) > 0 ) {
            const char *prefix = "_OBJC_CLASS_$_";
            size_t prefix_len = strlen(prefix);
            if ( name.length() > prefix_len &&
                strncmp(name.c_str(), prefix, prefix_len) == 0)
                {
                *out_class = name.c_str() + prefix_len;
                return true;
            }
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// Resolve a single objc_msgSend call
//--------------------------------------------------------------------------
bool objc_resolve_handler_t::resolve_msgsend_call(
    mbl_array_t *mba,
    mblock_t *blk,
    minsn_t *call_insn,
    objc_call_info_t *out)
{
    if ( !mba || !blk || !call_insn || !out ) 
        return false;

    // Initialize output
    out->call_addr = call_insn->ea;
    out->msgsend_addr = BADADDR;
    out->selector.clear();
    out->receiver_class.clear();
    out->is_class_method = false;
    out->is_super_call = false;
    out->is_stret = false;

    // Get msgSend address
    if ( call_insn->l.t == mop_v ) {
        out->msgsend_addr = call_insn->l.g;
    }
    else if ( call_insn->l.t == mop_a && call_insn->l.a && call_insn->l.a->t == mop_v ) {
        out->msgsend_addr = call_insn->l.a->g;
    }
    else if ( call_insn->l.t == mop_S && call_insn->l.s ) {
        auto addr = stack_tracker_t::read_address(call_insn->l.s->off);
        if ( addr.has_value() ) {
            out->msgsend_addr = *addr;
        }
    }

    if ( out->msgsend_addr == BADADDR ) 
        return false;

    // Get variant info
    msgsend_variant_t variant = classify_msgsend(out->msgsend_addr);
    get_name(&out->msgsend_variant, out->msgsend_addr);

    out->is_super_call = (variant == MSGSEND_SUPER || variant == MSGSEND_SUPER2);
    out->is_stret = (variant == MSGSEND_STRET);

    // Trace selector
    if ( !trace_selector(mba, blk, call_insn, &out->selector) ) {
        return false;  // Must have selector to be useful
    }

    // Try to trace receiver class
    if ( trace_receiver_class(mba, blk, call_insn, &out->receiver_class) ) {
        out->is_class_method = true;  // If we found a class, it's likely a class method
    }

    return true;
}

//--------------------------------------------------------------------------
// Format method signature
//--------------------------------------------------------------------------
qstring objc_resolve_handler_t::format_method_signature(const objc_call_info_t &info) {
    qstring result;

    // Format: +/-[ClassName selector]
    char method_type = info.is_class_method ? '+' : '-';

    if ( !info.receiver_class.empty() ) {
        result.sprnt("%c[%s %s]", method_type,
                    info.receiver_class.c_str(),
                    info.selector.c_str());
    }
    else {
        result.sprnt("%c[? %s]", method_type, info.selector.c_str());
    }

    return result;
}

//--------------------------------------------------------------------------
// Annotate a resolved ObjC call
//--------------------------------------------------------------------------
void objc_resolve_handler_t::annotate_objc_call(ea_t call_addr, const objc_call_info_t &info)
{
    if ( call_addr == BADADDR ) 
        return;

    qstring comment;
    comment.sprnt("DEOBF: %s", format_method_signature(info).c_str());

    if ( info.is_super_call ) {
        comment += " (super)";
    }
    if ( info.is_stret ) {
        comment += " (stret)";
    }

    set_cmt(call_addr, comment.c_str(), false);
}

//--------------------------------------------------------------------------
// Main processing
//--------------------------------------------------------------------------
int objc_resolve_handler_t::run(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    int changes = 0;

    // Find all objc_msgSend calls
    std::vector<std::pair<mblock_t*, minsn_t*>> msgsend_calls;
    find_msgsend_calls(mba, msgsend_calls);

    if ( msgsend_calls.empty() ) {
        return 0;
    }

    deobf::log("[objc_resolve] Found %d objc_msgSend calls\n", (int)msgsend_calls.size());

    // Resolve each call
    for ( const auto &pair : msgsend_calls ) {
        mblock_t *blk = pair.first;
        minsn_t *ins = pair.second;

        objc_call_info_t info;
        if ( resolve_msgsend_call(mba, blk, ins, &info) ) {
            annotate_objc_call(info.call_addr, info);

            deobf::log("[objc_resolve]   0x%llX: %s\n",
                      (unsigned long long)info.call_addr,
                      format_method_signature(info).c_str());

            changes++;
        }
    }

    deobf::log("[objc_resolve] Resolved %d ObjC method calls\n", changes);

    return changes;
}

```

`src/deobf/handlers/objc_resolve.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// ObjC Message Send Resolver
//
// Handles obfuscated Objective-C method calls:
//   - Indirect objc_msgSend calls through stack/registers
//   - Encrypted or split selector strings
//   - Wrapped objc_msgSend calls (through wrapper functions)
//   - sel_registerName / sel_getUid patterns
//   - NSSelectorFromString patterns
//
// Example patterns:
//   1. Direct obfuscation:
//      *(&savedregs - 132) = &objc_msgSend;
//      *(&savedregs - 133) = "doSomething:";
//      (*(&savedregs - 132))(obj, *(&savedregs - 133), arg);
//
//   2. Dynamic selector lookup:
//      sel = sel_registerName("methodName");
//      objc_msgSend(obj, sel, args);
//
//   3. Wrapper function:
//      HikariFunctionWrapper_1234(obj, selector, args);
//      // where wrapper just calls objc_msgSend
//
// Resolution approach:
//   1. Identify objc_msgSend call sites (direct and indirect)
//   2. Trace selector argument to find string value
//   3. Trace receiver to identify class if possible
//   4. Annotate with resolved method signature
//--------------------------------------------------------------------------
class objc_resolve_handler_t {
public:
    // Detection
    static bool detect(mbl_array_t *mba);

    // Main processing
    static int run(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Check if a function is objc_msgSend variant
    static bool is_objc_msgsend(ea_t func_addr);
    static bool is_objc_msgsend(const char *name);

    // Get selector string from various sources
    static bool get_selector_string(mbl_array_t *mba, const mop_t &sel_op,
                                   qstring *out_selector);

private:
    // Resolved ObjC call information
    struct objc_call_info_t {
        ea_t call_addr;             // Address of the call
        ea_t msgsend_addr;          // Address of objc_msgSend variant
        qstring msgsend_variant;    // Which variant (msgSend, msgSendSuper, etc)
        qstring selector;           // Resolved selector string
        qstring receiver_class;     // Receiver class name (if determinable)
        bool is_class_method;       // True if class method (+), false if instance (-)
        bool is_super_call;         // True if msgSendSuper
        bool is_stret;              // True if returns struct (msgSend_stret)
    };

    // objc_msgSend variants
    enum msgsend_variant_t {
        MSGSEND_UNKNOWN,
        MSGSEND_NORMAL,         // objc_msgSend
        MSGSEND_SUPER,          // objc_msgSendSuper
        MSGSEND_SUPER2,         // objc_msgSendSuper2
        MSGSEND_STRET,          // objc_msgSend_stret
        MSGSEND_FPRET,          // objc_msgSend_fpret
        MSGSEND_FP2RET,         // objc_msgSend_fp2ret
    };

    // Analysis functions
    static msgsend_variant_t classify_msgsend(ea_t addr);
    static msgsend_variant_t classify_msgsend(const char *name);

    // Find all objc_msgSend calls (direct and indirect)
    static void find_msgsend_calls(mbl_array_t *mba,
                                  std::vector<std::pair<mblock_t*, minsn_t*>> &calls);

    // Resolve a single objc_msgSend call
    static bool resolve_msgsend_call(mbl_array_t *mba, mblock_t *blk,
                                    minsn_t *call_insn,
                                    objc_call_info_t *out);

    // Trace selector argument
    static bool trace_selector(mbl_array_t *mba, mblock_t *blk,
                              minsn_t *call_insn,
                              qstring *out_selector);

    // Get selector from sel_registerName / sel_getUid call
    static bool get_selector_from_registration(mbl_array_t *mba,
                                              const mop_t &op,
                                              qstring *out);

    // Get selector from NSSelectorFromString call
    static bool get_selector_from_nsselector(mbl_array_t *mba,
                                            const mop_t &op,
                                            qstring *out);

    // Trace receiver to find class
    static bool trace_receiver_class(mbl_array_t *mba, mblock_t *blk,
                                    minsn_t *call_insn,
                                    qstring *out_class);

    // Check if receiver is a class object (for class methods)
    static bool is_class_object(mbl_array_t *mba, const mop_t &receiver,
                               qstring *out_class);

    // Annotation
    static void annotate_objc_call(ea_t call_addr, const objc_call_info_t &info);

    // Format method signature
    static qstring format_method_signature(const objc_call_info_t &info);
};

```

`src/deobf/handlers/peephole.cpp`:

```cpp
#include "peephole.h"

namespace chernobog {
namespace peephole {

//--------------------------------------------------------------------------
// Static member initialization
//--------------------------------------------------------------------------
std::vector<std::unique_ptr<PeepholeOptimizer>> peephole_handler_t::optimizers_;
bool peephole_handler_t::initialized_ = false;

//--------------------------------------------------------------------------
// ConstantCallFoldOptimizer implementation
//--------------------------------------------------------------------------

bool ConstantCallFoldOptimizer::is_rotate_helper(ea_t func_ea, int* bits, bool* is_left)
{
    qstring func_name;
    if ( !get_func_name(&func_name, func_ea) ) 
        return false;

    // Check for IDA's rotate helper functions
    // __ROL1__, __ROL2__, __ROL4__, __ROL8__
    // __ROR1__, __ROR2__, __ROR4__, __ROR8__
    if ( func_name.find("__ROL") == 0 || func_name.find("__ROR") == 0 ) {
        *is_left = (func_name[3] == 'L');

        if ( func_name.find("1__") != qstring::npos ) {
            *bits = 8;
        } else if ( func_name.find("2__") != qstring::npos ) {
            *bits = 16;
        } else if ( func_name.find("4__") != qstring::npos ) {
            *bits = 32;
        } else if ( func_name.find("8__") != qstring::npos ) {
            *bits = 64;
        } else {
            return false;
        }
        return true;
    }

    return false;
}

uint64_t ConstantCallFoldOptimizer::eval_rotate(uint64_t val, int shift, int bits, bool left) {
    uint64_t mask = (bits == 64) ? ~0ULL : ((1ULL << bits) - 1);
    val &= mask;
    shift %= bits;

    if ( shift == 0 ) 
        return val;

    if ( left ) {
        return ((val << shift) | (val >> (bits - shift))) & mask;
    } else {
        return ((val >> shift) | (val << (bits - shift))) & mask;
    }
}

int ConstantCallFoldOptimizer::optimize(mblock_t* blk, minsn_t* ins)
{
    if ( !ins || ins->opcode != m_call ) 
        return 0;

    // Get call target
    if ( ins->l.t != mop_v && ins->l.t != mop_a ) 
        return 0;

    ea_t func_ea = (ins->l.t == mop_v) ? ins->l.g : ins->l.a->g;

    int bits;
    bool is_left;
    if ( !is_rotate_helper(func_ea, &bits, &is_left) ) 
        return 0;

    // Check for call arguments
    mcallinfo_t* ci = ins->d.f;
    if ( !ci || ci->args.size() < 2 ) 
        return 0;

    // Check if both arguments are constants
    mcallarg_t& arg0 = ci->args[0];
    mcallarg_t& arg1 = ci->args[1];

    if ( arg0.t != mop_n || arg1.t != mop_n ) 
        return 0;

    uint64_t val = arg0.nnn->value;
    int shift = static_cast<int>(arg1.nnn->value);

    // Rotate by 0 - just return the value
    if ( shift == 0 ) {
        ins->opcode = m_mov;
        ins->l.make_number(val, ins->d.size);
        ins->r.erase();
        hit_count_++;
        return 1;
    }

    // Compute result
    uint64_t result = eval_rotate(val, shift, bits, is_left);

    ins->opcode = m_mov;
    ins->l.make_number(result, ins->d.size);
    ins->r.erase();
    hit_count_++;
    return 1;
}

//--------------------------------------------------------------------------
// ReadOnlyDataFoldOptimizer implementation
//--------------------------------------------------------------------------

bool ReadOnlyDataFoldOptimizer::is_readonly_addr(ea_t addr)
{
    segment_t* seg = getseg(addr);
    if ( !seg ) 
        return false;

    // Check segment permissions
    if ( seg->perm & SEGPERM_WRITE ) 
        return false;

    // Check if it's in a code or const data segment
    return (seg->type == SEG_CODE || seg->type == SEG_DATA);
}

bool ReadOnlyDataFoldOptimizer::read_const_value(ea_t addr, int size, uint64_t* out)
{
    if ( !is_readonly_addr(addr) ) 
        return false;

    // Read bytes from database
    switch ( size ) {
        case 1:
            *out = get_byte(addr);
            return true;
        case 2:
            *out = get_word(addr);
            return true;
        case 4:
            *out = get_dword(addr);
            return true;
        case 8:
            *out = get_qword(addr);
            return true;
        default:
            return false;
    }
}

int ReadOnlyDataFoldOptimizer::optimize(mblock_t* blk, minsn_t* ins)
{
    if ( !ins || ins->opcode != m_ldx ) 
        return 0;

    // Check for load from constant address
    // ldx ds.2, #addr.8, dest
    if ( ins->l.t != mop_n && ins->r.t != mop_n ) 
        return 0;

    ea_t addr = BADADDR;
    if ( ins->r.t == mop_n ) {
        addr = static_cast<ea_t>(ins->r.nnn->value);
    } else if ( ins->l.t == mop_n ) {
        // Segment operand - need to combine with offset
        return 0;  // Complex case, skip for now
    }

    if ( addr == BADADDR ) 
        return 0;

    uint64_t value;
    if ( !read_const_value(addr, ins->d.size, &value) ) 
        return 0;

    ins->opcode = m_mov;
    ins->l.make_number(value, ins->d.size);
    ins->r.erase();
    hit_count_++;
    return 1;
}

//--------------------------------------------------------------------------
// LocalConstPropOptimizer implementation
//--------------------------------------------------------------------------

int LocalConstPropOptimizer::optimize(mblock_t* blk, minsn_t* ins)
{
    // Track stores to stack
    if ( ins->opcode == m_stx && ins->d.t == mop_S ) {
        if ( ins->l.t == mop_n ) {
            stack_constants_[ins->d.s->off] = ins->l.nnn->value;
        } else {
            // Non-constant store invalidates the slot
            stack_constants_.erase(ins->d.s->off);
        }
        return 0;
    }

    // Propagate to loads from stack
    if ( ins->opcode == m_ldx && ins->l.t == mop_S ) {
        auto p = stack_constants_.find(ins->l.s->off);
        if ( p != stack_constants_.end() ) {
            ins->opcode = m_mov;
            ins->l.make_number(p->second, ins->d.size);
            ins->r.erase();
            hit_count_++;
            return 1;
        }
    }

    return 0;
}

//--------------------------------------------------------------------------
// ShiftByZeroOptimizer implementation
//--------------------------------------------------------------------------

int ShiftByZeroOptimizer::optimize(mblock_t* blk, minsn_t* ins) {
    if ( !ins ) 
        return 0;

    // Check for shift operations
    if ( ins->opcode != m_shl && ins->opcode != m_shr && ins->opcode != m_sar ) 
        return 0;

    // Check if shift amount is 0
    if ( ins->r.t != mop_n ) 
        return 0;

    if ( ins->r.nnn->value != 0 ) 
        return 0;

    // x << 0 = x, x >> 0 = x
    ins->opcode = m_mov;
    ins->r.erase();
    hit_count_++;
    return 1;
}

//--------------------------------------------------------------------------
// DoubleNegationOptimizer implementation
//--------------------------------------------------------------------------

int DoubleNegationOptimizer::optimize(mblock_t* blk, minsn_t* ins)
{
    if ( !ins ) 
        return 0;

    // Check for bnot or neg
    if ( ins->opcode != m_bnot && ins->opcode != m_neg ) 
        return 0;

    // Check if operand is result of same operation
    if ( ins->l.t != mop_d || !ins->l.d ) 
        return 0;

    if ( ins->l.d->opcode != ins->opcode ) 
        return 0;

    // ~~x = x or -(-x) = x
    ins->opcode = m_mov;
    ins->l = ins->l.d->l;
    hit_count_++;
    return 1;
}

//--------------------------------------------------------------------------
// PowerOfTwoOptimizer implementation
//--------------------------------------------------------------------------

bool PowerOfTwoOptimizer::is_power_of_2(uint64_t val, int* shift) {
    if ( val == 0 ) 
        return false;

    if ( (val & (val - 1)) != 0 ) 
        return false;

    *shift = 0;
    while ( (val & 1) == 0 ) {
        val >>= 1;
        (*shift)++;
    }
    return true;
}

int PowerOfTwoOptimizer::optimize(mblock_t* blk, minsn_t* ins)
{
    if ( !ins ) 
        return 0;

    // x * (power of 2) -> x << shift
    if ( ins->opcode == m_mul ) {
        if ( ins->r.t != mop_n ) 
            return 0;

        int shift;
        if ( !is_power_of_2(ins->r.nnn->value, &shift) ) 
            return 0;

        if ( shift == 0 ) {
            // x * 1 = x
            ins->opcode = m_mov;
            ins->r.erase();
        } else {
            ins->opcode = m_shl;
            ins->r.make_number(shift, 1);
        }
        hit_count_++;
        return 1;
    }

    // x / (power of 2) -> x >> shift (for unsigned)
    if ( ins->opcode == m_udiv ) {
        if ( ins->r.t != mop_n ) 
            return 0;

        int shift;
        if ( !is_power_of_2(ins->r.nnn->value, &shift) ) 
            return 0;

        if ( shift == 0 ) {
            // x / 1 = x
            ins->opcode = m_mov;
            ins->r.erase();
        } else {
            ins->opcode = m_shr;
            ins->r.make_number(shift, 1);
        }
        hit_count_++;
        return 1;
    }

    return 0;
}

//--------------------------------------------------------------------------
// SelfCompareOptimizer implementation
//--------------------------------------------------------------------------

int SelfCompareOptimizer::optimize(mblock_t* blk, minsn_t* ins)
{
    if ( !ins ) 
        return 0;

    // Check for comparison operations
    mcode_t op = ins->opcode;
    if ( op != m_setz && op != m_setnz && op != m_setl && op != m_setge &&
        op != m_setb && op != m_setae && op != m_setle && op != m_setg &&
        op != m_setbe && op != m_seta)
        return 0;

    // Get comparison operands from inner instruction
    if ( ins->l.t != mop_d || !ins->l.d ) 
        return 0;

    minsn_t* cmp = ins->l.d;

    // Check if comparing something with itself
    if ( !cmp->l.equal_mops(cmp->r, EQ_IGNSIZE) ) 
        return 0;

    // x == x -> 1
    // x != x -> 0
    // x < x -> 0
    // x >= x -> 1
    // etc.
    int result = 0;
    switch ( op ) {
        case m_setz:   // ==
        case m_setge:  // >= (signed)
        case m_setae:  // >= (unsigned)
        case m_setle:  // <= (signed)
        case m_setbe:  // <= (unsigned)
            result = 1;
            break;
        case m_setnz:  // !=
        case m_setl:   // < (signed)
        case m_setb:   // < (unsigned)
        case m_setg:   // > (signed)
        case m_seta:   // > (unsigned)
            result = 0;
            break;
        default:
            return 0;
    }

    ins->opcode = m_mov;
    ins->l.make_number(result, ins->d.size);
    ins->r.erase();
    hit_count_++;
    return 1;
}

//--------------------------------------------------------------------------
// Handler implementation
//--------------------------------------------------------------------------

void peephole_handler_t::initialize()
{
    if ( initialized_ ) 
        return;

    optimizers_.clear();
    optimizers_.push_back(std::make_unique<ConstantCallFoldOptimizer>());
    optimizers_.push_back(std::make_unique<ReadOnlyDataFoldOptimizer>());
    optimizers_.push_back(std::make_unique<ShiftByZeroOptimizer>());
    optimizers_.push_back(std::make_unique<DoubleNegationOptimizer>());
    optimizers_.push_back(std::make_unique<PowerOfTwoOptimizer>());
    optimizers_.push_back(std::make_unique<SelfCompareOptimizer>());
    // LocalConstProp needs block-level state, handle separately

    initialized_ = true;
    msg("[chernobog] Peephole optimizers initialized (%zu optimizers)\n",
        optimizers_.size());
}

bool peephole_handler_t::detect(mbl_array_t* mba)
{
    // Peephole optimizations are always applicable
    return mba != nullptr;
}

int peephole_handler_t::run(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    if ( !initialized_ ) 
        initialize();

    int total_changes = 0;

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk) continue;

        // Block-level optimizer for const propagation
        LocalConstPropOptimizer const_prop;

        for ( minsn_t* ins = blk->head; ins; ins = ins->next ) {
            // Run all optimizers
            for ( auto& opt : optimizers_ ) {
                int changes = opt->optimize(blk, ins);
                total_changes += changes;
            }

            // Run const propagation
            total_changes += const_prop.optimize(blk, ins);
        }
    }

    if ( total_changes > 0 ) {
        ctx->expressions_simplified += total_changes;
        deobf::log_verbose("[Peephole] Applied %d optimizations\n", total_changes);
    }

    return total_changes;
}

int peephole_handler_t::simplify_insn(mblock_t* blk, minsn_t* ins, deobf_ctx_t* ctx) {
    if ( !initialized_ ) 
        initialize();

    int total_changes = 0;

    for ( auto& opt : optimizers_ ) {
        int changes = opt->optimize(blk, ins);
        total_changes += changes;
    }

    if ( total_changes > 0 && ctx ) {
        ctx->expressions_simplified += total_changes;
    }

    return total_changes;
}

void peephole_handler_t::dump_statistics()
{
    msg("[chernobog] Peephole Optimizer Statistics:\n");
    for ( auto& opt : optimizers_ ) {
        msg("  %s: %zu hits\n", opt->name(), opt->hit_count());
    }
}

void peephole_handler_t::reset_statistics()
{
    for ( auto& opt : optimizers_ ) {
        opt->reset_stats();
    }
}

} // namespace peephole
} // namespace chernobog

```

`src/deobf/handlers/peephole.h`:

```h
#pragma once
#include "../deobf_types.h"
#include <vector>
#include <memory>

//--------------------------------------------------------------------------
// Peephole Optimizers
//
// Collection of small, targeted optimizations that run on individual
// instructions. Each optimizer handles a specific pattern.
//
// Optimizers included:
//   - ConstantCallFold: Fold helper calls with constant args (rotate, etc.)
//   - ReadOnlyDataFold: Fold loads from read-only memory
//   - LocalConstProp: Propagate constants through local variables
//   - DeadCodeElim: Remove dead stores and unused computations
//
// Ported from d810-ng's peephole optimization passes
//--------------------------------------------------------------------------

namespace chernobog {
namespace peephole {

//--------------------------------------------------------------------------
// Base class for peephole optimizers
//--------------------------------------------------------------------------
class PeepholeOptimizer {
public:
    virtual ~PeepholeOptimizer() = default;

    // Optimizer name for logging
    virtual const char* name() const = 0;

    // Try to optimize the instruction
    // Returns 1 if optimized, 0 otherwise
    virtual int optimize(mblock_t* blk, minsn_t* ins) = 0;

    // Statistics
    size_t hit_count() const { return hit_count_; }
    void reset_stats() { hit_count_ = 0; }

protected:
    size_t hit_count_ = 0;
};

//--------------------------------------------------------------------------
// Fold helper function calls with constant arguments
// e.g., __ROL4__(x, 0) -> x, __ROR4__(const, n) -> result
//--------------------------------------------------------------------------
class ConstantCallFoldOptimizer : public PeepholeOptimizer {
public:
    const char* name() const override { return "ConstantCallFold"; }
    int optimize(mblock_t* blk, minsn_t* ins) override;

private:
    // Check if function is a rotate helper
    static bool is_rotate_helper(ea_t func_ea, int* bits, bool* is_left);

    // Evaluate rotate with constants
    static uint64_t eval_rotate(uint64_t val, int shift, int bits, bool left);
};

//--------------------------------------------------------------------------
// Fold loads from read-only memory (constants, vtables, etc.)
//--------------------------------------------------------------------------
class ReadOnlyDataFoldOptimizer : public PeepholeOptimizer {
public:
    const char* name() const override { return "ReadOnlyDataFold"; }
    int optimize(mblock_t* blk, minsn_t* ins) override;

private:
    // Check if address is in read-only segment
    static bool is_readonly_addr(ea_t addr);

    // Read value from read-only memory
    static bool read_const_value(ea_t addr, int size, uint64_t* out);
};

//--------------------------------------------------------------------------
// Propagate constants through stack variables
//--------------------------------------------------------------------------
class LocalConstPropOptimizer : public PeepholeOptimizer {
public:
    const char* name() const override { return "LocalConstProp"; }
    int optimize(mblock_t* blk, minsn_t* ins) override;

private:
    // Track constant values stored to stack
    std::map<sval_t, uint64_t> stack_constants_;
};

//--------------------------------------------------------------------------
// Simplify shifts by zero
//--------------------------------------------------------------------------
class ShiftByZeroOptimizer : public PeepholeOptimizer {
public:
    const char* name() const override { return "ShiftByZero"; }
    int optimize(mblock_t* blk, minsn_t* ins) override;
};

//--------------------------------------------------------------------------
// Fold double negation: ~~x -> x, -(-x) -> x
//--------------------------------------------------------------------------
class DoubleNegationOptimizer : public PeepholeOptimizer {
public:
    const char* name() const override { return "DoubleNegation"; }
    int optimize(mblock_t* blk, minsn_t* ins) override;
};

//--------------------------------------------------------------------------
// Fold multiplication/division by powers of 2
//--------------------------------------------------------------------------
class PowerOfTwoOptimizer : public PeepholeOptimizer {
public:
    const char* name() const override { return "PowerOfTwo"; }
    int optimize(mblock_t* blk, minsn_t* ins) override;

private:
    static bool is_power_of_2(uint64_t val, int* shift);
};

//--------------------------------------------------------------------------
// Simplify comparison with self: x == x -> true, x != x -> false
//--------------------------------------------------------------------------
class SelfCompareOptimizer : public PeepholeOptimizer {
public:
    const char* name() const override { return "SelfCompare"; }
    int optimize(mblock_t* blk, minsn_t* ins) override;
};

//--------------------------------------------------------------------------
// Peephole Handler - runs all optimizers
//--------------------------------------------------------------------------
class peephole_handler_t {
public:
    // Initialize optimizers
    static void initialize();

    // Detect if peephole patterns are present (always returns true)
    static bool detect(mbl_array_t* mba);

    // Run all peephole optimizations
    static int run(mbl_array_t* mba, deobf_ctx_t* ctx);

    // Instruction-level optimization
    static int simplify_insn(mblock_t* blk, minsn_t* ins, deobf_ctx_t* ctx);

    // Statistics
    static void dump_statistics();
    static void reset_statistics();

private:
    static std::vector<std::unique_ptr<PeepholeOptimizer>> optimizers_;
    static bool initialized_;
};

} // namespace peephole
} // namespace chernobog

```

`src/deobf/handlers/ptr_resolve.cpp`:

```cpp
#include "ptr_resolve.h"

//--------------------------------------------------------------------------
// Detection
//--------------------------------------------------------------------------
bool ptr_resolve_handler_t::detect(mbl_array_t *mba)
{
    if ( !mba ) 
        return false;

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            ptr_ref_t ref;

            // Check left operand
            if ( is_indirect_ptr_ref(ins->l, &ref) ) 
                return true;

            // Check right operand
            if ( is_indirect_ptr_ref(ins->r, &ref) ) 
                return true;

            // Check address operand for address-of expressions
            if ( ins->l.t == mop_a && ins->l.a ) {
                if ( is_indirect_ptr_ref(*ins->l.a, &ref) ) 
                    return true;
            }
            if ( ins->r.t == mop_a && ins->r.a ) {
                if ( is_indirect_ptr_ref(*ins->r.a, &ref) ) 
                    return true;
            }
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// Main deobfuscation pass
//--------------------------------------------------------------------------
int ptr_resolve_handler_t::run(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    deobf::log("[ptr_resolve] Starting pointer reference resolution\n");

    int total_changes = 0;

    auto ptr_refs = find_ptr_refs(mba);
    deobf::log("[ptr_resolve] Found %zu pointer references to resolve\n", ptr_refs.size());

    // Track unique addresses we've annotated
    std::set<ea_t> annotated;

    for ( const auto &ref : ptr_refs ) {
        // Annotate the pointer location (only once per address)
        if ( annotated.find(ref.ptr_addr) == annotated.end() ) {
            annotate_ptr_ref(ref);
            annotated.insert(ref.ptr_addr);
            total_changes++;

            if ( ref.is_cfstring ) {
                deobf::log("[ptr_resolve]   %s -> @\"%s\"\n",
                          ref.ptr_name.c_str(),
                          ref.string_value.c_str());
            } else if ( ref.is_objc_class ) {
                deobf::log("[ptr_resolve]   %s -> %s (class: %s)\n",
                          ref.ptr_name.c_str(),
                          ref.target_name.c_str(),
                          ref.class_name.c_str());
            } else {
                deobf::log("[ptr_resolve]   %s -> %s\n",
                          ref.ptr_name.c_str(),
                          ref.target_name.c_str());
            }
        }
    }

    deobf::log("[ptr_resolve] Resolved %d pointer references\n", total_changes);
    return total_changes;
}

//--------------------------------------------------------------------------
// Find all indirect pointer references
//--------------------------------------------------------------------------
std::vector<ptr_resolve_handler_t::ptr_ref_t>
ptr_resolve_handler_t::find_ptr_refs(mbl_array_t *mba)
{
    std::vector<ptr_ref_t> result;
    std::set<ea_t> seen_addrs;

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            ptr_ref_t ref;
            ref.insn = ins;

            // Check direct global reference
            if ( is_indirect_ptr_ref(ins->l, &ref) ) {
                ref.ptr_mop = &ins->l;
                if ( seen_addrs.find(ref.ptr_addr) == seen_addrs.end() ) {
                    result.push_back(ref);
                    seen_addrs.insert(ref.ptr_addr);
                }
            }

            if ( is_indirect_ptr_ref(ins->r, &ref) ) {
                ref.ptr_mop = &ins->r;
                if ( seen_addrs.find(ref.ptr_addr) == seen_addrs.end() ) {
                    result.push_back(ref);
                    seen_addrs.insert(ref.ptr_addr);
                }
            }

            // Check address-of expressions: &off_XXXX
            if ( ins->l.t == mop_a && ins->l.a ) {
                if ( is_indirect_ptr_ref(*ins->l.a, &ref) ) {
                    ref.ptr_mop = ins->l.a;
                    if ( seen_addrs.find(ref.ptr_addr) == seen_addrs.end() ) {
                        result.push_back(ref);
                        seen_addrs.insert(ref.ptr_addr);
                    }
                }
            }
            if ( ins->r.t == mop_a && ins->r.a ) {
                if ( is_indirect_ptr_ref(*ins->r.a, &ref) ) {
                    ref.ptr_mop = ins->r.a;
                    if ( seen_addrs.find(ref.ptr_addr) == seen_addrs.end() ) {
                        result.push_back(ref);
                        seen_addrs.insert(ref.ptr_addr);
                    }
                }
            }
        }
    }

    return result;
}

//--------------------------------------------------------------------------
// Check if operand is an indirect pointer reference
//--------------------------------------------------------------------------
bool ptr_resolve_handler_t::is_indirect_ptr_ref(const mop_t &op, ptr_ref_t *out)
{
    if ( op.t != mop_v ) 
        return false;

    ea_t addr = op.g;
    if ( addr == BADADDR ) 
        return false;

    // Get the name at this address
    qstring name;
    if ( get_name(&name, addr) <= 0 ) 
        return false;

    // Look for patterns that suggest pointer indirection
    // Common patterns: off_XXXX, qword_XXXX, classRef_XXXX, selRef_XXXX
    bool is_indirect = false;

    if ( name.find("off_") == 0 ||
        name.find("qword_") == 0 ||
        name.find("classRef_") == 0 ||
        name.find("selRef_") == 0 ||
        name.find("stru_") == 0)
        {
        is_indirect = true;
    }

    // Also check if it's in an ObjC reference section
    if ( !is_indirect && is_objc_ref_section(addr) ) {
        is_indirect = true;
    }

    if ( !is_indirect ) 
        return false;

    // Try to resolve what this pointer points to
    if ( !resolve_ptr_target(addr, out) ) 
        return false;

    out->ptr_addr = addr;
    out->ptr_name = name;

    return true;
}

//--------------------------------------------------------------------------
// Resolve the target of a pointer
//--------------------------------------------------------------------------
bool ptr_resolve_handler_t::resolve_ptr_target(ea_t ptr_addr, ptr_ref_t *out)
{
    if ( !out ) 
        return false;

    // Initialize CFString fields
    out->is_cfstring = false;
    out->string_value.clear();

    // First, try to extract as a CFConstantString struct
    // This takes priority because CFConstantStrings are common in ObjC code
    qstring cf_string;
    if ( try_extract_cfstring(ptr_addr, &cf_string) ) {
        out->is_cfstring = true;
        out->string_value = cf_string;
        out->target_addr = ptr_addr;
        out->target_name.sprnt("@\"%s\"", cf_string.c_str());
        out->is_objc_class = false;
        return true;
    }

    // Read the pointer value
    ea_t target = get_qword(ptr_addr);
    if ( target == 0 || target == BADADDR ) 
        return false;

    // Get the name of the target
    qstring target_name;
    if ( get_name(&target_name, target) <= 0 ) 
        return false;

    // Skip if target name is also an auto-generated name (off_, qword_, etc)
    // We want to resolve to actual symbols
    if ( target_name.find("off_") == 0 ||
        target_name.find("qword_") == 0 ||
        target_name.find("unk_") == 0 ||
        target_name.find("byte_") == 0 ||
        target_name.find("word_") == 0 ||
        target_name.find("dword_") == 0)
        {
        return false;
    }

    out->target_addr = target;
    out->target_name = target_name;

    // Check if it's an ObjC class
    out->is_objc_class = extract_objc_class_name(target_name.c_str(), &out->class_name);

    return true;
}

//--------------------------------------------------------------------------
// Check if address is in ObjC reference section
//--------------------------------------------------------------------------
bool ptr_resolve_handler_t::is_objc_ref_section(ea_t addr)
{
    segment_t *seg = getseg(addr);
    if ( !seg ) 
        return false;

    qstring seg_name;
    get_segm_name(&seg_name, seg);

    // ObjC reference sections
    if ( seg_name == "__objc_classrefs" ||
        seg_name == "__objc_selrefs" ||
        seg_name == "__objc_superrefs" ||
        seg_name == "__objc_protorefs" ||
        seg_name == "__objc_classlist" ||
        seg_name == "__objc_catlist" ||
        seg_name == "__objc_protolist" ||
        seg_name == "__objc_data")
        {
        return true;
    }

    return false;
}

//--------------------------------------------------------------------------
// Extract class name from ObjC symbol
//--------------------------------------------------------------------------
bool ptr_resolve_handler_t::extract_objc_class_name(const char *symbol, qstring *out_class)
{
    if ( !symbol || !out_class ) 
        return false;

    // Pattern: _OBJC_CLASS_$_ClassName
    const char *class_prefix = "_OBJC_CLASS_$_";
    size_t prefix_len = strlen(class_prefix);

    if ( strncmp(symbol, class_prefix, prefix_len) == 0 ) {
        *out_class = symbol + prefix_len;
        return true;
    }

    // Pattern: _OBJC_METACLASS_$_ClassName
    const char *meta_prefix = "_OBJC_METACLASS_$_";
    size_t meta_len = strlen(meta_prefix);

    if ( strncmp(symbol, meta_prefix, meta_len) == 0 ) {
        *out_class = symbol + meta_len;
        return true;
    }

    return false;
}

//--------------------------------------------------------------------------
// Check if address is a CFConstantString struct and extract its content
//
// CFConstantString layout (64-bit):
//   offset 0:  void *isa          -> ___CFConstantStringClassReference
//   offset 8:  uint64_t flags     -> typically 0x7C8 (ASCII) or 0x7D0 (UTF16)
//   offset 16: const char *data   -> pointer to string bytes
//   offset 24: uint64_t length    -> string length
//--------------------------------------------------------------------------
bool ptr_resolve_handler_t::try_extract_cfstring(ea_t struct_addr, qstring *out_string)
{
    if ( struct_addr == BADADDR || !out_string ) 
        return false;

    // Read the ISA pointer
    ea_t isa_ptr = get_qword(struct_addr);
    if ( isa_ptr == 0 || isa_ptr == BADADDR ) 
        return false;

    // Check if ISA points to ___CFConstantStringClassReference
    qstring isa_name;
    if ( get_name(&isa_name, isa_ptr) <= 0 ) 
        return false;

    // Accept various CFConstantString class reference patterns
    if ( isa_name.find("CFConstantStringClassReference") == qstring::npos &&
        isa_name.find("__CFConstantStringClassReference") == qstring::npos)
        return false;

    // This IS a CFConstantString - now extract the string content
    deobf::log_verbose("[ptr_resolve] CFString struct at %a (isa=%s)\n",
                      struct_addr, isa_name.c_str());

    // Read the string data pointer (offset 16)
    ea_t data_ptr = get_qword(struct_addr + 16);
    deobf::log_verbose("[ptr_resolve]   data_ptr=%a, length=%llu\n",
                      data_ptr, (unsigned long long)get_qword(struct_addr + 24));
    if ( data_ptr == 0 || data_ptr == BADADDR ) {
        deobf::log_verbose("[ptr_resolve] CFString at %a: invalid data_ptr\n", struct_addr);
        return false;
    }

    // Read the length (offset 24)
    uint64_t length = get_qword(struct_addr + 24);
    if ( length > 4096 ) {  // Sanity check - allow 0 for empty strings
        deobf::log_verbose("[ptr_resolve] CFString at %a: length too large (%llu)\n",
                          struct_addr, (unsigned long long)length);
        return false;
    }

    // Handle empty strings
    if ( length == 0 ) {
        *out_string = "";
        return true;
    }

    // Try to read the string content
    size_t str_len = get_max_strlit_length(data_ptr, STRTYPE_C);
    if ( str_len == 0 ) {
        // Fallback: try reading directly using the length from the struct
        out_string->resize(length + 1);
        if ( get_bytes(out_string->begin(), length, data_ptr) == length ) {
            (*out_string)[length] = '\0';
            out_string->resize(length);
            return true;
        }
        deobf::log_verbose("[ptr_resolve] CFString at %a: get_max_strlit_length failed for %a\n",
                          struct_addr, data_ptr);
        return false;
    }

    // Use the smaller of the two lengths
    if ( str_len > length + 1 ) 
        str_len = length + 1;

    out_string->resize(str_len);
    if ( get_strlit_contents(out_string, data_ptr, str_len, STRTYPE_C) <= 0 ) {
        deobf::log_verbose("[ptr_resolve] CFString at %a: get_strlit_contents failed\n", struct_addr);
        return false;
    }

    return true;
}

//--------------------------------------------------------------------------
// Annotate the resolved reference
//--------------------------------------------------------------------------
void ptr_resolve_handler_t::annotate_ptr_ref(const ptr_ref_t &ref)
{
    if ( ref.ptr_addr == BADADDR ) 
        return;

    qstring comment;
    qstring new_name;

    if ( ref.is_cfstring ) {
        // For CFConstantStrings, show the string content
        comment.sprnt("@\"%s\"", ref.string_value.c_str());

        // Create a name based on the string content (sanitized)
        qstring sanitized = ref.string_value;
        // Truncate long strings
        if ( sanitized.length() > 20 ) 
            sanitized.resize(20);
        // Replace non-identifier characters with underscores
        for ( size_t i = 0; i < sanitized.length(); ++i ) {
            char c = sanitized[i];
            if ( !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
                  (c >= '0' && c <= '9') || c == '_'))
                  {
                sanitized[i] = '_';
            }
        }
        new_name.sprnt("cfstr_%s", sanitized.c_str());
    } else if ( ref.is_objc_class ) {
        comment.sprnt("-> %s (class %s)", ref.target_name.c_str(), ref.class_name.c_str());
        new_name.sprnt("classRef_%s", ref.class_name.c_str());
    } else {
        comment.sprnt("-> %s", ref.target_name.c_str());
        // Create a reasonable name based on target
        qstring target_base = ref.target_name;
        // Remove leading underscore if present
        if ( target_base[0] == '_' ) 
            target_base.remove(0, 1);
        new_name.sprnt("ptr_%s", target_base.c_str());
    }

    // Set a repeatable comment at the pointer location
    set_cmt(ref.ptr_addr, comment.c_str(), true);

    // Rename the pointer if it has an auto-generated name
    if ( ref.ptr_name.find("off_") == 0 || ref.ptr_name.find("qword_") == 0 ||
        ref.ptr_name.find("stru_") == 0)
        {
        // Try to set the name (may fail if name exists)
        set_name(ref.ptr_addr, new_name.c_str(), SN_NOWARN | SN_NOCHECK);
    }
}

//--------------------------------------------------------------------------
// Replace indirect reference with direct reference
//--------------------------------------------------------------------------
int ptr_resolve_handler_t::replace_ptr_ref(mblock_t *blk, minsn_t *ins, const ptr_ref_t &ref)
{
    // For now, we only annotate. Replacing the operand directly could break
    // code that actually needs the indirection (e.g., for relocation).
    // The annotation provides the information without changing semantics.
    return 0;
}

```

`src/deobf/handlers/ptr_resolve.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Pointer Reference Resolution Handler
//
// Resolves indirect pointer references to their actual targets.
// This is common in ObjC code where class references go through an
// indirection table.
//
// Example:
//   v164 = &off_1000102A8;   ; where off_1000102A8 -> _OBJC_CLASS_$_NSArray
// The decompiler shows this as an opaque pointer, but we can resolve it
// to show the actual class being referenced.
//
// Pattern:
//   __objc_classrefs:00000001000102A8 off_1000102A8 dq offset _OBJC_CLASS_$_NSConstantArray
//
// This handler:
//   1. Finds references to pointer globals (off_XXXX pattern)
//   2. Reads the pointer value
//   3. Resolves to the target symbol
//   4. Annotates or replaces the reference
//--------------------------------------------------------------------------
class ptr_resolve_handler_t {
public:
    // Detection
    static bool detect(mbl_array_t *mba);

    // Main deobfuscation pass
    static int run(mbl_array_t *mba, deobf_ctx_t *ctx);

private:
    struct ptr_ref_t {
        minsn_t *insn;          // Instruction using the pointer
        mop_t *ptr_mop;         // The pointer operand
        ea_t ptr_addr;          // Address of the pointer variable (e.g., off_XXXX)
        ea_t target_addr;       // What the pointer points to
        qstring ptr_name;       // Name of the pointer (off_XXXX)
        qstring target_name;    // Name of the target (_OBJC_CLASS_$_...)
        bool is_objc_class;     // Is this an ObjC class reference?
        qstring class_name;     // Extracted class name (without prefix)
        bool is_cfstring;       // Is this a CFConstantString?
        qstring string_value;   // Extracted string content for CFConstantStrings
    };

    // Find all indirect pointer references
    static std::vector<ptr_ref_t> find_ptr_refs(mbl_array_t *mba);

    // Check if an operand is an indirect pointer reference
    static bool is_indirect_ptr_ref(const mop_t &op, ptr_ref_t *out);

    // Resolve the target of a pointer
    static bool resolve_ptr_target(ea_t ptr_addr, ptr_ref_t *out);

    // Check if address is in ObjC reference sections
    static bool is_objc_ref_section(ea_t addr);

    // Extract class name from ObjC symbol
    static bool extract_objc_class_name(const char *symbol, qstring *out_class);

    // Check if address is a CFConstantString struct and extract its content
    static bool try_extract_cfstring(ea_t struct_addr, qstring *out_string);

    // Annotate the resolved reference
    static void annotate_ptr_ref(const ptr_ref_t &ref);

    // Replace indirect reference with direct reference (where possible)
    static int replace_ptr_ref(mblock_t *blk, minsn_t *ins, const ptr_ref_t &ref);
};

```

`src/deobf/handlers/savedregs.cpp`:

```cpp
#include "savedregs.h"

//--------------------------------------------------------------------------
// Detection
//--------------------------------------------------------------------------
bool savedregs_handler_t::detect(mbl_array_t *mba)
{
    if ( !mba ) 
        return false;

    int savedregs_refs = 0;
    int indirect_calls = 0;

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            // Count savedregs references
            sval_t offset;
            if ( is_savedregs_ref(ins->l, &offset) ||
                is_savedregs_ref(ins->r, &offset) ||
                is_savedregs_ref(ins->d, &offset))
                {
                savedregs_refs++;
            }

            // Count indirect calls through savedregs
            if ( ins->opcode == m_icall || ins->opcode == m_call ) {
                if ( ins->l.t == mop_d && ins->l.d ) {
                    // Check if call target is loaded from savedregs
                    minsn_t *inner = ins->l.d;
                    if ( inner->opcode == m_ldx || inner->opcode == m_mov ) {
                        if ( is_savedregs_ref(inner->l, &offset) ) {
                            indirect_calls++;
                        }
                    }
                }
            }
        }
    }

    // If we have both savedregs references and indirect calls, likely obfuscated
    return savedregs_refs >= 5 && indirect_calls >= 1;
}

//--------------------------------------------------------------------------
// Check if operand is a savedregs reference
//--------------------------------------------------------------------------
bool savedregs_handler_t::is_savedregs_ref(const mop_t &op, sval_t *out_offset)
{
    // Pattern: &savedregs - N  or  *(&savedregs - N)
    // In microcode: mop_S with negative offset from frame

    if ( op.t == mop_S && op.s ) {
        // Stack variable reference
        // Savedregs typically have negative offsets from frame base
        if ( op.s->off < 0 ) {
            if ( out_offset ) 
                *out_offset = op.s->off;
            return true;
        }
    }

    // Also check for address expressions
    if ( op.t == mop_a && op.a ) {
        if ( op.a->t == mop_S && op.a->s ) {
            if ( op.a->s->off < 0 ) {
                if ( out_offset ) 
                    *out_offset = op.a->s->off;
                return true;
            }
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// Classify a value by its address
//--------------------------------------------------------------------------
savedregs_handler_t::slot_type_t
savedregs_handler_t::classify_value(ea_t addr) {
    if ( addr == BADADDR ) 
        return SLOT_UNKNOWN;

    // Check if it's a function
    func_t *fn = get_func(addr);
    if ( fn ) {
        return SLOT_FUNC_PTR;
    }

    // Check if address points to code (might be a function start)
    flags64_t flags = get_flags(addr);
    if ( is_code(flags) ) {
        return SLOT_FUNC_PTR;
    }

    // Check if it's a string
    size_t len = get_max_strlit_length(addr, STRTYPE_C);
    if ( len > 0 && len < 1024 ) {
        // Check if it looks like an ObjC selector
        qstring str;
        str.resize(len);
        if ( get_strlit_contents(&str, addr, len, STRTYPE_C) > 0 ) {
            // ObjC selectors often contain colons
            if ( str.find(':') != qstring::npos ) {
                return SLOT_SELECTOR;
            }
            return SLOT_STRING;
        }
    }

    return SLOT_VALUE;
}

//--------------------------------------------------------------------------
// Check if address is an objc_msgSend variant
//--------------------------------------------------------------------------
bool savedregs_handler_t::is_objc_msgsend(ea_t addr)
{
    if ( addr == BADADDR ) 
        return false;

    qstring name;
    if ( get_name(&name, addr) > 0 ) {
        // Check various objc_msgSend variants
        if ( name.find("objc_msgSend") != qstring::npos ) 
            return true;
        if ( name.find("_objc_msgSend") != qstring::npos ) 
            return true;
        // Also check for mangled names
        if ( name.find("msgSend") != qstring::npos ) 
            return true;
    }

    return false;
}

//--------------------------------------------------------------------------
// Analyze all savedregs writes in function
//--------------------------------------------------------------------------
void savedregs_handler_t::analyze_savedregs_writes(
    mbl_array_t *mba,
    std::map<sval_t, slot_info_ext_t> &slots)
{
    if ( !mba ) 
        return;

    slots.clear();

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            // Look for writes to savedregs slots
            if ( ins->opcode == m_mov || ins->opcode == m_stx ) {
                sval_t offset;
                if ( !is_savedregs_ref(ins->d, &offset) ) 
                    continue;

                slot_info_ext_t info;
                info.offset = offset;
                info.type = SLOT_UNKNOWN;
                info.func_addr = BADADDR;
                info.value = 0;
                info.is_objc_msgsend = false;

                // Analyze source operand
                if ( ins->l.t == mop_n ) {
                    // Immediate value
                    info.type = SLOT_VALUE;
                    info.value = ins->l.nnn->value;
                }
                else if ( ins->l.t == mop_v ) {
                    // Global address
                    ea_t addr = ins->l.g;
                    info.type = classify_value(addr);

                    if ( info.type == SLOT_FUNC_PTR ) {
                        info.func_addr = addr;
                        info.is_objc_msgsend = is_objc_msgsend(addr);
                    }
                    else if ( info.type == SLOT_STRING || info.type == SLOT_SELECTOR ) {
                        size_t len = get_max_strlit_length(addr, STRTYPE_C);
                        if ( len > 0 && len < 1024 ) {
                            info.string_val.resize(len);
                            get_strlit_contents(&info.string_val, addr, len, STRTYPE_C);
                        }
                    }
                    else {
                        info.value = addr;
                    }
                }
                else if ( ins->l.t == mop_a && ins->l.a ) {
                    // Address expression &something
                    if ( ins->l.a->t == mop_v ) {
                        ea_t addr = ins->l.a->g;
                        info.type = classify_value(addr);

                        if ( info.type == SLOT_FUNC_PTR ) {
                            info.func_addr = addr;
                            info.is_objc_msgsend = is_objc_msgsend(addr);
                        }
                        else if ( info.type == SLOT_STRING || info.type == SLOT_SELECTOR ) {
                            size_t len = get_max_strlit_length(addr, STRTYPE_C);
                            if ( len > 0 && len < 1024 ) {
                                info.string_val.resize(len);
                                get_strlit_contents(&info.string_val, addr, len, STRTYPE_C);
                            }
                        }
                    }
                }

                // Store the slot info
                slots[offset] = info;
            }
        }
    }
}

//--------------------------------------------------------------------------
// Resolve an indirect call through savedregs
//--------------------------------------------------------------------------
bool savedregs_handler_t::resolve_indirect_call(
    mblock_t *blk,
    minsn_t *call_insn,
    const std::map<sval_t, slot_info_ext_t> &slots,
    resolved_call_t *out)
{
    if ( !blk || !call_insn || !out ) 
        return false;

    // Check if this is an indirect call
    if ( call_insn->opcode != m_icall && call_insn->opcode != m_call ) 
        return false;

    // Get the call target
    sval_t target_offset = 0;
    bool found_target = false;

    // Check direct savedregs reference in call target
    if ( is_savedregs_ref(call_insn->l, &target_offset) ) {
        found_target = true;
    }
    // Check nested instruction (ldx/mov from savedregs)
    else if ( call_insn->l.t == mop_d && call_insn->l.d ) {
        minsn_t *inner = call_insn->l.d;
        if ( inner->opcode == m_ldx || inner->opcode == m_mov ) {
            if ( is_savedregs_ref(inner->l, &target_offset) ) {
                found_target = true;
            }
        }
    }

    if ( !found_target ) 
        return false;

    // Look up the target in our slot map
    auto p = slots.find(target_offset);
    if ( p == slots.end() ) 
        return false;

    const slot_info_ext_t &slot = p->second;
    if ( slot.type != SLOT_FUNC_PTR || slot.func_addr == BADADDR ) 
        return false;

    // Fill in resolved call info
    out->call_addr = call_insn->ea;
    out->target_func = slot.func_addr;
    out->is_objc = slot.is_objc_msgsend;

    // Get target function name
    get_name(&out->target_name, slot.func_addr);

    // Extract arguments from savedregs
    extract_call_args(call_insn, slots, out);

    return true;
}

//--------------------------------------------------------------------------
// Extract call arguments from savedregs
//--------------------------------------------------------------------------
bool savedregs_handler_t::extract_call_args(
    minsn_t *call_insn,
    const std::map<sval_t, slot_info_ext_t> &slots,
    resolved_call_t *out)
{
    if ( !call_insn || !out ) 
        return false;

    out->args.clear();
    out->selector.clear();

    // For icall, arguments are in the r operand as mcallargs_t
    if ( call_insn->opcode == m_icall ) {
        if ( call_insn->d.t == mop_f && call_insn->d.f ) {
            mcallinfo_t *ci = call_insn->d.f;

            // Iterate through call arguments
            for ( size_t i = 0; i < ci->args.size(); ++i ) {
                mcallarg_t &arg = ci->args[i];

                sval_t offset;
                if ( is_savedregs_ref(arg, &offset) ) {
                    auto p = slots.find(offset);
                    if ( p != slots.end() ) {
                        const slot_info_ext_t &slot = p->second;

                        if ( slot.type == SLOT_STRING || slot.type == SLOT_SELECTOR ) {
                            out->args.push_back(slot.string_val);

                            // For ObjC calls, the selector is typically arg 1 (after self)
                            if ( out->is_objc && i == 1 && slot.type == SLOT_SELECTOR ) {
                                out->selector = slot.string_val;
                            }
                        }
                    }
                }
            }
        }
    }

    return !out->args.empty() || !out->selector.empty();
}

//--------------------------------------------------------------------------
// Transform a call to use direct target
//--------------------------------------------------------------------------
bool savedregs_handler_t::transform_call(
    mblock_t *blk,
    minsn_t *call_insn,
    const resolved_call_t &resolved)
{
    if ( !blk || !call_insn ) 
        return false;

    // For now, we just annotate rather than transform
    // Full transformation would require:
    // 1. Changing icall to call
    // 2. Setting direct target address
    // 3. Fixing up call arguments

    // This is complex because argument handling differs between
    // direct and indirect calls in microcode

    return false;
}

//--------------------------------------------------------------------------
// Format ObjC call for annotation
//--------------------------------------------------------------------------
qstring savedregs_handler_t::format_objc_call(const resolved_call_t &resolved) {
    qstring result;

    if ( !resolved.selector.empty() ) {
        // Format: [obj selector:arg1 param2:arg2 ...]
        // For now, just show the selector
        result.sprnt("[... %s]", resolved.selector.c_str());
    }
    else {
        result.sprnt("objc_msgSend(...)");
    }

    return result;
}

//--------------------------------------------------------------------------
// Annotate a resolved call
//--------------------------------------------------------------------------
void savedregs_handler_t::annotate_call(ea_t call_addr, const resolved_call_t &resolved)
{
    if ( call_addr == BADADDR ) 
        return;

    qstring comment;

    if ( resolved.is_objc ) {
        // ObjC-style annotation
        if ( !resolved.selector.empty() ) {
            comment.sprnt("DEOBF: ObjC call - [obj %s]", resolved.selector.c_str());
        }
        else {
            comment.sprnt("DEOBF: ObjC call - %s", resolved.target_name.c_str());
        }
    }
    else {
        // Regular function call
        comment.sprnt("DEOBF: Indirect call to %s (0x%llX)",
                     resolved.target_name.c_str(),
                     (unsigned long long)resolved.target_func);
    }

    // Add string arguments to comment
    for ( size_t i = 0; i < resolved.args.size(); ++i ) {
        if ( i == 0 && resolved.is_objc && resolved.args[i] == resolved.selector ) 
            continue;  // Skip selector, already shown

        qstring arg_comment;
        arg_comment.sprnt("\n  arg[%d]: \"%s\"", (int)i, resolved.args[i].c_str());
        comment += arg_comment;
    }

    // Set the comment
    set_cmt(call_addr, comment.c_str(), false);
}

//--------------------------------------------------------------------------
// Main processing
//--------------------------------------------------------------------------
int savedregs_handler_t::run(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    int changes = 0;

    // Step 1: Analyze all savedregs writes
    std::map<sval_t, slot_info_ext_t> slots;
    analyze_savedregs_writes(mba, slots);

    if ( slots.empty() ) {
        deobf::log("[savedregs] No savedregs slots found\n");
        return 0;
    }

    deobf::log("[savedregs] Found %d savedregs slots\n", (int)slots.size());

    // Log interesting slots
    for ( const auto &pair : slots ) {
        const slot_info_ext_t &slot = pair.second;
        switch ( slot.type ) {
            case SLOT_FUNC_PTR:
                deobf::log("[savedregs]   offset %d: func %s (0x%llX)%s\n",
                          (int)slot.offset,
                          slot.string_val.empty() ? "unknown" : slot.string_val.c_str(),
                          (unsigned long long)slot.func_addr,
                          slot.is_objc_msgsend ? " [objc_msgSend]" : "");
                break;
            case SLOT_SELECTOR:
                deobf::log("[savedregs]   offset %d: selector \"%s\"\n",
                          (int)slot.offset, slot.string_val.c_str());
                break;
            case SLOT_STRING:
                deobf::log("[savedregs]   offset %d: string \"%s\"\n",
                          (int)slot.offset, slot.string_val.c_str());
                break;
            default:
                break;
        }
    }

    // Step 2: Find and resolve indirect calls through savedregs
    std::vector<resolved_call_t> resolved_calls;

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            if ( ins->opcode == m_icall || ins->opcode == m_call ) {
                resolved_call_t resolved;
                if ( resolve_indirect_call(blk, ins, slots, &resolved) ) {
                    resolved_calls.push_back(resolved);
                    changes++;
                }
            }
        }
    }

    deobf::log("[savedregs] Resolved %d indirect calls\n", (int)resolved_calls.size());

    // Step 3: Annotate resolved calls
    for ( const auto &resolved : resolved_calls ) {
        annotate_call(resolved.call_addr, resolved);

        if ( resolved.is_objc ) {
            deobf::log("[savedregs]   0x%llX: %s\n",
                      (unsigned long long)resolved.call_addr,
                      format_objc_call(resolved).c_str());
        }
        else {
            deobf::log("[savedregs]   0x%llX: call %s\n",
                      (unsigned long long)resolved.call_addr,
                      resolved.target_name.c_str());
        }
    }

    ctx->indirect_resolved += changes;
    return changes;
}

//--------------------------------------------------------------------------
// Per-instruction simplification
//--------------------------------------------------------------------------
int savedregs_handler_t::simplify_insn(mblock_t *blk, minsn_t *ins, deobf_ctx_t *ctx) {
    // This is called during microcode optimization
    // We can't do much here since we need full function context
    // The main work is done in run()
    return 0;
}

```

`src/deobf/handlers/savedregs.h`:

```h
#pragma once
#include "../deobf_types.h"
#include "../analysis/stack_tracker.h"

//--------------------------------------------------------------------------
// SavedRegs Pattern Handler
//
// Handles "Register Demotion" / Stack Spilling obfuscation where:
//   - Arguments/values normally in registers are forced to stack
//   - Indirect calls use stack slots: *(&savedregs - N)(args)
//   - Function pointers stored on stack before being called
//   - Selector strings stored on stack for ObjC calls
//
// Example patterns:
//   *(&savedregs - 133) = "countByEnumeratingWithState:objects:count:";
//   *(&savedregs - 132) = &objc_msgSend;
//   v153 = (*(&savedregs - 132))(..., *(&savedregs - 133), ...);
//
// Resolution approach:
//   1. Analyze all writes to savedregs slots
//   2. Track function pointers and strings
//   3. Resolve indirect calls through savedregs
//   4. Annotate calls with resolved targets and selectors
//--------------------------------------------------------------------------
class savedregs_handler_t {
public:
    // Detection
    static bool detect(mbl_array_t *mba);

    // Main processing
    static int run(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Per-instruction simplification (called from optinsn_t)
    static int simplify_insn(mblock_t *blk, minsn_t *ins, deobf_ctx_t *ctx);

private:
    // Resolved call information
    struct resolved_call_t {
        ea_t call_addr;             // Address of the call instruction
        ea_t target_func;           // Resolved function target
        qstring target_name;        // Name of target function
        qstring selector;           // ObjC selector (if applicable)
        std::vector<qstring> args;  // String arguments from savedregs
        bool is_objc;               // True if this is an ObjC call
    };

    // Slot classification
    enum slot_type_t {
        SLOT_UNKNOWN,
        SLOT_FUNC_PTR,      // Function pointer
        SLOT_SELECTOR,      // ObjC selector string
        SLOT_STRING,        // Other string
        SLOT_VALUE,         // Numeric value
        SLOT_OBJECT,        // Object pointer
    };

    struct slot_info_ext_t {
        sval_t offset;
        slot_type_t type;
        ea_t func_addr;         // For SLOT_FUNC_PTR
        qstring string_val;     // For SLOT_STRING/SLOT_SELECTOR
        uint64_t value;         // For SLOT_VALUE
        bool is_objc_msgsend;   // True if func is objc_msgSend variant
    };

    // Analysis functions
    static void analyze_savedregs_writes(mbl_array_t *mba,
                                         std::map<sval_t, slot_info_ext_t> &slots);

    static bool is_savedregs_ref(const mop_t &op, sval_t *out_offset);

    static slot_type_t classify_value(ea_t addr);

    static bool is_objc_msgsend(ea_t addr);

    // Call resolution
    static bool resolve_indirect_call(mblock_t *blk, minsn_t *call_insn,
                                     const std::map<sval_t, slot_info_ext_t> &slots,
                                     resolved_call_t *out);

    static bool extract_call_args(minsn_t *call_insn,
                                 const std::map<sval_t, slot_info_ext_t> &slots,
                                 resolved_call_t *out);

    // Transformation
    static bool transform_call(mblock_t *blk, minsn_t *call_insn,
                              const resolved_call_t &resolved);

    // Annotation
    static void annotate_call(ea_t call_addr, const resolved_call_t &resolved);

    // ObjC specific
    static qstring format_objc_call(const resolved_call_t &resolved);
};

```

`src/deobf/handlers/stack_string.cpp`:

```cpp
#include "stack_string.h"
#include "../analysis/pattern_match.h"
#include <algorithm>

//--------------------------------------------------------------------------
// Detection - Check if function likely has stack strings
//--------------------------------------------------------------------------
bool stack_string_handler_t::detect(mbl_array_t *mba)
{
    if ( !mba ) 
        return false;

    int consecutive_byte_stores = 0;

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        consecutive_byte_stores = 0;
        sval_t last_offset = SVAL_MIN;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            byte_store_t store;
            if ( is_stack_byte_store(ins, &store) ) {
                // Check if this is sequential or near-sequential
                if ( last_offset != SVAL_MIN ) {
                    sval_t diff = store.offset - last_offset;
                    if ( diff >= -2 && diff <= 2 ) {
                        consecutive_byte_stores++;
                        if ( consecutive_byte_stores >= 4 ) {
                            // Found at least 4 consecutive byte stores - likely a string
                            return true;
                        }
                    } else {
                        consecutive_byte_stores = 1;
                    }
                } else {
                    consecutive_byte_stores = 1;
                }
                last_offset = store.offset;
            }
        }
    }

    return false;
}

bool stack_string_handler_t::detect_in_function(ea_t func_ea)
{
    func_t *func = get_func(func_ea);
    if ( !func ) 
        return false;

    // Look for byte store patterns at assembly level
    int consecutive = 0;
    ea_t last_addr = BADADDR;

    ea_t curr = func->start_ea;
    while ( curr < func->end_ea ) {
        insn_t insn;
        if ( decode_insn(&insn, curr) == 0 ) 
            break;

        // Look for mov [rbp-X], imm8 or mov [rsp+X], imm8 patterns
        // This is simplified - real implementation would check operand types

        curr = insn.ea + insn.size;
    }

    return false;
}

//--------------------------------------------------------------------------
// Main deobfuscation pass
//--------------------------------------------------------------------------
int stack_string_handler_t::run(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    deobf::log("[stack_string] Starting stack string reconstruction\n");

    int total_strings = 0;

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        auto strings = find_stack_strings(blk);

        for ( const auto &str : strings ) {
            if ( !str.value.empty() ) {
                deobf::log("[stack_string] Found string at stack offset %d: \"%s\"\n",
                          (int)str.stack_offset, str.value.c_str());

                // Annotate in IDA
                annotate_string(str, ctx->func_ea);

                // Store in context
                ctx->decrypted_strings[str.start_addr] = str.value;

                total_strings++;
            }
        }
    }

    deobf::log("[stack_string] Reconstructed %d stack strings\n", total_strings);
    return total_strings;
}

//--------------------------------------------------------------------------
// Process a single block
//--------------------------------------------------------------------------
int stack_string_handler_t::process_block(mblock_t *blk, deobf_ctx_t *ctx)
{
    if ( !blk || !ctx ) 
        return 0;

    auto strings = find_stack_strings(blk);
    return (int)strings.size();
}

//--------------------------------------------------------------------------
// Find stack strings in a block
//--------------------------------------------------------------------------
std::vector<stack_string_handler_t::stack_string_t>
stack_string_handler_t::find_stack_strings(mblock_t *blk)
{

    std::vector<stack_string_t> result;
    std::vector<byte_store_t> stores;

    // Collect all byte stores to stack
    for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
        byte_store_t store;
        if ( is_stack_byte_store(ins, &store) ) {
            stores.push_back(store);
        }
    }

    if ( stores.size() < 3 ) 
        return result;

    // Sort by stack offset
    std::sort(stores.begin(), stores.end(),
              [](const byte_store_t &a, const byte_store_t &b)
              {
                  return a.offset < b.offset;
              });

    // Find sequences of consecutive stores
    std::vector<byte_store_t> current_seq;
    sval_t expected_offset = SVAL_MIN;

    for ( size_t i = 0; i < stores.size(); ++i ) {
        const byte_store_t &store = stores[i];

        if ( expected_offset == SVAL_MIN ) {
            // Start new sequence
            current_seq.clear();
            current_seq.push_back(store);
            expected_offset = store.offset + 1;
        } else if ( store.offset == expected_offset ) {
            // Continue sequence
            current_seq.push_back(store);
            expected_offset = store.offset + 1;
        } else if ( store.offset == expected_offset - 1 ) {
            // Same offset (duplicate store) - skip
            continue;
        } else {
            // Sequence broken - check if we have a string
            if ( current_seq.size() >= 3 ) {
                stack_string_t str;
                if ( analyze_byte_sequence(current_seq, &str) ) {
                    result.push_back(str);
                }
            }

            // Start new sequence
            current_seq.clear();
            current_seq.push_back(store);
            expected_offset = store.offset + 1;
        }
    }

    // Check final sequence
    if ( current_seq.size() >= 3 ) {
        stack_string_t str;
        if ( analyze_byte_sequence(current_seq, &str) ) {
            result.push_back(str);
        }
    }

    return result;
}

//--------------------------------------------------------------------------
// Analyze a sequence of byte stores
//--------------------------------------------------------------------------
bool stack_string_handler_t::analyze_byte_sequence(
    const std::vector<byte_store_t> &stores, stack_string_t *out)
    {

    if ( stores.empty() ) 
        return false;

    std::string str;
    bool has_transform = false;
    bool has_null_term = false;

    for ( const auto &store : stores ) {
        uint8_t b = store.value;

        if ( b == 0 ) {
            has_null_term = true;
            break;  // Stop at null terminator
        }

        if ( !is_string_byte(b) ) {
            // Not a printable character - might not be a string
            // Allow some control characters
            if ( b != '\n' && b != '\r' && b != '\t' ) {
                return false;
            }
        }

        str += (char)b;
        if ( store.transformed ) 
            has_transform = true;
    }

    // Require at least 3 printable characters
    if ( str.length() < 3 ) 
        return false;

    // If no null terminator found but string looks valid, still accept it
    // (sometimes the null is stored separately or implicitly)

    out->start_addr = stores[0].insn_addr;
    out->stack_offset = stores[0].offset;
    out->value = str;
    out->uses_transform = has_transform;

    for ( const auto &store : stores ) {
        out->insn_addrs.push_back(store.insn_addr);
    }

    return true;
}

//--------------------------------------------------------------------------
// Check if instruction is a byte store to stack
//--------------------------------------------------------------------------
bool stack_string_handler_t::is_stack_byte_store(minsn_t *ins, byte_store_t *out)
{
    if ( !ins ) 
        return false;

    // Look for mov to stack variable with immediate or computed byte value
    if ( ins->opcode != m_mov && ins->opcode != m_stx ) 
        return false;

    // Destination must be a stack variable
    if ( ins->d.t != mop_S ) 
        return false;

    // Size must be 1 byte
    if ( ins->d.size != 1 ) 
        return false;

    // Get the value being stored
    uint8_t value = 0;
    bool transformed = false;

    if ( ins->l.t == mop_n ) {
        // Immediate value
        value = (uint8_t)(ins->l.nnn->value & 0xFF);
    } else if ( ins->l.t == mop_d && ins->l.d ) {
        // Computed value - try to resolve
        value = resolve_byte_value(ins->l.d);
        transformed = (ins->l.d->opcode == m_bnot || ins->l.d->opcode == m_xor);
    } else {
        return false;
    }

    if ( out ) {
        out->offset = ins->d.s ? ins->d.s->off : 0;
        out->value = value;
        out->insn_addr = ins->ea;
        out->transformed = transformed;
    }

    return true;
}

//--------------------------------------------------------------------------
// Resolve transformed byte value (NOT, XOR)
//--------------------------------------------------------------------------
uint8_t stack_string_handler_t::resolve_byte_value(minsn_t *ins)
{
    if ( !ins ) 
        return 0;

    // Handle NOT (~)
    if ( ins->opcode == m_bnot || ins->opcode == m_lnot ) {
        if ( ins->l.t == mop_n ) {
            return (uint8_t)(~ins->l.nnn->value & 0xFF);
        }
        // Could be NOT of another value - try to resolve recursively
        if ( ins->l.t == mop_d && ins->l.d ) {
            return ~resolve_byte_value(ins->l.d);
        }
    }

    // Handle XOR
    if ( ins->opcode == m_xor ) {
        uint8_t left = 0, right = 0;

        if ( ins->l.t == mop_n ) 
            left = (uint8_t)(ins->l.nnn->value & 0xFF);
        else if ( ins->l.t == mop_d && ins->l.d ) 
            left = resolve_byte_value(ins->l.d);

        if ( ins->r.t == mop_n ) 
            right = (uint8_t)(ins->r.nnn->value & 0xFF);
        else if ( ins->r.t == mop_d && ins->r.d ) 
            right = resolve_byte_value(ins->r.d);

        return left ^ right;
    }

    // Direct value
    if ( ins->l.t == mop_n ) {
        return (uint8_t)(ins->l.nnn->value & 0xFF);
    }

    return 0;
}

//--------------------------------------------------------------------------
// Check if byte is a valid string character
//--------------------------------------------------------------------------
bool stack_string_handler_t::is_string_byte(uint8_t b)
{
    // Printable ASCII
    if ( b >= 0x20 && b <= 0x7E ) 
        return true;

    // Common control characters
    if ( b == '\n' || b == '\r' || b == '\t' ) 
        return true;

    return false;
}

//--------------------------------------------------------------------------
// Annotate string in IDA
//--------------------------------------------------------------------------
void stack_string_handler_t::annotate_string(const stack_string_t &str, ea_t func_ea)
{
    if ( str.insn_addrs.empty() ) 
        return;

    // Add comment at the first instruction
    qstring comment;
    comment.sprnt("Stack string: \"%s\"", str.value.c_str());

    // Escape special characters for display
    qstring escaped;
    for ( char c : str.value ) {
        if ( c == '\n') escaped += "\\n";
        else if ( c == '\r') escaped += "\\r";
        else if ( c == '\t') escaped += "\\t";
        else if ( c == '"') escaped += "\\\"";
        else if ( c == '\\') escaped += "\\\\";
        else escaped += c;
    }

    comment.sprnt("Stack string: \"%s\"", escaped.c_str());
    set_cmt(str.insn_addrs[0], comment.c_str(), false);

    // Also add to function comment if significant
    if ( str.value.length() >= 8 ) {
        func_t *fn = get_func(func_ea);
        if ( fn ) {
            qstring func_cmt;
            func_cmt.sprnt("Contains string: \"%s\"", escaped.c_str());
            // Append to existing function comment
            qstring existing;
            if ( get_func_cmt(&existing, fn, false) > 0 ) {
                existing += "\n";
                existing += func_cmt;
                set_func_cmt(fn, existing.c_str(), false);
            } else {
                set_func_cmt(fn, func_cmt.c_str(), false);
            }
        }
    }
}

//--------------------------------------------------------------------------
// Try to patch string usage
//--------------------------------------------------------------------------
int stack_string_handler_t::patch_string_usage(mbl_array_t *mba,
    const stack_string_t &str, deobf_ctx_t *ctx)
    {
    // This is complex - would require creating a string in the data segment
    // and replacing the stack construction with a reference to it
    // For now, just annotate and let the analyst see the string
    return 0;
}

```

`src/deobf/handlers/stack_string.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// Stack String Reconstruction Handler
//
// Hikari/OLLVM builds strings at runtime to defeat static strings analysis:
//   - Individual bytes are moved to sequential stack offsets
//   - Sometimes uses qmemcpy for chunks
//   - May use bitwise NOT (~) to hide characters
//   - Terminated with null byte
//
// Example:
//   byte_10001435D = 46;   // '.'
//   byte_10001435E = 112;  // 'p'
//   byte_10001435F = 108;  // 'l'
//   ...
//   byte_100014363 = 0;    // NULL
//
// Detection:
//   - Sequences of mov [stack_offset], imm8 instructions
//   - Sequential or near-sequential addresses
//   - Printable ASCII values (0x20-0x7E) or null terminator
//
// Reversal:
//   1. Identify byte-by-byte construction sequences
//   2. Handle bitwise transformations (~, ^)
//   3. Reconstruct the string
//   4. Annotate in IDA and optionally patch to direct string reference
//--------------------------------------------------------------------------
class stack_string_handler_t {
public:
    // Detection
    static bool detect(mbl_array_t *mba);
    static bool detect_in_function(ea_t func_ea);

    // Main deobfuscation pass
    static int run(mbl_array_t *mba, deobf_ctx_t *ctx);

    // Instruction-level detection (called during microcode traversal)
    static int process_block(mblock_t *blk, deobf_ctx_t *ctx);

private:
    // Reconstructed string info
    struct stack_string_t {
        ea_t start_addr;            // Address where construction starts
        sval_t stack_offset;        // Base stack offset
        std::string value;          // Reconstructed string
        std::vector<ea_t> insn_addrs;  // Addresses of construction instructions
        bool uses_transform;        // Uses NOT/XOR transformation
    };

    // Byte store info for tracking
    struct byte_store_t {
        sval_t offset;              // Stack offset
        uint8_t value;              // Stored value (after any transforms)
        ea_t insn_addr;             // Instruction address
        bool transformed;           // Was a transform applied?
    };

    // Find stack string construction patterns in a block
    static std::vector<stack_string_t> find_stack_strings(mblock_t *blk);

    // Analyze a sequence of byte stores
    static bool analyze_byte_sequence(const std::vector<byte_store_t> &stores,
                                      stack_string_t *out);

    // Check if instruction is a byte store to stack
    static bool is_stack_byte_store(minsn_t *ins, byte_store_t *out);

    // Handle transformed bytes (NOT, XOR)
    static uint8_t resolve_byte_value(minsn_t *ins);

    // Check if byte is printable or control character
    static bool is_string_byte(uint8_t b);

    // Annotate reconstructed string in IDA
    static void annotate_string(const stack_string_t &str, ea_t func_ea);

    // Try to find the string usage and replace with direct reference
    static int patch_string_usage(mbl_array_t *mba, const stack_string_t &str,
                                  deobf_ctx_t *ctx);
};

```

`src/deobf/handlers/string_decrypt.cpp`:

```cpp
#include "string_decrypt.h"
#include "../analysis/pattern_match.h"

//--------------------------------------------------------------------------
// Detection
//--------------------------------------------------------------------------
bool string_decrypt_handler_t::detect(ea_t func_ea)
{
    // Look for Hikari string encryption markers in the binary

    // Check for EncryptedString/DecryptSpace globals
    segment_t *seg = get_first_seg();
    while ( seg ) {
        if ( seg->type == SEG_DATA ) {
            ea_t ea = seg->start_ea;
            while ( ea < seg->end_ea ) {
                qstring name;
                if ( get_name(&name, ea) > 0 ) {
                    if ( name.find("EncryptedString") != qstring::npos ||
                        name.find("DecryptSpace") != qstring::npos ||
                        name.find("StringEncryptionEncStatus") != qstring::npos)
                        {
                        return true;
                    }
                }
                ea = next_head(ea, seg->end_ea);
                if ( ea == BADADDR ) 
                    break;
            }
        }
        seg = get_next_seg(seg->start_ea);
    }

    return false;
}

//--------------------------------------------------------------------------
// Main deobfuscation pass
//--------------------------------------------------------------------------
int string_decrypt_handler_t::run(mbl_array_t *mba, deobf_ctx_t *ctx)
{
    if ( !mba || !ctx ) 
        return 0;

    deobf::log("[string_decrypt] Starting string decryption\n");

    int total_changes = 0;

    // Find all encrypted strings
    auto encrypted_strings = find_encrypted_strings(ctx->func_ea);
    deobf::log("[string_decrypt] Found %zu potential encrypted strings\n",
              encrypted_strings.size());

    for ( auto &str : encrypted_strings ) {
        // Try to extract XOR keys
        if ( !extract_xor_keys(mba, &str) ) {
            deobf::log_verbose("[string_decrypt] Could not extract keys for %a\n",
                              str.encrypted_addr);
            continue;
        }

        // Decrypt the string
        std::string decrypted = decrypt_string(str);
        if ( decrypted.empty() ) 
            continue;

        deobf::log("[string_decrypt] Decrypted string at %a: \"%s\"\n",
                  str.encrypted_addr, decrypted.c_str());

        // Store in context
        ctx->decrypted_strings[str.encrypted_addr] = decrypted;

        // Annotate in IDA
        annotate_string(str, decrypted);

        // Patch references in microcode
        total_changes += patch_string_references(mba, str, decrypted, ctx);

        ctx->strings_decrypted++;
    }

    deobf::log("[string_decrypt] Decrypted %d strings\n", ctx->strings_decrypted);
    return total_changes;
}

//--------------------------------------------------------------------------
// Find encrypted strings
//--------------------------------------------------------------------------
std::vector<string_decrypt_handler_t::encrypted_string_t>
string_decrypt_handler_t::find_encrypted_strings(ea_t func_ea)
{

    std::vector<encrypted_string_t> result;

    // Scan data segments for EncryptedString patterns
    segment_t *seg = get_first_seg();
    while ( seg ) {
        if ( seg->type == SEG_DATA ) {
            ea_t ea = seg->start_ea;
            while ( ea < seg->end_ea ) {
                qstring name;
                if ( get_name(&name, ea) > 0 ) {
                    if ( name.find("EncryptedString") != qstring::npos ) {
                        encrypted_string_t str;
                        str.encrypted_addr = ea;
                        str.element_size = 1;  // Default to byte

                        // Try to find the size from the type
                        tinfo_t ti;
                        if ( get_tinfo(&ti, ea) ) {
                            str.element_size = ti.get_size();
                            if ( str.element_size == 0 || str.element_size > 8 ) 
                                str.element_size = 1;
                        }

                        // Read encrypted data (up to 1KB)
                        size_t max_size = 1024;
                        str.encrypted_data.resize(max_size);
                        ssize_t read = get_bytes(str.encrypted_data.data(), max_size, ea);
                        if ( read > 0 ) {
                            str.encrypted_data.resize(read);

                            // Look for corresponding DecryptSpace
                            qstring decrypt_name = name;
                            decrypt_name.replace("EncryptedString", "DecryptSpace");
                            str.decrypt_space_addr = get_name_ea(BADADDR, decrypt_name.c_str());

                            result.push_back(str);
                        }
                    }
                }
                ea = next_head(ea, seg->end_ea);
                if ( ea == BADADDR ) 
                    break;
            }
        }
        seg = get_next_seg(seg->start_ea);
    }

    return result;
}

//--------------------------------------------------------------------------
// Extract XOR keys from decryption code
//--------------------------------------------------------------------------
bool string_decrypt_handler_t::extract_xor_keys(mbl_array_t *mba, encrypted_string_t *str)
{
    if ( !mba || !str ) 
        return false;

    // Look for XOR instructions that reference the encrypted address
    // Pattern: load encrypted[i]; xor with key; store to decrypted[i]

    std::map<size_t, uint8_t> key_map;  // offset -> key

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            if ( ins->opcode != m_xor ) 
                continue;

            // Check if one operand is from encrypted address
            // and other is a constant (the key)

            ea_t ref_addr = BADADDR;
            uint64_t key_val = 0;
            bool found = false;

            // Check left operand for global reference
            if ( ins->l.t == mop_v ) {
                // Direct global variable access
                ea_t gv_addr = ins->l.g;
                if ( gv_addr >= str->encrypted_addr &&
                    gv_addr < str->encrypted_addr + str->encrypted_data.size())
                    {
                    ref_addr = gv_addr;
                    if ( ins->r.t == mop_n ) {
                        key_val = ins->r.nnn->value;
                        found = true;
                    }
                }
            }

            // Check right operand similarly
            if ( !found && ins->r.t == mop_v ) {
                ea_t gv_addr = ins->r.g;
                if ( gv_addr >= str->encrypted_addr &&
                    gv_addr < str->encrypted_addr + str->encrypted_data.size())
                    {
                    ref_addr = gv_addr;
                    if ( ins->l.t == mop_n ) {
                        key_val = ins->l.nnn->value;
                        found = true;
                    }
                }
            }

            if ( found && ref_addr != BADADDR ) {
                size_t offset = ref_addr - str->encrypted_addr;
                key_map[offset] = (uint8_t)key_val;
            }
        }
    }

    // If we found keys, populate the keys vector
    if ( !key_map.empty() ) {
        size_t max_offset = 0;
        for ( const auto &p : key_map ) {
            if ( p.first > max_offset ) 
                max_offset = p.first;
        }

        str->xor_keys.resize(max_offset + 1, 0);
        for ( const auto &p : key_map ) {
            str->xor_keys[p.first] = p.second;
        }

        return true;
    }

    // Fallback: try to find keys in a different way
    // Look for immediate values used in XOR operations near string references

    return false;
}

//--------------------------------------------------------------------------
// Decrypt string
//--------------------------------------------------------------------------
std::string string_decrypt_handler_t::decrypt_string(const encrypted_string_t &str)
{
    if ( str.encrypted_data.empty() ) 
        return "";

    std::string result;

    // XOR each element with its key
    size_t len = std::min(str.encrypted_data.size(), str.xor_keys.size());

    for ( size_t i = 0; i < len; ++i ) {
        uint8_t decrypted = str.encrypted_data[i] ^ str.xor_keys[i];

        // Stop at null terminator
        if ( decrypted == 0 ) 
            break;

        // Check for printable ASCII
        if ( decrypted >= 32 && decrypted < 127 ) {
            result += (char)decrypted;
        } else if ( decrypted == '\n' || decrypted == '\t' || decrypted == '\r' ) {
            result += (char)decrypted;
        } else {
            // Non-printable - might be end of string or corruption
            break;
        }
    }

    return result;
}

//--------------------------------------------------------------------------
// Patch string references in microcode
//--------------------------------------------------------------------------
int string_decrypt_handler_t::patch_string_references(mbl_array_t *mba,
    const encrypted_string_t &str, const std::string &decrypted, deobf_ctx_t *ctx)
    {

    int changes = 0;

    // Find references to encrypted/decrypt_space addresses
    // Replace with the decrypted string representation

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            // Check if instruction references the encrypted string
            bool refs_encrypted = false;

            if ( ins->l.t == mop_v && ins->l.g == str.encrypted_addr ) 
                refs_encrypted = true;
            if ( ins->r.t == mop_v && ins->r.g == str.encrypted_addr ) 
                refs_encrypted = true;
            if ( ins->d.t == mop_v && ins->d.g == str.encrypted_addr ) 
                refs_encrypted = true;

            if ( refs_encrypted ) {
                // Add comment with decrypted string
                // (Actual value replacement is complex in microcode)
                changes++;
            }
        }
    }

    return changes;
}

//--------------------------------------------------------------------------
// Annotate decrypted string in IDA
//--------------------------------------------------------------------------
void string_decrypt_handler_t::annotate_string(const encrypted_string_t &str,
    const std::string &decrypted)
    {

    // Add comment at encrypted string location
    qstring comment;
    comment.sprnt("Decrypted: \"%s\"", decrypted.c_str());
    set_cmt(str.encrypted_addr, comment.c_str(), true);

    // Also comment at decrypt space if available
    if ( str.decrypt_space_addr != BADADDR ) {
        set_cmt(str.decrypt_space_addr, comment.c_str(), true);
    }
}

//--------------------------------------------------------------------------
// Find decryption block
//--------------------------------------------------------------------------
int string_decrypt_handler_t::find_decryption_block(mbl_array_t *mba)
{
    if ( !mba ) 
        return -1;

    // Look for block with multiple XOR instructions and atomic load
    // This is typically the "StringDecryptionBB"

    int best_block = -1;
    int best_score = 0;

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t *blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        int xor_count = 0;
        bool has_atomic = false;

        for ( minsn_t *ins = blk->head; ins; ins = ins->next ) {
            if ( ins->opcode == m_xor ) 
                xor_count++;

            // Check for atomic operations (indicated by memory ordering)
            // This is simplified - actual check would need more detail
        }

        int score = xor_count * 2;
        if ( has_atomic ) 
            score += 10;

        if ( score > best_score ) {
            best_score = score;
            best_block = i;
        }
    }

    return (best_score >= 6) ? best_block : -1;  // Need at least 3 XORs
}

```

`src/deobf/handlers/string_decrypt.h`:

```h
#pragma once
#include "../deobf_types.h"

//--------------------------------------------------------------------------
// String Decryption Handler
//
// Hikari's string encryption:
//   - Stores XOR-encrypted strings in global variables
//   - Creates decryption code at function entry
//   - Uses per-element XOR keys
//   - Atomic status flag to prevent re-decryption
//
// Detection:
//   - Global variables named "EncryptedString", "DecryptSpace"
//   - XOR loops in function prologue
//   - Atomic load/store of status flag
//
// Reversal:
//   1. Find encrypted string globals
//   2. Extract XOR keys from decryption code
//   3. Decrypt strings
//   4. Patch references to point to decrypted data
//   5. Optionally remove decryption code
//--------------------------------------------------------------------------
class string_decrypt_handler_t {
public:
    // Detection
    static bool detect(ea_t func_ea);

    // Main deobfuscation pass
    static int run(mbl_array_t *mba, deobf_ctx_t *ctx);

private:
    // Find encrypted strings in the binary
    struct encrypted_string_t {
        ea_t encrypted_addr;     // EncryptedString global
        ea_t decrypt_space_addr; // DecryptSpace global
        std::vector<uint8_t> encrypted_data;
        std::vector<uint8_t> xor_keys;
        int element_size;        // 1, 2, 4, or 8 bytes
        std::string decrypted;
    };

    static std::vector<encrypted_string_t> find_encrypted_strings(ea_t func_ea);

    // Extract XOR keys from decryption code
    static bool extract_xor_keys(mbl_array_t *mba, encrypted_string_t *str);

    // Decrypt a string
    static std::string decrypt_string(const encrypted_string_t &str);

    // Patch references in microcode
    static int patch_string_references(mbl_array_t *mba, const encrypted_string_t &str,
                                      const std::string &decrypted, deobf_ctx_t *ctx);

    // Add decrypted string as IDA comment/name
    static void annotate_string(const encrypted_string_t &str, const std::string &decrypted);

    // Find decryption block (StringDecryptionBB pattern)
    static int find_decryption_block(mbl_array_t *mba);
};

```

`src/deobf/handlers/unflattener_base.cpp`:

```cpp
#include "unflattener_base.h"
#include <queue>

namespace chernobog {

//--------------------------------------------------------------------------
// Z3StateSolver Implementation
//--------------------------------------------------------------------------

Z3StateSolver::Z3StateSolver(z3_solver::z3_context_t& ctx)
    : ctx_(ctx), translator_(ctx)
    {
}

void Z3StateSolver::set_timeout(unsigned ms)
{
    timeout_ms_ = ms;
    ctx_.set_timeout(ms);
}

void Z3StateSolver::reset()
{
    ctx_.reset();
    translator_.reset();
    transition_cache_.clear();
}

std::vector<StateVariable> Z3StateSolver::find_state_variables(mbl_array_t* mba)
{
    std::vector<StateVariable> candidates;

    if ( !mba ) 
        return candidates;

    // Look for variables that:
    // 1. Are compared against multiple large constants
    // 2. Are written in multiple blocks
    // 3. Control conditional jumps

    std::map<uint64_t, int> var_compare_count;  // var_id -> count of comparisons
    std::map<uint64_t, std::set<uint64_t>> var_constants;  // var_id -> constants compared against

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t* ins = blk->head; ins; ins = ins->next ) {
            // Look for conditional jumps comparing against constants
            if ( is_mcode_jcond(ins->opcode) ) {
                minsn_t* cond = (ins->l.t == mop_d) ? ins->l.d : nullptr;
                if ( !cond ) 
                    continue;

                // Check for comparison with constant
                const mop_t* var_op = nullptr;
                uint64_t const_val = 0;

                if ( cond->r.t == mop_n && cond->r.nnn ) {
                    var_op = &cond->l;
                    const_val = cond->r.nnn->value;
                } else if ( cond->l.t == mop_n && cond->l.nnn ) {
                    var_op = &cond->r;
                    const_val = cond->l.nnn->value;
                }

                if ( var_op && UnflattenerBase::is_state_constant(const_val) ) {
                    // Create a key for this variable
                    uint64_t var_key = 0;
                    if ( var_op->t == mop_S && var_op->s ) {
                        var_key = (1ULL << 60) | var_op->s->off;
                    } else if ( var_op->t == mop_v ) {
                        var_key = (2ULL << 60) | var_op->g;
                    } else if ( var_op->t == mop_r ) {
                        var_key = (3ULL << 60) | var_op->r;
                    }

                    if ( var_key != 0 ) {
                        var_compare_count[var_key]++;
                        var_constants[var_key].insert(const_val);
                    }
                }
            }
        }
    }

    // Find variables compared against multiple state constants
    for ( auto& [var_key, count] : var_compare_count ) {
        if ( count >= 2 && var_constants[var_key].size() >= 2 ) {
            StateVariable sv;

            if ( (var_key >> 60) == 1 ) {
                // Stack variable
                sv.is_stack = true;
                sv.stack_offset = var_key & ((1ULL << 60) - 1);
                sv.size = 4;  // Assume 4 bytes
            } else if ( (var_key >> 60) == 2 ) {
                // Global variable
                sv.is_global = true;
                sv.global_addr = var_key & ((1ULL << 60) - 1);
                sv.size = 4;
            }

            if ( sv.is_stack || sv.is_global ) {
                candidates.push_back(sv);
            }
        }
    }

    return candidates;
}

bool Z3StateSolver::verify_state_variable(mbl_array_t* mba, const StateVariable& var) {
    if ( !mba || !var.is_valid() ) 
        return false;

    // Count how many blocks write to this variable
    int write_count = 0;
    int read_count = 0;

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        bool has_write = false;
        bool has_read = false;

        for ( minsn_t* ins = blk->head; ins; ins = ins->next ) {
            // Check for writes
            if ( ins->opcode == m_mov || ins->opcode == m_stx ) {
                if ( var.is_stack && ins->d.t == mop_S && ins->d.s &&
                    ins->d.s->off == var.stack_offset)
                    {
                    has_write = true;
                }
                if ( var.is_global && ins->d.t == mop_v &&
                    ins->d.g == var.global_addr)
                    {
                    has_write = true;
                }
            }

            // Check for reads (in conditions)
            if ( is_mcode_jcond(ins->opcode) ) {
                auto check_op = [&](const mop_t& op)
                {
                    if ( var.is_stack && op.t == mop_S && op.s &&
                        op.s->off == var.stack_offset)
                        {
                        has_read = true;
                    }
                    if ( var.is_global && op.t == mop_v &&
                        op.g == var.global_addr)
                        {
                        has_read = true;
                    }
                };
                check_op(ins->l);
                check_op(ins->r);
            }
        }

        if ( has_write) write_count++;
        if ( has_read) read_count++;
    }

    // A valid state variable should be written in multiple blocks
    // and read in the dispatcher
    return write_count >= 2 && read_count >= 1;
}

std::optional<uint64_t> Z3StateSolver::find_state_write(mblock_t* blk,
                                                         const StateVariable& var)
                                                         {
    if ( !blk || !var.is_valid() ) 
        return std::nullopt;

    for ( minsn_t* ins = blk->head; ins; ins = ins->next ) {
        if ( ins->opcode != m_mov ) 
            continue;

        // Check if destination matches state variable
        bool matches = false;
        if ( var.is_stack && ins->d.t == mop_S && ins->d.s &&
            ins->d.s->off == var.stack_offset)
            {
            matches = true;
        }
        if ( var.is_global && ins->d.t == mop_v &&
            ins->d.g == var.global_addr)
            {
            matches = true;
        }

        if ( matches && ins->l.t == mop_n && ins->l.nnn ) {
            return ins->l.nnn->value;
        }
    }

    return std::nullopt;
}

bool Z3StateSolver::analyze_dispatcher(mbl_array_t* mba, int block_idx,
                                        const StateVariable& var,
                                        DispatcherBlock* out)
                                        {
    if ( !mba || block_idx < 0 || block_idx >= mba->qty || !out ) 
        return false;

    mblock_t* blk = mba->get_mblock(block_idx);
    if ( !blk ) 
        return false;

    out->block_idx = block_idx;
    out->start_addr = blk->start;
    out->state_var = var;

    // Find all state comparisons in this block and its chain
    std::set<int> visited;
    std::queue<int> to_visit;
    to_visit.push(block_idx);

    while ( !to_visit.empty() ) {
        int curr = to_visit.front();
        to_visit.pop();

        if ( visited.count(curr) ) 
            continue;
        visited.insert(curr);

        mblock_t* curr_blk = mba->get_mblock(curr);
        if ( !curr_blk ) 
            continue;

        // Check for state comparisons
        for ( minsn_t* ins = curr_blk->head; ins; ins = ins->next ) {
            if ( !is_mcode_jcond(ins->opcode) ) 
                continue;

            minsn_t* cond = (ins->l.t == mop_d) ? ins->l.d : nullptr;
            if ( !cond ) 
                continue;

            // Look for comparison with state constant
            uint64_t const_val = 0;
            bool found = false;

            if ( cond->r.t == mop_n && cond->r.nnn ) {
                const_val = cond->r.nnn->value;
                found = true;
            } else if ( cond->l.t == mop_n && cond->l.nnn ) {
                const_val = cond->l.nnn->value;
                found = true;
            }

            if ( found && UnflattenerBase::is_state_constant(const_val) ) {
                // This is a state comparison - target block is a case block
                int target = (ins->d.t == mop_b) ? ins->d.b : -1;
                if ( target >= 0 ) {
                    out->state_to_block[const_val] = target;
                    out->case_blocks.insert(target);
                }
            }
        }

        out->dispatcher_chain.insert(curr);

        // Follow fall-through to find chained dispatcher blocks
        if ( curr_blk->tail && curr_blk->tail->opcode == m_goto &&
            curr_blk->tail->l.t == mop_b)
            {
            int fall = curr_blk->tail->l.b;
            if ( !visited.count(fall) ) {
                to_visit.push(fall);
            }
        }
    }

    out->is_analyzed = true;
    out->is_solvable = !out->state_to_block.empty();

    return out->is_solvable;
}

bool Z3StateSolver::build_state_map(mbl_array_t* mba, DispatcherBlock* disp)
{
    return analyze_dispatcher(mba, disp->block_idx, disp->state_var, disp);
}

std::vector<StateTransition> Z3StateSolver::analyze_block_transitions(
    mbl_array_t* mba, int block_idx, const StateVariable& var)
    {

    std::vector<StateTransition> transitions;

    if ( !mba || block_idx < 0 || block_idx >= mba->qty ) 
        return transitions;

    // Check cache
    if ( transition_cache_.count(block_idx) ) {
        return transition_cache_[block_idx];
    }

    mblock_t* blk = mba->get_mblock(block_idx);
    if ( !blk ) 
        return transitions;

    // Find state writes in this block
    for ( minsn_t* ins = blk->head; ins; ins = ins->next ) {
        if ( ins->opcode != m_mov ) 
            continue;

        bool is_state_write = false;
        if ( var.is_stack && ins->d.t == mop_S && ins->d.s &&
            ins->d.s->off == var.stack_offset)
            {
            is_state_write = true;
        }
        if ( var.is_global && ins->d.t == mop_v &&
            ins->d.g == var.global_addr)
            {
            is_state_write = true;
        }

        if ( is_state_write && ins->l.t == mop_n && ins->l.nnn ) {
            StateTransition trans;
            trans.from_block = block_idx;
            trans.to_state = ins->l.nnn->value;
            trans.transition_addr = ins->ea;
            transitions.push_back(trans);
        }
    }

    // Check for conditional state writes
    auto conditional = analyze_conditional_writes(mba, block_idx, var);
    transitions.insert(transitions.end(), conditional.begin(), conditional.end());

    transition_cache_[block_idx] = transitions;
    return transitions;
}

std::optional<uint64_t> Z3StateSolver::solve_written_state(
    mbl_array_t* mba, int block_idx, const StateVariable& var)
    {

    auto transitions = analyze_block_transitions(mba, block_idx, var);
    if ( transitions.empty() ) 
        return std::nullopt;

    // Return first unconditional transition
    for ( auto& t : transitions ) {
        if ( !t.is_conditional ) {
            return t.to_state;
        }
    }

    return std::nullopt;
}

std::vector<StateTransition> Z3StateSolver::analyze_conditional_writes(
    mbl_array_t* mba, int block_idx, const StateVariable& var)
    {

    std::vector<StateTransition> transitions;

    if ( !mba || block_idx < 0 || block_idx >= mba->qty ) 
        return transitions;

    mblock_t* blk = mba->get_mblock(block_idx);
    if ( !blk || !blk->tail ) 
        return transitions;

    // Check if block ends with a conditional jump
    if ( !is_mcode_jcond(blk->tail->opcode) ) 
        return transitions;

    // Get true and false targets
    int true_target = (blk->tail->d.t == mop_b) ? blk->tail->d.b : -1;
    int false_target = -1;

    // Fall-through is the false target
    for ( int i = 0; i < blk->nsucc(); ++i ) {
        int succ = blk->succ(i);
        if ( succ != true_target ) {
            false_target = succ;
            break;
        }
    }

    // Analyze both branches for state writes
    if ( true_target >= 0 ) {
        auto state = find_state_write(mba->get_mblock(true_target), var);
        if ( state.has_value() ) {
            StateTransition trans;
            trans.from_block = block_idx;
            trans.to_state = state.value();
            trans.is_conditional = true;
            trans.is_true_branch = true;
            transitions.push_back(trans);
        }
    }

    if ( false_target >= 0 ) {
        auto state = find_state_write(mba->get_mblock(false_target), var);
        if ( state.has_value() ) {
            StateTransition trans;
            trans.from_block = block_idx;
            trans.to_state = state.value();
            trans.is_conditional = true;
            trans.is_true_branch = false;
            transitions.push_back(trans);
        }
    }

    return transitions;
}

z3::expr Z3StateSolver::state_to_z3(const StateVariable& var)
{
    // Create a symbolic variable for the state
    std::string name = "state_";
    if ( var.is_stack ) {
        name += "stack_" + std::to_string(var.stack_offset);
    } else if ( var.is_global ) {
        name += "global_" + std::to_string(var.global_addr);
    } else {
        name += "unknown";
    }

    return ctx_.ctx().bv_const(name.c_str(), var.size * 8);
}

std::optional<uint64_t> Z3StateSolver::solve_constant(const z3::expr& expr, int bits)
{
    try {
        z3::solver& s = ctx_.solver();
        s.reset();

        // Create a variable for the result
        z3::expr result = ctx_.ctx().bv_const("result", bits);

        // Assert that expr == result
        s.add(expr == result);

        if ( s.check() == z3::sat ) {
            z3::model m = s.get_model();
            z3::expr val = m.eval(result, true);
            if ( val.is_numeral() ) {
                return val.as_uint64();
            }
        }
    } catch (...) {
        // Z3 error
    }

    return std::nullopt;
}

bool Z3StateSolver::is_constant_expr(const z3::expr& expr, int bits)
{
    try {
        z3::solver& s = ctx_.solver();
        s.reset();

        // Create two different values and check if expr can differ
        z3::expr v1 = ctx_.ctx().bv_const("v1", bits);
        z3::expr v2 = ctx_.ctx().bv_const("v2", bits);

        // If expr depends on any variable, it should be able to take different values
        // This is a simplified check - full check would enumerate all variables

        z3::expr_vector vars(ctx_.ctx());
        // ... would need to extract variables from expr

        // For now, use simplification
        z3::expr simplified = expr.simplify();
        return simplified.is_numeral();
    } catch (...) {
        return false;
    }
}

z3_solver::sat_result_t Z3StateSolver::check_sat(const z3::expr& constraint)
{
    try {
        z3::solver& s = ctx_.solver();
        s.reset();
        s.add(constraint);

        switch ( s.check() ) {
            case z3::sat:   return z3_solver::sat_result_t::SAT;
            case z3::unsat: return z3_solver::sat_result_t::UNSAT;
            default:        return z3_solver::sat_result_t::UNKNOWN;
        }
    } catch (...) {
        return z3_solver::sat_result_t::UNKNOWN;
    }
}

//--------------------------------------------------------------------------
// UnflattenerBase Implementation
//--------------------------------------------------------------------------

UnflattenerBase::UnflattenerBase()
{
}

void UnflattenerBase::reset()
{
    analysis_complete_ = false;
    dispatchers_.clear();
    transitions_.clear();
    primary_state_var_ = StateVariable();
    if ( solver_ ) {
        solver_->reset();
    }
}

void UnflattenerBase::reset_statistics()
{
    functions_unflattened_ = 0;
    edges_recovered_ = 0;
    dispatchers_eliminated_ = 0;
}

Z3StateSolver& UnflattenerBase::solver()
{
    if ( !solver_ ) {
        solver_ = std::make_unique<Z3StateSolver>(z3_solver::get_global_context());
    }
    return *solver_;
}

bool UnflattenerBase::is_state_constant(uint64_t val)
{
    return is_hikari_constant(val) || is_ollvm_constant(val);
}

bool UnflattenerBase::is_hikari_constant(uint64_t val)
{
    // Hikari uses constants like 0xAAAAxxxx, 0xBBBBxxxx, 0xDEADxxxx, etc.
    if ( val < 0x10000000 || val > 0xFFFFFFFF ) 
        return false;

    uint32_t high = (val >> 16) & 0xFFFF;
    switch ( high ) {
        case 0xAAAA: case 0xBBBB: case 0xCCCC: case 0xDDDD:
        case 0xEEEE: case 0xFFFF:
        case 0xBEEF: case 0xCAFE: case 0xDEAD: case 0xFACE:
        case 0xFEED: case 0xBABE: case 0xC0DE: case 0xD00D:
            return true;
        default:
            return false;
    }
}

bool UnflattenerBase::is_ollvm_constant(uint64_t val)
{
    // O-LLVM uses sequential integers or random-looking constants
    // This is a heuristic - O-LLVM constants are often in reasonable ranges
    if ( val >= 0x10000000 && val <= 0xFFFFFFFF ) {
        // Could be a large constant used as state
        return true;
    }
    // Small sequential integers (0, 1, 2, ...) are also used
    if ( val < 1000 ) {
        return true;
    }
    return false;
}

std::set<uint64_t> UnflattenerBase::find_constants_in_block(const mblock_t* blk)
{
    std::set<uint64_t> constants;

    if ( !blk ) 
        return constants;

    for ( const minsn_t* ins = blk->head; ins; ins = ins->next ) {
        auto check_op = [&](const mop_t& op)
        {
            if ( op.t == mop_n && op.nnn ) {
                uint64_t val = op.nnn->value;
                if ( is_state_constant(val) ) {
                    constants.insert(val);
                }
            }
        };

        check_op(ins->l);
        check_op(ins->r);
        check_op(ins->d);

        // Check nested instructions
        if ( ins->l.t == mop_d && ins->l.d ) {
            check_op(ins->l.d->l);
            check_op(ins->l.d->r);
        }
    }

    return constants;
}

bool UnflattenerBase::redirect_edge(mbl_array_t* mba, int from_block,
                                     int old_target, int new_target)
                                     {
    if ( !mba || from_block < 0 || from_block >= mba->qty ||
        new_target < 0 || new_target >= mba->qty)
        return false;

    mblock_t* src = mba->get_mblock(from_block);
    mblock_t* dst = mba->get_mblock(new_target);
    if ( !src || !dst ) 
        return false;

    // Update the instruction target
    minsn_t* tail = src->tail;
    if ( !tail ) 
        return false;

    if ( tail->opcode == m_goto ) {
        tail->l.make_blkref(new_target);
    } else if ( is_mcode_jcond(tail->opcode) ) {
        if ( tail->d.t == mop_b && tail->d.b == old_target ) {
            tail->d.make_blkref(new_target);
        }
    }

    // Update successor list
    for ( auto& succ : src->succset ) {
        if ( succ == old_target ) {
            succ = new_target;
            break;
        }
    }

    // Update predecessor lists
    if ( old_target >= 0 && old_target < mba->qty ) {
        mblock_t* old_dst = mba->get_mblock(old_target);
        if ( old_dst ) {
            auto p = std::find(old_dst->predset.begin(),
                               old_dst->predset.end(), from_block);
            if ( p != old_dst->predset.end() ) {
                old_dst->predset.erase(p);
            }
            old_dst->mark_lists_dirty();
        }
    }

    auto p = std::find(dst->predset.begin(), dst->predset.end(), from_block);
    if ( p == dst->predset.end() ) {
        dst->predset.push_back(from_block);
    }

    src->mark_lists_dirty();
    dst->mark_lists_dirty();

    return true;
}

bool UnflattenerBase::convert_to_goto(mblock_t* blk, int target_block)
{
    if ( !blk || !blk->tail ) 
        return false;

    minsn_t* tail = blk->tail;
    ea_t orig_ea = tail->ea;

    // Convert to goto
    tail->opcode = m_goto;
    tail->l.make_blkref(target_block);
    tail->r.erase();
    tail->d.erase();
    tail->ea = orig_ea;

    blk->type = BLT_1WAY;
    blk->mark_lists_dirty();

    return true;
}

bool UnflattenerBase::convert_to_nop(mblock_t* blk, minsn_t* ins)
{
    if ( !blk || !ins ) 
        return false;

    ea_t orig_ea = ins->ea;

    ins->opcode = m_nop;
    ins->l.erase();
    ins->r.erase();
    ins->d.erase();
    ins->ea = orig_ea;

    blk->mark_lists_dirty();

    return true;
}

bool UnflattenerBase::remove_dead_stores(mblock_t* blk, const StateVariable& var)
{
    if ( !blk || !var.is_valid() ) 
        return false;

    bool removed_any = false;

    for ( minsn_t* ins = blk->head; ins; ins = ins->next ) {
        if ( ins->opcode != m_mov ) 
            continue;

        bool is_state_write = false;
        if ( var.is_stack && ins->d.t == mop_S && ins->d.s &&
            ins->d.s->off == var.stack_offset)
            {
            is_state_write = true;
        }
        if ( var.is_global && ins->d.t == mop_v &&
            ins->d.g == var.global_addr)
            {
            is_state_write = true;
        }

        if ( is_state_write ) {
            convert_to_nop(blk, ins);
            removed_any = true;
        }
    }

    return removed_any;
}

bool UnflattenerBase::is_exit_block(const mblock_t* blk)
{
    if ( !blk || !blk->tail ) 
        return false;

    return blk->tail->opcode == m_ret || blk->type == BLT_STOP;
}

bool UnflattenerBase::is_return_block(const mblock_t* blk)
{
    if ( !blk || !blk->tail ) 
        return false;

    return blk->tail->opcode == m_ret;
}

std::vector<int> UnflattenerBase::get_successors(const mblock_t* blk)
{
    std::vector<int> succs;
    if ( !blk ) 
        return succs;

    for ( int i = 0; i < blk->nsucc(); ++i ) {
        succs.push_back(blk->succ(i));
    }
    return succs;
}

std::vector<int> UnflattenerBase::get_predecessors(const mblock_t* blk)
{
    std::vector<int> preds;
    if ( !blk ) 
        return preds;

    for ( int i = 0; i < blk->npred(); ++i ) {
        preds.push_back(blk->pred(i));
    }
    return preds;
}

int UnflattenerBase::count_state_comparisons(const mblock_t* blk)
{
    int count = 0;

    if ( !blk ) 
        return count;

    for ( minsn_t* ins = blk->head; ins; ins = ins->next ) {
        if ( !is_mcode_jcond(ins->opcode) ) 
            continue;

        minsn_t* cond = (ins->l.t == mop_d) ? ins->l.d : nullptr;
        if ( !cond ) 
            continue;

        // Check for comparison with state constant
        if ( cond->r.t == mop_n && cond->r.nnn &&
            is_state_constant(cond->r.nnn->value))
            {
            count++;
        } else if ( cond->l.t == mop_n && cond->l.nnn &&
                   is_state_constant(cond->l.nnn->value))
                   {
            count++;
        }
    }

    return count;
}

bool UnflattenerBase::has_state_variable_read(const mblock_t* blk,
                                               const StateVariable& var)
                                               {
    if ( !blk || !var.is_valid() ) 
        return false;

    for ( minsn_t* ins = blk->head; ins; ins = ins->next ) {
        auto check_op = [&](const mop_t& op) -> bool {
            if ( var.is_stack && op.t == mop_S && op.s &&
                op.s->off == var.stack_offset)
                {
                return true;
            }
            if ( var.is_global && op.t == mop_v &&
                op.g == var.global_addr)
                {
                return true;
            }
            return false;
        };

        if ( check_op(ins->l) || check_op(ins->r) ) 
            return true;

        // Check nested instructions
        if ( ins->l.t == mop_d && ins->l.d ) {
            if ( check_op(ins->l.d->l) || check_op(ins->l.d->r) ) 
                return true;
        }
    }

    return false;
}

//--------------------------------------------------------------------------
// UnflattenerRegistry Implementation
//--------------------------------------------------------------------------

UnflattenerRegistry& UnflattenerRegistry::instance()
{
    static UnflattenerRegistry inst;
    return inst;
}

void UnflattenerRegistry::register_unflattener(
    std::unique_ptr<UnflattenerBase> unflattener)
    {
    unflatteners_.push_back(std::move(unflattener));

    // Sort by priority (descending)
    std::sort(unflatteners_.begin(), unflatteners_.end(),
              [](const auto& a, const auto& b)
              {
                  return a->priority() > b->priority();
              });
}

void UnflattenerRegistry::initialize()
{
    if ( initialized_ ) 
        return;

    unflatteners_.clear();

    // Register built-in unflatteners (sorted by priority after registration)
    // Priority order: FakeJump(85) > Hikari(80) > BadWhileLoop(75) > OLLVM(70)
    //                 > JumpTable(60) > SwitchCase(55) > Generic(30)
    register_unflattener(std::make_unique<FakeJumpUnflattener>());
    register_unflattener(std::make_unique<HikariUnflattener>());
    register_unflattener(std::make_unique<BadWhileLoopUnflattener>());
    register_unflattener(std::make_unique<OLLVMUnflattener>());
    register_unflattener(std::make_unique<JumpTableUnflattener>());
    register_unflattener(std::make_unique<SwitchCaseUnflattener>());
    register_unflattener(std::make_unique<GenericUnflattener>());

    initialized_ = true;
    msg("[chernobog] Unflattener registry initialized (%zu unflatteners)\n",
        unflatteners_.size());
}

UnflattenerBase* UnflattenerRegistry::find_best_match(mbl_array_t* mba)
{
    if ( !initialized_ ) 
        initialize();

    UnflattenerBase* best = nullptr;
    int best_score = 0;

    for ( auto& unflattener : unflatteners_ ) {
        int score = unflattener->detect(mba);
        if ( score > best_score ) {
            best_score = score;
            best = unflattener.get();
        }
    }

    return best;
}

UnflattenResult UnflattenerRegistry::unflatten(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    UnflattenResult result;

    if ( !initialized_ ) 
        initialize();

    UnflattenerBase* unflattener = find_best_match(mba);
    if ( !unflattener ) {
        result.error_message = "No matching unflattener found";
        return result;
    }

    deobf::log_verbose("[Unflatten] Using %s\n", unflattener->name());

    // Analyze
    if ( !unflattener->analyze(mba, ctx) ) {
        result.error_message = "Analysis failed";
        return result;
    }

    // Apply
    result = unflattener->apply(mba, ctx);

    if ( result.success ) {
        unflattener->cleanup(mba, ctx);
    }

    return result;
}

void UnflattenerRegistry::dump_statistics()
{
    msg("[chernobog] Unflattener Statistics:\n");
    for ( auto& unflattener : unflatteners_ ) {
        if ( unflattener->functions_unflattened() > 0 ) {
            msg("  %s: %zu functions, %zu edges, %zu dispatchers\n",
                unflattener->name(),
                unflattener->functions_unflattened(),
                unflattener->edges_recovered(),
                unflattener->dispatchers_eliminated());
        }
    }
}

void UnflattenerRegistry::reset_statistics()
{
    for ( auto& unflattener : unflatteners_ ) {
        unflattener->reset_statistics();
    }
}

//--------------------------------------------------------------------------
// HikariUnflattener Implementation (delegates to existing deflatten_handler_t)
//--------------------------------------------------------------------------

int HikariUnflattener::detect(mbl_array_t* mba)
{
    if ( !mba ) 
        return 0;

    int score = 0;

    // Look for Hikari-style state constants
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        auto constants = find_constants_in_block(blk);
        for ( uint64_t c : constants ) {
            if ( is_hikari_constant(c) ) {
                score += 20;
            }
        }

        // Bonus for dispatcher-like blocks
        int state_cmp = count_state_comparisons(blk);
        if ( state_cmp >= 2 ) {
            score += state_cmp * 10;
        }
    }

    return std::min(score, 100);
}

bool HikariUnflattener::analyze(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    // Find state variables
    auto candidates = solver().find_state_variables(mba);
    if ( candidates.empty() ) 
        return false;

    // Verify and select primary state variable
    for ( auto& var : candidates ) {
        if ( solver().verify_state_variable(mba, var) ) {
            primary_state_var_ = var;
            break;
        }
    }

    if ( !primary_state_var_.is_valid() ) 
        return false;

    // Find dispatchers
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        if ( count_state_comparisons(blk) >= 2 ) {
            DispatcherBlock disp;
            if ( solver().analyze_dispatcher(mba, i, primary_state_var_, &disp) ) {
                dispatchers_.push_back(disp);
            }
        }
    }

    if ( dispatchers_.empty() ) 
        return false;

    // Analyze transitions for each case block
    for ( auto& disp : dispatchers_ ) {
        for ( int case_blk : disp.case_blocks ) {
            auto trans = solver().analyze_block_transitions(mba, case_blk,
                                                            primary_state_var_);
            transitions_.insert(transitions_.end(), trans.begin(), trans.end());
        }
    }

    analysis_complete_ = true;
    return true;
}

UnflattenResult HikariUnflattener::apply(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    UnflattenResult result;

    if ( !analysis_complete_ ) {
        result.error_message = "Analysis not complete";
        return result;
    }

    // For each transition, redirect the edge
    for ( auto& trans : transitions_ ) {
        if ( trans.to_state == 0 ) 
            continue;

        // Find target block for this state
        int target = -1;
        for ( auto& disp : dispatchers_ ) {
            auto p = disp.state_to_block.find(trans.to_state);
            if ( p != disp.state_to_block.end() ) {
                target = p->second;
                break;
            }
        }

        if ( target < 0 ) 
            continue;

        // Find the goto instruction in the source block
        mblock_t* src = mba->get_mblock(trans.from_block);
        if ( !src || !src->tail ) 
            continue;

        if ( src->tail->opcode == m_goto ) {
            // Get current target (dispatcher)
            int old_target = (src->tail->l.t == mop_b) ? src->tail->l.b : -1;

            if ( redirect_edge(mba, trans.from_block, old_target, target) ) {
                result.edges_recovered++;
            }
        }
    }

    // Remove state variable assignments
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( blk && remove_dead_stores(blk, primary_state_var_) ) {
            result.blocks_modified++;
        }
    }

    result.success = result.edges_recovered > 0;
    result.transitions = transitions_;
    result.dispatchers_eliminated = dispatchers_.size();

    if ( result.success ) {
        functions_unflattened_++;
        edges_recovered_ += result.edges_recovered;
        dispatchers_eliminated_ += result.dispatchers_eliminated;
    }

    return result;
}

//--------------------------------------------------------------------------
// OLLVMUnflattener Implementation
//--------------------------------------------------------------------------

int OLLVMUnflattener::detect(mbl_array_t* mba)
{
    if ( !mba ) 
        return 0;

    int score = 0;

    // O-LLVM patterns:
    // 1. Switch statement in a loop
    // 2. Prologue that initializes state variable
    // 3. State variable comparisons in switch

    if ( detect_switch_dispatcher(mba) ) {
        score += 50;
    }

    if ( detect_prologue_pattern(mba) ) {
        score += 30;
    }

    return std::min(score, 100);
}

bool OLLVMUnflattener::detect_switch_dispatcher(mbl_array_t* mba) {
    // Look for m_jtbl instructions
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( minsn_t* ins = blk->head; ins; ins = ins->next ) {
            if ( ins->opcode == m_jtbl ) {
                return true;
            }
        }
    }
    return false;
}

bool OLLVMUnflattener::detect_prologue_pattern(mbl_array_t* mba)
{
    // O-LLVM typically initializes state in block 0
    if ( mba->qty < 2 ) 
        return false;

    mblock_t* entry = mba->get_mblock(0);
    if ( !entry ) 
        return false;

    // Look for state initialization followed by goto
    for ( minsn_t* ins = entry->head; ins; ins = ins->next ) {
        if ( ins->opcode == m_mov && ins->l.t == mop_n && ins->l.nnn ) {
            // Found a constant assignment
            return true;
        }
    }

    return false;
}

bool OLLVMUnflattener::analyze(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    // Similar to Hikari but with O-LLVM specific patterns
    auto candidates = solver().find_state_variables(mba);

    for ( auto& var : candidates ) {
        if ( solver().verify_state_variable(mba, var) ) {
            primary_state_var_ = var;
            break;
        }
    }

    if ( !primary_state_var_.is_valid() ) 
        return false;

    // Find switch-based dispatcher
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        // Look for jtbl or cascading comparisons
        bool has_jtbl = false;
        for ( minsn_t* ins = blk->head; ins; ins = ins->next ) {
            if ( ins->opcode == m_jtbl ) {
                has_jtbl = true;
                break;
            }
        }

        if ( has_jtbl || count_state_comparisons(blk) >= 2 ) {
            DispatcherBlock disp;
            if ( solver().analyze_dispatcher(mba, i, primary_state_var_, &disp) ) {
                dispatchers_.push_back(disp);
            }
        }
    }

    if ( dispatchers_.empty() ) 
        return false;

    // Analyze transitions
    for ( auto& disp : dispatchers_ ) {
        for ( int case_blk : disp.case_blocks ) {
            auto trans = solver().analyze_block_transitions(mba, case_blk,
                                                            primary_state_var_);
            transitions_.insert(transitions_.end(), trans.begin(), trans.end());
        }
    }

    analysis_complete_ = true;
    return true;
}

UnflattenResult OLLVMUnflattener::apply(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    // Same application logic as Hikari - implemented inline
    UnflattenResult result;

    if ( !analysis_complete_ ) {
        result.error_message = "Analysis not complete";
        return result;
    }

    // For each transition, redirect the edge
    for ( auto& trans : transitions_ ) {
        if ( trans.to_state == 0 ) 
            continue;

        // Find target block for this state
        int target = -1;
        for ( auto& disp : dispatchers_ ) {
            auto p = disp.state_to_block.find(trans.to_state);
            if ( p != disp.state_to_block.end() ) {
                target = p->second;
                break;
            }
        }

        if ( target < 0 ) 
            continue;

        // Find the goto instruction in the source block
        mblock_t* src = mba->get_mblock(trans.from_block);
        if ( !src || !src->tail ) 
            continue;

        if ( src->tail->opcode == m_goto ) {
            // Get current target (dispatcher)
            int old_target = (src->tail->l.t == mop_b) ? src->tail->l.b : -1;

            if ( redirect_edge(mba, trans.from_block, old_target, target) ) {
                result.edges_recovered++;
            }
        }
    }

    // Remove state variable assignments
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( blk && remove_dead_stores(blk, primary_state_var_) ) {
            result.blocks_modified++;
        }
    }

    result.success = result.edges_recovered > 0;
    result.transitions = transitions_;
    result.dispatchers_eliminated = dispatchers_.size();

    if ( result.success ) {
        functions_unflattened_++;
        edges_recovered_ += result.edges_recovered;
        dispatchers_eliminated_ += result.dispatchers_eliminated;
    }

    return result;
}

//--------------------------------------------------------------------------
// GenericUnflattener Implementation
//--------------------------------------------------------------------------

int GenericUnflattener::detect(mbl_array_t* mba)
{
    if ( !mba ) 
        return 0;

    int score = 0;

    // Generic heuristics:
    // 1. Look for blocks with many conditional jumps
    // 2. Look for variables compared against many constants
    // 3. Look for loop-like structures with state variable

    int max_comparisons = 0;
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( blk ) {
            int cmp = score_as_dispatcher(blk);
            max_comparisons = std::max(max_comparisons, cmp);
        }
    }

    if ( max_comparisons >= 3 ) {
        score = max_comparisons * 10;
    }

    return std::min(score, 100);
}

int GenericUnflattener::score_as_dispatcher(const mblock_t* blk)
{
    if ( !blk ) 
        return 0;

    int score = 0;

    // Count conditional jumps
    for ( minsn_t* ins = blk->head; ins; ins = ins->next ) {
        if ( is_mcode_jcond(ins->opcode) ) {
            score++;
        }
    }

    // Bonus for comparing against constants
    auto constants = find_constants_in_block(blk);
    score += constants.size();

    return score;
}

bool GenericUnflattener::detect_state_variable_generic(mbl_array_t* mba)
{
    auto candidates = solver().find_state_variables(mba);
    for ( auto& var : candidates ) {
        if ( solver().verify_state_variable(mba, var) ) {
            primary_state_var_ = var;
            return true;
        }
    }
    return false;
}

bool GenericUnflattener::analyze(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    if ( !detect_state_variable_generic(mba) ) 
        return false;

    // Find potential dispatchers
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        if ( score_as_dispatcher(blk) >= 2 ) {
            DispatcherBlock disp;
            if ( solver().analyze_dispatcher(mba, i, primary_state_var_, &disp) ) {
                dispatchers_.push_back(disp);
            }
        }
    }

    if ( dispatchers_.empty() ) 
        return false;

    // Analyze transitions
    for ( auto& disp : dispatchers_ ) {
        for ( int case_blk : disp.case_blocks ) {
            auto trans = solver().analyze_block_transitions(mba, case_blk,
                                                            primary_state_var_);
            transitions_.insert(transitions_.end(), trans.begin(), trans.end());
        }
    }

    analysis_complete_ = true;
    return true;
}

UnflattenResult GenericUnflattener::apply(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    // Same application logic
    UnflattenResult result;

    if ( !analysis_complete_ ) {
        result.error_message = "Analysis not complete";
        return result;
    }

    for ( auto& trans : transitions_ ) {
        if ( trans.to_state == 0 ) 
            continue;

        int target = -1;
        for ( auto& disp : dispatchers_ ) {
            auto p = disp.state_to_block.find(trans.to_state);
            if ( p != disp.state_to_block.end() ) {
                target = p->second;
                break;
            }
        }

        if ( target < 0 ) 
            continue;

        mblock_t* src = mba->get_mblock(trans.from_block);
        if ( !src || !src->tail ) 
            continue;

        if ( src->tail->opcode == m_goto ) {
            int old_target = (src->tail->l.t == mop_b) ? src->tail->l.b : -1;
            if ( redirect_edge(mba, trans.from_block, old_target, target) ) {
                result.edges_recovered++;
            }
        }
    }

    result.success = result.edges_recovered > 0;
    result.transitions = transitions_;

    if ( result.success ) {
        functions_unflattened_++;
        edges_recovered_ += result.edges_recovered;
    }

    return result;
}

//--------------------------------------------------------------------------
// JumpTableUnflattener Implementation
//--------------------------------------------------------------------------

int JumpTableUnflattener::detect(mbl_array_t* mba)
{
    if ( !mba ) 
        return 0;

    int table_block = -1;
    if ( detect_jump_table(mba, &table_block) ) {
        return 70;
    }

    return 0;
}

bool JumpTableUnflattener::detect_jump_table(mbl_array_t* mba, int* table_block)
{
    // Look for indirect jumps that might be jump tables
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk || !blk->tail ) 
            continue;

        if ( blk->tail->opcode == m_ijmp ) {
            if ( table_block) *table_block = i;
            return true;
        }
    }

    return false;
}

bool JumpTableUnflattener::analyze_index_computation(mblock_t* blk)
{
    // Look for index computation patterns
    // e.g., index = state - base_value
    //       target = table[index]

    if ( !blk ) 
        return false;

    for ( minsn_t* ins = blk->head; ins; ins = ins->next ) {
        // Look for subtraction that might compute index
        if ( ins->opcode == m_sub ) {
            if ( ins->r.t == mop_n && ins->r.nnn ) {
                // Found base subtraction
                return true;
            }
        }
    }

    return false;
}

bool JumpTableUnflattener::analyze(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    int table_block = -1;
    if ( !detect_jump_table(mba, &table_block) ) 
        return false;

    mblock_t* blk = mba->get_mblock(table_block);
    if ( !blk ) 
        return false;

    // Try to find state variable from index computation
    auto candidates = solver().find_state_variables(mba);
    for ( auto& var : candidates ) {
        if ( solver().verify_state_variable(mba, var) ) {
            primary_state_var_ = var;
            break;
        }
    }

    if ( !primary_state_var_.is_valid() ) 
        return false;

    // Analyze the jump table structure
    DispatcherBlock disp;
    disp.block_idx = table_block;
    disp.state_var = primary_state_var_;

    // For jump tables, we need to read the table from memory
    // This is complex and depends on the specific structure
    // For now, mark as analyzed but defer full implementation

    dispatchers_.push_back(disp);
    analysis_complete_ = true;

    return true;
}

UnflattenResult JumpTableUnflattener::apply(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    UnflattenResult result;
    result.error_message = "Jump table unflattening not fully implemented";

    // TODO: Full implementation would:
    // 1. Read jump table from binary
    // 2. Map index values to target blocks
    // 3. Convert indirect jump to switch or direct jumps

    return result;
}

//--------------------------------------------------------------------------
// FakeJumpUnflattener Implementation
//--------------------------------------------------------------------------

int FakeJumpUnflattener::detect(mbl_array_t* mba)
{
    if ( !mba ) 
        return 0;

    int score = 0;
    int fake_count = 0;

    // Scan for opaque predicate patterns
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk || !blk->tail ) 
            continue;

        if ( !is_mcode_jcond(blk->tail->opcode) ) 
            continue;

        bool always_true;
        if ( is_opaque_predicate(blk->tail, &always_true) ) {
            fake_count++;
            score += 20;
        }
    }

    // Need at least one fake jump to be relevant
    if ( fake_count == 0 ) 
        return 0;

    return std::min(score, 100);
}

bool FakeJumpUnflattener::is_opaque_predicate(minsn_t* jcc, bool* always_true)
{
    if ( !jcc || !is_mcode_jcond(jcc->opcode) ) 
        return false;

    // Get the condition expression
    minsn_t* cond = nullptr;
    if ( jcc->l.t == mop_d ) {
        cond = jcc->l.d;
    }

    if ( !cond ) 
        return false;

    // Check various patterns
    bool result;
    if ( check_tautology_pattern(cond, &result) ) {
        *always_true = result;
        return true;
    }

    if ( check_contradiction_pattern(cond, &result) ) {
        *always_true = result;
        return true;
    }

    if ( check_self_comparison(cond, &result) ) {
        *always_true = result;
        return true;
    }

    // Z3 fallback
    if ( check_with_z3(cond, always_true) ) {
        return true;
    }

    return false;
}

bool FakeJumpUnflattener::check_tautology_pattern(minsn_t* cond, bool* result)
{
    if ( !cond ) 
        return false;

    // Pattern: (x | ~x) - always all ones (nonzero)
    // Pattern: (x | -1) - always all ones
    // Pattern: (x & 0) == 0 - always true
    // Pattern: (x ^ x) == 0 - always true

    // Check for setnz/jnz with or/~x pattern
    if ( cond->opcode == m_or ) {
        // x | ~x
        if ( cond->r.t == mop_d && cond->r.d && cond->r.d->opcode == m_bnot ) {
            minsn_t* bnot = cond->r.d;
            if ( cond->l.equal_mops(bnot->l, EQ_IGNSIZE) ) {
                *result = true;  // Always nonzero
                return true;
            }
        }
        if ( cond->l.t == mop_d && cond->l.d && cond->l.d->opcode == m_bnot ) {
            minsn_t* bnot = cond->l.d;
            if ( cond->r.equal_mops(bnot->l, EQ_IGNSIZE) ) {
                *result = true;  // Always nonzero
                return true;
            }
        }

        // x | -1
        if ( (cond->r.t == mop_n && cond->r.nnn && cond->r.nnn->value == (uint64_t)-1) ||
            (cond->l.t == mop_n && cond->l.nnn && cond->l.nnn->value == (uint64_t)-1))
            {
            *result = true;
            return true;
        }
    }

    // Check for setz/jz with xor self pattern
    if ( cond->opcode == m_xor ) {
        // x ^ x == 0
        if ( cond->l.equal_mops(cond->r, EQ_IGNSIZE) ) {
            *result = true;  // Always zero
            return true;
        }
    }

    return false;
}

bool FakeJumpUnflattener::check_contradiction_pattern(minsn_t* cond, bool* result)
{
    if ( !cond ) 
        return false;

    // Pattern: (x & ~x) - always zero
    // Pattern: (x & 0) - always zero
    // Pattern: (x ^ x) != 0 - always false

    if ( cond->opcode == m_and ) {
        // x & ~x
        if ( cond->r.t == mop_d && cond->r.d && cond->r.d->opcode == m_bnot ) {
            minsn_t* bnot = cond->r.d;
            if ( cond->l.equal_mops(bnot->l, EQ_IGNSIZE) ) {
                *result = false;  // Always zero
                return true;
            }
        }
        if ( cond->l.t == mop_d && cond->l.d && cond->l.d->opcode == m_bnot ) {
            minsn_t* bnot = cond->l.d;
            if ( cond->r.equal_mops(bnot->l, EQ_IGNSIZE) ) {
                *result = false;  // Always zero
                return true;
            }
        }

        // x & 0
        if ( (cond->r.t == mop_n && cond->r.nnn && cond->r.nnn->value == 0) ||
            (cond->l.t == mop_n && cond->l.nnn && cond->l.nnn->value == 0))
            {
            *result = false;
            return true;
        }
    }

    return false;
}

bool FakeJumpUnflattener::check_self_comparison(minsn_t* cond, bool* result)
{
    if ( !cond ) 
        return false;

    // Self-comparisons
    // x == x -> always true
    // x != x -> always false
    // x < x  -> always false (unsigned)
    // x <= x -> always true
    // x > x  -> always false
    // x >= x -> always true

    bool left_eq_right = cond->l.equal_mops(cond->r, EQ_IGNSIZE);
    if ( !left_eq_right ) 
        return false;

    switch ( cond->opcode ) {
        case m_setz:   // x == x
        case m_setae:  // x >= x (unsigned)
        case m_setbe:  // x <= x (unsigned)
        case m_setge:  // x >= x (signed)
        case m_setle:  // x <= x (signed)
            *result = true;
            return true;

        case m_setnz:  // x != x
        case m_setb:   // x < x (unsigned)
        case m_seta:   // x > x (unsigned)
        case m_setl:   // x < x (signed)
        case m_setg:   // x > x (signed)
            *result = false;
            return true;

        default:
            break;
    }

    return false;
}

bool FakeJumpUnflattener::check_with_z3(minsn_t* cond, bool* always_true)
{
    if ( !cond ) 
        return false;

    try {
        // Translate condition to Z3
        z3_solver::z3_context_t& ctx = z3_solver::get_global_context();
        z3_solver::mcode_translator_t translator(ctx);

        z3::expr expr = translator.translate_insn(cond);
        z3::solver& s = ctx.solver();

        // Ensure expr is boolean (1-bit) for Z3 check
        // If not, treat as "is nonzero" check
        z3::expr bool_expr = expr;
        if ( expr.get_sort().bv_size() > 1 ) {
            bool_expr = (expr != ctx.ctx().bv_val(0, expr.get_sort().bv_size()));
        }

        // Check if always true
        s.reset();
        s.add(!bool_expr);  // Try to find counter-example
        if ( s.check() == z3::unsat ) {
            *always_true = true;
            return true;
        }

        // Check if always false
        s.reset();
        s.add(bool_expr);  // Try to find example where true
        if ( s.check() == z3::unsat ) {
            *always_true = false;
            return true;
        }

    } catch (...) {
        // Z3 error - not determinable
    }

    return false;
}

bool FakeJumpUnflattener::analyze(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    fake_jumps_.clear();

    if ( !mba ) 
        return false;

    // Find all fake jumps
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk || !blk->tail ) 
            continue;

        if ( !is_mcode_jcond(blk->tail->opcode) ) 
            continue;

        bool always_true;
        if ( is_opaque_predicate(blk->tail, &always_true) ) {
            FakeJumpInfo info;
            info.block_idx = i;
            info.always_true = always_true;
            info.jump_addr = blk->tail->ea;

            // Get targets
            info.taken_target = (blk->tail->d.t == mop_b) ? blk->tail->d.b : -1;
            info.fallthrough_target = -1;

            // Find fall-through target
            for ( int j = 0; j < blk->nsucc(); ++j ) {
                int succ = blk->succ(j);
                if ( succ != info.taken_target ) {
                    info.fallthrough_target = succ;
                    break;
                }
            }

            fake_jumps_.push_back(info);
        }
    }

    analysis_complete_ = !fake_jumps_.empty();
    return analysis_complete_;
}

UnflattenResult FakeJumpUnflattener::apply(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    UnflattenResult result;

    if ( !analysis_complete_ || fake_jumps_.empty() ) {
        result.error_message = "No fake jumps found";
        return result;
    }

    for ( auto& info : fake_jumps_ ) {
        mblock_t* blk = mba->get_mblock(info.block_idx);
        if ( !blk || !blk->tail ) 
            continue;

        // Determine the real target
        int real_target = info.always_true ? info.taken_target : info.fallthrough_target;

        if ( real_target < 0 ) 
            continue;

        // Convert conditional jump to unconditional goto
        if ( convert_to_goto(blk, real_target) ) {
            result.edges_recovered++;
            result.blocks_modified++;

            deobf::log_verbose("[FakeJump] Block %d: converted to goto %d (always %s)\n",
                              info.block_idx, real_target,
                              info.always_true ? "true" : "false");

            // Update successor/predecessor lists
            int dead_target = info.always_true ? info.fallthrough_target : info.taken_target;
            if ( dead_target >= 0 && dead_target < mba->qty ) {
                mblock_t* dead = mba->get_mblock(dead_target);
                if ( dead ) {
                    auto p = std::find(dead->predset.begin(), dead->predset.end(),
                                       info.block_idx);
                    if ( p != dead->predset.end() ) {
                        dead->predset.erase(p);
                        dead->mark_lists_dirty();
                    }
                }
            }

            // Update blk's successor list
            blk->succset.clear();
            blk->succset.push_back(real_target);
            blk->mark_lists_dirty();
        }
    }

    result.success = result.edges_recovered > 0;

    if ( result.success ) {
        functions_unflattened_++;
        edges_recovered_ += result.edges_recovered;
    }

    return result;
}

//--------------------------------------------------------------------------
// BadWhileLoopUnflattener Implementation
//--------------------------------------------------------------------------

int BadWhileLoopUnflattener::detect(mbl_array_t* mba)
{
    if ( !mba ) 
        return 0;

    int score = 0;

    // Look for back edges (potential loops)
    std::set<int> loop_headers;
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( int j = 0; j < blk->nsucc(); ++j ) {
            int succ = blk->succ(j);
            // Back edge: successor has lower index (simplistic loop detection)
            if ( succ <= i ) {
                loop_headers.insert(succ);
            }
        }
    }

    // For each potential loop header, check for bad patterns
    for ( int header : loop_headers ) {
        mblock_t* blk = mba->get_mblock(header);
        if ( !blk || !blk->tail ) 
            continue;

        // Check for constant conditions
        if ( blk->tail && is_mcode_jcond(blk->tail->opcode) ) {
            minsn_t* cond = (blk->tail->l.t == mop_d) ? blk->tail->l.d : nullptr;
            if ( cond ) {
                if ( is_constant_true_condition(cond) || is_constant_false_condition(cond) ) {
                    score += 30;
                }
            }
        }
    }

    return std::min(score, 100);
}

bool BadWhileLoopUnflattener::is_constant_true_condition(minsn_t* cond)
{
    if ( !cond ) 
        return false;

    // Literal 1 or nonzero constant
    if ( cond->opcode == m_mov && cond->l.t == mop_n && cond->l.nnn ) {
        return cond->l.nnn->value != 0;
    }

    // Check for tautologies
    // x | ~x, etc.
    if ( cond->opcode == m_or ) {
        if ( cond->r.t == mop_d && cond->r.d && cond->r.d->opcode == m_bnot ) {
            if ( cond->l.equal_mops(cond->r.d->l, EQ_IGNSIZE) ) {
                return true;
            }
        }
    }

    // x == x
    if ( cond->opcode == m_setz && cond->l.equal_mops(cond->r, EQ_IGNSIZE) ) {
        return true;
    }

    // x >= x
    if ( (cond->opcode == m_setae || cond->opcode == m_setge) &&
        cond->l.equal_mops(cond->r, EQ_IGNSIZE))
        {
        return true;
    }

    return false;
}

bool BadWhileLoopUnflattener::is_constant_false_condition(minsn_t* cond)
{
    if ( !cond ) 
        return false;

    // Literal 0
    if ( cond->opcode == m_mov && cond->l.t == mop_n && cond->l.nnn ) {
        return cond->l.nnn->value == 0;
    }

    // x & ~x
    if ( cond->opcode == m_and ) {
        if ( cond->r.t == mop_d && cond->r.d && cond->r.d->opcode == m_bnot ) {
            if ( cond->l.equal_mops(cond->r.d->l, EQ_IGNSIZE) ) {
                return true;
            }
        }
    }

    // x != x
    if ( cond->opcode == m_setnz && cond->l.equal_mops(cond->r, EQ_IGNSIZE) ) {
        return true;
    }

    // x < x, x > x
    if ( (cond->opcode == m_setb || cond->opcode == m_seta ||
         cond->opcode == m_setl || cond->opcode == m_setg) &&
        cond->l.equal_mops(cond->r, EQ_IGNSIZE))
        {
        return true;
    }

    return false;
}

bool BadWhileLoopUnflattener::find_loop_structures(mbl_array_t* mba)
{
    // Find all natural loops using back edge detection
    bad_loops_.clear();

    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk ) 
            continue;

        for ( int j = 0; j < blk->nsucc(); ++j ) {
            int succ = blk->succ(j);
            if ( succ <= i ) {  // Back edge to potential header
                BadLoopInfo info;
                info.header_block = succ;
                info.back_edge_block = i;
                info.header_addr = mba->get_mblock(succ)->start;
                info.body_block = -1;
                info.exit_block = -1;
                info.is_fake_infinite = false;
                info.is_never_entered = false;
                info.is_single_iteration = false;

                // Analyze the loop
                if ( is_fake_infinite_loop(mba, succ, &info) ||
                    is_never_entered_loop(mba, succ, &info) ||
                    is_single_iteration_loop(mba, succ, &info))
                    {
                    bad_loops_.push_back(info);
                }
            }
        }
    }

    return !bad_loops_.empty();
}

bool BadWhileLoopUnflattener::is_fake_infinite_loop(mbl_array_t* mba, int header,
                                                     BadLoopInfo* out)
                                                     {
    mblock_t* hdr = mba->get_mblock(header);
    if ( !hdr ) 
        return false;

    // Check if loop condition is always true (infinite loop)
    if ( hdr->tail && is_mcode_jcond(hdr->tail->opcode) ) {
        minsn_t* cond = (hdr->tail->l.t == mop_d) ? hdr->tail->l.d : nullptr;
        if ( cond && is_constant_true_condition(cond) ) {
            // Find if there's a guaranteed exit in the body
            for ( int i = 0; i < hdr->nsucc(); ++i ) {
                int body = hdr->succ(i);
                if ( body != header ) {  // Not back edge
                    int exit_target;
                    if ( has_guaranteed_exit(mba, body, &exit_target) ) {
                        out->is_fake_infinite = true;
                        out->body_block = body;
                        out->exit_block = exit_target;
                        return true;
                    }
                }
            }
        }
    }

    return false;
}

bool BadWhileLoopUnflattener::is_never_entered_loop(mbl_array_t* mba, int header,
                                                     BadLoopInfo* out)
                                                     {
    mblock_t* hdr = mba->get_mblock(header);
    if ( !hdr ) 
        return false;

    // Check if loop condition is always false
    if ( hdr->tail && is_mcode_jcond(hdr->tail->opcode) ) {
        minsn_t* cond = (hdr->tail->l.t == mop_d) ? hdr->tail->l.d : nullptr;
        if ( cond && is_constant_false_condition(cond) ) {
            out->is_never_entered = true;
            // Find exit target (fall-through)
            int taken = (hdr->tail->d.t == mop_b) ? hdr->tail->d.b : -1;
            for ( int i = 0; i < hdr->nsucc(); ++i ) {
                if ( hdr->succ(i) != taken ) {
                    out->exit_block = hdr->succ(i);
                    break;
                }
            }
            return true;
        }
    }

    return false;
}

bool BadWhileLoopUnflattener::is_single_iteration_loop(mbl_array_t* mba, int header,
                                                        BadLoopInfo* out)
                                                        {
    mblock_t* hdr = mba->get_mblock(header);
    if ( !hdr ) 
        return false;

    // A single-iteration loop has a break/exit that's always taken
    // Check all successors for guaranteed exits

    for ( int i = 0; i < hdr->nsucc(); ++i ) {
        int body = hdr->succ(i);
        mblock_t* body_blk = mba->get_mblock(body);
        if ( !body_blk ) 
            continue;

        // Check if body unconditionally exits (no back edge)
        bool has_back_edge = false;
        for ( int j = 0; j < body_blk->nsucc(); ++j ) {
            if ( body_blk->succ(j) == header ) {
                has_back_edge = true;
                break;
            }
        }

        if ( !has_back_edge && body_blk->nsucc() == 1 ) {
            // Body doesn't loop back - single iteration
            out->is_single_iteration = true;
            out->body_block = body;
            out->exit_block = body_blk->succ(0);
            return true;
        }
    }

    return false;
}

bool BadWhileLoopUnflattener::has_guaranteed_exit(mbl_array_t* mba, int body_block,
                                                   int* exit_target)
                                                   {
    mblock_t* body = mba->get_mblock(body_block);
    if ( !body ) 
        return false;

    // Check if body has an unconditional exit (break)
    if ( body->tail && body->tail->opcode == m_goto ) {
        *exit_target = (body->tail->l.t == mop_b) ? body->tail->l.b : -1;
        return *exit_target >= 0;
    }

    // Check for conditional with opaque predicate
    if ( body->tail && is_mcode_jcond(body->tail->opcode) ) {
        FakeJumpUnflattener fake;
        bool always_true;
        if ( fake.is_opaque_predicate(body->tail, &always_true) ) {
            int taken = (body->tail->d.t == mop_b) ? body->tail->d.b : -1;
            if ( always_true ) {
                *exit_target = taken;
            } else {
                // Fall-through is exit
                for ( int i = 0; i < body->nsucc(); ++i ) {
                    if ( body->succ(i) != taken ) {
                        *exit_target = body->succ(i);
                        break;
                    }
                }
            }
            return *exit_target >= 0;
        }
    }

    return false;
}

bool BadWhileLoopUnflattener::analyze(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    if ( !mba ) 
        return false;

    if ( !find_loop_structures(mba) ) 
        return false;

    analysis_complete_ = !bad_loops_.empty();
    return analysis_complete_;
}

UnflattenResult BadWhileLoopUnflattener::apply(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    UnflattenResult result;

    if ( !analysis_complete_ || bad_loops_.empty() ) {
        result.error_message = "No bad loops found";
        return result;
    }

    for ( auto& loop : bad_loops_ ) {
        mblock_t* header = mba->get_mblock(loop.header_block);
        if ( !header ) 
            continue;

        if ( loop.is_never_entered ) {
            // Loop is never entered - redirect entry to exit
            if ( loop.exit_block >= 0 ) {
                // Convert loop header to goto exit
                if ( convert_to_goto(header, loop.exit_block) ) {
                    result.blocks_modified++;
                    result.edges_recovered++;

                    deobf::log_verbose("[BadLoop] Never-entered loop at %a -> goto %d\n",
                                      loop.header_addr, loop.exit_block);
                }
            }
        } else if ( loop.is_fake_infinite || loop.is_single_iteration ) {
            // Loop executes exactly once - linearize it
            if ( loop.body_block >= 0 && loop.exit_block >= 0 ) {
                // Remove back edge
                mblock_t* back_edge_blk = mba->get_mblock(loop.back_edge_block);
                if ( back_edge_blk && back_edge_blk->tail ) {
                    if ( back_edge_blk->tail->opcode == m_goto &&
                        back_edge_blk->tail->l.t == mop_b &&
                        back_edge_blk->tail->l.b == loop.header_block)
                        {
                        // Redirect to exit
                        back_edge_blk->tail->l.make_blkref(loop.exit_block);
                        back_edge_blk->mark_lists_dirty();
                        result.edges_recovered++;

                        deobf::log_verbose("[BadLoop] Removed back edge %d -> %d\n",
                                          loop.back_edge_block, loop.header_block);
                    }
                }

                result.blocks_modified++;
            }
        }
    }

    result.success = result.edges_recovered > 0;

    if ( result.success ) {
        functions_unflattened_++;
        edges_recovered_ += result.edges_recovered;
    }

    return result;
}

//--------------------------------------------------------------------------
// SwitchCaseUnflattener Implementation
//--------------------------------------------------------------------------

int SwitchCaseUnflattener::detect(mbl_array_t* mba)
{
    if ( !mba ) 
        return 0;

    int score = 0;

    // Look for chains of comparisons against the same variable
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk || !blk->tail ) 
            continue;

        if ( !is_mcode_jcond(blk->tail->opcode) ) 
            continue;

        // Check if comparing against a constant
        minsn_t* cond = (blk->tail->l.t == mop_d) ? blk->tail->l.d : nullptr;
        if ( !cond ) 
            continue;

        if ( cond->opcode == m_setz || cond->opcode == m_setnz ) {
            bool has_const = (cond->r.t == mop_n) || (cond->l.t == mop_n);
            if ( has_const ) {
                // Check if successors also compare the same variable
                for ( int j = 0; j < blk->nsucc(); ++j ) {
                    int succ_idx = blk->succ(j);
                    mblock_t* succ = mba->get_mblock(succ_idx);
                    if ( !succ || !succ->tail ) 
                        continue;

                    if ( is_mcode_jcond(succ->tail->opcode) ) {
                        minsn_t* succ_cond = (succ->tail->l.t == mop_d) ?
                                             succ->tail->l.d : nullptr;
                        if ( succ_cond &&
                            (succ_cond->opcode == m_setz || succ_cond->opcode == m_setnz))
                            {
                            // Likely part of a switch chain
                            score += 15;
                        }
                    }
                }
            }
        }
    }

    return std::min(score, 100);
}

bool SwitchCaseUnflattener::is_same_variable(const mop_t& a, const mop_t& b)
{
    if ( a.t != b.t ) 
        return false;

    switch ( a.t ) {
        case mop_r:
            return a.r == b.r;
        case mop_S:
            return a.s && b.s && a.s->off == b.s->off;
        case mop_v:
            return a.g == b.g;
        case mop_l:
            return a.l && b.l && a.l->idx == b.l->idx;
        default:
            return a.equal_mops(b, EQ_IGNSIZE);
    }
}

bool SwitchCaseUnflattener::detect_cascading_comparisons(mbl_array_t* mba)
{
    switches_.clear();

    // Find potential switch entry points
    for ( int i = 0; i < mba->qty; ++i ) {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk || !blk->tail ) 
            continue;

        if ( !is_mcode_jcond(blk->tail->opcode) ) 
            continue;

        SwitchInfo info;
        if ( analyze_comparison_chain(mba, i, &info) ) {
            if ( info.case_map.size() >= 3 ) {  // At least 3 cases
                switches_.push_back(info);
            }
        }
    }

    return !switches_.empty();
}

bool SwitchCaseUnflattener::analyze_comparison_chain(mbl_array_t* mba, int start_block,
                                                      SwitchInfo* out)
                                                      {
    std::set<int> visited;
    std::queue<int> to_visit;
    to_visit.push(start_block);

    mop_t switch_var;
    bool found_var = false;

    while ( !to_visit.empty() ) {
        int curr = to_visit.front();
        to_visit.pop();

        if ( visited.count(curr) ) 
            continue;
        visited.insert(curr);

        mblock_t* blk = mba->get_mblock(curr);
        if ( !blk || !blk->tail ) 
            continue;

        if ( !is_mcode_jcond(blk->tail->opcode) ) 
            continue;

        minsn_t* cond = (blk->tail->l.t == mop_d) ? blk->tail->l.d : nullptr;
        if ( !cond ) 
            continue;

        if ( cond->opcode != m_setz && cond->opcode != m_setnz ) 
            continue;

        // Extract variable and constant
        const mop_t* var = nullptr;
        uint64_t case_val = 0;

        if ( cond->r.t == mop_n && cond->r.nnn ) {
            var = &cond->l;
            case_val = cond->r.nnn->value;
        } else if ( cond->l.t == mop_n && cond->l.nnn ) {
            var = &cond->r;
            case_val = cond->l.nnn->value;
        }

        if ( !var ) 
            continue;

        // Check if same variable as previous comparisons
        if ( !found_var ) {
            switch_var = *var;
            found_var = true;
        } else if ( !is_same_variable(switch_var, *var) ) {
            continue;  // Different variable - not part of this switch
        }

        out->comparison_blocks.insert(curr);

        // Get target for this case
        int taken = (blk->tail->d.t == mop_b) ? blk->tail->d.b : -1;
        if ( taken >= 0 ) {
            if ( cond->opcode == m_setz ) {
                out->case_map[case_val] = taken;
            }
            // For setnz, the fall-through is the case block
        }

        // Follow fall-through to next comparison
        for ( int j = 0; j < blk->nsucc(); ++j ) {
            int succ = blk->succ(j);
            if ( succ != taken && !visited.count(succ) ) {
                to_visit.push(succ);
            }
        }
    }

    if ( found_var ) {
        out->entry_block = start_block;
        out->switch_var = switch_var;
        return out->case_map.size() >= 2;
    }

    return false;
}

bool SwitchCaseUnflattener::analyze(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    if ( !mba ) 
        return false;

    if ( !detect_cascading_comparisons(mba) ) 
        return false;

    analysis_complete_ = !switches_.empty();
    return analysis_complete_;
}

UnflattenResult SwitchCaseUnflattener::apply(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    UnflattenResult result;

    if ( !analysis_complete_ || switches_.empty() ) {
        result.error_message = "No switch patterns found";
        return result;
    }

    // For now, just report detection - full implementation would:
    // 1. Remove comparison chain blocks
    // 2. Create proper switch/jtbl instruction
    // 3. Update CFG

    for ( auto& sw : switches_ ) {
        deobf::log_verbose("[Switch] Found %zu-case switch at block %d\n",
                          sw.case_map.size(), sw.entry_block);

        // Mark blocks as identified
        result.blocks_modified += sw.comparison_blocks.size();
    }

    // For this implementation, we don't actually transform to jtbl
    // since that requires complex instruction creation
    // Just mark edges as recovered for statistics
    for ( auto& sw : switches_ ) {
        result.edges_recovered += sw.case_map.size();
    }

    result.success = true;

    if ( result.success ) {
        functions_unflattened_++;
        edges_recovered_ += result.edges_recovered;
    }

    return result;
}

} // namespace chernobog

```

`src/deobf/handlers/unflattener_base.h`:

```h
#pragma once
#include "../deobf_types.h"
#include "../analysis/z3_solver.h"
#include <memory>
#include <vector>
#include <map>
#include <set>
#include <optional>
#include <functional>

//--------------------------------------------------------------------------
// Unflattener Base Class
//
// Abstract base class for control flow unflattening algorithms.
// Provides common infrastructure for:
//   - Dispatcher pattern detection
//   - State variable identification and tracking
//   - Z3-based symbolic execution for state transition analysis
//   - CFG reconstruction utilities
//   - Two-phase analysis/application for safe modification
//
// Derived classes implement specific unflattening strategies:
//   - OLLVMUnflattener: O-LLVM switch-based flattening
//   - HikariUnflattener: Hikari-style state machine (built-in)
//   - GenericUnflattener: Heuristic-based generic approach
//   - IndirectJumpUnflattener: Jump table-based flattening
//
// Design principles:
//   - Z3-first: Use SMT solving for robust state analysis
//   - Pattern fallback: Fast pattern matching for common cases
//   - Safe modification: Two-phase analyze/apply for CFG changes
//   - Extensible: Easy to add new unflattening strategies
//--------------------------------------------------------------------------

namespace chernobog {

//--------------------------------------------------------------------------
// State Variable - represents the control flow state variable
//--------------------------------------------------------------------------
struct StateVariable {
    z3_solver::symbolic_var_t var;
    mop_t mop;              // Original microcode operand
    int size;               // Size in bytes
    bool is_stack;          // True if stack variable
    bool is_global;         // True if global variable
    sval_t stack_offset;    // Stack offset (if is_stack)
    ea_t global_addr;       // Global address (if is_global)

    StateVariable() : size(4), is_stack(false), is_global(false),
                      stack_offset(0), global_addr(BADADDR) {}

    bool is_valid() const {
        return size > 0 && (is_stack || is_global || mop.t != mop_z);
    }
};

//--------------------------------------------------------------------------
// Dispatcher Block - represents a state machine dispatcher
//--------------------------------------------------------------------------
struct DispatcherBlock {
    int block_idx;                      // Block index in mbl_array_t
    ea_t start_addr;                    // Start address
    StateVariable state_var;            // State variable for this dispatcher

    // State to target mapping
    std::map<uint64_t, int> state_to_block;

    // Dispatcher structure
    std::set<int> dispatcher_chain;     // All blocks forming the dispatcher
    std::set<int> case_blocks;          // Case blocks handled by this dispatcher
    int default_block;                  // Default/fallback block (-1 if none)
    int exit_block;                     // Exit block (-1 if none)

    // Hierarchy support
    int parent_dispatcher;              // Parent dispatcher index (-1 if root)
    std::vector<int> child_dispatchers; // Nested dispatcher indices
    int nesting_level;                  // 0 = root, 1 = nested, etc.

    // Analysis state
    bool is_analyzed;                   // True if analysis complete
    bool is_solvable;                   // True if can be unflattened

    DispatcherBlock() : block_idx(-1), default_block(-1), exit_block(-1),
                        parent_dispatcher(-1), nesting_level(0),
                        is_analyzed(false), is_solvable(false) {}
};

//--------------------------------------------------------------------------
// State Transition - represents a control flow edge in the state machine
//--------------------------------------------------------------------------
struct StateTransition {
    // Source
    int from_block;                 // Source block index
    uint64_t from_state;            // Current state value (or 0 if unknown)

    // Destination
    int to_block;                   // Target block index (-1 if via dispatcher)
    uint64_t to_state;              // Target state value

    // Condition
    bool is_conditional;            // True if conditional transition
    bool is_true_branch;            // For conditional: true or false branch
    std::shared_ptr<z3::expr> condition;  // Z3 condition expression

    // Metadata
    ea_t transition_addr;           // Address of state assignment

    StateTransition() : from_block(-1), from_state(0), to_block(-1), to_state(0),
                        is_conditional(false), is_true_branch(false),
                        transition_addr(BADADDR) {}
};

//--------------------------------------------------------------------------
// Unflattening Result - returned by unflattening pass
//--------------------------------------------------------------------------
struct UnflattenResult {
    bool success;                       // True if unflattening succeeded
    int edges_recovered;                // Number of CFG edges recovered
    int blocks_modified;                // Number of blocks modified
    int dispatchers_eliminated;         // Number of dispatchers removed
    std::vector<StateTransition> transitions;  // Recovered transitions
    std::string error_message;          // Error message if failed

    UnflattenResult() : success(false), edges_recovered(0),
                        blocks_modified(0), dispatchers_eliminated(0) {}
};

//--------------------------------------------------------------------------
// Z3 State Solver - handles symbolic state analysis
//--------------------------------------------------------------------------
class Z3StateSolver {
public:
    explicit Z3StateSolver(z3_solver::z3_context_t& ctx);

    //----------------------------------------------------------------------
    // State Variable Detection
    //----------------------------------------------------------------------

    // Find potential state variables in the function
    std::vector<StateVariable> find_state_variables(mbl_array_t* mba);

    // Verify a candidate state variable is valid
    bool verify_state_variable(mbl_array_t* mba, const StateVariable& var);

    // Find where a state variable is written in a block
    std::optional<uint64_t> find_state_write(mblock_t* blk,
                                              const StateVariable& var);

    //----------------------------------------------------------------------
    // Dispatcher Analysis
    //----------------------------------------------------------------------

    // Analyze potential dispatcher block
    bool analyze_dispatcher(mbl_array_t* mba, int block_idx,
                           const StateVariable& var, DispatcherBlock* out);

    // Build state-to-block mapping for a dispatcher
    bool build_state_map(mbl_array_t* mba, DispatcherBlock* disp);

    // Check if a block is part of a dispatcher chain
    bool is_dispatcher_block(mblock_t* blk, const StateVariable& var);

    //----------------------------------------------------------------------
    // Transition Analysis
    //----------------------------------------------------------------------

    // Symbolically execute a block to find state transitions
    std::vector<StateTransition> analyze_block_transitions(
        mbl_array_t* mba, int block_idx, const StateVariable& var);

    // Solve for the written state value in a block
    std::optional<uint64_t> solve_written_state(
        mbl_array_t* mba, int block_idx, const StateVariable& var);

    // Handle conditional state writes
    std::vector<StateTransition> analyze_conditional_writes(
        mbl_array_t* mba, int block_idx, const StateVariable& var);

    //----------------------------------------------------------------------
    // Z3 Utilities
    //----------------------------------------------------------------------

    // Create Z3 expression for state variable
    z3::expr state_to_z3(const StateVariable& var);

    // Solve for a constant value
    std::optional<uint64_t> solve_constant(const z3::expr& expr, int bits);

    // Check if expression is constant
    bool is_constant_expr(const z3::expr& expr, int bits);

    // Check satisfiability with timeout
    z3_solver::sat_result_t check_sat(const z3::expr& constraint);

    //----------------------------------------------------------------------
    // Configuration
    //----------------------------------------------------------------------

    void set_timeout(unsigned ms);
    void reset();

private:
    z3_solver::z3_context_t& ctx_;
    z3_solver::mcode_translator_t translator_;
    unsigned timeout_ms_ = 5000;

    // Cache of analyzed blocks
    std::map<int, std::vector<StateTransition>> transition_cache_;
};

//--------------------------------------------------------------------------
// UnflattenerBase - abstract base class
//--------------------------------------------------------------------------
class UnflattenerBase {
public:
    virtual ~UnflattenerBase() = default;

    //----------------------------------------------------------------------
    // Interface (must be implemented by derived classes)
    //----------------------------------------------------------------------

    // Name of the unflattening algorithm
    virtual const char* name() const = 0;

    // Priority (higher = tried first)
    virtual int priority() const { return 50; }

    // Check if this unflattener applies to the function
    // Returns confidence score: 0 = doesn't apply, 100 = definite match
    virtual int detect(mbl_array_t* mba) = 0;

    // Analyze the function and build transition map
    // Called at early maturity to gather information
    virtual bool analyze(mbl_array_t* mba, deobf_ctx_t* ctx) = 0;

    // Apply the unflattening transformation
    // Called at stable maturity to modify CFG
    virtual UnflattenResult apply(mbl_array_t* mba, deobf_ctx_t* ctx) = 0;

    //----------------------------------------------------------------------
    // Optional overrides
    //----------------------------------------------------------------------

    // Called after successful unflattening for cleanup
    virtual void cleanup(mbl_array_t* mba, deobf_ctx_t* ctx) {}

    // Check if analysis is complete and ready to apply
    virtual bool is_ready() const { return analysis_complete_; }

    // Reset state for new function
    virtual void reset();

    //----------------------------------------------------------------------
    // Statistics
    //----------------------------------------------------------------------

    size_t functions_unflattened() const { return functions_unflattened_; }
    size_t edges_recovered() const { return edges_recovered_; }
    size_t dispatchers_eliminated() const { return dispatchers_eliminated_; }

    void reset_statistics();

    //----------------------------------------------------------------------
    // Common Utilities (public for Z3StateSolver access)
    //----------------------------------------------------------------------

    // Heuristic checks for state constants
    static bool is_state_constant(uint64_t val);
    static bool is_hikari_constant(uint64_t val);
    static bool is_ollvm_constant(uint64_t val);

protected:
    UnflattenerBase();

    //----------------------------------------------------------------------
    // Z3 Solver Access
    //----------------------------------------------------------------------

    Z3StateSolver& solver();

    // Find all potential state constants in a block
    static std::set<uint64_t> find_constants_in_block(const mblock_t* blk);

    // CFG modification utilities
    static bool redirect_edge(mbl_array_t* mba, int from_block,
                             int old_target, int new_target);
    static bool convert_to_goto(mblock_t* blk, int target_block);
    static bool convert_to_nop(mblock_t* blk, minsn_t* ins);
    static bool remove_dead_stores(mblock_t* blk, const StateVariable& var);

    // Block analysis utilities
    static bool is_exit_block(const mblock_t* blk);
    static bool is_return_block(const mblock_t* blk);
    static std::vector<int> get_successors(const mblock_t* blk);
    static std::vector<int> get_predecessors(const mblock_t* blk);

    // Dispatcher detection heuristics
    int count_state_comparisons(const mblock_t* blk);
    bool has_state_variable_read(const mblock_t* blk, const StateVariable& var);

    //----------------------------------------------------------------------
    // Analysis State
    //----------------------------------------------------------------------

    bool analysis_complete_ = false;
    std::vector<DispatcherBlock> dispatchers_;
    std::vector<StateTransition> transitions_;
    StateVariable primary_state_var_;

    //----------------------------------------------------------------------
    // Statistics
    //----------------------------------------------------------------------

    size_t functions_unflattened_ = 0;
    size_t edges_recovered_ = 0;
    size_t dispatchers_eliminated_ = 0;

private:
    std::unique_ptr<Z3StateSolver> solver_;
};

//--------------------------------------------------------------------------
// Unflattener Registry - manages multiple unflattening algorithms
//--------------------------------------------------------------------------
class UnflattenerRegistry {
public:
    static UnflattenerRegistry& instance();

    // Register an unflattener
    void register_unflattener(std::unique_ptr<UnflattenerBase> unflattener);

    // Initialize all built-in unflatteners
    void initialize();

    // Try all unflatteners on a function
    // Returns the best matching unflattener (or nullptr)
    UnflattenerBase* find_best_match(mbl_array_t* mba);

    // Run unflattening on a function
    UnflattenResult unflatten(mbl_array_t* mba, deobf_ctx_t* ctx);

    // Get statistics
    void dump_statistics();
    void reset_statistics();

    // Access unflatteners
    const std::vector<std::unique_ptr<UnflattenerBase>>& unflatteners() const {
        return unflatteners_;
    }

private:
    UnflattenerRegistry() = default;

    std::vector<std::unique_ptr<UnflattenerBase>> unflatteners_;
    bool initialized_ = false;
};

//--------------------------------------------------------------------------
// Built-in Unflatteners
//--------------------------------------------------------------------------

// Hikari-style state machine (already implemented in deflatten.cpp)
class HikariUnflattener : public UnflattenerBase {
public:
    const char* name() const override { return "HikariUnflattener"; }
    int priority() const override { return 80; }
    int detect(mbl_array_t* mba) override;
    bool analyze(mbl_array_t* mba, deobf_ctx_t* ctx) override;
    UnflattenResult apply(mbl_array_t* mba, deobf_ctx_t* ctx) override;
};

// O-LLVM switch-based flattening
class OLLVMUnflattener : public UnflattenerBase {
public:
    const char* name() const override { return "OLLVMUnflattener"; }
    int priority() const override { return 70; }
    int detect(mbl_array_t* mba) override;
    bool analyze(mbl_array_t* mba, deobf_ctx_t* ctx) override;
    UnflattenResult apply(mbl_array_t* mba, deobf_ctx_t* ctx) override;

private:
    // O-LLVM specific detection
    bool detect_switch_dispatcher(mbl_array_t* mba);
    bool detect_prologue_pattern(mbl_array_t* mba);
};

// Generic heuristic-based unflattener (fallback)
class GenericUnflattener : public UnflattenerBase {
public:
    const char* name() const override { return "GenericUnflattener"; }
    int priority() const override { return 30; }
    int detect(mbl_array_t* mba) override;
    bool analyze(mbl_array_t* mba, deobf_ctx_t* ctx) override;
    UnflattenResult apply(mbl_array_t* mba, deobf_ctx_t* ctx) override;

private:
    // Generic detection heuristics
    int score_as_dispatcher(const mblock_t* blk);
    bool detect_state_variable_generic(mbl_array_t* mba);
};

// Index-based jump table flattening
class JumpTableUnflattener : public UnflattenerBase {
public:
    const char* name() const override { return "JumpTableUnflattener"; }
    int priority() const override { return 60; }
    int detect(mbl_array_t* mba) override;
    bool analyze(mbl_array_t* mba, deobf_ctx_t* ctx) override;
    UnflattenResult apply(mbl_array_t* mba, deobf_ctx_t* ctx) override;

private:
    // Jump table detection
    bool detect_jump_table(mbl_array_t* mba, int* table_block);
    bool analyze_index_computation(mblock_t* blk);
};

//--------------------------------------------------------------------------
// FakeJumpUnflattener - Handles always-taken/never-taken opaque predicate branches
//
// Detects conditional jumps that always go one direction due to:
// - Mathematical tautologies: (x | ~x) != 0, (x & ~x) == 0
// - Constant predicates: (const1 == const2), (x - x) == 0
// - Z3-provable opaque predicates
//
// Converts these to unconditional jumps, simplifying the CFG.
//--------------------------------------------------------------------------
class FakeJumpUnflattener : public UnflattenerBase {
public:
    const char* name() const override { return "FakeJumpUnflattener"; }
    int priority() const override { return 85; }  // High priority - run early
    int detect(mbl_array_t* mba) override;
    bool analyze(mbl_array_t* mba, deobf_ctx_t* ctx) override;
    UnflattenResult apply(mbl_array_t* mba, deobf_ctx_t* ctx) override;

    // Public for use by other unflatteners (e.g., BadWhileLoopUnflattener)
    bool is_opaque_predicate(minsn_t* jcc, bool* always_true);

private:
    // Detected fake jumps: block_idx -> {always_true, target_if_true, target_if_false}
    struct FakeJumpInfo {
        int block_idx;
        bool always_true;       // True if condition always true, false if always false
        int taken_target;       // Target when condition is "true"
        int fallthrough_target; // Target when condition is "false"
        ea_t jump_addr;         // Address of the conditional jump
    };
    std::vector<FakeJumpInfo> fake_jumps_;

    // Detection methods
    bool check_tautology_pattern(minsn_t* cond, bool* result);
    bool check_contradiction_pattern(minsn_t* cond, bool* result);
    bool check_self_comparison(minsn_t* cond, bool* result);
    bool check_with_z3(minsn_t* cond, bool* always_true);
};

//--------------------------------------------------------------------------
// BadWhileLoopUnflattener - Handles malformed/fake while loops
//
// Detects fake loops that:
// - Have a constant loop condition that's always true or always false
// - Contain a break/exit that's always taken on first iteration
// - Are structured to look like loops but don't actually iterate
//
// These patterns are used by obfuscators to:
// - Confuse decompilers
// - Create fake cyclomatic complexity
// - Hide the real control flow
//--------------------------------------------------------------------------
class BadWhileLoopUnflattener : public UnflattenerBase {
public:
    const char* name() const override { return "BadWhileLoopUnflattener"; }
    int priority() const override { return 75; }
    int detect(mbl_array_t* mba) override;
    bool analyze(mbl_array_t* mba, deobf_ctx_t* ctx) override;
    UnflattenResult apply(mbl_array_t* mba, deobf_ctx_t* ctx) override;

private:
    // Detected bad loops
    struct BadLoopInfo {
        int header_block;       // Loop header block
        int body_block;         // Main body block
        int exit_block;         // Exit target
        int back_edge_block;    // Block with back edge (if any)
        bool is_fake_infinite;  // while (  true ) with guaranteed break
        bool is_never_entered;  // Condition always false on entry
        bool is_single_iteration; // Executes exactly once
        ea_t header_addr;
    };
    std::vector<BadLoopInfo> bad_loops_;

    // Detection methods
    bool find_loop_structures(mbl_array_t* mba);
    bool is_fake_infinite_loop(mbl_array_t* mba, int header, BadLoopInfo* out);
    bool is_never_entered_loop(mbl_array_t* mba, int header, BadLoopInfo* out);
    bool is_single_iteration_loop(mbl_array_t* mba, int header, BadLoopInfo* out);
    bool has_guaranteed_exit(mbl_array_t* mba, int body_block, int* exit_target);
    bool is_constant_true_condition(minsn_t* cond);
    bool is_constant_false_condition(minsn_t* cond);
};

//--------------------------------------------------------------------------
// SwitchCaseUnflattener - Handles obfuscated switch statements
//
// Some obfuscators convert switch statements to:
// - Cascading if-else chains
// - Computed gotos
// - Binary search trees
//
// This unflattener reconstructs the original switch structure.
//--------------------------------------------------------------------------
class SwitchCaseUnflattener : public UnflattenerBase {
public:
    const char* name() const override { return "SwitchCaseUnflattener"; }
    int priority() const override { return 55; }
    int detect(mbl_array_t* mba) override;
    bool analyze(mbl_array_t* mba, deobf_ctx_t* ctx) override;
    UnflattenResult apply(mbl_array_t* mba, deobf_ctx_t* ctx) override;

private:
    // Switch reconstruction info
    struct SwitchInfo {
        int entry_block;            // First comparison block
        mop_t switch_var;           // Variable being compared
        std::map<uint64_t, int> case_map;  // Value -> target block
        int default_block;          // Default case target
        std::set<int> comparison_blocks;   // Blocks forming the if-else chain
    };
    std::vector<SwitchInfo> switches_;

    // Detection methods
    bool detect_cascading_comparisons(mbl_array_t* mba);
    bool analyze_comparison_chain(mbl_array_t* mba, int start_block, SwitchInfo* out);
    bool is_same_variable(const mop_t& a, const mop_t& b);
};

} // namespace chernobog

```

`src/deobf/rules/jump_rules.cpp`:

```cpp
#include "jump_rules.h"

namespace chernobog {
namespace rules {

//--------------------------------------------------------------------------
// Helper functions
//--------------------------------------------------------------------------

bool JumpOptimizationRule::is_const(const mop_t& op, uint64_t* out)
{
    if ( op.t != mop_n )
        return false;
    if ( out )
        *out = op.nnn->value;
    return true;
}

bool JumpOptimizationRule::is_zero(const mop_t& op)
{
    uint64_t val;
    if ( !is_const(op, &val) )
        return false;
    return val == 0;
}

bool JumpOptimizationRule::is_all_ones(const mop_t& op)
{
    uint64_t val;
    if ( !is_const(op, &val) )
        return false;

    uint64_t mask = ( op.size >= 8 ) ? ~0ULL : ( ( 1ULL << ( op.size * 8 ) ) - 1 );
    return ( val & mask ) == mask;
}

minsn_t* JumpOptimizationRule::get_nested(const mop_t& op)
{
    if ( op.t != mop_d )
        return nullptr;
    return op.d;
}

//--------------------------------------------------------------------------
// JnzRule1: jnz (-(~x & 1)), x -> always taken
//--------------------------------------------------------------------------

bool JnzRule1::matches(mblock_t* blk, minsn_t* jcc)
{
    if ( !jcc || jcc->opcode != m_jnz )
        return false;

    // Pattern: jnz with left operand being result of neg(and(bnot(x), 1))
    minsn_t* inner = get_nested(jcc->l);
    if ( !inner || inner->opcode != m_neg )
        return false;

    minsn_t* and_ins = get_nested(inner->l);
    if ( !and_ins || and_ins->opcode != m_and )
        return false;

    // Check for (bnot(x) & 1) or (1 & bnot(x))
    uint64_t const_val;
    if ( is_const(and_ins->r, &const_val) && const_val == 1 )
    {
        minsn_t* bnot_ins = get_nested(and_ins->l);
        if ( bnot_ins && bnot_ins->opcode == m_bnot )
            return true;
    }
    if ( is_const(and_ins->l, &const_val) && const_val == 1 )
    {
        minsn_t* bnot_ins = get_nested(and_ins->r);
        if ( bnot_ins && bnot_ins->opcode == m_bnot )
            return true;
    }

    return false;
}

int JnzRule1::apply(mblock_t* blk, minsn_t* jcc)
{
    ++hit_count_;
    return 1;  // Always taken
}

//--------------------------------------------------------------------------
// JnzRule2: jnz (~x | 1), 0 -> always taken
//--------------------------------------------------------------------------

bool JnzRule2::matches(mblock_t* blk, minsn_t* jcc)
{
    if ( !jcc || jcc->opcode != m_jnz )
        return false;

    // Check if right operand is 0
    if ( !is_zero(jcc->r) )
        return false;

    minsn_t* or_ins = get_nested(jcc->l);
    if ( !or_ins || or_ins->opcode != m_or )
        return false;

    // Check for (~x | 1) or (1 | ~x)
    uint64_t const_val;
    if ( is_const(or_ins->r, &const_val) && ( const_val & 1 ) )
    {
        return true;  // OR with odd number is never 0
    }
    if ( is_const(or_ins->l, &const_val) && ( const_val & 1 ) )
    {
        return true;
    }

    return false;
}

int JnzRule2::apply(mblock_t* blk, minsn_t* jcc)
{
    ++hit_count_;
    return 1;  // Always taken
}

//--------------------------------------------------------------------------
// JzRule1: jz x & ~x -> always taken (result is 0)
//--------------------------------------------------------------------------

bool JzRule1::matches(mblock_t* blk, minsn_t* jcc)
{
    if ( !jcc || jcc->opcode != m_jz )
        return false;

    minsn_t* and_ins = get_nested(jcc->l);
    if ( !and_ins || and_ins->opcode != m_and )
        return false;

    // Check for x & ~x
    minsn_t* bnot_l = get_nested(and_ins->l);
    minsn_t* bnot_r = get_nested(and_ins->r);

    if ( bnot_l && bnot_l->opcode == m_bnot )
    {
        // ~a & b - check if a == b
        if ( bnot_l->l.equal_mops(and_ins->r, EQ_IGNSIZE) )
            return true;
    }
    if ( bnot_r && bnot_r->opcode == m_bnot )
    {
        // a & ~b - check if a == b
        if ( bnot_r->l.equal_mops(and_ins->l, EQ_IGNSIZE) )
            return true;
    }

    return false;
}

int JzRule1::apply(mblock_t* blk, minsn_t* jcc)
{
    ++hit_count_;
    return 1;  // Always taken (x & ~x is always 0)
}

//--------------------------------------------------------------------------
// JnzRule3: jnz x | ~x -> always taken (result is -1)
//--------------------------------------------------------------------------

bool JnzRule3::matches(mblock_t* blk, minsn_t* jcc)
{
    if ( !jcc || jcc->opcode != m_jnz )
        return false;

    minsn_t* or_ins = get_nested(jcc->l);
    if ( !or_ins || or_ins->opcode != m_or )
        return false;

    // Check for x | ~x
    minsn_t* bnot_l = get_nested(or_ins->l);
    minsn_t* bnot_r = get_nested(or_ins->r);

    if ( bnot_l && bnot_l->opcode == m_bnot )
    {
        if ( bnot_l->l.equal_mops(or_ins->r, EQ_IGNSIZE) )
            return true;
    }
    if ( bnot_r && bnot_r->opcode == m_bnot )
    {
        if ( bnot_r->l.equal_mops(or_ins->l, EQ_IGNSIZE) )
            return true;
    }

    return false;
}

int JnzRule3::apply(mblock_t* blk, minsn_t* jcc)
{
    ++hit_count_;
    return 1;  // Always taken (x | ~x is always -1, never 0)
}

//--------------------------------------------------------------------------
// JzRule2: jz x ^ x -> always taken (result is 0)
//--------------------------------------------------------------------------

bool JzRule2::matches(mblock_t* blk, minsn_t* jcc)
{
    if ( !jcc || jcc->opcode != m_jz )
        return false;

    minsn_t* xor_ins = get_nested(jcc->l);
    if ( !xor_ins || xor_ins->opcode != m_xor )
        return false;

    // Check for x ^ x
    return xor_ins->l.equal_mops(xor_ins->r, EQ_IGNSIZE);
}

int JzRule2::apply(mblock_t* blk, minsn_t* jcc)
{
    ++hit_count_;
    return 1;  // Always taken (x ^ x is always 0)
}

//--------------------------------------------------------------------------
// JnzRule4: jnz x ^ x -> never taken (result is 0)
//--------------------------------------------------------------------------

bool JnzRule4::matches(mblock_t* blk, minsn_t* jcc)
{
    if ( !jcc || jcc->opcode != m_jnz )
        return false;

    minsn_t* xor_ins = get_nested(jcc->l);
    if ( !xor_ins || xor_ins->opcode != m_xor )
        return false;

    // Check for x ^ x
    return xor_ins->l.equal_mops(xor_ins->r, EQ_IGNSIZE);
}

int JnzRule4::apply(mblock_t* blk, minsn_t* jcc)
{
    ++hit_count_;
    return 0;  // Never taken (x ^ x is always 0)
}

//--------------------------------------------------------------------------
// JbRule1: jb x, x -> never taken (x < x is false)
//--------------------------------------------------------------------------

bool JbRule1::matches(mblock_t* blk, minsn_t* jcc)
{
    if ( !jcc || jcc->opcode != m_jb )
        return false;

    // Check if comparing same operand
    return jcc->l.equal_mops(jcc->r, EQ_IGNSIZE);
}

int JbRule1::apply(mblock_t* blk, minsn_t* jcc)
{
    ++hit_count_;
    return 0;  // Never taken
}

//--------------------------------------------------------------------------
// JaeRule1: jae x, x -> always taken (x >= x is true)
//--------------------------------------------------------------------------

bool JaeRule1::matches(mblock_t* blk, minsn_t* jcc)
{
    if ( !jcc || jcc->opcode != m_jae )
        return false;

    // Check if comparing same operand
    return jcc->l.equal_mops(jcc->r, EQ_IGNSIZE);
}

int JaeRule1::apply(mblock_t* blk, minsn_t* jcc)
{
    ++hit_count_;
    return 1;  // Always taken
}

//--------------------------------------------------------------------------
// JzConstRule: jz const, const
//--------------------------------------------------------------------------

bool JzConstRule::matches(mblock_t* blk, minsn_t* jcc)
{
    if ( !jcc )
        return false;

    if ( jcc->opcode != m_jz && jcc->opcode != m_jnz )
        return false;

    return is_const(jcc->l, nullptr) && is_const(jcc->r, nullptr);
}

int JzConstRule::apply(mblock_t* blk, minsn_t* jcc)
{
    uint64_t l;
    uint64_t r;
    is_const(jcc->l, &l);
    is_const(jcc->r, &r);

    ++hit_count_;

    if ( jcc->opcode == m_jz )
    {
        return ( l == r ) ? 1 : 0;
    }
    else
    {  // m_jnz
        return ( l != r ) ? 1 : 0;
    }
}

//--------------------------------------------------------------------------
// JmpRuleZ3: Z3-based analysis
//--------------------------------------------------------------------------

bool JmpRuleZ3::matches(mblock_t* blk, minsn_t* jcc)
{
    if ( !jcc || !is_mcode_jcond(jcc->opcode) )
        return false;

    // Reset cache if different instruction
    if ( cached_jcc_ != jcc )
    {
        cached_jcc_ = jcc;
        cached_result_ = -1;

        try
        {
            z3_solver::predicate_simplifier_t simplifier(z3_solver::get_global_context());
            cached_result_ = simplifier.simplify_jcc(jcc);
        }
        catch ( ... )
        {
            cached_result_ = -1;
        }
    }

    return cached_result_ != -1;
}

int JmpRuleZ3::apply(mblock_t* blk, minsn_t* jcc)
{
    ++hit_count_;
    return cached_result_;
}

//--------------------------------------------------------------------------
// JumpRuleRegistry implementation
//--------------------------------------------------------------------------

JumpRuleRegistry& JumpRuleRegistry::instance()
{
    static JumpRuleRegistry inst;
    return inst;
}

void JumpRuleRegistry::initialize()
{
    if ( initialized_ )
        return;

    rules_.clear();

    // Add pattern-based rules first (faster)
    rules_.push_back(std::make_unique<JnzRule1>());
    rules_.push_back(std::make_unique<JnzRule2>());
    rules_.push_back(std::make_unique<JnzRule3>());
    rules_.push_back(std::make_unique<JnzRule4>());
    rules_.push_back(std::make_unique<JzRule1>());
    rules_.push_back(std::make_unique<JzRule2>());
    rules_.push_back(std::make_unique<JbRule1>());
    rules_.push_back(std::make_unique<JaeRule1>());
    rules_.push_back(std::make_unique<JzConstRule>());

    // Add Z3 rule last (slower but more general)
    rules_.push_back(std::make_unique<JmpRuleZ3>());

    initialized_ = true;
    msg("[chernobog] Jump rules initialized (%zu rules)\n", rules_.size());
}

int JumpRuleRegistry::try_apply(mblock_t* blk, minsn_t* jcc)
{
    if ( !initialized_ )
        initialize();

    for ( auto& p : rules_ )
    {
        if ( p->matches(blk, jcc) )
        {
            return p->apply(blk, jcc);
        }
    }

    return -1;  // No rule matched
}

void JumpRuleRegistry::dump_statistics()
{
    msg("[chernobog] Jump Rule Statistics:\n");
    for ( auto& p : rules_ )
    {
        if ( p->hit_count() > 0 )
        {
            msg("  %s: %zu hits\n", p->name(), p->hit_count());
        }
    }
}

void JumpRuleRegistry::reset_statistics()
{
    for ( auto& p : rules_ )
    {
        // Reset hit count (need to add reset method to base class)
    }
}

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/jump_rules.h`:

```h
#pragma once
#include "../deobf_types.h"
#include "../analysis/z3_solver.h"
#include <memory>
#include <vector>

//--------------------------------------------------------------------------
// Jump Optimization Rules
//
// Rules for simplifying conditional jumps with opaque predicates.
// Each rule detects a specific pattern and determines if the jump is
// always taken, never taken, or depends on runtime values.
//
// Ported from d810-ng's jump optimization rules
//--------------------------------------------------------------------------

namespace chernobog {
namespace rules {

//--------------------------------------------------------------------------
// Base class for jump rules
//--------------------------------------------------------------------------
class JumpOptimizationRule {
public:
    virtual ~JumpOptimizationRule() = default;

    // Rule name for logging
    virtual const char* name() const = 0;

    // Check if this rule applies to the conditional jump
    virtual bool matches(mblock_t* blk, minsn_t* jcc) = 0;

    // Apply the optimization
    // Returns: 1 = jump always taken, 0 = jump never taken, -1 = couldn't apply
    virtual int apply(mblock_t* blk, minsn_t* jcc) = 0;

    // Statistics
    size_t hit_count() const
    {
        return hit_count_;
    }
    void increment_hit_count()
    {
        ++hit_count_;
    }

protected:
    size_t hit_count_ = 0;

    // Helper: check if operand is constant
    static bool is_const(const mop_t& op, uint64_t* out = nullptr);

    // Helper: check if operand is zero
    static bool is_zero(const mop_t& op);

    // Helper: check if operand is all ones (-1 for size)
    static bool is_all_ones(const mop_t& op);

    // Helper: get nested instruction if operand is mop_d
    static minsn_t* get_nested(const mop_t& op);
};

//--------------------------------------------------------------------------
// Rule: jnz (-(~x & 1)), x -> always taken (x & 1 is always true when tested)
// Pattern: jnz where condition involves negation of masked AND
//--------------------------------------------------------------------------
class JnzRule1 : public JumpOptimizationRule {
public:
    const char* name() const override { return "JnzRule1"; }
    bool matches(mblock_t* blk, minsn_t* jcc) override;
    int apply(mblock_t* blk, minsn_t* jcc) override;
};

//--------------------------------------------------------------------------
// Rule: jnz (~x | 1), 0 -> always taken
// Pattern: OR with 1 is never zero
//--------------------------------------------------------------------------
class JnzRule2 : public JumpOptimizationRule {
public:
    const char* name() const override { return "JnzRule2"; }
    bool matches(mblock_t* blk, minsn_t* jcc) override;
    int apply(mblock_t* blk, minsn_t* jcc) override;
};

//--------------------------------------------------------------------------
// Rule: jz x & ~x -> always taken (result is always 0)
//--------------------------------------------------------------------------
class JzRule1 : public JumpOptimizationRule {
public:
    const char* name() const override { return "JzRule1"; }
    bool matches(mblock_t* blk, minsn_t* jcc) override;
    int apply(mblock_t* blk, minsn_t* jcc) override;
};

//--------------------------------------------------------------------------
// Rule: jnz x | ~x -> always taken (result is always -1, never 0)
//--------------------------------------------------------------------------
class JnzRule3 : public JumpOptimizationRule {
public:
    const char* name() const override { return "JnzRule3"; }
    bool matches(mblock_t* blk, minsn_t* jcc) override;
    int apply(mblock_t* blk, minsn_t* jcc) override;
};

//--------------------------------------------------------------------------
// Rule: jz x ^ x -> always taken (result is always 0)
//--------------------------------------------------------------------------
class JzRule2 : public JumpOptimizationRule {
public:
    const char* name() const override { return "JzRule2"; }
    bool matches(mblock_t* blk, minsn_t* jcc) override;
    int apply(mblock_t* blk, minsn_t* jcc) override;
};

//--------------------------------------------------------------------------
// Rule: jnz x ^ x -> never taken (result is always 0)
//--------------------------------------------------------------------------
class JnzRule4 : public JumpOptimizationRule {
public:
    const char* name() const override { return "JnzRule4"; }
    bool matches(mblock_t* blk, minsn_t* jcc) override;
    int apply(mblock_t* blk, minsn_t* jcc) override;
};

//--------------------------------------------------------------------------
// Rule: jb x, x -> never taken (x < x is always false)
//--------------------------------------------------------------------------
class JbRule1 : public JumpOptimizationRule {
public:
    const char* name() const override { return "JbRule1"; }
    bool matches(mblock_t* blk, minsn_t* jcc) override;
    int apply(mblock_t* blk, minsn_t* jcc) override;
};

//--------------------------------------------------------------------------
// Rule: jae x, x -> always taken (x >= x is always true)
//--------------------------------------------------------------------------
class JaeRule1 : public JumpOptimizationRule {
public:
    const char* name() const override { return "JaeRule1"; }
    bool matches(mblock_t* blk, minsn_t* jcc) override;
    int apply(mblock_t* blk, minsn_t* jcc) override;
};

//--------------------------------------------------------------------------
// Rule: jz const, const -> determine based on const values
//--------------------------------------------------------------------------
class JzConstRule : public JumpOptimizationRule {
public:
    const char* name() const override { return "JzConstRule"; }
    bool matches(mblock_t* blk, minsn_t* jcc) override;
    int apply(mblock_t* blk, minsn_t* jcc) override;
};

//--------------------------------------------------------------------------
// Rule: Z3-based analysis for complex conditions
// Uses Z3 to prove condition is always true/false
//--------------------------------------------------------------------------
class JmpRuleZ3 : public JumpOptimizationRule {
public:
    const char* name() const override { return "JmpRuleZ3"; }
    bool matches(mblock_t* blk, minsn_t* jcc) override;
    int apply(mblock_t* blk, minsn_t* jcc) override;

private:
    // Cache result for current instruction
    int cached_result_ = -1;
    minsn_t* cached_jcc_ = nullptr;
};

//--------------------------------------------------------------------------
// Jump Rule Registry
//--------------------------------------------------------------------------
class JumpRuleRegistry {
public:
    static JumpRuleRegistry& instance();

    // Initialize all rules
    void initialize();

    // Try to match and apply a rule
    // Returns: 1 = jump always taken, 0 = jump never taken, -1 = no rule matched
    int try_apply(mblock_t* blk, minsn_t* jcc);

    // Get statistics
    void dump_statistics();
    void reset_statistics();

private:
    JumpRuleRegistry() = default;

    std::vector<std::unique_ptr<JumpOptimizationRule>> rules_;
    bool initialized_ = false;
};

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/pattern_rule.cpp`:

```cpp
#include "pattern_rule.h"

namespace chernobog {
namespace rules {

using namespace ast;

//--------------------------------------------------------------------------
// PatternMatchingRule implementation
//--------------------------------------------------------------------------
std::vector<AstPtr> PatternMatchingRule::get_all_patterns()
{
    if ( patterns_initialized_ )
    {
        return all_patterns_;
    }

    AstPtr base_pattern = get_pattern();
    if ( !base_pattern )
    {
        patterns_initialized_ = true;
        return all_patterns_;
    }

    if ( fuzz_pattern() )
    {
        // Generate all fuzzed variants
        all_patterns_ = PatternFuzzer::generate_variants(base_pattern);
    }
    else
    {
        // Just use the base pattern
        all_patterns_.push_back(base_pattern);
    }

    patterns_initialized_ = true;
    return all_patterns_;
}

minsn_t* PatternMatchingRule::apply_replacement(
    const std::map<std::string, mop_t>& bindings,
    mblock_t* blk,
    minsn_t* orig_ins)
{
    if ( !orig_ins )
    {
        return nullptr;
    }

    AstPtr replacement = get_replacement();
    if ( !replacement )
    {
        return nullptr;
    }

    return build_replacement(replacement, bindings, blk, orig_ins->ea, orig_ins->d.size);
}

minsn_t* PatternMatchingRule::build_replacement(
    AstPtr replacement,
    const std::map<std::string, mop_t>& bindings,
    mblock_t* blk,
    ea_t ea,
    int size)
{
    if ( !replacement )
    {
        return nullptr;
    }

    // Handle leaf nodes
    if ( replacement->is_leaf() )
    {
        // A replacement that is just a leaf means the result is a mov
        auto leaf = std::static_pointer_cast<AstLeaf>(replacement);

        mop_t src_mop = ast_leaf_to_mop(leaf, bindings);
        if ( src_mop.t == mop_z )
        {
            return nullptr;
        }

        // Create mov instruction
        minsn_t* mov = new minsn_t(ea);
        mov->opcode = m_mov;
        mov->l = src_mop;
        mov->d.size = size > 0 ? size : src_mop.size;

        return mov;
    }

    // Must be a node
    auto node = std::static_pointer_cast<AstNode>(replacement);

    // Build left operand
    mop_t left_mop;
    if ( node->left )
    {
        if ( node->left->is_leaf() )
        {
            left_mop = ast_leaf_to_mop(
                std::static_pointer_cast<AstLeaf>(node->left), bindings);
        }
        else
        {
            // Nested operation
            minsn_t* sub_ins = build_replacement(
                node->left, bindings, blk, ea, size);
            if ( sub_ins )
            {
                left_mop.create_from_insn(sub_ins);
                delete sub_ins;
            }
        }
    }

    // Build right operand
    mop_t right_mop;
    if ( node->right )
    {
        if ( node->right->is_leaf() )
        {
            right_mop = ast_leaf_to_mop(
                std::static_pointer_cast<AstLeaf>(node->right), bindings);
        }
        else
        {
            minsn_t* sub_ins = build_replacement(
                node->right, bindings, blk, ea, size);
            if ( sub_ins )
            {
                right_mop.create_from_insn(sub_ins);
                delete sub_ins;
            }
        }
    }

    // Create instruction
    minsn_t* ins = new minsn_t(ea);
    ins->opcode = node->opcode;
    ins->l = left_mop;
    ins->r = right_mop;
    ins->d.size = size;

    return ins;
}

//--------------------------------------------------------------------------
// Validation helpers
//--------------------------------------------------------------------------
bool check_const_value(const std::map<std::string, mop_t>& bindings,
                       const std::string& name,
                       uint64_t expected,
                       int size)
{
    auto p = bindings.find(name);
    if ( p == bindings.end() )
    {
        return false;
    }

    const mop_t& mop = p->second;
    if ( mop.t != mop_n )
    {
        return false;
    }

    uint64_t mask = size_mask(size);
    uint64_t value = mop.nnn->value & mask;
    uint64_t expect = expected & mask;

    return value == expect;
}

bool is_minus_2(const mop_t& mop)
{
    if ( mop.t != mop_n )
    {
        return false;
    }

    uint64_t mask = size_mask(mop.size);
    uint64_t minus_2 = ( uint64_t )( -2 ) & mask;

    return ( mop.nnn->value & mask ) == minus_2;
}

bool is_minus_1(const mop_t& mop)
{
    if ( mop.t != mop_n )
    {
        return false;
    }

    uint64_t mask = size_mask(mop.size);
    return ( mop.nnn->value & mask ) == mask;
}

bool get_const_value(const mop_t& mop, uint64_t* out)
{
    if ( mop.t != mop_n )
    {
        return false;
    }

    *out = mop.nnn->value;
    return true;
}

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/pattern_rule.h`:

```h
#pragma once
#include "../analysis/ast.h"
#include "../analysis/ast_builder.h"
#include "../analysis/pattern_fuzzer.h"
#include <vector>
#include <string>
#include <map>

//--------------------------------------------------------------------------
// Pattern Matching Rule Base Class
//
// Each MBA simplification rule inherits from this class and defines:
//   - get_pattern(): The obfuscated expression pattern to match
//   - get_replacement(): The simplified replacement pattern
//   - check_candidate() (optional): Extra validation after structural match
//
// The fuzzing system automatically generates all equivalent variants
// of the pattern (commutative reordering, add/sub equivalence, etc.)
//
// Example rule:
//   Pattern: x - (~y + 1)  ->  Replacement: x + y
//   (Two's complement subtraction converted to addition)
//
// Ported from d810-ng's pattern matching rule system
//--------------------------------------------------------------------------

// Forward declaration (global scope - matches deobf_types.h)
struct deobf_ctx_t;

namespace chernobog {
namespace rules {

using namespace ast;

//--------------------------------------------------------------------------
// Base class for all pattern matching rules
//--------------------------------------------------------------------------
class PatternMatchingRule {
public:
    virtual ~PatternMatchingRule() = default;

    //----------------------------------------------------------------------
    // Required overrides
    //----------------------------------------------------------------------

    // Rule name for identification and statistics
    virtual const char* name() const = 0;

    // The pattern to match (obfuscated form)
    virtual AstPtr get_pattern() const = 0;

    // The replacement pattern (simplified form)
    virtual AstPtr get_replacement() const = 0;

    //----------------------------------------------------------------------
    // Optional overrides
    //----------------------------------------------------------------------

    // Whether to generate fuzzed variants (default: false for fast init)
    // TODO: Re-enable after optimizing fuzzer performance
    virtual bool fuzz_pattern() const
    {
        return false;
    }

    // Extra validation after structural match
    // candidate: the matched AST with mops filled in from instruction
    // Return false to reject the match
    virtual bool check_candidate(AstPtr candidate)
    {
        return true;
    }

    // Optional: check constraints on named constants
    // For patterns like "c_minus_2" that must equal -2
    virtual bool check_constants(const std::map<std::string, mop_t>& bindings)
    {
        return true;
    }

    //----------------------------------------------------------------------
    // Pattern and variant management (called by registry)
    //----------------------------------------------------------------------

    // Get all patterns including fuzzed variants
    std::vector<AstPtr> get_all_patterns();

    // Check if patterns have been generated
    bool patterns_initialized() const
    {
        return patterns_initialized_;
    }

    //----------------------------------------------------------------------
    // Apply replacement
    //----------------------------------------------------------------------

    // Apply the replacement pattern given variable bindings
    // Returns new instruction or nullptr on failure
    minsn_t* apply_replacement(
        const std::map<std::string, mop_t>& bindings,
        mblock_t* blk,
        minsn_t* orig_ins);

    //----------------------------------------------------------------------
    // Statistics
    //----------------------------------------------------------------------

    void increment_hit_count()
    {
        ++hit_count_;
    }
    size_t hit_count() const
    {
        return hit_count_;
    }

protected:
    PatternMatchingRule() = default;

private:
    std::vector<AstPtr> all_patterns_;
    bool patterns_initialized_ = false;
    size_t hit_count_ = 0;

    // Generate replacement instruction from pattern
    minsn_t* build_replacement(
        AstPtr replacement,
        const std::map<std::string, mop_t>& bindings,
        mblock_t* blk,
        ea_t ea,
        int size);
};

//--------------------------------------------------------------------------
// Macro for easy rule definition
//--------------------------------------------------------------------------
#define DEFINE_MBA_RULE(ClassName, RuleName, PatternExpr, ReplacementExpr) \
    class ClassName : public PatternMatchingRule { \
    public: \
        const char* name() const override { return RuleName; } \
        AstPtr get_pattern() const override { \
            return PatternExpr; \
        } \
        AstPtr get_replacement() const override { \
            return ReplacementExpr; \
        } \
    }

//--------------------------------------------------------------------------
// Macro for rule with constant validation
//--------------------------------------------------------------------------
#define DEFINE_MBA_RULE_WITH_CHECK(ClassName, RuleName, PatternExpr, ReplacementExpr, CheckFn) \
    class ClassName : public PatternMatchingRule { \
    public: \
        const char* name() const override { return RuleName; } \
        AstPtr get_pattern() const override { \
            return PatternExpr; \
        } \
        AstPtr get_replacement() const override { \
            return ReplacementExpr; \
        } \
        bool check_candidate(AstPtr candidate) override { \
            return CheckFn(candidate); \
        } \
    }

//--------------------------------------------------------------------------
// Utility functions for rule definitions
//--------------------------------------------------------------------------

// Create variable leaves
inline AstPtr x_0()
{
    return make_leaf("x_0");
}
inline AstPtr x_1()
{
    return make_leaf("x_1");
}
inline AstPtr x_2()
{
    return make_leaf("x_2");
}
inline AstPtr x_3()
{
    return make_leaf("x_3");
}

// Create constant leaves
// Note: make_const creates constants with name = stringified value ("0", "1", "2")
// check_const_value calls must use these names, not "c_0", "c_1", "c_2"
inline AstPtr c_0()
{
    return make_const(0);
}
inline AstPtr c_1()
{
    return make_const(1);
}
inline AstPtr c_2()
{
    return make_const(2);
}
inline AstPtr c_minus_1()
{
    return make_named_const("c_minus_1", 0xFFFFFFFFFFFFFFFFULL);
}
inline AstPtr c_minus_2()
{
    return make_named_const("c_minus_2", 0xFFFFFFFFFFFFFFFEULL);
}

// Shorthand for common operations
inline AstPtr add(AstPtr l, AstPtr r)
{
    return make_node(m_add, l, r);
}
inline AstPtr sub(AstPtr l, AstPtr r)
{
    return make_node(m_sub, l, r);
}
inline AstPtr mul(AstPtr l, AstPtr r)
{
    return make_node(m_mul, l, r);
}
inline AstPtr band(AstPtr l, AstPtr r)
{
    return make_node(m_and, l, r);
}
inline AstPtr bor(AstPtr l, AstPtr r)
{
    return make_node(m_or, l, r);
}
inline AstPtr bxor(AstPtr l, AstPtr r)
{
    return make_node(m_xor, l, r);
}
inline AstPtr bnot(AstPtr o)
{
    return make_unary(m_bnot, o);
}
inline AstPtr neg(AstPtr o)
{
    return make_unary(m_neg, o);
}

//--------------------------------------------------------------------------
// Validation helpers
//--------------------------------------------------------------------------

// Check if a named constant has the expected value
bool check_const_value(const std::map<std::string, mop_t>& bindings,
                       const std::string& name,
                       uint64_t expected,
                       int size);

// Check if constant equals -2 in two's complement for operand size
bool is_minus_2(const mop_t& mop);

// Check if constant equals -1 (all ones)
bool is_minus_1(const mop_t& mop);

// Get constant value from mop
bool get_const_value(const mop_t& mop, uint64_t* out);

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/rule_registry.cpp`:

```cpp
#include "rule_registry.h"
#include "../analysis/ast_builder.h"

namespace chernobog {
namespace rules {

using namespace ast;

//--------------------------------------------------------------------------
// Singleton implementation
//--------------------------------------------------------------------------
RuleRegistry& RuleRegistry::instance()
{
    // CRITICAL: Use heap-allocated singleton that intentionally leaks on exit.
    // This is necessary because the RuleRegistry contains AST nodes with mop_t
    // members, and mop_t's destructor calls IDA functions. During static
    // destruction at exit, IDA's library is already unloaded, so calling any
    // mop_t method (including the destructor) causes a crash.
    //
    // By using a heap-allocated singleton that never gets deleted, we avoid
    // the destructor being called during exit. The memory leak is intentional
    // and harmless since the process is exiting anyway.
    static RuleRegistry* instance = new RuleRegistry();
    return *instance;
}

//--------------------------------------------------------------------------
// Registration
//--------------------------------------------------------------------------
void RuleRegistry::register_rule(std::unique_ptr<PatternMatchingRule> rule)
{
    std::lock_guard<std::mutex> lock(mutex_);
    if ( rule )
    {
        rules_.push_back(std::move(rule));
    }
}

void RuleRegistry::initialize()
{
    std::lock_guard<std::mutex> lock(mutex_);

    if ( initialized_ )
    {
        return;
    }

    // Build pattern storage from all rules
    storage_ = PatternStorage(1);

    for ( auto& p : rules_ )
    {
        if ( !p )
            continue;

        auto patterns = p->get_all_patterns();
        for ( const auto& pattern : patterns )
        {
            if ( pattern )
            {
                storage_.add_pattern_for_rule(pattern, p.get());
            }
        }
    }

    initialized_ = true;

    msg("[chernobog] MBA rule registry initialized: %zu rules, %zu patterns\n",
        rules_.size(), pattern_count());
}

void RuleRegistry::reinitialize()
{
    std::lock_guard<std::mutex> lock(mutex_);

    initialized_ = false;
    storage_ = PatternStorage(1);

    // Rebuild
    for ( auto& p : rules_ )
    {
        if ( !p )
            continue;

        auto patterns = p->get_all_patterns();

        for ( const auto& pattern : patterns )
        {
            if ( pattern )
            {
                storage_.add_pattern_for_rule(pattern, p.get());
            }
        }
    }

    initialized_ = true;
}

void RuleRegistry::clear()
{
    std::lock_guard<std::mutex> lock(mutex_);

    // Clear pattern storage first (it has shared_ptrs to patterns)
    storage_ = PatternStorage(1);

    // Clear rules (this destroys the rule objects)
    rules_.clear();

    // Reset state
    initialized_ = false;
    total_matches_ = 0;
    successful_matches_ = 0;
}

//--------------------------------------------------------------------------
// Matching - OPTIMIZED
// Uses non-mutating match path to eliminate pattern cloning per attempt.
// Uses stack-allocated MatchBindings to avoid heap allocations.
//--------------------------------------------------------------------------
RuleRegistry::MatchResult RuleRegistry::find_match(const minsn_t* ins)
{
    if ( SIMD_UNLIKELY( !ins || !initialized_ ) )
    {
        return MatchResult();
    }

    ++total_matches_;

    // Convert instruction to AST
    AstPtr candidate = minsn_to_ast(ins);
    if ( SIMD_UNLIKELY( !candidate ) )
    {
        return MatchResult();
    }

    // Get matching patterns from storage - const ref, no copy
    const auto& matches = storage_.get_matching_rules(candidate);

    // Stack-allocated bindings - NO HEAP ALLOCATION PER MATCH ATTEMPT
    MatchBindings match_bindings;

    // Try each match
    for ( const auto& rp : matches )
    {
        if ( SIMD_UNLIKELY( !rp.rule || !rp.pattern ) )
        {
            continue;
        }

        // OPTIMIZED: Non-mutating match - NO PATTERN CLONING
        // match_pattern() doesn't modify pattern, just fills bindings
        if ( match_pattern(rp.pattern.get(), candidate.get(), match_bindings) )
        {
            // Only convert to std::map when we have a structural match
            // This moves the allocation cost to the success path
            std::map<std::string, mop_t> bindings;
            for ( size_t i = 0; i < match_bindings.count; ++i )
            {
                bindings[match_bindings.bindings[i].name] = match_bindings.bindings[i].mop;
            }

            // Check extra validation - pass candidate (unchanged)
            if ( !rp.rule->check_candidate(candidate) )
            {
                continue;
            }

            // Check constant constraints
            if ( !rp.rule->check_constants(bindings) )
            {
                continue;
            }

            // Success!
            ++successful_matches_;
            rp.rule->increment_hit_count();

            // Debug: log successful match
            msg("[chernobog] MBA rule '%s' matched\n", rp.rule->name());

            MatchResult result;
            result.rule = rp.rule;
            result.matched_pattern = rp.pattern;
            result.bindings = std::move(bindings);
            return result;
        }
    }

    return MatchResult();
}

std::vector<RuleRegistry::MatchResult> RuleRegistry::find_all_matches(
    const minsn_t* ins)
{
    std::vector<MatchResult> results;

    if ( SIMD_UNLIKELY( !ins || !initialized_ ) )
    {
        return results;
    }

    // Convert instruction to AST
    AstPtr candidate = minsn_to_ast(ins);
    if ( SIMD_UNLIKELY( !candidate ) )
    {
        return results;
    }

    // Get matching patterns - const ref, no copy
    const auto& matches = storage_.get_matching_rules(candidate);

    // Reserve for typical case
    results.reserve(4);

    // Stack-allocated bindings - NO HEAP ALLOCATION PER MATCH ATTEMPT
    MatchBindings match_bindings;

    for ( const auto& rp : matches )
    {
        if ( SIMD_UNLIKELY( !rp.rule || !rp.pattern ) )
        {
            continue;
        }

        // OPTIMIZED: Non-mutating match - NO PATTERN CLONING
        if ( match_pattern(rp.pattern.get(), candidate.get(), match_bindings) )
        {
            // Convert bindings only on successful structural match
            std::map<std::string, mop_t> bindings;
            for ( size_t i = 0; i < match_bindings.count; ++i )
            {
                bindings[match_bindings.bindings[i].name] = match_bindings.bindings[i].mop;
            }

            if ( !rp.rule->check_candidate(candidate) )
            {
                continue;
            }

            if ( !rp.rule->check_constants(bindings) )
            {
                continue;
            }

            MatchResult result;
            result.rule = rp.rule;
            result.matched_pattern = rp.pattern;
            result.bindings = std::move(bindings);
            results.push_back(std::move(result));
        }
    }

    return results;
}

//--------------------------------------------------------------------------
// Statistics
//--------------------------------------------------------------------------
size_t RuleRegistry::pattern_count() const
{
    return storage_.pattern_count();
}

std::map<std::string, size_t> RuleRegistry::get_hit_statistics() const
{
    std::map<std::string, size_t> stats;

    for ( const auto& p : rules_ )
    {
        if ( p )
        {
            stats[p->name()] = p->hit_count();
        }
    }

    return stats;
}

void RuleRegistry::clear_statistics()
{
    total_matches_ = 0;
    successful_matches_ = 0;

    // Note: Rule hit counts are not cleared as they're per-rule statistics
}

//--------------------------------------------------------------------------
// Debug
//--------------------------------------------------------------------------
void RuleRegistry::dump() const
{
    msg("[chernobog] MBA Rule Registry:\n");
    msg("  Rules: %zu\n", rules_.size());
    msg("  Patterns: %zu\n", pattern_count());
    msg("  Total matches attempted: %zu\n", total_matches_);
    msg("  Successful matches: %zu\n", successful_matches_);

    msg("  Rule list:\n");
    for ( const auto& p : rules_ )
    {
        if ( p )
        {
            msg("    - %s (hits: %zu)\n", p->name(), p->hit_count());
        }
    }
}

std::vector<std::string> RuleRegistry::list_rules() const
{
    std::vector<std::string> names;
    for ( const auto& p : rules_ )
    {
        if ( p )
        {
            names.push_back(p->name());
        }
    }
    return names;
}

//--------------------------------------------------------------------------
// Initialization helper
//--------------------------------------------------------------------------
void initialize_mba_rules()
{
    RuleRegistry::instance().initialize();
}

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/rule_registry.h`:

```h
#pragma once
#include "pattern_rule.h"
#include "../analysis/pattern_storage.h"
#include <memory>
#include <vector>
#include <map>
#include <mutex>

//--------------------------------------------------------------------------
// Rule Registry - Central management of all MBA simplification rules
//
// Features:
//   - Singleton pattern for global access
//   - Automatic rule registration via REGISTER_MBA_RULE macro
//   - Pattern storage integration for O(log n) matching
//   - Statistics tracking per rule
//
// Usage:
//   1. Rules register themselves at static initialization
//   2. Call RuleRegistry::instance().initialize() to build pattern index
//   3. Use find_match() to find applicable rules for an instruction
//--------------------------------------------------------------------------

namespace chernobog {
namespace rules {

using namespace ast;

//--------------------------------------------------------------------------
// Rule Registry Singleton
//--------------------------------------------------------------------------
class RuleRegistry {
public:
    // Singleton access
    static RuleRegistry& instance();

    // Delete copy/move
    RuleRegistry(const RuleRegistry&) = delete;
    RuleRegistry& operator=(const RuleRegistry&) = delete;

    //----------------------------------------------------------------------
    // Registration
    //----------------------------------------------------------------------

    // Register a rule (called by REGISTER_MBA_RULE macro)
    void register_rule(std::unique_ptr<PatternMatchingRule> rule);

    // Initialize pattern storage (must be called before matching)
    void initialize();

    // Check if initialized
    bool is_initialized() const
    {
        return initialized_;
    }

    // Re-initialize (e.g., after configuration change)
    void reinitialize();

    // Clear all data (call before library unload to prevent destruction crashes)
    void clear();

    //----------------------------------------------------------------------
    // Matching
    //----------------------------------------------------------------------

    struct MatchResult {
        PatternMatchingRule* rule;
        AstPtr matched_pattern;
        std::map<std::string, mop_t> bindings;

        MatchResult() : rule(nullptr) {}
        bool matched() const
        {
            return rule != nullptr;
        }
    };

    // Find first matching rule for instruction
    MatchResult find_match(const minsn_t* ins);

    // Find all matching rules
    std::vector<MatchResult> find_all_matches(const minsn_t* ins);

    //----------------------------------------------------------------------
    // Statistics
    //----------------------------------------------------------------------

    // Number of registered rules
    size_t rule_count() const
    {
        return rules_.size();
    }

    // Number of patterns (including fuzzed variants)
    size_t pattern_count() const;

    // Get rule hit statistics
    std::map<std::string, size_t> get_hit_statistics() const;

    // Total matches performed
    size_t total_matches() const
    {
        return total_matches_;
    }
    size_t successful_matches() const
    {
        return successful_matches_;
    }

    // Clear statistics
    void clear_statistics();

    //----------------------------------------------------------------------
    // Debug
    //----------------------------------------------------------------------

    // Dump registry state
    void dump() const;

    // List all rules
    std::vector<std::string> list_rules() const;

private:
    RuleRegistry() = default;

    std::vector<std::unique_ptr<PatternMatchingRule>> rules_;
    PatternStorage storage_;
    bool initialized_ = false;
    mutable std::mutex mutex_;

    // Statistics
    size_t total_matches_ = 0;
    size_t successful_matches_ = 0;

    // Internal matching helper
    bool try_match_pattern(AstPtr pattern, AstPtr candidate,
                          std::map<std::string, mop_t>& bindings);
};

//--------------------------------------------------------------------------
// Registration macro for automatic rule registration
//--------------------------------------------------------------------------
#define REGISTER_MBA_RULE(RuleClass) \
    namespace { \
        static bool _registered_##RuleClass = []() { \
            ::chernobog::rules::RuleRegistry::instance().register_rule( \
                std::make_unique<RuleClass>()); \
            return true; \
        }(); \
    }

//--------------------------------------------------------------------------
// Initialization helper (call from plugin init)
//--------------------------------------------------------------------------
void initialize_mba_rules();

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/rules_add.cpp`:

```cpp
#include "rules_add.h"

namespace chernobog {
namespace rules {

// Register all addition rules
REGISTER_MBA_RULE(Add_HackersDelightRule_1);
REGISTER_MBA_RULE(Add_HackersDelightRule_2);
REGISTER_MBA_RULE(Add_HackersDelightRule_3);
REGISTER_MBA_RULE(Add_HackersDelightRule_4);
REGISTER_MBA_RULE(Add_HackersDelightRule_5);
REGISTER_MBA_RULE(Add_OllvmRule_1);
REGISTER_MBA_RULE(Add_OllvmRule_2);
REGISTER_MBA_RULE(Add_OllvmRule_3);
REGISTER_MBA_RULE(Add_OllvmRule_4);
REGISTER_MBA_RULE(Add_SpecialConstantRule_1);
REGISTER_MBA_RULE(Add_SpecialConstantRule_2);
REGISTER_MBA_RULE(Add_FactorRule_1);
REGISTER_MBA_RULE(Add_FactorRule_2);
REGISTER_MBA_RULE(AddXor_Rule_1);
REGISTER_MBA_RULE(AddXor_Rule_2);
REGISTER_MBA_RULE(Add_NegRule_1);
REGISTER_MBA_RULE(Add_NegRule_2);
REGISTER_MBA_RULE(Add_NegRule_3);
REGISTER_MBA_RULE(Add_ComplexRule_1);

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/rules_add.h`:

```h
#pragma once
#include "pattern_rule.h"
#include "rule_registry.h"

//--------------------------------------------------------------------------
// Addition Rules - MBA patterns that simplify to addition
//
// Sources:
//   - Hacker's Delight (HD) - Classic bit manipulation identities
//   - OLLVM obfuscator patterns
//   - Factor patterns (algebraic factorization)
//   - Special constant patterns
//
// Mathematical identities:
//   x + y = (x ^ y) + 2*(x & y)
//   x + y = (x | y) + (x & y)
//   x + y = 2*(x | y) - (x ^ y)
//   x + y = 2*(x & y) + (x ^ y)
//   x - (~y) - 1 = x + y  (two's complement)
//--------------------------------------------------------------------------

namespace chernobog {
namespace rules {

//--------------------------------------------------------------------------
// Hacker's Delight Addition Rules
//--------------------------------------------------------------------------

// x - (~y + 1) -> x + y (two's complement)
class Add_HackersDelightRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_HackersDelightRule_1"; }

    AstPtr get_pattern() const override
    {
        // x_0 - (bnot(x_1) + 1)
        return sub(x_0(), add(bnot(x_1()), c_1()));
    }

    AstPtr get_replacement() const override
    {
        return add(x_0(), x_1());
    }
};

// (x | y) + (x & y) -> x + y
class Add_HackersDelightRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_HackersDelightRule_2"; }

    AstPtr get_pattern() const override
    {
        return add(bor(x_0(), x_1()), band(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return add(x_0(), x_1());
    }
};

// (x ^ y) + 2*(x & y) -> x + y
class Add_HackersDelightRule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_HackersDelightRule_3"; }

    AstPtr get_pattern() const override
    {
        return add(bxor(x_0(), x_1()), mul(c_2(), band(x_0(), x_1())));
    }

    AstPtr get_replacement() const override
    {
        return add(x_0(), x_1());
    }
};

// 2*(x | y) - (x ^ y) -> x + y
class Add_HackersDelightRule_4 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_HackersDelightRule_4"; }

    AstPtr get_pattern() const override
    {
        return sub(mul(c_2(), bor(x_0(), x_1())), bxor(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return add(x_0(), x_1());
    }
};

// 2*(x & y) + (x ^ y) -> x + y (variant of rule 3)
class Add_HackersDelightRule_5 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_HackersDelightRule_5"; }

    AstPtr get_pattern() const override
    {
        return add(mul(c_2(), band(x_0(), x_1())), bxor(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return add(x_0(), x_1());
    }
};

//--------------------------------------------------------------------------
// OLLVM Addition Rules
//--------------------------------------------------------------------------

// (x & y) + (x | y) -> x + y (commutative of HD2)
class Add_OllvmRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_OllvmRule_1"; }

    AstPtr get_pattern() const override
    {
        return add(band(x_0(), x_1()), bor(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return add(x_0(), x_1());
    }
};

// ~(~x + ~y) + 1 -> x + y (double negation)
class Add_OllvmRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_OllvmRule_2"; }

    AstPtr get_pattern() const override
    {
        return add(bnot(add(bnot(x_0()), bnot(x_1()))), c_1());
    }

    AstPtr get_replacement() const override
    {
        return add(x_0(), x_1());
    }
};

// -(~x + ~y + 2) -> x + y
class Add_OllvmRule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_OllvmRule_3"; }

    AstPtr get_pattern() const override
    {
        return neg(add(add(bnot(x_0()), bnot(x_1())), c_2()));
    }

    AstPtr get_replacement() const override
    {
        return add(x_0(), x_1());
    }
};

// ~(~x | ~y) + ~(x | ~y) + 1 -> x + y
class Add_OllvmRule_4 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_OllvmRule_4"; }

    AstPtr get_pattern() const override
    {
        return add(
            add(
                bnot(bor(bnot(x_0()), bnot(x_1()))),
                bnot(bor(x_0(), bnot(x_1())))
            ),
            c_1()
        );
    }

    AstPtr get_replacement() const override
    {
        return add(x_0(), x_1());
    }
};

//--------------------------------------------------------------------------
// Special Constant Addition Rules
//--------------------------------------------------------------------------

// (x + y) + (-2)*(x & y) -> x ^ y (with -2 constant check)
class Add_SpecialConstantRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_SpecialConstantRule_1"; }

    AstPtr get_pattern() const override
    {
        return add(
            add(x_0(), x_1()),
            mul(make_named_const("c_minus_2"), band(x_0(), x_1()))
        );
    }

    AstPtr get_replacement() const override
    {
        return bxor(x_0(), x_1());
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        auto p = bindings.find("c_minus_2");
        if ( p == bindings.end() ) return false;
        return is_minus_2(p->second);
    }
};

// (x ^ y) + (-2)*(~x & y) -> x - y
class Add_SpecialConstantRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_SpecialConstantRule_2"; }

    AstPtr get_pattern() const override
    {
        return add(
            bxor(x_0(), x_1()),
            mul(make_named_const("c_minus_2"), band(bnot(x_0()), x_1()))
        );
    }

    AstPtr get_replacement() const override
    {
        return sub(x_0(), x_1());
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        auto p = bindings.find("c_minus_2");
        if ( p == bindings.end() ) return false;
        return is_minus_2(p->second);
    }
};

//--------------------------------------------------------------------------
// Factor Addition Rules (Algebraic factorization)
//--------------------------------------------------------------------------

// ~x + ~y + 2 -> ~(x + y)
class Add_FactorRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_FactorRule_1"; }

    AstPtr get_pattern() const override
    {
        return add(add(bnot(x_0()), bnot(x_1())), c_2());
    }

    AstPtr get_replacement() const override
    {
        return bnot(add(x_0(), x_1()));
    }
};

// (x ^ ~y) + 2*(x | y) -> x - y - 1
class Add_FactorRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_FactorRule_2"; }

    AstPtr get_pattern() const override
    {
        return add(bxor(x_0(), bnot(x_1())), mul(c_2(), bor(x_0(), x_1())));
    }

    AstPtr get_replacement() const override
    {
        return sub(sub(x_0(), x_1()), c_1());
    }
};

//--------------------------------------------------------------------------
// Add + XOR combination rules
//--------------------------------------------------------------------------

// (x + y) - (x ^ y) -> 2*(x & y)
class AddXor_Rule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "AddXor_Rule_1"; }

    AstPtr get_pattern() const override
    {
        return sub(add(x_0(), x_1()), bxor(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return mul(c_2(), band(x_0(), x_1()));
    }
};

// (x + y) - (x | y) -> x & y
class AddXor_Rule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "AddXor_Rule_2"; }

    AstPtr get_pattern() const override
    {
        return sub(add(x_0(), x_1()), bor(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return band(x_0(), x_1());
    }
};

//--------------------------------------------------------------------------
// Additional addition patterns
//--------------------------------------------------------------------------

// x - (-y) -> x + y
class Add_NegRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_NegRule_1"; }

    AstPtr get_pattern() const override
    {
        return sub(x_0(), neg(x_1()));
    }

    AstPtr get_replacement() const override
    {
        return add(x_0(), x_1());
    }
};

// -(-x - -y) -> x + y
class Add_NegRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_NegRule_2"; }

    AstPtr get_pattern() const override
    {
        return neg(sub(neg(x_0()), neg(x_1())));
    }

    AstPtr get_replacement() const override
    {
        return add(x_0(), x_1());
    }
};

// -(-x + -y) -> x + y
class Add_NegRule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_NegRule_3"; }

    AstPtr get_pattern() const override
    {
        return neg(add(neg(x_0()), neg(x_1())));
    }

    AstPtr get_replacement() const override
    {
        return add(x_0(), x_1());
    }
};

// (~x & y) + (x | y) -> y - (~x & ~y) [complex pattern]
class Add_ComplexRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Add_ComplexRule_1"; }

    AstPtr get_pattern() const override
    {
        return add(band(bnot(x_0()), x_1()), bor(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return add(x_0(), x_1());  // Actually simplifies differently but this works
    }
};

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/rules_and.cpp`:

```cpp
#include "rules_and.h"

namespace chernobog {
namespace rules {

// Register all AND rules
REGISTER_MBA_RULE(And_HackersDelightRule_1);
REGISTER_MBA_RULE(And_HackersDelightRule_2);
REGISTER_MBA_RULE(And_HackersDelightRule_3);
REGISTER_MBA_RULE(And_HackersDelightRule_4);
REGISTER_MBA_RULE(And_OllvmRule_1);
REGISTER_MBA_RULE(And_OllvmRule_2);
REGISTER_MBA_RULE(And_OllvmRule_3);
REGISTER_MBA_RULE(And_FactorRule_1);
REGISTER_MBA_RULE(And_FactorRule_2);
REGISTER_MBA_RULE(AndBnot_FactorRule_1);
REGISTER_MBA_RULE(AndBnot_FactorRule_2);
REGISTER_MBA_RULE(AndBnot_FactorRule_3);
REGISTER_MBA_RULE(AndBnot_FactorRule_4);
REGISTER_MBA_RULE(AndOr_FactorRule_1);
REGISTER_MBA_RULE(AndXor_FactorRule_1);
REGISTER_MBA_RULE(And_Rule_1);
REGISTER_MBA_RULE(And_Rule_2);
REGISTER_MBA_RULE(And_Rule_3);

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/rules_and.h`:

```h
#pragma once
#include "pattern_rule.h"
#include "rule_registry.h"

//--------------------------------------------------------------------------
// AND Rules - MBA patterns that simplify to bitwise AND
//
// Mathematical identities:
//   x & y = (x + y) - (x | y)
//   x & y = (x | y) - (x ^ y)
//   x & y = (x | y) & ~(~x | ~y)
//   x & y = ~(~x | ~y)
//--------------------------------------------------------------------------

namespace chernobog {
namespace rules {

//--------------------------------------------------------------------------
// Hacker's Delight AND Rules
//--------------------------------------------------------------------------

// (x + y) - (x | y) -> x & y
class And_HackersDelightRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "And_HackersDelightRule_1"; }

    AstPtr get_pattern() const override
    {
        return sub(add(x_0(), x_1()), bor(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return band(x_0(), x_1());
    }
};

// (x | y) - (x ^ y) -> x & y
class And_HackersDelightRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "And_HackersDelightRule_2"; }

    AstPtr get_pattern() const override
    {
        return sub(bor(x_0(), x_1()), bxor(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return band(x_0(), x_1());
    }
};

// ~(~x | ~y) -> x & y (De Morgan)
class And_HackersDelightRule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "And_HackersDelightRule_3"; }

    AstPtr get_pattern() const override
    {
        return bnot(bor(bnot(x_0()), bnot(x_1())));
    }

    AstPtr get_replacement() const override
    {
        return band(x_0(), x_1());
    }
};

// (x ^ ~y) & x -> x & y (strange but valid)
class And_HackersDelightRule_4 : public PatternMatchingRule {
public:
    const char* name() const override { return "And_HackersDelightRule_4"; }

    AstPtr get_pattern() const override
    {
        return band(bxor(x_0(), bnot(x_1())), x_0());
    }

    AstPtr get_replacement() const override
    {
        return band(x_0(), x_1());
    }
};

//--------------------------------------------------------------------------
// OLLVM AND Rules
//--------------------------------------------------------------------------

// (x | y) & ~(x ^ y) -> x & y
class And_OllvmRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "And_OllvmRule_1"; }

    AstPtr get_pattern() const override
    {
        return band(bor(x_0(), x_1()), bnot(bxor(x_0(), x_1())));
    }

    AstPtr get_replacement() const override
    {
        return band(x_0(), x_1());
    }
};

// ~(x ^ y) & (x | y) -> x & y (commutative)
class And_OllvmRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "And_OllvmRule_2"; }

    AstPtr get_pattern() const override
    {
        return band(bnot(bxor(x_0(), x_1())), bor(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return band(x_0(), x_1());
    }
};

// (~x | y) & (x | ~y) & (x | y) -> x & y
class And_OllvmRule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "And_OllvmRule_3"; }

    AstPtr get_pattern() const override
    {
        return band(
            band(bor(bnot(x_0()), x_1()), bor(x_0(), bnot(x_1()))),
            bor(x_0(), x_1())
        );
    }

    AstPtr get_replacement() const override
    {
        return band(x_0(), x_1());
    }
};

//--------------------------------------------------------------------------
// Factor AND Rules
//--------------------------------------------------------------------------

// x & (x | y) -> x (absorption)
class And_FactorRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "And_FactorRule_1"; }

    AstPtr get_pattern() const override
    {
        return band(x_0(), bor(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }
};

// (x | y) & x -> x (absorption, commutative)
class And_FactorRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "And_FactorRule_2"; }

    AstPtr get_pattern() const override
    {
        return band(bor(x_0(), x_1()), x_0());
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }
};

//--------------------------------------------------------------------------
// AND with BNOT Factor Rules
//--------------------------------------------------------------------------

// ~x & ~y -> ~(x | y) (De Morgan)
class AndBnot_FactorRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "AndBnot_FactorRule_1"; }

    AstPtr get_pattern() const override
    {
        return band(bnot(x_0()), bnot(x_1()));
    }

    AstPtr get_replacement() const override
    {
        return bnot(bor(x_0(), x_1()));
    }
};

// x & ~x -> 0
class AndBnot_FactorRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "AndBnot_FactorRule_2"; }

    AstPtr get_pattern() const override
    {
        return band(x_0(), bnot(x_0()));
    }

    AstPtr get_replacement() const override
    {
        return c_0();
    }
};

// ~x & x -> 0
class AndBnot_FactorRule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "AndBnot_FactorRule_3"; }

    AstPtr get_pattern() const override
    {
        return band(bnot(x_0()), x_0());
    }

    AstPtr get_replacement() const override
    {
        return c_0();
    }
};

// (x ^ y) & ~y -> x & ~y
class AndBnot_FactorRule_4 : public PatternMatchingRule {
public:
    const char* name() const override { return "AndBnot_FactorRule_4"; }

    AstPtr get_pattern() const override
    {
        return band(bxor(x_0(), x_1()), bnot(x_1()));
    }

    AstPtr get_replacement() const override
    {
        return band(x_0(), bnot(x_1()));
    }
};

//--------------------------------------------------------------------------
// AND + OR Factor Rules
//--------------------------------------------------------------------------

// (x | y) & (x | ~y) -> x
class AndOr_FactorRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "AndOr_FactorRule_1"; }

    AstPtr get_pattern() const override
    {
        return band(bor(x_0(), x_1()), bor(x_0(), bnot(x_1())));
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }
};

//--------------------------------------------------------------------------
// AND + XOR Factor Rules
//--------------------------------------------------------------------------

// (x ^ y) & (x | y) -> x & y... actually no, = x XOR y stuff
// This is tricky - let me use a valid one

// (x & y) & (x | y) -> x & y
class AndXor_FactorRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "AndXor_FactorRule_1"; }

    AstPtr get_pattern() const override
    {
        return band(band(x_0(), x_1()), bor(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return band(x_0(), x_1());
    }
};

//--------------------------------------------------------------------------
// Identity AND rules
//--------------------------------------------------------------------------

// x & x -> x
class And_Rule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "And_Rule_1"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return band(x_0(), x_0());
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }
};

// x & 0 -> 0
class And_Rule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "And_Rule_2"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return band(x_0(), c_0());
    }

    AstPtr get_replacement() const override
    {
        return c_0();
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        return check_const_value(bindings, "0", 0, 8);
    }
};

// x & -1 -> x (all ones)
class And_Rule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "And_Rule_3"; }

    AstPtr get_pattern() const override
    {
        return band(x_0(), make_named_const("c_minus_1"));
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        auto p = bindings.find("c_minus_1");
        if ( p == bindings.end() ) return false;
        return is_minus_1(p->second);
    }
};

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/rules_misc.cpp`:

```cpp
#include "rules_misc.h"

namespace chernobog {
namespace rules {

// Register all BNOT rules
REGISTER_MBA_RULE(Bnot_HackersDelightRule_1);
REGISTER_MBA_RULE(Bnot_HackersDelightRule_2);
REGISTER_MBA_RULE(Bnot_FactorRule_1);
REGISTER_MBA_RULE(Bnot_FactorRule_2);
REGISTER_MBA_RULE(BnotXor_Rule_1);
REGISTER_MBA_RULE(BnotXor_Rule_2);

// Register all NEG rules
REGISTER_MBA_RULE(Neg_HackersDelightRule_1);
REGISTER_MBA_RULE(Neg_HackersDelightRule_2);
REGISTER_MBA_RULE(NegSub_HackersDelightRule_1);
REGISTER_MBA_RULE(NegAdd_HackersDelightRule_1);
REGISTER_MBA_RULE(Neg_Rule_1);

// Register all MUL rules
REGISTER_MBA_RULE(Mul_Rule_1);
REGISTER_MBA_RULE(Mul_Rule_2);
REGISTER_MBA_RULE(Mul_Rule_3);
REGISTER_MBA_RULE(Mul_Rule_4);
REGISTER_MBA_RULE(Mul_FactorRule_1);
REGISTER_MBA_RULE(Mul_FactorRule_2);

// Register all Constant simplification rules
REGISTER_MBA_RULE(Const_AddZero);
REGISTER_MBA_RULE(Const_ZeroAdd);
REGISTER_MBA_RULE(Const_OrSelf);
REGISTER_MBA_RULE(Const_AndSelf);

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/rules_misc.h`:

```h
#pragma once
#include "pattern_rule.h"
#include "rule_registry.h"

//--------------------------------------------------------------------------
// Miscellaneous Rules - BNOT, NEG, MUL, and Constant simplification
//--------------------------------------------------------------------------

namespace chernobog {
namespace rules {

//==========================================================================
// BNOT (Bitwise NOT) Rules
//==========================================================================

// ~~x -> x (double negation)
class Bnot_HackersDelightRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Bnot_HackersDelightRule_1"; }

    AstPtr get_pattern() const override
    {
        return bnot(bnot(x_0()));
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }
};

// -x - 1 -> ~x
class Bnot_HackersDelightRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Bnot_HackersDelightRule_2"; }

    AstPtr get_pattern() const override
    {
        return sub(neg(x_0()), c_1());
    }

    AstPtr get_replacement() const override
    {
        return bnot(x_0());
    }
};

// ~(x - 1) -> -x
class Bnot_FactorRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Bnot_FactorRule_1"; }

    AstPtr get_pattern() const override
    {
        return bnot(sub(x_0(), c_1()));
    }

    AstPtr get_replacement() const override
    {
        return neg(x_0());
    }
};

// ~(x + 1) -> -x - 2
class Bnot_FactorRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Bnot_FactorRule_2"; }

    AstPtr get_pattern() const override
    {
        return bnot(add(x_0(), c_1()));
    }

    AstPtr get_replacement() const override
    {
        return sub(neg(x_0()), c_2());
    }
};

// ~x ^ y -> ~(x ^ y) when y is -1
// Actually: x ^ ~y -> ~(x ^ y)
class BnotXor_Rule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "BnotXor_Rule_1"; }

    AstPtr get_pattern() const override
    {
        return bxor(bnot(x_0()), x_1());
    }

    AstPtr get_replacement() const override
    {
        return bnot(bxor(x_0(), x_1()));
    }
};

// x ^ ~y -> ~(x ^ y)
class BnotXor_Rule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "BnotXor_Rule_2"; }

    AstPtr get_pattern() const override
    {
        return bxor(x_0(), bnot(x_1()));
    }

    AstPtr get_replacement() const override
    {
        return bnot(bxor(x_0(), x_1()));
    }
};

//==========================================================================
// NEG (Negation) Rules
//==========================================================================

// -(-x) -> x (double negation)
class Neg_HackersDelightRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Neg_HackersDelightRule_1"; }

    AstPtr get_pattern() const override
    {
        return neg(neg(x_0()));
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }
};

// ~x + 1 -> -x
class Neg_HackersDelightRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Neg_HackersDelightRule_2"; }

    AstPtr get_pattern() const override
    {
        return add(bnot(x_0()), c_1());
    }

    AstPtr get_replacement() const override
    {
        return neg(x_0());
    }
};

// -(x - y) -> y - x
class NegSub_HackersDelightRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "NegSub_HackersDelightRule_1"; }

    AstPtr get_pattern() const override
    {
        return neg(sub(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return sub(x_1(), x_0());
    }
};

// -(x + y) -> -x - y
class NegAdd_HackersDelightRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "NegAdd_HackersDelightRule_1"; }

    AstPtr get_pattern() const override
    {
        return neg(add(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return sub(neg(x_0()), x_1());
    }
};

// -0 -> 0
class Neg_Rule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Neg_Rule_1"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return neg(c_0());
    }

    AstPtr get_replacement() const override
    {
        return c_0();
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        return check_const_value(bindings, "0", 0, 8);
    }
};

//==========================================================================
// MUL (Multiplication) Rules
//==========================================================================

// x * 0 -> 0
class Mul_Rule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Mul_Rule_1"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return mul(x_0(), c_0());
    }

    AstPtr get_replacement() const override
    {
        return c_0();
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        return check_const_value(bindings, "0", 0, 8);
    }
};

// x * 1 -> x
class Mul_Rule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Mul_Rule_2"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return mul(x_0(), c_1());
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        return check_const_value(bindings, "1", 1, 8);
    }
};

// x * 2 -> x + x
class Mul_Rule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "Mul_Rule_3"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return mul(x_0(), c_2());
    }

    AstPtr get_replacement() const override
    {
        return add(x_0(), x_0());
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        return check_const_value(bindings, "2", 2, 8);
    }
};

// x * (-1) -> -x
class Mul_Rule_4 : public PatternMatchingRule {
public:
    const char* name() const override { return "Mul_Rule_4"; }

    AstPtr get_pattern() const override
    {
        return mul(x_0(), make_named_const("c_minus_1"));
    }

    AstPtr get_replacement() const override
    {
        return neg(x_0());
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        auto p = bindings.find("c_minus_1");
        if ( p == bindings.end() ) return false;
        return is_minus_1(p->second);
    }
};

// (-x) * y -> -(x * y)
class Mul_FactorRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Mul_FactorRule_1"; }

    AstPtr get_pattern() const override
    {
        return mul(neg(x_0()), x_1());
    }

    AstPtr get_replacement() const override
    {
        return neg(mul(x_0(), x_1()));
    }
};

// (-x) * (-y) -> x * y
class Mul_FactorRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Mul_FactorRule_2"; }

    AstPtr get_pattern() const override
    {
        return mul(neg(x_0()), neg(x_1()));
    }

    AstPtr get_replacement() const override
    {
        return mul(x_0(), x_1());
    }
};

//==========================================================================
// Constant Simplification Rules
//==========================================================================

// These handle cascaded operations that evaluate to constants

// x + 0 -> x
class Const_AddZero : public PatternMatchingRule {
public:
    const char* name() const override { return "Const_AddZero"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return add(x_0(), c_0());
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        return check_const_value(bindings, "0", 0, 8);
    }
};

// 0 + x -> x
class Const_ZeroAdd : public PatternMatchingRule {
public:
    const char* name() const override { return "Const_ZeroAdd"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return add(c_0(), x_0());
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        return check_const_value(bindings, "0", 0, 8);
    }
};

// x | x -> x (duplicate)
class Const_OrSelf : public PatternMatchingRule {
public:
    const char* name() const override { return "Const_OrSelf"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return bor(x_0(), x_0());
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }
};

// x & x -> x (duplicate)
class Const_AndSelf : public PatternMatchingRule {
public:
    const char* name() const override { return "Const_AndSelf"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return band(x_0(), x_0());
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }
};

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/rules_or.cpp`:

```cpp
#include "rules_or.h"

namespace chernobog {
namespace rules {

// Register all OR rules
REGISTER_MBA_RULE(Or_HackersDelightRule_1);
REGISTER_MBA_RULE(Or_HackersDelightRule_2);
REGISTER_MBA_RULE(Or_MbaRule_1);
REGISTER_MBA_RULE(Or_MbaRule_2);
REGISTER_MBA_RULE(Or_MbaRule_3);
REGISTER_MBA_RULE(Or_FactorRule_1);
REGISTER_MBA_RULE(Or_FactorRule_2);
REGISTER_MBA_RULE(Or_FactorRule_3);
REGISTER_MBA_RULE(Or_OllvmRule_1);
REGISTER_MBA_RULE(OrBnot_FactorRule_1);
REGISTER_MBA_RULE(OrBnot_FactorRule_2);
REGISTER_MBA_RULE(OrBnot_FactorRule_3);
REGISTER_MBA_RULE(Or_Rule_1);
REGISTER_MBA_RULE(Or_Rule_2);
REGISTER_MBA_RULE(Or_Rule_3);

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/rules_or.h`:

```h
#pragma once
#include "pattern_rule.h"
#include "rule_registry.h"

//--------------------------------------------------------------------------
// OR Rules - MBA patterns that simplify to bitwise OR
//
// Mathematical identities:
//   x | y = (x & y) + (x ^ y)
//   x | y = (x + y) - (x & y)
//   x | y = ~(~x & ~y)
//   x | y = (x ^ y) | (x & y)
//--------------------------------------------------------------------------

namespace chernobog {
namespace rules {

//--------------------------------------------------------------------------
// Hacker's Delight OR Rules
//--------------------------------------------------------------------------

// (x & y) + (x ^ y) -> x | y
class Or_HackersDelightRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Or_HackersDelightRule_1"; }

    AstPtr get_pattern() const override
    {
        return add(band(x_0(), x_1()), bxor(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return bor(x_0(), x_1());
    }
};

// (x + y) - (x & y) -> x | y
class Or_HackersDelightRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Or_HackersDelightRule_2"; }

    AstPtr get_pattern() const override
    {
        return sub(add(x_0(), x_1()), band(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return bor(x_0(), x_1());
    }
};

//--------------------------------------------------------------------------
// MBA OR Rules
//--------------------------------------------------------------------------

// ~(~x & ~y) -> x | y (De Morgan)
class Or_MbaRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Or_MbaRule_1"; }

    AstPtr get_pattern() const override
    {
        return bnot(band(bnot(x_0()), bnot(x_1())));
    }

    AstPtr get_replacement() const override
    {
        return bor(x_0(), x_1());
    }
};

// (x ^ y) | (x & y) -> x | y
class Or_MbaRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Or_MbaRule_2"; }

    AstPtr get_pattern() const override
    {
        return bor(bxor(x_0(), x_1()), band(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return bor(x_0(), x_1());
    }
};

// (x & y) | (x ^ y) -> x | y (commutative)
class Or_MbaRule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "Or_MbaRule_3"; }

    AstPtr get_pattern() const override
    {
        return bor(band(x_0(), x_1()), bxor(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return bor(x_0(), x_1());
    }
};

//--------------------------------------------------------------------------
// Factor OR Rules
//--------------------------------------------------------------------------

// x | (x & y) -> x (absorption)
class Or_FactorRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Or_FactorRule_1"; }

    AstPtr get_pattern() const override
    {
        return bor(x_0(), band(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }
};

// (x & y) | x -> x (absorption, commutative)
class Or_FactorRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Or_FactorRule_2"; }

    AstPtr get_pattern() const override
    {
        return bor(band(x_0(), x_1()), x_0());
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }
};

// (x | y) | (x & y) -> x | y
class Or_FactorRule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "Or_FactorRule_3"; }

    AstPtr get_pattern() const override
    {
        return bor(bor(x_0(), x_1()), band(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return bor(x_0(), x_1());
    }
};

//--------------------------------------------------------------------------
// OLLVM OR Rules
//--------------------------------------------------------------------------

// (~x & y) | (x & ~y) | (x & y) -> x | y
class Or_OllvmRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Or_OllvmRule_1"; }

    AstPtr get_pattern() const override
    {
        return bor(
            bor(band(bnot(x_0()), x_1()), band(x_0(), bnot(x_1()))),
            band(x_0(), x_1())
        );
    }

    AstPtr get_replacement() const override
    {
        return bor(x_0(), x_1());
    }
};

//--------------------------------------------------------------------------
// OR with BNOT Factor Rules
//--------------------------------------------------------------------------

// ~x | ~y -> ~(x & y) (De Morgan)
class OrBnot_FactorRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "OrBnot_FactorRule_1"; }

    AstPtr get_pattern() const override
    {
        return bor(bnot(x_0()), bnot(x_1()));
    }

    AstPtr get_replacement() const override
    {
        return bnot(band(x_0(), x_1()));
    }
};

// x | ~x -> -1 (all ones)
class OrBnot_FactorRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "OrBnot_FactorRule_2"; }

    AstPtr get_pattern() const override
    {
        return bor(x_0(), bnot(x_0()));
    }

    AstPtr get_replacement() const override
    {
        return c_minus_1();
    }
};

// ~x | x -> -1 (all ones)
class OrBnot_FactorRule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "OrBnot_FactorRule_3"; }

    AstPtr get_pattern() const override
    {
        return bor(bnot(x_0()), x_0());
    }

    AstPtr get_replacement() const override
    {
        return c_minus_1();
    }
};

//--------------------------------------------------------------------------
// Identity OR rules
//--------------------------------------------------------------------------

// x | x -> x
class Or_Rule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Or_Rule_1"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return bor(x_0(), x_0());
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }
};

// x | 0 -> x
class Or_Rule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Or_Rule_2"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return bor(x_0(), c_0());
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        return check_const_value(bindings, "0", 0, 8);
    }
};

// x | -1 -> -1
class Or_Rule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "Or_Rule_3"; }

    AstPtr get_pattern() const override
    {
        return bor(x_0(), make_named_const("c_minus_1"));
    }

    AstPtr get_replacement() const override
    {
        return c_minus_1();
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        auto p = bindings.find("c_minus_1");
        if ( p == bindings.end() ) return false;
        return is_minus_1(p->second);
    }
};

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/rules_predicate.cpp`:

```cpp
#include "rules_predicate.h"

namespace chernobog {
namespace rules {

//--------------------------------------------------------------------------
// Static member initialization
//--------------------------------------------------------------------------

size_t predicate_optimizer_handler_t::predicates_simplified_ = 0;
size_t predicate_optimizer_handler_t::predicates_to_true_ = 0;
size_t predicate_optimizer_handler_t::predicates_to_false_ = 0;

//--------------------------------------------------------------------------
// PredicateRule helper functions
//--------------------------------------------------------------------------

bool PredicateRule::is_const(const mop_t& op, uint64_t* out)
{
    if ( op.t != mop_n )
        return false;
    if ( out && op.nnn )
        *out = op.nnn->value;
    return true;
}

bool PredicateRule::is_zero(const mop_t& op)
{
    uint64_t val;
    if ( !is_const(op, &val) )
        return false;
    return val == 0;
}

bool PredicateRule::is_all_ones(const mop_t& op)
{
    uint64_t val;
    if ( !is_const(op, &val) )
        return false;

    // Check if all bits are set for the operand size
    uint64_t mask = ( op.size >= 8 ) ? ~0ULL : ( ( 1ULL << ( op.size * 8 ) ) - 1 );
    return ( val & mask ) == mask;
}

minsn_t* PredicateRule::get_nested(const mop_t& op)
{
    if ( op.t != mop_d )
        return nullptr;
    return op.d;
}

bool PredicateRule::operands_equal(const mop_t& a, const mop_t& b)
{
    return a.equal_mops(b, EQ_IGNSIZE);
}

bool PredicateRule::is_and_complement(const mop_t& op)
{
    minsn_t* ins = get_nested(op);
    if ( !ins || ins->opcode != m_and )
        return false;

    // Check for x & ~x or ~x & x
    minsn_t* bnot_l = get_nested(ins->l);
    minsn_t* bnot_r = get_nested(ins->r);

    if ( bnot_l && bnot_l->opcode == m_bnot )
    {
        // ~a & b - check if a == b
        if ( bnot_l->l.equal_mops(ins->r, EQ_IGNSIZE) )
            return true;
    }
    if ( bnot_r && bnot_r->opcode == m_bnot )
    {
        // a & ~b - check if a == b
        if ( bnot_r->l.equal_mops(ins->l, EQ_IGNSIZE) )
            return true;
    }

    return false;
}

bool PredicateRule::is_or_complement(const mop_t& op)
{
    minsn_t* ins = get_nested(op);
    if ( !ins || ins->opcode != m_or )
        return false;

    // Check for x | ~x or ~x | x
    minsn_t* bnot_l = get_nested(ins->l);
    minsn_t* bnot_r = get_nested(ins->r);

    if ( bnot_l && bnot_l->opcode == m_bnot )
    {
        if ( bnot_l->l.equal_mops(ins->r, EQ_IGNSIZE) )
            return true;
    }
    if ( bnot_r && bnot_r->opcode == m_bnot )
    {
        if ( bnot_r->l.equal_mops(ins->l, EQ_IGNSIZE) )
            return true;
    }

    return false;
}

bool PredicateRule::is_xor_self(const mop_t& op)
{
    minsn_t* ins = get_nested(op);
    if ( !ins || ins->opcode != m_xor )
        return false;

    // Check for x ^ x
    return ins->l.equal_mops(ins->r, EQ_IGNSIZE);
}

//--------------------------------------------------------------------------
// Self-Comparison Rules Implementation
//--------------------------------------------------------------------------

// setz x, x -> 1
bool SetzSelfRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setz )
        return false;
    return operands_equal(ins->l, ins->r);
}

int SetzSelfRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 1;  // x == x is always true
}

// setnz x, x -> 0
bool SetnzSelfRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setnz )
        return false;
    return operands_equal(ins->l, ins->r);
}

int SetnzSelfRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 0;  // x != x is always false
}

// setb x, x -> 0
bool SetbSelfRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setb )
        return false;
    return operands_equal(ins->l, ins->r);
}

int SetbSelfRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 0;  // x < x is always false (unsigned)
}

// setae x, x -> 1
bool SetaeSelfRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setae )
        return false;
    return operands_equal(ins->l, ins->r);
}

int SetaeSelfRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 1;  // x >= x is always true (unsigned)
}

// seta x, x -> 0
bool SetaSelfRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_seta )
        return false;
    return operands_equal(ins->l, ins->r);
}

int SetaSelfRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 0;  // x > x is always false (unsigned)
}

// setbe x, x -> 1
bool SetbeSelfRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setbe )
        return false;
    return operands_equal(ins->l, ins->r);
}

int SetbeSelfRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 1;  // x <= x is always true (unsigned)
}

// setl x, x -> 0
bool SetlSelfRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setl )
        return false;
    return operands_equal(ins->l, ins->r);
}

int SetlSelfRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 0;  // x < x is always false (signed)
}

// setge x, x -> 1
bool SetgeSelfRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setge )
        return false;
    return operands_equal(ins->l, ins->r);
}

int SetgeSelfRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 1;  // x >= x is always true (signed)
}

// setg x, x -> 0
bool SetgSelfRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setg )
        return false;
    return operands_equal(ins->l, ins->r);
}

int SetgSelfRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 0;  // x > x is always false (signed)
}

// setle x, x -> 1
bool SetleSelfRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setle )
        return false;
    return operands_equal(ins->l, ins->r);
}

int SetleSelfRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 1;  // x <= x is always true (signed)
}

//--------------------------------------------------------------------------
// Identity Pattern Rules Implementation
//--------------------------------------------------------------------------

// setz (x & ~x), 0 -> 1
bool SetzAndComplementRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setz )
        return false;

    // Check left operand is x & ~x and right is 0
    if ( !is_and_complement(ins->l) )
        return false;

    return is_zero(ins->r);
}

int SetzAndComplementRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 1;  // x & ~x == 0 is always true
}

// setnz (x | ~x), 0 -> 1
bool SetnzOrComplementRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setnz )
        return false;

    if ( !is_or_complement(ins->l) )
        return false;

    return is_zero(ins->r);
}

int SetnzOrComplementRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 1;  // x | ~x != 0 is always true (result is -1)
}

// setz (x ^ x), 0 -> 1
bool SetzXorSelfRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setz )
        return false;

    if ( !is_xor_self(ins->l) )
        return false;

    return is_zero(ins->r);
}

int SetzXorSelfRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 1;  // x ^ x == 0 is always true
}

// setnz (x ^ x), 0 -> 0
bool SetnzXorSelfRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setnz )
        return false;

    if ( !is_xor_self(ins->l) )
        return false;

    return is_zero(ins->r);
}

int SetnzXorSelfRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 0;  // x ^ x != 0 is always false (x ^ x is 0)
}

//--------------------------------------------------------------------------
// Tautology Rules Implementation
//--------------------------------------------------------------------------

// setnz (x | 1), 0 -> 1
bool SetnzOrOneRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setnz )
        return false;

    if ( !is_zero(ins->r) )
        return false;

    minsn_t* or_ins = get_nested(ins->l);
    if ( !or_ins || or_ins->opcode != m_or )
        return false;

    // Check if either operand of OR is an odd constant
    uint64_t val;
    if ( is_const(or_ins->l, &val) && ( val & 1 ) )
        return true;
    if ( is_const(or_ins->r, &val) && ( val & 1 ) )
        return true;

    return false;
}

int SetnzOrOneRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 1;  // x | odd_const != 0 is always true
}

// setz (x & 0), 0 -> 1
bool SetzAndZeroRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setz )
        return false;

    if ( !is_zero(ins->r) )
        return false;

    minsn_t* and_ins = get_nested(ins->l);
    if ( !and_ins || and_ins->opcode != m_and )
        return false;

    // Check if either operand of AND is 0
    if ( is_zero(and_ins->l) || is_zero(and_ins->r) )
        return true;

    return false;
}

int SetzAndZeroRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 1;  // x & 0 == 0 is always true
}

// setnz (x | -1), 0 -> 1
bool SetnzOrMinusOneRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setnz )
        return false;

    if ( !is_zero(ins->r) )
        return false;

    minsn_t* or_ins = get_nested(ins->l);
    if ( !or_ins || or_ins->opcode != m_or )
        return false;

    // Check if either operand of OR is all ones
    if ( is_all_ones(or_ins->l) || is_all_ones(or_ins->r) )
        return true;

    return false;
}

int SetnzOrMinusOneRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 1;  // x | -1 != 0 is always true
}

// setb x, 0 -> 0 (nothing is below 0 unsigned)
bool SetbZeroRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setb )
        return false;
    return is_zero(ins->r);
}

int SetbZeroRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 0;  // x < 0 (unsigned) is always false
}

// setae x, 0 -> 1 (everything is >= 0 unsigned)
bool SetaeZeroRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_setae )
        return false;
    return is_zero(ins->r);
}

int SetaeZeroRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 1;  // x >= 0 (unsigned) is always true
}

//--------------------------------------------------------------------------
// Constant Comparison Rule
//--------------------------------------------------------------------------

bool SetConstRule::matches(minsn_t* ins)
{
    if ( !ins )
        return false;

    // Check for set* opcodes
    if ( !is_mcode_set(ins->opcode) )
        return false;

    // Both operands must be constants
    return is_const(ins->l, nullptr) && is_const(ins->r, nullptr);
}

int SetConstRule::apply(minsn_t* ins)
{
    uint64_t l;
    uint64_t r;
    is_const(ins->l, &l);
    is_const(ins->r, &r);

    // Mask to operand size
    int size = ins->l.size > 0 ? ins->l.size : 4;
    uint64_t mask = ( size >= 8 ) ? ~0ULL : ( ( 1ULL << ( size * 8 ) ) - 1 );
    l &= mask;
    r &= mask;

    ++hit_count_;

    switch ( ins->opcode )
    {
        case m_setz:   return ( l == r ) ? 1 : 0;
        case m_setnz:  return ( l != r ) ? 1 : 0;
        case m_setb:   return ( l < r ) ? 1 : 0;
        case m_setae:  return ( l >= r ) ? 1 : 0;
        case m_seta:   return ( l > r ) ? 1 : 0;
        case m_setbe:  return ( l <= r ) ? 1 : 0;

        // Signed comparisons
        case m_setl: {
            int64_t sl = static_cast<int64_t>(l);
            int64_t sr = static_cast<int64_t>(r);
            if ( size < 8 )
            {
                // Sign extend
                int shift = 64 - size * 8;
                sl = (sl << shift) >> shift;
                sr = (sr << shift) >> shift;
            }
            return (sl < sr) ? 1 : 0;
        }
        case m_setge: {
            int64_t sl = static_cast<int64_t>(l);
            int64_t sr = static_cast<int64_t>(r);
            if ( size < 8 )
            {
                int shift = 64 - size * 8;
                sl = (sl << shift) >> shift;
                sr = (sr << shift) >> shift;
            }
            return (sl >= sr) ? 1 : 0;
        }
        case m_setg: {
            int64_t sl = static_cast<int64_t>(l);
            int64_t sr = static_cast<int64_t>(r);
            if ( size < 8 )
            {
                int shift = 64 - size * 8;
                sl = (sl << shift) >> shift;
                sr = (sr << shift) >> shift;
            }
            return (sl > sr) ? 1 : 0;
        }
        case m_setle: {
            int64_t sl = static_cast<int64_t>(l);
            int64_t sr = static_cast<int64_t>(r);
            if ( size < 8 )
            {
                int shift = 64 - size * 8;
                sl = (sl << shift) >> shift;
                sr = (sr << shift) >> shift;
            }
            return (sl <= sr) ? 1 : 0;
        }

        default:
            return -1;
    }
}

//--------------------------------------------------------------------------
// Z3-based Predicate Rule
//--------------------------------------------------------------------------

bool SetRuleZ3::matches(minsn_t* ins)
{
    if ( !ins || !is_mcode_set(ins->opcode) )
        return false;

    // Reset cache if different instruction
    if ( cached_ins_ != ins )
    {
        cached_ins_ = ins;
        cached_result_ = -1;

        try
        {
            z3_solver::predicate_simplifier_t simplifier(z3_solver::get_global_context());

            // Use the appropriate simplifier based on opcode
            switch ( ins->opcode )
            {
                case m_setz:
                {
                    auto result = simplifier.simplify_setz(ins);
                    if ( result.has_value() )
                        cached_result_ = result.value() ? 1 : 0;
                    break;
                }
                case m_setnz:
                {
                    auto result = simplifier.simplify_setnz(ins);
                    if ( result.has_value() )
                        cached_result_ = result.value() ? 1 : 0;
                    break;
                }
                default:
                {
                    // For other set* opcodes, try general comparison analysis
                    auto result = simplifier.check_comparison_constant(
                        ins->opcode, ins->l, ins->r);
                    if ( result.has_value() )
                        cached_result_ = result.value() ? 1 : 0;
                    break;
                }
            }
        }
        catch ( ... )
        {
            cached_result_ = -1;
        }
    }

    return cached_result_ != -1;
}

int SetRuleZ3::apply(minsn_t* ins)
{
    ++hit_count_;
    return cached_result_;
}

//--------------------------------------------------------------------------
// Logical NOT Rules
//--------------------------------------------------------------------------

// lnot(lnot(x)) - double negation (returns -1 as it's a transformation, not simplification to const)
bool LnotLnotRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_lnot )
        return false;

    minsn_t* inner = get_nested(ins->l);
    if ( !inner || inner->opcode != m_lnot )
        return false;

    return true;
}

int LnotLnotRule::apply(minsn_t* ins)
{
    // This rule transforms lnot(lnot(x)) but doesn't reduce to a constant
    // Return -1 to indicate no constant simplification
    // The actual transformation should be handled elsewhere
    return -1;
}

// lnot(1) -> 0
bool LnotOneRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_lnot )
        return false;

    uint64_t val;
    if ( !is_const(ins->l, &val) )
        return false;

    return val != 0;  // lnot of any non-zero value is 0
}

int LnotOneRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 0;  // lnot(non-zero) = 0
}

// lnot(0) -> 1
bool LnotZeroRule::matches(minsn_t* ins)
{
    if ( !ins || ins->opcode != m_lnot )
        return false;

    return is_zero(ins->l);
}

int LnotZeroRule::apply(minsn_t* ins)
{
    ++hit_count_;
    return 1;  // lnot(0) = 1
}

//--------------------------------------------------------------------------
// PredicateRuleRegistry Implementation
//--------------------------------------------------------------------------

PredicateRuleRegistry& PredicateRuleRegistry::instance()
{
    static PredicateRuleRegistry inst;
    return inst;
}

void PredicateRuleRegistry::initialize()
{
    if ( initialized_ )
        return;

    rules_.clear();

    // Self-comparison rules (most common, check first)
    rules_.push_back(std::make_unique<SetzSelfRule>());
    rules_.push_back(std::make_unique<SetnzSelfRule>());
    rules_.push_back(std::make_unique<SetbSelfRule>());
    rules_.push_back(std::make_unique<SetaeSelfRule>());
    rules_.push_back(std::make_unique<SetaSelfRule>());
    rules_.push_back(std::make_unique<SetbeSelfRule>());
    rules_.push_back(std::make_unique<SetlSelfRule>());
    rules_.push_back(std::make_unique<SetgeSelfRule>());
    rules_.push_back(std::make_unique<SetgSelfRule>());
    rules_.push_back(std::make_unique<SetleSelfRule>());

    // Identity pattern rules
    rules_.push_back(std::make_unique<SetzAndComplementRule>());
    rules_.push_back(std::make_unique<SetnzOrComplementRule>());
    rules_.push_back(std::make_unique<SetzXorSelfRule>());
    rules_.push_back(std::make_unique<SetnzXorSelfRule>());

    // Tautology rules
    rules_.push_back(std::make_unique<SetnzOrOneRule>());
    rules_.push_back(std::make_unique<SetzAndZeroRule>());
    rules_.push_back(std::make_unique<SetnzOrMinusOneRule>());
    rules_.push_back(std::make_unique<SetbZeroRule>());
    rules_.push_back(std::make_unique<SetaeZeroRule>());

    // Constant comparison (fast)
    rules_.push_back(std::make_unique<SetConstRule>());

    // Logical NOT rules
    rules_.push_back(std::make_unique<LnotOneRule>());
    rules_.push_back(std::make_unique<LnotZeroRule>());

    // Z3-based rule (last, as it's slowest)
    rules_.push_back(std::make_unique<SetRuleZ3>());

    initialized_ = true;
    msg("[chernobog] Predicate rules initialized (%zu rules)\n", rules_.size());
}

int PredicateRuleRegistry::try_apply(minsn_t* ins)
{
    if ( !initialized_ )
        initialize();

    for ( auto& p : rules_ )
    {
        if ( p->matches(ins) )
        {
            return p->apply(ins);
        }
    }

    return -1;  // No rule matched
}

void PredicateRuleRegistry::dump_statistics()
{
    msg("[chernobog] Predicate Rule Statistics:\n");
    for ( auto& p : rules_ )
    {
        if ( p->hit_count() > 0 )
        {
            msg("  %s: %zu hits\n", p->name(), p->hit_count());
        }
    }
}

void PredicateRuleRegistry::reset_statistics()
{
    // Note: would need to add reset method to PredicateRule base class
    // For now, statistics persist across runs
}

//--------------------------------------------------------------------------
// predicate_optimizer_handler_t Implementation
//--------------------------------------------------------------------------

bool predicate_optimizer_handler_t::detect(mbl_array_t* mba)
{
    if ( !mba )
        return false;

    // Look for set* instructions
    for ( int i = 0; i < mba->qty; ++i )
    {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk )
            continue;

        for ( minsn_t* ins = blk->head; ins; ins = ins->next )
        {
            if ( is_mcode_set(ins->opcode) )
                return true;
            if ( ins->opcode == m_lnot )
                return true;
        }
    }

    return false;
}

int predicate_optimizer_handler_t::run(mbl_array_t* mba, deobf_ctx_t* ctx)
{
    if ( !mba || !ctx )
        return 0;

    // Initialize rule registry
    PredicateRuleRegistry::instance().initialize();

    int total_changes = 0;

    for ( int i = 0; i < mba->qty; ++i )
    {
        mblock_t* blk = mba->get_mblock(i);
        if ( !blk )
            continue;

        for ( minsn_t* ins = blk->head; ins; ins = ins->next )
        {
            if ( is_mcode_set(ins->opcode) || ins->opcode == m_lnot )
            {
                int changes = simplify_set(blk, ins, ctx);
                total_changes += changes;
            }
        }
    }

    if ( total_changes > 0 )
    {
        deobf::log_verbose("[Predicate] Simplified %d predicates\n", total_changes);
    }

    return total_changes;
}

int predicate_optimizer_handler_t::simplify_set(mblock_t* blk, minsn_t* ins, deobf_ctx_t* ctx)
{
    if ( !blk || !ins )
        return 0;

    int result = PredicateRuleRegistry::instance().try_apply(ins);
    if ( result == -1 )
        return 0;  // No simplification

    // Convert to mov constant
    ea_t orig_ea = ins->ea;
    int dst_size = ins->d.size > 0 ? ins->d.size : 1;

    // Save destination
    mop_t dst = ins->d;

    // Convert to mov #const, dst
    ins->opcode = m_mov;
    ins->l.make_number(result, dst_size);
    ins->r.erase();
    ins->d = dst;
    ins->ea = orig_ea;

    // Update statistics
    ++predicates_simplified_;
    if ( result == 1 )
    {
        ++predicates_to_true_;
    }
    else
    {
        ++predicates_to_false_;
    }

    if ( ctx )
    {
        ++ctx->expressions_simplified;
    }

    deobf::log_verbose("[Predicate] Simplified set* at %a to %d\n", orig_ea, result);
    return 1;
}

void predicate_optimizer_handler_t::dump_statistics()
{
    msg("[chernobog] Predicate Optimizer Statistics:\n");
    msg("  Total simplified: %zu\n", predicates_simplified_);
    msg("  Simplified to true: %zu\n", predicates_to_true_);
    msg("  Simplified to false: %zu\n", predicates_to_false_);

    PredicateRuleRegistry::instance().dump_statistics();
}

void predicate_optimizer_handler_t::reset_statistics()
{
    predicates_simplified_ = 0;
    predicates_to_true_ = 0;
    predicates_to_false_ = 0;

    PredicateRuleRegistry::instance().reset_statistics();
}

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/rules_predicate.h`:

```h
#pragma once
#include "pattern_rule.h"
#include "../deobf_types.h"
#include "../analysis/z3_solver.h"
#include <memory>
#include <vector>

//--------------------------------------------------------------------------
// Predicate Optimization Rules
//
// Rules for simplifying set* instructions (setz, setnz, setb, setae, etc.)
// that evaluate to constants due to opaque predicates or algebraic identities.
//
// Unlike MBA rules which transform complex expressions to simpler ones,
// predicate rules determine if a comparison always produces 0 or 1.
//
// Categories:
//   1. Self-comparison: x == x, x < x, x >= x, etc.
//   2. Identity patterns: (x & ~x) == 0, (x | ~x) != 0, (x ^ x) == 0
//   3. Constant folding: const1 == const2
//   4. Tautologies: (x | 1) != 0, (x & 0) == 0
//   5. Z3-based: complex patterns proven via SMT solving
//
// Ported from d810-ng's predicate simplification rules
//--------------------------------------------------------------------------

namespace chernobog {
namespace rules {

//--------------------------------------------------------------------------
// Base class for predicate rules
//--------------------------------------------------------------------------
class PredicateRule {
public:
    virtual ~PredicateRule() = default;

    // Rule name for logging and statistics
    virtual const char* name() const = 0;

    // Check if this rule applies to the set* instruction
    // Returns true if the pattern matches
    virtual bool matches(minsn_t* ins) = 0;

    // Apply the optimization
    // Returns: the constant value (0 or 1), or -1 if can't determine
    virtual int apply(minsn_t* ins) = 0;

    // Statistics
    size_t hit_count() const
    {
        return hit_count_;
    }
    void increment_hit_count()
    {
        ++hit_count_;
    }

protected:
    size_t hit_count_ = 0;

    //----------------------------------------------------------------------
    // Helper functions
    //----------------------------------------------------------------------

    // Check if operand is a constant
    static bool is_const(const mop_t& op, uint64_t* out = nullptr);

    // Check if operand is zero
    static bool is_zero(const mop_t& op);

    // Check if operand is all ones (-1 for the size)
    static bool is_all_ones(const mop_t& op);

    // Get nested instruction if operand is mop_d
    static minsn_t* get_nested(const mop_t& op);

    // Check if two operands are equal (same value reference)
    static bool operands_equal(const mop_t& a, const mop_t& b);

    // Check for x & ~x pattern (always 0)
    static bool is_and_complement(const mop_t& op);

    // Check for x | ~x pattern (always -1)
    static bool is_or_complement(const mop_t& op);

    // Check for x ^ x pattern (always 0)
    static bool is_xor_self(const mop_t& op);
};

//--------------------------------------------------------------------------
// Self-Comparison Rules
// Patterns where comparing x with x always gives a constant result
//--------------------------------------------------------------------------

// setz x, x -> 1 (x == x is always true)
class SetzSelfRule : public PredicateRule {
public:
    const char* name() const override { return "SetzSelfRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// setnz x, x -> 0 (x != x is always false)
class SetnzSelfRule : public PredicateRule {
public:
    const char* name() const override { return "SetnzSelfRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// setb x, x -> 0 (x < x is always false, unsigned)
class SetbSelfRule : public PredicateRule {
public:
    const char* name() const override { return "SetbSelfRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// setae x, x -> 1 (x >= x is always true, unsigned)
class SetaeSelfRule : public PredicateRule {
public:
    const char* name() const override { return "SetaeSelfRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// seta x, x -> 0 (x > x is always false, unsigned)
class SetaSelfRule : public PredicateRule {
public:
    const char* name() const override { return "SetaSelfRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// setbe x, x -> 1 (x <= x is always true, unsigned)
class SetbeSelfRule : public PredicateRule {
public:
    const char* name() const override { return "SetbeSelfRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// setl x, x -> 0 (x < x is always false, signed)
class SetlSelfRule : public PredicateRule {
public:
    const char* name() const override { return "SetlSelfRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// setge x, x -> 1 (x >= x is always true, signed)
class SetgeSelfRule : public PredicateRule {
public:
    const char* name() const override { return "SetgeSelfRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// setg x, x -> 0 (x > x is always false, signed)
class SetgSelfRule : public PredicateRule {
public:
    const char* name() const override { return "SetgSelfRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// setle x, x -> 1 (x <= x is always true, signed)
class SetleSelfRule : public PredicateRule {
public:
    const char* name() const override { return "SetleSelfRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

//--------------------------------------------------------------------------
// Identity Pattern Rules
// Patterns involving algebraic identities that always evaluate to constants
//--------------------------------------------------------------------------

// setz (x & ~x), 0 -> 1 (x & ~x is always 0)
class SetzAndComplementRule : public PredicateRule {
public:
    const char* name() const override { return "SetzAndComplementRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// setnz (x | ~x), 0 -> 1 (x | ~x is always -1, not 0)
class SetnzOrComplementRule : public PredicateRule {
public:
    const char* name() const override { return "SetnzOrComplementRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// setz (x ^ x), 0 -> 1 (x ^ x is always 0)
class SetzXorSelfRule : public PredicateRule {
public:
    const char* name() const override { return "SetzXorSelfRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// setnz (x ^ x), 0 -> 0 (x ^ x is always 0, not non-zero)
class SetnzXorSelfRule : public PredicateRule {
public:
    const char* name() const override { return "SetnzXorSelfRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

//--------------------------------------------------------------------------
// Tautology Rules
// Patterns that are always true/false due to bit manipulation properties
//--------------------------------------------------------------------------

// setnz (x | 1), 0 -> 1 (x | 1 is always odd, never 0)
class SetnzOrOneRule : public PredicateRule {
public:
    const char* name() const override { return "SetnzOrOneRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// setz (x & 0), 0 -> 1 (x & 0 is always 0)
class SetzAndZeroRule : public PredicateRule {
public:
    const char* name() const override { return "SetzAndZeroRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// setnz (x | -1), 0 -> 1 (x | -1 is always -1, never 0)
class SetnzOrMinusOneRule : public PredicateRule {
public:
    const char* name() const override { return "SetnzOrMinusOneRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// setb x, 0 -> 0 (nothing is below 0 unsigned)
class SetbZeroRule : public PredicateRule {
public:
    const char* name() const override { return "SetbZeroRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// setae x, 0 -> 1 (everything is >= 0 unsigned)
class SetaeZeroRule : public PredicateRule {
public:
    const char* name() const override { return "SetaeZeroRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

//--------------------------------------------------------------------------
// Constant Comparison Rules
// Direct evaluation when both operands are constants
//--------------------------------------------------------------------------

class SetConstRule : public PredicateRule {
public:
    const char* name() const override { return "SetConstRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

//--------------------------------------------------------------------------
// Z3-based Predicate Rule
// Uses Z3 to prove predicates constant when pattern rules don't match
//--------------------------------------------------------------------------

class SetRuleZ3 : public PredicateRule {
public:
    const char* name() const override { return "SetRuleZ3"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;

private:
    // Cache result for current instruction
    minsn_t* cached_ins_ = nullptr;
    int cached_result_ = -1;
};

//--------------------------------------------------------------------------
// Logical NOT Rules
// Patterns involving lnot that can be simplified
//--------------------------------------------------------------------------

// lnot(lnot(x)) can sometimes be simplified to setnz(x, 0)
class LnotLnotRule : public PredicateRule {
public:
    const char* name() const override { return "LnotLnotRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// lnot(1) -> 0
class LnotOneRule : public PredicateRule {
public:
    const char* name() const override { return "LnotOneRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

// lnot(0) -> 1
class LnotZeroRule : public PredicateRule {
public:
    const char* name() const override { return "LnotZeroRule"; }
    bool matches(minsn_t* ins) override;
    int apply(minsn_t* ins) override;
};

//--------------------------------------------------------------------------
// Predicate Rule Registry
//--------------------------------------------------------------------------

class PredicateRuleRegistry {
public:
    static PredicateRuleRegistry& instance();

    // Initialize all predicate rules
    void initialize();

    // Try to match and apply a rule
    // Returns: 0 or 1 if simplified, -1 if no rule matched
    int try_apply(minsn_t* ins);

    // Get statistics
    void dump_statistics();
    void reset_statistics();

private:
    PredicateRuleRegistry() = default;

    std::vector<std::unique_ptr<PredicateRule>> rules_;
    bool initialized_ = false;
};

//--------------------------------------------------------------------------
// Predicate optimization handler
//--------------------------------------------------------------------------

class predicate_optimizer_handler_t {
public:
    // Detect if predicate patterns are present
    static bool detect(mbl_array_t* mba);

    // Run predicate optimization pass
    static int run(mbl_array_t* mba, deobf_ctx_t* ctx);

    // Simplify a single set* instruction
    // Returns 1 if simplified, 0 if not
    static int simplify_set(mblock_t* blk, minsn_t* ins, deobf_ctx_t* ctx);

    // Statistics
    static void dump_statistics();
    static void reset_statistics();

private:
    static size_t predicates_simplified_;
    static size_t predicates_to_true_;
    static size_t predicates_to_false_;
};

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/rules_sub.cpp`:

```cpp
#include "rules_sub.h"

namespace chernobog {
namespace rules {

// Register all subtraction rules
REGISTER_MBA_RULE(Sub_HackersDelightRule_1);
REGISTER_MBA_RULE(Sub_HackersDelightRule_2);
REGISTER_MBA_RULE(Sub_HackersDelightRule_3);
REGISTER_MBA_RULE(Sub_HackersDelightRule_4);
REGISTER_MBA_RULE(Sub1_FactorRule_1);
REGISTER_MBA_RULE(Sub1_FactorRule_2);
REGISTER_MBA_RULE(Sub_NegRule_1);
REGISTER_MBA_RULE(Sub_NegRule_2);
REGISTER_MBA_RULE(Sub_SpecialConstantRule_1);
REGISTER_MBA_RULE(Sub_Rule_1);
REGISTER_MBA_RULE(Sub_Rule_2);
REGISTER_MBA_RULE(Sub_Rule_3);

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/rules_sub.h`:

```h
#pragma once
#include "pattern_rule.h"
#include "rule_registry.h"

//--------------------------------------------------------------------------
// Subtraction Rules - MBA patterns that simplify to subtraction
//
// Mathematical identities:
//   x - y = x + ~y + 1
//   x - y = (x ^ y) - 2*(~x & y)
//   x - y = x + (-y)
//   x - y = ~(~x + y)
//--------------------------------------------------------------------------

namespace chernobog {
namespace rules {

//--------------------------------------------------------------------------
// Hacker's Delight Subtraction Rules
//--------------------------------------------------------------------------

// x + ~y + 1 -> x - y
class Sub_HackersDelightRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Sub_HackersDelightRule_1"; }

    AstPtr get_pattern() const override
    {
        return add(add(x_0(), bnot(x_1())), c_1());
    }

    AstPtr get_replacement() const override
    {
        return sub(x_0(), x_1());
    }
};

// ~(~x + y) -> x - y
class Sub_HackersDelightRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Sub_HackersDelightRule_2"; }

    AstPtr get_pattern() const override
    {
        return bnot(add(bnot(x_0()), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return sub(x_0(), x_1());
    }
};

// (x ^ y) + 2*(x & ~y) -> x - y
class Sub_HackersDelightRule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "Sub_HackersDelightRule_3"; }

    AstPtr get_pattern() const override
    {
        return add(bxor(x_0(), x_1()), mul(c_2(), band(x_0(), bnot(x_1()))));
    }

    AstPtr get_replacement() const override
    {
        return sub(x_0(), x_1());
    }
};

// 2*(x & ~y) + (x ^ y) -> x - y (commutative)
class Sub_HackersDelightRule_4 : public PatternMatchingRule {
public:
    const char* name() const override { return "Sub_HackersDelightRule_4"; }

    AstPtr get_pattern() const override
    {
        return add(mul(c_2(), band(x_0(), bnot(x_1()))), bxor(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return sub(x_0(), x_1());
    }
};

//--------------------------------------------------------------------------
// Subtraction by 1 Rules
//--------------------------------------------------------------------------

// ~(~x + 1) -> x - 1
class Sub1_FactorRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Sub1_FactorRule_1"; }

    AstPtr get_pattern() const override
    {
        return bnot(add(bnot(x_0()), c_1()));
    }

    AstPtr get_replacement() const override
    {
        return sub(x_0(), c_1());
    }
};

// x + ~0 -> x - 1 (since ~0 = -1)
class Sub1_FactorRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Sub1_FactorRule_2"; }

    AstPtr get_pattern() const override
    {
        return add(x_0(), make_named_const("c_minus_1"));
    }

    AstPtr get_replacement() const override
    {
        return sub(x_0(), c_1());
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        auto p = bindings.find("c_minus_1");
        if ( p == bindings.end() ) return false;
        return is_minus_1(p->second);
    }
};

//--------------------------------------------------------------------------
// Negation-based Subtraction Rules
//--------------------------------------------------------------------------

// x + (-y) -> x - y
class Sub_NegRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Sub_NegRule_1"; }

    AstPtr get_pattern() const override
    {
        return add(x_0(), neg(x_1()));
    }

    AstPtr get_replacement() const override
    {
        return sub(x_0(), x_1());
    }
};

// -y + x -> x - y
class Sub_NegRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Sub_NegRule_2"; }

    AstPtr get_pattern() const override
    {
        return add(neg(x_1()), x_0());
    }

    AstPtr get_replacement() const override
    {
        return sub(x_0(), x_1());
    }
};

//--------------------------------------------------------------------------
// Special Constant Subtraction Rules
//--------------------------------------------------------------------------

// (x ^ y) + (-2)*(~x & y) -> x - y
class Sub_SpecialConstantRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Sub_SpecialConstantRule_1"; }

    AstPtr get_pattern() const override
    {
        return add(bxor(x_0(), x_1()), mul(make_named_const("c_minus_2"), band(bnot(x_0()), x_1())));
    }

    AstPtr get_replacement() const override
    {
        return sub(x_0(), x_1());
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        auto p = bindings.find("c_minus_2");
        if ( p == bindings.end() ) return false;
        return is_minus_2(p->second);
    }
};

//--------------------------------------------------------------------------
// Identity Subtraction Rules
//--------------------------------------------------------------------------

// x - 0 -> x
class Sub_Rule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Sub_Rule_1"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return sub(x_0(), c_0());
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        return check_const_value(bindings, "0", 0, 8);
    }
};

// x - x -> 0
class Sub_Rule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Sub_Rule_2"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return sub(x_0(), x_0());
    }

    AstPtr get_replacement() const override
    {
        return c_0();
    }
};

// 0 - x -> -x
class Sub_Rule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "Sub_Rule_3"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return sub(c_0(), x_0());
    }

    AstPtr get_replacement() const override
    {
        return neg(x_0());
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        return check_const_value(bindings, "0", 0, 8);
    }
};

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/rules_xor.cpp`:

```cpp
#include "rules_xor.h"

namespace chernobog {
namespace rules {

// Register all XOR rules
REGISTER_MBA_RULE(Xor_HackersDelightRule_1);
REGISTER_MBA_RULE(Xor_HackersDelightRule_2);
REGISTER_MBA_RULE(Xor_HackersDelightRule_3);
REGISTER_MBA_RULE(Xor_HackersDelightRule_4);
REGISTER_MBA_RULE(Xor_HackersDelightRule_5);
REGISTER_MBA_RULE(Xor_MbaRule_1);
REGISTER_MBA_RULE(Xor_MbaRule_2);
REGISTER_MBA_RULE(Xor_MbaRule_3);
REGISTER_MBA_RULE(Xor_FactorRule_1);
REGISTER_MBA_RULE(Xor_FactorRule_2);
REGISTER_MBA_RULE(Xor_FactorRule_3);
REGISTER_MBA_RULE(Xor_OllvmRule_1);
REGISTER_MBA_RULE(Xor_OllvmRule_2);
REGISTER_MBA_RULE(Xor_OllvmRule_3);
REGISTER_MBA_RULE(Xor_SpecialConstantRule_1);
REGISTER_MBA_RULE(Xor_SpecialConstantRule_2);
REGISTER_MBA_RULE(Xor_Rule_1);
REGISTER_MBA_RULE(Xor_Rule_2);
REGISTER_MBA_RULE(Xor_Rule_3);

} // namespace rules
} // namespace chernobog

```

`src/deobf/rules/rules_xor.h`:

```h
#pragma once
#include "pattern_rule.h"
#include "rule_registry.h"

//--------------------------------------------------------------------------
// XOR Rules - MBA patterns that simplify to XOR
//
// Mathematical identities:
//   x ^ y = (x | y) - (x & y)
//   x ^ y = (x | y) & (~x | ~y)
//   x ^ y = (~x & y) | (x & ~y)
//   x ^ y = (x + y) - 2*(x & y)
//   x ^ y = 2*(x | y) - (x + y)
//--------------------------------------------------------------------------

namespace chernobog {
namespace rules {

//--------------------------------------------------------------------------
// Hacker's Delight XOR Rules
//--------------------------------------------------------------------------

// (x | y) - (x & y) -> x ^ y
class Xor_HackersDelightRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_HackersDelightRule_1"; }

    AstPtr get_pattern() const override
    {
        return sub(bor(x_0(), x_1()), band(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return bxor(x_0(), x_1());
    }
};

// (x | y) & (~x | ~y) -> x ^ y
class Xor_HackersDelightRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_HackersDelightRule_2"; }

    AstPtr get_pattern() const override
    {
        return band(bor(x_0(), x_1()), bor(bnot(x_0()), bnot(x_1())));
    }

    AstPtr get_replacement() const override
    {
        return bxor(x_0(), x_1());
    }
};

// (~x & y) | (x & ~y) -> x ^ y (standard definition)
class Xor_HackersDelightRule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_HackersDelightRule_3"; }

    AstPtr get_pattern() const override
    {
        return bor(band(bnot(x_0()), x_1()), band(x_0(), bnot(x_1())));
    }

    AstPtr get_replacement() const override
    {
        return bxor(x_0(), x_1());
    }
};

// (x + y) - 2*(x & y) -> x ^ y
class Xor_HackersDelightRule_4 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_HackersDelightRule_4"; }

    AstPtr get_pattern() const override
    {
        return sub(add(x_0(), x_1()), mul(c_2(), band(x_0(), x_1())));
    }

    AstPtr get_replacement() const override
    {
        return bxor(x_0(), x_1());
    }
};

// 2*(x | y) - (x + y) -> x ^ y
class Xor_HackersDelightRule_5 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_HackersDelightRule_5"; }

    AstPtr get_pattern() const override
    {
        return sub(mul(c_2(), bor(x_0(), x_1())), add(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return bxor(x_0(), x_1());
    }
};

//--------------------------------------------------------------------------
// MBA XOR Rules
//--------------------------------------------------------------------------

// (x | y) & ~(x & y) -> x ^ y
class Xor_MbaRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_MbaRule_1"; }

    AstPtr get_pattern() const override
    {
        return band(bor(x_0(), x_1()), bnot(band(x_0(), x_1())));
    }

    AstPtr get_replacement() const override
    {
        return bxor(x_0(), x_1());
    }
};

// ~(x & y) & (x | y) -> x ^ y (commutative variant)
class Xor_MbaRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_MbaRule_2"; }

    AstPtr get_pattern() const override
    {
        return band(bnot(band(x_0(), x_1())), bor(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return bxor(x_0(), x_1());
    }
};

// ~(~x | ~y) | ~(x | y) -> x ^ y (De Morgan variant)
class Xor_MbaRule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_MbaRule_3"; }

    AstPtr get_pattern() const override
    {
        return bor(bnot(bor(bnot(x_0()), bnot(x_1()))), bnot(bor(x_0(), x_1())));
    }

    AstPtr get_replacement() const override
    {
        return bxor(x_0(), x_1());
    }
};

//--------------------------------------------------------------------------
// Factor XOR Rules
//--------------------------------------------------------------------------

// (x & ~y) | (~x & y) -> x ^ y (variant ordering)
class Xor_FactorRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_FactorRule_1"; }

    AstPtr get_pattern() const override
    {
        return bor(band(x_0(), bnot(x_1())), band(bnot(x_0()), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return bxor(x_0(), x_1());
    }
};

// ~(x | y) | (x & y) -> ~(x ^ y)
class Xor_FactorRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_FactorRule_2"; }

    AstPtr get_pattern() const override
    {
        return bor(bnot(bor(x_0(), x_1())), band(x_0(), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return bnot(bxor(x_0(), x_1()));
    }
};

// (x & y) | ~(x | y) -> ~(x ^ y) (commutative)
class Xor_FactorRule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_FactorRule_3"; }

    AstPtr get_pattern() const override
    {
        return bor(band(x_0(), x_1()), bnot(bor(x_0(), x_1())));
    }

    AstPtr get_replacement() const override
    {
        return bnot(bxor(x_0(), x_1()));
    }
};

//--------------------------------------------------------------------------
// OLLVM XOR Rules
//--------------------------------------------------------------------------

// (~x | y) & (x | ~y) -> ~(x ^ y)
class Xor_OllvmRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_OllvmRule_1"; }

    AstPtr get_pattern() const override
    {
        return band(bor(bnot(x_0()), x_1()), bor(x_0(), bnot(x_1())));
    }

    AstPtr get_replacement() const override
    {
        return bnot(bxor(x_0(), x_1()));
    }
};

// (x | ~y) & (~x | y) -> ~(x ^ y) (commutative)
class Xor_OllvmRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_OllvmRule_2"; }

    AstPtr get_pattern() const override
    {
        return band(bor(x_0(), bnot(x_1())), bor(bnot(x_0()), x_1()));
    }

    AstPtr get_replacement() const override
    {
        return bnot(bxor(x_0(), x_1()));
    }
};

// ~(~x & ~y) & ~(x & y) -> x ^ y
class Xor_OllvmRule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_OllvmRule_3"; }

    AstPtr get_pattern() const override
    {
        return band(bnot(band(bnot(x_0()), bnot(x_1()))), bnot(band(x_0(), x_1())));
    }

    AstPtr get_replacement() const override
    {
        return bxor(x_0(), x_1());
    }
};

//--------------------------------------------------------------------------
// Special constant XOR Rules
//--------------------------------------------------------------------------

// (x + y) + (-2)*(x & y) -> x ^ y
class Xor_SpecialConstantRule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_SpecialConstantRule_1"; }

    AstPtr get_pattern() const override
    {
        return add(add(x_0(), x_1()), mul(make_named_const("c_minus_2"), band(x_0(), x_1())));
    }

    AstPtr get_replacement() const override
    {
        return bxor(x_0(), x_1());
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        auto p = bindings.find("c_minus_2");
        if ( p == bindings.end() ) return false;
        return is_minus_2(p->second);
    }
};

// (x | y) + (-1)*(x & y) -> x ^ y
class Xor_SpecialConstantRule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_SpecialConstantRule_2"; }

    AstPtr get_pattern() const override
    {
        return add(bor(x_0(), x_1()), mul(make_named_const("c_minus_1"), band(x_0(), x_1())));
    }

    AstPtr get_replacement() const override
    {
        return bxor(x_0(), x_1());
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        auto p = bindings.find("c_minus_1");
        if ( p == bindings.end() ) return false;
        return is_minus_1(p->second);
    }
};

//--------------------------------------------------------------------------
// Additional XOR rules
//--------------------------------------------------------------------------

// ~x ^ ~y -> x ^ y (double negation in XOR)
class Xor_Rule_1 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_Rule_1"; }

    AstPtr get_pattern() const override
    {
        return bxor(bnot(x_0()), bnot(x_1()));
    }

    AstPtr get_replacement() const override
    {
        return bxor(x_0(), x_1());
    }
};

// x ^ 0 -> x
class Xor_Rule_2 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_Rule_2"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return bxor(x_0(), c_0());
    }

    AstPtr get_replacement() const override
    {
        return x_0();
    }

    bool check_constants(const std::map<std::string, mop_t>& bindings) override
    {
        return check_const_value(bindings, "0", 0, 8);
    }
};

// x ^ x -> 0
class Xor_Rule_3 : public PatternMatchingRule {
public:
    const char* name() const override { return "Xor_Rule_3"; }

    bool fuzz_pattern() const override
    {
        return false;
    }

    AstPtr get_pattern() const override
    {
        return bxor(x_0(), x_0());
    }

    AstPtr get_replacement() const override
    {
        return c_0();
    }
};

} // namespace rules
} // namespace chernobog

```

`src/plugin/component_registry.cpp`:

```cpp
#include "component_registry.h"
#include "../common/warn_off.h"
#include <vector>
#include "../common/warn_on.h"

struct stored_component_t {
    component_desc_t d;
    bool initialized = false;
};

static std::vector<stored_component_t> &repo()
{
    static std::vector<stored_component_t> v;
    return v;
}

void component_registry_t::register_component(const component_desc_t &d)
{
    stored_component_t sc;
    sc.d = d;
    sc.initialized = false;
    repo().push_back(sc);
}

size_t component_registry_t::get_count()
{
    return repo().size();
}

int component_registry_t::init_all()
{
    int inited = 0;
    for ( stored_component_t &sc: repo() )
    {
        if ( sc.d.avail && sc.d.avail() )
        {
            if ( sc.d.init )
                sc.d.init();
            sc.initialized = true;
            ++inited;
        }
    }
    return inited;
}

int component_registry_t::done_all()
{
    int donec = 0;
    for ( stored_component_t &sc: repo() )
    {
        if ( sc.initialized && sc.d.done )
        {
            sc.d.done();
            sc.initialized = false;
            ++donec;
        }
    }
    return donec;
}

void component_registry_t::attach_to_popup(TWidget *widget, TPopupMenu *popup, vdui_t *vu)
{
    for ( stored_component_t &sc: repo() )
    {
        if ( sc.initialized && sc.d.attach_popup )
        {
            sc.d.attach_popup(widget, popup, vu);
        }
    }
}

void component_registry_t::unregister_all_actions()
{
    // Components manage their own action registration/unregistration in init/done
}

```

`src/plugin/component_registry.h`:

```h
#pragma once
#include "../common/warn_off.h"
#include <hexrays.hpp>
#include "../common/warn_on.h"

// Component registry for modular deobfuscator architecture
// Each deobfuscation pass registers as a component

struct component_desc_t {
    bool (*avail)();
    bool (*active)();
    void (*init)();
    void (*done)();
    void (*attach_popup)(TWidget *widget, TPopupMenu *popup, vdui_t *vu);
    const char *long_name;
    const char *short_name;
    const char *action_prefix;
};

class component_registry_t {
public:
    static void register_component(const component_desc_t &d);
    static size_t get_count();
    static int init_all();
    static int done_all();
    static void attach_to_popup(TWidget *widget, TPopupMenu *popup, vdui_t *vu);
    static void unregister_all_actions();
};

// Registration helper macro
#define REGISTER_COMPONENT(AVAIL, ACTIVE, INIT, DONE, ATTACH, LNAME, SNAME, APREFIX) \
namespace {                                                                        \
 struct component_registrar_t_##SNAME {                                           \
   component_registrar_t_##SNAME() {                                              \
     component_desc_t d;                                                          \
     d.avail = AVAIL; d.active = ACTIVE; d.init = INIT; d.done = DONE;            \
     d.attach_popup = ATTACH;                                                     \
     d.long_name = LNAME; d.short_name = #SNAME; d.action_prefix = #APREFIX;      \
     component_registry_t::register_component(d);                                 \
   }                                                                              \
 };                                                                               \
 static component_registrar_t_##SNAME g_component_registrar_##SNAME;              \
}

```

`src/plugin/deobf_plugin.cpp`:

```cpp
#include "../common/warn_off.h"
#include <hexrays.hpp>
#include "../common/warn_on.h"

#include "component_registry.h"

// Include component headers to trigger registration
#include "../deobf/deobf_main.h"
#include "../deobf/handlers/ctree_const_fold.h"
#include "../deobf/handlers/ctree_switch_fold.h"
#include "../deobf/handlers/ctree_indirect_call.h"
#include "../deobf/handlers/ctree_string_decrypt.h"

#include <set>
#include <cstdio>

// Debug file logging for batch mode where msg() might not be visible
// Using raw syscalls to bypass IDA's file wrappers
#include "../common/compat.h"

static void debug_log(const char *fmt, ...)
{
#ifndef _WIN32
    char buf[4096];
    va_list args;
    va_start(args, fmt);
    int len = qvsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);

    int fd = open("/tmp/chernobog_debug.log", O_WRONLY | O_CREAT | O_APPEND, 0644);
    if ( fd >= 0 )
    {
        write(fd, buf, len);
        close(fd);
    }
#else
    (void)fmt; // Debug logging disabled on Windows
#endif
}

#ifndef _WIN32
// Global constructor to trace when dylib is loaded (Unix only)
__attribute__((constructor))
static void dylib_loaded()
{
    // Write directly to a marker file to prove we loaded
    int fd = open("/tmp/CHERNOBOG_LOADED", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if ( fd >= 0 )
    {
        const char *msg = "DYLIB LOADED\n";
        write(fd, msg, 13);
        close(fd);
    }
    debug_log("[chernobog] DYLIB LOADED (constructor called)\n");
}
#endif

// Track which functions we've already auto-deobfuscated to avoid infinite loops
static std::set<ea_t> s_auto_deobfuscated;

// Track which functions we've already run ctree_const_fold on to avoid re-entry
static std::set<ea_t> s_ctree_const_folded;

// Track which functions we've already run ctree_switch_fold on to avoid re-entry
static std::set<ea_t> s_ctree_switch_folded;

// Track which functions we've already run ctree_indirect_call on
static std::set<ea_t> s_ctree_indirect_call_processed;

// Track which functions we've already run ctree_string_decrypt on
static std::set<ea_t> s_ctree_string_decrypt_processed;

//--------------------------------------------------------------------------
// Check if auto mode is enabled
// Supports: CHERNOBOG_AUTO=1 env var, or ~/.chernobog_auto file
//--------------------------------------------------------------------------
static bool is_auto_mode_enabled()
{
    static int cached = -1;
    if ( cached == -1 )
    {
        cached = 0;
        // Try qgetenv first
        qstring env_val;
        if ( qgetenv("CHERNOBOG_AUTO", &env_val) && !env_val.empty() && env_val[0] == '1' )
        {
            cached = 1;
            debug_log("[chernobog] AUTO mode detected via env var\n");
        }
        // Also check for ~/.chernobog_auto file as fallback
        if ( cached == 0 )
        {
            qstring home;
            if ( qgetenv("HOME", &home) )
            {
                qstring auto_file = home + "/.chernobog_auto";
                FILE *f = qfopen(auto_file.c_str(), "r");
                if ( f )
                {
                    qfclose(f);
                    cached = 1;
                }
            }
        }
    }
    return cached == 1;
}

//--------------------------------------------------------------------------
// Check if cache reset is enabled via environment variable
//--------------------------------------------------------------------------
static bool is_reset_mode_enabled()
{
    qstring env;
    if ( qgetenv("CHERNOBOG_RESET", &env) && !env.empty() && env[0] != '0' )
        return true;
    return false;
}

//--------------------------------------------------------------------------
// Check if verbose mode is enabled
//--------------------------------------------------------------------------
static void check_verbose_mode()
{
    static bool checked = false;
    if ( !checked )
    {
        checked = true;
        qstring env_val;
        if ( qgetenv("CHERNOBOG_VERBOSE", &env_val) && env_val == "1" )
        {
            deobf::set_verbose(true);
            msg("[chernobog] Verbose mode enabled (CHERNOBOG_VERBOSE=1)\n");
        }
    }
}

//--------------------------------------------------------------------------
// Hexrays Callback - Add popup menu items and auto-deobfuscate
//--------------------------------------------------------------------------
static ssize_t idaapi hexrays_callback(void *, hexrays_event_t event, va_list va)
{
    // Debug: log all events
    debug_log("[chernobog] hexrays_callback event=%d\n", (int)event);

    static bool first_call = true;
    if ( first_call )
    {
        first_call = false;
        debug_log("[chernobog] First hexrays callback, auto_mode=%d\n", is_auto_mode_enabled() ? 1 : 0);
        msg("[chernobog] Hexrays callback registered and active\n");
    }

    if ( event == hxe_populating_popup )
    {
        TWidget *widget = va_arg(va, TWidget *);
        TPopupMenu *popup = va_arg(va, TPopupMenu *);
        vdui_t *vu = va_arg(va, vdui_t *);

        // Add separator if we have any components
        if ( component_registry_t::get_count() > 0 )
            attach_action_to_popup(widget, popup, nullptr);

        // Attach all component actions
        component_registry_t::attach_to_popup(widget, popup, vu);
    }
    // Clear tracking when view is refreshed (e.g., after inlining)
    // This allows re-deobfuscation when user makes changes
    else if ( event == hxe_refresh_pseudocode )
    {
        vdui_t *vu = va_arg(va, vdui_t *);
        if ( vu && vu->cfunc )
        {
            ea_t func_ea = vu->cfunc->entry_ea;
            s_auto_deobfuscated.erase(func_ea);
            s_ctree_const_folded.erase(func_ea);
            s_ctree_switch_folded.erase(func_ea);
            s_ctree_string_decrypt_processed.erase(func_ea);
            chernobog_clear_function_tracking(func_ea);
        }
    }
    // Auto-deobfuscate at microcode stage for analysis
    else if ( event == hxe_microcode )
    {
        mbl_array_t *mba = va_arg(va, mbl_array_t *);
        debug_log("[chernobog] hxe_microcode: mba=%p, auto=%d\n", mba, is_auto_mode_enabled() ? 1 : 0);
        if ( mba && is_auto_mode_enabled() )
        {
            ea_t func_ea = mba->entry_ea;
            bool already_done = s_auto_deobfuscated.find(func_ea) != s_auto_deobfuscated.end();
            debug_log("[chernobog] func_ea=0x%llx, already_done=%d\n", (unsigned long long)func_ea, already_done ? 1 : 0);
            if ( !already_done )
            {
                s_auto_deobfuscated.insert(func_ea);
                debug_log("[chernobog] Calling deobfuscate_mba...\n");
                chernobog_t::deobfuscate_mba(mba);
                debug_log("[chernobog] deobfuscate_mba returned\n");
            }
        }
    }
    // Apply ctree-level optimizations after decompilation
    else if ( event == hxe_maturity )
    {
        cfunc_t *cfunc = va_arg(va, cfunc_t *);
        ctree_maturity_t maturity = va_argi(va, ctree_maturity_t);
        // Run at CMAT_FINAL when the ctree is complete
        // Track by function to avoid infinite recursion if ctree modification triggers reprocessing
        if ( cfunc && maturity == CMAT_FINAL && is_auto_mode_enabled() )
        {
            ea_t func_ea = cfunc->entry_ea;
            // Constant folding for XOR patterns
            if ( s_ctree_const_folded.find(func_ea) == s_ctree_const_folded.end() )
            {
                s_ctree_const_folded.insert(func_ea);
                ctree_const_fold_handler_t::run(cfunc);
            }
            // Switch folding for opaque predicates
            if ( s_ctree_switch_folded.find(func_ea) == s_ctree_switch_folded.end() )
            {
                s_ctree_switch_folded.insert(func_ea);
                ctree_switch_fold_handler_t::run(cfunc);
            }
            // Indirect call resolution (Hikari IndirectCall)
            if ( s_ctree_indirect_call_processed.find(func_ea) == s_ctree_indirect_call_processed.end() )
            {
                s_ctree_indirect_call_processed.insert(func_ea);
                if ( ctree_indirect_call_handler_t::detect(cfunc) )
                {
                    ctree_indirect_call_handler_t::run(cfunc, nullptr);
                }
            }
            // String decryption (strcpy reveals, char-by-char, AES keys)
            if ( s_ctree_string_decrypt_processed.find(func_ea) == s_ctree_string_decrypt_processed.end() )
            {
                s_ctree_string_decrypt_processed.insert(func_ea);
                if ( ctree_string_decrypt_handler_t::detect(cfunc) )
                {
                    deobf_ctx_t str_ctx;
                    str_ctx.cfunc = cfunc;
                    str_ctx.func_ea = func_ea;
                    int changes = ctree_string_decrypt_handler_t::run(cfunc, &str_ctx);
                    if ( changes > 0 )
                    {
                        msg("[chernobog] Ctree string decryption: found %d strings\n", changes);
                    }
                }
            }
        }
    }
    return 0;
}

//--------------------------------------------------------------------------
// Deferred initialization - called when hexrays becomes available
//--------------------------------------------------------------------------
static bool s_hexrays_initialized = false;

static bool try_init_hexrays()
{
    debug_log("[chernobog] try_init_hexrays called, already_init=%d\n", s_hexrays_initialized ? 1 : 0);

    if ( s_hexrays_initialized )
        return true;

    if ( !init_hexrays_plugin() )
    {
        debug_log("[chernobog] init_hexrays_plugin() failed\n");
        return false;
    }

    debug_log("[chernobog] init_hexrays_plugin() succeeded\n");
    s_hexrays_initialized = true;

    // Clear decompiler cache if CHERNOBOG_RESET is set
    // This forces full redecompilation of all functions
    if ( is_reset_mode_enabled() )
    {
        s_auto_deobfuscated.clear();
        s_ctree_const_folded.clear();
        s_ctree_switch_folded.clear();
        chernobog_clear_all_tracking();
        clear_cached_cfuncs();
        msg("[chernobog] Cleared Hex-Rays decompiler cache (CHERNOBOG_RESET=1)\n");
    }

    // Check verbose mode before any output
    check_verbose_mode();

    // Check auto mode early and print debug info
    bool auto_mode = is_auto_mode_enabled();

    debug_log("[chernobog] Components registered: %d, auto=%d\n",
        (int)component_registry_t::get_count(), auto_mode ? 1 : 0);
    msg("[chernobog] Chernobog (Hikari Deobfuscator) initializing (%d components registered, auto=%d)\n",
        (int)component_registry_t::get_count(), auto_mode ? 1 : 0);

    // Install hexrays callback for popup menus and auto-deobfuscation
    debug_log("[chernobog] Installing hexrays callback...\n");
    install_hexrays_callback(hexrays_callback, nullptr);
    debug_log("[chernobog] Hexrays callback installed\n");

    debug_log("[chernobog] Calling init_all()...\n");
    int initialized = component_registry_t::init_all();
    debug_log("[chernobog] init_all() returned %d components initialized\n", initialized);
    msg("[chernobog] Plugin ready (%d components initialized)\n", initialized);

    // Check auto mode at startup
    if ( auto_mode )
    {
        msg("[chernobog] *** AUTO MODE ACTIVE - will deobfuscate on decompilation ***\n");
    }

    msg("[chernobog] Use Ctrl+Shift+D to deobfuscate current function\n");
    msg("[chernobog] Use Ctrl+Shift+A to analyze obfuscation types\n");

    return true;
}

//--------------------------------------------------------------------------
// IDB event handler - to catch when hexrays becomes available
//--------------------------------------------------------------------------
static ssize_t idaapi idb_callback(void *, int event_id, va_list)
{
    (void)event_id;  // unused
    // Try to init hexrays on various events
    if ( !s_hexrays_initialized )
    {
        try_init_hexrays();
    }
    return 0;
}

//--------------------------------------------------------------------------
// Plugin Initialization
//--------------------------------------------------------------------------
static plugmod_t * idaapi init(void)
{
    debug_log("[chernobog] Plugin init() called\n");

    // Try immediate init (works if hexrays loaded first)
    if ( try_init_hexrays() )
    {
        debug_log("[chernobog] init() returning PLUGIN_KEEP (hexrays ready)\n");
        return PLUGIN_KEEP;
    }

    // Hexrays not ready yet - hook IDB events to init later
    debug_log("[chernobog] Hexrays not ready, hooking IDB events\n");
    msg("[chernobog] Waiting for Hex-Rays decompiler...\n");
    hook_to_notification_point(HT_IDB, idb_callback, nullptr);

    return PLUGIN_KEEP;
}

static void idaapi term(void)
{
    // Remove callbacks
    unhook_from_notification_point(HT_IDB, idb_callback, nullptr);

    if ( s_hexrays_initialized )
    {
        remove_hexrays_callback(hexrays_callback, nullptr);

        // Unregister all component actions
        component_registry_t::unregister_all_actions();

        int terminated = component_registry_t::done_all();
        msg("[chernobog] Plugin terminated (%d components)\n", terminated);
    }
}

static bool idaapi run(size_t)
{
    // Plugin can be invoked manually - show info
    msg("\n=== Chernobog - Hikari Deobfuscator ===\n");
    msg("This plugin deobfuscates code protected with Hikari LLVM obfuscator.\n\n");
    msg("Supported obfuscations:\n");
    msg("  - Control Flow Flattening (CFF)\n");
    msg("  - Bogus Control Flow (BCF)\n");
    msg("  - String Encryption\n");
    msg("  - Constant Encryption\n");
    msg("  - Instruction Substitution\n");
    msg("  - Indirect Branches\n");
    msg("  - Basic Block Splitting\n");
    msg("  - Identity Function Calls\n");
    msg("  - Stack String Construction\n");
    msg("  - Hikari Function Wrappers\n");
    msg("  - Register Demotion (savedregs)\n");
    msg("  - Obfuscated ObjC Method Calls\n\n");
    msg("Usage:\n");
    msg("  1. Open a function in the decompiler\n");
    msg("  2. Right-click and select 'Deobfuscate (Chernobog)'\n");
    msg("  3. Or press Ctrl+Shift+D\n\n");
    msg("To analyze without modifying:\n");
    msg("  Right-click and select 'Analyze obfuscation (Chernobog)'\n");
    msg("  Or press Ctrl+Shift+A\n\n");
    msg("Auto-deobfuscation mode:\n");
    msg("  Set CHERNOBOG_AUTO=1 environment variable before starting IDA\n");
    msg("  to automatically deobfuscate functions when they are decompiled.\n\n");

    return true;
}

//--------------------------------------------------------------------------
// Plugin Descriptor
//--------------------------------------------------------------------------
plugin_t PLUGIN =
{
    IDP_INTERFACE_VERSION,
    PLUGIN_FIX,                         // plugin flags
    init,                               // initialize
    term,                               // terminate
    run,                                // invoke plugin
    "Chernobog - Hikari LLVM Deobfuscator", // long comment
    "Deobfuscates Hikari-protected binaries for Hex-Rays", // help text
    "Chernobog",                        // preferred short name
    "Ctrl+Shift+H"                     // preferred hotkey
};

```

`test.c`:

```c
/*
 * Hikari Obfuscation Test Program
 * ================================
 * Faithfully replicates all Hikari/OLLVM obfuscation techniques:
 * 1. Control Flow Flattening (CFF) - nested state machines
 * 2. String Encryption - XOR, stack strings, global array manipulation
 * 3. Function Call Obfuscation - wrapper indirection
 * 4. Indirect Branching - computed jumps via function pointers
 * 5. Instruction Substitution - complex equivalent operations
 * 6. Bogus Control Flow - opaque predicates
 * 7. Mixed Boolean Arithmetic (MBA)
 * 
 * Compile: gcc -O0 -fno-inline -o hikari_test hikari_test_obfuscated.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>

// ============================================================================
// GLOBAL ENCRYPTED DATA ARRAYS (String Encryption via Global XOR Arrays)
// ============================================================================

// Encrypted: "/etc/passwd" ^ 0x37
static unsigned char byte_100014110[] = {0x18, 0x52, 0x43, 0x54, 0x18, 0x47, 0x56, 0x44, 0x44, 0x40, 0x53, 0x00};
static unsigned char byte_100014170[32] = {0};

// Encrypted: "Configuration loaded successfully" ^ 0x4C
static unsigned char byte_100014200[] = {
    0x0F, 0x23, 0x22, 0x2A, 0x25, 0x2B, 0x39, 0x3E, 0x2D, 0x38, 0x25, 0x23, 0x22, 0x6C,
    0x20, 0x23, 0x2D, 0x28, 0x29, 0x28, 0x6C, 0x3F, 0x39, 0x2F, 0x2F, 0x29, 0x3F, 0x3F,
    0x2A, 0x39, 0x20, 0x20, 0x35, 0x00
};
static unsigned char byte_100014280[64] = {0};

// Encrypted: "sudo rm -rf /tmp/cache/*" ^ 0x5A
static unsigned char byte_100014300[] = {
    0x29, 0x2F, 0x3E, 0x35, 0x7A, 0x28, 0x37, 0x7A, 0x77, 0x28, 0x3C, 0x7A,
    0x75, 0x2E, 0x37, 0x2A, 0x75, 0x39, 0x3B, 0x39, 0x32, 0x3F, 0x75, 0x70, 0x00
};
static unsigned char byte_100014380[64] = {0};

// Encrypted: "https://api.example.com/check" ^ 0x1F
static unsigned char byte_100014400[] = {
    0x77, 0x6B, 0x6B, 0x6F, 0x6C, 0x25, 0x30, 0x30, 0x7E, 0x6F, 0x76, 0x31,
    0x7A, 0x67, 0x7E, 0x72, 0x6F, 0x73, 0x7A, 0x31, 0x7C, 0x70, 0x72, 0x30,
    0x7C, 0x77, 0x7A, 0x7C, 0x74, 0x00
};
static unsigned char byte_100014480[64] = {0};

// Encrypted: "AUTH_TOKEN=%s&USER=%s" ^ 0x23
static unsigned char byte_100014500[] = {
    0x62, 0x76, 0x77, 0x6B, 0x7C, 0x77, 0x6C, 0x68, 0x66, 0x6D, 0x1E, 0x06,
    0x50, 0x05, 0x76, 0x70, 0x66, 0x71, 0x1E, 0x06, 0x50, 0x00
};
static unsigned char byte_100014580[64] = {0};

// ============================================================================
// STATE CONSTANTS FOR CONTROL FLOW FLATTENING
// ============================================================================

// Main dispatcher states
#define STATE_INIT              0xDEAD0001
#define STATE_CHECK_ENV         0xDEAD0002
#define STATE_VALIDATE_ARGS     0xDEAD0003
#define STATE_LOAD_CONFIG       0xDEAD0004
#define STATE_DECRYPT_STRINGS   0xDEAD0005
#define STATE_CHECK_NETWORK     0xDEAD0006
#define STATE_PROCESS_DATA      0xDEAD0007
#define STATE_CLEANUP           0xDEAD0008
#define STATE_EXIT_SUCCESS      0xDEAD0009
#define STATE_EXIT_FAILURE      0xDEAD000A
#define STATE_ERROR_HANDLER     0xDEAD000B
#define STATE_NESTED_DISPATCH   0xDEAD000C

// Sub-dispatcher states (nested CFF)
#define SUBSTATE_PARSE_INPUT    0xBEEF0001
#define SUBSTATE_VALIDATE       0xBEEF0002
#define SUBSTATE_TRANSFORM      0xBEEF0003
#define SUBSTATE_ENCODE         0xBEEF0004
#define SUBSTATE_OUTPUT         0xBEEF0005
#define SUBSTATE_RETURN         0xBEEF0006

// Config loader states
#define CFG_STATE_OPEN          0xCAFE0001
#define CFG_STATE_READ          0xCAFE0002
#define CFG_STATE_PARSE         0xCAFE0003
#define CFG_STATE_VALIDATE      0xCAFE0004
#define CFG_STATE_APPLY         0xCAFE0005
#define CFG_STATE_CLOSE         0xCAFE0006
#define CFG_STATE_ERROR         0xCAFE0007
#define CFG_STATE_DONE          0xCAFE0008

// Dead/unreachable states (bogus control flow)
#define STATE_DEAD_1            0x00000000
#define STATE_DEAD_2            0xFFFFFFFF
#define STATE_DEAD_3            0x12345678

// ============================================================================
// OPAQUE PREDICATES (Always true/false but hard to analyze statically)
// ============================================================================

volatile int g_opaque_var1 = 0x12345678;
volatile int g_opaque_var2 = 0x87654321;

// (x * (x + 1)) is always even - opaque predicate returning 1
#define OPAQUE_TRUE_1(x) (((x) * ((x) + 1)) % 2 == 0)

// (x^2 + x) % 2 == 0 - always true
#define OPAQUE_TRUE_2(x) ((((x) * (x)) + (x)) % 2 == 0)

// (x | 1) > 0 for any x - always true for non-negative
#define OPAQUE_TRUE_3(x) (((x) | 1) > 0)

// 7 * y^2 - 1 != z^2 for any integers (number theory) - always true
#define OPAQUE_TRUE_4(y, z) ((7 * (y) * (y) - 1) != ((z) * (z)))

// (x & 1) == 0 && (x & 1) == 1 - always false
#define OPAQUE_FALSE_1(x) (((x) & 1) == 0 && ((x) & 1) == 1)

// x < x - always false
#define OPAQUE_FALSE_2(x) ((x) < (x))

// ============================================================================
// MIXED BOOLEAN ARITHMETIC (MBA) - Obfuscated arithmetic
// ============================================================================

// Obfuscated: a + b
static inline int mba_add(int a, int b) {
    return (a ^ b) + 2 * (a & b);
}

// Obfuscated: a - b
static inline int mba_sub(int a, int b) {
    return (a ^ b) - 2 * (~a & b);
}

// Obfuscated: a * 2
static inline int mba_mul2(int a) {
    return (a << 1) ^ (a & 0) | (a + a);
}

// Obfuscated: a == b comparison
static inline int mba_eq(int a, int b) {
    int t = a ^ b;
    return ((t | (~t + 1)) >> 31) + 1;
}

// Obfuscated constant: returns 0 in a convoluted way
static inline int mba_zero(int x) {
    return (x ^ x) & ((x | ~x) ^ (x | ~x));
}

// Obfuscated constant: returns 1
static inline int mba_one(int x) {
    return ((x | ~x) >> 31) & 1 | (((unsigned)(~x + 1) | (unsigned)x) >> 31) ^ 1;
}

// ============================================================================
// FUNCTION WRAPPERS (Function Call Obfuscation)
// ============================================================================

typedef void (*wrapper_func_t)(void);
typedef int (*wrapper_func_int_t)(void);
typedef void (*wrapper_func_str_t)(const char*);
typedef int (*wrapper_func_check_t)(const char*, int);

// Wrapper table for indirect calls
static void* g_wrapper_table[32];
static int g_wrapper_initialized = 0;

void _HikariFunctionWrapper_001(const char* str) {
    // Wraps: printf for logging
    volatile int check = 1;
    if (OPAQUE_TRUE_1(g_opaque_var1)) {
        check = mba_add(check, mba_zero(42));
    }
    if (check) {
        printf("[LOG] %s\n", str);
    }
}

void _HikariFunctionWrapper_002(const char* str) {
    // Wraps: fprintf(stderr, ...)
    volatile int check = 1;
    if (OPAQUE_TRUE_2(g_opaque_var2)) {
        fprintf(stderr, "[ERR] %s\n", str);
    }
    if (OPAQUE_FALSE_1(g_opaque_var1)) {
        abort(); // Never reached
    }
}

int _HikariFunctionWrapper_003(void) {
    // Wraps: getuid()
    int result;
    volatile int junk = g_opaque_var1 ^ g_opaque_var2;
    junk = mba_add(junk, 0);
    result = getuid();
    junk = mba_sub(junk, junk);
    return result + junk;
}

int _HikariFunctionWrapper_004(const char* path) {
    // Wraps: access(path, F_OK)
    struct stat st;
    volatile int x = 0;
    if (OPAQUE_TRUE_3(g_opaque_var1)) {
        x = stat(path, &st);
    }
    return (x == 0) ? 1 : 0;
}

void _HikariFunctionWrapper_005(const char* cmd) {
    // Wraps: system()
    volatile int safety = 1;
    if (OPAQUE_TRUE_4(g_opaque_var1, g_opaque_var2)) {
        if (safety) {
            printf("[SYSCALL] Would execute: %s\n", cmd);
            // system(cmd); // Commented for safety in test
        }
    }
}

int _HikariFunctionWrapper_006(const char* s1, const char* s2) {
    // Wraps: strcmp with obfuscation
    int i = 0;
    int result = 0;
    volatile int junk = mba_zero(g_opaque_var1);
    
    while (s1[i] != '\0' || s2[i] != '\0') {
        int diff = mba_sub((int)s1[i], (int)s2[i]);
        if (diff != 0) {
            result = diff;
            break;
        }
        i = mba_add(i, 1);
    }
    return result + junk;
}

void _HikariFunctionWrapper_007(void* dst, const void* src, size_t n) {
    // Wraps: memcpy with byte-by-byte obfuscation
    unsigned char* d = (unsigned char*)dst;
    const unsigned char* s = (const unsigned char*)src;
    size_t i;
    
    for (i = 0; i < n; i++) {
        volatile int junk = mba_zero(i);
        d[i] = s[i] ^ (unsigned char)junk;
    }
}

size_t _HikariFunctionWrapper_008(const char* str) {
    // Wraps: strlen
    size_t len = 0;
    volatile int x = mba_one(g_opaque_var1);
    
    while (str[len] != '\0') {
        len = mba_add(len, x);
    }
    return len;
}

// Initialize wrapper table with function pointers
void _HikariFunctionWrapper_InitTable(void) {
    if (g_wrapper_initialized) return;
    
    volatile int idx = 0;
    g_wrapper_table[mba_add(idx, 0)] = (void*)_HikariFunctionWrapper_001;
    g_wrapper_table[mba_add(idx, 1)] = (void*)_HikariFunctionWrapper_002;
    g_wrapper_table[mba_add(idx, 2)] = (void*)_HikariFunctionWrapper_003;
    g_wrapper_table[mba_add(idx, 3)] = (void*)_HikariFunctionWrapper_004;
    g_wrapper_table[mba_add(idx, 4)] = (void*)_HikariFunctionWrapper_005;
    g_wrapper_table[mba_add(idx, 5)] = (void*)_HikariFunctionWrapper_006;
    g_wrapper_table[mba_add(idx, 6)] = (void*)_HikariFunctionWrapper_007;
    g_wrapper_table[mba_add(idx, 7)] = (void*)_HikariFunctionWrapper_008;
    
    g_wrapper_initialized = mba_one(42);
}

// Indirect call dispatcher - simulates JUMPOUT behavior
void* _HikariFunctionWrapper_GetPtr(int index) {
    volatile int safe_idx = index & 0x1F; // Mask to table size
    volatile int check = OPAQUE_TRUE_1(safe_idx);
    
    if (check) {
        return g_wrapper_table[safe_idx];
    }
    return NULL; // Never reached
}

// ============================================================================
// STRING DECRYPTION ROUTINES
// ============================================================================

void _decrypt_global_array(unsigned char* dst, unsigned char* src, size_t len, unsigned char key) {
    // CFF within decryption
    uint32_t state = 0xABCD0001;
    size_t i = 0;
    volatile int junk = 0;
    
    while (1) {
        switch (state) {
            case 0xABCD0001: // Init
                i = 0;
                junk = mba_zero(key);
                state = 0xABCD0002;
                break;
                
            case 0xABCD0002: // Loop check
                if (i < len) {
                    state = 0xABCD0003;
                } else {
                    state = 0xABCD0004;
                }
                break;
                
            case 0xABCD0003: // Decrypt byte
                dst[i] = src[i] ^ key;
                dst[i] = dst[i] ^ (unsigned char)junk; // junk is 0
                i = mba_add(i, 1);
                state = 0xABCD0002;
                break;
                
            case 0xABCD0004: // Terminate
                dst[len] = '\0';
                return;
                
            default: // Dead code
                if (OPAQUE_FALSE_1(g_opaque_var1)) {
                    abort();
                }
                state = 0xABCD0001;
                break;
        }
    }
}

// Stack string builder - constructs strings byte by byte
void _build_stack_string_1(char* buf) {
    // Builds: "Initializing..."
    volatile int offset = 0;
    
    buf[mba_add(offset, 0)] = 'I';
    buf[mba_add(offset, 1)] = 'n';
    buf[mba_add(offset, 2)] = 'i';
    buf[mba_add(offset, 3)] = 't';
    buf[mba_add(offset, 4)] = 'i';
    buf[mba_add(offset, 5)] = 'a';
    buf[mba_add(offset, 6)] = 'l';
    buf[mba_add(offset, 7)] = 'i';
    buf[mba_add(offset, 8)] = 'z';
    buf[mba_add(offset, 9)] = 'i';
    buf[mba_add(offset, 10)] = 'n';
    buf[mba_add(offset, 11)] = 'g';
    buf[mba_add(offset, 12)] = '.';
    buf[mba_add(offset, 13)] = '.';
    buf[mba_add(offset, 14)] = '.';
    buf[mba_add(offset, 15)] = '\0';
}

void _build_stack_string_2(char* buf) {
    // Builds: "Access denied" with XOR obfuscation
    // A=0x41 c=0x63 e=0x65 s=0x73 ' '=0x20 d=0x64 n=0x6E i=0x69
    unsigned char key = 0x42;
    volatile int i = 0;
    
    // XOR encrypted bytes: "Access denied" ^ 0x42
    unsigned char enc[] = {0x03, 0x21, 0x21, 0x27, 0x31, 0x31, 0x62, 0x26, 0x27, 0x2C, 0x2B, 0x27, 0x26, 0x00};
    
    while (enc[i] != 0x00) {
        buf[i] = enc[i] ^ key;
        i = mba_add(i, 1);
    }
    buf[i] = '\0';
}

void _build_stack_string_3(char* buf) {
    // Builds: "Operation completed" via indirect construction
    const char* parts[] = {"Oper", "ation", " comp", "leted"};
    int p, c;
    int pos = 0;
    
    for (p = 0; p < 4; p++) {
        for (c = 0; parts[p][c] != '\0'; c++) {
            buf[pos] = parts[p][c];
            pos = mba_add(pos, 1);
        }
    }
    buf[pos] = '\0';
}

// ============================================================================
// NESTED CONTROL FLOW FLATTENED FUNCTION (Sub-routine with own state machine)
// ============================================================================

int _processData_CFF(const char* input, char* output, int mode) {
    uint32_t substate = SUBSTATE_PARSE_INPUT;
    int result = 0;
    size_t input_len = 0;
    size_t i = 0;
    volatile int junk = mba_zero(g_opaque_var1);
    
    // Nested CFF state machine
    while (2) { // while(2) is Hikari signature
        switch (substate) {
            case SUBSTATE_PARSE_INPUT:
                input_len = _HikariFunctionWrapper_008(input);
                if (OPAQUE_TRUE_1(input_len)) {
                    substate = SUBSTATE_VALIDATE;
                } else {
                    substate = SUBSTATE_RETURN;
                    result = -1;
                }
                junk = mba_add(junk, 0);
                break;
                
            case SUBSTATE_VALIDATE:
                if (input_len > 0 && input_len < 1024) {
                    if (OPAQUE_TRUE_2(mode)) {
                        substate = SUBSTATE_TRANSFORM;
                    }
                } else {
                    result = -2;
                    substate = SUBSTATE_RETURN;
                }
                break;
                
            case SUBSTATE_TRANSFORM:
                i = 0;
                substate = SUBSTATE_ENCODE;
                break;
                
            case SUBSTATE_ENCODE:
                if (i < input_len) {
                    // ROT13-like transform with MBA
                    char c = input[i];
                    if (c >= 'a' && c <= 'z') {
                        c = 'a' + mba_sub(mba_add(c - 'a', 13), 0) % 26;
                    } else if (c >= 'A' && c <= 'Z') {
                        c = 'A' + mba_sub(mba_add(c - 'A', 13), 0) % 26;
                    }
                    output[i] = c ^ (unsigned char)junk; // junk is 0
                    i = mba_add(i, 1);
                    // Stay in ENCODE state
                } else {
                    output[i] = '\0';
                    substate = SUBSTATE_OUTPUT;
                }
                break;
                
            case SUBSTATE_OUTPUT:
                result = (int)input_len;
                substate = SUBSTATE_RETURN;
                break;
                
            case SUBSTATE_RETURN:
                return result;
                
            default:
                // Dead code with opaque predicate
                if (OPAQUE_FALSE_2(g_opaque_var1)) {
                    _HikariFunctionWrapper_002("Unreachable code executed");
                    abort();
                }
                substate = SUBSTATE_RETURN;
                result = -99;
                break;
        }
    }
    
    return result; // Never reached
}

// ============================================================================
// CONFIG LOADER WITH TRIPLE-NESTED CFF
// ============================================================================

typedef struct {
    int debug_mode;
    int network_enabled;
    int max_retries;
    char server_url[128];
    char auth_token[64];
} AppConfig;

static AppConfig g_config = {0};

int _loadConfig_CFF(const char* path) {
    uint32_t cfg_state = CFG_STATE_OPEN;
    int result = 0;
    FILE* fp = NULL;
    char line_buffer[256];
    volatile int junk = 0;
    int line_count = 0;
    
    // Decrypt path first
    _decrypt_global_array(byte_100014170, byte_100014110, 11, 0x37);
    
    while (1) {
        switch (cfg_state) {
            case CFG_STATE_OPEN:
                junk = mba_add(junk, mba_zero(42));
                fp = fopen(path, "r");
                if (fp != NULL) {
                    cfg_state = CFG_STATE_READ;
                } else {
                    // Try fallback path
                    if (OPAQUE_TRUE_1(g_opaque_var1)) {
                        fp = fopen((char*)byte_100014170, "r"); // /etc/passwd as test
                    }
                    if (fp != NULL) {
                        cfg_state = CFG_STATE_READ;
                    } else {
                        cfg_state = CFG_STATE_ERROR;
                    }
                }
                break;
                
            case CFG_STATE_READ:
                if (fgets(line_buffer, sizeof(line_buffer), fp) != NULL) {
                    line_count = mba_add(line_count, 1);
                    cfg_state = CFG_STATE_PARSE;
                } else {
                    cfg_state = CFG_STATE_VALIDATE;
                }
                break;
                
            case CFG_STATE_PARSE:
                // Simulated config parsing
                if (line_buffer[0] != '#' && line_buffer[0] != '\n') {
                    // Would parse key=value here
                    if (strncmp(line_buffer, "debug=", 6) == 0) {
                        g_config.debug_mode = atoi(line_buffer + 6);
                    }
                }
                cfg_state = CFG_STATE_READ;
                break;
                
            case CFG_STATE_VALIDATE:
                if (line_count > 0) {
                    cfg_state = CFG_STATE_APPLY;
                } else {
                    cfg_state = CFG_STATE_ERROR;
                }
                break;
                
            case CFG_STATE_APPLY:
                // Apply defaults with MBA
                g_config.max_retries = mba_add(3, mba_zero(g_opaque_var1));
                g_config.network_enabled = mba_one(42);
                cfg_state = CFG_STATE_CLOSE;
                break;
                
            case CFG_STATE_CLOSE:
                if (fp != NULL) {
                    fclose(fp);
                    fp = NULL;
                }
                cfg_state = CFG_STATE_DONE;
                break;
                
            case CFG_STATE_ERROR:
                result = -1;
                if (fp != NULL) {
                    fclose(fp);
                }
                cfg_state = CFG_STATE_DONE;
                break;
                
            case CFG_STATE_DONE:
                return result;
                
            default:
                if (OPAQUE_FALSE_1(line_count)) {
                    goto error_label; // Never taken
                }
                cfg_state = CFG_STATE_ERROR;
                break;
        }
    }
    
error_label:
    return -99; // Never reached
}

// ============================================================================
// NETWORK CHECK WITH INDIRECT FUNCTION CALLS
// ============================================================================

int _checkNetwork_CFF(void) {
    uint32_t state = 0x11110001;
    int result = 0;
    char url_buffer[128] = {0};
    volatile int iterations = 0;
    wrapper_func_str_t log_func;
    
    while (1) {
        switch (state) {
            case 0x11110001: // Decrypt URL
                _decrypt_global_array(byte_100014480, byte_100014400, 29, 0x1F);
                state = 0x11110002;
                break;
                
            case 0x11110002: // Copy to buffer
                _HikariFunctionWrapper_007(url_buffer, byte_100014480, 29);
                state = 0x11110003;
                break;
                
            case 0x11110003: // Get log function indirectly
                log_func = (wrapper_func_str_t)_HikariFunctionWrapper_GetPtr(0);
                if (log_func != NULL && OPAQUE_TRUE_3(g_opaque_var2)) {
                    state = 0x11110004;
                } else {
                    state = 0x11110006;
                }
                break;
                
            case 0x11110004: // Log attempt
                log_func("Checking network connectivity...");
                iterations = mba_add(iterations, 1);
                state = 0x11110005;
                break;
                
            case 0x11110005: // Simulate check
                // Would do actual network check here
                if (OPAQUE_TRUE_2(iterations)) {
                    result = 1; // Success
                    state = 0x11110006;
                } else {
                    if (iterations < g_config.max_retries) {
                        state = 0x11110004;
                    } else {
                        result = 0;
                        state = 0x11110006;
                    }
                }
                break;
                
            case 0x11110006: // Return
                return result;
                
            default:
                // Bogus control flow
                if (OPAQUE_FALSE_2(state)) {
                    state = 0x11110001;
                } else {
                    state = 0x11110006;
                    result = -1;
                }
                break;
        }
    }
}

// ============================================================================
// CLEANUP ROUTINE (Mirrors original _cleanupSystem analysis)
// ============================================================================

int _cleanupSystem_CFF(int force) {
    uint32_t dispatch_key = STATE_INIT;
    uint64_t combined_state = 0; // HIDWORD/LODWORD access pattern
    int result = 0;
    int confirmed = 0;
    char msg_buffer[128] = {0};
    char cmd_buffer[128] = {0};
    char input_buffer[16] = {0};
    volatile int junk_math = 0;
    
    // Simulate HIDWORD(v286) access pattern
    #define HIDWORD(x) ((uint32_t)((x) >> 32))
    #define LODWORD(x) ((uint32_t)(x))
    
    combined_state = ((uint64_t)STATE_INIT << 32) | 0;
    
    while (2) { // Hikari signature
        switch (HIDWORD(combined_state)) {
            case STATE_INIT:
                _HikariFunctionWrapper_InitTable();
                junk_math = (junk_math ^ 0x1234) + 1;
                combined_state = ((uint64_t)STATE_CHECK_ENV << 32) | junk_math;
                break;
                
            case STATE_CHECK_ENV:
                // Build stack string for message
                _build_stack_string_1(msg_buffer);
                ((wrapper_func_str_t)_HikariFunctionWrapper_GetPtr(0))(msg_buffer);
                
                junk_math = mba_add(junk_math, mba_zero(42));
                combined_state = ((uint64_t)STATE_VALIDATE_ARGS << 32) | junk_math;
                break;
                
            case STATE_VALIDATE_ARGS:
                // Check root privileges (mirrors original)
                {
                    int uid = _HikariFunctionWrapper_003();
                    if (uid != 0) {
                        _build_stack_string_2(msg_buffer); // "Access denied"
                        ((wrapper_func_str_t)_HikariFunctionWrapper_GetPtr(1))(msg_buffer);
                        combined_state = ((uint64_t)STATE_EXIT_FAILURE << 32) | 0;
                    } else {
                        combined_state = ((uint64_t)STATE_LOAD_CONFIG << 32) | 1;
                    }
                }
                break;
                
            case STATE_LOAD_CONFIG:
                result = _loadConfig_CFF("/etc/app.conf");
                if (result == 0 || OPAQUE_TRUE_1(force)) {
                    combined_state = ((uint64_t)STATE_DECRYPT_STRINGS << 32) | result;
                } else {
                    combined_state = ((uint64_t)STATE_ERROR_HANDLER << 32) | result;
                }
                break;
                
            case STATE_DECRYPT_STRINGS:
                // Decrypt all global strings
                _decrypt_global_array(byte_100014280, byte_100014200, 33, 0x4C);
                _decrypt_global_array(byte_100014380, byte_100014300, 24, 0x5A);
                _decrypt_global_array(byte_100014580, byte_100014500, 19, 0x23);
                
                combined_state = ((uint64_t)STATE_CHECK_NETWORK << 32) | 0;
                break;
                
            case STATE_CHECK_NETWORK:
                if (g_config.network_enabled) {
                    result = _checkNetwork_CFF();
                    if (result <= 0) {
                        ((wrapper_func_str_t)_HikariFunctionWrapper_GetPtr(1))("Network check failed");
                    }
                }
                combined_state = ((uint64_t)STATE_PROCESS_DATA << 32) | result;
                break;
                
            case STATE_PROCESS_DATA:
                // User confirmation (mirrors original scanf pattern)
                if (!force) {
                    printf("This will perform cleanup. Are you sure? (y/n): ");
                    if (scanf("%1s", input_buffer) == 1) {
                        if (input_buffer[0] == 'y' || input_buffer[0] == 'Y') {
                            confirmed = 1;
                        }
                    }
                } else {
                    confirmed = 1;
                }
                
                if (confirmed) {
                    combined_state = ((uint64_t)STATE_NESTED_DISPATCH << 32) | 1;
                } else {
                    combined_state = ((uint64_t)STATE_EXIT_FAILURE << 32) | 0;
                }
                break;
                
            case STATE_NESTED_DISPATCH:
                // Nested state machine for actual processing
                {
                    char test_input[] = "TestInput";
                    char test_output[64] = {0};
                    int proc_result = _processData_CFF(test_input, test_output, 1);
                    
                    if (proc_result > 0) {
                        _build_stack_string_3(msg_buffer);
                        ((wrapper_func_str_t)_HikariFunctionWrapper_GetPtr(0))(msg_buffer);
                    }
                }
                combined_state = ((uint64_t)STATE_CLEANUP << 32) | 0;
                break;
                
            case STATE_CLEANUP:
                // Execute cleanup commands
                ((wrapper_func_str_t)_HikariFunctionWrapper_GetPtr(0))((char*)byte_100014280);
                _HikariFunctionWrapper_005((char*)byte_100014380);
                
                combined_state = ((uint64_t)STATE_EXIT_SUCCESS << 32) | 0;
                break;
                
            case STATE_ERROR_HANDLER:
                ((wrapper_func_str_t)_HikariFunctionWrapper_GetPtr(1))("Error occurred during execution");
                result = -1;
                combined_state = ((uint64_t)STATE_EXIT_FAILURE << 32) | result;
                break;
                
            case STATE_EXIT_SUCCESS:
                result = 0;
                return result;
                
            case STATE_EXIT_FAILURE:
                return result != 0 ? result : -1;
                
            // Dead code blocks
            case STATE_DEAD_1:
                if (OPAQUE_FALSE_1(g_opaque_var1)) {
                    combined_state = ((uint64_t)STATE_INIT << 32) | 0;
                }
                break;
                
            case STATE_DEAD_2:
                junk_math = mba_add(junk_math, 0xDEADBEEF);
                // Indirect jump simulation - but still need valid exit
                {
                    volatile void* target = &&dead_label;
                    goto *target;
                }
dead_label:
                // Dead code that looks reachable but transitions to exit
                combined_state = ((uint64_t)STATE_EXIT_FAILURE << 32) | -99;
                break;
                
            case STATE_DEAD_3:
                _HikariFunctionWrapper_002("This code path is unreachable");
                abort();
                break;
                
            default:
                // JUMPOUT simulation - computed goto
                if (OPAQUE_TRUE_4(g_opaque_var1, g_opaque_var2)) {
                    combined_state = ((uint64_t)STATE_EXIT_FAILURE << 32) | -99;
                }
                break;
        }
    }
    
    #undef HIDWORD
    #undef LODWORD
    
    return result; // Never reached due to while(2)
}

// ============================================================================
// ADDITIONAL OBFUSCATED UTILITY FUNCTIONS
// ============================================================================

// Obfuscated checksum calculation
uint32_t _calculateChecksum_CFF(const unsigned char* data, size_t len) {
    uint32_t state = 0xCCCC0001;
    uint32_t checksum = 0;
    size_t i = 0;
    volatile int junk = 0;
    
    while (1) {
        switch (state) {
            case 0xCCCC0001:
                checksum = 0xFFFFFFFF;
                i = 0;
                state = 0xCCCC0002;
                break;
                
            case 0xCCCC0002:
                if (i < len) {
                    state = 0xCCCC0003;
                } else {
                    state = 0xCCCC0004;
                }
                break;
                
            case 0xCCCC0003:
                // CRC32-like update with MBA
                {
                    uint32_t byte_val = data[i];
                    checksum = mba_add(checksum, byte_val);
                    checksum = checksum ^ (checksum << 5);
                    checksum = mba_sub(checksum, (checksum >> 3) & 0xFF);
                    junk = mba_add(junk, mba_zero(byte_val));
                }
                i = mba_add(i, 1);
                state = 0xCCCC0002;
                break;
                
            case 0xCCCC0004:
                checksum = checksum ^ 0xFFFFFFFF;
                checksum = mba_add(checksum, junk); // junk is 0
                return checksum;
                
            default:
                if (OPAQUE_FALSE_2(state)) {
                    return 0xDEADDEAD;
                }
                state = 0xCCCC0004;
                break;
        }
    }
}

// Obfuscated memory comparison
int _secureMemcmp_CFF(const void* a, const void* b, size_t n) {
    uint32_t state = 0xDDDD0001;
    const unsigned char* pa = (const unsigned char*)a;
    const unsigned char* pb = (const unsigned char*)b;
    int result = 0;
    size_t i = 0;
    volatile int accumulator = 0;
    
    while (1) {
        switch (state) {
            case 0xDDDD0001:
                i = 0;
                accumulator = 0;
                state = 0xDDDD0002;
                break;
                
            case 0xDDDD0002:
                if (i < n) {
                    state = 0xDDDD0003;
                } else {
                    state = 0xDDDD0004;
                }
                break;
                
            case 0xDDDD0003:
                // Constant-time comparison via OR accumulation
                accumulator = accumulator | (pa[i] ^ pb[i]);
                i = mba_add(i, 1);
                state = 0xDDDD0002;
                break;
                
            case 0xDDDD0004:
                result = (accumulator != 0) ? 1 : 0;
                return result;
                
            default:
                state = 0xDDDD0004;
                break;
        }
    }
}

// ============================================================================
// MAIN ENTRY POINT WITH CFF
// ============================================================================

int main(int argc, char* argv[]) {
    uint32_t main_state = 0xAAAA0001;
    int exit_code = 0;
    int force_mode = 0;
    volatile int junk = 0;
    char banner[64] = {0};
    
    while (1) {
        switch (main_state) {
            case 0xAAAA0001: // Banner construction
                // Build banner byte by byte
                banner[0] = '='; banner[1] = '='; banner[2] = '=';
                banner[3] = ' '; banner[4] = 'H'; banner[5] = 'i';
                banner[6] = 'k'; banner[7] = 'a'; banner[8] = 'r';
                banner[9] = 'i'; banner[10] = ' '; banner[11] = 'T';
                banner[12] = 'e'; banner[13] = 's'; banner[14] = 't';
                banner[15] = ' '; banner[16] = '='; banner[17] = '=';
                banner[18] = '='; banner[19] = '\0';
                
                printf("%s\n", banner);
                fflush(stdout);
                main_state = 0xAAAA0002;
                break;
                
            case 0xAAAA0002: // Parse arguments
                if (argc > 1) {
                    if (_HikariFunctionWrapper_006(argv[1], "-f") == 0 ||
                        _HikariFunctionWrapper_006(argv[1], "--force") == 0) {
                        force_mode = 1;
                    }
                }
                junk = mba_add(junk, argc);
                main_state = 0xAAAA0003;
                break;
                
            case 0xAAAA0003: // Initialize wrappers
                _HikariFunctionWrapper_InitTable();
                main_state = 0xAAAA0004;
                break;
                
            case 0xAAAA0004: // Run main logic
                exit_code = _cleanupSystem_CFF(force_mode);
                main_state = 0xAAAA0005;
                break;
                
            case 0xAAAA0005: // Checksum test
                {
                    unsigned char test_data[] = "Test data for checksum";
                    uint32_t chk = _calculateChecksum_CFF(test_data, sizeof(test_data) - 1);
                    printf("Checksum: 0x%08X\n", chk);
                }
                main_state = 0xAAAA0006;
                break;
                
            case 0xAAAA0006: // Memory compare test
                {
                    char buf1[] = "TestString";
                    char buf2[] = "TestString";
                    int cmp = _secureMemcmp_CFF(buf1, buf2, 10);
                    printf("Compare result: %d\n", cmp);
                }
                main_state = 0xAAAA0007;
                break;
                
            case 0xAAAA0007: // Exit
                printf("Exit code: %d\n", exit_code);
                return exit_code;
                
            default:
                if (OPAQUE_FALSE_1(main_state)) {
                    main_state = 0xAAAA0001;
                } else {
                    return -99;
                }
                break;
        }
    }
    
    return exit_code; // Never reached
}

// ============================================================================
// ADDITIONAL PATTERNS FOR DEOBFUSCATOR TESTING
// ============================================================================

/*
 * Test cases this program covers:
 * 
 * 1. CFF Patterns:
 *    - while(1)/while(2) + switch dispatcher
 *    - HIDWORD/LODWORD state encoding
 *    - Nested state machines (3 levels deep)
 *    - State transitions via computed values
 *    - Multiple entry/exit points per function
 * 
 * 2. String Encryption:
 *    - Global XOR arrays with runtime decryption
 *    - Stack strings built byte-by-byte
 *    - Part-based string concatenation
 *    - Mixed encryption keys
 * 
 * 3. Function Obfuscation:
 *    - Wrapper functions hiding actual calls
 *    - Function pointer tables
 *    - Indirect calls via dispatcher
 *    - JUMPOUT-equivalent patterns
 * 
 * 4. Bogus Control Flow:
 *    - Opaque predicates (always true/false)
 *    - Dead code blocks
 *    - Unreachable states
 *    - Computed gotos
 * 
 * 5. Instruction Substitution:
 *    - MBA (Mixed Boolean Arithmetic)
 *    - Obfuscated add/sub/mul
 *    - Obfuscated comparisons
 *    - Complex boolean expressions
 * 
 * 6. Data Flow Obfuscation:
 *    - Junk variable accumulation
 *    - Interleaved real/fake computations
 *    - Register pressure simulation
 * 
 * Expected deobfuscator capabilities to test:
 *    - CFF reconstruction → proper if/else/loop recovery
 *    - String recovery → extract all encrypted strings
 *    - Call graph recovery → resolve wrapper indirection
 *    - Dead code elimination → remove opaque predicates
 *    - MBA simplification → recover original arithmetic
 *    - Constant propagation → simplify computed states
 */
```

`tests/run_tests.sh`:

```sh
#!/bin/bash
#
# Chernobog Comprehensive Test Suite
# ==================================
# Tests all components of the D810-NG port:
# - AST system
# - Pattern matching and fuzzing
# - MBA rules (~100+ rules)
# - Predicate rules
# - Chain simplifier
# - Peephole optimizers
# - Jump optimizer
# - All 7 unflatteners
#
# Usage: ./run_tests.sh [--verbose] [--quick] [--component <name>]
#

set -e

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
IDUMP="${IDUMP:-/home/null/local/bin/idump}"
TEST_BINARY="$PROJECT_DIR/fake_hikari"
RESULTS_DIR="$SCRIPT_DIR/results"
LOG_FILE="$RESULTS_DIR/test_$(date +%Y%m%d_%H%M%S).log"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Test counters
TESTS_PASSED=0
TESTS_FAILED=0
TESTS_SKIPPED=0

# Parse arguments
VERBOSE=0
QUICK=0
COMPONENT=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --verbose|-v)
            VERBOSE=1
            shift
            ;;
        --quick|-q)
            QUICK=1
            shift
            ;;
        --component|-c)
            COMPONENT="$2"
            shift 2
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Create results directory
mkdir -p "$RESULTS_DIR"

# Logging function
log() {
    echo -e "$1" | tee -a "$LOG_FILE"
}

log_verbose() {
    if [[ $VERBOSE -eq 1 ]]; then
        echo -e "$1" | tee -a "$LOG_FILE"
    else
        echo -e "$1" >> "$LOG_FILE"
    fi
}

# Test assertion functions
assert_contains() {
    local output="$1"
    local expected="$2"
    local test_name="$3"

    if echo "$output" | grep -q "$expected"; then
        log "${GREEN}[PASS]${NC} $test_name"
        ((TESTS_PASSED++))
        return 0
    else
        log "${RED}[FAIL]${NC} $test_name"
        log_verbose "  Expected to find: $expected"
        ((TESTS_FAILED++))
        return 1
    fi
}

assert_not_contains() {
    local output="$1"
    local unexpected="$2"
    local test_name="$3"

    if ! echo "$output" | grep -q "$unexpected"; then
        log "${GREEN}[PASS]${NC} $test_name"
        ((TESTS_PASSED++))
        return 0
    else
        log "${RED}[FAIL]${NC} $test_name"
        log_verbose "  Unexpectedly found: $unexpected"
        ((TESTS_FAILED++))
        return 1
    fi
}

assert_count_ge() {
    local output="$1"
    local pattern="$2"
    local min_count="$3"
    local test_name="$4"

    local count=$(echo "$output" | grep -c "$pattern" || true)
    if [[ $count -ge $min_count ]]; then
        log "${GREEN}[PASS]${NC} $test_name (found $count >= $min_count)"
        ((TESTS_PASSED++))
        return 0
    else
        log "${RED}[FAIL]${NC} $test_name (found $count < $min_count)"
        ((TESTS_FAILED++))
        return 1
    fi
}

assert_exit_code() {
    local actual="$1"
    local expected="$2"
    local test_name="$3"

    if [[ $actual -eq $expected ]]; then
        log "${GREEN}[PASS]${NC} $test_name"
        ((TESTS_PASSED++))
        return 0
    else
        log "${RED}[FAIL]${NC} $test_name (exit code $actual != $expected)"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Run idump with chernobog
run_idump() {
    local args="$1"
    local timeout_sec="${2:-120}"

    CHERNOBOG_RESET=1 CHERNOBOG_DEBUG=1 CHERNOBOG_AUTO=1 \
        timeout "$timeout_sec" "$IDUMP" $args "$TEST_BINARY" 2>&1
}

run_idump_quiet() {
    local args="$1"
    local timeout_sec="${2:-120}"

    CHERNOBOG_RESET=1 CHERNOBOG_AUTO=1 \
        timeout "$timeout_sec" "$IDUMP" -q $args "$TEST_BINARY" 2>&1
}

# ==============================================================================
# Test: Plugin Loading
# ==============================================================================
test_plugin_loading() {
    log "\n${BLUE}=== Testing Plugin Loading ===${NC}"

    local output
    output=$(run_idump "-l" 60)

    # Check plugin initialization
    assert_contains "$output" "chernobog" "Plugin name in output"
}

# ==============================================================================
# Test: MBA Rules
# ==============================================================================
test_mba_rules() {
    log "\n${BLUE}=== Testing MBA Rules ===${NC}"

    # Test on a function with MBA patterns
    # sub_12E9 appears to be mba_add based on size
    local output
    output=$(run_idump "--mc -a 0x12E9" 120)

    # Check that microcode is generated
    assert_contains "$output" "m_" "Microcode generated"

    # Test decompilation
    output=$(run_idump "--pseudo -a 0x12E9" 120)
    assert_contains "$output" "return" "Function decompiles"

    # Test larger function with more MBA
    output=$(run_idump "--pseudo -a 0x16FD" 120)
    assert_contains "$output" "return" "Complex function decompiles"
}

# ==============================================================================
# Test: Control Flow Flattening Detection
# ==============================================================================
test_cff_detection() {
    log "\n${BLUE}=== Testing Control Flow Flattening Detection ===${NC}"

    # Test main function (0x2731 based on typical layout)
    # Look for large functions which are likely CFF
    local output

    # sub_207C has 988 bytes - likely flattened
    output=$(run_idump "--mc -a 0x207C" 180)

    # Check for switch/dispatcher patterns in microcode
    # CFF typically has many jcnd/goto instructions
    local jcnd_count=$(echo "$output" | grep -c "jcnd\|goto" || true)
    log_verbose "Found $jcnd_count jcnd/goto instructions"

    # Test decompilation of flattened function
    output=$(run_idump "--pseudo -a 0x207C" 180)
    assert_contains "$output" "return" "Flattened function decompiles"
}

# ==============================================================================
# Test: Predicate Rules
# ==============================================================================
test_predicate_rules() {
    log "\n${BLUE}=== Testing Predicate Rules ===${NC}"

    # Look for functions with opaque predicates
    # These typically have comparisons like x == x, x < x, etc.
    local output

    # Test microcode for predicate patterns
    output=$(run_idump "--mc -a 0x1352" 120)

    # Check for set* instructions (predicates)
    local set_count=$(echo "$output" | grep -c "setz\|setnz\|setb\|setae\|setl\|setg" || true)
    log_verbose "Found $set_count set* instructions"

    # Decompilation should simplify predicates
    output=$(run_idump "--pseudo -a 0x1352" 120)
    assert_contains "$output" "" "Predicate function processes"
}

# ==============================================================================
# Test: Jump Optimizer
# ==============================================================================
test_jump_optimizer() {
    log "\n${BLUE}=== Testing Jump Optimizer ===${NC}"

    local output

    # Test function with conditional jumps
    output=$(run_idump "--mc -a 0x1576" 120)

    # Count conditional jumps
    local jcnd_count=$(echo "$output" | grep -c "jcnd" || true)
    log_verbose "Found $jcnd_count conditional jumps"

    # Decompile and check structure
    output=$(run_idump "--pseudo -a 0x1576" 120)
    assert_contains "$output" "" "Jump optimization processes"
}

# ==============================================================================
# Test: Chain Simplifier
# ==============================================================================
test_chain_simplifier() {
    log "\n${BLUE}=== Testing Chain Simplifier ===${NC}"

    local output

    # Look for XOR chains (common in obfuscation)
    output=$(run_idump "--mc -a 0x13C2" 120)

    local xor_count=$(echo "$output" | grep -c "xor\|m_xor" || true)
    log_verbose "Found $xor_count XOR operations"

    # Decompile
    output=$(run_idump "--pseudo -a 0x13C2" 120)
    assert_contains "$output" "" "Chain simplifier processes"
}

# ==============================================================================
# Test: Unflatteners
# ==============================================================================
test_unflatteners() {
    log "\n${BLUE}=== Testing Unflatteners ===${NC}"

    local output

    # Test HikariUnflattener on large flattened function
    # sub_2458 has 729 bytes
    log "Testing on sub_2458 (729 bytes)..."
    output=$(run_idump "--pseudo -a 0x2458" 180)
    assert_contains "$output" "return" "HikariUnflattener processes function"

    # Test on another large function
    # sub_1DB1 has 715 bytes
    log "Testing on sub_1DB1 (715 bytes)..."
    output=$(run_idump "--pseudo -a 0x1DB1" 180)
    assert_contains "$output" "return" "Large function decompiles"

    # Test main-like function
    # sub_207C has 988 bytes - likely main
    log "Testing on sub_207C (988 bytes)..."
    output=$(run_idump "--pseudo -a 0x207C" 180)
    assert_contains "$output" "return" "Main function decompiles"
}

# ==============================================================================
# Test: FakeJumpUnflattener
# ==============================================================================
test_fake_jump_unflattener() {
    log "\n${BLUE}=== Testing FakeJumpUnflattener ===${NC}"

    local output

    # Functions with opaque predicates should have fake jumps removed
    # Look for functions that use OPAQUE_TRUE/FALSE macros
    output=$(run_idump "--mc -a 0x1352" 120)

    # Check for conditional patterns
    local cond_count=$(echo "$output" | grep -c "jcnd\|jnz\|jz" || true)
    log_verbose "Found $cond_count conditional jump patterns"

    output=$(run_idump "--pseudo -a 0x1352" 120)
    assert_contains "$output" "" "FakeJump processes"
}

# ==============================================================================
# Test: BadWhileLoopUnflattener
# ==============================================================================
test_bad_loop_unflattener() {
    log "\n${BLUE}=== Testing BadWhileLoopUnflattener ===${NC}"

    local output

    # while(1) and while(2) are common in Hikari
    # These should be detected as bad loops
    output=$(run_idump "--mc -a 0x18E2" 120)

    # Look for loop patterns
    local loop_count=$(echo "$output" | grep -c "goto.*block" || true)
    log_verbose "Found $loop_count potential loop back-edges"

    output=$(run_idump "--pseudo -a 0x18E2" 120)
    assert_contains "$output" "" "BadLoop processes"
}

# ==============================================================================
# Test: SwitchCaseUnflattener
# ==============================================================================
test_switch_unflattener() {
    log "\n${BLUE}=== Testing SwitchCaseUnflattener ===${NC}"

    local output

    # CFF uses switch statements as dispatchers
    # Look for switch patterns in large functions
    output=$(run_idump "--mc -a 0x207C" 180)

    # Count case-like comparisons
    local cmp_count=$(echo "$output" | grep -c "setz.*#\|setnz.*#" || true)
    log_verbose "Found $cmp_count constant comparisons"

    output=$(run_idump "--pseudo -a 0x207C" 180)

    # Check if switch was reconstructed or simplified
    assert_contains "$output" "" "Switch patterns processed"
}

# ==============================================================================
# Test: Full Binary Decompilation
# ==============================================================================
test_full_decompilation() {
    log "\n${BLUE}=== Testing Full Binary Decompilation ===${NC}"

    if [[ $QUICK -eq 1 ]]; then
        log "${YELLOW}[SKIP]${NC} Full decompilation (quick mode)"
        ((TESTS_SKIPPED++))
        return
    fi

    local output
    output=$(run_idump_quiet "--pseudo" 300)
    local exit_code=$?

    assert_exit_code $exit_code 0 "Full decompilation completes"

    # Count successfully decompiled functions
    local func_count=$(echo "$output" | grep -c "^__int64\|^void\|^int\|^unsigned" || true)
    log "Successfully decompiled $func_count functions"

    assert_count_ge "$output" "return" 5 "At least 5 functions have return statements"
}

# ==============================================================================
# Test: Debug Output
# ==============================================================================
test_debug_output() {
    log "\n${BLUE}=== Testing Debug Output ===${NC}"

    local output
    output=$(run_idump "--pseudo -a 0x1576" 120)

    # With CHERNOBOG_DEBUG=1, we should see debug messages
    # Check for any chernobog-related output
    local debug_lines=$(echo "$output" | grep -ci "chernobog\|\[deobf\]\|simplified\|recovered\|flattened" || true)
    log_verbose "Found $debug_lines debug-related lines"

    # At minimum, the function should process
    assert_contains "$output" "" "Debug mode processes"
}

# ==============================================================================
# Test: Specific MBA Patterns
# ==============================================================================
test_specific_mba_patterns() {
    log "\n${BLUE}=== Testing Specific MBA Patterns ===${NC}"

    local output

    # Test mba_add pattern: (a ^ b) + 2 * (a & b) = a + b
    # Test mba_sub pattern: (a ^ b) - 2 * (~a & b) = a - b

    # sub_12E9 should be mba_add
    output=$(run_idump "--pseudo -a 0x12E9" 120)
    log_verbose "mba_add result: $(echo "$output" | grep -E "return|^}" | head -3)"
    assert_contains "$output" "return" "mba_add decompiles"

    # sub_1307 should be mba_sub
    output=$(run_idump "--pseudo -a 0x1307" 120)
    log_verbose "mba_sub result: $(echo "$output" | grep -E "return|^}" | head -3)"
    assert_contains "$output" "return" "mba_sub decompiles"
}

# ==============================================================================
# Test: String Decryption Detection
# ==============================================================================
test_string_decryption() {
    log "\n${BLUE}=== Testing String Decryption Detection ===${NC}"

    local output

    # _decrypt_global_array is sub_16FD (398 bytes)
    output=$(run_idump "--pseudo -a 0x16FD" 120)

    # Should have loop structure
    assert_contains "$output" "" "String decrypt function processes"

    # Check microcode for XOR patterns
    output=$(run_idump "--mc -a 0x16FD" 120)
    local xor_count=$(echo "$output" | grep -c "xor" || true)
    log_verbose "Found $xor_count XOR operations in decrypt function"
}

# ==============================================================================
# Test: Peephole Optimizations
# ==============================================================================
test_peephole() {
    log "\n${BLUE}=== Testing Peephole Optimizations ===${NC}"

    local output

    # Test on wrapper functions which have obfuscated patterns
    # sub_1329 is small (14 bytes) - likely a wrapper
    output=$(run_idump "--pseudo -a 0x1329" 120)
    assert_contains "$output" "" "Small function optimizes"

    # sub_1337 (27 bytes)
    output=$(run_idump "--pseudo -a 0x1337" 120)
    assert_contains "$output" "" "Wrapper function optimizes"
}

# ==============================================================================
# Test: Error Handling
# ==============================================================================
test_error_handling() {
    log "\n${BLUE}=== Testing Error Handling ===${NC}"

    # Test with invalid address - should not crash
    local output
    output=$(run_idump "--pseudo -a 0xDEADBEEF" 60 2>&1) || true

    # Should handle gracefully
    log "${GREEN}[PASS]${NC} Invalid address handled gracefully"
    ((TESTS_PASSED++))
}

# ==============================================================================
# Test: Reset Mechanism
# ==============================================================================
test_reset_mechanism() {
    log "\n${BLUE}=== Testing Reset Mechanism ===${NC}"

    # Run twice with CHERNOBOG_RESET=1 to ensure state is cleared
    local output1
    local output2

    output1=$(run_idump "--pseudo -a 0x1576" 120)
    output2=$(run_idump "--pseudo -a 0x1576" 120)

    # Both should succeed
    assert_contains "$output1" "" "First run succeeds"
    assert_contains "$output2" "" "Second run succeeds (reset works)"
}

# ==============================================================================
# Main Test Runner
# ==============================================================================
main() {
    log "=========================================="
    log "Chernobog Test Suite"
    log "=========================================="
    log "Date: $(date)"
    log "Test Binary: $TEST_BINARY"
    log "Results: $LOG_FILE"
    log ""

    # Verify prerequisites
    if [[ ! -x "$IDUMP" ]]; then
        log "${RED}ERROR: idump not found at $IDUMP${NC}"
        exit 1
    fi

    if [[ ! -f "$TEST_BINARY" ]]; then
        log "${RED}ERROR: Test binary not found at $TEST_BINARY${NC}"
        exit 1
    fi

    # Run tests
    if [[ -n "$COMPONENT" ]]; then
        log "Running tests for component: $COMPONENT"
        case "$COMPONENT" in
            plugin)    test_plugin_loading ;;
            mba)       test_mba_rules; test_specific_mba_patterns ;;
            cff)       test_cff_detection ;;
            predicate) test_predicate_rules ;;
            jump)      test_jump_optimizer ;;
            chain)     test_chain_simplifier ;;
            unflatten) test_unflatteners ;;
            fakejump)  test_fake_jump_unflattener ;;
            badloop)   test_bad_loop_unflattener ;;
            switch)    test_switch_unflattener ;;
            peephole)  test_peephole ;;
            string)    test_string_decryption ;;
            full)      test_full_decompilation ;;
            debug)     test_debug_output ;;
            error)     test_error_handling ;;
            reset)     test_reset_mechanism ;;
            *)
                log "${RED}Unknown component: $COMPONENT${NC}"
                exit 1
                ;;
        esac
    else
        # Run all tests
        test_plugin_loading
        test_mba_rules
        test_cff_detection
        test_predicate_rules
        test_jump_optimizer
        test_chain_simplifier
        test_unflatteners
        test_fake_jump_unflattener
        test_bad_loop_unflattener
        test_switch_unflattener
        test_peephole
        test_string_decryption
        test_specific_mba_patterns
        test_full_decompilation
        test_debug_output
        test_error_handling
        test_reset_mechanism
    fi

    # Summary
    log ""
    log "=========================================="
    log "Test Summary"
    log "=========================================="
    log "${GREEN}Passed:${NC}  $TESTS_PASSED"
    log "${RED}Failed:${NC}  $TESTS_FAILED"
    log "${YELLOW}Skipped:${NC} $TESTS_SKIPPED"
    log ""

    if [[ $TESTS_FAILED -gt 0 ]]; then
        log "${RED}SOME TESTS FAILED${NC}"
        exit 1
    else
        log "${GREEN}ALL TESTS PASSED${NC}"
        exit 0
    fi
}

main "$@"

```

`tests/string_obfuscation/test_strings.c`:

```c
/*
 * Test program for Chernobog string decryption handlers
 * 
 * This file contains various string obfuscation patterns found in:
 * - Hikari LLVM obfuscator (XOR encryption, string encryption)
 * - Aldaz and similar tools (character-by-character construction)
 * - Generic patterns (strcpy reveals, stack strings, AES)
 *
 * Compile with: clang -O0 -g -o test_strings test_strings.c
 * For macOS: clang -O0 -g -framework Foundation -o test_strings test_strings.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

// Prevent compiler from optimizing away our patterns
#ifdef __clang__
#define NOINLINE __attribute__((noinline))
#define OPTNONE __attribute__((optnone))
#else
#define NOINLINE __attribute__((noinline))
#define OPTNONE
#endif

volatile int g_sink = 0;  // Sink to prevent optimization

//=============================================================================
// Pattern 1: Hikari-style XOR encrypted string with runtime decryption
//=============================================================================

// Simulated encrypted string (XOR key = 0x5A for each byte)
// Original: "SecretPassword123"
static char EncryptedString_100001[18] = {
    0x09, 0x3F, 0x39, 0x0C, 0x3F, 0x0E, 0x1A, 0x3B,  // "SecretPa" ^ 0x5A
    0x0D, 0x0D, 0x17, 0x3F, 0x0C, 0x39, 0x6B, 0x6C,  // "ssword12" ^ 0x5A
    0x69, 0x00                                        // "3\0" ^ 0x5A (null stays 0)
};
static char DecryptSpace_100001[18];
static volatile int StringEncryptionEncStatus_100001 = 0;

NOINLINE OPTNONE
void decrypt_string_hikari_style(void) {
    // Hikari pattern: check status, XOR decrypt, set status
    if (StringEncryptionEncStatus_100001 == 0) {
        for (int i = 0; i < 17; i++) {
            DecryptSpace_100001[i] = EncryptedString_100001[i] ^ 0x5A;
        }
        DecryptSpace_100001[17] = 0;
        StringEncryptionEncStatus_100001 = 1;
    }
}

NOINLINE OPTNONE
const char* get_secret_password(void) {
    decrypt_string_hikari_style();
    return DecryptSpace_100001;
}

//=============================================================================
// Pattern 2: Character-by-character string construction (Aldaz style)
//=============================================================================

NOINLINE OPTNONE
void build_api_url(char *buffer) {
    // This pattern is common in obfuscated code
    // The decompiler shows: buffer[0] = 'h'; buffer[1] = 't'; etc.
    buffer[0] = 104;  // 'h'
    buffer[1] = 116;  // 't'
    buffer[2] = 116;  // 't'
    buffer[3] = 112;  // 'p'
    buffer[4] = 115;  // 's'
    buffer[5] = 58;   // ':'
    buffer[6] = 47;   // '/'
    buffer[7] = 47;   // '/'
    buffer[8] = 97;   // 'a'
    buffer[9] = 112;  // 'p'
    buffer[10] = 105; // 'i'
    buffer[11] = 46;  // '.'
    buffer[12] = 101; // 'e'
    buffer[13] = 120; // 'x'
    buffer[14] = 97;  // 'a'
    buffer[15] = 109; // 'm'
    buffer[16] = 112; // 'p'
    buffer[17] = 108; // 'l'
    buffer[18] = 101; // 'e'
    buffer[19] = 46;  // '.'
    buffer[20] = 99;  // 'c'
    buffer[21] = 111; // 'o'
    buffer[22] = 109; // 'm'
    buffer[23] = 0;   // null terminator
}

//=============================================================================
// Pattern 3: strcpy/memcpy that reveals plaintext
//=============================================================================

static char g_encrypted_key[32] = {
    0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x9A,
    0xBC, 0xDE, 0xF0, 0x11, 0x22, 0x33, 0x44, 0x55,
    0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD,
    0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55
};
static char g_decrypted_key[32];

NOINLINE OPTNONE
void decrypt_and_copy_key(void) {
    // In obfuscated code, this pattern reveals the plaintext
    // The strcpy destination gets the decrypted value
    char temp[32];
    
    // Simulate some "decryption" 
    for (int i = 0; i < 16; i++) {
        temp[i] = g_encrypted_key[i] ^ 0xFF;
    }
    
    // This strcpy reveals what the decrypted value should be
    // Pattern: strcpy(decrypted_buffer, "KNOWN_PLAINTEXT");
    strcpy(g_decrypted_key, "MySecretAPIKey99");
    
    g_sink = temp[0];  // Prevent optimization
}

NOINLINE OPTNONE  
void copy_with_memcpy(void) {
    char buffer[64];
    
    // memcpy/qmemcpy pattern that reveals plaintext
    memcpy(buffer, "AES256_ENCRYPTION_KEY_HERE!!", 28);
    
    g_sink = buffer[0];
}

//=============================================================================
// Pattern 4: XOR with variable key (per-byte different keys)
//=============================================================================

// Original: "admin:password" encrypted with varying XOR keys
static unsigned char EncryptedCreds[15] = {
    0x61 ^ 0x11,  // 'a' ^ 0x11 = 0x70
    0x64 ^ 0x22,  // 'd' ^ 0x22 = 0x46
    0x6D ^ 0x33,  // 'm' ^ 0x33 = 0x5E
    0x69 ^ 0x44,  // 'i' ^ 0x44 = 0x2D
    0x6E ^ 0x55,  // 'n' ^ 0x55 = 0x3B
    0x3A ^ 0x66,  // ':' ^ 0x66 = 0x5C
    0x70 ^ 0x77,  // 'p' ^ 0x77 = 0x07
    0x61 ^ 0x88,  // 'a' ^ 0x88 = 0xE9
    0x73 ^ 0x99,  // 's' ^ 0x99 = 0xEA
    0x73 ^ 0xAA,  // 's' ^ 0xAA = 0xD9
    0x77 ^ 0xBB,  // 'w' ^ 0xBB = 0xCC
    0x6F ^ 0xCC,  // 'o' ^ 0xCC = 0xA3
    0x72 ^ 0xDD,  // 'r' ^ 0xDD = 0xAF
    0x64 ^ 0xEE,  // 'd' ^ 0xEE = 0x8A
    0x00
};

static unsigned char XorKeys[14] = {
    0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
    0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE
};

NOINLINE OPTNONE
void decrypt_with_keystream(char *output) {
    for (int i = 0; i < 14; i++) {
        output[i] = EncryptedCreds[i] ^ XorKeys[i];
    }
    output[14] = 0;
}

//=============================================================================
// Pattern 5: NOT-based obfuscation (~char)
//=============================================================================

NOINLINE OPTNONE
void build_string_with_not(char *buffer) {
    // Obfuscators sometimes use NOT instead of XOR
    // ~0x97 = 'h', ~0x96 = 'i', etc.
    buffer[0] = ~0x97;  // 'h'
    buffer[1] = ~0x96;  // 'i'
    buffer[2] = ~0x9B;  // 'd'
    buffer[3] = ~0x9B;  // 'd'
    buffer[4] = ~0x9A;  // 'e'
    buffer[5] = ~0x91;  // 'n'
    buffer[6] = 0;
}

//=============================================================================
// Pattern 6: Simulated AES decryption pattern
//=============================================================================

// Mock CCCrypt-like function
int mock_CCCrypt(int op, int alg, int options,
                 const void *key, size_t keyLength,
                 const void *iv,
                 const void *dataIn, size_t dataInLength,
                 void *dataOut, size_t dataOutAvailable,
                 size_t *dataOutMoved) {
    // Just copy for simulation
    if (dataOutMoved) *dataOutMoved = dataInLength;
    memcpy(dataOut, dataIn, dataInLength < dataOutAvailable ? dataInLength : dataOutAvailable);
    return 0;
}

#define kCCDecrypt 1
#define kCCAlgorithmAES128 0
#define kCCOptionPKCS7Padding 1

NOINLINE OPTNONE
void decrypt_aes_data(const unsigned char *encrypted, size_t len, char *output) {
    char key[16];
    char iv[16];
    size_t decrypted_len = 0;
    
    // Key setup pattern - this is what we want to detect
    memcpy(key, "9QxK3vPf2sL8tW0r", 16);  // AES-128 key
    memcpy(iv, "0123456789ABCDEF", 16);   // IV
    
    // CCCrypt call pattern
    mock_CCCrypt(kCCDecrypt,           // operation
                 kCCAlgorithmAES128,    // algorithm
                 kCCOptionPKCS7Padding, // options
                 key, 16,               // key, keyLength
                 iv,                    // iv
                 encrypted, len,        // input
                 output, 256,           // output
                 &decrypted_len);
}

//=============================================================================
// Pattern 7: Objective-C style CFSTR (simulated)
//=============================================================================

typedef struct {
    void *isa;
    int flags;
    const char *str;
    long length;
} CFStringStruct;

// Encrypted CFSTR-like string
static const char cfstr_encrypted[] = "\xF2\x0B\xCF\xB6\xBA";  // Encrypted "data" + null
static char cfstr_decrypted[8];

NOINLINE OPTNONE
const char* get_cfstr_decrypted(void) {
    // XOR decrypt (key = 0x96 for this example)
    // 'data' = 0x64, 0x61, 0x74, 0x61
    // encrypted: 0x64^0x96=0xF2, 0x61^0x96=0xF7... (simplified)
    for (int i = 0; i < 4; i++) {
        cfstr_decrypted[i] = cfstr_encrypted[i] ^ 0x96;
    }
    cfstr_decrypted[4] = 0;
    return cfstr_decrypted;
}

//=============================================================================
// Pattern 8: Base64-like encoded string with decode
//=============================================================================

static const char base64_encoded[] = "SGVsbG9Xb3JsZA==";  // "HelloWorld" in base64

NOINLINE OPTNONE
void decode_base64_string(char *output) {
    // Simplified - just copy for pattern demonstration
    // In real code, this would be actual base64 decode
    strcpy(output, "HelloWorld");
}

//=============================================================================
// Main - exercise all patterns
//=============================================================================

int main(int argc, char **argv) {
    char buffer[256];
    
    printf("Testing string obfuscation patterns for Chernobog\n");
    printf("=================================================\n\n");
    
    // Pattern 1: Hikari XOR
    printf("Pattern 1 (Hikari XOR): %s\n", get_secret_password());
    
    // Pattern 2: Character-by-character
    build_api_url(buffer);
    printf("Pattern 2 (Char-by-char): %s\n", buffer);
    
    // Pattern 3: strcpy reveal
    decrypt_and_copy_key();
    printf("Pattern 3 (strcpy reveal): %s\n", g_decrypted_key);
    
    // Pattern 4: memcpy reveal
    copy_with_memcpy();
    printf("Pattern 4 (memcpy reveal): done\n");
    
    // Pattern 5: Variable XOR keys
    decrypt_with_keystream(buffer);
    printf("Pattern 5 (Keystream XOR): %s\n", buffer);
    
    // Pattern 6: NOT-based
    build_string_with_not(buffer);
    printf("Pattern 6 (NOT-based): %s\n", buffer);
    
    // Pattern 7: Mock AES
    unsigned char fake_encrypted[32] = {0};
    decrypt_aes_data(fake_encrypted, 32, buffer);
    printf("Pattern 7 (AES): decrypted %zu bytes\n", strlen(buffer));
    
    // Pattern 8: CFSTR-like
    printf("Pattern 8 (CFSTR): %s\n", get_cfstr_decrypted());
    
    // Pattern 9: Base64
    decode_base64_string(buffer);
    printf("Pattern 9 (Base64): %s\n", buffer);
    
    return 0;
}

```

`tests/test_components.sh`:

```sh
#!/bin/bash
#
# Component-Level Tests for Chernobog
# ====================================
# Tests each D810-NG ported feature individually
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
IDUMP="${IDUMP:-/home/null/local/bin/idump}"
TEST_BINARY="$PROJECT_DIR/fake_hikari"
RESULTS_DIR="$SCRIPT_DIR/results/components"

mkdir -p "$RESULTS_DIR"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0

log_test() {
    local result="$1"
    local name="$2"
    local details="$3"

    ((TOTAL_TESTS++))
    if [[ "$result" == "PASS" ]]; then
        echo -e "${GREEN}[PASS]${NC} $name"
        ((PASSED_TESTS++))
    elif [[ "$result" == "FAIL" ]]; then
        echo -e "${RED}[FAIL]${NC} $name"
        [[ -n "$details" ]] && echo -e "       ${YELLOW}$details${NC}"
        ((FAILED_TESTS++))
    else
        echo -e "${YELLOW}[SKIP]${NC} $name"
    fi
}

run_idump() {
    local args="$1"
    local timeout_sec="${2:-120}"

    CHERNOBOG_RESET=1 CHERNOBOG_DEBUG=1 CHERNOBOG_AUTO=1 \
        timeout "$timeout_sec" "$IDUMP" $args "$TEST_BINARY" 2>&1
}

# ==============================================================================
# 1. AST System Tests
# ==============================================================================
test_ast_system() {
    echo -e "\n${MAGENTA}╔════════════════════════════════════════╗${NC}"
    echo -e "${MAGENTA}║ 1. AST System Tests                    ║${NC}"
    echo -e "${MAGENTA}╚════════════════════════════════════════╝${NC}"

    # AST is internal - test via successful microcode translation
    local output
    output=$(run_idump "--mc -a 0x12E9" 60)

    # Check microcode was generated (means AST worked)
    if echo "$output" | grep -q "m_mov\|m_add\|m_xor"; then
        log_test "PASS" "AST: Microcode translation works"
    else
        log_test "FAIL" "AST: Microcode translation failed"
    fi

    # Test larger function AST
    output=$(run_idump "--mc -a 0x207C" 120)
    local insn_count=$(echo "$output" | grep -c "^[0-9]" || true)

    if [[ $insn_count -gt 50 ]]; then
        log_test "PASS" "AST: Large function processed ($insn_count instructions)"
    else
        log_test "FAIL" "AST: Large function had too few instructions ($insn_count)"
    fi
}

# ==============================================================================
# 2. Pattern Matching Tests
# ==============================================================================
test_pattern_matching() {
    echo -e "\n${MAGENTA}╔════════════════════════════════════════╗${NC}"
    echo -e "${MAGENTA}║ 2. Pattern Matching Tests              ║${NC}"
    echo -e "${MAGENTA}╚════════════════════════════════════════╝${NC}"

    # Pattern matching is tested via rule application
    local output

    # Test MBA pattern: (a ^ b) + 2 * (a & b) = a + b
    # mba_add at 0x12E9
    output=$(run_idump "--pseudo -a 0x12E9" 60)

    if echo "$output" | grep -q "return"; then
        log_test "PASS" "Pattern Matching: mba_add pattern recognized"
    else
        log_test "FAIL" "Pattern Matching: mba_add pattern not recognized"
    fi

    # Test XOR patterns
    output=$(run_idump "--mc -a 0x1352" 60)
    if echo "$output" | grep -q "xor\|m_xor"; then
        log_test "PASS" "Pattern Matching: XOR patterns found"
    else
        log_test "FAIL" "Pattern Matching: XOR patterns not found"
    fi
}

# ==============================================================================
# 3. MBA Rule Tests
# ==============================================================================
test_mba_rules() {
    echo -e "\n${MAGENTA}╔════════════════════════════════════════╗${NC}"
    echo -e "${MAGENTA}║ 3. MBA Rule Tests                      ║${NC}"
    echo -e "${MAGENTA}╚════════════════════════════════════════╝${NC}"

    local output

    # Test Addition rules: (a ^ b) + 2 * (a & b) = a + b
    output=$(run_idump "--pseudo -a 0x12E9" 60)
    if echo "$output" | grep -q "return"; then
        log_test "PASS" "MBA Add Rules: Function decompiles"
    else
        log_test "FAIL" "MBA Add Rules: Function failed"
    fi

    # Test Subtraction rules: (a ^ b) - 2 * (~a & b) = a - b
    output=$(run_idump "--pseudo -a 0x1307" 60)
    if echo "$output" | grep -q "return"; then
        log_test "PASS" "MBA Sub Rules: Function decompiles"
    else
        log_test "FAIL" "MBA Sub Rules: Function failed"
    fi

    # Test XOR rules: x ^ x = 0
    output=$(run_idump "--pseudo -a 0x1352" 60)
    if echo "$output" | grep -q "return"; then
        log_test "PASS" "MBA XOR Rules: mba_zero decompiles"
    else
        log_test "FAIL" "MBA XOR Rules: mba_zero failed"
    fi

    # Test AND rules
    output=$(run_idump "--mc -a 0x1352" 60)
    local and_count=$(echo "$output" | grep -c "m_and\|and " || true)
    log_test "PASS" "MBA AND Rules: Found $and_count AND operations"

    # Test OR rules
    output=$(run_idump "--mc -a 0x13C2" 60)
    local or_count=$(echo "$output" | grep -c "m_or\|or " || true)
    log_test "PASS" "MBA OR Rules: Found $or_count OR operations"
}

# ==============================================================================
# 4. Predicate Rule Tests
# ==============================================================================
test_predicate_rules() {
    echo -e "\n${MAGENTA}╔════════════════════════════════════════╗${NC}"
    echo -e "${MAGENTA}║ 4. Predicate Rule Tests                ║${NC}"
    echo -e "${MAGENTA}╚════════════════════════════════════════╝${NC}"

    local output

    # Test self-comparison rules: x == x, x < x, etc.
    output=$(run_idump "--mc -a 0x1352" 60)

    # Count set* instructions
    local setz_count=$(echo "$output" | grep -c "setz\|m_setz" || true)
    local setnz_count=$(echo "$output" | grep -c "setnz\|m_setnz" || true)

    log_test "PASS" "Predicate: Found $setz_count setz, $setnz_count setnz"

    # Test on wrapper function with opaque predicates
    output=$(run_idump "--pseudo -a 0x143C" 60)
    if echo "$output" | grep -q "return\|if"; then
        log_test "PASS" "Predicate: Opaque predicate function decompiles"
    else
        log_test "FAIL" "Predicate: Opaque predicate function failed"
    fi
}

# ==============================================================================
# 5. Chain Simplifier Tests
# ==============================================================================
test_chain_simplifier() {
    echo -e "\n${MAGENTA}╔════════════════════════════════════════╗${NC}"
    echo -e "${MAGENTA}║ 5. Chain Simplifier Tests              ║${NC}"
    echo -e "${MAGENTA}╚════════════════════════════════════════╝${NC}"

    local output

    # Test XOR chains in decrypt function
    output=$(run_idump "--mc -a 0x16FD" 60)
    local xor_count=$(echo "$output" | grep -c "xor" || true)

    log_test "PASS" "Chain: XOR chain with $xor_count operations"

    # Test ADD chains
    output=$(run_idump "--mc -a 0x12E9" 60)
    local add_count=$(echo "$output" | grep -c "add\|m_add" || true)

    log_test "PASS" "Chain: ADD chain with $add_count operations"

    # Verify chain simplification via decompilation
    output=$(run_idump "--pseudo -a 0x16FD" 60)
    if echo "$output" | grep -q "return"; then
        log_test "PASS" "Chain: Decrypt function simplified"
    else
        log_test "FAIL" "Chain: Decrypt function not simplified"
    fi
}

# ==============================================================================
# 6. Peephole Optimizer Tests
# ==============================================================================
test_peephole() {
    echo -e "\n${MAGENTA}╔════════════════════════════════════════╗${NC}"
    echo -e "${MAGENTA}║ 6. Peephole Optimizer Tests            ║${NC}"
    echo -e "${MAGENTA}╚════════════════════════════════════════╝${NC}"

    local output

    # Test on small functions (wrappers)
    output=$(run_idump "--pseudo -a 0x1329" 60)
    if echo "$output" | grep -q "return"; then
        log_test "PASS" "Peephole: Small function optimized"
    else
        log_test "FAIL" "Peephole: Small function failed"
    fi

    # Test dead code elimination
    output=$(run_idump "--pseudo -a 0x1337" 60)
    local line_count=$(echo "$output" | grep -c "^" || true)

    log_test "PASS" "Peephole: Function produced $line_count lines"
}

# ==============================================================================
# 7. Jump Optimizer Tests
# ==============================================================================
test_jump_optimizer() {
    echo -e "\n${MAGENTA}╔════════════════════════════════════════╗${NC}"
    echo -e "${MAGENTA}║ 7. Jump Optimizer Tests                ║${NC}"
    echo -e "${MAGENTA}╚════════════════════════════════════════╝${NC}"

    local output

    # Test on function with many conditional jumps
    output=$(run_idump "--mc -a 0x1576" 60)

    local jcnd_before=$(echo "$output" | grep -c "jcnd\|jnz\|jz" || true)
    log_test "PASS" "Jump: Found $jcnd_before conditional jumps"

    # Decompile and check if structure is simplified
    output=$(run_idump "--pseudo -a 0x1576" 60)

    if echo "$output" | grep -q "if\|return"; then
        log_test "PASS" "Jump: Conditional structure preserved/simplified"
    else
        log_test "FAIL" "Jump: Conditional structure lost"
    fi
}

# ==============================================================================
# 8. Unflattener Tests
# ==============================================================================
test_unflatteners() {
    echo -e "\n${MAGENTA}╔════════════════════════════════════════╗${NC}"
    echo -e "${MAGENTA}║ 8. Unflattener Tests                   ║${NC}"
    echo -e "${MAGENTA}╚════════════════════════════════════════╝${NC}"

    local output

    # 8.1 HikariUnflattener (priority 80)
    echo -e "${CYAN}8.1 HikariUnflattener${NC}"
    output=$(run_idump "--pseudo -a 0x207C" 120)
    if echo "$output" | grep -q "return"; then
        log_test "PASS" "HikariUnflattener: Main function decompiles"
    else
        log_test "FAIL" "HikariUnflattener: Main function failed"
    fi

    # 8.2 FakeJumpUnflattener (priority 85)
    echo -e "${CYAN}8.2 FakeJumpUnflattener${NC}"
    output=$(run_idump "--pseudo -a 0x143C" 60)
    if echo "$output" | grep -q "return\|printf\|print"; then
        log_test "PASS" "FakeJumpUnflattener: Wrapper function simplified"
    else
        log_test "FAIL" "FakeJumpUnflattener: Wrapper function not simplified"
    fi

    # 8.3 BadWhileLoopUnflattener (priority 75)
    echo -e "${CYAN}8.3 BadWhileLoopUnflattener${NC}"
    output=$(run_idump "--pseudo -a 0x16FD" 60)
    # while(1) loops should be converted to proper structure
    if echo "$output" | grep -q "return\|while\|for"; then
        log_test "PASS" "BadWhileLoopUnflattener: Loop structure handled"
    else
        log_test "FAIL" "BadWhileLoopUnflattener: Loop structure lost"
    fi

    # 8.4 OLLVMUnflattener (priority 70)
    echo -e "${CYAN}8.4 OLLVMUnflattener${NC}"
    output=$(run_idump "--pseudo -a 0x1CC9" 120)
    if echo "$output" | grep -q "return"; then
        log_test "PASS" "OLLVMUnflattener: loadConfig decompiles"
    else
        log_test "FAIL" "OLLVMUnflattener: loadConfig failed"
    fi

    # 8.5 JumpTableUnflattener (priority 60)
    echo -e "${CYAN}8.5 JumpTableUnflattener${NC}"
    output=$(run_idump "--mc -a 0x207C" 120)
    # Look for switch/jump table patterns
    local switch_count=$(echo "$output" | grep -c "jtbl\|switch" || true)
    log_test "PASS" "JumpTableUnflattener: Found $switch_count jump table refs"

    # 8.6 SwitchCaseUnflattener (priority 55)
    echo -e "${CYAN}8.6 SwitchCaseUnflattener${NC}"
    output=$(run_idump "--pseudo -a 0x1DB1" 120)
    if echo "$output" | grep -q "return"; then
        log_test "PASS" "SwitchCaseUnflattener: checkNetwork decompiles"
    else
        log_test "FAIL" "SwitchCaseUnflattener: checkNetwork failed"
    fi

    # 8.7 GenericUnflattener (priority 30)
    echo -e "${CYAN}8.7 GenericUnflattener${NC}"
    output=$(run_idump "--pseudo -a 0x2458" 120)
    if echo "$output" | grep -q "return"; then
        log_test "PASS" "GenericUnflattener: checksum decompiles"
    else
        log_test "FAIL" "GenericUnflattener: checksum failed"
    fi
}

# ==============================================================================
# 9. Integration Tests
# ==============================================================================
test_integration() {
    echo -e "\n${MAGENTA}╔════════════════════════════════════════╗${NC}"
    echo -e "${MAGENTA}║ 9. Integration Tests                   ║${NC}"
    echo -e "${MAGENTA}╚════════════════════════════════════════╝${NC}"

    local output

    # Full binary decompilation
    echo "Running full binary decompilation (this may take a while)..."
    output=$(run_idump "--pseudo" 300)
    local exit_code=$?

    if [[ $exit_code -eq 0 ]]; then
        log_test "PASS" "Integration: Full binary decompiles"
    else
        log_test "FAIL" "Integration: Full binary failed (exit code $exit_code)"
    fi

    # Count decompiled functions
    local func_count=$(echo "$output" | grep -c "^__int64\|^void\|^int\|^unsigned" || true)
    log_test "PASS" "Integration: Decompiled $func_count functions"

    # Check for crashes or errors
    local error_count=$(echo "$output" | grep -ci "error\|crash\|abort\|segfault" || true)
    if [[ $error_count -eq 0 ]]; then
        log_test "PASS" "Integration: No crashes or errors"
    else
        log_test "FAIL" "Integration: Found $error_count error messages"
    fi
}

# ==============================================================================
# Summary
# ==============================================================================
print_summary() {
    echo -e "\n${MAGENTA}╔════════════════════════════════════════╗${NC}"
    echo -e "${MAGENTA}║            TEST SUMMARY                ║${NC}"
    echo -e "${MAGENTA}╚════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "Total Tests:  ${CYAN}$TOTAL_TESTS${NC}"
    echo -e "Passed:       ${GREEN}$PASSED_TESTS${NC}"
    echo -e "Failed:       ${RED}$FAILED_TESTS${NC}"
    echo ""

    local percent=$((PASSED_TESTS * 100 / TOTAL_TESTS))
    if [[ $FAILED_TESTS -eq 0 ]]; then
        echo -e "${GREEN}========================================${NC}"
        echo -e "${GREEN}  ALL TESTS PASSED! ($percent%)${NC}"
        echo -e "${GREEN}========================================${NC}"
    else
        echo -e "${YELLOW}========================================${NC}"
        echo -e "${YELLOW}  $FAILED_TESTS TESTS FAILED ($percent% passed)${NC}"
        echo -e "${YELLOW}========================================${NC}"
    fi
}

# ==============================================================================
# Main
# ==============================================================================
main() {
    echo -e "${BLUE}╔════════════════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║   Chernobog Component Test Suite                   ║${NC}"
    echo -e "${BLUE}║   Testing all D810-NG ported features              ║${NC}"
    echo -e "${BLUE}╚════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo "Date: $(date)"
    echo "Binary: $TEST_BINARY"
    echo ""

    case "${1:-all}" in
        all)
            test_ast_system
            test_pattern_matching
            test_mba_rules
            test_predicate_rules
            test_chain_simplifier
            test_peephole
            test_jump_optimizer
            test_unflatteners
            test_integration
            ;;
        ast)         test_ast_system ;;
        pattern)     test_pattern_matching ;;
        mba)         test_mba_rules ;;
        predicate)   test_predicate_rules ;;
        chain)       test_chain_simplifier ;;
        peephole)    test_peephole ;;
        jump)        test_jump_optimizer ;;
        unflatten)   test_unflatteners ;;
        integration) test_integration ;;
        *)
            echo "Usage: $0 [all|ast|pattern|mba|predicate|chain|peephole|jump|unflatten|integration]"
            exit 1
            ;;
    esac

    print_summary

    [[ $FAILED_TESTS -eq 0 ]]
}

main "$@"

```

`tests/test_individual_functions.sh`:

```sh
#!/bin/bash
#
# Individual Function Tests
# =========================
# Tests specific functions in the fake_hikari binary
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
IDUMP="${IDUMP:-/home/null/local/bin/idump}"
TEST_BINARY="$PROJECT_DIR/fake_hikari"
RESULTS_DIR="$SCRIPT_DIR/results/individual"

mkdir -p "$RESULTS_DIR"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Function addresses from fake_hikari
# Based on the test.c source mapping:
declare -A FUNCTIONS=(
    # MBA functions (small, should simplify)
    ["mba_add"]="0x12E9"
    ["mba_sub"]="0x1307"
    ["mba_mul2"]="0x1329"
    ["mba_eq"]="0x1337"
    ["mba_zero"]="0x1352"
    ["mba_one"]="0x13C2"

    # Wrapper functions (indirect calls)
    ["wrapper_001"]="0x143C"
    ["wrapper_002"]="0x148F"
    ["wrapper_003"]="0x150E"
    ["wrapper_004"]="0x1576"
    ["wrapper_005"]="0x162E"
    ["wrapper_006"]="0x16A5"

    # String operations
    ["decrypt_array"]="0x16FD"
    ["build_string_1"]="0x188B"
    ["build_string_2"]="0x18E2"
    ["build_string_3"]="0x1A40"

    # CFF functions (flattened control flow)
    ["processData"]="0x1C1A"
    ["loadConfig"]="0x1CC9"
    ["checkNetwork"]="0x1DB1"
    ["cleanupSystem"]="0x207C"

    # Utility functions
    ["checksum"]="0x2458"
    ["memcmp"]="0x2731"

    # Main
    ["main"]="0x27E9"
)

run_test() {
    local name="$1"
    local addr="$2"
    local mode="$3"  # pseudo, mc, asm

    echo -e "\n${CYAN}Testing $name @ $addr${NC}"

    local output_file="$RESULTS_DIR/${name}_${mode}.txt"

    CHERNOBOG_RESET=1 CHERNOBOG_DEBUG=1 CHERNOBOG_AUTO=1 \
        timeout 120 "$IDUMP" --${mode} -a "$addr" "$TEST_BINARY" > "$output_file" 2>&1

    local exit_code=$?

    if [[ $exit_code -eq 0 ]]; then
        echo -e "${GREEN}[OK]${NC} $name decompiled successfully"

        # Show summary
        if [[ "$mode" == "pseudo" ]]; then
            local lines=$(grep -c "^" "$output_file" || true)
            local returns=$(grep -c "return" "$output_file" || true)
            echo "  Lines: $lines, Returns: $returns"
        elif [[ "$mode" == "mc" ]]; then
            local insns=$(grep -c "^[0-9]" "$output_file" || true)
            echo "  Microcode instructions: $insns"
        fi
    else
        echo -e "${RED}[FAIL]${NC} $name failed (exit code $exit_code)"
    fi

    return $exit_code
}

test_all_pseudo() {
    echo -e "${BLUE}=== Testing All Functions (Pseudocode) ===${NC}"

    local passed=0
    local failed=0

    for name in "${!FUNCTIONS[@]}"; do
        if run_test "$name" "${FUNCTIONS[$name]}" "pseudo"; then
            ((passed++))
        else
            ((failed++))
        fi
    done

    echo -e "\n${BLUE}Summary:${NC} $passed passed, $failed failed"
}

test_all_microcode() {
    echo -e "${BLUE}=== Testing All Functions (Microcode) ===${NC}"

    local passed=0
    local failed=0

    for name in "${!FUNCTIONS[@]}"; do
        if run_test "$name" "${FUNCTIONS[$name]}" "mc"; then
            ((passed++))
        else
            ((failed++))
        fi
    done

    echo -e "\n${BLUE}Summary:${NC} $passed passed, $failed failed"
}

test_mba_functions() {
    echo -e "${BLUE}=== Testing MBA Functions ===${NC}"

    for name in mba_add mba_sub mba_mul2 mba_eq mba_zero mba_one; do
        run_test "$name" "${FUNCTIONS[$name]}" "pseudo"
        echo "  --- Microcode ---"
        run_test "$name" "${FUNCTIONS[$name]}" "mc"
    done
}

test_cff_functions() {
    echo -e "${BLUE}=== Testing CFF Functions ===${NC}"

    for name in processData loadConfig checkNetwork cleanupSystem; do
        run_test "$name" "${FUNCTIONS[$name]}" "pseudo"
    done
}

test_wrapper_functions() {
    echo -e "${BLUE}=== Testing Wrapper Functions ===${NC}"

    for name in wrapper_001 wrapper_002 wrapper_003 wrapper_004 wrapper_005 wrapper_006; do
        run_test "$name" "${FUNCTIONS[$name]}" "pseudo"
    done
}

compare_before_after() {
    echo -e "${BLUE}=== Comparing Before/After Deobfuscation ===${NC}"

    local addr="$1"
    local name="$2"

    echo "Testing $name @ $addr"

    # Without chernobog (just hex-rays)
    echo "Without chernobog:"
    CHERNOBOG_DISABLE=1 timeout 60 "$IDUMP" -q --pseudo -a "$addr" "$TEST_BINARY" 2>&1 | head -30

    echo ""
    echo "With chernobog:"
    CHERNOBOG_RESET=1 CHERNOBOG_AUTO=1 timeout 120 "$IDUMP" -q --pseudo -a "$addr" "$TEST_BINARY" 2>&1 | head -30
}

case "${1:-all}" in
    all)
        test_all_pseudo
        ;;
    mc)
        test_all_microcode
        ;;
    mba)
        test_mba_functions
        ;;
    cff)
        test_cff_functions
        ;;
    wrapper)
        test_wrapper_functions
        ;;
    compare)
        compare_before_after "${2:-0x207C}" "${3:-cleanupSystem}"
        ;;
    single)
        run_test "$2" "$3" "${4:-pseudo}"
        ;;
    *)
        echo "Usage: $0 [all|mc|mba|cff|wrapper|compare|single]"
        echo "  all     - Test all functions (pseudocode)"
        echo "  mc      - Test all functions (microcode)"
        echo "  mba     - Test MBA simplification functions"
        echo "  cff     - Test control flow flattened functions"
        echo "  wrapper - Test wrapper/indirect call functions"
        echo "  compare - Compare before/after deobfuscation"
        echo "  single <name> <addr> [mode] - Test single function"
        exit 1
        ;;
esac

```