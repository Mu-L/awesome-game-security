Project Path: arc_sonyps5201314_pdb_xz7z0p8o

Source Tree:

```txt
arc_sonyps5201314_pdb_xz7z0p8o
├── Helpers.cpp
├── Helpers.h
├── Program.cpp
├── Program.h
├── README.md
├── common.cpp
├── cvadd.h
├── dia2_internal.h
├── makefile
├── merge.cpp
├── misc.cpp
├── misc.h
├── msdia.cpp
├── msdia.hpp
├── old.cpp
├── oldpdb.h
├── pdb.cfg
├── pdb.cpp
├── pdb.hpp
├── pdb.vcxproj
├── pdb.vcxproj.filters
├── pdb_vs201x.sln
├── pdbaccess.hpp
├── pdblocal.cpp
├── pdblocal.hpp
├── pdbremote.cpp
├── pdbremote.hpp
├── sip.cpp
├── sip.hpp
├── stdafx.cpp
├── stdafx.h
├── targetver.h
├── tilbuild.cpp
├── tilbuild.hpp
└── varser.hpp

```

`Helpers.cpp`:

```cpp
// <copyright file="Helpers.cpp" company="Microsoft Corporation">
// Copyright (C) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt in the project root for license information.
// </copyright>

#include "stdafx.h"

using namespace std;

wostream& operator<<(_In_ wostream& os, _In_ const variant_t& var)
{
    switch (var.vt)
    {
    case VT_BOOL:
        if (VARIANT_FALSE == var.boolVal)
        {
            os << FALSESTRING;
        }
        else
        {
            os << TRUESTRING;
        }

        return os;

    case VT_BSTR:
        os << var.bstrVal;
        return os;

    case VT_I1:
    case VT_I2:
    case VT_I4:
    case VT_I8:
    case VT_UI1:
    case VT_UI2:
    case VT_UI4:
        os << var.llVal;
        return os;

    default:
        throw win32_exception(E_UNEXPECTED, "variant type not supported");
    }
}

```

`Helpers.h`:

```h
// <copyright file="Helpers.h" company="Microsoft Corporation">
// Copyright (C) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt in the project root for license information.
// </copyright>

#pragma once

#define __nameof(x) L#x

#define FALSESTRING L"False"
#define TRUESTRING L"True"

struct ModuleDeleter
{
    void operator()(_In_ HMODULE* phModule)
    {
        if (phModule && *phModule)
        {
            ::FreeLibrary(*phModule);
        }
    }
};

typedef std::unique_ptr<HMODULE, ModuleDeleter> module_ptr;

struct SafeArrayDeleter
{
    void operator()(_In_ LPSAFEARRAY* ppsa)
    {
        if (ppsa && *ppsa)
        {
            if ((*ppsa)->cLocks)
            {
                ::SafeArrayUnlock(*ppsa);
            }

            ::SafeArrayDestroy(*ppsa);
        }
    }
};

typedef std::unique_ptr<LPSAFEARRAY, SafeArrayDeleter> safearray_ptr;

class win32_exception :
    public std::exception
{
public:
    win32_exception(_In_ DWORD code, _In_z_ const char* what) noexcept :
        std::exception(what),
        m_code(code)
    {
    }

    win32_exception(_In_ const win32_exception& obj) noexcept :
        std::exception(obj)
    {
        m_code = obj.m_code;
    }

    DWORD code() const noexcept
    {
        return m_code;
    }

private:
    DWORD m_code;
};

class CoInitializer
{
public:
    CoInitializer()
    {
        hr = ::CoInitialize(nullptr);
        if (FAILED(hr))
        {
            throw win32_exception(hr, "failed to initialize COM");
        }
    }

    ~CoInitializer()
    {
        if (SUCCEEDED(hr))
        {
            ::CoUninitialize();
        }
    }

private:
    HRESULT hr;
};

std::wostream& operator<<(_In_ std::wostream& os, _In_ const variant_t& var);

```

`Program.cpp`:

```cpp
// <copyright file="Program.cpp" company="Microsoft Corporation">
// Copyright (C) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt in the project root for license information.
// </copyright>

#include "stdafx.h"

using namespace std;

// Use smart pointers (without ATL) to release objects when they fall out of scope.
_COM_SMARTPTR_TYPEDEF(ISetupInstance, __uuidof(ISetupInstance));
_COM_SMARTPTR_TYPEDEF(ISetupInstance2, __uuidof(ISetupInstance2));
_COM_SMARTPTR_TYPEDEF(IEnumSetupInstances, __uuidof(IEnumSetupInstances));
_COM_SMARTPTR_TYPEDEF(ISetupConfiguration, __uuidof(ISetupConfiguration));
_COM_SMARTPTR_TYPEDEF(ISetupConfiguration2, __uuidof(ISetupConfiguration2));
_COM_SMARTPTR_TYPEDEF(ISetupHelper, __uuidof(ISetupHelper));
_COM_SMARTPTR_TYPEDEF(ISetupPackageReference, __uuidof(ISetupPackageReference));
_COM_SMARTPTR_TYPEDEF(ISetupPropertyStore, __uuidof(ISetupPropertyStore));
_COM_SMARTPTR_TYPEDEF(ISetupInstanceCatalog, __uuidof(ISetupInstanceCatalog));

void PrintInstance(
    _In_ ISetupInstance* pInstance,
	_In_ ISetupHelper* pHelper,
	bstr_t& MaxVsInstanceVersion
);

//void PrintPackageReference(
//    _In_ ISetupPackageReference* pPackage
//);
//
//void PrintProperties(
//    _In_ ISetupPropertyStore* pStore
//);

BOOL FindVcInWorkloads(
    _In_ LPSAFEARRAY psaPackages
);

HRESULT GetMaxVersionVsInstallationPath(bstr_t& bstrVsInstallationPath, ULONGLONG& ullVersion)
{
    try
    {
        CoInitializer init;
        ISetupConfigurationPtr query;

		std::vector<ISetupInstancePtr> SetupInstances;
        bstr_t MaxVsInstanceVersion;

        auto hr = query.CreateInstance(__uuidof(SetupConfiguration));
        if (REGDB_E_CLASSNOTREG == hr)
        {
            cout << "The query API is not registered. Assuming no instances are installed." << endl;
            return hr;
        }
        else if (FAILED(hr))
        {
            throw win32_exception(hr, "failed to create query class");
        }

        ISetupConfiguration2Ptr query2(query);
        IEnumSetupInstancesPtr e;

        hr = query2->EnumAllInstances(&e);
        if (FAILED(hr))
        {
            throw win32_exception(hr, "failed to query all instances");
        }

        ISetupHelperPtr helper(query);

        ISetupInstance* pInstances[1] = {};
        hr = e->Next(1, pInstances, nullptr);
        while (S_OK == hr)
        {
            // Wrap instance without AddRef'ing.
            ISetupInstancePtr instance(pInstances[0], false);
            PrintInstance(instance, helper, MaxVsInstanceVersion);
			SetupInstances.push_back(instance);

            hr = e->Next(1, pInstances, nullptr);
        }

        if (FAILED(hr))
        {
            throw win32_exception(hr, "failed to enumerate all instances");
        }

		for (auto instance : SetupInstances)
		{
			HRESULT hr;
			bstr_t bstrVersion;
			if (FAILED(hr = instance->GetInstallationVersion(bstrVersion.GetAddress())))
			{
				throw win32_exception(hr, "failed to get InstallationVersion");
			}
			if (!wcscmp(bstrVersion, MaxVsInstanceVersion))
			{
				if (FAILED(hr = helper->ParseVersion(bstrVersion, &ullVersion)))
				{
					throw win32_exception(hr, "failed to parse InstallationVersion");
				}

				bstr_t bstrInstallationPath;
				if (FAILED(hr = instance->GetInstallationPath(bstrInstallationPath.GetAddress())))
				{
					throw win32_exception(hr, "failed to get InstallationPath");
				}

				//wcout << L"Max Vs InstallationPath: " << bstrInstallationPath << endl;
				bstrVsInstallationPath = bstrInstallationPath;
			}
		}
		SetupInstances.clear();
    }
    catch (win32_exception& ex)
    {
        cerr << hex << "Error 0x" << ex.code() << ": " << ex.what() << endl;
        return ex.code();
    }
    catch (exception& ex)
    {
        cerr << "Error: " << ex.what() << endl;
        return E_FAIL;
    }

    return ERROR_SUCCESS;
}

void PrintInstance(
    _In_ ISetupInstance* pInstance,
    _In_ ISetupHelper* pHelper,
    bstr_t& MaxVsInstanceVersion
)
{
    HRESULT hr = S_OK;
    ISetupInstance2Ptr instance(pInstance);

    bstr_t bstrId;
    if (FAILED(hr = instance->GetInstanceId(bstrId.GetAddress())))
    {
        throw win32_exception(hr, "failed to get InstanceId");
    }

    InstanceState state;
    if (FAILED(hr = instance->GetState(&state)))
    {
        throw win32_exception(hr, "failed to get State");
    }

    //wcout << L"InstanceId: " << bstrId << L" (" << (eComplete == state ? L"Complete" : L"Incomplete") << L")" << endl;

    bstr_t bstrVersion;
    if (FAILED(hr = instance->GetInstallationVersion(bstrVersion.GetAddress())))
    {
        throw win32_exception(hr, "failed to get InstallationVersion");
    }

    //ULONGLONG ullVersion;
    //if (FAILED(hr = pHelper->ParseVersion(bstrVersion, &ullVersion)))
    //{
    //    throw win32_exception(hr, "failed to parse InstallationVersion");
    //}

    //wcout << L"InstallationVersion: " << bstrVersion << L" (" << ullVersion << L")" << endl;

    // Reboot may have been required before the installation path was created.
    //if ((eLocal & state) == eLocal)
    //{
    //    bstr_t bstrInstallationPath;
    //    if (FAILED(hr = instance->GetInstallationPath(bstrInstallationPath.GetAddress())))
    //    {
    //        throw win32_exception(hr, "failed to get InstallationPath");
    //    }

    //    wcout << L"InstallationPath: " << bstrInstallationPath << endl;
    //}

    ISetupInstanceCatalogPtr catalog;
    if (SUCCEEDED(instance->QueryInterface(&catalog)))
    {
        VARIANT_BOOL fIsPrerelease;
        if (FAILED(hr = catalog->IsPrerelease(&fIsPrerelease)))
        {
            throw win32_exception(hr, "failed to get IsPrerelease");
        }

        const auto wzIsPrerelease = VARIANT_FALSE == fIsPrerelease ? FALSESTRING : TRUESTRING;
        //wcout << L"IsPrerelease: " << wzIsPrerelease << endl;
    }

    // Reboot may have been required before the product package was registered (last).
    if ((eRegistered & state) == eRegistered)
    {
        ISetupPackageReferencePtr product;
        if (FAILED(hr = instance->GetProduct(&product)))
        {
            throw win32_exception(hr, "failed to get Product");
        }

        //wcout << L"Product: ";
        //PrintPackageReference(product);

        //wcout << endl;

        LPSAFEARRAY psa = nullptr;
        if (FAILED(hr = instance->GetPackages(&psa)))
        {
            throw win32_exception(hr, "failed to get Packages");
        }

        // Make sure the SAFEARRAY is freed when it falls out of scope.
        safearray_ptr psa_ptr(&psa);

        //wcout << L"Workloads:" << endl;
		BOOL bFind = FindVcInWorkloads(psa);
		if (bFind)
		{
			if (MaxVsInstanceVersion.length() == 0)
			{
				MaxVsInstanceVersion = bstrVersion;
			}
			else if (CompareFileVersion(bstrVersion, MaxVsInstanceVersion) > 0)
			{
				MaxVsInstanceVersion = bstrVersion;
			}
		}
    }

    //ISetupPropertyStorePtr properties;
    //if (SUCCEEDED(instance->GetProperties(&properties)) && properties)
    //{
    //    wcout << L"Custom properties:" << endl;
    //    PrintProperties(properties);
    //}

    //if (catalog && SUCCEEDED(catalog->GetCatalogInfo(&properties)) && properties)
    //{
    //    wcout << L"Catalog properties:" << endl;
    //    PrintProperties(properties);
    //}

    //wcout << endl;
}

BOOL FindPackageReference(
    _In_ ISetupPackageReference* pPackage, LPOLESTR pszId
)
{
	BOOL bFind = FALSE;

    HRESULT hr = S_OK;
    ISetupPackageReferencePtr ref(pPackage);
    
    bstr_t bstrId;
    if (FAILED(hr = ref->GetId(bstrId.GetAddress())))
    {
        throw win32_exception(hr, "failed to get reference Id");
    }

    // Check that an ID is registered; unexpected otherwise, but would throw in RCW.
    if (!!bstrId)
    {
        //wcout << bstrId;
		if (!wcscmp(bstrId, pszId))
		{
			bFind = TRUE;
		}
    }

	return bFind;
}

void PrintProperties(
    _In_ ISetupPropertyStore* pStore
)
{
    HRESULT hr = S_OK;
    LPSAFEARRAY psaNames = nullptr;

    if (FAILED(hr = pStore->GetNames(&psaNames)))
    {
        throw win32_exception(hr, "failed to get property names");
    }

    // Make sure the SAFEARRAY is freed when it falls out of scope.
    safearray_ptr psaNames_ptr(&psaNames);

    // Lock the SAFEARRAY to get the raw pointer array.
    if (FAILED(hr = ::SafeArrayLock(psaNames)))
    {
        throw win32_exception(hr, "failed to lock property name array");
    }

    auto rgpNames = reinterpret_cast<BSTR*>(psaNames->pvData);
    auto cNames = psaNames->rgsabound[0].cElements;

    if (0 == cNames)
    {
        return;
    }

    vector<BSTR> names(rgpNames, rgpNames + cNames);
    sort(names.begin(), names.end(), [&](const BSTR bstrA, const BSTR bstrB) -> bool
    {
        return 0 > _wcsicmp((LPCWSTR)bstrA, (LPCWSTR)bstrB);
    });

    for_each(names.begin(), names.end(), [&](const BSTR bstrName)
    {
        variant_t var;
        if (FAILED(hr = pStore->GetValue((LPCWSTR)bstrName, &var)))
        {
            throw win32_exception(hr, "failed to get property value");
        }

        wcout << L"    " << bstrName << L": " << var << endl;
    });

    // SafeArrayDeleter will unlock if exception thrown.
    ::SafeArrayUnlock(psaNames);
}

BOOL FindVcInWorkloads(
    _In_ LPSAFEARRAY psaPackages
)
{
    // Lock the SAFEARRAY to get the raw pointer array.
    auto hr = ::SafeArrayLock(psaPackages);
    if (FAILED(hr))
    {
        throw win32_exception(hr, "failed to lock package arrays");
    }

    auto rgpPackages = reinterpret_cast<ISetupPackageReference**>(psaPackages->pvData);
    auto cPackages = psaPackages->rgsabound[0].cElements;

    if (0 == cPackages)
    {
        return FALSE;
    }

    vector<ISetupPackageReference*> packages(rgpPackages, rgpPackages + cPackages);

    const WCHAR wzType[] = L"Workload";
    const size_t cchType = sizeof(wzType) / sizeof(WCHAR) - 1;

    // Find all the workload package types.
    vector<ISetupPackageReference*> workloads;
    for (auto pPackage : packages)
    {
        bstr_t bstrType;

        if (SUCCEEDED(hr = pPackage->GetType(bstrType.GetAddress())))
        {
            if (cchType == bstrType.length() && 0 == _wcsnicmp(wzType, bstrType, cchType))
            {
                workloads.push_back(pPackage);
            }
        }
    }

    //sort(workloads.begin(), workloads.end(), [&](ISetupPackageReference* pA, ISetupPackageReference* pB) -> bool
    //{
    //    bstr_t bstrA;
    //    bstr_t bstrB;

    //    if (SUCCEEDED(hr = pA->GetId(bstrA.GetAddress())))
    //    {
    //        if (SUCCEEDED(hr = pB->GetId(bstrB.GetAddress())))
    //        {
    //            return 0 > _wcsicmp(bstrA, bstrB);
    //        }
    //    }

    //    return 0 > _wcsicmp(__nameof(bstrA), __nameof(bstrB));
    //});

	BOOL bFind = FALSE;
    for(ISetupPackageReference* pWorkload: workloads)
    {
        //wcout << L"    ";
        bFind = FindPackageReference(pWorkload, L"Microsoft.VisualStudio.Workload.NativeDesktop");
		if (bFind)
		{
			break;
		}

        //wcout << endl;
    }

    // SafeArrayDeleter will unlock if exception thrown.
    ::SafeArrayUnlock(psaPackages);

	return bFind;
}

```

`Program.h`:

```h
#pragma once

//代码修改自https://github.com/microsoft/vs-setup-samples

HRESULT GetMaxVersionVsInstallationPath(bstr_t& bstrVsInstallationPath, ULONGLONG& ullVersion);
```

`README.md`:

```md
# pdb
ida pdb plugin with enhance and bugfix

```

`common.cpp`:

```cpp

#include "pdbaccess.hpp"

//----------------------------------------------------------------------------
static const char g_spath_prefix[] = "srv*";
static const char g_spath_suffix[] = "*http://msdl.microsoft.com/download/symbols";

//----------------------------------------------------------------------------
HRESULT pdb_access_t::iterate_subtags(
        pdb_sym_t &sym,
        enum SymTagEnum type,
        children_visitor_t &visitor)
{
  struct subtag_helper_t : children_visitor_t
  {
    pdb_access_t *tb;
    enum SymTagEnum type;
    children_visitor_t &visitor;
    virtual HRESULT visit_child(pdb_sym_t &_sym) override
    {
      return tb->iterate_children(_sym, type, visitor);
    }
    subtag_helper_t(pdb_access_t *_tb, enum SymTagEnum t, children_visitor_t &_visitor)
      : tb(_tb),
        type(t),
        visitor(_visitor) {}
  };
  subtag_helper_t helper(this, type, visitor);
  return iterate_children(sym, SymTagCompiland, helper);
}

//----------------------------------------------------------------------------
HRESULT pdb_access_t::iterate_children(
        pdb_sym_t &sym,
        enum SymTagEnum type,
        children_visitor_t &visitor)
{
  visitor.parent = &sym;
  return do_iterate_children(sym, type, visitor);
}

//----------------------------------------------------------------------
void print_pdb_register(qstring *out, int machine, int reg)
{
  // Register subset shared by all processor types,
  switch ( reg )
  {
    case CV_ALLREG_ERR:    *out = "[*err*]"; return;
    case CV_ALLREG_TEB:    *out = "[*teb*]"; return;
    case CV_ALLREG_TIMER:  *out = "[*timer*]"; return;
    case CV_ALLREG_EFAD1:  *out = "[*efad1*]"; return;
    case CV_ALLREG_EFAD2:  *out = "[*efad2*]"; return;
    case CV_ALLREG_EFAD3:  *out = "[*efad3*]"; return;
    case CV_ALLREG_VFRAME: *out = "[*vframe*]"; return;
    case CV_ALLREG_HANDLE: *out = "[*handle*]"; return;
    case CV_ALLREG_PARAMS: *out = "[*params*]"; return;
    case CV_ALLREG_LOCALS: *out = "[*locals*]"; return;
    case CV_ALLREG_TID:    *out = "[*tid*]"; return;
    case CV_ALLREG_ENV:    *out = "[*env*]"; return;
    case CV_ALLREG_CMDLN:  *out = "[*cmdln*]"; return;
  }

  // Processor specific subsets
  switch ( machine )
  {
    case CV_CFL_8080:
    case CV_CFL_8086:
    case CV_CFL_80286:
    case CV_CFL_80386:
    case CV_CFL_80486:
    case CV_CFL_PENTIUM:
    case CV_CFL_PENTIUMII:
    case CV_CFL_PENTIUMIII:
      //  Register set for the Intel 80x86 and ix86 processor series
      //  (plus PCODE registers)
      switch ( reg )
      {
        case CV_REG_NONE:    *out = "none"; return;
        case CV_REG_AL:      *out = "al"; return;
        case CV_REG_CL:      *out = "cl"; return;
        case CV_REG_DL:      *out = "dl"; return;
        case CV_REG_BL:      *out = "bl"; return;
        case CV_REG_AH:      *out = "ah"; return;
        case CV_REG_CH:      *out = "ch"; return;
        case CV_REG_DH:      *out = "dh"; return;
        case CV_REG_BH:      *out = "bh"; return;
        case CV_REG_AX:      *out = "ax"; return;
        case CV_REG_CX:      *out = "cx"; return;
        case CV_REG_DX:      *out = "dx"; return;
        case CV_REG_BX:      *out = "bx"; return;
        case CV_REG_SP:      *out = "sp"; return;
        case CV_REG_BP:      *out = "bp"; return;
        case CV_REG_SI:      *out = "si"; return;
        case CV_REG_DI:      *out = "di"; return;
        case CV_REG_EAX:     *out = "eax"; return;
        case CV_REG_ECX:     *out = "ecx"; return;
        case CV_REG_EDX:     *out = "edx"; return;
        case CV_REG_EBX:     *out = "ebx"; return;
        case CV_REG_ESP:     *out = "esp"; return;
        case CV_REG_EBP:     *out = "ebp"; return;
        case CV_REG_ESI:     *out = "esi"; return;
        case CV_REG_EDI:     *out = "edi"; return;
        case CV_REG_ES:      *out = "es"; return;
        case CV_REG_CS:      *out = "cs"; return;
        case CV_REG_SS:      *out = "ss"; return;
        case CV_REG_DS:      *out = "ds"; return;
        case CV_REG_FS:      *out = "fs"; return;
        case CV_REG_GS:      *out = "gs"; return;
        case CV_REG_IP:      *out = "ip"; return;
        case CV_REG_FLAGS:   *out = "flags"; return;
        case CV_REG_EIP:     *out = "eip"; return;
        case CV_REG_EFLAGS:  *out = "eflags"; return;
        case CV_REG_TEMP:    *out = "temp"; return;          // PCODE Temp return;
        case CV_REG_TEMPH:   *out = "temph"; return;         // PCODE TempH return;
        case CV_REG_QUOTE:   *out = "quote"; return;         // PCODE Quote return;
        case CV_REG_PCDR3:   *out = "pcdr3"; return;         // PCODE reserved return;
        case CV_REG_PCDR4:   *out = "pcdr4"; return;         // PCODE reserved return;
        case CV_REG_PCDR5:   *out = "pcdr5"; return;         // PCODE reserved return;
        case CV_REG_PCDR6:   *out = "pcdr6"; return;         // PCODE reserved return;
        case CV_REG_PCDR7:   *out = "pcdr7"; return;         // PCODE reserved return;
        case CV_REG_CR0:     *out = "cr0"; return;           // CR0 -- control registers return;
        case CV_REG_CR1:     *out = "cr1"; return;
        case CV_REG_CR2:     *out = "cr2"; return;
        case CV_REG_CR3:     *out = "cr3"; return;
        case CV_REG_CR4:     *out = "cr4"; return;           // Pentium return;
        case CV_REG_DR0:     *out = "dr0"; return;           // Debug register return;
        case CV_REG_DR1:     *out = "dr1"; return;
        case CV_REG_DR2:     *out = "dr2"; return;
        case CV_REG_DR3:     *out = "dr3"; return;
        case CV_REG_DR4:     *out = "dr4"; return;
        case CV_REG_DR5:     *out = "dr5"; return;
        case CV_REG_DR6:     *out = "dr6"; return;
        case CV_REG_DR7:     *out = "dr7"; return;
        case CV_REG_GDTR:    *out = "gdtr"; return;
        case CV_REG_GDTL:    *out = "gdtl"; return;
        case CV_REG_IDTR:    *out = "idtr"; return;
        case CV_REG_IDTL:    *out = "idtl"; return;
        case CV_REG_LDTR:    *out = "ldtr"; return;
        case CV_REG_TR:      *out = "tr"; return;

        case CV_REG_PSEUDO1: *out = "pseudo1"; return;
        case CV_REG_PSEUDO2: *out = "pseudo2"; return;
        case CV_REG_PSEUDO3: *out = "pseudo3"; return;
        case CV_REG_PSEUDO4: *out = "pseudo4"; return;
        case CV_REG_PSEUDO5: *out = "pseudo5"; return;
        case CV_REG_PSEUDO6: *out = "pseudo6"; return;
        case CV_REG_PSEUDO7: *out = "pseudo7"; return;
        case CV_REG_PSEUDO8: *out = "pseudo8"; return;
        case CV_REG_PSEUDO9: *out = "pseudo9"; return;

        case CV_REG_ST0:     *out = "st0"; return;
        case CV_REG_ST1:     *out = "st1"; return;
        case CV_REG_ST2:     *out = "st2"; return;
        case CV_REG_ST3:     *out = "st3"; return;
        case CV_REG_ST4:     *out = "st4"; return;
        case CV_REG_ST5:     *out = "st5"; return;
        case CV_REG_ST6:     *out = "st6"; return;
        case CV_REG_ST7:     *out = "st7"; return;
        case CV_REG_CTRL:    *out = "ctrl"; return;
        case CV_REG_STAT:    *out = "stat"; return;
        case CV_REG_TAG:     *out = "tag"; return;
        case CV_REG_FPIP:    *out = "fpip"; return;
        case CV_REG_FPCS:    *out = "fpcs"; return;
        case CV_REG_FPDO:    *out = "fpdo"; return;
        case CV_REG_FPDS:    *out = "fpds"; return;
        case CV_REG_ISEM:    *out = "isem"; return;
        case CV_REG_FPEIP:   *out = "fpeip"; return;
        case CV_REG_FPEDO:   *out = "fpedo"; return;

        case CV_REG_MM0:     *out = "mm0"; return;
        case CV_REG_MM1:     *out = "mm1"; return;
        case CV_REG_MM2:     *out = "mm2"; return;
        case CV_REG_MM3:     *out = "mm3"; return;
        case CV_REG_MM4:     *out = "mm4"; return;
        case CV_REG_MM5:     *out = "mm5"; return;
        case CV_REG_MM6:     *out = "mm6"; return;
        case CV_REG_MM7:     *out = "mm7"; return;

        case CV_REG_XMM0:    *out = "xmm0"; return; // KATMAI registers return;
        case CV_REG_XMM1:    *out = "xmm1"; return;
        case CV_REG_XMM2:    *out = "xmm2"; return;
        case CV_REG_XMM3:    *out = "xmm3"; return;
        case CV_REG_XMM4:    *out = "xmm4"; return;
        case CV_REG_XMM5:    *out = "xmm5"; return;
        case CV_REG_XMM6:    *out = "xmm6"; return;
        case CV_REG_XMM7:    *out = "xmm7"; return;

        case CV_REG_XMM00:   *out = "xmm00"; return; // KATMAI sub-registers return;
        case CV_REG_XMM01:   *out = "xmm01"; return;
        case CV_REG_XMM02:   *out = "xmm02"; return;
        case CV_REG_XMM03:   *out = "xmm03"; return;
        case CV_REG_XMM10:   *out = "xmm10"; return;
        case CV_REG_XMM11:   *out = "xmm11"; return;
        case CV_REG_XMM12:   *out = "xmm12"; return;
        case CV_REG_XMM13:   *out = "xmm13"; return;
        case CV_REG_XMM20:   *out = "xmm20"; return;
        case CV_REG_XMM21:   *out = "xmm21"; return;
        case CV_REG_XMM22:   *out = "xmm22"; return;
        case CV_REG_XMM23:   *out = "xmm23"; return;
        case CV_REG_XMM30:   *out = "xmm30"; return;
        case CV_REG_XMM31:   *out = "xmm31"; return;
        case CV_REG_XMM32:   *out = "xmm32"; return;
        case CV_REG_XMM33:   *out = "xmm33"; return;
        case CV_REG_XMM40:   *out = "xmm40"; return;
        case CV_REG_XMM41:   *out = "xmm41"; return;
        case CV_REG_XMM42:   *out = "xmm42"; return;
        case CV_REG_XMM43:   *out = "xmm43"; return;
        case CV_REG_XMM50:   *out = "xmm50"; return;
        case CV_REG_XMM51:   *out = "xmm51"; return;
        case CV_REG_XMM52:   *out = "xmm52"; return;
        case CV_REG_XMM53:   *out = "xmm53"; return;
        case CV_REG_XMM60:   *out = "xmm60"; return;
        case CV_REG_XMM61:   *out = "xmm61"; return;
        case CV_REG_XMM62:   *out = "xmm62"; return;
        case CV_REG_XMM63:   *out = "xmm63"; return;
        case CV_REG_XMM70:   *out = "xmm70"; return;
        case CV_REG_XMM71:   *out = "xmm71"; return;
        case CV_REG_XMM72:   *out = "xmm72"; return;
        case CV_REG_XMM73:   *out = "xmm73"; return;

        case CV_REG_XMM0L:   *out = "xmm0l"; return;
        case CV_REG_XMM1L:   *out = "xmm1l"; return;
        case CV_REG_XMM2L:   *out = "xmm2l"; return;
        case CV_REG_XMM3L:   *out = "xmm3l"; return;
        case CV_REG_XMM4L:   *out = "xmm4l"; return;
        case CV_REG_XMM5L:   *out = "xmm5l"; return;
        case CV_REG_XMM6L:   *out = "xmm6l"; return;
        case CV_REG_XMM7L:   *out = "xmm7l"; return;

        case CV_REG_XMM0H:   *out = "xmm0h"; return;
        case CV_REG_XMM1H:   *out = "xmm1h"; return;
        case CV_REG_XMM2H:   *out = "xmm2h"; return;
        case CV_REG_XMM3H:   *out = "xmm3h"; return;
        case CV_REG_XMM4H:   *out = "xmm4h"; return;
        case CV_REG_XMM5H:   *out = "xmm5h"; return;
        case CV_REG_XMM6H:   *out = "xmm6h"; return;
        case CV_REG_XMM7H:   *out = "xmm7h"; return;

        case CV_REG_MXCSR:   *out = "mxcsr"; return; // XMM status register

        case CV_REG_EDXEAX:  *out = "edxeax"; return; // EDX";EAX pair

        case CV_REG_EMM0L:   *out = "emm0l"; return;  // XMM sub-registers (WNI integer)
        case CV_REG_EMM1L:   *out = "emm1l"; return;
        case CV_REG_EMM2L:   *out = "emm2l"; return;
        case CV_REG_EMM3L:   *out = "emm3l"; return;
        case CV_REG_EMM4L:   *out = "emm4l"; return;
        case CV_REG_EMM5L:   *out = "emm5l"; return;
        case CV_REG_EMM6L:   *out = "emm6l"; return;
        case CV_REG_EMM7L:   *out = "emm7l"; return;

        case CV_REG_EMM0H:   *out = "emm0h"; return;
        case CV_REG_EMM1H:   *out = "emm1h"; return;
        case CV_REG_EMM2H:   *out = "emm2h"; return;
        case CV_REG_EMM3H:   *out = "emm3h"; return;
        case CV_REG_EMM4H:   *out = "emm4h"; return;
        case CV_REG_EMM5H:   *out = "emm5h"; return;
        case CV_REG_EMM6H:   *out = "emm6h"; return;
        case CV_REG_EMM7H:   *out = "emm7h"; return;


        case CV_REG_MM00:    *out = "mm00"; return; // do not change the order of these regs, first one must be even too
        case CV_REG_MM01:    *out = "mm01"; return;
        case CV_REG_MM10:    *out = "mm10"; return;
        case CV_REG_MM11:    *out = "mm11"; return;
        case CV_REG_MM20:    *out = "mm20"; return;
        case CV_REG_MM21:    *out = "mm21"; return;
        case CV_REG_MM30:    *out = "mm30"; return;
        case CV_REG_MM31:    *out = "mm31"; return;
        case CV_REG_MM40:    *out = "mm40"; return;
        case CV_REG_MM41:    *out = "mm41"; return;
        case CV_REG_MM50:    *out = "mm50"; return;
        case CV_REG_MM51:    *out = "mm51"; return;
        case CV_REG_MM60:    *out = "mm60"; return;
        case CV_REG_MM61:    *out = "mm61"; return;
        case CV_REG_MM70:    *out = "mm70"; return;
        case CV_REG_MM71:    *out = "mm71"; return;


        case CV_REG_YMM0:    *out = "ymm0"; return; // AVX registers
        case CV_REG_YMM1:    *out = "ymm1"; return;
        case CV_REG_YMM2:    *out = "ymm2"; return;
        case CV_REG_YMM3:    *out = "ymm3"; return;
        case CV_REG_YMM4:    *out = "ymm4"; return;
        case CV_REG_YMM5:    *out = "ymm5"; return;
        case CV_REG_YMM6:    *out = "ymm6"; return;
        case CV_REG_YMM7:    *out = "ymm7"; return;

        case CV_REG_YMM0H:   *out = "ymm0h"; return;
        case CV_REG_YMM1H:   *out = "ymm1h"; return;
        case CV_REG_YMM2H:   *out = "ymm2h"; return;
        case CV_REG_YMM3H:   *out = "ymm3h"; return;
        case CV_REG_YMM4H:   *out = "ymm4h"; return;
        case CV_REG_YMM5H:   *out = "ymm5h"; return;
        case CV_REG_YMM6H:   *out = "ymm6h"; return;
        case CV_REG_YMM7H:   *out = "ymm7h"; return;

        case CV_REG_YMM0I0:    *out = "ymm0i0"; return; // AVX integer registers
        case CV_REG_YMM0I1:    *out = "ymm0i1"; return;
        case CV_REG_YMM0I2:    *out = "ymm0i2"; return;
        case CV_REG_YMM0I3:    *out = "ymm0i3"; return;
        case CV_REG_YMM1I0:    *out = "ymm1i0"; return;
        case CV_REG_YMM1I1:    *out = "ymm1i1"; return;
        case CV_REG_YMM1I2:    *out = "ymm1i2"; return;
        case CV_REG_YMM1I3:    *out = "ymm1i3"; return;
        case CV_REG_YMM2I0:    *out = "ymm2i0"; return;
        case CV_REG_YMM2I1:    *out = "ymm2i1"; return;
        case CV_REG_YMM2I2:    *out = "ymm2i2"; return;
        case CV_REG_YMM2I3:    *out = "ymm2i3"; return;
        case CV_REG_YMM3I0:    *out = "ymm3i0"; return;
        case CV_REG_YMM3I1:    *out = "ymm3i1"; return;
        case CV_REG_YMM3I2:    *out = "ymm3i2"; return;
        case CV_REG_YMM3I3:    *out = "ymm3i3"; return;
        case CV_REG_YMM4I0:    *out = "ymm4i0"; return;
        case CV_REG_YMM4I1:    *out = "ymm4i1"; return;
        case CV_REG_YMM4I2:    *out = "ymm4i2"; return;
        case CV_REG_YMM4I3:    *out = "ymm4i3"; return;
        case CV_REG_YMM5I0:    *out = "ymm5i0"; return;
        case CV_REG_YMM5I1:    *out = "ymm5i1"; return;
        case CV_REG_YMM5I2:    *out = "ymm5i2"; return;
        case CV_REG_YMM5I3:    *out = "ymm5i3"; return;
        case CV_REG_YMM6I0:    *out = "ymm6i0"; return;
        case CV_REG_YMM6I1:    *out = "ymm6i1"; return;
        case CV_REG_YMM6I2:    *out = "ymm6i2"; return;
        case CV_REG_YMM6I3:    *out = "ymm6i3"; return;
        case CV_REG_YMM7I0:    *out = "ymm7i0"; return;
        case CV_REG_YMM7I1:    *out = "ymm7i1"; return;
        case CV_REG_YMM7I2:    *out = "ymm7i2"; return;
        case CV_REG_YMM7I3:    *out = "ymm7i3"; return;

        case CV_REG_YMM0F0:    *out = "ymm0f0"; return; // AVX floating-point single precise registers
        case CV_REG_YMM0F1:    *out = "ymm0f1"; return;
        case CV_REG_YMM0F2:    *out = "ymm0f2"; return;
        case CV_REG_YMM0F3:    *out = "ymm0f3"; return;
        case CV_REG_YMM0F4:    *out = "ymm0f4"; return;
        case CV_REG_YMM0F5:    *out = "ymm0f5"; return;
        case CV_REG_YMM0F6:    *out = "ymm0f6"; return;
        case CV_REG_YMM0F7:    *out = "ymm0f7"; return;
        case CV_REG_YMM1F0:    *out = "ymm1f0"; return;
        case CV_REG_YMM1F1:    *out = "ymm1f1"; return;
        case CV_REG_YMM1F2:    *out = "ymm1f2"; return;
        case CV_REG_YMM1F3:    *out = "ymm1f3"; return;
        case CV_REG_YMM1F4:    *out = "ymm1f4"; return;
        case CV_REG_YMM1F5:    *out = "ymm1f5"; return;
        case CV_REG_YMM1F6:    *out = "ymm1f6"; return;
        case CV_REG_YMM1F7:    *out = "ymm1f7"; return;
        case CV_REG_YMM2F0:    *out = "ymm2f0"; return;
        case CV_REG_YMM2F1:    *out = "ymm2f1"; return;
        case CV_REG_YMM2F2:    *out = "ymm2f2"; return;
        case CV_REG_YMM2F3:    *out = "ymm2f3"; return;
        case CV_REG_YMM2F4:    *out = "ymm2f4"; return;
        case CV_REG_YMM2F5:    *out = "ymm2f5"; return;
        case CV_REG_YMM2F6:    *out = "ymm2f6"; return;
        case CV_REG_YMM2F7:    *out = "ymm2f7"; return;
        case CV_REG_YMM3F0:    *out = "ymm3f0"; return;
        case CV_REG_YMM3F1:    *out = "ymm3f1"; return;
        case CV_REG_YMM3F2:    *out = "ymm3f2"; return;
        case CV_REG_YMM3F3:    *out = "ymm3f3"; return;
        case CV_REG_YMM3F4:    *out = "ymm3f4"; return;
        case CV_REG_YMM3F5:    *out = "ymm3f5"; return;
        case CV_REG_YMM3F6:    *out = "ymm3f6"; return;
        case CV_REG_YMM3F7:    *out = "ymm3f7"; return;
        case CV_REG_YMM4F0:    *out = "ymm4f0"; return;
        case CV_REG_YMM4F1:    *out = "ymm4f1"; return;
        case CV_REG_YMM4F2:    *out = "ymm4f2"; return;
        case CV_REG_YMM4F3:    *out = "ymm4f3"; return;
        case CV_REG_YMM4F4:    *out = "ymm4f4"; return;
        case CV_REG_YMM4F5:    *out = "ymm4f5"; return;
        case CV_REG_YMM4F6:    *out = "ymm4f6"; return;
        case CV_REG_YMM4F7:    *out = "ymm4f7"; return;
        case CV_REG_YMM5F0:    *out = "ymm5f0"; return;
        case CV_REG_YMM5F1:    *out = "ymm5f1"; return;
        case CV_REG_YMM5F2:    *out = "ymm5f2"; return;
        case CV_REG_YMM5F3:    *out = "ymm5f3"; return;
        case CV_REG_YMM5F4:    *out = "ymm5f4"; return;
        case CV_REG_YMM5F5:    *out = "ymm5f5"; return;
        case CV_REG_YMM5F6:    *out = "ymm5f6"; return;
        case CV_REG_YMM5F7:    *out = "ymm5f7"; return;
        case CV_REG_YMM6F0:    *out = "ymm6f0"; return;
        case CV_REG_YMM6F1:    *out = "ymm6f1"; return;
        case CV_REG_YMM6F2:    *out = "ymm6f2"; return;
        case CV_REG_YMM6F3:    *out = "ymm6f3"; return;
        case CV_REG_YMM6F4:    *out = "ymm6f4"; return;
        case CV_REG_YMM6F5:    *out = "ymm6f5"; return;
        case CV_REG_YMM6F6:    *out = "ymm6f6"; return;
        case CV_REG_YMM6F7:    *out = "ymm6f7"; return;
        case CV_REG_YMM7F0:    *out = "ymm7f0"; return;
        case CV_REG_YMM7F1:    *out = "ymm7f1"; return;
        case CV_REG_YMM7F2:    *out = "ymm7f2"; return;
        case CV_REG_YMM7F3:    *out = "ymm7f3"; return;
        case CV_REG_YMM7F4:    *out = "ymm7f4"; return;
        case CV_REG_YMM7F5:    *out = "ymm7f5"; return;
        case CV_REG_YMM7F6:    *out = "ymm7f6"; return;
        case CV_REG_YMM7F7:    *out = "ymm7f7"; return;

        case CV_REG_YMM0D0:    *out = "YMM0D0"; return; // AVX floating-point double precise registers
        case CV_REG_YMM0D1:    *out = "YMM0D1"; return;
        case CV_REG_YMM0D2:    *out = "YMM0D2"; return;
        case CV_REG_YMM0D3:    *out = "YMM0D3"; return;
        case CV_REG_YMM1D0:    *out = "YMM1D0"; return;
        case CV_REG_YMM1D1:    *out = "YMM1D1"; return;
        case CV_REG_YMM1D2:    *out = "YMM1D2"; return;
        case CV_REG_YMM1D3:    *out = "YMM1D3"; return;
        case CV_REG_YMM2D0:    *out = "YMM2D0"; return;
        case CV_REG_YMM2D1:    *out = "YMM2D1"; return;
        case CV_REG_YMM2D2:    *out = "YMM2D2"; return;
        case CV_REG_YMM2D3:    *out = "YMM2D3"; return;
        case CV_REG_YMM3D0:    *out = "YMM3D0"; return;
        case CV_REG_YMM3D1:    *out = "YMM3D1"; return;
        case CV_REG_YMM3D2:    *out = "YMM3D2"; return;
        case CV_REG_YMM3D3:    *out = "YMM3D3"; return;
        case CV_REG_YMM4D0:    *out = "YMM4D0"; return;
        case CV_REG_YMM4D1:    *out = "YMM4D1"; return;
        case CV_REG_YMM4D2:    *out = "YMM4D2"; return;
        case CV_REG_YMM4D3:    *out = "YMM4D3"; return;
        case CV_REG_YMM5D0:    *out = "YMM5D0"; return;
        case CV_REG_YMM5D1:    *out = "YMM5D1"; return;
        case CV_REG_YMM5D2:    *out = "YMM5D2"; return;
        case CV_REG_YMM5D3:    *out = "YMM5D3"; return;
        case CV_REG_YMM6D0:    *out = "YMM6D0"; return;
        case CV_REG_YMM6D1:    *out = "YMM6D1"; return;
        case CV_REG_YMM6D2:    *out = "YMM6D2"; return;
        case CV_REG_YMM6D3:    *out = "YMM6D3"; return;
        case CV_REG_YMM7D0:    *out = "YMM7D0"; return;
        case CV_REG_YMM7D1:    *out = "YMM7D1"; return;
        case CV_REG_YMM7D2:    *out = "YMM7D2"; return;
        case CV_REG_YMM7D3:    *out = "YMM7D3"; return;

        case CV_REG_BND0:      *out = "bnd0"; return; // x86 MPX bounds registers
        case CV_REG_BND1:      *out = "bnd1"; return;
        case CV_REG_BND2:      *out = "bnd2"; return;
        case CV_REG_BND3:      *out = "bnd3"; return;
        case CV_REG_BNDCFGU:   *out = "bndcfgu"; return;
        case CV_REG_BNDSTATUS: *out = "bndstatus"; return;

        case CV_REG_ZMM0:      *out = "zmm0"; return; // AVX-512 registers
        case CV_REG_ZMM1:      *out = "zmm1"; return;
        case CV_REG_ZMM2:      *out = "zmm2"; return;
        case CV_REG_ZMM3:      *out = "zmm3"; return;
        case CV_REG_ZMM4:      *out = "zmm4"; return;
        case CV_REG_ZMM5:      *out = "zmm5"; return;
        case CV_REG_ZMM6:      *out = "zmm6"; return;
        case CV_REG_ZMM7:      *out = "zmm7"; return;

        case CV_REG_ZMM0H:     *out = "zmm0h"; return;
        case CV_REG_ZMM1H:     *out = "zmm1h"; return;
        case CV_REG_ZMM2H:     *out = "zmm2h"; return;
        case CV_REG_ZMM3H:     *out = "zmm3h"; return;
        case CV_REG_ZMM4H:     *out = "zmm4h"; return;
        case CV_REG_ZMM5H:     *out = "zmm5h"; return;
        case CV_REG_ZMM6H:     *out = "zmm6h"; return;
        case CV_REG_ZMM7H:     *out = "zmm7h"; return;

        case CV_REG_K0:        *out = "k0"; return;
        case CV_REG_K1:        *out = "k1"; return;
        case CV_REG_K2:        *out = "k2"; return;
        case CV_REG_K3:        *out = "k3"; return;
        case CV_REG_K4:        *out = "k4"; return;
        case CV_REG_K5:        *out = "k5"; return;
        case CV_REG_K6:        *out = "k6"; return;
        case CV_REG_K7:        *out = "k7"; return;

        case CV_REG_SSP:       *out = "ssp"; return; // CET- Shadow Stack Pointer
      }
      break;

      // registers for the 68K processors
    case CV_CFL_M68000:
    case CV_CFL_M68010:
    case CV_CFL_M68020:
    case CV_CFL_M68030:
    case CV_CFL_M68040:
      switch ( reg )
      {
        case CV_R68_D0:      *out = "D0"; return;
        case CV_R68_D1:      *out = "D1"; return;
        case CV_R68_D2:      *out = "D2"; return;
        case CV_R68_D3:      *out = "D3"; return;
        case CV_R68_D4:      *out = "D4"; return;
        case CV_R68_D5:      *out = "D5"; return;
        case CV_R68_D6:      *out = "D6"; return;
        case CV_R68_D7:      *out = "D7"; return;
        case CV_R68_A0:      *out = "A0"; return;
        case CV_R68_A1:      *out = "A1"; return;
        case CV_R68_A2:      *out = "A2"; return;
        case CV_R68_A3:      *out = "A3"; return;
        case CV_R68_A4:      *out = "A4"; return;
        case CV_R68_A5:      *out = "A5"; return;
        case CV_R68_A6:      *out = "A6"; return;
        case CV_R68_A7:      *out = "A7"; return;
        case CV_R68_CCR:     *out = "CCR"; return;
        case CV_R68_SR:      *out = "SR"; return;
        case CV_R68_USP:     *out = "USP"; return;
        case CV_R68_MSP:     *out = "MSP"; return;
        case CV_R68_SFC:     *out = "SFC"; return;
        case CV_R68_DFC:     *out = "DFC"; return;
        case CV_R68_CACR:    *out = "CACR"; return;
        case CV_R68_VBR:     *out = "VBR"; return;
        case CV_R68_CAAR:    *out = "CAAR"; return;
        case CV_R68_ISP:     *out = "ISP"; return;
        case CV_R68_PC:      *out = "PC"; return;
        // reserved  27
        case CV_R68_FPCR:    *out = "FPCR"; return;
        case CV_R68_FPSR:    *out = "FPSR"; return;
        case CV_R68_FPIAR:   *out = "FPIAR"; return;
        // reserved  31
        case CV_R68_FP0:     *out = "FP0"; return;
        case CV_R68_FP1:     *out = "FP1"; return;
        case CV_R68_FP2:     *out = "FP2"; return;
        case CV_R68_FP3:     *out = "FP3"; return;
        case CV_R68_FP4:     *out = "FP4"; return;
        case CV_R68_FP5:     *out = "FP5"; return;
        case CV_R68_FP6:     *out = "FP6"; return;
        case CV_R68_FP7:     *out = "FP7"; return;
        // reserved  40
        case CV_R68_MMUSR030:*out = "MMUSR030"; return;
        case CV_R68_MMUSR:   *out = "MMUSR"; return;
        case CV_R68_URP:     *out = "URP"; return;
        case CV_R68_DTT0:    *out = "DTT0"; return;
        case CV_R68_DTT1:    *out = "DTT1"; return;
        case CV_R68_ITT0:    *out = "ITT0"; return;
        case CV_R68_ITT1:    *out = "ITT1"; return;
        // reserved  50
        case CV_R68_PSR:     *out = "PSR"; return;
        case CV_R68_PCSR:    *out = "PCSR"; return;
        case CV_R68_VAL:     *out = "VAL"; return;
        case CV_R68_CRP:     *out = "CRP"; return;
        case CV_R68_SRP:     *out = "SRP"; return;
        case CV_R68_DRP:     *out = "DRP"; return;
        case CV_R68_TC:      *out = "TC"; return;
        case CV_R68_AC:      *out = "AC"; return;
        case CV_R68_SCC:     *out = "SCC"; return;
        case CV_R68_CAL:     *out = "CAL"; return;
        case CV_R68_TT0:     *out = "TT0"; return;
        case CV_R68_TT1:     *out = "TT1"; return;
        // reserved  63
        case CV_R68_BAD0:    *out = "BAD0"; return;
        case CV_R68_BAD1:    *out = "BAD1"; return;
        case CV_R68_BAD2:    *out = "BAD2"; return;
        case CV_R68_BAD3:    *out = "BAD3"; return;
        case CV_R68_BAD4:    *out = "BAD4"; return;
        case CV_R68_BAD5:    *out = "BAD5"; return;
        case CV_R68_BAD6:    *out = "BAD6"; return;
        case CV_R68_BAD7:    *out = "BAD7"; return;
        case CV_R68_BAC0:    *out = "BAC0"; return;
        case CV_R68_BAC1:    *out = "BAC1"; return;
        case CV_R68_BAC2:    *out = "BAC2"; return;
        case CV_R68_BAC3:    *out = "BAC3"; return;
        case CV_R68_BAC4:    *out = "BAC4"; return;
        case CV_R68_BAC5:    *out = "BAC5"; return;
        case CV_R68_BAC6:    *out = "BAC6"; return;
        case CV_R68_BAC7:    *out = "BAC7"; return;
      }
      break;

    case CV_CFL_MIPS:
    case CV_CFL_MIPS16:
    case CV_CFL_MIPS32:
    case CV_CFL_MIPS64:
    case CV_CFL_MIPSI:
    case CV_CFL_MIPSII:
    case CV_CFL_MIPSIII:
    case CV_CFL_MIPSIV:
    case CV_CFL_MIPSV:
      switch ( reg )
      {
        // Register set for the MIPS 4000
        case CV_M4_NOREG:    *out = "NOREG"; return;
        case CV_M4_IntZERO:  *out = "IntZERO"; return;    /* CPU REGISTER */
        case CV_M4_IntAT:    *out = "IntAT"; return;
        case CV_M4_IntV0:    *out = "IntV0"; return;
        case CV_M4_IntV1:    *out = "IntV1"; return;
        case CV_M4_IntA0:    *out = "IntA0"; return;
        case CV_M4_IntA1:    *out = "IntA1"; return;
        case CV_M4_IntA2:    *out = "IntA2"; return;
        case CV_M4_IntA3:    *out = "IntA3"; return;
        case CV_M4_IntT0:    *out = "IntT0"; return;
        case CV_M4_IntT1:    *out = "IntT1"; return;
        case CV_M4_IntT2:    *out = "IntT2"; return;
        case CV_M4_IntT3:    *out = "IntT3"; return;
        case CV_M4_IntT4:    *out = "IntT4"; return;
        case CV_M4_IntT5:    *out = "IntT5"; return;
        case CV_M4_IntT6:    *out = "IntT6"; return;
        case CV_M4_IntT7:    *out = "IntT7"; return;
        case CV_M4_IntS0:    *out = "IntS0"; return;
        case CV_M4_IntS1:    *out = "IntS1"; return;
        case CV_M4_IntS2:    *out = "IntS2"; return;
        case CV_M4_IntS3:    *out = "IntS3"; return;
        case CV_M4_IntS4:    *out = "IntS4"; return;
        case CV_M4_IntS5:    *out = "IntS5"; return;
        case CV_M4_IntS6:    *out = "IntS6"; return;
        case CV_M4_IntS7:    *out = "IntS7"; return;
        case CV_M4_IntT8:    *out = "IntT8"; return;
        case CV_M4_IntT9:    *out = "IntT9"; return;
        case CV_M4_IntKT0:   *out = "IntKT0"; return;
        case CV_M4_IntKT1:   *out = "IntKT1"; return;
        case CV_M4_IntGP:    *out = "IntGP"; return;
        case CV_M4_IntSP:    *out = "IntSP"; return;
        case CV_M4_IntS8:    *out = "IntS8"; return;
        case CV_M4_IntRA:    *out = "IntRA"; return;
        case CV_M4_IntLO:    *out = "IntLO"; return;
        case CV_M4_IntHI:    *out = "IntHI"; return;

        case CV_M4_Fir:
        case CV_M4_Psr:

        case CV_M4_FltF0:    *out = "FltF0"; return; /* Floating point registers */
        case CV_M4_FltF1:    *out = "FltF1"; return;
        case CV_M4_FltF2:    *out = "FltF2"; return;
        case CV_M4_FltF3:    *out = "FltF3"; return;
        case CV_M4_FltF4:    *out = "FltF4"; return;
        case CV_M4_FltF5:    *out = "FltF5"; return;
        case CV_M4_FltF6:    *out = "FltF6"; return;
        case CV_M4_FltF7:    *out = "FltF7"; return;
        case CV_M4_FltF8:    *out = "FltF8"; return;
        case CV_M4_FltF9:    *out = "FltF9"; return;
        case CV_M4_FltF10:   *out = "FltF10"; return;
        case CV_M4_FltF11:   *out = "FltF11"; return;
        case CV_M4_FltF12:   *out = "FltF12"; return;
        case CV_M4_FltF13:   *out = "FltF13"; return;
        case CV_M4_FltF14:   *out = "FltF14"; return;
        case CV_M4_FltF15:   *out = "FltF15"; return;
        case CV_M4_FltF16:   *out = "FltF16"; return;
        case CV_M4_FltF17:   *out = "FltF17"; return;
        case CV_M4_FltF18:   *out = "FltF18"; return;
        case CV_M4_FltF19:   *out = "FltF19"; return;
        case CV_M4_FltF20:   *out = "FltF20"; return;
        case CV_M4_FltF21:   *out = "FltF21"; return;
        case CV_M4_FltF22:   *out = "FltF22"; return;
        case CV_M4_FltF23:   *out = "FltF23"; return;
        case CV_M4_FltF24:   *out = "FltF24"; return;
        case CV_M4_FltF25:   *out = "FltF25"; return;
        case CV_M4_FltF26:   *out = "FltF26"; return;
        case CV_M4_FltF27:   *out = "FltF27"; return;
        case CV_M4_FltF28:   *out = "FltF28"; return;
        case CV_M4_FltF29:   *out = "FltF29"; return;
        case CV_M4_FltF30:   *out = "FltF30"; return;
        case CV_M4_FltF31:   *out = "FltF31"; return;
        case CV_M4_FltFsr:   *out = "FltFsr"; return;
      }
      break;

    case CV_CFL_ALPHA:
//    case CV_CFL_ALPHA_21064:
    case CV_CFL_ALPHA_21164:
    case CV_CFL_ALPHA_21164A:
    case CV_CFL_ALPHA_21264:
    case CV_CFL_ALPHA_21364:
      // Register set for the ALPHA AXP
      switch ( reg )
      {
        case CV_ALPHA_NOREG: *out = "NOREG"; return;
        case CV_ALPHA_FltF0: *out = "FltF0"; return; // Floating point registers
        case CV_ALPHA_FltF1: *out = "FltF1"; return;
        case CV_ALPHA_FltF2: *out = "FltF2"; return;
        case CV_ALPHA_FltF3: *out = "FltF3"; return;
        case CV_ALPHA_FltF4: *out = "FltF4"; return;
        case CV_ALPHA_FltF5: *out = "FltF5"; return;
        case CV_ALPHA_FltF6: *out = "FltF6"; return;
        case CV_ALPHA_FltF7: *out = "FltF7"; return;
        case CV_ALPHA_FltF8: *out = "FltF8"; return;
        case CV_ALPHA_FltF9: *out = "FltF9"; return;
        case CV_ALPHA_FltF10:*out = "FltF10"; return;
        case CV_ALPHA_FltF11:*out = "FltF11"; return;
        case CV_ALPHA_FltF12:*out = "FltF12"; return;
        case CV_ALPHA_FltF13:*out = "FltF13"; return;
        case CV_ALPHA_FltF14:*out = "FltF14"; return;
        case CV_ALPHA_FltF15:*out = "FltF15"; return;
        case CV_ALPHA_FltF16:*out = "FltF16"; return;
        case CV_ALPHA_FltF17:*out = "FltF17"; return;
        case CV_ALPHA_FltF18:*out = "FltF18"; return;
        case CV_ALPHA_FltF19:*out = "FltF19"; return;
        case CV_ALPHA_FltF20:*out = "FltF20"; return;
        case CV_ALPHA_FltF21:*out = "FltF21"; return;
        case CV_ALPHA_FltF22:*out = "FltF22"; return;
        case CV_ALPHA_FltF23:*out = "FltF23"; return;
        case CV_ALPHA_FltF24:*out = "FltF24"; return;
        case CV_ALPHA_FltF25:*out = "FltF25"; return;
        case CV_ALPHA_FltF26:*out = "FltF26"; return;
        case CV_ALPHA_FltF27:*out = "FltF27"; return;
        case CV_ALPHA_FltF28:*out = "FltF28"; return;
        case CV_ALPHA_FltF29:*out = "FltF29"; return;
        case CV_ALPHA_FltF30:*out = "FltF30"; return;
        case CV_ALPHA_FltF31:*out = "FltF31"; return;

        case CV_ALPHA_IntV0: *out = "IntV0"; return; // Integer registers
        case CV_ALPHA_IntT0: *out = "IntT0"; return;
        case CV_ALPHA_IntT1: *out = "IntT1"; return;
        case CV_ALPHA_IntT2: *out = "IntT2"; return;
        case CV_ALPHA_IntT3: *out = "IntT3"; return;
        case CV_ALPHA_IntT4: *out = "IntT4"; return;
        case CV_ALPHA_IntT5: *out = "IntT5"; return;
        case CV_ALPHA_IntT6: *out = "IntT6"; return;
        case CV_ALPHA_IntT7: *out = "IntT7"; return;
        case CV_ALPHA_IntS0: *out = "IntS0"; return;
        case CV_ALPHA_IntS1: *out = "IntS1"; return;
        case CV_ALPHA_IntS2: *out = "IntS2"; return;
        case CV_ALPHA_IntS3: *out = "IntS3"; return;
        case CV_ALPHA_IntS4: *out = "IntS4"; return;
        case CV_ALPHA_IntS5: *out = "IntS5"; return;
        case CV_ALPHA_IntFP: *out = "IntFP"; return;
        case CV_ALPHA_IntA0: *out = "IntA0"; return;
        case CV_ALPHA_IntA1: *out = "IntA1"; return;
        case CV_ALPHA_IntA2: *out = "IntA2"; return;
        case CV_ALPHA_IntA3: *out = "IntA3"; return;
        case CV_ALPHA_IntA4: *out = "IntA4"; return;
        case CV_ALPHA_IntA5: *out = "IntA5"; return;
        case CV_ALPHA_IntT8: *out = "IntT8"; return;
        case CV_ALPHA_IntT9: *out = "IntT9"; return;
        case CV_ALPHA_IntT10:*out = "IntT10"; return;
        case CV_ALPHA_IntT11:*out = "IntT11"; return;
        case CV_ALPHA_IntRA: *out = "IntRA"; return;
        case CV_ALPHA_IntT12:*out = "IntT12"; return;
        case CV_ALPHA_IntAT: *out = "IntAT"; return;
        case CV_ALPHA_IntGP: *out = "IntGP"; return;
        case CV_ALPHA_IntSP: *out = "IntSP"; return;
        case CV_ALPHA_IntZERO:*out = "IntZERO"; return;

        case CV_ALPHA_Fpcr:  *out = "Fpcr"; return; // Control registers
        case CV_ALPHA_Fir:   *out = "Fir"; return;
        case CV_ALPHA_Psr:   *out = "Psr"; return;
        case CV_ALPHA_FltFsr:*out = "FltFsr"; return;
        case CV_ALPHA_SoftFpcr:*out = "SoftFpcr"; return;
      }
      break;

    case CV_CFL_PPC601:
    case CV_CFL_PPC603:
    case CV_CFL_PPC604:
    case CV_CFL_PPC620:
    case CV_CFL_PPCFP:
    case CV_CFL_PPCBE:
      // Register Set for Motorola/IBM PowerPC
      switch ( reg )
      {
        /*
        ** PowerPC General Registers ( User Level )
        */
        case CV_PPC_GPR0:    *out = "gpr0"; return;
        case CV_PPC_GPR1:    *out = "gpr1"; return;
        case CV_PPC_GPR2:    *out = "gpr2"; return;
        case CV_PPC_GPR3:    *out = "gpr3"; return;
        case CV_PPC_GPR4:    *out = "gpr4"; return;
        case CV_PPC_GPR5:    *out = "gpr5"; return;
        case CV_PPC_GPR6:    *out = "gpr6"; return;
        case CV_PPC_GPR7:    *out = "gpr7"; return;
        case CV_PPC_GPR8:    *out = "gpr8"; return;
        case CV_PPC_GPR9:    *out = "gpr9"; return;
        case CV_PPC_GPR10:   *out = "gpr10"; return;
        case CV_PPC_GPR11:   *out = "gpr11"; return;
        case CV_PPC_GPR12:   *out = "gpr12"; return;
        case CV_PPC_GPR13:   *out = "gpr13"; return;
        case CV_PPC_GPR14:   *out = "gpr14"; return;
        case CV_PPC_GPR15:   *out = "gpr15"; return;
        case CV_PPC_GPR16:   *out = "gpr16"; return;
        case CV_PPC_GPR17:   *out = "gpr17"; return;
        case CV_PPC_GPR18:   *out = "gpr18"; return;
        case CV_PPC_GPR19:   *out = "gpr19"; return;
        case CV_PPC_GPR20:   *out = "gpr20"; return;
        case CV_PPC_GPR21:   *out = "gpr21"; return;
        case CV_PPC_GPR22:   *out = "gpr22"; return;
        case CV_PPC_GPR23:   *out = "gpr23"; return;
        case CV_PPC_GPR24:   *out = "gpr24"; return;
        case CV_PPC_GPR25:   *out = "gpr25"; return;
        case CV_PPC_GPR26:   *out = "gpr26"; return;
        case CV_PPC_GPR27:   *out = "gpr27"; return;
        case CV_PPC_GPR28:   *out = "gpr28"; return;
        case CV_PPC_GPR29:   *out = "gpr29"; return;
        case CV_PPC_GPR30:   *out = "gpr30"; return;
        case CV_PPC_GPR31:   *out = "gpr31"; return;

        /*
        ** PowerPC Condition Register ( user level )
        */
        case CV_PPC_CR:      *out = "cr"; return;
        case CV_PPC_CR0:     *out = "cr0"; return;
        case CV_PPC_CR1:     *out = "cr1"; return;
        case CV_PPC_CR2:     *out = "cr2"; return;
        case CV_PPC_CR3:     *out = "cr3"; return;
        case CV_PPC_CR4:     *out = "cr4"; return;
        case CV_PPC_CR5:     *out = "cr5"; return;
        case CV_PPC_CR6:     *out = "cr6"; return;
        case CV_PPC_CR7:     *out = "cr7"; return;

        /*
        ** PowerPC Floating Point Registers ( user Level )
        */
        case CV_PPC_FPR0:    *out = "fpr0"; return;
        case CV_PPC_FPR1:    *out = "fpr1"; return;
        case CV_PPC_FPR2:    *out = "fpr2"; return;
        case CV_PPC_FPR3:    *out = "fpr3"; return;
        case CV_PPC_FPR4:    *out = "fpr4"; return;
        case CV_PPC_FPR5:    *out = "fpr5"; return;
        case CV_PPC_FPR6:    *out = "fpr6"; return;
        case CV_PPC_FPR7:    *out = "fpr7"; return;
        case CV_PPC_FPR8:    *out = "fpr8"; return;
        case CV_PPC_FPR9:    *out = "fpr9"; return;
        case CV_PPC_FPR10:   *out = "fpr10"; return;
        case CV_PPC_FPR11:   *out = "fpr11"; return;
        case CV_PPC_FPR12:   *out = "fpr12"; return;
        case CV_PPC_FPR13:   *out = "fpr13"; return;
        case CV_PPC_FPR14:   *out = "fpr14"; return;
        case CV_PPC_FPR15:   *out = "fpr15"; return;
        case CV_PPC_FPR16:   *out = "fpr16"; return;
        case CV_PPC_FPR17:   *out = "fpr17"; return;
        case CV_PPC_FPR18:   *out = "fpr18"; return;
        case CV_PPC_FPR19:   *out = "fpr19"; return;
        case CV_PPC_FPR20:   *out = "fpr20"; return;
        case CV_PPC_FPR21:   *out = "fpr21"; return;
        case CV_PPC_FPR22:   *out = "fpr22"; return;
        case CV_PPC_FPR23:   *out = "fpr23"; return;
        case CV_PPC_FPR24:   *out = "fpr24"; return;
        case CV_PPC_FPR25:   *out = "fpr25"; return;
        case CV_PPC_FPR26:   *out = "fpr26"; return;
        case CV_PPC_FPR27:   *out = "fpr27"; return;
        case CV_PPC_FPR28:   *out = "fpr28"; return;
        case CV_PPC_FPR29:   *out = "fpr29"; return;
        case CV_PPC_FPR30:   *out = "fpr30"; return;
        case CV_PPC_FPR31:   *out = "fpr31"; return;

        /*
        ** PowerPC Floating Point Status and Control Register ( User Level )
        */
        case CV_PPC_FPSCR:   *out = "FPSCR"; return;

        /*
        ** PowerPC Machine State Register ( Supervisor Level )
        */
        case CV_PPC_MSR:     *out = "msr"; return;

        /*
        ** PowerPC Segment Registers ( Supervisor Level )
        */
        case CV_PPC_SR0:     *out = "sr0"; return;
        case CV_PPC_SR1:     *out = "sr1"; return;
        case CV_PPC_SR2:     *out = "sr2"; return;
        case CV_PPC_SR3:     *out = "sr3"; return;
        case CV_PPC_SR4:     *out = "sr4"; return;
        case CV_PPC_SR5:     *out = "sr5"; return;
        case CV_PPC_SR6:     *out = "sr6"; return;
        case CV_PPC_SR7:     *out = "sr7"; return;
        case CV_PPC_SR8:     *out = "sr8"; return;
        case CV_PPC_SR9:     *out = "sr9"; return;
        case CV_PPC_SR10:    *out = "sr10"; return;
        case CV_PPC_SR11:    *out = "sr11"; return;
        case CV_PPC_SR12:    *out = "sr12"; return;
        case CV_PPC_SR13:    *out = "sr13"; return;
        case CV_PPC_SR14:    *out = "sr14"; return;
        case CV_PPC_SR15:    *out = "sr15"; return;

        /*
        ** For all of the special purpose registers add 100 to the SPR# that the
        ** Motorola/IBM documentation gives with the exception of any imaginary
        ** registers.
        */

        /*
        ** PowerPC Special Purpose Registers ( User Level )
        */
        case CV_PPC_PC:      *out = "pc"; return; // PC (imaginary register)

        case CV_PPC_MQ:      *out = "mq"; return; // MPC601
        case CV_PPC_XER:     *out = "xer"; return;
        case CV_PPC_RTCU:    *out = "rtcu"; return; // MPC601
        case CV_PPC_RTCL:    *out = "rtcl"; return; // MPC601
        case CV_PPC_LR:      *out = "lr"; return;
        case CV_PPC_CTR:     *out = "ctr"; return;

        case CV_PPC_COMPARE: *out = "compare"; return;// part of XER (internal to the debugger only)
        case CV_PPC_COUNT:   *out = "count"; return;// part of XER (internal to the debugger only)

        /*
        ** PowerPC Special Purpose Registers ( supervisor Level )
        */
        case CV_PPC_DSISR:   *out = "dsisr"; return;
        case CV_PPC_DAR:     *out = "dar"; return;
        case CV_PPC_DEC:     *out = "dec"; return;
        case CV_PPC_SDR1:    *out = "sdr1"; return;
        case CV_PPC_SRR0:    *out = "srr0"; return;
        case CV_PPC_SRR1:    *out = "srr1"; return;
        case CV_PPC_SPRG0:   *out = "sprg0"; return;
        case CV_PPC_SPRG1:   *out = "sprg1"; return;
        case CV_PPC_SPRG2:   *out = "sprg2"; return;
        case CV_PPC_SPRG3:   *out = "sprg3"; return;
        case CV_PPC_ASR:     *out = "asr"; return;// 64-bit implementations only
        case CV_PPC_EAR:     *out = "ear"; return;
        case CV_PPC_PVR:     *out = "pvr"; return;
        case CV_PPC_BAT0U:   *out = "bat0u"; return;
        case CV_PPC_BAT0L:   *out = "bat0l"; return;
        case CV_PPC_BAT1U:   *out = "bat1u"; return;
        case CV_PPC_BAT1L:   *out = "bat1l"; return;
        case CV_PPC_BAT2U:   *out = "bat2u"; return;
        case CV_PPC_BAT2L:   *out = "bat2l"; return;
        case CV_PPC_BAT3U:   *out = "bat3u"; return;
        case CV_PPC_BAT3L:   *out = "bat3l"; return;
        case CV_PPC_DBAT0U:  *out = "dbat0u"; return;
        case CV_PPC_DBAT0L:  *out = "dbat0l"; return;
        case CV_PPC_DBAT1U:  *out = "dbat1u"; return;
        case CV_PPC_DBAT1L:  *out = "dbat1l"; return;
        case CV_PPC_DBAT2U:  *out = "dbat2u"; return;
        case CV_PPC_DBAT2L:  *out = "dbat2l"; return;
        case CV_PPC_DBAT3U:  *out = "dbat3u"; return;
        case CV_PPC_DBAT3L:  *out = "dbat3l"; return;

        /*
        ** PowerPC Special Purpose Registers implementation Dependent ( Supervisor Level )
        */

        /*
        ** Doesn't appear that IBM/Motorola has finished defining these.
        */

        case CV_PPC_PMR0:    *out = "pmr0"; return;// MPC620,
        case CV_PPC_PMR1:    *out = "pmr1"; return;// MPC620,
        case CV_PPC_PMR2:    *out = "pmr2"; return;// MPC620,
        case CV_PPC_PMR3:    *out = "pmr3"; return;// MPC620,
        case CV_PPC_PMR4:    *out = "pmr4"; return;// MPC620,
        case CV_PPC_PMR5:    *out = "pmr5"; return;// MPC620,
        case CV_PPC_PMR6:    *out = "pmr6"; return;// MPC620,
        case CV_PPC_PMR7:    *out = "pmr7"; return;// MPC620,
        case CV_PPC_PMR8:    *out = "pmr8"; return;// MPC620,
        case CV_PPC_PMR9:    *out = "pmr9"; return;// MPC620,
        case CV_PPC_PMR10:   *out = "pmr10"; return;// MPC620,
        case CV_PPC_PMR11:   *out = "pmr11"; return;// MPC620,
        case CV_PPC_PMR12:   *out = "pmr12"; return;// MPC620,
        case CV_PPC_PMR13:   *out = "pmr13"; return;// MPC620,
        case CV_PPC_PMR14:   *out = "pmr14"; return;// MPC620,
        case CV_PPC_PMR15:   *out = "pmr15"; return;// MPC620,

        case CV_PPC_DMISS:   *out = "dmiss"; return;// MPC603
        case CV_PPC_DCMP:    *out = "dcmp"; return;// MPC603
        case CV_PPC_HASH1:   *out = "hash1"; return;// MPC603
        case CV_PPC_HASH2:   *out = "hash2"; return;// MPC603
        case CV_PPC_IMISS:   *out = "imiss"; return;// MPC603
        case CV_PPC_ICMP:    *out = "icmp"; return;// MPC603
        case CV_PPC_RPA:     *out = "rpa"; return;// MPC603

        case CV_PPC_HID0:    *out = "hid0"; return;// MPC601, MPC603, MPC620
        case CV_PPC_HID1:    *out = "hid1"; return;// MPC601
        case CV_PPC_HID2:    *out = "hid2"; return;// MPC601, MPC603, MPC620 ( IABR )
        case CV_PPC_HID3:    *out = "hid3"; return;// Not Defined
        case CV_PPC_HID4:    *out = "hid4"; return;// Not Defined
        case CV_PPC_HID5:    *out = "hid5"; return;// MPC601, MPC604, MPC620 ( DABR )
        case CV_PPC_HID6:    *out = "hid6"; return;// Not Defined
        case CV_PPC_HID7:    *out = "hid7"; return;// Not Defined
        case CV_PPC_HID8:    *out = "hid8"; return;// MPC620 ( BUSCSR )
        case CV_PPC_HID9:    *out = "hid9"; return;// MPC620 ( L2CSR )
        case CV_PPC_HID10:   *out = "hid10"; return;// Not Defined
        case CV_PPC_HID11:   *out = "hid11"; return;// Not Defined
        case CV_PPC_HID12:   *out = "hid12"; return;// Not Defined
        case CV_PPC_HID13:   *out = "hid13"; return;// MPC604 ( HCR )
        case CV_PPC_HID14:   *out = "hid14"; return;// Not Defined
        case CV_PPC_HID15:   *out = "hid15"; return;// MPC601, MPC604, MPC620 ( PIR )
      }
      break;

    //
    // JAVA VM registers
    //

    //    case CV_JAVA_PC:     *out = "PC"; return;

    case CV_CFL_SH3:
    case CV_CFL_SH3E:
    case CV_CFL_SH3DSP:
    case CV_CFL_SH4:
      //
      // Register set for the Hitachi SH3
      //
      switch ( reg )
      {
        case CV_SH3_NOREG:   *out = "NOREG"; return;

        case CV_SH3_IntR0:   *out = "IntR0"; return;// CPU REGISTER
        case CV_SH3_IntR1:   *out = "IntR1"; return;
        case CV_SH3_IntR2:   *out = "IntR2"; return;
        case CV_SH3_IntR3:   *out = "IntR3"; return;
        case CV_SH3_IntR4:   *out = "IntR4"; return;
        case CV_SH3_IntR5:   *out = "IntR5"; return;
        case CV_SH3_IntR6:   *out = "IntR6"; return;
        case CV_SH3_IntR7:   *out = "IntR7"; return;
        case CV_SH3_IntR8:   *out = "IntR8"; return;
        case CV_SH3_IntR9:   *out = "IntR9"; return;
        case CV_SH3_IntR10:  *out = "IntR10"; return;
        case CV_SH3_IntR11:  *out = "IntR11"; return;
        case CV_SH3_IntR12:  *out = "IntR12"; return;
        case CV_SH3_IntR13:  *out = "IntR13"; return;
        case CV_SH3_IntFp:   *out = "IntFp"; return;
        case CV_SH3_IntSp:   *out = "IntSp"; return;
        case CV_SH3_Gbr:     *out = "Gbr"; return;
        case CV_SH3_Pr:      *out = "Pr"; return;
        case CV_SH3_Mach:    *out = "Mach"; return;
        case CV_SH3_Macl:    *out = "Macl"; return;

        case CV_SH3_Pc:      *out = "Pc"; return;
        case CV_SH3_Sr:      *out = "Sr"; return;

        case CV_SH3_BarA:    *out = "BarA"; return;
        case CV_SH3_BasrA:   *out = "BasrA"; return;
        case CV_SH3_BamrA:   *out = "BamrA"; return;
        case CV_SH3_BbrA:    *out = "BbrA"; return;
        case CV_SH3_BarB:    *out = "BarB"; return;
        case CV_SH3_BasrB:   *out = "BasrB"; return;
        case CV_SH3_BamrB:   *out = "BamrB"; return;
        case CV_SH3_BbrB:    *out = "BbrB"; return;
        case CV_SH3_BdrB:    *out = "BdrB"; return;
        case CV_SH3_BdmrB:   *out = "BdmrB"; return;
        case CV_SH3_Brcr:    *out = "Brcr"; return;

        //
        // Additional registers for Hitachi SH processors
        //

        case CV_SH_Fpscr:    *out = "Fpscr"; return;// floating point status/control register
        case CV_SH_Fpul:     *out = "Fpul"; return;// floating point communication register

        case CV_SH_FpR0:     *out = "FpR0"; return;// Floating point registers
        case CV_SH_FpR1:     *out = "FpR1"; return;
        case CV_SH_FpR2:     *out = "FpR2"; return;
        case CV_SH_FpR3:     *out = "FpR3"; return;
        case CV_SH_FpR4:     *out = "FpR4"; return;
        case CV_SH_FpR5:     *out = "FpR5"; return;
        case CV_SH_FpR6:     *out = "FpR6"; return;
        case CV_SH_FpR7:     *out = "FpR7"; return;
        case CV_SH_FpR8:     *out = "FpR8"; return;
        case CV_SH_FpR9:     *out = "FpR9"; return;
        case CV_SH_FpR10:    *out = "FpR10"; return;
        case CV_SH_FpR11:    *out = "FpR11"; return;
        case CV_SH_FpR12:    *out = "FpR12"; return;
        case CV_SH_FpR13:    *out = "FpR13"; return;
        case CV_SH_FpR14:    *out = "FpR14"; return;
        case CV_SH_FpR15:    *out = "FpR15"; return;

        case CV_SH_XFpR0:    *out = "XFpR0"; return;
        case CV_SH_XFpR1:    *out = "XFpR1"; return;
        case CV_SH_XFpR2:    *out = "XFpR2"; return;
        case CV_SH_XFpR3:    *out = "XFpR3"; return;
        case CV_SH_XFpR4:    *out = "XFpR4"; return;
        case CV_SH_XFpR5:    *out = "XFpR5"; return;
        case CV_SH_XFpR6:    *out = "XFpR6"; return;
        case CV_SH_XFpR7:    *out = "XFpR7"; return;
        case CV_SH_XFpR8:    *out = "XFpR8"; return;
        case CV_SH_XFpR9:    *out = "XFpR9"; return;
        case CV_SH_XFpR10:   *out = "XFpR10"; return;
        case CV_SH_XFpR11:   *out = "XFpR11"; return;
        case CV_SH_XFpR12:   *out = "XFpR12"; return;
        case CV_SH_XFpR13:   *out = "XFpR13"; return;
        case CV_SH_XFpR14:   *out = "XFpR14"; return;
        case CV_SH_XFpR15:   *out = "XFpR15"; return;
      }
      break;

    case CV_CFL_ARM3:
    case CV_CFL_ARM4:
    case CV_CFL_ARM4T:
    case CV_CFL_ARM5:
    case CV_CFL_ARM5T:
    case CV_CFL_ARM6:
    case CV_CFL_ARM_XMAC:
    case CV_CFL_ARM_WMMX:
    case CV_CFL_THUMB:
    case CV_CFL_ARMNT:
      //
      // Register set for the ARM processor.
      //
      switch ( reg )
      {
        case CV_ARM_NOREG:   *out = "noreg"; return;
        case CV_ARM_R0:      *out = "r0"; return;
        case CV_ARM_R1:      *out = "r1"; return;
        case CV_ARM_R2:      *out = "r2"; return;
        case CV_ARM_R3:      *out = "r3"; return;
        case CV_ARM_R4:      *out = "r4"; return;
        case CV_ARM_R5:      *out = "r5"; return;
        case CV_ARM_R6:      *out = "r6"; return;
        case CV_ARM_R7:      *out = "r7"; return;
        case CV_ARM_R8:      *out = "r8"; return;
        case CV_ARM_R9:      *out = "r9"; return;
        case CV_ARM_R10:     *out = "r10"; return;
        case CV_ARM_R11:     *out = "r11"; return;// Frame pointer, if allocated
        case CV_ARM_R12:     *out = "r12"; return;
        case CV_ARM_SP:      *out = "sp"; return;// Stack pointer
        case CV_ARM_LR:      *out = "lr"; return;// Link Register
        case CV_ARM_PC:      *out = "pc"; return;// Program counter
        case CV_ARM_CPSR:    *out = "cpsr"; return;// Current program status register


        case CV_ARM_ACC0:    *out = "acc0"; return; // DSP co-processor 0 40 bit accumulator

        //
        // Registers for ARM VFP10 support
        //

        case CV_ARM_FPSCR:   *out = "fpscr"; return;
        case CV_ARM_FPEXC:   *out = "fpexc"; return;

        case CV_ARM_FS0:     *out = "fs0"; return;
        case CV_ARM_FS1:     *out = "fs1"; return;
        case CV_ARM_FS2:     *out = "fs2"; return;
        case CV_ARM_FS3:     *out = "fs3"; return;
        case CV_ARM_FS4:     *out = "fs4"; return;
        case CV_ARM_FS5:     *out = "fs5"; return;
        case CV_ARM_FS6:     *out = "fs6"; return;
        case CV_ARM_FS7:     *out = "fs7"; return;
        case CV_ARM_FS8:     *out = "fs8"; return;
        case CV_ARM_FS9:     *out = "fs9"; return;
        case CV_ARM_FS10:    *out = "fs10"; return;
        case CV_ARM_FS11:    *out = "fs11"; return;
        case CV_ARM_FS12:    *out = "fs12"; return;
        case CV_ARM_FS13:    *out = "fs13"; return;
        case CV_ARM_FS14:    *out = "fs14"; return;
        case CV_ARM_FS15:    *out = "fs15"; return;
        case CV_ARM_FS16:    *out = "fs16"; return;
        case CV_ARM_FS17:    *out = "fs17"; return;
        case CV_ARM_FS18:    *out = "fs18"; return;
        case CV_ARM_FS19:    *out = "fs19"; return;
        case CV_ARM_FS20:    *out = "fs20"; return;
        case CV_ARM_FS21:    *out = "fs21"; return;
        case CV_ARM_FS22:    *out = "fs22"; return;
        case CV_ARM_FS23:    *out = "fs23"; return;
        case CV_ARM_FS24:    *out = "fs24"; return;
        case CV_ARM_FS25:    *out = "fs25"; return;
        case CV_ARM_FS26:    *out = "fs26"; return;
        case CV_ARM_FS27:    *out = "fs27"; return;
        case CV_ARM_FS28:    *out = "fs28"; return;
        case CV_ARM_FS29:    *out = "fs29"; return;
        case CV_ARM_FS30:    *out = "fs30"; return;
        case CV_ARM_FS31:    *out = "fs31"; return;

        //
        // ARM VFP Floating Point Extra control registers
        //

        case CV_ARM_FPEXTRA0: *out = "fpextra0"; return;
        case CV_ARM_FPEXTRA1: *out = "fpextra1"; return;
        case CV_ARM_FPEXTRA2: *out = "fpextra2"; return;
        case CV_ARM_FPEXTRA3: *out = "fpextra3"; return;
        case CV_ARM_FPEXTRA4: *out = "fpextra4"; return;
        case CV_ARM_FPEXTRA5: *out = "fpextra5"; return;
        case CV_ARM_FPEXTRA6: *out = "fpextra6"; return;
        case CV_ARM_FPEXTRA7: *out = "fpextra7"; return;

        // XSCALE Concan co-processor registers
        case CV_ARM_WR0:  *out = "wr0"; return;
        case CV_ARM_WR1:  *out = "wr1"; return;
        case CV_ARM_WR2:  *out = "wr2"; return;
        case CV_ARM_WR3:  *out = "wr3"; return;
        case CV_ARM_WR4:  *out = "wr4"; return;
        case CV_ARM_WR5:  *out = "wr5"; return;
        case CV_ARM_WR6:  *out = "wr6"; return;
        case CV_ARM_WR7:  *out = "wr7"; return;
        case CV_ARM_WR8:  *out = "wr8"; return;
        case CV_ARM_WR9:  *out = "wr9"; return;
        case CV_ARM_WR10: *out = "wr10"; return;
        case CV_ARM_WR11: *out = "wr11"; return;
        case CV_ARM_WR12: *out = "wr12"; return;
        case CV_ARM_WR13: *out = "wr13"; return;
        case CV_ARM_WR14: *out = "wr14"; return;
        case CV_ARM_WR15: *out = "wr15"; return;

        // XSCALE Concan co-processor control registers
        case CV_ARM_WCID:    *out = "wcid"; return;
        case CV_ARM_WCON:    *out = "wcon"; return;
        case CV_ARM_WCSSF:   *out = "wcssf"; return;
        case CV_ARM_WCASF:   *out = "wcasf"; return;
        case CV_ARM_WC4:     *out = "wc4"; return;
        case CV_ARM_WC5:     *out = "wc5"; return;
        case CV_ARM_WC6:     *out = "wc6"; return;
        case CV_ARM_WC7:     *out = "wc7"; return;
        case CV_ARM_WCGR0:   *out = "wcgr0"; return;
        case CV_ARM_WCGR1:   *out = "wcgr1"; return;
        case CV_ARM_WCGR2:   *out = "wcgr2"; return;
        case CV_ARM_WCGR3:   *out = "wcgr3"; return;
        case CV_ARM_WC12:    *out = "wc12"; return;
        case CV_ARM_WC13:    *out = "wc13"; return;
        case CV_ARM_WC14:    *out = "wc14"; return;
        case CV_ARM_WC15:    *out = "wc15"; return;

        //
        // ARM VFPv3/Neon extended floating Point
        //

        case CV_ARM_FS32:    *out = "fs32"; return;
        case CV_ARM_FS33:    *out = "fs33"; return;
        case CV_ARM_FS34:    *out = "fs34"; return;
        case CV_ARM_FS35:    *out = "fs35"; return;
        case CV_ARM_FS36:    *out = "fs36"; return;
        case CV_ARM_FS37:    *out = "fs37"; return;
        case CV_ARM_FS38:    *out = "fs38"; return;
        case CV_ARM_FS39:    *out = "fs39"; return;
        case CV_ARM_FS40:    *out = "fs40"; return;
        case CV_ARM_FS41:    *out = "fs41"; return;
        case CV_ARM_FS42:    *out = "fs42"; return;
        case CV_ARM_FS43:    *out = "fs43"; return;
        case CV_ARM_FS44:    *out = "fs44"; return;
        case CV_ARM_FS45:    *out = "fs45"; return;
        case CV_ARM_FS46:    *out = "fs46"; return;
        case CV_ARM_FS47:    *out = "fs47"; return;
        case CV_ARM_FS48:    *out = "fs48"; return;
        case CV_ARM_FS49:    *out = "fs49"; return;
        case CV_ARM_FS50:    *out = "fs50"; return;
        case CV_ARM_FS51:    *out = "fs51"; return;
        case CV_ARM_FS52:    *out = "fs52"; return;
        case CV_ARM_FS53:    *out = "fs53"; return;
        case CV_ARM_FS54:    *out = "fs54"; return;
        case CV_ARM_FS55:    *out = "fs55"; return;
        case CV_ARM_FS56:    *out = "fs56"; return;
        case CV_ARM_FS57:    *out = "fs57"; return;
        case CV_ARM_FS58:    *out = "fs58"; return;
        case CV_ARM_FS59:    *out = "fs59"; return;
        case CV_ARM_FS60:    *out = "fs60"; return;
        case CV_ARM_FS61:    *out = "fs61"; return;
        case CV_ARM_FS62:    *out = "fs62"; return;
        case CV_ARM_FS63:    *out = "fs63"; return;

        // ARM double-precision floating point

        case CV_ARM_ND0:     *out = "nd0"; return;
        case CV_ARM_ND1:     *out = "nd1"; return;
        case CV_ARM_ND2:     *out = "nd2"; return;
        case CV_ARM_ND3:     *out = "nd3"; return;
        case CV_ARM_ND4:     *out = "nd4"; return;
        case CV_ARM_ND5:     *out = "nd5"; return;
        case CV_ARM_ND6:     *out = "nd6"; return;
        case CV_ARM_ND7:     *out = "nd7"; return;
        case CV_ARM_ND8:     *out = "nd8"; return;
        case CV_ARM_ND9:     *out = "nd9"; return;
        case CV_ARM_ND10:    *out = "nd10"; return;
        case CV_ARM_ND11:    *out = "nd11"; return;
        case CV_ARM_ND12:    *out = "nd12"; return;
        case CV_ARM_ND13:    *out = "nd13"; return;
        case CV_ARM_ND14:    *out = "nd14"; return;
        case CV_ARM_ND15:    *out = "nd15"; return;
        case CV_ARM_ND16:    *out = "nd16"; return;
        case CV_ARM_ND17:    *out = "nd17"; return;
        case CV_ARM_ND18:    *out = "nd18"; return;
        case CV_ARM_ND19:    *out = "nd19"; return;
        case CV_ARM_ND20:    *out = "nd20"; return;
        case CV_ARM_ND21:    *out = "nd21"; return;
        case CV_ARM_ND22:    *out = "nd22"; return;
        case CV_ARM_ND23:    *out = "nd23"; return;
        case CV_ARM_ND24:    *out = "nd24"; return;
        case CV_ARM_ND25:    *out = "nd25"; return;
        case CV_ARM_ND26:    *out = "nd26"; return;
        case CV_ARM_ND27:    *out = "nd27"; return;
        case CV_ARM_ND28:    *out = "nd28"; return;
        case CV_ARM_ND29:    *out = "nd29"; return;
        case CV_ARM_ND30:    *out = "nd30"; return;
        case CV_ARM_ND31:    *out = "nd31"; return;

        // ARM extended precision floating point

        case CV_ARM_NQ0:     *out = "nq0"; return;
        case CV_ARM_NQ1:     *out = "nq1"; return;
        case CV_ARM_NQ2:     *out = "nq2"; return;
        case CV_ARM_NQ3:     *out = "nq3"; return;
        case CV_ARM_NQ4:     *out = "nq4"; return;
        case CV_ARM_NQ5:     *out = "nq5"; return;
        case CV_ARM_NQ6:     *out = "nq6"; return;
        case CV_ARM_NQ7:     *out = "nq7"; return;
        case CV_ARM_NQ8:     *out = "nq8"; return;
        case CV_ARM_NQ9:     *out = "nq9"; return;
        case CV_ARM_NQ10:    *out = "nq10"; return;
        case CV_ARM_NQ11:    *out = "nq11"; return;
        case CV_ARM_NQ12:    *out = "nq12"; return;
        case CV_ARM_NQ13:    *out = "nq13"; return;
        case CV_ARM_NQ14:    *out = "nq14"; return;
        case CV_ARM_NQ15:    *out = "nq15"; return;

      }
      break;

    case CV_CFL_IA64:
//    case CV_CFL_IA64_1:
    case CV_CFL_IA64_2:
      //
      // Register set for Intel IA64
      //
      switch ( reg )
      {
        case CV_IA64_NOREG:  *out = "noreg"; return;

        // Branch Registers

        case CV_IA64_Br0:    *out = "br0"; return;
        case CV_IA64_Br1:    *out = "br1"; return;
        case CV_IA64_Br2:    *out = "br2"; return;
        case CV_IA64_Br3:    *out = "br3"; return;
        case CV_IA64_Br4:    *out = "br4"; return;
        case CV_IA64_Br5:    *out = "br5"; return;
        case CV_IA64_Br6:    *out = "br6"; return;
        case CV_IA64_Br7:    *out = "br7"; return;

        // Predicate Registers

        case CV_IA64_P0:     *out = "p0"; return;
        case CV_IA64_P1:     *out = "p1"; return;
        case CV_IA64_P2:     *out = "p2"; return;
        case CV_IA64_P3:     *out = "p3"; return;
        case CV_IA64_P4:     *out = "p4"; return;
        case CV_IA64_P5:     *out = "p5"; return;
        case CV_IA64_P6:     *out = "p6"; return;
        case CV_IA64_P7:     *out = "p7"; return;
        case CV_IA64_P8:     *out = "p8"; return;
        case CV_IA64_P9:     *out = "p9"; return;
        case CV_IA64_P10:    *out = "p10"; return;
        case CV_IA64_P11:    *out = "p11"; return;
        case CV_IA64_P12:    *out = "p12"; return;
        case CV_IA64_P13:    *out = "p13"; return;
        case CV_IA64_P14:    *out = "p14"; return;
        case CV_IA64_P15:    *out = "p15"; return;
        case CV_IA64_P16:    *out = "p16"; return;
        case CV_IA64_P17:    *out = "p17"; return;
        case CV_IA64_P18:    *out = "p18"; return;
        case CV_IA64_P19:    *out = "p19"; return;
        case CV_IA64_P20:    *out = "p20"; return;
        case CV_IA64_P21:    *out = "p21"; return;
        case CV_IA64_P22:    *out = "p22"; return;
        case CV_IA64_P23:    *out = "p23"; return;
        case CV_IA64_P24:    *out = "p24"; return;
        case CV_IA64_P25:    *out = "p25"; return;
        case CV_IA64_P26:    *out = "p26"; return;
        case CV_IA64_P27:    *out = "p27"; return;
        case CV_IA64_P28:    *out = "p28"; return;
        case CV_IA64_P29:    *out = "p29"; return;
        case CV_IA64_P30:    *out = "p30"; return;
        case CV_IA64_P31:    *out = "p31"; return;
        case CV_IA64_P32:    *out = "p32"; return;
        case CV_IA64_P33:    *out = "p33"; return;
        case CV_IA64_P34:    *out = "p34"; return;
        case CV_IA64_P35:    *out = "p35"; return;
        case CV_IA64_P36:    *out = "p36"; return;
        case CV_IA64_P37:    *out = "p37"; return;
        case CV_IA64_P38:    *out = "p38"; return;
        case CV_IA64_P39:    *out = "p39"; return;
        case CV_IA64_P40:    *out = "p40"; return;
        case CV_IA64_P41:    *out = "p41"; return;
        case CV_IA64_P42:    *out = "p42"; return;
        case CV_IA64_P43:    *out = "p43"; return;
        case CV_IA64_P44:    *out = "p44"; return;
        case CV_IA64_P45:    *out = "p45"; return;
        case CV_IA64_P46:    *out = "p46"; return;
        case CV_IA64_P47:    *out = "p47"; return;
        case CV_IA64_P48:    *out = "p48"; return;
        case CV_IA64_P49:    *out = "p49"; return;
        case CV_IA64_P50:    *out = "p50"; return;
        case CV_IA64_P51:    *out = "p51"; return;
        case CV_IA64_P52:    *out = "p52"; return;
        case CV_IA64_P53:    *out = "p53"; return;
        case CV_IA64_P54:    *out = "p54"; return;
        case CV_IA64_P55:    *out = "p55"; return;
        case CV_IA64_P56:    *out = "p56"; return;
        case CV_IA64_P57:    *out = "p57"; return;
        case CV_IA64_P58:    *out = "p58"; return;
        case CV_IA64_P59:    *out = "p59"; return;
        case CV_IA64_P60:    *out = "p60"; return;
        case CV_IA64_P61:    *out = "p61"; return;
        case CV_IA64_P62:    *out = "p62"; return;
        case CV_IA64_P63:    *out = "p63"; return;

        case CV_IA64_Preds:  *out = "Preds"; return;

        // Banked General Registers

        case CV_IA64_IntH0:  *out = "IntH0"; return;
        case CV_IA64_IntH1:  *out = "IntH1"; return;
        case CV_IA64_IntH2:  *out = "IntH2"; return;
        case CV_IA64_IntH3:  *out = "IntH3"; return;
        case CV_IA64_IntH4:  *out = "IntH4"; return;
        case CV_IA64_IntH5:  *out = "IntH5"; return;
        case CV_IA64_IntH6:  *out = "IntH6"; return;
        case CV_IA64_IntH7:  *out = "IntH7"; return;
        case CV_IA64_IntH8:  *out = "IntH8"; return;
        case CV_IA64_IntH9:  *out = "IntH9"; return;
        case CV_IA64_IntH10: *out = "IntH10"; return;
        case CV_IA64_IntH11: *out = "IntH11"; return;
        case CV_IA64_IntH12: *out = "IntH12"; return;
        case CV_IA64_IntH13: *out = "IntH13"; return;
        case CV_IA64_IntH14: *out = "IntH14"; return;
        case CV_IA64_IntH15: *out = "IntH15"; return;

        // Special Registers

        case CV_IA64_Ip:     *out = "Ip"; return;
        case CV_IA64_Umask:  *out = "Umask"; return;
        case CV_IA64_Cfm:    *out = "Cfm"; return;
        case CV_IA64_Psr:    *out = "Psr"; return;

        // Banked General Registers

        case CV_IA64_Nats:   *out = "Nats"; return;
        case CV_IA64_Nats2:  *out = "Nats2"; return;
        case CV_IA64_Nats3:  *out = "Nats3"; return;

        // General-Purpose Registers

        // Integer registers
        case CV_IA64_IntR0:  *out = "IntR0"; return;
        case CV_IA64_IntR1:  *out = "IntR1"; return;
        case CV_IA64_IntR2:  *out = "IntR2"; return;
        case CV_IA64_IntR3:  *out = "IntR3"; return;
        case CV_IA64_IntR4:  *out = "IntR4"; return;
        case CV_IA64_IntR5:  *out = "IntR5"; return;
        case CV_IA64_IntR6:  *out = "IntR6"; return;
        case CV_IA64_IntR7:  *out = "IntR7"; return;
        case CV_IA64_IntR8:  *out = "IntR8"; return;
        case CV_IA64_IntR9:  *out = "IntR9"; return;
        case CV_IA64_IntR10: *out = "IntR10"; return;
        case CV_IA64_IntR11: *out = "IntR11"; return;
        case CV_IA64_IntR12: *out = "IntR12"; return;
        case CV_IA64_IntR13: *out = "IntR13"; return;
        case CV_IA64_IntR14: *out = "IntR14"; return;
        case CV_IA64_IntR15: *out = "IntR15"; return;
        case CV_IA64_IntR16: *out = "IntR16"; return;
        case CV_IA64_IntR17: *out = "IntR17"; return;
        case CV_IA64_IntR18: *out = "IntR18"; return;
        case CV_IA64_IntR19: *out = "IntR19"; return;
        case CV_IA64_IntR20: *out = "IntR20"; return;
        case CV_IA64_IntR21: *out = "IntR21"; return;
        case CV_IA64_IntR22: *out = "IntR22"; return;
        case CV_IA64_IntR23: *out = "IntR23"; return;
        case CV_IA64_IntR24: *out = "IntR24"; return;
        case CV_IA64_IntR25: *out = "IntR25"; return;
        case CV_IA64_IntR26: *out = "IntR26"; return;
        case CV_IA64_IntR27: *out = "IntR27"; return;
        case CV_IA64_IntR28: *out = "IntR28"; return;
        case CV_IA64_IntR29: *out = "IntR29"; return;
        case CV_IA64_IntR30: *out = "IntR30"; return;
        case CV_IA64_IntR31: *out = "IntR31"; return;

        // Register Stack
        case CV_IA64_IntR32: *out = "IntR32"; return;
        case CV_IA64_IntR33: *out = "IntR33"; return;
        case CV_IA64_IntR34: *out = "IntR34"; return;
        case CV_IA64_IntR35: *out = "IntR35"; return;
        case CV_IA64_IntR36: *out = "IntR36"; return;
        case CV_IA64_IntR37: *out = "IntR37"; return;
        case CV_IA64_IntR38: *out = "IntR38"; return;
        case CV_IA64_IntR39: *out = "IntR39"; return;
        case CV_IA64_IntR40: *out = "IntR40"; return;
        case CV_IA64_IntR41: *out = "IntR41"; return;
        case CV_IA64_IntR42: *out = "IntR42"; return;
        case CV_IA64_IntR43: *out = "IntR43"; return;
        case CV_IA64_IntR44: *out = "IntR44"; return;
        case CV_IA64_IntR45: *out = "IntR45"; return;
        case CV_IA64_IntR46: *out = "IntR46"; return;
        case CV_IA64_IntR47: *out = "IntR47"; return;
        case CV_IA64_IntR48: *out = "IntR48"; return;
        case CV_IA64_IntR49: *out = "IntR49"; return;
        case CV_IA64_IntR50: *out = "IntR50"; return;
        case CV_IA64_IntR51: *out = "IntR51"; return;
        case CV_IA64_IntR52: *out = "IntR52"; return;
        case CV_IA64_IntR53: *out = "IntR53"; return;
        case CV_IA64_IntR54: *out = "IntR54"; return;
        case CV_IA64_IntR55: *out = "IntR55"; return;
        case CV_IA64_IntR56: *out = "IntR56"; return;
        case CV_IA64_IntR57: *out = "IntR57"; return;
        case CV_IA64_IntR58: *out = "IntR58"; return;
        case CV_IA64_IntR59: *out = "IntR59"; return;
        case CV_IA64_IntR60: *out = "IntR60"; return;
        case CV_IA64_IntR61: *out = "IntR61"; return;
        case CV_IA64_IntR62: *out = "IntR62"; return;
        case CV_IA64_IntR63: *out = "IntR63"; return;
        case CV_IA64_IntR64: *out = "IntR64"; return;
        case CV_IA64_IntR65: *out = "IntR65"; return;
        case CV_IA64_IntR66: *out = "IntR66"; return;
        case CV_IA64_IntR67: *out = "IntR67"; return;
        case CV_IA64_IntR68: *out = "IntR68"; return;
        case CV_IA64_IntR69: *out = "IntR69"; return;
        case CV_IA64_IntR70: *out = "IntR70"; return;
        case CV_IA64_IntR71: *out = "IntR71"; return;
        case CV_IA64_IntR72: *out = "IntR72"; return;
        case CV_IA64_IntR73: *out = "IntR73"; return;
        case CV_IA64_IntR74: *out = "IntR74"; return;
        case CV_IA64_IntR75: *out = "IntR75"; return;
        case CV_IA64_IntR76: *out = "IntR76"; return;
        case CV_IA64_IntR77: *out = "IntR77"; return;
        case CV_IA64_IntR78: *out = "IntR78"; return;
        case CV_IA64_IntR79: *out = "IntR79"; return;
        case CV_IA64_IntR80: *out = "IntR80"; return;
        case CV_IA64_IntR81: *out = "IntR81"; return;
        case CV_IA64_IntR82: *out = "IntR82"; return;
        case CV_IA64_IntR83: *out = "IntR83"; return;
        case CV_IA64_IntR84: *out = "IntR84"; return;
        case CV_IA64_IntR85: *out = "IntR85"; return;
        case CV_IA64_IntR86: *out = "IntR86"; return;
        case CV_IA64_IntR87: *out = "IntR87"; return;
        case CV_IA64_IntR88: *out = "IntR88"; return;
        case CV_IA64_IntR89: *out = "IntR89"; return;
        case CV_IA64_IntR90: *out = "IntR90"; return;
        case CV_IA64_IntR91: *out = "IntR91"; return;
        case CV_IA64_IntR92: *out = "IntR92"; return;
        case CV_IA64_IntR93: *out = "IntR93"; return;
        case CV_IA64_IntR94: *out = "IntR94"; return;
        case CV_IA64_IntR95: *out = "IntR95"; return;
        case CV_IA64_IntR96: *out = "IntR96"; return;
        case CV_IA64_IntR97: *out = "IntR97"; return;
        case CV_IA64_IntR98: *out = "IntR98"; return;
        case CV_IA64_IntR99: *out = "IntR99"; return;
        case CV_IA64_IntR100:*out = "IntR100"; return;
        case CV_IA64_IntR101:*out = "IntR101"; return;
        case CV_IA64_IntR102:*out = "IntR102"; return;
        case CV_IA64_IntR103:*out = "IntR103"; return;
        case CV_IA64_IntR104:*out = "IntR104"; return;
        case CV_IA64_IntR105:*out = "IntR105"; return;
        case CV_IA64_IntR106:*out = "IntR106"; return;
        case CV_IA64_IntR107:*out = "IntR107"; return;
        case CV_IA64_IntR108:*out = "IntR108"; return;
        case CV_IA64_IntR109:*out = "IntR109"; return;
        case CV_IA64_IntR110:*out = "IntR110"; return;
        case CV_IA64_IntR111:*out = "IntR111"; return;
        case CV_IA64_IntR112:*out = "IntR112"; return;
        case CV_IA64_IntR113:*out = "IntR113"; return;
        case CV_IA64_IntR114:*out = "IntR114"; return;
        case CV_IA64_IntR115:*out = "IntR115"; return;
        case CV_IA64_IntR116:*out = "IntR116"; return;
        case CV_IA64_IntR117:*out = "IntR117"; return;
        case CV_IA64_IntR118:*out = "IntR118"; return;
        case CV_IA64_IntR119:*out = "IntR119"; return;
        case CV_IA64_IntR120:*out = "IntR120"; return;
        case CV_IA64_IntR121:*out = "IntR121"; return;
        case CV_IA64_IntR122:*out = "IntR122"; return;
        case CV_IA64_IntR123:*out = "IntR123"; return;
        case CV_IA64_IntR124:*out = "IntR124"; return;
        case CV_IA64_IntR125:*out = "IntR125"; return;
        case CV_IA64_IntR126:*out = "IntR126"; return;
        case CV_IA64_IntR127:*out = "IntR127"; return;

        // Floating-Point Registers

        // Low Floating Point Registers
        case CV_IA64_FltF0:  *out = "FltF0"; return;
        case CV_IA64_FltF1:  *out = "FltF1"; return;
        case CV_IA64_FltF2:  *out = "FltF2"; return;
        case CV_IA64_FltF3:  *out = "FltF3"; return;
        case CV_IA64_FltF4:  *out = "FltF4"; return;
        case CV_IA64_FltF5:  *out = "FltF5"; return;
        case CV_IA64_FltF6:  *out = "FltF6"; return;
        case CV_IA64_FltF7:  *out = "FltF7"; return;
        case CV_IA64_FltF8:  *out = "FltF8"; return;
        case CV_IA64_FltF9:  *out = "FltF9"; return;
        case CV_IA64_FltF10: *out = "FltF10"; return;
        case CV_IA64_FltF11: *out = "FltF11"; return;
        case CV_IA64_FltF12: *out = "FltF12"; return;
        case CV_IA64_FltF13: *out = "FltF13"; return;
        case CV_IA64_FltF14: *out = "FltF14"; return;
        case CV_IA64_FltF15: *out = "FltF15"; return;
        case CV_IA64_FltF16: *out = "FltF16"; return;
        case CV_IA64_FltF17: *out = "FltF17"; return;
        case CV_IA64_FltF18: *out = "FltF18"; return;
        case CV_IA64_FltF19: *out = "FltF19"; return;
        case CV_IA64_FltF20: *out = "FltF20"; return;
        case CV_IA64_FltF21: *out = "FltF21"; return;
        case CV_IA64_FltF22: *out = "FltF22"; return;
        case CV_IA64_FltF23: *out = "FltF23"; return;
        case CV_IA64_FltF24: *out = "FltF24"; return;
        case CV_IA64_FltF25: *out = "FltF25"; return;
        case CV_IA64_FltF26: *out = "FltF26"; return;
        case CV_IA64_FltF27: *out = "FltF27"; return;
        case CV_IA64_FltF28: *out = "FltF28"; return;
        case CV_IA64_FltF29: *out = "FltF29"; return;
        case CV_IA64_FltF30: *out = "FltF30"; return;
        case CV_IA64_FltF31: *out = "FltF31"; return;

        // High Floating Point Registers
        case CV_IA64_FltF32: *out = "FltF32"; return;
        case CV_IA64_FltF33: *out = "FltF33"; return;
        case CV_IA64_FltF34: *out = "FltF34"; return;
        case CV_IA64_FltF35: *out = "FltF35"; return;
        case CV_IA64_FltF36: *out = "FltF36"; return;
        case CV_IA64_FltF37: *out = "FltF37"; return;
        case CV_IA64_FltF38: *out = "FltF38"; return;
        case CV_IA64_FltF39: *out = "FltF39"; return;
        case CV_IA64_FltF40: *out = "FltF40"; return;
        case CV_IA64_FltF41: *out = "FltF41"; return;
        case CV_IA64_FltF42: *out = "FltF42"; return;
        case CV_IA64_FltF43: *out = "FltF43"; return;
        case CV_IA64_FltF44: *out = "FltF44"; return;
        case CV_IA64_FltF45: *out = "FltF45"; return;
        case CV_IA64_FltF46: *out = "FltF46"; return;
        case CV_IA64_FltF47: *out = "FltF47"; return;
        case CV_IA64_FltF48: *out = "FltF48"; return;
        case CV_IA64_FltF49: *out = "FltF49"; return;
        case CV_IA64_FltF50: *out = "FltF50"; return;
        case CV_IA64_FltF51: *out = "FltF51"; return;
        case CV_IA64_FltF52: *out = "FltF52"; return;
        case CV_IA64_FltF53: *out = "FltF53"; return;
        case CV_IA64_FltF54: *out = "FltF54"; return;
        case CV_IA64_FltF55: *out = "FltF55"; return;
        case CV_IA64_FltF56: *out = "FltF56"; return;
        case CV_IA64_FltF57: *out = "FltF57"; return;
        case CV_IA64_FltF58: *out = "FltF58"; return;
        case CV_IA64_FltF59: *out = "FltF59"; return;
        case CV_IA64_FltF60: *out = "FltF60"; return;
        case CV_IA64_FltF61: *out = "FltF61"; return;
        case CV_IA64_FltF62: *out = "FltF62"; return;
        case CV_IA64_FltF63: *out = "FltF63"; return;
        case CV_IA64_FltF64: *out = "FltF64"; return;
        case CV_IA64_FltF65: *out = "FltF65"; return;
        case CV_IA64_FltF66: *out = "FltF66"; return;
        case CV_IA64_FltF67: *out = "FltF67"; return;
        case CV_IA64_FltF68: *out = "FltF68"; return;
        case CV_IA64_FltF69: *out = "FltF69"; return;
        case CV_IA64_FltF70: *out = "FltF70"; return;
        case CV_IA64_FltF71: *out = "FltF71"; return;
        case CV_IA64_FltF72: *out = "FltF72"; return;
        case CV_IA64_FltF73: *out = "FltF73"; return;
        case CV_IA64_FltF74: *out = "FltF74"; return;
        case CV_IA64_FltF75: *out = "FltF75"; return;
        case CV_IA64_FltF76: *out = "FltF76"; return;
        case CV_IA64_FltF77: *out = "FltF77"; return;
        case CV_IA64_FltF78: *out = "FltF78"; return;
        case CV_IA64_FltF79: *out = "FltF79"; return;
        case CV_IA64_FltF80: *out = "FltF80"; return;
        case CV_IA64_FltF81: *out = "FltF81"; return;
        case CV_IA64_FltF82: *out = "FltF82"; return;
        case CV_IA64_FltF83: *out = "FltF83"; return;
        case CV_IA64_FltF84: *out = "FltF84"; return;
        case CV_IA64_FltF85: *out = "FltF85"; return;
        case CV_IA64_FltF86: *out = "FltF86"; return;
        case CV_IA64_FltF87: *out = "FltF87"; return;
        case CV_IA64_FltF88: *out = "FltF88"; return;
        case CV_IA64_FltF89: *out = "FltF89"; return;
        case CV_IA64_FltF90: *out = "FltF90"; return;
        case CV_IA64_FltF91: *out = "FltF91"; return;
        case CV_IA64_FltF92: *out = "FltF92"; return;
        case CV_IA64_FltF93: *out = "FltF93"; return;
        case CV_IA64_FltF94: *out = "FltF94"; return;
        case CV_IA64_FltF95: *out = "FltF95"; return;
        case CV_IA64_FltF96: *out = "FltF96"; return;
        case CV_IA64_FltF97: *out = "FltF97"; return;
        case CV_IA64_FltF98: *out = "FltF98"; return;
        case CV_IA64_FltF99: *out = "FltF99"; return;
        case CV_IA64_FltF100:*out = "FltF100"; return;
        case CV_IA64_FltF101:*out = "FltF101"; return;
        case CV_IA64_FltF102:*out = "FltF102"; return;
        case CV_IA64_FltF103:*out = "FltF103"; return;
        case CV_IA64_FltF104:*out = "FltF104"; return;
        case CV_IA64_FltF105:*out = "FltF105"; return;
        case CV_IA64_FltF106:*out = "FltF106"; return;
        case CV_IA64_FltF107:*out = "FltF107"; return;
        case CV_IA64_FltF108:*out = "FltF108"; return;
        case CV_IA64_FltF109:*out = "FltF109"; return;
        case CV_IA64_FltF110:*out = "FltF110"; return;
        case CV_IA64_FltF111:*out = "FltF111"; return;
        case CV_IA64_FltF112:*out = "FltF112"; return;
        case CV_IA64_FltF113:*out = "FltF113"; return;
        case CV_IA64_FltF114:*out = "FltF114"; return;
        case CV_IA64_FltF115:*out = "FltF115"; return;
        case CV_IA64_FltF116:*out = "FltF116"; return;
        case CV_IA64_FltF117:*out = "FltF117"; return;
        case CV_IA64_FltF118:*out = "FltF118"; return;
        case CV_IA64_FltF119:*out = "FltF119"; return;
        case CV_IA64_FltF120:*out = "FltF120"; return;
        case CV_IA64_FltF121:*out = "FltF121"; return;
        case CV_IA64_FltF122:*out = "FltF122"; return;
        case CV_IA64_FltF123:*out = "FltF123"; return;
        case CV_IA64_FltF124:*out = "FltF124"; return;
        case CV_IA64_FltF125:*out = "FltF125"; return;
        case CV_IA64_FltF126:*out = "FltF126"; return;
        case CV_IA64_FltF127:*out = "FltF127"; return;

        // Application Registers

        case CV_IA64_ApKR0:  *out = "ApKR0"; return;
        case CV_IA64_ApKR1:  *out = "ApKR1"; return;
        case CV_IA64_ApKR2:  *out = "ApKR2"; return;
        case CV_IA64_ApKR3:  *out = "ApKR3"; return;
        case CV_IA64_ApKR4:  *out = "ApKR4"; return;
        case CV_IA64_ApKR5:  *out = "ApKR5"; return;
        case CV_IA64_ApKR6:  *out = "ApKR6"; return;
        case CV_IA64_ApKR7:  *out = "ApKR7"; return;
        case CV_IA64_AR8:    *out = "AR8"; return;
        case CV_IA64_AR9:    *out = "AR9"; return;
        case CV_IA64_AR10:   *out = "AR10"; return;
        case CV_IA64_AR11:   *out = "AR11"; return;
        case CV_IA64_AR12:   *out = "AR12"; return;
        case CV_IA64_AR13:   *out = "AR13"; return;
        case CV_IA64_AR14:   *out = "AR14"; return;
        case CV_IA64_AR15:   *out = "AR15"; return;
        case CV_IA64_RsRSC:  *out = "RsRSC"; return;
        case CV_IA64_RsBSP:  *out = "RsBSP"; return;
        case CV_IA64_RsBSPSTORE:*out = "RsBSPSTORE"; return;
        case CV_IA64_RsRNAT: *out = "rsrnat"; return;
        case CV_IA64_AR20:   *out = "ar20"; return;
        case CV_IA64_StFCR:  *out = "stfcr"; return;
        case CV_IA64_AR22:   *out = "ar22"; return;
        case CV_IA64_AR23:   *out = "ar23"; return;
        case CV_IA64_EFLAG:  *out = "eflag"; return;
        case CV_IA64_CSD:    *out = "csd"; return;
        case CV_IA64_SSD:    *out = "ssd"; return;
        case CV_IA64_CFLG:   *out = "cflg"; return;
        case CV_IA64_StFSR:  *out = "stfsr"; return;
        case CV_IA64_StFIR:  *out = "stfir"; return;
        case CV_IA64_StFDR:  *out = "stfdr"; return;
        case CV_IA64_AR31:   *out = "ar31"; return;
        case CV_IA64_ApCCV:  *out = "apccv"; return;
        case CV_IA64_AR33:   *out = "ar33"; return;
        case CV_IA64_AR34:   *out = "ar34"; return;
        case CV_IA64_AR35:   *out = "ar35"; return;
        case CV_IA64_ApUNAT: *out = "apunat"; return;
        case CV_IA64_AR37:   *out = "ar37"; return;
        case CV_IA64_AR38:   *out = "ar38"; return;
        case CV_IA64_AR39:   *out = "ar39"; return;
        case CV_IA64_StFPSR: *out = "stfpsr"; return;
        case CV_IA64_AR41:   *out = "ar41"; return;
        case CV_IA64_AR42:   *out = "ar42"; return;
        case CV_IA64_AR43:   *out = "ar43"; return;
        case CV_IA64_ApITC:  *out = "apitc"; return;
        case CV_IA64_AR45:   *out = "ar45"; return;
        case CV_IA64_AR46:   *out = "ar46"; return;
        case CV_IA64_AR47:   *out = "ar47"; return;
        case CV_IA64_AR48:   *out = "ar48"; return;
        case CV_IA64_AR49:   *out = "ar49"; return;
        case CV_IA64_AR50:   *out = "ar50"; return;
        case CV_IA64_AR51:   *out = "ar51"; return;
        case CV_IA64_AR52:   *out = "ar52"; return;
        case CV_IA64_AR53:   *out = "ar53"; return;
        case CV_IA64_AR54:   *out = "ar54"; return;
        case CV_IA64_AR55:   *out = "ar55"; return;
        case CV_IA64_AR56:   *out = "ar56"; return;
        case CV_IA64_AR57:   *out = "ar57"; return;
        case CV_IA64_AR58:   *out = "ar58"; return;
        case CV_IA64_AR59:   *out = "ar59"; return;
        case CV_IA64_AR60:   *out = "ar60"; return;
        case CV_IA64_AR61:   *out = "ar61"; return;
        case CV_IA64_AR62:   *out = "ar62"; return;
        case CV_IA64_AR63:   *out = "ar63"; return;
        case CV_IA64_RsPFS:  *out = "rspfs"; return;
        case CV_IA64_ApLC:   *out = "aplc"; return;
        case CV_IA64_ApEC:   *out = "apec"; return;
        case CV_IA64_AR67:   *out = "ar67"; return;
        case CV_IA64_AR68:   *out = "ar68"; return;
        case CV_IA64_AR69:   *out = "ar69"; return;
        case CV_IA64_AR70:   *out = "ar70"; return;
        case CV_IA64_AR71:   *out = "ar71"; return;
        case CV_IA64_AR72:   *out = "ar72"; return;
        case CV_IA64_AR73:   *out = "ar73"; return;
        case CV_IA64_AR74:   *out = "ar74"; return;
        case CV_IA64_AR75:   *out = "ar75"; return;
        case CV_IA64_AR76:   *out = "ar76"; return;
        case CV_IA64_AR77:   *out = "ar77"; return;
        case CV_IA64_AR78:   *out = "ar78"; return;
        case CV_IA64_AR79:   *out = "ar79"; return;
        case CV_IA64_AR80:   *out = "ar80"; return;
        case CV_IA64_AR81:   *out = "ar81"; return;
        case CV_IA64_AR82:   *out = "ar82"; return;
        case CV_IA64_AR83:   *out = "ar83"; return;
        case CV_IA64_AR84:   *out = "ar84"; return;
        case CV_IA64_AR85:   *out = "ar85"; return;
        case CV_IA64_AR86:   *out = "ar86"; return;
        case CV_IA64_AR87:   *out = "ar87"; return;
        case CV_IA64_AR88:   *out = "ar88"; return;
        case CV_IA64_AR89:   *out = "ar89"; return;
        case CV_IA64_AR90:   *out = "ar90"; return;
        case CV_IA64_AR91:   *out = "ar91"; return;
        case CV_IA64_AR92:   *out = "ar92"; return;
        case CV_IA64_AR93:   *out = "ar93"; return;
        case CV_IA64_AR94:   *out = "ar94"; return;
        case CV_IA64_AR95:   *out = "ar95"; return;
        case CV_IA64_AR96:   *out = "ar96"; return;
        case CV_IA64_AR97:   *out = "ar97"; return;
        case CV_IA64_AR98:   *out = "ar98"; return;
        case CV_IA64_AR99:   *out = "ar99"; return;
        case CV_IA64_AR100:  *out = "ar100"; return;
        case CV_IA64_AR101:  *out = "ar101"; return;
        case CV_IA64_AR102:  *out = "ar102"; return;
        case CV_IA64_AR103:  *out = "ar103"; return;
        case CV_IA64_AR104:  *out = "ar104"; return;
        case CV_IA64_AR105:  *out = "ar105"; return;
        case CV_IA64_AR106:  *out = "ar106"; return;
        case CV_IA64_AR107:  *out = "ar107"; return;
        case CV_IA64_AR108:  *out = "ar108"; return;
        case CV_IA64_AR109:  *out = "ar109"; return;
        case CV_IA64_AR110:  *out = "ar110"; return;
        case CV_IA64_AR111:  *out = "ar111"; return;
        case CV_IA64_AR112:  *out = "ar112"; return;
        case CV_IA64_AR113:  *out = "ar113"; return;
        case CV_IA64_AR114:  *out = "ar114"; return;
        case CV_IA64_AR115:  *out = "ar115"; return;
        case CV_IA64_AR116:  *out = "ar116"; return;
        case CV_IA64_AR117:  *out = "ar117"; return;
        case CV_IA64_AR118:  *out = "ar118"; return;
        case CV_IA64_AR119:  *out = "ar119"; return;
        case CV_IA64_AR120:  *out = "ar120"; return;
        case CV_IA64_AR121:  *out = "ar121"; return;
        case CV_IA64_AR122:  *out = "ar122"; return;
        case CV_IA64_AR123:  *out = "ar123"; return;
        case CV_IA64_AR124:  *out = "ar124"; return;
        case CV_IA64_AR125:  *out = "ar125"; return;
        case CV_IA64_AR126:  *out = "ar126"; return;
        case CV_IA64_AR127:  *out = "ar127"; return;

        // CPUID Registers

        case CV_IA64_CPUID0: *out = "cpuid0"; return;
        case CV_IA64_CPUID1: *out = "cpuid1"; return;
        case CV_IA64_CPUID2: *out = "cpuid2"; return;
        case CV_IA64_CPUID3: *out = "cpuid3"; return;
        case CV_IA64_CPUID4: *out = "cpuid4"; return;

        // Control Registers

        case CV_IA64_ApDCR:  *out = "apdcr"; return;
        case CV_IA64_ApITM:  *out = "apitm"; return;
        case CV_IA64_ApIVA:  *out = "apiva"; return;
        case CV_IA64_CR3:    *out = "cr3"; return;
        case CV_IA64_CR4:    *out = "cr4"; return;
        case CV_IA64_CR5:    *out = "cr5"; return;
        case CV_IA64_CR6:    *out = "cr6"; return;
        case CV_IA64_CR7:    *out = "cr7"; return;
        case CV_IA64_ApPTA:  *out = "appta"; return;
        case CV_IA64_ApGPTA: *out = "apgpta"; return;
        case CV_IA64_CR10:   *out = "cr10"; return;
        case CV_IA64_CR11:   *out = "cr11"; return;
        case CV_IA64_CR12:   *out = "cr12"; return;
        case CV_IA64_CR13:   *out = "cr13"; return;
        case CV_IA64_CR14:   *out = "cr14"; return;
        case CV_IA64_CR15:   *out = "cr15"; return;
        case CV_IA64_StIPSR: *out = "stipsr"; return;
        case CV_IA64_StISR:  *out = "stisr"; return;
        case CV_IA64_CR18:   *out = "cr18"; return;
        case CV_IA64_StIIP:  *out = "stiip"; return;
        case CV_IA64_StIFA:  *out = "stifa"; return;
        case CV_IA64_StITIR: *out = "stitir"; return;
        case CV_IA64_StIIPA: *out = "stiipa"; return;
        case CV_IA64_StIFS:  *out = "stifs"; return;
        case CV_IA64_StIIM:  *out = "stiim"; return;
        case CV_IA64_StIHA:  *out = "stiha"; return;
        case CV_IA64_CR26:   *out = "cr26"; return;
        case CV_IA64_CR27:   *out = "cr27"; return;
        case CV_IA64_CR28:   *out = "cr28"; return;
        case CV_IA64_CR29:   *out = "cr29"; return;
        case CV_IA64_CR30:   *out = "cr30"; return;
        case CV_IA64_CR31:   *out = "cr31"; return;
        case CV_IA64_CR32:   *out = "cr32"; return;
        case CV_IA64_CR33:   *out = "cr33"; return;
        case CV_IA64_CR34:   *out = "cr34"; return;
        case CV_IA64_CR35:   *out = "cr35"; return;
        case CV_IA64_CR36:   *out = "cr36"; return;
        case CV_IA64_CR37:   *out = "cr37"; return;
        case CV_IA64_CR38:   *out = "cr38"; return;
        case CV_IA64_CR39:   *out = "cr39"; return;
        case CV_IA64_CR40:   *out = "cr40"; return;
        case CV_IA64_CR41:   *out = "cr41"; return;
        case CV_IA64_CR42:   *out = "cr42"; return;
        case CV_IA64_CR43:   *out = "cr43"; return;
        case CV_IA64_CR44:   *out = "cr44"; return;
        case CV_IA64_CR45:   *out = "cr45"; return;
        case CV_IA64_CR46:   *out = "cr46"; return;
        case CV_IA64_CR47:   *out = "cr47"; return;
        case CV_IA64_CR48:   *out = "cr48"; return;
        case CV_IA64_CR49:   *out = "cr49"; return;
        case CV_IA64_CR50:   *out = "cr50"; return;
        case CV_IA64_CR51:   *out = "cr51"; return;
        case CV_IA64_CR52:   *out = "cr52"; return;
        case CV_IA64_CR53:   *out = "cr53"; return;
        case CV_IA64_CR54:   *out = "cr54"; return;
        case CV_IA64_CR55:   *out = "cr55"; return;
        case CV_IA64_CR56:   *out = "cr56"; return;
        case CV_IA64_CR57:   *out = "cr57"; return;
        case CV_IA64_CR58:   *out = "cr58"; return;
        case CV_IA64_CR59:   *out = "cr59"; return;
        case CV_IA64_CR60:   *out = "cr60"; return;
        case CV_IA64_CR61:   *out = "cr61"; return;
        case CV_IA64_CR62:   *out = "cr62"; return;
        case CV_IA64_CR63:   *out = "cr63"; return;
        case CV_IA64_SaLID:  *out = "salid"; return;
        case CV_IA64_SaIVR:  *out = "saivr"; return;
        case CV_IA64_SaTPR:  *out = "satpr"; return;
        case CV_IA64_SaEOI:  *out = "saeoi"; return;
        case CV_IA64_SaIRR0: *out = "sairr0"; return;
        case CV_IA64_SaIRR1: *out = "sairr1"; return;
        case CV_IA64_SaIRR2: *out = "sairr2"; return;
        case CV_IA64_SaIRR3: *out = "sairr3"; return;
        case CV_IA64_SaITV:  *out = "saitv"; return;
        case CV_IA64_SaPMV:  *out = "sapmv"; return;
        case CV_IA64_SaCMCV: *out = "sacmcv"; return;
        case CV_IA64_CR75:   *out = "cr75"; return;
        case CV_IA64_CR76:   *out = "cr76"; return;
        case CV_IA64_CR77:   *out = "cr77"; return;
        case CV_IA64_CR78:   *out = "cr78"; return;
        case CV_IA64_CR79:   *out = "cr79"; return;
        case CV_IA64_SaLRR0: *out = "salrr0"; return;
        case CV_IA64_SaLRR1: *out = "salrr1"; return;
        case CV_IA64_CR82:   *out = "cr82"; return;
        case CV_IA64_CR83:   *out = "cr83"; return;
        case CV_IA64_CR84:   *out = "cr84"; return;
        case CV_IA64_CR85:   *out = "cr85"; return;
        case CV_IA64_CR86:   *out = "cr86"; return;
        case CV_IA64_CR87:   *out = "cr87"; return;
        case CV_IA64_CR88:   *out = "cr88"; return;
        case CV_IA64_CR89:   *out = "cr89"; return;
        case CV_IA64_CR90:   *out = "cr90"; return;
        case CV_IA64_CR91:   *out = "cr91"; return;
        case CV_IA64_CR92:   *out = "cr92"; return;
        case CV_IA64_CR93:   *out = "cr93"; return;
        case CV_IA64_CR94:   *out = "cr94"; return;
        case CV_IA64_CR95:   *out = "cr95"; return;
        case CV_IA64_CR96:   *out = "cr96"; return;
        case CV_IA64_CR97:   *out = "cr97"; return;
        case CV_IA64_CR98:   *out = "cr98"; return;
        case CV_IA64_CR99:   *out = "cr99"; return;
        case CV_IA64_CR100:  *out = "cr100"; return;
        case CV_IA64_CR101:  *out = "cr101"; return;
        case CV_IA64_CR102:  *out = "cr102"; return;
        case CV_IA64_CR103:  *out = "cr103"; return;
        case CV_IA64_CR104:  *out = "cr104"; return;
        case CV_IA64_CR105:  *out = "cr105"; return;
        case CV_IA64_CR106:  *out = "cr106"; return;
        case CV_IA64_CR107:  *out = "cr107"; return;
        case CV_IA64_CR108:  *out = "cr108"; return;
        case CV_IA64_CR109:  *out = "cr109"; return;
        case CV_IA64_CR110:  *out = "cr110"; return;
        case CV_IA64_CR111:  *out = "cr111"; return;
        case CV_IA64_CR112:  *out = "cr112"; return;
        case CV_IA64_CR113:  *out = "cr113"; return;
        case CV_IA64_CR114:  *out = "cr114"; return;
        case CV_IA64_CR115:  *out = "cr115"; return;
        case CV_IA64_CR116:  *out = "cr116"; return;
        case CV_IA64_CR117:  *out = "cr117"; return;
        case CV_IA64_CR118:  *out = "cr118"; return;
        case CV_IA64_CR119:  *out = "cr119"; return;
        case CV_IA64_CR120:  *out = "cr120"; return;
        case CV_IA64_CR121:  *out = "cr121"; return;
        case CV_IA64_CR122:  *out = "cr122"; return;
        case CV_IA64_CR123:  *out = "cr123"; return;
        case CV_IA64_CR124:  *out = "cr124"; return;
        case CV_IA64_CR125:  *out = "cr125"; return;
        case CV_IA64_CR126:  *out = "cr126"; return;
        case CV_IA64_CR127:  *out = "cr127"; return;

        // Protection Key Registers

        case CV_IA64_Pkr0:   *out = "pkr0"; return;
        case CV_IA64_Pkr1:   *out = "pkr1"; return;
        case CV_IA64_Pkr2:   *out = "pkr2"; return;
        case CV_IA64_Pkr3:   *out = "pkr3"; return;
        case CV_IA64_Pkr4:   *out = "pkr4"; return;
        case CV_IA64_Pkr5:   *out = "pkr5"; return;
        case CV_IA64_Pkr6:   *out = "pkr6"; return;
        case CV_IA64_Pkr7:   *out = "pkr7"; return;
        case CV_IA64_Pkr8:   *out = "pkr8"; return;
        case CV_IA64_Pkr9:   *out = "pkr9"; return;
        case CV_IA64_Pkr10:  *out = "pkr10"; return;
        case CV_IA64_Pkr11:  *out = "pkr11"; return;
        case CV_IA64_Pkr12:  *out = "pkr12"; return;
        case CV_IA64_Pkr13:  *out = "pkr13"; return;
        case CV_IA64_Pkr14:  *out = "pkr14"; return;
        case CV_IA64_Pkr15:  *out = "pkr15"; return;

        // Region Registers

        case CV_IA64_Rr0:    *out = "rr0"; return;
        case CV_IA64_Rr1:    *out = "rr1"; return;
        case CV_IA64_Rr2:    *out = "rr2"; return;
        case CV_IA64_Rr3:    *out = "rr3"; return;
        case CV_IA64_Rr4:    *out = "rr4"; return;
        case CV_IA64_Rr5:    *out = "rr5"; return;
        case CV_IA64_Rr6:    *out = "rr6"; return;
        case CV_IA64_Rr7:    *out = "rr7"; return;

        // Performance Monitor Data Registers

        case CV_IA64_PFD0:   *out = "pfd0"; return;
        case CV_IA64_PFD1:   *out = "pfd1"; return;
        case CV_IA64_PFD2:   *out = "pfd2"; return;
        case CV_IA64_PFD3:   *out = "pfd3"; return;
        case CV_IA64_PFD4:   *out = "pfd4"; return;
        case CV_IA64_PFD5:   *out = "pfd5"; return;
        case CV_IA64_PFD6:   *out = "pfd6"; return;
        case CV_IA64_PFD7:   *out = "pfd7"; return;
        case CV_IA64_PFD8:   *out = "pfd8"; return;
        case CV_IA64_PFD9:   *out = "pfd9"; return;
        case CV_IA64_PFD10:  *out = "pfd10"; return;
        case CV_IA64_PFD11:  *out = "pfd11"; return;
        case CV_IA64_PFD12:  *out = "pfd12"; return;
        case CV_IA64_PFD13:  *out = "pfd13"; return;
        case CV_IA64_PFD14:  *out = "pfd14"; return;
        case CV_IA64_PFD15:  *out = "pfd15"; return;
        case CV_IA64_PFD16:  *out = "pfd16"; return;
        case CV_IA64_PFD17:  *out = "pfd17"; return;

        // Performance Monitor Config Registers

        case CV_IA64_PFC0:   *out = "pfc0"; return;
        case CV_IA64_PFC1:   *out = "pfc1"; return;
        case CV_IA64_PFC2:   *out = "pfc2"; return;
        case CV_IA64_PFC3:   *out = "pfc3"; return;
        case CV_IA64_PFC4:   *out = "pfc4"; return;
        case CV_IA64_PFC5:   *out = "pfc5"; return;
        case CV_IA64_PFC6:   *out = "pfc6"; return;
        case CV_IA64_PFC7:   *out = "pfc7"; return;
        case CV_IA64_PFC8:   *out = "pfc8"; return;
        case CV_IA64_PFC9:   *out = "pfc9"; return;
        case CV_IA64_PFC10:  *out = "pfc10"; return;
        case CV_IA64_PFC11:  *out = "pfc11"; return;
        case CV_IA64_PFC12:  *out = "pfc12"; return;
        case CV_IA64_PFC13:  *out = "pfc13"; return;
        case CV_IA64_PFC14:  *out = "pfc14"; return;
        case CV_IA64_PFC15:  *out = "pfc15"; return;

        // Instruction Translation Registers

        case CV_IA64_TrI0:   *out = "tri0"; return;
        case CV_IA64_TrI1:   *out = "tri1"; return;
        case CV_IA64_TrI2:   *out = "tri2"; return;
        case CV_IA64_TrI3:   *out = "tri3"; return;
        case CV_IA64_TrI4:   *out = "tri4"; return;
        case CV_IA64_TrI5:   *out = "tri5"; return;
        case CV_IA64_TrI6:   *out = "tri6"; return;
        case CV_IA64_TrI7:   *out = "tri7"; return;

        // Data Translation Registers

        case CV_IA64_TrD0:   *out = "trd0"; return;
        case CV_IA64_TrD1:   *out = "trd1"; return;
        case CV_IA64_TrD2:   *out = "trd2"; return;
        case CV_IA64_TrD3:   *out = "trd3"; return;
        case CV_IA64_TrD4:   *out = "trd4"; return;
        case CV_IA64_TrD5:   *out = "trd5"; return;
        case CV_IA64_TrD6:   *out = "trd6"; return;
        case CV_IA64_TrD7:   *out = "trd7"; return;

        // Instruction Breakpoint Registers

        case CV_IA64_DbI0:   *out = "dbi0"; return;
        case CV_IA64_DbI1:   *out = "dbi1"; return;
        case CV_IA64_DbI2:   *out = "dbi2"; return;
        case CV_IA64_DbI3:   *out = "dbi3"; return;
        case CV_IA64_DbI4:   *out = "dbi4"; return;
        case CV_IA64_DbI5:   *out = "dbi5"; return;
        case CV_IA64_DbI6:   *out = "dbi6"; return;
        case CV_IA64_DbI7:   *out = "dbi7"; return;

        // Data Breakpoint Registers

        case CV_IA64_DbD0:   *out = "dbd0"; return;
        case CV_IA64_DbD1:   *out = "dbd1"; return;
        case CV_IA64_DbD2:   *out = "dbd2"; return;
        case CV_IA64_DbD3:   *out = "dbd3"; return;
        case CV_IA64_DbD4:   *out = "dbd4"; return;
        case CV_IA64_DbD5:   *out = "dbd5"; return;
        case CV_IA64_DbD6:   *out = "dbd6"; return;
        case CV_IA64_DbD7:   *out = "dbd7"; return;
      }
      break;


    case CV_CFL_TRICORE:
      //
      // Register set for the TriCore processor.
      //
      switch ( reg )
      {
        case CV_TRI_NOREG:   *out = "noreg"; return;

        // General Purpose Data Registers

        case CV_TRI_D0:      *out = "d0"; return;
        case CV_TRI_D1:      *out = "d1"; return;
        case CV_TRI_D2:      *out = "d2"; return;
        case CV_TRI_D3:      *out = "d3"; return;
        case CV_TRI_D4:      *out = "d4"; return;
        case CV_TRI_D5:      *out = "d5"; return;
        case CV_TRI_D6:      *out = "d6"; return;
        case CV_TRI_D7:      *out = "d7"; return;
        case CV_TRI_D8:      *out = "d8"; return;
        case CV_TRI_D9:      *out = "d9"; return;
        case CV_TRI_D10:     *out = "d10"; return;
        case CV_TRI_D11:     *out = "d11"; return;
        case CV_TRI_D12:     *out = "d12"; return;
        case CV_TRI_D13:     *out = "d13"; return;
        case CV_TRI_D14:     *out = "d14"; return;
        case CV_TRI_D15:     *out = "d15"; return;

        // General Purpose Address Registers

        case CV_TRI_A0:      *out = "a0"; return;
        case CV_TRI_A1:      *out = "a1"; return;
        case CV_TRI_A2:      *out = "a2"; return;
        case CV_TRI_A3:      *out = "a3"; return;
        case CV_TRI_A4:      *out = "a4"; return;
        case CV_TRI_A5:      *out = "a5"; return;
        case CV_TRI_A6:      *out = "a6"; return;
        case CV_TRI_A7:      *out = "a7"; return;
        case CV_TRI_A8:      *out = "a8"; return;
        case CV_TRI_A9:      *out = "a9"; return;
        case CV_TRI_A10:     *out = "a10"; return;
        case CV_TRI_A11:     *out = "a11"; return;
        case CV_TRI_A12:     *out = "a12"; return;
        case CV_TRI_A13:     *out = "a13"; return;
        case CV_TRI_A14:     *out = "a14"; return;
        case CV_TRI_A15:     *out = "a15"; return;

        // Extended (64-bit) data registers

        case CV_TRI_E0:      *out = "e0"; return;
        case CV_TRI_E2:      *out = "e2"; return;
        case CV_TRI_E4:      *out = "e4"; return;
        case CV_TRI_E6:      *out = "e6"; return;
        case CV_TRI_E8:      *out = "e8"; return;
        case CV_TRI_E10:     *out = "e10"; return;
        case CV_TRI_E12:     *out = "e12"; return;
        case CV_TRI_E14:     *out = "e14"; return;

        // Extended (64-bit) address registers

        case CV_TRI_EA0:     *out = "ea0"; return;
        case CV_TRI_EA2:     *out = "ea2"; return;
        case CV_TRI_EA4:     *out = "ea4"; return;
        case CV_TRI_EA6:     *out = "ea6"; return;
        case CV_TRI_EA8:     *out = "ea8"; return;
        case CV_TRI_EA10:    *out = "ea10"; return;
        case CV_TRI_EA12:    *out = "ea12"; return;
        case CV_TRI_EA14:    *out = "ea14"; return;

        case CV_TRI_PSW:     *out = "psw"; return;
        case CV_TRI_PCXI:    *out = "pcxi"; return;
        case CV_TRI_PC:      *out = "pc"; return;
        case CV_TRI_FCX:     *out = "fcx"; return;
        case CV_TRI_LCX:     *out = "lcx"; return;
        case CV_TRI_ISP:     *out = "isp"; return;
        case CV_TRI_ICR:     *out = "icr"; return;
        case CV_TRI_BIV:     *out = "biv"; return;
        case CV_TRI_BTV:     *out = "btv"; return;
        case CV_TRI_SYSCON:  *out = "syscon"; return;
        case CV_TRI_DPRx_0:  *out = "dprx_0"; return;
        case CV_TRI_DPRx_1:  *out = "dprx_1"; return;
        case CV_TRI_DPRx_2:  *out = "dprx_2"; return;
        case CV_TRI_DPRx_3:  *out = "dprx_3"; return;
//        case CV_TRI_CPRx_0:  *out = "cprx_0"; return;
//        case CV_TRI_CPRx_1:  *out = "cprx_1"; return;
//        case CV_TRI_CPRx_2:  *out = "cprx_2"; return;
//        case CV_TRI_CPRx_3:  *out = "cprx_3"; return;
//        case CV_TRI_DPMx_0:  *out = "dpmx_0"; return;
//        case CV_TRI_DPMx_1:  *out = "dpmx_1"; return;
//        case CV_TRI_DPMx_2:  *out = "dpmx_2"; return;
//        case CV_TRI_DPMx_3:  *out = "dpmx_3"; return;
//        case CV_TRI_CPMx_0:  *out = "cpmx_0"; return;
//        case CV_TRI_CPMx_1:  *out = "cpmx_1"; return;
//        case CV_TRI_CPMx_2:  *out = "cpmx_2"; return;
//        case CV_TRI_CPMx_3:  *out = "cpmx_3"; return;
        case CV_TRI_DBGSSR:  *out = "dbgssr"; return;
        case CV_TRI_EXEVT:   *out = "exevt"; return;
        case CV_TRI_SWEVT:   *out = "swevt"; return;
        case CV_TRI_CREVT:   *out = "crevt"; return;
        case CV_TRI_TRnEVT:  *out = "trnevt"; return;
        case CV_TRI_MMUCON:  *out = "mmucon"; return;
        case CV_TRI_ASI:     *out = "asi"; return;
        case CV_TRI_TVA:     *out = "tva"; return;
        case CV_TRI_TPA:     *out = "tpa"; return;
        case CV_TRI_TPX:     *out = "tpx"; return;
        case CV_TRI_TFA:     *out = "tfa"; return;
      }
      break;

    case CV_CFL_AM33:
      //
      // Register set for the AM33 and related processors.
      //
      switch ( reg )
      {
        case CV_AM33_NOREG:  *out = "noreg"; return;

        // "Extended" (general purpose integer) registers
        case CV_AM33_E0:     *out = "e0"; return;
        case CV_AM33_E1:     *out = "e1"; return;
        case CV_AM33_E2:     *out = "e2"; return;
        case CV_AM33_E3:     *out = "e3"; return;
        case CV_AM33_E4:     *out = "e4"; return;
        case CV_AM33_E5:     *out = "e5"; return;
        case CV_AM33_E6:     *out = "e6"; return;
        case CV_AM33_E7:     *out = "e7"; return;

        // Address registers
        case CV_AM33_A0:     *out = "a0"; return;
        case CV_AM33_A1:     *out = "a1"; return;
        case CV_AM33_A2:     *out = "a2"; return;
        case CV_AM33_A3:     *out = "a3"; return;

        // Integer data registers
        case CV_AM33_D0:     *out = "d0"; return;
        case CV_AM33_D1:     *out = "d1"; return;
        case CV_AM33_D2:     *out = "d2"; return;
        case CV_AM33_D3:     *out = "d3"; return;

        // (Single-precision) floating-point registers
        case CV_AM33_FS0:    *out = "fs0"; return;
        case CV_AM33_FS1:    *out = "fs1"; return;
        case CV_AM33_FS2:    *out = "fs2"; return;
        case CV_AM33_FS3:    *out = "fs3"; return;
        case CV_AM33_FS4:    *out = "fs4"; return;
        case CV_AM33_FS5:    *out = "fs5"; return;
        case CV_AM33_FS6:    *out = "fs6"; return;
        case CV_AM33_FS7:    *out = "fs7"; return;
        case CV_AM33_FS8:    *out = "fs8"; return;
        case CV_AM33_FS9:    *out = "fs9"; return;
        case CV_AM33_FS10:   *out = "fs10"; return;
        case CV_AM33_FS11:   *out = "fs11"; return;
        case CV_AM33_FS12:   *out = "fs12"; return;
        case CV_AM33_FS13:   *out = "fs13"; return;
        case CV_AM33_FS14:   *out = "fs14"; return;
        case CV_AM33_FS15:   *out = "fs15"; return;
        case CV_AM33_FS16:   *out = "fs16"; return;
        case CV_AM33_FS17:   *out = "fs17"; return;
        case CV_AM33_FS18:   *out = "fs18"; return;
        case CV_AM33_FS19:   *out = "fs19"; return;
        case CV_AM33_FS20:   *out = "fs20"; return;
        case CV_AM33_FS21:   *out = "fs21"; return;
        case CV_AM33_FS22:   *out = "fs22"; return;
        case CV_AM33_FS23:   *out = "fs23"; return;
        case CV_AM33_FS24:   *out = "fs24"; return;
        case CV_AM33_FS25:   *out = "fs25"; return;
        case CV_AM33_FS26:   *out = "fs26"; return;
        case CV_AM33_FS27:   *out = "fs27"; return;
        case CV_AM33_FS28:   *out = "fs28"; return;
        case CV_AM33_FS29:   *out = "fs29"; return;
        case CV_AM33_FS30:   *out = "fs30"; return;
        case CV_AM33_FS31:   *out = "fs31"; return;

        // Special purpose registers

        // Stack pointer
        case CV_AM33_SP:     *out = "sp"; return;

        // Program counter
        case CV_AM33_PC:     *out = "pc"; return;

        // Multiply-divide/accumulate registers
        case CV_AM33_MDR:    *out = "mdr"; return;
        case CV_AM33_MDRQ:   *out = "mdrq"; return;
        case CV_AM33_MCRH:   *out = "mcrh"; return;
        case CV_AM33_MCRL:   *out = "mcrl"; return;
        case CV_AM33_MCVF:   *out = "mcvf"; return;

        // CPU status words
        case CV_AM33_EPSW:   *out = "epsw"; return;
        case CV_AM33_FPCR:   *out = "fpcr"; return;

        // Loop buffer registers
        case CV_AM33_LIR:    *out = "lir"; return;
        case CV_AM33_LAR:    *out = "lar"; return;
      }
      break;

    case CV_CFL_M32R:
      //
      // Register set for the Mitsubishi M32R
      //
      switch ( reg )
      {
        case CV_M32R_NOREG:  *out = "noreg"; return;
        case CV_M32R_R0:     *out = "r0"; return;
        case CV_M32R_R1:     *out = "r1"; return;
        case CV_M32R_R2:     *out = "r2"; return;
        case CV_M32R_R3:     *out = "r3"; return;
        case CV_M32R_R4:     *out = "r4"; return;
        case CV_M32R_R5:     *out = "r5"; return;
        case CV_M32R_R6:     *out = "r6"; return;
        case CV_M32R_R7:     *out = "r7"; return;
        case CV_M32R_R8:     *out = "r8"; return;
        case CV_M32R_R9:     *out = "r9"; return;
        case CV_M32R_R10:    *out = "r10"; return;
        case CV_M32R_R11:    *out = "r11"; return;
        case CV_M32R_R12:    *out = "r12"; return;// Gloabal Pointer, if used
        case CV_M32R_R13:    *out = "r13"; return;// Frame Pointer, if allocated
        case CV_M32R_R14:    *out = "r14"; return;// Link Register
        case CV_M32R_R15:    *out = "r15"; return;// Stack Pointer
        case CV_M32R_PSW:    *out = "psw"; return;// Preocessor Status Register
        case CV_M32R_CBR:    *out = "cbr"; return;// Condition Bit Register
        case CV_M32R_SPI:    *out = "spi"; return;// Interrupt Stack Pointer
        case CV_M32R_SPU:    *out = "spu"; return;// User Stack Pointer
        case CV_M32R_SPO:    *out = "spo"; return;// OS Stack Pointer
        case CV_M32R_BPC:    *out = "bpc"; return;// Backup Program Counter
        case CV_M32R_ACHI:   *out = "achi"; return;// Accumulator High
        case CV_M32R_ACLO:   *out = "aclo"; return;// Accumulator Low
        case CV_M32R_PC:     *out = "pc"; return;// Program Counter
      }
      break;

      //
      // Register set for the SuperH SHMedia processor including compact
      // mode
      //
    case CV_CFL_SHMEDIA:
      switch ( reg )
      {
        // Integer - 64 bit general registers
        case CV_SHMEDIA_NOREG:*out = "noreg"; return;
        case CV_SHMEDIA_R0:  *out = "r0"; return;
        case CV_SHMEDIA_R1:  *out = "r1"; return;
        case CV_SHMEDIA_R2:  *out = "r2"; return;
        case CV_SHMEDIA_R3:  *out = "r3"; return;
        case CV_SHMEDIA_R4:  *out = "r4"; return;
        case CV_SHMEDIA_R5:  *out = "r5"; return;
        case CV_SHMEDIA_R6:  *out = "r6"; return;
        case CV_SHMEDIA_R7:  *out = "r7"; return;
        case CV_SHMEDIA_R8:  *out = "r8"; return;
        case CV_SHMEDIA_R9:  *out = "r9"; return;
        case CV_SHMEDIA_R10: *out = "r10"; return;
        case CV_SHMEDIA_R11: *out = "r11"; return;
        case CV_SHMEDIA_R12: *out = "r12"; return;
        case CV_SHMEDIA_R13: *out = "r13"; return;
        case CV_SHMEDIA_R14: *out = "r14"; return;
        case CV_SHMEDIA_R15: *out = "r15"; return;
        case CV_SHMEDIA_R16: *out = "r16"; return;
        case CV_SHMEDIA_R17: *out = "r17"; return;
        case CV_SHMEDIA_R18: *out = "r18"; return;
        case CV_SHMEDIA_R19: *out = "r19"; return;
        case CV_SHMEDIA_R20: *out = "r20"; return;
        case CV_SHMEDIA_R21: *out = "r21"; return;
        case CV_SHMEDIA_R22: *out = "r22"; return;
        case CV_SHMEDIA_R23: *out = "r23"; return;
        case CV_SHMEDIA_R24: *out = "r24"; return;
        case CV_SHMEDIA_R25: *out = "r25"; return;
        case CV_SHMEDIA_R26: *out = "r26"; return;
        case CV_SHMEDIA_R27: *out = "r27"; return;
        case CV_SHMEDIA_R28: *out = "r28"; return;
        case CV_SHMEDIA_R29: *out = "r29"; return;
        case CV_SHMEDIA_R30: *out = "r30"; return;
        case CV_SHMEDIA_R31: *out = "r31"; return;
        case CV_SHMEDIA_R32: *out = "r32"; return;
        case CV_SHMEDIA_R33: *out = "r33"; return;
        case CV_SHMEDIA_R34: *out = "r34"; return;
        case CV_SHMEDIA_R35: *out = "r35"; return;
        case CV_SHMEDIA_R36: *out = "r36"; return;
        case CV_SHMEDIA_R37: *out = "r37"; return;
        case CV_SHMEDIA_R38: *out = "r38"; return;
        case CV_SHMEDIA_R39: *out = "r39"; return;
        case CV_SHMEDIA_R40: *out = "r40"; return;
        case CV_SHMEDIA_R41: *out = "r41"; return;
        case CV_SHMEDIA_R42: *out = "r42"; return;
        case CV_SHMEDIA_R43: *out = "r43"; return;
        case CV_SHMEDIA_R44: *out = "r44"; return;
        case CV_SHMEDIA_R45: *out = "r45"; return;
        case CV_SHMEDIA_R46: *out = "r46"; return;
        case CV_SHMEDIA_R47: *out = "r47"; return;
        case CV_SHMEDIA_R48: *out = "r48"; return;
        case CV_SHMEDIA_R49: *out = "r49"; return;
        case CV_SHMEDIA_R50: *out = "r50"; return;
        case CV_SHMEDIA_R51: *out = "r51"; return;
        case CV_SHMEDIA_R52: *out = "r52"; return;
        case CV_SHMEDIA_R53: *out = "r53"; return;
        case CV_SHMEDIA_R54: *out = "r54"; return;
        case CV_SHMEDIA_R55: *out = "r55"; return;
        case CV_SHMEDIA_R56: *out = "r56"; return;
        case CV_SHMEDIA_R57: *out = "r57"; return;
        case CV_SHMEDIA_R58: *out = "r58"; return;
        case CV_SHMEDIA_R59: *out = "r59"; return;
        case CV_SHMEDIA_R60: *out = "r60"; return;
        case CV_SHMEDIA_R61: *out = "r61"; return;
        case CV_SHMEDIA_R62: *out = "r62"; return;
        case CV_SHMEDIA_R63: *out = "r63"; return;

        // Target Registers - 32 bit
        case CV_SHMEDIA_TR0: *out = "tr0"; return;
        case CV_SHMEDIA_TR1: *out = "tr1"; return;
        case CV_SHMEDIA_TR2: *out = "tr2"; return;
        case CV_SHMEDIA_TR3: *out = "tr3"; return;
        case CV_SHMEDIA_TR4: *out = "tr4"; return;
        case CV_SHMEDIA_TR5: *out = "tr5"; return;
        case CV_SHMEDIA_TR6: *out = "tr6"; return;
        case CV_SHMEDIA_TR7: *out = "tr7"; return;
        case CV_SHMEDIA_TR8: *out = "tr8"; return;  // future-proof
        case CV_SHMEDIA_TR9: *out = "tr9"; return;  // future-proof
        case CV_SHMEDIA_TR10:*out = "tr10"; return; // future-proof
        case CV_SHMEDIA_TR11:*out = "tr11"; return; // future-proof
        case CV_SHMEDIA_TR12:*out = "tr12"; return; // future-proof
        case CV_SHMEDIA_TR13:*out = "tr13"; return; // future-proof
        case CV_SHMEDIA_TR14:*out = "tr14"; return; // future-proof
        case CV_SHMEDIA_TR15:*out = "tr15"; return; // future-proof

        // Single - 32 bit fp registers
        case CV_SHMEDIA_FR0: *out = "fr0"; return;
        case CV_SHMEDIA_FR1: *out = "fr1"; return;
        case CV_SHMEDIA_FR2: *out = "fr2"; return;
        case CV_SHMEDIA_FR3: *out = "fr3"; return;
        case CV_SHMEDIA_FR4: *out = "fr4"; return;
        case CV_SHMEDIA_FR5: *out = "fr5"; return;
        case CV_SHMEDIA_FR6: *out = "fr6"; return;
        case CV_SHMEDIA_FR7: *out = "fr7"; return;
        case CV_SHMEDIA_FR8: *out = "fr8"; return;
        case CV_SHMEDIA_FR9: *out = "fr9"; return;
        case CV_SHMEDIA_FR10:*out = "fr10"; return;
        case CV_SHMEDIA_FR11:*out = "fr11"; return;
        case CV_SHMEDIA_FR12:*out = "fr12"; return;
        case CV_SHMEDIA_FR13:*out = "fr13"; return;
        case CV_SHMEDIA_FR14:*out = "fr14"; return;
        case CV_SHMEDIA_FR15:*out = "fr15"; return;
        case CV_SHMEDIA_FR16:*out = "fr16"; return;
        case CV_SHMEDIA_FR17:*out = "fr17"; return;
        case CV_SHMEDIA_FR18:*out = "fr18"; return;
        case CV_SHMEDIA_FR19:*out = "fr19"; return;
        case CV_SHMEDIA_FR20:*out = "fr20"; return;
        case CV_SHMEDIA_FR21:*out = "fr21"; return;
        case CV_SHMEDIA_FR22:*out = "fr22"; return;
        case CV_SHMEDIA_FR23:*out = "fr23"; return;
        case CV_SHMEDIA_FR24:*out = "fr24"; return;
        case CV_SHMEDIA_FR25:*out = "fr25"; return;
        case CV_SHMEDIA_FR26:*out = "fr26"; return;
        case CV_SHMEDIA_FR27:*out = "fr27"; return;
        case CV_SHMEDIA_FR28:*out = "fr28"; return;
        case CV_SHMEDIA_FR29:*out = "fr29"; return;
        case CV_SHMEDIA_FR30:*out = "fr30"; return;
        case CV_SHMEDIA_FR31:*out = "fr31"; return;
        case CV_SHMEDIA_FR32:*out = "fr32"; return;
        case CV_SHMEDIA_FR33:*out = "fr33"; return;
        case CV_SHMEDIA_FR34:*out = "fr34"; return;
        case CV_SHMEDIA_FR35:*out = "fr35"; return;
        case CV_SHMEDIA_FR36:*out = "fr36"; return;
        case CV_SHMEDIA_FR37:*out = "fr37"; return;
        case CV_SHMEDIA_FR38:*out = "fr38"; return;
        case CV_SHMEDIA_FR39:*out = "fr39"; return;
        case CV_SHMEDIA_FR40:*out = "fr40"; return;
        case CV_SHMEDIA_FR41:*out = "fr41"; return;
        case CV_SHMEDIA_FR42:*out = "fr42"; return;
        case CV_SHMEDIA_FR43:*out = "fr43"; return;
        case CV_SHMEDIA_FR44:*out = "fr44"; return;
        case CV_SHMEDIA_FR45:*out = "fr45"; return;
        case CV_SHMEDIA_FR46:*out = "fr46"; return;
        case CV_SHMEDIA_FR47:*out = "fr47"; return;
        case CV_SHMEDIA_FR48:*out = "fr48"; return;
        case CV_SHMEDIA_FR49:*out = "fr49"; return;
        case CV_SHMEDIA_FR50:*out = "fr50"; return;
        case CV_SHMEDIA_FR51:*out = "fr51"; return;
        case CV_SHMEDIA_FR52:*out = "fr52"; return;
        case CV_SHMEDIA_FR53:*out = "fr53"; return;
        case CV_SHMEDIA_FR54:*out = "fr54"; return;
        case CV_SHMEDIA_FR55:*out = "fr55"; return;
        case CV_SHMEDIA_FR56:*out = "fr56"; return;
        case CV_SHMEDIA_FR57:*out = "fr57"; return;
        case CV_SHMEDIA_FR58:*out = "fr58"; return;
        case CV_SHMEDIA_FR59:*out = "fr59"; return;
        case CV_SHMEDIA_FR60:*out = "fr60"; return;
        case CV_SHMEDIA_FR61:*out = "fr61"; return;
        case CV_SHMEDIA_FR62:*out = "fr62"; return;
        case CV_SHMEDIA_FR63:*out = "fr63"; return;

        // Double - 64 bit synonyms for 32bit fp register pairs
        //          subtract 128 to find first base single register
        case CV_SHMEDIA_DR0: *out = "dr0"; return;
        case CV_SHMEDIA_DR2: *out = "dr2"; return;
        case CV_SHMEDIA_DR4: *out = "dr4"; return;
        case CV_SHMEDIA_DR6: *out = "dr6"; return;
        case CV_SHMEDIA_DR8: *out = "dr8"; return;
        case CV_SHMEDIA_DR10:*out = "dr10"; return;
        case CV_SHMEDIA_DR12:*out = "dr12"; return;
        case CV_SHMEDIA_DR14:*out = "dr14"; return;
        case CV_SHMEDIA_DR16:*out = "dr16"; return;
        case CV_SHMEDIA_DR18:*out = "dr18"; return;
        case CV_SHMEDIA_DR20:*out = "dr20"; return;
        case CV_SHMEDIA_DR22:*out = "dr22"; return;
        case CV_SHMEDIA_DR24:*out = "dr24"; return;
        case CV_SHMEDIA_DR26:*out = "dr26"; return;
        case CV_SHMEDIA_DR28:*out = "dr28"; return;
        case CV_SHMEDIA_DR30:*out = "dr30"; return;
        case CV_SHMEDIA_DR32:*out = "dr32"; return;
        case CV_SHMEDIA_DR34:*out = "dr34"; return;
        case CV_SHMEDIA_DR36:*out = "dr36"; return;
        case CV_SHMEDIA_DR38:*out = "dr38"; return;
        case CV_SHMEDIA_DR40:*out = "dr40"; return;
        case CV_SHMEDIA_DR42:*out = "dr42"; return;
        case CV_SHMEDIA_DR44:*out = "dr44"; return;
        case CV_SHMEDIA_DR46:*out = "dr46"; return;
        case CV_SHMEDIA_DR48:*out = "dr48"; return;
        case CV_SHMEDIA_DR50:*out = "dr50"; return;
        case CV_SHMEDIA_DR52:*out = "dr52"; return;
        case CV_SHMEDIA_DR54:*out = "dr54"; return;
        case CV_SHMEDIA_DR56:*out = "dr56"; return;
        case CV_SHMEDIA_DR58:*out = "dr58"; return;
        case CV_SHMEDIA_DR60:*out = "dr60"; return;
        case CV_SHMEDIA_DR62:*out = "dr62"; return;

        // Vector - 128 bit synonyms for 32bit fp register quads
        //          subtract 384 to find first base single register
        case CV_SHMEDIA_FV0: *out = "fv0"; return;
        case CV_SHMEDIA_FV4: *out = "fv4"; return;
        case CV_SHMEDIA_FV8: *out = "fv8"; return;
        case CV_SHMEDIA_FV12:*out = "fv12"; return;
        case CV_SHMEDIA_FV16:*out = "fv16"; return;
        case CV_SHMEDIA_FV20:*out = "fv20"; return;
        case CV_SHMEDIA_FV24:*out = "fv24"; return;
        case CV_SHMEDIA_FV28:*out = "fv28"; return;
        case CV_SHMEDIA_FV32:*out = "fv32"; return;
        case CV_SHMEDIA_FV36:*out = "fv36"; return;
        case CV_SHMEDIA_FV40:*out = "fv40"; return;
        case CV_SHMEDIA_FV44:*out = "fv44"; return;
        case CV_SHMEDIA_FV48:*out = "fv48"; return;
        case CV_SHMEDIA_FV52:*out = "fv52"; return;
        case CV_SHMEDIA_FV56:*out = "fv56"; return;
        case CV_SHMEDIA_FV60:*out = "fv60"; return;

        // Matrix - 512 bit synonyms for 16 adjacent 32bit fp registers
        //          subtract 896 to find first base single register
        case CV_SHMEDIA_MTRX0: *out = "mtrx0"; return;
        case CV_SHMEDIA_MTRX16:*out = "mtrx16"; return;
        case CV_SHMEDIA_MTRX32:*out = "mtrx32"; return;
        case CV_SHMEDIA_MTRX48:*out = "mtrx48"; return;

        // Control - Implementation defined 64bit control registers
        case CV_SHMEDIA_CR0: *out = "cr0"; return;
        case CV_SHMEDIA_CR1: *out = "cr1"; return;
        case CV_SHMEDIA_CR2: *out = "cr2"; return;
        case CV_SHMEDIA_CR3: *out = "cr3"; return;
        case CV_SHMEDIA_CR4: *out = "cr4"; return;
        case CV_SHMEDIA_CR5: *out = "cr5"; return;
        case CV_SHMEDIA_CR6: *out = "cr6"; return;
        case CV_SHMEDIA_CR7: *out = "cr7"; return;
        case CV_SHMEDIA_CR8: *out = "cr8"; return;
        case CV_SHMEDIA_CR9: *out = "cr9"; return;
        case CV_SHMEDIA_CR10:*out = "cr10"; return;
        case CV_SHMEDIA_CR11:*out = "cr11"; return;
        case CV_SHMEDIA_CR12:*out = "cr12"; return;
        case CV_SHMEDIA_CR13:*out = "cr13"; return;
        case CV_SHMEDIA_CR14:*out = "cr14"; return;
        case CV_SHMEDIA_CR15:*out = "cr15"; return;
        case CV_SHMEDIA_CR16:*out = "cr16"; return;
        case CV_SHMEDIA_CR17:*out = "cr17"; return;
        case CV_SHMEDIA_CR18:*out = "cr18"; return;
        case CV_SHMEDIA_CR19:*out = "cr19"; return;
        case CV_SHMEDIA_CR20:*out = "cr20"; return;
        case CV_SHMEDIA_CR21:*out = "cr21"; return;
        case CV_SHMEDIA_CR22:*out = "cr22"; return;
        case CV_SHMEDIA_CR23:*out = "cr23"; return;
        case CV_SHMEDIA_CR24:*out = "cr24"; return;
        case CV_SHMEDIA_CR25:*out = "cr25"; return;
        case CV_SHMEDIA_CR26:*out = "cr26"; return;
        case CV_SHMEDIA_CR27:*out = "cr27"; return;
        case CV_SHMEDIA_CR28:*out = "cr28"; return;
        case CV_SHMEDIA_CR29:*out = "cr29"; return;
        case CV_SHMEDIA_CR30:*out = "cr30"; return;
        case CV_SHMEDIA_CR31:*out = "cr31"; return;
        case CV_SHMEDIA_CR32:*out = "cr32"; return;
        case CV_SHMEDIA_CR33:*out = "cr33"; return;
        case CV_SHMEDIA_CR34:*out = "cr34"; return;
        case CV_SHMEDIA_CR35:*out = "cr35"; return;
        case CV_SHMEDIA_CR36:*out = "cr36"; return;
        case CV_SHMEDIA_CR37:*out = "cr37"; return;
        case CV_SHMEDIA_CR38:*out = "cr38"; return;
        case CV_SHMEDIA_CR39:*out = "cr39"; return;
        case CV_SHMEDIA_CR40:*out = "cr40"; return;
        case CV_SHMEDIA_CR41:*out = "cr41"; return;
        case CV_SHMEDIA_CR42:*out = "cr42"; return;
        case CV_SHMEDIA_CR43:*out = "cr43"; return;
        case CV_SHMEDIA_CR44:*out = "cr44"; return;
        case CV_SHMEDIA_CR45:*out = "cr45"; return;
        case CV_SHMEDIA_CR46:*out = "cr46"; return;
        case CV_SHMEDIA_CR47:*out = "cr47"; return;
        case CV_SHMEDIA_CR48:*out = "cr48"; return;
        case CV_SHMEDIA_CR49:*out = "cr49"; return;
        case CV_SHMEDIA_CR50:*out = "cr50"; return;
        case CV_SHMEDIA_CR51:*out = "cr51"; return;
        case CV_SHMEDIA_CR52:*out = "cr52"; return;
        case CV_SHMEDIA_CR53:*out = "cr53"; return;
        case CV_SHMEDIA_CR54:*out = "cr54"; return;
        case CV_SHMEDIA_CR55:*out = "cr55"; return;
        case CV_SHMEDIA_CR56:*out = "cr56"; return;
        case CV_SHMEDIA_CR57:*out = "cr57"; return;
        case CV_SHMEDIA_CR58:*out = "cr58"; return;
        case CV_SHMEDIA_CR59:*out = "cr59"; return;
        case CV_SHMEDIA_CR60:*out = "cr60"; return;
        case CV_SHMEDIA_CR61:*out = "cr61"; return;
        case CV_SHMEDIA_CR62:*out = "cr62"; return;
        case CV_SHMEDIA_CR63:*out = "cr63"; return;

        case CV_SHMEDIA_FPSCR: *out = "fpscr"; return;

        // Compact mode synonyms
//        case CV_SHMEDIA_GBR:  *out = "gbr"; return;
        case CV_SHMEDIA_MACL: *out = "macl"; return;// synonym for lower 32bits of media R17
        case CV_SHMEDIA_MACH: *out = "mach"; return;// synonym for upper 32bits of media R17
//        case CV_SHMEDIA_PR:   *out = "pr"; return;
        case CV_SHMEDIA_T:    *out = "t"; return;// synonym for lowest bit of media R19
//        case CV_SHMEDIA_FPUL: *out = "fpul"; return;
        case CV_SHMEDIA_PC:   *out = "pc"; return;
//        case CV_SHMEDIA_SR:   *out = "sr"; return;
      }
      break;

    case CV_CFL_AMD64:
      //
      // AMD64 registers
      //
      switch ( reg )
      {
        case CV_AMD64_AL:     *out = "al"; return;
        case CV_AMD64_CL:     *out = "cl"; return;
        case CV_AMD64_DL:     *out = "dl"; return;
        case CV_AMD64_BL:     *out = "bl"; return;
        case CV_AMD64_AH:     *out = "ah"; return;
        case CV_AMD64_CH:     *out = "ch"; return;
        case CV_AMD64_DH:     *out = "dh"; return;
        case CV_AMD64_BH:     *out = "bh"; return;
        case CV_AMD64_AX:     *out = "ax"; return;
        case CV_AMD64_CX:     *out = "cx"; return;
        case CV_AMD64_DX:     *out = "dx"; return;
        case CV_AMD64_BX:     *out = "bx"; return;
        case CV_AMD64_SP:     *out = "sp"; return;
        case CV_AMD64_BP:     *out = "bp"; return;
        case CV_AMD64_SI:     *out = "si"; return;
        case CV_AMD64_DI:     *out = "di"; return;
        case CV_AMD64_EAX:    *out = "eax"; return;
        case CV_AMD64_ECX:    *out = "ecx"; return;
        case CV_AMD64_EDX:    *out = "edx"; return;
        case CV_AMD64_EBX:    *out = "ebx"; return;
        case CV_AMD64_ESP:    *out = "esp"; return;
        case CV_AMD64_EBP:    *out = "ebp"; return;
        case CV_AMD64_ESI:    *out = "esi"; return;
        case CV_AMD64_EDI:    *out = "edi"; return;
        case CV_AMD64_ES:     *out = "es"; return;
        case CV_AMD64_CS:     *out = "cs"; return;
        case CV_AMD64_SS:     *out = "ss"; return;
        case CV_AMD64_DS:     *out = "ds"; return;
        case CV_AMD64_FS:     *out = "fs"; return;
        case CV_AMD64_GS:     *out = "gs"; return;
        case CV_AMD64_FLAGS:  *out = "flags"; return;
        case CV_AMD64_RIP:    *out = "rip"; return;
        case CV_AMD64_EFLAGS: *out = "eflags"; return;

        // Control registers
        case CV_AMD64_CR0:    *out = "cr0"; return;
        case CV_AMD64_CR1:    *out = "cr1"; return;
        case CV_AMD64_CR2:    *out = "cr2"; return;
        case CV_AMD64_CR3:    *out = "cr3"; return;
        case CV_AMD64_CR4:    *out = "cr4"; return;
        case CV_AMD64_CR8:    *out = "cr8"; return;

        // Debug registers
        case CV_AMD64_DR0:    *out = "dr0"; return;
        case CV_AMD64_DR1:    *out = "dr1"; return;
        case CV_AMD64_DR2:    *out = "dr2"; return;
        case CV_AMD64_DR3:    *out = "dr3"; return;
        case CV_AMD64_DR4:    *out = "dr4"; return;
        case CV_AMD64_DR5:    *out = "dr5"; return;
        case CV_AMD64_DR6:    *out = "dr6"; return;
        case CV_AMD64_DR7:    *out = "dr7"; return;
        case CV_AMD64_DR8:    *out = "dr8"; return;
        case CV_AMD64_DR9:    *out = "dr9"; return;
        case CV_AMD64_DR10:   *out = "dr10"; return;
        case CV_AMD64_DR11:   *out = "dr11"; return;
        case CV_AMD64_DR12:   *out = "dr12"; return;
        case CV_AMD64_DR13:   *out = "dr13"; return;
        case CV_AMD64_DR14:   *out = "dr14"; return;
        case CV_AMD64_DR15:   *out = "dr15"; return;

        case CV_AMD64_GDTR:   *out = "gdtr"; return;
        case CV_AMD64_GDTL:   *out = "gdtl"; return;
        case CV_AMD64_IDTR:   *out = "idtr"; return;
        case CV_AMD64_IDTL:   *out = "idtl"; return;
        case CV_AMD64_LDTR:   *out = "ldtr"; return;
        case CV_AMD64_TR:     *out = "tr"; return;

        case CV_AMD64_ST0:    *out = "st0"; return;
        case CV_AMD64_ST1:    *out = "st1"; return;
        case CV_AMD64_ST2:    *out = "st2"; return;
        case CV_AMD64_ST3:    *out = "st3"; return;
        case CV_AMD64_ST4:    *out = "st4"; return;
        case CV_AMD64_ST5:    *out = "st5"; return;
        case CV_AMD64_ST6:    *out = "st6"; return;
        case CV_AMD64_ST7:    *out = "st7"; return;
        case CV_AMD64_CTRL:   *out = "ctrl"; return;
        case CV_AMD64_STAT:   *out = "stat"; return;
        case CV_AMD64_TAG:    *out = "tag"; return;
        case CV_AMD64_FPIP:   *out = "fpip"; return;
        case CV_AMD64_FPCS:   *out = "fpcs"; return;
        case CV_AMD64_FPDO:   *out = "fpdo"; return;
        case CV_AMD64_FPDS:   *out = "fpds"; return;
        case CV_AMD64_ISEM:   *out = "isem"; return;
        case CV_AMD64_FPEIP:  *out = "fpeip"; return;
        case CV_AMD64_FPEDO:  *out = "fpedo"; return;

        case CV_AMD64_MM0:    *out = "mm0"; return;
        case CV_AMD64_MM1:    *out = "mm1"; return;
        case CV_AMD64_MM2:    *out = "mm2"; return;
        case CV_AMD64_MM3:    *out = "mm3"; return;
        case CV_AMD64_MM4:    *out = "mm4"; return;
        case CV_AMD64_MM5:    *out = "mm5"; return;
        case CV_AMD64_MM6:    *out = "mm6"; return;
        case CV_AMD64_MM7:    *out = "mm7"; return;

        case CV_AMD64_XMM0:   *out = "xmm0"; return;// KATMAI registers
        case CV_AMD64_XMM1:   *out = "xmm1"; return;
        case CV_AMD64_XMM2:   *out = "xmm2"; return;
        case CV_AMD64_XMM3:   *out = "xmm3"; return;
        case CV_AMD64_XMM4:   *out = "xmm4"; return;
        case CV_AMD64_XMM5:   *out = "xmm5"; return;
        case CV_AMD64_XMM6:   *out = "xmm6"; return;
        case CV_AMD64_XMM7:   *out = "xmm7"; return;

        case CV_AMD64_XMM0_0: *out = "xmm0_0"; return;  // KATMAI sub-registers
        case CV_AMD64_XMM0_1: *out = "xmm0_1"; return;
        case CV_AMD64_XMM0_2: *out = "xmm0_2"; return;
        case CV_AMD64_XMM0_3: *out = "xmm0_3"; return;
        case CV_AMD64_XMM1_0: *out = "xmm1_0"; return;
        case CV_AMD64_XMM1_1: *out = "xmm1_1"; return;
        case CV_AMD64_XMM1_2: *out = "xmm1_2"; return;
        case CV_AMD64_XMM1_3: *out = "xmm1_3"; return;
        case CV_AMD64_XMM2_0: *out = "xmm2_0"; return;
        case CV_AMD64_XMM2_1: *out = "xmm2_1"; return;
        case CV_AMD64_XMM2_2: *out = "xmm2_2"; return;
        case CV_AMD64_XMM2_3: *out = "xmm2_3"; return;
        case CV_AMD64_XMM3_0: *out = "xmm3_0"; return;
        case CV_AMD64_XMM3_1: *out = "xmm3_1"; return;
        case CV_AMD64_XMM3_2: *out = "xmm3_2"; return;
        case CV_AMD64_XMM3_3: *out = "xmm3_3"; return;
        case CV_AMD64_XMM4_0: *out = "xmm4_0"; return;
        case CV_AMD64_XMM4_1: *out = "xmm4_1"; return;
        case CV_AMD64_XMM4_2: *out = "xmm4_2"; return;
        case CV_AMD64_XMM4_3: *out = "xmm4_3"; return;
        case CV_AMD64_XMM5_0: *out = "xmm5_0"; return;
        case CV_AMD64_XMM5_1: *out = "xmm5_1"; return;
        case CV_AMD64_XMM5_2: *out = "xmm5_2"; return;
        case CV_AMD64_XMM5_3: *out = "xmm5_3"; return;
        case CV_AMD64_XMM6_0: *out = "xmm6_0"; return;
        case CV_AMD64_XMM6_1: *out = "xmm6_1"; return;
        case CV_AMD64_XMM6_2: *out = "xmm6_2"; return;
        case CV_AMD64_XMM6_3: *out = "xmm6_3"; return;
        case CV_AMD64_XMM7_0: *out = "xmm7_0"; return;
        case CV_AMD64_XMM7_1: *out = "xmm7_1"; return;
        case CV_AMD64_XMM7_2: *out = "xmm7_2"; return;
        case CV_AMD64_XMM7_3: *out = "xmm7_3"; return;

        case CV_AMD64_XMM0L:  *out = "xmm0l"; return;
        case CV_AMD64_XMM1L:  *out = "xmm1l"; return;
        case CV_AMD64_XMM2L:  *out = "xmm2l"; return;
        case CV_AMD64_XMM3L:  *out = "xmm3l"; return;
        case CV_AMD64_XMM4L:  *out = "xmm4l"; return;
        case CV_AMD64_XMM5L:  *out = "xmm5l"; return;
        case CV_AMD64_XMM6L:  *out = "xmm6l"; return;
        case CV_AMD64_XMM7L:  *out = "xmm7l"; return;

        case CV_AMD64_XMM0H:  *out = "xmm0h"; return;
        case CV_AMD64_XMM1H:  *out = "xmm1h"; return;
        case CV_AMD64_XMM2H:  *out = "xmm2h"; return;
        case CV_AMD64_XMM3H:  *out = "xmm3h"; return;
        case CV_AMD64_XMM4H:  *out = "xmm4h"; return;
        case CV_AMD64_XMM5H:  *out = "xmm5h"; return;
        case CV_AMD64_XMM6H:  *out = "xmm6h"; return;
        case CV_AMD64_XMM7H:  *out = "xmm7h"; return;

        case CV_AMD64_MXCSR:  *out = "mxcsr"; return; // XMM status register

        case CV_AMD64_EMM0L:  *out = "emm0l"; return; // XMM sub-registers (WNI integer)
        case CV_AMD64_EMM1L:  *out = "emm1l"; return;
        case CV_AMD64_EMM2L:  *out = "emm2l"; return;
        case CV_AMD64_EMM3L:  *out = "emm3l"; return;
        case CV_AMD64_EMM4L:  *out = "emm4l"; return;
        case CV_AMD64_EMM5L:  *out = "emm5l"; return;
        case CV_AMD64_EMM6L:  *out = "emm6l"; return;
        case CV_AMD64_EMM7L:  *out = "emm7l"; return;

        case CV_AMD64_EMM0H:  *out = "emm0h"; return;
        case CV_AMD64_EMM1H:  *out = "emm1h"; return;
        case CV_AMD64_EMM2H:  *out = "emm2h"; return;
        case CV_AMD64_EMM3H:  *out = "emm3h"; return;
        case CV_AMD64_EMM4H:  *out = "emm4h"; return;
        case CV_AMD64_EMM5H:  *out = "emm5h"; return;
        case CV_AMD64_EMM6H:  *out = "emm6h"; return;
        case CV_AMD64_EMM7H:  *out = "emm7h"; return;

        // do not change the order of these regs, first one must be even too
        case CV_AMD64_MM00:   *out = "mm00"; return;
        case CV_AMD64_MM01:   *out = "mm01"; return;
        case CV_AMD64_MM10:   *out = "mm10"; return;
        case CV_AMD64_MM11:   *out = "mm11"; return;
        case CV_AMD64_MM20:   *out = "mm20"; return;
        case CV_AMD64_MM21:   *out = "mm21"; return;
        case CV_AMD64_MM30:   *out = "mm30"; return;
        case CV_AMD64_MM31:   *out = "mm31"; return;
        case CV_AMD64_MM40:   *out = "mm40"; return;
        case CV_AMD64_MM41:   *out = "mm41"; return;
        case CV_AMD64_MM50:   *out = "mm50"; return;
        case CV_AMD64_MM51:   *out = "mm51"; return;
        case CV_AMD64_MM60:   *out = "mm60"; return;
        case CV_AMD64_MM61:   *out = "mm61"; return;
        case CV_AMD64_MM70:   *out = "mm70"; return;
        case CV_AMD64_MM71:   *out = "mm71"; return;

        // Extended KATMAI registers
        case CV_AMD64_XMM8:   *out = "xmm8"; return;// KATMAI registers
        case CV_AMD64_XMM9:   *out = "xmm9"; return;
        case CV_AMD64_XMM10:  *out = "xmm10"; return;
        case CV_AMD64_XMM11:  *out = "xmm11"; return;
        case CV_AMD64_XMM12:  *out = "xmm12"; return;
        case CV_AMD64_XMM13:  *out = "xmm13"; return;
        case CV_AMD64_XMM14:  *out = "xmm14"; return;
        case CV_AMD64_XMM15:  *out = "xmm15"; return;

        case CV_AMD64_XMM8_0: *out = "xmm8_0"; return;  // KATMAI sub-registers
        case CV_AMD64_XMM8_1: *out = "xmm8_1"; return;
        case CV_AMD64_XMM8_2: *out = "xmm8_2"; return;
        case CV_AMD64_XMM8_3: *out = "xmm8_3"; return;
        case CV_AMD64_XMM9_0: *out = "xmm9_0"; return;
        case CV_AMD64_XMM9_1: *out = "xmm9_1"; return;
        case CV_AMD64_XMM9_2: *out = "xmm9_2"; return;
        case CV_AMD64_XMM9_3: *out = "xmm9_3"; return;
        case CV_AMD64_XMM10_0:*out = "xmm10_0"; return;
        case CV_AMD64_XMM10_1:*out = "xmm10_1"; return;
        case CV_AMD64_XMM10_2:*out = "xmm10_2"; return;
        case CV_AMD64_XMM10_3:*out = "xmm10_3"; return;
        case CV_AMD64_XMM11_0:*out = "xmm11_0"; return;
        case CV_AMD64_XMM11_1:*out = "xmm11_1"; return;
        case CV_AMD64_XMM11_2:*out = "xmm11_2"; return;
        case CV_AMD64_XMM11_3:*out = "xmm11_3"; return;
        case CV_AMD64_XMM12_0:*out = "xmm12_0"; return;
        case CV_AMD64_XMM12_1:*out = "xmm12_1"; return;
        case CV_AMD64_XMM12_2:*out = "xmm12_2"; return;
        case CV_AMD64_XMM12_3:*out = "xmm12_3"; return;
        case CV_AMD64_XMM13_0:*out = "xmm13_0"; return;
        case CV_AMD64_XMM13_1:*out = "xmm13_1"; return;
        case CV_AMD64_XMM13_2:*out = "xmm13_2"; return;
        case CV_AMD64_XMM13_3:*out = "xmm13_3"; return;
        case CV_AMD64_XMM14_0:*out = "xmm14_0"; return;
        case CV_AMD64_XMM14_1:*out = "xmm14_1"; return;
        case CV_AMD64_XMM14_2:*out = "xmm14_2"; return;
        case CV_AMD64_XMM14_3:*out = "xmm14_3"; return;
        case CV_AMD64_XMM15_0:*out = "xmm15_0"; return;
        case CV_AMD64_XMM15_1:*out = "xmm15_1"; return;
        case CV_AMD64_XMM15_2:*out = "xmm15_2"; return;
        case CV_AMD64_XMM15_3:*out = "xmm15_3"; return;

        case CV_AMD64_XMM8L:  *out = "xmm8l"; return;
        case CV_AMD64_XMM9L:  *out = "xmm9l"; return;
        case CV_AMD64_XMM10L: *out = "xmm10l"; return;
        case CV_AMD64_XMM11L: *out = "xmm11l"; return;
        case CV_AMD64_XMM12L: *out = "xmm12l"; return;
        case CV_AMD64_XMM13L: *out = "xmm13l"; return;
        case CV_AMD64_XMM14L: *out = "xmm14l"; return;
        case CV_AMD64_XMM15L: *out = "xmm15l"; return;

        case CV_AMD64_XMM8H:  *out = "xmm8h"; return;
        case CV_AMD64_XMM9H:  *out = "xmm9h"; return;
        case CV_AMD64_XMM10H: *out = "xmm10h"; return;
        case CV_AMD64_XMM11H: *out = "xmm11h"; return;
        case CV_AMD64_XMM12H: *out = "xmm12h"; return;
        case CV_AMD64_XMM13H: *out = "xmm13h"; return;
        case CV_AMD64_XMM14H: *out = "xmm14h"; return;
        case CV_AMD64_XMM15H: *out = "xmm15h"; return;

        case CV_AMD64_EMM8L:  *out = "emm8l"; return; // XMM sub-registers (WNI integer)
        case CV_AMD64_EMM9L:  *out = "emm9l"; return;
        case CV_AMD64_EMM10L: *out = "emm10l"; return;
        case CV_AMD64_EMM11L: *out = "emm11l"; return;
        case CV_AMD64_EMM12L: *out = "emm12l"; return;
        case CV_AMD64_EMM13L: *out = "emm13l"; return;
        case CV_AMD64_EMM14L: *out = "emm14l"; return;
        case CV_AMD64_EMM15L: *out = "emm15l"; return;

        case CV_AMD64_EMM8H:  *out = "emm8h"; return;
        case CV_AMD64_EMM9H:  *out = "emm9h"; return;
        case CV_AMD64_EMM10H: *out = "emm10h"; return;
        case CV_AMD64_EMM11H: *out = "emm11h"; return;
        case CV_AMD64_EMM12H: *out = "emm12h"; return;
        case CV_AMD64_EMM13H: *out = "emm13h"; return;
        case CV_AMD64_EMM14H: *out = "emm14h"; return;
        case CV_AMD64_EMM15H: *out = "emm15h"; return;

        // Low byte forms of some standard registers
        case CV_AMD64_SIL:    *out = "sil"; return;
        case CV_AMD64_DIL:    *out = "dil"; return;
        case CV_AMD64_BPL:    *out = "bpl"; return;
        case CV_AMD64_SPL:    *out = "spl"; return;

        // 64-bit regular registers
        case CV_AMD64_RAX:    *out = "rax"; return;
        case CV_AMD64_RBX:    *out = "rbx"; return;
        case CV_AMD64_RCX:    *out = "rcx"; return;
        case CV_AMD64_RDX:    *out = "rdx"; return;
        case CV_AMD64_RSI:    *out = "rsi"; return;
        case CV_AMD64_RDI:    *out = "rdi"; return;
        case CV_AMD64_RBP:    *out = "rbp"; return;
        case CV_AMD64_RSP:    *out = "rsp"; return;

        // 64-bit integer registers with 8-, 16-, and 32-bit forms (B, W, and D)
        case CV_AMD64_R8:     *out = "r8"; return;
        case CV_AMD64_R9:     *out = "r9"; return;
        case CV_AMD64_R10:    *out = "r10"; return;
        case CV_AMD64_R11:    *out = "r11"; return;
        case CV_AMD64_R12:    *out = "r12"; return;
        case CV_AMD64_R13:    *out = "r13"; return;
        case CV_AMD64_R14:    *out = "r14"; return;
        case CV_AMD64_R15:    *out = "r15"; return;

        case CV_AMD64_R8B:    *out = "r8b"; return;
        case CV_AMD64_R9B:    *out = "r9b"; return;
        case CV_AMD64_R10B:   *out = "r10b"; return;
        case CV_AMD64_R11B:   *out = "r11b"; return;
        case CV_AMD64_R12B:   *out = "r12b"; return;
        case CV_AMD64_R13B:   *out = "r13b"; return;
        case CV_AMD64_R14B:   *out = "r14b"; return;
        case CV_AMD64_R15B:   *out = "r15b"; return;

        case CV_AMD64_R8W:    *out = "r8w"; return;
        case CV_AMD64_R9W:    *out = "r9w"; return;
        case CV_AMD64_R10W:   *out = "r10w"; return;
        case CV_AMD64_R11W:   *out = "r11w"; return;
        case CV_AMD64_R12W:   *out = "r12w"; return;
        case CV_AMD64_R13W:   *out = "r13w"; return;
        case CV_AMD64_R14W:   *out = "r14w"; return;
        case CV_AMD64_R15W:   *out = "r15w"; return;

        case CV_AMD64_R8D:    *out = "r8d"; return;
        case CV_AMD64_R9D:    *out = "r9d"; return;
        case CV_AMD64_R10D:   *out = "r10d"; return;
        case CV_AMD64_R11D:   *out = "r11d"; return;
        case CV_AMD64_R12D:   *out = "r12d"; return;
        case CV_AMD64_R13D:   *out = "r13d"; return;
        case CV_AMD64_R14D:   *out = "r14d"; return;
        case CV_AMD64_R15D:   *out = "r15d"; return;

        // AVX registers 256 bits
        case CV_AMD64_YMM0:      *out = "ymm0"; return;
        case CV_AMD64_YMM1:      *out = "ymm1"; return;
        case CV_AMD64_YMM2:      *out = "ymm2"; return;
        case CV_AMD64_YMM3:      *out = "ymm3"; return;
        case CV_AMD64_YMM4:      *out = "ymm4"; return;
        case CV_AMD64_YMM5:      *out = "ymm5"; return;
        case CV_AMD64_YMM6:      *out = "ymm6"; return;
        case CV_AMD64_YMM7:      *out = "ymm7"; return;
        case CV_AMD64_YMM8:      *out = "ymm8"; return;
        case CV_AMD64_YMM9:      *out = "ymm9"; return;
        case CV_AMD64_YMM10:     *out = "ymm10"; return;
        case CV_AMD64_YMM11:     *out = "ymm11"; return;
        case CV_AMD64_YMM12:     *out = "ymm12"; return;
        case CV_AMD64_YMM13:     *out = "ymm13"; return;
        case CV_AMD64_YMM14:     *out = "ymm14"; return;
        case CV_AMD64_YMM15:     *out = "ymm15"; return;

        // AVX registers upper 128 bits
        case CV_AMD64_YMM0H:     *out = "ymm0h"; return;
        case CV_AMD64_YMM1H:     *out = "ymm1h"; return;
        case CV_AMD64_YMM2H:     *out = "ymm2h"; return;
        case CV_AMD64_YMM3H:     *out = "ymm3h"; return;
        case CV_AMD64_YMM4H:     *out = "ymm4h"; return;
        case CV_AMD64_YMM5H:     *out = "ymm5h"; return;
        case CV_AMD64_YMM6H:     *out = "ymm6h"; return;
        case CV_AMD64_YMM7H:     *out = "ymm7h"; return;
        case CV_AMD64_YMM8H:     *out = "ymm8h"; return;
        case CV_AMD64_YMM9H:     *out = "ymm9h"; return;
        case CV_AMD64_YMM10H:    *out = "ymm10h"; return;
        case CV_AMD64_YMM11H:    *out = "ymm11h"; return;
        case CV_AMD64_YMM12H:    *out = "ymm12h"; return;
        case CV_AMD64_YMM13H:    *out = "ymm13h"; return;
        case CV_AMD64_YMM14H:    *out = "ymm14h"; return;
        case CV_AMD64_YMM15H:    *out = "ymm15h"; return;

        // Lower/upper 8 bytes of XMM registers.  Unlike CV_AMD64_XMM<regnum><H/L>, these
        // values reprsesent the bit patterns of the registers as 64-bit integers, not
        // the representation of these registers as a double.
        case CV_AMD64_XMM0IL:    *out = "xmm0il"; return;
        case CV_AMD64_XMM1IL:    *out = "xmm1il"; return;
        case CV_AMD64_XMM2IL:    *out = "xmm2il"; return;
        case CV_AMD64_XMM3IL:    *out = "xmm3il"; return;
        case CV_AMD64_XMM4IL:    *out = "xmm4il"; return;
        case CV_AMD64_XMM5IL:    *out = "xmm5il"; return;
        case CV_AMD64_XMM6IL:    *out = "xmm6il"; return;
        case CV_AMD64_XMM7IL:    *out = "xmm7il"; return;
        case CV_AMD64_XMM8IL:    *out = "xmm8il"; return;
        case CV_AMD64_XMM9IL:    *out = "xmm9il"; return;
        case CV_AMD64_XMM10IL:   *out = "xmm10il"; return;
        case CV_AMD64_XMM11IL:   *out = "xmm11il"; return;
        case CV_AMD64_XMM12IL:   *out = "xmm12il"; return;
        case CV_AMD64_XMM13IL:   *out = "xmm13il"; return;
        case CV_AMD64_XMM14IL:   *out = "xmm14il"; return;
        case CV_AMD64_XMM15IL:   *out = "xmm15il"; return;

        case CV_AMD64_XMM0IH:    *out = "xmm0ih"; return;
        case CV_AMD64_XMM1IH:    *out = "xmm1ih"; return;
        case CV_AMD64_XMM2IH:    *out = "xmm2ih"; return;
        case CV_AMD64_XMM3IH:    *out = "xmm3ih"; return;
        case CV_AMD64_XMM4IH:    *out = "xmm4ih"; return;
        case CV_AMD64_XMM5IH:    *out = "xmm5ih"; return;
        case CV_AMD64_XMM6IH:    *out = "xmm6ih"; return;
        case CV_AMD64_XMM7IH:    *out = "xmm7ih"; return;
        case CV_AMD64_XMM8IH:    *out = "xmm8ih"; return;
        case CV_AMD64_XMM9IH:    *out = "xmm9ih"; return;
        case CV_AMD64_XMM10IH:   *out = "xmm10ih"; return;
        case CV_AMD64_XMM11IH:   *out = "xmm11ih"; return;
        case CV_AMD64_XMM12IH:   *out = "xmm12ih"; return;
        case CV_AMD64_XMM13IH:   *out = "xmm13ih"; return;
        case CV_AMD64_XMM14IH:   *out = "xmm14ih"; return;
        case CV_AMD64_XMM15IH:   *out = "xmm15ih"; return;

        case CV_AMD64_YMM0I0:    *out = "ymm0i0"; return; // AVX integer registers
        case CV_AMD64_YMM0I1:    *out = "ymm0i1"; return;
        case CV_AMD64_YMM0I2:    *out = "ymm0i2"; return;
        case CV_AMD64_YMM0I3:    *out = "ymm0i3"; return;
        case CV_AMD64_YMM1I0:    *out = "ymm1i0"; return;
        case CV_AMD64_YMM1I1:    *out = "ymm1i1"; return;
        case CV_AMD64_YMM1I2:    *out = "ymm1i2"; return;
        case CV_AMD64_YMM1I3:    *out = "ymm1i3"; return;
        case CV_AMD64_YMM2I0:    *out = "ymm2i0"; return;
        case CV_AMD64_YMM2I1:    *out = "ymm2i1"; return;
        case CV_AMD64_YMM2I2:    *out = "ymm2i2"; return;
        case CV_AMD64_YMM2I3:    *out = "ymm2i3"; return;
        case CV_AMD64_YMM3I0:    *out = "ymm3i0"; return;
        case CV_AMD64_YMM3I1:    *out = "ymm3i1"; return;
        case CV_AMD64_YMM3I2:    *out = "ymm3i2"; return;
        case CV_AMD64_YMM3I3:    *out = "ymm3i3"; return;
        case CV_AMD64_YMM4I0:    *out = "ymm4i0"; return;
        case CV_AMD64_YMM4I1:    *out = "ymm4i1"; return;
        case CV_AMD64_YMM4I2:    *out = "ymm4i2"; return;
        case CV_AMD64_YMM4I3:    *out = "ymm4i3"; return;
        case CV_AMD64_YMM5I0:    *out = "ymm5i0"; return;
        case CV_AMD64_YMM5I1:    *out = "ymm5i1"; return;
        case CV_AMD64_YMM5I2:    *out = "ymm5i2"; return;
        case CV_AMD64_YMM5I3:    *out = "ymm5i3"; return;
        case CV_AMD64_YMM6I0:    *out = "ymm6i0"; return;
        case CV_AMD64_YMM6I1:    *out = "ymm6i1"; return;
        case CV_AMD64_YMM6I2:    *out = "ymm6i2"; return;
        case CV_AMD64_YMM6I3:    *out = "ymm6i3"; return;
        case CV_AMD64_YMM7I0:    *out = "ymm7i0"; return;
        case CV_AMD64_YMM7I1:    *out = "ymm7i1"; return;
        case CV_AMD64_YMM7I2:    *out = "ymm7i2"; return;
        case CV_AMD64_YMM7I3:    *out = "ymm7i3"; return;
        case CV_AMD64_YMM8I0:    *out = "ymm8i0"; return;
        case CV_AMD64_YMM8I1:    *out = "ymm8i1"; return;
        case CV_AMD64_YMM8I2:    *out = "ymm8i2"; return;
        case CV_AMD64_YMM8I3:    *out = "ymm8i3"; return;
        case CV_AMD64_YMM9I0:    *out = "ymm9i0"; return;
        case CV_AMD64_YMM9I1:    *out = "ymm9i1"; return;
        case CV_AMD64_YMM9I2:    *out = "ymm9i2"; return;
        case CV_AMD64_YMM9I3:    *out = "ymm9i3"; return;
        case CV_AMD64_YMM10I0:   *out = "ymm10i0"; return;
        case CV_AMD64_YMM10I1:   *out = "ymm10i1"; return;
        case CV_AMD64_YMM10I2:   *out = "ymm10i2"; return;
        case CV_AMD64_YMM10I3:   *out = "ymm10i3"; return;
        case CV_AMD64_YMM11I0:   *out = "ymm11i0"; return;
        case CV_AMD64_YMM11I1:   *out = "ymm11i1"; return;
        case CV_AMD64_YMM11I2:   *out = "ymm11i2"; return;
        case CV_AMD64_YMM11I3:   *out = "ymm11i3"; return;
        case CV_AMD64_YMM12I0:   *out = "ymm12i0"; return;
        case CV_AMD64_YMM12I1:   *out = "ymm12i1"; return;
        case CV_AMD64_YMM12I2:   *out = "ymm12i2"; return;
        case CV_AMD64_YMM12I3:   *out = "ymm12i3"; return;
        case CV_AMD64_YMM13I0:   *out = "ymm13i0"; return;
        case CV_AMD64_YMM13I1:   *out = "ymm13i1"; return;
        case CV_AMD64_YMM13I2:   *out = "ymm13i2"; return;
        case CV_AMD64_YMM13I3:   *out = "ymm13i3"; return;
        case CV_AMD64_YMM14I0:   *out = "ymm14i0"; return;
        case CV_AMD64_YMM14I1:   *out = "ymm14i1"; return;
        case CV_AMD64_YMM14I2:   *out = "ymm14i2"; return;
        case CV_AMD64_YMM14I3:   *out = "ymm14i3"; return;
        case CV_AMD64_YMM15I0:   *out = "ymm15i0"; return;
        case CV_AMD64_YMM15I1:   *out = "ymm15i1"; return;
        case CV_AMD64_YMM15I2:   *out = "ymm15i2"; return;
        case CV_AMD64_YMM15I3:   *out = "ymm15i3"; return;

        case CV_AMD64_YMM0F0:    *out = "ymm0f0"; return; // AVX floating-point single precise registers
        case CV_AMD64_YMM0F1:    *out = "ymm0f1"; return;
        case CV_AMD64_YMM0F2:    *out = "ymm0f2"; return;
        case CV_AMD64_YMM0F3:    *out = "ymm0f3"; return;
        case CV_AMD64_YMM0F4:    *out = "ymm0f4"; return;
        case CV_AMD64_YMM0F5:    *out = "ymm0f5"; return;
        case CV_AMD64_YMM0F6:    *out = "ymm0f6"; return;
        case CV_AMD64_YMM0F7:    *out = "ymm0f7"; return;
        case CV_AMD64_YMM1F0:    *out = "ymm1f0"; return;
        case CV_AMD64_YMM1F1:    *out = "ymm1f1"; return;
        case CV_AMD64_YMM1F2:    *out = "ymm1f2"; return;
        case CV_AMD64_YMM1F3:    *out = "ymm1f3"; return;
        case CV_AMD64_YMM1F4:    *out = "ymm1f4"; return;
        case CV_AMD64_YMM1F5:    *out = "ymm1f5"; return;
        case CV_AMD64_YMM1F6:    *out = "ymm1f6"; return;
        case CV_AMD64_YMM1F7:    *out = "ymm1f7"; return;
        case CV_AMD64_YMM2F0:    *out = "ymm2f0"; return;
        case CV_AMD64_YMM2F1:    *out = "ymm2f1"; return;
        case CV_AMD64_YMM2F2:    *out = "ymm2f2"; return;
        case CV_AMD64_YMM2F3:    *out = "ymm2f3"; return;
        case CV_AMD64_YMM2F4:    *out = "ymm2f4"; return;
        case CV_AMD64_YMM2F5:    *out = "ymm2f5"; return;
        case CV_AMD64_YMM2F6:    *out = "ymm2f6"; return;
        case CV_AMD64_YMM2F7:    *out = "ymm2f7"; return;
        case CV_AMD64_YMM3F0:    *out = "ymm3f0"; return;
        case CV_AMD64_YMM3F1:    *out = "ymm3f1"; return;
        case CV_AMD64_YMM3F2:    *out = "ymm3f2"; return;
        case CV_AMD64_YMM3F3:    *out = "ymm3f3"; return;
        case CV_AMD64_YMM3F4:    *out = "ymm3f4"; return;
        case CV_AMD64_YMM3F5:    *out = "ymm3f5"; return;
        case CV_AMD64_YMM3F6:    *out = "ymm3f6"; return;
        case CV_AMD64_YMM3F7:    *out = "ymm3f7"; return;
        case CV_AMD64_YMM4F0:    *out = "ymm4f0"; return;
        case CV_AMD64_YMM4F1:    *out = "ymm4f1"; return;
        case CV_AMD64_YMM4F2:    *out = "ymm4f2"; return;
        case CV_AMD64_YMM4F3:    *out = "ymm4f3"; return;
        case CV_AMD64_YMM4F4:    *out = "ymm4f4"; return;
        case CV_AMD64_YMM4F5:    *out = "ymm4f5"; return;
        case CV_AMD64_YMM4F6:    *out = "ymm4f6"; return;
        case CV_AMD64_YMM4F7:    *out = "ymm4f7"; return;
        case CV_AMD64_YMM5F0:    *out = "ymm5f0"; return;
        case CV_AMD64_YMM5F1:    *out = "ymm5f1"; return;
        case CV_AMD64_YMM5F2:    *out = "ymm5f2"; return;
        case CV_AMD64_YMM5F3:    *out = "ymm5f3"; return;
        case CV_AMD64_YMM5F4:    *out = "ymm5f4"; return;
        case CV_AMD64_YMM5F5:    *out = "ymm5f5"; return;
        case CV_AMD64_YMM5F6:    *out = "ymm5f6"; return;
        case CV_AMD64_YMM5F7:    *out = "ymm5f7"; return;
        case CV_AMD64_YMM6F0:    *out = "ymm6f0"; return;
        case CV_AMD64_YMM6F1:    *out = "ymm6f1"; return;
        case CV_AMD64_YMM6F2:    *out = "ymm6f2"; return;
        case CV_AMD64_YMM6F3:    *out = "ymm6f3"; return;
        case CV_AMD64_YMM6F4:    *out = "ymm6f4"; return;
        case CV_AMD64_YMM6F5:    *out = "ymm6f5"; return;
        case CV_AMD64_YMM6F6:    *out = "ymm6f6"; return;
        case CV_AMD64_YMM6F7:    *out = "ymm6f7"; return;
        case CV_AMD64_YMM7F0:    *out = "ymm7f0"; return;
        case CV_AMD64_YMM7F1:    *out = "ymm7f1"; return;
        case CV_AMD64_YMM7F2:    *out = "ymm7f2"; return;
        case CV_AMD64_YMM7F3:    *out = "ymm7f3"; return;
        case CV_AMD64_YMM7F4:    *out = "ymm7f4"; return;
        case CV_AMD64_YMM7F5:    *out = "ymm7f5"; return;
        case CV_AMD64_YMM7F6:    *out = "ymm7f6"; return;
        case CV_AMD64_YMM7F7:    *out = "ymm7f7"; return;
        case CV_AMD64_YMM8F0:    *out = "ymm8f0"; return;
        case CV_AMD64_YMM8F1:    *out = "ymm8f1"; return;
        case CV_AMD64_YMM8F2:    *out = "ymm8f2"; return;
        case CV_AMD64_YMM8F3:    *out = "ymm8f3"; return;
        case CV_AMD64_YMM8F4:    *out = "ymm8f4"; return;
        case CV_AMD64_YMM8F5:    *out = "ymm8f5"; return;
        case CV_AMD64_YMM8F6:    *out = "ymm8f6"; return;
        case CV_AMD64_YMM8F7:    *out = "ymm8f7"; return;
        case CV_AMD64_YMM9F0:    *out = "ymm9f0"; return;
        case CV_AMD64_YMM9F1:    *out = "ymm9f1"; return;
        case CV_AMD64_YMM9F2:    *out = "ymm9f2"; return;
        case CV_AMD64_YMM9F3:    *out = "ymm9f3"; return;
        case CV_AMD64_YMM9F4:    *out = "ymm9f4"; return;
        case CV_AMD64_YMM9F5:    *out = "ymm9f5"; return;
        case CV_AMD64_YMM9F6:    *out = "ymm9f6"; return;
        case CV_AMD64_YMM9F7:    *out = "ymm9f7"; return;
        case CV_AMD64_YMM10F0:   *out = "ymm10f0"; return;
        case CV_AMD64_YMM10F1:   *out = "ymm10f1"; return;
        case CV_AMD64_YMM10F2:   *out = "ymm10f2"; return;
        case CV_AMD64_YMM10F3:   *out = "ymm10f3"; return;
        case CV_AMD64_YMM10F4:   *out = "ymm10f4"; return;
        case CV_AMD64_YMM10F5:   *out = "ymm10f5"; return;
        case CV_AMD64_YMM10F6:   *out = "ymm10f6"; return;
        case CV_AMD64_YMM10F7:   *out = "ymm10f7"; return;
        case CV_AMD64_YMM11F0:   *out = "ymm11f0"; return;
        case CV_AMD64_YMM11F1:   *out = "ymm11f1"; return;
        case CV_AMD64_YMM11F2:   *out = "ymm11f2"; return;
        case CV_AMD64_YMM11F3:   *out = "ymm11f3"; return;
        case CV_AMD64_YMM11F4:   *out = "ymm11f4"; return;
        case CV_AMD64_YMM11F5:   *out = "ymm11f5"; return;
        case CV_AMD64_YMM11F6:   *out = "ymm11f6"; return;
        case CV_AMD64_YMM11F7:   *out = "ymm11f7"; return;
        case CV_AMD64_YMM12F0:   *out = "ymm12f0"; return;
        case CV_AMD64_YMM12F1:   *out = "ymm12f1"; return;
        case CV_AMD64_YMM12F2:   *out = "ymm12f2"; return;
        case CV_AMD64_YMM12F3:   *out = "ymm12f3"; return;
        case CV_AMD64_YMM12F4:   *out = "ymm12f4"; return;
        case CV_AMD64_YMM12F5:   *out = "ymm12f5"; return;
        case CV_AMD64_YMM12F6:   *out = "ymm12f6"; return;
        case CV_AMD64_YMM12F7:   *out = "ymm12f7"; return;
        case CV_AMD64_YMM13F0:   *out = "ymm13f0"; return;
        case CV_AMD64_YMM13F1:   *out = "ymm13f1"; return;
        case CV_AMD64_YMM13F2:   *out = "ymm13f2"; return;
        case CV_AMD64_YMM13F3:   *out = "ymm13f3"; return;
        case CV_AMD64_YMM13F4:   *out = "ymm13f4"; return;
        case CV_AMD64_YMM13F5:   *out = "ymm13f5"; return;
        case CV_AMD64_YMM13F6:   *out = "ymm13f6"; return;
        case CV_AMD64_YMM13F7:   *out = "ymm13f7"; return;
        case CV_AMD64_YMM14F0:   *out = "ymm14f0"; return;
        case CV_AMD64_YMM14F1:   *out = "ymm14f1"; return;
        case CV_AMD64_YMM14F2:   *out = "ymm14f2"; return;
        case CV_AMD64_YMM14F3:   *out = "ymm14f3"; return;
        case CV_AMD64_YMM14F4:   *out = "ymm14f4"; return;
        case CV_AMD64_YMM14F5:   *out = "ymm14f5"; return;
        case CV_AMD64_YMM14F6:   *out = "ymm14f6"; return;
        case CV_AMD64_YMM14F7:   *out = "ymm14f7"; return;
        case CV_AMD64_YMM15F0:   *out = "ymm15f0"; return;
        case CV_AMD64_YMM15F1:   *out = "ymm15f1"; return;
        case CV_AMD64_YMM15F2:   *out = "ymm15f2"; return;
        case CV_AMD64_YMM15F3:   *out = "ymm15f3"; return;
        case CV_AMD64_YMM15F4:   *out = "ymm15f4"; return;
        case CV_AMD64_YMM15F5:   *out = "ymm15f5"; return;
        case CV_AMD64_YMM15F6:   *out = "ymm15f6"; return;
        case CV_AMD64_YMM15F7:   *out = "ymm15f7"; return;

        case CV_AMD64_YMM0D0:    *out = "ymm0d0"; return; // AVX floating-point double precise registers
        case CV_AMD64_YMM0D1:    *out = "ymm0d1"; return;
        case CV_AMD64_YMM0D2:    *out = "ymm0d2"; return;
        case CV_AMD64_YMM0D3:    *out = "ymm0d3"; return;
        case CV_AMD64_YMM1D0:    *out = "ymm1d0"; return;
        case CV_AMD64_YMM1D1:    *out = "ymm1d1"; return;
        case CV_AMD64_YMM1D2:    *out = "ymm1d2"; return;
        case CV_AMD64_YMM1D3:    *out = "ymm1d3"; return;
        case CV_AMD64_YMM2D0:    *out = "ymm2d0"; return;
        case CV_AMD64_YMM2D1:    *out = "ymm2d1"; return;
        case CV_AMD64_YMM2D2:    *out = "ymm2d2"; return;
        case CV_AMD64_YMM2D3:    *out = "ymm2d3"; return;
        case CV_AMD64_YMM3D0:    *out = "ymm3d0"; return;
        case CV_AMD64_YMM3D1:    *out = "ymm3d1"; return;
        case CV_AMD64_YMM3D2:    *out = "ymm3d2"; return;
        case CV_AMD64_YMM3D3:    *out = "ymm3d3"; return;
        case CV_AMD64_YMM4D0:    *out = "ymm4d0"; return;
        case CV_AMD64_YMM4D1:    *out = "ymm4d1"; return;
        case CV_AMD64_YMM4D2:    *out = "ymm4d2"; return;
        case CV_AMD64_YMM4D3:    *out = "ymm4d3"; return;
        case CV_AMD64_YMM5D0:    *out = "ymm5d0"; return;
        case CV_AMD64_YMM5D1:    *out = "ymm5d1"; return;
        case CV_AMD64_YMM5D2:    *out = "ymm5d2"; return;
        case CV_AMD64_YMM5D3:    *out = "ymm5d3"; return;
        case CV_AMD64_YMM6D0:    *out = "ymm6d0"; return;
        case CV_AMD64_YMM6D1:    *out = "ymm6d1"; return;
        case CV_AMD64_YMM6D2:    *out = "ymm6d2"; return;
        case CV_AMD64_YMM6D3:    *out = "ymm6d3"; return;
        case CV_AMD64_YMM7D0:    *out = "ymm7d0"; return;
        case CV_AMD64_YMM7D1:    *out = "ymm7d1"; return;
        case CV_AMD64_YMM7D2:    *out = "ymm7d2"; return;
        case CV_AMD64_YMM7D3:    *out = "ymm7d3"; return;
        case CV_AMD64_YMM8D0:    *out = "ymm8d0"; return;
        case CV_AMD64_YMM8D1:    *out = "ymm8d1"; return;
        case CV_AMD64_YMM8D2:    *out = "ymm8d2"; return;
        case CV_AMD64_YMM8D3:    *out = "ymm8d3"; return;
        case CV_AMD64_YMM9D0:    *out = "ymm9d0"; return;
        case CV_AMD64_YMM9D1:    *out = "ymm9d1"; return;
        case CV_AMD64_YMM9D2:    *out = "ymm9d2"; return;
        case CV_AMD64_YMM9D3:    *out = "ymm9d3"; return;
        case CV_AMD64_YMM10D0:   *out = "ymm10d0"; return;
        case CV_AMD64_YMM10D1:   *out = "ymm10d1"; return;
        case CV_AMD64_YMM10D2:   *out = "ymm10d2"; return;
        case CV_AMD64_YMM10D3:   *out = "ymm10d3"; return;
        case CV_AMD64_YMM11D0:   *out = "ymm11d0"; return;
        case CV_AMD64_YMM11D1:   *out = "ymm11d1"; return;
        case CV_AMD64_YMM11D2:   *out = "ymm11d2"; return;
        case CV_AMD64_YMM11D3:   *out = "ymm11d3"; return;
        case CV_AMD64_YMM12D0:   *out = "ymm12d0"; return;
        case CV_AMD64_YMM12D1:   *out = "ymm12d1"; return;
        case CV_AMD64_YMM12D2:   *out = "ymm12d2"; return;
        case CV_AMD64_YMM12D3:   *out = "ymm12d3"; return;
        case CV_AMD64_YMM13D0:   *out = "ymm13d0"; return;
        case CV_AMD64_YMM13D1:   *out = "ymm13d1"; return;
        case CV_AMD64_YMM13D2:   *out = "ymm13d2"; return;
        case CV_AMD64_YMM13D3:   *out = "ymm13d3"; return;
        case CV_AMD64_YMM14D0:   *out = "ymm14d0"; return;
        case CV_AMD64_YMM14D1:   *out = "ymm14d1"; return;
        case CV_AMD64_YMM14D2:   *out = "ymm14d2"; return;
        case CV_AMD64_YMM14D3:   *out = "ymm14d3"; return;
        case CV_AMD64_YMM15D0:   *out = "ymm15d0"; return;
        case CV_AMD64_YMM15D1:   *out = "ymm15d1"; return;
        case CV_AMD64_YMM15D2:   *out = "ymm15d2"; return;
        case CV_AMD64_YMM15D3:   *out = "ymm15d3"; return;

        case CV_AMD64_BND0:      *out = "bnd0"; return; // AMD64 MPX bounds registers
        case CV_AMD64_BND1:      *out = "bnd1"; return;
        case CV_AMD64_BND2:      *out = "bnd2"; return;
        case CV_AMD64_BND3:      *out = "bnd3"; return;
        case CV_AMD64_BNDCFGU:   *out = "bndcfgu"; return;
        case CV_AMD64_BNDSTATUS: *out = "bndstatus"; return;

        case CV_AMD64_XMM16:     *out = "xmm16"; return; // AVX-512 registers
        case CV_AMD64_XMM17:     *out = "xmm17"; return;
        case CV_AMD64_XMM18:     *out = "xmm18"; return;
        case CV_AMD64_XMM19:     *out = "xmm19"; return;
        case CV_AMD64_XMM20:     *out = "xmm20"; return;
        case CV_AMD64_XMM21:     *out = "xmm21"; return;
        case CV_AMD64_XMM22:     *out = "xmm22"; return;
        case CV_AMD64_XMM23:     *out = "xmm23"; return;
        case CV_AMD64_XMM24:     *out = "xmm24"; return;
        case CV_AMD64_XMM25:     *out = "xmm25"; return;
        case CV_AMD64_XMM26:     *out = "xmm26"; return;
        case CV_AMD64_XMM27:     *out = "xmm27"; return;
        case CV_AMD64_XMM28:     *out = "xmm28"; return;
        case CV_AMD64_XMM29:     *out = "xmm29"; return;
        case CV_AMD64_XMM30:     *out = "xmm30"; return;
        case CV_AMD64_XMM31:     *out = "xmm31"; return;

        case CV_AMD64_YMM16:     *out = "ymm16"; return;
        case CV_AMD64_YMM17:     *out = "ymm17"; return;
        case CV_AMD64_YMM18:     *out = "ymm18"; return;
        case CV_AMD64_YMM19:     *out = "ymm19"; return;
        case CV_AMD64_YMM20:     *out = "ymm20"; return;
        case CV_AMD64_YMM21:     *out = "ymm21"; return;
        case CV_AMD64_YMM22:     *out = "ymm22"; return;
        case CV_AMD64_YMM23:     *out = "ymm23"; return;
        case CV_AMD64_YMM24:     *out = "ymm24"; return;
        case CV_AMD64_YMM25:     *out = "ymm25"; return;
        case CV_AMD64_YMM26:     *out = "ymm26"; return;
        case CV_AMD64_YMM27:     *out = "ymm27"; return;
        case CV_AMD64_YMM28:     *out = "ymm28"; return;
        case CV_AMD64_YMM29:     *out = "ymm29"; return;
        case CV_AMD64_YMM30:     *out = "ymm30"; return;
        case CV_AMD64_YMM31:     *out = "ymm31"; return;

        case CV_AMD64_ZMM0:      *out = "zmm0"; return;
        case CV_AMD64_ZMM1:      *out = "zmm1"; return;
        case CV_AMD64_ZMM2:      *out = "zmm2"; return;
        case CV_AMD64_ZMM3:      *out = "zmm3"; return;
        case CV_AMD64_ZMM4:      *out = "zmm4"; return;
        case CV_AMD64_ZMM5:      *out = "zmm5"; return;
        case CV_AMD64_ZMM6:      *out = "zmm6"; return;
        case CV_AMD64_ZMM7:      *out = "zmm7"; return;
        case CV_AMD64_ZMM8:      *out = "zmm8"; return;
        case CV_AMD64_ZMM9:      *out = "zmm9"; return;
        case CV_AMD64_ZMM10:     *out = "zmm10"; return;
        case CV_AMD64_ZMM11:     *out = "zmm11"; return;
        case CV_AMD64_ZMM12:     *out = "zmm12"; return;
        case CV_AMD64_ZMM13:     *out = "zmm13"; return;
        case CV_AMD64_ZMM14:     *out = "zmm14"; return;
        case CV_AMD64_ZMM15:     *out = "zmm15"; return;
        case CV_AMD64_ZMM16:     *out = "zmm16"; return;
        case CV_AMD64_ZMM17:     *out = "zmm17"; return;
        case CV_AMD64_ZMM18:     *out = "zmm18"; return;
        case CV_AMD64_ZMM19:     *out = "zmm19"; return;
        case CV_AMD64_ZMM20:     *out = "zmm20"; return;
        case CV_AMD64_ZMM21:     *out = "zmm21"; return;
        case CV_AMD64_ZMM22:     *out = "zmm22"; return;
        case CV_AMD64_ZMM23:     *out = "zmm23"; return;
        case CV_AMD64_ZMM24:     *out = "zmm24"; return;
        case CV_AMD64_ZMM25:     *out = "zmm25"; return;
        case CV_AMD64_ZMM26:     *out = "zmm26"; return;
        case CV_AMD64_ZMM27:     *out = "zmm27"; return;
        case CV_AMD64_ZMM28:     *out = "zmm28"; return;
        case CV_AMD64_ZMM29:     *out = "zmm29"; return;
        case CV_AMD64_ZMM30:     *out = "zmm30"; return;
        case CV_AMD64_ZMM31:     *out = "zmm31"; return;

        case CV_AMD64_K0:        *out = "k0"; return;
        case CV_AMD64_K1:        *out = "k1"; return;
        case CV_AMD64_K2:        *out = "k2"; return;
        case CV_AMD64_K3:        *out = "k3"; return;
        case CV_AMD64_K4:        *out = "k4"; return;
        case CV_AMD64_K5:        *out = "k5"; return;
        case CV_AMD64_K6:        *out = "k6"; return;
        case CV_AMD64_K7:        *out = "k7"; return;

        case CV_AMD64_ZMM0H:     *out = "zmm0h"; return; // upper 256 bits of the first 16 AMD64 AVX-512 registers
        case CV_AMD64_ZMM1H:     *out = "zmm1h"; return;
        case CV_AMD64_ZMM2H:     *out = "zmm2h"; return;
        case CV_AMD64_ZMM3H:     *out = "zmm3h"; return;
        case CV_AMD64_ZMM4H:     *out = "zmm4h"; return;
        case CV_AMD64_ZMM5H:     *out = "zmm5h"; return;
        case CV_AMD64_ZMM6H:     *out = "zmm6h"; return;
        case CV_AMD64_ZMM7H:     *out = "zmm7h"; return;
        case CV_AMD64_ZMM8H:     *out = "zmm8h"; return;
        case CV_AMD64_ZMM9H:     *out = "zmm9h"; return;
        case CV_AMD64_ZMM10H:    *out = "zmm10h"; return;
        case CV_AMD64_ZMM11H:    *out = "zmm11h"; return;
        case CV_AMD64_ZMM12H:    *out = "zmm12h"; return;
        case CV_AMD64_ZMM13H:    *out = "zmm13h"; return;
        case CV_AMD64_ZMM14H:    *out = "zmm14h"; return;
        case CV_AMD64_ZMM15H:    *out = "zmm15h"; return;

        case CV_AMD64_XMM16L:    *out = "xmm16l"; return; // extended KATMAI registers
        case CV_AMD64_XMM17L:    *out = "xmm17l"; return;
        case CV_AMD64_XMM18L:    *out = "xmm18l"; return;
        case CV_AMD64_XMM19L:    *out = "xmm19l"; return;
        case CV_AMD64_XMM20L:    *out = "xmm20l"; return;
        case CV_AMD64_XMM21L:    *out = "xmm21l"; return;
        case CV_AMD64_XMM22L:    *out = "xmm22l"; return;
        case CV_AMD64_XMM23L:    *out = "xmm23l"; return;
        case CV_AMD64_XMM24L:    *out = "xmm24l"; return;
        case CV_AMD64_XMM25L:    *out = "xmm25l"; return;
        case CV_AMD64_XMM26L:    *out = "xmm26l"; return;
        case CV_AMD64_XMM27L:    *out = "xmm27l"; return;
        case CV_AMD64_XMM28L:    *out = "xmm28l"; return;
        case CV_AMD64_XMM29L:    *out = "xmm29l"; return;
        case CV_AMD64_XMM30L:    *out = "xmm30l"; return;
        case CV_AMD64_XMM31L:    *out = "xmm31l"; return;

        case CV_AMD64_XMM16_0:   *out = "xmm16_0"; return;
        case CV_AMD64_XMM17_0:   *out = "xmm17_0"; return;
        case CV_AMD64_XMM18_0:   *out = "xmm18_0"; return;
        case CV_AMD64_XMM19_0:   *out = "xmm19_0"; return;
        case CV_AMD64_XMM20_0:   *out = "xmm20_0"; return;
        case CV_AMD64_XMM21_0:   *out = "xmm21_0"; return;
        case CV_AMD64_XMM22_0:   *out = "xmm22_0"; return;
        case CV_AMD64_XMM23_0:   *out = "xmm23_0"; return;
        case CV_AMD64_XMM24_0:   *out = "xmm24_0"; return;
        case CV_AMD64_XMM25_0:   *out = "xmm25_0"; return;
        case CV_AMD64_XMM26_0:   *out = "xmm26_0"; return;
        case CV_AMD64_XMM27_0:   *out = "xmm27_0"; return;
        case CV_AMD64_XMM28_0:   *out = "xmm28_0"; return;
        case CV_AMD64_XMM29_0:   *out = "xmm29_0"; return;
        case CV_AMD64_XMM30_0:   *out = "xmm30_0"; return;
        case CV_AMD64_XMM31_0:   *out = "xmm31_0"; return;

        case CV_AMD64_XMM16H:    *out = "xmm16h"; return;
        case CV_AMD64_XMM17H:    *out = "xmm17h"; return;
        case CV_AMD64_XMM18H:    *out = "xmm18h"; return;
        case CV_AMD64_XMM19H:    *out = "xmm19h"; return;
        case CV_AMD64_XMM20H:    *out = "xmm20h"; return;
        case CV_AMD64_XMM21H:    *out = "xmm21h"; return;
        case CV_AMD64_XMM22H:    *out = "xmm22h"; return;
        case CV_AMD64_XMM23H:    *out = "xmm23h"; return;
        case CV_AMD64_XMM24H:    *out = "xmm24h"; return;
        case CV_AMD64_XMM25H:    *out = "xmm25h"; return;
        case CV_AMD64_XMM26H:    *out = "xmm26h"; return;
        case CV_AMD64_XMM27H:    *out = "xmm27h"; return;
        case CV_AMD64_XMM28H:    *out = "xmm28h"; return;
        case CV_AMD64_XMM29H:    *out = "xmm29h"; return;
        case CV_AMD64_XMM30H:    *out = "xmm30h"; return;
        case CV_AMD64_XMM31H:    *out = "xmm31h"; return;

        case CV_AMD64_EMM16H:    *out = "emm16h"; return;
        case CV_AMD64_EMM17H:    *out = "emm17h"; return;
        case CV_AMD64_EMM18H:    *out = "emm18h"; return;
        case CV_AMD64_EMM19H:    *out = "emm19h"; return;
        case CV_AMD64_EMM20H:    *out = "emm20h"; return;
        case CV_AMD64_EMM21H:    *out = "emm21h"; return;
        case CV_AMD64_EMM22H:    *out = "emm22h"; return;
        case CV_AMD64_EMM23H:    *out = "emm23h"; return;
        case CV_AMD64_EMM24H:    *out = "emm24h"; return;
        case CV_AMD64_EMM25H:    *out = "emm25h"; return;
        case CV_AMD64_EMM26H:    *out = "emm26h"; return;
        case CV_AMD64_EMM27H:    *out = "emm27h"; return;
        case CV_AMD64_EMM28H:    *out = "emm28h"; return;
        case CV_AMD64_EMM29H:    *out = "emm29h"; return;
        case CV_AMD64_EMM30H:    *out = "emm30h"; return;
        case CV_AMD64_EMM31H:    *out = "emm31h"; return;

        case CV_AMD64_SSP:       *out = "ssp"; return; // CET- Shadow Stack Pointer

        case CV_AMD64_TMM0:      *out = "tmm0"; return; // AMX tile registers
        case CV_AMD64_TMM1:      *out = "tmm1"; return;
        case CV_AMD64_TMM2:      *out = "tmm2"; return;
        case CV_AMD64_TMM3:      *out = "tmm3"; return;
        case CV_AMD64_TMM4:      *out = "tmm4"; return;
        case CV_AMD64_TMM5:      *out = "tmm5"; return;
        case CV_AMD64_TMM6:      *out = "tmm6"; return;
        case CV_AMD64_TMM7:      *out = "tmm7"; return;
        case CV_AMD64_TILECFG:   *out = "tilecfg"; return; // AMX tile cfg register

      }
      break;

    case CV_CFL_ARM64:
      //
      // ARM64 registers
      //
      switch ( reg )
      {
        case CV_ARM_NOREG:  *out = "noreg"; return;
        case CV_ARM64_W0:   *out = "w0";    return;
        case CV_ARM64_W1:   *out = "w1";    return;
        case CV_ARM64_W2:   *out = "w2";    return;
        case CV_ARM64_W3:   *out = "w3";    return;
        case CV_ARM64_W4:   *out = "w4";    return;
        case CV_ARM64_W5:   *out = "w5";    return;
        case CV_ARM64_W6:   *out = "w6";    return;
        case CV_ARM64_W7:   *out = "w7";    return;
        case CV_ARM64_W8:   *out = "w8";    return;
        case CV_ARM64_W9:   *out = "w9";    return;
        case CV_ARM64_W10:  *out = "w10";   return;
        case CV_ARM64_W11:  *out = "w11";   return;
        case CV_ARM64_W12:  *out = "w12";   return;
        case CV_ARM64_W13:  *out = "w13";   return;
        case CV_ARM64_W14:  *out = "w14";   return;
        case CV_ARM64_W15:  *out = "w15";   return;
        case CV_ARM64_W16:  *out = "w16";   return;
        case CV_ARM64_W17:  *out = "w17";   return;
        case CV_ARM64_W18:  *out = "w18";   return;
        case CV_ARM64_W19:  *out = "w19";   return;
        case CV_ARM64_W20:  *out = "w20";   return;
        case CV_ARM64_W21:  *out = "w21";   return;
        case CV_ARM64_W22:  *out = "w22";   return;
        case CV_ARM64_W23:  *out = "w23";   return;
        case CV_ARM64_W24:  *out = "w24";   return;
        case CV_ARM64_W25:  *out = "w25";   return;
        case CV_ARM64_W26:  *out = "w26";   return;
        case CV_ARM64_W27:  *out = "w27";   return;
        case CV_ARM64_W28:  *out = "w28";   return;
        case CV_ARM64_W29:  *out = "w29";   return;
        case CV_ARM64_WZR:  *out = "wzr";   return;

        // 64-bit integer registers
        case CV_ARM64_X0:   *out = "x0";    return;
        case CV_ARM64_X1:   *out = "x1";    return;
        case CV_ARM64_X2:   *out = "x2";    return;
        case CV_ARM64_X3:   *out = "x3";    return;
        case CV_ARM64_X4:   *out = "x4";    return;
        case CV_ARM64_X5:   *out = "x5";    return;
        case CV_ARM64_X6:   *out = "x6";    return;
        case CV_ARM64_X7:   *out = "x7";    return;
        case CV_ARM64_X8:   *out = "x8";    return;
        case CV_ARM64_X9:   *out = "x9";    return;
        case CV_ARM64_X10:  *out = "x10";   return;
        case CV_ARM64_X11:  *out = "x11";   return;
        case CV_ARM64_X12:  *out = "x12";   return;
        case CV_ARM64_X13:  *out = "x13";   return;
        case CV_ARM64_X14:  *out = "x14";   return;
        case CV_ARM64_X15:  *out = "x15";   return;
        case CV_ARM64_IP0:  *out = "x16";   return;
        case CV_ARM64_IP1:  *out = "x17";   return;
        case CV_ARM64_X18:  *out = "x18";   return;
        case CV_ARM64_X19:  *out = "x19";   return;
        case CV_ARM64_X20:  *out = "x20";   return;
        case CV_ARM64_X21:  *out = "x21";   return;
        case CV_ARM64_X22:  *out = "x22";   return;
        case CV_ARM64_X23:  *out = "x23";   return;
        case CV_ARM64_X24:  *out = "x24";   return;
        case CV_ARM64_X25:  *out = "x25";   return;
        case CV_ARM64_X26:  *out = "x26";   return;
        case CV_ARM64_X27:  *out = "x27";   return;
        case CV_ARM64_X28:  *out = "x28";   return;
        case CV_ARM64_FP:   *out = "fp";    return; // x29
        case CV_ARM64_LR:   *out = "lr";    return; // x30
        case CV_ARM64_SP:   *out = "sp";    return;
        case CV_ARM64_ZR:   *out = "xzr";   return;

        // 32-bit floating point registers
        case CV_ARM64_S0:   *out = "s0";   return;
        case CV_ARM64_S1:   *out = "s1";   return;
        case CV_ARM64_S2:   *out = "s2";   return;
        case CV_ARM64_S3:   *out = "s3";   return;
        case CV_ARM64_S4:   *out = "s4";   return;
        case CV_ARM64_S5:   *out = "s5";   return;
        case CV_ARM64_S6:   *out = "s6";   return;
        case CV_ARM64_S7:   *out = "s7";   return;
        case CV_ARM64_S8:   *out = "s8";   return;
        case CV_ARM64_S9:   *out = "s9";   return;
        case CV_ARM64_S10:  *out = "s10";  return;
        case CV_ARM64_S11:  *out = "s11";  return;
        case CV_ARM64_S12:  *out = "s12";  return;
        case CV_ARM64_S13:  *out = "s13";  return;
        case CV_ARM64_S14:  *out = "s14";  return;
        case CV_ARM64_S15:  *out = "s15";  return;
        case CV_ARM64_S16:  *out = "s16";  return;
        case CV_ARM64_S17:  *out = "s17";  return;
        case CV_ARM64_S18:  *out = "s18";  return;
        case CV_ARM64_S19:  *out = "s19";  return;
        case CV_ARM64_S20:  *out = "s20";  return;
        case CV_ARM64_S21:  *out = "s21";  return;
        case CV_ARM64_S22:  *out = "s22";  return;
        case CV_ARM64_S23:  *out = "s23";  return;
        case CV_ARM64_S24:  *out = "s24";  return;
        case CV_ARM64_S25:  *out = "s25";  return;
        case CV_ARM64_S26:  *out = "s26";  return;
        case CV_ARM64_S27:  *out = "s27";  return;
        case CV_ARM64_S28:  *out = "s28";  return;
        case CV_ARM64_S29:  *out = "s29";  return;
        case CV_ARM64_S30:  *out = "s30";  return;
        case CV_ARM64_S31:  *out = "s31";  return;

        // 64-bit floating point registers
        case CV_ARM64_D0:   *out = "d0";   return;
        case CV_ARM64_D1:   *out = "d1";   return;
        case CV_ARM64_D2:   *out = "d2";   return;
        case CV_ARM64_D3:   *out = "d3";   return;
        case CV_ARM64_D4:   *out = "d4";   return;
        case CV_ARM64_D5:   *out = "d5";   return;
        case CV_ARM64_D6:   *out = "d6";   return;
        case CV_ARM64_D7:   *out = "d7";   return;
        case CV_ARM64_D8:   *out = "d8";   return;
        case CV_ARM64_D9:   *out = "d9";   return;
        case CV_ARM64_D10:  *out = "d10";  return;
        case CV_ARM64_D11:  *out = "d11";  return;
        case CV_ARM64_D12:  *out = "d12";  return;
        case CV_ARM64_D13:  *out = "d13";  return;
        case CV_ARM64_D14:  *out = "d14";  return;
        case CV_ARM64_D15:  *out = "d15";  return;
        case CV_ARM64_D16:  *out = "d16";  return;
        case CV_ARM64_D17:  *out = "d17";  return;
        case CV_ARM64_D18:  *out = "d18";  return;
        case CV_ARM64_D19:  *out = "d19";  return;
        case CV_ARM64_D20:  *out = "d20";  return;
        case CV_ARM64_D21:  *out = "d21";  return;
        case CV_ARM64_D22:  *out = "d22";  return;
        case CV_ARM64_D23:  *out = "d23";  return;
        case CV_ARM64_D24:  *out = "d24";  return;
        case CV_ARM64_D25:  *out = "d25";  return;
        case CV_ARM64_D26:  *out = "d26";  return;
        case CV_ARM64_D27:  *out = "d27";  return;
        case CV_ARM64_D28:  *out = "d28";  return;
        case CV_ARM64_D29:  *out = "d29";  return;
        case CV_ARM64_D30:  *out = "d30";  return;
        case CV_ARM64_D31:  *out = "d31";  return;

        // 128-bit SIMD registers
        case CV_ARM64_Q0:   *out = "q0";   return;
        case CV_ARM64_Q1:   *out = "q1";   return;
        case CV_ARM64_Q2:   *out = "q2";   return;
        case CV_ARM64_Q3:   *out = "q3";   return;
        case CV_ARM64_Q4:   *out = "q4";   return;
        case CV_ARM64_Q5:   *out = "q5";   return;
        case CV_ARM64_Q6:   *out = "q6";   return;
        case CV_ARM64_Q7:   *out = "q7";   return;
        case CV_ARM64_Q8:   *out = "q8";   return;
        case CV_ARM64_Q9:   *out = "q9";   return;
        case CV_ARM64_Q10:  *out = "q10";  return;
        case CV_ARM64_Q11:  *out = "q11";  return;
        case CV_ARM64_Q12:  *out = "q12";  return;
        case CV_ARM64_Q13:  *out = "q13";  return;
        case CV_ARM64_Q14:  *out = "q14";  return;
        case CV_ARM64_Q15:  *out = "q15";  return;
        case CV_ARM64_Q16:  *out = "q16";  return;
        case CV_ARM64_Q17:  *out = "q17";  return;
        case CV_ARM64_Q18:  *out = "q18";  return;
        case CV_ARM64_Q19:  *out = "q19";  return;
        case CV_ARM64_Q20:  *out = "q20";  return;
        case CV_ARM64_Q21:  *out = "q21";  return;
        case CV_ARM64_Q22:  *out = "q22";  return;
        case CV_ARM64_Q23:  *out = "q23";  return;
        case CV_ARM64_Q24:  *out = "q24";  return;
        case CV_ARM64_Q25:  *out = "q25";  return;
        case CV_ARM64_Q26:  *out = "q26";  return;
        case CV_ARM64_Q27:  *out = "q27";  return;
        case CV_ARM64_Q28:  *out = "q28";  return;
        case CV_ARM64_Q29:  *out = "q29";  return;
        case CV_ARM64_Q30:  *out = "q30";  return;
        case CV_ARM64_Q31:  *out = "q31";  return;

        // Scalable Vector Extension (SVE)
        case CV_ARM64_Z0:   *out = "z0"; return;
        case CV_ARM64_Z1:   *out = "z1"; return;
        case CV_ARM64_Z2:   *out = "z2"; return;
        case CV_ARM64_Z3:   *out = "z3"; return;
        case CV_ARM64_Z4:   *out = "z4"; return;
        case CV_ARM64_Z5:   *out = "z5"; return;
        case CV_ARM64_Z6:   *out = "z6"; return;
        case CV_ARM64_Z7:   *out = "z7"; return;
        case CV_ARM64_Z8:   *out = "z8"; return;
        case CV_ARM64_Z9:   *out = "z9"; return;
        case CV_ARM64_Z10:  *out = "z10"; return;
        case CV_ARM64_Z11:  *out = "z11"; return;
        case CV_ARM64_Z12:  *out = "z12"; return;
        case CV_ARM64_Z13:  *out = "z13"; return;
        case CV_ARM64_Z14:  *out = "z14"; return;
        case CV_ARM64_Z15:  *out = "z15"; return;
        case CV_ARM64_Z16:  *out = "z16"; return;
        case CV_ARM64_Z17:  *out = "z17"; return;
        case CV_ARM64_Z18:  *out = "z18"; return;
        case CV_ARM64_Z19:  *out = "z19"; return;
        case CV_ARM64_Z20:  *out = "z20"; return;
        case CV_ARM64_Z21:  *out = "z21"; return;
        case CV_ARM64_Z22:  *out = "z22"; return;
        case CV_ARM64_Z23:  *out = "z23"; return;
        case CV_ARM64_Z24:  *out = "z24"; return;
        case CV_ARM64_Z25:  *out = "z25"; return;
        case CV_ARM64_Z26:  *out = "z26"; return;
        case CV_ARM64_Z27:  *out = "z27"; return;
        case CV_ARM64_Z28:  *out = "z28"; return;
        case CV_ARM64_Z29:  *out = "z29"; return;
        case CV_ARM64_Z30:  *out = "z30"; return;
        case CV_ARM64_Z31:  *out = "z31"; return;

        case CV_ARM64_P0:   *out = "p0"; return;
        case CV_ARM64_P1:   *out = "p1"; return;
        case CV_ARM64_P2:   *out = "p2"; return;
        case CV_ARM64_P3:   *out = "p3"; return;
        case CV_ARM64_P4:   *out = "p4"; return;
        case CV_ARM64_P5:   *out = "p5"; return;
        case CV_ARM64_P6:   *out = "p6"; return;
        case CV_ARM64_P7:   *out = "p7"; return;
        case CV_ARM64_P8:   *out = "p8"; return;
        case CV_ARM64_P9:   *out = "p9"; return;
        case CV_ARM64_P10:  *out = "p10"; return;
        case CV_ARM64_P11:  *out = "p11"; return;
        case CV_ARM64_P12:  *out = "p12"; return;
        case CV_ARM64_P13:  *out = "p13"; return;
        case CV_ARM64_P14:  *out = "p14"; return;
        case CV_ARM64_P15:  *out = "p15"; return;

        // SVE first-fault status register
        case CV_ARM64_FFR:  *out = "ffr"; return;
      }
      break;

    default:
      break;
  }
  out->sprnt("reg %d", reg);
}

```

`cvadd.h`:

```h
//
// Copyright (c) 2005-2025 Hex-Rays SA <support@hex-rays.com>
// ALL RIGHTS RESERVED.
//
// Utilities to extend cvconst.h and cvinfo.h
//
#pragma once

//----------------------------------------------------------------------------
inline bool is_intel386(uint32_t machine_type)
{
  return machine_type == CV_CFL_80386
      || machine_type == CV_CFL_80486
      || machine_type == CV_CFL_PENTIUM
      || machine_type == CV_CFL_PENTIUMII
      || machine_type == CV_CFL_PENTIUMIII;
}

//----------------------------------------------------------------------------
inline bool is_intel64(uint32_t machine_type)
{
  return machine_type == CV_CFL_X64;
}

//----------------------------------------------------------------------------
inline bool is_arm(uint32_t machine_type)
{
  return machine_type == CV_CFL_ARM3
      || machine_type == CV_CFL_ARM4
      || machine_type == CV_CFL_ARM4T
      || machine_type == CV_CFL_ARM5
      || machine_type == CV_CFL_ARM5T
      || machine_type == CV_CFL_ARM6
      || machine_type == CV_CFL_ARM7
      || machine_type == CV_CFL_ARMNT
      || machine_type == CV_CFL_ARM_XMAC
      || machine_type == CV_CFL_ARM_WMMX
      || machine_type == CV_CFL_THUMB
      || machine_type == CV_CFL_ARMNT;
}

//----------------------------------------------------------------------------
inline bool is_arm64(uint32_t machine_type)
{
  return machine_type == CV_CFL_ARM64;
}

//----------------------------------------------------------------------------
inline int get_stack_reg(uint32_t machine_type)
{
  return is_intel386(machine_type) ? CV_REG_ESP
       : is_intel64(machine_type)  ? CV_AMD64_RSP
       : is_arm(machine_type)      ? CV_ARM_SP
       : is_arm64(machine_type)    ? CV_ARM64_SP
       :                             CV_REG_NONE;
}

//----------------------------------------------------------------------------
inline int get_frame_reg(uint32_t machine_type)
{
  return is_intel386(machine_type) ? CV_REG_EBP
       : is_intel64(machine_type)  ? CV_AMD64_RBP
       : is_arm(machine_type)      ? CV_ARM_R11
       : is_arm64(machine_type)    ? CV_ARM64_FP
       :                             CV_REG_NONE;
}

```

`dia2_internal.h`:

```h
#pragma once

#include <dia2.h>
#include "pro.h"

typedef unsigned long   ulong;
enum MDTokenMapKind;

extern "C" const IID IID_IDiaSession10;
MIDL_INTERFACE("167e13cf-984d-ef4e-bd42-1723e6f34244")
IDiaSession10 :public IDiaSession
{
public:
	virtual HRESULT STDMETHODCALLTYPE addPublicSymbol(ushort const *, ulong, ulong, ulong, ulong, ulong, IDiaSymbol *, IDiaSymbol * *) = 0;
	virtual HRESULT STDMETHODCALLTYPE addStaticSymbol(ushort const *, ulong, ulong, ulong, ulong, ulong, IDiaSymbol *) = 0;
	virtual HRESULT STDMETHODCALLTYPE findSectionAddressByCrc(ulong, ulong, ulong, ulong, IDiaSymbol *, ulong *, ulong *, ulong *) = 0;
	virtual HRESULT STDMETHODCALLTYPE findThunkSymbol(IDiaSymbol *, IDiaSymbol * *) = 0;
	virtual HRESULT STDMETHODCALLTYPE makeThunkSymbol(ulong, ulong, IDiaSymbol * *) = 0;
	virtual HRESULT STDMETHODCALLTYPE mergeObjPDB(IDiaSymbol *) = 0;
	virtual HRESULT STDMETHODCALLTYPE commitObjPDBMerge(IDiaSymbol *) = 0;
	virtual HRESULT STDMETHODCALLTYPE cancelObjPDBMerge(IDiaSymbol *) = 0;
	virtual HRESULT STDMETHODCALLTYPE getLinkInfo(uchar *, ulong *, ulong *, ulong *, ulong *, ulong *) = 0;
	virtual HRESULT STDMETHODCALLTYPE isMiniPDB(int *) = 0;
	virtual HRESULT STDMETHODCALLTYPE prepareEnCRebuild(IDiaSymbol *) = 0;
	virtual HRESULT STDMETHODCALLTYPE dispose(void) = 0;
	virtual HRESULT STDMETHODCALLTYPE getRawSymbolsFromMiniPDB(ulong, ulong, ulong *, uchar * *) = 0;
	virtual HRESULT STDMETHODCALLTYPE getRawTypesFromMiniPDB(ulong, ulong *, uchar * *) = 0;
	virtual HRESULT STDMETHODCALLTYPE getPdbMappingsForMiniPDB(ulong *, ushort * *, ushort * *) = 0;
	virtual HRESULT STDMETHODCALLTYPE disposeObjForMiniPDB(ulong) = 0;
	virtual HRESULT STDMETHODCALLTYPE EnablePrefetching(void) = 0;
	virtual HRESULT STDMETHODCALLTYPE isPCTModuleFromMiniPDB(ulong, int *) = 0;
	virtual HRESULT STDMETHODCALLTYPE EnableMemoryMappedFileIO(void) = 0;
	virtual HRESULT STDMETHODCALLTYPE VSDebuggerPreloadPDBDone(void) = 0;
	virtual HRESULT STDMETHODCALLTYPE isLinkerGeneratedModuleInMiniPDB(ulong, int *) = 0;
	virtual HRESULT STDMETHODCALLTYPE getInlineeMDTokenMapSize(ulong *) = 0;
	virtual HRESULT STDMETHODCALLTYPE getInlineeMDTokenMap(ulong, ulong *, uchar *) = 0;
	virtual HRESULT STDMETHODCALLTYPE findChildrenHelper(IDiaSymbol *, enum SymTagEnum, ushort const *, ulong, ulong, bool, bool, IDiaEnumSymbols * *) = 0;
	virtual HRESULT STDMETHODCALLTYPE findLinesByLinenumHelper(bool, IDiaSymbol *, IDiaSourceFile *, ulong, ulong, IDiaEnumLineNumbers * *) = 0;
	virtual HRESULT STDMETHODCALLTYPE findSymbolsForAcceleratorPointerTagHelper(IDiaSymbol *, ulong, ulong, bool, IDiaEnumSymbols * *) = 0;
	virtual HRESULT STDMETHODCALLTYPE getMDTokenMapHelper(MDTokenMapKind, ulong, ulong *, uchar *) = 0;
	virtual HRESULT STDMETHODCALLTYPE getMDTokenMapHelper2(ulong, MDTokenMapKind, ulong, ulong *, uchar *) = 0;
	virtual HRESULT STDMETHODCALLTYPE getMDTokenRemapHelper(MDTokenMapKind, ulong, ulong *, uchar *) = 0;
	virtual HRESULT STDMETHODCALLTYPE getFunctionFragmentsHelper(ulong, ulong, ulong, ulong *, ulong *, ulong *) = 0;
};

//https://github.com/riverar/mach2/blob/master/src/dia2_internal.h
extern "C" const IID IID_IDiaDataSource10;
MIDL_INTERFACE("5c7e382a-93b4-4677-a6b5-cc28c3accb96")
IDiaDataSource10: public IDiaDataSource
{
public:
	virtual HRESULT STDMETHODCALLTYPE getRawPDBPtr(void** pppdb) = 0;
	virtual HRESULT STDMETHODCALLTYPE loadDataFromRawPDBPtr(void* ppdb) = 0;
	virtual HRESULT STDMETHODCALLTYPE getStreamSize(ushort const * stream, ulong* pcb) = 0;
	virtual HRESULT STDMETHODCALLTYPE getStreamRawData(ushort const * stream, ulong cbRead, uchar* pbData) = 0;
	virtual HRESULT STDMETHODCALLTYPE loadDataFromPdbEx(ushort const *, int) = 0;
	virtual HRESULT STDMETHODCALLTYPE loadAndValidateDataFromPdbEx(ushort const *, _GUID *, ulong, ulong, int) = 0;
	virtual HRESULT STDMETHODCALLTYPE loadDataForExeEx(ushort const *, ushort const *, IUnknown *, int) = 0;
	virtual HRESULT STDMETHODCALLTYPE loadDataFromIStreamEx(IStream *, int) = 0;
	virtual HRESULT STDMETHODCALLTYPE UNSUPPORTED_Method() = 0;
	virtual HRESULT STDMETHODCALLTYPE setPfnMiniPDBErrorCallback2(void *, long(*)(void *, ulong, ushort const * const, ushort const * const)) = 0;
	virtual HRESULT STDMETHODCALLTYPE setPfnMiniPDBNHBuildStatusCallback(void *, int(*)(void *, ulong)) = 0;
	virtual HRESULT STDMETHODCALLTYPE loadDataFromPdbEx2(ushort const *, int, int) = 0;
	virtual HRESULT STDMETHODCALLTYPE loadAndValidateDataFromPdbEx2(ushort const *, _GUID *, ulong, ulong, int, int) = 0;
	virtual HRESULT STDMETHODCALLTYPE loadDataForExeEx2(ushort const *, ushort const *, IUnknown *, int, int) = 0;
	virtual HRESULT STDMETHODCALLTYPE loadDataFromIStreamEx2(IStream *, int, int) = 0;
	virtual HRESULT STDMETHODCALLTYPE loadDataFromCodeViewInfoEx(ushort const *, ushort const *, ulong, uchar *, IUnknown *, int) = 0;
	virtual HRESULT STDMETHODCALLTYPE VSDebuggerPreloadPDBDone(void) = 0;
	virtual HRESULT STDMETHODCALLTYPE loadDataForExeEx3(ushort const *, ushort const *, IUnknown *, int, int, int) = 0;
	virtual HRESULT STDMETHODCALLTYPE usePdb(void *) = 0;
	virtual HRESULT STDMETHODCALLTYPE loadDataFromCodeViewInfoHelper(ushort const *, ushort const *, ulong, uchar *, IUnknown *, char const *) = 0;
};

class PDB1
{
public:
	virtual int32_t QueryInterfaceVersion() = 0;
	virtual int32_t QueryImplementationVersion() = 0;
	virtual BOOL QueryLastError() = 0;
	virtual PWSTR* QueryPDBName() = 0;
	virtual uint32_t QuerySignature() = 0;
	virtual uint32_t QueryAge() = 0;
	virtual void CreateDBI() = 0;
	virtual void OpenDBI() = 0;
	virtual void OpenTpi() = 0;
	virtual void OpenIpi() = 0;
	virtual void Commit() = 0;
	virtual void Close() = 0;
	virtual void OpenStream() = 0;
	virtual void GetEnumStreamNameMap() = 0;
	virtual void GetRawBytes() = 0;
	virtual void QueryPdbImplementationVersion() = 0;
	virtual void OpenDBIEx() = 0;
	virtual void CopyTo() = 0;
	virtual void OpenSrc() = 0;
	virtual void QueryLastErrorExW() = 0;
	virtual void QueryPDBNameExW() = 0;
	virtual BOOL QuerySignature2(GUID* guid) = 0;
	// ...
};
```

`makefile`:

```
PROC=pdb
CONFIGS=pdb.cfg

ifdef __NT__
  O1=old
  STDLIBS += wininet.lib
  STDLIBS += ole32.lib
  STDLIBS += oleaut32.lib
endif

include ../plugin.mak

$(F)pdb$(O): CC_WNO-$(call gte,$(GCC_VERSION),6.1) += -Wno-null-dereference


```

`merge.cpp`:

```cpp

/*
        Interactive disassembler (IDA).
        Copyright (c) 1990-2025 Hex-Rays SA <support@hex-rays.com>
        ALL RIGHTS RESERVED.

        Merge functionality.

*/

#include "pdb.hpp"
#include <mergemod.hpp>

//--------------------------------------------------------------------------
static const idbattr_info_t idpopts_info[] =
{
  IDI_ALTENTRY(PDB_DLLBASE_NODE_IDX, atag, sizeof(ea_t), 0, nullptr, "loading_result"),
};

SIMPLE_MODDATA_DIFF_HELPER(helper, "pdb", PDB_NODE_NAME, idpopts_info);

//--------------------------------------------------------------------------
void create_merge_handlers(merge_data_t &md)
{
  DEFINE_PLUGIN_MH_PARAMS("PDB", MH_TERSE);
  create_std_modmerge_handlers(mhp, data_id, helper);
}

```

`misc.cpp`:

```cpp

//----------------------------------------------------------------------
static const char *symtag_to_string(uint32 tag)
{
  static const char *const names[] =
  {
    "Null",
    "Exe",
    "Compiland",
    "CompilandDetails",
    "CompilandEnv",
    "Function",
    "Block",
    "Data",
    "Annotation",
    "Label",
    "PublicSymbol",
    "UDT",
    "Enum",
    "FunctionType",
    "PointerType",
    "ArrayType",
    "BaseType",
    "Typedef",
    "BaseClass",
    "Friend",
    "FunctionArgType",
    "FuncDebugStart",
    "FuncDebugEnd",
    "UsingNamespace",
    "VTableShape",
    "VTable",
    "Custom",
    "Thunk",
    "CustomType",
    "ManagedType",
    "Dimension"
  };
  return tag < qnumber(names) ? names[tag] : "???";
}

```

`misc.h`:

```h
#pragma once

#include <fpro.h>
#include <md5.h>

#ifdef _DEBUG
#define ASSERT(expr) QASSERT(__LINE__, expr)
#else
#define ASSERT(expr) ((void)0)
#endif

inline qwstring utf8_utf16(const char * in)
{
	qwstring out;
	bool bResult = utf8_utf16(&out, in);
	ASSERT(bResult);
	return out;
}

inline qstring utf8_acp(const char * in)
{
	qstring out;
	bool bResult = change_codepage(&out, in, CP_UTF8, CP_ACP);
	ASSERT(bResult);
	return out;
}

inline qstring utf16_utf8(const wchar16_t * in)
{
	qstring out;
	bool bResult = utf16_utf8(&out, in);
	ASSERT(bResult);
	return out;
}

inline qstring utf16_acp(const wchar16_t * in)
{
	qstring utf8(utf16_utf8(in));
	qstring out(utf8_acp(utf8.c_str()));
	return out;
}

inline uint64 qfilesize_utf8(const char * fname_utf8)
{
	qwstring fname_utf16(utf8_utf16(fname_utf8));
	//qfilesize目前有BUG，内部未先将参数转换为ANSI格式，即使转换成ANSI格式也会有问题，不支持Unicode路径
	//qstat 也一样有这个问题
	//只有qfilelength没有这个问题，不过它需要打开文件，开销较大，所以我们不使用
	WIN32_FILE_ATTRIBUTE_DATA FileAttribData = { 0 };
	GetFileAttributesExW(fname_utf16.c_str(), GetFileExInfoStandard, &FileAttribData);
	LARGE_INTEGER RetValue = { FileAttribData.nFileSizeLow, (LONG)FileAttribData.nFileSizeHigh };
	return RetValue.QuadPart;
}

inline void MD5_FromData(const uchar* buf, unsigned int len, uchar digest[16])
{
	MD5Context ctx;
	MD5Init(&ctx);
	MD5Update(&ctx, buf, len);
	MD5Final(digest, &ctx);
}

static qstring GetFileContext(const char* pszFileName, size_t& nFileSize, const char* pszMode = "rb")
{
	void* lpFileBuf = qalloc(nFileSize);
	if (!lpFileBuf)
	{
		ASSERT(lpFileBuf);
		return nullptr;
	}
	FILE* f = qfopen(pszFileName, pszMode);
	if (!f)
	{
		ASSERT(f);
		return nullptr;
	}
	nFileSize = qfread(f, lpFileBuf, sizeof(uchar) * nFileSize);
	qfclose(f);

	qstring result((const char*)lpFileBuf, nFileSize);
	qfree(lpFileBuf);
	lpFileBuf = nullptr;
	return result;
}

//此函数来自https://stackoverflow.com/questions/14374272/how-to-parse-version-number-to-compare-it
/*
 * return 1 if v1 > v2
 * return 0 if v1 = v2
 * return -1 if v1 < v2
 */
static int CompareFileVersion(const wchar_t* v1, const wchar_t* v2)
{
	int i;
	int oct_v1[4], oct_v2[4];
	int ret1 = swscanf(v1, L"%d.%d.%d.%d", &oct_v1[0], &oct_v1[1], &oct_v1[2], &oct_v1[3]);
	int ret2 = swscanf(v2, L"%d.%d.%d.%d", &oct_v2[0], &oct_v2[1], &oct_v2[2], &oct_v2[3]);
	ASSERT(ret1 == 4 && ret2 == 4);
	if (ret1 != 4 || ret2 != 4)
	{
		return wcscmp(v1, v2);
	}

	for (i = 0; i < 4; i++)
	{
		if (oct_v1[i] > oct_v2[i])
			return 1;
		else if (oct_v1[i] < oct_v2[i])
			return -1;
	}

	return 0;
}
```

`msdia.cpp`:

```cpp

// This file is included from 4 places:
//      - efd/pdb.cpp                   efd: to dump pdb contents
//      - base/pdb2til.cpp              tilib: to convert pdb to til
//      - plugins/pdb/pdb.cpp           ida: read pdb info and populate idb
//      - dbg/win32_server/tilfuncs.cpp win32_server: read pdb info and send it to ida
//
// The following symbols may be defined:
// PDB_PLUGIN           pdb
// PDB_WIN32_SERVER     win32_server

#include <diskio.hpp>

#include "msdia.hpp"

#include "../../ldr/pe/pe.h"
#include "pdblocal.cpp"
#include "dia2_internal.h"
#include "Program.h"
//因为从Visual Studio 2010开始DIA SDK的各个接口的虚表结构就改变了(虽然接口名字并没改变还是叫IDiaSession、IDiaSymbol等)，
//因此一套源码不能编译为同时支持两种不同虚表结构的接口的组件
//使用低于Visual Studio 2010提供的DIA SDK的版本时需要注释掉下面这个__IS_MSDIA100_OR_GREATER__宏，不然会报错提示
#define __IS_MSDIA100_OR_GREATER__
#ifdef __IS_MSDIA100_OR_GREATER__
__if_not_exists(IDiaSession::findChildrenEx)
{
    static int temp_result_for__IS_MSDIA100_OR_GREATER__ = _CrtDbgReportW(_CRT_ASSERT, _CRT_WIDE(__FILE__), __LINE__, nullptr, L"%ls", L"PLEASE undefine __IS_MSDIA100_OR_GREATER__");
}
#endif

//lint -esym(843, g_diadlls, g_pdb_errors, PathIsUNC) could be declared as const

int pdb_session_t::session_count = 0;
bool pdb_session_t::co_initialized = false;

#ifndef _INC_SHLWAPI
typedef BOOL (__stdcall *PathIsUNC_t)(LPCTSTR pszPath);
static PathIsUNC_t PathIsUNC = nullptr;
#endif

static bool check_for_odd_paths(const char *fname);

//---------------------------------------------------------------------------
class msdia_reader_t
{
public:
  virtual ~msdia_reader_t() {}
  virtual bool read(uint64 offset, void *buf, uint32 count, uint32 *nread) = 0;
  virtual bool setup(void) { return true; }
};

//---------------------------------------------------------------------------
class local_exe_msdia_reader_t : public msdia_reader_t
{
  LPCWSTR FileName;
  HANDLE hFile;

public:
  local_exe_msdia_reader_t(LPCWSTR _FileName)
  {
    FileName = _FileName;
    hFile = INVALID_HANDLE_VALUE;
  }

  ~local_exe_msdia_reader_t(void)
  {
    if ( hFile != INVALID_HANDLE_VALUE )
      CloseHandle(hFile);
  }

  virtual bool setup(void) override
  {
    hFile = CreateFileW(
      FileName,
      GENERIC_READ,
      FILE_SHARE_READ | FILE_SHARE_WRITE,
      nullptr,
      OPEN_EXISTING,
      0,
      nullptr);
    return hFile != INVALID_HANDLE_VALUE;
  }

  virtual bool read(uint64 offset, void *buf, uint32 count, uint32 *nread) override
  {
    if ( hFile == INVALID_HANDLE_VALUE )
      return false;

    LARGE_INTEGER pos;
    pos.QuadPart = (LONGLONG) offset;
    if ( SetFilePointerEx(hFile, pos, nullptr, FILE_BEGIN) == 0 )
      return false;

    if ( ReadFile(hFile, buf, count, (DWORD *) nread, nullptr) == 0 )
      return false;

    return true;
  }
};

#ifdef PDB_PLUGIN
//---------------------------------------------------------------------------
class local_mem_msdia_reader_t : public msdia_reader_t
{
public:
  virtual bool read(uint64 offset, void *buf, uint32 count, uint32 *nread) override
  {
    if ( get_bytes(buf, count, offset) != count )
      return false;
    *nread = count;
    return true;
  }
};

#elif defined(PDB_WIN32_SERVER)
//---------------------------------------------------------------------------
class win32_msdia_reader_t : public msdia_reader_t
{
  pdb_remote_session_t *pdb_rsess;
  pdb_rr_kind_t kind;
public:
  win32_msdia_reader_t(void *_pdb_rsess, pdb_rr_kind_t _kind)
  {
    pdb_rsess = (pdb_remote_session_t *) _pdb_rsess;
    kind = _kind;
  }

  virtual bool read(uint64 offset, void *buf, uint32 count, uint32 *nread) override
  {
    return pdb_rsess->client_read_request.request_read(kind, offset, count, buf, nread);
  }
};

#endif

//----------------------------------------------------------------------
// Common code for PDB handling
//----------------------------------------------------------------------
class CCallback : public IDiaLoadCallback2,
                  public IDiaReadExeAtRVACallback,
                  public IDiaReadExeAtOffsetCallback
{
  unsigned int m_nRefCount;
  ea_t m_load_address;
  msdia_reader_t *msdia_reader;
  pdb_session_t *pdb_session;
  DWORDLONG last_cv_off;
  ea_t last_cv_rva;
public:
  CCallback(pdb_session_t *_pdb_session,
        msdia_reader_t *_msdia_reader,
        ea_t _load_address)
    : msdia_reader(_msdia_reader),
      m_load_address(_load_address),
      // Note: we initialize the reference count to 1 since the only
      //       instance of this object is created in the stack, and
      //       the destructor will take care of the cleanup.
      m_nRefCount(1),
      pdb_session(_pdb_session),
      last_cv_off(0),
      last_cv_rva(BADADDR)
  {
  }

  // IUnknown
  ULONG STDMETHODCALLTYPE AddRef()
  {
    return InterlockedIncrement(&m_nRefCount);
  }

  ULONG STDMETHODCALLTYPE Release()
  {
    // Note: we don't check the reference count and delete the object
    //       (see comment for the m_nRefCount field).
    return InterlockedDecrement(&m_nRefCount);
  }

  HRESULT STDMETHODCALLTYPE QueryInterface(REFIID rid, void **ppUnk)
  {
    if ( ppUnk == nullptr )
      return E_INVALIDARG;

    *ppUnk = nullptr;
    if ( rid == __uuidof(IDiaLoadCallback2) || rid == __uuidof(IDiaLoadCallback) )
    {
      *ppUnk = (IDiaLoadCallback2 *)this;
    }
    else if ( rid == __uuidof(IDiaReadExeAtRVACallback) )
    {
      // we may use only one of IDiaReadExeAtRVACallback and IDiaReadExeAtOffsetCallback
      // claiming that both are supported will lead to crashes in MSDIA
      if ( m_load_address != BADADDR )
        *ppUnk = (IDiaReadExeAtRVACallback *)this;
    }
    else if ( rid == __uuidof(IDiaReadExeAtOffsetCallback) )
    {
      // see the comment above about IDiaReadExeAtRVACallback
      if ( m_load_address == BADADDR )
        *ppUnk = (IDiaReadExeAtOffsetCallback *)this;
    }
    else if ( rid == __uuidof(IUnknown) )
    {
      *ppUnk = (IUnknown *)(IDiaLoadCallback *)this;
    }
    if ( *ppUnk == nullptr )
      return E_NOINTERFACE;
    AddRef();
    return S_OK;
  }

  HRESULT STDMETHODCALLTYPE NotifyDebugDir(
        BOOL fExecutable,
        DWORD cbData,
        BYTE data[])
  {
    // msdia90.dll can crash on bogus CV data
    // so we remember the offset here and check it in ReadFileAt
    if ( fExecutable && cbData >= sizeof(debug_entry_t) )
    {
      debug_entry_t &de = *(debug_entry_t *)data;
      if ( de.type == DBG_CV )
      {
        last_cv_off = de.seek;
        last_cv_rva = de.rva;
      }
    }
    return S_OK;
  }
  HRESULT STDMETHODCALLTYPE NotifyOpenDBG(
        LPCOLESTR dbgPath,
        HRESULT resultCode)
  {
    if ( resultCode == S_OK )
      deb(IDA_DEBUG_DEBUGGER, "MSDIA: dbg file \"%S\" matched\n", dbgPath);
    else
      deb(IDA_DEBUG_DEBUGGER, "MSDIA: \"%S\": %s\n", dbgPath, pdberr(resultCode));

    return S_OK;
  }

  HRESULT STDMETHODCALLTYPE NotifyOpenPDB(
        LPCOLESTR pdbPath,
        HRESULT resultCode)
  {
    if ( resultCode == S_OK )
      deb(IDA_DEBUG_DEBUGGER, "MSDIA: pdb file \"%S\" matched\n", pdbPath);
    else
      deb(IDA_DEBUG_DEBUGGER, "MSDIA: \"%S\": %s\n", pdbPath, pdberr(resultCode));
#ifdef _DEBUG
    qstring spath;
    utf16_utf8(&spath, pdbPath);
    pdb_session->_pdb_path = spath;
#endif
    return S_OK;
  }
  HRESULT STDMETHODCALLTYPE RestrictRegistryAccess()
  {
    // return hr != S_OK to prevent querying the registry for symbol search paths
    return S_OK;
  }
  HRESULT STDMETHODCALLTYPE RestrictSymbolServerAccess()
  {
    // return hr != S_OK to prevent accessing a symbol server
    return S_OK;
  }
  HRESULT STDMETHODCALLTYPE RestrictOriginalPathAccess()
  {
    // return hr != S_OK to prevent querying the registry for symbol search paths
    return S_OK;
  }
  HRESULT STDMETHODCALLTYPE RestrictReferencePathAccess()
  {
    // return hr != S_OK to prevent accessing a symbol server
    return S_OK;
  }
  HRESULT STDMETHODCALLTYPE RestrictDBGAccess()
  {
    return S_OK;
  }
  HRESULT STDMETHODCALLTYPE RestrictSystemRootAccess()
  {
    return S_OK;
  }

  bool check_codeview_data(BYTE pbData[], DWORD cbData, qwstring& wspath)
  {
    bool ok = true;
    if ( cbData > 4 )
    {
      // check that the data has a valid NB or RSDS signature and PDB path doesn't look suspicious
      ok = false;
      if ( pbData[0] == 'N' && pbData[1] == 'B' && cbData >= sizeof(cv_info_pdb20_t) )
      {
        char *pdbname = (char*)pbData + sizeof(cv_info_pdb20_t);
        pbData[cbData-1] = '\0';
        ok = check_for_odd_paths(pdbname);
      }
      else if ( memcmp(pbData, "RSDS", 4) == 0 && cbData >= sizeof(rsds_t) )
      {
        char *pdbname = (char*)pbData + sizeof(rsds_t);
        pbData[cbData-1] = '\0';
        ok = check_for_odd_paths(pdbname);
        if (ok)
        {
            void try_download_pdb_from_sym_server_by_idm_when_not_exist(clsid_t & guid, uint32 age, const char* pdb_path, qstring & spath);

            rsds_t* pdb_info = (rsds_t*)pbData;
            qstring spath = utf16_utf8(wspath.c_str());
            try_download_pdb_from_sym_server_by_idm_when_not_exist(pdb_info->guid, pdb_info->age, pdbname, spath);
        }
      }
    }
    return ok;
  }

  // IDiaReadExeAtRVACallback
  HRESULT STDMETHODCALLTYPE ReadExecutableAtRVA(
        DWORD relativeVirtualAddress,
        DWORD cbData,
        DWORD *pcbData,
        BYTE data[])
  {
    ea_t ea = m_load_address + relativeVirtualAddress;
    if ( !msdia_reader->read(ea, data, cbData, (uint32 *) pcbData) )
      return E_FAIL;
    // are we reading the CV debug directory entry?
    if ( relativeVirtualAddress == last_cv_rva )
      return check_codeview_data(data, cbData, pdb_session->wspath) ? S_OK : E_FAIL;
    return S_OK;
  }

  // IDiaReadExeAtOffsetCallback
  HRESULT STDMETHODCALLTYPE ReadExecutableAt(
        DWORDLONG fileOffset,
        DWORD cbData,
        DWORD *pcbData,
        BYTE data[])
  {
    if ( !msdia_reader->read(fileOffset, data, cbData, (uint32 *) pcbData) )
      return E_FAIL;
    // are we reading the CV debug directory entry?
    if ( fileOffset != 0 && last_cv_off == fileOffset )
      return check_codeview_data(data, cbData, pdb_session->wspath) ? S_OK : E_FAIL;
    return S_OK;
  }
};

//---------------------------------------------------------------------------
static const char *const g_pdb_errors[] =
{
  "Operation successful (E_PDB_OK)",
  "(E_PDB_USAGE)",
  "Out of memory (E_PDB_OUT_OF_MEMORY)",
  "(E_PDB_FILE_SYSTEM)",
  "Failed to open the file, or the file has an invalid format (E_PDB_NOT_FOUND)",
  "Signature does not match (E_PDB_INVALID_SIG)",
  "Age does not match (E_PDB_INVALID_AGE)",
  "(E_PDB_PRECOMP_REQUIRED)",
  "(E_PDB_OUT_OF_TI)",
  "(E_PDB_NOT_IMPLEMENTED)",
  "(E_PDB_V1_PDB)",
  "Attempted to access a file with an obsolete format (E_PDB_FORMAT)",
  "(E_PDB_LIMIT)",
  "(E_PDB_CORRUPT)",
  "(E_PDB_TI16)",
  "(E_PDB_ACCESS_DENIED)",
  "(E_PDB_ILLEGAL_TYPE_EDIT)",
  "(E_PDB_INVALID_EXECUTABLE)",
  "(E_PDB_DBG_NOT_FOUND)",
  "(E_PDB_NO_DEBUG_INFO)",
  "(E_PDB_INVALID_EXE_TIMESTAMP)",
  "(E_PDB_RESERVED)",
  "(E_PDB_DEBUG_INFO_NOT_IN_PDB)",
  "(E_PDB_SYMSRV_BAD_CACHE_PATH)",
  "(E_PDB_SYMSRV_CACHE_FULL)",
};

//---------------------------------------------------------------------------
inline void pdberr_suggest_vs_runtime(HRESULT hr)
{
  if ( hr == E_NOINTERFACE )
  {
    msg("<< It appears that MS DIA SDK is not installed.\n");
#ifndef __IS_MSDIA100_OR_GREATER__
#ifdef __X86__
    msg("Please try installing \"Microsoft Visual C++ 2008 Redistributable Package / x86\" >>\n");
#else
    msg("Please try installing \"Microsoft Visual C++ 2008 Redistributable Package / x64\" >>\n");
#endif
#endif
  }
}

//---------------------------------------------------------------------------
const char *pdberr(int code)
{
  switch ( code )
  {                         // tab in first pos is flag for replace warning to msg
    case E_INVALIDARG:      return "Invalid parameter.";
    case E_UNEXPECTED:      return "Data source has already been prepared.";
    default:
      if ( code >= E_PDB_OK && (code - E_PDB_OK) < qnumber(g_pdb_errors) )
        return g_pdb_errors[code - E_PDB_OK];
  }
  return winerr(code);
}

//----------------------------------------------------------------------
#ifdef __IS_MSDIA100_OR_GREATER__
static const GUID* const g_msdiav[] = { &__uuidof(DiaSource) };
static const int         g_diaver[] = { 1400 };
static const char* const g_diadlls[] = { "msdia140.dll" };
#else
class DECLSPEC_UUID("4c41678e-887b-4365-a09e-925d28db33c2") DiaSource90;
class DECLSPEC_UUID("1fbd5ec4-b8e4-4d94-9efe-7ccaf9132c98") DiaSource80;
class DECLSPEC_UUID("31495af6-0897-4f1e-8dac-1447f10174a1") DiaSource71;
static const GUID *const g_d90 = &__uuidof(DiaSource90);  // msdia90.dll
static const GUID *const g_d80 = &__uuidof(DiaSource80);  // msdia80.dll
static const GUID *const g_d71 = &__uuidof(DiaSource71);  // msdia71.dll
static const GUID *const g_msdiav[] = { g_d90, g_d80, g_d71 };
static const int         g_diaver[] = { 900,   800,   710 };
static const char *const g_diadlls[] = { "msdia90.dll", "msdia80.dll", "msdia71.dll" };
#endif

//----------------------------------------------------------------------
HRESULT __stdcall CoCreateInstanceNoReg(
        LPCTSTR szDllName,
        IN REFCLSID rclsid,
        IUnknown *pUnkOuter,
        IN REFIID riid,
        OUT LPVOID FAR *ppv,
        OUT HMODULE *phMod)
{
  // http://lallousx86.wordpress.com/2007/01/29/emulating-cocreateinstance/
  HRESULT hr = REGDB_E_CLASSNOTREG;
  HMODULE hDll;
  do
  {
    hDll = LoadLibrary(szDllName);
    if ( hDll == nullptr )
      break;

    HRESULT (__stdcall *GetClassObject)(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);
    *(FARPROC*)&GetClassObject = GetProcAddress(hDll, "DllGetClassObject");
    if ( GetClassObject == nullptr )
      break;

    IClassFactory *pIFactory;
    hr = GetClassObject(rclsid, IID_IClassFactory, (LPVOID *)&pIFactory);
    if ( FAILED(hr) )
      break;

    hr = pIFactory->CreateInstance(pUnkOuter, riid, ppv);
    pIFactory->Release();
  }
  while ( false );

  if ( FAILED(hr) && hDll != nullptr )
    FreeLibrary(hDll);
  else
    *phMod = hDll;

  return hr;
}

//----------------------------------------------------------------------------
// Note: This will return the machine type, as it is known
// by the IDB, which might not be what you think. For example,
// if you need to tell x86 and x64 apart, you're out of luck.
// You may want to consider looking at pdbaccess_t's
// get_machine_type().
static DWORD get_machine_type(DWORD dwMachType)
{
  DWORD machine;
  switch ( dwMachType )
  {
    default:
      machine = CV_CFL_80386;
      break;
    case IMAGE_FILE_MACHINE_IA64:
      machine = CV_CFL_IA64;
      break;
    case IMAGE_FILE_MACHINE_AMD64:
      machine = CV_CFL_AMD64;
      break;
    case IMAGE_FILE_MACHINE_THUMB:
    case IMAGE_FILE_MACHINE_ARM:
      machine = CV_CFL_ARM6;
      break;
    case PECPU_ARMV7:
      machine = CV_CFL_ARM7;
      break;
    case PECPU_ARM64:
      machine = CV_CFL_ARM64;
      break;
    case PECPU_PPC:
      machine = CV_CFL_PPC620;
      break;
    case PECPU_PPCFP:
      machine = CV_CFL_PPCFP;
      break;
    case PECPU_PPCBE:
      machine = CV_CFL_PPCBE;
      break;
  }
  return machine;
}

//----------------------------------------------------------------------
pdb_session_t::~pdb_session_t()
{
  if ( --session_count == 0 && co_initialized )
  {
    CoUninitialize();
    co_initialized = false;
  }
}

//----------------------------------------------------------------------
void pdb_session_t::close()
{
  if ( pdb_access != nullptr )
  {
    delete pdb_access;
    pdb_access = nullptr;
  }

  if ( dia_hmod != nullptr )
  {
    FreeLibrary(dia_hmod);
    dia_hmod = nullptr;
  }

#ifdef _DEBUG
  if ( !_pdb_path.empty() && qfileexist(_pdb_path.begin() ) )
  {
    HANDLE hFile = CreateFileA(_pdb_path.begin(), GENERIC_READ, /*FILE_SHARE_READ*/ 0, 0, OPEN_EXISTING, 0, 0);
    if ( hFile == INVALID_HANDLE_VALUE )
      warning("Couldn't acquire probing lock to \"%s\"; file might be still locked by IDA", _pdb_path.begin());
    else
      CloseHandle(hFile);
  }
#endif
}

//----------------------------------------------------------------------
#include "dbghelp.h"
// copied from dbghelp.h
#ifndef SSRVOPT_CALLBACK
#define SSRVOPT_CALLBACK            0x000001
#endif
#ifndef SSRVOPT_SETCONTEXT
#define SSRVOPT_SETCONTEXT          0x000800
#endif
#ifndef SSRVOPT_TRACE
#define SSRVOPT_TRACE               0x000400
#endif
#ifndef SSRVACTION_TRACE
#define SSRVACTION_TRACE        1
#define SSRVACTION_QUERYCANCEL  2
#define SSRVACTION_EVENT        3
#define SSRVACTION_EVENTW       4
#endif
#ifndef SSRVACTION_SIZE
#define SSRVACTION_SIZE         5
#endif

//----------------------------------------------------------------------
static void symsrv_dprint(const char *str)
{
  qstring qbuf(str);
  qbuf.replace("\b", ""); // remove backspaces
  if ( qbuf.empty() )
    return;
  // strings usually already start with "SYMSRV:  "
  if ( strncmp(qbuf.c_str(), "SYMSRV:  ", 9) != 0 )
    qbuf.insert(0, "SYMSRV:  ");
  // strings usually already end with '\n'
  if ( qbuf.last() != '\n' )
    qbuf.append('\n');
  deb(IDA_DEBUG_DEBUGGER, "%s", qbuf.c_str());
}

static int GetDownloadPercentFromSymbolServerMessage(CString& Src)
{
	int result = 0;
	if (Src.Find("copied") == -1)
	{
		if (Src.Find("percent") != -1)
		{
			Src.TrimLeft('\b');
			char* EndPtr = nullptr;
			result = strtol(Src, &EndPtr, 10);
		}
	}
	else
	{
		result = 100;
	}
	return result;
}

//----------------------------------------------------------------------
static BOOL CALLBACK SymbolServerCallback(
        UINT_PTR action,
        ULONG64 data,
        ULONG64 context)
{
  bool *wait_box_shown = (bool *) context;
  switch ( action )
  {
    case SSRVACTION_SIZE:
      {
        if ( !*wait_box_shown )
          show_wait_box("Downloading pdb...");
        *wait_box_shown = true;
      }
      break;
    case SSRVACTION_QUERYCANCEL:
      {
        //https://docs.microsoft.com/en-us/windows/win32/api/dbghelp/nc-dbghelp-psymbolservercallbackproc
        //文档说明是取消变量*data是ULONG64类型
        ULONG64* do_cancel = (ULONG64*)data;
        // apparently this can arrive before SSRVACTION_SIZE
        // so check that we did show the waitbox
        if ( *wait_box_shown && user_cancelled() )
          *do_cancel = TRUE;
        else
          *do_cancel = FALSE;
      }
      break;
    case SSRVACTION_TRACE:
      symsrv_dprint((const char *)data);
      ATLTRACE((const char*)data);
      break;
    case SSRVACTION_EVENT:
      IMAGEHLP_CBA_EVENT *pev = (IMAGEHLP_CBA_EVENT*)data;
      // Event information is usually all zero.
      if ( pev->severity != 0 || pev->code != 0 || pev->object != nullptr )
        deb(IDA_DEBUG_DEBUGGER, "SYMSRV: event severity: %d code: %d object: %p\n", pev->severity, pev->code, pev->object);
	  CString strText;
	  if (IS_INTRESOURCE(pev->desc))
	  {
		  strText.LoadString((UINT)pev->desc);
	  }
	  else
	  {
		  strText = pev->desc;
	  }
	  if (strText.Find('\b') == -1 && strText.Find("percent") == -1 && strText.Find("copied") == -1)
	  {
		  symsrv_dprint(strText);
		  ATLTRACE(strText);
	  }
	  else
	  {
		  int nPercent = GetDownloadPercentFromSymbolServerMessage(strText);
		  replace_wait_box("Downloading pdb (%d%%)", nPercent);
	  }
      break;
  }
  return TRUE;
}

void try_download_pdb_from_sym_server_by_idm_when_not_exist(clsid_t& guid, uint32 age, const char* pdb_path, qstring& spath)
{
	CRegKey key;
	if (!key.Open(HKEY_CURRENT_USER, "Software\\DownloadManager", KEY_READ))
	{
		TCHAR szExePath[MAX_PATH];
		ULONG nChars = _countof(szExePath);
		if (!key.QueryStringValue("ExePath", szExePath, &nChars))
		{
			if (qfileexist(szExePath))
			{
				typedef BOOL(WINAPI* HTTPOPENFILEHANDLE)(LPCSTR, LPCSTR, DWORD, HANDLE*, HANDLE*);
				typedef BOOL(WINAPI* HTTPQUERYDATAAVAILABLE)(HANDLE, LPDWORD, DWORD, DWORD_PTR);
				typedef BOOL(WINAPI* HTTPREADFILE)(HANDLE, LPVOID, DWORD, LPDWORD);
				typedef BOOL(WINAPI* HTTPCLOSEHANDLE)(HANDLE);
				HMODULE symsrv_hmod = GetModuleHandle("symsrv.dll");
				HTTPOPENFILEHANDLE httpOpenFileHandle = (HTTPOPENFILEHANDLE)GetProcAddress(symsrv_hmod, "httpOpenFileHandle");
				HTTPQUERYDATAAVAILABLE httpQueryDataAvailable = (HTTPQUERYDATAAVAILABLE)GetProcAddress(symsrv_hmod, "httpQueryDataAvailable");
				HTTPREADFILE httpReadFile = (HTTPREADFILE)GetProcAddress(symsrv_hmod, "httpReadFile");
				HTTPCLOSEHANDLE httpCloseHandle = (HTTPCLOSEHANDLE)GetProcAddress(symsrv_hmod, "httpCloseHandle");
				BOOL bHttpIsValid = httpOpenFileHandle && httpQueryDataAvailable && httpReadFile && httpCloseHandle;
				ASSERT(bHttpIsValid);
				if (bHttpIsValid)
				{
					PSYMBOLSERVERSETOPTIONSPROC set_options = (PSYMBOLSERVERSETOPTIONSPROC)(void*)GetProcAddress(symsrv_hmod, "SymbolServerSetOptions");
					PSYMBOLSERVERGETINDEXSTRING get_index_string = (PSYMBOLSERVERGETINDEXSTRING)GetProcAddress(symsrv_hmod, "SymbolServerGetIndexString");
					ASSERT(set_options && get_index_string);
					if (set_options && get_index_string)
					{
						CHAR szIndexString[sizeof(GUID) * 2 + 1 + 1 + 1];
						set_options(SSRVOPT_PARAMTYPE, SSRVOPT_GUIDPTR);
						BOOL bResult = get_index_string(&guid, age, 0, szIndexString, _countof(szIndexString));
						ASSERT(bResult);
						if (bResult)
						{
							const char* pdb_name = qbasename(pdb_path);
							qstring path;
							path.sprnt("%s/%s/%s", pdb_name, szIndexString, pdb_name);

							bool bFindCache = false;
							qvector<qstring> cache_paths;
							qvector<qstring> srvs;

							LPSTR next_token = nullptr;
							LPSTR token = qstrtok(spath.begin(), ";", &next_token);
							while (token != nullptr)
							{
								qstring item(token);
								LPSTR next_token_item = nullptr;
								LPTSTR spath_prefix = qstrtok(item.begin(), "*", &next_token_item);
								ASSERT(spath_prefix);
								if (!strnicmp(spath_prefix, "srv", _countof("srv") - 1))
								{
									LPTSTR cache_path = qstrtok(nullptr, "*", &next_token_item);
									ASSERT(cache_path);
									if (cache_path)
									{
										qstring cache_file;
										cache_file.sprnt("%s\\%s", cache_path, path.c_str());
										if (qfileexist(cache_file.c_str()))
										{
											bFindCache = true;
											break;
										}
										cache_paths.push_back(cache_path);
										LPTSTR srv = qstrtok(nullptr, "*", &next_token_item);
										if (srv)
										{
											srvs.push_back(srv);
										}
									}
								}

								// Get next token: 
								token = qstrtok(nullptr, ";", &next_token);
							}

							if (!bFindCache)
							{
								for (size_t i = 0; i < cache_paths.size(); i++)
								{
									qstring srv = srvs[i];
									size_t pos = srv.find("//");
									if (pos != qstring::npos)
									{
										pos = srv.find('/', pos + 2);
									}
									else
									{
										pos = srv.find('/');
									}
									qstring srv_path;
									if (pos != qstring::npos)
									{
										srv_path = &srv[pos + 1];
										if (srv_path.last() != '/')
										{
											srv_path.append('/');
										}
										srv.resize(pos);
									}
									HANDLE hsite, hfile;
									BOOL bResult = httpOpenFileHandle(srv.c_str(), (srv_path + path).c_str(), 0, &hsite, &hfile);
									if (!bResult)
									{
										//尝试查找压缩格式的PDB文件(Mozilla服务器只提供了压缩格式，目前版本的IDA的PDB插件并不支持)
										qstring path_Compressed;//CompressedFileName
										path_Compressed = path.substr(0, path.length() - 1);
										path_Compressed.append('_');
										BOOL bResult_Compressed = httpOpenFileHandle(srv.c_str(), (srv_path + path_Compressed).c_str(), 0, &hsite, &hfile);
										if (bResult_Compressed)
										{
											//由于需要处理CAB,LZExpand,ZIP的解压，所以目前我们暂时不处理，UncompressFile
											//此时回落到使用symsrv.dll进行下载
											msg("PDB: The external downloader currently does not support downloading compressed PDB files.\n");
											break;
										}
									}
									BOOL bDownloadPdbCompleted = FALSE;
									if (bResult)
									{
										DWORD dwNumberOfBytesAvailable;
										if (httpQueryDataAvailable(hfile, &dwNumberOfBytesAvailable, 0, 0))
										{
											char szBuffer[64];
											DWORD dwNumberOfBytesToRead = __min(_countof(szBuffer), dwNumberOfBytesAvailable);
											DWORD dwNumberOfBytesRead;
											if (httpReadFile(hfile, szBuffer, dwNumberOfBytesToRead, &dwNumberOfBytesRead))
											{
												if (dwNumberOfBytesRead == dwNumberOfBytesToRead)
												{
													//下载下来的不一定是一个PDB文件，老版本symsrv.dll甚至会把HTTP 404 Not Found的数据都读取出来
													if (!strncmp(szBuffer, "Microsoft C/C++ ", _countof("Microsoft C/C++ ") - 1))
													{
														ATLTRACE("FIND PDB IN SERVER: %s\n", srv);
														qstring url(srv);
														if (url.last() != '/')
														{
															url.append('/');
														}
														url.append(srv_path + path);

														char szRelPath[MAX_PATH];
														szRelPath[0] = 0;
														qdirname(szRelPath, _countof(szRelPath), path.c_str());
														size_t nRelPathLen = qstrlen(szRelPath);
														for (size_t j = 0; j < nRelPathLen; j++)
														{
															if (szRelPath[j] == '/')
															{
																szRelPath[j] = '\\';
															}
														}
														qstring local_path(cache_paths[i]);
														if (local_path[local_path.length() - 1] != '\\')
														{
															local_path.append('\\');
														}
														local_path.append(szRelPath);

														qstring local_full_path(local_path);
														local_full_path.append('\\');
														local_full_path.append(pdb_name);
														if (qfileexist(local_full_path.c_str()))
														{
															qunlink(local_full_path.c_str());
														}

														show_wait_box("Waiting for external download to complete...\n%s", url.c_str());

														qstring strArgs;
														strArgs.sprnt("/d \"%s\" /p \"%s\" /f \"%s\" /q /n", url.c_str(), local_path.c_str(), pdb_name);
														launch_process_params_t lpp;
														lpp.flags = 0;
														lpp.path = szExePath;
														lpp.args = strArgs.c_str();
														qstring errbuf;
														void* handle = launch_process(lpp, &errbuf);
														if (handle)
														{
															while (!qfileexist(local_full_path.c_str()))
															{
																if (handle)
																{
																	int exit_code = 0;
																	if (check_process_exit(handle, &exit_code, 50) == 0)
																	{
																		handle = nullptr;
																	}
																}
																else
																{
																	Sleep(50);
																}
																if (user_cancelled())
																{
																	break;
																}
															}

															if (qfileexist(local_full_path.c_str()))
															{
																//等待第三方下载工具写入完成，也即我们能获取到独占写入权限的时候
																do
																{
																	FILE* file = qfopen(local_full_path.c_str(), "a+b");
																	if (file)
																	{
																		qfclose(file);
																		file = nullptr;

																		bDownloadPdbCompleted = TRUE;

																		break;
																	}
																	Sleep(50);
																} while (TRUE);
															}
														}
														hide_wait_box();
													}
												}
											}
										}
										httpCloseHandle(hfile);
										hfile = nullptr;
										httpCloseHandle(hsite);
										hsite = nullptr;
									}
									if (bDownloadPdbCompleted)
									{
										break;
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

//----------------------------------------------------------------------------
class symsrv_cb_t
{
  HMODULE symsrv_hmod;
  bool wait_box_shown;
  PSYMBOLSERVERGETOPTIONDATAPROC get_option_data; // "DbgHelp.dll 10.0 or later"
  PSYMBOLSERVERSETOPTIONSPROC set_options;
  ULONG64 was_context;
  ULONG64 was_callback;

public:
  symsrv_cb_t(void)
  {
    symsrv_hmod = LoadLibrary("symsrv.dll");
	if (!symsrv_hmod)
	{
		warning("The \"symsrv.dll\" file cannot be found, so it may not be possible to download symbols online!");
	}
	else
	{
		TCHAR szVersionFile[MAX_PATH];
		GetModuleFileName(symsrv_hmod, szVersionFile, _countof(szVersionFile));
		ASSERT(szVersionFile[0]);

		//https://stackoverflow.com/questions/940707/how-do-i-programmatically-get-the-version-of-a-dll-or-exe-file
		DWORD  verHandle = 0;
		UINT   size = 0;
		LPBYTE lpBuffer = nullptr;
		DWORD  verSize = GetFileVersionInfoSize(szVersionFile, &verHandle);

		if (verSize != 0)
		{
			BYTE* verData = new BYTE[verSize];

			if (GetFileVersionInfo(szVersionFile, verHandle, verSize, verData))
			{
				if (VerQueryValue(verData, _T("\\"), (LPVOID*)&lpBuffer, &size))
				{
					if (size)
					{
						VS_FIXEDFILEINFO* verInfo = (VS_FIXEDFILEINFO*)lpBuffer;
						if (verInfo->dwSignature == 0xfeef04bd)
						{

							// Doesn't matter if you are on 32 bit or 64 bit,
							// DWORD is always 32 bits, so first two revision numbers
							// come from dwFileVersionMS, last two come from dwFileVersionLS
							ULONGLONG ullCurVersion = make_uint64(verInfo->dwFileVersionLS, verInfo->dwFileVersionMS);
							ULONGLONG ullMinVersion = make_uint64(MAKELONG(1001, 19596), MAKELONG(0, 10));
							if (ullCurVersion < ullMinVersion)
							{
								warning("The version of the symsrv.dll file is lower than 10.0.19596.1001, so it cannot support immediate cancellation of the download operation!");
							}
						}
					}
				}
			}
			delete[] verData;
			verData = nullptr;
		}
	}
    wait_box_shown = false;
    get_option_data = nullptr;
    set_options = nullptr;
    was_context = 0;
    was_callback = 0;
  }

  void init(void)
  {
    if ( symsrv_hmod != nullptr )
    {
      get_option_data = (PSYMBOLSERVERGETOPTIONDATAPROC)(void *)GetProcAddress(symsrv_hmod, "SymbolServerGetOptionData");
      if ( get_option_data != nullptr )
      {
        get_option_data(SSRVOPT_SETCONTEXT, &was_context);
        get_option_data(SSRVOPT_CALLBACK, &was_callback);
      }

      set_options = (PSYMBOLSERVERSETOPTIONSPROC)(void *)GetProcAddress(symsrv_hmod, "SymbolServerSetOptions");
      if ( set_options != nullptr )
      {
        set_options(SSRVOPT_SETCONTEXT, (ULONG64) (intptr_t) &wait_box_shown);
        set_options(SSRVOPT_CALLBACK, (ULONG64) SymbolServerCallback);
        if ( (debug & IDA_DEBUG_DEBUGGER) != 0 )
        {
          set_options(SSRVOPT_TRACE, (ULONG64) TRUE);
        }
      }
    }
  }

  void term(void)
  {
    if ( symsrv_hmod != nullptr )
    {
      if ( set_options != nullptr )
      {
        set_options(SSRVOPT_SETCONTEXT, was_context);
        set_options(SSRVOPT_CALLBACK, was_callback);
      }
      FreeLibrary(symsrv_hmod);
      symsrv_hmod = nullptr;
      if ( wait_box_shown )
        hide_wait_box();
    }
  }
};

//----------------------------------------------------------------------------
static qstring print_guid(GUID *guid)
{
  qstring guid_str;
  if ( guid != nullptr )
  {
    OLECHAR *guid_wstr = nullptr;
    StringFromCLSID(*guid, &guid_wstr);
    if ( guid_wstr != nullptr )
    {
      utf16_utf8(&guid_str, guid_wstr);
      CoTaskMemFree(guid_wstr);
    }
  }
  if ( guid_str.empty() )
    guid_str = "{00000000-0000-0000-0000-000000000000}";
  return guid_str;
}

//----------------------------------------------------------------------------
HRESULT pdb_session_t::check_and_load_pdb(
        LPCOLESTR pdb_path,
        const pdb_signature_t &pdb_sign,
        bool load_anyway,
		pdbargs_t &pdbargs)
{
  HRESULT hr = E_FAIL;
  if ( !load_anyway )
  {
    uint32 sig = pdb_sign.sig;
    uint32 age = pdb_sign.age;
    GUID *pcsig70 = nullptr;
    for ( int i=0; i < qnumber(pdb_sign.guid); i++ )
    {
      if ( pdb_sign.guid[i] != 0 )
      {
        pcsig70 = (GUID *)&pdb_sign.guid;
        break;
      }
    }
    if ( sig == 0 && age == 0 && pcsig70 == nullptr )
      return E_FAIL;
    qstring guid_str = print_guid(pcsig70);
    deb(IDA_DEBUG_DEBUGGER, "PDB: Trying to load PDB \"%S\" (guid %s, sig 0x%08X, age 0x%08X)\n", pdb_path, guid_str.c_str(), sig, age);
    hr = pSource->loadAndValidateDataFromPdb(pdb_path, pcsig70, sig, age);
    deb(IDA_DEBUG_DEBUGGER, "PDB: loadAndValidateDataFromPdb(\"%S\"): %s\n", pdb_path, pdberr(hr));
    if ( hr == E_PDB_INVALID_SIG || hr == E_PDB_INVALID_AGE )
    {
      load_anyway = ask_yn(ASKBTN_NO,
                           "HIDECANCEL\nICON WARNING\nAUTOHIDE NONE\n"
                           "PDB signature and/or age does not match the input file.\n"
                           "Do you want to load it anyway?") == ASKBTN_YES;
    }
  }
  if ( load_anyway )
  {
    hr = pSource->loadDataFromPdb(pdb_path);
    deb(IDA_DEBUG_DEBUGGER, "PDB: loadDataFromPdb(\"%S\"): %s\n", pdb_path, pdberr(hr));
  }

  pdbargs.flags &= ~PDBFLG_IS_MINIPDB;
  if (hr == S_OK)
  {
	  IDiaSession* pDiaSession = nullptr;
	  HRESULT hr = pSource->openSession(&pDiaSession);

	  ASSERT(hr == S_OK);
	  if (hr == S_OK)
	  {
		  IDiaSession10* pIDiaSession10 = nullptr;
		  hr = pDiaSession->QueryInterface(IID_IDiaSession10, (void **)&pIDiaSession10);
		  pDiaSession->Release();
		  pDiaSession = nullptr;

		  //ASSERT(hr == S_OK);
		  if (hr == S_OK)
		  {
			  BOOL fMinimalDbgInfo = FALSE;
			  hr = pIDiaSession10->isMiniPDB(&fMinimalDbgInfo);
			  pIDiaSession10->Release();
			  pIDiaSession10 = nullptr;

			  ASSERT(hr == S_OK);
			  if (hr == S_OK)
			  {
				  if (fMinimalDbgInfo)
				  {
					  pdbargs.flags |= PDBFLG_IS_MINIPDB;
					  bool convert = ask_yn(ASKBTN_NO,
						  "HIDECANCEL\nICON WARNING\nAUTOHIDE NONE\n"
						  "PDB is a partial pdb file(build with /DEBUG:FASTLINK).\n"
						  "Do you want to convert it to a full pdb file(build with /DEBUG:FULL)?") == ASKBTN_YES;
					  if (convert)
					  {
						  qstring strPdbPath(utf16_utf8(pdb_path));
						  qstring strFileExtName(get_file_ext(strPdbPath.c_str()));
						  qstring strPdbPath_Full;
						  if (strFileExtName.length())
						  {
							  strFileExtName.insert(0, '.');
							  strPdbPath_Full = strPdbPath.substr(0, strPdbPath.length() - strFileExtName.length()) + "_Full" + strFileExtName;
						  }
						  else
						  {
							  strPdbPath_Full = strPdbPath + "_Full";
						  }
						  if (qfileexist(strPdbPath_Full.c_str()))
						  {
							  qunlink(strPdbPath_Full.c_str());
						  }

						  qstring strExeFile;

                          bstr_t bstrVsInstallationPath;
						  ULONGLONG ullVersion;
						  hr = GetMaxVersionVsInstallationPath(bstrVsInstallationPath, ullVersion);
						  ASSERT(hr == S_OK);
						  BOOL bUseVs2015MsPdbCmf = FALSE;
						  if (hr == S_OK)
						  {
							  qstring strVsInstallationPath(utf16_utf8(bstrVsInstallationPath));

							  ULARGE_INTEGER uli;
							  uli.QuadPart = ullVersion;
							  WORD wVsMainVersion = HIWORD(uli.HighPart);
							  ASSERT(wVsMainVersion > 14);
							  if (wVsMainVersion > 14)
							  {
								  strExeFile.append(strVsInstallationPath.c_str());
								  qstring qstrPath_Microsoft_VCToolsVersion_default_txt = strExeFile + "\\VC\\Auxiliary\\Build\\Microsoft.VCToolsVersion.default.txt";
								  uint64 nFileSize = qfilesize_utf8(qstrPath_Microsoft_VCToolsVersion_default_txt.c_str());
								  qstring strVersion = GetFileContext(qstrPath_Microsoft_VCToolsVersion_default_txt.c_str(), nFileSize);
								  strVersion.rtrim('\n');
								  strVersion.rtrim('\r');
								  strExeFile.cat_sprnt("\\VC\\Tools\\MSVC\\%s\\bin\\Hostx86\\x86\\mspdbcmf.exe", strVersion.c_str());
							  }
						  }
						  else
						  {
							  qstring strVs140ComnTools;
							  qgetenv("VS140COMNTOOLS", &strVs140ComnTools);
							  if (!strVs140ComnTools.empty())
							  {
								  strExeFile = strVs140ComnTools + "..\\..\\VC\\bin\\mspdbcmf.exe";
								  bUseVs2015MsPdbCmf = TRUE;
							  }
						  }

						  if (!qfileexist(strExeFile.c_str()))
						  {
							  warning("\"mspdbcmf.exe\" is not existed!");
						  }
						  else
						  {
							  BOOL bConverted = FALSE;
							  uchar md5Pdb_Old_for_Vs2015[16];
							  qstring strArgs;
							  if (bUseVs2015MsPdbCmf)
							  {
								  int result = qcopyfile(strPdbPath.c_str(), strPdbPath_Full.c_str());
								  ASSERT(!result);
								  if (!result)
								  {
									  uint64 nFileSize = qfilesize_utf8(strPdbPath_Full.c_str());
									  qstring strFileContext = GetFileContext(strPdbPath_Full.c_str(), nFileSize);
									  MD5_FromData((uchar*)strFileContext.c_str(), nFileSize, md5Pdb_Old_for_Vs2015);
									  strArgs.sprnt("/STATUS \"%s\"", strPdbPath_Full.c_str());
								  }
							  }
							  else
							  {
								  strArgs.sprnt("/STATUS /OUT:\"%s\" \"%s\"", strPdbPath_Full.c_str(), strPdbPath.c_str());
							  }
							  if (!strArgs.empty())
							  {
								  launch_process_params_t lpp;
								  lpp.flags = 0;
								  lpp.path= strExeFile.c_str();
								  lpp.args = strArgs.c_str();
								  qstring errbuf;
								  void * handle = launch_process(lpp, &errbuf);
								  if (handle)
								  {
									  int exit_code = 0;
									  check_process_exit(handle, &exit_code);
									  handle = nullptr;

									  if (bUseVs2015MsPdbCmf)
									  {
										  uint64 nFileSize = qfilesize_utf8(strPdbPath_Full.c_str());
										  qstring strFileBuffer = GetFileContext(strPdbPath_Full.c_str(), nFileSize);
										  uchar md5Pdb_New_for_Vs2015[16];
										  MD5_FromData((uchar*)strFileBuffer.c_str(), nFileSize, md5Pdb_New_for_Vs2015);
										  if (memcmp(md5Pdb_New_for_Vs2015, md5Pdb_Old_for_Vs2015, sizeof(md5Pdb_New_for_Vs2015)))
										  {
											  bConverted = TRUE;
										  }
										  else
										  {
											  qunlink(strPdbPath_Full.c_str());
										  }
									  }
									  else
									  {
										  bConverted = qfileexist(strPdbPath_Full.c_str());
									  }
								  }
							  }

							  if (bConverted)
							  {
								  pSource->Release();
								  pSource = nullptr;

								  int dia_version;
								  hr = create_dia_source(&dia_version);
								  if (hr == S_OK)
								  {
									  int result = qmove(strPdbPath_Full.c_str(), strPdbPath.c_str(), QMOVE_OVERWRITE);
									  if (!result)
									  {
										  hr = check_and_load_pdb(pdb_path, pdb_sign, load_anyway, pdbargs);
									  }
									  else
									  {
										  DWORD dwErrorCode = GetLastError();
										  char* pszError(winerr(dwErrorCode));

										  warning("Failed to move file, %s\n(from \"%s\" to \"%s\")", pszError, strPdbPath_Full.c_str(), strPdbPath.c_str());
										  qwstring pdb_path_full(utf8_utf16(strPdbPath_Full.c_str()));
										  hr = check_and_load_pdb(pdb_path_full.c_str(), pdb_sign, load_anyway, pdbargs);
									  }
								  }
							  }
							  else
							  {
								  warning("Try to convert to full pdb has failed!");
							  }
						  }
					  }
				  }
			  }
		  }
	  }
  }
  return hr;
}

//----------------------------------------------------------------------------
// warn the user about eventual UNC or other problematic paths
static bool check_for_odd_paths(const char *fname)
{
  if ( PathIsUNC == nullptr )
  {
#ifndef _INC_SHLWAPI
    HMODULE h = GetModuleHandle("shlwapi.dll");
    if ( h != nullptr )
      PathIsUNC = (PathIsUNC_t)(void*)GetProcAddress(h, "PathIsUNCA");
#else
	ASSERT(FALSE);
#endif
  }
  if ( fname[0] == '\\'
    || fname[0] == '/'
    || PathIsUNC != nullptr && PathIsUNC(fname) )
  {
    if ( ask_yn(ASKBTN_NO,
                "AUTOHIDE NONE\nHIDECANCEL\n"
                "Please be careful, the debug path looks odd!\n"
                "\"%s\"\n"
                "Do you really want IDA to access this path (possibly a remote server)?",
                fname) != ASKBTN_YES )
    {
      return false;
    }
  }
  return true;
}

//---------------------------------------------------------------------------
HRESULT pdb_session_t::load_data_for_exe(
        const pdbargs_t &pdbargs,
        load_data_type_t type)
{
  // First check for load address.
  ea_t load_address = BADADDR;
  if ( type == MEM_LOCAL || type == MEM_WIN32 )
  {
    load_address = pdbargs.loaded_base;
    if ( load_address == BADADDR )
      return E_FAIL;
  }

  msdia_reader_t *msdia_reader = nullptr;
  HRESULT hr = E_FAIL;
  switch ( type )
  {
    case EXE_LOCAL:
      msdia_reader = new local_exe_msdia_reader_t(winput.c_str());
      break;
#ifdef PDB_PLUGIN
    case MEM_LOCAL:
      msdia_reader = new local_mem_msdia_reader_t;
      break;
#elif defined(PDB_WIN32_SERVER)
    case EXE_WIN32:
      msdia_reader = new win32_msdia_reader_t(pdbargs.user_data, READ_INPUT_FILE);
      break;
    case MEM_WIN32:
      msdia_reader = new win32_msdia_reader_t(pdbargs.user_data, READ_MEMORY);
      break;
#endif
    default:
      break;
  }
  if ( msdia_reader->setup() )
  {
    qstring buf;
    if ( load_address != BADADDR )
      buf.sprnt(" with load address %a", load_address);
    deb(IDA_DEBUG_DEBUGGER, "PDB: Trying loadDataForExe(\"%S\", \"%S\")%s\n", winput.c_str(), wspath.c_str(), buf.c_str());

    CCallback callback(this, msdia_reader, load_address);
	//目前新版本中需要symsrv.dll才行
	//https://github.com/MicrosoftDocs/visualstudio-docs/issues/5781
    hr = pSource->loadDataForExe(winput.c_str(), wspath.c_str(), (IDiaLoadCallback *)&callback);

    deb(IDA_DEBUG_DEBUGGER, "PDB: %s\n", pdberr(hr));
  }
  delete msdia_reader;

  return hr;
}

//----------------------------------------------------------------------------
HRESULT pdb_session_t::load_input_path(
        const pdbargs_t &pdbargs,
        const char *input_path)
{
  utf8_utf16(&wspath, pdbargs.spath.c_str());
  utf8_utf16(&winput, input_path);

  qvector<load_data_type_t> methods;
#ifdef PDB_PLUGIN
  // Is the debugger active?
  if ( get_process_state() != DSTATE_NOTASK )
  {
    // First try using program data from debugger memory.
    methods.push_back(MEM_LOCAL);
    // Then try reading the executable (unless we're remote debugging).
    if ( !dbg->is_remote() )
      methods.push_back(EXE_LOCAL);
  }
  else // debugger not active
  {
    // First try reading the executable.
    methods.push_back(EXE_LOCAL);
    // Then try using program data from the IDB.
    methods.push_back(MEM_LOCAL);
  }
#elif defined(PDB_WIN32_SERVER)
  // First try reading the executable.
  if ( pdbargs.is_dbg_module() )
  {
    // If the module has been loaded by the debugger itself, we can
    // read the file locally on the server side.
    // TODO isn't this a security issue? the user can specify
    //      any input_path to be read on the server.
    methods.push_back(EXE_LOCAL);
  }
  else
  {
    // Otherwise we want to read the input file from the remote stub.
    methods.push_back(EXE_WIN32);
  }
  // Then try reading memory locally on the server side (the process
  // being debugged).
  methods.push_back(MEM_WIN32);
#else
  // For efd and tilib, only try loading the executable locally.
  methods.push_back(EXE_LOCAL);
#endif

  HRESULT hr = E_FAIL;
  for ( size_t i = 0; i < methods.size(); i++ )
  {
    hr = load_data_for_exe(pdbargs, methods[i]);
    if ( hr == S_OK )
      break;
    if ( hr == E_PDB_NOT_FOUND )
      break; // another address won't help
  }

  return hr;
}

//----------------------------------------------------------------------------
HRESULT pdb_session_t::open_session(pdbargs_t &pdbargs)
{
  // Already open?
  if ( pdb_access != nullptr )
    return S_OK;

  // Not initialized yet?
  if ( !co_initialized )
  {
    // Initialize COM
    CoInitialize(nullptr);
    co_initialized = true;
  }

  int dia_version;
  HRESULT hr;
  IDiaSession    *pSession = nullptr;
  IDiaSymbol     *pGlobal  = nullptr;
  bool pdb_loaded = false;

  // No interface was created?
  hr = create_dia_source(&dia_version);
  if ( FAILED(hr) )
    goto fail;

  // First try to open PDB file if it was specified.
  if ( !pdbargs.pdb_path.empty()
    && check_for_odd_paths(pdbargs.pdb_path.c_str())
    && qfileexist(pdbargs.pdb_path.c_str()) )
  {
    qwstring wpdb_path;
    utf8_utf16(&wpdb_path, pdbargs.pdb_path.c_str());
    bool force_load = (pdbargs.flags & (PDBFLG_LOAD_TYPES|PDBFLG_EFD)) != 0
                   && (pdbargs.flags & PDBFLG_LOAD_NAMES) == 0;
    hr = check_and_load_pdb(wpdb_path.c_str(), pdbargs.pdb_sign, force_load, pdbargs);
    if ( hr == E_PDB_INVALID_SIG || hr == E_PDB_INVALID_AGE ) // Mismatching PDB
      goto fail;
    pdb_loaded = (hr == S_OK);
    used_fname = pdbargs.pdb_path; // TODO is this needed?
  }

  // Failed? Try to load input_path as EXE if it was specified.
  if ( !pdb_loaded && !pdbargs.input_path.empty() )
  {
    qstring path = pdbargs.input_path;
    if ( !qfileexist(path.c_str()) )
    {
      // If the input path came from a remote system, it is unlikely to be
      // correct on our system. DIA does not care about the exact file name
      // but uses the directory path to locate the PDB file. It combines
      // the name of the pdb file from the debug directory and the directory
      // from the input path.
      // Since we cannot rely on remote paths, we simply use the current dir
      char buf[QMAXPATH];
      qgetcwd(buf, sizeof(buf));
      path.sprnt("%s\\%s", buf, qbasename(pdbargs.input_path.c_str()));
      msg("PDB: \"%s\": not found, trying \"%s\"\n", path.c_str(), buf);
    }
    if ( !check_for_odd_paths(path.c_str()) )
      return E_PDB_NOT_FOUND;

    used_fname = path;

    // Setup symsrv callback to show wait box for pdb downloading
    symsrv_cb_t symsrv_cb;
    symsrv_cb.init();

    // Try searching for PDB information from the debug directory in a
    // PE file. Either the input file is read directly or the contents
    // of a loaded module are read from memory.
    hr = load_input_path(pdbargs, path.c_str());
    pdb_loaded = (hr == S_OK);

    // Hide wait box for pdb downloading if needed
    symsrv_cb.term();
  }

  // Failed? Then nothing else to try, quit
  if ( !pdb_loaded )
  {
    // make sure we do return an error
    if ( hr == S_OK )
      hr = E_FAIL;
    goto fail;
  }

  // Open a session for querying symbols
  hr = pSource->openSession(&pSession);
  deb(IDA_DEBUG_DEBUGGER, "PDB: openSession(): %s\n", pdberr(hr));
  if ( FAILED(hr) )
    goto fail;

  // Set load address
  // TODO check if load_address should be set when loading PDB works directly.
  if ( pdbargs.loaded_base != BADADDR )
  {
    msg("PDB: using load address %a\n", pdbargs.loaded_base);
    pSession->put_loadAddress(pdbargs.loaded_base);
  }

  // Retrieve a reference to the global scope
  hr = pSession->get_globalScope(&pGlobal);
  if ( hr != S_OK )
    goto fail;

  pdb_access = new local_pdb_access_t(pdbargs, pSource, pSession, pGlobal);

  DWORD pdb_machType, machType;
  if ( pGlobal->get_machineType(&pdb_machType) != S_OK )
    pdb_machType = IMAGE_FILE_MACHINE_I386;
  machType = get_machine_type(pdb_machType);

  pdb_access->set_machine_type(machType);
  pdb_access->set_dia_version(dia_version);

  hr = pdb_access->init();
  if ( hr == S_OK )
    return hr;

  // TODO clear pdb_access since above test failed

fail:
  // In the event of an error, this will be reached.
  if ( pdb_access == nullptr )
  {
    if ( pGlobal != nullptr )
      pGlobal->Release();
    if ( pSession != nullptr )
      pSession->Release();
    if ( pSource != nullptr )
      pSource->Release();
  }
  return hr;
}

static qstring get_msdia140_dll_path()
{
	bstr_t bstrVsInstallationPath;
	ULONGLONG ullVersion;
	HRESULT hr = GetMaxVersionVsInstallationPath(bstrVsInstallationPath, ullVersion);
	if (hr == S_OK)
	{
        //Remote Debugger目录下的msdia140.dll的版本比DIA SDK目录下的高一个修订版本号且带有symsrv.dll，
        //所以我们使用这个目录下的版本，
        //虽然目前这个目录下的symsrv.dll版本会太低了，无法支持立刻取消下载，但是未来这个symsrv.dll的版本肯定会被升级的，
        //到时候我们就不需要自己提供更高版本的symsrv.dll文件了
		bstrVsInstallationPath += L"\\Common7\\IDE\\Remote Debugger\\x64\\msdia140.dll";
        return utf16_acp(bstrVsInstallationPath);
	}
    else
    {
        return "";
    }
}

//----------------------------------------------------------------------
HRESULT pdb_session_t::create_dia_source(int *dia_version)
{
  HRESULT hr;
  // VC80/90 CRT installs msdiaNN.dll in this folder:
  // "C:\Program Files (x86)\Common Files\microsoft shared\VC"
  char common_files[QMAXPATH];
  qstring vc_shared;
#ifndef __IS_MSDIA100_OR_GREATER__
  if ( get_special_folder(common_files, sizeof(common_files), CSIDL_PROGRAM_FILES_COMMON) )
  {
    vc_shared = common_files;
    vc_shared.append("\\Microsoft Shared\\VC");
  }
#endif

  for ( size_t i=0; i < qnumber(g_msdiav); i++ )
  {
    // Try to create using CoCreateInstance()
    hr = CoCreateInstance(*g_msdiav[i],
                          nullptr,
                          CLSCTX_INPROC_SERVER,
                          __uuidof(IDiaDataSource),
                          (void**)&pSource);

    // Try to create with CoCreateInstanceNoReg()
    if ( FAILED(hr) )
    {
      // Search for this interface in DIA dlls
      char path[QMAXPATH];
	  path[0] = 0;
	  if (g_diaver[i] == 1400)
	  {
		  qstring msdia140_dll_path = get_msdia140_dll_path();
		  if (!msdia140_dll_path.empty())
		  {
			  char dir_path[QMAXPATH];
			  qdirname(dir_path, qnumber(dir_path), msdia140_dll_path.c_str());
			  SetDllDirectory(dir_path);

			  qstrncpy(path, msdia140_dll_path.c_str(), qnumber(path));
		  }
	  }
	  if (!path[0])
	  {
		  if (SearchPathA(nullptr, g_diadlls[i], nullptr, qnumber(path), path, nullptr) == 0
              && !search_path(path, sizeof(path), g_diadlls[i], false)
			  && (vc_shared.empty()
				  || SearchPathA(vc_shared.c_str(), g_diadlls[i], nullptr,
					  qnumber(path), path, nullptr) == 0))
		  {
			  continue;
		  }
	  }

      for ( size_t j=0; j < qnumber(g_msdiav); j++ )
      {
        hr = CoCreateInstanceNoReg(path,
                                   *g_msdiav[j],
                                   nullptr,
                                   __uuidof(IDiaDataSource),
                                   (void**)&pSource,
                                   &dia_hmod);

        if ( hr == S_OK )
        {
          static bool displayed = false;
          if ( !displayed )
          {
            displayed = true;
            msg("PDB: using DIA dll \"%s\"\n", path);
          }
          i = j;
          break;
        }
      }
    }

    if ( hr == S_OK )
    {
      *dia_version = g_diaver[i];
      static bool displayed = false;
      if ( !displayed )
      {
        displayed = true;
        msg("PDB: DIA interface version %d.%d\n", (*dia_version)/100, (*dia_version)%100);
      }
      return hr;
    }
    else
    {
      *dia_version = 0;
    }
  }
  return E_NOINTERFACE;
}

//----------------------------------------------------------------------
pdb_session_ref_t::pdb_session_ref_t(const pdb_session_ref_t &r)
  : session(r.session)
{
  if ( session != nullptr )
    session->refcount++;
}

//----------------------------------------------------------------------
pdb_session_ref_t &pdb_session_ref_t::operator=(const pdb_session_ref_t &r)
{
  if ( &r != this )
  {
    this->~pdb_session_ref_t();
    new (this) pdb_session_ref_t(r);
  }
  return *this;
}

//----------------------------------------------------------------------------
pdb_session_ref_t::~pdb_session_ref_t()
{
  close();
  if ( session != nullptr )
  {
    delete session;
    session = nullptr;
  }
}

//----------------------------------------------------------------------
void pdb_session_ref_t::create_session(void)
{
  QASSERT(30462, session == nullptr);
  session = new pdb_session_t();
}

//----------------------------------------------------------------------
void pdb_session_ref_t::close()
{
  if ( session != nullptr )
  {
    // shared instance? then detach
    if ( session->refcount > 1 )
    { // unlink
      session->refcount--;
      session = nullptr;
    }
    else
    {
      session->close();
    }
  }
}

//----------------------------------------------------------------------
HRESULT pdb_session_ref_t::open_session(pdbargs_t &pdbargs)
{
  if ( opened() )
    return S_OK;

  if ( empty() )
    create_session();

  return session->open_session(pdbargs);
}

```

`msdia.hpp`:

```hpp

#ifndef MSDIA_HPP
#define MSDIA_HPP

#include "pdbaccess.hpp"
#include "pdblocal.hpp"

//----------------------------------------------------------------------------
struct pdb_session_t
{
  HMODULE dia_hmod;
  int refcount;
  local_pdb_access_t *pdb_access;

  pdb_session_t()
    : dia_hmod(nullptr),
      refcount(1),
      pdb_access(nullptr),
      pSource(nullptr)
  {
    session_count++;
  }
  ~pdb_session_t();

  HRESULT check_and_load_pdb(
	  LPCOLESTR pdb_path,
	  const pdb_signature_t &pdb_sign,
	  bool load_anyway,
	  pdbargs_t &pdbargs);
  HRESULT open_session(pdbargs_t &pdbargs);
  void close();
  const char *get_used_fname() const { return used_fname.begin(); }

private:
  DECLARE_UNCOPYABLE(pdb_session_t)
  HRESULT create_dia_source(int *dia_version);

  IDiaDataSource *pSource;
  qwstring winput;
public:
  qwstring wspath;
private:
  enum load_data_type_t
  {
    EXE_LOCAL,
    MEM_LOCAL,  // PDB_PLUGIN
    EXE_WIN32,  // PDB_WIN32_SERVER
    MEM_WIN32,  // PDB_WIN32_SERVER
  };
  HRESULT load_data_for_exe(const pdbargs_t &pdbargs, load_data_type_t type);
  HRESULT load_input_path(const pdbargs_t &pdbargs, const char *input_path);

  // The total number of different PDB sessions; kept track of
  // in order to know when we can safely CoUninitialize().
  static int session_count;

  // Whether COM is initialized in this thread.
  static bool co_initialized;
#ifdef _DEBUG
public:
  qstring _pdb_path;
#endif
  qstring used_fname;
};


//----------------------------------------------------------------------------
class pdb_session_ref_t
{
public:
  pdb_session_t *session;  // refcounted object

  pdb_session_ref_t(void) : session(nullptr) {}
  pdb_session_ref_t(const pdb_session_ref_t &r);
  ~pdb_session_ref_t();

  pdb_session_ref_t &operator=(const pdb_session_ref_t &r);
  void create_session();
  void close();
  bool empty() const { return session == nullptr; }
  bool opened() const { return !empty() && session->pdb_access != nullptr; }
  HRESULT open_session(pdbargs_t &args);
};

//----------------------------------------------------------------------------
const char *pdberr(int code);

#endif

```

`old.cpp`:

```cpp

// Old interface to PDB files
// It is used as a fallback method if DIA interface fails

#include <windows.h>

#pragma pack(push, 8)
#include "cvconst.h"
#include "dbghelp.h"
#pragma pack(pop)

#include <ida.hpp>
#include <idp.hpp>
#include <err.h>
#include "oldpdb.h"

//----------------------------------------------------------------------
typedef DWORD IMAGEAPI SymSetOptions_t(IN DWORD SymOptions);
typedef BOOL IMAGEAPI SymInitialize_t(IN HANDLE hProcess, IN LPCSTR UserSearchPath, IN BOOL fInvadeProcess);
typedef DWORD64 IMAGEAPI SymLoadModule64_t(IN HANDLE hProcess, IN HANDLE hFile, IN PSTR ImageName, IN PSTR ModuleName, IN DWORD64 BaseOfDll, IN DWORD SizeOfDll);
typedef BOOL IMAGEAPI SymEnumSymbols_t(IN HANDLE hProcess, IN ULONG64 BaseOfDll, IN PCSTR Mask, IN PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback, IN PVOID UserContext);
typedef BOOL IMAGEAPI SymUnloadModule64_t(IN HANDLE hProcess, IN DWORD64 BaseOfDll);
typedef BOOL IMAGEAPI SymCleanup_t(IN HANDLE hProcess);

static HINSTANCE dbghelp = nullptr;
static SymSetOptions_t     *pSymSetOptions     = nullptr;
static SymInitialize_t     *pSymInitialize     = nullptr;
static SymLoadModule64_t   *pSymLoadModule64   = nullptr;
static SymEnumSymbols_t    *pSymEnumSymbols    = nullptr;
static SymUnloadModule64_t *pSymUnloadModule64 = nullptr;
static SymCleanup_t        *pSymCleanup        = nullptr;
static int symbols_found = 0;

//----------------------------------------------------------------------
// Dynamically load and link to DBGHELP or IMAGEHLP libraries
// Return: success
static bool setup_pointers(bool *must_free)
{
  char dll[QMAXPATH];

  // check if it's already loaded
  dbghelp = GetModuleHandle("dbghelp.dll");

  *must_free = false;
  if ( dbghelp == nullptr )
  {
    // nope, load it
    // use search_path to avoid dll current directory attacks
    if ( !search_path(dll, sizeof(dll), "dbghelp.dll", false) )
      return false;
    dbghelp = LoadLibrary(dll);
    *must_free = true;
  }

  if ( dbghelp == nullptr )
  {
    deb(IDA_DEBUG_DBGINFO, "PDB plugin: failed to load DBGHELP.DLL");
  }
  else
  {
    *(FARPROC*)&pSymSetOptions     = GetProcAddress(dbghelp, "SymSetOptions");
    *(FARPROC*)&pSymInitialize     = GetProcAddress(dbghelp, "SymInitialize");
    *(FARPROC*)&pSymLoadModule64   = GetProcAddress(dbghelp, "SymLoadModule64");
    *(FARPROC*)&pSymEnumSymbols    = GetProcAddress(dbghelp, "SymEnumSymbols");
    *(FARPROC*)&pSymUnloadModule64 = GetProcAddress(dbghelp, "SymUnloadModule64");
    *(FARPROC*)&pSymCleanup        = GetProcAddress(dbghelp, "SymCleanup");

    if ( pSymSetOptions     != nullptr
      && pSymInitialize     != nullptr
      && pSymLoadModule64   != nullptr
      && pSymUnloadModule64 != nullptr
      && pSymCleanup        != nullptr
      && pSymEnumSymbols    != nullptr ) // required XP or higher
    {
      return true;
    }
  }
  deb(IDA_DEBUG_DBGINFO, "PDB plugin: Essential DBGHELP.DLL functions are missing\n");
  if ( dbghelp != nullptr )
  {
    FreeLibrary(dbghelp);
    dbghelp = nullptr;
  }
  return false;
}

//----------------------------------------------------------------------
// New method: symbol enumeration callback
//lint -e{818} could be declared as pointing to const
static BOOL CALLBACK EnumerateSymbolsProc(
        PSYMBOL_INFO psym,
        ULONG /*SymbolSize*/,
        PVOID delta)
{
  symbols_found++;
  ea_t ea = (ea_t)(psym->Address + *(adiff_t*)delta);
  const char *name = psym->Name;

  int maybe_func = 0; // maybe
  switch ( psym->Tag )
  {
    case SymTagFunction:
    case SymTagThunk:
      maybe_func = 1;
      break;
    case SymTagNull:
    case SymTagExe:
    case SymTagCompiland:
    case SymTagCompilandDetails:
    case SymTagCompilandEnv:
    case SymTagData:
    case SymTagAnnotation:
    case SymTagUDT:
    case SymTagEnum:
    case SymTagFunctionType:
    case SymTagPointerType:
    case SymTagArrayType:
    case SymTagBaseType:
    case SymTagTypedef:
    case SymTagBaseClass:
    case SymTagFunctionArgType:
    case SymTagUsingNamespace:
    case SymTagVTableShape:
    case SymTagVTable:
    case SymTagCustom:
    case SymTagCustomType:
    case SymTagManagedType:
    case SymTagDimension:
      maybe_func = -1;
      break;
    case SymTagBlock:
    case SymTagLabel:
    case SymTagFuncDebugStart:
    case SymTagFuncDebugEnd:
      maybe_func = 2;
      break;
    case SymTagPublicSymbol:
    case SymTagFriend:
    default:
      break;
  }

  bool ok = apply_name(ea, name, maybe_func);
  // New dbghelp.dll/symsrv.dll files return names without the terminating zero.
  // So, as soon as we have a long name, shorter names will have garbage at the end.
  // Clean up the name to avoid problems.
  size_t len = strlen(name);
  memset((void*)name, '\0', len);
  return ok;
}

//----------------------------------------------------------------------
// Display a system error message
static void error_msg(const char *name)
{
  int code = GetLastError();
  if ( code != 0 )
    msg("%s: %s\n", name, winerr(code));
}

//----------------------------------------------------------------------
// Try old method of loading symbols
bool old_pdb_plugin(ea_t loaded_base, const char *input, const char *spath)
{
  bool ok = false;
  bool must_free;
  if ( setup_pointers(&must_free) )
  {
    pSymSetOptions(SYMOPT_LOAD_LINES|SYMOPT_FAVOR_COMPRESSED|SYMOPT_NO_PROMPTS);

    void *fake_proc = (void *)(uintptr_t)0xBEEFFEED;
    if ( !pSymInitialize(fake_proc, spath, FALSE) )
    {
      error_msg("SymInitialize");
    }
    else
    {
      DWORD64 symbase = pSymLoadModule64(fake_proc, 0, (char*)input, nullptr, loaded_base, 0);
      if ( symbase != 0 )
      {
        load_vc_til();

        symbols_found = 0;
        adiff_t delta = adiff_t(loaded_base - symbase);
        ok = pSymEnumSymbols(fake_proc, symbase, nullptr, EnumerateSymbolsProc, &delta)
          && symbols_found > 0;
        if ( !ok )
          error_msg("EnumSymbols");
        if ( !pSymUnloadModule64(fake_proc, symbase) )
          error_msg("SymUnloadModule64");
      }
      if ( !pSymCleanup(fake_proc) )
        error_msg("SymCleanup");
    }
    if ( must_free )
    {
      FreeLibrary(dbghelp);
      dbghelp = nullptr;
    }
  }
  return ok;
}

```

`oldpdb.h`:

```h

// Common definitions for the old and new pdb plugins

// helper functions provided by the new pdb plugin
bool apply_name(ea_t ea, const qstring &name, int maybe_func);
void load_vc_til(void);

// entry point of the old pdb plugin
bool old_pdb_plugin(ea_t loaded_base, const char *input, const char *spath);

```

`pdb.cfg`:

```cfg
// PDB plugin

// PDB information provider
#define PDB_PROVIDER_MSDIA  1   // use MSDIA local/remote provider
#define PDB_PROVIDER_PDBIDA 2   // use PDBIDA provider
//PDB_PROVIDER = PDB_PROVIDER_PDBIDA

// it is possible to specify the desired provider in the command line:
//      ida -Opdb:off input_file
//      ida -Opdb:msdia input_file
//      ida -Opdb:pdbida input_file

// Symbol search path
// The _NT_SYMBOL_PATH environment variable overrides this setting.
// If none of these variables is set then the default value will be used:
// "SRV*CACHEDIR*http://msdl.microsoft.com/download/symbols"
// where
//   CACHEDIR=%TEMP%\ida  for Windows
//   CACHEDIR=$TMPDIR/ida or $TMP/ida or /tmp/ida for non-Windows OSes
//
//_NT_SYMBOL_PATH = "SRV*c:\\symbols*http://symbols.mozilla.org/firefox;SRV*c:\\symbols*http://msdl.microsoft.com/download/symbols";

// Network communications while looking for PDB file can be restricted.
// Valid only for PDBIDA provider.
#define PDB_NETWORK_OFF 0   // local directories search only
#define PDB_NETWORK_PE  1   // local directories search for COFF, full search for PE
#define PDB_NETWORK_ON  2   // no restrictions
//PDB_NETWORK = PDB_NETWORK_PE

// PDBIDA is able to load MSF 7.0 PDB files only.
// MSDIA can load all PDB files, including old MSF 2.0 files.
// If you set the following option to YES, IDA will automatically switch
// to MSDIA for old files.
// Please note that under Linux/macOS the MSDIA provider requires you to configure
// the win32_remote.exe or win64_remote64.exe server because it can run only on Windows.
// It is possible to specify the desired behavior in the command line:
//      ida -Opdb:fallback input_file
//      ida -Opdb:nofallback input_file
#ifdef __NT__
PDB_MSDIA_FALLBACK = YES
#else
PDB_MSDIA_FALLBACK = NO
#endif

// remote server where win32_remote.exe or win64_remote64.exe is running
// used when loading PDB symbols on non-Windows platforms
// NB: it will be used only if there is not already an existing debugging session started
PDB_REMOTE_SERVER = "localhost";
PDB_REMOTE_PORT   = 23946
// password for the remote server
PDB_REMOTE_PASSWD = "";

```

`pdb.cpp`:

```cpp

// IDA plugin to load function name information from PDB files
//      26-02-2008 Complete rewrite to use DIA API

#ifdef __NT__
#define USE_STANDARD_FILE_FUNCTIONS
#define _CRT_SECURE_NO_WARNINGS
#  define WIN32_LEAN_AND_MEAN
#  include <windows.h>
#  include <objidl.h>
#  define PDB_PLUGIN

#include "stdafx.h"

#else
#  define ENABLE_REMOTEPDB
#endif

#include <memory>

#include <ida.hpp>
#include <idp.hpp>
#include <err.h>
#include <md5.h>
#include <dbg.hpp>
#include <auto.hpp>
#include <name.hpp>
#include <frame.hpp>
#include <loader.hpp>
#include <diskio.hpp>
#include <typeinf.hpp>
#include <demangle.hpp>
#include <mergemod.hpp>
#include <intel.hpp>
#include <network.hpp>
#include <workarounds.hpp>
int data_id;

#include "pdb.hpp"
#define LOAD_TYPES 0x1
#define LOAD_NAMES 0x2

#include "common.cpp"
#ifdef ENABLE_REMOTEPDB
// We only enable remote PDB fetching in case
// we are building the plugin, for the moment.
// While this is an annoying limitation, it's mostly
// because the pdbremote code requires that
// the 'win32' (stub) debugger be loadable, in order
// to work: Ideally, we should only use an rpc_client
// instance, but currently we channel PDB requests
// through the remote debugger connection.
// (Neither efd.exe, nor tilib.exe can use of a
//  running win32_remote.exe debugger instance for the
//  moment)
#  include "pdbremote.cpp"
#else
#  include "oldpdb.h"
#  include "msdia.cpp"
#endif
#include "tilbuild.cpp"


#include "sip.cpp"


//----------------------------------------------------------------------
static bool looks_like_function_name(const char *name)
{
  // this is not quite correct: the presence of an opening brace
  // in the demangled name indicates a function
  // we can have a pointer to a function and there will be a brace
  // but this logic is not applied to data segments
  if ( strchr(name, '(') != nullptr )
    return true;

  // check various function keywords
  static const char *const keywords[] =
  {
    "__cdecl ",
    "public: ",
    "virtual ",
    "operator ",
    "__pascal ",
    "__stdcall ",
    "__thiscall ",
  };
  for ( int i=0; i < qnumber(keywords); i++ )
    if ( strstr(name, keywords[i]) != nullptr )
      return true;
  return false;
}

//----------------------------------------------------------------------
bool pdb_ctx_t::check_for_ids(ea_t ea, const char *name)
{
  // Seems to be a GUID?
  const char *ptr = name;
  while ( *ptr == '_' )
    ptr++;

  static const char *const guids[] = { "IID", "DIID", "GUID", "CLSID", "LIBID", nullptr };
  static const char *const sids[] = { "SID", nullptr };

  struct id_info_t
  {
    const char *const *names;
    const char *type;
  };
  static const id_info_t ids[] =
  {
    { guids, "GUID x;" },
    { sids,  "SID x;" },
  };
  if ( !checked_types )
  {
    if ( get_named_type(nullptr, "GUID", NTF_TYPE) == 0 )
    {
      static const char decl[] = "typedef struct _GUID { unsigned long  Data1; unsigned short Data2; unsigned short Data3; unsigned char Data4[8];} GUID;";
      h2ti(nullptr, nullptr, decl, HTI_DCL, nullptr, nullptr, msg);
    }
    // SID type is pretty complex, so we won't add it manually but just check if it exists
    has_sid = get_named_type(nullptr, "SID", NTF_TYPE) != 0;
    checked_types = true;
  }
  for ( int k=0; k < qnumber(ids); k++ )
  {
    if ( k == 1 && !has_sid )
      continue;
    for ( const char *const *p2=ids[k].names; *p2; p2++ )
    {
      const char *guid = *p2;
      size_t len = strlen(guid);
      if ( strncmp(ptr, guid, len) == 0
        && (ptr[len] == '_' || ptr[len] == ' ') ) // space can be in demangled names
      {
        apply_cdecl(nullptr, ea, ids[k].type);
        return true;
      }
    }
  }
  if ( strncmp(name, "_guid", 5) == 0 )
  {
    apply_cdecl(nullptr, ea, ids[0].type);
    return true;
  }
  return false;
}

//----------------------------------------------------------------------
static bool is_data_prefix(ea_t ea, const char *name)
{
  static const char *const data_prefixes[] =
  {
    "__IMPORT_DESCRIPTOR",
    //"__imp_",             // imported function pointer
  };
  for ( int i=0; i < qnumber(data_prefixes); i++ )
    if ( strncmp(name, data_prefixes[i], strlen(data_prefixes[i])) == 0 )
      return true;

  // __real@xxxxxxxx            - floating point number, 4 bytes
  // __real@xxxxxxxxxxxxxxxx    - floating point number, 8 bytes
  if ( strncmp(name, "__real@", 7) == 0 )
  {
    const char *ptr = name + 7;
    const char *hex = ptr;
    while ( qisxdigit(*ptr) )
      ptr++;
    size_t len = ptr - hex;
    if ( len == 8 )
    {
      create_float(ea, 4);
      return true;
    }
    if ( len == 16 )
    {
      create_double(ea, 8);
      return true;
    }
    if ( len == 20 )
    { // i haven't seen this, but probably it exists too
      create_tbyte(ea, 10);
      return true;
    }
  }
  return false;
}

//-------------------------------------------------------------------------
// Names that we prefer to ignore
static bool ignore_name(const char *name)
{
  struct ida_local sfxlen_t
  {
    const char *const sfx;
    size_t len;       // strlen(sfx)
  };

  static const sfxlen_t unwanted_suffixes[] =
  {
    { "_epilog1_start", 14 },
  };

  size_t len = qstrlen(name);

  for ( auto &sfx : unwanted_suffixes )
  {
    if ( len > sfx.len && streq(&name[len-sfx.len], sfx.sfx) )
      return true;
  }

  // MSVS debug symbols may contain the temporary labels "Temp.00000001"
  if ( strneq(name, "Temp.", 5) )
  {
    const char *p = &name[5];
    if ( *p != '\0' )
    {
      for ( ; *p != '\0' && qisdigit(*p); ++p )
        ;
      if ( *p == '\0' )
        return true;
    }
  }

  // _lc002_004933_
  if ( strneq(name, "_lc", 3) )
  {
    const char *p = &name[3];
    if ( qisdigit(p[0])
      && qisdigit(p[1])
      && qisdigit(p[2])
      && p[3] == '_'
      && qisdigit(p[4])
      && qisdigit(p[5])
      && qisdigit(p[6])
      && qisdigit(p[7])
      && qisdigit(p[8])
      && qisdigit(p[9])
      && p[10] == '_' )
    {
      return true;
    }
  }

  return false;
}

//-------------------------------------------------------------------------
int pdb_ctx_t::get_utf16_encoding_idx()
{
  if ( utf16_encidx < 0 )
    utf16_encidx = add_encoding(inf_is_be() ? "UTF-16BE" : "UTF-16LE");
  return utf16_encidx;
}

//----------------------------------------------------------------------
// maybe_func: -1:no, 0-maybe, 1-yes, 2:no,but iscode
bool pdb_ctx_t::apply_name_in_idb(ea_t ea, const qstring &name, int maybe_func, uint32 the_machine_type)
{
  show_addr(ea); // so the user doesn't get bored

  if ( ignore_name(name.c_str()) )
    return true;

  // check for meaningless 'string' names
  if ( strncmp(name.c_str(), "??_C@_", 6) == 0 )
  {
    // ansi:    ??_C@_0<len>@xxx
    // unicode: ??_C@_1<len>@xxx
    // TODO: parse length?
    uint32 strtype = STRTYPE_C;
    if ( name[6] == '1' )
      strtype = make_str_type(STRTYPE_C_16, get_utf16_encoding_idx());
    create_strlit(ea, 0, strtype);
    return true;
  }

  qstring demangled;
  if ( maybe_func <= 0 && demangle_name(&demangled, name.c_str(), MNG_SHORT_FORM) > 0 )
  {
    if ( demangled == "`string'" )
    {
      int utf16_idx = get_utf16_encoding_idx();
      uint32 utf16_strtype = make_str_type(STRTYPE_C_16, utf16_idx);
      size_t s1 = get_max_strlit_length(ea, STRTYPE_C);
      size_t s2 = get_max_strlit_length(ea, utf16_strtype);
      create_strlit(ea, 0, s1 >= s2 ? STRTYPE_C : utf16_strtype);
      return true;
    }
  }

  // Renaming things immediately right here can lead to bad things.
  // For example, if the name is a well known function name, then
  // ida will immediately try to create a function. This is a bad idea
  // because IDA does not know exact function boundaries and will try
  // to guess them. Since the database has little information yet, there
  // is a big chance that the function will end up to be way too long.
  // That's why we collect names here and will rename them later.
  namelist[ea] = name;

  if ( check_for_ids(ea, name.c_str())
    || check_for_ids(ea, demangled.c_str())
    || is_data_prefix(ea, name.c_str())
    || maybe_func < 0 )
  {
    set_notcode(ea); // should not be code
    return true;
  }
  if ( maybe_func == 0 && get_mangled_name_type(name.c_str()) == MANGLED_DATA )
  {
    // NB: don't call set_notcode() here
    // since demangler may give false positives
    return true;
  }

  // do not automatically create functions in debugger segments
  segment_t *s = getseg(ea);
  if ( s == nullptr || !s->is_loader_segm() )
    return true;

  // ARMv7 PDBs don't use bit 0 for Thumb mode
  if ( ph.has_code16_bit() && the_machine_type != CV_CFL_ARM7 )
  {
    // low bit is Thumb/MIPS16 mode
    bool func16 = (ea & 1) != 0;
    ea &= ~1;
    if ( func16 )
    {
      // move the entry in namelist
      namelist.erase(ea|1);
      namelist[ea] = name;
    }
  }

  if ( maybe_func == 0 )
  {
    do
    {
      // check for function telltales
      if ( segtype(ea) != SEG_DATA
        && demangle_name(&demangled, name.c_str(), MNG_LONG_FORM) > 0
        && looks_like_function_name(demangled.c_str()) )
      {
        maybe_func = 1;
        break;
      }

      int stype = segtype(ea);
      if ( stype != SEG_NORM && stype != SEG_CODE ) // only for code or normal segments
        break;

      insn_t insn;
      if ( decode_insn(&insn, ea) == 0 )
        break;

      if ( processor_t::is_sane_insn(insn, 1) < 0 )
        break;
      maybe_func = 1;
    } while ( false );
  }
  if ( maybe_func == 1 )
    auto_make_proc(ea); // fixme: when we will implement lvars, we have to process these request
                        // before handling lvars
  return true;
}

//----------------------------------------------------------------------------
// These two funcs for old.cpp only
bool apply_name(ea_t ea, const qstring &name, int maybe_func)
{
  pdb_ctx_t &pv = *GET_MODULE_DATA(pdb_ctx_t);
  return pv.apply_name_in_idb(ea, name, maybe_func, pv.g_machine_type);
}

void load_vc_til(void)
{
  pdb_ctx_t &pv = *GET_MODULE_DATA(pdb_ctx_t);
  pv.load_vc_til();
}

//----------------------------------------------------------------------
void pdb_ctx_t::load_vc_til(void) const
{
  // We managed to load the PDB file.
  // It is very probably that the file comes from VC
  // Load the corresponding type library immediately
  if ( ph.id == PLFM_386 && pe.signature == PEEXE_ID )
  {
    if ( pe.is_userland() )
      add_til(pe.is_pe_plus() ? "mssdk64_win7" : "mssdk_win7", ADDTIL_INCOMP);
    else
      add_til(pe.is_pe_plus() ? "ntddk64_win7" : "ntddk_win7", ADDTIL_INCOMP);
  }
}

//----------------------------------------------------------------------------
class pdb_til_builder_t : public til_builder_t
{
  int npass;
public:
  pdb_til_builder_t(pdb_ctx_t &_pv, til_t *_ti, pdb_access_t *_pa)
    : til_builder_t(_pv, _ti, _pa), npass(0) {}

  virtual HRESULT before_iterating(pdb_sym_t &global_sym) override;
  virtual bool iterate_symbols_once_more(pdb_sym_t & /*global_sym*/) override
  {
    handled.clear();
    return ++npass == 1;
  }
  virtual void type_created(ea_t ea, int id, const char *name, const tinfo_t &tif) const override;
  virtual bool handle_symbol_at_ea(pdb_sym_t &sym, DWORD tag, ea_t ea, qstring &name) override;
  virtual void handle_function_type(pdb_sym_t &fun_sym, ea_t ea) override;
  virtual HRESULT handle_function_child(
        pdb_sym_t &fun_sym,
        ea_t ea,
        pdb_sym_t &child_sym,
        DWORD child_tag,
        DWORD child_loc_type) override;
};

//----------------------------------------------------------------------------
HRESULT pdb_til_builder_t::before_iterating(pdb_sym_t &)
{
  pv.load_vc_til();
  if ( default_compiler() == COMP_UNK )
    set_compiler_id(COMP_MS);
  return S_OK;
}

//----------------------------------------------------------------------------
void pdb_til_builder_t::type_created(ea_t ea, int id, const char *name, const tinfo_t &tif) const
{
  pv.check_tinfo(ea, id, name, tif);
}

//----------------------------------------------------------------------------
// add the annotation strings to 'ea'
// following types are commonly used in windows drivers
// 1) assertion:
// #define NT_ASSERT(_exp)
//     ((!(_exp)) ?
//         (__annotation(L"Debug", L"AssertFail", L#_exp),
//          DbgRaiseAssertionFailure(), FALSE) :
//         TRUE)
// 2) trace message
//
//   TMF:
//   2158e7d3-9867-cde3-18b5-9713c628abdf TEEDriver // SRC=Queue.c MJ= MN=
//   #typev Queue_c2319 207 "%0PowerDown = %10!x!" //   LEVEL=TRACE_LEVEL_VERBOSE FLAGS=TRACE_QUEUE
//   {
//   devExt->powerDown, ItemLong -- 10
//   }, Constant
//
// 3) trace message control
// WPP_DEFINE_CONTROL_GUID(Name,Guid,Bits) __annotation(L"TMC:", WPP_GUID_WTEXT Guid, _WPPW(WPP_STRINGIZE(Name)) Bits WPP_TMC_ANNOT_SUFIX);
//  expands into:
//
//  TMC:
//  0b67e6f7-ae91-470c-b4b6-dcd6a9034e18
//  TEEDriverTraceGuid
//  MYDRIVER_ALL_INFO
//  TRACE_DRIVER
//  TRACE_DEVICE
//  [..]
//  TRACE_BUS_DRIVER_LAYER
//
// In all other cases we just use plain __annotation(a,b,c,...)
// TODO: use anterior lines for big annotations (over 1KB)
static void apply_annotation(ea_t ea, const qstrvec_t &params)
{
  if ( params.empty() )
    return;

  qstring full_cmt;
  if ( params.size() >= 3 && params[0] == "Debug" && params[1] == "AssertFail" )
  {
    full_cmt.sprnt("NT_ASSERT(\"%s\"", params[2].c_str());
    for ( size_t i = 3; i < params.size(); i++ )
      full_cmt.cat_sprnt(",\n  \"%s\"", params[i].c_str());
    full_cmt.append(")");
  }
  else if ( params[0] == "TMF:" )
  {
    full_cmt = "__annotation(\"TMF:\"";
    bool add_newline = true;
    for ( size_t i = 1; i < params.size(); i++ )
    {
      full_cmt.cat_sprnt(",%s\"%s\"", add_newline ? "\n  " : " ", params[i].c_str());
      // print args betwen { } on one line
      if ( params[i] == "{" )
        add_newline = false;
      else if ( params[i] == "}" )
        add_newline = true;
    }
    full_cmt.append(")");
  }
  else
  {
    full_cmt.sprnt("__annotation(\"%s\"", params[0].c_str());
    for ( size_t i = 1; i < params.size(); i++ )
      full_cmt.cat_sprnt(", \"%s\"", params[i].c_str());
    full_cmt.append(")");
  }
  set_cmt(ea, full_cmt.c_str(), false);
}

//----------------------------------------------------------------------------
bool pdb_til_builder_t::handle_symbol_at_ea(
        pdb_sym_t &sym,
        DWORD tag,
        ea_t ea,
        qstring &name)
{
  int maybe_func = 0;
  switch ( tag )
  {
    case SymTagFunction:
    case SymTagThunk:
      maybe_func = 1;
      break;
    case SymTagBlock:
    case SymTagLabel:
    case SymTagFuncDebugStart:
    case SymTagFuncDebugEnd:
      maybe_func = 2;
      break;
    case SymTagData:
    case SymTagVTable:
      maybe_func = -1;
      break;
    case SymTagPublicSymbol:
      {
        BOOL b;
        if ( sym.get_function(&b) == S_OK && b )
          maybe_func = 1;
      }
      break;
    case SymTagAnnotation:
      {
        struct annotation_value_collector_t : public pdb_access_t::children_visitor_t
        {
          const til_builder_t *tb;
          qstrvec_t ann_params;
          HRESULT visit_child(pdb_sym_t &child) override
          {
            qstring v;
            if ( tb->get_variant_string_value(&v, child) )
              // set_cmt(ea, v.c_str(), false);
              ann_params.push_back(v);
            return S_OK;
          }
          annotation_value_collector_t(const til_builder_t *_tb)
            : tb(_tb) {}
        };
        annotation_value_collector_t avc(this);
        pdb_access->iterate_children(sym, SymTagNull, avc);
        apply_annotation(ea, avc.ann_params);
        maybe_func = segtype(ea) == SEG_CODE ? 2 /*no func, but code*/ : 0 /*unclear*/;
      }
      break;
    default:
      break;
  }

  // symbols starting with __imp__ cannot be functions
  if ( strncmp(name.c_str(), "__imp__", 7) == 0 )
  {
    if ( inf_is_64bit() )
      create_qword(ea, 8);
    else
      create_dword(ea, 4);
    maybe_func = -1;
  }

  BOOL iscode;
  if ( sym.get_code(&iscode) == S_OK )
  {
    if ( iscode )
    {
      if ( is_notcode(ea) )
      {
        // clear wrong notcode mark
        // (was seen happening with bogus SymTagData symbol for _guard_dispatch_icall_nop)
        clr_notcode(ea);
        create_insn(ea);
      }
    }
    else
    {
      // not a function
      maybe_func = -1;
    }
  }

  if ( (pdb_access->pdbargs.flags & PDBFLG_LOAD_TYPES) != 0 )
  {
    tpinfo_t tpi;
    if ( get_symbol_type(&tpi, sym) )
    {
      // Apparently _NAME_ is a wrong symbol generated for file names
      // It has wrong type information, so correct it
      if ( tag == SymTagData && name == "_NAME_" && tpi.type.get_decltype() == BTF_CHAR )
        tpi.type = tinfo_t::get_stock(STI_ACHAR); // char []
      if ( tag == SymTagFunction )
      {
        // convert the type again, this time passing function symbol
        // this allows us to get parameter names and handle static class methods
        pdb_sym_t *func_sym = pdb_access->create_sym();
        pdb_sym_janitor_t janitor_pType(func_sym);
        if ( sym.get_type(func_sym) == S_OK )
        {
          tpinfo_t tpi2;
          if ( really_convert_type(&tpi2, *func_sym, &sym, SymTagFunctionType) == cvt_ok )
            tpi.type.swap(tpi2.type); // successfully retrieved
        }
      }
      if ( tpi.type.is_func() || tag == SymTagFunction )
      {
        maybe_func = 1;
        handle_function_type(sym, ea);
      }
      else
      {
        maybe_func = -1;
      }
      if ( npass != 0 )
      {
        bool use_ti = true;
        func_type_data_t fti;
        if ( tpi.type.get_func_details(&fti)
          && fti.empty()
          && fti.rettype.is_decl_void() )
        { // sometimes there are functions with linked FunctionType but no parameter or return type info in it
          // we get better results by not forcing type info on them
          use_ti = false;
        }
        if ( use_ti )
        {
          type_created(ea, 0, nullptr, tpi.type);
          apply_tinfo(ea, tpi.type, TINFO_STRICT);
        }
      }
    }
    else if ( maybe_func == 1 )
    {
      auto_make_proc(ea); // certainly a func
    }
  }
  pv.apply_name_in_idb(ea, name, maybe_func, pdb_access->get_machine_type());
  return true;
}

//---------------------------------------------------------------------------
HRESULT pdb_til_builder_t::handle_function_child(
        pdb_sym_t &fun_sym,
        ea_t ea,
        pdb_sym_t &child_sym,
        DWORD child_tag,
        DWORD child_loc_type)
{
  LONG offset;
  DWORD reg_id;
  switch ( child_loc_type )
  {
    case LocIsEnregistered:
      if ( child_sym.get_registerId(&reg_id) == S_OK )
      {
        if ( enregistered_bug && reg_id > 0 )
          reg_id--;
        func_t *pfn = get_func(ea);
        qstring name;
        child_sym.get_name(&name);
        qstring canon;
        print_pdb_register(&canon, pdb_access->get_machine_type(), reg_id);
        if ( pfn != nullptr )
          add_regvar(pfn, pfn->start_ea, pfn->end_ea, canon.c_str(), name.c_str(), nullptr);
      }
      break;

    case LocIsRegRel:
      if ( child_sym.get_registerId(&reg_id) == S_OK
        && child_sym.get_offset(&offset) == S_OK
        && (is_frame_reg(reg_id) || is_stack_reg(reg_id)) )
        // attempt at handling both stack and frame regs (was ebp only)
      {
        func_t *pfn = get_func(ea);
        if ( pfn != nullptr )
        {
          qstring name;
          child_sym.get_name(&name);
          tpinfo_t tpi;
          if ( get_symbol_type(&tpi, child_sym) )
          {
            if ( tpi.type.get_size() != BADSIZE )
            {
              // DIA's offset is bp-based, not frame-based like in IDA
              if ( is_frame_reg(reg_id) )
                offset -= pfn->fpd;
              else // SP-based; turn into frame-based
                offset -= pfn->frsize;
              // make sure the new variable is not overwriting the return address
              // for some reason some PDBs have bogus offsets for some params/locals...
              if ( !is_intel386(pdb_access->get_machine_type()) && !is_intel64(pdb_access->get_machine_type())
                || offset > 0
                || tpi.type.get_size() <= -offset )
              {
                if ( define_stkvar(pfn, name.c_str(), offset, tpi.type) )
                {
                  insn_t insn;
                  insn.ea = pfn->start_ea;
                  tinfo_t frame;
                  ssize_t stkvar_idx = frame.get_stkvar(nullptr, insn, nullptr, offset);
                  if ( stkvar_idx != -1 )
                  {
                    frame.set_udm_type(stkvar_idx, tpi.type);
                    tid_t tid = frame.get_udm_tid(stkvar_idx);
                    set_userti(tid);
                  }
                }
              }
            }
          }
          else // no type info...
          {
            msg("%a: stkvar '%s' with no type info\n", ea, name.c_str());
          }
        }
      }
      break;
    default:
      return til_builder_t::handle_function_child(fun_sym, ea, child_sym,
                                                  child_tag, child_loc_type);
  }
  return S_OK;
}

//---------------------------------------------------------------------------
void pdb_til_builder_t::handle_function_type(pdb_sym_t &sym, ea_t ea)
{
  if ( npass == 0 )
  {
    if ( !create_insn(ea) )
      return;

    // add the address to the queue - this will help to determine better function boundaries
    auto_make_proc(ea);
  }
  else
  {
    ea_t end = BADADDR;
    DWORD64 ulLen;
    if ( sym.get_length(&ulLen) == S_OK )
      end = ea + asize_t(ulLen);
    ea_t next_planned = peek_auto_queue(ea+1, AU_PROC);

    // before adding a function, try to create all its instructions.
    // without this the frame analysis may fail.
    func_t fn(ea);
    find_func_bounds(&fn, FIND_FUNC_DEFINE);

    bool created = false;
    bool acceptable_end = end <= next_planned;   // end is wrong for fragmented functions
    if ( acceptable_end )
      created = add_func(ea, end);
    if ( !created )
      add_func(ea);

    til_builder_t::handle_function_type(sym, ea);
  }
}

//---------------------------------------------------------------------------
static HRESULT common_handler(pdb_ctx_t &pv, pdb_access_t &pdb_access)
{
  try
  {
    pdb_til_builder_t builder(pv, CONST_CAST(til_t *)(get_idati()), &pdb_access);
    pdb_sym_t *global = pdb_access.create_sym(pdb_access.get_global_symbol_id());
    pdb_sym_janitor_t janitor_global(global);
    return builder.build(*global);
  }
  catch ( const pdb_exception_t &e )
  {
    msg("Couldn't parse PDB data: %s\n", e.what.c_str());
    return E_FAIL;
  }
}

//---------------------------------------------------------------------------
#ifdef ENABLE_REMOTEPDB
// On Unix computers use remote_pdb_access
static HRESULT remote_handler(pdb_ctx_t &pv, const pdbargs_t &args)
{
  int chosen_remote_port = pv.pdb_remote_port;
  if ( pv.pdb_remote_port_64 != -1 && inf_is_64bit() )
    chosen_remote_port = pv.pdb_remote_port_64;
  remote_pdb_access_t remote_pdb_access(args,
                                        pv.pdb_remote_server.c_str(),
                                        chosen_remote_port,
                                        pv.pdb_remote_passwd.c_str());
  HRESULT hr = remote_pdb_access.open_connection();
  if ( hr == S_OK )
    hr = common_handler(pv, remote_pdb_access);
  return hr;
}
#endif


/*====================================================================
                      IDA PRO INTERFACE START HERE
====================================================================*/

//-------------------------------------------------------------------------
static const cfgopt_t g_opts[] =
{
  CFGOPT_R ("PDB_REMOTE_PORT",    pdb_ctx_t, pdb_remote_port,    0, 65535),
  CFGOPT_R ("PDB_REMOTE_PORT_64", pdb_ctx_t, pdb_remote_port_64, 0, 65535),
  CFGOPT_QS("_NT_SYMBOL_PATH",    pdb_ctx_t, full_sympath,       true),
  CFGOPT_QS("PDB_REMOTE_SERVER",  pdb_ctx_t, pdb_remote_server,  true),
  CFGOPT_QS("PDB_REMOTE_PASSWD",  pdb_ctx_t, pdb_remote_passwd,  true),
  CFGOPT_R ("PDB_NETWORK",        pdb_ctx_t, pdb_network,        PDB_NETWORK_OFF, PDB_NETWORK_ON),
  CFGOPT_R("PDB_PROVIDER",		  pdb_ctx_t, pdb_provider,       PDB_PROVIDER_MSDIA, PDB_PROVIDER_PDBIDA),
  CFGOPT_QS("PDB_MSDIA_FALLBACK", pdb_ctx_t, opt_fallback,       true),
};

//----------------------------------------------------------------------
#ifndef ENABLE_REMOTEPDB
static uint32 get_machine_from_idb(const processor_t &ph)
{
  uint32 mt;
  switch ( ph.id )
  {
    case PLFM_ARM:
      mt = inf_is_64bit() ? CV_CFL_ARM64 : CV_CFL_ARM6;
      break;
    case PLFM_MIPS:
      mt = CV_CFL_MIPSR4000;
      break;
    case PLFM_PPC:
      mt = inf_is_be() ? CV_CFL_PPCBE : CV_CFL_PPCFP;
      break;
    case PLFM_SH:
      mt = CV_CFL_SH4;
      break;
    case PLFM_IA64:
      mt = CV_CFL_IA64;
      break;
    case PLFM_386:
    default:
      mt = CV_CFL_80386;
      break;
  }
  return mt;
}
#endif

//----------------------------------------------------------------------
void pdb_ctx_t::init_sympaths()
{
  // user specified symbol path?
  full_sympath.qclear();
  read_config_file2("pdb", g_opts, qnumber(g_opts), nullptr, nullptr, 0, this);
  if (pdb_provider != PDB_PROVIDER_MSDIA)
  {
	  msg("PDB: This modified version of PDB plug-in currently only supports MSDIA interface\n");
  }

  qstring env_sympath;
  if ( qgetenv("_NT_SYMBOL_PATH", &env_sympath) )
    full_sympath.swap(env_sympath);

  // default symbol search path
  if ( full_sympath.empty() )
  {
    char cache_path[QMAXPATH];
    #ifdef __NT__
    if ( !GetTempPath(sizeof(cache_path), cache_path) )
      cache_path[0] = '\0';
    else
      qstrncat(cache_path, "ida", sizeof(cache_path));
    #else
    qstring tmpdir;
    if ( !qgetenv("TMPDIR", &tmpdir) && !qgetenv("TMP", &tmpdir) )
      tmpdir = "/tmp";
    qmakepath(cache_path, sizeof(cache_path), tmpdir.c_str(), "ida", nullptr);
    if ( !qisdir(cache_path) && qmkdir(cache_path, 0777) != 0 )
      cache_path[0] = '\0';
    #endif
    full_sympath.sprnt("%s%s%s", g_spath_prefix, cache_path, g_spath_suffix);
  }
  deb(IDA_DEBUG_DBGINFO, "PDB: _NT_SYMBOL_PATH=%s\n", full_sympath.c_str());

  if ( opt_provider != 0 )
    pdb_provider = opt_provider;
}

//----------------------------------------------------------------------
#define MAX_DISP_PATH 80
// If path name is too long then replace some directories with "...."
static qstring truncate_path(const qstring &path)
{
  qstring str = path;
  int len = str.length();
  if ( len > MAX_DISP_PATH )
  {
    char slash = '\\';
    size_t start = str.find(slash);
    if ( start == qstring::npos )
    {
      slash = '/';
      start = str.find(slash);
    }
    if ( start != qstring::npos )
    {
      size_t end = str.rfind(slash);
      size_t prev_start;
      do
      {
        prev_start = start;
        start = str.find(slash, start + 1);
      } while ( len - (end - start) < MAX_DISP_PATH );
      start = prev_start + 1;
      if ( end > start )
      {
        str.remove(start, end - start);
        str.insert(start, "....");
      }
    }
  }
  return str;
}

//----------------------------------------------------------------------------
static bool read_pdb_signature(pdb_signature_t *pdb_sign)
{
  netnode penode(PE_NODE);
  rsds_t rsds;
  size_t size = sizeof(rsds_t);
  if ( penode.getblob(&rsds, &size, 0, RSDS_TAG) != nullptr && size == sizeof(rsds_t) ) // RSDS
  {
    pdb_sign->age = rsds.age;
    pdb_sign->sig = 0;
    memcpy(pdb_sign->guid, &rsds.guid, sizeof(pdb_sign->guid));
    CASSERT(sizeof(pdb_sign->guid) == sizeof(rsds.guid));
  }
  else
  {
    cv_info_pdb20_t nb10;
    size = sizeof(nb10);
    if ( penode.getblob(&nb10, &size, 0, NB10_TAG) != nullptr && size == sizeof(nb10) ) // NB10
    {
      pdb_sign->age = nb10.age;
      pdb_sign->sig = nb10.signature;
    }
    else
    {
      return false;
    }
  }
  return true;
}

//----------------------------------------------------------------------------
// moved into a separate function to diminish the stack consumption
static qstring get_input_path()
{
  char input_path[QMAXPATH];
  if ( get_input_file_path(input_path, sizeof(input_path)) <= 0 )
    input_path[0] = '\0';
  return input_path;
}

#define ADDRESS_FIELD 10
#define LOAD_TYPES_FIELD 20
#define LOAD_NAMES_FIELD 30

//--------------------------------------------------------------------------
static int idaapi details_modcb(int fid, form_actions_t &fa)
{
  switch ( fid )
  {
    case CB_INIT:
    case LOAD_TYPES_FIELD:
    case LOAD_NAMES_FIELD:
      {
        ushort types, names;
        if ( fa.get_rbgroup_value(LOAD_TYPES_FIELD, &types)
          && fa.get_rbgroup_value(LOAD_NAMES_FIELD, &names) )
        {
          fa.enable_field(ADDRESS_FIELD, !(types != 0 && names == 0));
        }
      }
      break;
  }

  return 1;
}

//-------------------------------------------------------------------------
static void set_file_by_ext(pdbargs_t *args, const char *buf)
{
  const char *ext = get_file_ext(buf);
  if ( ext != nullptr && strieq(ext, "pdb") )
  {
    args->pdb_path = buf;
    args->input_path.clear();
  }
  else
  {
    args->input_path = buf;
    args->pdb_path.clear();
  }
}

//----------------------------------------------------------------------------
static bool ask_pdb_details(pdbargs_t *args)
{
  netnode penode(PE_NODE);
  args->loaded_base = penode.altval(PE_ALT_IMAGEBASE);

  static const char form[] =
    "Load PDB file\n"
    "%/"
    "<#Specify the path to the file to load symbols for#~I~nput file:f:0:64::>\n"
    "<#Specify the loading address of the exe/dll file#~A~ddress   :N" QSTRINGIZE(ADDRESS_FIELD) "::64::>\n"
    "<#Load types#Load ~t~ypes:C" QSTRINGIZE(LOAD_TYPES_FIELD) ">\n"
    "<#Load names#Load ~n~ames:C" QSTRINGIZE(LOAD_NAMES_FIELD) ">>\n"
    "Note: you can specify either a .pdb, or an .exe/.dll file name.\n"
    "In the latter case, IDA will try to find and load\n"
    "the PDB specified in its debug directory.\n"
    "\n";

  char buf[QMAXPATH];
  const char *src = nullptr;
  if ( !args->pdb_path.empty() )
    src = args->pdb_path.begin();
  else if ( !args->input_path.empty() )
    src = args->input_path.begin();
  if ( src == nullptr )
    src = "*.pdb";

  qstrncpy(buf, src, sizeof(buf));

  CASSERT(sizeof(args->loaded_base) == sizeof(ea_t));
  sval_t load_options = 0;
  setflag(load_options, LOAD_TYPES, (args->flags & PDBFLG_LOAD_TYPES) != 0);
  setflag(load_options, LOAD_NAMES, (args->flags & PDBFLG_LOAD_NAMES) != 0);

  if ( !ask_form(form, details_modcb, buf, &args->loaded_base, &load_options) )
    return false;

  set_file_by_ext(args, buf);

  setflag(args->flags, PDBFLG_LOAD_TYPES, (load_options & LOAD_TYPES) != 0);
  setflag(args->flags, PDBFLG_LOAD_NAMES, (load_options & LOAD_NAMES) != 0);

  return true;
}

//-------------------------------------------------------------------------
static bool get_details_from_netnode(pdbargs_t *args)
{
  netnode pdbnode;
  pdbnode.create(PDB_NODE_NAME);

  args->loaded_base = pdbnode.altval(PDB_DLLBASE_NODE_IDX);
  if ( args->loaded_base == 0 )
  {
    msg("PDB: PDB_CC_USER_WITH_DATA called without an imagebase, cannot proceed\n");
fail:
    // set failure result
    pdbnode.altset(PDB_DLLBASE_NODE_IDX, 0);
    return false;
  }

  // TODO dllname shouldn't be needed when we're reading from debugger memory
  qstring tmp;
  pdbnode.supstr(&tmp, PDB_DLLNAME_NODE_IDX);
  if ( tmp.empty() )
  {
    msg("PDB: PDB_CC_USER_WITH_DATA called without a filename, cannot proceed\n");
    goto fail;
  }

  set_file_by_ext(args, tmp.c_str());

  setflag(args->flags, PDBFLG_LOAD_TYPES, true);
  setflag(args->flags, PDBFLG_LOAD_NAMES, pdbnode.altval(PDB_TYPESONLY_NODE_IDX) == 0);

  return true;
}

//-------------------------------------------------------------------------
static bool get_pdb_path(pdbargs_t *args, netnode penode)
{
  penode.supstr(&args->pdb_path, PE_SUPSTR_PDBNM);

  return !args->pdb_path.empty(); // do not ask to load pdb with empty name
}

//-------------------------------------------------------------------------
static bool get_details_from_pe(pdbargs_t *args)
{
  netnode penode(PE_NODE);
  if ( !get_pdb_path(args, penode) )
    return false;
  args->input_path = get_input_path();
  args->loaded_base = penode.altval(PE_ALT_IMAGEBASE);

  static const char form[] =
    "BUTTON YES ~Y~es\n"
    "BUTTON NO ~N~o\n"
    "BUTTON CANCEL NONE\n"
    "Load PDB file\n"
    "The input file was linked with debug information stored here:\n"
    "%q\n"
    "Do you want to look for this file at the specified path\n"
    "and the Microsoft Symbol Server?\n"
    "<#Load types#Load ~t~ypes:C10>\n"
    "<#Load names#Load n~a~mes:C20>>\n";

  sval_t load_options = 0;
  setflag(load_options, LOAD_TYPES, (args->flags & PDBFLG_LOAD_TYPES) != 0);
  setflag(load_options, LOAD_NAMES, (args->flags & PDBFLG_LOAD_NAMES) != 0);

  qstring *pdb_path = &args->pdb_path;
  int res = ask_form(form, pdb_path, &load_options);
  if ( res != 1 )
    return false;

  setflag(args->flags, PDBFLG_LOAD_TYPES, (load_options & LOAD_TYPES) != 0);
  setflag(args->flags, PDBFLG_LOAD_NAMES, (load_options & LOAD_NAMES) != 0);

  return true;
}

//-------------------------------------------------------------------------
static bool ask_for_pdb_file(pdbargs_t *pdbargs, const char *err_str)
{
  qstring disp_path = truncate_path(pdbargs->input_path);
  if ( ask_yn(ASKBTN_YES,
              "HIDECANCEL\n"
              "AUTOHIDE REGISTRY\n"
              "%s: failed to load pdb info.\n%s\n"
              "Do you want to browse for the pdb file on disk?",
              disp_path.c_str(),
              err_str == nullptr ? "" : err_str) == ASKBTN_YES )
  {
    char *pdb_file = ask_file(false, "*.pdb", "Choose PDB file");
    if ( pdb_file != nullptr )
    {
      pdbargs->pdb_path = pdb_file;
      return true;
    }
  }
  return false;
}

//-------------------------------------------------------------------------
bool pdb_ctx_t::apply_debug_info(pdbargs_t &pdbargs)
{
  // we may run out of memory on huge pdb files. prefer to keep the partial
  // idb file in this case.
  bool restore_kill_flag = is_database_flag(DBFL_KILL);
  clr_database_flag(DBFL_KILL);

  netnode pdbnode;
  if ( pdbargs.is_pdbfile() )
    pdbnode.create(PDB_NODE_NAME);

  init_sympaths();
  pdbargs.spath = full_sympath;

  setflag(pdbargs.flags, PDBFLG_USE_HTTP, use_http(pdbargs.is_pdbfile()));

  bool ok = true;
  HRESULT hr = E_FAIL;

  {
    msg("PDB: using MSDIA provider\n");
#ifdef ENABLE_REMOTEPDB
    hr = remote_handler(*this, pdbargs);
#else
    bool was_load_error = false;
LOAD_PDB:
    try
    {
      pdb_session_ref_t ref;
      hr = ref.open_session(pdbargs);
      if ( hr == S_OK )
        hr = common_handler(*this, *ref.session->pdb_access);
    }
    catch ( const std::bad_alloc & )
    {
      warning("It appears IDA has run out of memory while loading the PDB file.\n"
              "This can happen when using the DIA SDK dll with big and/or corrupt PDBs.\n"
              "While you will now be able to continue your work, IDA cannot proceed with PDB parsing, sorry.\n\n"
              "It is also HIGHLY recommended that you save the database as soon as possible,\n"
              "quit, and restart IDA with that database.");
      hr = E_PDB_OUT_OF_MEMORY;
      was_load_error = true;
    }
#endif

    if ( pdbargs.input_path.empty() )
      pdbargs.input_path = pdbargs.pdb_path;

    if ( FAILED(hr) )
    {
      ok = false;
#ifndef ENABLE_REMOTEPDB
      const char *err_str = pdberr(hr);
      msg("PDB: could not process file \"%s\" with DIA: %s\n", pdbargs.input_path.c_str(), err_str);
      pdberr_suggest_vs_runtime(hr);

      // DIA interface failed, try the old methods
      if ( !inf_test_mode() )
      {
        g_machine_type = get_machine_from_idb(ph); // See 'g_machine_type' comment above
        ok = old_pdb_plugin(pdbargs.loaded_base, pdbargs.input_path.c_str(), pdbargs.spath.c_str());
        if ( ok )
          msg("Old method of loading PDB files (dbghelp) was successful\n");
      }
      if ( !was_load_error && !ok )
      {
        was_load_error = true;
        if ( ask_for_pdb_file(&pdbargs, err_str) )
        {
          ok = true; // reset to default
          goto LOAD_PDB;
        }
      }
#else
      if ( !pdbargs.is_dbg_module() ) // called as main plugin routine
        warning("IDA could not open \"%s\". Please check that the file "
                "exists on the remote computer.", pdbargs.fname());
      else
        msg("No PDB information found for \"%s\"\n", pdbargs.fname());
#endif
    }
  }

  if ( ok && (pdbargs.flags & PDBFLG_LOAD_NAMES) != 0 )
  {
    // Now all information is loaded into the database (except names)
    // We are ready to use names.
    show_wait_box("Loading names ...");
    int counter = 0;
    for ( namelist_t::iterator p=namelist.begin(); p != namelist.end(); ++p )
    {
      ea_t ea = p->first;
      // do not override name for COFF file
      if ( pdbargs.is_pdbfile() || !has_name(get_flags32(ea)) )
      {
        if ( pdbargs.is_dbg_module() )
          counter += set_debug_name(ea, p->second.c_str());
        else
          counter += force_name(ea, p->second.c_str());
      }
      // Every now & then, make sure the UI has had a chance to refresh.
      if ( (counter % 10 == 0) && user_cancelled() )
      {
        ok = false;
        break;
      }
    }
    hide_wait_box();
    namelist.clear();
    msg("PDB: total %d symbol%s loaded for \"%s\"\n",
        counter,
        counter != 1 ? "s" : "",
        pdbargs.input_path.c_str());
  }

  pdbnode.altset(PDB_DLLBASE_NODE_IDX, ok);
  check_added_types();

  // we have to restore the kill flag; otherwise the logic of the other parts
  // of ida may change. for example, in the absence of DBFL_KILL we remember
  // the idb path in the idb history (displayed in the File menu)
  if ( restore_kill_flag )
    set_database_flag(DBFL_KILL);

  return ok;
}

//----------------------------------------------------------------------------
bool idaapi pdb_ctx_t::run(size_t _call_code)
{

  // PDB
  pdbargs_t pdbargs;
  pdbargs.flags |= PDBFLG_LOAD_TYPES;
  if ( !(inf_get_filetype() != f_PE && !is_miniidb()) )
    pdbargs.flags |= PDBFLG_LOAD_NAMES;

  netnode penode(PE_NODE);
  penode.valobj(&pe, sizeof(pe));

  bool ok = false;
  switch ( (pdb_callcode_t)_call_code )
  {
    case PDB_CC_USER:
      // user explicitly invoked the plugin
      ok = ask_pdb_details(&pdbargs);
      // pdb_path, input_path: only one is set (depending on the file
      //                       extension), the other is cleared
      // loaded_base: specified by user (default obtained from PE)
      break;
    case PDB_CC_USER_WITH_DATA:
      // user invoked the plugin programmatically
      ok = get_details_from_netnode(&pdbargs);
      // pdb_path, input_path: only one is set (depending on the file
      //                       extension), the other is cleared
      // loaded_base: specified by user
      break;
    case PDB_CC_IDA:
      // IDA decided to call the plugin
      ok = get_details_from_pe(&pdbargs);
      // pdb_path: obtained from PE
      // input_path: IDA's input file name
      // loaded_base: obtained from PE
      break;
    default:
      break;
  }

  if ( ok )
  {
    // read pdb signature from the database, if any
    if ( !read_pdb_signature(&pdbargs.pdb_sign) )
    {
      // make it invalid but not empty
      // so that check_and_load_pdb() does not fail silently
      pdbargs.pdb_sign.age = 0xFFFFFFFF;
    }

    apply_debug_info(pdbargs);
  }

  return true;
}

//--------------------------------------------------------------------------
void pdb_ctx_t::parse_options(bool *opt_skip)
{
  *opt_skip = false;
  qstring opts(get_plugin_options("pdb"));
  if ( opts.empty() )
    return;
  char *opt = opts.begin();
  opt_provider = 0;
  opt_fallback = -1;
  do
  {
    char *end = qstrchr(opt, ':');
    if ( end != nullptr )
      *end++ = '\0';

    if ( streq(opt, "off") )
    {
      *opt_skip = true;
    }
    else if ( streq(opt, "msdia") )
    {
      opt_provider = PDB_PROVIDER_MSDIA;
    }
    else
    {
      error("AUTOHIDE NONE\n"
            "Wrong option for the PDB plugin.\n"
            "\n"
            "The valid options are:\n"
            "off     do not load plugin\n"
            "msdia   use MSDIA provider\n");
    }

    if ( end == nullptr )
      break;
    opt = end;
  } while ( true );
}

//--------------------------------------------------------------------------
// initialize plugin
static plugmod_t *idaapi init()
{
  auto pv = std::unique_ptr<pdb_ctx_t>(new pdb_ctx_t);
  bool opt_skip;
  pv->parse_options(&opt_skip);
  if ( opt_skip )
    return nullptr;
  register_srcinfo_provider(pv->pdb_srcinfo_provider);

  auto plugmod = pv.release();
  set_module_data(&data_id, plugmod);
  return plugmod;
}

//--------------------------------------------------------------------------
ssize_t idaapi pdb_ctx_t::on_event(ssize_t event_id, va_list va)
{
  qnotused(event_id);
  qnotused(va);
  return 0;                     // event is not processed
}

//--------------------------------------------------------------------------
pdb_ctx_t::pdb_ctx_t()
{
  hook_event_listener(HT_IDP, this);
  memset(&pe, 0, sizeof(pe));
  alloc_pdb_srcinfo_provider();
  g_machine_type = CV_CFL_80386;
}

//--------------------------------------------------------------------------
// terminate
pdb_ctx_t::~pdb_ctx_t()
{
  namelist.clear();
  unregister_srcinfo_provider(pdb_srcinfo_provider);
  free_pdb_srcinfo_provider();
  clr_module_data(data_id);
}

//--------------------------------------------------------------------------
//
//      PLUGIN DESCRIPTION BLOCK
//
//--------------------------------------------------------------------------
plugin_t PLUGIN =
{
  IDP_INTERFACE_VERSION,
  PLUGIN_MOD | PLUGIN_HIDE | PLUGIN_MULTI, // plugin flags:
  init,                 // initialize
  nullptr,              // terminate. this pointer may be nullptr.
  nullptr,              // invoke plugin

  // long comment about the plugin
  // it could appear in the status line
  // or as a hint
  "Load debug information from a PDB file",

  // multiline help about the plugin
  "PDB file loader\n"
  "\n"
  "This module allows you to load debug information about function names\n"
  "from a PDB file.\n"
  "\n"
  "The PDB file should be in the same directory as the input file\n",

  // the preferred short name of the plugin
  "Load PDB file (dbghelp 4.1+)",
  // the preferred hotkey to run the plugin
  ""
};


//lint -esym(766, md5.h, diskio.hpp) Unused header files.

```

`pdb.hpp`:

```hpp
//
// Copyright (c) 2005-2025 Hex-Rays SA <support@hex-rays.com>
// ALL RIGHTS RESERVED.
//
#pragma once
#include <idp.hpp>
#include <idd.hpp>
#include <typeinf.hpp>
#include "../../ldr/pe/pe.h"

#define PDB_NODE_NAME             "$ pdb"
#define PDB_DLLBASE_NODE_IDX       0
#define PDB_DLLNAME_NODE_IDX       0
#define PDB_LOADING_WIN32_DBG      1
#define PDB_TYPESONLY_NODE_IDX     2

enum pdb_callcode_t
{
  // user invoked 'load pdb' command, load pdb for the input file.
  // after invocation, result (boolean) is stored in: netnode(PDB_NODE_NAME).altval(PDB_DLLBASE_NODE_IDX)
  PDB_CC_USER = 0,
  // ida decided to call the plugin itself
  PDB_CC_IDA  = 1,
  // load additional pdb. This is semantically the same as
  // PDB_CC_USER (i.e., "File > Load file > PDB file..."), except
  // it won't ask the user for the data; rather it expects it in
  // netnode(PDB_NODE_NAME):
  //   load_addr: netnode(PDB_NODE_NAME).altval(PDB_DLLBASE_NODE_IDX)
  //   dll_name:  netnode(PDB_NODE_NAME).supstr(PDB_DLLNAME_NODE_IDX)
  PDB_CC_USER_WITH_DATA = 3,
  // load debug info from the COFF file
  // ida decided to call the plugin itself
  //   dbginfo_params_t: netnode(DBGINFO_PARAM_NODE_NAME).supval(DBGINFO_PARAMS_KEY)
  PDB_CC_IDA_COFF = 4,
};

//----------------------------------------------------------------------
struct pdb_signature_t
{
  uint32 guid[4]; // if all zeroes, then consider as non-existing
  uint32 sig;
  uint32 age;
  pdb_signature_t(void) { memset(this, 0, sizeof(*this)); }
};

//----------------------------------------------------------------------------
struct pdbargs_t
{
  qstring pdb_path;     // Path to PDB file.
  qstring input_path;   // Path to PE file with associated PDB.
  pdb_signature_t pdb_sign;
  qstring spath;
  ea_t loaded_base;
  void *user_data;
  uint32 flags;
#define PDBFLG_DBG_MODULE  0x0001
#define PDBFLG_LOAD_TYPES  0x0002
#define PDBFLG_EFD         0x0004
#define PDBFLG_COFF_FILE   0x0008
#define PDBFLG_LOAD_NAMES  0x0010
#define PDBFLG_IS_MINIPDB  0x0020
#define PDBFLG_USE_HTTP    0x0100

  pdbargs_t(void)
    : loaded_base(BADADDR),
      user_data(nullptr),
      flags(PDBFLG_LOAD_TYPES|PDBFLG_LOAD_NAMES)
  {}

  // If true, we are in a debugging session and the file specified by
  // input_path is an additional module that has been loaded by the
  // debugger itself.
  bool is_dbg_module(void) const
  {
    return (flags & PDBFLG_DBG_MODULE) != 0;
  }
  // PDB?
  bool is_pdbfile(void) const { return (flags & PDBFLG_COFF_FILE) == 0; }
  bool use_http() const { return (flags & PDBFLG_USE_HTTP) != 0; }

  const char *fname(void) const
  {
    return !pdb_path.empty() ? pdb_path.begin() : input_path.c_str();
  }
};

//----------------------------------------------------------------------------
struct pdb_ctx_t : public plugmod_t, public event_listener_t
{
  qstring full_sympath; // PDB search path (in _NT_SYMBOL_PATH format)
  peheader_t pe;

  // config options
  int  pdb_remote_port = DEBUGGER_PORT_NUMBER;
  int  pdb_remote_port_64 = -1;
  qstring pdb_remote_server;
  qstring pdb_remote_passwd;
#define PDB_PROVIDER_MSDIA  1   // use MSDIA local/remote provider
#define PDB_PROVIDER_PDBIDA 2   // use PDBIDA provider
  uint pdb_provider = PDB_PROVIDER_MSDIA;
#define PDB_NETWORK_OFF 0   // local directories search only
#define PDB_NETWORK_PE  1   // local directories search for COFF, full search for PE
#define PDB_NETWORK_ON  2   // no restrictions
  uint pdb_network = PDB_NETWORK_PE;
  bool use_http(bool is_pe) const
  {
    bool ok = pdb_network == PDB_NETWORK_PE && is_pe
           || pdb_network == PDB_NETWORK_ON;
    deb(IDA_DEBUG_DBGINFO, ok ? "PDB: symbol servers will be used\n"
                              : "PDB: local directories search only\n");
    return ok;
  }

  // Plugin options
  uint opt_provider = 0;
  // -1 don't specified
  // 0  set PDB_FALLBACK to false
  // 1  set PDB_FALLBACK to true
  bool opt_fallback = -1;

  using namelist_t = std::map<ea_t, qstring>;
  namelist_t namelist;

  // srcinfo provider
  class pdb_provider_t *pdb_srcinfo_provider = nullptr;

  pdb_ctx_t();
  virtual ~pdb_ctx_t();
  virtual bool idaapi run(size_t arg) override;
  virtual ssize_t idaapi on_event(ssize_t code, va_list va) override;

  void parse_options(bool *opt_skip);

  void init_sympaths();
  void load_vc_til(void) const;

  // maybe_func: -1:no, 0-maybe, 1-yes, 2:no,but iscode
  bool apply_name_in_idb(ea_t ea, const qstring &name, int maybe_func, uint32 the_machine_type);
  bool apply_debug_info(pdbargs_t &pdbargs);

  // printable register name
  bool get_pdb_register_info(int *p_reg, uint64 *p_mask, int machine, int reg);

  // Because we need to be able to call the 'old' pdb plugin
  // code, which knows nothing about the til_builder_t (and
  // thus its 'machine_type' field, and also because, at the
  // very time we call the old pdb code, our til_builder_t
  // instance will have been long forgotten and destroyed,
  // we must keep this machine type information somewhere.
  uint32 g_machine_type = 0;  // will be set to CV_CFL_80386 in ctor

private:
  //-------------------------------------------------------------------------
  int utf16_encidx = -1;
  int get_utf16_encoding_idx();

  bool checked_types = false;
  bool has_sid       = false;
  bool check_for_ids(ea_t ea, const char *name);

  void alloc_pdb_srcinfo_provider();
  void free_pdb_srcinfo_provider();

public:
  //-------------------------------------------------------------------------
  //#define  CHECK_CREATED_TYPES
#ifdef CHECK_CREATED_TYPES
  struct type_to_check_t
  {
    // one of the following 3 will be valid:
    ea_t ea;
    int id;
    qstring name;

    // the type itself
    tinfo_t type;
  };

  qvector<type_to_check_t> types_to_check;
  int check_n = 0;

  void check_tinfo(ea_t ea, int id, const char *name, const tinfo_t &tif)
  {
    type_to_check_t &tc = types_to_check.push_back();
    tc.ea = ea;
    tc.id = id;
    tc.name = name;
    tc.type = tif;
  }

  void check_added_types(void)
  {
    for ( const auto &tc : types_to_check )
    {
      if ( !tc.type.is_correct() )
      {
        msg("%d: INCORRECT TYPE ", check_n);
        if ( !tc.name.empty() )
          msg("%s", tc.name.begin());
        else if ( tc.ea != BADADDR )
          msg("%a", tc.ea);
        else
          msg("#%d", tc.id);
        qstring res;
        tc.type.print(&res);
        msg(": %s\n", res.c_str());
        check_n++;
      }
    }
  }
#else
  inline void check_tinfo(ea_t,int,const char*,const tinfo_t &) {}
  inline void check_added_types(void) {}
#endif
};
extern int data_id;

```

`pdb.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7B123449-31A0-468F-9E7B-F24352345F61}</ProjectGuid>
    <RootNamespace>pdb</RootNamespace>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <GenerateManifest>true</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <AdditionalIncludeDirectories>$(VSInstallDir)\DIA SDK\include;..\..\include;.;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;__X64__;_CONSOLE;__NT__;__EA64__;__IDP__;MAXSTR=1024;DEBUGGER_SERVER;DEBUG_NETWORK0;__PLUGIN__;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <CallingConvention>StdCall</CallingConvention>
      <DisableSpecificWarnings>4800;4244;4996;4018;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <AdditionalOptions>/export:PLUGIN %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>diaguids.lib;wsock32.lib;ida.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(VSInstallDir)\DIA SDK\lib\amd64;..\..\lib\x64_win_vc_64</AdditionalLibraryDirectories>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <BaseAddress>0x0000000166C00000</BaseAddress>
    </Link>
    <PostBuildEvent />
    <PostBuildEvent>
      <Command>XCOPY /i /d /y $(TargetPath) "D:\Program Files\IDA Professional 9.2\plugins\"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalIncludeDirectories>$(VSInstallDir)\DIA SDK\include;..\..\include;.;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;__X64__;_CONSOLE;__NT__;__EA64__;__IDP__;MAXSTR=1024;DEBUGGER_SERVER;DEBUG_NETWORK0;__PLUGIN__;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <CallingConvention>StdCall</CallingConvention>
      <DisableSpecificWarnings>4800;4244;4996;4018;4068;4200;%(DisableSpecificWarnings)</DisableSpecificWarnings>
    </ClCompile>
    <Link>
      <AdditionalDependencies>diaguids.lib;wsock32.lib;ida.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(VSInstallDir)\DIA SDK\lib\amd64;..\..\lib\x64_win_vc_64</AdditionalLibraryDirectories>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <BaseAddress>0x0000000166C00000</BaseAddress>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
    </Link>
    <PostBuildEvent>
      <Command>XCOPY /i /d /y $(TargetPath) "D:\Program Files\IDA Professional 9.2\plugins\"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ProjectCapability Include="PackageReferences" />
  </ItemGroup>
  <PropertyGroup>
    <NuGetTargetMoniker Condition="'$(NuGetTargetMoniker)' == ''">native,Version=v0.0</NuGetTargetMoniker>
  </PropertyGroup>
  <ItemGroup>
    <ClInclude Include="cvadd.h" />
    <ClInclude Include="dia2_internal.h" />
    <ClInclude Include="Helpers.h" />
    <ClInclude Include="misc.h" />
    <ClInclude Include="msdia.hpp" />
    <ClInclude Include="oldpdb.h" />
    <ClInclude Include="pdb.hpp" />
    <ClInclude Include="pdbaccess.hpp" />
    <ClInclude Include="pdblocal.hpp" />
    <ClInclude Include="pdbremote.hpp" />
    <ClInclude Include="Program.h" />
    <ClInclude Include="sip.hpp" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="tilbuild.hpp" />
    <ClInclude Include="varser.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="common.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="Helpers.cpp" />
    <ClCompile Include="misc.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="msdia.cpp">
      <LanguageStandard Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdcpp17</LanguageStandard>
      <LanguageStandard Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdcpp17</LanguageStandard>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="old.cpp" />
    <ClCompile Include="pdb.cpp" />
    <ClCompile Include="pdblocal.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="pdbremote.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="Program.cpp" />
    <ClCompile Include="sip.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="stdafx.cpp" />
    <ClCompile Include="tilbuild.cpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="makefile" />
    <None Include="pdb.cfg" />
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Native">
      <Version>3.14.2075</Version>
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
</Project>
```

`pdb.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="misc">
      <UniqueIdentifier>{1e48c0cc-48b0-401f-a50c-c37324e594b9}</UniqueIdentifier>
    </Filter>
    <Filter Include="pdb">
      <UniqueIdentifier>{cdbcd796-682a-421a-9bf1-87cd59ddb335}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="oldpdb.h">
      <Filter>misc</Filter>
    </ClInclude>
    <ClInclude Include="msdia.hpp" />
    <ClInclude Include="pdb.hpp" />
    <ClInclude Include="pdbaccess.hpp" />
    <ClInclude Include="pdblocal.hpp" />
    <ClInclude Include="pdbremote.hpp" />
    <ClInclude Include="sip.hpp" />
    <ClInclude Include="tilbuild.hpp" />
    <ClInclude Include="varser.hpp" />
    <ClInclude Include="dia2_internal.h">
      <Filter>pdb</Filter>
    </ClInclude>
    <ClInclude Include="Helpers.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="Program.h" />
    <ClInclude Include="misc.h" />
    <ClInclude Include="cvadd.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="common.cpp">
      <Filter>pdb</Filter>
    </ClCompile>
    <ClCompile Include="old.cpp">
      <Filter>pdb</Filter>
    </ClCompile>
    <ClCompile Include="pdb.cpp">
      <Filter>pdb</Filter>
    </ClCompile>
    <ClCompile Include="misc.cpp" />
    <ClCompile Include="pdblocal.cpp" />
    <ClCompile Include="pdbremote.cpp" />
    <ClCompile Include="sip.cpp" />
    <ClCompile Include="tilbuild.cpp" />
    <ClCompile Include="msdia.cpp" />
    <ClCompile Include="Helpers.cpp" />
    <ClCompile Include="Program.cpp" />
    <ClCompile Include="stdafx.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="makefile">
      <Filter>pdb</Filter>
    </None>
    <None Include="pdb.cfg" />
  </ItemGroup>
</Project>
```

`pdb_vs201x.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36327.8 d17.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pdb", "pdb.vcxproj", "{7B123449-31A0-468F-9E7B-F24352345F61}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7B123449-31A0-468F-9E7B-F24352345F61}.Debug|x64.ActiveCfg = Debug|x64
		{7B123449-31A0-468F-9E7B-F24352345F61}.Debug|x64.Build.0 = Debug|x64
		{7B123449-31A0-468F-9E7B-F24352345F61}.Release|x64.ActiveCfg = Release|x64
		{7B123449-31A0-468F-9E7B-F24352345F61}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {2F3D74FA-9460-4C39-B74A-07C6C06C4001}
	EndGlobalSection
EndGlobal

```

`pdbaccess.hpp`:

```hpp


#ifndef PDBACCESS__H
#define PDBACCESS__H

#include <pro.h>
#include "cvconst.h"
#include "cvadd.h"

#ifdef __NT__
#include <windows.h>
#include <oaidl.h>
#include "dia2.h"
#else
// FIXME: It'd be good if those windows declarations for non-windows
// systems were somewhere else than in the PE loader.
#include "../../ldr/pe/mycor.h"
#endif
#include "pdb.hpp"

//----------------------------------------------------------------------------
class pdb_access_t;
class local_pdb_access_t;
class remote_pdb_access_t;

struct pdb_exception_t
{
  pdb_exception_t(const qstring &_what) : what(_what) {}
  qstring what;
};

//----------------------------------------------------------------------------
#ifdef __NT__
enum sym_token_t : uint64
#else
enum sym_token_t
#endif
{
  t_start                     = 1 << 0,
  // bool
  t_bool_start                = t_start,
  t_constType                 = t_bool_start,
  t_isStatic                  = 1 << 1,
  t_virtual                   = 1 << 2,
  t_volatileType              = 1 << 3,
  t_code                      = 1 << 4,
  t_hasAssignmentOperator     = 1 << 5,
  t_hasCastOperator           = 1 << 6,
  t_function                  = 1 << 7, // FIXME!
  t_constructor               = 1 << 8,
  t_isVirtualBaseClass        = 1 << 9,
  t_bool_end                  = t_isVirtualBaseClass,

  // dword
  t_dword_start               = 1 << 10,
  t_backEndMajor              = t_dword_start,
  t_baseType                  = 1 << 11,
  t_bitPosition               = 1 << 12,
  t_callingConvention         = 1 << 13,
  t_count                     = 1 << 14,
  t_dataKind                  = 1 << 15,
  t_locationType              = 1 << 16,
  t_registerId                = 1 << 17,
  t_relativeVirtualAddress    = 1 << 18,
  t_symIndexId                = 1 << 19,
  t_symTag                    = 1 << 20,
  t_udtKind                   = 1 << 21,
  t_virtualBaseOffset         = 1 << 22,
  t_machineType               = 1 << 23,
  t_classParentId             = 1 << 24,
  t_typeId                    = 1 << 25,
  t_lexicalParentId           = 1 << 26,
  t_dword_end                 = t_lexicalParentId,

  // dword64
  t_dword64_start             = 1 << 27,
  t_length                    = t_dword64_start,
  t_dword64_end               = t_length,

  // string
  t_string_start              = 1 << 28,
  t_name                      = t_string_start,
  t_string_end                = t_name,

  // long
  t_long_start                = 1 << 29,
  t_offset                    = t_long_start,
  t_long_end                  = t_offset,

  // ulonglong
  t_ulonglong_start           = 1 << 30,
  t_virtualAddress            = t_ulonglong_start,
  t_ulonglong_end             = t_virtualAddress,

  // variant
  t_variant_start             = 1ULL << 31,
  t_value                     = t_variant_start,
  t_variant_end               = t_value,

  t_end                       = 1ULL << 32,
};
CASSERT(sizeof(sym_token_t) == 8);

inline bool is_sym_token_bool(sym_token_t t) { return t >= t_bool_start && t <= t_bool_end; }
inline bool is_sym_token_dword(sym_token_t t) { return t >= t_dword_start && t <= t_dword_end; }
inline bool is_sym_token_dword64(sym_token_t t) { return t >= t_dword64_start && t <= t_dword64_end; }
// inline bool is_sym_token_pdb_sym(sym_token_t t) { return t >= t_pdb_sym_start && t <= t_pdb_sym_end; }
inline bool is_sym_token_string(sym_token_t t) { return t >= t_string_start && t <= t_string_end; }
inline bool is_sym_token_long(sym_token_t t) { return t >= t_long_start && t <= t_long_end; }
inline bool is_sym_token_ulonglong(sym_token_t t) { return t >= t_ulonglong_start && t <= t_ulonglong_end; }
inline bool is_sym_token_variant(sym_token_t t) { return t >= t_variant_start && t <= t_variant_end; }


typedef uint64 token_mask_t;
#define TOKEN_MASK_FULL token_mask_t(-1)

//----------------------------------------------------------------------------
// engine PDB symbol implementation identity
enum pdb_sym_id_t
{
  DIA_PDB_SYM,
  REMOTE_PDB_SYM,
  OWN_PDB_SYM,
};

//----------------------------------------------------------------------------
struct pdb_sym_t
{
  virtual HRESULT get_backEndMajor(DWORD *out) = 0;
  virtual HRESULT get_baseType(DWORD *out) = 0;
  virtual HRESULT get_bitPosition(DWORD *out) = 0;
  virtual HRESULT get_callingConvention(DWORD *out) = 0;
  virtual HRESULT get_code(BOOL *out) = 0;
  virtual HRESULT get_constructor(BOOL *out) = 0;   // Retrieves a flag that specifies whether the user-defined data type has a constructor or destructor.
  virtual HRESULT get_isVirtualBaseClass(BOOL *out) = 0;
  virtual HRESULT get_constType(BOOL *out) = 0;
  virtual HRESULT get_count(DWORD *out) = 0;
  virtual HRESULT get_dataKind(DWORD *out) = 0;
  virtual HRESULT get_function(BOOL *out) = 0;
  virtual HRESULT get_hasAssignmentOperator(BOOL *out) = 0;
  virtual HRESULT get_hasCastOperator(BOOL *out) = 0;
  virtual HRESULT get_isStatic(BOOL *out) = 0;
  virtual HRESULT get_length(DWORD64 *out) = 0;
  virtual HRESULT get_lexicalParent(pdb_sym_t *out) = 0;
  virtual HRESULT get_locationType(DWORD *out) = 0;
  virtual HRESULT get_machineType(DWORD *out) = 0;
  virtual HRESULT get_name(qstring *out) = 0;
  virtual HRESULT get_offset(LONG *out) = 0;
  virtual HRESULT get_registerId(DWORD *out) = 0;
  virtual HRESULT get_relativeVirtualAddress(DWORD *out) = 0;
  virtual HRESULT get_symIndexId(DWORD *out) = 0;
  virtual HRESULT get_symTag(DWORD *out) = 0;
  virtual HRESULT get_udtKind(DWORD *out) = 0;
  virtual HRESULT get_value(VARIANT *out) = 0;
  virtual HRESULT get_virtual(BOOL *out) = 0;
  virtual HRESULT get_virtualAddress(ULONGLONG *out) = 0;
  virtual HRESULT get_virtualBaseOffset(DWORD *out) = 0;
  virtual HRESULT get_volatileType(BOOL *out) = 0;
  // Be very, very careful to _not_ use classParent if you can avoid it:
  // In case the symbol was *not* resolved through get_type(), the link
  // to the parent might be lost, and a bug in the DIA SDK will
  // return S_FALSE.
  virtual HRESULT get_classParent(pdb_sym_t *out) = 0;
  virtual HRESULT get_type(pdb_sym_t *out) = 0;
  //------------------------------------------------------------
  virtual HRESULT get_ordinal(DWORD *pRetVal) = 0;

  // careful with this!
  virtual void steal_data(pdb_sym_t &other) = 0;

  virtual pdb_sym_id_t whoami(void) = 0;
  virtual bool empty(void) = 0;

  virtual ~pdb_sym_t() {}

  // Declare, but ***don't*** define: we don't want
  // that to happen, and thus we'll have a linker
  // error if that would happen in the code.
  DECLARE_UNCOPYABLE(pdb_sym_t);

protected:
  pdb_sym_t() {}
};
DECLARE_TYPE_AS_MOVABLE(pdb_sym_t);

typedef std::unique_ptr<pdb_sym_t> pdb_sym_janitor_t;

//----------------------------------------------------------------------------
enum packing_info_t
{
  SYMDAT_PACKED = 1,
  SYMDAT_UNPACKED
};

//----------------------------------------------------------------------------
struct sym_data_t
{
  sym_data_t(token_mask_t _tokens, const uchar *buf, size_t bufsize, packing_info_t _packing, bool *_warned);
  ~sym_data_t();

  DWORD get_id() const
  {
    DWORD id;
    if ( get_dword(t_symIndexId, &id) != S_OK )
      INTERR(30211);
    return id;
  }
  HRESULT get_bool(sym_token_t token, BOOL *out) const;
  HRESULT get_dword(sym_token_t token, DWORD *out) const;
  HRESULT get_dword64(sym_token_t token, DWORD64 *out) const;
  HRESULT get_pdb_sym(sym_token_t token, pdb_sym_t *out) const;
  HRESULT get_string(sym_token_t token, qstring *out) const;
  HRESULT get_dword(sym_token_t token, LONG *out) const;
  HRESULT get_ulonglong(sym_token_t token, ULONGLONG *out) const;
  HRESULT get_variant(sym_token_t token, VARIANT *out) const;

private:
  sym_data_t();

  bool token_present(sym_token_t token) const
  {
    return (present & token) == token;
  }

  void assert_token(sym_token_t token) const
  {
    if ( !token_present(token) )
      INTERR(30210);
  }

  const BOOL *bool_ptr(sym_token_t token) const
  {
    return (const BOOL *)any_ptr(token, t_bool_start, t_bool_end);
  }

  const DWORD *dword_ptr(sym_token_t token) const
  {
    return (const DWORD *)any_ptr(token, t_dword_start, t_dword_end);
  }

  const DWORD64 *dword64_ptr(sym_token_t token) const
  {
    return (const DWORD64 *)any_ptr(token, t_dword64_start, t_dword64_end);
  }

  const LONG *long_ptr(sym_token_t token) const
  {
    return (const LONG *)any_ptr(token, t_long_start, t_long_end);
  }

  const ULONGLONG *uint64_ptr(sym_token_t token) const
  {
    return (const ULONGLONG *)any_ptr(token, t_ulonglong_start, t_ulonglong_end);
  }

  const char **string_ptr(sym_token_t token) const
  {
    return (const char **)any_ptr(token, t_string_start, t_string_end);
  }

  const VARIANT *variant_ptr(sym_token_t token) const
  {
    return (const VARIANT *)any_ptr(token, t_variant_start, t_variant_end);
  }

  enum type_t
  {
    t_bool = 0,
    t_dword,
    t_dword64,
    t_string,
    t_long,
    t_ulonglong,
    t_variant,
    t_max
  };

  static const uint32 sizes[];

  const void *any_ptr(sym_token_t token, sym_token_t start, sym_token_t end) const;

  token_mask_t present; // The tokens that are present in this instance.
  bytevec_t data;
  uint8 counters[t_max];

  struct children_t
  {
    DWORD *ids;
    uint32 cnt;
  };
  children_t children_infos[SymTagMax];
  friend class remote_pdb_access_t; // accesses children_infos directly
  bool *warned;
};


//----------------------------------------------------------------------------
#ifdef __NT__
struct dia_pdb_sym_t : public pdb_sym_t
{
  dia_pdb_sym_t(pdb_access_t *_pdb_access, IDiaSymbol *_data, bool _own_sym)
    : pdb_access(_pdb_access),
      data(_data),
      own_sym(_own_sym)
  {}

  ~dia_pdb_sym_t()
  {
    if ( data != nullptr && own_sym )
    {
      data->Release();
      data = nullptr;
    }
    pdb_access = nullptr;
  }

  pdb_access_t *pdb_access;
  IDiaSymbol *data;
  bool own_sym;

  pdb_sym_id_t whoami(void) { return DIA_PDB_SYM; }
  void set_symbol_data(IDiaSymbol *s, bool own)
  {
    data    = s;
    own_sym = own;
  }
  bool empty(void) { return data == nullptr; }

  HRESULT get_backEndMajor(DWORD *out)            { return data->get_backEndMajor(out); }
  HRESULT get_baseType(DWORD *out)                { return data->get_baseType(out); }
  HRESULT get_bitPosition(DWORD *out)             { return data->get_bitPosition(out); }
  HRESULT get_callingConvention(DWORD *out)       { return data->get_callingConvention(out); }
  HRESULT get_code(BOOL *out)                     { return data->get_code(out); }
  HRESULT get_constType(BOOL *out)                { return data->get_constType(out); }
  HRESULT get_count(DWORD *out)                   { return data->get_count(out); }
  HRESULT get_constructor(BOOL *out)              { return data->get_constructor(out); }
  HRESULT get_isVirtualBaseClass(BOOL *out)       { return data->get_virtualBaseClass(out); }
  HRESULT get_dataKind(DWORD *out)                { return data->get_dataKind(out); }
  HRESULT get_function(BOOL *out)                 { return data->get_function(out); }
  HRESULT get_hasAssignmentOperator(BOOL *out)    { return data->get_hasAssignmentOperator(out); }
  HRESULT get_hasCastOperator(BOOL *out)          { return data->get_hasCastOperator(out); }
  HRESULT get_isStatic(BOOL *out)                 { return data->get_isStatic(out); }
  HRESULT get_length(DWORD64 *out)                { return data->get_length(out); }
  HRESULT get_lexicalParent(pdb_sym_t *out)
  {
    IDiaSymbol *t;
    HRESULT res = data->get_lexicalParent(&t);
    return handle_related_symbol(res, t, out);
  }
  HRESULT get_locationType(DWORD *out)            { return data->get_locationType(out); }
  HRESULT get_machineType(DWORD *out)             { return data->get_machineType(out); }
  HRESULT get_name(qstring *out)
  {
    BSTR name;
    HRESULT hr = data->get_name(&name);
    return maybe_convert_bstr(out, hr, &name);
  }
  HRESULT get_offset(LONG *out)                   { return data->get_offset(out); }
  HRESULT get_registerId(DWORD *out)              { return data->get_registerId(out); }
  HRESULT get_relativeVirtualAddress(DWORD *out)  { return data->get_relativeVirtualAddress(out); }
  HRESULT get_symIndexId(DWORD *out)              { return data->get_symIndexId(out); }
  HRESULT get_symTag(DWORD *out)                  { return data->get_symTag(out); }
  HRESULT get_udtKind(DWORD *out)                 { return data->get_udtKind(out); }
  HRESULT get_value(VARIANT *out)                 { return data->get_value(out); }
  HRESULT get_virtual(BOOL *out)                  { return data->get_virtual(out); }
  HRESULT get_virtualAddress(ULONGLONG *out)      { return data->get_virtualAddress(out); }
  HRESULT get_virtualBaseOffset(DWORD *out)       { return data->get_virtualBaseOffset(out); }
  HRESULT get_volatileType(BOOL *out)             { return data->get_volatileType(out); }
  HRESULT get_classParent(pdb_sym_t *out)
  {
    IDiaSymbol *t;
    HRESULT res = data->get_classParent(&t);
    return handle_related_symbol(res, t, out);
  }

  HRESULT get_type(pdb_sym_t *out)
  {
    IDiaSymbol *t;
    HRESULT res = data->get_type(&t);
    return handle_related_symbol(res, t, out);
  }

  //------------------------------------------------------------
  virtual HRESULT get_ordinal(DWORD *) override { return S_FALSE; }

  HRESULT handle_related_symbol(HRESULT fetch_success, IDiaSymbol *t, pdb_sym_t *out)
  {
    if ( out == nullptr )
      return S_FALSE;
    QASSERT(30545, out->whoami() == DIA_PDB_SYM);
    dia_pdb_sym_t *sym = (dia_pdb_sym_t *)out;
    sym->set_symbol_data(fetch_success == S_OK ? t : nullptr, true);
    return fetch_success;
  }

  // careful with this!
  void steal_data(pdb_sym_t &other)
  {
    QASSERT(30541, whoami() == other.whoami());
    dia_pdb_sym_t &other_dia = (dia_pdb_sym_t &)other;
    QASSERT(30503, other_dia.own_sym && other_dia.data != nullptr && data == nullptr);
    data = other_dia.data;
    own_sym = true;
    other_dia.own_sym = false;
    other_dia.data = nullptr;
  }

private:
  dia_pdb_sym_t();

  HRESULT maybe_convert_bstr(qstring *out, HRESULT hr, BSTR *s)
  {
    if ( hr == S_OK )
    {
      utf16_utf8(out, *s);
      SysFreeString(*s);
    }
    return hr;
  }
};
DECLARE_TYPE_AS_MOVABLE(dia_pdb_sym_t);

//----------------------------------------------------------------------------
#else   // __NT__
struct remote_pdb_sym_t : public pdb_sym_t
{
  remote_pdb_sym_t(pdb_access_t *_pdb_access, sym_data_t *_data)
    : pdb_access(_pdb_access),
      data(_data)
  {}

  ~remote_pdb_sym_t()
  {
    data = nullptr;
    pdb_access = nullptr;
  }

  void set_symbol_data(sym_data_t *s) { data = s; }

  HRESULT get_backEndMajor(DWORD *out) override           { return data->get_dword(t_backEndMajor, out); }
  HRESULT get_baseType(DWORD *out) override               { return data->get_dword(t_baseType, out); }
  HRESULT get_bitPosition(DWORD *out) override            { return data->get_dword(t_bitPosition, out); }
  HRESULT get_callingConvention(DWORD *out) override      { return data->get_dword(t_callingConvention, out); }
  HRESULT get_code(BOOL *out) override                    { return data->get_bool(t_code, out); }
  HRESULT get_constructor(BOOL *out) override             { return data->get_bool(t_constructor, out); }
  HRESULT get_isVirtualBaseClass(BOOL *out) override      { return data->get_bool(t_isVirtualBaseClass, out); }
  HRESULT get_constType(BOOL *out) override               { return data->get_bool(t_constType, out); }
  HRESULT get_count(DWORD *out) override                  { return data->get_dword(t_count, out); }
  HRESULT get_dataKind(DWORD *out) override               { return data->get_dword(t_dataKind, out); }
  HRESULT get_function(BOOL *out) override                { return data->get_bool(t_function, out); }
  HRESULT get_hasAssignmentOperator(BOOL *out) override   { return data->get_bool(t_hasAssignmentOperator, out); }
  HRESULT get_hasCastOperator(BOOL *out) override         { return data->get_bool(t_hasCastOperator, out); }
  HRESULT get_isStatic(BOOL *out) override                { return data->get_bool(t_isStatic, out); }
  HRESULT get_length(DWORD64 *out) override               { return data->get_dword64(t_length, out); }
  HRESULT get_lexicalParent(pdb_sym_t *out) override;
  HRESULT get_locationType(DWORD *out) override           { return data->get_dword(t_locationType, out); }
  HRESULT get_machineType(DWORD *out) override            { return data->get_dword(t_machineType, out); }
  HRESULT get_name(qstring *out) override                 { return data->get_string(t_name, out); }
  HRESULT get_offset(LONG *out) override                  { return data->get_dword(t_offset, out); }
  HRESULT get_registerId(DWORD *out) override             { return data->get_dword(t_registerId, out); }
  HRESULT get_relativeVirtualAddress(DWORD *out) override { return data->get_dword(t_relativeVirtualAddress, out); }
  HRESULT get_symIndexId(DWORD *out) override             { return data->get_dword(t_symIndexId, out); }
  HRESULT get_symTag(DWORD *out) override                 { return data->get_dword(t_symTag, out); }
  HRESULT get_udtKind(DWORD *out) override                { return data->get_dword(t_udtKind, out); }
  HRESULT get_value(VARIANT *out) override                { return data->get_variant(t_value, out); }
  HRESULT get_virtual(BOOL *out) override                 { return data->get_bool(t_virtual, out); }
  HRESULT get_virtualAddress(ULONGLONG *out) override     { return data->get_ulonglong(t_virtualAddress, out); }
  HRESULT get_virtualBaseOffset(DWORD *out) override      { return data->get_dword(t_virtualBaseOffset, out); }
  HRESULT get_volatileType(BOOL *out) override            { return data->get_bool(t_volatileType, out); }
  HRESULT get_classParent(pdb_sym_t *out) override;
  HRESULT get_type(pdb_sym_t *out) override;
  //------------------------------------------------------------
  virtual HRESULT get_ordinal(DWORD *) override { return S_FALSE; }

  // careful with this!
  void steal_data(pdb_sym_t &other) override
  {
    QASSERT(30542, whoami() == other.whoami());
    remote_pdb_sym_t &other_rem = (remote_pdb_sym_t &)other;
    QASSERT(30492, other_rem.data != nullptr && data == nullptr);
    data = other_rem.data;
    // we don't want to set 'other.data = nullptr', because in remote access,
    // the pdb_sym_t doesn't actually own the data anyway: it's part of
    // the cache.
  }

  pdb_sym_id_t whoami(void) override { return REMOTE_PDB_SYM; }
  bool empty(void) override          { return data == nullptr; }

  pdb_access_t *pdb_access;
  sym_data_t *data;

private:
  remote_pdb_sym_t();
};
DECLARE_TYPE_AS_MOVABLE(remote_pdb_sym_t);
#endif // !__NT__

//----------------------------------------------------------------------------
#define BAD_MACHINE_TYPE ((uint32) -1)

#define BADSYM ((uint32) -1)

//-------------------------------------------------------------------------
struct pdb_lnnum_t
{
  pdb_lnnum_t()
    : va(BADADDR), length(0),
      columnNumber(0), columnNumberEnd(0),
      lineNumber(0), lineNumberEnd(0),
      file_id(DWORD(-1)), statement(0) {}
  ULONGLONG va;
  DWORD length;
  DWORD columnNumber;
  DWORD columnNumberEnd;
  DWORD lineNumber;
  DWORD lineNumberEnd;
  DWORD file_id;
  BOOL statement;
};

//--------------------------------------------------------------------------
typedef qvector<pdb_lnnum_t> pdb_lnnum_vec_t;
typedef std::map<int, pdb_lnnum_vec_t> lnmap_t;

//-------------------------------------------------------------------------
struct pdb_lnnums_t : pdb_lnnum_vec_t
{
  pdb_lnnums_t() : inited(false) {}

  bool get_item_bounds(rangeset_t *set) const;
  int get_lnnum() const;
  int get_colnum() const;
  int get_end_lnnum() const;
  int get_end_colnum() const;

  bool inited;
};

//----------------------------------------------------------------------------
class pdb_access_t
{
public:
  pdb_access_t(const pdbargs_t &args)
    : pdbargs(args),
      machine_type((uint32) -1),
      dia_version(0),
      base_address(BADADDR),
      global_sym_id(BADSYM)
  {
  }
  virtual ~pdb_access_t() {}

  //----------------------------------------------------------------------
  struct children_visitor_t
  {
    children_visitor_t()
      : parent(nullptr) {}

    virtual HRESULT visit_child(pdb_sym_t &child) = 0;
    virtual ~children_visitor_t() {}

    pdb_sym_t *parent;
  };

  //-------------------------------------------------------------------------
  struct dummy_visitor_t : public children_visitor_t
  {
    virtual HRESULT visit_child(pdb_sym_t &) override { return S_OK; }
  };

  //----------------------------------------------------------------------------
  HRESULT iterate_children(
          pdb_sym_t &sym,
          enum SymTagEnum type,
          children_visitor_t &visitor);

  //----------------------------------------------------------------------------
  virtual HRESULT do_iterate_children(
        pdb_sym_t &sym,
        enum SymTagEnum type,
        children_visitor_t &visitor) = 0;
  virtual HRESULT iterate_subtags(
        pdb_sym_t &sym,
        enum SymTagEnum type,
        children_visitor_t &visitor);
  virtual HRESULT load(pdb_sym_t &sym, DWORD id) = 0;

  // source-level debugging-specific
  virtual HRESULT sip_retrieve_lines_by_va(
        pdb_lnnums_t *out,
        ULONGLONG va,
        ULONGLONG length) = 0;
  virtual HRESULT sip_retrieve_lines_by_coords(
        pdb_lnnums_t *out,
        DWORD file_id,
        int lnnum,
        int colnum) = 0;
  virtual HRESULT sip_iterate_symbols_at_ea(
        ULONGLONG va,
        ULONGLONG size,
        enum SymTagEnum tag,
        children_visitor_t &visitor) = 0;
  virtual HRESULT sip_iterate_file_compilands(
        DWORD file_id,
        children_visitor_t &visitor) = 0;
  virtual HRESULT sip_retrieve_file_path(
        qstring *out,
        qstring *errbuf,
        DWORD file_id) = 0;
  virtual HRESULT sip_retrieve_symbol_files(
        qvector<DWORD> *out,
        pdb_sym_t &sym) = 0;
  virtual HRESULT sip_find_files(
        qvector<DWORD> *out,
        const char *filename) = 0; // case insensitive search
  // /source-level debugging-specific

  //----------------------------------------------------------------------------
  virtual DWORD  get_global_symbol_id() const { return global_sym_id; }
  virtual ea_t   get_base_address()     const { return base_address; }
  virtual uint32 get_machine_type()     const { return machine_type; }
  virtual int    get_dia_version()      const { return dia_version; }

  void set_global_symbol_id(DWORD _global_sym_id) { global_sym_id = _global_sym_id; }
  void set_machine_type(uint32 _machine_type)     { machine_type  = _machine_type; }
  void set_base_address(ea_t _base_address)       { base_address  = _base_address; }
  void set_dia_version(int _dia_version)          { dia_version   = _dia_version; }

  //----------------------------------------------------------------------------
  virtual pdb_sym_t *create_sym(void *data=nullptr, bool own=false) = 0;
  pdb_sym_t *create_sym(DWORD sym_id)
  {
    pdb_sym_t *sym = create_sym();
    if ( load(*sym, sym_id) != S_OK )
    {
      qstring err;
      err.sprnt("Failed loading symbol data for ID %u", sym_id);
      delete sym;
      throw pdb_exception_t(err.c_str());
    }
    return sym;
  }

  //----------------------------------------------------------------------------
  const pdbargs_t &pdbargs;

private:
  uint32 machine_type;
  int dia_version;
  ea_t base_address;
  DWORD global_sym_id;
  DECLARE_UNCOPYABLE(pdb_access_t)
};


#endif // PDBACCESS__H

```

`pdblocal.cpp`:

```cpp

//----------------------------------------------------------------------------
template <typename T>
struct dia_ptr_t
{
  dia_ptr_t() : thing(nullptr) {}

  ~dia_ptr_t()
  {
    if ( thing != nullptr )
      thing->Release();
  }

  T *thing;
};

//----------------------------------------------------------------------------
HRESULT local_pdb_access_t::_do_iterate_symbols_enumerator(
        IDiaEnumSymbols *sym_enum,
        children_visitor_t &visitor)
{
  std::set<DWORD> seen;
  HRESULT hr = S_OK;
  while ( true )
  {
    ULONG celt = 0;
    IDiaSymbol *pChild = nullptr;
    hr = sym_enum->Next(1, &pChild, &celt);
    if ( FAILED(hr) || celt != 1 )
    {
      hr = S_OK; // end of enumeration
      break;
    }
    pdb_sym_t *child = create_sym(pChild, true);
    pdb_sym_janitor_t janitor_pType(child);
    DWORD sym_id;
    hr = child->get_symIndexId(&sym_id);
    if ( hr != S_OK )
      break;
    // It seems we can, in some cases, iterate over the
    // same child more than once.
    // Fortunately, it appears to be the same symbol data;
    // and not another symbol w/ the same ID
    // See also: sip_iterate_symbols_at_ea()
    if ( seen.insert(sym_id).second )
    {
      hr = visitor.visit_child(*child);
      if ( FAILED(hr) )
        break;
    }
  }

  return hr;
}

//----------------------------------------------------------------------------
HRESULT local_pdb_access_t::safe_iterate_children(
        pdb_sym_t &sym,
        enum SymTagEnum type,
        children_visitor_t &visitor)
{
  HRESULT hr = E_FAIL;
  IDiaEnumSymbols *pEnumSymbols;
  try
  {
    QASSERT(30536, sym.whoami() == DIA_PDB_SYM);
    dia_pdb_sym_t &diasym = (dia_pdb_sym_t &)sym;
    hr = dia_session->findChildren(diasym.data, type, nullptr, nsNone, &pEnumSymbols);
    if ( hr == S_OK )
    {
      hr = _do_iterate_symbols_enumerator(pEnumSymbols, visitor);
      pEnumSymbols->Release();
    }
  }
  catch ( const std::bad_alloc & )
  {
    // try to free some memory before quitting (and saving the idb)
    delete this;
    nomem("pdb");
  }
  catch ( const std::exception &e )
  {
    error("Unhandled C++ exception: %s", e.what());
  }
  catch ( ... )
  {
    error("Unhandled C++ exception!");
  }
  return hr;
}

//----------------------------------------------------------------------------
HRESULT local_pdb_access_t::do_iterate_children(
        pdb_sym_t &sym,
        enum SymTagEnum type,
        children_visitor_t &visitor)
{
  int code;
  HRESULT hr = E_FAIL;
  __try
  {
    hr = safe_iterate_children(sym, type, visitor);
  }
  __except ( code=GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER )
  {
    // complain to the user
    ask_for_feedback(
            "%s: %s\n"
            "Is the corresponding PDB file valid?",
            pdbargs.input_path.c_str(),
            winerr(code));

    // we may arrive here because we ran out of memory
    // try to free some memory before quitting (and saving the idb)
    delete this;
    error(nullptr); // and die... this will save the idb
  }
  return hr;
}

//----------------------------------------------------------------------------
HRESULT local_pdb_access_t::load(pdb_sym_t &pdbsym, DWORD id)
{
  IDiaSymbol *dia_sym;
  HRESULT hr = dia_session->symbolById(id, &dia_sym);
  if ( hr == S_OK )
  {
    QASSERT(30543, pdbsym.whoami() == DIA_PDB_SYM);
    dia_pdb_sym_t &sym = (dia_pdb_sym_t &)pdbsym;
    sym.set_symbol_data(dia_sym, true);
  }
  return hr;
}

//-------------------------------------------------------------------------
HRESULT local_pdb_access_t::_copy_line_numbers(
        pdb_lnnums_t *out,
        IDiaEnumLineNumbers *enumerator) const
{
  LONG count = 0;
  HRESULT hr = enumerator->get_Count(&count);
  if ( hr == S_OK )
  {
    IDiaLineNumber *lines[64];
    ULONG got = 0;
    for ( LONG i=0; i < count; i += got )
    {
      // Fetch many line number information at once
      enumerator->Next(qnumber(lines), lines, &got);
      if ( got == 0 )
        break;

      for ( ULONG j=0; j < got; j++ )
      {
        IDiaLineNumber *l = lines[j];
        pdb_lnnum_t &lo = out->push_back();
        l->get_virtualAddress(&lo.va);
        l->get_length(&lo.length);
        l->get_columnNumber(&lo.columnNumber);
        l->get_columnNumberEnd(&lo.columnNumberEnd);
        l->get_lineNumber(&lo.lineNumber);
        l->get_lineNumberEnd(&lo.lineNumberEnd);
        l->get_statement(&lo.statement);
        IDiaSourceFile *f = nullptr;
        if ( l->get_sourceFile(&f) == S_OK )
        {
          f->get_uniqueId(&lo.file_id);
          f->Release();
        }
        lines[j]->Release();
      }
    }
  }
  return hr;
}

//-------------------------------------------------------------------------
HRESULT local_pdb_access_t::sip_retrieve_lines_by_va(
        pdb_lnnums_t *out,
        ULONGLONG va,
        ULONGLONG length)
{
  dia_ptr_t<IDiaEnumLineNumbers> pEnumLineNumbers;
  HRESULT hr = dia_session->findLinesByVA(va, length, &pEnumLineNumbers.thing);
  if ( hr == S_OK )
    hr = _copy_line_numbers(out, pEnumLineNumbers.thing);
  return hr;
}

//-------------------------------------------------------------------------
HRESULT local_pdb_access_t::sip_retrieve_lines_by_coords(
        pdb_lnnums_t *out,
        DWORD file_id,
        int lnnum,
        int colnum)
{
  dia_ptr_t<IDiaSourceFile> pFile;
  HRESULT hr = dia_session->findFileById(file_id, &pFile.thing);
  if ( FAILED(hr) )
    return hr;

  dia_ptr_t<IDiaEnumSymbols> pEnumSymbols;
  hr = pFile.thing->get_compilands(&pEnumSymbols.thing);
  if ( FAILED(hr) )
    return hr;

  while ( true )
  {
    ULONG got = 0;
    IDiaSymbol *compiland;
    pEnumSymbols.thing->Next(1, &compiland, &got);
    if ( got == 0 )
      break;

    dia_ptr_t<IDiaEnumLineNumbers> pEnumLineNumbers;
    HRESULT hr2;
    if ( lnnum == 0 )
      hr2 = dia_session->findLines(
              compiland,
              pFile.thing,
              &pEnumLineNumbers.thing);
    else
      hr2 = dia_session->findLinesByLinenum(
              compiland,
              pFile.thing,
              lnnum,
              colnum,
              &pEnumLineNumbers.thing);
    compiland->Release();

    if ( hr == S_OK )
      _copy_line_numbers(out, pEnumLineNumbers.thing);
  }
  return hr;
}

//-------------------------------------------------------------------------
HRESULT local_pdb_access_t::sip_iterate_symbols_at_ea(
        ULONGLONG va,
        ULONGLONG size,
        enum SymTagEnum tag,
        children_visitor_t &visitor)
{
  // See also: _do_iterate_symbols_enumerator
  std::set<DWORD> seen;

  ea_t cur = va;
  while ( true )
  {
    if ( cur >= va + size )
      break;

    ea_t old = cur;
    qnotused(old);

    LONG disp;
    IDiaSymbol *sym = nullptr;
    HRESULT hr = dia_session->findSymbolByVAEx(cur, tag, &sym, &disp);
    if ( FAILED(hr) || sym == nullptr )
      break;

    // perform all get_*'s on 'sym' _before_ the visitor is called: it might
    // very well 'steal' the symbol & destroy it in case it's not needed.
    // (see source_items_vec_builder_t::visit_child())
    pdb_sym_t *psym = create_sym(sym, true);
    pdb_sym_janitor_t janitor_psym(psym);
    DWORD sym_id;
    hr = psym->get_symIndexId(&sym_id);
    if ( hr != S_OK )
      break;

    ULONGLONG length = 0;
    sym->get_length(&length);

    if ( seen.insert(sym_id).second )
    {
      hr = visitor.visit_child(*psym);
      if ( FAILED(hr) )
        break;
    }

    cur -= disp;
    cur += length;

    QASSERT(30169, cur > old); // to avoid endless loops - i do not know if they are possible
  }
  return S_OK;
}

//-------------------------------------------------------------------------
HRESULT local_pdb_access_t::sip_iterate_file_compilands(
        DWORD file_id,
        children_visitor_t &visitor)
{
  dia_ptr_t<IDiaSourceFile> pFile;
  HRESULT hr = dia_session->findFileById(file_id, &pFile.thing);
  if ( FAILED(hr) )
    return hr;

  dia_ptr_t<IDiaEnumSymbols> pEnumSymbols;
  hr = pFile.thing->get_compilands(&pEnumSymbols.thing);
  if ( hr == S_OK )
    hr = _do_iterate_symbols_enumerator(pEnumSymbols.thing, visitor);
  return hr;
}

//-------------------------------------------------------------------------
HRESULT local_pdb_access_t::sip_retrieve_file_path(
        qstring *out,
        qstring *errbuf,
        DWORD file_id)
{
  dia_ptr_t<IDiaSourceFile> pFile;
  HRESULT hr = dia_session->findFileById(file_id, &pFile.thing);
  if ( hr == S_OK )
  {
    BSTR path;
    hr = pFile.thing->get_fileName(&path);
    if ( hr == S_OK )
    {
      utf16_utf8(out, path);
      SysFreeString(path);
    }
  }

  if ( FAILED(hr) )
  {
    if ( errbuf != nullptr )
      *errbuf = winerr(hr);
  }

  return hr;
}

//-------------------------------------------------------------------------
HRESULT local_pdb_access_t::_copy_files_ids(
        qvector<DWORD> *out,
        IDiaEnumSourceFiles *enumerator) const
{
  ULONG celt = 0;
  IDiaSourceFile *file = nullptr;
  while ( enumerator->Next(1, &file, &celt) == S_OK && celt > 0 )
  {
    DWORD file_id;
    if ( file->get_uniqueId(&file_id) == S_OK )
      out->push_back(file_id);
    file->Release();
  }
  return S_OK;
}

//-------------------------------------------------------------------------
HRESULT local_pdb_access_t::sip_retrieve_symbol_files(
        qvector<DWORD> *out,
        pdb_sym_t &sym)
{
  // Retrieve source file name associated with the current symbol
  QASSERT(30537, sym.whoami() == DIA_PDB_SYM);
  dia_pdb_sym_t &diasym = (dia_pdb_sym_t &)sym;
  BSTR path;
  HRESULT hr = diasym.data->get_sourceFileName(&path);
  if ( hr == S_OK ) // cannot use SUCCEEDED(hr) because S_OK means success
  {
    dia_ptr_t<IDiaEnumSourceFiles> pEnumSourceFiles;
    hr = dia_session->findFile(nullptr, path, nsfFNameExt, &pEnumSourceFiles.thing);
    SysFreeString(path);

    if ( hr == S_OK )
      _copy_files_ids(out, pEnumSourceFiles.thing);
  }
  return hr;
}

//-------------------------------------------------------------------------
HRESULT local_pdb_access_t::sip_find_files(
        qvector<DWORD> *out,
        const char *filename)
{
  qwstring fnamebuf;
  wchar16_t *fname = nullptr;
  if ( filename != nullptr )
  {
    qstring fnametmp = filename;
    utf8_utf16(&fnamebuf, &fnametmp[0]);
    fname = fnamebuf.begin();
  }

  dia_ptr_t<IDiaEnumSourceFiles> pEnumSourceFiles;
  HRESULT hr = dia_session->findFile(
          nullptr,
          fname,
          nsfFNameExt | nsfCaseInsensitive,
          &pEnumSourceFiles.thing);

  if ( hr == S_OK )
    _copy_files_ids(out, pEnumSourceFiles.thing);

  return hr;
}

```

`pdblocal.hpp`:

```hpp

#ifndef PDBLOCAL_HPP
#define PDBLOCAL_HPP

// The PDB related code that works on Windows and uses DIA

//----------------------------------------------------------------------------
class local_pdb_access_t : public pdb_access_t
{
public:
  local_pdb_access_t(
        const pdbargs_t &args,
        IDiaDataSource *pSource,
        IDiaSession *pSession,
        IDiaSymbol *pGlobal)
    : pdb_access_t(args),
      dia_source(pSource),
      dia_session(pSession),
      dia_global(pGlobal)
  {
  }

  virtual ~local_pdb_access_t()
  {
#define RELEASE(thing) do { if ( thing != nullptr ) { (thing)->Release(); thing = nullptr; } } while ( false )
    RELEASE(dia_global);
    RELEASE(dia_session);
    RELEASE(dia_source);
#undef RELEASE
    set_global_symbol_id(BADSYM);
  }

  HRESULT init()
  {
    DWORD id;
    HRESULT hr = dia_global->get_symIndexId(&id);
    if ( hr != S_OK )
      return hr;
    set_global_symbol_id(id);

    DWORD64 load_addr;
    hr = dia_session->get_loadAddress(&load_addr);
    if ( hr != S_OK )
      return hr;
    set_base_address(load_addr);

    return S_OK;
  }

  virtual HRESULT do_iterate_children(
        pdb_sym_t &sym,
        enum SymTagEnum type,
        children_visitor_t &visitor) override;
  virtual HRESULT load(pdb_sym_t &sym, DWORD id) override;

  virtual HRESULT sip_retrieve_lines_by_va(
        pdb_lnnums_t *out,
        ULONGLONG va,
        ULONGLONG length) override;
  virtual HRESULT sip_retrieve_lines_by_coords(
        pdb_lnnums_t *out,
        DWORD file_id,
        int lnnum,
        int colnum) override;
  virtual HRESULT sip_iterate_symbols_at_ea(
        ULONGLONG va,
        ULONGLONG size,
        enum SymTagEnum tag,
        children_visitor_t &visitor) override;
  virtual HRESULT sip_iterate_file_compilands(
        DWORD file_id,
        children_visitor_t &visitor) override;
  virtual HRESULT sip_retrieve_file_path(
        qstring *out,
        qstring *errbuf,
        DWORD file_id) override;
  virtual HRESULT sip_retrieve_symbol_files(
        qvector<DWORD> *out,
        pdb_sym_t &sym) override;
  virtual HRESULT sip_find_files(
        qvector<DWORD> *out,
        const char *name) override;

  virtual pdb_sym_t *create_sym(void *data, bool own) override
  {
    IDiaSymbol *sym = (IDiaSymbol *)data;
    return new dia_pdb_sym_t(this, sym, own);
  }
  pdb_sym_t *create_sym(DWORD sym_id) { return pdb_access_t::create_sym(sym_id); }

  IDiaDataSource *dia_source;
  IDiaSession    *dia_session;
  IDiaSymbol     *dia_global;

private:
  HRESULT safe_iterate_children(
        pdb_sym_t &sym,
        enum SymTagEnum type,
        children_visitor_t &visitor);
  HRESULT _do_iterate_symbols_enumerator(
        IDiaEnumSymbols *sym_enum,
        children_visitor_t &visitor);

  HRESULT _copy_line_numbers(
        pdb_lnnums_t *out,
        IDiaEnumLineNumbers *enumerator) const;

  HRESULT _copy_files_ids(
        qvector<DWORD> *out,
        IDiaEnumSourceFiles *enumerator) const;

  DECLARE_UNCOPYABLE(local_pdb_access_t)
};


#endif // PDBLOCAL_HPP

```

`pdbremote.cpp`:

```cpp

#include <pro.h>

#include "pdbremote.hpp"
#include "varser.hpp"

// Since we're using the win32 local stup debugger at the moment,
// this is necessary.
#include <dbg.hpp>

//-------------------------------------------------------------------------
bool is_win32_remote_debugger_loaded()
{
  return dbg != nullptr && dbg->is_remote() && streq(dbg->name, "win32");
}

//----------------------------------------------------------------------------
HRESULT remote_pdb_sym_t::get_classParent(pdb_sym_t *out)
{
  DWORD parent_id;
  HRESULT hr = data->get_dword(t_classParentId, &parent_id);
  if ( hr == S_OK )
    hr = pdb_access->load(*out, parent_id);
  return hr;
}

//----------------------------------------------------------------------------
HRESULT remote_pdb_sym_t::get_type(pdb_sym_t *out)
{
  DWORD type_id;
  HRESULT hr = data->get_dword(t_typeId, &type_id);
  if ( hr == S_OK )
    hr = pdb_access->load(*out, type_id);
  return hr;
}

//----------------------------------------------------------------------------
HRESULT remote_pdb_sym_t::get_lexicalParent(pdb_sym_t *out)
{
  DWORD lparent_id;
  HRESULT hr = data->get_dword(t_lexicalParentId, &lparent_id);
  if ( hr == S_OK )
    hr = pdb_access->load(*out, lparent_id);
  return hr;
}

//----------------------------------------------------------------------------
const uint32 sym_data_t::sizes[] =
{
  sizeof(BOOL),
  sizeof(DWORD),
  sizeof(DWORD64),
  sizeof(char *),
  sizeof(LONG),
  sizeof(ULONGLONG),
  sizeof(VARIANT)
};

//----------------------------------------------------------------------------
sym_data_t::sym_data_t(
        token_mask_t _tokens,
        const uchar *buf,
        size_t bufsize,
        packing_info_t _packing,
        bool *_warned)
  : present(_tokens),
    warned(_warned)
{
  memset(counters, 0, sizeof(counters));
  memset(children_infos, 0, sizeof(children_infos));

  if ( _packing == SYMDAT_PACKED )
  {
    const uchar *ptr = buf;
    const uchar *const end = buf + bufsize;
    for ( uint64 bit = t_start; bit != t_end; bit <<= 1 )
    {
      sym_token_t token = sym_token_t(bit);
      if ( !token_present(token) )
        continue;

      if ( is_sym_token_bool(token) )
      {
        counters[t_bool]++;
        uint8 tmp = unpack_db(&ptr, end);
        data.append(&tmp, sizeof(tmp));
      }
      else if ( is_sym_token_dword(token) )
      {
        counters[t_dword]++;
        uint32 tmp = unpack_dd(&ptr, end);
        data.append(&tmp, sizeof(tmp));
      }
      else if ( is_sym_token_dword64(token) )
      {
        counters[t_dword64]++;
        uint64 tmp = unpack_dq(&ptr, end);
        data.append(&tmp, sizeof(tmp));
      }
      else if ( is_sym_token_string(token) )
      {
        counters[t_string]++;
        char *tmp = qstrdup(unpack_str(&ptr, end));
        data.append(&tmp, sizeof(tmp));
      }
      else if ( is_sym_token_long(token) )
      {
        counters[t_long]++;
        LONG tmp = unpack_dd(&ptr, end);
        data.append(&tmp, sizeof(tmp));
      }
      else if ( is_sym_token_ulonglong(token) )
      {
        counters[t_ulonglong]++;
        ULONGLONG tmp = unpack_dq(&ptr, end);
        data.append(&tmp, sizeof(tmp));
      }
      else if ( is_sym_token_variant(token) )
      {
        counters[t_variant]++;
        VARIANT var;
        if ( varser_t::deserialize(var, &ptr, end) )
        {
          data.append(&var, sizeof(var));
        }
        else
        {
          if ( !*warned )
          {
            warning("The PDB file contains VARIANT items that cannot be deserialized.");
            *warned = true;
          }
        }
      }
      else
      {
        INTERR(30200);
      }
    }

    QASSERT(30201, data.size() == counters[t_bool]      * sizes[t_bool]
                                + counters[t_dword]     * sizes[t_dword]
                                + counters[t_dword64]   * sizes[t_dword64]
                                + counters[t_string]    * sizes[t_string]
                                + counters[t_long]      * sizes[t_long]
                                + counters[t_ulonglong] * sizes[t_ulonglong]
                                + counters[t_variant]   * sizes[t_variant]);
    QASSERT(30202, ptr == end);
  }
  else
  {
    data.append(buf, bufsize);
    // Not supported yet. All that's left to do
    // is count the types (counters[]), though.
    INTERR(30203);
  }
}

//----------------------------------------------------------------------------
sym_data_t::~sym_data_t()
{
  for ( int i = 0; i < SymTagMax; i++ )
  {
    children_t &children = children_infos[i];
    if ( children.ids != nullptr )
    {
      qfree(children.ids);
      children.ids = nullptr;
      children.cnt = 0;
    }
  }

  uint8 nstring = counters[t_string];
  if ( nstring > 0 )
  {
    char **cur_str_ptr = (char **)string_ptr(t_string_start);
    for ( uint8 i = 0; i < nstring; i++, cur_str_ptr++ )
      qfree(*cur_str_ptr);
  }

  uint8 nvariant = counters[t_variant];
  if ( nvariant > 0 )
  {
    VARIANT *cur_variant_ptr = (VARIANT *)variant_ptr(t_variant_start);
    for ( uint8 i = 0; i < nvariant; i++, cur_variant_ptr++ )
      if ( cur_variant_ptr->vt == VT_LPSTR )
        qfree(cur_variant_ptr->punkVal);
  }

  warned = nullptr;
}


#define READ_IF_FOUND(type, fun)                \
  const type *ptr = fun##_ptr(token);           \
  if ( ptr == nullptr )                            \
  {                                             \
    return S_FALSE;                             \
  }                                             \
  else                                          \
  {                                             \
    *out = *ptr;                                \
    return S_OK;                                \
  }

//----------------------------------------------------------------------------
HRESULT sym_data_t::get_bool(sym_token_t token, BOOL *out) const
{
  READ_IF_FOUND(BOOL, bool)
}

//----------------------------------------------------------------------------
HRESULT sym_data_t::get_dword(sym_token_t token, DWORD *out) const
{
  READ_IF_FOUND(DWORD, dword)
}

//----------------------------------------------------------------------------
HRESULT sym_data_t::get_dword64(sym_token_t token, DWORD64 *out) const
{
  READ_IF_FOUND(DWORD64, dword64)
}

//----------------------------------------------------------------------------
HRESULT sym_data_t::get_string(sym_token_t token, qstring *out) const
{
  READ_IF_FOUND(char *, string)
}

//----------------------------------------------------------------------------
HRESULT sym_data_t::get_dword(sym_token_t token, LONG *out) const
{
  READ_IF_FOUND(LONG, long)
}

//----------------------------------------------------------------------------
HRESULT sym_data_t::get_ulonglong(sym_token_t token, ULONGLONG *out) const
{
  READ_IF_FOUND(ULONGLONG, uint64)
}

//----------------------------------------------------------------------------
HRESULT sym_data_t::get_variant(sym_token_t token, VARIANT *out) const
{
  READ_IF_FOUND(VARIANT, variant)
}

#undef READ_IF_FOUND

//----------------------------------------------------------------------------
const void *sym_data_t::any_ptr(sym_token_t token, sym_token_t start, sym_token_t end) const
{
  if ( !token_present(token) )
    return nullptr;

  static const sym_token_t ends[] =
  {
    t_bool_end,
    t_dword_end,
    t_dword64_end,
    t_string_end,
    t_long_end,
    t_ulonglong_end,
    t_variant_end,
  };
  CASSERT(qnumber(ends) == qnumber(counters));
  CASSERT(qnumber(sizes) == qnumber(counters));

  // count how many bytes we have to skip and determine the type size
  uint32 type_size = 0;
  const uchar *ptr = data.begin();
  for ( int i=0; i < qnumber(ends); i++ )
  {
    if ( token <= ends[i] )
    {
      type_size = sizes[i];
      break;
    }
    ptr += counters[i] * sizes[i];
  }
  QASSERT(30204, type_size != 0);

  // how many tokens of our type we have to skip?
  uint32 bit;
  for ( bit = start; bit <= end; bit <<= 1 )
  {
    sym_token_t t = sym_token_t(bit);
    if ( token_present(t) )
    {
      if ( t == token )
        return ptr;
      ptr += type_size;
    }
  }
  return nullptr; // did not find the requested token
}

//----------------------------------------------------------------------------
remote_pdb_access_t::~remote_pdb_access_t()
{
  typedef std::map<DWORD,sym_data_t*>::iterator iter;
  for ( iter it = cache.begin(), end = cache.end(); it != end; it++ )
    delete it->second;

  close_connection();
}

//----------------------------------------------------------------------------
void remote_pdb_access_t::close_connection()
{
  if ( remote_session_id > 0 )
  {
    bytevec_t dummy;
    perform_op(WIN32_IOCTL_PDB_CLOSE, dummy, nullptr);
    remote_session_id = -1;
  }

  if ( !was_connected && dbg != nullptr )
    dbg->term_debugger();
}

//----------------------------------------------------------------------
// load and connect to a remote win32 debugger, if necessary
bool remote_pdb_access_t::load_win32_debugger(void)
{
  was_connected = false;
  if ( dbg != nullptr && !is_win32_remote_debugger_loaded() )
  {
    // a debugger is loaded, but it's not a remote win32
    warning("Loading PDB symbols requires a remote win32 debugger. "
            "Please stop the current debugging session and try again.");
    return false;
  }
  if ( get_process_state() != DSTATE_NOTASK )
  {
    // the debugger is already connected
    was_connected = true;
    return true;
  }

  netnode pdbnode(PDB_NODE_NAME);
  pdbnode.altset(PDB_LOADING_WIN32_DBG, true);
  bool win32_dbg_loaded = load_debugger("win32", true) && dbg != nullptr;
  pdbnode.altdel(PDB_LOADING_WIN32_DBG);

  if ( !win32_dbg_loaded )
  {
    warning("Could not load remote Win32 debugger.");
    return false;
  }

  qstring server;
  server = host[0] != '\0' ? host : "localhost";

  qstring pass;
  if ( pwd != nullptr )
    pass = pwd;

  qstring dbg_errbuf;
  while ( !dbg->init_debugger(server.c_str(), port, pass.c_str(), &dbg_errbuf) )
  {
    if ( batch ) // avoid endless (and useless) loop in batch mode
    {
      msg("PDB: Could not load remote Win32 debugger\n");
      return false;
    }
    if ( !dbg_errbuf.empty() )
      msg("%s\n", dbg_errbuf.begin());
    // hrw
    const char *winremote = inf_is_64bit() ? "win64_remote64.exe" : "win32_remote.exe";
    qstring formstr;
    formstr.sprnt(
      "Remote PDB server\n"
      "In order to load PDB information, IDA requires a running %s debugger server\n"
      "running on a Windows host, but it could not connect to the %s debugger\n"
      "at the current specified address.\n"
      "Please make sure that %s is running there.\n\n"
      "<#Name of the remote host#~H~ostname :q:1023:30::> <#Remote port number#Po~r~t:D::8::>\n"
      "<#Password for the remote host#Pass~w~ord :q:1023:30::>\n"
      "Hint: to change this permanently, edit pdb.cfg.\n\n",
      winremote, winremote, winremote);
    uval_t sport = port;
    int r = ask_form(formstr.c_str(), &server, &sport, &pass);
    if ( r != 1 )
      return false;
    port = sport;
  }
  msg("PDB: successfully connected to %s\n", server.c_str());
  return true;
}


//----------------------------------------------------------------------------
#define REPORT_ERROR(Msg, Rc)                   \
  do                                            \
  {                                             \
    qfree(outbuf);                              \
    qstrncpy(errbuf, Msg, sizeof(errbuf));      \
    return Rc;                                  \
  } while ( false )

//-------------------------------------------------------------------------
HRESULT remote_pdb_access_t::open_connection()
{
  // Load win32 debugger (FIXME: Should just use an RPC client, not a full debugger!)
  if ( !load_win32_debugger() )
    return S_FALSE;

  // Init remote.
  bytevec_t oper;
  compiler_info_t cc;
  inf_get_cc(&cc);
  oper.append(&cc, sizeof(cc));
  oper.pack_str(pdbargs.pdb_path);
  oper.pack_str(pdbargs.input_path);
  oper.append(&pdbargs.pdb_sign, sizeof(pdbargs.pdb_sign));
  oper.pack_str(pdbargs.spath);
  oper.pack_ea64(get_base_address());
  oper.pack_dd(pdbargs.flags);

  void *outbuf = nullptr;
  ssize_t outsize = 0;
  ioctl_pdb_code_t rc = send_ioctl(
          WIN32_IOCTL_PDB_OPEN,
          oper.begin(), oper.size(), &outbuf, &outsize);
  if ( rc != pdb_ok || outsize < 1 )
    REPORT_ERROR(
            "PDB symbol extraction is not supported by the remote server",
            E_FAIL);

  // remote PDB session has become active
  bytevec_t sidbuf;
  {
    const uchar *ptr = (const uchar *) outbuf;
    const uchar *const end = ptr + outsize;
    remote_session_id = unpack_dd(&ptr, end);
    QASSERT(30493, remote_session_id > 0);
    sidbuf.pack_dd(remote_session_id);
  }

  // now, do the polling game.
  bool done = false;
  while ( !done )
  {
    qfree(outbuf);
    outbuf = nullptr;
    qsleep(100);
    user_cancelled(); // refresh the output window
    rc = send_ioctl(
            WIN32_IOCTL_PDB_OPERATION_COMPLETE,
            sidbuf.begin(), sidbuf.size(),
            &outbuf, &outsize);
    if ( rc != pdb_ok || outsize <= 0 )
      REPORT_ERROR(
              "remote server reported error while opening PDB",
              E_FAIL);
    const uchar *ptr = (const uchar *)outbuf;
    const uchar *const end = ptr + outsize;
    pdb_op_completion_t status = pdb_op_completion_t(unpack_dd(&ptr, end));
    done = true; // only 'not complete' status will make us continue.
    switch ( status )
    {
      case pdb_op_not_complete:
        done = false;
        break;
      case pdb_op_complete:
        {
          set_global_symbol_id(unpack_dd(&ptr, end));
          set_machine_type(unpack_dd(&ptr, end));
          set_dia_version(unpack_dd(&ptr, end));
          const char *fname = unpack_str(&ptr, end);
          // TODO The printed path is wrong (test with pc_gdb_notepad.exe).
          msg("PDB: opened \"%s\"\n", fname);
        }
        break;
      case pdb_op_failure:
        {
          const char *errmsg = unpack_str(&ptr, end);
          REPORT_ERROR(errmsg, E_FAIL);
          // if opening pdb fails, win32_remote closes the MSDIA pdb
          // session automatically.
          remote_session_id = -1;
        }
        break;
      default:
        break;
    }
  }
  qfree(outbuf);

  return remote_session_id > 0 ? S_OK : E_FAIL;
}


//----------------------------------------------------------------------------
ioctl_pdb_code_t remote_pdb_access_t::send_ioctl(
        int fn,
        const void *buf,
        size_t size,
        void **outbuf,
        ssize_t *outsz)
{
  if ( dbg == nullptr )
    return pdb_error;

  deb(IDA_DEBUG_DEBUGGER, "PDB: send_ioctl(fn=%d, size=%" FMT_Z ")\n", fn, size);
  // internal_ioctl() will either send the request to the debugger thread if
  // it exists (i.e., we are in a debugging session), or perform it directly.
  ioctl_pdb_code_t code = ioctl_pdb_code_t(internal_ioctl(fn, buf, size, outbuf, outsz));
  // ioctl_pdb_code_t code = ioctl_pdb_code_t(internal_ioctl  dbg->send_ioctl(fn, buf, size, outbuf, outsz));
  deb(IDA_DEBUG_DEBUGGER, "PDB: send_ioctl(fn=%d) complete. Code=%d\n", fn, int(code));
  return code;
}

//-------------------------------------------------------------------------
HRESULT remote_pdb_access_t::_do_iterate_symbols_ids(
        const DWORD *ids,
        size_t count,
        enum SymTagEnum type,
        children_visitor_t &visitor)
{
  HRESULT hr = S_OK;
  for ( size_t i = 0, n = count; i < n; ++i, ++ids )
  {
    DWORD tag;
    pdb_sym_t *cur = create_sym(*ids);
    pdb_sym_janitor_t janitor_cur(cur);
    if ( type == SymTagNull
      || cur->get_symTag(&tag) == S_OK && tag == type )
    {
      hr = visitor.visit_child(*cur);
      if ( FAILED(hr) )
        break;
    }
  }
  return hr;
}

//----------------------------------------------------------------------------
HRESULT remote_pdb_access_t::do_iterate_children(
        pdb_sym_t &sym,
        enum SymTagEnum type,
        children_visitor_t &visitor)
{
  sym_data_t *symbol;
  ioctl_pdb_code_t code = get_sym_data(sym, &symbol);
  QASSERT(30205, code == pdb_ok);
  QASSERT(30206, type < SymTagMax);
  sym_data_t::children_t &children = symbol->children_infos[type];
  if ( children.ids == nullptr )
  {
    qvector<DWORD> children_ids;
    code = fetch_children_infos(sym, type, &children_ids);
    if ( code == pdb_ok )
    {
      children.cnt = children_ids.size();
      children.ids = children_ids.extract();
    }
  }

  HRESULT hr = E_FAIL;
  if ( code == pdb_ok )
    hr = _do_iterate_symbols_ids(
            children.ids,
            children.cnt,
            type,
            visitor);
  return hr;
}

//----------------------------------------------------------------------------
HRESULT remote_pdb_access_t::load(pdb_sym_t &pdbsym, DWORD id)
{
  sym_data_t *sd;
  if ( get_sym_data(id, &sd) != pdb_ok )
    return E_FAIL;
  QASSERT(30544, pdbsym.whoami() == REMOTE_PDB_SYM);
  remote_pdb_sym_t &sym = (remote_pdb_sym_t &)pdbsym;
  sym.set_symbol_data(sd);
  return S_OK;
}

#define HAS_REMAINING_OR_FAIL(Ptr, End)         \
  do                                            \
  {                                             \
    if ( Ptr >= End )                           \
      return E_FAIL;                            \
  } while ( false )

#define ALL_CONSUMED_OR_FAIL(Ptr, End)          \
  do                                            \
  {                                             \
    if ( Ptr != End )                           \
      return E_FAIL;                            \
  } while ( false )

//-------------------------------------------------------------------------
HRESULT remote_pdb_access_t::handle_fetch_lnnums(
        pdb_lnnums_t *out,
        const bytevec_t &resp) const
{
  const uchar *ptr = resp.begin();
  const uchar *const end = resp.end();
  uint32 nlines = unpack_dd(&ptr, end);
  for ( uint32 i = 0; i < nlines; ++i )
  {
    HAS_REMAINING_OR_FAIL(ptr, end);
    pdb_lnnum_t &ln = out->push_back();
    ln.va = ULONGLONG(unpack_ea64(&ptr, end));
    ln.length = unpack_dd(&ptr, end);
    ln.columnNumber = unpack_dd(&ptr, end);
    ln.columnNumberEnd = unpack_dd(&ptr, end);
    ln.lineNumber = unpack_dd(&ptr, end);
    ln.lineNumberEnd = unpack_dd(&ptr, end);
    ln.file_id = unpack_dd(&ptr, end);
    ln.statement = unpack_db(&ptr, end);
  }
  ALL_CONSUMED_OR_FAIL(ptr, end);
  return S_OK;
}

//-------------------------------------------------------------------------
HRESULT remote_pdb_access_t::sip_retrieve_lines_by_va(
        pdb_lnnums_t *out,
        ULONGLONG va,
        ULONGLONG length)
{
  bytevec_t req, resp;
  req.pack_ea64(va);
  req.pack_dq(length);
  ioctl_pdb_code_t code = perform_op(
          WIN32_IOCTL_PDB_SIP_FETCH_LINES_BY_VA, req, &resp);
  return code == pdb_ok ? handle_fetch_lnnums(out, resp) : E_FAIL;
}

//-------------------------------------------------------------------------
HRESULT remote_pdb_access_t::sip_retrieve_lines_by_coords(
        pdb_lnnums_t *out,
        DWORD file_id,
        int lnnum,
        int colnum)
{
  bytevec_t req, resp;
  req.pack_dd(file_id);
  req.pack_dd(lnnum);
  req.pack_dd(colnum);
  ioctl_pdb_code_t code = perform_op(
          WIN32_IOCTL_PDB_SIP_FETCH_LINES_BY_COORDS, req, &resp);
  return code == pdb_ok ? handle_fetch_lnnums(out, resp) : E_FAIL;
}

//-------------------------------------------------------------------------
HRESULT remote_pdb_access_t::sip_iterate_symbols_at_ea(
        ULONGLONG va,
        ULONGLONG size,
        enum SymTagEnum tag,
        children_visitor_t &visitor)
{
  qvector<DWORD> ids;
  bytevec_t req;
  req.pack_ea64(va);
  req.pack_dq(size);
  req.pack_dd(tag);
  ioctl_pdb_code_t code = perform_op(
          WIN32_IOCTL_PDB_SIP_FETCH_SYMBOLS_AT_VA, req, &ids);
  if ( code != pdb_ok )
    return E_FAIL;
  return _do_iterate_symbols_ids(
          ids.begin(),
          ids.size(),
          tag,
          visitor);
}

//-------------------------------------------------------------------------
HRESULT remote_pdb_access_t::sip_iterate_file_compilands(
        DWORD file_id,
        children_visitor_t &visitor)
{
  qvector<DWORD> ids;
  bytevec_t req;
  req.pack_dd(file_id);
  ioctl_pdb_code_t code = perform_op(
          WIN32_IOCTL_PDB_SIP_FETCH_FILE_COMPILANDS, req, &ids);
  if ( code != pdb_ok )
    return E_FAIL;
  return _do_iterate_symbols_ids(
          ids.begin(),
          ids.size(),
          SymTagNull,
          visitor);
}

//-------------------------------------------------------------------------
HRESULT remote_pdb_access_t::sip_retrieve_file_path(
        qstring *out,
        qstring *,
        DWORD file_id)
{
  bytevec_t req, resp;
  req.pack_dd(file_id);
  ioctl_pdb_code_t code = perform_op(
          WIN32_IOCTL_PDB_SIP_FETCH_FILE_PATH, req, &resp);
  if ( code != pdb_ok )
    return E_FAIL;

  const uchar *ptr = resp.begin();
  const uchar *const end = resp.end();
  HAS_REMAINING_OR_FAIL(ptr, end);
  *out = unpack_str(&ptr, end);
  ALL_CONSUMED_OR_FAIL(ptr, end);
  return S_OK;
}

//-------------------------------------------------------------------------
HRESULT remote_pdb_access_t::handle_fetch_file_ids(
        qvector<DWORD> *out,
        const bytevec_t &resp) const
{
  const uchar *ptr = resp.begin();
  const uchar *const end = resp.end();
  uint32 nfiles = unpack_dd(&ptr, end);
  out->resize(nfiles);
  for ( uint32 i = 0; i < nfiles; ++i )
  {
    HAS_REMAINING_OR_FAIL(ptr, end);
    out->at(i) = unpack_dd(&ptr, end);
  }
  ALL_CONSUMED_OR_FAIL(ptr, end);
  return S_OK;
}

//-------------------------------------------------------------------------
HRESULT remote_pdb_access_t::sip_retrieve_symbol_files(
        qvector<DWORD> *out,
        pdb_sym_t &pdbsym)
{
  QASSERT(30538, pdbsym.whoami() == REMOTE_PDB_SYM);
  remote_pdb_sym_t &sym = (remote_pdb_sym_t &)pdbsym;
  bytevec_t req, resp;
  req.pack_dd(sym.data->get_id());
  ioctl_pdb_code_t code = perform_op(
          WIN32_IOCTL_PDB_SIP_FETCH_SYMBOL_FILES, req, &resp);
  return code == pdb_ok ? handle_fetch_file_ids(out, resp) : E_FAIL;
}

//-------------------------------------------------------------------------
HRESULT remote_pdb_access_t::sip_find_files(
        qvector<DWORD> *out,
        const char *fileName)
{
  bytevec_t req, resp;
  req.pack_str(fileName);
  ioctl_pdb_code_t code = perform_op(
          WIN32_IOCTL_PDB_SIP_FIND_FILES, req, &resp);
  return code == pdb_ok ? handle_fetch_file_ids(out, resp) : E_FAIL;
}

//----------------------------------------------------------------------------
DWORD remote_pdb_access_t::build_and_register_sym_data(
        const uchar **raw,
        const uchar *end)
{
  DWORD child_sym     = unpack_dd(raw, end);
  token_mask_t tokens = unpack_dq(raw, end);
  uint32 datasz       = unpack_dd(raw, end);
  const uchar *data = (const uchar *)unpack_obj_inplace(raw, end, datasz);
  cache[child_sym] = new sym_data_t(tokens, data, datasz, SYMDAT_PACKED, &warned);
  return child_sym;
}

//----------------------------------------------------------------------------
void remote_pdb_access_t::handle_fetch_response(
        const uchar **ptr,
        const uchar *end,
        qvector<DWORD> *ids_storage)
{
  // Build cache!
  uint32 nchildren = 0;
  unpack_obj(&nchildren, sizeof(nchildren), ptr, end);
  if ( ids_storage != nullptr )
    ids_storage->reserve(nchildren);
  for ( uint32 i = 0; i < nchildren; i++ )
  {
    DWORD created = build_and_register_sym_data(ptr, end);
    if ( ids_storage != nullptr )
      ids_storage->push_back(created);
  }
}

//----------------------------------------------------------------------------
ioctl_pdb_code_t remote_pdb_access_t::perform_op(
        int op_type,
        const bytevec_t &oper,
        void *data)
{
  void *outbuf = nullptr;
  ssize_t outsize = 0;
  bytevec_t raw;
  QASSERT(30494, remote_session_id > 0);
  raw.pack_dd(remote_session_id);
  if ( !oper.empty() )
    raw.append(oper.begin(), oper.size());
  ioctl_pdb_code_t rc = send_ioctl(op_type, raw.begin(), raw.size(), &outbuf, &outsize);
  if ( rc != pdb_ok )
    REPORT_ERROR(
            "PDB symbol extraction is not supported by the remote server",
            rc);

  // msg(" ok\n");

  // By now, the operation will be done. Let's parse
  // the contents of the output buffer.
  const uchar *ptr = (const uchar *)outbuf;
  const uchar *const end = ptr + outsize;
  switch ( op_type )
  {
    case WIN32_IOCTL_PDB_FETCH_SYMBOL:
    case WIN32_IOCTL_PDB_FETCH_CHILDREN:
    case WIN32_IOCTL_PDB_SIP_FETCH_SYMBOLS_AT_VA:
    case WIN32_IOCTL_PDB_SIP_FETCH_FILE_COMPILANDS:
      QASSERT(30207, outsize >= (4 /*(unpacked) nchildren*/));
      handle_fetch_response(&ptr, end, (qvector<DWORD> *)data);
      break;
    case WIN32_IOCTL_PDB_SIP_FETCH_LINES_BY_VA:
    case WIN32_IOCTL_PDB_SIP_FETCH_LINES_BY_COORDS:
    case WIN32_IOCTL_PDB_SIP_FETCH_FILE_PATH:
    case WIN32_IOCTL_PDB_SIP_FETCH_SYMBOL_FILES:
    case WIN32_IOCTL_PDB_SIP_FIND_FILES:
      {
        bytevec_t *bvout = (bytevec_t *) data;
        bvout->append(outbuf, outsize);
      }
      break;
    case WIN32_IOCTL_PDB_CLOSE:
      break;
    default:
      INTERR(30208);
  }

  qfree(outbuf);

  return pdb_ok;
}

//----------------------------------------------------------------------------
ioctl_pdb_code_t remote_pdb_access_t::fetch_children_infos(
        pdb_sym_t &pdbsym,
        enum SymTagEnum type,
        qvector<DWORD> *children_ids)
{
  QASSERT(30539, pdbsym.whoami() == REMOTE_PDB_SYM);
  remote_pdb_sym_t &sym = (remote_pdb_sym_t &)pdbsym;
  bytevec_t oper;
  oper.pack_dd(sym.data->get_id());
  oper.pack_dd(type);
  // msg("Fetching children: 0x%x", sym);
  return perform_op(WIN32_IOCTL_PDB_FETCH_CHILDREN, oper, children_ids);
}

//----------------------------------------------------------------------------
sym_data_t *remote_pdb_access_t::get_sym_data_from_cache(DWORD id)
{
  typedef std::map<DWORD,sym_data_t*>::const_iterator citer;
  citer it = cache.find(id);
  if ( it != cache.end() )
    return it->second;
  return nullptr;
}

//----------------------------------------------------------------------------
ioctl_pdb_code_t remote_pdb_access_t::get_sym_data(pdb_sym_t &pdbsym, sym_data_t **out)
{
  QASSERT(30540, pdbsym.whoami() == REMOTE_PDB_SYM);
  remote_pdb_sym_t &sym = (remote_pdb_sym_t &)pdbsym;
  DWORD id = sym.data->get_id();
  return get_sym_data(id, out);
}

//----------------------------------------------------------------------------
ioctl_pdb_code_t remote_pdb_access_t::get_sym_data(DWORD id, sym_data_t **out)
{
  sym_data_t *found = get_sym_data_from_cache(id);
  if ( found != nullptr )
  {
    *out = found;
    return pdb_ok;
  }
  else
  {
    bytevec_t oper;
    oper.pack_dd(id);
    ioctl_pdb_code_t rc = perform_op(WIN32_IOCTL_PDB_FETCH_SYMBOL, oper, nullptr);
    if ( rc == pdb_ok )
    {
      rc = get_sym_data(id, out);
      QASSERT(30209, rc == pdb_ok);
    }
    return rc;
  }
}

```

`pdbremote.hpp`:

```hpp

#ifndef PDBREMOTE_HPP
#define PDBREMOTE_HPP

#include <network.hpp>
#include "../../dbg/win32/win32_rpc.h"
#include "pdbaccess.hpp"

// The PDB related code that works on Unix
// It connects to a Windows computer and asks to retrieve PDB info

//----------------------------------------------------------------------------
bool is_win32_remote_debugger_loaded();

//----------------------------------------------------------------------------

class remote_pdb_access_t : public pdb_access_t
{
public:
  remote_pdb_access_t(
        const pdbargs_t &args,
        const char *_host,
        int _port,
        const char *_pwd)
    : pdb_access_t(args),
      host(_host),
      port(_port),
      pwd(_pwd),
      remote_session_id(-1)
  {
    set_base_address(args.loaded_base);
  }

  virtual ~remote_pdb_access_t();

  // Open connection, create PDB session.
  HRESULT open_connection();
  // Close PDB session, close connection.
  void close_connection();

  virtual HRESULT do_iterate_children(
        pdb_sym_t &sym,
        enum SymTagEnum type,
        children_visitor_t &visitor) override;
  virtual HRESULT load(pdb_sym_t &sym, DWORD id) override;

  virtual HRESULT sip_retrieve_lines_by_va(
        pdb_lnnums_t *out,
        ULONGLONG va,
        ULONGLONG length) override;
  virtual HRESULT sip_retrieve_lines_by_coords(
        pdb_lnnums_t *out,
        DWORD file_id,
        int lnnum,
        int colnum) override;
  virtual HRESULT sip_iterate_symbols_at_ea(
        ULONGLONG va,
        ULONGLONG size,
        enum SymTagEnum tag,
        children_visitor_t &visitor) override;
  virtual HRESULT sip_iterate_file_compilands(
        DWORD file_id,
        children_visitor_t &visitor) override;
  virtual HRESULT sip_retrieve_file_path(
        qstring *out,
        qstring *errbuf,
        DWORD file_id) override;
  virtual HRESULT sip_retrieve_symbol_files(
        qvector<DWORD> *out,
        pdb_sym_t &sym) override;
  virtual HRESULT sip_find_files(
        qvector<DWORD> *out,
        const char *name) override;

  virtual pdb_sym_t *create_sym(void *data, bool) override
  {
    sym_data_t *sym = (sym_data_t *)data;
    return new remote_pdb_sym_t(this, sym);
  }
  pdb_sym_t *create_sym(DWORD sym_id) { return pdb_access_t::create_sym(sym_id); }

  // Possibly remote operation.
  // If nullptr is returned, it means the symbol is not available, nor
  // could it be fetched remotely.
  ioctl_pdb_code_t get_sym_data(pdb_sym_t &sym, sym_data_t **);
  ioctl_pdb_code_t get_sym_data(DWORD sym_id, sym_data_t **);


private:
  HRESULT _do_iterate_symbols_ids(
        const DWORD *ids,
        size_t count,
        enum SymTagEnum type,
        children_visitor_t &visitor);

#define SAFE_GET(type)                                          \
  sym_data_t *sym_data;                                         \
  ioctl_pdb_code_t result = get_sym_data(sym, &sym_data);       \
  if ( result == pdb_ok )                                       \
    return sym_data->get_##type(token, out);                    \
  else                                                          \
    return E_FAIL

  // Build sym_data_t instance, and register it into the 'cache'.
  DWORD build_and_register_sym_data(const uchar **raw, const uchar *end);

  // Whenever fetch_children_infos() or get_sym_data() performs
  // a remote operation, this is used to handle the response
  // and add the fetched symbol data to the cache.
  void handle_fetch_response(
        const uchar **ptr,
        const uchar *end,
        qvector<DWORD> *ids_storage);

  // Remote operation.
  ioctl_pdb_code_t fetch_children_infos(
        pdb_sym_t &sym,
        enum SymTagEnum type,
        qvector<DWORD> *children_ids);

  HRESULT handle_fetch_lnnums(
        pdb_lnnums_t *out,
        const bytevec_t &resp) const;

  HRESULT handle_fetch_file_ids(
        qvector<DWORD> *out,
        const bytevec_t &resp) const;

  sym_data_t *get_sym_data_from_cache(DWORD id);

  // Low-level interface used by open_connection(), fetch_children_infos(), and get_sym_data().
  // 'fetch_type' is one of
  //   WIN32_IOCTL_PDB_OPEN,
  //   WIN32_IOCTL_PDB_FETCH_SYMBOL,
  //   WIN32_IOCTL_PDB_FETCH_CHILDREN
  ioctl_pdb_code_t perform_op(int op_type, const bytevec_t &oper, void *data);

  ioctl_pdb_code_t send_ioctl(
        int fn,
        const void *buf,
        size_t size,
        void **poutbuf,
        ssize_t *poutsize);

  std::map<DWORD, sym_data_t*> cache;
  const char *user_spath;
  char errbuf[MAXSTR];

  // For the moment, we'll channel all IOCTL requests
  // through the debugger. Ideally, we should be able to just
  // use a RPC client.
  bool load_win32_debugger(void);

  const char *host;
  int port;
  const char *pwd;
  bool was_connected;
  bool is_dbg_module;
  int remote_session_id;
  bool warned = false;
};

#endif // PDBREMOTE_HPP

```

`sip.cpp`:

```cpp

#include "sip.hpp"
#include "tilbuild.hpp"

#include <dbg.hpp>

struct pdb_modinfo_t;

static source_item_t *new_pdb_symbol(
        pdb_modinfo_t *pdb_module,
        DWORD sym_id);
static source_item_t *new_pdb_symbol_or_delete(
        pdb_modinfo_t *pdb_module,
        pdb_sym_t *sym);

typedef qvector<source_item_ptr> source_items_vec_t;

//-------------------------------------------------------------------------
// will steal data from all 'child' instances passed to 'visit_child()',
// and create new pdb_sym_t objects (wrapped in source_item_t's) with
// that data.
struct source_items_vec_builder_t : public pdb_access_t::children_visitor_t
{
  source_items_vec_t items;
  pdb_modinfo_t *pdb_module;
  source_items_vec_builder_t(pdb_modinfo_t *_mod) : pdb_module(_mod) {}
  virtual HRESULT visit_child(pdb_sym_t &child) override;
};

//--------------------------------------------------------------------------
// Implementation of source information provider using PDB information
// and the DIA SDK

//--------------------------------------------------------------------------
// Information about a PDB module. Contains a type cache, that'll
// last the same time as the debugging session.
struct pdb_modinfo_t
{
  pdb_ctx_t &pv;

  pdb_modinfo_t()
    : pv(*GET_MODULE_DATA(pdb_ctx_t)),
      base(BADADDR),
      size(0),
      opened(false),
      pdb_access(nullptr),
      type_cache(nullptr),
      use_pdbida(false)
  {}

  ~pdb_modinfo_t()
  {
    delete type_cache;
#ifdef __NT__
    // on windows with MSDIA provider, 'session_ref' owns the pdb_access
    if ( use_pdbida )
#endif
    {
      delete pdb_access;
    }
  }

  pdb_access_t *get_access() { return pdb_access; }

  HRESULT open(const char *input_file, const char *user_spath, ea_t load_address);
  source_item_t *find_static_item_in_module(const char *iname);

  typedef std::map<qstring,DWORD> module_globals_t;
  module_globals_t module_globals;

  qstring path;
  ea_t base;
  asize_t size;
  bool opened;
  pdb_access_t *pdb_access;
#ifndef ENABLE_REMOTEPDB
  pdb_session_ref_t session_ref;
#endif
  til_builder_t *type_cache;
  bool use_pdbida;
};
typedef std::map<ea_t, pdb_modinfo_t> pdb_modules_t;

//-------------------------------------------------------------------------
HRESULT pdb_modinfo_t::open(
        const char *input_file,
        const char *user_spath,
        ea_t load_address)
{
  QASSERT(30212, type_cache == nullptr);
  pdbargs_t args;
  args.input_path = input_file;
  args.spath = user_spath;
  args.loaded_base = load_address;
  HRESULT hr = E_FAIL;
  {
    msg("PDB: using MSDIA provider\n");
    #ifdef ENABLE_REMOTEPDB
    if ( is_win32_remote_debugger_loaded() )
    {
      args.flags |= PDBFLG_DBG_MODULE;
      remote_pdb_access_t *rpdb_access = new remote_pdb_access_t(
              args,
              "TESTER-SQUISH",
              23946,
              "");
      hr = rpdb_access->open_connection();
      if ( hr == S_OK )
        pdb_access = rpdb_access;
      else
        delete rpdb_access;
    }
    #else // ENABLE_REMOTEPDB
    hr = session_ref.open_session(args);
    if ( hr == S_OK )
      pdb_access = session_ref.session->pdb_access;
    #endif // ENABLE_REMOTEPDB
  }
  if ( hr == S_OK )
  {
    type_cache = new til_builder_t(pv, CONST_CAST(til_t *)(get_idati()), nullptr);
    type_cache->set_pdb_access(pdb_access);
  }
  return hr;
}

//-------------------------------------------------------------------------
source_item_t *pdb_modinfo_t::find_static_item_in_module(
        const char *iname)
{
  if ( !opened )
    return nullptr;

  DWORD id = 0;
  module_globals_t::iterator p = module_globals.find(iname);
  if ( p != module_globals.end() )
  {
    id = p->second;
  }
  else
  {
    struct ida_local iter_t : public pdb_access_t::children_visitor_t
    {
      pdb_modinfo_t *pdb_module;
      const char *name;
      DWORD id;
      iter_t(
              pdb_modinfo_t *_pdb_module,
              const char *_name)
        : pdb_module(_pdb_module), name(_name), id(0) {}
      virtual HRESULT visit_child(pdb_sym_t &data) override
      {
        qstring cname;
        if ( data.get_name(&cname) == S_OK && cname == name )
          data.get_symIndexId(&id);
        return id == 0 ? S_OK : E_FAIL; // 'id' still 0? keep iterating
      }
    };
    iter_t iter(this, iname);
    pdb_sym_t *global = get_access()->create_sym(get_access()->get_global_symbol_id());
    pdb_sym_janitor_t janitor_global(global);
    get_access()->iterate_children(*global, SymTagData, iter);
    id = iter.id;
    module_globals[iname] = id; // populate
  }
  return id != 0 ? new_pdb_symbol(this, id) : nullptr;
}

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------
bool pdb_ctx_t::get_pdb_register_info(int *p_reg, uint64 *p_mask, int machine, int reg)
{
  qstring name;
  print_pdb_register(&name, machine, reg);
  reg_info_t ri;
  if ( !parse_reg_name(&ri, name.c_str()) )
    return false;
  *p_reg = ri.reg;
  *p_mask = left_shift(uint64(1), 8*ri.size) - 1;
  return true;
}

//--------------------------------------------------------------------------
struct pdb_source_file_t : public source_file_t
{
  pdb_modinfo_t *pdb_module;
  DWORD file_id;
  qstring my_path;

  pdb_source_file_t(pdb_modinfo_t *_mod, DWORD _fid)
    : pdb_module(_mod), file_id(_fid) {}

  srcinfo_provider_t *idaapi get_provider(void) const override;
  virtual ~pdb_source_file_t(void) {}
  virtual void idaapi release() override { delete this; }
  const char *idaapi get_path(qstring *errbuf) override
  {
    if ( my_path.empty() )
    {
      pdb_module->get_access()->sip_retrieve_file_path(
              &my_path,
              errbuf,
              file_id);
    }
    return my_path.c_str();
  }

  bool idaapi read_file(strvec_t *buf, qstring *errbuf) override
  {
    buf->clear();
    const char *path = get_path(errbuf);

    // Always favor file mapping first.
    qstring mapbuf = path;
    callui(ui_dbg_map_source_path, &mapbuf);
    path = mapbuf.c_str();

    if ( !qfileexist(path) )
    {
      if ( errbuf != nullptr )
        errbuf->sprnt("source file not found: %s", path);
      return false;
    }

    FILE *fp = fopenRT(path);
    if ( fp == nullptr )
    {
      if ( errbuf != nullptr )
        *errbuf = get_errdesc(path);
      return false;
    }

    int tabsize = get_tab_size(path);
    qstring line;
    while ( qgetline(&line, fp) >= 0 )
    {
      simpleline_t &sl = buf->push_back();
      sl.line.clear();
      replace_tabs(&sl.line, line.c_str(), tabsize);
    }

    qfclose(fp);
    return true;
  }

  TWidget *open_srcview(strvec_t ** /*strvec*/, TWidget ** /*pview*/, int, int) override
  {
    return nullptr;
  }
};

//--------------------------------------------------------------------------
struct pdb_file_iterator : public _source_file_iterator
{
  struct entry_t
  {
    pdb_modinfo_t *pdb_module;
    DWORD file_id;
  };
  qvector<entry_t> entries;
  int idx;

  pdb_file_iterator() : idx(-1) {}
  virtual ~pdb_file_iterator(void) {}

  virtual void idaapi release(void) override { delete this; }
  bool idaapi first(void) override
  {
    idx = -1;
    return next();
  }

  bool idaapi next(void) override
  {
    ++idx;
    return idx < entries.size();
  }

  source_file_ptr idaapi operator *() override
  {
    const entry_t &e = entries[idx];
    return source_file_ptr(
            new pdb_source_file_t(e.pdb_module, e.file_id));
  }
};

//--------------------------------------------------------------------------
// Dummy source item: provides no information.
struct dummy_item_t : public source_item_t
{
  pdb_modinfo_t *pdb_module;

  dummy_item_t(pdb_modinfo_t *_pdb_module) : pdb_module(_pdb_module) {}
  virtual ~dummy_item_t(void) { pdb_module = nullptr; }
  void idaapi release(void) override { delete this; }
  source_file_iterator idaapi get_source_files(void) override { return source_file_iterator(nullptr); }
  int idaapi get_lnnum() const override { return -1; }
  int idaapi get_end_lnnum() const override { return -1; }
  int idaapi get_colnum() const override { return -1; }
  int idaapi get_end_colnum() const override { return -1; }
  ea_t idaapi get_ea() const override { return BADADDR; }
  asize_t idaapi get_size() const override { return 0; }
  bool idaapi get_item_bounds(rangeset_t *set) const override
  {
    ea_t ea = get_ea();
    if ( ea == BADADDR )
      return false;
    asize_t size = get_size();
    set->add(range_t(ea, ea+size));
    return true;
  }
  source_item_ptr idaapi get_parent(src_item_kind_t) const override { return source_item_ptr(nullptr); }
  source_item_iterator idaapi create_children_iterator() override { return source_item_iterator(nullptr); }
  bool idaapi get_hint(qstring *hint, const eval_ctx_t *, int *nlines) const override
  {
    // TODO: remove these test lines
    *hint = "test";
    *nlines = 1;
    return true;
  }
  bool idaapi evaluate(const eval_ctx_t *, idc_value_t *, qstring *) const override { return false; }
  // bool idaapi get_stkvar_info(char *, size_t, uval_t *, ea_t) const { return false; }
  // bool idaapi get_regvar_info(char *, size_t) const { return false; }
  // bool idaapi get_rrlvar_info(char *, size_t, uval_t *) const { return false; }
  bool idaapi get_expr_tinfo(tinfo_t *) const override { return false; }

  virtual bool idaapi get_location(argloc_t *, const eval_ctx_t *) const override { return false; }

  virtual srcinfo_provider_t *idaapi get_provider(void) const override;
};

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------
bool pdb_lnnums_t::get_item_bounds(rangeset_t *set) const
{
  for ( size_t i = 0, sz = size(); i < sz; ++i )
  {
    const pdb_lnnum_t &ln = at(i);
    set->add(ln.va, ln.va + ln.length);
  }
  return !set->empty();
}

//-------------------------------------------------------------------------
int pdb_lnnums_t::get_lnnum() const
{
  return empty() ? -1 : at(0).lineNumber;
}

//-------------------------------------------------------------------------
int pdb_lnnums_t::get_colnum() const
{
  return empty() ? -1 : at(0).columnNumber;
}

//-------------------------------------------------------------------------
int pdb_lnnums_t::get_end_lnnum() const
{
  return empty() ? -1 : at(size() - 1).lineNumber; //should it be lineNumberEnd; ?
}

//-------------------------------------------------------------------------
int pdb_lnnums_t::get_end_colnum() const
{
  return empty() ? -1 : at(size() - 1).columnNumber; //should it be columnNumberEnd; ?
}


//--------------------------------------------------------------------------
//                               pdb_item_iterator
//--------------------------------------------------------------------------
struct pdb_item_iterator : public _source_item_iterator
{
  pdb_modinfo_t *pdb_module;
  source_items_vec_t items;
  int index;

  pdb_item_iterator(pdb_modinfo_t *_mod, source_items_vec_t &_items)
    : pdb_module(_mod), index(-1)
  {
    items.swap(_items);
  }

  virtual ~pdb_item_iterator(void) {}

  void idaapi release(void) override
  {
    delete this;
  }

  bool idaapi first(void) override
  {
    index = -1;
    return next();
  }

  bool idaapi next(void) override
  {
    ++index;
    return index < items.size();
  }

  source_item_ptr idaapi operator *() override
  {
    return items[index];
  }
};


//-------------------------------------------------------------------------
//                               pdb_symbol_t
//--------------------------------------------------------------------------
// source item based on dia symbol
class pdb_symbol_t : public dummy_item_t
{
  pdb_sym_t *sym;
  mutable pdb_lnnums_t lnnums; // cached ptr to line number enumerator
  src_item_kind_t kind;
  bool own_sym;

  bool init_lnnums() const
  {
    if ( !lnnums.inited )
    {
      ULONGLONG va;
      if ( sym->get_virtualAddress(&va) == S_OK )
      {
        ULONGLONG length;
        if ( sym->get_length(&length) == S_OK )
        {
          pdb_access_t *pa = pdb_module->get_access();
          if ( pa->sip_retrieve_lines_by_va(&lnnums, va, length) == S_OK )
            lnnums.inited = true;
        }
      }
    }
    return lnnums.inited;
  }

public:
  pdb_symbol_t(pdb_modinfo_t *_pdb_module,
               pdb_sym_t *_sym,
               bool _own_sym,
               src_item_kind_t k)
    : dummy_item_t(_pdb_module),
      sym(_sym),
      kind(k),
      own_sym(_own_sym)
  {
  }

  virtual ~pdb_symbol_t(void)
  {
    if ( own_sym )
      delete sym;
  }

  pdb_sym_t *get_pdb_sym() { return sym; }

  source_file_iterator idaapi get_source_files(void) override
  {
    pdb_file_iterator *ret = nullptr;
    qvector<DWORD> ids;
    HRESULT hr = pdb_module->get_access()->sip_retrieve_symbol_files(
            &ids, *sym);
    if ( hr == S_OK )
    {
      ret = new pdb_file_iterator();
      for ( size_t i = 0; i < ids.size(); ++i )
      {
        pdb_file_iterator::entry_t &e = ret->entries.push_back();
        e.pdb_module = pdb_module;
        e.file_id = ids[i];
      }
    }
    return source_file_iterator(ret);
  }

  bool idaapi get_name(qstring *buf) const override
  {
    return sym->get_name(buf) == S_OK;
  }

  int idaapi get_lnnum() const override
  {
    return init_lnnums() ? lnnums.get_lnnum() : 0;
  }

  int idaapi get_end_lnnum() const override
  {
    return init_lnnums() ? lnnums.get_end_lnnum() : 0;
  }

  int idaapi get_colnum() const override
  {
    return init_lnnums() ? lnnums.get_colnum() : 0;
  }

  int idaapi get_end_colnum() const override
  {
    if ( !init_lnnums() )
      return 0;
    return lnnums.get_end_colnum();
  }

  ea_t idaapi get_ea() const override
  {
    ULONGLONG va = ULONGLONG(-1);
    return FAILED(sym->get_virtualAddress(&va)) ? BADADDR : va;
  }

  asize_t idaapi get_size() const override
  {
    ULONGLONG len = 0;
    return FAILED(sym->get_length(&len)) ? BADADDR : len;
  }

  bool idaapi get_item_bounds(rangeset_t *set) const override
  {
    return init_lnnums() && lnnums.get_item_bounds(set);
  }

  source_item_ptr idaapi get_parent(src_item_kind_t /*max_kind*/) const override
  {
    source_item_t *ret = nullptr;
    pdb_sym_t *lpar = pdb_module->get_access()->create_sym();
    pdb_sym_janitor_t janitor_lpar(lpar);
    DWORD par_id = 0;
    if ( sym->get_lexicalParent(lpar) == S_OK
      && lpar->get_symIndexId(&par_id) == S_OK )
    {
      ret = new_pdb_symbol(pdb_module, par_id);
    }
    return source_item_ptr(ret);
  }

  source_item_iterator idaapi create_children_iterator() override;

  // TODO: not implemented yet
  /*bool idaapi get_hint(qstring *hint, const eval_ctx_t *ctx, int *nlines) const
  {
    return false;
  }*/

  bool idaapi evaluate(const eval_ctx_t * /*ctx*/, idc_value_t * /*res*/, qstring * /*errbuf*/) const override
  {
    // not implemented yet
    return false;
  }

  virtual src_item_kind_t idaapi get_item_kind(const eval_ctx_t * /*ctx*/) const override
  {
    return kind;
  }

  virtual bool idaapi get_location(argloc_t *out, const eval_ctx_t *) const override
  {
    DWORD loctype = LocIsNull;
    HRESULT hr = sym->get_locationType(&loctype);
    if ( FAILED(hr) )
      return false;
    bool ok = false;
    int machine = pdb_module->get_access()->get_machine_type();
    switch ( loctype )
    {
      case LocIsRegRel:
        {
          DWORD dwReg = 0;
          LONG lOffset;
          if ( sym->get_registerId(&dwReg) == S_OK
            && sym->get_offset(&lOffset) == S_OK )
          {
            int regno;
            uint64 mask;
            if ( pdb_module->pv.get_pdb_register_info(&regno, &mask, machine, dwReg) )
            {
              rrel_t *rrel = new rrel_t();
              rrel->reg = regno;
              rrel->off = lOffset;
              out->consume_rrel(rrel);
              ok = true;
            }
          }
        }
        break;
      case LocIsEnregistered:
        {
          DWORD dwReg = 0;
          if ( sym->get_registerId(&dwReg) == S_OK )
          {
            int regno;
            uint64 mask;
            if ( pdb_module->pv.get_pdb_register_info(&regno, &mask, machine, dwReg) )
            {
              out->set_reg1(regno, 0); // off=0?
              ok = true;
            }
          }
        }
        break;
      default:
        break;
    }
    return ok;
  }

  bool idaapi get_expr_tinfo(tinfo_t *tif) const override
  {
    til_builder_t::tpinfo_t tpi;
    bool res = pdb_module->type_cache->retrieve_type(&tpi, *sym, nullptr);

    *tif = tpi.type;

    if ( (debug & IDA_DEBUG_SRCDBG) != 0 )
    {
      qstring type_str;
      tpi.type.print(&type_str);
      DWORD sym_id = 0;
      sym->get_symIndexId(&sym_id);
      qstring name;
      deb(IDA_DEBUG_SRCDBG, "Retrieved type for %s (symbol #%u): %s\n",
          get_name(&name) ? name.c_str() : "<unnamed>",
          sym_id,
          type_str.c_str());
    }

    return res;
  }

  bool idaapi equals(const source_item_t *othr) const override
  {
    DWORD this_id, other_id;
    pdb_symbol_t *other = (pdb_symbol_t*) othr;
    return other != nullptr
        && other->sym != nullptr
        && pdb_module == other->pdb_module
        && sym->get_symIndexId(&this_id) == S_OK
        && other->sym->get_symIndexId(&other_id) == S_OK
        && this_id == other_id;
  }
};

//--------------------------------------------------------------------------
source_item_iterator idaapi pdb_symbol_t::create_children_iterator()
{
  pdb_item_iterator *ret = nullptr;
  source_items_vec_builder_t items_builder(pdb_module);
  if ( pdb_module->get_access()->iterate_children(
               *sym, SymTagNull, items_builder) == S_OK )
    ret = new pdb_item_iterator(pdb_module, items_builder.items);
  return source_item_iterator(ret);
}

//--------------------------------------------------------------------------
class pdb_lnnum_item_t : public dummy_item_t
{
  pdb_lnnum_t *lnnum;        // we do not own this pointer

public:
  pdb_lnnum_item_t(pdb_modinfo_t *_pdb_module, pdb_lnnum_t *l)
    : dummy_item_t(_pdb_module),
      lnnum(l) {}

  virtual ~pdb_lnnum_item_t(void) {}

  virtual source_file_iterator idaapi get_source_files(void) override
  {
    pdb_file_iterator *ret = nullptr;
    if ( lnnum->file_id != DWORD(-1) )
    {
      ret = new pdb_file_iterator();
      pdb_file_iterator::entry_t &e = ret->entries.push_back();
      e.pdb_module = pdb_module;
      e.file_id = lnnum->file_id;
    }
    return source_file_iterator(ret);
  }

  virtual bool idaapi get_name(qstring *) const override
  {
    return false;
  }

  virtual int idaapi get_lnnum() const override
  {
    return lnnum->lineNumber;
  }

  virtual int idaapi get_end_lnnum() const override
  {
    return lnnum->lineNumberEnd;
  }

  virtual int idaapi get_colnum() const override
  {
    return lnnum->columnNumber;
  }

  virtual int idaapi get_end_colnum() const override
  {
    return lnnum->columnNumberEnd;
  }

  virtual ea_t idaapi get_ea() const override
  {
    return ea_t(lnnum->va);
  }

  virtual asize_t idaapi get_size() const override
  {
    return lnnum->length;
  }

  virtual src_item_kind_t idaapi get_item_kind(const eval_ctx_t * /*ctx*/) const override
  {
    return lnnum->statement ? SRCIT_STMT : SRCIT_EXPR;
  }

  virtual source_item_ptr idaapi get_parent(src_item_kind_t /*max_kind*/) const override
  {
    source_item_t *ret = nullptr;
    ea_t ea = get_ea();
    if ( ea != BADADDR )
    {
      source_items_vec_builder_t items_builder(pdb_module);
      HRESULT hr = pdb_module->get_access()->sip_iterate_symbols_at_ea(
              ea, /*size=*/ 1, SymTagFunction, items_builder);
      if ( hr == S_OK && !items_builder.items.empty() )
      {
        DWORD sym_id = 0;
        pdb_symbol_t &pit = (pdb_symbol_t &) *items_builder.items[0];
        hr = pit.get_pdb_sym()->get_symIndexId(&sym_id);
        if ( hr == S_OK )
          ret = new_pdb_symbol(pdb_module, sym_id);
      }
    }
    return source_item_ptr(ret);
  }

  bool idaapi equals(const source_item_t *othr) const override
  {
    pdb_lnnum_item_t *other = (pdb_lnnum_item_t*) othr;
    return other != nullptr
        && other->lnnum != nullptr
        && lnnum->va != BADADDR
        && other->lnnum->va != BADADDR
        && lnnum->va == other->lnnum->va;
  }
};

//-------------------------------------------------------------------------
static src_item_kind_t find_srcitem_kind(pdb_sym_t *sym)
{
  src_item_kind_t kind = SRCIT_NONE;
  DWORD tag = 0;
  HRESULT hr = sym->get_symTag(&tag);
  if ( hr == S_OK )
  {
    switch ( tag )
    {
      case SymTagFunction:
        kind = SRCIT_FUNC;
        break;

      case SymTagBlock:
        kind = SRCIT_STMT;
        break;

      case SymTagData:
      case SymTagPublicSymbol:
        {
          DWORD loctype = LocIsNull;
          sym->get_locationType(&loctype);
          switch ( loctype )
          {
            case LocIsStatic:
            case LocIsTLS:
              kind = SRCIT_STTVAR;
              break;

            case LocIsRegRel:
              DWORD dwReg;
              if ( sym->get_registerId(&dwReg) == S_OK
                && (dwReg == CV_REG_EBP || dwReg == CV_AMD64_RSP || dwReg == CV_ARM64_SP) )
              {
                kind = SRCIT_LOCVAR;
              }
              break;

            case LocIsEnregistered:
              kind = SRCIT_LOCVAR;
              break;
          }
        }
        break;
    }
  }
  return kind;
}

//--------------------------------------------------------------------------
static source_item_t *new_pdb_symbol(pdb_modinfo_t *pdb_module, DWORD sym_id)
{
  pdb_sym_t *sym = pdb_module->get_access()->create_sym(sym_id);
  src_item_kind_t kind = find_srcitem_kind(sym);
  if ( kind != SRCIT_NONE )
    return new pdb_symbol_t(pdb_module, sym, /*own=*/ true, kind);
  delete sym;
  return nullptr;
}

//--------------------------------------------------------------------------
static source_item_t *new_pdb_symbol_or_delete(pdb_modinfo_t *pdb_module, pdb_sym_t *sym)
{
  src_item_kind_t kind = find_srcitem_kind(sym);
  if ( kind != SRCIT_NONE )
    return new pdb_symbol_t(pdb_module, sym, /*own=*/ true, kind);
  delete sym;
  return nullptr;
}

//--------------------------------------------------------------------------
class pdb_provider_t : public srcinfo_provider_t
{
  pdb_ctx_t &pv;
  pdb_modules_t modules;
  qstring search_path;
  pdb_modinfo_t *open_module(pdb_modules_t::iterator p)
  {
    pdb_modinfo_t &mod = p->second;
    if ( !mod.opened )
    {
      msg("PDBSRC: loading symbols for '%s'...\n", mod.path.c_str());
      HRESULT hr = mod.open(mod.path.c_str(), search_path.c_str(), mod.base);
      if ( FAILED(hr) )
      { // failed to open the corresponding pdb file
        modules.erase(p);
        return nullptr;
      }
      mod.opened = true;
    }
    return &mod;
  }
  pdb_modinfo_t *find_module(ea_t ea)
  {
    deb(IDA_DEBUG_SRCDBG, "PDB: find_module(%a)\n", ea);
    pdb_modules_t::iterator p = modules.lower_bound(ea);
    if ( p == modules.end() || p->first > ea )
    {
      if ( p == modules.begin() )
        return nullptr; // could not find the module

      --p;
      if ( p->first > ea || p->first+p->second.size <= ea )
        return nullptr;
    }
    return open_module(p);
  }
  pdb_modinfo_t *find_module(const char *path)
  {
    deb(IDA_DEBUG_SRCDBG, "PDB: find_module(%s)\n", path);
    pdb_modules_t::iterator p = modules.begin();
    for ( ; p != modules.end(); ++p )
      if ( p->second.path == path )
        return &p->second;
    return nullptr;
  }

public:
  bool idaapi enable_provider(bool enable) override;
  const char *idaapi set_options(const char *keyword, int value_type, const void *value) override;
  void idaapi add_module(const char *path, ea_t base, asize_t size) override;
  void idaapi del_module(ea_t base) override;
  void idaapi get_ready(void) override;
  int idaapi get_change_flags(void) override;
  source_item_iterator idaapi find_source_items(ea_t ea, asize_t size, src_item_kind_t level, bool) override;
  source_item_iterator idaapi find_source_items(source_file_t *sf, int lnnum, int colnum) override;
  source_file_iterator idaapi create_file_iterator(const char *filename) override;
  source_item_iterator idaapi create_item_iterator(const source_file_t *sf) override;
  bool idaapi apply_module_info(const char *path) override;
  source_item_ptr idaapi find_static_item(const char *name, ea_t ea) override;

  pdb_provider_t(pdb_ctx_t &_pv, const char *nm, const char *dnm)
    : srcinfo_provider_t(nm, dnm),
      pv(_pv)
  {}
  virtual ~pdb_provider_t(void) {}
};

//---------------------------------------------------------------------------
static bool is_pdb_supported(void)
{
  // PE files.
  filetype_t ftype = inf_get_filetype();
  if ( ftype == f_PE )
    return true;

  // Otherwise check for debugger.
  if ( dbg == nullptr )
    return false;

  // Win32 debugger.
  qstring platform;
  debapp_attrs_t pattrs;
  if ( dbg->get_debapp_attrs(&pattrs) )
    platform.swap(pattrs.platform);
  else
    platform = dbg->name;
  if ( platform.find("win32") != qstring::npos )
    return true;

  // Some other debugger (e.g.: "gdb") with unknown filetype.
  // This is needed to debug windows kernels under VMware.
  if ( ftype == 0 )
    return true;

  return false;
}

//--------------------------------------------------------------------------
bool idaapi pdb_provider_t::enable_provider(bool enable)
{
  if ( enable )
  {
    if ( !is_pdb_supported() )
      return false;
    pv.init_sympaths();
    if ( pv.full_sympath.empty() )
      search_path.qclear();
    else
      search_path = pv.full_sympath;
  }
  return enable;
}

//--------------------------------------------------------------------------
const char *idaapi pdb_provider_t::set_options(
        const char * /*keyword*/,
        int /*value_type*/,
        const void * /*value*/)
{
  // todo: add option to set search path
  return IDPOPT_BADKEY;
}

//--------------------------------------------------------------------------
void idaapi pdb_provider_t::add_module(
        const char *path,
        ea_t base,
        asize_t size)
{
  deb(IDA_DEBUG_DEBUGGER, "PDB: add_module(%s, [%a -> %a))\n", path, base, ea_t(base + size));
  pdb_modinfo_t &mod = modules[base];
  mod.path = path;
  mod.base = base;
  mod.size = size;
  // do not open the module immediately, we will do it only when we
  // really need the module
  mod.opened     = false;
  mod.type_cache = nullptr;
}


//--------------------------------------------------------------------------
void idaapi pdb_provider_t::del_module(ea_t base)
{
  modules.erase(base);
}

//--------------------------------------------------------------------------
void idaapi pdb_provider_t::get_ready(void)
{
  // nothing to do
}

//--------------------------------------------------------------------------
int idaapi pdb_provider_t::get_change_flags(void)
{
  // nothing ever changes?
  return 0;
}

//--------------------------------------------------------------------------
// Retrieve the line numbers into a map
// 'enumerator' will be freed by this function
static void lnnums_to_lnmap(lnmap_t *map, const pdb_lnnums_t &lnnums)
{
  const size_t lncnt = lnnums.size();
  if ( lncnt > 0 )
  {
    pdb_lnnum_vec_t vec;
    vec.resize(lncnt);
    for ( size_t i = 0; i < lncnt; ++i )
    {
      const pdb_lnnum_t &lnnum = lnnums[i];
      (*map)[lnnum.lineNumber].push_back(lnnum);
    }
  }
}

//--------------------------------------------------------------------------
class pdb_lnmap_iterator : public _source_item_iterator
{
  pdb_modinfo_t *pdb_module;
  lnmap_t lnmap;        // lnnum -> pdb_lnnum_vec_t
  pdb_lnnum_t *item;    // holds the answer after next()
  lnmap_t::iterator p;  // current lnnum
  size_t idx;           // current item on the line
public:

  pdb_lnmap_iterator(pdb_modinfo_t *_pdb_module, lnmap_t *map)
    : pdb_module(_pdb_module), item(nullptr), idx(0)
  {
    map->swap(lnmap);
    p = lnmap.end();
  }

  virtual ~pdb_lnmap_iterator(void)
  {
  }

  void idaapi release(void) override
  {
    delete this;
  }

  bool idaapi first(void) override
  {
    p = lnmap.begin();
    idx = 0;
    return next();
  }

  bool idaapi next(void) override
  {
    // at the end?
    if ( p == lnmap.end() )
      return false;

    size_t size = p->second.size();
    if ( idx >= size )
      return false;

    // remember the item to return when dereferenced
    item = &p->second[idx];

    // advance pointer
    if ( ++idx >= size )
    {
      // go to next pdb_lnnum_vec_t
      ++p;

      // reset the index in the vector
      idx = 0;
    }

    return true;
  }

  source_item_ptr idaapi operator *() override
  {
    pdb_lnnum_item_t *ret = new pdb_lnnum_item_t(pdb_module, item);
    return source_item_ptr(ret);
  }
};

//--------------------------------------------------------------------------
source_item_iterator idaapi pdb_provider_t::find_source_items(
        ea_t ea,
        asize_t size,
        src_item_kind_t level,
        bool)
{
  deb(IDA_DEBUG_SRCDBG, "PDB: find_source_items(ea=%a, size=%" FMT_64 "u)\n", ea, (uint64) size);
  pdb_item_iterator *ret = nullptr;
  pdb_modinfo_t *pdb_module = find_module(ea);
  if ( pdb_module != nullptr )
  {
    enum SymTagEnum tag;
    switch ( level )
    {
      default:
        INTERR(30171);

      case SRCIT_STMT:       // a statement (if/while/for...)
      case SRCIT_EXPR:       // an expression (a+b*c)
        {
          pdb_lnmap_iterator *ret2 = nullptr;
          pdb_lnnums_t lnnums;
          HRESULT hr = pdb_module->get_access()->sip_retrieve_lines_by_va(
                  &lnnums, ea, size);
          if ( hr == S_OK )
          {
            // Precompute the lines associated with the given address
            lnmap_t lnmap;
            lnnums_to_lnmap(&lnmap, lnnums);
            ret2 = new pdb_lnmap_iterator(pdb_module, &lnmap);
          }
          return source_item_iterator(ret2);
        }

      case SRCIT_FUNC:       // function
        tag = SymTagFunction;
        break;

      case SRCIT_LOCVAR:     // variable
        tag = SymTagData;
        break;
    }
    source_items_vec_builder_t items_builder(pdb_module);
    if ( pdb_module->get_access()->sip_iterate_symbols_at_ea(
                 ea, size, tag, items_builder) == S_OK )
    {
      ret = new pdb_item_iterator(pdb_module, items_builder.items);
    }
  }
  return source_item_iterator(ret);
}

//--------------------------------------------------------------------------
source_item_iterator idaapi pdb_provider_t::find_source_items(
        source_file_t *sf,
        int lnnum,
        int colnum)
{
  pdb_lnmap_iterator *ret = nullptr;
  pdb_source_file_t *psf = (pdb_source_file_t *)sf;
  pdb_lnnums_t lnnums;
  HRESULT hr = psf->pdb_module->get_access()->sip_retrieve_lines_by_coords(
          &lnnums, psf->file_id, lnnum, colnum);
  if ( hr == S_OK && !lnnums.empty() )
  {
    lnmap_t lnmap;
    lnnums_to_lnmap(&lnmap, lnnums);
    ret = new pdb_lnmap_iterator(psf->pdb_module, &lnmap);
  }
  return source_item_iterator(ret);
}

//--------------------------------------------------------------------------
static bool is_hexrays_filename(const char *fname)
{
  if ( fname != nullptr && *fname == '$' )
  {
    while ( true )
    {
      char c = *++fname;
      if ( c == '\0' )
        return true;
      if ( qislower(c) || !qisxdigit(c) )
        break;
    }
  }
  return false;
}

//--------------------------------------------------------------------------
source_file_iterator idaapi pdb_provider_t::create_file_iterator(const char *filename)
{
  pdb_file_iterator *ret = nullptr;
  // hack: check if the filename is like "$12345678"
  // if so, immediately return because such names are used by the decompiler sip
  if ( !is_hexrays_filename(filename) )
  {
    ret = new pdb_file_iterator();

    // Get a source file item iterators from each module
    for ( pdb_modules_t::iterator p=modules.begin(); p != modules.end(); )
    {
      pdb_modinfo_t *m = open_module(p++);
      if ( m != nullptr )
      {
        qvector<DWORD> files_ids;
        m->get_access()->sip_find_files(&files_ids, filename);
        for ( size_t i = 0; i < files_ids.size(); ++i )
        {
          pdb_file_iterator::entry_t &e = ret->entries.push_back();
          e.pdb_module = m;
          e.file_id = files_ids[i];
        }
      }
    }

    if ( ret->entries.empty() )
    {
      delete ret;
      ret = nullptr;
    }
  }
  return source_file_iterator(ret);
}

//--------------------------------------------------------------------------
source_item_iterator idaapi pdb_provider_t::create_item_iterator(const source_file_t *sf)
{
  pdb_source_file_t *psf = (pdb_source_file_t *) sf;
  pdb_item_iterator *ret = nullptr;
  pdb_modinfo_t *mod = psf->pdb_module;
  source_items_vec_builder_t svec_builder(mod);
  if ( mod->get_access()->sip_iterate_file_compilands(
               psf->file_id, svec_builder) == S_OK )
  {
    ret = new pdb_item_iterator(mod, svec_builder.items);
  }
  return source_item_iterator(ret);
}

//-------------------------------------------------------------------------
bool idaapi pdb_provider_t::apply_module_info(const char *path)
{
#ifdef ENABLE_REMOTEPDB
  if ( !is_win32_remote_debugger_loaded() )
    return false;
#endif

  pdb_modinfo_t *module = find_module(path);
  if ( module == nullptr )
    return false;
  pdbargs_t pdbargs;
  pdbargs.flags = PDBFLG_DBG_MODULE;
  if ( (inf_get_filetype() == f_PE || is_miniidb()) )
    pdbargs.flags |= PDBFLG_LOAD_NAMES;
  else
    pdbargs.flags |= PDBFLG_LOAD_TYPES;
  pdbargs.loaded_base = module->base;
  pdbargs.input_path = module->path.c_str();

  static const char form[] =
    "Load PDB file\n"
    "\n"
    "%A\n"
    "<#Load types#Load ~t~ypes:C" QSTRINGIZE(LOAD_TYPES_FIELD) ">\n"
    "<#Load names#Load ~n~ames:C" QSTRINGIZE(LOAD_NAMES_FIELD) ">>\n";
  sval_t load_options = 0;
  setflag(load_options, LOAD_TYPES, (pdbargs.flags & PDBFLG_LOAD_TYPES) != 0);
  setflag(load_options, LOAD_NAMES, (pdbargs.flags & PDBFLG_LOAD_NAMES) != 0);
  const char *input_path = pdbargs.input_path.c_str();
  if ( !ask_form(form, input_path, &load_options) )
    return false;
  setflag(pdbargs.flags, PDBFLG_LOAD_TYPES, (load_options & LOAD_TYPES) != 0);
  setflag(pdbargs.flags, PDBFLG_LOAD_NAMES, (load_options & LOAD_NAMES) != 0);

  show_wait_box("HIDECANCEL\nRetrieving symbol information from '%s'",
                qbasename(module->path.c_str()));
  // pdb_path: cleared
  // input_path: module name
  // loaded_base: module base
  bool rc = pv.apply_debug_info(pdbargs);
  hide_wait_box();
  return rc;
}

//-------------------------------------------------------------------------
source_item_ptr idaapi pdb_provider_t::find_static_item(
        const char *iname,
        ea_t ea)
{
  source_item_t *si = nullptr;
  pdb_modinfo_t *pdb_module = find_module(ea);

  // find in current module
  if ( pdb_module != nullptr )
    si = pdb_module->find_static_item_in_module(iname);

  // not found? search in other modules
  if ( si == nullptr )
  {
    pdb_modules_t::iterator p = modules.begin();
    for ( ; si == nullptr && p != modules.end(); ++p )
      if ( &p->second != pdb_module )
        si = p->second.find_static_item_in_module(iname);
  }

  return source_item_ptr(si);
}

//-------------------------------------------------------------------------
HRESULT source_items_vec_builder_t::visit_child(pdb_sym_t &child)
{
  pdb_sym_t *cur = pdb_module->get_access()->create_sym();
  cur->steal_data(child);
  source_item_t *si = new_pdb_symbol_or_delete(pdb_module, cur);
  if ( si != nullptr )
    items.push_back(source_item_ptr(si));
  return S_OK;
}

//--------------------------------------------------------------------------
void pdb_ctx_t::alloc_pdb_srcinfo_provider()
{
  pdb_srcinfo_provider = new pdb_provider_t(*this, "PDB", "PDB");
}

void pdb_ctx_t::free_pdb_srcinfo_provider()
{
  delete pdb_srcinfo_provider;
  pdb_srcinfo_provider = nullptr;
}

//----------------------------------------------------------------------------
srcinfo_provider_t *idaapi pdb_source_file_t::get_provider(void) const
{
  return pdb_module->pv.pdb_srcinfo_provider;
}

//----------------------------------------------------------------------------
srcinfo_provider_t *idaapi dummy_item_t::get_provider(void) const
{
  return pdb_module->pv.pdb_srcinfo_provider;
}

```

`sip.hpp`:

```hpp

#ifndef PDB_SIP_H
#define PDB_SIP_H

bool apply_debug_info(pdbargs_t &pdbargs);

#include "pdbaccess.hpp"

#endif // PDB_SIP_H

```

`stdafx.cpp`:

```cpp
// <copyright file="stdafx.cs" company="Microsoft Corporation">
// Copyright (C) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt in the project root for license information.
// </copyright>

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`stdafx.h`:

```h
// <copyright file="stdafx.h" company="Microsoft Corporation">
// Copyright (C) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt in the project root for license information.
// </copyright>

#pragma once

#include "targetver.h"

#define _CRT_SECURE_NO_WARNINGS
#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <crtdbg.h>
#include <comip.h>
#include <comdef.h>
#include <comutil.h>

#include <algorithm>
#include <iostream>
#include <memory>
#include <vector>

#include <Setup.Configuration.h>
#include "Helpers.h"

#include <atlstr.h>

#include "misc.h"

#pragma comment(lib,"Version.lib")
```

`targetver.h`:

```h
// <copyright file="targetver.h" company="Microsoft Corporation">
// Copyright (C) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt in the project root for license information.
// </copyright>

#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <winsdkver.h>

#ifdef  _WIN32_WINNT
#undef  _WIN32_WINNT
#endif

#define _WIN32_WINNT 0x0601

#include <SDKDDKVer.h>

```

`tilbuild.cpp`:

```cpp

#include "tilbuild.hpp"
#include "misc.cpp"

//#define PDEB
//#define PDEBSYM
#ifdef PDEB
#define ddeb(x) _ddeb x
AS_PRINTF(1, 2) inline void _ddeb(const char *format, ...)
{
  va_list va;
  va_start(va, format);
  vmsg(format, va);
  va_end(va);
}

void dump_pdb_udt(const pdb_udt_type_data_t &udt, const char *udt_name)
{
  static size_t udt_counter = 0;
  ++udt_counter;
  msg("PDEB: %" FMT_Z " %s '%s' total_size %" FMT_Z " taudt_bits 0x%X is_union %s\n",
      udt_counter,
      udt.is_union ? "union" : "struct",
      udt_name != nullptr ? udt_name : "",
      udt.total_size,
      udt.taudt_bits,
      udt.is_union ? "Yes" : "No");
  for ( int i=0; i < udt.size(); i++ )
  {
    const pdb_udm_t &zudm = udt[i];
    msg("  %d. offset 0x%" FMT_64 "X size 0x%" FMT_64 "X '%s' type '%s' effalign %d tafld_bits 0x%X fda %d bit_offset %u\n",
        i,
        zudm.offset,
        zudm.size,
        zudm.name.c_str(),
        zudm.type.dstr(),
        zudm.effalign,
        zudm.tafld_bits,
        zudm.fda,
        zudm.bit_offset);
  }
}
#else
#define ddeb(x) (void)0
void dump_pdb_udt(const pdb_udt_type_data_t &, const char *) {}
#endif

static const char fake_vtable_type[] = "$vt";

//----------------------------------------------------------------------------
void til_builder_t::remove_anonymous_namespaces(qstring &buf)
{
  char *p = buf.begin();
  while ( true )
  {             // 1234567890
    p = strstr(p, "`anonymous");
    if ( p == nullptr )
      break;
    const char *q = p + 10;
    if ( *q != '-' && *q != ' ' )
      break;
    if ( strncmp(q+1, "namespace'::", 12) != 0 )
      break;      // 123456789012
    size_t idx = p - buf.begin();
    buf.remove(idx, 10+1+12);
    p = buf.begin() + idx;
  }
}

//-------------------------------------------------------------------------
static inline bool ident_char(char c)
{
  return c == '_' || qisalnum(c);
}

//----------------------------------------------------------------------------
bool til_builder_t::get_symbol_name(pdb_sym_t &sym, qstring &buf)
{
  bool is_unnamed = false;
  sym.get_name(&buf);
  if ( buf.empty() )
  {
    is_unnamed = true;
  }
  else
  {
    //
    remove_anonymous_namespaces(buf);

    // <unnamed-tag>  => <unnamed_tag>
    // <unnamed-type-xxx> => <unnamed_type_xxx>
    char *p = buf.begin();
    while ( true )
    {
      //             012345678
      p = strstr(p, "<unnamed");
      if ( p == nullptr )
        break;
      if ( p == buf.begin() )
        is_unnamed = true;
      p += 8;
      while ( *p != '\0' )
      {
        if ( *p == '>' )
        {
          p++;
          break;
        }
        else if ( *p == '-' )
        {
          *p = '_';
        }
        p++;
      }
    }
    if ( !is_unnamed )
    {
      const char *marker = strstr(buf.begin(), "__unnamed");
      if ( marker != nullptr
        // Is prev char not a valid identifier char?
        && (marker == buf.begin() || !ident_char(marker[-1]))
        // Is next char not a valid identifier char?
        && !ident_char(marker[9]) )
      {
        is_unnamed = true;
      }
    }
  }
  return is_unnamed;
}

//----------------------------------------------------------------------------
bool til_builder_t::get_symbol_type(tpinfo_t *out, pdb_sym_t &sym, uint32 *p_ord)
{
#ifdef PDEBSYM
  static int zz=0; ++zz;
  int zzz = zz;
  qstring sym_name;
  sym.get_name(&sym_name);
  DWORD sym_id = 0;
  sym.get_symIndexId(&sym_id);
  msg("PDEB: %d: get_symbol_type sym_id=%d '%s'\n", zzz, sym_id, sym_name.c_str());
#endif
  pdb_sym_t *pType = pdb_access->create_sym();
  pdb_sym_janitor_t janitor_pType(pType);
  if ( sym.get_type(pType) != S_OK )
    return false;
  bool ok = retrieve_type(out, *pType, nullptr, p_ord);
#ifdef PDEBSYM
  DWORD typsym_id = 0;
  pType->get_symIndexId(&typsym_id);
  msg("PDEB: %d: get_symbol_type typsym_id=%d tif='%s' ok=%d\n", zzz, typsym_id, out->type.dstr(), ok);
#endif
  return ok;
}

//----------------------------------------------------------------------------
bool til_builder_t::fix_ctor_to_return_ptr(func_type_data_t *fti, pdb_sym_t *parent)
{
  if ( inf_get_app_bitness() != 32 || parent == nullptr )
    return false;

  // detect constructor
  if ( fti->empty() || !fti->rettype.is_void() )
    return false;
  const auto &arg0 = fti->at(0);
  if ( !arg0.type.is_ptr() )
    return false;
  tinfo_t class_type = arg0.type.get_pointed_object();
  qstring class_name;
  if ( !class_type.get_type_name(&class_name) )
    return false;

  qstring funcname;
  parent->get_name(&funcname);
  qstring ctor_name;
  ctor_name.sprnt("%s::%s", class_name.c_str(), class_name.c_str());
  if ( ctor_name != funcname )
    return false;

  ddeb(("PDEB: detected constructor %s\n", funcname.c_str()));

  // do not set FTI_CTOR, normally IDA ignores ctor/dtor return type
  fti->flags &= ~FTI_CTOR;
  fti->rettype = arg0.type;
  return true;
}

//----------------------------------------------------------------------------
size_t til_builder_t::get_symbol_type_length(pdb_sym_t &sym) const
{
  DWORD64 size = 0;
  DWORD tag = 0;

  sym.get_symTag(&tag);
  if ( tag == SymTagData )
  {
    pdb_sym_t *pType = pdb_access->create_sym();
    pdb_sym_janitor_t janitor_pType(pType);
    if ( sym.get_type(pType) == S_OK )
      pType->get_length(&size);
  }
  else
  {
    sym.get_length(&size);
  }
  return size_t(size);
}

//----------------------------------------------------------------------
cvt_code_t til_builder_t::convert_basetype(
        tpinfo_t *out,
        DWORD baseType,
        int size) const
{
  type_t bt = BTF_TYPEDEF;
  const char *name = nullptr;
  switch ( baseType )
  {
    case btNoType:
      out->is_notype = true;
      [[fallthrough]];
    default:
    case 0x12c304:                      // "impdir_entry" (guessed)
    case btBCD:
    case btBit:
      return cvt_failed;
    case btVoid:
      bt = BTF_VOID;
      break;
    case btChar:
      bt = BT_INT8|BTMT_CHAR;
      break;
    case btBool:
      bt = BT_BOOL;
      if ( size != inf_get_cc_size_b() )
      {
        switch ( size )
        {
          case 1:
            bt |= BTMT_BOOL1;
            break;
          case 2:
            if ( inf_is_64bit() )
              goto MAKE_INT; // 64bit apps do not have BOOL2
            bt |= BTMT_BOOL2;
            break;
          case 4:
            bt |= BTMT_BOOL4;
            break;
          case 8:
            if ( !inf_is_64bit() )
              goto MAKE_INT; // 32bit apps do not have BOOL8
            bt |= BTMT_BOOL8;
            break;
          default:
            // can't make this bool size; make an int
            goto MAKE_INT;
        }
      }
      break;
MAKE_INT:
    case btInt:
    case btLong:
      bt = get_scalar_bt(size);
      if ( bt == BT_UNK )
        return cvt_failed;
      break;
    case btUInt:
    case btULong:
      if ( size == 1 )
      {
        bt = BTF_UCHAR; // get_scalar_bt returns 'char', or'ing it with BTMT_USIGNED
                        // does not help
      }
      else
      {
        bt = get_scalar_bt(size);
        if ( bt == BT_UNK )
          return cvt_failed;
        bt |= BTMT_USIGNED;
      }
      break;
    case btFloat:
      if ( size == pv.ph.sizeof_ldbl() )
      {
        bt = BTMT_LNGDBL;
      }
      else
      {
        switch ( size )
        {
          case 4:  bt = BTMT_FLOAT;   break;
          default:
          case 8:  bt = BTMT_DOUBLE;  break;
          case 10: bt = BTMT_SPECFLT; break;
        }
      }
      bt |= BT_FLOAT;
      break;
    case btWChar:    name = "wchar_t";                         break;
    case btBSTR:     name = "BSTR";                            break;
    case btHresult:  name = "HRESULT";                         break;
    case btCurrency: name = "CURRENCY";                        break;
    case btVariant:  name = "VARIANT";                         break;
    case btComplex:  name = "complex";                         break;
    case btDate:     name = "DATE";                            break;
  }
  if ( name != nullptr )
  {
    out->type.create_typedef(ti, name);
    return cvt_typedef;
  }
  else
  {
    out->type = tinfo_t(bt);
    return cvt_ok;
  }
}

//----------------------------------------------------------------------
callcnv_t til_builder_t::retrieve_arguments(
        pdb_sym_t &_sym,
        func_type_data_t &fi,
        pdb_sym_t *funcSym,
        callcnv_t cc)
{
  struct type_name_collector_t : public pdb_access_t::children_visitor_t
  {
    func_type_data_t &fi;
    til_builder_t *tb;
    til_t *ti;
    HRESULT visit_child(pdb_sym_t &sym) override
    {
      // check that it's a parameter
      DWORD dwDataKind;
      if ( sym.get_dataKind(&dwDataKind) == S_OK
        && dwDataKind != DataIsParam
        && dwDataKind != DataIsObjectPtr )
      {
        return S_OK;
      }
      tpinfo_t tpi;
      bool cvt_succeeded = tb->retrieve_type(&tpi, sym, parent);
      if ( cvt_succeeded || tpi.is_notype )
      {
        funcarg_t &arg = fi.push_back();
        arg.type = tpi.type;
        sym.get_name(&arg.name);
      }
      return S_OK;
    }
    type_name_collector_t(til_t *_ti, til_builder_t *_tb, func_type_data_t &_fi)
      : fi(_fi), tb(_tb), ti(_ti) {}
  };
  fi.clear();
  type_name_collector_t pp(ti, this, fi);
  HRESULT hr = pdb_access->iterate_children(_sym, SymTagNull, pp);
  if ( hr == S_OK && funcSym != nullptr )
  {
    // get parameter names from the function symbol
    func_type_data_t args;
    args.flags = 0;
    enum_function_args(*funcSym, args);
//    QASSERT(497, args.empty() || args.size() == fi.size() );
    bool custom_cc = false;
    for ( int i = 0; i < fi.size(); i++ )
    {
      if ( i < args.size() )
      {
        if ( fi[i].name.empty() )
          fi[i].name = args[i].name;
        argloc_t &cur_argloc = args[i].argloc;
        fi[i].argloc = cur_argloc;
        if ( !custom_cc && cur_argloc.is_reg1() )
        {
          if ( is_intel386(pdb_access->get_machine_type()) )
          {
            if ( (cc == CM_CC_FASTCALL || cc == CM_CC_SWIFT) // FIXME
              && cur_argloc.regoff() == 0
              && (cur_argloc.reg1() == R_cx && i == 0
               || cur_argloc.reg1() == R_dx && i == 1) )
            {
              // ignore ecx and edx for fastcall
            }
            else if ( cc == CM_CC_THISCALL
                   && cur_argloc.regoff() == 0
                   && cur_argloc.reg1() == R_cx && i == 0 )
            {
              // ignore ecx for thiscall
            }
            else
            {
              custom_cc = true;
            }
          }
        }
        //ask_for_feedback("pdb: register arguments are not supported for machine type %d", machine_type);
      }
    }
    if ( custom_cc )
    {
      // we have some register params; need to convert function to custom cc
      CASSERT(is_purging_cc(CM_CC_THISCALL));
      CASSERT(is_purging_cc(CM_CC_FASTCALL));
      cc = is_purging_cc(cc) ? CM_CC_SPECIALP : CM_CC_SPECIAL;
    }
  }
  return cc;
}

//----------------------------------------------------------------------
callcnv_t til_builder_t::convert_cc(DWORD cc0) const
{
  switch ( cc0 )
  {
    case CV_CALL_GENERIC    :
    case CV_CALL_NEAR_C     :
    case CV_CALL_FAR_C      :
      return inf_is_64bit() ? CM_CC_FASTCALL : CM_CC_CDECL;
    case CV_CALL_NEAR_PASCAL:
    case CV_CALL_FAR_PASCAL : return CM_CC_PASCAL;
    case CV_CALL_NEAR_FAST  :
    case CV_CALL_FAR_FAST   : return CM_CC_FASTCALL;
//    case CV_CALL_SKIPPED    :
    case CV_CALL_NEAR_STD   :
    case CV_CALL_FAR_STD    :
    case CV_CALL_ARMCALL    : return CM_CC_STDCALL;
    case CV_CALL_THISCALL   : return CM_CC_THISCALL;
//    case CV_CALL_NEAR_SYS   :
//    case CV_CALL_FAR_SYS    :
//    case CV_CALL_MIPSCALL   :
//    case CV_CALL_ALPHACALL  :
//    case CV_CALL_PPCCALL    :
//    case CV_CALL_SHCALL     :
//    case CV_CALL_ARMCALL    :
//    case CV_CALL_AM33CALL   :
//    case CV_CALL_TRICALL    :
//    case CV_CALL_SH5CALL    :
//    case CV_CALL_M32RCALL   :
  }
  return CM_CC_UNKNOWN;
}

//----------------------------------------------------------------------
bool til_builder_t::get_variant_string_value(qstring *out, pdb_sym_t &sym) const
{
  bool ok = false;
  VARIANT value;
  VariantInit(&value);
  if ( sym.get_value(&value) == S_OK )
  {
    if ( value.vt == VT_BSTR )
    {
      utf16_utf8(out, (wchar16_t*) value.bstrVal);
      ok = true;
    }
    else if ( value.vt == VT_LPSTR )
    {
      qstring str((const char *)value.byref);
      out->swap(str);
      ok = true;
    }
  }
  VariantClear(&value);
  return ok;
}

//----------------------------------------------------------------------
uint32 til_builder_t::get_variant_long_value(pdb_sym_t &sym) const
{
  uint32 v = 0;
  VARIANT value;
  VariantInit(&value);
  if ( sym.get_value(&value) == S_OK )
  {
    switch ( value.vt )
    {
      case VT_I1:   v = value.cVal; break;
      case VT_I2:   v = value.iVal; break;
      case VT_I4:   v = value.lVal; break;
      case VT_I8:   v = value.llVal; break;
      case VT_INT:  v = value.intVal; break;
      case VT_UI1:  v = value.bVal; break;
      case VT_UI2:  v = value.uiVal; break;
      case VT_UI4:  v = value.ulVal; break;
      case VT_UI8:  v = value.ullVal; break;
      case VT_UINT: v = value.uintVal; break;
      default:
        ask_for_feedback("pdb: unsupported VARIANT type %d", value.vt);
        break;
    }
  }
  VariantClear(&value);
  return v;
}

//----------------------------------------------------------------------
// funcSym is Function, typeSym is FunctionType
bool til_builder_t::is_member_func(tinfo_t *class_type, pdb_sym_t &typeSym, pdb_sym_t *funcSym)
{
  // make sure we retrieve class type first
  pdb_sym_t *pParent = pdb_access->create_sym();
  pdb_sym_janitor_t janitor_pParent(pParent);
  if ( typeSym.get_classParent(pParent) != S_OK || pParent->empty() )
    return false;

  tpinfo_t tpi;
  if ( !retrieve_type(&tpi, *pParent, nullptr) )
    return false; // failed to retrieve the parent's type

  class_type->swap(tpi.type);

  // then check if it's static
  if ( funcSym != nullptr
    && pdb_access->get_dia_version() >= 800 )
  {
    BOOL bIsStatic = false;
    HRESULT hr = funcSym->get_isStatic(&bIsStatic);
    if ( hr == S_OK )
      return !bIsStatic;
  }
  return true;
}

//----------------------------------------------------------------------
bool til_builder_t::is_stack_reg(int reg) const
{
  return reg == get_stack_reg(pdb_access->get_machine_type());
}

//----------------------------------------------------------------------
bool til_builder_t::is_frame_reg(int reg) const
{
  if (pdb_access->get_dia_version() >= 1400 && is_intel386(pdb_access->get_machine_type()))
  {
    return reg == CV_ALLREG_VFRAME || reg == CV_REG_EBP;
  }
  return reg == get_frame_reg(pdb_access->get_machine_type());
}

//----------------------------------------------------------------------------
int til_builder_t::get_symbol_funcarg_info(
        funcarg_t *out,
        pdb_sym_t &sym,
        DWORD /*dwDataKind*/,
        DWORD locType,
        int stack_off)
{
  sym.get_name(&out->name);
  tpinfo_t tpi;
  get_symbol_type(&tpi, sym);
  out->type = tpi.type;
  if ( locType == LocIsEnregistered )
  {
    DWORD dwReg;
    if ( sym.get_registerId(&dwReg) == S_OK )
    {
      if ( enregistered_bug && dwReg > 0 )
        dwReg--;
      qstring regname;
      print_pdb_register(&regname, pdb_access->get_machine_type(), dwReg);
      out->argloc._set_reg1(str2reg(regname.c_str()));
    }
  }
  else if ( locType == LocIsRegRel )
  {
    DWORD dwReg;
    LONG lOffset;
    if ( sym.get_registerId(&dwReg) == S_OK
      && sym.get_offset(&lOffset) == S_OK
      && (is_frame_reg(dwReg) || is_stack_reg(dwReg)) )
    {
      uint32 align;
      out->argloc._set_stkoff(stack_off);
      size_t argsz = out->type.get_size(&align);
      if ( align > argsz )
        argsz = align;
      stack_off += argsz;
    }
  }
  else
  {
    ask_for_feedback("pdb: unsupported location type %d", locType);
  }
  return stack_off;
}

//----------------------------------------------------------------------
void til_builder_t::enum_function_args(pdb_sym_t &_sym, func_type_data_t &args)
{
  // enumerate all function parameters and gather their names
  struct param_enumerator_t : public pdb_access_t::children_visitor_t
  {
    func_type_data_t &args;
    til_builder_t *tb;
    int stack_off;
    virtual HRESULT visit_child(pdb_sym_t &sym) override
    {
      DWORD tag = 0;
      HRESULT hr = sym.get_symTag(&tag);
      if ( FAILED(hr) )
        return hr;

      switch ( tag )
      {
        case SymTagBlock: // nested blocks
          return tb->pdb_access->iterate_children(sym, SymTagNull, *this);
        case SymTagFuncDebugStart:
        case SymTagFuncDebugEnd:
          return S_OK;    // ignore these for the moment
      }

      DWORD dwDataKind, locType;
      if ( sym.get_dataKind(&dwDataKind) == S_OK
        && dwDataKind == DataIsParam
        && sym.get_locationType(&locType) == S_OK )
      {
        funcarg_t &fa = args.push_back();
        stack_off = tb->get_symbol_funcarg_info(&fa, sym, dwDataKind, locType, stack_off);
      }
      return S_OK; // continue enumeration
    }
    param_enumerator_t(func_type_data_t &_args, til_builder_t *_tb)
      : args(_args), tb(_tb), stack_off(0) {}
  };
  param_enumerator_t pen(args, this);
  pdb_access->iterate_children(_sym, SymTagData, pen);
}

//----------------------------------------------------------------------
// corrupted PDB may produce the strange results
cvt_code_t til_builder_t::verify_struct(pdb_udt_type_data_t &udt) const
{
  for ( auto &udm : udt )
  {
    if ( !udm.is_bitfield() && (udm.offset % 8) != 0 )
      return cvt_failed;
  }
  return cvt_ok;
}

//----------------------------------------------------------------------
bool til_builder_t::verify_union_stem(pdb_udt_type_data_t &udt) const
{
  bool udt_fixed = false;
  // at the moment there is an issue with structure with bit fields only
  if ( udt.size() < 2 )
    return udt_fixed;
  for ( const pdb_udm_t &udm : udt )
  {
    if ( !udm.is_bitfield() )
      return udt_fixed;
  }

  // stem like:
  // 0 unsigned __int8 : 7 ZZ1 bit_offset 0
  // 8 unsigned __int32 : 24 AllFlags bit_offset 8
  // is collected wrongly and should be fixed.
  // There is a bit_offset 8 inside the bitfield group,
  // so we need to expand the type of field ZZ1

  dump_pdb_udt(udt, "verify_union_stem");
  bool udm_fixed;
  do
  {
    udm_fixed = false;
    for ( size_t i=0; i < udt.size()-1; ++i )
    {
      pdb_udm_t &udm0 = udt[i];
      const pdb_udm_t &udm1 = udt[i+1];

      size_t typsz0 = udm0.type.get_size();
      size_t typsz1 = udm1.type.get_size();
      if ( udm0.bit_offset < udm1.bit_offset
        && udm0.offset + udm0.size <= udm1.offset
        && typsz0 < typsz1 )
      {
        bitfield_type_data_t bi;
        udm0.type.get_bitfield_details(&bi);
        bi.nbytes = typsz1;
        udm0.type.create_bitfield(bi);
        udt_fixed = true;
        udm_fixed = true;
      }
    }
  } while ( udm_fixed );
  if ( udt_fixed )
    dump_pdb_udt(udt, "verify_union_stem FIXED");

  return udt_fixed;
}

//----------------------------------------------------------------------
// verify unions that would be created out of [p1, p2) members.
// The [p1, p2) members are spoiled by the function.
// Create substructures if necessary. Returns the result in out (can be the same
// vector as [p1, p2)
cvt_code_t til_builder_t::verify_union(
        pdb_udt_type_data_t *out,
        pdb_udt_type_data_t::iterator p1,
        pdb_udt_type_data_t::const_iterator p2) const
{
  if ( p1 == p2 )
    return cvt_ok;

  QASSERT(498, p2 > p1);
  uint64 off = p1->offset;
  typedef qvector<pdb_udt_type_data_t> stems_t;
  stems_t stems; // each stem is a member of the future union
  for ( pdb_udt_type_data_t::iterator q=p1; q != p2; ++q )
  {
    pdb_udt_type_data_t *best = nullptr;
    q->offset -= off;
    if ( q->offset != 0 )
    { // find best suited stem: the one with end() closest to our offset
      uint64 bestend = 0;
      for ( stems_t::iterator s=stems.begin(); s != stems.end(); ++s )
      {
        pdb_udt_type_data_t &sm = *s;
        pdb_udm_t &lastmem = sm.back();
        uint64 smend = lastmem.end();
        if ( (lastmem.is_bitfield() == q->is_bitfield() || q->bit_offset == 0)
          && smend <= q->begin()
          && (best == nullptr || bestend < smend) )
        {
          best = &sm;
          bestend = smend;
        }
      }
    }
    if ( best == nullptr )
      best = &stems.push_back();
    uint64 qend;
    if ( q->is_bitfield() )
    {
      bitfield_type_data_t bi;
      q->type.get_bitfield_details(&bi);
      size_t size = bi.nbytes * 8;
      QASSERT(30385, size == 8 || size == 16 || size == 32 || size == 64);
      qend = q->offset - q->bit_offset + size;
    }
    else
    {
      qend = q->offset + q->size + 7;
    }
    qend /= 8;
    if ( best->total_size < qend )
      best->total_size = qend;
    qswap(best->push_back(), *q);
  }

  // the stems are created artificially
  // and some of them need to be fixed
  // to prevent structure alignment issues
  for ( stems_t::iterator s=stems.begin(); s != stems.end(); ++s )
  {
    if ( s->size() == 1 && s->begin()->offset == 0 && !s->begin()->is_bitfield() )
      continue;
    verify_union_stem(*s);
  }

  // all non-trivial stems must be converted to structures
  for ( stems_t::iterator s=stems.begin(); s != stems.end(); ++s )
  {
    if ( s->size() == 1 && s->begin()->offset == 0 && !s->begin()->is_bitfield() )
      continue;
#ifdef PDEB
    msg("CREATE STEM total_size %" FMT_Z "\n", s->total_size);
    for ( pdb_udt_type_data_t::iterator p=s->begin(); p != s->end(); ++p )
      msg("  %" FMT_64 "x %s %s bit_offset %u\n", p->offset, p->type.dstr(), p->name.c_str(), p->bit_offset);
#endif
    if ( verify_struct(*s) != cvt_ok )
      return cvt_failed;
    tinfo_t tif;
    int total_size = s->total_size;
    cvt_code_t code = create_udt_ref(&tif, s, UdtStruct);
    if ( code != cvt_ok )
      return code;
    s->resize(1);
    pdb_udm_t &sm = s->front();
    sm.offset = 0;
    sm.size = uint64(total_size) * 8;
    sm.name.sprnt("__s%u", uint(s-stems.begin()));
    sm.type = tif;
  }

  // collect the results
  out->resize(stems.size());
  for ( int i=0; i < stems.size(); i++ )
  {
    QASSERT(499, stems[i].size() == 1);
    qswap(out->at(i), *stems[i].begin());
  }
  return cvt_ok;
}

//----------------------------------------------------------------------
// create a union out of [p1, p2) members. they are spoiled by the function.
// returns type of the new union and its fields
// this function also creates substructures if necessary
cvt_code_t til_builder_t::create_union(
        tinfo_t *out,
        size_t *p_total_size,
        pdb_udt_type_data_t::iterator p1,
        pdb_udt_type_data_t::const_iterator p2) const
{
#ifdef PDEB
  msg("CREATE UNION\n");
  for ( pdb_udt_type_data_t::iterator p=p1; p != p2; ++p )
    msg("  %" FMT_64 "x %s %s bit_offset %u\n", p->offset, p->type.dstr(), p->name.c_str(), p->bit_offset);
#endif
  pdb_udt_type_data_t unimems;
  cvt_code_t code = verify_union(&unimems, p1, p2);
  if ( code != cvt_ok )
    return code;
  // calculate the total size
  for ( int i=0; i < unimems.size(); i++ )
  {
    pdb_udm_t &udm = unimems[i];
    size_t nbytes = (udm.end() + 7) / 8;
    if ( nbytes > unimems.total_size )
      unimems.total_size = nbytes;
  }
  if ( p_total_size != nullptr )
    *p_total_size = unimems.total_size;
  return create_udt_ref(out, &unimems, UdtUnion);
}

//----------------------------------------------------------------------
inline void ida_vft_name(qstring *vftn, const char *ns, uint32_t offset=0)
{
  qstring new_vft_name(ns);
  if ( offset != 0 )
    new_vft_name.cat_sprnt("_%04X", offset);
  new_vft_name.append(VTBL_SUFFIX);
  vftn->swap(new_vft_name);
}

//----------------------------------------------------------------------
#define MS_VTBL_SUFFIX "Vtbl"
inline void ms_vft_name(qstring *vftn, const char *ns)
{
  qstring new_vft_name(ns);
  new_vft_name.append(MS_VTBL_SUFFIX);
  vftn->swap(new_vft_name);
}

//----------------------------------------------------------------------
inline bool is_ms_vft_name(const qstring &udt_name)
{
  size_t len = udt_name.length();
  return len > sizeof(MS_VTBL_SUFFIX)
      && streq(udt_name.begin() + (len - sizeof(MS_VTBL_SUFFIX) + 1), MS_VTBL_SUFFIX);
}

//----------------------------------------------------------------------
inline void ida_vft_name_from_ms(qstring *ivftnm, const qstring &msvftnm)
{
  qstring tmp(msvftnm);
  if ( is_ms_vft_name(msvftnm) )
    tmp.remove(tmp.length()-4, 4);
  ida_vft_name(ivftnm, tmp.c_str());
}

//----------------------------------------------------------------------
bool til_builder_t::get_vft_name(qstring *vftn, uint32 *p_ord, const char *ns, uint32_t offset)
{
  bool vft_creating = false;
  qstring new_vft_name;
  // check for MS vftable
  ms_vft_name(&new_vft_name, ns);
  uint32 ord = get_type_ordinal(ti, new_vft_name.c_str());
  if ( ord == 0 )
  {
    // maybe creating?
    vft_creating = creating.find(new_vft_name.c_str()) != creating.end();
    if ( !vft_creating )
    {
      ida_vft_name(&new_vft_name, ns, offset);
      ord = get_type_ordinal(ti, new_vft_name.c_str());
    }
  }
  vftn->swap(new_vft_name);
  if ( p_ord != nullptr )
    *p_ord = ord;
  return vft_creating;
}

//----------------------------------------------------------------------
void pdb_udt_type_data_t::convert_to_tinfo_udt(udt_type_data_t *out)
{
  out->total_size = total_size;
  out->taudt_bits = taudt_bits;
  out->is_union = is_union;
  out->reserve(size());
  for ( size_t i = 0; i < size(); i++ )
  {
    udm_t &udm = at(i);
#ifdef PDEB
    out->push_back() = udm;
#else
    out->push_back().swap(udm);
#endif
  }
}

//----------------------------------------------------------------------
// insert si into the destination type
inline void merge_vft_udm(int *j, udt_type_data_t *dst_udt, const udm_t &si, bool replace)
{
  bool insert_src = true;
  for ( ; *j < dst_udt->size(); (*j)++ )
  {
    udm_t &dj = (*dst_udt)[*j];
    if ( dj.offset + dj.size <= si.offset )
      continue;
    if ( dj.offset >= si.offset + si.size )
      break;  // should insert before dj
    // Looks like an overlap,
    // fields may differ in type and name only.
    // Ignore "__vecDelDtor",
    // this often happens when virtual class::~class
    // is later redefined as __vecDelDtor()
    if ( replace && si.name != "__vecDelDtor"
      || dj.name == "__vecDelDtor" )
    {
      dj.type = si.type;
      dj.name = si.name;
    }
    insert_src = false;
    break;
  }
  if ( insert_src )
    dst_udt->insert(dst_udt->begin()+*j, si);
}

//----------------------------------------------------------------------
// merge two vftables into one
// dst_udt gets all fields of srctype in addition to its own fields.
// dst_udt preserves or overrides the coinciding field.
static void merge_vftables(udt_type_data_t *dst_udt, const tinfo_t &srcvft, bool replace)
{
  udt_type_data_t src_udt;
  if ( !srcvft.get_udt_details(&src_udt) )
  {
    deb(IDA_DEBUG_DBGINFO, "PDB: failed to merge type '%s' to vftable\n", srcvft.dstr());
#if defined(TESTABLE_BUILD) && !defined(__FUZZER__)
    INTERR(30585);
#else
    return;
#endif
  }

  int j(0);
  for ( const auto &si : src_udt )
    merge_vft_udm(&j, dst_udt, si, replace);
  dst_udt->total_size = (dst_udt->back().end() + 7) / 8;
}

//----------------------------------------------------------------------
static void add_vftable_member(
        udt_type_data_t *dst_udt,
        const tinfo_t &member,
        const char *name,
        DWORD vfptr_offset)
{
  tinfo_t ptr_member;
  ptr_member.create_ptr(member);    // the field is a pointer to function
  asize_t size = ptr_member.get_size();

  udm_t udm;
  udm.offset = uint64(vfptr_offset) * 8;
  udm.size = uint64(size) * 8;
  udm.type = ptr_member;
  udm.effalign = size;
  udm.name = name;

  int j(0);
  merge_vft_udm(&j, dst_udt, udm, true);
  dst_udt->total_size = (dst_udt->back().end() + 7) / 8;
}

//----------------------------------------------------------------------
inline bool get_vfptr_offset(DWORD *vfptr_offset, pdb_sym_t &sym)
{
  BOOL is_virtual;
  return sym.get_virtual(&is_virtual) == S_OK
      && is_virtual
      && sym.get_virtualBaseOffset(vfptr_offset) == S_OK;
}

//----------------------------------------------------------------------
// enumerate virtual functions of class sym and create a vtable structure
// with function pointers
cvt_code_t til_builder_t::make_vtable_struct(tinfo_t *out, pdb_sym_t &_sym)
{
  struct virtual_func_visitor_t : public pdb_access_t::children_visitor_t
  {
    til_builder_t *tb;
    vft_info_t *vftinfo;        // vftable info
    virtual HRESULT visit_child(pdb_sym_t &sym) override
    {
      qstring name;
      sym.get_name(&name);

      // is introducing virtual?
      DWORD vfptr_offset = -1;
      bool is_intro_virtual = get_vfptr_offset(&vfptr_offset, sym);

      tpinfo_t tpi;
      if ( is_intro_virtual && tb->retrieve_type(&tpi, sym, parent) )
      {
        ddeb(("PDEB:   make_vtable_struct add '%s' vptr offset %u\n", tpi.type.dstr(), vfptr_offset));
        add_vftable_member(&vftinfo->udt, tpi.type, name.c_str(), vfptr_offset);
      }
      return S_OK;
    }
    virtual_func_visitor_t(til_builder_t *_tb, vft_info_t *_vftinfo)
      : tb(_tb),
        vftinfo(_vftinfo)
    {}
  };

  qstring udt_name;
  _sym.get_name(&udt_name);
  // FIXME: should we remove classprefix (name + "::") ?
  #ifdef PDEB
  static int zzlevel = 0;
  msg("PDEB: %d{ make_vtable_struct '%s'\n", ++zzlevel, udt_name.c_str());
  #endif
  vft_info_t vftinfo;
  virtual_func_visitor_t pp(this, &vftinfo);
  pdb_access->iterate_children(_sym, SymTagFunction, pp);

  bool ok = false;
  if ( !vftinfo.udt.empty() )
  {
    out->create_udt(vftinfo.udt, BTF_STRUCT);
    ddeb(("PDEB: %d make_vtable_struct collected vftable '%s'\n", zzlevel, out->dstr()));
    ok = out->calc_udt_aligns();
  }
  #ifdef PDEB
  if ( !ok )
    msg("PDEB: make_vtable_struct failed to create vftable\n");
  msg("PDEB: %d} make_vtable_struct '%s'\n", zzlevel--, udt_name.c_str());
  #endif
  return ok ? cvt_ok : cvt_failed;
}

//----------------------------------------------------------------------
inline bool is_fake_vftable(tinfo_t vft_tif)
{
  qstring tname;
  return vft_tif.get_final_type_name(&tname) && tname == fake_vtable_type;
}

//----------------------------------------------------------------------
static bool is_forbidden_name(const char *name)
{
  static const char *const forbidden_names[] = { "QueryInterface" };

  for ( size_t i = 0; i < qnumber(forbidden_names); i++ )
  {
    if ( strcmp(name, forbidden_names[i]) == 0 )
      return true;
  }

  return false;
}

//----------------------------------------------------------------------
// In some cases the type of 'this' is wrong for derived virtual methods,
// it uses the type of the base class instead of the derived class.
// Also, the destructor name may use the base class as well, which is wrong.
//
// For example we have a derived class:
//   class std::numpunct<char> : public _Facet_base
//   [...]
//
// Then its VFT should be like this:
//   struct /*VFT*/ std::numpunct<char>_vtbl
//   {
//     void (__cdecl *~std::numpunct<char>)(struct std::numpunct<char> *this);
//     void (__cdecl *_Incref)(struct std::numpunct<char> *this);
//   [...]
//
// Not like this:
//   struct /*VFT*/ std::numpunct<char>_vtbl
//   {
//     void (__fastcall *~_Facet_base)(std::_Facet_base *this);
//     void (__fastcall *_Incref)(std::_Facet_base *this);
//   [...]
void til_builder_t::fix_thisarg_type(const qstring &udt_name)
{
  uint32 udt_vft_ord = 0;
  qstring udt_vft_name;
  get_vft_name(&udt_vft_name, &udt_vft_ord, udt_name.c_str());

  tinfo_t tinfo;
  tinfo.get_named_type(nullptr, udt_vft_name.c_str(), BTF_STRUCT);
  udt_type_data_t udt;
  tinfo.get_udt_details(&udt);

  tinfo_t base_tif;
  base_tif.get_named_type(nullptr, udt_name.c_str(), BTF_STRUCT);

  tinfo_t base_tif_p;
  base_tif_p.create_ptr(base_tif);

  bool changed = false;

  for ( auto &udm : udt )
  {
    if ( is_forbidden_name(udm.name.c_str()) )
      return;

    tinfo_t tif_no_ptr = udm.type.get_pointed_object();
    func_type_data_t ftd;
    if ( !tif_no_ptr.get_func_details(&ftd, GTD_NO_ARGLOCS)
      || ftd.empty()
      || !ftd[0].type.is_ptr() )
    {
      continue;
    }

    // Fix destructor
    if ( udm.name[0] == '~' )
    {
      changed = true;
      qstring old_name = udm.name;
      udm.name = qstring("~") + udt_name;
      ddeb(("PDEB: Changed destructor in '%s' from '%s' to '%s'\n", udt_vft_name.c_str(), old_name.c_str(), udm.name.c_str()));
    }

    // Fix argument of functions if it doesn't match to real name
    if ( !base_tif.compare_with(remove_pointer(ftd[0].type), TCMP_IGNMODS) )
    {
      changed = true;

      ftd[0].type = tinfo_t(base_tif_p);
      qstring old_type_str;
      udm.type.print(&old_type_str);

      tinfo_t t;
      t.create_func(ftd);
      t.create_ptr(t);

      udm.type.clear();
      udm.type = t;

      qstring new_type_str;
      udm.type.print(&new_type_str);

      ddeb(("PDEB: Changed type in '%s' from '%s' to '%s'\n", udt_vft_name.c_str(), old_type_str.c_str(), new_type_str.c_str()));
    }
  }

  if ( changed )
  {
    tinfo.create_udt(udt, BTF_STRUCT);
    tinfo.set_named_type(nullptr, udt_vft_name.c_str(), NTF_REPLACE);
  }
}

//----------------------------------------------------------------------
cvt_code_t til_builder_t::convert_udt(
        tinfo_t *out,
        pdb_sym_t &_sym,
        DWORD64 size)
{
  DWORD udtKind;
  if ( _sym.get_udtKind(&udtKind) != S_OK )
    return cvt_failed;

  // retrieve member names, types, offsets
  struct type_name_collector_t : public pdb_access_t::children_visitor_t
  {
    til_builder_t *tb;
    pdb_udt_type_data_t &udt;
    const char *vftname;        // vftable name
    vft_info_t *vftinfo;        // vftable info, maybe nullptr if we don't want
                                // to collect vftable
    bool mark_lpVtbl;           // mark "lpVtbl" as pointer to vftable
    bool has_virtbases;
    HRESULT visit_child(pdb_sym_t &sym) override
    {
      qstring name;
      sym.get_name(&name);
      ddeb(("PDEB:   convert_udt adding member '%s'\n", name.c_str()));

      // is introducing virtual?
      DWORD vfptr_offset = -1;
      bool is_intro_virtual = get_vfptr_offset(&vfptr_offset, sym);

      LONG offset = 0;
      if ( !is_intro_virtual && sym.get_offset(&offset) != S_OK )
        return S_OK;
      // assert: intro virtual or data member

      tpinfo_t tpi;
      if ( !tb->retrieve_type(&tpi, sym, parent) )
        return S_OK;

      if ( is_intro_virtual )
      {
        if ( vftinfo != nullptr )
        {
          ddeb(("PDEB:   convert_udt vtable %s add '%s' of '%s' vptr offset %u\n", vftname, name.c_str(), tpi.type.dstr(), vfptr_offset));
          add_vftable_member(&vftinfo->udt, tpi.type, name.c_str(), vfptr_offset);
        }
        return S_OK;
      }

      ddeb(("PDEB:   convert_udt adding member '%s' of type '%s'\n", name.c_str(), tpi.type.dstr()));
      asize_t memsize = tb->get_symbol_type_length(sym);

      pdb_udm_t &udm = udt.push_back();

      DWORD tag = SymTagNull;
      sym.get_symTag(&tag);
      if ( tag == SymTagBaseClass )
      {
        udm.set_baseclass();
        // determine if the base is virtual
        BOOL is_virtbase = false;
        sym.get_isVirtualBaseClass(&is_virtbase);
        if ( is_virtbase )
        {
          udm.set_virtbase();
          has_virtbases = true;
        }

        // we are interested only in baseclass at offset 0
        if ( offset == 0 && vftinfo != nullptr )
        {
          // get baseclass vftable
          qstring bcvft_name;
          uint32 bcvft_ord;
          tb->get_vft_name(&bcvft_name, &bcvft_ord, name.c_str());
          if ( bcvft_ord != 0 )
          {
            tinfo_t bcvft_tif;
            bcvft_tif.get_numbered_type(tb->ti, bcvft_ord);
            if ( !is_fake_vftable(bcvft_tif) )
            {
              ddeb(("PDEB:   convert_udt vtable %s add baseclass %s vtable '%s'\n", vftname, bcvft_name.c_str(), bcvft_tif.dstr()));
              merge_vftables(&vftinfo->udt, bcvft_tif, false);
            }
            else
            {
              ddeb(("PDEB:   convert_udt vtable %s baseclass %s vtable is fake\n", vftname, bcvft_name.c_str()));
            }
          }
          else
          {
            ddeb(("PDEB:   convert_udt vtable %s baseclass %s vtable not found\n", vftname, bcvft_name.c_str()));
            vftinfo->base0.swap(bcvft_name);
          }
        }
        name.clear();   // no name for baseclass member
      }
      else if ( tag == SymTagVTable )
      {
        ddeb(("PDEB:   convert_udt our vtable '%s'\n", tpi.type.dstr()));
        if ( is_fake_vftable(tpi.type) )
        {
          tpi.type = tinfo_t::get_stock(STI_PVOID);
        }
        else
        {
          if ( vftinfo != nullptr )
            merge_vftables(&vftinfo->udt, tpi.type, true);
          // type is a structure, while the field is a pointer to it
          tpi.type.create_ptr(tpi.type);
        }
        name = VTBL_MEMNAME;    // we need only this name
        memsize = tpi.type.get_size();
        udm.set_vftable();
      }
      // mark MS vftable pointer
      if ( mark_lpVtbl && tpi.type.is_ptr() && name == "lpVtbl" )
      { // no need to rename it
        udm.set_vftable();
      }
      mark_lpVtbl = false;    // pointer to vftable maybe the first field only

      DWORD64 ulLen = DWORD64(memsize) * 8;
      DWORD dwBitPos = 0;
      DWORD dwLocType = LocIsNull;
      sym.get_locationType(&dwLocType); // may fail, just ignore
      if ( dwLocType == LocIsBitField )
      {
        sym.get_bitPosition(&dwBitPos);
        sym.get_length(&ulLen);
        if ( dwBitPos + ulLen > DWORD64(memsize) * 8 )
          return E_FAIL;
        bool is_unsigned = tpi.type.is_unsigned();
        udm.type.create_bitfield(memsize, ulLen, is_unsigned);
      }
      else
      {
        udm.type = tpi.type;
      }
      udm.size = ulLen;
      udm.offset = uint64(offset) * 8 + dwBitPos;
      udm.bit_offset = dwBitPos;
      udm.name.swap(name);
      ddeb(("PDEB:   convert_udt adding member size %" FMT_64 "u offset %" FMT_64 "u bit_offset %u\n", udm.size, udm.offset, udm.bit_offset));
      return S_OK;
    }
    type_name_collector_t(
            til_builder_t *_tb,
            pdb_udt_type_data_t &m,
            const char *_vftname,
            vft_info_t *_vftinfo)
      : tb(_tb),
        udt(m),
        vftname(_vftname),
        vftinfo(_vftinfo),
        mark_lpVtbl(true),
        has_virtbases(false)
    {}
  };

  qstring udt_name;
  _sym.get_name(&udt_name);

  bool is_vtbl_udt = is_ms_vft_name(udt_name);
  qstring udt_vft_name;
  uint32 udt_vft_ord = 0;
  bool vft_creating = false;
  if ( !is_vtbl_udt )
    vft_creating = get_vft_name(&udt_vft_name, &udt_vft_ord, udt_name.c_str());
  bool collect_vft = !vft_creating && !is_vtbl_udt && udt_vft_ord == 0;

  #ifdef PDEB
  static size_t entry_counter = 0;
  ++entry_counter;
  static int zzlevel = 0;
  msg("PDEB: %d{ convert_udt '%s' assuming vftable '%s' ENTRY %" FMT_Z "\n", ++zzlevel, udt_name.c_str(), udt_vft_name.c_str(), entry_counter);
  #endif
  pdb_udt_type_data_t udt;
  if ( is_vtbl_udt )
    udt.taudt_bits |= TAUDT_VFTABLE;
  vft_info_t vtinfo;
  type_name_collector_t pp(
          this,
          udt,
          udt_vft_name.c_str(),
          collect_vft ? &vtinfo : nullptr);
  pdb_access->iterate_children(_sym, SymTagNull, pp);

  bool is_cppobj = false;
  if ( collect_vft && !vtinfo.udt.empty() )
  {
    if ( vtinfo.base0.empty() )
    {
      tinfo_t vft_tif;
      if ( vft_tif.create_udt(vtinfo.udt, BTF_STRUCT)
        && vft_tif.calc_udt_aligns() )
      {
        ddeb(("PDEB: convert_udt %d collected vftable '%s' '%s'\n", zzlevel, udt_vft_name.c_str(), vft_tif.dstr()));
        uint32 id = get_type_ordinal(ti, udt_vft_name.c_str());
        if ( id == 0 )
          vft_tif.set_named_type(ti, udt_vft_name.c_str(), NTF_NOBASE);
        else
          ddeb(("PDEB: convert_udt '%s' exists\n", udt_vft_name.c_str()));
        is_cppobj = true;   // there is a vftable, so it is a C++ object
      }
      else
      { // ignore failure, continue w/o vftable
        ddeb(("PDEB: convert_udt failed to create vftable\n"));
      }
    }
    else
    {
      vftmap.emplace(std::make_pair(udt_vft_name.c_str(), vtinfo));
    }
  }
  #ifdef PDEB
  msg("PDEB: %d} convert_udt '%s'\n", zzlevel--, udt_name.c_str());
  #endif

  // if we will use MS Vtbl then create IDA synonym
  if ( is_vtbl_udt )
  {
    tinfo_t tif;
    tif.create_typedef(ti, udt_name.c_str());
    qstring ivftnm;
    ida_vft_name_from_ms(&ivftnm, udt_name.c_str());
    tif.set_named_type(ti, ivftnm.c_str(), NTF_NOBASE);
  }

  // if we inherit from c++ object, we are too a c++ object
  if ( size > 0 )
  {
    if ( udt.empty() )
      is_cppobj = true;
    if ( udt.size() == 1
      && udt[0].is_baseclass()
      && udt[0].type.is_empty_udt() )
    {
      is_cppobj = true;
    }
  }
  if ( is_cppobj )
  {
    udt.taudt_bits |= TAUDT_CPPOBJ;
  }
  else if ( udt.empty() )
  { // create forward ref
    qstring name;
    get_symbol_name(_sym, name);
    type_t bt = udtKind == UdtUnion ? BTF_UNION : BTF_STRUCT;
    out->create_typedef(ti, name.c_str(), bt);
    return cvt_typedef;
  }
  udt.total_size = size;
  std::stable_sort(udt.begin(), udt.end());
  BOOL cppobj;
  if ( _sym.get_constructor(&cppobj) == S_OK && cppobj > 0 )
    udt.taudt_bits |= TAUDT_CPPOBJ;
  cvt_code_t res = create_udt(out, &udt, udtKind, udt_name.c_str());

  if ( res == cvt_ok )
    fix_thisarg_type(udt_name);

  return res;
}

//----------------------------------------------------------------------
inline void get_empty_vft_tif(tinfo_t *vtif)
{
  udt_type_data_t empty_udt;
  empty_udt.taudt_bits |= TAUDT_VFTABLE;
  vtif->create_udt(empty_udt, BTF_STRUCT);
}

//----------------------------------------------------------------------
// fill the empty start slots of vftable,
// the holes will be filled latter, see SUDT_GAPS
static void fill_vft_empty_splots(udt_type_data_t *udt)
{
  if ( udt->empty() )
    return;

  uint64 offset = udt->begin()->offset;
  if ( offset == 0 )
    return;
  uint32 nbytes = offset / 8;

  udm_t gap;
  gap.type.create_array(tinfo_t(BTF_BYTE), nbytes);
  gap.offset = 0;
  gap.size = offset;
  gap.effalign = 1;
  gap.name = "gap0";
  udt->insert(udt->begin(), gap);
  // assert: no need to fix udt->total_size
}

//----------------------------------------------------------------------
void til_builder_t::create_vftables()
{
  int counter = 0;
  while ( !vftmap.empty() )
  {
    bool changed = false;
    for ( auto p=vftmap.begin(); p != vftmap.end(); )
    {
      auto &name = p->first;
      auto &info = p->second;
      ddeb(("PDB: create_vftables checking %s base0 %s\n", name.c_str(), info.base0.c_str()));
      const char *b0name = info.base0.c_str();
      uint32 id = get_type_ordinal(ti, b0name);
      if ( id != 0 )
      { // merge the known base class vftable
        ddeb(("PDB:   merge %s to %s\n", b0name, name.c_str()));
        tinfo_t btif;
        btif.get_numbered_type(ti, id);
        merge_vftables(&info.udt, btif, false);
        info.base0.clear();
        changed = true;
      }
      else
      {
        auto r = vftmap.find(b0name);
        if ( r == vftmap.end() || r->second.empty() )
        { // ordinary class
          ddeb(("PDB:   ignore %s for %s\n", b0name, name.c_str()));
          info.base0.clear();
          changed = true;
        }
        else
        {
          ddeb(("PDB:   skip %s for %s\n", b0name, name.c_str()));
        }
      }
      if ( info.base0.empty() )
      { // all base classes references are resolved, create vftable
        ddeb(("PDB: create_vftables creating %s\n", name.c_str()));
        tinfo_t vtif;
        if ( !vtif.create_udt(info.udt, BTF_STRUCT)
          || !vtif.calc_udt_aligns() )
        { // something wrong with vftable udt,
          // create an empty vftable
          ddeb(("PDEB: create_vftables failed to create vftable %s\n", name.c_str()));
          get_empty_vft_tif(&vtif);
        }
        ddeb(("PDB: create_vftables created %s '%s'\n", name.c_str(), vtif.dstr()));
        vtif.set_named_type(ti, name.c_str(), NTF_NOBASE);
        p = vftmap.erase(p);
        changed = true;
      }
      else
      {
        ++p;
      }

      ++counter;
      if ( (counter % 1000 == 0) && user_cancelled() )
        break;
    }
    if ( !changed || user_cancelled() )
      break;
  }

  if ( !vftmap.empty() )
  { // Something wrong or not:
    // base class w/o virtual functions
    // cyclic references,
    // missed types
    // Create the vftables ASIS
    for ( auto p : vftmap )
    {
      auto &name = p.first;
      auto &info = p.second;
      ddeb(("PDEB: create_vftables create vftable %s ASIS, base0 %s\n", name.c_str(), info.base0.c_str()));
      fill_vft_empty_splots(&info.udt);
      tinfo_t vtif;
      vtif.create_udt(info.udt, BTF_STRUCT);
      vtif.calc_udt_aligns();
      ddeb(("PDB: create_vftables created %s '%s'\n", name.c_str(), vtif.dstr()));
      vtif.set_named_type(ti, name.c_str(), NTF_NOBASE);
    }
    vftmap.clear();
  }
}

//----------------------------------------------------------------------
static bool set_array_type(pdb_udm_t *udm, int nbytes)
{
  bool ok = udm->type.create_array(tinfo_t(BT_UNK_BYTE), nbytes);
  if ( ok )
    udm->size = nbytes * 8;
  return ok;
}

//----------------------------------------------------------------------
// the real UDT should have non-zero size,
// detect a forward reference to a UDT without a real definition
inline bool is_fwdref_baseclass(pdb_udm_t &udm)
{
  return udm.is_baseclass() && udm.size == 0;
}

//----------------------------------------------------------------------
// The sparsed bit field union needs to be fixed, for example:
// 0x15e8 : LF_BITFIELD, bits = 4, starting position = 12, Type = T_ULONG(0022)
// 0x19b8 : LF_BITFIELD, bits = 1, starting position = 11, Type = T_ULONG(0022)
// 0x304f : LF_FIELDLIST
//   list[0] = LF_MEMBER, public, type = 0x19B8, offset = 4, member name = 'AbsoluteAddressing'
//   list[1] = LF_MEMBER, public, type = 0x15E8, offset = 4, member name = 'Op'
// 0x3050 : LF_UNION
//   # members = 2,  field list type 0x304f, SEALED, Size = 8, class name = GPUFLOW_RETURN
// We need:
// - add starting gap, others will be handled by SUDT_GAPS
// - change member field type
// - fix bit_offset
cvt_code_t til_builder_t::fix_bit_union(pdb_udt_type_data_t *udt) const
{
  if ( udt->empty() )
    return cvt_ok;
  // interested in bitfield union only
  for ( const pdb_udm_t &um : *udt )
  {
    if ( !um.is_bitfield() )
      return cvt_ok;
  }
  dump_pdb_udt(*udt, "|fix_bit_union|");
  // starting gap?
  if ( udt->begin()->offset == 0 )
    return cvt_ok;
  // union size
  size_t union_sz = udt->begin()->type.get_size();
  union_sz = qmax(udt->total_size, union_sz);
  bool is_unsigned = udt->begin()->type.is_unsigned();
  // fill gap
  pdb_udm_t gap;
  gap.bit_offset = 0;
  gap.offset = 0;
  gap.size = udt->begin()->offset;
  gap.name = "gap0";
  // gap.type will be fixed later
  udt->insert(udt->begin(), gap);
  // fix member type
  udt->total_size = union_sz;
  for ( pdb_udm_t &um : *udt )
  {
    um.type.create_bitfield(union_sz, um.size, is_unsigned);
    um.bit_offset = um.offset;
  }
  return cvt_ok;
}

//----------------------------------------------------------------------
cvt_code_t til_builder_t::create_udt(tinfo_t *out, pdb_udt_type_data_t *udt, int udtKind, const char *udt_name) const
{
#ifdef PDEB
  static size_t entry_counter = 0;
  ++entry_counter;
  _ddeb("PDEB: til_builder_t::create_udt ENTRY %" FMT_Z "\n", entry_counter);
  dump_pdb_udt(*udt, udt_name);
#endif
  cvt_code_t code;
  if ( udtKind == UdtUnion )
  {
    udt->is_union = true;
    fix_bit_union(udt);
    code = verify_union(udt, udt->begin(), udt->end());
  }
  else
  {
    // find overlapping members and convert into subunions (anonymous union would be great)
    udt->is_union = false;
    code = handle_overlapping_members(udt);
  }
  if ( code != cvt_ok )
    return code;

  // validate the type sizes, for the following reasons:
  //   - pdb information may be misleading (see pc_pdb_redefined_type.pe)
  //   - the same type name can be used for different types
  //   - invalid arrays happen (pc_pdb_wow.pe)
  for ( int i=0; i < udt->size(); i++ )
  {
    pdb_udm_t &udm = udt->at(i);
    if ( udm.is_bitfield() )
      continue;
    int gts_code = GTS_NESTED | (udm.is_baseclass() ? GTS_BASECLASS : 0);
    size_t nbytes = udm.type.get_size(nullptr, gts_code);
    if ( nbytes == BADSIZE && !is_fwdref_baseclass(udm) )
      continue; // cannot verify, the type is not ready yet
    if ( uint64(nbytes)*8 != udm.size )
    {
      if ( nbytes != 0 )
      {
        if ( !set_array_type(&udm, udm.size/8) )
          return cvt_failed;
        udm.clr_baseclass();
      }
      else if ( udm.is_baseclass() || udm.type.is_array() )
      { // nbytes==0
        udm.size = 0; // correct the base class size
      }
    }
  }

  if ( udt->total_size == 0 && !udt->empty() )
  { // msdia did not provide the udt size. use the end of the last element
    pdb_udm_t &udm = udt->back();
    udt->total_size = (udm.end() + 7) / 8;
  }

  // the kernel cannot handle virtual base classes yet, so we remove them
  // also check for overlapping members and members that go past the udt end
  uint64 last = 0;
  uint64 total_bits = uint64(udt->total_size) * 8;
  for ( int i=0; i < udt->size(); i++ )
  {
    pdb_udm_t &udm = udt->at(i);
    if ( udm.offset < last || udm.end() > total_bits )
    {
      if ( udm.end() > total_bits )
        udm.size = total_bits - udm.offset;
      if ( udm.offset > last )
        last = udm.offset;
      int nbytes = (udm.end() + 7 - last) / 8;
      if ( nbytes > 0 )
      { // replace with byte array
        if ( !set_array_type(&udm, nbytes) )
          return cvt_failed;
        if ( udm.name.empty() )
          udm.name.sprnt("_bytes_%" FMT_64 "x", last/8);
        udm.offset = last;
        udm.clr_baseclass();
        udm.clr_virtbase();
      }
      else
      { // we do not need this member
        udt->erase(udt->begin()+i);
        --i;
        continue;
      }
    }
    if ( udtKind != UdtUnion )
      last = udm.end();
  }

  type_t bt = udt->is_union ? BTF_UNION : BTF_STRUCT;
  udt_type_data_t tinfo_udt;
  udt->convert_to_tinfo_udt(&tinfo_udt);
  if ( !out->create_udt(tinfo_udt, bt) )
    return cvt_failed;
  if ( !out->calc_udt_aligns(SUDT_GAPS|SUDT_UNEX) )
  {
    dump_pdb_udt(*udt, udt_name);
    deb(IDA_DEBUG_DBGINFO, "PDB: Failed to calculate struct '%s' member alignments\n", udt_name != nullptr ? udt_name : "");
#if defined(TESTABLE_BUILD) && !defined(__FUZZER__)
    QASSERT(30380, !inf_test_mode() && out->get_size() == BADSIZE);
#endif
    ask_for_feedback("Failed to calculate struct member alignments");
  }
  return cvt_ok;
}

//----------------------------------------------------------------------
// is the return type complex?
// if so, a pointer to return value will be passed as a hidden parameter
bool til_builder_t::is_complex_return(pdb_sym_t &sym) const
{
  pdb_sym_t *pType = pdb_access->create_sym();
  pdb_sym_janitor_t janitor_pType(pType);
  bool complex = false;
  if ( sym.get_type(pType) == S_OK )
  {
    DWORD tag = 0;
    complex = pType->get_symTag(&tag) == S_OK && tag == SymTagUDT;
    if ( complex )
    {
      ULONGLONG size;
      complex = pType->get_length(&size) == S_OK && size > 8;
    }
    if ( !complex && tag == SymTagUDT )
    {
      // we've got a small UDT which possibly fits into a register (or two)
      // but it has to be a POD for that, i.e. should have no constructor or assignment operators
      BOOL b;
      if ( (pType->get_constructor          (&b) == S_OK) && b
        || (pType->get_hasAssignmentOperator(&b) == S_OK) && b
        || (pType->get_hasCastOperator      (&b) == S_OK) && b )
        complex = true;
    }
  }
  return complex;
}


//----------------------------------------------------------------------------
bool til_builder_t::is_unnamed_tag_typedef(const tinfo_t &tif) const
{
  uint32 id = tif.get_ordinal();
  if ( id == 0 )
    return false;

  return unnamed_types.find(id) != unnamed_types.end();
}


//----------------------------------------------------------------------
// borland does not like this structure to be defined inside a function.
// this is the only reason why it is in the file scope.
struct this_seeker_t : public pdb_access_t::children_visitor_t
{
  funcarg_t thisarg;
  til_builder_t *tb;
  bool found;
  virtual HRESULT visit_child(pdb_sym_t &sym) override
  {
    DWORD dwDataKind, locType;
    if ( sym.get_dataKind(&dwDataKind) == S_OK
      && dwDataKind == DataIsObjectPtr
      && sym.get_locationType(&locType) == S_OK )
    {
      tb->get_symbol_funcarg_info(&thisarg, sym, dwDataKind, locType, 0);
      found = true;
      return S_FALSE; // Stop enum.
    }
    return S_OK;
  }
  this_seeker_t(til_builder_t *_tb) : thisarg(), tb(_tb), found(false) {}
};

//----------------------------------------------------------------------------
inline type_t get_sym_modifiers(pdb_sym_t &sym)
{
  type_t type_mod = 0;
  BOOL sym_mod;
  if ( sym.get_constType(&sym_mod) == S_OK && sym_mod )
    type_mod |= BTM_CONST;
  if ( sym.get_volatileType(&sym_mod) == S_OK && sym_mod )
    type_mod |= BTM_VOLATILE;
  return type_mod;
}

//----------------------------------------------------------------------
cvt_code_t til_builder_t::really_convert_type(
        tpinfo_t *out,
        pdb_sym_t &sym,
        pdb_sym_t *parent,
        DWORD tag)
{
  // retrieve type modifiers
  type_t mods = parent ? 0 : get_sym_modifiers(sym);

  DWORD64 size = 0;
  sym.get_length(&size);
  DWORD bt, count;
  cvt_code_t code = cvt_ok;
  switch ( tag )
  {
    default:
    case SymTagNull:
      deb(IDA_DEBUG_DBGINFO, "PDB: unsupported tag %s\n", symtag_to_string(tag));
      code = cvt_failed;
      break;

    case SymTagBaseType:
      if ( sym.get_baseType(&bt) != S_OK )
        code = cvt_failed;
      else
        code = convert_basetype(out, bt, int(size));
      break;

    case SymTagPointerType:
      {
        tpinfo_t obj;
        if ( !get_symbol_type(&obj, sym) )
        {
          code = cvt_failed;
          break;
        }
        tinfo_t tif;
        tif.create_ptr(obj.type);
        int s2 = tif.get_size();
        if ( size != s2 )
        {
          if ( size == 4 || size == 8 )
          { // use __ptr32 or __ptr64
            ptr_type_data_t pi;
            pi.obj_type = obj.type;
            pi.taptr_bits = size == 4 ? TAPTR_PTR32 : TAPTR_PTR64;
            tif.create_ptr(pi);
          }
          else
          { // revert to int
            type_t inttype = get_scalar_bt(size);
            if ( inttype == BT_UNK )
            {
              code = cvt_failed;
              break;
            }
            tif = tinfo_t(inttype);
          }
        }
        out->type.swap(tif);
      }
      break;

    case SymTagArrayType:
      {
        tpinfo_t el;
        if ( !get_symbol_type(&el, sym) )
        {
FAILED_ARRAY:
          code = cvt_failed;
          break;
        }
        if ( sym.get_count(&count) != S_OK )
          goto FAILED_ARRAY;
        mods |= el.type.get_modifiers(); // propagate element type to array
        if ( !out->type.create_array(el.type, count) )
          goto FAILED_ARRAY;
      }
      break;

    case SymTagFunctionType:
      {
        tpinfo_t itp2;
        if ( !get_symbol_type(&itp2, sym) ) // return type
        {
          code = cvt_failed;
          break;
        }
        func_type_data_t fi;
        fi.rettype = itp2.type;
        if ( fi.rettype.is_array() )
        {
          code = cvt_failed; // arrays cannot be returned
          break;
        }
        DWORD cc0;
        callcnv_t cc = CM_CC_UNKNOWN;
        if ( sym.get_callingConvention(&cc0) == S_OK )
          cc = convert_cc(cc0);

        if ( cc != CM_CC_VOIDARG )
        {
          cc = retrieve_arguments(sym, fi, parent, cc);
          // if arg has unknown/invalid argument => convert to ellipsis
          for ( func_type_data_t::iterator i = fi.begin(); i != fi.end(); i++ )
          {
            if ( i->type.empty() )
            {
              // If the CC is cdecl, empty arguments represent an ellipsis.
              // Otherwise, it's likely to be a C-type function
              // with unknown number of arguments, such as 'foo()'
              // (as opposed to 'foo(void)'), and which might not have a cdecl
              // calling convention. E.g., pc_win32_appcall.pe's 'FARPROC':
              // "int (FAR WINAPI * FARPROC) ()", which is a stdcall.
              if ( cc == CM_CC_CDECL || inf_is_64bit() && cc == CM_CC_FASTCALL )
                cc = CM_CC_ELLIPSIS;
              // remove the ellipsis and any trailing arguments
              fi.erase(i, fi.end());
              break;
            }
          }
          // is there an implicit "result" pointer passed?
          if ( is_complex_return(sym) )
          {
            // complex return type: what's returned is actually a pointer
            fi.rettype.create_ptr(fi.rettype);
            funcarg_t retarg;
            retarg.type = fi.rettype;
            retarg.name = "result";
            fi.insert(fi.begin(), retarg);
          }
          // is there an implicit "this" passed?
          // N.B.: 'this' is passed before the implicit result, if both are present
          tinfo_t class_type;
          if ( is_member_func(&class_type, sym, parent) )
          {
            class_type.create_ptr(class_type);
            funcarg_t thisarg;
            thisarg.type = class_type;
            thisarg.name = "this";
            // due to MSDIA error sometimes it is failed to answer correctly
            // for the get_isStatic() request (S_FALSE).
            // So we need to check does 'this' pointer present in the function parameters.
            bool add_this = true;
            if ( parent != nullptr )
            {
              this_seeker_t ts(this);
              pdb_access->iterate_children(*parent, SymTagData, ts);
              thisarg.argloc = ts.thisarg.argloc;
              if ( thisarg.argloc.is_stkoff() )
              { // shift the remaining stkargs
                int delta = thisarg.type.get_size();
                for ( int i=0; i < fi.size(); i++ )
                {
                  funcarg_t &fa = fi[i];
                  if ( fa.argloc.is_stkoff() )
                    fa.argloc.set_stkoff(fa.argloc.stkoff()+delta);
                }
              }
              add_this = ts.found;
            }
            if ( add_this )
              fi.insert(fi.begin(), thisarg);
            if ( cc == CM_CC_THISCALL )
              fix_ctor_to_return_ptr(&fi, parent);
          }
          if ( is_user_cc(cc) )
          {
            // specify argloc for the return value
            size_t retsize = fi.rettype.get_size();
            if ( retsize <= 1 )
              fi.retloc._set_reg1(R_al);
            else if ( retsize <= 4 )
              fi.retloc._set_reg1(R_ax);
            else
              fi.retloc._set_reg2(R_ax, R_dx);

            // __usercall must have all its arguments location
            // specified.
            // It happens that some PDB information,
            // generated at compile-time, does _not_ hold info
            // about all the parameters. For example,
            // a function declared as:
            //   void BlockOpVPSDec(char *p, uint32 dwLength, char btXorKey, char /*foo*/)
            // will end up having only its first three arguments
            // properly defined in the PDB (because the fourth is
            // not used, its location is not defined.)
            // Still, in order for 'build_func_type2()' to work,
            // it requires all valid argloc_t instances. Thus,
            // we remove invalid ones completely.
            for ( int i = fi.size() - 1; i >= 0; --i )
              if ( fi[i].argloc.is_badloc() )
                fi.erase(fi.begin() + i);
          }
        }
        fi.set_cc(cc);
        out->type.create_func(fi);
      }
      break;

    case SymTagUDT:
    case SymTagBaseClass:
      code = convert_udt(&out->type, sym, size);
      break;
    case SymTagEnum:
      {
        struct name_value_collector_t : public pdb_access_t::children_visitor_t
        {
          const til_builder_t *tb;
          enum_type_data_t ei;
          HRESULT visit_child(pdb_sym_t &child) override
          {
            edm_t &em = ei.push_back();
            child.get_name(&em.name);
            em.value = tb->get_variant_long_value(child);
            if ( em.name.empty() )
            {
              return E_FAIL;
            }
            return S_OK;
          }
          name_value_collector_t(const til_builder_t *_tb)
            : tb(_tb) {}
        };
        name_value_collector_t nvc(this);
        if ( size != 0 && size <= 64 )
          nvc.ei.set_nbytes(size);
        HRESULT hr = pdb_access->iterate_children(sym, SymTagNull, nvc);
        if ( FAILED(hr) )
        { // corrupted name or
          // iterate_children failed to read any child
          if ( nvc.ei.empty() || nvc.ei.back().name.empty() )
          {
            code = cvt_failed;
            break;
          }
        }
        else
        {
          // Check if the type exists already. If so, create a typedef.
          qstring nm;
          const type_t *idatype = nullptr;
          get_symbol_name(sym, nm);
          if ( get_named_type(ti, nm.c_str(), NTF_TYPE, &idatype) == 1 )
          {
            // just reuse the existing enum
            if ( !out->type.deserialize(ti, &idatype) ) // this is not quite correct
              INTERR(30407);
            qstring n1;
            if ( out->type.get_type_name(&n1) )
            {
              if ( nm == n1 )
                code = cvt_typedef;       // avoid circular dependencies
            }
          }
          else
          {
            out->type.create_enum(nvc.ei);
          }
        }
      }
      break;

    case SymTagTypedef:
    case SymTagFunctionArgType:
    case SymTagFunction:
    case SymTagData:
      if ( !get_symbol_type(out, sym) )
        code = cvt_failed;
      else if ( out->type.is_decl_typedef() )
        code = cvt_typedef; // signal that this is a typedef
      break;

    case SymTagVTable:
      if ( parent == nullptr || make_vtable_struct(&out->type, *parent) != cvt_ok )
        out->type.create_typedef(ti, fake_vtable_type);
      break;
  }
  if ( code != cvt_failed && mods != 0 )
    out->type.set_modifiers(mods);
  // todo: check that the type has the expected size
  return code;
}

//----------------------------------------------------------------------
cvt_code_t til_builder_t::convert_type(
        tpinfo_t *out,
        pdb_sym_t &sym,
        pdb_sym_t *parent,
        DWORD type,
        DWORD tag)
{
  if ( level == 1000 )
  {
    deb(IDA_DEBUG_DBGINFO, "PDB: the maximum recursion level was reached\n");
    return cvt_failed;
  }
  ddeb(("PDEB: convert_type tag %d sym_id %d\n", tag, type));
  level++;
  typemap_t::iterator p = typemap.find(type);
  if ( p == typemap.end() )
  {
    tpinfo_t tpi;
    tpi.cvt_code = really_convert_type(&tpi, sym, parent, tag);
    p = typemap.insert(std::make_pair(type, tpi)).first;
  }
  tpinfo_t &tpi = p->second;
  *out = tpi;
  level--;
  return tpi.cvt_code;
}

//----------------------------------------------------------------------
uint32 til_builder_t::allocate_and_assign_ordinal(const char *name) const
{
  // type may be copied already from base til
  uint32 ord = get_type_ordinal(ti, name);
  if ( ord == 0 )
  {
    ord = alloc_type_ordinal(ti);
    // create a forward declaration.
    // we need it because named type my be appeared during copy_named_type()
    tinfo_t tif;
    tif.create_typedef(ti, "", BTF_STRUCT, false);
    tif.set_numbered_type(ti, ord, NTF_TYPE, name);
  }
  return ord;
}

//----------------------------------------------------------------------
bool til_builder_t::begin_creation(DWORD tag, const qstring &name, uint32 *p_ord)
{
  if ( tag != SymTagFunction )
  {
    uint32 ord = *p_ord;
    creating_t::iterator c = creating.find(name);
    if ( c != creating.end() ) // recursive call
    {
      if ( c->second == 0 ) // allocated?
      {
        if ( ord == 0 )
          ord = allocate_and_assign_ordinal(name.c_str());
        c->second = ord;
        QASSERT(490, ord != 0);
        ddeb(("PDEB: '%s' prematurely mapped to %u\n", name.c_str(), ord));
      }
      *p_ord = c->second;
      return false;
    }
    creating.insert(std::make_pair(name, ord)); // add to the 'creating' list
  }
  return true;
}

//----------------------------------------------------------------------------
uint32 til_builder_t::end_creation(const qstring &name)
{
  uint32 ord = 0;
  creating_t::iterator c = creating.find(name);
  if ( c != creating.end() )
  {
    ord = c->second;
    creating.erase(c);
  }
  if ( ord == 0 )
  {
    ord = allocate_and_assign_ordinal(name.c_str());
    QASSERT(491, ord != 0);
    ddeb(("PDEB: '%s' prematurely mapped to %u\n", name.c_str(), ord));
  }
  return ord;
}


//----------------------------------------------------------------------------
cvt_code_t til_builder_t::handle_overlapping_members(pdb_udt_type_data_t *udt) const
{
  qstack<qstring> union_names;
  pdb_udt_type_data_t::iterator end = udt->end();
  pdb_udt_type_data_t::iterator first = end; // !=end => collecting union members
  pdb_udt_type_data_t::iterator last = end;  // member with highest ending offset so far
  for ( pdb_udt_type_data_t::iterator p=udt->begin(); ; ++p )
  {
    if ( p != udt->end() )
    {
      if ( is_unnamed_tag_typedef(p->type) )
        handle_unnamed_overlapping_member(udt, &union_names, &p->name);
      if ( last == end )
      {
        last = p;
        continue;
      }
      if ( last->end() > p->begin() )
      { // found an overlap. however, we ignore base classes, in order
        // not to convert them into unions
        if ( first == end && !last->is_baseclass() )
          first = last;
        goto NEXT;
      }
    }
    if ( first != end )
    {
      int fidx = first - udt->begin();
      uval_t off = first->offset;
      // if we have a bitfield, include the adjacent bitfields in the new type
      int bf_typesize = 0;
      for ( pdb_udt_type_data_t::iterator q=first; q != p; ++q )
      {
        if ( q->is_bitfield() )
        {
          bf_typesize = q->type.get_size();
          break;
        }
      }
      if ( bf_typesize != 0 )
      {
        while ( fidx > 0
             && (first-1)->is_bitfield()
             && (first-1)->type.get_size() == bf_typesize )
        {
          --fidx;
          --first;
          off = first->offset;
        }
        // calculate collected bitfield size so far
        uint64 bf_collected_size = 0;
        for ( pdb_udt_type_data_t::iterator q=first; q != p; ++q )
        {
          if ( q->is_bitfield() )
            bf_collected_size += q->bit_offset + q->size;
        }
        // Fields are sorted by offsets. If union fields are structures,
        // it may lead to puzzling situations like this:
        //  4. offset 0x80 size 0x8  'Variant' type      'unsigned __int8' effalign 0 tafld_bits 0x0 fda 0 bit_offset 0
        //  5. offset 0x80 size 0x8  'Padding' type      'unsigned __int32 : 8' effalign 0 tafld_bits 0x0 fda 0 bit_offset 0
        //  6. offset 0x88 size 0x18 'Reserved' type     'unsigned __int8[3]' effalign 0 tafld_bits 0x0 fda 0 bit_offset 0
        //  7. offset 0x88 size 0x1  'ChangeTimeUpgrade' type 'unsigned __int32 : 1' effalign 0 tafld_bits 0x0 fda 0 bit_offset 8
        //  8. offset 0x89 size 0x17 'ReservedFlags'     type 'unsigned __int32 : 23' effalign 0 tafld_bits 0x0 fda 0 bit_offset 9
        // Here the "Padding' and 'Reserved' fields belong to different sub-structures:
        //   struct $2BE9FDB777E807E44C324ABC6EC300EB
        //   {
        //       unsigned __int8 Variant;
        //       unsigned __int8 Reserved[3];
        //   };
        //
        //   struct $A201E2401D2F1CB09DF5150550A30288
        //   {
        //       unsigned __int32 Padding : 8;
        //       unsigned __int32 ChangeTimeUpgrade : 1;
        //       unsigned __int32 ReservedFlags : 23;
        //   };
        //
        //   union $6092742E3C4906EBD927CAE4613FA161
        //   {
        //       $2BE9FDB777E807E44C324ABC6EC300EB __s0;
        //       $A201E2401D2F1CB09DF5150550A30288 __s1;
        //   };
        if ( p != end
          && !p->is_bitfield()
          && bf_collected_size != 0
          && bf_collected_size < bf_typesize*8
          && (p+1) != end
          && p->offset == (p+1)->offset
          && (p+1)->is_bitfield()
          && bf_collected_size <= (p+1)->bit_offset
          && (p+1)->type.get_size() == bf_typesize )
        {
          ++p;
        }
        while ( p != end
             && p->is_bitfield()
             && p->type.get_size() == bf_typesize )
        {
          ++p;
        }
      }
      // range [first, p) is overlapping, create a new type for it
      tinfo_t unitif;
      size_t union_size;
      cvt_code_t code = create_union(&unitif, &union_size, first, p);
      if ( code != cvt_ok )
        return code;
      udt->erase(first+1, p);
      end = udt->end();
      first = end;
      last = end;
      p = udt->begin() + fidx;
      p->offset = off & ~7;
      p->size = uint64(union_size) * 8;
      if ( union_names.empty() )
        p->name.sprnt("___u%d", fidx);
      else
        p->name = union_names.pop();
      p->type = unitif;
    }
    if ( p == end )
      break;
NEXT:
    if ( last->end() < p->end() )
      last = p;
  }
  return cvt_ok;
}


//----------------------------------------------------------------------------
void til_builder_t::handle_function_type(pdb_sym_t &fun_sym, ea_t ea)
{
  struct local_data_creator_t : public pdb_access_t::children_visitor_t
  {
    virtual HRESULT visit_child(pdb_sym_t &sym) override
    {
      DWORD tag = 0;
      HRESULT hr = sym.get_symTag(&tag);
      if ( FAILED(hr) )
        return hr;

      switch ( tag )
      {
        case SymTagBlock: // nested blocks
          return tb->pdb_access->iterate_children(sym, SymTagNull, *this);
        case SymTagFuncDebugStart:
        case SymTagFuncDebugEnd:
          return S_OK;    // ignore these for the moment
      }

      DWORD loc_type;
      if ( sym.get_locationType(&loc_type) != S_OK )
        return S_OK; // optimized away?

      return tb->handle_function_child(fun_sym, ea, sym, tag, loc_type);
    }
    local_data_creator_t(til_builder_t *_tb, pdb_sym_t &_fun_sym, ea_t _ea) :
      tb(_tb), fun_sym(_fun_sym), ea(_ea) {}
    til_builder_t *tb;
    pdb_sym_t &fun_sym;
    ea_t ea;
  };
  local_data_creator_t ldc(this, fun_sym, ea);
  pdb_access->iterate_children(fun_sym, SymTagNull, ldc);
}


//----------------------------------------------------------------------------
void til_builder_t::type_created(
        ea_t /*ea*/,
        int /*id*/,
        const char * /*name*/,
        const tinfo_t & /*ptr*/) const
{
}


//----------------------------------------------------------------------------
HRESULT til_builder_t::handle_function_child(
        pdb_sym_t & /*fun_sym*/,
        ea_t ea,
        pdb_sym_t &child_sym,
        DWORD child_tag,
        DWORD child_loc_type)
{
  switch ( child_loc_type )
  {
    case LocIsConstant:
      break; // we ignore function level constants

    case LocIsStatic:
    case LocIsTLS:              // not tested
      handle_symbol(child_sym);
      break;

    case LocIsEnregistered:
    case LocIsRegRel:
      break;

    default:
      ask_for_feedback("pdb: unsupported location type %d, tag %d at %a", child_loc_type, child_tag, ea);
      break;
  }
  return S_OK;
}


//----------------------------------------------------------------------------
cvt_code_t til_builder_t::create_udt_ref(tinfo_t *out, pdb_udt_type_data_t *udt, int udt_kind) const
{
  tinfo_t tif;
  cvt_code_t code = create_udt(&tif, udt, udt_kind, nullptr);
  if ( code != cvt_ok )
    return code;

  qtype type, fields;
  tif.serialize(&type, &fields);

  qstring name;
  build_anon_type_name(&name, type.begin(), fields.begin());
  uint32 ord = get_type_ordinal(ti, name.c_str());
  if ( ord == 0 )
  {
    ord = alloc_type_ordinal(ti);
    if ( tif.set_numbered_type(ti, ord, NTF_NOBASE|NTF_FIXNAME, name.c_str()) != TERR_OK )
      return cvt_failed;
    type_created(BADADDR, ord, nullptr, tif);
  }

  out->create_typedef(ti, ord);
  return cvt_ok;
}

//----------------------------------------------------------------------------
bool til_builder_t::retrieve_type(
        tpinfo_t *out,
        pdb_sym_t &sym,
        pdb_sym_t *parent,
        uint32 *p_ord)
{
  if ( p_ord != nullptr )
    *p_ord = 0;

  // id -> unknown typedef?
  DWORD sym_id = 0;
  sym.get_symIndexId(&sym_id);
  tpdefs_t::iterator q = tpdefs.find(sym_id);
  if ( q != tpdefs.end() )
  {
    out->type = q->second;
    return true;
  }

  DWORD tag = 0;
  HRESULT hr = sym.get_symTag(&tag);
  if ( FAILED(hr) )
    return false;

  qstring ns;
  bool is_unnamed = get_symbol_name(sym, ns);
  //msg("ID: %d -> %s\n", sym_id, ns.begin());
  uint32 ord = 0;
  bool ord_set = false;
  if ( tag == SymTagVTable && ns.empty() )
  {
    if ( parent != nullptr )
      get_symbol_name(*parent, ns);
    LONG offset = 0;
    sym.get_offset(&offset);
    get_vft_name(&ns, &ord, ns.c_str(), offset);

    is_unnamed = false;
    ord_set = true;
  }

  // udt fields and simple types are converted without allocating
  // an ordinal number
  if ( tag == SymTagData || ns.empty() )
    return convert_type(out, sym, parent, sym_id, tag) != cvt_failed;

  // give a unique name to unnamed types so they can be told apart
  // this is a temporary name, it will be replaced by $hex..
  if ( is_unnamed )
    ns.sprnt("unnamed-%d", unnamed_idx++);
  else
    validate_name(&ns, VNT_TYPE);

  // some types can be defined multiple times. check if the name is already defined
  bool defined_correctly = false;
  type_t tif_mod = 0;
  if ( !ord_set )
    ord = get_type_ordinal(ti, ns.c_str());
  if ( ord != 0 )
  {
    tinfo_t tif;
    tif.create_typedef(ti, ord);
    tif_mod = get_sym_modifiers(sym);
    if ( tif.get_realtype() != BT_UNK || !tif.is_forward_decl() )
      defined_correctly = true;
  }
  if ( !defined_correctly )
  {
    if ( begin_creation(tag, ns, &ord) )
    {
      // now convert the type information, recursive types won't bomb
      tpinfo_t tpi2;
      cvt_code_t cc = convert_type(&tpi2, sym, parent, sym_id, tag);
      if ( cc != cvt_ok ) // failed or typedef
      {
        creating.erase(ns);
        if ( cc == cvt_failed )
          return false;
        // cvt_typedef
        {
          tinfo_t tif;
          tif.create_typedef(ti, ns.c_str());
          tif.set_modifiers(tpi2.type.get_modifiers());
          tpdefs[sym_id] = tif;   // reference to unknown typedef
          if ( tpi2.type.present() && tpi2.type.is_decl_typedef() )
          { // do not put a lot of garbage to types: forward declarations etc
            if ( !tpi2.type.set_named_type(nullptr, ns.c_str(), NTF_TYPE|NTF_REPLACE) )
              return false;
            type_created(BADADDR, 0, ns.c_str(), tpi2.type);
          }
        }
        out->type = tpi2.type;
        return true;
      }

      qtype type, fields;
      if ( !tpi2.type.serialize(&type, &fields) )
        INTERR(30408);

      // Function types are saved as symbols
      if ( tag == SymTagFunction )
      {
        // the following may fail because of c++ overloaded functions
        // do not check the error code - we cannot help it
        tpi2.type.set_symbol_type(ti, ns.c_str(), NTF_SYMM);
        type_created(BADADDR, 0, ns.c_str(), tpi2.type);
        out->type = tpi2.type;
        return true;
      }

      bool reuse_anon_type = false;
      if ( is_unnamed ) // this type will be referenced, so create a name for it
      {
        build_anon_type_name(&ns, type.begin(), fields.begin());
        ord = get_type_ordinal(ti, ns.c_str());
        if ( ord != 0 ) // this type already exists, just reuse it
        {
          creating.erase(ns);
          reuse_anon_type = true;
        }
        tif_mod = get_sym_modifiers(sym);
      }
      if ( !reuse_anon_type )
      {
        ord = end_creation(ns);
        int ntf_flags = NTF_NOBASE|NTF_FIXNAME|NTF_REPLACE;
        tinfo_t tif;
        tinfo_code_t code = tif.deserialize(ti, &type, &fields)
                          ? tif.set_numbered_type(ti, ord, ntf_flags, ns.empty() ? nullptr : ns.c_str())
                          : TERR_BAD_TYPE;
        if ( code != TERR_OK )
        {
          ddeb(("PDEB: set_numbered_type(%u, %s) : %s\n", ord, ns.c_str(), tinfo_errstr(code)));
          return false;
        }
        tif_mod = tpi2.type.get_modifiers();
      }
      if ( is_unnamed )
        unnamed_types.insert(ord);
      // msg("%d: %s\n  name: %s\n", ord, tpi2.dstr(), ns.c_str());
      type_created(BADADDR, ord, nullptr, tpi2.type);
    }
    else
    { // in case of recursive call we need to preserve modifiers
      tif_mod = get_sym_modifiers(sym);
    }
  }
  if ( p_ord != nullptr )
    *p_ord = ord;
  out->type.create_typedef(ti, ord);
  if ( tif_mod != 0 )
    out->type.set_modifiers(tif_mod);
  return true;
}


//----------------------------------------------------------------------------
bool til_builder_t::handle_symbol_at_ea(pdb_sym_t &/*sym*/, DWORD /*tag*/, ea_t /*ea*/, qstring & /*name*/)
{
  return true;
}


//----------------------------------------------------------------------------
HRESULT til_builder_t::handle_symbol(pdb_sym_t &sym)
{
  DWORD id;
  HRESULT hr = sym.get_symIndexId(&id);
  if ( FAILED(hr) )
    return hr;

  if ( handled.find(id) != handled.end() )
    return S_OK;
  handled.insert(id);

  DWORD tag = 0;
  hr = sym.get_symTag(&tag);
  if ( FAILED(hr) )
    return hr;

  switch ( tag )
  {
    case SymTagNull:
    case SymTagExe:
    case SymTagCompiland:
    case SymTagCompilandEnv:
    case SymTagCustom:
    case SymTagCustomType:
    case SymTagManagedType:
    case SymTagUDT:
    case SymTagEnum:
    case SymTagFunctionType:
    case SymTagPointerType:
    case SymTagArrayType:
    case SymTagBaseType:
    case SymTagTypedef:
    case SymTagBaseClass:
    case SymTagFunctionArgType:
    case SymTagUsingNamespace:
    case SymTagVTableShape:
    case SymTagDimension:
      return S_OK;
    case SymTagCompilandDetails:
      {
        DWORD backEndVer;
        if ( is_intel386(pdb_access->get_machine_type()) && sym.get_backEndMajor(&backEndVer) == S_OK )
          enregistered_bug = backEndVer <= 13;
      }
      return S_OK;
    // new tags for msdia140
    case SymTagCallSite:
    case SymTagInlineSite:
    case SymTagBaseInterface:
    case SymTagVectorType:
    case SymTagMatrixType:
    case SymTagHLSLType:
    case SymTagCaller:
    case SymTagCallee:
    case SymTagExport:
    case SymTagHeapAllocationSite:
    case SymTagCoffGroup:
    case SymTagInlinee:
      return S_OK;
    default:
      ASSERT(tag < SymTagCallSite);
      break;
  }

  DWORD off = 0;
  hr = sym.get_relativeVirtualAddress(&off);
  if ( hr == S_OK )
  {
    ea_t ea = get_load_address() + off;
    qstring name;
    sym.get_name(&name);
    handle_symbol_at_ea(sym, tag, ea, name);
  }
  return S_OK;
}

//----------------------------------------------------------------------
// Each time we encounter a toplevel type/func/whatever, we want to make
// sure the UI has had a chance to refresh itself.
struct toplevel_children_visitor_t : public pdb_access_t::children_visitor_t
{
  virtual HRESULT visit_child(pdb_sym_t &sym) override
  {
    if ( user_cancelled() )
      return E_ABORT;
    return do_visit_child(sym);
  }

  virtual HRESULT do_visit_child(pdb_sym_t &sym) = 0;
};

//-------------------------------------------------------------------------
struct symbol_handler_t : public toplevel_children_visitor_t
{
  virtual HRESULT do_visit_child(pdb_sym_t &sym) override
  {
    return tb->handle_symbol(sym);
  }
  symbol_handler_t(til_builder_t *_tb) : tb(_tb) {}
  til_builder_t *tb;
};

//-------------------------------------------------------------------------
HRESULT til_builder_t::handle_symbols(pdb_sym_t &global_sym)
{
  symbol_handler_t cp(this);
  HRESULT hr;
  while ( true )
  {
    hr = pdb_access->iterate_subtags(global_sym, SymTagNull, cp);
    if ( FAILED(hr) )
      break;
    if ( !iterate_symbols_once_more(global_sym) )
      break;
  }
  return hr;
}

//-------------------------------------------------------------------------
HRESULT til_builder_t::handle_publics(pdb_sym_t &global_sym)
{
  symbol_handler_t cp(this);
  return pdb_access->iterate_children(global_sym, SymTagPublicSymbol, cp);
}

//-------------------------------------------------------------------------
HRESULT til_builder_t::handle_globals(pdb_sym_t &global_sym)
{
  symbol_handler_t cp(this);
  return pdb_access->iterate_children(global_sym, SymTagData, cp);
}


//----------------------------------------------------------------------
HRESULT til_builder_t::handle_types(pdb_sym_t &global_sym)
{
  struct type_importer_t : public toplevel_children_visitor_t
  {
    til_builder_t *tb;
    int counter;
    virtual HRESULT do_visit_child(pdb_sym_t &sym) override
    {
      tpinfo_t tpi;
      if ( tb->retrieve_type(&tpi, sym, parent) )
        counter++;
      return S_OK;
    }
    type_importer_t(til_builder_t *_tb) : tb(_tb), counter(0) {}
  };
  type_importer_t timp(this);
  HRESULT hr = pdb_access->iterate_children(global_sym, SymTagEnum, timp);
  if ( hr == S_OK )
    hr = pdb_access->iterate_children(global_sym, SymTagUDT, timp);
  if ( hr == S_OK )
    hr = pdb_access->iterate_children(global_sym, SymTagTypedef, timp);
  msg("PDB: loaded %d type%s\n", timp.counter, timp.counter != 1 ? "s" : "");
  return hr;
}


//----------------------------------------------------------------------------
HRESULT til_builder_t::before_iterating(pdb_sym_t &)
{
  return S_OK;
}


//----------------------------------------------------------------------------
HRESULT til_builder_t::after_iterating(pdb_sym_t &)
{
  return S_OK;
}

//----------------------------------------------------------------------------
HRESULT til_builder_t::build(pdb_sym_t &global_sym)
{
  HRESULT hr = before_iterating(global_sym);
  if ( hr == S_OK && (pdb_access->pdbargs.flags & PDBFLG_LOAD_TYPES) != 0 )
  {
    show_wait_box("Handling types ...");
    if ((pdb_access->pdbargs.flags & PDBFLG_IS_MINIPDB) == 0)
    {
      hr = handle_types(global_sym);
    }
    hide_wait_box();
  }
  if ( (pdb_access->pdbargs.flags & PDBFLG_LOAD_NAMES) != 0 )
  {
    show_wait_box("Handling symbols ...");
    if ((pdb_access->pdbargs.flags & PDBFLG_IS_MINIPDB) == 0)
    {
      if ( hr == S_OK )
        hr = handle_symbols(global_sym);
      if ( hr == S_OK )
        hr = handle_globals(global_sym);
    }
    // handle_globals() will set the type and undecorated name for globals,
    // and handle_publics() will set the decorated name for public symbols.
    // We want both the type (from handle_globals()) and the decorated symbol
    // name (from handle_publics()), since that gives the user more information
    // about the variable and enables FLIRT to match rulefuncs based on the
    // symbol name.
    // For example, @__security_check_cookie@4 is used as a rulefunc by FLIRT,
    // and that won't match with the undecorated name __security_check_cookie.
    // Therefore, handle_publics() must be called *after* handle_globals().
    if ( hr == S_OK )
      hr = handle_publics(global_sym);
    hide_wait_box();
  }
  if ( hr == S_OK )
  {
    show_wait_box("Creating virtual function tables ...");
    create_vftables();
    hide_wait_box();
    if ( user_cancelled() )
      return E_ABORT;

    hr = after_iterating(global_sym);
  }
  return hr;
}

```

`tilbuild.hpp`:

```hpp
#pragma once

//----------------------------------------------------------------------------
enum cvt_code_t
{
  cvt_failed,
  cvt_ok,
  cvt_typedef           // conversion resulted in a typedef to a named type
};

//----------------------------------------------------------------------------
// PBD provides the offset of a bitfield inside a bitfield group.
// We subclass udm_t in order to keep that information separate from
// the 'offset' field.
struct pdb_udm_t : public udm_t
{
  uint32 bit_offset = 0;    ///< member offset in bits from start of bitfield group
};
DECLARE_TYPE_AS_MOVABLE(pdb_udm_t);
typedef qvector<pdb_udm_t> pdbudtmembervec_t; ///< vector of pdb udt member objects

//----------------------------------------------------------------------------
// stripped-down version of udt_type_data_t with only the fields used by pdb.
struct pdb_udt_type_data_t : public pdbudtmembervec_t
{
  size_t total_size;    ///< total structure size in bytes
  uint32 taudt_bits;    ///< TA... and TAUDT... bits
  bool is_union;        ///< is union or struct?

  pdb_udt_type_data_t(void)
    : total_size(0),
      taudt_bits(0),
      is_union(false)
  {
  }

  void convert_to_tinfo_udt(udt_type_data_t *out);
};
DECLARE_TYPE_AS_MOVABLE(pdb_udt_type_data_t);

//----------------------------------------------------------------------------
class til_builder_t
{
protected:
  pdb_ctx_t &pv;
public:

  //----------------------------------------------------------------------------
  struct tpinfo_t
  {
    cvt_code_t cvt_code;
    bool is_notype;
    tinfo_t type;
    til_t *ti;  // FIXME: do we need this?
    tpinfo_t(void) : cvt_code(cvt_ok), is_notype(false), ti(nullptr) {}
    tpinfo_t(til_t *_ti, const tinfo_t &t) : cvt_code(cvt_ok), is_notype(false), type(t), ti(_ti) {}
    const char *dstr(void) const
    {
      if ( cvt_code == cvt_failed )
        return "#cvt_failed";

      static qstring res;
      if ( !type.print(&res) )
        res = "#print_failed";
      return res.c_str();
    }
  };

  //----------------------------------------------------------------------------
  til_builder_t(pdb_ctx_t &_pv, til_t *_ti, pdb_access_t *_pa)
    : pv(_pv),
      unnamed_idx(0),
      level(0),
      ti(_ti),
      pdb_access(nullptr),
      enregistered_bug(false)
  {
    set_pdb_access(_pa);
  }

  virtual ~til_builder_t()
  {
    typemap.clear();
    tpdefs.clear();
    handled.clear();
    creating.clear();
    unnamed_types.clear();
  }

  void set_pdb_access(pdb_access_t *_pdb_access)
  {
    pdb_access = _pdb_access;
  }

  typedef std::map<DWORD, tpinfo_t> typemap_t;
  typedef std::map<DWORD, tinfo_t> tpdefs_t;
  typedef std::set<DWORD> idset_t;
  typedef std::map<qstring, uint32> creating_t;   // typename : ordinal
  typedef std::set<uint32> unnamed_t;

  struct vft_info_t
  {
    udt_type_data_t udt;  // collected vft members
    qstring base0;        // base vftable at offset 0

    vft_info_t() { udt.taudt_bits |= TAUDT_VFTABLE; }
    bool empty() const { return udt.empty() && base0.empty(); }
  };
  typedef std::map<qstring, vft_info_t> vftmap_t;

  //      remove `anonymous-namespace'::
  // also remove `anonymous namespace'::
  void remove_anonymous_namespaces(qstring &storage);

  bool get_symbol_type(tpinfo_t *out, pdb_sym_t &sym, uint32 *p_ord=nullptr);
  bool retrieve_type(tpinfo_t *out, pdb_sym_t &sym, pdb_sym_t *parent, uint32 *p_ord=nullptr);
  callcnv_t retrieve_arguments(
        pdb_sym_t &sym,
        func_type_data_t &fi,
        pdb_sym_t *funcSym,
        callcnv_t cc);
  callcnv_t convert_cc(DWORD cc0) const;
  bool get_variant_string_value(qstring *out, pdb_sym_t &sym) const;
  uint32 get_variant_long_value(pdb_sym_t &sym) const;
  uint32 allocate_and_assign_ordinal(const char *name) const;
  bool begin_creation(DWORD tag, const qstring &name, uint32 *p_id);
  uint32 end_creation(const qstring &name);
  bool is_member_func(tinfo_t *class_type, pdb_sym_t &typeSym, pdb_sym_t *funcSym);
  bool is_frame_reg(int regnum) const;
  bool is_stack_reg(int regnum) const;
  bool is_complex_return(pdb_sym_t &sym) const;
  bool is_unnamed_tag_typedef(const tinfo_t &tif) const;
  int get_symbol_funcarg_info(
        funcarg_t *out,
        pdb_sym_t &sym,
        DWORD /*dwDataKind*/,
        DWORD locType,
        int stack_off);
  void enum_function_args(pdb_sym_t &sym, func_type_data_t &args);
  cvt_code_t verify_struct(pdb_udt_type_data_t &udt) const;
  bool verify_union_stem(pdb_udt_type_data_t &udt) const;
  cvt_code_t fix_bit_union(pdb_udt_type_data_t *udt) const;
  cvt_code_t verify_union(
        pdb_udt_type_data_t *out,
        pdb_udt_type_data_t::iterator p1,
        pdb_udt_type_data_t::const_iterator p2) const;
  cvt_code_t create_union(
        tinfo_t *out,
        size_t *p_total_size,
        pdb_udt_type_data_t::iterator p1,
        pdb_udt_type_data_t::const_iterator p2) const;
  cvt_code_t convert_basetype(tpinfo_t *out, DWORD baseType, int size) const;
  cvt_code_t make_vtable_struct(tinfo_t *out, pdb_sym_t &sym);
  cvt_code_t convert_udt(tinfo_t *out, pdb_sym_t &sym, DWORD64 size);
  cvt_code_t create_udt(tinfo_t *out, pdb_udt_type_data_t *udt, int udtKind, const char *udt_name) const;
  cvt_code_t create_udt_ref(tinfo_t *out, pdb_udt_type_data_t *udt, int udt_kind) const;
  cvt_code_t really_convert_type(tpinfo_t *out, pdb_sym_t &sym, pdb_sym_t *parent, DWORD tag);
  cvt_code_t convert_type(
        tpinfo_t *out,
        pdb_sym_t &sym,
        pdb_sym_t *parent,
        DWORD type,
        DWORD tag);
  cvt_code_t handle_overlapping_members(pdb_udt_type_data_t *udt) const;
  // Will iterate on children, and call handle_function_child()
  HRESULT handle_symbols(pdb_sym_t &pGlobal);
  HRESULT handle_globals(pdb_sym_t &pGlobal);
  HRESULT handle_publics(pdb_sym_t &pGlobal);
  HRESULT handle_types(pdb_sym_t &pGlobal);
  HRESULT build(pdb_sym_t &pGlobal);
  ea_t get_load_address() const { return pdb_access->get_base_address(); }
  HRESULT handle_symbol(pdb_sym_t &sym);
  size_t get_symbol_type_length(pdb_sym_t &sym) const;
  void create_vftables();
  // check for MS or IDA vftable name,
  // get type ordinal of vftable
  // returns the type is creating
  bool get_vft_name(qstring *vft_name, uint32 *ord, const char *udt_name, uint32_t offset=0);
  void fix_thisarg_type(const qstring &udt_name);
  bool fix_ctor_to_return_ptr(func_type_data_t *fti, pdb_sym_t *parent);

  virtual HRESULT before_iterating(pdb_sym_t &global_sym);
  virtual HRESULT after_iterating(pdb_sym_t &global_sym);
  virtual bool iterate_symbols_once_more(pdb_sym_t & /*global_sym*/) { return false; }
  virtual bool get_symbol_name(pdb_sym_t &sym, qstring &storage);
  virtual bool handle_symbol_at_ea(
        pdb_sym_t &sym,
        DWORD tag,
        ea_t ea,
        qstring &name);
  virtual void type_created(ea_t /*ea*/, int /*id*/, const char * /*name*/, const tinfo_t & /*ptr*/) const;
  virtual void handle_function_type(pdb_sym_t &fun_sym, ea_t ea);
  virtual HRESULT handle_function_child(
        pdb_sym_t &fun_sym,
        ea_t ea,
        pdb_sym_t &child_sym,
        DWORD child_tag,
        DWORD child_loc_type);
  virtual cvt_code_t handle_unnamed_overlapping_member(
        pdb_udt_type_data_t * /*udt*/,
        qstack<qstring> * /*union_names*/,
        qstring * /*name*/) const
  {
    return cvt_ok;
  }

protected:
  typemap_t typemap;            // id -> type info
  tpdefs_t tpdefs;              // id -> enum type defined in base til
  idset_t handled;              // set of handled symbols
  creating_t creating;
  unnamed_t unnamed_types;
  vftmap_t vftmap;              // vftable name -> vft info
  int unnamed_idx;
  int level;

public:
  til_t *ti;
  pdb_access_t *pdb_access;
  bool enregistered_bug;
};

```

`varser.hpp`:

```hpp

#ifndef VARSER_HPP
#define VARSER_HPP

// Variant serializer/deserializer.
struct varser_t
{
#ifdef __NT__
  static bool serialize(bytevec_t &out, const VARIANT &var);
#else
  static bool deserialize(VARIANT &var, const uchar **in, const uchar *const end);
#endif
};

#ifdef __NT__
//-------------------------------------------------------------------------
bool varser_t::serialize(bytevec_t &out, const VARIANT &var)
{
  out.pack_dw(var.vt);
  if ( (var.vt & VT_BYREF) == VT_BYREF
    || (var.vt & VT_ARRAY) == VT_ARRAY )
  {
    return false;
  }

  const size_t sz_before = out.size();
  switch ( var.vt )
  {
    case VT_EMPTY: // = 0x0000,
    case VT_NULL: // = 0x0001,
      break;
    case VT_I2: // = 0x0002,
    case VT_UI2: // = 0x0012,
      out.pack_dw(var.uiVal);
      break;
    case VT_I4: // = 0x0003,
    case VT_UI4: // = 0x0013,
      out.pack_dd(var.ulVal);
      break;
    case VT_R4: // = 0x0004,
      out.pack_dd(*(uint32*)&var.fltVal);
      break;
    case VT_R8: // = 0x0005,
      out.pack_dq(*(uint64*)&var.dblVal);
      break;
    case VT_CY: // = 0x0006,
    case VT_DATE: // = 0x0007,
      break;
    case VT_BSTR: // = 0x0008,
      {
        uint8 *ptr = (uint8*) var.bstrVal;
        ptr -= 4;
        uint32 bcnt = * (uint32*) ptr;
        out.pack_buf(ptr + 4, bcnt);
      }
      break;
    case VT_DISPATCH: // = 0x0009,
    case VT_ERROR: // = 0x000A,
    case VT_BOOL: // = 0x000B,
    case VT_VARIANT: // = 0x000C,
    case VT_UNKNOWN: // = 0x000D,
    case VT_DECIMAL: // = 0x000E,
    case VT_I1: // = 0x0010,
    case VT_UI1: // = 0x0011,
      out.pack_db(var.bVal);
      break;
    case VT_I8: // = 0x0014,
    case VT_UI8: // = 0x0015,
      out.pack_dq(var.ullVal);
      break;
    case VT_INT: // = 0x0016,
    case VT_UINT: // = 0x0017,
    case VT_HRESULT: // = 0x0019,
      out.pack_dd(var.uintVal);
      break;
    case VT_VOID: // = 0x0018,
    case VT_PTR: // = 0x001A,
    case VT_SAFEARRAY: // = 0x001B,
    case VT_CARRAY: // = 0x001C,
    case VT_USERDEFINED: // = 0x001D,
    case VT_LPSTR: // = 0x001E,
    case VT_LPWSTR: // = 0x001F,
    case VT_RECORD: // = 0x0024,
    case VT_INT_PTR: // = 0x0025,
    case VT_UINT_PTR: // = 0x0026,
      break;
    default: break;
  }
  return out.size() > sz_before;
}
#else
//-------------------------------------------------------------------------
bool varser_t::deserialize(VARIANT &var, const uchar **in, const uchar *const end)
{
  var.vt = unpack_dw(in, end);
  if ( (var.vt & VT_BYREF) == VT_BYREF
    || (var.vt & VT_ARRAY) == VT_ARRAY )
  {
    return false;
  }

  bool ok = false;
  switch ( var.vt )
  {
    case VT_EMPTY: // = 0x0000,
    case VT_NULL: // = 0x0001,
      break;
    case VT_I2: // = 0x0002,
    case VT_UI2: // = 0x0012,
      var.uiVal = unpack_dw(in, end);
      ok = true;
      break;
    case VT_I4: // = 0x0003,
    case VT_UI4: // = 0x0013,
      var.ulVal = unpack_dd(in, end);
      ok = true;
      break;
    case VT_R4: // = 0x0004,
      {
        uint32 res = unpack_dd(in, end);
        var.fltVal = *(FLOAT*)&res;
        ok = true;
      }
      break;
    case VT_R8: // = 0x0005,
      {
        uint64 res = unpack_dq(in, end);
        var.dblVal = *(DOUBLE*)&res;
        ok = true;
      }
      break;
    case VT_CY: // = 0x0006,
    case VT_DATE: // = 0x0007,
      break;
    case VT_BSTR: // = 0x0008,
      {
        uint32 bcnt = unpack_dd(in, end);
        uint32 nbytes = bcnt + 4 + 2; // +2 for terminating null character
        QASSERT(30472, nbytes > bcnt); // check for integer overflow
        uint8 *raw = (uint8 *)qalloc(nbytes);
        if ( raw != nullptr )
        {
          *(uint32*)raw = bcnt;
          raw += 4;
          unpack_obj(raw, bcnt, in, end);
          raw[bcnt] = '\0';
          raw[bcnt+1] = '\0';
          var.bstrVal = raw;
          ok = true;
        }
      }
      break;
    case VT_LPSTR: // = 0x001E,
    case VT_LPWSTR: // = 0x001F,
      {
        char *tmp = qstrdup(unpack_str(in, end));
        var.byref = tmp;
        ok = true;
      }
      break;
    case VT_DISPATCH: // = 0x0009,
    case VT_ERROR: // = 0x000A,
    case VT_BOOL: // = 0x000B,
    case VT_VARIANT: // = 0x000C,
    case VT_UNKNOWN: // = 0x000D,
    case VT_DECIMAL: // = 0x000E,
    case VT_I1: // = 0x0010,
    case VT_UI1: // = 0x0011,
      var.bVal = unpack_db(in, end);
      ok = true;
      break;
    case VT_I8: // = 0x0014,
    case VT_UI8: // = 0x0015,
      var.ullVal = unpack_dq(in, end);
      ok = true;
      break;
    case VT_INT: // = 0x0016,
    case VT_UINT: // = 0x0017,
    case VT_HRESULT: // = 0x0019,
      var.uintVal = unpack_dd(in, end);
      ok = true;
      break;
    case VT_VOID: // = 0x0018,
    case VT_PTR: // = 0x001A,
    case VT_SAFEARRAY: // = 0x001B,
    case VT_CARRAY: // = 0x001C,
    case VT_USERDEFINED: // = 0x001D,
    case VT_RECORD: // = 0x0024,
    case VT_INT_PTR: // = 0x0025,
    case VT_UINT_PTR: // = 0x0026,
      break;
    default: break;
  }
  return ok;
}
#endif // __NT__

#endif // VARSER_HPP

```