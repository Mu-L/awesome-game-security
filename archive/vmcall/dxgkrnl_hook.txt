Project Path: arc_vmcall_dxgkrnl_hook_zksgmd6q

Source Tree:

```txt
arc_vmcall_dxgkrnl_hook_zksgmd6q
├── README.md
├── dxgkrnl_hook
│   ├── Device.h
│   ├── Driver.h
│   ├── Public.h
│   ├── Queue.h
│   ├── Trace.h
│   ├── dxgkrnl_hook.cpp
│   ├── dxgkrnl_hook.hpp
│   ├── dxgkrnl_hook.inf
│   ├── dxgkrnl_hook.vcxproj
│   ├── dxgkrnl_hook.vcxproj.filters
│   └── entry.cpp
└── dxgkrnl_hook.sln

```

`README.md`:

```md
# dxgkrnl_hook

This hooks the graphics kernel subsystem to allow manipulation of the screen buffer, for more info see the [write-up](https://secret.club/2019/10/18/kernel_gdi_hook.html)

# Example usage

The player boxes in [this](https://secret.club/assets/img/rainbow.mp4) video is drawn by using that hook.

```

`dxgkrnl_hook.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28010.2016
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dxgkrnl_hook", "dxgkrnl_hook\dxgkrnl_hook.vcxproj", "{11ADF42E-392F-4AA8-86B6-484120E7A540}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Debug|ARM.ActiveCfg = Debug|ARM
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Debug|ARM.Build.0 = Debug|ARM
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Debug|ARM.Deploy.0 = Debug|ARM
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Debug|ARM64.Build.0 = Debug|ARM64
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Debug|x64.ActiveCfg = Debug|x64
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Debug|x64.Build.0 = Debug|x64
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Debug|x64.Deploy.0 = Debug|x64
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Debug|x86.ActiveCfg = Debug|Win32
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Debug|x86.Build.0 = Debug|Win32
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Debug|x86.Deploy.0 = Debug|Win32
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Release|ARM.ActiveCfg = Release|ARM
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Release|ARM.Build.0 = Release|ARM
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Release|ARM.Deploy.0 = Release|ARM
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Release|ARM64.ActiveCfg = Release|ARM64
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Release|ARM64.Build.0 = Release|ARM64
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Release|ARM64.Deploy.0 = Release|ARM64
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Release|x64.ActiveCfg = Release|x64
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Release|x64.Build.0 = Release|x64
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Release|x64.Deploy.0 = Release|x64
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Release|x86.ActiveCfg = Release|Win32
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Release|x86.Build.0 = Release|Win32
		{11ADF42E-392F-4AA8-86B6-484120E7A540}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F1E0558A-0FD8-4345-AB49-0A7D8364779D}
	EndGlobalSection
EndGlobal

```

`dxgkrnl_hook/Device.h`:

```h
/*++

Module Name:

    device.h

Abstract:

    This file contains the device definitions.

Environment:

    Kernel-mode Driver Framework

--*/

#include "public.h"

EXTERN_C_START

//
// The device context performs the same job as
// a WDM device extension in the driver frameworks
//
typedef struct _DEVICE_CONTEXT
{
    ULONG PrivateDeviceData;  // just a placeholder

} DEVICE_CONTEXT, *PDEVICE_CONTEXT;

//
// This macro will generate an inline function called DeviceGetContext
// which will be used to get a pointer to the device context memory
// in a type safe manner.
//
WDF_DECLARE_CONTEXT_TYPE_WITH_NAME(DEVICE_CONTEXT, DeviceGetContext)

//
// Function to initialize the device and its callbacks
//
NTSTATUS
dxgkrnlhookCreateDevice(
    _Inout_ PWDFDEVICE_INIT DeviceInit
    );

EXTERN_C_END

```

`dxgkrnl_hook/Driver.h`:

```h
/*++

Module Name:

    driver.h

Abstract:

    This file contains the driver definitions.

Environment:

    Kernel-mode Driver Framework

--*/

#include <ntddk.h>
#include <wdf.h>
#include <initguid.h>

#include "device.h"
#include "queue.h"
#include "trace.h"

EXTERN_C_START

//
// WDFDRIVER Events
//

DRIVER_INITIALIZE DriverEntry;
EVT_WDF_DRIVER_DEVICE_ADD dxgkrnlhookEvtDeviceAdd;
EVT_WDF_OBJECT_CONTEXT_CLEANUP dxgkrnlhookEvtDriverContextCleanup;

EXTERN_C_END

```

`dxgkrnl_hook/Public.h`:

```h
/*++

Module Name:

    public.h

Abstract:

    This module contains the common declarations shared by driver
    and user applications.

Environment:

    user and kernel

--*/

//
// Define an Interface Guid so that apps can find the device and talk to it.
//

DEFINE_GUID (GUID_DEVINTERFACE_dxgkrnlhook,
    0x517caa08,0xa850,0x475a,0x9f,0xa6,0x69,0xf5,0x03,0x20,0x72,0x27);
// {517caa08-a850-475a-9fa6-69f503207227}

```

`dxgkrnl_hook/Queue.h`:

```h
/*++

Module Name:

    queue.h

Abstract:

    This file contains the queue definitions.

Environment:

    Kernel-mode Driver Framework

--*/

EXTERN_C_START

//
// This is the context that can be placed per queue
// and would contain per queue information.
//
typedef struct _QUEUE_CONTEXT {

    ULONG PrivateDeviceData;  // just a placeholder

} QUEUE_CONTEXT, *PQUEUE_CONTEXT;

WDF_DECLARE_CONTEXT_TYPE_WITH_NAME(QUEUE_CONTEXT, QueueGetContext)

NTSTATUS
dxgkrnlhookQueueInitialize(
    _In_ WDFDEVICE Device
    );

//
// Events from the IoQueue object
//
EVT_WDF_IO_QUEUE_IO_DEVICE_CONTROL dxgkrnlhookEvtIoDeviceControl;
EVT_WDF_IO_QUEUE_IO_STOP dxgkrnlhookEvtIoStop;

EXTERN_C_END

```

`dxgkrnl_hook/Trace.h`:

```h
/*++

Module Name:

    Trace.h

Abstract:

    Header file for the debug tracing related function defintions and macros.

Environment:

    Kernel mode

--*/

//
// Define the tracing flags.
//
// Tracing GUID - b7f375fa-435f-4345-82c9-6945e2268c1c
//

#define WPP_CONTROL_GUIDS                                              \
    WPP_DEFINE_CONTROL_GUID(                                           \
        dxgkrnlhookTraceGuid, (b7f375fa,435f,4345,82c9,6945e2268c1c), \
                                                                            \
        WPP_DEFINE_BIT(MYDRIVER_ALL_INFO)                              \
        WPP_DEFINE_BIT(TRACE_DRIVER)                                   \
        WPP_DEFINE_BIT(TRACE_DEVICE)                                   \
        WPP_DEFINE_BIT(TRACE_QUEUE)                                    \
        )                             

#define WPP_FLAG_LEVEL_LOGGER(flag, level)                                  \
    WPP_LEVEL_LOGGER(flag)

#define WPP_FLAG_LEVEL_ENABLED(flag, level)                                 \
    (WPP_LEVEL_ENABLED(flag) &&                                             \
     WPP_CONTROL(WPP_BIT_ ## flag).Level >= level)

#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags) \
           WPP_LEVEL_LOGGER(flags)
               
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) \
           (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_ ## flags).Level >= lvl)

//           
// WPP orders static parameters before dynamic parameters. To support the Trace function
// defined below which sets FLAGS=MYDRIVER_ALL_INFO, a custom macro must be defined to
// reorder the arguments to what the .tpl configuration file expects.
//
#define WPP_RECORDER_FLAGS_LEVEL_ARGS(flags, lvl) WPP_RECORDER_LEVEL_FLAGS_ARGS(lvl, flags)
#define WPP_RECORDER_FLAGS_LEVEL_FILTER(flags, lvl) WPP_RECORDER_LEVEL_FLAGS_FILTER(lvl, flags)

//
// This comment block is scanned by the trace preprocessor to define our
// Trace function.
//
// begin_wpp config
// FUNC Trace{FLAGS=MYDRIVER_ALL_INFO}(LEVEL, MSG, ...);
// FUNC TraceEvents(LEVEL, FLAGS, MSG, ...);
// end_wpp
//

```

`dxgkrnl_hook/dxgkrnl_hook.cpp`:

```cpp
#include "dxgkrnl_hook.hpp"

bool dxgkrnl_hook::is_hooked = false;

dxgkrnl_hook::dxgk_submit_command_t dxgkrnl_hook::original_submit_command = nullptr;
dxgkrnl_hook::dxgk_submit_command_t* dxgkrnl_hook::original_entry = nullptr;

bool dxgkrnl_hook::hook_submit_command()
{
	// SAVE ORIGINAL ENTRY
	dxgkrnl_hook::original_entry = dxgkrnl_hook::find_submit_command_entry();

	if (dxgkrnl_hook::original_entry == nullptr)
	{
		DbgPrint("Failed to find NtGdiDdDDISubmitCommand\n");
		return false;
	}

	// SAVE ORIGINAL FUNCTION POINTER
	dxgkrnl_hook::original_submit_command = *dxgkrnl_hook::original_entry;

	if (dxgkrnl_hook::original_submit_command == nullptr)
	{
		DbgPrint("Failed to find DxgkSubmitCommand\n");
		return false;
	}

	// HOOK
	*dxgkrnl_hook::original_entry = dxgkrnl_hook::submit_command_hook;

	// SAVE STATE
	dxgkrnl_hook::is_hooked = true;

	DbgPrint("Hooked DxgkSubmitCommand!\n");

	return true;
}

bool dxgkrnl_hook::unhook_submit_command()
{
	if (!dxgkrnl_hook::is_hooked)
		return false;

	// UNHOOK
	*dxgkrnl_hook::original_entry = dxgkrnl_hook::original_submit_command;

	DbgPrint("Unhooked DxgkSubmitCommand!\n");

	return true;
}

dxgkrnl_hook::dxgk_submit_command_t* dxgkrnl_hook::find_submit_command_entry()
{
	uint8_t* submit_command_address = reinterpret_cast<uint8_t*>(NtGdiDdDDISubmitCommand);

	// FIND MOV INSTRUCTION
	auto instruction = submit_command_address;
	for (;
		instruction[0] != 0x48 ||
		instruction[1] != 0x8B ||
		instruction[2] != 0x05;
		instruction++)
	{
		//:)
	}

	// mov rax,QWORD PTR [rip+0x????????]
	// 48 8B 05 ?? ?? ?? ??
	auto delta = *reinterpret_cast<int32_t*>(instruction + 3);
	auto result = reinterpret_cast<dxgkrnl_hook::dxgk_submit_command_t*>(instruction + delta + 7);

	DbgPrint("DxgkSubmitCommand: %p\n", result);

	return result;
}

int64_t __fastcall dxgkrnl_hook::submit_command_hook(D3DKMT_SUBMITCOMMAND * data)
{
	const auto current_process = IoGetCurrentProcess();
	const auto process_name = PsGetProcessImageFileName(current_process);

	if (memeq(process_name, dxgkrnl_hook::target_name))
	{
		// GET CONTEXT
		const auto ctx = NtUserGetDc(0x00);

		// DRAW TO GAME WINDOW BUFFER
		NtGdiPatBlt(ctx, 15, 15, 5, 5, PATCOPY);
	}

	return dxgkrnl_hook::original_submit_command(data);
}

```

`dxgkrnl_hook/dxgkrnl_hook.hpp`:

```hpp
#pragma once

namespace dxgkrnl_hook
{
	extern bool is_hooked;

	constexpr auto target_name = "RainbowSix.exe";

	// HOOKERS
	bool hook_submit_command();
	bool unhook_submit_command();

	// HOOK INFO
	using dxgk_submit_command_t = int64_t(__fastcall*)(D3DKMT_SUBMITCOMMAND* data);
	extern dxgk_submit_command_t original_submit_command;
	extern dxgk_submit_command_t* original_entry;

	// NATIVE HELPERS
	dxgkrnl_hook::dxgk_submit_command_t* find_submit_command_entry();

	// HOOK HANDLER
	int64_t __fastcall submit_command_hook(D3DKMT_SUBMITCOMMAND* data);
}
```

`dxgkrnl_hook/dxgkrnl_hook.inf`:

```inf
;
; dxgkrnl_hook.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=dxgkrnl_hook.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
dxgkrnl_hook_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
dxgkrnl_hook.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%dxgkrnl_hook.DeviceDesc%=dxgkrnl_hook_Device, Root\dxgkrnl_hook ; TODO: edit hw-id

[dxgkrnl_hook_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
dxgkrnl_hook.sys

;-------------- Service installation
[dxgkrnl_hook_Device.NT.Services]
AddService = dxgkrnl_hook,%SPSVCINST_ASSOCSERVICE%, dxgkrnl_hook_Service_Inst

; -------------- dxgkrnl_hook driver install sections
[dxgkrnl_hook_Service_Inst]
DisplayName    = %dxgkrnl_hook.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\dxgkrnl_hook.sys

;
;--- dxgkrnl_hook_Device Coinstaller installation ------
;

[dxgkrnl_hook_Device.NT.CoInstallers]
AddReg=dxgkrnl_hook_Device_CoInstaller_AddReg
CopyFiles=dxgkrnl_hook_Device_CoInstaller_CopyFiles

[dxgkrnl_hook_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[dxgkrnl_hook_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[dxgkrnl_hook_Device.NT.Wdf]
KmdfService =  dxgkrnl_hook, dxgkrnl_hook_wdfsect
[dxgkrnl_hook_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "dxgkrnl_hook Installation Disk"
dxgkrnl_hook.DeviceDesc = "dxgkrnl_hook Device"
dxgkrnl_hook.SVCDESC = "dxgkrnl_hook Service"

```

`dxgkrnl_hook/dxgkrnl_hook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dxgkrnl_hook.cpp" />
    <ClCompile Include="entry.cpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{11ADF42E-392F-4AA8-86B6-484120E7A540}</ProjectGuid>
    <TemplateGuid>{497e31cb-056b-4f31-abb8-447fd55ee5a5}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>dxgkrnl_hook</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <LinkTimeCodeGeneration>UseFastLinkTimeCodeGeneration</LinkTimeCodeGeneration>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="dxgkrnl_hook.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`dxgkrnl_hook/dxgkrnl_hook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="entry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dxgkrnl_hook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="dxgkrnl_hook.hpp">
      <Filter>Resource Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`dxgkrnl_hook/entry.cpp`:

```cpp
#include <stdint.h>
#include "dxgkrnl_hook.hpp"

extern "C" int64_t DriverEntry(void* ctx)
{
	dxgkrnl_hook::hook_submit_command();

	return 1;
}
```