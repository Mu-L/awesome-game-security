Project Path: arc_DownWithUp_CallMon_6v9ctrlz

Source Tree:

```txt
arc_DownWithUp_CallMon_6v9ctrlz
├── Driver
│   ├── AltCall.c
│   └── Extras.h
├── GUI
│   ├── CallMon.c
│   ├── Resource.rc
│   ├── Utils.h
│   └── resource.h
├── README.md
└── Rust
    ├── Cargo.toml
    ├── Makefile.toml
    ├── build.rs
    ├── rustfmt.toml
    └── src
        ├── defines.rs
        ├── externs.rs
        ├── lib.rs
        ├── log.rs
        └── string.rs

```

`Driver/AltCall.c`:

```c
#include <ntifs.h>
#include <windef.h>
#include <intrin.h>
#include "Extras.h"

#pragma warning(disable : 4201)

#define ProcessAltSystemCallInformation 0x64
#define RTL_WALK_USER_MODE_STACK        0x00000001
#define IOCTL_ADD_PROCESS               0x550000
#define IOCTL_REMOVE_PROCESS            0x550002
#define IOCTL_INIT                      0x550004

typedef DWORD64 QWORD;
typedef UINT16  WORD;
typedef UCHAR   BYTE;
typedef NTSTATUS(NTAPI* PsRegisterAltSystemCallHandler)(PVOID HandlerFunction, LONG HandlerIndex);
typedef NTSTATUS(NTAPI* ZwSetInformationProcess)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation,
    ULONG ProcessInformationLength);
typedef NTSTATUS(NTAPI* PsSuspendProcess)(PEPROCESS Process);
typedef NTSTATUS(NTAPI* PsResumeProcess)(PEPROCESS Process);


// Globals
PsRegisterAltSystemCallHandler  pPsRegisterAltSystemCallHandler;
ZwSetInformationProcess         pZwSetInformationProcess;
PsSuspendProcess                pPsSuspendProcess;
PsResumeProcess                 pPsResumeProcess;
HANDLE                          hGlobalPipe = 0;

NTSTATUS DriverUnload(PDRIVER_OBJECT DriverObject)
{
    UNREFERENCED_PARAMETER(DriverObject);

    return(STATUS_ACCESS_DENIED);
}

BOOLEAN MyHandler(PKTRAP_FRAME Frame)
{
    IO_STATUS_BLOCK ioBlock;
    TOTAL_PACKET    totalPacket;
    NTSTATUS        ntRet;

    if (hGlobalPipe)
    {
        totalPacket.CustomHeader.ProcessId = (ULONG64)PsGetProcessId(PsGetCurrentProcess());
        if (((QWORD)Frame->Rsp < (QWORD)MmHighestUserAddress) && (MmIsAddressValid((PVOID)Frame->Rsp)))
        {
            memmove(&totalPacket.CustomHeader.StackData, (PVOID)Frame->Rsp, sizeof(totalPacket.CustomHeader.StackData));
        }
        memmove(&totalPacket.Frame, Frame, sizeof(KTRAP_FRAME));
        ntRet = ZwWriteFile(hGlobalPipe, 0, NULL, NULL, &ioBlock, &totalPacket, sizeof(totalPacket), NULL, NULL);
    }
    return(TRUE);
}

NTSTATUS AddProcess(DWORD PID)
{
    OBJECT_ATTRIBUTES   objAttr;
    CLIENT_ID           clientId;
    HANDLE              hProcess;
    QWORD               qwPID;


    InitializeObjectAttributes(&objAttr, NULL, OBJ_KERNEL_HANDLE, 0, 0);
    clientId.UniqueProcess = (HANDLE)PID;
    clientId.UniqueThread = 0;
    hProcess = 0;
    if (NT_SUCCESS(ZwOpenProcess(&hProcess, PROCESS_ALL_ACCESS, &objAttr, &clientId)))
    {
        qwPID = (QWORD)clientId.UniqueProcess;
        if (NT_SUCCESS(pZwSetInformationProcess(hProcess, (PROCESSINFOCLASS)ProcessAltSystemCallInformation, &qwPID, 1)))
        {
            ZwClose(hProcess);
            return(STATUS_SUCCESS);
        }
    }
    return(STATUS_UNSUCCESSFUL);
}

// ETHREAD is version dependent
typedef struct _ETHREAD
{
    BYTE Random[0x4E8];
    LIST_ENTRY ThreadListEntry;
}ETHREAD;

NTSTATUS RemoveProcess(DWORD PID)
{
    OBJECT_ATTRIBUTES   objAttr;
    PLIST_ENTRY         pThreadHead;
    PLIST_ENTRY         pThreadNext;
    PEPROCESS           pProcess;
    CLIENT_ID           clientId;
    PETHREAD            pThread;
    NTSTATUS            ntRet;
    HANDLE              hProcess;
    QWORD               qwPID;


    InitializeObjectAttributes(&objAttr, NULL, OBJ_KERNEL_HANDLE, 0, 0);
    clientId.UniqueProcess = (HANDLE)PID;
    clientId.UniqueThread = 0;
    hProcess = 0;
    ntRet = STATUS_UNSUCCESSFUL;
    if (NT_SUCCESS(ZwOpenProcess(&hProcess, PROCESS_ALL_ACCESS, &objAttr, &clientId)))
    {
        qwPID = (QWORD)clientId.UniqueProcess;
        
        if (NT_SUCCESS(ObReferenceObjectByHandleWithTag(hProcess, PROCESS_ALL_ACCESS, *PsProcessType, KernelMode, 0x75537350, &pProcess, NULL)))
        {
            ntRet = pPsSuspendProcess(pProcess);
            if (NT_SUCCESS(ntRet))
            {
                /*
                    Because Microsoft doesn't document the structure of EPROCESS or KTHREAD 
                    members and offsets here could change in a new release.
                    See: https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/eprocess
                */
                pThreadHead = (PLIST_ENTRY)((BYTE*)pProcess + 0x5E0); //EPROCESS.ThreadListHead
                pThreadNext = pThreadHead->Flink;

                while (pThreadNext != pThreadHead)
                {
                    pThread = (PETHREAD)((BYTE*)pThreadNext - 0x4E8);
                    _interlockedbittestandreset((PLONG)pThread, 0x1D);
                    pThreadNext = pThreadNext->Flink;
                }
               
                ntRet = pPsResumeProcess(pProcess);
            }
            ObDereferenceObjectWithTag(pProcess, 0x75537350);
        }
        ZwClose(hProcess);
    }
    return(ntRet);
}

NTSTATUS DeviceDispatch(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    PIO_STACK_LOCATION  pStack;
    OBJECT_ATTRIBUTES   objPipe;
    IO_STATUS_BLOCK     ioBlock;
    UNICODE_STRING      usPipe;
    NTSTATUS            ntRet;
    UNREFERENCED_PARAMETER(DeviceObject);

    pStack = IoGetCurrentIrpStackLocation(Irp);
    ntRet = STATUS_SUCCESS;
    if (pStack->MajorFunction == IRP_MJ_DEVICE_CONTROL)
    {
        switch (pStack->Parameters.DeviceIoControl.IoControlCode)
        {
        case IOCTL_ADD_PROCESS:
            if (pStack->Parameters.DeviceIoControl.InputBufferLength == 4)
            {
                ntRet = AddProcess(*(DWORD*)Irp->AssociatedIrp.SystemBuffer);
            }
            else
            {
                ntRet = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        case IOCTL_REMOVE_PROCESS:
            if (pStack->Parameters.DeviceIoControl.InputBufferLength == 4)
            {
                ntRet = RemoveProcess(*(DWORD*)Irp->AssociatedIrp.SystemBuffer);
            }
            else
            {
                ntRet = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        case IOCTL_INIT:
            if (hGlobalPipe)
            {
                ZwClose(hGlobalPipe);
                hGlobalPipe = 0;
            }
            if (!hGlobalPipe)
            {
                RtlInitUnicodeString(&usPipe, L"\\Device\\NamedPipe\\CallMonPipe");
                InitializeObjectAttributes(&objPipe, &usPipe, OBJ_KERNEL_HANDLE, 0, 0);
                if (NT_SUCCESS(ZwCreateFile(&hGlobalPipe, FILE_WRITE_DATA | SYNCHRONIZE, &objPipe, &ioBlock, NULL, 0, 0, FILE_OPEN, 
                                            FILE_SYNCHRONOUS_IO_NONALERT | FILE_DELETE_ON_CLOSE, NULL, 0)))
                {
                    ntRet = STATUS_SUCCESS;
                }
                else
                {
                    ntRet = STATUS_PIPE_BROKEN;
                }
            }
            break;
        default:
            break;
        }

    }
    Irp->IoStatus.Status = ntRet;
    IofCompleteRequest(Irp, IO_NO_INCREMENT);
    return(ntRet);
}

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
    UNICODE_STRING  usRoutine;
    UNICODE_STRING  usDevice;  
    UNICODE_STRING  usSymLink;
    PDEVICE_OBJECT  pDeviceObj;

    UNREFERENCED_PARAMETER(RegistryPath);

    RtlInitUnicodeString(&usRoutine, L"PsRegisterAltSystemCallHandler");
    pPsRegisterAltSystemCallHandler = (PsRegisterAltSystemCallHandler)MmGetSystemRoutineAddress(&usRoutine);
    RtlInitUnicodeString(&usRoutine, L"ZwSetInformationProcess");
    pZwSetInformationProcess = (ZwSetInformationProcess)MmGetSystemRoutineAddress(&usRoutine);
    RtlInitUnicodeString(&usRoutine, L"PsSuspendProcess");
    pPsSuspendProcess = (PsSuspendProcess)MmGetSystemRoutineAddress(&usRoutine);
    RtlInitUnicodeString(&usRoutine, L"PsResumeProcess");
    pPsResumeProcess = (PsResumeProcess)MmGetSystemRoutineAddress(&usRoutine);

    if ((pPsRegisterAltSystemCallHandler) && (pZwSetInformationProcess) && (pPsSuspendProcess) && (pPsResumeProcess))
    {
        DriverObject->DriverUnload = DriverUnload;
        for (int i = 0;  i < IRP_MJ_MAXIMUM_FUNCTION; i++)
        {
            DriverObject->MajorFunction[i] = DeviceDispatch;
        }
        RtlInitUnicodeString(&usDevice, L"\\Device\\CallMon");
        if (NT_SUCCESS(IoCreateDevice(DriverObject, 0, &usDevice, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &pDeviceObj)))
        {
            RtlInitUnicodeString(&usSymLink, L"\\DosDevices\\CallMon");
            if (NT_SUCCESS(IoCreateSymbolicLink(&usSymLink, &usDevice)))
            {
                pDeviceObj->Flags |= DO_BUFFERED_IO;
                pPsRegisterAltSystemCallHandler((PVOID)MyHandler, 1);
                return(STATUS_SUCCESS);
            }
        }
    }
    return(STATUS_UNSUCCESSFUL);
}

```

`Driver/Extras.h`:

```h
#pragma once

typedef struct _CUSTOM_HEADER
{
    ULONG64 ProcessId;
    ULONG64 StackData[0x10];
} CUSTOM_HEADER, * PCUSTOM_HEADER;

typedef struct _TOTAL_PACKET
{
    CUSTOM_HEADER CustomHeader;
    KTRAP_FRAME Frame;
} TOTAL_PACKET, * PTOTAL_PACKET;

```

`GUI/CallMon.c`:

```c
#include <Windows.h>
#include <stdio.h>
#include <shlwapi.h>
#include <winres.h>
#include <Uxtheme.h>
#include "Utils.h"
#include "resource.h" // This includes everything from the resource view (forms, elements, configs...)

#pragma comment(linker,"\"/manifestdependency:type='win32' \
                            name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
                            processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#pragma comment(linker, "/ENTRY:WinMain")
#pragma comment(linker, "/SUBSYSTEM:WINDOWS")
#pragma comment(lib, "UxTheme.lib")
#pragma comment(lib, "Shlwapi.lib")

VOID GUIInit(HWND hwnd)
{
    SetThemeAppProperties(STAP_ALLOW_NONCLIENT | STAP_ALLOW_CONTROLS);
    SetWindowTheme(hwnd, L"Explorer", NULL);
    ListView_SetExtendedListViewStyle(GetDlgItem(hwnd, IDC_LIST_MAIN), LVS_EX_GRIDLINES | LVS_EX_FULLROWSELECT | LVS_EX_ONECLICKACTIVATE);
    CListView_InsertColumn(GetDlgItem(hwnd, IDC_LIST_MAIN), 0, 0, 0, L"PID", 64);
    CListView_InsertColumn(GetDlgItem(hwnd, IDC_LIST_MAIN), 1, 1, 1, L"Syscall Number", 100);
    CListView_InsertColumn(GetDlgItem(hwnd, IDC_LIST_MAIN), 2, 2, 2, L"Arg #1", 170);
    CListView_InsertColumn(GetDlgItem(hwnd, IDC_LIST_MAIN), 3, 3, 3, L"Arg #2", 170);
    CListView_InsertColumn(GetDlgItem(hwnd, IDC_LIST_MAIN), 4, 4, 4, L"Arg #3", 170);
    CListView_InsertColumn(GetDlgItem(hwnd, IDC_LIST_MAIN), 5, 5, 5, L"Arg #4", 170);
    SetDlgItemTextA(hwnd, IDC_MEMO_STACK, "(Nothing selected)");
}

BOOL WINAPI EventHandler(HWND hwnd, UINT Msg, WPARAM wParam, LPARAM lParam) {
    LPNMITEMACTIVATE    pActivatedItem;
    PSTACK_CHUNK        pStackChunk;
    LPNMHDR             pNm;
    DWORD               dwIndex;
    PVOID               pData;
    HWND                hList;
    HWND                hBox;
    HWND                hMemo;
    RECT                rWindow;
    RECT                rList;
    RECT                rBox;
    RECT                rMemo;
    INT                 nWidth; 
    INT                 nHeight;

    switch (Msg) 
    {
    case WM_NOTIFY:
        pNm = (LPNMHDR)lParam;
        if (pNm->code == LVN_ITEMACTIVATE)
        {
            pActivatedItem = (LPNMITEMACTIVATE)lParam;
            if (pGlobalStackMem)
            {
                dwIndex = pActivatedItem->iItem;
                pStackChunk = (PSTACK_CHUNK)((BYTE*)pGlobalStackMem + (dwIndex * sizeof(STACK_CHUNK)));
                pData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x1000);
                if (pData)
                {
                    wnsprintfW(pData, 0x1000, L"0x%I64X\r\n0x%I64X\r\n0x%I64X\r\n0x%I64X\r\n0x%I64X\r\n0x%I64X\r\n0x%I64X\r\n0x%I64X\r\n"
                                            L"0x%I64X\r\n0x%I64X\r\n0x%I64X\r\n0x%I64X\r\n0x%I64X\r\n0x%I64X\r\n0x%I64X\r\n0x%I64X\r\n",
                                            pStackChunk->StackData[0], pStackChunk->StackData[1], pStackChunk->StackData[2],
                                            pStackChunk->StackData[3], pStackChunk->StackData[4], pStackChunk->StackData[5],
                                            pStackChunk->StackData[6], pStackChunk->StackData[7], pStackChunk->StackData[8],
                                            pStackChunk->StackData[9], pStackChunk->StackData[10], pStackChunk->StackData[11],
                                            pStackChunk->StackData[12], pStackChunk->StackData[13], pStackChunk->StackData[14],
                                            pStackChunk->StackData[15]);
                    SetDlgItemText(hwnd, IDC_MEMO_STACK, pData);
                    HeapFree(GetProcessHeap(), 0, pData);
                }
            }
            break;
        }  
        return(FALSE);
    case WM_INITDIALOG:
        GUIInit(hwnd);
        return(FALSE);
    case WM_CLOSE:
        DestroyWindow(hwnd);
        PostQuitMessage(0);
        return(FALSE);
    case WM_SIZING:
        rWindow = *((RECT*)lParam);
        if (rWindow.right - rWindow.left <= MIN_WIDTH)
            ((RECT*)lParam)->right = rWindow.left + MIN_WIDTH;

        if (rWindow.bottom - rWindow.top <= MIN_HEIGHT)
            ((RECT*)lParam)->bottom = rWindow.top + MIN_HEIGHT;
        return(FALSE);

    case WM_SYSCOMMAND:
        if (wParam != SC_MAXIMIZE)
        {
            break;
        }
    case WM_SIZE:
        nWidth = (INT)LOWORD(lParam);
        nHeight = (INT)HIWORD(lParam);
        GetClientRect(hwnd, &rWindow);
        if (!bGlobalSizes)
        {
            bGlobalSizes = TRUE;
            RtlSecureZeroMemory(&rList, sizeof(rList));
            GetWindowRect(GetDlgItem(hwnd, IDC_LIST_MAIN), &rList);
            RtlSecureZeroMemory(&rBox, sizeof(rBox));
            GetWindowRect(GetDlgItem(hwnd, IDC_STATIC_BOX), &rBox);
            RtlSecureZeroMemory(&rMemo, sizeof(rMemo));
            GetWindowRect(GetDlgItem(hwnd, IDC_MEMO_STACK), &rMemo);
            dx1 = rWindow.right - (rList.right - rList.left);
            dx2 = rList.bottom - rList.top;
            dx3 = rWindow.right - (rBox.right - rBox.left);
            dx4 = rBox.bottom - rBox.top;
            dx5 = rMemo.right - rMemo.left;
        }
        hList = GetDlgItem(hwnd, IDC_LIST_MAIN);
        if (hList) 
        {
            SetWindowPos(hList, 0, 0, 0, rWindow.right - dx1, nHeight - 99, SWP_NOMOVE | SWP_NOZORDER);
        }
        hBox = GetDlgItem(hwnd, IDC_STATIC_BOX);
        if (hBox)
        {
            SetWindowPos(hBox, 0, 0, 0, rWindow.right - dx3, dx4, SWP_NOMOVE | SWP_NOZORDER);
        }
        hMemo = GetDlgItem(hwnd, IDC_MEMO_STACK);
        if (hMemo)
        {
            SetWindowPos(hMemo, 0, 0, 0, dx5, nHeight - 115, SWP_NOMOVE | SWP_NOZORDER);
        }
        return(FALSE);
    case WM_COMMAND:
        return (CommandHandler(hwnd, wParam, lParam));
    }
    return FALSE;
}

void ShowDialog(HWND Parent) {
    WNDCLASSA   wClass;
    HWND        hDialog;
    MSG         msg;

    RtlSecureZeroMemory(&wClass, sizeof(wClass));
    RtlSecureZeroMemory(&msg, sizeof(msg));
    wClass.lpszClassName = "CallMon_MainForm";
    RegisterClassA(&wClass);
    hDialog = CreateDialogA(GetModuleHandleA(NULL), MAKEINTRESOURCEA(IDD_DIALOG1), Parent, &EventHandler); 
    ShowWindow(hDialog, SWP_NOSIZE | SW_SHOWNORMAL);
    while (GetMessageA(&msg, NULL, 0, 0)) 
    {
        TranslateMessage(&msg);
        DispatchMessageA(&msg);
    }
    return;
}

DWORD ListenProc(LPVOID lpvParam)
{
    PTOTAL_PACKET   pTotalPacket;
    PSTACK_CHUNK    pStackChunk;
    LPVOID          lpBuff;
    DWORD           dwBytesRead;
    DWORD           dwCount;
    HWND            hwMainWindow;
    HWND            hwList;

    hwMainWindow = FindWindowA("CallMon_MainForm", NULL);
    lpBuff = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(TOTAL_PACKET));
    dwCount = 0;
    ConnectNamedPipe((HANDLE)lpvParam, NULL);
    while (TRUE)
    {
        ReadFile((HANDLE)lpvParam, lpBuff, sizeof(TOTAL_PACKET), &dwBytesRead, NULL);
        if (hGlobalHWND)
        {
            pTotalPacket = (PTOTAL_PACKET)lpBuff;

            hwList = GetDlgItem(hGlobalHWND, IDC_LIST_MAIN);
            LV_ITEM lvItem = { 0 };

            lvItem.iItem = dwCount;
            ListView_InsertItem(hwList, &lvItem);

            PVOID pData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x100);
            wnsprintfW(pData, 0x100, L"%d", pTotalPacket->CustomHeader.ProcessId);
            ListView_SetItemText(hwList, dwCount, 0, pData);
            HeapFree(GetProcessHeap(), 0, pData);

            pData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x100);
            wnsprintfW(pData, 0x100, L"RAX: %I64X", pTotalPacket->Frame.Rax);
            ListView_SetItemText(hwList, dwCount, 1, pData);
            HeapFree(GetProcessHeap(), 0, pData);

            pData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x100);
            wnsprintfW(pData, 0x100, L"RCX: %I64X", pTotalPacket->Frame.Rcx);
            ListView_SetItemText(hwList, dwCount, 2, pData);
            HeapFree(GetProcessHeap(), 0, pData);
        
            pData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x100);
            wnsprintfW(pData, 0x100, L"RDX: %I64X", pTotalPacket->Frame.Rdx);
            ListView_SetItemText(hwList, dwCount, 3, pData);
            HeapFree(GetProcessHeap(), 0, pData);

            pData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x100);
            wnsprintfW(pData, 0x100, L"R8: %I64X", pTotalPacket->Frame.R8);
            ListView_SetItemText(hwList, dwCount, 4, pData);
            HeapFree(GetProcessHeap(), 0, pData);

            pData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x100);
            wnsprintfW(pData, 0x100, L"R9: %I64X", pTotalPacket->Frame.R9);
            ListView_SetItemText(hwList, dwCount, 5, pData);
            HeapFree(GetProcessHeap(), 0, pData);

            pStackChunk = (PSTACK_CHUNK)((BYTE*)pGlobalStackMem + (dwCount * sizeof(STACK_CHUNK)));
            pStackChunk->Row = dwCount;
            memcpy(pStackChunk->StackData, pTotalPacket->CustomHeader.StackData, sizeof(pTotalPacket->CustomHeader.StackData));
            dwCount++;
        }
    }
}

BOOL CommandHandler(HWND hwnd, WPARAM wParam, LPARAM lParam) {
    IsNTAdmin   pIsNTAdmin;
    HANDLE      hDriver;
    WCHAR       wzName[MAX_PATH];
    BOOL        bTranslated;
    INT         nPID;

    switch (LOWORD(wParam)) 
    {
    case IDC_BTN_INIT:
        hGlobalHWND = hwnd;
        pIsNTAdmin = *(IsNTAdmin)GetProcAddress(LoadLibraryA("advpack.dll"), "IsNTAdmin");
        if (pIsNTAdmin)
        {
            if (!pIsNTAdmin(0, NULL))
            {
                GetModuleFileNameW(0, (LPWSTR)&wzName, MAX_PATH * 2);
                if (MessageBoxA(hwnd, "You must be running as an administrator. Restart now?", "Warning", MB_ICONWARNING | MB_YESNO) == IDYES)
                {
                    ShellExecute(hwnd, L"runas", wzName, NULL, NULL, SW_SHOW);
                    ExitProcess(0);
                }
                else
                {
                    return(FALSE);
                }
            }
            else
            {
                hDriver = CreateFileA("AltCall.sys", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);
                if (hDriver != INVALID_HANDLE_VALUE)
                {
                    if ((!GetDriverPrivilege()) || (!LoadDriver(hDriver)))
                    {
                        MessageBoxA(hwnd, "Unable to load driver! Ensure it is in the same directory as "
                            "this program and DSE is disabled.", "Error", MB_ICONERROR);
                        CloseHandle(hDriver);
                        return(FALSE);
                       
                    }
                    CloseHandle(hDriver);
                }
                if (!pGlobalStackMem)
                {
                    pGlobalStackMem = VirtualAlloc(0, GLOBAL_STACK_MEM_SIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
                    if (!pGlobalStackMem)
                    {
                        MessageBoxA(hwnd, "Unable to allocate memory for stack capture!", "Fatal Error", MB_ICONERROR);
                        ExitProcess(-1);
                    }
                }
                ObtainDevice();
                CreatePipe();
                if ((hGlobalPipe != INVALID_HANDLE_VALUE) && (hGlobalDriver != INVALID_HANDLE_VALUE))
                {
                    hGlobalListenThread = CreateThread(NULL, 0, &ListenProc, hGlobalPipe, 0, NULL);
                    DeviceIoControl(hGlobalDriver, IOCTL_INIT, NULL, 0, NULL, 0, NULL, NULL);
                }
            }
        }
        return(FALSE);
    case IDC_BTN_ADD:
        nPID = GetDlgItemInt(hwnd, IDC_EDIT_ADD, &bTranslated, FALSE);
        if (bTranslated)
        {
            if (hGlobalDriver != INVALID_HANDLE_VALUE)
            {
                DeviceIoControl(hGlobalDriver, IOCTL_ADD_PROCESS, &nPID, sizeof(nPID), &nPID, sizeof(nPID), NULL, NULL);
                return(FALSE);
            }
        }
        else
        {
            MessageBoxA(hwnd, "Value must be a valid number!", "Error", MB_ICONERROR);
        }
        return(FALSE);
    case IDC_BTN_REMOVE:
        nPID = GetDlgItemInt(hwnd, IDC_EDIT_ADD, &bTranslated, FALSE);
        if (bTranslated)
        {
            if (hGlobalDriver != INVALID_HANDLE_VALUE)
            {
                DeviceIoControl(hGlobalDriver, IOCTL_REMOVE_PROCESS, &nPID, sizeof(nPID), &nPID, sizeof(nPID), NULL, NULL);
                return(FALSE);
            }
        }
        else
        {
            MessageBoxA(hwnd, "Value must be a valid number!", "Error", MB_ICONERROR);
        }
        return(FALSE);
    case IDC_BUTTON_CLEAR:
        if (MessageBoxA(hwnd, "Are you sure you want to clear all entries?", "Confirmation", MB_ICONWARNING | MB_YESNO) == IDYES)
        {
            if (pGlobalStackMem)
            {
                if (hGlobalListenThread != INVALID_HANDLE_VALUE)
                {
                    TerminateThread(hGlobalListenThread, 0);
                    ListView_DeleteAllItems(GetDlgItem(hwnd, IDC_LIST_MAIN));
                    RtlSecureZeroMemory(pGlobalStackMem, GLOBAL_STACK_MEM_SIZE);
                    hGlobalListenThread = CreateThread(NULL, 0, &ListenProc, hGlobalPipe, 0, NULL);
                }
            }
        }
        return(FALSE);
    default:
        return(FALSE);
    }
}

INT CALLBACK WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    ShowDialog(0);
    ExitProcess(0);
    return(0);
}

```

`GUI/Resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"
/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_DIALOG1 DIALOGEX 0, 0, 450, 200
STYLE DS_SETFONT | DS_FIXEDSYS | DS_CENTER | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
CAPTION "CallMon"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    GROUPBOX        "Configuration",IDC_STATIC_BOX,7,7,436,45
    PUSHBUTTON      "Initialize",IDC_BTN_INIT,15,26,50,14
    EDITTEXT        IDC_EDIT_ADD,122,26,40,14,ES_AUTOHSCROLL
    CONTROL         "",IDC_LIST_MAIN,"SysListView32",LVS_REPORT | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,117,54,326,139
    PUSHBUTTON      "Add Process",IDC_BTN_ADD,69,26,50,14
    PUSHBUTTON      "Remove Process",IDC_BTN_REMOVE,165,26,76,14
    EDITTEXT        IDC_MEMO_STACK,7,64,106,129,ES_MULTILINE | ES_AUTOHSCROLL | ES_READONLY
    LTEXT           "Stack Capture (First 0x80):",IDC_STATIC_LABEL,7,54,90,8
    PUSHBUTTON      "Clear",IDC_BUTTON_CLEAR,243,26,50,14
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_DIALOG1, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 443
        TOPMARGIN, 7
        BOTTOMMARGIN, 193
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// AFX_DIALOG_LAYOUT
//

IDD_DIALOG1 AFX_DIALOG_LAYOUT
BEGIN
    0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    100, 100, 100, 100,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

```

`GUI/Utils.h`:

```h
#pragma once
#include <winternl.h>
#pragma comment(lib, "ntdll.lib")

#define GLOBAL_STACK_MEM_SIZE   0x400000
#define IOCTL_ADD_PROCESS       0x550000
#define IOCTL_REMOVE_PROCESS    0x550002
#define IOCTL_INIT              0x550004
#define MIN_HEIGHT              200              
#define MIN_WIDTH               475

// Globals
HANDLE  hGlobalDriver       = INVALID_HANDLE_VALUE;
HANDLE  hGlobalPipe         = INVALID_HANDLE_VALUE;
HANDLE  hGlobalListenThread = INVALID_HANDLE_VALUE;
PVOID   pGlobalStackMem     = NULL;
HWND    hGlobalHWND         = 0;
BOOL    bGlobalSizes        = FALSE;
LONG    dx1, dx2, dx3, dx4, dx5;

typedef BOOL(WINAPI* IsNTAdmin)(DWORD Reserved, LPVOID pReserved);
typedef NTSTATUS(NTAPI* NtLoadDriver)(PUNICODE_STRING DriverServiceName);

typedef struct _STACK_CHUNK
{
    ULONG64 Row;
    ULONG64 StackData[0x10];
} STACK_CHUNK, *PSTACK_CHUNK;

typedef struct _CUSTOM_HEADER
{
    ULONG64 ProcessId;
    ULONG64 StackData[0x10];
} CUSTOM_HEADER, *PCUSTOM_HEADER;

typedef CCHAR KPROCESSOR_MODE;
typedef UCHAR KIRQL;

typedef struct _KTRAP_FRAME {

    //
    // Home address for the parameter registers.
    //

    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 P5;

    //
    // Previous processor mode (system services only) and previous IRQL
    // (interrupts only).
    //

    KPROCESSOR_MODE PreviousMode;

    KIRQL PreviousIrql;

    //
    // Page fault load/store indicator.
    //

    UCHAR FaultIndicator;

    //
    // Exception active indicator.
    //
    //    0 - interrupt frame.
    //    1 - exception frame.
    //    2 - service frame.
    //

    UCHAR ExceptionActive;

    //
    // Floating point state.
    //

    ULONG MxCsr;

    //
    //  Volatile registers.
    //
    // N.B. These registers are only saved on exceptions and interrupts. They
    //      are not saved for system calls.
    //

    ULONG64 Rax;
    ULONG64 Rcx;
    ULONG64 Rdx;
    ULONG64 R8;
    ULONG64 R9;
    ULONG64 R10;
    ULONG64 R11;

    //
    // Gsbase is only used if the previous mode was kernel.
    //
    // GsSwap is only used if the previous mode was user.
    //

    union {
        ULONG64 GsBase;
        ULONG64 GsSwap;
    };

    //
    // Volatile floating registers.
    //
    // N.B. These registers are only saved on exceptions and interrupts. They
    //      are not saved for system calls.
    //

    M128A Xmm0;
    M128A Xmm1;
    M128A Xmm2;
    M128A Xmm3;
    M128A Xmm4;
    M128A Xmm5;

    //
    // First parameter, page fault address, context record address if user APC
    // bypass.
    //

    union {
        ULONG64 FaultAddress;
        ULONG64 ContextRecord;
    };

    //
    //  Debug registers.
    //

    ULONG64 Dr0;
    ULONG64 Dr1;
    ULONG64 Dr2;
    ULONG64 Dr3;
    ULONG64 Dr6;
    ULONG64 Dr7;

    //
    // Special debug registers.
    //

    struct {
        ULONG64 DebugControl;
        ULONG64 LastBranchToRip;
        ULONG64 LastBranchFromRip;
        ULONG64 LastExceptionToRip;
        ULONG64 LastExceptionFromRip;
    };

    //
    //  Segment registers
    //

    USHORT SegDs;
    USHORT SegEs;
    USHORT SegFs;
    USHORT SegGs;

    //
    // Previous trap frame address.
    //

    ULONG64 TrapFrame;

    //
    // Saved nonvolatile registers RBX, RDI and RSI. These registers are only
    // saved in system service trap frames.
    //

    ULONG64 Rbx;
    ULONG64 Rdi;
    ULONG64 Rsi;

    //
    // Saved nonvolatile register RBP. This register is used as a frame
    // pointer during trap processing and is saved in all trap frames.
    //

    ULONG64 Rbp;

    //
    // Information pushed by hardware.
    //
    // N.B. The error code is not always pushed by hardware. For those cases
    //      where it is not pushed by hardware a dummy error code is allocated
    //      on the stack.
    //

    union {
        ULONG64 ErrorCode;
        ULONG64 ExceptionFrame;
    };

    ULONG64 Rip;
    USHORT SegCs;
    UCHAR Fill0;
    UCHAR Logging;
    USHORT Fill1[2];
    ULONG EFlags;
    ULONG Fill2;
    ULONG64 Rsp;
    USHORT SegSs;
    USHORT Fill3;
    ULONG Fill4;
} KTRAP_FRAME, * PKTRAP_FRAME;

typedef struct _TOTAL_PACKET
{
    CUSTOM_HEADER CustomHeader;
    KTRAP_FRAME Frame;
} TOTAL_PACKET, * PTOTAL_PACKET;


/*
    Taken from https://github.com/hfiref0x/WinObjEx64 GUI's code
*/
INT CListView_InsertColumn(HWND ListViewHWND, INT ColumnIndex, INT SubItemIndex, INT OrderIndex, LPWSTR Text, INT Width)
{
    LVCOLUMN lvColumn;

    lvColumn.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH | LVCF_ORDER;
    lvColumn.cx = (Width);
    lvColumn.pszText = Text;
    lvColumn.iSubItem = SubItemIndex;
    lvColumn.iOrder = OrderIndex;

    return(ListView_InsertColumn(ListViewHWND, ColumnIndex, &lvColumn));
}

BOOL ObtainDevice()
{
    hGlobalDriver = CreateFileA("\\\\.\\CallMon", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
    if (hGlobalDriver != INVALID_HANDLE_VALUE)
    {
        return(TRUE);
    }
    return(FALSE);
}

BOOL CreatePipe()
{
    hGlobalPipe = CreateNamedPipeA("\\\\.\\pipe\\CallMonPipe", PIPE_ACCESS_INBOUND, PIPE_READMODE_BYTE | PIPE_WAIT, 1, 0x1000, 0x1000, INFINITE, NULL);
    if (hGlobalPipe != INVALID_HANDLE_VALUE)
    {
        return(TRUE);
    }
    return(FALSE);
}

BOOL AddProcess(WORD ProcessId)
{
    if (hGlobalDriver != INVALID_HANDLE_VALUE)
    {
        if (ProcessId)
        {
            if (DeviceIoControl(hGlobalDriver, IOCTL_ADD_PROCESS, &ProcessId, sizeof(ProcessId), NULL, 0, NULL, NULL))
            {
                return(TRUE);
            }
        }
    }
    return(FALSE);
}

BOOL GetDriverPrivilege()
{
    TOKEN_PRIVILEGES  tokenPrivs;
    HANDLE            hToken;
    LUID              luid;

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
    {
        if (LookupPrivilegeValueA(NULL, "SeLoadDriverPrivilege", &luid))
        {
            tokenPrivs.PrivilegeCount = 1;
            tokenPrivs.Privileges[0].Luid = luid;
            tokenPrivs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
            if (AdjustTokenPrivileges(hToken, FALSE, &tokenPrivs, sizeof(tokenPrivs), NULL, NULL))
            {
                CloseHandle(hToken);
                return(TRUE);
            }
        }
    }
    return(FALSE);
}

BOOL LoadDriver(HANDLE hDriver)
{
    UNICODE_STRING  usDriver;
    NtLoadDriver    pNtLoadDriver;
    NTSTATUS        ntRet;
    DWORD           dwData;
    WCHAR           wzDriver[MAX_PATH];
    HKEY            hKey;

    GetFinalPathNameByHandleW(hDriver, (LPWSTR)&wzDriver, MAX_PATH * sizeof(WCHAR), FILE_NAME_NORMALIZED | VOLUME_NAME_NT);
    RegCreateKeyA(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Services\\AltCall.sys", &hKey);
    RegSetValueExW(hKey, L"ImagePath", 0, REG_SZ, (LPWSTR)&wzDriver, lstrlenW((LPCWSTR)&wzDriver) * sizeof(WCHAR));
    dwData = 0x1;
    RegSetValueExA(hKey, "Type", 0, REG_DWORD, (BYTE*)&dwData, sizeof(dwData));
    RtlInitUnicodeString(&usDriver, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\AltCall.sys");
    if (pNtLoadDriver = (NtLoadDriver)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtLoadDriver"))
    {
        ntRet = pNtLoadDriver(&usDriver);
        if ((!ntRet) || (ntRet == 0xC000010E)) // STATUS_IMAGE_ALREADY_LOADED
        {
            return(TRUE);
        }
        else if (ntRet == 0xC0000428)
        {
            MessageBoxA(0, "You must disable driver signature enforcement (DSE) before using this program!\n"
                "This is possible by running windows in test mode.", "Error", MB_ICONERROR);
        }
    }
    return(FALSE);
}

```

`GUI/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Resource.rc
//
#define IDD_DIALOG1                     101
#define IDC_BTN_INIT                    1003
#define IDC_EDIT_ADD                    1004
#define IDC_LIST_MAIN                   1006
#define IDC_BTN_ADD                     1008
#define IDC_BTN_REMOVE                  1009
#define IDC_STATIC_BOX                  1010
#define IDC_MEMO_STACK                  1011
#define IDC_STATIC_LABEL                1012
#define IDC_BUTTON1                     1013
#define IDC_BUTTON_CLEAR                1013

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`README.md`:

```md
# CallMon
CallMon is a system call monitoring tool that works on Windows 10 versions 2004+ using PsAltSystemCallHandlers. 

## Usage
 * <b>CallMon requires driver signature enforcement (DSE) to be disabled. </b>
 * Download release [here](https://github.com/DownWithUp/CallMon/releases/tag/v1.0.0) (or download and build from source)
 * Ensure both CallMon.exe and AltCall.sys are in the same directory
 * Run CallMon.exe as an administrator
 * Click on "Initialize"
 * Enter a process's ID in the text field and click "Add Process"

## Architecture
CallMon is comprised of a kernel driver (AltCall.sys) and a GUI application (CallMon.exe). Together, these programs work to provide API introspection for monitored processes.
The driver and GUI application communicate via a named pipe (\\\\.\pipe\CallMonPipe). The data passed by the driver to usermode consists of a custom header which contains the process id and stack information along with a KTRAP_FRAME structure received from the alt syscall handler function.

## Performance Impacts
Because the system call handler function is called everytime a targeted process preforms a call (and in the context of the targeted process), heavy API usage programs will experience a drop in performance due to the transfer of data back to the CallMon GUI process.

## Resources
[0xcpu's Research on AltSyscallHandlers](https://github.com/0xcpu/WinAltSyscallHandler)

# Rust Driver Version
Optionally, there is a version of the AltCall.sys driver written in Rust. The sources and binary are included only in the repository and not in the release. I highly recommended reading not-matthias' (his code was the foundation for the Rust version) [blog post](https://not-matthias.github.io/kernel-driver-with-rust/) on building Windows drivers in Rust. In addition, I will mention that I worked on this to better my Rust skills and not to make a memory safe driver. I heavily used "unsafe" Rust code, and kernel interactions in themselves can always go awire. <br>
### Build
If you are not already on the nightly channel, change to it using:<br>
<code>rustup toolchain install nightly</code><br>
Override using:<br>
<code>rustup override set nightly</code><br>
### C VS. Rust
Besides, the obvious syntax differences, I also made some design changes:<br>
* Rust version uses ProbeForRead instead of MmHighestUserAddress and MmIsAddressValid check for stack pointer.
* Rust version ~~has no remove process IOCTL handling function (possibly coming soon?)~~ now has support for removing processes!

```

`Rust/Cargo.toml`:

```toml
[package]
name = "AltCall"
version = "0.1.0"
edition = "2018"
build = "build.rs"

[lib]
path = "src/lib.rs"
crate-type = ["cdylib"]

[dependencies]
kernel-print = "0.1.0"
kernel-alloc = "0.1.0"
obfstr = "0.1.1"

[dependencies.winapi]
git = "https://github.com/Trantect/winapi-rs.git"
branch = "feature/km"
features = [
    "wdm",
    "ntstatus",
]

[build-dependencies]
winreg = "0.7.0"
failure = "0.1.8"

```

`Rust/Makefile.toml`:

```toml
[env.development]
TARGET_PATH = "target/x86_64-pc-windows-msvc/debug"

[env.production]
TARGET_PATH = "target/x86_64-pc-windows-msvc/release"
BUILD_FLAGS = "--release"

[tasks.build-driver]
script = [
    "cargo b %BUILD_FLAGS%"
]

[tasks.rename]
dependencies = ["build-driver"]
ignore_errors = true
script = [
    "cd %TARGET_PATH%",
    "rename driver.dll driver.sys",
]

[tasks.sign]
dependencies = ["build-driver", "rename"]
script = [
    # Load the Visual Studio Developer environment
    "call \"%ProgramFiles(x86)%\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat\"",

    # Create a self signed certificate (only if not already done)
    "if not exist DriverCertificate.cer ( makecert -r -pe -ss PrivateCertStore -n CN=DriverCertificate DriverCertificate.cer ) else ( echo Certificate already exists. )",

    # Sign the driver
    "signtool sign /a /v /s PrivateCertStore /n DriverCertificate /t http://timestamp.digicert.com %TARGET_PATH%/driver.sys"
]

```

`Rust/build.rs`:

```rs
use failure::{format_err, Error};
use std::{
    env::var,
    path::{Path, PathBuf},
};
use winreg::{enums::*, RegKey};

/// Returns the path to the `Windows Kits` directory. It's by default at
/// `C:\Program Files (x86)\Windows Kits\10`.
fn get_windows_kits_dir() -> Result<PathBuf, Error> {
    let hklm = RegKey::predef(HKEY_LOCAL_MACHINE);
    let key = r"SOFTWARE\Microsoft\Windows Kits\Installed Roots";
    let dir: String = hklm.open_subkey(key)?.get_value("KitsRoot10")?;

    Ok(dir.into())
}

/// Returns the path to the kernel mode libraries. The path may look like this:
/// `C:\Program Files (x86)\Windows Kits\10\lib\10.0.18362.0\km`.
fn get_km_dir(windows_kits_dir: &PathBuf) -> Result<PathBuf, Error> {
    let readdir = Path::new(windows_kits_dir).join("lib").read_dir()?;

    let max_libdir = readdir
        .filter_map(|dir| dir.ok())
        .map(|dir| dir.path())
        .filter(|dir| {
            dir.components()
                .last()
                .and_then(|c| c.as_os_str().to_str())
                .map(|c| c.starts_with("10.") && dir.join("km").is_dir())
                .unwrap_or(false)
        })
        .max()
        .ok_or_else(|| format_err!("Can not find a valid km dir in `{:?}`", windows_kits_dir))?;

    Ok(max_libdir.join("km"))
}

fn internal_link_search() {
    let windows_kits_dir = get_windows_kits_dir().unwrap();
    let km_dir = get_km_dir(&windows_kits_dir).unwrap();
    let target = var("TARGET").unwrap();

    let arch = if target.contains("x86_64") {
        "x64"
    } else if target.contains("i686") {
        "x86"
    } else {
        panic!("Only support x86_64 and i686!");
    };

    let lib_dir = km_dir.join(arch);
    println!("cargo:rustc-link-search=native={}", lib_dir.to_str().unwrap());
}

fn extra_link_search() {}

fn main() {
    if var(format!("CARGO_FEATURE_{}", "extra_link_search".to_uppercase())).is_ok() {
        extra_link_search()
    } else {
        internal_link_search()
    }
}

```

`Rust/rustfmt.toml`:

```toml
edition = "2018"

brace_style                     = "PreferSameLine"
color                           = "Always"
fn_args_layout                  = "Compressed"
fn_single_line                  = true
format_code_in_doc_comments     = true
format_macro_matchers           = true
format_macro_bodies             = true
format_strings                  = true
inline_attribute_width          = 80
max_width                       = 120
merge_imports                   = true
normalize_doc_attributes        = true
reorder_impl_items              = true
reorder_imports                 = true
reorder_modules                 = true
use_field_init_shorthand        = true
use_try_shorthand               = true
where_single_line               = true
wrap_comments                   = true

```

`Rust/src/defines.rs`:

```rs
/*
    Some defines and structs that are custom or was unable to find 
    in the winapi crate.
*/
#![allow(non_snake_case)]

use winapi::shared::ntdef::{ULONG, USHORT, UCHAR, KIRQL, HANDLE};
use winapi::um::winnt::M128A;
use winapi::km::wdm::KPROCESSOR_MODE;
use winapi::um::winnt::ACCESS_MASK;
pub type QWORD = u64;
pub const FILE_DEVICE_SECURE_OPEN: ULONG            = 0x00000100;
pub const FILE_DELETE_ON_CLOSE: ULONG               = 0x00001000;
pub const FILE_SYNCHRONOUS_IO_NONALERT:ULONG        = 0x00000020;
pub const FILE_OPEN:ULONG                           = 0x00000001;
pub const PagedPool: ULONG                          = 0x00000001;
pub const ProcessAltSystemCallInformation: ULONG    = 0x00000064;

pub const IOCTL_ADD_PROCESS: ULONG     = 0x550000;
pub const IOCTL_REMOVE_PROCESS: ULONG  = 0x550002;
pub const IOCTL_INIT: ULONG            = 0x550004;

pub struct State
{
    pub abc: ULONG,
} 

pub struct _CLIENT_ID
{
    pub UniqueProcess: HANDLE,
    pub UniqueThread: HANDLE,
}
pub type CLIENT_ID = _CLIENT_ID;
pub type PCLIENT_ID = *mut _CLIENT_ID;

pub struct _OBJECT_HANDLE_INFORMATION {
    pub HandleAttributes: ULONG,
    pub GrantedAccess: ACCESS_MASK,
} 
pub type OBJECT_HANDLE_INFORMATION = _OBJECT_HANDLE_INFORMATION;
pub type POBJECT_HANDLE_INFORMATION =  *mut _OBJECT_HANDLE_INFORMATION;

pub struct _CUSTOM_HEADER
{
    pub ProcessId: QWORD,
    pub StackData: [QWORD; 16],
} 
pub type CUSTOM_HEADER  = _CUSTOM_HEADER;
pub type PCUSTOM_HEADER = *mut _CUSTOM_HEADER;


// Unions for KTRAP_FRAME
pub union u1 
{
    pub GsBase: QWORD,
    pub GsSwap: QWORD,
}

pub union u2
{
    pub FaultAddress: QWORD,
    pub ContextRecord: QWORD,
}

pub union u3 
{
    pub ErrorCode: QWORD,
    pub ExceptionFrame: QWORD,
}

#[repr(C)]
pub struct _KTRAP_FRAME 
{
     //
     // Home address for the parameter registers.
     //     
    pub P1Home: QWORD,
    pub P2Home: QWORD,
    pub P3Home: QWORD,
    pub P4Home: QWORD,
    pub P5: QWORD,

    //
    // Previous processor mode (system services only) and previous IRQL
    // (interrupts only).
    //
     
    pub PreviousMode: KPROCESSOR_MODE,
     
    pub PreviousIrql: KIRQL,
     
    //
    // Page fault load/store indicator.
    // 
    pub FaultIndicator: UCHAR,
     
    //
    // Exception active indicator.
    //
    //    0 - interrupt frame.
    //    1 - exception frame.
    //    2 - service frame.
    // 
    pub ExceptionActive: UCHAR,
    
    //
    // Floating point state.
    //
 
    pub MxCsr: ULONG,
     
    //
    //  Volatile registers.
    //
    // N.B. These registers are only saved on exceptions and interrupts. They
    //      are not saved for system calls.
    // 
    pub Rax: QWORD,
    pub Rcx: QWORD,
    pub Rdx: QWORD,
    pub R8: QWORD,
    pub R9: QWORD,
    pub R10: QWORD,
    pub R11: QWORD,
 
    //
    // Gsbase is only used if the previous mode was kernel.
    //
    // GsSwap is only used if the previous mode was user.
    //
    pub u1: u1,
     
    //
    // Volatile floating registers.
    //
    // N.B. These registers are only saved on exceptions and interrupts. They
    //      are not saved for system calls.
    //
     
    pub Xmm0: M128A,
    pub Xmm1: M128A,
    pub Xmm2: M128A,
    pub Xmm3: M128A,
    pub Xmm4: M128A,
    pub Xmm5: M128A,
 
    //
    // First parameter, page fault address, context record address if user APC
    // bypass.
    //

    pub u2: u2, 
  
    //
    //  Debug registers.
    // 
    pub Dr0: QWORD,
    pub Dr1: QWORD,
    pub Dr2: QWORD,
    pub Dr3: QWORD,
    pub Dr6: QWORD,
    pub Dr7: QWORD,     
    //
    // Special debug registers.
    //

    //pub DebugRegs: _DEBUG_REGS,

    pub DebugControl: QWORD,
    pub LastBranchToRip: QWORD,
    pub LastBranchFromRip: QWORD,  
    pub LastExceptionToRip: QWORD,
    pub LastExceptionFromRip: QWORD,
         
     //
     //  Segment registers
     //
         
    pub SegDs: USHORT,
    pub SegEs: USHORT,
    pub SegFs: USHORT,
    pub SegGs: USHORT,
        
    //
    // Previous trap frame address.
    //
        
    pub TrapFrame: QWORD,
        
    //
    // Saved nonvolatile registers RBX, RDI and RSI. These registers are only
    // saved in system service trap frames.
    //

    pub Rbx: QWORD,
    pub Rdi: QWORD,
    pub Rsi: QWORD,
         
    //
    // Saved nonvolatile register RBP. This register is used as a frame
    // pointer during trap processing and is saved in all trap frames.
    // 
    pub Rbp: QWORD,
    
    //
    // Information pushed by hardware.
    //
    // N.B. The error code is not always pushed by hardware. For those cases
    //      where it is not pushed by hardware a dummy error code is allocated
    //      on the stack.
    //
    pub u3: u3, 

    pub Rip: QWORD,
    pub SegCs: USHORT,
    pub Fill0: UCHAR,
    pub Logging: UCHAR,
    pub Fill1: [USHORT;2],
    pub EFlags: ULONG,
    pub Fill2: ULONG,
    pub Rsp: QWORD,
    pub SegSs: USHORT,
    pub Fill3: USHORT,
    pub Fill4: ULONG,
}
pub type KTRAP_FRAME = _KTRAP_FRAME;
pub type PKTRAP_FRAME = *mut _KTRAP_FRAME;

pub struct _TOTAL_PACKET
{
    pub CustomHeader: CUSTOM_HEADER,
    /*
        The padding is here because for some reason, 
        the C version size of TOTAL_PACKET is 544
        while the rust version is 536. 
        In both versions the KTRAP_FRAME is 400
        and the CUSTOM_HEADER is 136 which should
        equal 536, but some optimization seems to occur
        which adds padding per struct in a struct.
    */
    CPadding: QWORD,
    pub Frame: KTRAP_FRAME,
}
pub type TOTAL_PACKET = _TOTAL_PACKET;
pub type PTOTAL_PACKET = *mut _TOTAL_PACKET;

```

`Rust/src/externs.rs`:

```rs
use winapi::km::wdm::*;
use winapi::km::wdm::IO_PRIORITY::KPRIORITY_BOOST;
use winapi::um::winnt::ACCESS_MASK;
use winapi::shared::ntdef::*;
use winapi::shared::basetsd::SIZE_T;
//crate::defines
use crate::PCLIENT_ID;
use crate::POBJECT_HANDLE_INFORMATION;

extern "system" {

    pub fn ProbeForRead(Address: PVOID, Length: SIZE_T, Alignment: ULONG);

    pub fn IoCreateDevice(DriverObject: PDRIVER_OBJECT, DeviceExtension: ULONG, DeviceName: PUNICODE_STRING, 
        DeviceType: ULONG, DeviceCharacteristics: ULONG, Exclusive: BOOLEAN, DeviceObject: *mut*mut DEVICE_OBJECT) -> NTSTATUS;

    pub fn IoCreateSymbolicLink(SymbolicLinkName: PUNICODE_STRING, DeviceName: PUNICODE_STRING) -> NTSTATUS;

    pub fn MmGetSystemRoutineAddress(SystemRoutineName: PUNICODE_STRING) -> PVOID;
    
    pub fn IofCompleteRequest(Irp : PIRP, PriorityBoost: KPRIORITY_BOOST);

    pub fn ZwSetInformationProcess(ProcessHandle: HANDLE, ProcessInformationClass: ULONG, ProcessInformation: PVOID,
        ProcessInformationLength: ULONG) -> NTSTATUS;
        
    pub fn PsSuspendProcess(Process: PEPROCESS) -> NTSTATUS;

    pub fn PsResumeProcess(Process: PEPROCESS) -> NTSTATUS;

    pub fn ZwCreateFile(FileHandle: PHANDLE, AccessMask: ACCESS_MASK, ObjectAttributes: POBJECT_ATTRIBUTES, IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER, FileAttributes: ULONG, ShareAccess: ULONG, CreateDisposition: ULONG, CreateOptions: ULONG, EaBuffer: PVOID,
        EaLength: ULONG) -> NTSTATUS;
    
    pub fn ZwOpenProcess(ProcessHandle: PHANDLE, DesiredAccess: ACCESS_MASK, ObjectAttributes: POBJECT_ATTRIBUTES, 
        ClientId: PCLIENT_ID) -> NTSTATUS;

    pub fn ZwWriteFile(FileHandle: HANDLE, Event: HANDLE, ApcRoutine: PVOID, ApcContext: PVOID, IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID, Length: ULONG, ByteOffset: PLARGE_INTEGER, Key: PULONG) -> NTSTATUS;
    
    pub fn ZwClose(Handle: HANDLE) -> NTSTATUS;

    pub fn memmove(Destination: PVOID, Source: PVOID, Size: SIZE_T) -> PVOID; // cdecl

    pub fn PsGetProcessId(Process: PEPROCESS) -> HANDLE;

    pub fn ObReferenceObjectByHandle(Handle: HANDLE, DesiredAccess: ACCESS_MASK, ObjectType: PVOID, AccessMode: KPROCESSOR_MODE,
        Object: *mut PVOID, HandleInformation: POBJECT_HANDLE_INFORMATION) -> NTSTATUS;

    pub fn PsGetCurrentProcess() -> PEPROCESS;

    pub fn ObDereferenceObject(Object: PVOID) -> NTSTATUS;
}

```

`Rust/src/lib.rs`:

```rs
#![no_std]
#![feature(alloc_error_handler)]
#![allow(non_snake_case)]
#![feature(asm)]

extern crate alloc;

use crate::{string::create_unicode_string, externs::IofCompleteRequest, externs::MmGetSystemRoutineAddress, 
    externs::PsGetCurrentProcess, externs::PsGetProcessId, externs::ZwClose, externs::ZwCreateFile, externs::ZwOpenProcess, 
    externs::ZwSetInformationProcess, externs::ProbeForRead, externs::ZwWriteFile, externs::memmove, 
    externs::ObReferenceObjectByHandle, externs::ObDereferenceObject, externs::PsSuspendProcess, externs::PsResumeProcess};
pub mod externs;
pub mod log;
pub mod string;
pub mod defines;

use core::panic::PanicInfo;
use winapi::um::winnt::PROCESS_ALL_ACCESS;
use winapi::km::wdm::KPROCESSOR_MODE::KernelMode;
use winapi::km::wdm::*;
use winapi::shared::ntdef::*;
use winapi::shared::ntstatus::*;
use defines::*;

// Globals
static mut hGlobalPipe: HANDLE = 0 as HANDLE;

// When using the alloc crate it seems like it does some unwinding. Adding this
// export satisfies the compiler but may introduce undefined behaviour when a
// panic occurs.
#[no_mangle]
pub extern "system" fn __CxxFrameHandler3(_: *mut u8, _: *mut u8, _: *mut u8, _: *mut u8) -> i32 { unimplemented!() }
// Hack, explanation can be found here: https://github.com/Trantect/win_driver_example/issues/4
#[export_name = "_fltused"]
static _FLTUSED: i32 = 0;

#[global_allocator]
static GLOBAL: kernel_alloc::KernelAlloc = kernel_alloc::KernelAlloc;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! 
{ 
    loop {};
}

extern "system" fn DriverUnloadFunction(DriverObject: &mut DRIVER_OBJECT)
{
    kernel_print::kernel_println!("Unload attempt");
    return;
}

pub extern "system" fn MyHandler(Frame: PKTRAP_FRAME) -> BOOLEAN
{
    unsafe
    {
        use core::ptr::null_mut;
        use core::mem::zeroed;
        use core::mem::transmute;

        let mut totalPacket: TOTAL_PACKET = core::mem::zeroed::<TOTAL_PACKET>();
        let mut ioBlock: IO_STATUS_BLOCK = core::mem::zeroed::<IO_STATUS_BLOCK>();

        totalPacket.CustomHeader.ProcessId = PsGetProcessId(PsGetCurrentProcess()) as QWORD;
        let mut TryProbe = ||
        {
            if (*Frame).Rsp as QWORD != 0
            {
                ProbeForRead((*Frame).Rsp as PVOID, (totalPacket.CustomHeader.StackData.len() * core::mem::size_of::<QWORD>()), 4);
                memmove(transmute(&mut totalPacket.CustomHeader.StackData), (*Frame).Rsp as PVOID, 
                    (totalPacket.CustomHeader.StackData.len() * core::mem::size_of::<QWORD>()));
            }
        };
        TryProbe();
        memmove(transmute(&mut totalPacket.Frame), Frame as PVOID, core::mem::size_of::<KTRAP_FRAME>());
        ZwWriteFile(hGlobalPipe, null_mut(), null_mut(), null_mut(), &mut ioBlock, transmute(&mut totalPacket), 
            core::mem::size_of::<TOTAL_PACKET>() as ULONG, null_mut(), null_mut());

        return TRUE;
    }
}

fn AddProcess(PID: DWORD) -> NTSTATUS
{
    use core::ptr::null_mut;

    unsafe
    {
        let mut objAttr: OBJECT_ATTRIBUTES = core::mem::zeroed::<OBJECT_ATTRIBUTES>();     
        let mut clientId: CLIENT_ID = core::mem::zeroed::<CLIENT_ID>();
        InitializeObjectAttributes(&mut objAttr, null_mut(), OBJ_KERNEL_HANDLE, null_mut(), null_mut()); 
        clientId.UniqueProcess = PID as HANDLE;
        clientId.UniqueThread = 0 as HANDLE;
        let mut hProcess: HANDLE = 0 as HANDLE;
        if NT_SUCCESS(ZwOpenProcess(&mut hProcess, PROCESS_ALL_ACCESS, &mut objAttr, &mut clientId))
        {
            let mut NewPID: QWORD = PID.into();
            
            if NT_SUCCESS(ZwSetInformationProcess(hProcess, ProcessAltSystemCallInformation, &mut NewPID as *mut QWORD as PVOID, 1))
            {
                ZwClose(hProcess);
                return STATUS_SUCCESS;
            }
        }
    }
    return STATUS_UNSUCCESSFUL;
}

fn RemoveProcess(PID: DWORD) -> NTSTATUS
{
    use core::ptr::null_mut;
    let mut ntRet: NTSTATUS = STATUS_SUCCESS;

    unsafe
    {
        let mut objAttr: OBJECT_ATTRIBUTES = core::mem::zeroed::<OBJECT_ATTRIBUTES>();     
        let mut clientId: CLIENT_ID = core::mem::zeroed::<CLIENT_ID>();
        InitializeObjectAttributes(&mut objAttr, null_mut(), OBJ_KERNEL_HANDLE, null_mut(), null_mut()); 
        clientId.UniqueProcess = PID as HANDLE;
        clientId.UniqueThread = 0 as HANDLE;
        let mut hProcess: HANDLE = 0 as HANDLE;
        if NT_SUCCESS(ZwOpenProcess(&mut hProcess, PROCESS_ALL_ACCESS, &mut objAttr, &mut clientId))
        {
            let mut NewPID: QWORD = PID.into();       
            let mut pProcess: PEPROCESS = null_mut();


            if NT_SUCCESS(ObReferenceObjectByHandle(hProcess, PROCESS_ALL_ACCESS, null_mut(), KernelMode, &mut pProcess, null_mut()))
            {
                ntRet = PsSuspendProcess(pProcess);
                let mut pThreadHead: PLIST_ENTRY = null_mut();
                let mut pThreadNext: PLIST_ENTRY = null_mut();

                pThreadHead = (pProcess as QWORD + 0x5E0) as PLIST_ENTRY;
                pThreadNext = (*pThreadHead).Flink;
                let mut pThread: PVOID = null_mut();
                while pThreadNext != pThreadHead
                {
                    pThread = pThreadNext as PVOID;
                    pThread = (pThread as QWORD - 0x4E8) as PVOID;
                    /*
                        asm block to replace the _interlockedbittestandreset macro
                        lock btr dword ptr [rax], 1Dh
                    */
                    asm!("lock btr dword ptr [{0}], 0x1D", inout(reg) pThread);
                    pThreadNext = (*pThreadNext).Flink;
                }

                ntRet = PsResumeProcess(pProcess);
                ObDereferenceObject(pProcess);
            }

            ZwClose(hProcess);
        
        }
    }
    return STATUS_SUCCESS;
}

fn PreformInit() -> NTSTATUS
{
    use core::ptr::null_mut;
    use core::mem::zeroed;
    
    let mut ntRet: NTSTATUS = STATUS_SUCCESS;
    unsafe
    {
        if hGlobalPipe != 0 as HANDLE
        {
            ZwClose(hGlobalPipe);
            hGlobalPipe = 0 as HANDLE;
        }
        else
        {
            let mut objPipe: OBJECT_ATTRIBUTES = core::mem::zeroed::<OBJECT_ATTRIBUTES>();
            let mut usPipe = create_unicode_string(obfstr::wide!("\\Device\\NamedPipe\\CallMonPipe"));
            InitializeObjectAttributes(&mut objPipe, &mut usPipe, OBJ_KERNEL_HANDLE, null_mut(), null_mut());
            let mut ioBlock: IO_STATUS_BLOCK = core::mem::zeroed::<IO_STATUS_BLOCK>();
            if NT_SUCCESS(ZwCreateFile(&mut hGlobalPipe, FILE_WRITE_DATA | SYNCHRONIZE, &mut objPipe, &mut ioBlock, null_mut(), 0, 0, FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DELETE_ON_CLOSE, NULL, 0))
            {
                ntRet = STATUS_SUCCESS;
            }
            else
            {
                ntRet = STATUS_PIPE_BROKEN;
            }
        }
    }
    return ntRet;
}

extern "system" fn DeviceDispatch(DeviceObject: &mut DEVICE_OBJECT, Irp: &mut IRP) -> NTSTATUS
{
    let pStack: &mut IO_STACK_LOCATION;
    let mut ntRet: NTSTATUS = STATUS_SUCCESS;

    unsafe
    {
        let FunctionCode = (*(*Irp.Tail.Overlay().__bindgen_anon_2.__bindgen_anon_1.CurrentStackLocation())).MajorFunction;
        let Stack = (*Irp.Tail.Overlay().__bindgen_anon_2.__bindgen_anon_1.CurrentStackLocation());
        let IOCTL = (*Stack).Parameters.DeviceIoControl().IoControlCode as u32;
        if FunctionCode == IRP_MJ::DEVICE_CONTROL as u8
        {
            match IOCTL
            {
                IOCTL_ADD_PROCESS =>
                {
                    if (*Stack).Parameters.DeviceIoControl().InputBufferLength as DWORD == 4
                    {
                        let mut buf = (*Irp.AssociatedIrp.SystemBuffer_mut());
                        let PID: &mut DWORD = &mut *(buf as *mut DWORD);
                        ntRet = AddProcess(*PID);
                    }
                    else 
                    {
                        ntRet = STATUS_BUFFER_TOO_SMALL;
                    }
                },
                IOCTL_REMOVE_PROCESS =>
                {
                    if (*Stack).Parameters.DeviceIoControl().InputBufferLength as DWORD == 4
                    {
                        let mut buf = (*Irp.AssociatedIrp.SystemBuffer_mut());
                        let PID: &mut DWORD = &mut *(buf as *mut DWORD);
                        ntRet = RemoveProcess(*PID);
                    }
                    else 
                    {
                        ntRet = STATUS_BUFFER_TOO_SMALL;
                    }

                },
                IOCTL_INIT => ntRet = PreformInit(),
                _ => kernel_print::kernel_println!("Invalid IOCTL (Might not be supported in rust version)"),
            } 
        }
        let a = Irp.IoStatus.__bindgen_anon_1.Status_mut();
        *a = ntRet;
        IofCompleteRequest(Irp, 0);
    }
    return STATUS_SUCCESS;
}

#[no_mangle]
pub extern "system" fn DriverEntry(DriverObject: &mut DRIVER_OBJECT, RegistryPath: PUNICODE_STRING) -> NTSTATUS 
{
    use core::mem::transmute;

    DriverObject.DriverUnload = Some(DriverUnloadFunction);
    let usDevice = create_unicode_string(obfstr::wide!("\\Device\\CallMon\0"));
    unsafe
    {
        use winapi::km::wdm::DEVICE_TYPE::FILE_DEVICE_UNKNOWN;
        let mut outDevice: *mut DEVICE_OBJECT = core::ptr::null_mut();

        if NT_SUCCESS(IoCreateDevice(DriverObject, 0, &usDevice, FILE_DEVICE_UNKNOWN,  FILE_DEVICE_SECURE_OPEN, FALSE, &mut outDevice))
        {
            kernel_print::kernel_println!("Finished initializing!");
            let usSymLink = create_unicode_string(obfstr::wide!("\\DosDevices\\CallMon"));
            if NT_SUCCESS(IoCreateSymbolicLink(&usSymLink, &usDevice))
            {
                (*outDevice).Flags |= DEVICE_FLAGS::DO_BUFFERED_IO as u32;
                for i in 0..IRP_MJ::MAXIMUM_FUNCTION as usize
                {
                    DriverObject.MajorFunction[i] = Some(DeviceDispatch);
                }
                let mut usPsRegisterAltSystemCallHandler = create_unicode_string(obfstr::wide!("PsRegisterAltSystemCallHandler"));
                type PsRegisterAltSystemCallHandler = extern "system" fn(HandlerRoutine: PVOID, HandlerIndex: LONG) -> NTSTATUS;
                let pPsRegisterAltSystemCallHandler: PsRegisterAltSystemCallHandler = transmute(MmGetSystemRoutineAddress(&mut usPsRegisterAltSystemCallHandler));
                if NT_SUCCESS(pPsRegisterAltSystemCallHandler(transmute(MyHandler as PVOID), 1))
                {
                    return STATUS_SUCCESS;
                }
            }
        }
    }
    return STATUS_UNSUCCESSFUL
}

```

`Rust/src/log.rs`:

```rs
pub use winapi::km::wdm::DbgPrint;

#[macro_export]
macro_rules! log {
    ($string: expr) => {
        unsafe {
            $crate::log::DbgPrint(concat!("[>] ", $string, "\0").as_ptr())
        }
    };

    ($string: expr, $($x:tt)*) => {
        unsafe {
            #[allow(unused_unsafe)]
            $crate::log::DbgPrint(concat!("[>] ", $string, "\0").as_ptr(), $($x)*)
        }
    };
}

```

`Rust/src/string.rs`:

```rs
use winapi::shared::ntdef::UNICODE_STRING;

pub fn create_unicode_string(s: &[u16]) -> UNICODE_STRING {
    let len = s.len();

    let n = if len > 0 && s[len - 1] == 0 { len - 1 } else { len };

    UNICODE_STRING {
        Length: (n * 2) as u16,
        MaximumLength: (len * 2) as u16,
        Buffer: s.as_ptr() as _,
    }
}

```