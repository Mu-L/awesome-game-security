Project Path: arc_irql_nokd_a_itya7u

Source Tree:

```txt
arc_irql_nokd_a_itya7u
├── README.md
├── example
│   ├── Exit.c
│   ├── Freeze.c
│   ├── KdLayer.c
│   └── Load.c
├── kdpl
│   ├── comm
│   │   ├── pci.c
│   │   ├── uart.c
│   │   ├── vmwrpc.c
│   │   └── vmwrpc64.asm
│   ├── inc
│   │   ├── dbgkd.h
│   │   ├── kddef.h
│   │   ├── kdpl.h
│   │   ├── pci.h
│   │   ├── uart.h
│   │   └── vmwrpc.h
│   ├── kdapi.c
│   ├── kdpl.c
│   ├── kdpl.vcxproj
│   └── kdpl.vcxproj.filters
└── nokd.sln

```

`README.md`:

```md
# nokd

This is a simple kd/WinDBG stub which can be implemented by anyone, in virtually any environment. 
I wrote this project a few years ago, and figured it would be nice to release to the public, I personally use it 
inside of my type 1 hypervisor to debug windows guests without flagging any anti-debug software, such as malware, or anti-cheats. 
The implementation does not require any of the KD specific variables in ntoskrnl to be set, it will copy the KdDebuggerDataBlock to local
memory and decoded it inline, then pass this to WinDBG as the debugger block, making it very difficult to flag. A few functions are required to
be implemented by yourself, but an example has been provided which was taken from my hypervisor. Not all of the functions need to be implemented
but some functionality will not work properly without them.

# Communication

I've provided a very basic UART driver, which can be used with either a motherboard COM header, or adapted to work with 
various PCI-e boards depending on their chipset. You may have to modify this for it to work on your hardware.

There is also a VMWare RPC driver, which was stripped & taken from [VirtualKD](https://github.com/sysprogs/VirtualKD/), this should
work fine on vmware, with VirtualKD-Redux version 2020.2.

# Implementation

I would recommend compiling as a static library, and including in your project. You will need to implement the 
8 functions, and 2 data variables required by the library, these can be found in [kddef.h](https://github.com/irql/nokd/blob/master/kdpl/inc/kddef.h#L56-L57)
labelled with `KDPLAPI`, an example can be found in the `/examples/` folder.

# Help

Feel free to contact me on discord if you need help implementing it: `ivql`

```

`example/Exit.c`:

```c

#include <Limevisor.h>
#include <Hypervisor/KiHpr.h>
#include <Nokd.h>
#include <Hypervisor/Ksrp.h>

VOID
KAPI
KiHprExitDispatch(
    _In_ PKTRAP_FRAME      TrapFrame,
    _In_ PKEXCEPTION_FRAME ExceptionFrame
    )
{

    //
    // ...
    //

    //
    // Check for a debug break on any processor.
    //
#if LIME_HV_ENABLE_NOKD

    if (K_SUCCESS(DbgKdInitStatus) && K_SUCCESS(DbgKdConnectionStatus)) {

        if (DbgKdTryAcquireDebuggerLock()) {

            if (DbgKdpPollBreak()) {
                DBG_PRINT("Break requested\n");

                DbgKdFreezeProcessors(TrapFrame,
                                      ExceptionFrame,
                                      &TrapRecord,
                                      DbgKdFrozenBreakpoint);
            }
            else {
                DbgKdReleaseDebuggerLock();
            }
        }
    }
#endif

    //
    // Handle your vmexit here...
    //

    //
    // All other processors should reach this statement, and be frozen.
    //
    if ((DbgKdpFreezeFlags & (KD_FREEZE_ACTIVE | KD_TRAP_ACTIVE)) == KD_FREEZE_ACTIVE) {

        DbgKdFreezeTrap(TrapFrame,
                        ExceptionFrame,
                        &TrapRecord);
    }

    //
    // ...
    //
}


```

`example/Freeze.c`:

```c

#include <Limevisor.h>
#include <Nokd.h>

KSPIN_LOCK                  DbgKdpDebuggerLock = 0;

VOLATILE ULONG32            DbgKdpFreezeFlags  = 0;
VOLATILE ULONG32            DbgKdpFreezeCount  = 0;
VOLATILE ULONG32            DbgKdpFreezeOwner  = 0;
VOLATILE PKD_FREEZE_ROUTINE DbgKdpFreezeRoutine;

VOLATILE PNT_CONTEXT           DbgKdpContextRecords[64];
VOLATILE PNT_SPECIAL_REGISTERS DbgKdpSpecialRegisters[64];

PNT_CONTEXT
KAPI
DbgKdQueryProcessorContext(
    _In_ ULONG32 ProcessorNumber
    )
{
    return DbgKdpContextRecords[ProcessorNumber];
}

PNT_SPECIAL_REGISTERS
KAPI
DbgKdQuerySpecialRegisters(
    _In_ ULONG32 ProcessorNumber
    )
{
    return DbgKdpSpecialRegisters[ProcessorNumber];
}


VOID
KAPI
DbgKdAcquireDebuggerLock(
    VOID
    )
{
    //
    // It is anticipated that this will only be called by things like the VM exit handler,
    // which is called with IF = 0. This is written under the assumption that 
    // interrupts ARE disabled.
    //
    KIRQL PreviousIrql;

    KeRaiseIrql(DISPATCH_LEVEL, &PreviousIrql);

    do {
        //
        // Check for freeze trap.
        //
    } while (_InterlockedCompareExchange64((volatile long long*)&DbgKdpDebuggerLock, 1, 0) != 0);

    KeLowerIrql(PreviousIrql);
}

BOOLEAN
KAPI
DbgKdTryAcquireDebuggerLock(
    VOID
    )
{
    if (DbgKdpDebuggerLock == 0) {
        return _InterlockedCompareExchange64((volatile long long*)&DbgKdpDebuggerLock, 1, 0) == 0;
    }
    else {
        return FALSE;
    }
}

VOID
KAPI
DbgKdReleaseDebuggerLock(
    VOID
    )
{
    DbgKdpDebuggerLock = 0;
}

KSTATUS
KAPI
DbgKdTrapStep(
    _In_ PKTRAP_FRAME        TrapFrame,
    _In_ PKEXCEPTION_FRAME   ExceptionFrame,
    _In_ PKHYPER_TRAP_RECORD TrapRecord,
    _In_ PVOID               TrapContext
    )
{
    UNREFERENCED_PARAMETER(TrapContext);

    DbgKdpFreezeFlags  &= ~KD_TRAP_ACTIVE;
    DbgKdpFreezeRoutine = DbgKdFrozenStep;
    DbgKdFreezeTrap(TrapFrame,
                    ExceptionFrame,
                    TrapRecord);

    if (DbgKdpFreezeFlags & KD_TRAP_ACTIVE) {
        //
        // Still stepping.
        // Could return STATUS_TRAP_AGAIN
        //
        return STATUS_SUCCESS;
    }

    DbgKdpFreezeCount = 0;
    DbgKdpFreezeFlags = 0;
    DbgKdReleaseDebuggerLock();
    return STATUS_SUCCESS;
}

VOID
KAPI
DbgKdFreezeTrap(
    _In_ PKTRAP_FRAME        TrapFrame,
    _In_ PKEXCEPTION_FRAME   ExceptionFrame,
    _In_ PKHYPER_TRAP_RECORD TrapRecord
    )
{
    UNREFERENCED_PARAMETER(TrapRecord);

    PKPCR                Pcr;
    ULONG32              PreviousProcessor;
    NT_CONTEXT           ContextRecord;
    NT_SPECIAL_REGISTERS SpecialRegisters;
    ULONG64              Long;
    BOOLEAN              Trap;

    Pcr  = KeGetPcr();
    Trap = FALSE;

    RtlZeroMemory(&ContextRecord, sizeof(NT_CONTEXT));
    RtlZeroMemory(&SpecialRegisters, sizeof(NT_SPECIAL_REGISTERS));

    KeVmGet(VMCS_GUEST_RIP, &TrapFrame->Rip);
    KeVmGet(VMCS_GUEST_RSP, &TrapFrame->Rsp);

    ContextRecord.Rax   = TrapFrame->Rax;
    ContextRecord.Rcx   = TrapFrame->Rcx;
    ContextRecord.Rdx   = TrapFrame->Rdx;
    ContextRecord.R8    = TrapFrame->R8;
    ContextRecord.R9    = TrapFrame->R9;
    ContextRecord.R10   = TrapFrame->R10;
    ContextRecord.R11   = TrapFrame->R11;

    ContextRecord.Xmm0  = TrapFrame->Xmm0;
    ContextRecord.Xmm1  = TrapFrame->Xmm1;
    ContextRecord.Xmm2  = TrapFrame->Xmm2;
    ContextRecord.Xmm3  = TrapFrame->Xmm3;
    ContextRecord.Xmm4  = TrapFrame->Xmm4;
    ContextRecord.Xmm5  = TrapFrame->Xmm5;

    ContextRecord.Rbx   = ExceptionFrame->Rbx;
    ContextRecord.Rbp   = ExceptionFrame->Rbp;
    ContextRecord.Rsi   = ExceptionFrame->Rsi;
    ContextRecord.Rdi   = ExceptionFrame->Rdi;
    ContextRecord.R12   = ExceptionFrame->R12;
    ContextRecord.R13   = ExceptionFrame->R13;
    ContextRecord.R14   = ExceptionFrame->R14;
    ContextRecord.R15   = ExceptionFrame->R15;

    ContextRecord.Xmm6  = ExceptionFrame->Xmm6;
    ContextRecord.Xmm7  = ExceptionFrame->Xmm7;
    ContextRecord.Xmm8  = ExceptionFrame->Xmm8;
    ContextRecord.Xmm9  = ExceptionFrame->Xmm9;
    ContextRecord.Xmm10 = ExceptionFrame->Xmm10;
    ContextRecord.Xmm11 = ExceptionFrame->Xmm11;
    ContextRecord.Xmm12 = ExceptionFrame->Xmm12;
    ContextRecord.Xmm13 = ExceptionFrame->Xmm13;
    ContextRecord.Xmm14 = ExceptionFrame->Xmm14;
    ContextRecord.Xmm15 = ExceptionFrame->Xmm15;
    ContextRecord.ContextFlags |= CONTEXT_INTEGER | CONTEXT_FLOATING_POINT;

    ContextRecord.Rip    = TrapFrame->Rip;
    ContextRecord.Rsp    = TrapFrame->Rsp;
    ContextRecord.EFlags = (ULONG)TrapFrame->EFlags;
    ContextRecord.ContextFlags |= CONTEXT_CONTROL;

    KeVmGet(VMCS_GUEST_CS_SELECTOR, &Long);
    ContextRecord.SegCs = (USHORT)Long;
    KeVmGet(VMCS_GUEST_DS_SELECTOR, &Long);
    ContextRecord.SegDs = (USHORT)Long;
    KeVmGet(VMCS_GUEST_ES_SELECTOR, &Long);
    ContextRecord.SegEs = (USHORT)Long;
    KeVmGet(VMCS_GUEST_FS_SELECTOR, &Long);
    ContextRecord.SegFs = (USHORT)Long;
    KeVmGet(VMCS_GUEST_GS_SELECTOR, &Long);
    ContextRecord.SegGs = (USHORT)Long;
    KeVmGet(VMCS_GUEST_SS_SELECTOR, &Long);
    ContextRecord.SegSs = (USHORT)Long;
    ContextRecord.ContextFlags |= CONTEXT_SEGMENTS;

    KeVmGet(VMCS_GUEST_CR0, &SpecialRegisters.Cr0);
    KeVmGet(VMCS_GUEST_CR3, &SpecialRegisters.Cr3);
    KeVmGet(VMCS_GUEST_CR4, &SpecialRegisters.Cr4);

    KeVmGet(VMCS_GUEST_GDTR_BASE, (ULONG64*)&SpecialRegisters.Gdtr.Base);
    KeVmGet(VMCS_GUEST_GDTR_LIMIT, &Long);
    SpecialRegisters.Gdtr.Limit = (USHORT)Long;

    KeVmGet(VMCS_GUEST_IDTR_BASE, (ULONG64*)&SpecialRegisters.Idtr.Base);
    KeVmGet(VMCS_GUEST_IDTR_LIMIT, &Long);
    SpecialRegisters.Idtr.Limit = (USHORT)Long;

    MmHprAttachSpace();

    DbgKdpContextRecords[Pcr->ProcessorNumber]   = &ContextRecord;
    DbgKdpSpecialRegisters[Pcr->ProcessorNumber] = &SpecialRegisters;

    InterlockedIncrement32(&DbgKdpFreezeCount);

    while (DbgKdpFreezeCount != KeEnabledProcessorCount)
        ;

    while (DbgKdpFreezeFlags & KD_FREEZE_ACTIVE) {

        if (Pcr->ProcessorNumber == DbgKdpFreezeOwner) {

            PreviousProcessor = DbgKdpFreezeOwner;

            //
            // Call freeze callback
            //
            DbgKdpFreezeRoutine(TrapFrame, ExceptionFrame);

            if (ContextRecord.EFlags & 0x100) {

                KiHprEnableMtf(TrapFrame, ExceptionFrame, TrapRecord, DbgKdTrapStep, NULL);

                Trap                  = TRUE;
                DbgKdpFreezeFlags    |= KD_TRAP_ACTIVE;
                ContextRecord.EFlags &= ~0x100;
                break;
            }

            if (PreviousProcessor == DbgKdpFreezeOwner) {
                //
                // Thaw, otherwise switch processor and stay frozen.
                //
                DbgKdThawProcessors();
                break;
            }
        }
    }

    //
    // N.B. Ignoring a lot of state shit here...
    //
    TrapFrame->Rip    = ContextRecord.Rip;
    TrapFrame->Rsp    = ContextRecord.Rsp;
    TrapFrame->SegCs  = ContextRecord.SegCs;
    TrapFrame->SegSs  = ContextRecord.SegSs;
    TrapFrame->EFlags = ContextRecord.EFlags;

    TrapFrame->Rax = ContextRecord.Rax;
    TrapFrame->Rcx = ContextRecord.Rcx;
    TrapFrame->Rdx = ContextRecord.Rdx;
    TrapFrame->R8  = ContextRecord.R8;
    TrapFrame->R9  = ContextRecord.R9;
    TrapFrame->R10 = ContextRecord.R10;
    TrapFrame->R11 = ContextRecord.R11;

    TrapFrame->Xmm0 = ContextRecord.Xmm0;
    TrapFrame->Xmm1 = ContextRecord.Xmm1;
    TrapFrame->Xmm2 = ContextRecord.Xmm2;
    TrapFrame->Xmm3 = ContextRecord.Xmm3;
    TrapFrame->Xmm4 = ContextRecord.Xmm4;
    TrapFrame->Xmm5 = ContextRecord.Xmm5;

    ExceptionFrame->Rbx = ContextRecord.Rbx;
    ExceptionFrame->Rbp = ContextRecord.Rbp;
    ExceptionFrame->Rsi = ContextRecord.Rsi;
    ExceptionFrame->Rdi = ContextRecord.Rdi;
    ExceptionFrame->R12 = ContextRecord.R12;
    ExceptionFrame->R13 = ContextRecord.R13;
    ExceptionFrame->R14 = ContextRecord.R14;
    ExceptionFrame->R15 = ContextRecord.R15;

    ExceptionFrame->Xmm6  = ContextRecord.Xmm6;
    ExceptionFrame->Xmm7  = ContextRecord.Xmm7;
    ExceptionFrame->Xmm8  = ContextRecord.Xmm8;
    ExceptionFrame->Xmm9  = ContextRecord.Xmm9;
    ExceptionFrame->Xmm10 = ContextRecord.Xmm10;
    ExceptionFrame->Xmm11 = ContextRecord.Xmm11;
    ExceptionFrame->Xmm12 = ContextRecord.Xmm12;
    ExceptionFrame->Xmm13 = ContextRecord.Xmm13;
    ExceptionFrame->Xmm14 = ContextRecord.Xmm14;
    ExceptionFrame->Xmm15 = ContextRecord.Xmm15;

    KeVmSet(VMCS_GUEST_RIP, TrapFrame->Rip);
    KeVmSet(VMCS_GUEST_RSP, TrapFrame->Rsp);

    InterlockedDecrement32(&DbgKdpFreezeCount);
    //KeSweepLocalCaches();
}

VOID
KAPI
DbgKdThawProcessors(
    VOID
    )
{
    DbgKdpFreezeFlags = 0;
}

VOID
KAPI
DbgKdFreezeProcessors(
    _In_ PKTRAP_FRAME        TrapFrame,
    _In_ PKEXCEPTION_FRAME   ExceptionFrame,
    _In_ PKHYPER_TRAP_RECORD TrapRecord,
    _In_ PKD_FREEZE_ROUTINE  FreezeRoutine
    )
{
    //
    // Environment: Debugger lock held.
    //
    PKPCR   Pcr;
    ULONG32 Processor;

    Pcr = KeGetPcr();

    //
    // Ensure the previous freeze was complete.
    //
    while (DbgKdpFreezeCount != 0)
        ;

    DbgKdpFreezeRoutine = FreezeRoutine; 
    DbgKdpFreezeFlags   = KD_FREEZE_ACTIVE;
    DbgKdpFreezeOwner   = Pcr->ProcessorNumber;
    DbgKdpFreezeCount   = 0;

    for (Processor = 0; Processor < KeEnabledProcessorCount; Processor++) {

        if (Processor == DbgKdpFreezeOwner) {
            continue;
        }

        KeWakeNmi(Processor);
    }

    DbgKdFreezeTrap(TrapFrame, ExceptionFrame, TrapRecord);

    DbgKdReleaseDebuggerLock();
}

VOID
KAPI
DbgKdSetFreezeParameters(
    _In_ ULONG32            FreezeOwner,
    _In_ PKD_FREEZE_ROUTINE FreezeRoutine
    )
{
    DbgKdpFreezeOwner   = FreezeOwner;
    DbgKdpFreezeRoutine = FreezeRoutine;
}

VOID
KAPI
DbgKdSwapProcessor(
    _In_ ULONG32 ProcessorNumber
    )
{
    DbgKdpFreezeOwner = ProcessorNumber;
}

```

`example/KdLayer.c`:

```c

#include <Limevisor.h>
#include <Nokd.h>

#define MM_COPY_MEMORY_PHYSICAL             0x1
#define MM_COPY_MEMORY_VIRTUAL              0x2

KSTATUS DbgKdInitStatus       = STATUS_UNSUCCESSFUL;
KSTATUS DbgKdConnectionStatus = STATUS_DISCONNECTED;

ULONG64 KdKernelBase;
ULONG32 KdKernelSize;

BOOLEAN DbgKdBreakRequested   = FALSE;

//
// Get the SectionBase, SectionSize from an image by name.
//
// SectionBase & SectionSize should be relative to the image base, so 
// ImageBase could be 0x7FFE00000000, and .text could be 0x7FFE00001000, so SectionBase = 0x1000
//
KSTATUS
KAPI
KdImageSection(
    _In_      PVOID  ImageBase,
    _In_      PCHAR  SectionName,
    _Out_opt_ PVOID* SectionBase,
    _Out_opt_ ULONG* SectionSize
    )
{
    return RtlImageSection(ImageBase,
                           SectionName,
                           SectionBase,
                           SectionSize);
}

//
// Pattern scan function which takes IDA-style patterns.
//
PVOID
KAPI
KdSearchSignature(
    _In_ PVOID BaseAddress,
    _In_ ULONG Length,
    _In_ PCHAR Signature
    )
{
    return KshSearchSequence((ULONG64)BaseAddress,
                             (ULONG64)Length,
                             Signature);
}

//
// Returns the current PCR, this is how I read it from the guest.
//
PVOID
KAPI
DbgKdQueryPcr(
    VOID
    )
{
    ULONG64 PrivilegeLevel;
    ULONG64 PcrAddress;

    KeVmGet(VMCS_GUEST_CS_SELECTOR, &PrivilegeLevel);
    PrivilegeLevel &= 3;

    if (PrivilegeLevel == 0) {
        KeVmGet(VMCS_GUEST_GS_BASE, &PcrAddress);
    }
    else {
        PcrAddress = KeGetMsr(MSR_AMD64_KERNEL_GS_BASE);
    }

    return (PVOID)PcrAddress;
}

ULONG32
KAPI
DbgKdQueryProcessorCount(
    VOID
    )
{
    return KeEnabledProcessorCount;
}

//
// Simply copy memory, this should account for the fact that normally, when KD
// is running on windows, it will reach kernel space on all processors, and then break-in,
// which causes the KVA shadow CR3 to be loaded, if you are in a hypervisor and you break-in
// during user mode, you may have issues due to the kernel not being mapped. I personally just
// disable KVA, but an easy fix is to just load it from the guest's PCR.  
//
KSTATUS
KAPI
DbgKdMmCopyMemory(
    _In_ PVOID    TargetAddress,
    _In_ PVOID    SourceAddress,
    _In_ ULONG64  NumberOfBytes,
    _In_ ULONG32  Flags,
    _In_ ULONG64* NumberOfBytesTransferred
    )
{
    //
    // TODO: Implement a KVA shadowing fix for when the guest is in user mode.
    //

    switch (Flags) {
    case MM_COPY_MEMORY_VIRTUAL:

        __try {

            RtlCopyMemory(TargetAddress,
                          SourceAddress,
                          NumberOfBytes);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {

            if (ARGUMENT_PRESENT(NumberOfBytesTransferred)) {
                *NumberOfBytesTransferred = 0;
            }
            return STATUS_UNSUCCESSFUL;
        }

        if (ARGUMENT_PRESENT(NumberOfBytesTransferred)) {
            *NumberOfBytesTransferred = NumberOfBytes;
        }
        return STATUS_SUCCESS;
    case MM_COPY_MEMORY_PHYSICAL:

        __try {

            KshCopyLogicalToLinear((ULONG64)TargetAddress,
                                   (ULONG64)SourceAddress,
                                   (ULONG64)NumberOfBytes);
        } 
        __except (EXCEPTION_EXECUTE_HANDLER) {

            if (ARGUMENT_PRESENT(NumberOfBytesTransferred)) {
                *NumberOfBytesTransferred = 0;
            }
            return STATUS_UNSUCCESSFUL;
        }

        if (ARGUMENT_PRESENT(NumberOfBytesTransferred)) {
            *NumberOfBytesTransferred = NumberOfBytes;
        }
        return STATUS_SUCCESS;
    default:
        return STATUS_INVALID_PARAMETER;
    }
}

VOID
KAPI
DbgKdFrozenBreakpoint(
    _In_ PKTRAP_FRAME      TrapFrame,
    _In_ PKEXCEPTION_FRAME ExceptionFrame
    )
{
    UNREFERENCED_PARAMETER(TrapFrame);
    UNREFERENCED_PARAMETER(ExceptionFrame);

    DBG_PRINT("0x80000003\n");

    KdReportStateChange(0x80000003 /* STATUS_BREAKPOINT */, DbgKdQueryProcessorContext(KeGetPcr()->ProcessorNumber));
}

//
// My step implementation uses MTFs, see Freeze.c for how this case is caught.
//
VOID
KAPI
DbgKdFrozenStep(
    _In_ PKTRAP_FRAME      TrapFrame,
    _In_ PKEXCEPTION_FRAME ExceptionFrame
    )
{
    UNREFERENCED_PARAMETER(TrapFrame);
    UNREFERENCED_PARAMETER(ExceptionFrame);
    //
    // All processors frozen in here, override the callback internally...
    //

    DbgKdSetFreezeParameters(KeGetPcr()->ProcessorNumber, DbgKdFrozenBreakpoint);

    KdReportStateChange(0x80000004 /* STATUS_SINGLE_STEP */, DbgKdQueryProcessorContext(KeGetPcr()->ProcessorNumber));
}

//
// This is how my breakpoints work, once it is hit, 
// we just need to break-in to KD, and it should do the rest.
//
KSTATUS
KAPI
DbgKdTrapBreakpoint(
    _In_ PKTRAP_FRAME        TrapFrame,
    _In_ PKEXCEPTION_FRAME   ExceptionFrame,
    _In_ PKHYPER_TRAP_RECORD TrapRecord
    )
{
    //
    // This is the shim routine, and trap dispatch!
    //
    // Depending on whether we're going to accept generic VM breakpoints
    // this should be either inserted or not inserted into the exit trap 
    // dispatch, instead of checking anything here.
    //

    DbgKdAcquireDebuggerLock();
    DbgKdFreezeProcessors(TrapFrame, 
                          ExceptionFrame,
                          TrapRecord,
                          DbgKdFrozenBreakpoint);
    DbgKdReleaseDebuggerLock();

    return STATUS_SUCCESS;
}

//
// Simply installs a breakpoint. As commented below, you could also hook
// KdpSetOwedBreakpoints, and install breakpoints when memory is paged in.
//
KSTATUS
KAPI
DbgKdInsertBreakpoint(
    _In_ ULONG64 Address
    )
{
    //
    // TODO: For a proper KD implementation, this should deal
    //       with any owed breakpoints too, ie hooking #PF and
    //       watching for page-in's, a prototype for this was
    //       written in kdproxy, but couldn't be properly done
    //       because of pg.
    //
    // remove bp -> MTF -> insert bp
    //

    KshBreakpointShimSet(Address,
                         SHIM_GLOBAL,
                         DbgKdTrapBreakpoint);
    return STATUS_SUCCESS;
}

//
// Remove a breakpoint
//
KSTATUS
KAPI
DbgKdRemoveBreakpoint(
    _In_ ULONG64 Address
    )
{
    KshBreakpointShimRemove(Address);
    return STATUS_SUCCESS;
}

//
// Poll whether KD has requested a break-in.
//
BOOLEAN
KAPI
DbgKdpPollBreak(
    VOID
    )
{
    if (!K_SUCCESS(DbgKdInitStatus) || !K_SUCCESS(DbgKdConnectionStatus)) {
        return FALSE;
    }

    if (DbgKdBreakRequested) {
        DbgKdBreakRequested = FALSE;
        return TRUE;
    }

    return KdPollBreakIn();
}

//
// This is not necessary at all, you can just type `.reload` into windbg
// and it will automatically read all the loaded modules, etc.
//
// But if you were to implement some form of module load hook, this will
// notify windbg that it has loaded. It can be nice for when you are breakpointing
// on the entry point of a module.
//
ULONG64 DbgKdpSymbol_ImageBase;
ULONG64 DbgKdpSymbol_ImageSize;
ULONG64 DbgKdpSymbol_ProcessId;
PCHAR   DbgKdpSymbol_ImageName;
BOOLEAN DbgKdpSymbol_Unload;

VOID
KAPI
DbgKdFrozenLoadSymbols(
    VOID
    )
{
    KdLoadSymbols(DbgKdQueryProcessorContext(KeGetPcr()->ProcessorNumber),
                  DbgKdpSymbol_ImageName,
                  DbgKdpSymbol_ImageBase,
                  (ULONG32)DbgKdpSymbol_ImageSize,
                  (ULONG32)DbgKdpSymbol_ProcessId,
                  (ULONG64)DbgKdpSymbol_Unload);
}

```

`example/Load.c`:

```c


//
// When the kernel loads, or whenever you are ready to load kd:
//
//        KdKernelBase       = KshShim_Ntoskrnl_ImageBase;
//        KdKernelSize       = (ULONG32)KshShim_Ntoskrnl_ImageSize;
//
//#if LIME_HV_ENABLE_NOKD
//        DbgKdInitStatus = KdDriverLoad();
//        if (K_SUCCESS(DbgKdInitStatus)) {
//            DBG_PRINT("KdDriverLoad success\n");
//
//            DbgKdConnectionStatus = KdTryConnect();
//            if (K_SUCCESS(DbgKdConnectionStatus)) {
//                DBG_PRINT("KdTryConnect success\n");
//            }
//        }
//#endif
```

`kdpl/comm/pci.c`:

```c

#include <kdpl.h>
#include <pci.h>

#define KeInPort8                   __inbyte
#define KeInPort16                  __inword
#define KeInPort32                  __indword
#define KeOutPort8                  __outbyte
#define KeOutPort16                 __outword
#define KeOutPort32                 __outdword

UCHAR
KdpPciRead08(
    _In_ ULONG32 BusId,
    _In_ ULONG32 DeviceId,
    _In_ ULONG32 FunctionId,
    _In_ ULONG32 Offset
    )
{
    KeOutPort32(PCI_CONFIG_ADDRESS, 
                PCI_GET_ADDRESS(BusId, 
                                DeviceId, 
                                FunctionId, 
                                Offset));
    return KeInPort8(PCI_CONFIG_DATA + (Offset & 3));
}

USHORT 
KdpPciRead16(
    _In_ ULONG32 BusId,
    _In_ ULONG32 DeviceId,
    _In_ ULONG32 FunctionId,
    _In_ ULONG32 Offset
    )
{
    KeOutPort32(PCI_CONFIG_ADDRESS, 
                PCI_GET_ADDRESS(BusId, 
                                DeviceId, 
                                FunctionId, 
                                Offset));
    return KeInPort16(PCI_CONFIG_DATA + (Offset & 2));
}

ULONG32
KdpPciRead32(
    _In_ ULONG32 BusId,
    _In_ ULONG32 DeviceId,
    _In_ ULONG32 FunctionId,
    _In_ ULONG32 Offset
    )
{
    KeOutPort32(PCI_CONFIG_ADDRESS, 
                PCI_GET_ADDRESS(BusId, 
                                DeviceId, 
                                FunctionId, 
                                Offset));
    return KeInPort32(PCI_CONFIG_DATA);
}

VOID
KdpPciWrite08(
    _In_ ULONG32 BusId,
    _In_ ULONG32 DeviceId,
    _In_ ULONG32 FunctionId,
    _In_ ULONG32 Offset,
    _In_ UCHAR Long
    )
{
    KeOutPort32(PCI_CONFIG_ADDRESS, 
                PCI_GET_ADDRESS(BusId, 
                                DeviceId, 
                                FunctionId, 
                                Offset));
    KeOutPort8(PCI_CONFIG_DATA + (Offset & 3), Long);
}

VOID
KdpPciWrite16(
    _In_ ULONG32 BusId,
    _In_ ULONG32 DeviceId,
    _In_ ULONG32 FunctionId,
    _In_ ULONG32 Offset,
    _In_ USHORT  Long
    )
{
    KeOutPort32(PCI_CONFIG_ADDRESS, 
                PCI_GET_ADDRESS(BusId, 
                                DeviceId, 
                                FunctionId, 
                                Offset));
    KeOutPort16(PCI_CONFIG_DATA + (Offset & 2), Long);
}

VOID
KdpPciWrite32(
    _In_ ULONG32 BusId,
    _In_ ULONG32 DeviceId,
    _In_ ULONG32 FunctionId,
    _In_ ULONG32 Offset,
    _In_ ULONG32 Long
    )
{
    KeOutPort32(PCI_CONFIG_ADDRESS, 
                PCI_GET_ADDRESS(BusId, 
                                DeviceId, 
                                FunctionId, 
                                Offset));
    KeOutPort32(PCI_CONFIG_DATA, Long);
}
```

`kdpl/comm/uart.c`:

```c

#include <kdpl.h>
#include <pci.h>

#define KeInPort8                   __inbyte
#define KeOutPort8                  __outbyte

#define IOCOM_THR 0 // Transmitter Holding Buffer
#define IOCOM_RBR 0 // Receiver Buffer

#define IOCOM_DLL 0 // Divisor Latch Low Byte
#define IOCOM_IER 1 // Interrupt Enable Register
#define IOCOM_DLH 1 // Divisor Latch High Byte
#define IOCOM_FCR 2 // FIFO Control Register
#define IOCOM_IIR 2 // Interrupt Identification Register
#define IOCOM_LCR 3 // Line Control Register
#define IOCOM_MCR 4 // Modem Control Register
#define IOCOM_LSR 5 // Line Status Register
#define IOCOM_MSR 6 // Modem Status Register
#define IOCOM_SR  7 // Scratch Register

#define IOCOM_LC_SBE (1 << 6) // Set Break Enable
#define IOCOM_LC_DLA (1 << 7) // Divisor Latch Access

#define IOCOM_LS_DR     (1 << 0)
#define IOCOM_LS_OE     (1 << 0)
#define IOCOM_LS_PE     (1 << 2)
#define IOCOM_LS_FE     (1 << 3)
#define IOCOM_LS_BI     (1 << 4)
#define IOCOM_LS_THRE   (1 << 5)
#define IOCOM_LS_TEMT   (1 << 6)
#define IOCOM_LS_ER_INP (1 << 7)

#define IOCOM_LC_DB_5 0
#define IOCOM_LC_DB_6 1
#define IOCOM_LC_DB_7 2
#define IOCOM_LC_DB_8 3

#define IOCOM_LC_SB_1 0
#define IOCOM_LC_SB_2 (1 << 2)

#define IOCOM_FC_64BYTE (1 << 5) // (16750) Enable 64 byte FIFO
#define IOCOM_FC_DMA    (1 << 3) // DMA mode select
#define IOCOM_FC_CT     (1 << 2) // Clear transmit
#define IOCOM_FC_CR     (1 << 1) // Clear receive
#define IOCOM_FC_EF     (1 << 0) // Enable FIFO

#define IOCOM_MC_AUTOFLOW (1 << 5) // (16750)
#define IOCOM_MC_LOOP     (1 << 4) // Loopback mode
#define IOCOM_MC_OUT2     (1 << 3) // Auxiliary Output 2
#define IOCOM_MC_OUT1     (1 << 2) // Auxiliary Output 1
#define IOCOM_MC_RTS      (1 << 1) // Request to send
#define IOCOM_MC_DTS      (1 << 0) // Data terminal ready (DTR, no??)

//
// Default port is 0x2F8 / COM1. 
//
USHORT  KdpUartPort = 0x2F8; 
//USHORT  KdpUartPort = 0x3F8; 
BOOLEAN KdpUartOpen = FALSE;

ULONG32 KdpUartBaudRate = 115200;

BOOLEAN
KdpUartSendReady(
    VOID
    )
{
    return (KeInPort8(KdpUartPort + IOCOM_LSR) & IOCOM_LS_THRE) == IOCOM_LS_THRE;
}

BOOLEAN
KdpUartReceiveReady(
    VOID
    )
{
    return (KeInPort8(KdpUartPort + IOCOM_LSR) & IOCOM_LS_DR) == IOCOM_LS_DR;
}

BOOLEAN
KdpUartSendChar(
    _In_ UCHAR Char
    )
{
    ULONG64 Timeout;

    Timeout = 2 * (40000000000ull / KdpUartBaudRate);

    while (Timeout > 0 && !KdpUartSendReady())
        Timeout--;

    if (Timeout == 0) {
        return FALSE;
    }

    KeOutPort8(KdpUartPort + IOCOM_THR, Char);
    return TRUE;
}

BOOLEAN
KdpUartReceiveChar(
    _Out_ PUCHAR Char
    )
{
    ULONG64 Timeout;

    Timeout = 2 * (40000000000ull / KdpUartBaudRate);

    while (Timeout > 0 && !KdpUartReceiveReady())
        Timeout--;

    if (Timeout == 0) {
        return FALSE;
    }

    *Char = KeInPort8(KdpUartPort + IOCOM_RBR);
    return TRUE;
}

BOOLEAN
KdpUartSendString(
    _In_ PUCHAR  Buffer,
    _In_ ULONG32 Length
    )
{
    ULONG32 Tries;

    Tries = 20;

    while (Length--) {

        while (Tries > 0 && !KdpUartSendChar(*Buffer)) {
            Tries--;
        }

        if (Tries == 0) {
            return FALSE;
        }

        Buffer += 1;
        Tries   = 20;
    }
    return TRUE;
}

BOOLEAN
KdpUartReceiveString(
    _In_ PUCHAR  Buffer,
    _In_ ULONG32 Length
    )
{
    ULONG32 Tries;

    Tries = 20;

    while (Length--) {

        while (Tries > 0 && !KdpUartReceiveChar(Buffer)) {
            Tries--;
        }

        if (Tries == 0) {
            return FALSE;
        }

        Buffer += 1;
        Tries   = 20;
    }
    return TRUE;
}

UCHAR       KdpUartPciBusId;
UCHAR       KdpUartPciDevId;
UCHAR       KdpUartPciFunId;
KPCI_DEVICE KdpUartPciDevice;

NTSTATUS
KdpUartLoadDriver(
    VOID
    )
{
    //
    // References: 
    // https://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming
    // https://www.latticesemi.com/-/media/LatticeSemi/Documents/ReferenceDesigns/SZ/UART16550Transceiver-Documentation.ashx?document_id=48168
    // https://www.nxp.com/docs/en/data-sheet/SC16C750B.pdf
    //

    UCHAR Lcr;
    UCHAR Mcr;
    UCHAR Msr;
    UCHAR Char;

    //
    // 7.10 SC16C750B defines the reset conditions.
    //

    if (FALSE) {
        ULONG32 Index;
        //
        // WCH382/CH382
        //
        KdpUartPciBusId = 4;
        KdpUartPciDevId = 0;
        KdpUartPciFunId = 0;

        for (Index = 0; Index < sizeof(KPCI_DEVICE); Index++) {
            ((UCHAR*)&KdpUartPciDevice)[Index] = KdpPciRead08(KdpUartPciBusId, 
                                                              KdpUartPciDevId,
                                                              KdpUartPciFunId,
                                                              Index);
        }

        //
        // Reset: 0
        // Write: PCI_CMD_MEMORY_SPACE, PCI_CMD_IO_SPACE, PCI_CMD_BUS_MASTER, PCI_CMD_INTERRUPT_DISABLE
        //
        KdpUartPciDevice.Header.Command &= ~(PCI_CMD_MEMORY_SPACE);
        KdpUartPciDevice.Header.Command |=  (PCI_CMD_IO_SPACE | PCI_CMD_BUS_MASTER | PCI_CMD_INTERRUPT_DISABLE);

        KdpPciWrite16(KdpUartPciBusId, 
                      KdpUartPciDevId,
                      KdpUartPciFunId,
                      FIELD_OFFSET(KPCI_DEVICE, Header.Command), 
                      KdpUartPciDevice.Header.Command);

        KdpUartPort = (USHORT)(KdpUartPciDevice.Common.Bar[0] & ~0x3) + 0xC0;
    }

    Mcr = KeInPort8(KdpUartPort + IOCOM_MCR);

    KeOutPort8(KdpUartPort + IOCOM_MCR, IOCOM_MC_LOOP);
    KeOutPort8(KdpUartPort + IOCOM_MCR, IOCOM_MC_LOOP);

    Msr = KeInPort8(KdpUartPort + IOCOM_MSR);

    if ((Msr & (0x10 | 0x20 | 0x40 | 0x80)) == 0) {
        
        KeOutPort8(KdpUartPort + IOCOM_MCR, IOCOM_MC_LOOP | IOCOM_MC_OUT1);

        Msr = KeInPort8(KdpUartPort + IOCOM_MSR);

        KeOutPort8(KdpUartPort + IOCOM_MCR, Mcr);

        if (Msr & 0x40) {
            KdpUartOpen = TRUE;
        }
        else {
            KdpUartOpen = FALSE;

            Char = 0;
            do {
                KeOutPort8(KdpUartPort + 0x14, Char);

                if (KeInPort8(KdpUartPort + 0x14) != Char) {
                    return STATUS_UNSUCCESSFUL;
                }
            } while (++Char != 0);

            KdpUartOpen = TRUE;
        }
    }

    //
    // Disable device interrupts.
    //
    KeOutPort8(KdpUartPort + IOCOM_LCR, 0);
    KeOutPort8(KdpUartPort + IOCOM_IER, 0);

    KeOutPort8(KdpUartPort + IOCOM_MCR, IOCOM_MC_RTS | IOCOM_MC_DTS | IOCOM_MC_OUT2);

    //
    // Set the Baud
    //
    Lcr = KeInPort8(KdpUartPort + IOCOM_LCR);

    KeOutPort8(KdpUartPort + IOCOM_LCR, Lcr | IOCOM_LC_DLA);
    KeOutPort8(KdpUartPort + IOCOM_DLL, 1);
    KeOutPort8(KdpUartPort + IOCOM_DLH, 0);
    KeOutPort8(KdpUartPort + IOCOM_LCR, Lcr);

    //
    // 8-bit word length.
    //
    KeOutPort8(KdpUartPort + IOCOM_LCR, 3);
    //
    // Clear & enable FIFO.
    //
    KeOutPort8(KdpUartPort + IOCOM_FCR, IOCOM_FC_EF | IOCOM_FC_CR | IOCOM_FC_CT);

    KeInPort8(KdpUartPort + IOCOM_RBR);

    return STATUS_SUCCESS;
}

ULONG32
KdpGetChecksum(
    _In_ PSTRING Contents
    )
{
    ULONG32 Index;
    ULONG32 Checksum;

    Checksum = 0;

    for (Index = 0; Index < Contents->Length; Index++) {

        Checksum += (UCHAR)Contents->Buffer[Index];
    }

    return Checksum;
}

VOID
KdpSendControlPacket(
    _In_ KD_PACKET_TYPE Type,
    _In_ ULONG32        PacketId
    );

KD_STATUS
KdUartRecvPacket(
    _In_    KD_PACKET_TYPE PacketType,
    _Inout_ PSTRING        Head,
    _Inout_ PSTRING        Body,
    _Out_   PULONG32       Length,
    _Inout_ PKD_CONTEXT    KdContext
    );

KD_STATUS
KdUartSendPacket(
    _In_     KD_PACKET_TYPE PacketType,
    _In_     PSTRING        Head,
    _In_opt_ PSTRING        Body,
    _Inout_  PKD_CONTEXT    KdContext
    );

NTSTATUS
KdUartConnect(
    VOID
    )
{
    KdDebugDevice.KdSendPacket = KdUartSendPacket;
    KdDebugDevice.KdReceivePacket = KdUartRecvPacket;

    return (NT_SUCCESS(KdpUartLoadDriver()) && KdpUartOpen) 
        ? STATUS_SUCCESS 
        : STATUS_CONNECTION_REFUSED;
}

ULONG32 KdCompPacketIdExpected   = 0x80800000;
ULONG32 KdCompNextPacketIdToSend = 0x80800800;
ULONG32 KdCompRetryCount         = 5;
ULONG32 KdCompNumberRetries;

KD_STATUS
KdUartSendPacket(
    _In_     KD_PACKET_TYPE PacketType,
    _In_     PSTRING        Head,
    _In_opt_ PSTRING        Body,
    _Inout_  PKD_CONTEXT    KdContext
    )
{
    KD_PACKET Packet;

    Packet.Checksum     = KdpGetChecksum(Head) + (ARGUMENT_PRESENT(Body) ? KdpGetChecksum(Body) : 0);
    Packet.PacketLeader = 0x30303030;
    Packet.PacketLength = Head->Length + (ARGUMENT_PRESENT(Body) ? Body->Length : 0);
    Packet.PacketType   = PacketType;

    Packet.PacketId     = KdCompNextPacketIdToSend;

    KdCompNumberRetries = KdCompRetryCount;

    do {
        KdpUartSendString((PVOID)&Packet, 16);
        KdpUartSendString((PVOID)Head->Buffer, Head->Length);
        if (ARGUMENT_PRESENT(Body)) {
            KdpUartSendString((PVOID)Body->Buffer, Body->Length);
        }
        KdpUartSendChar(0xAA);
        if (KdUartRecvPacket(KdTypeAcknowledge, 0, 0, 0, KdContext) == KdStatusTimeOut) {
            //KdCompNumberRetries--;
        }
        else {
            break;
        }
    } while (KdCompNumberRetries != 0);

    //KdCompRetryCount          = KdContext->RetryCount;
    KdCompNextPacketIdToSend &= ~0x800;

    return KdStatusSuccess;
}

KD_STATUS
KdUartRecvPacket(
    _In_    KD_PACKET_TYPE PacketType,
    _Inout_ PSTRING        Head,
    _Inout_ PSTRING        Body,
    _Out_   PULONG32       Length,
    _Inout_ PKD_CONTEXT    KdContext
    )
{
    Length;

    ULONG32   TimeOut;
    UCHAR     Buffer[4];
    UCHAR     Char;
    ULONG32   Index;
    KD_PACKET Packet;

    if (PacketType == KdTypeCheckQueue) {
        if (KdpUartReceiveReady() && KdpUartReceiveChar(&Char) && Char == 0x62) {
            return KdStatusSuccess;
        }
        return KdStatusTimeOut;
    }

    TimeOut = 1000000;
    Index   = 0;

    //
    // PacketLeader
    //
    do {

        //if (KdpUartReceiveReady()) {
        //    KdpUartReceiveChar(&Char);
        if (KdpUartReceiveChar(&Char)) {

            if (Char == 0x62) {
                KdContext->BreakRequested = 1;
                continue;
            }

            if (Char == 0x30 || Char == 0x69) {
                if (Index != 0 && Buffer[0] != Char) {
                    Index = 0;
                    continue;
                }
                
                Buffer[Index] = Char;
                Index++;
            }
            else {
                Index = 0;
            }
        }
        else {
            TimeOut--;
        }

    } while (Index < 4 && TimeOut > 0);

    if (TimeOut == 0) {
        return KdStatusTimeOut;
    }

    TimeOut = 1000000;

    if (Buffer[0] == 0x30) {
        Packet.PacketLeader = 0x30303030;
    }
    else {
        Packet.PacketLeader = 0x69696969;
    }

    KdCompNumberRetries = KdCompRetryCount;
    
    do {
        do {
            if (!KdpUartReceiveString((PVOID)&Packet.PacketType, 2)) {

                //KdpResend:
                //    if (Packet.PacketLeader == 0x69696969) {
                //        continue;
                //    }
                //    KdpSendControlPacket(KdTypeAcknowledge, 0);
                //    continue;

                return KdStatusTimeOut;
            }
            break;
        } while (FALSE);

        if (Packet.PacketLeader == 0x69696969 && Packet.PacketType == KdTypeResend) {
            return KdStatusResend;
        }

        if (!KdpUartReceiveString((PVOID)&Packet.PacketLength, 2)) {
            return KdStatusTimeOut;
        }

        if (!KdpUartReceiveString((PVOID)&Packet.PacketId, 4)) {
            return KdStatusTimeOut;
        }

        if (!KdpUartReceiveString((PVOID)&Packet.Checksum, 4)) {
            return KdStatusTimeOut;
        }

        if (Packet.PacketLeader != 0x69696969) {
            if (PacketType == KdTypeAcknowledge) {
                if (Packet.PacketId != KdCompPacketIdExpected) {
                    KdpSendControlPacket(KdTypeAcknowledge, Packet.PacketId);
                    continue;
                }
                KdpSendControlPacket(KdTypeResend, 0);
                KdCompNextPacketIdToSend ^= 1u;
            }
            else {

                if (!KdpUartReceiveString((PVOID)Head->Buffer, Head->MaximumLength)) {
                    // resend
                    return KdStatusTimeOut;
                }

                if (ARGUMENT_PRESENT(Body)) {
                    if (!KdpUartReceiveString((PVOID)Body->Buffer, Packet.PacketLength - Head->MaximumLength)) {
                        // resend
                        return KdStatusTimeOut;
                    }
                }

                if (!KdpUartReceiveString(&Char, 1)) {
                    return KdStatusTimeOut;
                }

                if (Char != 0xAA) {
                    // resend
                    return KdStatusTimeOut;
                }

                //
                // 1. Some PacketId shit i dont feel like writing
                // 2. Some Checksum checking, fuck no
                //

                KdpSendControlPacket(KdTypeAcknowledge, Packet.PacketId);
                KdCompPacketIdExpected ^= 1u;
            }
            return KdStatusSuccess;
        }
        switch (Packet.PacketType) {
        case KdTypeAcknowledge:
            if (Packet.PacketId != (KdCompNextPacketIdToSend & ~0x800u) || PacketType != KdTypeAcknowledge) {
                continue;
            }
            KdCompNextPacketIdToSend ^= 1u;
            return KdStatusSuccess;
        case KdTypeReset:
            KdCompNextPacketIdToSend = 0x80800000;
            KdCompPacketIdExpected = 0x80800000;
            KdpSendControlPacket(KdTypeReset, 0);
            break;
        case KdTypeResend:
            break;
        default:
            continue;
        }
        return KdStatusError;
    } while (TRUE);
}

VOID
KdpSendControlPacket(
    _In_ KD_PACKET_TYPE Type,
    _In_ ULONG32        PacketId
    )
{
    KD_PACKET Packet;

    Packet.PacketType = Type;
    Packet.PacketLeader = 0x69696969;
    Packet.PacketLength = 0;
    Packet.Checksum = 0;
    Packet.PacketId = PacketId;
    KdpUartSendString((PVOID)&Packet, 16);
}
```

`kdpl/comm/vmwrpc.c`:

```c

#include <kdpl.h>
#include <vmwrpc.h>

//
// TODO: MUST CALL KdVmwRpcRecvCommandFinish AFTER A FUNCTION
//       FAILURE, OTHERWISE NO NEW RPC DATA WILL BE DELIVERED
//       TO THE RESPECTIVE CHANNEL.
//

NTSTATUS
KdVmwRpcBufferedIoPrep(
    _In_ ULONG32 Length
);

NTSTATUS
KdVmwRpcBufferedIoSend(
    _In_ PVOID   Buffer,
    _In_ ULONG32 Length
);

NTSTATUS
KdVmwRpcBufferedIoDone(

);

static CHAR KdRpcCmdHead[ ] = "~kdVMvA ";
static CHAR KdRpcCmdRecp[ ] = "++kdVMvA ";

typedef enum _KD_RPC_CMD {
    KdRpcTestConnection = 't',
    KdRpcRecvPacket = 'r',
    KdRpcSendPacket = 's',
    KdRpcGetVersion = 'v'
} KD_RPC_CMD, *PKD_RPC_CMD;

#define KD_LS_NOT_PRESENT   0x01
#define KD_LS_RETRY         0x02
#define KD_LS_ENABLED_AVAIL 0x04

#define KD_RPC_RECV_RETURNED_ULONGS 5
#define KD_RPC_SEND_PASSED_ULONGS   4

//
// 0x101 is the VirtualKD version uploaded to github, but supporting
// the redux version is a larger concern, so i've upped it to 2020.2 and 
// start reading about their interface.
//

// 2020 << 16 | 2 => 2020.2
#define KD_RPC_PROTOCOL_VERSION     0x07E40002


#define KD_RPC_TEST_BUFFER_SIZE     512

//
// Sob, fuck you.
//
//C_ASSERT( FIELD_OFFSET( STRING, Buffer ) == 4 );

#pragma pack( push, 2 )

typedef struct _STRING_HEAD {
    USHORT Length;
    USHORT MaximumLength;
} STRING_HEAD, *PSTRING_HEAD;

C_ASSERT( FIELD_OFFSET( STRING, MaximumLength ) ==
          FIELD_OFFSET( STRING_HEAD, MaximumLength ) );
C_ASSERT( sizeof( STRING_HEAD ) == 4 );

#pragma pack( pop )
//C_ASSERT( sizeof( STRING_HEAD ) == FIELD_OFFSET( STRING, Buffer ) );

VOID
KdVmwRpcInitialize(

)
{
    KdDebugDevice.KdSendPacket = KdVmwRpcSendPacket;
    KdDebugDevice.KdReceivePacket = KdVmwRpcRecvPacket;
}

NTSTATUS
KdVmwRpcConnect(

)
{
    NTSTATUS ntStatus;

    ntStatus = KdVmwRpcOpenChannel( &KdDebugDevice.VmwRpc );

    if ( !NT_SUCCESS( ntStatus ) ) {

        return ntStatus;
    }

    return NT_SUCCESS( KdVmwRpcInitProtocol( ) ) ? KdVmwRpcTestConnection( ) : STATUS_UNSUCCESSFUL;
}

NTSTATUS
KdVmwRpcInitProtocol(

)
{
    //
    // Negotiate a protocol version,
    // 

    NTSTATUS ntStatus;
    CHAR     CommandType;
    ULONG32  Version;
    ULONG32  RecvLength;
    CHAR     Sig[ sizeof( KdRpcCmdRecp ) ];

    CommandType = KdRpcGetVersion;
    Version = KD_RPC_PROTOCOL_VERSION;

    KdVmwRpcBufferedIoPrep( sizeof( KdRpcCmdHead ) + sizeof( ULONG32 ) );

    KdVmwRpcBufferedIoSend( &KdRpcCmdHead, sizeof( KdRpcCmdHead ) - 1 );
    KdVmwRpcBufferedIoSend( &CommandType, 1 );
    KdVmwRpcBufferedIoSend( &Version, sizeof( ULONG32 ) );
    ntStatus = KdVmwRpcBufferedIoDone( );

    if ( !NT_SUCCESS( ntStatus ) ) {

        //DbgPrint( "KdVmwRpcInitProtocol failed on KdVmwRpcBufferedIoDone.\n" );
        return ntStatus;
    }

    KdVmwRpcRecvCommandLength( &KdDebugDevice.VmwRpc, &RecvLength );
    if ( RecvLength < sizeof( ULONG32 ) + sizeof( KdRpcCmdRecp ) - 1 + 2 ) {

        return STATUS_CONNECTION_REFUSED;
    }

    KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc, 2, Sig );

    if ( Sig[ 0 ] != '1' ||
         Sig[ 1 ] != ' ' ) {

        KdVmwRpcRecvCommandFinish( &KdDebugDevice.VmwRpc );
        return STATUS_CONNECTION_REFUSED;
    }

    KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc, sizeof( KdRpcCmdRecp ) - 1, Sig );

    if ( memcmp( Sig, KdRpcCmdRecp, sizeof( KdRpcCmdRecp ) - 1 ) != 0 ) {

        KdVmwRpcRecvCommandFinish( &KdDebugDevice.VmwRpc );
        return STATUS_CONNECTION_REFUSED;
    }

    KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc, sizeof( ULONG32 ), &Version );

    if ( Version != KD_RPC_PROTOCOL_VERSION ) {

        KdVmwRpcRecvCommandFinish( &KdDebugDevice.VmwRpc );
        return STATUS_PROTOCOL_NOT_SUPPORTED;
    }

    KdVmwRpcRecvCommandFinish( &KdDebugDevice.VmwRpc );
#if 0
    DbgPrint( "KdVmwRpcInitProtocol version negotiation successful, %d.%d\n",
              KD_RPC_PROTOCOL_VERSION >> 16,
              KD_RPC_PROTOCOL_VERSION & 0xFFFF );
#endif

    return STATUS_SUCCESS;
}

NTSTATUS
KdVmwRpcTestConnection(

)
{
    NTSTATUS ntStatus;
    CHAR     CommandType;
    UCHAR    Buffer[ KD_RPC_TEST_BUFFER_SIZE ];
    ULONG32  CurrentChar;
    ULONG32  RecvLength;

    CommandType = KdRpcTestConnection;

    for ( CurrentChar = 0;
          CurrentChar < KD_RPC_TEST_BUFFER_SIZE;
          CurrentChar++ ) {

        Buffer[ CurrentChar ] = ( UCHAR )CurrentChar;
    }

    KdVmwRpcBufferedIoPrep( KD_RPC_TEST_BUFFER_SIZE + sizeof( KdRpcCmdHead ) );

    KdVmwRpcBufferedIoSend( KdRpcCmdHead, sizeof( KdRpcCmdHead ) - 1 );
    KdVmwRpcBufferedIoSend( &CommandType, 1 );
    KdVmwRpcBufferedIoSend( Buffer, KD_RPC_TEST_BUFFER_SIZE );
    ntStatus = KdVmwRpcBufferedIoDone( );

    if ( !NT_SUCCESS( ntStatus ) ) {

        //DbgPrint( "KdVmwRpcTestConnection failed on KdVmwRpcBufferedIoDone.\n" );
        return ntStatus;
    }

    KdVmwRpcRecvCommandLength( &KdDebugDevice.VmwRpc, &RecvLength );
    if ( RecvLength <
         sizeof( KdRpcCmdRecp ) +
         KD_RPC_TEST_BUFFER_SIZE +
         2 - 1 ) {

        return STATUS_CONNECTION_REFUSED;
    }

    KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc, sizeof( KdRpcCmdRecp ) - 1 + 2, Buffer );

    if ( Buffer[ 0 ] != '1' &&
         Buffer[ 1 ] != ' ' ) {
        // virtualkd doesn't compare the expected space here, in their implementation

        KdVmwRpcRecvCommandFinish( &KdDebugDevice.VmwRpc );
        return STATUS_CONNECTION_REFUSED;
    }

    if ( memcmp( Buffer + 2, KdRpcCmdRecp, sizeof( KdRpcCmdRecp ) - 1 ) != 0 ) {

        KdVmwRpcRecvCommandFinish( &KdDebugDevice.VmwRpc );
        return STATUS_CONNECTION_REFUSED;
    }

    KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc, KD_RPC_TEST_BUFFER_SIZE, Buffer );
    KdVmwRpcRecvCommandFinish( &KdDebugDevice.VmwRpc );

    for ( CurrentChar = 0;
          CurrentChar < KD_RPC_TEST_BUFFER_SIZE;
          CurrentChar++ ) {

        if ( Buffer[ CurrentChar ] != ( UCHAR )( CurrentChar ^ 0x55 ) ) {

            return STATUS_CONNECTION_ABORTED;
        }
    }

    return STATUS_SUCCESS;
}

KD_STATUS
KdVmwRpcSendPacket(
    _In_     KD_PACKET_TYPE PacketType,
    _In_     PSTRING        Head,
    _In_opt_ PSTRING        Body,
    _Inout_  PKD_CONTEXT    KdContext
)
{
    KdContext;

    KD_CONTEXT KdContextDup = { 0 };

    NTSTATUS ntStatus;
    CHAR     CommandType;
    ULONG32  HeadLength;
    ULONG32  BodyLength;
    ULONG32  LocalState;
    CHAR     Sig[ sizeof( KdRpcCmdRecp ) ];
    ULONG32  ULongSend[ KD_RPC_SEND_PASSED_ULONGS ];
    STRING   Buffer = { 0 };
    ULONG32  RecvLength;

    if (PacketType != KdTypeStateManipulate) {
        //IoKdPrint("KdVmwRpcSendPacket: %d\n", PacketType);
    }
    else {
        //IoKdPrint("KdVmwRpcSendPacket: %d, Api:%lx\n", PacketType,   ((DBGKD_MANIPULATE_STATE64*)Head->Buffer)->ApiNumber);
    }

    HeadLength = Head != NULL ? Head->Length : 0;
    BodyLength = Body != NULL ? Body->Length : 0;
#if 0
    if ( PacketType != KdTypePrint &&
         KdDebuggerNotPresent_ ) {

        // attempt a KdRefreshDebuggerNotPresent
        KdPrint( "KDTARGET: Refreshing KD connection\n" );

        if ( KdDebuggerNotPresent_ ) {

            return KdStatusError;
        }
    }
#endif

    while ( TRUE ) {

        LocalState = KD_LS_ENABLED_AVAIL | 1 << 8;
        if ( KdDebuggerNotPresent_ ) {

            LocalState |= KD_LS_NOT_PRESENT;
        }

        ULongSend[ 0 ] = PacketType;
        ULongSend[ 1 ] = HeadLength;
        ULongSend[ 2 ] = BodyLength;
        ULongSend[ 3 ] = LocalState;

        CommandType = KdRpcSendPacket;

        KdVmwRpcBufferedIoPrep( sizeof( KdRpcCmdHead ) +
                                sizeof( ULONG32 ) * KD_RPC_SEND_PASSED_ULONGS +
                                2 * sizeof( STRING_HEAD ) +//FIELD_OFFSET( STRING, Buffer ) +
                                sizeof( KD_CONTEXT ) +
                                HeadLength + BodyLength );
        KdVmwRpcBufferedIoSend( KdRpcCmdHead, sizeof( KdRpcCmdHead ) - 1 );
        KdVmwRpcBufferedIoSend( &CommandType, 1 );
        KdVmwRpcBufferedIoSend( Head == NULL ? &Buffer : Head, sizeof( STRING_HEAD ) );//FIELD_OFFSET( STRING, Buffer ) );
        KdVmwRpcBufferedIoSend( Body == NULL ? &Buffer : Body, sizeof( STRING_HEAD ) );//FIELD_OFFSET( STRING, Buffer ) );
        KdVmwRpcBufferedIoSend( KdContext == NULL ? &KdContextDup : KdContext, sizeof( KD_CONTEXT ) );
        KdVmwRpcBufferedIoSend( ULongSend, sizeof( ULONG32 ) * KD_RPC_SEND_PASSED_ULONGS );

        if ( HeadLength != 0 ) {

            KdVmwRpcBufferedIoSend( Head->Buffer, HeadLength );
        }

        if ( BodyLength != 0 ) {

            KdVmwRpcBufferedIoSend( Body->Buffer, BodyLength );
        }

        ntStatus = KdVmwRpcBufferedIoDone( );

        if ( !NT_SUCCESS( ntStatus ) ) {

            //DbgPrint( "KdVmwRpcSendPacket failed on KdVmwRpcBufferedIoDone.\n" );
            return KdStatusError;
        }

        KdVmwRpcRecvCommandLength( &KdDebugDevice.VmwRpc, &RecvLength );

        if ( RecvLength <
             sizeof( KdRpcCmdRecp ) +
             2 + sizeof( KD_CONTEXT ) +
             sizeof( ULONG ) ) {

            //DbgPrint( "KdVmwRpcSendPacket invalid reply size: %d\n", RecvLength );

            KdVmwRpcRecvCommandFinish( &KdDebugDevice.VmwRpc );
            return KdStatusError;
        }

        KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc, 2, Sig );

        if ( Sig[ 0 ] != '1' ||
             Sig[ 1 ] != ' ' ) {

            KdVmwRpcRecvCommandFinish( &KdDebugDevice.VmwRpc );
            return KdStatusError;
        }

        KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc, sizeof( KdRpcCmdRecp ) - 1, Sig );
        KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc, 1, &CommandType );

        if ( memcmp( Sig, KdRpcCmdRecp, sizeof( KdRpcCmdRecp ) - 1 ) != 0 ||
             CommandType != KdRpcSendPacket ) {

            KdVmwRpcRecvCommandFinish( &KdDebugDevice.VmwRpc );
            return KdStatusError;
        }

        KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc,
                                   sizeof( KD_CONTEXT ),
                                   KdContext == NULL ? &KdContextDup : KdContext );

        KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc, sizeof( ULONG32 ), &LocalState );
        KdVmwRpcRecvCommandFinish( &KdDebugDevice.VmwRpc );

        KdDebuggerNotPresent_ = ( LocalState & KD_LS_NOT_PRESENT ) != 0;
        if ( LocalState & KD_LS_ENABLED_AVAIL ) {

            // Care.
        }

        if ( LocalState & KD_LS_RETRY ) {

            continue;
        }

        break;
    }

    return KdStatusSuccess;
}

KD_STATUS
KdVmwRpcRecvPacket(
    _In_    KD_PACKET_TYPE PacketType,
    _Inout_ PSTRING        Head,
    _Inout_ PSTRING        Body,
    _Out_   PULONG32       Length,
    _Inout_ PKD_CONTEXT    KdContext
)
{
    KdContext;

    //
    //! DO NOT RELY ON THE LENGTH PARAMETER
    //! USE (Head/Body)->Length INSTEAD!
    //

    //
    // Having individual handlers for packet recv & send apis
    // is because of VirtualKD, this implements a different
    // protocol, somewhat, because everything goes through their
    // host program, which forwards packets to dbgeng.dll
    //

    //if (PacketType != KdTypeCheckQueue)
        //IoKdPrint("KdVmwRpcRecvPacket: %d\n", PacketType);


    C_ASSERT( sizeof( KD_PACKET_TYPE ) == sizeof( ULONG32 ) );

    KD_CONTEXT KdContextDup = { 0 };

    NTSTATUS ntStatus;
    CHAR     CommandType;
    ULONG32  LocalState;
    ULONG32  RecvLength;
    ULONG32  RecvLengthMinimum;
    STRING   Buffer = { 0 };
    CHAR     Sig[ sizeof( KdRpcCmdRecp ) ];
    ULONG32  ULongRecv[ KD_RPC_RECV_RETURNED_ULONGS ];

    CommandType = KdRpcRecvPacket;

    LocalState = KD_LS_ENABLED_AVAIL | 1 << 8;
    if ( KdDebuggerNotPresent_ ) {

        LocalState |= KD_LS_NOT_PRESENT;
    }

    KdVmwRpcBufferedIoPrep( sizeof( KdRpcCmdHead ) +
                            2 * sizeof( STRING_HEAD ) +//FIELD_OFFSET( STRING, Buffer ) +
                            2 * sizeof( ULONG32 ) +
                            sizeof( KD_CONTEXT ) );
    KdVmwRpcBufferedIoSend( KdRpcCmdHead, sizeof( KdRpcCmdHead ) - 1 );
    KdVmwRpcBufferedIoSend( &CommandType, 1 );
    KdVmwRpcBufferedIoSend( &PacketType, sizeof( ULONG32 ) );
    KdVmwRpcBufferedIoSend( &LocalState, sizeof( ULONG32 ) );
    KdVmwRpcBufferedIoSend( Head == NULL ? &Buffer : Head, sizeof( STRING_HEAD ) );//FIELD_OFFSET( STRING, Buffer ) );
    KdVmwRpcBufferedIoSend( Body == NULL ? &Buffer : Body, sizeof( STRING_HEAD ) );//FIELD_OFFSET( STRING, Buffer ) );
    KdVmwRpcBufferedIoSend( KdContext == NULL ? &KdContextDup : KdContext, sizeof( KD_CONTEXT ) );
    ntStatus = KdVmwRpcBufferedIoDone( );

    if ( !NT_SUCCESS( ntStatus ) ) {

        //DbgPrint( "KdVmwRpcRecvPacket failed on KdVmwRpcBufferedIoDone.\n" );
        return ntStatus;
    }

    KdVmwRpcRecvCommandLength( &KdDebugDevice.VmwRpc, &RecvLength );

    RecvLengthMinimum = sizeof( KdRpcCmdRecp ) +
        2 * sizeof( STRING_HEAD ) +//FIELD_OFFSET( STRING, Buffer ) +
        sizeof( KD_CONTEXT ) +
        sizeof( ULONG32 ) * KD_RPC_RECV_RETURNED_ULONGS +
        2;

    if ( RecvLength < RecvLengthMinimum ) {

        //DbgPrint( "KdVmwRpcRecvPacket failed, has: %d, min: %d\n", RecvLength, RecvLengthMinimum );
        return KdStatusError;
    }

    KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc, 2, &Sig );

    if ( Sig[ 0 ] != '1' &&
         Sig[ 1 ] != ' ' ) {

        //DbgPrint( "KdVmwRpcRecvPacket failed, no sig %d\n", RecvLength );
        KdVmwRpcRecvCommandFinish( &KdDebugDevice.VmwRpc );
        return KdStatusError;
    }

    KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc,
                               sizeof( KdRpcCmdRecp ) - 1,
                               Sig );
    KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc,
                               1,
                               &CommandType );
    if ( memcmp( Sig, KdRpcCmdRecp, sizeof( KdRpcCmdRecp ) - 1 ) != 0 ||
         CommandType != KdRpcRecvPacket ) {

        //DbgPrint( "KdVmwRpcRecvPacket failed, bad recp sig\n" );
        KdVmwRpcRecvCommandFinish( &KdDebugDevice.VmwRpc );
        return KdStatusError;
    }

    KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc,
                               sizeof( STRING_HEAD ),//FIELD_OFFSET( STRING, Buffer ),
                               Head == NULL ? &Buffer : Head );
    KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc,
                               sizeof( STRING_HEAD ),//FIELD_OFFSET( STRING, Buffer ),
                               Body == NULL ? &Buffer : Body );

    KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc,
                               sizeof( KD_CONTEXT ),
                               KdContext == NULL ? &KdContextDup : KdContext );

    KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc,
                               sizeof( ULONG32 ) * KD_RPC_RECV_RETURNED_ULONGS,
                               ULongRecv );

    if ( Head != NULL ) {

        //DbgPrint( "Head->Length: %d => %d\n", Head->Length, ULongRecv[ 2 ] );
    }

    if ( Body != NULL ) {

        //DbgPrint( "Body->Length: %d => %d\n", Body->Length, ULongRecv[ 3 ] );
    }

    //
    // TODO: Range check on ULongRecv[2, 3] against KdTransportMaxPacketSize.
    //
    // TODO: Potentially adjust all RecvLength checks. (<, !=)
    //

    //DbgPrint( "ULongRecv: %d %d\n", ULongRecv[ 2 ], ULongRecv[ 3 ] );

    if ( RecvLength !=
         sizeof( KdRpcCmdRecp ) +
         ULongRecv[ 2 ] +
         ULongRecv[ 3 ] +
         2 * sizeof( STRING_HEAD ) +//FIELD_OFFSET( STRING, Buffer ) +
         sizeof( KD_CONTEXT ) +
         sizeof( ULONG32 ) * KD_RPC_RECV_RETURNED_ULONGS + 2 ) {

        KdVmwRpcRecvCommandFinish( &KdDebugDevice.VmwRpc );
        //DbgPrint( "KdVmwRpcRecvPacket failed2, has: %d, min: %d\n", RecvLength, RecvLengthMinimum );
        return KdStatusError;
    }

    if ( Head != NULL ) {

        //DbgPrint( "Head->MaximumLength: %d => %d\n", Head->MaximumLength, ULongRecv[ 2 ] );
    }

    if ( Body != NULL ) {

        //DbgPrint( "Body->MaximumLength: %d => %d\n", Body->MaximumLength, ULongRecv[ 3 ] );
    }

    //
    // Surprised code actually reaches this point, RecvLength has had inconsistent
    // and invalid values for a while.
    //

    if ( Head != NULL && Head->MaximumLength >= ULongRecv[ 2 ] && ULongRecv[ 2 ] > 0 ) {

        KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc,
                                   ULongRecv[ 2 ],
                                   Head->Buffer );
    }

    if ( Body != NULL && Body->MaximumLength >= ULongRecv[ 3 ] && ULongRecv[ 3 ] > 0 ) {

        KdVmwRpcRecvCommandBuffer( &KdDebugDevice.VmwRpc,
                                   ULongRecv[ 3 ],
                                   Body->Buffer );
    }

    //
    // ULongRecv[ 1 ] is seemingly invalid, perhaps 
    // *Length = ULongRecv[ 2 ] + ULongRecv[ 3 ] + sizeof(...)
    // and manually calculate this size.
    //

    if ( Length != NULL ) {

        *Length = ULongRecv[ 1 ];
    }

    LocalState = ULongRecv[ 4 ];

    KdDebuggerNotPresent_ = ( LocalState & KD_LS_NOT_PRESENT ) != 0;

    if ( LocalState & KD_LS_ENABLED_AVAIL ) {

        // Care.
    }

    KdVmwRpcRecvCommandFinish( &KdDebugDevice.VmwRpc );

    //DbgPrint( "done! ULongRecv->Result=%d\n", ULongRecv[ 0 ] );

    return ( KD_STATUS )ULongRecv[ 0 ];
}

//
// No need for any synchronization.
//
static ULONG32 KdpVmwRpcBufferedIoLength;
static ULONG32 KdpVmwRpcBufferedIoIndex;
static UCHAR   KdpVmwRpcBufferedIoBuffer[ 0x1000 ];

NTSTATUS
KdVmwRpcBufferedIoPrep(
    _In_ ULONG32 Length
)
{
    if ( Length > 0x1000 ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KdpVmwRpcBufferedIoLength = Length;
    KdpVmwRpcBufferedIoIndex = 0;
    RtlZeroMemory( KdpVmwRpcBufferedIoBuffer, 0x1000 );

    return STATUS_SUCCESS;
}

NTSTATUS
KdVmwRpcBufferedIoSend(
    _In_ PVOID   Buffer,
    _In_ ULONG32 Length
)
{

    if ( Length > KdpVmwRpcBufferedIoIndex + KdpVmwRpcBufferedIoLength ) {

        return STATUS_INVALID_BUFFER_SIZE;
    }

    RtlCopyMemory( KdpVmwRpcBufferedIoBuffer + KdpVmwRpcBufferedIoIndex,
                   Buffer,
                   Length );
    KdpVmwRpcBufferedIoIndex += Length;

    if ( KdpVmwRpcBufferedIoIndex >= KdpVmwRpcBufferedIoLength ) {

        //DbgPrint( "KdVmwRpcBufferedIoDone privately called.\n" );
        //KdVmwRpcBufferedIoDone( );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
KdVmwRpcBufferedIoDone(

)
{
    if (KdpVmwRpcBufferedIoLength < KdpVmwRpcBufferedIoIndex) {
        //KdPrint("Len: %d, Idx: %d N: %d\n", KdpVmwRpcBufferedIoLength, KdpVmwRpcBufferedIoIndex, KeGetCurrentProcessorNumber());
        NT_ASSERT(KdpVmwRpcBufferedIoLength >= KdpVmwRpcBufferedIoIndex);
    }

    KdVmwRpcSendCommandLength( &KdDebugDevice.VmwRpc,
                               KdpVmwRpcBufferedIoLength );
    KdVmwRpcSendCommandBuffer( &KdDebugDevice.VmwRpc,
                               KdpVmwRpcBufferedIoLength,
                               KdpVmwRpcBufferedIoBuffer );

    return STATUS_SUCCESS;
}

```

`kdpl/comm/vmwrpc64.asm`:

```asm

.CODE

;
; Resources: 
; - https://github.com/sysprogs/VirtualKD/blob/master/kdvm/vmwrpc64.asm
; - https://web.archive.org/web/20100610223425/http://chitchat.at.infoseek.co.jp:80/vmware/backdoor.html#cmd1e_hb_7
; Also it seems vmware cares about the state of some registers so the code is
; very weird and awkward. I had initially started reversing their replacement
; kdcom.dll until I realised it is public source, I'm only interested in their 
; vmware rpc, at the time of writing this, serial ports are not working at all
; on my vmware setup.
;

STATUS_UNSUCCESSFUL            = 0C0000001h

VMWARE_MAGIC                   = 564D5868h  ; 'VMXh'
VMWARE_IO_PORT                 = 5658h      ; 'VX'

VMWARE_CMD_RPC                 = 1Eh
VMWARE_MAGIC_RPC               = 0C9435052h ; 'RPCI' | 80000000h

VMWRPC_CMD_OPEN_CHANNEL        = 0000h
VMWRPC_CMD_SEND_COMMAND_LENGTH = 0001h 
VMWRPC_CMD_SEND_COMMAND_BUFFER = 0
VMWRPC_CMD_RECV_COMMAND_LENGTH = 0003h
VMWRPC_CMD_RECV_COMMAND_BUFFER = 0
VMWRPC_CMD_RECV_COMMAND_FINISH = 0005h
VMWRPC_CMD_CLOSE_CHANNEL       = 0006h

PUBLIC      KdVmwRpcOpenChannel
PUBLIC      KdVmwRpcCloseChannel
PUBLIC      KdVmwRpcSendCommandLength
PUBLIC      KdVmwRpcSendCommandBuffer
PUBLIC      KdVmwRpcSendFull
PUBLIC      KdVmwRpcRecvCommandLength
PUBLIC      KdVmwRpcRecvCommandBuffer
PUBLIC      KdVmwRpcRecvCommandFinish

KD_VMWRPC_CONTROL STRUCT 8
	Cookie1    dd 0
	Cookie2    dd 0
	Channel    dd 0
	RecvId     dd 0
KD_VMWRPC_CONTROL ENDS 

ALIGN       16
KdVmwRpcOpenChannel PROC FRAME

    push    rbx
.PUSHREG    rbx
    push    rsi
.PUSHREG    rsi
    push    rdi
.PUSHREG    rdi
.ENDPROLOG

    mov     eax, VMWARE_MAGIC
    mov     ebx, VMWARE_MAGIC_RPC
    mov     r8, rcx
    mov     ecx, VMWARE_CMD_RPC or (VMWRPC_CMD_OPEN_CHANNEL shl 16) ;1Eh
    mov     edx, VMWARE_IO_PORT
    out     dx, eax
    cmp     ecx, 10000h
    jne     @KdpVmwRpcExcp
    mov     dword ptr [r8+KD_VMWRPC_CONTROL.Cookie1], esi
    mov     dword ptr [r8+KD_VMWRPC_CONTROL.Cookie2], edi
    mov     dword ptr [r8+KD_VMWRPC_CONTROL.Channel], edx
    xor     rax, rax
    jmp     @KdpVmwRcpRetn

@KdpVmwRpcExcp:
    mov     rax, STATUS_UNSUCCESSFUL
@KdpVmwRcpRetn:
    pop     rdi
    pop     rsi
    pop     rbx
    ret

KdVmwRpcOpenChannel ENDP

ALIGN       16
KdVmwRpcCloseChannel PROC FRAME

    push    rsi
.PUSHREG    rsi
    push    rdi
.PUSHREG    rdi
.ENDPROLOG

    mov     eax, VMWARE_MAGIC
    mov     edx, [rcx+KD_VMWRPC_CONTROL.Channel]
    or      edx, VMWARE_IO_PORT
    mov     esi, [rcx+KD_VMWRPC_CONTROL.Cookie1]
    mov     edi, [rcx+KD_VMWRPC_CONTROL.Cookie2]
    mov     ecx, VMWARE_CMD_RPC or (VMWRPC_CMD_CLOSE_CHANNEL shl 16) ;6001Eh
    out     dx, eax
    xor     eax, eax
    cmp     ecx, 10000h
    je      @KdpVmwRpcRetn
    mov     eax, STATUS_UNSUCCESSFUL
@KdpVmwRpcRetn:
    pop     rdi
    pop     rsi
    ret

KdVmwRpcCloseChannel ENDP

ALIGN       16
KdVmwRpcSendCommandLength PROC FRAME

    push    rbx
.PUSHREG    rbx
    push    rsi
.PUSHREG    rsi
    push    rdi
.PUSHREG    rdi
.ENDPROLOG

    mov     eax, VMWARE_MAGIC
    mov     ebx, edx
    mov     edx, dword ptr [rcx+KD_VMWRPC_CONTROL.Channel]
    or      edx, VMWARE_IO_PORT
    mov     esi, dword ptr [rcx+KD_VMWRPC_CONTROL.Cookie1]
    mov     edi, dword ptr [rcx+KD_VMWRPC_CONTROL.Cookie2]
    mov     ecx, VMWARE_CMD_RPC or (VMWRPC_CMD_SEND_COMMAND_LENGTH shl 16); 1001Eh
    out     dx, eax
    xor     eax, eax
    cmp     ecx, 810000h
    je      @KdpVmwRpcRetn
    mov     eax, STATUS_UNSUCCESSFUL
@KdpVmwRpcRetn:
    pop     rdi
    pop     rsi
    pop     rbx
    ret

KdVmwRpcSendCommandLength ENDP

ALIGN       16
KdVmwRpcSendCommandBuffer PROC FRAME

    push    rbx
.PUSHREG    rbx
    push    rsi
.PUSHREG    rsi
    push    rdi
.PUSHREG    rdi
    push    rbp
.PUSHREG    rbp
.ENDPROLOG

    mov     eax, VMWARE_MAGIC
    xchg    rcx, rdx
    mov     ebx, 10000h
    mov     rsi, r8
    mov     ebp, dword ptr [rdx+KD_VMWRPC_CONTROL.Cookie1]
    mov     edi, dword ptr [rdx+KD_VMWRPC_CONTROL.Cookie2]
    mov     edx, dword ptr [rdx+KD_VMWRPC_CONTROL.Channel]
    or      edx, VMWARE_IO_PORT + 1
    cld
    rep     outsb
    xor     eax, eax
    cmp     ebx, 10000h
    je      @KdpVmwRpcRetn
    mov     eax, STATUS_UNSUCCESSFUL
@KdpVmwRpcRetn:
    pop     rbp
    pop     rdi
    pop     rsi
    pop     rbx
    ret

KdVmwRpcSendCommandBuffer ENDP

; i dont think this is correct.
ALIGN       16
KdVmwRpcSendFull PROC FRAME

    push    rbx
.PUSHREG    rbx
    push    rsi
.PUSHREG    rsi
    push    rdi
.PUSHREG    rdi
    push    rbp
.PUSHREG    rbp
.ENDPROLOG

    mov     eax, VMWARE_MAGIC
    mov     ebx, edx
    mov     edx, dword ptr [rcx+KD_VMWRPC_CONTROL.Channel]
    or      edx, VMWARE_IO_PORT + 1
    mov     esi, dword ptr [rcx+KD_VMWRPC_CONTROL.Cookie1]
    mov     edi, dword ptr [rcx+KD_VMWRPC_CONTROL.Cookie2]
    mov     r9, rcx
    mov     ecx, 1001Eh
    out     dx, eax
    cmp     ecx, 810000h
    jne     @KdpVmwRpcExcp
    xchg    ecx, ebx
    mov     ebx, 10000h
    mov     rsi, r8
    mov     edx, dword ptr [rcx+KD_VMWRPC_CONTROL.Channel]
    or      edx, 'VX'
    mov     ebp, dword ptr [rcx+KD_VMWRPC_CONTROL.Cookie1]
    mov     edi, dword ptr [rcx+KD_VMWRPC_CONTROL.Cookie2]
    rep     outsb
    xor     eax, eax
    cmp     ebx, 10000h
    jne     @KdpVmwRpcExcp
    jmp     @KdpVmwRpcRetn
@KdpVmwRpcExcp:
    mov     eax, 0C0000001h
@KdpVmwRpcRetn:
    pop     rbp
    pop     rdi
    pop     rsi
    pop     rbx
    ret

KdVmwRpcSendFull ENDP

ALIGN       16
KdVmwRpcRecvCommandLength PROC FRAME

    push    rbx
.PUSHREG    rbx
    push    rsi
.PUSHREG    rsi
    push    rdi
.PUSHREG    rdi
.ENDPROLOG

    mov     r9, rdx
    mov     eax, VMWARE_MAGIC
    mov     edx, dword ptr [rcx+KD_VMWRPC_CONTROL.Channel]
    or      edx, VMWARE_IO_PORT
    mov     esi, dword ptr [rcx+KD_VMWRPC_CONTROL.Cookie1]
    mov     edi, dword ptr [rcx+KD_VMWRPC_CONTROL.Cookie2]
    mov     r8, rcx
    mov     ecx, VMWARE_CMD_RPC or (VMWRPC_CMD_RECV_COMMAND_LENGTH shl 16) ;3001Eh
    out     dx, eax
    mov     dword ptr [r8+KD_VMWRPC_CONTROL.RecvId], edx
    mov     dword ptr [r9], ebx
    xor     eax, eax
    ;
    ; ecx is different on my vmware version 
    ; or something, this value no longer indicates
    ; success and has been causing issues.
    ; assume success.
    ;
    ;cmp     ecx, 830000h
    ;je      @KdpVmwRpcRetn
    ;mov     eax, STATUS_UNSUCCESSFUL
@KdpVmwRpcRetn:
    pop     rdi
    pop     rsi
    pop     rbx
    ret

KdVmwRpcRecvCommandLength ENDP

ALIGN       16
KdVmwRpcRecvCommandBuffer PROC FRAME

    push    rbx
.PUSHREG    rbx
    push    rsi
.PUSHREG    rsi
    push    rdi
.PUSHREG    rdi
    push    rbp
.PUSHREG    rbp
.ENDPROLOG

    mov     eax, VMWARE_MAGIC
    xchg    rcx, rdx
    mov     rdi, r8
    mov     esi, dword ptr [rdx+KD_VMWRPC_CONTROL.Cookie1]
    mov     ebp, dword ptr [rdx+KD_VMWRPC_CONTROL.Cookie2]
    mov     edx, dword ptr [rdx+KD_VMWRPC_CONTROL.Channel]
    or      edx, VMWARE_IO_PORT + 1
    mov     ebx, 10000h
    rep     insb
    xor     eax, eax
    cmp     ebx, 10000h
    je      @KdpVmwRpcRetn
    mov     eax, STATUS_UNSUCCESSFUL
@KdpVmwRpcRetn:
    pop     rbp
    pop     rdi
    pop     rsi
    pop     rbx
    ret

KdVmwRpcRecvCommandBuffer ENDP

ALIGN       16
KdVmwRpcRecvCommandFinish PROC FRAME

    push    rbx
.PUSHREG    rbx
    push    rsi
.PUSHREG    rsi
    push    rdi
.PUSHREG    rdi
.ENDPROLOG

    mov     eax, VMWARE_MAGIC
    mov     ebx, dword ptr [rcx+KD_VMWRPC_CONTROL.RecvId]
    mov     esi, dword ptr [rcx+KD_VMWRPC_CONTROL.Cookie1]
    mov     edi, dword ptr [rcx+KD_VMWRPC_CONTROL.Cookie2]
    mov     edx, dword ptr [rcx+KD_VMWRPC_CONTROL.Channel]
    or      edx, VMWARE_IO_PORT
    mov     ecx, VMWARE_CMD_RPC or (VMWRPC_CMD_RECV_COMMAND_FINISH shl 16); 5001Eh
    out     dx, eax
    xor     eax, eax
    cmp     ecx, 10000h
    je      @KdpVmwRpcRetn
    mov     eax, STATUS_UNSUCCESSFUL
@KdpVmwRpcRetn:
    pop     rdi
    pop     rsi
    pop     rbx
    ret

KdVmwRpcRecvCommandFinish ENDP

END
```

`kdpl/inc/dbgkd.h`:

```h

#pragma once

// ty good share pdb ^^
/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'ntoskrnl.exe'
*/

#define ALIGN( x ) __declspec( align( x ) )
#define ALIGN_PTR( x ) 

#pragma pack( push, 4 )

/* 1400 */
typedef struct ALIGN( 8 ) _DBGKD_LOAD_SYMBOLS64
{
    ULONG32 PathNameLength;
    ULONG32 Padding0;
    ULONG64 BaseOfDll;
    ULONG64 ProcessId;
    ULONG32 CheckSum;
    ULONG32 SizeOfImage;
    UCHAR   UnloadSymbols;
} ALIGN( 8 ) DBGKD_LOAD_SYMBOLS64, *PDBGKD_LOAD_SYMBOLS64;

C_ASSERT( FIELD_OFFSET( DBGKD_LOAD_SYMBOLS64, BaseOfDll ) == 8 );
C_ASSERT( FIELD_OFFSET( DBGKD_LOAD_SYMBOLS64, UnloadSymbols ) == 0x20 );
C_ASSERT( sizeof( DBGKD_LOAD_SYMBOLS64 ) == 0x28 );

/* 1401 */
typedef struct ALIGN( 4 ) _DBGKD_LOAD_SYMBOLS32
{
    ULONG32 PathNameLength;
    ULONG32 BaseOfDll;
    ULONG32 ProcessId;
    ULONG32 CheckSum;
    ULONG32 SizeOfImage;
    UCHAR   UnloadSymbols;
} ALIGN( 4 ) DBGKD_LOAD_SYMBOLS32, *ALIGN_PTR( 4 ) PDBGKD_LOAD_SYMBOLS32;

/* 1402 */
typedef struct _DBGKD_READ_MEMORY64
{
    ULONG64 TargetBaseAddress;
    ULONG32 TransferCount;
    ULONG32 ActualBytesRead;
} DBGKD_READ_MEMORY64, *PDBGKD_READ_MEMORY64;

/* 1403 */
typedef struct _DBGKD_READ_MEMORY32
{
    ULONG32 TargetBaseAddress;
    ULONG32 TransferCount;
    ULONG32 ActualBytesRead;
} DBGKD_READ_MEMORY32, *PDBGKD_READ_MEMORY32;

/* 1404 */
typedef struct _DBGKD_WRITE_MEMORY64
{
    ULONG64 TargetBaseAddress;
    ULONG32 TransferCount;
    ULONG32 ActualBytesWritten;
} DBGKD_WRITE_MEMORY64, *PDBGKD_WRITE_MEMORY64;

/* 1405 */
typedef struct _DBGKD_WRITE_MEMORY32
{
    ULONG32 TargetBaseAddress;
    ULONG32 TransferCount;
    ULONG32 ActualBytesWritten;
} DBGKD_WRITE_MEMORY32, *PDBGKD_WRITE_MEMORY32;

/* 1406 */
typedef struct ALIGN( 8 ) _DBGKD_WRITE_BREAKPOINT64
{
    ULONG64 BreakPointAddress;
    ULONG32 BreakPointHandle;
} ALIGN( 8 ) DBGKD_WRITE_BREAKPOINT64, *ALIGN_PTR( 8 ) PDBGKD_WRITE_BREAKPOINT64;

/* 1407 */
typedef struct _DBGKD_WRITE_BREAKPOINT32
{
    ULONG32 BreakPointAddress;
    ULONG32 BreakPointHandle;
} DBGKD_WRITE_BREAKPOINT32, *PDBGKD_WRITE_BREAKPOINT32;

/* 1408 */
typedef struct _DBGKD_READ_WRITE_IO64
{
    ULONG64 IoAddress;
    ULONG32 DataSize;
    ULONG32 DataValue;
} DBGKD_READ_WRITE_IO64, *PDBGKD_READ_WRITE_IO64;

/* 1409 */
typedef struct _DBGKD_READ_WRITE_IO32
{
    ULONG32 DataSize;
    ULONG32 IoAddress;
    ULONG32 DataValue;
} DBGKD_READ_WRITE_IO32, *PDBGKD_READ_WRITE_IO32;

/* 1410 */
typedef struct ALIGN( 8 ) _DBGKD_READ_WRITE_IO_EXTENDED64
{
    ULONG32 DataSize;
    ULONG32 InterfaceType;
    ULONG32 BusNumber;
    ULONG32 AddressSpace;
    ULONG64 IoAddress;
    ULONG32 DataValue;
} ALIGN( 8 ) DBGKD_READ_WRITE_IO_EXTENDED64, *ALIGN_PTR( 8 ) PDBGKD_READ_WRITE_IO_EXTENDED64;

/* 1411 */
typedef struct _DBGKD_READ_WRITE_IO_EXTENDED32
{
    ULONG32 DataSize;
    ULONG32 InterfaceType;
    ULONG32 BusNumber;
    ULONG32 AddressSpace;
    ULONG32 IoAddress;
    ULONG32 DataValue;
} DBGKD_READ_WRITE_IO_EXTENDED32, *PDBGKD_READ_WRITE_IO_EXTENDED32;

/* 1412 */
typedef struct _DBGKD_SET_SPECIAL_CALL32
{
    ULONG32 SpecialCall;
} DBGKD_SET_SPECIAL_CALL32, *PDBGKD_SET_SPECIAL_CALL32;

/* 1413 */
typedef struct _DBGKD_SET_SPECIAL_CALL64
{
    ULONG64 SpecialCall;
} DBGKD_SET_SPECIAL_CALL64, *PDBGKD_SET_SPECIAL_CALL64;

/* 1414 */
typedef struct _DBGKD_SET_INTERNAL_BREAKPOINT32
{
    ULONG32 BreakpointAddress;
    ULONG32 Flags;
} DBGKD_SET_INTERNAL_BREAKPOINT32, *PDBGKD_SET_INTERNAL_BREAKPOINT32;

/* 1415 */
typedef struct ALIGN( 8 ) _DBGKD_SET_INTERNAL_BREAKPOINT64
{
    ULONG64 BreakpointAddress;
    ULONG32 Flags;
} DBGKD_SET_INTERNAL_BREAKPOINT64, *PDBGKD_SET_INTERNAL_BREAKPOINT64;

/* 1416 */
typedef struct _DBGKD_GET_INTERNAL_BREAKPOINT64
{
    ULONG64 BreakpointAddress;
    ULONG32 Flags;
    ULONG32 Calls;
    ULONG32 MaxCallsPerPeriod;
    ULONG32 MinInstructions;
    ULONG32 MaxInstructions;
    ULONG32 TotalInstructions;
} DBGKD_GET_INTERNAL_BREAKPOINT64, *PDBGKD_GET_INTERNAL_BREAKPOINT64;

/* 1417 */
typedef struct _DBGKD_GET_INTERNAL_BREAKPOINT32
{
    ULONG32 BreakpointAddress;
    ULONG32 Flags;
    ULONG32 Calls;
    ULONG32 MaxCallsPerPeriod;
    ULONG32 MinInstructions;
    ULONG32 MaxInstructions;
    ULONG32 TotalInstructions;
} DBGKD_GET_INTERNAL_BREAKPOINT32, *PDBGKD_GET_INTERNAL_BREAKPOINT32;

/* 1418 */
typedef struct _DBGKD_GET_CONTEXT
{
    ULONG32 Unused;
} DBGKD_GET_CONTEXT, *PDBGKD_GET_CONTEXT;

/* 1419 */
typedef struct _DBGKD_SET_CONTEXT
{
    ULONG32 ContextFlags;
} DBGKD_SET_CONTEXT, *PDBGKD_SET_CONTEXT;

/* 1420 */
typedef struct _DBGKD_RESTORE_BREAKPOINT
{
    ULONG32 BreakPointHandle;
} DBGKD_RESTORE_BREAKPOINT, *PDBGKD_RESTORE_BREAKPOINT;

/* 1421 */
typedef struct _DBGKD_CONTINUE
{
    int ContinueStatus;
} DBGKD_CONTINUE, *PDBGKD_CONTINUE;

/* 1422 */
typedef struct __declspec( align( 4 ) ) _AMD64_DBGKD_CONTROL_SET
{
    ULONG32 TraceFlag;
    ULONG64 Dr7;
    ULONG64 CurrentSymbolStart;
    ULONG64 CurrentSymbolEnd;
} AMD64_DBGKD_CONTROL_SET, *PAMD64_DBGKD_CONTROL_SET;

/* 1423 */
typedef struct _X86_DBGKD_CONTROL_SET
{
    ULONG32 TraceFlag;
    ULONG32 Dr7;
    ULONG32 CurrentSymbolStart;
    ULONG32 CurrentSymbolEnd;
} X86_DBGKD_CONTROL_SET, *PX86_DBGKD_CONTROL_SET;

/* 1424 */
typedef struct ALIGN( 4 ) _IA64_DBGKD_CONTROL_SET
{
    ULONG32 Continue;
    ULONG64 CurrentSymbolStart;
    ULONG64 CurrentSymbolEnd;
} ALIGN( 4 ) IA64_DBGKD_CONTROL_SET, *ALIGN_PTR( 4 ) PIA64_DBGKD_CONTROL_SET;

/* 1425 */
typedef struct _ARM_DBGKD_CONTROL_SET
{
    ULONG32 Continue;
    ULONG32 CurrentSymbolStart;
    ULONG32 CurrentSymbolEnd;
} ARM_DBGKD_CONTROL_SET, *PARM_DBGKD_CONTROL_SET;

/* 1426 */
typedef struct _ARM64_DBGKD_CONTROL_SET
{
    ULONG32 Continue;
    ULONG32 TraceFlag;
    ULONG64 CurrentSymbolStart;
    ULONG64 CurrentSymbolEnd;
} ARM64_DBGKD_CONTROL_SET, *PARM64_DBGKD_CONTROL_SET;

/* 1427 */
typedef struct _ARMCE_DBGKD_CONTROL_SET
{
    ULONG32 Continue;
    ULONG32 CurrentSymbolStart;
    ULONG32 CurrentSymbolEnd;
} ARMCE_DBGKD_CONTROL_SET, *PARMCE_DBGKD_CONTROL_SET;

/* 1428 */
typedef struct _PPC_DBGKD_CONTROL_SET
{
    ULONG32 Continue;
    ULONG32 CurrentSymbolStart;
    ULONG32 CurrentSymbolEnd;
} PPC_DBGKD_CONTROL_SET, *PPPC_DBGKD_CONTROL_SET;

/* 1430 */
typedef struct _DBGKD_ANY_CONTROL_SET
{
    union ALIGN( 4 )
    {
        X86_DBGKD_CONTROL_SET X86ControlSet;
        ULONG32 AlphaControlSet;
        IA64_DBGKD_CONTROL_SET IA64ControlSet;
        AMD64_DBGKD_CONTROL_SET Amd64ControlSet;
        ARM_DBGKD_CONTROL_SET ArmControlSet;
        ARM64_DBGKD_CONTROL_SET Arm64ControlSet;
        ARMCE_DBGKD_CONTROL_SET ArmCeControlSet;
        PPC_DBGKD_CONTROL_SET PpcControlSet;
    };
} DBGKD_ANY_CONTROL_SET, *PDBGKD_ANY_CONTROL_SET;

/* 1432 */
typedef struct _DBGKD_CONTINUE2
{
    int ContinueStatus;
    union
    {
        AMD64_DBGKD_CONTROL_SET ControlSet;
        DBGKD_ANY_CONTROL_SET AnyControlSet;
    };
} DBGKD_CONTINUE2, *PDBGKD_CONTINUE2;

/* 1433 */
typedef struct _DBGKD_QUERY_SPECIAL_CALLS
{
    ULONG32 NumberOfSpecialCalls;
} DBGKD_QUERY_SPECIAL_CALLS, *PDBGKD_QUERY_SPECIAL_CALLS;

#if 0 // winh
/* 1434 */
typedef struct _DBGKD_GET_VERSION64
{
    USHORT MajorVersion;
    USHORT MinorVersion;
    UCHAR   ProtocolVersion;
    UCHAR   KdSecondaryVersion;
    USHORT Flags;
    USHORT MachineType;
    UCHAR   MaxPacketType;
    UCHAR   MaxStateChange;
    UCHAR   MaxManipulate;
    UCHAR   Simulation;
    USHORT Unused[ 1 ];
    ULONG64 KernBase;
    ULONG64 PsLoadedModuleList;
    ULONG64 DebuggerDataList;
} DBGKD_GET_VERSION64, *PDBGKD_GET_VERSION64;

#else
typedef struct _DBGKD_GET_VERSION64 {
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    UCHAR   ProtocolVersion;
    UCHAR   KdSecondaryVersion; // Cannot be 'A' for compat with dump header
    USHORT  Flags;
    USHORT  MachineType;

    //
    // Protocol command support descriptions.
    // These allow the debugger to automatically
    // adapt to different levels of command support
    // in different kernels.
    //

    // One beyond highest packet type understood, zero based.
    UCHAR   MaxPacketType;
    // One beyond highest state change understood, zero based.
    UCHAR   MaxStateChange;
    // One beyond highest state manipulate message understood, zero based.
    UCHAR   MaxManipulate;

    // Kind of execution environment the kernel is running in,
    // such as a real machine or a simulator.  Written back
    // by the simulation if one exists.
    UCHAR   Simulation;

    USHORT  Unused[ 1 ];

    ULONG64 KernBase;
    ULONG64 PsLoadedModuleList;

    //
    // Components may register a debug data block for use by
    // debugger extensions.  This is the address of the list head.
    //
    // There will always be an entry for the debugger.
    //

    ULONG64 DebuggerDataList;

} DBGKD_GET_VERSION64, *PDBGKD_GET_VERSION64;
#endif

/* 1435 */
typedef struct _DBGKD_BREAKPOINTEX
{
    ULONG32 BreakPointCount;
    int ContinueStatus;
} DBGKD_BREAKPOINTEX, *PDBGKD_BREAKPOINTEX;

/* 1436 */
typedef struct _DBGKD_READ_WRITE_MSR
{
    ULONG32 Msr;
    ULONG32 DataValueLow;
    ULONG32 DataValueHigh;
} DBGKD_READ_WRITE_MSR, *PDBGKD_READ_WRITE_MSR;


/* 1438 */
typedef struct ALIGN( 8 ) _DBGKD_SEARCH_MEMORY
{
    union
    {
        ULONG64 SearchAddress;
        ULONG64 FoundAddress;
    };
    ULONG64 SearchLength;
    ULONG32 PatternLength;
} ALIGN( 8 ) DBGKD_SEARCH_MEMORY, *ALIGN_PTR( 8 ) PDBGKD_SEARCH_MEMORY;

/* 1439 */
typedef struct _DBGKD_GET_SET_BUS_DATA
{
    ULONG32 BusDataType;
    ULONG32 BusNumber;
    ULONG32 SlotNumber;
    ULONG32 Offset;
    ULONG32 Length;
} DBGKD_GET_SET_BUS_DATA, *PDBGKD_GET_SET_BUS_DATA;

/* 1440 */
typedef struct _DBGKD_FILL_MEMORY
{
    ULONG64 Address;
    ULONG32 Length;
    USHORT Flags;
    USHORT PatternLength;
} DBGKD_FILL_MEMORY, *PDBGKD_FILL_MEMORY;

/* 1441 */
typedef struct _DBGKD_QUERY_MEMORY
{
    ULONG64 Address;
    ULONG64 Reserved;
    ULONG32 AddressSpace;
    ULONG32 Flags;
} DBGKD_QUERY_MEMORY, *PDBGKD_QUERY_MEMORY;

C_ASSERT( FIELD_OFFSET( DBGKD_QUERY_MEMORY, Flags ) == 0x14 );
C_ASSERT( FIELD_OFFSET( DBGKD_QUERY_MEMORY, AddressSpace ) == 0x10 );

/* 1442 */
typedef struct _DBGKD_SWITCH_PARTITION
{
    ULONG32 Partition;
} DBGKD_SWITCH_PARTITION, *PDBGKD_SWITCH_PARTITION;

/* 1443 */
typedef struct _DBGKD_CONTEXT_EX
{
    ULONG32 Offset;
    ULONG32 ByteCount;
    ULONG32 BytesCopied;
} DBGKD_CONTEXT_EX, *PDBGKD_CONTEXT_EX;

/* 1444 */
typedef struct ALIGN( 4 ) _DBGKD_WRITE_CUSTOM_BREAKPOINT
{
    ULONG64 BreakPointAddress;
    ULONG64 BreakPointInstruction;
    ULONG32 BreakPointHandle;
    UCHAR   BreakPointInstructionSize;
    UCHAR   BreakPointInstructionAlignment;
} ALIGN( 4 ) DBGKD_WRITE_CUSTOM_BREAKPOINT, *ALIGN_PTR( 4 ) PDBGKD_WRITE_CUSTOM_BREAKPOINT;

/* 1445 */
typedef struct ALIGN( 8 ) _DBGKD_MANIPULATE_STATE64
{
    ULONG32 ApiNumber;
    USHORT ProcessorLevel;
    USHORT Processor;
    int ReturnStatus;
    union
    {
        DBGKD_READ_MEMORY64 ReadMemory;
        DBGKD_WRITE_MEMORY64 WriteMemory;
        DBGKD_GET_CONTEXT GetContext;
        DBGKD_SET_CONTEXT SetContext;
        DBGKD_WRITE_BREAKPOINT64 WriteBreakPoint;
        DBGKD_RESTORE_BREAKPOINT RestoreBreakPoint;
        DBGKD_CONTINUE Continue;
        DBGKD_CONTINUE2 Continue2;
        DBGKD_READ_WRITE_IO64 ReadWriteIo;
        DBGKD_READ_WRITE_IO_EXTENDED64 ReadWriteIoExtended;
        DBGKD_QUERY_SPECIAL_CALLS QuerySpecialCalls;
        DBGKD_SET_SPECIAL_CALL64 SetSpecialCall;
        DBGKD_SET_INTERNAL_BREAKPOINT64 SetInternalBreakpoint;
        DBGKD_GET_INTERNAL_BREAKPOINT64 GetInternalBreakpoint;
        DBGKD_GET_VERSION64 GetVersion64;
        DBGKD_BREAKPOINTEX BreakPointEx;
        DBGKD_READ_WRITE_MSR ReadWriteMsr;
        DBGKD_SEARCH_MEMORY SearchMemory;
        DBGKD_GET_SET_BUS_DATA GetSetBusData;
        DBGKD_FILL_MEMORY FillMemory;
        DBGKD_QUERY_MEMORY QueryMemory;
        DBGKD_SWITCH_PARTITION SwitchPartition;
        DBGKD_CONTEXT_EX GetContextEx;
        DBGKD_CONTEXT_EX SetContextEx;
        DBGKD_WRITE_CUSTOM_BREAKPOINT WriteCustomBreakPoint;
    } u;
} ALIGN( 8 ) DBGKD_MANIPULATE_STATE64, *ALIGN_PTR( 8 ) PDBGKD_MANIPULATE_STATE64;

C_ASSERT( sizeof( DBGKD_MANIPULATE_STATE64 ) == 0x38 );

/* 1446 */
typedef struct _DBGKD_GET_VERSION32
{
    USHORT MajorVersion;
    USHORT MinorVersion;
    USHORT ProtocolVersion;
    USHORT Flags;
    ULONG32 KernBase;
    ULONG32 PsLoadedModuleList;
    USHORT MachineType;
    USHORT ThCallbackStack;
    USHORT NextCallback;
    USHORT FramePointer;
    ULONG32 KiCallUserMode;
    ULONG32 KeUserCallbackDispatcher;
    ULONG32 BreakpointWithStatus;
    ULONG32 DebuggerDataList;
} DBGKD_GET_VERSION32, *PDBGKD_GET_VERSION32;

/* 1447 */
typedef struct _DBGKD_MANIPULATE_STATE32
{
    ULONG32 ApiNumber;
    USHORT ProcessorLevel;
    USHORT Processor;
    int ReturnStatus;
    union
    {
        DBGKD_READ_MEMORY32 ReadMemory;
        DBGKD_WRITE_MEMORY32 WriteMemory;
        DBGKD_READ_MEMORY64 ReadMemory64;
        DBGKD_WRITE_MEMORY64 WriteMemory64;
        DBGKD_GET_CONTEXT GetContext;
        DBGKD_SET_CONTEXT SetContext;
        DBGKD_WRITE_BREAKPOINT32 WriteBreakPoint;
        DBGKD_RESTORE_BREAKPOINT RestoreBreakPoint;
        DBGKD_CONTINUE Continue;
        DBGKD_CONTINUE2 Continue2;
        DBGKD_READ_WRITE_IO32 ReadWriteIo;
        DBGKD_READ_WRITE_IO_EXTENDED32 ReadWriteIoExtended;
        DBGKD_QUERY_SPECIAL_CALLS QuerySpecialCalls;
        DBGKD_SET_SPECIAL_CALL32 SetSpecialCall;
        DBGKD_SET_INTERNAL_BREAKPOINT32 SetInternalBreakpoint;
        DBGKD_GET_INTERNAL_BREAKPOINT32 GetInternalBreakpoint;
        DBGKD_GET_VERSION32 GetVersion32;
        DBGKD_BREAKPOINTEX BreakPointEx;
        DBGKD_READ_WRITE_MSR ReadWriteMsr;
        DBGKD_SEARCH_MEMORY SearchMemory;
        DBGKD_CONTEXT_EX GetContextEx;
        DBGKD_CONTEXT_EX SetContextEx;
    } u;
} ALIGN( 4 ) DBGKD_MANIPULATE_STATE32, *ALIGN_PTR( 4 ) PDBGKD_MANIPULATE_STATE32;

typedef struct ALIGN( 8 ) _DBGKM_EXCEPTION64 {
    EXCEPTION_RECORD64 ExceptionRecord;
    ULONG32 FirstChance;
} ALIGN( 8 ) DBGKM_EXCEPTION64, *ALIGN_PTR( 8 ) PDBGKM_EXCEPTION64;

#pragma pack( pop )

//
// non ida shit.
//

#if 0
#define KdApiReadMemory 0x3130
#define KdApiWriteMemory 0x3131
#define KdApiGetContext 0x3132
#define KdApiSetContext 0x3133
#define KdApiWriteBreakPoint 0x3134
#define KdApiRestoreBreakPoint 0x3135
#define KdApiContinue 0x3136
#define KdApiReadControlSpace 0x3137
#define KdApiWriteControlSpace 0x3138
#define KdApiReadIoSpace 0x3139
#define KdApiWriteIoSpace 0x313A
#define KdApiReboot 0x313B
#define KdApiContinueStateChange 0x313C
#define KdApiReadPhysicalMemory 0x313D
#define KdApiWritePhysicalMemory 0x313E
#endif

#if 1
//
// Managed to find these definitions and thank you sir.
//

#define DbgKdMinimumManipulate              0x00003130L

#define DbgKdReadVirtualMemoryApi           0x00003130L
#define DbgKdWriteVirtualMemoryApi          0x00003131L
#define DbgKdGetContextApi                  0x00003132L
#define DbgKdSetContextApi                  0x00003133L
#define DbgKdWriteBreakPointApi             0x00003134L
#define DbgKdRestoreBreakPointApi           0x00003135L
#define DbgKdContinueApi                    0x00003136L
#define DbgKdReadControlSpaceApi            0x00003137L
#define DbgKdWriteControlSpaceApi           0x00003138L
#define DbgKdReadIoSpaceApi                 0x00003139L
#define DbgKdWriteIoSpaceApi                0x0000313AL
#define DbgKdRebootApi                      0x0000313BL
#define DbgKdContinueApi2                   0x0000313CL
#define DbgKdReadPhysicalMemoryApi          0x0000313DL
#define DbgKdWritePhysicalMemoryApi         0x0000313EL
#define DbgKdQuerySpecialCallsApi           0x0000313FL
#define DbgKdSetSpecialCallApi              0x00003140L
#define DbgKdClearSpecialCallsApi           0x00003141L
#define DbgKdSetInternalBreakPointApi       0x00003142L
#define DbgKdGetInternalBreakPointApi       0x00003143L
#define DbgKdReadIoSpaceExtendedApi         0x00003144L
#define DbgKdWriteIoSpaceExtendedApi        0x00003145L
#define DbgKdGetVersionApi                  0x00003146L
#define DbgKdWriteBreakPointExApi           0x00003147L
#define DbgKdRestoreBreakPointExApi         0x00003148L
#define DbgKdCauseBugCheckApi               0x00003149L
#define DbgKdSwitchProcessor                0x00003150L
#define DbgKdPageInApi                      0x00003151L // obsolete
#define DbgKdReadMachineSpecificRegister    0x00003152L
#define DbgKdWriteMachineSpecificRegister   0x00003153L
#define OldVlm1                             0x00003154L
#define OldVlm2                             0x00003155L
#define DbgKdSearchMemoryApi                0x00003156L
#define DbgKdGetBusDataApi                  0x00003157L
#define DbgKdSetBusDataApi                  0x00003158L
#define DbgKdCheckLowMemoryApi              0x00003159L
#define DbgKdClearAllInternalBreakpointsApi 0x0000315AL
#define DbgKdFillMemoryApi                  0x0000315BL
#define DbgKdQueryMemoryApi                 0x0000315CL
#define DbgKdSwitchPartition                0x0000315DL

#define DbgKdGetContextEx                   0x0000315FL
#define DbgKdSetContextEx                   0x00003160L
#define DbgKdWriteCustomBreakpointEx        0x00003161L
#define DbgKdReadPhysicalMemoryLong         0x00003162L

#define DbgKdMaximumManipulate              0x00003163L

//
// There is another one for reading physical memory, with run length encoding
// however, I won't be implementing that and I'm yet to see a debugger call it.
//

#endif

#if 0
typedef enum _KD_API_NUMBER {
    KdApiReadMemory = 0x3130,
    KdApiWriteMemory,
    KdApiGetContext,
    KdApiSetContext,
    KdApiWriteBreakPoint,
    KdApiRestoreBreakPoint,
    KdApiContinue,
    KdApiReadControlSpace,
    KdApiWriteControlSpace,
    KdApiReadIoSpace,
    KdApiWriteIoSpace,
    KdApiReboot,
    KdApiContinueStateChange,
    KdApiReadPhysicalMemory,
    KdApiWritePhysicalMemory,

    KdApiReadIoSpace2 = 0x3144,
    KdApiWriteIoSpace2,
    KdApiGetVersion,
    KdApiWriteBreakPointEx,
    KdApiRestoreBreakPointEx,
    KdApiManualCrash,
    KdApiSwitchProcessor,
    KdApi_Unk0, // always returns STATUS_UNSUCCESSFUL.
    KdApiReadMsr,
    KdApiWriteMsr,
    KdApiSearchMemory,
    KdApiReadBusData,
    KdApiWriteBusData,

    KdApi_Unk_PhysicalRange,

    KdApiFillMemory = 0x315B,
    KdApiQueryMemory,
    KdApiGetContextEx = 0x315F,
    KdApiSetContextEx,
    KdApiWriteCustomBreakPoint,
    KdApiReadPhysicalMemoryRLE,
} KD_API_NUMBER, *PKD_API_NUMBER;

#endif

typedef struct _DBGKD_CONTROL_REPORT {
    ULONG64 Dr6;
    ULONG64 Dr7;
    ULONG   EFlags;
    USHORT  InstructionCount;
    USHORT  ReportFlags;
    UCHAR   InstructionStream[ 16 ];
    USHORT  SegCs;
    USHORT  SegDs;
    USHORT  SegEs;
    USHORT  SegFs;
} DBGKD_CONTROL_REPORT, *PDBGKD_CONTROL_REPORT;

typedef struct _DBGKD_PRINT_STRING {
    ULONG32 ApiNumber;
    USHORT  ProcessorLevel;
    USHORT  Processor;
    ULONG32 Length;
    ULONG32 Pad0;
} DBGKD_PRINT_STRING, *PDBGKD_PRINT_STRING;

C_ASSERT( sizeof( DBGKD_PRINT_STRING ) == 0x10 );

typedef struct _DBGKD_WAIT_STATE_CHANGE {
    ULONG32 ApiNumber;
    USHORT  ProcessorLevel;
    USHORT  Processor;
    ULONG32 ProcessorCount;
    ULONG64 CurrentThread;
    ULONG64 ProgramCounter;

    union {
        DBGKD_LOAD_SYMBOLS64 LoadSymbols;
        DBGKM_EXCEPTION64 Exception;
        char Pad[ 208 ];
        // there is another type in this union for
        // command strings, and maybe more i missed
        // inside KdTrap
    } u;
    DBGKD_CONTROL_REPORT ControlReport;
} DBGKD_WAIT_STATE_CHANGE, *PDBGKD_WAIT_STATE_CHANGE;

C_ASSERT( FIELD_OFFSET( DBGKD_WAIT_STATE_CHANGE, CurrentThread ) == 16 );

#define KD_LEADER_BREAK_IN      0x62626262
#define KD_LEADER_BREAK_IN_BYTE 0x62
#define KD_LEADER_PACKET        0x30303030
#define KD_LEADER_PACKET_BYTE   0x30
#define KD_LEADER_CONTROL       0x69696969
#define KD_LEADER_CONTROL_BYTE  0x69

#define KD_PACKET_ID_RESET      0x80800000

typedef enum _ADDRESS_SPACE {
    UserSpace    = 0,
    SessionSpace = 1,
    SystemSpace  = 2,
} ADDRESS_SPACE;

typedef struct _KD_SYMBOL_INFO {
    ULONG64 BaseAddress;
    ULONG64 ProcessId;
    ULONG32 CheckSum;
    ULONG32 SizeOfImage;
} KD_SYMBOL_INFO, *PKD_SYMBOL_INFO;

//
// WDBGEXTS.H
//

typedef struct _DBGKD_DEBUG_DATA_HEADER64 {

    //
    // Link to other blocks
    //

    LIST_ENTRY64 List;

    //
    // This is a unique tag to identify the owner of the block.
    // If your component only uses one pool tag, use it for this, too.
    //

    ULONG           OwnerTag;

    //
    // This must be initialized to the size of the data block,
    // including this structure.
    //

    ULONG           Size;

} DBGKD_DEBUG_DATA_HEADER64, *PDBGKD_DEBUG_DATA_HEADER64;

typedef struct _KDDEBUGGER_DATA64 {

    DBGKD_DEBUG_DATA_HEADER64 Header;

    //
    // Base address of kernel image
    //

    ULONG64   KernBase;

    //
    // DbgBreakPointWithStatus is a function which takes an argument
    // and hits a breakpoint.  This field contains the address of the
    // breakpoint instruction.  When the debugger sees a breakpoint
    // at this address, it may retrieve the argument from the first
    // argument register, or on x86 the eax register.
    //

    ULONG64   BreakpointWithStatus;       // address of breakpoint

    //
    // Address of the saved context record during a bugcheck
    //
    // N.B. This is an automatic in KeBugcheckEx's frame, and
    // is only valid after a bugcheck.
    //

    ULONG64   SavedContext;

    //
    // help for walking stacks with user callbacks:
    //

    //
    // The address of the thread structure is provided in the
    // WAIT_STATE_CHANGE packet.  This is the offset from the base of
    // the thread structure to the pointer to the kernel stack frame
    // for the currently active usermode callback.
    //

    USHORT  ThCallbackStack;            // offset in thread data

    //
    // these values are offsets into that frame:
    //

    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer

    //
    // pad to a quad boundary
    //
    USHORT  PaeEnabled : 1;

    //
    // Address of the kernel callout routine.
    //

    ULONG64   KiCallUserMode;             // kernel routine

    //
    // Address of the usermode entry point for callbacks.
    //

    ULONG64   KeUserCallbackDispatcher;   // address in ntdll


    //
    // Addresses of various kernel data structures and lists
    // that are of interest to the kernel debugger.
    //

    ULONG64   PsLoadedModuleList;
    ULONG64   PsActiveProcessHead;
    ULONG64   PspCidTable;

    ULONG64   ExpSystemResourcesList;
    ULONG64   ExpPagedPoolDescriptor;
    ULONG64   ExpNumberOfPagedPools;

    ULONG64   KeTimeIncrement;
    ULONG64   KeBugCheckCallbackListHead;
    ULONG64   KiBugcheckData;

    ULONG64   IopErrorLogListHead;

    ULONG64   ObpRootDirectoryObject;
    ULONG64   ObpTypeObjectType;

    ULONG64   MmSystemCacheStart;
    ULONG64   MmSystemCacheEnd;
    ULONG64   MmSystemCacheWs;

    ULONG64   MmPfnDatabase;
    ULONG64   MmSystemPtesStart;
    ULONG64   MmSystemPtesEnd;
    ULONG64   MmSubsectionBase;
    ULONG64   MmNumberOfPagingFiles;

    ULONG64   MmLowestPhysicalPage;
    ULONG64   MmHighestPhysicalPage;
    ULONG64   MmNumberOfPhysicalPages;

    ULONG64   MmMaximumNonPagedPoolInBytes;
    ULONG64   MmNonPagedSystemStart;
    ULONG64   MmNonPagedPoolStart;
    ULONG64   MmNonPagedPoolEnd;

    ULONG64   MmPagedPoolStart;
    ULONG64   MmPagedPoolEnd;
    ULONG64   MmPagedPoolInformation;
    ULONG64   MmPageSize;

    ULONG64   MmSizeOfPagedPoolInBytes;

    ULONG64   MmTotalCommitLimit;
    ULONG64   MmTotalCommittedPages;
    ULONG64   MmSharedCommit;
    ULONG64   MmDriverCommit;
    ULONG64   MmProcessCommit;
    ULONG64   MmPagedPoolCommit;
    ULONG64   MmExtendedCommit;

    ULONG64   MmZeroedPageListHead;
    ULONG64   MmFreePageListHead;
    ULONG64   MmStandbyPageListHead;
    ULONG64   MmModifiedPageListHead;
    ULONG64   MmModifiedNoWritePageListHead;
    ULONG64   MmAvailablePages;
    ULONG64   MmResidentAvailablePages;

    ULONG64   PoolTrackTable;
    ULONG64   NonPagedPoolDescriptor;

    ULONG64   MmHighestUserAddress;
    ULONG64   MmSystemRangeStart;
    ULONG64   MmUserProbeAddress;

    ULONG64   KdPrintCircularBuffer;
    ULONG64   KdPrintCircularBufferEnd;
    ULONG64   KdPrintWritePointer;
    ULONG64   KdPrintRolloverCount;

    ULONG64   MmLoadedUserImageList;

    // NT 5.1 Addition

    ULONG64   NtBuildLab;
    ULONG64   KiNormalSystemCall;

    // NT 5.0 hotfix addition

    ULONG64   KiProcessorBlock;
    ULONG64   MmUnloadedDrivers;
    ULONG64   MmLastUnloadedDriver;
    ULONG64   MmTriageActionTaken;
    ULONG64   MmSpecialPoolTag;
    ULONG64   KernelVerifier;
    ULONG64   MmVerifierData;
    ULONG64   MmAllocatedNonPagedPool;
    ULONG64   MmPeakCommitment;
    ULONG64   MmTotalCommitLimitMaximum;
    ULONG64   CmNtCSDVersion;

    // NT 5.1 Addition

    ULONG64   MmPhysicalMemoryBlock;
    ULONG64   MmSessionBase;
    ULONG64   MmSessionSize;
    ULONG64   MmSystemParentTablePage;

    // Server 2003 addition

    ULONG64   MmVirtualTranslationBase;

    USHORT    OffsetKThreadNextProcessor;
    USHORT    OffsetKThreadTeb;
    USHORT    OffsetKThreadKernelStack;
    USHORT    OffsetKThreadInitialStack;

    USHORT    OffsetKThreadApcProcess;
    USHORT    OffsetKThreadState;
    USHORT    OffsetKThreadBStore;
    USHORT    OffsetKThreadBStoreLimit;

    USHORT    SizeEProcess;
    USHORT    OffsetEprocessPeb;
    USHORT    OffsetEprocessParentCID;
    USHORT    OffsetEprocessDirectoryTableBase;

    USHORT    SizePrcb;
    USHORT    OffsetPrcbDpcRoutine;
    USHORT    OffsetPrcbCurrentThread;
    USHORT    OffsetPrcbMhz;

    USHORT    OffsetPrcbCpuType;
    USHORT    OffsetPrcbVendorString;
    USHORT    OffsetPrcbProcStateContext;
    USHORT    OffsetPrcbNumber;

    USHORT    SizeEThread;

    ULONG64   KdPrintCircularBufferPtr;
    ULONG64   KdPrintBufferSize;

    ULONG64   KeLoaderBlock;

    USHORT    SizePcr;
    USHORT    OffsetPcrSelfPcr;
    USHORT    OffsetPcrCurrentPrcb;
    USHORT    OffsetPcrContainedPrcb;

    USHORT    OffsetPcrInitialBStore;
    USHORT    OffsetPcrBStoreLimit;
    USHORT    OffsetPcrInitialStack;
    USHORT    OffsetPcrStackLimit;

    USHORT    OffsetPrcbPcrPage;
    USHORT    OffsetPrcbProcStateSpecialReg;
    USHORT    GdtR0Code;
    USHORT    GdtR0Data;

    USHORT    GdtR0Pcr;
    USHORT    GdtR3Code;
    USHORT    GdtR3Data;
    USHORT    GdtR3Teb;

    USHORT    GdtLdt;
    USHORT    GdtTss;
    USHORT    Gdt64R3CmCode;
    USHORT    Gdt64R3CmTeb;

    ULONG64   IopNumTriageDumpDataBlocks;
    ULONG64   IopTriageDumpDataBlocks;

    // Longhorn addition

    ULONG64   VfCrashDataBlock;
    ULONG64   MmBadPagesDetected;
    ULONG64   MmZeroedPageSingleBitErrorsDetected;

    // Windows 7 addition

    ULONG64   EtwpDebuggerData;
    USHORT    OffsetPrcbContext;

    // Windows 8 addition

    USHORT    OffsetPrcbMaxBreakpoints;
    USHORT    OffsetPrcbMaxWatchpoints;

    ULONG     OffsetKThreadStackLimit;
    ULONG     OffsetKThreadStackBase;
    ULONG     OffsetKThreadQueueListEntry;
    ULONG     OffsetEThreadIrpList;

    USHORT    OffsetPrcbIdleThread;
    USHORT    OffsetPrcbNormalDpcState;
    USHORT    OffsetPrcbDpcStack;
    USHORT    OffsetPrcbIsrStack;

    USHORT    SizeKDPC_STACK_FRAME;

    // Windows 8.1 Addition

    USHORT    OffsetKPriQueueThreadListHead;
    USHORT    OffsetKThreadWaitReason;

    // Windows 10 RS1 Addition

    USHORT    Padding;
    ULONG64   PteBase;

    // Windows 10 RS5 Addition

    ULONG64 RetpolineStubFunctionTable;
    ULONG RetpolineStubFunctionTableSize;
    ULONG RetpolineStubOffset;
    ULONG RetpolineStubSize;

} KDDEBUGGER_DATA64, *PKDDEBUGGER_DATA64;

C_ASSERT( sizeof( KDDEBUGGER_DATA64 ) == 0x380 );
C_ASSERT( FIELD_OFFSET( KDDEBUGGER_DATA64, KernBase ) == 0x18 );

#pragma pack( push, 2 )
typedef struct _KD_CONTEXT {
    ULONG32                       RetryCount;
    BOOLEAN                       BreakRequested;
} KD_CONTEXT, *PKD_CONTEXT;
#pragma pack( pop )

C_ASSERT( sizeof( KD_CONTEXT ) == 0x6 );

typedef struct _KD_PACKET {
    ULONG32 PacketLeader;
    USHORT  PacketType;
    USHORT  PacketLength;
    ULONG32 PacketId;
    ULONG32 Checksum;
} KD_PACKET, *PKD_PACKET;

C_ASSERT( sizeof( KD_PACKET ) == 0x10 );

CFORCEINLINE
ULONG32
KdMessageChecksum(
    _In_ PSTRING Message
)
{
    ULONG32 Length;
    ULONG32 Checksum;
    PUCHAR  Buffer;

    Checksum = 0;
    Length = Message->Length;
    Buffer = ( PUCHAR )Message->Buffer;

    while ( Length-- ) {

        Checksum += *Buffer++;
    }

    return Checksum;
}

typedef enum _KD_PACKET_TYPE {
    KdTypeStateManipulate = 2,
    KdTypePrint           = 3,
    KdTypeAcknowledge     = 4,
    KdTypeResend          = 5,
    KdTypeReset           = 6,
    KdTypeStateChange     = 7,
    KdTypeCheckQueue      = 8,
    KdTypeTraceIo         = 9,
    KdTypeControlRequest  = 10,
    KdTypeFileIo          = 11,
} KD_PACKET_TYPE, *PKD_PACKET_TYPE;

typedef struct _KDESCRIPTOR {
    USHORT Pad[ 3 ];
    USHORT Limit;
    PVOID  Base;
} KDESCRIPTOR, *PKDESCRIPTOR;

typedef struct _KSPECIAL_REGISTERS
{
    ULONG64 Cr0;
    ULONG64 Cr2;
    ULONG64 Cr3;
    ULONG64 Cr4;
    ULONG64 KernelDr0;
    ULONG64 KernelDr1;
    ULONG64 KernelDr2;
    ULONG64 KernelDr3;
    ULONG64 KernelDr6;
    ULONG64 KernelDr7;
    KDESCRIPTOR Gdtr;
    KDESCRIPTOR Idtr;
    USHORT  Tr;
    USHORT  Ldtr;
    ULONG32 MxCsr;
    ULONG64 DebugControl;
    ULONG64 LastBranchToRip;
    ULONG64 LastBranchFromRip;
    ULONG64 LastExceptionToRip;
    ULONG64 LastExceptionFromRip;
    ULONG64 Cr8;
    ULONG64 MsrGsBase;
    ULONG64 MsrGsSwap;
    ULONG64 MsrStar;
    ULONG64 MsrLStar;
    ULONG64 MsrCStar;
    ULONG64 MsrSyscallMask;
    ULONG64 Xcr0;
    ULONG64 MsrFsBase;
    ULONG64 SpecialPadding0;
} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;

C_ASSERT( sizeof( KSPECIAL_REGISTERS ) == 0xF0 );

typedef struct _KPROCESSOR_STATE {
    KSPECIAL_REGISTERS SpecialRegisters;
    CONTEXT            ContextFrame;
} KPROCESSOR_STATE, *PKPROCESSOR_STATE;

#define AMD64_DEBUG_CONTROL_SPACE_PCR      0
#define AMD64_DEBUG_CONTROL_SPACE_PRCB     1
#define AMD64_DEBUG_CONTROL_SPACE_KSPECIAL 2
#define AMD64_DEBUG_CONTROL_SPACE_THREAD   3

```

`kdpl/inc/kddef.h`:

```h

#pragma once

#ifndef DBGKD_H
typedef struct _KDESCRIPTOR {
    USHORT Pad[ 3 ];
    USHORT Limit;
    PVOID  Base;
} KDESCRIPTOR, *PKDESCRIPTOR;

typedef struct _KSPECIAL_REGISTERS {
    ULONG64     Cr0;
    ULONG64     Cr2;
    ULONG64     Cr3;
    ULONG64     Cr4;
    ULONG64     KernelDr0;
    ULONG64     KernelDr1;
    ULONG64     KernelDr2;
    ULONG64     KernelDr3;
    ULONG64     KernelDr6;
    ULONG64     KernelDr7;
    KDESCRIPTOR Gdtr;
    KDESCRIPTOR Idtr;
    USHORT      Tr;
    USHORT      Ldtr;
    ULONG32     MxCsr;
    ULONG64     DebugControl;
    ULONG64     LastBranchToRip;
    ULONG64     LastBranchFromRip;
    ULONG64     LastExceptionToRip;
    ULONG64     LastExceptionFromRip;
    ULONG64     Cr8;
    ULONG64     MsrGsBase;
    ULONG64     MsrGsSwap;
    ULONG64     MsrStar;
    ULONG64     MsrLStar;
    ULONG64     MsrCStar;
    ULONG64     MsrSyscallMask;
    ULONG64     Xcr0;
    ULONG64     MsrFsBase;
    ULONG64     SpecialPadding0;
} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;
#endif

#ifndef MM_COPY_MEMORY_VIRTUAL
#define MM_COPY_MEMORY_VIRTUAL   0x2
#endif

#ifndef MM_COPY_MEMORY_PHYSICAL
#define MM_COPY_MEMORY_PHYSICAL  0x1
#endif

//#pragma comment(lib, "kdpl.lib")

//
// KDPLAPI = function definitions required by the linker
// KDAPI   = function definitions exported by the library 
//

#ifdef  KDPL
#define KDPLAPI EXTERN_C
#define KDAPI   
#else
#define KDPLAPI 
#define KDAPI   EXTERN_C
#endif

KDPLAPI ULONG64 KdKernelBase;
KDPLAPI ULONG32 KdKernelSize;

KDPLAPI
PKPCR
DbgKdQueryPcr(

);

KDPLAPI
ULONG32
DbgKdQueryProcessorCount(

);

//
// Expects the system to call KdReportStateChange on the processor
// specified by the processor number.
//
KDPLAPI
VOID
DbgKdSwapProcessor(
    _In_ ULONG32 ProcessorNumber
);

KDPLAPI
NTSTATUS
DbgKdMmCopyMemory(
    _In_ PVOID    TargetAddress,
    _In_ PVOID    SourceAddress,
    _In_ ULONG64  NumberOfBytes,
    _In_ ULONG32  Flags,
    _In_ ULONG64* NumberOfBytesTransferred
);

KDPLAPI
PCONTEXT
DbgKdQueryProcessorContext(
    _In_ ULONG32 ProcessorNumber
);

KDPLAPI
PKSPECIAL_REGISTERS
DbgKdQuerySpecialRegisters(
    _In_ ULONG32 ProcessorNumber
);

KDPLAPI
NTSTATUS
DbgKdInsertBreakpoint(
    _In_ ULONG64 Address
);

KDPLAPI
NTSTATUS
DbgKdRemoveBreakpoint(
    _In_ ULONG64 Address
);

KDAPI
NTSTATUS
KdDriverLoad(

);

KDAPI
VOID
KdDriverUnload(

);

KDAPI
BOOLEAN
KdPollBreakIn(

);

KDAPI
VOID
KdReportStateChange(
    _In_    NTSTATUS Status,
    _Inout_ PCONTEXT ContextRecord
);

KDAPI
VOID
KdLoadSymbols(
    _Inout_ PCONTEXT ContextRecord,
    _In_    PCHAR    ImageName,
    _In_    ULONG64  ImageBase,
    _In_    ULONG32  ImageSize,
    _In_    HANDLE   ProcessId,
    _In_    BOOLEAN  Unload
);

KDAPI
VOID
KdPrint(
    _In_ PCHAR Format,
    _In_ ...
);

KDAPI
NTSTATUS
KdTryConnect(

);

```

`kdpl/inc/kdpl.h`:

```h

#pragma once

#pragma warning(disable:4201)
#pragma warning(disable:4214)

#define KDPL

#define KD_STARTUP_SIG \
"              __          __     \n" \
"             /\\ \\        /\\ \\    \n" \
"  ___     ___\\ \\ \\/'\\    \\_\\ \\   \n" \
"/' _ `\\  / __`\\ \\ , <    /'_` \\  \n" \
"/\\ \\/\\ \\/\\ \\L\\ \\ \\ \\\\`\\ /\\ \\L\\ \\ \n" \
"\\ \\_\\ \\_\\ \\____/\\ \\_\\ \\_\\ \\___,_\\\n" \
" \\/_/\\/_/\\/___/  \\/_/\\/_/\\/__,_ /\n" \
"\n"

#include <ntifs.h>
#include <ntstrsafe.h>
#undef KdPrint
#define DBGKD_H
#include "dbgkd.h"

#define MM_COPY_MEMORY_PHYSICAL             0x1
#define MM_COPY_MEMORY_VIRTUAL              0x2

#define KD_BREAKPOINT_TABLE_LENGTH          32

typedef struct _KD_VMWRPC_CONTROL {
    ULONG32 Cookie1;
    ULONG32 Cookie2;
    ULONG32 Channel;
    ULONG32 RecvId;

    ULONG32 RecvExtraLength;
    PVOID   RecvExtraBuffer;
} KD_VMWRPC_CONTROL, *PKD_VMWRPC_CONTROL;

typedef struct _KD_DEBUG_DEVICE *PKD_DEBUG_DEVICE;

#define KD_BPE_SET      (0x00000001)
#define KD_BPE_OWE      (0x00000002)

typedef struct _KD_BREAKPOINT_ENTRY {
    PEPROCESS Process;
    ULONG64   Address;
    ULONG32   Flags;
    ULONG32   ContentLength;
    UCHAR     Content[ 0x20 ];
} KD_BREAKPOINT_ENTRY, *PKD_BREAKPOINT_ENTRY;

typedef enum _KD_STATUS {
    KdStatusSuccess = 0,
    KdStatusTimeOut = 1,
    KdStatusError   = 2,
    KdStatusResend,
} KD_STATUS, *PKD_STATUS;

typedef struct _KD_DEBUG_DEVICE {

    //
    // This structure is supposed to replace the interface of which 
    // kd* dll's provide, these dll's export a few functions which the OS 
    // would call, such as KdReceivePacket & KdSendPacket, and they are 
    // responsible for communication between the target & host. 
    //

    union {
        KD_VMWRPC_CONTROL VmwRpc;
    };

    //
    // List of kd* dll api's:
    //  KdReceivePacket
    //  KdSendPacket
    //  KdPower
    //  KdInitialize
    //  KdSetHiberRange
    //

    KD_STATUS( *KdSendPacket )(
        _In_     KD_PACKET_TYPE PacketType,
        _In_     PSTRING        Head,
        _In_opt_ PSTRING        Body,
        _Inout_  PKD_CONTEXT    KdContext );
    KD_STATUS( *KdReceivePacket )(
        _In_    KD_PACKET_TYPE PacketType,
        _Inout_ PSTRING        Head,
        _Inout_ PSTRING        Body,
        _Out_   PULONG32       Length,
        _Inout_ PKD_CONTEXT    KdContext );

} KD_DEBUG_DEVICE, *PKD_DEBUG_DEVICE;

EXTERN_C KD_DEBUG_DEVICE             KdDebugDevice;

EXTERN_C UCHAR                       KdpMessageBuffer[ 0x1000 ];
EXTERN_C CHAR                        KdpPathBuffer[ 0x1000 ];

EXTERN_C PUSHORT                     KeProcessorLevel;
EXTERN_C ULONG32                     KdDebuggerNotPresent_;

EXTERN_C KD_BREAKPOINT_ENTRY         KdpBreakpointTable[ KD_BREAKPOINT_TABLE_LENGTH ];

EXTERN_C KDDEBUGGER_DATA64           KdDebuggerDataBlock;

EXTERN_C DBGKD_GET_VERSION64         KdVersionBlock;
EXTERN_C LIST_ENTRY                  KdpDebuggerDataListHead;
EXTERN_C ULONG64                     KdpLoaderDebuggerBlock;
EXTERN_C KD_CONTEXT                  KdpContext;

#include "vmwrpc.h"
#include "uart.h"
#include "kddef.h"

#define DbgKdQueryCurrentProcessorNumber( ) DbgKdRead32( ( ULONG32* )( ( ULONG64 )DbgKdQueryPcr( ) + 0x1A4 ) )//DbgKdRead32( ( ULONG32* )( ( ULONG64 )DbgKdQueryPcr( ) + 0x184 ) )
#define DbgKdQueryCurrentPrcbNumber( )      DbgKdRead32( ( ULONG32* )( ( ULONG64 )DbgKdQueryPcr( ) + 0x1A4 ) )
#define DbgKdQueryCurrentThread( )          DbgKdRead64( ( ULONG64* )( ( ULONG64 )DbgKdQueryPcr( ) + 0x188 ) )

//

ULONG64
DbgKdRead64(
    _In_ PULONG64 Address
);

ULONG32
DbgKdRead32(
    _In_ PULONG32 Address
);

USHORT
DbgKdRead16(
    _In_ PUSHORT Address
);

UCHAR
DbgKdRead8(
    _In_ PUCHAR Address
);

//

VOID
KdpSetContextState(
    _Inout_ PDBGKD_WAIT_STATE_CHANGE Change,
    _In_    PCONTEXT                 Context
);

VOID
KdpSetCommonState(
    _In_    ULONG32                  ApiNumber,
    _In_    PCONTEXT                 Context,
    _Inout_ PDBGKD_WAIT_STATE_CHANGE Change
);

BOOLEAN
KdpSendWaitContinue(
    _In_ ULONG64  Unused,
    _In_ PSTRING  StateChangeHead,
    _In_ PSTRING  StateChangeBody,
    _In_ PCONTEXT Context
);

BOOLEAN
KdpReportExceptionStateChange(
    _In_ PEXCEPTION_RECORD64 ExceptRecord,
    _In_ PCONTEXT            ExceptContext,
    _In_ BOOLEAN             SecondChance
);

BOOLEAN
KdpReportLoadSymbolsStateChange(
    _In_    PSTRING         PathName,
    _In_    PKD_SYMBOL_INFO Symbol,
    _In_    BOOLEAN         Unload,
    _Inout_ PCONTEXT        Context
);

VOID
KdpPrintString_(
    _In_ PANSI_STRING String
);

VOID
KdPrint_(
    _In_ PCHAR Format,
    _In_ ...
);

//
// KDAPI.C
//

KD_STATUS
KdpReadVirtualMemory(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
);

KD_STATUS
KdpWriteVirtualMemory(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
);

VOID
KdpGetBaseContext(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body,
    _Inout_ PCONTEXT                  Context
);

KD_STATUS
KdpGetContext(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body,
    _Inout_ PCONTEXT                  Context
);

KD_STATUS
KdpGetContextEx(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body,
    _Inout_ PCONTEXT                  Context
);

KD_STATUS
KdpSetContext(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body,
    _Inout_ PCONTEXT                  Context
);

KD_STATUS
KdpSetContextEx(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body,
    _Inout_ PCONTEXT                  Context
);

KD_STATUS
KdpGetStateChangeApi(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body,
    _Inout_ PCONTEXT                  Context
);

KD_STATUS
KdpReadControlSpace(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
);

KD_STATUS
KdpWriteControlSpace(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
);

KD_STATUS
KdpReadIoSpace(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
);

KD_STATUS
KdpWriteIoSpace(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
);

KD_STATUS
KdpReadPhysicalMemory(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
);

KD_STATUS
KdpWritePhysicalMemory(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
);

KD_STATUS
KdpGetVersion(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
);

KD_STATUS
KdpQueryMemory(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
);

KD_STATUS
KdpInsertBreakpoint(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
);

KD_STATUS
KdpRemoveBreakpoint(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
);
```

`kdpl/inc/pci.h`:

```h

#pragma once

#define PCI_CONFIG_ADDRESS  0x0CF8
#define PCI_CONFIG_DATA     0x0CFC

#define PCI_GET_ADDRESS(Bus, Device, Function, Offset)      \
    ((Bus)      << 16) |                                    \
    ((Device)   << 11) |                                    \
    ((Function) << 8 ) |                                    \
    ((Offset)    & ~3) | (1 << 31)

#define PCI_CMD_INTERRUPT_DISABLE   0x400
#define PCI_CMD_IO_SPACE            0x001
#define PCI_CMD_MEMORY_SPACE        0x002
#define PCI_CMD_BUS_MASTER          0x004

typedef struct _KPCI_DEVICE_HEADER {
    USHORT  VendorId;
    USHORT  DeviceId;
    USHORT  Command;
    USHORT  Status;
    UCHAR   RevisionId;
    UCHAR   ProgrammingInterface;
    UCHAR   SubClass;
    UCHAR   Class;
    UCHAR   CacheLineSize;
    UCHAR   LatencyTimer;
    UCHAR   HeaderType;
    UCHAR   Bist;
} KPCI_DEVICE_HEADER, *PKPCI_DEVICE_HEADER;

// 
// Description               USB Controller (xHCI)
// Location                  bus 0 (0x00), device 20 (0x14), function 0 (0x00)
// Common header                
//      Vendor ID            0x8086 (Intel)
//      Model ID             0xA2AF
//      Revision ID          0x00
// PCI header                
//      Address 0 (memory)   0x00000000F7410004
//      Subvendor ID         0x1043 (ASUSTeK)
//      Subsystem ID         0x8694
//      Int. Line            0x00
//      Int. Pin             0x01
// PCI capability                
//      Caps class           Power Management
//      Caps offset          0x70
//      Caps version         1.1
// PCI capability                
//      Caps class           Message Signalled Interrupts
//      Caps offset          0x80
// 

typedef struct _KPCI_DEVICE {
    KPCI_DEVICE_HEADER Header;

    union {

        //
        // HeaderType = 0.
        //
        struct {
            ULONG32 Bar[6];
            ULONG32 CardbusInfoAddress;
            USHORT  SubsystemVendorId;
            USHORT  SubsystemId;
            ULONG32 ExpansionRomBase;
            UCHAR   CapsAddress;
            UCHAR   Reserved[7];
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            UCHAR   MinimumGrant;
            UCHAR   MaximumLatency;
        } Common;
    };


} KPCI_DEVICE, *PKPCI_DEVICE;

UCHAR  
KdpPciRead08(
    _In_ ULONG32 BusId,
    _In_ ULONG32 DeviceId,
    _In_ ULONG32 FunctionId,
    _In_ ULONG32 Offset
    );

USHORT 
KdpPciRead16(
    _In_ ULONG32 BusId,
    _In_ ULONG32 DeviceId,
    _In_ ULONG32 FunctionId,
    _In_ ULONG32 Offset
    );

ULONG32
KdpPciRead32(
    _In_ ULONG32 BusId,
    _In_ ULONG32 DeviceId,
    _In_ ULONG32 FunctionId,
    _In_ ULONG32 Offset
    );

VOID
KdpPciWrite08(
    _In_ ULONG32 BusId,
    _In_ ULONG32 DeviceId,
    _In_ ULONG32 FunctionId,
    _In_ ULONG32 Offset,
    _In_ UCHAR   Long
    );

VOID
KdpPciWrite16(
    _In_ ULONG32 BusId,
    _In_ ULONG32 DeviceId,
    _In_ ULONG32 FunctionId,
    _In_ ULONG32 Offset,
    _In_ USHORT  Long
    );

VOID
KdpPciWrite32(
    _In_ ULONG32 BusId,
    _In_ ULONG32 DeviceId,
    _In_ ULONG32 FunctionId,
    _In_ ULONG32 Offset,
    _In_ ULONG32 Long
    );
```

`kdpl/inc/uart.h`:

```h

#pragma once

NTSTATUS
KdUartConnect(
    VOID
    );
```

`kdpl/inc/vmwrpc.h`:

```h

#pragma once

VOID
KdVmwRpcInitialize(

);

NTSTATUS
KdVmwRpcConnect(

);

NTSTATUS
KdVmwRpcInitProtocol(

);

NTSTATUS
KdVmwRpcTestConnection(

);

KD_STATUS
KdVmwRpcSendPacket(
    _In_     KD_PACKET_TYPE PacketType,
    _In_     PSTRING        Head,
    _In_opt_ PSTRING        Body,
    _Inout_  PKD_CONTEXT    KdContext
);

KD_STATUS
KdVmwRpcRecvPacket(
    _In_    KD_PACKET_TYPE PacketType,
    _Inout_ PSTRING        Head,
    _Inout_ PSTRING        Body,
    _Out_   PULONG32       Length,
    _Inout_ PKD_CONTEXT    KdContext
);

NTSTATUS
KdVmwRpcOpenChannel(
    _In_ PKD_VMWRPC_CONTROL VmwRpc
);

NTSTATUS
KdVmwRpcCloseChannel(
    _In_ PKD_VMWRPC_CONTROL VmwRpc
);

NTSTATUS
KdVmwRpcSendCommandLength(
    _In_ PKD_VMWRPC_CONTROL VmwRpc,
    _In_ ULONG32            Length
);

NTSTATUS
KdVmwRpcSendCommandBuffer(
    _In_ PKD_VMWRPC_CONTROL VmwRpc,
    _In_ ULONG32            Length,
    _In_ PVOID              Buffer
);

NTSTATUS
KdVmwRpcRecvCommandLength(
    _In_ PKD_VMWRPC_CONTROL VmwRpc,
    _In_ PULONG32           Length
);

NTSTATUS
KdVmwRpcRecvCommandBuffer(
    _In_ PKD_VMWRPC_CONTROL VmwRpc,
    _In_ ULONG32            Length,
    _In_ PVOID              Buffer
);

//PUBLIC      KdVmwRpcSendFull

NTSTATUS
KdVmwRpcRecvCommandFinish(
    _In_ PKD_VMWRPC_CONTROL VmwRpc
);

```

`kdpl/kdapi.c`:

```c

#include <kdpl.h>

ULONG32             KdTransportMaxPacketSize = 0xFA0; // 4000.

KD_STATUS
KdpReadVirtualMemory(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
)
{
    STRING  Reciprocate;
    ULONG64 ReadCount;

    ReadCount = Packet->u.ReadMemory.TransferCount;
    ReadCount = min( KdTransportMaxPacketSize - sizeof( DBGKD_MANIPULATE_STATE64 ), ReadCount );
    ReadCount = min( Body->MaximumLength, ReadCount );

    Packet->ReturnStatus = DbgKdMmCopyMemory( Body->Buffer,
        ( PVOID )Packet->u.ReadMemory.TargetBaseAddress,
                                              ReadCount,
                                              MM_COPY_MEMORY_VIRTUAL,
                                              &ReadCount );

    Body->Length = ( USHORT )ReadCount;
    Packet->u.ReadMemory.ActualBytesRead = ( unsigned int )ReadCount;

    Reciprocate.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Buffer = ( PCHAR )Packet;

    return KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                       &Reciprocate,
                                       Body,
                                       &KdpContext );
}

KD_STATUS
KdpWriteVirtualMemory(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
)
{
    STRING  Reciprocate;
    ULONG64 Length;

    Packet->ReturnStatus = DbgKdMmCopyMemory( ( PVOID )Packet->u.WriteMemory.TargetBaseAddress,
                                              Body->Buffer,
                                              Body->Length,
                                              MM_COPY_MEMORY_VIRTUAL,
                                              &Length );
    Packet->u.WriteMemory.TransferCount = ( unsigned int )Length;

    Reciprocate.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Buffer = ( PCHAR )Packet;

    return KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                       &Reciprocate,
                                       NULL,
                                       &KdpContext );
}

VOID
KdpGetBaseContext(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body,
    _Inout_ PCONTEXT                  Context
)
{
    ULONG32 Length;

    if ( Packet->Processor != DbgKdQueryCurrentPrcbNumber( ) ) {

        Context = DbgKdQueryProcessorContext( Packet->Processor );
    }

    Length = sizeof( CONTEXT );
    Length += 15;

    if ( Length <= Body->MaximumLength ) {

        RtlCopyMemory( Body->Buffer, Context, Length );
        Body->Length = ( USHORT )Length;
        Packet->ReturnStatus = STATUS_SUCCESS;
    }
    else {

        Body->Length = 0;
        Packet->ReturnStatus = STATUS_UNSUCCESSFUL;
    }
}

KD_STATUS
KdpGetContext(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body,
    _Inout_ PCONTEXT                  Context
)
{
    STRING  Reciprocate;

    KdpGetBaseContext( Packet, Body, Context );

    Reciprocate.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Buffer = ( PCHAR )Packet;

    return KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                       &Reciprocate,
                                       Body,
                                       &KdpContext );
}

KD_STATUS
KdpGetContextEx(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body,
    _Inout_ PCONTEXT                  Context
)
{
    STRING  Reciprocate;
    ULONG64 BodyLength;
    ULONG64 BodyOffset;

    Reciprocate.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Buffer = ( PCHAR )Packet;

    KdpGetBaseContext( Packet, Body, Context );

    Packet->u.GetContextEx.BytesCopied = 0;

    if ( NT_SUCCESS( Packet->ReturnStatus ) ) {

        BodyOffset = Body->Length;

        if ( Packet->u.GetContextEx.Offset < BodyOffset ) {

            BodyOffset = Packet->u.GetContextEx.Offset;
        }

        BodyLength = Body->Length - BodyOffset;
        if ( Packet->u.GetContextEx.ByteCount <= BodyLength ) {

            BodyLength = Packet->u.GetContextEx.ByteCount;
        }

        if ( BodyOffset != 0 && BodyLength != 0 ) {

            RtlMoveMemory( Body->Buffer,
                           Body->Buffer + BodyOffset,
                           BodyLength );
        }

        Packet->u.GetContextEx.Offset = ( unsigned int )BodyOffset;
        Packet->u.GetContextEx.ByteCount = Body->Length;
        Packet->u.GetContextEx.BytesCopied = ( unsigned int )BodyLength;
        Body->Length = ( USHORT )BodyLength;
    }

    return KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                       &Reciprocate,
                                       Body,
                                       &KdpContext );
}

KD_STATUS
KdpSetContext(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body,
    _Inout_ PCONTEXT                  Context
)
{
    STRING Reciprocate;

    Reciprocate.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Buffer = ( PCHAR )Packet;

    //
    // They have the field Packet.u.SetContext.ContextFlags, but 
    // it's not used or even referenced.
    //

    if ( Packet->Processor != DbgKdQueryCurrentPrcbNumber( ) ) {

        Context = DbgKdQueryProcessorContext( Packet->Processor );
    }

    RtlCopyMemory( Context, Body->Buffer, Body->Length );
    Packet->ReturnStatus = STATUS_SUCCESS;

    return KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                       &Reciprocate,
                                       NULL,
                                       &KdpContext );
}

KD_STATUS
KdpSetContextEx(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body,
    _Inout_ PCONTEXT                  Context
)
{

    STRING Reciprocate;

    Reciprocate.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Buffer = ( PCHAR )Packet;

    //
    // Windows use a global var as an intermediate buffer
    // for the context.
    //
    // TODO: Basic range checks are done by windows.
    //

    if ( Packet->Processor != DbgKdQueryCurrentPrcbNumber( ) ) {

        Context = DbgKdQueryProcessorContext( Packet->Processor );
    }

    RtlCopyMemory( ( PCHAR )Context + Packet->u.SetContextEx.Offset,
                   Body->Buffer, Packet->u.SetContextEx.ByteCount );
    Packet->u.SetContextEx.BytesCopied = Packet->u.SetContextEx.ByteCount;
    Packet->ReturnStatus = STATUS_SUCCESS;

    return KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                       &Reciprocate,
                                       NULL,
                                       &KdpContext );
}

KD_STATUS
KdpGetStateChangeApi(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body,
    _Inout_ PCONTEXT                  Context
)
{
    Packet;
    Body;
    Context;
    return KdStatusSuccess;
}

KD_STATUS
KdpReadControlSpace(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
)
{
    STRING  Reciprocate;
    PVOID   ControlSpace;
    ULONG64 Pcr;
    ULONG64 Prcb;
    ULONG64 ReadCount;
    ULONG64 MaximumLength;
    ULONG64 Pointer;

    Pcr = ( ULONG64 )DbgKdQueryPcr( );
    Prcb = Pcr + 0x180;

    Packet->ReturnStatus = STATUS_SUCCESS;

    Reciprocate.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Buffer = ( PCHAR )Packet;

    MaximumLength = 8;

    ReadCount = Packet->u.ReadMemory.TransferCount;
    ReadCount = min( KdTransportMaxPacketSize - sizeof( DBGKD_MANIPULATE_STATE64 ), ReadCount );
    ReadCount = min( Body->MaximumLength, ReadCount );

    switch ( Packet->u.ReadMemory.TargetBaseAddress ) {
    case AMD64_DEBUG_CONTROL_SPACE_PCR:
        ControlSpace = &Pcr;
        break;
    case AMD64_DEBUG_CONTROL_SPACE_PRCB:
        ControlSpace = &Prcb;
        break;
    case AMD64_DEBUG_CONTROL_SPACE_KSPECIAL:
        MaximumLength = sizeof( KSPECIAL_REGISTERS );

        ControlSpace = DbgKdQuerySpecialRegisters( DbgKdQueryCurrentProcessorNumber( ) );
        break;
    case AMD64_DEBUG_CONTROL_SPACE_THREAD:
        //
        // ProcessorPrcb->CurrentThread
        //
        Pointer = Pcr + 0x188;
        ControlSpace = &Pointer;
        break;
    default:
        ControlSpace = NULL; // Compiler
        NT_ASSERT( FALSE );
    }

    if ( MaximumLength > ReadCount ) {

        MaximumLength = ReadCount;
    }

    Packet->u.ReadMemory.ActualBytesRead = ( ULONG32 )MaximumLength;
    Body->Length = ( USHORT )MaximumLength;

    if ( Packet->u.ReadMemory.TargetBaseAddress == AMD64_DEBUG_CONTROL_SPACE_KSPECIAL ) {

        RtlCopyMemory( Body->Buffer, ControlSpace, MaximumLength );
    }
    else {
        DbgKdMmCopyMemory( Body->Buffer,
                           ControlSpace,
                           MaximumLength,
                           MM_COPY_MEMORY_VIRTUAL,
                           &ReadCount );
        Packet->u.ReadMemory.ActualBytesRead = ( ULONG32 )ReadCount;
    }

    return KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                       &Reciprocate,
                                       Body,
                                       &KdpContext );
}

KD_STATUS
KdpWriteControlSpace(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
)
{
    STRING              Reciprocate;
    PVOID               ControlSpace;
    ULONG64             Pcr;
    ULONG64             Prcb;
    ULONG64             ReadCount;
    ULONG64             MaximumLength;
    ULONG64             Pointer;
    PKSPECIAL_REGISTERS Special;

    Pcr = ( ULONG64 )DbgKdQueryPcr( );
    Prcb = Pcr + 0x180;

    Packet->ReturnStatus = STATUS_SUCCESS;

    Reciprocate.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Buffer = ( PCHAR )Packet;

    MaximumLength = 8;

    ReadCount = Packet->u.ReadMemory.TransferCount;
    ReadCount = min( KdTransportMaxPacketSize - sizeof( DBGKD_MANIPULATE_STATE64 ), ReadCount );
    ReadCount = min( Body->MaximumLength, ReadCount );

    if (Packet->u.ReadMemory.TargetBaseAddress != AMD64_DEBUG_CONTROL_SPACE_KSPECIAL) {

        // had some issues with this function, this is actually in the kernel to return unsuccessful 
        // when it's not type 2, so I figured I'd just have it here too, 
        // only real use is to set KSPECIAL tbh 
        Packet->ReturnStatus = STATUS_UNSUCCESSFUL;
        return KdDebugDevice.KdSendPacket(KdTypeStateManipulate,
                                          &Reciprocate,
                                          Body,
                                          &KdpContext);
    }

    switch ( Packet->u.ReadMemory.TargetBaseAddress ) {
    case AMD64_DEBUG_CONTROL_SPACE_PCR:
        ControlSpace = ( PVOID )Pcr;
        //ControlSpace = &Pcr;
        break;
    case AMD64_DEBUG_CONTROL_SPACE_PRCB:
        ControlSpace = ( PVOID )Prcb;
        //ControlSpace = &Prcb;
        break;
    case AMD64_DEBUG_CONTROL_SPACE_KSPECIAL:
        //
        // ProcessorPrcb->ProcessorState
        //
        // Must be emulated because this can be considered part of the
        // context record.
        //

        MaximumLength = sizeof( KSPECIAL_REGISTERS );

        Special = DbgKdQuerySpecialRegisters( DbgKdQueryCurrentProcessorNumber( ) );
        ControlSpace = ( PVOID )Special;
        //ControlSpace = &Special;
        break;
    case AMD64_DEBUG_CONTROL_SPACE_THREAD:
        //
        // ProcessorPrcb->CurrentThread
        //
        Pointer = Pcr + 0x188;
        ControlSpace = ( PVOID )Pointer;
        //ControlSpace = &Pointer;
        break;
    default:
        ControlSpace = NULL; // Compiler
        NT_ASSERT( FALSE );
    }

    if ( MaximumLength > ReadCount ) {

        MaximumLength = ReadCount;
    }

    Packet->u.ReadMemory.ActualBytesRead = ( ULONG32 )MaximumLength;
    Body->Length = ( USHORT )MaximumLength;

    if ( Packet->u.ReadMemory.TargetBaseAddress == AMD64_DEBUG_CONTROL_SPACE_KSPECIAL ) {

        RtlCopyMemory( ControlSpace, Body->Buffer, MaximumLength );
    }
    else {
        DbgKdMmCopyMemory( ControlSpace,
                           Body->Buffer,
                           MaximumLength,
                           MM_COPY_MEMORY_VIRTUAL,
                           &ReadCount );
        Packet->u.ReadMemory.ActualBytesRead = ( ULONG32 )ReadCount;
    }

    // oddly enough, this does send the body back?
    return KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                       &Reciprocate,
                                       Body,
                                       &KdpContext );
}

KD_STATUS
KdpReadIoSpace(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
)
{
    Body;

    STRING Reciprocate;
    USHORT Address;

    //
    // TODO: probably allow the DbgKd to do this, and dont do it here!
    // 
    // Although it is very rare that this will be needed.
    //

    Address = ( USHORT )Packet->u.ReadWriteIo.IoAddress;

    switch ( Packet->u.ReadWriteIo.DataSize ) {
    case 1:
        Packet->u.ReadWriteIo.DataValue = __inbyte( Address );
        Packet->ReturnStatus = STATUS_SUCCESS;
        break;
    case 2:
        if ( ( Address & 1 ) == 0 ) {

            Packet->u.ReadWriteIo.DataValue = __inword( Address );
            Packet->ReturnStatus = STATUS_SUCCESS;
        }
        else {

            Packet->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
        }
        break;
    case 4:
        if ( ( Address & 3 ) == 0 ) {

            Packet->u.ReadWriteIo.DataValue = __inword( Address );
            Packet->ReturnStatus = STATUS_SUCCESS;
        }
        else {

            Packet->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
        }
        break;
    default:
        Packet->ReturnStatus = STATUS_INVALID_PARAMETER;
        break;
    }

    Reciprocate.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Buffer = ( PCHAR )Packet;

    return KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                       &Reciprocate,
                                       NULL,
                                       &KdpContext );
}

KD_STATUS
KdpWriteIoSpace(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
)
{
    Body;

    STRING Reciprocate;
    USHORT Address;

    Address = ( USHORT )Packet->u.ReadWriteIo.IoAddress;

    switch ( Packet->u.ReadWriteIo.DataSize ) {
    case 1:
        __outbyte( Address, ( UCHAR )Packet->u.ReadWriteIo.DataValue );
        Packet->ReturnStatus = STATUS_SUCCESS;
        break;
    case 2:
        if ( ( Address & 1 ) == 0 ) {

            __outword( Address, ( USHORT )Packet->u.ReadWriteIo.DataValue );
            Packet->ReturnStatus = STATUS_SUCCESS;
        }
        else {

            Packet->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
        }
        break;
    case 4:
        if ( ( Address & 3 ) == 0 ) {

            __outdword( Address, ( ULONG )Packet->u.ReadWriteIo.DataValue );
            Packet->ReturnStatus = STATUS_SUCCESS;
        }
        else {

            Packet->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
        }
        break;
    default:
        Packet->ReturnStatus = STATUS_INVALID_PARAMETER;
        break;
    }

    Reciprocate.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Buffer = ( PCHAR )Packet;

    return KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                       &Reciprocate,
                                       NULL,
                                       &KdpContext );
}

KD_STATUS
KdpReadPhysicalMemory(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
)
{
    STRING  Reciprocate;
    ULONG64 ReadCount;

    ReadCount = Packet->u.ReadMemory.TransferCount;
    ReadCount = min( KdTransportMaxPacketSize - sizeof( DBGKD_MANIPULATE_STATE64 ), ReadCount );
    ReadCount = min( Body->MaximumLength, ReadCount );

    Packet->ReturnStatus = DbgKdMmCopyMemory( Body->Buffer,
        ( PVOID )Packet->u.ReadMemory.TargetBaseAddress,
                                              ReadCount,
                                              MM_COPY_MEMORY_PHYSICAL,
                                              &ReadCount );

    Body->Length = ( USHORT )ReadCount;
    Packet->u.ReadMemory.ActualBytesRead = ( unsigned int )ReadCount;

    Reciprocate.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Buffer = ( PCHAR )Packet;

    return KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                       &Reciprocate,
                                       Body,
                                       &KdpContext );
}

KD_STATUS
KdpWritePhysicalMemory(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
)
{
    //
    // This real ntoskrnl version of this function
    // handles packet with ApiNumber 0x3162, this is the same,
    // however, the buffer is run length encoded.
    //

    STRING Reciprocate;
    SIZE_T ReadCount;

    ReadCount = Packet->u.WriteMemory.TransferCount;
    ReadCount = min( KdTransportMaxPacketSize - sizeof( DBGKD_MANIPULATE_STATE64 ), ReadCount );
    ReadCount = min( Body->MaximumLength, ReadCount );

    Packet->ReturnStatus = DbgKdMmCopyMemory( ( PVOID )Packet->u.WriteMemory.TargetBaseAddress,
                                              Body->Buffer,
                                              ReadCount,
                                              MM_COPY_MEMORY_VIRTUAL,
                                              &ReadCount );

    Packet->u.WriteMemory.ActualBytesWritten = ( unsigned int )ReadCount;

    Reciprocate.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Buffer = ( PCHAR )Packet;

    return KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                       &Reciprocate,
                                       NULL,
                                       &KdpContext );

}

KD_STATUS
KdpGetVersion(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
)
{
    Body;

    STRING Reciprocate;

    Packet->u.GetVersion64 = KdVersionBlock;
    Packet->ReturnStatus = STATUS_SUCCESS;

    Reciprocate.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Buffer = ( PCHAR )Packet;

    return KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                       &Reciprocate,
                                       NULL,
                                       &KdpContext );
}

KD_STATUS
KdpQueryMemory(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
)
{
    Body;

    STRING Reciprocate;

    if ( Packet->u.QueryMemory.AddressSpace != 0 ) {

        //
        // Bit weird, but okay windows.
        //

        Packet->ReturnStatus = STATUS_INVALID_PARAMETER;
    }
    else {

        if ( Packet->u.QueryMemory.Address >= 0x7FFFFFFEFFFF ) {

            //
            // TODO: We can replace MmIsSessionAddress in the future, we
            //       can use KdDebuggerData.MmSessionBase - KdDebuggerData.MmSessionSize
            //       or hardcode FFFFF900`00000000 to FFFFF97F`FFFFFFFF
            //

            if ( FALSE ) {
                //if ( MmIsSessionAddress( Packet->u.QueryMemory.Address )  ) {

                Packet->u.QueryMemory.AddressSpace = SessionSpace;
            }
            else {

                Packet->u.QueryMemory.AddressSpace = SystemSpace;
            }
        }
        else {

            Packet->u.QueryMemory.AddressSpace = UserSpace;
        }

        Packet->u.QueryMemory.Flags = 7;
        Packet->ReturnStatus = STATUS_SUCCESS;
    }

    //
    // Windows sets this to zero for some reason.
    //

    Packet->u.QueryMemory.Reserved = 0;

    Reciprocate.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Buffer = ( PCHAR )Packet;

    return KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                       &Reciprocate,
                                       NULL,
                                       &KdpContext );
}

KD_STATUS
KdpInsertBreakpoint(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
)
{
    Body;

    STRING  Reciprocate;
    ULONG32 Handle;
    ULONG32 CurrentBreakpoint;

    Handle = ( ULONG32 )( -1 );
    for ( CurrentBreakpoint = 0;
          CurrentBreakpoint < KD_BREAKPOINT_TABLE_LENGTH;
          CurrentBreakpoint++ ) {

        if ( ( KdpBreakpointTable[ CurrentBreakpoint ].Flags & KD_BPE_SET ) == 0 ) {

            Handle = CurrentBreakpoint;
            break;
        }
    }

    if ( Handle == ( ULONG32 )( -1 ) ) {

        Packet->ReturnStatus = STATUS_UNSUCCESSFUL;
        goto DbgKdpProcedureDone;
    }

    Packet->ReturnStatus = STATUS_SUCCESS;

    KdpBreakpointTable[ Handle ].Address = Packet->u.WriteBreakPoint.BreakPointAddress;
    KdpBreakpointTable[ Handle ].Flags = KD_BPE_SET;

    Packet->u.WriteBreakPoint.BreakPointHandle = Handle;

    DbgKdInsertBreakpoint( KdpBreakpointTable[ Handle ].Address );
DbgKdpProcedureDone:

    Reciprocate.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Buffer = ( PCHAR )Packet;

    return KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                       &Reciprocate,
                                       NULL,
                                       &KdpContext );
}

KD_STATUS
KdpRemoveBreakpoint(
    _Inout_ PDBGKD_MANIPULATE_STATE64 Packet,
    _Inout_ PSTRING                   Body
)
{
    Body;

    STRING Reciprocate;

    if ( Packet->u.RestoreBreakPoint.BreakPointHandle >= KD_BREAKPOINT_TABLE_LENGTH ) {

        Packet->ReturnStatus = STATUS_UNSUCCESSFUL;
    }
    else if ( KdpBreakpointTable[ Packet->u.RestoreBreakPoint.BreakPointHandle ].Flags & KD_BPE_SET ) {

        DbgKdRemoveBreakpoint( KdpBreakpointTable[ Packet->u.RestoreBreakPoint.BreakPointHandle ].Address );

        KdpBreakpointTable[ Packet->u.RestoreBreakPoint.BreakPointHandle ].Flags &= ~KD_BPE_SET;
        Packet->ReturnStatus = STATUS_SUCCESS;
    }
    else {

        Packet->ReturnStatus = STATUS_SUCCESS;
    }

    Reciprocate.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
    Reciprocate.Buffer = ( PCHAR )Packet;

    return KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                       &Reciprocate,
                                       NULL,
                                       &KdpContext );
}

```

`kdpl/kdpl.c`:

```c

#include <kdpl.h>

// 
// Your implementation
//
EXTERN_C
NTSTATUS
KdImageSection(
    _In_      PVOID  ImageBase,
    _In_      PCHAR  SectionName,
    _Out_opt_ PVOID* SectionBase,
    _Out_opt_ ULONG* SectionSize
);

EXTERN_C
PVOID
KdSearchSignature(
    _In_ PVOID BaseAddress,
    _In_ ULONG Length,
    _In_ PCHAR Signature
);

KD_DEBUG_DEVICE             KdDebugDevice;

UCHAR                       KdpMessageBuffer[ 0x1000 ];
CHAR                        KdpPathBuffer[ 0x1000 ];

PUSHORT                     KeProcessorLevel;
ULONG32                     KdDebuggerNotPresent_ = TRUE;

KD_BREAKPOINT_ENTRY         KdpBreakpointTable[ KD_BREAKPOINT_TABLE_LENGTH ] = { 0 };

KDDEBUGGER_DATA64           KdDebuggerDataBlock = { 0 };

DBGKD_GET_VERSION64         KdVersionBlock = {
    0x0F,
    0x536A,
    0x06,
    0x02,
    0x46,
    0x8664,
    0x0C,
    0x03,
    0x33,
    0,
    0,
    0,
    0,
    0 };
LIST_ENTRY                  KdpDebuggerDataListHead;
KD_CONTEXT                  KdpContext = { 0 };

ULONG64
DbgKdRead64(
    _In_ PULONG64 Address
)
{
    NTSTATUS ntStatus;
    ULONG64  Buffer;
    ULONG64  Transferred;

    ntStatus = DbgKdMmCopyMemory( &Buffer,
                                  Address,
                                  sizeof( ULONG64 ),
                                  MM_COPY_MEMORY_VIRTUAL,
                                  &Transferred );
    NT_ASSERT( NT_SUCCESS( ntStatus ) );
    NT_ASSERT( Transferred == sizeof( ULONG64 ) );

    return Buffer;
}

ULONG32
DbgKdRead32(
    _In_ PULONG32 Address
)
{
    NTSTATUS ntStatus;
    ULONG32  Buffer;
    ULONG64  Transferred;

    ntStatus = DbgKdMmCopyMemory( &Buffer,
                                  Address,
                                  sizeof( ULONG32 ),
                                  MM_COPY_MEMORY_VIRTUAL,
                                  &Transferred );
    NT_ASSERT( NT_SUCCESS( ntStatus ) );
    NT_ASSERT( Transferred == sizeof( ULONG32 ) );

    return Buffer;
}

USHORT
DbgKdRead16(
    _In_ PUSHORT Address
)
{
    NTSTATUS ntStatus;
    USHORT   Buffer;
    ULONG64  Transferred;

    ntStatus = DbgKdMmCopyMemory( &Buffer,
                                  Address,
                                  sizeof( USHORT ),
                                  MM_COPY_MEMORY_VIRTUAL,
                                  &Transferred );
    NT_ASSERT( NT_SUCCESS( ntStatus ) );
    NT_ASSERT( Transferred == sizeof( USHORT ) );

    return Buffer;
}

UCHAR
DbgKdRead8(
    _In_ PUCHAR Address
)
{
    NTSTATUS ntStatus;
    UCHAR    Buffer;
    ULONG64  Transferred;

    ntStatus = DbgKdMmCopyMemory( &Buffer,
                                  Address,
                                  sizeof( UCHAR ),
                                  MM_COPY_MEMORY_VIRTUAL,
                                  &Transferred );
    NT_ASSERT( NT_SUCCESS( ntStatus ) );
    NT_ASSERT( Transferred == sizeof( UCHAR ) );

    return Buffer;
}

BOOLEAN
KdPollBreakIn(

)
{
    if ( KdpContext.BreakRequested == TRUE ) {

        KdpContext.BreakRequested = FALSE;
        return TRUE;
    }

    return KdDebugDevice.KdReceivePacket( KdTypeCheckQueue,
                                          NULL,
                                          NULL,
                                          NULL,
                                          &KdpContext ) == KdStatusSuccess;
}

VOID
KdReportStateChange(
    _In_    NTSTATUS Status,
    _Inout_ PCONTEXT ContextRecord
)
{
    EXCEPTION_RECORD64 ExceptRecord = { 0 };

    ExceptRecord.ExceptionAddress = ContextRecord->Rip;
    ExceptRecord.ExceptionCode = Status;

    KdpReportExceptionStateChange( &ExceptRecord,
                                   ContextRecord,
                                   FALSE );
}

VOID
KdLoadSymbols(
    _Inout_ PCONTEXT ContextRecord,
    _In_    PCHAR    ImageName,
    _In_    ULONG64  ImageBase,
    _In_    ULONG32  ImageSize,
    _In_    HANDLE   ProcessId,
    _In_    BOOLEAN  Unload
)
{
    KD_SYMBOL_INFO     Symbol;
    LONG32             Elfanew;
    STRING             PathName;

    Symbol.BaseAddress = ImageBase;
    Symbol.SizeOfImage = ImageSize;
    Symbol.ProcessId = ( ULONG64 )ProcessId;

    if ( NT_SUCCESS( DbgKdMmCopyMemory( &Elfanew,
        ( PVOID )( ImageBase + 0x3C ),
                                        sizeof( LONG32 ),
                                        MM_COPY_MEMORY_VIRTUAL,
                                        NULL ) ) ) {

        Symbol.CheckSum = 0;
        DbgKdMmCopyMemory( &Symbol.CheckSum,
            ( PVOID )( ImageBase + Elfanew + 0x40 ),
                           sizeof( ULONG32 ),
                           MM_COPY_MEMORY_VIRTUAL,
                           NULL );
    }

    RtlInitString( &PathName, ImageName );

    KdpReportLoadSymbolsStateChange( &PathName, &Symbol, Unload, ContextRecord );
}

VOID
KdpSetCommonState(
    _In_    ULONG32                  ApiNumber,
    _In_    PCONTEXT                 Context,
    _Inout_ PDBGKD_WAIT_STATE_CHANGE Change
)
{
    //
    // TODO: This procedure also deletes the breakpoint range at
    //       the context's rip.
    //

    ULONG64 InstructionCount;
    ULONG32 CurrentHandle;

    Change->ApiNumber = ApiNumber;
    Change->Processor = ( USHORT )DbgKdQueryCurrentPrcbNumber( );
    Change->ProcessorCount = DbgKdQueryProcessorCount( );
    if ( Change->ProcessorCount <= Change->Processor ) {

        Change->ProcessorCount = Change->Processor + 1;
    }

    Change->ProcessorLevel = *KeProcessorLevel;
    Change->CurrentThread = DbgKdQueryCurrentThread( );

    RtlZeroMemory( &Change->ControlReport, sizeof( DBGKD_CONTROL_REPORT ) );

    //
    // This is important breakpoint handling code,
    // this will set a stub-bp directly after the previous instruction,
    // this will be caught, and the old bp will be re-added.
    //

    for ( CurrentHandle = 0;
          CurrentHandle < KD_BREAKPOINT_TABLE_LENGTH;
          CurrentHandle++ ) {

        if ( KdpBreakpointTable[ CurrentHandle ].Flags & KD_BPE_SET ) {

            if ( KdpBreakpointTable[ CurrentHandle ].Address == Context->Rip ) {

                //
                // Normally the bp would be hit and the instruction pointer would 
                // be += the bp length -- assume dealt with
                //

                DbgKdRemoveBreakpoint( KdpBreakpointTable[ CurrentHandle ].Address );
                break;
            }
        }
    }

    Change->ProgramCounter = Context->Rip;

    __try {
        // TODO: DbgKdMmCopy
        RtlCopyMemory( Change->ControlReport.InstructionStream, ( PVOID )Context->Rip, 0x10 );
        InstructionCount = 0x10;
    }
    __except ( EXCEPTION_EXECUTE_HANDLER ) {

        InstructionCount = 0;
    }
    Change->ControlReport.InstructionCount = ( USHORT )InstructionCount;

}

VOID
KdpSetContextState(
    _Inout_ PDBGKD_WAIT_STATE_CHANGE Change,
    _In_    PCONTEXT                 Context
)
{
    Change->ControlReport.Dr6 = 0xFFFF0FF0;//KdGetPrcbSpecialRegisters( KeGetCurrentPrcb( ) )->KernelDr6;
    Change->ControlReport.Dr7 = 0x400;//KdGetPrcbSpecialRegisters( KeGetCurrentPrcb( ) )->KernelDr7;

    Change->ControlReport.SegCs = Context->SegCs;
    Change->ControlReport.SegDs = Context->SegDs;
    Change->ControlReport.SegEs = Context->SegEs;
    Change->ControlReport.SegFs = Context->SegFs;

    Change->ControlReport.EFlags = Context->EFlags;
    Change->ControlReport.ReportFlags = 1;

    if ( Context->SegCs == 0x10 ||
         Context->SegCs == 0x33 ) {

        Change->ControlReport.ReportFlags = 0x3;
    }
}

VOID
KdpPrintString_(
    _In_ PANSI_STRING String
)
{
    STRING             Body;
    STRING             Head;
    DBGKD_PRINT_STRING Print = { 0 };

    Print.ProcessorLevel = *KeProcessorLevel;
    Print.ApiNumber = 0x3230;
    Print.Processor = ( USHORT )DbgKdQueryCurrentProcessorNumber( );
    Print.Length = String->Length;

    RtlCopyMemory( KdpMessageBuffer, String->Buffer, String->Length );

    Head.Length = sizeof( DBGKD_PRINT_STRING );
    Head.MaximumLength = sizeof( DBGKD_PRINT_STRING );
    Head.Buffer = ( PCHAR )&Print;

    Body.Length = String->Length;
    Body.MaximumLength = 0x1000;
    Body.Buffer = ( PCHAR )KdpMessageBuffer;

    KdDebugDevice.KdSendPacket( KdTypePrint,
                                &Head,
                                &Body,
                                &KdpContext );
}

VOID
KdPrint_(
    _In_ PCHAR Format,
    _In_ ...
)
{
    CHAR        Buffer[ 512 ];
    ANSI_STRING String;
    va_list     List;

    va_start( List, Format );
    RtlStringCchVPrintfA( Buffer,
                          512,
                          Format,
                          List );
    va_end( List );
    String.MaximumLength = 512;
    String.Length = ( USHORT )( strlen( Buffer ) );
    String.Buffer = ( PCHAR )Buffer;

    KdpPrintString_( &String );
}

BOOLEAN
KdpReportExceptionStateChange(
    _In_ PEXCEPTION_RECORD64 ExceptRecord,
    _In_ PCONTEXT            ExceptContext,
    _In_ BOOLEAN             SecondChance
)
{
    STRING                  Head;
    DBGKD_WAIT_STATE_CHANGE State = { 0 };

    KdpSetCommonState( 0x3030, ExceptContext, &State );
    RtlCopyMemory( &State.u.Exception.ExceptionRecord,
                   ExceptRecord,
                   sizeof( EXCEPTION_RECORD64 ) );
    State.u.Exception.FirstChance = !SecondChance;
    State.u.Exception.ExceptionRecord.ExceptionAddress = ExceptContext->Rip;
    KdpSetContextState( &State, ExceptContext );

    Head.Length = sizeof( DBGKD_WAIT_STATE_CHANGE );
    Head.MaximumLength = sizeof( DBGKD_WAIT_STATE_CHANGE );
    Head.Buffer = ( PCHAR )&State;

    return KdpSendWaitContinue( 0,
                                &Head,
                                NULL,
                                ExceptContext );
}

BOOLEAN
KdpReportLoadSymbolsStateChange(
    _In_    PSTRING         PathName,
    _In_    PKD_SYMBOL_INFO Symbol,
    _In_    BOOLEAN         Unload,
    _Inout_ PCONTEXT        Context
)
{
    STRING                  Head;
    STRING                  Body;
    PSTRING                 BodyAddress;
    DBGKD_WAIT_STATE_CHANGE LoadSymbol = { 0 };

    KdpSetCommonState( 0x3031, Context, &LoadSymbol );
    KdpSetContextState( &LoadSymbol, Context );

    LoadSymbol.u.LoadSymbols.BaseOfDll = Symbol->BaseAddress;
    LoadSymbol.u.LoadSymbols.ProcessId = Symbol->ProcessId;
    LoadSymbol.u.LoadSymbols.CheckSum = Symbol->CheckSum;
    LoadSymbol.u.LoadSymbols.SizeOfImage = Symbol->SizeOfImage;
    LoadSymbol.u.LoadSymbols.UnloadSymbols = Unload;

    if ( PathName != NULL ) {

        BodyAddress = &Body;

        LoadSymbol.u.LoadSymbols.PathNameLength = PathName->Length + 1;
        Body.Length = PathName->Length + 1;
        Body.Buffer = KdpPathBuffer;
        Body.MaximumLength = 0x1000;

        RtlCopyMemory( KdpPathBuffer,
                       PathName->Buffer,
                       PathName->Length );
        KdpPathBuffer[ PathName->Length ] = 0;
    }
    else {
        Body.Length = 0;
        LoadSymbol.u.LoadSymbols.PathNameLength = 0;
        BodyAddress = NULL;
    }

    Head.Length = sizeof( DBGKD_WAIT_STATE_CHANGE );
    Head.MaximumLength = sizeof( DBGKD_WAIT_STATE_CHANGE );
    Head.Buffer = ( PCHAR )&LoadSymbol;

    return KdpSendWaitContinue( 0,
                                &Head,
                                BodyAddress,
                                Context );
}

BOOLEAN
KdpSendWaitContinue(
    _In_ ULONG64  Unused,
    _In_ PSTRING  StateChangeHead,
    _In_ PSTRING  StateChangeBody,
    _In_ PCONTEXT Context
)
{
    Context;
    Unused;

    //
    // This function prototype is matched with the nt
    // function, the first parameter is infact unreferenced.
    // 
    // Some things are quite different later down, but it still
    // works fine with WinDbg.
    //

    KD_STATUS                Status;
    STRING                   Head;
    STRING                   Body;
    ULONG32                  Length;
    ULONG32                  Processor;
    DBGKD_MANIPULATE_STATE64 Packet;

    Head.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
    Head.Length = 0;
    Head.Buffer = ( PCHAR )&Packet;

    Body.MaximumLength = 0x1000;
    Body.Length = 0;
    Body.Buffer = ( PCHAR )&KdpMessageBuffer;

KdpResendPacket:
    KdDebugDevice.KdSendPacket( KdTypeStateChange,
                                StateChangeHead,
                                StateChangeBody,
                                &KdpContext );

    while ( !KdDebuggerNotPresent_ ) {

        while ( 1 ) {

            RtlZeroMemory( &Packet, sizeof( DBGKD_MANIPULATE_STATE64 ) );

            Head.MaximumLength = sizeof( DBGKD_MANIPULATE_STATE64 );
            Head.Length = 0;

            Body.MaximumLength = 0x1000;
            Body.Length = 0;

            Status = KdDebugDevice.KdReceivePacket( KdTypeStateManipulate,
                                                    &Head,
                                                    &Body,
                                                    &Length,
                                                    &KdpContext );
            if ( Status == KdStatusResend ) {

                //
                // This seems a little weird, but this is the same as 
                // nt!KdpSendWaitContinue, if a resend is requested at any point
                // the state is sent, I believe it is for when the debugger
                // is restarted maybe? Not sure.
                //

                goto KdpResendPacket;
            }

            if ( Status == KdStatusSuccess &&
                 Packet.ApiNumber >= DbgKdMinimumManipulate &&
                 Packet.ApiNumber < DbgKdMaximumManipulate ) {

                switch ( Packet.ApiNumber ) {
                case DbgKdReadVirtualMemoryApi:
                    KdpReadVirtualMemory( &Packet,
                                          &Body );
                    break;
                case DbgKdWriteVirtualMemoryApi:
                    KdpWriteVirtualMemory( &Packet,
                                           &Body );
                    break;
                case DbgKdGetContextApi:
                    KdpGetContext( &Packet,
                                   &Body,
                                   Context );
                    break;
                case DbgKdSetContextApi:
                    KdpSetContext( &Packet,
                                   &Body,
                                   Context );
                    break;
                case DbgKdWriteBreakPointApi:
                    KdpInsertBreakpoint( &Packet,
                                         &Body );
                    break;
                case DbgKdRestoreBreakPointApi:
                    KdpRemoveBreakpoint( &Packet,
                                         &Body );
                    break;
                case DbgKdContinueApi:
                    return NT_SUCCESS( Packet.u.Continue.ContinueStatus );
                case DbgKdReadControlSpaceApi:
                    KdpReadControlSpace( &Packet,
                                         &Body );
                    break;
                case DbgKdWriteControlSpaceApi:
                    KdpWriteControlSpace( &Packet,
                                          &Body );
                    break;
                case DbgKdReadIoSpaceApi:
                    KdpReadIoSpace( &Packet,
                                    &Body );
                    break;
                case DbgKdWriteIoSpaceApi:
                    KdpWriteIoSpace( &Packet,
                                     &Body );
                    break;
                case DbgKdRebootApi:
                case DbgKdCauseBugCheckApi:

                    //KdThawProcessors( );
                    //KeBugCheck( 0 );
                    break;
                case DbgKdContinueApi2:
                    if ( !NT_SUCCESS( Packet.u.Continue2.ContinueStatus ) ) {

                        return FALSE;
                    }

                    if ( Packet.u.Continue2.ControlSet.TraceFlag ) {

                        //
                        // DbgKd layer will handle this.
                        //
                        Context->EFlags |= 0x100;
                    }

                    for ( Processor = 0;
                          Processor < DbgKdQueryProcessorCount( );
                          Processor++ ) {

                        DbgKdQueryProcessorContext( Processor )->Dr6 = 0;
                        DbgKdQueryProcessorContext( Processor )->Dr7 = Packet.u.Continue2.ControlSet.Dr7;
                    }

                    return TRUE;
                case DbgKdReadPhysicalMemoryApi:
                    KdpReadPhysicalMemory( &Packet,
                                           &Body );
                    break;
                case DbgKdWritePhysicalMemoryApi:
                    KdpWritePhysicalMemory( &Packet,
                                            &Body );
                    break;
                case DbgKdGetVersionApi:
                    KdpGetVersion( &Packet,
                                   &Body );
                    break;
                case DbgKdSetSpecialCallApi:
                case DbgKdClearSpecialCallsApi:
                case DbgKdSetInternalBreakPointApi:
                case DbgKdClearAllInternalBreakpointsApi:
                    continue;
                case DbgKdGetContextEx:
                    KdpGetContextEx( &Packet,
                                     &Body,
                                     Context );
                    break;
                case DbgKdSetContextEx:
                    KdpSetContextEx( &Packet,
                                     &Body,
                                     Context );
                    break;
                case DbgKdQueryMemoryApi:
                    KdpQueryMemory( &Packet,
                                    &Body );
                    break;
                case DbgKdSwitchProcessor:

                    if ( Packet.Processor == ( USHORT )DbgKdQueryCurrentProcessorNumber( ) ) {

                        goto KdpResendPacket;
                    }

                    DbgKdSwapProcessor( Packet.Processor );
                    return TRUE;
                default:
                    Packet.ReturnStatus = STATUS_UNSUCCESSFUL;
                    Head.Buffer = ( PCHAR )&Packet;
                    Head.Length = sizeof( DBGKD_MANIPULATE_STATE64 );
                    KdDebugDevice.KdSendPacket( KdTypeStateManipulate,
                                                &Head,
                                                NULL,
                                                &KdpContext );
                    //KdPrint( "KdApiNumber unhandled: %#.4lx\n", Packet.ApiNumber );
                    break;
                }
            }
        }

        KdDebugDevice.KdSendPacket( KdTypeStateChange,
                                    StateChangeHead,
                                    StateChangeBody,
                                    &KdpContext );
    }

    return TRUE;
}

NTSTATUS
KdTryConnect(

)
{
#if 0
    if ( !NT_SUCCESS( KdVmwRpcConnect( ) ) ) {

        return STATUS_UNSUCCESSFUL;
    }
#else
    if (!NT_SUCCESS(KdUartConnect())) {
    
        return STATUS_UNSUCCESSFUL;
    }
#endif

    KdDebuggerNotPresent_ = FALSE;
    KdPrint_( KD_STARTUP_SIG );

    return STATUS_SUCCESS;
}

NTSTATUS
KdDriverLoad(

)
{
    PVOID              ImageBase;
    ULONG              ImageSize;
    PVOID              SectionTextBase;
    ULONG              SectionTextSize;
    PVOID              SectionPageLKBase;
    ULONG              SectionPageLKSize;
    ULONG_PTR          KdCopyDataBlockAddress;
    ULONG_PTR          KeProcessorLevelAddress;
    ULONG_PTR          KdpDataBlockEncodedAddress;
    ULONG_PTR          KiWaitAlwaysAddress;
    ULONG_PTR          KiWaitNeverAddress;
    ULONG_PTR          KdEncodeDataBlockAddress;
    ULONG_PTR          KiWaitAlways;
    ULONG_PTR          KiWaitNever;
    ULONG32            Length;
    ULONG64*           Long;

    ULONG_PTR          KdDebuggerDataBlockAddress;

    ImageBase = NULL;
    ImageSize = 0;

    SectionTextBase = NULL;
    SectionTextSize = 0;

    //
    // "Guestify" everything!
    //

    ImageBase = ( PVOID )KdKernelBase;
    ImageSize = ( ULONG )KdKernelSize;

    KdImageSection( ImageBase, ".text\0\0", &SectionTextBase, &SectionTextSize );
    KdImageSection( ImageBase, "PAGELK\0", &SectionPageLKBase, &SectionPageLKSize );

    KdCopyDataBlockAddress = ( ULONG_PTR )KdSearchSignature( ( PVOID )( ( ULONG_PTR )ImageBase + ( ULONG_PTR )SectionTextBase ),
                                                             SectionTextSize,
                                                             "80 3D ? ? ? ? ? 4C 8D 05 ? ? ? ?" );

    if ( KdCopyDataBlockAddress == 0 ) {

        return STATUS_UNSUCCESSFUL;
    }
#if 0
    KdDebuggerDataBlockAddress = ( ULONG64 )( KdCopyDataBlockAddress + 14 + ( LONG32 )DbgKdRead32( ( ULONG32* )( KdCopyDataBlockAddress + 10 ) ) );


    KeProcessorLevelAddress = ( ULONG_PTR )KdSearchSignature( ( PVOID )( ( ULONG_PTR )ImageBase + ( ULONG_PTR )SectionTextBase ),
                                                              SectionTextSize,
                                                              "66 89 01 0F B7 05 ? ? ? ? 66 89 41 02" );

    if ( KeProcessorLevelAddress == 0 ) {

        return STATUS_UNSUCCESSFUL;
    }

    KeProcessorLevel = ( PUSHORT )( KeProcessorLevelAddress + 10 + ( LONG32 )DbgKdRead32( ( ULONG32* )( KeProcessorLevelAddress + 6 ) ) );


    KdEncodeDataBlockAddress = ( ULONG_PTR )KdSearchSignature( ( PVOID )( ( ULONG_PTR )ImageBase + ( ULONG_PTR )SectionPageLKBase ),
                                                               SectionPageLKSize,
                                                               "E8 ? ? ? ? 33 DB 48 8D 8F ? ? ? ?" );

    KdEncodeDataBlockAddress =  KdEncodeDataBlockAddress + 5 + ( LONG64 )( LONG32 )DbgKdRead32( ( ULONG32* )( KdEncodeDataBlockAddress + 1 ) );

    KiWaitNeverAddress = KdEncodeDataBlockAddress + 12;
    KiWaitNeverAddress = ( ULONG64 )( KiWaitNeverAddress + 4 + ( LONG64 )( LONG32 )DbgKdRead32( ( ULONG32* )KiWaitNeverAddress ) );
    KdpDataBlockEncodedAddress =  KdEncodeDataBlockAddress + 25;
    KdpDataBlockEncodedAddress = ( ULONG64 )( KdpDataBlockEncodedAddress + 5 + ( LONG64 )( LONG32 )DbgKdRead32( ( ULONG32* )KdpDataBlockEncodedAddress ) );
    KiWaitAlwaysAddress = KdEncodeDataBlockAddress + 49;
    KiWaitAlwaysAddress = ( ULONG64 )( KiWaitAlwaysAddress + 4 + ( LONG64 )( LONG32 )DbgKdRead32( ( ULONG32* )KiWaitAlwaysAddress ) );

    DbgKdMmCopyMemory( &KdDebuggerDataBlock,
        ( PVOID )KdDebuggerDataBlockAddress,
                       sizeof( KDDEBUGGER_DATA64 ),
                       MM_COPY_MEMORY_VIRTUAL,
                       NULL );
#if 0
    RtlCopyMemory( &KdDebuggerDataBlock,
        ( PVOID )KdDebuggerDataBlockAddress,
                   sizeof( KDDEBUGGER_DATA64 ) );
#endif

    KiWaitAlways = DbgKdRead64( ( ULONG64* )KiWaitAlwaysAddress );
    KiWaitNever = DbgKdRead64( ( ULONG64* )KiWaitNeverAddress );
#else
    KdDebuggerDataBlockAddress = ( ULONG64 )( KdCopyDataBlockAddress + 14 + *( LONG32 * )( KdCopyDataBlockAddress + 10 ) );


    KeProcessorLevelAddress = ( ULONG_PTR )KdSearchSignature( ( PVOID )( ( ULONG_PTR )ImageBase + ( ULONG_PTR )SectionTextBase ),
                                                              SectionTextSize,
                                                              "66 89 01 0F B7 05 ? ? ? ? 66 89 41 02" );

    if ( KeProcessorLevelAddress == 0 ) {

        return STATUS_UNSUCCESSFUL;
    }

    KeProcessorLevel = ( PUSHORT )( KeProcessorLevelAddress + 10 + *( LONG32* )( KeProcessorLevelAddress + 6 ) );

    KdEncodeDataBlockAddress = (ULONG_PTR)KdSearchSignature( ( PVOID )( ( ULONG_PTR )ImageBase + ( ULONG_PTR )SectionTextBase ),
                                                             SectionTextSize,
                                                             "80 3D ? ? ? ? ? 74 48");
    //KdEncodeDataBlockAddress = ( ULONG_PTR )KdSearchSignature( ( PVOID )( ( ULONG_PTR )ImageBase + ( ULONG_PTR )SectionPageLKBase ),
    //                                                           SectionPageLKSize,
    //                                                           "E8 ? ? ? ? 33 DB 48 8D 8F ? ? ? ?" );

    //KdEncodeDataBlockAddress =  KdEncodeDataBlockAddress + 5 + ( LONG64 )*( LONG32* )( KdEncodeDataBlockAddress + 1 );

    KiWaitNeverAddress = KdEncodeDataBlockAddress + 12;
    KiWaitNeverAddress = ( ULONG64 )( KiWaitNeverAddress + 4 + ( LONG64 )*( LONG32 * )( KiWaitNeverAddress ) );
    KdpDataBlockEncodedAddress =  KdEncodeDataBlockAddress + 25;
    KdpDataBlockEncodedAddress = ( ULONG64 )( KdpDataBlockEncodedAddress + 5 + ( LONG64 )*( LONG32* )( KdpDataBlockEncodedAddress ) );
    KiWaitAlwaysAddress = KdEncodeDataBlockAddress + 49;
    KiWaitAlwaysAddress = ( ULONG64 )( KiWaitAlwaysAddress + 4 + ( LONG64 )*( LONG32* )( KiWaitAlwaysAddress ) );

    /*
    DbgKdMmCopyMemory( &KdDebuggerDataBlock,
                       KdDebuggerDataBlockAddress,
                       sizeof( KDDEBUGGER_DATA64 ),
                       MM_COPY_MEMORY_VIRTUAL,
                       NULL );
    */
    RtlCopyMemory( &KdDebuggerDataBlock,
        ( PVOID )KdDebuggerDataBlockAddress,
                   sizeof( KDDEBUGGER_DATA64 ) );

    KiWaitAlways = *( PULONG64 )KiWaitAlwaysAddress;
    KiWaitNever = *( PULONG64 )KiWaitNeverAddress;
#endif

    //
    // DbgKdpDecodeDataBlock
    //

    //if ( DbgKdRead8( ( UCHAR* )KdpDataBlockEncodedAddress ) ) {
    if ( *( UCHAR* )KdpDataBlockEncodedAddress ) {


        Long = ( ULONG64* )&KdDebuggerDataBlock;
        Length = sizeof( KDDEBUGGER_DATA64 ) / sizeof( ULONG64 );

        while ( Length ) {

            *Long = KiWaitAlways ^
                _byteswap_uint64( KdpDataBlockEncodedAddress ^
                                  _rotl64( *Long ^ KiWaitNever, ( int )KiWaitNever ) );
            Long++;
            Length--;
        }
    }

    //
    // ASSUME: assumes that the guest can read our memory just fine, 
    // which should be the case really -- if necessary, a catch can be added
    // inside KdpReadVirtualMemory. We could tag root addresses using the sign
    // extended upper 16 bits
    //

    InitializeListHead( &KdpDebuggerDataListHead );
    InsertTailList( &KdpDebuggerDataListHead, ( PLIST_ENTRY )&KdDebuggerDataBlock.Header.List );

    KdDebuggerDataBlock.KernBase = ( ULONG64 )ImageBase;

    KdVersionBlock.Flags |= 1;

    KdVersionBlock.DebuggerDataList = ( ULONG64 )&KdpDebuggerDataListHead;
    KdVersionBlock.PsLoadedModuleList = KdDebuggerDataBlock.PsLoadedModuleList;
    KdVersionBlock.KernBase = KdDebuggerDataBlock.KernBase;

    NT_ASSERT( KdDebuggerDataBlock.Header.OwnerTag == 'GBDK' );
    NT_ASSERT( KdDebuggerDataBlock.Header.Size == 0x380 );

    //KdPrint( KD_STARTUP_SIG );

    //
    // TODO: Should require a page fault hook.
    //
#if 0
    KdVmwRpcInitialize( );
#endif
    //KdTryConnect( );
    //KdDebuggerNotPresent_ = FALSE;

    return STATUS_SUCCESS;
}

VOID
KdDriverUnload(

)
{

}
```

`kdpl/kdpl.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{19119F43-1A98-4692-A1D0-CAE716EAE5A1}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>kdpl</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.22621.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
      <AdditionalIncludeDirectories>$(ProjectDir)inc;$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <AdditionalIncludeDirectories>$(ProjectDir)inc;$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="comm\pci.c" />
    <ClCompile Include="comm\uart.c" />
    <ClCompile Include="comm\vmwrpc.c" />
    <ClCompile Include="kdapi.c" />
    <ClCompile Include="kdpl.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="inc\dbgkd.h" />
    <ClInclude Include="inc\kddef.h" />
    <ClInclude Include="inc\kdpl.h" />
    <ClInclude Include="inc\pci.h" />
    <ClInclude Include="inc\uart.h" />
    <ClInclude Include="inc\vmwrpc.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="comm\vmwrpc64.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`kdpl/kdpl.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="kdpl.c" />
    <ClCompile Include="comm\vmwrpc.c" />
    <ClCompile Include="kdapi.c" />
    <ClCompile Include="comm\uart.c" />
    <ClCompile Include="comm\pci.c" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="comm\vmwrpc64.asm" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="inc\kdpl.h" />
    <ClInclude Include="inc\vmwrpc.h" />
    <ClInclude Include="inc\dbgkd.h" />
    <ClInclude Include="inc\kddef.h" />
    <ClInclude Include="inc\uart.h" />
    <ClInclude Include="inc\pci.h" />
  </ItemGroup>
</Project>
```

`nokd.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.10.35013.160
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "kdpl", "kdpl\kdpl.vcxproj", "{19119F43-1A98-4692-A1D0-CAE716EAE5A1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Debug|ARM.ActiveCfg = Debug|ARM
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Debug|ARM.Build.0 = Debug|ARM
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Debug|ARM.Deploy.0 = Debug|ARM
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Debug|ARM64.Build.0 = Debug|ARM64
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Debug|x64.ActiveCfg = Debug|x64
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Debug|x64.Build.0 = Debug|x64
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Debug|x64.Deploy.0 = Debug|x64
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Debug|x86.ActiveCfg = Debug|Win32
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Debug|x86.Build.0 = Debug|Win32
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Debug|x86.Deploy.0 = Debug|Win32
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Release|ARM.ActiveCfg = Release|ARM
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Release|ARM.Build.0 = Release|ARM
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Release|ARM.Deploy.0 = Release|ARM
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Release|ARM64.ActiveCfg = Release|ARM64
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Release|ARM64.Build.0 = Release|ARM64
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Release|ARM64.Deploy.0 = Release|ARM64
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Release|x64.ActiveCfg = Release|x64
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Release|x64.Build.0 = Release|x64
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Release|x64.Deploy.0 = Release|x64
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Release|x86.ActiveCfg = Release|Win32
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Release|x86.Build.0 = Release|Win32
		{19119F43-1A98-4692-A1D0-CAE716EAE5A1}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {860FD042-D0F1-4EA4-8B62-7FC5D9D87771}
	EndGlobalSection
EndGlobal

```