Project Path: arc_cdpred_RedTalaria_biw4as6w

Source Tree:

```txt
arc_cdpred_RedTalaria_biw4as6w
├── CHANGELOG.md
├── CONTRIBUTORS.md
├── Content
│   └── Editor
│       └── Slate
│           ├── RedTalaria_16.png
│           └── attribution.txt
├── LICENSE.txt
├── README.md
├── README_link_behavior_tree_node_focus.png
├── README_link_blueprint_node_focus.png
├── README_link_blueprint_node_jump_target.png
├── README_link_content_folder_1.png
├── README_link_content_folder_2.png
├── README_link_level_actor_from_outliner.png
├── README_link_level_actor_from_viewport.png
├── README_link_level_at_camera_coords.png
├── RedTalaria.uplugin
├── Resources
│   ├── Icon128.png
│   └── attribution.txt
└── Source
    ├── RedHermesAutomationEndpoint
    │   ├── Private
    │   │   ├── RedHermesAutomationEndpoint.cpp
    │   │   └── RedHermesAutomationEndpointModule.cpp
    │   ├── Public
    │   │   └── RedHermesAutomationEndpoint.h
    │   └── RedHermesAutomationEndpoint.Build.cs
    ├── RedHermesBehaviorTreeNodeEndpoint
    │   ├── Private
    │   │   └── RedHermesBehaviorTreeNodeEndpoint.cpp
    │   ├── Public
    │   │   └── RedHermesBehaviorTreeNodeEndpoint.h
    │   └── RedHermesBehaviorTreeNodeEndpoint.Build.cs
    ├── RedHermesBlueprintNodeEndpoint
    │   ├── Private
    │   │   └── RedHermesBlueprintNodeEndpoint.cpp
    │   ├── Public
    │   │   └── RedHermesBlueprintNodeEndpoint.h
    │   └── RedHermesBlueprintNodeEndpoint.Build.cs
    ├── RedHermesContentFolderEndpoint
    │   ├── Private
    │   │   ├── RedHermesContentFolderEndpoint.cpp
    │   │   ├── RedHermesContentFolderEndpointEditorExtension.cpp
    │   │   └── RedHermesContentFolderEndpointModule.cpp
    │   ├── Public
    │   │   ├── RedHermesContentFolderEndpoint.h
    │   │   ├── RedHermesContentFolderEndpointEditorExtension.h
    │   │   └── RedHermesContentFolderEndpointModule.h
    │   └── RedHermesContentFolderEndpoint.Build.cs
    ├── RedHermesGraphNodeEndpoint
    │   ├── Private
    │   │   ├── RedHermesGraphNodeEndpoint.cpp
    │   │   ├── RedHermesGraphNodeEndpointEditorExtension.cpp
    │   │   ├── RedHermesGraphNodeEndpointModule.cpp
    │   │   └── RedHermesGraphNodeEndpointUtils.cpp
    │   ├── Public
    │   │   ├── RedHermesGraphNodeEndpoint.h
    │   │   ├── RedHermesGraphNodeEndpointEditorExtension.h
    │   │   ├── RedHermesGraphNodeEndpointModule.h
    │   │   └── RedHermesGraphNodeEndpointUtils.h
    │   └── RedHermesGraphNodeEndpoint.Build.cs
    ├── RedHermesLevelActorEndpoint
    │   ├── Private
    │   │   ├── RedHermesLevelActorEndpoint.cpp
    │   │   ├── RedHermesLevelActorEndpointEditorExtension.cpp
    │   │   └── RedHermesLevelActorEndpointModule.cpp
    │   ├── Public
    │   │   ├── RedHermesLevelActorEndpoint.h
    │   │   └── RedHermesLevelActorEndpointEditorExtension.h
    │   └── RedHermesLevelActorEndpoint.Build.cs
    ├── RedHermesLevelAtCameraCoordsEndpoint
    │   ├── Private
    │   │   ├── RedHermesLevelAtCameraCoordsEndpoint.cpp
    │   │   ├── RedHermesLevelAtCameraCoordsEndpointEditorExtension.cpp
    │   │   └── RedHermesLevelAtCameraCoordsEndpointModule.cpp
    │   ├── Public
    │   │   ├── RedHermesLevelAtCameraCoordsEndpoint.h
    │   │   ├── RedHermesLevelAtCameraCoordsEndpointEditorExtension.h
    │   │   └── RedHermesLevelAtCameraCoordsEndpointModule.h
    │   └── RedHermesLevelAtCameraCoordsEndpoint.Build.cs
    ├── RedTalaria
    │   ├── Private
    │   │   ├── RedHermesEndpoint.cpp
    │   │   └── RedTalaria.cpp
    │   ├── Public
    │   │   ├── RedHermesEndpoint.h
    │   │   └── RedTalaria.h
    │   └── RedTalaria.Build.cs
    └── RedTalariaUrls
        ├── Private
        │   ├── RedTalariaAutomationUrls.cpp
        │   ├── RedTalariaContentFolderUrls.cpp
        │   ├── RedTalariaContentUrls.cpp
        │   ├── RedTalariaGraphNodeUrls.cpp
        │   ├── RedTalariaLevelActorUrls.cpp
        │   ├── RedTalariaLevelAtCameraCoordsUrls.cpp
        │   └── RedTalariaUrls.cpp
        ├── Public
        │   ├── RedTalariaAutomationUrls.h
        │   ├── RedTalariaContentFolderUrls.h
        │   ├── RedTalariaContentUrls.h
        │   ├── RedTalariaGraphNodeUrls.h
        │   ├── RedTalariaLevelActorUrls.h
        │   ├── RedTalariaLevelAtCameraCoordsUrls.h
        │   └── RedTalariaUrls.h
        └── RedTalariaUrls.Build.cs

```

`CHANGELOG.md`:

```md
# Version 1.3.0

New functionality:
* linking level actors
* linking automated tests

Misc:
* LevelAtCameraCoordsEndpoint: don't (re)load the linked level if it's already opened in the editor
* Add `FRedTalariaContentUrls::GetUrlForPackage`
* various compilation and code style fixes

# Version 1.2.0

New functionality:
* linking BehaviorTree nodes

Misc:
* general cleanup, formatting & IWYU pass

# Version 1.1.0

New functionality:
* linking folders in the content browser

# Version 1.0.1

New functionality:
* allow linking Blueprint comment nodes

# Version 1.0

Endpoints provided:
* linking Blueprint nodes
	- focus node
	- open the jump target of the node
* linking levels at specific camera coordinates

```

`CONTRIBUTORS.md`:

```md
<!-- Please keep this list sorted alphabetically (case-insensitive). -->

* [ezioleq](https://github.com/ezioleq)
* [fastfend](https://github.com/fastfend)
* [jorgenpt](https://github.com/jorgenpt)
* [KristofMorva](https://github.com/KristofMorva)
* [liquidev](https://github.com/liquidev)
* [MeetMarkelov](https://github.com/MeetMarkelov)
* [zosiu](https://github.com/zosiu)

```

`Content/Editor/Slate/attribution.txt`:

```txt
Hermes icons (RedTalaria_16.png) created by max.icons - Flaticon : https://www.flaticon.com/free-icons/hermes
```

`LICENSE.txt`:

```txt
MIT License

Copyright (c) 2022 CD PROJEKT S.A.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# RedTalaria URLs for Unreal Engine

RedTalaria is a plugin for Unreal Engine that builds on [Hermes](https://github.com/jorgenpt/Hermes) and provides a collection of Hermes endpoints to link "parts" of your project and share them with your team e.g. through Slack.

Big thanks to [Jørgen P. Tjernø](https://github.com/jorgenpt) for [Hermes](https://github.com/jorgenpt/Hermes)!

# Engine compatibilty

RedTalaria was tested (and thus should be compatible) with UE 5.3 and UE 4.27.

# Setup

1. Setup [Hermes](https://github.com/jorgenpt/Hermes#setup).
2. Clone this repository into your project's Plugins folder.
3. Start your editor and enjoy your new Hermes endpoints.

# Using

## Linking Blueprint nodes
Once you've set up RedTalaria, you should be able to right click on any Blueprint node and see a new `Copy 'Focus node' URL` option:

[<img src="README_link_blueprint_node_focus.png?raw=true">](README_link_blueprint_node_focus.png?raw=true)

Clicking on links like these will open up the asset in the editor and focus on the linked node.

---

For nodes that have a jump target, you'll see an additional `Copy 'Open node' URL` option:

[<img src="README_link_blueprint_node_jump_target.png?raw=true">](README_link_blueprint_node_jump_target.png?raw=true)

Clicking on links like these will open up the (jump target of the) linked node in the editor.

## Linking BehaviorTree nodes
This feature is only available in UE 5.3+, if you are using a source build, make sure you have [this commit](https://github.com/EpicGames/UnrealEngine/commit/6bb52ead8294554e5bdb60f637729eae397942d8).

Once you've set up RedTalaria, you should be able to right click on any BehaviorTree node and see a new `Copy 'Focus node' URL` option:

[<img src="README_link_behavior_tree_node_focus.png?raw=true">](README_link_behavior_tree_node_focus.png?raw=true)

Clicking on links like these will open up the asset in the editor and focus on the linked node.

## Linking Levels at a specific camera position
Once you've set up RedTalaria, under the Viewport options menu you should see a new `Copy camera coords URL` option (it will only be active for perspective viewports):

[<img src="README_link_level_at_camera_coords.png?raw=true">](README_link_level_at_camera_coords.png?raw=true)

Clicking on links like these will open up the level at the exact camera location / rotation for when the link was made.

## Linking folders in the content browser

Once you've set up RedTalaria, when right clicking on a folder in the content browser you should see a new `Copy folder URL` option:

[<img src="README_link_content_folder_1.png?raw=true">](README_link_content_folder_1.png?raw=true)
[<img src="README_link_content_folder_2.png?raw=true">](README_link_content_folder_2.png?raw=true)

Clicking on links like these will focus the given folder in the content browser.

## Linking level actors
This feature is only available in UE 5.3+, and only for actors with external packaging ([OFPA](https://docs.unrealengine.com/5.3/en-US/one-file-per-actor-in-unreal-engine/)).

Once you've set up RedTalaria, you should be able to right click on any actor placed in a level or in the outliner and see a new `Copy selected actor URL(s)` option:

[<img src="README_link_level_actor_from_viewport.png?raw=true">](README_link_level_actor_from_viewport.png?raw=true)
[<img src="README_link_level_actor_from_outliner.png?raw=true">](README_link_level_actor_from_outliner.png?raw=true)

Clicking on links like these will open up the level the actor is placed in, select the actor in the outliner and focus the camera on the actor.
If the level is partitioned, the actor will be loaded (even if it resides in a currently unloaded region).

## Linking automated tests
This feature is only available in UE 5+.

Once you've set up RedTalaria, you should be able to link automated tests like so:
```
YOUR_PROJECT://automation?test_name_filter=YOUR_TEST_NAME_FILTER_STRING_URL_ENCODED
```
Spaces in the test name filter have to be encoded as `%20`.

Clicking on links like these will open up the session frontend window and execute all tests matching the given test name filter.

Example links to engine provided tests (for UE 5.3 projects):
* `YOUR_PROJECT://automation?test_name_filter=TestFramework.Log.Add%20Log%20Message` (runs one test)
* `YOUR_PROJECT://automation?test_name_filter=TestFramework.Log` (runs 3 tests)

# Extending

## Creating custom URLs for graph nodes
Take a look at [RedHermesGraphNodeEndpoint](Source/RedHermesGraphNodeEndpoint/Public/RedHermesGraphNodeEndpoint.h) & [RedHermesGraphNodeEndpointEditorExtension](Source/RedHermesGraphNodeEndpoint/Public/RedHermesGraphNodeEndpointEditorExtension.h), which serve as a base for linking graph nodes, and
[RedHermesBlueprintNodeEndpoint](Source/RedHermesBlueprintNodeEndpoint/Public/RedHermesBlueprintNodeEndpoint.h) as a concrete example building on them.

## Creating custom URLs with your own functionality
Take a look at [RedHermesEndpoint](Source/RedTalaria/Public/RedHermesEndpoint.h), which serves as a base for custom Hermes endpoints, and [RedHermesLevelAtCameraCoordsEndpoint](Source/RedHermesLevelAtCameraCoordsEndpoint/Public/RedHermesLevelAtCameraCoordsEndpoint.h) & [RedHermesLevelAtCameraCoordsEndpointEditorExtension](Source/RedHermesLevelAtCameraCoordsEndpoint/Public/RedHermesLevelAtCameraCoordsEndpointEditorExtension.h) as a concrete example building on it.

# License

Hermes icons ([Icon128.png](Resources/Icon128.png) & [RedTalaria_16.png](Content/Editor/Slate/RedTalaria_16.png)) created by max.icons - [Flaticon](https://www.flaticon.com/free-icons/hermes).

RedTalaria is licensed under the MIT license ([LICENSE](LICENSE.txt) or http://opensource.org/licenses/MIT).

```

`RedTalaria.uplugin`:

```uplugin
{
	"FileVersion": 3,
	"Version": 1,
	"VersionName": "1.1.0",
	"FriendlyName": "RedTalaria",
	"Description": "A collection of Hermes endpoints. Hermes icons created by max.icons - Flaticon : https://www.flaticon.com/free-icons/hermes",
	"Category": "Other",
	"CreatedBy": "CD PROJEKT S.A.",
	"CreatedByURL": "",
	"DocsURL": "",
	"MarketplaceURL": "",
	"SupportURL": "",
	"CanContainContent": true,
	"IsBetaVersion": false,
	"IsExperimentalVersion": false,
	"Installed": false,
	"Modules": [
		{
			"Name": "RedTalariaUrls",
			"Type": "Runtime",
			"LoadingPhase": "Default"
		},
		{
			"Name": "RedTalaria",
			"Type": "EditorNoCommandlet",
			"LoadingPhase": "Default",
			"WhitelistPlatforms": [
				"Win64"
			]
		},
		{
			"Name": "RedHermesGraphNodeEndpoint",
			"Type": "EditorNoCommandlet",
			"LoadingPhase": "Default",
			"WhitelistPlatforms": [
				"Win64"
			]
		},
		{
			"Name": "RedHermesBlueprintNodeEndpoint",
			"Type": "EditorNoCommandlet",
			"LoadingPhase": "PostEngineInit",
			"WhitelistPlatforms": [
				"Win64"
			]
		},
		{
			"Name": "RedHermesBehaviorTreeNodeEndpoint",
			"Type": "EditorNoCommandlet",
			"LoadingPhase": "PostEngineInit",
			"WhitelistPlatforms": [
				"Win64"
			]
		},
		{
			"Name": "RedHermesLevelAtCameraCoordsEndpoint",
			"Type": "EditorNoCommandlet",
			"LoadingPhase": "PostEngineInit",
			"WhitelistPlatforms": [
				"Win64"
			]
		},
		{
			"Name": "RedHermesContentFolderEndpoint",
			"Type": "EditorNoCommandlet",
			"LoadingPhase": "Default",
			"WhitelistPlatforms": [
				"Win64"
			]
		},
		{
			"Name": "RedHermesLevelActorEndpoint",
			"Type": "EditorNoCommandlet",
			"LoadingPhase": "Default",
			"WhitelistPlatforms": [
				"Win64"
			]
		}, 
		{
			"Name": "RedHermesAutomationEndpoint",
			"Type": "EditorNoCommandlet",
			"LoadingPhase": "Default",
			"WhitelistPlatforms": [
				"Win64"
			]
		}
	],
	"Plugins": [
		{
			"Name": "HermesCore",
			"Enabled": true,
			"WhitelistPlatforms": [
				"Win64"
			]
		}
	]
}

```

`Resources/attribution.txt`:

```txt
Hermes icons (Icon128.png) created by max.icons - Flaticon : https://www.flaticon.com/free-icons/hermes

```

`Source/RedHermesAutomationEndpoint/Private/RedHermesAutomationEndpoint.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedHermesAutomationEndpoint.h"

#include "RedTalariaAutomationUrls.h"
#include "Runtime/Launch/Resources/Version.h"

#if ENGINE_MAJOR_VERSION >= 5
#include "AutomationGroupFilter.h"
#include "Editor.h"
#include "IAutomationControllerModule.h"
#include "ISessionFrontendModule.h"
#include "TimerManager.h"
#include "GenericPlatform/GenericPlatformHttp.h"
#include "Misc/FilterCollection.h"
#endif

DEFINE_LOG_CATEGORY_STATIC(LogRedHermesAutomationEndpoint, Log, All);

void URedHermesAutomationEndpoint::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);
#if ENGINE_MAJOR_VERSION >= 5
	auto* AutomationControllerModule = &FModuleManager::LoadModuleChecked<IAutomationControllerModule>("AutomationController");
	AutomationController = AutomationControllerModule->GetAutomationController();
	AutomationController->Init();
	AutomationController->Startup();
#endif
}

FName URedHermesAutomationEndpoint::GetHermesEndpointId() const
{
	return FRedTalariaAutomationUrls::HermesEndpointId;
}

void URedHermesAutomationEndpoint::ProcessRequest(const FString& Path, const FHermesQueryParamsMap& QueryParams) const
{
#if ENGINE_MAJOR_VERSION >= 5
	if (!QueryParams.Contains(FRedTalariaAutomationUrls::TestNameFilterParamName))
	{
		return;
	}

	auto& SessionFrontend = FModuleManager::LoadModuleChecked<ISessionFrontendModule>("SessionFrontend");
	SessionFrontend.InvokeSessionFrontend(FName("AutomationPanel"));

	FString TestNameFilter = FGenericPlatformHttp::UrlDecode(QueryParams[FRedTalariaAutomationUrls::TestNameFilterParamName]).TrimStartAndEnd();
	FTimerHandle TimerHandle;
	const float Delay = (AutomationController->GetTestState() == EAutomationControllerModuleState::Ready) ? 1.f : 10.f;
	GEditor->GetTimerManager()->SetTimer(TimerHandle, FTimerDelegate::CreateUObject(this, &ThisClass::RunTestsWithNameFilter, MoveTemp(TestNameFilter)), Delay, false);
#endif
}

void URedHermesAutomationEndpoint::RunTestsWithNameFilter(FString TestNameFilter) const
{
#if ENGINE_MAJOR_VERSION >= 5
	if (TestNameFilter.IsEmpty())
	{
		return;
	}

	TArray<FAutomatedTestFilter> FiltersList;
	constexpr bool bMatchFromStart = false;
	constexpr bool bMatchFromEnd = false;

	FiltersList.Add(FAutomatedTestFilter(TestNameFilter, bMatchFromStart, bMatchFromEnd));
	FAutomationGroupFilter* FilterForGivenStr = new FAutomationGroupFilter();
	FilterForGivenStr->SetFilters(FiltersList);
	TSharedPtr<AutomationFilterCollection> AutomationFilters = MakeShareable(new AutomationFilterCollection());
	AutomationFilters->Add(MakeShareable(FilterForGivenStr));

	AutomationController->SetVisibleTestsEnabled(false);
	AutomationController->SetFilter(AutomationFilters);
	AutomationController->SetVisibleTestsEnabled(true);
	TArray<FString> FilteredTestNames;
	AutomationController->GetEnabledTestNames(FilteredTestNames);
	AutomationController->SetEnabledTests(FilteredTestNames);
	AutomationController->OnTestsRefreshed().Broadcast();

	AutomationController->RunTests();
#endif
}

```

`Source/RedHermesAutomationEndpoint/Private/RedHermesAutomationEndpointModule.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "Modules/ModuleManager.h"

IMPLEMENT_MODULE(FDefaultModuleImpl, RedHermesAutomationEndpoint);

```

`Source/RedHermesAutomationEndpoint/Public/RedHermesAutomationEndpoint.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "RedHermesEndpoint.h"

#include "IAutomationControllerManager.h"

#include "RedHermesAutomationEndpoint.generated.h"

UCLASS()
class REDHERMESAUTOMATIONENDPOINT_API URedHermesAutomationEndpoint : public URedHermesEndpoint
{
	GENERATED_BODY()
public:
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;

protected:
	virtual FName GetHermesEndpointId() const override;
	virtual void ProcessRequest(const FString& Path, const FHermesQueryParamsMap& QueryParams) const override;

private:
	IAutomationControllerManagerPtr AutomationController;
	FDelegateHandle TestAvailableHandle;

	void RunTestsWithNameFilter(FString TestNameFilter) const;
};

```

`Source/RedHermesAutomationEndpoint/RedHermesAutomationEndpoint.Build.cs`:

```cs
// Copyright (c) CD PROJEKT S.A.

using UnrealBuildTool;

public class RedHermesAutomationEndpoint : ModuleRules
{
	public RedHermesAutomationEndpoint(ReadOnlyTargetRules Target) : base(Target)
	{
		ShortName = "RedHermesAE";
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(
			new[]
			{
				"Core",
				"RedTalaria",
			}
		);

		PrivateDependencyModuleNames.AddRange(
			new[]
			{
				"AutomationController",
				"CoreUObject",
				"Engine",
				"HTTP",
				"RedTalariaUrls",
				"SessionFrontend",
				"Slate",
				"SlateCore",
				"UnrealEd",
			}
		);
	}
}

```

`Source/RedHermesBehaviorTreeNodeEndpoint/Private/RedHermesBehaviorTreeNodeEndpoint.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedHermesBehaviorTreeNodeEndpoint.h"

#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 3
#include "BehaviorTreeGraph.h"
#include "Editor.h"
#include "IBehaviorTreeEditor.h"
#include "RedHermesGraphNodeEndpoint.h"
#include "RedHermesGraphNodeEndpointEditorExtension.h"
#include "BehaviorTree/BehaviorTree.h"
#include "EdGraph/EdGraph.h"
#include "Toolkits/ToolkitManager.h"
#endif

#define LOCTEXT_NAMESPACE "FRedHermesBehaviorTreeNodeEndpointModule"

void FRedHermesBehaviorTreeNodeEndpointModule::StartupModule()
{
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 3
	if (const auto RedHermesGraphNodeEndpoint = GEditor->GetEditorSubsystem<URedHermesGraphNodeEndpoint>())
	{
		OnRequestDelegateHandle = RedHermesGraphNodeEndpoint->OnRequest().AddStatic(&FRedHermesBehaviorTreeNodeEndpointModule::HandleRequest);
	}

	if (const auto NodeExtensionSubsystem = GEditor->GetEditorSubsystem<URedHermesGraphNodeEndpointEditorExtension>())
	{
		OnNodeMenuExtensionHookRequestDelegateHandle = NodeExtensionSubsystem->OnNodeMenuExtensionHookRequest().AddStatic(&FRedHermesBehaviorTreeNodeEndpointModule::ProvideNodeExtensionHook);
	}
#endif
}

void FRedHermesBehaviorTreeNodeEndpointModule::ShutdownModule()
{
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 3
	if (OnRequestDelegateHandle.IsValid())
	{
		if (GEditor != nullptr)
		{
			if (const auto RedHermesGraphNodeEndpoint = GEditor->GetEditorSubsystem<URedHermesGraphNodeEndpoint>())
			{
				RedHermesGraphNodeEndpoint->OnRequest().Remove(OnRequestDelegateHandle);
			}
			OnRequestDelegateHandle.Reset();
		}
	}

	if (OnNodeMenuExtensionHookRequestDelegateHandle.IsValid())
	{
		if (GEditor != nullptr)
		{
			if (const auto NodeExtensionSubsystem = GEditor->GetEditorSubsystem<URedHermesGraphNodeEndpointEditorExtension>())
			{
				NodeExtensionSubsystem->OnNodeMenuExtensionHookRequest().Remove(OnNodeMenuExtensionHookRequestDelegateHandle);
			}
			OnNodeMenuExtensionHookRequestDelegateHandle.Reset();
		}
	}
#endif
}

#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 3
UEdGraphNode* FRedHermesBehaviorTreeNodeEndpointModule::GetNodeInAsset(FGuid NodeGuid, const UObject* Asset)
{

	if (const auto BehaviorTreeObj = Cast<UBehaviorTree>(Asset))
	{
		for (UEdGraphNode* Node : BehaviorTreeObj->BTGraph->Nodes)
		{
			if (Node->NodeGuid == NodeGuid)
			{
				return Node;
			}
		}
	}

	return nullptr;
}

void FRedHermesBehaviorTreeNodeEndpointModule::HandleRequest(FGuid NodeGuid, UObject* Asset, bool bOpenJumpTarget)
{
	if (UEdGraphNode* Node = GetNodeInAsset(NodeGuid, Asset))
	{
		GEditor->GetEditorSubsystem<UAssetEditorSubsystem>()->OpenEditorForAsset(Asset);
		TSharedPtr<IToolkit> FoundAssetEditor = FToolkitManager::Get().FindEditorForAsset(Asset);
		if (FoundAssetEditor.IsValid())
		{
			auto BehaviorTreeEditor = StaticCastSharedPtr<IBehaviorTreeEditor>(FoundAssetEditor);
			BehaviorTreeEditor->FocusWindow();
			bOpenJumpTarget ? BehaviorTreeEditor->DoubleClickNode(Node) : BehaviorTreeEditor->FocusAttentionOnNode(Node);
		}
	}
}

void FRedHermesBehaviorTreeNodeEndpointModule::ProvideNodeExtensionHook(const UEdGraphNode* Node, const UEdGraph* /*Graph*/, TSet<FName>& ExtensionHooks)
{
	// Determinate that Node is a UBehaviorTreeGraphNode
	// Can't use UBehaviorTreeGraphNode::StaticClass(), because it's not exposed to API
	if (Node->GetGraph()->IsA<UBehaviorTreeGraph>())
	{
		ExtensionHooks.Emplace(FName(TEXT("BehaviorTreeGraphSchemaNodeActions")));
	}
}
#endif

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FRedHermesBehaviorTreeNodeEndpointModule, RedHermesBehaviorTreeNodeEndpoint)

```

`Source/RedHermesBehaviorTreeNodeEndpoint/Public/RedHermesBehaviorTreeNodeEndpoint.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

// The engine commit that is needed for this to work: https://github.com/EpicGames/UnrealEngine/commit/6bb52ead8294554e5bdb60f637729eae397942d8 .

#include "Modules/ModuleInterface.h"
#include "Runtime/Launch/Resources/Version.h"

#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 3
#include "Delegates/IDelegateInstance.h"
#include "UObject/NameTypes.h"

class UObject;
class UEdGraphNode;
class UEdGraph;
#endif

class FRedHermesBehaviorTreeNodeEndpointModule : public IModuleInterface
{
public:
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;

private:
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 3
	FDelegateHandle OnRequestDelegateHandle;
	FDelegateHandle OnNodeMenuExtensionHookRequestDelegateHandle;

	static UEdGraphNode* GetNodeInAsset(FGuid NodeGuid, const UObject* Asset);
	static void HandleRequest(FGuid NodeGuid, UObject* Asset, bool bOpenJumpTarget);
	static void ProvideNodeExtensionHook(const UEdGraphNode* Node, const UEdGraph* Graph, TSet<FName>& ExtensionHooks);
#endif
};

```

`Source/RedHermesBehaviorTreeNodeEndpoint/RedHermesBehaviorTreeNodeEndpoint.Build.cs`:

```cs
// Copyright (c) CD PROJEKT S.A.

using UnrealBuildTool;

public class RedHermesBehaviorTreeNodeEndpoint : ModuleRules
{
	public RedHermesBehaviorTreeNodeEndpoint(ReadOnlyTargetRules Target) : base(Target)
	{
		ShortName = "RedHermesBTNE";
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(
			new[]
			{
				"Core",
				"AIModule",
			}
		);

		PrivateDependencyModuleNames.AddRange(
			new[]
			{
				"CoreUObject",
				"Engine",
				"Slate",
				"SlateCore",
				"UnrealEd",
				"RedHermesGraphNodeEndpoint",
				"AIGraph",
				"BehaviorTreeEditor",
			}
		);

		BuildVersion Version;
		if (BuildVersion.TryRead(BuildVersion.GetDefaultFileName(), out Version))
		{
			if (Version.MajorVersion >= 5)
			{
				PrivateDependencyModuleNames.Add("EditorFramework");
			}
		}
	}
}

```

`Source/RedHermesBlueprintNodeEndpoint/Private/RedHermesBlueprintNodeEndpoint.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedHermesBlueprintNodeEndpoint.h"

#include "EdGraph/EdGraph.h"
#include "EdGraphNode_Comment.h"
#include "Editor.h"
#include "K2Node.h"
#include "Kismet2/KismetEditorUtilities.h"
#include "RedHermesGraphNodeEndpoint.h"
#include "RedHermesGraphNodeEndpointEditorExtension.h"

#define LOCTEXT_NAMESPACE "FRedHermesBlueprintNodeEndpointModule"

void FRedHermesBlueprintNodeEndpointModule::StartupModule()
{
	if (const auto RedHermesGraphNodeEndpoint = GEditor->GetEditorSubsystem<URedHermesGraphNodeEndpoint>())
	{
		OnRequestDelegateHandle = RedHermesGraphNodeEndpoint->OnRequest().AddStatic(&FRedHermesBlueprintNodeEndpointModule::HandleRequest);
	}

	if (const auto NodeExtensionSubsystem = GEditor->GetEditorSubsystem<URedHermesGraphNodeEndpointEditorExtension>())
	{
		OnNodeMenuExtensionHookRequestDelegateHandle = NodeExtensionSubsystem->OnNodeMenuExtensionHookRequest().AddStatic(&FRedHermesBlueprintNodeEndpointModule::ProvideNodeExtensionHook);
	}
}

void FRedHermesBlueprintNodeEndpointModule::ShutdownModule()
{
	if (OnRequestDelegateHandle.IsValid())
	{
		if (GEditor != nullptr)
		{
			if (const auto RedHermesGraphNodeEndpoint = GEditor->GetEditorSubsystem<URedHermesGraphNodeEndpoint>())
			{
				RedHermesGraphNodeEndpoint->OnRequest().Remove(OnRequestDelegateHandle);
			}
			OnRequestDelegateHandle.Reset();
		}
	}

	if (OnNodeMenuExtensionHookRequestDelegateHandle.IsValid())
	{
		if (GEditor != nullptr)
		{
			if (const auto NodeExtensionSubsystem = GEditor->GetEditorSubsystem<URedHermesGraphNodeEndpointEditorExtension>())
			{
				NodeExtensionSubsystem->OnNodeMenuExtensionHookRequest().Remove(OnNodeMenuExtensionHookRequestDelegateHandle);
			}
			OnNodeMenuExtensionHookRequestDelegateHandle.Reset();
		}
	}
}

const UEdGraphNode* FRedHermesBlueprintNodeEndpointModule::GetNodeInAsset(FGuid NodeGuid, const UObject* Asset)
{
	if (const auto BlueprintObj = Cast<UBlueprint>(Asset))
	{
		TArray<UEdGraph*> Graphs;
		BlueprintObj->GetAllGraphs(Graphs);

		for (const UEdGraph* Graph : Graphs)
		{
			for (const UEdGraphNode* Node : Graph->Nodes)
			{
				if (Node->NodeGuid == NodeGuid)
				{
					return Node;
				}
			}
		}
	}

	return nullptr;
}

void FRedHermesBlueprintNodeEndpointModule::HandleRequest(FGuid NodeGuid, UObject* Asset, bool bOpenJumpTarget)
{
	if (const UEdGraphNode* Node = GetNodeInAsset(NodeGuid, Asset))
	{
		const UObject* JumpTarget = Node->GetJumpTargetForDoubleClick();
		FKismetEditorUtilities::BringKismetToFocusAttentionOnObject(bOpenJumpTarget && JumpTarget ? JumpTarget : Node, false);
	}
}

void FRedHermesBlueprintNodeEndpointModule::ProvideNodeExtensionHook(const UEdGraphNode* Node, const UEdGraph* /*Graph*/, TSet<FName>& ExtensionHooks)
{
	if (Node->IsA<UK2Node>() || Node->IsA<UEdGraphNode_Comment>())
	{
		ExtensionHooks.Emplace(FName(TEXT("EdGraphSchemaNodeActions")));
	}
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FRedHermesBlueprintNodeEndpointModule, RedHermesBlueprintNodeEndpoint)

```

`Source/RedHermesBlueprintNodeEndpoint/Public/RedHermesBlueprintNodeEndpoint.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "Delegates/IDelegateInstance.h"
#include "Modules/ModuleInterface.h"
#include "UObject/NameTypes.h"

class UObject;
class UEdGraphNode;
class UEdGraph;

class FRedHermesBlueprintNodeEndpointModule : public IModuleInterface
{
public:
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;

private:
	FDelegateHandle OnRequestDelegateHandle;
	FDelegateHandle OnNodeMenuExtensionHookRequestDelegateHandle;

	static const UEdGraphNode* GetNodeInAsset(FGuid NodeGuid, const UObject* Asset);
	static void HandleRequest(FGuid NodeGuid, UObject* Asset, bool bOpenJumpTarget);
	static void ProvideNodeExtensionHook(const UEdGraphNode* Node, const UEdGraph* Graph, TSet<FName>& ExtensionHooks);
};

```

`Source/RedHermesBlueprintNodeEndpoint/RedHermesBlueprintNodeEndpoint.Build.cs`:

```cs
// Copyright (c) CD PROJEKT S.A.

using UnrealBuildTool;

public class RedHermesBlueprintNodeEndpoint : ModuleRules
{
	public RedHermesBlueprintNodeEndpoint(ReadOnlyTargetRules Target) : base(Target)
	{
		ShortName = "RedHermesBNE";
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(
			new[]
			{
				"Core",
			}
		);

		PrivateDependencyModuleNames.AddRange(
			new[]
			{
				"CoreUObject",
				"Engine",
				"Slate",
				"SlateCore",
				"UnrealEd",
				"RedHermesGraphNodeEndpoint",
				"BlueprintGraph",
			}
		);
	}
}

```

`Source/RedHermesContentFolderEndpoint/Private/RedHermesContentFolderEndpoint.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedHermesContentFolderEndpoint.h"

#include "ContentBrowserModule.h"
#include "IContentBrowserSingleton.h"
#include "RedTalariaContentFolderUrls.h"

FName URedHermesContentFolderEndpoint::GetHermesEndpointId() const
{
	return FRedTalariaContentFolderUrls::HermesEndpointId;
}

void URedHermesContentFolderEndpoint::ProcessRequest(const FString& Path, const FHermesQueryParamsMap& QueryParams) const
{
	IContentBrowserSingleton& ContentBrowser = FModuleManager::LoadModuleChecked<FContentBrowserModule>("ContentBrowser").Get();
	ContentBrowser.SyncBrowserToFolders({Path});
}

```

`Source/RedHermesContentFolderEndpoint/Private/RedHermesContentFolderEndpointEditorExtension.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedHermesContentFolderEndpointEditorExtension.h"

#include "ContentBrowserMenuContexts.h"
#include "RedTalaria.h"
#include "RedTalariaContentFolderUrls.h"
#include "ToolMenus.h"
#include "HAL/PlatformApplicationMisc.h"
#include "Runtime/Launch/Resources/Version.h"

#define LOCTEXT_NAMESPACE "Editor.RedHermesContentFolderEndpointEditorExtension"

void URedHermesContentFolderEndpointEditorExtension::Initialize(FSubsystemCollectionBase& Collection)
{
	RegisterContentBrowserFolderContextExtender();
}

void URedHermesContentFolderEndpointEditorExtension::Deinitialize()
{
	UnregisterContentBrowserFolderContextExtender();
}

void URedHermesContentFolderEndpointEditorExtension::RegisterContentBrowserFolderContextExtender()
{
	FToolMenuOwnerScoped ToolMenuOwnerScoped(this);

	FToolUIAction CopyLinkToFolderAction;
	CopyLinkToFolderAction.ExecuteAction.BindLambda([](const FToolMenuContext& MenuContext) {
		if (const UContentBrowserDataMenuContext_FolderMenu* Context = GetContextWithSingleFolderSelected(MenuContext))
		{
			FPlatformApplicationMisc::ClipboardCopy(
#if ENGINE_MAJOR_VERSION >= 5
				*FRedTalariaContentFolderUrls::GetUrlForContentFolder(Context->SelectedItems[0].GetInvariantPath())
#else
				*FRedTalariaContentFolderUrls::GetUrlForContentFolder(Context->SelectedItems[0].GetVirtualPath())
#endif
			);
		}
	});
	CopyLinkToFolderAction.CanExecuteAction.BindLambda([](const FToolMenuContext& MenuContext) {
		return GetContextWithSingleFolderSelected(MenuContext) != nullptr;
	});

	if (UToolMenu* Menu = UToolMenus::Get()->ExtendMenu("ContentBrowser.FolderContextMenu"))
	{
		FToolMenuSection& Section = Menu->AddSection(
			TEXT("Hermes"),
			LOCTEXT("ContentBrowser.FolderContextMenu.Hermes", "Hermes"));
		Section.AddMenuEntry("CopyURL",
			LOCTEXT("ContentBrowser.FolderContextMenu.CopyFolderUrl", "Copy folder URL"),
			LOCTEXT("ContentBrowser.FolderContextMenu.CopyFolderUrlTooltip", "Copy an URL that will reveal this folder in the content browser."),
			FSlateIcon(FRedTalariaModule::SlateStyleSetName, FRedTalariaModule::TalariaIconSlateStyleName),
			CopyLinkToFolderAction);
	}
}

void URedHermesContentFolderEndpointEditorExtension::UnregisterContentBrowserFolderContextExtender()
{
	UToolMenus::UnregisterOwner(this);
}

const UContentBrowserDataMenuContext_FolderMenu* URedHermesContentFolderEndpointEditorExtension::GetContextWithSingleFolderSelected(const FToolMenuContext& MenuContext)
{
	if (const auto* Context = MenuContext.FindContext<UContentBrowserDataMenuContext_FolderMenu>())
	{
		if (Context->SelectedItems.Num() == 1 && Context->SelectedItems[0].IsFolder())
		{
			return Context;
		}
	}

	return nullptr;
}

#undef LOCTEXT_NAMESPACE

```

`Source/RedHermesContentFolderEndpoint/Private/RedHermesContentFolderEndpointModule.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedHermesContentFolderEndpointModule.h"

#include "Modules/ModuleManager.h"

#define LOCTEXT_NAMESPACE "FRedHermesContentFolderEndpointModule"

void FRedHermesContentFolderEndpointModule::StartupModule()
{
}

void FRedHermesContentFolderEndpointModule::ShutdownModule()
{
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FRedHermesContentFolderEndpointModule, RedHermesContentFolderEndpoint)

```

`Source/RedHermesContentFolderEndpoint/Public/RedHermesContentFolderEndpoint.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "RedHermesEndpoint.h"

#include "RedHermesContentFolderEndpoint.generated.h"

UCLASS()
class REDHERMESCONTENTFOLDERENDPOINT_API URedHermesContentFolderEndpoint : public URedHermesEndpoint
{
	GENERATED_BODY()

protected:
	virtual FName GetHermesEndpointId() const override;
	virtual void ProcessRequest(const FString& Path, const FHermesQueryParamsMap& QueryParams) const override;
};

```

`Source/RedHermesContentFolderEndpoint/Public/RedHermesContentFolderEndpointEditorExtension.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "EditorSubsystem.h"
#include "ToolMenuContext.h"

#include "RedHermesContentFolderEndpointEditorExtension.generated.h"

class UContentBrowserDataMenuContext_FolderMenu;

UCLASS()
class REDHERMESCONTENTFOLDERENDPOINT_API URedHermesContentFolderEndpointEditorExtension : public UEditorSubsystem
{
	GENERATED_BODY()

public:
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;

private:
	void RegisterContentBrowserFolderContextExtender();
	void UnregisterContentBrowserFolderContextExtender();

	static const UContentBrowserDataMenuContext_FolderMenu* GetContextWithSingleFolderSelected(const FToolMenuContext& MenuContext);
};

```

`Source/RedHermesContentFolderEndpoint/Public/RedHermesContentFolderEndpointModule.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "Modules/ModuleInterface.h"

class FRedHermesContentFolderEndpointModule : public IModuleInterface
{
public:
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

```

`Source/RedHermesContentFolderEndpoint/RedHermesContentFolderEndpoint.Build.cs`:

```cs
// Copyright (c) CD PROJEKT S.A.

using UnrealBuildTool;

public class RedHermesContentFolderEndpoint : ModuleRules
{
	public RedHermesContentFolderEndpoint(ReadOnlyTargetRules Target) : base(Target)
	{
		ShortName = "RedHermesCFE";
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(
			new[]
			{
				"Core",
			}
		);

		PrivateDependencyModuleNames.AddRange(
			new[]
			{
				"CoreUObject",
				"Engine",
				"Slate",
				"SlateCore",
				"RedTalaria",
				"RedTalariaUrls",
				"EditorSubsystem",
				"ContentBrowserData",
				"ToolMenus",
				"ApplicationCore",
			}
		);
	}
}

```

`Source/RedHermesGraphNodeEndpoint/Private/RedHermesGraphNodeEndpoint.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedHermesGraphNodeEndpoint.h"

#include "RedTalariaGraphNodeUrls.h"
#include "AssetRegistry/AssetData.h"
#include "AssetRegistry/AssetRegistryModule.h"
#include "Interfaces/IMainFrameModule.h"
#include "Widgets/SWindow.h"

DEFINE_LOG_CATEGORY_STATIC(LogRedHermesGraphNodeEndpoint, Log, All);

FName URedHermesGraphNodeEndpoint::GetHermesEndpointId() const
{
	return FRedTalariaGraphNodeUrls::HermesEndpointId;
}

void URedHermesGraphNodeEndpoint::ProcessRequest(const FString& Path, const FHermesQueryParamsMap& QueryParams) const
{
	if (!QueryParams.Contains(FRedTalariaGraphNodeUrls::GuidQueryParamName))
	{
		UE_LOG(LogRedHermesGraphNodeEndpoint, Error, TEXT("%s query param is missing."), *FRedTalariaGraphNodeUrls::GuidQueryParamName);
		return;
	}

	const FGuid NodeGuid(QueryParams[FRedTalariaGraphNodeUrls::GuidQueryParamName]);

	const IAssetRegistry& AssetRegistry = FModuleManager::LoadModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry")).Get();
	TArray<FAssetData> AssetData;
	AssetRegistry.GetAssetsByPackageName(*Path, AssetData);

	if (AssetData.Num() > 0)
	{
		OnRequestDelegate.Broadcast(NodeGuid, AssetData[0].GetAsset(), QueryParams.Contains(FRedTalariaGraphNodeUrls::OpenJumpTargetQueryParamName));

		const IMainFrameModule& MainFrameModule = IMainFrameModule::Get();
		const TSharedPtr<SWindow> ParentWindow = MainFrameModule.GetParentWindow();
		if (ParentWindow.IsValid())
		{
			ParentWindow->ShowWindow();
			ParentWindow->GetNativeWindow()->HACK_ForceToFront();
		}
	}
	else
	{
		UE_LOG(LogRedHermesGraphNodeEndpoint, Error, TEXT("Failed loading asset for path %s."), *Path);
	}
}

```

`Source/RedHermesGraphNodeEndpoint/Private/RedHermesGraphNodeEndpointEditorExtension.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedHermesGraphNodeEndpointEditorExtension.h"

#include "Algo/AllOf.h"
#include "EdGraph/EdGraph.h"
#include "EdGraph/EdGraphNode.h"
#include "EdGraph/EdGraphPin.h"
#include "Framework/MultiBox/MultiBoxBuilder.h"
#include "GraphEditorModule.h"
#include "HAL/PlatformApplicationMisc.h"
#include "Modules/ModuleManager.h"
#include "RedHermesGraphNodeEndpointUtils.h"
#include "RedTalaria.h"

#define LOCTEXT_NAMESPACE "Editor.RedHermesGraphNodeEndpointEditorExtension"

const FName GraphEditorModuleName(TEXT("GraphEditor"));

void URedHermesGraphNodeEndpointEditorExtension::Initialize(FSubsystemCollectionBase& Collection)
{
	auto& GraphEditorModule = FModuleManager::LoadModuleChecked<FGraphEditorModule>(GraphEditorModuleName);
	GraphEditorModule.GetAllGraphEditorContextMenuExtender().Add(
		FGraphEditorModule::FGraphEditorMenuExtender_SelectedNode::CreateUObject(this, &ThisClass::HandleOnExtendGraphEditorContextMenu));
}

void URedHermesGraphNodeEndpointEditorExtension::Deinitialize()
{
	if (const auto GraphEditorModule = FModuleManager::GetModulePtr<FGraphEditorModule>(GraphEditorModuleName))
	{
		GraphEditorModule->GetAllGraphEditorContextMenuExtender().RemoveAll(
			[](const FGraphEditorModule::FGraphEditorMenuExtender_SelectedNode& Delegate) {
				const FName LocalFunction = GET_FUNCTION_NAME_CHECKED(ThisClass, HandleOnExtendGraphEditorContextMenu);
				return Delegate.TryGetBoundFunctionName() == LocalFunction;
			});
	}
}

TSharedRef<FExtender> URedHermesGraphNodeEndpointEditorExtension::HandleOnExtendGraphEditorContextMenu(
	const TSharedRef<FUICommandList> CommandList,
	const UEdGraph* Graph,
	const UEdGraphNode* Node,
	const UEdGraphPin* Pin,
	bool /* bIsConst */)
{
	TSharedRef<FExtender> Extender = MakeShared<FExtender>();

	TSet<FName> ExtensionHooks;
	OnNodeMenuExtensionHookRequestDelegate.Broadcast(Node, Graph, ExtensionHooks);

	for (const FName ExtensionHook : ExtensionHooks)
	{
		TArray<FCopyUrlMenuEntry> MenuEntries = {
			{LOCTEXT("NodeAction.CopyFocusUrl", "Copy 'Focus node' URL"),
				LOCTEXT("NodeAction.CopyFocusUrlTooltip", "Copy an URL that will open this asset and focus on this node."),
				FRedHermesGraphNodeEndpointUtils::GetFocusUrlForNodeInGraph(Node, Graph)},
			{LOCTEXT("NodeAction.CopyJumpTargetUrl", "Copy 'Open node' URL"),
				LOCTEXT("NodeAction.CopyJumpTargetUrlTooltip", "Copy an URL that will open (the jump target of) this node."),
				FRedHermesGraphNodeEndpointUtils::GetOpenJumpTargetUrlForNodeInGraph(Node, Graph)}};

		Extender->AddMenuExtension(
			ExtensionHook,
			EExtensionHook::Before,
			CommandList,
			FMenuExtensionDelegate::CreateStatic(&ThisClass::HandleOnExtendContextMenu, MoveTemp(MenuEntries)));
	}

	return Extender;
}

void URedHermesGraphNodeEndpointEditorExtension::HandleOnExtendContextMenu(FMenuBuilder& MenuBuilder, TArray<FCopyUrlMenuEntry> MenuEntries)
{
	if (Algo::AllOf(MenuEntries, [](const FCopyUrlMenuEntry& Entry) { return Entry.UrlToCopy.IsEmpty(); }))
	{
		return;
	}

	MenuBuilder.BeginSection(NAME_None, LOCTEXT("SectionName", "Hermes"));
	for (const FCopyUrlMenuEntry& Entry : MenuEntries)
	{
		if (!Entry.UrlToCopy.IsEmpty())
		{
			MenuBuilder.AddMenuEntry(
				Entry.Label,
				Entry.Tooltip,
				FSlateIcon(FRedTalariaModule::SlateStyleSetName, FRedTalariaModule::TalariaIconSlateStyleName),
				FUIAction(FExecuteAction::CreateLambda([UrlToCopy = Entry.UrlToCopy]() {
					FPlatformApplicationMisc::ClipboardCopy(*UrlToCopy);
				})));
		}
	}
	MenuBuilder.EndSection();
}

#undef LOCTEXT_NAMESPACE

```

`Source/RedHermesGraphNodeEndpoint/Private/RedHermesGraphNodeEndpointModule.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedHermesGraphNodeEndpointModule.h"

#include "Modules/ModuleManager.h"

void FRedHermesGraphNodeEndpointModule::StartupModule() {}

void FRedHermesGraphNodeEndpointModule::ShutdownModule() {}

IMPLEMENT_MODULE(FRedHermesGraphNodeEndpointModule, RedHermesGraphNodeEndpoint)

```

`Source/RedHermesGraphNodeEndpoint/Private/RedHermesGraphNodeEndpointUtils.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedHermesGraphNodeEndpointUtils.h"

#include "RedTalariaGraphNodeUrls.h"
#include "AssetRegistry/AssetData.h"
#include "AssetRegistry/AssetRegistryModule.h"
#include "AssetRegistry/IAssetRegistry.h"
#include "EdGraph/EdGraph.h"
#include "EdGraph/EdGraphNode.h"
#include "UObject/Package.h"

UObject* FRedHermesGraphNodeEndpointUtils::GetGraphOwnerAsset(const UEdGraph* Graph)
{
	if (!IsValid(Graph))
	{
		return nullptr;
	}

	// Basically, one of the outer parts of the graph is an asset.
	UObject* TestOuter = Graph->GetOuter();
	while (IsValid(TestOuter))
	{
		if (TestOuter->IsAsset())
		{
			return TestOuter;
		}

		TestOuter = TestOuter->GetOuter();
	}

	// If it is not referencing an asset from the graph,
	// search for the asset with the same name as the outermost object.
	const UObject* OutermostObject = nullptr;
	TestOuter = Graph->GetOuter();
	while (IsValid(TestOuter))
	{
		const UObject* OuterObject = TestOuter->GetOuter();
		const UPackage* TransientPackage = GetTransientPackage();
		if (IsValid(OuterObject) && IsValid(TransientPackage))
		{
			if (OuterObject->GetFullName().Equals(TransientPackage->GetFullName()))
			{
				OutermostObject = TestOuter;
			}
		}

		TestOuter = TestOuter->GetOuter();
	}

	if (!IsValid(OutermostObject))
	{
		return nullptr;
	}

	UObject* SameNameAsset = nullptr;
	const IAssetRegistry& AssetRegistry = FAssetRegistryModule::GetRegistry();
	AssetRegistry.EnumerateAllAssets(
		[&](const FAssetData& AssetData) -> bool {
			if (AssetData.AssetName == OutermostObject->GetFName())
			{
				SameNameAsset = AssetData.GetAsset();
				return false;
			}

			return true;
		});

	return SameNameAsset;
}

FString FRedHermesGraphNodeEndpointUtils::GetFocusUrlForNodeInGraph(const UEdGraphNode* Node, const UEdGraph* Graph)
{
	if (IsValid(Node) && IsValid(Graph))
	{
		if (const UObject* Asset = GetGraphOwnerAsset(Graph))
		{
			return FRedTalariaGraphNodeUrls::GetFocusUrlForNode(Asset->GetOutermost()->GetFName(), Node->NodeGuid);
		}
	}

	return FString();
}

FString FRedHermesGraphNodeEndpointUtils::GetOpenJumpTargetUrlForNodeInGraph(const UEdGraphNode* Node, const UEdGraph* Graph)
{
	if (IsValid(Node) && IsValid(Graph))
	{
		if (Node->GetJumpTargetForDoubleClick() != nullptr)
		{
			if (const UObject* Asset = GetGraphOwnerAsset(Graph))
			{
				return FRedTalariaGraphNodeUrls::GetOpenJumpTargetUrlForNode(Asset->GetOutermost()->GetFName(), Node->NodeGuid);
			}
		}
	}

	return FString();
}

```

`Source/RedHermesGraphNodeEndpoint/Public/RedHermesGraphNodeEndpoint.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "RedHermesEndpoint.h"

#include "RedHermesGraphNodeEndpoint.generated.h"

UCLASS()
class REDHERMESGRAPHNODEENDPOINT_API URedHermesGraphNodeEndpoint : public URedHermesEndpoint
{
	GENERATED_BODY()

public:
	DECLARE_MULTICAST_DELEGATE_ThreeParams(FOnReqestDelegate, FGuid NodeGuid, UObject* Asset, bool bOpenJumpTarget)

	FOnReqestDelegate& OnRequest()
	{
		return OnRequestDelegate;
	}

protected:
	virtual FName GetHermesEndpointId() const override;
	virtual void ProcessRequest(const FString& Path, const FHermesQueryParamsMap& QueryParams) const override;

private:
	FOnReqestDelegate OnRequestDelegate;
};

```

`Source/RedHermesGraphNodeEndpoint/Public/RedHermesGraphNodeEndpointEditorExtension.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "EditorSubsystem.h"

#include "RedHermesGraphNodeEndpointEditorExtension.generated.h"

class FMenuBuilder;
class FExtender;
class FUICommandList;
class UEdGraph;
class UEdGraphNode;
class UEdGraphPin;

UCLASS()
class REDHERMESGRAPHNODEENDPOINT_API URedHermesGraphNodeEndpointEditorExtension : public UEditorSubsystem
{
	GENERATED_BODY()

public:
	DECLARE_MULTICAST_DELEGATE_ThreeParams(FOnNodeMenuExtensionHookRequestDelegate, const UEdGraphNode*, const UEdGraph*, TSet<FName>&)

	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;

	FOnNodeMenuExtensionHookRequestDelegate& OnNodeMenuExtensionHookRequest() { return OnNodeMenuExtensionHookRequestDelegate; }

private:
	FOnNodeMenuExtensionHookRequestDelegate OnNodeMenuExtensionHookRequestDelegate;

	TSharedRef<FExtender> HandleOnExtendGraphEditorContextMenu(
		const TSharedRef<FUICommandList> CommandList,
		const UEdGraph* Graph,
		const UEdGraphNode* Node,
		const UEdGraphPin* Pin,
		bool bIsConst);

	struct FCopyUrlMenuEntry
	{
		FText Label;
		FText Tooltip;
		FString UrlToCopy;
	};

	static void HandleOnExtendContextMenu(FMenuBuilder& MenuBuilder, TArray<FCopyUrlMenuEntry> MenuEntries);
};

```

`Source/RedHermesGraphNodeEndpoint/Public/RedHermesGraphNodeEndpointModule.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "Modules/ModuleInterface.h"

class FRedHermesGraphNodeEndpointModule : public IModuleInterface
{
public:
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

```

`Source/RedHermesGraphNodeEndpoint/Public/RedHermesGraphNodeEndpointUtils.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "Containers/UnrealString.h"

class UEdGraph;
class UEdGraphNode;
class UObject;

class REDHERMESGRAPHNODEENDPOINT_API FRedHermesGraphNodeEndpointUtils
{
public:
	static UObject* GetGraphOwnerAsset(const UEdGraph* Graph);

	static FString GetFocusUrlForNodeInGraph(const UEdGraphNode* Node, const UEdGraph* Graph);
	static FString GetOpenJumpTargetUrlForNodeInGraph(const UEdGraphNode* Node, const UEdGraph* Graph);
};

```

`Source/RedHermesGraphNodeEndpoint/RedHermesGraphNodeEndpoint.Build.cs`:

```cs
// Copyright (c) CD PROJEKT S.A.

using UnrealBuildTool;

public class RedHermesGraphNodeEndpoint : ModuleRules
{
	public RedHermesGraphNodeEndpoint(ReadOnlyTargetRules Target) : base(Target)
	{
		ShortName = "RedHermesGNE";
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(
			new[]
			{
				"Core",
				"RedTalaria",
			}
		);

		PrivateDependencyModuleNames.AddRange(
			new[]
			{
				"ApplicationCore",
				"AssetRegistry",
				"CoreUObject",
				"Engine",
				"RedTalariaUrls",
				"Slate",
				"SlateCore",
				"ToolMenus",
				"UnrealEd",
				"EditorSubsystem",
				"MainFrame",
			}
		);
	}
}

```

`Source/RedHermesLevelActorEndpoint/Private/RedHermesLevelActorEndpoint.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedHermesLevelActorEndpoint.h"

#include "Editor.h"
#include "RedTalariaLevelActorUrls.h"
#include "AssetRegistry/AssetRegistryModule.h"
#include "Interfaces/IMainFrameModule.h"
#include "Subsystems/AssetEditorSubsystem.h"

#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 3
#include "WorldPartition/WorldPartition.h"
#include "WorldPartition/WorldPartitionHelpers.h"
#include "WorldPartition/LoaderAdapter/LoaderAdapterActorList.h"
#endif

DEFINE_LOG_CATEGORY_STATIC(LogRedHermesLevelActorEndpoint, Log, All);

#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 3
TMap<UWorldPartition*, TUniquePtr<FLoaderAdapterActorList>> URedHermesLevelActorEndpoint::LoaderAdapterActorListMap;
FDelegateHandle URedHermesLevelActorEndpoint::OnWorldPartitionUninitializedHandle;

void URedHermesLevelActorEndpoint::OnWorldPartitionUninitialized(UWorldPartition* InWorldPartition)
{
	if (auto* LoaderAdapterActorList = LoaderAdapterActorListMap.Find(InWorldPartition))
	{
		LoaderAdapterActorList->Get()->Unload();
	}

	LoaderAdapterActorListMap.Remove(InWorldPartition);
	if (LoaderAdapterActorListMap.IsEmpty())
	{
		InWorldPartition->GetWorld()->OnWorldPartitionUninitialized().Remove(OnWorldPartitionUninitializedHandle);
	}
}

void URedHermesLevelActorEndpoint::LoadActor(UWorldPartition* WorldPartition, FGuid ActorGuid)
{
	if (WorldPartition == nullptr)
	{
		return;
	}

	if (LoaderAdapterActorListMap.IsEmpty())
	{
		OnWorldPartitionUninitializedHandle = WorldPartition->GetWorld()->OnWorldPartitionUninitialized().AddStatic(&ThisClass::OnWorldPartitionUninitialized);
	}

	TUniquePtr<FLoaderAdapterActorList>& LoaderAdapterActorList = LoaderAdapterActorListMap.FindOrAdd(WorldPartition, MakeUnique<FLoaderAdapterActorList>(WorldPartition->GetWorld()));
	LoaderAdapterActorList->AddActors({ActorGuid});
}
#endif

FName URedHermesLevelActorEndpoint::GetHermesEndpointId() const
{
	return FRedTalariaLevelActorUrls::HermesEndpointId;
}

void URedHermesLevelActorEndpoint::ProcessRequest(const FString& Path, const FHermesQueryParamsMap& QueryParams) const
{
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 3
	const IAssetRegistry& AssetRegistry = FModuleManager::LoadModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry")).Get();
	TArray<FAssetData> AssetData;
	AssetRegistry.GetAssetsByPackageName(*Path, AssetData);

	if (AssetData.IsEmpty())
	{
		UE_LOG(LogRedHermesLevelActorEndpoint, Error, TEXT("Failed loading asset for path %s."), *Path);
		return;
	}

	const auto* Actor = Cast<AActor>(AssetData[0].GetAsset());
	if (Actor == nullptr)
	{
		UE_LOG(LogRedHermesLevelActorEndpoint, Error, TEXT("Asset for path %s is not an AActor."), *Path);
		return;
	}

	const UWorld* ActorWorld = Actor->GetWorld();
	if (ActorWorld == nullptr)
	{
		UE_LOG(LogRedHermesLevelActorEndpoint, Error, TEXT("World for actor %s is null."), *Actor->GetActorNameOrLabel());
		return;
	}

	if (GEditor->GetEditorWorldContext().World() != ActorWorld)
	{
		if (auto* AssetEditorSubsystem = GEditor->GetEditorSubsystem<UAssetEditorSubsystem>())
		{
			AssetEditorSubsystem->OpenEditorForAsset(ActorWorld);
		}
	}

	GEditor->GetTimerManager()->SetTimerForNextTick(FTimerDelegate::CreateLambda(
		[Path]() {
			TArray<FAssetData> AssetData;
			const IAssetRegistry& AssetRegistry = FModuleManager::LoadModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry")).Get();
			AssetRegistry.GetAssetsByPackageName(*Path, AssetData);

			if (auto* ActorToSelect = Cast<AActor>(AssetData[0].GetAsset()))
			{
				if (const UWorld* World = ActorToSelect->GetWorld())
				{
					if (World->IsPartitionedWorld())
					{
						LoadActor(FWorldPartitionHelpers::GetWorldPartition(ActorToSelect), ActorToSelect->GetActorGuid());
					}
				}

				FGlobalTabmanager::Get()->TryInvokeTab(FTabId(TEXT("LevelEditor")));

				GEditor->SelectNone(true, true);
				GEditor->SelectActor(ActorToSelect, true, true, true, true);
				GEditor->MoveViewportCamerasToActor(*ActorToSelect, false);
			}
		}));

	const IMainFrameModule& MainFrameModule = IMainFrameModule::Get();
	const TSharedPtr<SWindow> ParentWindow = MainFrameModule.GetParentWindow();

	if (ParentWindow.IsValid())
	{
		ParentWindow->ShowWindow();
		ParentWindow->GetNativeWindow()->HACK_ForceToFront();
	}
#endif
}

```

`Source/RedHermesLevelActorEndpoint/Private/RedHermesLevelActorEndpointEditorExtension.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedHermesLevelActorEndpointEditorExtension.h"

#include "LevelEditor.h"
#include "RedTalaria.h"
#include "RedTalariaLevelActorUrls.h"
#include "ToolMenus.h"
#include "HAL/PlatformApplicationMisc.h"
#include "Runtime/Launch/Resources/Version.h"

#define LOCTEXT_NAMESPACE "Editor.RedHermesLevelActorEndpointEditorExtension"

const FName LevelEditorModuleName(TEXT("LevelEditor"));

void URedHermesLevelActorEndpointEditorExtension::Initialize(FSubsystemCollectionBase& Collection)
{
	RegisterExtender();
}

void URedHermesLevelActorEndpointEditorExtension::Deinitialize()
{
	UnregisterExtender();
}

void URedHermesLevelActorEndpointEditorExtension::RegisterExtender()
{
	auto& LevelEditorModule = FModuleManager::Get().LoadModuleChecked<FLevelEditorModule>(LevelEditorModuleName);
	LevelEditorModule.GetAllLevelViewportContextMenuExtenders().Add(
		FLevelEditorModule::FLevelViewportMenuExtender_SelectedActors::CreateStatic(&ThisClass::HandleOnExtendLevelEditorActorContextMenu));
}

void URedHermesLevelActorEndpointEditorExtension::UnregisterExtender()
{
	if (auto* LevelEditorModule = FModuleManager::GetModulePtr<FLevelEditorModule>(LevelEditorModuleName))
	{
		LevelEditorModule->GetAllLevelViewportContextMenuExtenders().RemoveAll(
			[](const FLevelEditorModule::FLevelViewportMenuExtender_SelectedActors& Delegate) {
				const FName LocalFunction = GET_FUNCTION_NAME_CHECKED(ThisClass, HandleOnExtendLevelEditorActorContextMenu);
				return Delegate.TryGetBoundFunctionName() == LocalFunction;
			});
	}
}

TSharedRef<FExtender> URedHermesLevelActorEndpointEditorExtension::HandleOnExtendLevelEditorActorContextMenu(const TSharedRef<FUICommandList> CommandList, const TArray<AActor*> SelectedActors)
{
	TSharedRef<FExtender> Extender(new FExtender());

#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 3
	if (!SelectedActors.IsEmpty())
	{
		TArray<FString> ActorUrls;
		Algo::TransformIf(
			SelectedActors, ActorUrls,
			[](const AActor* Actor) {
				return (Actor != nullptr) && Actor->IsPackageExternal();
			},
			[](const AActor* Actor) {
				return FRedTalariaLevelActorUrls::GetUrlForLevelActor(Actor->GetPackage()->GetFName(), Actor->GetActorNameOrLabel());
			});
		FString URlsToCopy = FString::Join(ActorUrls, TEXT("\n"));

		Extender->AddMenuExtension(
			TEXT("ActorOptions"),
			EExtensionHook::Before,
			CommandList,
			FMenuExtensionDelegate::CreateStatic(&ThisClass::HandleOnExtendContextMenu, MoveTemp(URlsToCopy)));
	}
#endif

	return Extender;
}

void URedHermesLevelActorEndpointEditorExtension::HandleOnExtendContextMenu(FMenuBuilder& MenuBuilder, FString UrlsToCopy)
{
	if (UrlsToCopy.IsEmpty())
	{
		return;
	}

	MenuBuilder.BeginSection(NAME_None, LOCTEXT("SectionName", "Hermes"));
	MenuBuilder.AddMenuEntry(
		LOCTEXT("ActorAction.CopyHermesUrl", "Copy selected actor URL(s)"),
		LOCTEXT("ActorAction.CopyHermesUrlTooltip", "Copy an URL (for each selected actor) that will open this level and focus on that actor."),
		FSlateIcon(FRedTalariaModule::SlateStyleSetName, FRedTalariaModule::TalariaIconSlateStyleName),
		FUIAction(FExecuteAction::CreateLambda([UrlsToCopy]() {
			FPlatformApplicationMisc::ClipboardCopy(*UrlsToCopy);
		})));
	MenuBuilder.EndSection();
}

#undef LOCTEXT_NAMESPACE

```

`Source/RedHermesLevelActorEndpoint/Private/RedHermesLevelActorEndpointModule.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "Modules/ModuleManager.h"

IMPLEMENT_MODULE(FDefaultModuleImpl, RedHermesLevelActorEndpoint);

```

`Source/RedHermesLevelActorEndpoint/Public/RedHermesLevelActorEndpoint.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "Runtime/Launch/Resources/Version.h"

#include "RedHermesEndpoint.h"

#include "RedHermesLevelActorEndpoint.generated.h"

class UWorldPartition;
class FLoaderAdapterActorList;

UCLASS()
class URedHermesLevelActorEndpoint : public URedHermesEndpoint
{
	GENERATED_BODY()

protected:
	virtual FName GetHermesEndpointId() const override;
	virtual void ProcessRequest(const FString& Path, const FHermesQueryParamsMap& QueryParams) const override;

private:
#if ENGINE_MAJOR_VERSION >= 5 && ENGINE_MINOR_VERSION >= 3
	static TMap<UWorldPartition*, TUniquePtr<FLoaderAdapterActorList>> LoaderAdapterActorListMap;
	static FDelegateHandle OnWorldPartitionUninitializedHandle;

	static void OnWorldPartitionUninitialized(UWorldPartition* InWorldPartition);
	static void LoadActor(UWorldPartition* WorldPartition, FGuid ActorGuid);
#endif
};

```

`Source/RedHermesLevelActorEndpoint/Public/RedHermesLevelActorEndpointEditorExtension.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "EditorSubsystem.h"

#include "RedHermesLevelActorEndpointEditorExtension.generated.h"

class FExtender;
class FUICommandList;
class FMenuBuilder;
class AActor;

UCLASS()
class URedHermesLevelActorEndpointEditorExtension : public UEditorSubsystem
{
	GENERATED_BODY()

public:
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;

private:
	void RegisterExtender();
	void UnregisterExtender();

	static TSharedRef<FExtender> HandleOnExtendLevelEditorActorContextMenu(const TSharedRef<FUICommandList> CommandList, const TArray<AActor*> SelectedActors);
	static void HandleOnExtendContextMenu(FMenuBuilder& MenuBuilder, FString UrlsToCopy);
};

```

`Source/RedHermesLevelActorEndpoint/RedHermesLevelActorEndpoint.Build.cs`:

```cs
// Copyright (c) CD PROJEKT S.A.

using UnrealBuildTool;

public class RedHermesLevelActorEndpoint : ModuleRules
{
	public RedHermesLevelActorEndpoint(ReadOnlyTargetRules Target) : base(Target)
	{
		ShortName = "RedHermesLAE";
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(
			new[]
			{
				"Core",
				"RedTalaria",
			}
		);

		PrivateDependencyModuleNames.AddRange(
			new[]
			{
				"ApplicationCore",
				"CoreUObject",
				"EditorSubsystem",
				"Engine",
				"LevelEditor",
				"MainFrame",
				"RedTalariaUrls",
				"Slate",
				"SlateCore",
				"ToolMenus",
				"UnrealEd",
			}
		);
	}
}

```

`Source/RedHermesLevelAtCameraCoordsEndpoint/Private/RedHermesLevelAtCameraCoordsEndpoint.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedHermesLevelAtCameraCoordsEndpoint.h"

#include "Editor.h"
#include "LevelEditorViewport.h"
#include "RedTalariaLevelAtCameraCoordsUrls.h"
#include "AssetRegistry/AssetRegistryModule.h"
#include "Interfaces/IMainFrameModule.h"
#include "Subsystems/AssetEditorSubsystem.h"

DEFINE_LOG_CATEGORY_STATIC(LogRedHermesLevelAtCameraCoordsEndpoint, Log, All);

FName URedHermesLevelAtCameraCoordsEndpoint::GetHermesEndpointId() const
{
	return FRedTalariaLevelAtCameraCoordsUrls::HermesEndpointId;
}

void URedHermesLevelAtCameraCoordsEndpoint::ProcessRequest(const FString& Path, const FHermesQueryParamsMap& QueryParams) const
{
	const IAssetRegistry& AssetRegistry = FModuleManager::LoadModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry")).Get();
	TArray<FAssetData> AssetData;
	AssetRegistry.GetAssetsByPackageName(*Path, AssetData);

	if (AssetData.Num() > 0)
	{
		UObject* Asset = AssetData[0].GetAsset();
		if (auto* World = Cast<UWorld>(Asset))
		{
			if (GEditor->GetEditorWorldContext().World() != World)
			{
				if (auto* AssetEditorSubsystem = GEditor->GetEditorSubsystem<UAssetEditorSubsystem>())
				{
					AssetEditorSubsystem->OpenEditorForAsset(World);
				}
			}

			if (
				QueryParams.Contains(FRedTalariaLevelAtCameraCoordsUrls::CameraLocationXParamName) && //
				QueryParams.Contains(FRedTalariaLevelAtCameraCoordsUrls::CameraLocationYParamName) && //
				QueryParams.Contains(FRedTalariaLevelAtCameraCoordsUrls::CameraLocationZParamName) && //
				QueryParams.Contains(FRedTalariaLevelAtCameraCoordsUrls::CameraRotationPParamName) && //
				QueryParams.Contains(FRedTalariaLevelAtCameraCoordsUrls::CameraRotationYParamName) && //
				QueryParams.Contains(FRedTalariaLevelAtCameraCoordsUrls::CameraRotationRParamName))
			{
				for (FLevelEditorViewportClient* LevelVC : GEditor->GetLevelViewportClients())
				{
					if (LevelVC && LevelVC->IsPerspective())
					{
						LevelVC->SetViewLocation({
							FCString::Atof(*QueryParams[FRedTalariaLevelAtCameraCoordsUrls::CameraLocationXParamName]), //
							FCString::Atof(*QueryParams[FRedTalariaLevelAtCameraCoordsUrls::CameraLocationYParamName]), //
							FCString::Atof(*QueryParams[FRedTalariaLevelAtCameraCoordsUrls::CameraLocationZParamName])	//
						});
						LevelVC->SetViewRotation({
							FCString::Atof(*QueryParams[FRedTalariaLevelAtCameraCoordsUrls::CameraRotationPParamName]), //
							FCString::Atof(*QueryParams[FRedTalariaLevelAtCameraCoordsUrls::CameraRotationYParamName]), //
							FCString::Atof(*QueryParams[FRedTalariaLevelAtCameraCoordsUrls::CameraRotationRParamName])	//
						});
						break;
					}
				}
			}

			const IMainFrameModule& MainFrameModule = IMainFrameModule::Get();
			const TSharedPtr<SWindow> ParentWindow = MainFrameModule.GetParentWindow();

			if (ParentWindow.IsValid())
			{
				ParentWindow->ShowWindow();
				ParentWindow->GetNativeWindow()->HACK_ForceToFront();
			}
		}
		else
		{
			UE_LOG(LogRedHermesLevelAtCameraCoordsEndpoint, Error, TEXT("Asset for path %s is not a UWorld."), *Path);
		}
	}
	else
	{
		UE_LOG(LogRedHermesLevelAtCameraCoordsEndpoint, Error, TEXT("Failed loading asset for path %s."), *Path);
	}
}

```

`Source/RedHermesLevelAtCameraCoordsEndpoint/Private/RedHermesLevelAtCameraCoordsEndpointEditorExtension.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedHermesLevelAtCameraCoordsEndpointEditorExtension.h"

#include "LevelEditorMenuContext.h"
#include "LevelEditorViewport.h"
#include "RedTalaria.h"
#include "RedTalariaLevelAtCameraCoordsUrls.h"
#include "ToolMenus.h"
#include "HAL/PlatformApplicationMisc.h"

#define LOCTEXT_NAMESPACE "Editor.RedHermesLevelAtCameraCoordsEndpointEditorExtension"

void URedHermesLevelAtCameraCoordsEndpointEditorExtension::Initialize(FSubsystemCollectionBase& Collection)
{
	RegisterViewportOptionMenuExtender();
}

void URedHermesLevelAtCameraCoordsEndpointEditorExtension::Deinitialize()
{
	UnregisterViewportOptionMenuExtender();
}

void URedHermesLevelAtCameraCoordsEndpointEditorExtension::RegisterViewportOptionMenuExtender()
{
	FToolMenuOwnerScoped ToolMenuOwnerScoped(this);

	if (UToolMenu* Menu = UToolMenus::Get()->ExtendMenu("LevelEditor.LevelViewportToolBar.Options"))
	{
		static auto GetPerspectiveLevelEditorViewportClient = [](const FToolMenuContext& MenuContext) -> FLevelEditorViewportClient* {
			ULevelViewportToolBarContext* Context = MenuContext.FindContext<ULevelViewportToolBarContext>();
			if (Context && Context->LevelViewportToolBarWidget.IsValid())
			{
				FLevelEditorViewportClient* ViewportClient = Context->GetLevelViewportClient();
				if (ViewportClient && ViewportClient->ViewportType == LVT_Perspective)
				{
					return ViewportClient;
				}
			}

			return nullptr;
		};

		FToolUIAction CopyLinkToLevelAtCameraCoordsAction;
		CopyLinkToLevelAtCameraCoordsAction.ExecuteAction.BindLambda([](const FToolMenuContext& MenuContext) {
			if (const FLevelEditorViewportClient* ViewportClient = GetPerspectiveLevelEditorViewportClient(MenuContext))
			{
				const FName LevelPackageName = ViewportClient->GetWorld()->GetPackage()->GetFName();
				const FVector Location = ViewportClient->GetViewLocation();
				const FRotator Rotation = ViewportClient->GetViewRotation();
				FPlatformApplicationMisc::ClipboardCopy(
					*FRedTalariaLevelAtCameraCoordsUrls::GetUrlForLevelAtLocationAtRotation(LevelPackageName, Location, Rotation));
			}
		});
		CopyLinkToLevelAtCameraCoordsAction.CanExecuteAction.BindLambda([](const FToolMenuContext& MenuContext) {
			return GetPerspectiveLevelEditorViewportClient(MenuContext) != nullptr;
		});

		FToolMenuSection& Section = Menu->AddSection(
			TEXT("Hermes"),
			LOCTEXT("LevelViewportToolBar.Options.Hermes", "Hermes"),
			FToolMenuInsert(TEXT("LevelViewportViewportOptions"), EToolMenuInsertType::Before));
		Section.AddMenuEntry("CopyURL",
			LOCTEXT("ViewportAction.CopyCameraCoordsUrl", "Copy camera coords URL"),
			LOCTEXT("ViewportAction.CopyCameraCoordsUrlTooltip", "Copy an URL that will open this level at the current camera position"),
			FSlateIcon(FRedTalariaModule::SlateStyleSetName, FRedTalariaModule::TalariaIconSlateStyleName),
			CopyLinkToLevelAtCameraCoordsAction);
	}
}

void URedHermesLevelAtCameraCoordsEndpointEditorExtension::UnregisterViewportOptionMenuExtender()
{
	UToolMenus::UnregisterOwner(this);
}

#undef LOCTEXT_NAMESPACE

```

`Source/RedHermesLevelAtCameraCoordsEndpoint/Private/RedHermesLevelAtCameraCoordsEndpointModule.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedHermesLevelAtCameraCoordsEndpointModule.h"

#include "Modules/ModuleManager.h"

#define LOCTEXT_NAMESPACE "FRedHermesLevelAtCameraCoordsEndpointModule"

void FRedHermesLevelAtCameraCoordsEndpointModule::StartupModule() {}

void FRedHermesLevelAtCameraCoordsEndpointModule::ShutdownModule() {}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FRedHermesLevelAtCameraCoordsEndpointModule, RedHermesLevelAtCameraCoordsEndpoint)

```

`Source/RedHermesLevelAtCameraCoordsEndpoint/Public/RedHermesLevelAtCameraCoordsEndpoint.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "RedHermesEndpoint.h"

#include "RedHermesLevelAtCameraCoordsEndpoint.generated.h"

UCLASS()
class URedHermesLevelAtCameraCoordsEndpoint : public URedHermesEndpoint
{
	GENERATED_BODY()

protected:
	virtual FName GetHermesEndpointId() const override;
	virtual void ProcessRequest(const FString& Path, const FHermesQueryParamsMap& QueryParams) const override;
};

```

`Source/RedHermesLevelAtCameraCoordsEndpoint/Public/RedHermesLevelAtCameraCoordsEndpointEditorExtension.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "EditorSubsystem.h"

#include "RedHermesLevelAtCameraCoordsEndpointEditorExtension.generated.h"

UCLASS()
class URedHermesLevelAtCameraCoordsEndpointEditorExtension : public UEditorSubsystem
{
	GENERATED_BODY()

public:
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;

private:
	void RegisterViewportOptionMenuExtender();
	void UnregisterViewportOptionMenuExtender();
};

```

`Source/RedHermesLevelAtCameraCoordsEndpoint/Public/RedHermesLevelAtCameraCoordsEndpointModule.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "Modules/ModuleInterface.h"

class FRedHermesLevelAtCameraCoordsEndpointModule : public IModuleInterface
{
public:
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

```

`Source/RedHermesLevelAtCameraCoordsEndpoint/RedHermesLevelAtCameraCoordsEndpoint.Build.cs`:

```cs
// Copyright (c) CD PROJEKT S.A.

using UnrealBuildTool;

public class RedHermesLevelAtCameraCoordsEndpoint : ModuleRules
{
	public RedHermesLevelAtCameraCoordsEndpoint(ReadOnlyTargetRules Target) : base(Target)
	{
		ShortName = "RedHermesLACCE";
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(
			new[]
			{
				"Core",
				"RedTalaria",
			}
		);

		PrivateDependencyModuleNames.AddRange(
			new[]
			{
				"CoreUObject",
				"Engine",
				"Slate",
				"SlateCore",
				"RedTalariaUrls",
				"UnrealEd",
				"EditorSubsystem",
				"ToolMenus",
				"LevelEditor",
				"ApplicationCore",
				"MainFrame",
			}
		);
	}
}

```

`Source/RedTalaria/Private/RedHermesEndpoint.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedHermesEndpoint.h"

#include "Runtime/Launch/Resources/Version.h"

#if ENGINE_MAJOR_VERSION >= 5
#include "AssetRegistry/AssetRegistryModule.h"
#else
#include "AssetRegistryModule.h"
#endif

#define LOCTEXT_NAMESPACE "Editor.RedHermesEndpoint"

DEFINE_LOG_CATEGORY_STATIC(LogRedHermesEndpoint, Log, All);

void URedHermesEndpoint::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	IAssetRegistry& AssetRegistry = FModuleManager::LoadModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry")).Get();
	if (AssetRegistry.IsLoadingAssets())
	{
		UE_LOG(LogRedHermesEndpoint, Verbose, TEXT("Asset registry is currently loading..."));
		AssetRegistry.OnFilesLoaded().AddUObject(this, &ThisClass::OnAssetRegistryFilesLoaded);
	}

	IHermesServerModule& Hermes = FModuleManager::LoadModuleChecked<IHermesServerModule>(TEXT("HermesServer"));
	Hermes.Register(GetHermesEndpointId(), FHermesOnRequest::CreateUObject(this, &ThisClass::OnHermesRequest));
}

void URedHermesEndpoint::Deinitialize()
{
	if (const auto Hermes = FModuleManager::GetModulePtr<IHermesServerModule>(TEXT("HermesServer")))
	{
		Hermes->Unregister(GetHermesEndpointId());
	}

	if (const auto AssetRegistry = FModuleManager::GetModulePtr<FAssetRegistryModule>(TEXT("AssetRegistry")))
	{
		AssetRegistry->Get().OnFilesLoaded().RemoveAll(this);
	}

	Super::Deinitialize();
}

void URedHermesEndpoint::OnAssetRegistryFilesLoaded()
{
	UE_LOG(LogRedHermesEndpoint, Verbose,
		TEXT("Finished loading asset registry, processing %d pending requests"), PendingRequests.Num());

	for (const FPendingRequest& Request : PendingRequests)
	{
		ProcessRequest(Request.Path, Request.Query);
	}
	PendingRequests.Empty();
}

void URedHermesEndpoint::OnHermesRequest(const FString& Path, const FHermesQueryParamsMap& QueryParams)
{
	const IAssetRegistry& AssetRegistry = FModuleManager::LoadModuleChecked<FAssetRegistryModule>(TEXT("AssetRegistry")).Get();
	if (AssetRegistry.IsLoadingAssets())
	{
		UE_LOG(LogRedHermesEndpoint, Verbose,
			TEXT("Received request for %s while loading asset registry, putting in queue"), *Path);
		FPendingRequest& Request = PendingRequests.AddDefaulted_GetRef();
		Request.Path = Path;
		Request.Query = QueryParams;
	}
	else
	{
		ProcessRequest(Path, QueryParams);
	}
}

#undef LOCTEXT_NAMESPACE

```

`Source/RedTalaria/Private/RedTalaria.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedTalaria.h"

#include "Interfaces/IPluginManager.h"
#include "Modules/ModuleManager.h"
#include "Runtime/Launch/Resources/Version.h"
#include "Styling/CoreStyle.h"
#include "Styling/SlateStyle.h"
#include "Styling/SlateStyleRegistry.h"

#define LOCTEXT_NAMESPACE "FRedTalariaModule"

const FName FRedTalariaModule::SlateStyleSetName = TEXT("RedTalariaModuleStyleSet");
const FName FRedTalariaModule::TalariaIconSlateStyleName = TEXT("RedTalariaModule_TalariaIcon");

void FRedTalariaModule::StartupModule()
{
	RegisterSlateStyle();
}

void FRedTalariaModule::ShutdownModule()
{
	UnregisterSlateStyle();
}

void FRedTalariaModule::RegisterSlateStyle()
{
	const auto Plugin = IPluginManager::Get().FindPlugin(UE_PLUGIN_NAME);
	checkf(Plugin, TEXT("Couldn't load our own plugin descriptor"));

	SlateStyle = MakeShareable(new FSlateStyleSet(SlateStyleSetName));

	SlateStyle->SetContentRoot(FPaths::Combine(Plugin->GetContentDir(), TEXT("Editor/Slate")));

#define IMAGE_BRUSH(RelativePath, ...) FSlateImageBrush(SlateStyle->RootToContentDir(RelativePath, TEXT(".png")), __VA_ARGS__)
#if ENGINE_MAJOR_VERSION >= 5
	SlateStyle->Set(TalariaIconSlateStyleName, new IMAGE_BRUSH("RedTalaria_16", CoreStyleConstants::Icon16x16));
#else
	const FVector2D Icon16X16(16.0f, 16.0f);
	SlateStyle->Set(TalariaIconSlateStyleName, new IMAGE_BRUSH("RedTalaria_16", Icon16X16));
#endif
#undef IMAGE_BRUSH

	FSlateStyleRegistry::RegisterSlateStyle(*SlateStyle);
}

void FRedTalariaModule::UnregisterSlateStyle()
{
	FSlateStyleRegistry::UnRegisterSlateStyle(*SlateStyle);
	SlateStyle.Reset();
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FRedTalariaModule, RedTalaria)

```

`Source/RedTalaria/Public/RedHermesEndpoint.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "EditorSubsystem.h"
#include "HermesServer.h"

#include "RedHermesEndpoint.generated.h"

UCLASS(Abstract)
class REDTALARIA_API URedHermesEndpoint : public UEditorSubsystem
{
	GENERATED_BODY()

public:
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;

protected:
	virtual FName GetHermesEndpointId() const
		PURE_VIRTUAL(URedHermesEndpoint::GetHermesEndpointId, return NAME_None;);

	virtual void ProcessRequest(const FString& Path, const FHermesQueryParamsMap& QueryParams) const
		PURE_VIRTUAL(URedHermesEndpoint::ProcessRequest,);

private:
	struct FPendingRequest
	{
		FString Path;
		FHermesQueryParamsMap Query;
	};

	TArray<FPendingRequest> PendingRequests;

	void OnAssetRegistryFilesLoaded();
	void OnHermesRequest(const FString& Path, const FHermesQueryParamsMap& QueryParams);
};

```

`Source/RedTalaria/Public/RedTalaria.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "Modules/ModuleInterface.h"
#include "Templates/SharedPointer.h"
#include "UObject/NameTypes.h"

class FSlateStyleSet;

class REDTALARIA_API FRedTalariaModule : public IModuleInterface
{
public:
	static const FName SlateStyleSetName;
	static const FName TalariaIconSlateStyleName;

	virtual void StartupModule() override;
	virtual void ShutdownModule() override;

private:
	TSharedPtr<FSlateStyleSet> SlateStyle;

	void RegisterSlateStyle();
	void UnregisterSlateStyle();
};

```

`Source/RedTalaria/RedTalaria.Build.cs`:

```cs
// Copyright (c) CD PROJEKT S.A.

using UnrealBuildTool;

public class RedTalaria : ModuleRules
{
	public RedTalaria(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(
			new[]
			{
				"Core",
				"HermesServer",
			}
		);

		PrivateDependencyModuleNames.AddRange(
			new[]
			{
				"CoreUObject",
				"Engine",
				"Slate",
				"SlateCore",
				"EditorSubsystem",
				"Projects",
			}
		);
	}
}

```

`Source/RedTalariaUrls/Private/RedTalariaAutomationUrls.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedTalariaAutomationUrls.h"

const FName FRedTalariaAutomationUrls::HermesEndpointId = TEXT("automation");

const FString FRedTalariaAutomationUrls::TestNameFilterParamName = TEXT("test_name_filter");

```

`Source/RedTalariaUrls/Private/RedTalariaContentFolderUrls.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedTalariaContentFolderUrls.h"

#include "HermesServer.h"
#include "Modules/ModuleManager.h"

const FName FRedTalariaContentFolderUrls::HermesEndpointId = TEXT("content_folder");

FString FRedTalariaContentFolderUrls::GetUrlForContentFolder(FName FolderPath)
{
	if (const auto Hermes = FModuleManager::LoadModulePtr<IHermesServerModule>(TEXT("HermesServer")))
	{
		return Hermes->GetUri(HermesEndpointId, *FolderPath.ToString());
	}

	return FString(TEXT(""));
}

```

`Source/RedTalariaUrls/Private/RedTalariaContentUrls.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedTalariaContentUrls.h"

#include "HermesServer.h"
#include "Modules/ModuleManager.h"

const FName FRedTalariaContentUrls::HermesEndpointId = TEXT("content");

FString FRedTalariaContentUrls::GetUrlForPackage(FName PackageName)
{
	if (const auto Hermes = FModuleManager::LoadModulePtr<IHermesServerModule>(TEXT("HermesServer")))
	{
		return Hermes->GetUri(HermesEndpointId, *PackageName.ToString());
	}

	return FString();
}

```

`Source/RedTalariaUrls/Private/RedTalariaGraphNodeUrls.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedTalariaGraphNodeUrls.h"

#include "HermesServer.h"
#include "Modules/ModuleManager.h"

const FName FRedTalariaGraphNodeUrls::HermesEndpointId = TEXT("graph_node");
const FString FRedTalariaGraphNodeUrls::GuidQueryParamName = TEXT("guid");
const FString FRedTalariaGraphNodeUrls::OpenJumpTargetQueryParamName = TEXT("open_jump_target");

FString FRedTalariaGraphNodeUrls::GetFocusUrlForNode(FName Package, FGuid NodeGuid)
{
	if (const auto Hermes = FModuleManager::LoadModulePtr<IHermesServerModule>(TEXT("HermesServer")))
	{
		return FString::Printf(TEXT("%s?%s=%s"),
			*Hermes->GetUri(HermesEndpointId, *Package.ToString()),
			*GuidQueryParamName,
			*NodeGuid.ToString());
	}

	return FString(TEXT(""));
}

FString FRedTalariaGraphNodeUrls::GetOpenJumpTargetUrlForNode(FName Package, FGuid NodeGuid)
{
	const FString NodeUrl = GetFocusUrlForNode(Package, NodeGuid);
	if (!NodeUrl.IsEmpty())
	{
		return FString::Printf(TEXT("%s&%s"), *NodeUrl, *OpenJumpTargetQueryParamName);
	}

	return FString(TEXT(""));
}

```

`Source/RedTalariaUrls/Private/RedTalariaLevelActorUrls.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedTalariaLevelActorUrls.h"

#include "HermesServer.h"
#include "GenericPlatform/GenericPlatformHttp.h"
#include "Modules/ModuleManager.h"

const FName FRedTalariaLevelActorUrls::HermesEndpointId = TEXT("level_actor");
const FString FRedTalariaLevelActorUrls::ActorNameParamName = TEXT("actor_name");

FString FRedTalariaLevelActorUrls::GetUrlForLevelActor(FName Package, const FString& ActorName)
{
	if (const auto Hermes = FModuleManager::LoadModulePtr<IHermesServerModule>(TEXT("HermesServer")))
	{
		return FString::Printf(TEXT("%s?%s=%s"), *Hermes->GetUri(HermesEndpointId, *Package.ToString()), *ActorNameParamName, *FGenericPlatformHttp::UrlEncode(ActorName));
	}

	return FString(TEXT(""));
}

```

`Source/RedTalariaUrls/Private/RedTalariaLevelAtCameraCoordsUrls.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedTalariaLevelAtCameraCoordsUrls.h"

#include "Algo/Transform.h"
#include "HermesServer.h"
#include "Modules/ModuleManager.h"

const FName FRedTalariaLevelAtCameraCoordsUrls::HermesEndpointId = TEXT("level_coords");
const FString FRedTalariaLevelAtCameraCoordsUrls::CameraLocationXParamName = TEXT("lx");
const FString FRedTalariaLevelAtCameraCoordsUrls::CameraLocationYParamName = TEXT("ly");
const FString FRedTalariaLevelAtCameraCoordsUrls::CameraLocationZParamName = TEXT("lz");
const FString FRedTalariaLevelAtCameraCoordsUrls::CameraRotationPParamName = TEXT("rp");
const FString FRedTalariaLevelAtCameraCoordsUrls::CameraRotationYParamName = TEXT("ry");
const FString FRedTalariaLevelAtCameraCoordsUrls::CameraRotationRParamName = TEXT("rr");

FString FRedTalariaLevelAtCameraCoordsUrls::GetUrlForLevelAtLocationAtRotation(FName Package, const FVector& Location, const FRotator& Rotation)
{
	if (const auto Hermes = FModuleManager::LoadModulePtr<IHermesServerModule>(TEXT("HermesServer")))
	{
		const TMap<FString, double> QueryParamMap = {
			{CameraLocationXParamName, Location.X},
			{CameraLocationYParamName, Location.Y},
			{CameraLocationZParamName, Location.Z},
			{CameraRotationPParamName, Rotation.Pitch},
			{CameraRotationYParamName, Rotation.Yaw},
			{CameraRotationRParamName, Rotation.Roll}};

		TArray<FString> QueryParams;
		Algo::Transform(QueryParamMap, QueryParams, [](const auto& Pair) {
			return FString::Printf(TEXT("%s=%f"), *Pair.Key, Pair.Value);
		});

		return FString::Printf(TEXT("%s?%s"), *Hermes->GetUri(HermesEndpointId, *Package.ToString()), *FString::Join(QueryParams, TEXT("&")));
	}

	return FString(TEXT(""));
}

```

`Source/RedTalariaUrls/Private/RedTalariaUrls.cpp`:

```cpp
// Copyright (c) CD PROJEKT S.A.

#include "RedTalariaUrls.h"

#include "Modules/ModuleManager.h"

#define LOCTEXT_NAMESPACE "FRedTalariaUrlsModule"

void FRedTalariaUrlsModule::StartupModule() {}

void FRedTalariaUrlsModule::ShutdownModule() {}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FRedTalariaUrlsModule, RedTalariaUrls)

```

`Source/RedTalariaUrls/Public/RedTalariaAutomationUrls.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "Containers/UnrealString.h"
#include "UObject/NameTypes.h"

class REDTALARIAURLS_API FRedTalariaAutomationUrls
{
public:
	static const FName HermesEndpointId;

	static const FString TestNameFilterParamName;
};

```

`Source/RedTalariaUrls/Public/RedTalariaContentFolderUrls.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "UObject/NameTypes.h"

class REDTALARIAURLS_API FRedTalariaContentFolderUrls
{
public:
	static const FName HermesEndpointId;

	static FString GetUrlForContentFolder(FName FolderPath);
};

```

`Source/RedTalariaUrls/Public/RedTalariaContentUrls.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "UObject/NameTypes.h"

class REDTALARIAURLS_API FRedTalariaContentUrls
{
public:
	static const FName HermesEndpointId;

	static FString GetUrlForPackage(FName PackageName);
};

```

`Source/RedTalariaUrls/Public/RedTalariaGraphNodeUrls.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "Containers/UnrealString.h"
#include "UObject/NameTypes.h"

class REDTALARIAURLS_API FRedTalariaGraphNodeUrls
{
public:
	static const FName HermesEndpointId;
	static const FString GuidQueryParamName;
	static const FString OpenJumpTargetQueryParamName;

	static FString GetFocusUrlForNode(FName Package, FGuid NodeGuid);
	static FString GetOpenJumpTargetUrlForNode(FName Package, FGuid NodeGuid);
};

```

`Source/RedTalariaUrls/Public/RedTalariaLevelActorUrls.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "Containers/UnrealString.h"
#include "UObject/NameTypes.h"

class REDTALARIAURLS_API FRedTalariaLevelActorUrls
{
public:
	static const FName HermesEndpointId;
	static const FString ActorNameParamName;

	static FString GetUrlForLevelActor(FName Package, const FString& ActorName);
};

```

`Source/RedTalariaUrls/Public/RedTalariaLevelAtCameraCoordsUrls.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "Containers/UnrealString.h"
#include "UObject/NameTypes.h"

class REDTALARIAURLS_API FRedTalariaLevelAtCameraCoordsUrls
{
public:
	static const FName HermesEndpointId;

	static const FString CameraLocationXParamName;
	static const FString CameraLocationYParamName;
	static const FString CameraLocationZParamName;
	static const FString CameraRotationPParamName;
	static const FString CameraRotationYParamName;
	static const FString CameraRotationRParamName;

	static FString GetUrlForLevelAtLocationAtRotation(FName Package, const FVector& Location, const FRotator& Rotation);
};

```

`Source/RedTalariaUrls/Public/RedTalariaUrls.h`:

```h
// Copyright (c) CD PROJEKT S.A.

#pragma once

#include "Modules/ModuleInterface.h"

class FRedTalariaUrlsModule : public IModuleInterface
{
public:
	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

```

`Source/RedTalariaUrls/RedTalariaUrls.Build.cs`:

```cs
// Copyright (c) CD PROJEKT S.A.

using UnrealBuildTool;

public class RedTalariaUrls : ModuleRules
{
	public RedTalariaUrls(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(
			new[]
			{
				"Core",
			}
		);

		PrivateDependencyModuleNames.AddRange(
			new[]
			{
				"CoreUObject",
				"Engine",
				"HTTP",
				"Slate",
				"SlateCore",
			}
		);

		PrivateIncludePathModuleNames.AddRange(
			new[]
			{
				"HermesServer",
			}
		);
	}
}

```