Project Path: arc_travisfoley_dfirtriage_mizfaa1d

Source Tree:

```txt
arc_travisfoley_dfirtriage_mizfaa1d
├── LICENSE
├── README.md
├── binary
│   ├── DFIRtriage-v6-pub.exe
│   └── file-info.txt
├── code
│   └── DFIRtriage-v6-pub.py
└── data
    ├── core.ir
    └── core.ir_file-info.txt

```

`LICENSE`:

```
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org>

```

`README.md`:

```md
# **dfirtriage**

Digital forensic acquisition tool for Windows-based incident response.  


# How to Use

To run, drop dfirtriage.exe on the target or connected USB drive and execute with admin rights, `-h` for help.

___

# **DFIRTriage v6.0 User's Manual**

## Description

This document outlines the functionality and proper use of the DFIRtriage tool. Also included is detailed information to help with analysis of the output. The goal is to equip the Incident Responder with the tools needed to gather and analyze data quickly.

## About

DFIRtriage is an incident response tool designed to provide the Incident Responder with rapid host data. Upon execution, select host data and information will be gathered and placed into the execution directory. DFIRtriage may be ran from a USB drive or executed remotely on the target host.

## What’s new in v6.0?


**Output restructure**

- Reorganized the output files and directories in a more logical manner

**Logging total run time**

- added total run time to the run log file (runlog.txt)

**Bug fixes**

- non-zero exit status 1 when ntuser.dat is missing from a user profile directory
- now only attempts to pull locked files from user profile directories where an ntuser.dat file exists

**Added arguments for individual system artifacts**

- breaking up the system file acquisition option into individual artifacts cuts down on the total file size when you are only wanting one and not all 3.
` -sdb, --srumdb` (srum database), `-hf, --hiberfil` (hiberfil.sys), `-p, --pagefile` (pagefile.sys)

**Improved executable file hashing capabilites**

- Hashes all .dll and .exe files on the OS drive. Recommended to disable A/V realtime scanning when using the hash arguments.

**Running process details**

- improved the running process information to include PID, PPID, process name, command executed to launch the process, and files opened by the process.

**Bitlocker key dump**

- to dump OS drive bitlocker key information you can now pass the `-bl` or `--bitlocker` argument on the command line

**Memory acquisition no longer default action**

- to acquire memory you must pass the `-m` or `--memory` argument on the command line

**User prompt removed from end of execution**

- no longer need to designate the `-hl` or `--headless` argument to bypass the ending user prompt, script will run to completion, clean up, and exit with no user intervention.

**Windows firewall**

- dumping Windows firewall configuration
- default parsing of key firewall events
- pulling full firewall event log (EVTX) with `-elf` argument

**Improved user account report**

- creating a more detailed user account report that includes account SIDs and last logon time.

**dtfind - admin requirement removed**

- removed the requirement for admin permissions to run dtfind

**3rd party tools update**

- core.ir toolset has been updated with current tool versions

**External IP**

- Grabs endpoint external IP address

**PowerShell**

- Now acquires Powershell history for commands ran by SYSTEM
- Full Powershell EVTX file is now pulled with `-elf`, `--evtlogfiles` argument

**System Information**

- New system and networked data collected in WLAN report


**Event Logs**

- Acquires virtual drive (VHD) drive mount events from VHD operations event log
- New event log events added to default collection.
- Pulling full Powershell and Firewall event logs with `-elf`, `--evtlogfiles` argument

**Application event log**

- WER events for application crashes only (1001)
- User logging on with temporary profile (1511)
- Cannot create profile using temporary profile (1518)
- Application error events, similar to WER/1001. These include full path to faulting EXE/Module (1000)
- Application crash/hang events, similar to WER/1001. These include full path to faulting EXE/Module (1002)

**Security event log**

- Replay attack (4649)
- Kerberos TGT request (4768)
- Kerberos service ticket requested (4769)
- Kerberos service ticket renewal (4770)
- Kerberos pre-authentication failed (4771)
- Workstation locked (4800)
- Workstation unlocked (4801)
- Screensaver was invoked (4802)
- Screensaver was dismissed (4803)
- An attempt was made to change an account's password (4723)
- A user account was disabled (4725)
- A user account was deleted (4726)
- Group creations (4727, 4731, 4754)
- Group member removals (4729, 4733, 4757)
- Group changes (4735, 4737, 4755, 4764)
- A user account was locked out (4740)
- A computer account was created (4741)
- A computer account was changed (4742)
- A computer account was deleted (4743)
- SID history (4765, 4766)
- A user account was unlocked (4767)
- ACL set on accounts (4780)
- System time was changed (4616)
- Kerberos service ticket was denied (4821)
- NTLM authentication failed (4822, 4823)
- Kerberos pre-authentication failed (4824)
- Certificate Services received a certificate request (4886)
- Certificate Services approved a certificate request (4887)
- A Certificate Services template was updated (4899)
- Certificate Services template security was updated (4900)
- Kerberos policy was changed (4713)
- An operation was performed on an object (4662)

**Powershell event log**

- PowerShell executes block activity (4103)
- Remote Command (4104)

**Windows Firewall event log**

Local Modifications (Levels 0, 2, 4) (2004, 2005, 2006, 2009, 2033)


## Dependencies

The tool repository contains the full toolset required for proper execution and is packed into a single a single file named `core.ir`. This `.ir` file is the only required dependency of DFIRtriage when running in Python and should reside in a directory named data, (ie. `./data/core.ir`). The compiled version of DFIRtriage has the full toolset embedded and does not require the addition of the `./data/core.ir` file. 


## Operation

DFIRtriage acquires data from the host on which it is executed.  Behind the keyboard executions are best conducted from a USB device.  For acquisitions of remote hosts, the DFIRtriage files will need to be copied to the target, then executed via remote shell. (ie. SSH or PSEXEC)

## PSEXEC Usage

_WARNING: Do not use PSEXEC arguments to pass credentials to a remote system for authentication. Doing so will send your username and password across the network in the clear._

**The following steps should be taken for proper usage of PSEXEC**

1.  Map a network drive and authenticate with an account that has local administrative privileges on the target host.

> You can used this mapped connection to copy DFIRtriage to the target.

2.  We can now shovel a remote shell to the target host using PSEXEC.
    
    `psexec \\target\_host cmd`
    
3.  You now have a remote shell on the target. All commands executed at this point are done so on the target host.
    

**Usage**

1.  Once the remote shell has been established on the target you can change directory to the location of the extracted DFIRtriage.exe file and execute.
    
2.  Memory acquisition does not occur by default. To dump memory, pass the following argument:  `-m, --memory` 
    
3.  DFIRtriage must be executed with Administrative privileges.
    

## OUTPUT ANALYSIS

Once complete, press enter to cleanup the output directory. If running the executable, the only data remaining with be a zipped archive of the output as well as DFIRtriage.exe. If running the Python code directly only DFIRtriage python script and a zipped archive of the output are left.

## OUTPUT FOLDER

The output folder name includes the target hostname and a date/time code indicating when DFIRtriage was executed. The date/time code format is `YYYYMMDDHHMMSS`.

# ARTIFACTS LIST

The table below provides a general listing of the type of information and artifacts gathered by DFIRtriage v6.0.

|   |   |
|---|---|
|**Artifacts**|**Description**|
|Memory|Raw image acquisition|
|System information|Build, version, installed patches, bitlocker & shadow copy info, etc.|
|Current date and time|Current system date and time|
|Prefetch|Collects and parses prefetch data|
|PowerShell command history|Gathers PowerShell command history for all users including the SYSTEM account|
|User activity|HTML report of recent user activity|
|File hash|Calculates an MD5, SHA-1, or SHA-256 hash of all EXE and DLL files on the OS partition|
|Network information|Network configuration, routing tables, connections, etc.|
|DNS cache entries|List of complete DNS cache contents|
|ARP table information|List of complete ARP cache contents|
|NetBIOS information|Active NetBIOS sessions, transferred files, etc.|
|Windows Update Log|Gathers update information and builds Windows update log|
|Windows Event Logs|Gathers and parses multiple Windows Event logs|
|Process information|Processes, PID, image path, and full command line|
|List of remotely opened files|Files on target system opened by remote hosts|
|List of hidden directories|List of all hidden directories on the system partition|
|Alternate Data Streams|List of files containing alternate data streams|
|Complete file listing|Full list of all files on the system partition|
|List of scheduled tasks|List of all configured scheduled tasks|
|Hash of all collected triage data|SHA-256 hash of all data collected by DFIRtriage|
|Local & domain user account information|Usernames, profile paths, account SID, etc.|
|Autorun information|All autorun locations and content|
|Logged on users|All users currently logged on to target system|
|Registry hives|Pulls down all registry hives|
|USB artifacts|Collects data needed to parse USB usage info|
|Browser History|Aggregated report of browser history|
| SRUM database  | System usage information collected by SRUM (System Usage Resource Monitor) | 


## OUTPUT REFERENCE

This section of the manual is provided to offer guidance during analysis of the DFIRtriage output.  The below information is only provided as a guideline as it would not be practical to detail every possible use of this data. The bulk of analysis will depend on context and the analysis skills of the Incident Responder.

| Output Directory Root           | Analysis Notes                                                                                                                                          |
|---------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------|
| ForensicImages\                 | See information below for content details.                                                                                                              |
| LiveResponseData.zip            | Compressed triage collection data                                                                                                                       |
| triage_acquisition_hashlist.csv | This file contains the calculated hash value for all data collected by DFIRtriage. This information can be used to verify integrity of the output data. |


<br>

| ForensicImages \ hdd | Analysis Notes                                                                                                                  |
|----------------------|---------------------------------------------------------------------------------------------------------------------------------|
| .E01, .dd, etc       | The triage script does not acquire a file system image. This folder is here for organizational purposes should one be acquired. |



<br>


| ForensicImages \ memory | Analysis Notes                                                                                                                                                                                                 |
|-------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| memdump.raw             | memdump.raw is a full raw image of volatile memory which should be acquired before a shutdown or reboot of the target machine. Multiple memory analysis tools should be used for cross-validation of findings. |


<br>


| ForensicImages \ system-files | Analysis Notes                                                                                |
|-------------------------------|-----------------------------------------------------------------------------------------------|
| hiberfil.sys                  | Hiberfil.sys is a compressed RAM image created during a system hibernation event.             |
| pagefile.sys                  | Pagefile.sys stores data that would normally be written to RAM when no RAM is available.      |
| srudb.dat                     | Srudb.dat contains system usage information collected by SRUM (System Usage Resource Monitor) |



<br>


| LiveResponseData \ filesystem | Analysis Notes                                                                                                                                                                                                   |
|-------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Alternate_data_streams.txt    | Contains all files on the target system that contain alternate data stream content.  Alternate data streams can be used to easily hide information, or even entire files while remaining undetected by the user. |
| full_file_list.csv.zip        | This report is very helpful in determining if a known folder or file is present on the target system.                                                                                                            |
| List_hidden_directories.txt   | Log of all directories that have been hidden from the User. This log should be reviewed for suspicious hidden directories in unusual locations (e.g. in user temp folders)                                       |
| psfile.txt                    | Review information to determine if there are any files opened remotely on the target host.                                                                                                                       |
| shadow_files.txt              | Provides details on volume shadow points available on the target system.                                                                                                                                         |



<br>


| LiveResponseData \ hashes | Analysis Notes                                                                                                                                                                                                                                      |
|---------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| hash-report.csv           | Provides an MD5, SHA-1, or SHA-256 hash value of all accessible EXE and DLL files on the target system if an argument is passed (eg. -sha256).   Data can be reviewed for suspicious filenames and hash values can be used to search IOC databases. |



<br>


| LiveResponseData \ logs               | Analysis Notes                                                                                                                                                                                                                                                                                                                                                                                |
|---------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| BrowsingHistoryView.csv               | Offers a quick review of browser activity. Will contain information from IE, Chrome, Firefox, and Safari if available. The -bho argument can be used when executing to force a browser history “only” acquisition.                                                                                                                                                                            |
| eventlogs_key_events.csv              | There are a total of 96 select events total from the application, system, security, and PowerShell event logs and this log file is generated by default.                                                                                                                                                                                                                                      |
| eventlogs-all.csv                     | Contains parsed data from all events in the Application, System, Security, and Powershell event logs.  Created by the “-elpa, --evtlogparseall” command line argument.                                                                                                                                                                                                                        |
| firewall_events.csv                   | This log contains all Windows Firewall modification events (Levels 0, 2, 4).                                                                                                                                                                                                                                                                                                                  |
| rdp_logon_logoff_events.csv           | Contains all Remote Desktop logon and logoff events from the Windows Terminal Services Local Session Manager event logs.                                                                                                                                                                                                                                                                      |
| vhd_mount_log.csv                     | This log will show details on image files (eg. ISO files) mounted on the system.                                                                                                                                                                                                                                                                                                              |
| EVTX files                            | If the “-elf, --eventlogfiles” argument is used, full copies of the Application, System, Security, Powershell, & Firewall event logs will be acquired.                                                                                                                                                                                                                                        |
| powershell_command_history_<user>.txt | Contains Powershell command history for all users if available.                                                                                                                                                                                                                                                                                                                               |

<br>

| LiveResponseData \ Network    | Analysis Notes                                                                                                                                                                                                                   
| -------------------------------------- | ---------------- |                                                                                                                                                                                                           
| ARP.txt                       | This file contains the ARP cache from the target system. While the ARP protocol is not routable to the internet, it can help to identify additional hosts on a network that may have been compromised or that may have been used to launch the internal attack.                                                                                                                              |
| cports.html                   | This is a very detail report showing TCP/UDP connections on the target host. Additionally, you have information on the process that created the connection (name, PID, etc.), the Window Title (if exists), and more.                                                                                                                                                                         |
| DNS_cache.txt                 | This is a log file of the target system DNS cache. Malware generally can connect to the network in order to do things like gathering additional exploits, join a command & control infrastructure, wait for more commands, etc. It is common for malware to be coded with domain names which must queried and resolved before it can connect. This information can be found in the DNS cache. |
| hosts.txt                     | This is a copy of the contents of the system HOSTS file                                                                                                                                                                                                                                                                                                                                       |
| Internet_settings.txt         | This is a log of the local network adapter configuration on the target host. This log should be reviewed to ensure the settings are correct and have not been altered. (E.g. Suspicious domains added to the DNS Suffix Search List)                                                                                                                                                          |
| NetBIOS_sessions.txt          | This file will contain information on any current NetBIOS sessions to the target host.                                                                                                                                                                                                                                                                                                        |
| NetBIOS_transferred_files.txt | This log will show if any files were transferred over the network from the target host using the “net file” command.                                                                                                                                                                                                                                                                          |
| Open_network_connections.txt  | This file also contains TCP/UDP connection information. The process PID and connection state information is also available. While it may seem redundant, it is essential to identify current and recent network activity. Some of these tools may capture information that the others miss. All findings should be validated.                                                                 |
| routing_table.txt             | This file contains the routing table of the target host. This information should be reviewed to ensure it has not been modified with additional routes or a modified gateway. Comparing this information to the routing table from a known good machine may be helpful.                                                                                                                       |
| Tcpvcon.txt                   | Additional information on network connections from target host. Contains protocol type (TCP/UDP), process name, PID, state, local address, and remote address.                                                                                                                                                                                                                                |


<br>

| LiveResponseData \ Network \ WLAN | Analysis Notes                                                                                                                                                                                                                                                      |
|-----------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| wlan-report-latest.html           | This is a wireless network report showing all Wi-Fi events from the last three days and groups them by Wi-Fi connection sessions. It also shows the results of several network-related command line scripts and a list of all the network adapters on the endpoing. |



<br>


| LiveResponseData \ persistence | Analysis Notes                                                                                                                                                                                                                                                                                                                         |
|--------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| autorunsc.txt                  | This information will show all the programs that Windows will automatically execute when starting up. This is a very common method used by malware to maintain persistence on a system. This data can be reviewed for suspicious file names and paths.                                                                                 |
| Loaded_dlls.txt                | This file contains a process listing which includes all loaded DLLs for each running process. Persistence can be gained by injecting a malicious DLL into a normal Windows process. This data should be examined for suspicious DLLs. It is very helpful to have a list of loaded DLLs from a known good system to use for comparison. |
| scheduled_tasks.txt            | This file contains all scheduled tasks found on the target system. Inserting a scheduled task into the target host is a common method used by malware to maintain persistence on the victim machine. This information should be reviewed for suspicious tasks.                                                                         |
| services_aw_processes.txt      | This file provides a list of services running on the target system, with the associated process name and PID. Rogue services are another persistence mechanism that can be utilized by malware.                                                                                                                                        |



<br>


| LiveResponseData \ prefetch  | Analysis Notes                                                                                                                                                                                                                                                               |
|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| parsed-prefetch.txt          | This file contains parsed data from the prefetch files collected from the target system. Information such as file name, modified, accessed, and created times, number of times executed, last run time, and all loaded DLLs and other dependent files used during execution. |


<br>

| LiveResponseData \ prefetch \ raw | Analysis Notes                                                                                                                                                                                                                                                                                                                                     |
|-----------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| .pf                               | The “raw” subdirectory contains the raw prefetch files found on the target system. This data is collected and then parsed later in the DFIRtriage process. The filenames of the prefetch files will give you an indication of which programs where recently executed. Especially useful if you already have a binary name from an external source. |



<br>


| LiveResponseData \ processes | Analysis Notes                                                                                                                                                                                                                                                                                       |
|------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| running_processes.csv        | This report provides details on all processes currently running in memory.  The PID and PPID information helps to determine the order in which the processes occur in memory as well as the spawning or parent process.  In addition, it provides the full command line used to execute the process. |



<br>


| LiveResponseData \ registry | Analysis Notes                                   |
|-----------------------------|--------------------------------------------------|
| *-parsed.txt                | Regripper output for each of the registry hives. |



<br>

| LiveResponseData \ registry \ raw | Analysis Notes                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|-----------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| NTUSER & USRCLASS                 | A copy of the user registry hives NTUSER.dat and USRCLASS.dat are acquired for all user profiles found on the target system.  These user registry files contain information on general user behavior such as recently viewed documents, typed URLs, mount points, mapped drives, local search terms, uninstalled software, and more. These files can be parsed with Regripper for easier analysis.                                                              |
| SAM                               | A copy of the Security Accounts Manager registry hive (SAM) from the target system.  The SAM registry file contains local user and group information such as Security Identifiers (SID) for local accounts and groups, account and group creation and deletion information. This file can be parsed with Regripper for easier analysis.                                                                                                                         |
| SECURITY                          | A copy of the Security registry hive (SECURITY) from the target system. The SECURITY registry hive contains account and system security information such as local security policies, user rights assignments, password policies, and more. The SECURITY hive is linked to the SAM hive for update accuracy. This file can be parsed with Regripper for easier analysis.                                                                                         |
| SOFTWARE                          | A copy of the Software registry hive (SOFTWARE) from the target system. The SOFTWARE registry hive contains information about installed software, uninstalled software, file extension associations, last logged on user, and more. This file can be parsed with Regripper for easier analysis.                                                                                                                                                                 |
| SYSTEM                            | A copy of the System registry hive (SYSTEM) from the target system. The SYSTEM registry hive contains information specific to the software and hardware configuration of the target system. For example, the SYSTEM registry contains system startup parameters, device driver configurations, hardware configurations, time zone settings, computer names, USB connections and pointers, and more. This file can be parsed with Regripper for easier analysis. |



<br>


| LiveResponseData \ system | Analysis Notes                                                                                                                                                                                                                            |
|---------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Bitlocker_key.txt         | This file contains the bitlocker recovery keys found on the endpoint.  Created by the “-bl, --bitlocker” command line argument.                                                                                                           |
| firewall_config.txt       | An export of all configured Windows Firewall rules                                                                                                                                                                                        |
| system_info.txt           | Detailed target system information.                                                                                                                                                                                                       |
| Windows_codepage.txt      | This file contains the active code page identifier on the target system. The typical North America EHI build should have a code page value of “437”. This is typically not an issue but modifying this value will cause data corruption.  |
| Windows_Version.txt       | Contains the version of Windows running on the target system.                                                                                                                                                                             |
| WindowsUpdate.log         | The Windows update log is no longer created by the system as of Windows 10, so we’re building it from converted event trace log (ETL) data.                                                                                               |



<br>


| LiveResponseData \ usbdevices \ usb-install-logs | Analysis Notes                                                                                                                                                                                                                             |
|--------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| setupapi.*.log                                   | This is a copy of all device installation logs from the target system.  These logs, in correlation with the SYSTEM registry hive, can be used to determine the first time a removable device (e.g. USB drive) was plugged into the system. |
| PsLoggedon.txt                                   | Use this information to help identify any users (local or remote) who are authenticated to target system.                                                                                                                                  |



<br>


| LiveResponseData \ user | Analysis Notes                                                                                                                                   |
|-------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|
| List_users.txt          | This file simply contains a list of all local user accounts found on the target system. This file can be reviewed for suspicious local accounts. |
| Local_user_list.txt     | A list of all local user accounts.                                                                                                               |
| LastActivityView.html   | An HTML report of recent user activity.                                                                                                          |
| PsLoggedon.txt          | Use this information to help identify any users (local or remote) who are authenticated to target system.                                        |
| user_acct_report.txt    | Provides local & domain usernames, profile paths, account SID, etc.                                                                              |



<br>









## EVENT ID REFERENCE

|   |   |   |
|---|---|---|
|**Event Log**|**Event ID**|**Description**|
|SECURITY|1102|user cleared security log; this is logged regardless of audit policy|
|SECURITY|4616|System time was changed|
|SECURITY|4624|successful logon|
|SECURITY|4625|failed logon|
|SECURITY|4634|Logoff|
|SECURITY|4647|User initiated logoff|
|SECURITY|4648|RunAs usage, privilege escalation, lateral movement|
|SECURITY|4649|Replay attack|
|SECURITY|4662|An operation was performed on an object|
|SECURITY|4672|Special privileges attempted login|
|SECURITY|4697|service creation, details will contain service image name (e.g. psexec), persistence|
|SECURITY|4698|Scheduled task created, potential for persistence|
|SECURITY|4722|a user account was enabled|
|SECURITY|4724|user account password reset attempt|
|SECURITY|4728|member added to security-enabled global group|
|SECURITY|4732|user added to privileged local group|
|SECURITY|4735|security-enabled local group was changed|
|SECURITY|4738|a user account was changed|
|SECURITY|4756|a member was added to a security-enabled universal group|
|SECURITY|4768|Kerberos TGT request|
|SECURITY|4769|Kerberos service ticket requested|
|SECURITY|4713|Kerberos policy was changed|
|SECURITY|4770|Kerberos service ticket renewal|
|SECURITY|4771|Kerberos pre-auth failed|
|SECURITY|4634, 4647|successful logoff|
|SECURITY|4672|account logon with superuser rights _(I.e. administrator)_|
|SECURITY|4776|Domain controller validation attempt|
|SECURITY|4778|an RDP session was reconnected as opposed to a fresh logon seen by event 4624|
|SECURITY|4688|new process created (includes exe path); process exit|
|SECURITY|4699|scheduled task was deleted|
|SECURITY|4700|scheduled task was enabled|
|SECURITY|4701|scheduled task disabled|
|SECURITY|4702|scheduled task was updated|
|SECURITY|4720|an account was created|
|SECURITY|4722|A user account was enabled|
|SECURITY|4723|An attempt was made to change an account’s password|
|SECURITY|4724|An attempt was made to reset an account’s password|
|SECURITY|4725|A user account was disabled|
|SECURITY|4726|A user account was deleted|
|SECURITY|4735, 4737, 4755, 4764|Group creations|
|SECURITY|4738|A user account was changed|
|SECURITY|4740|A user account was locked out|
|SECURITY|4741|A computer account was created|
|SECURITY|4742|A computer account was changed|
|SECURITY|4743|A computer account was deleted|
|SECURITY|4765, 4766|SID history|
|SECURITY|4767|A user account was unlocked|
|SECURITY|4776|account logon success/fail, can identify auth for a mapped drive|
|SECURITY|4779|an RDP session was disconnected as opposed to a logoff seen by events 4647 or 4634|
|SECURITY|4780|ACL set on accounts|
|SECURITY|4798|a user's local group membership was enumerated|
|SECURITY|4799|a security-enabled local group membership was enumerated|
|SECURITY|4800|Workstation locked|
|SECURITY|4801|Workstation unlocked|
|SECURITY|4802|Screensaver was invoked|
|SECURITY|4803|Screensaver was dismissed|
|SECURITY|4821|Kerberos service ticket was denied|
|SECURITY|4822, 4823|NTLM authentication failed|
|SECURITY|4824|Kerberos pre-authentication failed|
|SECURITY|4825|User denied access to Remote Desktop|
|SECURITY|4886|Certificate Services received a certificate request|
|SECURITY|4887|Certificate Services approved a certificate requeset|
|SECURITY|4899|Certificate Services template was updated|
|SECURITY|4900|Certificate Services template security was updated|
|SECURITY|5058|Key file operation|
|SECURITY|5059|Key migration operation|
|SECURITY|5140|network share was accessed|
|SECURITY|5145|shared object was accessed|
|SECURITY|7034|service crashed unexpectedly|
|SECURITY|7036|service started or stopped|
|SECURITY|7040|service start type changed (boot \| on request \| disabled)|
|APPLICATION|1022|new MSI file installed.|
|APPLICATION|1033|program installed using MSI installer|
|APPLICATION|1034|application removal complete (success/failure status)|
|APPLICATION|11707|installation completed successfully|
|APPLICATION|11708|installation operation failed|
|APPLICATION|11724|application removal completed successfully|
|APPLICATION|1000|Application crash/hang events, like WER/1001 and include full path to faulting EXE/Module|
|APPLICATION|1001, 1002|WER events for application crashes only|
|APPLICATION|1511|User logging on with temporary profile|
|APPLICATION|1518|Cannot create profile using temporary profile|
|SYSTEM|6|new kernel filter driver possible indication of kernel-mode rootkit installation|
|SYSTEM|104|user cleared system log OR application log _(note: clearing application log creates event in system log, not app log)_|
|SYSTEM|7035|successful start OR stop control was sent to a service|
|SYSTEM|7045|new Windows service was installed|
|POWERSHELL/OPERATIONAL|600|Powershell command executed|
|POWERSHELL/OPERATIONAL|4105, 4106|Powershell script start/stop|
|POWERSHELL/OPERATIONAL|4103|Powershell executes block activity|
|POWERSHELL/OPERATIONAL|4104|Remote command|
|MICROSOFT-WINDOWS-VHDMP|1|Surface Disk - Shows when a virtual drive image file is mounted.  _Eg. “The VHD C:\Users\<USER>\AppData\Local\Temp\1\Temp1_KYC_BP12(Dec15).zip\KYC#BP12.img has come online (surfaced) as disk number 0.”_|
|WINDOWS FIREWALL WITH ADVANCED SECURITY|2004, 2005, 2006, 2009, 2033|Local Modifications (Levels 0, 2, 4)|



```

`binary/file-info.txt`:

```txt
==================================================
Filename          : DFIRtriage-v6-pub.exe
MD5               : 8b6e24ccead267fd837ebffba445249a
SHA1              : 8ce6e8ba98b478bb08c1652986fe6d6f3fa17bb3
CRC32             : d67d9495
SHA-256           : 7f1468c2a9ae0b926d15688bb1f97f988a7bc01fdeceed71df0f4a6337279292
SHA-512           : 82c765ea6ade205640e6ce3707f6549027733997bbb82990755c585a248d2e78fef75ec9ea3f5ac6c0bf17e09fc3fec8123825347c53a03c2c0a2e1749ae783f
SHA-384           : 45ab9aac99dd01f5f4d872464bed1ae4b490173a0753daabe305ac2152b152173ada614ed2536cc2ca3669b392958db2
Modified Time     : 12/13/2023 10:30:22 AM
Created Time      : 12/13/2023 10:30:22 AM
Entry Modified Time: 12/13/2023 10:30:53 AM
File Size         : 39,434,603
File Version      : 
Product Version   : 
Identical         : 
Extension         : exe
File Attributes   : A
==================================================


```

`code/DFIRtriage-v6-pub.py`:

```py
# python3

"""Digital forensic acquisition tool for Windows based incident response"""

#############################################################################
##                                                                         ##
## Unlicense                                                               ##
## No Copyright                                                            ##
##                                                                         ##
## This is free and unencumbered software released into the public domain. ##
## Anyone is free to copy, modify, publish, use, compile, sell, or         ##
## distribute this software, either in source code form or as a compiled   ##
## binary, for any purpose, commercial or non-commercial, and by any       ##
## means.                                                                  ##
##                                                                         ##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,         ##
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF      ##
## MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  ##
## IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR       ##
## OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   ##
## ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR   ##
## OTHER DEALINGS IN THE SOFTWARE.                                         ##
##                                                                         ##
##  For more information, please refer to  http://unlicense.org            ##
##                                                                         ##
##  Author: Travis Foley, travis.foley@gmail.com                           ##
##                                                                         ##
#############################################################################

#############################################################################
##                                                                         ##
## DESCRIPTION: Forensic acquisition of volatile data and system           ##
## information for use with initial Incident Response.                     ##
##                                                                         ##
## FILENAME: DFIRtriage.py                                                 ##
## VERSION: 6.0                                                            ##
## STATUS: DEV                                                             ##
## LAST MOD: 1/10/24 @ 1:36 PM                                             ##
## AUTHOR: Travis Foley                                                    ##
#############################################################################

'''
NOTES:
version 6.0 complete
'''

# Built-in Imports:
import os
import psutil
import csv
from datetime import datetime
import time
import socket
import sys
import ctypes
import subprocess
import shutil
import zipfile
import argparse
import getpass
import hashlib
from tqdm import tqdm
global public_ip
import public_ip as pub_ip

NOERROR = open(os.devnull, 'w')
TARGETNAME = socket.gethostname()
DATEANDTIME = time.strftime("%Y%m%d%H%M%S")
DATE_TIME_NORM = time.strftime("%m-%d-%Y %H:%M:%S")
START_TIME = time.strftime("%H:%M:%S")
stime = datetime.strptime(START_TIME, "%H:%M:%S")
CASEFOLDER = TARGETNAME + "." + DATEANDTIME
END_TIME = time.strftime("%H:%M:%S")
OSARCH = ''
MD5_PATH = ''
CPORTSDIR = ''
WMICDIR = ''
BVHRUN = ''
OSVERSION = sys.getwindowsversion()
VERSION = "6.0"
CURRENTUSER = getpass.getuser()

if OSVERSION.major == 10:
    LOGGEDUSERS = subprocess.getoutput("whoami")
else:
    LOGGEDUSERS = getpass.getuser()

#setup commandline options
PARSER = argparse.ArgumentParser(
    description='Forensic acquisition of volatile data and system information for use '
    'in initial incident response ', epilog='Example usage: "dfirtriage -bl -xip" will run default collection in addition to grabbing Bitlocker keys and external IP address')
GROUP = PARSER.add_mutually_exclusive_group(required=False)
GROUP.add_argument('-m', '--memory', action='store_true', help="Acquires memory and continues with artifact collection")
GROUP.add_argument('-p', '--pagefile', action='store_true', help="Acquires paged memory file (pagefile.sys)")
GROUP.add_argument('-hf', '--hiberfil', action='store_true', help="Acquires hibernation memory file (hiberfil.sys)")
PARSER.add_argument('-mo', '--memonly', action='store_true', help="Acquires memory then exits")
PARSER.add_argument('-po', '--pageonly', action='store_true', help="Acquires paged memory file (pagefile.sys) then exits")
PARSER.add_argument('-hfo', '--hiberfonly', action='store_true', help="Acquires hibernation memory file (hiberfil.sys) then exits")
PARSER.add_argument('-bho', '--browserhistonly', action='store_true', help="Pulls browser history then exits")
PARSER.add_argument('-bl', '--bitlocker', action='store_true', help="Dumps bitlocker keys")
PARSER.add_argument('-elpa', '--evtlogparseall', action='store_true', help="Parses all Application, System, Security, and Powershell event logs")
PARSER.add_argument('-elf', '--evtlogfiles', action='store_true', help="Pulls full APP, SEC, SYS, Powershell, & Firewall evtx files")
PARSER.add_argument('-xip', '--externalip', action='store_true', help="Grabs the external IP address of the host.")
PARSER.add_argument('-sdb', '--srumdb', action='store_true', help="Collect system resource ulization monitor (SRUM) database (srudb.dat)")
PARSER.add_argument('-md5', '--md5hash', action='store_true', help=r"MD5 hash all execuatable files on OS drive. DISABLE A/V REALTIME SCANNING FOR FASTER PERFORMANCE.")
PARSER.add_argument('-sha1', '--sha1hash', action='store_true', help=r"SHA-1 hash all execuatable files on OS drive. DISABLE A/V REALTIME SCANNING FOR FASTER PERFORMANCE.")
PARSER.add_argument('-sha256', '--sha256hash', action='store_true', help=r"SHA-256 hash all execuatable files on OS drive. DISABLE A/V REALTIME SCANNING FOR FASTER PERFORMANCE.")
ARGS = PARSER.parse_args()


def banner():
    print("                                                     ")
    print("  (     (    (   (                                   ")
    print("  )\ )  )\ ) )\ ))\ )    *   )                       ")
    print(" (()/( (()/((()/(()/(  ` )  /((  (     ) (  (    (   ")
    print("  /(_)) /(_))/(_))(_))  ( )(_))( )\ ( /( )\))(  ))\  ")
    print(" (_))_ (_))_(_))(_))   (_(_()|()((_))(_)|(_))\ /((_) ")
    print("  |   \| |_ |_ _| _ \  |_   _|((_|_|(_)_ (()(_|_))   ")
    print("  | |) | __| | ||   /    | | | '_| / _` / _` |/ -_)  ")
    print("  |___/|_|  |___|_|_\    |_| |_| |_\__,_\__, |\___|  ")
    print("                                        |___/        ")
    print("        - - - - - - - - - - - - - - - - - - -        ")
    print("           P U B L I C    R E L E A S E              ")
    print("        - - - - - - - - - - - - - - - - - - -        ")
    print("                                                     ")
    print("                     version {}      ".format(VERSION))
    print("                                                     ")
    print("                                                     ")


if ARGS.md5hash and (ARGS.sha1hash or ARGS.sha256hash):
    banner()
    print("[!] Oops, hash arguments are mutually exclusive, retry selecting only one method.\n")
    sys.exit(2)


#This is a test to see if we are compiled into a binary or we are just a script
if getattr(sys, 'frozen', False):
    COMPILED = 1
    BUNDLE_DIR = sys._MEIPASS + "/core.ir/"

else:
    COMPILED = 0
    BUNDLE_DIR = os.path.dirname(os.path.abspath(__file__)) + "/data"

# Forcing stdout to flush so all print() and stdout.write()
# functions will display in the console when executing
# over a remote shell with psexec
sys.stdout.flush()
os.system('color 0A')


def has_admin_access():
    """Admin rights check and exit if they are not found """
    try:
        is_admin = os.getuid() == 0
    except AttributeError:
        is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0
    if not is_admin:
        print("[+] Has Local Admin rights? [NO]\n")
        open("DFIRTriage must be ran as Local ADMIN.txt", 'w')
        sys.exit(0)
    else:
        print("[+] Has Local Admin rights? [YES]")


def env_setup():
    """Setup all the environment stuff"""
    print("\n[+] Setting up environment", flush=True)

    # Preventing target from sleeping
    pwrcfg = "c:\\windows\\system32\\powercfg.exe -change "
    pwrcfg_args = ["-monitor-timeout-ac 0", "-monitor-timeout-dc 0", "-disk-timeout-ac 0",
    "-disk-timeout-dc 0", "-standby-timeout-ac 0", "-standby-timeout-dc 0", "-hibernate-timeout-ac 0",
    "-hibernate-timeout-dc 0"]
    print("\n[+] Caffeinating endpoint")
    for i in pwrcfg_args:
        os.system(pwrcfg+i)
    print("\n[+] Sleep prevention complete\n")

    # Exporting tools
    zip_file_name = BUNDLE_DIR + '\\core.ir'
    zip_core = zipfile.ZipFile(zip_file_name)
    zip_core.extractall(r'.')

    #Check OS Type
    global OSARCH
    global MD5_PATH
    global CPORTSDIR
    global WMICDIR
    global BVHRUN
    if 'PROGRAMFILES(X86)' in os.environ:
        print("[+] Detecting OS and System Architecture [64-BIT]", flush=True)
        sys.stdout.flush()
        OSARCH = 64
        CPORTSDIR = os.path.realpath('.') + "/cports-x64/"
        WMICDIR = os.path.realpath('.') + "\\WMIC\\"
        BVHRUN = "BrowsingHistoryView.exe"

    else:
        print("[+] Detecting OS and System Architecture [32bit system]")
        sys.stdout.flush()
        OSARCH = 32
        CPORTSDIR = os.path.realpath('.') + "/cports/"
        WMICDIR = os.path.realpath('.') + "\\WMIC32\\"
        BVHRUN = "BrowsingHistoryView32.exe"

    print("\n[+] Building acquisition directory structure\n", flush=True)

    # This list contains list of all directories that need to be created for output
    app_folders = ["ForensicImages/memory", "ForensicImages/hdd", "ForensicImages/system-files", "LiveResponseData/user",
                   "LiveResponseData/logs", "LiveResponseData/system", "LiveResponseData/processes",
                   "LiveResponseData/network", "LiveResponseData/network/WLAN Report", "LiveResponseData/persistence",
                   "LiveResponseData/registry", "LiveResponseData/registry/raw",
                   "LiveResponseData/usbdevices", "LiveResponseData/usbdevices/usb-install-logs", "LiveResponseData/prefetch",
                   "LiveResponseData/prefetch/raw", "LiveResponseData/filesystem", "LiveResponseData/hashes"]
    if not os.path.exists(CASEFOLDER):
        os.makedirs(CASEFOLDER)
    for folder in app_folders:
        os.makedirs(CASEFOLDER + "/" + folder)
    pversion = sys.version_info
    pversion_final = ''
    for ver_sec in pversion:
        pversion_final += str(ver_sec) + '.'

    # Capture version and commandline options
    with open('runlog.txt', 'w') as fout:
        fout.write('Hostname: ' + TARGETNAME + '\n')
        fout.write('User : ' + CURRENTUSER + '\n')
        fout.write('Start time: ' + DATE_TIME_NORM + '\n')
        fout.write('Version: ' + VERSION + '\n')
        fout.write('Commandline options: ' +str(sys.argv)  + '\n')
        fout.write('Python version: ' + pversion_final + '\n')
        fout.write('Logged in users: ' + LOGGEDUSERS + '\n')

    fout.close()

    # moving triage info file & dtfind.exe to case folder
    move_to_casefolder = ["runlog.txt", "dtfind.exe"]
    for file in move_to_casefolder:
        os.rename(os.path.realpath('.') + "\\{}".format(file), CASEFOLDER + "\\{}".format(file))


def env_cleanup():
    """[END] Compress and Move Output"""
    util_list = ["cports", "cports-x64", "lastactivityview", "PrcView",
                 "sysinternals", "PECmd", "EvtxECmd", "WMIC", "WMIC32", "xcopy", "xcopy64",
                 "memory", "regripper", "BrowsingHistoryView", "userprofilesview", "FGET"]

    #These are files that need to be cleaned up and not included in the zip
    file_clean_up = ["DFIRtriage must be ran as Local ADMIN.txt", "0", "1", "2", "3", "dtfind.exe", "Microsoft-Windows-VHDMP-Operational.evtx", "Microsoft-Windows-Windows Firewall With Advanced Security%4Firewall.evtx", "Microsoft-Windows-TerminalServices-LocalSessionManager%4Operational.evtx", "full_file_list.csv.txt"]
    tool_path = os.path.realpath('.')

    for tool in util_list:
        shutil.rmtree(tool_path + "\\" + tool)

    for files in file_clean_up:
        if os.path.exists(files):
            os.remove(files)
    else:
        print("[+] Cleaning up\n\n[+] Triage acquisition complete.")
        if os.path.exists(__file__):
            os.remove(__file__)


def mem_scrape():
    """Acquires a raw memory dump from the target system"""
    print("[+] Dumping memory\n", flush=True)
    # variable to point to the "memory" subdir of current directory
    mem_dir = os.path.realpath('.') + "\\memory\\"
    # setting up variables to run winpemem with different parameters
    mem_acq_get = mem_dir + "winpmem_mini_x64_rc2.exe memdump.raw"
    # executing winpmem
    subprocess.call(mem_acq_get, stderr=NOERROR)
    # moving acquired memory image to case folder
    os.rename(os.path.realpath('.') + "\\" + "memdump.raw", CASEFOLDER \
        + "\\ForensicImages\\Memory" + "\\" + "memdump.raw")


def pre_fetch():
    """Collects the Prefetch"""
    print("[+] Collecting prefetch\n", flush=True)

    # Detecting system architecture
    if os.path.exists("c:\\windows\\system32\\"):
        # variable to point to the location of "xcopy" on the remote system
        xcopy_dir = "c:\\windows\\system32\\"
        # setting up variables to run xcopy with appropriate parameters
        xcopy_param = xcopy_dir + "xcopy.exe /s/e/h/i C:\\Windows\\Prefetch\\*.pf "
        xcopy_out = CASEFOLDER + "\\LiveResponseData\\Prefetch\\raw"
        xcopy_pf = xcopy_param + xcopy_out

        # copying prefetch files from target
        subprocess.call(xcopy_pf, stdout=NOERROR, stderr=NOERROR)

    else:
        print("\nXcopy missing from target\n", flush=True)



def list_users():
    """Get a list of the users from the system"""
    list_stuff = "cmd.exe /C dir c:\\Users /b "
    all_system_users = subprocess.check_output(list_stuff, stderr=NOERROR, universal_newlines=True)
    list_of_users = all_system_users.rsplit("\n")
    del list_of_users[-1]
    verfied_user_list = []
    for user in list_of_users:
        if os.path.exists("c:\\users\\{}\\ntuser.dat".format(user)):
            verfied_user_list.append(user)
        else:
            pass
    return verfied_user_list



def last_user():
    """[BEGIN] Begin LastUser Activity Data Collection"""
    print("\n[+] Generating last user activity report\n", flush=True)

    # variable to point to the "lastactivityview" subdir of current directory
    lav_dir = os.path.realpath('.') + "/lastactivityview/"

    # setting up variables to run LastActivityView with output parameters
    lav_run = lav_dir + "LastActivityView.exe /shtml "
    lav_param = CASEFOLDER + "/LiveResponseData/user" + "/LastActivityView.html"
    lav_exe = lav_run + lav_param

    # executing lastactivityview
    subprocess.call(lav_exe)


def hash_exes():
    exe_file_list = []
    no_access = 0
    exe_count = len(exe_file_list)
    print("[+] Gathering all EXE and DLL files\n", flush=True)

    # Walking through files and dirs from root
    for root, dirs, files in os.walk('C:\\'):
        for file in files:
            filestr = str(file)
            # Check if the file is executable
            if filestr.endswith(".exe"):
                file_path = os.path.join(root, file)
                exe_file_list.append(file_path)
            elif filestr.endswith(".dll"):
                file_path = os.path.join(root, file)
                exe_file_list.append(file_path)
            else:
                continue

    file_info_list = []

    print("[+] Hashing EXE and DLL files\n", flush=True)
    print("    NOTE: Disabling real-time AV protection during file hashing will speed up the process\n", flush=True)
    total=len(exe_file_list)
    for exe in exe_file_list:

        try:
            # Grabbing file info
            file_stat = os.stat(exe)
            creation_time = datetime.fromtimestamp(file_stat.st_ctime)
            modified_time = datetime.fromtimestamp(file_stat.st_mtime)

            #Calculate hash values
            if ARGS.md5hash:
                with open(exe, 'rb') as f:
                    file_hash_md5 = hashlib.md5(f.read()).hexdigest()
                f.close()

            if ARGS.sha1hash:
                with open(exe, 'rb') as f:
                    file_hash_sha1 = hashlib.sha1(f.read()).hexdigest()
                f.close()

            if ARGS.sha256hash:
                with open(exe, 'rb') as f:
                    file_hash_sha256 = hashlib.sha256(f.read()).hexdigest()
                f.close()

            # Append file information to the list
            if ARGS.md5hash:
                file_info_list.append([exe, creation_time, modified_time, file_hash_md5])

            if ARGS.sha1hash:
                file_info_list.append([exe, creation_time, modified_time, file_hash_sha1])

            if ARGS.sha256hash:
                file_info_list.append([exe, creation_time, modified_time, file_hash_sha256])

        except(PermissionError, OSError):
            no_access += 1
            pass

    print("\n[i] File hashing complete with access denied for {} files\n".format(no_access), flush=True)


    # Write file information to a csv file

    try:
        with open("hash-report.csv", 'w', newline='') as csv_file:
            csv_writer = csv.writer(csv_file)
            if ARGS.md5hash:
                csv_writer.writerow(['File', 'Creation Date', 'Modified Date', 'MD5'])
            if ARGS.sha1hash:
                csv_writer.writerow(['File', 'Creation Date', 'Modified Date', 'SHA-1'])
            if ARGS.sha256hash:
                csv_writer.writerow(['File', 'Creation Date', 'Modified Date', 'SHA-256'])
            csv_writer.writerows(file_info_list)

        csv_file.close()

    except PermissionError:
        print("\n[!] Ouch, it appears hash-report.csv is still open. Please close and rerun if you want the new hash report.")

    os.rename(os.path.realpath('.') + "/" + "hash-report.csv", CASEFOLDER +
              "/LiveResponseData/hashes" + "/" + "hash-report.csv")


def triage_acquistion_hash():
    dfirt_file_list = []
    dfirt_file_count = len(dfirt_file_list)

    # Iterate through all files in the current directory and its subdirectories
    triage_data_loc = CASEFOLDER
    for root, dirs, files in os.walk(triage_data_loc):
        for file in files:
            filestr = str(file)
            file_path = os.path.join(root, file)
            dfirt_file_list.append(file_path)

    file_info_list = []

    with tqdm(total=len(dfirt_file_list), desc="[+] Hashing triage artifacts", unit="file") as pbar:
        for artifact in dfirt_file_list:
            pbar.update(1)

            #Calculate hash values
            with open(artifact, 'rb') as f:
                file_hash_sha256 = hashlib.sha256(f.read()).hexdigest()
            f.close()

            # Append file information to the list
            file_info_list.append([artifact, file_hash_sha256])

    # Write file information to a csv file

    try:
        with open("triage_acquisition_hashlist.csv", 'w', newline='') as csv_file:
            csv_writer = csv.writer(csv_file)
            csv_writer.writerow(['Artifact', 'SHA-256'])
            csv_writer.writerows(file_info_list)

        csv_file.close()

    except PermissionError:
        print("\n[!] Ouch, it appears hash-report.csv is still open. Please close and rerun if you want the new hash report.")

    # moving hash file to case folder
    move_to_casefolder = ["triage_acquisition_hashlist.csv"]
    for file in move_to_casefolder:
        os.rename(os.path.realpath('.') + "\\{}".format(file), CASEFOLDER + "\\{}".format(file))


def core_integrity():
    """Check the validity of the core"""
    if os.path.isfile(BUNDLE_DIR + "\\core.ir"):
        print("\n[+] Verifying core integrity", flush=True)

    else:
        os.system('color 4F')
        print("\n[!] Oops, this copy of the DFIRTriage script is corrupt. "
              "Please download a new copy of DFIRtriage.", flush=True)
        sys.exit()

    hasher = hashlib.md5()
    core_val = "49e8595f34f699f708c8ccaa64e95959"
    with open(BUNDLE_DIR + '\\core.ir', 'rb') as corefile:
        buf = corefile.read()
        hasher.update(buf)

    core_check = hasher.hexdigest()
    if core_val == core_check:
        print("\n[+] Core integrity [OK]", flush=True)

    else:
        os.system('color 4F')
        print("\n[!] Oops, hash values do not match. Integrity check failed. Please email"
              " forensics@ehi.com and request latest version.", flush=True)
        sys.exit()


def generate_file_list(root_path, output_file):
    print("\n[+] Building C drive file list")
    with open(output_file, 'w', newline='', encoding='utf-8') as filelist:
        csv_writer = csv.writer(filelist)
        csv_writer.writerow(['Path', 'Type'])  # Header

        for foldername, subfolders, filenames in os.walk(root_path, followlinks=False):
            try:
                for subfolder in subfolders:
                    folder_path = os.path.join(foldername, subfolder)
                    csv_writer.writerow([folder_path, 'Directory'])

                for filename in filenames:
                    file_path = os.path.join(foldername, filename)
                    csv_writer.writerow([file_path, 'File'])

            except Exception as e:
                print(f"Error processing folder {foldername}: {e}")

    filelist.close()

    # compressing file list to reduce overall file size of the triage output
    with zipfile.ZipFile("full_file_list.csv.zip", "w", compression=zipfile.ZIP_DEFLATED, compresslevel=9) as zip_filelist:
        zip_filelist.write("full_file_list.csv.txt")
    zip_filelist.close()
    os.rename(os.path.realpath('.') + "\\full_file_list.csv.zip", CASEFOLDER + "\\LiveResponseData\\filesystem" + "\\full_file_list.csv.zip")




def volatile_data_gather():
    """Gathers the volatile data"""
    print("\n[+] Gathering additional volatile data", flush=True)

    # grabbing host file
    hosts_file = "C:\\Windows\\System32\\drivers\\etc\\hosts"
    hosts_file_dst = "{}/LiveResponseData/network/{}".format(CASEFOLDER, "hosts.txt")
    os.system("type {} > {}".format(hosts_file, hosts_file_dst))

    procs = [
        {'Command': "{}/pv.exe -m -e *".format(os.path.realpath('./prcview')), 'output': "Loaded_dlls.txt",
         'outdir': "/persistence/"},
        {'Command': "cmd.exe /C tasklist /SVC", 'output': "services_aw_processes.txt",
         'outdir': "/persistence/"},
        {'Command': "cmd.exe /C ipconfig /all", 'output': "Internet_settings.txt",
         'outdir': "/network/"},
        {'Command': "cmd.exe /C netstat -anbo", 'output': "Open_network_connections.txt",
         'outdir': "/network/"},
        {'Command': "cmd.exe /C ipconfig /displaydns", 'output': "DNS_cache.txt",
         'outdir': "/network/"},
        {'Command': "cmd.exe /C arp -a", 'output': "ARP.txt",
         'outdir': "/network/"},
        {'Command': "cmd.exe /C net user", 'output': "Local_user_list.txt",
         'outdir': "/user/"},
        {'Command': "cmd.exe /C netstat -rn", 'output': "routing_table.txt",
         'outdir': "/network/"},
        {'Command': "cmd.exe /C net sessions", 'output': "NetBIOS_sessions.txt",
         'outdir': "/network/"},
        {'Command': "cmd.exe /C net file", 'output': "NetBIOS_transferred_files.txt",
         'outdir': "/network/"},
        {'Command': "cmd.exe /C schtasks /query /fo LIST /v", 'output': "scheduled_tasks.txt",
         'outdir': "/persistence/"},
        {'Command': "cmd.exe /C systeminfo", 'output': "system_info.txt",
         'outdir': "/system/"},
        {'Command': "cmd.exe /C ver", 'output': "Windows_Version.txt",
         'outdir': "/system/"},
        {'Command': "cmd.exe /C dir /S /B /AHD C:\\Windows\\*",
         'output': "List_hidden_directories.txt", 'outdir': "/filesystem/"},
        {'Command': "{}\\system32\\chcp.com".format(os.getenv('WINDIR')),
         'output': "Windows_codepage.txt", 'outdir': "/system/"},
    ]

    for processes in procs:
        running_procs = processes['Command']
        with open(processes['output'], "w+") as fout:
            subprocess.call(running_procs, stdout=fout)
    for files in procs:
        os.rename(os.path.realpath('.') + "/" + files['output'],
                  CASEFOLDER + "/LiveResponseData" + files['outdir'] + files['output'])
        fout.close()


def get_process_info(process):
    try:
        process_info = {
            'PID': process.pid,
            'PPID': process.ppid(),
            'Name': process.name(),
            'User': process.username(),
            'Command': ' '.join(process.cmdline()),
            'Open Files': process.open_files()
        }
        return process_info
    except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
        return None


def save_processes_to_csv(processes, csv_filename):
    with open(csv_filename, 'w', newline='', encoding='utf-8') as csvfile:
        fieldnames = ['PID', 'PPID', 'Name', 'User', 'Command', 'Open Files']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()

        for process in processes:
            process_info = get_process_info(process)
            if process_info:
                writer.writerow(process_info)


def dump_procs():
    print("\n[+] Exporting process details", flush=True)
    running_processes = psutil.process_iter(attrs=['pid', 'ppid', 'name', 'cmdline'])
    save_processes_to_csv(running_processes, 'running_processes.csv')
    proc_dest = CASEFOLDER + "\\LiveResponseData\\processes\\running_processes.csv"
    # moving prefetch info to case folder
    os.rename(os.path.realpath('.') + "/" + "running_processes.csv", proc_dest)


def user_account_report():
    # User details for local and domain user accounts
    print("[+] Pulling user account details\n", flush=True)
    UARDIR = os.path.realpath('.') + "/userprofilesview/"
    uar_dst = CASEFOLDER + "\\LiveResponseData\\user\\user_acct_report.txt"
    UARCMD = "{}userprofilesview.exe /stext {}".format(UARDIR, uar_dst)
    subprocess.call(UARCMD)


def network_data_gathering():
    """Get open TCP and UDP ports"""
    print("\n[+] Network information gathering", flush=True)
    print("\n\t" + "[-] Collecting currently open TCP/UDP ports", flush=True)
    # setting up variables to run cports with output parameters
    c_ports_run = CPORTSDIR + "cports.exe /shtml cports.html /sort 1 /sort ~'Remote Address'"
    c_ports_param = CASEFOLDER + "/LiveResponseData/network" + "/cports.html"
    c_ports_exe = c_ports_run + c_ports_param
    # executing cports
    subprocess.call(c_ports_exe)
    # moving cports output case folder
    os.rename(os.path.realpath('.') + "/" + "cports.html", CASEFOLDER +
              "/LiveResponseData/network" + "/" + "cports.html")
    print("\t" + "[-] Running WLAN Report\n", flush=True)
    if os.path.exists("C:\\ProgramData\\Microsoft\\Windows\\WlanReport\\"):
        os.system("rd /s/q C:\\ProgramData\\Microsoft\\Windows\\WlanReport\\")
        os.system("netsh wlan show wlanreport > nul")
        os.rename("C:\\ProgramData\\Microsoft\\Windows\\WlanReport\\wlan-report-latest.html", CASEFOLDER +
              "/LiveResponseData/network/WLAN Report" + "/" + "wlan-report-latest.html")
        os.rename("C:\\ProgramData\\Microsoft\\Windows\\WlanReport\\wlan-report-latest.xml", CASEFOLDER +
              "/LiveResponseData/network/WLAN Report" + "/" + "wlan-report-latest.xml")
        os.rename("C:\\ProgramData\\Microsoft\\Windows\\WlanReport\\wlan-report-latest.cab", CASEFOLDER +
              "/LiveResponseData/network/WLAN Report" + "/" + "wlan-report-latest.cab")
    else:
        os.system("netsh wlan show wlanreport > nul")
        os.rename("C:\\ProgramData\\Microsoft\\Windows\\WlanReport\\wlan-report-latest.html", CASEFOLDER +
              "/LiveResponseData/network/WLAN Report" + "/" + "wlan-report-latest.html")
        os.rename("C:\\ProgramData\\Microsoft\\Windows\\WlanReport\\wlan-report-latest.xml", CASEFOLDER +
              "/LiveResponseData/network/WLAN Report" + "/" + "wlan-report-latest.xml")
        os.rename("C:\\ProgramData\\Microsoft\\Windows\\WlanReport\\wlan-report-latest.cab", CASEFOLDER +
              "/LiveResponseData/network/WLAN Report" + "/" + "wlan-report-latest.cab")


def external_ip():
    print("\t[-] Grabbing external IP address", flush=True)
    """Get public IP"""
    public_ip = pub_ip.get()
    with open("external_IP.txt", "w") as ipfout:
        ipfout.write("External host IP:\n")
        ipfout.write(public_ip)
    ipfout.close()
    os.rename(os.path.realpath('.') + "/" + "external_IP.txt", CASEFOLDER +
              "/LiveResponseData/network" + "/" + "external_IP.txt")


def fwlog_dump():
    """Dump Windows firewall config"""
    print("[+] Dumping Windows firewall config", flush=True)
    # setting up vars
    fw_cmd = os.system("netsh advfirewall show all >> firewall_config.txt")
    advfw_did = os.system("netsh advfirewall firewall show rule name=all dir=in type=dynamic >> firewall_config.txt")
    advfw_dod = os.system("netsh advfirewall firewall show rule name=all dir=out type=dynamic >> firewall_config.txt")
    advfw_dis = os.system("netsh advfirewall firewall show rule name=all dir=in type=static >> firewall_config.txt")
    advfw_dos = os.system("netsh advfirewall firewall show rule name=all dir=out type=static >> firewall_config.txt")
    os.rename(os.path.realpath('.') + "/" + "firewall_config.txt", CASEFOLDER + "/LiveResponseData/system" + "/" + "firewall_config.txt")


def windows_update_log():
    '''Convert ETL files to Windows Update log'''
    winuplog_src = "c:\\temp\\WindowsUpdate.log"
    winuplog_dst = CASEFOLDER + "\\LiveResponseData\\system\\WindowsUpdate.log"
    winuplog_run = "cmd /c powershell Get-WindowsUpdateLog -LogPath c:\\temp\\WindowsUpdate.log > nul"
    print("\n[+] Building Windows Update log from event trace log files", flush=True)

    if not os.path.isdir("C:\\Program Files (x86)\\Windows Defender\\"):
        try:
            os.makedirs("C:\\Program Files (x86)\\Windows Defender\\")
        except PermissionError:
            pass
    if not os.path.isfile("C:\\Program Files (x86)\\Windows Defender\\SymSrv.dll"):
        try:
            with open("C:\\Program Files (x86)\\Windows Defender\\SymSrv.dll", "w") as plug:
                plug.write("Pluggin a hole")
            plug.close()
        except PermissionError:
            pass

    subprocess.call(winuplog_run)

    try:
        if os.path.isfile(winuplog_src):
            shutil.move(winuplog_src, winuplog_dst)
        else:
            print("\n[!] Windows Update log was not generated correctly.", flush=True)
    except IOError as io_error:
        print(io_error)
        sys.exit("\n[!] Ouch! Something went wrong, but I'm not sure what :).")


def powershell_history():
    """Grab powershell console command history file"""
    print("[+] Acquiring existing powershell command history for all users\n", flush=True)
    user_list = os.popen("cmd.exe /C dir c:\\Users /b ")
    for users in user_list:
        users = users.strip()
        ps_history_src = "c:\\users\\{}\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt".format(users)
        ps_history_dst = CASEFOLDER + "\\LiveResponseData\\logs\\powershell_command_history_{}.txt".format(users)

        try:
            if os.path.isfile(ps_history_src):
                print("\t[+] Checking '{}' [OK]".format(users), flush=True)
                shutil.copy(ps_history_src, ps_history_dst)
            else:
                print("\t[-] Checking '{}' [NOT FOUND]".format(users), flush=True)
        except IOError as io_error_2:
            print(io_error_2)
            sys.exit("\n[!] Ouch! Something went wrong, but I'm not sure what :).")

    sys_pshf = "C:\\Windows\\System32\\config\\systemprofile\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt"
    ps_sys_history_dst = CASEFOLDER + "\\LiveResponseData\\logs\\powershell_command_history_SYSTEM.txt"

    if os.path.isfile(sys_pshf):
        print("\t[+] Checking 'SYSTEM' [OK]", flush=True)
        shutil.copy(sys_pshf, ps_sys_history_dst)
    else:
        print("\t[-] Checking 'SYSTEM' [NOT FOUND]", flush=True)


def system_data_gathering():
    """Gather system data"""
    # [BEGIN] System Data Gathering
    if ARGS.externalip:
        print("\n[+] Gathering system data\n", flush=True)
    else:
        print("[+] Gathering system data\n", flush=True)
    print("[+] Running Sysinternals tools\n", flush=True)
    print("\t[-] Accepting EULA", flush=True)
    print("\t[-] Executing toolset", flush=True)
    sys_internals_list = ['Autoruns', 'PsFile', 'PsLoggedOn',
                          'PsLogList', 'Tcpvcon', 'TCPView', 'Streams']

    for program in sys_internals_list:
        eula = "cmd.exe /C reg.exe ADD HKCU\\Software\\Sysinternals\\" + \
        program + " /v EulaAccepted /t REG_DWORD /d 1 /f"
        subprocess.call(eula, stdout=NOERROR, stderr=NOERROR)

    si_dir = os.path.realpath('.') + "\\sysinternals\\"

    # [autorunsc] setting up path to Sysinternals tools

    sys_proc = [
        {'Command': "autorunsc.exe", 'output': "autorunsc.txt",
         'outdir': "/persistence/"},
        {'Command': "psfile.exe", 'output': "psfile.txt", 'outdir': "/filesystem/"},
        {'Command': "PsLoggedon.exe", 'output': "PsLoggedon.txt", 'outdir':"/user/"},
        {'Command': "Tcpvcon.exe -a ", 'output': "Tcpvcon.txt", 'outdir':"/network/"},
        {'Command': "streams.exe  -s {}\\ ".format(os.getenv('WINDIR')),
         'output': "Alternate_data_streams.txt", 'outdir':"/filesystem/"}
    ]

    for sys_internals in sys_proc:
        sys_running_procs = si_dir + sys_internals['Command']
        with open(sys_internals['output'], "w+") as fout:
            subprocess.call(sys_running_procs, stdout=fout, stderr=NOERROR)
        os.rename(os.path.realpath('.') + "/" + sys_internals['output'],
                  CASEFOLDER + "/LiveResponseData" + sys_internals['outdir']
                  + sys_internals['output'])


def list_shadows():
    # Shadow copy info
    print("\n[+] Exporting shadow file data", flush=True)
    with open("shadow_files.txt", "w") as shd:
        subprocess.call("vssadmin list shadows", stdout=shd, stderr=NOERROR)
    shd.close()
    shadow_dst = CASEFOLDER + "\\LiveResponseData\\filesystem\\shadow_files.txt"
    os.rename(os.path.realpath('.') + "/" + "shadow_files.txt", shadow_dst)


def evtparseall():
    """Function to parse all events in the APP, SEC, SYS, & POWERSHELL event logs"""
    print("[+] Parsing all events in the APP, SEC, & SYS event logs\n", flush=True)
    # [psloglist] setting up path to EXE
    si_dir = os.path.realpath('.') + "\\sysinternals\\"
    si_psloglist_exe_path = si_dir + "psloglist.exe -accepteula"

    # [psloglist] setting parameters
    si_psloglist_app_param = " -s -x -nobanner application"
    si_psloglist_sec_param = " -s -x -nobanner security"
    si_psloglist_sys_param = " -s -x -nobanner system"
    si_psloglist_ps_param = ' -s -x -nobanner "Windows PowerShell"'

    # [psloglist] setting execution command
    si_psloglist_app_exec = si_psloglist_exe_path + si_psloglist_app_param
    si_psloglist_sec_exec = si_psloglist_exe_path + si_psloglist_sec_param
    si_psloglist_sys_exec = si_psloglist_exe_path + si_psloglist_sys_param
    si_psloglist_ps_exec = si_psloglist_exe_path + si_psloglist_ps_param

    # [psloglist] running
    with open('eventlogs-all.csv', 'w') as fout:
        subprocess.call(si_psloglist_app_exec, stdout=fout, stderr=NOERROR)
        subprocess.call(si_psloglist_sec_exec, stdout=fout, stderr=NOERROR)
        subprocess.call(si_psloglist_sys_exec, stdout=fout, stderr=NOERROR)
        subprocess.call(si_psloglist_ps_exec, stdout=fout, stderr=NOERROR)

    # [psloglist] moving output to case folder
    os.rename(os.path.realpath('.') + "/" + "eventlogs-all.csv",\
     CASEFOLDER + "/LiveResponseData/logs" + "/" + "eventlogs-all.csv")


def evtparse():
    """Function to collect event logs"""
    print("\n[+] Parsing key events from APP, SEC, SYS, & PowerShell\n", flush=True)
    si_dir = os.path.realpath('.') + "\\sysinternals\\"
    si_psloglist_app_evt_list = "1000,1001,1002,1022,1033,1034,1511,1518,11707,11708,11724"
    si_psloglist_sec_evt_list = "1102,4624,4625,4634,4647,4672,4648,\
4688,4697,4698,4699,4700,4701,4702,4720,4722,4724,4728,4732,\
4735,4738,4756,4776,4778,4779,4798,4799,4880,4881,4896,4898,5140,\
5145,7034,7036,7040,4649,4768,4769,4770,4771,4800,4801,4802,4803,4723,4725,\
4726,4727,4729,4731,4733,4737,4740,4741,4742,4743,4754,4755,4757,4764,\
4765,4766,4767,4780,4616,4821,4822,4823,4824,4886,4887,4899,4900,4713,4662"
    si_psloglist_sys_evt_list = "6,104,7035,7045"
    si_psloglist_ps_evt_list = "600,4103,4104,4105,4106"
    pslog_list = [
        {'Command': "psloglist.exe -accepteula -s -x -nobanner -i {} \
         Application".format(si_psloglist_app_evt_list),
         'output': "eventlogs_key_events.csv", 'outdir':"/logs/"},
        {'Command': "psloglist.exe -accepteula -s -x -nobanner -i {} \
         Security".format(si_psloglist_sec_evt_list),
         'output': "eventlogs_key_events.csv", 'outdir':"/logs/"},
        {'Command': "psloglist.exe -accepteula -s -x -nobanner -i {} \
         System".format(si_psloglist_sys_evt_list),
         'output': "eventlogs_key_events.csv", 'outdir':"/logs/"},
        {'Command': 'psloglist.exe -accepteula -s -x -nobanner -i {} \
         "Windows PowerShell"'.format(si_psloglist_ps_evt_list),
         'output': "eventlogs_key_events.csv", 'outdir':"/logs/"}
        ]
    for pslog in pslog_list:
        pslog_running_procs = pslog['Command']
        with open(pslog['output'], "a") as fout:
            subprocess.call(si_dir + pslog_running_procs, stdout=fout, stderr=subprocess.STDOUT, shell=True)
    os.rename(os.path.realpath('.') + "/" + pslog_list[0]['output'],
              CASEFOLDER + "/LiveResponseData" + pslog_list[0]['outdir'] + pslog_list[0]['output'])


    # Grabbing and parsing virtual drive operations event log
    vhd_logfile_src = "C:\\Windows\\System32\\Winevt\\Logs\\Microsoft-Windows-VHDMP-Operational.evtx"
    if not os.path.exists(vhd_logfile_src):
        no_vmount = CASEFOLDER + "/LiveResponseData/logs/" + "vhd_mount_log.txt"
        with open(no_vmount, "w") as no_vhd:
            no_vhd.write("No virtual drive mounts found on this system.")
        no_vhd.close()
        print("[!] Skipping virtual drive mount info, no log found", flush=True)

    else:
        print("[+] Parsing virtual drive mounts", flush=True)
        vhd_log_cmd_dir = os.path.realpath('.') + "\\EvtxECmd\\"
        vhd_logfile_dst = os.path.realpath('.') + "\\Microsoft-Windows-VHDMP-Operational.evtx"
        shutil.copy2(vhd_logfile_src, vhd_logfile_dst)
        vhd_logfile = vhd_logfile_dst
        vhdoutput_dir1 = os.path.realpath('.')
        vhdoutput_file = "vhd_mount_log.csv"
        vhd_evtx_cmd = '{}evtxecmd.exe -f "{}" --inc 1 --csv {} --csvf {}'.format(vhd_log_cmd_dir, vhd_logfile, vhdoutput_dir1, vhdoutput_file)
        subprocess.call(vhd_evtx_cmd, stdout=NOERROR, stderr=subprocess.STDOUT, shell=True)
        os.rename(os.path.realpath('.') + "/" + "vhd_mount_log.csv",
                  CASEFOLDER + "/LiveResponseData" + "/logs/" + "vhd_mount_log.csv")



    # Grabbing and parsing Windows Firewall event log
    fw_log_cmd_dir = os.path.realpath('.') + "\\EvtxECmd\\"
    fw_logfile_src = "C:\\Windows\\System32\\Winevt\\Logs\\Microsoft-Windows-Windows Firewall With Advanced Security%4Firewall.evtx"
    print("\n[+] Parsing firewall events", flush=True)
    fw_logfile_dst = os.path.realpath('.') + "\\Microsoft-Windows-Windows Firewall With Advanced Security%4Firewall.evtx"
    shutil.copy2(fw_logfile_src, fw_logfile_dst)
    fw_logfile = fw_logfile_dst
    fwoutput_dir1 = os.path.realpath('.')
    fwoutput_file = "firewall_events.csv"
    fw_evtx_cmd = '{}evtxecmd.exe -f "{}" --inc 2004,2005,2006,2009,2033 --csv {} --csvf {}'.format(fw_log_cmd_dir, fw_logfile, fwoutput_dir1, fwoutput_file)
    subprocess.call(fw_evtx_cmd, stdout=NOERROR, stderr=subprocess.STDOUT, shell=True)
    os.rename(os.path.realpath('.') + "/" + "firewall_events.csv",
              CASEFOLDER + "/LiveResponseData" + "/logs/" + "firewall_events.csv")



    # Grabbing and parsing RDP Local Session Manager Operational event log
    evtxecmd_dir = os.path.realpath('.') + "\\EvtxECmd\\"
    rdp_logfile_src = "C:\\Windows\\System32\\Winevt\\Logs\\Microsoft-Windows-TerminalServices-LocalSessionManager%4Operational.evtx"
    print("\n[+] Parsing RPD logon/logoff events", flush=True)
    rdp_logfile_dst = os.path.realpath('.') + "\\Microsoft-Windows-TerminalServices-LocalSessionManager%4Operational.evtx"
    shutil.copy2(rdp_logfile_src, rdp_logfile_dst)
    rdp_logfile = rdp_logfile_dst
    output_dir1 = os.path.realpath('.')
    output_file = "rdp_logon_logoff_events.csv"
    rdp_evtx_cmd = '{}evtxecmd.exe -f "{}" --inc 21,23 --csv {} --csvf {}'.format(evtxecmd_dir, rdp_logfile, output_dir1, output_file)
    subprocess.call(rdp_evtx_cmd, stdout=NOERROR, stderr=subprocess.STDOUT, shell=True)
    os.rename(os.path.realpath('.') + "/" + "rdp_logon_logoff_events.csv",
              CASEFOLDER + "/LiveResponseData" + "/logs/" + "rdp_logon_logoff_events.csv")


def evtxall():
    """Function to pull full APP, SYS, SEC, Powershell, & Firewall event log (evtx) files"""
    print("[+] Grabbing App, Sys, Sec, Powershell, & Firewall (.evtx) files\n", flush=True)

    event_log_path = "C:\\Windows\\System32\\winevt\\Logs"
    event_log_dst = CASEFOLDER + "\\LiveResponseData\\logs"
    app_log_src = "{}\\Application.evtx".format(event_log_path)
    sys_log_src = "{}\\System.evtx".format(event_log_path)
    sec_log_src = "{}\\Security.evtx".format(event_log_path)
    ps_log_src = "{}\\Windows PowerShell.evtx".format(event_log_path)
    fw_log_src = "{}\\Microsoft-Windows-Windows Firewall With Advanced Security%4Firewall.evtx".format(event_log_path)

    # executing file copy using shutil.copy2 in order to preserve file metadata
    shutil.copy2(app_log_src, event_log_dst)
    shutil.copy2(sys_log_src, event_log_dst)
    shutil.copy2(sec_log_src, event_log_dst)
    shutil.copy2(ps_log_src, event_log_dst)
    shutil.copy2(fw_log_src, event_log_dst)



def prefetch_p():
    """Parse the Prefetch"""
    # [BEGIN] Prefetch Parsing
    print("\n[+] Parsing prefetch data\n", flush=True)

    # [pf] setting up path to Eric Zimmermans tools
    pecmd_dir = os.path.realpath('.') + "\\PECmd\\"

    # [pf] setting up path to EXE and adding the -d option for directory
    pf_exe_path = pecmd_dir + "PECmd.exe -d  "

    # [pf] directory location of Prefetch files
    pf_directory = "{}\\LiveResponseData\\Prefetch\\raw".format(CASEFOLDER)

    # [pf] setting full pf.exe command with args
    pf_command = pf_exe_path + pf_directory

    # Execute the pf command and directing output to a file
    with open('parsed-prefetch.txt', 'w') as fout:
        subprocess.call(pf_command, stdout=fout)

    # moving prefetch info to case folder
    os.rename(os.path.realpath('.') + "/" + "parsed-prefetch.txt",
              CASEFOLDER + "\\LiveResponseData\\Prefetch\\parsed-prefetch.txt")


def registry_stuff():
    """[BEGIN] registry Extraction"""
    print("[+] Dumping & parsing registry hives\n", flush=True)
    registry_dump_hives = {"SAM": r'HKLM\SAM', "SYSTEM": r'HKLM\SYSTEM',
                           "SECURITY": r'HKLM\SECURITY', "SOFTWARE": r'HKLM\SOFTWARE'}
    for hive in registry_dump_hives:
        reg = "cmd.exe /C reg.exe SAVE " + registry_dump_hives[hive]
        reg_out = " " + CASEFOLDER + "\\LiveResponseData\\registry\\raw\\" + hive + " " + hive + ".hiv"
        reg_dump = reg + reg_out
        subprocess.call(reg_dump, stdout=NOERROR, stderr=NOERROR)
    # [END] registry Extraction

    # [BEGIN] registry Parsing
    # [Regripper] setting up path to Regripper
    rr_dir = os.path.realpath('.') + "\\regripper\\"

    # [Regripper] setting up path to EXE
    rr_exe_path = rr_dir + "rip.exe"

    # [Regripper] setting parameters
    registry_hives_os = ["SAM", "SYSTEM", "SECURITY", "SOFTWARE"]
    for hives in registry_hives_os:
        param_1 = " -r " + CASEFOLDER + "\\LiveResponseData\\registry\\" + hives + " -f " + hives
        reg_exec = rr_exe_path + param_1
        out_put_file = hives + "-parsed.txt"
        with open(out_put_file, 'w') as fout:
            subprocess.call(reg_exec, stdout=fout, stderr=NOERROR)
        os.rename(os.path.realpath('.') + "/" + out_put_file, CASEFOLDER +
                  "/LiveResponseData/registry" + "/" + out_put_file)

    # [Regripper] building user reg file list
    for root, dirs, files in os.walk(CASEFOLDER + "\\LiveResponseData\\registry\\raw"):
        registry_hives_users = [file for file in files if file.endswith(".DAT")]
        # [Regripper] processing user reg files with regripper
        for userreg in registry_hives_users:
            if "USRCLASS" in userreg:
                param_2 = " -r " + CASEFOLDER + "\\LiveResponseData\\registry\\" + userreg + " -f USRCLASS"
                reg_exec2 = rr_exe_path + param_2
                out_put_file2 = userreg + "-parsed.txt"
                with open(out_put_file2, 'w') as fout2:
                    subprocess.call(reg_exec2, stdout=fout2, stderr=NOERROR)
                fout2.close()
                os.rename(os.path.realpath('.') + "/" + out_put_file2, CASEFOLDER + "/LiveResponseData/registry" + "/" + out_put_file2)
            if "NTUSER" in userreg:
                param_3 = " -r " + CASEFOLDER + "\\LiveResponseData\\registry\\" + userreg + " -f NTUSER"
                reg_exec3 = rr_exe_path + param_3
                out_put_file3 = userreg + "-parsed.txt"
                with open(out_put_file3, 'w') as fout3:
                    subprocess.call(reg_exec3, stdout=fout3, stderr=NOERROR)
                fout3.close()
                os.rename(os.path.realpath('.') + "/" + out_put_file3, CASEFOLDER + "/LiveResponseData/registry" + "/" + out_put_file3)


def usb_ap():
    """Gather the USB artifacts"""
    # [BEGIN] USB Artifact Parsing
    print("[+] Grabbing USB logs\n", flush=True)

    # Detecting system architecture
    if os.path.exists("c:\\windows\\system32\\"):
        # variable to point to the location of "xcopy" on the remote system
        xcopy_dir = "c:\\windows\\system32\\"
        # setting up variables to run xcopy with appropriate parameters
        xcopy_param = xcopy_dir + "xcopy.exe C:\\Windows\\inf\\setupapi.*.log "
        xcopy_out = CASEFOLDER + "\\LiveResponseData\\usbdevices\\usb-install-logs"
        xcopy_usb = xcopy_param + xcopy_out

        # copying USB setup log from target
        subprocess.call(xcopy_usb, stdout=NOERROR, stderr=NOERROR)

    else:
        print("Xcopy missing from target", flush=True)


def log_total_runtime():
    runlog = CASEFOLDER + "\\runlog.txt"
    END_TIME = time.strftime("%H:%M:%S")
    etime = datetime.strptime(END_TIME, "%H:%M:%S")
    delta = etime - stime
    secs = delta.total_seconds()
    mins = secs / 60

    with open(runlog, "a+", newline="") as logupdate:
        logupdate.write('End time: ' + time.strftime("%m-%d-%Y %H:%M:%S") + '\n')
        logupdate.write('Total runtime: ' + str(mins) + ' minutes\n')

    logupdate.close()


def get_bitlocker():
    """Dumping bitlocker keys"""
    print("\n[+] Dumping bitlocker keys\n", flush=True)
    bl_dest = CASEFOLDER + "\\LiveResponseData\\system\\Bitlocker_key.txt"
    bl_cmd = "manage-bde -protectors C: -get >> Bitlocker_key.txt"

    # dumping bitlocker keys from target
    os.system(bl_cmd)

    # moving prefetch info to case folder
    os.rename(os.path.realpath('.') + "/" + "Bitlocker_key.txt", bl_dest)


def data_compress():
    """Log total runtime in runlog.txt"""
    log_total_runtime()

    """Allows compression for files """
    print("\n[+] Compressing triage output, please wait", flush=True)
    # Compress Case Folder output data
    # The Liveresponsedata is compressed to save space but the Forensic
    # images are not so we do not corrupt them
    file_compress_out = TARGETNAME + "." + DATEANDTIME +".zip"
    file_compress_in = "LiveResponseData.zip"
    zip_file_1 = zipfile.ZipFile(file_compress_in, "w", zipfile.ZIP_DEFLATED)
    current_dir = os.getcwd()
    os.chdir(CASEFOLDER)
    for dirname, subdirs, files in os.walk("LiveResponseData"):
        #Make pylint happy :)
        print(subdirs, file=NOERROR)
        zip_file_1.write(dirname)
        for filename in files:
            zip_file_1.write(os.path.join(dirname, filename))

    zip_file_1.close()
    os.chdir(current_dir)
    zip_file_2 = zipfile.ZipFile(file_compress_out, "w")
    os.rename(os.path.realpath('.') + "/" + file_compress_in, CASEFOLDER + "/" + file_compress_in)
    shutil.rmtree(os.path.realpath(CASEFOLDER + "/LiveResponseData"))
    for dirname, subdirs, files in os.walk(CASEFOLDER):
        zip_file_2.write(dirname)
        for filename in files:
            zip_file_2.write(os.path.join(dirname, filename))
    zip_file_2.close()
    shutil.rmtree(os.path.realpath(CASEFOLDER))


def get_browser_history():
    """Collect the browser history"""
    print("[+] Getting User Browsing History\n", flush=True)
    bhv_dir = os.path.realpath('.') + "\\BrowsingHistoryView\\"
    bhv_exe_path = bhv_dir + BVHRUN
    bhv_param = " /SaveDirect /sort 3 /VisitTimeFilterType 1 /cfg " + "BrowsingHistoryView.cfg /scomma " + CASEFOLDER + "/LiveResponseData/logs/BrowsingHistoryView.csv  "
    bhv_command = bhv_exe_path + bhv_param
    bhv_run = bhv_command
    subprocess.call(bhv_run, stderr=NOERROR)


def freespace_check(drive, minspace):
    """Check for free space on given drive"""
    usage = shutil.disk_usage(drive)
    if (usage.free // (2**30)) < minspace:  # the amount of free space required to get a full memory image in GB's
        if ARGS.memonly:
            print("\n[+] Checking free space", flush=True)
            print("\n\t[-] Free space is {} GB".format(usage.free // (2**30)), flush=True)
            print("\n\t[!] Disk space low on target, unable to dump memory. Please free up space on target and retry.", flush=True)
            env_cleanup()
            sys.exit()
        if ARGS.memory:
            print("\n[+] Checking free space", flush=True)
            print("\n\t[-] Free space is {} GB".format(usage.free // (2**30)), flush=True)
            print("\n\t[!] Disk space too low on target, unable to dump memory\n \n\t[!] Free up space or remove the -m argument and retry\n",
                flush=True)
            env_cleanup()
            sys.exit()
        if ARGS.pagefile:
            print("\n[+] Checking for additional free space for pagefile", flush=True)
            print("\n\t[-] Free space is {} GB".format(usage.free // (2**30)), flush=True)
            print("\n\t[!] Disk space too low on target, unable to grab pagefile file\n \n\t[!] Free up space or remove -p argument and retry\n", flush=True)
            env_cleanup()
            sys.exit()
        if ARGS.hiberfil:
            if os.path.isfile("C:\\hiberfil.sys"):
                print("\n[+] Checking for additional free space for hiberfil.sys", flush=True)
                print("\n\t[-] Free space is {} GB".format(usage.free // (2**30)), flush=True)
                print("\n\t[!] Disk space too low on target, unable to grab system files\n \n\t[!] Free up space or remove -hf argument and retry\n", flush=True)
                env_cleanup()
                sys.exit()
            else:
                no_file_out = CASEFOLDER + "/ForensicImages/system-files/" + "hiberfil.sys.txt"
                with open(no_file_out, "w") as no_file:
                    no_file.write("Hiberfil.sys not found on this system.")
                no_file.close()
                print("[!] Skipping hiberfil.sys collection, no file found\n", flush=True)

def get_defender_scanlogs():
    """Grab Windows Defender scan log"""
    print("\n[+] Pulling Windows Defender scanlog", flush=True)
    scanlog_dir = "c:\\programdata\\microsoft\\windows defender\\support\\"
    for root, dirs, files in os.walk(scanlog_dir):
        #Make pylint happy :)
        print(dirs, root, file=NOERROR)
        for file in files:
            if file.startswith("MPLog-"):
                scanlog_src = "{}\\{}".format(scanlog_dir, file)
                scanlog_dst = "{}/LiveResponseData/logs/Windows_Defender_Scanlogs_{} \
                ".format(CASEFOLDER, file)
                shutil.copy(scanlog_src, scanlog_dst)
            else:
                pass


def fget_copy(val):
    """Use fget to copy User registry files that are in use"""

    if " Documents" in val:
        pass
    elif val == "Public":
        pass
    elif val == "ADMINI~1":
        pass
    else:
        print("[+] Grabbing locked files from " + val + "\n", flush=True)
        files = ""
        file_list = "cmd.exe /C dir /a c:\\Users\\" + "\"" + val + "\"" + "\\" +"NTUSER.dat*" + " /b "
        all_ntuser_dat = subprocess.check_output(file_list, stderr=NOERROR, universal_newlines=True)
        list_of_files = all_ntuser_dat.rsplit("\n")
        fget_dir = os.path.realpath('.') + "\\FGET\\"
        for files in list_of_files:
            if files == "":
                pass
            else:
                fget_usrclass_output = CASEFOLDER + "/LiveResponseData/Registry/raw/" + val + "_" + "USRCLASS.DAT"
                fget_ntuser_output = CASEFOLDER + "/LiveResponseData/Registry/raw/" + "\"" + val + "\"" + "_" + files
                fget_exe_path = fget_dir + "FGET.exe -extract" + r' c:\Users\\' + "\"" + val + "\""+ "\\" + files + " " + fget_ntuser_output
                fget_exe_usrclass_path = fget_dir + "FGET.exe -extract" + " c:\\Users\\" + val + "\\AppData\\Local\\Microsoft\\Windows\\USRCLASS.DAT" + " " + fget_usrclass_output
                # Foresic copy of users NTUSER.DAT & USRCLASS.DAT
                subprocess.call(fget_exe_path, stdout=NOERROR, stderr=NOERROR)
                subprocess.call(fget_exe_usrclass_path, stdout=NOERROR, stderr=NOERROR)


def collect_hiberfil():
    """Using Fget to copy locked system files"""
    if os.path.isfile(CASEFOLDER + "/ForensicImages/system-files/" + "hiberfil.sys.txt"):
        pass

    else:
        print("[+] Collecting hiberfil.sys\n", flush=True)

        if COMPILED == 0:
            hiber_file = {"hiberfil.sys" : r'c:'}
        else:
            hiber_file = {"hiberfil.sys" : r'c:'}

        fget_dir = os.path.realpath('.') + "\\FGET\\"

        for hfile in hiber_file:
            col_hiber_file_output = CASEFOLDER + "/ForensicImages/system-files/" + hfile
            col_hiber_file_exe_path = fget_dir + "FGET.exe -extract" + " " + hiber_file[hfile] + "\\" + hfile + " " + col_hiber_file_output
            subprocess.call(col_hiber_file_exe_path, stdout=NOERROR, stderr=NOERROR)


def collect_pagefile():
    """Using Fget to copy locked system files"""
    if os.path.isfile("C:\\pagefile.sys"):
        print("[+] Collecting pagefile\n", flush=True)

        if COMPILED == 0:
            page_file = {"pagefile.sys" : r'c:'}
        else:
            page_file = {"pagefile.sys" : r'c:'}

        fget_dir = os.path.realpath('.') + "\\FGET\\"

        for pfile in page_file:
            col_pfile_output = CASEFOLDER + "/ForensicImages/system-files/" + pfile
            col_pfile_exe_path = fget_dir + "FGET.exe -extract" + " " + page_file[pfile] + "\\" + pfile + " " + col_pfile_output
            subprocess.call(col_pfile_exe_path, stdout=NOERROR, stderr=NOERROR)

    else:
        print("[+] Skipping pagefile collection, file not found on OS drive\n", flush=True)


def collect_srum():
    """Using Fget to copy locked system files"""
    print("[+] Collecting SRUM database\n", flush=True)

    if COMPILED == 0:
        srum_db = {"srudb.dat" : r'c:\windows\system32\sru'}
    else:
        if OSARCH == 64:
            srum_db = {"srudb.dat" : r'c:\windows\Sysnative\sru'}
        else:
            srum_db = {"srudb.dat" : r'c:\windows\system32\sru'}

    fget_dir = os.path.realpath('.') + "\\FGET\\"

    for sdb in srum_db:
        col_sdb_file_output = CASEFOLDER + "/ForensicImages/system-files/" + sdb
        col_sdb_file_exe_path = fget_dir + "FGET.exe -extract" + " " + srum_db[sdb] + "\\" + sdb + " " + col_sdb_file_output
        subprocess.call(col_sdb_file_exe_path, stdout=NOERROR, stderr=NOERROR)


##########################################################################
#   All function calls should be defined above this.                     #
##########################################################################

banner()
sys.stdout.flush()
has_admin_access()
core_integrity()
env_setup()

if ARGS.memonly:
    freespace_check("C:", 60)
    mem_scrape()
    data_compress()
    triage_acquistion_hash()
    banner()
    sys.stdout.flush()
    env_cleanup()
    sys.exit(0)

if ARGS.pageonly:
    freespace_check("C:", 60)
    collect_pagefile()
    triage_acquistion_hash()
    data_compress()
    banner()
    sys.stdout.flush()
    env_cleanup()
    sys.exit(0)

if ARGS.hiberfonly:
    freespace_check("C:", 60)
    collect_hiberfil()
    triage_acquistion_hash()
    data_compress()
    banner()
    sys.stdout.flush()
    env_cleanup()
    sys.exit(0)

if ARGS.browserhistonly:
    get_browser_history()
    triage_acquistion_hash()
    data_compress()
    banner()
    sys.stdout.flush()
    env_cleanup()
    sys.exit(0)

if ARGS.pagefile:
    freespace_check("C:", 100)
    collect_pagefile()

if ARGS.hiberfil:
    freespace_check("C:", 100)
    collect_hiberfil()

if ARGS.srumdb:
    collect_srum()

if ARGS.memory:
    freespace_check("C:", 100)
    mem_scrape()

if ARGS.evtlogparseall:
    evtparseall()

if ARGS.evtlogfiles:
    evtxall()

pre_fetch()
powershell_history()
last_user()
USERS_LIST = list_users()

for user in USERS_LIST:
    fget_copy(user)

user_account_report()
fwlog_dump()
dump_procs()
generate_file_list("C:\\", "full_file_list.csv.txt")
volatile_data_gather()
network_data_gathering()

if ARGS.externalip:
    external_ip()

if ARGS.bitlocker:
    get_bitlocker()

system_data_gathering()
list_shadows()
windows_update_log()
get_defender_scanlogs()
evtparse()
prefetch_p()
registry_stuff()
usb_ap()
get_browser_history()

if ARGS.md5hash:
    hash_exes()

if ARGS.sha1hash:
    hash_exes()

if ARGS.sha256hash:
    hash_exes()

triage_acquistion_hash()
data_compress()
banner()
sys.stdout.flush()
env_cleanup()
sys.exit(0)

```

`data/core.ir_file-info.txt`:

```txt
==================================================
Filename          : core.ir
MD5               : 49e8595f34f699f708c8ccaa64e95959
SHA1              : 49c71f82bb9b121407888a30ae2866ea2f0fdc5a
CRC32             : fd766f19
SHA-256           : 439afd6d70e8fe0635ab335cadd923bc1396f8a463ff794c026f6cc517e8086a
SHA-512           : 4bce2b68105055fe640e396e55d0c976b909cd90ffc5fc10b3cf9e5c3011ed6e3c4e2f3af2e080356bae4a5f56e5479c60a4ba3be798114add15f5e673ac5d17
SHA-384           : 4c8dd97cb048e3d04bef0800146522b6e74fcae9dfc90415bc71221a8105d90eee5e13c0b4ea950c3f8df060d3dea469
Modified Time     : 12/7/2023 1:05:39 PM
Created Time      : 12/1/2023 10:35:11 AM
Entry Modified Time: 12/7/2023 1:05:54 PM
File Size         : 27,259,088
File Version      : 
Product Version   : 
Identical         : 
Extension         : ir
File Attributes   : A
==================================================


```