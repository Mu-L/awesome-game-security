Project Path: arc_memflow_memflow-kvm_nmp3nbls

Source Tree:

```txt
arc_memflow_memflow-kvm_nmp3nbls
├── Cargo.lock
├── Cargo.toml
├── LICENSE
├── Makefile
├── README.md
├── dkms.conf
├── install.rhai
├── mabi.h
├── memflow-kmod
│   ├── Kbuild
│   ├── LICENSE.md
│   ├── Makefile
│   ├── kallsyms
│   ├── main.c
│   ├── main.h
│   ├── mmap_lock.h
│   ├── vmtools.c
│   └── vmtools.h
├── memflow-kvm
│   ├── Cargo.toml
│   ├── README.md
│   └── src
│       └── lib.rs
├── memflow-kvm-ioctl
│   ├── Cargo.toml
│   ├── build.rs
│   ├── mabi.h
│   ├── src
│   │   └── lib.rs
│   └── wrapper.h
└── umode_test.c

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "abi_stable"
version = "0.10.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c8f0d5c8e09e8b591f6db9f56b006c9b9e7a44064acb274411ae51aaaa1364d"
dependencies = [
 "abi_stable_derive",
 "abi_stable_shared",
 "core_extensions",
 "crossbeam-channel",
 "generational-arena",
 "libloading 0.7.4",
 "lock_api",
 "parking_lot",
 "paste",
 "repr_offset",
 "rustc_version 0.4.0",
 "serde",
 "serde_derive",
 "serde_json",
]

[[package]]
name = "abi_stable_derive"
version = "0.10.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b9810ef8debee5544010d92dac0b88b32853cd5bd5ca3298243c99e931da0f0"
dependencies = [
 "abi_stable_shared",
 "as_derive_utils",
 "core_extensions",
 "proc-macro2",
 "quote",
 "rustc_version 0.2.3",
 "syn 1.0.109",
 "typed-arena",
]

[[package]]
name = "abi_stable_shared"
version = "0.10.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ece9da89066e018d908b48755e17cdd08a46ce222f84b1f226e837f836f84a5f"
dependencies = [
 "core_extensions",
]

[[package]]
name = "ahash"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91429305e9f0a25f6205c5b8e0d2db09e0708a7a6df0f42212bb56c32c8ac97a"
dependencies = [
 "cfg-if",
 "once_cell",
 "version_check",
 "zerocopy",
]

[[package]]
name = "aho-corasick"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2969dcb958b36655471fc61f7e416fa76033bdd4bfed0678d8fee1e2d07a1f0"
dependencies = [
 "memchr",
]

[[package]]
name = "allocator-api2"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0942ffc6dcaadf03badf6e6a2d0228460359d5e34b57ccdc720b7382dfbd5ec5"

[[package]]
name = "as_derive_utils"
version = "0.10.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0a26fa495cefb8c86d9ce183b3f39ad11678e54fb3c20e6b7dbd87770811d9b"
dependencies = [
 "core_extensions",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "autocfg"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"

[[package]]
name = "bindgen"
version = "0.69.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ffcebc3849946a7170a05992aac39da343a90676ab392c51a4280981d6379c2"
dependencies = [
 "bitflags 2.4.1",
 "cexpr",
 "clang-sys",
 "lazy_static",
 "lazycell",
 "log",
 "peeking_take_while",
 "prettyplease",
 "proc-macro2",
 "quote",
 "regex",
 "rustc-hash",
 "shlex",
 "syn 2.0.43",
 "which",
]

[[package]]
name = "bit_field"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc827186963e592360843fb5ba4b973e145841266c1357f7180c43526f2e5b61"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "327762f6e5a765692301e5bb513e0d9fef63be86bbc14528052b1cd3e6f03e07"

[[package]]
name = "bumpalo"
version = "3.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f30e7476521f6f8af1a1c4c0b8cc94f0bee37d91763d0ca2665f299b6cd8aec"

[[package]]
name = "cexpr"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
dependencies = [
 "nom",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "cglue"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9cbee103c8a337b7cf4d299133132237dff667d5f90cb1e97626a5caa1bb9ab9"
dependencies = [
 "abi_stable",
 "cglue-macro",
 "no-std-compat",
 "rustc_version 0.4.0",
 "serde",
 "tarc",
]

[[package]]
name = "cglue-gen"
version = "0.2.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09113ac46fb70539ed96b74af4382516fc25bfc463164eeb0ca036b9f77371d8"
dependencies = [
 "itertools 0.10.5",
 "lazy_static",
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "cglue-macro"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf28b8c74a050973c9972edfad2f32f404bc1ff6725e37d003e7d55504dec1cf"
dependencies = [
 "cglue-gen",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "clang-sys"
version = "1.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c688fc74432808e3eb684cae8830a86be1d66a2bd58e1f248ed0960a590baf6f"
dependencies = [
 "glob",
 "libc",
 "libloading 0.7.4",
]

[[package]]
name = "coarsetime"
version = "0.1.33"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "71367d3385c716342014ad17e3d19f7788ae514885a1f4c24f500260fb365e1a"
dependencies = [
 "libc",
 "once_cell",
 "wasi",
 "wasm-bindgen",
]

[[package]]
name = "core_extensions"
version = "1.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "92c71dc07c9721607e7a16108336048ee978c3a8b129294534272e8bac96c0ee"
dependencies = [
 "core_extensions_proc_macros",
]

[[package]]
name = "core_extensions_proc_macros"
version = "1.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69f3b219d28b6e3b4ac87bc1fc522e0803ab22e055da177bff0068c4150c61a6"

[[package]]
name = "crossbeam-channel"
version = "0.5.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82a9b73a36529d9c47029b9fb3a6f0ea3cc916a261195352ba19e770fc1748b2"
dependencies = [
 "cfg-if",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3a430a770ebd84726f584a90ee7f020d28db52c6d02138900f22341f866d39c"
dependencies = [
 "cfg-if",
]

[[package]]
name = "darling"
version = "0.20.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0209d94da627ab5605dcccf08bb18afa5009cfbef48d8a8b7d7bdbc79be25c5e"
dependencies = [
 "darling_core",
 "darling_macro",
]

[[package]]
name = "darling_core"
version = "0.20.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "177e3443818124b357d8e76f53be906d60937f0d3a90773a664fa63fa253e621"
dependencies = [
 "fnv",
 "ident_case",
 "proc-macro2",
 "quote",
 "strsim",
 "syn 2.0.43",
]

[[package]]
name = "darling_macro"
version = "0.20.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "836a9bbc7ad63342d6d6e7b815ccab164bc77a2d95d84bc3117a8c0d5c98e2d5"
dependencies = [
 "darling_core",
 "quote",
 "syn 2.0.43",
]

[[package]]
name = "dataview"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "47a802a2cad0ff4dfc4f3110da174b7a6928c315cae523e88638cfb72941b4d5"

[[package]]
name = "dataview"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50eb3a329e19d78c3a3dfa4ec5a51ecb84fa3a20c06edad04be25356018218f9"

[[package]]
name = "dirs"
version = "5.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44c45a9d03d6676652bcb5e724c7e988de1acad23a711b5217ab9cbecbec2225"
dependencies = [
 "dirs-sys",
]

[[package]]
name = "dirs-sys"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "520f05a5cbd335fae5a99ff7a6ab8627577660ee5cfd6a94a6a929b52ff0321c"
dependencies = [
 "libc",
 "option-ext",
 "redox_users",
 "windows-sys 0.48.0",
]

[[package]]
name = "either"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a26ae43d7bcc3b814de94796a5e736d4029efb0ee900c12e2d54c993ad1a1e07"

[[package]]
name = "equivalent"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"

[[package]]
name = "errno"
version = "0.3.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a258e46cdc063eb8519c00b9fc845fc47bcfca4130e2f08e88665ceda8474245"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "fixed-slice-vec"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bb23c599a9ff5b981529099902fe5de8d55ecc8c1f451542da17b8d2d65326e"

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "generational-arena"
version = "0.2.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877e94aff08e743b651baaea359664321055749b398adff8740a7399af7796e7"
dependencies = [
 "cfg-if",
]

[[package]]
name = "getrandom"
version = "0.2.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe9006bed769170c11f845cf00c7c1e9092aeb3f268e007c3e760ac68008070f"
dependencies = [
 "cfg-if",
 "libc",
 "wasi",
]

[[package]]
name = "glob"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2fabcfbdc87f4758337ca535fb41a6d701b65693ce38287d856d1674551ec9b"

[[package]]
name = "goblin"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f27c1b4369c2cd341b5de549380158b105a04c331be5db9110eef7b6d2742134"
dependencies = [
 "log",
 "plain",
 "scroll",
]

[[package]]
name = "hashbrown"
version = "0.14.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "290f1a1d9242c78d09ce40a5e87e7554ee637af1351968159f4952f028f75604"
dependencies = [
 "ahash",
 "allocator-api2",
]

[[package]]
name = "home"
version = "0.5.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3d1354bf6b7235cb4a0576c2619fd4ed18183f689b12b006a0ee7329eeff9a5"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "ident_case"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39"

[[package]]
name = "indexmap"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d530e1a18b1cb4c484e6e34556a0d948706958449fca0cab753d649f2bce3d1f"
dependencies = [
 "equivalent",
 "hashbrown",
]

[[package]]
name = "instant"
version = "0.1.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a5bbe824c507c5da5956355e86a746d82e0e1464f65d862cc5e71da70e94b2c"
dependencies = [
 "cfg-if",
]

[[package]]
name = "itertools"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
dependencies = [
 "either",
]

[[package]]
name = "itertools"
version = "0.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "25db6b064527c5d482d0423354fcd07a89a2dfe07b67892e62411946db7f07b0"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b1a46d1a171d865aa5f83f92695765caa047a9b4cbae2cbf37dbd613a793fd4c"

[[package]]
name = "lazy_static"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"

[[package]]
name = "lazycell"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"

[[package]]
name = "libc"
version = "0.2.151"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "302d7ab3130588088d277783b1e2d2e10c9e9e4a16dd9050e6ec93fb3e7048f4"

[[package]]
name = "libloading"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b67380fd3b2fbe7527a606e18729d21c6f3951633d0500574c4dc22d2d638b9f"
dependencies = [
 "cfg-if",
 "winapi",
]

[[package]]
name = "libloading"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c571b676ddfc9a8c12f1f3d3085a7b163966a8fd8098a90640953ce5f6170161"
dependencies = [
 "cfg-if",
 "windows-sys 0.48.0",
]

[[package]]
name = "libredox"
version = "0.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85c833ca1e66078851dba29046874e38f08b2c883700aa29a03ddd3b23814ee8"
dependencies = [
 "bitflags 2.4.1",
 "libc",
 "redox_syscall 0.4.1",
]

[[package]]
name = "linux-raw-sys"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4cd1a83af159aa67994778be9070f0ae1bd732942279cabb14f86f986a21456"

[[package]]
name = "lock_api"
version = "0.4.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c168f8615b12bc01f9c17e2eb0cc07dcae1940121185446edc3744920e8ef45"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5e6163cb8c49088c2c36f57875e58ccd8c87c7427f7fbd50ea6710b2f3f2e8f"

[[package]]
name = "memchr"
version = "2.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f665ee40bc4a3c5590afb1e9677db74a508659dfd71e126420da8274909a0167"

[[package]]
name = "memflow"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e4ab23adc6b68aa85d9d2d43c04f31c51b895acb323f807ff95ed8d844639b1"
dependencies = [
 "abi_stable",
 "bitflags 1.3.2",
 "bumpalo",
 "cglue",
 "coarsetime",
 "dataview 1.0.1",
 "dirs",
 "fixed-slice-vec",
 "goblin",
 "hashbrown",
 "itertools 0.12.0",
 "libloading 0.8.1",
 "log",
 "memflow-derive",
 "memmap",
 "no-std-compat",
 "once_cell",
 "pelite",
 "rangemap",
 "serde",
 "smallvec",
 "toml",
 "x86_64",
]

[[package]]
name = "memflow-derive"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d766f6681f968c92eb0359fc4bc99039ebe2568df4bb884c7cb7b16023e94d32"
dependencies = [
 "darling",
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn 2.0.43",
]

[[package]]
name = "memflow-kvm"
version = "0.2.1"
dependencies = [
 "log",
 "memflow",
 "memflow-kvm-ioctl",
]

[[package]]
name = "memflow-kvm-ioctl"
version = "0.1.2"
dependencies = [
 "bindgen",
]

[[package]]
name = "memmap"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6585fd95e7bb50d6cc31e20d4cf9afb4e2ba16c5846fc76793f11218da9c475b"
dependencies = [
 "libc",
 "winapi",
]

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "no-std-compat"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b93853da6d84c2e3c7d730d6473e8817692dd89be387eb01b94d7f108ecb5b8c"

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "once_cell"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"

[[package]]
name = "option-ext"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04744f49eae99ab78e0d5c0b603ab218f515ea8cfe5a456d7629ad883a3b6e7d"

[[package]]
name = "parking_lot"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d17b78036a60663b797adeaee46f5c9dfebb86948d1255007a1d6be0271ff99"
dependencies = [
 "instant",
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60a2cfe6f0ad2bfc16aefa463b497d5c7a5ecd44a23efa72aa342d90177356dc"
dependencies = [
 "cfg-if",
 "instant",
 "libc",
 "redox_syscall 0.2.16",
 "smallvec",
 "winapi",
]

[[package]]
name = "paste"
version = "1.0.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c"

[[package]]
name = "peeking_take_while"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19b17cddbe7ec3f8bc800887bab5e717348c95ea2ca0b1bf0837fb964dc67099"

[[package]]
name = "pelite"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c270b1a0c279bbcb4cff3d2294121731c48ee68f0435d26cf71018a853cb890"
dependencies = [
 "dataview 0.1.2",
 "no-std-compat",
 "pelite-macros",
]

[[package]]
name = "pelite-macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a7cf3f8ecebb0f4895f4892a8be0a0dc81b498f9d56735cb769dc31bf00815b"

[[package]]
name = "plain"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4596b6d070b27117e987119b4dac604f3c58cfb0b191112e24771b2faeac1a6"

[[package]]
name = "prettyplease"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae005bd773ab59b4725093fd7df83fd7892f7d8eafb48dbd7de6e024e4215f9d"
dependencies = [
 "proc-macro2",
 "syn 2.0.43",
]

[[package]]
name = "proc-macro-crate"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97dc5fea232fc28d2f597b37c4876b348a40e33f3b02cc975c8d006d78d94b1a"
dependencies = [
 "toml_datetime",
 "toml_edit",
]

[[package]]
name = "proc-macro2"
version = "1.0.71"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75cb1540fadbd5b8fbccc4dddad2734eba435053f725621c070711a14bb5f4b8"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.33"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5267fca4496028628a95160fc423a33e8b2e6af8a5302579e322e4b520293cae"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rangemap"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "977b1e897f9d764566891689e642653e5ed90c6895106acd005eb4c1d0203991"

[[package]]
name = "redox_syscall"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_syscall"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4722d768eff46b75989dd134e5c353f0d6296e5aaa3132e776cbdb56be7731aa"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_users"
version = "0.4.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a18479200779601e498ada4e8c1e1f50e3ee19deb0259c25825a98b5603b2cb4"
dependencies = [
 "getrandom",
 "libredox",
 "thiserror",
]

[[package]]
name = "regex"
version = "1.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "380b951a9c5e80ddfd6136919eef32310721aa4aacd4889a8d39124b026ab343"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f804c7828047e88b2d32e2d7fe5a105da8ee3264f01902f796c8e067dc2483f"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08c74e62047bb2de4ff487b251e4a92e24f48745648451635cec7d591162d9f"

[[package]]
name = "repr_offset"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb1070755bd29dffc19d0971cab794e607839ba2ef4b69a9e6fbc8733c1b72ea"
dependencies = [
 "tstr",
]

[[package]]
name = "rustc-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"

[[package]]
name = "rustc_version"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a"
dependencies = [
 "semver 0.9.0",
]

[[package]]
name = "rustc_version"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366"
dependencies = [
 "semver 1.0.20",
]

[[package]]
name = "rustix"
version = "0.38.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72e572a5e8ca657d7366229cdde4bd14c4eb5499a9573d4d366fe1b599daa316"
dependencies = [
 "bitflags 2.4.1",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.52.0",
]

[[package]]
name = "rustversion"
version = "1.0.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7ffc183a10b4478d04cbbbfc96d0873219d962dd5accaff2ffbd4ceb7df837f4"

[[package]]
name = "ryu"
version = "1.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f98d2aa92eebf49b69786be48e4477826b256916e84a57ff2a4f21923b48eb4c"

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "scroll"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "04c565b551bafbef4157586fa379538366e4385d42082f255bfd96e4fe8519da"
dependencies = [
 "scroll_derive",
]

[[package]]
name = "scroll_derive"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1db149f81d46d2deba7cd3c50772474707729550221e69588478ebf9ada425ae"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.43",
]

[[package]]
name = "semver"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403"
dependencies = [
 "semver-parser",
]

[[package]]
name = "semver"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "836fa6a3e1e547f9a2c4040802ec865b5d85f4014efe00555d7090a3dcaa1090"

[[package]]
name = "semver-parser"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3"

[[package]]
name = "serde"
version = "1.0.193"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "25dd9975e68d0cb5aa1120c288333fc98731bd1dd12f561e468ea4728c042b89"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.193"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43576ca501357b9b071ac53cdc7da8ef0cbd9493d8df094cd821777ea6e894d3"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.43",
]

[[package]]
name = "serde_json"
version = "1.0.108"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d1c7e3eac408d115102c4c24ad393e0821bb3a5df4d506a80f85f7a742a526b"
dependencies = [
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "serde_spanned"
version = "0.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eb3622f419d1296904700073ea6cc23ad690adbd66f13ea683df73298736f0c1"
dependencies = [
 "serde",
]

[[package]]
name = "shlex"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7cee0529a6d40f580e7a5e6c495c8fbfe21b7b52795ed4bb5e62cdf92bc6380"

[[package]]
name = "smallvec"
version = "1.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4dccd0940a2dcdf68d092b8cbab7dc0ad8fa938bf95787e1b916b0e3d0e8e970"

[[package]]
name = "strsim"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623"

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.43"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee659fb5f3d355364e1f3e5bc10fb82068efbf824a1e9d1c9504244a6469ad53"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "tarc"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88da97cd34718f47df2adae0c2310ee305e061c794b9c07fd33d8387f4ee2e1c"

[[package]]
name = "thiserror"
version = "1.0.51"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f11c217e1416d6f036b870f14e0413d480dbf28edbee1f877abaf0206af43bb7"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.51"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "01742297787513b79cf8e29d1056ede1313e2420b7b3b15d0a768b4921f549df"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.43",
]

[[package]]
name = "toml"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "185d8ab0dfbb35cf1399a6344d8484209c088f75f8f68230da55d48d95d43e3d"
dependencies = [
 "serde",
 "serde_spanned",
 "toml_datetime",
 "toml_edit",
]

[[package]]
name = "toml_datetime"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7cda73e2f1397b1262d6dfdcef8aafae14d1de7748d66822d3bfeeb6d03e5e4b"
dependencies = [
 "serde",
]

[[package]]
name = "toml_edit"
version = "0.20.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "396e4d48bbb2b7554c944bde63101b5ae446cff6ec4a24227428f15eb72ef338"
dependencies = [
 "indexmap",
 "serde",
 "serde_spanned",
 "toml_datetime",
 "winnow",
]

[[package]]
name = "tstr"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cca3264971090dec0feef3b455a3c178f02762f7550cf4592991ac64b3be2d7e"
dependencies = [
 "tstr_proc_macros",
]

[[package]]
name = "tstr_proc_macros"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e78122066b0cb818b8afd08f7ed22f7fdbc3e90815035726f0840d0d26c0747a"

[[package]]
name = "typed-arena"
version = "2.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6af6ae20167a9ece4bcb41af5b80f8a1f1df981f6391189ce00fd257af04126a"

[[package]]
name = "unicode-ident"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"

[[package]]
name = "version_check"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"

[[package]]
name = "volatile"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "442887c63f2c839b346c192d047a7c87e73d0689c9157b00b53dcc27dd5ea793"

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasm-bindgen"
version = "0.2.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ed0d4f68a3015cc185aff4db9506a015f4b96f95303897bfa23f846db54064e"
dependencies = [
 "cfg-if",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b56f625e64f3a1084ded111c4d5f477df9f8c92df113852fa5a374dbda78826"
dependencies = [
 "bumpalo",
 "log",
 "once_cell",
 "proc-macro2",
 "quote",
 "syn 2.0.43",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0162dbf37223cd2afce98f3d0785506dcb8d266223983e4b5b525859e6e182b2"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0eb82fcb7930ae6219a7ecfd55b217f5f0893484b7a13022ebb2b2bf20b5283"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.43",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7ab9b36309365056cd639da3134bf87fa8f3d86008abf99e612384a6eecd459f"

[[package]]
name = "which"
version = "4.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87ba24419a2078cd2b0f2ede2691b6c66d8e47836da3b6db8265ebad47afbfc7"
dependencies = [
 "either",
 "home",
 "once_cell",
 "rustix",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-sys"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
dependencies = [
 "windows-targets 0.48.5",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.0",
]

[[package]]
name = "windows-targets"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
dependencies = [
 "windows_aarch64_gnullvm 0.48.5",
 "windows_aarch64_msvc 0.48.5",
 "windows_i686_gnu 0.48.5",
 "windows_i686_msvc 0.48.5",
 "windows_x86_64_gnu 0.48.5",
 "windows_x86_64_gnullvm 0.48.5",
 "windows_x86_64_msvc 0.48.5",
]

[[package]]
name = "windows-targets"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a18201040b24831fbb9e4eb208f8892e1f50a37feb53cc7ff887feb8f50e7cd"
dependencies = [
 "windows_aarch64_gnullvm 0.52.0",
 "windows_aarch64_msvc 0.52.0",
 "windows_i686_gnu 0.52.0",
 "windows_i686_msvc 0.52.0",
 "windows_x86_64_gnu 0.52.0",
 "windows_x86_64_gnullvm 0.52.0",
 "windows_x86_64_msvc 0.52.0",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb7764e35d4db8a7921e09562a0304bf2f93e0a51bfccee0bd0bb0b666b015ea"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbaa0368d4f1d2aaefc55b6fcfee13f41544ddf36801e793edbbfd7d7df075ef"

[[package]]
name = "windows_i686_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"

[[package]]
name = "windows_i686_gnu"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a28637cb1fa3560a16915793afb20081aba2c92ee8af57b4d5f28e4b3e7df313"

[[package]]
name = "windows_i686_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"

[[package]]
name = "windows_i686_msvc"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ffe5e8e31046ce6230cc7215707b816e339ff4d4d67c65dffa206fd0f7aa7b9a"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d6fa32db2bc4a2f5abeacf2b69f7992cd09dca97498da74a151a3132c26befd"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a657e1e9d3f514745a572a6846d3c7aa7dbe1658c056ed9c3344c4109a6949e"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dff9641d1cd4be8d1a070daf9e3773c5f67e78b4d9d42263020c057706765c04"

[[package]]
name = "winnow"
version = "0.5.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b5c3db89721d50d0e2a673f5043fc4722f76dcc352d7b1ab8b8288bed4ed2c5"
dependencies = [
 "memchr",
]

[[package]]
name = "x86_64"
version = "0.14.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b835097a84e4457323331ec5d6eb23d096066cbfb215d54096dcb4b2e85f500"
dependencies = [
 "bit_field",
 "bitflags 2.4.1",
 "rustversion",
 "volatile",
]

[[package]]
name = "zerocopy"
version = "0.7.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74d4d3961e53fa4c9a25a8637fc2bfaf2595b3d3ae34875568a5cf64787716be"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.7.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ce1b18ccd8e73a9321186f97e46f9f04b778851177567b1975109d26a08d2a6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.43",
]

```

`Cargo.toml`:

```toml

[profile.bench]
debug = true

[profile.release]
lto = "fat"

[workspace]
resolver = "1"
members = [
    "memflow-kvm-ioctl",
    "memflow-kvm"
]

default-members = [
    "memflow-kvm-ioctl",
    "memflow-kvm"
]

#[patch.crates-io]
#memflow = { path = "../memflow/memflow" }

```

`LICENSE`:

```
Copyright (C) 2020 Aurimas Blažulionis <0x60@pm.me>

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`Makefile`:

```
all:
	cd memflow-kmod && make all

clean:
	cd memflow-kmod && make clean


```

`README.md`:

```md
# memflow's KVM connector and its driver

This is a connector for Kernel based virtual machines, by using a driver that maps all KVM pages into the memflow process (userspace -> userspace DMA).

`memflow-kmod` includes the kernel module that performs the operations.

`memflow-kvm-ioctl` provides a rust based IOCTL api to the kernel module.

`memflow-kvm` provides a memflow physical memory connector that uses the ioctl.

## Setup

#### Connector

Recommended way is to use [memflowup](https://github.com/memflow/memflowup).

#### Kernel module

**Your kernel must be compiled with `CONFIG_KALLSYMS=y`, and `CONFIG_KALLSYMS_ALL=y` being set in kconfig.**

Stable versions are available under [releases](https://github.com/memflow/memflow-kvm/releases).

Debian/Ubuntu package can be installed with `sudo dpkg -i memflow-dkms_${VERSION}_amd64.deb`, where `VERSION` is the version of the downloaded module.

For other distributions, run this command:
```
sudo dkms install --archive=memflow-${VERSION}-source-only.dkms.tar.gz
```

It might be necessary to also load the module at runtime:
```
sudo modprobe memflow
```

To load the module at startup create a new file in `/etc/modules-load.d/`:
```
/etc/modules-load.d/memflow-kvm.conf
---
# Load memflow-kvm module on startup
memflow
```

The simplest way to setup the kernel module is to create a new group called `memflow` and use a udev rule to set access rights to `/dev/memflow` automatically when the module is being loaded:

```
groupadd memflow
usermod -a -G memflow $USER
```

Then create the udev rule in `/etc/udev/rules.d/`:
```
/etc/udev/rules.d/99-memflow-kvm.rules
---
KERNEL=="memflow" SUBSYSTEM=="misc" GROUP="memflow" MODE="0660"
```

## Manual installation

#### Connector

Install the connector using `cargo build --release --all-features`. This will compile the connector in release mode and place it under `target/release/` directory. Do copy out the underlying shared library to `~/.local/lib/memflow/` if you want to use it across other memflow tools.

#### Kernel module

Initialize submodules:

```
git submodule update --init
```

Run `make`. output will be placed in `memflow-kmod/memflow.ko`.

Then to install the module:
```
source dkms.conf

mkdir /usr/src/$BUILT_MODULE_NAME-$PACKAGE_VERSION
cp -r * /usr/src/$BUILT_MODULE_NAME-$PACKAGE_VERSION

dkms build -m $BUILT_MODULE_NAME -v $PACKAGE_VERSION

dkms install -m $BUILT_MODULE_NAME -v $PACKAGE_VERSION
```

Then you can load the module:
```
sudo modprobe memflow
```

## FAQ

Q. I'm getting this warning:

```
warning: couldn't execute `llvm-config --prefix` (error: No such file or directory (os error 2))
warning: set the LLVM_CONFIG_PATH environment variable to the full path to a valid `llvm-config` executable (including the executable itself)
```

A. This warning is harmless and can be safely ignored.

## Licensing note

While `memflow-kvm-ioctl`, and `memflow-kvm` are licensed under the `MIT` license, `memflow-kmod` is licensed only under `GPL-2`.

```

`dkms.conf`:

```conf
MAKE="make KERNELDIR=/lib/modules/${kernelver}/build"
CLEAN="make clean"
BUILT_MODULE_NAME=memflow
BUILT_MODULE_LOCATION=memflow-kmod/
DEST_MODULE_LOCATION="/updates"
PACKAGE_NAME=memflow-dkms
PACKAGE_VERSION=0.2.1
REMAKE_INITRD=no
AUTOINSTALL=yes

```

`install.rhai`:

```rhai
fn install_message() {
    info("memflow-kvm kernel module installation finished");
    info("you might have to manually invoke 'modprobe memflow' after installation and make sure the /dev/memflow device is present and you have access to it.");
    info("it is also recommended to setup a 'memflow' user group in linux and add your user to it");
    info("additionally, you might want to setup a udev rule thatll make /dev/memflow accessible to that group.");
    info("see the readme for more details");
}

// builds the connector from a given path (never called by the engine directly)
fn build_from_path(ctx, repo_path) {
    info("Installing connector");
    cargo("build --release --all-features", repo_path);
    ctx.copy_cargo_plugin_artifact(repo_path, name_to_lib(ctx.crate_name()));

    info("Installing memflow-kvm kernel module");
    ctx.dkms_install(repo_path);

    post_install();

    install_message();
}

// builds the connector from local path
fn build_local(ctx) {
    build_from_path(ctx, ctx.build_path())
}

fn get_source(ctx) {
    // clone the repository with all submodules via git
    ctx.clone_repository()
}

// builds the connector from source
fn build_from_source(ctx) {
    build_from_path(ctx, get_source(ctx))
}

// downloads a binary release of the plugin, still needs dkms
fn install(ctx) {
    let libname = name_to_lib_with_arch(ctx.crate_name());
    let artifact = ctx.github_release_artifact(libname);
    ctx.write_plugin_artifact(artifact, name_to_lib(ctx.crate_name()));

    info("Installing memflow-kvm kernel module");
    let tarball = ctx.github_release_artifact("memflow-source-only.dkms.tar.gz");
    ctx.dkms_install(tarball);

    post_install();

    install_message();
}

fn post_install() {
    try {
        udev_add_rule("memflow-kvm", "KERNEL==\"memflow\" SUBSYSTEM==\"misc\" GROUP=\"memflow\" MODE=\"0660\"");
    } catch (err) {
        info("Your memflowup installation might be out of date, please make sure to use the latest version.")
    }
}

```

`mabi.h`:

```h
/* SPDX-License-Identifier: (GPL-2.0 WITH Linux-syscall-note) OR MIT */

#ifndef MABI_H
#define MABI_H

/**
 * @file mabi.h
 * @brief Define memflow kernel module ABI
 *
 * Provides all structures and ioctls for interacting with memflow's kernel module
 *
*/

#include <linux/types.h>
#include <linux/ioctl.h>

/// @brief structure describing a guest to host memory mapping
typedef struct vm_memslot {
	/// Base physical address in the guest
	__aligned_u64 base;
	/// Host virtual address where the guest base resides in
	__aligned_u64 host_base;
	/// Size of the mapping
	__aligned_u64 map_size;
} vm_memslot_t;

/// @brief structure describing the virtual machine
typedef struct vm_info {
	/// PID of userspace VM monitor.
	__kernel_pid_t userspace_pid;
	/// Number of memory slots allocated by userspace. After MEMFLOW_VM_INFO ioctl -
	/// number of slots in the VM
	__u32 slot_count;
	/// The memory slots, sorted by base address
	struct vm_memslot *slots;
} vm_info_t;

/// @brief structure describing memory layout of the mapped virtual machine
typedef struct vm_map_info {
	/// Number of memory slots that were allocated. After MEMFLOW_MAP_VM ioctl -
	/// number of slots that were mapped in the VM
	__u32 slot_count;
	/// The mapped memory slots, sorted by base address. Slots only include the regions that were mapped in,
	/// so the first, and the last slots may not be the full KVM memslots, if not everything is mapped in
	struct vm_memslot *slots;
} vm_map_info_t;

#define MEMFLOW_IOCTL_MAGIC 0x6d

/**
 * @brief Get a file descriptor to KVM based virtual machine
 *
 * Returns a file descriptor to KVM VMM in the given process. If the pid is 0, handle from any VMM is returned.
 * If the process does not have a KVM instance, -1 is returned.
 *
 * The KVM instance will not be freed until the returned fd is closed.
*/
#define MEMFLOW_OPEN_VM _IOR(MEMFLOW_IOCTL_MAGIC, 0, __kernel_pid_t)

/**
 * @brief Describe the virtual machine
 *
 * Fills `vm_info_t` structure that describes the virtual machine. Note that the memory layout of the VM may
 * change before it gets mapped in, so it is advised to use MEMFLOW_VM_MAP_INFO after mapping the VM in.
*/
#define MEMFLOW_VM_INFO _IOWR(MEMFLOW_IOCTL_MAGIC, 1, vm_info_t)

/**
 * @brief Map the VM and retrieve its memory layout
 *
 * Fills `vm_map_info_t` structure that describes the memory layout of the mapped VM. Returns a file descriptor
 * to the memory mapping handle. The VM memory stays mapped in, until the fd gets closed.
*/
#define MEMFLOW_MAP_VM _IOWR(MEMFLOW_IOCTL_MAGIC, 2, vm_map_info_t)

#endif

```

`memflow-kmod/Kbuild`:

```
obj-m += memflow.o
memflow-y := main.o vmtools.o

```

`memflow-kmod/LICENSE.md`:

```md
                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.
```

`memflow-kmod/Makefile`:

```
obj-y += memflow-kmod/

MCFLAGS += -O3
ccflags-y += ${MCFLAGS}
CC += ${MCFLAGS}

ifndef KERNELDIR
	KDIR := /lib/modules/$(shell uname -r)/build
else
	KDIR := $(KERNELDIR)
endif

KOUTPUT := $(PWD)

all:
	@echo "$(KOUTPUT)"
	make -C $(KDIR) M=$(KOUTPUT) src=$(PWD) modules

clean:
	make -C $(KDIR) M=$(KOUTPUT) src=$(PWD) clean
	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c
	rm -f Module.markers Module.symvers modules.order
	rm -rf .tmp_versions Modules.symvers

```

`memflow-kmod/main.c`:

```c
// SPDX-License-Identifier: GPL-2.0
#include "vmtools.h"
#include <linux/types.h>
#include <linux/version.h>
#include <linux/module.h>
#include <linux/miscdevice.h>
#include "../mabi.h"
#include "main.h"
#include "kallsyms/kallsyms.h"
#include "kallsyms/kallsyms.c"
#include "kallsyms/ksyms.h"

MODULE_DESCRIPTION("memflow kernel module used to support KVM backend");
MODULE_AUTHOR("Heep");
MODULE_LICENSE("GPL");

static int memflow_init(void);
static void memflow_exit(void);

module_init(memflow_init);
module_exit(memflow_exit);

static long memflow_ioctl(struct file *filp, unsigned int cmd, unsigned long argp);

static const struct file_operations memflow_chardev_ops = {
	.owner = THIS_MODULE,
	.unlocked_ioctl = memflow_ioctl
};

static struct miscdevice memflow_dev = {
	MEMFLOW_IOCTL_MAGIC,
	"memflow",
	&memflow_chardev_ops
};


KSYMDEF(kvm_lock);
KSYMDEF(vm_list);

static int memflow_init(void)
{
	int r;

	if ((r = init_kallsyms()))
		return r;

	KSYMINIT_FAULT(kvm_lock);
	KSYMINIT_FAULT(vm_list);

	r = misc_register(&memflow_dev);

	if (r)
		return r;

	mprintk("initialized\n");

	return 0;
}

static void memflow_exit(void)
{
	misc_deregister(&memflow_dev);
	mprintk("uninitialized\n");
}

static long memflow_ioctl(struct file *filp, unsigned int cmd, unsigned long argp)
{
	pid_t target_pid = argp;

	switch (cmd) {
		case MEMFLOW_OPEN_VM:
			return open_vm(target_pid);
	}

	return -1;
}

```

`memflow-kmod/main.h`:

```h
/* SPDX-License-Identifier: GPL-2.0 */

#ifndef MEMFLOW_H
#define MEMFLOW_H

#include <linux/printk.h>
#define mprintk(format, ...) printk(KBUILD_MODNAME": "format, ##__VA_ARGS__)

#endif

```

`memflow-kmod/mmap_lock.h`:

```h
/* SPDX-License-Identifier: GPL-2.0 */

#ifndef MMAP_LOCK_H
#define MMAP_LOCK_H

#include <linux/version.h>

#if LINUX_VERSION_CODE < KERNEL_VERSION(5,8,0)
static inline void mmap_write_lock(struct mm_struct *mm)
{
	down_write(&mm->mmap_sem);
}

static inline void mmap_write_unlock(struct mm_struct *mm)
{
	up_write(&mm->mmap_sem);
}
#else
#include <linux/mmap_lock.h>
#endif

#endif

```

`memflow-kmod/vmtools.c`:

```c
// SPDX-License-Identifier: GPL-2.0
#include "vmtools.h"
#include "main.h"
#include "kallsyms/ksyms.h"
#include "../mabi.h"
#include <linux/kvm_host.h>
#include <linux/anon_inodes.h>
#include <linux/sort.h>
#include <linux/mm.h>
#include <linux/mman.h>
#include <linux/version.h>
#include "mmap_lock.h"

#if LINUX_VERSION_CODE < KERNEL_VERSION(5,17,0)
#define kvm_for_each_memslot2(memslot, bkt, slots) (void)bkt; kvm_for_each_memslot(memslot, slots)
#else
#define kvm_for_each_memslot2 kvm_for_each_memslot
#endif

static int memflow_vm_release(struct inode *inode, struct file *filp);
static long memflow_vm_ioctl(struct file *filp, unsigned int cmd, unsigned long argp);

static const struct file_operations memflow_vm_fops = {
	.release = memflow_vm_release,
	.unlocked_ioctl = memflow_vm_ioctl,
	.owner = THIS_MODULE
};

static int memflow_vm_mapped_release(struct inode *inode, struct file *filp);

struct vm_vma_map {
	unsigned long start, end;
};

struct vm_mapped_data {
	u32 mapped_vma_count;
	struct vm_vma_map vma_maps[KVM_MEM_SLOTS_NUM];
	vm_map_info_t vm_map_info;
	struct vm_memslot map_slots[KVM_MEM_SLOTS_NUM];
};

static const struct file_operations memflow_vm_mapped_fops = {
	.release = memflow_vm_mapped_release,
	.owner = THIS_MODULE
};

KSYMDEC(kvm_lock);
KSYMDEC(vm_list);

static int open_kvm(struct kvm *kvm)
{
	int fd = -1;

	fd = anon_inode_getfd("memflow-vm", &memflow_vm_fops, kvm, O_RDWR | O_CLOEXEC);

	if (fd < 0) {
		goto fail_fd;
	}

	return fd;

fail_fd:
	kvm_put_kvm(kvm);

	return -1;
}

int open_vm(pid_t target_pid)
{
	struct kvm *kvm;
	int ret = -1;

	mutex_lock(_kvm_lock);

	list_for_each_entry(kvm, _vm_list, vm_list) {
		kvm_get_kvm(kvm);

		if (target_pid == 0 || target_pid == kvm->userspace_pid) {
			ret = open_kvm(kvm);
			break;
		}

		kvm_put_kvm(kvm);
	}

	mutex_unlock(_kvm_lock);

	return ret;
}

static int memflow_vm_release(struct inode *inode, struct file *filp)
{
	struct kvm *kvm = filp->private_data;
	kvm_put_kvm(kvm);
	return 0;
}

static int memslot_compare(const void *lhs, const void *rhs) {
	gfn_t lbase = ((vm_memslot_t *)lhs)->base;
	gfn_t rbase = ((vm_memslot_t *)rhs)->base;

	if (lbase < rbase)
		return -1;
	if (lbase > rbase)
		return 1;
	return 0;
}

static int get_sorted_memslots(struct kvm_memslots *slots, int max_slots, vm_memslot_t *slots_out)
{
	struct kvm_memory_slot *slot;
	int slot_count, bkt;

	slot_count = 0;
	kvm_for_each_memslot2(slot, bkt, slots) {
		if (slot->npages && slot->npages != -1) {
			slots_out[slot_count++] = (vm_memslot_t) {
				.base = gfn_to_gpa(slot->base_gfn),
				.host_base = slot->userspace_addr,
				.map_size = gfn_to_gpa(slot->npages)
			};
		}
	}

	sort(slots_out, slot_count, sizeof(*slots_out), memslot_compare, NULL);

	//TODO: coalesce nearby slots

	return slot_count;
}

static int get_vm_info(struct kvm *kvm, vm_info_t __user *user_info)
{
	vm_info_t kernel_info;
	vm_memslot_t *memslot_map;
	vm_memslot_t __user *user_slots;
	struct kvm_memslots *slots;
	struct kvm_memory_slot *slot;
	int ret, bkt;
	u32 used_slots, slot_count;

	ret = -1;

	if (copy_from_user(&kernel_info, user_info, sizeof(vm_info_t)))
		goto do_return;

	user_slots = kernel_info.slots;

	mutex_lock(&kvm->lock);
	mutex_lock(&kvm->slots_lock);

	if (!kernel_info.slot_count)
		goto unlock_kvm;

	// Clamp user provided sizes...
	slots = kvm_memslots(kvm);
	used_slots = 0;
	kvm_for_each_memslot2(slot, bkt, slots) {
		used_slots++;
	}
	if (kernel_info.slot_count > used_slots)
		kernel_info.slot_count = used_slots;

	// Supposedly exactly used_slots should have non-zero sized values, but what if not?
	memslot_map = vmalloc(sizeof(*memslot_map) * kernel_info.slot_count);

	if (!memslot_map)
		goto unlock_kvm;

	if ((slot_count = get_sorted_memslots(kvm_memslots(kvm), kernel_info.slot_count, memslot_map)) == -1)
		goto free_slots;

	kernel_info.userspace_pid = kvm->userspace_pid;
	kernel_info.slot_count = slot_count;

	if (copy_to_user(user_info, &kernel_info, sizeof(vm_info_t)))
		goto free_slots;
	if (slot_count && copy_to_user(user_slots, memslot_map, sizeof(*memslot_map) * slot_count))
		goto free_slots;

	ret = 0;

free_slots:
	vfree(memslot_map);
unlock_kvm:
	mutex_unlock(&kvm->slots_lock);
	mutex_unlock(&kvm->lock);
do_return:
	return ret;
}

struct vm_mem_data {
	// This field is only valid pre-mmap call.
	struct vm_area_struct *wrapped_vma;
	struct task_struct *wrapped_task;
	int nr_pages;
	struct page **pages;
};

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,7,0) && LINUX_VERSION_CODE < KERNEL_VERSION(5,10,0)
#define PAGE_GET_FLAG FOLL_LONGTERM
#else
#define PAGE_GET_FLAG 0
#endif

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,7,0)
#define RELEASE_PAGE put_page
#else
#define PAGE_GET_FLAG 0
#define RELEASE_PAGE put_user_page
#endif

static int memflow_vm_mem_release(struct inode *inode, struct file *file)
{
	struct vm_mem_data *data = file->private_data;
	int i;

	if (data) {
		if (data->pages) {
			for (i = 0; i < data->nr_pages; i++)
				RELEASE_PAGE(data->pages[i]);
			vfree(data->pages);
		}

		vfree(data);
	}

	return 0;
}

static int memflow_vm_mem_mmap(struct file *file, struct vm_area_struct *vma)
{
	struct vm_mem_data *data = file->private_data;
	unsigned long nr_pages = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
	int i, ret = -1;
	unsigned long foll_flags = PAGE_GET_FLAG|FOLL_GET;
	pgprot_t remap_flags = PAGE_SHARED;
#if LINUX_VERSION_CODE < KERNEL_VERSION(6,5,0)
	struct vm_area_struct **tmp_vmas;
#endif

	if (vma->vm_flags & VM_WRITE)
		foll_flags |= FOLL_WRITE;
	else
		remap_flags = PAGE_READONLY;

	if (data->wrapped_vma->vm_end - data->wrapped_vma->vm_start != nr_pages << PAGE_SHIFT)
		goto do_return;

	data->pages = vmalloc(sizeof(*data->pages) * nr_pages);

	if (!data->pages)
		goto do_return;

#if LINUX_VERSION_CODE < KERNEL_VERSION(6,5,0)
	tmp_vmas = vmalloc(sizeof(*tmp_vmas) * nr_pages);
	if (!tmp_vmas)
		goto free_pages;
#endif

	data->nr_pages = get_user_pages_remote(
#if LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0)
		data->wrapped_task,
#endif
		data->wrapped_task->mm,
		data->wrapped_vma->vm_start,
		nr_pages,
		foll_flags,
		data->pages,
#if LINUX_VERSION_CODE < KERNEL_VERSION(6,5,0)
		tmp_vmas,
#endif
		NULL
	);

#if LINUX_VERSION_CODE < KERNEL_VERSION(6,5,0)
	// We really don't need them, but we vmalloc it, because the kernel kcallocs it, and it fails?
	vfree(tmp_vmas);
#endif

	if (data->nr_pages != nr_pages)
		goto put_pages;

#if LINUX_VERSION_CODE < KERNEL_VERSION(6,3,0)
	vma->vm_flags |= VM_PFNMAP | VM_DONTDUMP;
#else
	vm_flags_set(vma, VM_PFNMAP | VM_DONTDUMP);
#endif

	ret = 0;

	// We would normally use vm_insert_pages, but the given pages may be compound
	for (i = 0; i < data->nr_pages; i++) {
		ret = remap_pfn_range(vma, vma->vm_start + i * (1ul << PAGE_SHIFT), page_to_pfn(data->pages[i]), 1ul << PAGE_SHIFT, remap_flags);
		if (ret) {
			//Unmap all mapped pages
			break;
		}
	}

	if (ret || data->nr_pages != nr_pages)
		goto put_pages;

	data->wrapped_vma = NULL;
	data->wrapped_task = NULL;

	return 0;

put_pages:
	for (i = 0; i < data->nr_pages; i++)
		RELEASE_PAGE(data->pages[i]);
#if LINUX_VERSION_CODE < KERNEL_VERSION(6,5,0)
free_pages:
#endif
	vfree(data->pages);
	data->nr_pages = 0;
	data->pages = NULL;
do_return:
	return ret;
}

static unsigned long memflow_vm_mem_get_unmapped_area(struct file *file, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags)
{
    struct vm_mem_data *data = file->private_data;
#if LINUX_VERSION_CODE < KERNEL_VERSION(6,10,0)
    return get_unmapped_area(data->wrapped_vma->vm_file, addr, len, pgoff + data->wrapped_vma->vm_pgoff, flags);
#else
    return mm_get_unmapped_area(data->wrapped_task->mm, data->wrapped_vma->vm_file, addr, len, pgoff + data->wrapped_vma->vm_pgoff, flags);
#endif
}

static const struct file_operations memflow_vm_mem_fops = {
	.release = memflow_vm_mem_release,
	.mmap = memflow_vm_mem_mmap,
	.get_unmapped_area = memflow_vm_mem_get_unmapped_area,
	.owner = THIS_MODULE
};

static unsigned long mmap_vma(struct vm_area_struct *vma, struct task_struct *task)
{
	struct file *wrap_file;
	unsigned long page_prot = PROT_READ;
	struct vm_mem_data *priv;
	unsigned long ret = -1;

	priv = vmalloc(sizeof(*priv));

	if (!priv)
		goto do_return;

	priv->pages = NULL;
	priv->wrapped_vma = vma;
	priv->wrapped_task = task;

	wrap_file = anon_inode_getfile("memflow-vm-mem", &memflow_vm_mem_fops, priv, O_RDWR);

	if (IS_ERR_OR_NULL(wrap_file))
		goto free_priv;

	if (vma->vm_flags & VM_WRITE)
		page_prot |= PROT_WRITE;

	ret = vm_mmap(wrap_file, 0, vma->vm_end - vma->vm_start, page_prot, MAP_SHARED, 0);

	fput(wrap_file);

	return ret;

free_priv:
	vfree(priv);
do_return:
	return ret;
}

// Called with otask->mm->mm_sem locked for writing. Does not release the lock
static void remap_vmas(struct vm_mapped_data *data, struct task_struct *otask)
{
	int i, o, u;
	vm_memslot_t *slot;
	struct vm_vma_map *mapped_vma;
	struct vm_area_struct *vma;
	unsigned long retaddr;
	unsigned long offset;

	for (i = 0; i < data->mapped_vma_count; i++) {
		mapped_vma = data->vma_maps + i;

		vma = find_vma(otask->mm, mapped_vma->start);

		if (!vma)
			goto remove_vma_map_entry;

		retaddr = mmap_vma(vma, otask);

		if (IS_ERR((void *)retaddr))
			goto remove_unmapped_slots;

		// Update the internal structure to point to the current userspace
		offset = retaddr - mapped_vma->start;

		for (o = 0; o < data->vm_map_info.slot_count; o++) {
			slot = data->vm_map_info.slots + o;
			if (slot->host_base >= mapped_vma->start && slot->host_base < mapped_vma->end) {
				slot->host_base += offset;
			}
		}

		mapped_vma->start += retaddr;
		mapped_vma->end += offset;

		continue;

remove_unmapped_slots:
		// Remove all memslots that correspond to this vma
		for (o = data->vm_map_info.slot_count - 1; o >= 0; o--) {
			slot = data->vm_map_info.slots + o;
			if (slot->host_base >= vma->vm_start && slot->host_base < vma->vm_end) {
				data->vm_map_info.slot_count--;
				for (u = o; u < data->vm_map_info.slot_count; u++) {
					data->vm_map_info.slots[u] = data->vm_map_info.slots[u + 1];
				}
			}
		}

remove_vma_map_entry:
		// Do swap remove
		data->vma_maps[i--] = data->vma_maps[--data->mapped_vma_count];
	}
}

static void find_unique_vmas(struct vm_mapped_data *data, struct mm_struct *other_mm)
{
	int i, o;
	struct vm_area_struct *vma;
	vm_memslot_t *slot;

	for (i = 0; i < data->vm_map_info.slot_count; i++) {
		slot = data->vm_map_info.slots + i;
		vma = find_vma(other_mm, slot->host_base);

		for (o = 0; o < data->mapped_vma_count; o++) {
			if (vma->vm_start == data->vma_maps[o].start)
				goto skip_slot;
		}

		data->vma_maps[data->mapped_vma_count++] = (struct vm_vma_map) {
			.start = vma->vm_start,
			.end = vma->vm_end
		};

skip_slot:
		continue;
	}
}

static int do_map_vm(struct kvm *kvm, vm_map_info_t __user *user_info)
{
	struct vm_mapped_data *priv;
	int fd = -1, memslot_count;
	struct file *file;
	struct task_struct *other_task;
	struct mm_struct *other_mm;
	vm_map_info_t user_info_copied;

	other_task = pid_task(find_vpid(kvm->userspace_pid), PIDTYPE_PID);

	// We could support doing the remapping in current process, but it's pointless and adds extra lock complexity
	if (!other_task || other_task == current)
		goto do_return;

	other_mm = other_task->mm;

	if (!other_mm || other_mm == current->mm)
		goto do_return;

	priv = vmalloc(sizeof(*priv));

	if (!priv)
		goto do_return;

	priv->mapped_vma_count = 0;
	priv->vm_map_info.slot_count = 0;

	if (copy_from_user(&user_info_copied, user_info, sizeof(vm_map_info_t)))
		goto free_alloc;
	
	priv->vm_map_info = user_info_copied;
	priv->vm_map_info.slots = priv->map_slots;

	if (!priv->vm_map_info.slot_count)
		goto free_alloc;

	if (priv->vm_map_info.slot_count > KVM_MEM_SLOTS_NUM)
		priv->vm_map_info.slot_count = KVM_MEM_SLOTS_NUM;

	fd = get_unused_fd_flags(O_CLOEXEC);

	if (fd < 0)
		goto free_alloc;

	mutex_lock(&kvm->lock);
	mutex_lock(&kvm->slots_lock);

	if ((memslot_count = get_sorted_memslots(kvm_memslots(kvm), priv->vm_map_info.slot_count, priv->vm_map_info.slots)) == -1) {
        mutex_unlock(&kvm->lock);
        mutex_unlock(&kvm->slots_lock);
		goto put_fd;
    }

	priv->vm_map_info.slot_count = memslot_count;

	mmap_write_lock(other_mm);
	
    // Once we hold mmap_sem, the slots won't be freed so there is no purpose to hold the locks
    mutex_unlock(&kvm->lock);
	mutex_unlock(&kvm->slots_lock);

	// First order of business is to grab all unique mappings to memslots (that are backed by some kind of file)
	find_unique_vmas(priv, other_mm);

	file = anon_inode_getfile("memflow-vm-map", &memflow_vm_mapped_fops, priv, O_RDWR);

	if (IS_ERR_OR_NULL(file))
		goto unlock_mem;

	// Now remap all unique mappings
	remap_vmas(priv, other_task);

	if (!priv->mapped_vma_count)
		goto release_file;

	user_info_copied.slot_count = priv->vm_map_info.slot_count;

	if (copy_to_user(user_info, &user_info_copied, sizeof(vm_map_info_t)))
		goto release_file;
	if (priv->vm_map_info.slot_count && copy_to_user(user_info_copied.slots, priv->vm_map_info.slots, sizeof(vm_memslot_t) * priv->vm_map_info.slot_count))
		goto release_file;

	fd_install(fd, file);

	mmap_write_unlock(other_mm);

	return fd;

release_file:
	// The data will be freed later on, so we do not have to do that ourselves
	priv = NULL;
	fput(file);
unlock_mem:
	mmap_write_unlock(other_mm);
put_fd:
	put_unused_fd(fd);
free_alloc:
	if (priv)
		vfree(priv);
do_return:
	return -1;
}

static long memflow_vm_ioctl(struct file *filp, unsigned int cmd, unsigned long argp)
{
	switch (cmd) {
		case MEMFLOW_VM_INFO:
			return get_vm_info(filp->private_data, (vm_info_t __user *)argp);
		case MEMFLOW_MAP_VM:
			return do_map_vm(filp->private_data, (vm_map_info_t __user *)argp);
	}

	return -1;
}

static int memflow_vm_mapped_release(struct inode *inode, struct file *filp)
{
	vfree(filp->private_data);
	return 0;
}


```

`memflow-kmod/vmtools.h`:

```h
/* SPDX-License-Identifier: GPL-2.0 */

#ifndef VMTOOLS_H
#define VMTOOLS_H

#include <linux/types.h>

extern int open_vm(pid_t target_pid);

#endif

```

`memflow-kvm-ioctl/Cargo.toml`:

```toml
[package]
name = "memflow-kvm-ioctl"
version = "0.1.2"
authors = ["Aurimas Blažulionis <0x60@pm.me>"]
edition = "2021"
build = "build.rs"
description = "interface to memflow's KVM kernel module"
homepage = "https://memflow.github.io/"
repository = "https://github.com/memflow/memflow-kvm.git"
documentation = "https://docs.rs/memflow-kvm-ioctl"
keywords = [ "memflow", "introspection", "memory" ]
categories = [ "api-bindings", "memory-management", "os" ]
readme = "../README.md"
license = "MIT"

[build-dependencies]
bindgen = "^0.69.1"

```

`memflow-kvm-ioctl/build.rs`:

```rs
extern crate bindgen;

use std::env;
use std::path::PathBuf;

fn main() {
    println!("cargo:rerun-if-changed=../mabi.h");
    println!("cargo:rerun-if-changed=wrapper.h");

    let bindings = bindgen::Builder::default()
        .header("wrapper.h")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
        .derive_default(true)
        .use_core()
        .size_t_is_usize(true)
        .allowlist_type("vm_memslot")
        .allowlist_type("vm_map_info")
        .allowlist_type("vm_info")
        .allowlist_var("IO_MEMFLOW_OPEN_VM")
        .allowlist_var("IO_MEMFLOW_VM_INFO")
        .allowlist_var("IO_MEMFLOW_MAP_VM")
        .generate()
        .expect("Unable to generate bindings");

    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());

    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Couldn't write bindings!");
}

```

`memflow-kvm-ioctl/mabi.h`:

```h
/* SPDX-L
```

`memflow-kvm-ioctl/src/lib.rs`:

```rs
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

use std::fs::File;
use std::os::unix::io::{AsRawFd, FromRawFd, RawFd};

// Do not depend on entire libc just for this function
extern "C" {
    fn ioctl(fd: i32, request: __u64, ...) -> i32;
    fn munmap(addr: *mut std::os::raw::c_void, len: usize) -> i32;
}

use std::io::Result;

/// Structure assisting automatic memory map unmapping
///
/// It does not reference count on its own. Wrap it in Arc,
/// or Rc for it to take place
pub struct AutoMunmap {
    memslots: Vec<vm_memslot>,
}

impl AutoMunmap {
    /// Create automatic unmapping
    ///
    /// # Safety
    ///
    /// Drop implementation of this structure calls munmap on all mapped memory regions.
    /// vm_memslots have to be correct for the runnings process, or causes undefined bahaviour.
    pub unsafe fn new(memslots: Vec<vm_memslot>) -> Self {
        Self { memslots }
    }
}

impl Drop for AutoMunmap {
    fn drop(&mut self) {
        for slot in &self.memslots {
            unsafe {
                munmap(slot.host_base as _, slot.map_size as _);
            }
        }
    }
}

/// Handle to memflow's kernel module
///
/// This is a handle to `/dev/memflow`. It functions as a file, closes automatically when dropped
pub struct ModuleHandle {
    memflow: File,
}

impl ModuleHandle {
    pub fn try_open() -> Result<Self> {
        Ok(Self {
            memflow: File::open("/dev/memflow")?,
        })
    }
}

impl AsRawFd for ModuleHandle {
    fn as_raw_fd(&self) -> RawFd {
        self.memflow.as_raw_fd()
    }
}

/// Handle to a KVM VM
///
/// This is a handle to a single KVM instance. Allows access to basic memory layout information of the VM.
pub struct VMHandle {
    vm: File,
}

impl VMHandle {
    /// Open a KVM instance with a memflow handle
    ///
    /// This may be useful when multiple VMs are accessed to save syscalls, but in regular scenarios,
    /// use `try_open`.
    ///
    /// # Arguments
    ///
    /// * `memflow` - handle to the memflow driver
    /// * `pid` - optional process identifier. If it is `None`, or `Some(0)`, handle to any of the KVM
    /// VMs gets retrieved.
    pub fn try_open_handle(memflow: &ModuleHandle, pid: Option<i32>) -> Result<Self> {
        let vm_fd: RawFd = unsafe {
            ioctl(
                memflow.as_raw_fd(),
                IO_MEMFLOW_OPEN_VM as u64,
                pid.unwrap_or_default(),
            )
        };

        if vm_fd < 0 {
            Err(std::io::Error::last_os_error())
        } else {
            Ok(Self {
                vm: unsafe { File::from_raw_fd(vm_fd) },
            })
        }
    }

    /// Open a KVM instance
    ///
    /// # Arguments
    ///
    /// * `pid` - optional process identifier. If it is `None`, or `Some(0)`, handle to any of the KVM
    /// VMs gets retrieved. Otherwise, the specific PID gets targeted. And if the process does not exist,
    /// this function will fail.
    pub fn try_open(pid: Option<i32>) -> Result<Self> {
        Self::try_open_handle(&ModuleHandle::try_open()?, pid)
    }

    /// Retrieve info about the KVM instance
    ///
    /// Pulls info about the current VM handle. That means its PID, and the memory layout (in KVMs userspace).
    pub fn info(&self, slot_count: usize) -> Result<(i32, Vec<vm_memslot>)> {
        let mut vm_info = vm_info::default();
        let mut memslots = vec![Default::default(); slot_count];

        vm_info.slot_count = slot_count as u32;
        vm_info.slots = memslots.as_mut_ptr();

        let ret = unsafe { ioctl(self.vm.as_raw_fd(), IO_MEMFLOW_VM_INFO as u64, &mut vm_info) };

        if ret < 0 {
            Err(std::io::Error::last_os_error())
        } else {
            memslots.truncate(vm_info.slot_count as usize);
            #[allow(clippy::unnecessary_cast)]
            Ok((vm_info.userspace_pid as i32, memslots))
        }
    }

    /// Memory map the KVM instance
    ///
    /// Maps the memory of the KVM instance into local address space, and returns the mapped memory layout.
    ///
    /// The memory map is permanent (unless manually unmapped using libc). KVM has the possibility of changing
    /// the memory layout (in its process only), but this function can not account for it.
    pub fn map_vm(&self, slot_count: usize) -> Result<Vec<vm_memslot>> {
        let mut vm_info = vm_map_info::default();
        let mut memslots = vec![Default::default(); slot_count];

        vm_info.slot_count = slot_count as u32;
        vm_info.slots = memslots.as_mut_ptr();

        let ret = unsafe { ioctl(self.vm.as_raw_fd(), IO_MEMFLOW_MAP_VM as u64, &mut vm_info) };

        if ret < 0 {
            Err(std::io::Error::last_os_error())
        } else {
            memslots.truncate(vm_info.slot_count as usize);
            Ok(memslots)
        }
    }
}

```

`memflow-kvm-ioctl/wrapper.h`:

```h
#include "mabi.h"
#include <stddef.h>

const size_t IO_MEMFLOW_OPEN_VM = MEMFLOW_OPEN_VM;
const size_t IO_MEMFLOW_VM_INFO = MEMFLOW_VM_INFO;
const size_t IO_MEMFLOW_MAP_VM = MEMFLOW_MAP_VM;


```

`memflow-kvm/Cargo.toml`:

```toml
[package]
name = "memflow-kvm"
version = "0.2.1"
authors = ["Aurimas Blažulionis <0x60@pm.me>"]
edition = "2021"
rust-version = "1.65.0"
description = "kvm connector for the memflow physical memory introspection framework"
homepage = "https://memflow.github.io/"
repository = "https://github.com/memflow/memflow-kvm.git"
documentation = "https://docs.rs/memflow-kvm"
keywords = [ "memflow", "introspection", "memory" ]
categories = [ "api-bindings", "memory-management", "os" ]
readme = "README.md"
license = "MIT"

[lib]
crate-type = ["lib", "cdylib"]

[dependencies]
memflow-kvm-ioctl = { version = "0.1.1", path = "../memflow-kvm-ioctl" }
memflow = { version = "0.2", features = ["plugins"] }
log = { version = "0.4", default-features = false }

[features]
default = []
inventory = []

```

`memflow-kvm/README.md`:

```md
# memflow's KVM connector

This is a connector for Linux kernel based virtual machines (KVMs), which by utilizing a kernel module directly maps all VM memory. This provides an effortless way to run memflow on all KVM based VMs (not just QEMU), and with highest performance.

## Setting up

This connector requires the [memflow module](https://github.com/memflow/memflow-kvm) to be present (to access `/dev/memflow` interface), and have appropriate permissions to access the interface.

For development purposes, it is possible to `chmod o+rw /dev/memflow` to gain access, but it is a security risk.

`create_connector` accepts a single, optional, argument - PID. This PID will be passed to the `memflow` module to select which VM monitor to target, or can be omitted to pick the first found one.

```

`memflow-kvm/src/lib.rs`:

```rs
use log::{debug, info};

use memflow::connector::MappedPhysicalMemory;
use memflow::derive::connector;
use memflow::error::*;
use memflow::mem::MemoryMap;
use memflow::plugins::ConnectorArgs;
use memflow::types::{umem, Address};
use memflow_kvm_ioctl::{AutoMunmap, VMHandle};
use std::sync::Arc;

pub type KVMConnector<'a> = MappedPhysicalMemory<&'a mut [u8], KVMMapData<&'a mut [u8]>>;

pub struct KVMMapData<T> {
    handle: Arc<AutoMunmap>,
    mappings: MemoryMap<T>,
    addr_mappings: MemoryMap<(Address, umem)>,
}

impl<'a> Clone for KVMMapData<&'a mut [u8]> {
    fn clone(&self) -> Self {
        unsafe { Self::from_addrmap_mut(self.handle.clone(), self.addr_mappings.clone()) }
    }
}

impl<T> AsRef<MemoryMap<T>> for KVMMapData<T> {
    fn as_ref(&self) -> &MemoryMap<T> {
        &self.mappings
    }
}

impl<'a> KVMMapData<&'a mut [u8]> {
    unsafe fn from_addrmap_mut(handle: Arc<AutoMunmap>, map: MemoryMap<(Address, umem)>) -> Self {
        Self {
            handle,
            mappings: map.clone().into_bufmap_mut(),
            addr_mappings: map,
        }
    }
}

/// Creates a new KVM Connector instance.
#[connector(name = "kvm")]
pub fn create_connector<'a>(
    args: &ConnectorArgs,
) -> Result<MappedPhysicalMemory<&'a mut [u8], KVMMapData<&'a mut [u8]>>> {
    const ERROR_UNABLE_TO_READ_MEMORY: &str = "Could not access the memflow device at /dev/memflow. Please make sure that you installed the dkms module properly and that it is loaded via `modprobe memflow`. Also ensure that you have read and write access to /dev/memflow. For further information check the readme at https://github.com/memflow/memflow-kvm";

    let pid = match &args.target {
        Some(pidstr) => Some(
            pidstr
                .parse::<i32>()
                .map_err(|_| Error(ErrorOrigin::Connector, ErrorKind::ArgValidation))?,
        ),
        None => None,
    };

    let vm = VMHandle::try_open(pid).map_err(|_| {
        Error(ErrorOrigin::Connector, ErrorKind::UnableToReadMemory)
            .log_error(ERROR_UNABLE_TO_READ_MEMORY)
    })?;
    let (pid, memslots) = vm.info(64).map_err(|_| {
        Error(ErrorOrigin::Connector, ErrorKind::UnableToReadMemory)
            .log_error(ERROR_UNABLE_TO_READ_MEMORY)
    })?;
    debug!("pid={} memslots.len()={}", pid, memslots.len());
    for slot in memslots.iter() {
        debug!(
            "{:x}-{:x} -> {:x}-{:x}",
            slot.base,
            slot.base + slot.map_size,
            slot.host_base,
            slot.host_base + slot.map_size
        );
    }
    let mapped_memslots = vm.map_vm(64).map_err(|e| {
        Error(ErrorOrigin::Connector, ErrorKind::UnableToMapFile).log_error(format!(
            "The mapped memory slots for the vm could not be read: {}",
            e
        ))
    })?;

    let mut mem_map = MemoryMap::new();

    info!("mmapped {} slots", mapped_memslots.len());
    for slot in mapped_memslots.iter() {
        debug!(
            "{:x}-{:x} -> {:x}-{:x}",
            slot.base,
            slot.base + slot.map_size,
            slot.host_base,
            slot.host_base + slot.map_size
        );
        mem_map.push_remap(
            slot.base.into(),
            slot.map_size as umem,
            slot.host_base.into(),
        );
    }

    let munmap = Arc::new(unsafe { AutoMunmap::new(mapped_memslots) });

    let map_data = unsafe { KVMMapData::from_addrmap_mut(munmap, mem_map) };

    let mem = MappedPhysicalMemory::with_info(map_data);

    Ok(mem)
}

```

`umode_test.c`:

```c
#include "mabi.h"
#include <stdio.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <alloca.h>
#include <errno.h>
#include <sys/mman.h>
#include <string.h>

#define MAX_MEMSLOTS 64

int main()
{
	int memflow_fd = open("/dev/memflow", O_RDONLY);

	if (memflow_fd == -1) {
		printf("/dev/memflow open failed\n");
		return -1;
	}

	printf("memflow_fd %x\n", memflow_fd);

	int vm_fd = ioctl(memflow_fd, MEMFLOW_OPEN_VM, 0);

	if (vm_fd == -1) {
		printf("MEMFLOW_OPEN_VM failed\n");
		return -1;
	}

	printf("vm_fd %d\n", vm_fd);

	{
		vm_info_t *vm_info = alloca(sizeof(vm_info_t) + sizeof(vm_memslot_t) * MAX_MEMSLOTS);
		vm_info->slots = vm_info + 1;
		vm_info->slot_count = MAX_MEMSLOTS;

		if (ioctl(vm_fd, MEMFLOW_VM_INFO, vm_info)) {
			printf("MEMFLOW_VM_INFO failed %d\n", errno);
			return -1;
		}

		printf("kvm pid: %d\n", (int)vm_info->userspace_pid);
		printf("Memory maps (count=%u):\n", vm_info->slot_count);

		for (int i = 0; i < vm_info->slot_count; i++) {
			vm_memslot_t *slot = vm_info->slots + i;
			printf("%d %llx->%llx (%llx)\n", i, slot->base, slot->host_base, slot->map_size);
		}
	}

	{
		vm_map_info_t *vm_info = alloca(sizeof(vm_map_info_t) + sizeof(vm_memslot_t) * MAX_MEMSLOTS);
		vm_info->slots = vm_info + 1;
		vm_info->slot_count = MAX_MEMSLOTS;

		int vm_map_fd = ioctl(vm_fd, MEMFLOW_MAP_VM, vm_info);

		if (vm_map_fd < 0) {
			printf("MEMFLOW_MAP_VM failed %d\n", errno);
			return -1;
		}

		printf("MEMFLOW_MAP_VM fd %d\n", vm_map_fd);

		getchar();

		printf("Memory maps (count=%u):\n", vm_info->slot_count);

		for (int i = 0; i < vm_info->slot_count; i++) {
			vm_memslot_t *slot = vm_info->slots + i;
			printf("%d %llx->%llx (%llx)\n", i, slot->base, slot->host_base, slot->map_size);
			memset((void *)slot->host_base, 0, slot->map_size);
		}

		close(vm_map_fd);

		printf("Closed vm_map_fd");

		getchar();
	}

	return 0;
}

```