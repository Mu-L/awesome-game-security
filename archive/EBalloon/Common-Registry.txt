Project Path: arc_EBalloon_Common-Registry_hdfdiqpb

Source Tree:

```txt
arc_EBalloon_Common-Registry_hdfdiqpb
├── Common-Registry.sln
├── KernelMode
│   ├── KernelMode.vcxproj
│   ├── KernelMode.vcxproj.filters
│   ├── KernelMode.vcxproj.user
│   ├── Source.cpp
│   └── utils.h
├── README.md
└── UserMode
    ├── UserMode.cpp
    ├── UserMode.vcxproj
    ├── UserMode.vcxproj.filters
    └── UserMode.vcxproj.user

```

`Common-Registry.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31605.320
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UserMode", "UserMode\UserMode.vcxproj", "{DB51166A-0CBA-46EC-BE23-0B1E4833A426}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "KernelMode", "KernelMode\KernelMode.vcxproj", "{280B4436-1B02-4328-A4FE-4438A668B84C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DB51166A-0CBA-46EC-BE23-0B1E4833A426}.Debug|ARM.ActiveCfg = Debug|Win32
		{DB51166A-0CBA-46EC-BE23-0B1E4833A426}.Debug|ARM64.ActiveCfg = Debug|Win32
		{DB51166A-0CBA-46EC-BE23-0B1E4833A426}.Debug|x64.ActiveCfg = Debug|x64
		{DB51166A-0CBA-46EC-BE23-0B1E4833A426}.Debug|x64.Build.0 = Debug|x64
		{DB51166A-0CBA-46EC-BE23-0B1E4833A426}.Debug|x86.ActiveCfg = Debug|Win32
		{DB51166A-0CBA-46EC-BE23-0B1E4833A426}.Debug|x86.Build.0 = Debug|Win32
		{DB51166A-0CBA-46EC-BE23-0B1E4833A426}.Release|ARM.ActiveCfg = Release|Win32
		{DB51166A-0CBA-46EC-BE23-0B1E4833A426}.Release|ARM64.ActiveCfg = Release|Win32
		{DB51166A-0CBA-46EC-BE23-0B1E4833A426}.Release|x64.ActiveCfg = Release|x64
		{DB51166A-0CBA-46EC-BE23-0B1E4833A426}.Release|x64.Build.0 = Release|x64
		{DB51166A-0CBA-46EC-BE23-0B1E4833A426}.Release|x86.ActiveCfg = Release|Win32
		{DB51166A-0CBA-46EC-BE23-0B1E4833A426}.Release|x86.Build.0 = Release|Win32
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Debug|ARM.ActiveCfg = Debug|ARM
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Debug|ARM.Build.0 = Debug|ARM
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Debug|ARM.Deploy.0 = Debug|ARM
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Debug|ARM64.Build.0 = Debug|ARM64
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Debug|x64.ActiveCfg = Debug|x64
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Debug|x64.Build.0 = Debug|x64
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Debug|x64.Deploy.0 = Debug|x64
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Debug|x86.ActiveCfg = Debug|Win32
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Debug|x86.Build.0 = Debug|Win32
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Debug|x86.Deploy.0 = Debug|Win32
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Release|ARM.ActiveCfg = Release|ARM
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Release|ARM.Build.0 = Release|ARM
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Release|ARM.Deploy.0 = Release|ARM
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Release|ARM64.ActiveCfg = Release|ARM64
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Release|ARM64.Build.0 = Release|ARM64
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Release|ARM64.Deploy.0 = Release|ARM64
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Release|x64.ActiveCfg = Release|x64
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Release|x64.Build.0 = Release|x64
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Release|x64.Deploy.0 = Release|x64
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Release|x86.ActiveCfg = Release|Win32
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Release|x86.Build.0 = Release|Win32
		{280B4436-1B02-4328-A4FE-4438A668B84C}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {2CE11893-8C06-4C39-B7D4-8D2D2B8A6782}
	EndGlobalSection
EndGlobal

```

`KernelMode/KernelMode.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{280B4436-1B02-4328-A4FE-4438A668B84C}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>ThreadNotify</RootNamespace>
    <ProjectName>KernelMode</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`KernelMode/KernelMode.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`KernelMode/KernelMode.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`KernelMode/Source.cpp`:

```cpp
#include "utils.h"


NTSTATUS RegistryCallback(PVOID callbackContext, PVOID arg1, PVOID arg2) {

	UNREFERENCED_PARAMETER(callbackContext);

	if (INT(arg1) != 16) // RegNtPostSetValueKey
		return STATUS_SUCCESS;

	PREG_POST_OPERATION_INFORMATION postInfo = (PREG_POST_OPERATION_INFORMATION)arg2;
	PREG_SET_VALUE_KEY_INFORMATION preInfo = (PREG_SET_VALUE_KEY_INFORMATION)postInfo->PreInformation;

	if (RtlEqualUnicodeString(preInfo->ValueName, &MyKey, TRUE) == 0)
		return STATUS_SUCCESS;

	if (!preInfo->Data)
		return STATUS_SUCCESS;

	PREQUEST Data = *reinterpret_cast<PREQUEST*>(preInfo->Data);

	if (!Data)
		return STATUS_SUCCESS;;

	switch (Data->Type)
	{

	// Read Memory
	case 1:
	{
		auto MemoryInfo = PCOPY_MEMORY(Data->Instruction);
		if (MemoryInfo->ProcessId && MemoryInfo->Source && MemoryInfo->Size)
		{
			auto Status = ReadProcessMemory(HANDLE(MemoryInfo->ProcessId), MemoryInfo->Source, &MemoryInfo->Destination, MemoryInfo->Size);
			if (NT_SUCCESS(Status))
				DbgPrintEx(0, 0, "Type: %d - Read Memory: %llu - Status: 0x%08X\n", Data->Type, uint64_t(MemoryInfo->Destination), Status);
		}
		break;
	}

	// Write Memory
	case 2:
	{		
		auto MemoryInfo = PCOPY_MEMORY(Data->Instruction);
		if (MemoryInfo->ProcessId && MemoryInfo->Source && MemoryInfo->Size)
		{
			auto Status = WriteProcessMemory(HANDLE(MemoryInfo->ProcessId), MemoryInfo->Source, &MemoryInfo->Destination, MemoryInfo->Size);
			if (NT_SUCCESS(Status))
				DbgPrintEx(0, 0, "Type: %d - Write Memory: %llu - Status: 0x%08X\n", Data->Type, uint64_t(MemoryInfo->Destination), Status);
		}
		break;
	}

	// Module Base
	case 3:
	{
		auto ModuleInfo = PMODULE_BASE(Data->Instruction);
		ModuleInfo->Base = GetModuleBaseProcess(HANDLE(ModuleInfo->ProcessId), ModuleInfo->ModuleName);
		if (ModuleInfo->Base)
			DbgPrintEx(0, 0, "Type: %d - Base: %p\n", Data->Type, ModuleInfo->Base);
		break;
	}
	
	}
	// ...

	return STATUS_SUCCESS;
}

NTSTATUS
DriverEntry(
	_In_ PDRIVER_OBJECT DriverObject,
	_In_ PUNICODE_STRING RegistryPath
)
{
	UNREFERENCED_PARAMETER(DriverObject);
	UNREFERENCED_PARAMETER(RegistryPath);

	DbgPrintEx(0, 0, "EntryPoint: %s\n", __FUNCTION__);

	// RegisterCallback
	RtlInitUnicodeString(&MyKey, L"MyRegID");
	auto Status = RegisterCallback(PEX_CALLBACK_FUNCTION(RegistryCallback), nullptr, &CmCookie);
	if (!NT_SUCCESS(Status))
		return Status;

	DbgPrintEx(0, 0, "Success!\n");

	return Status;
}
```

`KernelMode/utils.h`:

```h
#include <ntdef.h>
#include <intrin.h>
#include <ntifs.h>
#include <ntimage.h>

typedef unsigned long       DWORD;
typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef float               FLOAT;
typedef int                 PINT;
typedef unsigned long long uint64_t;

extern "C" PLIST_ENTRY NTKERNELAPI PsLoadedModuleList;
extern "C" PPEB NTKERNELAPI PsGetProcessPeb(PEPROCESS Process);
extern "C" NTSTATUS NTKERNELAPI ZwQuerySystemInformation( DWORD32 systemInformationClass, PVOID systemInformation,
	ULONG systemInformationLength, PULONG returnLength);

UCHAR ShellCode[] = {
	0x50,
	0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x48, 0x87, 0x04, 0x24,
	0xC3
};

typedef struct _REQUEST {
	UINT32 Type;
	PVOID Instruction;
} REQUEST, * PREQUEST;

typedef struct _COPY_MEMORY {
	ULONG ProcessId;
	PVOID Destination;
	PVOID Source;
	SIZE_T Size;
} COPY_MEMORY, * PCOPY_MEMORY;

typedef struct _MODULE_BASE {
	ULONG ProcessId;
	LPCWSTR ModuleName;
	PVOID Base;
} MODULE_BASE, * PMODULE_BASE;

UNICODE_STRING MyKey;
LARGE_INTEGER CmCookie = { 0x3090 };

typedef struct _RegisterCallbackEntry
{
	LIST_ENTRY ListEntryHead;
	BOOLEAN PendingDelete;
	LARGE_INTEGER Cookie;
	void* Context;
	void* Routine;
} RegisterCallbackEntry, * PRegisterCallbackEntry;

typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	BOOLEAN Initialized;
	HANDLE SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
	BOOLEAN ShutdownInProgress;
	HANDLE ShutdownThreadId;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _LDR_SERVICE_TAG_RECORD
{
	struct _LDR_SERVICE_TAG_RECORD* Next;
	ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD, * PLDR_SERVICE_TAG_RECORD;

typedef struct _LDRP_CSLIST
{
	PSINGLE_LIST_ENTRY Tail;
} LDRP_CSLIST, * PLDRP_CSLIST;

typedef enum _LDR_DDAG_STATE {
	LdrModulesMerged = -5,
	LdrModulesInitError = -4,
	LdrModulesSnapError = -3,
	LdrModulesUnloaded = -2,
	LdrModulesUnloading = -1,
	LdrModulesPlaceHolder = 0,
	LdrModulesMapping = 1,
	LdrModulesMapped = 2,
	LdrModulesWaitingForDependencies = 3,
	LdrModulesSnapping = 4,
	LdrModulesSnapped = 5,
	LdrModulesCondensed = 6,
	LdrModulesReadyToInit = 7,
	LdrModulesInitializing = 8,
	LdrModulesReadyToRun = 9
} LDR_DDAG_STATE;

typedef struct _LDR_DDAG_NODE
{
	LIST_ENTRY Modules;
	PLDR_SERVICE_TAG_RECORD ServiceTagList;
	ULONG LoadCount;
	ULONG LoadWhileUnloadingCount;
	ULONG LowestLink;
	union {
		LDRP_CSLIST Dependencies;
		SINGLE_LIST_ENTRY RemovalLink;
	};
	LDRP_CSLIST IncomingDependencies;
	LDR_DDAG_STATE State;
	SINGLE_LIST_ENTRY CondenseLink;
	ULONG PreorderNumber;
} LDR_DDAG_NODE, * PLDR_DDAG_NODE;

typedef struct _LDR_DEPENDENCY_RECORD
{
	SINGLE_LIST_ENTRY DependencyLink;
	PLDR_DDAG_NODE DependencyNode;
	SINGLE_LIST_ENTRY IncomingDependencyLink;
	PLDR_DDAG_NODE IncomingDependencyNode;
} LDR_DEPENDENCY_RECORD, * PLDR_DEPENDENCY_RECORD;

typedef enum _LDR_DLL_LOAD_REASON {
	LoadReasonStaticDependency,
	LoadReasonStaticForwarderDependency,
	LoadReasonDynamicForwarderDependency,
	LoadReasonDelayloadDependency,
	LoadReasonDynamicLoad,
	LoadReasonAsImageLoad,
	LoadReasonAsDataLoad,
	LoadReasonUnknown = -1
} LDR_DLL_LOAD_REASON,
* PLDR_DLL_LOAD_REASON;

typedef struct _SYSTEM_MODULE
{
	ULONG_PTR Reserved[2];
	PVOID Base;
	ULONG Size;
	ULONG Flags;
	USHORT Index;
	USHORT Unknown;
	USHORT LoadCount;
	USHORT ModuleNameOffset;
	CHAR ImageName[256];
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG_PTR ulModuleCount;
	SYSTEM_MODULE Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	union {
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	union {
		UCHAR FlagGroup[4];
		ULONG Flags;
		struct
		{
			ULONG PackagedBinary : 1;
			ULONG MarkedForRemoval : 1;
			ULONG ImageDll : 1;
			ULONG LoadNotificationsSent : 1;
			ULONG TelemetryEntryProcessed : 1;
			ULONG ProcessStaticImport : 1;
			ULONG InLegacyLists : 1;
			ULONG InIndexes : 1;
			ULONG ShimDll : 1;
			ULONG InExceptionTable : 1;
			ULONG ReservedFlags1 : 2;
			ULONG LoadInProgress : 1;
			ULONG LoadConfigProcessed : 1;
			ULONG EntryProcessed : 1;
			ULONG ProtectDelayLoad : 1;
			ULONG ReservedFlags3 : 2;
			ULONG DontCallForThreads : 1;
			ULONG ProcessAttachCalled : 1;
			ULONG ProcessAttachFailed : 1;
			ULONG CorDeferredValidate : 1;
			ULONG CorImage : 1;
			ULONG DontRelocate : 1;
			ULONG CorILOnly : 1;
			ULONG ReservedFlags5 : 3;
			ULONG Redirected : 1;
			ULONG ReservedFlags6 : 2;
			ULONG CompatDatabaseProcessed : 1;
		};
	};
	USHORT ObsoleteLoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
	struct _ACTIVATION_CONTEXT* EntryPointActivationContext;
	PVOID Lock;
	PLDR_DDAG_NODE DdagNode;
	LIST_ENTRY NodeModuleLink;
	struct _LDRP_LOAD_CONTEXT* LoadContext;
	PVOID ParentDllBase;
	PVOID SwitchBackContext;
	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;
	ULONG_PTR OriginalBase;
	LARGE_INTEGER LoadTime;
	ULONG BaseNameHashValue;
	LDR_DLL_LOAD_REASON LoadReason;
	ULONG ImplicitPathOptions;
	ULONG ReferenceCount;
	ULONG DependentLoadFlags;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	PVOID Mutant;
	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PVOID FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	PVOID CrossProcessFlags;
	PVOID UserSharedInfoPtr;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
} PEB, * PPEB;

BOOL CheckMask(PCHAR base, PCHAR pattern, PCHAR mask)
{
	for (; *mask; ++base, ++pattern, ++mask)
	{
		if ('x' == *mask && *base != *pattern)
		{
			return FALSE;
		}
	}

	return TRUE;
}

UINT_PTR FindPattern(PCHAR base, DWORD length, PCHAR pattern, PCHAR mask)
{
	length -= (DWORD)strlen(mask);
	for (DWORD i = 0; i <= length; ++i)
	{
		UINT_PTR addr = UINT_PTR( &base[i] );

		if (CheckMask((PCHAR)addr, pattern, mask))
		{
			return addr;
		}
	}

	return 0;
}

UINT_PTR FindPatternImage(PCHAR base, PCHAR pattern, PCHAR mask)
{
	UINT_PTR match = 0;

	PIMAGE_NT_HEADERS headers = (PIMAGE_NT_HEADERS)(base + ((PIMAGE_DOS_HEADER)base)->e_lfanew);
	PIMAGE_SECTION_HEADER sections = IMAGE_FIRST_SECTION(headers);
	for (DWORD i = 0; i < headers->FileHeader.NumberOfSections; ++i)
	{
		PIMAGE_SECTION_HEADER section = &sections[i];
		if ('EGAP' == *(int*)section->Name || memcmp(section->Name, ".text", 5) == 0)
		{
			match = FindPattern(base + section->VirtualAddress, section->Misc.VirtualSize, pattern, mask);
			if (match)
			{
				break;
			}
		}
	}

	return match;
}

uint64_t GetModuleNtoskrnlBase()
{
	uint64_t Base;
	ULONG Size = 0;
	ZwQuerySystemInformation(11, &Size, 0, &Size);
	if (Size == 0)
		return false;

	const unsigned long tag = 'VMON';
	PSYSTEM_MODULE_INFORMATION sys_mods = (PSYSTEM_MODULE_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, Size, tag);
	if (sys_mods == 0) 
		return false;

	NTSTATUS status = ZwQuerySystemInformation(11, sys_mods, Size, 0);
	if (!NT_SUCCESS(status))
	{
		ExFreePoolWithTag(sys_mods, tag);
		return false;
	}

	for (unsigned long long i = 0; i < sys_mods->ulModuleCount; i++)
	{
		PSYSTEM_MODULE mod = &sys_mods->Modules[i];
		if (strstr(mod->ImageName, "ntoskrnl.exe"))
		{
			Base = (uint64_t)mod->Base;
			break;
		}
	}

	ExFreePoolWithTag(sys_mods, tag);
	return Base;
}

UINT_PTR GetModuleBase(LPCWSTR moduleName) {

	PLIST_ENTRY ModuleList = reinterpret_cast<PLIST_ENTRY>(PsLoadedModuleList);
	if (!ModuleList)
		return NULL;

	UNICODE_STRING pmoduleName{ };
	RtlInitUnicodeString(&pmoduleName, moduleName);

	for (auto entry = PsLoadedModuleList; entry != PsLoadedModuleList->Blink; entry = entry->Flink)
	{
		PLDR_DATA_TABLE_ENTRY Datatable = CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

		if (Datatable->BaseDllName.Length == pmoduleName.Length && RtlEqualUnicodeString(&Datatable->BaseDllName, &pmoduleName, TRUE)) {
			return reinterpret_cast<UINT_PTR>(Datatable->DllBase);
		}
	}

	return NULL;
}

UINT_PTR LookupCodecave(UINT_PTR ModuleBase, INT Size)
{
	auto* dos_header = reinterpret_cast<IMAGE_DOS_HEADER*>(ModuleBase);
	auto* nt_headers = reinterpret_cast<IMAGE_NT_HEADERS*>(((BYTE*)dos_header + dos_header->e_lfanew));

	UINT_PTR start = 0, size = 0;

	UINT_PTR header_offset = (UINT_PTR)IMAGE_FIRST_SECTION(nt_headers);

	for (auto x = 0; x < nt_headers->FileHeader.NumberOfSections; ++x)
	{
		auto* header = reinterpret_cast<IMAGE_SECTION_HEADER*>(header_offset);

		if (strcmp((CHAR*)header->Name, ".rdata") == 0)
		{
			start = (UINT_PTR)ModuleBase + header->PointerToRawData;
			size = header->SizeOfRawData;
			break;
		}

		header_offset += sizeof(IMAGE_SECTION_HEADER);
	}

	UINT_PTR match = 0;
	INT cur_length = 0;

	for (auto cur = start; cur < start + size; ++cur)
	{
		if (*(BYTE*)cur == 0xCC)
		{
			if (!match)
				match = cur;

			if (++cur_length == Size)
				return match;
		}
		else
			match = cur_length = 0;
	}

	return NULL;
}

UINT_PTR GetCodeCave()
{
	UINT_PTR Driver = NULL;
	UINT_PTR IsCodeCave = 0;

	Driver = GetModuleBase(L"peauth.sys");
	if (Driver)
	{
		IsCodeCave = LookupCodecave(Driver, sizeof(ShellCode));
		if (IsCodeCave) {
			return IsCodeCave;
		}
	}

	return NULL;
}

bool ClearPFN(PMDL mdl)
{
	PPFN_NUMBER mdl_pages = MmGetMdlPfnArray(mdl);
	if (!mdl_pages)
		return false;

	ULONG mdl_page_count = ADDRESS_AND_SIZE_TO_SPAN_PAGES(MmGetMdlVirtualAddress(mdl), MmGetMdlByteCount(mdl));

	ULONG null_pfn = 0x0;
	MM_COPY_ADDRESS source_address = { 0 };
	source_address.VirtualAddress = &null_pfn;

	for (ULONG i = 0; i < mdl_page_count; i++)
	{
		size_t bytes = 0;
		MmCopyMemory(&mdl_pages[i], source_address, sizeof(ULONG), MM_COPY_MEMORY_VIRTUAL, &bytes);
	}

	return true;
};

PVOID
Sleep(
	ULONG Milliseconds
)
{
	LARGE_INTEGER Timeout;
	Timeout.QuadPart = -1 * 10000LL * (LONGLONG)Milliseconds;
	KeDelayExecutionThread(KernelMode, FALSE, &Timeout);

	return NULL;
}

void
CopyList(IN PLIST_ENTRY Original,
	IN PLIST_ENTRY Copy,
	IN KPROCESSOR_MODE Mode)
{
	if (IsListEmpty(&Original[Mode]))
	{
		InitializeListHead(&Copy[Mode]);
	}
	else
	{
		Copy[Mode].Flink = Original[Mode].Flink;
		Copy[Mode].Blink = Original[Mode].Blink;
		Original[Mode].Flink->Blink = &Copy[Mode];
		Original[Mode].Blink->Flink = &Copy[Mode];
	}
}

void
MoveApcState(PKAPC_STATE OldState,
	PKAPC_STATE NewState)
{
	RtlCopyMemory(NewState, OldState, sizeof(KAPC_STATE));

	CopyList(OldState->ApcListHead, NewState->ApcListHead, KernelMode);
	CopyList(OldState->ApcListHead, NewState->ApcListHead, UserMode);
}

uintptr_t OldProcess;
void AttachProcess(PEPROCESS NewProcess)
{
	PKTHREAD Thread = KeGetCurrentThread();

	PKAPC_STATE ApcState = *(PKAPC_STATE*)(uintptr_t(Thread) + 0x98); // 0x98 = _KTHREAD::ApcState

	if (*(PEPROCESS*)(uintptr_t(ApcState) + 0x20) == NewProcess) // 0x20 = _KAPC_STATE::Process
		return;

	if ((*(UCHAR*)(uintptr_t(Thread) + 0x24a) != 0)) // 0x24a = _KTHREAD::ApcStateIndex
	{
		KeBugCheck(INVALID_PROCESS_ATTACH_ATTEMPT);
		return;
	}

	MoveApcState(ApcState, *(PKAPC_STATE*)(uintptr_t(Thread) + 0x258)); // 0x258 = _KTHREAD::SavedApcState

	InitializeListHead(&ApcState->ApcListHead[KernelMode]);
	InitializeListHead(&ApcState->ApcListHead[UserMode]);

	OldProcess = *(uintptr_t*)(uintptr_t(ApcState) + 0x20);

	*(PEPROCESS*)(uintptr_t(ApcState) + 0x20) = NewProcess; // 0x20 = _KAPC_STATE::Process
	*(UCHAR*)(uintptr_t(ApcState) + 0x28) = 0;				// 0x28 = _KAPC_STATE::InProgressFlags
	*(UCHAR*)(uintptr_t(ApcState) + 0x29) = 0;				// 0x29 = _KAPC_STATE::KernelApcPending
	*(UCHAR*)(uintptr_t(ApcState) + 0x2a) = 0;				// 0x2a = _KAPC_STATE::UserApcPendingAll

	*(UCHAR*)(uintptr_t(Thread) + 0x24a) = 1; // 0x24a = _KTHREAD::ApcStateIndex

	auto DirectoryTableBase = *(uint64_t*)(uint64_t(NewProcess) + 0x28);  // 0x28 = _EPROCESS::DirectoryTableBase
	__writecr3(DirectoryTableBase);
}

void DetachProcess()
{
	PKTHREAD Thread = KeGetCurrentThread();
	PKAPC_STATE ApcState = *(PKAPC_STATE*)(uintptr_t(Thread) + 0x98); // 0x98 = _KTHREAD->ApcState

	if ((*(UCHAR*)(uintptr_t(Thread) + 0x24a) == 0)) // 0x24a = KTHREAD->ApcStateIndex
		return;

	if ((*(UCHAR*)(uintptr_t(ApcState) + 0x28)) ||  // 0x28 = _KAPC_STATE->InProgressFlags
		!(IsListEmpty(&ApcState->ApcListHead[KernelMode])) ||
		!(IsListEmpty(&ApcState->ApcListHead[UserMode])))
	{
		KeBugCheck(INVALID_PROCESS_DETACH_ATTEMPT);
	}

	MoveApcState(*(PKAPC_STATE*)(uintptr_t(Thread) + 0x258), ApcState); // 0x258 = _KTHREAD::SavedApcState

	if (OldProcess)
		*(uintptr_t*)(uintptr_t(ApcState) + 0x20) = OldProcess; // 0x20 = _KAPC_STATE::Process

	*(PEPROCESS*)(*(uintptr_t*)(uintptr_t(Thread) + 0x258) + 0x20) = 0; // 0x258 = _KTHREAD::SavedApcState + 0x20 = _KAPC_STATE::Process

	*(UCHAR*)(uintptr_t(Thread) + 0x24a) = 0; // 0x24a = _KTHREAD::ApcStateIndex

	auto DirectoryTableBase = *(uint64_t*)(uint64_t(*(PEPROCESS*)(uintptr_t(ApcState) + 0x20)) + 0x28); // 0x20 = _KAPC_STATE::Process + 0x28 = _EPROCESS::DirectoryTableBase
	__writecr3(DirectoryTableBase);

	if (!(IsListEmpty(&ApcState->ApcListHead[KernelMode])))
	{
		*(UCHAR*)(uint64_t(ApcState) + 0x29) = 1; // 0x29 = _KAPC_STATE::KernelApcPending
	}

	RemoveEntryList(&ApcState->ApcListHead[KernelMode]);

	OldProcess = 0;
}

PHYSICAL_ADDRESS
SafeMmGetPhysicalAddress(PVOID BaseAddress)
{
	static BOOLEAN* KdEnteredDebugger = 0;
	if (!KdEnteredDebugger)
	{
		UNICODE_STRING UniCodeFunctionName = RTL_CONSTANT_STRING(L"KdEnteredDebugger");
		KdEnteredDebugger = reinterpret_cast<BOOLEAN*>(MmGetSystemRoutineAddress(&UniCodeFunctionName));
	}

	*KdEnteredDebugger = FALSE;
	PHYSICAL_ADDRESS PhysicalAddress = MmGetPhysicalAddress(BaseAddress);
	*KdEnteredDebugger = TRUE;

	return PhysicalAddress;
}

NTSTATUS ReadVirtualMemory(
	PEPROCESS Process,
	PVOID Destination,
	PVOID Source,
	SIZE_T Size)
{
	NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
	PHYSICAL_ADDRESS SourcePhysicalAddress;
	PVOID MappedIoSpace;
	BOOLEAN IsAttached;

	// 1. Attach to the process
	//    Sets specified process's PML4 to the CR3
	AttachProcess(Process);
	IsAttached = TRUE;

	if (!MmIsAddressValid(Source))
		goto _Exit;

	// 2. Get the physical address corresponding to the user virtual memory
	SourcePhysicalAddress = SafeMmGetPhysicalAddress(Source);

	// 3. Detach from the process
	//    Restores previous the current thread
	DetachProcess();
	IsAttached = FALSE;

	if (!SourcePhysicalAddress.QuadPart)
		return ntStatus;

	// 4. Map an IO space for MDL
	MappedIoSpace = MmMapIoSpaceEx(SourcePhysicalAddress, Size, PAGE_READWRITE);
	if (!MappedIoSpace)
		goto _Exit;

	// 5. copy memory
	memcpy(Destination, MappedIoSpace, Size);

	// 6. Free Map
	MmUnmapIoSpace(MappedIoSpace, Size);

	ntStatus = STATUS_SUCCESS;

_Exit:

	if (IsAttached)
		DetachProcess();

	return ntStatus;
}

NTSTATUS WriteVirtualMemory(
	PEPROCESS Process,
	PVOID Destination,
	PVOID Source,
	SIZE_T Size)
{
	NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
	PHYSICAL_ADDRESS SourcePhysicalAddress;
	PVOID MappedIoSpace;
	BOOLEAN IsAttached;

	// 1. Attach to the process
	  //    Sets specified process's PML4 to the CR3
	AttachProcess(Process);
	IsAttached = TRUE;

	if (!MmIsAddressValid(Source))
		goto _Exit;

	// 2. Get the physical address corresponding to the user virtual memory
	SourcePhysicalAddress = SafeMmGetPhysicalAddress(Source);

	// 3. Detach from the process
	//    Restores previous the current thread
	DetachProcess();
	IsAttached = FALSE;

	if (!SourcePhysicalAddress.QuadPart)
		return ntStatus;

	// 4. Map an IO space for MDL
	MappedIoSpace = MmMapIoSpaceEx(SourcePhysicalAddress, Size, PAGE_READWRITE);
	if (!MappedIoSpace)
		goto _Exit;

	// 5. copy memory
	memcpy(MappedIoSpace, Destination, Size);

	// 6. Free Map
	MmUnmapIoSpace(MappedIoSpace, Size);

	ntStatus = STATUS_SUCCESS;

_Exit:

	if (IsAttached)
		DetachProcess();
}

NTSTATUS ReadProcessMemory(HANDLE ProcessPid, PVOID Address, PVOID Buffer, SIZE_T Size)
{
	PEPROCESS Process = { 0 };
	auto ntStatus = PsLookupProcessByProcessId(ProcessPid, &Process);
	if (NT_SUCCESS(ntStatus) && Process)
	{
		ntStatus = ReadVirtualMemory(Process, Buffer, Address, Size);
	}

	ObDereferenceObject(Process);
	return ntStatus;
}

NTSTATUS WriteProcessMemory(HANDLE ProcessPid, PVOID Address, PVOID Buffer, SIZE_T Size)
{
	PEPROCESS Process = { 0 };
	auto ntStatus = PsLookupProcessByProcessId(ProcessPid, &Process);
	if (NT_SUCCESS(ntStatus) && Process)
	{
		ntStatus = WriteVirtualMemory(Process, Buffer, Address, Size);
	}

	ObDereferenceObject(Process);
	return ntStatus;
}

PVOID GetModuleBaseProcess(
	HANDLE ProcessId,
	LPCWSTR ModuleName
)
{
	PVOID mBase = 0;
	PEPROCESS Process = { 0 };

	UNICODE_STRING module_name = RTL_CONSTANT_STRING(ModuleName);
	if (ProcessId && NT_SUCCESS(PsLookupProcessByProcessId(HANDLE(ProcessId), &Process)) && Process)
	{
		PPEB pPeb = PsGetProcessPeb(Process);

		AttachProcess(Process);

		for (PLIST_ENTRY pListEntry = pPeb->Ldr->InMemoryOrderModuleList.Flink; pListEntry != &pPeb->Ldr->InMemoryOrderModuleList; pListEntry = pListEntry->Flink)
		{
			PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

			if (RtlEqualUnicodeString(&pEntry->BaseDllName, &module_name, TRUE) == 0) {
				mBase = pEntry->DllBase;
				break;
			}
		}

		DetachProcess();
	}

	return mBase;
}

BOOLEAN
WriteToReadOnly(PVOID destination,
	PVOID buffer,
	SIZE_T size
)
{
	PMDL mdl = IoAllocateMdl(destination, size, FALSE, FALSE, 0);
	if (!mdl)
		return FALSE;

	MmProbeAndLockPages(mdl, KernelMode, IoReadAccess);
	MmProtectMdlSystemAddress(mdl, PAGE_EXECUTE_READWRITE);

	auto mmMap = MmMapLockedPagesSpecifyCache(mdl, KernelMode, MmNonCached, NULL, FALSE, NormalPagePriority);
	memcpy(mmMap, buffer, size);

	MmUnmapLockedPages(mmMap, mdl);
	MmUnlockPages(mdl);
	IoFreeMdl(mdl);

	return TRUE;
}

uintptr_t GetCallbackListHead()
{
	uint64_t NtoskrnlBase = GetModuleNtoskrnlBase();
	if (!NtoskrnlBase)
		return 0;

	auto CallbackListHead = FindPatternImage(PCHAR(NtoskrnlBase),
		"\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8B\xF8\x48\x89\x44\x24\x00\x48\x85\xC0",
		"xxx????x????xxxxxxx?xxx");

	if (!CallbackListHead)
		return 0;

	CallbackListHead = reinterpret_cast<uintptr_t>(PCHAR(CallbackListHead) + 7 + *reinterpret_cast<INT*>(PCHAR(CallbackListHead) + 3));
	return uintptr_t(CallbackListHead);
}

NTSTATUS RegisterCallback(
	PEX_CALLBACK_FUNCTION  Function,
	PVOID Context,
	PLARGE_INTEGER Cookie
)
{
	LARGE_INTEGER LowAddress, HighAddress, SkipBytes;
	LowAddress.QuadPart = 0;
	HighAddress.QuadPart = 0xffffffffffffffffULL;
	SkipBytes.QuadPart = 0;

	auto CmiCallbackHead = PRegisterCallbackEntry(GetCallbackListHead());
	if (!CmiCallbackHead)
		return STATUS_INSUFFICIENT_RESOURCES;

	auto mdl = MmAllocatePagesForMdl(LowAddress, HighAddress, SkipBytes, sizeof(RegisterCallbackEntry));
	if (!mdl) {
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	auto Mapping = MmMapLockedPagesSpecifyCache(mdl, KernelMode, MmNonCached, NULL, FALSE, NormalPagePriority);
	if (!Mapping) {
		MmFreePagesFromMdl(mdl);
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	const auto Protect = MmProtectMdlSystemAddress(mdl, PAGE_READWRITE);
	if (!NT_SUCCESS(Protect)) {
		MmUnmapLockedPages(Mapping, mdl);
		MmFreePagesFromMdl(mdl);
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	if (!ClearPFN(mdl)) {
		MmUnmapLockedPages(Mapping, mdl);
		MmFreePagesFromMdl(mdl);
		return STATUS_UNSUCCESSFUL;
	}

	auto ListMap = PRegisterCallbackEntry(Mapping);

	auto IsCodeCave = GetCodeCave();
	if (!IsCodeCave)
		return STATUS_UNSUCCESSFUL;

	*(PVOID*)(ShellCode + 3) = reinterpret_cast<PVOID>(Function);

	if (!WriteToReadOnly(PVOID(IsCodeCave), ShellCode, sizeof(ShellCode)))
	{
		DbgPrintEx(0, 0, "Failed to Write To Read Only Memory");
		return STATUS_UNSUCCESSFUL;
	}

	ListMap->Routine = PVOID(IsCodeCave);
	ListMap->Context = Context;
	ListMap->PendingDelete = FALSE;
	ListMap->Cookie.QuadPart = 0; // put a random number
	
	InsertTailList(&CmiCallbackHead->ListEntryHead, &ListMap->ListEntryHead);

	*Cookie = ListMap->Cookie;

	return STATUS_SUCCESS;

	// Do this if you want to delete the callback later when you don't need it
	/*
	RemoveEntryList(&ListMap->ListEntryHead);
	*/
}


```

`README.md`:

```md
# POC Common-Registry

    Communication via Registry/Reg
    Clearing PFN
    Custom AttachProcess


This is an old project I did in 2020, it just replaces AttachProcess (by me)

```

`UserMode/UserMode.cpp`:

```cpp
#include <iostream>
#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>

typedef struct _COPY_MEMORY {
	ULONG ProcessId;
	PVOID Destination;
	PVOID Source;
	SIZE_T Size;
} COPY_MEMORY, * PCOPY_MEMORY;

typedef struct _MODULE_BASE {
	ULONG ProcessId;
	LPCWSTR ModuleName;
	PVOID Base;
} MODULE_BASE, * PMODULE_BASE;

typedef struct _REQUEST {
	UINT32 Type;
	PVOID Instruction;
} REQUEST, * PREQUEST;

ULONG ProcessPid;

void ReadWriteRegistry(uint32_t type, void* instruction) {

	HKEY hKey = NULL;
	void* pointer = NULL;
	char Code[30] = "MyRegID";
	RegOpenKeyExA(HKEY_LOCAL_MACHINE, "Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers", 0, KEY_ALL_ACCESS, &hKey);

	if (hKey != NULL && hKey != INVALID_HANDLE_VALUE) {

		auto SetRegistryValue = [&](BYTE* pointer, SIZE_T size, DWORD Type) -> BOOL
		{
			if (RegSetValueExA(hKey, Code, 0, Type, reinterpret_cast<BYTE*>(pointer), size) == ERROR_SUCCESS)
			{
				RegDeleteValue(hKey, Code);
				RegCloseKey(hKey);
				return TRUE;
			}
			return FALSE;
		};

		REQUEST request;

		request.Type = type;
		request.Instruction = instruction;

		pointer = &request;
		SetRegistryValue(reinterpret_cast<BYTE*>(&pointer), sizeof uintptr_t, REG_QWORD);
	}
}

template<typename T>
T ReadMemory(uint64_t address) {

	COPY_MEMORY Request;

	Request.ProcessId = ProcessPid;
	Request.Source = reinterpret_cast<void*>(address);
	Request.Size = sizeof(T);

	ReadWriteRegistry(1, &Request);

	auto result = reinterpret_cast<T>(Request.Destination);
	return result;
}

template<typename T>
void WriteMemory(uint64_t address, T Value) {

	COPY_MEMORY Request;

	Request.ProcessId = ProcessPid;
	Request.Source = reinterpret_cast<void*>(address);
	Request.Destination = reinterpret_cast<void*>(Value);
	Request.Size = sizeof(T);

	ReadWriteRegistry(2, &Request);
}

uint64_t GetModuleBase(LPCWSTR ModuleName) {

	MODULE_BASE Request;

	Request.ProcessId = ProcessPid;
	Request.ModuleName = ModuleName;

	ReadWriteRegistry(3, &Request);

	return reinterpret_cast<uint64_t>(Request.Base);
}

DWORD AttachProcess(std::string processName) {

	DWORD ProcessPid = 0;
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	if (Process32First(snapshot, &entry) == TRUE)
	{
		while (Process32Next(snapshot, &entry) == TRUE)
		{
			if (strcmp(entry.szExeFile, processName.c_str()) == 0)
			{
				ProcessPid = entry.th32ProcessID;
				break;
			}
		}
	}

	CloseHandle(snapshot);
	return ProcessPid;
}

int main()
{
	ProcessPid = AttachProcess("Paladins.exe");
	std::cout << "ProcessPid: " << ProcessPid << std::endl;

	if (!ProcessPid)
		system("pause");

	auto Base = GetModuleBase(L"Paladins.exe");
	std::cout << std::hex << "Base: 0x"  << Base << std::endl;

	if (!Base)
		system("pause");

	auto Value = 1000;
	WriteMemory(Base + 0x77, Value);

	Value = ReadMemory<uint64_t>(Base + 0x77);
	printf("Value: %llu\n", Value);

	system("pause");
}

```

`UserMode/UserMode.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{db51166a-0cba-46ec-be23-0b1e4833a426}</ProjectGuid>
    <RootNamespace>UserMode</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="UserMode.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`UserMode/UserMode.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Arquivos de Origem">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Arquivos de Cabeçalho">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Arquivos de Recurso">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="UserMode.cpp">
      <Filter>Arquivos de Origem</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`UserMode/UserMode.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```