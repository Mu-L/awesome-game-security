Project Path: arc_EBalloon_MapPage_9rkl0wkm

Source Tree:

```txt
arc_EBalloon_MapPage_9rkl0wkm
├── KernelMode
│   ├── Driver.cpp
│   ├── KernelMode.vcxproj
│   ├── KernelMode.vcxproj.filters
│   ├── KernelMode.vcxproj.user
│   └── Utils.h
├── MapPage.sln
├── README.md
└── UserMode
    ├── UserMode.cpp
    ├── UserMode.user
    ├── UserMode.vcxproj
    ├── UserMode.vcxproj.filters
    └── UserMode.vcxproj.user

```

`KernelMode/Driver.cpp`:

```cpp

#include "Utils.h"

DECLSPEC_NOINLINE INT64 __fastcall Khg_Function(PVOID, PVOID, PVOID, PVOID, PVOID);

uint32_t FixImports(PVOID Function, SIZE_T Size, PVOID Imports)
{
	uint32_t Index = 0;
	for (SIZE_T i = 0; i < Size - sizeof(ULONG64); i++)
	{
		if (*(ULONG64*)((ULONG64)Function + i) - MAGICNUMBER < 0x10000 &&
			(LONG64)(*(ULONG64*)((ULONG64)Function + i) - MAGICNUMBER) >= 0)
		{
			Index++;
			auto Address = ((*(ULONG64*)((ULONG64)Function + i)) - MAGICNUMBER);
			auto Value = ((DWORD64)Imports + Address);
			*(ULONG64*)((ULONG64)Function + i) = Value;
		}
	}
	return Index;
}

PVOID AllocatePage()
{
	typedef PVOID
	(*MiMapSinglePage_t)(
		PVOID VirtualAddress,
		ULONGLONG PageFrameNumber
		);

	auto MiMapSinglePage = reinterpret_cast<MiMapSinglePage_t>(
		FindPatternImage((PCHAR)g_KernelBase, 
			(PCHAR)"\x48\x8B\xC4\x48\x89\x00\x00\x48\x89\x00\x00\x48\x00\x00\x00\x48\x89\x00\x00\x00\x00\x00\x55\x00\x00\x48\x83\x00\x00\x41\x8B\x00\x45\x8B", 
			(PCHAR)"xxxxx??xx??x???xx?????x??xx??xx?xx"));

	auto Result = MiMapSinglePage(nullptr, 0);
	if (!Result)
		return NULL;

	auto PTE = GetPteAddress(Result);
	MiMakePageValid(PTE);

	auto PDE = GetPdeAddress(Result);
	MiMakePageValid(PDE);

	return Result;
}

BOOL ReadVirtualMemory(PVOID dest, PVOID src, size_t size) {

	size_t pSize;
	if (NT_SUCCESS(g_Imports->MmCopyVirtualMemory(g_Imports->IoGetCurrentProcess(), src,
		g_Imports->IoGetCurrentProcess(), dest, size, KernelMode, &pSize)
	) && size == pSize) {
		return TRUE;
	}

	return FALSE;
}

NTSTATUS MapPage()
{
	auto win32kbase = GetModuleBase(L"win32kbase.sys");
	if (!win32kbase)
		return STATUS_UNSUCCESSFUL;

	auto DataPtr = (uint64_t)FindPatternImage(
		(PCHAR)win32kbase,
		(PCHAR)"\x74\x20\x48\x8B\x44\x24\x00\x44", 
		(PCHAR)"xxxxxx?x");

	if (!DataPtr)
		return STATUS_UNSUCCESSFUL;

	DataPtr = uint64_t((uint64_t)DataPtr - 0xA);
	DataPtr = (uint64_t)DataPtr + *(uint32_t*)((PBYTE)DataPtr + 3) + 7;

	g_Code = reinterpret_cast<ImportsList*>(ExAllocatePool(NonPagedPoolNx, sizeof(ImportsList)));
	if (!g_Code)
		return STATUS_UNSUCCESSFUL;

	RtlZeroMemory(g_Code, sizeof(ImportsList));

	g_Code->ExGetPreviousMode = ExGetPreviousMode;
	g_Code->DbgPrintEx = DbgPrintEx;
	g_Code->PsGetProcessSectionBaseAddress = PsGetProcessSectionBaseAddress;
	g_Code->PsLookupProcessByProcessId = PsLookupProcessByProcessId;
	g_Code->MmCopyVirtualMemory = MmCopyVirtualMemory;
	g_Code->IoGetCurrentProcess = IoGetCurrentProcess;

	g_Code->FunctionHook = reinterpret_cast<Khg_Function_t>(AllocatePage());
	if (!g_Code->FunctionHook)
		return STATUS_UNSUCCESSFUL;

	memcpy(g_Code->FunctionHook, &Khg_Function, PAGE_SIZE);

	auto Count = FixImports(g_Code->FunctionHook, PAGE_SIZE, g_Code);

	*(PVOID*)&g_Code->FunctionOriginal = _InterlockedExchangePointer(
		(PVOID*)DataPtr,
		(PVOID)g_Code->FunctionHook);

	if (!g_Code->FunctionOriginal)
		return STATUS_UNSUCCESSFUL;

	DbgPrintEx(0, 0, "[g_KernelBase: 0x%p] Mapped at 0x%p | Fixed: %d imports\n", (void*)g_KernelBase, (void*)g_Code->FunctionHook, Count);

	return STATUS_SUCCESS;
}

NTSTATUS g_DriverEntry(PVOID Base, PVOID Size)
{
	g_KernelBase = (ULONG64)GetModuleBase(L"ntoskrnl.exe");
	if (!g_KernelBase)
		return STATUS_UNSUCCESSFUL;

	return MapPage();
}

#pragma code_seg(".dump")
DECLSPEC_NOINLINE INT64 __fastcall Khg_Function(PVOID a1, PVOID a2, PVOID a3, PVOID a4, PVOID a5)
{
	if (g_Imports->ExGetPreviousMode() != UserMode) {
		return g_Imports->FunctionOriginal(a1, a2, a3, a4, a5);
	}

	Communication comms = {};
	if (!ReadVirtualMemory(&comms, a3, sizeof(Communication)) || comms.Reason != COMMUNICATION_KEY) {
		return g_Imports->FunctionOriginal(a1, a2, a3, a4, a5);
	}

	auto args = (Communication*)a3;

	switch (comms.Request) {

		case Request::GETBASE: {
			if (comms.processID) {
				PEPROCESS process = { 0 };
				g_Imports->PsLookupProcessByProcessId((HANDLE)args->processID, &process);
				args->Outbase = g_Imports->PsGetProcessSectionBaseAddress(process);
				g_Imports->DbgPrintEx(0, 0, "Base: %p", args->Outbase);
			}
			break;
		}
		case Request::READPROCESSMEMORY: {
			if (comms.processID) {
				PEPROCESS Process = { 0 };
				auto ntStatus = g_Imports->PsLookupProcessByProcessId((HANDLE)args->processID, &Process);
				if (NT_SUCCESS(ntStatus) && Process && args->Address)
				{
					SIZE_T Bytes = 0;
					g_Imports->MmCopyVirtualMemory(Process, args->Address, g_Imports->IoGetCurrentProcess(), &args->result, args->size, KernelMode, &Bytes);
					g_Imports->DbgPrintEx(0, 0, "Result: %llu", args->result);
				}
			}
			break;
		}
	}

	return NULL;
}
#pragma code_seg()

```

`KernelMode/KernelMode.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>DSMM</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
    <ProjectName>KernelMode</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>
    </TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <SpectreMitigation>false</SpectreMitigation>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SupportsPackaging>false</SupportsPackaging>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <KMDF_VERSION_MAJOR>1</KMDF_VERSION_MAJOR>
    <KMDF_VERSION_MINOR>9</KMDF_VERSION_MINOR>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
    <PostBuildEventUseInBuild>false</PostBuildEventUseInBuild>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <TreatLinkerWarningAsErrors>false</TreatLinkerWarningAsErrors>
      <EntryPointSymbol>g_DriverEntry</EntryPointSymbol>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <ProfileGuidedDatabase />
    </Link>
    <PostBuildEvent>
      <Command>call "$(ProjectDir)peupdate\peupdate.exe" -c "$(TargetPath)"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`KernelMode/KernelMode.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`KernelMode/KernelMode.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`KernelMode/Utils.h`:

```h
#include <ntifs.h>
#include <windef.h>
#include <ntimage.h>

extern "C" {

	NTKERNELAPI PVOID NTAPI 
		PsGetProcessSectionBaseAddress(
			__in PEPROCESS Process
		);

	NTKERNELAPI NTSTATUS NTAPI
		MmCopyVirtualMemory(
			_In_ PEPROCESS FromProcess,
			_In_ CONST VOID* FromAddress,
			_In_ PEPROCESS ToProcess,
			_Out_ PVOID ToAddress,
			_In_ SIZE_T BufferSize,
			_In_ KPROCESSOR_MODE PreviousMode,
			_Out_ PSIZE_T NumberOfBytesCopied
		);

	NTKERNELAPI NTSTATUS NTAPI 
		PsLookupProcessByProcessId(
			_In_ HANDLE    ProcessId,
			_Out_ PEPROCESS* Process
		);

	NTKERNELAPI PLIST_ENTRY NTKERNELAPI 
		PsLoadedModuleList;
}

typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef struct _MMPTE_HARDWARE
{
	/* 0x0000 */ unsigned __int64 Valid : 1; /* bit position: 0 */
	/* 0x0000 */ unsigned __int64 Dirty1 : 1; /* bit position: 1 */
	/* 0x0000 */ unsigned __int64 Owner : 1; /* bit position: 2 */
	/* 0x0000 */ unsigned __int64 WriteThrough : 1; /* bit position: 3 */
	/* 0x0000 */ unsigned __int64 CacheDisable : 1; /* bit position: 4 */
	/* 0x0000 */ unsigned __int64 Accessed : 1; /* bit position: 5 */
	/* 0x0000 */ unsigned __int64 Dirty : 1; /* bit position: 6 */
	/* 0x0000 */ unsigned __int64 LargePage : 1; /* bit position: 7 */
	/* 0x0000 */ unsigned __int64 Global : 1; /* bit position: 8 */
	/* 0x0000 */ unsigned __int64 CopyOnWrite : 1; /* bit position: 9 */
	/* 0x0000 */ unsigned __int64 Unused : 1; /* bit position: 10 */
	/* 0x0000 */ unsigned __int64 Write : 1; /* bit position: 11 */
	/* 0x0000 */ unsigned __int64 PageFrameNumber : 36; /* bit position: 12 */
	/* 0x0000 */ unsigned __int64 ReservedForHardware : 4; /* bit position: 48 */
	/* 0x0000 */ unsigned __int64 ReservedForSoftware : 4; /* bit position: 52 */
	/* 0x0000 */ unsigned __int64 WsleAge : 4; /* bit position: 56 */
	/* 0x0000 */ unsigned __int64 WsleProtection : 3; /* bit position: 60 */
	/* 0x0000 */ unsigned __int64 NoExecute : 1; /* bit position: 63 */
} MMPTE_HARDWARE, * PMMPTE_HARDWARE; /* size: 0x0008 */
typedef struct _MMPTE
{
	union
	{
		/* 0x0000 */ unsigned __int64 Long;
		/* 0x0000 */ volatile unsigned __int64 VolatileLong;
		/* 0x0000 */ struct _MMPTE_HARDWARE Hard;
		/* 0x0000 */ typedef struct _MMPTE_PROTOTYPE Proto;
		/* 0x0000 */ typedef struct _MMPTE_SOFTWARE Soft;
		/* 0x0000 */ typedef struct _MMPTE_TIMESTAMP TimeStamp;
		/* 0x0000 */ typedef struct _MMPTE_TRANSITION Trans;
		/* 0x0000 */ typedef struct _MMPTE_SUBSECTION Subsect;
		/* 0x0000 */ typedef struct _MMPTE_LIST List;
	} /* size: 0x0008 */ u;
} MMPTE, * PMMPTE; /* size: 0x0008 */

typedef struct _LDR_SERVICE_TAG_RECORD
{
	struct _LDR_SERVICE_TAG_RECORD* Next;
	ULONG ServiceTag;
} LDR_SERVICE_TAG_RECORD, * PLDR_SERVICE_TAG_RECORD;

typedef struct _LDRP_CSLIST
{
	PSINGLE_LIST_ENTRY Tail;
} LDRP_CSLIST, * PLDRP_CSLIST;

typedef enum _LDR_DDAG_STATE {
	LdrModulesMerged = -5,
	LdrModulesInitError = -4,
	LdrModulesSnapError = -3,
	LdrModulesUnloaded = -2,
	LdrModulesUnloading = -1,
	LdrModulesPlaceHolder = 0,
	LdrModulesMapping = 1,
	LdrModulesMapped = 2,
	LdrModulesWaitingForDependencies = 3,
	LdrModulesSnapping = 4,
	LdrModulesSnapped = 5,
	LdrModulesCondensed = 6,
	LdrModulesReadyToInit = 7,
	LdrModulesInitializing = 8,
	LdrModulesReadyToRun = 9
} LDR_DDAG_STATE;

typedef struct _LDR_DDAG_NODE
{
	LIST_ENTRY Modules;
	PLDR_SERVICE_TAG_RECORD ServiceTagList;
	ULONG LoadCount;
	ULONG LoadWhileUnloadingCount;
	ULONG LowestLink;
	union {
		LDRP_CSLIST Dependencies;
		SINGLE_LIST_ENTRY RemovalLink;
	};
	LDRP_CSLIST IncomingDependencies;
	LDR_DDAG_STATE State;
	SINGLE_LIST_ENTRY CondenseLink;
	ULONG PreorderNumber;
} LDR_DDAG_NODE, * PLDR_DDAG_NODE;

typedef struct _LDR_DEPENDENCY_RECORD
{
	SINGLE_LIST_ENTRY DependencyLink;
	PLDR_DDAG_NODE DependencyNode;
	SINGLE_LIST_ENTRY IncomingDependencyLink;
	PLDR_DDAG_NODE IncomingDependencyNode;
} LDR_DEPENDENCY_RECORD, * PLDR_DEPENDENCY_RECORD;

typedef enum _LDR_DLL_LOAD_REASON {
	LoadReasonStaticDependency,
	LoadReasonStaticForwarderDependency,
	LoadReasonDynamicForwarderDependency,
	LoadReasonDelayloadDependency,
	LoadReasonDynamicLoad,
	LoadReasonAsImageLoad,
	LoadReasonAsDataLoad,
	LoadReasonUnknown = -1
} LDR_DLL_LOAD_REASON,
* PLDR_DLL_LOAD_REASON;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	union {
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	union {
		UCHAR FlagGroup[4];
		ULONG Flags;
		struct
		{
			ULONG PackagedBinary : 1;
			ULONG MarkedForRemoval : 1;
			ULONG ImageDll : 1;
			ULONG LoadNotificationsSent : 1;
			ULONG TelemetryEntryProcessed : 1;
			ULONG ProcessStaticImport : 1;
			ULONG InLegacyLists : 1;
			ULONG InIndexes : 1;
			ULONG ShimDll : 1;
			ULONG InExceptionTable : 1;
			ULONG ReservedFlags1 : 2;
			ULONG LoadInProgress : 1;
			ULONG LoadConfigProcessed : 1;
			ULONG EntryProcessed : 1;
			ULONG ProtectDelayLoad : 1;
			ULONG ReservedFlags3 : 2;
			ULONG DontCallForThreads : 1;
			ULONG ProcessAttachCalled : 1;
			ULONG ProcessAttachFailed : 1;
			ULONG CorDeferredValidate : 1;
			ULONG CorImage : 1;
			ULONG DontRelocate : 1;
			ULONG CorILOnly : 1;
			ULONG ReservedFlags5 : 3;
			ULONG Redirected : 1;
			ULONG ReservedFlags6 : 2;
			ULONG CompatDatabaseProcessed : 1;
		};
	};
	USHORT ObsoleteLoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
	struct _ACTIVATION_CONTEXT* EntryPointActivationContext;
	PVOID Lock;
	PLDR_DDAG_NODE DdagNode;
	LIST_ENTRY NodeModuleLink;
	struct _LDRP_LOAD_CONTEXT* LoadContext;
	PVOID ParentDllBase;
	PVOID SwitchBackContext;
	RTL_BALANCED_NODE BaseAddressIndexNode;
	RTL_BALANCED_NODE MappingInfoIndexNode;
	ULONG_PTR OriginalBase;
	LARGE_INTEGER LoadTime;
	ULONG BaseNameHashValue;
	LDR_DLL_LOAD_REASON LoadReason;
	ULONG ImplicitPathOptions;
	ULONG ReferenceCount;
	ULONG DependentLoadFlags;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef INT64(_fastcall* Khg_Function_t)(PVOID, PVOID, PVOID, PVOID, PVOID);

#define MAGICNUMBER 0xDEADC0DE66660000ull
#define COMMUNICATION_KEY (0xDEADBEEF)

enum Request {
	GETBASE = 0,
	READPROCESSMEMORY = 1,
	WRITEPROCESSMEMORY = 2,
	OPENHANDLE = 3,
};

struct Communication {

	Request Request;
	DWORD processID;
	DWORD Reason; // must be 0xDEADBEEF....
	PVOID Outbase; // output image base for process.

	/*
	* READ/WRITE PROCESS MEMORY.
	*/
	PVOID Address;
	PVOID result;
	size_t size;
};

typedef struct
{
	decltype(&ExGetPreviousMode)(ExGetPreviousMode);
	decltype(&DbgPrintEx)(DbgPrintEx);
	decltype(&PsGetProcessSectionBaseAddress)(PsGetProcessSectionBaseAddress);
	decltype(&PsLookupProcessByProcessId)(PsLookupProcessByProcessId);
	decltype(&MmCopyVirtualMemory)(MmCopyVirtualMemory);
	decltype(&IoGetCurrentProcess)(IoGetCurrentProcess);

	Khg_Function_t FunctionOriginal;
	Khg_Function_t FunctionHook;

} ImportsList;

ImportsList* g_Code;
ImportsList* g_Imports = (ImportsList*)MAGICNUMBER;

ULONG64 g_KernelBase = 0;

BOOL CheckMask(PCHAR base, PCHAR pattern, PCHAR mask)
{
	for (; *mask; ++base, ++pattern, ++mask)
	{
		if ('x' == *mask && *base != *pattern)
		{
			return FALSE;
		}
	}

	return TRUE;
}

UINT_PTR FindPattern(PCHAR base, DWORD length, PCHAR pattern, PCHAR mask)
{
	length -= (DWORD)strlen(mask);
	for (DWORD i = 0; i <= length; ++i)
	{
		UINT_PTR addr = UINT_PTR(&base[i]);

		if (CheckMask((PCHAR)addr, pattern, mask))
		{
			return addr;
		}
	}

	return 0;
}

UINT_PTR FindPatternImage(PCHAR base, PCHAR pattern, PCHAR mask)
{
	UINT_PTR match = 0;

	PIMAGE_NT_HEADERS headers = (PIMAGE_NT_HEADERS)(base + ((PIMAGE_DOS_HEADER)base)->e_lfanew);
	PIMAGE_SECTION_HEADER sections = IMAGE_FIRST_SECTION(headers);
	for (DWORD i = 0; i < headers->FileHeader.NumberOfSections; ++i)
	{
		PIMAGE_SECTION_HEADER section = &sections[i];
		if ('EGAP' == *(int*)section->Name || memcmp(section->Name, ".text", 5) == 0)
		{
			match = FindPattern(base + section->VirtualAddress, section->Misc.VirtualSize, pattern, mask);
			if (match)
			{
				break;
			}
		}
	}

	return match;
}

PMMPTE GetPteAddress(PVOID Address)
{
	typedef PMMPTE
	(*MiGetPteAddress_t)(
		PVOID Address
		);

	static auto MiGetPteAddress = reinterpret_cast<MiGetPteAddress_t>(
		FindPatternImage((PCHAR)g_KernelBase,
			(PCHAR)"\x48\xC1\xE9\x09\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00\x48\x23\xC8\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00\x48\x03\xC1\xC3",
			(PCHAR)"xxxxxx????????xxxxx????????xxxx"));

	return MiGetPteAddress(Address);
}

PMMPTE GetPdeAddress(PVOID Address)
{
	typedef PMMPTE
	(*MiGetPdeAddress_t)(
		PVOID Address
		);

	static auto MiGetPdeAddress = reinterpret_cast<MiGetPdeAddress_t>(
		FindPatternImage((PCHAR)g_KernelBase,
			(PCHAR)"\x48\xC1\xE9\x12\x81\xE1\x00\x00\x00\x00\x48\xB8\x00\x00\x00\x00\x00\x00\x00\x00\x48\x03\xC1\xC3",
			(PCHAR)"xxxxxx????xx????????xxxx"));

	return MiGetPdeAddress(Address);
}

void MiMakePageValid(PMMPTE PTE)
{
	PTE->u.Hard.Dirty = 1;
	PTE->u.Hard.Accessed = 1;
	PTE->u.Hard.Owner = 0;
	PTE->u.Hard.Write = 1;
	PTE->u.Hard.NoExecute = 0;
	PTE->u.Hard.Valid = 1;
}

PVOID GetModuleBase(LPCWSTR moduleName) {

	UNICODE_STRING pmoduleName{ };
	RtlInitUnicodeString(&pmoduleName, moduleName);

	for (auto entry = PsLoadedModuleList; entry != PsLoadedModuleList->Blink; entry = entry->Flink)
	{
		PLDR_DATA_TABLE_ENTRY Datatable = CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

		if (Datatable->BaseDllName.Length == pmoduleName.Length && RtlEqualUnicodeString(&Datatable->BaseDllName, &pmoduleName, TRUE)) {
			return Datatable->DllBase;
		}
	}

	return NULL;
}
```

`MapPage.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32413.511
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UserMode", "UserMode\UserMode.vcxproj", "{868436CA-0CE1-4722-BD8D-3AE186474F0B}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "KernelMode", "KernelMode\KernelMode.vcxproj", "{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{868436CA-0CE1-4722-BD8D-3AE186474F0B}.Debug|x64.ActiveCfg = Debug|x64
		{868436CA-0CE1-4722-BD8D-3AE186474F0B}.Debug|x64.Build.0 = Debug|x64
		{868436CA-0CE1-4722-BD8D-3AE186474F0B}.Debug|x86.ActiveCfg = Debug|Win32
		{868436CA-0CE1-4722-BD8D-3AE186474F0B}.Debug|x86.Build.0 = Debug|Win32
		{868436CA-0CE1-4722-BD8D-3AE186474F0B}.Release|x64.ActiveCfg = Release|x64
		{868436CA-0CE1-4722-BD8D-3AE186474F0B}.Release|x64.Build.0 = Release|x64
		{868436CA-0CE1-4722-BD8D-3AE186474F0B}.Release|x86.ActiveCfg = Release|Win32
		{868436CA-0CE1-4722-BD8D-3AE186474F0B}.Release|x86.Build.0 = Release|Win32
		{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}.Debug|x64.ActiveCfg = Release|x64
		{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}.Debug|x64.Build.0 = Release|x64
		{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}.Debug|x64.Deploy.0 = Release|x64
		{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}.Debug|x86.ActiveCfg = Release|x64
		{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}.Debug|x86.Build.0 = Release|x64
		{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}.Debug|x86.Deploy.0 = Release|x64
		{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}.Release|x64.ActiveCfg = Release|x64
		{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}.Release|x64.Build.0 = Release|x64
		{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}.Release|x64.Deploy.0 = Release|x64
		{B7E0C19B-89BE-4D0C-8ED4-737CA6175D99}.Release|x86.ActiveCfg = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {3E813DCE-2F6B-4FFA-8BAB-6BC371A11D97}
	EndGlobalSection
EndGlobal

```

`README.md`:

```md
# Another POC
    After you map with kdmapper just free all mapped memory.
    use (MmFreePagesFromMdl and FreePool) 
    and you will only have one page allocated

    in this method i am using .data ptr to communicate (NtUserGetObjectInformation) (https://www.unknowncheats.me/forum/anti-cheat-bypass/425352-driver-communication-using-data-ptr-called-function.html)
    but you can use any kind of communication


# Visual studio project
# Properties -> C/C++ -> Optimization
    Full program optimization (Yes (/GL))
# Properties -> C/C++ -> Code generation
    Security Check (Disable Security Check (/GS-))
    Control flow protection (No)


# TODO

Replace KeAttachProcess with my Custom AttachProcess    
    https://github.com/EBalloon/Rw-No-Attach

```

`UserMode/UserMode.cpp`:

```cpp
#include <Windows.h>
#include <TlHelp32.h>
#include <iostream>

void*  g_DataPtr = 0;

enum Request {
	GETBASE = 0,
	READPROCESSMEMORY = 1,
	WRITEPROCESSMEMORY = 2,
	OPENHANDLE = 3,
};

struct Communication {

	Request Request;
	DWORD processID;
	DWORD Reason; // must be 0xDEADBEEF....
	PVOID Outbase; // output image base for process.

	/*
	* READ/WRITE PROCESS MEMORY.
	*/
	PVOID Address;
	PVOID result;
	size_t size;
};

BOOL Setup() {

	LoadLibraryA("user32.dll");
	LoadLibraryA("win32u.dll");
	LoadLibraryA("ntdll.dll");

	auto win32u = GetModuleHandle("win32u.dll");
	if (!win32u) {
		printf("failed to load win32u.dll\n");
		return FALSE;
	}

	g_DataPtr = GetProcAddress(win32u, "NtUserGetObjectInformation");
	if (!g_DataPtr) {
		printf("failed to find NtUserGetObjectInformation\n");
		return FALSE;
	}

	return TRUE;
}

template<typename ... Arg>
PVOID CallCommunication(const Arg ... args)
{
	if (!g_DataPtr)
		return NULL;

	auto aFunc = static_cast<PVOID(_fastcall*)(Arg...)>(g_DataPtr);
	return aFunc(args ...);
}

PVOID GetBaseAddress(DWORD processID) {
	Communication request = {};
	SecureZeroMemory(&request, sizeof(Communication));

	request.Request = Request::GETBASE;
	request.Reason = 0xDEADBEEF;
	request.processID = processID;
	request.Outbase = 0;

	CallCommunication(0, 0, &request);
	return request.Outbase;
}

template <typename T>
T ReadProcessMemory(DWORD processID, T Address) {
	Communication request = {};
	SecureZeroMemory(&request, sizeof(Communication));

	request.Request = Request::READPROCESSMEMORY;
	request.Reason = 0xDEADBEEF;
	request.processID = processID;
	request.Address = Address;
	request.size = sizeof(T);

	CallCommunication(0, 0, &request);
	return request.result;
}

DWORD GetProcessID(std::string processName) {

	DWORD processpid = 0;
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	if (Process32First(snapshot, &entry) == TRUE)
	{
		while (Process32Next(snapshot, &entry) == TRUE)
		{
			if (stricmp(entry.szExeFile, processName.c_str()) == 0)
			{
				processpid = entry.th32ProcessID;
				break;
			}
		}
	}

	CloseHandle(snapshot);
	return processpid;
}

int main()
{
	if (!Setup()) {
		printf("failed to initialize communication!\n");
		Sleep(-1);
		return -1;
	}

	auto procID = GetProcessID("ProcessName.exe");
	if (!procID) {
		printf("process not found!\n");
		Sleep(-1);
		return -1;
	}

	printf("Process ID -> %d\n", procID);

	auto base = GetBaseAddress(procID);
	if (!base) {
		printf("failed to get base address of process id -> %d\n", procID);
		Sleep(-1);
		return -1;
	}

	printf("Image Base -> 0x%p\n", base);


	ULONG Offset = 0x77;
	auto Value = ReadProcessMemory(procID, PVOID((uint64_t)base + Offset));
	printf("Value -> %llu\n", (uint64_t)Value);

	Sleep(-1);

	return 0;
}
```

`UserMode/UserMode.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`UserMode/UserMode.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="UserMode.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ntdll\ntdll.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{868436CA-0CE1-4722-BD8D-3AE186474F0B}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Tutorial6ShareMemCommunicationCLI</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>ClangCL</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExceptionHandling>false</ExceptionHandling>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`UserMode/UserMode.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="UserMode.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ntdll\ntdll.h">
      <Filter>ntdll</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="ntdll">
      <UniqueIdentifier>{005fb191-ec7a-48cf-8fcf-4ddce1697106}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`UserMode/UserMode.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```