Project Path: arc_gopro2027_ParadiseBO2_inp8q1t0

Source Tree:

```txt
arc_gopro2027_ParadiseBO2_inp8q1t0
├── Paradise BO2 Open Source
│   ├── GSC
│   │   ├── 28.gsc
│   │   ├── Elegance.gsc
│   │   ├── LozSnip.gsc
│   │   ├── azza.gsc
│   │   ├── bossam.gsc
│   │   ├── crusher.gsc
│   │   ├── hunger.gsc
│   │   ├── lmz1.gsc
│   │   ├── mike.gsc
│   │   ├── sagi.gsc
│   │   ├── stur.gsc
│   │   └── zombieland.gsc
│   ├── PS3_Debug
│   │   ├── CONTROLS.txt
│   │   ├── Call of DutyÂ®  Black Ops II.png
│   │   ├── EBOOT.BIN
│   │   ├── HOW TO INSTALL.txt
│   │   ├── Menu1.gsc
│   │   ├── ParadiseBO2.sprx
│   │   └── compiled console.gsc
│   ├── ParadiseCompatabilityTester
│   │   ├── Aimbot.h
│   │   ├── Base.h
│   │   ├── Injector.h
│   │   ├── ParadiseCompatabilityTester.vcxproj
│   │   ├── ParadiseCompatabilityTester.vcxproj.filters
│   │   ├── ParadiseCompatabilityTester.vcxproj.user
│   │   ├── Structs.h
│   │   ├── Vectors.h
│   │   ├── Window.h
│   │   ├── WindowSetup.h
│   │   ├── autowall.h
│   │   ├── autowall2.h
│   │   ├── aw.h
│   │   ├── bo2dvars.h
│   │   ├── networking.h
│   │   ├── printf.cpp
│   │   ├── prx.cpp
│   │   ├── stats.h
│   │   ├── stats2.h
│   │   ├── stats3.h
│   │   ├── stdafx.cpp
│   │   └── stdafx.h
│   ├── ParadiseCompatabilityTester.sdf
│   ├── ParadiseCompatabilityTester.sln
│   ├── ParadiseCompatabilityTester.suo
│   ├── batman.gsc
│   └── shader_list.txt
└── README.md

```

`Paradise BO2 Open Source/PS3_Debug/CONTROLS.txt`:

```txt
Copyright© http://paradisesprx.com by gopro_2027

COD BO2 SPRX v1.2

Open: L1 + Dpad UP
Scroll: DPad up/down
Change Window: R1/L1
Select: L3
Exit: R3
Edit Value: DPad left/right or Square for keyboard dialog

```

`Paradise BO2 Open Source/PS3_Debug/HOW TO INSTALL.txt`:

```txt
Put ParadiseBO2.sprx in /dev_hdd0/tmp/ParadiseBO2.sprx
Put EBOOT.BIN in your Black Ops 2 USRDIR folder
Run bo2 and you should get a notification saying welcome to paradise!
```

`Paradise BO2 Open Source/ParadiseCompatabilityTester.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ParadiseCompatabilityTester", "ParadiseCompatabilityTester\ParadiseCompatabilityTester.vcxproj", "{4D6610B6-AF75-4554-A7B4-50EB4C25971C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|PS3 = Debug|PS3
		Release|PS3 = Release|PS3
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4D6610B6-AF75-4554-A7B4-50EB4C25971C}.Debug|PS3.ActiveCfg = Debug|PS3
		{4D6610B6-AF75-4554-A7B4-50EB4C25971C}.Debug|PS3.Build.0 = Debug|PS3
		{4D6610B6-AF75-4554-A7B4-50EB4C25971C}.Release|PS3.ActiveCfg = Release|PS3
		{4D6610B6-AF75-4554-A7B4-50EB4C25971C}.Release|PS3.Build.0 = Release|PS3
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/Aimbot.h`:

```h
bool canUseAutowall() {
	if (autowallEnabled == false)
		return false;
	//if (allowAutowall == false)
		//return false;
	return true;
}

int Centity(int ClientIndex)
{
	return *(int*)(0xE22F20) + (ClientIndex * 0x374);
}

opd_s GetWeaponDef_t = {0x00606F08,TOC};
int(*GetWeaponDef)(int weapon) = (int(*)(int))&GetWeaponDef_t;

opd_s GetSpreadForWeapon_t = {0x005F09C8,TOC};
void(*GetSpreadForWeapon)(int playerstate,int weaponid,float *min, float *max) = (void(*)(int,int,float*,float*))&GetSpreadForWeapon_t;
#include "aw.h"

int cg_t(int Mod)
{
	return *(int*)(addresses.GLOBAL_CGAME_PTR_ADD/*0xE22F18*/) + Mod;
}
typedef float vec3_t[3];
Vector3 GetTagPos(int targEnt, const char *tagName)
{
	float out[3];
	AimTarget_GetTagPos(Centity(targEnt), SL_GetString(tagName), out);
	return Vector3(out[0], out[1], out[2]);
}
float outTMPTAGPOS[3];
float *GetTagPosFloat(int targEnt, const char *tagName)
{
	AimTarget_GetTagPos(Centity(targEnt), SL_GetString(tagName), outTMPTAGPOS);
	return outTMPTAGPOS;
}

int ClientActive(int Mod)
{
	return Mod + *(int*)addresses.GLOBAL_CLIENT_PTR_ADD/*0xD689D8*/;
}

Vector3 GetPlayerOrigin(int index)
{
	return *(Vector3*)(Centity(index) + 0x168);
}
float *GetPlayerOriginFloat(int index)
{
	return (float*)(Centity(index) + 0x168);
}

float *getMyRefDef() {
	return (float*)&(Get_cgs()->refdef.viewOrigin);
}

int ClientInfo(int Index, int Mod)
{
	return (cg_t(0)) + 0x69DA0 + (Index * 0x808) + Mod;
}

char *tagList[] = {"j_head",
"j_neck",
"j_spine4",
"back_mid",
"back_low",
"torso_stabilizer",
"pelvis",
"j_mainroot",
"j_wrist_ri",
"j_wrist_le",
"j_elbow_ri",
"j_elbow_le",
"j_shoulder_ri",
"j_shoulder_le",
"j_ankle_ri",
"j_ankle_le",
"j_knee_ri",
"j_knee_le",
"tag_weapon_right",
"tag_weapon_left"};
int playerTags[18];
void setPlayerTag(int player, int tag) {
	playerTags[player] = tag%20;
}
int getPlayerTag(int player) {
	return playerTags[player];
}
char *getTagInList(int tag) {
	return tagList[tag];
}
int nearestClient;
char *bestTag = "";
int GetNearestPlayer(int Client)
{
	bestTag = TagOrigin;
	nearestClient = -1;
	float nearestDistance = 99999999;
	for (int i = 0; i < 18; ++i)
	{
		if (i != Client)
		{
			if (!CG_IsEntityFriendlyNotEnemy(0, Centity(i)))
			{
				if (!*(bool*)ClientInfo(i, 0x8F))
				{
					if (*(int*)ClientInfo(i, 0x0C) > 0 && *(int*)(Centity(i)+0x2B4) != 0x59/*assault shield*/)
					{
						float Distance = Distance3D(GetPlayerOrigin(Client), GetPlayerOrigin(i));
							if (Distance < nearestDistance)
							{
						if ((AimTarget_isTargetVisible(0, Centity(i)) && Stealth))
						{
							//float Distance = Distance3D(GetPlayerOrigin(Client), GetPlayerOrigin(i));
							//if (Distance < nearestDistance)
							//{
								nearestDistance = Distance;
								nearestClient = i;
								ClientReady = true;
							//}
						}
						else if (!Stealth)
						{
							//float Distance = Distance3D(GetPlayerOrigin(Client), GetPlayerOrigin(i));
							//if (Distance < nearestDistance)
							//{
								nearestDistance = Distance;
								nearestClient = i;
								ClientReady = true;
							//}
						}
						else if (autowallEnabled != 0) {
							int tag = getPlayerTag(i);
							if (autowallEnabled == 2) {//experimental
								//for (int ti = 0; ti < 20; ti++) {
									bestTag = getTagInList(tag);
									if (autowall::isTargetHitable(getMyRefDef(), GetTagPosFloat(i, bestTag),i)/*autowall::GetAutoWallDamageMultiplier(getMyRefDef(), GetTagPosFloat(i, TagOrigin)) > 0.9f*/) {
										//float Distance = Distance3D(GetPlayerOrigin(Client), GetPlayerOrigin(i));
										//if (Distance < nearestDistance)
										//{
										nearestDistance = Distance;
										nearestClient = i;
										ClientReady = true;
										//break;
										//}
									} else {
										setPlayerTag(i,tag+1);
									}
								//}
							}
							else if(autowallEnabled == 3) {//super
								for (int ti = 0; ti < 20; ti++) {
									bestTag = getTagInList(ti);
									if (autowall::isTargetHitable(getMyRefDef(), GetTagPosFloat(i, bestTag),i)/*autowall::GetAutoWallDamageMultiplier(getMyRefDef(), GetTagPosFloat(i, TagOrigin)) > 0.9f*/) {
										nearestDistance = Distance;
										nearestClient = i;
										ClientReady = true;
										break;
									}
								}
							}
							else {//stable aka 1
								if (autowall::isTargetHitable(getMyRefDef(), GetTagPosFloat(i, TagOrigin),i)/*autowall::GetAutoWallDamageMultiplier(getMyRefDef(), GetTagPosFloat(i, TagOrigin)) > 0.9f*/) {
										//float Distance = Distance3D(GetPlayerOrigin(Client), GetPlayerOrigin(i));
										//if (Distance < nearestDistance)
										//{
										nearestDistance = Distance;
										nearestClient = i;
										ClientReady = true;
										//}
									}
							}
						}
							}
					}
				}
			}
		}
	}
	TagOrigin = bestTag;
	return nearestClient;
}

bool WorldPosToScreenPos_r(int Entity, float* x, float* y, char *tag = "j_neck")
{
	//0x10024000 is ok because allocations start at 0x10026000
	*(Vector3*)0x10024000 = GetTagPos(Entity, tag);
	__asm(
	"li %r3, 0;"
		"lis %r4, 0x1002;"
		"ori %r4, %r4, 0x4000;"
		"lis %r5, 0x1002;"
		"ori %r5, %r5, 0x5000;"
		"lis %r11, 0x5;"
		"ori %r11, %r11, 0xA480;"
		"mtctr %r11;"
		"bctrl;"
		"mr %r8, %r3;"
		);
	*x = *(float*)0x10025000;
	*y = *(float*)0x10025004;
	__asm("mr %r3, %r8");

}

bool WorldPosToScreenPos_r(Vector3 pos, float* x, float* y)
{
	*(float*)(0x10024000) = pos.x;
	*(float*)(0x10024004) = pos.y;
	*(float*)(0x10024008) = pos.z;
	__asm(
	"li %r3, 0;"
		"lis %r4, 0x1002;"
		"ori %r4, %r4, 0x4000;"
		"lis %r5, 0x1002;"
		"ori %r5, %r5, 0x5000;"
		"lis %r11, 0x5;"
		"ori %r11, %r11, 0xA480;"
		"mtctr %r11;"
		"bctrl;"
		"mr %r8, %r3;"
		);
	*x = *(float*)0x10025000;
	*y = *(float*)0x10025004;
	__asm("mr %r3, %r8");

}

void renderESP(int Client) {
	float cx = getScreenPercentX(0.5f);
	float cy = getScreenPercentY(0.5f);
	for (int i = 0; i < 18; ++i) {
		if (i != Client) {
			if (!CG_IsEntityFriendlyNotEnemy(0, Centity(i))) {//is enemy
				if (!*(bool*)ClientInfo(i, 0x8F)) {
					if (*(int*)ClientInfo(i, 0x0C) > 0) {
						//float x,y;
						float hx,hy;
						float rx,ry;
						float mcx,mcy;
						//float lx,ly;
						if (WorldPosToScreenPos_r(i,&hx,&hy,"j_helmet") && WorldPosToScreenPos_r(i,&rx,&ry,"j_ankle_ri") && WorldPosToScreenPos_r(i,&mcx,&mcy,"j_mainroot")) {
							int maxy = ry;
							int miny = hy;
							int sizey = myMath::abs(ry-hy);
							int sizex = sizey/2;//cuz why not
							int minx = hx - sizex/2;
							if (AimTarget_isTargetVisible(0, Centity(i))) {
								//color blue
								if(ESP)
									DrawShader(minx,miny,sizex,sizey,colors::LightBlueOpaque,"white");
								if(SNAPLINES)
									DrawLine1(cx,cy,mcx,mcy,colors::LightBlueOpaque);
							} else {
								//color red
								if(ESP)
									DrawShader(minx,miny,sizex,sizey,colors::RedOpaque,"white");
								if(SNAPLINES)
									DrawLine1(cx,cy,mcx,mcy,colors::RedOpaque);
							}
						}
					}
				}
			}
		}
	}
}





//#include "autowall.h"

#define ANGLE2SHORT(x)   ((int)((x)*65536/360) & 65535)
float normalize180(float num) {
	while (num < -180)
		num+=360;
	while (num > 180)
		num-=360;
	return num;
}
float normalize90(float num) {
	while (num < -90)
		num+=180;
	while (num > 90)
		num-=180;
	if (num > 89)
		num = 88;
	if (num < -89)
		num = -88;
	return num;
}

opd_s clcnc = {0x00105244,TOC};
int(*CL_CreateNewCommands)(int localClientNum) = (int(*)(int))&clcnc;
opd_s clwp = {0x00116524,TOC};
int(*CL_WritePacket)(int localClientNum) = (int(*)(int))&clwp;
int hkCL(int r3);
int clcnc_redo(int r3) {//bo2: 0x00105244
	char bytes[16] = {0xF8, 0x21, 0xFF, 0x41, 0x7C, 0x08, 0x02, 0xA6, 0xF8, 0x01, 0x00, 0xD0, 0x1C, 0x83, 0x04, 0x58};
	write_process((void*)0x00105244,bytes,16);
	int j = CL_CreateNewCommands(r3);
	PatchInJump(0x00105244,(int)hkCL,false);
	return j;
}
int wp_redo(int r3, int howManyTimes = 0) {//bo2: 0x00116524
	char bytes[16] = {0xF8, 0x21, 0xF6, 0xC1, 0x7C, 0x08, 0x02, 0xA6, 0xF8, 0x01, 0x09, 0x50, 0xFB, 0x41, 0x09, 0x10};
	write_process((void*)0x00116524,bytes,16);
	int j = 0;//CL_WritePacket(r3);
	for (int i = 0; i < howManyTimes; i++)
		j = CL_WritePacket(r3);
	PatchInJump(0x00116524,(int)hkCL,false);
	return j;
}

void AntiAimCmd(CCommand* c)//idk if this works lol
{
    c->buttons &= ~(1<<28);
    c->buttons &= ~(1<<11);
}


/*void BG_seedRandWithGameTime(int *pHoldrand)
{
	*pHoldrand ^= *(char *)pHoldrand << 8;
	*pHoldrand = *pHoldrand ^ ((*(char *)pHoldrand << 8) << 8) ^ ((*(char *)pHoldrand << 8) << 16);
}*/

void SinCos(float num, float *sin, float *cos) {
	*sin = myMath::sin(num);
	*cos = myMath::cos(num);
}
void AngleVectors( Vector3 *angles, Vector3 *forward, Vector3 *right, Vector3 *up )
{
	float sr, sp, sy, cr, cp, cy;
	SinCos(angles->y, &sy, &cy );
	SinCos(angles->x, &sp, &cp );
	SinCos(angles->z, &sr, &cr );
	//printf("sr %i, sp %i, sy %i, cr %i, cp %i, cy %i\n", (int)(sr*100),(int)(sp*100),(int)(sy*100),(int)(cr*100),(int)(cp*100),(int)(cy*100));
	//if (forward)
	//{
		forward->x = cp*cy;
		forward->y = cp*sy;
		forward->z = -sp;
	//}
 
	//if (right)
	//{
		right->x = (-1*sr*sp*cy+-1*cr*-sy);
		right->y = (-1*sr*sp*sy+-1*cr*cy);
		right->z = -1*sr*cp;
	//}
 
	//if (up)
	//{
		up->x = (cr*sp*cy+-sr*-sy);
		up->y = (cr*sp*sy+-sr*cy);
		up->z = cr*cp;
	//}
}

void VectorAnglessss(Vector3 *dir, Vector3 *save) {
	float forward;
	float yaw, pitch;
	if (dir->x == 0 && dir->y == 0)
	{
		yaw = 0;
		if (dir->z > 0) pitch = 90.00;
		else pitch = 270.00;
	}
	else
	{
		if (dir->x != -1) yaw = (float)(myMath::atan2((double)dir->y, (double)dir->x) * 180.00 / PI);
		else if (dir->y > 0) yaw = 90.00;
		else yaw = 270;
		if (yaw < 0) yaw += 360.00;
		forward = (float)sqrt((double)(dir->x * dir->x + dir->y * dir->y));
		pitch = (float)(myMath::atan2((double)dir->z, (double)forward) * 180.00 / PI);
		if (pitch < 0) pitch += 360.00;
	}
	save->x = -pitch;
	save->y = yaw;
	save->z = 0;
}
#define SHORT2ANGLE(x)  ((x)*(360.0/65536))
void GetMovementFix(unsigned int state, float oForwardMove, float oSideMove, CCommand *cmd)
    {
        //fix movement Q_Q
        switch (state)
        {
        case 0:
        case 1:
            if (cmd->forwardmove == 0)
            {
                if (cmd->sidemove == 0)
                {
                    cmd->forwardmove = 0;
                    cmd->sidemove = 0;
                }
                else if (cmd->sidemove < 0)
                {
                    cmd->forwardmove = 450;
                    cmd->sidemove = -450;
                }
                else if (cmd->sidemove > 0)
                {
                    cmd->forwardmove = -450;
                    cmd->sidemove = 450;
                }
            }
            else if (cmd->forwardmove < 0)
            {
                if (cmd->sidemove == 0)
                {
                    cmd->forwardmove = -450;
                    cmd->sidemove = -450;
                }
                else if (cmd->sidemove < 0)
                {
                    cmd->forwardmove = 0;
                    cmd->sidemove = -450;
                }
                else if (cmd->sidemove > 0)
                {
                    cmd->forwardmove = -450;
                    cmd->sidemove = 0;
                }
            }
            else if (cmd->forwardmove > 0)
            {
                if (cmd->sidemove == 0)
                {
                    cmd->forwardmove = 450;
                    cmd->sidemove = 450;
                }
                else if (cmd->sidemove < 0)
                {
                    cmd->forwardmove = 450;
                    cmd->sidemove = 0;
                }
                else if (cmd->sidemove > 0)
                {
                    cmd->forwardmove = 0;
                    cmd->sidemove = 450;
                }
            }
        case 2:
            cmd->forwardmove = -oSideMove;
            cmd->sidemove = oForwardMove;
        case 3:
            if (cmd->forwardmove == 0)
            {
                if (cmd->sidemove == 0)
                {
                    cmd->sidemove = 0;
                    cmd->forwardmove = 0;
                }
                else if (cmd->sidemove < 0)
                {
                    cmd->sidemove = 450;
                    cmd->forwardmove = 450;
                }
                else if (cmd->sidemove > 0)
                {
                    cmd->sidemove = -450;
                    cmd->forwardmove = -450;
                }
            }
            else if (cmd->forwardmove < 0)
            {
                if (cmd->sidemove == 0)
                {
                    cmd->sidemove = -450;
                    cmd->forwardmove = 450;
                }
                else if (cmd->sidemove < 0)
                {
                    cmd->sidemove = 0;
                    cmd->forwardmove = 450;
                }
                else if (cmd->sidemove > 0)
                {
                    cmd->sidemove = -450;
                    cmd->forwardmove = 0;
                }
            }
            else if (cmd->forwardmove > 0)
            {
                if (cmd->sidemove == 0)
                {
                    cmd->sidemove = 450;
                    cmd->forwardmove = -450;
                }
                else if (cmd->sidemove < 0)
                {
                    cmd->sidemove = 450;
                    cmd->forwardmove = 0;
                }
                else if (cmd->sidemove > 0)
                {
                    cmd->sidemove = 0;
                    cmd->forwardmove = -450;
                }
            }
            break;
        case 4:
            cmd->forwardmove = -oForwardMove;
            cmd->sidemove = -oSideMove;
            break;
        case 5:
            if (cmd->forwardmove == 0)
            {
                if (cmd->sidemove == 0)
                {
                    cmd->forwardmove = 0;
                    cmd->sidemove = 0;
                }
                else if (cmd->sidemove < 0)
                {
                    cmd->forwardmove = -450;
                    cmd->sidemove = 450;
                }
                else if (cmd->sidemove > 0)
                {
                    cmd->forwardmove = 450;
                    cmd->sidemove = -450;
                }
            }
            else if (cmd->forwardmove < 0)
            {
                if (cmd->sidemove == 0)
                {
                    cmd->forwardmove = 450;
                    cmd->sidemove = 450;
                }
                else if (cmd->sidemove < 0)
                {
                    cmd->forwardmove = 0;
                    cmd->sidemove = 450;
                }
                else if (cmd->sidemove > 0)
                {
                    cmd->forwardmove = 450;
                    cmd->sidemove = 0;
                }
            }
            else if (cmd->forwardmove > 0)
            {
                if (cmd->sidemove == 0)
                {
                    cmd->forwardmove = -450;
                    cmd->sidemove = -450;
                }
                else if (cmd->sidemove < 0)
                {
                    cmd->forwardmove = -450;
                    cmd->sidemove = 0;
                }
                else if (cmd->sidemove > 0)
                {
                    cmd->forwardmove = 0;
                    cmd->sidemove = -450;
                }
            }
            break;
        case 6:
            cmd->forwardmove = oSideMove;
            cmd->sidemove = -oForwardMove;
            break;
        case 7://originally 6. Changed to 7
            if (cmd->forwardmove == 0)
            {
                if (cmd->sidemove == 0)
                {
                    cmd->sidemove = 0;
                    cmd->forwardmove = 0;
                }
                else if (cmd->sidemove < 0)
                {
                    cmd->sidemove = -450;
                    cmd->forwardmove = -450;
                }
                else if (cmd->sidemove > 0)
                {
                    cmd->sidemove = 450;
                    cmd->forwardmove = 450;
                }
            }
            else if (cmd->forwardmove < 0)
            {
                if (cmd->sidemove == 0)
                {
                    cmd->sidemove = 450;
                    cmd->forwardmove = -450;
                }
                else if (cmd->sidemove < 0)
                {
                    cmd->sidemove = 0;
                    cmd->forwardmove = -450;
                }
                else if (cmd->sidemove > 0)
                {
                    cmd->sidemove = 450;
                    cmd->forwardmove = 0;
                }
            }
            else if (cmd->forwardmove > 0)
            {
                if (cmd->sidemove == 0)
                {
                    cmd->sidemove = -450;
                    cmd->forwardmove = 450;
                }
                else if (cmd->sidemove < 0)
                {
                    cmd->sidemove = -450;
                    cmd->forwardmove = 0;
                }
                else if (cmd->sidemove > 0)
                {
                    cmd->sidemove = 0;
                    cmd->forwardmove = 450;
                }
            }
            break;
        }
    }

void doSilentAim() {

	/*if ((!(cmd->buttons & IN_ATTACK) || (cmd->buttons & IN_ATTACK && BaseWeapon->NextPrimaryAttack() > flServerTime &&
    !CBaseWeapon::IsWeaponNonAim(BaseWeapon->GetWeaponID())))
    && !(cmd->buttons & IN_USE))
{
    Vector spinAngles = viewAnglesCopy;
 
    spinAngles.y += 45 * (state % 8);
    cmd->viewangles = Vector::ClampAngle(spinAngles);
 
    g_pMISC->GetMovementFix(state % 8, oForwardMove, oSideMove, cmd);
 
    state++;
}*/
	


	int wepid = *(int*)(Centity(Get_cgs()->localIndex)+0x2B4);
	float spread, minSpread, maxSpread;
	CCommand* cmd = &client_get()->input.commands[client_get()->input.currentIdx&0x7F];
	CCommand* oldcmd = &client_get()->input.commands[(client_get()->input.currentIdx-1)&0x7F];
	int playerstate = addresses.playerstate/*0x03780EA28*/;
	float aimRatio_a = *(float*)0x03780EC08;//0 is not aiming. 1.0 is aimed all the way
	if (aimRatio_a == 1.0f)
		return;
	int weaponDefPtr = GetWeaponDef(wepid);
	spread = Get_cgs()->spreadMult * 0.0039215689;
	GetSpreadForWeapon(playerstate,wepid,&minSpread,&maxSpread);
	spread = minSpread + ((maxSpread - minSpread) * spread);
	int iCurrentTime = *(int*)playerstate;
	opd_s BG_seedRandWithGameTime_t = {addresses.BG_seedRandWithGameTime/*0x005D6C54*/,TOC};
	void(*BG_seedRandWithGameTime)(int *save) = (void(*)(int *))&BG_seedRandWithGameTime_t;
	BG_seedRandWithGameTime(&iCurrentTime);
	Vector3 viewAngles,spreadEndVec;
	float range = 8192.0f;
	Vector3 viewAxis[3];
	vec3_t spreadDirection;
	AngleVectors(&AimAngles, &(viewAxis[0]), &(viewAxis[1]), &(viewAxis[2]));
	opd_s CG_BulletEndposition_t = {addresses.CG_BulletEndposition/*0x000EBB48*/,TOC};
	void(*CG_BulletEndposition)(int *seed,float spread,Vector3 *start,Vector3 *end,vec3_t *dir,Vector3 *forwdir, Vector3 *rightdir, Vector3 *updir, float range) = (void(*)(int*,float,Vector3*,Vector3*,vec3_t *,Vector3*,Vector3*,Vector3*,float))&CG_BulletEndposition_t;
	CG_BulletEndposition(&iCurrentTime, spread, &Get_cgs()->refdef.viewOrigin,&spreadEndVec, &spreadDirection,&viewAxis[0], &viewAxis[1], &viewAxis[2], range);
	Vector3 tmp = Difference(spreadEndVec, Get_cgs()->refdef.viewOrigin);
	VectorAnglessss(&tmp,&viewAngles);
	oldcmd->viewAngles.x += ANGLE2SHORT(/*AimAngles.x+*/(AimAngles.x - viewAngles.x));
	oldcmd->viewAngles.y += ANGLE2SHORT(/*AimAngles.y+*/(AimAngles.y - viewAngles.y));
}

/*
//basic silent aim for reference
void DoSilentAim(bool bAdjust)
{
	CCommand* cmd = &client_get()->input.commands[client_get()->input.currentIdx&0x7F];
	CCommand* oldcmd = &client_get()->input.commands[(client_get()->input.currentIdx-1)&0x7F];

    if (bAdjust) {
		oldcmd->time+=2;// = getServerTime()-1;
		int x = ANGLE2SHORT(normalize90(AimAngles.x));
		int y = ANGLE2SHORT(normalize180(AimAngles.y));

        oldcmd->viewAngles.x = x;
        oldcmd->viewAngles.y = y;

		NoSpread(oldcmd);

		//oldcmd->buttons &= ~(1<<31);//unshoot
		if(autoShoot)
			cmd->buttons |= (1<<31);//shoot    oldcmd does not work
    }
}*/
float AngleNormalize360(float angle) {
	return (360.0 / 65536) * ((int)(angle * (65536 / 360.0)) & 65535);
}
void fixWalking() {
	CCommand* cmd = &client_get()->input.commands[client_get()->input.currentIdx&0x7F];
	CCommand* oldcmd = &client_get()->input.commands[(client_get()->input.currentIdx-1)&0x7F];
	int forwardmove = cmd->forwardmove;
	int rightmove = cmd->sidemove;
					
					if ( forwardmove != 0 || rightmove != 0 )
					{
						float move_angle = AngleNormalize360( myMath::atan2( -rightmove / 127.0, forwardmove / 127.0 ) );
						float delta_angle = 0;//AngleNormalize360( AimAngles.y - ( game_->GetCG( )->predictedPlayerState.viewangles[ 1 ] - SHORT2ANGLE( game_->GetCG( )->predictedPlayerState.delta_angles[ 1 ] ) ) );
						float destination_angle = AngleNormalize360( move_angle - delta_angle );
						float forwardmove_ratio = myMath::cos( destination_angle  );
						float rightmove_ratio = -myMath::sin( destination_angle  );
 
						if ( myMath::abs( forwardmove_ratio ) < myMath::abs( rightmove_ratio ) )
						{
							forwardmove_ratio *= 1.0 / myMath::abs( rightmove_ratio );
							rightmove_ratio = rightmove_ratio > 0.0 ? 1.0 : -1.0;
						}
						else if ( myMath::abs( forwardmove_ratio ) > myMath::abs( rightmove_ratio ) )
						{
							rightmove_ratio *= 1.0 / myMath::abs( forwardmove_ratio );
							forwardmove_ratio = forwardmove_ratio > 0.0 ? 1.0 : -1.0;
						}
						else
						{
							forwardmove_ratio = 1.0;
							rightmove_ratio = 1.0;
						}
 
						forwardmove = forwardmove_ratio * 127;
						rightmove = rightmove_ratio * 127;
 
						oldcmd->forwardmove = forwardmove;
						oldcmd->sidemove = rightmove;
					}
}

int timelag = 0;
int testtype = 0;
bool ySwitch;
int hkCL(int r3)
{
	CCommand* cmd = &client_get()->input.commands[client_get()->input.currentIdx&0x7F];
	CCommand* oldcmd = &client_get()->input.commands[(client_get()->input.currentIdx-1)&0x7F];


	bool changeTime = false;
	bool doWpRedo = true;
	if (aimbothit && silentAimbot && AimbotStarted) {
		oldcmd->viewAngles.x = ANGLE2SHORT(AimAngles.x);
		oldcmd->viewAngles.y = ANGLE2SHORT(AimAngles.y);
		changeTime = true;

		if (fakeLag) {
			timelag++;
			doWpRedo = false;
			if (timelag >= 25) {
				doWpRedo = true;
				timelag = 0;
			}
		}
	}
	if (aimbothit && AimbotStarted && NoSpreadToggle) {
		doSilentAim();
		changeTime = true;
	}
	if(aimbothit && autoShoot && AimbotStarted) {
		//cmd->buttons |= (1<<31);
		oldcmd->buttons &= ~(1<<31);
                cmd->buttons |= (1<<31);
	}
	if (changeTime) {
		oldcmd->time += 1;//I originally had it at 2
		//fixWalking();//doesn't work yet
	}

	//if (ySwitch == true) {
		//cmd->buttons &= ~(1<<31);
	//}

	
	if(!(oldcmd->buttons &= (1<<31))) {
		/*if ( ySwitch )
			oldcmd->viewAngles.y += 323210000;
		else
			oldcmd->viewAngles.y -= 323210000;
		
		ySwitch = !ySwitch;*/

		static int state = 0;
		static vec3i spinAngles;
		spinAngles.y += 45 * (state % 8);
		cmd->viewAngles.x = ANGLE2SHORT(spinAngles.x);
 
		GetMovementFix(state % 8, oldcmd->forwardmove, oldcmd->sidemove, cmd);
		
		state++;
	}

	//printf("x: %i y: %i z: %i\n",(int)((float)SHORT2ANGLE(oldcmd->viewAngles.x)),(int)((float)SHORT2ANGLE(oldcmd->viewAngles.y)),(int)((float)SHORT2ANGLE(oldcmd->viewAngles.z)));
	while ((float)SHORT2ANGLE(oldcmd->viewAngles.x) > 360.0f)
		oldcmd->viewAngles.x = ANGLE2SHORT((float)SHORT2ANGLE(oldcmd->viewAngles.x)-360.0f);
	while ((float)SHORT2ANGLE(oldcmd->viewAngles.x) < 0.0f)
		oldcmd->viewAngles.x = ANGLE2SHORT((float)SHORT2ANGLE(oldcmd->viewAngles.x)+360.0f);

	while ((float)SHORT2ANGLE(oldcmd->viewAngles.y) > 360.0f)
		oldcmd->viewAngles.y = ANGLE2SHORT((float)SHORT2ANGLE(oldcmd->viewAngles.y)-360.0f);
	while ((float)SHORT2ANGLE(oldcmd->viewAngles.y) < 0.0f)
		oldcmd->viewAngles.y = ANGLE2SHORT((float)SHORT2ANGLE(oldcmd->viewAngles.y)+360.0f);
	if (doWpRedo)
		return wp_redo(r3,1);
	return 0;
} 
```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/Base.h`:

```h
bool WorldPosToScreenPos_r(Vector3 pos, float* x, float* y);
int selectedMenu = 0;
int selectedOption = 0;
int currentOptionCount = 0;
int lastMenus[20];
int lastMenuCount = 0;
namespace MENUS {
enum MENUS {
	Closed,
	Name,
	LobbyInfo,
	Main,
	Prelobby,
	Self,
	PrivateLobby,
	Aimbot,
	AimbotPresets,
	Host,
	Infection,
	Injector,
	IPs,
	IP2s,
	Credits,
	Invalid,

	Submenus_Count
};
}

#define KEYBOARD_MAX_LENGTH 256
namespace SWindow {class WindowOption;};
namespace keyboardSWindow {void openKeyboard(SWindow::WindowOption *callback, int maxLength = KEYBOARD_MAX_LENGTH, char *title = "Enter Value", char *presetMessage = "");}
#include "Window.h"

namespace keyboard {
	wchar_t Title[KEYBOARD_MAX_LENGTH];
	wchar_t Preset[KEYBOARD_MAX_LENGTH];
	void GetWC(char *c, wchar_t *save) {
		int len = strlen(c);
		for (int i = 0; i < len; i++)
			save[i] = (wchar_t)c[i];
		save[len+1] = (wchar_t)'\0';
	}
	void (*callbackFunction)(char *) = 0;
	char str[KEYBOARD_MAX_LENGTH+1];
	void keyboardCallback(int LocalClientNum, const wchar_t * wString, int Length) {
		for (int i = 0; i < Length; i++) {
			str[i] = wString[i];
		}
		str[Length] = '\0';
		callbackFunction(str);
	}
	void OnScreenKeyboard(int LocalClientNum, wchar_t *Title, wchar_t *PresetMessage, int Length, void(*CompleteFunction)(int LocalClientNum, const wchar_t * wString, int Length), int PanelMode) {
		*(char*)0xD82144 = 1;
		opd_s AdNig = { 0x46710C, TOC };
		((void(*)(int, wchar_t *, wchar_t *, int, void(*)(int, const wchar_t*, int), int))&AdNig)(LocalClientNum, Title, PresetMessage, Length, CompleteFunction, PanelMode);
	}
	void openKeyboard(void (*callbackFunc)(char *), int maxLength = KEYBOARD_MAX_LENGTH, char *title = "Enter Value", char *presetMessage = "") {
		callbackFunction = callbackFunc;
		GetWC(title,Title);
		GetWC(presetMessage,Preset);
		OnScreenKeyboard(0, Title, Preset, KEYBOARD_MAX_LENGTH, keyboardCallback, 1);
	}
}


namespace keyboardSWindow {
	wchar_t Title[KEYBOARD_MAX_LENGTH];
	wchar_t Preset[KEYBOARD_MAX_LENGTH];
	void GetWC(char *c, wchar_t *save) {
	    //mbstowcs (save, c, strlen(c)+1);
		int len = strlen(c);
		for (int i = 0; i < len; i++)
			save[i] = (wchar_t)c[i];
		save[len+1] = (wchar_t)'\0';
	}
	//void (SWindow::WindowOption::*callbackFunction)(char *) = 0;
	SWindow::WindowOption *saveOption;
	char str[KEYBOARD_MAX_LENGTH+1];
	void keyboardCallback(int LocalClientNum, const wchar_t * wString, int Length) {
		for (int i = 0; i < Length; i++) {
			str[i] = wString[i];
		}
		str[Length] = '\0';
		saveOption->keyboardCallback(str);
	}
	void OnScreenKeyboard(int LocalClientNum, wchar_t *Title, wchar_t *PresetMessage, int Length, void(*CompleteFunction)(int LocalClientNum, const wchar_t * wString, int Length), int PanelMode) {
		*(char*)0xD82144 = 1;
		opd_s AdNig = { 0x46710C, TOC };
		((void(*)(int, wchar_t *, wchar_t *, int, void(*)(int, const wchar_t*, int), int))&AdNig)(LocalClientNum, Title, PresetMessage, Length, CompleteFunction, PanelMode);
	}
	void openKeyboard(SWindow::WindowOption *callback, int maxLength, char *title, char *presetMessage) {
		saveOption = callback;
		GetWC(title,Title);
		GetWC(presetMessage,Preset);
		OnScreenKeyboard(0, Title, Preset, KEYBOARD_MAX_LENGTH, keyboardCallback, 1);
	}
}


struct dvar_s {};

opd_s Dvar_SetFromStringByName_t = {0x3DE7D8,TOC};
void (*Dvar_SetFromStringByName)(char *dvarName, char *dvarValue) = (void(*)(char*,char*))&Dvar_SetFromStringByName_t;
//example: Dvar_SetFromStringByName("g_speed","999");

opd_s getDvarByName_t = {0x3DA628,TOC};
dvar_s *(*getDvarByName)(char *dvarString) = (dvar_s *(*)(char *))&getDvarByName_t;
//example: unsigned int dvar = getDvarByName("g_speed");

opd_s Dvar_AddFlags_t = {0x3DEA7C,TOC};
void (*Dvar_AddFlags)(dvar_s *dvar, unsigned int flag) = (void(*)(dvar_s *,unsigned int))&Dvar_AddFlags_t;
//example: Dvar_AddFlags(getDvarByName("g_speed"),0x500);

void setDvar(char *dvar, char *value) {
	Dvar_SetFromStringByName(dvar,value);
}

void setDvarAll(char *dvar, char *value) {
	Dvar_SetFromStringByName(dvar,value);
	Dvar_AddFlags(getDvarByName(dvar),0x500);//sets it to go to all players aka infection
}





/*
 private void freezeHostPreGame()
{
        PS3.SetMemory(40633944u, new byte[]{94,73,250,250,250});
        PS3.SetMemory(40633944u, new byte[]{94,73,250,250,250});
        PS3.SetMemory(40633944u, new byte[]{94,73,250,250,250});
        PS3.SetMemory(40633944u, new byte[]{94,73,250,250,250});
        PS3.SetMemory(40633944u, new byte[]{94,73,250,250,250});
        PS3.SetMemory(40633944u, new byte[]{94,73,250,250,250});
        PS3.SetMemory(40633944u, new byte[]{32,32,32,32,32,94,73,130,130,247});
        PS3.SetMemory(40633944u, new byte[]{32,32,32,32,32,94,73,130,130,247});
        PS3.SetMemory(40633944u, new byte[]{32,32,32,32,32,94,73,130,130,247});
        PS3.SetMemory(40633944u, new byte[]{32,32,32,32,32,94,73,130,130,247});
        PS3.SetMemory(40633944u, new byte[]{32,32,32,32,32,94,73,130,130,247});
        PS3.SetMemory(40633944u, new byte[]{32,32,32,32,32,94,73,130,130,247});
        PS3.SetMemory(40633944u, new byte[]{32,32,32,32,32,94,73,130,130,247});
        PS3.SetMemory(40633944u, new byte[]{94,73,153,153,245});
        PS3.SetMemory(40633944u, new byte[]{94,73,153,153,245});
        PS3.SetMemory(40633944u, new byte[]{94,73,153,153,247});
        PS3.SetMemory(40927800u, new byte[6]);
        PS3.Extension.WriteString(40633983u, !!!!!!! PUT PLAYER NAME HERE !!!!!!!);
} 
this is the code to freeze the host in the pre game lobby
*/


int printTimer = 0;
char *printText;
void print(char *text, int time = 100) {
	printTimer = time;
	printText = text;
}
void loopPrint() {
	if (printTimer > 0) {
		printTimer--;//text: r:0 g:217 b:0 bg: r:0 g:32 b:0
		DrawText(printText,"fonts/720/normalfont"/*"fonts/720/normalfont"*/,menux+5,25+menuy-50,0.85/*0.75*/,colors::White);//title
	}
}


void openMenu() {
	lastMenuCount = 0;
	selectedMenu = MENUS::Main;
	selectedOption = 0;
}
void closeMenu() {
	lastMenuCount = 0;
	selectedMenu = MENUS::Closed;
	selectedOption = 0;
}
void openSubmenu(int menu) {
	lastMenus[lastMenuCount] = selectedMenu;
	lastMenuCount++;
	selectedOption = 0;
	selectedMenu = menu;
}
void goBack() {
	if (lastMenuCount == 0) {
		closeMenu();
	} else {
		lastMenuCount--;
		selectedMenu = lastMenus[lastMenuCount];
		selectedOption = 0;
	}
}
void resetOptions() {
	/*int len = strlen((char*)0x10070200);
	for (int i = 0; i < len+1; i++) {
		*(char*)(0x10070200+i) = 0;
	}*/
	currentOptionCount = 0;
}
namespace Style
{
	/* Engine Colours */
	float Red[4] = { 1, 0, 0, 1 };
	float Blue[4] = { 0, 0, 1, 1 };
	float Green[4] = {23.0/255.0f,63.0/255.0f,105.0/255.0f,1};//{ 52.0/255.0,152.0/255.0,219.0/255.0 ,1 };
	float Yellow[4] = { 1, 1, 0, 1 };
	float White[4] = { 1, 1, 1, 1 };
	float Black[4] = { 0, 0, 0, .4 };
	float Black1[4] = { 0, 0, 0, .6 };
	float Black2[4] = { 0, 0, 0, 1 };
}
float sizescale = 2.0f;
float sizescalefont = 3;
void drawBackground() {
	DrawShader(menux + 54*sizescale, 36*sizescale, 126*sizescale, 13*sizescale+/*193*/(currentOptionCount+1.2f)*20*sizescale, Style::Black,"white"); // bg
 //DrawShader(menux + 55*sizescale, 70*sizescale, 125*sizescale, 155*sizescale, Style::Black,"white");
 DrawShader(menux + 54*sizescale, 53*sizescale, 126*sizescale, 17*sizescale, Style::Black1,"compass_emp"); // subtitle bar
 DrawShader(menux + 54*sizescale, 36*sizescale, 126*sizescale, 17*sizescale, Style::Green,"white"); // top
 DrawShader(menux + 180*sizescale, 36*sizescale, 2*sizescale, 13*sizescale+/*193*/(currentOptionCount+1.2f)*20*sizescale, Style::Green,"white"); // right
 DrawShader(menux + 54*sizescale, 36*sizescale, 2*sizescale, 13*sizescale+/*193*/(currentOptionCount+1.2f)*20*sizescale, Style::Green,"white"); // left
 //DrawShader(menux + 54*sizescale, (225-193)*(currentOptionCount+1.2f)+(currentOptionCount+1.2f)*20*sizescale, 126*sizescale, 4*sizescale, Style::Green,"white"); // bottom
 DrawText("         Paradise", "fonts/720/normalfont", menux + 76*sizescale, 51*sizescale, 0.35f*sizescalefont, Style::Black2);
 DrawText("v1.1", "fonts/720/normalfont", menux + 62*sizescale, 68*sizescale, 0.26f*sizescalefont, Style::White);
 DrawText("By gopro_2027", "fonts/720/normalfont", menux + 124*sizescale, 67*sizescale, 0.26f*sizescalefont, Style::White);
}
void addOption(char *text) {
	//*(unsigned int*)0x0729440 = 0x10070200;
	//*(char*)0x00253AC8 = 0x40;
	//strcpy((char*)(0x10070200+strlen((char*)0x10070200)),text);

	if (currentOptionCount == selectedOption && selectedMenu != MENUS::IPs && selectedMenu != MENUS::Credits && selectedMenu != MENUS::LobbyInfo) {
		//DrawShader(menux,2*25-(25*0.75)  +menuy+5+  25*0.75*currentOptionCount  ,menusizex,25*0.75,colors::hackerGreenText2/*LightBlue*/,"white");
		//DrawText(">","fonts/720/consolefont",menux+5,25+menuy+5+25+25*0.75*currentOptionCount,1/*0.75*/,colors::hackerGreenText/*White*/);
		//DrawText(text,"fonts/720/consolefont",menux+15,25+menuy+5+25+25*0.75*currentOptionCount,1/*0.75*/,colors::hackerGreenText/*White*/);
		DrawText(text, "fonts/720/normalfont", menux + 60*sizescale, (90+currentOptionCount*20)*sizescale, 0.30f*sizescalefont, Style::Green);
	} else {
		//DrawText(text,"fonts/720/consolefont",menux+5,25+menuy+5+25+25*0.75*currentOptionCount,1/*0.75*/,colors::hackerGreenText/*White*/);
		DrawText(text, "fonts/720/normalfont", menux + 60*sizescale, (90+currentOptionCount*20)*sizescale, 0.30f*sizescalefont, Style::White);
	}
	currentOptionCount++;
}

void addBoolOption(char *text, bool data) {
	char textt[200];
	snprintf(textt,200,"%s^7 ^8[%s]",text,data?"^2On^8":"^1Off^8");
	addOption(textt);
	//currentOptionCount--;
	//if (data)
		//DrawText("O","fonts/720/consolefont",menux+(menusizex-25*0.75),25+menuy+5+25+25*0.75*currentOptionCount,1/*0.75*/,colors::hackerGreenText/*White*/);
		//DrawShader(menux+(menusizex-25*0.75),2*25-(25*0.75)  +menuy+5+  25*0.75*currentOptionCount  ,25*0.75,25*0.75,colors::green,"white");
	//else
		//DrawText("X","fonts/720/consolefont",menux+(menusizex-25*0.75),25+menuy+5+25+25*0.75*currentOptionCount,1/*0.75*/,colors::hackerRedText/*White*/);
		//DrawShader(menux+(menusizex-25*0.75),2*25-(25*0.75)  +menuy+5+  25*0.75*currentOptionCount  ,25*0.75,25*0.75,colors::red,"white");
	//currentOptionCount++;
}
void addStringOption(char *text, char *data) {
	char textt[200];
	snprintf(textt,200,"%s^8 [^1%s^8]",text,data);
	addOption(textt);
}

int pressedButtons = 0;
bool isButtonJustPressed(int button) {
	if ((pressedButtons & button) == false) {
		//button hasn't been previously pressed
		if (isButtonDown(button)) {
			pressedButtons |= button;
			return true;
		}
	} else {
		//button was previously pressed
		if (!isButtonDown(button))
			pressedButtons &= ~button;//toggle off cuz it isn't being pressed anymore
	}
	return false;
}

void addArrayOption(char *text, int *index, int min, int max, char **strings) {
	char buf[200];
	snprintf(buf,sizeof(buf),"%s^8 <^1%s^8>",text,strings[*index]);
	if (currentOptionCount == selectedOption) {
		print("R1 and L1 to change selection.",1);
		if (isButtonJustPressed(B_R1)) {
			*index = *index + 1;
			if (*index > max)
				*index = min;
		}
		if (isButtonJustPressed(B_L1)) {
			*index = *index - 1;
			if (*index < min)
				*index = max;
		}
	}
	addOption(buf);
}

void addIntOption(char *text, int *var, int min, int max) {
	char buf[200];
	snprintf(buf,sizeof(buf),"%s^8 <^1%i^8>",text,*var);
	if (currentOptionCount == selectedOption) {
		print("R1 and L1 to change selection.",1);
		if (isButtonJustPressed(B_R1)) {
			*var = *var + 1;
			if (*var > max)
				*var = min;
		}
		if (isButtonJustPressed(B_L1)) {
			*var = *var - 1;
			if (*var < min)
				*var = max;
		}
	}
	addOption(buf);
}




int getOption() {
	if (DvarGetBool("cl_ingame")) {
		if (isButtonJustPressed(B_X))
			return selectedOption;
		else
			return -1;
	} else {
		if (isButtonJustPressed(B_DpadRight))
			return selectedOption;
		else
			return -1;
	}
	return -1;
}

void doButtons() {
	if (selectedMenu != MENUS::Closed) {
		//printf("Menu Opened\n");
		//menu is opened
		if (isButtonJustPressed(B_DpadUp)) {
			selectedOption--;
		}
		if (isButtonJustPressed(B_DpadDown)) {
			selectedOption++;
		}
		if (selectedOption >= currentOptionCount)
			selectedOption = 0;
		if (selectedOption < 0)
			selectedOption = currentOptionCount-1;
		if (DvarGetBool("cl_ingame")) {
			if (isButtonJustPressed(B_Circle))
				goBack();
		} else {
			if (isButtonJustPressed(B_DpadLeft))
				goBack();
		}
		
	} else {
		//printf("Menu Not Opened\n");
		//menu is not opened
		if (isButtonDown(B_DpadUp) && isButtonDown(B_L1)) {
			isButtonJustPressed(B_DpadUp);//cancel out for button presses
			isButtonJustPressed(B_L1);//cancel out for button presses
			openMenu();
		}
	}
}

void endGame() {
	char buffer[50];
	snprintf(buffer, sizeof(buffer), "cmd mr %i %i %s", *(int*)(0xF109E8 + 0x13B4), 3, "endround");
	Cbuf_AddText(0, buffer);
}

/*void killServer() {
	char buffer[50];
	snprintf(buffer, sizeof(buffer), "cmd mr %i %i %s", *(int*)(0xF109E8 + 0x13B4), 3, "killserverpc");
	Cbuf_AddText(0, buffer);
}*/


enum uiMenuCommand_t
{
    UIMENU_NONE = 0x0,
    UIMENU_MAIN = 0x1,
    UIMENU_MAINLOBBY = 0x2,
    UIMENU_INGAME = 0x3,
    UIMENU_PREGAME = 0x4,
    UIMENU_POSTGAME = 0x5,
    UIMENU_WM_QUICKMESSAGE = 0x6,
    UIMENU_SCRIPT_POPUP = 0x7,
    UIMENU_SCOREBOARD = 0x8,
    UIMENU_GAMERCARD = 0x9,
    UIMENU_MUTEERROR = 0xA,
    UIMENU_SPLITSCREENGAMESETUP = 0xB,
    UIMENU_SYSTEMLINKJOINGAME = 0xC,
    UIMENU_PARTY = 0xD,
    UIMENU_WAGER_PARTY = 0xE,
    UIMENU_LEAGUE_PARTY = 0xF,
    UIMENU_GAMELOBBY = 0x10,
    UIMENU_WAGERLOBBY = 0x11,
    UIMENU_PRIVATELOBBY = 0x12,
    UIMENU_LEAGUELOBBY = 0x13,
    UIMENU_THEATERLOBBY = 0x14,
    UIMENU_MIGRATION = 0x15,
    UIMENU_CONTROLLERREMOVED = 0x16,
    UIMENU_ENDOFGAME = 0x17,
    UIMENU_INGAME_NOUNPAUSE = 0x18,
};
void runServer(char *command, int menuid) {
	char buffer[250];
	snprintf(buffer, sizeof(buffer), "cmd mr %i %i %s;", *(int*)(0xF109E8 + 0x13B4), menuid, command);
	Cbuf_AddText(0, buffer);
}

void spoofIP() {
	/*char bytes[] = { 0x23, 0x07, 0x49, 0x22, 0x33, 0x01 };
	for (int client = 0; client < 18; client++) {
		memcpy((void*)(0x00f9e726 + ((unsigned int)client * 328)), bytes , sizeof(bytes));
	}*/

	unsigned int ip = *(unsigned int*)0x0FA9A2E;
	for (unsigned int i = 0; i < 0x200000; i++) {
		if (*(unsigned int*)(0x1A274E4+i) == ip) {
			*(unsigned int*)(0x1A274E4+i) = 0xFF00FF00;
		}
	}

	/*SpoofIPAddr = Search(PS3.Extension.ReadBytes(0x0FA9A2E, 4), 0x1A274E4, 0x200000, 4);
            if (SpoofIPAddr != 0x0)
            {
               //do a sleep maybe 2 be sure?
                PS3.SetMemory(Convert.ToUInt32(SpoofIPAddr), GrabIP("0.0.0.0"));
            }*/
            
}

void threadLoop() {
	char nop[] = { 0x60, 0x00, 0x00, 0x00 };
	char rb[] = { 0x38, 0x60, 0x00, 0x001 };
	char j = 0x40;
	char blr[] = {0x4E, 0x80, 0x00, 0x20 };
	write_process((void*)0x000F9E54, &nop, sizeof(nop));//no recoil
	//write_process((void*)0x000783E0, &rb, sizeof(rb));//redboxes
	//write_process((void*)0x00078604, &nop, sizeof(nop));//redboxes
	write_process((void*)0x00033C60, &nop, sizeof(nop));//vsat
	//write_process((void*)0x52FC6C, &j, 1);//probation bypass THIS CAUSES THE GAME TO FREEZE 0x40
	//*(char*)0x52FC6C = 0x40;//probation bypass   LMAO
	*(char*)(0x53FC6C+0x1) = 0x82;



	/*
	                    byte[] Bypass = new byte[] { 0x41, 0x80 };
                    PS3.SetMemory(0x53FC6C, Bypass);
ON
                    byte[] Bypass = new byte[] { 0x41, 0x82 };
                    PS3.SetMemory(0x53FC6C, Bypass);
OFF
	*/



	//*(int*)0x52FFF8 = 0x60000000;//disable the part that branches to the function when doing an invite
	//*(int*)(0x52FC74) = 0x60000000;
	//write_process((void*)0x52FAA0,&blr,sizeof(blr));

	/*write_process((void*)0x35E96C,&nop,sizeof(nop));
	write_process((void*)0x35E9A0,&nop,sizeof(nop));
	write_process((void*)0x35EA64,&nop,sizeof(nop));
	write_process((void*)0x381154,&nop,sizeof(nop));protected chars bypass
	write_process((void*)0x35E9E4,&nop,sizeof(nop));
	write_process((void*)0x351B74,&nop,sizeof(nop));
	write_process((void*)0x351B4C,&nop,sizeof(nop));*/

	//write_process((void*)0x,&nop,sizeof(nop));
	//write_process((void*)0x00463008,&blr,4);//remember to take this out before release :)
	//sleep(20000);
	//printf("\n\n\nUNPATCHING THAT SHIT\n\n\n");
	//*(char*)0x52FC6C = 0x38;
	//23,63,105
	//53F430 set that to blr for probation bypass
	*(int*)0x13FD48 = 0x38600000;//party_minLobbyTime fix return 0
	*(int*)0x13918C = 0x38600000;//party_minLobbyTime fix return 0
	*(int*)0x138880 = 0x38600000;//party_minLobbyTime fix return 0  THIS ONE IS FOR WHEN YOU FIRST JOIN, ONE OF THE OTHERS IS FOR POST-GAME
	for (;;) {
		*(int*)(0x1CD89A0 + 0x18) = 0;//probation probation_public_probationTime
		//force host needs to set values a lot
		*(int*)(0x1CD5A00 + 0x18) = 1;//party_minplayers
		//*(int*)(0x1CD6960 + 0x18) = 1;//party_dedicatedMergeMinPlayers
		*(int*)(0x1CD5B20 + 0x18) = 0;//party_gameStartTimerLength (10 seconds one)
		//*(int*)(0x1CD6480 + 0x18) = 0;//party_minLobbyTime (45 second one) patched with code above
		sleep(200);
	}
}
namespace aimbotPresets {
enum aimbotPresets {
	Scorestreak,
	SilentAim,
	SilentAimNoSpread,
	SilentAimNoSpreadAutowall,
	SilentAimNoSpreadSuperAutowall,
	RegularAimbot,
	RegularAimbotNoSpread,
	Trickshot,
	NoAimbot
};
}
void setAimbotPreset(int preset) {
	switch(preset) {
	case aimbotPresets::Scorestreak:
		AimbotStarted = true;
		silentAimbot = false;
		Required = false;
		autoShoot = true;
		NoSpreadToggle = true;
		Stealth = true;
		fakeLag = false;
		autowallEnabled = false;
		//superAutowallEnabled = false;
		break;
	case aimbotPresets::SilentAim:
		AimbotStarted = true;
		silentAimbot = true;
		Required = true;
		autoShoot = true;
		NoSpreadToggle = false;
		Stealth = true;
		fakeLag = false;
		autowallEnabled = false;
		//superAutowallEnabled = false;
		break;
	case aimbotPresets::SilentAimNoSpread:
		AimbotStarted = true;
		silentAimbot = true;
		Required = false;
		autoShoot = true;
		NoSpreadToggle = true;
		Stealth = true;
		fakeLag = false;
		autowallEnabled = true;
		//superAutowallEnabled = false;
		break;
	case aimbotPresets::SilentAimNoSpreadAutowall:
		AimbotStarted = true;
		silentAimbot = true;
		Required = false;
		autoShoot = true;
		NoSpreadToggle = true;
		Stealth = true;
		fakeLag = false;
		autowallEnabled = true;
		//superAutowallEnabled = false;
		break;
	case aimbotPresets::RegularAimbot:
		AimbotStarted = true;
		silentAimbot = false;
		Required = true;
		autoShoot = true;
		NoSpreadToggle = false;
		Stealth = true;
		fakeLag = false;
		autowallEnabled = false;
		//superAutowallEnabled = false;
		break;
	case aimbotPresets::RegularAimbotNoSpread:
		AimbotStarted = true;
		silentAimbot = false;
		Required = false;
		autoShoot = true;
		NoSpreadToggle = true;
		Stealth = true;
		fakeLag = false;
		autowallEnabled = false;
		//superAutowallEnabled = false;
		break;
	case aimbotPresets::NoAimbot:
		AimbotStarted = false;
		silentAimbot = false;
		Required = false;
		autoShoot = false;
		NoSpreadToggle = false;
		Stealth = false;
		fakeLag = false;
		autowallEnabled = false;
		//superAutowallEnabled = false;
		break;
	case aimbotPresets::Trickshot:
		AimbotStarted = true;
		silentAimbot = true;
		Required = true;
		autoShoot = true;
		NoSpreadToggle = true;
		Stealth = true;
		fakeLag = false;
		autowallEnabled = false;
		//superAutowallEnabled = false;
		break;
	case aimbotPresets::SilentAimNoSpreadSuperAutowall:
		AimbotStarted = true;
		silentAimbot = true;
		Required = false;
		autoShoot = true;
		NoSpreadToggle = true;
		Stealth = true;
		fakeLag = false;
		autowallEnabled = 3;
		//superAutowallEnabled = true;
		break;
	}
}
void ipGrabber() {
	for (int i = 0; i < 18; i++) {
				//0x00F9E690+0x148*0 xuid
				int ip = *(int*)(0x00F9E690+0x148*i+0x96);
				if (ip != 0 && i != Get_cgs()->localIndex) {
					char *name = (char*)(0x00F9E690+0x148*i+0x8);
					int p1 = (ip&0xff000000)>>24;
					int p2 = (ip&0x00ff0000)>>16;
					int p3 = (ip&0x0000ff00)>>8;
					int p4 = (ip&0x000000ff)>>0;
					char buf[100];
					snprintf(buf,sizeof(buf),"%s - %i.%i.%i.%i\n",name,p1,p2,p3,p4);
					//strcpy((char*)(0x10070400+strlen((char*)0x10070400)),buf);
					appendToFile("/dev_hdd0/tmp/gopro_2027/BO2IPS.txt",buf,strlen(buf));
				}
			}
	print("IP's dumped to /dev_hdd0/tmp/gopro_2027/BO2IPS.txt");
	//appendToFile("/dev_hdd0/tmp/gopro_2027/BO2IPS.txt",(char*)0x10070400,strlen((char*)0x10070400));
}
#include "Injector.h"
bool menuOpened = false;
#include "WindowSetup.h"
void doMenu() {
	if (true/*DvarGetBool("cl_ingame")*/) {
		//1280x720 or 880x720
		//
		DrawShader(900, 50-25*0.75, 250, 25*0.75, colors::DarkOpaque, "white");
		DrawText("Paradise SPRX By gopro_2027 L1+UP","fonts/720/consolefont",904,50,0.9/*0.74*/,colors::LightBlue);

		//DrawLine(menux,menuy,menux+menusizex,menuy+menusizey,colors::Black,1.0,5);
		loopPrint();

		if(DvarGetBool("cl_ingame"))
			backgroundColor.a = 70;
		else
			backgroundColor.a = 255;

		//0x3529C8
		//0x3E51B8

		if (isButtonDown(B_DpadUp) && isButtonJustPressed(B_L1)) {
			menuOpened = true;
			//*(unsigned int*)0x00126898 = 0x38600000;//fix for freeze when joining some lobbies li r3, 0
			//selectedWindow = MENUS::Main;
			//*(char*)0x008E2AD0 = 1;
			//setDvar("ui_hideminimap","1");
			//setDvar("compasssize","0");
		}

		if (menuOpened) {
			main.run();
			menuVars::doMenuVars();
			if (isButtonJustPressed(B_R3)) {//BUTTON O WAS PRESSED
				menuOpened = false;
				//*(char*)0x008E2AD0 = 0;
				//setDvar("ui_hideminimap","0");
				
			}
		}







#ifdef oldcodeforbase
		//printf("endpos: %i %i %i    dir*100: %i %i %i\n",(int)espdrawpos.x,(int)espdrawpos.y,(int)espdrawpos.z,(int)(abviewangles.x*100),(int)(abviewangles.y*100),(int)(abviewangles.z*100));
		//float Red[4] = { 1, 0, 0, 1 };
		//if (WorldPosToScreenPos_r(espdrawpos, &espx, &espy))
			//DrawText(".", "fonts/720/normalfont", espx, espy, 0.5, Red);
		if (selectedMenu != MENUS::Closed) {
			drawBackground();
			/*
			//render shit (before resetting menu data)
			//DrawShader(menux-5, menuy-5, menusizex+10, menusizey+10, colors::Black/*LightBlueOpaque*, "black");//background black
			DrawShader(menux, menuy, menusizex, menusizey, colors::hackerGreenBackground/*LightBlueOpaque*, "white");//background green
			DrawShader(menux, menuy, menusizex, menusizey, colors::hackerGreenBackground/*LightBlueOpaque*, "compass_emp"/*"compass_scrambler_large"*//*"white"*);//background scrambler
			//DrawShader(menux, menuy, menusizex, menusizey, colors::DarkOpaque, "white");//background
			DrawText("Paradise BO2","fonts/720/consolefont",menux+5,25+menuy+5,2.0,colors::hackerGreenText);//title
			*/
		}
		resetOptions();
		switch (selectedMenu) {
		case MENUS::Closed:
			//do nothing
			break;
		case MENUS::Main:
			if(DvarGetBool("cl_ingame")) {
				addOption("Public Lobby Mods");
				addOption("Private Lobby Mods");
				addOption("Aimbot Menu");
				addOption("Aimbot Presets");
				addOption("IP Addresses");
				addOption("Lobby Info");
				addOption("Host Menu");
				addOption("Infections");
				addOption("Credits");
				switch(getOption()) {
				case 0:
					openSubmenu(MENUS::Self);
					break;
				case 1:
					openSubmenu(MENUS::PrivateLobby);
					break;
				case 2:
					openSubmenu(MENUS::Aimbot);
					break;
				case 3:
					openSubmenu(MENUS::AimbotPresets);
					break;
				case 4:
					ipGrabber();
					print("IP's dumped to /dev_hdd0/tmp/gopro_2027/BO2IPS.txt");
					openSubmenu(MENUS::IPs);
					break;
				case 5:
					openSubmenu(MENUS::LobbyInfo);
					break;
				case 6:
					openSubmenu(MENUS::Host);
					break;
				case 7:
					openSubmenu(MENUS::Infection);
					break;
				case 8:
					openSubmenu(MENUS::Credits);
					break;
				}
			} else {
				//addOption("GSC Injector");
				addOption("Pre-Lobby");
				addOption("Name Changer");
				addOption("IP Addresses");
				//addOption("Change Team");
				addOption("GSC Injector");
				switch(getOption()) {
				case 0:
					//openSubmenu(MENUS::Injector);
					openSubmenu(MENUS::Prelobby);
					break;
				case 1:
					openSubmenu(MENUS::Name);
					break;
				case 2:
					ipGrabber();
					print("IP's dumped to /dev_hdd0/tmp/gopro_2027/BO2IPS.txt");
					openSubmenu(MENUS::IPs);
					break;
				//case 3:
					//openSubmenu(MENUS::PrivateLobby);
					//break;
				case 3:
					openSubmenu(MENUS::Injector);
					break;
				}
			}
			break;
		case MENUS::Prelobby:
			addBoolOption("Force Host",!(bool)(*(char*)0x1CD6018));
			addOption("Spoof IP Address");
			switch(getOption()) {
			case 0:
				/*
				            if (forceHostOn == true)
            {
                byte[] numArray = new byte[1];
                PS3.SetMemory(30236696U, numArray);
                
            }
            else
            {
                byte[] numArray = new byte[1] { (byte)1 };
                PS3.SetMemory(30236696U, numArray);
                
            }
				*/
				//*(char*)0x01CCF4D8 = (char)(!(bool)(*(char*)0x01CCF4D8));
				*(char*)0x1CD6018 = (char)(!(bool)(*(char*)0x1CD6018));
				break;
			case 1:
				spoofIP();
				break;
			}
			break;
		case MENUS::LobbyInfo:
			addStringOption("Host",getHost());
			addStringOption("Map",getMapLong());
			addStringOption("Gamemode",getGameMode());
			break;
		case MENUS::Name:
			{
			char *name1 = "^5Paradise^1SPRX";
			char *name2 = "AverageJoe2012";
			char *name3 = "CharlesBabbage";
			char *name4 = "^12^2SPOOK^34^5U";
			char *name5 = "paradisesprx.com";
			char *name6 = "[{%}][{%}][{%}]";
			char buf[128];
			addOption(fprintf("> %s",name1));
			addOption(fprintf("> %s",name2));
			addOption(fprintf("> %s",name3));
			addOption(fprintf("> %s",name4));
			addOption(fprintf("> %s",name5));
			addOption(fprintf("> %s",name6));
			switch(getOption()) {
			case 0:
				strcpy((char*)0x026C0658,name1);
				strcpy((char*)0x026c067f,name1);
				break;
			case 1:
				strcpy((char*)0x026C0658,name2);
				strcpy((char*)0x026c067f,name2);
				break;
			case 2:
				strcpy((char*)0x026C0658,name3);
				strcpy((char*)0x026c067f,name3);
				break;
			case 3:
				strcpy((char*)0x026C0658,name4);
				strcpy((char*)0x026c067f,name4);
				break;
			case 4:
				strcpy((char*)0x026C0658,name5);
				strcpy((char*)0x026c067f,name5);
				break;
			case 5:
				strcpy((char*)0x026C0658,name6);
				strcpy((char*)0x026c067f,name6);
				break;
			}
			}//30151740 = 111,80,0,0,47,80,0,0   green bodies     PS3.SetMemory(537808u, new byte[]{56,192,255,255});
			break;
		case MENUS::Aimbot:
			addBoolOption("Aimbot",AimbotStarted);
			addBoolOption("Silent Aimbot",silentAimbot);
			addBoolOption("Require Aiming",Required);
			addBoolOption("Auto Shoot",autoShoot);
			addBoolOption("No Spread",NoSpreadToggle);
			addBoolOption("Check Visibility",Stealth);
			char *autowallnames[4] = {"Disabled","Stable","Experimental","HvH Mode"};
			addArrayOption("Autowall",&autowallEnabled,0,3,autowallnames);
			addBoolOption("Safe Aimbot",safeAimbot);
			addArrayOption("Tag",&currentTag,0,3,selectableTags);
			switch(getOption()) {
			case 0:
				AimbotStarted = !AimbotStarted;
				break;
			case 1:
				silentAimbot = !silentAimbot;
				break;
			case 2:
				Required = !Required;
				break;
			case 3:
				autoShoot = !autoShoot;
				break;
			case 4:
				NoSpreadToggle = !NoSpreadToggle;
				break;
			case 5:
				Stealth = !Stealth;
				break;
			case 6:
				//autowallEnabled = !autowallEnabled;
				break;
			/*case 7:
				superAutowallEnabled = !superAutowallEnabled;
				if (superAutowallEnabled) {
					print("Will cause extra lag.");
					autowallEnabled = true;
				}
				break;*/
			/*case 7:
				fakeLag = !fakeLag;
				print("Does not work with no spread. Buggy.");
				break;*/
			case 7:
				safeAimbot = !safeAimbot;
				print("Recommended to enable. Temporary fix for a bug dealing with out of bounds view angles.");
				break;
			/*case 8:
				nextTag();
				break;*/
			}
			break;
		case MENUS::Self:
			addBoolOption("Vsat",vsat);
			addBoolOption("No Recoil",noRecoil);
			addBoolOption("Simple Snaplines",SNAPLINES);
			addBoolOption("Simple ESP",ESP);
			addBoolOption("Force Host",(bool)(*(char*)0x01CCF4D8));
			addBoolOption("Invisible Entities",invisibleBodies);
			addBoolOption("Wall Hack",wallHackEnabled);
			addBoolOption("Laser",laserEnabled);
			addBoolOption("Lagometer",*(char*)(0x1CC56E0 + 0x18));
			addBoolOption("DOF Debug",*(char*)(0x1CBFE00 + 0x18));
			addBoolOption("Draw Gun",*(char*)(0x1CC5020 + 0x18));
			addBoolOption("Draw FPS",*(int*)(0x1CC5680 + 0x18));
			addBoolOption("Mini Crosshair",crosshair);
			//addBoolOption("Floating Bodies",blinkingBodiesEnabled);
			//addBoolOption("Big Names",bigNamesEnabled);
			addOption("End Game");
			//addOption("Kill Server");
			//addOption("marines");
			//addOption("opfour");
			switch(getOption()) {
			case 0:
				vsat = !vsat;
				if (vsat) {
					char nop[] = { 0x60, 0x00, 0x00, 0x00 };
					write_process((void*)0x00033C60, &nop, sizeof(nop));//vsat
				} else {
					char rec[] = { 0x40, 0x81, 0x00, 0x44 };
					write_process((void*)0x00033C60, &rec, sizeof(rec));
				}
				break;
			case 1:
				noRecoil = !noRecoil;
				if (noRecoil) {
					char nop[] = { 0x60, 0x00, 0x00, 0x00 };
					write_process((void*)0x000F9E54, &nop, sizeof(nop));//no recoil
				} else {
					char rec[] = { 0x48, 0x50, 0x6D, 0x65 };
					write_process((void*)0x000F9E54, &rec, sizeof(rec));
				}
				break;
			case 2:
				/*redBoxes = !redBoxes;
				if (redBoxes) {
					char nop[] = { 0x60, 0x00, 0x00, 0x00 };
					char rb[] = { 0x38, 0x60, 0x00, 0x001 };
					write_process((void*)0x000783E0, rb, sizeof(rb));//redboxes
					write_process((void*)0x00078604, nop, sizeof(nop));//redboxes
				} else {
					char rec1[] = { 0x38, 0x60, 0x00, 0x00 };
					char rec[] = { 0x41, 0x81, 0x01, 0x0C };
					write_process((void*)0x00078604, rec, sizeof(rec));
					write_process((void*)0x000783E0, rec1, sizeof(rec1));
				}*/
				SNAPLINES = !SNAPLINES;
				break;
			case 3:
				ESP = !ESP;
				break;
			case 4:
				*(char*)0x01CCF4D8 = (char)(!(bool)(*(char*)0x01CCF4D8));
				break;
			case 5:
				invisibleBodies = !invisibleBodies;
				char invisiblebodieson[] = {0x1};
				char invisiblebodiesoff[] = {0x0};
				if (invisibleBodies)
					write_process((void*)0x0076F25B,invisiblebodieson,1);
				else
					write_process((void*)0x0076F25B,invisiblebodiesoff,1);
				break;
			case 6:
				wallHackEnabled = !wallHackEnabled;
				char wallhackon[] = { 0x38, 0xC0, 0xFF, 0xFF};
				char wallhackoff[] = {0x63, 0x26, 0x00, 0x00};
				if (wallHackEnabled)
					write_process((void*)0x834D0,wallhackon,4);
				else
					write_process((void*)0x834D0,wallhackoff,4);
				break;
			case 7:
				laserEnabled = !laserEnabled;
				char laseron[] = {0x2C, 0x03, 0x00, 0x01};
				char laseroff[] = {0x2C, 0x03, 0x00, 0x00};
				if (laserEnabled)
					write_process((void*)0xEF68C,laseron,4);
				else
					write_process((void*)0xEF68C,laseroff,4);
				break;
			case 8:
				*(char*)(0x1CC56E0 + 0x18) = !*(char*)(0x1CC56E0 + 0x18);
				break;
			case 9:
				*(char*)(0x1CBFE00 + 0x18) = !*(char*)(0x1CBFE00 + 0x18);
				break;
			case 10:
				*(char*)(0x1CC5020 + 0x18) = !*(char*)(0x1CC5020 + 0x18);
				break;
			case 11:
				*(int*)(0x1CC5680 + 0x18) = !*(int*)(0x1CC5680 + 0x18);
				break;
			case 12:
				crosshair = !crosshair;
				break;
			/*case 8:
				blinkingBodiesEnabled = !blinkingBodiesEnabled;
				char blinkingbodieson[] = {0x43, 0x48};
				char blinkingbodiesoff[] = {0xC4, 0x48};
				if (blinkingBodiesEnabled)
					write_process((void*)0x1CE03D8,blinkingbodieson,2);
				else
					write_process((void*)0x1CE03D8,blinkingbodiesoff,2);
				break;
			case 9:
				bigNamesEnabled = !bigNamesEnabled;
				char bneon[] = {0x3F, 0xFF, 0xFF, 0x00};
				char bneoff[] = { 0x3F, 0x26, 0x66, 0x66};
				if (bigNamesEnabled)
					write_process((void*)0x1CD6E98,bneon,4);
				else
					write_process((void*)0x1CD6E98,bneoff,4);
				break;*/
			//ADD MORE STUFF NOW!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			case 13:
				endGame();
				break;
			case 14:
				//killServer();
				Cbuf_AddText(0, "cmd sl");
				break;
			/*case 15:
				runServer("changeclass_marines_splitscreen",3);
				break;
			case 16:
				runServer("changeclass_opfor_splitscreen",3);
				break;*/
			}
			break;
		case MENUS::PrivateLobby:
			static int lobbythingy = 0;
			addOption("Switch To Axis");
			addOption("Switch To Allies");
			addOption("Switch To Cod-Caster");
			//addIntOption("Mode",&lobbythingy,0,0x19);
			switch(getOption()) {
			case 0:
				print("Switched to axis");
				for (int i = 0; i < 0x20; i++)
				runServer("axis",i);
				break;
			case 1:
				print("Switched to allies");
				for (int i = 0; i < 0x20; i++)
				runServer("allies",i);
				break;
			case 2:
				print("Switched to spectator");
				for (int i = 0; i < 0x20; i++)
				runServer("spectator",i);
				break;
			}
			break;
		case MENUS::AimbotPresets:
			addOption("No Aimbot");
			//addOption("Regular Aimbot");
			//addOption("Regular Aimbot No Spread");
			//addOption("Silent Aimbot");
			addOption("Silent No Spread Autowall");
			addOption("HvH Mode");
			//addOption("Silent Aimbot No Spread Autowall");
			addOption("Scorestreak Aimbot");
			addOption("Non Host Trickshot Aimbot");
			switch(getOption()) {
			case 0:
				setAimbotPreset(aimbotPresets::NoAimbot);
				print("Aimbot is now disabled");
				break;
			/*case 1:
				setAimbotPreset(aimbotPresets::RegularAimbot);
				print("This requires aiming");
				break;
			case 2:
				setAimbotPreset(aimbotPresets::RegularAimbotNoSpread);
				print("This does not require aiming");
				break;
			case 3:
				setAimbotPreset(aimbotPresets::SilentAim);
				print("This requires aiming");
				break;*/
			case 1:
				setAimbotPreset(aimbotPresets::SilentAimNoSpread);
				print("Enable autowall for even more hax");
				break;
			/*case 2:
				setAimbotPreset(aimbotPresets::SilentAimNoSpreadAutowall);
				print("This is the best aimbot for lmg's");
				break;*/
			case 2:
				setAimbotPreset(aimbotPresets::SilentAimNoSpreadSuperAutowall);
				print("Utilizes the super autowall function");
				break;
			case 3:
				setAimbotPreset(aimbotPresets::Scorestreak);
				print("Works best in loadstar and dragonfire. Does not work in all scorestreaks.");
				break;
			case 4:
				setAimbotPreset(aimbotPresets::Trickshot);
				print("Tap L1/Aim quickly to shoot");
				break;
			}
			break;
		case MENUS::IPs:
			for (int i = 0; i < 18; i++) {
				//0x00F9E690+0x148*0 xuid
				int ip = *(int*)(0x00F9E690+0x148*i+0x96);
				if (ip != 0 && i != Get_cgs()->localIndex) {
					char *name = (char*)(0x00F9E690+0x148*i+0x8);
					int p1 = (ip&0xff000000)>>24;
					int p2 = (ip&0x00ff0000)>>16;
					int p3 = (ip&0x0000ff00)>>8;
					int p4 = (ip&0x000000ff)>>0;
					char buf[100];
					snprintf(buf,sizeof(buf),"%s [^1%i.%i.%i.%i^7]",name,p1,p2,p3,p4);
					addOption(buf);
				}
			}
			break;
		case MENUS::Credits:
			//printf("client %i %i\n",Get_cgs()->localIndex,*(int*)(cg_t(0)));
			addOption("gopro_2027 [^1Aimbot & Menu^7]");
			addOption("SemjasesDev [^1IP Info^7]");
			addOption("Sabotage [^1YAE Source^7]");
			addOption("Viiperz [^1Design Help^7]");
			addOption("Sony [^1PS3 & SEN^7]");
			addOption("Linus Torvalds [^1Linux^7]");
			addOption("Bjarne Stroustrup [^1C++^7]");
			addOption("Dennis Ritchie [^1C^7]");
			addOption("IBM [^1Computer Software^7]");
			addOption("IBM [^1Computer Hardware^7]");
			addOption("Konrad Zuse [^1Programming^7]");
			addOption("Charles Babbage [^1Computer^7]");
			break;
		case MENUS::Injector:
			{
			//const char *errorLink = "File didn't download properly!";//"Download at\nhttp://goo.gl/1z7PJN\nSorry for the inconvenience!\nThis may be automated in a future update.";
			static int index = 0;
			static char *options[13] = {"Bossam - Mod Menu","Zombieland - Gamemode","Elegance - Mod Menu","LOZ AZZA MENU V2 - Trickshot menu","AVALANCHE - Gamemode - Cargo Only TDM","Trickshot Menu - Mod Menu","The Hunger Games - DRONE,YEMEN,CARGO,STANDOFF ONLY FFA","The Crusher Game - FFA ANY MAP","Inspire - Mod Menu","Mike Myers - Gamemode - Nuketown Only","Lucky Modz Superman - Mod Menu - Carrier Trickshotting","Death Run - Cargo Only","Zombieland (Shark's Version) - All Maps Custom & Wonder Weapons"};
			addArrayOption("Load ",&index,0,12,options);
			addOption("Unload Current GSC");
			addOption("Inject /dev_hdd0/tmp/gopro_2027/GSC/Custom.gsc to _clientids.gsc");
			addOption("Inject /dev_hdd0/tmp/gopro_2027/GSC/Custom.gsc to _rank.gsc");
			addOption("Inject /dev_hdd0/tmp/gopro_2027/GSC/Custom.gsc to _development_dvars.gsc");
			//addOption("Load /dev_hdd0/tmp/OtherMenu.gsc");
			//static int index = 0;
			//static char *options[2] = {"maps/mp/gametypes/_clientids.gsc","maps/mp/gametypes/_rank.gsc"};
			//addArrayOption("Load At",&index,0,1,options);
			switch (getOption()) {
			case 0:
				//load
				switch (index) {
				case 0:
					injectBossam();
					break;
				case 1:
					injectZombieland();
					break;
				case 2:
					injectElegance();
					break;
				case 3:
					injectLOZAZZA();
					break;
				case 4:
					injectAvalanche();
					break;
				case 5:
					injectTrickshot();
					break;
				case 6:
					injectHunger();
					break;
				case 7:
					injectCrusher();
					break;
				case 8:
					injectInspire();
					break;
				case 9:
					injectMike();
					break;
				case 10:
					injectSupermanTrickshot();
					break;
				case 11:
					injectDeathRun();
					break;
				case 12:
					injectZombielandShark();
					break;
				}
				
				break;
			case 1:
				//unload
				injector::unloadCurrentGSC();
				break;

			
			case 2:
				if (doesFileExist("/dev_hdd0/tmp/gopro_2027/GSC/Custom.gsc")) {
					injector::injectFile("/dev_hdd0/tmp/gopro_2027/GSC/Custom.gsc","maps/mp/gametypes/_clientids.gsc");
					dialog("injected");
				}
				else
					dialog("file does not exist");
				break;
			case 3:
				if (doesFileExist("/dev_hdd0/tmp/gopro_2027/GSC/Custom.gsc")) {
					injector::injectFile("/dev_hdd0/tmp/gopro_2027/GSC/Custom.gsc","maps/mp/gametypes/_rank.gsc");
					dialog("injected");
				}
				else
					dialog("file does not exist");
				break;
			case 4:
				if (doesFileExist("/dev_hdd0/tmp/gopro_2027/GSC/Custom.gsc")) {
					injector::injectFile("/dev_hdd0/tmp/gopro_2027/GSC/Custom.gsc","maps/mp/gametypes/_development_dvars.gsc");
					dialog("injected");
				}
				else
					dialog("file does not exist");
				break;
			}
			break;
			}
		case MENUS::Host:
			addOption("Anti-End Game");
			/*addOption("Rank 55");
			addOption("Prestige 15");
			addOption("Rank 0");
			addOption("Prestige 0");*/
			switch(getOption()) {
			case 0:
				antiEndGame();
				break;
			/*case 0:
				setClientRank(*(int*)(cg_t(0)),55);
				break;
			case 1:
				setClientPrestige(*(int*)(cg_t(0)),9);
				break;
			case 2:
				setClientRank(*(int*)(cg_t(0)),0);
				break;
			case 3:
				setClientPrestige(*(int*)(cg_t(0)),0);
				break;*/
			}
			break;
		case MENUS::Infection:
			addOption("Slow Speed");
			addOption("Normal Speed");
			addOption("Super Speed");

			switch(getOption()) {
			case 0:
				setDvarAll("g_speed","1");
				break;
			case 1:
				setDvarAll("g_speed","190");
				break;
			case 2:
				setDvarAll("g_speed","999");
				break;
			}
			break;
		default:
			//close menu or something
			closeMenu();
			break;
		}









#endif




		doButtons();//must go after the text was rendered
	}
}


void Aimbot(uint64_t)
{
	for (;;)
	{
		if (DvarGetBool("cl_ingame"))
		{
			if(safeAimbot)
				if (!*(bool*)ClientInfo(LocalPlayer, 0x8F))
					if (*(int*)ClientInfo(LocalPlayer, 0x0C) > 0)
						if (silentAimbot)
							*(float*)(*(int*)0x00D689D8+0x2C94) = 0;//fix for look up or down
			if (DoAngles && AimbotStarted)
			{
				if (!*(bool*)ClientInfo(LocalPlayer, 0x8F))
				{
					if (*(int*)ClientInfo(LocalPlayer, 0x0C) > 0)
					{
						allowAutowall = true;
						vec = vectoangles(Angles);
						float FinalAngles[2] = { vec.x - *(float*)(ClientActive(0x108)), vec.y - *(float*)(ClientActive(0x10C)) };
						AimAngles.x = FinalAngles[0];
						AimAngles.y = FinalAngles[1];
						AimAngles.z = 0;
						aimbothit = true;
						if (!silentAimbot) {
							CL_SetViewAngles(0, FinalAngles);
							//if (autoShoot) {
								//*(char*)0xee4dc0 = 1;//shoot
							//}
						}
					} else {
						allowAutowall = false;
						aimbothit = false;
					}
				} else {
					allowAutowall = false;
					aimbothit = false;
				}
				DoAngles = false;
			}
			sleep(2);
		} else {
			allowAutowall = false;
			aimbothit = false;
		}
		sleep(4);
	}
}
void drawCrosshair(float size1, float size2) {
	float x = getScreenPercentX(0.5f);
	float y = getScreenPercentY(0.5f);
	DrawShader(x-size1/2,y-size2/2,size1,size2,colors::red,"white");
	DrawShader(x-size2/2,y-size1/2,size2,size1,colors::red,"white");
	*(char*)(0x1CC5AA0 + 0x18) = false;//crosshair
}

void renderHook() {
	*(char*)(0x1CC5AA0 + 0x18) = true;//crosshair
	doMenu();
	if (DvarGetBool("cl_ingame"))
		if (crosshair)
			drawCrosshair(100,1);
}
bool isAimingAllTheWay() {
	float aimRatio_a = *(float*)0x03780EC08;//0 is not aiming. 1.0 is aimed all the way
	return (aimRatio_a == 1.0f);
}
void hook() {
	if (DvarGetBool("cl_ingame")) {
	LocalPlayer = *(int*)(cg_t(0));
	if(ESP || SNAPLINES) {
		renderESP(LocalPlayer);
	}
	if (AimbotStarted)
		{
			//*(int*)(0x1EF77B0) & (1<<8)
			if (Required && /*isButtonDown(B_L1)*//**(int*)(0x1EF77B0) & (1<<8)*/isAimingAllTheWay()/*this is the dvar*(char*)0x00EE4D00*//**(char*)(0x1EF77B2) == 0x01 || *(char*)(0x1EF77B2) == 0x03*/)
			{
				//LocalPlayer = *(int*)(cg_t(0));
				if (!*(bool*)ClientInfo(LocalPlayer, 0x8F))
				{
					if (*(int*)ClientInfo(LocalPlayer, 0x0C) > 0)
					{
						NearstPlayer = GetNearestPlayer(LocalPlayer);
						if (NearstPlayer == -1) {
							aimbothit = false;
							//if(AimbotStarted && autoShoot && !silentAimbot)
								//*(char*)0xee4dc0 = 0;//unshoot
						}
						else
						if (ClientReady)
						{
							ClientReady = false;
							Position = GetTagPos(NearstPlayer, TagOrigin);
							Angles = Difference(Position, Get_cgs()->refdef.viewOrigin/*GetTagPos(LocalPlayer, TagOrigin)*/);
							DoAngles = true;
						}
					}
				}
			}
			else if (!Required)
			{
				LocalPlayer = *(int*)(cg_t(0));
				if (!*(bool*)ClientInfo(LocalPlayer, 0x8F))
				{
					if (*(int*)ClientInfo(LocalPlayer, 0x0C) > 0)
					{
						NearstPlayer = GetNearestPlayer(LocalPlayer);
						if (NearstPlayer == -1) {
							aimbothit = false;
							//if(AimbotStarted && autoShoot && !silentAimbot)
								//*(char*)0xee4dc0 = 0;//unshoot
						}
						else
						if (ClientReady)
						{
							ClientReady = false;
							Position = GetTagPos(NearstPlayer, TagOrigin);
							Angles = Difference(Position, Get_cgs()->refdef.viewOrigin/*GetTagPos(LocalPlayer, TagOrigin)*/);
							DoAngles = true;
						}
					}
				}
			} 
			else {
				aimbothit = false;
			}
		}
	}
}

//0x00F9E690+0x148*i steal host. set your long int to the host's long int
/*

C14F5771 A433BCCF

F56BE9B29275E8D4 my current xuid

My xuid is also at 0x00D86760 (probably main)
Also my xuid at 0x00ED6D40   this one gets overwrritten at 0x000008BDC4
then in mem is the player xuid array I look at
then xuid at 0x00FA7B08
then another xuid array at 0x00FA7FEB
then another that is similar to the one I always use at 0x00FA9998

0x0377C7E98+0x69E18 aka 0x37831CB0 is my real xuid?

0x0377C7E98+0x69E18+0x808*-3

xuid's: 0x377C6680+0x808*i+0x69E18 but THIS one gets reset too

*/
```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/Injector.h`:

```h
namespace injector {        

//char *Bytes;
        int ByteLength;
        unsigned int MALLOC = 0;//just an open sppot    0x10026000
		unsigned int currentlyLoadedGSCAddressToPatch = 0;
		unsigned int currentlyLoadedGSCAddressFix = 0;
        unsigned int InjectTolocation(char *location)
        {
			char returnData[20];
			opd_s jjj_t = {0x18ac04,TOC};
			int(*jjj)(unsigned int arg1, int arg2, char *arg3, int arg4, int arg5) = (int(*)(unsigned int, int, char *, int, int))&jjj_t;
			jjj((unsigned int)&returnData/*0x10040000*/, 0x33, location, 1, -1);
			return *(unsigned int*)((unsigned int)&returnData)/*0x10040000*/;
            //RPC.Call(0x18ac04, new object[] { 0x10040000, 0x33, location, 1, -1 });
            //return PS3.Extensions.ReadUInt32(0x10040000);
        }
 
        unsigned int SpacetoInject()
        {
			if (MALLOC == 0) {
				MALLOC = (unsigned int)SWindow::WUtils::malloc(300000);
				printf("\n\nGSC Locations: 0x%X to 0x%X\n\n\n",MALLOC,MALLOC+300000);
			}
            return MALLOC;//(MALLOC = (MALLOC + ByteLength) + 100);
        }
		void unloadCurrentGSC() {
			if (currentlyLoadedGSCAddressToPatch != 0)
				*(unsigned int*)(currentlyLoadedGSCAddressToPatch) = currentlyLoadedGSCAddressFix;
			currentlyLoadedGSCAddressToPatch = 0;
		}
		char dialoginfo[0xFF];
        void injectFile(char *file,char *overrite/* = "maps/mp/gametypes/_clientids.gsc" *//*"maps/mp/gametypes/_rank.gsc" for some*/ )//inject a .gsc file
        {
			unloadCurrentGSC();
			printf("Injecting %s\n",file);
			ByteLength = getFileSize(file);
			if (ByteLength != -1) {
				printf("ByteLength: 0x%X\n",ByteLength);
				unsigned int WriteOffset = SpacetoInject();
				printf("WriteOffset: 0x%X\n",WriteOffset);
				unsigned int offset = InjectTolocation(overrite);//for zombies use  "maps/mp/gametypes_zm/_clientids.gsc"
				printf("offset: 0x%X\n",offset);
				//char zero[] = {0};
				//memfill((void*)WriteOffset,zero,sizeof(zero),ByteLength+8);//8 just cuz it might not be exactly 4 aligned idk who cares
				//printf("Prepared area of memory\n");
				readFile(file,(char*)WriteOffset,ByteLength);
				printf("File read to address 0x%X\n",WriteOffset);
				currentlyLoadedGSCAddressToPatch = offset + 8;
				currentlyLoadedGSCAddressFix = *(unsigned int*)(offset + 8);
				*(unsigned int*)(offset + 8) = WriteOffset;
				printf("WriteOffset written to 0x%X\n\n",offset + 8);
				//*(int*)0x140C2D0 = WriteOffset;
				//printf("Inject %s!\n",file);
				//cellMsgDialogOpen(1,fprintf("Injected %s!",file),my_dialog2,(void*) 0x0000aaab, NULL);
				strcpy(dialoginfo,fprintf("Injected %s!",file));
				dialog(dialoginfo);
			} else {
				//cellMsgDialogOpen(1,fprintf("Failed to inject %s!",file),my_dialog2,(void*) 0x0000aaab, NULL);
				strcpy(dialoginfo,fprintf("Failed to inject %s!",file));
				dialog(dialoginfo);//has to save it cuz it doesn't instantly call it in the dialog function, it takes a second to send
			}
        }
 
}

//BossamBemass is the creator of bossam
//OfficialCoolJay is the creator of zombieland



/*
downloadFile("dl/bossam.gsc","gopro_2027/bossam.gsc",279068);
	downloadFile("dl/zombieland.gsc","gopro_2027/zombieland.gsc",188538);
	downloadFile("dl/batman.gsc","gopro_2027/batman.gsc",275688);
*/

void injectGSC(char *filename, char *overrite, int fileSize = 0) {
	static char text[128];
	strcpy(text,"Loading GSC");
	dialog(text);
	if (!doesFileExist(filename)) {
		if (fileSize != 0) {//can only download if file size is specified
			strcpy(text,"Downloading...");
			makeFolder("/dev_hdd0/tmp/gopro_2027/");
			makeFolder("/dev_hdd0/tmp/gopro_2027/GSC/");
			char buf1[128];
			char buf2[128];
			strcpy(buf1,fprintf("dl/GSC/%s",filename));
			strcpy(buf2,fprintf("gopro_2027/GSC/%s",filename));
			downloadFile(buf1,buf2,fileSize);
		} else {
			strcpy(text,"Could not download!");
			dialog(text);
			return;
		}
	}
	strcpy(text,"Injecting...");
	dialog(text);
	strcpy(text,fprintf("/dev_hdd0/tmp/gopro_2027/GSC/%s",filename));
	injector::injectFile(text,overrite);
	strcpy(text,"Injected!");
	dialog(text);
}

void injectBossam() {
	//injector::injectFile("/dev_hdd0/tmp/gopro_2027/bossam.gsc","maps/mp/gametypes/_clientids.gsc");
	if (!DvarGetBool("cl_ingame"))
	injectGSC("bossam.gsc","maps/mp/gametypes/_clientids.gsc",279068);//300000
}
void injectZombieland() {
	//injector::injectFile("/dev_hdd0/tmp/gopro_2027/zombieland.gsc","maps/mp/gametypes/_rank.gsc");
	if (!DvarGetBool("cl_ingame"))
	injectGSC("zombieland.gsc","maps/mp/gametypes/_rank.gsc",188538);
}
//void injectBatman() {
	//injector::injectFile("/dev_hdd0/tmp/gopro_2027/batman.gsc","maps/mp/gametypes/_development_dvars.gsc");
//}

void injectElegance() {
	if (!DvarGetBool("cl_ingame"))
	injectGSC("Elegance.gsc","maps/mp/_development_dvars.gsc",211416);
}
void injectLOZAZZA() {
	if (!DvarGetBool("cl_ingame"))
	injectGSC("LozSnip.gsc","maps/mp/gametypes/_clientids.gsc",121624);
}
void injectAvalanche() {
	if (!DvarGetBool("cl_ingame"))
	injectGSC("28.gsc","maps/mp/gametypes/_clientids.gsc",29688);
}
void injectTrickshot() {
	if (!DvarGetBool("cl_ingame"))
	injectGSC("azza.gsc","maps/mp/gametypes/_clientids.gsc",59580);
}
void injectHunger() {
	if (!DvarGetBool("cl_ingame"))
	injectGSC("hunger.gsc","maps/mp/gametypes/_clientids.gsc",100272);
}
void injectCrusher() {
	if (!DvarGetBool("cl_ingame"))
	injectGSC("crusher.gsc","maps/mp/gametypes/_clientids.gsc",18908);
}
void injectInspire() {
	if (!DvarGetBool("cl_ingame"))
	injectGSC("sagi.gsc","maps/mp/_development_dvars.gsc",183652);
}
void injectMike() {
	if (!DvarGetBool("cl_ingame"))
	injectGSC("mike.gsc","maps/mp/gametypes/_clientids.gsc",49516);
}
void injectSupermanTrickshot() {
	if (!DvarGetBool("cl_ingame"))
	injectGSC("lmz1.gsc","maps/mp/gametypes/_clientids.gsc",76812);
}
void injectDeathRun() {
	if (!DvarGetBool("cl_ingame"))
	injectGSC("stur.gsc","maps/mp/gametypes/_clientids.gsc",34556);
}
void injectZombielandShark() {
	if (!DvarGetBool("cl_ingame"))
	injectGSC("zombieland2.gsc","maps/mp/gametypes/_clientids.gsc",122000);
}


/*
bossam
zombieland
Elegance v5 lite - mod menu - maps/mp/_development_dvars.gsc - Elegance.gsc
LOZ AZZA MENU V2 - trickshotting menu - maps/mp/gametypes/_clientids.gsc - LozSnip.gsc
AVALANCHE GAMEMODE - cargo only TDM - maps/mp/gametypes/_clientids.gsc - 28.gsc
Trickshot Menu V4 - trickshots - maps/mp/gametypes/_clientids.gsc - azza.gsc
The Hunger Games V3.5 - DRONE,YEMEN,CARGO,STANDOFF ONLY FFA - maps/mp/gametypes/_clientids.gsc - hunger.gsc
The Crusher Game - FFA ANY MAP - maps/mp/gametypes/_clientids.gsc - crusher.gsc
Insipre v1 - mod menu - maps/mp/_development_dvars.gsc - sagi.gsc
Mike Myers - nuketown only - maps/mp/gametypes/_clientids.gsc - mike.gsc
Lucky Modz Superman mod menu - Trickshotting on carrier - maps/mp/gametypes/_clientids.gsc - lmz1.gsc
Death Run - Cargo Only - maps/mp/gametypes/_clientids.gsc - stur.gsc
*/




namespace injector2 {        


        unsigned int InjectTolocation(char *location)
        {
			char returnData[20];
			opd_s jjj_t = {0x18ac04,TOC};
			int(*jjj)(unsigned int arg1, int arg2, char *arg3, int arg4, int arg5) = (int(*)(unsigned int, int, char *, int, int))&jjj_t;
			jjj((unsigned int)&returnData/*0x10040000*/, 0x33, location, 1, -1);
			return *(unsigned int*)((unsigned int)&returnData)/*0x10040000*/;
        }
 
        
        void dumpFile(char *file,char *overrite/* = "maps/mp/gametypes/_clientids.gsc" *//*"maps/mp/gametypes/_rank.gsc" for some*/ )//inject a .gsc file
        {
				unsigned int offset = InjectTolocation(overrite);//for zombies use  "maps/mp/gametypes_zm/_clientids.gsc"
				printf("Dumping %s\n",overrite);
				printf("Offset: 0x%X\n",offset);
				return;
				if (offset > 0x10000) {
				
					char *data = (char*)(*(unsigned int*)(offset + 8));
					printf("Data: 0x%X\n",(unsigned int)data);
					if ((unsigned int)data > 0x10000) {
						//300000 is size

						writeToFile(file,data,100000);
						printf("Dumped!\n");
						return;
					}
				}
				printf("failed to dump\n");
        }

		void dumpThem() {
			//"maps/mp/gametypes/_clientids.gsc"
			//"maps/mp/gametypes/_rank.gsc"
			//"maps/mp/gametypes/_development_dvars.gsc"
			dumpFile("/dev_hdd0/tmp/_clientids.gsc","maps/mp/gametypes/_clientids.gsc");
			dumpFile("/dev_hdd0/tmp/_rank.gsc","maps/mp/gametypes/_rank.gsc");
			dumpFile("/dev_hdd0/tmp/_development_dvars.gsc","maps/mp/gametypes/_development_dvars.gsc");
		}
 
}
```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/ParadiseCompatabilityTester.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|PS3">
      <Configuration>Debug</Configuration>
      <Platform>PS3</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|PS3">
      <Configuration>Release</Configuration>
      <Platform>PS3</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4D6610B6-AF75-4554-A7B4-50EB4C25971C}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|PS3'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>SNC</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|PS3'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>SNC</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|PS3'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|PS3'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|PS3'">
    <TargetName>ParadiseBO2</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|PS3'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;__CELL_ASSERT__;%(PreprocessorDefinitions);</PreprocessorDefinitions>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <PrecompiledHeader>Use</PrecompiledHeader>
    </ClCompile>
    <Link>
      <AdditionalDependencies>$(SCE_PS3_ROOT)\target\ppu\lib\libstdc++.a;$(SCE_PS3_ROOT)\target\ppu\lib\libstdc++_stub.a;$(SCE_PS3_ROOT)\target\ppu\lib\libc.a;$(SCE_PS3_ROOT)\target\ppu\lib\libc_stub.a;$(SCE_PS3_ROOT)\target\ppu\lib\libhttp_stub.a;$(SCE_PS3_ROOT)\target\ppu\lib\libnet_stub.a;$(SCE_PS3_ROOT)\target\ppu\lib\libsysutil_stub.a;$(SN_PS3_PATH)\ppu\lib\sn\libsn.a;$(SCE_PS3_ROOT)\target\ppu\lib\libm.a;$(SCE_PS3_ROOT)\target\ppu\lib\libio_stub.a;$(SCE_PS3_ROOT)\target\ppu\lib\libsysmodule_stub.a;$(SCE_PS3_ROOT)\target\ppu\lib\libsyscall.a;$(SCE_PS3_ROOT)\target\ppu\lib\fno-exceptions\libstdc++_stub.a;$(SCE_PS3_ROOT)\target\ppu\lib\fno-exceptions\fno-rtti\libstdc++_stub.a;%(AdditionalDependencies)</AdditionalDependencies>
      <InfoStripping>StripSymsAndDebug</InfoStripping>
      <DataStripping>StripFuncsAndData</DataStripping>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|PS3'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions);</PreprocessorDefinitions>
      <OptimizationLevel>Level2</OptimizationLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Aimbot.h" />
    <ClInclude Include="autowall.h" />
    <ClInclude Include="autowall2.h" />
    <ClInclude Include="aw.h" />
    <ClInclude Include="bo2dvars.h" />
    <ClInclude Include="Injector.h" />
    <ClInclude Include="networking.h" />
    <ClInclude Include="stats.h" />
    <ClInclude Include="stats2.h" />
    <ClInclude Include="stats3.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="Structs.h" />
    <ClInclude Include="Vectors.h" />
    <ClInclude Include="Window.h" />
    <ClInclude Include="WindowSetup.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="printf.cpp" />
    <ClCompile Include="prx.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|PS3'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|PS3'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Condition="'$(ConfigurationType)' == 'Makefile' and Exists('$(VCTargetsPath)\Platforms\$(Platform)\SCE.Makefile.$(Platform).targets')" Project="$(VCTargetsPath)\Platforms\$(Platform)\SCE.Makefile.$(Platform).targets" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/ParadiseCompatabilityTester.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;cc;s;asm</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Aimbot.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Vectors.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Structs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="autowall2.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="autowall.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stats.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="aw.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Injector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stats2.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="networking.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Window.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="WindowSetup.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stats3.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="bo2dvars.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="prx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="printf.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/ParadiseCompatabilityTester.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
</Project>
```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/Structs.h`:

```h
#define TOC 0xD67E98

/* dvar->flags */
#define DVAR_ARCHIVE		(1 << 0)	// 0x0001
#define DVAR_USERINFO		(1 << 1)	// 0x0002
#define DVAR_SERVERINFO		(1 << 2)	// 0x0004
#define DVAR_SYSTEMINFO		(1 << 3)	// 0x0008
#define DVAR_INIT		(1 << 4)	// 0x0010
#define DVAR_LATCH		(1 << 5)	// 0x0020
#define DVAR_ROM		(1 << 6)	// 0x0040
#define DVAR_CHEAT		(1 << 7)	// 0x0080
#define DVAR_DEVELOPER		(1 << 8)	// 0x0100
#define DVAR_SAVED		(1 << 9)	// 0x0200
#define DVAR_NORESTART		(1 << 10)	// 0x0400
#define DVAR_CHANGEABLE_RESET	(1 << 12)	// 0x1000
#define DVAR_EXTERNAL		(1 << 14)	// 0x4000
#define DVAR_AUTOEXEC		(1 << 15)	// 0x8000

enum dvarType_t
{
	DVAR_TYPE_INVALID = 0x0,
	DVAR_TYPE_BOOL = 0x1,
	DVAR_TYPE_FLOAT = 0x2,
	DVAR_TYPE_FLOAT_2 = 0x3,
	DVAR_TYPE_FLOAT_3 = 0x4,
	DVAR_TYPE_FLOAT_4 = 0x5,
	DVAR_TYPE_INT = 0x6,
	DVAR_TYPE_ENUM = 0x7,
	DVAR_TYPE_STRING = 0x8,
	DVAR_TYPE_COLOR = 0x9,
	DVAR_TYPE_INT64 = 0xA,
	DVAR_TYPE_LINEAR_COLOR_RGB = 0xB,
	DVAR_TYPE_COLOR_XYZ = 0xC,
	DVAR_TYPE_COUNT = 0xD,
};

union DvarLimits
{
	struct {
		int stringCount;
		const char **strings;
	} enumeration;

	struct {
		int min;
		int max;
	} integer;

	struct {
		float min;
		float max;
	} value, vector;

	struct {
		int64_t min;
		int64_t max;
	} integer64;
};

union DvarValue
{
	bool enabled;
	int integer;
	unsigned int unsignedInt;
	int64_t integer64;
	 int64_t unsignedInt64;
	float value;
	float vectorv[4];
	const char *string;
	char color[4];
};

#pragma pack(push, 4)
struct dvar_t
{
	const char *name;
	const char *description;
	int hash;
	unsigned int flags;
	dvarType_t type;
	bool modified;
	DvarValue current;
	DvarValue latched;
	DvarValue reset;
	DvarLimits domain;
	dvar_t *hashNext;
	int unknown3;
};
#pragma pack(pop)


struct GfxCmdHeader
{
	unsigned short byteCount;
	char id;
	char ui3d;
};

union GfxColor
{
	unsigned int packed;
	char array[4];
};

struct GfxCmdDrawText2D
{
	GfxCmdHeader header;
	int type;
	float x;
	float y;
	float w;
	float h;
	float rotation;
	void *font;
	float xScale;
	float yScale;
	GfxColor color;
	signed int maxChars;
	int renderFlags;
	int cursorPos;
	char cursorLetter;
	GfxColor glowForceColor;
	int fxBirthTime;
	int fxLetterTime;
	int fxDecayStartTime;
	int fxDecayDuration;
	int fxRedactDecayStartTime;
	int fxRedactDecayDuration;
	void *fxMaterial;
	void *fxMaterialGlow;
	float padding;
	char text[3];
};

struct GfxCmdStretchPic
{
	GfxCmdHeader header;
	void *material;
	float x;
	float y;
	float w0;
	float w;
	float h;
	float s0;
	float t0;
	float s1;
	float t1;
	GfxColor color;
};

//#define GLOBAL_CGAME_PTR_ADDR		0xE22F18
//#define GLOBAL_CLIENT_PTR_ADDR	0xD689D8

typedef struct
{
	int x;						// 0x0
	int y;						// 0x4
	int width;					// 0x8
	int height;					// 0xC
	char padding000[0x14];		// 0x10
	float fovx;					// 0x24
	float fovy;					// 0x28
	float fovz;					// 0x2C
	char padding001[0x4];		// 0x30
	float fov;					// 0x34
	Vector3 viewOrigin;			// 0x38
	char padding002[0x4];		// 0x44
	Vector3 axis[3];			// 0x48
	// 0x6C
} RefDef;

typedef struct
{
	char padding000[0x2B4];		// 0x0
	int identifierThing;		// 0x2B4
	// 0x2B8
} WeaponInfoThing;

typedef struct
{
	char padding000[0xC];		// 0x0
	char name[0x20];			// 0xC
	int team;					// 0x2C
	char padding001[0x7D8];		// 0x30
	// 0x808
} ClientInfor;


typedef struct
{
	int localIndex;				// 0x0
	char padding000[0x244];		// 0x4
	int weaponData;				// 0x248
	char padding001[0x24];		// 0x24C
	float zoomAmount;			// 0x270
	char padding002[0x4832C];	// 0x274
	float refdefViewAngles[3];	// 0x485A0
	char padding003[0x2810];	// 0x485AC
	WeaponInfoThing weaponThing;// 0x4ADBC
	char padding004[0x2B1C];	// 0x4B074
	RefDef refdef;				// 0x4DB90
	char padding005[0x1C1A4];	// 0x4DBFC
	ClientInfor clientInfosZ[16];	// 0x69DA0
	char padding006[0xF070];	// 0x71E20
	float spreadMult;			// 0x80E90
} cgs;
//*(int*)0xE22F18+0x4DB90+0x38 = view origin

enum CommandMask
{
	CMD_MASK_FIRE = (1 << 31),
};
struct vec3i {
	int x,y,z;
};
/*typedef struct
{
	int time;					// 0x0
	int buttons;				// 0x4
	char padding000[0x4];		// 0x8
	vec3i viewAngles;		    // 0xC
	char padding001[0x24];		// 0x18
	// 0x3C
} CCommand;*/
typedef struct
{
	int time;					// 0x0
	int buttons;				// 0x4
	char padding000[0x4];		// 0x8
	vec3i viewAngles;		    // 0xC
	char padding002[0xC];       // 0x18
	char forwardmove;           // 0x24
	char sidemove;             // 0x25
	char upmove;                // 0x26
	char padding003[0x1];       // 0x27
	char padding001[0x14];		// 0x28
	// 0x3C
} CCommand;

typedef struct
{
	CCommand commands[128];		// 0x0
	int currentIdx;				// 0x1E00
} CInput;

typedef struct
{
	char padding000[0x98];		// 0x0
	Vector3 origin;				// 0x98
	char padding001[0x64];		// 0xA4
	float refViewAngle[2];		// 0x108
	char padding002[0x2B84];	// 0x110
	float viewAngle[2];			// 0x2C94
	char padding003[0x40014];	// 0x2C9C
	CInput input;				// 0x42CB0
} Client;

struct ScreenPlacement
{
    int64_t scaleVirtualToReal;
    int64_t scaleVirtualToFull;
    int64_t scaleRealToVirtual;
    int64_t virtualViewableMin;
    int64_t virtualViewableMax;
    int64_t virtualTweakableMin;
    int64_t virtualTweakableMax;
    int64_t realViewportBase;
    int64_t realViewportSize;
    int64_t realViewportMid;
    int64_t realViewableMin;
    int32_t realViewableMaxX;
    int32_t realViewableMaxY;
    int64_t realTweakableMin;
    int64_t realTweakableMax;
    int64_t subScreen;
    int hudSplitscreenScale;
};





cgs* Get_cgs()
{
	return *((cgs **)addresses.GLOBAL_CGAME_PTR_ADD);
}


Client* client_get()
{
	return *((Client **)addresses.GLOBAL_CLIENT_PTR_ADD);
}

int getServerTime() {
	return *(int*)(*(int*)addresses.GLOBAL_CLIENT_PTR_ADD/*0xD689D8*/+0x2AAC);
}

char *getHost() {
	return (char*)(*(int*)0xE22F1C+20*4);
}

char *getMapLong() {
	return (char*)(*(int*)0xE22F1C+8+7*12*4);
}

char *getMapShort() {
	return (char*)(*(int*)0xE22F1C+7*15*4-0xc);
}

char *getGameMode() {
	return (char*)(*(int*)0xE22F1C+12*4);
}

void drawLagometer(bool enable) {
	*(char*)(0x1CC56E0 + 0x18) = enable;
}

void drawDofDebug(bool enable) {
	*(char*)(0x1CBFE00 + 0x18) = enable;
}

void drawGun(bool enable) {
	*(char*)(0x1CC5020 + 0x18) = enable;
}
void drawFPS(bool enable) {
	*(int*)(0x1CC5680 + 0x18) = enable;
}
struct opd_s {
	int addr,toc;
};

opd_s AimTarget_isTargetVisible_t = { 0x15988, TOC };
opd_s SL_GetString_t = { 0x48ED68, TOC };
opd_s AimTarget_GetTagPos_t = { 0x015708, TOC };
opd_s CL_SetViewAngles_t = { 0x10B978, TOC };
opd_s Dvar_GetBool_t = { 0x3DA948, TOC };
opd_s Dvar_FindMalleableVar_t = { 0x3DA628, TOC };
opd_s CG_IsEntityFriendlyNotEnemy_t = { 0x049720, TOC };
opd_s R_ConvertColorToBytes_t = { 0x794980, TOC };
opd_s R_GetCommandBuffer_t = { 0x769F6C, TOC };
opd_s SetDrawText2DGlowParms_t = { 0x76A9B8, TOC };
opd_s Material_RegisterHandle_t = { 0x763220, TOC };
opd_s R_RegisterFont_t = { 0x75A2C0, TOC };
opd_s CG_GameMessage_t = { 0x6AD98, TOC };
opd_s Cbuf_AddText_t = { 0x313C18, TOC };
opd_s CG_DrawRotatedPicPhysical_t = { 0x0456F8, TOC };
opd_s R_AddCmdDrawTextInternal_t = { 0x76A910, TOC };
opd_s R_AddCmdDrawStretchPicInternal_t = { 0x076A3E8, TOC };
//opd_s CL_WritePacket_t = {0x00116524,TOC};
opd_s ScrPlace_GetView_t = {0x0015F080,TOC};


void(*R_AddCmdDrawStretchPicInternal)(float x, float y, float w, float h, float s0, float t0, float s1, float t1, float * color, void *material) = (void(*)(float, float, float, float, float, float, float, float, float *, void*))&R_AddCmdDrawStretchPicInternal_t;
void(*R_AddCmdDrawTextInternal)(const char* text, int maxChars, void* font, float x, float y, float yScale, float xScale, float rotation, float * colors, int Style) = (void(*)(const char*, int, void*, float, float, float, float, float, float *, int))&R_AddCmdDrawTextInternal_t;
int(*CG_DrawRotatedPicPhysical)(ScreenPlacement* screenPlacement, float X, float Y, float Width, float Height, float Angle, float* Color, void* Material) = (int(*)(ScreenPlacement*, float, float, float, float, float, float*, void*))&CG_DrawRotatedPicPhysical_t;
void(*Cbuf_AddText)(int LocalClient, char* text) = (void(*)(int, char*))&Cbuf_AddText_t;
void(*CL_SetViewAngles)(int LocalClient, const float* Angles) = (void(*)(int, const float*))&CL_SetViewAngles_t;
int(*SL_GetString)(const char *str) = (int(*)(const char*))&SL_GetString_t;
bool(*AimTarget_GetTagPos)(int targ_centity, unsigned tagIndex, float *pos) = (bool(*)(int, unsigned int, float*))&AimTarget_GetTagPos_t;
bool(*AimTarget_GetTagPos_r)(int targ_centity, unsigned tagIndex, float *pos) = (bool(*)(int, unsigned int, float*))&AimTarget_GetTagPos_t;
bool(*AimTarget_isTargetVisible)(int LocalClient, int Centity) = (bool(*)(int, int))&AimTarget_isTargetVisible_t;
bool(*Dvar_GetBool_f)(dvar_t* LocalClient) = (bool(*)(dvar_t*))&Dvar_GetBool_t;
dvar_t*(*Dvar_FindMalleableVar)(const char* LocalClient) = (dvar_t*(*)(const char*))&Dvar_FindMalleableVar_t;
void*(*R_ConvertColorToBytes)(const float* colorFloat, char* colorBytes) = (void*(*)(const float*, char*))&R_ConvertColorToBytes_t;
bool(*CG_IsEntityFriendlyNotEnemy)(int LocalClient, int Centity) = (bool(*)(int, int))&CG_IsEntityFriendlyNotEnemy_t;
GfxCmdHeader*(*R_GetCommandBuffer)(int renderCmd, int bytes) = (GfxCmdHeader*(*)(int, int))&R_GetCommandBuffer_t;
bool(*SetDrawText2DGlowParms)(GfxCmdDrawText2D *cmd, const float *color, const float *glowColor) = (bool(*)(GfxCmdDrawText2D*, const float*, const float*))&SetDrawText2DGlowParms_t;
void*(*Material_RegisterHandle)(const char *name, int imageTrack, bool errorIfMissing, int waitTime) = (void*(*)(const char*, int, bool, int))&Material_RegisterHandle_t;
void*(*R_RegisterFont)(const char * name, int imageTrack) = (void*(*)(const char*, int))&R_RegisterFont_t;
void(*CG_GameMessage)(int LocalClient, const char * msg) = (void(*)(int, const char *))&CG_GameMessage_t;
ScreenPlacement*(*ScrPlace_GetView)(int localClient) = (ScreenPlacement*(*)(int))&ScrPlace_GetView_t;
//void(*CL_WritePacket)(int LocalClient) = (void(*)(int))&CL_WritePacket_t;

void DrawText(const char *text, const char *fontName, float x, float y, float scale, float * color)
{
	R_AddCmdDrawTextInternal(text, 0x7FFFFFFF, R_RegisterFont(fontName, 0), x, y, scale, scale, 0, color, 0);
}

void DrawShader(float x, float y, float width, float height, float * color, const char *material)
{
	R_AddCmdDrawStretchPicInternal(x, y, width, height, 0, 0, 1, 1, color, Material_RegisterHandle(material, 0, 0, 0));
}

float getScreenPercentX(float percent) {
	Get_cgs()->refdef.width*percent;
}
float getScreenPercentY(float percent) {
	Get_cgs()->refdef.height*percent;
}

void DrawLine(float X1, float Y1, float X2, float Y2, float *color/*4 floats array*/, float a, float Width)
{
	//not working yet
	ScreenPlacement* scr = ScrPlace_GetView(0);
	float X, Y, Angle, L1, L2, H1;
	H1 = Y2 - Y1;
	L1 = X2 - X1;
	L2 = myMath::root(L1 * L1 + H1 * H1,2);//this is nor correct somehow
	L2*=myMath::sin(L2);
	X = X1 + ((L1 - L2) / 2);//(dif-length)/2+startx THIS IS CORRECT  this made it move right
	Y = Y1 + (H1 / 2);//correct
	scr->realViewableMaxX = (int32_t)X;
	scr->realViewableMaxY = (int32_t)Y;
	Angle = (float)myMath::atan2(H1,L1) * 180.00 / PI;
	float colorf[4] = { color[0], color[1], color[2],  a};
	CG_DrawRotatedPicPhysical(scr, X, Y, L2, Width, Angle, colorf, Material_RegisterHandle("white", 0, 0, 0));
}

int DrawLine1(int x1, int y1, int x2, int y2, float* color){
	ScreenPlacement* ptr = ScrPlace_GetView(0);

	float x,y,angle,l1,l2,h1;
    h1=y2-y1;
    l1=x2-x1;
    l2=sqrt(l1 * l1 + h1 * h1);
    x=x1+((l1-l2)/2);
    y=y1+(h1/2);
    angle=myMath::atan2(h1,l1)* (180 / 3.14159265358979323846) ;
    return CG_DrawRotatedPicPhysical(ptr,x,y,l2,1.0,angle,color, Material_RegisterHandle("white", 0, 0, 0));
}




bool checkAntiBan()
{
	int nop = 0x60000000;
	if (
		*(int*)0x004FBA74 == nop &&
		*(int*)0x00537DD4 == nop &&
		*(int*)0x00538148 == nop &&
		*(int*)0x005200E8 == nop &&
		*(int*)0x005200F4 == nop 
		) return true; else return false;
}

bool doAntiBan()
{
	char nop[4] = { 0x60, 0x00, 0x00, 0x00 };
	write_process((void*)0x004FBA74, nop, sizeof(nop));
	write_process((void*)0x00537DD4, nop, sizeof(nop));
	write_process((void*)0x00538148, nop, sizeof(nop));
	write_process((void*)0x005200E8, nop, sizeof(nop));
	write_process((void*)0x005200F4, nop, sizeof(nop));
	sleep(1000);
	if (checkAntiBan() == true)
		return true;
	else
		return false;
}


bool AimbotStarted = true;
bool DoAngles;
int LocalPlayer;
int NearstPlayer;
bool silentAimbot = true;
int autowallEnabled = 1;
//int superAutowallEnabled = 0;
bool allowAutowall = false;
bool NoSpreadToggle = true;
bool aimbothit;
bool safeAimbot = false;
Vector3 AimAngles;
Vector3 Position;
Vector3 vec;
Vector3 Angles;
Vector3 veccccc;
bool ClientReady;
bool Required = false;
bool ESP = true;
bool SNAPLINES = false;
bool invisibleBodies = false;
bool wallHackEnabled = false;
bool laserEnabled = false;
bool blinkingBodiesEnabled = false;
bool bigNamesEnabled = false;
bool autoShoot = true;
bool Stealth = true;
bool fakeLag = false;
bool redBoxes = false;
bool noRecoil = true;
bool vsat = true;
bool crosshair = false;
float espx, espy;
Vector3 espdrawpos = Vector3(50,50,50);
Vector3 abviewangles = Vector3(50,50,50);
char* TagOrigin = "j_head";
char *selectableTags[] = {"j_head","j_helmet","j_neck","torso_stabilizer"};
int currentTag = 0;
/*void nextTag() {
	currentTag++;
	if (currentTag > 3)
		currentTag = 0;
	switch(currentTag) {
	case 0:
		TagOrigin = "j_head";
		break;
	case 1:
		TagOrigin = "j_helmet";
		break;
	case 2:
		TagOrigin = "j_neck";
		break;
	case 3:
		TagOrigin = "torso_stabilizer";
		break;
	}
}*/
//char *font = "fonts/distfont";
float menux = 200, menuy = 100;
float menusizex = 220, menusizey = 300;

namespace colors {
float LightBlue[] = {0.0,1.0,1.0,1.0};
float Blue[] = {0.0,0.0,1.0,1.0};
float LightBlueOpaque[] = {0,1.0,1,100.0/255.0};
float DarkOpaque[] = {0,0,0,100.0/255.0};
float White[] = {1,1,1,1};
float Black[] = {0,0,0,1};
float RedOpaque[] = {1.0,0.0,0.0,100.0/255.0};
float green[] = {0,1,0,1};
float red[] = {1,0,0,1};
//text: r:0 g:217 b:0 bg: r:0 g:32 b:0
float hackerGreenText[] = {0,217.0/255.0,0,1.0};
float hackerGreenText2[] = {0,217.0/255.0,0,0.7};
float hackerGreenBackground[] = {0,32.0/255.0,0,1};
float hackerRedText[] = {217.0/255.0,0,0,1.0};
}

enum buttonslol {
	B_X = 0x1000,
	B_Triangle = 0x8000,
	B_Square = 0x4000,
	B_Circle = 0x2000,
	B_DpadUp = 0x0001,
	B_DpadDown = 0x0002,
	B_DpadLeft = 0x0004,
	B_DpadRight = 0x0008,
	B_R1 = 0x0200,
	B_R2 = 0x0800,
	B_R3 = 0x0080,
	B_L1 = 0x0100,
	B_L2 = 0x0400,
	B_L3 = 0x0040,
	B_Start = 0x0010,
	B_Select = 0x0020,
};
bool isButtonDown(int button) {
	return *(short*)0x1EF77B2 & button;
}
```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/Vectors.h`:

```h
namespace myMath {
	#define PI (3.1415926535897931)
float abs(float a) {
	if (a < 0)
		return a*-1;
	return a;
}
float DegreesToRadians(float Degrees)
{
    return Degrees * PI / 180.0f;
}
 
float RadiansToDegrees(float Radians)
{
    return Radians * 180.0f / PI;
}
 
float pow(float num, int power) {
    float ret = 1;
    for (int i = 0; i < power; i++)
        ret = ret*num;
    return ret;
}
 
float root(float num, int nroot) {
    int iterations = 15 * (nroot-1);
    float x = iterations*100;
    for (int i = 1; i < iterations; i++) {
       x = (float)(((float)1/nroot)*(((nroot-1)*x)+(num/pow(x,nroot-1))));
    }
    return x;
}
 
float sin(float deg) {
    bool neg = false;
    while (deg >= 360) deg = deg - 360;
    while (deg < 0) deg = deg + 360;
    if (deg > 180) {
        deg = deg - 180;
        neg = true;
    }
    float ret = (float)(4*deg*(180-deg))/(40500-(deg*(180-deg)));
    if (neg)return ret*-1;
    return ret;
}
 
float cos(float AnglesDeg)
{
 float AnglesRad = DegreesToRadians(AnglesDeg);
 float Rad = (float)(PI/2.0f)-AnglesRad;
 float ang = RadiansToDegrees(Rad);
    return sin(ang);
}
 
float tan(float AnglesDeg)
{
    float sinus = sin(AnglesDeg);
    float cosinus = cos(AnglesDeg);
    return sinus/cosinus;
}

double atan(double x, int n)
{
	double a = 0.0;// 1st term
	double sum = 0.0;

	// special cases
	if( x == 1.0 ) return PI/4.0;
	if( x == -1.0 ) return -PI/4.0;

	if(n > 0)
	{
	    if( (x < -1.0) || (x > 1.0) )
	    {
	        // constant term
	        if( x > 1.0 )
                sum = PI/2.0;
            else
                sum = -PI/2.0;
            // initial value of a
            a = -1.0/x;
            for(int j=1; j<=n; j++)
            {
                sum += a;
                a *= -1.0*(2.0*j-1)/((2.0*j+1)*x*x);// next term from last
            }
	    }
	    else// -1 < x < 1
	    {
	        // constant term
	        sum = 0.0;
	        // initial value of a
            a = x;
            for(int j=1; j<=n; j++)
            {
                sum += a;
                a *= -1.0*(2.0*j-1)*x*x/(2.0*j+1);// next term from last
            }
	    }
		//r_err = a;// max. error = 1st term not taken for alternating series
	}

	return sum;
}

double atan2(double y, double x)
{
    double u = atan( y/x, 24);
    if( x < 0.0 )// 2nd, 3rd quadrant
    {
        if( u > 0.0 )// will go to 3rd quadrant
            u -= PI;
        else
            u += PI;
    }
    return u;
}


}




typedef struct Vector2
{
	float x, y;

}Vector2, *PVector2;

typedef struct Vector3
{
	float x, y, z;
	Vector3()
	{
		x = y = z = 0;
	}
	Vector3(float x, float y, float z)
	{
		this->x = x; this->y = y; this->z = z;
	}
	const bool operator== (Vector3 const &Vector)
	{
		return (this->x == Vector.x && this->y == Vector.y && this->z == Vector.z);
	}
	const Vector3& operator+ (Vector3 const &Vector)
	{
		return Vector3(this->x + Vector.x, this->y + Vector.y, this->z + Vector.z);
	}
	const Vector3& operator- (Vector3 const &Vector)
	{
		return Vector3(this->x - Vector.x, this->y - Vector.y, this->z - Vector.z);
	}

	float Distance(Vector3 const &Vector)
	{
		return sqrt(DistanceEx(Vector));
	}
	float DistanceEx(Vector3 const &Vector)
	{
		float _x = this->x - Vector.x, _y = this->y - Vector.y, _z = this->z - Vector.z;
		return ((_x * _x) + (_y * _y) + (_z * _z));
	}
	float DotProduct(Vector3 const &Vector)
	{
		return (this->x * Vector.x) + (this->y * Vector.y) + (this->z * Vector.z);
	}
	const Vector3 &RoundHalfUp()
	{
		return Vector3(floor(this->x + 0.5), floor(this->y + 0.5), floor(this->z + 0.5));
	}\
		const Vector3 &RoundHalfDown()
	{
		return Vector3(floor(this->x + 0.5), floor(this->y + 0.5), floor(this->z + 0.5));
	}
} Vector3, *PVector3;


float dx, dy, dz;
float Distance3D(Vector3 c1, Vector3 c2)
{
	float dx = c2.x - c1.x;
	float dy = c2.y - c1.y;
	float dz = c2.z - c1.z;

	return sqrt((float)((dx * dx) + (dy * dy) + (dz * dz)));
}

typedef struct Vector4
{
	float x, y, z, a;
	Vector4()
	{
		x = y = z = a = 0;
	}
	Vector4(float x, float y, float z, float a)
	{
		this->x = x;
		this->y = y;
		this->z = z;
		this->a = a;
	}

} Vector4, *PVector4;

Vector3 vectoangles(Vector3 Angles)
{
	float forward;
	float yaw, pitch;
	//float PI = 3.1415926535897931;
	if (Angles.x == 0 && Angles.y == 0)
	{
		yaw = 0;
		if (Angles.z > 0) pitch = 90.00;
		else pitch = 270.00;
	}
	else
	{
		if (Angles.x != -1) yaw = (float)(atan2((double)Angles.y, (double)Angles.x) * 180.00 / PI);
		else if (Angles.y > 0) yaw = 90.00;
		else yaw = 270;
		if (yaw < 0) yaw += 360.00;

		forward = (float)sqrt((double)(Angles.x * Angles.x + Angles.y * Angles.y));
		pitch = (float)(atan2((double)Angles.z, (double)forward) * 180.00 / PI);
		if (pitch < 0) pitch += 360.00;
	}
	Vector3 AnglesVector(-pitch, yaw, 0);
	return AnglesVector;
}

Vector3 Difference(Vector3 Target, Vector3 Entity)
{
	Vector3 Return = Target - Entity;
	return Return;
}

typedef struct vec4_t
{
	float x, y, z, w;
	vec4_t()
	{
		x = y = z = w = 0;
	};
};

void VectorCopy(Vector3 *orig, Vector3 *final) {
	final->x = orig->x;
	final->y = orig->y;
	final->z = orig->z;
}
```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/Window.h`:

```h
/*
GOAL:
Dpad up/down to scroll
Dpad left/right
R1/L1 to swap between windows
R3 + Right Joystick to move current window
*/

//OnScreenKeyboard(0, title, presetMessage, len, KeyboardComplete, panelMode);


bool isButtonJustPressed(int button);
char ftosbuf[50];
char *FtoS(float fl) {
	snprintf(ftosbuf,sizeof(ftosbuf),"%f",fl);
	return ftosbuf;
}
float StoF(const char* s){
  float rez = 0, fact = 1;
  if (*s == '-'){
    s++;
    fact = -1;
  }
  for (int point_seen = 0; *s; s++){
    if (*s == '.'){
      point_seen = 1;
      continue;
    }
    int d = *s - '0';
    if (d >= 0 && d <= 9){
      if (point_seen) fact /= 10.0f;
      rez = rez * 10.0f + (float)d;
    }
  }
  return rez * fact;
}
//void drawText(char * text, int font, float x, float y, float scalex, float scaley, int r, int g, int b, int a, bool center);
void sleep(usecond_t time);
//struct Vector2 {float x,y;};//already declared in Vectors.h
struct Vector2i {int x,y;};
struct Color {int r,g,b,a;};
typedef Vector2 Ratio;
typedef Vector2i Pixel;
#define SCREENRES (*(Vector2i*)(0xF11A18/*0xF11A10 for the lower resolution*//*&Get_cgs()->refdef.width*/))
void RatioToPixel(Ratio ratio, Pixel *pixel) {
	pixel->x = (int)(ratio.x*(float)SCREENRES.x);
	pixel->y = (int)(ratio.y*(float)SCREENRES.y);
}
void PixelToRatio(Pixel pixel, Ratio *ratio) {
	ratio->x = (float)((float)pixel.x/SCREENRES.x);
	ratio->y = (float)((float)pixel.y/SCREENRES.y);
}
void drawRectByRatiosCentered(Ratio origin, Ratio size, Color color) {
	//printf("w: %i, h: %i\n",SCREENRES.x,SCREENRES.y);
	//printf("w1: %i, h1: %i\n\n",Get_cgs()->refdef.width,Get_cgs()->refdef.height);
	//GRAPHICS::DRAW_RECT(origin.x, origin.y, size.x, size.y,color.r,color.g,color.b,color.a);
	float width = size.x*SCREENRES.x;
	float height = size.y*SCREENRES.y;
	float x = origin.x*SCREENRES.x-(width/2);
	float y = origin.y*SCREENRES.y-(height/2);
	float c[] = {color.r/255.0f,color.g/255.0f,color.b/255.0f,color.a/255.0f};
	DrawShader(x,y,width,height,c,"white");
}
void drawRectByPixelsCentered(Pixel origin, Pixel size, Color color) {
	Ratio o,s;
	PixelToRatio(origin,&o);
	PixelToRatio(size,&s);
	drawRectByRatiosCentered(o,s,color);
}
/*void drawRectByPixels(Pixel origin, Pixel size, Color color) {//origin is top left, size extends right and down. size is NOT a second coordinate
	Pixel o;
	o.x = (float)origin.x+(float)size.x/2;
	o.y = (float)origin.y+(float)size.y/2;
	drawRectByPixelsCentered(o,size,color);
}*/
enum Alignment {
	Align_Left,
	Align_Center,
	Align_Right
};
void drawRectByPixels(Pixel origin, Pixel size, Color color, Alignment xalign = Align_Right, Alignment yalign = Align_Right) {//origin is top left, size extends right and down. size is NOT a second coordinate
	Pixel o;
	//o.x = (float)origin.x+(float)size.x/2;//align right x
	//o.x = (float)origin.x-(float)size.x/2;//align left x
	//o.x = (float)origin.x;//align center x

	//calculate the halves of size
	float xo2 = (float)size.x/2;
	float yo2 = (float)size.y/2;
	//assume center align was used cuz that requires like nothing and will be used in ever single one
	//Align_Center
	o.x = origin.x;
	o.y = origin.y;
	//check alignment left or right
	if (xalign == Align_Left)
		o.x -= xo2;//align left x
	else if (xalign == Align_Right)
		o.x += xo2;//align right x
	if (yalign == Align_Left)
		o.y -= yo2;//align left y
	else if (yalign == Align_Right)
		o.y += yo2;//align right y
	drawRectByPixelsCentered(o,size,color);
}
void drawTextByPixels(char * text, int font, Pixel origin, Ratio textsize, Color color, int addY = 0) {
	Ratio r;
	PixelToRatio(origin,&r);
	origin.y+=addY;//THIS IS NECESSARY BECAUSE THE COD ENGINE RENDERS TEXT A BIT DIFFERENT THAN THE GTA ENGINE AND IT MESSES UP THE Y VALUE FOR TEXT WHICH I CANNOT EASILY FIX WITHOUT SIMPLY ADDING THE NECESSARY BIT
	//drawText(text, font, r.x, r.y, textsize.x, textsize.y, color.r, color.g, color.b, color.a, false);
	float c[] = {color.r/255.0f,color.g/255.0f,color.b/255.0f,color.a/255.0f};
	DrawText(text,"fonts/720/normalfont",origin.x,origin.y,textsize.x/*0.9*//*0.74*/,c);
}
void nullfunc() {};
namespace SWindow {
	namespace WUtils {
		void* malloc(uint32_t a_uiSize) {
			static unsigned int addr = 0x10026000;//0x10060010;
			sys_addr_t l_uiAddr = addr;
			addr += a_uiSize;
			addr += 4-addr%4;
			//a_uiSize = ((a_uiSize + 65536) / 65536) * 65536;
			//sys_memory_allocate(a_uiSize, SYS_MEMORY_PAGE_SIZE_64K, &l_uiAddr);
			return (void*)l_uiAddr;
		}
		void free(void* a_Addr) {
			//sys_memory_free((sys_addr_t)a_Addr);
		}
		float getTextWidth(char * text, int font, Ratio scale) {
			//don't have a thing for this in cod
			return 400/SCREENRES.x;
		}
	};


	Color backgroundColor = {0,0,0,255};//0,0,0,70
	Color headerSelectedBackgroundColor = {52, 152, 219,255};//same
	Color headerTextColor = {52, 152, 219,255};//same
	Color optionColor = {255,255,255,255};
	Color headerColor = {0,0,0,255};
	Color selectorColor = {231, 76, 60,255};
	Color trueColor = {46, 204, 113,255};
	Color falseColor = {192, 57, 43,255};
	Pixel box10 = {10,10};//great little box
	Pixel box20 = {20,20};//bigger box. Unsure why
	int optionFont = 4;//2
	Ratio textSizeRatio = {0.7f,0.4f};//0.026 for font 2 and this size
	float optionFontDefaultYSize = 0.026;//for font 4
	int optionFontDefaultYSizePixels = 18;
	bool globalKeyboardBool = false;
	/*int selectionToRenderSlot(int selection) {
		return selection%maxOptionsPerPage;
	}
	int getMinOptionToRender(int selection) {
		int leftover = selection%maxOptionsPerPage;//2%10=2, 9%10=9,10%10=0,11%10=1,15%10=5
		int minOption = selection-leftover;//2-2=0,9-9=0,10-0=10,11-1=10,15-5=10
	}
	int getMaxOptionToRender(int selection) {
		//it will go from min to including (the return of this -1) so this is like maxOption
		int leftover = selection%maxOptionsPerPage;//2%10=2, 9%10=9,10%10=0,11%10=1,15%10=5
		int minOption = selection-leftover+maxOptionsPerPage;//2-2=0,9-9=0,10-0=10,11-1=10,15-5=10
	}*/
	enum OptionType {
		Option_None,//No special changeable value
		Option_Bool,
		Option_Int,
		Option_Float,
		Option_Hex,
		Option_String
	};

	union OptionValue {
		int i;
		unsigned int ui;
		float f;
		char *str;
		bool b;

		operator int () const { return i; }
		operator unsigned int () const { return ui; }
		operator float () const { return f; }
		operator char *() const { return str; }
		operator bool () const { return b; }
	};

	OptionValue nulloptionvalue;

	class WindowOption {
	public:
		char *optionText;
		char *optionInfo;
		OptionType optionType;
		OptionValue *optionValue;
		bool awaitingKeyboard;
		OptionValue minmax[2];
		bool useminmax;
		void (*callback)();
		Pixel size;
		
		void create() {
			callback = nullfunc;
			optionText = "Default Text";
			optionInfo = "Defualt Info";
			optionType = Option_None;
			Ratio r;
			r.y = optionFontDefaultYSize;
			r.x = 0.0;
			RatioToPixel(r,&size);
			useminmax = false;
		}
		void setup(char *text, void(*runOnSelect)() = nullfunc, OptionType type = Option_None, OptionValue *modifyValue = &nulloptionvalue, char *infotext = "") {
			optionText = text;
			optionInfo = infotext;
			callback = runOnSelect;
			optionType = type;
			optionValue = modifyValue;
		}
		void setHeightByRatio(float ratio) {
			Ratio r;
			PixelToRatio(size,&r);
			r.y = ratio;
			RatioToPixel(r,&size);
		}
		void setupMinMax(OptionValue min, OptionValue max) {
			minmax[0] = min;
			minmax[1] = max;
			useminmax = true;
		}
		void setupMinMax(int min, int max) {
			minmax[0].i = min;
			minmax[1].i = max;
			useminmax = true;
		}
		void setupMinMax(float min, float max) {
			minmax[0].f = min;
			minmax[1].f = max;
			useminmax = true;
		}
		void setCallback(void(*f)()) {
			callback = f;
		}
		void callCallback() {
			callback();
		}
		void fixMinMax() {
			if (useminmax) {
				if (optionType == Option_Int || optionType == Option_Hex) {
					if ((*optionValue).i > minmax[1].i)
						(*optionValue).i = minmax[0].i;
					if ((*optionValue).i < minmax[0].i)
						(*optionValue).i = minmax[1].i;
				}
				else if (optionType == Option_Float) {
					if ((*optionValue).f > minmax[1].f)
						(*optionValue).f = minmax[0].f;
					if ((*optionValue).f < minmax[0].f)
						(*optionValue).f = minmax[1].f;
				}
			}
		}
		void keyboardCallback(char *str/*int localClientNum, const wchar_t *text, int len*/) {
			/*void KeyboardComplete(int localClientNum, const wchar_t *text, int len) {
	char * CString = ToStr(text);
}
*/
			/*char str[KEYBOARD_MAX_LENGTH+1];
			for (int i = 0; i < len; i++) {
				str[i] = text[i];
			}
			str[len] = '\0';*/

			//awaitingKeyboard = false;
			if (optionType == Option_Int || optionType == Option_Hex) {
				//printf("String %s\n",str);
				(*optionValue).i = StoI(str);
			}
			else if (optionType == Option_Float) {
				(*optionValue).f = StoF(str);
			}
			else if (optionType == Option_String) {
				strcpy((*optionValue).str,str);
			}
			fixMinMax();
		}
		void increaseValue() {
			if (optionType == Option_Int || optionType == Option_Hex)
				(*optionValue).i++;
			if (optionType == Option_Float)
				(*optionValue).f++;
			fixMinMax();
		}
		void decreaseValue() {
			if (optionType == Option_Int || optionType == Option_Hex)
				(*optionValue).i--;
			if (optionType == Option_Float)
				(*optionValue).f--;
			fixMinMax();
		}
		/*void OnScreenKeyboard(int LocalClientNum, char *Title, char *PresetMessage, int Length, void(SWindow::WindowOption::*CompleteFunction)(int LocalClientNum, const wchar_t * wString, int Length), int PanelMode) {
			*(char*)0xD82144 = 1;
			opd_s AdNig = { 0x46710C, TOC };
			((void(*)(int, char *, char *, int, void(SWindow::WindowOption::*)(int, const wchar_t*, int), int))&AdNig)(LocalClientNum, Title, PresetMessage, Length, CompleteFunction, PanelMode);
		}*/
		void editValueWithKeyboard() {
			//TODO
			//GAMEPLAY::DISPLAY_ONSCREEN_KEYBOARD(0, "FMMC_KEY_TIP8", "", ""/*default text*/, "", "", "", 64);
			//globalKeyboardBool = true;
			//awaitingKeyboard = true;
			//KEYBOARD_MAX_LENGTH
			//OnScreenKeyboard(0, "Enter Value", "", KEYBOARD_MAX_LENGTH, &SWindow::WindowOption::keyboardCallback, 1);
			if (optionType == Option_Int || optionType == Option_Float || optionType == Option_Hex || optionType == Option_String)
				keyboardSWindow::openKeyboard(this);
		}
		OptionValue getOptionValue() {
			return *optionValue;
		}
		void updateSize(bool isSelected, bool isCurrentWindow) {
			Ratio r;
			//PixelToRatio(size,&r);
			r.y = optionFontDefaultYSize;
			//r.x = 0.0;
			r.x = WUtils::getTextWidth(optionText,optionFont,textSizeRatio);
			//printf("r.x: %s\n",FtoS(r.x));
			RatioToPixel(r,&size);//convert our sizes to pixels
			size.x+=5;//padding for the text
			//printf("size.y: %s\n",FtoS(size.y));
			if (optionType == Option_Bool)
				size.x+=10;//for the 10px bool box
			else if ((optionType == Option_Int || optionType == Option_Float || optionType == Option_Hex || optionType == Option_String) && isSelected && isCurrentWindow)
				size.y+=25;
		}
		
	};

	class Window {
	public:
		Pixel origin;
		char *header;
		WindowOption *options;
		int currentPage;
		int selectedOption;
		int maxOptions;
		bool isOpened;
		bool menuHasBeenFilledWithOptions;
		int maxOptionsPerPage;
#define SELECTION2RENDERSLOT(x) (x%maxOptionsPerPage)
#define MINOPTION2RENDER(x) (x-SELECTION2RENDERSLOT(x))
#define MAXOPTION2RENDER(x) (MINOPTION2RENDER(x)+maxOptionsPerPage)
		void create() {
			origin.x = 0;
			origin.y = 0;
			header = "Default";
			currentPage = 0;
			selectedOption = 0;
			isOpened = false;//change to false later so closed by default
			maxOptionsPerPage = 10;
		}
		void runStandard() {//this is constantly ran just like the render thread
			
		}
		void runSelected() {//this is ran while this menu is selected
			
		}
		void scrollDown() {
			selectedOption--;
			if (selectedOption < 0)
				selectedOption = maxOptions-1;
		}
		void scrollUp() {
			selectedOption++;
			if (selectedOption >= maxOptions)
				selectedOption = 0;
		}
		void render(bool isCurrentWindow) {//this is ran 100% of the time
			char *info = "";
			float currentY = origin.y;//start drawing option text at the start of the window origin
			Pixel size = {190,0};//100px minimum width
			Pixel sizeheader = {size.x,0};
			Ratio r = {0,optionFontDefaultYSize};
			RatioToPixel(r,&sizeheader);
			Pixel shiftedOrigin = {origin.x,origin.y+sizeheader.y};
			currentY+=sizeheader.y;//shift down so the header starts at origin and not the options
			//Pixel scrollerOrigin = {0,0};
			int minOptionToRender = MINOPTION2RENDER(selectedOption);
			int maxOptionToRender = MAXOPTION2RENDER(selectedOption);
			if (maxOptionToRender > maxOptions)
				maxOptionToRender = maxOptions;
			//printf("1\n");
			Pixel bgsize = {size.x,size.y};
			for (int i = minOptionToRender/*0*/; i < maxOptionToRender/*maxOptions*/; i++) {
				options[i].updateSize(i == selectedOption,isCurrentWindow);
				if (size.x<options[i].size.x) {
					size.x=options[i].size.x;
					bgsize.x=options[i].size.x;
				}
				bgsize.y+=options[i].size.y;
			}
			drawRectByPixels(shiftedOrigin,bgsize,backgroundColor);//100% correct main background
			for (int i = minOptionToRender/*0*/; i < maxOptionToRender/*maxOptions*/; i++) {
				size.y+=options[i].size.y;
				//printf("2\n");
				//cmd vsay hi
				//These pixel values spread from the very top of where the text was drawn to the top of the next text drawn. So if you have double the length, the center one for example would be the bottom off the current option
				Pixel o = {origin.x,currentY};//this is the point on the top left corner of the currently selected option
				Pixel om = {origin.x,currentY+(float)options[i].size.y/2.0f};//this is the point on the middle left of the currently selected option
				Pixel ob = {origin.x,currentY+options[i].size.y};//this is the point on the bottom left of the currently selected option
				Pixel orr = {origin.x+size.x,currentY};//this is the point on the top right corner of the currently selected option
				Pixel orm = {origin.x+size.x,currentY+(float)options[i].size.y/2.0f};//this is the point on the middle right of the currently selected option
				Pixel orb = {origin.x+size.x,currentY+options[i].size.y};//this is the point on the bottom right of the currently selected option
				
				if (i == selectedOption && isCurrentWindow) {//only display these if you are in the menu
					Pixel s = {size.x,options[i].size.y};
					drawRectByPixels(o,s,headerTextColor);//scrollbar to the left
				}
				
				drawTextByPixels(options[i].optionText,optionFont,o,textSizeRatio,optionColor,sizeheader.y);//100% correct
				//printf("3\n");
				if (i == selectedOption && isCurrentWindow) {//only display these if you are in the menu
					//scrollerOrigin.x = o.x;
					//scrollerOrigin.y = o.y;
					if (options[i].optionType == Option_Int) {
						char buf[12];
						//printf("3.1\n");
						snprintf(buf,sizeof(buf),"%i",options[i].getOptionValue().i);
						//printf("3.2\n");
						drawTextByPixels(buf,optionFont,om,textSizeRatio,optionColor,sizeheader.y);//om because it's twice as long so we want the middle
					}
					else if (options[i].optionType == Option_Hex) {
						char buf[12];
						//printf("3.3\n");
						snprintf(buf,sizeof(buf),"0x%X",options[i].getOptionValue().i);
						//printf("3.4\n");
						drawTextByPixels(buf,optionFont,om,textSizeRatio,optionColor,sizeheader.y);
					}
					else if (options[i].optionType == Option_Float) {
						//printf("3.5\n");
						drawTextByPixels(FtoS(options[i].getOptionValue().f),optionFont,om,textSizeRatio,optionColor,sizeheader.y);
						//printf("3.6\n");
					}
					else if (options[i].optionType == Option_String) {
						//printf("3.5\n");
						drawTextByPixels(options[i].getOptionValue().str,optionFont,om,textSizeRatio,optionColor,sizeheader.y);
						//printf("3.6\n");
					}
				}
				if (options[i].optionType == Option_Bool) {
					drawRectByPixels(orm,box10,options[i].getOptionValue().b?trueColor:falseColor,Align_Left,Align_Center);//box
				}
				currentY+=options[i].size.y;
			}
			
			//drawRectByPixels(shiftedOrigin,size,backgroundColor);//100% correct main background
			
			/*if (isCurrentWindow) {
				//draw scroller down here because drawing it under the background shader is bad
				Pixel s = {size.x,optionFontDefaultYSizePixels};
				drawRectByPixels(scrollerOrigin,s,headerTextColor);
			}*/
			sizeheader.x = size.x;
			drawRectByPixels(origin,sizeheader,isCurrentWindow?headerSelectedBackgroundColor:headerColor);//100% correct header background

			drawTextByPixels(header,optionFont,origin,textSizeRatio,isCurrentWindow?headerColor/*this is black*/:headerTextColor,sizeheader.y);//100% correct header text
		}
		void generateOptions(int optionCount) {
			//printf("4\n");
			menuHasBeenFilledWithOptions = true;
			options = (WindowOption*)WUtils::malloc(optionCount*sizeof(WindowOption));
			for (int i = 0; i < optionCount; i++) {
				options[i].create();
			}
			maxOptions = optionCount;
		}
		void setup(int optionCount, char *title,float x, float y) {
			generateOptions(optionCount);
			header = title;
			origin.x = x;
			origin.y = y;
		}
	};


	class WindowHandler {
	public:
		int windowCount;
		Window *windows;
		int selectedWindow;
		//int buttonPressTimeout;
		void create() {
			
		}
		void run() {
			//printf("5\n");
			//this snippet makes sure we are not on an unused window
			while (windows[selectedWindow].menuHasBeenFilledWithOptions == false || windows[selectedWindow].isOpened == false) {
				selectedWindow++;
				if (selectedWindow >= windowCount)
					selectedWindow = 0;
			}

			//printf("6\n");
			//if (buttonPressTimeout > 20) {//this shouldn't be much of a problem in my game cuz in this base it doesn't have a timeout to wait in between scripts
			if (isButtonJustPressed(B_L3)) {//BUTTON L3 WAS PRESSED
				//printf("\n\n\n\nX BUTTON PRESSED!!!\n\n\n\n");
				windows[selectedWindow].options[windows[selectedWindow].selectedOption].callCallback();//option was selected, run it
				//buttonPressTimeout = 0;
			}
			if (isButtonJustPressed(B_Square)) {//BUTTON SQUARE WAS PRESSED
				windows[selectedWindow].options[windows[selectedWindow].selectedOption].editValueWithKeyboard();//option was selected, run it
				//buttonPressTimeout = 0;
			}
			if (isButtonJustPressed(B_DpadLeft)) {//DPAD LEFT WAS PRESSED
				windows[selectedWindow].options[windows[selectedWindow].selectedOption].decreaseValue();//option was selected, run it
				//buttonPressTimeout = 0;
			}
			if (isButtonJustPressed(B_DpadRight)) {//DPAD RIGHT WAS PRESSED
				windows[selectedWindow].options[windows[selectedWindow].selectedOption].increaseValue();//option was selected, run it
				//buttonPressTimeout = 0;
			}
			if (isButtonJustPressed(B_DpadUp)) {//DPAD UP WAS PRESSED
				windows[selectedWindow].scrollDown();//scroll down
				//buttonPressTimeout = 0;
			}
			if (isButtonJustPressed(B_DpadDown)) {//DPAD DOWN WAS PRESSED
				windows[selectedWindow].scrollUp();//scroll up
				//buttonPressTimeout = 0;
			}
			if (isButtonJustPressed(B_R1)) {//R1 WAS PRESSED
				//buttonPressTimeout = 0;
				selectedWindow++;
				while (windows[selectedWindow].menuHasBeenFilledWithOptions == false || windows[selectedWindow].isOpened == false) {
					selectedWindow++;
					if (selectedWindow >= windowCount)
						selectedWindow = 0;
				}
			}
			if (isButtonJustPressed(B_L1)) {//L1 WAS PRESSED
				//buttonPressTimeout = 0;
				selectedWindow--;
				while (windows[selectedWindow].menuHasBeenFilledWithOptions == false || windows[selectedWindow].isOpened == false) {
					selectedWindow--;
					if (selectedWindow < 0)
						selectedWindow = windowCount-1;
				}
			}

			/*
			
			//keyboard manager
			if (GAMEPLAY::UPDATE_ONSCREEN_KEYBOARD() == 1 && globalKeyboardBool == true) {
				//valid result
				globalKeyboardBool = false;
				char *result = GAMEPLAY::GET_ONSCREEN_KEYBOARD_RESULT();
				for (int i = 0; i < windowCount; i++)
					if (windows[i].menuHasBeenFilledWithOptions)
						for (int j = 0; j < windows[i].maxOptions; j++)
							if (windows[i].options[j].awaitingKeyboard)
								windows[i].options[j].keyboardCallback(result);
			}
			else if (GAMEPLAY::UPDATE_ONSCREEN_KEYBOARD() == 2 || GAMEPLAY::UPDATE_ONSCREEN_KEYBOARD() == 3) {
				//invalid
				for (int i = 0; i < windowCount; i++)
					if (windows[i].menuHasBeenFilledWithOptions)
						for (int j = 0; j < windows[i].maxOptions; j++)
							windows[i].options[j].awaitingKeyboard = false;
			}
			
			*/

				//printf("7\n");
			//}
			//buttonPressTimeout++;
			//printf("8\n");
			windows[selectedWindow].runSelected();
			//printf("9\n");
			for (int i = 0; i < windowCount; i++)
				if (windows[i].menuHasBeenFilledWithOptions)
					windows[i].runStandard();
			//printf("3.1\n");
			for (int i = 0; i < windowCount; i++)
				if (windows[i].menuHasBeenFilledWithOptions && windows[i].isOpened)
					windows[i].render(i==selectedWindow);
			//printf("10\n");
		}
		void createWindowPool(int windowCountt) {
			windowCount = windowCountt;
			windows = (Window*)WUtils::malloc(windowCount*sizeof(Window));
			for (int i = 0; i < windowCount; i++) {
				windows[i].create();
			}
		}
	};

	WindowHandler main;
};
using namespace SWindow;




namespace windowUtils {
	void closeAllWindows() {
		for (int i = 0; i < MENUS::Submenus_Count; i++)
			main.windows[i].isOpened = false;
	}
	void openWindow(int id) {
		Window *menu = &main.windows[MENUS::Main];
		menu->isOpened = true;
		menu = &main.windows[id];
		menu->isOpened = true;
	}
	void closeWindow(int id) {
		Window *menu = &main.windows[MENUS::Main];
		menu->isOpened = true;
		menu = &main.windows[id];
		menu->isOpened = false;
	}
	void setMenuOptionName(int windowid, int optionnumber, const char *text) {
		Window *menu = &main.windows[windowid];
		//printf("0x%X\n",(unsigned int)menu);
		menu->options[optionnumber].optionText = (char*)text;
	}
}






```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/WindowSetup.h`:

```h
namespace submenuOpensFuncs {
	void self() {
		windowUtils::closeAllWindows();
		windowUtils::openWindow(MENUS::Self);
		windowUtils::openWindow(MENUS::PrivateLobby);
	}
	void aimbot() {
		windowUtils::closeAllWindows();
		windowUtils::openWindow(MENUS::Aimbot);
		windowUtils::openWindow(MENUS::AimbotPresets);
	}
	void ipaddresses(){
		windowUtils::closeAllWindows();
		windowUtils::openWindow(MENUS::IPs);
		windowUtils::openWindow(MENUS::IP2s);
	}
	void lobbyinfo(){
		windowUtils::closeAllWindows();
		windowUtils::openWindow(MENUS::LobbyInfo);
	}
	void hostmenu(){
		windowUtils::closeAllWindows();
		windowUtils::openWindow(MENUS::Host);
		windowUtils::openWindow(MENUS::Infection);
	}
	void credits(){
		windowUtils::closeAllWindows();
		windowUtils::openWindow(MENUS::Credits);
	}
	void pregame() {
		windowUtils::closeAllWindows();
		windowUtils::openWindow(MENUS::Prelobby);
		windowUtils::openWindow(MENUS::Injector);
		windowUtils::openWindow(MENUS::Name);
	}
};
namespace menuVars {
	char dvarName[50];
	char dvarValue[50];
	OptionValue aimbotToggle;
	OptionValue ESPToggle;
	OptionValue testInt;
	OptionValue testFloat;
	OptionValue selectedPlayer;
	OptionValue zero;
	OptionValue silentaimbot;
	OptionValue requireaiming;
	OptionValue autoshoot;
	OptionValue nospread;
	OptionValue safeaimbot;
	OptionValue checkvisibility;
	OptionValue autowall;
	OptionValue vsat;
	OptionValue norecoil;
	OptionValue snaplines;
	OptionValue entities;
	OptionValue wallhack;
	OptionValue laser;
	OptionValue lag;
	OptionValue dof;
	OptionValue drawgun;
	OptionValue drawfps;
	OptionValue minicrosshair;
	OptionValue forcehost;
	OptionValue dvarname;
	OptionValue dvarvalue;
	OptionValue playerNameInt;
	OptionValue playerPrestigeLevelInt;
	OptionValue playerLevelInt;
	void doMenuVars() {
		//force the windows to show up
		if (main.selectedWindow == MENUS::Main) {
			Window *menu = &main.windows[MENUS::Main];
			menu->options[menu->selectedOption].callback();
		}
		aimbotToggle.b = AimbotStarted;
		ESPToggle.b = ESP;
		zero.i = 0;
		silentaimbot.b = silentAimbot;
		requireaiming.b = Required;
		autoshoot.b = autoShoot;
		nospread.b = NoSpreadToggle;
		safeaimbot.b = safeAimbot;
		checkvisibility.b = Stealth;
		autowall.b = autowallEnabled;//even though it's an int, has to be a bool for the menu to pick up on it properly
		forcehost.b = !(bool)(*(char*)0x1CD6018);
		dvarname.str = dvarName;
		dvarvalue.str = dvarValue;
		
		//begin set player name option
		char *name = (char*)(0x00F9E690+0x148*playerNameInt.i+0x8);
		static char playerName[50];
		snprintf(playerName,sizeof(playerName),"Player: %s",name);
		windowUtils::setMenuOptionName(MENUS::Host,1,playerName);
		//end set player name option



	}
};
namespace optionCallbacks {
	using namespace menuVars;
	void aimbotToggleCallback() {
		AimbotStarted = !AimbotStarted;
	}
	void silentaimbot() {
		silentAimbot = !silentAimbot;
	}
	void requireaiming() {
		Required = !Required;
	}
	void autoshoot() {
		autoShoot = !autoShoot;
	}
	void nospread() {
		NoSpreadToggle = !NoSpreadToggle;
	}
	void safeaimbot() {
		safeAimbot = !safeAimbot;
		print("Recommended to enable. Fix for a bug dealing with out of bounds view angles.");
	}
	void checkvisibility() {
		Stealth = !Stealth;
	}
	void autowall() {
		autowallEnabled = !autowallEnabled;
	}
	void ESPCallback() {
		ESP = !ESP;
	}
	void endgame() {
		endGame();
	}
	void crashServer() {
		Cbuf_AddText(0, "cmd sl");
	}
	void vsatCallback() {
		menuVars::vsat.b = !menuVars::vsat.b;
				if (menuVars::vsat.b) {
					char nop[] = { 0x60, 0x00, 0x00, 0x00 };
					write_process((void*)0x00033C60, &nop, sizeof(nop));//vsat
				} else {
					char rec[] = { 0x40, 0x81, 0x00, 0x44 };
					write_process((void*)0x00033C60, &rec, sizeof(rec));
				}
	}
	void norecoilCallback() {
		norecoil.b = !norecoil.b;
				if (norecoil.b) {
					char nop[] = { 0x60, 0x00, 0x00, 0x00 };
					write_process((void*)0x000F9E54, &nop, sizeof(nop));//no recoil
				} else {
					char rec[] = { 0x48, 0x50, 0x6D, 0x65 };
					write_process((void*)0x000F9E54, &rec, sizeof(rec));
				}
	}
	void snaplinesCallback() {
		SNAPLINES = !SNAPLINES;
		snaplines.b = SNAPLINES;
	}
	void entitiesCallback() {
		entities.b = !entities.b;
				char invisiblebodieson[] = {0x1};
				char invisiblebodiesoff[] = {0x0};
				if (entities.b)
					write_process((void*)0x0076F25B,invisiblebodieson,1);
				else
					write_process((void*)0x0076F25B,invisiblebodiesoff,1);
				
	}
	void wallhackCallback() {
		wallhack.b = !wallhack.b;
				char wallhackon[] = { 0x38, 0xC0, 0xFF, 0xFF};
				char wallhackoff[] = {0x63, 0x26, 0x00, 0x00};
				if (wallhack.b)
					write_process((void*)0x834D0,wallhackon,4);
				else
					write_process((void*)0x834D0,wallhackoff,4);
	}
	void laserCallback() {
		laser.b = !laser.b;
				char laseron[] = {0x2C, 0x03, 0x00, 0x01};
				char laseroff[] = {0x2C, 0x03, 0x00, 0x00};
				if (laser.b)
					write_process((void*)0xEF68C,laseron,4);
				else
					write_process((void*)0xEF68C,laseroff,4);
	}
	void lagCallback() {
		*(char*)(0x1CC56E0 + 0x18) = !*(char*)(0x1CC56E0 + 0x18);
		lag.b = *(char*)(0x1CC56E0 + 0x18);
	}
	void dofCallback() {
		*(char*)(0x1CBFE00 + 0x18) = !*(char*)(0x1CBFE00 + 0x18);
		dof.b = *(char*)(0x1CBFE00 + 0x18);
	}
	void drawgunCallback() {
		*(char*)(0x1CC5020 + 0x18) = !*(char*)(0x1CC5020 + 0x18);
		drawgun.b = *(char*)(0x1CC5020 + 0x18);
	}
	void drawfpsCallback() {
		*(int*)(0x1CC5680 + 0x18) = !*(int*)(0x1CC5680 + 0x18);
		drawfps.b = *(int*)(0x1CC5680 + 0x18);
	}
	void minicrosshairCallback() {
		crosshair = !crosshair;
		minicrosshair.b = crosshair;
	}
	void forcehostCallback() {
		*(char*)0x1CD6018 = (char)(!(bool)(*(char*)0x1CD6018));//party_connectToOthers = 0x1CD6000 + 0x18;
		   //Form1.PS31.SetMemory(30236696u, new byte[1]);//0x1CD6000 + 0x18  party_connectToOthers
                //Form1.PS31.SetMemory(30235163u, new byte[]{1});//party_minplayers = 0x1CD5A00 + 0x18;
                //Form1.PS31.SetMemory(30237851u, new byte[]{1});//party_minLobbyTime = 0x1CD6480 + 0x18;
                //Form1.PS31.SetMemory(30235451u, new byte[]{1});//party_gameStartTimerLength = 0x1CD5B20 + 0x18;
	}
	void switchtoaxis() {
		print("Switched to axis");
		for (int i = 0; i < 0x20; i++)
				runServer("axis",i);
	}
	void switchtoallies() {
		print("Switched to allies");
				for (int i = 0; i < 0x20; i++)
				runServer("allies",i);
	}
	void switchtocodcaster() {
		print("Switched to spectator");
				for (int i = 0; i < 0x20; i++)
				runServer("spectator",i);
	}

	SWindow::OptionValue speedInfectionValue;
	void speedInfection() {
		setDvarAll("g_speed",ItoS(speedInfectionValue.i));
	}
	void presetNoAimbot() {
		setAimbotPreset(aimbotPresets::NoAimbot);
		print("Aimbot is now disabled");
	}
	void presetSANS() {
		setAimbotPreset(aimbotPresets::SilentAimNoSpread);
		print("Great choice");
	}
	void presetHVH() {
		setAimbotPreset(aimbotPresets::SilentAimNoSpreadSuperAutowall);
		print("Utilizes the super autowall function");
	}
	void presetSSTREAK() {
		setAimbotPreset(aimbotPresets::Scorestreak);
		print("Works best in loadstar and dragonfire. Does not work in all scorestreaks.");
	}
	void presetTrickshot() {
		setAimbotPreset(aimbotPresets::Trickshot);
		print("Tap L1/Aim quickly to shoot");
	}
	void changeNameCallback(char *str) {
		//CharlesBabbage
		strcpy((char*)0x026C0658,str);
		strcpy((char*)0x026c067f,str);
	}
	void changeName() {
		keyboard::openKeyboard(changeNameCallback,20);
	}

	void sayInChatCallback(char *str) {
		char buf[300];
		snprintf(buf,sizeof(buf),"cmd say %s\n",str);
		Cbuf_AddText(0,buf);
	}
	void sayInChat() {
		//cmd vsay %s\n
		keyboard::openKeyboard(sayInChatCallback);
	}

	void runCMDCallback(char *str) {
		Cbuf_AddText(0,str);
	}
	void runCMD() {
		keyboard::openKeyboard(runCMDCallback);
	}

	void updateIPList() {
		static char strings[18][200];
		for (int i = 0; i < 18; i++) {
			//0x00F9E690+0x148*0 xuid
			int ip = *(int*)(0x00F9E690+0x148*i+0x96);
			//if (ip != 0 && i != Get_cgs()->localIndex) {
				char *name = (char*)(0x00F9E690+0x148*i+0x8);
				int p1 = (ip&0xff000000)>>24;
				int p2 = (ip&0x00ff0000)>>16;
				int p3 = (ip&0x0000ff00)>>8;
				int p4 = (ip&0x000000ff)>>0;
				if (i != Get_cgs()->localIndex)
					snprintf(strings[i],sizeof(strings[i]),"%s [^1%i.%i.%i.%i^7]",name,p1,p2,p3,p4);
				else
					snprintf(strings[i],sizeof(strings[i]),"%s [^1You!^7]",name);
				addOption(strings[i]);
			//}
		}

		for (int i = 0; i <= 17; i++) {
			windowUtils::setMenuOptionName(MENUS::IP2s,i,strings[i]);
		}
	}

	
	/*
#define min(x,y) (x>y?y:x)
#define max(x,y) (x>y?x:y)
	void setDvarNameCallback(char *str) {
		strncpy(dvarName,str,min(50,strlen(str)));
		windowUtils::setMenuOptionName(MENUS::Infection,0,dvarName);
	}
	void setDvarValueCallback(char *str) {
		strncpy(dvarValue,str,min(50,strlen(str)));
		windowUtils::setMenuOptionName(MENUS::Infection,0,dvarValue);
	}
	void setDvarName() {
		keyboard::openKeyboard(setDvarNameCallback,50);
	}
	void setDvarValue() {
		keyboard::openKeyboard(setDvarValueCallback,50);
	}*/
	void doInfection() {
		if (strlen(dvarName) < 1) {
			print("Dvar name not set! Press Square to edit values");
			return;
		}
		if (strlen(dvarValue) < 1) {
			print("Dvar value not set! Press Square to edit values");
			return;
		}
		setDvarAll(dvarName,dvarValue);
		print("Infection set!");
	}


	void runInfectionString(char *str) {
		int index;
		for (index = 0; index < strlen(str); index++) {
			if (str[index] == ' ')
				break;
		}
		//index is now the position of the first space
		str[index] = 0;
		setDvarAll(str,str+index+1);
		printf("Setting dvar %s with value %s\n",(char*)str,(char*)(str+index+1));
		str[index] = ' ';
	}

	void loadInfections() {
		if (doesFileExist("/dev_hdd0/tmp/gopro_2027/bo2infection.txt")) {
			char *buf = (char*)0x10070000;
			unsigned int fileSize = getFileSize("/dev_hdd0/tmp/gopro_2027/bo2infection.txt");
			readFile("/dev_hdd0/tmp/gopro_2027/bo2infection.txt",buf,fileSize);
			char *currentString = buf;
			for (int i = 0; i < fileSize; i++) {
				if (buf[i] == '\n') {
					buf[i] = 0;
					runInfectionString(currentString);
					buf[i] = '\n';//sets back to normal. Not necessary but whatever
					currentString = (char*)(buf+i+1);
				}
			}
			dialog("Infections set!");
		} else {
			dialog("Please create the file '/dev_hdd0/tmp/gopro_2027/bo2infection.txt' and put your infection code in there.\nThis is an image of the file format for the infections:\nhttp://i.imgur.com/D06p9wj.png\nHave fun and be nice!");
		}
	}

	
	void setPrestigeCallback() {
		//playerPrestigeLevelInt
		//playerNameInt
		setPrestige(playerNameInt.i,playerPrestigeLevelInt.i);
	}
	void setLevelCallback() {
		//playerPrestigeLevelInt
		//playerNameInt
		setLevel(playerNameInt.i,playerLevelInt.i);
	}
#include "bo2dvars.h"
	void dumpDvars() {
		//first dvar 0xD9B540
		dvar_t *dvar = (dvar_t *)(0xD9B540);
		while ((unsigned int)(dvar->hashNext) >= 0x10000) {

			dvar = dvar->hashNext;
			char text[200];
			//unsigned int value = *(unsigned int*)(allBo2Dvars[i]);
			//unsigned int addr = allBo2Dvars[i];
			//unsigned int addrminus18 = allBo2Dvars[i]-0x18;
			//unsigned int flags = *(unsigned int*)(addrminus18+0xc);
			//if (flags & 0x500) {
				snprintf(text,sizeof(text),"%s 0x%X 0x%X\n",dvar->name,(unsigned int)dvar,dvar->flags&0x500);
				appendToFile("/dev_hdd0/tmp/bo2dvarsdump.txt",text,strlen(text));
			//}
		}
	}

	void loadSPRX() {
		loader_sprx("/dev_hdd0/tmp/webm.sprx");
	}

};













char SV_ReceiveStatsSaveData[4*4];
void SV_ReceiveStatsDetour(unsigned int r3, unsigned int r4, unsigned int r5, unsigned int r6);
void SV_ReceiveStatsDetour(unsigned int r3, unsigned int r4, unsigned int r5, unsigned int r6) {
	printf("Started writing data to file\n");
	appendToFile("/dev_hdd0/tmp/gopro_2027/BO2StatsDump.txt",(char*)(0x19CE8BC+8),strlen((char*)(0x19CE8BC+8)));
	appendToFile("/dev_hdd0/tmp/gopro_2027/BO2StatsDump.txt","\n",1);
	printf("Done writing data to file\n");
	opd_s SV_ReceiveStats_t = {0x344148,TOC};
	void(*SV_ReceiveStats)(unsigned int r3, unsigned int r4, unsigned int r5, unsigned int r6) = (void(*)(unsigned int, unsigned int, unsigned int, unsigned int))&SV_ReceiveStats_t;
	memcpy((void*)0x344148,(void*)SV_ReceiveStatsSaveData,4*4);//fix original function
	printf("Calling receive stats\n");
	SV_ReceiveStats(r3,r4,r5,r6);//run original code
	printf("Done calling receive stats\n");
	PatchInJump(0x344148,(int)SV_ReceiveStatsDetour,false);//patch back again
}

void SV_ReceiveStatsDetourStart() {
	//0x19CE8BC+10*10*4 is the read address + size
	memcpy((void*)SV_ReceiveStatsSaveData,(void*)0x344148,4*4);
	PatchInJump(0x344148,(int)SV_ReceiveStatsDetour,false);
}




void setupMenu() {

	//all client ip list (maybe leave out)
	//more infections
	//more names to change to
	//credits
	//lobby info

	//SV_ReceiveStatsDetourStart();


	//setup bool values that are changed on the start:
	menuVars::vsat.b = true;
	menuVars::norecoil.b = true;
	menuVars::drawgun.b = true;

	printf("Doign menu setup\n");
	sleep(10000);
	//allocate space for the windows
	main.createWindowPool(MENUS::Submenus_Count);
	printf("Kek\n");
#pragma region main menu
	{
		//setup window
		Window *menu = &main.windows[MENUS::Main];
		menu->setup(5,"Paradise BO2",300,100);
		menu->isOpened = true;
		//setup options
		WindowOption *options = menu->options;
		options[0].setup("Non-Host",submenuOpensFuncs::self);
		options[1].setup("Aimbot",submenuOpensFuncs::aimbot);
		options[2].setup("IP Addresses",submenuOpensFuncs::ipaddresses);
		//options[3].setup("Lobby Info",submenuOpensFuncs::lobbyinfo);
		options[3].setup("Host Menu",submenuOpensFuncs::hostmenu);
		options[4].setup("Pre-Game Only",submenuOpensFuncs::pregame);
		//options[5].setup("Credits",submenuOpensFuncs::credits);      //TODO
	}
#pragma endregion

#pragma region self menu
	{
		//setup window
		Window *menu = &main.windows[MENUS::Self];
		menu->setup(16,"Public Lobby",500,100);
		//setup options
		WindowOption *options = menu->options;
		options[0].setup("Vsat",optionCallbacks::vsatCallback,Option_Bool,&menuVars::vsat,"");
		options[1].setup("No Recoil",optionCallbacks::norecoilCallback,Option_Bool,&menuVars::norecoil,"");
		options[2].setup("Simple Snaplines",optionCallbacks::snaplinesCallback,Option_Bool,&menuVars::snaplines,"");
		options[3].setup("Simple ESP",optionCallbacks::ESPCallback,Option_Bool,&menuVars::ESPToggle,"Toggle ESP");
		options[4].setup("Invisible Entities",optionCallbacks::entitiesCallback,Option_Bool,&menuVars::entities,"");
		options[5].setup("Wall Hack",optionCallbacks::wallhackCallback,Option_Bool,&menuVars::wallhack,"");
		options[6].setup("Laser",optionCallbacks::laserCallback,Option_Bool,&menuVars::laser,"");
		options[7].setup("Lagometer",optionCallbacks::lagCallback,Option_Bool,&menuVars::lag,"");
		options[8].setup("DOF Debug",optionCallbacks::dofCallback,Option_Bool,&menuVars::dof,"");
		options[9].setup("Draw Gun",optionCallbacks::drawgunCallback,Option_Bool,&menuVars::drawgun,"");
		options[10].setup("Draw FPS",optionCallbacks::drawfpsCallback,Option_Bool,&menuVars::drawfps,"");
		options[11].setup("Mini Crosshair",optionCallbacks::minicrosshairCallback,Option_Bool,&menuVars::minicrosshair,"");
		options[12].setup("End Game",optionCallbacks::endgame);
		options[13].setup("Crash Server",optionCallbacks::crashServer);
		options[14].setup("Say in Chat",optionCallbacks::sayInChat);
		options[15].setup("Run CMD",optionCallbacks::runCMD);
		//options[14].setup("",optionCallbacks::ESPCallback,Option_Bool,&menuVars:,"");
	}
#pragma endregion

#pragma region private lobby menu
	{
		//setup window
		Window *menu = &main.windows[MENUS::PrivateLobby];
		menu->setup(4,"Private Lobby Only",700,100);
		//setup options
		WindowOption *options = menu->options;
		options[0].setup("Switch To Axis",optionCallbacks::switchtoaxis);
		options[1].setup("Switch To Allies",optionCallbacks::switchtoallies);
		options[2].setup("Switch To Spectator",optionCallbacks::switchtocodcaster);
		options[3].setup("Dump dvars",optionCallbacks::dumpDvars);
	}
#pragma endregion

	/*
#pragma region menu
	{
		//setup window
		Window *menu = &main.windows[MENUS::PrivateLobby];
		menu->setup(1,"",500,100);
		//setup options
		WindowOption *options = menu->options;
		//options[0].setup("",optionCallbacks::,Option_Bool,&menuVars:,"");
	}
#pragma endregion
	*/

#pragma region menu
	{
		//setup window
		Window *menu = &main.windows[MENUS::AimbotPresets];
		menu->setup(6,"Presets",700,100);
		//setup options
		WindowOption *options = menu->options;
		options[0].setup("No Aimbot",optionCallbacks::presetNoAimbot);
		options[1].setup("Silent No Spread Autowall",optionCallbacks::presetSANS);
		options[2].setup("HvH Mode",optionCallbacks::presetHVH);
		options[3].setup("Scorestreak Aimbot",optionCallbacks::presetSSTREAK);
		options[4].setup("Non Host Trickshot Aimbot",optionCallbacks::presetTrickshot);
		options[5].setup("Load webm.sprx",optionCallbacks::loadSPRX);
	}
#pragma endregion

#pragma region menu
	{
		//setup window
		Window *menu = &main.windows[MENUS::Injector];
		menu->setup(14,"Inject GSC",700,100);
		//setup options
		WindowOption *options = menu->options;
		options[0].setup("Bossam",injectBossam);
		options[1].setup("Zombieland 1",injectZombieland);
		options[2].setup("Elegance",injectElegance);
		options[3].setup("LOZAZZA",injectLOZAZZA);
		options[4].setup("Avalanche Gamemode",injectAvalanche);
		options[5].setup("Trickshot",injectTrickshot);
		options[6].setup("Hunger Games",injectHunger);
		options[7].setup("Crusher Gamemode",injectCrusher);
		options[8].setup("Inspire",injectInspire);
		options[9].setup("Mike Myers",injectMike);
		options[10].setup("Superman Trickshot",injectSupermanTrickshot);
		options[11].setup("Death Run",injectDeathRun);
		options[12].setup("Zombieland 2",injectZombielandShark);
		options[13].setup("Unload GSC",injector::unloadCurrentGSC);
	}
#pragma endregion

#pragma region menu
	{
		//setup window
		Window *menu = &main.windows[MENUS::Name];
		menu->setup(1,"Name Changer",900,100);
		//setup options
		WindowOption *options = menu->options;
		options[0].setup("Custom Name",optionCallbacks::changeName);
	}
#pragma endregion

#pragma region menu
	{
		//setup window
		Window *menu = &main.windows[MENUS::IPs];
		menu->setup(2,"IP Utils",500,100);
		//setup options
		WindowOption *options = menu->options;
		options[0].setup("Dump IP's To File",ipGrabber);
		options[1].setup("Update IP List",optionCallbacks::updateIPList);
	}
#pragma endregion

#pragma region menu
	{
		//setup window
		Window *menu = &main.windows[MENUS::IP2s];
		menu->setup(18,"IP Addresses",700,100);
		//setup options
		WindowOption *options = menu->options;
		menu->maxOptionsPerPage = 18;
		for (int i = 0; i <= 17; i++) {
			options[i].setup("");
		}
	}
#pragma endregion

#pragma region menu
	{
		//setup window
		Window *menu = &main.windows[MENUS::Host];
		menu->setup(4,"Host Utilities",500,100);
		//setup options
		WindowOption *options = menu->options;
		options[0].setup("Anti-Non Host End Game",antiEndGame);
		options[1].setup("Player",nullfunc,Option_Int,&optionCallbacks::playerNameInt);
		options[2].setup("Set Prestige",optionCallbacks::setPrestigeCallback,Option_Int,&optionCallbacks::playerPrestigeLevelInt);
		options[2].setupMinMax(0,15);
		options[3].setup("Set Level",optionCallbacks::setLevelCallback,Option_Int,&optionCallbacks::playerLevelInt);
		options[3].setupMinMax(0,55);
	}
#pragma endregion

#pragma region menu
	{
		//setup window
		Window *menu = &main.windows[MENUS::Infection];
		menu->setup(4,"Infections",700,100);
		//setup options
		WindowOption *options = menu->options;
		//options[0].setup("Speed",optionCallbacks::speedInfection,SWindow::Option_Int,&optionCallbacks::speedInfectionValue);
		options[0].setup("Dvar Name",nullfunc,Option_String,&optionCallbacks::dvarname);
		options[1].setup("Dvar Value",nullfunc,Option_String,&optionCallbacks::dvarvalue);
		options[2].setup("Set Dvar/Infection",optionCallbacks::doInfection);
		options[3].setup("Load Infections From File",optionCallbacks::loadInfections);
	}
#pragma endregion

#pragma region aimbot menu
	{
		//setup window
		Window *menu = &main.windows[MENUS::Aimbot];
		menu->setup(8,"Aimbot Options",500,100);
		//setup options
		WindowOption *options = menu->options;
		options[0].setup("Aimbot",optionCallbacks::aimbotToggleCallback,Option_Bool,&menuVars::aimbotToggle,"Toggle Aimbot");
		options[1].setup("Silent Aimbot",optionCallbacks::silentaimbot,Option_Bool,&menuVars::silentaimbot,"Like you're not looking at them");
		options[2].setup("Require Aiming",optionCallbacks::requireaiming,Option_Bool,&menuVars::requireaiming,"Must aim to trigger aimbot");
		options[3].setup("Auto Shoot",optionCallbacks::autoshoot,Option_Bool,&menuVars::autoshoot,"Shoots automatically");
		options[4].setup("No Spread",optionCallbacks::nospread,Option_Bool,&menuVars::nospread,"Don't have to aim at all");
		options[5].setup("Check Visibility",optionCallbacks::checkvisibility,Option_Bool,&menuVars::checkvisibility,"Player has to be in sight");
		options[6].setup("Autowall",optionCallbacks::autowall,Option_Bool,&menuVars::autowall,"Players has to be damageable");
		options[7].setup("Safe Aimbot",optionCallbacks::safeaimbot,Option_Bool,&menuVars::safeaimbot,"Helps prevent problems with silent aimbot");
		//options[0].setup("",optionCallbacks:,Option_Bool,&menuVars:,"Info");
	}
#pragma endregion



#pragma region pre lobby menu
	{
		//setup window
		Window *menu = &main.windows[MENUS::Prelobby];
		menu->setup(2,"Pre-Game",500,100);
		//setup options
		WindowOption *options = menu->options;
		options[0].setup("Force Host",optionCallbacks::forcehostCallback,Option_Bool,&menuVars::forcehost,"");
		options[1].setup("Spoof IP",spoofIP);
	}
#pragma endregion


	printf("Finished Menu Setup\n");
}



```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/autowall.h`:

```h
enum TraceHitType
{
    TRACE_HITTYPE_NONE = 0,
    TRACE_HITTYPE_ENTITY = 1,
    TRACE_HITTYPE_DYNENT_MODEL = 2,
    TRACE_HITTYPE_DYNENT_BRUSH = 3,
    TRACE_HITTYPE_DYNENT_UNKNOWN = 4
};
 
#pragma pack(push, 1)
 
struct trace_t
{
    vec3_t normal;
    char unk1[0x04];
    float fraction;
    char unk2[0x08];
    TraceHitType hitType;
    short hitId;
    short modelIndex;
    short partName;
    short partGroup;
    char unk4[0x10];
}; // 0x38
 
#pragma pack(pop)
 
struct BulletFireParams
{
    int weaponEntIndex;
    int ignoreEntIndex;
    float damageMultiplier;
    int methodOfDeath;
    Vector3 origStart;
    Vector3 start;
    Vector3 end;
    Vector3 dir;
}; // 0x40
 
struct BulletTraceResults
{
    trace_t trace;
    int* hitEnt; // gentity_s*
    float hitPos[3];
    int ignoreHitEnt;
    int hitSurfaceType;
}; // 0x50
 
int _BulletTrace = 0xblahblah;
 
float (__cdecl* _BG_GetSurfacePenetrationDepth)(int weaponDefPtr, int surfaceType) = (float(__cdecl*)(int,int))0xfakfak;
 
bool (__cdecl* _BG_AdvanceTrace)(BulletFireParams* bulletFireParams, BulletTraceResults* bulletTraceResults, float amount) = (bool(_cdecl*)(BulletFireParams*,BulletTraceResults*,float))0xmehmeh;
 
bool BulletTrace(BulletFireParams* bulletFireParams, BulletTraceResults* bulletTraceResults, int localClientNum, centity_s* entity, int surfaceType)
{
    bool hit = 0;
    __declspec(align(16)) char save[512];
    _fxsave(save);
    __asm
    {
        push surfaceType
        push entity
        push localClientNum
        mov esi,bulletTraceResults
        mov edi,bulletFireParams
        call _BulletTrace
        mov hit,al
        add esp,0Ch
    }
    _fxrstor(save);
    return hit;
}
 
float BG_GetSurfacePenetrationDepth(int weaponDefPtr, int surfaceType)
{
    return _BG_GetSurfacePenetrationDepth(weaponDefPtr, surfaceType);
}
 
bool BG_AdvanceTrace(BulletFireParams* bulletFireParams, BulletTraceResults* bulletTraceResults, float amount)
{
    return _BG_AdvanceTrace(bulletFireParams, bulletTraceResults, amount);
}
 
float GetAutoWallDamageMultiplier(Vector3 *start, Vector3 *end)
{
    // get our weapon
    int wepid = *(int*)(Centity(Get_cgs()->localIndex)+addresses.wepidcentityoffset/*0x2B4*/);
	int weaponDefPtr = GetWeaponDef(wepid);
    // set up our BulletFireParams struct
    BulletFireParams bulletFireParams;
    memset(&bulletFireParams, 0x00, sizeof(BulletFireParams));
 
    bulletFireParams.weaponEntIndex = 1022;
    bulletFireParams.ignoreEntIndex = *(int*)((int)&cg_entitiesArray[cgArray->clientNum] + 0x1E8);
    bulletFireParams.damageMultiplier = 1.0f;
    bulletFireParams.methodOfDeath = (*(char*)(weaponDefPtr + 0x54D) != 0) + 1;
    VectorCopy(start, &bulletFireParams.origStart);
    VectorCopy(start, &bulletFireParams.start);
    VectorCopy(end, &bulletFireParams.end);
 
    vec3_t dir;
    VectorSubtract(end, start, dir);
    VectorNormalize(dir);
    VectorCopy(dir, bulletFireParams.dir);
 
    // call BulletTrace for the first time and get our BulletTraceResults struct
    BulletTraceResults bulletTraceResults;
    bool hit = BulletTrace(&bulletFireParams, &bulletTraceResults, 0, &cg_entitiesArray[cgArray->clientNum], 0);
 
    // if the result of the bullet trace was TRACE_HITTYPE_NONE, we return the full damage multiplier
    if (!hit)
        return bulletFireParams.damageMultiplier;
 
    // return if the hit type was TRACE_HITTYPE_ENTITY
    if (Trace_GetEntityHitId(&bulletTraceResults.trace) != 1022)
        return 0.0f;
 
    if (*(WORD*)((DWORD)&bulletTraceResults.trace + 40) == 2)
        return 0.0f;
 
    // return if our weapon doesn't penetrate, some weird var from bulletTraceResults.trace is true or some weird weapon shit i dont know
    if (!*(DWORD*)(weaponDefPtr + 36) // if (weaponDefPtr->penetrateType == PENETRATE_TYPE_NONE)
        || *(BYTE*)((DWORD)&bulletTraceResults.trace + 43)
        || *(BYTE*)(weaponDefPtr + 1581)
        )
        return 0.0f;
 
    // we can penetrate a maximum of 5 walls, we loop each wall
    int penetrationCount = 0;
    float perk_bulletPenetrationMultiplier = 2.0f;
    float penetrationDepth;
    BulletFireParams bulletFireParams_2;
    BulletTraceResults bulletTraceResults_2;
    vec3_t hitPosBackup;
    bool hit_2;
    bool v26;
    while (true)
    {
        // get the penetration depth of the hit surface, and apply the perk_bulletPenetrationMultiplier perk if we have it
        // need to test if perk detection works
        penetrationDepth = BG_GetSurfacePenetrationDepth(weaponDefPtr, bulletTraceResults.hitSurfaceType);
        if (*(WORD*)((DWORD)&cg_entitiesArray[cgArray->clientNum] + 678) == 1 && (*(DWORD*)((DWORD)&clientinfo[cgArray->clientNum] + 389756) & 32))
            penetrationDepth *= perk_bulletPenetrationMultiplier;
 
        // we return if our penetration depth is zero or negative
        if (penetrationDepth <= 0.0f)
            return 0.0f;
 
        // backup our latest hit position and advance the trace (return if we can't advance the trace)
        VectorCopy(bulletTraceResults.hitPos, hitPosBackup);
        if (!BG_AdvanceTrace(&bulletFireParams, &bulletTraceResults, 0.13500000536441803f))
            return 0.0f;
 
        // get the wall depth by hitting the face of the surface, then the back of the surface, and saving those hit positions
        hit = BulletTrace(&bulletFireParams, &bulletTraceResults, 0, &cg_entitiesArray[cgArray->clientNum], bulletTraceResults.hitSurfaceType);
 
        memcpy(&bulletFireParams_2, &bulletFireParams, sizeof(BulletFireParams));
 
        VectorScale(bulletFireParams.dir, -1.0f, bulletFireParams_2.dir); // inverse the direction when at the back of the wall
        VectorCopy(bulletFireParams.end, bulletFireParams_2.start);
        VectorMA(hitPosBackup, 0.009999999776482582f, bulletFireParams_2.dir, bulletFireParams_2.end);
 
        memcpy(&bulletTraceResults_2, &bulletTraceResults, sizeof(BulletTraceResults));
 
        VectorScale(bulletTraceResults_2.trace.normal, -1.0f, bulletTraceResults_2.trace.normal);
 
        if (hit)
            BG_AdvanceTrace(&bulletFireParams_2, &bulletTraceResults_2, 0.009999999776482582f);
 
        hit_2 = BulletTrace(&bulletFireParams_2, &bulletTraceResults_2, 0, &cg_entitiesArray[cgArray->clientNum], bulletTraceResults_2.hitSurfaceType);
 
        v26 = (hit_2 != 0) && *(BYTE*)((DWORD)&bulletTraceResults_2.trace + 42) || *(BYTE*)((DWORD)&bulletTraceResults.trace + 43) && *(BYTE*)((DWORD)&bulletTraceResults_2.trace + 43);
 
        if (hit_2 || v26)
            break;
        if (!hit)
        {
            return bulletFireParams.damageMultiplier;
        }
        goto continueLoop;
 
continueLoop:
        if (hit)
        {
            penetrationCount++;
            if (penetrationCount < 5) // max number of surfaces penetrated is 5 (from penetrationCount dvar)
                continue;
        }
 
        return 0.0f;
    }
 
    // calculate the surface depth
    float surfaceDepth = 0.0f;
    if (v26)
        surfaceDepth = Get3DDistance(bulletFireParams_2.start, bulletFireParams_2.end);
    else
        surfaceDepth = Get3DDistance(bulletTraceResults_2.hitPos, hitPosBackup);
    
    // minimum surface depth is 1.0f
    if (surfaceDepth < 1.0f)
        surfaceDepth = 1.0f;
    
    // if we hit the back side of the wall, set the minimum penetration depth of both surfaces hit as our final penetration depth
    if (hit_2)
    {
        float penetrationDepth_2 = BG_GetSurfacePenetrationDepth(weaponDefPtr, bulletTraceResults_2.hitSurfaceType);
        if (*(WORD*)((DWORD)&cg_entitiesArray[cgArray->clientNum] + 678) == 1 && (*(DWORD*)((DWORD)&clientinfo[cgArray->clientNum] + 389756) & 32))
            penetrationDepth_2 *= perk_bulletPenetrationMultiplier;
        
        penetrationDepth = min(penetrationDepth, penetrationDepth_2);
        
        // we return if our penetration depth is zero or negative
        if (penetrationDepth <= 0.0f)
            return 0.0f;
    }
 
    if (*(WORD*)((DWORD)&cg_entitiesArray[cgArray->clientNum] + 678) == 1)
    {
        if (*(DWORD*)((DWORD)&clientinfo[cgArray->clientNum] + 389756) & 32)
        {
LABEL_84:
            if (bulletFireParams.damageMultiplier <= 0.0f)
                return 0.0f;
 
            goto continueLoop;
        }
    }
    
    // decrease our damage multiplier (the fraction)
    bulletFireParams.damageMultiplier -= surfaceDepth / penetrationDepth;
    goto LABEL_84;
 
    // impossibru, this return can't be executed (who cares)
    return 0.0f;
}
```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/autowall2.h`:

```h
//WHAT I NEED TO FIND void CG_SimulateBulletFire_Internal(BulletFireParams *bp, centity_t *attacker)
struct BulletFireParams
{
    int weaponEntIndex;
    int ignoreEntIndex;
    float damageMultiplier;
    int methodOfDeath;
    Vector3 origStart;
    Vector3 start;
    Vector3 end;
    Vector3 dir;
};
opd_s CG_SimulateBulletFire_Internal_t = {0x000EA224,TOC};
void(*CG_SimulateBulletFire_Internal)(BulletFireParams *bp, int centityAttacker) = (void(*)(BulletFireParams,int))&CG_SimulateBulletFire_Internal_t;

/*
class bulletTrace_t  //I think this is actually BulletFireParams based on this post https://www.unknowncheats.me/forum/call-duty-black-ops/99400-perfect-autowall.html
{  //used in CG_SimulateBulletFire_Internal on bo2
public:
    __int32 worldEntNum; //0x0000
    __int32 skipNum; //0x0004
    float power; //0x0008
    __int32 bulletType; //0x000C
    Vector3 vieworg; //0x0010
    Vector3 start; //0x001C
    Vector3 end; //0x0028
    Vector3 viewDirection; //0x0034
};//Size=0x0040
*/
void SetupBulletTrace( BulletFireParams* btr, Vector3 start, Vector3 end, int skipNum )
{
    btr->weaponEntIndex = 2047;
    btr->ignoreEntIndex = skipNum;
    btr->damageMultiplier = 1.0f;
    btr->methodOfDeath = 1;

	//copy view angles
	btr->origStart.x = Get_cgs()->refdefViewAngles[0];
	btr->origStart.y = Get_cgs()->refdefViewAngles[1];
	btr->origStart.z = Get_cgs()->refdefViewAngles[2];
    
	//copy start pos
	btr->start.x = start.x;
	btr->start.y = start.y;
	btr->start.z = start.z;

	//copy end pos
	btr->end.x = end.x;
	btr->end.y = end.y;
	btr->end.z = end.z;
 
    Vector3 delta = end - start;
    //VectorSubtract( end, start, delta );
 
    Vector3 angles;
    VectorAngles( delta, angles );
    AngleVectors( angles, btr->viewDirection, NULL, NULL );
}

/*
typedef void ( __cdecl* oFireBulletPenetrate ) (int localClientNum, bulletTrace_t* btr, int weaponID, centity_t *ent, int minus_1_param, float *tracerStart, bool drawTracer);
oFireBulletPenetrate FireBulletPenetrate = ( oFireBulletPenetrate)0x5A5370;
bool R_BulletPenetrationCheck( bulletTrace_t * pBulletTrace )
{
    DWORD dwAddr = 0x5A2FB0;
    static bool returnC;
    __asm   mov     eax, pBulletTrace
    __asm   call    dwAddr
    __asm   mov    returnC, al
 
    return returnC;
 
}*/
 
bool GetRemainingPower( vec3_t vieworg, centity_t* cent, vec3_t origin, float* remainingPower )
{
    bulletTrace_t bulletTrace;
    SetupBulletTrace( &bulletTrace, vieworg, origin, 0 );
    if(R_BulletPenetrationCheck(&bulletTrace))
    {
    //BYTE Patch3[1]        = {0xC3};
    //BYTE Patch4[1]        = {0x8B};
    //WriteProcessMemory(GetCurrentProcess(), (void*)0x5A5210, &Patch3, 1, 0);
    FireBulletPenetrate(cg->clientNum,&bulletTrace,cg_entities[cg->clientNum].WeaponID,&cg_entities[cg->clientNum],-1,refdef->viewOrg,false);
    //WriteProcessMemory(GetCurrentProcess(), (void*)0x5A5210, &Patch4, 1, 0);
 
    if ( bulletTrace.skipNum == cent->clientNUm)
    {
        *remainingPower = bulletTrace.power;
 
        return true;
    }
    else
    {
        *remainingPower = -0.0f;
 
        return false;
    }
    }
    else
    {
    return false;
    }
```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/aw.h`:

```h
namespace autowall {



typedef float vec_t;
typedef vec_t vec2_t[2];
typedef vec_t vec3_t[3];
typedef vec_t vec4_t[4];
typedef vec_t vec5_t[5];
typedef int DWORD;
typedef short WORD;
typedef char BYTE;
typedef vec_t *pvec3_t;
float Get3DDistance(vec_t *v1, vec_t *v2) {
	float a = v1[0]-v2[0];
	float b = v1[1]-v2[1];
	float c = v1[2]-v2[2];
	return sqrt(a*a+b*b+c*c);
}
/*void VectorCopy(vec_t *original, vec_t *save) {
	save[0] = original[0];
	save[1] = original[1];
	save[2] = original[2];
}

void VectorSubtract(vec_t *end, vec_t *start, vec_t *dir) {
	dir[0] = end[0] - start[0];
	dir[1] = end[1] - start[1];
	dir[2] = end[2] - start[2];
}
*/
void VectorNormalize(vec_t *v){
	float length = sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
    if(length != 0){
        v[0] = v[0]/length;
        v[1] = v[1]/length;
        v[2] = v[2]/length;
    }
}
#define DotProduct(a,b)			((a)[0]*(b)[0]+(a)[1]*(b)[1]+(a)[2]*(b)[2])
#define VectorSubtract(a,b,c)	((c)[0]=(a)[0]-(b)[0],(c)[1]=(a)[1]-(b)[1],(c)[2]=(a)[2]-(b)[2])
#define VectorAdd(a,b,c)		((c)[0]=(a)[0]+(b)[0],(c)[1]=(a)[1]+(b)[1],(c)[2]=(a)[2]+(b)[2])
#define VectorCopy(a,b)			((b)[0]=(a)[0],(b)[1]=(a)[1],(b)[2]=(a)[2])

#define	VectorScale(v, s, o)	((o)[0]=(v)[0]*(s),(o)[1]=(v)[1]*(s),(o)[2]=(v)[2]*(s))
#define	VectorMA(v, s, b, o)	((o)[0]=(v)[0]+(b)[0]*(s),(o)[1]=(v)[1]+(b)[1]*(s),(o)[2]=(v)[2]+(b)[2]*(s))
#define CrossProduct(a,b,c)		((c)[0]=(a)[1]*(b)[2]-(a)[2]*(b)[1],(c)[1]=(a)[2]*(b)[0]-(a)[0]*(b)[2],(c)[2]=(a)[0]*(b)[1]-(a)[1]*(b)[0])

float min(float x, float y) {
	return x > y ? y : x;
}
enum TraceHitType
{
    TRACE_HITTYPE_NONE = 0,
    TRACE_HITTYPE_ENTITY = 1,
    TRACE_HITTYPE_DYNENT_MODEL = 2,
    TRACE_HITTYPE_DYNENT_BRUSH = 3,
    TRACE_HITTYPE_DYNENT_UNKNOWN = 4
};
struct trace_t
{
    vec3_t normal;//0x0
    float fraction;//0xC
    short sflags;
	short cflags;
    TraceHitType hitType;
    short hitId;//0x20
    short modelIndex;
    short partName;
    short partGroup;
    char unk4[0x10];
}; // 0x38

//opd_s Trace_GetEntityHitID_t = {0x306CC0,TOC};
//int(*Trace_GetEntityHitID_a)(int trace) = (int(*)(int))&Trace_GetEntityHitID_t;
int Trace_GetEntityHitID(unsigned int trace) {
	/*__asm("clrldi %r3, %r3, 32");*/
	//Trace_GetEntityHitID_a(trace);


	int r4 = *(int*)(trace+0x1C);
	bool cr0 = r4 == 2;
	int cr1 = r4 == 1;
	int cr6 = r4 == 4;
	int cr7 = r4 == 3;
	if (cr0 == true) {
		return 0x3FE;
	}
	if (cr7 == false) {
		if (cr6 == false) {
			if (cr1 == false) {
				return 0x3FF;
			} else {
				return *(short*)(trace+0x20);
			}
		} else {
			return 0x3FE;
		}
	} else {
		return 0x3FE;
	}
}

 
struct BulletFireParams//I believe this is proper
{
    int worldEntNum;//proper
	int skipNum;//equals 0
    float damageMultiplier;
    int methodOfDeath;//bulletType
    vec3_t origStart;
    vec3_t start;
    vec3_t end;
    vec3_t dir;
}; // 0x40
/*
D014B6C0  00000000 000003FE 3F800000 00000001 C4DB7115 43602935 C07A1800 ........?.........q.C`)5.z..
D014B6DC  C48081D4 44127B19 C034233F 45AE6B1F 45720B20 40E3B8DC 3F6538BE ....D.{..4#?E.k.Er. @...?e8.
D014B6F8  3EE3F9FB 3AB05729 00000000 00000000 00000000 00000000 00000000
struct from memoru
*/
 
struct BulletTraceResults
{
    /*trace_t trace;//THIS NEED TO BE FIXED. THE STRUCTURE.
    int* hitEnt; // gentity_s*
    float hitPos[3];0x2F0-0x8-0xc
    int ignoreHitEnt;0x2F0-0x8
    int hitSurfaceType;*/ //0x2F0
	//hirSurfaceType is at 0x2F0   or 0xF4 or 0x54
	char data[0x2F4];
}; // 0x2F4
struct weaponWeirdData {
	int unknwn1;
	int unknown2;
	int weaponDefPtr;
};
weaponWeirdData wtfisthislolweaponshit;
//opd_s BulletTrace_t = {0x001CF4B8,TOC};
//bool (*BulletTraceO)(int localClientNum, BulletFireParams *bp, int weapDefptr, int centityattacker, BulletTraceResults *br, int lastSurfaceType, bool simulated) = (bool(*)(int, BulletFireParams *, int, int, BulletTraceResults *, int, bool))&BulletTrace_t;
opd_s BulletTrace_t = {0xE9FBC/*0x001CF4B8 Bullet_Trace*/,TOC};//5 args.
/*
r3=00000000D014B6C0  BulletFireParams //proven
r4=000000000135B948  WEAPON DEF POINTER  //proven    return value from sub_606EE0
r5=00000000016B9F20  probably BulletTraceResults
r6=00000000D014B360  CENTITY  //proven
r7=0000000000000000  surface type I think
*/
//int localClientNum, BulletFireParams *bp, int weapDef, int centityattacker, BulletTraceResults *br, int lastSurfaceType, bool simulated
//I want BulletTrace not Bullet_Trace
bool (*BulletTraceO)(int localClientNum, BulletFireParams *bp, unsigned int weapDef, unsigned int centityattacker, BulletTraceResults *br, unsigned int lastSurfaceType, bool simulated) = (bool(*)(int,BulletFireParams *, unsigned int,unsigned int, BulletTraceResults *,unsigned int, bool))&BulletTrace_t;
bool BulletTrace(BulletFireParams* bulletFireParams, BulletTraceResults* bulletTraceResults, unsigned int localClientNum, unsigned int centity, unsigned int surfaceType)
{
	int wepid = *(int*)(Centity(Get_cgs()->localIndex)+0x2B4);
	//0x606EE0
	//opd_s unkfunk_t = {0x606EE0,TOC};//weapon def variant
	//int (*unkfunk)(int wepid) = (int(*)(int))&unkfunk_t;
	int weaponDefPtr = GetWeaponDef(wepid);
	//printf("WeaponDefPtr: %x, *(int*)(weaponDefPtr+0x8): %x\n",weaponDefPtr,*(int*)(weaponDefPtr+0x8));
	//wtfisthislolweaponshit.weaponDefPtr = weaponDefPtr;
	//if (weaponDefPtr < 0x10000)
		//return false;
	return BulletTraceO(localClientNum,bulletFireParams,weaponDefPtr,centity,bulletTraceResults,surfaceType,false);
	//return BulletTraceO(bulletFireParams,/*0x0135B948*//*(int)&wtfisthislolweaponshit*/weaponDefPtr,bulletTraceResults,centity,surfaceType);
    /*bool hit = 0;
    __declspec(align(16)) char save[512];
    _fxsave(save);
    __asm
    {
        push surfaceType
        push entity
        push localClientNum
        mov esi,bulletTraceResults
        mov edi,bulletFireParams
        call _BulletTrace
        mov hit,al
        add esp,0Ch
    }
    _fxrstor(save);
    return hit;*/
}
 
 //0x005EFFC0
opd_s BG_GetSurfacePenetrationDepth_t = {0x005EFFC0,TOC};
float (*BG_GetSurfacePenetrationDepth)(unsigned int weaponDefPtr, unsigned int surfaceType) = (float(*)(unsigned int,unsigned int))&BG_GetSurfacePenetrationDepth_t;
 
opd_s BG_AdvanceTrace_t = {0x005EFE18,TOC};
bool (*BG_AdvanceTrace)(BulletFireParams* bulletFireParams, BulletTraceResults* bulletTraceResults, float amount) = (bool(*)(BulletFireParams*,BulletTraceResults*,float))&BG_AdvanceTrace_t;
 


opd_s FireBulletPenetrate_t = {0x000EAC28,TOC};
void (*FireBulletPenetrate)(int localClientNum, BulletFireParams* bulletFireParams, int weaponIndex, unsigned int centityAttacker, unsigned int pointerToViewPoint, bool unknwon, bool unknwon2, BulletTraceResults *btr) = (void(*)(int,BulletFireParams*,int,unsigned int, unsigned int, bool, bool, BulletTraceResults *))&FireBulletPenetrate_t;

char blr[4] = { 0x4E, 0x80, 0x00, 0x20 };
char nop[4] = { 0x60, 0x00, 0x00, 0x00 };
char patch0[4] = { 0xF8, 0x21, 0xFE, 0xC1 };
char patch1[4] = { 0xF8, 0x21, 0xFE, 0xE1 };
//int tmpdsgfhasedfrh = 0;
bool isTargetHitable(pvec3_t start, pvec3_t end/*,int targetClient*//*int localClient, int targetClient, char* tagName*/, int targetClientNum) {
	//if (!cEntityz(localClient)->Alive)return false;

	//write_process(0xB5EA8, blr, 4);
	//write_process(0x14A6D8, blr, 4);
	//write_process(0xBC854, nop, 4);

	/*Vector3 PlayerOrigin;
	if(!GetTagPos(targetClient, tagName, PlayerOrigin)) return;

	BulletFireParams bp;
	bp.MaxEntNum = 2046;
	bp.ignoreEntIndex = localClient;
	bp.damageMultiplier = 1.0f;
	bp.methodOfDeath = 2;

	Memcpy(&bp.origStart, &refdef->ViewOrigin);
	Memcpy(&bp.start, &refdef->ViewOrigin, 12);
	Memcpy(&bp.end, &PlayerOrigin, 12);
	*/
	BulletTraceResults bulletTraceResults;
	BulletFireParams bulletFireParams;
    memset(&bulletFireParams, 0x00, sizeof(BulletFireParams));
 
    bulletFireParams.worldEntNum = 1022;//0x3FE
    bulletFireParams.skipNum = 0;//Centity(Get_cgs()->localIndex);//*(DWORD*)((DWORD)&cg_entitiesArray[cgArray->clientNum] + 488);
    bulletFireParams.damageMultiplier = 1.0f;
    bulletFireParams.methodOfDeath = 1;//(*(BYTE*)(weaponDefPtr + 1357) != 0) + 1;   like I care what this deos right now
    VectorCopy(start, bulletFireParams.origStart);
    VectorCopy(start, bulletFireParams.start);
    VectorCopy(end, bulletFireParams.end);

	/*Vector3 angles; VectoAngles(&SubstractVector(PlayerOrigin, refdef->ViewOrigin), &angles);
	bp.dir = AnglesToForward_0(angles);*/
	vec3_t dir;
    VectorSubtract(end, start, dir);
    VectorNormalize(dir);
    VectorCopy(dir, bulletFireParams.dir);
	//hi:
	int wepid = *(int*)(Centity(Get_cgs()->localIndex)+0x2B4);
	//printf("Centity: 0x%x\n",Centity(Get_cgs()->localIndex));
	//if (tmpdsgfhasedfrh == 0)
	write_process((void*)addresses.CG_BulletHitEvent_Patch/*0x000E9BE8*/,blr,4);//CG_BulletHitEvent
	write_process((void*)addresses.Tracer_Spawn_Patch/*0x0045C038*/,blr,4);//Tracer_Spawn
		FireBulletPenetrate(0, &bulletFireParams, wepid, Centity(Get_cgs()->localIndex), (unsigned int)&(Get_cgs()->refdef.viewOrigin), 1,1,&bulletTraceResults);
	write_process((void*)addresses.CG_BulletHitEvent_Patch/*0x000E9BE8*/,patch0,4);//CG_BulletHitEvent
	write_process((void*)addresses.Tracer_Spawn_Patch/*0x0045C038*/,patch1,4);//Tracer_Spawn
	//0x000EB188 maybe this to disable sound? nah
	//tmpdsgfhasedfrh++;
	//if (tmpdsgfhasedfrh > 100)
		//tmpdsgfhasedfrh = 0;
	//write_process(0xB5EA8, patch0, 4);
	//write_process(0x14A6D8, patch1, 4);
	//printf("Damage: %x\n",*(unsigned int*)&bulletFireParams.damageMultiplier);
	unsigned int traceResultTrace = (unsigned int)&bulletTraceResults;
	/*if (bulletFireParams.damageMultiplier > 0.0f) {
		return true;
		//BG_AdvanceTrace(&bulletFireParams,&bulletTraceResults,1.13500000536441803f);
		//goto hi;
	}*/
	return (bulletFireParams.skipNum == targetClientNum);
	if (/*Trace_GetEntityHitID(traceResultTrace) != 1022*/bulletFireParams.skipNum == targetClientNum/* && bulletFireParams.damageMultiplier > 0.0f && bulletFireParams.damageMultiplier < 1.0f*/)//returns here
        return true;
	/*if (bulletFireParams.damageMultiplier >= 1.0f)
		return false;
	if (bulletFireParams.damageMultiplier > 0.0f)//can be changed
		return true;*/
	return false;
	//return bulletFireParams.damageMultiplier;
	//return (bulletFireParams.unknwon/*ignoreEntIndex*/ == targetClient); //8----->
}





float GetAutoWallDamageMultiplier(pvec3_t start, pvec3_t end)
{
	if (autowallEnabled == false)
		return 0.0;
	if (allowAutowall == false)
		return 0.0;
    // get our weapon
	int wepid = *(int*)(Centity(Get_cgs()->localIndex)+0x2B4);
	int weaponDefPtr = GetWeaponDef(wepid);
	//printf("Got wep id %i %i %i\n",weaponDefPtr,(int)*(char*)(weaponDefPtr+0x2b),(int)*(char*)(weaponDefPtr+0x2f));
 
    // set up our BulletFireParams struct
    BulletFireParams bulletFireParams;
    memset(&bulletFireParams, 0x00, sizeof(BulletFireParams));
 
    bulletFireParams.worldEntNum = 1022;
    //bulletFireParams.ignoreEntIndex = Centity(Get_cgs()->localIndex);//*(DWORD*)((DWORD)&cg_entitiesArray[cgArray->clientNum] + 488);
    bulletFireParams.damageMultiplier = 1.0f;
    bulletFireParams.methodOfDeath = 1;//(*(BYTE*)(weaponDefPtr + 1357) != 0) + 1;   like I care what this deos right now
    VectorCopy(start, bulletFireParams.origStart);
    VectorCopy(start, bulletFireParams.start);
    VectorCopy(end, bulletFireParams.end);
 
    vec3_t dir;
    VectorSubtract(end, start, dir);
    VectorNormalize(dir);
    VectorCopy(dir, bulletFireParams.dir);
	//printf("Initialized shit\n");
 
    // call BulletTrace for the first time and get our BulletTraceResults struct
    BulletTraceResults bulletTraceResults;
    int hit = BulletTrace(&bulletFireParams, &bulletTraceResults, 0, Centity(Get_cgs()->localIndex)/*&cg_entitiesArray[cgArray->clientNum]*/, 0);
	//printf("did the first BulletTrace %i %i\n",*(int*)(&bulletFireParams.damageMultiplier),hit);
    // if the result of the bullet trace was TRACE_HITTYPE_NONE, we return the full damage multiplier
    if (hit == false)//means it hit the entity
        return bulletFireParams.damageMultiplier;
//#ifdef appleslololol
	//printf("There was not a hit\n");
    // return if the hit type was TRACE_HITTYPE_ENTITY
	unsigned int traceResultTrace = (unsigned int)&bulletTraceResults;
    if (Trace_GetEntityHitID(traceResultTrace) != 1022)//returns here
        return 1.0f;
	//printf("Yayy! It's a proper hit!: %x hit:%i\n",*(unsigned int*)(&bulletFireParams.damageMultiplier),hit);
	//float pen = BG_GetSurfacePenetrationDepth(*(DWORD*)(weaponDefPtr + 36)/*weaponDefPtr*/, *(unsigned int*)(&bulletTraceResults+0x54));//0x24
	//return pen > 0.0f ? pen: 0.0f;




//#ifdef appleslololol


	//printf("Got entity hit id\n");
    //if (*(WORD*)((DWORD)&bulletTraceResults.trace + 40) == 2)
        //return 0.0f;
	//printf("Not sure what is here but it worked\n");
    // return if our weapon doesn't penetrate, some weird var from bulletTraceResults.trace is true or some weird weapon shit i dont know
    /*if (!*(DWORD*)(weaponDefPtr + 36) // if (weaponDefPtr->penetrateType == PENETRATE_TYPE_NONE)
        || *(BYTE*)((DWORD)bulletTraceResults.data + 43)
        || *(BYTE*)(weaponDefPtr + 1581)
        )
        return 0.0f;*/
	//printf("btrdata: %i %i\n",*(BYTE*)((DWORD)bulletTraceResults.data + 43), *(BYTE*)((DWORD)bulletTraceResults.data + 47));
	//return 0;
	if (*(DWORD*)(weaponDefPtr + 36) == 0 // if (weaponDefPtr->penetrateType == PENETRATE_TYPE_NONE)
        /*|| *(BYTE*)((DWORD)bulletTraceResults.data + 43)//not sure if this
		|| *(BYTE*)((DWORD)bulletTraceResults.data + 47)//or this
        || *(BYTE*)(weaponDefPtr + 1585) == 0*/
        )
        return 0.0f;
	//printf("yea...\n");
    // we can penetrate a maximum of 5 walls, we loop each wall
    int penetrationCount = 0;
    float perk_bulletPenetrationMultiplier = 2.0f;
    float penetrationDepth;
    BulletFireParams bulletFireParams_2;
    BulletTraceResults bulletTraceResults_2;
    vec3_t hitPosBackup;
    bool hit_2;
    bool v26;
	int loopcount = 0;
    while (true)
    {
		//printf("In loop %i\n",loopcount);
		loopcount++;
        // get the penetration depth of the hit surface, and apply the perk_bulletPenetrationMultiplier perk if we have it
        // need to test if perk detection works
		//printf("Bullet Trace Results addr: %i surface: %i %i\n",(unsigned int)&bulletTraceResults,*(unsigned int*)(bulletTraceResults.data+0xF4),*(unsigned int*)(bulletTraceResults.data+0x54));
        penetrationDepth = BG_GetSurfacePenetrationDepth(*(DWORD*)(weaponDefPtr + 36)/*weaponDefPtr*/,*(unsigned int*)(bulletTraceResults.data+0x54));
        //if (*(WORD*)((DWORD)&cg_entitiesArray[cgArray->clientNum] + 678) == 1 && (*(DWORD*)((DWORD)&clientinfo[cgArray->clientNum] + 389756) & 32))
            //penetrationDepth *= perk_bulletPenetrationMultiplier;
		//printf("heya %i\n",*(unsigned int*)&penetrationDepth);
        // we return if our penetration depth is zero or negative
        if (penetrationDepth <= 0.0f)
            return 0.0f;
		//else
			//return 1.0f;
		//printf("ohoh\n");

		/*VectorCopy(*(vec3_t*)(&bulletTraceResults+0x40),bulletFireParams.start);
		VectorCopy(*(vec3_t*)(&bulletTraceResults+0x40),bulletFireParams.origStart);
		VectorCopy(end,bulletFireParams.end);*/
		BG_AdvanceTrace(&bulletFireParams, &bulletTraceResults, 1.13500000536441803f);
		//VectorCopy(bulletFireParams.end, bulletFireParams.start);
		//VectorMA(bulletFireParams.start, 2, bulletFireParams.dir, *(vec3_t*)(&bulletTraceResults+/*0x2dc*/0x54-0x14));
		hit = BulletTrace(&bulletFireParams, &bulletTraceResults, 0, Centity(Get_cgs()->localIndex), *(unsigned int*)(bulletTraceResults.data+0x54)/*bulletTraceResults.hitSurfaceType*/);
		
		unsigned int traceResultTrace = (unsigned int)&bulletTraceResults;
		//return Trace_GetEntityHitID(traceResultTrace) != 1022?1.0:0.0;

		bulletFireParams.damageMultiplier -= 1.13500000536441803f / penetrationDepth;
		//printf("Damage Multiplier: %x\n",*(unsigned int*)&bulletFireParams.damageMultiplier);
		if (Trace_GetEntityHitID(traceResultTrace) != 1022)//returns here
			return bulletFireParams.damageMultiplier;
		else
			return 0.0f;















        // backup our latest hit position and advance the trace (return if we can't advance the trace)
        VectorCopy(*(vec3_t*)(&bulletTraceResults+/*0x2dc*/0x54-0x14), hitPosBackup);
        if (!BG_AdvanceTrace(&bulletFireParams, &bulletTraceResults, 0.13500000536441803f))
            return 0.0f;
		//printf("Did some advance trace\n");
        // get the wall depth by hitting the face of the surface, then the back of the surface, and saving those hit positions
        hit = BulletTrace(&bulletFireParams, &bulletTraceResults, 0, Centity(Get_cgs()->localIndex), *(unsigned int*)(bulletTraceResults.data+0x54)/*bulletTraceResults.hitSurfaceType*/);
		
		//printf("did some bullet trace\n");
        memcpy(&bulletFireParams_2, &bulletFireParams, sizeof(BulletFireParams));
 
        VectorScale(bulletFireParams.dir, -1.0f, bulletFireParams_2.dir); // inverse the direction when at the back of the wall
        VectorCopy(bulletFireParams.end, bulletFireParams_2.start);
        VectorMA(hitPosBackup, 0.009999999776482582f, bulletFireParams_2.dir, bulletFireParams_2.end);
 
        memcpy(&bulletTraceResults_2, &bulletTraceResults, sizeof(BulletTraceResults));
 
        VectorScale(*(vec3_t*)&bulletTraceResults_2, -1.0f, *(vec3_t*)&bulletTraceResults_2);
		//printf("scaled a vector\n");
        if (hit)
            BG_AdvanceTrace(&bulletFireParams_2, &bulletTraceResults_2, 0.009999999776482582f);
		//printf("more shit\n");
        hit_2 = BulletTrace(&bulletFireParams_2, &bulletTraceResults_2, 0, Centity(Get_cgs()->localIndex), *(unsigned int*)(bulletTraceResults_2.data+0x54)/*bulletTraceResults_2.hitSurfaceType*/);
		
		//printf("even more shit\n");
        v26 = (hit_2 != 0) && *(BYTE*)((DWORD)&bulletTraceResults_2/*.trace*/ + 42) || *(BYTE*)((DWORD)&bulletTraceResults/*.trace*/ + 43) && *(BYTE*)((DWORD)&bulletTraceResults_2/*.trace*/ + 43);
		//printf("am I loco shit\n");
        if (hit_2 || v26)
            break;
        if (!hit)
        {
            return bulletFireParams.damageMultiplier;
        }
        goto continueLoop;
 
continueLoop:
        if (hit)
        {
            penetrationCount++;
            if (penetrationCount < 5) // max number of surfaces penetrated is 5 (from penetrationCount dvar)
                continue;
        }
 
        //return 0.0f;
    }
 
    // calculate the surface depth
    float surfaceDepth = 0.0f;
	//printf("About to calc 3d\n");
    if (v26)
        surfaceDepth = Get3DDistance(bulletFireParams_2.start, bulletFireParams_2.end);
    else
        surfaceDepth = Get3DDistance(*(vec3_t*)(&bulletTraceResults_2+/*0x2dc*/0x54-0x14), hitPosBackup);
    //printf("calculated some 3d\n");
    // minimum surface depth is 1.0f
    if (surfaceDepth < 1.0f)
        surfaceDepth = 1.0f;
    
    // if we hit the back side of the wall, set the minimum penetration depth of both surfaces hit as our final penetration depth
    if (hit_2)
    {
        float penetrationDepth_2 = BG_GetSurfacePenetrationDepth(*(DWORD*)(weaponDefPtr + 36)/*weaponDefPtr*/, *(unsigned int*)(bulletTraceResults_2.data+0x54)/*bulletTraceResults_2.hitSurfaceType*/);
		//printf("kekekekekekek\n");
        //if (*(WORD*)((DWORD)&cg_entitiesArray[cgArray->clientNum] + 678) == 1 && (*(DWORD*)((DWORD)&clientinfo[cgArray->clientNum] + 389756) & 32))
            //penetrationDepth_2 *= perk_bulletPenetrationMultiplier;
        //printf("calced da min: %i %i\n",*(int*)(&penetrationDepth),*(int*)(&penetrationDepth_2));
        penetrationDepth = min(penetrationDepth, penetrationDepth_2);
        
        // we return if our penetration depth is zero or negative
        if (penetrationDepth <= 0.0f)
            return 0.0f;
    }
 bulletFireParams.damageMultiplier -= surfaceDepth / penetrationDepth;
   /* if (*(WORD*)((DWORD)&cg_entitiesArray[cgArray->clientNum] + 678) == 1)
    {
        if (*(DWORD*)((DWORD)&clientinfo[cgArray->clientNum] + 389756) & 32)
        {
LABEL_84:*/
            /*if (bulletFireParams.damageMultiplier <= 0.0f)
                return 0.0f;
 
            goto continueLoop;*/
        //}
    
    // decrease our damage multiplier (the fraction)
    //bulletFireParams.damageMultiplier -= surfaceDepth / penetrationDepth;
    //goto LABEL_84;
 
    // impossibru, this return can't be executed (who cares)
	//printf("came to end\n");
    return bulletFireParams.damageMultiplier;
//#endif
}






}
```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/bo2dvars.h`:

```h
unsigned int allBo2Dvars[] = {
 0x1CCAFC0 + 0x18,
 0x1CD90C0 + 0x18,
 0x1CD8F40 + 0x18,
 0x1CD8FA0 + 0x18,
 0x1CD9060 + 0x18,
 0x1CD9000 + 0x18,
 0x1CB3C80 + 0x18,
 0x1CA5580 + 0x18,
 0x1CA55E0 + 0x18,
 0x1CA5520 + 0x18,
 0x1CA56A0 + 0x18,
 0x1CA6180 + 0x18,
 0x1CA5BE0 + 0x18,
 0x1CA5EE0 + 0x18,
 0x1CA62A0 + 0x18,
 0x1CA5A60 + 0x18,
 0x1CA5AC0 + 0x18,
 0x1CA5B80 + 0x18,
 0x1CA5B20 + 0x18,
 0x1CA60C0 + 0x18,
 0x1CA6240 + 0x18,
 0x1CA61E0 + 0x18,
 0x1CA5C40 + 0x18,
 0x1CA6840 + 0x18,
 0x1CA6720 + 0x18,
 0x1CA6780 + 0x18,
 0x1CA64E0 + 0x18,
 0x1CA6540 + 0x18,
 0x1CA6300 + 0x18,
 0x1CA6360 + 0x18,
 0x1CA65A0 + 0x18,
 0x1CA6660 + 0x18,
 0x1CA63C0 + 0x18,
 0x1CA6480 + 0x18,
 0x1CA67E0 + 0x18,
 0x1CA6600 + 0x18,
 0x1CA6420 + 0x18,
 0x1CA66C0 + 0x18,
 0x1CA6A80 + 0x18,
 0x1CA6AE0 + 0x18,
 0x1CA6B40 + 0x18,
 0x1CA6D20 + 0x18,
 0x1CA6CC0 + 0x18,
 0x1CA6C60 + 0x18,
 0x1CA6BA0 + 0x18,
 0x1CA6C00 + 0x18,
 0x1CA5CA0 + 0x18,
 0x1CA6000 + 0x18,
 0x1CA5DC0 + 0x18,
 0x1CA6060 + 0x18,
 0x1CA5D60 + 0x18,
 0x1CA5E20 + 0x18,
 0x1CA6960 + 0x18,
 0x1CA69C0 + 0x18,
 0x1CA68A0 + 0x18,
 0x1CA6900 + 0x18,
 0x1CA5F40 + 0x18,
 0x1CA5D00 + 0x18,
 0x1CA5FA0 + 0x18,
 0x1CA5A00 + 0x18,
 0x1CA57C0 + 0x18,
 0x1CA5820 + 0x18,
 0x1CA5700 + 0x18,
 0x1CA5760 + 0x18,
 0x1CA59A0 + 0x18,
 0x1CA5940 + 0x18,
 0x1CA5E80 + 0x18,
 0x1CA5880 + 0x18,
 0x1CA58E0 + 0x18,
 0x1CA6120 + 0x18,
 0x1CA5400 + 0x18,
 0x1CA5460 + 0x18,
 0x1CA53A0 + 0x18,
 0x1CA54C0 + 0x18,
 0x1CA6A20 + 0x18,
 0x1CA5640 + 0x18,
 0x1CA5220 + 0x18,
 0x1CA5340 + 0x18,
 0x1CA5280 + 0x18,
 0x1CA52E0 + 0x18,
 0x1CEA160 + 0x18,
 0x1CEA100 + 0x18,
 0x1CEA1C0 + 0x18,
 0x1CE9C80 + 0x18,
 0x1CEAD60 + 0x18,
 0x1CEAEE0 + 0x18,
 0x1CEB060 + 0x18,
 0x1CEB000 + 0x18,
 0x1CEAE20 + 0x18,
 0x1CEB180 + 0x18,
 0x1CEB120 + 0x18,
 0x1CEA6A0 + 0x18,
 0x1CEA640 + 0x18,
 0x1CEA5E0 + 0x18,
 0x1CEA760 + 0x18,
 0x1CEA700 + 0x18,
 0x1CE9CE0 + 0x18,
 0x1CEAB20 + 0x18,
 0x1CEA820 + 0x18,
 0x1CEA7C0 + 0x18,
 0x1CEA880 + 0x18,
 0x1CEAA00 + 0x18,
 0x1CEAAC0 + 0x18,
 0x1CEAA60 + 0x18,
 0x1CEA9A0 + 0x18,
 0x1CEA940 + 0x18,
 0x1CEA8E0 + 0x18,
 0x1CE9E00 + 0x18,
 0x1CE9DA0 + 0x18,
 0x1CE9E60 + 0x18,
 0x1CEA0A0 + 0x18,
 0x1CEA040 + 0x18,
 0x1CEACA0 + 0x18,
 0x1CEAD00 + 0x18,
 0x1CEAC40 + 0x18,
 0x1CEAE80 + 0x18,
 0x1CEAFA0 + 0x18,
 0x1CEAF40 + 0x18,
 0x1CEADC0 + 0x18,
 0x1CEB0C0 + 0x18,
 0x1CEA280 + 0x18,
 0x1CEA220 + 0x18,
 0x1CEA460 + 0x18,
 0x1CEA4C0 + 0x18,
 0x1CEA400 + 0x18,
 0x1CEA3A0 + 0x18,
 0x1CEA340 + 0x18,
 0x1CEA2E0 + 0x18,
 0x1CEA520 + 0x18,
 0x1CEA580 + 0x18,
 0x1CE9A40 + 0x18,
 0x1CE9AA0 + 0x18,
 0x1CE99E0 + 0x18,
 0x1CE9D40 + 0x18,
 0x1CE9B60 + 0x18,
 0x1CE9920 + 0x18,
 0x1CE9980 + 0x18,
 0x1CE9B00 + 0x18,
 0x1CEB1E0 + 0x18,
 0x1CE98C0 + 0x18,
 0x1CE9860 + 0x18,
 0x1CE9C20 + 0x18,
 0x1CE9EC0 + 0x18,
 0x1CE9F20 + 0x18,
 0x1CE9F80 + 0x18,
 0x1CE9FE0 + 0x18,
 0x1CEAB80 + 0x18,
 0x1CAABC0 + 0x18,
 0x1CB8840 + 0x18,
 0x1CA3F00 + 0x18,
 0x1CE0800 + 0x18,
 0x1CE07A0 + 0x18,
 0x1CD7CE0 + 0x18,
 0x1CD7C80 + 0x18,
 0x1CD3720 + 0x18,
 0x1CD83A0 + 0x18,
 0x1CD8460 + 0x18,
 0x1CD8400 + 0x18,
 0x1CD84C0 + 0x18,
 0x1CCAF60 + 0x18,
 0x1CB92C0 + 0x18,
 0x1CB9320 + 0x18,
 0x1CB9140 + 0x18,
 0x1CB91A0 + 0x18,
 0x1CB9200 + 0x18,
 0x1CB9260 + 0x18,
 0x1CB90E0 + 0x18,
 0x1CDAFE0 + 0x18,
 0x1CDD260 + 0x18,
 0x1CE7580 + 0x18,
 0x1CE79A0 + 0x18,
 0x1CE7880 + 0x18,
 0x1CE7A00 + 0x18,
 0x1CE7A60 + 0x18,
 0x1CE76A0 + 0x18,
 0x1CE77C0 + 0x18,
 0x1CE75E0 + 0x18,
 0x1CE7940 + 0x18,
 0x1CE78E0 + 0x18,
 0x1CE7820 + 0x18,
 0x1CE7640 + 0x18,
 0x1CE7520 + 0x18,
 0x1CE7700 + 0x18,
 0x1CE7760 + 0x18,
 0x1CE73A0 + 0x18,
 0x1CE7400 + 0x18,
 0x1CE74C0 + 0x18,
 0x1CE7460 + 0x18,
 0x1CB3C20 + 0x18,
 0x1CAC8A0 + 0x18,
 0x1CB3B60 + 0x18,
 0x1CB3BC0 + 0x18,
 0x1CAC1E0 + 0x18,
 0x1CAC120 + 0x18,
 0x1CAAF20 + 0x18,
 0x1CAB2E0 + 0x18,
 0x1CAB3A0 + 0x18,
 0x1CAAFE0 + 0x18,
 0x1CAAF80 + 0x18,
 0x1CAB1C0 + 0x18,
 0x1CAB460 + 0x18,
 0x1CAB160 + 0x18,
 0x1CAB340 + 0x18,
 0x1CAB400 + 0x18,
 0x1CAB100 + 0x18,
 0x1CAB0A0 + 0x18,
 0x1CAB220 + 0x18,
 0x1CAB040 + 0x18,
 0x1CB02C0 + 0x18,
 0x1CAD260 + 0x18,
 0x1CAD320 + 0x18,
 0x1CAD2C0 + 0x18,
 0x1CABA60 + 0x18,
 0x1CABA00 + 0x18,
 0x1CAB8E0 + 0x18,
 0x1CAB820 + 0x18,
 0x1CAB7C0 + 0x18,
 0x1CAB940 + 0x18,
 0x1CAB880 + 0x18,
 0x1CAC960 + 0x18,
 0x1CAC180 + 0x18,
 0x1CAC780 + 0x18,
 0x1CAF9C0 + 0x18,
 0x1CB0380 + 0x18,
 0x1CAB700 + 0x18,
 0x1CABD00 + 0x18,
 0x1CABD60 + 0x18,
 0x1CABCA0 + 0x18,
 0x1CAFA20 + 0x18,
 0x1CAC900 + 0x18,
 0x1CAFA80 + 0x18,
 0x1CAAEC0 + 0x18,
 0x1CB0320 + 0x18,
 0x1CAC9C0 + 0x18,
 0x1CAB760 + 0x18,
 0x1CABC40 + 0x18,
 0x1CB1100 + 0x18,
 0x1CB0260 + 0x18,
 0x1CB01A0 + 0x18,
 0x1CB0200 + 0x18,
 0x1CB0140 + 0x18,
 0x1CAEF40 + 0x18,
 0x1CAED00 + 0x18,
 0x1CAEE80 + 0x18,
 0x1CAED60 + 0x18,
 0x1CAEDC0 + 0x18,
 0x1CAEE20 + 0x18,
 0x1CAEEE0 + 0x18,
 0x1CAE700 + 0x18,
 0x1CAE6A0 + 0x18,
 0x1CAE7C0 + 0x18,
 0x1CAE760 + 0x18,
 0x1CAE640 + 0x18,
 0x1CAE940 + 0x18,
 0x1CAEB80 + 0x18,
 0x1CAE580 + 0x18,
 0x1CAE5E0 + 0x18,
 0x1CAE9A0 + 0x18,
 0x1CAEA00 + 0x18,
 0x1CAE4C0 + 0x18,
 0x1CAEAC0 + 0x18,
 0x1CAEA60 + 0x18,
 0x1CAE520 + 0x18,
 0x1CAEC40 + 0x18,
 0x1CAEB20 + 0x18,
 0x1CAECA0 + 0x18,
 0x1CAEBE0 + 0x18,
 0x1CAE8E0 + 0x18,
 0x1CAE820 + 0x18,
 0x1CAE880 + 0x18,
 0x1CAF000 + 0x18,
 0x1CAEFA0 + 0x18,
 0x1CAF060 + 0x18,
 0x1CB03E0 + 0x18,
 0x1CABBE0 + 0x18,
 0x1CB0560 + 0x18,
 0x1CB1160 + 0x18,
 0x1CB0AA0 + 0x18,
 0x1CB07A0 + 0x18,
 0x1CB0740 + 0x18,
 0x1CB09E0 + 0x18,
 0x1CB0A40 + 0x18,
 0x1CB0920 + 0x18,
 0x1CB0980 + 0x18,
 0x1CB0B60 + 0x18,
 0x1CB0860 + 0x18,
 0x1CB08C0 + 0x18,
 0x1CB0800 + 0x18,
 0x1CB0CE0 + 0x18,
 0x1CB0C80 + 0x18,
 0x1CB0C20 + 0x18,
 0x1CB0BC0 + 0x18,
 0x1CB0B00 + 0x18,
 0x1CABE20 + 0x18,
 0x1CABFA0 + 0x18,
 0x1CAC000 + 0x18,
 0x1CAC060 + 0x18,
 0x1CAC0C0 + 0x18,
 0x1CABDC0 + 0x18,
 0x1CABEE0 + 0x18,
 0x1CABF40 + 0x18,
 0x1CABE80 + 0x18,
 0x1CAADA0 + 0x18,
 0x1CAAE00 + 0x18,
 0x1CAAE60 + 0x18,
 0x1CAAD40 + 0x18,
 0x1CAD200 + 0x18,
 0x1CAC540 + 0x18,
 0x1CAC2A0 + 0x18,
 0x1CAC3C0 + 0x18,
 0x1CAC420 + 0x18,
 0x1CAC4E0 + 0x18,
 0x1CAC480 + 0x18,
 0x1CAC5A0 + 0x18,
 0x1CAC240 + 0x18,
 0x1CAC360 + 0x18,
 0x1CAC300 + 0x18,
 0x1CAC6C0 + 0x18,
 0x1CAC720 + 0x18,
 0x1CAC660 + 0x18,
 0x1CAC600 + 0x18,
 0x1CAC840 + 0x18,
 0x1CE2CC0 + 0x18,
 0x1CDE400 + 0x18,
 0x1CDE220 + 0x18,
 0x1CDE2E0 + 0x18,
 0x1CDE100 + 0x18,
 0x1CDE0A0 + 0x18,
 0x1CDE160 + 0x18,
 0x1CDE040 + 0x18,
 0x1CDE1C0 + 0x18,
 0x1CDE5E0 + 0x18,
 0x1CDE760 + 0x18,
 0x1CDE820 + 0x18,
 0x1CDE8E0 + 0x18,
 0x1CDE520 + 0x18,
 0x1CDE6A0 + 0x18,
 0x1CDE9A0 + 0x18,
 0x1CDED00 + 0x18,
 0x1CDE460 + 0x18,
 0x1CDE580 + 0x18,
 0x1CDE700 + 0x18,
 0x1CDE7C0 + 0x18,
 0x1CDE880 + 0x18,
 0x1CDE4C0 + 0x18,
 0x1CDE640 + 0x18,
 0x1CDE940 + 0x18,
 0x1CDECA0 + 0x18,
 0x1CDEB20 + 0x18,
 0x1CDEB80 + 0x18,
 0x1CDEBE0 + 0x18,
 0x1CDEAC0 + 0x18,
 0x1CDE280 + 0x18,
 0x1CDEC40 + 0x18,
 0x1CDE340 + 0x18,
 0x1CDE3A0 + 0x18,
 0x1CDEA00 + 0x18,
 0x1CDEA60 + 0x18,
 0x1CA6D80 + 0x18,
 0x1CAFD20 + 0x18,
 0x1CAFD80 + 0x18,
 0x1CDF300 + 0x18,
 0x1CC7C00 + 0x18,
 0x1CC7C60 + 0x18,
 0x1CC7CC0 + 0x18,
 0x1CC7AE0 + 0x18,
 0x1CC7B40 + 0x18,
 0x1CC7BA0 + 0x18,
 0x1CC75A0 + 0x18,
 0x1CC6640 + 0x18,
 0x1CC66A0 + 0x18,
 0x1CC6580 + 0x18,
 0x1CC65E0 + 0x18,
 0x1CC7960 + 0x18,
 0x1CCE3E0 + 0x18,
 0x1CC7A80 + 0x18,
 0x1CC9040 + 0x18,
 0x1CC8F80 + 0x18,
 0x1CC91C0 + 0x18,
 0x1CC9160 + 0x18,
 0x1CC8FE0 + 0x18,
 0x1CC90A0 + 0x18,
 0x1CC9100 + 0x18,
 0x1CC4900 + 0x18,
 0x1CC4C00 + 0x18,
 0x1CC4960 + 0x18,
 0x1CC4C60 + 0x18,
 0x1CC4A80 + 0x18,
 0x1CC4A20 + 0x18,
 0x1CC49C0 + 0x18,
 0x1CC7540 + 0x18,
 0x1CC74E0 + 0x18,
 0x1CCE200 + 0x18,
 0x1CCE1A0 + 0x18,
 0x1CCE080 + 0x18,
 0x1CCE0E0 + 0x18,
 0x1CCE020 + 0x18,
 0x1CC60A0 + 0x18,
 0x1CAFDE0 + 0x18,
 0x1CC4DE0 + 0x18,
 0x1CC4D20 + 0x18,
 0x1CC4E40 + 0x18,
 0x1CC4D80 + 0x18,
 0x1CC6C40 + 0x18,
 0x1CC7480 + 0x18,
 0x1CC6100 + 0x18,
 0x1CC6160 + 0x18,
 0x1CC61C0 + 0x18,
 0x1CC6220 + 0x18,
 0x1CCDD20 + 0x18,
 0x1CCDC60 + 0x18,
 0x1CC5080 + 0x18,
 0x1CC6AC0 + 0x18,
 0x1CC62E0 + 0x18,
 0x1CC6280 + 0x18,
 0x1CC8500 + 0x18,
 0x1CC8560 + 0x18,
 0x1CC8620 + 0x18,
 0x1CC86E0 + 0x18,
 0x1CC8680 + 0x18,
 0x1CC84A0 + 0x18,
 0x1CC85C0 + 0x18,
 0x1CC87A0 + 0x18,
 0x1CC8740 + 0x18,
 0x1CC8860 + 0x18,
 0x1CC8800 + 0x18,
 0x1CC57A0 + 0x18,
 0x1CC5500 + 0x18,
 0x1CC8EC0 + 0x18,
 0x1CC8DA0 + 0x18,
 0x1CC8D40 + 0x18,
 0x1CC8E60 + 0x18,
 0x1CC8E00 + 0x18,
 0x1CC8F20 + 0x18,
 0x1CC54A0 + 0x18,
 0x1CC5680 + 0x18,
 0x1CC5620 + 0x18,
 0x1CC5AA0 + 0x18,
 0x1CC5B60 + 0x18,
 0x1CC5BC0 + 0x18,
 0x1CC5C20 + 0x18,
 0x1CC5740 + 0x18,
 0x1CC5800 + 0x18,
 0x1CC7000 + 0x18,
 0x1CC5020 + 0x18,
 0x1CC55C0 + 0x18,
 0x1CC5B00 + 0x18,
 0x1CC56E0 + 0x18,
 0x1CC5920 + 0x18,
 0x1CC59E0 + 0x18,
 0x1CC5980 + 0x18,
 0x1CC5A40 + 0x18,
 0x1CC6A60 + 0x18,
 0x1CC5C80 + 0x18,
 0x1CCE680 + 0x18,
 0x1CC71E0 + 0x18,
 0x1CC8C20 + 0x18,
 0x1CC8BC0 + 0x18,
 0x1CC6B20 + 0x18,
 0x1CC7DE0 + 0x18,
 0x1CC6A00 + 0x18,
 0x1CC7060 + 0x18,
 0x1CC7120 + 0x18,
 0x1CC8920 + 0x18,
 0x1CC8AA0 + 0x18,
 0x1CC8A40 + 0x18,
 0x1CC8CE0 + 0x18,
 0x1CC8C80 + 0x18,
 0x1CC88C0 + 0x18,
 0x1CC8980 + 0x18,
 0x1CC89E0 + 0x18,
 0x1CC6940 + 0x18,
 0x1CC6520 + 0x18,
 0x1CCE380 + 0x18,
 0x1CC78A0 + 0x18,
 0x1CC63A0 + 0x18,
 0x1CC6460 + 0x18,
 0x1CC6400 + 0x18,
 0x1CC6340 + 0x18,
 0x1CC4720 + 0x18,
 0x1CC5200 + 0x18,
 0x1CC5320 + 0x18,
 0x1CC52C0 + 0x18,
 0x1CC5260 + 0x18,
 0x1CC70C0 + 0x18,
 0x1CC7180 + 0x18,
 0x1CCB260 + 0x18,
 0x1CCD780 + 0x18,
 0x1CCDB40 + 0x18,
 0x1CCD7E0 + 0x18,
 0x1CCDAE0 + 0x18,
 0x1CCD840 + 0x18,
 0x1CCD8A0 + 0x18,
 0x1CCD900 + 0x18,
 0x1CCD960 + 0x18,
 0x1CCDC00 + 0x18,
 0x1CCD9C0 + 0x18,
 0x1CCDA80 + 0x18,
 0x1CCDBA0 + 0x18,
 0x1CCDA20 + 0x18,
 0x1CCD660 + 0x18,
 0x1CCD6C0 + 0x18,
 0x1CCD720 + 0x18,
 0x1CC6CA0 + 0x18,
 0x1CC7F60 + 0x18,
 0x1CC8020 + 0x18,
 0x1CC7FC0 + 0x18,
 0x1CC7EA0 + 0x18,
 0x1CC7F00 + 0x18,
 0x1CC80E0 + 0x18,
 0x1CC8080 + 0x18,
 0x1CC5E60 + 0x18,
 0x1CC5DA0 + 0x18,
 0x1CC5D40 + 0x18,
 0x1CC5E00 + 0x18,
 0x1CC5EC0 + 0x18,
 0x1CC5F20 + 0x18,
 0x1CC5FE0 + 0x18,
 0x1CC5F80 + 0x18,
 0x1CCAEA0 + 0x18,
 0x1CCAD80 + 0x18,
 0x1CCAD20 + 0x18,
 0x1CCAE40 + 0x18,
 0x1CCADE0 + 0x18,
 0x1CCACC0 + 0x18,
 0x1CC4660 + 0x18,
 0x1CC46C0 + 0x18,
 0x1CC47E0 + 0x18,
 0x1CC4780 + 0x18,
 0x1CC48A0 + 0x18,
 0x1CC97C0 + 0x18,
 0x1CC7D20 + 0x18,
 0x1CC5CE0 + 0x18,
 0x1CC72A0 + 0x18,
 0x1CC9760 + 0x18,
 0x1CC96A0 + 0x18,
 0x1CC9700 + 0x18,
 0x1CCDCC0 + 0x18,
 0x1CC7D80 + 0x18,
 0x1CC4F60 + 0x18,
 0x1CC6EE0 + 0x18,
 0x1CC6DC0 + 0x18,
 0x1CC6E20 + 0x18,
 0x1CC6FA0 + 0x18,
 0x1CC6D00 + 0x18,
 0x1CC6D60 + 0x18,
 0x1CC6E80 + 0x18,
 0x1CCDFC0 + 0x18,
 0x1CC6F40 + 0x18,
 0x1CCDF60 + 0x18,
 0x1CC7420 + 0x18,
 0x1CC7360 + 0x18,
 0x1CC7300 + 0x18,
 0x1CC73C0 + 0x18,
 0x1CC7240 + 0x18,
 0x1CC7A20 + 0x18,
 0x1CC3D60 + 0x18,
 0x1CC3EE0 + 0x18,
 0x1CC3E80 + 0x18,
 0x1CC3D00 + 0x18,
 0x1CC3F40 + 0x18,
 0x1CC3FA0 + 0x18,
 0x1CC3DC0 + 0x18,
 0x1CC3E20 + 0x18,
 0x1CC50E0 + 0x18,
 0x1CC5140 + 0x18,
 0x1CC8B60 + 0x18,
 0x1CC8B00 + 0x18,
 0x1CCBDA0 + 0x18,
 0x1CCBD40 + 0x18,
 0x1CCBC20 + 0x18,
 0x1CCBCE0 + 0x18,
 0x1CCBC80 + 0x18,
 0x1CC81A0 + 0x18,
 0x1CC8200 + 0x18,
 0x1CC82C0 + 0x18,
 0x1CC8380 + 0x18,
 0x1CC8320 + 0x18,
 0x1CC8140 + 0x18,
 0x1CC8260 + 0x18,
 0x1CC8440 + 0x18,
 0x1CC83E0 + 0x18,
 0x1CCAF00 + 0x18,
 0x1CC4000 + 0x18,
 0x1CC4420 + 0x18,
 0x1CC4480 + 0x18,
 0x1CC4360 + 0x18,
 0x1CC41E0 + 0x18,
 0x1CC4120 + 0x18,
 0x1CC4180 + 0x18,
 0x1CC4060 + 0x18,
 0x1CC4300 + 0x18,
 0x1CC4240 + 0x18,
 0x1CC42A0 + 0x18,
 0x1CC40C0 + 0x18,
 0x1CC43C0 + 0x18,
 0x1CC4540 + 0x18,
 0x1CC44E0 + 0x18,
 0x1CC45A0 + 0x18,
 0x1CC4F00 + 0x18,
 0x1CC6B80 + 0x18,
 0x1CC6BE0 + 0x18,
 0x1CC6820 + 0x18,
 0x1CC6760 + 0x18,
 0x1CC67C0 + 0x18,
 0x1CC6880 + 0x18,
 0x1CC6700 + 0x18,
 0x1CCDF00 + 0x18,
 0x1CC64C0 + 0x18,
 0x1CC7900 + 0x18,
 0x1CC95E0 + 0x18,
 0x1CC9280 + 0x18,
 0x1CC92E0 + 0x18,
 0x1CC93A0 + 0x18,
 0x1CC9460 + 0x18,
 0x1CC9400 + 0x18,
 0x1CC9220 + 0x18,
 0x1CC9580 + 0x18,
 0x1CC9340 + 0x18,
 0x1CC9520 + 0x18,
 0x1CC94C0 + 0x18,
 0x1CC9640 + 0x18,
 0x1CABB80 + 0x18,
 0x1CC68E0 + 0x18,
 0x1CC4CC0 + 0x18,
 0x1CCE320 + 0x18,
 0x1CC5380 + 0x18,
 0x1CC69A0 + 0x18,
 0x1CC4FC0 + 0x18,
 0x1CC4600 + 0x18,
 0x1CC4B40 + 0x18,
 0x1CC4BA0 + 0x18,
 0x1CC4AE0 + 0x18,
 0x1CC53E0 + 0x18,
 0x1CC5440 + 0x18,
 0x1CC76C0 + 0x18,
 0x1CC7660 + 0x18,
 0x1CC7720 + 0x18,
 0x1CC7840 + 0x18,
 0x1CC77E0 + 0x18,
 0x1CCE140 + 0x18,
 0x1CC4840 + 0x18,
 0x1CC51A0 + 0x18,
 0x1CCDD80 + 0x18,
 0x1CA41A0 + 0x18,
 0x1CA4140 + 0x18,
 0x1CE0860 + 0x18,
 0x1CB6500 + 0x18,
 0x1CB6BC0 + 0x18,
 0x1CB6B60 + 0x18,
 0x1CC31C0 + 0x18,
 0x1CB6800 + 0x18,
 0x1CB68C0 + 0x18,
 0x1CB63E0 + 0x18,
 0x1CD1020 + 0x18,
 0x1CB6860 + 0x18,
 0x1CB67A0 + 0x18,
 0x1CB7DC0 + 0x18,
 0x1CC3B80 + 0x18,
 0x1CB7E80 + 0x18,
 0x1CB6DA0 + 0x18,
 0x1CB64A0 + 0x18,
 0x1CB6B00 + 0x18,
 0x1CDB580 + 0x18,
 0x1CC3040 + 0x18,
 0x1CB8BA0 + 0x18,
 0x1CB80C0 + 0x18,
 0x1CB6E60 + 0x18,
 0x1CB8060 + 0x18,
 0x1CB6E00 + 0x18,
 0x1CB6F20 + 0x18,
 0x1CB7160 + 0x18,
 0x1CB7940 + 0x18,
 0x1CB7B20 + 0x18,
 0x1CB7B80 + 0x18,
 0x1CB8000 + 0x18,
 0x1CC9D00 + 0x18,
 0x1CC9EE0 + 0x18,
 0x1CCAC60 + 0x18,
 0x1CCA6C0 + 0x18,
 0x1CCA5A0 + 0x18,
 0x1CCA600 + 0x18,
 0x1CCA660 + 0x18,
 0x1CCA780 + 0x18,
 0x1CCA900 + 0x18,
 0x1CCA8A0 + 0x18,
 0x1CCA7E0 + 0x18,
 0x1CCA840 + 0x18,
 0x1CCA2A0 + 0x18,
 0x1CCA240 + 0x18,
 0x1CC9D60 + 0x18,
 0x1CC9E20 + 0x18,
 0x1CC9DC0 + 0x18,
 0x1CCA480 + 0x18,
 0x1CCA360 + 0x18,
 0x1CCA540 + 0x18,
 0x1CCA420 + 0x18,
 0x1CCA4E0 + 0x18,
 0x1CCA3C0 + 0x18,
 0x1CCA300 + 0x18,
 0x1CCA1E0 + 0x18,
 0x1CC9F40 + 0x18,
 0x1CCA000 + 0x18,
 0x1CC9FA0 + 0x18,
 0x1CCA0C0 + 0x18,
 0x1CCA180 + 0x18,
 0x1CCA060 + 0x18,
 0x1CCA720 + 0x18,
 0x1CC9E80 + 0x18,
 0x1CCA120 + 0x18,
 0x1CC3340 + 0x18,
 0x1CC33A0 + 0x18,
 0x1CA3F60 + 0x18,
 0x1CC3280 + 0x18,
 0x1CC3220 + 0x18,
 0x1CC32E0 + 0x18,
 0x1CC3400 + 0x18,
 0x1CC3580 + 0x18,
 0x1CC35E0 + 0x18,
 0x1CA3FC0 + 0x18,
 0x1CC34C0 + 0x18,
 0x1CC3460 + 0x18,
 0x1CC3520 + 0x18,
 0x1CC3640 + 0x18,
 0x1CC37C0 + 0x18,
 0x1CC3820 + 0x18,
 0x1CA4020 + 0x18,
 0x1CC3700 + 0x18,
 0x1CC36A0 + 0x18,
 0x1CC3760 + 0x18,
 0x1CC3880 + 0x18,
 0x1CC3A00 + 0x18,
 0x1CC3A60 + 0x18,
 0x1CA4080 + 0x18,
 0x1CC3940 + 0x18,
 0x1CC38E0 + 0x18,
 0x1CC39A0 + 0x18,
 0x1CC3AC0 + 0x18,
 0x1CC3B20 + 0x18,
 0x1CB78E0 + 0x18,
 0x1CDD6E0 + 0x18,
 0x1CDAC80 + 0x18,
 0x1CDAC20 + 0x18,
 0x1CB8C60 + 0x18,
 0x1CB8780 + 0x18,
 0x1CD3AE0 + 0x18,
 0x1CDD380 + 0x18,
 0x1CDD4A0 + 0x18,
 0x1CDD3E0 + 0x18,
 0x1CDD500 + 0x18,
 0x1CDD440 + 0x18,
 0x1CDD560 + 0x18,
 0x1CDD2C0 + 0x18,
 0x1CB6380 + 0x18,
 0x1CE6740 + 0x18,
 0x1CE66E0 + 0x18,
 0x1CB8AE0 + 0x18,
 0x1CB8960 + 0x18,
 0x1CD08A0 + 0x18,
 0x1CD0840 + 0x18,
 0x1CDC3C0 + 0x18,
 0x1CDC420 + 0x18,
 0x1CDC480 + 0x18,
 0x1CD01E0 + 0x18,
 0x1CD0240 + 0x18,
 0x1CD0180 + 0x18,
 0x1CEB360 + 0x18,
 0x1CEB300 + 0x18,
 0x1CCEC80 + 0x18,
 0x1CCF580 + 0x18,
 0x1CCF4C0 + 0x18,
 0x1CCE980 + 0x18,
 0x1CCEE00 + 0x18,
 0x1CCEF80 + 0x18,
 0x1CCEFE0 + 0x18,
 0x1CCEF20 + 0x18,
 0x1CCEEC0 + 0x18,
 0x1CCF040 + 0x18,
 0x1CCF0A0 + 0x18,
 0x1CCEE60 + 0x18,
 0x1CCFAC0 + 0x18,
 0x1CCFA60 + 0x18,
 0x1CCFA00 + 0x18,
 0x1CCF9A0 + 0x18,
 0x1CCF940 + 0x18,
 0x1CCFD00 + 0x18,
 0x1CCE740 + 0x18,
 0x1CCED40 + 0x18,
 0x1CCF700 + 0x18,
 0x1CCE920 + 0x18,
 0x1CCE8C0 + 0x18,
 0x1CCFCA0 + 0x18,
 0x1CCE800 + 0x18,
 0x1CCF160 + 0x18,
 0x1CCF1C0 + 0x18,
 0x1CCF100 + 0x18,
 0x1CCF400 + 0x18,
 0x1CCF3A0 + 0x18,
 0x1CCF340 + 0x18,
 0x1CCF220 + 0x18,
 0x1CCF2E0 + 0x18,
 0x1CCF280 + 0x18,
 0x1CCF640 + 0x18,
 0x1CCF5E0 + 0x18,
 0x1CCEA40 + 0x18,
 0x1CCFC40 + 0x18,
 0x1CCEB60 + 0x18,
 0x1CCF520 + 0x18,
 0x1CCF460 + 0x18,
 0x1CCEAA0 + 0x18,
 0x1CCEB00 + 0x18,
 0x1CCE9E0 + 0x18,
 0x1CCE7A0 + 0x18,
 0x1CCE860 + 0x18,
 0x1CCEDA0 + 0x18,
 0x1CCEC20 + 0x18,
 0x1CCECE0 + 0x18,
 0x1CCF6A0 + 0x18,
 0x1CCF8E0 + 0x18,
 0x1CCF880 + 0x18,
 0x1CCF820 + 0x18,
 0x1CCF760 + 0x18,
 0x1CCF7C0 + 0x18,
 0x1CCEBC0 + 0x18,
 0x1CB8C00 + 0x18,
 0x1CCFB20 + 0x18,
 0x1CCFB80 + 0x18,
 0x1CCFBE0 + 0x18,
 0x1CB7A00 + 0x18,
 0x1CB7A60 + 0x18,
 0x1CB0440 + 0x18,
 0x1CB7040 + 0x18,
 0x1CB70A0 + 0x18,
 0x1CD42C0 + 0x18,
 0x1CD8520 + 0x18,
 0x1CD85E0 + 0x18,
 0x1CD8580 + 0x18,
 0x1CD8640 + 0x18,
 0x1CACA20 + 0x18,
 0x1CB6EC0 + 0x18,
 0x1CAF420 + 0x18,
 0x1CAF480 + 0x18,
 0x1CE6800 + 0x18,
 0x1CE67A0 + 0x18,
 0x1CAFE40 + 0x18,
 0x1CAFF00 + 0x18,
 0x1CAFEA0 + 0x18,
 0x1CAFF60 + 0x18,
 0x1CEB420 + 0x18,
 0x1CB1CA0 + 0x18,
 0x1CB6C20 + 0x18,
 0x1CB81E0 + 0x18,
 0x1CDABC0 + 0x18,
 0x1CB1940 + 0x18,
 0x1CB1BE0 + 0x18,
 0x1CB1B80 + 0x18,
 0x1CB1B20 + 0x18,
 0x1CB1DC0 + 0x18,
 0x1CB1A00 + 0x18,
 0x1CB19A0 + 0x18,
 0x1CB1C40 + 0x18,
 0x1CB1D00 + 0x18,
 0x1CB1D60 + 0x18,
 0x1CB1AC0 + 0x18,
 0x1CB1A60 + 0x18,
 0x1CD38A0 + 0x18,
 0x1CD3900 + 0x18,
 0x1CD3840 + 0x18,
 0x1CDB820 + 0x18,
 0x1CDB8E0 + 0x18,
 0x1CDB880 + 0x18,
 0x1CDA4A0 + 0x18,
 0x1CD9A20 + 0x18,
 0x1CD9A80 + 0x18,
 0x1CD9AE0 + 0x18,
 0x1CD9B40 + 0x18,
 0x1CD37E0 + 0x18,
 0x1CC9820 + 0x18,
 0x1CAAC80 + 0x18,
 0x1CC9880 + 0x18,
 0x1CC9A00 + 0x18,
 0x1CC99A0 + 0x18,
 0x1CC9940 + 0x18,
 0x1CC98E0 + 0x18,
 0x1CAACE0 + 0x18,
 0x1CC9A60 + 0x18,
 0x1CC9C40 + 0x18,
 0x1CC9CA0 + 0x18,
 0x1CC9BE0 + 0x18,
 0x1CDBCA0 + 0x18,
 0x1CC3C40 + 0x18,
 0x1CB3EC0 + 0x18,
 0x1CB3F20 + 0x18,
 0x1CD0900 + 0x18,
 0x1CD0960 + 0x18,
 0x1CD4380 + 0x18,
 0x1CD43E0 + 0x18,
 0x1CD4320 + 0x18,
 0x1CD4C20 + 0x18,
 0x1CBEA80 + 0x18,
 0x1CD4020 + 0x18,
 0x1CD3E40 + 0x18,
 0x1CD3FC0 + 0x18,
 0x1CD3F00 + 0x18,
 0x1CD3F60 + 0x18,
 0x1CD3EA0 + 0x18,
 0x1CD4080 + 0x18,
 0x1CD40E0 + 0x18,
 0x1CD4140 + 0x18,
 0x1CB7C40 + 0x18,
 0x1CB7CA0 + 0x18,
 0x1CD8DC0 + 0x18,
 0x1CD00C0 + 0x18,
 0x1CD0060 + 0x18,
 0x1CD02A0 + 0x18,
 0x1CD0360 + 0x18,
 0x1CD0300 + 0x18,
 0x1CCFFA0 + 0x18,
 0x1CD0120 + 0x18,
 0x1CD0000 + 0x18,
 0x1CCFEE0 + 0x18,
 0x1CCFF40 + 0x18,
 0x1CCB4A0 + 0x18,
 0x1CB0500 + 0x18,
 0x1CABAC0 + 0x18,
 0x1CDA7A0 + 0x18,
 0x1CDA680 + 0x18,
 0x1CDA9E0 + 0x18,
 0x1CDA860 + 0x18,
 0x1CDA920 + 0x18,
 0x1CDA6E0 + 0x18,
 0x1CDAA40 + 0x18,
 0x1CDAAA0 + 0x18,
 0x1CDA8C0 + 0x18,
 0x1CD9C60 + 0x18,
 0x1CDA980 + 0x18,
 0x1CDA740 + 0x18,
 0x1CDA800 + 0x18,
 0x1CD9CC0 + 0x18,
 0x1CD9D20 + 0x18,
 0x1CE9380 + 0x18,
 0x1CE9320 + 0x18,
 0x1CE96E0 + 0x18,
 0x1CE9500 + 0x18,
 0x1CE92C0 + 0x18,
 0x1CE94A0 + 0x18,
 0x1CE9260 + 0x18,
 0x1CE97A0 + 0x18,
 0x1CE9680 + 0x18,
 0x1CE9620 + 0x18,
 0x1CE9560 + 0x18,
 0x1CE95C0 + 0x18,
 0x1CE9440 + 0x18,
 0x1CE9800 + 0x18,
 0x1CE9740 + 0x18,
 0x1CE93E0 + 0x18,
 0x1CDF3C0 + 0x18,
 0x1CA8520 + 0x18,
 0x1CA8580 + 0x18,
 0x1CA5100 + 0x18,
 0x1CA51C0 + 0x18,
 0x1CA7020 + 0x18,
 0x1CA8400 + 0x18,
 0x1CA85E0 + 0x18,
 0x1CA8040 + 0x18,
 0x1CA7440 + 0x18,
 0x1CA74A0 + 0x18,
 0x1CA7500 + 0x18,
 0x1CA4FE0 + 0x18,
 0x1CA4F80 + 0x18,
 0x1CA79E0 + 0x18,
 0x1CA7A40 + 0x18,
 0x1CA7AA0 + 0x18,
 0x1CA7B00 + 0x18,
 0x1CA4380 + 0x18,
 0x1CA43E0 + 0x18,
 0x1CA4440 + 0x18,
 0x1CA44A0 + 0x18,
 0x1CA45C0 + 0x18,
 0x1CA4800 + 0x18,
 0x1CA8100 + 0x18,
 0x1CA8160 + 0x18,
 0x1CDB700 + 0x18,
 0x1CDB6A0 + 0x18,
 0x1CDB760 + 0x18,
 0x1CA6DE0 + 0x18,
 0x1CA6EA0 + 0x18,
 0x1CA6F00 + 0x18,
 0x1CA6F60 + 0x18,
 0x1CA6E40 + 0x18,
 0x1CA42C0 + 0x18,
 0x1CE2060 + 0x18,
 0x1CE2000 + 0x18,
 0x1CB5360 + 0x18,
 0x1CB5420 + 0x18,
 0x1CB53C0 + 0x18,
 0x1CA7BC0 + 0x18,
 0x1CA7C20 + 0x18,
 0x1CE6980 + 0x18,
 0x1CA4320 + 0x18,
 0x1CA4EC0 + 0x18,
 0x1CB6080 + 0x18,
 0x1CB9620 + 0x18,
 0x1CA4CE0 + 0x18,
 0x1CA4DA0 + 0x18,
 0x1CA4D40 + 0x18,
 0x1CA8280 + 0x18,
 0x1CA4F20 + 0x18,
 0x1CA46E0 + 0x18,
 0x1CA4740 + 0x18,
 0x1CA4680 + 0x18,
 0x1CA47A0 + 0x18,
 0x1CA7FE0 + 0x18,
 0x1CA4620 + 0x18,
 0x1CA6FC0 + 0x18,
 0x1CA7B60 + 0x18,
 0x1CA4E00 + 0x18,
 0x1CA4A40 + 0x18,
 0x1CA4920 + 0x18,
 0x1CA49E0 + 0x18,
 0x1CA4980 + 0x18,
 0x1CA4860 + 0x18,
 0x1CA48C0 + 0x18,
 0x1CA83A0 + 0x18,
 0x1CA8220 + 0x18,
 0x1CA7380 + 0x18,
 0x1CA73E0 + 0x18,
 0x1CA7260 + 0x18,
 0x1CA7320 + 0x18,
 0x1CA7200 + 0x18,
 0x1CA72C0 + 0x18,
 0x1CA5160 + 0x18,
 0x1CA4E60 + 0x18,
 0x1CA4C80 + 0x18,
 0x1CA7680 + 0x18,
 0x1CA76E0 + 0x18,
 0x1CA77A0 + 0x18,
 0x1CA7860 + 0x18,
 0x1CA7980 + 0x18,
 0x1CA7740 + 0x18,
 0x1CA7800 + 0x18,
 0x1CC79C0 + 0x18,
 0x1CA78C0 + 0x18,
 0x1CA7920 + 0x18,
 0x1CA7080 + 0x18,
 0x1CA70E0 + 0x18,
 0x1CA7140 + 0x18,
 0x1CA71A0 + 0x18,
 0x1CA7560 + 0x18,
 0x1CA75C0 + 0x18,
 0x1CA7620 + 0x18,
 0x1CB61A0 + 0x18,
 0x1CB6140 + 0x18,
 0x1CB60E0 + 0x18,
 0x1CA81C0 + 0x18,
 0x1CA82E0 + 0x18,
 0x1CA5040 + 0x18,
 0x1CA50A0 + 0x18,
 0x1CA84C0 + 0x18,
 0x1CD7740 + 0x18,
 0x1CE3200 + 0x18,
 0x1CD4C80 + 0x18,
 0x1CDDC20 + 0x18,
 0x1CC2F80 + 0x18,
 0x1CC2F20 + 0x18,
 0x1CC2EC0 + 0x18,
 0x1CDDCE0 + 0x18,
 0x1CDDC80 + 0x18,
 0x1CDDD40 + 0x18,
 0x1CDDDA0 + 0x18,
 0x1CC2E60 + 0x18,
 0x1CB6F80 + 0x18,
 0x1CAAB60 + 0x18,
 0x1CAA860 + 0x18,
 0x1CAA8C0 + 0x18,
 0x1CAA920 + 0x18,
 0x1CAAB00 + 0x18,
 0x1CAA7A0 + 0x18,
 0x1CAA740 + 0x18,
 0x1CAA800 + 0x18,
 0x1CAA680 + 0x18,
 0x1CAA6E0 + 0x18,
 0x1CAA980 + 0x18,
 0x1CAA9E0 + 0x18,
 0x1CAAAA0 + 0x18,
 0x1CAAA40 + 0x18,
 0x1CD3D20 + 0x18,
 0x1CD3CC0 + 0x18,
 0x1CB71C0 + 0x18,
 0x1CC2C80 + 0x18,
 0x1CC2C20 + 0x18,
 0x1CC2BC0 + 0x18,
 0x1CC2B60 + 0x18,
 0x1CE2D80 + 0x18,
 0x1CB18E0 + 0x18,
 0x1CB1880 + 0x18,
 0x1CB8120 + 0x18,
 0x1CE1640 + 0x18,
 0x1CE8C00 + 0x18,
 0x1CE8D80 + 0x18,
 0x1CE8D20 + 0x18,
 0x1CE8CC0 + 0x18,
 0x1CE8C60 + 0x18,
 0x1CE9140 + 0x18,
 0x1CE9200 + 0x18,
 0x1CE91A0 + 0x18,
 0x1CE8F60 + 0x18,
 0x1CE8F00 + 0x18,
 0x1CE90E0 + 0x18,
 0x1CE9080 + 0x18,
 0x1CE9020 + 0x18,
 0x1CE8FC0 + 0x18,
 0x1CE8E40 + 0x18,
 0x1CE8EA0 + 0x18,
 0x1CE8DE0 + 0x18,
 0x1CCC5E0 + 0x18,
 0x1CB9C20 + 0x18,
 0x1CB9B60 + 0x18,
 0x1CB9BC0 + 0x18,
 0x1CB9B00 + 0x18,
 0x1CBA280 + 0x18,
 0x1CBA2E0 + 0x18,
 0x1CB9740 + 0x18,
 0x1CBA220 + 0x18,
 0x1CBA040 + 0x18,
 0x1CB9F80 + 0x18,
 0x1CB9FE0 + 0x18,
 0x1CBA1C0 + 0x18,
 0x1CBA100 + 0x18,
 0x1CBA160 + 0x18,
 0x1CB96E0 + 0x18,
 0x1CB9A40 + 0x18,
 0x1CB9AA0 + 0x18,
 0x1CB9980 + 0x18,
 0x1CB99E0 + 0x18,
 0x1CB9800 + 0x18,
 0x1CB9860 + 0x18,
 0x1CB98C0 + 0x18,
 0x1CB9F20 + 0x18,
 0x1CBA0A0 + 0x18,
 0x1CB9C80 + 0x18,
 0x1CB97A0 + 0x18,
 0x1CB9D40 + 0x18,
 0x1CB9CE0 + 0x18,
 0x1CB9920 + 0x18,
 0x1CB9E00 + 0x18,
 0x1CB9DA0 + 0x18,
 0x1CB9EC0 + 0x18,
 0x1CB9E60 + 0x18,
 0x1CDB400 + 0x18,
 0x1CDAF20 + 0x18,
 0x1CB11C0 + 0x18,
 0x1CB12E0 + 0x18,
 0x1CB1280 + 0x18,
 0x1CB1340 + 0x18,
 0x1CB1220 + 0x18,
 0x1CB6320 + 0x18,
 0x1CA40E0 + 0x18,
 0x1CC6040 + 0x18,
 0x1CA4200 + 0x18,
 0x1CBA7C0 + 0x18,
 0x1CCBBC0 + 0x18,
 0x1CCB9E0 + 0x18,
 0x1CCB920 + 0x18,
 0x1CCB6E0 + 0x18,
 0x1CCB980 + 0x18,
 0x1CCBB60 + 0x18,
 0x1CCB860 + 0x18,
 0x1CCB7A0 + 0x18,
 0x1CCB8C0 + 0x18,
 0x1CCB800 + 0x18,
 0x1CCBB00 + 0x18,
 0x1CCB620 + 0x18,
 0x1CCB740 + 0x18,
 0x1CCB680 + 0x18,
 0x1CCBAA0 + 0x18,
 0x1CCB560 + 0x18,
 0x1CCBA40 + 0x18,
 0x1CCB5C0 + 0x18,
 0x1CDBD60 + 0x18,
 0x1CDC060 + 0x18,
 0x1CDC0C0 + 0x18,
 0x1CDC000 + 0x18,
 0x1CDBFA0 + 0x18,
 0x1CDBEE0 + 0x18,
 0x1CDBF40 + 0x18,
 0x1CD8EE0 + 0x18,
 0x1CD8E80 + 0x18,
 0x1CD9840 + 0x18,
 0x1CD5340 + 0x18,
 0x1CD3960 + 0x18,
 0x1CD3BA0 + 0x18,
 0x1CD30C0 + 0x18,
 0x1CD2EE0 + 0x18,
 0x1CD3000 + 0x18,
 0x1CD2FA0 + 0x18,
 0x1CD2F40 + 0x18,
 0x1CD10E0 + 0x18,
 0x1CDC2A0 + 0x18,
 0x1CDC360 + 0x18,
 0x1CDC300 + 0x18,
 0x1CDC240 + 0x18,
 0x1CDC1E0 + 0x18,
 0x1CDC180 + 0x18,
 0x1CDC120 + 0x18,
 0x1CBA880 + 0x18,
 0x1CBA820 + 0x18,
 0x1CBA8E0 + 0x18,
 0x1CBA940 + 0x18,
 0x1CB7AC0 + 0x18,
 0x1CB7D00 + 0x18,
 0x1CCB020 + 0x18,
 0x1CCB080 + 0x18,
 0x1CCB1A0 + 0x18,
 0x1CCB200 + 0x18,
 0x1CCB0E0 + 0x18,
 0x1CCB140 + 0x18,
 0x1CE1E80 + 0x18,
 0x1CE28A0 + 0x18,
 0x1CE2840 + 0x18,
 0x1CE2720 + 0x18,
 0x1CE27E0 + 0x18,
 0x1CE2780 + 0x18,
 0x1CE1D00 + 0x18,
 0x1CB7220 + 0x18,
 0x1CB73A0 + 0x18,
 0x1CB7280 + 0x18,
 0x1CB72E0 + 0x18,
 0x1CB7340 + 0x18,
 0x1CB6740 + 0x18,
 0x1CB6680 + 0x18,
 0x1CB65C0 + 0x18,
 0x1CB66E0 + 0x18,
 0x1CB6620 + 0x18,
 0x1CB14C0 + 0x18,
 0x1CB15E0 + 0x18,
 0x1CB1640 + 0x18,
 0x1CB1580 + 0x18,
 0x1CB1460 + 0x18,
 0x1CB1520 + 0x18,
 0x1CB1400 + 0x18,
 0x1CB13A0 + 0x18,
 0x1CB16A0 + 0x18,
 0x1CB1760 + 0x18,
 0x1CB1700 + 0x18,
 0x1CDEE80 + 0x18,
 0x1CDEE20 + 0x18,
 0x1CD7680 + 0x18,
 0x1CD8E20 + 0x18,
 0x1CD96C0 + 0x18,
 0x1CEB240 + 0x18,
 0x1CEB2A0 + 0x18,
 0x1CD9960 + 0x18,
 0x1CA7C80 + 0x18,
 0x1CD9780 + 0x18,
 0x1CD9600 + 0x18,
 0x1CD9660 + 0x18,
 0x1CB0E00 + 0x18,
 0x1CB0E60 + 0x18,
 0x1CB1040 + 0x18,
 0x1CE00E0 + 0x18,
 0x1CE0260 + 0x18,
 0x1CE01A0 + 0x18,
 0x1CE0080 + 0x18,
 0x1CE0140 + 0x18,
 0x1CE02C0 + 0x18,
 0x1CE0200 + 0x18,
 0x1CD9C00 + 0x18,
 0x1CB8EA0 + 0x18,
 0x1CA9EA0 + 0x18,
 0x1CA9F00 + 0x18,
 0x1CA9900 + 0x18,
 0x1CA9960 + 0x18,
 0x1CA99C0 + 0x18,
 0x1CA9A20 + 0x18,
 0x1CA9840 + 0x18,
 0x1CA98A0 + 0x18,
 0x1CAA020 + 0x18,
 0x1CAA140 + 0x18,
 0x1CA9C60 + 0x18,
 0x1CA9CC0 + 0x18,
 0x1CA9D20 + 0x18,
 0x1CA9C00 + 0x18,
 0x1CA9F60 + 0x18,
 0x1CA9FC0 + 0x18,
 0x1CAA0E0 + 0x18,
 0x1CAA080 + 0x18,
 0x1CA9E40 + 0x18,
 0x1CA9D80 + 0x18,
 0x1CA9DE0 + 0x18,
 0x1CA9AE0 + 0x18,
 0x1CA9B40 + 0x18,
 0x1CA9A80 + 0x18,
 0x1CA9BA0 + 0x18,
 0x1CA9240 + 0x18,
 0x1CA92A0 + 0x18,
 0x1CA9600 + 0x18,
 0x1CA9660 + 0x18,
 0x1CA93C0 + 0x18,
 0x1CA9420 + 0x18,
 0x1CA9480 + 0x18,
 0x1CA94E0 + 0x18,
 0x1CA9300 + 0x18,
 0x1CA9360 + 0x18,
 0x1CA97E0 + 0x18,
 0x1CA96C0 + 0x18,
 0x1CA9720 + 0x18,
 0x1CA9780 + 0x18,
 0x1CA9540 + 0x18,
 0x1CA95A0 + 0x18,
 0x1CAA320 + 0x18,
 0x1CAA380 + 0x18,
 0x1CAA2C0 + 0x18,
 0x1CAA3E0 + 0x18,
 0x1CAA4A0 + 0x18,
 0x1CAA440 + 0x18,
 0x1CAA5C0 + 0x18,
 0x1CAA500 + 0x18,
 0x1CAA620 + 0x18,
 0x1CAA200 + 0x18,
 0x1CAA560 + 0x18,
 0x1CAA260 + 0x18,
 0x1CAA1A0 + 0x18,
 0x1CB9680 + 0x18,
 0x1CB6980 + 0x18,
 0x1CD3120 + 0x18,
 0x1CDDF80 + 0x18,
 0x1CDDE60 + 0x18,
 0x1CDDE00 + 0x18,
 0x1CDDEC0 + 0x18,
 0x1CDDF20 + 0x18,
 0x1CE03E0 + 0x18,
 0x1CE0440 + 0x18,
 0x1CB8B40 + 0x18,
 0x1CDF8A0 + 0x18,
 0x1CCB440 + 0x18,
 0x1CCB380 + 0x18,
 0x1CCB3E0 + 0x18,
 0x1CB76A0 + 0x18,
 0x1CC7780 + 0x18,
 0x1CD5160 + 0x18,
 0x1CD6420 + 0x18,
 0x1CD71A0 + 0x18,
 0x1CD6EA0 + 0x18,
 0x1CD6AE0 + 0x18,
 0x1CD5940 + 0x18,
 0x1CD6600 + 0x18,
 0x1CD6000 + 0x18,
 0x1CD6DE0 + 0x18,
 0x1CD6060 + 0x18,
 0x1CD6960 + 0x18,
 0x1CD59A0 + 0x18,
 0x1CD58E0 + 0x18,
 0x1CD50A0 + 0x18,
 0x1CD5040 + 0x18,
 0x1CD60C0 + 0x18,
 0x1CD6720 + 0x18,
 0x1CD4FE0 + 0x18,
 0x1CD6CC0 + 0x18,
 0x1CD6D20 + 0x18,
 0x1CD6180 + 0x18,
 0x1CD5B20 + 0x18,
 0x1CD5A60 + 0x18,
 0x1CD6120 + 0x18,
 0x1CD6300 + 0x18,
 0x1CD66C0 + 0x18,
 0x1CD5C40 + 0x18,
 0x1CD69C0 + 0x18,
 0x1CD6E40 + 0x18,
 0x1CD6240 + 0x18,
 0x1CD70E0 + 0x18,
 0x1CD5F40 + 0x18,
 0x1CD5FA0 + 0x18,
 0x1CD6C60 + 0x18,
 0x1CD6A80 + 0x18,
 0x1CD61E0 + 0x18,
 0x1CD6360 + 0x18,
 0x1CD63C0 + 0x18,
 0x1CD4EC0 + 0x18,
 0x1CD7020 + 0x18,
 0x1CD5100 + 0x18,
 0x1CD5700 + 0x18,
 0x1CD5880 + 0x18,
 0x1CD5220 + 0x18,
 0x1CD5280 + 0x18,
 0x1CD52E0 + 0x18,
 0x1CD57C0 + 0x18,
 0x1CD5640 + 0x18,
 0x1CD55E0 + 0x18,
 0x1CD75C0 + 0x18,
 0x1CD6FC0 + 0x18,
 0x1CD53A0 + 0x18,
 0x1CD56A0 + 0x18,
 0x1CD5820 + 0x18,
 0x1CD51C0 + 0x18,
 0x1CD5460 + 0x18,
 0x1CD54C0 + 0x18,
 0x1CD5760 + 0x18,
 0x1CD5580 + 0x18,
 0x1CD5520 + 0x18,
 0x1CD5400 + 0x18,
 0x1CD6780 + 0x18,
 0x1CD7500 + 0x18,
 0x1CD67E0 + 0x18,
 0x1CD6840 + 0x18,
 0x1CD7620 + 0x18,
 0x1CD6480 + 0x18,
 0x1CD7560 + 0x18,
 0x1CD5A00 + 0x18,
 0x1CD6A20 + 0x18,
 0x1CD7080 + 0x18,
 0x1CD62A0 + 0x18,
 0x1CD6660 + 0x18,
 0x1CD5B80 + 0x18,
 0x1CD5AC0 + 0x18,
 0x1CD5EE0 + 0x18,
 0x1CD5E20 + 0x18,
 0x1CD5E80 + 0x18,
 0x1CD4F20 + 0x18,
 0x1CD4F80 + 0x18,
 0x1CD6D80 + 0x18,
 0x1CD65A0 + 0x18,
 0x1CD68A0 + 0x18,
 0x1CD5CA0 + 0x18,
 0x1CDB3A0 + 0x18,
 0x1CD6540 + 0x18,
 0x1CD64E0 + 0x18,
 0x1CD6900 + 0x18,
 0x1CD6B40 + 0x18,
 0x1CD6BA0 + 0x18,
 0x1CD6C00 + 0x18,
 0x1CD5BE0 + 0x18,
 0x1CD5DC0 + 0x18,
 0x1CD5D00 + 0x18,
 0x1CD5D60 + 0x18,
 0x1CD6F60 + 0x18,
 0x1CD4680 + 0x18,
 0x1CD46E0 + 0x18,
 0x1CD4860 + 0x18,
 0x1CD4740 + 0x18,
 0x1CD47A0 + 0x18,
 0x1CD49E0 + 0x18,
 0x1CD48C0 + 0x18,
 0x1CD4800 + 0x18,
 0x1CD4920 + 0x18,
 0x1CD7140 + 0x18,
 0x1CD7200 + 0x18,
 0x1CB6920 + 0x18,
 0x1CDF1E0 + 0x18,
 0x1CDF2A0 + 0x18,
 0x1CDF240 + 0x18,
 0x1CB3500 + 0x18,
 0x1CE3B00 + 0x18,
 0x1CB35C0 + 0x18,
 0x1CE3AA0 + 0x18,
 0x1CB2D20 + 0x18,
 0x1CB3200 + 0x18,
 0x1CB30E0 + 0x18,
 0x1CB2FC0 + 0x18,
 0x1CB3020 + 0x18,
 0x1CB3560 + 0x18,
 0x1CE3B60 + 0x18,
 0x1CB2CC0 + 0x18,
 0x1CB3620 + 0x18,
 0x1CB34A0 + 0x18,
 0x1CB33E0 + 0x18,
 0x1CB3440 + 0x18,
 0x1CB38C0 + 0x18,
 0x1CB3920 + 0x18,
 0x1CB3860 + 0x18,
 0x1CB37A0 + 0x18,
 0x1CB3740 + 0x18,
 0x1CB3800 + 0x18,
 0x1CB2D80 + 0x18,
 0x1CB2E40 + 0x18,
 0x1CB31A0 + 0x18,
 0x1CB3320 + 0x18,
 0x1CB2F60 + 0x18,
 0x1CB2F00 + 0x18,
 0x1CB2EA0 + 0x18,
 0x1CB32C0 + 0x18,
 0x1CB3680 + 0x18,
 0x1CB36E0 + 0x18,
 0x1CB39E0 + 0x18,
 0x1CB3980 + 0x18,
 0x1CB3A40 + 0x18,
 0x1CB3AA0 + 0x18,
 0x1CB3B00 + 0x18,
 0x1CB3260 + 0x18,
 0x1CB3080 + 0x18,
 0x1CB2DE0 + 0x18,
 0x1CB3140 + 0x18,
 0x1CB3380 + 0x18,
 0x1CB2B40 + 0x18,
 0x1CB2C60 + 0x18,
 0x1CB2BA0 + 0x18,
 0x1CB2AE0 + 0x18,
 0x1CB2A80 + 0x18,
 0x1CB2A20 + 0x18,
 0x1CB29C0 + 0x18,
 0x1CB2C00 + 0x18,
 0x1CD0720 + 0x18,
 0x1CD0600 + 0x18,
 0x1CD06C0 + 0x18,
 0x1CD07E0 + 0x18,
 0x1CD03C0 + 0x18,
 0x1CD0420 + 0x18,
 0x1CD0A80 + 0x18,
 0x1CD0AE0 + 0x18,
 0x1CD0A20 + 0x18,
 0x1CD05A0 + 0x18,
 0x1CD0660 + 0x18,
 0x1CD0780 + 0x18,
 0x1CD04E0 + 0x18,
 0x1CD0480 + 0x18,
 0x1CD0540 + 0x18,
 0x1CA80A0 + 0x18,
 0x1CACDE0 + 0x18,
 0x1CAD3E0 + 0x18,
 0x1CAD440 + 0x18,
 0x1CAD9E0 + 0x18,
 0x1CAE040 + 0x18,
 0x1CADFE0 + 0x18,
 0x1CAE0A0 + 0x18,
 0x1CAF900 + 0x18,
 0x1CAF960 + 0x18,
 0x1CACB40 + 0x18,
 0x1CACC60 + 0x18,
 0x1CACBA0 + 0x18,
 0x1CACAE0 + 0x18,
 0x1CACC00 + 0x18,
 0x1CACA80 + 0x18,
 0x1CACD20 + 0x18,
 0x1CACCC0 + 0x18,
 0x1CACF60 + 0x18,
 0x1CACEA0 + 0x18,
 0x1CAE220 + 0x18,
 0x1CAE460 + 0x18,
 0x1CAE340 + 0x18,
 0x1CAE3A0 + 0x18,
 0x1CAE400 + 0x18,
 0x1CAE2E0 + 0x18,
 0x1CAD380 + 0x18,
 0x1CADB60 + 0x18,
 0x1CAD560 + 0x18,
 0x1CAFCC0 + 0x18,
 0x1CAD620 + 0x18,
 0x1CACFC0 + 0x18,
 0x1CAD020 + 0x18,
 0x1CAD0E0 + 0x18,
 0x1CAB640 + 0x18,
 0x1CAB6A0 + 0x18,
 0x1CAB580 + 0x18,
 0x1CAB5E0 + 0x18,
 0x1CAE280 + 0x18,
 0x1CAF600 + 0x18,
 0x1CAF660 + 0x18,
 0x1CAF5A0 + 0x18,
 0x1CAF180 + 0x18,
 0x1CAF1E0 + 0x18,
 0x1CAF0C0 + 0x18,
 0x1CAF120 + 0x18,
 0x1CA7F20 + 0x18,
 0x1CACE40 + 0x18,
 0x1CAD500 + 0x18,
 0x1CB69E0 + 0x18,
 0x1CAD1A0 + 0x18,
 0x1CAD140 + 0x18,
 0x1CAD4A0 + 0x18,
 0x1CAD5C0 + 0x18,
 0x1CACD80 + 0x18,
 0x1CAD8C0 + 0x18,
 0x1CAD860 + 0x18,
 0x1CAD800 + 0x18,
 0x1CAD740 + 0x18,
 0x1CAD920 + 0x18,
 0x1CAD7A0 + 0x18,
 0x1CADAA0 + 0x18,
 0x1CADB00 + 0x18,
 0x1CADF20 + 0x18,
 0x1CADC80 + 0x18,
 0x1CADE00 + 0x18,
 0x1CADE60 + 0x18,
 0x1CADCE0 + 0x18,
 0x1CADEC0 + 0x18,
 0x1CAD680 + 0x18,
 0x1CADDA0 + 0x18,
 0x1CADD40 + 0x18,
 0x1CAE100 + 0x18,
 0x1CADA40 + 0x18,
 0x1CAD980 + 0x18,
 0x1CACF00 + 0x18,
 0x1CAFB40 + 0x18,
 0x1CAFBA0 + 0x18,
 0x1CAFAE0 + 0x18,
 0x1CA7D40 + 0x18,
 0x1CA7DA0 + 0x18,
 0x1CA7E00 + 0x18,
 0x1CADF80 + 0x18,
 0x1CA7E60 + 0x18,
 0x1CA7EC0 + 0x18,
 0x1CAB520 + 0x18,
 0x1CAB4C0 + 0x18,
 0x1CAFC00 + 0x18,
 0x1CAFC60 + 0x18,
 0x1CAD6E0 + 0x18,
 0x1CAF8A0 + 0x18,
 0x1CAF7E0 + 0x18,
 0x1CAF840 + 0x18,
 0x1CADC20 + 0x18,
 0x1CADBC0 + 0x18,
 0x1CB0620 + 0x18,
 0x1CE0680 + 0x18,
 0x1CE05C0 + 0x18,
 0x1CE0620 + 0x18,
 0x1CE0560 + 0x18,
 0x1CCA9C0 + 0x18,
 0x1CD8A60 + 0x18,
 0x1CD8D60 + 0x18,
 0x1CD8B80 + 0x18,
 0x1CD8BE0 + 0x18,
 0x1CD8C40 + 0x18,
 0x1CD8D00 + 0x18,
 0x1CD8AC0 + 0x18,
 0x1CD8B20 + 0x18,
 0x1CD8CA0 + 0x18,
 0x1CD8700 + 0x18,
 0x1CD8A00 + 0x18,
 0x1CD8820 + 0x18,
 0x1CD8880 + 0x18,
 0x1CD88E0 + 0x18,
 0x1CD89A0 + 0x18,
 0x1CD8760 + 0x18,
 0x1CD87C0 + 0x18,
 0x1CD8940 + 0x18,
 0x1CD86A0 + 0x18,
 0x1CD3D80 + 0x18,
 0x1CB1820 + 0x18,
 0x1CDEDC0 + 0x18,
 0x1CDACE0 + 0x18,
 0x1CDB640 + 0x18,
 0x1CDAD40 + 0x18,
 0x1CB79A0 + 0x18,
 0x1CDB940 + 0x18,
 0x1CDBA00 + 0x18,
 0x1CD4BC0 + 0x18,
 0x1CD4B60 + 0x18,
 0x1CB8900 + 0x18,
 0x1CC0280 + 0x18,
 0x1CBB900 + 0x18,
 0x1CBDA00 + 0x18,
 0x1CBDA60 + 0x18,
 0x1CC1B40 + 0x18,
 0x1CC1AE0 + 0x18,
 0x1CC1A20 + 0x18,
 0x1CC1A80 + 0x18,
 0x1CBEEA0 + 0x18,
 0x1CBEE40 + 0x18,
 0x1CBE3C0 + 0x18,
 0x1CBE7E0 + 0x18,
 0x1CBC800 + 0x18,
 0x1CBC5C0 + 0x18,
 0x1CBC620 + 0x18,
 0x1CBB240 + 0x18,
 0x1CBB300 + 0x18,
 0x1CBB2A0 + 0x18,
 0x1CBBCC0 + 0x18,
 0x1CBE780 + 0x18,
 0x1CBB3C0 + 0x18,
 0x1CC1960 + 0x18,
 0x1CC2080 + 0x18,
 0x1CBB5A0 + 0x18,
 0x1CBB540 + 0x18,
 0x1CC2020 + 0x18,
 0x1CC1FC0 + 0x18,
 0x1CC1F60 + 0x18,
 0x1CBE840 + 0x18,
 0x1CC20E0 + 0x18,
 0x1CBC6E0 + 0x18,
 0x1CBC740 + 0x18,
 0x1CBFDA0 + 0x18,
 0x1CBF9E0 + 0x18,
 0x1CBFB00 + 0x18,
 0x1CBFD40 + 0x18,
 0x1CBFCE0 + 0x18,
 0x1CBFAA0 + 0x18,
 0x1CBFC80 + 0x18,
 0x1CBFC20 + 0x18,
 0x1CBFE00 + 0x18,
 0x1CBFA40 + 0x18,
 0x1CBFBC0 + 0x18,
 0x1CBFB60 + 0x18,
 0x1CC2A40 + 0x18,
 0x1CC2140 + 0x18,
 0x1CBBDE0 + 0x18,
 0x1CBBD80 + 0x18,
 0x1CBCE60 + 0x18,
 0x1CBE300 + 0x18,
 0x1CBE2A0 + 0x18,
 0x1CBE360 + 0x18,
 0x1CBBBA0 + 0x18,
 0x1CC1900 + 0x18,
 0x1CBE6C0 + 0x18,
 0x1CBD160 + 0x18,
 0x1CBE660 + 0x18,
 0x1CC1000 + 0x18,
 0x1CC1060 + 0x18,
 0x1CC2560 + 0x18,
 0x1CC25C0 + 0x18,
 0x1CBE480 + 0x18,
 0x1CBE8A0 + 0x18,
 0x1CBE900 + 0x18,
 0x1CBEA20 + 0x18,
 0x1CBE960 + 0x18,
 0x1CBE4E0 + 0x18,
 0x1CBE9C0 + 0x18,
 0x1CC10C0 + 0x18,
 0x1CC1120 + 0x18,
 0x1CBE420 + 0x18,
 0x1CBFF20 + 0x18,
 0x1CC0040 + 0x18,
 0x1CBFFE0 + 0x18,
 0x1CBFF80 + 0x18,
 0x1CBD820 + 0x18,
 0x1CBCC80 + 0x18,
 0x1CBCCE0 + 0x18,
 0x1CBCB00 + 0x18,
 0x1CBCC20 + 0x18,
 0x1CBCA40 + 0x18,
 0x1CBCDA0 + 0x18,
 0x1CBCE00 + 0x18,
 0x1CBC980 + 0x18,
 0x1CBCB60 + 0x18,
 0x1CBCBC0 + 0x18,
 0x1CBCAA0 + 0x18,
 0x1CBCD40 + 0x18,
 0x1CBC9E0 + 0x18,
 0x1CBBA20 + 0x18,
 0x1CC2980 + 0x18,
 0x1CC0B80 + 0x18,
 0x1CC0C40 + 0x18,
 0x1CC0D00 + 0x18,
 0x1CC0BE0 + 0x18,
 0x1CC0CA0 + 0x18,
 0x1CC0D60 + 0x18,
 0x1CC0DC0 + 0x18,
 0x1CC0F40 + 0x18,
 0x1CC0E20 + 0x18,
 0x1CC0FA0 + 0x18,
 0x1CC0E80 + 0x18,
 0x1CC0EE0 + 0x18,
 0x1CC0B20 + 0x18,
 0x1CBB180 + 0x18,
 0x1CBE5A0 + 0x18,
 0x1CBE540 + 0x18,
 0x1CBE600 + 0x18,
 0x1CBD340 + 0x18,
 0x1CBB4E0 + 0x18,
 0x1CC1BA0 + 0x18,
 0x1CBB360 + 0x18,
 0x1CC0400 + 0x18,
 0x1CC0460 + 0x18,
 0x1CC04C0 + 0x18,
 0x1CC0520 + 0x18,
 0x1CC03A0 + 0x18,
 0x1CC16C0 + 0x18,
 0x1CC29E0 + 0x18,
 0x1CC13C0 + 0x18,
 0x1CC1420 + 0x18,
 0x1CBD1C0 + 0x18,
 0x1CBB600 + 0x18,
 0x1CC1360 + 0x18,
 0x1CC12A0 + 0x18,
 0x1CC1300 + 0x18,
 0x1CBBC60 + 0x18,
 0x1CC1C00 + 0x18,
 0x1CC1CC0 + 0x18,
 0x1CC1C60 + 0x18,
 0x1CBBC00 + 0x18,
 0x1CBC0E0 + 0x18,
 0x1CBC1A0 + 0x18,
 0x1CBC200 + 0x18,
 0x1CBC260 + 0x18,
 0x1CBC2C0 + 0x18,
 0x1CBC140 + 0x18,
 0x1CBCEC0 + 0x18,
 0x1CBCF20 + 0x18,
 0x1CBB720 + 0x18,
 0x1CBB7E0 + 0x18,
 0x1CBB6C0 + 0x18,
 0x1CBB780 + 0x18,
 0x1CBD2E0 + 0x18,
 0x1CBD280 + 0x18,
 0x1CBC3E0 + 0x18,
 0x1CBD220 + 0x18,
 0x1CC2500 + 0x18,
 0x1CBC7A0 + 0x18,
 0x1CBBB40 + 0x18,
 0x1CC24A0 + 0x18,
 0x1CBC440 + 0x18,
 0x1CBBD20 + 0x18,
 0x1CC1480 + 0x18,
 0x1CBBAE0 + 0x18,
 0x1CBBA80 + 0x18,
 0x1CC14E0 + 0x18,
 0x1CC1540 + 0x18,
 0x1CC15A0 + 0x18,
 0x1CC0A00 + 0x18,
 0x1CC09A0 + 0x18,
 0x1CC0880 + 0x18,
 0x1CC0940 + 0x18,
 0x1CC08E0 + 0x18,
 0x1CBD100 + 0x18,
 0x1CBD0A0 + 0x18,
 0x1CC11E0 + 0x18,
 0x1CC1240 + 0x18,
 0x1CC1180 + 0x18,
 0x1CC2620 + 0x18,
 0x1CC2680 + 0x18,
 0x1CC2AA0 + 0x18,
 0x1CBBEA0 + 0x18,
 0x1CBB1E0 + 0x18,
 0x1CC0580 + 0x18,
 0x1CC07C0 + 0x18,
 0x1CC05E0 + 0x18,
 0x1CC0700 + 0x18,
 0x1CC0820 + 0x18,
 0x1CC0760 + 0x18,
 0x1CC0640 + 0x18,
 0x1CC06A0 + 0x18,
 0x1CC0340 + 0x18,
 0x1CC02E0 + 0x18,
 0x1CBC4A0 + 0x18,
 0x1CC21A0 + 0x18,
 0x1CC26E0 + 0x18,
 0x1CC2740 + 0x18,
 0x1CC17E0 + 0x18,
 0x1CC1840 + 0x18,
 0x1CC18A0 + 0x18,
 0x1CBD040 + 0x18,
 0x1CBBF60 + 0x18,
 0x1CBBFC0 + 0x18,
 0x1CBC020 + 0x18,
 0x1CBC380 + 0x18,
 0x1CBBF00 + 0x18,
 0x1CBC080 + 0x18,
 0x1CBC320 + 0x18,
 0x1CBCFE0 + 0x18,
 0x1CBB840 + 0x18,
 0x1CBB8A0 + 0x18,
 0x1CBCF80 + 0x18,
 0x1CC2800 + 0x18,
 0x1CC2860 + 0x18,
 0x1CC28C0 + 0x18,
 0x1CC2920 + 0x18,
 0x1CC27A0 + 0x18,
 0x1CC19C0 + 0x18,
 0x1CC1780 + 0x18,
 0x1CC1720 + 0x18,
 0x1CC1DE0 + 0x18,
 0x1CC1D20 + 0x18,
 0x1CC1D80 + 0x18,
 0x1CBBE40 + 0x18,
 0x1CBC920 + 0x18,
 0x1CBC860 + 0x18,
 0x1CBC8C0 + 0x18,
 0x1CBFE60 + 0x18,
 0x1CBDFA0 + 0x18,
 0x1CBE0C0 + 0x18,
 0x1CBE120 + 0x18,
 0x1CBE060 + 0x18,
 0x1CBE000 + 0x18,
 0x1CBE180 + 0x18,
 0x1CBE1E0 + 0x18,
 0x1CBE240 + 0x18,
 0x1CBDBE0 + 0x18,
 0x1CBDC40 + 0x18,
 0x1CBDD00 + 0x18,
 0x1CBDE80 + 0x18,
 0x1CBDEE0 + 0x18,
 0x1CBDF40 + 0x18,
 0x1CBDE20 + 0x18,
 0x1CBDCA0 + 0x18,
 0x1CBDD60 + 0x18,
 0x1CBDDC0 + 0x18,
 0x1CC1600 + 0x18,
 0x1CBB120 + 0x18,
 0x1CBAE80 + 0x18,
 0x1CBAEE0 + 0x18,
 0x1CBADC0 + 0x18,
 0x1CBAE20 + 0x18,
 0x1CBAD60 + 0x18,
 0x1CBACA0 + 0x18,
 0x1CBAD00 + 0x18,
 0x1CBAC40 + 0x18,
 0x1CBABE0 + 0x18,
 0x1CBAB80 + 0x18,
 0x1CBAB20 + 0x18,
 0x1CBAAC0 + 0x18,
 0x1CBAA60 + 0x18,
 0x1CBF560 + 0x18,
 0x1CBB060 + 0x18,
 0x1CBB0C0 + 0x18,
 0x1CBAFA0 + 0x18,
 0x1CBB000 + 0x18,
 0x1CBAF40 + 0x18,
 0x1CBA9A0 + 0x18,
 0x1CBAA00 + 0x18,
 0x1CC1660 + 0x18,
 0x1CBF5C0 + 0x18,
 0x1CC1E40 + 0x18,
 0x1CC1EA0 + 0x18,
 0x1CC1F00 + 0x18,
 0x1CC2200 + 0x18,
 0x1CBB420 + 0x18,
 0x1CBB480 + 0x18,
 0x1CDC4E0 + 0x18,
 0x1CC2260 + 0x18,
 0x1CC2440 + 0x18,
 0x1CC22C0 + 0x18,
 0x1CC23E0 + 0x18,
 0x1CC2320 + 0x18,
 0x1CC2380 + 0x18,
 0x1CC2B00 + 0x18,
 0x1CBFEC0 + 0x18,
 0x1CBC680 + 0x18,
 0x1CBC500 + 0x18,
 0x1CBC560 + 0x18,
 0x1CBE720 + 0x18,
 0x1CC00A0 + 0x18,
 0x1CC0160 + 0x18,
 0x1CC0100 + 0x18,
 0x1CC01C0 + 0x18,
 0x1CC0220 + 0x18,
 0x1CDD140 + 0x18,
 0x1CBF6E0 + 0x18,
 0x1CBF620 + 0x18,
 0x1CBF860 + 0x18,
 0x1CBF8C0 + 0x18,
 0x1CBF740 + 0x18,
 0x1CBF920 + 0x18,
 0x1CBF980 + 0x18,
 0x1CBF800 + 0x18,
 0x1CBF7A0 + 0x18,
 0x1CBF680 + 0x18,
 0x1CC0A60 + 0x18,
 0x1CC0AC0 + 0x18,
 0x1CBB660 + 0x18,
 0x1CBB9C0 + 0x18,
 0x1CBB960 + 0x18,
 0x1CBEF00 + 0x18,
 0x1CBD8E0 + 0x18,
 0x1CBD880 + 0x18,
 0x1CBD9A0 + 0x18,
 0x1CBD940 + 0x18,
 0x1CA7CE0 + 0x18,
 0x1CD0DE0 + 0x18,
 0x1CD0D20 + 0x18,
 0x1CD0D80 + 0x18,
 0x1CD0B40 + 0x18,
 0x1CD0C60 + 0x18,
 0x1CD0CC0 + 0x18,
 0x1CD0BA0 + 0x18,
 0x1CD0F00 + 0x18,
 0x1CD0E40 + 0x18,
 0x1CD0C00 + 0x18,
 0x1CD0FC0 + 0x18,
 0x1CD0EA0 + 0x18,
 0x1CD0F60 + 0x18,
 0x1CB6A40 + 0x18,
 0x1CD8340 + 0x18,
 0x1CCAA20 + 0x18,
 0x1CCAA80 + 0x18,
 0x1CCAAE0 + 0x18,
 0x1CCAB40 + 0x18,
 0x1CE04A0 + 0x18,
 0x1CE0500 + 0x18,
 0x1CDBC40 + 0x18,
 0x1CC2CE0 + 0x18,
 0x1CAD080 + 0x18,
 0x1CB2600 + 0x18,
 0x1CB22A0 + 0x18,
 0x1CB26C0 + 0x18,
 0x1CB2660 + 0x18,
 0x1CB2240 + 0x18,
 0x1CB24E0 + 0x18,
 0x1CB2540 + 0x18,
 0x1CB25A0 + 0x18,
 0x1CB2420 + 0x18,
 0x1CB2480 + 0x18,
 0x1CB2300 + 0x18,
 0x1CB2360 + 0x18,
 0x1CB23C0 + 0x18,
 0x1CC30A0 + 0x18,
 0x1CC3100 + 0x18,
 0x1CB8CC0 + 0x18,
 0x1CE7B20 + 0x18,
 0x1CB8D80 + 0x18,
 0x1CE7AC0 + 0x18,
 0x1CE30E0 + 0x18,
 0x1CE3080 + 0x18,
 0x1CE3020 + 0x18,
 0x1CE3140 + 0x18,
 0x1CE2FC0 + 0x18,
 0x1CB8DE0 + 0x18,
 0x1CE68C0 + 0x18,
 0x1CE6860 + 0x18,
 0x1CDD860 + 0x18,
 0x1CDD8C0 + 0x18,
 0x1CDD800 + 0x18,
 0x1CDC960 + 0x18,
 0x1CE6EC0 + 0x18,
 0x1CEB4E0 + 0x18,
 0x1CDC900 + 0x18,
 0x1CE2C00 + 0x18,
 0x1CE2C60 + 0x18,
 0x1CDDA40 + 0x18,
 0x1CDDB00 + 0x18,
 0x1CDDAA0 + 0x18,
 0x1CE3C80 + 0x18,
 0x1CB06E0 + 0x18,
 0x1CE6920 + 0x18,
 0x1CE3260 + 0x18,
 0x1CDD1A0 + 0x18,
 0x1CE32C0 + 0x18,
 0x1CE8BA0 + 0x18,
 0x1CE3320 + 0x18,
 0x1CE8B40 + 0x18,
 0x1CDD740 + 0x18,
 0x1CE1EE0 + 0x18,
 0x1CE38C0 + 0x18,
 0x1CE37A0 + 0x18,
 0x1CDCA20 + 0x18,
 0x1CE3800 + 0x18,
 0x1CE36E0 + 0x18,
 0x1CE3740 + 0x18,
 0x1CE3860 + 0x18,
 0x1CDC9C0 + 0x18,
 0x1CE88A0 + 0x18,
 0x1CE7C40 + 0x18,
 0x1CE8480 + 0x18,
 0x1CE7D00 + 0x18,
 0x1CE8540 + 0x18,
 0x1CE84E0 + 0x18,
 0x1CE7E20 + 0x18,
 0x1CE7E80 + 0x18,
 0x1CE7DC0 + 0x18,
 0x1CE8840 + 0x18,
 0x1CE87E0 + 0x18,
 0x1CE80C0 + 0x18,
 0x1CE7B80 + 0x18,
 0x1CE7CA0 + 0x18,
 0x1CE8360 + 0x18,
 0x1CE7D60 + 0x18,
 0x1CE8060 + 0x18,
 0x1CE8240 + 0x18,
 0x1CE8720 + 0x18,
 0x1CE7BE0 + 0x18,
 0x1CE83C0 + 0x18,
 0x1CE8420 + 0x18,
 0x1CE8660 + 0x18,
 0x1CE86C0 + 0x18,
 0x1CE8600 + 0x18,
 0x1CE8300 + 0x18,
 0x1CE81E0 + 0x18,
 0x1CE7EE0 + 0x18,
 0x1CE8120 + 0x18,
 0x1CE82A0 + 0x18,
 0x1CE8180 + 0x18,
 0x1CE7FA0 + 0x18,
 0x1CE7F40 + 0x18,
 0x1CE8000 + 0x18,
 0x1CE8780 + 0x18,
 0x1CE85A0 + 0x18,
 0x1CB88A0 + 0x18,
 0x1CB8A20 + 0x18,
 0x1CE6C20 + 0x18,
 0x1CE2F60 + 0x18,
 0x1CDCD80 + 0x18,
 0x1CE8900 + 0x18,
 0x1CE6AA0 + 0x18,
 0x1CB8A80 + 0x18,
 0x1CE2F00 + 0x18,
 0x1CE3380 + 0x18,
 0x1CB0680 + 0x18,
 0x1CE7280 + 0x18,
 0x1CE6FE0 + 0x18,
 0x1CE6F20 + 0x18,
 0x1CE7040 + 0x18,
 0x1CE70A0 + 0x18,
 0x1CE7160 + 0x18,
 0x1CE7100 + 0x18,
 0x1CE7220 + 0x18,
 0x1CE6F80 + 0x18,
 0x1CE71C0 + 0x18,
 0x1CE8A80 + 0x18,
 0x1CDD9E0 + 0x18,
 0x1CDD7A0 + 0x18,
 0x1CE8960 + 0x18,
 0x1CE89C0 + 0x18,
 0x1CE8A20 + 0x18,
 0x1CE3CE0 + 0x18,
 0x1CDD920 + 0x18,
 0x1CDD980 + 0x18,
 0x1CE3D40 + 0x18,
 0x1CEB540 + 0x18,
 0x1CDD620 + 0x18,
 0x1CDCE40 + 0x18,
 0x1CE5120 + 0x18,
 0x1CE5060 + 0x18,
 0x1CE50C0 + 0x18,
 0x1CE4580 + 0x18,
 0x1CE44C0 + 0x18,
 0x1CE4520 + 0x18,
 0x1CE4C40 + 0x18,
 0x1CE4B80 + 0x18,
 0x1CE4BE0 + 0x18,
 0x1CE4B20 + 0x18,
 0x1CE4A60 + 0x18,
 0x1CE4AC0 + 0x18,
 0x1CE48E0 + 0x18,
 0x1CE4820 + 0x18,
 0x1CE4880 + 0x18,
 0x1CE4100 + 0x18,
 0x1CE4220 + 0x18,
 0x1CE4160 + 0x18,
 0x1CE41C0 + 0x18,
 0x1CE40A0 + 0x18,
 0x1CE4460 + 0x18,
 0x1CE43A0 + 0x18,
 0x1CE4400 + 0x18,
 0x1CE4040 + 0x18,
 0x1CE3F80 + 0x18,
 0x1CE3FE0 + 0x18,
 0x1CE5240 + 0x18,
 0x1CE51E0 + 0x18,
 0x1CE5180 + 0x18,
 0x1CE52A0 + 0x18,
 0x1CE72E0 + 0x18,
 0x1CE7340 + 0x18,
 0x1CEB480 + 0x18,
 0x1CE3F20 + 0x18,
 0x1CE3E60 + 0x18,
 0x1CE3EC0 + 0x18,
 0x1CE47C0 + 0x18,
 0x1CE4700 + 0x18,
 0x1CE4760 + 0x18,
 0x1CE46A0 + 0x18,
 0x1CE45E0 + 0x18,
 0x1CE4640 + 0x18,
 0x1CE5420 + 0x18,
 0x1CE53C0 + 0x18,
 0x1CE5300 + 0x18,
 0x1CE5360 + 0x18,
 0x1CE4A00 + 0x18,
 0x1CE4940 + 0x18,
 0x1CE49A0 + 0x18,
 0x1CE3E00 + 0x18,
 0x1CE56C0 + 0x18,
 0x1CE5600 + 0x18,
 0x1CE5660 + 0x18,
 0x1CE5000 + 0x18,
 0x1CE4FA0 + 0x18,
 0x1CE4EE0 + 0x18,
 0x1CE4F40 + 0x18,
 0x1CE4E80 + 0x18,
 0x1CE4DC0 + 0x18,
 0x1CE4E20 + 0x18,
 0x1CE3DA0 + 0x18,
 0x1CE4D60 + 0x18,
 0x1CE4CA0 + 0x18,
 0x1CE4D00 + 0x18,
 0x1CE55A0 + 0x18,
 0x1CE5540 + 0x18,
 0x1CE5480 + 0x18,
 0x1CE54E0 + 0x18,
 0x1CE4340 + 0x18,
 0x1CE4280 + 0x18,
 0x1CE42E0 + 0x18,
 0x1CAB9A0 + 0x18,
 0x1CDCAE0 + 0x18,
 0x1CDCA80 + 0x18,
 0x1CE6C80 + 0x18,
 0x1CE6CE0 + 0x18,
 0x1CE8AE0 + 0x18,
 0x1CE58A0 + 0x18,
 0x1CE5840 + 0x18,
 0x1CE5BA0 + 0x18,
 0x1CE5720 + 0x18,
 0x1CE5C00 + 0x18,
 0x1CE5C60 + 0x18,
 0x1CE5CC0 + 0x18,
 0x1CE5A80 + 0x18,
 0x1CE5A20 + 0x18,
 0x1CE59C0 + 0x18,
 0x1CE5AE0 + 0x18,
 0x1CE5B40 + 0x18,
 0x1CE5960 + 0x18,
 0x1CE5900 + 0x18,
 0x1CE6020 + 0x18,
 0x1CE5FC0 + 0x18,
 0x1CE6560 + 0x18,
 0x1CE65C0 + 0x18,
 0x1CE6500 + 0x18,
 0x1CE5780 + 0x18,
 0x1CE57E0 + 0x18,
 0x1CE64A0 + 0x18,
 0x1CE60E0 + 0x18,
 0x1CE6320 + 0x18,
 0x1CE6380 + 0x18,
 0x1CE6440 + 0x18,
 0x1CE63E0 + 0x18,
 0x1CE6200 + 0x18,
 0x1CE61A0 + 0x18,
 0x1CE6140 + 0x18,
 0x1CE6080 + 0x18,
 0x1CE6680 + 0x18,
 0x1CE6620 + 0x18,
 0x1CE6260 + 0x18,
 0x1CE62C0 + 0x18,
 0x1CE5DE0 + 0x18,
 0x1CE5EA0 + 0x18,
 0x1CE5E40 + 0x18,
 0x1CE5F60 + 0x18,
 0x1CE5F00 + 0x18,
 0x1CE5D20 + 0x18,
 0x1CE5D80 + 0x18,
 0x1CE3A40 + 0x18,
 0x1CDD200 + 0x18,
 0x1CDCF00 + 0x18,
 0x1CDD020 + 0x18,
 0x1CDCF60 + 0x18,
 0x1CDD080 + 0x18,
 0x1CDCFC0 + 0x18,
 0x1CDD0E0 + 0x18,
 0x1CB8E40 + 0x18,
 0x1CDCEA0 + 0x18,
 0x1CDCDE0 + 0x18,
 0x1CB89C0 + 0x18,
 0x1CE35C0 + 0x18,
 0x1CE3500 + 0x18,
 0x1CE34A0 + 0x18,
 0x1CE33E0 + 0x18,
 0x1CE3680 + 0x18,
 0x1CE3620 + 0x18,
 0x1CE3560 + 0x18,
 0x1CE3440 + 0x18,
 0x1CE6D40 + 0x18,
 0x1CE6E00 + 0x18,
 0x1CE6DA0 + 0x18,
 0x1CE6E60 + 0x18,
 0x1CDCCC0 + 0x18,
 0x1CDCD20 + 0x18,
 0x1CD7B00 + 0x18,
 0x1CD7B60 + 0x18,
 0x1CD7920 + 0x18,
 0x1CD7980 + 0x18,
 0x1CD79E0 + 0x18,
 0x1CD7A40 + 0x18,
 0x1CD7AA0 + 0x18,
 0x1CD7800 + 0x18,
 0x1CD7860 + 0x18,
 0x1CD77A0 + 0x18,
 0x1CD78C0 + 0x18,
 0x1CE14C0 + 0x18,
 0x1CE1460 + 0x18,
 0x1CE1520 + 0x18,
 0x1CE15E0 + 0x18,
 0x1CE1580 + 0x18,
 0x1CDAEC0 + 0x18,
 0x1CD76E0 + 0x18,
 0x1CD3060 + 0x18,
 0x1CB27E0 + 0x18,
 0x1CB2840 + 0x18,
 0x1CB2720 + 0x18,
 0x1CB2780 + 0x18,
 0x1CB21E0 + 0x18,
 0x1CB2180 + 0x18,
 0x1CB1E80 + 0x18,
 0x1CB1E20 + 0x18,
 0x1CB20C0 + 0x18,
 0x1CB2060 + 0x18,
 0x1CB2000 + 0x18,
 0x1CB1FA0 + 0x18,
 0x1CB2120 + 0x18,
 0x1CB1F40 + 0x18,
 0x1CB1EE0 + 0x18,
 0x1CB28A0 + 0x18,
 0x1CDDBC0 + 0x18,
 0x1CCAC00 + 0x18,
 0x1CCABA0 + 0x18,
 0x1CB8240 + 0x18,
 0x1CCB500 + 0x18,
 0x1CE2BA0 + 0x18,
 0x1CD81C0 + 0x18,
 0x1CD8280 + 0x18,
 0x1CD8220 + 0x18,
 0x1CD82E0 + 0x18,
 0x1CBDB80 + 0x18,
 0x1CBD520 + 0x18,
 0x1CBD4C0 + 0x18,
 0x1CBD460 + 0x18,
 0x1CBD580 + 0x18,
 0x1CBDAC0 + 0x18,
 0x1CBDB20 + 0x18,
 0x1CBD5E0 + 0x18,
 0x1CBD3A0 + 0x18,
 0x1CBD400 + 0x18,
 0x1CBD640 + 0x18,
 0x1CBD6A0 + 0x18,
 0x1CBD700 + 0x18,
 0x1CBD760 + 0x18,
 0x1CBD7C0 + 0x18,
 0x1CC5560 + 0x18,
 0x1CEB3C0 + 0x18,
 0x1CD1080 + 0x18,
 0x1CBA400 + 0x18,
 0x1CCC820 + 0x18,
 0x1CCC9A0 + 0x18,
 0x1CCC940 + 0x18,
 0x1CCD1E0 + 0x18,
 0x1CCD180 + 0x18,
 0x1CCCFA0 + 0x18,
 0x1CCCF40 + 0x18,
 0x1CCD060 + 0x18,
 0x1CCD000 + 0x18,
 0x1CCD120 + 0x18,
 0x1CCD0C0 + 0x18,
 0x1CCCEE0 + 0x18,
 0x1CCCE80 + 0x18,
 0x1CCCB20 + 0x18,
 0x1CCCAC0 + 0x18,
 0x1CCCCA0 + 0x18,
 0x1CCCBE0 + 0x18,
 0x1CCCC40 + 0x18,
 0x1CCCB80 + 0x18,
 0x1CCCE20 + 0x18,
 0x1CCCD60 + 0x18,
 0x1CCCDC0 + 0x18,
 0x1CCCD00 + 0x18,
 0x1CCC880 + 0x18,
 0x1CCC8E0 + 0x18,
 0x1CCD300 + 0x18,
 0x1CCD2A0 + 0x18,
 0x1CCD3C0 + 0x18,
 0x1CCD360 + 0x18,
 0x1CCD240 + 0x18,
 0x1CBA3A0 + 0x18,
 0x1CC5860 + 0x18,
 0x1CC58C0 + 0x18,
 0x1CBA640 + 0x18,
 0x1CCD540 + 0x18,
 0x1CCD600 + 0x18,
 0x1CCD5A0 + 0x18,
 0x1CBA460 + 0x18,
 0x1CBA4C0 + 0x18,
 0x1CCD420 + 0x18,
 0x1CCD4E0 + 0x18,
 0x1CCD480 + 0x18,
 0x1CBA6A0 + 0x18,
 0x1CBA700 + 0x18,
 0x1CBA760 + 0x18,
 0x1CCCA60 + 0x18,
 0x1CCCA00 + 0x18,
 0x1CBA520 + 0x18,
 0x1CBA580 + 0x18,
 0x1CBA5E0 + 0x18,
 0x1CB4FA0 + 0x18,
 0x1CB51E0 + 0x18,
 0x1CB4EE0 + 0x18,
 0x1CB4E80 + 0x18,
 0x1CB4F40 + 0x18,
 0x1CB5000 + 0x18,
 0x1CB4580 + 0x18,
 0x1CB4A00 + 0x18,
 0x1CB45E0 + 0x18,
 0x1CB47C0 + 0x18,
 0x1CB4760 + 0x18,
 0x1CB4700 + 0x18,
 0x1CB4AC0 + 0x18,
 0x1CB4820 + 0x18,
 0x1CB46A0 + 0x18,
 0x1CB4640 + 0x18,
 0x1CB4A60 + 0x18,
 0x1CB48E0 + 0x18,
 0x1CB4880 + 0x18,
 0x1CB4940 + 0x18,
 0x1CB49A0 + 0x18,
 0x1CB52A0 + 0x18,
 0x1CB5240 + 0x18,
 0x1CB4D00 + 0x18,
 0x1CB4D60 + 0x18,
 0x1CB4CA0 + 0x18,
 0x1CB5300 + 0x18,
 0x1CB5180 + 0x18,
 0x1CB5120 + 0x18,
 0x1CB5060 + 0x18,
 0x1CB50C0 + 0x18,
 0x1CB4DC0 + 0x18,
 0x1CB4E20 + 0x18,
 0x1CB4BE0 + 0x18,
 0x1CB4B80 + 0x18,
 0x1CB4B20 + 0x18,
 0x1CB4C40 + 0x18,
 0x1CB6C80 + 0x18,
 0x1CE16A0 + 0x18,
 0x1CE1700 + 0x18,
 0x1CB6CE0 + 0x18,
 0x1CB7640 + 0x18,
 0x1CC2FE0 + 0x18,
 0x1CD9900 + 0x18,
 0x1CD9D80 + 0x18,
 0x1CABB20 + 0x18,
 0x1CD97E0 + 0x18,
 0x1CDB9A0 + 0x18,
 0x1CDF9C0 + 0x18,
 0x1CDF780 + 0x18,
 0x1CA3EA0 + 0x18,
 0x1CDDFE0 + 0x18,
 0x1CDF120 + 0x18,
 0x1CDF180 + 0x18,
 0x1CE0320 + 0x18,
 0x1CE0380 + 0x18,
 0x1CDF5A0 + 0x18,
 0x1CDFA80 + 0x18,
 0x1CDF000 + 0x18,
 0x1CDF360 + 0x18,
 0x1CDF960 + 0x18,
 0x1CDF420 + 0x18,
 0x1CB77C0 + 0x18,
 0x1CB7820 + 0x18,
 0x1CDF600 + 0x18,
 0x1CB7880 + 0x18,
 0x1CDF060 + 0x18,
 0x1CDF7E0 + 0x18,
 0x1CDF840 + 0x18,
 0x1CDCC60 + 0x18,
 0x1CDFBA0 + 0x18,
 0x1CDF4E0 + 0x18,
 0x1CDF480 + 0x18,
 0x1CDF900 + 0x18,
 0x1CB7D60 + 0x18,
 0x1CDFAE0 + 0x18,
 0x1CDF0C0 + 0x18,
 0x1CDFC00 + 0x18,
 0x1CB7E20 + 0x18,
 0x1CDFA20 + 0x18,
 0x1CDEF40 + 0x18,
 0x1CDEFA0 + 0x18,
 0x1CDFFC0 + 0x18,
 0x1CDFF60 + 0x18,
 0x1CDFC60 + 0x18,
 0x1CDFD20 + 0x18,
 0x1CDFCC0 + 0x18,
 0x1CDFDE0 + 0x18,
 0x1CDFE40 + 0x18,
 0x1CDFEA0 + 0x18,
 0x1CDFF00 + 0x18,
 0x1CDFD80 + 0x18,
 0x1CDF720 + 0x18,
 0x1CDFB40 + 0x18,
 0x1CB7FA0 + 0x18,
 0x1CE0020 + 0x18,
 0x1CDEEE0 + 0x18,
 0x1CDF540 + 0x18,
 0x1CDF660 + 0x18,
 0x1CDF6C0 + 0x18,
 0x1CB6AA0 + 0x18,
 0x1CDAF80 + 0x18,
 0x1CDB4C0 + 0x18,
 0x1CD4CE0 + 0x18,
 0x1CD4980 + 0x18,
 0x1CB6FE0 + 0x18,
 0x1CE1760 + 0x18,
 0x1CB7BE0 + 0x18,
 0x1CB4460 + 0x18,
 0x1CB4520 + 0x18,
 0x1CB44C0 + 0x18,
 0x1CCFDC0 + 0x18,
 0x1CCFD60 + 0x18,
 0x1CA4500 + 0x18,
 0x1CB6D40 + 0x18,
 0x1CDBB80 + 0x18,
 0x1CE2EA0 + 0x18,
 0x1CB93E0 + 0x18,
 0x1CCE2C0 + 0x18,
 0x1CDBBE0 + 0x18,
 0x1CCFE20 + 0x18,
 0x1CB6560 + 0x18,
 0x1CDA440 + 0x18,
 0x1CB7460 + 0x18,
 0x1CD4A40 + 0x18,
 0x1CD4B00 + 0x18,
 0x1CD4AA0 + 0x18,
 0x1CAE1C0 + 0x18,
 0x1CD3C60 + 0x18,
 0x1CA4560 + 0x18,
 0x1CD34E0 + 0x18,
 0x1CD3C00 + 0x18,
 0x1CD9540 + 0x18,
 0x1CB9440 + 0x18,
 0x1CAAC20 + 0x18,
 0x1CDA1A0 + 0x18,
 0x1CDA200 + 0x18,
 0x1CA91E0 + 0x18,
 0x1CCDEA0 + 0x18,
 0x1CCE5C0 + 0x18,
 0x1CB6200 + 0x18,
 0x1CD8160 + 0x18,
 0x1CD3DE0 + 0x18,
 0x1CB9500 + 0x18,
 0x1CCE6E0 + 0x18,
 0x1CAF3C0 + 0x18,
 0x1CAF360 + 0x18,
 0x1CCDE40 + 0x18,
 0x1CB94A0 + 0x18,
 0x1CB9560 + 0x18,
 0x1CAC7E0 + 0x18,
 0x1CD7C20 + 0x18,
 0x1CD36C0 + 0x18,
 0x1CAF4E0 + 0x18,
 0x1CCE620 + 0x18,
 0x1CAB280 + 0x18,
 0x1CCFE80 + 0x18,
 0x1CB6260 + 0x18,
 0x1CAF540 + 0x18,
 0x1CD95A0 + 0x18,
 0x1CD4E60 + 0x18,
 0x1CB62C0 + 0x18,
 0x1CB95C0 + 0x18,
 0x1CDA2C0 + 0x18,
 0x1CDA260 + 0x18,
 0x1CD7260 + 0x18,
 0x1CD3A80 + 0x18,
 0x1CE06E0 + 0x18,
 0x1CE0740 + 0x18,
 0x1CD72C0 + 0x18,
 0x1CD3A20 + 0x18,
 0x1CD39C0 + 0x18,
 0x1CD9DE0 + 0x18,
 0x1CD9120 + 0x18,
 0x1CD9EA0 + 0x18,
 0x1CD9E40 + 0x18,
 0x1CD9180 + 0x18,
 0x1CD91E0 + 0x18,
 0x1CB10A0 + 0x18,
 0x1CAF240 + 0x18,
 0x1CD7EC0 + 0x18,
 0x1CCE260 + 0x18,
 0x1CD9240 + 0x18,
 0x1CD3B40 + 0x18,
 0x1CD7DA0 + 0x18,
 0x1CC9AC0 + 0x18,
 0x1CC9B20 + 0x18,
 0x1CC9B80 + 0x18,
 0x1CC3CA0 + 0x18,
 0x1CD7E60 + 0x18,
 0x1CD9F00 + 0x18,
 0x1CE08C0 + 0x18,
 0x1CD7380 + 0x18,
 0x1CD7320 + 0x18,
 0x1CD4440 + 0x18,
 0x1CD7D40 + 0x18,
 0x1CAF2A0 + 0x18,
 0x1CAE160 + 0x18,
 0x1CDBA60 + 0x18,
 0x1CD7E00 + 0x18,
 0x1CD92A0 + 0x18,
 0x1CC3BE0 + 0x18,
 0x1CD7F20 + 0x18,
 0x1CE9BC0 + 0x18,
 0x1CDED60 + 0x18,
 0x1CCE440 + 0x18,
 0x1CAF720 + 0x18,
 0x1CAF6C0 + 0x18,
 0x1CAF780 + 0x18,
 0x1CDAB00 + 0x18,
 0x1CDAB60 + 0x18,
 0x1CD8040 + 0x18,
 0x1CD7F80 + 0x18,
 0x1CD7FE0 + 0x18,
 0x1CD80A0 + 0x18,
 0x1CAF300 + 0x18,
 0x1CD73E0 + 0x18,
 0x1CB7400 + 0x18,
 0x1CD9360 + 0x18,
 0x1CD9300 + 0x18,
 0x1CE2E40 + 0x18,
 0x1CE2DE0 + 0x18,
 0x1CD9FC0 + 0x18,
 0x1CD9F60 + 0x18,
 0x1CDA080 + 0x18,
 0x1CDA020 + 0x18,
 0x1CE2120 + 0x18,
 0x1CD93C0 + 0x18,
 0x1CD8100 + 0x18,
 0x1CD7440 + 0x18,
 0x1CDA3E0 + 0x18,
 0x1CDBD00 + 0x18,
 0x1CDD680 + 0x18,
 0x1CDA0E0 + 0x18,
 0x1CDA380 + 0x18,
 0x1CDBAC0 + 0x18,
 0x1CD09C0 + 0x18,
 0x1CD9420 + 0x18,
 0x1CDA140 + 0x18,
 0x1CDA320 + 0x18,
 0x1CD4D40 + 0x18,
 0x1CCE560 + 0x18,
 0x1CD7BC0 + 0x18,
 0x1CC7E40 + 0x18,
 0x1CDBB20 + 0x18,
 0x1CD4E00 + 0x18,
 0x1CD74A0 + 0x18,
 0x1CD9480 + 0x18,
 0x1CCE500 + 0x18,
 0x1CD4DA0 + 0x18,
 0x1CCE4A0 + 0x18,
 0x1CB9380 + 0x18,
 0x1CCDDE0 + 0x18,
 0x1CD94E0 + 0x18,
 0x1CE0BC0 + 0x18,
 0x1CEABE0 + 0x18,
 0x1CE24E0 + 0x18,
 0x1CB3E00 + 0x18,
 0x1CB3E60 + 0x18,
 0x1CB6020 + 0x18,
 0x1CB3CE0 + 0x18,
 0x1CB3D40 + 0x18,
 0x1CB3DA0 + 0x18,
 0x1CA90C0 + 0x18,
 0x1CB0D40 + 0x18,
 0x1CB0DA0 + 0x18,
 0x1CA9120 + 0x18,
 0x1CA9180 + 0x18,
 0x1CB0FE0 + 0x18,
 0x1CB0F80 + 0x18,
 0x1CA8460 + 0x18,
 0x1CD4560 + 0x18,
 0x1CD45C0 + 0x18,
 0x1CD4620 + 0x18,
 0x1CD44A0 + 0x18,
 0x1CD4500 + 0x18,
 0x1CCA960 + 0x18,
 0x1CE25A0 + 0x18,
 0x1CDC780 + 0x18,
 0x1CE31A0 + 0x18,
 0x1CE6B60 + 0x18,
 0x1CCB320 + 0x18,
 0x1CE0980 + 0x18,
 0x1CB8720 + 0x18,
 0x1CDC5A0 + 0x18,
 0x1CDC720 + 0x18,
 0x1CE2900 + 0x18,
 0x1CE1FA0 + 0x18,
 0x1CB8480 + 0x18,
 0x1CD3600 + 0x18,
 0x1CE0F20 + 0x18,
 0x1CB6440 + 0x18,
 0x1CE0AA0 + 0x18,
 0x1CE0B00 + 0x18,
 0x1CE0A40 + 0x18,
 0x1CE09E0 + 0x18,
 0x1CB84E0 + 0x18,
 0x1CE1340 + 0x18,
 0x1CD3780 + 0x18,
 0x1CE2180 + 0x18,
 0x1CE1280 + 0x18,
 0x1CE2480 + 0x18,
 0x1CB87E0 + 0x18,
 0x1CD33C0 + 0x18,
 0x1CC7600 + 0x18,
 0x1CD3360 + 0x18,
 0x1CD3420 + 0x18,
 0x1CD3240 + 0x18,
 0x1CB8660 + 0x18,
 0x1CB86C0 + 0x18,
 0x1CB8600 + 0x18,
 0x1CE1BE0 + 0x18,
 0x1CDC600 + 0x18,
 0x1CE1D60 + 0x18,
 0x1CE11C0 + 0x18,
 0x1CE1220 + 0x18,
 0x1CE6BC0 + 0x18,
 0x1CE2A20 + 0x18,
 0x1CE2300 + 0x18,
 0x1CE2360 + 0x18,
 0x1CE2420 + 0x18,
 0x1CE23C0 + 0x18,
 0x1CB83C0 + 0x18,
 0x1CE12E0 + 0x18,
 0x1CE69E0 + 0x18,
 0x1CD3480 + 0x18,
 0x1CE3920 + 0x18,
 0x1CDD5C0 + 0x18,
 0x1CE2960 + 0x18,
 0x1CE29C0 + 0x18,
 0x1CDBDC0 + 0x18,
 0x1CDBE20 + 0x18,
 0x1CE2240 + 0x18,
 0x1CE6A40 + 0x18,
 0x1CDCB40 + 0x18,
 0x1CDCBA0 + 0x18,
 0x1CDCC00 + 0x18,
 0x1CE2600 + 0x18,
 0x1CE1160 + 0x18,
 0x1CDB7C0 + 0x18,
 0x1CDB5E0 + 0x18,
 0x1CD31E0 + 0x18,
 0x1CE1E20 + 0x18,
 0x1CE20C0 + 0x18,
 0x1CE1DC0 + 0x18,
 0x1CE0E60 + 0x18,
 0x1CE0EC0 + 0x18,
 0x1CE0C80 + 0x18,
 0x1CE0CE0 + 0x18,
 0x1CE0D40 + 0x18,
 0x1CE0DA0 + 0x18,
 0x1CE0E00 + 0x18,
 0x1CB8420 + 0x18,
 0x1CE1CA0 + 0x18,
 0x1CE10A0 + 0x18,
 0x1CE2540 + 0x18,
 0x1CE1C40 + 0x18,
 0x1CB8540 + 0x18,
 0x1CB8360 + 0x18,
 0x1CE1040 + 0x18,
 0x1CE1400 + 0x18,
 0x1CE6B00 + 0x18,
 0x1CE1A60 + 0x18,
 0x1CDC840 + 0x18,
 0x1CDC8A0 + 0x18,
 0x1CD3660 + 0x18,
 0x1CE2B40 + 0x18,
 0x1CE0C20 + 0x18,
 0x1CD35A0 + 0x18,
 0x1CDC6C0 + 0x18,
 0x1CE26C0 + 0x18,
 0x1CE2660 + 0x18,
 0x1CE1B80 + 0x18,
 0x1CE2AE0 + 0x18,
 0x1CE2A80 + 0x18,
 0x1CE0B60 + 0x18,
 0x1CE0F80 + 0x18,
 0x1CE0FE0 + 0x18,
 0x1CE1100 + 0x18,
 0x1CE22A0 + 0x18,
 0x1CCB2C0 + 0x18,
 0x1CC3160 + 0x18,
 0x1CE3C20 + 0x18,
 0x1CA4C20 + 0x18,
 0x1CA4BC0 + 0x18,
 0x1CA4B00 + 0x18,
 0x1CA4B60 + 0x18,
 0x1CE1AC0 + 0x18,
 0x1CE1A00 + 0x18,
 0x1CE1B20 + 0x18,
 0x1CA4AA0 + 0x18,
 0x1CE19A0 + 0x18,
 0x1CE18E0 + 0x18,
 0x1CE1880 + 0x18,
 0x1CE1940 + 0x18,
 0x1CE13A0 + 0x18,
 0x1CB85A0 + 0x18,
 0x1CE1820 + 0x18,
 0x1CE17C0 + 0x18,
 0x1CDC7E0 + 0x18,
 0x1CDBE80 + 0x18,
 0x1CDC540 + 0x18,
 0x1CE21E0 + 0x18,
 0x1CE1F40 + 0x18,
 0x1CD32A0 + 0x18,
 0x1CD3180 + 0x18,
 0x1CD3540 + 0x18,
 0x1CE39E0 + 0x18,
 0x1CE3BC0 + 0x18,
 0x1CD3300 + 0x18,
 0x1CDD320 + 0x18,
 0x1CE3980 + 0x18,
 0x1CD9720 + 0x18,
 0x1CB7EE0 + 0x18,
 0x1CB7F40 + 0x18,
 0x1CD6F00 + 0x18,
 0x1CBF440 + 0x18,
 0x1CBF380 + 0x18,
 0x1CBF3E0 + 0x18,
 0x1CBF320 + 0x18,
 0x1CBF2C0 + 0x18,
 0x1CBF260 + 0x18,
 0x1CBEAE0 + 0x18,
 0x1CBEB40 + 0x18,
 0x1CBEBA0 + 0x18,
 0x1CBEC00 + 0x18,
 0x1CBEC60 + 0x18,
 0x1CBF4A0 + 0x18,
 0x1CBF200 + 0x18,
 0x1CBF1A0 + 0x18,
 0x1CBF140 + 0x18,
 0x1CBEFC0 + 0x18,
 0x1CBECC0 + 0x18,
 0x1CBED20 + 0x18,
 0x1CBEF60 + 0x18,
 0x1CBF0E0 + 0x18,
 0x1CBF080 + 0x18,
 0x1CBF020 + 0x18,
 0x1CBF500 + 0x18,
 0x1CBED80 + 0x18,
 0x1CBEDE0 + 0x18,
 0x1CB7100 + 0x18,
 0x1CE0920 + 0x18,
 0x1CB2960 + 0x18,
 0x1CB2900 + 0x18,
 0x1CA8340 + 0x18,
 0x1CA8E80 + 0x18,
 0x1CA8DC0 + 0x18,
 0x1CA8E20 + 0x18,
 0x1CA8D00 + 0x18,
 0x1CA8D60 + 0x18,
 0x1CA8CA0 + 0x18,
 0x1CA8AC0 + 0x18,
 0x1CA8A60 + 0x18,
 0x1CA86A0 + 0x18,
 0x1CA88E0 + 0x18,
 0x1CA8C40 + 0x18,
 0x1CA8BE0 + 0x18,
 0x1CA8B80 + 0x18,
 0x1CA8A00 + 0x18,
 0x1CA8700 + 0x18,
 0x1CA8B20 + 0x18,
 0x1CA87C0 + 0x18,
 0x1CA8880 + 0x18,
 0x1CA8760 + 0x18,
 0x1CA89A0 + 0x18,
 0x1CA8820 + 0x18,
 0x1CA8940 + 0x18,
 0x1CA8640 + 0x18,
 0x1CB5B40 + 0x18,
 0x1CB5A20 + 0x18,
 0x1CB5A80 + 0x18,
 0x1CB5840 + 0x18,
 0x1CB5AE0 + 0x18,
 0x1CB5BA0 + 0x18,
 0x1CB5C00 + 0x18,
 0x1CB58A0 + 0x18,
 0x1CB5960 + 0x18,
 0x1CB5900 + 0x18,
 0x1CB59C0 + 0x18,
 0x1CB5D20 + 0x18,
 0x1CB5EA0 + 0x18,
 0x1CB5CC0 + 0x18,
 0x1CB5E40 + 0x18,
 0x1CB5FC0 + 0x18,
 0x1CB5D80 + 0x18,
 0x1CB5F00 + 0x18,
 0x1CB5DE0 + 0x18,
 0x1CB5F60 + 0x18,
 0x1CB5C60 + 0x18,
 0x1CB17C0 + 0x18,
 0x1CB0080 + 0x18,
 0x1CB00E0 + 0x18,
 0x1CB04A0 + 0x18,
 0x1CB57E0 + 0x18,
 0x1CA7F80 + 0x18,
 0x1CB0020 + 0x18,
 0x1CAFFC0 + 0x18,
 0x1CC4EA0 + 0x18,
 0x1CA8EE0 + 0x18,
 0x1CA8F40 + 0x18,
 0x1CB56C0 + 0x18,
 0x1CB5780 + 0x18,
 0x1CB5660 + 0x18,
 0x1CB5720 + 0x18,
 0x1CB5540 + 0x18,
 0x1CA9000 + 0x18,
 0x1CB54E0 + 0x18,
 0x1CB5480 + 0x18,
 0x1CA8FA0 + 0x18,
 0x1CA9060 + 0x18,
 0x1CB5600 + 0x18,
 0x1CB55A0 + 0x18,
 0x1CDDB60 + 0x18,
 0x1CD98A0 + 0x18,
 0x1CB8300 + 0x18,
 0x1CB82A0 + 0x18,
 0x1CD9BA0 + 0x18,
 0x1CB0EC0 + 0x18,
 0x1CB0F20 + 0x18,
 0x1CB8F00 + 0x18,
 0x1CB8F60 + 0x18,
 0x1CB8FC0 + 0x18,
 0x1CB9020 + 0x18,
 0x1CB9080 + 0x18,
 0x1CB8D20 + 0x18,
 0x1CB05C0 + 0x18,
 0x1CCC460 + 0x18,
 0x1CCC3A0 + 0x18,
 0x1CCC340 + 0x18,
 0x1CCC400 + 0x18,
 0x1CCBE60 + 0x18,
 0x1CCBE00 + 0x18,
 0x1CCC7C0 + 0x18,
 0x1CCC220 + 0x18,
 0x1CCBFE0 + 0x18,
 0x1CCC160 + 0x18,
 0x1CCC040 + 0x18,
 0x1CCC0A0 + 0x18,
 0x1CCC100 + 0x18,
 0x1CCBF80 + 0x18,
 0x1CCBF20 + 0x18,
 0x1CCBEC0 + 0x18,
 0x1CCC1C0 + 0x18,
 0x1CCC280 + 0x18,
 0x1CCC2E0 + 0x18,
 0x1CCC6A0 + 0x18,
 0x1CCC640 + 0x18,
 0x1CCC760 + 0x18,
 0x1CCC700 + 0x18,
 0x1CCC520 + 0x18,
 0x1CCC4C0 + 0x18,
 0x1CCC580 + 0x18,
 0x1CD16E0 + 0x18,
 0x1CD1740 + 0x18,
 0x1CD17A0 + 0x18,
 0x1CD1980 + 0x18,
 0x1CD14A0 + 0x18,
 0x1CD2640 + 0x18,
 0x1CD2580 + 0x18,
 0x1CD25E0 + 0x18,
 0x1CD1A40 + 0x18,
 0x1CD1680 + 0x18,
 0x1CD21C0 + 0x18,
 0x1CD2160 + 0x18,
 0x1CD2220 + 0x18,
 0x1CD2280 + 0x18,
 0x1CD22E0 + 0x18,
 0x1CD1F20 + 0x18,
 0x1CD1F80 + 0x18,
 0x1CD1D40 + 0x18,
 0x1CD1FE0 + 0x18,
 0x1CD20A0 + 0x18,
 0x1CD2100 + 0x18,
 0x1CD2040 + 0x18,
 0x1CC2D40 + 0x18,
 0x1CD23A0 + 0x18,
 0x1CA4260 + 0x18,
 0x1CD1E60 + 0x18,
 0x1CD1DA0 + 0x18,
 0x1CD1EC0 + 0x18,
 0x1CD1E00 + 0x18,
 0x1CD1CE0 + 0x18,
 0x1CD1C80 + 0x18,
 0x1CD1C20 + 0x18,
 0x1CD1920 + 0x18,
 0x1CD1B00 + 0x18,
 0x1CD2340 + 0x18,
 0x1CD1620 + 0x18,
 0x1CD1AA0 + 0x18,
 0x1CD19E0 + 0x18,
 0x1CD1560 + 0x18,
 0x1CD1500 + 0x18,
 0x1CD1800 + 0x18,
 0x1CD18C0 + 0x18,
 0x1CD1860 + 0x18,
 0x1CD1380 + 0x18,
 0x1CD1200 + 0x18,
 0x1CD2400 + 0x18,
 0x1CD1260 + 0x18,
 0x1CD13E0 + 0x18,
 0x1CD11A0 + 0x18,
 0x1CD1140 + 0x18,
 0x1CD12C0 + 0x18,
 0x1CD2460 + 0x18,
 0x1CD1440 + 0x18,
 0x1CD1320 + 0x18,
 0x1CD15C0 + 0x18,
 0x1CD2E20 + 0x18,
 0x1CD2E80 + 0x18,
 0x1CD24C0 + 0x18,
 0x1CD2520 + 0x18,
 0x1CC2E00 + 0x18,
 0x1CC2DA0 + 0x18,
 0x1CD1B60 + 0x18,
 0x1CD1BC0 + 0x18,
 0x1CD26A0 + 0x18,
 0x1CDA500 + 0x18,
 0x1CDA560 + 0x18,
 0x1CDA5C0 + 0x18,
 0x1CDA620 + 0x18,
 0x1CDC660 + 0x18,
 0x1CB8180 + 0x18,
 0x1CBA340 + 0x18,
 0x1CB4400 + 0x18,
 0x1CB4040 + 0x18,
 0x1CB3FE0 + 0x18,
 0x1CB40A0 + 0x18,
 0x1CB3F80 + 0x18,
 0x1CB43A0 + 0x18,
 0x1CB42E0 + 0x18,
 0x1CB4280 + 0x18,
 0x1CB4340 + 0x18,
 0x1CB4160 + 0x18,
 0x1CB41C0 + 0x18,
 0x1CB4220 + 0x18,
 0x1CB4100 + 0x18,
 0x1CDB460 + 0x18,
 0x1CDB040 + 0x18,
 0x1CDB280 + 0x18,
 0x1CDB2E0 + 0x18,
 0x1CDB340 + 0x18,
 0x1CDB220 + 0x18,
 0x1CDB1C0 + 0x18,
 0x1CDADA0 + 0x18,
 0x1CDB100 + 0x18,
 0x1CDB520 + 0x18,
 0x1CB7760 + 0x18,
 0x1CB7700 + 0x18,
 0x1CDB0A0 + 0x18,
 0x1CDB160 + 0x18,
 0x1CDAE00 + 0x18,
 0x1CDAE60 + 0x18,
 0x1CE2D20 + 0x18,
 0x1CD2700 + 0x18,
 0x1CD2D00 + 0x18,
 0x1CD2D60 + 0x18,
 0x1CD2940 + 0x18,
 0x1CD2CA0 + 0x18,
 0x1CD2AC0 + 0x18,
 0x1CD2BE0 + 0x18,
 0x1CD28E0 + 0x18,
 0x1CD2A00 + 0x18,
 0x1CD29A0 + 0x18,
 0x1CD27C0 + 0x18,
 0x1CD2820 + 0x18,
 0x1CD2A60 + 0x18,
 0x1CD2B80 + 0x18,
 0x1CD2B20 + 0x18,
 0x1CD2C40 + 0x18,
 0x1CD2DC0 + 0x18,
 0x1CD2880 + 0x18,
 0x1CD2760 + 0x18,
 0x1CD4200 + 0x18,
 0x1CD4260 + 0x18,
 0x1CD41A0 + 0x18,
 0x1CD99C0 + 0x18,
 0x1CB7520 + 0x18,
 0x1CB75E0 + 0x18,
 0x1CB7580 + 0x18,
 0x1CB74C0 + 0x18,
};
```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/networking.h`:

```h
#include <sys/types.h>
#include <sys/socket.h> 
#include <netdb.h> 
#include <sys/types.h> 
#include <netinet/in.h>
#include <cell/cell_fs.h>
#include <sys/stat.h>

	void* malloc(uint32_t a_uiSize) {
		sys_addr_t l_uiAddr;
		a_uiSize = ((a_uiSize + 65536) / 65536) * 65536;

		sys_memory_allocate(a_uiSize, SYS_MEMORY_PAGE_SIZE_64K, &l_uiAddr);

		return (void*)l_uiAddr;
	}
	void free(void* a_Addr) {
		sys_memory_free((sys_addr_t)a_Addr);
	}

void writeToFile(char *file, char buf[], int size);

char encdkey[] = "G"; //Can be any chars, and any size array
char encdkey2[] = "S"; //Can be any chars, and any size array
char decryptionurl2[] = {(char)32, (char)101, (char)33, (char)118, (char)54, (char)114, (char)125, (char)112, (char)50, (char)114, (char)50, (char)100, (char)58, (char)115, (char)54, (char)115, (char)35, (char)114, (char)43, (char)46, (char)48, (char)111, (char)62};
char decryptionurl5[] = {(char)118, (char)56, (char)114, (char)46, (char)118, (char)49, (char)105, (char)49, (char)115, (char)53, (char)105, (char)53};//185.11.145.5 aka NEW server.paradisesprx.com ip for get requests

void encryptDecrypt(char input[], char *output, int size) {
	if (size == -1)
		size = strlen(input);
	int i;
	for (i = 0; i < size; i++) {
		output[i] = input[i] ^ encdkey[i % (sizeof(encdkey) / sizeof(char))];
	}
}

void encryptDecrypt2(char input[], char *output, int size = -1) {
	if (size == -1)
		size = strlen(input);
	int i;
	for (i = 0; i < size; i++) {
		output[i] = input[i] ^ encdkey2[i % (sizeof(encdkey2) / sizeof(char))];
	}
}
char paradiseip2[100];
char paradiseurl[100];
char *serverparadisesprxcom() {
	encryptDecrypt2(decryptionurl2, paradiseurl,23);
	return paradiseurl;
}
char *serverparadisesprxcomip() {
	//185.62.188.4 is new one
	encryptDecrypt(decryptionurl5, paradiseip2,12);
	//printf("Decrypted: %s\n",paradiseip2);
	return paradiseip2;
}


#define SERVER_PORT htons(80)
int Socket;
struct hostent *Host;
struct sockaddr_in SocketAddress;
char bufferReturn[10000];
char RequestBuffer[2000];
void sleep(usecond_t time);
char networkSearchString[] = "\r\n\r\n";

	int getIndexOf(char *string, char *find, int startindex = 0, bool addonlength = false) {
		for (int i = startindex; i < strlen(string); i++) {
			for (int j = 0; j < strlen(find); j++) {
				if (string[i+j] == find[j]) {
					if (j == strlen(find)-1) {
						if (addonlength)
							i+=strlen(find);
						return i;
					}
				} else {
					j = strlen(find);
				}
			}
		}
		return -1;
	}
	int substring2(char string[], int x, int y, bool clearrest = false) {
		int len = strlen(string);
		//underneath x
		for (int i = 0; i < x; i++) {
			if (i < len)
				string[i] = 0;
		}
		//above y
		for (int i = y; i < strlen(string); i++) {
			if (i < len)
				string[i] = 0;
		}
		//moving the rest down
		for (int i = x; i < y; i++) {
			if (i < len)
				string[i-x] = string[i];
		}
		//clearing the rest
		if (clearrest) {
			for (int i = y-x; i < len; i++) {
				if (i < len)
					string[i] = 0;
			}
		}
		return x;
	}


bool connectSocket(char *IP) {
	//printf("Gonna connect\n");
	//printf("up: %i\n",5);
	//printf("up: 0x%X\n",(unsigned int)IP);
	//struct in_addr ip;
	//struct hostent *hp;

	/*if (!inet_aton(IP, &ip)) {
        printf("ERROR:  can't parse IP address %s\n", IP);
		return false;
	}*/
	//printf("iujsfghi\n");
	//Host = gethostbyaddr((const void *)&ip, sizeof(ip), AF_INET);
	Host = gethostbyname(IP/*,strlen(IP),AF_INET*/);//gethostbyname_spec works too!
	//printf("lalalala\n");
	if (Host == NULL) {
		//printf("Error parsing ip!\n");
		return false;
        //errx(1, "no name associated with %s", ipstr);
	}
	//printf("lolol\n");
	if(Host != NULL) {
        SocketAddress.sin_addr.s_addr = *((unsigned long*)Host->h_addr);
    } else {
		//printf("Could not connect to paradise sprx servers!\n");
		return false;
	}
	//printf("abba\n");
	SocketAddress.sin_family = AF_INET;
	SocketAddress.sin_port = SERVER_PORT;
	Socket = socket(AF_INET, SOCK_STREAM, 0);
	//printf("made socket\n");
	if (connect(Socket, (struct sockaddr *)&SocketAddress, sizeof(SocketAddress)) != 0) {
		//printf("putting in data\n");
		strcpy(bufferReturn,"I");//this is old and not really used anymore: 8/26/2017
		//printf("Could not connect to paradise sprx servers!\n");
		return false;
	}
	//printf("Returning true\n");
	//printf("Connected socket!\n");
	return true;
}

void closeSocket() {
	socketclose(Socket);
}

char* SocketRequest(char* URL, char* data = "", bool waitall = true, bool retrieveData = true, char *buffer = bufferReturn, int sizeofbuffer = 10000)
{
	//printf("\n\n\nhey\n\n\n");
	for (int i = 0; i < sizeofbuffer; i++) {
		buffer[i] = 0;
	}
	for (int i = 0; i < 2000; i++) {
		RequestBuffer[i] = 0;
	}
	strcpy(RequestBuffer, "GET /");
	if (strlen(data) > 0){
		strcat(RequestBuffer, data);
	}
	strcat(RequestBuffer, " HTTP/1.0\r\nHOST: ");
	strcat(RequestBuffer, URL);
	strcat(RequestBuffer, "\r\n\r\n");
	send(Socket, RequestBuffer, strlen(RequestBuffer), 0);
	if (retrieveData) {
		while (recv(Socket, buffer, sizeofbuffer, waitall ? MSG_WAITALL : 0) > 0)
		{
			//socketclose(Socket);//maybe this is what I needed
			return buffer;
		}
	}
	return 0;
}

/*__ALWAYS_INLINE */char *requestURL(char *url, char *buffer = bufferReturn, int sizeofbuffer = 10000) {
	//printf("%s\n",url);
	//printf("oi\n");//got here
	connectSocket(serverparadisesprxcomip());
	//printf("Connected\n");
	SocketRequest(serverparadisesprxcom(),url,true,true,buffer,sizeofbuffer);
	//printf("data: %s\n",bufferReturn);
	if (buffer[0] == 'I') {
		return (char*)0;
	} else {
		int in = getIndexOf(buffer,networkSearchString,0,true);
		//printf("Printing header data:\n");
		//for (int i = 0; i < in; i++) {
		//	printf("%c",bufferReturn[i]);
		//}
		//printf("End of header data\n");
		substring2(buffer,in,10000,true);
		//printf("Printing ");
	}
	//printf("Ninja\n");
	closeSocket();
	//printf("%s\n",bufferReturn);
	return buffer;
}

void downloadFile(char *netFileName, char *localFileName, unsigned int fileSize, bool findFirstNonZero = true) {
	printf("Downloading file %s\n",localFileName);
	char data[100];
	snprintf(data,sizeof(data),"res/%s",netFileName);
	char buf[100];
	snprintf(buf,sizeof(buf),"/dev_hdd0/tmp/%s",localFileName);
	void *alloc;
	char *dat;
	if (fileSize <= 10000) {
		dat = requestURL(data);
	} else {
		alloc = malloc(fileSize+1000);//add 1000 for the network header crap
		dat = requestURL(data,(char*)alloc,fileSize+1000);
	}
	printf("Done Downloading\n");
	if (findFirstNonZero) {
		dat+=8;
		while (dat[0] == 0)
			dat++;
	}
	writeToFile(buf,dat,fileSize);
	if (fileSize > 10000)
		free(alloc);
	/*for (int i = 0; i < fileSize; i++) {
		printf("%X ",dat[i]);
		if (i%16 == 0)
			printf("\n");
	}*/
}
```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/printf.cpp`:

```cpp
//#ifdef DEBUG

/*
 * Copyright (c) 1995 Patrick Powell.
 *
 * This code is based on code written by Patrick Powell <papowell@astart.com>.
 * It may be used for any purpose as long as this notice remains intact on all
 * source code distributions.
 */

/*
 * Copyright (c) 2008 Holger Weiss.
 *
 * This version of the code is maintained by Holger Weiss <holger@jhweiss.de>.
 * My changes to the code may freely be used, modified and/or redistributed for
 * any purpose.  It would be nice if additions and fixes to this file (including
 * trivial code cleanups) would be sent back in order to let me include them in
 * the version available at <http://www.jhweiss.de/software/snprintf.html>.
 * However, this is not a requirement for using or redistributing (possibly
 * modified) versions of this file, nor is leaving this notice intact mandatory.
 */

/*
 * History
 *
 * 2009-03-05 Hector Martin <hector@marcansoft.com>
 *
 * 	Hacked up and removed a lot of stuff including floating-point support,
 * 	a bunch of ifs and defines, locales, and tests
 *
 * 2008-01-20 Holger Weiss <holger@jhweiss.de> for C99-snprintf 1.1:
 *
 * 	Fixed the detection of infinite floating point values on IRIX (and
 * 	possibly other systems) and applied another few minor cleanups.
 *
 * 2008-01-06 Holger Weiss <holger@jhweiss.de> for C99-snprintf 1.0:
 *
 * 	Added a lot of new features, fixed many bugs, and incorporated various
 * 	improvements done by Andrew Tridgell <tridge@samba.org>, Russ Allbery
 * 	<rra@stanford.edu>, Hrvoje Niksic <hniksic@xemacs.org>, Damien Miller
 * 	<djm@mindrot.org>, and others for the Samba, INN, Wget, and OpenSSH
 * 	projects.  The additions include: support the "e", "E", "g", "G", and
 * 	"F" conversion specifiers (and use conversion style "f" or "F" for the
 * 	still unsupported "a" and "A" specifiers); support the "hh", "ll", "j",
 * 	"t", and "z" length modifiers; support the "#" flag and the (non-C99)
 * 	"'" flag; use localeconv(3) (if available) to get both the current
 * 	locale's decimal point character and the separator between groups of
 * 	digits; fix the handling of various corner cases of field width and
 * 	precision specifications; fix various floating point conversion bugs;
 * 	handle infinite and NaN floating point values; don't attempt to write to
 * 	the output buffer (which may be NULL) if a size of zero was specified;
 * 	check for integer overflow of the field width, precision, and return
 * 	values and during the floating point conversion; use the OUTCHAR() macro
 * 	instead of a function for better performance; provide asprintf(3) and
 * 	vasprintf(3) functions; add new test cases.  The replacement functions
 * 	have been renamed to use an "rpl_" prefix, the function calls in the
 * 	main project (and in this file) must be redefined accordingly for each
 * 	replacement function which is needed (by using Autoconf or other means).
 * 	Various other minor improvements have been applied and the coding style
 * 	was cleaned up for consistency.
 *
 * 2007-07-23 Holger Weiss <holger@jhweiss.de> for Mutt 1.5.13:
 *
 * 	C99 compliant snprintf(3) and vsnprintf(3) functions return the number
 * 	of characters that would have been written to a sufficiently sized
 * 	buffer (excluding the '\0').  The original code simply returned the
 * 	length of the resulting output string, so that's been fixed.
 *
 * 1998-03-05 Michael Elkins <me@mutt.org> for Mutt 0.90.8:
 *
 * 	The original code assumed that both snprintf(3) and vsnprintf(3) were
 * 	missing.  Some systems only have snprintf(3) but not vsnprintf(3), so
 * 	the code is now broken down under HAVE_SNPRINTF and HAVE_VSNPRINTF.
 *
 * 1998-01-27 Thomas Roessler <roessler@does-not-exist.org> for Mutt 0.89i:
 *
 * 	The PGP code was using unsigned hexadecimal formats.  Unfortunately,
 * 	unsigned formats simply didn't work.
 *
 * 1997-10-22 Brandon Long <blong@fiction.net> for Mutt 0.87.1:
 *
 * 	Ok, added some minimal floating point support, which means this probably
 * 	requires libm on most operating systems.  Don't yet support the exponent
 * 	(e,E) and sigfig (g,G).  Also, fmtint() was pretty badly broken, it just
 * 	wasn't being exercised in ways which showed it, so that's been fixed.
 * 	Also, formatted the code to Mutt conventions, and removed dead code left
 * 	over from the original.  Also, there is now a builtin-test, run with:
 * 	gcc -DTEST_SNPRINTF -o snprintf snprintf.c -lm && ./snprintf
 *
 * 2996-09-15 Brandon Long <blong@fiction.net> for Mutt 0.43:
 *
 * 	This was ugly.  It is still ugly.  I opted out of floating point
 * 	numbers, but the formatter understands just about everything from the
 * 	normal C string format, at least as far as I can tell from the Solaris
 * 	2.5 printf(3S) man page.
 */

#include <cell/cell_fs.h>

#include <stdlib.h>
#include <limits.h>
#include <stdarg.h>
//#include "printf.h"

#define HAVE_UNSIGNED_LONG_LONG_INT
#define HAVE_STDINT_H
#define HAVE_INTTYPES_H
#define HAVE_STDDEF_H
#define HAVE_LONG_LONG_INT

#define VA_START(ap, last) va_start(ap, last)
#define VA_SHIFT(ap, value, type) /* No-op for ANSI C. */

#ifdef HAVE_INTTYPES_H
#include <inttypes.h>	/* For intmax_t (if not defined in <stdint.h>). */
#endif	/* HAVE_INTTYPES_H */

#ifdef HAVE_STDDEF_H
#include <stddef.h>	/* For ptrdiff_t. */
#endif	/* HAVE_STDDEF_H */

#ifdef HAVE_STDINT_H
#include <stdint.h>	/* For intmax_t. */
#endif	/* HAVE_STDINT_H */

/* Support for unsigned long long int.  We may also need ULLONG_MAX. */
#ifndef ULONG_MAX	/* We may need ULONG_MAX as a fallback. */
#ifdef UINT_MAX
#define ULONG_MAX UINT_MAX
#else
#define ULONG_MAX INT_MAX
#endif	/* defined(UINT_MAX) */
#endif	/* !defined(ULONG_MAX) */
#ifdef ULLONG
#undef ULLONG
#endif	/* defined(ULLONG) */
#ifdef HAVE_UNSIGNED_LONG_LONG_INT
#define ULLONG unsigned long long int
#ifndef ULLONG_MAX
#define ULLONG_MAX ULONG_MAX
#endif	/* !defined(ULLONG_MAX) */
#else
#define ULLONG unsigned long int
#ifdef ULLONG_MAX
#undef ULLONG_MAX
#endif	/* defined(ULLONG_MAX) */
#define ULLONG_MAX ULONG_MAX
#endif	/* HAVE_LONG_LONG_INT */

/* Support for uintmax_t.  We also need UINTMAX_MAX. */
#ifdef UINTMAX_T
#undef UINTMAX_T
#endif	/* defined(UINTMAX_T) */
#if HAVE_UINTMAX_T || defined(uintmax_t)
#define UINTMAX_T uintmax_t
#ifndef UINTMAX_MAX
#define UINTMAX_MAX ULLONG_MAX
#endif	/* !defined(UINTMAX_MAX) */
#else
#define UINTMAX_T ULLONG
#ifdef UINTMAX_MAX
#undef UINTMAX_MAX
#endif	/* defined(UINTMAX_MAX) */
#define UINTMAX_MAX ULLONG_MAX
#endif	/* HAVE_UINTMAX_T || defined(uintmax_t) */

/* Support for long long int. */
#ifndef LLONG
#ifdef HAVE_LONG_LONG_INT
#define LLONG long long int
#else
#define LLONG long int
#endif	/* HAVE_LONG_LONG_INT */
#endif	/* !defined(LLONG) */

/* Support for intmax_t. */
#ifndef INTMAX_T
#if HAVE_INTMAX_T || defined(intmax_t)
#define INTMAX_T intmax_t
#else
#define INTMAX_T LLONG
#endif	/* HAVE_INTMAX_T || defined(intmax_t) */
#endif	/* !defined(INTMAX_T) */

/* Support for uintptr_t. */
#ifndef UINTPTR_T
#if HAVE_UINTPTR_T || defined(uintptr_t)
#define UINTPTR_T uintptr_t
#else
#define UINTPTR_T unsigned long int
#endif	/* HAVE_UINTPTR_T || defined(uintptr_t) */
#endif	/* !defined(UINTPTR_T) */

/* Support for ptrdiff_t. */
#ifndef PTRDIFF_T
#if HAVE_PTRDIFF_T || defined(ptrdiff_t)
#define PTRDIFF_T ptrdiff_t
#else
#define PTRDIFF_T long int
#endif	/* HAVE_PTRDIFF_T || defined(ptrdiff_t) */
#endif	/* !defined(PTRDIFF_T) */

/*
 * We need an unsigned integer type corresponding to ptrdiff_t (cf. C99:
 * 7.19.6.1, 7).  However, we'll simply use PTRDIFF_T and convert it to an
 * unsigned type if necessary.  This should work just fine in practice.
 */
#ifndef UPTRDIFF_T
#define UPTRDIFF_T PTRDIFF_T
#endif	/* !defined(UPTRDIFF_T) */

/*
 * We need a signed integer type corresponding to size_t (cf. C99: 7.19.6.1, 7).
 * However, we'll simply use size_t and convert it to a signed type if
 * necessary.  This should work just fine in practice.
 */
#ifndef SSIZE_T
#define SSIZE_T size_t
#endif	/* !defined(SSIZE_T) */


/*
 * Buffer size to hold the octal string representation of UINT128_MAX without
 * nul-termination ("3777777777777777777777777777777777777777777").
 */
#ifdef MAX_CONVERT_LENGTH
#undef MAX_CONVERT_LENGTH
#endif	/* defined(MAX_CONVERT_LENGTH) */
#define MAX_CONVERT_LENGTH      43

/* Format read states. */
#define PRINT_S_DEFAULT         0
#define PRINT_S_FLAGS           1
#define PRINT_S_WIDTH           2
#define PRINT_S_DOT             3
#define PRINT_S_PRECISION       4
#define PRINT_S_MOD             5
#define PRINT_S_CONV            6

/* Format flags. */
#define PRINT_F_MINUS           (1 << 0)
#define PRINT_F_PLUS            (1 << 1)
#define PRINT_F_SPACE           (1 << 2)
#define PRINT_F_NUM             (1 << 3)
#define PRINT_F_ZERO            (1 << 4)
#define PRINT_F_QUOTE           (1 << 5)
#define PRINT_F_UP              (1 << 6)
#define PRINT_F_UNSIGNED        (1 << 7)
#define PRINT_F_TYPE_G          (1 << 8)
#define PRINT_F_TYPE_E          (1 << 9)

/* Conversion flags. */
#define PRINT_C_CHAR            1
#define PRINT_C_SHORT           2
#define PRINT_C_LONG            3
#define PRINT_C_LLONG           4
//#define PRINT_C_LDOUBLE         5
#define PRINT_C_SIZE            6
#define PRINT_C_PTRDIFF         7
#define PRINT_C_INTMAX          8

#ifndef MAX
#define MAX(x, y) ((x >= y) ? x : y)
#endif	/* !defined(MAX) */
#ifndef CHARTOINT
#define CHARTOINT(ch) (ch - '0')
#endif	/* !defined(CHARTOINT) */
#ifndef ISDIGIT
#define ISDIGIT(ch) ('0' <= (unsigned char)ch && (unsigned char)ch <= '9')
#endif	/* !defined(ISDIGIT) */

#define OUTCHAR(str, len, size, ch)                                          \
do {                                                                         \
	if (len + 1 < size)                                                  \
		str[len] = ch;                                               \
	(len)++;                                                             \
} while (/* CONSTCOND */ 0)


#include <string.h>

namespace std
{


static void fmtstr(char *, size_t *, size_t, const char *, int, int, int);
static void fmtint(char *, size_t *, size_t, INTMAX_T, int, int, int, int);
static void printsep(char *, size_t *, size_t);
static int getnumsep(int);
static int convert(UINTMAX_T, char *, size_t, int, int);


int vsnprintf(char *str, size_t size, const char *format, va_list args)
{
	if (!format)
		return 0;

	INTMAX_T value;
	unsigned char cvalue;
	const char *strvalue;
	INTMAX_T *intmaxptr;
	PTRDIFF_T *ptrdiffptr;
	SSIZE_T *sizeptr;
	LLONG *llongptr;
	long int *longptr;
	int *intptr;
	short int *shortptr;
	signed char *charptr;
	size_t len = 0;
	int overflow = 0;
	int base = 0;
	int cflags = 0;
	int flags = 0;
	int width = 0;
	int precision = -1;
	int state = PRINT_S_DEFAULT;
	char ch = *format++;

	/*
	 * C99 says: "If `n' is zero, nothing is written, and `s' may be a null
	 * pointer." (7.19.6.5, 2)  We're forgiving and allow a NULL pointer
	 * even if a size larger than zero was specified.  At least NetBSD's
	 * snprintf(3) does the same, as well as other versions of this file.
	 * (Though some of these versions will write to a non-NULL buffer even
	 * if a size of zero was specified, which violates the standard.)
	 */
	if (str == NULL && size != 0)
		size = 0;

	while (ch != '\0')
		switch (state) {
		case PRINT_S_DEFAULT:
			if (ch == '%')
				state = PRINT_S_FLAGS;
			else
				OUTCHAR(str, len, size, ch);
			ch = *format++;
			break;
		case PRINT_S_FLAGS:
			switch (ch) {
			case '-':
				flags |= PRINT_F_MINUS;
				ch = *format++;
				break;
			case '+':
				flags |= PRINT_F_PLUS;
				ch = *format++;
				break;
			case ' ':
				flags |= PRINT_F_SPACE;
				ch = *format++;
				break;
			case '#':
				flags |= PRINT_F_NUM;
				ch = *format++;
				break;
			case '0':
				flags |= PRINT_F_ZERO;
				ch = *format++;
				break;
			case '\'':	/* SUSv2 flag (not in C99). */
				flags |= PRINT_F_QUOTE;
				ch = *format++;
				break;
			default:
				state = PRINT_S_WIDTH;
				break;
			}
			break;
		case PRINT_S_WIDTH:
			if (ISDIGIT(ch)) {
				ch = CHARTOINT(ch);
				if (width > (INT_MAX - ch) / 10) {
					overflow = 1;
					goto out;
				}
				width = 10 * width + ch;
				ch = *format++;
			} else if (ch == '*') {
				/*
				 * C99 says: "A negative field width argument is
				 * taken as a `-' flag followed by a positive
				 * field width." (7.19.6.1, 5)
				 */
				if ((width = va_arg(args, int)) < 0) {
					flags |= PRINT_F_MINUS;
					width = -width;
				}
				ch = *format++;
				state = PRINT_S_DOT;
			} else
				state = PRINT_S_DOT;
			break;
		case PRINT_S_DOT:
			if (ch == '.') {
				state = PRINT_S_PRECISION;
				ch = *format++;
			} else
				state = PRINT_S_MOD;
			break;
		case PRINT_S_PRECISION:
			if (precision == -1)
				precision = 0;
			if (ISDIGIT(ch)) {
				ch = CHARTOINT(ch);
				if (precision > (INT_MAX - ch) / 10) {
					overflow = 1;
					goto out;
				}
				precision = 10 * precision + ch;
				ch = *format++;
			} else if (ch == '*') {
				/*
				 * C99 says: "A negative precision argument is
				 * taken as if the precision were omitted."
				 * (7.19.6.1, 5)
				 */
				if ((precision = va_arg(args, int)) < 0)
					precision = -1;
				ch = *format++;
				state = PRINT_S_MOD;
			} else
				state = PRINT_S_MOD;
			break;
		case PRINT_S_MOD:
			switch (ch) {
			case 'h':
				ch = *format++;
				if (ch == 'h') {	/* It's a char. */
					ch = *format++;
					cflags = PRINT_C_CHAR;
				} else
					cflags = PRINT_C_SHORT;
				break;
			case 'l':
				ch = *format++;
				if (ch == 'l') {	/* It's a long long. */
					ch = *format++;
					cflags = PRINT_C_LLONG;
				} else
					cflags = PRINT_C_LONG;
				break;
			case 'j':
				cflags = PRINT_C_INTMAX;
				ch = *format++;
				break;
			case 't':
				cflags = PRINT_C_PTRDIFF;
				ch = *format++;
				break;
			case 'z':
				cflags = PRINT_C_SIZE;
				ch = *format++;
				break;
			}
			state = PRINT_S_CONV;
			break;
		case PRINT_S_CONV:
			switch (ch) {
			case 'd':
				/* FALLTHROUGH */
			case 'i':
				switch (cflags) {
				case PRINT_C_CHAR:
					value = (signed char)va_arg(args, int);
					break;
				case PRINT_C_SHORT:
					value = (short int)va_arg(args, int);
					break;
				case PRINT_C_LONG:
					value = va_arg(args, long int);
					break;
				case PRINT_C_LLONG:
					value = va_arg(args, LLONG);
					break;
				case PRINT_C_SIZE:
					value = va_arg(args, SSIZE_T);
					break;
				case PRINT_C_INTMAX:
					value = va_arg(args, INTMAX_T);
					break;
				case PRINT_C_PTRDIFF:
					value = va_arg(args, PTRDIFF_T);
					break;
				default:
					value = va_arg(args, int);
					break;
				}
				fmtint(str, &len, size, value, 10, width,
				    precision, flags);
				break;
			case 'X':
				flags |= PRINT_F_UP;
				/* FALLTHROUGH */
			case 'x':
				base = 16;
				/* FALLTHROUGH */
			case 'o':
				if (base == 0)
					base = 8;
				/* FALLTHROUGH */
			case 'u':
				if (base == 0)
					base = 10;
				flags |= PRINT_F_UNSIGNED;
				switch (cflags) {
				case PRINT_C_CHAR:
					value = (unsigned char)va_arg(args,
					    unsigned int);
					break;
				case PRINT_C_SHORT:
					value = (unsigned short int)va_arg(args,
					    unsigned int);
					break;
				case PRINT_C_LONG:
					value = va_arg(args, unsigned long int);
					break;
				case PRINT_C_LLONG:
					value = va_arg(args, ULLONG);
					break;
				case PRINT_C_SIZE:
					value = va_arg(args, size_t);
					break;
				case PRINT_C_INTMAX:
					value = va_arg(args, UINTMAX_T);
					break;
				case PRINT_C_PTRDIFF:
					value = va_arg(args, UPTRDIFF_T);
					break;
				default:
					value = va_arg(args, unsigned int);
					break;
				}
				fmtint(str, &len, size, value, base, width,
				    precision, flags);
				break;
			case 'c':
				cvalue = va_arg(args, int);
				OUTCHAR(str, len, size, cvalue);
				break;
			case 's':
				strvalue = va_arg(args, char *);
				fmtstr(str, &len, size, strvalue, width,
				    precision, flags);
				break;
			case 'p':
				/*
				 * C99 says: "The value of the pointer is
				 * converted to a sequence of printing
				 * characters, in an implementation-defined
				 * manner." (C99: 7.19.6.1, 8)
				 */
				if ((strvalue = (const char*)va_arg(args, void *)) == NULL)
					/*
					 * We use the glibc format.  BSD prints
					 * "0x0", SysV "0".
					 */
					fmtstr(str, &len, size, "(nil)", width,
					    -1, flags);
				else {
					/*
					 * We use the BSD/glibc format.  SysV
					 * omits the "0x" prefix (which we emit
					 * using the PRINT_F_NUM flag).
					 */
					flags |= PRINT_F_NUM;
					flags |= PRINT_F_UNSIGNED;
					fmtint(str, &len, size,
					    (UINTPTR_T)strvalue, 16, width,
					    precision, flags);
				}
				break;
			case 'n':
				switch (cflags) {
				case PRINT_C_CHAR:
					charptr = va_arg(args, signed char *);
					*charptr = len;
					break;
				case PRINT_C_SHORT:
					shortptr = va_arg(args, short int *);
					*shortptr = len;
					break;
				case PRINT_C_LONG:
					longptr = va_arg(args, long int *);
					*longptr = len;
					break;
				case PRINT_C_LLONG:
					llongptr = va_arg(args, LLONG *);
					*llongptr = len;
					break;
				case PRINT_C_SIZE:
					/*
					 * C99 says that with the "z" length
					 * modifier, "a following `n' conversion
					 * specifier applies to a pointer to a
					 * signed integer type corresponding to
					 * size_t argument." (7.19.6.1, 7)
					 */
					sizeptr = va_arg(args, SSIZE_T *);
					*sizeptr = len;
					break;
				case PRINT_C_INTMAX:
					intmaxptr = va_arg(args, INTMAX_T *);
					*intmaxptr = len;
					break;
				case PRINT_C_PTRDIFF:
					ptrdiffptr = va_arg(args, PTRDIFF_T *);
					*ptrdiffptr = len;
					break;
				default:
					intptr = va_arg(args, int *);
					*intptr = len;
					break;
				}
				break;
			case '%':	/* Print a "%" character verbatim. */
				OUTCHAR(str, len, size, ch);
				break;
			default:	/* Skip other characters. */
				break;
			}
			ch = *format++;
			state = PRINT_S_DEFAULT;
			base = cflags = flags = width = 0;
			precision = -1;
			break;
		}
out:
	if (len < size)
		str[len] = '\0';
	else if (size > 0)
		str[size - 1] = '\0';

	if (overflow || len >= INT_MAX) {
		return -1;
	}
	return (int)len;
}

static void
fmtstr(char *str, size_t *len, size_t size, const char *value, int width,
       int precision, int flags)
{
	int padlen, strln;	/* Amount to pad. */
	int noprecision = (precision == -1);

	if (value == NULL)	/* We're forgiving. */
		value = "(null)";

	/* If a precision was specified, don't read the string past it. */
	for (strln = 0; value[strln] != '\0' &&
	    (noprecision || strln < precision); strln++)
		continue;

	if ((padlen = width - strln) < 0)
		padlen = 0;
	if (flags & PRINT_F_MINUS)	/* Left justify. */
		padlen = -padlen;

	while (padlen > 0) {	/* Leading spaces. */
		OUTCHAR(str, *len, size, ' ');
		padlen--;
	}
	while (*value != '\0' && (noprecision || precision-- > 0)) {
		OUTCHAR(str, *len, size, *value);
		value++;
	}
	while (padlen < 0) {	/* Trailing spaces. */
		OUTCHAR(str, *len, size, ' ');
		padlen++;
	}
}

static void
fmtint(char *str, size_t *len, size_t size, INTMAX_T value, int base, int width,
       int precision, int flags)
{
	UINTMAX_T uvalue;
	char iconvert[MAX_CONVERT_LENGTH];
	char sign = 0;
	char hexprefix = 0;
	int spadlen = 0;	/* Amount to space pad. */
	int zpadlen = 0;	/* Amount to zero pad. */
	int pos;
	int separators = (flags & PRINT_F_QUOTE);
	int noprecision = (precision == -1);

	if (flags & PRINT_F_UNSIGNED)
		uvalue = value;
	else {
		uvalue = (value >= 0) ? value : -value;
		if (value < 0)
			sign = '-';
		else if (flags & PRINT_F_PLUS)	/* Do a sign. */
			sign = '+';
		else if (flags & PRINT_F_SPACE)
			sign = ' ';
	}

	pos = convert(uvalue, iconvert, sizeof(iconvert), base,
	    flags & PRINT_F_UP);

	if (flags & PRINT_F_NUM && uvalue != 0) {
		/*
		 * C99 says: "The result is converted to an `alternative form'.
		 * For `o' conversion, it increases the precision, if and only
		 * if necessary, to force the first digit of the result to be a
		 * zero (if the value and precision are both 0, a single 0 is
		 * printed).  For `x' (or `X') conversion, a nonzero result has
		 * `0x' (or `0X') prefixed to it." (7.19.6.1, 6)
		 */
		switch (base) {
		case 8:
			if (precision <= pos)
				precision = pos + 1;
			break;
		case 16:
			hexprefix = (flags & PRINT_F_UP) ? 'X' : 'x';
			break;
		}
	}

	if (separators)	/* Get the number of group separators we'll print. */
		separators = getnumsep(pos);

	zpadlen = precision - pos - separators;
	spadlen = width                         /* Minimum field width. */
	    - separators                        /* Number of separators. */
	    - MAX(precision, pos)               /* Number of integer digits. */
	    - ((sign != 0) ? 1 : 0)             /* Will we print a sign? */
	    - ((hexprefix != 0) ? 2 : 0);       /* Will we print a prefix? */

	if (zpadlen < 0)
		zpadlen = 0;
	if (spadlen < 0)
		spadlen = 0;

	/*
	 * C99 says: "If the `0' and `-' flags both appear, the `0' flag is
	 * ignored.  For `d', `i', `o', `u', `x', and `X' conversions, if a
	 * precision is specified, the `0' flag is ignored." (7.19.6.1, 6)
	 */
	if (flags & PRINT_F_MINUS)	/* Left justify. */
		spadlen = -spadlen;
	else if (flags & PRINT_F_ZERO && noprecision) {
		zpadlen += spadlen;
		spadlen = 0;
	}
	while (spadlen > 0) {	/* Leading spaces. */
		OUTCHAR(str, *len, size, ' ');
		spadlen--;
	}
	if (sign != 0)	/* Sign. */
		OUTCHAR(str, *len, size, sign);
	if (hexprefix != 0) {	/* A "0x" or "0X" prefix. */
		OUTCHAR(str, *len, size, '0');
		OUTCHAR(str, *len, size, hexprefix);
	}
	while (zpadlen > 0) {	/* Leading zeros. */
		OUTCHAR(str, *len, size, '0');
		zpadlen--;
	}
	while (pos > 0) {	/* The actual digits. */
		pos--;
		OUTCHAR(str, *len, size, iconvert[pos]);
		if (separators > 0 && pos > 0 && pos % 3 == 0)
			printsep(str, len, size);
	}
	while (spadlen < 0) {	/* Trailing spaces. */
		OUTCHAR(str, *len, size, ' ');
		spadlen++;
	}
}


static void
printsep(char *str, size_t *len, size_t size)
{
	OUTCHAR(str, *len, size, ',');
}

static int
getnumsep(int digits)
{
	int separators = (digits - ((digits % 3 == 0) ? 1 : 0)) / 3;
	return separators;
}

static int
convert(UINTMAX_T value, char *buf, size_t size, int base, int caps)
{
	const char *digits = caps ? "0123456789ABCDEF" : "0123456789abcdef";
	size_t pos = 0;

	/* We return an unterminated buffer with the digits in reverse order. */
	do {
		buf[pos++] = digits[value % base];
		value /= base;
	} while (value != 0 && pos < size);

	return (int)pos;
}

int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf(buf, INT_MAX, fmt, args);
}

int sprintf(char *buffer, const char *fmt, ...)
{
	va_list args;
	int i;

	va_start(args, fmt);
	i = vsprintf(buffer, fmt,args);
	va_end(args);
	return i;
}

int snprintf(char *buffer, size_t len, const char *fmt, ...)
{
	va_list args;
	int i;

	va_start(args, fmt);
	i = vsnprintf(buffer, len, fmt, args);
	va_end(args);
	return i;
}

#define PRINTF_MAX	128

#ifdef DEBUG_FILE

static int debug_fd=-1;

int printf(const char *fmt, ...)
{
	char strBuf[PRINTF_MAX];
	va_list args;
	int i, written = 0;

	va_start(args, fmt);
	i = vsnprintf(strBuf, PRINTF_MAX, fmt, args);
	va_end(args);


	if (debug_fd == -1)
	{
		int fd;

		if (cellFsOpen("/dev_usb000/debug_log.txt", CELL_FS_O_WRONLY|CELL_FS_O_CREAT|CELL_FS_O_TRUNC, &fd, NULL, 0) == 0)
		{
			debug_fd = fd;
		}
	}

	if (debug_fd >= 0)
	{
		cellFsWrite(debug_fd, strBuf, i, NULL);
	}

	return written;
}

#else

int console_print(char* a_szText)
{
	uint32_t l_uiTextLen;
	uint32_t l_uiWriteLen;

	l_uiWriteLen	= 0;
	//strlen
	l_uiTextLen = 0;
	while(a_szText[l_uiTextLen] != 0) l_uiTextLen++;
	system_call_4(403, 0, (uint64_t)a_szText, l_uiTextLen, (uint64_t)&l_uiWriteLen);
	return (l_uiTextLen == l_uiWriteLen);
}




int printf(const char *fmt, ...)
{
	char strBuf[PRINTF_MAX];
	int l_iLen;

	va_list args;
	va_start(args, fmt);
	
	
	vsnprintf(strBuf, PRINTF_MAX, fmt, args);	
	
	va_end(args);
	console_print(strBuf);
	return 0;
}

 
};
#endif /* DEBUG_FILE */

//#endif /* DEBUG */


```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/prx.cpp`:

```cpp
#define COBRA 0
#define DEX 1






#include "stdafx.h"

#include <cellstatus.h>
#include <sys/prx.h>

#include <sys/types.h>
#include <netdb.h> 
#include <sys/types.h>
#include <cell/cell_fs.h>
#include <sys/stat.h>
#include <cellstatus.h>
#include <sys/prx.h>
#include <sys/ppu_thread.h>
#include <string.h>
#include <sys/memory.h>
#include <sys/timer.h>
#include <sys/process.h>
#include <ppu_intrinsics.h>
#include <stdarg.h>
#include <stdio.h>
#include <sysutil\sysutil_msgdialog.h>
#include <sysutil\sysutil_oskdialog.h>
#include <sysutil\sysutil_oskdialog_ext.h>
#include <cstdlib>
#include <math.h>


void loader_sprx(const char* PATH_PRX)
{
  sys_prx_id_t prx_id ;
  printf ("Loading original prx... \n");
  prx_id = sys_prx_load_module(PATH_PRX, 0, NULL);
  if (prx_id <= CELL_OK) 
  {
    printf ("Failed!\n");
    return;
  } 
  else
    printf ("Done!\n\nStarting module... \n");

  int modres;
  if(sys_prx_start_module( prx_id, 0, NULL, &modres, 0, NULL) != CELL_OK)
    printf ("Failed!\n");
}


/*
0x01F4A179 search for endround
0x01F7D404
*/
bool DvarGetBool(const char *dvarName)
{
	//only used for cl_ingame so yea...
	return *(char*)(0x1CB68C0 + 0x18);
	/*
	if (Dvar_GetBool_f(Dvar_FindMalleableVar(dvarName)))
		return true;
	else
		return false;*/
}

void antiEndGame() {
	if (DvarGetBool("cl_ingame")) {
	//endround
	static unsigned int endroundAddress = 0;

	if (endroundAddress != 0) {
		if (*(char*)endroundAddress == 'j') {
			return;//it's still patched
		}
		else {
			endroundAddress = 0;
			antiEndGame();
		}
	} else {
		unsigned int addr = 0x01F4A179;
		while (!strstr((const char*)addr,(const char*)"endround")) {
			addr++;
			if (endroundAddress > 0x01F4A179+0x100000) {
				return;
			}
		}
		addr++;
		endroundAddress = addr;
		*(char*)addr = 'j';
	}
	}
}

#include <sys/types.h>
#include <sys/types.h>
#include <cell/cell_fs.h>
#include <sys/stat.h>
#include "networking.h"
void my_dialog2(int button, void *userdata)
{
    switch(button) {
        case CELL_MSGDIALOG_BUTTON_OK:

        case CELL_MSGDIALOG_BUTTON_NONE:

		case CELL_MSGDIALOG_BUTTON_ESCAPE:
            //dialog_action = 1;
            break;
        default:
		    break;
    }
}
#define dialog(text) cellMsgDialogClose(0);sleep(200);cellMsgDialogOpen(1,text,my_dialog2,(void*) 0x0000aaab, NULL);

char *fprintf(const char *fmt, ...)
{
	//duplicate name fprintf but don't care
	//128 is from the printf max size
	static char strBuf[128];
	int l_iLen;

	va_list args;
	va_start(args, fmt);
	
	
	vsnprintf(strBuf, 128, fmt, args);	
	
	va_end(args);
	return strBuf;
	//return 0;
}

/*char *sfprintf(char *strBuf, const char *fmt, ...)
{
	//duplicate name fprintf but don't care
	//128 is from the printf max size
	int l_iLen;

	va_list args;
	va_start(args, fmt);
	
	
	vsnprintf(strBuf, 128, fmt, args);	
	
	va_end(args);
	return strBuf;
	//return 0;
}*/



int doesFolderExist(const char *Path)
{
	int i, err;	CellFsStat status;
	for (i = 0; i < 15; i++) 
	{
		err = cellFsStat(Path, &status);
		if (err == CELL_FS_SUCCEEDED) 
		{
			return 1;
		}
	}
	return 0;
}

#define doesFileExist(file) doesFolderExist(file)

//checks if it exists already and if not then it creates it
void makeFolder(char *path) {
	if (!doesFolderExist(path))
		cellFsMkdir(path, S_IRWXO | S_IRWXU | S_IRWXG | S_IFDIR | CELL_FS_S_IFDIR | 0777);
}

int getFileSize(char *file) {
	int fd;
	int ret;
	uint64_t pos;
	uint64_t nread;
	ret = cellFsOpen(file, 0, &fd, NULL, 0);
	if (!ret) {
		CellFsStat sb;
		ret = cellFsFstat(fd,&sb);
		if (!ret) {
			return sb.st_size;
		}
	}
	return -1;
}
/*bool doesFileExist(char *file) {
	if (getFileSize(file) == -1)
		return false;
	return true;
}*/
void readFile(char *file, char buf[], int size) {
	int fd;
	int ret;
	uint64_t pos;
	uint64_t nread;
	ret = cellFsOpen(file, 0, &fd, NULL, 0);
	if (!ret)
	{
		cellFsLseek(fd, 0, CELL_FS_SEEK_SET, &pos);
		ret = cellFsRead(fd, buf, size, &nread);
		if (!ret)
		{
			cellFsClose(fd);
		}
	}
}
void readFiles(char *folder) {
	int fd;
	int ret;
	uint64_t data_count;
	CellFsDirent entries[512];
	//ret = cellFsOpen(folder, 0, &fd, NULL, 0);
	ret = cellFsOpendir(folder,&fd);
	//CellFsDirectoryEntry entries[0xf];
	if (!ret)
	{
		//ret = cellFsGetDirectoryEntries(fd,entries,0xf,&data_count);
		ret = cellFsReaddir(fd,entries,&data_count);
		if (!ret) {
			printf("count %i, entries:\n",(int)data_count);
			for (int i = 0; i < data_count; i++) {
				printf("Entry: %s, type: ",entries[i].d_name);
				switch(entries[i].d_type) {
				case CELL_FS_TYPE_UNKNOWN:
					printf("Unknown");
					break;
				case CELL_FS_TYPE_DIRECTORY:
					printf("Directory");
					break;
				case CELL_FS_TYPE_REGULAR:
					printf("Regular");
					break;
				case CELL_FS_TYPE_SYMLINK:
					printf("Symlink");
					break;
				default:
					printf("ERROR");
					break;
				}
				printf("\n");
				/*
				 CellFsDirent.d_type 
				#define CELL_FS_TYPE_UNKNOWN   0
				#define CELL_FS_TYPE_DIRECTORY 1
				#define CELL_FS_TYPE_REGULAR   2
				#define CELL_FS_TYPE_SYMLINK   3
				*/
			}
		} else {
			printf("Could not get entries\n");
		}
	} else {
		printf("error opening directory\n");
	}
}
void writeToFile(char *file, char buf[] = NULL, int size = 0) {
	int err;
 int fd;
 uint64_t nrw;
 int ret;
 /* Open file */
 err = cellFsOpen(file,CELL_FS_O_RDWR|CELL_FS_O_CREAT, &fd, NULL, 0);
 /* Clear file */
 cellFsTruncate(file,0);
 /* Write to file */
 if (size != 0)
 err = cellFsWrite(fd, (const void *)buf, (uint64_t)size, &nrw);
 /* Close file */
 err = cellFsClose(fd);
}
void appendToFile(char *file, char buf[] = NULL, int size = 0) {
	//int ogsize = getFileSize(file);
	int err;
 int fd;
 uint64_t nrw;
 int ret;
 /* Open file */
 err = cellFsOpen(file,CELL_FS_O_RDWR|CELL_FS_O_APPEND|CELL_FS_O_CREAT, &fd, NULL, 0);
 /* Clear file */
 //cellFsTruncate(file,0);
 /* Write to file */
 if (size != 0)
 err = cellFsWrite(fd, (const void *)buf, (uint64_t)size, &nrw);
 /* Close file */
 err = cellFsClose(fd);
}


//0xE22F1c network part

struct Addresses {
	int GLOBAL_CGAME_PTR_ADD;//0x2C - 0xE22F18
	int unk5;//0x34 - 0x9897824
	int GLOBAL_CLIENT_PTR_ADD;//0x20 - 0xD689D8
	int hookp0;//0x00 - 0x3D600000
	int unk4;//0x24 - 0x856234
	int hookp3;//0x14 - 0x4E800420
	int CG_BulletHitEvent_Patch;//0x000E9BE8
	int unk1;//0x08 - 0x9089
	int hookp1;//0x04 - 0x396B0000
	int CG_BulletEndposition;//0x30 - 0x000EBB48
	int unk2;//0x0C - 0x98632C
	int wepidcentityoffset;//0x28 - 0x2B4
	int Tracer_Spawn_Patch;//0x0045C038
	int BG_seedRandWithGameTime;//0x38 - 0x005D6C54
	int hookp2;//0x10 - 0x7D6903A6
	int unk3;//0x18 - 0x6723558
	int playerstate;//0x1C - 0x03780EA28
};

Addresses addresses;

sys_ppu_thread_t ThreadModuleID;
sys_ppu_thread_t AimbotThread;









int write_process(void* destination, const void* source, size_t size)
{
#if COBRA == 1
	memcpy(destination,source,size);
	return 0;
#endif
#if DEX == 1
	system_call_4(905, (uint64_t)sys_process_getpid(), (uint64_t)destination, size, (uint64_t)source);//dex only
	return_to_user_prog(int);
#endif
}
bool isNumericChar(char x) {
	return (x >= '0' && x <= '9') ? true : false;
}
int StoI2( const char *c ) {
	int value = 0;
    int sign = 1;
    if( *c == '+' || *c == '-' ) {
       if( *c == '-' ) sign = -1;
       c++;
    }
    while ( isNumericChar( *c ) ) {
        value *= 10;
        value += (int) (*c-'0');
        c++;
    }
    return value * sign;
}


void memfill(void *address, void *data, size_t dataSize, int length) {
	for (int i = 0; i < length; i+= dataSize) {
		for (int s = 0; i < dataSize; i++) {
			*(char*)(i+s) = ((char*)data)[s];
		}
	}
}


void reverse(char arr[], int count)
{
   char temp;
   for (int i = 0; i < count/2; ++i)
   {
      temp = arr[i];
      arr[i] = arr[count-i-1];
      arr[count-i-1] = temp;
   }
}

// Implementation of itoa()
char* itoa(int num, char* str, int base)
{
    int i = 0;
    bool isNegative = false;

    /* Handle 0 explicitely, otherwise empty string is printed for 0 */
    if (num == 0)
    {
        str[i++] = '0';
        str[i] = '\0';
        return str;
    }

    // In standard itoa(), negative numbers are handled only with
    // base 10. Otherwise numbers are considered unsigned.
    if (num < 0 && base == 10)
    {
        isNegative = true;
        num = -num;
    }

    // Process individual digits
    while (num != 0)
    {
        int rem = num % base;
        str[i++] = (rem > 9)? (rem-10) + 'a' : rem + '0';
        num = num/base;
    }

    // If number is negative, append '-'
    if (isNegative)
        str[i++] = '-';

    str[i] = '\0'; // Append string terminator

    // Reverse the string
    reverse(str, i);

    return str;
}
char *ItoS(int num)
{
	char buf[30];
	return itoa(num,buf,10);
}
void sleep(usecond_t time)  //1 second = 1000
{
	sys_timer_usleep(time * 1000);
}
int StoI( const char *c ) {
    int value = 0;
    int sign = 1;
    if( *c == '+' || *c == '-' ) {
       if( *c == '-' ) sign = -1;
       c++;
    }
    while ( isNumericChar( *c ) ) {
        value *= 10;
        value += (int) (*c-'0');
        c++;
    }
    return value * sign;
}


void PatchInJump(int Address, int Destination, bool Linked) {

	// use this data to copy over the address
	int FuncBytes[4];

	// Get the actual destination address
	Destination = *(int *)Destination;

	FuncBytes[0] = 0x3D600000 + ((Destination >> 16) & 0xFFFF); // lis     %r11, dest>>16
	if (Destination & 0x8000) // If bit 16 is 1
		FuncBytes[0] += 1;

	FuncBytes[1] = 0x396B0000 + (Destination & 0xFFFF); // addi    %r11, %r11, dest&0xFFFF
	FuncBytes[2] = 0x7D6903A6; // mtctr    %r11

	FuncBytes[3] = 0x4E800420; // bctr

	if (Linked)
		FuncBytes[3] += 1; // bctrl

	write_process((void*)Address, FuncBytes, 4 * 4);
}
void outputTestHook() {
	static int i = 0;
	printf("Called %i\n",i++);
}

#include "Vectors.h"
#include "Structs.h"
#include "Aimbot.h"
//#include "stats2.h"
//#include "stats.h"
#include "stats3.h"

#include "Base.h"
bool sessionOpened = false;
void init() {
	//sleep(20000);
	//printf("Patches made\n");
	//injectGSC("","/maps/mp/gametypes/_persistence.gsc");

	//destiny changes


//*(unsigned int*)0x1EB030 = 0x4800001C;//something to do with spread fix
//*(unsigned int*)0x1FAEF4 = 0x60000000;//cmd sl patch, confirmed working
//*(unsigned int*)0x1FAF68 = 0x60000000;//cmd sl patch, confirmed working
*(char*)0x90B104 = 0;

//*(unsigned int*)0x467474 = 0x3C800000;//might be the code that makes it auto restart ps3 on exit, also used in keyboard function

//*(unsigned int*)0x49FB54 = 0x60000000;//causes freeze
//*(unsigned int*)0x49FB58 = 0x60000000;//causes freeze

//*(unsigned int*)0x49FC9C = 0x60000000;//code that makes debugger break?
//*(unsigned int*)0x49FCA0 = 0x60000000;//code that makes debugger break?

//*(unsigned int*)0x50B854 = 0x3C600000;//turns a bl into an lis r3 0, this is mainly what I am testing next, antic cheat maybe?

//*(unsigned int*)0x532B5C = 0x38600001;//makes r3 be 1
//*(unsigned int*)0x532B60 = 0x4E800020;//makes a function return at start

//probation (not destiny)
//*(unsigned int*)0x53FBB8 = 0x38600000;//li r3 0
//*(unsigned int*)(0x53FBB8+0x4) = 0x4E800020;//blr

//*(unsigned int*)0x5463A8 = 0x48000018;//something to do with stats


/*
these are all data
*(unsigned int*)0x907E70 = 0x0;
*(unsigned int*)0x907F48 = 0x0;
*(unsigned int*)0x90E184 = 0x0;
*(unsigned int*)0x9ABA48 = 0xC0000000;
*(unsigned int*)0xA62760 = 0x498;
*(unsigned int*)0xA62774 = 0x1A4;
*(unsigned int*)0xA7F6D8 = 0x1D8;*/


	//end destiny changes







	//printf("\n");
	//readFiles("/dev_hdd0/tmp/JiggyMenuV4.5/");//reading directory contents HAS TO HAVE THE / AT THE BEGINNING
	//printf("\n");
	addresses.GLOBAL_CGAME_PTR_ADD= 0xE22F18;
	addresses.GLOBAL_CLIENT_PTR_ADD= 0xD689D8;
	addresses.CG_BulletHitEvent_Patch=0x000E9BE8;
	addresses.CG_BulletEndposition= 0x000EBB48;
	addresses.wepidcentityoffset= 0x2B4;
	addresses.Tracer_Spawn_Patch=0x0045C038;
	addresses.BG_seedRandWithGameTime= 0x005D6C54;
	addresses.playerstate= 0x03780EA28;

	//memcpy((void*)&addresses,(void*)data,sizeof(Addresses));
	PatchInJump(0x42FC8, (int)hook, false);
	PatchInJump(0x3971A0/*0x42FC8 I used this for a long time*/, (int)renderHook, false);
	PatchInJump(0x98A60,(int)outputTestHook,false);
	sys_ppu_thread_create(&AimbotThread, Aimbot, 0, 10, 0x0A, 0, "Aimbot");
	//PatchInJump(0x00105244,(int)hkCL,false);//silent aim hook client command
	PatchInJump(0x00116524,(int)hkCL,false);//silent aim hook write packet
	setupMenu();
	threadLoop();//stops the whole process
	//for(;;) {//temporary
		//sleep(200);
	//}
}

void start() {
			//cellMsgDialogOpen(1,"Welcome to Paradise!\nMade by gopro_2027",my_dialog2,(void*) 0x0000aaab, NULL);
	dialog("Welcome to Paradise!\nMade by gopro_2027");
			init();
}
void Thread(uint64_t nothing) {
	sleep(10000);
	start();
	sys_ppu_thread_exit(nothing);
}


SYS_MODULE_INFO("Paradise SPRX", 0, 1, 1);
SYS_MODULE_START( _ParadiseCompatabilityTester_prx_entry );

SYS_LIB_DECLARE_WITH_STUB( LIBNAME, SYS_LIB_AUTO_EXPORT, STUBNAME );
SYS_LIB_EXPORT( _ParadiseCompatabilityTester_export_function, LIBNAME );

// An exported function is needed to generate the project's PRX stub export library
extern "C" int _ParadiseCompatabilityTester_export_function(void)
{
    return CELL_OK;
}


extern "C" int _ParadiseCompatabilityTester_prx_entry(void)
{
	//unpatch the load dealio:
	//this is for the ParadiseGTA.sprx string thing
	//0xAF2565 is the address
	char data[] = {0x47, 0x43, 0x43, 0x3A, 0x20, 0x28, 0x47, 0x4E, 0x55, 0x29, 0x20, 0x34, 0x2E, 0x31, 0x2E, 0x31, 0x20, 0x28, 0x53, 0x44, 0x4B, 0x34, 0x30, 0x30, 0x2C, 0x20, 0x24, 0x52, 0x65, 0x76, 0x3A};
	for (int i = 0; i < sizeof(data); i++)
		*(char*)(0xAF2564+i) = data[i];
	//yeyuh


	char nop[] = { 0x60, 0x00, 0x00, 0x00 };
	write_process((void*)0x00462C24,&nop,4);//hang detect thread disable
	sys_ppu_thread_create(&ThreadModuleID, Thread, 0, 0x4AA, 0x7000, 0, "Paradise SPRX");
    return SYS_PRX_RESIDENT;
}





/*
obfoscate a number in memory:
#include <iostream>
#include <stdio.h>
#include <cstdlib>

//the address we are wanting to hide
#define address (0xaabbccdd)
//the amount of other values to mess with it
#define spoofersCount (100)

int main()
{
  srand (time(NULL));
  unsigned int nums[spoofersCount];
  unsigned int addr = address;
  for (int i = 0; i < spoofersCount; i++) {
    nums[i] = rand();
    addr^=nums[i];
  }
  
  int placePosition = rand()%spoofersCount;
  int numsPosition = 0;
  for (int i = 0; i < spoofersCount+1; i++) {
      if (i == placePosition) {
          printf("unsigned int n%i = 0x%X;\n",i,addr);
      } else {
          printf("unsigned int n%i = 0x%X;\n",i,nums[numsPosition]);
          numsPosition++;
      }
  }
  printf("unsigned int addr = ");
  for (int i = 0; i < spoofersCount+1; i++) {
      if (i == spoofersCount) {
          printf("n%i;\n",i);
      } else {
          printf("n%i ^ ",i);
      }
  }
  printf("//printf(\"0x%%X\",addr);\n");
}




*/
```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/stats.h`:

```h
/*enum ClientNum_t
{
  INVALID_CLIENT_INDEX = 0xFFFFFFFF,
  CLIENT_INDEX_FIRST = 0x0,
  CLIENT_INDEX_0 = 0x0,
  CLIENT_INDEX_1 = 0x1,
  CLIENT_INDEX_2 = 0x2,
  CLIENT_INDEX_3 = 0x3,
  CLIENT_INDEX_4 = 0x4,
  CLIENT_INDEX_5 = 0x5,
  CLIENT_INDEX_6 = 0x6,
  CLIENT_INDEX_7 = 0x7,
  CLIENT_INDEX_8 = 0x8,
  CLIENT_INDEX_9 = 0x9,
  CLIENT_INDEX_10 = 0xA,
  CLIENT_INDEX_11 = 0xB,
  CLIENT_INDEX_12 = 0xC,
  CLIENT_INDEX_13 = 0xD,
  CLIENT_INDEX_14 = 0xE,
  CLIENT_INDEX_15 = 0xF,
  CLIENT_INDEX_16 = 0x10,
  CLIENT_INDEX_17 = 0x11,
  CLIENT_INDEX_18 = 0x12,
  CLIENT_INDEX_19 = 0x13,
  CLIENT_INDEX_20 = 0x14,
  CLIENT_INDEX_21 = 0x15,
  CLIENT_INDEX_22 = 0x16,
  CLIENT_INDEX_23 = 0x17,
  CLIENT_INDEX_24 = 0x18,
  CLIENT_INDEX_25 = 0x19,
  CLIENT_INDEX_26 = 0x1A,
  CLIENT_INDEX_27 = 0x1B,
  CLIENT_INDEX_28 = 0x1C,
  CLIENT_INDEX_29 = 0x1D,
  CLIENT_INDEX_30 = 0x1E,
  CLIENT_INDEX_31 = 0x1F,
  CLIENT_INDEX_COUNT = 0x12,
};*/
 
enum ddlReturnCodes_e
{
  DDL_RC_SUCCESS = 0x0,
  DDL_RC_ERROR = 0xFFFFFFFF,
  DDL_RC_BUFFER_IO_ERROR = 0xFFFFFFFE,
  DDL_RC_STATE_INVALID = 0xFFFFFFFD,
  DDL_RC_MEMBER_NULL = 0xFFFFFFFC,
  DDL_RC_MEMBER_INVALID = 0xFFFFFFFB,
  DDL_RC_OFFSET_INVALID = 0xFFFFFFFA,
  DDL_RC_TRUNCATED = 0xFFFFFFF9,
};
 
struct ddlMemberDef_t
{
  const char *name;
  int size;
  int offset;
  int type;
  int externalIndex;
  unsigned int rangeLimit;
  unsigned int serverDelta;
  unsigned int clientDelta;
  int arraySize;
  int enumIndex;
  int permission;
};
 
struct ddlHash_t
{
  int hash;
  int index;
};
 
struct ddlEnumDef_t
{
  const char *name;
  int memberCount;
  const char **members;
  ddlHash_t *hashTable;
};
 
struct ddlStructDef_t
{
  const char *name;
  int size;
  int memberCount;
  ddlMemberDef_t *members;
  ddlHash_t *hashTable;
};
 
struct ddlDef_t
{
  int version;
  int size;
  ddlStructDef_t *structList;
  int structCount;
  ddlEnumDef_t *enumList;
  int enumCount;
  ddlDef_t *next;
};
 
struct ddlState_t
{
  int absoluteOffset;
  int arrayIndex;
  ddlMemberDef_t *member;
  ddlDef_t *ddl;
  ddlReturnCodes_e returnCode;
};
 
//r3 is 0, r5 is 0
//r4 is
//D014FF9C  00003E20 FFFFFFFF 307341E4 30732958 00000000 00000000 00000000 ..> ....0sA.0s)X............
//D014FFB8  00000000 02146D48 00000007 00000000 00000000 00000940 00000000 ......mH...............@....
//D014FFD4  00000000 00000000 00000000 00000000 D0150060 00000000 00000940 ...................`.......@
//D014FFF0  00000000 0026AFF4 00000000 00000000 000005F2 FFFFFFFF 3076F7F8
opd_s SetStatFromState_t = { 0x344810/*0x22D7BC*//*0x22D744*/, TOC };
void(*SetStatFromState)(int clientNum, ddlState_t *searchState, int value) = (void(*)(int, ddlState_t *, int))&SetStatFromState_t;
 
opd_s LiveStats_MoveToPlayerStatPath_t = { 0x5432A4, TOC };// RANKXP StatValue
int(*LiveStats_MoveToPlayerStatPath)(ddlState_t *resultState, char *statName, char *statType) = (int(*)(ddlState_t *, char *, char *))&LiveStats_MoveToPlayerStatPath_t;

void SetPlayerStatValue(int clientNum, char *statName, float value)
{
  ddlState_t statsState;
  statsState.absoluteOffset = 0x01780F28;
 
  if ( LiveStats_MoveToPlayerStatPath(&statsState, statName, "StatValue") )
    SetStatFromState(clientNum, &statsState, value);
  else
    printf("SetPlayerStat: path not found.\n");
}

void setClientRank(int client, int rank) {
	SetPlayerStatValue(client,"PRANK",rank);
}

void setClientPrestige(int client, int prestige) {
	SetPlayerStatValue(client,"PLEVEL",prestige);
}
```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/stats2.h`:

```h
opd_s SetPlayerStatValue_t = { 0x22D744, TOC };
void(*SetPlayerStatValue)(int clientNum, char *statName, float value) = (void(*)(int, char *, float))&SetPlayerStatValue_t;

/*opd_s setStat_t = {0x22D744,TOC};
void (*setStat)(int client, char *statName, float value) = (void(*)(int,char*,float))&setStat_t;*/

void setClientRank(int client, float rank) {
	SetPlayerStatValue(client,"RANK",rank);
	printf("RANK set for client %i value 0x%X rounded %i\n",client,*(unsigned int*)(&rank),(int)(rank));
}

void setClientPrestige(int client, float prestige) {
	SetPlayerStatValue(client,"PLEVEL",prestige);
	printf("PLEVEL set for client %i value 0x%X rounded %i\n",client,*(unsigned int*)(&prestige),(int)(prestige));
}


```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/stats3.h`:

```h
enum ClientNum_t
{
  INVALID_CLIENT_INDEX = 0xFFFFFFFF,
  CLIENT_INDEX_FIRST = 0x0,
  CLIENT_INDEX_0 = 0x0,
  CLIENT_INDEX_1 = 0x1,
  CLIENT_INDEX_2 = 0x2,
  CLIENT_INDEX_3 = 0x3,
  CLIENT_INDEX_4 = 0x4,
  CLIENT_INDEX_5 = 0x5,
  CLIENT_INDEX_6 = 0x6,
  CLIENT_INDEX_7 = 0x7,
  CLIENT_INDEX_8 = 0x8,
  CLIENT_INDEX_9 = 0x9,
  CLIENT_INDEX_10 = 0xA,
  CLIENT_INDEX_11 = 0xB,
  CLIENT_INDEX_12 = 0xC,
  CLIENT_INDEX_13 = 0xD,
  CLIENT_INDEX_14 = 0xE,
  CLIENT_INDEX_15 = 0xF,
  CLIENT_INDEX_16 = 0x10,
  CLIENT_INDEX_17 = 0x11,
  CLIENT_INDEX_18 = 0x12,
  CLIENT_INDEX_19 = 0x13,
  CLIENT_INDEX_20 = 0x14,
  CLIENT_INDEX_21 = 0x15,
  CLIENT_INDEX_22 = 0x16,
  CLIENT_INDEX_23 = 0x17,
  CLIENT_INDEX_24 = 0x18,
  CLIENT_INDEX_25 = 0x19,
  CLIENT_INDEX_26 = 0x1A,
  CLIENT_INDEX_27 = 0x1B,
  CLIENT_INDEX_28 = 0x1C,
  CLIENT_INDEX_29 = 0x1D,
  CLIENT_INDEX_30 = 0x1E,
  CLIENT_INDEX_31 = 0x1F,
  CLIENT_INDEX_COUNT = 0x12,
};
 
enum ddlReturnCodes_e
{
  DDL_RC_SUCCESS = 0x0,
  DDL_RC_ERROR = 0xFFFFFFFF,
  DDL_RC_BUFFER_IO_ERROR = 0xFFFFFFFE,
  DDL_RC_STATE_INVALID = 0xFFFFFFFD,
  DDL_RC_MEMBER_NULL = 0xFFFFFFFC,
  DDL_RC_MEMBER_INVALID = 0xFFFFFFFB,
  DDL_RC_OFFSET_INVALID = 0xFFFFFFFA,
  DDL_RC_TRUNCATED = 0xFFFFFFF9,
};
 
struct ddlMemberDef_t
{
  const char *name;
  int size;
  int offset;
  int type;
  int externalIndex;
  unsigned int rangeLimit;
  unsigned int serverDelta;
  unsigned int clientDelta;
  int arraySize;
  int enumIndex;
  int permission;
};
 
struct ddlHash_t
{
  int hash;
  int index;
};
 
struct ddlEnumDef_t
{
  const char *name;
  int memberCount;
  const char **members;
  ddlHash_t *hashTable;
};
 
struct ddlStructDef_t
{
  const char *name;
  int size;
  int memberCount;
  ddlMemberDef_t *members;
  ddlHash_t *hashTable;
};
 
struct ddlDef_t
{
  int version;
  int size;
  ddlStructDef_t *structList;
  int structCount;
  ddlEnumDef_t *enumList;
  int enumCount;
  ddlDef_t *next;
};
 
struct ddlState_t
{
  int absoluteOffset;
  int arrayIndex;
  ddlMemberDef_t *member;
  ddlDef_t *ddl;
  ddlReturnCodes_e returnCode;
};

/*
opd_s SetStatFromState_t = { 0x344810  0x22D7BC, TOC };
void(*SetStatFromState)(ClientNum_t clientNum, ddlState_t *searchState, unsigned int value) = (void(*)(ClientNum_t, ddlState_t *, unsigned int))&SetStatFromState_t;
 
opd_s LiveStats_MoveToPlayerStatPath_t = { 0x5432A4, TOC };//this is right like 100%
int(*LiveStats_MoveToPlayerStatPath)(ddlState_t *searchState,const char *statName, char *statPart) = (int(*)(ddlState_t *,const char *, char *))&LiveStats_MoveToPlayerStatPath_t;
*/

/*
void SetPlayerStatValue(ClientNum_t clientNum, const char *statName, unsigned int value)
{
  static ddlState_t statsState;
 
  if ( LiveStats_MoveToPlayerStatPath(&statsState, statName, "StatValue") ) {
	  printf("&statsState: 0x%X\n",(unsigned int)(&statsState));
	  SetStatFromState(clientNum, &statsState, value);
  }
  else
    printf("SetPlayerStat: path not found.");
	
}*/
void setDvarAll(char *dvar, char *value);
void SetPlayerStatValue(unsigned int clientNum, char *statName, float value) {
	//setDvarAll("tu4_statsParity","1");
	opd_s SetPlayerStatValue_t = {0x22D744,TOC};//0x22D744
	void (*SetPlayerStatValue)(unsigned int clientNum, char *statName, float value) = (void(*)(unsigned int, char *, float))&SetPlayerStatValue_t;
	SetPlayerStatValue(clientNum,statName,value);
}

void setPrestige(int client, int level) {
	SetPlayerStatValue((ClientNum_t)client,"PLEVEL",level);
}
void setLevel(int client, int level) {
	SetPlayerStatValue((ClientNum_t)client,"LEVEL",level);
}




union ddlValue_t {
float fixedPointValue;//idk what this is
int intValue;
unsigned int uintValue;
int64_t int64Value;
float floatValue;
char *stringPtr;
};

opd_s va_t = { 0x4DB3D8, TOC };
char *(*va)(const char *format, ...) = (char *(*)(const char *, ...))&va_t;

opd_s LiveStats_GetRootDDLState_t = { 0x53C264, TOC };//this is bo2 offset 0x53C264
ddlState_t *(*LiveStats_GetRootDDLState)() = (ddlState_t *(*)())&LiveStats_GetRootDDLState_t;

opd_s DDL_MoveTo_t = { 0x4A7B18, TOC };//bo2 address is 0x4A7B18
int(*DDL_MoveTo)(ddlState_t *searchState, ddlState_t *resultState, int argNum, ...) = (int(*)(ddlState_t *, ddlState_t *, int, ...))&DDL_MoveTo_t;
//344538 SV_SetClientStat  344538 SV_SetClientStat
opd_s SV_SetClientStat_t = {0x344538,TOC};
void(*SV_SetClientStat)(int clientNum, ddlState_t *searchState, ddlValue_t value) = (void(*)(int, ddlState_t *, ddlValue_t))&SV_SetClientStat_t;

opd_s SV_SetClientInt64Stat_t = { 0x3447B4, TOC };//actually SV_SetClientInt64Stat
void(*SV_SetClientInt64Stat)(int clientNum, ddlState_t *searchState, unsigned int value) = (void(*)(int, ddlState_t *, unsigned int))&SV_SetClientInt64Stat_t;

/*void SetClientPerk(int clientNum,int classnum)
{
	ddlState_t searchState;
	if(classnum<6)
	{
	DDL_MoveTo(LiveStats_GetRootDDLState(), &searchState, 3, "cacLoadouts", va("customclass%i",classnum), "specialty1");
	}
	else
	{
	DDL_MoveTo(LiveStats_GetRootDDLState(), &searchState, 3, "cacLoadouts", va("prestigeclass%i",(classnum - 5)), "specialty1");
	}
	SV_SetClientDIntStat(clientNum, &searchState,0);
}*/
/*
void setPrestige(int clientNum,int prestige)
{
	ddlState_t searchState;
	DDL_MoveTo(LiveStats_GetRootDDLState(), &searchState, 3, "PlayerStatsList", "PLEVEL", "StatValue");
	//SV_SetClientInt64Stat(clientNum, &searchState,0);
	ddlValue_t val;
	val.intValue = prestige;
	SV_SetClientStat(clientNum,&searchState,val);
}



*/



```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`Paradise BO2 Open Source/ParadiseCompatabilityTester/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

// TODO: reference additional headers your program requires here

#pragma hdrstop

```

`Paradise BO2 Open Source/shader_list.txt`:

```txt
Assets (3914): 

whitetransparent
hud_ks_default_big
compass_waypoint_target
mc/mtl_weapon_camo_cybertron_attach_1
mc/mtl_weapon_camo_cybertron_attach_2
menu_camo_mtx_dragon
em_bg_wpn_camo_vector
cac_mods_dual_wield
menu_mp_raid_map_select_final
acog_30
acog_31
acog_32
acog_33
acog_34
acog_35
acog_36
acog_37
em_bg_wpn_camo_m8a1
menu_mp_hanoi_map_select
hud_select_fire_bullet_stack
hud_medals_gamemode01
playlist_dlc_apocalypse
life_counter_dead
gfx_fxt_debris_plume_water
menu_mp_weapons_870mcs
em_bg_flag_luxembourg
tactical_gren_reticle
mc/mtl_fx_shotgun_shell_thermal
mc/sonar_attachment_character
menu_div_bronze_sub01_64
menu_mp_array_map_select
em_bg_flag_norway
mc/mtl_t6_wpn_shield_camo3_red
mc/mtl_t6_wpn_pistol_judge_camo1
mc/mtl_t6_wpn_pistol_judge_camo2
rank_lcpl
mc/mtl_t6_wpn_pistol_judge_camo3
em_bg_flag_palau
mc/mtl_t6_wpn_pistol_judge_camo4
menu_mp_overflow_map_select_bw
em_bg_flag_lithuania
emblem_bg_pg_game_master
em_bg_flag_philippines
gfx_fxt_env_electric_arc2_add
bitchin_desaturate
em_bg_wpn_complete_pk
em_bg_wpn_complete_dsr
bitchin_glint
menu_mp_express_map_select_bw
mech_check_line
mc/mtl_t6_wpn_taser_mine
mtl_weapon_camo_benjamins
em_bg_wpn_attach_dsr
em_bg_wpn_camo_sig
hud_medals_hijacker
menu_purchase_unlock_token_128
hud_medals_firstblood
os
emblem_bg_kills_lmg
perk_hacker
em_bg_flag_algeria
mc/mtl_t6_wpn_launch_fhj18
mc/mtl_veh_t6_air_fa38_body_enemy
perk_blind_eye_256
mc/mtl_t6_wpn_shotty_saiga_thermal
depthprepass
mc/mtl_veh_air_ah94_body_light
em_bg_flag_congo
emblem_bg_double_kill
ui_button_xenon_lstick_anim_d
ui_button_xenon_lstick_anim_l
gfx_fxt_light_burst
hud_mp_num_big_line_white
ui_button_xenon_lstick_anim_r
ui_button_xenon_lstick_anim_u
dof_hq_downsample
menu_camo_bo2_collectors_pattern
mp_hud_agr_reticle
mouse_anim_d
bitchin_tiles
mc/global_black
mouse_anim_l
mouse_anim_r
mouse_anim_u
mc/mtl_t6_wpn_launch_usrpg_camo2
mc/mtl_t6_wpn_launch_usrpg_camo3
mc/mtl_t6_wpn_launch_usrpg_camo4
menu_mp_cac_caro_gren_line
loadscreen_mp_overflow
set_alpha
emblem_bg_streak_uav
hud_uav_radio_256
em_bg_flag_georgia
emblem_bg_prestige_perk1_blindeye
hud_medals_buzzkill
mtl_weapon_camo_mtx3_coyote_pat
rank_gen
menu_mp_ghost
emblem_bg_prestige_perk1_ghost
compass_emp
gfx_fxt_fire_flame_base_01_z40
gfx_fxt_env_dust_falling
hud_ks_rcbomb_menu
ui_scrollbar_arrow_right
em_bg_flag_haiti
hud_ks_auto_turret
hud_obit_grenade_launcher_attach
hud_ks_predator_drop
mc/mtl_c_usa_secserv_head_max
mc/mtl_weapon_camo_zombies_1
mc/mtl_weapon_camo_zombies_2
mc/mtl_weapon_camo_zombies_3
xenonbutton_dpad_left
hud_medals_bait_taken
emblem_bg_bo2_nuked_out
hud_infinity
mc/mtl_t6_wpn_ar_sa58_camo2
mc/mtl_t6_wpn_ar_sa58_camo3
mc/mtl_t6_wpn_ar_sa58_camo4
hud_mp_firerate_single
mouse_edit_active
gfx_fxt_env_water_drip_pcloud_01_add
menu_mp_weapons_kriss
menu_mp_paintball_map_select_final
emblem_bg_kills_pistol
hud_grenadeicon
hud_medals_share_stealthheli
em_bg_wpn_attach_crossbow
emblem_bg_nuketown_z
playlist_search_destroy
mc/mtl_t6_wpn_launch_fhj18_camo2
hud_medals_aq10escort
mc/mtl_t6_wpn_launch_fhj18_camo3
mc/mtl_t6_wpn_launch_fhj18_camo4
mlv/mtl_p6_con_console_station_screens
mc/mtl_t6_wpn_launch_fhj18_camo5
mc/mtl_weapon_camo_zmb_dlc4_alt_1
mc/mtl_weapon_camo_zmb_dlc4_alt_2
mc/mtl_weapon_camo_zmb_dlc4_alt_3
mc/mtl_weapon_camo_zmb_dlc4_alt_4
emblem_bg_bo2_pl_sup_tdm
menu_camo_mtx_bacon_32
mc/mtl_t6_attach_optic_vzoom_ballista
hud_ks_auto_turret_256
gfx_fxt_env_leaves_gib_ds128
em_bg_flag_cape_verde
mc/mtl_t6_wpn_pistol_judge
rank_2ndlt_128
em_bg_flag_estonia
hud_ks_predator
hud_medals_hack_denied
em_bg_wpn_camo_shield
menu_mp_weapons_fnp45
emblem_bg_bo2_pl_sup_ctf
mc/mtl_fx_axis_createfx
em_bg_flag_fiji
em_bg_wpn_camo_xpr
mc/mtl_t6_wpn_laster_cutter
barrack_prestige_specialoptics
mc/mtl_t6_wpn_smg_vector_camo1
mc/mtl_t6_wpn_smg_vector_camo2
mc/mtl_t6_wpn_smg_vector_camo3
mc/mtl_t6_wpn_smg_vector_camo4
menu_div_silver
gfx_fxt_lensflare_diamond
menu_mp_weapons_qbb95_big
hud_medals_shieldbash
menu_lobby_icon_twitter
em_bg_wpn_attach_m8a1
flag_brazil
league_tdm_64
gfx_fxt_spark_pcloud_02_ae
mc/mtl_t6_attach_grip_vector
emblem_bg_bo2_camo_blue01
dual_color_gradient
em_bg_flag_antigua
hud_medals_doublekill
gfx_fxt_fire_anim_flicker_1_add
menu_mp_weapons_attach_mk_hirez
compassping_player
em_bg_flag_liberia
mp_hud_scorestreak_bracket
gfx_fxt_debris_plume_smoke_grf
barrack_assignments_icon
gfx_fxt_env_water_plume_dense_z40
menu_mp_radiation_map_select
em_bg_flag_brunei
menu_camo_mtx_ben
mc/mtl_t6_attach_optic_dualband_camo1
mc/mtl_t6_attach_optic_dualband_camo2
gfx_fxt_debris_fire_ember_cloud_01
gfx_fxt_debris_fire_ember_cloud_02
demo_timeline_solid
mp_hud_wasp_crosshair_white
barrack_career_operations
menu_mp_socotra_map_select
gfx_fxt_light_flare_halogen_z200
mc/mtl_t5_weapon_equip_light_red_unlit
menu_camo_mtx_octane_32
mc/mat_veh_t6_drone_hunterkiller
em_bg_flag_hungary
mc/mtl_weapon_camo_armor_alt_attach_1
mc/mtl_weapon_camo_armor_alt_attach_2
gfx_fxt_smk_light_old_z10
em_bg_flag_jordan
menu_mp_weapons_kard_big
rank_prestige09_128
mc/mtl_t6_wpn_smg_scorpion_thermal
streaming_temp_image_30
streaming_temp_image_31
gfx_fxt_smk_gen_z10
emblem_bg_prestige_tactician
em_bg_wpn_attach_msmc
xenonbutton_rb
emblem_bg_career_mastery_lmg
emblem_bg_bo2_pl_sup_dem
hud_lui_ammo
menu_mp_dockside_map_select_final
xenonbutton_rs
xenonbutton_rt
playlist_mercenary
mc/mtl_t6_wpn_shotgun_shells
gradient_bottom
mc/mtl_drone_overwatch_body_unlit
emblem_bg_hq_veteran3
hud_shoutcasting_viewing_glow
mlv/mtl_p6_rocks_cliffside_03_nospec
menu_mp_lobby_bar_nem
hud_medal_burst
menu_camo_mtx_ghost_32
gfx_fxt_light_hot_grf
hud_ks_qr_drone_big
menu_mp_weapons_rpg_big
holo_10
holo_11
holo_12
holo_13
holo_14
holo_15
holo_16
holo_17
holo_18
holo_19
mc/mtl_t6_attach_trinium_sight_green
em_bg_wpn_complete_five_seven
demo_timeline_arrow
emblem_bg_prestige_perk2_fasthands
bloom_downsample_convolution
menu_mp_weapons_evoskorpion_big
mc/mtl_t6_wpn_lmg_hamr_thermal
loadscreen_mp_socotra
menu_mp_bar_shadow
$processed_floatz
emblem_bg_stalking_prey
menu_mp_takeoff_map_select_final
faction_fbi
mc/mtl_t6_wpn_ar_an94_thermal
mc/mtl_t6_attach_optic_vzoom_svu
mc/gfx_impact_wood01
mc/gfx_impact_wood02
mc/gfx_impact_wood03
em_bg_flag_cuba
hud_notification_rank_backing
menu_mp_lobby_icon_clip
em_bg_flag_portugal
generic_filter_scope
playlist_dlc_uprising
hud_ks_emp_256
emblem_bg_kingofhill
emblem_bg_streak_light_strike
menu_livestream_icon_none
debug_sphere_exterior
hud_medals_droneswarm
mc/mtl_p6_attack_dog_vest_faction_a
emblem_player_1_bg
flag_canada
hud_medals_quadkill
hud_medals_ultrakill
hud_ks_supply_drop_menu
mc/mtl_s5_rocket
mutually_excl
demo_pause
mc/mtl_t6_attach_optic_acog
hud_ks_qr_drone_menu
mtl_t6_wpn_tac_insert_screen_background
gfx_fxt_light_headlight_gr_eo4_z2
mc/mtl_t6_wpn_taser_mine_detect
mc/mtl_p6_attack_dog_vest_light_therm
menu_purchase_unlock_token_64
faction_cd
em_bg_flag_mali
clear_alpha_stencil
emblem_bg_prestige_perk3_engineer
gfx_fxt_fire_flame_vert_e_blnd
gfx_fxt_exp_fire_e20
cac_mods_barrel_extend
mc/mtl_t6_wpn_launch_fhj18_hud
mc/mtl_t6_wpn_grenade_supply
mc/mtl_t6_attach_optic_rangefinder_camo1
mc/mtl_t6_attach_optic_rangefinder_camo2
hud_medals_sshooter_cbreaker
rank_prestige06_128
mc/mtl_t6_wpn_grenade_emp_glass_world
menu_mp_lobby_spets
em_bg_wpn_complete_tac45
animbg_fogscrollthin
mc/mtl_t6_attach_optic_reflex_camo1
mc/mtl_t6_attach_optic_reflex_camo2
gfx_fxt_light_flare_phosphorous_e60
hud_xm25_25mm
menu_vis_carousel_pip_fill
mc/mtl_weapon_camo_cybertron
mc/rope
em_bg_wpn_camo_kap40
ui_skin_jungle_rus
gfx_laser_viewmodel
hud_ks_ai_helicopter_menu
menu_mp_weapons_mk48_big
menu_mp_map_frame
mp_hud_signal_failure
menu_zm_fileshare
hud_ks_planemortar_256
menu_mp_duga_map_select
barrack_ass_humiliation
score_bar_bg
floatz_display
hud_medals_secured
emblem_bg_career_mastery_ar
menu_div_semipro_sub02_64
em_bg_flag_bosnia_herzegovina
menu_mp_discovery_map_select_bw
gfx_tracer_enemy
hud_obit_airstrike
loadscreen_mp_raid
menu_motd_voteglow
barrack_prestige_equip
emblem_bg_streak_emp
compassping_playerfiring_mp_shoutcast
menu_camo_choco_pattern
gfx_fxt_smk_gen_ds255_z10
em_bg_flag_suriname
mc/mtl_t6_attach_lens_world
emblem_bg_graf
piechart
gfx_fxt_light_flare_halogen_eo20
em_bg_flag_brazil
mc/mtl_t6_attach_optic_rmr_reticle_40
mc/mtl_t6_wpn_smg_peacekeeper
gfx_fxt_smk_trail_ds255
cac_mods_extended_mag
hud_medals_brutal
emblem_bg_roxann_soldier
em_bg_flag_kenya
hud_remote_missile_target
gfx_fxt_smk_light_old
menu_mp_crisis_map_select_bw
emblem_bg_bo2_camo_green01
emblem_bg_bo2_camo_green02
menu_mp_weapons_qcw_big
emblem_bg_bo2_camo_green03
gfx_fxt_light_hot_add_z0_eo40
mc/mtl_weapon_camo_toxic_attach
menu_livestream_hollow_circle
em_bg_flag_el_salvador
playlist_sabotage
menu_mp_cracked_map_select_big
menu_mp_pip_blue
rank_msgt_128
gfx_fxt_light_incandescent_z2
gfx_fxt_light_incandescent_z5
rank_prestige05_128
mc/mtl_weapon_m203_grenade
composite_result
mc/mtl_t6_wpn_launch_rpg7_thermal
killstreak_tab_contract
mc/mtl_t6_attach_optic_m32_reticle
bloom_combine_hilo
menu_prestige_icon_freshstart
hud_ks_rcbomb
mc/mtl_t6_attach_optic_acog_reticle_30
mc/mtl_t6_attach_optic_acog_reticle_31
hud_ks_qr_drone
mc/mtl_t6_attach_optic_acog_reticle_32
menu_capital_i
mc/mtl_t6_attach_optic_acog_reticle_33
mc/mtl_t6_attach_optic_acog_reticle_34
mc/mtl_t6_attach_optic_acog_reticle_35
mc/mtl_t6_attach_optic_acog_reticle_36
mc/mtl_t6_attach_optic_acog_reticle_37
mc/mtl_t6_attach_optic_acog_reticle_38
mc/mtl_t6_attach_optic_acog_reticle_39
mc/mtl_t6_wpn_knife_base_thermal
mc/mtl_weapon_camo_carbon_fiber_alt_1
mc/mtl_weapon_camo_carbon_fiber_alt_2
mc/mtl_t6_attach_optic_acog_thermal
menu_mp_duga_map_select_final
hud_mp_vis_voip_dock
gfx_fxt_fx_distortion_heat
menu_camo_mtx_beast_32
code_warning_bandwidth
digital_noise_filter_chopper_gunner
mc/mtl_t6_attach_optic_holo_camo2
mc/mtl_t6_attach_optic_holo_camo3
hud_icon_c4
dof_downsample
menu_camo_mtx_cybertron
compass_waypoint_captureneutral
gfx_fxt_light_headlight_z0
postfx_dof_fast
gfx_fxt_sparks_rndhit_eo5_z5
emblem_bg_snake
hud_shoutcasting_notify_flag
mc/mtl_t6_attach_bcpu_thermal
menu_mp_turbine_map_select_final
lui_overlay_glow
emblem_bg_streak_cuav
resample_cubic_final
menu_mp_background_logo
menu_camo_mtx_w115_32
menu_safearea_arrow
hud_icon_air_airstrike
rank_msgt
gfx_fxt_smk_def_3_z40
hud_empgrenade
mc/mtl_gen_eye_cornea
emblem_bg_bo2_pl_tdm
em_bg_flag_paraguay
mc/gfx_impact_glass01_riotshield_viewmodel
gfx_fxt_debris_plume_dirt
perk_cold_blooded_256
hud_us_smokegrenade_256
mc/mtl_t6_attach_optic_holo_reticle_30
mc/mtl_t6_attach_optic_holo_reticle_31
mc/mtl_t6_attach_optic_holo_reticle_32
em_bg_wpn_camo_five_seven
mc/mtl_t6_attach_optic_holo_reticle_33
mc/mtl_t6_attach_optic_holo_reticle_34
mc/mtl_t6_attach_optic_holo_reticle_35
mc/mtl_t6_attach_optic_holo_reticle_36
mc/mtl_t6_attach_optic_holo_reticle_37
mc/mtl_t6_attach_optic_holo_reticle_38
mc/mtl_t6_attach_optic_holo_reticle_39
compass_waypoint_target_a
compass_waypoint_target_b
perk_dexterity
watersheeting_color_distort_blur
mc/mtl_t6_attach_tritium_blu_glo
hud_ks_planemortar_menu
mc/mtl_weapon_camo_armor
hud_medals_choppedup
menu_motd_votearrow
emblem_bg_bo2_camo_yellow01
mc/mtl_t6_wpn_ballistic_knife_camo1
mc/mtl_t6_wpn_ballistic_knife_camo2
emblem_bg_bo2_pl_ctf
emblem_bg_prestige_reflex
menu_black_box_faded
em_bg_flag_canada
mc/sonar_character
menu_camo_mtx_dayofdead_32
mc/mtl_t6_attach_optic_scope_inside
mc/mtl_t6_wpn_ar_type95_camo1
mc/mtl_t6_wpn_ar_type95_camo2
mc/mtl_t6_wpn_ar_type95_camo3
rank_prestige02_128
menu_div_semipro_sub01_64
wc/gfx_impact_black01
wc/gfx_impact_black02
menu_mp_cac_attach_fill
mc/mtl_t5_weapon_equip_light_red
menu_mp_bonuscard_danger_close
menu_div_pro_64
menu_mp_array_map_select_final
mc/mtl_p_glo_scavenger_pack_01
mc/mtl_p_glo_scavenger_pack_02
compass_radarline
perk_awareness
mc/mtl_t6_attach_wlp_thermal
gfx_fxt_env_water_foam2_ds128
gfx_fxt_env_dust_mote_pcloud_blend
hud_grenadeicon_256
mc/mtl_t6_wpn_shotty_870mcs
menu_mp_mountain_map_select_big
mc/mtl_fx_decal_character_blood
xenonbutton_a
xenonbutton_b
gfx_fxt_debris_clump_dirt_ds16
mc/mtl_c_usa_secserv_sam_head
ui_skin_german
xenonbutton_x
xenonbutton_y
gfx_fxt_sparks_rndhit
gfx_fxt_light_flare_phosphorous_e10_z10
em_bg_flag_belgium
playlist_koth
barrack_prestige_icon
mc/mtl_c_gen_mp_datapad_thermal
em_bg_flag_china
hud_ks_m32_menu
hatchet_reticle
hud_medals_destroyed_missile_drone
hud_scavenger_pickup
em_bg_flag_sudan
menu_mp_lobby_aar_icons_target
mc/mtl_t6_attach_rus_silencer
cac_mods_mms
em_bg_wpn_camo_crossbow
hud_medals_cleanup
emblem_bg_buzzkill
hudicon_ctf_flag_carry_pmc
reflex_0
reflex_1
reflex_2
reflex_3
reflex_4
reflex_5
reflex_6
reflex_7
reflex_8
reflex_9
loadscreen_zm_transit_dr_zcleansed_diner
hud_medals_longshot
hud_medals_share_sentrygun
hud_mp_vis_ks_bar
gfx_fxt_debris_gib_metal_ds16_add
menu_mp_weapons_saiga12_big
hud_medals_share_rcxd
em_bg_wpn_camo_b23
demo_button_outline
perk_ghost_256
wc/gfx_crater_dirt
emblem_bg_weapons_master
rank_cpl_128
em_bg_wpn_attach_judge
hud_medals_ggame_humiliation
menu_div_gold_sub03_64
rank_ltcol
extracam2d
hud_medals_defense
rank_prestige01_128
reticle_center_cross
em_bg_flag_macedonia
emblem_bg_bo2_pl_kc
mc/mtl_t6_wpn_shotty_saiga_camo1
mc/mtl_t6_wpn_shotty_saiga_camo2
mc/mtl_t6_wpn_shotty_saiga_camo3
mc/mtl_t6_wpn_turret_sentry_gun_ammo_thermal
menu_mp_lobby_aar_award_challenge
fullscreen_dirt_right
gfx_fxt_light_glow_square_z0
rank_maj_128
gfx_fxt_light_glow_square_z3
emblem_bg_streak_stealth_heli
hud_us_flashgrenade_256
menu_mp_cosmodrome_map_select_big
rank_cpl
rank_cpt
em_bg_flag_vietnam
gfx_fxt_debris_trash
mc/mtl_weapon_camo_bacon_attach_1
mc/mtl_weapon_camo_bacon_attach_2
mc/mtl_hellfire_missile
menu_mp_star_rating
gfx_fxt_fire_anim_lick_add
em_bg_flag_croatia
menu_mp_weapons_rpg
hud_medals_agr
hud_medals_destroyed_uav
graphline
mc/mtl_veh_t6_air_fa38_cockpit_baked_low
mc/mtl_t6_wpn_turret_ads_detect
cac_mods_combo_r_a
hud_medals_dogs
hud_medals_destroyed_plane_mortar
league_team_1
league_team_2
menu_mp_dots_middle_repeat
gfx_fxt_light_flare_phosphorous_eo20_z20
mc/mtl_t6_wpn_ballistic_knife_thermal
hud_medals_share_hellstorm
em_bg_flag_lesotho
mc/mtl_t6_wpn_grenade_frag
menu_mp_lobby_locked
em_bg_flag_serbia
mc/mtl_t6_wpn_grenade_emp_glass
emblem_bg_diamond_club
perk_ninja
mc/mtl_german_shepherd_fur_black
gfx_fxt_gas_flash_blue_z0_blnd
menu_mp_lobby_views
mc/mtl_weapon_camo_toxic_attach_1
emblem_bg_master_humiliation
mc/mtl_weapon_camo_toxic_attach_2
hud_shoutcasting_notify_kc
reticle_side_round
menu_mp_weapons_ballistic_knife_big
menu_div_platinum
hud_medals_destroyed_heli_guard
menu_mp_weapons_pm_big
menu_mp_weapons_hk416_big
mc/mtl_p_glo_scavenger_pack_01_obj
em_bg_wpn_camo_rpg
wc/gfx_impact_plaster01
wc/gfx_impact_plaster02
menu_mp_tab_end
mc/mtl_t6_wpn_uav_radio
menu_mp_toomany_backing
em_bg_flag_south_sudan
mc/mtl_t6_wpn_turret_ads
gfx_fxt_smk_scattered_z10_ds255
mc/mtl_t6_attach_optic_combo_lens
mc/gfx_impact_blood_spatter01
mc/gfx_impact_blood_spatter02
mc/gfx_impact_blood_spatter03
hud_obit_hk_drone
mc/mtl_t6_wpn_pistol_fnp45
emblem_bg_chain_killer
em_bg_wpn_complete_mcs
bitchin_flash
em_bg_flag_morocco
menu_mp_popup
mc/mtl_t6_wpn_supply_drop_trap
mc/mtl_t6_wpn_pistol_judge_thermal
league_tdm
cac_mods_extended_stock
waypoint_return
equipped_box
menu_mp_cac_wcard_line
mc/mtl_t6_wpn_claymore
em_bg_wpn_attach_mcs
mc/mtl_t6_attach_bcpu
hud_medals_killchain
hud_mp_vis_gun_title_right
em_bg_flag_marshall_islands
em_bg_flag_angola
hud_ks_auto_turret_big
em_bg_flag_argentina
mc/global_invisible_bullet_clip_brick
poison
lui_glow_point
em_bg_flag_eritrea
emblem_bg_ffa_superior
codtv_recording
barrack_ass_fieldspecial
menu_mp_weapons_mp7_big
waypoint_circle_arrow_green
$line
menu_mp_bonuscard_perk_1_greed
menu_div_gold_sub02_64
menu_sp_cac_single_dip
gfx_fxt_light_flare_phosphorous_eo20
hud_medals_aggression_dom
em_bg_flag_mauritius
menu_mp_la_map_select_bw
mc/mtl_t6_attach_optic_rmr_reticle_01
mc/mtl_t6_attach_optic_rmr_reticle_02
mc/mtl_t6_attach_optic_rmr_reticle_03
mc/mtl_t6_attach_optic_rmr_reticle_04
mc/mtl_t6_attach_optic_rmr_reticle_05
mc/mtl_t6_attach_optic_rmr_reticle_06
mc/mtl_t6_attach_optic_rmr_reticle_07
mc/mtl_t6_attach_optic_rmr_reticle_08
mc/mtl_t6_attach_optic_rmr_reticle_09
mc/mtl_t6_wpn_minigun_thermal
reflex_20
reflex_21
reflex_22
reflex_23
reflex_24
reflex_25
hud_ks_u2_spyplane_menu
reflex_26
reflex_27
reflex_28
reflex_29
hud_ks_spy_sat_menu
hudicon_ctf_flag_carry_cd
gfx_fxt_light_flare2_eo2
gfx_fxt_light_flare2_eo5
menu_theater_arrow
em_bg_flag_libya
emblem_bg_classified_lobby
em_bg_wpn_camo_smaw
mc/mtl_t6_attach_tritium_grn_glo
perk_awareness_256
perk_fast_hands_256
menu_mp_weapons_smaw
spectator_box_end
hud_ks_supply_drop
mtl_weapon_camo_viper
mc/mtl_t6_wpn_knife_base_camo2
ui_sliderbutt_1
hud_medals_deathmachine
menu_camo_mtx_punk
hud_faction_backing
em_bg_flag_madagascar
mc/mtl_t6_wpn_smg_chicom_thermal
em_bg_ani_dragon
spectator_box_middle
hud_obit_case
heatmap_default
hud_xm25_dist
em_bg_flag_austria
lui_loader_32
mc/mtl_c_usa_milcas_mcknight_head_camo
map_grid_square
hud_faction_back_light
mc/mtl_fxuse_oneflag_flagbase_cylinder
hud_medals_hack_heist
menu_mp_weapons_insas
talkingicon
hud_pitch_meter
mc/mtl_t6_wpn_ar_scarh_thermal
mc/mtl_t6_wpn_ar_scarh_camo1
menu_mp_lobby_new
menu_camo_siberia_pattern
mc/mtl_t6_wpn_ar_scarh_camo2
mc/mtl_t6_wpn_ar_scarh_camo3
mc/mtl_t6_wpn_ar_scarh_camo4
menu_mp_weapons_pm
mtl_weapon_camo_mtx3_massacre_alt
mc/mtl_t6_wpn_turret_sentry_gun_base_detect
digital_noise_filter
menu_mp_lobby_heat_indicator_circle
mc/gfx_impact_black01
mc/gfx_impact_black02
mc/mtl_weapon_camo_carbon_fiber
mc/mtl_weapon_camo_muertos_attach
menu_button_backing
em_bg_flag_venezuela
mc/mtl_weapon_camo_zmb_dlc4_alt_attach
mc/mtl_clan_tag
menu_camo_kryptek_pattern
em_bg_wpn_camo_mk48
menu_mp_lobby_frame_inner_ingame
mc/mtl_veh_t6_rcxd_extra_bits_alt
mc/mtl_sa6_missile_desert
em_bg_flag_monaco
menu_mp_cac_tact_line
compassping_squad_lead_mp
mc/mtl_t6_attach_optic_rangefinder_ads
stencilshadow
menu_mp_weapons_mk48
hud_medals_share_uav
league_moshpit_64
mc/mtl_t6_wpn_pistol_fnp45_camo2
mc/mtl_t6_wpn_pistol_fnp45_camo3
menu_motd_votecamo_1b
mc/mtl_german_shepherd_black
gfx_fxt_smk_def_4_z200
gfx_fxt_light_hot_add_z0
mc/mtl_t6_attach_optic_combo
hud_mp_vis_ks_dpad_box
em_bg_flag_bangladesh
mc/mtl_veh_t6_v78_vtol_enemy
emblem_bg_streak_missle
mc/mtl_t6_wpn_sniper_ballista_camo1
mc/mtl_t6_wpn_sniper_ballista_camo2
mc/mtl_t6_wpn_sniper_ballista_camo3
menu_mp_cairo_map_select
mc/mtl_t6_attach_optic_acog_camo1
mc/mtl_t6_attach_optic_acog_camo2
barrack_career_icon
mc/mtl_weapon_camo_bacon_attach
menu_mp_killstreak_select
gfx_fxt_debris_clump_dirt_ds128_z0
emblem_bg_bo2_pl_sup_hardpoint
faction_pla
mc/mtl_t6_wpn_lmg_mk48_camo2_detail
mc/mtl_t6_wpn_lmg_mk48_camo1
mc/mtl_t6_wpn_lmg_mk48_camo2
mc/mtl_t6_wpn_lmg_mk48_camo3
mc/mtl_t6_wpn_lmg_mk48_camo4
menu_mp_crisis_map_select
menu_camo_mtx_beast
hud_ks_rcbomb_256
perk_flak_jacket
gfx_fxt_env_water_foam2
hud_ks_emp_big
hud_medals_share_warthog
cac_mods_red_dot
mc/mtl_weapon_camo_diamond_alt_attach
mc/mtl_t6_wpn_sniper_dsr50_thermal
acog_0
acog_1
acog_2
barrack_career_precision
acog_3
acog_4
acog_5
acog_6
acog_7
acog_8
acog_9
menu_camo_mtx_massacre
perk_hardwired
emblem_bg_streak_deathmachine
demo_timeline_faded
mpflag_spectator
gfx_fxt_debris_cottonpuff
gfx_fxt_smk_def_2_z200
emblem_bg_spotter
em_bg_flag_wales
gfx_fxt_smk_light_z3
menu_mp_lobby_ops
mtl_weapon_camo_mtx3_breach_alt
hud_mp_num_big_slash_white
lui_array_map_vote
mc/mtl_weapon_camo_etching_attach
mc/gfx_grass_piece1
lagometer
mc/gfx_impact_glass01_riotshield
menu_mp_mirage_map_select_final
mc/mtl_player_icon_world
flag_australia
hud_ks_qr_drone_drop
mc/mtl_t6_wpn_sniper_xpr50_scope_thermal
mc/mtl_t6_wpn_claymore_detect
mc/mtl_t6_wpn_sniper_svu_thermal
mc/mtl_t6_veh_drone_quad_rotor_gun
hud_medals_share_satrecon
mp_hud_wasp_inner_white
emblem_bg_prestige_pfighter
mc/mtl_weapon_camo_zombies_attach_1
emblem_bg_att_adj_stock
mc/mtl_t6_wpn_pistol_kard
em_bg_flag_turkmenistan
scope_overlay_envg_ir
hud_ks_planemortar_big
lui_playercard
hud_lui_meter_bracket_shadow
mc/mtl_t6_wpn_ar_hk416_grip_camo2
em_bg_wpn_complete_smaw
hud_ks_counter_uav_menu
menu_mp_slums_map_select_final
mouse_click_active
mc/mtl_veh_t6_drone_tank_alt
gfx_fxt_fx_null
kd_chart_plus
em_bg_flag_kyrgyzstan
playlist_hardcore
barrack_secondary_icon
menu_mp_carrier_map_select
mc/mtl_t6_wpn_launch_m32
menu_livestream_hollow_fill
emblem_bg_weapon_bootcamp
lui_rightshadow
mc/mtl_veh_t6_rcxd_wheels_alt
rank_gysgt
resample_shift
mc/mtl_t6_wpn_turret_minigun_detect
mc/mtl_t6_wpn_shotty_870mcs_thermal
$blend
gfx_fxt_debris_wind_ash_z10
hud_medals_unstoppable
hud_frame_faction_fade
emblem_bg_equip_ax
menu_mp_russianbase_map_select
menu_mp_downhill_map_select_final
mc/mtl_weapon_camo_zmb_dlc2_alt_1
mc/mtl_t6_attach_optic_reflex_reticle_20
mc/mtl_weapon_camo_zmb_dlc2_alt_2
mc/mtl_t6_attach_optic_reflex_reticle_21
mc/mtl_weapon_camo_zmb_dlc2_alt_3
emblem_bg_hq_assault
mc/mtl_t6_attach_optic_reflex_reticle_22
mc/mtl_t6_attach_optic_reflex_reticle_23
mc/mtl_t6_attach_optic_reflex_reticle_24
mc/mtl_t6_attach_optic_reflex_reticle_27
mc/mtl_t6_attach_speedloader
mc/mtl_t6_attach_optic_reflex_reticle_28
mc/mtl_t6_attach_optic_reflex_reticle_29
menu_mp_lobby_frame_tab_center
gfx_fxt_light_incandescent
$raw
gfx_fxt_smk_def_1_z200_ds192
menu_mp_random_map_select_bw
mc/mtl_t6_wpn_ar_an94_camo1
mc/mtl_t6_wpn_ar_an94_camo2
mc/mtl_t6_wpn_ar_an94_camo3
mc/mtl_t6_wpn_ar_an94_camo4
menu_camo_mtx_pap_32
mc/mtl_t6_wpn_shield_camo1
mc/mtl_t6_wpn_shield_camo2
mc/mtl_t6_wpn_shield_camo3
gfx_fxt_smk_light_add_z5
generic_filter_infrared
gfx_fxt_env_electric_arc1_add_eo10
cac_mods_tribolt
mtl_fx_hydro_water_dam3b
button_right_mouse
menu_mp_lobby_icon_film
mc/mtl_weapon_camo_dragon_alt
headicontalkballoon
menu_mp_esrb
em_bg_wpn_complete_mk48
menu_prestige_icon_refund
mc/mtl_weapon_camo_zmb_dlc4_alt
ui_button_xenon_stick_ani_32_rdown
em_bg_wpn_attach_hamr
em_bg_flag_kuwait
mc/mtl_t6_wpn_grenade_emp
mc/mtl_fx_wood_splinter
emblem_bg_streak_hpm
mc/mtl_veh_t6_cuav_drone
em_bg_flag_france
perk_hardline_256
mc/mtl_weapon_camo_mystic_alt_1
mc/mtl_weapon_camo_mystic_alt_2
mc/mtl_weapon_camo_mystic_alt_3
menu_mp_nuked_map_select
hud_medals_dropshot
mc/mtl_t6_wpn_smg_chicom_camo1
mc/mtl_t6_wpn_smg_chicom_camo2
mc/mtl_t6_wpn_smg_chicom_camo3
mc/mtl_t6_wpn_smg_chicom_camo4
rank_mgysgt_128
mc/mtl_t6_wpn_briefcase_bomb_detail
menu_mp_nightclub_map_select_bw
menu_mp_turbine_map_select_bw
em_bg_wpn_complete_an94
menu_camo_blossom_pattern
mc/mtl_t6_attach_optic_vzoom_xpr50
fonts/distfont
em_bg_flag_dominica
menu_mp_weapons_smaw_big
gfx_fxt_debris_gib_glass2_add
hud_medals_denied
mc/mtl_t5_weapon_explosive_arrow
mc/mtl_veh_t6_v78_vtol_guns_enemy
mc/mtl_weapon_camo_diamond
menu_mp_lobby_icon_customgamemode
menu_div_platinum_sub02_64
menu_mp_array_map_select_bw
menu_mp_weapons_mp7
mc/mtl_veh_t6_pegasus_body
menu_mp_bonuscard_secondary_gunfighter
hud_medals_hacked
menu_mp_weapons_sa58
shadowoverlay
mc/mtl_t6_wpn_briefcase_bomb
gfx_fxt_light_flare_halogen_gr_nocull
hud_medals_destroyed_heli_comlink
em_bg_flag_ghana
menu_next_prev_arrow
rank_majgen_128
mc/mtl_weapon_camo_ghost_1
mc/mtl_weapon_camo_ghost_2
mc/mtl_weapon_camo_ghost_3
mc/mtl_weapon_camo_ghost_4
menu_livestream_signal
code_warning_collision
gfx_fxt_sparks_rndhit_eo15_z15
gfx_fxt_smk_puff_z120
mc/mtl_c_gen_insidemouth_thermal
menu_mp_bonuscard_perk_2_greed
emblem_bg_camo03
mc/mtl_weapon_camo_bacon_alt_attach_1
mc/mtl_weapon_camo_bacon_alt_attach_2
gfx_fxt_smk_anim_cloud_ds192
hud_ks_ai_helicopter
loadscreen_zm_nuked_zstandard_nuked
emblem_bg_ctf_flag_warden
gfx_fxt_debris_clump_dirt_ds128_z0_add
menu_mp_weapons_tar21_big
hud_medals_hero
em_bg_flag_moldova
gfx_fxt_light_headlight_gr_eo10_z5
mtl_weapon_camo_octane
mc/mat_veh_t6_drone_hunterkiller_unlit_viewmodel
mtl_weapon_camo_partyrock_solid
menu_number_zero
menu_mp_cac_second_line
com_sup_locked
em_bg_flag_iceland
menu_mp_lobby_cac_highlight
em_bg_wpn_camo_mp7
hud_ks_planemortar_drop
menu_mp_weapon_lvl_star
mc/mtl_flag_red
rank_ssgt
menu_mp_firingrange_map_select_bw
menu_prestige_icon_awards
menu_mp_heatmap_figure
mc/mtl_weapon_camo_muertos
emblem_bg_bo2_mt_vet
menu_mp_soldiers
mc/mtl_t6_wpn_sniper_xpr50_thermal
barrack_prestige_wc
gfx_fxt_light_ray_search
mc/mtl_weapon_camo_carbon_fiber_alt_attach_1
emblem_bg_score_master_support
mc/mtl_t6_wpn_turret_sentry_gun_base
hud_medals_avenger
perk_scavenger_256
menu_mp_weapons_sa58_big
gfx_fxt_smk_trail_thick
hud_medals_lightstrike
em_bg_flag_azerbaijan
perk_lightweight_256
hud_medals_share_emp
em_bg_flag_papua_new_guinea
gfx_fxt_bio_bloodburst_c_ds64
hud_medals_killstreak01
gfx_fxt_debris_clump_ds128_z10
emblem_bg_snd_master
stencildisplay
gfx_fxt_bio_bloodgush_ds64
emblem_bg_dcoyote
menu_mp_lobby_frame_inner
mc/mtl_t6_attach_bullet
gfx_fxt_light_glow_square_gr
mc/mtl_cbu97_clusterbomb
menu_mp_random_map_select
emblem_bg_ffa_master
gfx_fxt_smk_gen
$fxaa
menu_mp_carrier_map_select_final
cac_mods_fmj
xenon_stick_move_look
gradient_fadein
mc/mtl_t6_wpn_turret_ads_glass_thermal
hud_ks_supply_drop_256
emblem_bg_masterchef
gfx_fxt_smk_scattered_ds255
lui_loader
menu_mp_cac_perk_wc
gfx_fxt_spark_grind
mc/mtl_veh_t6_drone_supply_alt
em_bg_prestige_10
em_bg_prestige_11
em_bg_wpn_camo_judge
livestream_cam
em_bg_ani_anarchy
waypoint_flag_capture
em_bg_wpn_complete_kap40
em_bg_flag_nicaragua
emblem_bg_prestige_flash
perk_warrior
menu_mp_discovery_map_select
hud_ks_dogs_menu
hud_obit_warthog
menu_div_platinum_sub01_64
gfx_fxt_smk_spiral
mc/mtl_t6_attach_optic_vzoom_thermal
em_bg_flag_cyprus
gfx_fxt_debris_plume_dirt_ds128
hud_ks_emp
gfx_fxt_env_electric_arc2_add_eo10
hud_us_stungrenade
reticle_flechette
mc/mtl_t6_attach_smg_silencer1
mc/mtl_t6_wpn_launch_smaw_thermal
menu_div_no_place
emblem_bg_bloodthirsty
menu_camo_ronin_pattern
party_ready
ui_smoke
menu_mp_nuketown_2020_map_select_final
rank_sgt
hud_medals_afterlife
mc/mtl_test_sphere_silver_lores
em_bg_flag_togo
menu_mp_villa_map_select_final
mc/mtl_weapon_camo_etching_1
mc/mtl_weapon_camo_etching_2
mc/mtl_weapon_camo_etching_3
mc/mtl_weapon_camo_etching_4
em_bg_wpn_camo_m1216
clear_alpha
emblem_bg_ovsat_support
menu_mp_carrier_map_select_bw
menu_codtv_icon_rated
hudicon_ctf_flag_carry_fbi
em_bg_wpn_attach_mtar
rank_prestige13_128
pc_keyboard_right
objective_friendly
emblem_bg_tdm_vanquisher
circle
mc/mtl_fx_bullet_chain_alpha
mc/mtl_p6_con_tv_wall_screens
em_bg_flag_albania
gfx_fxt_smk_def_1_z10
loadscreen_mp_express
mc/mtl_weapon_camo_ghost
acog_20
acog_21
acog_22
acog_23
acog_24
acog_25
acog_26
acog_27
acog_28
acog_29
mc/mtl_mi24p_hind_desert
hud_xpticker480ws
mc/mtl_weapon_camo_dragon_1
mc/mtl_weapon_camo_dragon_2
mc/mtl_weapon_camo_dragon_3
hud_medals_oic_elimination
hud_medals_merciless
hud_ks_straferun_256
gfx_fxt_spark_pcloud_02_oo
emblem_bg_hq_master
hud_medals_skewer
mc/mtl_fx_dest_atlas
gfx_fxt_debris_fine_clump_ds64
dualoptic_down_0
dualoptic_down_9
mc/mtl_t6_wpn_smg_mp7_thermal
em_bg_flag_sierra_leone
em_bg_flag_switzerland
menu_div_silver_sub03_64
hud_medals_share_counteruav
menu_camo_mtx_kawaii
emblem_bg_streak_uav_kill
menu_div_no_place_64
emblem_bg_master
menu_mp_russianbase_map_select_bw
debug_sphere_interior
gfx_fxt_debris_gib_metal_ds16
playlistpop_default
loadscreen_mp_frostbite
mc/mtl_weapon_camo_carbon_fiber_1
mc/mtl_weapon_camo_carbon_fiber_2
mc/mtl_weapon_camo_carbon_fiber_3
em_bg_ani_armor
headicon_dead
mtl_weapon_camo_octane_solid
scope_overlay_xpr50
em_bg_wpn_attach_saiga
mc/mtl_veh_t6_a10f
loadscreen_mp_meltdown
menu_mp_weapons_evoskorpion
hud_trophy_system
menu_mp_hijacked_map_select_final
compass_talon_top
mc/mtl_weapon_camo_mystic_alt_attach
em_bg_ani_w115
mc/mtl_t6_wpn_smg_msmc_thermal
gfx_fxt_light_headlight_eo2_z2
perk_fast_hands
menu_mp_cac_gren_line
emblem_bg_junkyard
hud_lui_medal_glow
emblem_bg_att_fore_grip
menu_mp_lobby_aar_wager01
menu_mp_lobby_aar_wager02
menu_mp_lobby_aar_wager03
hud_xm25_number_strip
mc/mtl_t6_wpn_turret_sentry_gun_base_red
mp_minimap_overlay
hud_mp_num_big_0
hud_mp_num_big_1
hud_mp_num_big_2
hud_mp_num_big_3
hud_mp_num_big_4
hud_mp_num_big_5
hud_mp_num_big_6
hud_mp_num_big_7
hud_mp_num_big_8
hud_mp_num_big_9
mc/railroadtrack_top
mc/mtl_p6_attack_dog_vest_dark
ui_left_arrow_active
menu_mp_combatrecord_bar
playlist_combat_training_obj
emblem_bg_streak_hk
mc/mtl_t6_attach_optic_mms_thermal
barrack_ass_precision
mc/gfx_impact_concrete01
mc/gfx_impact_concrete02
mc/gfx_impact_concrete03
em_bg_flag_latvia
em_bg_flag_peru
hud_obit_minigun
scope_overlay_envg_emp
menu_camo_mtx_ghost_128
hud_medals_multikill01
hud_ks_spy_sat_drop
feedbackfilmblend
menu_div_silver_64
hud_icon_satchelcharge
hud_shoutcasting_boxes_glow
menu_mp_lobby_frame_fade
menu_camo_skulls_pattern
menu_mp_heatmap_10
menu_mp_heatmap_11
menu_mp_heatmap_12
menu_mp_heatmap_13
menu_mp_heatmap_14
menu_mp_heatmap_15
menu_mp_heatmap_16
gfx_fxt_debris_plume_water_z0
menu_mp_heatmap_17
em_bg_flag_seychelles
lui_loader_32_no_offset
emblem_bg_dom_vet
hud_medals_superkill
menu_mp_lobby_classified
menu_div_bronze
menu_lobby_strip_whole
hud_medals_megakill
em_bg_flag_south_africa
wc/gfx_impact_asphalt01
wc/gfx_impact_asphalt02
menu_camo_mtx_aqua_32
cac_mods_rapid_fire
em_bg_flag_india
mc/mtl_t6_wpn_lmg_lsat_ammo
em_bg_flag_myanmar
spinner_wedge
hud_obit_death_suicide
rank_prestige10
rank_prestige11
rank_prestige12
rank_prestige13
playlist_gungame
rank_prestige14
rank_prestige15
hud_medals_sentrygun
mc/mtl_t6_wpn_ar_sig556_camo1
mc/mtl_t6_wpn_ar_sig556_camo2
mc/mtl_t6_wpn_ar_sig556_camo3
mc/mtl_t6_wpn_ar_sig556_camo4
webm_720p
menu_mp_lobby_op40
mc/global_invisible_nosight_clip
mc/mtl_t6_wpn_sniper_dsr50_scope_camo2
line_horizontal
reticle_side_round_big_left
emblem_bg_bo2_pl_sup_stick_stone
gfx_fxt_debris_fine_clump_ds128
menu_mp_hanoi_map_select_big
emblem_bg_att_select_fire
menu_mp_bonuscard_perk_3_greed
mc/mtl_t6_wpn_turret_sentry_gun_base_thermal
light_corona
reticle_side_round_big_top
em_bg_flag_falkland_islands
gfx_fxt_spark_pcloud_01_oo
hud_mp_num_big_slash
mc/mtl_weapon_camo_diamond_attach
menu_mp_weapons_dsr1
menu_camo_massacre_pattern
reticle_center_cross_mg42
menu_div_silver_sub02_64
mc/mtl_t6_attach_tritium_red_glo
hud_mp_vis_score_highlight
hud_icon_bomb_b_bottom
mc/mtl_t6_attach_optic_reflex_reticle
mc/mtl_t6_wpn_shield_thermal
generic_filter_hud_outline
menu_mp_mountain_map_select_bw
flag_denmark
mtl_weapon_camo_mtx3_aqua_pat
emblem_bg_att_tac_knife
menu_mp_backing_frame
em_bg_flag_new_zealand
menu_mp_weapons_ballista_big
resample_hdr
hud_medals_double_penetration
em_bg_flag_solomon_islands
hud_medals_hellstorm
mc/mtl_t6_wpn_ballistic_knife_retrieve
gfx_fxt_debris_heli_rotor_swirl_ds192
rank_prvt
emblem_bg_prestige_p1
emblem_bg_prestige_p2
emblem_bg_prestige_p3
emblem_bg_prestige_ironsites
hud_ks_microwave_turret
ui_scrollbar_arrow_dwn_a
waypoint_flag_grab
em_bg_flag_uruguay
emblem_bg_kcon_vet
mc/mtl_t6_attach_optic_vzoom_dsr50
em_bg_flag_united_states
mc/mtl_t6_wpn_pistol_fiveseven_thermal
mc/mtl_mh_6_little_bird_body
hud_mp_firerate_lock
xenonbutton_dpad_right
mc/mtl_t6_wpn_ar_saritch_thermal
mc/mtl_weapon_camo_etching
mc/mtl_t6_attach_optic_combo_thermal
mc/mtl_defaultvehicle
mtl_t6_wpn_launch_fhj18_ui3d_background
menu_mp_drone_map_select_final
emblem_bg_dom_master
menu_camo_matuka_pattern
mc/mtl_t6_wpn_lmg_hamr_strap
mc/mtl_t6_attach_optic_combo_reticle_up
streaming_temp_image_20
streaming_temp_image_21
menu_div_bronze_sub01
streaming_temp_image_22
menu_div_bronze_sub02
streaming_temp_image_23
menu_div_bronze_sub03
streaming_temp_image_24
gfx_fxt_exp_ember_omni_add
streaming_temp_image_25
streaming_temp_image_26
streaming_temp_image_27
streaming_temp_image_28
streaming_temp_image_29
hud_ks_straferun_drop
kd_chart_minus
cinematic
mouse_grab_open
mc/mtl_t6_wpn_ar_xm8_thermal
menu_zm_nuked_map_blur
em_bg_flag_colombia
mc/mtl_t6_wpn_pda_ui3d
hud_sensor_grenade_256
c4_reticle
loadscreen_mp_la
em_bg_flag_lebanon
loadscreen_mp_turbine
em_bg_flag_malawi
mc/mtl_german_shepherd_thermal
menu_mp_berlinwall_map_select_bw
mc/mtl_t6_wpn_launch_fhj18_reticle
gfx_fxt_debris_spike_z3
hud_us_stungrenade_256
mc/mtl_t6_attach_optic_holo_lens
hud_ks_counter_uav_drop
hud_ks_counter_uav_256
hud_mp_firerate_auto
playlist_sp_vet
perk_hardline
gfx_fxt_smk_scattered_z120_ds255
hud_medals_frenzykill
emblem_bg_prestige_perk1_hline
gfx_fxt_debris_fine_clump_ds128_add
faction_128_seals
mtl_weapon_camo_mtx3_coyote_alt
blue_square_glow
em_bg_flag_netherlands
emblem_bg_nocod
menu_white_backing_faded
mc/mtl_weapon_camo_etching_attach_1
mc/mtl_weapon_camo_etching_attach_2
em_bg_wpn_complete_m27
menu_div_silver_sub01_64
hud_mp_vis_ks_prog_arrow
perk_hacker_256
emblem_bg_precision_master
playlist_nt2025
lui_ratecurve
playlist_multiteam
hud_mp_num_big_line
em_bg_flag_mozambique
em_bg_wpn_attach_m27
codtv_dislike
em_bg_flag_botswana
cac_mods_ironsight
mc/mtl_flag_neutral
ui_host
mc/mtl_weapon_camo_armor_attach_1
mc/mtl_weapon_camo_armor_attach_2
gfx_fxt_light_flare2_z0
mc/mtl_t6_wpn_sniper_svu
hud_ks_harpy_single
mc/mtl_t6_wpn_sniper_dsr50_scope_thermal
emblem_bg_massacre
em_bg_wpn_complete_qbb
emblem_bg_prestige_sniper
mc/mtl_t6_attach_optic_specter_camo1
mc/mtl_t6_attach_optic_specter_camo2
hud_ks_heli_gunner_256
em_bg_flag_australia
perk_cold_blooded
rank_2ndlt
hud_medals_ggame_regicide
em_bg_wpn_camo_scar
em_bg_wpn_complete_smr
em_bg_wpn_attach_qbb
menu_mp_weapons_scar
menu_codtv_icon_fileshare
menu_mp_frostbite_map_select_final
ssao_ao
em_bg_wpn_camo_pk
gfx_fxt_debris_clump_dirt_ds128
em_bg_wpn_attach_smr
gradient_left
gfx_fxt_env_water_drip_pcloud_01
gfx_fxt_env_water_drip_pcloud_02
gfx_fxt_env_water_drip_pcloud_03
gfx_fxt_env_water_drip_pcloud_04
ui_line_graph
mc/mtl_t6_wpn_shotty_saiga
mc/mtl_t6_attach_gl_gp25_thermal
mc/mtl_t6_attach_optic_rmr_reticle_30
mc/mtl_t6_attach_optic_rmr_reticle_31
mc/mtl_t6_attach_optic_rmr_reticle_32
mc/mtl_t6_attach_optic_rmr_reticle_33
mc/mtl_t6_attach_optic_rmr_reticle_34
mc/mtl_t6_attach_optic_rmr_reticle_35
mc/mtl_t6_attach_optic_rmr_reticle_36
mc/mtl_t6_attach_optic_rmr_reticle_37
mc/mtl_t6_attach_optic_rmr_reticle_38
mc/mtl_t6_attach_optic_rmr_reticle_39
remotemissile_target
menu_popup_back
perk_marathon
hud_medals_choppergunner
emblem_bg_career_mastery_scorestreak
mc/mtl_us_smoke_grenade_burnt
wc/gfx_impact_glass01_riotshield_viewmodel
em_bg_flag_bahamas
em_bg_flag_england
cac_mods_bors
menu_camo_mtx_bacon
emblem_bg_tdm_master
menu_mp_weapons_hk416
em_bg_flag_san_marino
menu_camo_mtx_graf
mc/mtl_t6_wpn_shotty_srm1216_camo1
mc/mtl_t6_wpn_shotty_srm1216_camo2
mc/mtl_t6_wpn_shotty_srm1216_camo3
mc/mtl_t6_wpn_shotty_srm1216_camo4
mc/mtl_t6_wpn_grenade_flashbang
em_bg_flag_singapore
mc/mtl_t6_wpn_ar_x95l_alpha
emblem_bg_backstabber
compass_turret_white
menu_camo_mtx_partyrock_32
hud_medals_oic_frugal
damage_feedback
mc/mtl_t6_wpn_crossbow_camo1
mc/mtl_t6_wpn_crossbow_camo2
mc/mtl_t6_wpn_crossbow_camo3
menu_camo_mtx_kawaii_32
mc/mtl_t6_wpn_shield_camo1_red
menu_lobby_icon_elite
gfx_fxt_light_incandescent_eo10_z5
hud_obit_silent_guardian
mc/mtl_t6_wpn_ar_hk416_thermal
hud_xpticker480
gfx_green_tracer
emblem_bg_bo2_pl_sup_dom
gfx_fxt_light_burst_eo5
streaming_temp_image_0
streaming_temp_image_1
streaming_temp_image_2
streaming_temp_image_3
playlist_infantry
streaming_temp_image_4
streaming_temp_image_5
streaming_temp_image_6
streaming_temp_image_7
streaming_temp_image_8
streaming_temp_image_9
mc/mtl_t6_attach_optic_acog_reticle_20
mc/mtl_t6_attach_optic_acog_reticle_21
mc/mtl_t6_attach_optic_acog_reticle_22
mc/mtl_t6_attach_optic_acog_reticle_23
mc/mtl_t6_attach_optic_acog_reticle_24
mc/mtl_t6_attach_optic_acog_reticle_27
mc/mtl_t6_attach_optic_acog_reticle_28
mc/mtl_t6_attach_optic_acog_reticle_29
hud_ks_talon_256
lui_map
mc/mtl_t6_wpn_briefcase_bomb_alpha
mc/mtl_veh_t6_drone_tank_missile
mc/mtl_t6_wpn_hatchet
spectator_pip_scoretop
emblem_bg_triple_killer
menu_mp_weapons_ksg_big
compassping_enemyyelling
gfx_fxt_light_glow
menu_mp_cac_gren_wc
menu_mp_emblem_new_icon
mc/mtl_t6_wpn_shield_red
menu_mp_lobby_locked_big
mc/infrared_white
compassping_squadyelling_mp
hud_obit_crate
hud_obit_exploding_car
hud_shoutcasting_viewing_box
console
mc/mtl_veh_t6_air_fa38_glass_opaque
emblem_bg_bo2_pl_sup_hq
hud_medal_burst_red
scope_overlay_dsr50
menu_div_semipro_sub03_64
hud_mp_vis_right_lower
mc/mtl_veh_t6_asd_tread_thermal
menu_motd_votecamo_4b
mc/dub_concrete_wall_01_trim_clean
mc/mtl_t6_wpn_turret_ads_alpha_thermal
hud_medals_destroyed_heli_gunner
mc/mtl_t6_attach_optic_holo_reticle_20
hud_grenade_launcher_256
mc/mtl_t6_attach_optic_holo_reticle_21
mc/mtl_t6_attach_optic_holo_reticle_22
mc/mtl_t6_attach_optic_holo_reticle_23
rank_cpt_128
mc/mtl_t6_attach_optic_holo_reticle_26
mc/mtl_t6_attach_optic_holo_reticle_27
mc/mtl_t6_attach_optic_holo_reticle_28
mc/mtl_t6_attach_optic_holo_reticle_29
em_bg_flag_uzbekistan
mc/mtl_weapon_camo_mystic_1
mc/mtl_weapon_camo_mystic_2
mc/mtl_weapon_camo_mystic_3
cac_mods_var_zoom
hud_ks_supply_drop_big
gfx_fxt_smk_light_z200
hud_tact_insert_256
compass_sam_turret_red
mc/mtl_t6_wpn_motion_sensor_detect
hud_medals_assist_suicide
dof_near_coc
mc/mtl_t6_wpn_turret_ads_thermal
gfx_fxt_light_flare_drone
menu_mp_meltdown_map_select_final
mtl_weapon_camo_kawaii_solid
emblem_lut
hud_medal_burst_yellow
hud_ks_u2_spyplane
compass_talon
hud_shoutcasting_bar_end
lui_galil
rank_bgen_128
hud_ks_talon_menu
menu_mp_weapons_attach_gl_hirez
gfx_fxt_smk_light_old_z5
hud_medals_share_hpm
menu_mp_radiation_map_select_bw
emblem_bg_movie_star
mc/mtl_fx_bullet_chain
em_bg_wpn_complete_chicom
mc/mtl_t6_wpn_briefcase_bomb_screen
emblem_bg_career_mastery_shotgun
menu_mp_pod_map_select_final
em_bg_flag_saudi_arabia
mc/mtl_t6_wpn_smg_peacekeeper_thermal
perk_blind_eye
em_bg_wpn_complete_shield
menu_mp_weapons_lsat_big
perk_ninja_256
mc/mtl_gen_eye_cornea_thermal_s
code_warning_file
emblem_bg_streak_sentry
emblem_bg_bouncing_betty
overlay_low_health
em_bg_wpn_complete_scar
ui_skin_tan
menu_mp_dots_top_bottom_fade
emblem_bg_att_tritip
menu_mp_lobby_token_128
hud_medals_sticks_bankrupt
menu_mp_lobby_sog
hudicon_ctf_flag_carry_pla
playlist_generic_01
playlist_generic_02
playlist_generic_03
playlist_generic_04
playlist_generic_05
mc/mtl_t6_attach_optic_reflex_lens
menu_mp_cac_prim_hl
em_bg_flag_tajikistan
emblem_bg_att_grenade_launcher
rank_prestige08_128
hud_ks_harpy_menu
menu_mp_lobby_like
menu_host_warning
menu_mp_weapons_attach_ft_hirez
demo_backing
generic_filter_stencil2argb
mc/global_invisible
hud_ks_straferun_big
ssao_blur
menu_mp_cairo_map_select_big
perk_marathon_256
menu_mp_express_map_select_final
mc/mtl_t6_wpn_crossbow
compass_waypoint_captureneutral_a
compass_waypoint_captureneutral_b
compass_waypoint_captureneutral_c
mc/mtl_weapon_m84_burnt
mc/mtl_t6_wpn_trophy_system_detect
webm_small
menu_mp_weapons_srm_big
hud_ks_auto_turret_marker
menu_camo_mtx_partyrock
gfx_fxt_fire_anim_fuel_gr
emblem_bg_bo2_griz_vet
mc/mtl_t6_wpn_ar_hk416_camo2
mc/mtl_t6_wpn_ar_hk416_camo3
mc/mtl_t6_wpn_ar_hk416_camo4
hud_icon_bomb_a_bottom
mc/mtl_t6_wpn_launch_usrpg
hud_offscreenobjectivepointer
mc/mtl_t6_wpn_ar_type95
menu_mp_lobby_aar_icons_kd
gfx_tracer
compass_sam_turret_green
rank_col
rank_com
gfx_fxt_debris_gib_glass2
em_bg_wpn_camo_fal
em_bg_wpn_camo_saiga
mc/gfx_crater_dirt
hud_proximitymine
em_bg_wpn_attach_pk
menu_mp_weapons_type95_big
playlist_party
mc/mtl_t6_wpn_grenade_concussion
com_sup_x
playlist_sp_reg
hud_medals_challenge
menu_mp_cac_gren_hl
mc/mtl_veh_t6_v78_vtol_glass_in
playlist_custom
emblem_bg_dom_vanquisher
hud_medals_opening_move
xenonbutton_dpad_rl
gfx_fxt_light_ray_ribbon_spread_z1
$defaultmaterial
mc/mtl_t6_attach_grip_thermal
menu_mp_cac_tact_wc
mc/mtl_t6_wpn_sniper_svu_camo2
mc/mtl_t6_wpn_sniper_svu_camo3
fullscreen_proximity_vertical0
hud_medals_pancake
fullscreen_proximity_vertical1
fullscreen_proximity_vertical2
playlist_sticks_and_stones
mc/mtl_weapon_camo_mystic_attach_1
mc/mtl_weapon_camo_mystic_attach_2
mc/mtl_t6_attach_optic_mms_camo1
menu_camo_mtx_dcoyote
lui_ratecurve_arrow
mc/mtl_t6_wpn_turret_ads_yellow
gfx_fxt_sparks_rndhit_eo15
menu_div_platinum_64
hud_medals_headshot
emblem_bg_bo2_pl_sup_sd
em_bg_wpn_camo_pdw
scope_overlay_vzoom
em_bg_flag_costa_rica
ors
compass_waypoint_defend_a
compass_waypoint_defend_b
compass_waypoint_defend_c
mech_check_fill
emblem_bg_combat_master
cac_mods_acog
mc/mtl_t6_wpn_turret_sentry_gun_ammo_detect
gfx_fxt_env_water_mist_ds128
emblem_bg_from_grave
emblem_bg_streak_rcxd
menu_white_line
perk_warrior_256
gfx_fxt_smk_light_ds128_z20
mc/mtl_t6_veh_drone_quad_rotor_body
playlist_domination
menu_mp_la_map_select
emblem_bg_bo2_green_digital01
mc/mtl_veh_t6_rcxd
menu_mp_cosmodrome_map_select_final
compass_waypoint_contested
mc/mtl_veh_t6_v78_thermal
mc/mtl_fx_shell_thermal
mc/mtl_t6_wpn_minigun_ammo
menu_mp_weapons_hamr_big
gfx_fxt_debris_gib_wood
motionblurfilter1
motionblurfilter2
motionblurfilter3
motionblurfilter4
motionblurfilter5
motionblurfilter6
motionblurfilter7
motionblurfilter8
lui_loader_no_offset
hud_willy_pete
hud_medals_oic_underdog
hud_shoutcasting_viewing_box_dead
hud_medals_sshooter_gunexpert
menu_mp_pip_outline_x
gfx_flamethrower_smoke_add_z100
mc/mtl_t6_attach_gl_m320_thermal
mc/mtl_weapon_camo_mystic
mc/mtl_t6_wpn_lmg_hamr_camo1
mc/mtl_t6_wpn_lmg_hamr_camo2
mc/mtl_t6_wpn_lmg_hamr_camo3
mc/mtl_t6_wpn_lmg_hamr_camo4
emblem_bg_nuketown_2025
em_bg_wpn_complete_sig
mc/mtl_t6_wpn_launch_m32_thermal
hud_ks_harpy
menu_mp_circle_shadow
menu_mp_weapons_five_seven
em_bg_wpn_complete_type25
mc/mtl_t6_wpn_sniper_svu_lens
gfx_fxt_smk_spiral_nocull
em_bg_ani_paladin
gfx_fxt_debris_clump_ds64_z10
menu_camo_gold_pattern
em_bg_wpn_attach_sig
mc/mat_veh_t6_drone_hunterkiller_unlit
menu_mp_village_map_select_final
hud_ks_harpy_single_256
emblem_bg_bo2_scope
menu_mp_weapons_as50_big
code_warning_maxeffects
em_bg_wpn_complete_judge
mc/mtl_veh_t6_v78_vtol_interior
emblem_bg_snd_superior
reflex_10
reflex_11
reflex_12
reflex_13
reflex_14
reflex_15
reflex_16
reflex_17
reflex_18
reflex_19
kd_chart_red
flag_russia
rank_prestige04_128
menu_camo_mtx_roxann_128
faction_isa
em_bg_flag_central_african_rep
mc/mtl_drone_overwatch_body_dark
flag_neth
rank_gysgt_128
mc/mtl_weapon_camo_armor_attach
emblem_bg_kawaii
gfx_fxt_smk_puff_z20
em_bg_flag_sweden
mtl_weapon_camo_jungletiger
emblem_bg_ctf_assassination3
hud_suitcase_bomb
hud_medals_clutch
mc/mtl_veh_t6_drone_tank_thermal
menu_mp_pip_outline
scope_overlay_svu
hud_obit_dogs
em_bg_wpn_complete_ballista
menu_mp_cracked_map_select_final
reticle_side_round_big_bottom
emblem_bg_bo2_pl_dom
compass_waypoint_kill
$additive
hud_icon_stuck_semtex
menu_mp_russianbase_map_select_final
gfx_fxt_env_water_splash_z3
mc/mtl_t5_weapon_equip_light_grn_unlit
emblem_bg_bo2_green_camo01
emblem_bg_bo2_green_camo02
mc/mtl_weapon_camo_bacon_1
mc/mtl_weapon_camo_bacon_2
em_bg_flag_panama
mc/mtl_weapon_camo_bacon_3
mc/mtl_t6_wpn_tac_insert_screen
mc/mtl_veh_air_ah94_decals
gfx_red_tracer
em_bg_wpn_complete_reflex
em_bg_wpn_complete_m1216
hud_empgrenade_256
playlist_combat_training
menu_mp_lobby_aar_award_ccontract
demo_forward_fast
mtl_weapon_camo_roxann_solid
mc/mtl_t6_wpn_lmg_type95_camo1
mc/mtl_t6_wpn_lmg_type95_camo2
mc/mtl_t6_wpn_lmg_type95_camo3
mc/mtl_t6_wpn_lmg_type95_camo4
emblem_bg_ctf_escort3
mc/mtl_t6_wpn_pistol_fiveseven_camo1
mc/mtl_t6_wpn_pistol_fiveseven_camo2
mc/mtl_t6_wpn_pistol_fiveseven_camo3
mc/mtl_t6_attach_tritium_grn
menu_mp_cac_prim_line
em_bg_flag_bhutan
rank_lt
hud_ks_reaper_drop
ui_skin_jungle_us
gfx_fxt_fire_flame_base_01_z3
mc/mtl_t6_wpn_launch_usrpg_thermal
menu_div_pro_sub03_64
postfx_dof_color
loadscreen_mp_carrier
mc/mtl_t6_attach_optic_acog_crosshair
mouse_grab_close
mc/mtl_t6_attach_optic_rangefinder_lens
menu_mp_cac_tact_hl
apply_lut3d
menu_camo_mtx_dragon_32
em_bg_wpn_complete_xpr
menu_camo_multicam_pattern
mc/mtl_t6_wpn_shotty_ksg_thermal
hud_medals_killtype01
hud_mp_firerate_hybrid
gfx_fxt_env_lightning_bolt_lg_eo2
mp_hud_sentry_inner
em_bg_wpn_attach_xpr
mc/mtl_p6_attack_dog_vest_light
xenon_stick_move
mc/mtl_t6_attach_fastmag
hud_mp_num_big_2_white
motd_elite_logo
menu_camo_mtx_massacre_32
menu_theater_nodata
mc/mtl_t6_wpn_supply_drop_detect
hud_bounce_betty
emblem_bg_streak_emp_kill
mc/mtl_t6_wpn_shield_glass_sortfx
cac_mods_foregrip
em_bg_flag_thailand
menu_mp_weapons_ksg
hud_icon_minigun
gfx_fxt_smk_scattered_z10
gfx_fxt_env_water_splash2_add
emblem_bg_bo2_pl_s_and_d
emblem_bg_kills_ar
hud_medals_ruthless
menu_mp_overflow_map_select
hud_ks_counter_uav_big
emblem_bg_ffa_hydra
playlist_hacker
hud_gl_select
hud_medals_ggame_gunslinger
menu_mp_lobby_frame_tab
ui_skin_white
compassping_squad_mp
em_bg_flag_uganda
mc/mtl_weapon_camo_muertos_attach_1
hud_mp_vis_ks_bar_backing
mc/mtl_weapon_camo_muertos_attach_2
hud_obit_death_falling
compassping_enemyfiring
hud_medals_drone
emblem_bg_att_v_zoom
emblem_bg_hq_superior
emblem_bg_streak_escort
wc/gfx_impact_glass01
wc/gfx_impact_glass02
menu_mp_hanoi_map_select_bw
playlist_sp_hard
mc/mtl_t6_wpn_turret_ads_alpha_red
gfx_fxt_env_snow_flake_cloud_01
gfx_fxt_env_snow_flake_cloud_04
gfx_fxt_env_water_plume_dense_gr
mtl_weapon_camo_mtx3_zulu_pat
hud_server_locked
killicondied
hud_shoutcasting_boxes
gfx_fxt_debris_clump_dirt_ds192
em_bg_wpn_camo_ksg
gfx_fxt_light_ray_spread_z20
hud_medals_share_ammo
perk_ghost
emblem_bg_prestige_perk2_toughness
directional_damage_feedback
menu_mp_weapons_xm8_big
mc/mtl_t6_attach_dbal
hud_medals_share_lodestar
menu_mp_weapons_870mcs_big
ui_scrollbar_arrow_left
mc/mtl_t6_wpn_turret_ads_red
feedbackblend
hud_ks_heli_gunner_big
mc/mtl_veh_air_ah94_body_dark
em_bg_flag_mongolia
ui_right_arrow_active
mc/mtl_t6_wpn_ar_x95l_cord
emblem_bg_bo2_honeycomb01
playlist_headquarters
pc_keyboard_up
hud_medal_burst_orange
rank_ltcol_128
mc/mtl_veh_t6_drone_tank
em_bg_flag_russia
hud_ks_rcbomb_drop
menu_div_pro
hud_arrow_down
emblem_bg_prestige_reset
ks_menu_background
menu_mp_elitedownload
menu_mp_cac_grad_stretch_add
hud_medals_share_drone
hud_medals_flyswatter
mc/mtl_t6_attach_optic_rmr_reticle
mc/mtl_t6_wpn_tablet
menu_div_pro_sub02_64
wager_yellow
emblem_bg_bo2_knife01
mc/mtl_t6_wpn_pda_lens
menu_mp_cr_bkg
emblem_bg_anti_air_iv
mc/mtl_t6_attach_optic_reflex_reticle_10
mc/mtl_t6_attach_optic_reflex_reticle_11
mc/mtl_weapon_camo_gold_alt
mc/mtl_t6_attach_optic_reflex_reticle_12
mc/mtl_t6_attach_optic_reflex_reticle_13
mc/mtl_t6_attach_optic_reflex_reticle_14
mc/mtl_t6_attach_optic_reflex_reticle_15
mc/mtl_t6_attach_optic_reflex_reticle_16
mc/mtl_t6_attach_optic_reflex_reticle_17
mc/mtl_t6_attach_optic_reflex_reticle_18
mc/mtl_t6_attach_optic_reflex_reticle_19
menu_mp_lobby_frame_circle
em_bg_flag_senegal
gfx_fxt_fx_emp_ring_wave
mc/com_glass_shattered_outside
compass_waypoint_targetneutral
mc/mtl_t6_wpn_turret_minigun_yellow
gfx_fxt_debris_gib_rock
em_bg_flag_benin
gfx_fxt_smk_gen_z200
em_bg_flag_slovakia
mc/mtl_veh_t6_fa38_display_glass_reflect
gfx_fxt_light_flare_phosphorous_z0
gfx_fxt_light_flare_phosphorous_z5
holo_0
holo_1
holo_2
holo_3
holo_4
holo_5
holo_6
holo_7
holo_8
holo_9
menu_mp_lobby_views_bg
em_bg_flag_nepal
listen_in
mc/mtl_veh_t6_v78_screens1
mc/mtl_veh_t6_v78_screens2
menu_div_gold_sub01
menu_div_gold_sub02
menu_div_gold_sub03
emblem_bg_prestige_concussion
hud_ks_talon_big
menu_mp_dockside_map_select
menu_camo_tiger_blue_pattern
emblem_bg_bo2_nuclear_killer
mc/mtl_weapon_camo_carbon_fiber_alt
lui_menu_tab_bkg
fullscreen_proximity_horizontal0
fullscreen_proximity_horizontal1
fullscreen_proximity_horizontal2
mc/mtl_t6_wpn_sniper_dsr50_scope
mc/mtl_weapon_camo_mystic_attach
emblem_bg_bo2_pl_sup_dom_tu
em_bg_ani_octane
emblem_bg_partyrock
menu_mp_bridge_map_select_final
mc/mtl_t6_wpn_sniper_ballista_level
mc/mtl_t6_wpn_ar_type95_thermal
menu_mp_weapons_as50
lui_bottomshadow
mc/mtl_t6_attach_optic_mms_lens
xenonbutton_start
hud_medals_wipeout
menu_mp_weapons_saritch_big
menu_camo_erdl_pattern
menu_mp_tab
menu_camo_mtx_dcoyote_32
gfx_fxt_smk_scattered
gfx_fxt_smk_light_add
menu_x2_xp_notify
wc/gfx_impact_concrete01
wc/gfx_impact_concrete02
wc/gfx_impact_concrete03
em_bg_flag_israel
bitchin_glint_reveal
mc/hud_outline_model
mtl_weapon_camo_wanted_solid
mc/mtl_t6_wpn_shotgun_shells_red
em_bg_flag_ecuador
compass_waypoint_capture
mc/mtl_t6_wpn_briefcase_bomb_lens
menu_camo_mtx_armor_32
hud_medals_closecall
mc/mtl_t6_attach_optic_rmr_lens
killstreak_tab_kill
xenon_controller_top
mc/mtl_t6_wpn_lmg_type95_drum
shadowcaster
hud_objective_rcbomb
menu_mp_weapons_svu
hud_shoutcasting_change_tab
loadscreen_mp_nightclub
gfx_fxt_exp_fire_z200
wc/gfx_bullethit_sand
menu_mp_weapons_tar21
emblem_bg_bo2_pl_gungame
mc/mtl_t6_wpn_launch_usrpg_alpha
ui_globe
emblem_bg_bo2_debris
menu_mp_nightclub_map_select_final
menu_codtv_icon_mychannel
em_bg_wpn_camo_an94
mc/mtl_t6_attach_gl_gp25
emblem_bg_dem_destroyer3
playlist_one_chamber
$blend_nodepth
gfx_laser_light
mc/mtl_t6_attach_optic_reflex
menu_mp_weapons_an94
menu_mp_weapons_fhj
em_bg_flag_zimbabwe
bitchin_twist
gfx_laser
mc/mtl_t6_wpn_ar_tavor_thermal
menu_div_pro_sub01_64
voice_on
em_bg_wpn_complete_skorpion
menu_camo_mtx_zulu_32
gfx_flamethrower_smoke_z100
emblem_bg_streak_vsat
progress_bar_fill
mc/mtl_c_usa_navy_head3_dlc1_thrm
menu_mp_weapons_ar57
menu_codtv_logo
em_bg_wpn_camo_svu
codtv_comment
menu_mp_lobby_cac_line_2_prong
fullscreen_dirt_bottom_b
menu_mp_villa_map_select
mc/mtl_c_usa_mcknight_dlc1_head_thrm
mc/mtl_t6_wpn_supply_drop_axis
mc/mtl_weapon_camo_bacon
gfx_fxt_smk_gen_z1_eo1
menu_mp_russianbase_map_select_big
ui_scrollbar_arrow_up_a
gfx_fxt_gas_flash_blue_z0
gfx_fxt_smk_light
scope_overlay_ballista
menu_mp_weapons_ballistic_knife
mc/mtl_t6_attach_bcpu_ui3d
menu_mp_duga_map_select_bw
menu_div_platinum_sub03_64
menu_mp_berlinwall_map_select
rank_icon_bg
em_bg_wpn_camo_fhj
emblem_bg_xray
menu_mp_weapons_insas_big
mc/mtl_t6_wpn_smg_pdw57_thermal
emblem_bg_dom_superior
menu_mp_missing_motd_spass
holo_30
holo_31
holo_32
holo_33
holo_34
hud_medals_takedown_ctf
holo_35
holo_36
menu_mp_cac_second_wc
holo_37
em_bg_flag_samoa
xenon_stick_turn
mp_hud_dot
code_warning_soundcpu
hud_medals_playmaker
compass_supply_drop_red
hud_ks_harpy_drop
em_bg_flag_iran
em_bg_prestige_1
em_bg_flag_iraq
em_bg_prestige_2
em_bg_prestige_3
em_bg_prestige_4
em_bg_prestige_5
menu_mp_lobby_circle
em_bg_prestige_6
em_bg_prestige_7
em_bg_prestige_8
em_bg_prestige_9
hud_mp_num_big_3_white
mc/mtl_t6_wpn_lmg_mk48_ammo_camo1
mc/mtl_t6_wpn_lmg_mk48_ammo_camo2
gfx_fxt_exp_fire
emblem_bg_relentless
mc/mtl_weapon_camo_carbon_fiber_attach
scope_overlay_specter
menu_mp_lobby_frame_outer_ingame
emblem_bg_blank
mc/gfx_impact_glass01
mc/gfx_impact_glass02
code_warning_scripterrors
menu_mp_weapons_riot_shield_big
mc/mtl_veh_t6_v78_interior_unlit
em_bg_wpn_attach_smaw
demo_play
mc/mtl_veh_t6_uav_drone
menu_mp_labc_map_select_final
playlist_ffa
menu_mp_lobby_scrollbar_main
bloom_apply_hq
emblem_bg_streak_warthog
em_bg_flag_pakistan
gfx_fxt_env_water_splash_add
hud_ks_ai_helicopter_drop
lui_overlay_combatload
mc/hud_outline_model_green
emblem_bg_dayofdead
menu_lobby_icon_facebook
hud_indicator_arrow
gfx_fxt_light_flare_halogen_z0
gfx_fxt_light_flare_halogen_z3
em_bg_flag_kiribati
mc/mtl_t6_wpn_lmg_hamr_parts
mc/mtl_t6_wpn_smg_peacekeeper_camo2
mc/mtl_t6_wpn_smg_peacekeeper_camo3
mc/mtl_t6_wpn_smg_peacekeeper_camo4
league_team_2_64
hud_obit_hind
emblem_bg_prestige_dclose
demo_step
mc/gfx_crater_blacktop
mc/mtl_t6_attach_belt_links
hud_medals_wasp
acog_10
acog_11
acog_12
acog_13
acog_14
acog_15
em_bg_flag_romania
acog_16
acog_17
acog_18
acog_19
hud_medals_forward_position
em_bg_wpn_complete_b23
menu_camo_mtx_snake
emblem_bg_dem_bomb_defuser3
menu_mp_dig_map_select_final
cac_mods_tact_knife
progress_bar_fg_small
white
menu_mp_nuked_map_select_bw
objective_line
hud_medals_bloodthirsty
menu_background_fade
menu_mp_vertigo_map_select_final
mc/mtl_t6_attach_optic_m32_lens
menu_mp_weapons_scar_big
mc/mtl_t6_attach_dbal_thermal
em_bg_wpn_attach_b23
menu_mp_cracked_map_select_bw
em_bg_wpn_attach_mk48
menu_mp_hydro_map_select_final
menu_zm_background_main
gfx_fxt_env_water_splash2
mc/mtl_t6_wpn_motion_sensor
rank_lcpl_128
em_bg_flag_cameroon
barrack_career_mastery
gfx_fxt_debris_spike
menu_camo_mtx_comics_32
hud_icon_m249saw_mounted
emblem_bg_prestige_perk2_coldblooded
menu_mp_nuked_map_select_final
hud_medals_wasphunter
hud_bounce_betty_256
mc/mtl_t6_wpn_ar_x95l_camo1
mc/mtl_t6_wpn_ar_x95l_camo2
mc/mtl_t6_wpn_ar_x95l_camo3
mc/mtl_t6_wpn_ar_x95l_camo4
menu_camo_mtx_breach
loadscreen_mp_mirage
gfx_fxt_smk_whisp_spiral_z120
em_bg_wpn_attach_an94
gfx_distortion_heat
loadscreen_mp_hijacked
feedbackreplace
mc/mtl_t6_wpn_lmg_hamr_parts_thermal
hud_compass_a10
mc/mtl_t6_attach_gl_ammo
compass_qrdrone
$additive_nodepth
gfx_fxt_debris_gib_dirt_pcloud_1
em_bg_flag_guinea
gfx_fxt_debris_gib_dirt_pcloud_2
gfx_fxt_debris_gib_dirt_pcloud_3
emblem_bg_dem_master3
gfx_fxt_debris_gib_dirt_pcloud_4
menu_mp_weapons_dsr1_big
dof_hq_final
emblem_bg_prestige_frag
emblem_bg_score_master_air
mtl_t6_wpn_pda_ui3d_background
emblem_bg_streak_hpm_kill
reticle_m203
mc/mtl_t6_wpn_shotty_ksg_camo1
mc/mtl_t6_wpn_shotty_ksg_camo2
mc/mtl_t6_wpn_shotty_ksg_camo3
mc/mtl_t6_wpn_shotty_ksg_camo4
gfx_dollycam_tracer
rank_pfc_128
menu_registered_symbol
menu_mp_studio_map_select_final
hud_anim_cobra
hud_medals_revenge
mc/mtl_weapon_camo_ghost_attach_1
mc/mtl_weapon_camo_ghost_attach_2
hud_ks_harpy_single_big
demo_forward_slow
ui_codpoints_symbol_32x32
kd_chart_green
menu_button_backing_highlight
menu_mp_lobby_cac_line_2_prong_left
menu_mp_lobby_bar_party
hud_mp_num_big_8_white
mp_hud_deployed
menu_mp_la_map_select_final
menu_mp_lobby_customgame
menu_mp_cac_wcard_fill
bitchin_mosaic
barrack_prestige_perks
em_bg_flag_liechtenstein
emblem_bg_dem_veteran3
hud_medals_nuclear
hud_ctf_flag_icon_green
cac_mods_laser
perk_scavenger
em_bg_wpn_complete_rpg
hud_medals_aggression_hq
menu_mp_cac_second_hl
hud_mp_vis_ks_dpad_box_back
emblem_bg_ruthless
menu_mp_bonuscard_two_tacticals
emblem_bg_emp_v
gfx_fxt_smk_gen_z3
playlist_standard
menu_mp_theater_question
loadscreen_mp_drone
wager_green
emblem_bg_streak_swarm
mc/mtl_t6_attach_optic_holo_thermal
mc/mtl_t6_wpn_pda
rank_bgen
gfx_fxt_env_leaves_gib
em_bg_wpn_attach_rpg
flag_germany
emblem_bg_career_mastery_assignment
emblem_bg_bo2_pl_sup_gungame
mc/mtl_t6_wpn_sniper_ballista_lens
em_bg_flag_timor_leste
lui_weapons_cac
mc/global_invisible_missile_clip
lui_overlay_overview
mc/mtl_t6_wpn_sniper_xpr50_scope_camo2
menu_mp_cairo_map_select_bw
emblem_bg_kills_sniper
playlist_war
anaglyph
com_sup_box
hud_mp_firerate_bolt
com_sup_no_select
emblem_bg_bo2_pl_sup_kc
mc/gfx_bullethit_sand
mc/mtl_t6_wpn_sniper_ballista_scope_thermal
menu_mp_castaway_map_select_final
gfx_fxt_debris_clump_rocks_ds128
league_team_1_64
rank_prestige01
emblem_bg_streak_dogs
rank_prestige02
rank_prestige03
rank_prestige04
rank_prestige05
rank_prestige06
rank_prestige07
rank_prestige08
rank_prestige09
emblem_bg_ctf_defender
mp_hud_armed
mc/mtl_t6_wpn_sniper_ballista_sights
hud_medals_scrapped
lui_soldier
menu_mp_havoc_map_select_final
hud_medals_oneshot_onekill
compass_supply_drop_white
emblem_bg_prestige_sfighter
mc/mtl_veh_t6_v78_vtol_friend
mc/mtl_t6_wpn_c4_detonator
wc/gfx_crater_blacktop
generic_filter_model_outline
mtl_weapon_camo_zombies_solid
mc/mtl_t6_wpn_launch_smaw_camo2
mc/mtl_t6_wpn_launch_smaw_camo3
mc/mtl_t6_wpn_launch_smaw_camo4
mc/mtl_t6_wpn_launch_smaw_camo5
hud_grenadepointer
emblem_bg_streak_warmachine
hud_ks_predator_menu
gfx_fxt_exp_glow
mc/mtl_t6_wpn_turret_minigun_red
gfx_fxt_smk_tendril
gfx_fxt_spark_anim_blink
em_bg_flag_chad
hud_momentum_meter_preview
gfx_fxt_light_incandescent_eo20_z20
hud_ks_m32_drop
fullscreen_dirt_left
em_bg_flag_barbados
gfx_fxt_light_flare_phosphorous
gfx_fxt_smk_scattered_z80
mc/mtl_t6_wpn_pistol_b2023r
menu_div_pro_sub01
menu_div_pro_sub02
menu_div_pro_sub03
em_bg_flag_belize
menu_white_line_faded
waypoint_circle_arrow
codtv_camera
hud_mp_ks_arrow
mtl_weapon_camo_comics
menu_mp_fileshare_custom
gfx_fxt_fire_flame_vert_d_blnd
hud_ks_predator_256
menu_mp_weapons_srm
gfx_fxt_debris_clump_dirt_ds32
emblem_bg_mega_killer
mc/mtl_veh_t6_rcxd_extra_bits
em_bg_flag_united_kingdom
menu_div_iron_64
em_bg_wpn_complete_saiga
emblem_bg_tdm_veteran
menu_mp_cac_tact_fill
playlist_sharpshooter
lui_bracket
hud_ks_littlebird_256
hud_medal_burst_green
em_bg_flag_syria
wc/gfx_impact_fabric
menu_mp_radiation_map_select_final
mc/mtl_t6_wpn_launch_fhj18_thermal
emblem_bg_aqua
bloom_downsample
menu_mp_lobby_cac_line_3_prong
hud_medals_backfire
hud_medals_hpm
playlist_core
rank_pfc
mc/mtl_veh_t6_cuav_thermal
gfx_fxt_env_electric_arc1_add_eo2
menu_mp_lobby_frame_line
ui_skin_black
hud_obit_talon
mc/mtl_weapon_camo_armor_1
mc/mtl_weapon_camo_armor_2
mc/mtl_weapon_camo_armor_3
em_bg_flag_malta
mc/mtl_t6_wpn_lmg_type95_thermal
menu_mp_party_ease_icon
logo
emblem_bg_equip_smoke
fake_emblem
streaming_temp_image_10
streaming_temp_image_11
streaming_temp_image_12
streaming_temp_image_13
streaming_temp_image_14
streaming_temp_image_15
streaming_temp_image_16
streaming_temp_image_17
hud_mp_firerate_free
streaming_temp_image_18
streaming_temp_image_19
em_bg_flag_maldives
menu_mp_concert_map_select_final
mc/mtl_t6_wpn_sniper_svu_scope_thermal
code_warning_gamestate
menu_mp_weapons_judge
mc/mtl_t6_wpn_shield
hud_grenade_launcher
hud_mp_num_big_4_white
em_bg_wpn_camo_dsr
gfx_fxt_debris_clump_dirt
hud_ks_reaper_256
mc/mtl_t6_wpn_shotty_srm1216_thermal
webm_720p_2
webm_720p_3
webm_720p_4
webm_720p_5
webm_720p_6
menu_mp_lobby_nva
webm_720p_7
webm_720p_8
webm_720p_9
gfx_fxt_fire_flame_vert_e_z0
gfx_flamethrower_smoke
objpoint_default
playlist_wager_highroller_bw
mc/mtl_t6_wpn_trophy_system
cac_mods_dual_band
compassping_enemydirectional
shellshock
hud_medals_destroyed_remote_mortar
emblem_bg_bo2_pl_demo
mp_hud_reticle_side_round
code_warning_snapshotents
xenonbutton_dpad_ud
postfx_dof
xenonbutton_dpad_up
mc/mtl_t6_wpn_hatchet_retrieve
menu_mp_lobby_token_64
code_warning_fps
mc/mtl_weapon_camo_carbon_fiber_alt_attach
gfx_fxt_light_flare_phosphorous_z120
mc/railroadtrack_side
menu_mp_cac_wcard_wc
mc/mtl_weapon_camo_dragon_alt_1
mc/mtl_weapon_camo_dragon_alt_2
mc/mtl_weapon_camo_dragon_alt_3
hud_mp_vis_right_lower_white
rank_prestige12_128
mc/mtl_weapon_camo_dragon
voice_off_xboxlive
debug_zbuffer
mc/mtl_t6_wpn_ar_hk416_grip
em_bg_flag_equitorial_guinea
emblem_bg_bo2_camo_grey01
em_bg_flag_tunisia
mc/mtl_t6_wpn_ar_xm8_camo1
mc/mtl_t6_wpn_ar_xm8_camo2
mc/mtl_t6_wpn_ar_xm8_camo3
hud_medals_destroyed_sentry_gun
emblem_bg_unforgiving
hud_horizontal_compass_white
gfx_fxt_smk_puff_z200_ds255
emblem_bg_sensor_v
mc/mtl_veh_t6_drone_tank_wheels
emblem_bg_prestige_perk1_lweight
emblem_bg_att_fast_mag
hud_ks_u2_spyplane_drop
mc/mtl_t6_attach_optic_rangefinder_reticle
mc/mtl_veh_t6_a10f_alt
compassping_enemysatellite
menu_mp_nuked_map_select_big
rank_com_128
combat_tab_knife
bloom_downsample_hq
lui_leftshadow
hud_icon_sticky_grenade
mc/mtl_weapon_camo_mystic_alt
hud_mp_vis_left_lower
gfx_fxt_smk_def_2_z120_ds128
hud_shoutcasting_notify_bomb
emblem_bg_bo2_metal_camo01
fonts/distfont_glow
mc/mtl_t6_veh_drone_quad_rotor_blades
gfx_fxt_bio_bloodburst
gfx_bullet
mc/mtl_t6_attach_sniper_silencer1
menu_mp_weapons_kriss_big
mc/mtl_c_gen_insidemouth
line_vertical
mc/mtl_t6_wpn_shield_glass
compass_objpoint_helicopter
menu_camo_artofwar_pattern
ssao_reconstruct_csz
damage_feedback_flak
menu_codtv_icon_trending
mc/mtl_t6_attach_optic_rmr_reticle_20
mc/mtl_t6_attach_optic_rmr_reticle_21
mc/mtl_t6_attach_optic_rmr_reticle_22
mc/mtl_t6_attach_optic_rmr_reticle_23
mc/mtl_t6_attach_optic_rmr_reticle_24
menu_mp_weapons_ar57_big
mc/mtl_t6_attach_optic_rmr_reticle_27
mc/mtl_t6_attach_optic_rmr_reticle_28
mc/mtl_t6_attach_optic_rmr_reticle_29
rank_prestige11_128
small_blur
mc/mtl_c_usa_secserv_sam_head_thermal
mtl_weapon_camo_mtx3_aqua_alt
gfx_fxt_debris_wind_ash_gr
hud_ks_m32_256
hud_grenadethrowback
compass_map_color_underlay
menu_mp_weapons_svu_big
em_bg_flag_namibia
nottalkingicon
menu_mp_nightclub_map_select
hud_mp_num_big_9_white
gfx_fxt_smk_puff_z2
gfx_fxt_smk_puff_z5
menu_random_map_select_final
menu_mp_havoc_map_select_bw
mc/mtl_t6_wpn_lmg_lsat_thermal
emblem_bg_snd_vanquisher
mc/mtl_gen_eye_iris_thermal
em_bg_flag_slovenia
hud_medals_share_choppergunner
mc/mtl_player_icon
hud_ks_microwave_turret_menu
menu_camo_bo2_elite_pattern
gfx_fxt_fire_flame_vert_d_z1
emblem_bg_pg_gun_game
playlist_dlc_revolution
emblem_bg_bo2_dogtags01
em_bg_flag_cote_divoire
hud_ks_ai_tank_drop
mtl_weapon_camo_ukpunk_solid
menu_mp_weapons_type95
emblem_bg_bo2_mt_vanquish
hud_medals_stealthheli
rank_col_128
gfx_fxt_debris_plume_dirt_z5
mc/mtl_t6_attach_optic_acog_reticle_10
mc/mtl_t6_attach_optic_acog_reticle_11
mc/mtl_t6_attach_optic_acog_reticle_12
mc/mtl_t6_attach_optic_acog_reticle_13
mc/mtl_t6_attach_optic_acog_reticle_14
mc/mtl_t6_attach_optic_acog_reticle_15
mc/mtl_t6_attach_optic_acog_reticle_16
mc/mtl_t6_attach_optic_acog_reticle_17
mc/mtl_t6_attach_optic_acog_reticle_18
mc/mtl_t6_attach_optic_acog_reticle_19
hud_status_connecting
menu_mp_title_screen
emblem_bg_laid_to_rest
hud_mp_num_big_0_white
hudicon_ctf_flag_carry_isa
gfx_fxt_light_ray_spread_solid
hud_medals_destroyed_cuav
menu_zm_nuked_map
shellshock_flashed
menu_lobby_name_highlight
em_bg_flag_bolivia
mc/mtl_t6_attach_sniper_fastmag
gfx_fxt_fx_distortion_heat_scale5
cac_mods_suppressor
hud_ks_rcbomb_big
menu_mp_cac_second_fill
em_bg_wpn_complete_crossbow
motionblurradial
gfx_fxt_debris_plume_smoke0_ds128
mc/mtl_t6_wpn_smg_pdw57_camo1
mc/mtl_t6_wpn_smg_pdw57_camo2
gfx_fxt_gas_flash_eo2_z2
mc/mtl_t6_wpn_smg_pdw57_camo3
mc/mtl_t6_wpn_smg_pdw57_camo4
gfx_fxt_gas_flash_blnd
waypoint_circle_arrow_yellow
mc/mtl_t6_attach_optic_acog_shade
menu_div_semipro_64
menu_mp_cac_wcard_hl
hud_ks_player_helicopter
menu_motd_votecamo_3b
gfx_fxt_smk_puff_ds192
hudscoreboardscroll_upkey
dualoptic_up_0
mc/mtl_t6_attach_optic_holo_reticle_10
mc/mtl_t6_attach_optic_holo_reticle_11
mc/mtl_t6_attach_optic_holo_reticle_12
mc/mtl_t6_attach_optic_holo_reticle_13
mc/mtl_t6_attach_optic_holo_reticle_14
mc/mtl_t6_attach_optic_holo_reticle_15
dualoptic_up_9
mc/mtl_t6_attach_optic_holo_reticle_16
mc/mtl_t6_attach_optic_holo_reticle_17
mc/mtl_t6_attach_optic_holo_reticle_18
mc/mtl_t6_attach_optic_holo_reticle_19
menu_div_gold_64
hud_obit_pegasus
barrack_optics_icon
hud_ks_minigun_menu
gfx_fxt_light_ray_search_z1
menu_camo_mtx_octane
gfx_fxt_light_ray_search_z3
em_bg_flag_somalia
gfx_fxt_smk_trail
mp_hud_signal_strong
mc/mtl_veh_t6_air_fa38_cockpit_low
mc/mtl_drone_overwatch_body
emblem_bg_career_mastery_primary
menu_mp_weapons_ballista
emblem_bg_kcon_den
menu_black_line
em_bg_wpn_complete_mp7
ui_button_xenon_rstick_anim_d
ui_button_xenon_rstick_anim_l
menu_mp_lobby_none_selected
ui_button_xenon_rstick_anim_r
ui_button_xenon_rstick_anim_u
gfx_fxt_light_hot_z400
mc/mtl_veh_t6_uav_thermal
mc/mtl_weapon_camo_diamond_alt
emblem_bg_mil
menu_mp_lobby_tropas
mc/mtl_weapon_camo_armor_alt_attach
gfx_fxt_smk_gen_z40_gr
hud_momentum_meter
motionblurframebased
em_bg_flag_japan
em_bg_wpn_attach_mp7
hud_medals_badass01
gfx_fxt_env_water_foam_light_ds128
menu_mp_weapons_qcw
mc/mtl_t5_weapon_crossbow
digital_noise_filter_remote_mortar
hud_medals_share_aq10escort
hud_mp_vis_ks_dpad_bracket
mc/mtl_weapon_camo_armor_alt
dof_hq_blur
button_left_mouse
mc/mtl_weapon_camo_diamond_attach_1
hud_medals_destroyed_missile_swarm
menu_mp_weapon_lvl
hud_ks_microwave_turret_256
hud_ks_heli_gunner
emblem_bg_ultra_killer
em_bg_flag_chile
em_bg_flag_armenia
wc/gfx_impact_metal01
wc/gfx_impact_metal02
wc/gfx_impact_metal03
hud_hatchet
hud_lui_scorefeed_glow
menu_mp_popup_bottom
gfx_fxt_debris_clump_rocks
emblem_bg_streak_cuav_kill
em_bg_flag_trinidad_tobago
menu_mp_firingrange_map_select
menu_mp_weapons_an94_big
mc/mtl_t6_wpn_drop_box
hud_obit_cobra
menu_camo_mtx_comics
emblem_bg_career_mastery_sniper
emblem_bg_bo2_mt_superior
em_bg_wpn_camo_ballistic
black
barrack_primary_icon
hud_mp_num_big_5_white
em_bg_wpn_camo_skorpion
em_bg_wpn_complete_lsat
lock
mc/mtl_flag_allies_1
mc/mtl_flag_allies_2
mc/mtl_flag_allies_3
compass_map_color_overlay
hud_icon_claymore_256
mc/mtl_t6_wpn_turret_sentry_gun_ammo
xenonbutton_lb
ui_line
xenonbutton_ls
xenonbutton_lt
hud_ks_ai_helicopter_256
gfx_fxt_env_dust_mote_eo20
menu_mp_lobby_aar_icons_skull
em_bg_flag_tanzania
mtl_fx_hydro_water_dam
emblem_bg_ghost
gfx_fxt_ui_arrow
menu_mp_radiation_map_select_big
mc/mtl_t6_attach_optic_reflex_reticle_40
gfx_fxt_smk_gen_add_z5
gfx_fxt_fire_anim_lick
wc/gfx_impact_wood01
wc/gfx_impact_wood02
wc/gfx_impact_wood03
menu_codtv_icon_feed
gfx_fxt_smk_def_2_z120
hud_medals_share_wasp
em_bg_wpn_complete_vector
mc/mtl_weapon_camo_bacon_alt
menu_mp_firingrange_map_select_final
gfx_fxt_debris_wind_ash
mc/mtl_p6_dogtags
compass_vtol
gfx_fxt_env_water_splash
emblem_bg_career_mastery_secondary
hud_icon_sticky_grenade_256
em_bg_wpn_attach_chicom
hud_ks_harpy_single_menu
mc/missing_fx
ui_holotable_grid
menu_div_iron_sub02_64
menu_sp_cac_single_big_dip
mc/mtl_weapon_camo_cybertron_1
em_bg_wpn_attach_shield
mc/mtl_weapon_camo_cybertron_2
mc/mtl_weapon_camo_cybertron_3
mc/mtl_weapon_camo_cybertron_4
hud_obit_rcbomb
menu_select_highlight
em_bg_flag_italy
hud_icon_stuck_arrow
mc/mtl_weapon_camo_mystic_alt_attach_1
mc/mtl_weapon_camo_mystic_alt_attach_2
menu_mp_random_map_select_big
em_bg_wpn_attach_five_seven
emblem_bg_prestige_perk1_flak
gfx_fxt_debris_clump_rocks_ds16
menu_mp_dockside_map_select_bw
gfx_fxt_light_ray_spread
emblem_bg_bo2_career_wins
hud_obit_exploding_barrel
gfx_fxt_smk_def_0_ds128
mc/mtl_weapon_camo_diamond_1
mc/mtl_weapon_camo_diamond_2
mc/mtl_weapon_camo_diamond_3
hud_medals_triplekill
hud_obit_predator
mouse_edit
hud_mp_vis_left_lower_back
mtl_weapon_camo_mango
emblem_bg_backfire
mc/mtl_t6_wpn_sniper_dsr50_camo2
gfx_fxt_light_hot_z200
menu_next_prev_arrow_black
hud_medals_default
menu_mp_cac_gren_fill
menu_mp_weapons_fnp45_big
hint_mantle
menu_div_iron_sub01
menu_div_iron_sub02
menu_div_iron_sub03
menu_livestream_tower
menu_mp_crisis_map_select_final
compassping_enemy_diamond_bottom
em_bg_wpn_complete_ballistic
gfx_fxt_superflare_mp_la_sun1
em_bg_wpn_camo_msmc
mc/mtl_t6_wpn_turret_sentry_gun_ammo_yellow
hud_ks_talon
webm_720p_10
emblem_bg_tdm_superior
playlist_team_tactical
gfx_fxt_gas_flash
menu_attribute_bar_part
mc/mtl_weapon_camo_zmb_dlc2_1
mc/mtl_weapon_camo_zmb_dlc2_2
mc/mtl_weapon_camo_zmb_dlc2_3
em_bg_flag_yemen
rank_majgen
hud_medals_share_droneswarm
mc/mtl_t6_wpn_ar_saritch_camo1
mc/mtl_t6_wpn_ar_saritch_camo2
mc/mtl_t6_wpn_ar_saritch_camo3
emblem_bg_weapon_flasher
menu_mp_pip_green
compass_waypoint_bomb
compass_supply_drop_black
menu_zm_map_nuked_blit_nuked
gfx_fxt_light_incandescent_eo5_z3
hudscoreboardscroll_downarrow
mc/mtl_t6_wpn_lmg_lsat_camo1
mc/mtl_t6_wpn_lmg_lsat_camo2
mc/mtl_t6_wpn_lmg_lsat_camo3
mc/mtl_t6_wpn_lmg_lsat_camo4
emblem_bg_att_las_sight
spectator_reticle_status
mc/mtl_t6_wpn_ar_hk416_grip_thermal
emblem_bg_pda_v
hudscoreboardscroll_uparrow
menu_mp_array_map_select_big
menu_camo_mtx_afterlife_32
frame_alpha_debug
emblem_bg_career_mastery_gametype
hud_obit_mortar
gfx_fxt_smk_def_1_z200
hud_ks_minigun_256
menu_lobby_title_strip
menu_codtv_icon_staff
menu_mp_lobby_scrollbar_block
killiconheadshot
menu_mp_star_rating_empty
emblem_bg_zombies
hud_ks_predator_big
emblem_bg_breach
gfx_fxt_light_flare_halogen_eo4_z2
hud_ks_planemortar
menu_codtv_icon_shared
menu_mp_berlinwall_map_select_big
menu_mp_cairo_map_select_final
hud_status
ui_arrow_right
mc/mtl_t6_attach_optic_dualband
menu_mp_weapons_grim_reaper
hud_medals_completed_match
hud_medals_sticks_switchhitter
hud_medals_savior
gfx_fxt_env_water_wake_heli
hud_mp_num_big_1_white
em_bg_flag_micronesia
em_bg_wpn_camo_chicom
gfx_fxt_smk_gen_z60
hud_ks_littlebird_big
hud_dpad_emp
emblem_bg_prestige_perk3_tacmask
hud_ks_dogs_drop
wc/gfx_impact_blood_spatter01
wc/gfx_impact_blood_spatter02
wc/gfx_impact_blood_spatter03
emblem_bg_bo2_top_3_player
menu_mp_cac_attach_line
menu_div_iron_sub01_64
mc/mtl_t6_attach_optic_mms_reticle
emblem_bg_prestige_perk2_scavenger
em_bg_flag_bulgaria
gfx_flamethrower_smoke_add
gfx_fxt_debris_gib_metal_ds0
menu_mp_discovery_map_select_final
cac_mods_dual_clip
em_bg_wpn_attach_scar
hud_medals_share_mgl
gfx_fxt_fire_flame_vert_c
gfx_fxt_fire_flame_vert_d
gfx_fxt_fire_flame_vert_e
bloom_blur_x
bloom_blur_y
bloom_apply
mc/mtl_german_shepherd
rank_mgysgt
menu_camo_mtx_zulu
mc/mtl_weapon_camo_gold
emblem_bg_pg_oic
mc/mtl_veh_t6_v78_guns_thermal
em_bg_wpn_attach_ballistic_tu
em_bg_wpn_complete_m8a1
hud_mp_firerate_pump
hud_hatchet_256
mtl_weapon_camo_graffiti
em_bg_wpn_attach_type25
apply_lut2d
mc/mtl_c_gen_mp_datapad
menu_mp_hanoi_map_select_final
statmon_warning_tris
mc/mtl_weapon_camo_dragon_attach
create_lut2dv
hudscoreboardscroll_downkey
compassping_friendlyyelling_mp
flag_poland
em_bg_flag_turkey
mc/mtl_t6_wpn_tac_insert
gfx_fxt_bio_bloodtrail_ds64
hud_obit_knife
compassping_enemysatellite_diamond
mc/gfx_impact_metal01
mc/gfx_impact_metal02
mc/gfx_impact_metal03
emblem_bg_return_to_sender
hud_ks_reaper_big
hud_ks_m32
compass_map_flicker
hud_arrow_right
hud_ks_emp_menu
gfx_fxt_env_water_ripple
ui_blur
mc/mtl_weapon_camo_gold_attach
mc/mtl_t6_wpn_sniper_ballista_sights_thermal
emblem_bg_snd_veteran
menu_mp_lobby_bar_name
hud_obit_turret
compass_map_color_underlay2
emblem_slug_0
emblem_slug_1
emblem_slug_2
gfx_fxt_env_water_splash2_z10
emblem_slug_3
emblem_slug_4
emblem_slug_5
emblem_slug_6
emblem_slug_7
emblem_slug_8
emblem_slug_9
mc/mtl_t6_attach_optic_rangefinder_reticle2
net_new_animation
emblem_bg_streak_vtol
emblem_bg_ctf_veteran
hud_momentum_meter_streak
mc/mtl_t6_wpn_briefcase_bomb_keypad
hud_uav_radio
perk_tactical_mask
mc/mtl_t6_wpn_lmg_lsat_ammo_counter
perk_times_two
xenon_stick_move_turn
mc/lambert1
mc/mtl_t6_attach_rmr_thermal
hud_xm25_targ
spectator_1st_star
mc/mtl_t6_wpn_lmg_mk48_thermal
emblem_bg_bo2_pl_hardpoint
compass_waypoint_capture_a
compass_waypoint_capture_b
compass_waypoint_capture_c
em_bg_wpn_complete_msmc
menu_mp_bonuscard_primary_gunfighter
mp_hud_cluster_status
menu_mp_weapons_sig556_big
lui_havana_map_vote
gfx_fxt_smk_light_z1_eo1
menu_vis_bracket_small01
ui_skin_green
emblem_bg_kcon_masterl
emblem_bg_bo2_hc_vanquish
xenonbutton_back
menu_div_silver_sub01
menu_div_silver_sub02
menu_div_silver_sub03
mc/mtl_t6_wpn_lmg_lsat_ammo_thermal
rank_prestige07_128
hud_medals_bankshot
mc/mtl_fx_shell
em_bg_flag_guinea_bissau
barrack_ass_bootcamp
em_bg_flag_malaysia
mc/mtl_flag_green
fullscreen_dirt_bottom
em_bg_wpn_camo_mcs
mc/mtl_t5_veh_rcbomb_allies
hud_mp_num_big_6_white
emblem_bg_equip_stuck
hud_obit_huey
mouse_click
hud_medals_takedown
menu_scroll_arrow
dof_hq_final_extra
hud_medals_won_match
hud_obit_hatchet
menu_mp_weapons_kard
perk_flak_jacket_256
gfx_fxt_exp_glow_z60
hud_obit_thawk
gfx_fxt_fx_raygun_ring
emblem_bg_streak_lodestar
barrack_gamemode_icon
hud_ks_littlebird_menu
mc/mtl_t6_wpn_smg_scorpion_camo1
mc/mtl_t6_wpn_smg_scorpion_camo2
mc/mtl_t6_wpn_smg_scorpion_camo3
mc/mtl_t6_wpn_smg_scorpion_camo4
mc/mtl_t6_attach_tritium_red
menu_mp_cac_grid_pattern
emblem_bg_kills_score_streaks
hud_ks_dogs_256
gfx_fxt_debris_clump
voice_on_xboxlive
perk_lightweight
mc/mtl_t6_wpn_pistol_kard_thermal
hud_ks_u2_spyplane_256
compass_waypoint_defend
menu_mp_lobby_icon_screenshot
rank_ltgen
mc/mtl_t6_wpn_smg_mp7_camo1
mc/mtl_t6_wpn_smg_mp7_camo2
mc/mtl_t6_wpn_smg_mp7_camo3
mc/mtl_t6_wpn_smg_mp7_camo4
mc/mtl_veh_t6_air_fa38_glass_outside_low
mc/mtl_mh_6_little_bird_blade_spin
menu_mp_lobby_icon_class_set
playlist_demolition
playlist_map
shadowclear
em_bg_wpn_camo_type25
ui_cursor
codtv_add
emblem_bg_bo2_pl_sup_ffa
emblem_bg_pap
mc/mtl_t6_wpn_shield_light_fx
em_bg_flag_oman
hud_ks_m32_big
gfx_fxt_fire_flame_base_01
hud_mp_xm25_overlay
mc/mtl_t6_attach_optic_reflex_reticle_01
mc/mtl_t6_attach_optic_reflex_reticle_02
menu_prestige_unlock_token_64
mc/mtl_t6_attach_optic_reflex_reticle_03
mc/mtl_t6_attach_optic_reflex_reticle_04
mc/mtl_t6_attach_optic_reflex_reticle_05
mc/mtl_t6_attach_optic_reflex_reticle_06
mc/mtl_t6_attach_optic_reflex_reticle_07
mc/mtl_t6_attach_optic_reflex_reticle_08
mc/mtl_t6_attach_optic_reflex_reticle_09
cac_mods_rangefinder
bitchin_grid
gfx_fxt_bio_bloodburst_b_ds64
emblem_bg_pg_sticks_stones
loadscreen_mp_hydro
hud_ks_spy_sat_256
mc/mtl_weapon_camo_dragon_alt_attach_1
mc/mtl_weapon_camo_dragon_alt_attach_2
$ps3_aadownsample
menu_camo_mtx_breach_32
em_bg_flag_mauritania
emblem_bg_bo2_pl_sharpshooter
gfx_fxt_spark_anim_blink_eo2
em_bg_flag_greece
emblem_bg_trophy_v
mc/global_invisible_bullet_clip_wood
compassping_firstplace
emblem_bg_kills_shotgun
gfx_fxt_smk_anim_cloud
gfx_fxt_smk_def_1_ds128
em_bg_flag_south_korea
menu_mp_duga_map_select_big
playlist_combat_training_bc
em_bg_flag_jamaica
gfx_fxt_smk_anim_cloud_ds_255
mc/mtl_veh_t6_rcxd_alt
hud_medals_offense
em_bg_flag_gambia
emblem_bg_four_piece
voice_off_mute_xboxlive
gfx_fxt_ui_tickring
menu_div_gold
menu_mp_magma_map_select_final
mc/mtl_t6_wpn_turret_ads_alpha_yellow
emblem_bg_sticky
mc/mtl_t6_wpn_bouncing_betty
hud_ks_microwave_turret_drop
menu_camo_mtx_punk_32
menu_camo_carbon_pattern
hud_lui_meter_bracket
mtl_fx_hydro_water_dam2
mtl_fx_hydro_water_dam3
mtl_fx_hydro_water_dam4
mtl_fx_hydro_water_dam5
mtl_fx_hydro_water_dam6
mc/mtl_t6_attach_gl_m320
mc/mtl_t6_attach_optic_holo
hudicon_ctf_flag_carry_seals
hud_medals_lodestar
hud_medals_humiliation
playlist_sp_recr
hud_medals_buddy01
emblem_bg_score_master_return
mc/mtl_t6_veh_drone_quad_rotor_body2
mc/mtl_veh_t6_air_fa38_decals_02_low
menu_mp_popup_stretch
em_bg_flag_poland
menu_livestream_icon_live
hud_shoutcasting_time_box
gfx_fxt_smk_light_z10
hud_medals_deadeye
gfx_fxt_fx_distortion_ring_light
rank_lt_128
menu_camo_mtx_dayofdead
menu_lobby_icon_xboxlive
emblem_bg_zulu
menu_mp_havoc_map_select_big
emblem_bg_bo2_hc_superior
$default
mc/mtl_mh_6_little_bird_body_thermal
menu_camo_mtx_mil
mc/mtl_weapon_camo_toxic
rank_sgt_128
menu_mp_villa_map_select_big
mtl_t6_attach_optic_rangefinder_ui3d_background
gfx_fxt_smk_trail_tracer
em_bg_flag_afghanistan
mc/mtl_hellfire_missile_alpha
mc/mtl_veh_t6_overwatch_thermal
hud_ks_spy_sat
emblem_bg_streak_agr
gfx_fxt_spark_single
emblem_bg_sit_aware
hud_ks_heli_gunner_menu
gfx_fxt_debris_clump_dirt_ds64
menu_mp_mountain_map_select_final
pc_keyboard_left
menu_mp_havoc_map_select
rank_prestige03_128
reticle_side_small
mc/mtl_weapon_camo_gold_1
barrack_prestige_combat_eff
mc/mtl_weapon_camo_gold_2
barrack_ss_return
mc/mtl_weapon_camo_gold_3
menu_mp_bonuscard_glow
menu_vis_carousel_pip
mc/mtl_t6_wpn_turret_sentry_gun_base_yellow
menu_camo_mtx_dmh_32
hud_ks_minigun_drop
em_bg_flag_niger
em_bg_wpn_attach_tac45
gfx_fxt_smk_def_1_z80_gr
loadscreen_mp_slums
gfx_fxt_debris_gib_grass_sngl
hud_medals_relentless
mc/mtl_t6_wpn_smg_msmc_camo1
mc/mtl_t6_wpn_smg_msmc_camo2
mc/mtl_t6_wpn_smg_msmc_camo3
mc/mtl_t6_wpn_smg_msmc_camo4
hud_tact_insert
menu_mp_weapons_baretta_big
hud_medals_warthog
emblem_bg_bo2_pl_sup_oic
menu_camo_mtx_cybertron_32
menu_mp_tab_frame_inner
menu_mp_skate_map_select_final
em_bg_flag_sri_lanka
gfx_fxt_smk_whisp
hud_trophy_system_256
mc/mtl_t6_attach_optic_acog_lens
mc/mtl_weapon_camo_diamond_alt_attach_1
mc/mtl_weapon_camo_bacon_alt_1
mc/mtl_weapon_camo_bacon_alt_2
mc/mtl_weapon_camo_bacon_alt_3
loadscreen_mp_dig
compassping_friendlyfiring_mp
hud_objective_full_circle_meter
mc/mtl_clan_tag_world
mtl_weapon_camo_mtx3_zulu_alt
emblem_bg_score_master_ground
hud_ks_littlebird
emblem_bg_snd_bomb_defuser
waypoint_circle_arrow_red
menu_camo_mtx_mil_32
em_bg_flag_swaziland
hud_ks_microwave_turret_big
gfx_fxt_env_water_splash2_ds64_z10
compass_map_color_overlay2
gfx_fxt_smk_light_old_z20
emblem_bg_dragonfire
lui_arraybkg
hud_status_dead
menu_mp_background_main2
em_bg_flag_grenada
compass_lodestar
gfx_fxt_debris_plume_smoke
em_bg_flag_faroe_islands
mc/mtl_weapon_camo_zombies_attach
gfx_fxt_ui_heli_reticule
hud_medals_share_deathmachine
mc/mtl_t6_wpn_pistol_b2023r_thermal
ui_skin_urban_rus
spectator_reticle_streak
emblem_bg_prestige_perk1_hline2
gfx_fxt_light_hot_add_eo5
menu_mp_background_main
holo_20
holo_21
holo_22
hud_lui_ammo_shadow
holo_23
holo_24
holo_25
holo_26
holo_27
holo_28
holo_29
mc/mtl_veh_t6_rcxd_antenna_shadow
bloom_apply_thermal
barrack_ss_ground
hud_medals_roadrage
gfx_fxt_light_ray_spread_no_gr
mc/mtl_t6_wpn_c4_detect
emblem_bg_prestige_tazer
menu_camo_diamond_pattern
menu_motd_survey
mc/mtl_t6_wpn_sniper_xpr50_scope
hud_ks_ai_helicopter_big
mc/mtl_t6_wpn_minigun_ammo_noalpha
playstation_store_ingame_logo
party_notready
em_bg_flag_zambia
em_bg_flag_mexico
mc/mtl_t6_wpn_shotty_870mcs_camo1
mc/mtl_t6_wpn_shotty_870mcs_camo2
mc/mtl_t6_wpn_shotty_870mcs_camo3
em_bg_flag_sao_tome_principe
mtl_weapon_camo_benjamins_solid
mc/mtl_t6_wpn_knife_base
menu_mp_drone_map_select_bw
postfx_color
barrack_ass_killer
hud_medals_hack_hackathon
hud_medals_dronehunter
gfx_fxt_env_water_splash_z10
mc/gfx_impact_plaster01
mc/gfx_impact_plaster02
mc/mtl_t6_attach_optic_rangefinder
em_bg_flag_djibouti
twitch_logo
hud_ctf_flag_icon_red
loadscreen_mp_takeoff
mtl_weapon_camo_roxann
menu_mp_cac_caro_perk_hl
mc/mtl_sidewinder_missile
menu_mp_cac_caro_weapon_line
hud_ks_straferun
hud_anim_littlebird
flag_japan
mtl_weapon_camo_partyrock
mc/mtl_fx_shell_alpha
hud_ks_harpy_single_drop
em_bg_flag_kazakhstan
mc/mtl_p_glo_scavenger_pack_02_obj
menu_mp_nt_motd_big
menu_div_platinum_sub01
menu_div_platinum_sub02
menu_mp_socotra_map_select_bw
menu_div_platinum_sub03
em_bg_flag_nigeria
emblem_bg_streak_dragonfire
mc/mtl_t6_wpn_grenade_semtex
$glare_blind
hud_obit_death_grenade_round
hud_mp_num_big_7_white
codtv_frame
menu_mp_mountain_map_select
hud_ks_harpy_256
mtl_weapon_camo_wanted
gradient_top
mc/mtl_weapon_camo_gold_alt_attach
emblem_bg_att_ext_clip
hud_medals_comeback
menu_mp_overflow_map_select_final
hud_icon_claymore
mc/mtl_veh_t6_a10f_thermal
hud_mp_vis_gun_title_left
rank_ltgen_128
lui_arrow
thumbsup
menu_mp_express_map_select
playlist_tdm
flag_austria
mtl_weapon_camo_comics_solid
menu_mp_cac_caro_perk_line
menu_mp_lobby_aar_award_best
emblem_bg_prestige_c4
em_bg_wpn_attach_m1216
mc/mtl_weapon_camo_3layer_1
mc/mtl_weapon_camo_3layer_2
mc/mtl_weapon_camo_3layer_3
league_champions
emblem_lut_2d
mc/mtl_flag_axis_1
mc/mtl_flag_axis_2
mc/mtl_flag_axis_3
mc/mtl_veh_t6_v78_vtol_guns_friend
mc/mtl_t6_wpn_ar_xm8_detail
em_bg_wpn_complete_fal
mc/mtl_t5_weapon_equip_light_grn
mtl_t6_wpn_briefcase_bomb_progress_background
mc/mtl_t6_wpn_launch_fhj18_lens
em_bg_flag_ukraine
playlist_ctf
gfx_fxt_light_flare_phosphorous_eo300
emblem_bg_att_quick_draw
menu_camo_mtx_zombies_32
compassping_blankfiring_mp
emblem_bg_bo2_pl_sticks_stones
mc/mtl_t6_wpn_turret_ads_glass
em_bg_wpn_attach_fal
em_bg_flag_belarus
mc/mtl_weapon_camo_dragon_alt_attach
mc/mtl_t6_wpn_tac_insert_detect
menu_camo_atacs_pattern
rank_ssgt_128
code_warning_bandwidthlimited
em_bg_flag_congo_pr
compassping_player_bracket
mc/mtl_t6_wpn_c4
emblem_bg_bo2_pl_ffa
em_bg_flag_gibraltar
pc_resolve_floatz1
pc_resolve_floatz2
pc_resolve_floatz4
pc_resolve_floatz8
pc_resolve_floatz16
gfx_fxt_gas_flash_z0
menu_camo_mtx_afterlife
emblem_bg_snd_destroyer
life_counter_alive
menu_div_bronze_64
em_bg_wpn_attach_ballista
hud_ks_minigun_big
compassping_friendly_mp
em_bg_wpn_complete_pdw
mc/mtl_t6_attach_optic_acog_reticle_40
mc/mtl_t6_attach_shotgun_silencer1
mc/mtl_t6_wpn_shield_nodecal_thermal
filter_symmetric_1
filter_symmetric_2
filter_symmetric_3
mc/mtl_weapon_camo_ghost_attach
filter_symmetric_4
filter_symmetric_5
filter_symmetric_6
filter_symmetric_7
spectator_pip_scoretop_middle
filter_symmetric_8
hud_ks_minigun
mc/mtl_t6_attach_ar_silencer1
mc/mtl_t6_attach_optic_dualband_thermal
grid_tiles
em_bg_flag_cambodia
em_bg_flag_czech_republic
em_bg_flag_dominican_republic
em_bg_flag_rwanda
hud_obit_proximitymine
em_bg_flag_n_ireland
hud_medals_sshooter_ddown
em_bg_wpn_attach_pdw
menu_mp_weapons_five_seven_big
voice_off
em_bg_ani_cybertron
menu_div_iron
menu_mp_weapons_xm8
mc/mtl_t6_wpn_bouncing_betty_detect
hud_sensor_grenade
hud_medals_aggression_ctf
em_bg_flag_guyana
emblem_bg_default
xenonbutton_dpad_all
compassping_dog
progress_bar_fg
gfx_fxt_smk_def_0
gfx_fxt_smk_def_1
gfx_fxt_smk_def_3
gfx_fxt_smk_def_4
ui_scrollbar
em_bg_ani_comics
emblem_slug_10
emblem_slug_11
emblem_slug_12
emblem_slug_13
emblem_slug_14
emblem_slug_15
emblem_slug_16
emblem_slug_17
menu_mp_pip_orange
menu_mp_weapons_judge_big
menu_mp_turbine_map_select
overlay_low_health_splat
mc/mtl_t6_attach_tritium_red_txt
em_bg_flag_gabon
mc/mtl_veh_t6_asd_tread_left
compass_supply_drop_green
menu_mp_background_glow
hud_ks_auto_turret_menu
mc/mtl_t6_attach_tritium_wht
emblem_bg_seasonpass
hud_medals_share01
menu_white_line_faded_big
gfx_fxt_smk_scattered_z3
emblem_bg_dom_defender
em_bg_ani_beast
em_bg_flag_qatar
ui_slider2
demo_stop
mc/mtl_t6_attach_optic_acog_reticle
gfx_fxt_env_dust_mote_pcloud_add
menu_mp_playlist_map
mc/mtl_t6_attach_optic_holo_zmb
em_bg_flag_isle_of_man
hud_ks_lit_glow
mc/mtl_t6_attach_optic_combo_camo1
mc/mtl_t6_attach_optic_combo_camo2
em_bg_flag_honduras
code_warning_serverfps
menu_mp_lobby_frame_outer
menu_camo_mtx_roxann_32
em_bg_flag_tonga
emblem_bg_prestige_perk3_extreme
em_bg_flag_guatemala
mc/mtl_weapon_camo_3layer
menu_mp_cac_prim_fill
codtv_like
lui_grid
gfx_fxt_light_flare2_eo2_z2
gfx_fxt_env_water_foam_light_z10
gfx_fxt_light_ray_spread_z3
hud_ks_emp_drop
emblem_bg_bo2_pl_oic
mc/mtl_weapon_camo_toxic_1
mc/mtl_weapon_camo_toxic_2
em_bg_flag_saint_lucia
mc/mtl_weapon_camo_toxic_3
mc/mtl_weapon_camo_toxic_4
menu_mp_weapons_crossbow
playlist_zsurvival
compassping_squad_fire_mp
color_channel_mixer
menu_mp_pip_red
em_bg_wpn_camo_hamr
hud_horizontal_compass_minimap
emp_filter_overlay
mc/mtl_veh_t6_rcxd_wheels
menu_camo_mtx_dmh
menu_mp_weapons_hamr
em_bg_flag_spain
em_bg_flag_vanuatu
gfx_fxt_smk_light_z120
hud_obit_exploding_arrow
digital_noise_filter_qrdrone
bloom_apply_null
mc/mtl_t6_wpn_sniper_xpr50
menu_mp_cosmodrome_map_select
ssao_minify
gfx_fxt_smk_def_0_ds255
em_bg_flag_bahrain
mc/mtl_weapon_camo_bacon_alt_attach
menu_lobby_icon_blackops
playlist_kill_confirm
mc/mtl_t6_wpn_ar_saritch
menu_camo_mtx_aqua
mc/mtl_veh_t6_quad_rotor_thermal
mc/mtl_t6_wpn_crossbow_thermal
mc/mtl_t6_wpn_launch_smaw
emblem_bg_dom_aggression
mtl_weapon_camo_mtx3_massacre_pat
league_moshpit
em_bg_ani_dmh
mc/mtl_t6_wpn_turret_sentry_gun_ammo_red
vac
emblem_bg_att_silencer
mc/mtl_veh_t6_air_fa38_body_friendly
mc/mtl_t6_wpn_lmg_mk48_ammo_thermal
damage_feedback_tac
hud_objective_circle_meter
gfx_fxt_smk_puff
compass_hk
mc/mtl_weapon_camo_dragon_attach_1
mc/mtl_weapon_camo_dragon_attach_2
hit_direction
gradient_center
gfx_fxt_smk_tendril_ds255
menu_camo_mtx_pap
faction_128_pmc
mtl_weapon_camo_kawaii
mc/mtl_mp_flag_base
hud_ks_dogs_big
code_warning_models
hud_shoutcasting_notify_a
hud_shoutcasting_notify_b
hud_shoutcasting_notify_c
menu_div_gold_sub01_64
mc/mtl_weapon_camo_gold_alt_attach_1
gfx_fxt_drone_harpy_silhouette
hud_medals_fourpiece
menu_camo_mtx_zombies
mc/mtl_t6_attach_optic_rangefinder_thermal
menu_mp_popup_top
hud_ks_littlebird_drop
compassping_enemy
hud_ks_u2_spyplane_big
gfx_fxt_smk_def_1_ds192
emblem_bg_prestige_mms
hud_ks_straferun_menu
hud_medals_takedown_bomb
xenonbutton_dpad_down
mc/mtl_weapon_camo_carbon_fiber_attach_1
menu_mp_weapons_saiga12
mc/mtl_veh_air_fa38_glass_shadow
hud_frame_faction_lines
mc/hud_outline_model_orange
gfx_fxt_light_flare_halogen
codtv_info
hud_medals_intercepted
mc/mtl_t6_attach_optic_specter_thermal
mc/mtl_t6_wpn_tablet_buttons
menu_mp_weapons_crossbow_big
emblem_bg_ctf_aggression
mc/mtl_fx_char_gib_chunks
lui_bkg
mc/mtl_t6_attach_optic_specter
gfx_fxt_bio_blooddrops_ds64
hud_ks_spy_sat_big
gfx_fxt_light_glow_eo10
perk_tactical_mask_256
hud_anim_overwatch
barrack_scorestreaks_icon
waypoint_bomb_enemy
menu_mp_star_rating_half
menu_mp_drone_map_select
menu_mp_weapons_fhj_big
em_bg_ani_afterlife
em_bg_wpn_complete_ksg
flag_korea
mc/mtl_weapon_camo_zmb_dlc4_alt_attach_1
mtl_weapon_camo_mtx3_breach_pat
mc/mtl_weapon_camo_zmb_dlc4_alt_attach_2
menu_mp_lobby_icon_highlight
menu_mp_weapons_sig556
mc/mtl_t6_attach_trinium_sight_white_add
em_bg_wpn_attach_ksg
bloom_downsample_convolution_hq
mc/mtl_t6_attach_optic_combo_reticle_down
dof_hq_blur_mask
emblem_bg_kills_smg
hud_medals_destroyed_supply_drop
mtl_weapon_camo_ukpunk
knife_ballistic_reticle
emblem_bg_prestige_perk3_dexterity
resample_final
mtl_t6_attach_bcpu_ui3d_background
mc/mtl_weapon_camo_gold_attach_1
hud_medals_backstabber
menu_mp_firingrange_map_select_big
mc/mtl_t6_attach_optic_reflex_thermal
flag_brit
mc/mtl_t6_wpn_grenade_smoke
hud_us_flashgrenade
hud_medals_closecall_ctf
em_bg_flag_saint_kitts_nevis
gfx_fxt_debris_clump_add
gfx_fxt_smk_light_ds128
ui_scrollbar_thumb
mc/mtl_t6_wpn_sniper_svu_scope
emblem_bg_elite1
emblem_bg_elite2
emblem_bg_hq_vanquisher
em_bg_flag_tuvalu
mc/mtl_t6_attach_optic_rmr_reticle_10
mc/mtl_t6_attach_optic_rmr_reticle_12
em_bg_wpn_complete_acog
mc/mtl_t6_attach_optic_rmr_reticle_13
mc/mtl_t6_attach_optic_rmr_reticle_14
mc/mtl_t6_attach_optic_rmr_reticle_15
mc/mtl_t6_attach_optic_rmr_reticle_16
mc/mtl_t6_attach_optic_rmr_reticle_17
mc/mtl_t6_attach_optic_rmr_reticle_18
mc/mtl_t6_attach_optic_rmr_reticle_19
emblem_bg_bo2_screens
reflex_30
gfx_fxt_env_water_splash_ds128
menu_mp_berlinwall_map_select_final
reflex_31
reflex_32
reflex_33
reflex_34
reflex_35
mc/mtl_t6_attach_optic_rmr
reflex_36
reflex_37
emblem_bg_prestige_perk3_awareness
menu_mp_bonuscard_overkill
mc/mtl_t6_wpn_pistol_kard_camo1
mc/mtl_t6_wpn_pistol_kard_camo2
mc/mtl_t6_wpn_pistol_kard_camo3
postfx
youtube_logo
em_bg_wpn_complete_hamr
mc/mtl_t6_wpn_launch_rpg7
hud_team_emp
$point
mc/mtl_t6_attach_silencer_thermal
em_bg_flag_finland
hud_ks_counter_uav
hud_medals_lastmanstanding
mc/mtl_weapon_camo_cybertron_attach
bitchin_clock
hud_rts_mech_arrow
menu_mp_crisis_map_select_big
cac_mods_trigger_group
em_bg_wpn_attach_skorpion
mc/mtl_t6_wpn_turret_ads_alpha
em_bg_wpn_camo_tac40
hud_ks_heli_gunner_drop
ui_heatmap
mc/mtl_weapon_camo_zmb_dlc2_alt
mc/mtl_weapon_camo_zombies
emblem_bg_ffa_vanquisher
menu_mp_missing_motd_big
em_bg_wpn_camo_mtar
emblem_bg_bo2_camo_red01
compass_static
mc/mtl_t6_attach_wlp
menu_mp_weapons_baretta
mc/mtl_t6_attach_optic_acog_reticle_01
mc/mtl_t6_attach_optic_acog_reticle_02
mc/mtl_t6_attach_optic_acog_reticle_03
mc/mtl_t6_attach_optic_acog_reticle_04
mc/mtl_t6_attach_optic_acog_reticle_05
mc/mtl_t6_attach_optic_acog_reticle_06
mc/mtl_t6_attach_optic_acog_reticle_07
mc/mtl_t6_attach_optic_acog_reticle_08
mc/mtl_t6_attach_optic_acog_reticle_09
compassping_blank_mp
menu_mp_weapons_qbb95
faction_seals
mc/mtl_t6_attach_optic_mms_display
hud_us_grenade
ui_holotable_grid2
ui_holotable_grid3
hud_ks_reaper
perk_dexterity_256
emblem_bg_prestige_claymore
mc/metal_aircraft_catapult_strip
mc/mtl_t6_wpn_sniper_svu_scope_camo2
em_bg_wpn_complete_holo
gfx_fxt_debris_gib_glass_cloud_01
gfx_fxt_debris_gib_glass_cloud_03
gfx_fxt_debris_gib_glass_cloud_04
menu_mp_contract_paid
em_bg_flag_uae
wc/gfx_impact_glass01_riotshield
rank_prestige15_128
playlist_wager
gfx_fxt_smk_def_3_z80_gr
progress_bar_bg
gfx_fxt_smk_trail_ds128
league_champions_64
menu_mp_cracked_map_select
hud_icon_satchelcharge_256
hud_proximitymine_256
menu_mp_weapons_saritch
hud_icon_bomb_a
hud_icon_bomb_b
perk_hardwired_256
mc/mtl_german_shepherd_fur
menu_motd_votecamo_2b
menu_mp_cac_grad_stretch
mc/mtl_t6_wpn_pistol_judge_shell
mc/mtl_t6_wpn_shield_detect
mc/mtl_t6_attach_optic_holo_reticle_01
mc/mtl_t6_attach_optic_holo_reticle_02
mc/mtl_t6_attach_optic_holo_reticle_03
mc/mtl_t6_attach_optic_holo_reticle_04
mc/mtl_t6_attach_optic_holo_reticle_05
mc/mtl_t6_attach_optic_holo_reticle_06
mc/mtl_t6_attach_optic_holo_reticle_07
mc/mtl_t6_attach_optic_holo_reticle_08
mc/mtl_t6_attach_optic_holo_reticle_09
menu_numbers_1
menu_numbers_2
menu_numbers_3
menu_numbers_4
menu_numbers_5
gfx_fxt_smk_trail_ds128_bg
mc/mtl_weapon_camo_muertos_1
mc/mtl_weapon_camo_muertos_2
gfx_fxt_env_water_splash_ds64
mc/mtl_weapon_camo_muertos_3
em_bg_flag_ethiopia
mc/mtl_weapon_camo_muertos_4
emblem_bg_bo2_bandolier
hud_shoutcasting_notify_arrow
reticle_side_round_big_right
mc/mtl_p6_dogtags_friend
menu_mp_cosmodrome_map_select_bw
hud_medals_mgl
em_bg_wpn_camo_ballista
mc/mtl_t6_wpn_minigun
emblem_bg_kills_assists
faction_pmc
mc/mtl_p6_screen_killstreaks
emblem_bg_bacon
menu_mp_cac_caro_gren_hl
menu_mp_weapon_lvl_loc
gfx_fxt_debris_spike_ds255
mc/mtl_t6_wpn_sniper_ballista_scope_camo1
mc/mtl_t6_wpn_smg_vector_thermal
mc/mtl_t6_wpn_sniper_ballista_scope_camo2
em_bg_flag_germany
$line_nodepth
mc/mtl_gen_eye_iris_blue
menu_div_semipro_sub01
menu_div_semipro_sub02
menu_div_semipro_sub03
menu_mp_cac_attach_wc
em_bg_wpn_complete_hybrid
mc/mtl_veh_t6_ah94_thermal
em_bg_wpn_camo_m27
menu_camo_mtx_graf_32
hud_ks_dogs
emblem_bg_merciless
rank_prestige14_128
em_bg_wpn_complete_svu
emblem_bg_career_mastery_smg
gfx_fxt_light_flare_halogen_z10
mc/mtl_t6_wpn_sniper_ballista_thermal
mc/mtl_t6_attach_pistol_silencer
gfx_fxt_env_water_mist_ds64
mc/mtl_t6_attach_grip
gfx_fxt_smk_def_1_ds255
menu_mp_heatmap_1
menu_mp_heatmap_2
menu_mp_heatmap_3
emblem_bg_att_rapid_fire
menu_mp_heatmap_4
menu_mp_heatmap_5
menu_mp_heatmap_6
mc/mtl_t6_wpn_supply_drop_ally
menu_mp_heatmap_7
menu_mp_heatmap_8
menu_mp_heatmap_9
dollycam2d
menu_mp_socotra_map_select_final
emblem_bg_ben
em_bg_wpn_attach_svu
menu_mp_uplink_map_select_final
gfx_fxt_smk_scattered_z120
mc/mtl_veh_t6_drone_supply
barrack_ss_support
gfx_fxt_debris_conc
menu_prestige_unlock_token_128
em_bg_wpn_complete_fhj
em_bg_wpn_camo_qbb
hud_medals_share_agr
emblem_bg_prestige_overkill
hud_medals_sticks_regicide
hud_ks_qr_drone_256
loadscreen_mp_dockside
em_bg_flag_andorra
hud_ks_harpy_big
menu_camo_mtx_w115
em_bg_wpn_attach_fhj
em_bg_wpn_camo_smr
bloom_remap
hud_medals_retrieval
mc/mtl_t5_weapon_camera_spike
gfx_fxt_light_hot_add
frame_color_debug
gfx_fxt_smk_light_ds255_z10
emblem_bg_bo2_hc_vet
emblem_bg_bo2_pl_hq
emblem_bg_bo2_pl_sup_sharpshooter
waypoint_recon_artillery_strike
ui_button_xenon_stick_ani_32_ldown
mc/mtl_t6_wpn_ar_hk416
glow_setup
mc/mtl_weapon_camo_zmb_dlc2
em_bg_flag_st_vincent_grenadines
gfx_fxt_fx_distortion_ripple_trail
menu_div_bronze_sub03_64
mc/mtl_drone_overwatch_body_dark_unlit
mp_hud_reaper_reticle
ping_bar_01
pc_keyboard_down
ping_bar_02
mc/mtl_t6_wpn_ar_sig556_thermal
ping_bar_03
ping_bar_04
mc/mtl_weapon_camo_armor_alt_1
em_bg_wpn_complete_mtar
mc/mtl_weapon_camo_armor_alt_2
mc/mtl_weapon_camo_armor_alt_3
progress_bar_bg_small
mc/mtl_t6_attach_optic_reflex_reticle_30
mc/mtl_t6_attach_optic_reflex_reticle_31
mc/mtl_t6_attach_optic_reflex_reticle_32
menu_camo_ghostex_pattern
mc/mtl_t6_attach_optic_reflex_reticle_33
mc/mtl_t6_attach_optic_reflex_reticle_34
mc/mtl_t6_attach_optic_reflex_reticle_35
mc/mtl_t6_attach_optic_reflex_reticle_36
mc/mtl_t6_attach_optic_reflex_reticle_37
mc/mtl_t6_attach_optic_reflex_reticle_38
mc/mtl_t6_attach_optic_reflex_reticle_39
gfx_fxt_debris_wind_ash_add
loadscreen_mp_pod
mc/mtl_t6_wpn_ar_sa58_thermal
map_mortar_selector
gfx_fxt_debris_fine_clump
ui_arrow_left
emblem_bg_tacinsert_v
gfx_fxt_fx_distortion_ring_heavy
gfx_fxt_env_water_splash2_ds64
hud_medals_streak01
mtl_fx_hydro_water_dam4b
em_bg_flag_nauru
hud_momentum_meter_bottom
mtl_weapon_camo_jungletiger_solid
cac_mods_pistol_grip
hud_lui_arrow_global
mc/gfx_impact_asphalt01
mc/gfx_impact_asphalt02
menu_camo_mtx_armor
menu_div_semipro
mp_hud_sentry_outer_white
menu_mp_title_screen_mp
menu_motd_votearrow_glow
hud_mp_vis_ks_dpad_arrow
$floatz
hud_medals_share_dogs
em_bg_wpn_camo_lsat
mc/mtl_t6_wpn_sniper_dsr50
mc/mtl_veh_air_ah94_canopy
hud_shoutcasting_notify_hq
gfx_fxt_lensflare_stripe_white_dtle
mp_hud_wasp_outer_white
mc/mtl_t6_wpn_shield_nodecal
emblem_bg_att_bal_cpu
em_bg_wpn_attach_kap40
flag_usa
wheel_up_mouse
menu_mp_weapons_lsat
resolve_color
playlist_single_ctf
mc/mtl_veh_t6_air_fa38_decals_mult_low
emblem_bg_att_dual_wield
mc/mtl_weapon_stinger_missle
gradient
hud_obit_death_crush
emblem_bg_att_fmj
gfx_fxt_smk_light_z40
hud_mp_vis_gun_title_mid
mc/mtl_t6_attach_optic_holo_zmb_camo2
hud_shoutcasting_bar_stretch
menu_camo_mtx_snake_32
gfx_fxt_debris_heli_rotor_swirl
lui_hanoi_map_vote
emblem_bg_att_long_barrel
menu_mp_cac_attach_hl
menu_mp_cac_grad_stretch_add_v2
emblem_bg_hp_defenderl
em_bg_flag_comoros
menu_mp_lobby_aar_icons_splat
hud_ctf_flag_icon_white
em_bg_flag_indonesia
rank_prestige10_128
loadscreen_mp_skate
mc/mtl_t6_wpn_pistol_b2023r_camo1
mc/mtl_t6_wpn_ar_sa58
mc/mtl_t6_wpn_pistol_b2023r_camo2
mc/mtl_t6_wpn_pistol_b2023r_camo3
menu_mp_lobby_icon_emblem
hud_medals_bomber
gfx_fxt_light_flare2_eo2_gr
killiconsuicide
gfx_fxt_smk_gen_z120
hud_medals_share_lightstrike
cac_mods_holographic
wpc/mp_la_mall_ad01
em_bg_wpn_attach_vector
mc/mtl_t6_veh_drone_quad_rotor_body_dest
rank_gen_128
gfx_fxt_debris_plume_smoke_ds128_gr
wheel_down_mouse
emblem_bg_bo2_camo_rust01
emblem_bg_bo2_camo_rust02
hud_mp_vis_ks_dpad_box_back_lit
hud_ks_auto_turret_drop
mc/mtl_fx_shotgun_shell_alpha
em_bg_flag_north_korea
em_bg_flag_burundi
menu_div_iron_sub03_64
em_bg_flag_eqypt
mc/mtl_weapon_camo_gold_alt_1
mc/mtl_weapon_camo_gold_alt_2
mc/mtl_weapon_camo_gold_alt_3
mtl_weapon_camo_graffiti_solid
em_bg_flag_laos
menu_div_bronze_sub02_64
loadscreen_mp_village
mc/mtl_t6_wpn_shotty_saiga_skull
gfx_fxt_smk_light_ds255_z120
hud_obit_tact_grenade
mc/mtl_t6_wpn_sniper_dsr50_scope_lens
mtl_weapon_camo_zombies_pat
mc/gfx_impact_fabric
mc/mtl_fx_shotgun_shell
em_bg_flag_ireland
ssao_apply
emblem_bg_kcon_con
mc/mtl_veh_t6_drone_supply_thermal
menu_mp_lobby_gamercard_shadow
mc/mtl_default
headiconyouinkillcam
menu_mp_reward_bracket
cac_restricted
menu_mp_cac_backing
em_bg_flag_montenegro
menu_mp_weapons_riot_shield
mc/mtl_t6_wpn_pistol_fnp45_thermal
mlv/mtl_p6_con_locker_door
mc/mtl_t6_wpn_lmg_type95_drum_thermal
menu_mp_cac_caro_weapon_hl
mc/mtl_p6_attack_dog_vest_faction_a_therm
emblem_bg_bo2_camo_brown
mc/mtl_weapon_camo_diamond_alt_1
mc/mtl_weapon_camo_diamond_alt_2
mc/mtl_weapon_camo_diamond_alt_3
emblem_bg_dom_assault
mc/mtl_weapon_at4
menu_mp_contract_expired
waypoint_flag_yellow
mc/mtl_t6_attach_optic_holo_reticle
waypoint_dogtags
mc/mtl_t6_attach_optic_mms
hud_medals_stick
menu_mp_villa_map_select_bw
playlist_dlc_vengeance
hud_mp_firerate_burst
fonts/devfonts
compass_sg_white
button_middle_mouse
mc/mtl_t6_wpn_pda_screen
rank_maj
hud_medals_rcxd
mc/mtl_veh_t6_drone_supply_blade_spin
gfx_fxt_spark_pcloud_01
gfx_fxt_spark_pcloud_02
gfx_fxt_spark_pcloud_03
em_bg_flag_scotland
mc/mtl_t6_wpn_ar_xm8
mc/mtl_t6_wpn_sniper_xpr50_camo2
mc/mtl_t6_wpn_sniper_xpr50_camo3
menu_prestige_icon_cacslot
lui_topshadow
em_bg_wpn_attach_lsat
loadscreen_mp_downhill
hud_ks_reaper_menu
fonts/devfonts_glow
em_bg_flag_denmark
demo_timeline_bookmark
menu_lobby_title_back
compassping_squad_lead_fire_mp
emblem_bg_ctf_master
scorebar_fadein
menu_mp_discovery_map_select_big
menu_camo_mtx_ben_32
```

`README.md`:

```md
# ParadiseBO2
This is the old Paradise SPRX BO2 source code circa 2018

This is actually a more recent version, probably most recently released version, because it contains the window code

```