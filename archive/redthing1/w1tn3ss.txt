Project Path: arc_redthing1_w1tn3ss_7vvd9j0k

Source Tree:

```txt
arc_redthing1_w1tn3ss_7vvd9j0k
├── CMakeLists.txt
├── README.md
├── cmake
│   ├── AsmrConfig.cmake
│   ├── FormattingConfig.cmake
│   ├── LuaJITBuild.cmake
│   ├── PlatformConfig.cmake
│   ├── README_Embed.md
│   ├── README_Lua.md
│   ├── SampleConfig.cmake
│   ├── TestConfig.cmake
│   ├── TidyConfig.cmake
│   ├── W1CompilerCache.cmake
│   ├── W1Deps.cmake
│   ├── W1Init.cmake
│   ├── W1Options.cmake
│   ├── W1Packaging.cmake
│   ├── W1Targets.cmake
│   ├── W1Tracers.cmake
│   └── WindowsSymbolConfig.cmake
├── doc
│   ├── build.md
│   ├── frida_tracers.md
│   ├── p1ll_python.md
│   └── p1lljs.md
├── frida
│   ├── call_tracer.py
│   └── stalk_drcov.py
├── samples
│   ├── CMakeLists.txt
│   ├── programs
│   │   ├── CMakeLists.txt
│   │   ├── control_flow_1.cpp
│   │   ├── hook_test_target.c
│   │   ├── instraware
│   │   │   ├── CMakeLists.txt
│   │   │   ├── instraware_common.cpp
│   │   │   ├── instraware_common.hpp
│   │   │   ├── instraware_qbdi_fault.cpp
│   │   │   ├── instraware_qbdi_rai.cpp
│   │   │   ├── instraware_qbdi_smc.cpp
│   │   │   └── instraware_qbdi_stack.cpp
│   │   ├── linux_daemon.c
│   │   ├── linux_target.c
│   │   ├── multi_threaded_target.c
│   │   ├── p1ll_test_target.c
│   │   ├── rewind_demo_algorithms.c
│   │   ├── rewind_demo_basic.c
│   │   ├── rewind_demo_calls.c
│   │   ├── rewind_demo_io.c
│   │   ├── rewind_demo_memops.c
│   │   ├── rewind_demo_million.c
│   │   ├── runtime_injection_target.c
│   │   ├── signature_helper.h
│   │   ├── simple_demo.c
│   │   ├── threadtest_demo.c
│   │   └── threadtest_evasive_demo.cpp
│   └── standalone
│       ├── README.md
│       ├── p1ll_python
│       │   └── test_p1ll_python.py
│       └── p1ll_standalone
│           ├── CMakeLists.txt
│           ├── test_p1ll_capi.c
│           └── test_p1ll_standalone.cpp
├── scripts
│   ├── d0ct0r.py
│   ├── p1ll
│   │   ├── string_patch.js
│   │   └── string_patch.lua
│   ├── python
│   │   ├── p1ll_patch.py
│   │   ├── p1ll_regions.py
│   │   └── p1ll_scan.py
│   ├── w1dump.py
│   ├── w1dump_tui.py
│   ├── w1mem_analyzer.py
│   ├── w1rewind_view.py
│   ├── w1script
│   │   ├── coverage_tracker.lua
│   │   ├── instruction_tracer.lua
│   │   ├── jsonl_tracer.lua
│   │   ├── memory_tracer.lua
│   │   ├── mnem_tracker.lua
│   │   ├── symbol_resolver.lua
│   │   └── xfer_tracker.lua
│   └── w1trace_stats.py
├── src
│   ├── p01s0n
│   │   ├── CMakeLists.txt
│   │   ├── p01s0n.cpp
│   │   ├── p01s0n.hpp
│   │   └── p01s0n_config.hpp
│   ├── p1ll
│   │   ├── CMakeLists.txt
│   │   ├── bindings
│   │   │   └── python
│   │   │       ├── CMakeLists.txt
│   │   │       ├── p1ll
│   │   │       │   └── __init__.py
│   │   │       ├── p1ll_python.cpp
│   │   │       └── pyproject.toml
│   │   ├── capi
│   │   │   ├── CMakeLists.txt
│   │   │   ├── p1ll_c.cpp
│   │   │   └── p1ll_c.h
│   │   ├── engine
│   │   │   ├── address_space.cpp
│   │   │   ├── address_space.hpp
│   │   │   ├── apply.cpp
│   │   │   ├── apply.hpp
│   │   │   ├── pattern.cpp
│   │   │   ├── pattern.hpp
│   │   │   ├── pattern_matcher.cpp
│   │   │   ├── pattern_matcher.hpp
│   │   │   ├── plan_builder.cpp
│   │   │   ├── plan_builder.hpp
│   │   │   ├── platform
│   │   │   │   ├── platform.cpp
│   │   │   │   ├── platform.hpp
│   │   │   │   ├── process_memory.hpp
│   │   │   │   ├── process_memory_common.hpp
│   │   │   │   ├── process_memory_linux.cpp
│   │   │   │   ├── process_memory_macos.cpp
│   │   │   │   └── process_memory_windows.cpp
│   │   │   ├── pretty_logging.hpp
│   │   │   ├── result.hpp
│   │   │   ├── scanner.cpp
│   │   │   ├── scanner.hpp
│   │   │   ├── session.cpp
│   │   │   ├── session.hpp
│   │   │   └── types.hpp
│   │   ├── heur
│   │   │   ├── code_signature.cpp
│   │   │   └── code_signature.hpp
│   │   ├── p1ll.hpp
│   │   ├── scripting
│   │   │   ├── js
│   │   │   │   ├── js_bindings.hpp
│   │   │   │   ├── js_engine.cpp
│   │   │   │   └── js_engine.hpp
│   │   │   ├── lua
│   │   │   │   ├── lua_bindings.hpp
│   │   │   │   ├── lua_engine.cpp
│   │   │   │   └── lua_engine.hpp
│   │   │   ├── script_engine.hpp
│   │   │   ├── script_engine_factory.cpp
│   │   │   └── script_engine_factory.hpp
│   │   └── utils
│   │       ├── file_utils.cpp
│   │       ├── file_utils.hpp
│   │       ├── hex_pattern.cpp
│   │       ├── hex_pattern.hpp
│   │       ├── hex_utils.cpp
│   │       ├── hex_utils.hpp
│   │       ├── memory_align.hpp
│   │       ├── pretty_hexdump.cpp
│   │       ├── pretty_hexdump.hpp
│   │       └── windows_compat.hpp
│   ├── p1llx
│   │   ├── CMakeLists.txt
│   │   ├── commands
│   │   │   ├── asm.cpp
│   │   │   ├── asm.hpp
│   │   │   ├── cure.cpp
│   │   │   ├── cure.hpp
│   │   │   ├── disasm.cpp
│   │   │   ├── disasm.hpp
│   │   │   ├── patch.cpp
│   │   │   ├── patch.hpp
│   │   │   ├── platform_utils.hpp
│   │   │   ├── poison.cpp
│   │   │   ├── poison.hpp
│   │   │   ├── sig.cpp
│   │   │   └── sig.hpp
│   │   └── main.cpp
│   ├── third_party
│   │   ├── capstone
│   │   ├── doctest
│   │   │   └── doctest.hpp
│   │   ├── funchook
│   │   ├── gdbstub_cpp
│   │   ├── jnjs
│   │   ├── keystone
│   │   ├── lief
│   │   ├── lua_headers
│   │   │   └── lua
│   │   │       ├── lauxlib.h
│   │   │       ├── lua.h
│   │   │       └── lualib.h
│   │   ├── luajit
│   │   ├── luajit_cmake
│   │   ├── nlohmann_json
│   │   ├── plthook
│   │   ├── qbdi
│   │   ├── redlog_cpp
│   │   └── sol2
│   ├── tracers
│   │   ├── CMakeLists.txt
│   │   ├── w1cov
│   │   │   ├── CMakeLists.txt
│   │   │   ├── config
│   │   │   │   └── coverage_config.hpp
│   │   │   ├── coverage.hpp
│   │   │   ├── coverage_recipe.hpp
│   │   │   ├── engine
│   │   │   │   ├── coverage_engine.cpp
│   │   │   │   ├── coverage_engine.hpp
│   │   │   │   ├── coverage_exporter.cpp
│   │   │   │   ├── coverage_exporter.hpp
│   │   │   │   ├── coverage_snapshot.hpp
│   │   │   │   ├── coverage_store.cpp
│   │   │   │   └── coverage_store.hpp
│   │   │   ├── entrypoints
│   │   │   │   └── preload.cpp
│   │   │   ├── runtime
│   │   │   │   └── coverage_runtime.hpp
│   │   │   └── thread
│   │   │       ├── coverage_thread_tracer.cpp
│   │   │       └── coverage_thread_tracer.hpp
│   │   ├── w1dump
│   │   │   ├── CMakeLists.txt
│   │   │   ├── config
│   │   │   │   └── dump_config.hpp
│   │   │   ├── dump_recipe.hpp
│   │   │   ├── engine
│   │   │   │   ├── dump_engine.cpp
│   │   │   │   └── dump_engine.hpp
│   │   │   ├── instrument
│   │   │   │   ├── dump_recorder.cpp
│   │   │   │   └── dump_recorder.hpp
│   │   │   ├── preload.cpp
│   │   │   └── runtime
│   │   │       └── dump_runtime.hpp
│   │   ├── w1rewind
│   │   │   ├── CMakeLists.txt
│   │   │   ├── config
│   │   │   │   ├── rewind_config.cpp
│   │   │   │   └── rewind_config.hpp
│   │   │   ├── engine
│   │   │   │   ├── module_table_builder.cpp
│   │   │   │   ├── module_table_builder.hpp
│   │   │   │   ├── register_schema.cpp
│   │   │   │   ├── register_schema.hpp
│   │   │   │   ├── rewind_engine.cpp
│   │   │   │   ├── rewind_engine.hpp
│   │   │   │   ├── target_environment_provider.cpp
│   │   │   │   ├── target_environment_provider.hpp
│   │   │   │   ├── trace_emitter.cpp
│   │   │   │   └── trace_emitter.hpp
│   │   │   ├── entrypoints
│   │   │   │   └── preload.cpp
│   │   │   ├── rewind_recipe.hpp
│   │   │   ├── runtime
│   │   │   │   └── rewind_runtime.hpp
│   │   │   └── thread
│   │   │       ├── memory_access_builder.cpp
│   │   │       ├── memory_access_builder.hpp
│   │   │       ├── memory_filter.cpp
│   │   │       ├── memory_filter.hpp
│   │   │       ├── register_delta_builder.cpp
│   │   │       ├── register_delta_builder.hpp
│   │   │       ├── rewind_thread_tracer.cpp
│   │   │       ├── rewind_thread_tracer.hpp
│   │   │       ├── snapshot_builder.cpp
│   │   │       ├── snapshot_builder.hpp
│   │   │       ├── stack_window_policy.cpp
│   │   │       └── stack_window_policy.hpp
│   │   ├── w1script
│   │   │   ├── CMakeLists.txt
│   │   │   ├── bindings
│   │   │   │   ├── abi.cpp
│   │   │   │   ├── abi.hpp
│   │   │   │   ├── inst.cpp
│   │   │   │   ├── inst.hpp
│   │   │   │   ├── mem.cpp
│   │   │   │   ├── mem.hpp
│   │   │   │   ├── module.cpp
│   │   │   │   ├── module.hpp
│   │   │   │   ├── output.cpp
│   │   │   │   ├── output.hpp
│   │   │   │   ├── reg.cpp
│   │   │   │   ├── reg.hpp
│   │   │   │   ├── root.cpp
│   │   │   │   ├── root.hpp
│   │   │   │   ├── symbol.cpp
│   │   │   │   ├── symbol.hpp
│   │   │   │   ├── util.cpp
│   │   │   │   ├── util.hpp
│   │   │   │   ├── w1_bindings.cpp
│   │   │   │   └── w1_bindings.hpp
│   │   │   ├── config
│   │   │   │   └── script_config.hpp
│   │   │   ├── entrypoints
│   │   │   │   └── preload.cpp
│   │   │   ├── runtime
│   │   │   │   ├── callback_registry.cpp
│   │   │   │   ├── callback_registry.hpp
│   │   │   │   ├── callback_store.hpp
│   │   │   │   ├── lua_runtime.cpp
│   │   │   │   ├── lua_runtime.hpp
│   │   │   │   ├── output_state.cpp
│   │   │   │   ├── output_state.hpp
│   │   │   │   ├── script_context.cpp
│   │   │   │   ├── script_context.hpp
│   │   │   │   └── script_runtime.hpp
│   │   │   ├── script.hpp
│   │   │   ├── script_recipe.hpp
│   │   │   └── thread
│   │   │       ├── script_tracer.cpp
│   │   │       └── script_tracer.hpp
│   │   └── w1xfer
│   │       ├── CMakeLists.txt
│   │       ├── config
│   │       │   └── transfer_config.hpp
│   │       ├── engine
│   │       │   ├── transfer_engine.cpp
│   │       │   └── transfer_engine.hpp
│   │       ├── entrypoints
│   │       │   └── preload.cpp
│   │       ├── io
│   │       │   ├── transfer_writer_jsonl.cpp
│   │       │   └── transfer_writer_jsonl.hpp
│   │       ├── model
│   │       │   └── transfer_types.hpp
│   │       ├── runtime
│   │       │   └── transfer_runtime.hpp
│   │       ├── thread
│   │       │   ├── transfer_tracer.cpp
│   │       │   └── transfer_tracer.hpp
│   │       ├── transfer.hpp
│   │       └── transfer_recipe.hpp
│   ├── w1analysis
│   │   ├── CMakeLists.txt
│   │   ├── abi_dispatcher.cpp
│   │   ├── abi_dispatcher.hpp
│   │   ├── symbol_lookup.cpp
│   │   └── symbol_lookup.hpp
│   ├── w1asmr
│   │   ├── CMakeLists.txt
│   │   ├── arch.cpp
│   │   ├── arch.hpp
│   │   ├── asmr.cpp
│   │   ├── asmr.hpp
│   │   └── result.hpp
│   ├── w1base
│   │   ├── CMakeLists.txt
│   │   ├── arch_spec.cpp
│   │   ├── arch_spec.hpp
│   │   ├── cli
│   │   │   └── verbosity.hpp
│   │   ├── env_config.cpp
│   │   ├── env_config.hpp
│   │   ├── ext
│   │   │   ├── args.hpp
│   │   │   ├── jsonstruct.hpp
│   │   │   └── tinyformat.hpp
│   │   ├── interval.hpp
│   │   ├── module_identity.cpp
│   │   ├── module_identity.hpp
│   │   ├── platform_utils.hpp
│   │   ├── signal_handler.cpp
│   │   ├── signal_handler.hpp
│   │   ├── stderr_write.hpp
│   │   ├── thread_utils.hpp
│   │   ├── types.hpp
│   │   ├── uuid_format.cpp
│   │   ├── uuid_format.hpp
│   │   ├── windows_clean.hpp
│   │   └── windows_console.hpp
│   ├── w1debugger
│   │   ├── CMakeLists.txt
│   │   ├── error.cpp
│   │   ├── error.hpp
│   │   ├── platform
│   │   │   ├── darwin
│   │   │   │   ├── darwin_debugger.hpp
│   │   │   │   ├── darwin_internal.hpp
│   │   │   │   ├── darwin_session.cpp
│   │   │   │   ├── entitlement_check.cpp
│   │   │   │   ├── memory_ops.cpp
│   │   │   │   ├── process_control.cpp
│   │   │   │   └── thread_context.cpp
│   │   │   ├── linux
│   │   │   │   ├── linux_debugger.cpp
│   │   │   │   └── linux_debugger.hpp
│   │   │   └── windows
│   │   │       ├── windows_debugger.cpp
│   │   │       └── windows_debugger.hpp
│   │   ├── session_impl.hpp
│   │   ├── types.hpp
│   │   ├── w1debugger.cpp
│   │   └── w1debugger.hpp
│   ├── w1dump
│   │   ├── CMakeLists.txt
│   │   ├── memory_dumper.cpp
│   │   ├── memory_dumper.hpp
│   │   ├── process_dumper.cpp
│   │   ├── process_dumper.hpp
│   │   ├── register_dumper.cpp
│   │   └── register_dumper.hpp
│   ├── w1formats
│   │   ├── CMakeLists.txt
│   │   ├── drcov.hpp
│   │   ├── dump_format.hpp
│   │   ├── jsonl_writer.cpp
│   │   └── jsonl_writer.hpp
│   ├── w1gadget
│   │   ├── CMakeLists.txt
│   │   ├── gadget_executor.cpp
│   │   └── gadget_executor.hpp
│   ├── w1h00k
│   │   ├── CMakeLists.txt
│   │   ├── backend
│   │   │   ├── backend.hpp
│   │   │   ├── import_table
│   │   │   │   ├── import_table_backend.cpp
│   │   │   │   └── import_table_backend.hpp
│   │   │   ├── inline
│   │   │   │   ├── inline_backend.cpp
│   │   │   │   ├── inline_backend.hpp
│   │   │   │   ├── inline_detour.cpp
│   │   │   │   ├── inline_detour.hpp
│   │   │   │   ├── inline_instrumentation.cpp
│   │   │   │   └── inline_instrumentation.hpp
│   │   │   ├── interpose
│   │   │   │   ├── interpose_backend.cpp
│   │   │   │   └── interpose_backend.hpp
│   │   │   ├── patch_batch.hpp
│   │   │   ├── pointer_auth.hpp
│   │   │   ├── registry.cpp
│   │   │   └── registry.hpp
│   │   ├── core
│   │   │   ├── hook_args.hpp
│   │   │   ├── hook_manager.cpp
│   │   │   ├── hook_manager.hpp
│   │   │   ├── hook_transaction.cpp
│   │   │   ├── hook_transaction.hpp
│   │   │   └── plan_targets.hpp
│   │   ├── errors.cpp
│   │   ├── errors.hpp
│   │   ├── hook.cpp
│   │   ├── hook.hpp
│   │   ├── memory
│   │   │   ├── memory.hpp
│   │   │   ├── posix.cpp
│   │   │   └── windows.cpp
│   │   ├── os
│   │   │   ├── os.cpp
│   │   │   └── os.hpp
│   │   ├── patcher
│   │   │   ├── patcher.hpp
│   │   │   ├── posix.cpp
│   │   │   └── windows.cpp
│   │   ├── reloc
│   │   │   ├── arm64.cpp
│   │   │   ├── arm64.hpp
│   │   │   ├── common.hpp
│   │   │   ├── relocator.cpp
│   │   │   ├── relocator.hpp
│   │   │   ├── x86.cpp
│   │   │   └── x86.hpp
│   │   └── resolve
│   │       ├── module_match.hpp
│   │       ├── posix.cpp
│   │       ├── resolve.hpp
│   │       └── windows.cpp
│   ├── w1import
│   │   ├── CMakeLists.txt
│   │   ├── backend
│   │   │   └── macos
│   │   │       ├── macho_processor.cpp
│   │   │       └── macho_processor.hpp
│   │   ├── import_insertion.cpp
│   │   ├── import_insertion.hpp
│   │   └── platform
│   │       ├── linux
│   │       │   ├── linux_import_inserter.cpp
│   │       │   └── linux_import_inserter.hpp
│   │       ├── macos
│   │       │   ├── macos_import_inserter.cpp
│   │       │   └── macos_import_inserter.hpp
│   │       └── windows
│   │           ├── windows_import_inserter.cpp
│   │           └── windows_import_inserter.hpp
│   ├── w1instrument
│   │   ├── CMakeLists.txt
│   │   ├── config
│   │   │   └── tracer_common_config.hpp
│   │   ├── core
│   │   │   ├── instrumentation_policy.cpp
│   │   │   ├── instrumentation_policy.hpp
│   │   │   ├── module_cache.hpp
│   │   │   ├── module_id_map.hpp
│   │   │   ├── module_registry.hpp
│   │   │   ├── thread_buffer.hpp
│   │   │   ├── vm_controller.cpp
│   │   │   └── vm_controller.hpp
│   │   ├── logging.hpp
│   │   ├── preload
│   │   │   ├── entrypoints.hpp
│   │   │   └── immortal_state.hpp
│   │   ├── process
│   │   │   └── process_session.hpp
│   │   ├── self_exclude.hpp
│   │   ├── trace
│   │   │   ├── event_dispatcher.hpp
│   │   │   └── thread_session.hpp
│   │   └── tracer
│   │       ├── event.hpp
│   │       ├── recipe.hpp
│   │       ├── runtime.hpp
│   │       ├── trace_context.hpp
│   │       ├── tracer.hpp
│   │       └── types.hpp
│   ├── w1monitor
│   │   ├── CMakeLists.txt
│   │   ├── backend
│   │   │   ├── darwin
│   │   │   │   ├── darwin_module_monitor.cpp
│   │   │   │   ├── darwin_module_monitor.hpp
│   │   │   │   ├── darwin_thread_monitor.cpp
│   │   │   │   └── darwin_thread_monitor.hpp
│   │   │   ├── hook_helpers.hpp
│   │   │   ├── linux
│   │   │   │   ├── linux_module_monitor.cpp
│   │   │   │   ├── linux_module_monitor.hpp
│   │   │   │   ├── linux_thread_monitor.cpp
│   │   │   │   └── linux_thread_monitor.hpp
│   │   │   ├── module_snapshot.hpp
│   │   │   ├── null
│   │   │   │   ├── null_module_monitor.cpp
│   │   │   │   ├── null_module_monitor.hpp
│   │   │   │   ├── null_thread_monitor.cpp
│   │   │   │   └── null_thread_monitor.hpp
│   │   │   ├── thread_entry.hpp
│   │   │   ├── thread_event_helpers.hpp
│   │   │   └── windows
│   │   │       ├── windows_module_monitor.cpp
│   │   │       ├── windows_module_monitor.hpp
│   │   │       ├── windows_string_utils.hpp
│   │   │       ├── windows_thread_monitor.cpp
│   │   │       └── windows_thread_monitor.hpp
│   │   ├── event_queue.hpp
│   │   ├── module_monitor.hpp
│   │   ├── monitor_factory.cpp
│   │   ├── monitor_factory.hpp
│   │   └── thread_monitor.hpp
│   ├── w1nj3ct
│   │   ├── CMakeLists.txt
│   │   ├── error.cpp
│   │   ├── error.hpp
│   │   ├── platform
│   │   │   ├── darwin
│   │   │   │   ├── darwin_injector.cpp
│   │   │   │   ├── darwin_injector.hpp
│   │   │   │   └── impl
│   │   │   │       ├── exc_handler.c
│   │   │   │       ├── injector.c
│   │   │   │       ├── injector.h
│   │   │   │       ├── injector_internal.h
│   │   │   │       ├── mach.c
│   │   │   │       ├── mach_exc.h
│   │   │   │       ├── mach_excServer.c
│   │   │   │       ├── ptrace.c
│   │   │   │       ├── remote_call.c
│   │   │   │       └── util.c
│   │   │   ├── linux
│   │   │   │   ├── impl
│   │   │   │   │   ├── elf.c
│   │   │   │   │   ├── injector.c
│   │   │   │   │   ├── injector.h
│   │   │   │   │   ├── injector_internal.h
│   │   │   │   │   ├── ptrace.c
│   │   │   │   │   ├── remote_call.c
│   │   │   │   │   ├── shellcode.S
│   │   │   │   │   └── util.c
│   │   │   │   ├── linux_injector.cpp
│   │   │   │   └── linux_injector.hpp
│   │   │   └── windows
│   │   │       ├── error_windows.cpp
│   │   │       ├── impl
│   │   │       │   ├── auxiliary.cpp
│   │   │       │   ├── auxiliary.hpp
│   │   │       │   ├── inject.hpp
│   │   │       │   ├── inject_createremotethread.cpp
│   │   │       │   ├── inject_launch.cpp
│   │   │       │   ├── inject_reflective.cpp
│   │   │       │   ├── inject_rtlcreateuserthread.cpp
│   │   │       │   ├── inject_setwindowshook.cpp
│   │   │       │   ├── util.hpp
│   │   │       │   └── winapis.h
│   │   │       ├── windows_injector.cpp
│   │   │       └── windows_injector.hpp
│   │   ├── w1nj3ct.cpp
│   │   └── w1nj3ct.hpp
│   ├── w1replay
│   │   ├── CMakeLists.txt
│   │   ├── cli
│   │   │   ├── commands
│   │   │   │   ├── checkpoint.cpp
│   │   │   │   ├── checkpoint.hpp
│   │   │   │   ├── inspect.cpp
│   │   │   │   ├── inspect.hpp
│   │   │   │   ├── server.cpp
│   │   │   │   ├── server.hpp
│   │   │   │   ├── summary.cpp
│   │   │   │   ├── summary.hpp
│   │   │   │   ├── threads.cpp
│   │   │   │   └── threads.hpp
│   │   │   └── main.cpp
│   │   ├── gdb
│   │   │   ├── adapter.cpp
│   │   │   ├── adapter.hpp
│   │   │   ├── adapter_components.hpp
│   │   │   ├── adapter_services.hpp
│   │   │   ├── breakpoint_store.hpp
│   │   │   ├── components
│   │   │   │   ├── auxv_component.cpp
│   │   │   │   ├── breakpoints_component.cpp
│   │   │   │   ├── host_info_component.cpp
│   │   │   │   ├── libraries_component.cpp
│   │   │   │   ├── loaded_libraries_component.cpp
│   │   │   │   ├── mem_component.cpp
│   │   │   │   ├── memory_layout_component.cpp
│   │   │   │   ├── offsets_component.cpp
│   │   │   │   ├── process_info_component.cpp
│   │   │   │   ├── register_info_component.cpp
│   │   │   │   ├── regs_component.cpp
│   │   │   │   ├── run_component.cpp
│   │   │   │   └── threads_component.cpp
│   │   │   ├── layout.cpp
│   │   │   ├── layout.hpp
│   │   │   ├── lldb
│   │   │   │   ├── darwin_loaded_libraries.cpp
│   │   │   │   └── darwin_loaded_libraries.hpp
│   │   │   ├── loaded_libraries_provider.cpp
│   │   │   ├── loaded_libraries_provider.hpp
│   │   │   ├── memory_map.cpp
│   │   │   ├── memory_map.hpp
│   │   │   ├── run_policy.hpp
│   │   │   ├── stepper.cpp
│   │   │   ├── stepper.hpp
│   │   │   ├── target_xml.cpp
│   │   │   ├── target_xml.hpp
│   │   │   ├── thread_state.hpp
│   │   │   ├── triple_utils.cpp
│   │   │   ├── triple_utils.hpp
│   │   │   ├── value_codec.cpp
│   │   │   └── value_codec.hpp
│   │   ├── memory
│   │   │   ├── memory_view.cpp
│   │   │   └── memory_view.hpp
│   │   ├── modules
│   │   │   ├── address_index.cpp
│   │   │   ├── address_index.hpp
│   │   │   ├── asmr_block_decoder.cpp
│   │   │   ├── asmr_block_decoder.hpp
│   │   │   ├── image_reader.hpp
│   │   │   ├── lief_module_provider.cpp
│   │   │   ├── lief_module_provider.hpp
│   │   │   ├── metadata_provider.hpp
│   │   │   ├── module_image.cpp
│   │   │   ├── module_image.hpp
│   │   │   ├── module_image_lief.cpp
│   │   │   ├── module_image_lief.hpp
│   │   │   ├── path_resolver.cpp
│   │   │   └── path_resolver.hpp
│   │   └── trace_loader
│   │       ├── trace_loader.cpp
│   │       └── trace_loader.hpp
│   ├── w1rewind
│   │   ├── CMakeLists.txt
│   │   ├── format
│   │   │   ├── register_metadata.hpp
│   │   │   ├── register_numbering.cpp
│   │   │   ├── register_numbering.hpp
│   │   │   ├── trace_codec.hpp
│   │   │   ├── trace_format.hpp
│   │   │   ├── trace_io.hpp
│   │   │   ├── trace_validator.cpp
│   │   │   └── trace_validator.hpp
│   │   ├── record
│   │   │   ├── memory_map_utils.cpp
│   │   │   ├── memory_map_utils.hpp
│   │   │   ├── trace_builder.cpp
│   │   │   ├── trace_builder.hpp
│   │   │   └── trace_builder_types.hpp
│   │   ├── replay
│   │   │   ├── block_decoder.hpp
│   │   │   ├── flow_cursor.cpp
│   │   │   ├── flow_cursor.hpp
│   │   │   ├── flow_extractor.cpp
│   │   │   ├── flow_extractor.hpp
│   │   │   ├── flow_types.hpp
│   │   │   ├── history_window.cpp
│   │   │   ├── history_window.hpp
│   │   │   ├── memory_store.cpp
│   │   │   ├── memory_store.hpp
│   │   │   ├── record_stream_cursor.cpp
│   │   │   ├── record_stream_cursor.hpp
│   │   │   ├── replay_context.cpp
│   │   │   ├── replay_context.hpp
│   │   │   ├── replay_context_builder.cpp
│   │   │   ├── replay_context_builder.hpp
│   │   │   ├── replay_instruction_cursor.cpp
│   │   │   ├── replay_instruction_cursor.hpp
│   │   │   ├── replay_position.cpp
│   │   │   ├── replay_position.hpp
│   │   │   ├── replay_session.cpp
│   │   │   ├── replay_session.hpp
│   │   │   ├── replay_state.cpp
│   │   │   ├── replay_state.hpp
│   │   │   ├── replay_state_applier.cpp
│   │   │   ├── replay_state_applier.hpp
│   │   │   ├── stateful_flow_cursor.cpp
│   │   │   └── stateful_flow_cursor.hpp
│   │   └── trace
│   │       ├── flow_classifier.hpp
│   │       ├── record_sink.hpp
│   │       ├── record_stream.hpp
│   │       ├── replay_checkpoint.cpp
│   │       ├── replay_checkpoint.hpp
│   │       ├── trace_file_writer.cpp
│   │       ├── trace_file_writer.hpp
│   │       ├── trace_index.cpp
│   │       ├── trace_index.hpp
│   │       ├── trace_reader.cpp
│   │       └── trace_reader.hpp
│   ├── w1runtime
│   │   ├── CMakeLists.txt
│   │   ├── memory_reader.cpp
│   │   ├── memory_reader.hpp
│   │   ├── module_catalog.cpp
│   │   ├── module_catalog.hpp
│   │   ├── process_event.hpp
│   │   ├── process_observer.cpp
│   │   ├── process_observer.hpp
│   │   ├── register_capture.cpp
│   │   ├── register_capture.hpp
│   │   ├── stack_capture.cpp
│   │   ├── stack_capture.hpp
│   │   ├── thread_catalog.cpp
│   │   └── thread_catalog.hpp
│   └── w1tool
│       ├── CMakeLists.txt
│       ├── commands
│       │   ├── cover.cpp
│       │   ├── cover.hpp
│       │   ├── debug.cpp
│       │   ├── debug.hpp
│       │   ├── dump.cpp
│       │   ├── dump.hpp
│       │   ├── inject.cpp
│       │   ├── inject.hpp
│       │   ├── insert_library.cpp
│       │   ├── insert_library.hpp
│       │   ├── inspect.cpp
│       │   ├── inspect.hpp
│       │   ├── read_drcov.cpp
│       │   ├── read_drcov.hpp
│       │   ├── read_dump.cpp
│       │   ├── read_dump.hpp
│       │   ├── rewind.cpp
│       │   ├── rewind.hpp
│       │   ├── tracer.cpp
│       │   └── tracer.hpp
│       ├── main.cpp
│       ├── tracer_discovery.cpp
│       └── tracer_discovery.hpp
├── test
│   ├── CMakeLists.txt
│   ├── common
│   │   ├── test_main.cpp
│   │   └── test_paths.hpp
│   ├── p1ll
│   │   ├── CMakeLists.txt
│   │   ├── core
│   │   │   ├── CMakeLists.txt
│   │   │   ├── address_space_test.cpp
│   │   │   ├── apply_test.cpp
│   │   │   ├── pattern_matcher_test.cpp
│   │   │   ├── pattern_test.cpp
│   │   │   ├── plan_builder_test.cpp
│   │   │   ├── platform_test.cpp
│   │   │   ├── scanner_test.cpp
│   │   │   ├── session_test.cpp
│   │   │   ├── test_helpers.hpp
│   │   │   └── test_main.cpp
│   │   └── heur
│   │       ├── CMakeLists.txt
│   │       ├── heur_test.cpp
│   │       └── test_main.cpp
│   ├── w1analysis
│   │   ├── CMakeLists.txt
│   │   ├── abi_dispatcher_test.cpp
│   │   └── symbol_lookup_test.cpp
│   ├── w1asmr
│   │   ├── CMakeLists.txt
│   │   ├── asmr_test.cpp
│   │   └── test_main.cpp
│   ├── w1base
│   │   ├── CMakeLists.txt
│   │   └── interval_test.cpp
│   ├── w1formats
│   │   ├── CMakeLists.txt
│   │   └── jsonl_writer_test.cpp
│   ├── w1h00k
│   │   ├── CMakeLists.txt
│   │   ├── arg_access_tests.cpp
│   │   ├── import_table_tests.cpp
│   │   ├── inline_detour_tests.cpp
│   │   ├── inline_tests.cpp
│   │   ├── instrument_tests.cpp
│   │   ├── interpose_tests.cpp
│   │   ├── memory_tests.cpp
│   │   ├── module_match_tests.cpp
│   │   ├── patcher_tests.cpp
│   │   ├── reloc_tests.cpp
│   │   ├── resolve_tests.cpp
│   │   └── test_main.cpp
│   ├── w1instrument
│   │   ├── CMakeLists.txt
│   │   ├── event_router_test.cpp
│   │   ├── instrumentation_policy_test.cpp
│   │   └── thread_session_simple_test.cpp
│   ├── w1monitor
│   │   ├── CMakeLists.txt
│   │   ├── backend_helpers_tests.cpp
│   │   ├── event_queue_tests.cpp
│   │   ├── monitor_test_helpers.hpp
│   │   ├── monitor_tests.cpp
│   │   ├── monitor_tests_darwin.cpp
│   │   ├── monitor_tests_linux.cpp
│   │   ├── monitor_tests_windows.cpp
│   │   └── test_main.cpp
│   ├── w1replay
│   │   ├── CMakeLists.txt
│   │   ├── e2e
│   │   │   ├── common.py
│   │   │   ├── lldb_flow_e2e_test.py
│   │   │   ├── lldb_state_e2e_test.py
│   │   │   └── trace_e2e_test.py
│   │   ├── gdb_adapter_test.cpp
│   │   ├── gdb_host_process_info_test.cpp
│   │   ├── gdb_layout_test.cpp
│   │   ├── gdb_libraries_component_test.cpp
│   │   ├── gdb_loaded_libraries_test.cpp
│   │   ├── gdb_memory_map_test.cpp
│   │   ├── gdb_memory_read_test.cpp
│   │   ├── gdb_pc_only_test.cpp
│   │   ├── gdb_register_info_test.cpp
│   │   ├── gdb_run_policy_test.cpp
│   │   ├── gdb_stepper_test.cpp
│   │   ├── gdb_target_xml_test.cpp
│   │   ├── gdb_value_codec_test.cpp
│   │   ├── module_address_index_test.cpp
│   │   ├── module_image_test.cpp
│   │   ├── module_path_resolver_test.cpp
│   │   ├── replay_context_test.cpp
│   │   └── test_main.cpp
│   ├── w1rewind
│   │   ├── CMakeLists.txt
│   │   ├── rewind_config_validation_test.cpp
│   │   ├── rewind_flow_extractor_test.cpp
│   │   ├── rewind_history_window_test.cpp
│   │   ├── rewind_memory_filter_test.cpp
│   │   ├── rewind_memory_map_mapping_test.cpp
│   │   ├── rewind_minimal_trace_test.cpp
│   │   ├── rewind_module_event_test.cpp
│   │   ├── rewind_recorder_block_recording_test.cpp
│   │   ├── rewind_recorder_helpers_test.cpp
│   │   ├── rewind_recorder_recording_test.cpp
│   │   ├── rewind_replay_checkpoint_test.cpp
│   │   ├── rewind_replay_cursor_property_test.cpp
│   │   ├── rewind_replay_cursor_semantics_test.cpp
│   │   ├── rewind_replay_cursor_test.cpp
│   │   ├── rewind_replay_instruction_cursor_test.cpp
│   │   ├── rewind_replay_position_test.cpp
│   │   ├── rewind_replay_run_invariants_test.cpp
│   │   ├── rewind_replay_session_position_test.cpp
│   │   ├── rewind_replay_session_test.cpp
│   │   ├── rewind_replay_state_applier_test.cpp
│   │   ├── rewind_replay_state_test.cpp
│   │   ├── rewind_snapshot_codec_test.cpp
│   │   ├── rewind_stack_window_policy_test.cpp
│   │   ├── rewind_test_helpers.hpp
│   │   ├── rewind_trace_index_test.cpp
│   │   └── rewind_trace_io_test.cpp
│   └── w1runtime
│       ├── CMakeLists.txt
│       ├── memory_reader_test.cpp
│       └── module_catalog_test.cpp
├── tests
│   ├── CMakeLists.txt
│   ├── cmake_embed
│   │   └── w1rewind
│   │       ├── CMakeLists.txt
│   │       └── main.cpp
│   ├── harness
│   │   ├── CMakeLists.txt
│   │   ├── test_gadget_executor.cpp
│   │   ├── test_monitor_demo.cpp
│   │   ├── test_rewind_format.cpp
│   │   ├── test_w1cov_components.cpp
│   │   ├── test_w1cov_module_filtering.cpp
│   │   ├── test_w1cov_multithread_demo.cpp
│   │   ├── test_w1cov_single_thread.cpp
│   │   ├── test_w1script.cpp
│   │   ├── test_w1xfer.cpp
│   │   ├── w1cov_demo_lib.hpp
│   │   └── w1cov_test_targets.cpp
│   └── libraries
│       ├── CMakeLists.txt
│       ├── counter_lib.c
│       ├── linux_test_lib.c
│       ├── memory_lib.c
│       ├── tracer_lib.c
│       ├── w1cov_demo_lib.c
│       ├── w1h00k_interpose_lib.c
│       └── w1monitor_thread_lib.c
└── tools
    ├── README.md
    ├── macos_signing
    │   ├── entitlement.xml
    │   ├── genkey.sh
    │   └── sign.sh
    ├── setup_macos.sh
    └── windows
        ├── run_cmd.py
        └── run_dev_command.ps1

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

project(w1tn3ss
    VERSION 0.1.0
    DESCRIPTION "Cross-platform dynamic binary analysis tool"
    LANGUAGES C CXX ASM
)

if(CMAKE_C_COMPILER_ID STREQUAL "GNU" OR CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    message(FATAL_ERROR "GCC is not supported. Configure with Clang instead.")
endif()

include(cmake/W1Init.cmake)
include(cmake/WindowsSymbolConfig.cmake)

function(w1_component_option_name NAME OUT_VAR)
    string(TOUPPER "${NAME}" _upper)
    string(REPLACE "-" "_" _upper "${_upper}")
    set(${OUT_VAR} "W1_BUILD_${_upper}" PARENT_SCOPE)
endfunction()

set(W1_COMPONENTS
    w1base
    w1h00k
    w1monitor
    w1formats
    w1runtime
    w1instrument
    w1analysis
    w1import
    w1dump
    w1gadget
    w1rewind
    tracers
    w1asmr
    p1ll
    p1llx
    w1nj3ct
    w1debugger
    w1tool
    w1replay
    p01s0n
)

set(W1_COMPONENT_DIR_w1base "src/w1base")
set(W1_COMPONENT_DIR_w1h00k "src/w1h00k")
set(W1_COMPONENT_DIR_w1monitor "src/w1monitor")
set(W1_COMPONENT_DIR_w1formats "src/w1formats")
set(W1_COMPONENT_DIR_w1runtime "src/w1runtime")
set(W1_COMPONENT_DIR_w1instrument "src/w1instrument")
set(W1_COMPONENT_DIR_w1analysis "src/w1analysis")
set(W1_COMPONENT_DIR_w1import "src/w1import")
set(W1_COMPONENT_DIR_w1dump "src/w1dump")
set(W1_COMPONENT_DIR_w1gadget "src/w1gadget")
set(W1_COMPONENT_DIR_w1rewind "src/w1rewind")
set(W1_COMPONENT_DIR_tracers "src/tracers")
set(W1_COMPONENT_DIR_w1asmr "src/w1asmr")
set(W1_COMPONENT_DIR_p1ll "src/p1ll")
set(W1_COMPONENT_DIR_p1llx "src/p1llx")
set(W1_COMPONENT_DIR_w1nj3ct "src/w1nj3ct")
set(W1_COMPONENT_DIR_w1debugger "src/w1debugger")
set(W1_COMPONENT_DIR_w1tool "src/w1tool")
set(W1_COMPONENT_DIR_w1replay "src/w1replay")
set(W1_COMPONENT_DIR_p01s0n "src/p01s0n")

set(W1_COMPONENT_DEPS_w1base "")
set(W1_COMPONENT_DEPS_w1h00k "w1base;w1asmr")
set(W1_COMPONENT_DEPS_w1monitor "w1base;w1h00k")
set(W1_COMPONENT_DEPS_w1formats "")
set(W1_COMPONENT_DEPS_w1runtime "")
set(W1_COMPONENT_DEPS_w1instrument "w1runtime;w1base")
set(W1_COMPONENT_DEPS_w1analysis "w1runtime")
set(W1_COMPONENT_DEPS_w1import "")
set(W1_COMPONENT_DEPS_w1dump "w1formats;w1runtime")
set(W1_COMPONENT_DEPS_w1gadget "")
set(W1_COMPONENT_DEPS_w1rewind "w1base")
set(W1_COMPONENT_DEPS_tracers "w1instrument;w1formats;w1analysis;w1rewind;w1dump;w1gadget")
set(W1_COMPONENT_DEPS_w1asmr "w1base")
set(W1_COMPONENT_DEPS_p1ll "w1asmr")
set(W1_COMPONENT_DEPS_p1llx "p1ll;w1base;w1nj3ct")
set(W1_COMPONENT_DEPS_w1nj3ct "")
set(W1_COMPONENT_DEPS_w1debugger "")
set(W1_COMPONENT_DEPS_w1tool "w1base;w1dump;w1formats;w1import;w1nj3ct;w1debugger")
set(W1_COMPONENT_DEPS_w1replay "w1base;w1rewind")
set(W1_COMPONENT_DEPS_p01s0n "p1ll")

foreach(component IN LISTS W1_COMPONENTS)
    w1_component_option_name("${component}" _opt)
    w1_set_cache_default(${_opt} BOOL ${W1_BUILD_ALL} "Build component ${component}")
endforeach()

if(W1_BUILD_W1H00K AND NOT WITNESS_ASMR)
    message(STATUS "Enabling WITNESS_ASMR because w1h00k depends on w1asmr")
    set(WITNESS_ASMR ON CACHE BOOL "Build w1asmr disassembler/assembler" FORCE)
endif()

function(w1_enable_component NAME)
    get_property(_already_set GLOBAL PROPERTY "W1_COMPONENT_ENABLED_${NAME}")
    if(_already_set)
        return()
    endif()
    set_property(GLOBAL PROPERTY "W1_COMPONENT_ENABLED_${NAME}" TRUE)

    foreach(dep IN LISTS W1_COMPONENT_DEPS_${NAME})
        if(dep)
            w1_enable_component("${dep}")
        endif()
    endforeach()

    w1_component_option_name("${NAME}" _opt)
    if(DEFINED ${_opt} AND NOT ${_opt})
        message(STATUS "Enabling ${NAME} because it is required")
    endif()
    set(${_opt} ON CACHE BOOL "Build component ${NAME}" FORCE)

    set(_dir "${W1_COMPONENT_DIR_${NAME}}")
    if(NOT _dir)
        message(FATAL_ERROR "Unknown component directory for ${NAME}")
    endif()

    add_subdirectory("${_dir}")
endfunction()

foreach(component IN LISTS W1_COMPONENTS)
    w1_component_option_name("${component}" _opt)
    if(${_opt})
        w1_enable_component("${component}")
    endif()
endforeach()

if(W1_IS_TOP_LEVEL)
    w1_set_cache_default(BUILD_TESTS BOOL ${W1_BUILD_ALL} "Build test programs and libraries")
    w1_set_cache_default(BUILD_SAMPLES BOOL ${W1_BUILD_ALL} "Build sample programs")
else()
    w1_set_cache_default(BUILD_TESTS BOOL OFF "Build test programs and libraries")
    w1_set_cache_default(BUILD_SAMPLES BOOL OFF "Build sample programs")
endif()

if(BUILD_TESTS)
    enable_testing()
    add_subdirectory(test)
    add_subdirectory(tests)
endif()

if(BUILD_SAMPLES)
    add_subdirectory(samples)
endif()

if(WIN32 AND MSVC)
    apply_windows_symbol_resolution_to_all()
endif()

if(W1_ENABLE_DEV_TOOLS)
    include(cmake/FormattingConfig.cmake)
    include(cmake/TidyConfig.cmake)
endif()

if(W1_IS_TOP_LEVEL AND W1_ENABLE_PACKAGING)
    include(cmake/W1Packaging.cmake)
endif()

```

`README.md`:

```md
# w1tn3ss

a cross-platform framework for binary analysis/instrumentation.
fully supports **linux**, **macos**, **windows** across `x86`, `x64`, and `arm64`.

built to enable flexible auditing, tracing, analysis, instrumentation of binaries across platforms.

highlights:
+ **record-and-replay** (experimental): **record** the execution of a process, and **replay** the trace on any platform; with full time-travel
+ **code coverage**: automatic gathering of code coverage/block hits for any instrumentable binary
+ **declarative patching**: scriptable, ergonomic, declarative binary patching

## features

+ dynamic instrumentation tracers
  + code coverage: `w1cov`
  + record and replay `w1rewind`/`w1replay`
  + call tracing: `w1xfer`
  + scripting: `w1script`
  + memory: `w1mem`
  + process dump: `w1dump`
+ signature scanning and binary patching (`p1ll`/`p1llx`)
+ scriptable with js/lua
+ reusable binary instrumentation infra
  + cross-platform library injection: `w1nj3ct`
  + cross-platform function hooking: `w1h00k`
  + calling convention/abi modeling for many platforms

## build

initialize submodules:
```sh
git submodule update --init --recursive
```

build:
```sh
cmake -G Ninja -B build-release -DCMAKE_BUILD_TYPE=Release
cmake --build build-release --parallel
```

see [doc/build.md](./doc/build.md) for features and platform-specific instructions.

## `w1tool` guide

this is a brief guide to using `w1tool`, a ready-to-use command-line for running tracers

### coverage & tracing

code coverage helps us learn what code in a program gets run and how often. the `w1cov` tracer is purpose-built to collect detailed code coverage information, with only modest performance overhead.

the drcov format is ideal for coverage tracing, as it includes metadata about loaded modules. `w1cov` also supports collecting data in a superset of the drcov format, which also records hit counts of coverage units. this can be useful to record the execution frequency of a block.
my other project [covtool](https://github.com/redthing1/covtool) provides a powerful tool for viewing, editing, and browsing coverage traces.

collect coverage in drcov format using `w1cov`:
```sh
# macos/linux
./build-release/bin/w1tool cover -s ./build-release/bin/samples/programs/simple_demo
# windows
.\build-release\bin\w1tool.exe cover -s .\build-release\bin\samples\programs\simple_demo.exe
```

output will resemble:
```
[w1cov.preload] [inf] coverage data export completed      output_file=simple_demo_coverage.drcov
[w1cov.tracer] [inf] coverage collection completed       coverage_units=59 modules=50 total_hits=71
```

the default block tracing mode is significantly more efficient than per-instruction tracing as it requires less frequent callback interruptions. however, qbdi detects basic blocks dynamically, so recorded block boundaries may differ from those detected by static analysis tools. this usually isn't an issue, as you can script your disassembler to fix any discrepancies when marking basic block coverage.

you can also trace coverage in the same drcov format by passing `--inst` to `cover`, which will use instruction callbacks.

for a more primitive form of tracing which simply records the instruction pointer, use `w1trace`:
```sh
# macos/linux
./build-release/bin/w1tool tracer -n w1trace -c output=simple_demo_trace.txt -s ./build-release/bin/samples/programs/simple_demo
# windows
.\build-release\bin\w1tool.exe tracer -n w1trace -c output=simple_demo_trace.txt -s .\build-release\bin\samples\programs\simple_demo.exe
```

### real-time api call analysis

often it is valuable to learn what system library apis a program calls. for example, we can learn a lot about the behavior of a program by observing its calls to `libc`. the `w1xfer` tracer, powered by qbdi's [`ExecBroker`](https://qbdi.readthedocs.io/en/stable/tutorial_ExecBrokerEvent.html) mechanism, can intercept and observe calls from and returns back to instrumented code.

in addition to detecting calls crossing the instrumentation boundary, `w1xfer` resolves the symbols of these calls, and extracts function arguments based on platform-specific calling convention models. this allows for very rich interception and tracing of the arguments and return values of common library apis.

trace api calls in real time with `w1xfer`:
```sh
# macos/linux
./build-release/bin/w1tool -v tracer -n w1xfer -c analyze_apis=true -c output=test_transfers.jsonl -s ./build-release/bin/samples/programs/simple_demo
# windows
.\build-release\bin\w1tool.exe -v tracer -n w1xfer -c analyze_apis=true -c output=test_transfers.jsonl -s .\build-release\bin\samples\programs\simple_demo.exe
```

output will resemble:
```sh
registered platform conventions     platform=aarch64 count=1
...
call=malloc(size=64) category=Heap module=libsystem_malloc.dylib
return=malloc() = 0x600003b982c0 raw_value=105553178755776 module=libsystem_malloc.dylib
...
call=puts(s="simple demo finished") category=I/O module=libsystem_c.dylib
simple demo finished
return=puts() = 10 raw_value=10 module=libsystem_c.dylib
call=intercept_exit(?) category= module=w1xfer_qbdipreload.dylib
```

as seen above, this can successfully intercept calls to many common `libc` apis!

### scripting

w1tn3ss supports writing custom tracers in luajit through the `w1script` tracer.
scripts can hook various callbacks and directly access vm state, registers, and memory.

here's a simple instruction tracer:
```lua
local instruction_count = 0

local tracer = {}

local function on_instruction(vm, gpr, fpr)
    instruction_count = instruction_count + 1

    local pc = w1.reg.pc(gpr) or 0
    local disasm = w1.inst.disasm(vm) or "<unknown>"

    w1.log.info(w1.util.format_address(pc) .. ": " .. disasm)
    return w1.enum.vm_action.CONTINUE
end

function tracer.init()
    w1.on(w1.event.INSTRUCTION_PRE, on_instruction)
end

function tracer.shutdown()
    w1.log.info("traced " .. instruction_count .. " instructions")
end

return tracer
```

run it:
```sh
# macos/linux
./build-release/bin/w1tool tracer -n w1script -c script=./scripts/w1script/instruction_tracer.lua -s ./build-release/bin/samples/programs/simple_demo
# windows
.\build-release\bin\w1tool.exe tracer -n w1script -c script=./scripts/w1script/instruction_tracer.lua -s .\build-release\bin\samples\programs\simple_demo.exe
```

this will produce a trace of disassembled instructions as they are executed.

see the [example scripts](./scripts/w1script/), which demonstrate memory tracing, coverage collection, and api interception.

## record and replay

the duo `w1rewind` + `w1replay` provides record/replay functionality.
traces can be captured with various levels of detail, trading performance/size for fidelity.

record a rewind trace:
```sh
./build-release/bin/w1tool rewind -s -o /tmp/trace.w1r -- ./build-release/bin/samples/programs/simple_demo
```

inspect:
```sh
./build-release/bin/w1replay inspect -t /tmp/trace.w1r --thread 1 --count 10
```

tips:
- to increase trace detail, use `--flow instruction --reg-deltas --mem-access reads_writes --mem-values`
- to capture stack bytes, use `--stack-window frame --stack-snapshot-interval 1`
- run a gdb rsp server with `w1replay server -t <trace> --gdb 127.0.0.1:5555`

## `p1ll` guide

patching binaries is an essential part of a reversing or cracking workflow. `p1ll` is a portable signature scanning and patching library that can patch binaries statically on disk or dynamically in memory.
`p1llx` provides a nifty command line to run and inspect patches.

### static patching

patch a binary on disk:
```sh
./build-release/bin/p1llx -vv cure -c ./patch_script.lua -i ./target_binary -o ./patched_binary
```

on macos, statically patched binaries require codesigning:
```sh
codesign -fs - ./patched_binary
```

the `d0ct0r.py` script provides intelligent patch development features; it automatically backs up the input file, and handles permissions and codesigning.

### dynamic patching

patch a running process in memory:
```sh
# spawn new process
./build-release/bin/p1llx -vv poison -c ./patch_script.lua -s ./target_binary
# attach to existing process
./build-release/bin/p1llx -vv poison -c ./patch_script.lua -n target_binary
```

### patch scripts

`p1ll` uses scripts to define signatures and patching. this is designed to be used through the declarative `auto_cure` api, which can define platform-specific signatures and patches.

example patch script:
```lua
-- validation signature
local SIG_DEMO_NAME = p1.sig(p1.str2hex("Demo Program"))
-- unique signature for this string
local SIG_ANGERY = p1.sig(p1.str2hex("Angery"), {single = true})

-- find a function by signature (optional module filter)
local SIG_CHECK_LICENSE_WIN_X64 = p1.sig([[
  4885c0          -- test rax, rax
  74??            -- je <offset>
  b001            -- mov al, 1
]], {filter = "demo_program"})

-- patch: fall through the check by nopping it
local FIX_CHECK_LICENSE_WIN_X64 = [[
  ??????
  9090            -- nop nop
  ????
]]

local meta = { -- declarative patch
  name = "demo_program",
  platforms = {"windows:x64"}, -- platforms supported by this patch
  sigs = {
    ["*"] = { -- wildcard signatures are checked on all platforms
      SIG_DEMO_NAME,
      SIG_ANGERY,
    }
  },
  patches = {
    ["windows:x64"] = { -- patch only on windows:x64
        p1.patch(SIG_CHECK_LICENSE_WIN_X64, 0, FIX_CHECK_LICENSE_WIN_X64)
    },
    ["*"] = { -- wildcard patches are used on all platforms
      p1.patch(SIG_ANGERY, 0, p1.str2hex("Happey"))
    }
  }
}

function cure()
  return p1.auto_cure(meta)
end
```

key concepts:
- `p1.sig()`: define byte patterns (with `??` for wildcards)
- `p1.patch()`: specify signature, offset, and replacement
- `meta` table: organize sigs and patches by platform

optional python bindings are available under `src/p1ll/bindings/python`. see the [python bindings guide](./doc/p1ll_python.md) and samples under `scripts/python`.

`p1ll` is an excellent and powerful tool for binary modification!
see the [guide](./doc/p1lljs.md)

## acknowledgements

+ many thanks to quarkslab for [qbdi](https://github.com/QBDI/QBDI) and [lief](https://github.com/lief-project/LIEF).

```

`cmake/AsmrConfig.cmake`:

```cmake
# asmrconfig.cmake - capstone/keystone configuration module
# provides functions for setting up w1asmr dependencies

include_guard()

set(WITNESS_ASMR_CAPSTONE_DIR "${W1_SOURCE_DIR}/src/third_party/capstone" CACHE PATH "capstone source directory")
set(WITNESS_ASMR_KEYSTONE_DIR "${W1_SOURCE_DIR}/src/third_party/keystone" CACHE PATH "keystone source directory")

if(NOT DEFINED WITNESS_ASMR_DISASM_ARCHES)
    set(WITNESS_ASMR_DISASM_ARCHES "X86;AARCH64;ARM;RISCV" CACHE STRING "Capstone disassembly architectures")
endif()
if(NOT DEFINED WITNESS_ASMR_ASM_ARCHES)
    set(WITNESS_ASMR_ASM_ARCHES "X86;AARCH64" CACHE STRING "Keystone assembly architectures")
endif()

function(_witness_normalize_arch_list input_list output_var)
    set(result "")
    foreach(item IN LISTS input_list)
        string(TOUPPER "${item}" item_upper)
        string(STRIP "${item_upper}" item_upper)
        if(item_upper STREQUAL "")
            continue()
        endif()
        if(item_upper STREQUAL "ARM64")
            set(item_upper "AARCH64")
        elseif(item_upper STREQUAL "RISC-V")
            set(item_upper "RISCV")
        elseif(item_upper STREQUAL "S390X" OR item_upper STREQUAL "S390")
            set(item_upper "SYSTEMZ")
        elseif(item_upper STREQUAL "THUMB")
            set(item_upper "ARM")
        endif()
        list(APPEND result "${item_upper}")
    endforeach()
    list(REMOVE_DUPLICATES result)
    set(${output_var} "${result}" PARENT_SCOPE)
endfunction()

function(validate_asmr_submodules)
    if(NOT EXISTS "${WITNESS_ASMR_CAPSTONE_DIR}/CMakeLists.txt")
        message(FATAL_ERROR "capstone submodule not found at ${WITNESS_ASMR_CAPSTONE_DIR}. run: git submodule update --init --recursive")
    endif()
    if(NOT EXISTS "${WITNESS_ASMR_KEYSTONE_DIR}/CMakeLists.txt")
        message(FATAL_ERROR "keystone submodule not found at ${WITNESS_ASMR_KEYSTONE_DIR}. run: git submodule update --init --recursive")
    endif()
endfunction()

function(setup_asmr_environment)
    if(NOT WITNESS_ASMR)
        return()
    endif()

    _witness_normalize_arch_list("${WITNESS_ASMR_DISASM_ARCHES}" _witness_disasm_arches)

    # capstone build options
    set(CAPSTONE_BUILD_SHARED_LIBS OFF CACHE BOOL "disable capstone shared library" FORCE)
    set(CAPSTONE_BUILD_STATIC_LIBS ON CACHE BOOL "enable capstone static library" FORCE)
    set(CAPSTONE_BUILD_CSTOOL OFF CACHE BOOL "disable capstone cstool" FORCE)
    set(CAPSTONE_BUILD_CSTEST OFF CACHE BOOL "disable capstone tests" FORCE)
    set(CAPSTONE_BUILD_LEGACY_TESTS OFF CACHE BOOL "disable capstone legacy tests" FORCE)
    set(CAPSTONE_BUILD_DIET OFF CACHE BOOL "disable capstone diet library" FORCE)
    set(CAPSTONE_ARCHITECTURE_DEFAULT OFF CACHE BOOL "disable capstone default architectures" FORCE)
    set(CAPSTONE_ARM_SUPPORT OFF CACHE BOOL "disable capstone arm support for asmr" FORCE)
    set(CAPSTONE_AARCH64_SUPPORT OFF CACHE BOOL "disable capstone aarch64 support for asmr" FORCE)
    set(CAPSTONE_MIPS_SUPPORT OFF CACHE BOOL "disable capstone mips support for asmr" FORCE)
    set(CAPSTONE_PPC_SUPPORT OFF CACHE BOOL "disable capstone ppc support for asmr" FORCE)
    set(CAPSTONE_X86_SUPPORT OFF CACHE BOOL "disable capstone x86 support for asmr" FORCE)
    set(CAPSTONE_SPARC_SUPPORT OFF CACHE BOOL "disable capstone sparc support for asmr" FORCE)
    set(CAPSTONE_SYSTEMZ_SUPPORT OFF CACHE BOOL "disable capstone systemz support for asmr" FORCE)
    set(CAPSTONE_RISCV_SUPPORT OFF CACHE BOOL "disable capstone riscv support for asmr" FORCE)
    set(CAPSTONE_WASM_SUPPORT OFF CACHE BOOL "disable capstone wasm support for asmr" FORCE)
    foreach(_witness_arch IN LISTS _witness_disasm_arches)
        if(_witness_arch STREQUAL "ARM")
            set(CAPSTONE_ARM_SUPPORT ON CACHE BOOL "enable capstone arm support for asmr" FORCE)
        elseif(_witness_arch STREQUAL "AARCH64")
            set(CAPSTONE_AARCH64_SUPPORT ON CACHE BOOL "enable capstone aarch64 support for asmr" FORCE)
        elseif(_witness_arch STREQUAL "MIPS")
            set(CAPSTONE_MIPS_SUPPORT ON CACHE BOOL "enable capstone mips support for asmr" FORCE)
        elseif(_witness_arch STREQUAL "PPC")
            set(CAPSTONE_PPC_SUPPORT ON CACHE BOOL "enable capstone ppc support for asmr" FORCE)
        elseif(_witness_arch STREQUAL "X86")
            set(CAPSTONE_X86_SUPPORT ON CACHE BOOL "enable capstone x86 support for asmr" FORCE)
        elseif(_witness_arch STREQUAL "SPARC")
            set(CAPSTONE_SPARC_SUPPORT ON CACHE BOOL "enable capstone sparc support for asmr" FORCE)
        elseif(_witness_arch STREQUAL "SYSTEMZ")
            set(CAPSTONE_SYSTEMZ_SUPPORT ON CACHE BOOL "enable capstone systemz support for asmr" FORCE)
        elseif(_witness_arch STREQUAL "RISCV")
            set(CAPSTONE_RISCV_SUPPORT ON CACHE BOOL "enable capstone riscv support for asmr" FORCE)
        elseif(_witness_arch STREQUAL "WASM")
            set(CAPSTONE_WASM_SUPPORT ON CACHE BOOL "enable capstone wasm support for asmr" FORCE)
        else()
            message(WARNING "Unknown disassembly architecture '${_witness_arch}' in WITNESS_ASMR_DISASM_ARCHES")
        endif()
    endforeach()

    # keystone build options
    set(BUILD_LIBS_ONLY ON CACHE BOOL "build keystone library only" FORCE)
    set(KEYSTONE_BUILD_STATIC_RUNTIME ON CACHE BOOL "embed static runtime for keystone" FORCE)
endfunction()

function(configure_asmr_targets)
    if(NOT WITNESS_ASMR)
        return()
    endif()

    if(TARGET capstone_static AND NOT TARGET capstone::capstone)
        add_library(capstone::capstone ALIAS capstone_static)
    elseif(TARGET capstone AND NOT TARGET capstone::capstone)
        add_library(capstone::capstone ALIAS capstone)
    endif()

    if(TARGET keystone AND NOT TARGET keystone::keystone)
        add_library(keystone::keystone ALIAS keystone)
    endif()

    if(TARGET keystone)
        _witness_normalize_arch_list("${WITNESS_ASMR_ASM_ARCHES}" _witness_asm_arches)
        set(_witness_keystone_defs "")
        foreach(_witness_arch IN LISTS _witness_asm_arches)
            if(_witness_arch STREQUAL "AARCH64")
                list(APPEND _witness_keystone_defs
                    LLVMInitializeAArch64TargetInfo=LLVMInitializeAArch64TargetInfo_ks
                    LLVMInitializeAArch64Target=LLVMInitializeAArch64Target_ks
                    LLVMInitializeAArch64TargetMC=LLVMInitializeAArch64TargetMC_ks
                    LLVMInitializeAArch64AsmParser=LLVMInitializeAArch64AsmParser_ks
                )
            elseif(_witness_arch STREQUAL "X86")
                list(APPEND _witness_keystone_defs
                    LLVMInitializeX86TargetInfo=LLVMInitializeX86TargetInfo_ks
                    LLVMInitializeX86Target=LLVMInitializeX86Target_ks
                    LLVMInitializeX86TargetMC=LLVMInitializeX86TargetMC_ks
                    LLVMInitializeX86AsmParser=LLVMInitializeX86AsmParser_ks
                )
            elseif(_witness_arch STREQUAL "ARM")
                list(APPEND _witness_keystone_defs
                    LLVMInitializeARMTargetInfo=LLVMInitializeARMTargetInfo_ks
                    LLVMInitializeARMTarget=LLVMInitializeARMTarget_ks
                    LLVMInitializeARMTargetMC=LLVMInitializeARMTargetMC_ks
                    LLVMInitializeARMAsmParser=LLVMInitializeARMAsmParser_ks
                )
            elseif(_witness_arch STREQUAL "MIPS")
                list(APPEND _witness_keystone_defs
                    LLVMInitializeMipsTargetInfo=LLVMInitializeMipsTargetInfo_ks
                    LLVMInitializeMipsTarget=LLVMInitializeMipsTarget_ks
                    LLVMInitializeMipsTargetMC=LLVMInitializeMipsTargetMC_ks
                    LLVMInitializeMipsAsmParser=LLVMInitializeMipsAsmParser_ks
                )
            elseif(_witness_arch STREQUAL "RISCV")
                list(APPEND _witness_keystone_defs
                    LLVMInitializeRISCVTargetInfo=LLVMInitializeRISCVTargetInfo_ks
                    LLVMInitializeRISCVTarget=LLVMInitializeRISCVTarget_ks
                    LLVMInitializeRISCVTargetMC=LLVMInitializeRISCVTargetMC_ks
                    LLVMInitializeRISCVAsmParser=LLVMInitializeRISCVAsmParser_ks
                )
            else()
                message(WARNING "Unknown assembly architecture '${_witness_arch}' in WITNESS_ASMR_ASM_ARCHES")
            endif()
        endforeach()
        if(_witness_keystone_defs)
            target_compile_definitions(keystone PRIVATE ${_witness_keystone_defs})
        endif()
    endif()
endfunction()

function(configure_asmr_dependencies)
    if(NOT WITNESS_ASMR)
        return()
    endif()

    set(_witness_build_shared_libs_was_set FALSE)
    if(DEFINED BUILD_SHARED_LIBS)
        set(_witness_build_shared_libs_prev "${BUILD_SHARED_LIBS}")
        set(_witness_build_shared_libs_was_set TRUE)
    endif()

    set(_witness_llvm_enable_zlib_was_set FALSE)
    if(DEFINED LLVM_ENABLE_ZLIB)
        set(_witness_llvm_enable_zlib_prev "${LLVM_ENABLE_ZLIB}")
        set(_witness_llvm_enable_zlib_was_set TRUE)
    endif()
    set(_witness_llvm_enable_zstd_was_set FALSE)
    if(DEFINED LLVM_ENABLE_ZSTD)
        set(_witness_llvm_enable_zstd_prev "${LLVM_ENABLE_ZSTD}")
        set(_witness_llvm_enable_zstd_was_set TRUE)
    endif()

    set(_witness_llvm_targets_was_set FALSE)
    if(DEFINED LLVM_TARGETS_TO_BUILD)
        set(_witness_llvm_targets_prev "${LLVM_TARGETS_TO_BUILD}")
        set(_witness_llvm_targets_was_set TRUE)
    endif()
    _witness_normalize_arch_list("${WITNESS_ASMR_ASM_ARCHES}" _witness_asm_arches)
    set(_witness_llvm_targets "")
    foreach(_witness_arch IN LISTS _witness_asm_arches)
        if(_witness_arch STREQUAL "AARCH64")
            list(APPEND _witness_llvm_targets "AArch64")
        elseif(_witness_arch STREQUAL "X86")
            list(APPEND _witness_llvm_targets "X86")
        elseif(_witness_arch STREQUAL "ARM")
            list(APPEND _witness_llvm_targets "ARM")
        elseif(_witness_arch STREQUAL "RISCV")
            list(APPEND _witness_llvm_targets "RISCV")
        elseif(_witness_arch STREQUAL "MIPS")
            list(APPEND _witness_llvm_targets "Mips")
        else()
            message(WARNING "Unknown assembly architecture '${_witness_arch}' in WITNESS_ASMR_ASM_ARCHES")
        endif()
    endforeach()
    if(NOT _witness_llvm_targets)
        list(APPEND _witness_llvm_targets "X86")
        message(WARNING "WITNESS_ASMR_ASM_ARCHES is empty; defaulting LLVM_TARGETS_TO_BUILD to X86")
    endif()
    list(REMOVE_DUPLICATES _witness_llvm_targets)
    string(JOIN ";" _witness_llvm_targets_joined ${_witness_llvm_targets})
    set(LLVM_TARGETS_TO_BUILD "${_witness_llvm_targets_joined}" CACHE STRING "keystone llvm targets" FORCE)

    if(NOT DEFINED CMAKE_POLICY_VERSION_MINIMUM)
        set(CMAKE_POLICY_VERSION_MINIMUM 3.5)
    endif()

    set(LLVM_ENABLE_ZLIB OFF CACHE BOOL "disable zlib for keystone llvm" FORCE)
    set(LLVM_ENABLE_ZSTD OFF CACHE BOOL "disable zstd for keystone llvm" FORCE)
    set(BUILD_SHARED_LIBS OFF CACHE BOOL "force static libs for keystone" FORCE)
    setup_asmr_environment()
    validate_asmr_submodules()

    add_subdirectory("${WITNESS_ASMR_CAPSTONE_DIR}" "${CMAKE_BINARY_DIR}/capstone")

    # Keystone pins CMP0051 to OLD, which newer CMake releases reject.
    # Patch the submodule sources in-place to keep the build compatible.
    set(_witness_keystone_policy_files
        "${WITNESS_ASMR_KEYSTONE_DIR}/CMakeLists.txt"
        "${WITNESS_ASMR_KEYSTONE_DIR}/llvm/CMakeLists.txt"
    )
    foreach(_witness_policy_file IN LISTS _witness_keystone_policy_files)
        if(EXISTS "${_witness_policy_file}")
            file(READ "${_witness_policy_file}" _witness_policy_contents)
            string(REPLACE "cmake_policy(SET CMP0051 OLD)"
                "cmake_policy(SET CMP0051 NEW)"
                _witness_policy_contents
                "${_witness_policy_contents}"
            )
            file(WRITE "${_witness_policy_file}" "${_witness_policy_contents}")
        endif()
    endforeach()

    set(_witness_prev_cxx_standard "${CMAKE_CXX_STANDARD}")
    set(_witness_prev_cxx_standard_required "${CMAKE_CXX_STANDARD_REQUIRED}")
    set(CMAKE_CXX_STANDARD 11)
    set(CMAKE_CXX_STANDARD_REQUIRED ON)
    add_subdirectory("${WITNESS_ASMR_KEYSTONE_DIR}" "${CMAKE_BINARY_DIR}/keystone")
    set(CMAKE_CXX_STANDARD "${_witness_prev_cxx_standard}")
    set(CMAKE_CXX_STANDARD_REQUIRED "${_witness_prev_cxx_standard_required}")

    configure_asmr_targets()

    set(WITNESS_ASMR_CAPSTONE_INCLUDE_DIR "${WITNESS_ASMR_CAPSTONE_DIR}/include" PARENT_SCOPE)
    set(WITNESS_ASMR_KEYSTONE_INCLUDE_DIR "${WITNESS_ASMR_KEYSTONE_DIR}/include" PARENT_SCOPE)

    if(_witness_llvm_targets_was_set)
        set(LLVM_TARGETS_TO_BUILD "${_witness_llvm_targets_prev}" CACHE STRING "restore LLVM_TARGETS_TO_BUILD" FORCE)
    else()
        unset(LLVM_TARGETS_TO_BUILD CACHE)
    endif()

    if(_witness_llvm_enable_zlib_was_set)
        set(LLVM_ENABLE_ZLIB "${_witness_llvm_enable_zlib_prev}" CACHE BOOL "restore LLVM_ENABLE_ZLIB" FORCE)
    else()
        unset(LLVM_ENABLE_ZLIB CACHE)
    endif()
    if(_witness_llvm_enable_zstd_was_set)
        set(LLVM_ENABLE_ZSTD "${_witness_llvm_enable_zstd_prev}" CACHE BOOL "restore LLVM_ENABLE_ZSTD" FORCE)
    else()
        unset(LLVM_ENABLE_ZSTD CACHE)
    endif()

    if(_witness_build_shared_libs_was_set)
        set(BUILD_SHARED_LIBS "${_witness_build_shared_libs_prev}" CACHE BOOL "restore BUILD_SHARED_LIBS" FORCE)
    else()
        unset(BUILD_SHARED_LIBS CACHE)
    endif()
endfunction()

```

`cmake/FormattingConfig.cmake`:

```cmake
if(NOT DEFINED W1_SOURCE_DIR)
    set(W1_SOURCE_DIR "${PROJECT_SOURCE_DIR}")
endif()

find_program(CLANG_FORMAT_EXECUTABLE
    NAMES clang-format clang-format-18 clang-format-17 clang-format-16 clang-format-15
)

if(CLANG_FORMAT_EXECUTABLE)
    file(GLOB_RECURSE ALL_FORMAT_FILES
        "${W1_SOURCE_DIR}/src/w1base/*.cpp" "${W1_SOURCE_DIR}/src/w1base/*.h" "${W1_SOURCE_DIR}/src/w1base/*.hpp" "${W1_SOURCE_DIR}/src/w1base/*.c"
        "${W1_SOURCE_DIR}/src/w1formats/*.cpp" "${W1_SOURCE_DIR}/src/w1formats/*.h" "${W1_SOURCE_DIR}/src/w1formats/*.hpp" "${W1_SOURCE_DIR}/src/w1formats/*.c"
        "${W1_SOURCE_DIR}/src/w1runtime/*.cpp" "${W1_SOURCE_DIR}/src/w1runtime/*.h" "${W1_SOURCE_DIR}/src/w1runtime/*.hpp" "${W1_SOURCE_DIR}/src/w1runtime/*.c"
        "${W1_SOURCE_DIR}/src/w1instrument/*.cpp" "${W1_SOURCE_DIR}/src/w1instrument/*.h" "${W1_SOURCE_DIR}/src/w1instrument/*.hpp" "${W1_SOURCE_DIR}/src/w1instrument/*.c"
        "${W1_SOURCE_DIR}/src/w1analysis/*.cpp" "${W1_SOURCE_DIR}/src/w1analysis/*.h" "${W1_SOURCE_DIR}/src/w1analysis/*.hpp" "${W1_SOURCE_DIR}/src/w1analysis/*.c"
        "${W1_SOURCE_DIR}/src/w1import/*.cpp" "${W1_SOURCE_DIR}/src/w1import/*.h" "${W1_SOURCE_DIR}/src/w1import/*.hpp" "${W1_SOURCE_DIR}/src/w1import/*.c"
        "${W1_SOURCE_DIR}/src/w1dump/*.cpp" "${W1_SOURCE_DIR}/src/w1dump/*.h" "${W1_SOURCE_DIR}/src/w1dump/*.hpp" "${W1_SOURCE_DIR}/src/w1dump/*.c"
        "${W1_SOURCE_DIR}/src/w1gadget/*.cpp" "${W1_SOURCE_DIR}/src/w1gadget/*.h" "${W1_SOURCE_DIR}/src/w1gadget/*.hpp" "${W1_SOURCE_DIR}/src/w1gadget/*.c"
        "${W1_SOURCE_DIR}/src/w1rewind/*.cpp" "${W1_SOURCE_DIR}/src/w1rewind/*.h" "${W1_SOURCE_DIR}/src/w1rewind/*.hpp" "${W1_SOURCE_DIR}/src/w1rewind/*.c"
        "${W1_SOURCE_DIR}/src/w1nj3ct/*.cpp" "${W1_SOURCE_DIR}/src/w1nj3ct/*.h" "${W1_SOURCE_DIR}/src/w1nj3ct/*.hpp" "${W1_SOURCE_DIR}/src/w1nj3ct/*.c"
        "${W1_SOURCE_DIR}/src/w1debugger/*.cpp" "${W1_SOURCE_DIR}/src/w1debugger/*.h" "${W1_SOURCE_DIR}/src/w1debugger/*.hpp" "${W1_SOURCE_DIR}/src/w1debugger/*.c"
        "${W1_SOURCE_DIR}/src/w1tool/*.cpp" "${W1_SOURCE_DIR}/src/w1tool/*.h" "${W1_SOURCE_DIR}/src/w1tool/*.hpp" "${W1_SOURCE_DIR}/src/w1tool/*.c"
        "${W1_SOURCE_DIR}/src/w1replay/*.cpp" "${W1_SOURCE_DIR}/src/w1replay/*.h" "${W1_SOURCE_DIR}/src/w1replay/*.hpp" "${W1_SOURCE_DIR}/src/w1replay/*.c"
        "${W1_SOURCE_DIR}/src/tracers/*.cpp" "${W1_SOURCE_DIR}/src/tracers/*.h" "${W1_SOURCE_DIR}/src/tracers/*.hpp" "${W1_SOURCE_DIR}/src/tracers/*.c"
        "${W1_SOURCE_DIR}/src/p1ll/*.cpp" "${W1_SOURCE_DIR}/src/p1ll/*.h" "${W1_SOURCE_DIR}/src/p1ll/*.hpp" "${W1_SOURCE_DIR}/src/p1ll/*.c"
        "${W1_SOURCE_DIR}/src/p1llx/*.cpp" "${W1_SOURCE_DIR}/src/p1llx/*.h" "${W1_SOURCE_DIR}/src/p1llx/*.hpp" "${W1_SOURCE_DIR}/src/p1llx/*.c"
        "${W1_SOURCE_DIR}/src/p01s0n/*.cpp" "${W1_SOURCE_DIR}/src/p01s0n/*.h" "${W1_SOURCE_DIR}/src/p01s0n/*.hpp" "${W1_SOURCE_DIR}/src/p01s0n/*.c"
        "${W1_SOURCE_DIR}/samples/*.cpp" "${W1_SOURCE_DIR}/samples/*.h" "${W1_SOURCE_DIR}/samples/*.hpp" "${W1_SOURCE_DIR}/samples/*.c"
        "${W1_SOURCE_DIR}/tests/*.cpp" "${W1_SOURCE_DIR}/tests/*.h" "${W1_SOURCE_DIR}/tests/*.hpp" "${W1_SOURCE_DIR}/tests/*.c"
        "${W1_SOURCE_DIR}/test/*.cpp" "${W1_SOURCE_DIR}/test/*.h" "${W1_SOURCE_DIR}/test/*.hpp" "${W1_SOURCE_DIR}/test/*.c"
    )
    
    list(FILTER ALL_FORMAT_FILES EXCLUDE REGEX ".*/build-.*/.*")
    list(FILTER ALL_FORMAT_FILES EXCLUDE REGEX ".*/CMakeFiles/.*")
    
    add_custom_target(w1-format
        COMMAND ${CLANG_FORMAT_EXECUTABLE} -i -style=file ${ALL_FORMAT_FILES}
        WORKING_DIRECTORY ${W1_SOURCE_DIR}
        VERBATIM
    )
    
    add_custom_target(w1-format-check
        COMMAND ${CLANG_FORMAT_EXECUTABLE} --dry-run --Werror -style=file ${ALL_FORMAT_FILES}
        WORKING_DIRECTORY ${W1_SOURCE_DIR}
        VERBATIM
    )
endif()

```

`cmake/LuaJITBuild.cmake`:

```cmake
# luajitbuild.cmake - builds luajit from source using luajit-cmake wrapper
# provides cross-platform luajit static library build

# main function to build luajit static library
function(build_luajit_from_source)
    if(NOT EXISTS "${W1_SOURCE_DIR}/src/third_party/luajit_cmake/CMakeLists.txt")
        message(FATAL_ERROR "luajit-cmake submodule not found. run: git submodule update --init --recursive")
    endif()

    if(NOT EXISTS "${W1_SOURCE_DIR}/src/third_party/luajit/src/lua.h")
        message(FATAL_ERROR "luajit submodule not found. run: git submodule update --init --recursive")
    endif()
    
    # set luajit source directory for luajit-cmake wrapper
    set(LUAJIT_DIR "${W1_SOURCE_DIR}/src/third_party/luajit" CACHE PATH "path to luajit source")
    
    # configure luajit build options
    set(LUAJIT_DISABLE_FFI ${WITNESS_LUAJIT_DISABLE_FFI} CACHE BOOL "disable luajit ffi")
    set(LUAJIT_DISABLE_JIT ${WITNESS_LUAJIT_DISABLE_JIT} CACHE BOOL "disable jit compilation")
    set(LUAJIT_ENABLE_LUA52COMPAT ${WITNESS_LUAJIT_ENABLE_LUA52COMPAT} CACHE BOOL "enable lua 5.2 compatibility")
    set(LUAJIT_BUILD_EXE OFF CACHE BOOL "disable luajit executable build")
    set(LUAJIT_BUILD_ALAMG OFF CACHE BOOL "disable amalgamated build")
    
    # set architecture manually to avoid try_compile issues in cross-compilation
    if(CMAKE_SYSTEM_PROCESSOR MATCHES "aarch64|arm64")
        set(LJ_DETECTED_ARCH "AArch64" CACHE STRING "luajit target architecture")
    elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "x86_64|AMD64")
        set(LJ_DETECTED_ARCH "x86_64" CACHE STRING "luajit target architecture")
    elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "i[3-6]86|x86")
        set(LJ_DETECTED_ARCH "x86" CACHE STRING "luajit target architecture")
    elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "arm")
        set(LJ_DETECTED_ARCH "ARM" CACHE STRING "luajit target architecture")
    endif()
    
    # add luajit-cmake subdirectory with unique binary directory
    add_subdirectory(${W1_SOURCE_DIR}/src/third_party/luajit_cmake ${CMAKE_BINARY_DIR}/witness_luajit)

    if(TARGET libluajit)
        set_target_properties(libluajit PROPERTIES POSITION_INDEPENDENT_CODE ON)
    endif()
    
    # ensure generated headers are available (luajit.h, etc.)
    if(TARGET luajit-header)
        target_include_directories(luajit-header INTERFACE ${CMAKE_BINARY_DIR}/witness_luajit)
    endif()
    
    # export targets and variables for parent scope
    set(LUAJIT_STATIC_TARGET luajit::lib PARENT_SCOPE)
    set(LUAJIT_INCLUDE_DIRS ${LUA_INCLUDE_DIR} PARENT_SCOPE)
    set(LUAJIT_LIBRARIES luajit::lib PARENT_SCOPE)
    
    message(STATUS "configured luajit static library build using luajit-cmake")
endfunction()

```

`cmake/PlatformConfig.cmake`:

```cmake
# platform and architecture detection
include_guard()

# detect platform for qbdi
function(detect_qbdi_platform)
    if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
        set(QBDI_PLATFORM "linux" CACHE STRING "QBDI Platform" FORCE)
    elseif(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
        set(QBDI_PLATFORM "osx" CACHE STRING "QBDI Platform" FORCE)
    elseif(CMAKE_SYSTEM_NAME STREQUAL "Windows")
        set(QBDI_PLATFORM "windows" CACHE STRING "QBDI Platform" FORCE)
    else()
        message(FATAL_ERROR "Unsupported platform: ${CMAKE_SYSTEM_NAME}")
    endif()
    
    message(STATUS "QBDI Platform: ${QBDI_PLATFORM}")
endfunction()

# detect and configure architecture
function(detect_architecture)
    if(NOT DEFINED WITNESS_ARCH OR WITNESS_ARCH STREQUAL "Auto")
        # auto-detect architecture
        if(CMAKE_SYSTEM_PROCESSOR MATCHES "^(x86_64|AMD64)$")
            set(QBDI_ARCH "X86_64" CACHE STRING "QBDI Architecture")
            set(WITNESS_ARCH "x64" CACHE STRING "Witness Architecture")
        elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "^(i386|i686)$")
            set(QBDI_ARCH "X86" CACHE STRING "QBDI Architecture")
            set(WITNESS_ARCH "x86" CACHE STRING "Witness Architecture")
        elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "^(aarch64|arm64)$")
            set(QBDI_ARCH "AARCH64" CACHE STRING "QBDI Architecture")
            set(WITNESS_ARCH "arm64" CACHE STRING "Witness Architecture")
        elseif(CMAKE_SYSTEM_PROCESSOR STREQUAL "arm")
            set(QBDI_ARCH "ARM" CACHE STRING "QBDI Architecture")
            set(WITNESS_ARCH "arm" CACHE STRING "Witness Architecture")
        else()
            message(FATAL_ERROR "Unsupported architecture: ${CMAKE_SYSTEM_PROCESSOR}")
        endif()
        message(STATUS "Auto-detected architecture: ${WITNESS_ARCH}")
    else()
        # user-specified architecture
        if(WITNESS_ARCH STREQUAL "x64")
            set(QBDI_ARCH "X86_64" CACHE STRING "QBDI Architecture")
        elseif(WITNESS_ARCH STREQUAL "x86")
            set(QBDI_ARCH "X86" CACHE STRING "QBDI Architecture")
        elseif(WITNESS_ARCH STREQUAL "arm64")
            set(QBDI_ARCH "AARCH64" CACHE STRING "QBDI Architecture")
        else()
            message(FATAL_ERROR "Invalid WITNESS_ARCH: ${WITNESS_ARCH}. Must be: x64, x86, arm64, Auto")
        endif()
        message(STATUS "User-specified architecture: ${WITNESS_ARCH}")
    endif()
    
    message(STATUS "WITNESS Architecture: ${WITNESS_ARCH}")
    message(STATUS "QBDI Architecture: ${QBDI_ARCH}")
endfunction()

# configure qbdi build options
function(configure_qbdi_options)
    set(QBDI_STATIC_LIBRARY ON PARENT_SCOPE)
    set(QBDI_SHARED_LIBRARY ON PARENT_SCOPE)
    set(QBDI_LOG_DEBUG OFF PARENT_SCOPE)
    set(QBDI_TOOLS_QBDIPRELOAD ON PARENT_SCOPE)
    set(QBDI_CCACHE ON PARENT_SCOPE)
    set(QBDI_DISABLE_AVX OFF PARENT_SCOPE)
    set(QBDI_ASAN OFF PARENT_SCOPE)

    if(WITNESS_QBDI_EXTRAS)
        set(QBDI_TOOLS_PYQBDI ON PARENT_SCOPE)
        set(QBDI_TOOLS_FRIDAQBDI ON PARENT_SCOPE)
        set(QBDI_TEST ON PARENT_SCOPE)
        set(QBDI_EXAMPLES ON PARENT_SCOPE)
        set(QBDI_BENCHMARK ON PARENT_SCOPE)
    else()
        set(QBDI_TOOLS_PYQBDI OFF PARENT_SCOPE)
        set(QBDI_TOOLS_FRIDAQBDI OFF PARENT_SCOPE)
        set(QBDI_TEST OFF PARENT_SCOPE)
        set(QBDI_EXAMPLES ON PARENT_SCOPE)
        set(QBDI_BENCHMARK OFF PARENT_SCOPE)
    endif()
endfunction()
```

`cmake/README_Embed.md`:

```md
# Embedding w1tn3ss components

This repository can be built as a full monorepo, or embedded as a subdirectory where only specific components are enabled. The embedding flow avoids pulling heavy dependencies unless the selected components need them.

## Embed only w1rewind

Add the repo root as a subdirectory, disable the full build, and enable the component you need.

Example CMakeLists.txt:

    cmake_minimum_required(VERSION 3.16)
    project(my_embed LANGUAGES CXX)

    set(W1_BUILD_ALL OFF CACHE BOOL "" FORCE)
    set(W1_BUILD_W1REWIND ON CACHE BOOL "" FORCE)
    add_subdirectory(path/to/w1tn3ss w1tn3ss_build)

    add_executable(my_app main.cpp)
    target_link_libraries(my_app PRIVATE w1::rewind::replay)

Targets provided:

- w1::rewind::format (alias: w1rewind::format)
- w1::rewind::record (alias: w1rewind::record)
- w1::rewind::replay (alias: w1rewind::replay)

## Embed the full repository but select components

Add the repo as a subdirectory and explicitly enable the components you need. When w1tn3ss is a subproject, all components default to OFF.

Example:

    set(W1_BUILD_ALL OFF CACHE BOOL "" FORCE)
    set(W1_BUILD_W1REWIND ON CACHE BOOL "" FORCE)
    set(W1_BUILD_W1REPLAY ON CACHE BOOL "" FORCE)
    add_subdirectory(path/to/w1tn3ss w1tn3ss_build)

Component options are named W1_BUILD_<COMPONENT>, where <COMPONENT> matches the directory name (uppercased). For example, W1_BUILD_W1REWIND, W1_BUILD_W1RUNTIME, W1_BUILD_TRACERS, and W1_BUILD_P1LL.

## Notes

- Heavy dependencies like QBDI and LIEF are only configured when a component that needs them is enabled.
- Use W1_USE_SYSTEM_DEPS=ON to prefer system-installed dependencies via find_package.

```

`cmake/README_Lua.md`:

```md
# WITNESS Lua/Sol2 Integration

This directory contains a clean, cross-platform Lua/sol2 integration for WITNESS projects.

## Overview

- **LuaJIT**: Built from source using `luajit-cmake` wrapper for cross-platform compatibility
- **sol2**: Header-only C++ library for elegant Lua bindings
- **Static linking**: No runtime dependencies
- **Optional**: Easily enabled/disabled with `WITNESS_SCRIPT` option

## Files

- `LuaJITBuild.cmake` - LuaJIT build system using luajit-cmake wrapper (used internally by w1tn3ss)

## Usage

### For new projects (inside w1tn3ss)

Enable scripting and link to the Lua interface target:

```cmake
set(WITNESS_SCRIPT ON CACHE BOOL "" FORCE)
add_subdirectory(path/to/w1tn3ss w1tn3ss_build)

target_link_libraries(my_target PRIVATE w1::lua)
```

### Configuration options:

```bash
# Enable Lua scripting support
cmake -DWITNESS_SCRIPT=ON ...

# Optional LuaJIT configuration
cmake -DWITNESS_SCRIPT=ON \
      -DWITNESS_LUAJIT_DISABLE_FFI=OFF \
      -DWITNESS_LUAJIT_DISABLE_JIT=OFF \
      -DWITNESS_LUAJIT_ENABLE_LUA52COMPAT=OFF \
      ...
```

## Dependencies

Required submodules (auto-checked):
- `src/third_party/luajit` - LuaJIT source code
- `src/third_party/luajit_cmake` - CMake wrapper for LuaJIT  
- `src/third_party/sol2` - sol2 header library

Initialize with: `git submodule update --init --recursive`

## Example Usage in Code

```cpp
#ifdef WITNESS_SCRIPT_ENABLED
#include <sol/sol.hpp>

void init_lua() {
    sol::state lua;
    lua.open_libraries(sol::lib::base, sol::lib::package);
    lua["hello"] = []() { return "Hello from Lua!"; };
}
#endif
```

```

`cmake/SampleConfig.cmake`:

```cmake
# shared helpers for sample programs
include_guard()

if(NOT COMMAND w1_target_defaults)
    include("${CMAKE_CURRENT_LIST_DIR}/W1Init.cmake")
endif()

function(w1_add_sample_program target)
    set(options)
    set(one_value_args OUTPUT_DIR)
    set(multi_value_args SOURCES)
    cmake_parse_arguments(W1 "${options}" "${one_value_args}" "${multi_value_args}" ${ARGN})

    if(NOT W1_SOURCES)
        message(FATAL_ERROR "w1_add_sample_program requires SOURCES")
    endif()

    add_executable(${target} ${W1_SOURCES})
    w1_register_target(${target})
    w1_target_defaults(${target})

    set(sample_output_dir "${W1_OUTPUT_SAMPLE_DIR}")
    if(W1_OUTPUT_DIR)
        set(sample_output_dir "${W1_OUTPUT_DIR}")
    endif()

    set_target_properties(${target} PROPERTIES
        RUNTIME_OUTPUT_DIRECTORY ${sample_output_dir}
    )
endfunction()

function(w1_apply_debug_sanitizers target)
    if(CMAKE_BUILD_TYPE STREQUAL "Debug" AND NOT WIN32)
        target_compile_options(${target} PRIVATE ${SANITIZER_FLAGS})
        target_link_options(${target} PRIVATE ${SANITIZER_FLAGS})
    endif()
endfunction()

function(w1_apply_debug_sanitizers_to_targets)
    foreach(target IN LISTS ARGN)
        w1_apply_debug_sanitizers(${target})
    endforeach()
endfunction()

```

`cmake/TestConfig.cmake`:

```cmake
# shared helpers for test targets
include_guard()

if(NOT COMMAND w1_target_defaults)
    include("${CMAKE_CURRENT_LIST_DIR}/W1Init.cmake")
endif()

function(w1_resolve_test_output_dir out_var output_subdir)
    set(output_dir "${W1_OUTPUT_TEST_DIR}")
    if(output_subdir)
        if(IS_ABSOLUTE "${output_subdir}")
            set(output_dir "${output_subdir}")
        else()
            set(output_dir "${W1_OUTPUT_TEST_DIR}/${output_subdir}")
        endif()
    endif()
    set(${out_var} "${output_dir}" PARENT_SCOPE)
endfunction()

function(w1_set_test_output_dirs target output_subdir)
    w1_resolve_test_output_dir(output_dir "${output_subdir}")

    set_target_properties(${target} PROPERTIES
        LIBRARY_OUTPUT_DIRECTORY ${output_dir}
        RUNTIME_OUTPUT_DIRECTORY ${output_dir}
        ARCHIVE_OUTPUT_DIRECTORY ${output_dir}
    )
endfunction()

function(w1_disable_sanitizers target)
    if(CMAKE_BUILD_TYPE STREQUAL "Debug" AND NOT WIN32)
        target_compile_options(${target} PRIVATE -fno-sanitize=all)
        target_link_options(${target} PRIVATE -fno-sanitize=all)
    endif()
endfunction()

function(w1_add_doctest_suite target)
    set(options)
    set(one_value_args OUTPUT_SUBDIR)
    set(multi_value_args SOURCES LIBS INCLUDE_DIRS)
    cmake_parse_arguments(W1 "${options}" "${one_value_args}" "${multi_value_args}" ${ARGN})

    if(NOT W1_SOURCES)
        message(FATAL_ERROR "w1_add_doctest_suite requires SOURCES")
    endif()

    add_executable(${target} ${W1_SOURCES})
    w1_register_target(${target})
    if(W1_INCLUDE_DIRS)
        target_include_directories(${target} PRIVATE ${W1_INCLUDE_DIRS})
    endif()
    if(W1_LIBS)
        target_link_libraries(${target} PRIVATE ${W1_LIBS})
    endif()

    w1_apply_test_defaults(${target})
    w1_set_test_output_dirs(${target} "${W1_OUTPUT_SUBDIR}")

    w1_resolve_test_output_dir(_w1_working_dir "${W1_OUTPUT_SUBDIR}")

    add_test(
        NAME ${target}
        COMMAND ${target}
        WORKING_DIRECTORY ${_w1_working_dir}
    )
endfunction()

function(w1_add_harness_test target)
    set(options)
    set(one_value_args OUTPUT_SUBDIR)
    set(multi_value_args SOURCES LIBS INCLUDE_DIRS ARGS)
    cmake_parse_arguments(W1 "${options}" "${one_value_args}" "${multi_value_args}" ${ARGN})

    if(NOT W1_SOURCES)
        message(FATAL_ERROR "w1_add_harness_test requires SOURCES")
    endif()

    add_executable(${target} ${W1_SOURCES})
    w1_register_target(${target})
    if(W1_INCLUDE_DIRS)
        target_include_directories(${target} PRIVATE ${W1_INCLUDE_DIRS})
    endif()
    if(W1_LIBS)
        target_link_libraries(${target} PRIVATE ${W1_LIBS})
    endif()

    w1_apply_test_defaults(${target})
    w1_set_test_output_dirs(${target} "${W1_OUTPUT_SUBDIR}")

    w1_resolve_test_output_dir(_w1_working_dir "${W1_OUTPUT_SUBDIR}")

    if(W1_ARGS)
        add_test(
            NAME ${target}
            COMMAND ${target} ${W1_ARGS}
            WORKING_DIRECTORY ${_w1_working_dir}
        )
    else()
        add_test(
            NAME ${target}
            COMMAND ${target}
            WORKING_DIRECTORY ${_w1_working_dir}
        )
    endif()
endfunction()

```

`cmake/TidyConfig.cmake`:

```cmake
include_guard()

# detect homebrew llvm on macos
if(APPLE)
    execute_process(
        COMMAND brew --prefix llvm
        OUTPUT_VARIABLE HOMEBREW_LLVM_PREFIX
        OUTPUT_STRIP_TRAILING_WHITESPACE
        ERROR_QUIET
    )
    if(HOMEBREW_LLVM_PREFIX)
        set(CLANG_TIDY_SEARCH_PATHS "${HOMEBREW_LLVM_PREFIX}/bin")
    endif()
endif()

if(NOT DEFINED W1_SOURCE_DIR)
    set(W1_SOURCE_DIR "${PROJECT_SOURCE_DIR}")
endif()

if(NOT DEFINED W1_ENABLE_CLANG_TIDY)
    option(W1_ENABLE_CLANG_TIDY "Enable clang-tidy for w1 targets" ON)
endif()

find_program(CLANG_TIDY_EXECUTABLE
    NAMES clang-tidy clang-tidy-18 clang-tidy-17 clang-tidy-16 clang-tidy-15
    PATHS ${CLANG_TIDY_SEARCH_PATHS}
)

if(CLANG_TIDY_EXECUTABLE)
    if(NOT DEFINED W1_CLANG_TIDY_COMMAND)
        set(W1_CLANG_TIDY_COMMAND "${CLANG_TIDY_EXECUTABLE};--format-style=file")
    endif()

    if(NOT DEFINED W1_CLANG_TIDY_EXCLUDE_DIRS)
        set(_w1_default_tidy_excludes "${W1_SOURCE_DIR}/src/third_party")
        if(EXISTS "${_w1_default_tidy_excludes}")
            set(W1_CLANG_TIDY_EXCLUDE_DIRS "${_w1_default_tidy_excludes}")
        else()
            set(W1_CLANG_TIDY_EXCLUDE_DIRS "")
        endif()
    endif()

    if(NOT COMMAND w1_apply_clang_tidy)
        function(w1_apply_clang_tidy TARGET_NAME)
            if(NOT W1_ENABLE_CLANG_TIDY)
                return()
            endif()

            if(NOT W1_CLANG_TIDY_COMMAND)
                return()
            endif()

            get_target_property(_w1_aliased ${TARGET_NAME} ALIASED_TARGET)
            if(_w1_aliased)
                return()
            endif()

            get_target_property(_w1_imported ${TARGET_NAME} IMPORTED)
            if(_w1_imported)
                return()
            endif()

            get_target_property(_w1_target_type ${TARGET_NAME} TYPE)
            if(_w1_target_type STREQUAL "INTERFACE_LIBRARY" OR _w1_target_type STREQUAL "UTILITY")
                return()
            endif()

            get_target_property(_w1_skip_tidy ${TARGET_NAME} W1_CLANG_TIDY_SKIP)
            if(_w1_skip_tidy)
                return()
            endif()

            get_target_property(_w1_target_source_dir ${TARGET_NAME} SOURCE_DIR)
            if(_w1_target_source_dir AND W1_CLANG_TIDY_EXCLUDE_DIRS)
                file(TO_CMAKE_PATH "${_w1_target_source_dir}" _w1_target_source_dir_norm)
                foreach(_w1_exclude_dir IN LISTS W1_CLANG_TIDY_EXCLUDE_DIRS)
                    if(NOT _w1_exclude_dir)
                        continue()
                    endif()
                    file(TO_CMAKE_PATH "${_w1_exclude_dir}" _w1_exclude_dir_norm)
                    set(_w1_exclude_dir_norm "${_w1_exclude_dir_norm}/")
                    set(_w1_target_source_dir_check "${_w1_target_source_dir_norm}/")
                    string(FIND "${_w1_target_source_dir_check}" "${_w1_exclude_dir_norm}" _w1_exclude_idx)
                    if(_w1_exclude_idx EQUAL 0)
                        return()
                    endif()
                endforeach()
            endif()

            set_target_properties(${TARGET_NAME} PROPERTIES
                C_CLANG_TIDY "${W1_CLANG_TIDY_COMMAND}"
                CXX_CLANG_TIDY "${W1_CLANG_TIDY_COMMAND}"
            )
        endfunction()
    endif()

    # enable compile commands database for better analysis
    set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
    
    file(GLOB_RECURSE ALL_TIDY_FILES
        "${W1_SOURCE_DIR}/src/w1base/*.cpp" "${W1_SOURCE_DIR}/src/w1base/*.hpp"
        "${W1_SOURCE_DIR}/src/w1formats/*.cpp" "${W1_SOURCE_DIR}/src/w1formats/*.hpp"
        "${W1_SOURCE_DIR}/src/w1runtime/*.cpp" "${W1_SOURCE_DIR}/src/w1runtime/*.hpp"
        "${W1_SOURCE_DIR}/src/w1instrument/*.cpp" "${W1_SOURCE_DIR}/src/w1instrument/*.hpp"
        "${W1_SOURCE_DIR}/src/w1analysis/*.cpp" "${W1_SOURCE_DIR}/src/w1analysis/*.hpp"
        "${W1_SOURCE_DIR}/src/w1import/*.cpp" "${W1_SOURCE_DIR}/src/w1import/*.hpp"
        "${W1_SOURCE_DIR}/src/w1dump/*.cpp" "${W1_SOURCE_DIR}/src/w1dump/*.hpp"
        "${W1_SOURCE_DIR}/src/w1gadget/*.cpp" "${W1_SOURCE_DIR}/src/w1gadget/*.hpp"
        "${W1_SOURCE_DIR}/src/w1rewind/*.cpp" "${W1_SOURCE_DIR}/src/w1rewind/*.hpp"
        "${W1_SOURCE_DIR}/src/w1nj3ct/*.cpp" "${W1_SOURCE_DIR}/src/w1nj3ct/*.hpp"
        "${W1_SOURCE_DIR}/src/w1debugger/*.cpp" "${W1_SOURCE_DIR}/src/w1debugger/*.hpp"
        "${W1_SOURCE_DIR}/src/w1tool/*.cpp" "${W1_SOURCE_DIR}/src/w1tool/*.hpp"
        "${W1_SOURCE_DIR}/src/w1replay/*.cpp" "${W1_SOURCE_DIR}/src/w1replay/*.hpp"
        "${W1_SOURCE_DIR}/src/tracers/*.cpp" "${W1_SOURCE_DIR}/src/tracers/*.hpp"
        "${W1_SOURCE_DIR}/src/p1ll/*.cpp" "${W1_SOURCE_DIR}/src/p1ll/*.hpp"
        "${W1_SOURCE_DIR}/src/p1llx/*.cpp" "${W1_SOURCE_DIR}/src/p1llx/*.hpp"
        "${W1_SOURCE_DIR}/src/p01s0n/*.cpp" "${W1_SOURCE_DIR}/src/p01s0n/*.hpp"
        "${W1_SOURCE_DIR}/samples/*.cpp" "${W1_SOURCE_DIR}/samples/*.hpp"
        "${W1_SOURCE_DIR}/tests/*.cpp" "${W1_SOURCE_DIR}/tests/*.hpp"
        "${W1_SOURCE_DIR}/test/*.cpp" "${W1_SOURCE_DIR}/test/*.hpp"
    )
    
    list(FILTER ALL_TIDY_FILES EXCLUDE REGEX ".*/build-.*/.*")
    list(FILTER ALL_TIDY_FILES EXCLUDE REGEX ".*/CMakeFiles/.*")
    
    # use compile commands database if available, fallback to manual includes
    if(EXISTS "${CMAKE_BINARY_DIR}/compile_commands.json")
        add_custom_target(w1-tidy
            COMMAND ${CLANG_TIDY_EXECUTABLE} --fix --format-style=file -p ${CMAKE_BINARY_DIR} ${ALL_TIDY_FILES}
            WORKING_DIRECTORY ${W1_SOURCE_DIR}
            VERBATIM
        )
        
        add_custom_target(w1-tidy-check
            COMMAND ${CLANG_TIDY_EXECUTABLE} -p ${CMAKE_BINARY_DIR} ${ALL_TIDY_FILES}
            WORKING_DIRECTORY ${W1_SOURCE_DIR}
            VERBATIM
        )
    else()
        add_custom_target(w1-tidy
            COMMAND ${CLANG_TIDY_EXECUTABLE} --fix --format-style=file ${ALL_TIDY_FILES}
            WORKING_DIRECTORY ${W1_SOURCE_DIR}
            VERBATIM
        )
        
        add_custom_target(w1-tidy-check
            COMMAND ${CLANG_TIDY_EXECUTABLE} ${ALL_TIDY_FILES}
            WORKING_DIRECTORY ${W1_SOURCE_DIR}
            VERBATIM
        )
    endif()

    get_property(_w1_all_targets GLOBAL PROPERTY TARGETS)
    foreach(_w1_target IN LISTS _w1_all_targets)
        w1_apply_clang_tidy(${_w1_target})
    endforeach()
endif()

```

`cmake/W1CompilerCache.cmake`:

```cmake
# compiler cache selection for w1tn3ss
include_guard()

if(NOT W1_ENABLE_COMPILER_CACHE)
    return()
endif()

if(CMAKE_C_COMPILER_LAUNCHER OR CMAKE_CXX_COMPILER_LAUNCHER)
    message(STATUS "Compiler launcher already set; skipping w1 cache")
    return()
endif()

set(_w1_cache "")
if(WIN32)
    find_program(_w1_cache sccache)
    if(NOT _w1_cache)
        find_program(_w1_cache ccache)
    endif()
else()
    find_program(_w1_cache ccache)
    if(NOT _w1_cache)
        find_program(_w1_cache sccache)
    endif()
endif()

if(_w1_cache)
    set(CMAKE_C_COMPILER_LAUNCHER "${_w1_cache}" CACHE STRING "C compiler cache" FORCE)
    set(CMAKE_CXX_COMPILER_LAUNCHER "${_w1_cache}" CACHE STRING "CXX compiler cache" FORCE)
    set(QBDI_CCACHE OFF CACHE BOOL "Enable QBDI ccache" FORCE)
    set(LIEF_USE_CCACHE OFF CACHE BOOL "Use ccache for LIEF" FORCE)
    message(STATUS "Compiler cache: ${_w1_cache}")
else()
    message(STATUS "Compiler cache requested but not found")
endif()

```

`cmake/W1Deps.cmake`:

```cmake
# dependency setup for w1tn3ss
include_guard()

include(FetchContent)

if(NOT DEFINED W1_SOURCE_DIR)
    set(W1_SOURCE_DIR "${PROJECT_SOURCE_DIR}")
endif()

if(NOT COMMAND w1_set_cache_default)
    include("${CMAKE_CURRENT_LIST_DIR}/W1Options.cmake")
endif()

function(w1_dep_redlog)
    if(TARGET redlog::redlog)
        return()
    endif()

    if(W1_USE_SYSTEM_DEPS)
        find_package(redlog CONFIG QUIET)
        if(TARGET redlog::redlog)
            return()
        endif()
    endif()

    if(NOT EXISTS "${W1_SOURCE_DIR}/src/third_party/redlog_cpp/CMakeLists.txt")
        message(FATAL_ERROR "redlog_cpp submodule not found at ${W1_SOURCE_DIR}/src/third_party/redlog_cpp. Run: git submodule update --init --recursive")
    endif()

    w1_set_cache_default(REDLOG_BUILD_EXAMPLES BOOL OFF "Build redlog examples")
    w1_set_cache_default(REDLOG_BUILD_TESTS BOOL OFF "Build redlog tests")

    FetchContent_Declare(redlog_cpp SOURCE_DIR "${W1_SOURCE_DIR}/src/third_party/redlog_cpp")
    FetchContent_MakeAvailable(redlog_cpp)
endfunction()

function(w1_dep_nlohmann_json)
    if(TARGET nlohmann_json::nlohmann_json)
        return()
    endif()

    if(W1_USE_SYSTEM_DEPS)
        find_package(nlohmann_json CONFIG QUIET)
        if(TARGET nlohmann_json::nlohmann_json)
            return()
        endif()
    endif()

    if(NOT EXISTS "${W1_SOURCE_DIR}/src/third_party/nlohmann_json/CMakeLists.txt")
        message(FATAL_ERROR "nlohmann_json submodule not found at ${W1_SOURCE_DIR}/src/third_party/nlohmann_json. Run: git submodule update --init --recursive")
    endif()

    w1_set_cache_default(JSON_BuildTests BOOL OFF "Build nlohmann_json tests")

    FetchContent_Declare(nlohmann_json SOURCE_DIR "${W1_SOURCE_DIR}/src/third_party/nlohmann_json")
    FetchContent_MakeAvailable(nlohmann_json)
endfunction()

function(w1_dep_gdbstub)
    if(TARGET gdbstub::gdbstub)
        return()
    endif()

    if(W1_USE_SYSTEM_DEPS)
        find_package(gdbstub_cpp CONFIG QUIET)
        if(TARGET gdbstub::gdbstub)
            return()
        endif()
    endif()

    if(NOT EXISTS "${W1_SOURCE_DIR}/src/third_party/gdbstub_cpp/CMakeLists.txt")
        message(FATAL_ERROR "gdbstub_cpp submodule not found at ${W1_SOURCE_DIR}/src/third_party/gdbstub_cpp. Run: git submodule update --init --recursive")
    endif()

    w1_set_cache_default(GDBSTUB_BUILD_TESTS BOOL OFF "Build gdbstub_cpp tests")

    FetchContent_Declare(gdbstub_cpp SOURCE_DIR "${W1_SOURCE_DIR}/src/third_party/gdbstub_cpp")
    FetchContent_MakeAvailable(gdbstub_cpp)

    if(TARGET gdbstub AND NOT TARGET gdbstub::gdbstub)
        add_library(gdbstub::gdbstub ALIAS gdbstub)
    endif()
endfunction()

function(w1_dep_plthook)
    if(TARGET plthook::plthook)
        return()
    endif()

    if(W1_USE_SYSTEM_DEPS)
        find_package(plthook CONFIG QUIET)
        if(TARGET plthook::plthook)
            return()
        endif()
    endif()

    if(NOT EXISTS "${W1_SOURCE_DIR}/src/third_party/plthook/CMakeLists.txt")
        message(FATAL_ERROR "plthook submodule not found at ${W1_SOURCE_DIR}/src/third_party/plthook. Run: git submodule update --init --recursive")
    endif()

    w1_set_cache_default(PLTHOOK_BUILD_TESTS BOOL OFF "Build plthook tests")

    FetchContent_Declare(plthook SOURCE_DIR "${W1_SOURCE_DIR}/src/third_party/plthook")
    FetchContent_MakeAvailable(plthook)

    if(TARGET plthook AND NOT TARGET plthook::plthook)
        add_library(plthook::plthook ALIAS plthook)
    endif()
endfunction()

function(w1_dep_funchook)
    if(NOT WIN32)
        return()
    endif()

    if(TARGET funchook::funchook)
        return()
    endif()

    if(W1_USE_SYSTEM_DEPS)
        find_package(funchook CONFIG QUIET)
        if(TARGET funchook::funchook)
            return()
        endif()
    endif()

    if(NOT EXISTS "${W1_SOURCE_DIR}/src/third_party/funchook/CMakeLists.txt")
        message(FATAL_ERROR "funchook submodule not found at ${W1_SOURCE_DIR}/src/third_party/funchook. Run: git submodule update --init --recursive")
    endif()

    w1_set_cache_default(FUNCHOOK_BUILD_TESTS BOOL OFF "Build funchook tests")
    w1_set_cache_default(FUNCHOOK_BUILD_SHARED BOOL OFF "Build funchook shared library")
    w1_set_cache_default(FUNCHOOK_BUILD_STATIC BOOL ON "Build funchook static library")

    FetchContent_Declare(funchook SOURCE_DIR "${W1_SOURCE_DIR}/src/third_party/funchook")
    FetchContent_MakeAvailable(funchook)

    if(TARGET funchook-static AND NOT TARGET funchook::funchook)
        add_library(funchook::funchook ALIAS funchook-static)
    elseif(TARGET funchook-shared AND NOT TARGET funchook::funchook)
        add_library(funchook::funchook ALIAS funchook-shared)
    endif()
endfunction()

function(w1_dep_qbdi)
    if(TARGET QBDI_static OR TARGET QBDI::QBDI)
        return()
    endif()

    if(W1_USE_SYSTEM_DEPS)
        find_package(QBDI CONFIG QUIET)
        if(TARGET QBDI_static OR TARGET QBDI::QBDI)
            return()
        endif()
    endif()

    if(NOT EXISTS "${W1_SOURCE_DIR}/src/third_party/qbdi/CMakeLists.txt")
        message(FATAL_ERROR "QBDI submodule not found at ${W1_SOURCE_DIR}/src/third_party/qbdi. Run: git submodule update --init --recursive")
    endif()

    include("${W1_CMAKE_DIR}/PlatformConfig.cmake")
    detect_qbdi_platform()
    detect_architecture()

    w1_set_cache_default(QBDI_SHARED_LIBRARY BOOL OFF "Build QBDI shared library")
    w1_set_cache_default(QBDI_STATIC_LIBRARY BOOL ON "Build QBDI static library")

    if(WITNESS_QBDI_EXTRAS)
        w1_set_cache_default(QBDI_TEST BOOL ON "Build QBDI tests")
        w1_set_cache_default(QBDI_EXAMPLES BOOL ON "Build QBDI examples")
        w1_set_cache_default(QBDI_BENCHMARK BOOL ON "Build QBDI benchmark")
        w1_set_cache_default(QBDI_TOOLS_PYQBDI BOOL ON "Build pyqbdi")
        w1_set_cache_default(QBDI_TOOLS_FRIDAQBDI BOOL ON "Build frida-qbdi")
    else()
        w1_set_cache_default(QBDI_TEST BOOL OFF "Build QBDI tests")
        w1_set_cache_default(QBDI_EXAMPLES BOOL OFF "Build QBDI examples")
        w1_set_cache_default(QBDI_BENCHMARK BOOL OFF "Build QBDI benchmark")
        w1_set_cache_default(QBDI_TOOLS_PYQBDI BOOL OFF "Build pyqbdi")
        w1_set_cache_default(QBDI_TOOLS_FRIDAQBDI BOOL OFF "Build frida-qbdi")
    endif()

    w1_set_cache_default(QBDI_TOOLS_QBDIPRELOAD BOOL ON "Build QBDIPreload")
    w1_set_cache_default(QBDI_LOG_DEBUG BOOL OFF "Enable QBDI debug logging")
    w1_set_cache_default(QBDI_CCACHE BOOL ON "Enable QBDI ccache")
    w1_set_cache_default(QBDI_DISABLE_AVX BOOL OFF "Disable AVX in QBDI")
    w1_set_cache_default(QBDI_ASAN BOOL OFF "Enable QBDI ASAN")
    w1_set_cache_default(QBDI_INCLUDE_DOCS BOOL OFF "Enable QBDI docs")

    FetchContent_Declare(qbdi SOURCE_DIR "${W1_SOURCE_DIR}/src/third_party/qbdi")
    FetchContent_MakeAvailable(qbdi)

    get_directory_property(_w1_qbdi_targets DIRECTORY "${W1_SOURCE_DIR}/src/third_party/qbdi" BUILDSYSTEM_TARGETS)
    foreach(_target IN LISTS _w1_qbdi_targets)
        if(TARGET ${_target})
            set_property(TARGET ${_target} PROPERTY CXX_STANDARD 17)
            set_property(TARGET ${_target} PROPERTY CXX_STANDARD_REQUIRED ON)
        endif()
    endforeach()

    if(NOT TARGET QBDI_static)
        message(FATAL_ERROR "QBDI_static target not found. QBDI static library is required.")
    endif()

    if(NOT TARGET QBDI::QBDI)
        add_library(QBDI::QBDI ALIAS QBDI_static)
    endif()
endfunction()

function(w1_dep_lief)
    if(TARGET w1::lief)
        return()
    endif()

    add_library(w1_lief INTERFACE)
    add_library(w1::lief ALIAS w1_lief)

    if(NOT WITNESS_LIEF)
        return()
    endif()

    if(W1_USE_SYSTEM_DEPS)
        find_package(LIEF CONFIG QUIET)
        if(TARGET LIEF::LIEF)
            target_link_libraries(w1_lief INTERFACE LIEF::LIEF)
            target_compile_definitions(w1_lief INTERFACE WITNESS_LIEF_ENABLED=1)
            return()
        endif()
    endif()

    if(NOT EXISTS "${W1_SOURCE_DIR}/src/third_party/lief/CMakeLists.txt")
        message(FATAL_ERROR "LIEF submodule not found at ${W1_SOURCE_DIR}/src/third_party/lief. Run: git submodule update --init --recursive")
    endif()

    w1_set_cache_default(LIEF_EXAMPLES BOOL OFF "Disable LIEF examples")
    w1_set_cache_default(LIEF_TESTS BOOL OFF "Disable LIEF tests")
    w1_set_cache_default(LIEF_PYTHON_API BOOL OFF "Disable LIEF Python API")
    w1_set_cache_default(LIEF_C_API BOOL OFF "Disable LIEF C API")
    w1_set_cache_default(LIEF_RUST_API BOOL OFF "Disable LIEF Rust API")
    w1_set_cache_default(LIEF_LOGGING BOOL OFF "Disable LIEF logging")
    w1_set_cache_default(LIEF_ENABLE_JSON BOOL OFF "Disable LIEF JSON")

    FetchContent_Declare(lief SOURCE_DIR "${W1_SOURCE_DIR}/src/third_party/lief")
    FetchContent_MakeAvailable(lief)

    get_directory_property(_w1_lief_targets DIRECTORY "${W1_SOURCE_DIR}/src/third_party/lief" BUILDSYSTEM_TARGETS)
    foreach(_target IN LISTS _w1_lief_targets)
        if(TARGET ${_target})
            set_property(TARGET ${_target} PROPERTY CXX_STANDARD 17)
            set_property(TARGET ${_target} PROPERTY CXX_STANDARD_REQUIRED ON)
        endif()
    endforeach()

    if(TARGET LIEF::LIEF)
        target_link_libraries(w1_lief INTERFACE LIEF::LIEF)
        target_compile_definitions(w1_lief INTERFACE WITNESS_LIEF_ENABLED=1)
    endif()
endfunction()

function(w1_dep_asmr)
    if(NOT WITNESS_ASMR)
        return()
    endif()

    if(TARGET w1::asmr_deps)
        return()
    endif()

    include("${W1_CMAKE_DIR}/AsmrConfig.cmake")
    configure_asmr_dependencies()

    if(TARGET capstone::capstone AND TARGET keystone::keystone)
        add_library(w1_asmr_deps INTERFACE)
        add_library(w1::asmr_deps ALIAS w1_asmr_deps)
        target_link_libraries(w1_asmr_deps INTERFACE capstone::capstone keystone::keystone)
        target_compile_definitions(w1_asmr_deps INTERFACE WITNESS_ASMR_ENABLED=1)

        if(DEFINED WITNESS_ASMR_CAPSTONE_DIR)
            target_include_directories(w1_asmr_deps INTERFACE "${WITNESS_ASMR_CAPSTONE_DIR}/include")
        endif()
        if(DEFINED WITNESS_ASMR_KEYSTONE_DIR)
            target_include_directories(w1_asmr_deps INTERFACE "${WITNESS_ASMR_KEYSTONE_DIR}/include")
        endif()
    endif()
endfunction()

function(w1_dep_lua)
    if(NOT WITNESS_SCRIPT)
        return()
    endif()

    if(TARGET w1::lua)
        return()
    endif()

    include("${W1_CMAKE_DIR}/LuaJITBuild.cmake")

    if(NOT EXISTS "${W1_SOURCE_DIR}/src/third_party/sol2/include/sol/sol.hpp")
        message(FATAL_ERROR "sol2 submodule not found at ${W1_SOURCE_DIR}/src/third_party/sol2. Run: git submodule update --init --recursive")
    endif()

    build_luajit_from_source()

    add_library(w1_lua INTERFACE)
    add_library(w1::lua ALIAS w1_lua)
    target_include_directories(w1_lua INTERFACE
        "${W1_SOURCE_DIR}/src/third_party/lua_headers"
        "${W1_SOURCE_DIR}/src/third_party/sol2/include"
        ${LUAJIT_INCLUDE_DIRS}
    )
    target_link_libraries(w1_lua INTERFACE ${LUAJIT_LIBRARIES} luajit::header)
    target_compile_definitions(w1_lua INTERFACE
        SOL_NO_LUA_HPP=1
        WITNESS_SCRIPT_ENABLED=1
    )
endfunction()

function(w1_dep_jnjs)
    if(NOT WITNESS_SCRIPT)
        return()
    endif()

    if(NOT WITNESS_SCRIPT_ENGINE STREQUAL "js")
        return()
    endif()

    if(TARGET w1::jnjs)
        return()
    endif()

    if(W1_USE_SYSTEM_DEPS)
        find_package(jnjs CONFIG QUIET)
        if(TARGET jnjs)
            add_library(w1_jnjs INTERFACE)
            add_library(w1::jnjs ALIAS w1_jnjs)
            target_link_libraries(w1_jnjs INTERFACE jnjs)
            target_compile_definitions(w1_jnjs INTERFACE WITNESS_SCRIPT_ENABLED=1)
            return()
        endif()
    endif()

    if(NOT EXISTS "${W1_SOURCE_DIR}/src/third_party/jnjs/CMakeLists.txt")
        message(FATAL_ERROR "jnjs submodule not found at ${W1_SOURCE_DIR}/src/third_party/jnjs. Run: git submodule update --init --recursive")
    endif()

    w1_set_cache_default(JNJS_ENABLE_TESTING BOOL OFF "Disable jnjs tests")

    FetchContent_Declare(jnjs SOURCE_DIR "${W1_SOURCE_DIR}/src/third_party/jnjs")
    FetchContent_MakeAvailable(jnjs)

    if(TARGET jnjs)
        add_library(w1_jnjs INTERFACE)
        add_library(w1::jnjs ALIAS w1_jnjs)
        target_link_libraries(w1_jnjs INTERFACE jnjs)
        target_compile_definitions(w1_jnjs INTERFACE WITNESS_SCRIPT_ENABLED=1)
    endif()
endfunction()

function(w1_dep_zstd)
    if(TARGET w1::zstd)
        return()
    endif()

    add_library(w1_zstd INTERFACE)
    add_library(w1::zstd ALIAS w1_zstd)

    if(NOT W1_USE_SYSTEM_ZSTD)
        return()
    endif()

    set(_w1_zstd_found FALSE)

    find_package(zstd CONFIG QUIET)
    if(TARGET zstd::libzstd OR TARGET zstd::libzstd_static)
        set(_w1_zstd_found TRUE)
    endif()

    if(NOT _w1_zstd_found)
        find_package(ZSTD QUIET)
        if(ZSTD_FOUND OR TARGET ZSTD::ZSTD OR TARGET zstd::libzstd OR TARGET zstd::libzstd_static)
            set(_w1_zstd_found TRUE)
        endif()
    endif()

    if(NOT _w1_zstd_found)
        if(W1_REQUIRE_ZSTD)
            message(FATAL_ERROR "ZSTD requested but not found (set ZSTD_DIR or disable W1_USE_SYSTEM_ZSTD)")
        else()
            message(STATUS "ZSTD not found; rewind compression disabled")
        endif()
        return()
    endif()

    if(W1_PREFER_STATIC_ZSTD AND TARGET zstd::libzstd_static)
        target_link_libraries(w1_zstd INTERFACE zstd::libzstd_static)
    elseif(TARGET zstd::libzstd)
        target_link_libraries(w1_zstd INTERFACE zstd::libzstd)
        if(W1_PREFER_STATIC_ZSTD)
            message(STATUS "ZSTD static target not found; using zstd::libzstd")
        endif()
    elseif(TARGET ZSTD::ZSTD)
        target_link_libraries(w1_zstd INTERFACE ZSTD::ZSTD)
        if(W1_PREFER_STATIC_ZSTD)
            message(STATUS "ZSTD static target not found; using ZSTD::ZSTD")
        endif()
    elseif(TARGET zstd::libzstd_shared)
        target_link_libraries(w1_zstd INTERFACE zstd::libzstd_shared)
    elseif(ZSTD_LIBRARIES)
        target_link_libraries(w1_zstd INTERFACE ${ZSTD_LIBRARIES})
    endif()

    if(ZSTD_INCLUDE_DIRS)
        target_include_directories(w1_zstd INTERFACE ${ZSTD_INCLUDE_DIRS})
    endif()

    target_compile_definitions(w1_zstd INTERFACE W1_REWIND_HAVE_ZSTD=1)
endfunction()

```

`cmake/W1Init.cmake`:

```cmake
# entry point for w1tn3ss CMake configuration
include_guard()

include("${CMAKE_CURRENT_LIST_DIR}/W1Options.cmake")
include("${CMAKE_CURRENT_LIST_DIR}/W1CompilerCache.cmake")
include("${CMAKE_CURRENT_LIST_DIR}/W1Deps.cmake")
include("${CMAKE_CURRENT_LIST_DIR}/W1Targets.cmake")

```

`cmake/W1Options.cmake`:

```cmake
# shared options and target defaults for w1tn3ss
include_guard()

set(W1_SOURCE_DIR "${PROJECT_SOURCE_DIR}")
set(W1_CMAKE_DIR "${PROJECT_SOURCE_DIR}/cmake")

set(W1_IS_TOP_LEVEL FALSE)
if(PROJECT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
    set(W1_IS_TOP_LEVEL TRUE)
endif()

function(w1_set_cache_default VAR TYPE VALUE DOC)
    if(NOT DEFINED ${VAR})
        set(${VAR} "${VALUE}" CACHE ${TYPE} "${DOC}")
    endif()
endfunction()

option(W1_USE_SYSTEM_DEPS "Prefer system dependencies via find_package" OFF)
option(W1_BUILD_ALL "Build all w1tn3ss components" ${W1_IS_TOP_LEVEL})

option(WITNESS_BUILD_STATIC "Build static libraries" ON)
option(WITNESS_BUILD_SHARED "Build shared libraries" ON)
option(WITNESS_QBDI_EXTRAS "Build QBDI examples/tests/tools" OFF)

option(WITNESS_LIEF "Enable LIEF support" ON)
option(WITNESS_ASMR "Build w1asmr disassembler/assembler" OFF)
option(WITNESS_SCRIPT "Enable scripting support" OFF)
set(WITNESS_SCRIPT_ENGINE "lua" CACHE STRING "Script engine to use (lua or js)")
set_property(CACHE WITNESS_SCRIPT_ENGINE PROPERTY STRINGS "lua" "js")

option(WITNESS_LUAJIT_DISABLE_FFI "Disable luajit ffi support" OFF)
option(WITNESS_LUAJIT_DISABLE_JIT "Disable jit compilation" OFF)
option(WITNESS_LUAJIT_ENABLE_LUA52COMPAT "Enable lua 5.2 compatibility features" OFF)

if(W1_IS_TOP_LEVEL)
    w1_set_cache_default(W1_ENABLE_DEV_TOOLS BOOL ON "Enable formatting and tidy helpers")
    w1_set_cache_default(W1_EXPORT_COMPILE_COMMANDS BOOL ON "Generate compile_commands.json")
    w1_set_cache_default(W1_ENABLE_PACKAGING BOOL ON "Enable packaging support")
    w1_set_cache_default(W1_ENABLE_COMPILER_CACHE BOOL ON "Enable compiler caching (sccache/ccache)")
else()
    w1_set_cache_default(W1_ENABLE_DEV_TOOLS BOOL OFF "Enable formatting and tidy helpers")
    w1_set_cache_default(W1_EXPORT_COMPILE_COMMANDS BOOL OFF "Generate compile_commands.json")
    w1_set_cache_default(W1_ENABLE_PACKAGING BOOL OFF "Enable packaging support")
    w1_set_cache_default(W1_ENABLE_COMPILER_CACHE BOOL OFF "Enable compiler caching (sccache/ccache)")
endif()

if(W1_ENABLE_DEV_TOOLS)
    w1_set_cache_default(W1_ENABLE_CLANG_TIDY BOOL ON "Enable clang-tidy for w1 targets")
else()
    w1_set_cache_default(W1_ENABLE_CLANG_TIDY BOOL OFF "Enable clang-tidy for w1 targets")
endif()

if(NOT DEFINED W1_CLANG_TIDY_EXCLUDE_DIRS)
    set(_w1_default_tidy_excludes "${W1_SOURCE_DIR}/src/third_party")
    if(EXISTS "${_w1_default_tidy_excludes}")
        set(W1_CLANG_TIDY_EXCLUDE_DIRS "${_w1_default_tidy_excludes}" CACHE STRING "Directories excluded from clang-tidy")
    else()
        set(W1_CLANG_TIDY_EXCLUDE_DIRS "" CACHE STRING "Directories excluded from clang-tidy")
    endif()
endif()

if(W1_EXPORT_COMPILE_COMMANDS)
    set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
endif()

w1_set_cache_default(W1_INSTALL_COMPONENT STRING "w1" "Install component name for w1tn3ss artifacts")
w1_set_cache_default(W1_TESTS_COMPONENT STRING "tests" "Install component name for test artifacts")
w1_set_cache_default(W1_USE_SYSTEM_ZSTD BOOL ON "Use system Zstd when available (adds runtime dependency)")
w1_set_cache_default(W1_PREFER_STATIC_ZSTD BOOL ON "Prefer static Zstd when available")
w1_set_cache_default(W1_REQUIRE_ZSTD BOOL OFF "Fail configuration if Zstd requested but not found")
w1_set_cache_default(W1_STATIC_MSVC_RUNTIME BOOL ON "Use static MSVC runtime on Windows")

if(MSVC AND W1_STATIC_MSVC_RUNTIME)
    set(_w1_msvc_runtime "MultiThreaded$<$<CONFIG:Debug>:Debug>")
    set(CMAKE_MSVC_RUNTIME_LIBRARY "${_w1_msvc_runtime}" CACHE STRING "MSVC runtime library" FORCE)
endif()

w1_set_cache_default(W1_OUTPUT_BIN_DIR PATH "${CMAKE_BINARY_DIR}/bin" "Output directory for executables")
w1_set_cache_default(W1_OUTPUT_LIB_DIR PATH "${CMAKE_BINARY_DIR}/lib" "Output directory for libraries")
w1_set_cache_default(W1_OUTPUT_TEST_DIR PATH "${CMAKE_BINARY_DIR}/test" "Output directory for test binaries")
w1_set_cache_default(W1_OUTPUT_SAMPLE_DIR PATH "${CMAKE_BINARY_DIR}/bin/samples" "Output directory for sample binaries")

add_library(w1_config INTERFACE)
add_library(w1::config ALIAS w1_config)

target_compile_features(w1_config INTERFACE cxx_std_20)

if(WIN32)
    target_compile_definitions(w1_config INTERFACE
        NOMINMAX
        WIN32_LEAN_AND_MEAN
        _CRT_SECURE_NO_WARNINGS
    )
    target_link_libraries(w1_config INTERFACE psapi kernel32 user32)
elseif(UNIX AND NOT APPLE)
    target_link_libraries(w1_config INTERFACE dl)
endif()

add_library(w1_warnings INTERFACE)
add_library(w1::warnings ALIAS w1_warnings)

target_compile_options(w1_warnings INTERFACE
    $<$<CXX_COMPILER_ID:GNU,Clang,AppleClang>:-Wall;-Wextra>
    $<$<CXX_COMPILER_ID:MSVC>:/EHsc>
)

function(w1_apply_clang_tidy TARGET_NAME)
    if(NOT W1_ENABLE_CLANG_TIDY)
        return()
    endif()

    if(NOT W1_CLANG_TIDY_COMMAND)
        return()
    endif()

    get_target_property(_w1_aliased ${TARGET_NAME} ALIASED_TARGET)
    if(_w1_aliased)
        return()
    endif()

    get_target_property(_w1_imported ${TARGET_NAME} IMPORTED)
    if(_w1_imported)
        return()
    endif()

    get_target_property(_w1_target_type ${TARGET_NAME} TYPE)
    if(_w1_target_type STREQUAL "INTERFACE_LIBRARY" OR _w1_target_type STREQUAL "UTILITY")
        return()
    endif()

    get_target_property(_w1_skip_tidy ${TARGET_NAME} W1_CLANG_TIDY_SKIP)
    if(_w1_skip_tidy)
        return()
    endif()

    get_target_property(_w1_target_source_dir ${TARGET_NAME} SOURCE_DIR)
    if(_w1_target_source_dir AND W1_CLANG_TIDY_EXCLUDE_DIRS)
        file(TO_CMAKE_PATH "${_w1_target_source_dir}" _w1_target_source_dir_norm)
        foreach(_w1_exclude_dir IN LISTS W1_CLANG_TIDY_EXCLUDE_DIRS)
            if(NOT _w1_exclude_dir)
                continue()
            endif()
            file(TO_CMAKE_PATH "${_w1_exclude_dir}" _w1_exclude_dir_norm)
            set(_w1_exclude_dir_norm "${_w1_exclude_dir_norm}/")
            set(_w1_target_source_dir_check "${_w1_target_source_dir_norm}/")
            string(FIND "${_w1_target_source_dir_check}" "${_w1_exclude_dir_norm}" _w1_exclude_idx)
            if(_w1_exclude_idx EQUAL 0)
                return()
            endif()
        endforeach()
    endif()

    set_target_properties(${TARGET_NAME} PROPERTIES
        C_CLANG_TIDY "${W1_CLANG_TIDY_COMMAND}"
        CXX_CLANG_TIDY "${W1_CLANG_TIDY_COMMAND}"
    )
endfunction()

function(w1_target_defaults TARGET_NAME)
    target_link_libraries(${TARGET_NAME} PUBLIC w1::config)
    target_link_libraries(${TARGET_NAME} PRIVATE w1::warnings)
    w1_apply_clang_tidy(${TARGET_NAME})
endfunction()

```

`cmake/W1Packaging.cmake`:

```cmake
# packaging configuration for w1tn3ss
include_guard()

include(GNUInstallDirs)

if(NOT DEFINED CMAKE_INSTALL_DEFAULT_COMPONENT_NAME OR CMAKE_INSTALL_DEFAULT_COMPONENT_NAME STREQUAL "")
    set(CMAKE_INSTALL_DEFAULT_COMPONENT_NAME "third_party" CACHE STRING "Default install component name" FORCE)
endif()

if(EXISTS "${PROJECT_SOURCE_DIR}/scripts")
    install(DIRECTORY "${PROJECT_SOURCE_DIR}/scripts/"
        DESTINATION "${CMAKE_INSTALL_DATADIR}/w1tn3ss/scripts"
        COMPONENT ${W1_INSTALL_COMPONENT}
        USE_SOURCE_PERMISSIONS
        PATTERN "__pycache__" EXCLUDE
        PATTERN "*.pyc" EXCLUDE
        PATTERN "*.pyo" EXCLUDE
    )
endif()

set(CPACK_PACKAGE_NAME "${PROJECT_NAME}")
set(CPACK_PACKAGE_VENDOR "w1tn3ss")
set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "${PROJECT_DESCRIPTION}")
set(CPACK_PACKAGE_VERSION "${PROJECT_VERSION}")
set(CPACK_GENERATOR "ZIP")
set(CPACK_INCLUDE_TOPLEVEL_DIRECTORY ON)

string(TOLOWER "${CMAKE_SYSTEM_NAME}" _w1_pkg_os)
set(_w1_pkg_arch "${WITNESS_ARCH}")
if(NOT _w1_pkg_arch)
    set(_w1_pkg_arch "${CMAKE_SYSTEM_PROCESSOR}")
endif()
string(TOLOWER "${_w1_pkg_arch}" _w1_pkg_arch)
set(CPACK_PACKAGE_FILE_NAME "${CPACK_PACKAGE_NAME}-${CPACK_PACKAGE_VERSION}-${_w1_pkg_os}-${_w1_pkg_arch}")

set(CPACK_COMPONENTS_ALL "${W1_INSTALL_COMPONENT}")
set(CPACK_INSTALL_CMAKE_PROJECTS "${CMAKE_BINARY_DIR};${PROJECT_NAME};${W1_INSTALL_COMPONENT};/")

include(CPack)

```

`cmake/W1Targets.cmake`:

```cmake
# target helper functions for w1tn3ss
include_guard()

if(NOT DEFINED W1_SOURCE_DIR)
    set(W1_SOURCE_DIR "${PROJECT_SOURCE_DIR}")
endif()

if(NOT COMMAND w1_target_defaults)
    include("${CMAKE_CURRENT_LIST_DIR}/W1Options.cmake")
endif()

function(w1_register_target TARGET_NAME)
    if(COMMAND w1_register_target_for_symbol_resolution)
        w1_register_target_for_symbol_resolution(${TARGET_NAME})
    endif()
endfunction()

function(w1_apply_component_defaults TARGET_NAME)
    w1_target_defaults(${TARGET_NAME})

    target_include_directories(${TARGET_NAME}
        PUBLIC $<BUILD_INTERFACE:${W1_SOURCE_DIR}/src>
        PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}
    )

    set_target_properties(${TARGET_NAME} PROPERTIES
        ARCHIVE_OUTPUT_DIRECTORY ${W1_OUTPUT_LIB_DIR}
        LIBRARY_OUTPUT_DIRECTORY ${W1_OUTPUT_LIB_DIR}
        RUNTIME_OUTPUT_DIRECTORY ${W1_OUTPUT_LIB_DIR}
        POSITION_INDEPENDENT_CODE ON
    )
endfunction()

function(w1_apply_executable_defaults TARGET_NAME)
    w1_target_defaults(${TARGET_NAME})

    target_include_directories(${TARGET_NAME}
        PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}
    )

    set_target_properties(${TARGET_NAME} PROPERTIES
        RUNTIME_OUTPUT_DIRECTORY ${W1_OUTPUT_BIN_DIR}
    )
endfunction()

function(w1_add_static_library TARGET_NAME)
    add_library(${TARGET_NAME} STATIC ${ARGN})
    w1_apply_component_defaults(${TARGET_NAME})
    w1_register_target(${TARGET_NAME})
endfunction()

function(w1_add_shared_library TARGET_NAME)
    add_library(${TARGET_NAME} SHARED ${ARGN})
    w1_apply_component_defaults(${TARGET_NAME})
    w1_register_target(${TARGET_NAME})
endfunction()

function(w1_add_executable TARGET_NAME)
    add_executable(${TARGET_NAME} ${ARGN})
    w1_apply_executable_defaults(${TARGET_NAME})
    w1_register_target(${TARGET_NAME})
endfunction()

function(w1_apply_test_defaults TARGET_NAME)
    w1_apply_executable_defaults(${TARGET_NAME})
    set_target_properties(${TARGET_NAME} PROPERTIES
        RUNTIME_OUTPUT_DIRECTORY ${W1_OUTPUT_TEST_DIR}
    )
endfunction()

function(w1_add_test_executable TARGET_NAME)
    add_executable(${TARGET_NAME} ${ARGN})
    w1_apply_test_defaults(${TARGET_NAME})
    w1_register_target(${TARGET_NAME})
endfunction()

```

`cmake/W1Tracers.cmake`:

```cmake
# helper functions for tracer libraries
include_guard()

if(NOT DEFINED W1_SOURCE_DIR)
    set(W1_SOURCE_DIR "${PROJECT_SOURCE_DIR}")
endif()

if(NOT COMMAND w1_target_defaults)
    include("${CMAKE_CURRENT_LIST_DIR}/W1Init.cmake")
endif()

function(w1_configure_tracer_target TARGET_NAME)
    target_include_directories(${TARGET_NAME} PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}
        ${W1_SOURCE_DIR}/src/third_party/qbdi/tools/QBDIPreload/include
    )

    target_link_libraries(${TARGET_NAME} PUBLIC
        w1instrument
        QBDI::QBDI
    )

    if(${TARGET_NAME} MATCHES "_qbdipreload$")
        if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
            target_link_options(${TARGET_NAME} PRIVATE "LINKER:--whole-archive,$<TARGET_FILE:QBDI_static>,--no-whole-archive")
        elseif(CMAKE_SYSTEM_NAME STREQUAL "Windows")
            target_link_options(${TARGET_NAME} PRIVATE "/WHOLEARCHIVE:$<TARGET_FILE:QBDI_static>")
        endif()

        if(TARGET QBDIPreload)
            target_link_libraries(${TARGET_NAME} PRIVATE QBDIPreload)
        endif()
    endif()

    w1_target_defaults(${TARGET_NAME})

    set_target_properties(${TARGET_NAME} PROPERTIES PREFIX "")
    set_target_properties(${TARGET_NAME} PROPERTIES
        ARCHIVE_OUTPUT_DIRECTORY ${W1_OUTPUT_LIB_DIR}
        LIBRARY_OUTPUT_DIRECTORY ${W1_OUTPUT_LIB_DIR}
        RUNTIME_OUTPUT_DIRECTORY ${W1_OUTPUT_LIB_DIR}
    )
    if(APPLE)
        set_target_properties(${TARGET_NAME} PROPERTIES MACOSX_RPATH TRUE)
    endif()
endfunction()

function(w1_add_tracer TRACER_NAME)
    set(options)
    set(one_value_args)
    set(multi_value_args SOURCES LIBS)
    cmake_parse_arguments(W1 "${options}" "${one_value_args}" "${multi_value_args}" ${ARGN})

    if(NOT W1_SOURCES)
        message(FATAL_ERROR "w1_add_tracer requires SOURCES")
    endif()

    if(WITNESS_BUILD_SHARED)
        add_library(${TRACER_NAME}_qbdipreload SHARED ${W1_SOURCES})
        w1_register_target(${TRACER_NAME}_qbdipreload)
        w1_configure_tracer_target(${TRACER_NAME}_qbdipreload)
        if(W1_LIBS)
            target_link_libraries(${TRACER_NAME}_qbdipreload PUBLIC ${W1_LIBS})
        endif()

        install(TARGETS ${TRACER_NAME}_qbdipreload
            RUNTIME DESTINATION lib COMPONENT ${W1_INSTALL_COMPONENT}
            LIBRARY DESTINATION lib COMPONENT ${W1_INSTALL_COMPONENT}
            ARCHIVE DESTINATION lib COMPONENT ${W1_INSTALL_COMPONENT}
        )
    endif()

    if(WITNESS_BUILD_STATIC)
        add_library(${TRACER_NAME}_static STATIC ${W1_SOURCES})
        w1_register_target(${TRACER_NAME}_static)
        w1_configure_tracer_target(${TRACER_NAME}_static)
        if(W1_LIBS)
            target_link_libraries(${TRACER_NAME}_static PUBLIC ${W1_LIBS})
        endif()
    endif()
endfunction()

```

`cmake/WindowsSymbolConfig.cmake`:

```cmake
# WindowsSymbolConfig.cmake - Windows-specific symbol conflict resolution
# handles duplicate symbol issues that occur on Windows MSVC but not on Unix platforms

include_guard()

set(_W1_QBDI_LINK_HINTS
    "QBDI"         # QBDI_static, QBDI::QBDI, QBDIPreload
    "w1cov"
    "w1dump"
    "w1rewind"
    "w1xfer"
    "w1script"
    "w1mem"
    "w1trace"
)

set(_W1_LIEF_LINK_HINTS
    "LIEF"         # LIEF::LIEF or LIEF.lib
    "w1::lief"
    "w1_lief"
    "w1import"
)

function(_w1_normalize_link_item ITEM OUT_VAR)
    set(_value "${ITEM}")
    if(_value MATCHES "^\\$<LINK_ONLY:(.+)>$")
        set(_value "${CMAKE_MATCH_1}")
    elseif(_value MATCHES "^\\$<TARGET_NAME_IF_EXISTS:([^>]+)>$")
        set(_value "${CMAKE_MATCH_1}")
    elseif(_value MATCHES "^\\$<TARGET_OBJECTS:([^>]+)>$")
        set(_value "${CMAKE_MATCH_1}")
    endif()
    set(${OUT_VAR} "${_value}" PARENT_SCOPE)
endfunction()

function(_w1_target_has_link_hint_impl TARGET_NAME OUT_VAR)
    set(options)
    set(one_value_args)
    set(multi_value_args PATTERNS VISITED)
    cmake_parse_arguments(W1 "${options}" "${one_value_args}" "${multi_value_args}" ${ARGN})

    if(TARGET_NAME IN_LIST W1_VISITED)
        set(${OUT_VAR} FALSE PARENT_SCOPE)
        return()
    endif()
    list(APPEND W1_VISITED ${TARGET_NAME})

    foreach(_prop IN ITEMS LINK_LIBRARIES INTERFACE_LINK_LIBRARIES)
        get_target_property(_libs ${TARGET_NAME} ${_prop})
        if(NOT _libs OR _libs STREQUAL "${_prop}-NOTFOUND")
            continue()
        endif()
        foreach(_lib IN LISTS _libs)
            _w1_normalize_link_item("${_lib}" _norm)
            foreach(_pattern IN LISTS W1_PATTERNS)
                if(_norm MATCHES "${_pattern}")
                    set(${OUT_VAR} TRUE PARENT_SCOPE)
                    return()
                endif()
            endforeach()

            if(TARGET ${_norm})
                get_target_property(_aliased ${_norm} ALIASED_TARGET)
                if(_aliased)
                    set(_norm ${_aliased})
                endif()
                _w1_target_has_link_hint_impl(${_norm} _child
                    PATTERNS ${W1_PATTERNS}
                    VISITED ${W1_VISITED}
                )
                if(_child)
                    set(${OUT_VAR} TRUE PARENT_SCOPE)
                    return()
                endif()
            endif()
        endforeach()
    endforeach()

    set(${OUT_VAR} FALSE PARENT_SCOPE)
endfunction()

function(_w1_target_has_link_hint TARGET_NAME OUT_VAR)
    _w1_target_has_link_hint_impl(${TARGET_NAME} _hint_found PATTERNS ${ARGN})
    set(${OUT_VAR} ${_hint_found} PARENT_SCOPE)
endfunction()

# configure Windows-specific linker options to handle duplicate symbols
function(configure_windows_symbol_resolution TARGET_NAME)
    if(NOT (WIN32 AND MSVC))
        return()
    endif()

    _w1_target_has_link_hint(${TARGET_NAME} _w1_has_qbdi ${_W1_QBDI_LINK_HINTS})
    _w1_target_has_link_hint(${TARGET_NAME} _w1_has_lief ${_W1_LIEF_LINK_HINTS})

    if(_w1_has_qbdi AND _w1_has_lief)
        message(STATUS "applying fmt conflict resolution for ${TARGET_NAME}")
        # allow first definition to win for duplicates between bundled fmt variants
        target_link_options(${TARGET_NAME} PRIVATE /FORCE:MULTIPLE)
    endif()
endfunction()

function(w1_register_target_for_symbol_resolution TARGET_NAME)
    set_property(GLOBAL APPEND PROPERTY W1_WINDOWS_SYMBOL_TARGETS ${TARGET_NAME})
endfunction()

function(apply_windows_symbol_resolution_to_all)
    get_property(targets GLOBAL PROPERTY W1_WINDOWS_SYMBOL_TARGETS)
    if(NOT targets)
        return()
    endif()
    list(REMOVE_DUPLICATES targets)

    foreach(target IN LISTS targets)
        # only apply to executable and library targets
        get_target_property(target_type ${target} TYPE)
        if(target_type MATCHES "EXECUTABLE|SHARED_LIBRARY|MODULE_LIBRARY|STATIC_LIBRARY")
            configure_windows_symbol_resolution(${target})
        endif()
    endforeach()
endfunction()

```

`doc/build.md`:

```md

# build guide

a guide to building on all platforms.

## common

initialize submodules:
```sh
git submodule update --init --recursive
```

common options:
```sh
-DWITNESS_SCRIPT=ON
-DWITNESS_SCRIPT_ENGINE=js # js/lua
-DWITNESS_LIEF=ON
-DWITNESS_ASMR=ON
```

zstd:
```sh
-DW1_REQUIRE_ZSTD=ON
```

## linux

```sh
cmake -G Ninja -B build-release -DCMAKE_BUILD_TYPE=Release -DWITNESS_SCRIPT=ON -DWITNESS_LIEF=ON -DWITNESS_ASMR=ON -DWITNESS_SCRIPT_ENGINE=js
cmake --build build-release --parallel
```

## macos

```sh
cmake -G Ninja -B build-release -DCMAKE_BUILD_TYPE=Release -DWITNESS_SCRIPT=ON -DWITNESS_LIEF=ON -DWITNESS_ASMR=ON -DWITNESS_SCRIPT_ENGINE=js
cmake --build build-release --parallel
```

## windows

```powershell
$env:VCPKG_ROOT = "path\to\vcpkg"
```

### windows x64

```powershell
python .\tools\windows\run_cmd.py --arch x64 --env "VCPKG_ROOT=\path\vcpkg" -- cmake -G Ninja -B build-release `
  -DCMAKE_BUILD_TYPE=Release `
  -DWITNESS_SCRIPT=ON `
  -DWITNESS_LIEF=ON `
  -DWITNESS_ASMR=ON `
  -DWITNESS_SCRIPT_ENGINE=js `
  -DW1_REQUIRE_ZSTD=ON `
  -DCMAKE_TOOLCHAIN_FILE="%VCPKG_ROOT%/scripts/buildsystems/vcpkg.cmake" `
  -DVCPKG_TARGET_TRIPLET=x64-windows-static `
  -Dzstd_DIR="%VCPKG_ROOT%/installed/x64-windows-static/share/zstd"
python .\tools\windows\run_cmd.py --arch x64 -- cmake --build build-release --parallel
```

### windows x86

```powershell
python .\tools\windows\run_cmd.py --arch x86 --host-arch amd64 --env "VCPKG_ROOT=\path\vcpkg" -- cmake -G Ninja -B build-win32 `
  -DCMAKE_BUILD_TYPE=Release `
  -DWITNESS_ARCH=x86 `
  -DWITNESS_SCRIPT=ON `
  -DWITNESS_LIEF=ON `
  -DWITNESS_ASMR=ON `
  -DWITNESS_SCRIPT_ENGINE=js `
  -DW1_REQUIRE_ZSTD=ON `
  -DCMAKE_TOOLCHAIN_FILE="%VCPKG_ROOT%/scripts/buildsystems/vcpkg.cmake" `
  -DVCPKG_TARGET_TRIPLET=x86-windows-static `
  -Dzstd_DIR="%VCPKG_ROOT%/installed/x86-windows-static/share/zstd"
python .\tools\windows\run_cmd.py --arch x86 --host-arch amd64 -- cmake --build build-win32 --parallel
```

### tests

```powershell
python .\tools\windows\run_cmd.py --arch x86 --host-arch amd64 -- ctest --test-dir build-win32 --output-on-failure
```

### lldb tests

```powershell
python .\tools\windows\run_cmd.py --arch x86 --host-arch amd64 `
  --env "LLDB_PATH=C:\Program Files\LLVM\bin\lldb.exe" `
  --prepend-path "C:\Program Files\LLVM\bin;C:\Path\To\Python\Python310" `
  -- ctest -R lldb --test-dir build-win32 --output-on-failure
```

### tips

- use `tools/windows/run_cmd.py` for cmake/ctest in the dev shell
- if using `--prepend-path`, pass a single value with `;` separators
- lldb tests need `LLDB_PATH` and may depend on a python dll they were built against (e.g. `python310.dll`). if it fails with missing `python310.dll`, install and prepend to `PATH`

## tests

```sh
ctest --test-dir build-release --output-on-failure
```

## packaging

build a zip from install rules:
```sh
cpack --config build-release\CPackConfig.cmake
```

```

`doc/frida_tracers.md`:

```md

# frida tracers

this repo also contains some frida scripts which may be useful for tracing.
in general i find that frida often causes issues or weird behavior in applications, on windows, macos, and linux.
that's part of the reason `w1tn3ss` exists!

but here's how to use them:

```sh
uv tool run --from frida-tools python ./frida/stalk_drcov.py -v -s ./build-release/samples/programs/simple_demo
```

this assumes frida was installed via `uv tool install -U frida-tools` for the `frida` command.

```

`doc/p1ll_python.md`:

```md
# p1ll python bindings

## build

```sh
cmake -G Ninja -S src/p1ll/bindings/python -B build-p1ll-python -DCMAKE_BUILD_TYPE=Release -DPython_EXECUTABLE="$VIRTUAL_ENV/bin/python"
cmake --build build-p1ll-python
PYTHONPATH=build-p1ll-python "$VIRTUAL_ENV/bin/python" -c "import p1ll; print(p1ll.has_scripting_support())"
```

# git install

```sh
python -m pip install "git+https://github.com/redthing1/w1tn3ss.git@<ref>#subdirectory=src/p1ll/bindings/python"
```

```

`doc/p1lljs.md`:

```md
# p1ll script guide (js)

This guide explains how to write `p1ll` patch scripts using the JS script engine (`-DWITNESS_SCRIPT_ENGINE=js`).

## intro

a `p1ll` script describes:
- what bytes to locate (signatures)
- what bytes to replace (patches)
- which platforms a patch should run on

the engine scans memory (dynamic) or a file buffer (static), builds a patch plan, and applies it.
scripts are declarative by default (via `auto_cure`) with optional imperative checks for logging and validation.

## usage

some typical commands:

```sh
# static patching (on-disk)
./build-release/p1llx -vv cure -c ./patch.js -i ./target_binary -o ./patched_binary

# dynamic patching (spawn)
./build-release/p1llx -vv poison -c ./patch.js -s ./target_binary

# dynamic patching (attach)
./build-release/p1llx -vv poison -c ./patch.js -n target_binary
```

## using `d0ct0r.py`

`scripts/d0ct0r.py` is a smart wrapper around `p1llx` to makes static patching safer.it manages backups, preserves permissions, and handles macOS codesigning.

### `auto-cure` (smart static patching)

- detect binary, backup to `<original>.d0ct0r.bak`
- patch the binary
- ad-hoc codesign on macos

```sh
./scripts/d0ct0r.py -vvv -c ./cure_script.js -i ./target_binary
```

### `insert-poison`

insert a dynamic binary load (defaulting to `p01s0n`) in the binary's imports, then resign the binary.

```sh
./scripts/d0ct0r.py -v insert-poison -i ./target_binary
```

## script contract

each script must define a top-level `cure()` function.

```js
function cure() {
  // build and apply patches
  const meta = { patches: [/* ... */] };
  return p1.auto_cure(meta);
}
```

## pattern language

p1ll signatures and patch patterns are hex strings:
- two hex digits per byte, case-insensitive
- `??` is a wildcard byte
- whitespace is ignored
- comments are allowed: `--`, `//`, `#`, `;`

Examples:

```js
const SIG = p1.sig(`
  48 8b ?? ?? ?? ?? ?? ??  // mov rax, [rip+...]
  85 c0                    // test eax, eax
  74 ??                    // je <offset>
`);

const PATCH = `
  90 90 90 90              // nop nop nop nop
`;
```

`p1.str2hex("text")` converts ascii text to a hex pattern, and `p1.hex2str("6869")` converts hex to a string. `p1.format_address(addr)` formats addresses for logging.

## api reference

### `p1.sig(pattern, options?)`

Create a signature object from a hex pattern.

Options (all optional):
- `filter` (string): regex against region/module name (dynamic). Ignored for static buffers.
- `only_executable` (bool)
- `exclude_system` (bool)
- `min_size` (int)
- `min_address` (uint64)
- `max_address` (uint64)
- `single` (bool): require exactly one match
- `max_matches` (int): cap returned matches
- `required` (bool): fail if not found (default true)
- `platforms` (array of strings): allowed platforms for this signature

Example:

```js
const SIG_CHECK = p1.sig("48 85 c0 74 ?? b0 01", {
  filter: "demo_program",
  single: true,
  required: true,
  platforms: ["windows:x64"]
});
```

### `p1.patch(signature, offset, patchPattern, options?)`

Create a patch bound to a signature. The signature must be a `p1.sig()` result.

Parameters:
- `signature`: signature object
- `offset`: signed byte offset from the match address
- `patchPattern`: hex pattern to write (wildcards keep original bytes)

Options:
- `required` (bool): fail if patch cannot be applied (default true)
- `platforms` (array of strings): allowed platforms for this patch

Example:

```js
const PATCH = p1.patch(SIG_CHECK, 0, "90 90");
```

### `p1.auto_cure(meta)`

Builds and applies a patch plan. `meta` is a recipe object.

Supported keys:
- `name` (string)
- `platforms` (array): allowed platforms for the recipe
- `validations` (array of signatures)
- `sigs` (map<string, array<signature>>): per-platform validations
- `patches` (array of patches) OR (map<string, array<patch>>)

Platform keys are strings like `windows:x64`, `linux:x64`, `darwin:arm64`, or `*` / `*:*`.

Return value:
- an apply report object with methods:
  - `get_success()`
  - `get_applied()`
  - `get_failed()`
  - `get_error_messages()`
  - `get_diagnostics()` (strings of `error_code: message`)
  - `has_errors()`

### `p1.search_sig(pattern, options?)`

Search for a single signature. Returns a `scan_result` or `null`.

`scan_result` methods:
- `get_address()`
- `get_region_name()`

If `options.single` is true and multiple matches are found, it returns `null`.

### `p1.search_sig_multiple(pattern, options?)`

Returns an array of `scan_result` entries. Useful for debugging or reporting.

### `p1.get_modules(filterPattern?)` (dynamic only)

Returns a list of modules in the target process. Each module has:
- `get_name()`
- `get_path()`
- `get_base_address()`
- `get_size()`
- `get_permissions()` (e.g., `"r-x"`)
- `get_is_system_module()`

If called in static mode, it returns an empty array.

### Logging helpers

Use these for script output:
- `p1.log_info(msg)`
- `p1.log_debug(msg)`
- `p1.log_warn(msg)`
- `p1.log_err(msg)`

## Recipe structure in depth

`auto_cure` builds a patch plan using these rules:
- `meta.platforms` gates the entire recipe.
- `sigs` are validations: all required signatures must match.
- `patches` define what is actually written.
- Each signature/patch can also have its own `platforms` and `required` flags.
- Patches are applied in address order and must not overlap.
- At least one patch entry must be produced; otherwise `auto_cure` fails with `no patch entries produced`.

If any required validation or required patch fails, `auto_cure` returns a failure report.

## examples

### 1) simple string patch

```js
const SIG_DEMO = p1.sig(p1.str2hex("DEMO VERSION"), { filter: "p1ll_test_target" });
const SIG_TRIAL = p1.sig(p1.str2hex("TRIAL VERSION"), { filter: "p1ll_test_target" });

const meta = {
  name: "string_patch",
  platforms: ["darwin:arm64", "linux:x64", "windows:x64"],
  sigs: { "*": [SIG_DEMO, SIG_TRIAL] },
  patches: {
    "*": [
      p1.patch(SIG_DEMO, 0, p1.str2hex("OOPS VERSION")),
      p1.patch(SIG_TRIAL, 0, p1.str2hex("SILLY VER"))
    ]
  }
};

function cure() {
  return p1.auto_cure(meta);
}
```

### 2) validation + targeted code patch

```js
const SIG_BANNER = p1.sig(p1.str2hex("Demo Program"), { single: true });

const SIG_CHECK = p1.sig(`
  48 85 c0        // test rax, rax
  74 ??           // je <offset>
  b0 01           // mov al, 1
`, { filter: "demo_program", single: true, platforms: ["windows:x64"] });

const FIX_CHECK = `
  ?? ?? ??        // keep test rax, rax
  90 90           // nop out the conditional jump
  ?? ??           // keep mov al, 1
`;

const meta = {
  name: "disable_license_check",
  platforms: ["windows:x64"],
  validations: [SIG_BANNER],
  patches: [p1.patch(SIG_CHECK, 0, FIX_CHECK)]
};

function cure() {
  return p1.auto_cure(meta);
}
```

### 3) patch + diagnostics

```js
const SIG_OPTIONAL = p1.sig("48 83 ec ?? 48 8d 0d ?? ?? ?? ??", {
  only_executable: true,
  required: false
});

const meta = {
  name: "optional_patch",
  patches: [p1.patch(SIG_OPTIONAL, 0, "90 90", { required: false })]
};

function cure() {
  const report = p1.auto_cure(meta);
  if (report.has_errors()) {
    p1.log_warn("optional patch had errors: " + report.get_diagnostics().join(", "));
  }
  return report;
}
```

### 4) dynamic module scanning

```js
function cure() {
  const mods = p1.get_modules("demo_program");
  mods.forEach((mod) => {
    p1.log_info(
      mod.get_name() + " @" + p1.format_address(mod.get_base_address()) + " " + mod.get_permissions()
    );
  });

  const SIG = p1.sig("e8 ?? ?? ?? ?? 48 8b c8", {
    filter: "demo_program",
    single: true
  });

  const meta = {
    name: "patch_call_site",
    patches: [p1.patch(SIG, 0, "90 90 90 90 90")]
  };

  return p1.auto_cure(meta);
}
```

```

`frida/call_tracer.py`:

```py
#!/usr/bin/env python3

"""
call_tracer.py
A frida-based call tracer that monitors function calls within specified functions.

Example usage:

# install frida-tools via uv
uv tool install frida-tools

# run python with uv
uv tool run --from frida-tools python ...

# trace and show summary in terminal (no file output)
python call_tracer.py 1234 -F 0x401000

# trace with verbose output (-v for verbose, -vv for extra verbose)
python call_tracer.py 1234 -F 0x401000 -vv

# trace with custom buffer size
python call_tracer.py 1234 -F 0x401000 --buffer-size 2000

# trace specific functions and save to file
python call_tracer.py 1234 -F 0x401000 -F 0x402000 -o traces.json

# trace using module+offset format (handles ASLR)
python call_tracer.py 1234 -F myapp+0x1234 -F libcrypto+2048 -o traces.json

# trace by function name with symbols
python call_tracer.py myapp.exe -n malloc -n free -o calls.json

# monitor all functions in a module, excluding system modules
python call_tracer.py 1234 -m myapp --no-system -o trace.json

# monitor everything except system modules
python call_tracer.py -s ./target_binary -M --no-system -t 30

# spawn with arguments (use -- to separate)
python call_tracer.py -s ./target_binary -F 0x401000 -- --input file.txt --verbose
"""

from __future__ import print_function

import argparse
import json
import os
import signal
import sys
import time
import struct
import lzma
import threading
from dataclasses import dataclass, field
from typing import List, Tuple, Dict, Optional, Any, Set
from collections import defaultdict, Counter
from enum import Enum

import frida

# constants
VERSION = "1.0.0"
BINARY_MAGIC = b"CTRC"
BINARY_VERSION = 1
SHUTDOWN_TIMEOUT_SECONDS = 4  # max time to wait for graceful shutdown

# frida javascript agent code
js_agent_code = """
"use strict";

//=============================================================================
// CONFIGURATION AND GLOBALS
//=============================================================================

// configuration passed from python
const config = JSON.parse('CONFIG_JSON_PLACEHOLDER');
const monitoredFunctions = config.functions || [];
const targetModules = config.modules || [];
const monitorAll = config.monitorAll || false;
const excludeSystem = config.excludeSystem || false;
const verbose = config.verbose || false;
const extraVerbose = config.extraVerbose || false;

// state management
const threadState = new Map();           // per-thread state tracking
const functionContextStack = new Map(); // function call stack per thread
const activeStalkers = new Set();       // active stalker thread IDs

// data collection
let totalCalls = 0;
const functionStats = new Map();        // func_addr -> { calls: number, threads: Set }
const callBuffer = [];
const MAX_BUFFER_SIZE = config.bufferSize || 1;
const FLUSH_THRESHOLD = 25;             // flush when buffer reaches this size
const FLUSH_INTERVAL_MS = 1000;         // flush every N milliseconds

//=============================================================================
// UTILITY FUNCTIONS
//=============================================================================

// periodic buffer flush
function flushBuffer() {
    try {
        if (callBuffer.length > 0) {
            const dataToSend = callBuffer.splice(0);
            if (extraVerbose) console.log(`Flushing ${dataToSend.length} calls from buffer`);
            send({
                type: 'calls',
                data: dataToSend
            });
        }
    } catch (e) {
        console.error('Error flushing buffer:', e.message);
        // Clear buffer on error to prevent memory buildup
        callBuffer.length = 0;
    }
}

// force flush buffer if it's getting too large to prevent memory issues
function forceFlushIfNeeded() {
    if (callBuffer.length >= MAX_BUFFER_SIZE) {
        // console.warn(`Buffer full: flushing ${callBuffer.length} calls`);
        if (extraVerbose) console.log(`Buffer full: flushing ${callBuffer.length} calls`);
        try {
            const dataToSend = callBuffer.splice(0);
            send({
                type: 'calls',
                data: dataToSend
            });
        } catch (e) {
            console.error('Error in force flush:', e.message);
            callBuffer.length = 0; // Clear to prevent memory buildup
        }
    }
}

// flush buffer at regular intervals
setInterval(flushBuffer, FLUSH_INTERVAL_MS);

//=============================================================================
// THREAD AND STATE MANAGEMENT
//=============================================================================

// get or create thread state
function getThreadState(threadId) {
    if (!threadState.has(threadId)) {
        threadState.set(threadId, {
            depths: new Map(),
            stalking: false
        });
    }
    return threadState.get(threadId);
}

// get current function context for thread
function getCurrentFunctionContext(threadId) {
    const stack = functionContextStack.get(threadId);
    if (!stack || stack.length === 0) return null;
    return stack[stack.length - 1]; // top of stack
}

//=============================================================================
// EVENT PROCESSING
//=============================================================================

// process call event from stalker
function processCallEvent(sourceAddr, targetAddr, threadId, callType = 'call') {
    try {
        const funcContext = getCurrentFunctionContext(threadId);
        if (!funcContext) {
            // If no function context, this is a call happening outside our monitored functions
            // We can still record it with a generic context
            const callData = {
                timestamp: Date.now() / 1000.0,
                thread_id: threadId,
                source_addr: sourceAddr.toString(),
                target_addr: targetAddr.toString(),
                function_context: "0x0", // generic context for calls outside monitored functions
                call_type: callType
            };
            
            callBuffer.push(callData);
            totalCalls++;
            
            // check buffer size and flush if needed
            forceFlushIfNeeded();
            if (callBuffer.length >= FLUSH_THRESHOLD) {
                try {
                    const dataToSend = callBuffer.splice(0);
                    send({
                        type: 'calls',
                        data: dataToSend
                    });
                } catch (e) {
                    console.error('Error sending call data:', e.message);
                    callBuffer.length = 0;
                }
            }
            return;
        }
        
        // create call event
        const callData = {
            timestamp: Date.now() / 1000.0,
            thread_id: threadId,
            source_addr: sourceAddr.toString(),
            target_addr: targetAddr.toString(),
            function_context: funcContext,
            call_type: callType
        };
        
        // add to buffer
        callBuffer.push(callData);
        totalCalls++;
        
        // Log individual calls in extra verbose mode
        if (extraVerbose) {
            console.log(`[CALL] ${callData.call_type}: ${callData.source_addr} -> ${callData.target_addr} (ctx: ${callData.function_context}, tid: ${callData.thread_id})`);
        }
        
        // update function statistics
        const stats = functionStats.get(funcContext);
        if (stats) {
            stats.calls++;
            stats.threads.add(threadId);
        }
        
        // check buffer size and flush if needed
        forceFlushIfNeeded();
        if (callBuffer.length >= FLUSH_THRESHOLD) {
            try {
                const dataToSend = callBuffer.splice(0);
                send({
                    type: 'calls',
                    data: dataToSend
                });
            } catch (e) {
                console.error('Error sending call data:', e.message);
                callBuffer.length = 0;
            }
        }
    } catch (e) {
        console.error('Error processing call event:', e.message);
    }
}

// process return event from stalker
function processReturnEvent(sourceAddr, threadId) {
    try {
        const funcContext = getCurrentFunctionContext(threadId);
        if (!funcContext) {
            // If no function context, still record with generic context
            const returnData = {
                timestamp: Date.now() / 1000.0,
                thread_id: threadId,
                source_addr: sourceAddr.toString(),
                target_addr: "0x0",
                function_context: "0x0",
                call_type: 'return'
            };
            
            callBuffer.push(returnData);
            totalCalls++;
            
            forceFlushIfNeeded();
            if (callBuffer.length >= FLUSH_THRESHOLD) {
                try {
                    const dataToSend = callBuffer.splice(0);
                    send({
                        type: 'calls',
                        data: dataToSend
                    });
                } catch (e) {
                    console.error('Error sending return data:', e.message);
                    callBuffer.length = 0;
                }
            }
            return;
        }
        
        // create return event
        const returnData = {
            timestamp: Date.now() / 1000.0,
            thread_id: threadId,
            source_addr: sourceAddr.toString(),
            target_addr: "0x0", // return doesn't have a target
            function_context: funcContext,
            call_type: 'return'
        };
        
        // add to buffer
        callBuffer.push(returnData);
        totalCalls++;
        
        // Log individual returns in extra verbose mode
        if (extraVerbose) {
            console.log(`[RETURN] return from ${returnData.source_addr} (ctx: ${returnData.function_context}, tid: ${returnData.thread_id})`);
        }
        
        // check buffer size and flush if needed
        forceFlushIfNeeded();
        if (callBuffer.length >= FLUSH_THRESHOLD) {
            try {
                const dataToSend = callBuffer.splice(0);
                send({
                    type: 'calls',
                    data: dataToSend
                });
            } catch (e) {
                console.error('Error sending return data:', e.message);
                callBuffer.length = 0;
            }
        }
    } catch (e) {
        console.error('Error processing return event:', e.message);
    }
}

//=============================================================================
// FUNCTION INSTRUMENTATION
//=============================================================================

// function entry handler
function enterMonitoredFunction(funcAddr, threadId) {
    try {
        const state = getThreadState(threadId);
        const depth = state.depths.get(funcAddr) || 0;
        state.depths.set(funcAddr, depth + 1);
        
        // push to context stack
        if (!functionContextStack.has(threadId)) {
            functionContextStack.set(threadId, []);
        }
        functionContextStack.get(threadId).push(funcAddr);
        
        // create function entry event
        const entryEvent = {
            timestamp: Date.now() / 1000.0,
            thread_id: threadId,
            source_addr: "0x0",  // entry point
            target_addr: funcAddr,
            function_context: funcAddr,
            call_type: 'entry'
        };
        
        callBuffer.push(entryEvent);
        totalCalls++;
        
        // Log function entries in extra verbose mode
        if (extraVerbose) {
            console.log(`[ENTRY] Entering function ${funcAddr} on thread ${threadId} (depth: ${depth + 1})`);
        }
        
        // update function statistics
        const stats = functionStats.get(funcAddr);
        if (stats) {
            stats.calls++;
            stats.threads.add(threadId);
        }
        
        // send buffer if getting full or at regular intervals
        if (callBuffer.length >= MAX_BUFFER_SIZE || callBuffer.length >= FLUSH_THRESHOLD) {
            send({
                type: 'calls',
                data: callBuffer.splice(0)
            });
        }
        
        // start stalking if this is the first monitored function entry for this thread
        if (!state.stalking && !activeStalkers.has(threadId)) {
            if (extraVerbose) console.log(`Stalking thread ${threadId}`);
            
            try {
                // Convert thread ID to unsigned integer for Frida
                // On Linux, thread IDs can be negative, but Stalker.follow expects unsigned
                var unsignedThreadId = threadId >>> 0;
                
                Stalker.follow(unsignedThreadId, {
                    events: {
                        call: true,
                        ret: true,
                        exec: false,  // Too noisy for call tracing
                        block: false, // Too noisy for call tracing
                        compile: false // Not needed for call tracing
                    },
                    onReceive: function(events) {
                        try {
                            if (!events || events.byteLength === 0) {
                                return; // Skip empty events
                            }
                            
                            const parsed = Stalker.parse(events, {
                                stringify: false,
                                annotate: false
                            });
                            
                            if (!parsed || parsed.length === 0) {
                                return; // Skip if no parsed events
                            }
                            
                            // process each event - format is [source, target, depth]
                            for (const event of parsed) {
                                try {
                                    if (!event || event.length < 3) {
                                        continue; // Skip malformed events
                                    }
                                    
                                    const sourceAddr = ptr(event[0]);
                                    const targetAddr = ptr(event[1]);
                                    const depth = event[2];
                                    
                                    if (depth >= 0) {
                                        // Positive or zero depth indicates a call
                                        processCallEvent(sourceAddr, targetAddr, threadId, 'call');
                                    } else {
                                        // Negative depth indicates a return
                                        processReturnEvent(sourceAddr, threadId);
                                    }
                                } catch (eventError) {
                                    console.error(`Error processing individual event:`, eventError.message);
                                    // Continue processing other events
                                }
                            }
                        } catch (e) {
                            console.error(`Error in stalker onReceive for thread ${threadId}:`, e.message);
                            // Don't crash the stalker, just log and continue
                        }
                    },
                    onCallSummary: function(summary) {
                        // Optional call summary logging
                    }
                });
                
                state.stalking = true;
                activeStalkers.add(threadId);
            } catch (e) {
                console.error(`Error starting stalker for thread ${threadId}:`, e.message);
            }
        }
    } catch (e) {
        console.error('Error in enterMonitoredFunction:', e.message);
    }
}

// function exit handler
function exitMonitoredFunction(funcAddr, threadId) {
    try {
        const state = getThreadState(threadId);
        const depth = state.depths.get(funcAddr) || 0;
        
        if (depth > 0) {
            // create function exit event
            const exitEvent = {
                timestamp: Date.now() / 1000.0,
                thread_id: threadId,
                source_addr: funcAddr,
                target_addr: "0x0",  // exit point
                function_context: funcAddr,
                call_type: 'exit'
            };
            
            callBuffer.push(exitEvent);
            totalCalls++;
            
            // Log function exits in extra verbose mode
            if (extraVerbose) {
                console.log(`[EXIT] Exiting function ${funcAddr} on thread ${threadId} (depth: ${depth - 1})`);
            }
            
            state.depths.set(funcAddr, depth - 1);
            
            // pop from context stack
            const stack = functionContextStack.get(threadId);
            if (stack && stack.length > 0) {
                const idx = stack.lastIndexOf(funcAddr);
                if (idx !== -1) {
                    stack.splice(idx, 1);
                }
            }
            
            // check buffer size and flush if needed
            forceFlushIfNeeded();
            if (callBuffer.length >= FLUSH_THRESHOLD) {
                try {
                    const dataToSend = callBuffer.splice(0);
                    send({
                        type: 'calls',
                        data: dataToSend
                    });
                } catch (e) {
                    console.error('Error sending exit event data:', e.message);
                    callBuffer.length = 0;
                }
            }
            
            // check if we're exiting all monitored functions in this thread
            if (depth === 1) {
                let stillInMonitoredFunction = false;
                state.depths.forEach((d, addr) => {
                    if (d > 0 && addr !== funcAddr) {
                        stillInMonitoredFunction = true;
                    }
                });
                
                if (!stillInMonitoredFunction) {
                    if (extraVerbose) console.log(`Thread ${threadId} exited all monitored functions`);
                    
                    // Don't stop stalking immediately - let it continue for a bit
                    // to catch any remaining call/ret events
                    setTimeout(() => {
                        if (state.stalking) {
                            if (extraVerbose) console.log(`Stopping stalker for thread ${threadId} (delayed)`);
                            try {
                                // Convert thread ID to unsigned integer for Frida
                                var unsignedThreadId = threadId >>> 0;
                                Stalker.unfollow(unsignedThreadId);
                                state.stalking = false;
                                activeStalkers.delete(threadId);
                                
                                // Check if this was the last active thread
                                if (activeStalkers.size === 0) {
                                    if (extraVerbose) console.log('All threads completed, flushing final data...');
                                    flushBuffer();
                                    cleanup();
                                    
                                    // Signal final completion
                                    send({ type: 'process_complete' });
                                } else {
                                    if (extraVerbose) console.log(`Thread ${threadId} completed, ${activeStalkers.size} threads still active`);
                                }
                            } catch (e) {
                                console.error(`Error stopping stalker for thread ${threadId}:`, e.message);
                            }
                        }
                    }, 100); // Small delay to capture remaining events
                }
            }
        }
    } catch (e) {
        console.error('Error in exitMonitoredFunction:', e.message);
    }
}

//=============================================================================
// FUNCTION DISCOVERY AND HOOKING
//=============================================================================

// setup function hooks
function setupFunctionHooks() {
    const resolved = [];
    const failed = [];
    
    monitoredFunctions.forEach(func => {
        try {
            const addr = ptr(func.address);
            
            // verify the address is readable
            addr.readU8();
            
            Interceptor.attach(addr, {
                onEnter: function(args) {
                    const threadId = Process.getCurrentThreadId();
                    enterMonitoredFunction(func.address, threadId);
                },
                onLeave: function(retval) {
                    const threadId = Process.getCurrentThreadId();
                    exitMonitoredFunction(func.address, threadId);
                }
            });
            
            resolved.push(func);
            const moduleInfo = func.module ? ` in ${func.module}` : '';
            if (verbose) console.log(`Hooked ${func.address} (${func.name || 'unnamed'})${moduleInfo}`);
            
            // Log call details in extra verbose mode
            if (extraVerbose) {
                console.log(`Hook details: address=${func.address}, name=${func.name || 'unnamed'}, module=${func.module || 'unknown'}`);
            }
            
        } catch (e) {
            console.error(`Failed to hook ${func.address}: ${e.message}`);
            failed.push(func);
        }
    });
    
    send({
        type: 'hook_status',
        resolved: resolved,
        failed: failed
    });
}

// resolve module+offset to addresses
function resolveModuleOffsets(moduleOffsets) {
    const resolved = [];
    
    moduleOffsets.forEach(entry => {
        const moduleName = entry.module;
        const offset = parseInt(entry.offset, 16);
        let found = false;
        
        // find module by name
        Process.enumerateModules().forEach(module => {
            if (found) return;
            
            // Match by exact name or basename
            const moduleBaseName = module.name.split('/').pop().split('\\\\').pop();
            if (module.name === moduleName || moduleBaseName === moduleName) {
                const baseAddr = module.base;
                const targetAddr = baseAddr.add(offset);
                
                resolved.push({
                    address: targetAddr.toString(),
                    name: `${moduleName}+${entry.offset}`,
                    module: module.name,
                    offset: entry.offset
                });
                found = true;
                if (extraVerbose) console.log(`Resolved ${moduleName}+${entry.offset} to ${targetAddr} (base: ${baseAddr})`);
            }
        });
        
        if (!found) {
            console.warn(`Could not resolve module: ${moduleName}`);
        }
    });
    
    return resolved;
}

// resolve function names to addresses
function resolveFunctionNames(names) {
    const resolved = [];
    
    names.forEach(name => {
        let found = false;
        
        // try module exports
        Process.enumerateModules().forEach(module => {
            if (found) return;
            
            module.enumerateExports().forEach(exp => {
                if (exp.name === name) {
                    resolved.push({
                        address: exp.address.toString(),
                        name: exp.name,
                        module: module.name
                    });
                    found = true;
                }
            });
        });
        
        if (!found) {
            console.warn(`Could not resolve function: ${name}`);
        }
    });
    
    return resolved;
}

// expand address ranges
function expandAddressRanges(ranges) {
    const functions = [];
    
    ranges.forEach(range => {
        const [start, end] = range.split(':').map(a => parseInt(a, 16));
        
        // for now, just hook the start address
        functions.push({
            address: '0x' + start.toString(16),
            name: `range_${start.toString(16)}_${end.toString(16)}`
        });
    });
    
    return functions;
}

// check if a module is a system module
function isSystemModule(moduleName, modulePath) {
    const name = moduleName.toLowerCase();
    const path = modulePath ? modulePath.toLowerCase() : '';
    
    // Cross-platform system module patterns
    const systemPatterns = [
        // macOS system modules
        /^lib(system|c|objc|dispatch|foundation|corefoundation|security)/,
        /^(dyld|libdyld)/,
        /\\.framework\\//,
        /^\\/system\\//,
        /^\\/usr\\/lib\\//,
        
        // Linux system modules
        /^lib(c|pthread|dl|m|rt|resolv|nsl|util|crypt)\\.so/,
        /^ld-linux/,
        /^\\/lib\\//,
        /^\\/usr\\/lib\\//,
        /^linux-vdso/,
        
        // Windows system modules  
        /^(ntdll|kernel32|user32|advapi32|ole32|oleaut32|shell32|gdi32|winmm|ws2_32|crypt32|rpcrt4|comctl32|comdlg32|version|shlwapi)\\.dll$/,
        /^msvcrt/,
        /^ucrtbase/,
        /^vcruntime/,
        /^api-ms-/,
        /^ext-ms-/,
        
        // Common patterns
        /^libc\\+\\+/,
        /^libstdc\\+\\+/,
        /^libgcc/
    ];
    
    return systemPatterns.some(pattern => 
        pattern.test(name) || (path && pattern.test(path))
    );
}

// discover functions in specified modules
function discoverModuleFunctions(moduleNames) {
    const functions = [];
    
    Process.enumerateModules().forEach(module => {
        // Skip system modules if excludeSystem is enabled
        if (excludeSystem && isSystemModule(module.name, module.path)) {
            return;
        }
        
        if (moduleNames.length === 0 || moduleNames.includes(module.name)) {
            if (extraVerbose) console.log(`Discovering functions in module: ${module.name}`);
            
            // enumerate exports
            module.enumerateExports().forEach(exp => {
                if (exp.type === 'function') {
                    functions.push({
                        address: exp.address.toString(),
                        name: exp.name,
                        module: module.name
                    });
                }
            });
        }
    });
    
    const moduleDesc = moduleNames.length > 0 ? moduleNames.join(', ') : 'all modules';
    const systemDesc = excludeSystem ? ' (excluding system modules)' : '';
    if (verbose) console.log(`Discovered ${functions.length} functions in ${moduleDesc}${systemDesc}`);
    return functions;
}

// discover all functions in all modules (for monitor-all mode)
function discoverAllFunctions() {
    const functions = [];
    
    Process.enumerateModules().forEach(module => {
        // Skip system modules if excludeSystem is enabled
        if (excludeSystem && isSystemModule(module.name, module.path)) {
            if (extraVerbose) console.log(`Skipping system module: ${module.name}`);
            return;
        }
        
        if (extraVerbose) console.log(`Discovering all functions in module: ${module.name}`);
        
        // enumerate exports
        module.enumerateExports().forEach(exp => {
            if (exp.type === 'function') {
                functions.push({
                    address: exp.address.toString(),
                    name: exp.name,
                    module: module.name
                });
            }
        });
    });
    
    const systemDesc = excludeSystem ? ' (excluding system modules)' : '';
    if (verbose) console.log(`Discovered ${functions.length} total functions in all modules${systemDesc}`);
    return functions;
}

//=============================================================================
// CLEANUP AND SHUTDOWN
//=============================================================================

// send final data on cleanup
function cleanup() {
    if (extraVerbose) console.log(`Final cleanup: buffer has ${callBuffer.length} calls, total calls: ${totalCalls}`);
    
    // send any remaining calls
    if (callBuffer.length > 0) {
        send({
            type: 'calls',
            data: callBuffer.splice(0)  // clear the buffer
        });
    }
    
    // send final statistics
    const stats = {};
    functionStats.forEach((stat, addr) => {
        stats[addr] = {
            calls: stat.calls,
            threads: stat.threads.size
        };
    });
    
    send({
        type: 'statistics',
        total_calls: totalCalls,
        function_stats: stats
    });
    
    // ensure completion signal is sent
    if (extraVerbose) console.log('Sending process complete signal...');
    send({ type: 'process_complete' });
}

//=============================================================================
// INITIALIZATION AND SETUP
//=============================================================================

// handle different monitoring modes
if (monitorAll) {
    // monitor all functions in all modules
    const allFunctions = discoverAllFunctions();
    allFunctions.forEach(f => monitoredFunctions.push(f));
} else if (targetModules.length > 0) {
    // monitor functions in specific modules
    const moduleFunctions = discoverModuleFunctions(targetModules);
    moduleFunctions.forEach(f => monitoredFunctions.push(f));
}

// process address ranges if any
const ranges = monitoredFunctions.filter(f => f.range).map(f => f.range);
if (ranges.length > 0) {
    const rangeFunctions = expandAddressRanges(ranges);
    rangeFunctions.forEach(f => monitoredFunctions.push(f));
}

// process module+offset entries if any
const moduleOffsets = monitoredFunctions.filter(f => f.module && f.offset);
if (moduleOffsets.length > 0) {
    const resolved = resolveModuleOffsets(moduleOffsets);
    resolved.forEach(r => monitoredFunctions.push(r));
}

// process function names if any
const namesToResolve = monitoredFunctions.filter(f => f.name && !f.address && !f.module).map(f => f.name);
if (namesToResolve.length > 0) {
    const resolved = resolveFunctionNames(namesToResolve);
    resolved.forEach(r => monitoredFunctions.push(r));
}

// filter out functions without addresses
const validFunctions = monitoredFunctions.filter(f => f.address);

// update monitored functions list
monitoredFunctions.length = 0;
validFunctions.forEach(f => monitoredFunctions.push(f));

// initialize function statistics for all monitored functions
monitoredFunctions.forEach(func => {
    functionStats.set(func.address, { calls: 0, threads: new Set() });
});

// setup hooks
if (monitoredFunctions.length > 0) {
    setupFunctionHooks();
} else {
    send({
        type: 'error',
        message: 'No valid functions to monitor'
    });
}

//=============================================================================
// MESSAGE HANDLING AND LIFECYCLE
//=============================================================================

// register cleanup
Script.bindWeak(globalThis, cleanup);

// handle messages from python
recv(function(message) {
    if (message.type === 'shutdown') {
        if (extraVerbose) console.log('Received shutdown request, stopping all stalkers...');
        
        // Stop all active stalkers
        activeStalkers.forEach(threadId => {
            try {
                if (extraVerbose) console.log(`Force stopping stalker for thread ${threadId}`);
                var unsignedThreadId = threadId >>> 0;
                Stalker.unfollow(unsignedThreadId);
            } catch (e) {
                console.error(`Error stopping stalker for thread ${threadId}:`, e.message);
            }
        });
        activeStalkers.clear();
        
        // Flush all remaining data
        flushBuffer();
        cleanup();
        send({ type: 'shutdown_complete' });
    }
});

// collect module information early for RE analysis
const moduleInfo = [];
Process.enumerateModules().forEach(module => {
    moduleInfo.push({
        name: module.name,
        base: module.base.toString(),
        size: module.size,
        path: module.path
    });
});

// send module information 
send({
    type: 'modules',
    data: moduleInfo
});

// send ready signal
send({ type: 'ready' });
"""


# ==============================================================================
# DATA STRUCTURES
# ==============================================================================


@dataclass
class CallEvent:
    """Represents a single call/return event"""

    timestamp: float
    thread_id: int
    source_addr: int
    target_addr: int
    function_context: int
    call_type: str


@dataclass
class FunctionContext:
    """Tracks statistics for a monitored function"""

    address: int
    name: Optional[str]
    module: Optional[str] = None
    total_calls: int = 0
    unique_threads: Set[int] = field(default_factory=set)
    unique_targets: Set[int] = field(default_factory=set)


@dataclass
class CallSummary:
    """Summary statistics for a tracing session"""

    total_calls: int
    unique_threads: int
    duration: float
    calls_per_second: float
    functions: List[Dict[str, Any]]
    top_targets: List[Tuple[str, int]]
    thread_distribution: Dict[int, int]


# ==============================================================================
# MAIN TRACER CLASS
# ==============================================================================


class CallTracer:
    """Main call tracer implementation using Frida"""

    def __init__(self, args):
        self.args = args
        self.start_time = time.time()
        self.end_time = None
        self.running = False
        self.script = None
        self.session = None
        self.device = None
        self.pid = None

        # data storage
        self.call_events = []
        self.function_contexts = {}  # addr -> FunctionContext
        self.monitored_functions = []
        self.shutdown_complete = False
        self.modules = []  # module information for RE analysis

        # prepare monitored functions
        self._prepare_monitored_functions()

    # --------------------------------------------------------------------------
    # Setup and Configuration
    # --------------------------------------------------------------------------

    def _prepare_monitored_functions(self):
        """Prepare the list of functions to monitor"""
        functions = []

        # add functions by address or module+offset
        for addr in self.args.hook_func or []:
            try:
                # Check for module+offset format (e.g., "mymodule+1234" or "mymodule+0x1234")
                if "+" in addr:
                    module_name, offset_str = addr.split("+", 1)
                    # Parse offset as hex (strip 0x prefix if present)
                    offset_clean = (
                        offset_str[2:]
                        if offset_str.startswith(("0x", "0X"))
                        else offset_str
                    )
                    offset = int(offset_clean, 16)
                    functions.append(
                        {
                            "module": module_name.strip(),
                            "offset": hex(offset),
                            "name": f"{module_name}+{hex(offset)}",
                        }
                    )
                else:
                    # Handle regular address format - always treat as hex
                    if addr.startswith(("0x", "0X")):
                        addr_int = int(addr, 16)
                    else:
                        # Always treat as hex, even without 0x prefix
                        addr_int = int(addr, 16)
                    func_ctx = FunctionContext(address=addr_int, name=None)
                    self.function_contexts[addr] = func_ctx
                    functions.append({"address": addr, "name": None})
            except ValueError:
                print(
                    f"[-] Invalid address/module+offset format: {addr}. "
                    f"Use hex (0x1234 or 1234) or module+offset (mymodule+0x1234)."
                )
                sys.exit(1)

        # add functions by name
        for name in self.args.hook_name or []:
            functions.append({"address": None, "name": name})

        # add address ranges
        for range_str in self.args.hook_range or []:
            if ":" not in range_str:
                print(f"[-] Invalid range format: {range_str}. Use START:END format.")
                sys.exit(1)
            try:
                start_str, end_str = range_str.split(":", 1)
                # Validate that both parts are valid addresses
                start_addr = (
                    int(start_str, 16)
                    if start_str.startswith("0x")
                    else int(start_str, 16)
                )
                end_addr = (
                    int(end_str, 16) if end_str.startswith("0x") else int(end_str, 16)
                )
                if start_addr >= end_addr:
                    print(
                        f"[-] Invalid range: start address must be less than end address"
                    )
                    sys.exit(1)
                functions.append({"range": range_str})
            except ValueError:
                print(
                    f"[-] Invalid range format: {range_str}. Use hex addresses like 0x1000:0x2000"
                )
                sys.exit(1)

        self.monitored_functions = functions

    def _resolve_address_to_module_offset(self, address):
        """Resolve an address to module+offset format"""
        if not self.modules:
            # handle both int and string addresses
            if isinstance(address, str):
                return address if address.startswith("0x") else f"0x{address}"
            return hex(address)  # fallback to hex if no modules

        # handle different address formats
        if isinstance(address, str):
            if address.startswith("0x"):
                addr_int = int(address, 16)
            elif address.isdigit():
                addr_int = int(address)
            else:
                try:
                    addr_int = int(address, 16)
                except ValueError:
                    return address  # return as-is if can't parse
        else:
            addr_int = address

        # Find the module containing this address
        for module in self.modules:
            base_addr = int(module["base"], 16)
            module_size = module["size"]

            if base_addr <= addr_int < (base_addr + module_size):
                offset = addr_int - base_addr
                return f"{module['name']}+{hex(offset)}"

        # If no module found, return hex address
        return hex(addr_int)

    def start_tracing(self):
        """Start the tracing session"""
        try:
            # setup device
            self.device = self._get_device()

            # attach or spawn
            if self.args.spawn:
                if not os.path.exists(self.args.target):
                    raise FileNotFoundError(
                        f"Target binary not found: {self.args.target}"
                    )

                # prepare spawn options
                spawn_options = {}
                if self.args.disable_aslr:
                    # disable aslr using frida
                    spawn_options["aslr"] = "disable"
                    # on macos, try DYLD_DISABLE_ASLR
                    if sys.platform == "darwin":
                        spawn_options["env"] = {
                            "DYLD_DISABLE_ASLR": "1",
                        }
                    print("[*] Attempting to disable ASLR for the target process")

                # Build command line with target and arguments
                cmd_line = [self.args.target] + self.args.target_args
                if self.args.target_args:
                    print(f"[*] Spawning with arguments: {' '.join(cmd_line)}")
                self.pid = self.device.spawn(cmd_line, **spawn_options)
                self.session = self.device.attach(self.pid)
                print(f"[+] Spawned process with PID: {self.pid}")
            else:
                # attach to existing process
                target = self.args.target

                # try to parse as PID first
                try:
                    self.pid = int(target)
                    print(f"[*] Attaching to PID: {self.pid}")
                    self.session = self.device.attach(self.pid)
                    print(f"[+] Attached to PID: {self.pid}")
                except ValueError:
                    # treat as process name
                    print(f"[*] Looking for process: {target}")
                    try:
                        process = self.device.get_process(target)
                        self.pid = process.pid
                        print(f"[*] Found process '{target}' with PID: {self.pid}")
                        self.session = self.device.attach(self.pid)
                        print(f"[+] Attached to process")
                    except frida.ProcessNotFoundError:
                        # fallback to enumeration
                        print(
                            f"[*] Process '{target}' not found by direct lookup, searching..."
                        )
                        try:
                            processes = self.device.enumerate_processes()
                            matches = [
                                p
                                for p in processes
                                if target.lower() in p.name.lower()
                                or str(p.pid) == target
                            ]

                            if not matches:
                                available_processes = [
                                    f"{p.pid}: {p.name}" for p in processes[:10]
                                ]
                                available_str = "\n".join(available_processes)
                                if len(processes) > 10:
                                    available_str += f"\n... and {len(processes) - 10} more processes"

                                raise RuntimeError(
                                    f"Process '{target}' not found.\n"
                                    f"Available processes (showing first 10):\n{available_str}\n\n"
                                    f"Use a valid PID or process name."
                                )
                            elif len(matches) > 1:
                                print(f"[!] Multiple processes match '{target}':")
                                for p in matches:
                                    print(f"    PID: {p.pid}, Name: {p.name}")
                                self.pid = matches[0].pid
                                print(f"[*] Using first match: PID {self.pid}")
                            else:
                                self.pid = matches[0].pid
                                print(
                                    f"[*] Found process: PID {self.pid}, Name: {matches[0].name}"
                                )

                            self.session = self.device.attach(self.pid)
                            print(f"[+] Attached to process")

                        except Exception as e:
                            raise RuntimeError(
                                f"Failed to enumerate or attach to processes: {e}"
                            )
                except frida.ProcessNotFoundError:
                    raise RuntimeError(
                        f"Process with PID {self.pid} not found or access denied"
                    )
                except Exception as e:
                    raise RuntimeError(f"Failed to attach to process: {e}")

            # validate we have something to monitor
            if (
                not self.monitored_functions
                and not self.args.module
                and not self.args.monitor_all
            ):
                raise ValueError(
                    "No functions, modules, or monitor-all specified. "
                    "Use -F/--hook-func, -n/--hook-name, -m/--module, or -M/--monitor-all"
                )

            # prepare configuration for JS agent
            config = {
                "functions": self.monitored_functions,
                "modules": self.args.module or [],
                "monitorAll": self.args.monitor_all,
                "excludeSystem": self.args.no_system,
                "verbose": self.args.verbose >= 1,
                "extraVerbose": self.args.verbose >= 2,
                "bufferSize": self.args.buffer_size,
            }

            # inject script with properly escaped JSON
            try:
                # properly escape JSON for JavaScript string literal
                config_json = json.dumps(config)
                # escape single quotes and backslashes for JavaScript string literal
                config_json_escaped = config_json.replace("\\", "\\\\").replace(
                    "'", "\\'"
                )
                script_code = js_agent_code.replace(
                    "CONFIG_JSON_PLACEHOLDER", config_json_escaped
                )

                self.script = self.session.create_script(script_code)
                self.script.on("message", self._on_message)
                self.script.load()

            except frida.InvalidArgumentError as e:
                raise RuntimeError(f"Invalid JavaScript agent code: {e}")
            except Exception as e:
                raise RuntimeError(
                    f"Failed to inject JavaScript agent: {e}. Check target process compatibility."
                )

            # resume if spawned
            if self.args.spawn:
                self.device.resume(self.pid)
                print("[+] Process resumed")

            self.running = True

            # start timeout if specified
            if self.args.timeout:
                timer = threading.Timer(self.args.timeout, self._timeout_handler)
                timer.daemon = True
                timer.start()

        except Exception as e:
            # Cleanup on failure
            if hasattr(self, "session") and self.session:
                try:
                    self.session.detach()
                except:
                    pass
            raise e

    def _get_device(self):
        """Get the Frida device"""
        try:
            if self.args.host:
                manager = frida.get_device_manager()
                device = manager.add_remote_device(self.args.host)
                print(f"[*] Using remote device: {self.args.host}")
            else:
                device = frida.get_device(self.args.device)
                print(f"[*] Using device: {device.id}")
            return device
        except Exception as e:
            raise RuntimeError(f"Failed to get Frida device: {e}")

    # --------------------------------------------------------------------------
    # Message Handling
    # --------------------------------------------------------------------------

    def _on_message(self, message, data):
        """Handle messages from the JS agent"""
        try:
            if not message or not isinstance(message, dict):
                print(f"[!] Invalid message format: {message}")
                return

            if message["type"] == "error":
                print(f"[!] Script error: {message}")
                return

            if message["type"] == "send":
                payload = message.get("payload", {})
                if not isinstance(payload, dict):
                    print(f"[!] Invalid payload format: {payload}")
                    return

                msg_type = payload.get("type")

            if msg_type == "ready":
                print("[+] Agent ready and monitoring")

            elif msg_type == "modules":
                # store module information for RE analysis
                self.modules = payload.get("data", [])
                print(f"[*] Collected information for {len(self.modules)} modules")

            elif msg_type == "hook_status":
                resolved = payload.get("resolved", [])
                failed = payload.get("failed", [])

                # update function contexts
                for func in resolved:
                    addr = func["address"]
                    if addr not in self.function_contexts:
                        func_ctx = FunctionContext(
                            address=int(addr, 16) if isinstance(addr, str) else addr,
                            name=func.get("name"),
                            module=func.get("module"),
                        )
                        self.function_contexts[addr] = func_ctx

                        if self.args.verbose >= 2:
                            print(
                                f"[DEBUG] Registered function context: {addr} ({func.get('name', 'unnamed')})"
                            )

                if failed:
                    print(f"[!] Failed to hook {len(failed)} functions")
                    if self.args.verbose >= 2:
                        for func in failed:
                            print(
                                f"[DEBUG] Failed to hook: {func.get('address', 'unknown')} ({func.get('name', 'unnamed')})"
                            )

            elif msg_type == "calls":
                # process batch of calls
                calls = payload.get("data", [])
                if self.args.verbose >= 2:
                    print(f"[DEBUG] Processing {len(calls)} call events")
                for call_data in calls:
                    try:
                        event = CallEvent(
                            timestamp=call_data["timestamp"],
                            thread_id=call_data["thread_id"],
                            source_addr=int(call_data["source_addr"], 16),
                            target_addr=int(call_data["target_addr"], 16),
                            function_context=int(call_data["function_context"], 16),
                            call_type=call_data["call_type"],
                        )
                        self.call_events.append(event)

                        # update function stats
                        func_addr = call_data["function_context"]
                        if func_addr in self.function_contexts:
                            ctx = self.function_contexts[func_addr]
                            ctx.total_calls += 1
                            ctx.unique_threads.add(event.thread_id)
                            ctx.unique_targets.add(event.target_addr)

                            if self.args.verbose >= 3:
                                print(
                                    f"[TRACE] Call: {event.call_type} from {hex(event.source_addr)} to {hex(event.target_addr)} (ctx: {func_addr})"
                                )

                    except (KeyError, ValueError) as e:
                        if self.args.verbose >= 1:
                            print(f"[-] Error processing call: {e}")
                        if self.args.verbose >= 2:
                            print(f"[-] Call data: {call_data}")

            elif msg_type == "statistics":
                # final statistics
                self.final_stats = payload

            elif msg_type == "shutdown_complete":
                # script has finished cleanup, now we can safely unload
                print("[*] Received shutdown complete signal")
                self.shutdown_complete = True
                self._force_cleanup()

            elif msg_type == "process_complete":
                # target process has finished and data is flushed
                print("[*] Target process completed, all data collected")
                if self.args.verbose >= 2:
                    print(f"[DEBUG] Setting shutdown_complete=True, running=False")
                self.shutdown_complete = True
                self.running = False  # Stop the main loop

            elif msg_type == "error":
                print(f"[!] Error: {payload.get('message', 'Unknown error')}")

        except KeyError as e:
            print(f"[!] Missing required field in message: {e}")
        except Exception as e:
            print(f"[!] Error processing message: {e}")
            if self.args.verbose >= 1:
                import traceback

                traceback.print_exc()

    def _timeout_handler(self):
        """Handle timeout"""
        print(f"\n[!] Timeout reached ({self.args.timeout}s)")
        self.stop_tracing()

    def stop_tracing(self):
        """Stop tracing and cleanup"""
        if not self.running:
            return  # Already stopped

        print("[*] Stopping tracing...")
        self.running = False
        self.end_time = time.time()

        if self.script:
            try:
                # Send shutdown signal
                print("[*] Sending shutdown signal to script...")
                self.script.post({"type": "shutdown"})
            except Exception as e:
                print(f"[-] Warning: Error sending shutdown signal: {e}")
                self._force_cleanup()

    def _force_cleanup(self):
        """Force cleanup when normal shutdown fails"""
        if self.script:
            try:
                self.script.unload()
            except Exception as e:
                if self.args.verbose >= 1:
                    print(f"[-] Warning: Error unloading script: {e}")

        if self.session:
            try:
                self.session.detach()
            except Exception as e:
                if self.args.verbose >= 1:
                    print(f"[-] Warning: Error detaching session: {e}")

        print("[*] Tracing stopped.")

    # --------------------------------------------------------------------------
    # Data Analysis and Export
    # --------------------------------------------------------------------------

    def get_summary(self) -> CallSummary:
        """Generate a summary of the trace data"""
        duration = (self.end_time or time.time()) - self.start_time
        total_calls = len(self.call_events)

        # count unique threads
        unique_threads = set(e.thread_id for e in self.call_events)

        # count calls per target
        target_counts = Counter(hex(e.target_addr) for e in self.call_events)

        # count calls per thread
        thread_counts = Counter(e.thread_id for e in self.call_events)

        # prepare function summaries
        function_summaries = []
        for addr, ctx in self.function_contexts.items():
            function_summaries.append(
                {
                    "address": hex(ctx.address),
                    "name": ctx.name or "unnamed",
                    "calls": ctx.total_calls,
                    "threads": len(ctx.unique_threads),
                    "unique_targets": len(ctx.unique_targets),
                }
            )

        # sort functions by call count
        function_summaries.sort(key=lambda x: x["calls"], reverse=True)

        return CallSummary(
            total_calls=total_calls,
            unique_threads=len(unique_threads),
            duration=duration,
            calls_per_second=total_calls / duration if duration > 0 else 0,
            functions=function_summaries,
            top_targets=target_counts.most_common(10),
            thread_distribution=dict(thread_counts),
        )

    def print_summary(self):
        """Print a neat summary to stdout"""
        summary = self.get_summary()

        print("\n" + "=" * 60)
        print("                    CALL TRACE SUMMARY")
        print("=" * 60)

        print(f"\nTotal Calls:      {summary.total_calls:,}")
        print(f"Unique Threads:   {summary.unique_threads}")
        print(f"Duration:         {summary.duration:.2f}s")
        print(f"Calls/Second:     {summary.calls_per_second:.1f}")

        # Call type breakdown
        call_types = {}
        for event in self.call_events:
            call_types[event.call_type] = call_types.get(event.call_type, 0) + 1

        if call_types:
            print(f"\nCall Types:")
            print("-" * 70)
            for call_type, count in sorted(call_types.items()):
                print(f"{call_type:<12}: {count:>8,}")

        if summary.functions:
            print(f"\nMonitored Functions ({len(summary.functions)}):")
            print("-" * 70)
            print(
                f"{'Module+Offset':<36} {'Name':<36} {'Calls':>16} {'Threads':>8} {'Targets':>8}"
            )
            print("-" * 70)
            for func in summary.functions:
                name = func["name"][:20]
                # Convert address to module+offset for display
                module_offset = self._resolve_address_to_module_offset(func["address"])
                print(
                    f"{module_offset:<36} {name:<36} {func['calls']:>16,} "
                    f"{func['threads']:>8} {func['unique_targets']:>8}"
                )

        if summary.top_targets:
            print(f"\nTop Call Targets:")
            print("-" * 70)
            print(f"{'Module+Offset':<36} {'Count':>16}")
            print("-" * 70)
            for addr, count in summary.top_targets:
                # Convert hex address to module+offset for display
                module_offset = self._resolve_address_to_module_offset(addr)
                print(f"{module_offset:<36} {count:>16,}")

        if len(summary.thread_distribution) > 1:
            print(f"\nThread Distribution:")
            print("-" * 70)
            sorted_threads = sorted(
                summary.thread_distribution.items(), key=lambda x: x[1], reverse=True
            )
            for tid, count in sorted_threads[:5]:
                pct = (count / summary.total_calls) * 100
                print(f"Thread {tid:<8}: {count:>8,} calls ({pct:>5.1f}%)")
            if len(sorted_threads) > 5:
                print(f"... and {len(sorted_threads) - 5} more threads")

        print("\n" + "=" * 70)

    def export_results(self):
        """Export results to file"""
        try:
            output_file = self.args.output
            if not output_file:
                raise ValueError("No output file specified")

            # Validate output directory exists
            output_dir = os.path.dirname(os.path.abspath(output_file))
            if not os.path.exists(output_dir):
                os.makedirs(output_dir, exist_ok=True)
                print(f"[*] Created output directory: {output_dir}")

            # handle compression
            if self.args.compress:
                if not output_file.endswith(".xz"):
                    output_file += ".xz"

            # export based on format
            if self.args.format == "json":
                self._export_json(output_file)
            else:
                raise ValueError(f"Unsupported export format: {self.args.format}")

            if os.path.exists(output_file):
                file_size = os.path.getsize(output_file)
                print(f"[+] Results saved to: {output_file} ({file_size:,} bytes)")
            else:
                print(f"[!] Warning: Output file was not created: {output_file}")

        except Exception as e:
            print(f"[!] Error exporting results: {e}")
            if self.args.verbose >= 1:
                import traceback

                traceback.print_exc()
            raise

    def _export_json(self, filepath):
        """Export to JSON format"""
        try:
            summary = self.get_summary()

            data = {
                "metadata": {
                    "version": VERSION,
                    "target": self.args.target,
                    "start_time": self.start_time,
                    "end_time": self.end_time,
                    "duration": summary.duration,
                    "total_calls": summary.total_calls,
                    "unique_threads": summary.unique_threads,
                    "calls_per_second": summary.calls_per_second,
                    "functions": summary.functions,
                },
                "modules": self.modules,
                "calls": [
                    {
                        "timestamp": e.timestamp,
                        "thread_id": e.thread_id,
                        "source_addr": hex(e.source_addr) if e.source_addr else "0x0",
                        "source_module_offset": (
                            self._resolve_address_to_module_offset(e.source_addr)
                            if e.source_addr
                            else "0x0"
                        ),
                        "target_addr": hex(e.target_addr) if e.target_addr else "0x0",
                        "target_module_offset": (
                            self._resolve_address_to_module_offset(e.target_addr)
                            if e.target_addr
                            else "0x0"
                        ),
                        "function_context": (
                            hex(e.function_context) if e.function_context else "0x0"
                        ),
                        "function_context_module_offset": (
                            self._resolve_address_to_module_offset(e.function_context)
                            if e.function_context
                            else "0x0"
                        ),
                        "call_type": e.call_type or "unknown",
                    }
                    for e in self.call_events
                ],
            }

            if self.args.compress:
                with lzma.open(filepath, "wt", encoding="utf-8") as f:
                    json.dump(data, f, indent=2)
            else:
                with open(filepath, "w", encoding="utf-8") as f:
                    json.dump(data, f, indent=2)

        except (IOError, OSError) as e:
            raise RuntimeError(f"Failed to write JSON file: {e}")
        except Exception as e:
            raise RuntimeError(f"Error creating JSON data: {e}")


# ==============================================================================
# SIGNAL HANDLING AND MAIN FUNCTION
# ==============================================================================


def signal_handler(signum, frame):
    """Handle signals for graceful shutdown"""
    print(f"\n[!] Received signal {signum}, shutting down gracefully...")
    if hasattr(signal_handler, "tracer"):
        signal_handler.tracer.stop_tracing()
        # Don't exit here - let the main loop handle cleanup gracefully


def main():
    parser = argparse.ArgumentParser(
        description="Frida-based call tracer for monitoring function calls",
        formatter_class=argparse.RawTextHelpFormatter,
    )

    # target
    parser.add_argument("target", help="Process ID, process name, or executable path")

    # function selection
    parser.add_argument(
        "-F",
        "--hook-func",
        action="append",
        help="Function address or module+offset to monitor (can be repeated).\n"
        "Examples: 0x401000, 401000, mymodule+0x1234, mymodule+1234",
    )
    parser.add_argument(
        "-n",
        "--hook-name",
        action="append",
        help="Function name to monitor (can be repeated)",
    )
    parser.add_argument(
        "-r",
        "--hook-range",
        action="append",
        help="Address range to monitor (format: START:END)",
    )
    parser.add_argument(
        "-m",
        "--module",
        action="append",
        help="Module to monitor (can be repeated)",
    )
    parser.add_argument(
        "-M",
        "--monitor-all",
        action="store_true",
        help="Monitor all functions in all modules (explicit flag required)",
    )
    parser.add_argument(
        "--no-system",
        action="store_true",
        help="Exclude system modules from monitoring",
    )

    # output options
    parser.add_argument(
        "-o",
        "--output",
        help="Output file path (if not specified, prints summary to stdout)",
    )
    parser.add_argument(
        "-f",
        "--format",
        choices=["json"],
        default="json",
        help="Output format",
    )
    parser.add_argument(
        "--compress", action="store_true", help="Compress output file with XZ/LZMA"
    )

    # control options
    parser.add_argument(
        "-t", "--timeout", type=int, help="Maximum collection time in seconds"
    )
    parser.add_argument(
        "-s",
        "--spawn",
        action="store_true",
        help="Spawn new process instead of attaching",
    )
    parser.add_argument(
        "--disable-aslr",
        action="store_true",
        help="Disable ASLR for spawned process (macOS only, requires code signing)",
    )

    # device options
    parser.add_argument(
        "-D", "--device", default="local", help="Frida device (default: local)"
    )
    parser.add_argument("-H", "--host", help="Connect to remote frida-server")

    # debug options
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="Verbose output (-v for verbose, -vv for extra verbose)",
    )
    parser.add_argument(
        "--buffer-size",
        type=int,
        default=1000,
        help="JavaScript agent buffer size (default: 1000)",
    )

    # target arguments (after --)
    parser.add_argument(
        "target_args",
        nargs="*",
        help="Arguments to pass to spawned process (use after --)",
    )

    args = parser.parse_args()

    # validate arguments
    if not any(
        [args.hook_func, args.hook_name, args.hook_range, args.module, args.monitor_all]
    ):
        print("[-] Error: At least one function selection option required")
        parser.print_help()
        sys.exit(1)

    # threading is already imported at module level

    # create tracer
    tracer = CallTracer(args)

    # setup signal handlers
    signal_handler.tracer = tracer
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # start tracing
    try:
        tracer.start_tracing()

        if args.output:
            print("[*] Tracing started. Press Ctrl+C to stop and save.")
        else:
            print("[*] Tracing started. Press Ctrl+C to stop and see summary.")

        # wait for completion
        if args.timeout:
            time.sleep(args.timeout + 0.5)
        else:
            # poll until interrupted or shutdown complete
            while tracer.running:
                try:
                    time.sleep(0.1)
                    if args.verbose >= 2:
                        print(
                            f"[DEBUG] Main loop: running={tracer.running}, shutdown_complete={tracer.shutdown_complete}"
                        )

                    # Check if spawned process has exited
                    if args.spawn and tracer.pid:
                        try:
                            processes = tracer.device.enumerate_processes()
                            process_exists = any(p.pid == tracer.pid for p in processes)
                            if not process_exists:
                                print("[*] Spawned process has exited")
                                tracer.running = False
                                break
                        except Exception as e:
                            if args.verbose >= 2:
                                print(f"[DEBUG] Error checking process existence: {e}")
                            # If we can't enumerate processes, assume it's still running
                            pass

                except KeyboardInterrupt:
                    print(f"\n[!] Interrupted by user")
                    tracer.stop_tracing()
                    break

            print(
                f"[*] Main loop exited: running={tracer.running}, shutdown_complete={tracer.shutdown_complete}"
            )

            # If shutdown was initiated, wait for it to complete
            if not tracer.running and not tracer.shutdown_complete:
                print("[*] Waiting for data collection to complete...")
                # Wait for shutdown to complete
                wait_start = time.time()
                while (
                    not tracer.shutdown_complete
                    and (time.time() - wait_start) < SHUTDOWN_TIMEOUT_SECONDS
                ):
                    time.sleep(0.01)

                if not tracer.shutdown_complete:
                    print("[-] Timeout waiting for shutdown, forcing cleanup...")
                    tracer._force_cleanup()

    except frida.ProcessNotFoundError:
        print(f"[-] Process not found: {args.target}")
        sys.exit(1)
    except frida.PermissionDeniedError:
        print(f"[-] Permission denied. Try with elevated privileges.")
        sys.exit(1)
    except RuntimeError as e:
        print(f"[-] Error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"[-] Unexpected error: {e}")
        if args.verbose >= 1:
            import traceback

            traceback.print_exc()
        sys.exit(1)
    else:
        # only run this if no exceptions occurred (tracer is properly initialized)
        try:
            tracer.stop_tracing()

            # show results
            tracer.print_summary()

            # export results if requested
            if tracer.call_events:
                if args.output:
                    print(f"[*] Exporting results to {args.output}...")
                    tracer.export_results()
            else:
                print("[!] No calls collected.")
        except Exception as e:
            print(f"[-] Error during cleanup: {e}")
            if args.verbose >= 1:
                import traceback

                traceback.print_exc()


if __name__ == "__main__":
    main()

```

`frida/stalk_drcov.py`:

```py
#!/usr/bin/env python3

"""
stalk_drcov.py
A frida-based basic block tracer that outputs coverage data in the drcov format.

Example usage:

# install frida-tools via uv
uv tool install frida-tools

# run python with uv
uv tool run --from frida-tools python ...

# spawn and trace a binary
python stalk_drcov.py -s /path/to/binary -o coverage.drcov

# attach to existing process by PID
python stalk_drcov.py 1234 -o coverage.drcov

# attach to process by name
python stalk_drcov.py myapp -o coverage.drcov

# trace specific modules only
python stalk_drcov.py 1234 -w main.exe -w helper.dll -o coverage.drcov

# trace all modules excluding system modules
python stalk_drcov.py -s ./target --no-system -o coverage.drcov

# disable ASLR for spawned process (macOS only)
python stalk_drcov.py -s ./target --disable-aslr -o coverage.drcov

# spawn with arguments (use -- to separate)
python stalk_drcov.py -s ./target --no-system -- --input file.txt --verbose

# enable hit count tracking (uses block events)
python stalk_drcov.py -s ./target --hits -o coverage-with-hits.drcov
"""

from __future__ import print_function

import argparse
import json
import os
import signal
import struct
import sys
import time
from typing import List, Dict, Set, Optional

import frida

# constants
VERSION = "1.0.0"
DRCOV_BB_ENTRY_SIZE_BYTES = 8

# javascript agent code for basic block tracing
js_agent_code = """
"use strict";

// configuration passed from python
const config = JSON.parse('CONFIG_JSON_PLACEHOLDER');
const whitelistedModules = config.whitelistedModules || ['all'];
const threadIdList = config.threadIdList || ['all'];
const excludeSystem = config.excludeSystem || false;
const useHitCounting = config.useHitCounting || false;
const verbose = config.verbose || false;

// drcov basic block entries are 8 bytes:
//   uint32_t start_offset; (from module base)
//   uint16_t size;
//   uint16_t mod_id;
const DRCOV_BB_ENTRY_SIZE_BYTES = 8;

// system module detection
function isSystemModule(moduleName, modulePath) {
    const name = moduleName.toLowerCase();
    const path = modulePath ? modulePath.toLowerCase() : '';
    
    // Cross-platform system module patterns
    const systemPatterns = [
        // macOS system modules
        /^lib(system|c|objc|dispatch|foundation|corefoundation|security)/,
        /^(dyld|libdyld)/,
        /\\.framework\\//,
        /^\\/system\\//,
        /^\\/usr\\/lib\\//,
        
        // Linux system modules
        /^lib(c|pthread|dl|m|rt|resolv|nsl|util|crypt)\\.so/,
        /^ld-linux/,
        /^\\/lib\\//,
        /^\\/usr\\/lib\\//,
        /^linux-vdso/,
        
        // Windows system modules  
        /^(ntdll|kernel32|user32|advapi32|ole32|oleaut32|shell32|gdi32|winmm|ws2_32|crypt32|rpcrt4|comctl32|comdlg32|version|shlwapi)\\.dll$/,
        /^msvcrt/,
        /^ucrtbase/,
        /^vcruntime/,
        /^api-ms-/,
        /^ext-ms-/,
        
        // Common patterns
        /^libc\\+\\+/,
        /^libstdc\\+\\+/,
        /^libgcc/
    ];
    
    return systemPatterns.some(pattern => 
        pattern.test(name) || (path && pattern.test(path))
    );
}

// prepare module data
function prepareModuleData() {
    var rawModules = Process.enumerateModules();
    var internalUseModules = [];
    var pythonSendModules = [];

    for (var i = 0; i < rawModules.length; i++) {
        var mod = rawModules[i];
        
        // skip system modules if excludeSystem is enabled
        if (excludeSystem && isSystemModule(mod.name, mod.path)) {
            continue;
        }
        
        var moduleEndAddress = mod.base.add(mod.size);

        // version for internal js use
        internalUseModules.push({
            id: internalUseModules.length, // assign sequential id
            name: mod.name,
            base: mod.base,
            size: mod.size,
            path: mod.path,
            end: moduleEndAddress
        });

        // version for sending to python
        pythonSendModules.push({
            id: internalUseModules.length - 1,
            name: mod.name,
            base: mod.base.toString(),
            size: mod.size,
            path: mod.path,
            end: moduleEndAddress.toString()
        });
    }
    return { internal: internalUseModules, forPython: pythonSendModules };
}

// initial module processing
var moduleProcessingResult = prepareModuleData();
var modulesForJsLogic = moduleProcessingResult.internal;
var modulesForPythonHost = moduleProcessingResult.forPython;

// send the python-friendly module list to the host
send({'type': 'modules', 'data': modulesForPythonHost});

// create a lookup table: module_path -> {id: module_id, start: module_base_nativepointer}
var modulePathToIdMap = {};
modulesForJsLogic.forEach(function (moduleEntry) {
    modulePathToIdMap[moduleEntry.path] = {id: moduleEntry.id, start: moduleEntry.base};
});

// create filtered module map based on whitelist
var filteredModuleMap = new ModuleMap(function (m) {
    if (whitelistedModules.indexOf('all') >= 0) {
        return !excludeSystem || !isSystemModule(m.name, m.path);
    }
    // check if module name matches whitelist
    return whitelistedModules.some(item => m.name.toLowerCase().includes(item.toLowerCase()));
});

// convert basic blocks to drcov format
function convertBasicBlocksToDrcov(basicBlockEvents, activeModuleMap, pathToIdLookup) {
    var buffer = new ArrayBuffer(DRCOV_BB_ENTRY_SIZE_BYTES * basicBlockEvents.length);
    var numEntriesWritten = 0;

    for (var i = 0; i < basicBlockEvents.length; ++i) {
        var blockEvent = basicBlockEvents[i];
        var startAddress = blockEvent[0];
        var endAddress = blockEvent[1];

        var modulePath = activeModuleMap.findPath(startAddress);
        if (modulePath === null) {
            continue;
        }

        var moduleInfo = pathToIdLookup[modulePath];
        if (!moduleInfo || !(moduleInfo.start instanceof NativePointer)) {
            continue;
        }

        var offset = startAddress.sub(moduleInfo.start).toInt32();
        var size = endAddress.sub(startAddress).toInt32();
        var moduleId = moduleInfo.id;

        var currentOffsetBytes = numEntriesWritten * DRCOV_BB_ENTRY_SIZE_BYTES;

        // write offset (uint32_t)
        new Uint32Array(buffer, currentOffsetBytes, 1)[0] = offset;
        // write size (uint16_t) and mod_id (uint16_t)
        var uint16View = new Uint16Array(buffer, currentOffsetBytes + 4, 2);
        uint16View[0] = size;
        uint16View[1] = moduleId;

        ++numEntriesWritten;
    }

    if (numEntriesWritten === 0) {
        return null;
    }
    return new Uint8Array(buffer, 0, numEntriesWritten * DRCOV_BB_ENTRY_SIZE_BYTES);
}

// stalker configuration
Stalker.trustThreshold = 0;

// track active stalkers
var activeStalkers = new Set();

// start stalking thread if needed
function startStalkingThreadIfNeeded(threadId) {
    var shouldStalkThisThread = threadIdList.indexOf('all') >= 0 || threadIdList.indexOf(threadId) >= 0;

    if (!shouldStalkThisThread) {
        return;
    }

    if (activeStalkers.has(threadId)) {
        return; // already stalking
    }

    if (verbose) console.log('Stalking thread ' + threadId);
    activeStalkers.add(threadId);

    // Configure events based on hit counting mode
    var stalkerEvents = useHitCounting ? {
        block: true    // Use block events for hit counting
    } : {
        compile: true  // Use compile events for coverage only
    };
    
    // Convert thread ID to unsigned integer for Frida
    // On Linux, thread IDs can be negative, but Stalker.follow expects unsigned
    var unsignedThreadId = threadId >>> 0;
    
    Stalker.follow(unsignedThreadId, {
        events: stalkerEvents,
        onReceive: function (rawStalkerEvents) {
            try {
                var parsedBasicBlocks = Stalker.parse(rawStalkerEvents, {stringify: false, annotate: false});

                if (parsedBasicBlocks && parsedBasicBlocks.length > 0) {
                    var drcovFormattedBlocks = convertBasicBlocksToDrcov(parsedBasicBlocks, filteredModuleMap, modulePathToIdMap);
                    if (drcovFormattedBlocks && drcovFormattedBlocks.buffer.byteLength > 0) {
                        send({type: 'bbs'}, drcovFormattedBlocks);
                    }
                }
            } catch (e) {
                console.error('Error in stalker onReceive for thread ' + threadId + ':', e.message);
            }
        }
    });
}

// thread observer for handling both existing and new threads
var threadObserver = Process.attachThreadObserver({
    onAdded: function (thread) {
        startStalkingThreadIfNeeded(thread.id);
    },
    onRemoved: function (thread) {
        if (activeStalkers.has(thread.id)) {
            activeStalkers.delete(thread.id);
            if (verbose) console.log('Thread ' + thread.id + ' removed from stalker tracking');
        }
    }
});

if (verbose) console.log('Thread observer ready');

// handle shutdown
recv(function(message) {
    if (message.type === 'shutdown') {
        if (verbose) console.log('Received shutdown request');
        
        // stop all stalkers
        activeStalkers.forEach(function(threadId) {
            try {
                Stalker.unfollow(threadId);
            } catch (e) {
                console.error('Error stopping stalker for thread ' + threadId + ':', e.message);
            }
        });
        activeStalkers.clear();
        
        // detach thread observer
        if (threadObserver) {
            threadObserver.detach();
        }
        
        send({type: 'shutdown_complete'});
    }
});

// send ready signal
send({type: 'ready'});
"""


class StalkDrcovTracer:
    """Main tracer class for basic block coverage collection"""

    def __init__(self, args):
        self.args = args

        # Frida objects
        self.device = None
        self.session = None
        self.script = None
        self.pid = None

        # State tracking
        self.running = False
        self.shutdown_complete = False

        # Data storage - depends on hit counting mode
        self.modules = []
        self._initialize_storage()

    def _initialize_storage(self):
        """Initialize basic blocks storage based on mode"""
        if self.args.hits:
            # Dict for hit counting: bb_entry_bytes -> count
            self.basic_blocks = {}
            print("[*] Coverage mode: Hit counting (using block events)")
        else:
            # Set for coverage tracking (standard drcov behavior)
            self.basic_blocks = set()
            print("[*] Coverage mode: Basic (using compile events)")

    def start_tracing(self):
        """Start the tracing process"""
        try:
            # get device
            self.device = self._get_device()

            # attach or spawn
            if self.args.spawn:
                self._spawn_process()
            else:
                self._attach_process()

            # inject script
            self._inject_script()

            # resume if spawned
            if self.args.spawn:
                self.device.resume(self.pid)
                print("[+] Process resumed")

            self.running = True

        except Exception as e:
            # cleanup on failure
            if hasattr(self, "session") and self.session:
                try:
                    self.session.detach()
                except:
                    pass
            raise e

    def _get_device(self):
        """Get the Frida device"""
        try:
            if self.args.host:
                manager = frida.get_device_manager()
                device = manager.add_remote_device(self.args.host)
                print(f"[*] Using remote device: {self.args.host}")
            else:
                device = frida.get_device(self.args.device)
                print(f"[*] Using device: {device.id}")
            return device
        except Exception as e:
            raise RuntimeError(f"Failed to get Frida device: {e}")

    def _spawn_process(self):
        """Spawn a new process"""
        try:
            target_path = self.args.target
            print(f"[*] Spawning: {target_path}")

            spawn_options = {}
            if self.args.disable_aslr:
                spawn_options["aslr"] = "disable"
                print("[*] ASLR disabled for spawned process")

            # Build command line with target and arguments
            cmd_line = [target_path] + self.args.target_args
            if self.args.target_args:
                print(f"[*] Spawning with arguments: {' '.join(cmd_line)}")
            self.pid = self.device.spawn(cmd_line, **spawn_options)
            print(f"[+] Spawned process with PID: {self.pid}")

            self.session = self.device.attach(self.pid)
            print(f"[+] Attached to spawned process")

        except frida.ExecutableNotFoundError:
            raise RuntimeError(f"Executable not found: {target_path}")
        except Exception as e:
            raise RuntimeError(f"Failed to spawn process: {e}")

    def _attach_process(self):
        """Attach to existing process"""
        try:
            target = self.args.target

            # try to parse as PID first
            try:
                self.pid = int(target)
                print(f"[*] Attaching to PID: {self.pid}")
                self.session = self.device.attach(self.pid)
                print(f"[+] Attached to PID: {self.pid}")
            except ValueError:
                # treat as process name
                print(f"[*] Looking for process: {target}")
                try:
                    process = self.device.get_process(target)
                    self.pid = process.pid
                    print(f"[*] Found process '{target}' with PID: {self.pid}")
                    self.session = self.device.attach(self.pid)
                    print(f"[+] Attached to process")
                except frida.ProcessNotFoundError:
                    # fallback to enumeration
                    print(
                        f"[*] Process '{target}' not found by direct lookup, searching..."
                    )
                    try:
                        processes = self.device.enumerate_processes()
                        matches = [
                            p
                            for p in processes
                            if target.lower() in p.name.lower() or str(p.pid) == target
                        ]

                        if not matches:
                            available_processes = [
                                f"{p.pid}: {p.name}" for p in processes[:10]
                            ]
                            available_str = "\n".join(available_processes)
                            if len(processes) > 10:
                                available_str += (
                                    f"\n... and {len(processes) - 10} more processes"
                                )

                            raise RuntimeError(
                                f"Process '{target}' not found.\n"
                                f"Available processes (showing first 10):\n{available_str}\n\n"
                                f"Use a valid PID or process name."
                            )
                        elif len(matches) > 1:
                            print(f"[!] Multiple processes match '{target}':")
                            for p in matches:
                                print(f"    PID: {p.pid}, Name: {p.name}")
                            self.pid = matches[0].pid
                            print(f"[*] Using first match: PID {self.pid}")
                        else:
                            self.pid = matches[0].pid
                            print(
                                f"[*] Found process: PID {self.pid}, Name: {matches[0].name}"
                            )

                        self.session = self.device.attach(self.pid)
                        print(f"[+] Attached to process")

                    except Exception as e:
                        raise RuntimeError(
                            f"Failed to enumerate or attach to processes: {e}"
                        )
            except frida.ProcessNotFoundError:
                raise RuntimeError(
                    f"Process with PID {self.pid} not found or access denied"
                )
            except Exception as e:
                raise RuntimeError(f"Failed to attach to process: {e}")

        except Exception as e:
            raise RuntimeError(f"Failed to attach to process: {e}")

    def _inject_script(self):
        """Inject the JavaScript agent"""
        try:
            # prepare configuration
            config = {
                "whitelistedModules": self.args.whitelist_modules or ["all"],
                "threadIdList": self.args.thread_id or ["all"],
                "excludeSystem": self.args.no_system,
                "useHitCounting": self.args.hits,
                "verbose": self.args.verbose,
            }

            # inject script with properly escaped JSON
            config_json = json.dumps(config)
            config_json_escaped = config_json.replace("\\", "\\\\").replace("'", "\\'")
            script_code = js_agent_code.replace(
                "CONFIG_JSON_PLACEHOLDER", config_json_escaped
            )

            self.script = self.session.create_script(script_code)
            self.script.on("message", self._on_message)
            self.script.load()

        except Exception as e:
            raise RuntimeError(f"Failed to inject JavaScript agent: {e}")

    def _on_message(self, message, data):
        """Handle messages from the JS agent"""
        try:
            if message["type"] == "error":
                print(f"[!] Script error: {message}")
                return

            if message["type"] == "send":
                payload = message.get("payload", {})
                msg_type = payload.get("type")

                if msg_type == "ready":
                    print("[+] Agent ready")

                elif msg_type == "modules":
                    self.modules = payload.get("data", [])
                    print(f"[*] Modules: {len(self.modules)} loaded")

                elif msg_type == "bbs":
                    if data:
                        self._process_basic_blocks(data)

                elif msg_type == "shutdown_complete":
                    print("[*] Shutdown complete")
                    self.shutdown_complete = True

        except Exception as e:
            print(f"[!] Error processing message: {e}")

    def _process_basic_blocks(self, bb_data_buffer):
        """Process basic block data from JS agent"""
        if not bb_data_buffer or len(bb_data_buffer) == 0:
            return

        if len(bb_data_buffer) % DRCOV_BB_ENTRY_SIZE_BYTES != 0:
            print(f"[!] Invalid BB data length: {len(bb_data_buffer)}")
            return

        # process each basic block entry
        for i in range(0, len(bb_data_buffer), DRCOV_BB_ENTRY_SIZE_BYTES):
            bb_entry = bb_data_buffer[i : i + DRCOV_BB_ENTRY_SIZE_BYTES]

            if self.args.hits:
                # track hit counts in dict
                if bb_entry in self.basic_blocks:
                    self.basic_blocks[bb_entry] += 1
                else:
                    self.basic_blocks[bb_entry] = 1
            else:
                # just track coverage in set
                self.basic_blocks.add(bb_entry)

    def stop_tracing(self):
        """Stop tracing and cleanup"""
        if not self.running:
            return

        print("[*] Stopping tracing...")
        self.running = False

        if self.script:
            try:
                print("[*] Sending shutdown signal...")
                self.script.post({"type": "shutdown"})

                # wait for shutdown complete
                timeout = 5.0
                start_time = time.time()
                while (
                    not self.shutdown_complete and (time.time() - start_time) < timeout
                ):
                    time.sleep(0.1)

                if not self.shutdown_complete:
                    print("[!] Timeout waiting for shutdown")

            except Exception as e:
                print(f"[!] Error during shutdown: {e}")

        # cleanup session
        if self.session:
            try:
                self.session.detach()
                print("[+] Session detached")
            except Exception as e:
                print(f"[!] Error detaching session: {e}")

    def save_coverage(self):
        """Save coverage data to drcov file"""
        try:
            output_file = self.args.output
            if not output_file:
                output_file = "frida-cov.drcov"

            # Generate status message
            block_count = len(self.basic_blocks)
            if self.args.hits:
                total_hits = sum(self.basic_blocks.values())
                status_msg = f"[*] Saving {block_count:,} unique basic blocks ({total_hits:,} total hits) to '{output_file}'..."
            else:
                status_msg = f"[*] Saving {block_count:,} unique basic blocks to '{output_file}'..."
            print(status_msg)

            # create drcov header
            header = self._create_drcov_header()

            # create drcov body
            body = self._create_drcov_body()

            # write file
            with open(output_file, "wb") as f:
                f.write(header)
                f.write(body)

            print(f"[+] Coverage data saved to: {output_file}")

        except Exception as e:
            print(f"[!] Error saving coverage: {e}")

    def _create_drcov_header(self):
        """Create drcov file header"""
        lines = []
        lines.append("DRCOV VERSION: 2")
        # Set flavor based on hit counting mode
        if self.args.hits:
            lines.append("DRCOV FLAVOR: drcov-hits")
        else:
            lines.append("DRCOV FLAVOR: frida")

        if not self.modules:
            lines.append("Module Table: version 2, count 0")
        else:
            lines.append(f"Module Table: version 2, count {len(self.modules)}")

        lines.append("Columns: id, base, end, entry, checksum, timestamp, path")

        for module in self.modules:
            line = "%3d, %#016x, %#016x, %#016x, %#08x, %#08x, %s" % (
                module["id"],
                int(module["base"], 16),
                int(module["end"], 16),
                0,  # entry point
                0,  # checksum
                0,  # timestamp
                module["name"],  # Use basename instead of full path
            )
            lines.append(line)

        return ("\n".join(lines) + "\n").encode("utf-8")

    def _create_drcov_body(self):
        """Create drcov file body (standard or hit count format)"""
        if self.args.hits:
            return self._create_hit_count_body()
        else:
            return self._create_standard_body()

    def _create_standard_body(self):
        """Create standard drcov body (coverage only)"""
        sorted_bbs = sorted(list(self.basic_blocks))
        bb_header = f"BB Table: {len(sorted_bbs)} bbs\n".encode("utf-8")
        bb_data = b"".join(sorted_bbs)
        return bb_header + bb_data

    def _create_hit_count_body(self):
        """Create drcov body with hit count table"""
        # Sort basic blocks for deterministic output
        sorted_bb_items = sorted(self.basic_blocks.items())
        bb_entries = [bb_entry for bb_entry, count in sorted_bb_items]
        hit_counts = [count for bb_entry, count in sorted_bb_items]

        # Create BB Table
        bb_header = f"BB Table: {len(bb_entries)} bbs\n".encode("utf-8")
        bb_data = b"".join(bb_entries)

        # Create Hit Count Table (as per proposal specification)
        hit_header = f"Hit Count Table: version 1, count {len(hit_counts)}\n".encode(
            "utf-8"
        )
        hit_data = b"".join(struct.pack("<I", count) for count in hit_counts)

        return bb_header + bb_data + hit_header + hit_data


def signal_handler(signum, frame):
    """Handle signals for graceful shutdown"""
    print(f"\n[!] Received signal {signum}, shutting down...")
    if hasattr(signal_handler, "tracer"):
        signal_handler.tracer.stop_tracing()


def main():
    parser = argparse.ArgumentParser(
        description="Frida-based basic block tracer outputting drcov format",
        formatter_class=argparse.RawTextHelpFormatter,
    )

    # Target specification
    parser.add_argument("target", help="Process ID, process name, or executable path")
    parser.add_argument(
        "target_args",
        nargs="*",
        help="Arguments to pass to spawned process (use after --)",
    )

    # Execution mode
    parser.add_argument(
        "-s",
        "--spawn",
        action="store_true",
        help="Spawn new process instead of attaching",
    )
    parser.add_argument(
        "--disable-aslr",
        action="store_true",
        help="Disable ASLR for spawned process (macOS only)",
    )

    # Output options
    parser.add_argument(
        "-o",
        "--output",
        default="frida-cov.drcov",
        help="Output drcov file path (default: frida-cov.drcov)",
    )
    parser.add_argument(
        "--hits",
        action="store_true",
        help="Enable hit count tracking (uses block events, generates drcov-hits format)",
    )

    # Filtering options
    parser.add_argument(
        "-w",
        "--whitelist-modules",
        action="append",
        default=[],
        help="Module name to trace (can be repeated, default: all modules)",
    )
    parser.add_argument(
        "-t",
        "--thread-id",
        action="append",
        default=[],
        help="Thread ID to trace (can be repeated, default: all threads)",
    )
    parser.add_argument(
        "--no-system", action="store_true", help="Exclude system modules from tracing"
    )

    # Control options
    parser.add_argument(
        "--timeout", type=int, help="Maximum collection time in seconds"
    )

    # Device options
    parser.add_argument(
        "-D", "--device", default="local", help="Frida device (default: local)"
    )
    parser.add_argument("-H", "--host", help="Connect to remote frida-server")

    # Debug options
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    args = parser.parse_args()

    # create tracer
    tracer = StalkDrcovTracer(args)

    # setup signal handlers
    signal_handler.tracer = tracer
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    try:
        # start tracing
        tracer.start_tracing()
        print("[*] Tracing started. Press Ctrl+C to stop and save.")

        # wait for completion
        if args.timeout:
            time.sleep(args.timeout)
            tracer.stop_tracing()
        else:
            # wait for interrupt
            while tracer.running:
                try:
                    time.sleep(0.1)

                    # check if spawned process has exited
                    if args.spawn and tracer.pid:
                        try:
                            processes = tracer.device.enumerate_processes()
                            process_exists = any(p.pid == tracer.pid for p in processes)
                            if not process_exists:
                                print("[*] Spawned process has exited")
                                tracer.stop_tracing()
                                break
                        except:
                            pass  # ignore enumeration errors

                except KeyboardInterrupt:
                    print("\n[!] Interrupted by user")
                    tracer.stop_tracing()
                    break

    except frida.ProcessNotFoundError:
        print(f"[-] Process not found: {args.target}")
        sys.exit(1)
    except frida.PermissionDeniedError:
        print(f"[-] Permission denied. Try with elevated privileges.")
        sys.exit(1)
    except RuntimeError as e:
        print(f"[-] Error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"[-] Unexpected error: {e}")
        if args.verbose:
            import traceback

            traceback.print_exc()
        sys.exit(1)
    else:
        # only run this if no exceptions occurred (tracer is properly initialized)
        try:
            # save results
            tracer.save_coverage()
        except Exception as e:
            print(f"[-] Error saving coverage: {e}")
            if args.verbose:
                import traceback

                traceback.print_exc()


if __name__ == "__main__":
    main()

```

`samples/CMakeLists.txt`:

```txt
add_subdirectory(programs)

```

`samples/programs/CMakeLists.txt`:

```txt
# sample programs for tracer demos and instrumentation targets

include(${W1_SOURCE_DIR}/cmake/SampleConfig.cmake)

set(samples_output_dir ${W1_OUTPUT_SAMPLE_DIR}/programs)

add_subdirectory(instraware)

# core sample programs
w1_add_sample_program(multi_threaded_target
    SOURCES multi_threaded_target.c
    OUTPUT_DIR ${samples_output_dir}
)

w1_add_sample_program(control_flow_1
    SOURCES control_flow_1.cpp
    OUTPUT_DIR ${samples_output_dir}
)

w1_add_sample_program(runtime_injection_target
    SOURCES runtime_injection_target.c
    OUTPUT_DIR ${samples_output_dir}
)

w1_add_sample_program(simple_demo
    SOURCES simple_demo.c
    OUTPUT_DIR ${samples_output_dir}
)

# rewind tracer demos
w1_add_sample_program(rewind_demo_basic
    SOURCES rewind_demo_basic.c
    OUTPUT_DIR ${samples_output_dir}
)

w1_add_sample_program(rewind_demo_calls
    SOURCES rewind_demo_calls.c
    OUTPUT_DIR ${samples_output_dir}
)

w1_add_sample_program(rewind_demo_memops
    SOURCES rewind_demo_memops.c
    OUTPUT_DIR ${samples_output_dir}
)

w1_add_sample_program(rewind_demo_io
    SOURCES rewind_demo_io.c
    OUTPUT_DIR ${samples_output_dir}
)

w1_add_sample_program(rewind_demo_algorithms
    SOURCES rewind_demo_algorithms.c
    OUTPUT_DIR ${samples_output_dir}
)

w1_add_sample_program(rewind_demo_million
    SOURCES rewind_demo_million.c
    OUTPUT_DIR ${samples_output_dir}
)

# thread test demo programs
w1_add_sample_program(threadtest_demo
    SOURCES threadtest_demo.c
    OUTPUT_DIR ${samples_output_dir}
)

w1_add_sample_program(threadtest_evasive_demo
    SOURCES threadtest_evasive_demo.cpp
    OUTPUT_DIR ${samples_output_dir}
)

# hook test target program for signature-based hooking
w1_add_sample_program(hook_test_target
    SOURCES hook_test_target.c
    OUTPUT_DIR ${samples_output_dir}
)

# linux-specific target programs
if(UNIX AND NOT APPLE)
    w1_add_sample_program(linux_target
        SOURCES linux_target.c
        OUTPUT_DIR ${samples_output_dir}
    )

    w1_add_sample_program(linux_daemon
        SOURCES linux_daemon.c
        OUTPUT_DIR ${samples_output_dir}
    )
endif()

# p1ll sample program (only build when lua scripting is enabled)
if(WITNESS_SCRIPT)
    w1_add_sample_program(p1ll_test_target
        SOURCES p1ll_test_target.c
        OUTPUT_DIR ${samples_output_dir}
    )
endif()

# platform-specific linking
if(WIN32)
    # no additional libraries needed for Windows
elseif(UNIX)
    target_link_libraries(multi_threaded_target PRIVATE pthread)
    target_link_libraries(runtime_injection_target PRIVATE pthread)
    target_link_libraries(threadtest_demo PRIVATE pthread)
    target_link_libraries(threadtest_evasive_demo PRIVATE pthread)
endif()

# enable sanitizers for sample programs in debug builds
set(sample_targets
    multi_threaded_target
    control_flow_1
    runtime_injection_target
    simple_demo
    rewind_demo_basic
    rewind_demo_calls
    rewind_demo_memops
    rewind_demo_io
    rewind_demo_algorithms
    rewind_demo_million
    threadtest_demo
    threadtest_evasive_demo
    hook_test_target
)

list(APPEND sample_targets
    instraware_qbdi_rai
    instraware_qbdi_stack
    instraware_qbdi_smc
    instraware_qbdi_fault
)

if(WITNESS_SCRIPT)
    list(APPEND sample_targets p1ll_test_target)
endif()

if(UNIX AND NOT APPLE)
    list(APPEND sample_targets linux_target linux_daemon)
endif()

w1_apply_debug_sanitizers_to_targets(${sample_targets})

# install targets
install(TARGETS ${sample_targets}
    RUNTIME DESTINATION bin/samples/programs
    COMPONENT ${W1_INSTALL_COMPONENT}
)

```

`samples/programs/control_flow_1.cpp`:

```cpp
#include <algorithm>
#include <chrono>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>
#include <vector>

#ifdef _WIN32
#include <process.h>
#include <windows.h>
#define getpid _getpid
#else
#include <unistd.h>
#endif

class ValidationEngine {
private:
  static constexpr uint32_t MAGIC_CONSTANT = 0xDEADBEEF;
  static constexpr const char* SECRET_KEY = "w1tn3ss_cr4ckm3";

  bool anti_debug_check() {
    // simple timing-based anti-debug (cross-platform)
    auto start = std::chrono::high_resolution_clock::now();
    volatile int dummy = 0;
    for (int i = 0; i < 1000; i++) {
      dummy += i;
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

    // if execution takes too long, might be debugged
    // more lenient timing for cross-platform compatibility
    return duration.count() < 10000;
  }

  uint32_t hash_string(const std::string& input) {
    uint32_t hash = 5381;
    for (char c : input) {
      hash = ((hash << 5) + hash) + static_cast<uint32_t>(c);
    }
    return hash ^ MAGIC_CONSTANT;
  }

  bool validate_length(const std::string& input) { return input.length() >= 8 && input.length() <= 32; }

  bool validate_charset(const std::string& input) {
    bool has_upper = false, has_lower = false, has_digit = false;

    for (char c : input) {
      if (c >= 'A' && c <= 'Z') {
        has_upper = true;
      } else if (c >= 'a' && c <= 'z') {
        has_lower = true;
      } else if (c >= '0' && c <= '9') {
        has_digit = true;
      } else if (c == '_' || c == '-') {
        continue;
      } else {
        return false;
      }
    }

    return has_upper && has_lower && has_digit;
  }

  bool validate_pattern(const std::string& input) {
    // must contain "w1" somewhere
    if (input.find("w1") == std::string::npos) {
      return false;
    }

    // must not start with digit
    if (!input.empty() && input[0] >= '0' && input[0] <= '9') {
      return false;
    }

    // must contain at least 2 uppercase letters
    int upper_count = 0;
    for (char c : input) {
      if (c >= 'A' && c <= 'Z') {
        upper_count++;
      }
    }

    return upper_count >= 2;
  }

  bool validate_checksum(const std::string& input) {
    // the correct password is "w1tn3ss_H4ckM3" but good luck finding it without
    // reversing
    uint32_t expected_hash = 0x1a7a9dde;
    uint32_t actual_hash = hash_string(input);

    // obfuscate the comparison
    uint32_t diff = expected_hash ^ actual_hash;
    return diff == 0;
  }

public:
  enum ValidationResult {
    SUCCESS = 0,
    ANTI_DEBUG_FAILED = 1,
    LENGTH_FAILED = 2,
    CHARSET_FAILED = 3,
    PATTERN_FAILED = 4,
    CHECKSUM_FAILED = 5
  };

  ValidationResult validate_input(const std::string& input) {
    // stage 1: anti-debug check
    if (!anti_debug_check()) {
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
      return ANTI_DEBUG_FAILED;
    }

    // stage 2: length validation
    if (!validate_length(input)) {
      return LENGTH_FAILED;
    }

    // stage 3: charset validation
    if (!validate_charset(input)) {
      return CHARSET_FAILED;
    }

    // stage 4: pattern validation
    if (!validate_pattern(input)) {
      return PATTERN_FAILED;
    }

    // stage 5: final checksum
    if (!validate_checksum(input)) {
      return CHECKSUM_FAILED;
    }

    return SUCCESS;
  }

  void print_hint(ValidationResult result) {
    switch (result) {
    case ANTI_DEBUG_FAILED:
      std::cout << "hint: something's watching..." << std::endl;
      break;
    case LENGTH_FAILED:
      std::cout << "hint: length matters (8-32 chars)" << std::endl;
      break;
    case CHARSET_FAILED:
      std::cout << "hint: mix it up (upper, lower, digits, _/-)" << std::endl;
      break;
    case PATTERN_FAILED:
      std::cout << "hint: witness the pattern (w1 + 2 uppercase)" << std::endl;
      break;
    case CHECKSUM_FAILED:
      std::cout << "hint: close, but not quite..." << std::endl;
      break;
    case SUCCESS:
      break;
    }
  }
};

void print_banner() {
  std::cout << "╔══════════════════════════════════════════════╗" << std::endl;
  std::cout << "║           w1tn3ss control flow #1            ║" << std::endl;
  std::cout << "║              crackme challenge               ║" << std::endl;
  std::cout << "╚══════════════════════════════════════════════╝" << std::endl;
  std::cout << std::endl;
}

void success_message() {
  std::cout << std::endl;
  std::cout << "*** congratulations! you've cracked it! ***" << std::endl;
  std::cout << "the control flow analysis revealed the path..." << std::endl;
  std::cout << std::endl;
  std::cout << "flag: w1tn3ss{c0ntr0l_fl0w_m4st3r}" << std::endl;
}

void failure_message(int attempts) {
  std::cout << std::endl;
  if (attempts >= 5) {
    std::cout << "*** too many failed attempts. access denied. ***" << std::endl;
    std::cout << "hint: try analyzing the control flow..." << std::endl;
  } else {
    std::cout << "*** access denied. attempts remaining: " << (5 - attempts) << " ***" << std::endl;
  }
}

int main(int argc, char* argv[]) {
  print_banner();

  ValidationEngine engine;
  std::string input;
  int attempts = 0;
  const int max_attempts = 5;

  // check for command line argument
  if (argc > 1) {
    input = argv[1];
    std::cout << "validating provided key: " << input << std::endl;

    auto result = engine.validate_input(input);
    if (result == ValidationEngine::SUCCESS) {
      success_message();
      return 0;
    } else {
      engine.print_hint(result);
      failure_message(1);
      return 1;
    }
  }

  // interactive mode
  std::cout << "enter the access key: ";
  while (attempts < max_attempts && std::getline(std::cin, input)) {
    attempts++;

    if (input.empty()) {
      std::cout << "empty input. try again: ";
      continue;
    }

    auto result = engine.validate_input(input);

    if (result == ValidationEngine::SUCCESS) {
      success_message();
      return 0;
    }

    engine.print_hint(result);
    failure_message(attempts);

    if (attempts < max_attempts) {
      std::cout << "enter the access key: ";
    }
  }

  return 1;
}
```

`samples/programs/hook_test_target.c`:

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#ifdef _WIN32
#include <io.h>
#else
#include <unistd.h>
#endif

#include "signature_helper.h"

// create unique signatures using inline asm with different constants
#if defined(__x86_64__)
#define UNIQUE_SIGNATURE(id) __asm__ volatile("movabs $0xDEADBEEF0000" #id ", %%rax\n\t" : : : "rax")
#elif defined(__aarch64__)
#define UNIQUE_SIGNATURE(id)                                                                                           \
  __asm__ volatile("mov x0, #0x" #id "\n\t"                                                                            \
                   "movk x0, #0xBEEF, lsl #16\n\t"                                                                     \
                   "movk x0, #0xDEAD, lsl #32\n\t"                                                                     \
                   :                                                                                                   \
                   :                                                                                                   \
                   : "x0")
#else
#define UNIQUE_SIGNATURE(id) ASM_SIGNATURE_HELPER()
#endif

// test function 1: simple arithmetic with signature
NOINLINE int calculate_secret(int a, int b) {
  UNIQUE_SIGNATURE(1111);
  printf("[calculate_secret] computing %d * 3 + %d * 2\n", a, b);
  return 3 * a + 2 * b;
}

// test function 2: string operation with signature
#define MAX_BUFFER_SIZE 256
NOINLINE void format_message(char buffer[MAX_BUFFER_SIZE], const char* name, int value) {
  UNIQUE_SIGNATURE(2222);
  snprintf(buffer, MAX_BUFFER_SIZE, "hello %s, your magic number is %d", name, value);
  printf("[format_message] formatted: %s\n", buffer);
}

// test function 3: memory allocation with signature
NOINLINE void* allocate_buffer(size_t size) {
  UNIQUE_SIGNATURE(3333);
  printf("[allocate_buffer] allocating %zu bytes\n", size);
  void* ptr = malloc(size);
  if (ptr) {
    memset(ptr, 0, size);
  }
  return ptr;
}

// test function 4: comparison with signature
NOINLINE int compare_strings(const char* str1, const char* str2) {
  UNIQUE_SIGNATURE(4444);
  printf("[compare_strings] comparing \"%s\" with \"%s\"\n", str1, str2);
  return strcmp(str1, str2);
}

// test function 5: vulnerable function for security testing
NOINLINE void unsafe_copy(char* dst, const char* src) {
  UNIQUE_SIGNATURE(5555);
  // intentionally unsafe for testing security monitoring
  strcpy(dst, src);
  printf("[unsafe_copy] copied: %s\n", dst);
}

// utility functions that can be called via gadgeting

// function to get string length (useful for gadgeting)
NOINLINE size_t get_string_length(const char* str) {
  UNIQUE_SIGNATURE(6666);
  if (!str) {
    return 0;
  }
  return strlen(str);
}

// function to check if buffer contains pattern (useful for analysis)
NOINLINE int contains_pattern(const char* buffer, const char* pattern) {
  UNIQUE_SIGNATURE(7777);
  if (!buffer || !pattern) {
    return 0;
  }
  return strstr(buffer, pattern) != NULL;
}

// function to compute hash (useful for integrity checks)
NOINLINE unsigned int compute_hash(const void* data, size_t len) {
  UNIQUE_SIGNATURE(8888);
  const unsigned char* bytes = (const unsigned char*) data;
  unsigned int hash = 5381;
  for (size_t i = 0; i < len; i++) {
    hash = ((hash << 5) + hash) + bytes[i];
  }
  return hash;
}

// function to get process info (useful for context)
NOINLINE int get_process_id(void) {
  UNIQUE_SIGNATURE(9999);
  return getpid();
}

// function to validate pointer (useful for safety checks)
NOINLINE int is_valid_pointer(const void* ptr) {
  UNIQUE_SIGNATURE(aaaa);
  if (!ptr) {
    return 0;
  }
  // simple heuristic - check if it's in reasonable address range
  uintptr_t addr = (uintptr_t) ptr;
  return addr > 0x1000 && addr < 0x7fffffffffff;
}

int main(int argc, char* argv[]) {
  printf("=== hook test target program ===\n");
  printf("this program contains functions with asm signatures for testing\n\n");

  // test 1: calculate secret
  int x = 10, y = 20;
  int result = calculate_secret(x, y);
  printf("result: %d\n\n", result);

  // test 2: format message
  char message[MAX_BUFFER_SIZE];
  format_message(message, "tester", 42);
  printf("message: %s\n\n", message);

  // test 3: allocate buffer
  void* buffer = allocate_buffer(128);
  if (buffer) {
    printf("buffer allocated at: %p\n", buffer);
    free(buffer);
  }
  printf("\n");

  // test 4: compare strings
  const char* str1 = "hello";
  const char* str2 = "world";
  int cmp_result = compare_strings(str1, str2);
  printf("comparison result: %d\n\n", cmp_result);

  // test 5: unsafe copy (if argument provided)
  if (argc > 1) {
    char dest[64]; // small buffer for testing
    printf("performing unsafe copy of argument: %s\n", argv[1]);
    unsafe_copy(dest, argv[1]);
  }

  printf("=== test complete ===\n");
  return 0;
}
```

`samples/programs/instraware/CMakeLists.txt`:

```txt
set(INSTRAWARE_COMMON_SOURCES
    instraware_common.cpp
)

function(add_instraware_target target_name source_file)
    add_executable(${target_name} ${source_file} ${INSTRAWARE_COMMON_SOURCES})
    w1_target_defaults(${target_name})
    target_include_directories(${target_name} PRIVATE ${CMAKE_CURRENT_LIST_DIR})
    set_target_properties(${target_name} PROPERTIES
        RUNTIME_OUTPUT_DIRECTORY ${samples_output_dir}
    )
endfunction()

add_instraware_target(instraware_qbdi_rai instraware_qbdi_rai.cpp)
add_instraware_target(instraware_qbdi_stack instraware_qbdi_stack.cpp)
add_instraware_target(instraware_qbdi_smc instraware_qbdi_smc.cpp)
add_instraware_target(instraware_qbdi_fault instraware_qbdi_fault.cpp)

target_compile_options(instraware_qbdi_rai PRIVATE
    $<$<CXX_COMPILER_ID:GNU,Clang>:-fno-omit-frame-pointer -fno-optimize-sibling-calls>
    $<$<CXX_COMPILER_ID:MSVC>:/Oy- /Ob0>
)

target_compile_options(instraware_qbdi_stack PRIVATE
    $<$<CXX_COMPILER_ID:GNU,Clang>:-fno-omit-frame-pointer -fno-optimize-sibling-calls>
    $<$<CXX_COMPILER_ID:MSVC>:/Oy- /Ob0>
)

```

`samples/programs/instraware/instraware_common.cpp`:

```cpp
#include "instraware_common.hpp"

#include <cstdlib>
#include <cstring>

#if defined(_WIN32)
#include <windows.h>
#elif defined(__APPLE__)
#include <mach/mach_time.h>
#include <time.h>
#else
#include <time.h>
#endif

namespace instraware {
namespace {

std::string escape_json(const std::string& input) {
  std::string out;
  out.reserve(input.size());
  for (char c : input) {
    switch (c) {
    case '\\':
      out += "\\\\";
      break;
    case '"':
      out += "\\\"";
      break;
    case '\n':
      out += "\\n";
      break;
    case '\r':
      out += "\\r";
      break;
    case '\t':
      out += "\\t";
      break;
    default:
      if (static_cast<unsigned char>(c) < 0x20) {
        out += "?";
      } else {
        out += c;
      }
      break;
    }
  }
  return out;
}

} // namespace

uint64_t now_ns() {
#if defined(_WIN32)
  static LARGE_INTEGER freq = [] {
    LARGE_INTEGER value;
    QueryPerformanceFrequency(&value);
    return value;
  }();
  LARGE_INTEGER counter;
  QueryPerformanceCounter(&counter);
  return static_cast<uint64_t>((counter.QuadPart * 1000000000ULL) / freq.QuadPart);
#elif defined(__APPLE__)
  static mach_timebase_info_data_t timebase = [] {
    mach_timebase_info_data_t info{};
    mach_timebase_info(&info);
    return info;
  }();
  uint64_t t = mach_absolute_time();
  return (t * timebase.numer) / timebase.denom;
#else
  struct timespec ts;
#ifdef CLOCK_MONOTONIC_RAW
  clock_gettime(CLOCK_MONOTONIC_RAW, &ts);
#else
  clock_gettime(CLOCK_MONOTONIC, &ts);
#endif
  return static_cast<uint64_t>(ts.tv_sec) * 1000000000ULL + static_cast<uint64_t>(ts.tv_nsec);
#endif
}

const char* platform() {
#if defined(_WIN32)
  return "windows";
#elif defined(__APPLE__)
  return "macos";
#elif defined(__linux__)
  return "linux";
#else
  return "unknown";
#endif
}

const char* arch() {
#if defined(__x86_64__) || defined(_M_X64)
  return "x86_64";
#elif defined(__aarch64__) || defined(_M_ARM64)
  return "arm64";
#else
  return "unknown";
#endif
}

args parse_args(int argc, char** argv) {
  args parsed;
  for (int i = 1; i < argc; ++i) {
    const char* arg = argv[i];
    if (std::strncmp(arg, "--iterations=", 13) == 0) {
      parsed.iterations = std::strtoull(arg + 13, nullptr, 10);
    } else if (std::strncmp(arg, "--json-out=", 11) == 0) {
      parsed.json_out = arg + 11;
    } else if (std::strcmp(arg, "--verbose") == 0 || std::strcmp(arg, "-v") == 0) {
      parsed.verbose = true;
    }
  }
  return parsed;
}

FILE* open_output(const char* path) {
  if (!path || path[0] == '\0') {
    return stdout;
  }

  FILE* out = std::fopen(path, "a");
  if (!out) {
    return stdout;
  }
  return out;
}

void close_output(FILE* file) {
  if (file && file != stdout) {
    std::fclose(file);
  }
}

void emit_json(const result& entry, FILE* out) {
  if (!out) {
    out = stdout;
  }
  std::string notes = escape_json(entry.notes);
  std::fprintf(
      out,
      "{\"test_id\":\"%s\",\"platform\":\"%s\",\"arch\":\"%s\",\"iterations\":%llu,"
      "\"score\":%.6f,\"confidence\":%.6f,\"anomalies\":%llu,\"notes\":\"%s\"}\n",
      entry.test_id.c_str(), entry.platform.c_str(), entry.arch.c_str(),
      static_cast<unsigned long long>(entry.iterations), entry.score, entry.confidence,
      static_cast<unsigned long long>(entry.anomalies), notes.c_str()
  );
  std::fflush(out);
}

} // namespace instraware

```

`samples/programs/instraware/instraware_common.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <cstdio>
#include <string>

namespace instraware {

struct result {
  std::string test_id;
  std::string platform;
  std::string arch;
  uint64_t iterations = 0;
  double score = 0.0;
  double confidence = 0.0;
  uint64_t anomalies = 0;
  std::string notes;
};

struct args {
  uint64_t iterations = 1000;
  const char* json_out = nullptr;
  bool verbose = false;
};

uint64_t now_ns();
const char* platform();
const char* arch();
args parse_args(int argc, char** argv);
FILE* open_output(const char* path);
void close_output(FILE* file);
void emit_json(const result& entry, FILE* out);

} // namespace instraware

```

`samples/programs/instraware/instraware_qbdi_fault.cpp`:

```cpp
#if defined(__APPLE__)
#define _XOPEN_SOURCE 700
#endif

#include "instraware_common.hpp"

#include <cstdint>
#include <string>

#if defined(_WIN32)
#include <windows.h>
#else
#include <signal.h>
#include <ucontext.h>
#endif

#if defined(__APPLE__) && defined(__aarch64__)
#include <ptrauth.h>
#endif

namespace {

static volatile uintptr_t g_expected_pc = 0;
static volatile uintptr_t g_expected_next_pc = 0;
static volatile uintptr_t g_observed_pc = 0;
static volatile bool g_faulted = false;

uintptr_t strip_pac(uintptr_t value) {
#if defined(__APPLE__) && defined(__aarch64__) && defined(__has_feature)
#if __has_feature(ptrauth_calls)
  return reinterpret_cast<uintptr_t>(ptrauth_strip(reinterpret_cast<void*>(value), ptrauth_key_return_address));
#endif
#endif
  return value;
}

#if !defined(_WIN32)
#if (defined(__APPLE__) || defined(__linux__)) && (defined(__x86_64__) || defined(__aarch64__))
#define INSTRAWARE_HAVE_UCONTEXT_PC 1
#else
#define INSTRAWARE_HAVE_UCONTEXT_PC 0
#endif

#if INSTRAWARE_HAVE_UCONTEXT_PC
uintptr_t extract_pc(void* ctx_ptr) {
  auto* ctx = reinterpret_cast<ucontext_t*>(ctx_ptr);
#if defined(__APPLE__)
#if defined(__x86_64__)
  return static_cast<uintptr_t>(ctx->uc_mcontext->__ss.__rip);
#elif defined(__aarch64__)
  return static_cast<uintptr_t>(ctx->uc_mcontext->__ss.__pc);
#else
  return 0;
#endif
#elif defined(__linux__)
#if defined(__x86_64__)
  return static_cast<uintptr_t>(ctx->uc_mcontext.gregs[REG_RIP]);
#elif defined(__aarch64__)
  return static_cast<uintptr_t>(ctx->uc_mcontext.pc);
#else
  return 0;
#endif
#else
  return 0;
#endif
}

bool set_pc(void* ctx_ptr, uintptr_t pc) {
  auto* ctx = reinterpret_cast<ucontext_t*>(ctx_ptr);
#if defined(__APPLE__)
#if defined(__x86_64__)
  ctx->uc_mcontext->__ss.__rip = static_cast<uint64_t>(pc);
  return true;
#elif defined(__aarch64__)
  ctx->uc_mcontext->__ss.__pc = static_cast<uint64_t>(pc);
  return true;
#else
  (void) ctx;
  (void) pc;
  return false;
#endif
#elif defined(__linux__)
#if defined(__x86_64__)
  ctx->uc_mcontext.gregs[REG_RIP] = static_cast<greg_t>(pc);
  return true;
#elif defined(__aarch64__)
  ctx->uc_mcontext.pc = static_cast<unsigned long long>(pc);
  return true;
#else
  (void) ctx;
  (void) pc;
  return false;
#endif
#else
  (void) ctx;
  (void) pc;
  return false;
#endif
}
#else
uintptr_t extract_pc(void*) { return 0; }

bool set_pc(void*, uintptr_t) { return false; }
#endif

void fault_handler(int sig, siginfo_t*, void* ctx) {
  (void) sig;
  g_observed_pc = extract_pc(ctx);
  g_faulted = true;
  uintptr_t resume = static_cast<uintptr_t>(g_expected_next_pc);
  if (resume != 0) {
    set_pc(ctx, resume);
  }
}
#endif

void trigger_fault() {
#if defined(__GNUC__) || defined(__clang__)
  g_expected_pc = reinterpret_cast<uintptr_t>(&&fault_label);
  g_expected_next_pc = reinterpret_cast<uintptr_t>(&&after_fault);
fault_label:
#if defined(__x86_64__) || defined(_M_X64)
  asm volatile("int3");
#elif defined(__aarch64__) || defined(_M_ARM64)
  asm volatile("brk #0");
#else
  __builtin_trap();
#endif
after_fault:
  asm volatile("" ::: "memory");
#else
#if defined(_WIN32)
  __debugbreak();
#else
  __builtin_trap();
#endif
#endif
}

} // namespace

#if defined(_WIN32)
void run_fault_probe() {
  EXCEPTION_POINTERS* info = nullptr;
  __try {
    trigger_fault();
  } __except ((info = GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER) {
#if defined(_M_X64)
    if (info && info->ContextRecord) {
      g_observed_pc = static_cast<uintptr_t>(info->ContextRecord->Rip);
    }
#elif defined(_M_ARM64)
    if (info && info->ContextRecord) {
      g_observed_pc = static_cast<uintptr_t>(info->ContextRecord->Pc);
    }
#endif
    g_faulted = true;
  }
}
#endif

int main(int argc, char** argv) {
  instraware::args args = instraware::parse_args(argc, argv);
  instraware::result result;
  result.test_id = "fault";
  result.platform = instraware::platform();
  result.arch = instraware::arch();

  FILE* out = instraware::open_output(args.json_out);

#if defined(_WIN32)
  bool have_expected = false;
  run_fault_probe();

  result.iterations = 0;
  result.anomalies = 0;
  result.score = 0.0;
  result.confidence = 0.3;
  result.notes = have_expected ? "fault_checked" : "fault_subtest_skipped: no portable fault label on msvc";
  instraware::emit_json(result, out);
  instraware::close_output(out);
  return 0;
#else
#if !INSTRAWARE_HAVE_UCONTEXT_PC
  result.iterations = 0;
  result.anomalies = 0;
  result.score = 0.0;
  result.confidence = 0.3;
  result.notes = "fault_subtest_skipped: unsupported ucontext pc";
  instraware::emit_json(result, out);
  instraware::close_output(out);
  return 0;
#endif

#if !defined(__GNUC__) && !defined(__clang__)
  result.iterations = 0;
  result.anomalies = 0;
  result.score = 0.0;
  result.confidence = 0.3;
  result.notes = "fault_subtest_skipped: no label support";
  instraware::emit_json(result, out);
  instraware::close_output(out);
  return 0;
#endif

  struct sigaction sa{};
  sa.sa_sigaction = fault_handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = SA_SIGINFO;
  sigaction(SIGTRAP, &sa, nullptr);
  sigaction(SIGILL, &sa, nullptr);

  g_faulted = false;
  g_observed_pc = 0;
  g_expected_pc = 0;
  g_expected_next_pc = 0;
  trigger_fault();

  uintptr_t expected = strip_pac(static_cast<uintptr_t>(g_expected_pc));
  uintptr_t expected_next = strip_pac(static_cast<uintptr_t>(g_expected_next_pc));
  uintptr_t observed = strip_pac(static_cast<uintptr_t>(g_observed_pc));
  bool have_expected = expected != 0 && expected_next != 0;
  bool mismatch = have_expected && g_faulted && (observed != expected && observed != expected_next);
  bool missing_fault = have_expected && !g_faulted;

  result.iterations = have_expected ? 1 : 0;
  result.anomalies = (mismatch || missing_fault) ? 1 : 0;
  result.score = result.anomalies ? 1.0 : 0.0;
  result.confidence = have_expected ? 0.8 : 0.3;
  std::string notes = have_expected ? "fault_checked" : "fault_subtest_skipped: no label support";
  if (have_expected && missing_fault) {
    notes += ";fault_missing";
  } else if (have_expected && mismatch) {
    notes += ";fault_pc_mismatch";
  }
  result.notes = notes;

  instraware::emit_json(result, out);
  instraware::close_output(out);
  return 0;
#endif
}

```

`samples/programs/instraware/instraware_qbdi_rai.cpp`:

```cpp
#include "instraware_common.hpp"

#include <cstdint>
#include <cstring>
#include <string>

#if defined(_WIN32)
#include <windows.h>
#elif defined(__APPLE__)
#include <pthread.h>
#include <sys/mman.h>
#else
#include <sys/mman.h>
#include <unistd.h>
#endif

#if defined(__APPLE__) && defined(__aarch64__)
#include <ptrauth.h>
#endif

#if !defined(_WIN32)
#ifndef MAP_ANON
#define MAP_ANON MAP_ANONYMOUS
#endif
#endif

namespace {

struct exec_buffer {
  uint8_t* data = nullptr;
  size_t size = 0;
};

bool alloc_exec_buffer(exec_buffer* buffer, size_t size) {
  if (!buffer || size == 0) {
    return false;
  }
#if defined(_WIN32)
  buffer->data = static_cast<uint8_t*>(VirtualAlloc(nullptr, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));
  buffer->size = buffer->data ? size : 0;
  return buffer->data != nullptr;
#else
  int flags = MAP_PRIVATE | MAP_ANON;
  int prot = PROT_READ | PROT_WRITE;
#if defined(__APPLE__) && defined(__aarch64__)
  flags |= MAP_JIT;
  prot |= PROT_EXEC;
#endif
  void* ptr = mmap(nullptr, size, prot, flags, -1, 0);
  if (ptr == MAP_FAILED) {
    return false;
  }
  buffer->data = static_cast<uint8_t*>(ptr);
  buffer->size = size;
  return true;
#endif
}

bool make_buffer_writable(exec_buffer* buffer) {
  if (!buffer || !buffer->data) {
    return false;
  }
#if defined(_WIN32)
  DWORD old_protect = 0;
  return VirtualProtect(buffer->data, buffer->size, PAGE_READWRITE, &old_protect) != 0;
#elif defined(__APPLE__) && defined(__aarch64__)
  pthread_jit_write_protect_np(0);
  return true;
#else
  return mprotect(buffer->data, buffer->size, PROT_READ | PROT_WRITE) == 0;
#endif
}

bool make_buffer_executable(exec_buffer* buffer) {
  if (!buffer || !buffer->data) {
    return false;
  }
#if defined(_WIN32)
  DWORD old_protect = 0;
  return VirtualProtect(buffer->data, buffer->size, PAGE_EXECUTE_READ, &old_protect) != 0;
#elif defined(__APPLE__) && defined(__aarch64__)
  pthread_jit_write_protect_np(1);
  __builtin___clear_cache(reinterpret_cast<char*>(buffer->data), reinterpret_cast<char*>(buffer->data + buffer->size));
  return true;
#else
  bool ok = mprotect(buffer->data, buffer->size, PROT_READ | PROT_EXEC) == 0;
  __builtin___clear_cache(reinterpret_cast<char*>(buffer->data), reinterpret_cast<char*>(buffer->data + buffer->size));
  return ok;
#endif
}

void free_exec_buffer(exec_buffer* buffer) {
  if (!buffer || !buffer->data) {
    return;
  }
#if defined(_WIN32)
  VirtualFree(buffer->data, 0, MEM_RELEASE);
#else
  munmap(buffer->data, buffer->size);
#endif
  buffer->data = nullptr;
  buffer->size = 0;
}

uintptr_t strip_pac(uintptr_t value) {
#if defined(__APPLE__) && defined(__aarch64__) && defined(__has_feature)
#if __has_feature(ptrauth_calls)
  return reinterpret_cast<uintptr_t>(ptrauth_strip(reinterpret_cast<void*>(value), ptrauth_key_return_address));
#endif
#endif
  return value;
}

bool build_rai_stub(exec_buffer* buffer, std::string* notes) {
  if (!buffer || !buffer->data) {
    return false;
  }
  if (!make_buffer_writable(buffer)) {
    if (notes) {
      *notes = "jit_write_protect_failed";
    }
    return false;
  }

#if defined(__x86_64__) || defined(_M_X64)
#if defined(_WIN32)
  const uint8_t code[] = {0x48, 0x8B, 0x04, 0x24, 0x48, 0x89, 0x01, 0xC3};
#else
  const uint8_t code[] = {0x48, 0x8B, 0x04, 0x24, 0x48, 0x89, 0x07, 0xC3};
#endif
  if (buffer->size < sizeof(code)) {
    return false;
  }
  std::memcpy(buffer->data, code, sizeof(code));
#elif defined(__aarch64__) || defined(_M_ARM64)
  const uint8_t code[] = {0x1E, 0x00, 0x00, 0xF9, 0xC0, 0x03, 0x5F, 0xD6};
  if (buffer->size < sizeof(code)) {
    return false;
  }
  std::memcpy(buffer->data, code, sizeof(code));
#else
  if (notes) {
    *notes = "unsupported_arch";
  }
  return false;
#endif

  return make_buffer_executable(buffer);
}

} // namespace

int main(int argc, char** argv) {
  instraware::args args = instraware::parse_args(argc, argv);
  instraware::result result;
  result.test_id = "rai";
  result.platform = instraware::platform();
  result.arch = instraware::arch();

  FILE* out = instraware::open_output(args.json_out);

#if defined(_MSC_VER)
  result.iterations = 0;
  result.score = 0.0;
  result.confidence = 0.3;
  result.anomalies = 0;
  result.notes = "rai_subtest_skipped: no portable callsite marker on msvc";
  instraware::emit_json(result, out);
  instraware::close_output(out);
  return 0;
#endif

  exec_buffer buffer;
  std::string notes;
  if (!alloc_exec_buffer(&buffer, 64) || !build_rai_stub(&buffer, &notes)) {
    result.iterations = 0;
    result.score = 0.0;
    result.confidence = 0.3;
    result.anomalies = 0;
    result.notes = notes.empty() ? "jit_allocation_failed" : notes;
    instraware::emit_json(result, out);
    instraware::close_output(out);
    free_exec_buffer(&buffer);
    return 0;
  }

  using rai_fn_t = void (*)(uintptr_t*);
  auto fn = reinterpret_cast<rai_fn_t>(buffer.data);

  uint64_t iterations = args.iterations == 0 ? 1000 : args.iterations;
  uint64_t mismatches = 0;
  bool have_label = true;

  for (uint64_t i = 0; i < iterations; ++i) {
    uintptr_t observed = 0;
    uintptr_t expected = 0;
#if defined(__GNUC__) || defined(__clang__)
    expected = reinterpret_cast<uintptr_t>(&&after_call);
#else
    have_label = false;
#endif
    fn(&observed);
  after_call:
    observed = strip_pac(observed);
    expected = strip_pac(expected);
    if (have_label && observed != expected) {
      mismatches++;
    }
  }

  result.iterations = have_label ? iterations : 0;
  result.anomalies = mismatches;
  result.score = have_label && iterations ? static_cast<double>(mismatches) / static_cast<double>(iterations) : 0.0;
  result.confidence = have_label ? 0.8 : 0.3;
  result.notes = have_label ? "rai_checked" : "rai_subtest_skipped: no label support";

  instraware::emit_json(result, out);
  instraware::close_output(out);
  free_exec_buffer(&buffer);
  return 0;
}

```

`samples/programs/instraware/instraware_qbdi_smc.cpp`:

```cpp
#include "instraware_common.hpp"

#include <cstdint>
#include <cstring>
#include <string>

#if defined(_WIN32)
#include <windows.h>
#elif defined(__APPLE__)
#include <pthread.h>
#include <sys/mman.h>
#else
#include <sys/mman.h>
#include <unistd.h>
#endif

#if !defined(_WIN32)
#ifndef MAP_ANON
#define MAP_ANON MAP_ANONYMOUS
#endif
#endif

namespace {

struct exec_buffer {
  uint8_t* data = nullptr;
  size_t size = 0;
};

bool alloc_exec_buffer(exec_buffer* buffer, size_t size) {
  if (!buffer || size == 0) {
    return false;
  }
#if defined(_WIN32)
  buffer->data = static_cast<uint8_t*>(VirtualAlloc(nullptr, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));
  buffer->size = buffer->data ? size : 0;
  return buffer->data != nullptr;
#else
  int flags = MAP_PRIVATE | MAP_ANON;
  int prot = PROT_READ | PROT_WRITE;
#if defined(__APPLE__) && defined(__aarch64__)
  flags |= MAP_JIT;
  prot |= PROT_EXEC;
#endif
  void* ptr = mmap(nullptr, size, prot, flags, -1, 0);
  if (ptr == MAP_FAILED) {
    return false;
  }
  buffer->data = static_cast<uint8_t*>(ptr);
  buffer->size = size;
  return true;
#endif
}

bool make_buffer_writable(exec_buffer* buffer) {
  if (!buffer || !buffer->data) {
    return false;
  }
#if defined(_WIN32)
  DWORD old_protect = 0;
  return VirtualProtect(buffer->data, buffer->size, PAGE_READWRITE, &old_protect) != 0;
#elif defined(__APPLE__) && defined(__aarch64__)
  pthread_jit_write_protect_np(0);
  return true;
#else
  return mprotect(buffer->data, buffer->size, PROT_READ | PROT_WRITE) == 0;
#endif
}

bool make_buffer_executable(exec_buffer* buffer) {
  if (!buffer || !buffer->data) {
    return false;
  }
#if defined(_WIN32)
  DWORD old_protect = 0;
  bool ok = VirtualProtect(buffer->data, buffer->size, PAGE_EXECUTE_READ, &old_protect) != 0;
  FlushInstructionCache(GetCurrentProcess(), buffer->data, buffer->size);
  return ok;
#elif defined(__APPLE__) && defined(__aarch64__)
  pthread_jit_write_protect_np(1);
  __builtin___clear_cache(reinterpret_cast<char*>(buffer->data), reinterpret_cast<char*>(buffer->data + buffer->size));
  return true;
#else
  bool ok = mprotect(buffer->data, buffer->size, PROT_READ | PROT_EXEC) == 0;
  __builtin___clear_cache(reinterpret_cast<char*>(buffer->data), reinterpret_cast<char*>(buffer->data + buffer->size));
  return ok;
#endif
}

void free_exec_buffer(exec_buffer* buffer) {
  if (!buffer || !buffer->data) {
    return;
  }
#if defined(_WIN32)
  VirtualFree(buffer->data, 0, MEM_RELEASE);
#else
  munmap(buffer->data, buffer->size);
#endif
  buffer->data = nullptr;
  buffer->size = 0;
}

bool write_return_constant(exec_buffer* buffer, uint32_t value) {
  if (!buffer || !buffer->data) {
    return false;
  }
#if defined(__x86_64__) || defined(_M_X64)
  if (buffer->size < 6) {
    return false;
  }
  buffer->data[0] = 0xB8;
  std::memcpy(buffer->data + 1, &value, sizeof(uint32_t));
  buffer->data[5] = 0xC3;
  return true;
#elif defined(__aarch64__) || defined(_M_ARM64)
  if (buffer->size < 8) {
    return false;
  }
  uint32_t mov = 0x52800000 | ((value & 0xFFFFU) << 5);
  buffer->data[0] = static_cast<uint8_t>(mov & 0xFF);
  buffer->data[1] = static_cast<uint8_t>((mov >> 8) & 0xFF);
  buffer->data[2] = static_cast<uint8_t>((mov >> 16) & 0xFF);
  buffer->data[3] = static_cast<uint8_t>((mov >> 24) & 0xFF);
  buffer->data[4] = 0xC0;
  buffer->data[5] = 0x03;
  buffer->data[6] = 0x5F;
  buffer->data[7] = 0xD6;
  return true;
#else
  return false;
#endif
}

} // namespace

int main(int argc, char** argv) {
  instraware::args args = instraware::parse_args(argc, argv);
  instraware::result result;
  result.test_id = "smc";
  result.platform = instraware::platform();
  result.arch = instraware::arch();

  FILE* out = instraware::open_output(args.json_out);

  exec_buffer buffer;
  if (!alloc_exec_buffer(&buffer, 64)) {
    result.iterations = 0;
    result.score = 0.0;
    result.confidence = 0.3;
    result.anomalies = 0;
    result.notes = "jit_allocation_failed";
    instraware::emit_json(result, out);
    instraware::close_output(out);
    return 0;
  }

  using smc_fn_t = uint32_t (*)();
  auto fn = reinterpret_cast<smc_fn_t>(buffer.data);

  uint64_t iterations = args.iterations == 0 ? 100 : args.iterations;
  uint64_t anomalies = 0;

  for (uint64_t i = 0; i < iterations; ++i) {
    if (!make_buffer_writable(&buffer) || !write_return_constant(&buffer, 1) || !make_buffer_executable(&buffer)) {
      anomalies++;
      continue;
    }
    uint32_t v1 = fn();

    if (!make_buffer_writable(&buffer) || !write_return_constant(&buffer, 2) || !make_buffer_executable(&buffer)) {
      anomalies++;
      continue;
    }
    uint32_t v2 = fn();

    if (v1 != 1 || v2 != 2) {
      anomalies++;
    }
  }

  result.iterations = iterations;
  result.anomalies = anomalies;
  result.score = iterations ? static_cast<double>(anomalies) / static_cast<double>(iterations) : 0.0;
  result.confidence = 0.7;
  result.notes = "smc_checked";

  instraware::emit_json(result, out);
  instraware::close_output(out);
  free_exec_buffer(&buffer);
  return 0;
}

```

`samples/programs/instraware/instraware_qbdi_stack.cpp`:

```cpp
#include "instraware_common.hpp"

#include <cstdint>
#include <cstring>
#include <string>

#if defined(_WIN32)
#include <intrin.h>
#include <windows.h>
#endif

namespace {

#if defined(_MSC_VER)
#define INSTRAWARE_NOINLINE __declspec(noinline)
#else
#define INSTRAWARE_NOINLINE __attribute__((noinline))
#endif

uintptr_t read_sp() {
#if defined(__x86_64__) || defined(_M_X64)
#if defined(_MSC_VER)
  return reinterpret_cast<uintptr_t>(_AddressOfReturnAddress());
#else
  uintptr_t sp = 0;
  asm volatile("mov %%rsp, %0" : "=r"(sp));
  return sp;
#endif
#elif defined(__aarch64__) || defined(_M_ARM64)
#if defined(_MSC_VER)
  return reinterpret_cast<uintptr_t>(_AddressOfReturnAddress());
#else
  uintptr_t sp = 0;
  asm volatile("mov %0, sp" : "=r"(sp));
  return sp;
#endif
#else
  return 0;
#endif
}

uintptr_t read_fp() {
#if defined(__x86_64__) || defined(_M_X64)
#if defined(_MSC_VER)
  return 0;
#else
  uintptr_t fp = 0;
  asm volatile("mov %%rbp, %0" : "=r"(fp));
  return fp;
#endif
#elif defined(__aarch64__) || defined(_M_ARM64)
#if defined(_MSC_VER)
  return 0;
#else
  uintptr_t fp = 0;
  asm volatile("mov %0, x29" : "=r"(fp));
  return fp;
#endif
#else
  return 0;
#endif
}

bool sp_alignment_ok(uintptr_t sp) {
  if (sp == 0) {
    return true;
  }
  uint64_t mod = sp % 16;
  return mod == 0 || mod == 8;
}

INSTRAWARE_NOINLINE bool check_frame_chain_inner(size_t depth, size_t max_depth, void* expected_prev, bool* checked) {
#if defined(__GNUC__) || defined(__clang__)
  uintptr_t fp_value = read_fp();
  if (fp_value == 0) {
    if (checked) {
      *checked = false;
    }
    return true;
  }
  void* fp = reinterpret_cast<void*>(fp_value);
  if (expected_prev) {
    void** slot = reinterpret_cast<void**>(fp);
    if (!slot || slot[0] == nullptr) {
      if (checked) {
        *checked = false;
      }
      return true;
    }
    if (slot[0] != expected_prev) {
      return false;
    }
  }
  // Prevent tail recursion elimination so each depth has its own frame.
  volatile uintptr_t sink = fp_value;
  if (depth < max_depth) {
    bool ok = check_frame_chain_inner(depth + 1, max_depth, fp, checked);
    sink ^= fp_value;
    if (!ok) {
      return false;
    }
  }
  if (sink == 0xdeadbeefULL) {
    return false;
  }
  if (checked) {
    *checked = true;
  }
  return true;
#else
  (void) depth;
  (void) max_depth;
  (void) expected_prev;
  if (checked) {
    *checked = false;
  }
  return true;
#endif
}

bool check_frame_chain(size_t depth, std::string* notes, bool* checked) {
  if (checked) {
    *checked = false;
  }
#if defined(__GNUC__) || defined(__clang__)
  constexpr size_t kMaxDepth = 8;
  if (depth == 0 || depth > kMaxDepth) {
    depth = depth == 0 ? 1 : kMaxDepth;
  }
  bool ok = check_frame_chain_inner(0, depth, nullptr, checked);
  if (!ok) {
    return false;
  }
  if (!checked || !*checked) {
    if (notes) {
      if (notes->find("frame_chain_skipped") == std::string::npos) {
        *notes += "frame_chain_skipped;";
      }
    }
    return true;
  }
  if (notes) {
    if (notes->find("frame_chain_internal") == std::string::npos) {
      *notes += "frame_chain_internal;";
    }
  }
  return true;
#else
  if (notes) {
    if (notes->find("frame_chain_skipped") == std::string::npos) {
      *notes += "frame_chain_skipped;";
    }
  }
  return true;
#endif
}

INSTRAWARE_NOINLINE void fill_sentinel(volatile uint64_t* data, size_t count, uint64_t seed) {
  for (size_t i = 0; i < count; ++i) {
    data[i] = seed ^ (0x9e3779b97f4a7c15ULL + static_cast<uint64_t>(i) * 0x10001ULL);
  }
}

INSTRAWARE_NOINLINE bool verify_sentinel(volatile uint64_t* data, size_t count, uint64_t seed) {
  for (size_t i = 0; i < count; ++i) {
    uint64_t expected = seed ^ (0x9e3779b97f4a7c15ULL + static_cast<uint64_t>(i) * 0x10001ULL);
    if (data[i] != expected) {
      return false;
    }
  }
  return true;
}

INSTRAWARE_NOINLINE void probe_frame(
    int depth, int max_depth, uint64_t* sentinel_failures, uint64_t* alignment_failures
) {
  volatile uint64_t sentinel[8];
  uint64_t seed = 0x13579bdf2468ace0ULL ^ static_cast<uint64_t>(depth);
  fill_sentinel(sentinel, 8, seed);

  uintptr_t sp = read_sp();
  if (!sp_alignment_ok(sp)) {
    (*alignment_failures)++;
  }

  if (depth < max_depth) {
    probe_frame(depth + 1, max_depth, sentinel_failures, alignment_failures);
  }

  if (!verify_sentinel(sentinel, 8, seed)) {
    (*sentinel_failures)++;
  }
}

} // namespace

int main(int argc, char** argv) {
  instraware::args args = instraware::parse_args(argc, argv);
  instraware::result result;
  result.test_id = "stack";
  result.platform = instraware::platform();
  result.arch = instraware::arch();

  FILE* out = instraware::open_output(args.json_out);

  uint64_t iterations = args.iterations == 0 ? 1000 : args.iterations;
  uint64_t sentinel_failures = 0;
  uint64_t alignment_failures = 0;
  uint64_t chain_failures = 0;
  uint64_t chain_checks = 0;
  std::string notes;

  for (uint64_t i = 0; i < iterations; ++i) {
    probe_frame(0, 4, &sentinel_failures, &alignment_failures);
    bool checked = false;
    if (!check_frame_chain(4, &notes, &checked)) {
      chain_failures++;
    }
    if (checked) {
      chain_checks++;
    }
  }

  result.iterations = iterations;
  result.anomalies = sentinel_failures + alignment_failures + chain_failures;
  double ratio = iterations ? static_cast<double>(result.anomalies) / static_cast<double>(iterations) : 0.0;
  result.score = ratio > 1.0 ? 1.0 : ratio;
  result.confidence = notes.find("frame_chain_skipped") != std::string::npos ? 0.6 : 0.8;

  notes += "sentinel_failures=" + std::to_string(sentinel_failures) + ";";
  notes += "alignment_failures=" + std::to_string(alignment_failures) + ";";
  notes += "chain_failures=" + std::to_string(chain_failures) + ";";
  notes += "chain_checks=" + std::to_string(chain_checks) + ";";
  result.notes = notes;

  instraware::emit_json(result, out);
  instraware::close_output(out);
  return 0;
}

```

`samples/programs/linux_daemon.c`:

```c
/*
 * Linux daemon-like target for testing injection into backgrounded processes
 * Tests injection into processes that have detached from terminal
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <time.h>
#include <syslog.h>

volatile int running = 1;
const char* pidfile_path = "/tmp/linux_daemon.pid";

void signal_handler(int sig) {
  syslog(LOG_INFO, "linux_daemon: received signal %d", sig);
  running = 0;
}

void cleanup() {
  unlink(pidfile_path);
  closelog();
}

int create_pidfile() {
  FILE* f = fopen(pidfile_path, "w");
  if (!f) {
    return -1;
  }
  fprintf(f, "%d\n", getpid());
  fclose(f);
  return 0;
}

void daemonize() {
  pid_t pid = fork();

  if (pid < 0) {
    exit(EXIT_FAILURE);
  }

  if (pid > 0) {
    // Parent process exits
    exit(EXIT_SUCCESS);
  }

  // Child continues as daemon
  if (setsid() < 0) {
    exit(EXIT_FAILURE);
  }

  // Change working directory to root
  if (chdir("/") < 0) {
    exit(EXIT_FAILURE);
  }

  // Close file descriptors
  close(STDIN_FILENO);
  close(STDOUT_FILENO);
  close(STDERR_FILENO);

  // Redirect standard file descriptors to /dev/null
  open("/dev/null", O_RDONLY); // stdin
  open("/dev/null", O_WRONLY); // stdout
  open("/dev/null", O_WRONLY); // stderr
}

void daemon_work() {
  // Simulate daemon work
  int work_counter = 0;

  while (running) {
    syslog(LOG_INFO, "linux_daemon: work iteration %d", work_counter++);

    // Simulate some work
    void* ptr = malloc(1024);
    if (ptr) {
      memset(ptr, work_counter & 0xFF, 1024);
      free(ptr);
    }

    // Check if we should exit
    if (work_counter >= 15) { // Run for limited time in testing
      syslog(LOG_INFO, "linux_daemon: work limit reached, exiting");
      break;
    }

    sleep(2);
  }
}

int main(int argc, char* argv[]) {
  int foreground = 0;

  // Simple argument parsing
  if (argc > 1 && strcmp(argv[1], "--foreground") == 0) {
    foreground = 1;
  }

  // Open syslog
  openlog("linux_daemon", LOG_PID | LOG_CONS, LOG_DAEMON);

  if (!foreground) {
    printf("linux_daemon: daemonizing (PID: %d)\n", getpid());
    daemonize();
  } else {
    printf("linux_daemon: running in foreground (PID: %d)\n", getpid());
  }

  syslog(LOG_INFO, "linux_daemon: started (PID: %d)", getpid());

  // Set up signal handlers
  signal(SIGTERM, signal_handler);
  signal(SIGINT, signal_handler);
  signal(SIGHUP, signal_handler);

  // Create PID file
  if (create_pidfile() < 0) {
    syslog(LOG_ERR, "linux_daemon: failed to create PID file");
  }

  // Set up cleanup
  atexit(cleanup);

  // Log injection indicators
  if (getenv("LD_PRELOAD")) {
    syslog(LOG_INFO, "linux_daemon: LD_PRELOAD detected: %s", getenv("LD_PRELOAD"));
  }

  // Do daemon work
  daemon_work();

  syslog(LOG_INFO, "linux_daemon: exiting");
  return 0;
}
```

`samples/programs/linux_target.c`:

```c
/*
 * Linux-specific target program for injection testing
 * Tests Linux-specific functionality like signals, ptrace detection, etc.
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/ptrace.h>
#include <errno.h>
#include <string.h>
#include <time.h>
#include <sys/socket.h>
#include <netinet/in.h>

volatile int running = 1;
volatile int injection_detected = 0;

void signal_handler(int sig) {
  printf("linux_target: received signal %d (%s)\n", sig, strsignal(sig));
  if (sig == SIGTERM || sig == SIGINT) {
    running = 0;
  }
}

void check_ptrace_status() {
  // Check if we're being traced
  if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) == -1) {
    if (errno == EPERM) {
      printf("linux_target: ptrace detected - we're being traced\n");
      injection_detected = 1;
    }
  } else {
    // Detach immediately if successful
    ptrace(PTRACE_DETACH, 0, NULL, NULL);
  }
}

void perform_linux_operations() {
  // Test various Linux-specific operations that might be hooked

  // File operations
  FILE* f = fopen("/proc/self/status", "r");
  if (f) {
    char line[256];
    while (fgets(line, sizeof(line), f)) {
      if (strncmp(line, "TracerPid:", 10) == 0) {
        int tracer_pid = atoi(line + 10);
        if (tracer_pid != 0) {
          printf("linux_target: TracerPid detected: %d\n", tracer_pid);
          injection_detected = 1;
        }
        break;
      }
    }
    fclose(f);
  }

  // Memory operations
  void* ptr = malloc(1024);
  if (ptr) {
    memset(ptr, 0xAA, 1024);
    free(ptr);
  }

  // System calls
  getpid();
  getppid();
  geteuid();
  getegid();
}

void test_library_hooks() {
  // Test common functions that injection libraries might hook
  printf("linux_target: testing library function hooks\n");

  // Test malloc/free
  void* test_ptr = malloc(64);
  if (test_ptr) {
    free(test_ptr);
  }

  // Test file operations
  FILE* f = fopen("/dev/null", "w");
  if (f) {
    fwrite("test", 1, 4, f);
    fclose(f);
  }

  // Test network-like operations (even if they fail)
  socket(AF_INET, SOCK_STREAM, 0);
}

int main(int argc, char* argv[]) {
  printf("linux_target: Linux injection test target starting (PID: %d)\n", getpid());
  printf("linux_target: PPID: %d, UID: %d, GID: %d\n", getppid(), getuid(), getgid());

  // Set up signal handlers
  signal(SIGTERM, signal_handler);
  signal(SIGINT, signal_handler);
  signal(SIGCHLD, signal_handler);
  signal(SIGUSR1, signal_handler);
  signal(SIGUSR2, signal_handler);

  // Set process name
  if (prctl(PR_SET_NAME, "linux_target", 0, 0, 0) == 0) {
    printf("linux_target: process name set\n");
  }

  // Check environment variables that might indicate injection
  if (getenv("LD_PRELOAD")) {
    printf("linux_target: LD_PRELOAD detected: %s\n", getenv("LD_PRELOAD"));
    injection_detected = 1;
  }

  int iteration = 0;
  time_t start_time = time(NULL);

  while (running && (time(NULL) - start_time) < 30) { // Run for max 30 seconds
    printf("linux_target: iteration %d\n", iteration++);

    // Perform various operations
    perform_linux_operations();
    check_ptrace_status();
    test_library_hooks();

    // Print injection status
    if (injection_detected) {
      printf("linux_target: injection/debugging detected\n");
    }

    sleep(2);

    // Exit after reasonable time for testing
    if (iteration >= 10) {
      printf("linux_target: iteration limit reached\n");
      break;
    }
  }

  printf("linux_target: exiting after %d iterations\n", iteration);
  return injection_detected ? 42 : 0; // Special exit code if injection detected
}
```

`samples/programs/multi_threaded_target.c`:

```c
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <windows.h>
#include <process.h>
#define getpid _getpid
#define usleep(x) Sleep((x) / 1000)
typedef HANDLE pthread_t;
volatile BOOL running = TRUE;
BOOL WINAPI console_handler(DWORD signal) {
  if (signal == CTRL_C_EVENT || signal == CTRL_BREAK_EVENT) {
    printf("multi_threaded_target: received signal, shutting down...\n");
    running = FALSE;
    return TRUE;
  }
  return FALSE;
}
#else
#include <unistd.h>
#include <pthread.h>
volatile int running = 1;
void signal_handler(int sig) {
  printf("multi_threaded_target: received signal %d, shutting down...\n", sig);
  running = 0;
}
#endif

typedef struct {
  int thread_id;
  const char* task_type;
  int iterations;
} thread_data_t;

#ifdef _WIN32
DWORD WINAPI worker_thread(LPVOID arg) {
#else
void* worker_thread(void* arg) {
#endif
  thread_data_t* data = (thread_data_t*) arg;
  int completed = 0;

  printf("worker_thread %d (%s): started\n", data->thread_id, data->task_type);

  while (running && completed < data->iterations) {
    if (strcmp(data->task_type, "compute") == 0) {
      // computational work
      volatile long sum = 0;
      for (int i = 0; i < 500000; i++) {
        sum += i * data->thread_id;
      }
    } else if (strcmp(data->task_type, "memory") == 0) {
      // memory allocation/deallocation work
      char* buffer = malloc(1024 * data->thread_id);
      if (buffer) {
        memset(buffer, data->thread_id % 256, 1024 * data->thread_id);
        free(buffer);
      }
    } else if (strcmp(data->task_type, "io") == 0) {
      // simulate I/O work with longer sleeps
      usleep(100000); // 100ms
    }

    completed++;
    printf(
        "worker_thread %d (%s): completed iteration %d/%d\n", data->thread_id, data->task_type, completed,
        data->iterations
    );

    usleep(200000); // 200ms between iterations
  }

  printf("worker_thread %d (%s): finished after %d iterations\n", data->thread_id, data->task_type, completed);

#ifdef _WIN32
  return 0;
#else
  return NULL;
#endif
}

int main() {
#ifdef _WIN32
  SetConsoleCtrlHandler(console_handler, TRUE);
#else
  signal(SIGTERM, signal_handler);
  signal(SIGINT, signal_handler);
#endif

  printf("multi_threaded_target: started (PID: %d)\n", getpid());
  printf("multi_threaded_target: main thread spawning workers...\n");

  // Define different types of work
  const char* task_types[] = {"compute", "memory", "io", "compute"};
  const int task_iterations[] = {6, 4, 8, 5};

#define NUM_THREADS 4
#ifdef _WIN32
  HANDLE threads[NUM_THREADS];
#else
  pthread_t threads[NUM_THREADS];
#endif
  thread_data_t thread_data[NUM_THREADS];

  // Main thread creates and manages worker threads
  for (int i = 0; i < NUM_THREADS; i++) {
    thread_data[i].thread_id = i + 1;
    thread_data[i].task_type = task_types[i];
    thread_data[i].iterations = task_iterations[i];

    printf(
        "main_thread: creating worker %d with task '%s' (%d iterations)\n", thread_data[i].thread_id,
        thread_data[i].task_type, thread_data[i].iterations
    );

#ifdef _WIN32
    threads[i] = CreateThread(NULL, 0, worker_thread, &thread_data[i], 0, NULL);
    if (threads[i] == NULL) {
#else
    if (pthread_create(&threads[i], NULL, worker_thread, &thread_data[i]) != 0) {
#endif
      printf("multi_threaded_target: failed to create thread %d\n", i + 1);
      exit(1);
    }

    // Main thread does some work between spawning threads
    printf("main_thread: performing coordination work...\n");
    volatile int main_work = 0;
    for (int j = 0; j < 100000; j++) {
      main_work += j;
    }
    usleep(50000); // 50ms delay between thread creation
  }

  printf("multi_threaded_target: main thread monitoring %d workers...\n", NUM_THREADS);

  // Main thread continues to do work while monitoring
  int monitor_cycles = 0;
  while (running && monitor_cycles < 20) {
    printf("main_thread: monitoring cycle %d\n", monitor_cycles + 1);

    // Do some monitoring work
    volatile int monitor_work = 0;
    for (int i = 0; i < 200000; i++) {
      monitor_work += i * monitor_cycles;
    }

    monitor_cycles++;
    usleep(300000); // 300ms between monitoring cycles
  }

  printf("main_thread: waiting for all workers to complete...\n");

  // Wait for all threads to complete
  for (int i = 0; i < NUM_THREADS; i++) {
#ifdef _WIN32
    WaitForSingleObject(threads[i], INFINITE);
    CloseHandle(threads[i]);
#else
    pthread_join(threads[i], NULL);
#endif
    printf("main_thread: worker %d joined\n", i + 1);
  }

  printf("multi_threaded_target: all workers completed, main thread exiting\n");
  return 0;
}
```

`samples/programs/p1ll_test_target.c`:

```c
#include <stdint.h>
#include <stdio.h>

// simple test target for p1ll binary patching validation
// contains predictable patterns that can be found and patched

void platform_info() {
// function with platform-specific information

// arch
#if defined(__x86_64__)
  printf("Platform: x86_64\n");
#elif defined(__aarch64__)
  printf("Platform: aarch64\n");
#elif defined(__i386__)
  printf("Platform: i386\n");
#endif

// os
#if defined(__linux__)
  printf("OS: Linux\n");
#elif defined(__APPLE__)
  printf("OS: macOS\n");
#elif defined(_WIN32)
  printf("OS: Windows\n");
#endif
}

void license_check() {
  // function with conditional jump that can be patched
  uint64_t license_status = 0; // 0 = trial, 1 = licensed

  if (license_status == 0) {
    printf("TRIAL VERSION - Please purchase a license\n");
  } else {
    printf("Licensed version - Thank you!\n");
  }
}

void demo_message() {
  // function with string that can be patched
  printf("DEMO VERSION - Limited functionality\n");
}

void validation_routine() {
  // another function with patchable logic
  int validation_result = 0; // 0 = fail, 1 = pass

  if (validation_result != 1) {
    printf("Validation failed - Access denied\n");
  } else {
    printf("Validation passed - Full access granted\n");
  }
}

int main() {
  printf("p1ll test target v1.0\n");
  printf("=====================\n\n");

  platform_info();
  license_check();
  demo_message();
  validation_routine();

  printf("\ntest target completed.\n");
  return 0;
}

```

`samples/programs/rewind_demo_algorithms.c`:

```c
// algorithmic demo resembling a mini crackme. safe and non-malicious.

#include <stdint.h>
#include <stdio.h>
#include <string.h>

static uint32_t rotate_left(uint32_t value, unsigned int count) {
  return (value << (count % 32u)) | (value >> (32u - (count % 32u)));
}

static uint32_t mix_block(const char* block, size_t len, uint32_t seed) {
  uint32_t acc = seed;
  for (size_t i = 0; i < len; ++i) {
    acc ^= (uint8_t) block[i];
    acc = rotate_left(acc, (unsigned int) ((block[i] % 13) + 5));
    acc = acc * 0x45d9f3bu + 0x1337u;
  }
  return acc;
}

static uint32_t derive_key(const char* input) {
  uint32_t key = 0xDEADBEEFu;
  size_t len = strlen(input);
  for (size_t i = 0; i < len; i += 4) {
    key = mix_block(&input[i], (len - i) < 4 ? (len - i) : 4, key ^ (uint32_t) i);
  }
  return key;
}

static uint32_t evaluate_candidate(const char* candidate) {
  uint32_t key = derive_key(candidate);
  uint32_t score = 0;
  for (size_t i = 0; candidate[i] != '\0'; ++i) {
    score += (uint32_t) (candidate[i] * (int) (i + 7));
    score = rotate_left(score ^ key, (unsigned int) (i % 5 + 1));
  }
  return score ^ (uint32_t) strlen(candidate);
}

int main(void) {
  const char* const secrets[] = {
      "rew1nd-42",
      "rew1nd-43",
      "rew1nd-44",
  };

  uint32_t final_score = 0;
  for (size_t i = 0; i < sizeof(secrets) / sizeof(secrets[0]); ++i) {
    final_score ^= evaluate_candidate(secrets[i]) << (i * 3);
  }

  const char* attempt = "rew1nd-42";
  uint32_t attempt_score = evaluate_candidate(attempt);
  const int accepted = (attempt_score & 0xFFu) == (final_score & 0xFFu);

  printf("alg score=%u accepted=%d secret_xor=%u\n", attempt_score, accepted, final_score);
  return accepted ? 0 : 1;
}

```

`samples/programs/rewind_demo_basic.c`:

```c
// demo program for validating the rewind tracer. this code is safe and not malicious.

#include <stdint.h>
#include <stdio.h>
#include <string.h>

struct simple_record {
  uint32_t checksum;
  uint32_t count;
  uint8_t history[16];
};

static void update_record(struct simple_record* record, uint8_t value) {
  const size_t slot = record->count % sizeof(record->history);
  record->history[slot] = (uint8_t) (value ^ record->checksum);
  record->count += 1;
  record->checksum = (record->checksum << 1) ^ (uint32_t) (value * 0x45u + 0x33u);
  record->checksum ^= (uint32_t) (record->history[(slot + 7u) % sizeof(record->history)] * 17u);
}

#if defined(__clang__)
__attribute__((optnone))
#endif
static uint32_t sum_bytes(const uint8_t* data, size_t size) {
  uint32_t total = 0;
  for (size_t i = 0; i < size; ++i) {
    total += data[i];
  }
  return total;
}

int main(void) {
  struct simple_record record = {0};
  uint8_t buffer[32];
  uint8_t shadow[32];
  memset(buffer, 0, sizeof(buffer));
  memset(shadow, 0, sizeof(shadow));

#if defined(__clang__)
#pragma clang loop vectorize(disable)
#pragma clang loop interleave(disable)
#endif
  for (uint8_t i = 0; i < 20; ++i) {
    update_record(&record, (uint8_t) (i * 7u));
    buffer[i % sizeof(buffer)] = (uint8_t) (record.checksum & 0xFFu);
    shadow[(i * 5u) % sizeof(shadow)] = (uint8_t) (record.checksum >> 8);
  }

  // exercise common memory primitives with overlapping regions
  memmove(buffer + 4, buffer, 12);
  memcpy(shadow + 8, buffer + 8, 16);
  memset(buffer + 20, (int) record.history[3], 6);

  const uint32_t total = sum_bytes(buffer, sizeof(buffer));
  const uint32_t shadow_total = sum_bytes(shadow, sizeof(shadow));

  printf("record checksum=%u, count=%u, total=%u, shadow=%u\n", record.checksum, record.count, total, shadow_total);
  return (int) ((record.checksum ^ total ^ shadow_total) & 0xFF);
}

```

`samples/programs/rewind_demo_calls.c`:

```c
// demo program for exercising nested calls under the rewind tracer. safe and non-malicious.

#include <stdint.h>
#include <stddef.h>
#include <stdio.h>

struct frame_state {
  int32_t values[8];
};

static void seed_frame(struct frame_state* state, int32_t base) {
  for (size_t i = 0; i < sizeof(state->values) / sizeof(state->values[0]); ++i) {
    state->values[i] = base + (int32_t) (i * 3);
  }
}

static int32_t scramble_frame(struct frame_state* state, int depth) {
  int32_t total = 0;
  for (size_t i = 0; i < sizeof(state->values) / sizeof(state->values[0]); ++i) {
    int32_t v = state->values[i] ^ (int32_t) (depth * 11 + (int) i);
    state->values[i] = (v << 1) | (v >> 7);
    total += state->values[i];
  }
  return total;
}

static int32_t walk_frames(struct frame_state* state, int depth, int toggle) {
  if (depth == 0) {
    return scramble_frame(state, toggle);
  }

  int32_t subtotal = walk_frames(state, depth - 1, toggle ^ depth);
  subtotal += scramble_frame(state, depth);

  switch ((toggle + depth) % 3) {
  case 0:
    subtotal ^= state->values[depth % 8];
    break;
  case 1:
    subtotal += (state->values[(depth + 5) % 8] << 2);
    break;
  default:
    subtotal -= (state->values[(depth + 2) % 8] >> 1);
    break;
  }

  if ((toggle & depth) == 0 && depth > 1) {
    subtotal += walk_frames(state, depth - 2, toggle + depth);
  }

  return subtotal;
}

static void mix_history(int32_t history[6], int32_t value) {
  for (int i = 5; i > 0; --i) {
    history[i] = history[i - 1];
  }
  history[0] = value;
}

int main(void) {
  struct frame_state root;
  int32_t history[6] = {0};

  seed_frame(&root, 42);

  for (int round = 0; round < 5; ++round) {
    int32_t result = walk_frames(&root, 3, round);
    mix_history(history, result);
    root.values[round % 8] ^= result;
    root.values[(round + 3) % 8] ^= (result << 1);
  }

  int32_t final = 0;
  for (size_t i = 0; i < sizeof(history) / sizeof(history[0]); ++i) {
    final ^= history[i];
  }

  printf("final=%d history0=%d history1=%d\n", final, history[0], history[1]);
  return final & 0xFF;
}

```

`samples/programs/rewind_demo_io.c`:

```c
// demo program exercising stdio-style I/O for the rewind tracer. safe and non-malicious.

#include <stdint.h>
#include <stdio.h>
#include <string.h>

static void synthesize_line(char* buffer, size_t size, uint32_t seed) {
  for (size_t i = 0; i < size - 1; ++i) {
    buffer[i] = (char) ('A' + (int) ((seed + i * 7u) % 26u));
  }
  buffer[size - 1] = '\0';
}

int main(void) {
  char line1[32];
  char line2[32];
  synthesize_line(line1, sizeof(line1), 1234u);
  synthesize_line(line2, sizeof(line2), 9876u);

  FILE* temp = tmpfile();
  if (temp == NULL) {
    return 1;
  }
  setvbuf(temp, NULL, _IOLBF, 0);

  fputs(line1, temp);
  fputc('\n', temp);
  fwrite(line2, 1, strlen(line2), temp);
  fflush(temp);

  fseek(temp, 0, SEEK_SET);
  char readback[64];
  size_t read_total = fread(readback, 1, sizeof(readback) - 1, temp);
  readback[read_total] = '\0';
  fclose(temp);

  uint32_t checksum = 0;
  for (size_t i = 0; i < read_total; ++i) {
    checksum = (checksum * 131u) ^ (uint8_t) readback[i];
  }

  printf("io digest=%u len=%zu\n", checksum, read_total);
  return (int) (checksum & 0xFF);
}

```

`samples/programs/rewind_demo_memops.c`:

```c
// demo program covering memcpy/memmove/memset patterns. safe and non-malicious.

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static uint32_t accumulate(const uint8_t* data, size_t size) {
  uint32_t acc = 0;
  for (size_t i = 0; i < size; ++i) {
    acc = (acc << 5) ^ (acc >> 2) ^ data[i];
  }
  return acc;
}

int main(void) {
  uint8_t src[96];
  uint8_t dst[96];
  for (size_t i = 0; i < sizeof(src); ++i) {
    src[i] = (uint8_t) ((i * 13u) ^ 0x5Au);
  }
  memset(dst, 0, sizeof(dst));

  // overlapping move
  memmove(dst + 8, src, 64);
  memmove(dst + 24, dst + 8, 40);
  memset(dst + 12, 0xA5, 8);

  uint8_t* heap = (uint8_t*) malloc(160);
  if (heap == NULL) {
    return 1;
  }
  memset(heap, 0, 160);
  memcpy(heap + 16, dst, 48);
  memmove(heap + 32, heap + 16, 64);

  // small struct copy via memcpy
  struct pair {
    uint32_t a;
    uint32_t b;
  } pairs[6];
  for (size_t i = 0; i < 6; ++i) {
    pairs[i].a = (uint32_t) (i * 0x11111111u);
    pairs[i].b = accumulate(src + i * 4, 4);
  }
  memcpy(heap + 96, pairs, sizeof(pairs));

  uint32_t digest = accumulate(dst, sizeof(dst));
  digest ^= accumulate(heap, 160);
  digest ^= accumulate((const uint8_t*) pairs, sizeof(pairs));

  printf("memops digest=%08x\n", digest);
  free(heap);
  return (int) (digest & 0xFF);
}

```

`samples/programs/rewind_demo_million.c`:

```c
// demo program to generate a few million basic block flow events. safe and non-malicious.

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#if defined(__clang__)
#define W1_NO_INLINE __attribute__((noinline))
#define W1_OPTNONE __attribute__((optnone))
#elif defined(__GNUC__)
#define W1_NO_INLINE __attribute__((noinline))
#define W1_OPTNONE
#else
#define W1_NO_INLINE
#define W1_OPTNONE
#endif

static W1_NO_INLINE W1_OPTNONE uint8_t rotl8(uint8_t value, unsigned int count) {
  const unsigned int r = count & 7u;
  if (r == 0u) {
    return value;
  }
  return (uint8_t) ((uint8_t) (value << r) | (uint8_t) (value >> (8u - r)));
}

static W1_NO_INLINE W1_OPTNONE uint32_t mix_slice(uint8_t* buffer, size_t len, uint32_t seed) {
  uint32_t acc = seed ^ 0x9e3779b9u;
  for (size_t i = 0; i < len; ++i) {
    acc ^= (uint32_t) (buffer[i] + (uint8_t) (i * 11u));
    acc = (acc << 7) | (acc >> 25);
    buffer[i] = (uint8_t) (buffer[i] + (uint8_t) (acc >> 3));
  }
  return acc;
}

static W1_NO_INLINE W1_OPTNONE uint64_t run_workload(uint8_t* buffer, size_t len, uint32_t iterations) {
  const uint32_t mask = (uint32_t) (len - 1u);
  uint32_t state = 0x1234567u;
  uint64_t acc = 0;

#if defined(__clang__)
#pragma clang loop vectorize(disable)
#pragma clang loop interleave(disable)
#endif
  for (uint32_t i = 0; i < iterations; ++i) {
    state = state * 1664525u + 1013904223u;
    const uint32_t idx = state & mask;
    const uint32_t alt = (idx + ((state >> 8) & mask)) & mask;

    switch (state & 3u) {
    case 0u:
      buffer[idx] ^= (uint8_t) state;
      acc += buffer[idx];
      break;
    case 1u:
      buffer[idx] = (uint8_t) (buffer[idx] + (uint8_t) (state >> 8));
      acc ^= (uint64_t) buffer[(idx + 1u) & mask];
      break;
    case 2u:
      buffer[idx] = rotl8(buffer[idx], (unsigned int) (state & 7u));
      acc += (uint64_t) (buffer[idx] * 3u);
      break;
    default:
      {
        uint8_t tmp = buffer[idx];
        buffer[idx] = buffer[alt];
        buffer[alt] = (uint8_t) (tmp ^ (uint8_t) (state >> 16));
        acc ^= (uint64_t) buffer[alt];
      }
      break;
    }

    if ((i & 1023u) == 0u) {
      acc ^= mix_slice(buffer, 16u, state);
    }
  }

  return acc;
}

int main(int argc, char** argv) {
  const uint32_t default_iterations = 1000000u;
  uint32_t iterations = default_iterations;
  if (argc > 1) {
    const unsigned long parsed = strtoul(argv[1], NULL, 10);
    if (parsed > 0u && parsed < 200000000u) {
      iterations = (uint32_t) parsed;
    }
  }

  uint8_t buffer[256];
  for (size_t i = 0; i < sizeof(buffer); ++i) {
    buffer[i] = (uint8_t) ((i * 37u) ^ 0xA5u);
  }

  const uint64_t acc = run_workload(buffer, sizeof(buffer), iterations);

  uint64_t checksum = acc;
  for (size_t i = 0; i < sizeof(buffer); ++i) {
    checksum += (uint64_t) buffer[i] * (uint64_t) (i + 1u);
  }

  printf("rewind million iterations=%u checksum=%llu\n", iterations, (unsigned long long) checksum);
  return (int) (checksum & 0xFFu);
}

```

`samples/programs/runtime_injection_target.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef _WIN32
#include <windows.h>
#include <process.h>
#else
#include <unistd.h>
#include <pthread.h>
#include <sys/time.h>
#endif

// Global state for the application
static volatile int g_running = 1;
static volatile int g_counter = 0;
static volatile int g_operations_performed = 0;

// Different algorithms to create interesting code paths
int fibonacci(int n) {
  if (n <= 1) {
    return n;
  }
  return fibonacci(n - 1) + fibonacci(n - 2);
}

int factorial(int n) {
  if (n <= 1) {
    return 1;
  }
  return n * factorial(n - 1);
}

void bubble_sort(int arr[], int n) {
  for (int i = 0; i < n - 1; i++) {
    for (int j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        int temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
}

void string_operations() {
  char buffer[256];
  const char* words[] = {"hello", "world", "coverage", "testing", "runtime", "injection"};
  int word_count = sizeof(words) / sizeof(words[0]);

  strcpy(buffer, "Runtime injection test: ");

  for (int i = 0; i < 3; i++) {
    strcat(buffer, words[rand() % word_count]);
    if (i < 2) {
      strcat(buffer, " ");
    }
  }

  printf("[%d] %s (length: %zu)\n", g_counter, buffer, strlen(buffer));
}

void mathematical_operations() {
  int a = rand() % 10 + 1;
  int b = rand() % 10 + 1;

  int fib_result = fibonacci(a);
  int fact_result = factorial(b);

  printf("[%d] Math: fib(%d)=%d, fact(%d)=%d\n", g_counter, a, fib_result, b, fact_result);
}

void array_operations() {
  int size = rand() % 10 + 5;
  int* arr = malloc(size * sizeof(int));

  // Fill with random data
  for (int i = 0; i < size; i++) {
    arr[i] = rand() % 100;
  }

  printf("[%d] Sorting array of %d elements: ", g_counter, size);
  for (int i = 0; i < size; i++) {
    printf("%d ", arr[i]);
  }

  bubble_sort(arr, size);

  printf("-> ");
  for (int i = 0; i < size; i++) {
    printf("%d ", arr[i]);
  }
  printf("\n");

  free(arr);
}

void* worker_thread(void* arg) {
  int thread_id = *(int*) arg;
  int local_counter = 0;

  while (g_running) {
    local_counter++;

    if (local_counter % 5 == 0) {
      printf("[Thread %d] Background work iteration %d\n", thread_id, local_counter);
    }

    // Do some work to create coverage
    int temp = fibonacci(5) + factorial(3);
    temp = temp % 100; // Use the result

#ifdef _WIN32
    Sleep(500); // 0.5 second
#else
    usleep(500000); // 0.5 second
#endif
  }

  printf("[Thread %d] Exiting after %d iterations\n", thread_id, local_counter);
  return NULL;
}

void print_status() {
#ifdef _WIN32
  SYSTEMTIME st;
  GetLocalTime(&st);

  printf("\n=== Runtime Injection Target Status ===\n");
  printf("PID: %d\n", _getpid());
  printf("Operations performed: %d\n", g_operations_performed);
  printf("Current counter: %d\n", g_counter);
  printf("Timestamp: %02d:%02d:%02d.%03d\n", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
  printf("Ready for runtime injection testing!\n");
  printf("=======================================\n\n");
#else
  struct timeval tv;
  gettimeofday(&tv, NULL);

  printf("\n=== Runtime Injection Target Status ===\n");
  printf("PID: %d\n", getpid());
  printf("Operations performed: %d\n", g_operations_performed);
  printf("Current counter: %d\n", g_counter);
  printf("Timestamp: %lld.%06lld\n", (long long) tv.tv_sec, (long long) tv.tv_usec);
  printf("Ready for runtime injection testing!\n");
  printf("=======================================\n\n");
#endif
}

int main() {
#ifdef _WIN32
  printf("Starting runtime injection target (PID: %d)\n", _getpid());
#else
  printf("Starting runtime injection target (PID: %d)\n", getpid());
#endif
  printf("This program will run continuously until interrupted.\n");
  printf("Use w1tool to inject coverage collection while it's running.\n\n");

  srand(time(NULL));

#ifndef _WIN32
  // Start background worker thread (Unix only)
  pthread_t worker;
  int thread_id = 1;
  pthread_create(&worker, NULL, worker_thread, &thread_id);
#endif

  print_status();

  // Main loop with different operation types
  while (g_running) {
    g_counter++;

    // Cycle through different types of operations
    switch (g_counter % 4) {
    case 0:
      string_operations();
      break;
    case 1:
      mathematical_operations();
      break;
    case 2:
      array_operations();
      break;
    case 3:
      printf("[%d] Simple operation: %d + %d = %d\n", g_counter, g_counter, g_counter * 2, g_counter + g_counter * 2);
      break;
    }

    g_operations_performed++;

    // Print status periodically
    if (g_counter % 10 == 0) {
      print_status();
    }

    // Stop after a reasonable number of operations for testing
    if (g_counter >= 50) {
      printf("\nReached operation limit, shutting down gracefully...\n");
      g_running = 0;
    }

#ifdef _WIN32
    Sleep(1000); // 1 second between operations
#else
    sleep(1); // 1 second between operations
#endif
  }

#ifndef _WIN32
  // Wait for worker thread to finish (Unix only)
  pthread_join(worker, NULL);
#endif

  printf("\nRuntime injection target completed.\n");
  printf("Total operations performed: %d\n", g_operations_performed);

  return 0;
}

```

`samples/programs/signature_helper.h`:

```h
#pragma once

#include <stdint.h>

// prevent inlining
#if defined(_MSC_VER)
#define NOINLINE __declspec(noinline)
#elif defined(__GNUC__) || defined(__clang__)
#define NOINLINE __attribute__((noinline))
#else
#define NOINLINE
#endif

/*
 * ASM_SIGNATURE_HELPER Macro (Thank you Claude 3.5 Sonnet)
 *
 * Purpose:
 * This macro inserts a unique, easily identifiable assembly code sequence
 * into a function. It's designed to assist in debugging, function detouring,
 * and memory analysis by providing a consistent, platform-specific signature
 * that can be used to locate functions in memory.
 *
 * Supported Platforms:
 * - MSVC x86
 * - MSVC x64
 * - MSVC ARM64
 * - Clang x64
 * - Clang ARM64
 * - GCC x64
 * - GCC ARM64
 *
 * Key Features:
 * 1. Platform-Specific Implementation: Uses conditional compilation to provide
 *    appropriate assembly for each supported platform and architecture.
 * 2. Unique Signature: Utilizes easily recognizable constants (0xDEADBEEFCAFEBABE
 *    and 0xCAFEBABEDEADBEEF) to create a distinct pattern in memory.
 * 3. Optimization Resistance: Employs various techniques to prevent compiler
 *    optimization from removing or altering the signature code.
 *
 * Optimization Prevention Techniques:
 * - Volatile Assembly: Marks assembly as volatile to indicate potential side effects.
 * - Memory Barriers: Prevents instruction reordering around the signature.
 * - Dummy Variables: Forces the compiler to consider the computation results.
 * - Output Constraints: Ensures the assembly results are used (for Clang and GCC).
 * - Memory Clobbering: Indicates potential memory access to the compiler.
 * - Stack Operations: Simulates memory side effects (especially for ARM).
 *
 * Usage:
 * Insert ASM_SIGNATURE_HELPER(); at the beginning of any function you want to mark.
 * Example:
 *     void my_function() {
 *         ASM_SIGNATURE_HELPER();
 *         // Rest of the function code...
 *     }
 *
 * Finding the Function Start:
 * 1. Locate the signature in memory.
 * 2. Scan backwards for the function prologue:
 *    - x64: Look for instructions like "push rbp; mov rbp, rsp"
 *    - ARM64: Look for instructions like "stp x29, x30, [sp, #-16]!"
 * 3. The first instruction of the prologue is likely the true function start.
 *
 * Note:
 * While this macro is designed to be optimization-resistant, it's not guaranteed
 * to work with all optimization levels or future compiler versions. Always test
 * thoroughly with your specific build configuration.
 */
#if defined(_MSC_VER) && defined(_M_IX86)
// MSVC for x86 (32-bit)
#define ASM_SIGNATURE_HELPER()                                                                                         \
  do {                                                                                                                 \
    volatile uint32_t dummy1_low = 0xCAFEBABE;                                                                         \
    volatile uint32_t dummy1_high = 0xDEADBEEF;                                                                        \
    volatile uint32_t dummy2_low = 0xDEADBEEF;                                                                         \
    volatile uint32_t dummy2_high = 0xCAFEBABE;                                                                        \
    volatile uint32_t result_low, result_high;                                                                         \
    result_low = dummy1_low ^ dummy2_low;                                                                              \
    result_high = dummy1_high ^ dummy2_high;                                                                           \
    dummy1_low = result_low;                                                                                           \
    dummy1_high = result_high;                                                                                         \
    _ReadWriteBarrier();                                                                                               \
    (void) dummy1_low; /* Prevent 'unused variable' warnings */                                                        \
    (void) dummy1_high;                                                                                                \
    (void) dummy2_low;                                                                                                 \
    (void) dummy2_high;                                                                                                \
  } while (0)
#elif defined(_MSC_VER) && defined(_M_X64)
// MSVC for x64
#define ASM_SIGNATURE_HELPER()                                                                                         \
  do {                                                                                                                 \
    volatile uint64_t dummy1 = 0xDEADBEEFCAFEBABE;                                                                     \
    volatile uint64_t dummy2 = 0xCAFEBABEDEADBEEF;                                                                     \
    volatile uint64_t result;                                                                                          \
    result = dummy1 ^ dummy2;                                                                                          \
    dummy1 = result;                                                                                                   \
    _ReadWriteBarrier();                                                                                               \
    _mm_mfence();                                                                                                      \
    (void) dummy1; /* Prevent 'unused variable' warnings */                                                            \
    (void) dummy2;                                                                                                     \
  } while (0)
#elif defined(_MSC_VER) && defined(_M_ARM64)
// MSVC for ARM64
#define ASM_SIGNATURE_HELPER()                                                                                         \
  do {                                                                                                                 \
    volatile uint64_t dummy1 = 0xDEADBEEFCAFEBABE;                                                                     \
    volatile uint64_t dummy2 = 0xCAFEBABEDEADBEEF;                                                                     \
    volatile uint64_t result;                                                                                          \
    result = dummy1 ^ dummy2;                                                                                          \
    dummy1 = result;                                                                                                   \
    __dmb(_ARM64_BARRIER_ISH);      /* Data Memory Barrier */                                                          \
    __iso_volatile_load64(&dummy1); /* Volatile read to prevent optimization */                                        \
    (void) dummy2;                                                                                                     \
  } while (0)
#elif defined(__clang__)
#if defined(__x86_64__)
// Clang for x64
#define ASM_SIGNATURE_HELPER()                                                                                         \
  do {                                                                                                                 \
    uint64_t dummy;                                                                                                    \
    __asm__ volatile("nop\n\t"                                                                                         \
                     "movabs $0xDEADBEEFCAFEBABE, %%rax\n\t"                                                           \
                     "movabs $0xCAFEBABEDEADBEEF, %%rbx\n\t"                                                           \
                     "xorq %%rbx, %%rax\n\t"                                                                           \
                     "movq %%rax, %0\n\t"                                                                              \
                     "nop\n\t"                                                                                         \
                     : "=r"(dummy)                                                                                     \
                     :                                                                                                 \
                     : "rax", "rbx", "memory");                                                                        \
    __asm__ volatile("" : : : "memory");                                                                               \
    (void) dummy;                                                                                                      \
  } while (0)
#elif defined(__aarch64__)
// Clang for ARM64
#define ASM_SIGNATURE_HELPER()                                                                                         \
  do {                                                                                                                 \
    uint64_t dummy;                                                                                                    \
    __asm__ volatile("nop\n\t"                                                                                         \
                     "mov x0, #0xDEAD\n\t"                                                                             \
                     "movk x0, #0xBEEF, lsl #16\n\t"                                                                   \
                     "movk x0, #0xCAFE, lsl #32\n\t"                                                                   \
                     "movk x0, #0xBABE, lsl #48\n\t"                                                                   \
                     "mov x1, #0xCAFE\n\t"                                                                             \
                     "movk x1, #0xBABE, lsl #16\n\t"                                                                   \
                     "movk x1, #0xDEAD, lsl #32\n\t"                                                                   \
                     "movk x1, #0xBEEF, lsl #48\n\t"                                                                   \
                     "eor x0, x0, x1\n\t"                                                                              \
                     "str x0, [sp, #-16]!\n\t"                                                                         \
                     "ldr x0, [sp], #16\n\t"                                                                           \
                     "mov %0, x0\n\t"                                                                                  \
                     "nop\n\t"                                                                                         \
                     : "=r"(dummy)                                                                                     \
                     :                                                                                                 \
                     : "x0", "x1", "memory");                                                                          \
    __asm__ volatile("" : : : "memory");                                                                               \
    (void) dummy;                                                                                                      \
  } while (0)
#else
#error "Unsupported architecture for ASM_SIGNATURE_HELPER"
#endif
#elif defined(__GNUC__)
#if defined(__x86_64__)
// GCC for x64
#define ASM_SIGNATURE_HELPER()                                                                                         \
  do {                                                                                                                 \
    uint64_t dummy;                                                                                                    \
    __asm__ volatile("nop\n\t"                                                                                         \
                     "movabs $0xDEADBEEFCAFEBABE, %%rax\n\t"                                                           \
                     "movabs $0xCAFEBABEDEADBEEF, %%rbx\n\t"                                                           \
                     "xorq %%rbx, %%rax\n\t"                                                                           \
                     "movq %%rax, %0\n\t"                                                                              \
                     "nop\n\t"                                                                                         \
                     : "=r"(dummy)                                                                                     \
                     :                                                                                                 \
                     : "rax", "rbx", "memory");                                                                        \
    __asm__ volatile("" : : : "memory");                                                                               \
    (void) dummy;                                                                                                      \
  } while (0)
#elif defined(__aarch64__)
// GCC for ARM64
#define ASM_SIGNATURE_HELPER()                                                                                         \
  do {                                                                                                                 \
    uint64_t dummy;                                                                                                    \
    __asm__ volatile("nop\n\t"                                                                                         \
                     "mov x0, #0xDEAD\n\t"                                                                             \
                     "movk x0, #0xBEEF, lsl #16\n\t"                                                                   \
                     "movk x0, #0xCAFE, lsl #32\n\t"                                                                   \
                     "movk x0, #0xBABE, lsl #48\n\t"                                                                   \
                     "mov x1, #0xCAFE\n\t"                                                                             \
                     "movk x1, #0xBABE, lsl #16\n\t"                                                                   \
                     "movk x1, #0xDEAD, lsl #32\n\t"                                                                   \
                     "movk x1, #0xBEEF, lsl #48\n\t"                                                                   \
                     "eor x0, x0, x1\n\t"                                                                              \
                     "str x0, [sp, #-16]!\n\t"                                                                         \
                     "ldr x0, [sp], #16\n\t"                                                                           \
                     "mov %0, x0\n\t"                                                                                  \
                     "nop\n\t"                                                                                         \
                     : "=r"(dummy)                                                                                     \
                     :                                                                                                 \
                     : "x0", "x1", "memory");                                                                          \
    __asm__ volatile("" : : : "memory");                                                                               \
    (void) dummy;                                                                                                      \
  } while (0)
#else
#error "Unsupported architecture for ASM_SIGNATURE_HELPER"
#endif
#else
#error "Unsupported compiler for ASM_SIGNATURE_HELPER"
#endif

```

`samples/programs/simple_demo.c`:

```c
/*
 * simple demo program for w1script testing
 * performs basic operations with limited output
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// simple function to add two numbers
int add(int a, int b) { return a + b; }

// simple function to multiply two numbers
int multiply(int a, int b) { return a * b; }

// function that allocates and frees memory
void memory_test() {
  char* buffer = malloc(64);
  if (buffer) {
    strcpy(buffer, "hello world");
    printf("allocated buffer: %s\n", buffer);
    free(buffer);
  }
}

// function with a simple loop
void loop_test() {
  int sum = 0;
  for (int i = 1; i <= 5; i++) {
    sum += i;
  }
  printf("sum 1-5: %d\n", sum);
}

int main() {
  printf("simple demo starting\n");

  // basic arithmetic
  int result1 = add(10, 20);
  int result2 = multiply(5, 6);
  printf("add(10, 20) = %d\n", result1);
  printf("multiply(5, 6) = %d\n", result2);

  // memory operations
  memory_test();

  // loop operations
  loop_test();

  printf("simple demo finished\n");
  return 0;
}
```

`samples/programs/threadtest_demo.c`:

```c
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#if defined(_WIN32)
int main(void) {
  fprintf(stderr, "threadtest_demo is not supported on Windows.\n");
  return EXIT_SUCCESS;
}
#else

#include <pthread.h>
#include <unistd.h>

typedef struct worker_args {
  int index;
  int iterations;
} worker_args;

static void random_delay(void) {
  struct timespec ts;
  ts.tv_sec = 0;
  ts.tv_nsec = (rand() % 200 + 50) * 1000000; // 50-250ms
  nanosleep(&ts, NULL);
}

static void* worker_thread(void* arg) {
  worker_args* args = (worker_args*) arg;
  long accumulator = 0;
  for (int i = 0; i < args->iterations; ++i) {
    accumulator += (args->index + 1) * (i + 1);
    if ((i % 3) == 0) {
      random_delay();
    }
  }

  printf("worker %d done: iterations=%d sum=%ld\n", args->index, args->iterations, accumulator);
  fflush(stdout);

  return (void*) (uintptr_t) accumulator;
}

int main(void) {
  unsigned int seed = 1;
  const char* seed_env = getenv("THREADTEST_SEED");
  if (seed_env != NULL) {
    seed = (unsigned int) strtoul(seed_env, NULL, 0);
  }
  srand(seed);

  const int thread_count = 3;
  pthread_t threads[thread_count];
  worker_args args[thread_count];

  for (int i = 0; i < thread_count; ++i) {
    args[i].index = i;
    args[i].iterations = 10 + (i * 5);
    int rc = pthread_create(&threads[i], NULL, worker_thread, &args[i]);
    if (rc != 0) {
      fprintf(stderr, "pthread_create failed for thread %d: %d\n", i, rc);
      return EXIT_FAILURE;
    }
  }

  for (int i = 0; i < thread_count; ++i) {
    void* result = NULL;
    int rc = pthread_join(threads[i], &result);
    if (rc != 0) {
      fprintf(stderr, "pthread_join failed for thread %d: %d\n", i, rc);
      continue;
    }
    printf("worker %d result=%ld\n", i, (long) (uintptr_t) result);
  }

  printf("threadtest_demo complete\n");
  return EXIT_SUCCESS;
}

#endif

```

`samples/programs/threadtest_evasive_demo.cpp`:

```cpp
// threadtest_evasive_demo exercises thread creation paths that bypass our pthread hooks.
// this program is strictly for validating instrumentation coverage against evasive behavior.
// it does not perform any malicious action and is used to test our analysis tools.

#include <cstdio>
#include <cstdlib>
#include <cstdint>

#if defined(_WIN32)
int main() {
  std::fprintf(stderr, "threadtest_evasive_demo is not supported on Windows.\n");
  return EXIT_SUCCESS;
}
#elif defined(__APPLE__)

#include <atomic>
#include <dispatch/dispatch.h>
#include <mach/mach.h>
#include <mach/mach_vm.h>
#include <mach/thread_act.h>
#include <mach/thread_state.h>
#include <pthread.h>
#include <string.h>
#include <sys/syscall.h>
#include <time.h>
#include <unistd.h>
#include <vector>

extern "C" void __bsdthread_terminate(void*, void*, uint32_t, uint32_t);

// shared completion counter so the main thread can wait for every worker
static std::atomic<int> g_completed_threads{0};

struct worker_payload {
  const char* tag;
  int iterations;
};

// simple workload that burns some cpu time and emits a status line
static void sleep_millis(int millis) {
  if (millis <= 0) {
    return;
  }

  struct timespec ts;
  ts.tv_sec = millis / 1000;
  ts.tv_nsec = (millis % 1000) * 1000000L;
  while (nanosleep(&ts, &ts) != 0) {
    // retry when interrupted
  }
}

static void perform_work(const worker_payload& payload, bool allow_sleep, bool emit_log) {
  volatile uint64_t accumulator = 0;
  for (int i = 0; i < payload.iterations; ++i) {
    accumulator += static_cast<uint64_t>((i + 1) * 13);
    if (allow_sleep && (i % 4) == 0) {
      sleep_millis(30);
    }
  }

  if (emit_log) {
    std::printf("[%s] work complete (acc=%llu)\n", payload.tag, static_cast<unsigned long long>(accumulator));
  }
  g_completed_threads.fetch_add(1, std::memory_order_release);
}

// -- standard pthread_create -------------------------------------------------

static void* pthread_worker_entry(void* arg) {
  const worker_payload* payload = static_cast<const worker_payload*>(arg);
  perform_work(*payload, /*allow_sleep=*/true, /*emit_log=*/true);
  return nullptr;
}

static bool launch_plain_pthread(worker_payload& payload, pthread_t* out_thread) {
  int rc = pthread_create(out_thread, nullptr, &pthread_worker_entry, &payload);
  if (rc != 0) {
    std::fprintf(stderr, "pthread_create failed: %d\n", rc);
    return false;
  }
  return true;
}

// -- pthread_create_suspended_np path ----------------------------------------

static void* suspended_worker_entry(void* arg) {
  const worker_payload* payload = static_cast<const worker_payload*>(arg);
  perform_work(*payload, /*allow_sleep=*/true, /*emit_log=*/true);
  return nullptr;
}

static bool launch_suspended_pthread(worker_payload& payload, pthread_t* out_thread) {
  int rc = pthread_create_suspended_np(out_thread, nullptr, &suspended_worker_entry, &payload);
  if (rc != 0) {
    std::fprintf(stderr, "pthread_create_suspended_np failed: %d\n", rc);
    return false;
  }

  // resume the thread so it starts executing without going through pthread_create
  thread_act_t thread_port = pthread_mach_thread_np(*out_thread);
  kern_return_t kr = thread_resume(thread_port);
  if (kr != KERN_SUCCESS) {
    std::fprintf(stderr, "thread_resume failed: %d\n", kr);
    return false;
  }
  return true;
}

// -- direct mach thread via thread_create_running ----------------------------

struct mach_thread_allocation {
  mach_port_t thread_port;
  mach_vm_address_t stack_address;
  mach_vm_size_t stack_size;
};

struct mach_thread_payload {
  worker_payload payload;
};

static void mach_thread_entry(void* raw_arg) {
  mach_thread_payload* thread_payload = static_cast<mach_thread_payload*>(raw_arg);
  perform_work(thread_payload->payload, /*allow_sleep=*/false, /*emit_log=*/false);

  const char* msg = "[mach_thread_create] work complete\n";
  write(STDOUT_FILENO, msg, strlen(msg));

  delete thread_payload;

  // exit without relying on pthread teardown APIs
  __bsdthread_terminate(nullptr, nullptr, 0, 0);
}

static bool launch_mach_thread(const worker_payload& payload, mach_thread_allocation& allocation) {
  allocation.stack_address = 0;
  allocation.stack_size = 0;
  allocation.thread_port = MACH_PORT_NULL;

  // allocate a private stack for the mach thread
  const mach_vm_size_t stack_size = (1u << 20); // 1 MiB
  mach_vm_address_t stack_base = 0;
  kern_return_t kr = mach_vm_allocate(mach_task_self(), &stack_base, stack_size, VM_FLAGS_ANYWHERE);
  if (kr != KERN_SUCCESS) {
    std::fprintf(stderr, "mach_vm_allocate failed: %d\n", kr);
    return false;
  }

  mach_vm_address_t stack_top = stack_base + stack_size - 0x10;

  auto* thread_payload = new mach_thread_payload{payload};

#if defined(__aarch64__)
  arm_thread_state64_t state = {};
  uint64_t entry = reinterpret_cast<uint64_t>(&mach_thread_entry);
#if defined(__arm64e__)
  entry = reinterpret_cast<uint64_t>(__builtin_ptrauth_strip(reinterpret_cast<void*>(&mach_thread_entry), 0));
#endif
  state.__pc = entry;
  state.__sp = stack_top;
  state.__x[0] = reinterpret_cast<uint64_t>(thread_payload);
  state.__lr = 0;
  mach_msg_type_number_t state_count = ARM_THREAD_STATE64_COUNT;
  thread_state_flavor_t flavor = ARM_THREAD_STATE64;
#elif defined(__x86_64__)
  x86_thread_state64_t state = {};
  state.__rip = reinterpret_cast<uint64_t>(&mach_thread_entry);
  state.__rsp = stack_top;
  state.__rdi = reinterpret_cast<uint64_t>(thread_payload);
  state.__rbp = 0;
  mach_msg_type_number_t state_count = x86_THREAD_STATE64_COUNT;
  thread_state_flavor_t flavor = x86_THREAD_STATE64;
#else
#error "unsupported darwin architecture"
#endif

  mach_port_t thread_port = MACH_PORT_NULL;
  kr = thread_create_running(
      mach_task_self(), flavor, reinterpret_cast<thread_state_t>(&state), state_count, &thread_port
  );
  if (kr != KERN_SUCCESS) {
    std::fprintf(stderr, "thread_create_running failed: %d\n", kr);
    delete thread_payload;
    mach_vm_deallocate(mach_task_self(), stack_base, stack_size);
    return false;
  }

  allocation.stack_address = stack_base;
  allocation.stack_size = stack_size;
  allocation.thread_port = thread_port;
  return true;
}

// -- dispatch workqueue path --------------------------------------------------

struct dispatch_payload {
  worker_payload payload;
};

static void dispatch_worker(void* context) {
  auto* payload = static_cast<dispatch_payload*>(context);
  perform_work(payload->payload, /*allow_sleep=*/true, /*emit_log=*/true);
  delete payload;
}

static bool launch_dispatch_worker(const worker_payload& payload, dispatch_queue_t queue) {
  auto* context = new dispatch_payload{payload};
  dispatch_async_f(queue, context, &dispatch_worker);
  return true;
}

int main() {
  std::vector<mach_thread_allocation> mach_allocations;
  mach_allocations.reserve(2);

  worker_payload pthread_payload{"pthread_create", 12};
  worker_payload suspended_payload{"pthread_create_suspended_np", 10};
  worker_payload mach_payload{"mach_thread_create", 14};
  worker_payload dispatch_payload_data{"dispatch_async", 8};

  pthread_t plain_thread{};
  pthread_t suspended_thread{};

  if (!launch_plain_pthread(pthread_payload, &plain_thread)) {
    return EXIT_FAILURE;
  }

  if (!launch_suspended_pthread(suspended_payload, &suspended_thread)) {
    // ensure the first thread is joined before exiting
    pthread_join(plain_thread, nullptr);
    return EXIT_FAILURE;
  }

  mach_thread_allocation mach_allocation{};
  if (launch_mach_thread(mach_payload, mach_allocation)) {
    mach_allocations.push_back(mach_allocation);
  } else {
    std::fprintf(stderr, "mach thread launch failed\n");
  }

  dispatch_queue_t queue = dispatch_queue_create("com.w1tn3ss.threadtest.evasive", DISPATCH_QUEUE_CONCURRENT);
  launch_dispatch_worker(dispatch_payload_data, queue);

  // join the pthread-based workers to keep the demo tidy
  pthread_join(plain_thread, nullptr);
  pthread_join(suspended_thread, nullptr);

  const int expected = 4;
  while (g_completed_threads.load(std::memory_order_acquire) < expected) {
    sleep_millis(50);
  }

  // clean up any mach resources we own
  for (const auto& allocation : mach_allocations) {
    if (allocation.thread_port != MACH_PORT_NULL) {
      mach_port_deallocate(mach_task_self(), allocation.thread_port);
    }
    if (allocation.stack_address != 0 && allocation.stack_size != 0) {
      mach_vm_deallocate(mach_task_self(), allocation.stack_address, allocation.stack_size);
    }
  }

#if !OS_OBJECT_USE_OBJC
  dispatch_release(queue);
#endif

  std::printf("threadtest_evasive_demo complete\n");
  return EXIT_SUCCESS;
}

#else
int main() {
  std::fprintf(stderr, "threadtest_evasive_demo is only implemented for Darwin targets.\n");
  return EXIT_SUCCESS;
}
#endif

```

`samples/standalone/README.md`:

```md
# Standalone samples

This directory contains self-contained sample projects that build against the p1ll core without the full w1tn3ss build.

## p1ll_standalone

Build and run the standalone C++ and C API tests:

    cmake -G Ninja -S samples/standalone/p1ll_standalone -B build-p1ll-standalone
    cmake --build build-p1ll-standalone
    ./build-p1ll-standalone/test_p1ll_standalone
    ./build-p1ll-standalone/test_p1ll_capi

## p1ll_python

After building the Python bindings (see `doc/p1ll_python.md`), run:

    PYTHONPATH=build-p1ll-python python3 samples/standalone/p1ll_python/test_p1ll_python.py

```

`samples/standalone/p1ll_python/test_p1ll_python.py`:

```py
#!/usr/bin/env python3

import sys

import p1ll


def main() -> int:
    sess = p1ll.Session.for_buffer(b"\x90\x90\xcc\x90")
    options = p1ll.ScanOptions()
    options.single = True
    results = sess.scan("90 90", options)

    if not results:
        print("no matches found")
        return 1

    print("before:", sess.buffer_bytes().hex())

    sig = p1ll.SignatureSpec()
    sig.pattern = "90 90"
    sig.options = options
    sig.required = True

    patch = p1ll.PatchSpec()
    patch.signature = sig
    patch.offset = 0
    patch.patch = "CC CC"
    patch.required = True

    recipe = p1ll.Recipe()
    recipe.name = "test"
    recipe.patches = [patch]

    plan = sess.plan(recipe)
    report = sess.apply(plan)

    print("after:", sess.buffer_bytes().hex())
    print(
        f"applied: {report.applied} failed: {report.failed} success: {report.success}"
    )

    if not report.success:
        return 1

    return 0


if __name__ == "__main__":
    sys.exit(main())

```

`samples/standalone/p1ll_standalone/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.12)
project(test_p1ll_standalone)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# external projects would use find_package instead
set(W1TNSS_ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../../..)

# add redlog: p1ll depends on it
add_subdirectory(${W1TNSS_ROOT}/src/third_party/redlog_cpp redlog_cpp EXCLUDE_FROM_ALL)

# configure c api before adding p1ll
option(BUILD_C_API_TEST "Build C API test executable" ON)
if(BUILD_C_API_TEST)
    set(P1LL_BUILD_CAPI ON CACHE BOOL "Enable C API" FORCE)
endif()

# add p1ll core library
add_subdirectory(${W1TNSS_ROOT}/src/p1ll p1ll_standalone_build)

# create c++ test executable
add_executable(test_p1ll_standalone test_p1ll_standalone.cpp)
target_link_libraries(test_p1ll_standalone PRIVATE p1ll_core)
target_include_directories(test_p1ll_standalone PRIVATE ${W1TNSS_ROOT}/src)

# create c api test executable if enabled
if(BUILD_C_API_TEST)
    # create c test executable
    add_executable(test_p1ll_capi test_p1ll_capi.c)
    target_link_libraries(test_p1ll_capi PRIVATE p1ll_c)
    
    # ensure c standard
    set_target_properties(test_p1ll_capi PROPERTIES
        C_STANDARD 99
        C_STANDARD_REQUIRED ON
    )
    
    message(STATUS "c api test executable enabled")
else()
    message(STATUS "c api test executable disabled")
endif()

```

`samples/standalone/p1ll_standalone/test_p1ll_capi.c`:

```c
/**
 * @file test_p1ll_capi.c
 * @brief sanity test for the p1ll C API session interface
 */

#include <assert.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <p1ll_c.h>

#define TEST_BUFFER_SIZE 256

static void print_error(const char* context) {
  const char* error = p1ll_get_last_error();
  if (error && strlen(error) > 0) {
    printf("[error] %s: %s\n", context, error);
  } else {
    printf("[error] %s: unknown error\n", context);
  }
}

static void test_capabilities(void) {
  printf("=== capability tests ===\n");

  int has_scripting = p1ll_has_scripting_support();
  printf("scripting support: %s\n", has_scripting ? "yes" : "no");
  printf("[ok] capability queries\n\n");
}

static void test_pattern_validation(void) {
  printf("=== pattern validation tests ===\n");

  const char* valid_patterns[] = {"48 89 e5", "ff d0 ?? 74", "90 90 90 90", "48 ?? ?? ?? 74 ??", "c3"};

  for (size_t i = 0; i < sizeof(valid_patterns) / sizeof(valid_patterns[0]); ++i) {
    int valid = p1ll_validate_pattern(valid_patterns[i]);
    assert(valid == 1);
    printf("[ok] validated pattern: '%s'\n", valid_patterns[i]);
  }

  const char* invalid_patterns[] = {"zz 90", "4", "", "90 gg 74"};

  for (size_t i = 0; i < sizeof(invalid_patterns) / sizeof(invalid_patterns[0]); ++i) {
    int valid = p1ll_validate_pattern(invalid_patterns[i]);
    assert(valid == 0);
    printf("[ok] rejected invalid pattern: '%s'\n", invalid_patterns[i]);
  }

  printf("[ok] pattern validation\n\n");
}

static void test_hex_utilities(void) {
  printf("=== hex utility tests ===\n");

  const char* hex_string = "48894e08";
  uint8_t* bytes = NULL;
  size_t byte_count = 0;

  int result = p1ll_hex_string_to_bytes(hex_string, &bytes, &byte_count);
  assert(result == P1LL_SUCCESS);
  assert(bytes != NULL);
  assert(byte_count == 4);
  assert(bytes[0] == 0x48);
  assert(bytes[1] == 0x89);
  assert(bytes[2] == 0x4e);
  assert(bytes[3] == 0x08);
  printf("[ok] hex string '%s' -> %zu bytes\n", hex_string, byte_count);

  char* hex_result = p1ll_bytes_to_hex_string(bytes, byte_count);
  assert(hex_result != NULL);
  printf("[ok] bytes -> hex string: '%s'\n", hex_result);

  p1ll_free_bytes(bytes);
  p1ll_free_string(hex_result);

  uint64_t test_addresses[] = {0x7fff12345678ULL, 0x1000ULL, 0x0ULL, 0xfffffffffffff000ULL};
  for (size_t i = 0; i < sizeof(test_addresses) / sizeof(test_addresses[0]); ++i) {
    char* addr_str = p1ll_format_address(test_addresses[i]);
    assert(addr_str != NULL);
    printf("[ok] address 0x%llx -> '%s'\n", (unsigned long long) test_addresses[i], addr_str);
    p1ll_free_string(addr_str);
  }

  printf("[ok] hex utilities\n\n");
}

static void test_buffer_scan_and_apply(void) {
  printf("=== buffer scan/apply tests ===\n");

  uint8_t buffer[TEST_BUFFER_SIZE];
  memset(buffer, 0x90, sizeof(buffer));

  buffer[32] = 0xde;
  buffer[33] = 0xad;
  buffer[34] = 0xbe;
  buffer[35] = 0xef;

  buffer[64] = 0x48;
  buffer[65] = 0x89;
  buffer[66] = 0xe5;
  buffer[128] = 0x48;
  buffer[129] = 0x89;
  buffer[130] = 0xe5;

  p1ll_session_t session = p1ll_session_create_buffer(buffer, sizeof(buffer));
  assert(session != NULL);

  p1ll_scan_result_t* results = NULL;
  size_t result_count = 0;
  p1ll_scan_options_t scan_opts;
  memset(&scan_opts, 0, sizeof(scan_opts));

  int rc = p1ll_scan(session, "48 89 e5", &scan_opts, &results, &result_count);
  assert(rc == P1LL_SUCCESS);
  assert(result_count >= 2);
  printf("[ok] scan found %zu matches\n", result_count);

  if (result_count > 0) {
    printf("[ok] first result region: '%s'\n", results[0].region_name);
  }

  p1ll_free_scan_results(results);

  p1ll_scan_options_t single_opts;
  memset(&single_opts, 0, sizeof(single_opts));
  single_opts.single = 1;

  rc = p1ll_scan(session, "48 89 e5", &single_opts, &results, &result_count);
  assert(rc == P1LL_ERROR);
  print_error("single scan");

  p1ll_scan_options_t validation_opts;
  memset(&validation_opts, 0, sizeof(validation_opts));
  validation_opts.single = 1;

  p1ll_signature_spec_t validation;
  memset(&validation, 0, sizeof(validation));
  validation.pattern = "de ad be ef";
  validation.options = validation_opts;
  validation.required = 1;

  p1ll_patch_spec_t patches[2];
  memset(patches, 0, sizeof(patches));
  patches[0].signature = validation;
  patches[0].offset = 0;
  patches[0].patch = "11 22 33 44";
  patches[0].required = 1;

  patches[1].signature.pattern = "00 11 22 33";
  patches[1].signature.options.single = 1;
  patches[1].patch = "ff ff ff ff";
  patches[1].required = 0;

  p1ll_recipe_t recipe;
  memset(&recipe, 0, sizeof(recipe));
  recipe.name = "buffer_patch";
  recipe.validations = &validation;
  recipe.validation_count = 1;
  recipe.patches = patches;
  recipe.patch_count = 2;

  p1ll_plan_entry_t* entries = NULL;
  size_t entry_count = 0;
  rc = p1ll_plan(session, &recipe, &entries, &entry_count);
  if (rc != P1LL_SUCCESS) {
    print_error("plan");
    assert(rc == P1LL_SUCCESS);
  }
  assert(entry_count == 1);

  p1ll_apply_report_t report;
  memset(&report, 0, sizeof(report));
  rc = p1ll_apply(session, entries, entry_count, &report);
  if (rc != P1LL_SUCCESS) {
    print_error("apply");
    assert(rc == P1LL_SUCCESS);
  }
  assert(report.success);
  assert(report.applied == 1);
  assert(report.failed == 0);

  p1ll_free_plan_entries(entries, entry_count);

  assert(buffer[32] == 0x11);
  assert(buffer[33] == 0x22);
  assert(buffer[34] == 0x33);
  assert(buffer[35] == 0x44);
  printf("[ok] patch applied to buffer\n");

  p1ll_session_destroy(session);

  printf("[ok] buffer scan/apply\n\n");
}

int main(void) {
  test_capabilities();
  test_pattern_validation();
  test_hex_utilities();
  test_buffer_scan_and_apply();

  printf("all p1ll C API tests passed\n");
  return 0;
}

```

`samples/standalone/p1ll_standalone/test_p1ll_standalone.cpp`:

```cpp
#include "p1ll/p1ll.hpp"
#include <cstdlib>
#include <iostream>
#include <span>
#include <vector>

namespace {

void expect(bool condition, const char* message) {
  if (!condition) {
    std::cerr << "test failed: " << message << std::endl;
    std::exit(1);
  }
}

} // namespace

int main() {
  std::vector<uint8_t> buffer(256, 0x90);

  // unique validation signature
  buffer[32] = 0xde;
  buffer[33] = 0xad;
  buffer[34] = 0xbe;
  buffer[35] = 0xef;

  // repeated signature for scan tests
  buffer[64] = 0x48;
  buffer[65] = 0x89;
  buffer[66] = 0xe5;
  buffer[128] = 0x48;
  buffer[129] = 0x89;
  buffer[130] = 0xe5;

  auto session = p1ll::engine::session::for_buffer(std::span<uint8_t>(buffer.data(), buffer.size()));

  p1ll::engine::scan_options scan_opts;
  auto scan_results = session.scan("48 89 e5", scan_opts);
  expect(scan_results.ok(), "scan failed");
  expect(scan_results.value.size() >= 2, "expected multiple matches");

  p1ll::engine::scan_options single_opts;
  single_opts.single = true;
  auto single_results = session.scan("48 89 e5", single_opts);
  expect(!single_results.ok(), "single scan should fail on multiple matches");

  p1ll::engine::signature_spec validation;
  validation.pattern = "de ad be ef";
  validation.options.single = true;

  p1ll::engine::patch_spec patch;
  patch.signature = validation;
  patch.offset = 0;
  patch.patch = "11 22 33 44";
  patch.required = true;

  p1ll::engine::patch_spec optional_patch;
  optional_patch.signature.pattern = "00 11 22 33";
  optional_patch.signature.options.single = true;
  optional_patch.patch = "ff ff ff ff";
  optional_patch.required = false;

  p1ll::engine::recipe recipe;
  recipe.name = "buffer_patch";
  recipe.validations.push_back(validation);
  recipe.patches.push_back(patch);
  recipe.patches.push_back(optional_patch);

  auto plan = session.plan(recipe);
  expect(plan.ok(), "plan failed");
  expect(plan.value.size() == 1, "expected one plan entry");

  auto applied = session.apply(plan.value);
  expect(applied.ok(), "apply failed");
  expect(applied.value.success, "apply did not report success");
  expect(applied.value.applied == 1, "expected one applied entry");
  expect(applied.value.failed == 0, "expected zero failed entries");

  expect(buffer[32] == 0x11, "patch byte 0 mismatch");
  expect(buffer[33] == 0x22, "patch byte 1 mismatch");
  expect(buffer[34] == 0x33, "patch byte 2 mismatch");
  expect(buffer[35] == 0x44, "patch byte 3 mismatch");

  std::cout << "p1ll standalone test ok" << std::endl;
  return 0;
}

```

`scripts/d0ct0r.py`:

```py
#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# dependencies = [
#   "typer>=0.15.0",
#   "rich>=13.0.0",
#   "sh>=2.2.0",
# ]
# ///

import os
import sys
import platform
import stat
import subprocess
import shutil
from pathlib import Path
from typing import Optional, Tuple, List, Dict, Any

import typer
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.panel import Panel
from rich.text import Text
from rich.table import Table
from rich.logging import RichHandler
import logging

CONTEXT_SETTINGS = dict(help_option_names=["-h", "--help"])

APP_NAME = "d0ct0r"
app = typer.Typer(
    name=APP_NAME,
    help=f"{APP_NAME}: intelligent p1llx wrapper with backup management and codesigning",
    no_args_is_help=True,
    context_settings=CONTEXT_SETTINGS,
    pretty_exceptions_short=True,
    pretty_exceptions_show_locals=False,
)

console = Console()

# global state for sudo and verbosity
global_sudo = False
global_verbose = 0


class BinaryFormat:
    """binary format detection utilities"""

    # magic numbers for different binary formats
    MACH_O_MAGIC = {
        0xFEEDFACE: "mach-o 32-bit",
        0xFEEDFACF: "mach-o 64-bit",
        0xCAFEBABE: "mach-o fat binary",
        0xCFFAEDFE: "mach-o 64-bit (reverse)",
        0xCEFAEDFE: "mach-o 32-bit (reverse)",
    }

    ELF_MAGIC = 0x7F454C46  # \x7fELF
    PE_MAGIC = 0x5A4D  # MZ

    @staticmethod
    def detect_format(file_path: Path) -> Tuple[str, bool]:
        """
        detect binary format from magic numbers
        returns (format_name, is_macho)
        """
        try:
            with open(file_path, "rb") as f:
                magic = f.read(4)
                if len(magic) < 4:
                    return "unknown", False

                magic_int = int.from_bytes(magic, byteorder="little")

                # check mach-o formats
                if magic_int in BinaryFormat.MACH_O_MAGIC:
                    return BinaryFormat.MACH_O_MAGIC[magic_int], True

                # check big-endian mach-o
                magic_int_be = int.from_bytes(magic, byteorder="big")
                if magic_int_be in BinaryFormat.MACH_O_MAGIC:
                    return BinaryFormat.MACH_O_MAGIC[magic_int_be], True

                # check elf
                if magic_int == BinaryFormat.ELF_MAGIC:
                    return "elf", False

                # check pe
                if magic_int & 0xFFFF == BinaryFormat.PE_MAGIC:
                    return "pe/coff", False

                return "unknown", False

        except Exception as e:
            console.print(f"[red]error detecting format: {e}[/red]")
            return "unknown", False


class FileOperations:
    """cross-platform file operations with elevation support"""

    @staticmethod
    def copy_file(src: Path, dst: Path, use_elevation: bool = False) -> bool:
        """cross-platform file copy with optional elevation"""
        console.print(f"[cyan]copying: {src} -> {dst}[/cyan]")

        # try normal copy first (unless explicitly told to use elevation)
        if not use_elevation:
            try:
                dst.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy2(src, dst)
                console.print(f"[green]✓ copied successfully[/green]")
                return True
            except PermissionError:
                if platform.system() == "Windows":
                    console.print(
                        "[red]permission denied - please run as administrator[/red]"
                    )
                    return False
                else:
                    console.print(
                        "[yellow]permission denied - retrying with sudo[/yellow]"
                    )
                    # fall through to elevated copy below
            except Exception as e:
                console.print(f"[red]copy failed: {e}[/red]")
                return False

        # elevated copy (either requested explicitly or after permission error)
        if platform.system() == "Windows":
            console.print(
                "[red]windows elevation required - please run as administrator[/red]"
            )
            return False
        else:
            # unix-like: use sudo cp with preserve attributes
            # first ensure destination directory exists with sudo
            dst_dir = dst.parent
            if not dst_dir.exists():
                mkdir_cmd = ["sudo", "mkdir", "-p", str(dst_dir)]
                try:
                    mkdir_result = subprocess.run(
                        mkdir_cmd, capture_output=True, text=True
                    )
                    if mkdir_result.returncode != 0:
                        console.print(
                            f"[red]failed to create directory with sudo: {mkdir_result.stderr}[/red]"
                        )
                        return False
                except Exception as e:
                    console.print(f"[red]sudo mkdir error: {e}[/red]")
                    return False

            # now copy with sudo
            cmd = ["sudo", "cp", "-p", str(src), str(dst)]
            try:
                console.print(f"[dim]$ {' '.join(cmd)}[/dim]")
                result = subprocess.run(cmd, capture_output=True, text=True)
                if result.returncode == 0:
                    console.print(f"[green]✓ copied with sudo[/green]")
                    return True
                else:
                    console.print(f"[red]sudo copy failed: {result.stderr}[/red]")
                    return False
            except Exception as e:
                console.print(f"[red]sudo copy error: {e}[/red]")
                return False

    @staticmethod
    def set_permissions(
        file_path: Path, permissions: int, use_elevation: bool = False
    ) -> bool:
        """cross-platform permission setting with optional elevation"""
        # try normal chmod first (unless explicitly told to use elevation)
        if not use_elevation:
            try:
                file_path.chmod(permissions)
                console.print(
                    f"[green]✓ restored permissions: {oct(permissions)}[/green]"
                )
                return True
            except PermissionError:
                if platform.system() == "Windows":
                    console.print(
                        "[yellow]windows permission model differs - skipping[/yellow]"
                    )
                    return True  # windows permission model is different
                else:
                    console.print(
                        "[yellow]permission denied - retrying with sudo[/yellow]"
                    )
                    # fall through to elevated chmod below
            except Exception as e:
                console.print(f"[red]permission setting failed: {e}[/red]")
                return False

        # elevated chmod (either requested explicitly or after permission error)
        if platform.system() == "Windows":
            console.print(
                "[yellow]windows elevation for permissions not implemented[/yellow]"
            )
            return True  # windows permission model is different
        else:
            cmd = ["sudo", "chmod", oct(permissions)[2:], str(file_path)]
            try:
                console.print(f"[dim]$ {' '.join(cmd)}[/dim]")
                result = subprocess.run(cmd, capture_output=True, text=True)
                if result.returncode == 0:
                    console.print(
                        f"[green]✓ restored permissions with sudo: {oct(permissions)}[/green]"
                    )
                    return True
                else:
                    console.print(f"[red]sudo chmod failed: {result.stderr}[/red]")
                    return False
            except Exception as e:
                console.print(f"[red]sudo chmod error: {e}[/red]")
                return False


class BackupManager:
    """smart backup management for d0ct0r operations"""

    @staticmethod
    def get_backup_path(file_path: Path) -> Path:
        """get the backup path for a given file"""
        return file_path.with_suffix(file_path.suffix + ".d0ct0r.bak")

    @staticmethod
    def create_backup(
        file_path: Path, force: bool = False, use_elevation: bool = False
    ) -> Path:
        """
        create a backup of the file if it doesn't exist
        returns the backup path
        """
        backup_path = BackupManager.get_backup_path(file_path)

        if backup_path.exists() and not force:
            console.print(f"[yellow]using existing backup: {backup_path.name}[/yellow]")
            return backup_path

        if not file_path.exists():
            raise FileNotFoundError(f"source file not found: {file_path}")

        console.print(
            f"[blue]creating backup: {file_path.name} -> {backup_path.name}[/blue]"
        )

        if not FileOperations.copy_file(file_path, backup_path, use_elevation):
            raise RuntimeError(f"failed to create backup: {backup_path}")

        return backup_path

    @staticmethod
    def should_use_backup(input_path: Path, output_path: Optional[Path] = None) -> bool:
        """
        determine if we should use backup-based workflow
        """
        if output_path is None:
            # in-place modification, definitely use backup
            return True

        if input_path.resolve() == output_path.resolve():
            # same file, use backup
            return True

        return False


class PermissionManager:
    """permission preservation utilities"""

    @staticmethod
    def get_permissions(file_path: Path) -> int:
        """get file permissions"""
        return stat.S_IMODE(file_path.stat().st_mode)

    @staticmethod
    def set_permissions(
        file_path: Path, permissions: int, use_elevation: bool = False
    ) -> bool:
        """set file permissions using file operations"""
        return FileOperations.set_permissions(file_path, permissions, use_elevation)


class CodesignManager:
    """macos codesigning utilities"""

    @staticmethod
    def should_codesign(file_path: Path) -> bool:
        """
        determine if file should be codesigned based on platform and format
        """
        if platform.system() != "Darwin":
            return False

        format_name, is_macho = BinaryFormat.detect_format(file_path)
        return is_macho

    @staticmethod
    def codesign(file_path: Path, sudo: bool = False) -> bool:
        """
        codesign a file with ad-hoc signature
        """
        if not CodesignManager.should_codesign(file_path):
            return True

        cmd = ["codesign", "-fs", "-", str(file_path)]
        if sudo:
            cmd = ["sudo"] + cmd

        try:
            console.print(f"[blue]codesigning: {file_path.name}[/blue]")
            console.print(f"[dim]$ {' '.join(cmd)}[/dim]")
            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode == 0:
                console.print(f"[green]✓ codesigned successfully[/green]")
                return True
            else:
                console.print(f"[red]codesigning failed: {result.stderr}[/red]")
                return False

        except Exception as e:
            console.print(f"[red]codesigning error: {e}[/red]")
            return False


class P1llxRunner:
    """p1llx command execution utilities"""

    @staticmethod
    def find_p1llx() -> Path:
        """find the p1llx executable"""
        script_dir = Path(__file__).parent
        p1llx_path = script_dir.parent / "build-release" / "bin" / "p1llx"

        if not p1llx_path.exists():
            raise FileNotFoundError(f"p1llx not found at {p1llx_path}")

        return p1llx_path

    @staticmethod
    def run_p1llx(cmd_args: List[str], sudo: bool = False) -> bool:
        """
        run p1llx with given arguments
        """
        p1llx_path = P1llxRunner.find_p1llx()
        cmd = [str(p1llx_path)] + cmd_args

        if sudo:
            cmd = ["sudo"] + cmd

        try:
            console.print(f"[dim]$ {' '.join(cmd)}[/dim]")
            result = subprocess.run(cmd, text=True)

            if result.returncode == 0:
                console.print(f"[green]✓ p1llx completed successfully[/green]")
                return True
            else:
                console.print(
                    f"[red]p1llx failed with exit code: {result.returncode}[/red]"
                )
                return False

        except Exception as e:
            console.print(f"[red]p1llx execution error: {e}[/red]")
            return False


class InsertLibraryRunner:
    """w1tool insert-library command execution utilities"""

    @staticmethod
    def find_w1tool() -> Path:
        """find the w1tool executable"""
        script_dir = Path(__file__).parent
        w1tool_path = script_dir.parent / "build-release" / "bin" / "w1tool"

        if not w1tool_path.exists():
            raise FileNotFoundError(f"w1tool not found at {w1tool_path}")

        return w1tool_path

    @staticmethod
    def run_insert_library(cmd_args: List[str], sudo: bool = False) -> bool:
        """
        run w1tool insert-library with given arguments
        """
        w1tool_path = InsertLibraryRunner.find_w1tool()
        cmd = [str(w1tool_path), "insert-library"] + cmd_args

        if sudo:
            cmd = ["sudo"] + cmd

        try:
            console.print(f"[dim]$ {' '.join(cmd)}[/dim]")
            result = subprocess.run(cmd, text=True)

            if result.returncode == 0:
                console.print(f"[green]✓ w1tool insert-library completed successfully[/green]")
                return True
            else:
                console.print(
                    f"[red]w1tool insert-library failed with exit code: {result.returncode}[/red]"
                )
                return False

        except Exception as e:
            console.print(f"[red]w1tool insert-library execution error: {e}[/red]")
            return False


class P01s0nManager:
    """p01s0n.dylib deployment utilities"""

    @staticmethod
    def find_p01s0n_dylib() -> Path:
        """find the p01s0n.dylib library"""
        script_dir = Path(__file__).parent
        p01s0n_path = script_dir.parent / "build-release" / "lib" / "p01s0n.dylib"

        if not p01s0n_path.exists():
            raise FileNotFoundError(f"p01s0n.dylib not found at {p01s0n_path}")

        return p01s0n_path

    @staticmethod
    def deploy_p01s0n(target_binary: Path, use_elevation: bool = False) -> Path:
        """
        deploy p01s0n.dylib next to target binary
        returns the deployed dylib path
        """
        p01s0n_source = P01s0nManager.find_p01s0n_dylib()
        target_dir = target_binary.parent
        p01s0n_target = target_dir / "p01s0n.dylib"

        console.print(f"[blue]deploying p01s0n.dylib to: {target_dir}[/blue]")

        if not FileOperations.copy_file(p01s0n_source, p01s0n_target, use_elevation):
            raise RuntimeError(f"failed to deploy p01s0n.dylib to {p01s0n_target}")

        return p01s0n_target


def setup_logging(verbose: int = 0):
    """setup logging based on verbosity level"""
    levels = [logging.WARNING, logging.INFO, logging.DEBUG]
    level = levels[min(verbose, len(levels) - 1)]

    logging.basicConfig(
        level=level,
        format="%(message)s",
        handlers=[RichHandler(console=console, rich_tracebacks=True)],
    )


@app.callback()
def main_callback(
    sudo: bool = typer.Option(False, "--sudo", help="run p1llx commands with sudo"),
    verbose: int = typer.Option(
        0, "-v", "--verbose", count=True, help="increase verbosity"
    ),
):
    """global options for d0ct0r"""
    global global_sudo, global_verbose
    global_sudo = sudo
    global_verbose = verbose

    setup_logging(verbose)

    if verbose > 0:
        console.print(f"[dim]verbose level: {verbose}[/dim]")
    if sudo:
        console.print(f"[dim]sudo mode enabled[/dim]")


@app.command()
def auto_cure(
    cure_script: str = typer.Option(..., "-c", "--cure", help="lua cure script path"),
    input_file: str = typer.Option(..., "-i", "--input", help="input file path"),
    output_file: Optional[str] = typer.Option(
        None, "-o", "--output", help="output file path"
    ),
    platform_override: Optional[str] = typer.Option(
        None, "-p", "--platform", help="platform override (e.g., darwin:arm64)"
    ),
    no_backup: bool = typer.Option(
        False, "--no-backup", help="disable backup creation"
    ),
):
    """
    static cure patching with automatic backup and codesigning
    """
    setup_logging(global_verbose)

    input_path = Path(input_file)
    output_path = Path(output_file) if output_file else None

    console.print(
        Panel(
            f"[bold]d0ct0r auto-cure[/bold]\n"
            f"input: {input_path.name}\n"
            f"output: {output_path.name if output_path else 'in-place'}\n"
            f"script: {Path(cure_script).name}"
        )
    )

    # validate input file exists
    if not input_path.exists():
        console.print(f"[red]input file not found: {input_path}[/red]")
        raise typer.Exit(1)

    # prevent same input/output
    if output_path and input_path.resolve() == output_path.resolve():
        console.print(f"[red]input and output cannot be the same file[/red]")
        raise typer.Exit(1)

    # detect binary format
    format_name, is_macho = BinaryFormat.detect_format(input_path)
    console.print(f"[cyan]detected format: {format_name}[/cyan]")

    # preserve original permissions
    original_permissions = PermissionManager.get_permissions(input_path)

    # handle backup workflow
    if not no_backup and BackupManager.should_use_backup(input_path, output_path):
        backup_path = BackupManager.create_backup(
            input_path, force=False, use_elevation=global_sudo
        )
        actual_input = backup_path
    else:
        actual_input = input_path

    # build p1llx command
    cmd_args = []
    if global_verbose > 0:
        cmd_args.append("-" + "v" * global_verbose)

    cmd_args.extend(["cure", "-c", cure_script, "-i", str(actual_input)])

    # determine target file and ensure we don't modify backup in-place
    # critical: p1llx modifies input file when no -o is specified!
    # we must always specify -o when using backup to preserve backup integrity
    if output_path:
        cmd_args.extend(["-o", str(output_path)])
        target_file = output_path
    else:
        # in-place modification: always specify output to avoid corrupting backup
        if actual_input != input_path:  # we're using a backup
            cmd_args.extend(
                ["-o", str(input_path)]
            )  # output to original file, preserve backup
            target_file = input_path
        else:
            # no backup workflow, p1llx can modify in-place safely
            target_file = input_path

    if platform_override:
        cmd_args.extend(["-p", platform_override])

    # run p1llx
    if not P1llxRunner.run_p1llx(cmd_args, global_sudo):
        raise typer.Exit(1)

    # codesign if needed
    if not CodesignManager.codesign(target_file, global_sudo):
        console.print(f"[yellow]warning: codesigning failed[/yellow]")

    # restore permissions
    if not PermissionManager.set_permissions(
        target_file, original_permissions, global_sudo
    ):
        console.print(f"[yellow]warning: could not restore permissions[/yellow]")

    console.print(f"[green]✓ auto-cure completed successfully[/green]")


@app.command()
def cure(
    cure_script: str = typer.Option(..., "-c", "--cure", help="lua cure script path"),
    input_file: str = typer.Option(..., "-i", "--input", help="input file path"),
    output_file: Optional[str] = typer.Option(
        None, "-o", "--output", help="output file path"
    ),
    platform_override: Optional[str] = typer.Option(
        None, "-p", "--platform", help="platform override"
    ),
):
    """
    pass-through to p1llx cure with optional enhancements
    """
    cmd_args = []
    if global_verbose > 0:
        cmd_args.append("-" + "v" * global_verbose)

    cmd_args.extend(["cure", "-c", cure_script, "-i", input_file])

    if output_file:
        cmd_args.extend(["-o", output_file])

    if platform_override:
        cmd_args.extend(["-p", platform_override])

    if not P1llxRunner.run_p1llx(cmd_args, global_sudo):
        raise typer.Exit(1)


@app.command()
def patch(
    address: str = typer.Option(..., "--address", help="address to patch (hex)"),
    replace: str = typer.Option(..., "--replace", help="replacement hex bytes"),
    input_file: str = typer.Option(..., "-i", "--input", help="input file path"),
    output_file: Optional[str] = typer.Option(
        None, "-o", "--output", help="output file path"
    ),
):
    """
    pass-through to p1llx patch
    """
    cmd_args = []
    if global_verbose > 0:
        cmd_args.append("-" + "v" * global_verbose)

    cmd_args.extend(
        [
            "patch",
            f"--address={address}",
            f"--replace={replace}",
            "-i",
            input_file,
        ]
    )

    if output_file:
        cmd_args.extend(["-o", output_file])

    if not P1llxRunner.run_p1llx(cmd_args, global_sudo):
        raise typer.Exit(1)


@app.command()
def poison(
    cure_script: str = typer.Option(..., "-c", "--cure", help="lua cure script path"),
    spawn: bool = typer.Option(False, "-s", "--spawn", help="spawn target binary"),
    pid: Optional[int] = typer.Option(None, "--pid", help="target process pid"),
    process_name: Optional[str] = typer.Option(
        None, "--process-name", help="target process name"
    ),
    suspended: bool = typer.Option(
        False, "--suspended", help="start in suspended mode"
    ),
    args: Optional[List[str]] = typer.Argument(
        None, help="target binary and arguments"
    ),
):
    """
    pass-through to p1llx poison for dynamic patching
    """
    cmd_args = []
    if global_verbose > 0:
        cmd_args.append("-" + "v" * global_verbose)

    cmd_args.extend(["poison", "-c", cure_script])

    # target specification
    if spawn:
        cmd_args.append("-s")
    elif pid:
        cmd_args.extend(["--pid", str(pid)])
    elif process_name:
        cmd_args.extend(["--process-name", process_name])
    else:
        console.print(
            "[red]must specify target: --spawn, --pid, or --process-name[/red]"
        )
        raise typer.Exit(1)

    if suspended:
        cmd_args.append("--suspended")

    if args:
        cmd_args.extend(args)

    if not P1llxRunner.run_p1llx(cmd_args, global_sudo):
        raise typer.Exit(1)


@app.command()
def insert_poison(
    input_file: str = typer.Option(..., "-i", "--input", help="input file path"),
    output_file: Optional[str] = typer.Option(
        None, "-o", "--output", help="output file path"
    ),
    poison_lib: Optional[str] = typer.Option(
        None,
        "-L",
        "--poison-lib",
        help="custom dylib to inject (default: p01s0n.dylib)",
    ),
    no_backup: bool = typer.Option(
        False, "--no-backup", help="disable backup creation"
    ),
):
    """
    insert p01s0n dylib into import table of target binary
    """
    setup_logging(global_verbose)

    # check platform
    if platform.system() != "Darwin":
        console.print(f"[red]insert-poison is only supported on macOS[/red]")
        raise typer.Exit(1)

    input_path = Path(input_file)
    output_path = Path(output_file) if output_file else None

    # determine dylib to inject
    if poison_lib:
        poison_lib_path = Path(poison_lib)
        if not poison_lib_path.exists():
            console.print(f"[red]custom poison library not found: {poison_lib}[/red]")
            raise typer.Exit(1)
        dylib_name = poison_lib_path.name
        dylib_import_path = f"@executable_path/{dylib_name}"
        use_custom_lib = True
    else:
        # default to p01s0n.dylib
        dylib_name = "p01s0n.dylib"
        dylib_import_path = "@executable_path/p01s0n.dylib"
        use_custom_lib = False

    console.print(
        Panel(
            f"[bold]d0ct0r insert-poison[/bold]\n"
            f"input: {input_path.name}\n"
            f"output: {output_path.name if output_path else 'in-place'}\n"
            f"poison lib: {dylib_name}\n"
            f"method: import table modification + dylib deployment"
        )
    )

    # validate input file exists
    if not input_path.exists():
        console.print(f"[red]input file not found: {input_path}[/red]")
        raise typer.Exit(1)

    # prevent same input/output
    if output_path and input_path.resolve() == output_path.resolve():
        console.print(f"[red]input and output cannot be the same file[/red]")
        raise typer.Exit(1)

    # detect binary format - must be mach-o
    format_name, is_macho = BinaryFormat.detect_format(input_path)
    console.print(f"[cyan]detected format: {format_name}[/cyan]")

    if not is_macho:
        console.print(
            f"[red]insert-poison requires mach-o binary, got: {format_name}[/red]"
        )
        raise typer.Exit(1)

    # preserve original permissions
    original_permissions = PermissionManager.get_permissions(input_path)

    # handle backup workflow
    if not no_backup and BackupManager.should_use_backup(input_path, output_path):
        backup_path = BackupManager.create_backup(
            input_path, force=False, use_elevation=global_sudo
        )
        actual_input = backup_path
    else:
        actual_input = input_path

    # determine target file
    if output_path:
        target_file = output_path
    else:
        target_file = input_path

    # build w1tool insert-library command
    # format: w1tool insert-library [flags] dylib_path binary_path [output_path]
    cmd_args = []

    # add w1tool insert-library specific flags
    cmd_args.extend(["--strip-codesig", "--all-yes"])  # auto-answer prompts

    # for in-place modification, we need to be careful with the workflow
    if output_path:
        # explicit output path - straightforward
        cmd_args.extend([dylib_import_path, str(actual_input), str(output_path)])
    else:
        # in-place modification: work from backup to original location
        cmd_args.extend(
            [
                "--overwrite",  # allow overwriting existing file
                dylib_import_path,
                str(actual_input),
                str(target_file),  # output back to original location
            ]
        )

    # run w1tool insert-library
    if not InsertLibraryRunner.run_insert_library(cmd_args, global_sudo):
        raise typer.Exit(1)

    # deploy dylib next to target binary
    try:
        if use_custom_lib:
            # deploy custom dylib
            target_dir = target_file.parent
            dylib_target = target_dir / dylib_name
            console.print(f"[blue]deploying custom dylib to: {target_dir}[/blue]")
            if not FileOperations.copy_file(poison_lib_path, dylib_target, global_sudo):
                raise RuntimeError(f"failed to deploy {dylib_name} to {dylib_target}")
            deployed_dylib = dylib_target
        else:
            # deploy default p01s0n.dylib
            deployed_dylib = P01s0nManager.deploy_p01s0n(target_file, global_sudo)

        console.print(f"[green]✓ deployed dylib: {deployed_dylib.name}[/green]")
    except Exception as e:
        console.print(f"[red]failed to deploy dylib: {e}[/red]")
        raise typer.Exit(1)

    # codesign if needed
    if not CodesignManager.codesign(target_file, global_sudo):
        console.print(f"[yellow]warning: codesigning failed[/yellow]")

    # restore permissions
    if not PermissionManager.set_permissions(
        target_file, original_permissions, global_sudo
    ):
        console.print(f"[yellow]warning: could not restore permissions[/yellow]")

    console.print(f"[green]✓ insert-poison completed successfully[/green]")
    console.print(
        f"[dim]note: binary now loads {dylib_name} from {dylib_import_path}[/dim]"
    )


if __name__ == "__main__":
    app()

```

`scripts/p1ll/string_patch.js`:

```js
// some sample signatures with region filters
var SIG_DEMO_VERSION =
    p1.sig(p1.str2hex('DEMO VERSION'), {filter: 'p1ll_test_target'});
var SIG_TRIAL_VERSION =
    p1.sig(p1.str2hex('TRIAL VERSION'), {filter: 'p1ll_test_target'});

var meta = {
  name: 'string_patch',
  // supported platforms
  platforms: ['darwin:arm64', 'linux:x64', 'windows:x64'],

  // all matching sigs must match in order for cure to be applicable
  sigs: {
    // wildcards match all platforms
    '*': [SIG_DEMO_VERSION, SIG_TRIAL_VERSION]
  },

  // patches to apply if all sigs match
  patches: {
    // wildcard patches are used on all platforms
    '*': [ // a patch declares a signature, an offset, a replacement, and optional parameters
      p1.patch(SIG_DEMO_VERSION, 0, p1.str2hex('OOPS VERSION')), 
      p1.patch(SIG_TRIAL_VERSION, 0, p1.str2hex('SILLY VER'))
    ]
  }
};

// the cure function is called by the p1ll framework
function cure() {
  // use the mostly declarative auto cure api
  return p1.auto_cure(meta);
}

```

`scripts/p1ll/string_patch.lua`:

```lua
-- some sample signatures with region filters
local SIG_DEMO_VERSION = p1.sig(p1.str2hex("DEMO VERSION"), {filter = "p1ll_test_target"})
local SIG_TRIAL_VERSION = p1.sig(p1.str2hex("TRIAL VERSION"), {filter = "p1ll_test_target"})

local meta = {
    name = "string_patch",
    -- supported platforms
    platforms = {"darwin:arm64", "linux:x64", "windows:x64"},

    -- all matching sigs must match in order for cure to be applicable
    sigs = {
        -- wildcards match all platforms
        ["*"] = {SIG_DEMO_VERSION, SIG_TRIAL_VERSION}
    },

    -- patches to apply if all sigs match
    patches = {
        -- wildcard patches are used on all platforms
        ["*"] = { -- a patch declares a signature, an offset, a replacement, and optional parameters
        p1.patch(SIG_DEMO_VERSION, 0, p1.str2hex("OOPS VERSION")), 
        p1.patch(SIG_TRIAL_VERSION, 0, p1.str2hex("SILLY VER"))}
    }
}

-- the cure function is called by the p1ll framework
function cure()
    -- use the mostly declarative auto cure api
    return p1.auto_cure(meta)
end

```

`scripts/python/p1ll_patch.py`:

```py
#!/usr/bin/env python3

import argparse
import sys
from typing import Optional, Tuple

import p1ll


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Patch a file or buffer using p1ll signatures"
    )

    source = parser.add_mutually_exclusive_group(required=True)
    source.add_argument("--input", help="path to binary/file to patch")
    source.add_argument("--data-hex", help="hex bytes to patch (e.g. '90 90 cc 90')")
    source.add_argument("--data-text", help="raw text to patch (utf-8)")

    dest = parser.add_mutually_exclusive_group()
    dest.add_argument("--output", help="output path for patched file")
    dest.add_argument("--inplace", action="store_true", help="overwrite input file")

    pattern = parser.add_mutually_exclusive_group(required=True)
    pattern.add_argument("--pattern", help="hex signature pattern")
    pattern.add_argument("--pattern-text", help="ASCII text to convert to hex pattern")

    patch = parser.add_mutually_exclusive_group(required=True)
    patch.add_argument("--patch", help="hex patch bytes")
    patch.add_argument("--patch-text", help="ASCII text to convert to hex patch")

    parser.add_argument("--offset", type=int, default=0)

    parser.add_argument("--single", dest="single", action="store_true")
    parser.add_argument("--no-single", dest="single", action="store_false")
    parser.set_defaults(single=True)

    parser.add_argument("--max-matches", type=int, default=0)

    parser.add_argument(
        "--validate", action="append", default=[], help="hex validation pattern"
    )
    parser.add_argument(
        "--validate-text", action="append", default=[], help="text validation pattern"
    )

    parser.add_argument(
        "--platform", help="platform override for buffer sessions (e.g. linux:x64)"
    )
    parser.add_argument("--recipe-name", default="python-patch")

    parser.add_argument("--verify", dest="verify", action="store_true")
    parser.add_argument("--no-verify", dest="verify", action="store_false")
    parser.set_defaults(verify=True)

    parser.add_argument("--flush-icache", dest="flush_icache", action="store_true")
    parser.add_argument("--no-flush-icache", dest="flush_icache", action="store_false")
    parser.set_defaults(flush_icache=True)

    parser.add_argument("--rollback", dest="rollback", action="store_true")
    parser.add_argument("--no-rollback", dest="rollback", action="store_false")
    parser.set_defaults(rollback=True)

    parser.add_argument("--allow-wx", action="store_true")

    parser.add_argument("--show-bytes", action="store_true")
    parser.add_argument("--show-max", type=int, default=64)

    return parser.parse_args()


def decode_hex_data(value: str) -> bytes:
    normalized = p1ll.utils.normalize_hex_pattern(value)
    if "?" in normalized:
        raise ValueError("data hex cannot include wildcards ('??')")
    if not normalized:
        raise ValueError("data hex is empty")
    return bytes.fromhex(normalized)


def load_data(args: argparse.Namespace) -> Tuple[p1ll.Session, bytes, str]:
    if args.input:
        data = p1ll.utils.read_file(args.input)
        if data is None:
            raise ValueError("failed to read file: {}".format(args.input))
        label = args.input
    elif args.data_hex:
        data = decode_hex_data(args.data_hex)
        label = "hex-buffer"
    else:
        data = args.data_text.encode("utf-8")
        label = "text-buffer"

    if args.platform:
        return p1ll.Session.for_buffer(data, args.platform), data, label
    return p1ll.Session.for_buffer(data), data, label


def build_pattern(hex_value: Optional[str], text_value: Optional[str]) -> str:
    if text_value is not None:
        return p1ll.utils.str2hex(text_value)
    return hex_value or ""


def add_validations(recipe: p1ll.Recipe, args: argparse.Namespace) -> None:
    patterns = []
    patterns.extend(args.validate)
    patterns.extend(p1ll.utils.str2hex(text) for text in args.validate_text)

    for pattern in patterns:
        sig = p1ll.SignatureSpec()
        sig.pattern = pattern
        sig.options = p1ll.ScanOptions()
        sig.options.single = args.single
        sig.options.max_matches = args.max_matches
        sig.required = True
        recipe.validations.append(sig)


def summarize_bytes(data: bytes, max_bytes: int) -> str:
    if len(data) <= max_bytes:
        return data.hex()
    prefix = data[:max_bytes].hex()
    return "{}...(+{} bytes)".format(prefix, len(data) - max_bytes)


def main() -> int:
    try:
        args = parse_args()

        if args.inplace and not args.input:
            raise ValueError("--inplace is only valid with --input")
        if args.output and not args.input:
            raise ValueError("--output is only valid with --input")
        if args.input and not (args.output or args.inplace):
            raise ValueError("--output or --inplace is required when using --input")

        sess, original_data, label = load_data(args)
    except ValueError as exc:
        print("error: {}".format(exc), file=sys.stderr)
        return 2

    recipe = p1ll.Recipe()
    recipe.name = args.recipe_name

    sig = p1ll.SignatureSpec()
    sig.pattern = build_pattern(args.pattern, args.pattern_text)
    sig.options = p1ll.ScanOptions()
    sig.options.single = args.single
    sig.options.max_matches = args.max_matches
    sig.required = True

    patch = p1ll.PatchSpec()
    patch.signature = sig
    patch.offset = args.offset
    patch.patch = build_pattern(args.patch, args.patch_text)
    patch.required = True

    recipe.patches = [patch]
    add_validations(recipe, args)

    apply_options = p1ll.ApplyOptions()
    apply_options.verify = args.verify
    apply_options.flush_icache = args.flush_icache
    apply_options.rollback_on_failure = args.rollback
    apply_options.allow_wx = args.allow_wx

    if args.show_bytes:
        print("before:", summarize_bytes(original_data, args.show_max))

    plan = sess.plan(recipe)
    report = sess.apply(plan, apply_options)

    if args.show_bytes:
        print("after:", summarize_bytes(sess.buffer_bytes(), args.show_max))

    if args.input:
        output_path = args.output if args.output else args.input
        if not p1ll.utils.write_file(output_path, sess.buffer_bytes()):
            print(
                "error: failed to write file: {}".format(output_path), file=sys.stderr
            )
            return 1
        print("output: {}".format(output_path))

    print(
        "source: {} applied: {} failed: {} success: {}".format(
            label, report.applied, report.failed, report.success
        )
    )

    return 0


if __name__ == "__main__":
    raise SystemExit(main())

```

`scripts/python/p1ll_regions.py`:

```py
#!/usr/bin/env python3

import argparse

import p1ll


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="List regions from the current process using p1ll"
    )
    parser.add_argument("--name-regex", default="")
    parser.add_argument("--only-executable", action="store_true")
    parser.add_argument("--exclude-system", action="store_true")
    parser.add_argument("--min-size", type=int, default=0)
    parser.add_argument("--min-address", type=lambda v: int(v, 0))
    parser.add_argument("--max-address", type=lambda v: int(v, 0))
    parser.add_argument("--limit", type=int, default=10)
    parser.add_argument("--all", action="store_true")
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    sess = p1ll.Session.for_process()

    scan_filter = p1ll.ScanFilter()
    scan_filter.name_regex = args.name_regex
    scan_filter.only_executable = args.only_executable
    scan_filter.exclude_system = args.exclude_system
    scan_filter.min_size = args.min_size
    if args.min_address is not None:
        scan_filter.min_address = args.min_address
    if args.max_address is not None:
        scan_filter.max_address = args.max_address

    regions = sess.regions(scan_filter)
    print("regions:", len(regions))

    limit = None if args.all else args.limit
    for idx, region in enumerate(regions):
        if limit is not None and idx >= limit:
            break
        base = p1ll.utils.format_address(region.base_address)
        name = region.name or "[anonymous]"
        print(
            "{}: base={} size={} perms={} name={}".format(
                idx, base, region.size, region.protection, name
            )
        )

    return 0


if __name__ == "__main__":
    raise SystemExit(main())

```

`scripts/python/p1ll_scan.py`:

```py
#!/usr/bin/env python3

import argparse
import sys
from typing import Tuple

import p1ll


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Scan a file, buffer, or current process using p1ll patterns"
    )

    source = parser.add_mutually_exclusive_group(required=True)
    source.add_argument("--input", help="path to a binary/file to scan")
    source.add_argument("--data-hex", help="hex bytes to scan (e.g. '90 90 cc 90')")
    source.add_argument("--data-text", help="raw text to scan (utf-8)")
    source.add_argument(
        "--process", action="store_true", help="scan the current process"
    )

    pattern = parser.add_mutually_exclusive_group(required=True)
    pattern.add_argument("--pattern", help="hex signature pattern")
    pattern.add_argument("--pattern-text", help="ASCII text to convert to hex pattern")

    parser.add_argument("--single", dest="single", action="store_true")
    parser.add_argument("--no-single", dest="single", action="store_false")
    parser.set_defaults(single=False)

    parser.add_argument("--max-matches", type=int, default=0)

    parser.add_argument("--name-regex", default="")
    parser.add_argument("--only-executable", action="store_true")
    parser.add_argument("--exclude-system", action="store_true")
    parser.add_argument("--min-size", type=int, default=0)
    parser.add_argument("--min-address", type=lambda v: int(v, 0))
    parser.add_argument("--max-address", type=lambda v: int(v, 0))

    parser.add_argument(
        "--platform", help="platform override for buffer sessions (e.g. linux:x64)"
    )

    return parser.parse_args()


def build_pattern(args: argparse.Namespace) -> str:
    if args.pattern_text:
        return p1ll.utils.str2hex(args.pattern_text)
    return args.pattern


def decode_hex_data(value: str) -> bytes:
    normalized = p1ll.utils.normalize_hex_pattern(value)
    if "?" in normalized:
        raise ValueError("data hex cannot include wildcards ('??')")
    if not normalized:
        raise ValueError("data hex is empty")
    return bytes.fromhex(normalized)


def load_data(args: argparse.Namespace) -> Tuple[p1ll.Session, str]:
    if args.process:
        if args.platform:
            raise ValueError("--platform is only valid for buffer sessions")
        return p1ll.Session.for_process(), "process"

    if args.input:
        data = p1ll.utils.read_file(args.input)
        if data is None:
            raise ValueError("failed to read file: {}".format(args.input))
        label = args.input
    elif args.data_hex:
        data = decode_hex_data(args.data_hex)
        label = "hex-buffer"
    else:
        data = args.data_text.encode("utf-8")
        label = "text-buffer"

    if args.platform:
        return p1ll.Session.for_buffer(data, args.platform), label
    return p1ll.Session.for_buffer(data), label


def main() -> int:
    try:
        args = parse_args()
        sess, label = load_data(args)
    except ValueError as exc:
        print("error: {}".format(exc), file=sys.stderr)
        return 2

    options = p1ll.ScanOptions()
    options.single = args.single
    options.max_matches = args.max_matches

    scan_filter = p1ll.ScanFilter()
    scan_filter.name_regex = args.name_regex
    scan_filter.only_executable = args.only_executable
    scan_filter.exclude_system = args.exclude_system
    scan_filter.min_size = args.min_size
    if args.min_address is not None:
        scan_filter.min_address = args.min_address
    if args.max_address is not None:
        scan_filter.max_address = args.max_address
    options.filter = scan_filter

    pattern = build_pattern(args)
    results = sess.scan(pattern, options)

    print("source: {}".format(label))
    print("matches: {}".format(len(results)))
    for idx, result in enumerate(results):
        addr = p1ll.utils.format_address(result.address)
        name = result.region_name or "[anonymous]"
        print("{}: addr={} region={}".format(idx, addr, name))

    return 0


if __name__ == "__main__":
    raise SystemExit(main())

```

`scripts/w1dump.py`:

```py
#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.8"
# dependencies = [
#     "msgpack",
# ]
# ///
"""
read_w1dump.py - a standalone script to read and parse w1dump files
supports x86, x86_64, and arm64 architectures with proper GPRState handling

can be used as both a command-line tool and a python module:

as a tool:
    ./scripts/read_w1dump.py dump.w1dump              # full analysis
    ./scripts/read_w1dump.py dump.w1dump --summary    # summary only
    ./scripts/read_w1dump.py dump.w1dump --full       # show all memory regions

as a module:
    from read_w1dump import load_dump, W1Dump

    dump = load_dump("process.w1dump")
    print(f"process: {dump.metadata.process_name}")
    print(f"pc: {dump.thread.gpr_state.pc:016x}")

    # find module at address
    module = dump.get_module_at(dump.thread.gpr_state.pc)
    if module:
        print(f"executing in: {module.name}")
"""

import json
import struct
import sys
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Union, Any
from pathlib import Path
from enum import IntEnum
import msgpack


# public API exports
__all__ = [
    # main functions
    "load_dump",
    "export_dump",
    # core classes
    "W1Dump",
    "DumpMetadata",
    "ThreadState",
    "MemoryRegion",
    "ModuleInfo",
    # architecture states
    "GPRState_x86_64",
    "GPRState_x86",
    "GPRState_arm64",
    "GPRStateBase",
    # enums
    "MemoryPermissions",
    # constants
    "SUPPORTED_ARCHITECTURES",
]


# architecture registry for extensibility
SUPPORTED_ARCHITECTURES = {
    "x86_64": {"pointer_size": 8, "gpr_count": 20},
    "x86": {"pointer_size": 4, "gpr_count": 10},
    "arm64": {"pointer_size": 8, "gpr_count": 36},
    "aarch64": {"pointer_size": 8, "gpr_count": 36},  # alias for arm64
}


# base class for GPR states
@dataclass
class GPRStateBase:
    """base class for architecture-specific GPR states"""

    @classmethod
    def from_values(cls, values: List[int]):
        """create from list of values in QBDI order"""
        raise NotImplementedError("subclasses must implement from_values")

    @property
    def pc(self) -> int:
        """get program counter value"""
        raise NotImplementedError("subclasses must implement pc property")

    @property
    def sp(self) -> int:
        """get stack pointer value"""
        raise NotImplementedError("subclasses must implement sp property")


# architecture-specific GPRState definitions
@dataclass
class GPRState_x86_64(GPRStateBase):
    """x86_64 general purpose register state"""

    rax: int = 0
    rbx: int = 0
    rcx: int = 0
    rdx: int = 0
    rsi: int = 0
    rdi: int = 0
    r8: int = 0
    r9: int = 0
    r10: int = 0
    r11: int = 0
    r12: int = 0
    r13: int = 0
    r14: int = 0
    r15: int = 0
    rbp: int = 0
    rsp: int = 0
    rip: int = 0
    eflags: int = 0
    fs: int = 0
    gs: int = 0

    @classmethod
    def from_values(cls, values: List[int]) -> "GPRState_x86_64":
        """create from list of values in QBDI order"""
        if len(values) < 18:
            raise ValueError(
                f"Expected at least 18 values for x86_64, got {len(values)}"
            )
        return cls(
            rax=values[0],
            rbx=values[1],
            rcx=values[2],
            rdx=values[3],
            rsi=values[4],
            rdi=values[5],
            r8=values[6],
            r9=values[7],
            r10=values[8],
            r11=values[9],
            r12=values[10],
            r13=values[11],
            r14=values[12],
            r15=values[13],
            rbp=values[14],
            rsp=values[15],
            rip=values[16],
            eflags=values[17],
            fs=values[18] if len(values) > 18 else 0,
            gs=values[19] if len(values) > 19 else 0,
        )

    def __str__(self) -> str:
        lines = []
        lines.append(
            f"rax = {self.rax:016x}  rbx = {self.rbx:016x}  rcx = {self.rcx:016x}  rdx = {self.rdx:016x}"
        )
        lines.append(
            f"rsi = {self.rsi:016x}  rdi = {self.rdi:016x}  r8  = {self.r8:016x}  r9  = {self.r9:016x}"
        )
        lines.append(
            f"r10 = {self.r10:016x}  r11 = {self.r11:016x}  r12 = {self.r12:016x}  r13 = {self.r13:016x}"
        )
        lines.append(
            f"r14 = {self.r14:016x}  r15 = {self.r15:016x}  rbp = {self.rbp:016x}  rsp = {self.rsp:016x}"
        )
        lines.append(f"rip = {self.rip:016x}  eflags = {self.eflags:08x}")
        if self.fs or self.gs:
            lines.append(f"fs  = {self.fs:016x}  gs  = {self.gs:016x}")
        return "\n".join(lines)

    @property
    def pc(self) -> int:
        """get program counter value"""
        return self.rip

    @property
    def sp(self) -> int:
        """get stack pointer value"""
        return self.rsp


@dataclass
class GPRState_x86(GPRStateBase):
    """x86 (32-bit) general purpose register state"""

    eax: int = 0
    ebx: int = 0
    ecx: int = 0
    edx: int = 0
    esi: int = 0
    edi: int = 0
    ebp: int = 0
    esp: int = 0
    eip: int = 0
    eflags: int = 0

    @classmethod
    def from_values(cls, values: List[int]) -> "GPRState_x86":
        """create from list of values in QBDI order"""
        if len(values) < 10:
            raise ValueError(f"Expected at least 10 values for x86, got {len(values)}")
        return cls(
            eax=values[0],
            ebx=values[1],
            ecx=values[2],
            edx=values[3],
            esi=values[4],
            edi=values[5],
            ebp=values[6],
            esp=values[7],
            eip=values[8],
            eflags=values[9],
        )

    def __str__(self) -> str:
        lines = []
        lines.append(
            f"eax = {self.eax:08x}  ebx = {self.ebx:08x}  ecx = {self.ecx:08x}  edx = {self.edx:08x}"
        )
        lines.append(
            f"esi = {self.esi:08x}  edi = {self.edi:08x}  ebp = {self.ebp:08x}  esp = {self.esp:08x}"
        )
        lines.append(f"eip = {self.eip:08x}  eflags = {self.eflags:08x}")
        return "\n".join(lines)

    @property
    def pc(self) -> int:
        """get program counter value"""
        return self.eip

    @property
    def sp(self) -> int:
        """get stack pointer value"""
        return self.esp


@dataclass
class LocalMonitor:
    """arm64 local monitor state for exclusive load/store"""

    addr: int = 0
    enable: int = 0


@dataclass
class GPRState_arm64(GPRStateBase):
    """arm64 (aarch64) general purpose register state"""

    x0: int = 0
    x1: int = 0
    x2: int = 0
    x3: int = 0
    x4: int = 0
    x5: int = 0
    x6: int = 0
    x7: int = 0
    x8: int = 0
    x9: int = 0
    x10: int = 0
    x11: int = 0
    x12: int = 0
    x13: int = 0
    x14: int = 0
    x15: int = 0
    x16: int = 0
    x17: int = 0
    x18: int = 0
    x19: int = 0
    x20: int = 0
    x21: int = 0
    x22: int = 0
    x23: int = 0
    x24: int = 0
    x25: int = 0
    x26: int = 0
    x27: int = 0
    x28: int = 0
    x29: int = 0  # FP
    lr: int = 0  # x30
    sp: int = 0
    nzcv: int = 0
    pc: int = 0
    local_monitor: LocalMonitor = field(default_factory=LocalMonitor)

    @classmethod
    def from_values(cls, values: List[int]) -> "GPRState_arm64":
        """create from list of values in QBDI order"""
        if len(values) < 34:
            raise ValueError(
                f"Expected at least 34 values for arm64, got {len(values)}"
            )

        instance = cls(
            x0=values[0],
            x1=values[1],
            x2=values[2],
            x3=values[3],
            x4=values[4],
            x5=values[5],
            x6=values[6],
            x7=values[7],
            x8=values[8],
            x9=values[9],
            x10=values[10],
            x11=values[11],
            x12=values[12],
            x13=values[13],
            x14=values[14],
            x15=values[15],
            x16=values[16],
            x17=values[17],
            x18=values[18],
            x19=values[19],
            x20=values[20],
            x21=values[21],
            x22=values[22],
            x23=values[23],
            x24=values[24],
            x25=values[25],
            x26=values[26],
            x27=values[27],
            x28=values[28],
            x29=values[29],
            lr=values[30],
            sp=values[31],
            nzcv=values[32],
            pc=values[33],
        )

        # handle local monitor if present
        if len(values) >= 36:
            instance.local_monitor = LocalMonitor(addr=values[34], enable=values[35])

        return instance

    def __str__(self) -> str:
        lines = []
        # general purpose registers in neat rows
        for i in range(0, 28, 4):
            parts = []
            for j in range(4):
                if i + j < 28:
                    reg_val = getattr(self, f"x{i+j}")
                    parts.append(f"x{i+j:<2} = {reg_val:016x}")
            lines.append("  ".join(parts))

        # special registers
        lines.append(f"x28 = {self.x28:016x}  x29 = {self.x29:016x}")
        lines.append(f"x30 = {self.lr:016x}  sp  = {self.sp:016x}")
        lines.append(f"pc  = {self.pc:016x}  nzcv = {self.nzcv:08x}")

        # local monitor if enabled
        if self.local_monitor.enable:
            lines.append(f"local monitor: addr={self.local_monitor.addr:016x}")

        return "\n".join(lines)


# core dump data structures
@dataclass
class DumpMetadata:
    """dump file metadata"""

    version: int = 1
    timestamp: int = 0
    os: str = ""
    arch: str = ""
    pointer_size: int = 8
    pid: int = 0
    process_name: str = ""


@dataclass
class ThreadState:
    """thread state with registers"""

    thread_id: int
    gpr_values: List[int]
    fpr_values: List[int]
    gpr_state: Optional[Union[GPRState_x86, GPRState_x86_64, GPRState_arm64]] = None

    def __post_init__(self):
        """parse GPR values based on architecture (set later)"""
        pass


class MemoryPermissions(IntEnum):
    """qbdi memory permission flags"""

    NONE = 0
    READ = 1
    WRITE = 2
    EXEC = 4


@dataclass
class MemoryRegion:
    """memory region information"""

    start: int
    end: int
    permissions: int
    module_name: str = ""
    is_stack: bool = False
    is_code: bool = False
    is_data: bool = False
    is_anonymous: bool = False
    data: Optional[bytes] = None

    @property
    def size(self) -> int:
        return self.end - self.start

    @property
    def perms_str(self) -> str:
        """get permissions as readable string"""
        perms = []
        if self.permissions & MemoryPermissions.READ:
            perms.append("r")
        else:
            perms.append("-")
        if self.permissions & MemoryPermissions.WRITE:
            perms.append("w")
        else:
            perms.append("-")
        if self.permissions & MemoryPermissions.EXEC:
            perms.append("x")
        else:
            perms.append("-")
        return "".join(perms)

    def __str__(self) -> str:
        flags = []
        if self.is_stack:
            flags.append("STACK")
        if self.is_code:
            flags.append("CODE")
        if self.is_data:
            flags.append("DATA")
        if self.is_anonymous:
            flags.append("ANON")

        flag_str = f" [{', '.join(flags)}]" if flags else ""
        module_str = f" ({self.module_name})" if self.module_name else ""

        return f"{self.start:016x}-{self.end:016x} {self.perms_str} {self.size:10} bytes{module_str}{flag_str}"


@dataclass
class ModuleInfo:
    """module/library information"""

    path: str
    name: str
    base_address: int
    size: int
    type: str
    is_system_library: bool
    permissions: int

    def __str__(self) -> str:
        system_str = " [SYSTEM]" if self.is_system_library else ""
        return f"{self.base_address:016x} {self.size:10} bytes {self.name} ({self.type}){system_str}"


@dataclass
class W1Dump:
    """complete w1dump structure"""

    metadata: DumpMetadata
    thread: ThreadState
    regions: List[MemoryRegion]
    modules: List[ModuleInfo]

    def __post_init__(self):
        """parse architecture-specific data after initialization"""
        # normalize architecture name
        arch = self.metadata.arch.lower()
        if arch == "aarch64":
            arch = "arm64"  # normalize aarch64 to arm64

        # validate architecture
        if arch not in SUPPORTED_ARCHITECTURES:
            import warnings

            warnings.warn(
                f"unknown architecture '{self.metadata.arch}', supported: {list(SUPPORTED_ARCHITECTURES.keys())}"
            )
            return

        # validate pointer size
        expected_ptr_size = SUPPORTED_ARCHITECTURES[arch]["pointer_size"]
        if self.metadata.pointer_size != expected_ptr_size:
            import warnings

            warnings.warn(
                f"unexpected pointer size {self.metadata.pointer_size} for {arch}, expected {expected_ptr_size}"
            )

        # parse GPR state based on architecture
        try:
            if arch == "x86_64":
                self.thread.gpr_state = GPRState_x86_64.from_values(
                    self.thread.gpr_values
                )
            elif arch == "x86":
                self.thread.gpr_state = GPRState_x86.from_values(self.thread.gpr_values)
            elif arch == "arm64":
                self.thread.gpr_state = GPRState_arm64.from_values(
                    self.thread.gpr_values
                )
        except ValueError as e:
            import warnings

            warnings.warn(f"failed to parse GPR state: {e}")

    def get_module_at(self, address: int) -> Optional[ModuleInfo]:
        """find module containing the given address"""
        for module in self.modules:
            if module.base_address <= address < module.base_address + module.size:
                return module
        return None

    def get_region_at(self, address: int) -> Optional[MemoryRegion]:
        """find memory region containing the given address"""
        for region in self.regions:
            if region.start <= address < region.end:
                return region
        return None

    def get_stack_regions(self) -> List[MemoryRegion]:
        """get all stack regions"""
        return [r for r in self.regions if r.is_stack]

    def get_code_regions(self) -> List[MemoryRegion]:
        """get all code regions"""
        return [r for r in self.regions if r.is_code]

    def get_module_regions(self, module_name: str) -> List[MemoryRegion]:
        """get all regions belonging to a specific module"""
        return [r for r in self.regions if r.module_name == module_name]

    def read_memory(self, address: int, size: int) -> Optional[bytes]:
        """read memory from dump if available"""
        region = self.get_region_at(address)
        if not region or not region.data:
            return None

        # calculate offset within region
        offset = address - region.start
        if offset + size > len(region.data):
            return None

        return region.data[offset : offset + size]

    @property
    def main_module(self) -> Optional[ModuleInfo]:
        """get the main executable module"""
        for module in self.modules:
            if module.type == "main_executable":
                return module
        return None

    def print_summary(self):
        """print a summary of the dump"""
        from datetime import datetime, timezone

        # use unicode box drawing chars that work cross-platform
        print("=" * 60)
        print("w1dump analysis")
        print("=" * 60)

        # process info
        print(f"process:      {self.metadata.process_name} (pid: {self.metadata.pid})")
        print(
            f"architecture: {self.metadata.arch} ({self.metadata.pointer_size * 8}-bit)"
        )
        print(f"platform:     {self.metadata.os}")

        # timestamp - handle milliseconds properly
        if self.metadata.timestamp > 0:
            # convert milliseconds to seconds for timestamp
            dt = datetime.fromtimestamp(
                self.metadata.timestamp / 1000.0, tz=timezone.utc
            )
            # format in local time
            print(f"captured:     {dt.astimezone().strftime('%Y-%m-%d %H:%M:%S %Z')}")

        print(f"thread id:    {self.thread.thread_id}")
        print()

        # stats
        print("statistics:")
        print(f"  modules:         {len(self.modules):4d}")
        print(f"  memory regions:  {len(self.regions):4d}")

        # calculate memory stats
        total_size = sum(r.size for r in self.regions)
        code_size = sum(r.size for r in self.regions if r.is_code)
        data_size = sum(r.size for r in self.regions if r.is_data)
        stack_size = sum(r.size for r in self.regions if r.is_stack)
        anon_size = sum(r.size for r in self.regions if r.is_anonymous)

        def format_size(size):
            """format size in human readable form"""
            for unit in ["B", "KB", "MB", "GB"]:
                if size < 1024.0:
                    return f"{size:6.1f} {unit}"
                size /= 1024.0
            return f"{size:6.1f} TB"

        print()
        print("memory breakdown:")
        print(f"  total:      {format_size(total_size):>12} ({total_size:,} bytes)")
        print(f"  code:       {format_size(code_size):>12} ({code_size:,} bytes)")
        print(f"  data:       {format_size(data_size):>12} ({data_size:,} bytes)")
        print(f"  stack:      {format_size(stack_size):>12} ({stack_size:,} bytes)")
        print(f"  anonymous:  {format_size(anon_size):>12} ({anon_size:,} bytes)")

    def print_registers(self):
        """print register state"""
        print()
        print("-" * 60)
        print("registers")
        print("-" * 60)
        if self.thread.gpr_state:
            print(self.thread.gpr_state)
        else:
            print("no parsed GPR state available")

    def print_modules(self):
        """print loaded modules"""
        print()
        print("-" * 60)
        print(f"modules ({len(self.modules)})")
        print("-" * 60)

        # group by type
        by_type = {}
        for module in self.modules:
            by_type.setdefault(module.type, []).append(module)

        for mod_type, modules in sorted(by_type.items()):
            if modules:
                print(f"\n{mod_type}:")
                for module in sorted(modules, key=lambda m: m.base_address):
                    system = " [system]" if module.is_system_library else ""
                    print(
                        f"  {module.base_address:016x}  {module.size:10,} bytes  {module.name}{system}"
                    )

    def print_memory_map(self):
        """print memory regions"""
        print()
        print("-" * 60)
        print(f"memory map ({len(self.regions)} regions)")
        print("-" * 60)

        # show first few regions and last few
        regions = sorted(self.regions, key=lambda r: r.start)

        if len(regions) <= 20:
            for region in regions:
                print(region)
        else:
            print(
                "\nshowing first 10 and last 10 regions (use --full for complete map):"
            )
            print()
            for region in regions[:10]:
                print(region)
            print(f"\n... {len(regions) - 20} more regions ...\n")
            for region in regions[-10:]:
                print(region)


def export_dump(dump: W1Dump, output_path: Union[str, Path], selected_regions: List[int] = None) -> None:
    """
    export a w1dump with optionally filtered regions to a new file
    
    args:
        dump: the W1Dump object to export
        output_path: path for the new dump file
        selected_regions: list of region indices to include (None = all regions)
    
    raises:
        IOError: if writing fails
        ValueError: if invalid region indices provided
    """
    import copy
    from pathlib import Path
    
    output_path = Path(output_path)
    
    # create a copy of the dump to modify
    new_dump = copy.deepcopy(dump)
    
    # filter regions if specified
    if selected_regions is not None:
        if not all(0 <= i < len(dump.regions) for i in selected_regions):
            raise ValueError(f"invalid region indices provided")
        
        # keep only selected regions
        new_dump.regions = [dump.regions[i] for i in selected_regions]
    
    # update timestamp to current time
    import time
    new_dump.metadata.timestamp = int(time.time() * 1000)
    
    # serialize to MessagePack
    try:
        # convert to dict format
        dump_dict = {
            "metadata": {
                "version": new_dump.metadata.version,
                "timestamp": new_dump.metadata.timestamp,
                "os": new_dump.metadata.os,
                "arch": new_dump.metadata.arch,
                "pointer_size": new_dump.metadata.pointer_size,
                "pid": new_dump.metadata.pid,
                "process_name": new_dump.metadata.process_name,
            },
            "thread": {
                "thread_id": new_dump.thread.thread_id,
                "gpr_values": new_dump.thread.gpr_values,
                "fpr_values": new_dump.thread.fpr_values,
            },
            "regions": [],
            "modules": []
        }
        
        # serialize regions
        for region in new_dump.regions:
            region_dict = {
                "start": region.start,
                "end": region.end,
                "permissions": region.permissions,
                "module_name": region.module_name,
                "is_stack": region.is_stack,
                "is_code": region.is_code,
                "is_data": region.is_data,
                "is_anonymous": region.is_anonymous,
                "data": list(region.data) if region.data else None
            }
            dump_dict["regions"].append(region_dict)
        
        # serialize modules
        for module in new_dump.modules:
            module_dict = {
                "path": module.path,
                "name": module.name,
                "base_address": module.base_address,
                "size": module.size,
                "type": module.type,
                "is_system_library": module.is_system_library,
                "permissions": module.permissions,
            }
            dump_dict["modules"].append(module_dict)
        
        # write to file
        data = msgpack.packb(dump_dict)
        with open(output_path, 'wb') as f:
            f.write(data)
            
    except Exception as e:
        raise IOError(f"failed to export dump: {e}")


def load_dump(path: Union[str, Path], validate: bool = True) -> W1Dump:
    """
    load a w1dump file from disk

    args:
        path: path to the dump file
        validate: whether to validate the dump structure (default: True)

    returns:
        W1Dump object containing the parsed dump

    raises:
        FileNotFoundError: if the dump file doesn't exist
        ValueError: if the dump file is invalid or corrupted
    """
    path = Path(path)

    if not path.exists():
        raise FileNotFoundError(f"dump file not found: {path}")

    # check file size
    file_size = path.stat().st_size
    if file_size == 0:
        raise ValueError("dump file is empty")
    if file_size > 10 * 1024 * 1024 * 1024:  # 10GB sanity check
        raise ValueError(
            f"dump file unusually large ({file_size} bytes), may be corrupted"
        )

    # read the file
    try:
        with open(path, "rb") as f:
            data = f.read()
    except IOError as e:
        raise ValueError(f"failed to read dump file: {e}")

    # unpack from MessagePack
    try:
        dump_dict = msgpack.unpackb(data, raw=False, strict_map_key=False)
    except msgpack.exceptions.ExtraData as e:
        raise ValueError(f"dump file contains extra data, may be corrupted: {e}")
    except Exception as e:
        raise ValueError(f"failed to parse MessagePack format: {e}")

    # validate basic structure
    if validate:
        required_keys = {"metadata", "thread", "regions", "modules"}
        missing_keys = required_keys - set(dump_dict.keys())
        if missing_keys:
            raise ValueError(f"dump file missing required keys: {missing_keys}")

    # parse metadata
    try:
        metadata = DumpMetadata(**dump_dict["metadata"])
    except (KeyError, TypeError) as e:
        raise ValueError(f"invalid metadata section: {e}")

    # parse thread state
    try:
        thread = ThreadState(**dump_dict["thread"])
    except (KeyError, TypeError) as e:
        raise ValueError(f"invalid thread section: {e}")

    # parse memory regions
    regions = []
    try:
        for i, r in enumerate(dump_dict["regions"]):
            # convert data from list to bytes if present
            if "data" in r and r["data"] is not None:
                r["data"] = bytes(r["data"])
            regions.append(MemoryRegion(**r))
    except (KeyError, TypeError) as e:
        raise ValueError(f"invalid memory region at index {i}: {e}")

    # parse modules
    modules = []
    try:
        for i, m in enumerate(dump_dict["modules"]):
            modules.append(ModuleInfo(**m))
    except (KeyError, TypeError) as e:
        raise ValueError(f"invalid module at index {i}: {e}")

    # create and return dump object
    return W1Dump(metadata=metadata, thread=thread, regions=regions, modules=modules)


def main():
    """main entry point"""
    import argparse

    parser = argparse.ArgumentParser(
        description="read and analyze w1dump process dump files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
examples:
  %(prog)s dump.w1dump              # show summary, registers, modules, and memory map
  %(prog)s dump.w1dump --summary    # show only summary
  %(prog)s dump.w1dump --full       # show full memory map (all regions)
  %(prog)s dump.w1dump --no-modules # skip module listing
""",
    )

    parser.add_argument("dump_file", help="path to w1dump file")
    parser.add_argument("--summary", action="store_true", help="show only summary")
    parser.add_argument("--full", action="store_true", help="show full memory map")
    parser.add_argument(
        "--no-registers", action="store_true", help="skip register display"
    )
    parser.add_argument("--no-modules", action="store_true", help="skip module listing")
    parser.add_argument("--no-memory", action="store_true", help="skip memory map")

    args = parser.parse_args()

    try:
        # load the dump
        dump = load_dump(args.dump_file)

        # always show summary
        dump.print_summary()

        # show other sections based on flags
        if not args.summary:
            if not args.no_registers:
                dump.print_registers()
            if not args.no_modules:
                dump.print_modules()
            if not args.no_memory:
                # pass full flag through
                if args.full:
                    # temporarily show all regions
                    regions = sorted(dump.regions, key=lambda r: r.start)
                    print()
                    print("-" * 60)
                    print(f"memory map ({len(dump.regions)} regions) - full listing")
                    print("-" * 60)
                    for region in regions:
                        print(region)
                else:
                    dump.print_memory_map()

    except Exception as e:
        print(f"error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()

```

`scripts/w1dump_tui.py`:

```py
#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.8"
# dependencies = [
#     "msgpack",
#     "urwid",
# ]
# ///
"""
w1dump_tui.py - an interactive TUI for exploring w1dump files

usage:
    ./scripts/w1dump_tui.py dump.w1dump

features:
    - multi-tab interface with keyboard navigation
    - overview, registers, modules, memory map, and region editor tabs
    - export filtered dumps with selected regions
    - search and filtering capabilities
"""

import sys
import argparse
import re
from pathlib import Path
from typing import List, Optional, Tuple, Any, NamedTuple

import urwid
import w1dump


class SearchResult(NamedTuple):
    """search result with context"""
    address: int
    region_index: int
    offset: int
    context_before: bytes
    match: bytes
    context_after: bytes


class HexSearcher:
    """efficient hex pattern search using Boyer-Moore algorithm"""
    
    @staticmethod
    def parse_hex_pattern(pattern: str) -> Tuple[bytes, bytes]:
        """
        parse hex pattern like "48 8B ?? 90" into pattern and mask
        returns (pattern_bytes, mask_bytes) where mask 0x00 = wildcard, 0xFF = exact match
        """
        # remove whitespace and normalize
        pattern = re.sub(r'\s+', ' ', pattern.strip().upper())
        parts = pattern.split(' ')
        
        pattern_bytes = bytearray()
        mask_bytes = bytearray()
        
        for part in parts:
            if part == '??':
                pattern_bytes.append(0x00)
                mask_bytes.append(0x00)  # wildcard
            else:
                try:
                    byte_val = int(part, 16)
                    pattern_bytes.append(byte_val)
                    mask_bytes.append(0xFF)  # exact match
                except ValueError:
                    raise ValueError(f"invalid hex byte: {part}")
        
        return bytes(pattern_bytes), bytes(mask_bytes)
    
    @staticmethod
    def search(data: bytes, pattern: bytes, mask: bytes) -> List[int]:
        """
        search for pattern in data using boyer-moore with wildcard support
        returns list of offsets where pattern matches
        """
        if len(pattern) != len(mask):
            raise ValueError("pattern and mask must be same length")
        
        if not pattern:
            return []
        
        results = []
        data_len = len(data)
        pattern_len = len(pattern)
        
        if pattern_len > data_len:
            return results
        
        # simplified boyer-moore with wildcards
        # build bad character table for exact bytes only
        bad_char = {}
        for i, (p_byte, m_byte) in enumerate(zip(pattern, mask)):
            if m_byte == 0xFF:  # exact match required
                bad_char[p_byte] = i
        
        skip = 0
        while skip <= data_len - pattern_len:
            # check pattern at current position
            match = True
            for i in range(pattern_len):
                if mask[i] == 0xFF:  # exact match required
                    if data[skip + i] != pattern[i]:
                        match = False
                        break
                # wildcards (mask[i] == 0x00) always match
            
            if match:
                results.append(skip)
                skip += 1  # continue searching for overlapping matches
            else:
                # boyer-moore skip calculation
                if skip + pattern_len - 1 < data_len:
                    bad_char_byte = data[skip + pattern_len - 1]
                    if bad_char_byte in bad_char:
                        skip = max(1, pattern_len - bad_char[bad_char_byte] - 1) + skip
                    else:
                        skip += pattern_len
                else:
                    skip += 1
        
        return results


class GotoDialog:
    """dialog for entering hex addresses"""
    
    def __init__(self, callback):
        self.callback = callback
        self.edit = urwid.Edit("Address: ")
        
        ok_button = urwid.Button("OK", on_press=self.on_ok)
        cancel_button = urwid.Button("Cancel", on_press=self.on_cancel)
        
        buttons = urwid.Columns([
            ('fixed', 6, urwid.AttrMap(ok_button, 'body')),
            ('fixed', 10, urwid.AttrMap(cancel_button, 'body')),
        ], dividechars=2)
        
        pile = urwid.Pile([
            self.edit,
            urwid.Divider(),
            buttons
        ])
        
        self.widget = urwid.LineBox(pile, title="Goto")
    
    def keypress(self, size, key):
        if key == 'enter':
            self.on_ok(None)
            return None
        elif key == 'esc':
            self.on_cancel(None)
            return None
        else:
            return self.widget.keypress(size, key)
    
    def on_ok(self, button):
        text = self.edit.get_edit_text().strip()
        try:
            if text.startswith('0x') or text.startswith('0X'):
                address = int(text, 16)
            else:
                address = int(text, 16) if text else 0
            self.callback(address)
        except ValueError:
            # invalid input, show error
            pass
        raise urwid.ExitMainLoop()
    
    def on_cancel(self, button):
        self.callback(None)
        raise urwid.ExitMainLoop()


class HelpDialog:
    """enhanced help dialog with categorized shortcuts"""
    
    def __init__(self, on_close):
        self.on_close = on_close
        help_sections = [
            ("Navigation", [
                "Tab/Shift-Tab    - Switch between tabs",
                "1-6              - Jump directly to tab",
                "↑/↓ or j/k       - Navigate lists",
                "Page Up/Down     - Scroll pages",
                "Home/End         - Go to top/bottom",
            ]),
            ("Search & Navigation", [
                "/                - Search hex pattern (e.g., '48 8B ?? 90')",
                "g                - Goto address",
                "n                - Next search result",
                "p                - Previous search result",
            ]),
            ("Region Editor", [
                "Space            - Toggle region selection",
                "a                - Select all regions",
                "Ctrl+a           - Select all regions",
                "z                - Select none",
                "e                - Export selected regions",
            ]),
            ("Global", [
                "?                - Show this help",
                "h                - Show this help",
                "q                - Quit",
                "Ctrl+c           - Quit",
            ])
        ]
        
        lines = []
        for section_name, shortcuts in help_sections:
            lines.append(urwid.Text(('header', section_name)))
            for shortcut in shortcuts:
                lines.append(urwid.Text(f"  {shortcut}"))
            lines.append(urwid.Divider())
        
        lines.append(urwid.Text("Press any key to close this help...", align='center'))
        
        listbox = urwid.ListBox(urwid.SimpleFocusListWalker([
            urwid.AttrMap(line, 'body') for line in lines
        ]))
        
        self.widget = urwid.LineBox(listbox, title="Help - w1dump TUI")
    
    def keypress(self, size, key):
        # close on any key press
        self.on_close()
        return key


class W1DumpTUI:
    """main TUI application class"""
    
    TAB_OVERVIEW = 0
    TAB_REGISTERS = 1
    TAB_MODULES = 2
    TAB_MEMORY = 3
    TAB_REGION_EDITOR = 4
    TAB_SEARCH = 5
    
    def __init__(self, dump_file: Path):
        self.dump_file = dump_file
        self.dump = None
        self.selected_regions = set()
        self.search_results = []
        self.current_search_index = -1
        self.last_search_pattern = ""
        
        try:
            self.dump = w1dump.load_dump(dump_file)
        except Exception as e:
            raise ValueError(f"failed to load dump: {e}")
        
        self.palette = [
            ('title', 'white,bold', 'dark blue'),
            ('tab_active', 'white,bold', 'dark blue'),
            ('tab_inactive', 'white', 'black'),
            ('header', 'yellow,bold', 'black'),
            ('body', 'white', 'black'),
            ('footer', 'white', 'dark blue'),
            ('error', 'light red', 'black'),
            ('success', 'light green', 'black'),
            ('highlight', 'white,bold', 'dark red'),
            ('checkbox', 'white', 'black'),
            ('checkbox_selected', 'white,bold', 'dark green'),
        ]
        
        self.tab_names = ['Overview', 'Registers', 'Modules', 'Memory Map', 'Region Editor', 'Search']
        self.current_tab = 0
        self.setup_ui()
    
    @staticmethod
    def format_size(size: int) -> str:
        """format byte size in human readable form"""
        if size >= 1024*1024*1024:
            return f"{size/(1024*1024*1024):.1f}G"
        elif size >= 1024*1024:
            return f"{size/(1024*1024):.1f}M"
        elif size >= 1024:
            return f"{size/1024:.1f}K"
        else:
            return f"{size:,}"
    
    @staticmethod
    def build_flag_string(region) -> str:
        """build flag string for memory region"""
        flags = []
        if region.is_stack:
            flags.append("STACK")
        if region.is_code:
            flags.append("CODE")
        if region.is_data:
            flags.append("DATA")
        if region.is_anonymous:
            flags.append("ANON")
        if hasattr(region, 'data') and region.data:
            flags.append("DUMPED" if len(flags) < 4 else "DUMP")
        return ",".join(flags)
    
    def create_table_header(self, columns_data: List[Tuple]) -> urwid.Widget:
        """create a table header row"""
        widgets = self._build_column_widgets(columns_data, is_header=True)
        row = urwid.Columns(widgets, dividechars=1)
        return urwid.AttrMap(row, 'header')
    
    def create_table_row(self, columns_data: List[Tuple], selectable=True) -> urwid.Widget:
        """create a table data row"""
        widgets = self._build_column_widgets(columns_data, is_header=False)
        row = urwid.Columns(widgets, dividechars=1)
        if selectable:
            return urwid.AttrMap(row, 'body', 'highlight')
        else:
            return urwid.AttrMap(row, 'body')
    
    def _build_column_widgets(self, columns_data: List[Tuple], is_header: bool) -> List[Tuple]:
        """build column widgets from specifications"""
        widgets = []
        for spec in columns_data:
            if len(spec) == 2:
                width, text = spec
                if isinstance(width, int):
                    attr = ('header', text) if is_header else text
                    widgets.append(('fixed', width, urwid.Text(attr)))
                else:
                    attr = ('header', text) if is_header else text
                    widgets.append(urwid.Text(attr))
            elif len(spec) == 3:
                width_type, width_val, text = spec
                attr = ('header', text) if is_header else text
                widgets.append((width_type, width_val, urwid.Text(attr)))
        return widgets
    
    def update_status_bar(self, message=None):
        """update status bar with dynamic shortcuts based on current tab"""
        if message:
            self.status_text.set_text(message)
            return
        
        base_shortcuts = "Tab:Switch ?:Help q:Quit"
        tab_shortcuts = {
            self.TAB_REGION_EDITOR: " g:Goto /:Search Space:Toggle a:All z:None e:Export",
            self.TAB_MODULES: " g:Goto /:Search",
            self.TAB_MEMORY: " g:Goto /:Search",
            self.TAB_SEARCH: " Enter:Search n:Next p:Prev",
        }
        
        shortcuts = base_shortcuts + tab_shortcuts.get(self.current_tab, "")
        
        if self.search_results:
            shortcuts += f" | Results: {len(self.search_results)}"
            if self.current_search_index >= 0:
                shortcuts += f" ({self.current_search_index + 1}/{len(self.search_results)})"
        
        self.status_text.set_text(f"File: {self.dump_file.name} | {shortcuts}")
        self.status_bar.set_attr_map({None: 'footer'})
    
    def setup_ui(self):
        """initialize the main UI structure"""
        self.tab_buttons = []
        for i, name in enumerate(self.tab_names):
            btn = urwid.Button(f" {name} ", on_press=self.switch_tab, user_data=i)
            if i == 0:
                btn = urwid.AttrMap(btn, 'tab_active', 'tab_active')
            else:
                btn = urwid.AttrMap(btn, 'tab_inactive', 'tab_inactive')
            self.tab_buttons.append(btn)
        
        self.tab_bar = urwid.Columns(self.tab_buttons, dividechars=1)
        
        self.tab_contents = [None] * len(self.tab_names)
        self.tab_contents[self.TAB_OVERVIEW] = self.create_overview_tab()
        self.tab_contents[self.TAB_REGISTERS] = self.create_registers_tab()
        self.tab_contents[self.TAB_MODULES] = self.create_modules_tab()
        self.tab_contents[self.TAB_MEMORY] = self.create_memory_tab()
        self.tab_contents[self.TAB_REGION_EDITOR] = self.create_region_editor_tab()
        self.tab_contents[self.TAB_SEARCH] = self.create_search_tab()
        
        self.status_text = urwid.Text("")
        self.status_bar = urwid.AttrMap(self.status_text, 'footer')
        self.update_status_bar()
        
        header = urwid.Pile([
            urwid.AttrMap(urwid.Text(f"w1dump TUI - {self.dump.metadata.process_name}", align='center'), 'title'),
            urwid.Divider(),
            self.tab_bar,
            urwid.Divider('─'),
        ])
        
        self.content_area = self.tab_contents[self.TAB_OVERVIEW]
        
        self.main_frame = urwid.Frame(
            body=self.content_area,
            header=header,
            footer=self.status_bar
        )
    
    def create_overview_tab(self):
        """create overview tab content"""
        lines = []
        
        lines.append(urwid.Text(('header', 'Process Information')))
        lines.append(urwid.Text(f"Name:         {self.dump.metadata.process_name}"))
        lines.append(urwid.Text(f"PID:          {self.dump.metadata.pid}"))
        lines.append(urwid.Text(f"Architecture: {self.dump.metadata.arch} ({self.dump.metadata.pointer_size * 8}-bit)"))
        lines.append(urwid.Text(f"Platform:     {self.dump.metadata.os}"))
        
        # timestamp
        if self.dump.metadata.timestamp > 0:
            from datetime import datetime, timezone
            dt = datetime.fromtimestamp(self.dump.metadata.timestamp / 1000.0, tz=timezone.utc)
            lines.append(urwid.Text(f"Captured:     {dt.astimezone().strftime('%Y-%m-%d %H:%M:%S %Z')}"))
        
        lines.append(urwid.Text(f"Thread ID:    {self.dump.thread.thread_id}"))
        lines.append(urwid.Divider())
        
        lines.append(urwid.Text(('header', 'Statistics')))
        lines.append(urwid.Text(f"Modules:         {len(self.dump.modules):4d}"))
        lines.append(urwid.Text(f"Memory regions:  {len(self.dump.regions):4d}"))
        
        total_size = sum(r.size for r in self.dump.regions)
        code_size = sum(r.size for r in self.dump.regions if r.is_code)
        data_size = sum(r.size for r in self.dump.regions if r.is_data)
        stack_size = sum(r.size for r in self.dump.regions if r.is_stack)
        anon_size = sum(r.size for r in self.dump.regions if r.is_anonymous)
        
        
        lines.append(urwid.Divider())
        lines.append(urwid.Text(('header', 'Memory Breakdown')))
        lines.append(urwid.Text(f"Total:      {self.format_size(total_size):>12} ({total_size:,} bytes)"))
        lines.append(urwid.Text(f"Code:       {self.format_size(code_size):>12} ({code_size:,} bytes)"))
        lines.append(urwid.Text(f"Data:       {self.format_size(data_size):>12} ({data_size:,} bytes)"))
        lines.append(urwid.Text(f"Stack:      {self.format_size(stack_size):>12} ({stack_size:,} bytes)"))
        lines.append(urwid.Text(f"Anonymous:  {self.format_size(anon_size):>12} ({anon_size:,} bytes)"))
        
        # current execution context
        if self.dump.thread.gpr_state:
            lines.append(urwid.Divider())
            lines.append(urwid.Text(('header', 'Execution Context')))
            pc = self.dump.thread.gpr_state.pc
            lines.append(urwid.Text(f"PC:           {pc:016x}"))
            
            # find module at PC
            module = self.dump.get_module_at(pc)
            if module:
                lines.append(urwid.Text(f"Module:       {module.name}"))
                lines.append(urwid.Text(f"Module base:  {module.base_address:016x}"))
                lines.append(urwid.Text(f"Offset:       +{pc - module.base_address:x}"))
            
            # find region at PC
            region = self.dump.get_region_at(pc)
            if region:
                lines.append(urwid.Text(f"Region:       {region.start:016x}-{region.end:016x} {region.perms_str}"))
        
        return urwid.ListBox(urwid.SimpleFocusListWalker([urwid.AttrMap(line, 'body') for line in lines]))
    
    def create_registers_tab(self):
        """create registers tab content"""
        lines = []
        
        if self.dump.thread.gpr_state:
            lines.append(urwid.Text(('header', 'General Purpose Registers')))
            # split the register string by newlines and create text widgets
            reg_str = str(self.dump.thread.gpr_state)
            for reg_line in reg_str.split('\n'):
                lines.append(urwid.Text(f"  {reg_line}"))
        else:
            lines.append(urwid.Text(('error', 'No parsed register state available')))
        
        return urwid.ListBox(urwid.SimpleFocusListWalker([urwid.AttrMap(line, 'body') for line in lines]))
    
    def create_modules_tab(self):
        """create modules tab content"""
        lines = []
        
        # table header
        header_cols = [
            (18, "Address"),
            (12, "Size"),
            ('weight', 1, "Name"),
            (4, "Type"),
            (8, "Flags")
        ]
        
        lines.append(self.create_table_header(header_cols))
        lines.append(urwid.Divider('─'))
        
        # sort all modules by address
        all_modules = sorted(self.dump.modules, key=lambda m: m.base_address)
        
        for module in all_modules:
            # build flags
            flags = ["SYS"] if module.is_system_library else []
            flag_str = ",".join(flags)
            
            # format size and type
            size_str = self.format_size(module.size)
            type_short = "E" if module.type == "main_executable" else "L"
            
            row_data = [
                (18, f"{module.base_address:016x}"),
                (12, size_str),
                ('weight', 1, module.name),
                (4, type_short),
                (8, flag_str)
            ]
            
            lines.append(self.create_table_row(row_data))
        
        return urwid.ListBox(urwid.SimpleFocusListWalker(lines))
    
    def create_memory_tab(self):
        """create memory map tab content"""
        lines = []
        
        # table header
        header_cols = [
            (18, "Start"),
            (18, "End"),
            (5, "Perms"),
            (12, "Size"),
            ('weight', 1, "Module"),
            (20, "Flags")
        ]
        
        lines.append(self.create_table_header(header_cols))
        lines.append(urwid.Divider('─'))
        
        # show ALL regions (no truncation)
        regions = sorted(self.dump.regions, key=lambda r: r.start)
        
        for region in regions:
            flag_str = self.build_flag_string(region)
            size_str = self.format_size(region.size)
            
            row_data = [
                (18, f"{region.start:016x}"),
                (18, f"{region.end:016x}"),
                (5, region.perms_str),
                (12, size_str),
                ('weight', 1, region.module_name or ""),
                (20, flag_str)
            ]
            
            lines.append(self.create_table_row(row_data))
        
        return urwid.ListBox(urwid.SimpleFocusListWalker(lines))
    
    def create_region_editor_tab(self):
        """create region editor tab content"""
        lines = []
        
        # control buttons
        buttons = urwid.Columns([
            urwid.Text(('header', 'Region Editor - Select regions to export:')),
            ('fixed', 8, urwid.AttrMap(urwid.Button("All", on_press=self.select_all_regions), 'body')),
            ('fixed', 9, urwid.AttrMap(urwid.Button("None", on_press=self.select_no_regions), 'body')),
            ('fixed', 11, urwid.AttrMap(urwid.Button("Export", on_press=self.export_selected), 'success')),
        ], dividechars=2)
        
        lines.append(buttons)
        lines.append(urwid.Divider('─'))
        
        # table header
        header_cols = [
            (4, "Sel"),
            (18, "Start"),
            (18, "End"),
            (6, "Perms"),
            (12, "Size"),
            ('weight', 1, "Module"),
            (15, "Flags")
        ]
        
        lines.append(self.create_table_header(header_cols))
        lines.append(urwid.Divider('─'))
        
        # region checkboxes for ALL regions (no truncation)
        self.region_checkboxes = []
        regions = sorted(self.dump.regions, key=lambda r: r.start)
        
        for i, region in enumerate(regions):
            flag_str = self.build_flag_string(region).replace("DUMPED", "DUMP")
            size_str = self.format_size(region.size)
            
            checkbox = urwid.CheckBox("", state=True, on_state_change=self.region_checkbox_changed, user_data=i)
            self.region_checkboxes.append(checkbox)
            
            # create a selectable row with proper column alignment
            row = urwid.Columns([
                ('fixed', 4, checkbox),
                ('fixed', 18, urwid.Text(f"{region.start:016x}")),
                ('fixed', 18, urwid.Text(f"{region.end:016x}")),
                ('fixed', 6, urwid.Text(region.perms_str)),
                ('fixed', 12, urwid.Text(size_str)),
                ('weight', 1, urwid.Text(region.module_name or "")),
                ('fixed', 15, urwid.Text(flag_str))
            ], dividechars=1)
            
            lines.append(urwid.AttrMap(row, 'body', 'highlight'))
        
        # initialize selected regions to all
        self.selected_regions = set(range(len(self.dump.regions)))
        
        return urwid.ListBox(urwid.SimpleFocusListWalker(lines))
    
    def create_search_tab(self):
        """create search tab content"""
        lines = []
        
        # search input
        self.search_edit = urwid.Edit("Hex Pattern (e.g., '48 8B ?? 90'): ")
        search_btn = urwid.Button("Search", on_press=self.perform_search)
        
        search_row = urwid.Columns([
            ('weight', 1, self.search_edit),
            ('fixed', 10, urwid.AttrMap(search_btn, 'body')),
        ], dividechars=2)
        
        lines.append(urwid.Text(('header', 'Hex Pattern Search')))
        lines.append(urwid.Divider())
        lines.append(search_row)
        lines.append(urwid.Divider())
        
        # results display
        self.search_results_walker = urwid.SimpleFocusListWalker([])
        self.search_results_listbox = urwid.ListBox(self.search_results_walker)
        
        if not self.search_results:
            lines.append(urwid.Text("No search results. Enter a hex pattern above."))
        else:
            # show search results
            lines.append(urwid.Text(('header', f'Results ({len(self.search_results)}):')))
            for i, result in enumerate(self.search_results):
                region = self.dump.regions[result.region_index]
                text = f"{result.address:016x} (+{result.offset:x}) in {region.module_name or 'unknown'}"
                if i == self.current_search_index:
                    lines.append(urwid.AttrMap(urwid.Text(f"→ {text}"), 'highlight'))
                else:
                    lines.append(urwid.Text(f"  {text}"))
        
        return urwid.ListBox(urwid.SimpleFocusListWalker([urwid.AttrMap(line, 'body') for line in lines]))
    
    def switch_tab(self, button, tab_index):
        """switch to a different tab"""
        # update tab button appearance
        for i, btn in enumerate(self.tab_buttons):
            if i == tab_index:
                btn.set_attr_map({None: 'tab_active'})
            else:
                btn.set_attr_map({None: 'tab_inactive'})
        
        # update content
        self.current_tab = tab_index
        self.content_area = self.tab_contents[tab_index]
        self.main_frame.body = self.content_area
        self.update_status_bar()
    
    def select_all_regions(self, button):
        """select all regions for export"""
        for checkbox in self.region_checkboxes:
            checkbox.set_state(True)
    
    def select_no_regions(self, button):
        """deselect all regions for export"""
        for checkbox in self.region_checkboxes:
            checkbox.set_state(False)
    
    def region_checkbox_changed(self, checkbox, new_state, user_data):
        """handle region checkbox state change"""
        region_index = user_data
        if new_state:
            self.selected_regions.add(region_index)
        else:
            self.selected_regions.discard(region_index)
    
    def export_selected(self, button):
        """export dump with selected regions"""
        if not self.selected_regions:
            self.show_message("No regions selected for export", "error")
            return
        
        # generate output filename
        base_name = self.dump_file.stem
        output_file = self.dump_file.parent / f"{base_name}_filtered.w1dump"
        
        try:
            selected_list = list(self.selected_regions)
            w1dump.export_dump(self.dump, output_file, selected_list)
            self.show_message(f"Exported {len(selected_list)} regions to {output_file.name}", "success")
        except Exception as e:
            self.show_message(f"Export failed: {e}", "error")
    
    def perform_search(self, button=None):
        """perform hex pattern search"""
        pattern = self.search_edit.get_edit_text().strip()
        if not pattern:
            self.show_message("Enter a hex pattern to search", "error")
            return
        
        try:
            pattern_bytes, mask_bytes = HexSearcher.parse_hex_pattern(pattern)
        except ValueError as e:
            self.show_message(f"Invalid hex pattern: {e}", "error")
            return
        
        self.search_results = []
        self.current_search_index = -1
        self.last_search_pattern = pattern
        
        # search through all regions with data
        for region_idx, region in enumerate(self.dump.regions):
            if not region.data:
                continue
            
            matches = HexSearcher.search(region.data, pattern_bytes, mask_bytes)
            for offset in matches:
                address = region.start + offset
                context_start = max(0, offset - 8)
                context_end = min(len(region.data), offset + len(pattern_bytes) + 8)
                
                result = SearchResult(
                    address=address,
                    region_index=region_idx,
                    offset=offset,
                    context_before=region.data[context_start:offset],
                    match=region.data[offset:offset + len(pattern_bytes)],
                    context_after=region.data[offset + len(pattern_bytes):context_end]
                )
                self.search_results.append(result)
        
        if self.search_results:
            self.current_search_index = 0
            self.show_message(f"Found {len(self.search_results)} matches", "success")
        else:
            self.show_message("No matches found", "error")
        
        self.update_status_bar()
        
        # refresh search tab if currently active
        if self.current_tab == self.TAB_SEARCH:
            self.tab_contents[self.TAB_SEARCH] = self.create_search_tab()
            self.main_frame.body = self.tab_contents[self.TAB_SEARCH]
    
    def goto_address(self):
        """show goto address dialog"""
        def on_address_entered(address):
            if address is None:
                return
            
            # find module containing this address
            module = self.dump.get_module_at(address)
            region = self.dump.get_region_at(address)
            
            if module or region:
                # switch to appropriate tab and highlight the item
                if module:
                    self.switch_tab(None, self.TAB_MODULES)
                    self.show_message(f"Found address in module: {module.name}", "success")
                elif region:
                    self.switch_tab(None, self.TAB_MEMORY)
                    self.show_message(f"Found address in region: {region.start:016x}-{region.end:016x}", "success")
            else:
                self.show_message(f"Address {address:016x} not found in dump", "error")
        
        dialog = GotoDialog(on_address_entered)
        overlay = urwid.Overlay(
            dialog.widget,
            self.main_frame,
            align='center',
            width=30,
            valign='middle',
            height=5,
        )
        
        def dialog_unhandled_input(key):
            return dialog.keypress(None, key)
        
        loop = urwid.MainLoop(overlay, self.palette, unhandled_input=dialog_unhandled_input)
        loop.run()
    
    def next_search_result(self):
        """go to next search result"""
        if not self.search_results:
            self.show_message("No search results", "error")
            return
        
        self.current_search_index = (self.current_search_index + 1) % len(self.search_results)
        self.update_status_bar()
        self.show_message(f"Search result {self.current_search_index + 1}/{len(self.search_results)}", "body")
    
    def prev_search_result(self):
        """go to previous search result"""
        if not self.search_results:
            self.show_message("No search results", "error")
            return
        
        self.current_search_index = (self.current_search_index - 1) % len(self.search_results)
        self.update_status_bar()
        self.show_message(f"Search result {self.current_search_index + 1}/{len(self.search_results)}", "body")
    
    def show_message(self, message, style='body'):
        """show a message in the status bar temporarily"""
        self.status_text.set_text(message)
        if style == 'error':
            self.status_bar.set_attr_map({None: 'error'})
        elif style == 'success':
            self.status_bar.set_attr_map({None: 'success'})
        else:
            self.status_bar.set_attr_map({None: 'footer'})
    
    def show_help_dialog(self):
        """show enhanced help dialog"""
        def close_help():
            raise urwid.ExitMainLoop()
        
        help_dialog = HelpDialog(close_help)
        overlay = urwid.Overlay(
            help_dialog.widget,
            self.main_frame,
            align='center',
            width=60,
            valign='middle',
            height=30,
        )
        
        def help_unhandled_input(key):
            close_help()
            return None
        
        loop = urwid.MainLoop(overlay, self.palette, unhandled_input=help_unhandled_input)
        loop.run()
        self.update_status_bar()
    
    def unhandled_input(self, key):
        """handle global keyboard shortcuts"""
        # quit commands
        if key in ('q', 'Q', 'ctrl c'):
            raise urwid.ExitMainLoop()
        
        # help commands  
        if key in ('h', '?'):
            self.show_help_dialog()
            return
        
        # tab navigation
        if key == 'tab':
            self.switch_tab(None, (self.current_tab + 1) % len(self.tab_names))
            return
        if key == 'shift tab':
            self.switch_tab(None, (self.current_tab - 1) % len(self.tab_names))
            return
        if key in ('1', '2', '3', '4', '5', '6'):
            tab_idx = int(key) - 1
            if 0 <= tab_idx < len(self.tab_names):
                self.switch_tab(None, tab_idx)
            return
        
        # search navigation
        if key == 'n':
            self.next_search_result()
            return
        if key == 'p':
            self.prev_search_result()
            return
        
        # tabs that support goto/search
        goto_search_tabs = {self.TAB_MODULES, self.TAB_MEMORY, self.TAB_REGION_EDITOR}
        if self.current_tab in goto_search_tabs:
            if key == 'g':
                self.goto_address()
                return
            if key == '/':
                self.switch_tab(None, self.TAB_SEARCH)
                self.main_frame.set_focus('body')
                return
        
        # region editor specific commands
        if self.current_tab == self.TAB_REGION_EDITOR:
            region_commands = {
                'a': self.select_all_regions,
                'z': self.select_no_regions, 
                'e': self.export_selected
            }
            if key in region_commands:
                region_commands[key](None)
                return
        
        # search tab specific commands
        if self.current_tab == self.TAB_SEARCH and key == 'enter':
            self.perform_search()
            return
    
    
    def run(self):
        """start the TUI"""
        try:
            loop = urwid.MainLoop(self.main_frame, self.palette, unhandled_input=self.unhandled_input)
            loop.run()
        except Exception as e:
            # fallback to text mode if TUI fails
            print(f"TUI failed to start: {e}")
            print("Falling back to text mode...")
            self.dump.print_summary()
            if input("\nShow registers? (y/n): ").lower().startswith('y'):
                self.dump.print_registers()
            if input("\nShow modules? (y/n): ").lower().startswith('y'):
                self.dump.print_modules()


def main():
    parser = argparse.ArgumentParser(
        description="interactive TUI for exploring w1dump process dump files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
examples:
  %(prog)s dump.w1dump                 # open dump in TUI
  
keyboard shortcuts:
  Tab/Shift-Tab: switch tabs    h: help    q: quit
  1-6: jump to tab             space: toggle checkbox
""")
    
    parser.add_argument("dump_file", help="path to w1dump file")
    
    args = parser.parse_args()
    
    dump_file = Path(args.dump_file)
    if not dump_file.exists():
        print(f"error: dump file not found: {dump_file}")
        sys.exit(1)
    
    try:
        app = W1DumpTUI(dump_file)
        app.run()
    except KeyboardInterrupt:
        print("\nExited by user")
        pass
    except Exception as e:
        import traceback
        print(f"error: {e}")
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
```

`scripts/w1mem_analyzer.py`:

```py
#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.8"
# dependencies = [
#     "typer",
# ]
# ///

"""
w1mem trace analyzer - simple analysis tool for w1mem memory traces

Analyzes JSONL memory traces produced by w1mem tracer to extract basic information about:
- Memory access patterns (reads/writes, sizes, addresses)
- Module attribution and memory layout
- Access frequency and hotspots

Usage:
    python3 w1mem_analyzer.py <trace_file.jsonl> [options]
"""

import json
import sys
import os
from collections import defaultdict, Counter
from dataclasses import dataclass
from typing import List, Dict, Optional

import typer


@dataclass
class MemoryAccess:
    """represents a single memory access event from w1mem trace"""
    instruction_addr: int
    memory_addr: int
    size: int
    access_type: int  # 1=read, 2=write
    instruction_count: int
    instruction_module: str
    memory_module: str
    value: int
    value_valid: bool
    
    @property
    def is_read(self) -> bool:
        return self.access_type == 1
        
    @property
    def is_write(self) -> bool:
        return self.access_type == 2


@dataclass 
class ModuleInfo:
    """represents a loaded module from trace metadata"""
    id: int
    name: str
    path: str
    base: int
    size: int
    type: str
    is_system: bool


class W1MemAnalyzer:
    """analyzes w1mem memory traces"""
    
    def __init__(self, trace_file: str):
        self.trace_file = trace_file
        self.modules: Dict[str, ModuleInfo] = {}
        self.accesses: List[MemoryAccess] = []
        self.module_by_id: Dict[int, ModuleInfo] = {}
        
    def load_trace(self) -> None:
        """load and parse the JSONL trace file"""
        if not os.path.exists(self.trace_file):
            print(f"error: trace file not found: {self.trace_file}", file=sys.stderr)
            sys.exit(1)
            
        try:
            with open(self.trace_file, 'r') as f:
                lines = f.readlines()
        except Exception as e:
            print(f"error: failed to read trace file: {e}", file=sys.stderr)
            sys.exit(1)
            
        if not lines:
            print("error: empty trace file", file=sys.stderr)
            sys.exit(1)
            
        # parse metadata (first line)
        try:
            metadata = json.loads(lines[0])
        except json.JSONDecodeError as e:
            print(f"error: invalid JSON in metadata line: {e}", file=sys.stderr)
            sys.exit(1)
            
        if metadata.get('type') != 'metadata':
            print("error: first line must contain metadata with type='metadata'", file=sys.stderr)
            sys.exit(1)
            
        # load module information
        for mod_data in metadata.get('modules', []):
            module = ModuleInfo(
                id=mod_data['id'],
                name=mod_data['name'],
                path=mod_data['path'],
                base=mod_data['base'],
                size=mod_data['size'],
                type=mod_data['type'],
                is_system=mod_data['is_system']
            )
            self.modules[module.name] = module
            self.module_by_id[module.id] = module
            
        # parse memory access events
        for line_num, line in enumerate(lines[1:], 2):
            try:
                data = json.loads(line)
                if data.get('type') == 'event':
                    event_data = data['data']
                    access = MemoryAccess(
                        instruction_addr=event_data['instruction_addr'],
                        memory_addr=event_data['memory_addr'],
                        size=event_data['size'],
                        access_type=event_data['access_type'],
                        instruction_count=event_data['instruction_count'],
                        instruction_module=event_data['instruction_module'],
                        memory_module=event_data['memory_module'],
                        value=event_data['value'],
                        value_valid=event_data['value_valid']
                    )
                    self.accesses.append(access)
            except Exception as e:
                if line_num <= 10:  # only show first few parse errors
                    print(f"warning: failed to parse line {line_num}: {e}", file=sys.stderr)
                
        print(f"loaded {len(self.modules)} modules and {len(self.accesses)} memory accesses")
        
    def print_summary(self) -> None:
        """print high-level trace summary"""
        print("\n" + "="*60)
        print("MEMORY TRACE SUMMARY")
        print("="*60)
        
        total_accesses = len(self.accesses)
        if total_accesses == 0:
            print("no memory accesses found in trace")
            return
            
        reads = sum(1 for a in self.accesses if a.is_read)
        writes = sum(1 for a in self.accesses if a.is_write)
        valid_values = sum(1 for a in self.accesses if a.value_valid)
        
        print(f"trace file: {self.trace_file}")
        print(f"total memory accesses: {total_accesses}")
        print(f"  reads:      {reads:6} ({reads/total_accesses*100:.1f}%)")
        print(f"  writes:     {writes:6} ({writes/total_accesses*100:.1f}%)")
        print(f"  valid values: {valid_values:4} ({valid_values/total_accesses*100:.1f}%)")
        
        # instruction count range
        inst_counts = [a.instruction_count for a in self.accesses]
        if inst_counts:
            print(f"instruction count range: {min(inst_counts)} - {max(inst_counts)}")
        
        # size distribution
        size_counts = Counter(a.size for a in self.accesses)
        print(f"\naccess size distribution:")
        for size in sorted(size_counts.keys()):
            count = size_counts[size]
            print(f"  {size:2} bytes: {count:6} accesses ({count/total_accesses*100:.1f}%)")
            
        # module activity
        module_counts = Counter(a.instruction_module for a in self.accesses)
        print(f"\ntop instruction modules:")
        for i, (module, count) in enumerate(module_counts.most_common(10), 1):
            print(f"  {i:2}. {module:20}: {count:6} accesses ({count/total_accesses*100:.1f}%)")
            
        # memory regions
        memory_counts = Counter(a.memory_module for a in self.accesses)
        print(f"\ntop memory regions:")
        for i, (region, count) in enumerate(memory_counts.most_common(10), 1):
            print(f"  {i:2}. {region:20}: {count:6} accesses ({count/total_accesses*100:.1f}%)")
            
    def print_hotspots(self, top_n: int = 15) -> None:
        """find and display memory access hotspots"""
        print(f"\n" + "="*60)
        print("MEMORY HOTSPOT ANALYSIS")
        print("="*60)
        
        if not self.accesses:
            print("no memory accesses to analyze")
            return
            
        # memory address frequency
        addr_access_info = defaultdict(lambda: {'reads': 0, 'writes': 0, 'total': 0})
        for access in self.accesses:
            info = addr_access_info[access.memory_addr]
            if access.is_read:
                info['reads'] += 1
            else:
                info['writes'] += 1
            info['total'] += 1
            
        print(f"top {top_n} most accessed memory addresses:")
        sorted_addrs = sorted(addr_access_info.items(), key=lambda x: x[1]['total'], reverse=True)
        for i, (addr, info) in enumerate(sorted_addrs[:top_n], 1):
            total = info['total']
            reads = info['reads']
            writes = info['writes']
            pct = total / len(self.accesses) * 100
            print(f"  {i:2}. 0x{addr:016x}: {total:4} accesses ({pct:4.1f}%) | R: {reads:2} W: {writes:2}")
            
        # instruction address frequency
        inst_access_info = defaultdict(lambda: {'reads': 0, 'writes': 0, 'total': 0, 'module': '', 'addrs': set()})
        for access in self.accesses:
            info = inst_access_info[access.instruction_addr]
            if access.is_read:
                info['reads'] += 1
            else:
                info['writes'] += 1
            info['total'] += 1
            info['module'] = access.instruction_module
            info['addrs'].add(access.memory_addr)
            
        print(f"\ntop {top_n} most active instruction addresses:")
        sorted_insts = sorted(inst_access_info.items(), key=lambda x: x[1]['total'], reverse=True)
        for i, (addr, info) in enumerate(sorted_insts[:top_n], 1):
            total = info['total']
            reads = info['reads']
            writes = info['writes']
            num_addrs = len(info['addrs'])
            pct = total / len(self.accesses) * 100
            module = info['module'][:15]  # truncate long module names
            print(f"  {i:2}. 0x{addr:016x}: {total:4} accesses ({pct:4.1f}%) | R: {reads:2} W: {writes:2} | {num_addrs:3} addrs | {module}")
            
    def print_modules(self) -> None:
        """print module information"""
        print(f"\n" + "="*60)
        print("MODULE INFORMATION")
        print("="*60)
        
        if not self.modules:
            print("no module information available")
            return
            
        print(f"total modules: {len(self.modules)}")
        
        # categorize modules
        system_modules = [m for m in self.modules.values() if m.is_system]
        user_modules = [m for m in self.modules.values() if not m.is_system]
        main_modules = [m for m in self.modules.values() if m.type == 'main']
        
        print(f"  system modules: {len(system_modules)}")
        print(f"  user modules:   {len(user_modules)}")
        print(f"  main modules:   {len(main_modules)}")
        
        # show modules with memory accesses
        module_access_counts = Counter(a.instruction_module for a in self.accesses)
        active_modules = [(name, count) for name, count in module_access_counts.items() if count > 0]
        
        if active_modules:
            print(f"\nmodules with memory accesses:")
            for name, count in sorted(active_modules, key=lambda x: x[1], reverse=True):
                module = self.modules.get(name)
                if module:
                    type_str = module.type[:8]
                    system_str = "system" if module.is_system else "user"
                    pct = count / len(self.accesses) * 100
                    print(f"  {name:25}: {count:6} accesses ({pct:4.1f}%) | {type_str:8} | {system_str}")
                else:
                    print(f"  {name:25}: {count:6} accesses | unknown module")


def main(
    trace_file: str = typer.Argument(..., help="JSONL trace file from w1mem"),
    top_n: int = typer.Option(15, "--top-n", help="number of top results to show in hotspot analysis"),
    modules: bool = typer.Option(False, "--modules", help="include detailed module information")
):
    """analyze w1mem memory traces"""
    try:
        analyzer = W1MemAnalyzer(trace_file)
        analyzer.load_trace()
        analyzer.print_summary()
        analyzer.print_hotspots(top_n)
        
        if modules:
            analyzer.print_modules()
            
    except KeyboardInterrupt:
        print("\nanalysis interrupted by user", file=sys.stderr)
        raise typer.Exit(1)
    except Exception as e:
        print(f"error: {e}", file=sys.stderr)
        raise typer.Exit(1)


if __name__ == '__main__':
    typer.run(main)
```

`scripts/w1rewind_view.py`:

```py
#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.8"
# dependencies = [
#     "typer",
#     "rich",
#     "zstandard",
# ]
# ///

"""w1rewind trace viewer (v6)"""

from __future__ import annotations

import struct
from dataclasses import dataclass, field
from pathlib import Path
from typing import Iterable, List, Optional, Union

import typer
from rich.console import Console
from rich.table import Table

try:
    import zstandard as zstd
except ImportError:  # pragma: no cover - optional dependency for compressed traces
    zstd = None

console = Console()
app = typer.Typer(add_completion=False, no_args_is_help=True)

MAGIC = b"W1RWND6\x00"
HEADER_STRUCT = struct.Struct("<8sHHIQII")
CHUNK_HEADER_STRUCT = struct.Struct("<II")
RECORD_HEADER_STRUCT = struct.Struct("<HHI")
U8 = struct.Struct("<B")
U16 = struct.Struct("<H")
U32 = struct.Struct("<I")
U64 = struct.Struct("<Q")

TRACE_FLAG_INSTRUCTIONS = 1 << 0
TRACE_FLAG_REGISTER_DELTAS = 1 << 1
TRACE_FLAG_MEMORY_ACCESS = 1 << 2
TRACE_FLAG_MEMORY_VALUES = 1 << 3
TRACE_FLAG_BOUNDARIES = 1 << 4
TRACE_FLAG_STACK_WINDOW = 1 << 5
TRACE_FLAG_BLOCKS = 1 << 6

COMPRESSION_NONE = 0
COMPRESSION_ZSTD = 1

RECORD_REGISTER_TABLE = 1
RECORD_MODULE_TABLE = 2
RECORD_THREAD_START = 3
RECORD_INSTRUCTION = 4
RECORD_REGISTER_DELTAS = 5
RECORD_MEMORY_ACCESS = 6
RECORD_BOUNDARY = 7
RECORD_THREAD_END = 8
RECORD_BLOCK_DEFINITION = 9
RECORD_BLOCK_EXEC = 10


@dataclass
class TraceHeader:
    version: int
    architecture: int
    pointer_size: int
    flags: int
    compression: int
    chunk_size: int


@dataclass
class RegisterTableRecord:
    names: List[str]


@dataclass
class ModuleRecord:
    module_id: int
    base: int
    size: int
    permissions: int
    path: str


@dataclass
class ModuleTableRecord:
    modules: List[ModuleRecord]


@dataclass
class ThreadStartRecord:
    thread_id: int
    name: str


@dataclass
class InstructionRecord:
    sequence: int
    thread_id: int
    module_id: int
    module_offset: int
    size: int
    flags: int


@dataclass
class BlockDefinitionRecord:
    block_id: int
    module_id: int
    module_offset: int
    size: int


@dataclass
class BlockExecRecord:
    sequence: int
    thread_id: int
    block_id: int


@dataclass
class RegisterDelta:
    reg_id: int
    value: int


@dataclass
class RegisterDeltaRecord:
    sequence: int
    thread_id: int
    deltas: List[RegisterDelta]


@dataclass
class MemoryAccessRecord:
    sequence: int
    thread_id: int
    kind: int
    address: int
    size: int
    value_known: bool
    value_truncated: bool
    data: bytes = field(default_factory=bytes)


@dataclass
class BoundaryRecord:
    boundary_id: int
    sequence: int
    thread_id: int
    registers: List[RegisterDelta]
    stack_window: bytes
    reason: str


@dataclass
class ThreadEndRecord:
    thread_id: int


Record = Union[
    RegisterTableRecord,
    ModuleTableRecord,
    ThreadStartRecord,
    InstructionRecord,
    BlockDefinitionRecord,
    BlockExecRecord,
    RegisterDeltaRecord,
    MemoryAccessRecord,
    BoundaryRecord,
    ThreadEndRecord,
]


@dataclass
class TraceFile:
    header: TraceHeader
    register_table: List[str]
    module_table: List[ModuleRecord]
    block_table: List[BlockDefinitionRecord]
    records: List[Record]

    def per_thread_counts(self) -> dict[int, int]:
        counts: dict[int, int] = {}
        for record in self.records:
            thread_id = _record_thread_id(record)
            if thread_id is None:
                continue
            counts[thread_id] = counts.get(thread_id, 0) + 1
        return counts


class TraceParserError(RuntimeError):
    pass


class RecordReader:
    def __init__(self, data: bytes) -> None:
        self._data = memoryview(data)
        self._cursor = 0

    def _read(self, struct_obj: struct.Struct) -> int:
        try:
            value = struct_obj.unpack_from(self._data, self._cursor)[0]
        except struct.error as exc:
            raise TraceParserError("truncated record payload") from exc
        self._cursor += struct_obj.size
        return value

    def read_u8(self) -> int:
        return self._read(U8)

    def read_u16(self) -> int:
        return self._read(U16)

    def read_u32(self) -> int:
        return self._read(U32)

    def read_u64(self) -> int:
        return self._read(U64)

    def read_bytes(self, size: int) -> bytes:
        if self._cursor + size > len(self._data):
            raise TraceParserError("truncated record payload")
        data = bytes(self._data[self._cursor : self._cursor + size])
        self._cursor += size
        return data

    def read_string(self) -> str:
        length = self.read_u16()
        raw = self.read_bytes(length)
        return raw.decode("utf-8", errors="replace")


class TraceParser:
    def __init__(self, data: bytes) -> None:
        self._data = memoryview(data)
        self._cursor = 0

    def parse(self) -> TraceFile:
        try:
            magic, version, arch, pointer_size, flags, compression, chunk_size = HEADER_STRUCT.unpack_from(
                self._data, self._cursor
            )
        except struct.error as exc:
            raise TraceParserError("truncated trace header") from exc
        self._cursor += HEADER_STRUCT.size

        if magic != MAGIC:
            raise TraceParserError(f"unexpected magic {magic!r}; not a v6 w1rewind trace")
        if version != 6:
            raise TraceParserError(f"unsupported trace version {version} (expected v6)")
        if chunk_size == 0:
            raise TraceParserError("invalid chunk size in trace header")

        header = TraceHeader(
            version=version,
            architecture=arch,
            pointer_size=pointer_size,
            flags=flags,
            compression=compression,
            chunk_size=chunk_size,
        )

        record_stream = self._expand_record_stream(compression)
        self._data = memoryview(record_stream)
        self._cursor = 0
        register_table: List[str] = []
        module_table: List[ModuleRecord] = []
        block_table: List[BlockDefinitionRecord] = []
        records: List[Record] = []

        while self._cursor < len(self._data):
            record = self._parse_record(register_table, module_table, block_table)
            records.append(record)

        return TraceFile(
            header=header,
            register_table=register_table,
            module_table=module_table,
            block_table=block_table,
            records=records,
        )

    def _expand_record_stream(self, compression: int) -> bytes:
        record_data = bytearray()
        decompressor = None
        if compression == COMPRESSION_ZSTD:
            if zstd is None:
                raise TraceParserError("trace uses zstd compression but zstandard is not installed")
            decompressor = zstd.ZstdDecompressor()

        while self._cursor < len(self._data):
            if self._cursor + CHUNK_HEADER_STRUCT.size > len(self._data):
                raise TraceParserError("truncated chunk header")
            compressed_size, uncompressed_size = CHUNK_HEADER_STRUCT.unpack_from(
                self._data, self._cursor
            )
            self._cursor += CHUNK_HEADER_STRUCT.size
            if compressed_size == 0 or uncompressed_size == 0:
                raise TraceParserError("invalid chunk header")
            if self._cursor + compressed_size > len(self._data):
                raise TraceParserError("truncated chunk payload")
            payload = bytes(self._data[self._cursor : self._cursor + compressed_size])
            self._cursor += compressed_size

            if compression == COMPRESSION_NONE:
                if compressed_size != uncompressed_size:
                    raise TraceParserError("uncompressed chunk size mismatch")
                record_data.extend(payload)
                continue

            if compression != COMPRESSION_ZSTD or decompressor is None:
                raise TraceParserError("unsupported trace compression mode")

            chunk = decompressor.decompress(payload, uncompressed_size)
            if len(chunk) != uncompressed_size:
                raise TraceParserError("zstd decompressed size mismatch")
            record_data.extend(chunk)

        return bytes(record_data)

    def _parse_record(
        self,
        register_table: List[str],
        module_table: List[ModuleRecord],
        block_table: List[BlockDefinitionRecord],
    ) -> Record:
        start = self._cursor
        try:
            kind, flags, size = RECORD_HEADER_STRUCT.unpack_from(
                self._data, self._cursor
            )
        except struct.error as exc:
            raise TraceParserError(f"truncated record header at offset {start}") from exc
        self._cursor += RECORD_HEADER_STRUCT.size

        if self._cursor + size > len(self._data):
            raise TraceParserError("truncated record payload")

        payload = bytes(self._data[self._cursor : self._cursor + size])
        self._cursor += size
        reader = RecordReader(payload)

        if kind == RECORD_REGISTER_TABLE:
            count = reader.read_u16()
            names = [reader.read_string() for _ in range(count)]
            register_table.clear()
            register_table.extend(names)
            return RegisterTableRecord(names=names)

        if kind == RECORD_MODULE_TABLE:
            count = reader.read_u32()
            modules = []
            for _ in range(count):
                module_id = reader.read_u64()
                base = reader.read_u64()
                size_value = reader.read_u64()
                permissions = reader.read_u32()
                path = reader.read_string()
                modules.append(
                    ModuleRecord(
                        module_id=module_id,
                        base=base,
                        size=size_value,
                        permissions=permissions,
                        path=path,
                    )
                )
            module_table.clear()
            module_table.extend(modules)
            return ModuleTableRecord(modules=modules)

        if kind == RECORD_THREAD_START:
            thread_id = reader.read_u64()
            name = reader.read_string()
            return ThreadStartRecord(thread_id=thread_id, name=name)

        if kind == RECORD_INSTRUCTION:
            sequence = reader.read_u64()
            thread_id = reader.read_u64()
            module_id = reader.read_u64()
            module_offset = reader.read_u64()
            size_value = reader.read_u32()
            flags_value = reader.read_u32()
            return InstructionRecord(
                sequence=sequence,
                thread_id=thread_id,
                module_id=module_id,
                module_offset=module_offset,
                size=size_value,
                flags=flags_value,
            )

        if kind == RECORD_BLOCK_DEFINITION:
            block_id = reader.read_u64()
            module_id = reader.read_u64()
            module_offset = reader.read_u64()
            size_value = reader.read_u32()
            record = BlockDefinitionRecord(
                block_id=block_id,
                module_id=module_id,
                module_offset=module_offset,
                size=size_value,
            )
            block_table.append(record)
            return record

        if kind == RECORD_BLOCK_EXEC:
            sequence = reader.read_u64()
            thread_id = reader.read_u64()
            block_id = reader.read_u64()
            return BlockExecRecord(sequence=sequence, thread_id=thread_id, block_id=block_id)

        if kind == RECORD_REGISTER_DELTAS:
            sequence = reader.read_u64()
            thread_id = reader.read_u64()
            count = reader.read_u16()
            deltas = []
            for _ in range(count):
                reg_id = reader.read_u16()
                value = reader.read_u64()
                deltas.append(RegisterDelta(reg_id=reg_id, value=value))
            return RegisterDeltaRecord(sequence=sequence, thread_id=thread_id, deltas=deltas)

        if kind == RECORD_MEMORY_ACCESS:
            sequence = reader.read_u64()
            thread_id = reader.read_u64()
            access_kind = reader.read_u8()
            value_known = reader.read_u8() != 0
            value_truncated = reader.read_u8() != 0
            reader.read_u8()
            address = reader.read_u64()
            size_value = reader.read_u32()
            data_size = reader.read_u32()
            data = reader.read_bytes(data_size) if data_size else b""
            return MemoryAccessRecord(
                sequence=sequence,
                thread_id=thread_id,
                kind=access_kind,
                address=address,
                size=size_value,
                value_known=value_known,
                value_truncated=value_truncated,
                data=data,
            )

        if kind == RECORD_BOUNDARY:
            boundary_id = reader.read_u64()
            sequence = reader.read_u64()
            thread_id = reader.read_u64()
            count = reader.read_u16()
            registers = []
            for _ in range(count):
                reg_id = reader.read_u16()
                value = reader.read_u64()
                registers.append(RegisterDelta(reg_id=reg_id, value=value))
            stack_size = reader.read_u32()
            stack_window = reader.read_bytes(stack_size) if stack_size else b""
            reason = reader.read_string()
            return BoundaryRecord(
                boundary_id=boundary_id,
                sequence=sequence,
                thread_id=thread_id,
                registers=registers,
                stack_window=stack_window,
                reason=reason,
            )

        if kind == RECORD_THREAD_END:
            thread_id = reader.read_u64()
            return ThreadEndRecord(thread_id=thread_id)

        raise TraceParserError(f"unsupported record kind {kind} at offset {start}")


def load_trace(path: Path) -> TraceFile:
    try:
        data = path.read_bytes()
    except OSError as exc:
        raise TraceParserError(f"failed to read trace: {exc}") from exc
    parser = TraceParser(data)
    return parser.parse()


def format_architecture(arch: int) -> str:
    mapping = {
        0x0101: "x86_64",
        0x0102: "x86",
        0x0201: "aarch64",
        0x0202: "arm",
    }
    return mapping.get(arch, f"0x{arch:04x}")


def format_flags(flags: int) -> str:
    parts = []
    if flags & TRACE_FLAG_INSTRUCTIONS:
        parts.append("instructions")
    if flags & TRACE_FLAG_BLOCKS:
        parts.append("blocks")
    if flags & TRACE_FLAG_REGISTER_DELTAS:
        parts.append("register_deltas")
    if flags & TRACE_FLAG_MEMORY_ACCESS:
        parts.append("memory_access")
    if flags & TRACE_FLAG_MEMORY_VALUES:
        parts.append("memory_values")
    if flags & TRACE_FLAG_BOUNDARIES:
        parts.append("boundaries")
    if flags & TRACE_FLAG_STACK_WINDOW:
        parts.append("stack_window")
    return ", ".join(parts) if parts else "none"


def format_compression(compression: int) -> str:
    if compression == COMPRESSION_NONE:
        return "none"
    if compression == COMPRESSION_ZSTD:
        return "zstd"
    return f"0x{compression:x}"


def _record_thread_id(record: Record) -> Optional[int]:
    if isinstance(
        record,
        (
            InstructionRecord,
            BlockExecRecord,
            RegisterDeltaRecord,
            MemoryAccessRecord,
            BoundaryRecord,
        ),
    ):
        return record.thread_id
    if isinstance(record, (ThreadStartRecord, ThreadEndRecord)):
        return record.thread_id
    return None


def _module_by_id(modules: List[ModuleRecord]) -> dict[int, ModuleRecord]:
    return {module.module_id: module for module in modules}


def _block_by_id(blocks: List[BlockDefinitionRecord]) -> dict[int, BlockDefinitionRecord]:
    return {block.block_id: block for block in blocks}


@app.command()
def summary(
    trace_path: Path = typer.Argument(
        ..., exists=True, readable=True, help="Path to a w1rewind trace file"
    ),
) -> None:
    """Print a high-level overview of the trace."""
    trace = load_trace(trace_path)

    console.print(f"[bold]trace[/] {trace_path}")
    console.print(f"  version     : {trace.header.version}")
    console.print(f"  architecture: {format_architecture(trace.header.architecture)}")
    console.print(f"  pointer size: {trace.header.pointer_size}")
    console.print(f"  flags       : {format_flags(trace.header.flags)}")
    console.print(f"  compression : {format_compression(trace.header.compression)}")
    console.print(f"  chunk size  : {trace.header.chunk_size}")
    console.print(f"  records     : {len(trace.records)}")

    flow = "unknown"
    if trace.header.flags & TRACE_FLAG_BLOCKS:
        flow = "blocks"
    elif trace.header.flags & TRACE_FLAG_INSTRUCTIONS:
        flow = "instructions"
    console.print(f"  flow        : {flow}")

    instruction_count = sum(isinstance(r, InstructionRecord) for r in trace.records)
    block_exec_count = sum(isinstance(r, BlockExecRecord) for r in trace.records)
    boundary_count = sum(isinstance(r, BoundaryRecord) for r in trace.records)
    memory_reads = sum(
        isinstance(r, MemoryAccessRecord) and r.kind == 1 for r in trace.records
    )
    memory_writes = sum(
        isinstance(r, MemoryAccessRecord) and r.kind == 2 for r in trace.records
    )

    if flow == "blocks":
        console.print(f"  blocks      : {block_exec_count}")
        console.print(f"  block defs  : {len(trace.block_table)}")
    else:
        console.print(f"  instructions: {instruction_count}")

    console.print(f"  boundaries  : {boundary_count}")
    if memory_reads or memory_writes:
        console.print(f"  memory reads : {memory_reads}")
        console.print(f"  memory writes: {memory_writes}")

    thread_counts = trace.per_thread_counts()
    if thread_counts:
        table = Table(title="Records per thread", show_lines=False)
        table.add_column("thread id", justify="right")
        table.add_column("records", justify="right")
        for thread_id, count in sorted(thread_counts.items()):
            table.add_row(str(thread_id), str(count))
        console.print(table)


@app.command()
def events(
    trace_path: Path = typer.Argument(
        ..., exists=True, readable=True, help="Path to a w1rewind trace file"
    ),
    thread_id: Optional[int] = typer.Option(
        None, help="Limit output to a specific thread id"
    ),
    limit: Optional[int] = typer.Option(10, help="Maximum number of records to display"),
    show_reads: bool = typer.Option(False, help="Include memory read records"),
    show_writes: bool = typer.Option(True, help="Include memory write records"),
) -> None:
    """Pretty-print trace records."""
    trace = load_trace(trace_path)
    module_lookup = _module_by_id(trace.module_table)
    block_lookup = _block_by_id(trace.block_table)

    records = list(
        _iter_records(
            trace.records,
            thread_id=thread_id,
            limit=limit,
            show_reads=show_reads,
            show_writes=show_writes,
        )
    )
    if not records:
        console.print("[yellow]no records matched filters[/]")
        return

    table = Table(title=f"Records ({len(records)} displayed)")
    table.add_column("type", justify="left")
    table.add_column("seq", justify="right")
    table.add_column("thread", justify="right")
    table.add_column("addr", justify="right")
    table.add_column("size", justify="right")
    table.add_column("info", justify="left")

    for record in records:
        row = _record_row(record, module_lookup, block_lookup)
        table.add_row(*row)

    console.print(table)


def _iter_records(
    records: Iterable[Record],
    *,
    thread_id: Optional[int],
    limit: Optional[int],
    show_reads: bool,
    show_writes: bool,
) -> Iterable[Record]:
    count = 0
    for record in records:
        if isinstance(record, (RegisterTableRecord, ModuleTableRecord, BlockDefinitionRecord)):
            continue
        if isinstance(record, MemoryAccessRecord):
            if record.kind == 1 and not show_reads:
                continue
            if record.kind == 2 and not show_writes:
                continue
        if thread_id is not None:
            rec_thread = _record_thread_id(record)
            if rec_thread is None or rec_thread != thread_id:
                continue
        yield record
        count += 1
        if limit is not None and count >= limit:
            break


def _record_row(
    record: Record,
    module_lookup: dict[int, ModuleRecord],
    block_lookup: dict[int, BlockDefinitionRecord],
) -> List[str]:
    if isinstance(record, ThreadStartRecord):
        return ["thread_start", "", str(record.thread_id), "", "", record.name]
    if isinstance(record, ThreadEndRecord):
        return ["thread_end", "", str(record.thread_id), "", "", ""]
    if isinstance(record, InstructionRecord):
        module = module_lookup.get(record.module_id)
        addr = _format_instruction_addr(record, module)
        info = ""
        if module:
            info = Path(module.path).name
        return ["inst", str(record.sequence), str(record.thread_id), addr, str(record.size), info]
    if isinstance(record, BlockExecRecord):
        block = block_lookup.get(record.block_id)
        addr, size, info = _format_block_info(block, module_lookup)
        return ["block", str(record.sequence), str(record.thread_id), addr, size, info]
    if isinstance(record, RegisterDeltaRecord):
        return [
            "regs",
            str(record.sequence),
            str(record.thread_id),
            "",
            str(len(record.deltas)),
            "",
        ]
    if isinstance(record, MemoryAccessRecord):
        kind = "read" if record.kind == 1 else "write"
        info = kind
        if record.value_known:
            info += f" data={len(record.data)}"
            if record.value_truncated:
                info += " truncated"
        return [
            "mem",
            str(record.sequence),
            str(record.thread_id),
            f"0x{record.address:x}",
            str(record.size),
            info,
        ]
    if isinstance(record, BoundaryRecord):
        info = (
            f"id={record.boundary_id} regs={len(record.registers)} "
            f"stack={len(record.stack_window)} reason={record.reason}"
        )
        return [
            "boundary",
            str(record.sequence),
            str(record.thread_id),
            "",
            "",
            info,
        ]
    return ["unknown", "", "", "", "", ""]


def _format_instruction_addr(record: InstructionRecord, module: Optional[ModuleRecord]) -> str:
    if record.module_id == 0:
        return f"0x{record.module_offset:x}"
    if module is None:
        return f"m{record.module_id}+0x{record.module_offset:x}"
    absolute = module.base + record.module_offset
    return f"0x{absolute:x}"


def _format_block_info(
    block: Optional[BlockDefinitionRecord],
    module_lookup: dict[int, ModuleRecord],
) -> tuple[str, str, str]:
    if block is None:
        return "", "", ""
    module = module_lookup.get(block.module_id)
    if block.module_id == 0:
        addr = f"0x{block.module_offset:x}"
    elif module is None:
        addr = f"m{block.module_id}+0x{block.module_offset:x}"
    else:
        addr = f"0x{module.base + block.module_offset:x}"
    info = Path(module.path).name if module else ""
    return addr, str(block.size), info


if __name__ == "__main__":
    app()

```

`scripts/w1script/coverage_tracker.lua`:

```lua
-- coverage tracker
-- counts unique basic blocks and total block hits
local discovered_blocks = {}
local total_block_hits = 0
local unique_block_count = 0

local tracer = {}

local function on_basic_block(vm, state, gpr, fpr)
    local block_address = state.basicBlockStart or 0
    local block_key = w1.util.format_address(block_address)

    total_block_hits = total_block_hits + 1

    if not discovered_blocks[block_key] then
        discovered_blocks[block_key] = true
        unique_block_count = unique_block_count + 1
    end

    return w1.enum.vm_action.CONTINUE
end

function tracer.init()
    w1.on(w1.event.BASIC_BLOCK_ENTRY, on_basic_block)
end

function tracer.shutdown()
    local avg_hits = unique_block_count > 0 and (total_block_hits / unique_block_count) or 0

    w1.log.info("coverage summary:")
    w1.log.info("  unique blocks: " .. unique_block_count)
    w1.log.info("  total hits: " .. total_block_hits)
    w1.log.info("  average hits per block: " .. string.format("%.2f", avg_hits))
end

return tracer

```

`scripts/w1script/instruction_tracer.lua`:

```lua
-- instruction tracer with disassembly
-- logs every instruction with address and assembly code
local instruction_count = 0

local tracer = {}

local function on_instruction(vm, gpr, fpr)
    instruction_count = instruction_count + 1

    local pc = w1.reg.pc(gpr) or 0
    local disasm = w1.inst.disasm(vm) or "<unknown>"

    w1.log.info(w1.util.format_address(pc) .. ": " .. disasm)
    return w1.enum.vm_action.CONTINUE
end

function tracer.init()
    w1.on(w1.event.INSTRUCTION_PRE, on_instruction)
end

function tracer.shutdown()
    w1.log.info("traced " .. instruction_count .. " instructions")
end

return tracer

```

`scripts/w1script/jsonl_tracer.lua`:

```lua
-- jsonl tracer
-- demonstrates jsonl streaming output for execution tracing
local tracer = {}

local stats = {
    blocks = 0,
    calls = 0,
    returns = 0
}

function tracer.init()
    local output_file = w1.config.output or "trace.jsonl"
    w1.log.info("initializing jsonl tracer, output file: " .. output_file)
    w1.output.open(output_file, {
        tracer = "jsonl_tracer",
        version = "1.0"
    })

    w1.on(w1.event.BASIC_BLOCK_ENTRY, function(vm, state, gpr, fpr)
        stats.blocks = stats.blocks + 1

        if stats.blocks <= 100 then
            w1.output.write({
                type = "block",
                address = w1.util.format_address(state.basicBlockStart),
                size = state.basicBlockEnd - state.basicBlockStart
            })
        end

        return w1.enum.vm_action.CONTINUE
    end)

    w1.on(w1.event.EXEC_TRANSFER_CALL, function(vm, state, gpr, fpr)
        stats.calls = stats.calls + 1

        local pc = w1.reg.pc(gpr) or 0
        w1.output.write({
            type = "call",
            from = w1.util.format_address(state.sequenceStart),
            to = w1.util.format_address(pc),
            from_module = w1.module.name(state.sequenceStart),
            to_module = w1.module.name(pc)
        })

        return w1.enum.vm_action.CONTINUE
    end)

    w1.on(w1.event.EXEC_TRANSFER_RETURN, function(vm, state, gpr, fpr)
        stats.returns = stats.returns + 1

        local pc = w1.reg.pc(gpr) or 0
        w1.output.write({
            type = "return",
            from = w1.util.format_address(state.sequenceStart),
            to = w1.util.format_address(pc),
            from_module = w1.module.name(state.sequenceStart)
        })

        return w1.enum.vm_action.CONTINUE
    end)
end

function tracer.shutdown()
    w1.output.write({
        type = "stats",
        total_blocks = stats.blocks,
        total_calls = stats.calls,
        total_returns = stats.returns
    })

    w1.output.close()

    w1.log.info("trace complete: " .. stats.blocks .. " blocks, " .. stats.calls .. " calls, " .. stats.returns ..
                    " returns")
end

return tracer

```

`scripts/w1script/memory_tracer.lua`:

```lua
-- memory access tracer with values
-- monitors memory read and write operations with detailed logging

local read_count = 0
local write_count = 0

local tracer = {}

local function format_value(access)
    if not access.value_known or access.value == nil then
        return "<??>"
    end

    local hex = w1.util.format_hex(access.value, {prefix = true, width = access.size * 2})
    return hex or tostring(access.value)
end

local function log_memory_access(access_type, count, pc, address, size, value, instruction)
    local msg = string.format("%s #%d @ %s [%s] size=%d value=%s inst: %s",
        access_type,
        count,
        w1.util.format_address(pc),
        w1.util.format_address(address),
        size,
        value,
        instruction)
    w1.log.info(msg)
end

local function on_instruction(vm, gpr, fpr)
    local memory_accesses = w1.mem.accesses(vm)

    if #memory_accesses > 0 then
        local pc = w1.reg.pc(gpr) or 0
        local instruction = w1.inst.disasm(vm) or "<unknown>"

        for _, access in ipairs(memory_accesses) do
            local formatted_value = format_value(access)

            if access.is_read then
                read_count = read_count + 1
                log_memory_access("read", read_count, pc, access.address, access.size, formatted_value, instruction)
            end

            if access.is_write then
                write_count = write_count + 1
                log_memory_access("write", write_count, pc, access.address, access.size, formatted_value, instruction)
            end
        end
    end

    return w1.enum.vm_action.CONTINUE
end

function tracer.init()
    w1.on(w1.event.INSTRUCTION_POST, on_instruction)
end

function tracer.shutdown()
    local total_operations = read_count + write_count

    w1.log.info("memory operations summary:")
    w1.log.info(string.format("  reads: %d", read_count))
    w1.log.info(string.format("  writes: %d", write_count))
    w1.log.info(string.format("  total: %d", total_operations))
end

return tracer

```

`scripts/w1script/mnem_tracker.lua`:

```lua
-- mnemonic tracker
-- tracks specific instruction mnemonics using explicit callback registration

local mnemonic_counts = {}
local matched_instructions = 0
local unique_sites = {}
local arch_targets = {}

local default_mnemonics = {
    arm64 = {"B*", "BL*", "BR*", "BLR*", "RET*"},
    x64 = {"CALL*", "JMP*", "RET*", "TAI*"},
    x86 = {"CALL*", "JMP*", "RET*", "TAI*"}
}

local tracer = {}

local function parse_mnemonic(vm)
    local disasm = w1.inst.disasm(vm) or ""
    return disasm:match("^%s*(%S+)") or ""
end

local function register_mnemonic(pattern)
    w1.on(w1.event.INSTRUCTION_PRE, function(vm, gpr, fpr)
        local address = w1.reg.pc(gpr) or 0
        local actual_mnemonic = parse_mnemonic(vm)

        matched_instructions = matched_instructions + 1
        if not unique_sites[address] then
            unique_sites[address] = true
        end

        mnemonic_counts[pattern] = (mnemonic_counts[pattern] or 0) + 1

        w1.log.debug(string.format("mnemonic matched: %s (address=0x%016x, actual=%s)",
            pattern, address, actual_mnemonic))

        return w1.enum.vm_action.CONTINUE
    end, {
        mnemonic = pattern
    })
end

function tracer.init()
    local arch = w1.util.architecture()
    w1.log.info("mnemonic tracker initialized for " .. arch)

    arch_targets = default_mnemonics[arch] or {}

    for _, mnemonic in ipairs(arch_targets) do
        mnemonic_counts[mnemonic] = 0
        register_mnemonic(mnemonic)
    end

    w1.log.info("registered " .. #arch_targets .. " mnemonic callbacks")
end

function tracer.shutdown()
    local unique_count = 0
    for _ in pairs(unique_sites) do
        unique_count = unique_count + 1
    end

    w1.log.info("mnemonic summary:")
    w1.log.info("  matched instructions: " .. matched_instructions)
    w1.log.info("  unique sites: " .. unique_count)
    w1.log.info("  target patterns: " .. #arch_targets)

    local sorted = {}
    for mnemonic, count in pairs(mnemonic_counts) do
        if count > 0 then
            table.insert(sorted, {mnemonic = mnemonic, count = count})
        end
    end
    table.sort(sorted, function(a, b) return a.count > b.count end)

    if #sorted > 0 then
        w1.log.info("  breakdown by pattern:")
        for _, entry in ipairs(sorted) do
            local pct = matched_instructions > 0 and (entry.count / matched_instructions * 100) or 0
            w1.log.info(string.format("    %s: %d (%.1f%%)", entry.mnemonic, entry.count, pct))
        end
    end
end

return tracer

```

`scripts/w1script/symbol_resolver.lua`:

```lua
-- symbol resolution demo
-- resolves and displays symbol information during execution
local first_run = true
local instruction_count = 0
local unique_symbols = {}

local tracer = {}

local function on_instruction(vm, gpr, fpr)
    instruction_count = instruction_count + 1

    local pc = w1.reg.pc(gpr) or 0
    local sym = w1.symbol.resolve_address(pc)
    if sym then
        unique_symbols[sym.name] = true
        local disasm = w1.inst.disasm(vm) or "<unknown>"
        w1.log.info(string.format("%s: %s+0x%x: %s", w1.util.format_address(pc), sym.name, sym.offset, disasm))
    end

    if first_run then
        first_run = false

        w1.log.info("symbol backend: " .. w1.symbol.backend())
    end

    return w1.enum.vm_action.CONTINUE
end

function tracer.init()
    w1.on(w1.event.INSTRUCTION_PRE, on_instruction)
end

function tracer.shutdown()
    local symbol_count = 0
    for _ in pairs(unique_symbols) do
        symbol_count = symbol_count + 1
    end

    w1.log.info(string.format("traced %d instructions in %d unique functions", instruction_count, symbol_count))
end

return tracer

```

`scripts/w1script/xfer_tracker.lua`:

```lua
-- execution transfer tracker
-- tracks function calls and returns with detailed logging and module info

local call_stack = {}
local total_calls = 0
local total_returns = 0
local unique_call_targets = {}
local unique_return_sources = {}
local max_call_depth = 0
local current_call_depth = 0
local module_call_stats = {}
local module_return_stats = {}

local tracer = {}

local function on_call(vm, state, gpr, fpr)
    local pc = w1.reg.pc(gpr) or 0
    local source_addr = w1.util.format_address(state.sequenceStart)
    local target_addr = w1.util.format_address(pc)
    local thread_id = w1.util.thread_id() or 0

    local source_module = w1.module.name(state.sequenceStart)
    local target_module = w1.module.name(pc)

    total_calls = total_calls + 1
    current_call_depth = current_call_depth + 1

    if not unique_call_targets[target_addr] then
        unique_call_targets[target_addr] = true
    end

    module_call_stats[target_module] = (module_call_stats[target_module] or 0) + 1

    if current_call_depth > max_call_depth then
        max_call_depth = current_call_depth
    end

    table.insert(call_stack, {
        source = source_addr,
        target = target_addr,
        source_module = source_module,
        target_module = target_module,
        depth = current_call_depth
    })

    w1.log.info(string.format("call: %s (%s) -> %s (%s) (depth: %d, tid: %d)",
        source_addr, source_module, target_addr, target_module, current_call_depth, thread_id))

    return w1.enum.vm_action.CONTINUE
end

local function on_return(vm, state, gpr, fpr)
    local pc = w1.reg.pc(gpr) or 0
    local source_addr = w1.util.format_address(state.sequenceStart)
    local target_addr = w1.util.format_address(pc)
    local thread_id = w1.util.thread_id() or 0

    local source_module = w1.module.name(state.sequenceStart)
    local target_module = w1.module.name(pc)

    total_returns = total_returns + 1
    current_call_depth = math.max(0, current_call_depth - 1)

    if not unique_return_sources[source_addr] then
        unique_return_sources[source_addr] = true
    end

    module_return_stats[source_module] = (module_return_stats[source_module] or 0) + 1

    local call_info = nil
    if #call_stack > 0 then
        call_info = table.remove(call_stack)
    end

    if call_info then
        w1.log.info(string.format(
            "return: %s (%s) -> %s (%s) (from call %s -> %s at depth %d, tid: %d)",
            source_addr, source_module, target_addr, target_module,
            call_info.source_module, call_info.target_module, call_info.depth, thread_id
        ))
    else
        w1.log.info(string.format("return: %s (%s) -> %s (%s) (unmatched return, tid: %d)",
            source_addr, source_module, target_addr, target_module, thread_id))
    end

    return w1.enum.vm_action.CONTINUE
end

function tracer.init()
    w1.on(w1.event.EXEC_TRANSFER_CALL, on_call)
    w1.on(w1.event.EXEC_TRANSFER_RETURN, on_return)
end

function tracer.shutdown()
    local unique_call_count = 0
    for _ in pairs(unique_call_targets) do
        unique_call_count = unique_call_count + 1
    end

    local unique_return_count = 0
    for _ in pairs(unique_return_sources) do
        unique_return_count = unique_return_count + 1
    end

    w1.log.info("execution transfer summary:")
    w1.log.info("  total calls: " .. total_calls)
    w1.log.info("  total returns: " .. total_returns)
    w1.log.info("  unique call targets: " .. unique_call_count)
    w1.log.info("  unique return sources: " .. unique_return_count)
    w1.log.info("  max call depth: " .. max_call_depth)
    w1.log.info("  final call depth: " .. current_call_depth)
    w1.log.info("  unmatched calls: " .. #call_stack)
    w1.log.info("  total modules discovered: " .. w1.module.count())

    w1.log.info("module call statistics:")
    for module, count in pairs(module_call_stats) do
        w1.log.info(string.format("  %s: %d calls", module, count))
    end

    w1.log.info("module return statistics:")
    for module, count in pairs(module_return_stats) do
        w1.log.info(string.format("  %s: %d returns", module, count))
    end
end

return tracer

```

`scripts/w1trace_stats.py`:

```py
#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.8"
# dependencies = [
#     "typer",
# ]
# ///

"""
w1trace stats - minimalist analyzer for w1trace instruction traces

analyzes jsonl traces from w1trace to extract:
- execution statistics and module coverage
- control flow patterns (when tracked)
- hot code regions and instruction addresses

usage:
    python3 w1trace_stats.py <trace.jsonl>
"""

import json
import sys
from collections import Counter, defaultdict
from typing import Dict, List, Optional, Tuple

import typer


class TraceStats:
    """analyze w1trace jsonl output"""

    def __init__(self, trace_file: str):
        self.trace_file = trace_file
        self.modules: List[Dict] = []
        self.module_map: Dict[Tuple[int, int], str] = {}  # (base, end) -> name
        self.instructions: List[Dict] = []
        self.branches: List[Dict] = []
        self.has_control_flow = False

    def load(self) -> None:
        """load and parse trace file"""
        with open(self.trace_file, "r") as f:
            for line in f:
                try:
                    data = json.loads(line)
                    event_type = data.get("type")

                    if event_type == "metadata":
                        self.modules = data.get("modules", [])
                        self._build_module_map()
                        self.has_control_flow = data.get("config", {}).get(
                            "track_control_flow", False
                        )
                    elif event_type == "insn":
                        self.instructions.append(data)
                    elif event_type == "branch":
                        self.branches.append(data)
                except json.JSONDecodeError:
                    continue

    def _build_module_map(self) -> None:
        """build efficient module lookup map"""
        for module in self.modules:
            base = module["base"]
            end = base + module["size"]
            self.module_map[(base, end)] = module["name"]

    def resolve_module(self, address: int) -> str:
        """resolve address to module name"""
        for (base, end), name in self.module_map.items():
            if base <= address < end:
                return name
        return "unknown"

    def print_summary(self) -> None:
        """print trace summary"""
        print(f"\ntrace: {self.trace_file}")
        print(f"instructions: {len(self.instructions):,}")

        if self.has_control_flow:
            print(f"branches: {len(self.branches):,}")

            # branch type breakdown
            if self.branches:
                branch_types = Counter(
                    b.get("branch_type", "unknown") for b in self.branches
                )
                print("\ncontrol flow:")
                for btype, count in sorted(branch_types.items()):
                    pct = count / len(self.branches) * 100
                    print(f"  {btype:8}: {count:5} ({pct:5.1f}%)")

    def print_modules(self) -> None:
        """print module execution statistics"""
        if not self.instructions:
            return

        # count instructions per module
        module_counts = Counter()
        for insn in self.instructions:
            addr = insn["address"]
            module = self.resolve_module(addr)
            module_counts[module] += 1

        print("\nmodule execution:")
        total = len(self.instructions)
        for module, count in module_counts.most_common(10):
            pct = count / total * 100
            print(f"  {module:30}: {count:7,} ({pct:5.1f}%)")

    def print_hotspots(self, top_n: int = 10) -> None:
        """identify hot code regions"""
        if not self.instructions:
            return

        # count instruction addresses
        addr_counts = Counter(insn["address"] for insn in self.instructions)

        print(f"\ntop {top_n} hot addresses:")
        for addr, count in addr_counts.most_common(top_n):
            module = self.resolve_module(addr)
            pct = count / len(self.instructions) * 100
            print(f"  0x{addr:016x}: {count:5} ({pct:5.1f}%) [{module}]")

    def print_flow_graph(self, limit: int = 20) -> None:
        """show control flow transitions"""
        if not self.branches or not self.has_control_flow:
            return

        print(f"\ncontrol flow graph (first {limit}):")
        for i, branch in enumerate(self.branches[:limit]):
            src = branch["source"]
            dst = branch["dest"]
            btype = branch.get("branch_type", "?")
            src_mod = self.resolve_module(src)
            dst_mod = self.resolve_module(dst)

            # show module transition if different
            if src_mod != dst_mod:
                print(
                    f"  {i:3}: {btype:4} 0x{src:08x} -> 0x{dst:08x} [{src_mod} -> {dst_mod}]"
                )
            else:
                print(f"  {i:3}: {btype:4} 0x{src:08x} -> 0x{dst:08x} [{src_mod}]")


def main(
    trace_file: str = typer.Argument(..., help="w1trace jsonl file"),
    hotspots: int = typer.Option(
        10, "--hot", "-h", help="number of hot addresses to show"
    ),
    flow: Optional[int] = typer.Option(
        None, "--flow", "-f", help="show control flow graph (limit entries)"
    ),
    modules: bool = typer.Option(
        True, "--modules/--no-modules", "-m/-M", help="show module statistics"
    ),
):
    """analyze w1trace instruction traces"""

    # load and analyze
    stats = TraceStats(trace_file)
    stats.load()

    # display results
    stats.print_summary()

    if modules:
        stats.print_modules()

    stats.print_hotspots(hotspots)

    if flow is not None:
        stats.print_flow_graph(flow if flow > 0 else 20)


if __name__ == "__main__":
    typer.run(main)

```

`src/p01s0n/CMakeLists.txt`:

```txt
# p01s0n - preload injection library for dynamic patching
# this library gets injected into target processes and applies patches at runtime

w1_dep_lua()
w1_dep_redlog()

if(WITNESS_SCRIPT)
    # build as shared library for injection
    w1_add_shared_library(p01s0n
        p01s0n.cpp
        p01s0n.hpp
    )
    add_library(w1::p01s0n ALIAS p01s0n)

    # link p1ll as static library
    target_link_libraries(p01s0n PRIVATE
        p1ll_script
        redlog::redlog
    )

    # remove lib prefix and set platform-specific properties like tracers
    set_target_properties(p01s0n PROPERTIES 
        PREFIX ""  # no lib prefix
    )

    if(APPLE)
        set_target_properties(p01s0n PROPERTIES MACOSX_RPATH TRUE)
    endif()

    # export symbols for dynamic loading
    if(WIN32)
        target_compile_definitions(p01s0n PRIVATE
            P01S0N_EXPORTS
        )
    endif()

    # install target
    install(TARGETS p01s0n
        LIBRARY DESTINATION lib
        RUNTIME DESTINATION bin
        COMPONENT ${W1_INSTALL_COMPONENT}
    )
    
    message(STATUS "p01s0n dynamic injection library configured")
    
else()
    message(STATUS "p01s0n library skipped - lua scripting not enabled")
endif()

```

`src/p01s0n/p01s0n.cpp`:

```cpp
#include "p01s0n.hpp"
#include "p01s0n_config.hpp"

#include <cstdlib>
#include <iostream>
#include <filesystem>
#include <fstream>

#include <redlog.hpp>
#include "p1ll/p1ll.hpp"
#include "p1ll/scripting/script_engine_factory.hpp"

namespace p01s0n {

int p01s0n_run() {
  p01s0n_config config = p01s0n_config::discover();

  if (config.verbose >= 4) {
    redlog::set_level(redlog::level::pedantic);
  } else if (config.verbose >= 3) {
    redlog::set_level(redlog::level::debug);
  } else if (config.verbose >= 2) {
    redlog::set_level(redlog::level::trace);
  } else if (config.verbose >= 1) {
    redlog::set_level(redlog::level::verbose);
  } else {
    redlog::set_level(redlog::level::info);
  }

  auto log = redlog::get_logger("p01s0n");

  log.inf("p01s0n dynamic patcher starting", redlog::field("config_source", config.source_string()));

  if (config.script_path.empty()) {
    log.warn("no cure script configured");
    return 0;
  }

  log.inf("found cure script", redlog::field("path", config.script_path));

  if (!std::filesystem::exists(config.script_path)) {
    log.err("script file does not exist", redlog::field("path", config.script_path));
    return 1;
  }

  try {
    auto session = p1ll::engine::session::for_process();

    log.inf("executing dynamic cure script", redlog::field("script", config.script_path));

    std::ifstream file(config.script_path);
    if (!file.is_open()) {
      log.err("failed to open script file", redlog::field("path", config.script_path));
      return 1;
    }

    std::string script_content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
    file.close();

    auto script_engine = p1ll::scripting::ScriptEngineFactory::create();
    if (!script_engine) {
      log.err("failed to create script engine");
      return 1;
    }

    auto result = script_engine->execute_script(session, script_content);

    if (result.ok() && result.value.success) {
      log.inf(
          "dynamic cure completed successfully", redlog::field("patches_applied", result.value.applied),
          redlog::field("patches_failed", result.value.failed)
      );
      return 0;
    } else {
      log.err(
          "dynamic cure failed", redlog::field("patches_applied", result.value.applied),
          redlog::field("patches_failed", result.value.failed),
          redlog::field("error_count", result.value.diagnostics.size())
      );

      for (const auto& error : result.value.diagnostics) {
        log.err("cure error", redlog::field("message", error.message));
      }
      if (!result.ok() && !result.status_info.message.empty()) {
        log.err("cure error", redlog::field("message", result.status_info.message));
      }
      return 1;
    }

  } catch (const std::exception& e) {
    log.err("exception during dynamic cure", redlog::field("what", e.what()));
    return 1;
  }
}

} // namespace p01s0n

// platform-specific library initializers
#ifdef _WIN32
// windows dll entry point
#include <windows.h>

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
  switch (ul_reason_for_call) {
  case DLL_PROCESS_ATTACH:
    // run p01s0n when dll is loaded
    p01s0n::p01s0n_run();
    break;
  case DLL_THREAD_ATTACH:
  case DLL_THREAD_DETACH:
  case DLL_PROCESS_DETACH:
    break;
  }
  return TRUE;
}

#else
// unix (darwin/linux) constructor attribute
__attribute__((constructor)) static void p01s0n_init() {
  // run p01s0n when shared library is loaded
  p01s0n::p01s0n_run();
}

#endif

```

`src/p01s0n/p01s0n.hpp`:

```hpp
#pragma once

#include <string>

#ifdef _WIN32
#define P01S0N_API __declspec(dllexport)
#else
#define P01S0N_API __attribute__((visibility("default")))
#endif

namespace p01s0n {

/**
 * @brief Main entry point for p01s0n dynamic patching
 *
 * This function is called automatically when the library is loaded
 * via preload injection. It reads the P1LL_CURE environment variable
 * and applies the specified cure script to the current process.
 *
 * @return 0 on success, non-zero on failure
 */
P01S0N_API int p01s0n_run();

} // namespace p01s0n
```

`src/p01s0n/p01s0n_config.hpp`:

```hpp
#pragma once

#include <string>
#include <cstdlib>
#include <cstring>
#include <filesystem>
#include <fstream>
#include <vector>
#include <optional>
#include "../p1ll/scripting/script_engine_factory.hpp"

namespace p01s0n {

struct p01s0n_config {
  int verbose = 0;
  std::string script_path = "";

  enum class config_source { none, config_file, auto_discovery, environment };

  config_source source = config_source::none;

  static p01s0n_config from_environment() {
    p01s0n_config config;
    config.source = config_source::environment;

    const char* verbose_env = std::getenv("POISON_VERBOSE");
    if (verbose_env) {
      config.verbose = std::atoi(verbose_env);
    }

    const char* script_env = std::getenv("POISON_CURE");
    if (script_env) {
      config.script_path = script_env;
    }

    return config;
  }

  static std::optional<p01s0n_config> from_config_file(const std::string& config_path = "p01s0n.conf") {
    if (!std::filesystem::exists(config_path)) {
      return std::nullopt;
    }

    std::ifstream file(config_path);
    if (!file.is_open()) {
      return std::nullopt;
    }

    p01s0n_config config;
    config.source = config_source::config_file;
    std::string line;

    while (std::getline(file, line)) {
      if (line.empty() || line[0] == '#') {
        continue;
      }

      auto pos = line.find('=');
      if (pos == std::string::npos) {
        continue;
      }

      std::string key = line.substr(0, pos);
      std::string value = line.substr(pos + 1);

      // trim whitespace
      key.erase(0, key.find_first_not_of(" \t"));
      key.erase(key.find_last_not_of(" \t") + 1);
      value.erase(0, value.find_first_not_of(" \t"));
      value.erase(value.find_last_not_of(" \t") + 1);

      if (key == "script") {
        config.script_path = value;
      } else if (key == "verbose") {
        config.verbose = std::atoi(value.c_str());
      }
    }

    return config;
  }

  static std::optional<p01s0n_config> from_auto_discovery() {
    auto supported_extensions = p1ll::scripting::ScriptEngineFactory::get_supported_extensions();

    for (const auto& ext : supported_extensions) {
      std::string filename = "cure" + ext;
      if (std::filesystem::exists(filename)) {
        p01s0n_config config;
        config.source = config_source::auto_discovery;
        config.script_path = filename;
        return config;
      }
    }

    return std::nullopt;
  }

  static p01s0n_config discover() {
    if (auto config = from_config_file()) {
      return *config;
    }

    if (auto config = from_auto_discovery()) {
      return *config;
    }

    return from_environment();
  }

  const char* source_string() const {
    switch (source) {
    case config_source::config_file:
      return "config_file";
    case config_source::auto_discovery:
      return "auto_discovery";
    case config_source::environment:
      return "environment";
    default:
      return "none";
    }
  }
};

} // namespace p01s0n
```

`src/p1ll/CMakeLists.txt`:

```txt
# p1ll binary patching library

w1_dep_redlog()

# core library sources
set(P1LL_CORE_SOURCES
    engine/address_space.cpp
    engine/apply.cpp
    engine/pattern.cpp
    engine/pattern_matcher.cpp
    engine/plan_builder.cpp
    engine/scanner.cpp
    engine/session.cpp
    engine/platform/platform.cpp
    engine/platform/process_memory_macos.cpp
    engine/platform/process_memory_linux.cpp
    engine/platform/process_memory_windows.cpp
    utils/hex_utils.cpp
    utils/hex_pattern.cpp
    utils/file_utils.cpp
    utils/pretty_hexdump.cpp
)

# p1ll_core static library (always available)
w1_add_static_library(p1ll_core ${P1LL_CORE_SOURCES})
add_library(p1ll::core ALIAS p1ll_core)
target_link_libraries(p1ll_core PUBLIC redlog::redlog)
target_include_directories(p1ll_core
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}
        ${CMAKE_CURRENT_SOURCE_DIR}/..
)

# p1ll_script static library (optional)
if(WITNESS_SCRIPT)
    w1_dep_lua()
    if(WITNESS_SCRIPT_ENGINE STREQUAL "js")
        w1_dep_jnjs()
    endif()
    # scripting sources
    set(P1LL_SCRIPT_SOURCES
        scripting/script_engine_factory.cpp
    )
    
    # add engine-specific sources
    if(WITNESS_SCRIPT_ENGINE STREQUAL "lua")
        list(APPEND P1LL_SCRIPT_SOURCES scripting/lua/lua_engine.cpp)
    elseif(WITNESS_SCRIPT_ENGINE STREQUAL "js")
        list(APPEND P1LL_SCRIPT_SOURCES scripting/js/js_engine.cpp)
    endif()
    
    w1_add_static_library(p1ll_script ${P1LL_SCRIPT_SOURCES})
    add_library(p1ll::script ALIAS p1ll_script)
    target_link_libraries(p1ll_script PUBLIC p1ll_core PRIVATE redlog::redlog)
    target_include_directories(p1ll_script
        PUBLIC
            ${CMAKE_CURRENT_SOURCE_DIR}
            ${CMAKE_CURRENT_SOURCE_DIR}/..
    )
    target_compile_definitions(p1ll_script PUBLIC P1LL_HAS_SCRIPTING=1)
    
    # configure engine-specific integration
    if(WITNESS_SCRIPT_ENGINE STREQUAL "lua")
        target_link_libraries(p1ll_script PUBLIC w1::lua)
        message(STATUS "p1ll_script configured with lua support")
    elseif(WITNESS_SCRIPT_ENGINE STREQUAL "js")
        target_link_libraries(p1ll_script PUBLIC w1::jnjs)
        target_compile_definitions(p1ll_script PRIVATE
            PILL_SCRIPT_ENGINE_JS=1
            PILL_HAS_JAVASCRIPT_SUPPORT=1
        )
        message(STATUS "p1ll_script configured with javascript support")
    endif()
else()
    message(STATUS "p1ll_core available (scripting disabled)")
endif()

# p1ll_c api wrapper (optional)
option(P1LL_BUILD_CAPI "Build C API wrapper for p1ll" OFF)

if(P1LL_BUILD_CAPI)
    add_subdirectory(capi)
    message(STATUS "p1ll c api enabled")
endif()

# p1ll_heur static library (optional)
if(WITNESS_ASMR)
    w1_dep_asmr()
    set(P1LL_HEUR_SOURCES
        heur/code_signature.cpp
    )

    w1_add_static_library(p1ll_heur ${P1LL_HEUR_SOURCES})
    add_library(p1ll::heur ALIAS p1ll_heur)
    target_link_libraries(p1ll_heur PUBLIC p1ll_core w1asmr)
    target_include_directories(p1ll_heur
        PUBLIC
            ${CMAKE_CURRENT_SOURCE_DIR}
            ${CMAKE_CURRENT_SOURCE_DIR}/..
    )
endif()

```

`src/p1ll/bindings/python/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.15)

project(p1ll_python LANGUAGES C CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

include(FetchContent)

get_filename_component(P1LL_SOURCE_DIR "${CMAKE_CURRENT_LIST_DIR}/../.." ABSOLUTE)
get_filename_component(W1TN3SS_ROOT "${P1LL_SOURCE_DIR}/../.." ABSOLUTE)

find_package(Python REQUIRED COMPONENTS Interpreter Development.Module)

set(NB_TEST OFF CACHE BOOL "disable nanobind tests" FORCE)
set(NB_CREATE_INSTALL_RULES OFF CACHE BOOL "disable nanobind install rules" FORCE)
FetchContent_Declare(
    nanobind
    GIT_REPOSITORY https://github.com/wjakob/nanobind.git
    GIT_TAG v2.10.2
    GIT_SUBMODULES_RECURSE ON
)
FetchContent_MakeAvailable(nanobind)

set(W1_BUILD_ALL OFF CACHE BOOL "disable full w1tn3ss build" FORCE)
set(W1_BUILD_P1LL ON CACHE BOOL "build p1ll component" FORCE)
set(WITNESS_SCRIPT OFF CACHE BOOL "disable scripting for standalone p1ll python build" FORCE)
set(P1LL_BUILD_CAPI OFF CACHE BOOL "disable p1ll c api for python build" FORCE)

add_subdirectory("${W1TN3SS_ROOT}" "${CMAKE_BINARY_DIR}/w1tn3ss")

nanobind_add_module(_p1ll
    "${CMAKE_CURRENT_LIST_DIR}/p1ll_python.cpp"
)
target_link_libraries(_p1ll PRIVATE p1ll_core)

set(P1LL_PYTHON_OUTPUT_DIR "${CMAKE_BINARY_DIR}/p1ll")
file(MAKE_DIRECTORY "${P1LL_PYTHON_OUTPUT_DIR}")
set_target_properties(_p1ll PROPERTIES
    LIBRARY_OUTPUT_DIRECTORY "${P1LL_PYTHON_OUTPUT_DIR}"
    RUNTIME_OUTPUT_DIRECTORY "${P1LL_PYTHON_OUTPUT_DIR}"
    ARCHIVE_OUTPUT_DIRECTORY "${P1LL_PYTHON_OUTPUT_DIR}"
)

add_custom_command(TARGET _p1ll POST_BUILD
    COMMAND "${CMAKE_COMMAND}" -E copy_if_different
            "${CMAKE_CURRENT_LIST_DIR}/p1ll/__init__.py"
            "${P1LL_PYTHON_OUTPUT_DIR}/__init__.py"
)

install(TARGETS _p1ll
    LIBRARY DESTINATION p1ll
    RUNTIME DESTINATION p1ll
    ARCHIVE DESTINATION p1ll
    COMPONENT ${W1_INSTALL_COMPONENT}
)
install(FILES "${CMAKE_CURRENT_LIST_DIR}/p1ll/__init__.py"
    DESTINATION p1ll
    COMPONENT ${W1_INSTALL_COMPONENT}
)

```

`src/p1ll/bindings/python/p1ll/__init__.py`:

```py
from ._p1ll import *

```

`src/p1ll/bindings/python/p1ll_python.cpp`:

```cpp
#include <nanobind/nanobind.h>
#include <nanobind/stl/optional.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/vector.h>

#include <Python.h>

#include "p1ll.hpp"

#include <memory>
#include <stdexcept>
#include <string>
#include <utility>
#include <vector>

namespace nb = nanobind;

namespace {

using p1ll::engine::apply_options;
using p1ll::engine::apply_report;
using p1ll::engine::error_code;
using p1ll::engine::memory_protection;
using p1ll::engine::memory_region;
using p1ll::engine::patch_spec;
using p1ll::engine::plan_entry;
using p1ll::engine::recipe;
using p1ll::engine::result;
using p1ll::engine::scan_filter;
using p1ll::engine::scan_options;
using p1ll::engine::scan_result;
using p1ll::engine::session;
using p1ll::engine::signature_spec;
using p1ll::engine::status;
using p1ll::engine::platform::platform_key;

struct engine_error : public std::runtime_error {
  error_code code = error_code::internal_error;
  std::string message;

  explicit engine_error(status st) : std::runtime_error(st.message), code(st.code), message(std::move(st.message)) {}
};

void raise_engine_error(const status& st) { throw engine_error(st); }

template <typename T> T unwrap(result<T> res) {
  if (!res.ok()) {
    throw engine_error(res.status_info);
  }
  return std::move(res.value);
}

std::vector<uint8_t> buffer_to_vector(nb::handle data) {
  Py_buffer view{};
  if (PyObject_GetBuffer(data.ptr(), &view, PyBUF_SIMPLE) != 0) {
    throw nb::type_error("expected a bytes-like object");
  }

  auto* bytes = static_cast<const uint8_t*>(view.buf);
  std::vector<uint8_t> out(bytes, bytes + static_cast<size_t>(view.len));
  PyBuffer_Release(&view);
  return out;
}

struct py_session {
  std::unique_ptr<session> session_impl;
  std::vector<uint8_t> buffer;
  bool is_buffer = false;

  static py_session for_process() {
    py_session wrapper;
    wrapper.session_impl = std::make_unique<session>(session::for_process());
    wrapper.is_buffer = false;
    return wrapper;
  }

  static py_session for_buffer(nb::handle data, std::optional<std::string> platform_override) {
    py_session wrapper;
    wrapper.buffer = buffer_to_vector(data);
    if (platform_override.has_value()) {
      auto parsed = p1ll::engine::platform::parse_platform(*platform_override);
      if (!parsed.ok()) {
        raise_engine_error(parsed.status_info);
      }
      wrapper.session_impl = std::make_unique<session>(session::for_buffer(wrapper.buffer, parsed.value));
    } else {
      wrapper.session_impl = std::make_unique<session>(session::for_buffer(wrapper.buffer));
    }
    wrapper.is_buffer = true;
    return wrapper;
  }

  platform_key platform_key_value() const { return session_impl->platform_key(); }

  std::vector<memory_region> regions(const scan_filter& filter) const { return unwrap(session_impl->regions(filter)); }

  std::vector<scan_result> scan(const std::string& pattern, const scan_options& options) const {
    return unwrap(session_impl->scan(pattern, options));
  }

  std::vector<plan_entry> plan(const recipe& recipe) const { return unwrap(session_impl->plan(recipe)); }

  apply_report apply(const std::vector<plan_entry>& plan, const apply_options& options) {
    return unwrap(session_impl->apply(plan, options));
  }

  nb::bytes buffer_bytes() const {
    if (!is_buffer) {
      raise_engine_error(
          p1ll::engine::make_status(error_code::invalid_context, "buffer_bytes only valid for buffer sessions")
      );
    }
    if (buffer.empty()) {
      return nb::bytes("", 0);
    }
    return nb::bytes(buffer.data(), buffer.size());
  }
};

} // namespace

NB_MODULE(_p1ll, m) {
  nb::object engine_error_type =
      nb::steal<nb::object>(PyErr_NewException("p1ll.EngineError", PyExc_RuntimeError, nullptr));
  m.attr("EngineError") = engine_error_type;

  nb::register_exception_translator(
      [](const std::exception_ptr& p, void* payload) {
        try {
          std::rethrow_exception(p);
        } catch (const engine_error& e) {
          auto* type = static_cast<PyObject*>(payload);
          nb::object exc = nb::steal<nb::object>(PyObject_CallFunction(type, "s", e.message.c_str()));
          if (!exc.is_valid()) {
            return;
          }
          exc.attr("code") = nb::cast(e.code);
          exc.attr("message") = nb::str(e.message.c_str(), e.message.size());
          PyErr_SetObject(type, exc.ptr());
        }
      },
      engine_error_type.ptr()
  );

  auto error_code_enum = nb::enum_<error_code>(m, "ErrorCode", nb::is_arithmetic());
  error_code_enum.value("ok", error_code::ok)
      .value("invalid_argument", error_code::invalid_argument)
      .value("invalid_pattern", error_code::invalid_pattern)
      .value("not_found", error_code::not_found)
      .value("multiple_matches", error_code::multiple_matches)
      .value("io_error", error_code::io_error)
      .value("protection_error", error_code::protection_error)
      .value("verification_failed", error_code::verification_failed)
      .value("platform_mismatch", error_code::platform_mismatch)
      .value("overlap", error_code::overlap)
      .value("unsupported", error_code::unsupported)
      .value("invalid_context", error_code::invalid_context)
      .value("internal_error", error_code::internal_error);

  nb::class_<status>(m, "Status")
      .def(nb::init<>())
      .def_rw("code", &status::code)
      .def_rw("message", &status::message)
      .def("ok", &status::ok)
      .def("__repr__", [](const status& st) {
        return "Status(code=" + std::to_string(static_cast<int>(st.code)) + ", message='" + st.message + "')";
      });

  nb::enum_<memory_protection>(m, "MemoryProtection", nb::is_arithmetic())
      .value("none", memory_protection::none)
      .value("read", memory_protection::read)
      .value("write", memory_protection::write)
      .value("execute", memory_protection::execute)
      .value("read_write", memory_protection::read_write)
      .value("read_execute", memory_protection::read_execute)
      .value("read_write_execute", memory_protection::read_write_execute);

  nb::class_<memory_region>(m, "MemoryRegion")
      .def(nb::init<>())
      .def_rw("base_address", &memory_region::base_address)
      .def_rw("size", &memory_region::size)
      .def_rw("protection", &memory_region::protection)
      .def_rw("name", &memory_region::name)
      .def_rw("is_executable", &memory_region::is_executable)
      .def_rw("is_system", &memory_region::is_system);

  nb::class_<scan_filter>(m, "ScanFilter")
      .def(nb::init<>())
      .def_rw("name_regex", &scan_filter::name_regex)
      .def_rw("only_executable", &scan_filter::only_executable)
      .def_rw("exclude_system", &scan_filter::exclude_system)
      .def_rw("min_size", &scan_filter::min_size)
      .def_rw("min_address", &scan_filter::min_address)
      .def_rw("max_address", &scan_filter::max_address);

  nb::class_<scan_options>(m, "ScanOptions")
      .def(nb::init<>())
      .def_rw("filter", &scan_options::filter)
      .def_rw("single", &scan_options::single)
      .def_rw("max_matches", &scan_options::max_matches);

  nb::class_<scan_result>(m, "ScanResult")
      .def(nb::init<>())
      .def_rw("address", &scan_result::address)
      .def_rw("region_name", &scan_result::region_name);

  nb::class_<signature_spec>(m, "SignatureSpec")
      .def(nb::init<>())
      .def_rw("pattern", &signature_spec::pattern)
      .def_rw("options", &signature_spec::options)
      .def_rw("platforms", &signature_spec::platforms)
      .def_rw("required", &signature_spec::required);

  nb::class_<patch_spec>(m, "PatchSpec")
      .def(nb::init<>())
      .def_rw("signature", &patch_spec::signature)
      .def_rw("offset", &patch_spec::offset)
      .def_rw("patch", &patch_spec::patch)
      .def_rw("platforms", &patch_spec::platforms)
      .def_rw("required", &patch_spec::required);

  nb::class_<recipe>(m, "Recipe")
      .def(nb::init<>())
      .def_rw("name", &recipe::name)
      .def_rw("platforms", &recipe::platforms)
      .def_rw("validations", &recipe::validations)
      .def_rw("patches", &recipe::patches);

  nb::class_<plan_entry>(m, "PlanEntry")
      .def(nb::init<>())
      .def_rw("spec", &plan_entry::spec)
      .def_rw("address", &plan_entry::address)
      .def_rw("patch_bytes", &plan_entry::patch_bytes)
      .def_rw("patch_mask", &plan_entry::patch_mask);

  nb::class_<apply_options>(m, "ApplyOptions")
      .def(nb::init<>())
      .def_rw("verify", &apply_options::verify)
      .def_rw("flush_icache", &apply_options::flush_icache)
      .def_rw("rollback_on_failure", &apply_options::rollback_on_failure)
      .def_rw("allow_wx", &apply_options::allow_wx);

  nb::class_<apply_report>(m, "ApplyReport")
      .def(nb::init<>())
      .def_rw("success", &apply_report::success)
      .def_rw("applied", &apply_report::applied)
      .def_rw("failed", &apply_report::failed)
      .def_rw("diagnostics", &apply_report::diagnostics);

  nb::class_<platform_key>(m, "PlatformKey")
      .def(nb::init<>())
      .def_rw("os", &platform_key::os)
      .def_rw("arch", &platform_key::arch)
      .def("to_string", &platform_key::to_string)
      .def("__repr__", [](const platform_key& key) {
        return "PlatformKey(os='" + key.os + "', arch='" + key.arch + "')";
      });

  nb::class_<py_session>(m, "Session")
      .def_static("for_process", &py_session::for_process)
      .def_static("for_buffer", &py_session::for_buffer, nb::arg("data"), nb::arg("platform_override") = nb::none())
      .def_prop_ro("platform_key", &py_session::platform_key_value)
      .def("regions", &py_session::regions, nb::arg("filter") = scan_filter{})
      .def("scan", &py_session::scan, nb::arg("pattern"), nb::arg("options") = scan_options{})
      .def("plan", &py_session::plan)
      .def("apply", &py_session::apply, nb::arg("plan"), nb::arg("options") = apply_options{})
      .def("buffer_bytes", &py_session::buffer_bytes);

  nb::module_ platform = m.def_submodule("platform", "platform helpers");
  platform.def("detect_platform", &p1ll::engine::platform::detect_platform);
  platform.def("parse_platform", [](const std::string& key) {
    auto parsed = p1ll::engine::platform::parse_platform(key);
    if (!parsed.ok()) {
      raise_engine_error(parsed.status_info);
    }
    return parsed.value;
  });
  platform.def("platform_matches", [](const platform_key& selector, const platform_key& target) {
    return p1ll::engine::platform::platform_matches(selector, target);
  });
  platform.def("platform_matches", [](const std::string& selector, const platform_key& target) {
    return p1ll::engine::platform::platform_matches(selector, target);
  });
  platform.def("any_platform_matches", &p1ll::engine::platform::any_platform_matches);

  nb::module_ utils = m.def_submodule("utils", "utility helpers");
  utils.def("str2hex", &p1ll::utils::str2hex);
  utils.def("hex2str", &p1ll::utils::hex2str);
  utils.def("format_address", &p1ll::utils::format_address);
  utils.def("format_bytes", [](const nb::bytes& data) {
    const auto* bytes = static_cast<const uint8_t*>(data.data());
    std::vector<uint8_t> buffer(bytes, bytes + data.size());
    return p1ll::utils::format_bytes(buffer);
  });
  utils.def("is_hex_digit", [](const std::string& value) {
    if (value.size() != 1) {
      throw nb::value_error("is_hex_digit expects a single character");
    }
    return p1ll::utils::is_hex_digit(value[0]);
  });
  utils.def("parse_hex_digit", [](const std::string& value) {
    if (value.size() != 1) {
      throw nb::value_error("parse_hex_digit expects a single character");
    }
    return p1ll::utils::parse_hex_digit(value[0]);
  });
  utils.def("to_hex_string", &p1ll::utils::to_hex_string);
  utils.def("is_valid_hex_pattern", &p1ll::utils::is_valid_hex_pattern);
  utils.def("parse_hex_pattern", &p1ll::utils::parse_hex_pattern);
  utils.def("normalize_hex_pattern", &p1ll::utils::normalize_hex_pattern);
  utils.def("format_memory_range", &p1ll::utils::format_memory_range);
  utils.def("format_memory_region", &p1ll::utils::format_memory_region);
  utils.def(
      "format_hex_bytes",
      [](const nb::bytes& data, size_t max_bytes) {
        return p1ll::utils::format_hex_bytes(static_cast<const uint8_t*>(data.data()), data.size(), max_bytes);
      },
      nb::arg("data"), nb::arg("max_bytes") = 16
  );

  utils.def("read_file", [](const std::string& path) -> nb::object {
    auto value = p1ll::utils::read_file(path);
    if (!value.has_value()) {
      return nb::none();
    }
    if (value->empty()) {
      return nb::bytes("", 0);
    }
    return nb::bytes(value->data(), value->size());
  });
  utils.def("read_file_string", [](const std::string& path) -> nb::object {
    auto value = p1ll::utils::read_file_string(path);
    if (!value.has_value()) {
      return nb::none();
    }
    return nb::str(value->c_str(), value->size());
  });
  utils.def("write_file", [](const std::string& path, const nb::bytes& data) {
    const auto* bytes = static_cast<const uint8_t*>(data.data());
    std::vector<uint8_t> buffer(bytes, bytes + data.size());
    return p1ll::utils::write_file(path, buffer);
  });
  utils.def("write_file", [](const std::string& path, const std::string& data) {
    return p1ll::utils::write_file(path, data);
  });
  utils.def("file_exists", &p1ll::utils::file_exists);
  utils.def("get_file_size", &p1ll::utils::get_file_size);

  m.def("has_scripting_support", &p1ll::has_scripting_support);
}

```

`src/p1ll/bindings/python/pyproject.toml`:

```toml
[build-system]
requires = ["scikit-build-core>=0.10"]
build-backend = "scikit_build_core.build"

[project]
name = "p1ll"
version = "0.1.0"
description = "python bindings for p1ll"
requires-python = ">=3.8"

[tool.scikit-build]
minimum-version = "build-system.requires"
cmake.source-dir = "."

```

`src/p1ll/capi/CMakeLists.txt`:

```txt
# p1ll c api wrapper

set(P1LL_CAPI_SOURCES
    p1ll_c.cpp
)

# p1ll_c static library
w1_add_static_library(p1ll_c ${P1LL_CAPI_SOURCES})
add_library(p1ll::capi ALIAS p1ll_c)

# link against p1ll_core
target_link_libraries(p1ll_c PUBLIC p1ll_core)

# include directories
target_include_directories(p1ll_c
    PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}
    PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/..
)

# export header for installation
if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)
    install(TARGETS p1ll_c DESTINATION lib COMPONENT ${W1_INSTALL_COMPONENT})
endif()

message(STATUS "p1ll c api configured")

```

`src/p1ll/capi/p1ll_c.cpp`:

```cpp
/**
 * @file p1ll_c.cpp
 * @brief C API implementation wrapping the p1ll engine session
 */

#include "p1ll_c.h"
#include "../p1ll.hpp"
#include "../engine/platform/platform.hpp"
#include "../engine/pattern.hpp"
#include "../utils/hex_utils.hpp"

#include <cstring>
#include <memory>
#include <span>
#include <string>
#include <vector>

thread_local std::string last_error;

static void set_error(const std::string& msg) { last_error = msg; }
static void clear_error() { last_error.clear(); }

struct p1ll_session {
  std::unique_ptr<p1ll::engine::session> session;
};

static p1ll::engine::scan_options convert_scan_options(const p1ll_scan_options_t* options) {
  p1ll::engine::scan_options out;
  if (!options) {
    return out;
  }
  if (options->filter.name_regex) {
    out.filter.name_regex = options->filter.name_regex;
  }
  out.filter.only_executable = options->filter.only_executable != 0;
  out.filter.exclude_system = options->filter.exclude_system != 0;
  out.filter.min_size = options->filter.min_size;
  if (options->filter.has_min_address) {
    out.filter.min_address = options->filter.min_address;
  }
  if (options->filter.has_max_address) {
    out.filter.max_address = options->filter.max_address;
  }
  out.single = options->single != 0;
  out.max_matches = options->max_matches;
  return out;
}

static std::vector<std::string> convert_platforms(const char** platforms, size_t count) {
  std::vector<std::string> result;
  if (!platforms) {
    return result;
  }
  for (size_t i = 0; i < count; ++i) {
    if (platforms[i]) {
      result.push_back(platforms[i]);
    }
  }
  return result;
}

static p1ll::engine::signature_spec convert_signature_spec(const p1ll_signature_spec_t& spec) {
  p1ll::engine::signature_spec out;
  if (spec.pattern) {
    out.pattern = spec.pattern;
  }
  out.options = convert_scan_options(&spec.options);
  out.platforms = convert_platforms(spec.platforms, spec.platform_count);
  out.required = spec.required != 0;
  return out;
}

static p1ll::engine::patch_spec convert_patch_spec(const p1ll_patch_spec_t& spec) {
  p1ll::engine::patch_spec out;
  out.signature = convert_signature_spec(spec.signature);
  out.offset = spec.offset;
  if (spec.patch) {
    out.patch = spec.patch;
  }
  out.platforms = convert_platforms(spec.platforms, spec.platform_count);
  out.required = spec.required != 0;
  return out;
}

p1ll_session_t p1ll_session_create_process(void) {
  try {
    clear_error();
    auto session = std::make_unique<p1ll::engine::session>(p1ll::engine::session::for_process());
    return new p1ll_session{std::move(session)};
  } catch (const std::exception& e) {
    set_error("failed to create process session: " + std::string(e.what()));
    return nullptr;
  }
}

p1ll_session_t p1ll_session_create_buffer(uint8_t* buffer, size_t size) {
  if (!buffer || size == 0) {
    set_error("invalid buffer");
    return nullptr;
  }
  try {
    clear_error();
    auto session =
        std::make_unique<p1ll::engine::session>(p1ll::engine::session::for_buffer(std::span<uint8_t>(buffer, size)));
    return new p1ll_session{std::move(session)};
  } catch (const std::exception& e) {
    set_error("failed to create buffer session: " + std::string(e.what()));
    return nullptr;
  }
}

p1ll_session_t p1ll_session_create_buffer_with_platform(uint8_t* buffer, size_t size, const char* platform_key) {
  if (!buffer || size == 0) {
    set_error("invalid buffer");
    return nullptr;
  }
  if (!platform_key) {
    set_error("invalid platform key");
    return nullptr;
  }
  try {
    clear_error();
    auto parsed = p1ll::engine::platform::parse_platform(platform_key);
    if (!parsed.ok()) {
      set_error(parsed.status_info.message.empty() ? "invalid platform key" : parsed.status_info.message);
      return nullptr;
    }
    auto session = std::make_unique<p1ll::engine::session>(
        p1ll::engine::session::for_buffer(std::span<uint8_t>(buffer, size), parsed.value)
    );
    return new p1ll_session{std::move(session)};
  } catch (const std::exception& e) {
    set_error("failed to create buffer session: " + std::string(e.what()));
    return nullptr;
  }
}

void p1ll_session_destroy(p1ll_session_t session) {
  if (session) {
    delete session;
  }
}

int p1ll_scan(
    p1ll_session_t session, const char* pattern, const p1ll_scan_options_t* options, p1ll_scan_result_t** out_results,
    size_t* out_count
) {
  if (!session || !pattern || !out_results || !out_count) {
    set_error("invalid parameters");
    return P1LL_ERROR;
  }

  try {
    clear_error();
    auto scan_opts = convert_scan_options(options);
    auto result = session->session->scan(pattern, scan_opts);
    if (!result.ok()) {
      set_error(result.status_info.message.empty() ? "scan failed" : result.status_info.message);
      return P1LL_ERROR;
    }

    *out_count = result.value.size();
    if (*out_count == 0) {
      *out_results = nullptr;
      return P1LL_SUCCESS;
    }

    *out_results = static_cast<p1ll_scan_result_t*>(calloc(*out_count, sizeof(p1ll_scan_result_t)));
    if (!*out_results) {
      set_error("failed to allocate scan results");
      return P1LL_ERROR;
    }

    for (size_t i = 0; i < *out_count; ++i) {
      (*out_results)[i].address = result.value[i].address;
      strncpy(
          (*out_results)[i].region_name, result.value[i].region_name.c_str(), sizeof((*out_results)[i].region_name) - 1
      );
      (*out_results)[i].region_name[sizeof((*out_results)[i].region_name) - 1] = '\0';
    }

    return P1LL_SUCCESS;
  } catch (const std::exception& e) {
    set_error("exception in scan: " + std::string(e.what()));
    return P1LL_ERROR;
  }
}

void p1ll_free_scan_results(p1ll_scan_result_t* results) { free(results); }

int p1ll_plan(p1ll_session_t session, const p1ll_recipe_t* recipe, p1ll_plan_entry_t** out_entries, size_t* out_count) {
  if (!session || !recipe || !out_entries || !out_count) {
    set_error("invalid parameters");
    return P1LL_ERROR;
  }

  try {
    clear_error();
    p1ll::engine::recipe plan_recipe;
    if (recipe->name) {
      plan_recipe.name = recipe->name;
    }
    plan_recipe.platforms = convert_platforms(recipe->platforms, recipe->platform_count);

    for (size_t i = 0; i < recipe->validation_count; ++i) {
      plan_recipe.validations.push_back(convert_signature_spec(recipe->validations[i]));
    }
    for (size_t i = 0; i < recipe->patch_count; ++i) {
      plan_recipe.patches.push_back(convert_patch_spec(recipe->patches[i]));
    }

    auto plan = session->session->plan(plan_recipe);
    if (!plan.ok()) {
      set_error(plan.status_info.message.empty() ? "plan failed" : plan.status_info.message);
      return P1LL_ERROR;
    }

    *out_count = plan.value.size();
    if (*out_count == 0) {
      *out_entries = nullptr;
      return P1LL_SUCCESS;
    }

    *out_entries = static_cast<p1ll_plan_entry_t*>(calloc(*out_count, sizeof(p1ll_plan_entry_t)));
    if (!*out_entries) {
      set_error("failed to allocate plan entries");
      return P1LL_ERROR;
    }

    for (size_t i = 0; i < *out_count; ++i) {
      const auto& entry = plan.value[i];
      auto& out = (*out_entries)[i];
      out.address = entry.address;
      out.size = entry.patch_bytes.size();
      out.required = entry.spec.required ? 1 : 0;

      out.patch_bytes = static_cast<uint8_t*>(malloc(out.size));
      out.patch_mask = static_cast<uint8_t*>(malloc(out.size));
      if (!out.patch_bytes || !out.patch_mask) {
        p1ll_free_plan_entries(*out_entries, i + 1);
        *out_entries = nullptr;
        *out_count = 0;
        set_error("failed to allocate patch bytes");
        return P1LL_ERROR;
      }

      std::memcpy(out.patch_bytes, entry.patch_bytes.data(), out.size);
      std::memcpy(out.patch_mask, entry.patch_mask.data(), out.size);
    }

    return P1LL_SUCCESS;
  } catch (const std::exception& e) {
    set_error("exception in plan: " + std::string(e.what()));
    return P1LL_ERROR;
  }
}

void p1ll_free_plan_entries(p1ll_plan_entry_t* entries, size_t count) {
  if (!entries) {
    return;
  }
  for (size_t i = 0; i < count; ++i) {
    free(entries[i].patch_bytes);
    free(entries[i].patch_mask);
  }
  free(entries);
}

int p1ll_apply(
    p1ll_session_t session, const p1ll_plan_entry_t* entries, size_t count, p1ll_apply_report_t* out_report
) {
  if (!session || !entries || !out_report) {
    set_error("invalid parameters");
    return P1LL_ERROR;
  }

  try {
    clear_error();
    std::vector<p1ll::engine::plan_entry> plan_entries;
    plan_entries.reserve(count);
    for (size_t i = 0; i < count; ++i) {
      p1ll::engine::plan_entry entry;
      entry.address = entries[i].address;
      entry.patch_bytes.assign(entries[i].patch_bytes, entries[i].patch_bytes + entries[i].size);
      entry.patch_mask.assign(entries[i].patch_mask, entries[i].patch_mask + entries[i].size);
      entry.spec.required = entries[i].required != 0;
      plan_entries.push_back(std::move(entry));
    }

    auto applied = session->session->apply(plan_entries);
    out_report->success = applied.value.success ? 1 : 0;
    out_report->applied = applied.value.applied;
    out_report->failed = applied.value.failed;

    if (!applied.ok()) {
      set_error(applied.status_info.message.empty() ? "apply failed" : applied.status_info.message);
      return P1LL_ERROR;
    }

    return P1LL_SUCCESS;
  } catch (const std::exception& e) {
    set_error("exception in apply: " + std::string(e.what()));
    return P1LL_ERROR;
  }
}

int p1ll_validate_pattern(const char* hex_pattern) {
  if (!hex_pattern) {
    return 0;
  }
  auto parsed = p1ll::engine::parse_signature(hex_pattern);
  return parsed.ok() ? 1 : 0;
}

int p1ll_hex_string_to_bytes(const char* hex, uint8_t** out_bytes, size_t* out_size) {
  if (!hex || !out_bytes || !out_size) {
    set_error("invalid parameters");
    return P1LL_ERROR;
  }

  try {
    clear_error();
    std::string hex_str = hex;
    std::string clean_hex;
    for (char c : hex_str) {
      if (c != ' ') {
        if (!p1ll::utils::is_hex_digit(c)) {
          set_error("invalid hex character");
          return P1LL_ERROR;
        }
        clean_hex += c;
      }
    }

    if (clean_hex.length() % 2 != 0) {
      set_error("hex string must have even length");
      return P1LL_ERROR;
    }

    *out_size = clean_hex.length() / 2;
    *out_bytes = static_cast<uint8_t*>(malloc(*out_size));
    if (!*out_bytes) {
      set_error("failed to allocate bytes array");
      return P1LL_ERROR;
    }

    for (size_t i = 0; i < *out_size; ++i) {
      uint8_t high = p1ll::utils::parse_hex_digit(clean_hex[i * 2]);
      uint8_t low = p1ll::utils::parse_hex_digit(clean_hex[i * 2 + 1]);
      (*out_bytes)[i] = (high << 4) | low;
    }

    return P1LL_SUCCESS;
  } catch (const std::exception& e) {
    set_error("exception in hex_string_to_bytes: " + std::string(e.what()));
    return P1LL_ERROR;
  }
}

char* p1ll_bytes_to_hex_string(const uint8_t* bytes, size_t size) {
  if (!bytes) {
    set_error("invalid parameters");
    return nullptr;
  }

  try {
    clear_error();
    std::vector<uint8_t> byte_vec(bytes, bytes + size);
    std::string hex_str = p1ll::utils::format_bytes(byte_vec);

    char* result = static_cast<char*>(malloc(hex_str.length() + 1));
    if (!result) {
      set_error("failed to allocate string");
      return nullptr;
    }

    std::strcpy(result, hex_str.c_str());
    return result;
  } catch (const std::exception& e) {
    set_error("exception in bytes_to_hex_string: " + std::string(e.what()));
    return nullptr;
  }
}

char* p1ll_format_address(uint64_t address) {
  try {
    clear_error();
    std::string addr_str = p1ll::utils::format_address(address);

    char* result = static_cast<char*>(malloc(addr_str.length() + 1));
    if (!result) {
      set_error("failed to allocate string");
      return nullptr;
    }

    std::strcpy(result, addr_str.c_str());
    return result;
  } catch (const std::exception& e) {
    set_error("exception in format_address: " + std::string(e.what()));
    return nullptr;
  }
}

void p1ll_free_bytes(uint8_t* bytes) { free(bytes); }
void p1ll_free_string(char* str) { free(str); }

int p1ll_has_scripting_support(void) { return p1ll::has_scripting_support() ? 1 : 0; }

const char* p1ll_get_last_error(void) { return last_error.c_str(); }

```

`src/p1ll/capi/p1ll_c.h`:

```h
/**
 * @file p1ll_c.h
 * @brief C API for the p1ll engine session interface
 */

#ifndef P1LL_C_H
#define P1LL_C_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stddef.h>
#include <stdint.h>

#define P1LL_SUCCESS 0
#define P1LL_ERROR -1

// opaque handle for engine sessions
typedef struct p1ll_session* p1ll_session_t;

// scan filtering options
typedef struct {
  const char* name_regex;
  int only_executable;
  int exclude_system;
  size_t min_size;
  int has_min_address;
  uint64_t min_address;
  int has_max_address;
  uint64_t max_address;
} p1ll_scan_filter_t;

typedef struct {
  p1ll_scan_filter_t filter;
  int single;
  size_t max_matches;
} p1ll_scan_options_t;

typedef struct {
  uint64_t address;
  char region_name[256];
} p1ll_scan_result_t;

// signature and patch specs for recipe construction
typedef struct {
  const char* pattern;
  p1ll_scan_options_t options;
  const char** platforms;
  size_t platform_count;
  int required;
} p1ll_signature_spec_t;

typedef struct {
  p1ll_signature_spec_t signature;
  int64_t offset;
  const char* patch;
  const char** platforms;
  size_t platform_count;
  int required;
} p1ll_patch_spec_t;

typedef struct {
  const char* name;
  const char** platforms;
  size_t platform_count;
  const p1ll_signature_spec_t* validations;
  size_t validation_count;
  const p1ll_patch_spec_t* patches;
  size_t patch_count;
} p1ll_recipe_t;

typedef struct {
  uint64_t address;
  uint8_t* patch_bytes;
  uint8_t* patch_mask;
  size_t size;
  int required;
} p1ll_plan_entry_t;

typedef struct {
  int success;
  size_t applied;
  size_t failed;
} p1ll_apply_report_t;

// session lifecycle
p1ll_session_t p1ll_session_create_process(void);
p1ll_session_t p1ll_session_create_buffer(uint8_t* buffer, size_t size);
p1ll_session_t p1ll_session_create_buffer_with_platform(uint8_t* buffer, size_t size, const char* platform_key);
void p1ll_session_destroy(p1ll_session_t session);

// scanning and planning
int p1ll_scan(
    p1ll_session_t session, const char* pattern, const p1ll_scan_options_t* options, p1ll_scan_result_t** out_results,
    size_t* out_count
);
void p1ll_free_scan_results(p1ll_scan_result_t* results);

int p1ll_plan(p1ll_session_t session, const p1ll_recipe_t* recipe, p1ll_plan_entry_t** out_entries, size_t* out_count);
void p1ll_free_plan_entries(p1ll_plan_entry_t* entries, size_t count);

int p1ll_apply(p1ll_session_t session, const p1ll_plan_entry_t* entries, size_t count, p1ll_apply_report_t* out_report);

// utilities
int p1ll_validate_pattern(const char* hex_pattern);
int p1ll_hex_string_to_bytes(const char* hex, uint8_t** out_bytes, size_t* out_size);
char* p1ll_bytes_to_hex_string(const uint8_t* bytes, size_t size);
char* p1ll_format_address(uint64_t address);
void p1ll_free_bytes(uint8_t* bytes);
void p1ll_free_string(char* str);

// capability and error helpers
int p1ll_has_scripting_support(void);
const char* p1ll_get_last_error(void);

#ifdef __cplusplus
}
#endif

#endif /* P1LL_C_H */

```

`src/p1ll/engine/address_space.cpp`:

```cpp
#include "address_space.hpp"
#include "engine/platform/process_memory.hpp"
#include <algorithm>
#include <filesystem>
#include <regex>

namespace p1ll::engine {

namespace {

bool filter_is_empty(const scan_filter& filter) {
  return filter.name_regex.empty() && !filter.only_executable && !filter.exclude_system && filter.min_size == 0 &&
         !filter.min_address.has_value() && !filter.max_address.has_value();
}

result<bool> matches_filter(const memory_region& region, const scan_filter& filter) {
  if (filter.only_executable && !region.is_executable) {
    return ok_result(false);
  }
  if (filter.exclude_system && region.is_system) {
    return ok_result(false);
  }
  if (filter.min_size > 0 && region.size < filter.min_size) {
    return ok_result(false);
  }

  if (filter.min_address.has_value()) {
    uint64_t region_end = region.base_address + region.size;
    if (region_end <= *filter.min_address) {
      return ok_result(false);
    }
  }
  if (filter.max_address.has_value()) {
    if (region.base_address >= *filter.max_address) {
      return ok_result(false);
    }
  }

  if (!filter.name_regex.empty()) {
    try {
      std::string region_name =
          region.name.empty() ? "[anonymous]" : std::filesystem::path(region.name).filename().string();
      if (!std::regex_search(region_name, std::regex(filter.name_regex))) {
        return ok_result(false);
      }
    } catch (const std::regex_error&) {
      return error_result<bool>(error_code::invalid_argument, "invalid regex in scan filter");
    }
  }

  return ok_result(true);
}

} // namespace

result<std::vector<uint8_t>> process_address_space::read(uint64_t address, size_t size) const {
  if (size == 0) {
    return ok_result(std::vector<uint8_t>{});
  }

  if (address > UINT64_MAX - size) {
    return error_result<std::vector<uint8_t>>(error_code::invalid_argument, "address range overflow");
  }

  auto region = region_info(address);
  if (!region.ok()) {
    return error_result<std::vector<uint8_t>>(region.status_info.code, region.status_info.message);
  }
  if (!has_protection(region.value.protection, memory_protection::read)) {
    return error_result<std::vector<uint8_t>>(error_code::protection_error, "memory not readable");
  }
  if (address + size > region.value.base_address + region.value.size) {
    return error_result<std::vector<uint8_t>>(error_code::invalid_argument, "read crosses region boundary");
  }

  return platform::read(address, size);
}

status process_address_space::write(uint64_t address, std::span<const uint8_t> data) const {
  if (data.empty()) {
    return ok_status();
  }

  if (address > UINT64_MAX - data.size()) {
    return make_status(error_code::invalid_argument, "address range overflow");
  }

  auto region = region_info(address);
  if (!region.ok()) {
    return region.status_info;
  }
  if (!has_protection(region.value.protection, memory_protection::write)) {
    return make_status(error_code::protection_error, "memory not writable");
  }
  if (address + data.size() > region.value.base_address + region.value.size) {
    return make_status(error_code::invalid_argument, "write crosses region boundary");
  }

  return platform::write(address, data);
}

result<memory_region> process_address_space::region_info(uint64_t address) const {
  return platform::region_info(address);
}

status process_address_space::set_protection(uint64_t address, size_t size, memory_protection protection) const {
  return platform::set_protection(address, size, protection);
}

status process_address_space::flush_instruction_cache(uint64_t address, size_t size) const {
  return platform::flush_instruction_cache(address, size);
}

result<std::vector<memory_region>> process_address_space::regions(const scan_filter& filter) const {
  auto regions = platform::enumerate_regions();
  if (!regions.ok()) {
    return error_result<std::vector<memory_region>>(regions.status_info.code, regions.status_info.message);
  }

  if (filter_is_empty(filter)) {
    return regions;
  }

  std::vector<memory_region> filtered;
  for (const auto& region : regions.value) {
    auto match = matches_filter(region, filter);
    if (!match.ok()) {
      return error_result<std::vector<memory_region>>(match.status_info.code, match.status_info.message);
    }
    if (match.value) {
      filtered.push_back(region);
    }
  }

  return ok_result(filtered);
}

result<size_t> process_address_space::page_size() const { return platform::page_size(); }

result<void*> process_address_space::allocate(size_t size, memory_protection protection) const {
  return platform::allocate(size, protection);
}

status process_address_space::free(void* address, size_t size) const { return platform::free(address, size); }

buffer_address_space::buffer_address_space(std::span<uint8_t> buffer) : buffer_(buffer) {}

result<std::vector<uint8_t>> buffer_address_space::read(uint64_t address, size_t size) const {
  if (size == 0) {
    return ok_result(std::vector<uint8_t>{});
  }
  if (address > buffer_.size() || size > buffer_.size() - address) {
    return error_result<std::vector<uint8_t>>(error_code::invalid_argument, "read out of buffer bounds");
  }
  return ok_result(std::vector<uint8_t>(buffer_.begin() + address, buffer_.begin() + address + size));
}

status buffer_address_space::write(uint64_t address, std::span<const uint8_t> data) const {
  if (data.empty()) {
    return ok_status();
  }
  if (address > buffer_.size() || data.size() > buffer_.size() - address) {
    return make_status(error_code::invalid_argument, "write out of buffer bounds");
  }
  std::copy(data.begin(), data.end(), buffer_.begin() + address);
  return ok_status();
}

result<memory_region> buffer_address_space::region_info(uint64_t address) const {
  if (address >= buffer_.size()) {
    return error_result<memory_region>(error_code::not_found, "address not found in buffer");
  }
  memory_region region;
  region.base_address = 0;
  region.size = buffer_.size();
  region.protection = memory_protection::read_write;
  region.name = "buffer";
  region.is_executable = false;
  region.is_system = false;
  return ok_result(region);
}

status buffer_address_space::set_protection(uint64_t, size_t, memory_protection) const { return ok_status(); }

status buffer_address_space::flush_instruction_cache(uint64_t, size_t) const { return ok_status(); }

result<std::vector<memory_region>> buffer_address_space::regions(const scan_filter& filter) const {
  memory_region region;
  region.base_address = 0;
  region.size = buffer_.size();
  region.protection = memory_protection::read_write;
  region.name = "buffer";
  region.is_executable = false;
  region.is_system = false;

  scan_filter effective_filter = filter;
  effective_filter.name_regex.clear();

  if (filter_is_empty(effective_filter)) {
    return ok_result(std::vector<memory_region>{region});
  }

  auto match = matches_filter(region, effective_filter);
  if (!match.ok()) {
    return error_result<std::vector<memory_region>>(match.status_info.code, match.status_info.message);
  }
  if (!match.value) {
    return ok_result(std::vector<memory_region>{});
  }
  return ok_result(std::vector<memory_region>{region});
}

result<size_t> buffer_address_space::page_size() const { return ok_result(static_cast<size_t>(1)); }

result<void*> buffer_address_space::allocate(size_t, memory_protection) const {
  return error_result<void*>(error_code::unsupported, "buffer address space does not allocate");
}

status buffer_address_space::free(void*, size_t) const {
  return make_status(error_code::unsupported, "buffer address space does not free");
}

} // namespace p1ll::engine

```

`src/p1ll/engine/address_space.hpp`:

```hpp
#pragma once

#include "engine/result.hpp"
#include "engine/types.hpp"
#include <cstddef>
#include <cstdint>
#include <memory>
#include <span>
#include <vector>

namespace p1ll::engine {

class address_space {
public:
  virtual ~address_space() = default;

  virtual result<std::vector<uint8_t>> read(uint64_t address, size_t size) const = 0;
  virtual status write(uint64_t address, std::span<const uint8_t> data) const = 0;
  virtual result<memory_region> region_info(uint64_t address) const = 0;
  virtual status set_protection(uint64_t address, size_t size, memory_protection protection) const = 0;
  virtual status flush_instruction_cache(uint64_t address, size_t size) const = 0;
  virtual result<std::vector<memory_region>> regions(const scan_filter& filter) const = 0;
  virtual result<size_t> page_size() const = 0;
  virtual result<void*> allocate(size_t size, memory_protection protection) const = 0;
  virtual status free(void* address, size_t size) const = 0;
};

class process_address_space final : public address_space {
public:
  process_address_space() = default;
  ~process_address_space() override = default;

  result<std::vector<uint8_t>> read(uint64_t address, size_t size) const override;
  status write(uint64_t address, std::span<const uint8_t> data) const override;
  result<memory_region> region_info(uint64_t address) const override;
  status set_protection(uint64_t address, size_t size, memory_protection protection) const override;
  status flush_instruction_cache(uint64_t address, size_t size) const override;
  result<std::vector<memory_region>> regions(const scan_filter& filter) const override;
  result<size_t> page_size() const override;
  result<void*> allocate(size_t size, memory_protection protection) const override;
  status free(void* address, size_t size) const override;
};

class buffer_address_space final : public address_space {
public:
  explicit buffer_address_space(std::span<uint8_t> buffer);
  ~buffer_address_space() override = default;

  result<std::vector<uint8_t>> read(uint64_t address, size_t size) const override;
  status write(uint64_t address, std::span<const uint8_t> data) const override;
  result<memory_region> region_info(uint64_t address) const override;
  status set_protection(uint64_t address, size_t size, memory_protection protection) const override;
  status flush_instruction_cache(uint64_t address, size_t size) const override;
  result<std::vector<memory_region>> regions(const scan_filter& filter) const override;
  result<size_t> page_size() const override;
  result<void*> allocate(size_t size, memory_protection protection) const override;
  status free(void* address, size_t size) const override;

private:
  std::span<uint8_t> buffer_;
};

} // namespace p1ll::engine

```

`src/p1ll/engine/apply.cpp`:

```cpp
#include "apply.hpp"
#include "pretty_logging.hpp"
#include "utils/hex_utils.hpp"
#include <algorithm>
#include <redlog.hpp>
#include <span>
#include <utility>

namespace p1ll::engine {

namespace {

constexpr uint64_t k_context_alignment_mask = 0xF;
constexpr uint64_t k_context_alignment_size = 16;

size_t count_written_bytes(const std::vector<uint8_t>& mask) {
  return static_cast<size_t>(std::count_if(mask.begin(), mask.end(), [](uint8_t value) { return value != 0; }));
}

memory_protection remove_execute(memory_protection prot) {
  return static_cast<memory_protection>(static_cast<int>(prot) & ~static_cast<int>(memory_protection::execute));
}

bool build_patch_context(
    address_space& space, uint64_t address, const std::vector<uint8_t>& before, const std::vector<uint8_t>& after,
    std::vector<uint8_t>& context_before, std::vector<uint8_t>& context_after, uint64_t& context_base
) {
  if (before.size() != after.size() || before.empty()) {
    return false;
  }

  uint64_t patch_size = static_cast<uint64_t>(before.size());
  if (address > UINT64_MAX - patch_size) {
    return false;
  }
  if (address > UINT64_MAX - patch_size - (k_context_alignment_size - 1)) {
    return false;
  }

  uint64_t aligned_start = address & ~k_context_alignment_mask;
  uint64_t aligned_end = (address + patch_size + k_context_alignment_size - 1) & ~k_context_alignment_mask;
  if (aligned_end < aligned_start) {
    return false;
  }

  size_t context_size = static_cast<size_t>(aligned_end - aligned_start);
  if (context_size == 0) {
    return false;
  }

  auto context = space.read(aligned_start, context_size);
  if (!context.ok()) {
    return false;
  }

  context_before = std::move(context.value);
  context_after = context_before;

  size_t patch_offset = static_cast<size_t>(address - aligned_start);
  if (patch_offset > context_after.size() || context_after.size() - patch_offset < after.size()) {
    return false;
  }

  std::copy(after.begin(), after.end(), context_after.begin() + patch_offset);
  context_base = aligned_start;
  return true;
}

result<std::vector<uint8_t>> merge_patch_bytes(
    const std::vector<uint8_t>& patch_bytes, const std::vector<uint8_t>& patch_mask,
    const std::vector<uint8_t>& original
) {
  if (patch_bytes.size() != patch_mask.size() || patch_bytes.size() != original.size()) {
    return error_result<std::vector<uint8_t>>(error_code::invalid_argument, "patch size mismatch");
  }

  std::vector<uint8_t> merged = original;
  for (size_t i = 0; i < patch_bytes.size(); ++i) {
    if (patch_mask[i]) {
      merged[i] = patch_bytes[i];
    }
  }

  return ok_result(merged);
}

result<size_t> apply_entry(address_space& space, const plan_entry& entry, const apply_options& options) {
  auto log = redlog::get_logger("p1ll.apply");
  int log_level = static_cast<int>(redlog::get_level());
  bool verbose_enabled = log_level >= static_cast<int>(redlog::level::verbose);
  bool trace_enabled = log_level >= static_cast<int>(redlog::level::trace);
  size_t patch_size = entry.patch_bytes.size();
  if (patch_size == 0) {
    if (trace_enabled) {
      log.trc("skipping empty patch", redlog::field("address", utils::format_address(entry.address)));
    }
    return ok_result(static_cast<size_t>(0));
  }

  if (trace_enabled) {
    log.trc(
        "applying patch entry", redlog::field("address", utils::format_address(entry.address)),
        redlog::field("patch_size", patch_size), redlog::field("required", entry.spec.required)
    );
  }

  auto region = space.region_info(entry.address);
  if (!region.ok()) {
    return error_result<size_t>(region.status_info.code, "failed to resolve memory region");
  }

  if (entry.address > UINT64_MAX - patch_size) {
    return error_result<size_t>(error_code::invalid_argument, "patch address overflow");
  }
  uint64_t region_end = region.value.base_address + region.value.size;
  if (entry.address < region.value.base_address || entry.address + patch_size > region_end) {
    return error_result<size_t>(error_code::invalid_argument, "patch crosses region boundary");
  }

  auto original_bytes = space.read(entry.address, patch_size);
  if (!original_bytes.ok()) {
    return error_result<size_t>(original_bytes.status_info.code, "failed to read original bytes");
  }

  auto merged = merge_patch_bytes(entry.patch_bytes, entry.patch_mask, original_bytes.value);
  if (!merged.ok()) {
    return error_result<size_t>(merged.status_info.code, merged.status_info.message);
  }

  std::vector<uint8_t> context_before;
  std::vector<uint8_t> context_after;
  uint64_t context_base = entry.address;
  bool has_context = false;
  if (verbose_enabled) {
    has_context = build_patch_context(
        space, entry.address, original_bytes.value, merged.value, context_before, context_after, context_base
    );
  }

  memory_protection original_protection = region.value.protection;
  bool writable = has_protection(original_protection, memory_protection::write);
  bool executable = has_protection(original_protection, memory_protection::execute);

  bool needs_protection_change = !writable;
  if (needs_protection_change) {
    memory_protection desired = original_protection | memory_protection::write;
    if (!options.allow_wx && executable) {
      desired = remove_execute(desired);
    }
    auto status = space.set_protection(entry.address, patch_size, desired);
    if (!status.ok()) {
      return error_result<size_t>(status.code, "failed to change memory protection");
    }
  }

  auto write_status = space.write(entry.address, std::span<const uint8_t>(merged.value));
  if (!write_status.ok()) {
    if (needs_protection_change) {
      auto restore = space.set_protection(entry.address, patch_size, original_protection);
      if (!restore.ok()) {
        log.wrn(
            "failed to restore original protection", redlog::field("address", utils::format_address(entry.address))
        );
      }
    }
    return error_result<size_t>(write_status.code, "failed to write patch bytes");
  }

  if (options.verify) {
    auto verify = space.read(entry.address, patch_size);
    if (!verify.ok() || !std::equal(merged.value.begin(), merged.value.end(), verify.value.begin())) {
      if (options.rollback_on_failure) {
        space.write(entry.address, std::span<const uint8_t>(original_bytes.value));
      }
      if (needs_protection_change) {
        auto restore = space.set_protection(entry.address, patch_size, original_protection);
        if (!restore.ok()) {
          log.wrn(
              "failed to restore original protection", redlog::field("address", utils::format_address(entry.address))
          );
        }
      }
      return error_result<size_t>(error_code::verification_failed, "patch verification failed");
    }
  }

  if (options.flush_icache && executable) {
    auto flush = space.flush_instruction_cache(entry.address, patch_size);
    if (!flush.ok()) {
      log.wrn("failed to flush instruction cache", redlog::field("address", utils::format_address(entry.address)));
    }
  }

  if (needs_protection_change) {
    auto restore = space.set_protection(entry.address, patch_size, original_protection);
    if (!restore.ok()) {
      log.wrn("failed to restore original protection", redlog::field("address", utils::format_address(entry.address)));
    }
  }

  size_t bytes_written = count_written_bytes(entry.patch_mask);
  if (verbose_enabled) {
    const std::vector<uint8_t>* hexdump_before = &original_bytes.value;
    const std::vector<uint8_t>* hexdump_after = &merged.value;
    uint64_t hexdump_base = entry.address;
    if (has_context) {
      hexdump_before = &context_before;
      hexdump_after = &context_after;
      hexdump_base = context_base;
    }

    pretty_logging::log_patch_apply(
        log, entry, bytes_written, region.value, *hexdump_before, *hexdump_after, hexdump_base
    );
  }

  log.inf(
      "patch applied", redlog::field("address", utils::format_address(entry.address)),
      redlog::field("bytes_written", bytes_written)
  );

  return ok_result(bytes_written);
}

} // namespace

result<apply_report> apply_plan(
    address_space& space, const std::vector<plan_entry>& plan, const apply_options& options
) {
  auto log = redlog::get_logger("p1ll.apply");
  apply_report report;

  log.inf("applying patch plan", redlog::field("entries", plan.size()));
  if (static_cast<int>(redlog::get_level()) >= static_cast<int>(redlog::level::trace)) {
    log.trc(
        "apply options", redlog::field("verify", options.verify), redlog::field("flush_icache", options.flush_icache),
        redlog::field("rollback_on_failure", options.rollback_on_failure), redlog::field("allow_wx", options.allow_wx)
    );
  }

  for (const auto& entry : plan) {
    auto applied = apply_entry(space, entry, options);
    if (!applied.ok()) {
      report.failed++;
      report.diagnostics.push_back(applied.status_info);
      if (entry.spec.required) {
        log.err(
            "required patch failed", redlog::field("address", utils::format_address(entry.address)),
            redlog::field("signature", entry.spec.signature.pattern),
            redlog::field("error", applied.status_info.message)
        );
        report.success = false;
        return result<apply_report>{report, applied.status_info};
      }
      log.wrn(
          "optional patch failed", redlog::field("address", utils::format_address(entry.address)),
          redlog::field("signature", entry.spec.signature.pattern), redlog::field("error", applied.status_info.message)
      );
      continue;
    }

    report.applied++;
  }

  report.success = (report.failed == 0 && report.applied > 0);
  log.inf(
      "patch plan complete", redlog::field("success", report.success), redlog::field("applied", report.applied),
      redlog::field("failed", report.failed)
  );
  return ok_result(report);
}

} // namespace p1ll::engine

```

`src/p1ll/engine/apply.hpp`:

```hpp
#pragma once

#include "engine/address_space.hpp"
#include "engine/types.hpp"

namespace p1ll::engine {

struct apply_options {
  bool verify = true;
  bool flush_icache = true;
  bool rollback_on_failure = true;
  bool allow_wx = false;
};

result<apply_report> apply_plan(
    address_space& space, const std::vector<plan_entry>& plan, const apply_options& options
);

} // namespace p1ll::engine

```

`src/p1ll/engine/pattern.cpp`:

```cpp
#include "pattern.hpp"
#include "utils/hex_pattern.hpp"
#include "utils/hex_utils.hpp"
#include <redlog.hpp>
#include <algorithm>
#include <string>

namespace p1ll::engine {

namespace {

result<pattern> parse_pattern_impl(std::string_view hex, error_code invalid_code, std::string_view kind) {
  auto log = redlog::get_logger("p1ll.pattern");
  std::string hex_str(hex);
  log.trc("parsing pattern", redlog::field("kind", kind), redlog::field("input", hex_str));
  if (!p1ll::utils::is_valid_hex_pattern(hex_str)) {
    log.err("invalid pattern", redlog::field("kind", kind), redlog::field("pattern", hex_str));
    return error_result<pattern>(invalid_code, "invalid hex pattern");
  }

  std::string normalized = p1ll::utils::normalize_hex_pattern(hex_str);
  pattern parsed;
  parsed.bytes.reserve(normalized.size() / 2);
  parsed.mask.reserve(normalized.size() / 2);

  for (size_t i = 0; i < normalized.size(); i += 2) {
    char first = normalized[i];
    char second = normalized[i + 1];
    if (first == '?' && second == '?') {
      parsed.bytes.push_back(0x00);
      parsed.mask.push_back(0);
      continue;
    }

    uint8_t high = p1ll::utils::parse_hex_digit(first);
    uint8_t low = p1ll::utils::parse_hex_digit(second);
    parsed.bytes.push_back(static_cast<uint8_t>((high << 4) | low));
    parsed.mask.push_back(1);
  }

  size_t wildcards = static_cast<size_t>(std::count(parsed.mask.begin(), parsed.mask.end(), static_cast<uint8_t>(0)));
  log.dbg(
      "parsed pattern", redlog::field("kind", kind), redlog::field("bytes", parsed.bytes.size()),
      redlog::field("wildcards", wildcards)
  );

  return ok_result(parsed);
}

} // namespace

result<pattern> parse_signature(std::string_view hex) {
  return parse_pattern_impl(hex, error_code::invalid_pattern, "signature");
}

result<pattern> parse_patch(std::string_view hex) {
  return parse_pattern_impl(hex, error_code::invalid_pattern, "patch");
}

} // namespace p1ll::engine

```

`src/p1ll/engine/pattern.hpp`:

```hpp
#pragma once

#include "result.hpp"
#include <cstddef>
#include <cstdint>
#include <string_view>
#include <vector>

namespace p1ll::engine {

// parsed pattern with mask; mask byte 1 means match/write, 0 means wildcard/skip
struct pattern {
  std::vector<uint8_t> bytes;
  std::vector<uint8_t> mask;

  size_t size() const noexcept { return bytes.size(); }
  bool empty() const noexcept { return bytes.empty(); }
};

result<pattern> parse_signature(std::string_view hex);
result<pattern> parse_patch(std::string_view hex);

} // namespace p1ll::engine

```

`src/p1ll/engine/pattern_matcher.cpp`:

```cpp
#include "pattern_matcher.hpp"
#include <redlog.hpp>
#include <algorithm>

namespace p1ll::engine {

pattern_matcher::pattern_matcher(pattern signature) : signature_(std::move(signature)) {
  auto log = redlog::get_logger("p1ll.pattern_matcher");
  if (signature_.empty()) {
    log.err("cannot create pattern matcher with empty signature");
    return;
  }

  build_shift_table();

  size_t wildcards =
      static_cast<size_t>(std::count(signature_.mask.begin(), signature_.mask.end(), static_cast<uint8_t>(0)));
  log.dbg(
      "created pattern matcher", redlog::field("pattern_size", signature_.size()), redlog::field("wildcards", wildcards)
  );
}

void pattern_matcher::build_shift_table() {
  const size_t pattern_len = signature_.size();
  if (pattern_len == 0) {
    return;
  }

  shift_table_.fill(pattern_len);

  for (size_t i = 0; i + 1 < pattern_len; ++i) {
    if (signature_.mask[i]) {
      shift_table_[signature_.bytes[i]] = pattern_len - 1 - i;
    }
  }

  // wildcards require conservative shifts to avoid skipping matches
  for (size_t i = 0; i + 1 < pattern_len; ++i) {
    if (!signature_.mask[i]) {
      size_t wildcard_shift = pattern_len - 1 - i;
      for (size_t b = 0; b < 256; ++b) {
        shift_table_[b] = std::min(shift_table_[b], wildcard_shift);
      }
    }
  }

  size_t exact_bytes =
      static_cast<size_t>(std::count(signature_.mask.begin(), signature_.mask.end(), static_cast<uint8_t>(1)));
  if (pattern_len > 0 && exact_bytes < pattern_len / 2) {
    auto log = redlog::get_logger("p1ll.pattern_matcher");
    log.wrn(
        "pattern has many wildcards, performance may be suboptimal", redlog::field("exact_bytes", exact_bytes),
        redlog::field("total_bytes", pattern_len),
        redlog::field("wildcard_ratio", (pattern_len - exact_bytes) * 100 / pattern_len)
    );
  }

  for (size_t i = 0; i < 256; ++i) {
    if (shift_table_[i] == 0) {
      shift_table_[i] = 1;
    }
  }
}

std::vector<uint64_t> pattern_matcher::search(const uint8_t* data, size_t size) const {
  std::vector<uint64_t> results;
  if (!is_valid() || !data || size < signature_.size()) {
    auto log = redlog::get_logger("p1ll.pattern_matcher");
    log.dbg(
        "search skipped - invalid input", redlog::field("valid", is_valid()),
        redlog::field("data_ptr", data != nullptr), redlog::field("size", size),
        redlog::field("pattern_size", signature_.size())
    );
    return results;
  }

  const size_t pattern_len = signature_.size();
  size_t i = 0;
  while (i + pattern_len <= size) {
    if (match_at_position(data, i)) {
      results.push_back(i);
      i += 1;
    } else {
      size_t last_index = i + pattern_len - 1;
      size_t skip = shift_table_[data[last_index]];
      if (skip == 0) {
        skip = 1;
      }
      i += skip;
    }
  }

  auto log = redlog::get_logger("p1ll.pattern_matcher");
  log.dbg(
      "pattern search completed", redlog::field("search_size", size), redlog::field("pattern_size", pattern_len),
      redlog::field("results", results.size())
  );
  return results;
}

std::optional<uint64_t> pattern_matcher::search_single(const uint8_t* data, size_t size) const {
  auto log = redlog::get_logger("p1ll.pattern_matcher");
  auto results = search(data, size);
  if (results.size() != 1) {
    if (results.empty()) {
      log.dbg("signature not found for single match requirement");
    } else {
      log.err(
          "multiple matches found for single signature", redlog::field("matches", results.size()),
          redlog::field("pattern_size", signature_.size())
      );
      if (static_cast<int>(redlog::get_level()) >= static_cast<int>(redlog::level::pedantic)) {
        for (size_t i = 0; i < results.size(); ++i) {
          log.ped("match location", redlog::field("index", i + 1), redlog::field("offset", results[i]));
        }
      }
    }
    return std::nullopt;
  }
  return results[0];
}

bool pattern_matcher::match_at_position(const uint8_t* data, size_t pos) const {
  const size_t pattern_len = signature_.size();
  for (int i = static_cast<int>(pattern_len) - 1; i >= 0; --i) {
    if (signature_.mask[i]) {
      if (signature_.bytes[i] != data[pos + i]) {
        return false;
      }
    }
  }
  return true;
}

} // namespace p1ll::engine

```

`src/p1ll/engine/pattern_matcher.hpp`:

```hpp
#pragma once

#include "engine/pattern.hpp"
#include <array>
#include <cstdint>
#include <optional>
#include <vector>

namespace p1ll::engine {

// boyer-moore-horspool matcher with wildcard support
class pattern_matcher {
public:
  explicit pattern_matcher(pattern signature);

  std::vector<uint64_t> search(const uint8_t* data, size_t size) const;
  std::optional<uint64_t> search_single(const uint8_t* data, size_t size) const;

  size_t pattern_size() const { return signature_.size(); }
  bool is_valid() const { return !signature_.empty(); }

private:
  pattern signature_;
  std::array<size_t, 256> shift_table_{};

  void build_shift_table();
  bool match_at_position(const uint8_t* data, size_t pos) const;
};

} // namespace p1ll::engine

```

`src/p1ll/engine/plan_builder.cpp`:

```cpp
#include "plan_builder.hpp"
#include "engine/pattern.hpp"
#include "engine/scanner.hpp"
#include "utils/hex_utils.hpp"
#include <redlog.hpp>
#include <algorithm>
#include <sstream>
#include <unordered_map>

namespace p1ll::engine {

namespace {

std::string make_scan_key(const std::string& pattern, const scan_options& options) {
  std::ostringstream oss;
  oss << pattern << "|";
  oss << options.filter.name_regex << "|";
  oss << (options.filter.only_executable ? "1" : "0") << "|";
  oss << (options.filter.exclude_system ? "1" : "0") << "|";
  oss << options.filter.min_size << "|";
  oss << (options.filter.min_address ? std::to_string(*options.filter.min_address) : "-") << "|";
  oss << (options.filter.max_address ? std::to_string(*options.filter.max_address) : "-") << "|";
  oss << (options.single ? "1" : "0") << "|";
  oss << options.max_matches;
  return oss.str();
}

} // namespace

plan_builder::plan_builder(const address_space& space, platform::platform_key platform_key)
    : space_(space), platform_(std::move(platform_key)) {}

result<bool> plan_builder::platform_allowed(const std::vector<std::string>& selectors) const {
  auto log = redlog::get_logger("p1ll.plan_builder");
  if (selectors.empty()) {
    if (static_cast<int>(redlog::get_level()) >= static_cast<int>(redlog::level::trace)) {
      log.trc("no platform selectors provided", redlog::field("platform", platform_.to_string()));
    }
    return ok_result(true);
  }
  for (const auto& selector : selectors) {
    auto parsed = platform::parse_platform(selector);
    if (!parsed.ok()) {
      log.err("invalid platform selector", redlog::field("selector", selector));
      return error_result<bool>(parsed.status_info.code, parsed.status_info.message);
    }
    if (platform::platform_matches(parsed.value, platform_)) {
      if (static_cast<int>(redlog::get_level()) >= static_cast<int>(redlog::level::trace)) {
        log.trc(
            "platform selector matched", redlog::field("selector", selector),
            redlog::field("platform", platform_.to_string())
        );
      }
      return ok_result(true);
    }
  }
  if (static_cast<int>(redlog::get_level()) >= static_cast<int>(redlog::level::trace)) {
    log.trc("no platform selectors matched", redlog::field("platform", platform_.to_string()));
  }
  return ok_result(false);
}

result<std::vector<plan_entry>> plan_builder::build(const recipe& recipe) {
  auto log = redlog::get_logger("p1ll.plan_builder");
  log.trc(
      "building patch plan", redlog::field("recipe", recipe.name),
      redlog::field("validations", recipe.validations.size()), redlog::field("patches", recipe.patches.size())
  );
  auto recipe_ok = platform_allowed(recipe.platforms);
  if (!recipe_ok.ok()) {
    return error_result<std::vector<plan_entry>>(recipe_ok.status_info.code, recipe_ok.status_info.message);
  }
  if (!recipe_ok.value) {
    log.inf("recipe not allowed on this platform", redlog::field("platform", platform_.to_string()));
    return error_result<std::vector<plan_entry>>(error_code::platform_mismatch, "recipe not allowed on this platform");
  }

  scanner scanner(space_);
  std::unordered_map<std::string, pattern> signature_cache;
  std::unordered_map<std::string, result<std::vector<scan_result>>> scan_cache;

  auto compile_signature = [&](const std::string& pattern_str) -> result<pattern> {
    auto it = signature_cache.find(pattern_str);
    if (it != signature_cache.end()) {
      return ok_result(it->second);
    }
    auto parsed = parse_signature(pattern_str);
    if (!parsed.ok()) {
      return error_result<pattern>(parsed.status_info.code, parsed.status_info.message);
    }
    signature_cache.emplace(pattern_str, parsed.value);
    return parsed;
  };

  auto scan_signature = [&](const std::string& pattern_str,
                            const scan_options& options) -> result<std::vector<scan_result>> {
    std::string key = make_scan_key(pattern_str, options);
    auto it = scan_cache.find(key);
    if (it != scan_cache.end()) {
      return it->second;
    }

    auto compiled = compile_signature(pattern_str);
    if (!compiled.ok()) {
      result<std::vector<scan_result>> err =
          error_result<std::vector<scan_result>>(compiled.status_info.code, compiled.status_info.message);
      scan_cache.emplace(key, err);
      return err;
    }

    auto results = scanner.scan(compiled.value, options);
    scan_cache.emplace(key, results);
    return results;
  };

  for (const auto& sig_spec : recipe.validations) {
    auto platform_ok = platform_allowed(sig_spec.platforms);
    if (!platform_ok.ok()) {
      return error_result<std::vector<plan_entry>>(platform_ok.status_info.code, platform_ok.status_info.message);
    }
    if (!platform_ok.value) {
      log.trc("skipping validation for platform mismatch", redlog::field("pattern", sig_spec.pattern));
      continue;
    }

    auto scan_results = scan_signature(sig_spec.pattern, sig_spec.options);
    if (!scan_results.ok()) {
      if (sig_spec.required) {
        log.err(
            "validation scan failed", redlog::field("pattern", sig_spec.pattern),
            redlog::field("error", scan_results.status_info.message)
        );
        return error_result<std::vector<plan_entry>>(
            scan_results.status_info.code, "validation failed: " + sig_spec.pattern
        );
      }
      log.wrn(
          "optional validation scan failed", redlog::field("pattern", sig_spec.pattern),
          redlog::field("error", scan_results.status_info.message)
      );
      continue;
    }

    if (scan_results.value.empty() && sig_spec.required) {
      log.err("validation signature not found", redlog::field("pattern", sig_spec.pattern));
      return error_result<std::vector<plan_entry>>(error_code::not_found, "validation not found: " + sig_spec.pattern);
    }
    if (!scan_results.value.empty()) {
      log.dbg(
          "validated signature", redlog::field("pattern", sig_spec.pattern),
          redlog::field("matches", scan_results.value.size())
      );
    }
  }

  std::vector<plan_entry> entries;
  for (const auto& patch_spec : recipe.patches) {
    auto patch_platform_ok = platform_allowed(patch_spec.platforms);
    if (!patch_platform_ok.ok()) {
      return error_result<std::vector<plan_entry>>(
          patch_platform_ok.status_info.code, patch_platform_ok.status_info.message
      );
    }
    if (!patch_platform_ok.value) {
      log.trc("skipping patch for platform mismatch", redlog::field("pattern", patch_spec.signature.pattern));
      continue;
    }

    auto sig_platform_ok = platform_allowed(patch_spec.signature.platforms);
    if (!sig_platform_ok.ok()) {
      return error_result<std::vector<plan_entry>>(
          sig_platform_ok.status_info.code, sig_platform_ok.status_info.message
      );
    }
    if (!sig_platform_ok.value) {
      log.trc("skipping signature for platform mismatch", redlog::field("pattern", patch_spec.signature.pattern));
      continue;
    }

    auto scan_results = scan_signature(patch_spec.signature.pattern, patch_spec.signature.options);
    if (!scan_results.ok()) {
      if (patch_spec.required) {
        log.err(
            "patch signature scan failed", redlog::field("pattern", patch_spec.signature.pattern),
            redlog::field("error", scan_results.status_info.message)
        );
        return error_result<std::vector<plan_entry>>(
            scan_results.status_info.code, "patch signature failed: " + patch_spec.signature.pattern
        );
      }
      log.wrn(
          "optional patch signature scan failed", redlog::field("pattern", patch_spec.signature.pattern),
          redlog::field("error", scan_results.status_info.message)
      );
      continue;
    }

    if (scan_results.value.empty()) {
      if (patch_spec.required) {
        log.err("patch signature not found", redlog::field("pattern", patch_spec.signature.pattern));
        return error_result<std::vector<plan_entry>>(
            error_code::not_found, "patch signature not found: " + patch_spec.signature.pattern
        );
      }
      log.wrn("optional patch signature not found", redlog::field("pattern", patch_spec.signature.pattern));
      continue;
    }
    log.dbg(
        "patch signature matched", redlog::field("pattern", patch_spec.signature.pattern),
        redlog::field("matches", scan_results.value.size())
    );

    auto parsed_patch = parse_patch(patch_spec.patch);
    if (!parsed_patch.ok()) {
      if (patch_spec.required) {
        log.err("patch pattern invalid", redlog::field("pattern", patch_spec.patch));
        return error_result<std::vector<plan_entry>>(
            parsed_patch.status_info.code, "patch pattern invalid: " + patch_spec.patch
        );
      }
      log.wrn("optional patch pattern invalid", redlog::field("pattern", patch_spec.patch));
      continue;
    }

    size_t patch_count = patch_spec.signature.options.single ? 1 : scan_results.value.size();
    for (size_t i = 0; i < patch_count; ++i) {
      const auto& match = scan_results.value[i];
      uint64_t address = match.address;

      if (patch_spec.offset < 0) {
        uint64_t neg = static_cast<uint64_t>(-patch_spec.offset);
        if (address < neg) {
          if (patch_spec.required) {
            log.err("patch offset underflow", redlog::field("pattern", patch_spec.signature.pattern));
            return error_result<std::vector<plan_entry>>(error_code::invalid_argument, "patch offset underflow");
          }
          log.wrn("optional patch offset underflow", redlog::field("pattern", patch_spec.signature.pattern));
          continue;
        }
        address -= neg;
      } else {
        uint64_t add = static_cast<uint64_t>(patch_spec.offset);
        if (address > UINT64_MAX - add) {
          if (patch_spec.required) {
            log.err("patch offset overflow", redlog::field("pattern", patch_spec.signature.pattern));
            return error_result<std::vector<plan_entry>>(error_code::invalid_argument, "patch offset overflow");
          }
          log.wrn("optional patch offset overflow", redlog::field("pattern", patch_spec.signature.pattern));
          continue;
        }
        address += add;
      }

      plan_entry entry;
      entry.spec = patch_spec;
      entry.address = address;
      entry.patch_bytes = parsed_patch.value.bytes;
      entry.patch_mask = parsed_patch.value.mask;
      entries.push_back(std::move(entry));
    }
  }

  if (entries.empty()) {
    log.err("no patch entries produced");
    return error_result<std::vector<plan_entry>>(error_code::not_found, "no patch entries produced");
  }

  std::sort(entries.begin(), entries.end(), [](const plan_entry& a, const plan_entry& b) {
    if (a.address == b.address) {
      return a.patch_bytes.size() < b.patch_bytes.size();
    }
    return a.address < b.address;
  });

  for (size_t i = 1; i < entries.size(); ++i) {
    const auto& prev = entries[i - 1];
    const auto& current = entries[i];
    uint64_t prev_end = prev.address + prev.patch_bytes.size();
    if (prev_end < prev.address) {
      log.err("patch range overflow");
      return error_result<std::vector<plan_entry>>(error_code::invalid_argument, "patch range overflow");
    }
    if (current.address < prev_end) {
      log.err(
          "patches overlap in plan", redlog::field("first", utils::format_address(prev.address)),
          redlog::field("second", utils::format_address(current.address))
      );
      return error_result<std::vector<plan_entry>>(error_code::overlap, "patches overlap in plan");
    }
  }

  log.dbg("built patch plan", redlog::field("entries", entries.size()));
  return ok_result(entries);
}

} // namespace p1ll::engine

```

`src/p1ll/engine/plan_builder.hpp`:

```hpp
#pragma once

#include "engine/address_space.hpp"
#include "engine/types.hpp"
#include "engine/platform/platform.hpp"
#include <unordered_map>

namespace p1ll::engine {

class plan_builder {
public:
  plan_builder(const address_space& space, platform::platform_key platform_key);

  result<std::vector<plan_entry>> build(const recipe& recipe);

private:
  const address_space& space_;
  platform::platform_key platform_;

  result<bool> platform_allowed(const std::vector<std::string>& selectors) const;
};

} // namespace p1ll::engine

```

`src/p1ll/engine/platform/platform.cpp`:

```cpp
#include "platform.hpp"
#include <redlog.hpp>
#include <algorithm>

namespace p1ll::engine::platform {

namespace {

std::string detect_operating_system() {
#ifdef __APPLE__
  return "darwin";
#elif __linux__
  return "linux";
#elif _WIN32
  return "windows";
#elif __FreeBSD__
  return "freebsd";
#elif __OpenBSD__
  return "openbsd";
#elif __NetBSD__
  return "netbsd";
#elif __DragonFly__
  return "dragonfly";
#elif __sun
  return "solaris";
#elif __CYGWIN__
  return "cygwin";
#elif __MINGW32__ || __MINGW64__
  return "mingw";
#else
  return "unknown";
#endif
}

std::string detect_architecture() {
#if defined(__x86_64__) || defined(_M_X64)
  return "x64";
#elif defined(__aarch64__) || defined(_M_ARM64)
  return "arm64";
#elif defined(__i386__) || defined(_M_IX86)
  return "x86";
#elif defined(__arm__) || defined(_M_ARM)
  return "arm";
#elif defined(__riscv) && (__riscv_xlen == 64)
  return "riscv64";
#elif defined(__riscv) && (__riscv_xlen == 32)
  return "riscv32";
#elif defined(__mips__) && defined(__mips64)
  return "mips64";
#elif defined(__mips__)
  return "mips";
#elif defined(__powerpc64__) || defined(__ppc64__)
  return "ppc64";
#elif defined(__powerpc__) || defined(__ppc__)
  return "ppc";
#elif defined(__s390x__)
  return "s390x";
#elif defined(__s390__)
  return "s390";
#else
  return "unknown";
#endif
}

std::string trim(std::string_view input) {
  std::string value(input);
  auto start = value.find_first_not_of(" \t");
  auto end = value.find_last_not_of(" \t");
  if (start == std::string::npos || end == std::string::npos) {
    return "";
  }
  return value.substr(start, end - start + 1);
}

} // namespace

platform_key detect_platform() {
  platform_key key;
  key.os = detect_operating_system();
  key.arch = detect_architecture();
  auto log = redlog::get_logger("p1ll.platform");
  if (key.os == "unknown") {
    log.wrn("unknown operating system detected - consider adding support");
  }
  if (key.arch == "unknown") {
    log.wrn("unknown architecture detected - consider adding support");
  }
  log.dbg("detected platform", redlog::field("os", key.os), redlog::field("arch", key.arch));
  return key;
}

result<platform_key> parse_platform(std::string_view key) {
  auto log = redlog::get_logger("p1ll.platform");
  std::string text = trim(key);
  if (text.empty()) {
    log.wrn("empty platform selector, using wildcard");
    return ok_result(platform_key{"*", "*"});
  }
  if (text == "*") {
    return ok_result(platform_key{"*", "*"});
  }

  auto colon_pos = text.find(':');
  platform_key parsed;
  if (colon_pos == std::string::npos) {
    parsed.os = trim(text);
    parsed.arch = "*";
  } else {
    auto left = trim(text.substr(0, colon_pos));
    auto right = trim(text.substr(colon_pos + 1));
    parsed.os = left.empty() ? "*" : left;
    parsed.arch = right.empty() ? "*" : right;
  }

  if (parsed.os.empty() || parsed.arch.empty()) {
    log.err("invalid platform selector", redlog::field("input", std::string(key)));
    return error_result<platform_key>(error_code::invalid_argument, "invalid platform selector");
  }

  log.dbg(
      "parsed platform selector", redlog::field("input", text), redlog::field("os", parsed.os),
      redlog::field("arch", parsed.arch)
  );
  return ok_result(parsed);
}

bool platform_matches(const platform_key& selector, const platform_key& target) {
  bool os_match = selector.os == "*" || target.os == "*" || selector.os == target.os;
  bool arch_match = selector.arch == "*" || target.arch == "*" || selector.arch == target.arch;
  return os_match && arch_match;
}

bool platform_matches(std::string_view selector, const platform_key& target) {
  auto parsed = parse_platform(selector);
  if (!parsed.ok()) {
    return false;
  }
  return platform_matches(parsed.value, target);
}

bool any_platform_matches(const std::vector<std::string>& selectors, const platform_key& target) {
  if (selectors.empty()) {
    return true;
  }
  for (const auto& selector : selectors) {
    if (platform_matches(selector, target)) {
      return true;
    }
  }
  return false;
}

} // namespace p1ll::engine::platform

```

`src/p1ll/engine/platform/platform.hpp`:

```hpp
#pragma once

#include "engine/result.hpp"
#include <string>
#include <string_view>
#include <vector>

namespace p1ll::engine::platform {

struct platform_key {
  std::string os;
  std::string arch;

  std::string to_string() const { return os + ":" + arch; }
};

platform_key detect_platform();
result<platform_key> parse_platform(std::string_view key);
bool platform_matches(const platform_key& selector, const platform_key& target);
bool platform_matches(std::string_view selector, const platform_key& target);
bool any_platform_matches(const std::vector<std::string>& selectors, const platform_key& target);

} // namespace p1ll::engine::platform

```

`src/p1ll/engine/platform/process_memory.hpp`:

```hpp
#pragma once

#include "engine/result.hpp"
#include "engine/types.hpp"
#include <cstddef>
#include <cstdint>
#include <span>
#include <vector>

namespace p1ll::engine::platform {

// platform-specific process memory operations
result<std::vector<memory_region>> enumerate_regions();
result<memory_region> region_info(uint64_t address);
result<std::vector<uint8_t>> read(uint64_t address, size_t size);
status write(uint64_t address, std::span<const uint8_t> data);
status set_protection(uint64_t address, size_t size, memory_protection protection);
status flush_instruction_cache(uint64_t address, size_t size);
result<void*> allocate(size_t size, memory_protection protection);
status free(void* address, size_t size);
result<size_t> page_size();

} // namespace p1ll::engine::platform

```

`src/p1ll/engine/platform/process_memory_common.hpp`:

```hpp
#pragma once

#include "engine/types.hpp"
#include <algorithm>
#include <cctype>
#include <string>

#ifdef _WIN32
#include <windows.h>
#endif

namespace p1ll::engine::platform {

// best-effort system library detection based on path prefixes
inline bool is_system_region(const memory_region& region) {
  if (region.name.empty()) {
    return false;
  }
#ifdef _WIN32
  char system_path_buf[MAX_PATH];
  if (GetSystemDirectoryA(system_path_buf, MAX_PATH) == 0) {
    return false;
  }
  std::string system_path(system_path_buf);
  std::string module_path = region.name;
  std::transform(system_path.begin(), system_path.end(), system_path.begin(), ::tolower);
  std::transform(module_path.begin(), module_path.end(), module_path.begin(), ::tolower);
  return module_path.rfind(system_path, 0) == 0;
#elif defined(__APPLE__)
  return region.name.rfind("/System/", 0) == 0 || region.name.rfind("/usr/lib/", 0) == 0 ||
         region.name.rfind("/usr/libexec/", 0) == 0;
#elif defined(__linux__)
  return region.name.rfind("/lib/", 0) == 0 || region.name.rfind("/usr/lib/", 0) == 0 ||
         region.name.rfind("/lib64/", 0) == 0 || region.name.rfind("/usr/lib64/", 0) == 0 ||
         region.name.rfind("/usr/libexec/", 0) == 0;
#else
  return false;
#endif
}

} // namespace p1ll::engine::platform

```

`src/p1ll/engine/platform/process_memory_linux.cpp`:

```cpp
#ifdef __linux__

#include "process_memory.hpp"
#include "process_memory_common.hpp"
#include "utils/memory_align.hpp"
#include <elf.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <cerrno>
#include <cstring>
#include <fstream>
#include <sstream>

namespace p1ll::engine::platform {

namespace {

memory_protection platform_to_protection(int prot) {
  memory_protection result = memory_protection::none;
  if (prot & PROT_READ) {
    result = result | memory_protection::read;
  }
  if (prot & PROT_WRITE) {
    result = result | memory_protection::write;
  }
  if (prot & PROT_EXEC) {
    result = result | memory_protection::execute;
  }
  return result;
}

int protection_to_platform(memory_protection protection) {
  int result = PROT_NONE;
  if (has_protection(protection, memory_protection::read)) {
    result |= PROT_READ;
  }
  if (has_protection(protection, memory_protection::write)) {
    result |= PROT_WRITE;
  }
  if (has_protection(protection, memory_protection::execute)) {
    result |= PROT_EXEC;
  }
  return result;
}

} // namespace

result<std::vector<memory_region>> enumerate_regions() {
  std::ifstream maps("/proc/self/maps");
  if (!maps) {
    return error_result<std::vector<memory_region>>(error_code::io_error, "failed to open /proc/self/maps");
  }

  std::vector<memory_region> regions;
  std::string line;
  while (std::getline(maps, line)) {
    std::stringstream ss(line);
    uint64_t start = 0;
    uint64_t end = 0;
    std::string perms_str;
    std::string offset_str;
    std::string dev_str;
    std::string inode_str;
    std::string path_str;

    ss >> std::hex >> start;
    ss.ignore(1, '-');
    ss >> std::hex >> end >> perms_str >> offset_str >> dev_str >> inode_str;
    std::getline(ss, path_str);
    if (!path_str.empty()) {
      auto first = path_str.find_first_not_of(" \t");
      if (first != std::string::npos) {
        path_str.erase(0, first);
      } else {
        path_str.clear();
      }
    }

    memory_region region;
    region.base_address = start;
    region.size = static_cast<size_t>(end - start);
    region.name = path_str;

    int perms = 0;
    if (perms_str.size() > 0 && perms_str[0] == 'r') {
      perms |= PROT_READ;
    }
    if (perms_str.size() > 1 && perms_str[1] == 'w') {
      perms |= PROT_WRITE;
    }
    if (perms_str.size() > 2 && perms_str[2] == 'x') {
      perms |= PROT_EXEC;
    }

    region.protection = platform_to_protection(perms);
    region.is_executable = has_protection(region.protection, memory_protection::execute);
    region.is_system = is_system_region(region);
    regions.push_back(region);
  }

  return ok_result(regions);
}

result<memory_region> region_info(uint64_t address) {
  auto regions = enumerate_regions();
  if (!regions.ok()) {
    return error_result<memory_region>(regions.status_info.code, regions.status_info.message);
  }
  for (const auto& region : regions.value) {
    if (address >= region.base_address && address < (region.base_address + region.size)) {
      return ok_result(region);
    }
  }
  return error_result<memory_region>(error_code::not_found, "address not found in memory map");
}

result<std::vector<uint8_t>> read(uint64_t address, size_t size) {
  std::vector<uint8_t> buffer(size);
  if (size == 0) {
    return ok_result(buffer);
  }
  std::memcpy(buffer.data(), reinterpret_cast<const void*>(address), size);
  return ok_result(buffer);
}

status write(uint64_t address, std::span<const uint8_t> data) {
  if (data.empty()) {
    return ok_status();
  }
  std::memcpy(reinterpret_cast<void*>(address), data.data(), data.size());
  return ok_status();
}

status set_protection(uint64_t address, size_t size, memory_protection protection) {
  if (size == 0) {
    return make_status(error_code::invalid_argument, "size cannot be zero");
  }

  auto page = page_size();
  if (!page.ok()) {
    return page.status_info;
  }

  uint64_t aligned_start = p1ll::utils::align_down(address, page.value);
  uint64_t aligned_end = p1ll::utils::align_up(address + size, page.value);
  if (aligned_end < aligned_start) {
    return make_status(error_code::invalid_argument, "alignment overflow");
  }
  size_t aligned_size = static_cast<size_t>(aligned_end - aligned_start);

  int prot = protection_to_platform(protection);
  if (mprotect(reinterpret_cast<void*>(aligned_start), aligned_size, prot) == -1) {
    return make_status(error_code::protection_error, "mprotect failed");
  }

  return ok_status();
}

status flush_instruction_cache(uint64_t address, size_t size) {
  if (size == 0) {
    return ok_status();
  }
  void* start = reinterpret_cast<void*>(address);
  void* end = reinterpret_cast<void*>(address + size);
  __builtin___clear_cache(start, end);
  return ok_status();
}

result<void*> allocate(size_t size, memory_protection protection) {
  if (size == 0) {
    return error_result<void*>(error_code::invalid_argument, "size must be non-zero");
  }

  void* address = mmap(NULL, size, protection_to_platform(protection), MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (address == MAP_FAILED) {
    return error_result<void*>(error_code::io_error, "mmap failed");
  }

  return ok_result(address);
}

status free(void* address, size_t size) {
  if (!address || size == 0) {
    return make_status(error_code::invalid_argument, "invalid address or size");
  }
  if (munmap(address, size) != 0) {
    return make_status(error_code::io_error, "munmap failed");
  }
  return ok_status();
}

result<size_t> page_size() {
  long page = sysconf(_SC_PAGESIZE);
  if (page <= 0) {
    return error_result<size_t>(error_code::io_error, "sysconf(_SC_PAGESIZE) failed");
  }
  return ok_result(static_cast<size_t>(page));
}

} // namespace p1ll::engine::platform

#endif // __linux__

```

`src/p1ll/engine/platform/process_memory_macos.cpp`:

```cpp
#ifdef __APPLE__

#include "process_memory.hpp"
#include "process_memory_common.hpp"
#include "utils/memory_align.hpp"
#include <mach/mach.h>
#include <mach/mach_vm.h>
#include <libproc.h>
#include <libkern/OSCacheControl.h>
#include <unistd.h>
#include <cerrno>
#include <cstring>

namespace p1ll::engine::platform {

namespace {

memory_protection platform_to_protection(vm_prot_t prot) {
  memory_protection result = memory_protection::none;
  if (prot & VM_PROT_READ) {
    result = result | memory_protection::read;
  }
  if (prot & VM_PROT_WRITE) {
    result = result | memory_protection::write;
  }
  if (prot & VM_PROT_EXECUTE) {
    result = result | memory_protection::execute;
  }
  return result;
}

int protection_to_platform(memory_protection protection) {
  int result = VM_PROT_NONE;
  if (has_protection(protection, memory_protection::read)) {
    result |= VM_PROT_READ;
  }
  if (has_protection(protection, memory_protection::write)) {
    result |= (VM_PROT_WRITE | VM_PROT_COPY);
  }
  if (has_protection(protection, memory_protection::execute)) {
    result |= VM_PROT_EXECUTE;
  }
  return result;
}

} // namespace

result<std::vector<memory_region>> enumerate_regions() {
  std::vector<memory_region> regions;

  task_t task = mach_task_self();
  mach_vm_address_t address = 0;
  int pid = getpid();

  for (;;) {
    mach_vm_size_t size = 0;
    vm_region_submap_info_data_64_t info;
    mach_msg_type_number_t count = VM_REGION_SUBMAP_INFO_COUNT_64;
    uint32_t depth = 1;

    kern_return_t kr = mach_vm_region_recurse(task, &address, &size, &depth, (vm_region_recurse_info_t) &info, &count);
    if (kr != KERN_SUCCESS) {
      break;
    }

    memory_region region;
    region.base_address = address;
    region.size = size;
    region.protection = platform_to_protection(info.protection);
    region.is_executable = has_protection(region.protection, memory_protection::execute);

    char filename[PATH_MAX] = {0};
    if (proc_regionfilename(pid, address, filename, sizeof(filename)) > 0) {
      region.name = filename;
    }
    region.is_system = is_system_region(region);
    regions.push_back(region);

    address += size;
  }

  return ok_result(regions);
}

result<memory_region> region_info(uint64_t address) {
  mach_vm_address_t target_address = address;
  mach_vm_size_t size = 0;
  vm_region_basic_info_data_64_t info;
  mach_msg_type_number_t info_count = VM_REGION_BASIC_INFO_COUNT_64;
  mach_port_t object_name;

  kern_return_t kr = mach_vm_region(
      mach_task_self(), &target_address, &size, VM_REGION_BASIC_INFO, (vm_region_info_t) &info, &info_count,
      &object_name
  );
  if (kr != KERN_SUCCESS) {
    return error_result<memory_region>(error_code::io_error, "mach_vm_region failed");
  }
  if (address < target_address || address >= target_address + size) {
    return error_result<memory_region>(error_code::not_found, "address not found in region");
  }

  memory_region region;
  region.base_address = target_address;
  region.size = size;
  region.protection = platform_to_protection(info.protection);
  region.is_executable = has_protection(region.protection, memory_protection::execute);

  char filename[PATH_MAX] = {0};
  if (proc_regionfilename(getpid(), target_address, filename, sizeof(filename)) > 0) {
    region.name = filename;
    region.is_system = is_system_region(region);
  }

  return ok_result(region);
}

result<std::vector<uint8_t>> read(uint64_t address, size_t size) {
  std::vector<uint8_t> buffer(size);
  if (size == 0) {
    return ok_result(buffer);
  }

  std::memcpy(buffer.data(), reinterpret_cast<const void*>(address), size);
  return ok_result(buffer);
}

status write(uint64_t address, std::span<const uint8_t> data) {
  if (data.empty()) {
    return ok_status();
  }
  std::memcpy(reinterpret_cast<void*>(address), data.data(), data.size());
  return ok_status();
}

status set_protection(uint64_t address, size_t size, memory_protection protection) {
  if (size == 0) {
    return make_status(error_code::invalid_argument, "size cannot be zero");
  }

  auto page = page_size();
  if (!page.ok()) {
    return page.status_info;
  }

  uint64_t aligned_start = p1ll::utils::align_down(address, page.value);
  uint64_t aligned_end = p1ll::utils::align_up(address + size, page.value);
  if (aligned_end < aligned_start) {
    return make_status(error_code::invalid_argument, "alignment overflow");
  }

  size_t aligned_size = static_cast<size_t>(aligned_end - aligned_start);
  int prot = protection_to_platform(protection);

  kern_return_t kr = mach_vm_protect(mach_task_self(), aligned_start, aligned_size, FALSE, prot);
  if (kr != KERN_SUCCESS) {
    return make_status(error_code::protection_error, "mach_vm_protect failed");
  }

  return ok_status();
}

status flush_instruction_cache(uint64_t address, size_t size) {
  if (size == 0) {
    return ok_status();
  }
  sys_icache_invalidate(reinterpret_cast<void*>(address), size);
  return ok_status();
}

result<void*> allocate(size_t size, memory_protection protection) {
  if (size == 0) {
    return error_result<void*>(error_code::invalid_argument, "size must be non-zero");
  }

  vm_address_t address = 0;
  kern_return_t kr = vm_allocate(mach_task_self(), &address, size, VM_FLAGS_ANYWHERE);
  if (kr != KERN_SUCCESS) {
    return error_result<void*>(error_code::io_error, "vm_allocate failed");
  }

  kr = vm_protect(mach_task_self(), address, size, FALSE, protection_to_platform(protection));
  if (kr != KERN_SUCCESS) {
    vm_deallocate(mach_task_self(), address, size);
    return error_result<void*>(error_code::protection_error, "vm_protect failed");
  }

  return ok_result(reinterpret_cast<void*>(address));
}

status free(void* address, size_t size) {
  if (!address || size == 0) {
    return make_status(error_code::invalid_argument, "invalid address or size");
  }
  if (vm_deallocate(mach_task_self(), reinterpret_cast<vm_address_t>(address), size) != KERN_SUCCESS) {
    return make_status(error_code::io_error, "vm_deallocate failed");
  }
  return ok_status();
}

result<size_t> page_size() {
  long page = sysconf(_SC_PAGESIZE);
  if (page <= 0) {
    return error_result<size_t>(error_code::io_error, "sysconf(_SC_PAGESIZE) failed");
  }
  return ok_result(static_cast<size_t>(page));
}

} // namespace p1ll::engine::platform

#endif // __APPLE__

```

`src/p1ll/engine/platform/process_memory_windows.cpp`:

```cpp
#ifdef _WIN32

#include "process_memory.hpp"
#include "process_memory_common.hpp"
#include "utils/memory_align.hpp"
#include "utils/windows_compat.hpp"
#include <psapi.h>

namespace p1ll::engine::platform {

namespace {

static constexpr DWORD k_windows_protection_mask = 0xFF;

memory_protection platform_to_protection(DWORD prot) {
  DWORD p = prot & k_windows_protection_mask;
  if (p == PAGE_EXECUTE_READWRITE || p == PAGE_EXECUTE_WRITECOPY) {
    return memory_protection::read_write_execute;
  }
  if (p == PAGE_EXECUTE_READ) {
    return memory_protection::read_execute;
  }
  if (p == PAGE_EXECUTE) {
    return memory_protection::execute;
  }
  if (p == PAGE_READWRITE) {
    return memory_protection::read_write;
  }
  if (p == PAGE_READONLY || p == PAGE_WRITECOPY) {
    return memory_protection::read;
  }
  return memory_protection::none;
}

DWORD protection_to_platform(memory_protection protection) {
  bool r = has_protection(protection, memory_protection::read);
  bool w = has_protection(protection, memory_protection::write);
  bool x = has_protection(protection, memory_protection::execute);
  if (x && r && w) {
    return PAGE_EXECUTE_READWRITE;
  }
  if (x && r) {
    return PAGE_EXECUTE_READ;
  }
  if (x) {
    return PAGE_EXECUTE;
  }
  if (r && w) {
    return PAGE_READWRITE;
  }
  if (r) {
    return PAGE_READONLY;
  }
  return PAGE_NOACCESS;
}

} // namespace

result<std::vector<memory_region>> enumerate_regions() {
  std::vector<memory_region> regions;

  HANDLE process = GetCurrentProcess();
  SYSTEM_INFO si;
  GetSystemInfo(&si);

  uint64_t current = reinterpret_cast<uint64_t>(si.lpMinimumApplicationAddress);
  uint64_t max_address = reinterpret_cast<uint64_t>(si.lpMaximumApplicationAddress);

  while (current < max_address) {
    MEMORY_BASIC_INFORMATION mbi;
    if (VirtualQueryEx(process, reinterpret_cast<LPCVOID>(current), &mbi, sizeof(mbi)) == 0) {
      break;
    }

    if (mbi.State == MEM_COMMIT) {
      memory_region region;
      region.base_address = reinterpret_cast<uint64_t>(mbi.BaseAddress);
      region.size = mbi.RegionSize;
      region.protection = platform_to_protection(mbi.Protect);
      region.is_executable = has_protection(region.protection, memory_protection::execute);

      char filename[MAX_PATH];
      if (mbi.Type != MEM_PRIVATE && GetMappedFileNameA(process, mbi.BaseAddress, filename, sizeof(filename)) > 0) {
        region.name = filename;
      }

      region.is_system = is_system_region(region);
      regions.push_back(region);
    }

    uint64_t next = reinterpret_cast<uint64_t>(mbi.BaseAddress) + mbi.RegionSize;
    if (next <= current) {
      break;
    }
    current = next;
  }

  return ok_result(regions);
}

result<memory_region> region_info(uint64_t address) {
  MEMORY_BASIC_INFORMATION mbi;
  if (VirtualQuery(reinterpret_cast<LPCVOID>(address), &mbi, sizeof(mbi)) == 0) {
    return error_result<memory_region>(error_code::io_error, "VirtualQuery failed");
  }

  memory_region region;
  region.base_address = reinterpret_cast<uint64_t>(mbi.BaseAddress);
  region.size = mbi.RegionSize;
  region.protection = platform_to_protection(mbi.Protect);
  region.is_executable = has_protection(region.protection, memory_protection::execute);

  char filename[MAX_PATH];
  if (mbi.Type != MEM_PRIVATE &&
      GetMappedFileNameA(GetCurrentProcess(), mbi.BaseAddress, filename, sizeof(filename)) > 0) {
    region.name = filename;
    region.is_system = is_system_region(region);
  }

  return ok_result(region);
}

result<std::vector<uint8_t>> read(uint64_t address, size_t size) {
  std::vector<uint8_t> buffer(size);
  if (size == 0) {
    return ok_result(buffer);
  }
  SIZE_T bytes_read = 0;
  if (!ReadProcessMemory(GetCurrentProcess(), reinterpret_cast<LPCVOID>(address), buffer.data(), size, &bytes_read) ||
      bytes_read != size) {
    return error_result<std::vector<uint8_t>>(error_code::io_error, "ReadProcessMemory failed");
  }
  return ok_result(buffer);
}

status write(uint64_t address, std::span<const uint8_t> data) {
  if (data.empty()) {
    return ok_status();
  }
  SIZE_T bytes_written = 0;
  if (!WriteProcessMemory(
          GetCurrentProcess(), reinterpret_cast<LPVOID>(address), data.data(), data.size(), &bytes_written
      ) ||
      bytes_written != data.size()) {
    return make_status(error_code::io_error, "WriteProcessMemory failed");
  }
  return ok_status();
}

status set_protection(uint64_t address, size_t size, memory_protection protection) {
  if (size == 0) {
    return make_status(error_code::invalid_argument, "size cannot be zero");
  }

  auto page = page_size();
  if (!page.ok()) {
    return page.status_info;
  }

  uint64_t aligned_start = p1ll::utils::align_down(address, page.value);
  uint64_t aligned_end = p1ll::utils::align_up(address + size, page.value);
  if (aligned_end < aligned_start) {
    return make_status(error_code::invalid_argument, "alignment overflow");
  }
  size_t aligned_size = static_cast<size_t>(aligned_end - aligned_start);

  DWORD old_protect;
  if (!VirtualProtect(
          reinterpret_cast<LPVOID>(aligned_start), aligned_size, protection_to_platform(protection), &old_protect
      )) {
    return make_status(error_code::protection_error, "VirtualProtect failed");
  }
  return ok_status();
}

status flush_instruction_cache(uint64_t address, size_t size) {
  if (size == 0) {
    return ok_status();
  }
  if (!FlushInstructionCache(GetCurrentProcess(), reinterpret_cast<LPCVOID>(address), size)) {
    return make_status(error_code::io_error, "FlushInstructionCache failed");
  }
  return ok_status();
}

result<void*> allocate(size_t size, memory_protection protection) {
  if (size == 0) {
    return error_result<void*>(error_code::invalid_argument, "size must be non-zero");
  }
  void* address = VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, protection_to_platform(protection));
  if (!address) {
    return error_result<void*>(error_code::io_error, "VirtualAlloc failed");
  }
  return ok_result(address);
}

status free(void* address, size_t size) {
  if (!address || size == 0) {
    return make_status(error_code::invalid_argument, "invalid address or size");
  }
  if (!VirtualFree(address, 0, MEM_RELEASE)) {
    return make_status(error_code::io_error, "VirtualFree failed");
  }
  return ok_status();
}

result<size_t> page_size() {
  SYSTEM_INFO si;
  GetSystemInfo(&si);
  return ok_result(static_cast<size_t>(si.dwPageSize));
}

} // namespace p1ll::engine::platform

#endif // _WIN32

```

`src/p1ll/engine/pretty_logging.hpp`:

```hpp
#pragma once

#include "engine/pattern.hpp"
#include "engine/types.hpp"
#include "utils/hex_pattern.hpp"
#include "utils/hex_utils.hpp"
#include "utils/pretty_hexdump.hpp"
#include <redlog.hpp>
#include <string>
#include <vector>

namespace p1ll::engine::pretty_logging {

inline std::string render_signature_pattern(const pattern& signature) {
  return utils::format_signature_pattern(signature.bytes, signature.mask);
}

inline std::string render_patch_pattern(const plan_entry& entry) {
  return utils::format_patch_pattern(entry.patch_bytes, entry.patch_mask);
}

inline std::string render_region_desc(const memory_region& region) {
  return utils::format_memory_region(region.base_address, region.size, region.name);
}

inline void log_signature_match(
    redlog::logger& log, const std::string& signature_pattern, uint64_t match_address, const std::string& region_name,
    const uint8_t* data, size_t data_size, size_t match_offset, size_t pattern_size, uint64_t base_offset
) {
  log.vrb(
      "signature match", redlog::field("pattern", signature_pattern),
      redlog::field("address", utils::format_address(match_address)), redlog::field("region", region_name)
  );

  std::string match_hexdump =
      utils::format_signature_match_hexdump(data, data_size, match_offset, pattern_size, base_offset);
  if (!match_hexdump.empty()) {
    log.vrb(redlog::fmt("signature\n%s", match_hexdump));
  }
}

inline void log_patch_apply(
    redlog::logger& log, const plan_entry& entry, size_t bytes_written, const memory_region& region,
    const std::vector<uint8_t>& before, const std::vector<uint8_t>& after, uint64_t base_offset
) {
  std::string patch_pattern = render_patch_pattern(entry);
  std::string region_desc = render_region_desc(region);

  log.vrb(
      "patch applied", redlog::field("address", utils::format_address(entry.address)),
      redlog::field("bytes_written", bytes_written), redlog::field("signature", entry.spec.signature.pattern),
      redlog::field("patch", patch_pattern), redlog::field("region", region_desc)
  );

  std::string patch_hexdump = utils::format_patch_hexdump(before, after, base_offset);
  if (!patch_hexdump.empty()) {
    log.vrb(redlog::fmt("patch\n%s", patch_hexdump));
  }
}

} // namespace p1ll::engine::pretty_logging

```

`src/p1ll/engine/result.hpp`:

```hpp
#pragma once

#include <string>
#include <utility>

namespace p1ll::engine {

// engine error codes for structured results
enum class error_code {
  ok,
  invalid_argument,
  invalid_pattern,
  not_found,
  multiple_matches,
  io_error,
  protection_error,
  verification_failed,
  platform_mismatch,
  overlap,
  unsupported,
  invalid_context,
  internal_error
};

// status holds an error code and a human-readable message
struct status {
  error_code code = error_code::ok;
  std::string message;

  bool ok() const noexcept { return code == error_code::ok; }
};

inline status ok_status() { return {}; }

inline status make_status(error_code code, std::string message) { return status{code, std::move(message)}; }

// result carries a value and a status; value is default-initialized on errors
template <typename T> struct result {
  T value{};
  status status_info{};

  bool ok() const noexcept { return status_info.ok(); }
};

template <typename T> inline result<T> ok_result(T value) { return result<T>{std::move(value), ok_status()}; }

template <typename T> inline result<T> error_result(error_code code, std::string message) {
  return result<T>{T{}, make_status(code, std::move(message))};
}

} // namespace p1ll::engine

```

`src/p1ll/engine/scanner.cpp`:

```cpp
#include "scanner.hpp"
#include "pattern_matcher.hpp"
#include "pretty_logging.hpp"
#include "utils/hex_utils.hpp"
#include <redlog.hpp>
#include <algorithm>
#include <filesystem>

namespace p1ll::engine {

namespace {

constexpr size_t k_chunk_size = 1024 * 1024;

size_t effective_max_matches(const scan_options& options) {
  if (!options.single) {
    return options.max_matches;
  }
  if (options.max_matches == 0) {
    return 2;
  }
  return std::max<size_t>(options.max_matches, 2);
}

} // namespace

scanner::scanner(const address_space& space) : space_(space) {}

result<std::vector<scan_result>> scanner::scan(const pattern& signature, const scan_options& options) const {
  if (signature.empty()) {
    return ok_result(std::vector<scan_result>{});
  }

  auto log = redlog::get_logger("p1ll.scanner");
  int log_level = static_cast<int>(redlog::get_level());
  bool verbose_enabled = log_level >= static_cast<int>(redlog::level::verbose);
  bool trace_enabled = log_level >= static_cast<int>(redlog::level::trace);
  bool pedantic_enabled = log_level >= static_cast<int>(redlog::level::pedantic);

  if (trace_enabled) {
    log.trc(
        "starting signature scan", redlog::field("pattern_size", signature.size()),
        redlog::field("single", options.single), redlog::field("max_matches", options.max_matches),
        redlog::field("filter_name_regex", options.filter.name_regex),
        redlog::field("filter_only_executable", options.filter.only_executable),
        redlog::field("filter_exclude_system", options.filter.exclude_system),
        redlog::field("filter_min_size", options.filter.min_size),
        redlog::field(
            "filter_min_address", options.filter.min_address ? utils::format_address(*options.filter.min_address) : "-"
        ),
        redlog::field(
            "filter_max_address", options.filter.max_address ? utils::format_address(*options.filter.max_address) : "-"
        )
    );
  }

  std::string signature_pattern;
  if (verbose_enabled) {
    signature_pattern = pretty_logging::render_signature_pattern(signature);
  }

  auto regions = space_.regions(options.filter);
  if (!regions.ok()) {
    log.err("failed to enumerate scan regions", redlog::field("error", regions.status_info.message));
    return error_result<std::vector<scan_result>>(regions.status_info.code, regions.status_info.message);
  }

  std::vector<scan_result> results;
  pattern_matcher matcher(signature);
  size_t overlap = signature.size() > 0 ? signature.size() - 1 : 0;
  size_t max_matches = effective_max_matches(options);

  for (const auto& region : regions.value) {
    if (region.size < signature.size() || !has_protection(region.protection, memory_protection::read)) {
      if (pedantic_enabled) {
        log.ped(
            "skipping region", redlog::field("base", utils::format_address(region.base_address)),
            redlog::field("size", region.size),
            redlog::field("readable", has_protection(region.protection, memory_protection::read))
        );
      }
      continue;
    }

    if (pedantic_enabled) {
      log.ped(
          "scanning region", redlog::field("base", utils::format_address(region.base_address)),
          redlog::field("size", region.size), redlog::field("name", region.name.empty() ? "[anonymous]" : region.name)
      );
    }

    size_t offset = 0;
    while (offset < region.size) {
      size_t base_chunk_size = std::min(k_chunk_size, region.size - offset);
      size_t read_size = base_chunk_size;
      if (offset + base_chunk_size < region.size) {
        read_size = std::min(region.size - offset, base_chunk_size + overlap);
      }

      auto data_result = space_.read(region.base_address + offset, read_size);
      if (!data_result.ok()) {
        log.dbg(
            "failed to read chunk", redlog::field("base", utils::format_address(region.base_address + offset)),
            redlog::field("size", read_size)
        );
        break;
      }

      auto offsets = matcher.search(data_result.value.data(), data_result.value.size());
      for (uint64_t match_offset : offsets) {
        if (match_offset >= base_chunk_size) {
          continue;
        }
        std::string region_name =
            region.name.empty() ? "[anonymous]" : std::filesystem::path(region.name).filename().string();
        uint64_t match_address = region.base_address + offset + match_offset;
        results.push_back(scan_result{match_address, region_name});

        if (verbose_enabled) {
          pretty_logging::log_signature_match(
              log, signature_pattern, match_address, region_name, data_result.value.data(), data_result.value.size(),
              static_cast<size_t>(match_offset), signature.size(), region.base_address + offset
          );
        }

        if (max_matches > 0 && results.size() >= max_matches) {
          break;
        }
      }

      if (max_matches > 0 && results.size() >= max_matches) {
        break;
      }

      if (base_chunk_size == 0) {
        break;
      }
      offset += base_chunk_size;
    }

    if (max_matches > 0 && results.size() >= max_matches) {
      break;
    }
  }

  if (trace_enabled) {
    log.trc("signature scan completed", redlog::field("matches", results.size()));
  }

  if (options.single) {
    if (results.empty()) {
      log.dbg("single scan found no matches");
      return error_result<std::vector<scan_result>>(error_code::not_found, "signature not found");
    }
    if (results.size() > 1) {
      log.err("single scan found multiple matches", redlog::field("matches", results.size()));
      return error_result<std::vector<scan_result>>(error_code::multiple_matches, "multiple matches found");
    }
  }

  return ok_result(results);
}

} // namespace p1ll::engine

```

`src/p1ll/engine/scanner.hpp`:

```hpp
#pragma once

#include "engine/address_space.hpp"
#include "engine/pattern.hpp"
#include "engine/types.hpp"

namespace p1ll::engine {

class scanner {
public:
  explicit scanner(const address_space& space);

  result<std::vector<scan_result>> scan(const pattern& signature, const scan_options& options) const;

private:
  const address_space& space_;
};

} // namespace p1ll::engine

```

`src/p1ll/engine/session.cpp`:

```cpp
#include "session.hpp"

namespace p1ll::engine {

session::session(std::unique_ptr<address_space> space, platform::platform_key platform_key, bool dynamic)
    : space_(std::move(space)), platform_(std::move(platform_key)), dynamic_(dynamic) {}

session session::for_process() {
  auto platform_key = platform::detect_platform();
  return session(std::make_unique<process_address_space>(), platform_key, true);
}

session session::for_buffer(std::span<uint8_t> buffer) {
  auto platform_key = platform::detect_platform();
  return session(std::make_unique<buffer_address_space>(buffer), platform_key, false);
}

session session::for_buffer(std::span<uint8_t> buffer, platform::platform_key platform_override) {
  return session(std::make_unique<buffer_address_space>(buffer), std::move(platform_override), false);
}

result<std::vector<memory_region>> session::regions(const scan_filter& filter) const { return space_->regions(filter); }

result<std::vector<scan_result>> session::scan(std::string_view pattern, const scan_options& options) const {
  auto parsed = parse_signature(pattern);
  if (!parsed.ok()) {
    return error_result<std::vector<scan_result>>(parsed.status_info.code, parsed.status_info.message);
  }

  scanner scanner(*space_);
  return scanner.scan(parsed.value, options);
}

result<std::vector<plan_entry>> session::plan(const recipe& recipe) const {
  plan_builder builder(*space_, platform_);
  return builder.build(recipe);
}

result<apply_report> session::apply(const std::vector<plan_entry>& plan, const apply_options& options) {
  return apply_plan(*space_, plan, options);
}

} // namespace p1ll::engine

```

`src/p1ll/engine/session.hpp`:

```hpp
#pragma once

#include "engine/address_space.hpp"
#include "engine/apply.hpp"
#include "engine/plan_builder.hpp"
#include "engine/pattern.hpp"
#include "engine/scanner.hpp"
#include "engine/types.hpp"
#include "engine/platform/platform.hpp"
#include <memory>
#include <span>
#include <string_view>

namespace p1ll::engine {

class session {
public:
  static session for_process();
  static session for_buffer(std::span<uint8_t> buffer);
  static session for_buffer(std::span<uint8_t> buffer, platform::platform_key platform_override);

  bool is_dynamic() const noexcept { return dynamic_; }
  bool is_static() const noexcept { return !dynamic_; }

  const platform::platform_key& platform_key() const noexcept { return platform_; }

  result<std::vector<memory_region>> regions(const scan_filter& filter) const;
  result<std::vector<scan_result>> scan(std::string_view pattern, const scan_options& options) const;
  result<std::vector<plan_entry>> plan(const recipe& recipe) const;
  result<apply_report> apply(const std::vector<plan_entry>& plan, const apply_options& options = {});

private:
  session(std::unique_ptr<address_space> space, platform::platform_key platform_key, bool dynamic);

  std::unique_ptr<address_space> space_;
  platform::platform_key platform_;
  bool dynamic_ = true;
};

} // namespace p1ll::engine

```

`src/p1ll/engine/types.hpp`:

```hpp
#pragma once

#include "result.hpp"
#include <cstddef>
#include <cstdint>
#include <optional>
#include <string>
#include <vector>

namespace p1ll::engine {

// memory protection flags used across the engine
enum class memory_protection : int {
  none = 0x00,
  read = 0x01,
  write = 0x02,
  execute = 0x04,
  read_write = read | write,
  read_execute = read | execute,
  read_write_execute = read | write | execute
};

constexpr memory_protection operator|(memory_protection a, memory_protection b) {
  return static_cast<memory_protection>(static_cast<int>(a) | static_cast<int>(b));
}

constexpr memory_protection operator&(memory_protection a, memory_protection b) {
  return static_cast<memory_protection>(static_cast<int>(a) & static_cast<int>(b));
}

constexpr bool has_protection(memory_protection flags, memory_protection check) { return (flags & check) == check; }

struct memory_region {
  uint64_t base_address = 0;
  size_t size = 0;
  memory_protection protection = memory_protection::none;
  std::string name;
  bool is_executable = false;
  bool is_system = false;
};

struct scan_filter {
  std::string name_regex;
  bool only_executable = false;
  bool exclude_system = false;
  size_t min_size = 0;
  std::optional<uint64_t> min_address;
  std::optional<uint64_t> max_address;
};

struct scan_options {
  scan_filter filter;
  bool single = false;
  size_t max_matches = 0;
};

struct scan_result {
  uint64_t address = 0;
  std::string region_name;
};

struct signature_spec {
  std::string pattern;
  scan_options options;
  std::vector<std::string> platforms;
  bool required = true;
};

struct patch_spec {
  signature_spec signature;
  int64_t offset = 0;
  std::string patch;
  std::vector<std::string> platforms;
  bool required = true;
};

struct recipe {
  std::string name;
  std::vector<std::string> platforms;
  std::vector<signature_spec> validations;
  std::vector<patch_spec> patches;
};

struct plan_entry {
  patch_spec spec;
  uint64_t address = 0;
  std::vector<uint8_t> patch_bytes;
  std::vector<uint8_t> patch_mask;
};

struct apply_report {
  bool success = false;
  size_t applied = 0;
  size_t failed = 0;
  std::vector<status> diagnostics;
};

} // namespace p1ll::engine

```

`src/p1ll/heur/code_signature.cpp`:

```cpp
#include "p1ll/heur/code_signature.hpp"

#include <capstone/arm64.h>
#include <capstone/x86.h>

#include <algorithm>
#include <cctype>
#include <limits>
#include <optional>
#include <string>
#include <vector>

#include "w1asmr/asmr.hpp"
#include "utils/hex_utils.hpp"

namespace p1ll::heur {

namespace {

using w1::asmr::asm_context;
using w1::asmr::disasm_context;
using w1::asmr::instruction;
using w1::asmr::operand_kind;

struct policy_params {
  size_t min_fixed_bytes = 0;
  size_t max_instructions = 0;
};

policy_params params_for(policy policy_value) {
  switch (policy_value) {
  case policy::strict:
    return policy_params{8, 20};
  case policy::balanced:
    return policy_params{12, 20};
  case policy::durable:
    return policy_params{16, 20};
  }
  return policy_params{12, 20};
}

policy_params apply_options(policy_params params, const signature_options& options, size_t& min_instructions) {
  if (options.min_fixed_bytes) {
    params.min_fixed_bytes = *options.min_fixed_bytes;
  }
  if (options.max_instructions && *options.max_instructions > 0) {
    params.max_instructions = *options.max_instructions;
  }
  min_instructions = options.min_instructions.value_or(0);
  if (params.max_instructions == 0) {
    params.max_instructions = std::numeric_limits<size_t>::max();
  }
  if (min_instructions > params.max_instructions) {
    min_instructions = params.max_instructions;
  }
  return params;
}

p1ll::engine::error_code map_error_code(w1::asmr::error_code code) {
  switch (code) {
  case w1::asmr::error_code::ok:
    return p1ll::engine::error_code::ok;
  case w1::asmr::error_code::invalid_argument:
    return p1ll::engine::error_code::invalid_argument;
  case w1::asmr::error_code::not_found:
    return p1ll::engine::error_code::not_found;
  case w1::asmr::error_code::unsupported:
    return p1ll::engine::error_code::unsupported;
  case w1::asmr::error_code::invalid_context:
    return p1ll::engine::error_code::invalid_context;
  case w1::asmr::error_code::internal_error:
    return p1ll::engine::error_code::internal_error;
  }
  return p1ll::engine::error_code::internal_error;
}

void mask_range(std::vector<uint8_t>& mask, size_t offset, size_t size) {
  if (size == 0 || mask.empty()) {
    return;
  }
  if (offset >= mask.size()) {
    return;
  }
  size_t end = std::min(mask.size(), offset + size);
  for (size_t i = offset; i < end; ++i) {
    mask[i] = 0;
  }
}

bool only_register_operands(const instruction& inst) {
  if (inst.operand_details.empty()) {
    return false;
  }
  for (const auto& op : inst.operand_details) {
    if (op.kind != operand_kind::reg) {
      return false;
    }
  }
  return true;
}

bool has_rip_relative_operand(const instruction& inst) {
  for (const auto& op : inst.operand_details) {
    if (op.kind == operand_kind::mem && op.mem_base == X86_REG_RIP) {
      return true;
    }
  }
  return false;
}

bool has_arm64_immediate(const instruction& inst) {
  for (const auto& op : inst.operand_details) {
    if (op.kind == operand_kind::imm || op.kind == operand_kind::mem) {
      return true;
    }
  }
  return false;
}

std::string normalize_arm64_operands(const std::string& op_str) {
  if (op_str.empty()) {
    return {};
  }

  std::string output;
  output.reserve(op_str.size());

  for (size_t i = 0; i < op_str.size();) {
    if (op_str[i] != '#') {
      output.push_back(op_str[i]);
      ++i;
      continue;
    }

    output += "#0";
    ++i;

    if (i < op_str.size() && (op_str[i] == '+' || op_str[i] == '-')) {
      ++i;
    }

    if (i + 1 < op_str.size() && op_str[i] == '0' && (op_str[i + 1] == 'x' || op_str[i + 1] == 'X')) {
      i += 2;
      while (i < op_str.size() && std::isxdigit(static_cast<unsigned char>(op_str[i]))) {
        ++i;
      }
    } else {
      while (i < op_str.size() && std::isdigit(static_cast<unsigned char>(op_str[i]))) {
        ++i;
      }
    }
  }

  return output;
}

std::vector<uint8_t> mask_x86_instruction(const instruction& inst, policy policy_value) {
  std::vector<uint8_t> mask(inst.bytes.size(), 1);

  bool rip_relative = has_rip_relative_operand(inst);
  bool only_regs = only_register_operands(inst);

  if (policy_value == policy::strict) {
    if (inst.is_branch_relative) {
      mask_range(mask, inst.encoding_info.imm_offset, inst.encoding_info.imm_size);
    }
    if (rip_relative) {
      mask_range(mask, inst.encoding_info.disp_offset, inst.encoding_info.disp_size);
    }
  } else {
    mask_range(mask, inst.encoding_info.imm_offset, inst.encoding_info.imm_size);
    mask_range(mask, inst.encoding_info.disp_offset, inst.encoding_info.disp_size);
  }

  if (policy_value == policy::durable && only_regs && inst.encoding_info.modrm_offset > 0) {
    mask_range(mask, inst.encoding_info.modrm_offset, 1);
  }

  return mask;
}

std::vector<uint8_t> mask_arm64_instruction(const instruction& inst, const asm_context& ctx, policy policy_value) {
  std::vector<uint8_t> mask(inst.bytes.size(), 1);

  bool should_normalize = false;
  if (policy_value == policy::strict) {
    should_normalize = inst.is_branch_relative || inst.id == ARM64_INS_ADR || inst.id == ARM64_INS_ADRP;
  } else {
    should_normalize = true;
  }

  if (!should_normalize) {
    return mask;
  }

  std::string normalized_ops = normalize_arm64_operands(inst.operands);
  std::string text = inst.mnemonic;
  if (!normalized_ops.empty()) {
    text += " ";
    text += normalized_ops;
  }

  auto assembled = ctx.assemble(text, inst.address);
  if (!assembled.ok() || assembled.value.size() != inst.bytes.size()) {
    if (policy_value == policy::durable && has_arm64_immediate(inst)) {
      std::fill(mask.begin(), mask.end(), 0);
    }
    return mask;
  }

  bool any_diff = false;
  for (size_t i = 0; i < inst.bytes.size(); ++i) {
    if (assembled.value[i] != inst.bytes[i]) {
      mask[i] = 0;
      any_diff = true;
    }
  }

  if (!any_diff && policy_value == policy::durable && has_arm64_immediate(inst)) {
    std::fill(mask.begin(), mask.end(), 0);
  }

  return mask;
}

void append_pattern(std::string& output, const std::vector<uint8_t>& bytes, const std::vector<uint8_t>& mask) {
  for (size_t i = 0; i < bytes.size(); ++i) {
    if (!output.empty()) {
      output += " ";
    }
    if (i < mask.size() && mask[i] == 0) {
      output += "??";
    } else {
      output += p1ll::utils::to_hex_string(bytes[i]);
    }
  }
}

std::string format_pretty_line(const instruction& inst, const std::vector<uint8_t>& mask) {
  std::string line;
  for (size_t i = 0; i < inst.bytes.size(); ++i) {
    if (i < mask.size() && mask[i] == 0) {
      line += "??";
    } else {
      line += p1ll::utils::to_hex_string(inst.bytes[i]);
    }
  }

  if (!inst.mnemonic.empty()) {
    line += "  // ";
    line += inst.mnemonic;
    if (!inst.operands.empty()) {
      line += " ";
      line += inst.operands;
    }
  }

  return line;
}

} // namespace

engine::result<signature> code_signature(
    std::span<const uint8_t> bytes, uint64_t address, const engine::platform::platform_key& platform,
    policy policy_value, const signature_options& options
) {
  if (bytes.empty()) {
    return engine::error_result<signature>(engine::error_code::invalid_argument, "signature input is empty");
  }

  if (platform.arch.empty() || platform.arch == "*") {
    return engine::error_result<signature>(
        engine::error_code::invalid_argument, "platform arch must be specified for signature generation"
    );
  }

  auto arch_value = w1::asmr::parse_arch_spec(platform.arch);
  if (!arch_value.ok()) {
    return engine::error_result<signature>(map_error_code(arch_value.status_info.code), arch_value.status_info.message);
  }

  if (arch_value.value.arch_mode != w1::arch::mode::x86_32 && arch_value.value.arch_mode != w1::arch::mode::x86_64 &&
      arch_value.value.arch_mode != w1::arch::mode::aarch64) {
    return engine::error_result<signature>(engine::error_code::unsupported, "unsupported architecture for signature");
  }

  auto disasm_ctx = disasm_context::for_arch(arch_value.value);
  if (!disasm_ctx.ok()) {
    return engine::error_result<signature>(map_error_code(disasm_ctx.status_info.code), disasm_ctx.status_info.message);
  }

  std::optional<asm_context> asm_ctx;
  if (arch_value.value.arch_mode == w1::arch::mode::aarch64) {
    auto asm_result = asm_context::for_arch(arch_value.value);
    if (!asm_result.ok()) {
      return engine::error_result<signature>(
          map_error_code(asm_result.status_info.code), asm_result.status_info.message
      );
    }
    asm_ctx = std::move(asm_result.value);
  }

  auto disassembly = disasm_ctx.value.disassemble(bytes, address);
  if (!disassembly.ok()) {
    return engine::error_result<signature>(
        map_error_code(disassembly.status_info.code), disassembly.status_info.message
    );
  }

  if (disassembly.value.empty()) {
    return engine::error_result<signature>(engine::error_code::not_found, "no instructions decoded");
  }

  size_t min_instructions = 0;
  policy_params params = apply_options(params_for(policy_value), options, min_instructions);

  signature output;
  size_t fixed_bytes = 0;
  size_t instruction_count = 0;

  for (const auto& inst : disassembly.value) {
    if (instruction_count >= params.max_instructions) {
      break;
    }

    std::vector<uint8_t> mask;
    if (arch_value.value.arch_mode == w1::arch::mode::aarch64) {
      mask = mask_arm64_instruction(inst, *asm_ctx, policy_value);
    } else {
      mask = mask_x86_instruction(inst, policy_value);
    }

    append_pattern(output.pattern, inst.bytes, mask);

    if (!output.pretty.empty()) {
      output.pretty += "\n";
    }
    output.pretty += format_pretty_line(inst, mask);

    for (auto value : mask) {
      if (value != 0) {
        ++fixed_bytes;
      }
    }

    ++instruction_count;
    if (fixed_bytes >= params.min_fixed_bytes && instruction_count >= min_instructions) {
      break;
    }
  }

  output.instruction_count = instruction_count;
  output.fixed_bytes = fixed_bytes;
  return engine::ok_result(output);
}

} // namespace p1ll::heur

```

`src/p1ll/heur/code_signature.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <optional>
#include <span>
#include <string>

#include "p1ll/engine/platform/platform.hpp"
#include "p1ll/engine/result.hpp"

namespace p1ll::heur {

enum class policy { strict, balanced, durable };

struct signature {
  std::string pattern;
  std::string pretty;
  size_t instruction_count = 0;
  size_t fixed_bytes = 0;
};

struct signature_options {
  std::optional<size_t> min_fixed_bytes;
  std::optional<size_t> min_instructions;
  std::optional<size_t> max_instructions;
};

engine::result<signature> code_signature(
    std::span<const uint8_t> bytes, uint64_t address, const engine::platform::platform_key& platform,
    policy policy_value = policy::balanced, const signature_options& options = {}
);

} // namespace p1ll::heur

```

`src/p1ll/p1ll.hpp`:

```hpp
#pragma once

#include <string>
#include <memory>

// engine public surface
#include "engine/result.hpp"
#include "engine/types.hpp"
#include "engine/pattern.hpp"
#include "engine/session.hpp"
#include "engine/platform/platform.hpp"

// utilities
#include "utils/hex_utils.hpp"
#include "utils/hex_pattern.hpp"
#include "utils/file_utils.hpp"

namespace p1ll {

/**
 * @brief check if scripting support is compiled in
 */
inline bool has_scripting_support() {
#ifdef P1LL_HAS_SCRIPTING
  return true;
#else
  return false;
#endif
}

} // namespace p1ll

```

`src/p1ll/scripting/js/js_bindings.hpp`:

```hpp
#pragma once

#include <jnjs/jnjs.h>
#include <redlog.hpp>
#include <algorithm>
#include <cctype>
#include <filesystem>
#include <limits>
#include <optional>
#include <regex>
#include <string>
#include <unordered_map>
#include <vector>

#include "p1ll/engine/result.hpp"
#include "p1ll/engine/session.hpp"
#include "p1ll/engine/types.hpp"
#include "p1ll/utils/hex_utils.hpp"

namespace p1ll::scripting::js {

using namespace jnjs;

inline const char* error_code_name(engine::error_code code) {
  switch (code) {
  case engine::error_code::ok:
    return "ok";
  case engine::error_code::invalid_argument:
    return "invalid_argument";
  case engine::error_code::invalid_pattern:
    return "invalid_pattern";
  case engine::error_code::not_found:
    return "not_found";
  case engine::error_code::multiple_matches:
    return "multiple_matches";
  case engine::error_code::io_error:
    return "io_error";
  case engine::error_code::protection_error:
    return "protection_error";
  case engine::error_code::verification_failed:
    return "verification_failed";
  case engine::error_code::platform_mismatch:
    return "platform_mismatch";
  case engine::error_code::overlap:
    return "overlap";
  case engine::error_code::unsupported:
    return "unsupported";
  case engine::error_code::invalid_context:
    return "invalid_context";
  case engine::error_code::internal_error:
    return "internal_error";
  }
  return "unknown";
}

inline std::string format_status(const engine::status& status) {
  std::string label = error_code_name(status.code);
  if (status.message.empty()) {
    return label;
  }
  return label + ": " + status.message;
}

inline bool looks_like_path(const std::string& value) {
  return value.find('/') != std::string::npos || value.find('\\') != std::string::npos;
}

inline std::string module_key_for_path(const std::string& path) {
#ifdef _WIN32
  std::string key = path;
  std::replace(key.begin(), key.end(), '/', '\\');
  std::transform(key.begin(), key.end(), key.begin(), [](unsigned char c) {
    return static_cast<char>(std::tolower(c));
  });
  return key;
#else
  return path;
#endif
}

// result wrapper for script-friendly return values
struct apply_report_wrapper {
  bool success = false;
  int applied = 0;
  int failed = 0;
  std::vector<std::string> error_messages;
  std::vector<engine::status> diagnostics;

  apply_report_wrapper() = default;
  apply_report_wrapper(const engine::apply_report& report)
      : success(report.success), applied(static_cast<int>(report.applied)), failed(static_cast<int>(report.failed)) {
    diagnostics = report.diagnostics;
    for (const auto& diag : report.diagnostics) {
      if (!diag.message.empty()) {
        error_messages.push_back(diag.message);
      }
    }
  }

  void add_error(const std::string& message) {
    error_messages.push_back(message);
    diagnostics.push_back(engine::make_status(engine::error_code::invalid_argument, message));
    success = false;
  }

  bool get_success() { return success; }
  int get_applied() { return applied; }
  int get_failed() { return failed; }
  std::vector<std::string> get_error_messages() { return error_messages; }
  std::vector<std::string> get_diagnostics() {
    std::vector<std::string> output;
    output.reserve(diagnostics.size());
    for (const auto& diag : diagnostics) {
      output.push_back(format_status(diag));
    }
    return output;
  }
  std::vector<engine::status> get_statuses() { return diagnostics; }
  bool has_errors() { return !error_messages.empty(); }

  constexpr static wrapped_class_builder<apply_report_wrapper> build_js_class() {
    wrapped_class_builder<apply_report_wrapper> builder("apply_report");
    builder.bind_function<&apply_report_wrapper::get_success>("get_success");
    builder.bind_function<&apply_report_wrapper::get_applied>("get_applied");
    builder.bind_function<&apply_report_wrapper::get_failed>("get_failed");
    builder.bind_function<&apply_report_wrapper::get_error_messages>("get_error_messages");
    builder.bind_function<&apply_report_wrapper::get_diagnostics>("get_diagnostics");
    builder.bind_function<&apply_report_wrapper::has_errors>("has_errors");
    return builder;
  }
};

struct scan_result_wrapper {
  uint64_t address = 0;
  std::string region_name;

  scan_result_wrapper() = default;
  scan_result_wrapper(const engine::scan_result& result) : address(result.address), region_name(result.region_name) {}

  uint64_t get_address() { return address; }
  std::string get_region_name() { return region_name; }

  constexpr static wrapped_class_builder<scan_result_wrapper> build_js_class() {
    wrapped_class_builder<scan_result_wrapper> builder("scan_result");
    builder.bind_function<&scan_result_wrapper::get_address>("get_address");
    builder.bind_function<&scan_result_wrapper::get_region_name>("get_region_name");
    return builder;
  }
};

struct module_info_wrapper {
  std::string name;
  std::string path;
  uint64_t base_address = 0;
  uint64_t size = 0;
  std::string permissions;
  bool is_system_module = false;

  std::string get_name() { return name; }
  std::string get_path() { return path; }
  uint64_t get_base_address() { return base_address; }
  uint64_t get_size() { return size; }
  std::string get_permissions() { return permissions; }
  bool get_is_system_module() { return is_system_module; }

  constexpr static wrapped_class_builder<module_info_wrapper> build_js_class() {
    wrapped_class_builder<module_info_wrapper> builder("module_info");
    builder.bind_function<&module_info_wrapper::get_name>("get_name");
    builder.bind_function<&module_info_wrapper::get_path>("get_path");
    builder.bind_function<&module_info_wrapper::get_base_address>("get_base_address");
    builder.bind_function<&module_info_wrapper::get_size>("get_size");
    builder.bind_function<&module_info_wrapper::get_permissions>("get_permissions");
    builder.bind_function<&module_info_wrapper::get_is_system_module>("get_is_system_module");
    return builder;
  }
};

struct signature_wrapper {
  engine::signature_spec spec;

  signature_wrapper() = default;
  explicit signature_wrapper(engine::signature_spec spec_in) : spec(std::move(spec_in)) {}

  std::string get_pattern() { return spec.pattern; }

  constexpr static wrapped_class_builder<signature_wrapper> build_js_class() {
    wrapped_class_builder<signature_wrapper> builder("signature");
    builder.bind_function<&signature_wrapper::get_pattern>("get_pattern");
    return builder;
  }
};

struct patch_wrapper {
  engine::patch_spec spec;

  patch_wrapper() = default;
  explicit patch_wrapper(engine::patch_spec spec_in) : spec(std::move(spec_in)) {}

  signature_wrapper* get_signature() { return new signature_wrapper(spec.signature); }
  int64_t get_offset() { return spec.offset; }
  std::string get_pattern() { return spec.patch; }
  bool is_required() { return spec.required; }

  constexpr static wrapped_class_builder<patch_wrapper> build_js_class() {
    wrapped_class_builder<patch_wrapper> builder("patch");
    builder.bind_function<&patch_wrapper::get_signature>("get_signature");
    builder.bind_function<&patch_wrapper::get_offset>("get_offset");
    builder.bind_function<&patch_wrapper::get_pattern>("get_pattern");
    builder.bind_function<&patch_wrapper::is_required>("is_required");
    return builder;
  }
};

inline bool is_defined(const jnjs::value& value) { return !(value.is<jnjs::undefined>() || value.is<jnjs::null>()); }

inline std::optional<uint64_t> parse_u64(const jnjs::value& value) {
  if (value.is<uint64_t>()) {
    return value.as<uint64_t>();
  }
  if (value.is<int64_t>()) {
    int64_t v = value.as<int64_t>();
    if (v < 0) {
      return std::nullopt;
    }
    return static_cast<uint64_t>(v);
  }
  if (value.is<int>()) {
    int v = value.as<int>();
    if (v < 0) {
      return std::nullopt;
    }
    return static_cast<uint64_t>(v);
  }
  return std::nullopt;
}

inline void apply_scan_options(engine::scan_options& options, const jnjs::value& obj) {
  auto filter_val = obj["filter"];
  if (filter_val.is<std::string>()) {
    options.filter.name_regex = filter_val.as<std::string>();
  }

  auto single_val = obj["single"];
  if (single_val.is<bool>()) {
    options.single = single_val.as<bool>();
  }

  auto max_val = obj["max_matches"];
  if (max_val.is<int>()) {
    options.max_matches = static_cast<size_t>(max_val.as<int>());
  }

  auto exec_val = obj["only_executable"];
  if (exec_val.is<bool>()) {
    options.filter.only_executable = exec_val.as<bool>();
  }

  auto sys_val = obj["exclude_system"];
  if (sys_val.is<bool>()) {
    options.filter.exclude_system = sys_val.as<bool>();
  }

  auto min_size = obj["min_size"];
  if (min_size.is<int>()) {
    options.filter.min_size = static_cast<size_t>(min_size.as<int>());
  }

  auto min_addr = obj["min_address"];
  if (is_defined(min_addr)) {
    auto parsed = parse_u64(min_addr);
    if (parsed.has_value()) {
      options.filter.min_address = parsed;
    }
  }

  auto max_addr = obj["max_address"];
  if (is_defined(max_addr)) {
    auto parsed = parse_u64(max_addr);
    if (parsed.has_value()) {
      options.filter.max_address = parsed;
    }
  }
}

inline std::vector<std::string> parse_platform_list(const jnjs::value& value) {
  if (value.is<std::vector<std::string>>()) {
    return value.as<std::vector<std::string>>();
  }
  return {};
}

// main api exposed to scripts
struct p1ll_api {
  engine::session* session = nullptr;

  explicit p1ll_api(engine::session* session_in) : session(session_in) {}

  std::string str2hex(const std::string& str) { return p1ll::utils::str2hex(str); }
  std::string hex2str(const std::string& hex) { return p1ll::utils::hex2str(hex); }
  std::string format_address(uint64_t address) { return p1ll::utils::format_address(address); }

  signature_wrapper* sig(const std::string& pattern, std::optional<jnjs::value> options = std::nullopt) {
    engine::signature_spec spec;
    spec.pattern = pattern;

    if (options && is_defined(*options)) {
      apply_scan_options(spec.options, *options);

      auto required_val = (*options)["required"];
      if (required_val.is<bool>()) {
        spec.required = required_val.as<bool>();
      }

      auto platforms_val = (*options)["platforms"];
      if (is_defined(platforms_val)) {
        spec.platforms = parse_platform_list(platforms_val);
      }
    }

    return new signature_wrapper(spec);
  }

  patch_wrapper* patch(
      signature_wrapper* sig, int64_t offset, const std::string& patch_pattern,
      std::optional<jnjs::value> options = std::nullopt
  ) {
    engine::patch_spec spec;
    if (sig) {
      spec.signature = sig->spec;
    }
    spec.offset = offset;
    spec.patch = patch_pattern;
    spec.required = true;

    if (options && is_defined(*options)) {
      auto required_val = (*options)["required"];
      if (required_val.is<bool>()) {
        spec.required = required_val.as<bool>();
      }

      auto platforms_val = (*options)["platforms"];
      if (is_defined(platforms_val)) {
        spec.platforms = parse_platform_list(platforms_val);
      }
    }

    return new patch_wrapper(spec);
  }

  apply_report_wrapper* auto_cure(jnjs::value meta_obj);

  std::vector<module_info_wrapper*> get_modules(const std::string& filter_pattern = "") {
    auto log = redlog::get_logger("p1ll.js");

    if (!session || !session->is_dynamic()) {
      log.dbg("get_modules unavailable in static mode");
      return {};
    }

    auto regions = session->regions(engine::scan_filter{});
    if (!regions.ok()) {
      log.err("get_modules failed", redlog::field("error", regions.status_info.message));
      return {};
    }

    std::optional<std::regex> filter_regex;
    if (!filter_pattern.empty()) {
      try {
        filter_regex.emplace(filter_pattern);
      } catch (const std::regex_error&) {
        log.err("invalid module filter regex");
        return {};
      }
    }

    struct module_accumulator {
      std::string path;
      uint64_t base_address = std::numeric_limits<uint64_t>::max();
      uint64_t end_address = 0;
      engine::memory_protection protection = engine::memory_protection::none;
      bool has_executable = false;
      bool is_system = false;
    };

    std::unordered_map<std::string, module_accumulator> modules;
    for (const auto& region : regions.value) {
      if (region.name.empty() || !looks_like_path(region.name)) {
        continue;
      }

      auto& entry = modules[module_key_for_path(region.name)];
      if (entry.path.empty()) {
        entry.path = region.name;
      }

      entry.base_address = std::min(entry.base_address, region.base_address);
      uint64_t region_end = region.base_address + region.size;
      if (region_end >= region.base_address) {
        entry.end_address = std::max(entry.end_address, region_end);
      }
      entry.protection = entry.protection | region.protection;
      entry.has_executable = entry.has_executable || region.is_executable;
      entry.is_system = entry.is_system || region.is_system;
    }

    std::vector<module_info_wrapper*> result;
    result.reserve(modules.size());
    for (const auto& [path, entry] : modules) {
      if (!entry.has_executable || entry.base_address == std::numeric_limits<uint64_t>::max()) {
        continue;
      }

      std::string name = std::filesystem::path(entry.path).filename().string();
      if (filter_regex) {
        if (!std::regex_search(entry.path, *filter_regex) && !std::regex_search(name, *filter_regex)) {
          continue;
        }
      }

      if (entry.end_address < entry.base_address) {
        continue;
      }

      auto* mod = new module_info_wrapper();
      mod->name = name;
      mod->path = entry.path;
      mod->base_address = entry.base_address;
      mod->size = entry.end_address - entry.base_address;
      mod->permissions =
          std::string(engine::has_protection(entry.protection, engine::memory_protection::read) ? "r" : "-") +
          (engine::has_protection(entry.protection, engine::memory_protection::write) ? "w" : "-") +
          (engine::has_protection(entry.protection, engine::memory_protection::execute) ? "x" : "-");
      mod->is_system_module = entry.is_system;
      result.push_back(mod);
    }

    std::sort(result.begin(), result.end(), [](const module_info_wrapper* a, const module_info_wrapper* b) {
      return a->base_address < b->base_address;
    });

    log.dbg("found modules", redlog::field("count", result.size()));
    return result;
  }

  std::vector<scan_result_wrapper*> search_sig_multiple(
      const std::string& pattern, std::optional<jnjs::value> options = std::nullopt
  ) {
    auto log = redlog::get_logger("p1ll.js");
    if (!session) {
      log.err("search_sig_multiple called with no session");
      return {};
    }

    engine::scan_options scan_opts;
    if (options && is_defined(*options)) {
      apply_scan_options(scan_opts, *options);
    }

    auto results = session->scan(pattern, scan_opts);
    if (!results.ok()) {
      log.err("search failed", redlog::field("pattern", pattern), redlog::field("error", results.status_info.message));
      return {};
    }

    std::vector<scan_result_wrapper*> output;
    for (const auto& result : results.value) {
      output.push_back(new scan_result_wrapper(result));
    }
    log.dbg("search completed", redlog::field("results", output.size()));
    return output;
  }

  scan_result_wrapper* search_sig(const std::string& pattern, std::optional<jnjs::value> options = std::nullopt) {
    auto log = redlog::get_logger("p1ll.js");
    if (!session) {
      log.err("search_sig called with no session");
      return nullptr;
    }

    engine::scan_options scan_opts;
    if (options && is_defined(*options)) {
      apply_scan_options(scan_opts, *options);
    }

    auto results = session->scan(pattern, scan_opts);
    if (!results.ok() || results.value.empty()) {
      if (!results.ok()) {
        log.err(
            "search failed", redlog::field("pattern", pattern), redlog::field("error", results.status_info.message)
        );
      } else {
        log.dbg("search returned no matches", redlog::field("pattern", pattern));
      }
      return nullptr;
    }

    if (scan_opts.single && results.value.size() != 1) {
      log.dbg(
          "single match required but search returned unexpected count", redlog::field("count", results.value.size())
      );
      return nullptr;
    }

    if (results.value.size() > 1) {
      log.wrn("multiple matches, returning first", redlog::field("count", results.value.size()));
    }
    return new scan_result_wrapper(results.value.front());
  }

  void log_info(const std::string& msg) { redlog::get_logger("p1ll.js").inf(msg); }
  void log_debug(const std::string& msg) { redlog::get_logger("p1ll.js").dbg(msg); }
  void log_warn(const std::string& msg) { redlog::get_logger("p1ll.js").wrn(msg); }
  void log_err(const std::string& msg) { redlog::get_logger("p1ll.js").err(msg); }

  constexpr static wrapped_class_builder<p1ll_api> build_js_class() {
    wrapped_class_builder<p1ll_api> builder("p1ll_api");
    builder.bind_function<&p1ll_api::str2hex>("str2hex");
    builder.bind_function<&p1ll_api::hex2str>("hex2str");
    builder.bind_function<&p1ll_api::format_address>("format_address");
    builder.bind_function<&p1ll_api::sig>("sig");
    builder.bind_function<&p1ll_api::patch>("patch");
    builder.bind_function<&p1ll_api::auto_cure>("auto_cure");
    builder.bind_function<&p1ll_api::get_modules>("get_modules");
    builder.bind_function<&p1ll_api::search_sig>("search_sig");
    builder.bind_function<&p1ll_api::search_sig_multiple>("search_sig_multiple");
    builder.bind_function<&p1ll_api::log_info>("log_info");
    builder.bind_function<&p1ll_api::log_debug>("log_debug");
    builder.bind_function<&p1ll_api::log_warn>("log_warn");
    builder.bind_function<&p1ll_api::log_err>("log_err");
    return builder;
  }
};

inline void append_signatures_from_map(
    std::vector<engine::signature_spec>& out,
    const std::unordered_map<std::string, std::vector<signature_wrapper*>>& sigs_map
) {
  for (const auto& [platform_key, sigs] : sigs_map) {
    for (auto* sig : sigs) {
      if (!sig) {
        continue;
      }
      engine::signature_spec spec = sig->spec;
      spec.platforms.clear();
      if (platform_key != "*" && platform_key != "*:*") {
        spec.platforms.push_back(platform_key);
      }
      out.push_back(spec);
    }
  }
}

inline void append_patches_from_map(
    std::vector<engine::patch_spec>& out, const std::unordered_map<std::string, std::vector<patch_wrapper*>>& patch_map
) {
  for (const auto& [platform_key, patches] : patch_map) {
    for (auto* patch : patches) {
      if (!patch) {
        continue;
      }
      engine::patch_spec spec = patch->spec;
      spec.platforms.clear();
      if (platform_key != "*" && platform_key != "*:*") {
        spec.platforms.push_back(platform_key);
      }
      out.push_back(spec);
    }
  }
}

inline engine::recipe parse_recipe(const jnjs::value& meta_obj) {
  engine::recipe recipe;

  auto name_val = meta_obj["name"];
  if (name_val.is<std::string>()) {
    recipe.name = name_val.as<std::string>();
  }

  auto platforms_val = meta_obj["platforms"];
  if (platforms_val.is<std::vector<std::string>>()) {
    recipe.platforms = platforms_val.as<std::vector<std::string>>();
  }

  auto validations_val = meta_obj["validations"];
  if (validations_val.is<std::vector<signature_wrapper*>>()) {
    for (auto* sig : validations_val.as<std::vector<signature_wrapper*>>()) {
      if (sig) {
        recipe.validations.push_back(sig->spec);
      }
    }
  }

  auto sigs_val = meta_obj["sigs"];
  if (sigs_val.is<std::unordered_map<std::string, std::vector<signature_wrapper*>>>()) {
    append_signatures_from_map(
        recipe.validations, sigs_val.as<std::unordered_map<std::string, std::vector<signature_wrapper*>>>()
    );
  }

  auto patches_val = meta_obj["patches"];
  if (patches_val.is<std::vector<patch_wrapper*>>()) {
    for (auto* patch : patches_val.as<std::vector<patch_wrapper*>>()) {
      if (patch) {
        recipe.patches.push_back(patch->spec);
      }
    }
  } else if (patches_val.is<std::unordered_map<std::string, std::vector<patch_wrapper*>>>()) {
    append_patches_from_map(
        recipe.patches, patches_val.as<std::unordered_map<std::string, std::vector<patch_wrapper*>>>()
    );
  }

  return recipe;
}

inline apply_report_wrapper* p1ll_api::auto_cure(jnjs::value meta_obj) {
  auto log = redlog::get_logger("p1ll.js.auto_cure");

  if (!session) {
    log.err("auto_cure called with no session");
    auto* report = new apply_report_wrapper();
    report->add_error("no session available");
    return report;
  }

  if (!is_defined(meta_obj)) {
    log.err("auto_cure called with invalid metadata object");
    auto* report = new apply_report_wrapper();
    report->add_error("invalid metadata object");
    return report;
  }

  auto recipe = parse_recipe(meta_obj);
  if (recipe.patches.empty()) {
    log.err("auto_cure called with empty patch list");
    auto* report = new apply_report_wrapper();
    report->add_error("recipe.patches is required");
    return report;
  }

  log.inf("executing auto_cure", redlog::field("name", recipe.name));
  auto plan = session->plan(recipe);
  if (!plan.ok()) {
    log.err("auto_cure planning failed", redlog::field("error", plan.status_info.message));
    auto* report = new apply_report_wrapper();
    report->add_error(plan.status_info.message.empty() ? "plan failed" : plan.status_info.message);
    return report;
  }

  auto applied = session->apply(plan.value);
  auto* report = new apply_report_wrapper(applied.value);
  if (!applied.ok()) {
    log.err("auto_cure apply failed", redlog::field("error", applied.status_info.message));
    if (!applied.status_info.message.empty()) {
      report->add_error(applied.status_info.message);
    }
  }
  log.inf(
      "auto_cure completed", redlog::field("success", report->success), redlog::field("applied", report->applied),
      redlog::field("failed", report->failed)
  );
  return report;
}

inline void setup_p1ll_js_bindings(jnjs::context& js_ctx, engine::session& session) {
  auto log = redlog::get_logger("p1ll.js_bindings");
  log.inf("setting up js bindings", redlog::field("mode", session.is_dynamic() ? "dynamic" : "static"));
  js_ctx.install_class<apply_report_wrapper>();
  js_ctx.install_class<scan_result_wrapper>();
  js_ctx.install_class<module_info_wrapper>();
  js_ctx.install_class<signature_wrapper>();
  js_ctx.install_class<patch_wrapper>();
  js_ctx.install_class<p1ll_api>();

  auto api = new p1ll_api(&session);
  js_ctx.set_global("p1", api);
  log.inf("js bindings registered");
}

} // namespace p1ll::scripting::js

```

`src/p1ll/scripting/js/js_engine.cpp`:

```cpp
#include "js_engine.hpp"
#include "js_bindings.hpp"
#include <jnjs/jnjs.h>
#include <redlog.hpp>

namespace p1ll::scripting::js {

namespace {

engine::apply_report extract_apply_report(const jnjs::value& js_result) {
  engine::apply_report report;

  if (js_result.is<apply_report_wrapper*>()) {
    auto wrapper = js_result.as<apply_report_wrapper*>();
    if (wrapper) {
      report.success = wrapper->get_success();
      report.applied = wrapper->get_applied();
      report.failed = wrapper->get_failed();
      report.diagnostics = wrapper->get_statuses();
      return report;
    }
  }

  if (js_result["success"].is<bool>()) {
    report.success = js_result["success"].as<bool>();
  }
  if (js_result["applied"].is<int>()) {
    report.applied = static_cast<size_t>(js_result["applied"].as<int>());
  }
  if (js_result["failed"].is<int>()) {
    report.failed = static_cast<size_t>(js_result["failed"].as<int>());
  }

  return report;
}

engine::result<engine::apply_report> execute_cure_script_impl(
    jnjs::context& js_ctx, const std::string& script_content, const std::string& log_context
) {
  auto log = redlog::get_logger("p1ll.js_engine");

  try {
    js_ctx.eval(script_content);

    auto cure_fn = js_ctx.eval("cure");
    if (!cure_fn.is<jnjs::function>()) {
      log.err("no cure() function found in script", redlog::field("context", log_context));
      return engine::error_result<engine::apply_report>(
          engine::error_code::invalid_argument, "script must define a callable cure() function"
      );
    }

    log.dbg("executing cure() function", redlog::field("context", log_context));
    auto js_result = cure_fn.as<jnjs::function>()();
    auto report = extract_apply_report(js_result);
    log.inf(
        "cure completed", redlog::field("success", report.success), redlog::field("applied", report.applied),
        redlog::field("failed", report.failed)
    );
    return engine::ok_result(report);
  } catch (const std::runtime_error& e) {
    log.err("js runtime error", redlog::field("error", e.what()), redlog::field("context", log_context));
    return engine::error_result<engine::apply_report>(
        engine::error_code::internal_error, "js runtime error: " + std::string(e.what())
    );
  } catch (const std::bad_alloc& e) {
    log.err("js memory allocation failed", redlog::field("error", e.what()), redlog::field("context", log_context));
    return engine::error_result<engine::apply_report>(
        engine::error_code::internal_error, "js out of memory: " + std::string(e.what())
    );
  } catch (const std::exception& e) {
    log.err("js execution failed", redlog::field("error", e.what()), redlog::field("context", log_context));
    return engine::error_result<engine::apply_report>(
        engine::error_code::internal_error, "js execution error: " + std::string(e.what())
    );
  }
}

} // namespace

js_engine::js_engine() {
  auto log = redlog::get_logger("p1ll.js_engine");
  log.inf("initializing js engine");
}

engine::result<engine::apply_report> js_engine::execute_script(
    engine::session& session, const std::string& script_content
) {
  auto log = redlog::get_logger("p1ll.js_engine");
  log.inf("executing js script", redlog::field("mode", session.is_dynamic() ? "dynamic" : "static"));

  auto js_ctx = jnjs::runtime::new_context();
  setup_p1ll_js_bindings(js_ctx, session);
  return execute_cure_script_impl(js_ctx, script_content, session.is_dynamic() ? "dynamic" : "static");
}

} // namespace p1ll::scripting::js

```

`src/p1ll/scripting/js/js_engine.hpp`:

```hpp
#pragma once

#include "../script_engine.hpp"
#include <string>
#include <memory>

namespace p1ll::scripting::js {

// javascript script execution engine (stub implementation)
class js_engine : public IScriptEngine {
public:
  js_engine();
  ~js_engine() = default;

  // execute script with an active session
  engine::result<engine::apply_report> execute_script(
      engine::session& session, const std::string& script_content
  ) override;
};

} // namespace p1ll::scripting::js

```

`src/p1ll/scripting/lua/lua_bindings.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>
#include <redlog.hpp>
#include <algorithm>
#include <cctype>
#include <filesystem>
#include <limits>
#include <regex>
#include <string>
#include <unordered_map>
#include <vector>

#include "p1ll/engine/result.hpp"
#include "p1ll/engine/session.hpp"
#include "p1ll/engine/types.hpp"
#include "p1ll/utils/hex_utils.hpp"

namespace p1ll::scripting::lua {

inline const char* error_code_name(engine::error_code code) {
  switch (code) {
  case engine::error_code::ok:
    return "ok";
  case engine::error_code::invalid_argument:
    return "invalid_argument";
  case engine::error_code::invalid_pattern:
    return "invalid_pattern";
  case engine::error_code::not_found:
    return "not_found";
  case engine::error_code::multiple_matches:
    return "multiple_matches";
  case engine::error_code::io_error:
    return "io_error";
  case engine::error_code::protection_error:
    return "protection_error";
  case engine::error_code::verification_failed:
    return "verification_failed";
  case engine::error_code::platform_mismatch:
    return "platform_mismatch";
  case engine::error_code::overlap:
    return "overlap";
  case engine::error_code::unsupported:
    return "unsupported";
  case engine::error_code::invalid_context:
    return "invalid_context";
  case engine::error_code::internal_error:
    return "internal_error";
  }
  return "unknown";
}

inline std::string format_status(const engine::status& status) {
  std::string label = error_code_name(status.code);
  if (status.message.empty()) {
    return label;
  }
  return label + ": " + status.message;
}

inline bool looks_like_path(const std::string& value) {
  return value.find('/') != std::string::npos || value.find('\\') != std::string::npos;
}

inline std::string module_key_for_path(const std::string& path) {
#ifdef _WIN32
  std::string key = path;
  std::replace(key.begin(), key.end(), '/', '\\');
  std::transform(key.begin(), key.end(), key.begin(), [](unsigned char c) {
    return static_cast<char>(std::tolower(c));
  });
  return key;
#else
  return path;
#endif
}

struct apply_report_wrapper {
  bool success = false;
  int applied = 0;
  int failed = 0;
  std::vector<std::string> error_messages;
  std::vector<std::string> diagnostics;

  apply_report_wrapper() = default;
  explicit apply_report_wrapper(const engine::apply_report& report)
      : success(report.success), applied(static_cast<int>(report.applied)), failed(static_cast<int>(report.failed)) {
    for (const auto& diag : report.diagnostics) {
      diagnostics.push_back(format_status(diag));
      if (!diag.message.empty()) {
        error_messages.push_back(diag.message);
      }
    }
  }

  void add_error(const std::string& message) {
    error_messages.push_back(message);
    diagnostics.push_back(format_status(engine::make_status(engine::error_code::invalid_argument, message)));
    success = false;
  }
};

struct scan_result_wrapper {
  uint64_t address = 0;
  std::string region_name;
};

struct module_info_wrapper {
  std::string name;
  std::string path;
  uint64_t base_address = 0;
  uint64_t size = 0;
  std::string permissions;
  bool is_system_module = false;
};

struct signature_wrapper {
  engine::signature_spec spec;
};

struct patch_wrapper {
  engine::patch_spec spec;
};

inline void apply_scan_options(engine::scan_options& options, const sol::table& opts) {
  sol::optional<std::string> filter = opts["filter"];
  if (filter) {
    options.filter.name_regex = *filter;
  }

  sol::optional<bool> single = opts["single"];
  if (single) {
    options.single = *single;
  }

  sol::optional<int> max_matches = opts["max_matches"];
  if (max_matches) {
    options.max_matches = static_cast<size_t>(*max_matches);
  }

  sol::optional<bool> only_exec = opts["only_executable"];
  if (only_exec) {
    options.filter.only_executable = *only_exec;
  }

  sol::optional<bool> exclude_system = opts["exclude_system"];
  if (exclude_system) {
    options.filter.exclude_system = *exclude_system;
  }

  sol::optional<int> min_size = opts["min_size"];
  if (min_size) {
    options.filter.min_size = static_cast<size_t>(*min_size);
  }

  sol::optional<uint64_t> min_addr = opts["min_address"];
  if (min_addr) {
    options.filter.min_address = *min_addr;
  }

  sol::optional<uint64_t> max_addr = opts["max_address"];
  if (max_addr) {
    options.filter.max_address = *max_addr;
  }
}

inline std::vector<std::string> parse_platform_list(const sol::object& value) {
  if (value.is<sol::table>()) {
    std::vector<std::string> platforms;
    sol::table table = value.as<sol::table>();
    for (const auto& entry : table) {
      if (entry.second.is<std::string>()) {
        platforms.push_back(entry.second.as<std::string>());
      }
    }
    return platforms;
  }
  return {};
}

inline engine::recipe parse_recipe(const sol::table& meta) {
  engine::recipe recipe;

  sol::optional<std::string> name_val = meta["name"];
  if (name_val) {
    recipe.name = *name_val;
  }

  sol::object platforms_val = meta["platforms"];
  if (platforms_val.valid()) {
    recipe.platforms = parse_platform_list(platforms_val);
  }

  sol::optional<sol::table> validations_val = meta["validations"];
  if (validations_val) {
    sol::table list = *validations_val;
    for (const auto& entry : list) {
      if (entry.second.is<signature_wrapper>()) {
        recipe.validations.push_back(entry.second.as<signature_wrapper>().spec);
      }
    }
  }

  sol::optional<sol::table> sigs_val = meta["sigs"];
  if (sigs_val) {
    sol::table map = *sigs_val;
    for (const auto& entry : map) {
      std::string platform_key = entry.first.as<std::string>();
      sol::table sig_list = entry.second.as<sol::table>();
      for (const auto& sig_entry : sig_list) {
        if (!sig_entry.second.is<signature_wrapper>()) {
          continue;
        }
        engine::signature_spec spec = sig_entry.second.as<signature_wrapper>().spec;
        spec.platforms.clear();
        if (platform_key != "*" && platform_key != "*:*") {
          spec.platforms.push_back(platform_key);
        }
        recipe.validations.push_back(spec);
      }
    }
  }

  sol::optional<sol::table> patches_val = meta["patches"];
  if (patches_val) {
    sol::table patch_table = *patches_val;
    if (patch_table.size() > 0 && patch_table[1].valid()) {
      for (const auto& entry : patch_table) {
        if (entry.second.is<patch_wrapper>()) {
          recipe.patches.push_back(entry.second.as<patch_wrapper>().spec);
        }
      }
    } else {
      for (const auto& entry : patch_table) {
        std::string platform_key = entry.first.as<std::string>();
        sol::table patch_list = entry.second.as<sol::table>();
        for (const auto& patch_entry : patch_list) {
          if (!patch_entry.second.is<patch_wrapper>()) {
            continue;
          }
          engine::patch_spec spec = patch_entry.second.as<patch_wrapper>().spec;
          spec.platforms.clear();
          if (platform_key != "*" && platform_key != "*:*") {
            spec.platforms.push_back(platform_key);
          }
          recipe.patches.push_back(spec);
        }
      }
    }
  }

  return recipe;
}

inline void setup_p1ll_bindings(sol::state& lua, engine::session& session) {
  auto log = redlog::get_logger("p1ll.lua_bindings");
  log.inf("setting up lua bindings", redlog::field("mode", session.is_dynamic() ? "dynamic" : "static"));
  lua.new_usertype<apply_report_wrapper>(
      "apply_report", "success", &apply_report_wrapper::success, "applied", &apply_report_wrapper::applied, "failed",
      &apply_report_wrapper::failed, "error_messages", &apply_report_wrapper::error_messages, "diagnostics",
      &apply_report_wrapper::diagnostics
  );

  lua.new_usertype<scan_result_wrapper>(
      "scan_result", "address", &scan_result_wrapper::address, "region_name", &scan_result_wrapper::region_name
  );

  lua.new_usertype<module_info_wrapper>(
      "module_info", "name", &module_info_wrapper::name, "path", &module_info_wrapper::path, "base_address",
      &module_info_wrapper::base_address, "size", &module_info_wrapper::size, "permissions",
      &module_info_wrapper::permissions, "is_system_module", &module_info_wrapper::is_system_module
  );

  lua.new_usertype<signature_wrapper>("signature", "pattern", sol::property([](const signature_wrapper& sig) {
                                        return sig.spec.pattern;
                                      }));

  lua.new_usertype<patch_wrapper>("patch");

  sol::table p1_module = lua.create_named_table("p1");

  p1_module.set_function("str2hex", [](const std::string& str) { return p1ll::utils::str2hex(str); });
  p1_module.set_function("hex2str", [](const std::string& hex) { return p1ll::utils::hex2str(hex); });
  p1_module.set_function("format_address", [](uint64_t address) { return p1ll::utils::format_address(address); });

  p1_module.set_function("sig", [](const std::string& pattern, sol::optional<sol::table> opts) {
    engine::signature_spec spec;
    spec.pattern = pattern;
    if (opts) {
      apply_scan_options(spec.options, *opts);
      sol::optional<bool> required = (*opts)["required"];
      if (required) {
        spec.required = *required;
      }
      sol::object platforms = (*opts)["platforms"];
      if (platforms.valid()) {
        spec.platforms = parse_platform_list(platforms);
      }
    }
    signature_wrapper wrapper;
    wrapper.spec = std::move(spec);
    return wrapper;
  });

  p1_module.set_function(
      "patch", [](sol::object sig_param, int64_t offset, const std::string& pattern, sol::optional<sol::table> opts) {
        engine::patch_spec spec;
        if (sig_param.is<signature_wrapper>()) {
          spec.signature = sig_param.as<signature_wrapper>().spec;
        } else if (sig_param.is<std::string>()) {
          spec.signature.pattern = sig_param.as<std::string>();
        }
        spec.offset = offset;
        spec.patch = pattern;
        spec.required = true;

        if (opts) {
          sol::optional<bool> required = (*opts)["required"];
          if (required) {
            spec.required = *required;
          }
          sol::object platforms = (*opts)["platforms"];
          if (platforms.valid()) {
            spec.platforms = parse_platform_list(platforms);
          }
        }

        patch_wrapper wrapper;
        wrapper.spec = std::move(spec);
        return wrapper;
      }
  );

  p1_module.set_function("auto_cure", [&session](sol::table meta) {
    auto log = redlog::get_logger("p1ll.lua.auto_cure");
    auto recipe = parse_recipe(meta);
    apply_report_wrapper report;
    if (recipe.patches.empty()) {
      log.err("auto_cure called with empty patch list");
      report.add_error("recipe.patches is required");
      return report;
    }

    log.inf("executing auto_cure", redlog::field("name", recipe.name));
    auto plan = session.plan(recipe);
    if (!plan.ok()) {
      log.err("auto_cure planning failed", redlog::field("error", plan.status_info.message));
      report.add_error(plan.status_info.message.empty() ? "plan failed" : plan.status_info.message);
      return report;
    }

    auto applied = session.apply(plan.value);
    report = apply_report_wrapper(applied.value);
    if (!applied.ok()) {
      if (!applied.status_info.message.empty()) {
        report.add_error(applied.status_info.message);
      }
      log.err("auto_cure apply failed", redlog::field("error", applied.status_info.message));
    }
    log.inf(
        "auto_cure completed", redlog::field("success", report.success), redlog::field("applied", report.applied),
        redlog::field("failed", report.failed)
    );
    return report;
  });

  p1_module.set_function("get_modules", [&session](sol::optional<std::string> filter_pattern) {
    std::vector<module_info_wrapper> result;
    auto log = redlog::get_logger("p1ll.lua");
    if (!session.is_dynamic()) {
      log.dbg("get_modules unavailable in static mode");
      return result;
    }

    auto regions = session.regions(engine::scan_filter{});
    if (!regions.ok()) {
      log.err("get_modules failed", redlog::field("error", regions.status_info.message));
      return result;
    }

    std::optional<std::regex> filter_regex;
    if (filter_pattern && !filter_pattern->empty()) {
      try {
        filter_regex.emplace(*filter_pattern);
      } catch (const std::regex_error&) {
        log.err("invalid module filter regex");
        return result;
      }
    }

    struct module_accumulator {
      std::string path;
      uint64_t base_address = std::numeric_limits<uint64_t>::max();
      uint64_t end_address = 0;
      engine::memory_protection protection = engine::memory_protection::none;
      bool has_executable = false;
      bool is_system = false;
    };

    std::unordered_map<std::string, module_accumulator> modules;
    for (const auto& region : regions.value) {
      if (region.name.empty() || !looks_like_path(region.name)) {
        continue;
      }

      auto& entry = modules[module_key_for_path(region.name)];
      if (entry.path.empty()) {
        entry.path = region.name;
      }

      entry.base_address = std::min(entry.base_address, region.base_address);
      uint64_t region_end = region.base_address + region.size;
      if (region_end >= region.base_address) {
        entry.end_address = std::max(entry.end_address, region_end);
      }
      entry.protection = entry.protection | region.protection;
      entry.has_executable = entry.has_executable || region.is_executable;
      entry.is_system = entry.is_system || region.is_system;
    }

    result.reserve(modules.size());
    for (const auto& [path, entry] : modules) {
      if (!entry.has_executable || entry.base_address == std::numeric_limits<uint64_t>::max()) {
        continue;
      }

      std::string name = std::filesystem::path(entry.path).filename().string();
      if (filter_regex) {
        if (!std::regex_search(entry.path, *filter_regex) && !std::regex_search(name, *filter_regex)) {
          continue;
        }
      }

      if (entry.end_address < entry.base_address) {
        continue;
      }

      module_info_wrapper mod;
      mod.name = name;
      mod.path = entry.path;
      mod.base_address = entry.base_address;
      mod.size = entry.end_address - entry.base_address;
      mod.permissions =
          std::string(engine::has_protection(entry.protection, engine::memory_protection::read) ? "r" : "-") +
          (engine::has_protection(entry.protection, engine::memory_protection::write) ? "w" : "-") +
          (engine::has_protection(entry.protection, engine::memory_protection::execute) ? "x" : "-");
      mod.is_system_module = entry.is_system;
      result.push_back(mod);
    }

    std::sort(result.begin(), result.end(), [](const module_info_wrapper& a, const module_info_wrapper& b) {
      return a.base_address < b.base_address;
    });

    log.dbg("found modules", redlog::field("count", result.size()));
    return result;
  });

  p1_module.set_function(
      "search_sig", [&session, &lua](const std::string& pattern, sol::optional<sol::table> opts) -> sol::object {
        auto log = redlog::get_logger("p1ll.lua");
        engine::scan_options options;
        if (opts) {
          apply_scan_options(options, *opts);
        }
        auto results = session.scan(pattern, options);
        if (!results.ok() || results.value.empty()) {
          if (!results.ok()) {
            log.err(
                "search failed", redlog::field("pattern", pattern), redlog::field("error", results.status_info.message)
            );
          } else {
            log.dbg("search returned no matches", redlog::field("pattern", pattern));
          }
          return sol::make_object(lua, sol::lua_nil);
        }
        if (options.single && results.value.size() != 1) {
          log.dbg(
              "single match required but search returned unexpected count", redlog::field("count", results.value.size())
          );
          return sol::make_object(lua, sol::lua_nil);
        }
        if (results.value.size() > 1) {
          log.wrn("multiple matches, returning first", redlog::field("count", results.value.size()));
        }
        scan_result_wrapper wrapper;
        wrapper.address = results.value.front().address;
        wrapper.region_name = results.value.front().region_name;
        return sol::make_object(lua, wrapper);
      }
  );

  p1_module.set_function(
      "search_sig_multiple",
      [&session](const std::string& pattern, sol::optional<sol::table> opts) -> std::vector<scan_result_wrapper> {
        std::vector<scan_result_wrapper> output;
        auto log = redlog::get_logger("p1ll.lua");
        engine::scan_options options;
        if (opts) {
          apply_scan_options(options, *opts);
        }
        auto results = session.scan(pattern, options);
        if (!results.ok()) {
          log.err(
              "search failed", redlog::field("pattern", pattern), redlog::field("error", results.status_info.message)
          );
          return output;
        }
        for (const auto& result : results.value) {
          scan_result_wrapper wrapper;
          wrapper.address = result.address;
          wrapper.region_name = result.region_name;
          output.push_back(wrapper);
        }
        log.dbg("search completed", redlog::field("results", output.size()));
        return output;
      }
  );
  log.inf("lua bindings registered");
}

} // namespace p1ll::scripting::lua

```

`src/p1ll/scripting/lua/lua_engine.cpp`:

```cpp
#include "lua_engine.hpp"
#include "lua_bindings.hpp"
#include <redlog.hpp>
#include <fstream>
#include <sstream>

namespace p1ll::scripting::lua {

lua_engine::lua_engine() {
  setup_lua_environment();
  setup_logging_integration();
}

void lua_engine::setup_lua_environment() {
  auto log = redlog::get_logger("p1ll.lua_engine");
  log.dbg("setting up lua environment");

  // open standard lua libraries
  lua_.open_libraries(sol::lib::base, sol::lib::string, sol::lib::math, sol::lib::table, sol::lib::io, sol::lib::os);

  log.dbg("lua environment ready (bindings setup deferred)");
}

void lua_engine::setup_logging_integration() {
  auto log = redlog::get_logger("p1ll.lua_engine");
  log.dbg("setting up logging integration");

  // override lua print function to use redlog
  lua_["print"] = [](sol::variadic_args args) {
    auto log = redlog::get_logger("p1ll.lua.print");
    std::ostringstream oss;

    for (const auto& arg : args) {
      if (oss.tellp() > 0) {
        oss << "\t";
      }
      oss << lua_tostring(args.lua_state(), arg.stack_index());
    }

    log.inf(oss.str());
  };

  log.dbg("logging integration complete");
}

engine::result<engine::apply_report> lua_engine::execute_script(
    engine::session& session, const std::string& script_content
) {
  auto log = redlog::get_logger("p1ll.lua_engine");

  log.inf("executing lua script", redlog::field("mode", session.is_dynamic() ? "dynamic" : "static"));

  try {
    setup_p1ll_bindings(lua_, session);

    auto script_result = lua_.script(script_content);
    if (!script_result.valid()) {
      sol::error error = script_result;
      log.err("lua script failed", redlog::field("error", error.what()));
      return engine::error_result<engine::apply_report>(
          engine::error_code::invalid_argument, "lua script error: " + std::string(error.what())
      );
    }

    return call_cure_function();
  } catch (const sol::error& e) {
    log.err("lua execution error", redlog::field("error", e.what()));
    return engine::error_result<engine::apply_report>(
        engine::error_code::internal_error, "lua execution error: " + std::string(e.what())
    );
  } catch (const std::exception& e) {
    log.err("lua execution c++ exception", redlog::field("error", e.what()));
    return engine::error_result<engine::apply_report>(
        engine::error_code::internal_error, "lua execution failed: " + std::string(e.what())
    );
  }
}

engine::result<engine::apply_report> lua_engine::call_cure_function() {
  auto log = redlog::get_logger("p1ll.lua_engine");

  try {
    sol::function cure_func = lua_["cure"];
    if (!cure_func.valid()) {
      log.err("cure function not found");
      return engine::error_result<engine::apply_report>(
          engine::error_code::invalid_argument, "cure function not found in script"
      );
    }

    log.dbg("calling cure function");
    auto cure_result = cure_func();

    if (!cure_result.valid()) {
      sol::error error = cure_result;
      log.err("cure function failed", redlog::field("error", error.what()));
      return engine::error_result<engine::apply_report>(
          engine::error_code::internal_error, "cure function failed: " + std::string(error.what())
      );
    }

    sol::object result_obj = cure_result;
    if (result_obj.is<apply_report_wrapper>()) {
      auto wrapper = result_obj.as<apply_report_wrapper>();
      engine::apply_report report;
      report.success = wrapper.success;
      report.applied = static_cast<size_t>(wrapper.applied);
      report.failed = static_cast<size_t>(wrapper.failed);
      for (const auto& message : wrapper.error_messages) {
        report.diagnostics.push_back(engine::make_status(engine::error_code::internal_error, message));
      }

      log.inf(
          "cure completed", redlog::field("success", report.success), redlog::field("applied", report.applied),
          redlog::field("failed", report.failed)
      );
      return engine::ok_result(report);
    }

    if (result_obj.is<sol::table>()) {
      sol::table table = result_obj;
      engine::apply_report report;
      report.success = table["success"].get_or(false);
      report.applied = table["applied"].get_or(0);
      report.failed = table["failed"].get_or(0);
      log.inf(
          "cure completed", redlog::field("success", report.success), redlog::field("applied", report.applied),
          redlog::field("failed", report.failed)
      );
      return engine::ok_result(report);
    }

    log.err("cure function returned unexpected type");
    return engine::error_result<engine::apply_report>(
        engine::error_code::invalid_argument, "cure function returned unexpected type"
    );
  } catch (const sol::error& e) {
    log.err("cure function lua error", redlog::field("error", e.what()));
    return engine::error_result<engine::apply_report>(
        engine::error_code::internal_error, "cure function lua error: " + std::string(e.what())
    );
  } catch (const std::exception& e) {
    log.err("cure function c++ exception", redlog::field("error", e.what()));
    return engine::error_result<engine::apply_report>(
        engine::error_code::internal_error, "cure function failed: " + std::string(e.what())
    );
  }
}

} // namespace p1ll::scripting::lua

```

`src/p1ll/scripting/lua/lua_engine.hpp`:

```hpp
#pragma once

#include "../script_engine.hpp"
#include <sol/sol.hpp>
#include <string>
#include <memory>

namespace p1ll::scripting::lua {

// lua script execution engine
class lua_engine : public IScriptEngine {
public:
  lua_engine();
  ~lua_engine() = default;

  // execute script with an active session
  engine::result<engine::apply_report> execute_script(
      engine::session& session, const std::string& script_content
  ) override;

  // get lua state for advanced usage
  sol::state& get_lua_state() { return lua_; }

private:
  sol::state lua_;

  void setup_lua_environment();
  void setup_logging_integration();

  // execute cure function from loaded script
  engine::result<engine::apply_report> call_cure_function();
};

} // namespace p1ll::scripting::lua

```

`src/p1ll/scripting/script_engine.hpp`:

```hpp
#pragma once

#include "engine/result.hpp"
#include "engine/session.hpp"
#include "engine/types.hpp"
#include <string>
#include <memory>

namespace p1ll::scripting {

// abstract interface for script engines
class IScriptEngine {
public:
  virtual ~IScriptEngine() = default;

  // execute script with an active session (process or buffer)
  virtual engine::result<engine::apply_report> execute_script(
      engine::session& session, const std::string& script_content
  ) = 0;
};

// supported script engine types
enum class ScriptEngineType { LUA, JAVASCRIPT };

} // namespace p1ll::scripting

```

`src/p1ll/scripting/script_engine_factory.cpp`:

```cpp
#include "script_engine_factory.hpp"
#include <redlog.hpp>

// conditional includes based on compile-time configuration
#ifdef PILL_SCRIPT_ENGINE_JS
#include "js/js_engine.hpp"
#else
#include "lua/lua_engine.hpp"
#endif

namespace p1ll::scripting {

std::unique_ptr<IScriptEngine> ScriptEngineFactory::create() { return create(get_default_engine_type()); }

std::unique_ptr<IScriptEngine> ScriptEngineFactory::create(ScriptEngineType engine_type) {
  auto log = redlog::get_logger("p1ll.script_factory");

  switch (engine_type) {
#ifndef PILL_SCRIPT_ENGINE_JS
  case ScriptEngineType::LUA:
    log.inf("creating lua script engine");
    return std::make_unique<lua::lua_engine>();
#endif

#ifdef PILL_SCRIPT_ENGINE_JS
  case ScriptEngineType::JAVASCRIPT:
    log.inf("creating js script engine");
    return std::make_unique<js::js_engine>();
#endif

  default:
    log.err("unsupported script engine type for this build configuration");
    return nullptr;
  }
}

ScriptEngineType ScriptEngineFactory::get_default_engine_type() {
  // compile-time engine selection based on configuration
#ifdef PILL_SCRIPT_ENGINE_JS
  return ScriptEngineType::JAVASCRIPT;
#else
  // default to lua
  return ScriptEngineType::LUA;
#endif
}

std::vector<ScriptEngineType> ScriptEngineFactory::get_supported_engines() {
  std::vector<ScriptEngineType> supported;

#ifndef PILL_SCRIPT_ENGINE_JS
  supported.push_back(ScriptEngineType::LUA);
#endif

#ifdef PILL_SCRIPT_ENGINE_JS
  supported.push_back(ScriptEngineType::JAVASCRIPT);
#endif

  return supported;
}

std::vector<std::string> ScriptEngineFactory::get_supported_extensions() {
  std::vector<std::string> extensions;

#ifndef PILL_SCRIPT_ENGINE_JS
  extensions.push_back(".lua");
#endif

#ifdef PILL_SCRIPT_ENGINE_JS
  extensions.push_back(".js");
#endif

  return extensions;
}

bool ScriptEngineFactory::is_engine_supported(ScriptEngineType engine_type) {
  switch (engine_type) {
#ifndef PILL_SCRIPT_ENGINE_JS
  case ScriptEngineType::LUA:
    return true;
#endif
#ifdef PILL_SCRIPT_ENGINE_JS
  case ScriptEngineType::JAVASCRIPT:
    return true;
#endif
  default:
    return false;
  }
}

} // namespace p1ll::scripting

```

`src/p1ll/scripting/script_engine_factory.hpp`:

```hpp
#pragma once

#include "script_engine.hpp"
#include <memory>
#include <vector>
#include <string>

namespace p1ll::scripting {

// factory for creating script engines
class ScriptEngineFactory {
public:
  // create script engine based on compile-time configuration
  static std::unique_ptr<IScriptEngine> create();

  // create script engine by explicit type (for testing)
  static std::unique_ptr<IScriptEngine> create(ScriptEngineType engine_type);

  // get the default engine type based on build configuration
  static ScriptEngineType get_default_engine_type();

  // get list of supported script engines in this build
  static std::vector<ScriptEngineType> get_supported_engines();

  // get file extensions for supported engines
  static std::vector<std::string> get_supported_extensions();

  // check if an engine type is supported in this build
  static bool is_engine_supported(ScriptEngineType engine_type);
};

} // namespace p1ll::scripting
```

`src/p1ll/utils/file_utils.cpp`:

```cpp
#include "file_utils.hpp"
#include <fstream>
#include <filesystem>
#include <iterator>

namespace p1ll::utils {

std::optional<std::vector<uint8_t>> read_file(const std::string& file_path) {
  std::ifstream file(file_path, std::ios::binary);
  if (!file.is_open()) {
    return std::nullopt;
  }

  std::vector<uint8_t> data;
  data.assign(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>());
  return data;
}

std::optional<std::string> read_file_string(const std::string& file_path) {
  std::ifstream file(file_path);
  if (!file.is_open()) {
    return std::nullopt;
  }

  std::string content;
  content.assign(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>());
  return content;
}

bool write_file(const std::string& file_path, const std::vector<uint8_t>& data) {
  std::ofstream file(file_path, std::ios::binary);
  if (!file.is_open()) {
    return false;
  }

  file.write(reinterpret_cast<const char*>(data.data()), data.size());
  return file.good();
}

bool write_file(const std::string& file_path, const std::string& data) {
  std::ofstream file(file_path);
  if (!file.is_open()) {
    return false;
  }

  file << data;
  return file.good();
}

bool file_exists(const std::string& file_path) { return std::filesystem::exists(file_path); }

std::optional<size_t> get_file_size(const std::string& file_path) {
  std::error_code ec;
  auto size = std::filesystem::file_size(file_path, ec);
  if (ec) {
    return std::nullopt;
  }
  return size;
}

} // namespace p1ll::utils
```

`src/p1ll/utils/file_utils.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>
#include <optional>
#include <cstdint>

namespace p1ll::utils {

// file reading/writing utilities
std::optional<std::vector<uint8_t>> read_file(const std::string& file_path);
std::optional<std::string> read_file_string(const std::string& file_path);
bool write_file(const std::string& file_path, const std::vector<uint8_t>& data);
bool write_file(const std::string& file_path, const std::string& data);

// file system utilities
bool file_exists(const std::string& file_path);
std::optional<size_t> get_file_size(const std::string& file_path);

} // namespace p1ll::utils
```

`src/p1ll/utils/hex_pattern.cpp`:

```cpp
#include "hex_pattern.hpp"
#include "hex_utils.hpp"
#include <redlog.hpp>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <cctype>

namespace p1ll::utils {

std::string strip_comments_hex_pattern(const std::string& pattern);

bool is_valid_hex_pattern(const std::string& pattern) {
  std::string normalized = normalize_hex_pattern(pattern);

  // empty patterns are invalid
  if (normalized.empty()) {
    return false;
  }

  // check if length is even (each byte needs 2 hex digits or ?? wildcard)
  if (normalized.length() % 2 != 0) {
    return false;
  }

  // validate each byte position
  for (size_t i = 0; i < normalized.length(); i += 2) {
    char first = normalized[i];
    char second = normalized[i + 1];

    // either both are hex digits or both are wildcards
    if ((first == '?' && second == '?') || (p1ll::utils::is_hex_digit(first) && p1ll::utils::is_hex_digit(second))) {
      continue;
    } else {
      return false;
    }
  }

  return true;
}

std::vector<uint8_t> parse_hex_pattern(const std::string& hex) {
  auto log = redlog::get_logger("p1ll.hex_pattern");

  std::vector<uint8_t> bytes;
  std::string clean_hex = normalize_hex_pattern(hex);

  if (!is_valid_hex_pattern(clean_hex)) {
    log.err("invalid hex pattern", redlog::field("pattern", hex));
    return bytes;
  }

  for (size_t i = 0; i < clean_hex.length(); i += 2) {
    char hex_byte[3] = {clean_hex[i], clean_hex[i + 1], '\0'};

    if (hex_byte[0] == '?' && hex_byte[1] == '?') {
      // wildcard byte, use 0x00 as placeholder
      bytes.push_back(0x00);
    } else {
      uint8_t byte = static_cast<uint8_t>(std::stoul(hex_byte, nullptr, 16));
      bytes.push_back(byte);
    }
  }

  return bytes;
}

std::string strip_comments_hex_pattern(const std::string& pattern) {
  std::string result;
  std::istringstream stream(pattern);
  std::string line;

  while (std::getline(stream, line)) {
    // find the first comment delimiter
    size_t comment_pos = std::string::npos;

    // check for -- comment
    size_t pos = line.find("--");
    if (pos != std::string::npos) {
      comment_pos = pos;
    }

    // check for // comment
    pos = line.find("//");
    if (pos != std::string::npos && pos < comment_pos) {
      comment_pos = pos;
    }

    // check for # comment
    pos = line.find('#');
    if (pos != std::string::npos && pos < comment_pos) {
      comment_pos = pos;
    }

    // check for ; comment
    pos = line.find(';');
    if (pos != std::string::npos && pos < comment_pos) {
      comment_pos = pos;
    }

    // extract the part before the comment
    if (comment_pos != std::string::npos) {
      line = line.substr(0, comment_pos);
    }

    // add the line to result (with a space separator if needed)
    if (!result.empty() && !line.empty()) {
      result += " ";
    }
    result += line;
  }

  return result;
}

std::string normalize_hex_pattern(const std::string& pattern) {
  // first strip comments
  std::string stripped = strip_comments_hex_pattern(pattern);

  std::string result;
  result.reserve(stripped.length());

  for (char c : stripped) {
    if (std::isspace(c)) {
      // skip whitespace
      continue;
    } else if (std::isalpha(c)) {
      // convert to lowercase
      result.push_back(std::tolower(c));
    } else {
      // numbers, question marks, etc.
      result.push_back(c);
    }
  }

  return result;
}

// pattern visualization
std::string format_memory_range(uint64_t start_addr, uint64_t end_addr) {
  size_t range_size = static_cast<size_t>(end_addr - start_addr);
  std::ostringstream oss;
  oss << "range([$" << std::hex << std::setw(16) << std::setfill('0') << std::nouppercase << start_addr << "-$"
      << std::setw(16) << std::setfill('0') << end_addr << "], sz=" << std::dec << range_size << ")";
  return oss.str();
}

std::string format_memory_region(uint64_t start_addr, uint64_t size, const std::string& name) {
  uint64_t end_addr = start_addr + size;
  std::ostringstream oss;
  oss << "region([$" << std::hex << std::setw(16) << std::setfill('0') << std::nouppercase << start_addr << "-$"
      << std::setw(16) << std::setfill('0') << end_addr << "], sz=" << std::dec << size;
  if (!name.empty()) {
    oss << ", name=" << name;
  }
  oss << ")";
  return oss.str();
}

std::string format_hex_bytes(const uint8_t* data, size_t size, size_t max_bytes) {
  std::ostringstream oss;
  size_t display_size = std::min(size, max_bytes);

  for (size_t i = 0; i < display_size; i++) {
    oss << std::hex << std::setw(2) << std::setfill('0') << std::nouppercase << static_cast<int>(data[i]);
    if (i < display_size - 1) {
      oss << " ";
    }
  }

  if (size > max_bytes) {
    oss << " ... (+" << (size - max_bytes) << " bytes)";
  }

  return oss.str();
}

} // namespace p1ll::utils
```

`src/p1ll/utils/hex_pattern.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>
#include <cstdint>

namespace p1ll::utils {

// pattern validation and parsing
bool is_valid_hex_pattern(const std::string& pattern);
std::vector<uint8_t> parse_hex_pattern(const std::string& hex);
std::string normalize_hex_pattern(const std::string& pattern);

// pattern visualization
std::string format_memory_range(uint64_t start_addr, uint64_t end_addr);
std::string format_memory_region(uint64_t start_addr, uint64_t size, const std::string& name);
std::string format_hex_bytes(const uint8_t* data, size_t size, size_t max_bytes = 16);

} // namespace p1ll::utils
```

`src/p1ll/utils/hex_utils.cpp`:

```cpp
#include "hex_utils.hpp"
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <cctype>

namespace p1ll::utils {

std::string str2hex(const std::string& str) {
  std::ostringstream oss;
  for (unsigned char c : str) {
    oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(c);
  }
  return oss.str();
}

std::string hex2str(const std::string& hex) {
  std::string result;
  std::string clean_hex = hex;

  // remove spaces and convert to lowercase
  clean_hex.erase(std::remove_if(clean_hex.begin(), clean_hex.end(), ::isspace), clean_hex.end());
  std::transform(clean_hex.begin(), clean_hex.end(), clean_hex.begin(), ::tolower);

  if (clean_hex.length() % 2 != 0) {
    return "";
  }

  for (size_t i = 0; i < clean_hex.length(); i += 2) {
    char hex_byte[3] = {clean_hex[i], clean_hex[i + 1], '\0'};

    if (!is_hex_digit(hex_byte[0]) || !is_hex_digit(hex_byte[1])) {
      return "";
    }

    uint8_t byte = static_cast<uint8_t>(std::stoul(hex_byte, nullptr, 16));
    result.push_back(static_cast<char>(byte));
  }

  return result;
}

std::string format_address(uint64_t address) {
  std::ostringstream oss;
  oss << "0x" << std::hex << std::setw(16) << std::setfill('0') << address;
  return oss.str();
}

std::string format_bytes(const std::vector<uint8_t>& bytes) {
  std::ostringstream oss;
  for (size_t i = 0; i < bytes.size(); ++i) {
    if (i > 0) {
      oss << " ";
    }
    oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]);
  }
  return oss.str();
}

bool is_hex_digit(char c) { return std::isdigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'); }

uint8_t parse_hex_digit(char c) {
  if (std::isdigit(c)) {
    return static_cast<uint8_t>(c - '0');
  } else if (c >= 'a' && c <= 'f') {
    return static_cast<uint8_t>(c - 'a' + 10);
  } else if (c >= 'A' && c <= 'F') {
    return static_cast<uint8_t>(c - 'A' + 10);
  }
  return 0; // invalid
}

std::string to_hex_string(uint8_t byte) {
  std::ostringstream oss;
  oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
  return oss.str();
}

} // namespace p1ll::utils
```

`src/p1ll/utils/hex_utils.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>
#include <cstdint>

namespace p1ll::utils {

// string to hex conversion
std::string str2hex(const std::string& str);
std::string hex2str(const std::string& hex);

// address formatting
std::string format_address(uint64_t address);
std::string format_bytes(const std::vector<uint8_t>& bytes);

// hex digit utilities
bool is_hex_digit(char c);
uint8_t parse_hex_digit(char c);
std::string to_hex_string(uint8_t byte);

} // namespace p1ll::utils
```

`src/p1ll/utils/memory_align.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>

namespace p1ll::utils {

inline uint64_t align_down(uint64_t value, size_t alignment) {
  if (alignment == 0) {
    return value;
  }
  uint64_t mask = static_cast<uint64_t>(alignment - 1);
  return value & ~mask;
}

inline uint64_t align_up(uint64_t value, size_t alignment) {
  if (alignment == 0) {
    return value;
  }
  uint64_t mask = static_cast<uint64_t>(alignment - 1);
  return (value + mask) & ~mask;
}

} // namespace p1ll::utils

```

`src/p1ll/utils/pretty_hexdump.cpp`:

```cpp
#include "pretty_hexdump.hpp"
#include <redlog.hpp>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <vector>

namespace p1ll::utils {

namespace {

// color scheme for different element types
constexpr auto offset_color = redlog::color::bright_black;
constexpr auto unchanged_color = redlog::color::white;
constexpr auto before_change_color = redlog::color::cyan;
constexpr auto after_change_color = redlog::color::red;
constexpr auto signature_match_color = redlog::color::bright_green;
constexpr auto context_color = redlog::color::bright_black;
constexpr auto ascii_color = redlog::color::bright_black;

/**
 * format a single hex byte with optional color.
 */
std::string format_hex_byte(uint8_t byte, redlog::color color = redlog::color::none) {
  std::ostringstream oss;
  oss << std::hex << std::setw(2) << std::setfill('0') << std::nouppercase << static_cast<int>(byte);
  return redlog::detail::colorize(oss.str(), color);
}

/**
 * format a printable ascii character with optional color.
 */
std::string format_ascii_char(uint8_t byte, redlog::color color = redlog::color::none) {
  char c = (byte >= 32 && byte <= 126) ? static_cast<char>(byte) : '.';
  return redlog::detail::colorize(std::string(1, c), color);
}

/**
 * format an address offset with consistent width and color.
 */
std::string format_offset(uint64_t offset) {
  std::ostringstream oss;
  oss << std::hex << std::setw(16) << std::setfill('0') << std::nouppercase << offset << ":";
  return redlog::detail::colorize(oss.str(), offset_color);
}

/**
 * detect which bytes differ between two arrays.
 */
std::vector<bool> find_byte_differences(const uint8_t* a, const uint8_t* b, size_t size) {
  std::vector<bool> differences(size);
  for (size_t i = 0; i < size; ++i) {
    differences[i] = (a[i] != b[i]);
  }
  return differences;
}

/**
 * format a line of hex bytes with optional highlighting.
 */
std::string format_hex_line(
    const uint8_t* data, size_t line_size, size_t bytes_per_line, const std::vector<bool>& highlight_mask = {},
    redlog::color highlight_color = redlog::color::none
) {
  std::ostringstream oss;

  for (size_t i = 0; i < bytes_per_line; ++i) {
    if (i > 0) {
      oss << " ";
    }

    if (i < line_size) {
      redlog::color color = unchanged_color;
      if (!highlight_mask.empty() && i < highlight_mask.size() && highlight_mask[i]) {
        color = highlight_color;
      }
      oss << format_hex_byte(data[i], color);
    } else {
      // padding for incomplete lines
      oss << "  ";
    }

    // add extra space every 8 bytes for readability
    if (i == 7) {
      oss << " ";
    }
  }

  return oss.str();
}

/**
 * format ascii representation of a line with optional highlighting.
 */
std::string format_ascii_line(
    const uint8_t* data, size_t line_size, const std::vector<bool>& highlight_mask = {},
    redlog::color highlight_color = redlog::color::none
) {
  std::ostringstream oss;
  oss << "|";

  for (size_t i = 0; i < line_size; ++i) {
    redlog::color color = ascii_color;
    if (!highlight_mask.empty() && i < highlight_mask.size() && highlight_mask[i]) {
      color = highlight_color;
    }
    oss << format_ascii_char(data[i], color);
  }

  oss << "|";
  return oss.str();
}

} // anonymous namespace

std::string format_hexdump(const uint8_t* data, size_t size, uint64_t base_offset, const hexdump_options& opts) {
  if (!data || size == 0) {
    return "";
  }

  std::ostringstream result;
  size_t lines_shown = 0;

  // calculate 16-byte aligned boundaries
  uint64_t aligned_start = base_offset & ~0xF;
  uint64_t aligned_end = (base_offset + size + 15) & ~0xF;

  // calculate padding at start and end
  size_t start_padding = base_offset - aligned_start;
  size_t total_aligned_size = aligned_end - aligned_start;

  for (size_t aligned_offset = 0; aligned_offset < total_aligned_size; aligned_offset += opts.bytes_per_line) {
    if (lines_shown >= opts.max_lines) {
      result << "... (truncated, " << (total_aligned_size - aligned_offset) << " more bytes)\n";
      break;
    }

    uint64_t display_offset = aligned_start + aligned_offset;
    result << format_offset(display_offset) << "  ";

    // format hex bytes for this line
    for (size_t i = 0; i < opts.bytes_per_line; ++i) {
      if (i > 0) {
        result << " ";
      }
      if (i == 8) {
        result << " "; // extra space after 8 bytes
      }

      size_t data_pos = aligned_offset + i;
      if (data_pos < start_padding || data_pos >= start_padding + size) {
        // padding byte
        result << "  ";
      } else {
        // actual data byte
        size_t data_index = data_pos - start_padding;
        result << format_hex_byte(data[data_index], unchanged_color);
      }
    }

    if (opts.show_ascii) {
      result << "  |";
      for (size_t i = 0; i < opts.bytes_per_line; ++i) {
        size_t data_pos = aligned_offset + i;
        if (data_pos < start_padding || data_pos >= start_padding + size) {
          // padding byte
          result << " ";
        } else {
          // actual data byte
          size_t data_index = data_pos - start_padding;
          result << format_ascii_char(data[data_index], ascii_color);
        }
      }
      result << "|";
    }

    result << "\n";
    lines_shown++;
  }

  return result.str();
}

std::string format_patch_hexdump(
    const uint8_t* before_data, const uint8_t* after_data, size_t size, uint64_t base_offset,
    const hexdump_options& opts
) {
  if (!before_data || !after_data || size == 0) {
    return "";
  }

  std::ostringstream result;
  size_t lines_shown = 0;

  // find differences in the actual data
  auto differences = find_byte_differences(before_data, after_data, size);

  // iterate through data, showing full 16-byte aligned rows
  for (size_t offset = 0; offset < size; offset += opts.bytes_per_line) {
    if (lines_shown >= opts.max_lines) {
      result << "... (truncated)\n";
      break;
    }

    size_t line_size = std::min(opts.bytes_per_line, size - offset);
    uint64_t display_offset = base_offset + offset;

    // before line
    result << format_offset(display_offset) << "  ";

    // format hex bytes for this line
    for (size_t i = 0; i < opts.bytes_per_line; ++i) {
      if (i > 0) {
        result << " ";
      }
      if (i == 8) {
        result << " "; // extra space after 8 bytes
      }

      if (i < line_size) {
        // actual data byte
        bool is_different = differences[offset + i];
        redlog::color color = is_different ? before_change_color : unchanged_color;
        result << format_hex_byte(before_data[offset + i], color);
      } else {
        // padding for incomplete line
        result << "  ";
      }
    }

    if (opts.show_ascii) {
      result << "  |";
      for (size_t i = 0; i < opts.bytes_per_line; ++i) {
        if (i < line_size) {
          // actual data byte
          bool is_different = differences[offset + i];
          redlog::color color = is_different ? before_change_color : ascii_color;
          result << format_ascii_char(before_data[offset + i], color);
        } else {
          // padding for incomplete line
          result << " ";
        }
      }
      result << "|";
    }
    result << "\n";

    // after line - same offset, no label for clean alignment
    result << format_offset(display_offset) << "  ";

    // format hex bytes for this line
    for (size_t i = 0; i < opts.bytes_per_line; ++i) {
      if (i > 0) {
        result << " ";
      }
      if (i == 8) {
        result << " "; // extra space after 8 bytes
      }

      if (i < line_size) {
        // actual data byte
        bool is_different = differences[offset + i];
        redlog::color color = is_different ? after_change_color : unchanged_color;
        result << format_hex_byte(after_data[offset + i], color);
      } else {
        // padding for incomplete line
        result << "  ";
      }
    }

    if (opts.show_ascii) {
      result << "  |";
      for (size_t i = 0; i < opts.bytes_per_line; ++i) {
        if (i < line_size) {
          // actual data byte
          bool is_different = differences[offset + i];
          redlog::color color = is_different ? after_change_color : ascii_color;
          result << format_ascii_char(after_data[offset + i], color);
        } else {
          // padding for incomplete line
          result << " ";
        }
      }
      result << "|";
    }
    result << "\n";

    lines_shown++;
  }

  std::string output = result.str();
  // remove trailing newline since logging will add one
  if (!output.empty() && output.back() == '\n') {
    output.pop_back();
  }
  return output;
}

std::string format_signature_match_hexdump(
    const uint8_t* data, size_t data_size, size_t match_offset, size_t pattern_size, uint64_t base_offset,
    const hexdump_options& opts
) {
  if (!data || data_size == 0 || match_offset >= data_size) {
    return "";
  }

  // calculate context boundaries with alignment
  size_t context_start = (match_offset >= opts.context_bytes) ? match_offset - opts.context_bytes : 0;
  size_t context_end = std::min(data_size, match_offset + pattern_size + opts.context_bytes);

  // align context boundaries to 16-byte boundaries
  size_t aligned_start = context_start & ~0xF;
  size_t aligned_end = (context_end + 15) & ~0xF;

  // ensure we don't go past data boundaries
  if (aligned_end > data_size) {
    aligned_end = data_size;
  }

  std::ostringstream result;
  size_t lines_shown = 0;

  for (size_t offset = aligned_start; offset < aligned_end; offset += opts.bytes_per_line) {
    if (lines_shown >= opts.max_lines) {
      result << "... (truncated)\n";
      break;
    }

    uint64_t display_offset = base_offset + offset;
    result << format_offset(display_offset) << "  ";

    // format hex bytes for this line
    for (size_t i = 0; i < opts.bytes_per_line; ++i) {
      if (i > 0) {
        result << " ";
      }
      if (i == 8) {
        result << " "; // extra space after 8 bytes
      }

      size_t absolute_pos = offset + i;
      if (absolute_pos >= data_size) {
        // past end of data
        result << "  ";
      } else {
        // determine if this byte is part of the match
        bool is_match = absolute_pos >= match_offset && absolute_pos < match_offset + pattern_size;
        redlog::color color = is_match ? signature_match_color : unchanged_color;
        result << format_hex_byte(data[absolute_pos], color);
      }
    }

    if (opts.show_ascii) {
      result << "  |";
      for (size_t i = 0; i < opts.bytes_per_line; ++i) {
        size_t absolute_pos = offset + i;
        if (absolute_pos >= data_size) {
          // past end of data
          result << " ";
        } else {
          // determine if this byte is part of the match
          bool is_match = absolute_pos >= match_offset && absolute_pos < match_offset + pattern_size;
          redlog::color color = is_match ? signature_match_color : ascii_color;
          result << format_ascii_char(data[absolute_pos], color);
        }
      }
      result << "|";
    }

    result << "\n";
    lines_shown++;
  }

  return result.str();
}

std::string format_signature_pattern(const std::vector<uint8_t>& bytes, const std::vector<uint8_t>& mask) {
  if (bytes.size() != mask.size()) {
    return "invalid signature pattern";
  }

  std::ostringstream oss;
  for (size_t i = 0; i < bytes.size(); ++i) {
    if (i > 0) {
      oss << " ";
    }
    if (mask[i]) {
      oss << format_hex_byte(bytes[i], signature_match_color);
    } else {
      oss << redlog::detail::colorize("??", context_color);
    }
  }

  return oss.str();
}

std::string format_patch_pattern(const std::vector<uint8_t>& bytes, const std::vector<uint8_t>& mask) {
  if (bytes.size() != mask.size()) {
    return "invalid patch pattern";
  }

  std::ostringstream oss;
  for (size_t i = 0; i < bytes.size(); ++i) {
    if (i > 0) {
      oss << " ";
    }
    if (mask[i]) {
      oss << format_hex_byte(bytes[i], after_change_color);
    } else {
      oss << redlog::detail::colorize("??", context_color);
    }
  }

  return oss.str();
}

std::string format_patch_hexdump(
    const std::vector<uint8_t>& before, const std::vector<uint8_t>& after, uint64_t base_offset,
    const hexdump_options& opts
) {
  if (before.size() != after.size()) {
    return "error: before and after vectors must be same size\n";
  }

  return format_patch_hexdump(before.data(), after.data(), before.size(), base_offset, opts);
}

std::string format_hexdump(const std::vector<uint8_t>& data, uint64_t base_offset, const hexdump_options& opts) {
  return format_hexdump(data.data(), data.size(), base_offset, opts);
}

} // namespace p1ll::utils

```

`src/p1ll/utils/pretty_hexdump.hpp`:

```hpp
#pragma once

#include <string>
#include <cstdint>
#include <vector>

namespace p1ll::utils {

/**
 * options for controlling hexdump formatting and appearance.
 */
struct hexdump_options {
  size_t bytes_per_line = 16; // number of bytes to display per line
  bool show_ascii = true;     // include ascii representation column
  bool show_offset = true;    // include offset column
  size_t context_bytes = 8;   // context bytes for signature matches
  size_t max_lines = 32;      // maximum lines to display (prevents spam)
};

/**
 * create a pretty hexdump of memory data.
 *
 * @param data pointer to data to dump
 * @param size number of bytes to dump
 * @param base_offset base address offset for display
 * @param opts formatting options
 * @return formatted hexdump string
 */
std::string format_hexdump(
    const uint8_t* data, size_t size, uint64_t base_offset = 0, const hexdump_options& opts = {}
);

/**
 * create a side-by-side patch comparison hexdump showing before/after changes.
 *
 * @param before_data original data
 * @param after_data patched data
 * @param size number of bytes to compare
 * @param base_offset base address offset for display
 * @param opts formatting options
 * @return formatted side-by-side comparison string
 */
std::string format_patch_hexdump(
    const uint8_t* before_data, const uint8_t* after_data, size_t size, uint64_t base_offset = 0,
    const hexdump_options& opts = {}
);

/**
 * create a signature match hexdump highlighting the matched pattern.
 * matched bytes are highlighted in green with surrounding context in gray.
 *
 * @param data memory data containing the match
 * @param data_size total size of data buffer
 * @param match_offset offset where pattern was found
 * @param pattern_size size of matched pattern
 * @param base_offset base address offset for display
 * @param opts formatting options
 * @return formatted signature match visualization
 */
std::string format_signature_match_hexdump(
    const uint8_t* data, size_t data_size, size_t match_offset, size_t pattern_size, uint64_t base_offset = 0,
    const hexdump_options& opts = {}
);

/**
 * create a colorized signature pattern string with wildcards.
 */
std::string format_signature_pattern(const std::vector<uint8_t>& bytes, const std::vector<uint8_t>& mask);

/**
 * create a colorized patch pattern string with wildcards.
 */
std::string format_patch_pattern(const std::vector<uint8_t>& bytes, const std::vector<uint8_t>& mask);

/**
 * convenience function to create a patch comparison for vectors.
 */
std::string format_patch_hexdump(
    const std::vector<uint8_t>& before, const std::vector<uint8_t>& after, uint64_t base_offset = 0,
    const hexdump_options& opts = {}
);

/**
 * convenience function to create a hexdump for a vector.
 */
std::string format_hexdump(
    const std::vector<uint8_t>& data, uint64_t base_offset = 0, const hexdump_options& opts = {}
);

} // namespace p1ll::utils

```

`src/p1ll/utils/windows_compat.hpp`:

```hpp
#pragma once

/**
 * @brief clean windows headers for p1ll
 */

#ifdef _WIN32

#ifndef NOMINMAX
#define NOMINMAX
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN
#endif

#include <windows.h>

#ifdef NEED_PSAPI
#include <psapi.h>
#endif

// undefine problematic macros
#ifdef ERROR
#undef ERROR
#endif

#ifdef min
#undef min
#endif

#ifdef max
#undef max
#endif

#endif // _WIN32
```

`src/p1llx/CMakeLists.txt`:

```txt
# p1llx static binary patcher tool

if(WITNESS_SCRIPT)
    # p1llx executable sources
    set(P1LLX_SOURCES
        main.cpp
        commands/cure.cpp
        commands/patch.cpp
        commands/poison.cpp
        commands/sig.cpp
    )

    if(WITNESS_ASMR)
        list(APPEND P1LLX_SOURCES
            commands/asm.cpp
            commands/disasm.cpp
        )
    endif()
    
    # create executable
    w1_add_executable(p1llx ${P1LLX_SOURCES})
    
    # link with p1ll library and dependencies
    target_link_libraries(p1llx 
        PRIVATE 
        p1ll_core
        p1ll_script
        w1base
        w1nj3ct
    )

    if(WITNESS_ASMR)
        target_link_libraries(p1llx PRIVATE w1asmr)
    endif()
    
    install(TARGETS p1llx
        RUNTIME DESTINATION bin
        COMPONENT ${W1_INSTALL_COMPONENT}
    )

    message(STATUS "p1llx static patcher tool configured")
    
else()
    message(STATUS "p1llx tool skipped - lua scripting not enabled")
endif()

```

`src/p1llx/commands/asm.cpp`:

```cpp
#include "asm.hpp"

#include <iostream>

#include <redlog.hpp>

#include "p1ll/utils/hex_utils.hpp"
#include "w1asmr/asmr.hpp"

namespace p1llx::commands {

namespace {

w1::asmr::result<w1::asmr::arch_spec> resolve_arch(const std::string& arch_override) {
  if (arch_override.empty()) {
    return w1::asmr::detect_host_arch_spec();
  }
  return w1::asmr::parse_arch_spec(arch_override);
}

} // namespace

int asm_command(const asm_request& request) {
  auto log = redlog::get_logger("p1llx.asm");

  if (request.text.empty()) {
    log.err("assembly text required");
    std::cerr << "error: assembly text is required" << std::endl;
    return 1;
  }

  auto arch_value = resolve_arch(request.arch);
  if (!arch_value.ok()) {
    log.err("invalid arch override", redlog::field("error", arch_value.status_info.message));
    std::cerr << "error: invalid arch override" << std::endl;
    return 1;
  }

  auto ctx = w1::asmr::asm_context::for_arch(arch_value.value);
  if (!ctx.ok()) {
    log.err("failed to initialize assembler", redlog::field("error", ctx.status_info.message));
    std::cerr << "error: failed to initialize assembler" << std::endl;
    return 1;
  }

  uint64_t address = request.has_address ? request.address : 0;
  auto assembled = ctx.value.assemble(request.text, address);
  if (!assembled.ok()) {
    log.err("assembly failed", redlog::field("error", assembled.status_info.message));
    std::cerr << "error: assembly failed" << std::endl;
    return 1;
  }

  std::cout << p1ll::utils::format_bytes(assembled.value) << std::endl;
  return 0;
}

} // namespace p1llx::commands

```

`src/p1llx/commands/asm.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>

namespace p1llx::commands {

struct asm_request {
  std::string text;
  std::string arch;
  bool has_address = false;
  uint64_t address = 0;
};

int asm_command(const asm_request& request);

} // namespace p1llx::commands

```

`src/p1llx/commands/cure.cpp`:

```cpp
#include "cure.hpp"
#include <p1ll/p1ll.hpp>
#include <p1ll/scripting/script_engine_factory.hpp>
#include <redlog.hpp>
#include <iostream>
#include <fstream>
#include <sstream>

namespace p1llx::commands {

int cure(
    const std::string& script_path, const std::string& input_file, const std::string& output_file,
    const std::string& platform_override
) {

  auto log = redlog::get_logger("p1llx.commands.cure");

  log.inf(
      "applying cure script to file", redlog::field("script", script_path), redlog::field("input", input_file),
      redlog::field("output", output_file), redlog::field("platform", platform_override)
  );

  try {
    // read script content
    std::ifstream script_stream(script_path);
    if (!script_stream) {
      std::cerr << "failed to open script file: " << script_path << std::endl;
      return 1;
    }

    std::ostringstream script_buffer;
    script_buffer << script_stream.rdbuf();
    std::string script_content = script_buffer.str();

    log.dbg("loaded script content", redlog::field("size", script_content.size()));

    // read input file to buffer
    std::ifstream input_stream(input_file, std::ios::binary);
    if (!input_stream) {
      std::cerr << "failed to open input file: " << input_file << std::endl;
      return 1;
    }

    std::vector<uint8_t> buffer_data((std::istreambuf_iterator<char>(input_stream)), std::istreambuf_iterator<char>());

    log.dbg("loaded input file", redlog::field("size", buffer_data.size()));

    // create buffer session
    p1ll::engine::session session = p1ll::engine::session::for_buffer(buffer_data);
    if (!platform_override.empty()) {
      auto parsed = p1ll::engine::platform::parse_platform(platform_override);
      if (!parsed.ok()) {
        log.err("invalid platform override", redlog::field("platform", platform_override));
        std::cerr << "invalid platform override '" << platform_override << "'" << std::endl;
        return 1;
      }
      log.inf("using platform override", redlog::field("platform", parsed.value.to_string()));
      session = p1ll::engine::session::for_buffer(buffer_data, parsed.value);
    }

    auto script_engine = p1ll::scripting::ScriptEngineFactory::create();
    if (!script_engine) {
      std::cerr << "failed to create script engine" << std::endl;
      return 1;
    }
    auto result = script_engine->execute_script(session, script_content);
    if (result.ok() && result.value.success) {
      // write modified buffer to output file
      std::ofstream output_stream(output_file, std::ios::binary);
      if (!output_stream) {
        std::cerr << "failed to create output file: " << output_file << std::endl;
        return 1;
      }

      output_stream.write(reinterpret_cast<const char*>(buffer_data.data()), buffer_data.size());

      log.inf(
          "cure completed successfully", redlog::field("patches_applied", result.value.applied),
          redlog::field("patches_failed", result.value.failed)
      );

      return 0;
    } else {
      size_t error_count = result.value.diagnostics.size();
      log.err("cure failed", redlog::field("errors", error_count));

      std::cerr << "cure failed with " << error_count << " errors:" << std::endl;
      for (const auto& error : result.value.diagnostics) {
        std::cerr << "  error: " << error.message << std::endl;
        log.err("cure error detail", redlog::field("message", error.message));
      }
      if (!result.ok() && !result.status_info.message.empty()) {
        std::cerr << "  error: " << result.status_info.message << std::endl;
      }

      return 1;
    }

  } catch (const std::exception& e) {
    log.err("cure execution failed", redlog::field("error", e.what()));
    std::cerr << "cure execution failed: " << e.what() << std::endl;
    return 1;
  }
}

} // namespace p1llx::commands

```

`src/p1llx/commands/cure.hpp`:

```hpp
#pragma once

#include <string>

namespace p1llx::commands {

/**
 * @brief Apply auto-cure lua script to static file
 *
 * @param script_path Path to lua cure script
 * @param input_file Path to input binary file
 * @param output_file Path to output binary file
 * @param platform_override Optional platform override (e.g., "linux:x64", "darwin:arm64")
 * @return 0 for success, 1 for failure
 */
int cure(
    const std::string& script_path, const std::string& input_file, const std::string& output_file,
    const std::string& platform_override = ""
);

} // namespace p1llx::commands
```

`src/p1llx/commands/disasm.cpp`:

```cpp
#include "disasm.hpp"

#include <cctype>
#include <iostream>
#include <string>
#include <vector>

#include <redlog.hpp>

#include "p1ll/utils/hex_utils.hpp"
#include "w1asmr/asmr.hpp"

namespace p1llx::commands {

namespace {

bool parse_hex_bytes(const std::string& input, std::vector<uint8_t>& output, std::string& error) {
  std::string clean;
  clean.reserve(input.size());

  for (char c : input) {
    if (std::isspace(static_cast<unsigned char>(c))) {
      continue;
    }
    if (c == '?') {
      error = "wildcards are not supported for disasm";
      return false;
    }
    clean.push_back(c);
  }

  if (clean.empty()) {
    error = "hex input is empty";
    return false;
  }

  if (clean.size() % 2 != 0) {
    error = "hex input must have an even number of digits";
    return false;
  }

  output.clear();
  output.reserve(clean.size() / 2);
  for (size_t i = 0; i < clean.size(); i += 2) {
    char hi = clean[i];
    char lo = clean[i + 1];
    if (!p1ll::utils::is_hex_digit(hi) || !p1ll::utils::is_hex_digit(lo)) {
      error = "hex input contains non-hex characters";
      return false;
    }
    uint8_t byte = static_cast<uint8_t>((p1ll::utils::parse_hex_digit(hi) << 4) | p1ll::utils::parse_hex_digit(lo));
    output.push_back(byte);
  }

  return true;
}

w1::asmr::result<w1::asmr::arch_spec> resolve_arch(const std::string& arch_override) {
  if (arch_override.empty()) {
    return w1::asmr::detect_host_arch_spec();
  }
  return w1::asmr::parse_arch_spec(arch_override);
}

} // namespace

int disasm_command(const disasm_request& request) {
  auto log = redlog::get_logger("p1llx.disasm");

  if (request.bytes.empty()) {
    log.err("hex bytes required");
    std::cerr << "error: hex bytes are required" << std::endl;
    return 1;
  }

  std::vector<uint8_t> bytes;
  std::string parse_error;
  if (!parse_hex_bytes(request.bytes, bytes, parse_error)) {
    log.err("invalid hex bytes", redlog::field("error", parse_error));
    std::cerr << "error: invalid hex bytes" << std::endl;
    return 1;
  }

  auto arch_value = resolve_arch(request.arch);
  if (!arch_value.ok()) {
    log.err("invalid arch override", redlog::field("error", arch_value.status_info.message));
    std::cerr << "error: invalid arch override" << std::endl;
    return 1;
  }

  auto ctx = w1::asmr::disasm_context::for_arch(arch_value.value);
  if (!ctx.ok()) {
    log.err("failed to initialize disassembler", redlog::field("error", ctx.status_info.message));
    std::cerr << "error: failed to initialize disassembler" << std::endl;
    return 1;
  }

  uint64_t address = request.has_address ? request.address : 0;
  auto disassembled = ctx.value.disassemble(bytes, address);
  if (!disassembled.ok()) {
    log.err("disassembly failed", redlog::field("error", disassembled.status_info.message));
    std::cerr << "error: disassembly failed" << std::endl;
    return 1;
  }

  for (const auto& inst : disassembled.value) {
    std::cout << p1ll::utils::format_address(inst.address) << ": " << p1ll::utils::format_bytes(inst.bytes);
    if (!inst.mnemonic.empty()) {
      std::cout << "  " << inst.mnemonic;
      if (!inst.operands.empty()) {
        std::cout << " " << inst.operands;
      }
    }
    std::cout << "\n";
  }

  return 0;
}

} // namespace p1llx::commands

```

`src/p1llx/commands/disasm.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>

namespace p1llx::commands {

struct disasm_request {
  std::string bytes;
  std::string arch;
  bool has_address = false;
  uint64_t address = 0;
};

int disasm_command(const disasm_request& request);

} // namespace p1llx::commands

```

`src/p1llx/commands/patch.cpp`:

```cpp
#include "patch.hpp"

#include <fstream>
#include <iostream>
#include <span>

#include <redlog.hpp>

#include <p1ll/p1ll.hpp>
#include "p1ll/engine/session.hpp"
#include "platform_utils.hpp"

namespace p1llx::commands {

namespace {

bool parse_offset_value(const std::string& value, int64_t& out) {
  if (value.empty()) {
    out = 0;
    return true;
  }

  try {
    size_t idx = 0;
    long long parsed = std::stoll(value, &idx, 0);
    if (idx != value.size()) {
      return false;
    }
    out = static_cast<int64_t>(parsed);
    return true;
  } catch (const std::exception&) {
    return false;
  }
}

} // namespace

int patch(
    const std::string& address_str, const std::string& replace_data, const std::string& input_file,
    const std::string& output_file
) {

  auto log = redlog::get_logger("p1llx.commands.patch");

  log.inf(
      "applying manual patch", redlog::field("address", address_str), redlog::field("replace", replace_data),
      redlog::field("input", input_file), redlog::field("output", output_file)
  );

  try {
    // parse address (support both 0x prefix and plain hex)
    uint64_t address;
    if (address_str.substr(0, 2) == "0x" || address_str.substr(0, 2) == "0X") {
      address = std::stoull(address_str, nullptr, 16);
    } else {
      address = std::stoull(address_str, nullptr, 16);
    }

    // validate hex pattern
    if (!p1ll::utils::is_valid_hex_pattern(replace_data)) {
      log.err("invalid replacement hex pattern", redlog::field("pattern", replace_data));
      std::cerr << "error: invalid hex pattern: " << replace_data << std::endl;
      return 1;
    }

    // read input file
    std::ifstream input(input_file, std::ios::binary | std::ios::ate);
    if (!input.is_open()) {
      log.err("failed to open input file", redlog::field("path", input_file));
      std::cerr << "error: could not open input file: " << input_file << std::endl;
      return 1;
    }

    auto file_size = input.tellg();
    input.seekg(0, std::ios::beg);

    std::vector<uint8_t> file_data(static_cast<size_t>(file_size));
    input.read(reinterpret_cast<char*>(file_data.data()), file_size);
    input.close();

    if (!input) {
      log.err("failed to read input file", redlog::field("path", input_file));
      std::cerr << "error: failed to read input file: " << input_file << std::endl;
      return 1;
    }

    // compile patch
    auto parsed_patch = p1ll::engine::parse_patch(replace_data);
    if (!parsed_patch.ok()) {
      log.err("failed to compile patch", redlog::field("pattern", replace_data));
      std::cerr << "error: failed to compile patch pattern: " << replace_data << std::endl;
      return 1;
    }

    // check bounds
    if (address + parsed_patch.value.bytes.size() > file_data.size()) {
      log.err(
          "patch would exceed file bounds", redlog::field("address", address),
          redlog::field("patch_size", parsed_patch.value.bytes.size()), redlog::field("file_size", file_data.size())
      );
      std::cerr << "error: patch would exceed file bounds" << std::endl;
      return 1;
    }

    // apply patch
    size_t bytes_patched = 0;
    for (size_t i = 0; i < parsed_patch.value.bytes.size(); ++i) {
      if (parsed_patch.value.mask[i]) {
        file_data[address + i] = parsed_patch.value.bytes[i];
        bytes_patched++;
      }
    }

    // write output file
    std::ofstream output(output_file, std::ios::binary);
    if (!output.is_open()) {
      log.err("failed to create output file", redlog::field("path", output_file));
      std::cerr << "error: could not create output file: " << output_file << std::endl;
      return 1;
    }

    output.write(reinterpret_cast<const char*>(file_data.data()), file_data.size());
    output.close();

    if (!output) {
      log.err("failed to write output file", redlog::field("path", output_file));
      std::cerr << "error: failed to write output file: " << output_file << std::endl;
      return 1;
    }

    log.inf(
        "patch applied successfully", redlog::field("bytes_patched", bytes_patched), redlog::field("address", address)
    );

    std::cout << "patch applied successfully" << std::endl;
    std::cout << "bytes patched: " << bytes_patched << " at address 0x" << std::hex << address << std::endl;

    return 0;

  } catch (const std::exception& e) {
    log.err("patch failed", redlog::field("error", e.what()));
    std::cerr << "error: " << e.what() << std::endl;
    return 1;
  }
}

int patch_signature(
    const std::string& signature_pattern, const std::string& offset_str, const std::string& replace_data,
    const std::string& input_file, const std::string& output_file, const std::string& platform_override
) {
  auto log = redlog::get_logger("p1llx.commands.patch_sig");

  if (signature_pattern.empty()) {
    log.err("signature pattern required");
    std::cerr << "error: signature pattern is required" << std::endl;
    return 1;
  }

  int64_t offset = 0;
  if (!parse_offset_value(offset_str, offset)) {
    log.err("invalid patch offset", redlog::field("offset", offset_str));
    std::cerr << "error: invalid patch offset" << std::endl;
    return 1;
  }

  if (!p1ll::utils::is_valid_hex_pattern(signature_pattern)) {
    log.err("invalid signature pattern", redlog::field("pattern", signature_pattern));
    std::cerr << "error: invalid signature pattern" << std::endl;
    return 1;
  }

  if (!p1ll::utils::is_valid_hex_pattern(replace_data)) {
    log.err("invalid replacement hex pattern", redlog::field("pattern", replace_data));
    std::cerr << "error: invalid hex pattern: " << replace_data << std::endl;
    return 1;
  }

  auto file_data = p1ll::utils::read_file(input_file);
  if (!file_data.has_value()) {
    log.err("failed to read input file", redlog::field("path", input_file));
    std::cerr << "error: could not read input file: " << input_file << std::endl;
    return 1;
  }

  auto platform = resolve_platform(platform_override);
  if (!platform.ok()) {
    log.err("invalid platform override", redlog::field("error", platform.status_info.message));
    std::cerr << "error: invalid platform override" << std::endl;
    return 1;
  }

  auto buffer = std::span<uint8_t>(*file_data);
  auto session = platform_override.empty() ? p1ll::engine::session::for_buffer(buffer)
                                           : p1ll::engine::session::for_buffer(buffer, platform.value);

  p1ll::engine::signature_spec signature;
  signature.pattern = signature_pattern;
  signature.options.single = true;

  p1ll::engine::patch_spec patch_spec;
  patch_spec.signature = signature;
  patch_spec.offset = offset;
  patch_spec.patch = replace_data;
  patch_spec.required = true;

  p1ll::engine::recipe recipe;
  recipe.name = "p1llx.patch";
  recipe.patches.push_back(patch_spec);

  auto plan = session.plan(recipe);
  if (!plan.ok()) {
    log.err("failed to build patch plan", redlog::field("error", plan.status_info.message));
    std::cerr << "error: " << plan.status_info.message << std::endl;
    return 1;
  }

  auto report = session.apply(plan.value);
  if (!report.ok()) {
    log.err("failed to apply patch plan", redlog::field("error", report.status_info.message));
    std::cerr << "error: " << report.status_info.message << std::endl;
    return 1;
  }
  if (!report.value.success) {
    log.err("patch plan failed", redlog::field("applied", report.value.applied));
    std::cerr << "error: patch plan failed" << std::endl;
    return 1;
  }

  if (!p1ll::utils::write_file(output_file, *file_data)) {
    log.err("failed to write output file", redlog::field("path", output_file));
    std::cerr << "error: failed to write output file: " << output_file << std::endl;
    return 1;
  }

  std::cout << "patch applied successfully" << std::endl;
  if (plan.value.size() == 1) {
    std::cout << "patched " << p1ll::utils::format_address(plan.value.front().address) << std::endl;
  } else {
    std::cout << "patched " << plan.value.size() << " locations" << std::endl;
  }

  return 0;
}

} // namespace p1llx::commands

```

`src/p1llx/commands/patch.hpp`:

```hpp
#pragma once

#include <string>

namespace p1llx::commands {

/**
 * @brief Apply manual hex patch to file
 *
 * @param address_str Address to patch (hex string)
 * @param replace_data Replacement hex bytes
 * @param input_file Path to input binary file
 * @param output_file Path to output binary file
 * @return 0 for success, 1 for failure
 */
int patch(
    const std::string& address_str, const std::string& replace_data, const std::string& input_file,
    const std::string& output_file
);

/**
 * @brief Apply signature-based patch to file
 *
 * @param signature_pattern Signature hex pattern
 * @param offset_str Offset from signature match (hex or decimal; empty means 0)
 * @param replace_data Replacement hex bytes
 * @param input_file Path to input binary file
 * @param output_file Path to output binary file
 * @param platform_override Optional platform override (e.g., "linux:x64", "darwin:arm64")
 * @return 0 for success, 1 for failure
 */
int patch_signature(
    const std::string& signature_pattern, const std::string& offset_str, const std::string& replace_data,
    const std::string& input_file, const std::string& output_file, const std::string& platform_override = ""
);

} // namespace p1llx::commands

```

`src/p1llx/commands/platform_utils.hpp`:

```hpp
#pragma once

#include <string_view>

#include "p1ll/engine/platform/platform.hpp"
#include "p1ll/engine/result.hpp"

namespace p1llx::commands {

inline p1ll::engine::result<p1ll::engine::platform::platform_key> resolve_platform(
    std::string_view platform_override, bool require_arch = true
) {
  if (platform_override.empty()) {
    return p1ll::engine::ok_result(p1ll::engine::platform::detect_platform());
  }

  auto parsed = p1ll::engine::platform::parse_platform(platform_override);
  if (!parsed.ok()) {
    return p1ll::engine::error_result<p1ll::engine::platform::platform_key>(
        parsed.status_info.code, parsed.status_info.message
    );
  }

  if (require_arch && (parsed.value.arch.empty() || parsed.value.arch == "*")) {
    return p1ll::engine::error_result<p1ll::engine::platform::platform_key>(
        p1ll::engine::error_code::invalid_argument, "platform override must include a concrete arch"
    );
  }

  return parsed;
}

} // namespace p1llx::commands

```

`src/p1llx/commands/poison.cpp`:

```cpp
#include "poison.hpp"

#include <iostream>
#include <filesystem>
#include <cstdlib>

#include <redlog.hpp>
#include <w1nj3ct/w1nj3ct.hpp>
#include <w1base/platform_utils.hpp>

namespace p1llx::commands {

// shared helper function to find p01s0n library
static std::string find_p01s0n_library(const std::string& executable_path) {
  auto log = redlog::get_logger("p1llx.poison");

  // find p01s0n library using same discovery pattern as tracers
  std::string p01s0n_lib_name = "p01s0n";
  std::string lib_ext = w1::common::platform_utils::get_library_extension();
  std::string p01s0n_filename = p01s0n_lib_name + lib_ext;

  // get executable directory for relative search (same as tracer discovery)
  std::filesystem::path exec_path;
  try {
    if (!executable_path.empty()) {
      exec_path = std::filesystem::canonical(executable_path);
    } else {
      exec_path = std::filesystem::current_path();
    }
  } catch (const std::exception& e) {
    log.dbg(
        "failed to canonicalize executable path, using as-is", redlog::field("path", executable_path),
        redlog::field("error", e.what())
    );
    exec_path = !executable_path.empty() ? std::filesystem::path(executable_path) : std::filesystem::path(".");
  }

  std::filesystem::path exec_dir = exec_path.parent_path();

  log.dbg(
      "searching for p01s0n library", redlog::field("filename", p01s0n_filename),
      redlog::field("exec_dir", exec_path.string())
  );

  // search paths relative to executable directory (same as tracer discovery)
  std::vector<std::filesystem::path> search_dirs = {
      exec_dir,                // same directory as executable
      exec_dir / "lib",        // lib/ subdirectory
      exec_dir / ".." / "lib", // ../lib/ (for installed layouts)
      exec_dir / "..",         // parent directory
  };

  for (const auto& search_dir : search_dirs) {
    if (!std::filesystem::exists(search_dir) || !std::filesystem::is_directory(search_dir)) {
      continue;
    }

    auto candidate_path = search_dir / p01s0n_filename;
    if (std::filesystem::exists(candidate_path)) {
      std::string found_lib_path = std::filesystem::canonical(candidate_path).string();
      log.dbg("found p01s0n library", redlog::field("path", found_lib_path));
      return found_lib_path;
    }
  }

  log.err("p01s0n library not found", redlog::field("filename", p01s0n_filename));
  std::cerr << "error: p01s0n library not found (" << p01s0n_filename << ")" << std::endl;
  std::cerr << "searched directories:" << std::endl;
  for (const auto& dir : search_dirs) {
    std::cerr << "  " << dir.string() << std::endl;
  }
  return "";
}

int poison_spawn(
    const std::string& script_path, const std::string& binary_path, const std::vector<std::string>& binary_args,
    bool suspended, const std::string& executable_path, int verbosity_level
) {

  auto log = redlog::get_logger("p1llx.poison");

  log.inf(
      "starting p01s0n injection", redlog::field("script", script_path), redlog::field("binary", binary_path),
      redlog::field("suspended", suspended ? "true" : "false")
  );

  // validate script file exists
  if (!std::filesystem::exists(script_path)) {
    log.err("cure script file does not exist", redlog::field("path", script_path));
    std::cerr << "error: cure script not found: " << script_path << std::endl;
    return 1;
  }

  // validate binary exists
  if (!std::filesystem::exists(binary_path)) {
    log.err("target binary does not exist", redlog::field("path", binary_path));
    std::cerr << "error: target binary not found: " << binary_path << std::endl;
    return 1;
  }

  // find p01s0n library
  std::string found_lib_path = find_p01s0n_library(executable_path);
  if (found_lib_path.empty()) {
    return 1;
  }

  log.inf("found p01s0n library", redlog::field("path", found_lib_path));

  // convert script path to absolute path for environment variable
  std::string abs_script_path = std::filesystem::absolute(script_path).string();

  // prepare injection configuration
  w1::inject::config cfg;
  cfg.library_path = found_lib_path;
  cfg.injection_method = w1::inject::method::preload; // preload injection
  cfg.binary_path = binary_path;
  cfg.args = binary_args;
  cfg.suspended = suspended;
  cfg.wait_for_completion = true;

  // set POISON_CURE environment variable for p01s0n
  cfg.env_vars["POISON_CURE"] = abs_script_path;

  // set POISON_VERBOSE environment variable for p01s0n verbosity
  if (verbosity_level > 0) {
    cfg.env_vars["POISON_VERBOSE"] = std::to_string(verbosity_level);
  }

  log.inf(
      "injection configuration", redlog::field("library", found_lib_path), redlog::field("binary", binary_path),
      redlog::field("args_count", binary_args.size()), redlog::field("cure_script", abs_script_path)
  );

  // check platform support
  const std::string platform = w1::common::platform_utils::get_platform_name();
  if (!w1::common::platform_utils::supports_runtime_injection()) {
    log.warn("runtime injection may not be supported", redlog::field("platform", platform));
  }

  // perform injection
  auto result = w1::inject::inject(cfg);

  if (result.success()) {
    log.inf("p01s0n injection completed successfully", redlog::field("target_pid", result.target_pid));

    std::cout << "p01s0n injection successful" << std::endl;
    if (result.target_pid > 0) {
      std::cout << "target process pid: " << result.target_pid << std::endl;
    }

    return 0;
  } else {
    log.err("p01s0n injection failed", redlog::field("error", result.error_message));
    std::cerr << "error: injection failed: " << result.error_message << std::endl;
    return 1;
  }
}

int poison_pid(
    const std::string& script_path, int target_pid, const std::string& executable_path, int verbosity_level
) {
  auto log = redlog::get_logger("p1llx.poison");

  log.inf(
      "starting p01s0n runtime injection by pid", redlog::field("script", script_path), redlog::field("pid", target_pid)
  );

  // validate script file exists
  if (!std::filesystem::exists(script_path)) {
    log.err("cure script file does not exist", redlog::field("path", script_path));
    std::cerr << "error: cure script not found: " << script_path << std::endl;
    return 1;
  }

  // find p01s0n library
  std::string found_lib_path = find_p01s0n_library(executable_path);
  if (found_lib_path.empty()) {
    return 1;
  }

  log.inf("found p01s0n library", redlog::field("path", found_lib_path));

  // convert script path to absolute path for environment variable
  std::string abs_script_path = std::filesystem::absolute(script_path).string();

  // prepare injection configuration
  w1::inject::config cfg;
  cfg.library_path = found_lib_path;
  cfg.injection_method = w1::inject::method::runtime; // runtime injection
  cfg.pid = target_pid;
  cfg.wait_for_completion = false; // don't wait for runtime injection

  // set POISON_CURE environment variable for p01s0n
  cfg.env_vars["POISON_CURE"] = abs_script_path;

  // set POISON_VERBOSE environment variable for p01s0n verbosity
  if (verbosity_level > 0) {
    cfg.env_vars["POISON_VERBOSE"] = std::to_string(verbosity_level);
  }

  log.inf(
      "runtime injection configuration", redlog::field("library", found_lib_path), redlog::field("pid", target_pid),
      redlog::field("cure_script", abs_script_path)
  );

  // check platform support
  const std::string platform = w1::common::platform_utils::get_platform_name();
  if (!w1::common::platform_utils::supports_runtime_injection()) {
    log.warn("runtime injection may not be supported", redlog::field("platform", platform));
  }

  // perform injection
  auto result = w1::inject::inject(cfg);

  if (result.success()) {
    log.inf("p01s0n runtime injection completed successfully", redlog::field("target_pid", result.target_pid));
    std::cout << "p01s0n runtime injection successful" << std::endl;
    if (result.target_pid > 0) {
      std::cout << "target process pid: " << result.target_pid << std::endl;
    }
    return 0;
  } else {
    log.err("p01s0n runtime injection failed", redlog::field("error", result.error_message));
    std::cerr << "error: injection failed: " << result.error_message << std::endl;
    return 1;
  }
}

int poison_process_name(
    const std::string& script_path, const std::string& process_name, const std::string& executable_path,
    int verbosity_level
) {
  auto log = redlog::get_logger("p1llx.poison");

  log.inf(
      "starting p01s0n runtime injection by process name", redlog::field("script", script_path),
      redlog::field("process_name", process_name)
  );

  // validate script file exists
  if (!std::filesystem::exists(script_path)) {
    log.err("cure script file does not exist", redlog::field("path", script_path));
    std::cerr << "error: cure script not found: " << script_path << std::endl;
    return 1;
  }

  // find p01s0n library
  std::string found_lib_path = find_p01s0n_library(executable_path);
  if (found_lib_path.empty()) {
    return 1;
  }

  log.inf("found p01s0n library", redlog::field("path", found_lib_path));

  // convert script path to absolute path for environment variable
  std::string abs_script_path = std::filesystem::absolute(script_path).string();

  // prepare injection configuration
  w1::inject::config cfg;
  cfg.library_path = found_lib_path;
  cfg.injection_method = w1::inject::method::runtime; // runtime injection
  cfg.process_name = process_name;
  cfg.wait_for_completion = false; // don't wait for runtime injection

  // set POISON_CURE environment variable for p01s0n
  cfg.env_vars["POISON_CURE"] = abs_script_path;

  // set POISON_VERBOSE environment variable for p01s0n verbosity
  if (verbosity_level > 0) {
    cfg.env_vars["POISON_VERBOSE"] = std::to_string(verbosity_level);
  }

  log.inf(
      "runtime injection configuration", redlog::field("library", found_lib_path),
      redlog::field("process_name", process_name), redlog::field("cure_script", abs_script_path)
  );

  // check platform support
  const std::string platform = w1::common::platform_utils::get_platform_name();
  if (!w1::common::platform_utils::supports_runtime_injection()) {
    log.warn("runtime injection may not be supported", redlog::field("platform", platform));
  }

  // perform injection
  auto result = w1::inject::inject(cfg);

  if (result.success()) {
    log.inf("p01s0n runtime injection completed successfully", redlog::field("target_pid", result.target_pid));
    std::cout << "p01s0n runtime injection successful" << std::endl;
    if (result.target_pid > 0) {
      std::cout << "target process pid: " << result.target_pid << std::endl;
    }
    return 0;
  } else {
    log.err("p01s0n runtime injection failed", redlog::field("error", result.error_message));
    std::cerr << "error: injection failed: " << result.error_message << std::endl;
    return 1;
  }
}

} // namespace p1llx::commands
```

`src/p1llx/commands/poison.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>

namespace p1llx::commands {

/**
 * @brief Inject p01s0n library into target process for dynamic patching (spawn method)
 *
 * Uses preload injection to load p01s0n.so/dylib/dll into the target process.
 * The POISON_CURE environment variable specifies which cure script to apply.
 *
 * @param script_path Path to lua cure script (sets POISON_CURE env var)
 * @param binary_path Path to target binary to launch and inject
 * @param binary_args Arguments to pass to target binary
 * @param suspended Whether to start target in suspended mode
 * @param executable_path Path to p1llx executable for library discovery
 * @param verbosity_level Verbosity level to pass to p01s0n (0-3)
 * @return 0 for success, 1 for failure
 */
int poison_spawn(
    const std::string& script_path, const std::string& binary_path, const std::vector<std::string>& binary_args = {},
    bool suspended = false, const std::string& executable_path = "", int verbosity_level = 0
);

/**
 * @brief Inject p01s0n library into existing process by PID (runtime method)
 *
 * Uses runtime injection to load p01s0n.so/dylib/dll into an existing process.
 * The POISON_CURE environment variable specifies which cure script to apply.
 *
 * @param script_path Path to lua cure script (sets POISON_CURE env var)
 * @param target_pid Process ID of target process
 * @param executable_path Path to p1llx executable for library discovery
 * @param verbosity_level Verbosity level to pass to p01s0n (0-3)
 * @return 0 for success, 1 for failure
 */
int poison_pid(
    const std::string& script_path, int target_pid, const std::string& executable_path = "", int verbosity_level = 0
);

/**
 * @brief Inject p01s0n library into existing process by name (runtime method)
 *
 * Uses runtime injection to load p01s0n.so/dylib/dll into an existing process.
 * The POISON_CURE environment variable specifies which cure script to apply.
 *
 * @param script_path Path to lua cure script (sets POISON_CURE env var)
 * @param process_name Name of target process
 * @param executable_path Path to p1llx executable for library discovery
 * @param verbosity_level Verbosity level to pass to p01s0n (0-3)
 * @return 0 for success, 1 for failure
 */
int poison_process_name(
    const std::string& script_path, const std::string& process_name, const std::string& executable_path = "",
    int verbosity_level = 0
);

} // namespace p1llx::commands
```

`src/p1llx/commands/sig.cpp`:

```cpp
#include "sig.hpp"

#include <iostream>
#include <span>

#include <redlog.hpp>

#include "p1ll/engine/session.hpp"
#include "p1ll/utils/file_utils.hpp"
#include "p1ll/utils/hex_utils.hpp"

namespace p1llx::commands {

int sig_command(const sig_request& request) {
  auto log = redlog::get_logger("p1llx.sig");

  if (request.pattern.empty()) {
    log.err("signature pattern required");
    std::cerr << "error: signature pattern is required" << std::endl;
    return 1;
  }

  if (request.input_file.empty()) {
    log.err("input file required");
    std::cerr << "error: input file is required" << std::endl;
    return 1;
  }

  auto file_data = p1ll::utils::read_file(request.input_file);
  if (!file_data.has_value()) {
    log.err("failed to read input file", redlog::field("path", request.input_file));
    std::cerr << "error: could not read input file: " << request.input_file << std::endl;
    return 1;
  }

  auto session = p1ll::engine::session::for_buffer(std::span<uint8_t>(*file_data));
  p1ll::engine::scan_options options;
  options.single = request.single;

  auto results = session.scan(request.pattern, options);
  if (!results.ok()) {
    log.err("signature scan failed", redlog::field("error", results.status_info.message));
    std::cerr << "error: " << results.status_info.message << std::endl;
    return 1;
  }

  if (results.value.empty()) {
    log.err("signature not found", redlog::field("pattern", request.pattern));
    std::cerr << "error: signature not found" << std::endl;
    return 1;
  }

  std::cout << "matches: " << results.value.size() << std::endl;
  for (const auto& match : results.value) {
    std::cout << p1ll::utils::format_address(match.address);
    if (!match.region_name.empty()) {
      std::cout << " " << match.region_name;
    }
    std::cout << "\n";
  }

  return 0;
}

} // namespace p1llx::commands

```

`src/p1llx/commands/sig.hpp`:

```hpp
#pragma once

#include <string>

namespace p1llx::commands {

struct sig_request {
  std::string pattern;
  std::string input_file;
  bool single = false;
};

int sig_command(const sig_request& request);

} // namespace p1llx::commands

```

`src/p1llx/main.cpp`:

```cpp
#ifdef WITNESS_ASMR_ENABLED
#include "commands/asm.hpp"
#include "commands/disasm.hpp"
#endif
#include "commands/cure.hpp"
#include "commands/patch.hpp"
#include "commands/poison.hpp"
#include "commands/sig.hpp"
#include <cstdint>
#include <w1base/ext/args.hpp>
#include <redlog.hpp>
#include <w1base/cli/verbosity.hpp>
#include <string>

// global executable path for library discovery (like w1tool)
namespace {
std::string g_executable_path;

#ifdef WITNESS_ASMR_ENABLED
bool parse_address_value(const std::string& value, uint64_t& out) {
  try {
    size_t idx = 0;
    unsigned long long parsed = std::stoull(value, &idx, 0);
    if (idx != value.size()) {
      return false;
    }
    out = static_cast<uint64_t>(parsed);
    return true;
  } catch (const std::exception&) {
    return false;
  }
}
#endif
} // namespace

// following w1tool patterns exactly
namespace cli {
args::Group arguments("arguments");
args::HelpFlag help_flag(arguments, "help", "help", {'h', "help"});
args::CounterFlag verbosity_flag(arguments, "verbosity", "verbosity level", {'v'});

void apply_verbosity() { w1::cli::apply_verbosity(args::get(verbosity_flag)); }
} // namespace cli

// command functions following w1tool pattern
int cmd_cure(
    args::ValueFlag<std::string>& script_flag, args::ValueFlag<std::string>& input_flag,
    args::ValueFlag<std::string>& output_flag, args::ValueFlag<std::string>& platform_flag
) {
  auto log = redlog::get_logger("p1llx.cure");
  cli::apply_verbosity();

  // validate required arguments
  if (!script_flag) {
    log.err("cure script required");
    std::cerr << "error: cure script (-c/--cure) is required" << std::endl;
    return 1;
  }

  if (!input_flag) {
    log.err("input file required");
    std::cerr << "error: input file (-i/--input) is required" << std::endl;
    return 1;
  }

  // default output to input if not specified
  std::string output_file = output_flag ? *output_flag : *input_flag;

  // get platform override if specified
  std::string platform_override = platform_flag ? *platform_flag : "";

  return p1llx::commands::cure(*script_flag, *input_flag, output_file, platform_override);
}

int cmd_patch(
    args::ValueFlag<std::string>& sig_flag, args::ValueFlag<std::string>& address_flag,
    args::ValueFlag<std::string>& offset_flag, args::ValueFlag<std::string>& replace_flag,
    args::ValueFlag<std::string>& input_flag, args::ValueFlag<std::string>& output_flag,
    args::ValueFlag<std::string>& platform_flag
) {
  auto log = redlog::get_logger("p1llx.patch");
  cli::apply_verbosity();

  // validate required arguments
  if (!replace_flag || !input_flag) {
    log.err("replace data and input file required");
    std::cerr << "error: replace data (--replace) and input file (-i/--input) are required" << std::endl;
    return 1;
  }

  bool has_sig = sig_flag;
  bool has_address = address_flag;
  if (has_sig == has_address) {
    log.err("either signature or address required");
    std::cerr << "error: specify exactly one of --sig or --address" << std::endl;
    return 1;
  }

  // default output to input if not specified
  std::string output_file = output_flag ? *output_flag : *input_flag;

  if (has_sig) {
    std::string offset_value = offset_flag ? *offset_flag : "";
    std::string platform_override = platform_flag ? *platform_flag : "";
    return p1llx::commands::patch_signature(
        *sig_flag, offset_value, *replace_flag, *input_flag, output_file, platform_override
    );
  }

  return p1llx::commands::patch(*address_flag, *replace_flag, *input_flag, output_file);
}

int cmd_sig(
    args::Positional<std::string>& pattern_flag, args::ValueFlag<std::string>& input_flag, args::Flag& single_flag
) {
  auto log = redlog::get_logger("p1llx.sig");
  cli::apply_verbosity();

  if (!pattern_flag) {
    log.err("signature pattern required");
    std::cerr << "error: signature pattern is required" << std::endl;
    return 1;
  }

  if (!input_flag) {
    log.err("input file required");
    std::cerr << "error: input file (-i/--input) is required" << std::endl;
    return 1;
  }

  p1llx::commands::sig_request request;
  request.pattern = args::get(pattern_flag);
  request.input_file = args::get(input_flag);
  request.single = single_flag;

  return p1llx::commands::sig_command(request);
}

#ifdef WITNESS_ASMR_ENABLED
int cmd_asm(
    args::Positional<std::string>& assembly_flag, args::ValueFlag<std::string>& arch_flag,
    args::ValueFlag<std::string>& address_flag
) {
  auto log = redlog::get_logger("p1llx.asm");
  cli::apply_verbosity();

  if (!assembly_flag) {
    log.err("assembly text required");
    std::cerr << "error: assembly text is required" << std::endl;
    return 1;
  }

  p1llx::commands::asm_request request;
  request.text = args::get(assembly_flag);
  if (arch_flag) {
    request.arch = args::get(arch_flag);
  }
  if (address_flag) {
    uint64_t parsed = 0;
    if (!parse_address_value(args::get(address_flag), parsed)) {
      std::cerr << "error: invalid address value" << std::endl;
      return 1;
    }
    request.address = parsed;
    request.has_address = true;
  }

  return p1llx::commands::asm_command(request);
}

int cmd_disasm(
    args::Positional<std::string>& bytes_flag, args::ValueFlag<std::string>& arch_flag,
    args::ValueFlag<std::string>& address_flag
) {
  auto log = redlog::get_logger("p1llx.disasm");
  cli::apply_verbosity();

  if (!bytes_flag) {
    log.err("hex bytes required");
    std::cerr << "error: hex bytes are required" << std::endl;
    return 1;
  }

  p1llx::commands::disasm_request request;
  request.bytes = args::get(bytes_flag);
  if (arch_flag) {
    request.arch = args::get(arch_flag);
  }
  if (address_flag) {
    uint64_t parsed = 0;
    if (!parse_address_value(args::get(address_flag), parsed)) {
      std::cerr << "error: invalid address value" << std::endl;
      return 1;
    }
    request.address = parsed;
    request.has_address = true;
  }

  return p1llx::commands::disasm_command(request);
}
#endif

int cmd_poison(
    args::ValueFlag<std::string>& script_flag, args::Flag& spawn_flag, args::ValueFlag<int>& pid_flag,
    args::ValueFlag<std::string>& process_name_flag, args::Flag& suspended_flag,
    args::PositionalList<std::string>& args_list
) {
  auto log = redlog::get_logger("p1llx.poison");
  cli::apply_verbosity();

  // validate required arguments
  if (!script_flag) {
    log.err("cure script required");
    std::cerr << "error: cure script (-c/--cure) is required" << std::endl;
    return 1;
  }

  // validate target specification
  int target_count = 0;
  if (spawn_flag) {
    target_count++;
  }
  if (pid_flag) {
    target_count++;
  }
  if (process_name_flag) {
    target_count++;
  }

  if (target_count != 1) {
    log.err("exactly one target required: specify -s/--spawn, --pid, or --process-name");
    std::cerr << "error: exactly one target required: specify -s/--spawn, --pid, or --process-name" << std::endl;
    return 1;
  }

  // validate suspended flag usage
  if (suspended_flag && !spawn_flag) {
    log.err("--suspended can only be used with -s/--spawn");
    std::cerr << "error: --suspended can only be used with -s/--spawn" << std::endl;
    return 1;
  }

  int verbosity_level = args::get(cli::verbosity_flag);

  // determine target method and call appropriate poison function
  if (spawn_flag) {
    // spawn injection with positional arguments
    if (args_list.Get().empty()) {
      log.err("binary path required when using -s/--spawn flag");
      std::cerr << "error: binary path required when using -s/--spawn flag" << std::endl;
      return 1;
    }

    std::vector<std::string> all_args = args::get(args_list);
    std::string binary_path = all_args[0];

    // extract arguments after the binary (everything after first arg)
    std::vector<std::string> binary_args;
    if (all_args.size() > 1) {
      binary_args.assign(all_args.begin() + 1, all_args.end());
    }

    return p1llx::commands::poison_spawn(
        *script_flag, binary_path, binary_args, suspended_flag, g_executable_path, verbosity_level
    );

  } else if (pid_flag) {
    // runtime injection by pid
    return p1llx::commands::poison_pid(*script_flag, args::get(pid_flag), g_executable_path, verbosity_level);

  } else if (process_name_flag) {
    // runtime injection by process name
    return p1llx::commands::poison_process_name(
        *script_flag, args::get(process_name_flag), g_executable_path, verbosity_level
    );

  } else {
    log.err("target required: specify -s/--spawn, --pid, or --process-name");
    std::cerr << "error: target required: specify -s/--spawn, --pid, or --process-name" << std::endl;
    return 1;
  }
}

int main(int argc, char* argv[]) {
  // store executable path for library auto-discovery (like w1tool)
  g_executable_path = argv[0];

  // argument parser following w1tool style
  args::ArgumentParser parser("p1llx - static binary patcher");
  parser.helpParams.showTerminator = false;

  // global flags
  parser.Add(cli::arguments);

  // cure command
  args::Command cure_cmd(parser, "cure", "apply auto-cure lua script to file");
  args::ValueFlag<std::string> cure_script_flag(cure_cmd, "script", "lua cure script path", {'c', "cure"});
  args::ValueFlag<std::string> cure_input_flag(cure_cmd, "input", "input file path", {'i', "input"});
  args::ValueFlag<std::string> cure_output_flag(
      cure_cmd, "output", "output file path (default: overwrite input)", {'o', "output"}
  );
  args::ValueFlag<std::string> cure_platform_flag(
      cure_cmd, "platform", "platform override (e.g., linux:x64, darwin:arm64)", {'p', "platform"}
  );

  // patch command
  args::Command patch_cmd(parser, "patch", "signature or address patching");
  args::ValueFlag<std::string> patch_sig_flag(patch_cmd, "signature", "signature hex pattern", {"sig"});
  args::ValueFlag<std::string> patch_address_flag(patch_cmd, "address", "address to patch (hex)", {"address"});
  args::ValueFlag<std::string> patch_offset_flag(
      patch_cmd, "offset", "offset from signature match (hex or decimal)", {"offset"}
  );
  args::ValueFlag<std::string> patch_replace_flag(patch_cmd, "replace", "replacement hex bytes", {"replace"});
  args::ValueFlag<std::string> patch_input_flag(patch_cmd, "input", "input file path", {'i', "input"});
  args::ValueFlag<std::string> patch_output_flag(
      patch_cmd, "output", "output file path (default: overwrite input)", {'o', "output"}
  );
  args::ValueFlag<std::string> patch_platform_flag(
      patch_cmd, "platform", "platform override (e.g., linux:x64, darwin:arm64)", {'p', "platform"}
  );

  // sig command
  args::Command sig_cmd(parser, "sig", "search for a signature in a file");
  args::Positional<std::string> sig_pattern_flag(sig_cmd, "pattern", "signature hex pattern");
  args::ValueFlag<std::string> sig_input_flag(sig_cmd, "input", "input file path", {'i', "input"});
  args::Flag sig_single_flag(sig_cmd, "single", "require exactly one match", {"single"});

#ifdef WITNESS_ASMR_ENABLED
  // asm/disasm commands
  args::Command asm_cmd(parser, "asm", "assemble instruction text");
  args::Positional<std::string> asm_text_flag(asm_cmd, "assembly", "assembly string");
  args::ValueFlag<std::string> asm_arch_flag(asm_cmd, "arch", "architecture (e.g., x86, x64, arm64)", {"arch"});
  args::ValueFlag<std::string> asm_address_flag(asm_cmd, "address", "base address (hex or decimal)", {"address"});

  args::Command disasm_cmd(parser, "disasm", "disassemble hex bytes");
  args::Positional<std::string> disasm_bytes_flag(disasm_cmd, "bytes", "hex bytes");
  args::ValueFlag<std::string> disasm_arch_flag(disasm_cmd, "arch", "architecture (e.g., x86, x64, arm64)", {"arch"});
  args::ValueFlag<std::string> disasm_address_flag(disasm_cmd, "address", "base address (hex or decimal)", {"address"});
#endif

  // poison command
  args::Command poison_cmd(parser, "poison", "inject p01s0n for dynamic patching");
  args::ValueFlag<std::string> poison_script_flag(poison_cmd, "script", "lua cure script path", {'c', "cure"});
  args::Flag poison_spawn_flag(poison_cmd, "spawn", "spawn target binary with p01s0n injection", {'s', "spawn"});
  args::ValueFlag<int> poison_pid_flag(poison_cmd, "pid", "inject into existing process by pid", {'p', "pid"});
  args::ValueFlag<std::string> poison_process_name_flag(
      poison_cmd, "process-name", "inject into existing process by name", {'n', "process-name"}
  );
  args::Flag poison_suspended_flag(poison_cmd, "suspended", "start target in suspended mode", {"suspended"});
  args::PositionalList<std::string> poison_args_list(
      poison_cmd, "args", "target binary and arguments (use -- to separate)"
  );

  try {
    parser.ParseCLI(argc, argv);

    if (cure_cmd) {
      return cmd_cure(cure_script_flag, cure_input_flag, cure_output_flag, cure_platform_flag);
    } else if (patch_cmd) {
      return cmd_patch(
          patch_sig_flag, patch_address_flag, patch_offset_flag, patch_replace_flag, patch_input_flag,
          patch_output_flag, patch_platform_flag
      );
    } else if (sig_cmd) {
      return cmd_sig(sig_pattern_flag, sig_input_flag, sig_single_flag);
#ifdef WITNESS_ASMR_ENABLED
    } else if (asm_cmd) {
      return cmd_asm(asm_text_flag, asm_arch_flag, asm_address_flag);
    } else if (disasm_cmd) {
      return cmd_disasm(disasm_bytes_flag, disasm_arch_flag, disasm_address_flag);
#endif
    } else if (poison_cmd) {
      return cmd_poison(
          poison_script_flag, poison_spawn_flag, poison_pid_flag, poison_process_name_flag, poison_suspended_flag,
          poison_args_list
      );
    } else {
      std::cerr << "error: no command specified" << std::endl;
      std::cerr << parser;
      return 1;
    }

  } catch (const args::Help&) {
    std::cout << parser;
    return 0;
  } catch (const args::ParseError& e) {
    std::cerr << e.what() << std::endl;
    std::cerr << parser;
    return 1;
  } catch (const args::ValidationError& e) {
    std::cerr << e.what() << std::endl;
    std::cerr << parser;
    return 1;
  }

  return 0;
}

```

`src/third_party/doctest/doctest.hpp`:

```hpp
// ====================================================================== lgtm [cpp/missing-header-guard]
// == DO NOT MODIFY THIS FILE BY HAND - IT IS AUTO GENERATED BY CMAKE! ==
// ======================================================================
//
// doctest.h - the lightest feature-rich C++ single-header testing framework for unit tests and TDD
//
// Copyright (c) 2016-2023 Viktor Kirilov
//
// Distributed under the MIT Software License
// See accompanying file LICENSE.txt or copy at
// https://opensource.org/licenses/MIT
//
// The documentation can be found at the library's page:
// https://github.com/doctest/doctest/blob/master/doc/markdown/readme.md
//
// =================================================================================================
// =================================================================================================
// =================================================================================================
//
// The library is heavily influenced by Catch - https://github.com/catchorg/Catch2
// which uses the Boost Software License - Version 1.0
// see here - https://github.com/catchorg/Catch2/blob/master/LICENSE.txt
//
// The concept of subcases (sections in Catch) and expression decomposition are from there.
// Some parts of the code are taken directly:
// - stringification - the detection of "ostream& operator<<(ostream&, const T&)" and StringMaker<>
// - the Approx() helper class for floating point comparison
// - colors in the console
// - breaking into a debugger
// - signal / SEH handling
// - timer
// - XmlWriter class - thanks to Phil Nash for allowing the direct reuse (AKA copy/paste)
//
// The expression decomposing templates are taken from lest - https://github.com/martinmoene/lest
// which uses the Boost Software License - Version 1.0
// see here - https://github.com/martinmoene/lest/blob/master/LICENSE.txt
//
// =================================================================================================
// =================================================================================================
// =================================================================================================

#ifndef DOCTEST_LIBRARY_INCLUDED
#define DOCTEST_LIBRARY_INCLUDED

// =================================================================================================
// == VERSION ======================================================================================
// =================================================================================================

#define DOCTEST_VERSION_MAJOR 2
#define DOCTEST_VERSION_MINOR 4
#define DOCTEST_VERSION_PATCH 12

// util we need here
#define DOCTEST_TOSTR_IMPL(x) #x
#define DOCTEST_TOSTR(x) DOCTEST_TOSTR_IMPL(x)

#define DOCTEST_VERSION_STR                                                                        \
    DOCTEST_TOSTR(DOCTEST_VERSION_MAJOR) "."                                                       \
    DOCTEST_TOSTR(DOCTEST_VERSION_MINOR) "."                                                       \
    DOCTEST_TOSTR(DOCTEST_VERSION_PATCH)

#define DOCTEST_VERSION                                                                            \
    (DOCTEST_VERSION_MAJOR * 10000 + DOCTEST_VERSION_MINOR * 100 + DOCTEST_VERSION_PATCH)

// =================================================================================================
// == COMPILER VERSION =============================================================================
// =================================================================================================

// ideas for the version stuff are taken from here: https://github.com/cxxstuff/cxx_detect

#ifdef _MSC_VER
#define DOCTEST_CPLUSPLUS _MSVC_LANG
#else
#define DOCTEST_CPLUSPLUS __cplusplus
#endif

#define DOCTEST_COMPILER(MAJOR, MINOR, PATCH) ((MAJOR)*10000000 + (MINOR)*100000 + (PATCH))

// GCC/Clang and GCC/MSVC are mutually exclusive, but Clang/MSVC are not because of clang-cl...
#if defined(_MSC_VER) && defined(_MSC_FULL_VER)
#if _MSC_VER == _MSC_FULL_VER / 10000
#define DOCTEST_MSVC DOCTEST_COMPILER(_MSC_VER / 100, _MSC_VER % 100, _MSC_FULL_VER % 10000)
#else // MSVC
#define DOCTEST_MSVC                                                                               \
    DOCTEST_COMPILER(_MSC_VER / 100, (_MSC_FULL_VER / 100000) % 100, _MSC_FULL_VER % 100000)
#endif // MSVC
#endif // MSVC
#if defined(__clang__) && defined(__clang_minor__) && defined(__clang_patchlevel__)
#define DOCTEST_CLANG DOCTEST_COMPILER(__clang_major__, __clang_minor__, __clang_patchlevel__)
#elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__) &&              \
        !defined(__INTEL_COMPILER)
#define DOCTEST_GCC DOCTEST_COMPILER(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
#endif // GCC
#if defined(__INTEL_COMPILER)
#define DOCTEST_ICC DOCTEST_COMPILER(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)
#endif // ICC

#ifndef DOCTEST_MSVC
#define DOCTEST_MSVC 0
#endif // DOCTEST_MSVC
#ifndef DOCTEST_CLANG
#define DOCTEST_CLANG 0
#endif // DOCTEST_CLANG
#ifndef DOCTEST_GCC
#define DOCTEST_GCC 0
#endif // DOCTEST_GCC
#ifndef DOCTEST_ICC
#define DOCTEST_ICC 0
#endif // DOCTEST_ICC

// =================================================================================================
// == COMPILER WARNINGS HELPERS ====================================================================
// =================================================================================================

#if DOCTEST_CLANG && !DOCTEST_ICC
#define DOCTEST_PRAGMA_TO_STR(x) _Pragma(#x)
#define DOCTEST_CLANG_SUPPRESS_WARNING_PUSH _Pragma("clang diagnostic push")
#define DOCTEST_CLANG_SUPPRESS_WARNING(w) DOCTEST_PRAGMA_TO_STR(clang diagnostic ignored w)
#define DOCTEST_CLANG_SUPPRESS_WARNING_POP _Pragma("clang diagnostic pop")
#define DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(w)                                                \
    DOCTEST_CLANG_SUPPRESS_WARNING_PUSH DOCTEST_CLANG_SUPPRESS_WARNING(w)
#else // DOCTEST_CLANG
#define DOCTEST_CLANG_SUPPRESS_WARNING_PUSH
#define DOCTEST_CLANG_SUPPRESS_WARNING(w)
#define DOCTEST_CLANG_SUPPRESS_WARNING_POP
#define DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(w)
#endif // DOCTEST_CLANG

#if DOCTEST_GCC
#define DOCTEST_PRAGMA_TO_STR(x) _Pragma(#x)
#define DOCTEST_GCC_SUPPRESS_WARNING_PUSH _Pragma("GCC diagnostic push")
#define DOCTEST_GCC_SUPPRESS_WARNING(w) DOCTEST_PRAGMA_TO_STR(GCC diagnostic ignored w)
#define DOCTEST_GCC_SUPPRESS_WARNING_POP _Pragma("GCC diagnostic pop")
#define DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(w)                                                  \
    DOCTEST_GCC_SUPPRESS_WARNING_PUSH DOCTEST_GCC_SUPPRESS_WARNING(w)
#else // DOCTEST_GCC
#define DOCTEST_GCC_SUPPRESS_WARNING_PUSH
#define DOCTEST_GCC_SUPPRESS_WARNING(w)
#define DOCTEST_GCC_SUPPRESS_WARNING_POP
#define DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(w)
#endif // DOCTEST_GCC

#if DOCTEST_MSVC
#define DOCTEST_MSVC_SUPPRESS_WARNING_PUSH __pragma(warning(push))
#define DOCTEST_MSVC_SUPPRESS_WARNING(w) __pragma(warning(disable : w))
#define DOCTEST_MSVC_SUPPRESS_WARNING_POP __pragma(warning(pop))
#define DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(w)                                                 \
    DOCTEST_MSVC_SUPPRESS_WARNING_PUSH DOCTEST_MSVC_SUPPRESS_WARNING(w)
#else // DOCTEST_MSVC
#define DOCTEST_MSVC_SUPPRESS_WARNING_PUSH
#define DOCTEST_MSVC_SUPPRESS_WARNING(w)
#define DOCTEST_MSVC_SUPPRESS_WARNING_POP
#define DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(w)
#endif // DOCTEST_MSVC

// =================================================================================================
// == COMPILER WARNINGS ============================================================================
// =================================================================================================

// both the header and the implementation suppress all of these,
// so it only makes sense to aggregate them like so
#define DOCTEST_SUPPRESS_COMMON_WARNINGS_PUSH                                                      \
    DOCTEST_CLANG_SUPPRESS_WARNING_PUSH                                                            \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wunknown-pragmas")                                            \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wweak-vtables")                                               \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wpadded")                                                     \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-prototypes")                                         \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wc++98-compat")                                               \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wc++98-compat-pedantic")                                      \
                                                                                                   \
    DOCTEST_GCC_SUPPRESS_WARNING_PUSH                                                              \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wunknown-pragmas")                                              \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wpragmas")                                                      \
    DOCTEST_GCC_SUPPRESS_WARNING("-Weffc++")                                                       \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wstrict-overflow")                                              \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wstrict-aliasing")                                              \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wmissing-declarations")                                         \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wuseless-cast")                                                 \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wnoexcept")                                                     \
                                                                                                   \
    DOCTEST_MSVC_SUPPRESS_WARNING_PUSH                                                             \
    /* these 4 also disabled globally via cmake: */                                                \
    DOCTEST_MSVC_SUPPRESS_WARNING(4514) /* unreferenced inline function has been removed */        \
    DOCTEST_MSVC_SUPPRESS_WARNING(4571) /* SEH related */                                          \
    DOCTEST_MSVC_SUPPRESS_WARNING(4710) /* function not inlined */                                 \
    DOCTEST_MSVC_SUPPRESS_WARNING(4711) /* function selected for inline expansion*/                \
    /* common ones */                                                                              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4616) /* invalid compiler warning */                             \
    DOCTEST_MSVC_SUPPRESS_WARNING(4619) /* invalid compiler warning */                             \
    DOCTEST_MSVC_SUPPRESS_WARNING(4996) /* The compiler encountered a deprecated declaration */    \
    DOCTEST_MSVC_SUPPRESS_WARNING(4706) /* assignment within conditional expression */             \
    DOCTEST_MSVC_SUPPRESS_WARNING(4512) /* 'class' : assignment operator could not be generated */ \
    DOCTEST_MSVC_SUPPRESS_WARNING(4127) /* conditional expression is constant */                   \
    DOCTEST_MSVC_SUPPRESS_WARNING(4820) /* padding */                                              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4625) /* copy constructor was implicitly deleted */              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4626) /* assignment operator was implicitly deleted */           \
    DOCTEST_MSVC_SUPPRESS_WARNING(5027) /* move assignment operator implicitly deleted */          \
    DOCTEST_MSVC_SUPPRESS_WARNING(5026) /* move constructor was implicitly deleted */              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4640) /* construction of local static object not thread-safe */  \
    DOCTEST_MSVC_SUPPRESS_WARNING(5045) /* Spectre mitigation for memory load */                   \
    DOCTEST_MSVC_SUPPRESS_WARNING(5264) /* 'variable-name': 'const' variable is not used */        \
    /* static analysis */                                                                          \
    DOCTEST_MSVC_SUPPRESS_WARNING(26439) /* Function may not throw. Declare it 'noexcept' */       \
    DOCTEST_MSVC_SUPPRESS_WARNING(26495) /* Always initialize a member variable */                 \
    DOCTEST_MSVC_SUPPRESS_WARNING(26451) /* Arithmetic overflow ... */                             \
    DOCTEST_MSVC_SUPPRESS_WARNING(26444) /* Avoid unnamed objects with custom ctor and dtor... */  \
    DOCTEST_MSVC_SUPPRESS_WARNING(26812) /* Prefer 'enum class' over 'enum' */

#define DOCTEST_SUPPRESS_COMMON_WARNINGS_POP                                                       \
    DOCTEST_CLANG_SUPPRESS_WARNING_POP                                                             \
    DOCTEST_GCC_SUPPRESS_WARNING_POP                                                               \
    DOCTEST_MSVC_SUPPRESS_WARNING_POP

DOCTEST_SUPPRESS_COMMON_WARNINGS_PUSH

DOCTEST_CLANG_SUPPRESS_WARNING_PUSH
DOCTEST_CLANG_SUPPRESS_WARNING("-Wnon-virtual-dtor")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wdeprecated")

DOCTEST_GCC_SUPPRESS_WARNING_PUSH
DOCTEST_GCC_SUPPRESS_WARNING("-Wctor-dtor-privacy")
DOCTEST_GCC_SUPPRESS_WARNING("-Wnon-virtual-dtor")
DOCTEST_GCC_SUPPRESS_WARNING("-Wsign-promo")

DOCTEST_MSVC_SUPPRESS_WARNING_PUSH
DOCTEST_MSVC_SUPPRESS_WARNING(4623) // default constructor was implicitly defined as deleted

#define DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN                                 \
    DOCTEST_MSVC_SUPPRESS_WARNING_PUSH                                                             \
    DOCTEST_MSVC_SUPPRESS_WARNING(4548) /* before comma no effect; expected side - effect */       \
    DOCTEST_MSVC_SUPPRESS_WARNING(4265) /* virtual functions, but destructor is not virtual */     \
    DOCTEST_MSVC_SUPPRESS_WARNING(4986) /* exception specification does not match previous */      \
    DOCTEST_MSVC_SUPPRESS_WARNING(4350) /* 'member1' called instead of 'member2' */                \
    DOCTEST_MSVC_SUPPRESS_WARNING(4668) /* not defined as a preprocessor macro */                  \
    DOCTEST_MSVC_SUPPRESS_WARNING(4365) /* signed/unsigned mismatch */                             \
    DOCTEST_MSVC_SUPPRESS_WARNING(4774) /* format string not a string literal */                   \
    DOCTEST_MSVC_SUPPRESS_WARNING(4820) /* padding */                                              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4625) /* copy constructor was implicitly deleted */              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4626) /* assignment operator was implicitly deleted */           \
    DOCTEST_MSVC_SUPPRESS_WARNING(5027) /* move assignment operator implicitly deleted */          \
    DOCTEST_MSVC_SUPPRESS_WARNING(5026) /* move constructor was implicitly deleted */              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4623) /* default constructor was implicitly deleted */           \
    DOCTEST_MSVC_SUPPRESS_WARNING(5039) /* pointer to pot. throwing function passed to extern C */ \
    DOCTEST_MSVC_SUPPRESS_WARNING(5045) /* Spectre mitigation for memory load */                   \
    DOCTEST_MSVC_SUPPRESS_WARNING(5105) /* macro producing 'defined' has undefined behavior */     \
    DOCTEST_MSVC_SUPPRESS_WARNING(4738) /* storing float result in memory, loss of performance */  \
    DOCTEST_MSVC_SUPPRESS_WARNING(5262) /* implicit fall-through */

#define DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END DOCTEST_MSVC_SUPPRESS_WARNING_POP

// =================================================================================================
// == FEATURE DETECTION ============================================================================
// =================================================================================================

// general compiler feature support table: https://en.cppreference.com/w/cpp/compiler_support
// MSVC C++11 feature support table: https://msdn.microsoft.com/en-us/library/hh567368.aspx
// GCC C++11 feature support table: https://gcc.gnu.org/projects/cxx-status.html
// MSVC version table:
// https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B#Internal_version_numbering
// MSVC++ 14.3 (17) _MSC_VER == 1930 (Visual Studio 2022)
// MSVC++ 14.2 (16) _MSC_VER == 1920 (Visual Studio 2019)
// MSVC++ 14.1 (15) _MSC_VER == 1910 (Visual Studio 2017)
// MSVC++ 14.0      _MSC_VER == 1900 (Visual Studio 2015)
// MSVC++ 12.0      _MSC_VER == 1800 (Visual Studio 2013)
// MSVC++ 11.0      _MSC_VER == 1700 (Visual Studio 2012)
// MSVC++ 10.0      _MSC_VER == 1600 (Visual Studio 2010)
// MSVC++ 9.0       _MSC_VER == 1500 (Visual Studio 2008)
// MSVC++ 8.0       _MSC_VER == 1400 (Visual Studio 2005)

// Universal Windows Platform support
#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
#define DOCTEST_CONFIG_NO_WINDOWS_SEH
#endif // WINAPI_FAMILY
#if DOCTEST_MSVC && !defined(DOCTEST_CONFIG_WINDOWS_SEH)
#define DOCTEST_CONFIG_WINDOWS_SEH
#endif // MSVC
#if defined(DOCTEST_CONFIG_NO_WINDOWS_SEH) && defined(DOCTEST_CONFIG_WINDOWS_SEH)
#undef DOCTEST_CONFIG_WINDOWS_SEH
#endif // DOCTEST_CONFIG_NO_WINDOWS_SEH

#if !defined(_WIN32) && !defined(__QNX__) && !defined(DOCTEST_CONFIG_POSIX_SIGNALS) &&             \
        !defined(__EMSCRIPTEN__) && !defined(__wasi__)
#define DOCTEST_CONFIG_POSIX_SIGNALS
#endif // _WIN32
#if defined(DOCTEST_CONFIG_NO_POSIX_SIGNALS) && defined(DOCTEST_CONFIG_POSIX_SIGNALS)
#undef DOCTEST_CONFIG_POSIX_SIGNALS
#endif // DOCTEST_CONFIG_NO_POSIX_SIGNALS

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
#if !defined(__cpp_exceptions) && !defined(__EXCEPTIONS) && !defined(_CPPUNWIND)                   \
        || defined(__wasi__)
#define DOCTEST_CONFIG_NO_EXCEPTIONS
#endif // no exceptions
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

#ifdef DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS
#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
#define DOCTEST_CONFIG_NO_EXCEPTIONS
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS

#if defined(DOCTEST_CONFIG_NO_EXCEPTIONS) && !defined(DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS)
#define DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS && !DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS

#ifdef __wasi__
#define DOCTEST_CONFIG_NO_MULTITHREADING
#endif

#if defined(DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN) && !defined(DOCTEST_CONFIG_IMPLEMENT)
#define DOCTEST_CONFIG_IMPLEMENT
#endif // DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN

#if defined(_WIN32) || defined(__CYGWIN__)
#if DOCTEST_MSVC
#define DOCTEST_SYMBOL_EXPORT __declspec(dllexport)
#define DOCTEST_SYMBOL_IMPORT __declspec(dllimport)
#else // MSVC
#define DOCTEST_SYMBOL_EXPORT __attribute__((dllexport))
#define DOCTEST_SYMBOL_IMPORT __attribute__((dllimport))
#endif // MSVC
#else  // _WIN32
#define DOCTEST_SYMBOL_EXPORT __attribute__((visibility("default")))
#define DOCTEST_SYMBOL_IMPORT
#endif // _WIN32

#ifdef DOCTEST_CONFIG_IMPLEMENTATION_IN_DLL
#ifdef DOCTEST_CONFIG_IMPLEMENT
#define DOCTEST_INTERFACE DOCTEST_SYMBOL_EXPORT
#else // DOCTEST_CONFIG_IMPLEMENT
#define DOCTEST_INTERFACE DOCTEST_SYMBOL_IMPORT
#endif // DOCTEST_CONFIG_IMPLEMENT
#else  // DOCTEST_CONFIG_IMPLEMENTATION_IN_DLL
#define DOCTEST_INTERFACE
#endif // DOCTEST_CONFIG_IMPLEMENTATION_IN_DLL

// needed for extern template instantiations
// see https://github.com/fmtlib/fmt/issues/2228
#if DOCTEST_MSVC
#define DOCTEST_INTERFACE_DECL
#define DOCTEST_INTERFACE_DEF DOCTEST_INTERFACE
#else // DOCTEST_MSVC
#define DOCTEST_INTERFACE_DECL DOCTEST_INTERFACE
#define DOCTEST_INTERFACE_DEF
#endif // DOCTEST_MSVC

#define DOCTEST_EMPTY

#if DOCTEST_MSVC
#define DOCTEST_NOINLINE __declspec(noinline)
#define DOCTEST_UNUSED
#define DOCTEST_ALIGNMENT(x)
#elif DOCTEST_CLANG && DOCTEST_CLANG < DOCTEST_COMPILER(3, 5, 0)
#define DOCTEST_NOINLINE
#define DOCTEST_UNUSED
#define DOCTEST_ALIGNMENT(x)
#else
#define DOCTEST_NOINLINE __attribute__((noinline))
#define DOCTEST_UNUSED __attribute__((unused))
#define DOCTEST_ALIGNMENT(x) __attribute__((aligned(x)))
#endif

#ifdef DOCTEST_CONFIG_NO_CONTRADICTING_INLINE
#define DOCTEST_INLINE_NOINLINE inline
#else
#define DOCTEST_INLINE_NOINLINE inline DOCTEST_NOINLINE
#endif

#ifndef DOCTEST_NORETURN
#if DOCTEST_MSVC && (DOCTEST_MSVC < DOCTEST_COMPILER(19, 0, 0))
#define DOCTEST_NORETURN
#else // DOCTEST_MSVC
#define DOCTEST_NORETURN [[noreturn]]
#endif // DOCTEST_MSVC
#endif // DOCTEST_NORETURN

#ifndef DOCTEST_NOEXCEPT
#if DOCTEST_MSVC && (DOCTEST_MSVC < DOCTEST_COMPILER(19, 0, 0))
#define DOCTEST_NOEXCEPT
#else // DOCTEST_MSVC
#define DOCTEST_NOEXCEPT noexcept
#endif // DOCTEST_MSVC
#endif // DOCTEST_NOEXCEPT

#ifndef DOCTEST_CONSTEXPR
#if DOCTEST_MSVC && (DOCTEST_MSVC < DOCTEST_COMPILER(19, 0, 0))
#define DOCTEST_CONSTEXPR const
#define DOCTEST_CONSTEXPR_FUNC inline
#else // DOCTEST_MSVC
#define DOCTEST_CONSTEXPR constexpr
#define DOCTEST_CONSTEXPR_FUNC constexpr
#endif // DOCTEST_MSVC
#endif // DOCTEST_CONSTEXPR

#ifndef DOCTEST_NO_SANITIZE_INTEGER
#if DOCTEST_CLANG >= DOCTEST_COMPILER(3, 7, 0)
#define DOCTEST_NO_SANITIZE_INTEGER __attribute__((no_sanitize("integer")))
#else
#define DOCTEST_NO_SANITIZE_INTEGER
#endif
#endif // DOCTEST_NO_SANITIZE_INTEGER

// =================================================================================================
// == FEATURE DETECTION END ========================================================================
// =================================================================================================

#define DOCTEST_DECLARE_INTERFACE(name)                                                            \
    virtual ~name();                                                                               \
    name() = default;                                                                              \
    name(const name&) = delete;                                                                    \
    name(name&&) = delete;                                                                         \
    name& operator=(const name&) = delete;                                                         \
    name& operator=(name&&) = delete;

#define DOCTEST_DEFINE_INTERFACE(name)                                                             \
    name::~name() = default;

// internal macros for string concatenation and anonymous variable name generation
#define DOCTEST_CAT_IMPL(s1, s2) s1##s2
#define DOCTEST_CAT(s1, s2) DOCTEST_CAT_IMPL(s1, s2)
#ifdef __COUNTER__ // not standard and may be missing for some compilers
#define DOCTEST_ANONYMOUS(x) DOCTEST_CAT(x, __COUNTER__)
#else // __COUNTER__
#define DOCTEST_ANONYMOUS(x) DOCTEST_CAT(x, __LINE__)
#endif // __COUNTER__

#ifndef DOCTEST_CONFIG_ASSERTION_PARAMETERS_BY_VALUE
#define DOCTEST_REF_WRAP(x) x&
#else // DOCTEST_CONFIG_ASSERTION_PARAMETERS_BY_VALUE
#define DOCTEST_REF_WRAP(x) x
#endif // DOCTEST_CONFIG_ASSERTION_PARAMETERS_BY_VALUE

// not using __APPLE__ because... this is how Catch does it
#ifdef __MAC_OS_X_VERSION_MIN_REQUIRED
#define DOCTEST_PLATFORM_MAC
#elif defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
#define DOCTEST_PLATFORM_IPHONE
#elif defined(_WIN32)
#define DOCTEST_PLATFORM_WINDOWS
#elif defined(__wasi__)
#define DOCTEST_PLATFORM_WASI
#else // DOCTEST_PLATFORM
#define DOCTEST_PLATFORM_LINUX
#endif // DOCTEST_PLATFORM

namespace doctest { namespace detail {
    static DOCTEST_CONSTEXPR int consume(const int*, int) noexcept { return 0; }
}}

#define DOCTEST_GLOBAL_NO_WARNINGS(var, ...)                                                         \
    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wglobal-constructors")                                \
    static const int var = doctest::detail::consume(&var, __VA_ARGS__);                              \
    DOCTEST_CLANG_SUPPRESS_WARNING_POP

#ifndef DOCTEST_BREAK_INTO_DEBUGGER
// should probably take a look at https://github.com/scottt/debugbreak
#ifdef DOCTEST_PLATFORM_LINUX
#if defined(__GNUC__) && (defined(__i386) || defined(__x86_64))
// Break at the location of the failing check if possible
#define DOCTEST_BREAK_INTO_DEBUGGER() __asm__("int $3\n" : :) // NOLINT(hicpp-no-assembler)
#else
#include <signal.h>
#define DOCTEST_BREAK_INTO_DEBUGGER() raise(SIGTRAP)
#endif
#elif defined(DOCTEST_PLATFORM_MAC)
#if defined(__x86_64) || defined(__x86_64__) || defined(__amd64__) || defined(__i386)
#define DOCTEST_BREAK_INTO_DEBUGGER() __asm__("int $3\n" : :) // NOLINT(hicpp-no-assembler)
#elif defined(__ppc__) || defined(__ppc64__)
// https://www.cocoawithlove.com/2008/03/break-into-debugger.html
#define DOCTEST_BREAK_INTO_DEBUGGER() __asm__("li r0, 20\nsc\nnop\nli r0, 37\nli r4, 2\nsc\nnop\n": : : "memory","r0","r3","r4") // NOLINT(hicpp-no-assembler)
#else
#define DOCTEST_BREAK_INTO_DEBUGGER() __asm__("brk #0"); // NOLINT(hicpp-no-assembler)
#endif
#elif DOCTEST_MSVC
#define DOCTEST_BREAK_INTO_DEBUGGER() __debugbreak()
#elif defined(__MINGW32__)
DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wredundant-decls")
extern "C" __declspec(dllimport) void __stdcall DebugBreak();
DOCTEST_GCC_SUPPRESS_WARNING_POP
#define DOCTEST_BREAK_INTO_DEBUGGER() ::DebugBreak()
#else // linux
#define DOCTEST_BREAK_INTO_DEBUGGER() (static_cast<void>(0))
#endif // linux
#endif // DOCTEST_BREAK_INTO_DEBUGGER

// this is kept here for backwards compatibility since the config option was changed
#ifdef DOCTEST_CONFIG_USE_IOSFWD
#ifndef DOCTEST_CONFIG_USE_STD_HEADERS
#define DOCTEST_CONFIG_USE_STD_HEADERS
#endif
#endif // DOCTEST_CONFIG_USE_IOSFWD

// for clang - always include ciso646 (which drags some std stuff) because
// we want to check if we are using libc++ with the _LIBCPP_VERSION macro in
// which case we don't want to forward declare stuff from std - for reference:
// https://github.com/doctest/doctest/issues/126
// https://github.com/doctest/doctest/issues/356
#if DOCTEST_CLANG
#include <ciso646>
#endif // clang

#ifdef _LIBCPP_VERSION
#ifndef DOCTEST_CONFIG_USE_STD_HEADERS
#define DOCTEST_CONFIG_USE_STD_HEADERS
#endif
#endif // _LIBCPP_VERSION

#ifdef DOCTEST_CONFIG_USE_STD_HEADERS
#ifndef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
#define DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN
#include <cstddef>
#include <ostream>
#include <istream>
DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END
#else // DOCTEST_CONFIG_USE_STD_HEADERS

// Forward declaring 'X' in namespace std is not permitted by the C++ Standard.
DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4643)

namespace std { // NOLINT(cert-dcl58-cpp)
typedef decltype(nullptr) nullptr_t; // NOLINT(modernize-use-using)
typedef decltype(sizeof(void*)) size_t; // NOLINT(modernize-use-using)
template <class charT>
struct char_traits;
template <>
struct char_traits<char>;
template <class charT, class traits>
class basic_ostream; // NOLINT(fuchsia-virtual-inheritance)
typedef basic_ostream<char, char_traits<char>> ostream; // NOLINT(modernize-use-using)
template<class traits>
// NOLINTNEXTLINE
basic_ostream<char, traits>& operator<<(basic_ostream<char, traits>&, const char*);
template <class charT, class traits>
class basic_istream;
typedef basic_istream<char, char_traits<char>> istream; // NOLINT(modernize-use-using)
template <class... Types>
class tuple;
#if DOCTEST_MSVC >= DOCTEST_COMPILER(19, 20, 0)
// see this issue on why this is needed: https://github.com/doctest/doctest/issues/183
template <class Ty>
class allocator;
template <class Elem, class Traits, class Alloc>
class basic_string;
using string = basic_string<char, char_traits<char>, allocator<char>>;
#endif // VS 2019
} // namespace std

DOCTEST_MSVC_SUPPRESS_WARNING_POP

#endif // DOCTEST_CONFIG_USE_STD_HEADERS

#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
#include <type_traits>
#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS

namespace doctest {

using std::size_t;

DOCTEST_INTERFACE extern bool is_running_in_test;

#ifndef DOCTEST_CONFIG_STRING_SIZE_TYPE
#define DOCTEST_CONFIG_STRING_SIZE_TYPE unsigned
#endif

// A 24 byte string class (can be as small as 17 for x64 and 13 for x86) that can hold strings with length
// of up to 23 chars on the stack before going on the heap - the last byte of the buffer is used for:
// - "is small" bit - the highest bit - if "0" then it is small - otherwise its "1" (128)
// - if small - capacity left before going on the heap - using the lowest 5 bits
// - if small - 2 bits are left unused - the second and third highest ones
// - if small - acts as a null terminator if strlen() is 23 (24 including the null terminator)
//              and the "is small" bit remains "0" ("as well as the capacity left") so its OK
// Idea taken from this lecture about the string implementation of facebook/folly - fbstring
// https://www.youtube.com/watch?v=kPR8h4-qZdk
// TODO:
// - optimizations - like not deleting memory unnecessarily in operator= and etc.
// - resize/reserve/clear
// - replace
// - back/front
// - iterator stuff
// - find & friends
// - push_back/pop_back
// - assign/insert/erase
// - relational operators as free functions - taking const char* as one of the params
class DOCTEST_INTERFACE String
{
public:
    using size_type = DOCTEST_CONFIG_STRING_SIZE_TYPE;

private:
    static DOCTEST_CONSTEXPR size_type len  = 24;      //!OCLINT avoid private static members
    static DOCTEST_CONSTEXPR size_type last = len - 1; //!OCLINT avoid private static members

    struct view // len should be more than sizeof(view) - because of the final byte for flags
    {
        char*    ptr;
        size_type size;
        size_type capacity;
    };

    union
    {
        char buf[len]; // NOLINT(*-avoid-c-arrays)
        view data;
    };

    char* allocate(size_type sz);

    bool isOnStack() const noexcept { return (buf[last] & 128) == 0; }
    void setOnHeap() noexcept;
    void setLast(size_type in = last) noexcept;
    void setSize(size_type sz) noexcept;

    void copy(const String& other);

public:
    static DOCTEST_CONSTEXPR size_type npos = static_cast<size_type>(-1);

    String() noexcept;
    ~String();

    // cppcheck-suppress noExplicitConstructor
    String(const char* in);
    String(const char* in, size_type in_size);

    String(std::istream& in, size_type in_size);

    String(const String& other);
    String& operator=(const String& other);

    String& operator+=(const String& other);

    String(String&& other) noexcept;
    String& operator=(String&& other) noexcept;

    char  operator[](size_type i) const;
    char& operator[](size_type i);

    // the only functions I'm willing to leave in the interface - available for inlining
    const char* c_str() const { return const_cast<String*>(this)->c_str(); } // NOLINT
    char*       c_str() {
        if (isOnStack()) {
            return reinterpret_cast<char*>(buf);
        }
        return data.ptr;
    }

    size_type size() const;
    size_type capacity() const;

    String substr(size_type pos, size_type cnt = npos) &&;
    String substr(size_type pos, size_type cnt = npos) const &;

    size_type find(char ch, size_type pos = 0) const;
    size_type rfind(char ch, size_type pos = npos) const;

    int compare(const char* other, bool no_case = false) const;
    int compare(const String& other, bool no_case = false) const;

friend DOCTEST_INTERFACE std::ostream& operator<<(std::ostream& s, const String& in);
};

DOCTEST_INTERFACE String operator+(const String& lhs, const String& rhs);

DOCTEST_INTERFACE bool operator==(const String& lhs, const String& rhs);
DOCTEST_INTERFACE bool operator!=(const String& lhs, const String& rhs);
DOCTEST_INTERFACE bool operator<(const String& lhs, const String& rhs);
DOCTEST_INTERFACE bool operator>(const String& lhs, const String& rhs);
DOCTEST_INTERFACE bool operator<=(const String& lhs, const String& rhs);
DOCTEST_INTERFACE bool operator>=(const String& lhs, const String& rhs);

class DOCTEST_INTERFACE Contains {
public:
    explicit Contains(const String& string);

    bool checkWith(const String& other) const;

    String string;
};

DOCTEST_INTERFACE String toString(const Contains& in);

DOCTEST_INTERFACE bool operator==(const String& lhs, const Contains& rhs);
DOCTEST_INTERFACE bool operator==(const Contains& lhs, const String& rhs);
DOCTEST_INTERFACE bool operator!=(const String& lhs, const Contains& rhs);
DOCTEST_INTERFACE bool operator!=(const Contains& lhs, const String& rhs);

namespace Color {
    enum Enum
    {
        None = 0,
        White,
        Red,
        Green,
        Blue,
        Cyan,
        Yellow,
        Grey,

        Bright = 0x10,

        BrightRed   = Bright | Red,
        BrightGreen = Bright | Green,
        LightGrey   = Bright | Grey,
        BrightWhite = Bright | White
    };

    DOCTEST_INTERFACE std::ostream& operator<<(std::ostream& s, Color::Enum code);
} // namespace Color

namespace assertType {
    enum Enum
    {
        // macro traits

        is_warn    = 1,
        is_check   = 2 * is_warn,
        is_require = 2 * is_check,

        is_normal      = 2 * is_require,
        is_throws      = 2 * is_normal,
        is_throws_as   = 2 * is_throws,
        is_throws_with = 2 * is_throws_as,
        is_nothrow     = 2 * is_throws_with,

        is_false = 2 * is_nothrow,
        is_unary = 2 * is_false, // not checked anywhere - used just to distinguish the types

        is_eq = 2 * is_unary,
        is_ne = 2 * is_eq,

        is_lt = 2 * is_ne,
        is_gt = 2 * is_lt,

        is_ge = 2 * is_gt,
        is_le = 2 * is_ge,

        // macro types

        DT_WARN    = is_normal | is_warn,
        DT_CHECK   = is_normal | is_check,
        DT_REQUIRE = is_normal | is_require,

        DT_WARN_FALSE    = is_normal | is_false | is_warn,
        DT_CHECK_FALSE   = is_normal | is_false | is_check,
        DT_REQUIRE_FALSE = is_normal | is_false | is_require,

        DT_WARN_THROWS    = is_throws | is_warn,
        DT_CHECK_THROWS   = is_throws | is_check,
        DT_REQUIRE_THROWS = is_throws | is_require,

        DT_WARN_THROWS_AS    = is_throws_as | is_warn,
        DT_CHECK_THROWS_AS   = is_throws_as | is_check,
        DT_REQUIRE_THROWS_AS = is_throws_as | is_require,

        DT_WARN_THROWS_WITH    = is_throws_with | is_warn,
        DT_CHECK_THROWS_WITH   = is_throws_with | is_check,
        DT_REQUIRE_THROWS_WITH = is_throws_with | is_require,

        DT_WARN_THROWS_WITH_AS    = is_throws_with | is_throws_as | is_warn,
        DT_CHECK_THROWS_WITH_AS   = is_throws_with | is_throws_as | is_check,
        DT_REQUIRE_THROWS_WITH_AS = is_throws_with | is_throws_as | is_require,

        DT_WARN_NOTHROW    = is_nothrow | is_warn,
        DT_CHECK_NOTHROW   = is_nothrow | is_check,
        DT_REQUIRE_NOTHROW = is_nothrow | is_require,

        DT_WARN_EQ    = is_normal | is_eq | is_warn,
        DT_CHECK_EQ   = is_normal | is_eq | is_check,
        DT_REQUIRE_EQ = is_normal | is_eq | is_require,

        DT_WARN_NE    = is_normal | is_ne | is_warn,
        DT_CHECK_NE   = is_normal | is_ne | is_check,
        DT_REQUIRE_NE = is_normal | is_ne | is_require,

        DT_WARN_GT    = is_normal | is_gt | is_warn,
        DT_CHECK_GT   = is_normal | is_gt | is_check,
        DT_REQUIRE_GT = is_normal | is_gt | is_require,

        DT_WARN_LT    = is_normal | is_lt | is_warn,
        DT_CHECK_LT   = is_normal | is_lt | is_check,
        DT_REQUIRE_LT = is_normal | is_lt | is_require,

        DT_WARN_GE    = is_normal | is_ge | is_warn,
        DT_CHECK_GE   = is_normal | is_ge | is_check,
        DT_REQUIRE_GE = is_normal | is_ge | is_require,

        DT_WARN_LE    = is_normal | is_le | is_warn,
        DT_CHECK_LE   = is_normal | is_le | is_check,
        DT_REQUIRE_LE = is_normal | is_le | is_require,

        DT_WARN_UNARY    = is_normal | is_unary | is_warn,
        DT_CHECK_UNARY   = is_normal | is_unary | is_check,
        DT_REQUIRE_UNARY = is_normal | is_unary | is_require,

        DT_WARN_UNARY_FALSE    = is_normal | is_false | is_unary | is_warn,
        DT_CHECK_UNARY_FALSE   = is_normal | is_false | is_unary | is_check,
        DT_REQUIRE_UNARY_FALSE = is_normal | is_false | is_unary | is_require,
    };
} // namespace assertType

DOCTEST_INTERFACE const char* assertString(assertType::Enum at);
DOCTEST_INTERFACE const char* failureString(assertType::Enum at);
DOCTEST_INTERFACE const char* skipPathFromFilename(const char* file);

struct DOCTEST_INTERFACE TestCaseData
{
    String      m_file;       // the file in which the test was registered (using String - see #350)
    unsigned    m_line;       // the line where the test was registered
    const char* m_name;       // name of the test case
    const char* m_test_suite; // the test suite in which the test was added
    const char* m_description;
    bool        m_skip;
    bool        m_no_breaks;
    bool        m_no_output;
    bool        m_may_fail;
    bool        m_should_fail;
    int         m_expected_failures;
    double      m_timeout;
};

struct DOCTEST_INTERFACE AssertData
{
    // common - for all asserts
    const TestCaseData* m_test_case;
    assertType::Enum    m_at;
    const char*         m_file;
    int                 m_line;
    const char*         m_expr;
    bool                m_failed;

    // exception-related - for all asserts
    bool   m_threw;
    String m_exception;

    // for normal asserts
    String m_decomp;

    // for specific exception-related asserts
    bool           m_threw_as;
    const char*    m_exception_type;

    class DOCTEST_INTERFACE StringContains {
        private:
            Contains content;
            bool isContains;

        public:
            StringContains(const String& str) : content(str), isContains(false) { }
            StringContains(Contains cntn) : content(static_cast<Contains&&>(cntn)), isContains(true) { }

            bool check(const String& str) { return isContains ? (content == str) : (content.string == str); }

            operator const String&() const { return content.string; }

            const char* c_str() const { return content.string.c_str(); }
    } m_exception_string;

    AssertData(assertType::Enum at, const char* file, int line, const char* expr,
        const char* exception_type, const StringContains& exception_string);
};

struct DOCTEST_INTERFACE MessageData
{
    String           m_string;
    const char*      m_file;
    int              m_line;
    assertType::Enum m_severity;
};

struct DOCTEST_INTERFACE SubcaseSignature
{
    String      m_name;
    const char* m_file;
    int         m_line;

    bool operator==(const SubcaseSignature& other) const;
    bool operator<(const SubcaseSignature& other) const;
};

struct DOCTEST_INTERFACE IContextScope
{
    DOCTEST_DECLARE_INTERFACE(IContextScope)
    virtual void stringify(std::ostream*) const = 0;
};

namespace detail {
    struct DOCTEST_INTERFACE TestCase;
} // namespace detail

struct ContextOptions //!OCLINT too many fields
{
    std::ostream* cout = nullptr; // stdout stream
    String        binary_name;    // the test binary name

    const detail::TestCase* currentTest = nullptr;

    // == parameters from the command line
    String   out;       // output filename
    String   order_by;  // how tests should be ordered
    unsigned rand_seed; // the seed for rand ordering

    unsigned first; // the first (matching) test to be executed
    unsigned last;  // the last (matching) test to be executed

    int abort_after;           // stop tests after this many failed assertions
    int subcase_filter_levels; // apply the subcase filters for the first N levels

    bool success;              // include successful assertions in output
    bool case_sensitive;       // if filtering should be case sensitive
    bool exit;                 // if the program should be exited after the tests are ran/whatever
    bool duration;             // print the time duration of each test case
    bool minimal;              // minimal console output (only test failures)
    bool quiet;                // no console output
    bool no_throw;             // to skip exceptions-related assertion macros
    bool no_exitcode;          // if the framework should return 0 as the exitcode
    bool no_run;               // to not run the tests at all (can be done with an "*" exclude)
    bool no_intro;             // to not print the intro of the framework
    bool no_version;           // to not print the version of the framework
    bool no_colors;            // if output to the console should be colorized
    bool force_colors;         // forces the use of colors even when a tty cannot be detected
    bool no_breaks;            // to not break into the debugger
    bool no_skip;              // don't skip test cases which are marked to be skipped
    bool gnu_file_line;        // if line numbers should be surrounded with :x: and not (x):
    bool no_path_in_filenames; // if the path to files should be removed from the output
    String strip_file_prefixes;// remove the longest matching one of these prefixes from any file paths in the output
    bool no_line_numbers;      // if source code line numbers should be omitted from the output
    bool no_debug_output;      // no output in the debug console when a debugger is attached
    bool no_skipped_summary;   // don't print "skipped" in the summary !!! UNDOCUMENTED !!!
    bool no_time_in_output;    // omit any time/timestamps from output !!! UNDOCUMENTED !!!

    bool help;             // to print the help
    bool version;          // to print the version
    bool count;            // if only the count of matching tests is to be retrieved
    bool list_test_cases;  // to list all tests matching the filters
    bool list_test_suites; // to list all suites matching the filters
    bool list_reporters;   // lists all registered reporters
};

namespace detail {
    namespace types {
#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
        using namespace std;
#else
        template <bool COND, typename T = void>
        struct enable_if { };

        template <typename T>
        struct enable_if<true, T> { using type = T; };

        struct true_type { static DOCTEST_CONSTEXPR bool value = true; };
        struct false_type { static DOCTEST_CONSTEXPR bool value = false; };

        template <typename T> struct remove_reference { using type = T; };
        template <typename T> struct remove_reference<T&> { using type = T; };
        template <typename T> struct remove_reference<T&&> { using type = T; };

        template <typename T> struct is_rvalue_reference : false_type { };
        template <typename T> struct is_rvalue_reference<T&&> : true_type { };

        template<typename T> struct remove_const { using type = T; };
        template <typename T> struct remove_const<const T> { using type = T; };

        // Compiler intrinsics
        template <typename T> struct is_enum { static DOCTEST_CONSTEXPR bool value = __is_enum(T); };
        template <typename T> struct underlying_type { using type = __underlying_type(T); };

        template <typename T> struct is_pointer : false_type { };
        template <typename T> struct is_pointer<T*> : true_type { };

        template <typename T> struct is_array : false_type { };
        // NOLINTNEXTLINE(*-avoid-c-arrays)
        template <typename T, size_t SIZE> struct is_array<T[SIZE]> : true_type { };
#endif
    }

    // <utility>
    template <typename T>
    T&& declval();

    template <class T>
    DOCTEST_CONSTEXPR_FUNC T&& forward(typename types::remove_reference<T>::type& t) DOCTEST_NOEXCEPT {
        return static_cast<T&&>(t);
    }

    template <class T>
    DOCTEST_CONSTEXPR_FUNC T&& forward(typename types::remove_reference<T>::type&& t) DOCTEST_NOEXCEPT {
        return static_cast<T&&>(t);
    }

    template <typename T>
    struct deferred_false : types::false_type { };

// MSVS 2015 :(
#if !DOCTEST_CLANG && defined(_MSC_VER) && _MSC_VER <= 1900
    template <typename T, typename = void>
    struct has_global_insertion_operator : types::false_type { };

    template <typename T>
    struct has_global_insertion_operator<T, decltype(::operator<<(declval<std::ostream&>(), declval<const T&>()), void())> : types::true_type { };

    template <typename T, typename = void>
    struct has_insertion_operator { static DOCTEST_CONSTEXPR bool value = has_global_insertion_operator<T>::value; };

    template <typename T, bool global>
    struct insert_hack;

    template <typename T>
    struct insert_hack<T, true> {
        static void insert(std::ostream& os, const T& t) { ::operator<<(os, t); }
    };

    template <typename T>
    struct insert_hack<T, false> {
        static void insert(std::ostream& os, const T& t) { operator<<(os, t); }
    };

    template <typename T>
    using insert_hack_t = insert_hack<T, has_global_insertion_operator<T>::value>;
#else
    template <typename T, typename = void>
    struct has_insertion_operator : types::false_type { };
#endif

    template <typename T>
    struct has_insertion_operator<T, decltype(operator<<(declval<std::ostream&>(), declval<const T&>()), void())> : types::true_type { };

    template <typename T>
    struct should_stringify_as_underlying_type {
        static DOCTEST_CONSTEXPR bool value = detail::types::is_enum<T>::value && !doctest::detail::has_insertion_operator<T>::value;
    };

    DOCTEST_INTERFACE std::ostream* tlssPush();
    DOCTEST_INTERFACE String tlssPop();

    template <bool C>
    struct StringMakerBase {
        template <typename T>
        static String convert(const DOCTEST_REF_WRAP(T)) {
#ifdef DOCTEST_CONFIG_REQUIRE_STRINGIFICATION_FOR_ALL_USED_TYPES
            static_assert(deferred_false<T>::value, "No stringification detected for type T. See string conversion manual");
#endif
            return "{?}";
        }
    };

    template <typename T>
    struct filldata;

    template <typename T>
    void filloss(std::ostream* stream, const T& in) {
        filldata<T>::fill(stream, in);
    }

    template <typename T, size_t N>
    void filloss(std::ostream* stream, const T (&in)[N]) { // NOLINT(*-avoid-c-arrays)
        // T[N], T(&)[N], T(&&)[N] have same behaviour.
        // Hence remove reference.
        filloss<typename types::remove_reference<decltype(in)>::type>(stream, in);
    }

    template <typename T>
    String toStream(const T& in) {
        std::ostream* stream = tlssPush();
        filloss(stream, in);
        return tlssPop();
    }

    template <>
    struct StringMakerBase<true> {
        template <typename T>
        static String convert(const DOCTEST_REF_WRAP(T) in) {
            return toStream(in);
        }
    };
} // namespace detail

template <typename T>
struct StringMaker : public detail::StringMakerBase<
    detail::has_insertion_operator<T>::value || detail::types::is_pointer<T>::value || detail::types::is_array<T>::value>
{};

#ifndef DOCTEST_STRINGIFY
#ifdef DOCTEST_CONFIG_DOUBLE_STRINGIFY
#define DOCTEST_STRINGIFY(...) toString(toString(__VA_ARGS__))
#else
#define DOCTEST_STRINGIFY(...) toString(__VA_ARGS__)
#endif
#endif

template <typename T>
String toString() {
#if DOCTEST_CLANG == 0 && DOCTEST_GCC == 0 && DOCTEST_ICC == 0
    String ret = __FUNCSIG__; // class doctest::String __cdecl doctest::toString<TYPE>(void)
    String::size_type beginPos = ret.find('<');
    return ret.substr(beginPos + 1, ret.size() - beginPos - static_cast<String::size_type>(sizeof(">(void)")));
#else
    String ret = __PRETTY_FUNCTION__; // doctest::String toString() [with T = TYPE]
    String::size_type begin = ret.find('=') + 2;
    return ret.substr(begin, ret.size() - begin - 1);
#endif
}

template <typename T, typename detail::types::enable_if<!detail::should_stringify_as_underlying_type<T>::value, bool>::type = true>
String toString(const DOCTEST_REF_WRAP(T) value) {
    return StringMaker<T>::convert(value);
}

#ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
DOCTEST_INTERFACE String toString(const char* in);
#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING

#if DOCTEST_MSVC >= DOCTEST_COMPILER(19, 20, 0)
// see this issue on why this is needed: https://github.com/doctest/doctest/issues/183
DOCTEST_INTERFACE String toString(const std::string& in);
#endif // VS 2019

DOCTEST_INTERFACE String toString(String in);

DOCTEST_INTERFACE String toString(std::nullptr_t);

DOCTEST_INTERFACE String toString(bool in);

DOCTEST_INTERFACE String toString(float in);
DOCTEST_INTERFACE String toString(double in);
DOCTEST_INTERFACE String toString(double long in);

DOCTEST_INTERFACE String toString(char in);
DOCTEST_INTERFACE String toString(char signed in);
DOCTEST_INTERFACE String toString(char unsigned in);
DOCTEST_INTERFACE String toString(short in);
DOCTEST_INTERFACE String toString(short unsigned in);
DOCTEST_INTERFACE String toString(signed in);
DOCTEST_INTERFACE String toString(unsigned in);
DOCTEST_INTERFACE String toString(long in);
DOCTEST_INTERFACE String toString(long unsigned in);
DOCTEST_INTERFACE String toString(long long in);
DOCTEST_INTERFACE String toString(long long unsigned in);

template <typename T, typename detail::types::enable_if<detail::should_stringify_as_underlying_type<T>::value, bool>::type = true>
String toString(const DOCTEST_REF_WRAP(T) value) {
    using UT = typename detail::types::underlying_type<T>::type;
    return (DOCTEST_STRINGIFY(static_cast<UT>(value)));
}

namespace detail {
    template <typename T>
    struct filldata
    {
        static void fill(std::ostream* stream, const T& in) {
#if defined(_MSC_VER) && _MSC_VER <= 1900
        insert_hack_t<T>::insert(*stream, in);
#else
        operator<<(*stream, in);
#endif
        }
    };

DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4866)
// NOLINTBEGIN(*-avoid-c-arrays)
    template <typename T, size_t N>
    struct filldata<T[N]> {
        static void fill(std::ostream* stream, const T(&in)[N]) {
            *stream << "[";
            for (size_t i = 0; i < N; i++) {
                if (i != 0) { *stream << ", "; }
                *stream << (DOCTEST_STRINGIFY(in[i]));
            }
            *stream << "]";
        }
    };
// NOLINTEND(*-avoid-c-arrays)
DOCTEST_MSVC_SUPPRESS_WARNING_POP

    // Specialized since we don't want the terminating null byte!
// NOLINTBEGIN(*-avoid-c-arrays)
    template <size_t N>
    struct filldata<const char[N]> {
        static void fill(std::ostream* stream, const char (&in)[N]) {
            *stream << String(in, in[N - 1] ? N : N - 1);
        } // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks)
    };
// NOLINTEND(*-avoid-c-arrays)

    template <>
    struct filldata<const void*> {
        static void fill(std::ostream* stream, const void* in);
    };

    template <typename T>
    struct filldata<T*> {
DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4180)
        static void fill(std::ostream* stream, const T* in) {
DOCTEST_MSVC_SUPPRESS_WARNING_POP
DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wmicrosoft-cast")
            filldata<const void*>::fill(stream,
#if DOCTEST_GCC == 0 || DOCTEST_GCC >= DOCTEST_COMPILER(4, 9, 0)
                reinterpret_cast<const void*>(in)
#else
                *reinterpret_cast<const void* const*>(&in)
#endif
            );
DOCTEST_CLANG_SUPPRESS_WARNING_POP
        }
    };
}

struct DOCTEST_INTERFACE Approx
{
    Approx(double value);

    Approx operator()(double value) const;

#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
    template <typename T>
    explicit Approx(const T& value,
                    typename detail::types::enable_if<std::is_constructible<double, T>::value>::type* =
                            static_cast<T*>(nullptr)) {
        *this = static_cast<double>(value);
    }
#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS

    Approx& epsilon(double newEpsilon);

#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
    template <typename T>
    typename std::enable_if<std::is_constructible<double, T>::value, Approx&>::type epsilon(
            const T& newEpsilon) {
        m_epsilon = static_cast<double>(newEpsilon);
        return *this;
    }
#endif //  DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS

    Approx& scale(double newScale);

#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
    template <typename T>
    typename std::enable_if<std::is_constructible<double, T>::value, Approx&>::type scale(
            const T& newScale) {
        m_scale = static_cast<double>(newScale);
        return *this;
    }
#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS

    // clang-format off
    DOCTEST_INTERFACE friend bool operator==(double lhs, const Approx & rhs);
    DOCTEST_INTERFACE friend bool operator==(const Approx & lhs, double rhs);
    DOCTEST_INTERFACE friend bool operator!=(double lhs, const Approx & rhs);
    DOCTEST_INTERFACE friend bool operator!=(const Approx & lhs, double rhs);
    DOCTEST_INTERFACE friend bool operator<=(double lhs, const Approx & rhs);
    DOCTEST_INTERFACE friend bool operator<=(const Approx & lhs, double rhs);
    DOCTEST_INTERFACE friend bool operator>=(double lhs, const Approx & rhs);
    DOCTEST_INTERFACE friend bool operator>=(const Approx & lhs, double rhs);
    DOCTEST_INTERFACE friend bool operator< (double lhs, const Approx & rhs);
    DOCTEST_INTERFACE friend bool operator< (const Approx & lhs, double rhs);
    DOCTEST_INTERFACE friend bool operator> (double lhs, const Approx & rhs);
    DOCTEST_INTERFACE friend bool operator> (const Approx & lhs, double rhs);

#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
#define DOCTEST_APPROX_PREFIX \
    template <typename T> friend typename std::enable_if<std::is_constructible<double, T>::value, bool>::type

    DOCTEST_APPROX_PREFIX operator==(const T& lhs, const Approx& rhs) { return operator==(static_cast<double>(lhs), rhs); }
    DOCTEST_APPROX_PREFIX operator==(const Approx& lhs, const T& rhs) { return operator==(rhs, lhs); }
    DOCTEST_APPROX_PREFIX operator!=(const T& lhs, const Approx& rhs) { return !operator==(lhs, rhs); }
    DOCTEST_APPROX_PREFIX operator!=(const Approx& lhs, const T& rhs) { return !operator==(rhs, lhs); }
    DOCTEST_APPROX_PREFIX operator<=(const T& lhs, const Approx& rhs) { return static_cast<double>(lhs) < rhs.m_value || lhs == rhs; }
    DOCTEST_APPROX_PREFIX operator<=(const Approx& lhs, const T& rhs) { return lhs.m_value < static_cast<double>(rhs) || lhs == rhs; }
    DOCTEST_APPROX_PREFIX operator>=(const T& lhs, const Approx& rhs) { return static_cast<double>(lhs) > rhs.m_value || lhs == rhs; }
    DOCTEST_APPROX_PREFIX operator>=(const Approx& lhs, const T& rhs) { return lhs.m_value > static_cast<double>(rhs) || lhs == rhs; }
    DOCTEST_APPROX_PREFIX operator< (const T& lhs, const Approx& rhs) { return static_cast<double>(lhs) < rhs.m_value && lhs != rhs; }
    DOCTEST_APPROX_PREFIX operator< (const Approx& lhs, const T& rhs) { return lhs.m_value < static_cast<double>(rhs) && lhs != rhs; }
    DOCTEST_APPROX_PREFIX operator> (const T& lhs, const Approx& rhs) { return static_cast<double>(lhs) > rhs.m_value && lhs != rhs; }
    DOCTEST_APPROX_PREFIX operator> (const Approx& lhs, const T& rhs) { return lhs.m_value > static_cast<double>(rhs) && lhs != rhs; }
#undef DOCTEST_APPROX_PREFIX
#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS

    // clang-format on

    double m_epsilon;
    double m_scale;
    double m_value;
};

DOCTEST_INTERFACE String toString(const Approx& in);

DOCTEST_INTERFACE const ContextOptions* getContextOptions();

template <typename F>
struct DOCTEST_INTERFACE_DECL IsNaN
{
    F value; bool flipped;
    IsNaN(F f, bool flip = false) : value(f), flipped(flip) { }
    IsNaN<F> operator!() const { return { value, !flipped }; }
    operator bool() const;
};
#ifndef __MINGW32__
extern template struct DOCTEST_INTERFACE_DECL IsNaN<float>;
extern template struct DOCTEST_INTERFACE_DECL IsNaN<double>;
extern template struct DOCTEST_INTERFACE_DECL IsNaN<long double>;
#endif
DOCTEST_INTERFACE String toString(IsNaN<float> in);
DOCTEST_INTERFACE String toString(IsNaN<double> in);
DOCTEST_INTERFACE String toString(IsNaN<double long> in);

#ifndef DOCTEST_CONFIG_DISABLE

namespace detail {
    // clang-format off
#ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
    template<class T>               struct decay_array       { using type = T; };
    template<class T, unsigned N>   struct decay_array<T[N]> { using type = T*; };
    template<class T>               struct decay_array<T[]>  { using type = T*; };

    template<class T>   struct not_char_pointer              { static DOCTEST_CONSTEXPR int value = 1; };
    template<>          struct not_char_pointer<char*>       { static DOCTEST_CONSTEXPR int value = 0; };
    template<>          struct not_char_pointer<const char*> { static DOCTEST_CONSTEXPR int value = 0; };

    template<class T> struct can_use_op : public not_char_pointer<typename decay_array<T>::type> {};
#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
    // clang-format on

    struct DOCTEST_INTERFACE TestFailureException
    {
    };

    DOCTEST_INTERFACE bool checkIfShouldThrow(assertType::Enum at);

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
    DOCTEST_NORETURN
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
    DOCTEST_INTERFACE void throwException();

    struct DOCTEST_INTERFACE Subcase
    {
        SubcaseSignature m_signature;
        bool             m_entered = false;

        Subcase(const String& name, const char* file, int line);
        Subcase(const Subcase&) = delete;
        Subcase(Subcase&&) = delete;
        Subcase& operator=(const Subcase&) = delete;
        Subcase& operator=(Subcase&&) = delete;
        ~Subcase();

        operator bool() const;

        private:
            bool checkFilters();
    };

    template <typename L, typename R>
    String stringifyBinaryExpr(const DOCTEST_REF_WRAP(L) lhs, const char* op,
                               const DOCTEST_REF_WRAP(R) rhs) {
        return (DOCTEST_STRINGIFY(lhs)) + op + (DOCTEST_STRINGIFY(rhs));
    }

#if DOCTEST_CLANG && DOCTEST_CLANG < DOCTEST_COMPILER(3, 6, 0)
DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wunused-comparison")
#endif

// This will check if there is any way it could find a operator like member or friend and uses it.
// If not it doesn't find the operator or if the operator at global scope is defined after
// this template, the template won't be instantiated due to SFINAE. Once the template is not
// instantiated it can look for global operator using normal conversions.
#ifdef __NVCC__
#define SFINAE_OP(ret,op) ret
#else
#define SFINAE_OP(ret,op) decltype((void)(doctest::detail::declval<L>() op doctest::detail::declval<R>()),ret{})
#endif

#define DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(op, op_str, op_macro)                              \
    template <typename R>                                                                          \
    DOCTEST_NOINLINE SFINAE_OP(Result,op) operator op(R&& rhs) {                                   \
    bool res = op_macro(doctest::detail::forward<const L>(lhs), doctest::detail::forward<R>(rhs)); \
        if(m_at & assertType::is_false)                                                            \
            res = !res;                                                                            \
        if(!res || doctest::getContextOptions()->success)                                          \
            return Result(res, stringifyBinaryExpr(lhs, op_str, rhs));                             \
        return Result(res);                                                                        \
    }

    // more checks could be added - like in Catch:
    // https://github.com/catchorg/Catch2/pull/1480/files
    // https://github.com/catchorg/Catch2/pull/1481/files
#define DOCTEST_FORBIT_EXPRESSION(rt, op)                                                          \
    template <typename R>                                                                          \
    rt& operator op(const R&) {                                                                    \
        static_assert(deferred_false<R>::value,                                                    \
                      "Expression Too Complex Please Rewrite As Binary Comparison!");              \
        return *this;                                                                              \
    }

    struct DOCTEST_INTERFACE Result // NOLINT(*-member-init)
    {
        bool   m_passed;
        String m_decomp;

        Result() = default; // TODO: Why do we need this? (To remove NOLINT)
        Result(bool passed, const String& decomposition = String());

        // forbidding some expressions based on this table: https://en.cppreference.com/w/cpp/language/operator_precedence
        DOCTEST_FORBIT_EXPRESSION(Result, &)
        DOCTEST_FORBIT_EXPRESSION(Result, ^)
        DOCTEST_FORBIT_EXPRESSION(Result, |)
        DOCTEST_FORBIT_EXPRESSION(Result, &&)
        DOCTEST_FORBIT_EXPRESSION(Result, ||)
        DOCTEST_FORBIT_EXPRESSION(Result, ==)
        DOCTEST_FORBIT_EXPRESSION(Result, !=)
        DOCTEST_FORBIT_EXPRESSION(Result, <)
        DOCTEST_FORBIT_EXPRESSION(Result, >)
        DOCTEST_FORBIT_EXPRESSION(Result, <=)
        DOCTEST_FORBIT_EXPRESSION(Result, >=)
        DOCTEST_FORBIT_EXPRESSION(Result, =)
        DOCTEST_FORBIT_EXPRESSION(Result, +=)
        DOCTEST_FORBIT_EXPRESSION(Result, -=)
        DOCTEST_FORBIT_EXPRESSION(Result, *=)
        DOCTEST_FORBIT_EXPRESSION(Result, /=)
        DOCTEST_FORBIT_EXPRESSION(Result, %=)
        DOCTEST_FORBIT_EXPRESSION(Result, <<=)
        DOCTEST_FORBIT_EXPRESSION(Result, >>=)
        DOCTEST_FORBIT_EXPRESSION(Result, &=)
        DOCTEST_FORBIT_EXPRESSION(Result, ^=)
        DOCTEST_FORBIT_EXPRESSION(Result, |=)
    };

#ifndef DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION

    DOCTEST_CLANG_SUPPRESS_WARNING_PUSH
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wsign-conversion")
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wsign-compare")
    //DOCTEST_CLANG_SUPPRESS_WARNING("-Wdouble-promotion")
    //DOCTEST_CLANG_SUPPRESS_WARNING("-Wconversion")
    //DOCTEST_CLANG_SUPPRESS_WARNING("-Wfloat-equal")

    DOCTEST_GCC_SUPPRESS_WARNING_PUSH
    DOCTEST_GCC_SUPPRESS_WARNING("-Wsign-conversion")
    DOCTEST_GCC_SUPPRESS_WARNING("-Wsign-compare")
    //DOCTEST_GCC_SUPPRESS_WARNING("-Wdouble-promotion")
    //DOCTEST_GCC_SUPPRESS_WARNING("-Wconversion")
    //DOCTEST_GCC_SUPPRESS_WARNING("-Wfloat-equal")

    DOCTEST_MSVC_SUPPRESS_WARNING_PUSH
    // https://stackoverflow.com/questions/39479163 what's the difference between 4018 and 4389
    DOCTEST_MSVC_SUPPRESS_WARNING(4388) // signed/unsigned mismatch
    DOCTEST_MSVC_SUPPRESS_WARNING(4389) // 'operator' : signed/unsigned mismatch
    DOCTEST_MSVC_SUPPRESS_WARNING(4018) // 'expression' : signed/unsigned mismatch
    //DOCTEST_MSVC_SUPPRESS_WARNING(4805) // 'operation' : unsafe mix of type 'type' and type 'type' in operation

#endif // DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION

    // clang-format off
#ifndef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
#define DOCTEST_COMPARISON_RETURN_TYPE bool
#else // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
#define DOCTEST_COMPARISON_RETURN_TYPE typename types::enable_if<can_use_op<L>::value || can_use_op<R>::value, bool>::type
    inline bool eq(const char* lhs, const char* rhs) { return String(lhs) == String(rhs); }
    inline bool ne(const char* lhs, const char* rhs) { return String(lhs) != String(rhs); }
    inline bool lt(const char* lhs, const char* rhs) { return String(lhs) <  String(rhs); }
    inline bool gt(const char* lhs, const char* rhs) { return String(lhs) >  String(rhs); }
    inline bool le(const char* lhs, const char* rhs) { return String(lhs) <= String(rhs); }
    inline bool ge(const char* lhs, const char* rhs) { return String(lhs) >= String(rhs); }
#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
    // clang-format on

#define DOCTEST_RELATIONAL_OP(name, op)                                                            \
    template <typename L, typename R>                                                              \
    DOCTEST_COMPARISON_RETURN_TYPE name(const DOCTEST_REF_WRAP(L) lhs,                             \
                                        const DOCTEST_REF_WRAP(R) rhs) {                           \
        return lhs op rhs;                                                                         \
    }

    DOCTEST_RELATIONAL_OP(eq, ==)
    DOCTEST_RELATIONAL_OP(ne, !=)
    DOCTEST_RELATIONAL_OP(lt, <)
    DOCTEST_RELATIONAL_OP(gt, >)
    DOCTEST_RELATIONAL_OP(le, <=)
    DOCTEST_RELATIONAL_OP(ge, >=)

#ifndef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
#define DOCTEST_CMP_EQ(l, r) l == r
#define DOCTEST_CMP_NE(l, r) l != r
#define DOCTEST_CMP_GT(l, r) l > r
#define DOCTEST_CMP_LT(l, r) l < r
#define DOCTEST_CMP_GE(l, r) l >= r
#define DOCTEST_CMP_LE(l, r) l <= r
#else // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
#define DOCTEST_CMP_EQ(l, r) eq(l, r)
#define DOCTEST_CMP_NE(l, r) ne(l, r)
#define DOCTEST_CMP_GT(l, r) gt(l, r)
#define DOCTEST_CMP_LT(l, r) lt(l, r)
#define DOCTEST_CMP_GE(l, r) ge(l, r)
#define DOCTEST_CMP_LE(l, r) le(l, r)
#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING

    template <typename L>
    // cppcheck-suppress copyCtorAndEqOperator
    struct Expression_lhs
    {
        L                lhs;
        assertType::Enum m_at;

        explicit Expression_lhs(L&& in, assertType::Enum at)
                : lhs(static_cast<L&&>(in))
                , m_at(at) {}

        DOCTEST_NOINLINE operator Result() {
// this is needed only for MSVC 2015
DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4800) // 'int': forcing value to bool
            bool res = static_cast<bool>(lhs);
DOCTEST_MSVC_SUPPRESS_WARNING_POP
            if(m_at & assertType::is_false) { //!OCLINT bitwise operator in conditional
                res = !res;
            }

            if(!res || getContextOptions()->success) {
                return { res, (DOCTEST_STRINGIFY(lhs)) };
            }
            return { res };
        }

        /* This is required for user-defined conversions from Expression_lhs to L */
        operator L() const { return lhs; }

        // clang-format off
        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(==, " == ", DOCTEST_CMP_EQ) //!OCLINT bitwise operator in conditional
        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(!=, " != ", DOCTEST_CMP_NE) //!OCLINT bitwise operator in conditional
        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(>,  " >  ", DOCTEST_CMP_GT) //!OCLINT bitwise operator in conditional
        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(<,  " <  ", DOCTEST_CMP_LT) //!OCLINT bitwise operator in conditional
        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(>=, " >= ", DOCTEST_CMP_GE) //!OCLINT bitwise operator in conditional
        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(<=, " <= ", DOCTEST_CMP_LE) //!OCLINT bitwise operator in conditional
        // clang-format on

        // forbidding some expressions based on this table: https://en.cppreference.com/w/cpp/language/operator_precedence
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, &)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, ^)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, |)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, &&)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, ||)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, =)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, +=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, -=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, *=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, /=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, %=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, <<=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, >>=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, &=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, ^=)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, |=)
        // these 2 are unfortunate because they should be allowed - they have higher precedence over the comparisons, but the
        // ExpressionDecomposer class uses the left shift operator to capture the left operand of the binary expression...
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, <<)
        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, >>)
    };

#ifndef DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION

    DOCTEST_CLANG_SUPPRESS_WARNING_POP
    DOCTEST_MSVC_SUPPRESS_WARNING_POP
    DOCTEST_GCC_SUPPRESS_WARNING_POP

#endif // DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION

#if DOCTEST_CLANG && DOCTEST_CLANG < DOCTEST_COMPILER(3, 6, 0)
DOCTEST_CLANG_SUPPRESS_WARNING_POP
#endif

    struct DOCTEST_INTERFACE ExpressionDecomposer
    {
        assertType::Enum m_at;

        ExpressionDecomposer(assertType::Enum at);

        // The right operator for capturing expressions is "<=" instead of "<<" (based on the operator precedence table)
        // but then there will be warnings from GCC about "-Wparentheses" and since "_Pragma()" is problematic this will stay for now...
        // https://github.com/catchorg/Catch2/issues/870
        // https://github.com/catchorg/Catch2/issues/565
        template <typename L>
        Expression_lhs<const L&&> operator<<(const L&& operand) { //bitfields bind to universal ref but not const rvalue ref
            return Expression_lhs<const L&&>(static_cast<const L&&>(operand), m_at);
        }

        template <typename L,typename types::enable_if<!doctest::detail::types::is_rvalue_reference<L>::value,void >::type* = nullptr>
        Expression_lhs<const L&> operator<<(const L &operand) {
            return Expression_lhs<const L&>(operand, m_at);
        }
    };

    struct DOCTEST_INTERFACE TestSuite
    {
        const char* m_test_suite = nullptr;
        const char* m_description = nullptr;
        bool        m_skip = false;
        bool        m_no_breaks = false;
        bool        m_no_output = false;
        bool        m_may_fail = false;
        bool        m_should_fail = false;
        int         m_expected_failures = 0;
        double      m_timeout = 0;

        TestSuite& operator*(const char* in);

        template <typename T>
        TestSuite& operator*(const T& in) {
            in.fill(*this);
            return *this;
        }
    };

    using funcType = void (*)();

    struct DOCTEST_INTERFACE TestCase : public TestCaseData
    {
        funcType m_test; // a function pointer to the test case

        String m_type; // for templated test cases - gets appended to the real name
        int m_template_id; // an ID used to distinguish between the different versions of a templated test case
        String m_full_name; // contains the name (only for templated test cases!) + the template type

        TestCase(funcType test, const char* file, unsigned line, const TestSuite& test_suite,
                 const String& type = String(), int template_id = -1);

        TestCase(const TestCase& other);
        TestCase(TestCase&&) = delete;

        DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(26434) // hides a non-virtual function
        TestCase& operator=(const TestCase& other);
        DOCTEST_MSVC_SUPPRESS_WARNING_POP

        TestCase& operator=(TestCase&&) = delete;

        TestCase& operator*(const char* in);

        template <typename T>
        TestCase& operator*(const T& in) {
            in.fill(*this);
            return *this;
        }

        bool operator<(const TestCase& other) const;

        ~TestCase() = default;
    };

    // forward declarations of functions used by the macros
    DOCTEST_INTERFACE int  regTest(const TestCase& tc);
    DOCTEST_INTERFACE int  setTestSuite(const TestSuite& ts);
    DOCTEST_INTERFACE bool isDebuggerActive();

    template<typename T>
    int instantiationHelper(const T&) { return 0; }

    namespace binaryAssertComparison {
        enum Enum
        {
            eq = 0,
            ne,
            gt,
            lt,
            ge,
            le
        };
    } // namespace binaryAssertComparison

    // clang-format off
    template <int, class L, class R> struct RelationalComparator     { bool operator()(const DOCTEST_REF_WRAP(L),     const DOCTEST_REF_WRAP(R)    ) const { return false;        } };

#define DOCTEST_BINARY_RELATIONAL_OP(n, op) \
    template <class L, class R> struct RelationalComparator<n, L, R> { bool operator()(const DOCTEST_REF_WRAP(L) lhs, const DOCTEST_REF_WRAP(R) rhs) const { return op(lhs, rhs); } };
    // clang-format on

    DOCTEST_BINARY_RELATIONAL_OP(0, doctest::detail::eq)
    DOCTEST_BINARY_RELATIONAL_OP(1, doctest::detail::ne)
    DOCTEST_BINARY_RELATIONAL_OP(2, doctest::detail::gt)
    DOCTEST_BINARY_RELATIONAL_OP(3, doctest::detail::lt)
    DOCTEST_BINARY_RELATIONAL_OP(4, doctest::detail::ge)
    DOCTEST_BINARY_RELATIONAL_OP(5, doctest::detail::le)

    struct DOCTEST_INTERFACE ResultBuilder : public AssertData
    {
        ResultBuilder(assertType::Enum at, const char* file, int line, const char* expr,
                      const char* exception_type = "", const String& exception_string = "");

        ResultBuilder(assertType::Enum at, const char* file, int line, const char* expr,
                      const char* exception_type, const Contains& exception_string);

        void setResult(const Result& res);

        template <int comparison, typename L, typename R>
        DOCTEST_NOINLINE bool binary_assert(const DOCTEST_REF_WRAP(L) lhs,
                                            const DOCTEST_REF_WRAP(R) rhs) {
            m_failed = !RelationalComparator<comparison, L, R>()(lhs, rhs);
            if (m_failed || getContextOptions()->success) {
                m_decomp = stringifyBinaryExpr(lhs, ", ", rhs);
            }
            return !m_failed;
        }

        template <typename L>
        DOCTEST_NOINLINE bool unary_assert(const DOCTEST_REF_WRAP(L) val) {
            m_failed = !val;

            if (m_at & assertType::is_false) { //!OCLINT bitwise operator in conditional
                m_failed = !m_failed;
            }

            if (m_failed || getContextOptions()->success) {
                m_decomp = (DOCTEST_STRINGIFY(val));
            }

            return !m_failed;
        }

        void translateException();

        bool log();
        void react() const;
    };

    namespace assertAction {
        enum Enum
        {
            nothing     = 0,
            dbgbreak    = 1,
            shouldthrow = 2
        };
    } // namespace assertAction

    DOCTEST_INTERFACE void failed_out_of_a_testing_context(const AssertData& ad);

    DOCTEST_INTERFACE bool decomp_assert(assertType::Enum at, const char* file, int line,
                                         const char* expr, const Result& result);

#define DOCTEST_ASSERT_OUT_OF_TESTS(decomp)                                                        \
    do {                                                                                           \
        if(!is_running_in_test) {                                                                  \
            if(failed) {                                                                           \
                ResultBuilder rb(at, file, line, expr);                                            \
                rb.m_failed = failed;                                                              \
                rb.m_decomp = decomp;                                                              \
                failed_out_of_a_testing_context(rb);                                               \
                if(isDebuggerActive() && !getContextOptions()->no_breaks)                          \
                    DOCTEST_BREAK_INTO_DEBUGGER();                                                 \
                if(checkIfShouldThrow(at))                                                         \
                    throwException();                                                              \
            }                                                                                      \
            return !failed;                                                                        \
        }                                                                                          \
    } while(false)

#define DOCTEST_ASSERT_IN_TESTS(decomp)                                                            \
    ResultBuilder rb(at, file, line, expr);                                                        \
    rb.m_failed = failed;                                                                          \
    if(rb.m_failed || getContextOptions()->success)                                                \
        rb.m_decomp = decomp;                                                                      \
    if(rb.log())                                                                                   \
        DOCTEST_BREAK_INTO_DEBUGGER();                                                             \
    if(rb.m_failed && checkIfShouldThrow(at))                                                      \
    throwException()

    template <int comparison, typename L, typename R>
    DOCTEST_NOINLINE bool binary_assert(assertType::Enum at, const char* file, int line,
                                        const char* expr, const DOCTEST_REF_WRAP(L) lhs,
                                        const DOCTEST_REF_WRAP(R) rhs) {
        bool failed = !RelationalComparator<comparison, L, R>()(lhs, rhs);

        // ###################################################################################
        // IF THE DEBUGGER BREAKS HERE - GO 1 LEVEL UP IN THE CALLSTACK FOR THE FAILING ASSERT
        // THIS IS THE EFFECT OF HAVING 'DOCTEST_CONFIG_SUPER_FAST_ASSERTS' DEFINED
        // ###################################################################################
        DOCTEST_ASSERT_OUT_OF_TESTS(stringifyBinaryExpr(lhs, ", ", rhs));
        DOCTEST_ASSERT_IN_TESTS(stringifyBinaryExpr(lhs, ", ", rhs));
        return !failed;
    }

    template <typename L>
    DOCTEST_NOINLINE bool unary_assert(assertType::Enum at, const char* file, int line,
                                       const char* expr, const DOCTEST_REF_WRAP(L) val) {
        bool failed = !val;

        if(at & assertType::is_false) //!OCLINT bitwise operator in conditional
            failed = !failed;

        // ###################################################################################
        // IF THE DEBUGGER BREAKS HERE - GO 1 LEVEL UP IN THE CALLSTACK FOR THE FAILING ASSERT
        // THIS IS THE EFFECT OF HAVING 'DOCTEST_CONFIG_SUPER_FAST_ASSERTS' DEFINED
        // ###################################################################################
        DOCTEST_ASSERT_OUT_OF_TESTS((DOCTEST_STRINGIFY(val)));
        DOCTEST_ASSERT_IN_TESTS((DOCTEST_STRINGIFY(val)));
        return !failed;
    }

    struct DOCTEST_INTERFACE IExceptionTranslator
    {
        DOCTEST_DECLARE_INTERFACE(IExceptionTranslator)
        virtual bool translate(String&) const = 0;
    };

    template <typename T>
    class ExceptionTranslator : public IExceptionTranslator //!OCLINT destructor of virtual class
    {
    public:
        explicit ExceptionTranslator(String (*translateFunction)(T))
                : m_translateFunction(translateFunction) {}

        bool translate(String& res) const override {
#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
            try {
                throw; // lgtm [cpp/rethrow-no-exception]
                // cppcheck-suppress catchExceptionByValue
            } catch(const T& ex) {
                res = m_translateFunction(ex); //!OCLINT parameter reassignment
                return true;
            } catch(...) {}         //!OCLINT -  empty catch statement
#endif                              // DOCTEST_CONFIG_NO_EXCEPTIONS
            static_cast<void>(res); // to silence -Wunused-parameter
            return false;
        }

    private:
        String (*m_translateFunction)(T);
    };

    DOCTEST_INTERFACE void registerExceptionTranslatorImpl(const IExceptionTranslator* et);

    // ContextScope base class used to allow implementing methods of ContextScope
    // that don't depend on the template parameter in doctest.cpp.
    struct DOCTEST_INTERFACE ContextScopeBase : public IContextScope {
        ContextScopeBase(const ContextScopeBase&) = delete;

        ContextScopeBase& operator=(const ContextScopeBase&) = delete;
        ContextScopeBase& operator=(ContextScopeBase&&) = delete;

        ~ContextScopeBase() override = default;

    protected:
        ContextScopeBase();
        ContextScopeBase(ContextScopeBase&& other) noexcept;

        void destroy();
        bool need_to_destroy{true};
    };

    template <typename L> class ContextScope : public ContextScopeBase
    {
        L lambda_;

    public:
        explicit ContextScope(const L &lambda) : lambda_(lambda) {}
        explicit ContextScope(L&& lambda) : lambda_(static_cast<L&&>(lambda)) { }

        ContextScope(const ContextScope&) = delete;
        ContextScope(ContextScope&&) noexcept = default;

        ContextScope& operator=(const ContextScope&) = delete;
        ContextScope& operator=(ContextScope&&) = delete;

        void stringify(std::ostream* s) const override { lambda_(s); }

        ~ContextScope() override {
            if (need_to_destroy) {
                destroy();
            }
        }
    };

    struct DOCTEST_INTERFACE MessageBuilder : public MessageData
    {
        std::ostream* m_stream;
        bool          logged = false;

        MessageBuilder(const char* file, int line, assertType::Enum severity);

        MessageBuilder(const MessageBuilder&) = delete;
        MessageBuilder(MessageBuilder&&) = delete;

        MessageBuilder& operator=(const MessageBuilder&) = delete;
        MessageBuilder& operator=(MessageBuilder&&) = delete;

        ~MessageBuilder();

        // the preferred way of chaining parameters for stringification
DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4866)
        template <typename T>
        MessageBuilder& operator,(const T& in) {
            *m_stream << (DOCTEST_STRINGIFY(in));
            return *this;
        }
DOCTEST_MSVC_SUPPRESS_WARNING_POP

        // kept here just for backwards-compatibility - the comma operator should be preferred now
        template <typename T>
        MessageBuilder& operator<<(const T& in) { return this->operator,(in); }

        // the `,` operator has the lowest operator precedence - if `<<` is used by the user then
        // the `,` operator will be called last which is not what we want and thus the `*` operator
        // is used first (has higher operator precedence compared to `<<`) so that we guarantee that
        // an operator of the MessageBuilder class is called first before the rest of the parameters
        template <typename T>
        MessageBuilder& operator*(const T& in) { return this->operator,(in); }

        bool log();
        void react();
    };

    template <typename L>
    ContextScope<L> MakeContextScope(const L &lambda) {
        return ContextScope<L>(lambda);
    }
} // namespace detail

#define DOCTEST_DEFINE_DECORATOR(name, type, def)                                                  \
    struct name                                                                                    \
    {                                                                                              \
        type data;                                                                                 \
        name(type in = def)                                                                        \
                : data(in) {}                                                                      \
        void fill(detail::TestCase& state) const { state.DOCTEST_CAT(m_, name) = data; }           \
        void fill(detail::TestSuite& state) const { state.DOCTEST_CAT(m_, name) = data; }          \
    }

DOCTEST_DEFINE_DECORATOR(test_suite, const char*, "");
DOCTEST_DEFINE_DECORATOR(description, const char*, "");
DOCTEST_DEFINE_DECORATOR(skip, bool, true);
DOCTEST_DEFINE_DECORATOR(no_breaks, bool, true);
DOCTEST_DEFINE_DECORATOR(no_output, bool, true);
DOCTEST_DEFINE_DECORATOR(timeout, double, 0);
DOCTEST_DEFINE_DECORATOR(may_fail, bool, true);
DOCTEST_DEFINE_DECORATOR(should_fail, bool, true);
DOCTEST_DEFINE_DECORATOR(expected_failures, int, 0);

template <typename T>
int registerExceptionTranslator(String (*translateFunction)(T)) {
    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wexit-time-destructors")
    static detail::ExceptionTranslator<T> exceptionTranslator(translateFunction);
    DOCTEST_CLANG_SUPPRESS_WARNING_POP
    detail::registerExceptionTranslatorImpl(&exceptionTranslator);
    return 0;
}

} // namespace doctest

// in a separate namespace outside of doctest because the DOCTEST_TEST_SUITE macro
// introduces an anonymous namespace in which getCurrentTestSuite gets overridden
namespace doctest_detail_test_suite_ns {
DOCTEST_INTERFACE doctest::detail::TestSuite& getCurrentTestSuite();
} // namespace doctest_detail_test_suite_ns

namespace doctest {
#else  // DOCTEST_CONFIG_DISABLE
template <typename T>
int registerExceptionTranslator(String (*)(T)) {
    return 0;
}
#endif // DOCTEST_CONFIG_DISABLE

namespace detail {
    using assert_handler = void (*)(const AssertData&);
    struct ContextState;
} // namespace detail

class DOCTEST_INTERFACE Context
{
    detail::ContextState* p;

    void parseArgs(int argc, const char* const* argv, bool withDefaults = false);

public:
    explicit Context(int argc = 0, const char* const* argv = nullptr);

    Context(const Context&) = delete;
    Context(Context&&) = delete;

    Context& operator=(const Context&) = delete;
    Context& operator=(Context&&) = delete;

    ~Context(); // NOLINT(performance-trivially-destructible)

    void applyCommandLine(int argc, const char* const* argv);

    void addFilter(const char* filter, const char* value);
    void clearFilters();
    void setOption(const char* option, bool value);
    void setOption(const char* option, int value);
    void setOption(const char* option, const char* value);

    bool shouldExit();

    void setAsDefaultForAssertsOutOfTestCases();

    void setAssertHandler(detail::assert_handler ah);

    void setCout(std::ostream* out);

    int run();
};

namespace TestCaseFailureReason {
    enum Enum
    {
        None                     = 0,
        AssertFailure            = 1,   // an assertion has failed in the test case
        Exception                = 2,   // test case threw an exception
        Crash                    = 4,   // a crash...
        TooManyFailedAsserts     = 8,   // the abort-after option
        Timeout                  = 16,  // see the timeout decorator
        ShouldHaveFailedButDidnt = 32,  // see the should_fail decorator
        ShouldHaveFailedAndDid   = 64,  // see the should_fail decorator
        DidntFailExactlyNumTimes = 128, // see the expected_failures decorator
        FailedExactlyNumTimes    = 256, // see the expected_failures decorator
        CouldHaveFailedAndDid    = 512  // see the may_fail decorator
    };
} // namespace TestCaseFailureReason

struct DOCTEST_INTERFACE CurrentTestCaseStats
{
    int    numAssertsCurrentTest;
    int    numAssertsFailedCurrentTest;
    double seconds;
    int    failure_flags; // use TestCaseFailureReason::Enum
    bool   testCaseSuccess;
};

struct DOCTEST_INTERFACE TestCaseException
{
    String error_string;
    bool   is_crash;
};

struct DOCTEST_INTERFACE TestRunStats
{
    unsigned numTestCases;
    unsigned numTestCasesPassingFilters;
    unsigned numTestSuitesPassingFilters;
    unsigned numTestCasesFailed;
    int      numAsserts;
    int      numAssertsFailed;
};

struct QueryData
{
    const TestRunStats*  run_stats = nullptr;
    const TestCaseData** data      = nullptr;
    unsigned             num_data  = 0;
};

struct DOCTEST_INTERFACE IReporter
{
    // The constructor has to accept "const ContextOptions&" as a single argument
    // which has most of the options for the run + a pointer to the stdout stream
    // Reporter(const ContextOptions& in)

    // called when a query should be reported (listing test cases, printing the version, etc.)
    virtual void report_query(const QueryData&) = 0;

    // called when the whole test run starts
    virtual void test_run_start() = 0;
    // called when the whole test run ends (caching a pointer to the input doesn't make sense here)
    virtual void test_run_end(const TestRunStats&) = 0;

    // called when a test case is started (safe to cache a pointer to the input)
    virtual void test_case_start(const TestCaseData&) = 0;
    // called when a test case is reentered because of unfinished subcases (safe to cache a pointer to the input)
    virtual void test_case_reenter(const TestCaseData&) = 0;
    // called when a test case has ended
    virtual void test_case_end(const CurrentTestCaseStats&) = 0;

    // called when an exception is thrown from the test case (or it crashes)
    virtual void test_case_exception(const TestCaseException&) = 0;

    // called whenever a subcase is entered (don't cache pointers to the input)
    virtual void subcase_start(const SubcaseSignature&) = 0;
    // called whenever a subcase is exited (don't cache pointers to the input)
    virtual void subcase_end() = 0;

    // called for each assert (don't cache pointers to the input)
    virtual void log_assert(const AssertData&) = 0;
    // called for each message (don't cache pointers to the input)
    virtual void log_message(const MessageData&) = 0;

    // called when a test case is skipped either because it doesn't pass the filters, has a skip decorator
    // or isn't in the execution range (between first and last) (safe to cache a pointer to the input)
    virtual void test_case_skipped(const TestCaseData&) = 0;

    DOCTEST_DECLARE_INTERFACE(IReporter)

    // can obtain all currently active contexts and stringify them if one wishes to do so
    static int                         get_num_active_contexts();
    static const IContextScope* const* get_active_contexts();

    // can iterate through contexts which have been stringified automatically in their destructors when an exception has been thrown
    static int           get_num_stringified_contexts();
    static const String* get_stringified_contexts();
};

namespace detail {
    using reporterCreatorFunc =  IReporter* (*)(const ContextOptions&);

    DOCTEST_INTERFACE void registerReporterImpl(const char* name, int prio, reporterCreatorFunc c, bool isReporter);

    template <typename Reporter>
    IReporter* reporterCreator(const ContextOptions& o) {
        return new Reporter(o);
    }
} // namespace detail

template <typename Reporter>
int registerReporter(const char* name, int priority, bool isReporter) {
    detail::registerReporterImpl(name, priority, detail::reporterCreator<Reporter>, isReporter);
    return 0;
}
} // namespace doctest

#ifdef DOCTEST_CONFIG_ASSERTS_RETURN_VALUES
#define DOCTEST_FUNC_EMPTY [] { return false; }()
#else
#define DOCTEST_FUNC_EMPTY (void)0
#endif

// if registering is not disabled
#ifndef DOCTEST_CONFIG_DISABLE

#ifdef DOCTEST_CONFIG_ASSERTS_RETURN_VALUES
#define DOCTEST_FUNC_SCOPE_BEGIN [&]
#define DOCTEST_FUNC_SCOPE_END ()
#define DOCTEST_FUNC_SCOPE_RET(v) return v
#else
#define DOCTEST_FUNC_SCOPE_BEGIN do
#define DOCTEST_FUNC_SCOPE_END while(false)
#define DOCTEST_FUNC_SCOPE_RET(v) (void)0
#endif

// common code in asserts - for convenience
#define DOCTEST_ASSERT_LOG_REACT_RETURN(b)                                                         \
    if(b.log()) DOCTEST_BREAK_INTO_DEBUGGER();                                                     \
    b.react();                                                                                     \
    DOCTEST_FUNC_SCOPE_RET(!b.m_failed)

#ifdef DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS
#define DOCTEST_WRAP_IN_TRY(x) x;
#else // DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS
#define DOCTEST_WRAP_IN_TRY(x)                                                                     \
    try {                                                                                          \
        x;                                                                                         \
    } catch(...) { DOCTEST_RB.translateException(); }
#endif // DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS

#ifdef DOCTEST_CONFIG_VOID_CAST_EXPRESSIONS
#define DOCTEST_CAST_TO_VOID(...)                                                                  \
    DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wuseless-cast")                                       \
    static_cast<void>(__VA_ARGS__);                                                                \
    DOCTEST_GCC_SUPPRESS_WARNING_POP
#else // DOCTEST_CONFIG_VOID_CAST_EXPRESSIONS
#define DOCTEST_CAST_TO_VOID(...) __VA_ARGS__;
#endif // DOCTEST_CONFIG_VOID_CAST_EXPRESSIONS

// registers the test by initializing a dummy var with a function
#define DOCTEST_REGISTER_FUNCTION(global_prefix, f, decorators)                                    \
    global_prefix DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_VAR_), /* NOLINT */    \
            doctest::detail::regTest(                                                              \
                    doctest::detail::TestCase(                                                     \
                            f, __FILE__, __LINE__,                                                 \
                            doctest_detail_test_suite_ns::getCurrentTestSuite()) *                 \
                    decorators))

#define DOCTEST_IMPLEMENT_FIXTURE(der, base, func, decorators)                                     \
    namespace { /* NOLINT */                                                                       \
        struct der : public base                                                                   \
        {                                                                                          \
            void f();                                                                              \
        };                                                                                         \
        static DOCTEST_INLINE_NOINLINE void func() {                                               \
            der v;                                                                                 \
            v.f();                                                                                 \
        }                                                                                          \
        DOCTEST_REGISTER_FUNCTION(DOCTEST_EMPTY, func, decorators)                                 \
    }                                                                                              \
    DOCTEST_INLINE_NOINLINE void der::f() // NOLINT(misc-definitions-in-headers)

#define DOCTEST_CREATE_AND_REGISTER_FUNCTION(f, decorators)                                        \
    static void f();                                                                               \
    DOCTEST_REGISTER_FUNCTION(DOCTEST_EMPTY, f, decorators)                                        \
    static void f()

#define DOCTEST_CREATE_AND_REGISTER_FUNCTION_IN_CLASS(f, proxy, decorators)                        \
    static doctest::detail::funcType proxy() { return f; }                                         \
    DOCTEST_REGISTER_FUNCTION(inline, proxy(), decorators)                                         \
    static void f()

// for registering tests
#define DOCTEST_TEST_CASE(decorators)                                                              \
    DOCTEST_CREATE_AND_REGISTER_FUNCTION(DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_), decorators)

// for registering tests in classes - requires C++17 for inline variables!
#if DOCTEST_CPLUSPLUS >= 201703L
#define DOCTEST_TEST_CASE_CLASS(decorators)                                                        \
    DOCTEST_CREATE_AND_REGISTER_FUNCTION_IN_CLASS(DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_),           \
                                                  DOCTEST_ANONYMOUS(DOCTEST_ANON_PROXY_),          \
                                                  decorators)
#else // DOCTEST_TEST_CASE_CLASS
#define DOCTEST_TEST_CASE_CLASS(...)                                                               \
    TEST_CASES_CAN_BE_REGISTERED_IN_CLASSES_ONLY_IN_CPP17_MODE_OR_WITH_VS_2017_OR_NEWER
#endif // DOCTEST_TEST_CASE_CLASS

// for registering tests with a fixture
#define DOCTEST_TEST_CASE_FIXTURE(c, decorators)                                                   \
    DOCTEST_IMPLEMENT_FIXTURE(DOCTEST_ANONYMOUS(DOCTEST_ANON_CLASS_), c,                           \
                              DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_), decorators)

// for converting types to strings without the <typeinfo> header and demangling
#define DOCTEST_TYPE_TO_STRING_AS(str, ...)                                                        \
    namespace doctest {                                                                            \
        template <>                                                                                \
        inline String toString<__VA_ARGS__>() {                                                    \
            return str;                                                                            \
        }                                                                                          \
    }                                                                                              \
    static_assert(true, "")

#define DOCTEST_TYPE_TO_STRING(...) DOCTEST_TYPE_TO_STRING_AS(#__VA_ARGS__, __VA_ARGS__)

#define DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL(dec, T, iter, func)                                 \
    template <typename T>                                                                          \
    static void func();                                                                            \
    namespace { /* NOLINT */                                                                       \
        template <typename Tuple>                                                                  \
        struct iter;                                                                               \
        template <typename Type, typename... Rest>                                                 \
        struct iter<std::tuple<Type, Rest...>>                                                     \
        {                                                                                          \
            iter(const char* file, unsigned line, int index) {                                     \
                doctest::detail::regTest(doctest::detail::TestCase(func<Type>, file, line,         \
                                            doctest_detail_test_suite_ns::getCurrentTestSuite(),   \
                                            doctest::toString<Type>(),                             \
                                            int(line) * 1000 + index)                              \
                                         * dec);                                                   \
                iter<std::tuple<Rest...>>(file, line, index + 1);                                  \
            }                                                                                      \
        };                                                                                         \
        template <>                                                                                \
        struct iter<std::tuple<>>                                                                  \
        {                                                                                          \
            iter(const char*, unsigned, int) {}                                                    \
        };                                                                                         \
    }                                                                                              \
    template <typename T>                                                                          \
    static void func()

#define DOCTEST_TEST_CASE_TEMPLATE_DEFINE(dec, T, id)                                              \
    DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL(dec, T, DOCTEST_CAT(id, ITERATOR),                      \
                                           DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_))

#define DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(id, anon, ...)                                 \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_CAT(anon, DUMMY), /* NOLINT(cert-err58-cpp, fuchsia-statically-constructed-objects) */ \
        doctest::detail::instantiationHelper(                                                      \
            DOCTEST_CAT(id, ITERATOR)<__VA_ARGS__>(__FILE__, __LINE__, 0)))

#define DOCTEST_TEST_CASE_TEMPLATE_INVOKE(id, ...)                                                 \
    DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(id, DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_), std::tuple<__VA_ARGS__>) \
    static_assert(true, "")

#define DOCTEST_TEST_CASE_TEMPLATE_APPLY(id, ...)                                                  \
    DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(id, DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_), __VA_ARGS__) \
    static_assert(true, "")

#define DOCTEST_TEST_CASE_TEMPLATE_IMPL(dec, T, anon, ...)                                         \
    DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL(dec, T, DOCTEST_CAT(anon, ITERATOR), anon);             \
    DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(anon, anon, std::tuple<__VA_ARGS__>)               \
    template <typename T>                                                                          \
    static void anon()

#define DOCTEST_TEST_CASE_TEMPLATE(dec, T, ...)                                                    \
    DOCTEST_TEST_CASE_TEMPLATE_IMPL(dec, T, DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_), __VA_ARGS__)

// for subcases
#define DOCTEST_SUBCASE(name)                                                                      \
    if(const doctest::detail::Subcase & DOCTEST_ANONYMOUS(DOCTEST_ANON_SUBCASE_) DOCTEST_UNUSED =  \
               doctest::detail::Subcase(name, __FILE__, __LINE__))

// for grouping tests in test suites by using code blocks
#define DOCTEST_TEST_SUITE_IMPL(decorators, ns_name)                                               \
    namespace ns_name { namespace doctest_detail_test_suite_ns {                                   \
            static DOCTEST_NOINLINE doctest::detail::TestSuite& getCurrentTestSuite() noexcept {   \
                DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4640)                                      \
                DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wexit-time-destructors")                \
                DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wmissing-field-initializers")             \
                static doctest::detail::TestSuite data{};                                          \
                static bool                       inited = false;                                  \
                DOCTEST_MSVC_SUPPRESS_WARNING_POP                                                  \
                DOCTEST_CLANG_SUPPRESS_WARNING_POP                                                 \
                DOCTEST_GCC_SUPPRESS_WARNING_POP                                                   \
                if(!inited) {                                                                      \
                    data* decorators;                                                              \
                    inited = true;                                                                 \
                }                                                                                  \
                return data;                                                                       \
            }                                                                                      \
        }                                                                                          \
    }                                                                                              \
    namespace ns_name

#define DOCTEST_TEST_SUITE(decorators)                                                             \
    DOCTEST_TEST_SUITE_IMPL(decorators, DOCTEST_ANONYMOUS(DOCTEST_ANON_SUITE_))

// for starting a testsuite block
#define DOCTEST_TEST_SUITE_BEGIN(decorators)                                                       \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_VAR_), /* NOLINT(cert-err58-cpp) */  \
            doctest::detail::setTestSuite(doctest::detail::TestSuite() * decorators))              \
    static_assert(true, "")

// for ending a testsuite block
#define DOCTEST_TEST_SUITE_END                                                                     \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_VAR_), /* NOLINT(cert-err58-cpp) */  \
            doctest::detail::setTestSuite(doctest::detail::TestSuite() * ""))                      \
    using DOCTEST_ANONYMOUS(DOCTEST_ANON_FOR_SEMICOLON_) = int

// for registering exception translators
#define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR_IMPL(translatorName, signature)                      \
    inline doctest::String translatorName(signature);                                              \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_TRANSLATOR_), /* NOLINT(cert-err58-cpp) */ \
            doctest::registerExceptionTranslator(translatorName))                                  \
    doctest::String translatorName(signature)

#define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR(signature)                                           \
    DOCTEST_REGISTER_EXCEPTION_TRANSLATOR_IMPL(DOCTEST_ANONYMOUS(DOCTEST_ANON_TRANSLATOR_),        \
                                               signature)

// for registering reporters
#define DOCTEST_REGISTER_REPORTER(name, priority, reporter)                                        \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_REPORTER_), /* NOLINT(cert-err58-cpp) */ \
            doctest::registerReporter<reporter>(name, priority, true))                             \
    static_assert(true, "")

// for registering listeners
#define DOCTEST_REGISTER_LISTENER(name, priority, reporter)                                        \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_REPORTER_), /* NOLINT(cert-err58-cpp) */ \
            doctest::registerReporter<reporter>(name, priority, false))                            \
    static_assert(true, "")

// clang-format off
// for logging - disabling formatting because it's important to have these on 2 separate lines - see PR #557
#define DOCTEST_INFO(...)                                                                          \
    DOCTEST_INFO_IMPL(DOCTEST_ANONYMOUS(DOCTEST_CAPTURE_),                                         \
                      DOCTEST_ANONYMOUS(DOCTEST_CAPTURE_OTHER_),                                   \
                      __VA_ARGS__)
// clang-format on

#define DOCTEST_INFO_IMPL(mb_name, s_name, ...)                                       \
    auto DOCTEST_ANONYMOUS(DOCTEST_CAPTURE_) = doctest::detail::MakeContextScope(                  \
        [&](std::ostream* s_name) {                                                                \
        doctest::detail::MessageBuilder mb_name(__FILE__, __LINE__, doctest::assertType::is_warn); \
        mb_name.m_stream = s_name;                                                                 \
        mb_name * __VA_ARGS__;                                                                     \
    })

#define DOCTEST_CAPTURE(x) DOCTEST_INFO(#x " := ", x)

#define DOCTEST_ADD_AT_IMPL(type, file, line, mb, ...)                                             \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        doctest::detail::MessageBuilder mb(file, line, doctest::assertType::type);                 \
        mb * __VA_ARGS__;                                                                          \
        if(mb.log())                                                                               \
            DOCTEST_BREAK_INTO_DEBUGGER();                                                         \
        mb.react();                                                                                \
    } DOCTEST_FUNC_SCOPE_END

// clang-format off
#define DOCTEST_ADD_MESSAGE_AT(file, line, ...) DOCTEST_ADD_AT_IMPL(is_warn, file, line, DOCTEST_ANONYMOUS(DOCTEST_MESSAGE_), __VA_ARGS__)
#define DOCTEST_ADD_FAIL_CHECK_AT(file, line, ...) DOCTEST_ADD_AT_IMPL(is_check, file, line, DOCTEST_ANONYMOUS(DOCTEST_MESSAGE_), __VA_ARGS__)
#define DOCTEST_ADD_FAIL_AT(file, line, ...) DOCTEST_ADD_AT_IMPL(is_require, file, line, DOCTEST_ANONYMOUS(DOCTEST_MESSAGE_), __VA_ARGS__)
// clang-format on

#define DOCTEST_MESSAGE(...) DOCTEST_ADD_MESSAGE_AT(__FILE__, __LINE__, __VA_ARGS__)
#define DOCTEST_FAIL_CHECK(...) DOCTEST_ADD_FAIL_CHECK_AT(__FILE__, __LINE__, __VA_ARGS__)
#define DOCTEST_FAIL(...) DOCTEST_ADD_FAIL_AT(__FILE__, __LINE__, __VA_ARGS__)

#define DOCTEST_TO_LVALUE(...) __VA_ARGS__ // Not removed to keep backwards compatibility.

#ifndef DOCTEST_CONFIG_SUPER_FAST_ASSERTS

#define DOCTEST_ASSERT_IMPLEMENT_2(assert_type, ...)                                               \
    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Woverloaded-shift-op-parentheses")                  \
    /* NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks) */                                  \
    doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,          \
                                               __LINE__, #__VA_ARGS__);                            \
    DOCTEST_WRAP_IN_TRY(DOCTEST_RB.setResult(                                                      \
            doctest::detail::ExpressionDecomposer(doctest::assertType::assert_type)                \
            << __VA_ARGS__)) /* NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks) */         \
    DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB)                                                    \
    DOCTEST_CLANG_SUPPRESS_WARNING_POP

#define DOCTEST_ASSERT_IMPLEMENT_1(assert_type, ...)                                               \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        DOCTEST_ASSERT_IMPLEMENT_2(assert_type, __VA_ARGS__);                                      \
    } DOCTEST_FUNC_SCOPE_END // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks)

#define DOCTEST_BINARY_ASSERT(assert_type, comp, ...)                                              \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,      \
                                                   __LINE__, #__VA_ARGS__);                        \
        DOCTEST_WRAP_IN_TRY(                                                                       \
                DOCTEST_RB.binary_assert<doctest::detail::binaryAssertComparison::comp>(           \
                        __VA_ARGS__))                                                              \
        DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB);                                               \
    } DOCTEST_FUNC_SCOPE_END

#define DOCTEST_UNARY_ASSERT(assert_type, ...)                                                     \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,      \
                                                   __LINE__, #__VA_ARGS__);                        \
        DOCTEST_WRAP_IN_TRY(DOCTEST_RB.unary_assert(__VA_ARGS__))                                  \
        DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB);                                               \
    } DOCTEST_FUNC_SCOPE_END

#else // DOCTEST_CONFIG_SUPER_FAST_ASSERTS

// necessary for <ASSERT>_MESSAGE
#define DOCTEST_ASSERT_IMPLEMENT_2 DOCTEST_ASSERT_IMPLEMENT_1

#define DOCTEST_ASSERT_IMPLEMENT_1(assert_type, ...)                                               \
    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Woverloaded-shift-op-parentheses")                  \
    doctest::detail::decomp_assert(                                                                \
            doctest::assertType::assert_type, __FILE__, __LINE__, #__VA_ARGS__,                    \
            doctest::detail::ExpressionDecomposer(doctest::assertType::assert_type)                \
                    << __VA_ARGS__) DOCTEST_CLANG_SUPPRESS_WARNING_POP

#define DOCTEST_BINARY_ASSERT(assert_type, comparison, ...)                                        \
    doctest::detail::binary_assert<doctest::detail::binaryAssertComparison::comparison>(           \
            doctest::assertType::assert_type, __FILE__, __LINE__, #__VA_ARGS__, __VA_ARGS__)

#define DOCTEST_UNARY_ASSERT(assert_type, ...)                                                     \
    doctest::detail::unary_assert(doctest::assertType::assert_type, __FILE__, __LINE__,            \
                                  #__VA_ARGS__, __VA_ARGS__)

#endif // DOCTEST_CONFIG_SUPER_FAST_ASSERTS

#define DOCTEST_WARN(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_WARN, __VA_ARGS__)
#define DOCTEST_CHECK(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_CHECK, __VA_ARGS__)
#define DOCTEST_REQUIRE(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_REQUIRE, __VA_ARGS__)
#define DOCTEST_WARN_FALSE(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_WARN_FALSE, __VA_ARGS__)
#define DOCTEST_CHECK_FALSE(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_CHECK_FALSE, __VA_ARGS__)
#define DOCTEST_REQUIRE_FALSE(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_REQUIRE_FALSE, __VA_ARGS__)

// clang-format off
#define DOCTEST_WARN_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_WARN, cond); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_CHECK, cond); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_REQUIRE, cond); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_WARN_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_WARN_FALSE, cond); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_CHECK_FALSE, cond); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_REQUIRE_FALSE, cond); } DOCTEST_FUNC_SCOPE_END
// clang-format on

#define DOCTEST_WARN_EQ(...) DOCTEST_BINARY_ASSERT(DT_WARN_EQ, eq, __VA_ARGS__)
#define DOCTEST_CHECK_EQ(...) DOCTEST_BINARY_ASSERT(DT_CHECK_EQ, eq, __VA_ARGS__)
#define DOCTEST_REQUIRE_EQ(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_EQ, eq, __VA_ARGS__)
#define DOCTEST_WARN_NE(...) DOCTEST_BINARY_ASSERT(DT_WARN_NE, ne, __VA_ARGS__)
#define DOCTEST_CHECK_NE(...) DOCTEST_BINARY_ASSERT(DT_CHECK_NE, ne, __VA_ARGS__)
#define DOCTEST_REQUIRE_NE(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_NE, ne, __VA_ARGS__)
#define DOCTEST_WARN_GT(...) DOCTEST_BINARY_ASSERT(DT_WARN_GT, gt, __VA_ARGS__)
#define DOCTEST_CHECK_GT(...) DOCTEST_BINARY_ASSERT(DT_CHECK_GT, gt, __VA_ARGS__)
#define DOCTEST_REQUIRE_GT(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_GT, gt, __VA_ARGS__)
#define DOCTEST_WARN_LT(...) DOCTEST_BINARY_ASSERT(DT_WARN_LT, lt, __VA_ARGS__)
#define DOCTEST_CHECK_LT(...) DOCTEST_BINARY_ASSERT(DT_CHECK_LT, lt, __VA_ARGS__)
#define DOCTEST_REQUIRE_LT(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_LT, lt, __VA_ARGS__)
#define DOCTEST_WARN_GE(...) DOCTEST_BINARY_ASSERT(DT_WARN_GE, ge, __VA_ARGS__)
#define DOCTEST_CHECK_GE(...) DOCTEST_BINARY_ASSERT(DT_CHECK_GE, ge, __VA_ARGS__)
#define DOCTEST_REQUIRE_GE(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_GE, ge, __VA_ARGS__)
#define DOCTEST_WARN_LE(...) DOCTEST_BINARY_ASSERT(DT_WARN_LE, le, __VA_ARGS__)
#define DOCTEST_CHECK_LE(...) DOCTEST_BINARY_ASSERT(DT_CHECK_LE, le, __VA_ARGS__)
#define DOCTEST_REQUIRE_LE(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_LE, le, __VA_ARGS__)

#define DOCTEST_WARN_UNARY(...) DOCTEST_UNARY_ASSERT(DT_WARN_UNARY, __VA_ARGS__)
#define DOCTEST_CHECK_UNARY(...) DOCTEST_UNARY_ASSERT(DT_CHECK_UNARY, __VA_ARGS__)
#define DOCTEST_REQUIRE_UNARY(...) DOCTEST_UNARY_ASSERT(DT_REQUIRE_UNARY, __VA_ARGS__)
#define DOCTEST_WARN_UNARY_FALSE(...) DOCTEST_UNARY_ASSERT(DT_WARN_UNARY_FALSE, __VA_ARGS__)
#define DOCTEST_CHECK_UNARY_FALSE(...) DOCTEST_UNARY_ASSERT(DT_CHECK_UNARY_FALSE, __VA_ARGS__)
#define DOCTEST_REQUIRE_UNARY_FALSE(...) DOCTEST_UNARY_ASSERT(DT_REQUIRE_UNARY_FALSE, __VA_ARGS__)

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS

#define DOCTEST_ASSERT_THROWS_AS(expr, assert_type, message, ...)                                  \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        if(!doctest::getContextOptions()->no_throw) {                                              \
            doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,  \
                                                       __LINE__, #expr, #__VA_ARGS__, message);    \
            try {                                                                                  \
                DOCTEST_CAST_TO_VOID(expr)                                                         \
            } catch(const typename doctest::detail::types::remove_const<                           \
                    typename doctest::detail::types::remove_reference<__VA_ARGS__>::type>::type&) {\
                DOCTEST_RB.translateException();                                                   \
                DOCTEST_RB.m_threw_as = true;                                                      \
            } catch(...) { DOCTEST_RB.translateException(); }                                      \
            DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB);                                           \
        } else { /* NOLINT(*-else-after-return) */                                                 \
            DOCTEST_FUNC_SCOPE_RET(false);                                                         \
        }                                                                                          \
    } DOCTEST_FUNC_SCOPE_END

#define DOCTEST_ASSERT_THROWS_WITH(expr, expr_str, assert_type, ...)                               \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        if(!doctest::getContextOptions()->no_throw) {                                              \
            doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,  \
                                                       __LINE__, expr_str, "", __VA_ARGS__);       \
            try {                                                                                  \
                DOCTEST_CAST_TO_VOID(expr)                                                         \
            } catch(...) { DOCTEST_RB.translateException(); }                                      \
            DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB);                                           \
        } else { /* NOLINT(*-else-after-return) */                                                 \
           DOCTEST_FUNC_SCOPE_RET(false);                                                          \
        }                                                                                          \
    } DOCTEST_FUNC_SCOPE_END

#define DOCTEST_ASSERT_NOTHROW(assert_type, ...)                                                   \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,      \
                                                   __LINE__, #__VA_ARGS__);                        \
        try {                                                                                      \
            DOCTEST_CAST_TO_VOID(__VA_ARGS__)                                                      \
        } catch(...) { DOCTEST_RB.translateException(); }                                          \
        DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB);                                               \
    } DOCTEST_FUNC_SCOPE_END

// clang-format off
#define DOCTEST_WARN_THROWS(...) DOCTEST_ASSERT_THROWS_WITH((__VA_ARGS__), #__VA_ARGS__, DT_WARN_THROWS, "")
#define DOCTEST_CHECK_THROWS(...) DOCTEST_ASSERT_THROWS_WITH((__VA_ARGS__), #__VA_ARGS__, DT_CHECK_THROWS, "")
#define DOCTEST_REQUIRE_THROWS(...) DOCTEST_ASSERT_THROWS_WITH((__VA_ARGS__), #__VA_ARGS__, DT_REQUIRE_THROWS, "")

#define DOCTEST_WARN_THROWS_AS(expr, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_WARN_THROWS_AS, "", __VA_ARGS__)
#define DOCTEST_CHECK_THROWS_AS(expr, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_CHECK_THROWS_AS, "", __VA_ARGS__)
#define DOCTEST_REQUIRE_THROWS_AS(expr, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_REQUIRE_THROWS_AS, "", __VA_ARGS__)

#define DOCTEST_WARN_THROWS_WITH(expr, ...) DOCTEST_ASSERT_THROWS_WITH(expr, #expr, DT_WARN_THROWS_WITH, __VA_ARGS__)
#define DOCTEST_CHECK_THROWS_WITH(expr, ...) DOCTEST_ASSERT_THROWS_WITH(expr, #expr, DT_CHECK_THROWS_WITH, __VA_ARGS__)
#define DOCTEST_REQUIRE_THROWS_WITH(expr, ...) DOCTEST_ASSERT_THROWS_WITH(expr, #expr, DT_REQUIRE_THROWS_WITH, __VA_ARGS__)

#define DOCTEST_WARN_THROWS_WITH_AS(expr, message, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_WARN_THROWS_WITH_AS, message, __VA_ARGS__)
#define DOCTEST_CHECK_THROWS_WITH_AS(expr, message, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_CHECK_THROWS_WITH_AS, message, __VA_ARGS__)
#define DOCTEST_REQUIRE_THROWS_WITH_AS(expr, message, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_REQUIRE_THROWS_WITH_AS, message, __VA_ARGS__)

#define DOCTEST_WARN_NOTHROW(...) DOCTEST_ASSERT_NOTHROW(DT_WARN_NOTHROW, __VA_ARGS__)
#define DOCTEST_CHECK_NOTHROW(...) DOCTEST_ASSERT_NOTHROW(DT_CHECK_NOTHROW, __VA_ARGS__)
#define DOCTEST_REQUIRE_NOTHROW(...) DOCTEST_ASSERT_NOTHROW(DT_REQUIRE_NOTHROW, __VA_ARGS__)

#define DOCTEST_WARN_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_THROWS(expr); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_THROWS(expr); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_THROWS(expr); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_THROWS_AS(expr, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_THROWS_AS(expr, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_THROWS_AS(expr, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_THROWS_WITH(expr, with); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_THROWS_WITH(expr, with); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_THROWS_WITH(expr, with); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_THROWS_WITH_AS(expr, with, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_THROWS_WITH_AS(expr, with, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_WARN_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_NOTHROW(expr); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_NOTHROW(expr); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_NOTHROW(expr); } DOCTEST_FUNC_SCOPE_END
// clang-format on

#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

// =================================================================================================
// == WHAT FOLLOWS IS VERSIONS OF THE MACROS THAT DO NOT DO ANY REGISTERING!                      ==
// == THIS CAN BE ENABLED BY DEFINING DOCTEST_CONFIG_DISABLE GLOBALLY!                            ==
// =================================================================================================
#else // DOCTEST_CONFIG_DISABLE

#define DOCTEST_IMPLEMENT_FIXTURE(der, base, func, name)                                           \
    namespace /* NOLINT */ {                                                                       \
        template <typename DOCTEST_UNUSED_TEMPLATE_TYPE>                                           \
        struct der : public base                                                                   \
        { void f(); };                                                                             \
    }                                                                                              \
    template <typename DOCTEST_UNUSED_TEMPLATE_TYPE>                                               \
    inline void der<DOCTEST_UNUSED_TEMPLATE_TYPE>::f()

#define DOCTEST_CREATE_AND_REGISTER_FUNCTION(f, name)                                              \
    template <typename DOCTEST_UNUSED_TEMPLATE_TYPE>                                               \
    static inline void f()

// for registering tests
#define DOCTEST_TEST_CASE(name)                                                                    \
    DOCTEST_CREATE_AND_REGISTER_FUNCTION(DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_), name)

// for registering tests in classes
#define DOCTEST_TEST_CASE_CLASS(name)                                                              \
    DOCTEST_CREATE_AND_REGISTER_FUNCTION(DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_), name)

// for registering tests with a fixture
#define DOCTEST_TEST_CASE_FIXTURE(x, name)                                                         \
    DOCTEST_IMPLEMENT_FIXTURE(DOCTEST_ANONYMOUS(DOCTEST_ANON_CLASS_), x,                           \
                              DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_), name)

// for converting types to strings without the <typeinfo> header and demangling
#define DOCTEST_TYPE_TO_STRING_AS(str, ...) static_assert(true, "")
#define DOCTEST_TYPE_TO_STRING(...) static_assert(true, "")

// for typed tests
#define DOCTEST_TEST_CASE_TEMPLATE(name, type, ...)                                                \
    template <typename type>                                                                       \
    inline void DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_)()

#define DOCTEST_TEST_CASE_TEMPLATE_DEFINE(name, type, id)                                          \
    template <typename type>                                                                       \
    inline void DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_)()

#define DOCTEST_TEST_CASE_TEMPLATE_INVOKE(id, ...) static_assert(true, "")
#define DOCTEST_TEST_CASE_TEMPLATE_APPLY(id, ...) static_assert(true, "")

// for subcases
#define DOCTEST_SUBCASE(name)

// for a testsuite block
#define DOCTEST_TEST_SUITE(name) namespace // NOLINT

// for starting a testsuite block
#define DOCTEST_TEST_SUITE_BEGIN(name) static_assert(true, "")

// for ending a testsuite block
#define DOCTEST_TEST_SUITE_END using DOCTEST_ANONYMOUS(DOCTEST_ANON_FOR_SEMICOLON_) = int

#define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR(signature)                                           \
    template <typename DOCTEST_UNUSED_TEMPLATE_TYPE>                                               \
    static inline doctest::String DOCTEST_ANONYMOUS(DOCTEST_ANON_TRANSLATOR_)(signature)

#define DOCTEST_REGISTER_REPORTER(name, priority, reporter)
#define DOCTEST_REGISTER_LISTENER(name, priority, reporter)

#define DOCTEST_INFO(...) (static_cast<void>(0))
#define DOCTEST_CAPTURE(x) (static_cast<void>(0))
#define DOCTEST_ADD_MESSAGE_AT(file, line, ...) (static_cast<void>(0))
#define DOCTEST_ADD_FAIL_CHECK_AT(file, line, ...) (static_cast<void>(0))
#define DOCTEST_ADD_FAIL_AT(file, line, ...) (static_cast<void>(0))
#define DOCTEST_MESSAGE(...) (static_cast<void>(0))
#define DOCTEST_FAIL_CHECK(...) (static_cast<void>(0))
#define DOCTEST_FAIL(...) (static_cast<void>(0))

#if defined(DOCTEST_CONFIG_EVALUATE_ASSERTS_EVEN_WHEN_DISABLED)                                    \
 && defined(DOCTEST_CONFIG_ASSERTS_RETURN_VALUES)

#define DOCTEST_WARN(...) [&] { return __VA_ARGS__; }()
#define DOCTEST_CHECK(...) [&] { return __VA_ARGS__; }()
#define DOCTEST_REQUIRE(...) [&] { return __VA_ARGS__; }()
#define DOCTEST_WARN_FALSE(...) [&] { return !(__VA_ARGS__); }()
#define DOCTEST_CHECK_FALSE(...) [&] { return !(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_FALSE(...) [&] { return !(__VA_ARGS__); }()

#define DOCTEST_WARN_MESSAGE(cond, ...) [&] { return cond; }()
#define DOCTEST_CHECK_MESSAGE(cond, ...) [&] { return cond; }()
#define DOCTEST_REQUIRE_MESSAGE(cond, ...) [&] { return cond; }()
#define DOCTEST_WARN_FALSE_MESSAGE(cond, ...) [&] { return !(cond); }()
#define DOCTEST_CHECK_FALSE_MESSAGE(cond, ...) [&] { return !(cond); }()
#define DOCTEST_REQUIRE_FALSE_MESSAGE(cond, ...) [&] { return !(cond); }()

namespace doctest {
namespace detail {
#define DOCTEST_RELATIONAL_OP(name, op)                                                            \
    template <typename L, typename R>                                                              \
    bool name(const DOCTEST_REF_WRAP(L) lhs, const DOCTEST_REF_WRAP(R) rhs) { return lhs op rhs; }

    DOCTEST_RELATIONAL_OP(eq, ==)
    DOCTEST_RELATIONAL_OP(ne, !=)
    DOCTEST_RELATIONAL_OP(lt, <)
    DOCTEST_RELATIONAL_OP(gt, >)
    DOCTEST_RELATIONAL_OP(le, <=)
    DOCTEST_RELATIONAL_OP(ge, >=)
} // namespace detail
} // namespace doctest

#define DOCTEST_WARN_EQ(...) [&] { return doctest::detail::eq(__VA_ARGS__); }()
#define DOCTEST_CHECK_EQ(...) [&] { return doctest::detail::eq(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_EQ(...) [&] { return doctest::detail::eq(__VA_ARGS__); }()
#define DOCTEST_WARN_NE(...) [&] { return doctest::detail::ne(__VA_ARGS__); }()
#define DOCTEST_CHECK_NE(...) [&] { return doctest::detail::ne(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_NE(...) [&] { return doctest::detail::ne(__VA_ARGS__); }()
#define DOCTEST_WARN_LT(...) [&] { return doctest::detail::lt(__VA_ARGS__); }()
#define DOCTEST_CHECK_LT(...) [&] { return doctest::detail::lt(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_LT(...) [&] { return doctest::detail::lt(__VA_ARGS__); }()
#define DOCTEST_WARN_GT(...) [&] { return doctest::detail::gt(__VA_ARGS__); }()
#define DOCTEST_CHECK_GT(...) [&] { return doctest::detail::gt(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_GT(...) [&] { return doctest::detail::gt(__VA_ARGS__); }()
#define DOCTEST_WARN_LE(...) [&] { return doctest::detail::le(__VA_ARGS__); }()
#define DOCTEST_CHECK_LE(...) [&] { return doctest::detail::le(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_LE(...) [&] { return doctest::detail::le(__VA_ARGS__); }()
#define DOCTEST_WARN_GE(...) [&] { return doctest::detail::ge(__VA_ARGS__); }()
#define DOCTEST_CHECK_GE(...) [&] { return doctest::detail::ge(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_GE(...) [&] { return doctest::detail::ge(__VA_ARGS__); }()
#define DOCTEST_WARN_UNARY(...) [&] { return __VA_ARGS__; }()
#define DOCTEST_CHECK_UNARY(...) [&] { return __VA_ARGS__; }()
#define DOCTEST_REQUIRE_UNARY(...) [&] { return __VA_ARGS__; }()
#define DOCTEST_WARN_UNARY_FALSE(...) [&] { return !(__VA_ARGS__); }()
#define DOCTEST_CHECK_UNARY_FALSE(...) [&] { return !(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_UNARY_FALSE(...) [&] { return !(__VA_ARGS__); }()

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS

#define DOCTEST_WARN_THROWS_WITH(expr, with, ...) [] { static_assert(false, "Exception translation is not available when doctest is disabled."); return false; }()
#define DOCTEST_CHECK_THROWS_WITH(expr, with, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_REQUIRE_THROWS_WITH(expr, with, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_WARN_THROWS_WITH_AS(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_CHECK_THROWS_WITH_AS(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)

#define DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)

#define DOCTEST_WARN_THROWS(...) [&] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_CHECK_THROWS(...) [&] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_REQUIRE_THROWS(...) [&] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_WARN_THROWS_AS(expr, ...) [&] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_CHECK_THROWS_AS(expr, ...) [&] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_REQUIRE_THROWS_AS(expr, ...) [&] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_WARN_NOTHROW(...) [&] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()
#define DOCTEST_CHECK_NOTHROW(...) [&] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()
#define DOCTEST_REQUIRE_NOTHROW(...) [&] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()

#define DOCTEST_WARN_THROWS_MESSAGE(expr, ...) [&] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_CHECK_THROWS_MESSAGE(expr, ...) [&] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, ...) [&] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, ...) [&] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, ...) [&] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) [&] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_WARN_NOTHROW_MESSAGE(expr, ...) [&] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()
#define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, ...) [&] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()
#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, ...) [&] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()

#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

#else // DOCTEST_CONFIG_EVALUATE_ASSERTS_EVEN_WHEN_DISABLED

#define DOCTEST_WARN(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_FALSE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_FALSE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_FALSE(...) DOCTEST_FUNC_EMPTY

#define DOCTEST_WARN_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY

#define DOCTEST_WARN_EQ(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_EQ(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_EQ(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_NE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_NE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_NE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_GT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_GT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_GT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_LT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_LT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_LT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_GE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_GE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_GE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_LE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_LE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_LE(...) DOCTEST_FUNC_EMPTY

#define DOCTEST_WARN_UNARY(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_UNARY(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_UNARY(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_UNARY_FALSE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_UNARY_FALSE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_UNARY_FALSE(...) DOCTEST_FUNC_EMPTY

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS

#define DOCTEST_WARN_THROWS(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_AS(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_AS(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_AS(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_WITH(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_WITH(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_WITH(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_WITH_AS(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_WITH_AS(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_NOTHROW(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_NOTHROW(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_NOTHROW(...) DOCTEST_FUNC_EMPTY

#define DOCTEST_WARN_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY

#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

#endif // DOCTEST_CONFIG_EVALUATE_ASSERTS_EVEN_WHEN_DISABLED

#endif // DOCTEST_CONFIG_DISABLE

#ifdef DOCTEST_CONFIG_NO_EXCEPTIONS

#ifdef DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS
#define DOCTEST_EXCEPTION_EMPTY_FUNC DOCTEST_FUNC_EMPTY
#else // DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS
#define DOCTEST_EXCEPTION_EMPTY_FUNC [] { static_assert(false, "Exceptions are disabled! " \
    "Use DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS if you want to compile with exceptions disabled."); return false; }()

#undef DOCTEST_REQUIRE
#undef DOCTEST_REQUIRE_FALSE
#undef DOCTEST_REQUIRE_MESSAGE
#undef DOCTEST_REQUIRE_FALSE_MESSAGE
#undef DOCTEST_REQUIRE_EQ
#undef DOCTEST_REQUIRE_NE
#undef DOCTEST_REQUIRE_GT
#undef DOCTEST_REQUIRE_LT
#undef DOCTEST_REQUIRE_GE
#undef DOCTEST_REQUIRE_LE
#undef DOCTEST_REQUIRE_UNARY
#undef DOCTEST_REQUIRE_UNARY_FALSE

#define DOCTEST_REQUIRE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_FALSE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_MESSAGE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_FALSE_MESSAGE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_EQ DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_NE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_GT DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_LT DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_GE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_LE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_UNARY DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_UNARY_FALSE DOCTEST_EXCEPTION_EMPTY_FUNC

#endif // DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS

#define DOCTEST_WARN_THROWS(...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS(...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS(...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_AS(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_AS(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_AS(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_WITH(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_WITH(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_WITH(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_WITH_AS(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_WITH_AS(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_NOTHROW(...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_NOTHROW(...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_NOTHROW(...) DOCTEST_EXCEPTION_EMPTY_FUNC

#define DOCTEST_WARN_THROWS_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_NOTHROW_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC

#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

// clang-format off
// KEPT FOR BACKWARDS COMPATIBILITY - FORWARDING TO THE RIGHT MACROS
#define DOCTEST_FAST_WARN_EQ             DOCTEST_WARN_EQ
#define DOCTEST_FAST_CHECK_EQ            DOCTEST_CHECK_EQ
#define DOCTEST_FAST_REQUIRE_EQ          DOCTEST_REQUIRE_EQ
#define DOCTEST_FAST_WARN_NE             DOCTEST_WARN_NE
#define DOCTEST_FAST_CHECK_NE            DOCTEST_CHECK_NE
#define DOCTEST_FAST_REQUIRE_NE          DOCTEST_REQUIRE_NE
#define DOCTEST_FAST_WARN_GT             DOCTEST_WARN_GT
#define DOCTEST_FAST_CHECK_GT            DOCTEST_CHECK_GT
#define DOCTEST_FAST_REQUIRE_GT          DOCTEST_REQUIRE_GT
#define DOCTEST_FAST_WARN_LT             DOCTEST_WARN_LT
#define DOCTEST_FAST_CHECK_LT            DOCTEST_CHECK_LT
#define DOCTEST_FAST_REQUIRE_LT          DOCTEST_REQUIRE_LT
#define DOCTEST_FAST_WARN_GE             DOCTEST_WARN_GE
#define DOCTEST_FAST_CHECK_GE            DOCTEST_CHECK_GE
#define DOCTEST_FAST_REQUIRE_GE          DOCTEST_REQUIRE_GE
#define DOCTEST_FAST_WARN_LE             DOCTEST_WARN_LE
#define DOCTEST_FAST_CHECK_LE            DOCTEST_CHECK_LE
#define DOCTEST_FAST_REQUIRE_LE          DOCTEST_REQUIRE_LE

#define DOCTEST_FAST_WARN_UNARY          DOCTEST_WARN_UNARY
#define DOCTEST_FAST_CHECK_UNARY         DOCTEST_CHECK_UNARY
#define DOCTEST_FAST_REQUIRE_UNARY       DOCTEST_REQUIRE_UNARY
#define DOCTEST_FAST_WARN_UNARY_FALSE    DOCTEST_WARN_UNARY_FALSE
#define DOCTEST_FAST_CHECK_UNARY_FALSE   DOCTEST_CHECK_UNARY_FALSE
#define DOCTEST_FAST_REQUIRE_UNARY_FALSE DOCTEST_REQUIRE_UNARY_FALSE

#define DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE(id, ...) DOCTEST_TEST_CASE_TEMPLATE_INVOKE(id,__VA_ARGS__)
// clang-format on

// BDD style macros
// clang-format off
#define DOCTEST_SCENARIO(name) DOCTEST_TEST_CASE("  Scenario: " name)
#define DOCTEST_SCENARIO_CLASS(name) DOCTEST_TEST_CASE_CLASS("  Scenario: " name)
#define DOCTEST_SCENARIO_TEMPLATE(name, T, ...)  DOCTEST_TEST_CASE_TEMPLATE("  Scenario: " name, T, __VA_ARGS__)
#define DOCTEST_SCENARIO_TEMPLATE_DEFINE(name, T, id) DOCTEST_TEST_CASE_TEMPLATE_DEFINE("  Scenario: " name, T, id)

#define DOCTEST_GIVEN(name)     DOCTEST_SUBCASE("   Given: " name)
#define DOCTEST_WHEN(name)      DOCTEST_SUBCASE("    When: " name)
#define DOCTEST_AND_WHEN(name)  DOCTEST_SUBCASE("And when: " name)
#define DOCTEST_THEN(name)      DOCTEST_SUBCASE("    Then: " name)
#define DOCTEST_AND_THEN(name)  DOCTEST_SUBCASE("     And: " name)
// clang-format on

// == SHORT VERSIONS OF THE MACROS
#ifndef DOCTEST_CONFIG_NO_SHORT_MACRO_NAMES

#define TEST_CASE(name) DOCTEST_TEST_CASE(name)
#define TEST_CASE_CLASS(name) DOCTEST_TEST_CASE_CLASS(name)
#define TEST_CASE_FIXTURE(x, name) DOCTEST_TEST_CASE_FIXTURE(x, name)
#define TYPE_TO_STRING_AS(str, ...) DOCTEST_TYPE_TO_STRING_AS(str, __VA_ARGS__)
#define TYPE_TO_STRING(...) DOCTEST_TYPE_TO_STRING(__VA_ARGS__)
#define TEST_CASE_TEMPLATE(name, T, ...) DOCTEST_TEST_CASE_TEMPLATE(name, T, __VA_ARGS__)
#define TEST_CASE_TEMPLATE_DEFINE(name, T, id) DOCTEST_TEST_CASE_TEMPLATE_DEFINE(name, T, id)
#define TEST_CASE_TEMPLATE_INVOKE(id, ...) DOCTEST_TEST_CASE_TEMPLATE_INVOKE(id, __VA_ARGS__)
#define TEST_CASE_TEMPLATE_APPLY(id, ...) DOCTEST_TEST_CASE_TEMPLATE_APPLY(id, __VA_ARGS__)
#define SUBCASE(name) DOCTEST_SUBCASE(name)
#define TEST_SUITE(decorators) DOCTEST_TEST_SUITE(decorators)
#define TEST_SUITE_BEGIN(name) DOCTEST_TEST_SUITE_BEGIN(name)
#define TEST_SUITE_END DOCTEST_TEST_SUITE_END
#define REGISTER_EXCEPTION_TRANSLATOR(signature) DOCTEST_REGISTER_EXCEPTION_TRANSLATOR(signature)
#define REGISTER_REPORTER(name, priority, reporter) DOCTEST_REGISTER_REPORTER(name, priority, reporter)
#define REGISTER_LISTENER(name, priority, reporter) DOCTEST_REGISTER_LISTENER(name, priority, reporter)
#define INFO(...) DOCTEST_INFO(__VA_ARGS__)
#define CAPTURE(x) DOCTEST_CAPTURE(x)
#define ADD_MESSAGE_AT(file, line, ...) DOCTEST_ADD_MESSAGE_AT(file, line, __VA_ARGS__)
#define ADD_FAIL_CHECK_AT(file, line, ...) DOCTEST_ADD_FAIL_CHECK_AT(file, line, __VA_ARGS__)
#define ADD_FAIL_AT(file, line, ...) DOCTEST_ADD_FAIL_AT(file, line, __VA_ARGS__)
#define MESSAGE(...) DOCTEST_MESSAGE(__VA_ARGS__)
#define FAIL_CHECK(...) DOCTEST_FAIL_CHECK(__VA_ARGS__)
#define FAIL(...) DOCTEST_FAIL(__VA_ARGS__)
#define TO_LVALUE(...) DOCTEST_TO_LVALUE(__VA_ARGS__)

#define WARN(...) DOCTEST_WARN(__VA_ARGS__)
#define WARN_FALSE(...) DOCTEST_WARN_FALSE(__VA_ARGS__)
#define WARN_THROWS(...) DOCTEST_WARN_THROWS(__VA_ARGS__)
#define WARN_THROWS_AS(expr, ...) DOCTEST_WARN_THROWS_AS(expr, __VA_ARGS__)
#define WARN_THROWS_WITH(expr, ...) DOCTEST_WARN_THROWS_WITH(expr, __VA_ARGS__)
#define WARN_THROWS_WITH_AS(expr, with, ...) DOCTEST_WARN_THROWS_WITH_AS(expr, with, __VA_ARGS__)
#define WARN_NOTHROW(...) DOCTEST_WARN_NOTHROW(__VA_ARGS__)
#define CHECK(...) DOCTEST_CHECK(__VA_ARGS__)
#define CHECK_FALSE(...) DOCTEST_CHECK_FALSE(__VA_ARGS__)
#define CHECK_THROWS(...) DOCTEST_CHECK_THROWS(__VA_ARGS__)
#define CHECK_THROWS_AS(expr, ...) DOCTEST_CHECK_THROWS_AS(expr, __VA_ARGS__)
#define CHECK_THROWS_WITH(expr, ...) DOCTEST_CHECK_THROWS_WITH(expr, __VA_ARGS__)
#define CHECK_THROWS_WITH_AS(expr, with, ...) DOCTEST_CHECK_THROWS_WITH_AS(expr, with, __VA_ARGS__)
#define CHECK_NOTHROW(...) DOCTEST_CHECK_NOTHROW(__VA_ARGS__)
#define REQUIRE(...) DOCTEST_REQUIRE(__VA_ARGS__)
#define REQUIRE_FALSE(...) DOCTEST_REQUIRE_FALSE(__VA_ARGS__)
#define REQUIRE_THROWS(...) DOCTEST_REQUIRE_THROWS(__VA_ARGS__)
#define REQUIRE_THROWS_AS(expr, ...) DOCTEST_REQUIRE_THROWS_AS(expr, __VA_ARGS__)
#define REQUIRE_THROWS_WITH(expr, ...) DOCTEST_REQUIRE_THROWS_WITH(expr, __VA_ARGS__)
#define REQUIRE_THROWS_WITH_AS(expr, with, ...) DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, __VA_ARGS__)
#define REQUIRE_NOTHROW(...) DOCTEST_REQUIRE_NOTHROW(__VA_ARGS__)

#define WARN_MESSAGE(cond, ...) DOCTEST_WARN_MESSAGE(cond, __VA_ARGS__)
#define WARN_FALSE_MESSAGE(cond, ...) DOCTEST_WARN_FALSE_MESSAGE(cond, __VA_ARGS__)
#define WARN_THROWS_MESSAGE(expr, ...) DOCTEST_WARN_THROWS_MESSAGE(expr, __VA_ARGS__)
#define WARN_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, __VA_ARGS__)
#define WARN_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, __VA_ARGS__)
#define WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, __VA_ARGS__)
#define WARN_NOTHROW_MESSAGE(expr, ...) DOCTEST_WARN_NOTHROW_MESSAGE(expr, __VA_ARGS__)
#define CHECK_MESSAGE(cond, ...) DOCTEST_CHECK_MESSAGE(cond, __VA_ARGS__)
#define CHECK_FALSE_MESSAGE(cond, ...) DOCTEST_CHECK_FALSE_MESSAGE(cond, __VA_ARGS__)
#define CHECK_THROWS_MESSAGE(expr, ...) DOCTEST_CHECK_THROWS_MESSAGE(expr, __VA_ARGS__)
#define CHECK_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, __VA_ARGS__)
#define CHECK_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, __VA_ARGS__)
#define CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, __VA_ARGS__)
#define CHECK_NOTHROW_MESSAGE(expr, ...) DOCTEST_CHECK_NOTHROW_MESSAGE(expr, __VA_ARGS__)
#define REQUIRE_MESSAGE(cond, ...) DOCTEST_REQUIRE_MESSAGE(cond, __VA_ARGS__)
#define REQUIRE_FALSE_MESSAGE(cond, ...) DOCTEST_REQUIRE_FALSE_MESSAGE(cond, __VA_ARGS__)
#define REQUIRE_THROWS_MESSAGE(expr, ...) DOCTEST_REQUIRE_THROWS_MESSAGE(expr, __VA_ARGS__)
#define REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, __VA_ARGS__)
#define REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, __VA_ARGS__)
#define REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, __VA_ARGS__)
#define REQUIRE_NOTHROW_MESSAGE(expr, ...) DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, __VA_ARGS__)

#define SCENARIO(name) DOCTEST_SCENARIO(name)
#define SCENARIO_CLASS(name) DOCTEST_SCENARIO_CLASS(name)
#define SCENARIO_TEMPLATE(name, T, ...) DOCTEST_SCENARIO_TEMPLATE(name, T, __VA_ARGS__)
#define SCENARIO_TEMPLATE_DEFINE(name, T, id) DOCTEST_SCENARIO_TEMPLATE_DEFINE(name, T, id)
#define GIVEN(name) DOCTEST_GIVEN(name)
#define WHEN(name) DOCTEST_WHEN(name)
#define AND_WHEN(name) DOCTEST_AND_WHEN(name)
#define THEN(name) DOCTEST_THEN(name)
#define AND_THEN(name) DOCTEST_AND_THEN(name)

#define WARN_EQ(...) DOCTEST_WARN_EQ(__VA_ARGS__)
#define CHECK_EQ(...) DOCTEST_CHECK_EQ(__VA_ARGS__)
#define REQUIRE_EQ(...) DOCTEST_REQUIRE_EQ(__VA_ARGS__)
#define WARN_NE(...) DOCTEST_WARN_NE(__VA_ARGS__)
#define CHECK_NE(...) DOCTEST_CHECK_NE(__VA_ARGS__)
#define REQUIRE_NE(...) DOCTEST_REQUIRE_NE(__VA_ARGS__)
#define WARN_GT(...) DOCTEST_WARN_GT(__VA_ARGS__)
#define CHECK_GT(...) DOCTEST_CHECK_GT(__VA_ARGS__)
#define REQUIRE_GT(...) DOCTEST_REQUIRE_GT(__VA_ARGS__)
#define WARN_LT(...) DOCTEST_WARN_LT(__VA_ARGS__)
#define CHECK_LT(...) DOCTEST_CHECK_LT(__VA_ARGS__)
#define REQUIRE_LT(...) DOCTEST_REQUIRE_LT(__VA_ARGS__)
#define WARN_GE(...) DOCTEST_WARN_GE(__VA_ARGS__)
#define CHECK_GE(...) DOCTEST_CHECK_GE(__VA_ARGS__)
#define REQUIRE_GE(...) DOCTEST_REQUIRE_GE(__VA_ARGS__)
#define WARN_LE(...) DOCTEST_WARN_LE(__VA_ARGS__)
#define CHECK_LE(...) DOCTEST_CHECK_LE(__VA_ARGS__)
#define REQUIRE_LE(...) DOCTEST_REQUIRE_LE(__VA_ARGS__)
#define WARN_UNARY(...) DOCTEST_WARN_UNARY(__VA_ARGS__)
#define CHECK_UNARY(...) DOCTEST_CHECK_UNARY(__VA_ARGS__)
#define REQUIRE_UNARY(...) DOCTEST_REQUIRE_UNARY(__VA_ARGS__)
#define WARN_UNARY_FALSE(...) DOCTEST_WARN_UNARY_FALSE(__VA_ARGS__)
#define CHECK_UNARY_FALSE(...) DOCTEST_CHECK_UNARY_FALSE(__VA_ARGS__)
#define REQUIRE_UNARY_FALSE(...) DOCTEST_REQUIRE_UNARY_FALSE(__VA_ARGS__)

// KEPT FOR BACKWARDS COMPATIBILITY
#define FAST_WARN_EQ(...) DOCTEST_FAST_WARN_EQ(__VA_ARGS__)
#define FAST_CHECK_EQ(...) DOCTEST_FAST_CHECK_EQ(__VA_ARGS__)
#define FAST_REQUIRE_EQ(...) DOCTEST_FAST_REQUIRE_EQ(__VA_ARGS__)
#define FAST_WARN_NE(...) DOCTEST_FAST_WARN_NE(__VA_ARGS__)
#define FAST_CHECK_NE(...) DOCTEST_FAST_CHECK_NE(__VA_ARGS__)
#define FAST_REQUIRE_NE(...) DOCTEST_FAST_REQUIRE_NE(__VA_ARGS__)
#define FAST_WARN_GT(...) DOCTEST_FAST_WARN_GT(__VA_ARGS__)
#define FAST_CHECK_GT(...) DOCTEST_FAST_CHECK_GT(__VA_ARGS__)
#define FAST_REQUIRE_GT(...) DOCTEST_FAST_REQUIRE_GT(__VA_ARGS__)
#define FAST_WARN_LT(...) DOCTEST_FAST_WARN_LT(__VA_ARGS__)
#define FAST_CHECK_LT(...) DOCTEST_FAST_CHECK_LT(__VA_ARGS__)
#define FAST_REQUIRE_LT(...) DOCTEST_FAST_REQUIRE_LT(__VA_ARGS__)
#define FAST_WARN_GE(...) DOCTEST_FAST_WARN_GE(__VA_ARGS__)
#define FAST_CHECK_GE(...) DOCTEST_FAST_CHECK_GE(__VA_ARGS__)
#define FAST_REQUIRE_GE(...) DOCTEST_FAST_REQUIRE_GE(__VA_ARGS__)
#define FAST_WARN_LE(...) DOCTEST_FAST_WARN_LE(__VA_ARGS__)
#define FAST_CHECK_LE(...) DOCTEST_FAST_CHECK_LE(__VA_ARGS__)
#define FAST_REQUIRE_LE(...) DOCTEST_FAST_REQUIRE_LE(__VA_ARGS__)

#define FAST_WARN_UNARY(...) DOCTEST_FAST_WARN_UNARY(__VA_ARGS__)
#define FAST_CHECK_UNARY(...) DOCTEST_FAST_CHECK_UNARY(__VA_ARGS__)
#define FAST_REQUIRE_UNARY(...) DOCTEST_FAST_REQUIRE_UNARY(__VA_ARGS__)
#define FAST_WARN_UNARY_FALSE(...) DOCTEST_FAST_WARN_UNARY_FALSE(__VA_ARGS__)
#define FAST_CHECK_UNARY_FALSE(...) DOCTEST_FAST_CHECK_UNARY_FALSE(__VA_ARGS__)
#define FAST_REQUIRE_UNARY_FALSE(...) DOCTEST_FAST_REQUIRE_UNARY_FALSE(__VA_ARGS__)

#define TEST_CASE_TEMPLATE_INSTANTIATE(id, ...) DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE(id, __VA_ARGS__)

#endif // DOCTEST_CONFIG_NO_SHORT_MACRO_NAMES

#ifndef DOCTEST_CONFIG_DISABLE

// this is here to clear the 'current test suite' for the current translation unit - at the top
DOCTEST_TEST_SUITE_END();

#endif // DOCTEST_CONFIG_DISABLE

DOCTEST_CLANG_SUPPRESS_WARNING_POP
DOCTEST_MSVC_SUPPRESS_WARNING_POP
DOCTEST_GCC_SUPPRESS_WARNING_POP

DOCTEST_SUPPRESS_COMMON_WARNINGS_POP

#endif // DOCTEST_LIBRARY_INCLUDED

#ifndef DOCTEST_SINGLE_HEADER
#define DOCTEST_SINGLE_HEADER
#endif // DOCTEST_SINGLE_HEADER

#if defined(DOCTEST_CONFIG_IMPLEMENT) || !defined(DOCTEST_SINGLE_HEADER)

#ifndef DOCTEST_SINGLE_HEADER
#include "doctest_fwd.h"
#endif // DOCTEST_SINGLE_HEADER

DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wunused-macros")

#ifndef DOCTEST_LIBRARY_IMPLEMENTATION
#define DOCTEST_LIBRARY_IMPLEMENTATION

DOCTEST_CLANG_SUPPRESS_WARNING_POP

DOCTEST_SUPPRESS_COMMON_WARNINGS_PUSH

DOCTEST_CLANG_SUPPRESS_WARNING_PUSH
DOCTEST_CLANG_SUPPRESS_WARNING("-Wglobal-constructors")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wexit-time-destructors")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wsign-conversion")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wshorten-64-to-32")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-variable-declarations")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wswitch")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wswitch-enum")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wcovered-switch-default")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-noreturn")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wdisabled-macro-expansion")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-braces")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-field-initializers")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wunused-member-function")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wnonportable-system-include-path")

DOCTEST_GCC_SUPPRESS_WARNING_PUSH
DOCTEST_GCC_SUPPRESS_WARNING("-Wconversion")
DOCTEST_GCC_SUPPRESS_WARNING("-Wsign-conversion")
DOCTEST_GCC_SUPPRESS_WARNING("-Wmissing-field-initializers")
DOCTEST_GCC_SUPPRESS_WARNING("-Wmissing-braces")
DOCTEST_GCC_SUPPRESS_WARNING("-Wswitch")
DOCTEST_GCC_SUPPRESS_WARNING("-Wswitch-enum")
DOCTEST_GCC_SUPPRESS_WARNING("-Wswitch-default")
DOCTEST_GCC_SUPPRESS_WARNING("-Wunsafe-loop-optimizations")
DOCTEST_GCC_SUPPRESS_WARNING("-Wold-style-cast")
DOCTEST_GCC_SUPPRESS_WARNING("-Wunused-function")
DOCTEST_GCC_SUPPRESS_WARNING("-Wmultiple-inheritance")
DOCTEST_GCC_SUPPRESS_WARNING("-Wsuggest-attribute")

DOCTEST_MSVC_SUPPRESS_WARNING_PUSH
DOCTEST_MSVC_SUPPRESS_WARNING(4267) // 'var' : conversion from 'x' to 'y', possible loss of data
DOCTEST_MSVC_SUPPRESS_WARNING(4530) // C++ exception handler used, but unwind semantics not enabled
DOCTEST_MSVC_SUPPRESS_WARNING(4577) // 'noexcept' used with no exception handling mode specified
DOCTEST_MSVC_SUPPRESS_WARNING(4774) // format string expected in argument is not a string literal
DOCTEST_MSVC_SUPPRESS_WARNING(4365) // conversion from 'int' to 'unsigned', signed/unsigned mismatch
DOCTEST_MSVC_SUPPRESS_WARNING(5039) // pointer to potentially throwing function passed to extern C
DOCTEST_MSVC_SUPPRESS_WARNING(4800) // forcing value to bool 'true' or 'false' (performance warning)
DOCTEST_MSVC_SUPPRESS_WARNING(5245) // unreferenced function with internal linkage has been removed

DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN

// required includes - will go only in one translation unit!
#include <ctime>
#include <cmath>
#include <climits>
// borland (Embarcadero) compiler requires math.h and not cmath - https://github.com/doctest/doctest/pull/37
#ifdef __BORLANDC__
#include <math.h>
#endif // __BORLANDC__
#include <new>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <limits>
#include <utility>
#include <fstream>
#include <sstream>
#ifndef DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
#include <iostream>
#endif // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
#include <algorithm>
#include <iomanip>
#include <vector>
#ifndef DOCTEST_CONFIG_NO_MULTITHREADING
#include <atomic>
#include <mutex>
#define DOCTEST_DECLARE_MUTEX(name) std::mutex name;
#define DOCTEST_DECLARE_STATIC_MUTEX(name) static DOCTEST_DECLARE_MUTEX(name)
#define DOCTEST_LOCK_MUTEX(name) std::lock_guard<std::mutex> DOCTEST_ANONYMOUS(DOCTEST_ANON_LOCK_)(name);
#else // DOCTEST_CONFIG_NO_MULTITHREADING
#define DOCTEST_DECLARE_MUTEX(name)
#define DOCTEST_DECLARE_STATIC_MUTEX(name)
#define DOCTEST_LOCK_MUTEX(name)
#endif // DOCTEST_CONFIG_NO_MULTITHREADING
#include <set>
#include <map>
#include <unordered_set>
#include <exception>
#include <stdexcept>
#include <csignal>
#include <cfloat>
#include <cctype>
#include <cstdint>
#include <string>

#ifdef DOCTEST_PLATFORM_MAC
#include <sys/types.h>
#include <unistd.h>
#include <sys/sysctl.h>
#endif // DOCTEST_PLATFORM_MAC

#ifdef DOCTEST_PLATFORM_WINDOWS

// defines for a leaner windows.h
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#define DOCTEST_UNDEF_WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN
#ifndef NOMINMAX
#define NOMINMAX
#define DOCTEST_UNDEF_NOMINMAX
#endif // NOMINMAX

// not sure what AfxWin.h is for - here I do what Catch does
#ifdef __AFXDLL
#include <AfxWin.h>
#else
#include <windows.h>
#endif
#include <io.h>

#else // DOCTEST_PLATFORM_WINDOWS

#include <sys/time.h>
#include <unistd.h>

#endif // DOCTEST_PLATFORM_WINDOWS

// this is a fix for https://github.com/doctest/doctest/issues/348
// https://mail.gnome.org/archives/xml/2012-January/msg00000.html
#if !defined(HAVE_UNISTD_H) && !defined(STDOUT_FILENO)
#define STDOUT_FILENO fileno(stdout)
#endif // HAVE_UNISTD_H

DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END

// counts the number of elements in a C array
#define DOCTEST_COUNTOF(x) (sizeof(x) / sizeof(x[0]))

#ifdef DOCTEST_CONFIG_DISABLE
#define DOCTEST_BRANCH_ON_DISABLED(if_disabled, if_not_disabled) if_disabled
#else // DOCTEST_CONFIG_DISABLE
#define DOCTEST_BRANCH_ON_DISABLED(if_disabled, if_not_disabled) if_not_disabled
#endif // DOCTEST_CONFIG_DISABLE

#ifndef DOCTEST_CONFIG_OPTIONS_PREFIX
#define DOCTEST_CONFIG_OPTIONS_PREFIX "dt-"
#endif

#ifndef DOCTEST_CONFIG_OPTIONS_FILE_PREFIX_SEPARATOR
#define DOCTEST_CONFIG_OPTIONS_FILE_PREFIX_SEPARATOR ':'
#endif

#ifndef DOCTEST_THREAD_LOCAL
#if defined(DOCTEST_CONFIG_NO_MULTITHREADING) || DOCTEST_MSVC && (DOCTEST_MSVC < DOCTEST_COMPILER(19, 0, 0))
#define DOCTEST_THREAD_LOCAL
#else // DOCTEST_MSVC
#define DOCTEST_THREAD_LOCAL thread_local
#endif // DOCTEST_MSVC
#endif // DOCTEST_THREAD_LOCAL

#ifndef DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES
#define DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES 32
#endif

#ifndef DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE
#define DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE 64
#endif

#ifdef DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS
#define DOCTEST_OPTIONS_PREFIX_DISPLAY DOCTEST_CONFIG_OPTIONS_PREFIX
#else
#define DOCTEST_OPTIONS_PREFIX_DISPLAY ""
#endif

#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
#define DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS
#endif

#ifndef DOCTEST_CDECL
#define DOCTEST_CDECL __cdecl
#endif

namespace doctest {

bool is_running_in_test = false;

namespace {
    using namespace detail;

    template <typename Ex>
    DOCTEST_NORETURN void throw_exception(Ex const& e) {
#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
        throw e;
#else  // DOCTEST_CONFIG_NO_EXCEPTIONS
#ifdef DOCTEST_CONFIG_HANDLE_EXCEPTION
        DOCTEST_CONFIG_HANDLE_EXCEPTION(e);
#else // DOCTEST_CONFIG_HANDLE_EXCEPTION
#ifndef DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
        std::cerr << "doctest will terminate because it needed to throw an exception.\n"
                  << "The message was: " << e.what() << '\n';
#endif // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
#endif // DOCTEST_CONFIG_HANDLE_EXCEPTION
        std::terminate();
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
    }

#ifndef DOCTEST_INTERNAL_ERROR
#define DOCTEST_INTERNAL_ERROR(msg)                                                                \
    throw_exception(std::logic_error(                                                              \
            __FILE__ ":" DOCTEST_TOSTR(__LINE__) ": Internal doctest error: " msg))
#endif // DOCTEST_INTERNAL_ERROR

    // case insensitive strcmp
    int stricmp(const char* a, const char* b) {
        for(;; a++, b++) {
            const int d = tolower(*a) - tolower(*b);
            if(d != 0 || !*a)
                return d;
        }
    }

    struct Endianness
    {
        enum Arch
        {
            Big,
            Little
        };

        static Arch which() {
            int x = 1;
            // casting any data pointer to char* is allowed
            auto ptr = reinterpret_cast<char*>(&x);
            if(*ptr)
                return Little;
            return Big;
        }
    };
} // namespace

namespace detail {
    DOCTEST_THREAD_LOCAL class
    {
        std::vector<std::streampos> stack;
        std::stringstream           ss;

    public:
        std::ostream* push() {
            stack.push_back(ss.tellp());
            return &ss;
        }

        String pop() {
            if (stack.empty())
                DOCTEST_INTERNAL_ERROR("TLSS was empty when trying to pop!");

            std::streampos pos = stack.back();
            stack.pop_back();
            unsigned sz = static_cast<unsigned>(ss.tellp() - pos);
            ss.rdbuf()->pubseekpos(pos, std::ios::in | std::ios::out);
            return String(ss, sz);
        }
    } g_oss;

    std::ostream* tlssPush() {
        return g_oss.push();
    }

    String tlssPop() {
        return g_oss.pop();
    }

#ifndef DOCTEST_CONFIG_DISABLE

namespace timer_large_integer
{

#if defined(DOCTEST_PLATFORM_WINDOWS)
    using type = ULONGLONG;
#else // DOCTEST_PLATFORM_WINDOWS
    using type = std::uint64_t;
#endif // DOCTEST_PLATFORM_WINDOWS
}

using ticks_t = timer_large_integer::type;

#ifdef DOCTEST_CONFIG_GETCURRENTTICKS
    ticks_t getCurrentTicks() { return DOCTEST_CONFIG_GETCURRENTTICKS(); }
#elif defined(DOCTEST_PLATFORM_WINDOWS)
    ticks_t getCurrentTicks() {
        static LARGE_INTEGER hz = { {0} }, hzo = { {0} };
        if(!hz.QuadPart) {
            QueryPerformanceFrequency(&hz);
            QueryPerformanceCounter(&hzo);
        }
        LARGE_INTEGER t;
        QueryPerformanceCounter(&t);
        return ((t.QuadPart - hzo.QuadPart) * LONGLONG(1000000)) / hz.QuadPart;
    }
#else  // DOCTEST_PLATFORM_WINDOWS
    ticks_t getCurrentTicks() {
        timeval t;
        gettimeofday(&t, nullptr);
        return static_cast<ticks_t>(t.tv_sec) * 1000000 + static_cast<ticks_t>(t.tv_usec);
    }
#endif // DOCTEST_PLATFORM_WINDOWS

    struct Timer
    {
        void         start() { m_ticks = getCurrentTicks(); }
        unsigned int getElapsedMicroseconds() const {
            return static_cast<unsigned int>(getCurrentTicks() - m_ticks);
        }
        //unsigned int getElapsedMilliseconds() const {
        //    return static_cast<unsigned int>(getElapsedMicroseconds() / 1000);
        //}
        double getElapsedSeconds() const { return static_cast<double>(getCurrentTicks() - m_ticks) / 1000000.0; }

    private:
        ticks_t m_ticks = 0;
    };

#ifdef DOCTEST_CONFIG_NO_MULTITHREADING
    template <typename T>
    using Atomic = T;
#else // DOCTEST_CONFIG_NO_MULTITHREADING
    template <typename T>
    using Atomic = std::atomic<T>;
#endif // DOCTEST_CONFIG_NO_MULTITHREADING

#if defined(DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS) || defined(DOCTEST_CONFIG_NO_MULTITHREADING)
    template <typename T>
    using MultiLaneAtomic = Atomic<T>;
#else // DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS
    // Provides a multilane implementation of an atomic variable that supports add, sub, load,
    // store. Instead of using a single atomic variable, this splits up into multiple ones,
    // each sitting on a separate cache line. The goal is to provide a speedup when most
    // operations are modifying. It achieves this with two properties:
    //
    // * Multiple atomics are used, so chance of congestion from the same atomic is reduced.
    // * Each atomic sits on a separate cache line, so false sharing is reduced.
    //
    // The disadvantage is that there is a small overhead due to the use of TLS, and load/store
    // is slower because all atomics have to be accessed.
    template <typename T>
    class MultiLaneAtomic
    {
        struct CacheLineAlignedAtomic
        {
            Atomic<T> atomic{};
            char padding[DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE - sizeof(Atomic<T>)];
        };
        CacheLineAlignedAtomic m_atomics[DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES];

        static_assert(sizeof(CacheLineAlignedAtomic) == DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE,
                      "guarantee one atomic takes exactly one cache line");

    public:
        T operator++() DOCTEST_NOEXCEPT { return fetch_add(1) + 1; }

        T operator++(int) DOCTEST_NOEXCEPT { return fetch_add(1); }

        T fetch_add(T arg, std::memory_order order = std::memory_order_seq_cst) DOCTEST_NOEXCEPT {
            return myAtomic().fetch_add(arg, order);
        }

        T fetch_sub(T arg, std::memory_order order = std::memory_order_seq_cst) DOCTEST_NOEXCEPT {
            return myAtomic().fetch_sub(arg, order);
        }

        operator T() const DOCTEST_NOEXCEPT { return load(); }

        T load(std::memory_order order = std::memory_order_seq_cst) const DOCTEST_NOEXCEPT {
            auto result = T();
            for(auto const& c : m_atomics) {
                result += c.atomic.load(order);
            }
            return result;
        }

        T operator=(T desired) DOCTEST_NOEXCEPT { // lgtm [cpp/assignment-does-not-return-this]
            store(desired);
            return desired;
        }

        void store(T desired, std::memory_order order = std::memory_order_seq_cst) DOCTEST_NOEXCEPT {
            // first value becomes desired", all others become 0.
            for(auto& c : m_atomics) {
                c.atomic.store(desired, order);
                desired = {};
            }
        }

    private:
        // Each thread has a different atomic that it operates on. If more than NumLanes threads
        // use this, some will use the same atomic. So performance will degrade a bit, but still
        // everything will work.
        //
        // The logic here is a bit tricky. The call should be as fast as possible, so that there
        // is minimal to no overhead in determining the correct atomic for the current thread.
        //
        // 1. A global static counter laneCounter counts continuously up.
        // 2. Each successive thread will use modulo operation of that counter so it gets an atomic
        //    assigned in a round-robin fashion.
        // 3. This tlsLaneIdx is stored in the thread local data, so it is directly available with
        //    little overhead.
        Atomic<T>& myAtomic() DOCTEST_NOEXCEPT {
            static Atomic<size_t> laneCounter;
            DOCTEST_THREAD_LOCAL size_t tlsLaneIdx =
                    laneCounter++ % DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES;

            return m_atomics[tlsLaneIdx].atomic;
        }
    };
#endif // DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS

    // this holds both parameters from the command line and runtime data for tests
    struct ContextState : ContextOptions, TestRunStats, CurrentTestCaseStats
    {
        MultiLaneAtomic<int> numAssertsCurrentTest_atomic;
        MultiLaneAtomic<int> numAssertsFailedCurrentTest_atomic;

        std::vector<std::vector<String>> filters = decltype(filters)(9); // 9 different filters

        std::vector<IReporter*> reporters_currently_used;

        assert_handler ah = nullptr;

        Timer timer;

        std::vector<String> stringifiedContexts; // logging from INFO() due to an exception

        // stuff for subcases
        bool reachedLeaf;
        std::vector<SubcaseSignature> subcaseStack;
        std::vector<SubcaseSignature> nextSubcaseStack;
        std::unordered_set<unsigned long long> fullyTraversedSubcases;
        size_t currentSubcaseDepth;
        Atomic<bool> shouldLogCurrentException;

        void resetRunData() {
            numTestCases                = 0;
            numTestCasesPassingFilters  = 0;
            numTestSuitesPassingFilters = 0;
            numTestCasesFailed          = 0;
            numAsserts                  = 0;
            numAssertsFailed            = 0;
            numAssertsCurrentTest       = 0;
            numAssertsFailedCurrentTest = 0;
        }

        void finalizeTestCaseData() {
            seconds = timer.getElapsedSeconds();

            // update the non-atomic counters
            numAsserts += numAssertsCurrentTest_atomic;
            numAssertsFailed += numAssertsFailedCurrentTest_atomic;
            numAssertsCurrentTest       = numAssertsCurrentTest_atomic;
            numAssertsFailedCurrentTest = numAssertsFailedCurrentTest_atomic;

            if(numAssertsFailedCurrentTest)
                failure_flags |= TestCaseFailureReason::AssertFailure;

            if(Approx(currentTest->m_timeout).epsilon(DBL_EPSILON) != 0 &&
               Approx(seconds).epsilon(DBL_EPSILON) > currentTest->m_timeout)
                failure_flags |= TestCaseFailureReason::Timeout;

            if(currentTest->m_should_fail) {
                if(failure_flags) {
                    failure_flags |= TestCaseFailureReason::ShouldHaveFailedAndDid;
                } else {
                    failure_flags |= TestCaseFailureReason::ShouldHaveFailedButDidnt;
                }
            } else if(failure_flags && currentTest->m_may_fail) {
                failure_flags |= TestCaseFailureReason::CouldHaveFailedAndDid;
            } else if(currentTest->m_expected_failures > 0) {
                if(numAssertsFailedCurrentTest == currentTest->m_expected_failures) {
                    failure_flags |= TestCaseFailureReason::FailedExactlyNumTimes;
                } else {
                    failure_flags |= TestCaseFailureReason::DidntFailExactlyNumTimes;
                }
            }

            bool ok_to_fail = (TestCaseFailureReason::ShouldHaveFailedAndDid & failure_flags) ||
                              (TestCaseFailureReason::CouldHaveFailedAndDid & failure_flags) ||
                              (TestCaseFailureReason::FailedExactlyNumTimes & failure_flags);

            // if any subcase has failed - the whole test case has failed
            testCaseSuccess = !(failure_flags && !ok_to_fail);
            if(!testCaseSuccess)
                numTestCasesFailed++;
        }
    };

    ContextState* g_cs = nullptr;

    // used to avoid locks for the debug output
    // TODO: figure out if this is indeed necessary/correct - seems like either there still
    // could be a race or that there wouldn't be a race even if using the context directly
    DOCTEST_THREAD_LOCAL bool g_no_colors;

#endif // DOCTEST_CONFIG_DISABLE
} // namespace detail

char* String::allocate(size_type sz) {
    if (sz <= last) {
        buf[sz] = '\0';
        setLast(last - sz);
        return buf;
    } else {
        setOnHeap();
        data.size = sz;
        data.capacity = data.size + 1;
        data.ptr = new char[data.capacity];
        data.ptr[sz] = '\0';
        return data.ptr;
    }
}

void String::setOnHeap() noexcept { *reinterpret_cast<unsigned char*>(&buf[last]) = 128; }
void String::setLast(size_type in) noexcept { buf[last] = char(in); }
void String::setSize(size_type sz) noexcept {
    if (isOnStack()) { buf[sz] = '\0'; setLast(last - sz); }
    else { data.ptr[sz] = '\0'; data.size = sz; }
}

void String::copy(const String& other) {
    if(other.isOnStack()) {
        memcpy(buf, other.buf, len);
    } else {
        memcpy(allocate(other.data.size), other.data.ptr, other.data.size);
    }
}

String::String() noexcept {
    buf[0] = '\0';
    setLast();
}

String::~String() {
    if(!isOnStack())
        delete[] data.ptr;
} // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks)

String::String(const char* in)
        : String(in, strlen(in)) {}

String::String(const char* in, size_type in_size) {
    memcpy(allocate(in_size), in, in_size);
}

String::String(std::istream& in, size_type in_size) {
    in.read(allocate(in_size), in_size);
}

String::String(const String& other) { copy(other); }

String& String::operator=(const String& other) {
    if(this != &other) {
        if(!isOnStack())
            delete[] data.ptr;

        copy(other);
    }

    return *this;
}

String& String::operator+=(const String& other) {
    const size_type my_old_size = size();
    const size_type other_size  = other.size();
    const size_type total_size  = my_old_size + other_size;
    if(isOnStack()) {
        if(total_size < len) {
            // append to the current stack space
            memcpy(buf + my_old_size, other.c_str(), other_size + 1);
            // NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)
            setLast(last - total_size);
        } else {
            // alloc new chunk
            char* temp = new char[total_size + 1];
            // copy current data to new location before writing in the union
            memcpy(temp, buf, my_old_size); // skip the +1 ('\0') for speed
            // update data in union
            setOnHeap();
            data.size     = total_size;
            data.capacity = data.size + 1;
            data.ptr      = temp;
            // transfer the rest of the data
            memcpy(data.ptr + my_old_size, other.c_str(), other_size + 1);
        }
    } else {
        if(data.capacity > total_size) {
            // append to the current heap block
            data.size = total_size;
            memcpy(data.ptr + my_old_size, other.c_str(), other_size + 1);
        } else {
            // resize
            data.capacity *= 2;
            if(data.capacity <= total_size)
                data.capacity = total_size + 1;
            // alloc new chunk
            char* temp = new char[data.capacity];
            // copy current data to new location before releasing it
            memcpy(temp, data.ptr, my_old_size); // skip the +1 ('\0') for speed
            // release old chunk
            delete[] data.ptr;
            // update the rest of the union members
            data.size = total_size;
            data.ptr  = temp;
            // transfer the rest of the data
            memcpy(data.ptr + my_old_size, other.c_str(), other_size + 1);
        }
    }

    return *this;
}

String::String(String&& other) noexcept {
    memcpy(buf, other.buf, len);
    other.buf[0] = '\0';
    other.setLast();
}

String& String::operator=(String&& other) noexcept {
    if(this != &other) {
        if(!isOnStack())
            delete[] data.ptr;
        memcpy(buf, other.buf, len);
        other.buf[0] = '\0';
        other.setLast();
    }
    return *this;
}

char String::operator[](size_type i) const {
    return const_cast<String*>(this)->operator[](i);
}

char& String::operator[](size_type i) {
    if(isOnStack())
        return reinterpret_cast<char*>(buf)[i];
    return data.ptr[i];
}

DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wmaybe-uninitialized")
String::size_type String::size() const {
    if(isOnStack())
        return last - (size_type(buf[last]) & 31); // using "last" would work only if "len" is 32
    return data.size;
}
DOCTEST_GCC_SUPPRESS_WARNING_POP

String::size_type String::capacity() const {
    if(isOnStack())
        return len;
    return data.capacity;
}

String String::substr(size_type pos, size_type cnt) && {
    cnt = std::min(cnt, size() - pos);
    char* cptr = c_str();
    memmove(cptr, cptr + pos, cnt);
    setSize(cnt);
    return std::move(*this);
}

String String::substr(size_type pos, size_type cnt) const & {
    cnt = std::min(cnt, size() - pos);
    return String{ c_str() + pos, cnt };
}

String::size_type String::find(char ch, size_type pos) const {
    const char* begin = c_str();
    const char* end = begin + size();
    const char* it = begin + pos;
    for (; it < end && *it != ch; it++);
    if (it < end) { return static_cast<size_type>(it - begin); }
    else { return npos; }
}

String::size_type String::rfind(char ch, size_type pos) const {
    const char* begin = c_str();
    const char* it = begin + std::min(pos, size() - 1);
    for (; it >= begin && *it != ch; it--);
    if (it >= begin) { return static_cast<size_type>(it - begin); }
    else { return npos; }
}

int String::compare(const char* other, bool no_case) const {
    if(no_case)
        return doctest::stricmp(c_str(), other);
    return std::strcmp(c_str(), other);
}

int String::compare(const String& other, bool no_case) const {
    return compare(other.c_str(), no_case);
}

String operator+(const String& lhs, const String& rhs) { return  String(lhs) += rhs; }

bool operator==(const String& lhs, const String& rhs) { return lhs.compare(rhs) == 0; }
bool operator!=(const String& lhs, const String& rhs) { return lhs.compare(rhs) != 0; }
bool operator< (const String& lhs, const String& rhs) { return lhs.compare(rhs) < 0; }
bool operator> (const String& lhs, const String& rhs) { return lhs.compare(rhs) > 0; }
bool operator<=(const String& lhs, const String& rhs) { return (lhs != rhs) ? lhs.compare(rhs) < 0 : true; }
bool operator>=(const String& lhs, const String& rhs) { return (lhs != rhs) ? lhs.compare(rhs) > 0 : true; }

std::ostream& operator<<(std::ostream& s, const String& in) { return s << in.c_str(); }

Contains::Contains(const String& str) : string(str) { }

bool Contains::checkWith(const String& other) const {
    return strstr(other.c_str(), string.c_str()) != nullptr;
}

String toString(const Contains& in) {
    return "Contains( " + in.string + " )";
}

bool operator==(const String& lhs, const Contains& rhs) { return rhs.checkWith(lhs); }
bool operator==(const Contains& lhs, const String& rhs) { return lhs.checkWith(rhs); }
bool operator!=(const String& lhs, const Contains& rhs) { return !rhs.checkWith(lhs); }
bool operator!=(const Contains& lhs, const String& rhs) { return !lhs.checkWith(rhs); }

namespace {
    void color_to_stream(std::ostream&, Color::Enum) DOCTEST_BRANCH_ON_DISABLED({}, ;)
} // namespace

namespace Color {
    std::ostream& operator<<(std::ostream& s, Color::Enum code) {
        color_to_stream(s, code);
        return s;
    }
} // namespace Color

// clang-format off
const char* assertString(assertType::Enum at) {
    DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4061) // enum 'x' in switch of enum 'y' is not explicitly handled
    #define DOCTEST_GENERATE_ASSERT_TYPE_CASE(assert_type) case assertType::DT_ ## assert_type: return #assert_type
    #define DOCTEST_GENERATE_ASSERT_TYPE_CASES(assert_type) \
        DOCTEST_GENERATE_ASSERT_TYPE_CASE(WARN_ ## assert_type); \
        DOCTEST_GENERATE_ASSERT_TYPE_CASE(CHECK_ ## assert_type); \
        DOCTEST_GENERATE_ASSERT_TYPE_CASE(REQUIRE_ ## assert_type)
    switch(at) {
        DOCTEST_GENERATE_ASSERT_TYPE_CASE(WARN);
        DOCTEST_GENERATE_ASSERT_TYPE_CASE(CHECK);
        DOCTEST_GENERATE_ASSERT_TYPE_CASE(REQUIRE);

        DOCTEST_GENERATE_ASSERT_TYPE_CASES(FALSE);

        DOCTEST_GENERATE_ASSERT_TYPE_CASES(THROWS);

        DOCTEST_GENERATE_ASSERT_TYPE_CASES(THROWS_AS);

        DOCTEST_GENERATE_ASSERT_TYPE_CASES(THROWS_WITH);

        DOCTEST_GENERATE_ASSERT_TYPE_CASES(THROWS_WITH_AS);

        DOCTEST_GENERATE_ASSERT_TYPE_CASES(NOTHROW);

        DOCTEST_GENERATE_ASSERT_TYPE_CASES(EQ);
        DOCTEST_GENERATE_ASSERT_TYPE_CASES(NE);
        DOCTEST_GENERATE_ASSERT_TYPE_CASES(GT);
        DOCTEST_GENERATE_ASSERT_TYPE_CASES(LT);
        DOCTEST_GENERATE_ASSERT_TYPE_CASES(GE);
        DOCTEST_GENERATE_ASSERT_TYPE_CASES(LE);

        DOCTEST_GENERATE_ASSERT_TYPE_CASES(UNARY);
        DOCTEST_GENERATE_ASSERT_TYPE_CASES(UNARY_FALSE);

        default: DOCTEST_INTERNAL_ERROR("Tried stringifying invalid assert type!");
    }
    DOCTEST_MSVC_SUPPRESS_WARNING_POP
}
// clang-format on

const char* failureString(assertType::Enum at) {
    if(at & assertType::is_warn) //!OCLINT bitwise operator in conditional
        return "WARNING";
    if(at & assertType::is_check) //!OCLINT bitwise operator in conditional
        return "ERROR";
    if(at & assertType::is_require) //!OCLINT bitwise operator in conditional
        return "FATAL ERROR";
    return "";
}

DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wnull-dereference")
DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wnull-dereference")
// depending on the current options this will remove the path of filenames
const char* skipPathFromFilename(const char* file) {
#ifndef DOCTEST_CONFIG_DISABLE
    if(getContextOptions()->no_path_in_filenames) {
        auto back    = std::strrchr(file, '\\');
        auto forward = std::strrchr(file, '/');
        if(back || forward) {
            if(back > forward)
                forward = back;
            return forward + 1;
        }
    } else {
        const auto prefixes = getContextOptions()->strip_file_prefixes;
        const char separator = DOCTEST_CONFIG_OPTIONS_FILE_PREFIX_SEPARATOR;
        String::size_type longest_match = 0U;
        for(String::size_type pos = 0U; pos < prefixes.size(); ++pos)
        {
            const auto prefix_start = pos;
            pos = std::min(prefixes.find(separator, prefix_start), prefixes.size());
            
            const auto prefix_size = pos - prefix_start;
            if(prefix_size > longest_match)
            {
                // TODO under DOCTEST_MSVC: does the comparison need strnicmp() to work with drive letter capitalization?
                if(0 == std::strncmp(prefixes.c_str() + prefix_start, file, prefix_size))
                {
                    longest_match = prefix_size;
                }
            }
        }
        return &file[longest_match];
    }
#endif // DOCTEST_CONFIG_DISABLE
    return file;
}
DOCTEST_CLANG_SUPPRESS_WARNING_POP
DOCTEST_GCC_SUPPRESS_WARNING_POP

bool SubcaseSignature::operator==(const SubcaseSignature& other) const {
    return m_line == other.m_line
        && std::strcmp(m_file, other.m_file) == 0
        && m_name == other.m_name;
}

bool SubcaseSignature::operator<(const SubcaseSignature& other) const {
    if(m_line != other.m_line)
        return m_line < other.m_line;
    if(std::strcmp(m_file, other.m_file) != 0)
        return std::strcmp(m_file, other.m_file) < 0;
    return m_name.compare(other.m_name) < 0;
}

DOCTEST_DEFINE_INTERFACE(IContextScope)

namespace detail {
    void filldata<const void*>::fill(std::ostream* stream, const void* in) {
        if (in) { *stream << in; }
        else { *stream << "nullptr"; }
    }

    template <typename T>
    String toStreamLit(T t) {
        std::ostream* os = tlssPush();
        os->operator<<(t);
        return tlssPop();
    }
}

#ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
String toString(const char* in) { return String("\"") + (in ? in : "{null string}") + "\""; }
#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING

#if DOCTEST_MSVC >= DOCTEST_COMPILER(19, 20, 0)
// see this issue on why this is needed: https://github.com/doctest/doctest/issues/183
String toString(const std::string& in) { return in.c_str(); }
#endif // VS 2019

String toString(String in) { return in; }

String toString(std::nullptr_t) { return "nullptr"; }

String toString(bool in) { return in ? "true" : "false"; }

String toString(float in) { return toStreamLit(in); }
String toString(double in) { return toStreamLit(in); }
String toString(double long in) { return toStreamLit(in); }

String toString(char in) { return toStreamLit(static_cast<signed>(in)); }
String toString(char signed in) { return toStreamLit(static_cast<signed>(in)); }
String toString(char unsigned in) { return toStreamLit(static_cast<unsigned>(in)); }
String toString(short in) { return toStreamLit(in); }
String toString(short unsigned in) { return toStreamLit(in); }
String toString(signed in) { return toStreamLit(in); }
String toString(unsigned in) { return toStreamLit(in); }
String toString(long in) { return toStreamLit(in); }
String toString(long unsigned in) { return toStreamLit(in); }
String toString(long long in) { return toStreamLit(in); }
String toString(long long unsigned in) { return toStreamLit(in); }

Approx::Approx(double value)
        : m_epsilon(static_cast<double>(std::numeric_limits<float>::epsilon()) * 100)
        , m_scale(1.0)
        , m_value(value) {}

Approx Approx::operator()(double value) const {
    Approx approx(value);
    approx.epsilon(m_epsilon);
    approx.scale(m_scale);
    return approx;
}

Approx& Approx::epsilon(double newEpsilon) {
    m_epsilon = newEpsilon;
    return *this;
}
Approx& Approx::scale(double newScale) {
    m_scale = newScale;
    return *this;
}

bool operator==(double lhs, const Approx& rhs) {
    // Thanks to Richard Harris for his help refining this formula
    return std::fabs(lhs - rhs.m_value) <
           rhs.m_epsilon * (rhs.m_scale + std::max<double>(std::fabs(lhs), std::fabs(rhs.m_value)));
}
bool operator==(const Approx& lhs, double rhs) { return operator==(rhs, lhs); }
bool operator!=(double lhs, const Approx& rhs) { return !operator==(lhs, rhs); }
bool operator!=(const Approx& lhs, double rhs) { return !operator==(rhs, lhs); }
bool operator<=(double lhs, const Approx& rhs) { return lhs < rhs.m_value || lhs == rhs; }
bool operator<=(const Approx& lhs, double rhs) { return lhs.m_value < rhs || lhs == rhs; }
bool operator>=(double lhs, const Approx& rhs) { return lhs > rhs.m_value || lhs == rhs; }
bool operator>=(const Approx& lhs, double rhs) { return lhs.m_value > rhs || lhs == rhs; }
bool operator<(double lhs, const Approx& rhs) { return lhs < rhs.m_value && lhs != rhs; }
bool operator<(const Approx& lhs, double rhs) { return lhs.m_value < rhs && lhs != rhs; }
bool operator>(double lhs, const Approx& rhs) { return lhs > rhs.m_value && lhs != rhs; }
bool operator>(const Approx& lhs, double rhs) { return lhs.m_value > rhs && lhs != rhs; }

String toString(const Approx& in) {
    return "Approx( " + doctest::toString(in.m_value) + " )";
}
const ContextOptions* getContextOptions() { return DOCTEST_BRANCH_ON_DISABLED(nullptr, g_cs); }

DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4738)
template <typename F>
IsNaN<F>::operator bool() const {
    return std::isnan(value) ^ flipped;
}
DOCTEST_MSVC_SUPPRESS_WARNING_POP
template struct DOCTEST_INTERFACE_DEF IsNaN<float>;
template struct DOCTEST_INTERFACE_DEF IsNaN<double>;
template struct DOCTEST_INTERFACE_DEF IsNaN<long double>;
template <typename F>
String toString(IsNaN<F> in) { return String(in.flipped ? "! " : "") + "IsNaN( " + doctest::toString(in.value) + " )"; }
String toString(IsNaN<float> in) { return toString<float>(in); }
String toString(IsNaN<double> in) { return toString<double>(in); }
String toString(IsNaN<double long> in) { return toString<double long>(in); }

} // namespace doctest

#ifdef DOCTEST_CONFIG_DISABLE
namespace doctest {
Context::Context(int, const char* const*) {}
Context::~Context() = default;
void Context::applyCommandLine(int, const char* const*) {}
void Context::addFilter(const char*, const char*) {}
void Context::clearFilters() {}
void Context::setOption(const char*, bool) {}
void Context::setOption(const char*, int) {}
void Context::setOption(const char*, const char*) {}
bool Context::shouldExit() { return false; }
void Context::setAsDefaultForAssertsOutOfTestCases() {}
void Context::setAssertHandler(detail::assert_handler) {}
void Context::setCout(std::ostream*) {}
int  Context::run() { return 0; }

int                         IReporter::get_num_active_contexts() { return 0; }
const IContextScope* const* IReporter::get_active_contexts() { return nullptr; }
int                         IReporter::get_num_stringified_contexts() { return 0; }
const String*               IReporter::get_stringified_contexts() { return nullptr; }

int registerReporter(const char*, int, IReporter*) { return 0; }

} // namespace doctest
#else // DOCTEST_CONFIG_DISABLE

#if !defined(DOCTEST_CONFIG_COLORS_NONE)
#if !defined(DOCTEST_CONFIG_COLORS_WINDOWS) && !defined(DOCTEST_CONFIG_COLORS_ANSI)
#ifdef DOCTEST_PLATFORM_WINDOWS
#define DOCTEST_CONFIG_COLORS_WINDOWS
#else // linux
#define DOCTEST_CONFIG_COLORS_ANSI
#endif // platform
#endif // DOCTEST_CONFIG_COLORS_WINDOWS && DOCTEST_CONFIG_COLORS_ANSI
#endif // DOCTEST_CONFIG_COLORS_NONE

namespace doctest_detail_test_suite_ns {
// holds the current test suite
doctest::detail::TestSuite& getCurrentTestSuite() {
    static doctest::detail::TestSuite data{};
    return data;
}
} // namespace doctest_detail_test_suite_ns

namespace doctest {
namespace {
    // the int (priority) is part of the key for automatic sorting - sadly one can register a
    // reporter with a duplicate name and a different priority but hopefully that won't happen often :|
    using reporterMap = std::map<std::pair<int, String>, reporterCreatorFunc>;

    reporterMap& getReporters() {
        static reporterMap data;
        return data;
    }
    reporterMap& getListeners() {
        static reporterMap data;
        return data;
    }
} // namespace
namespace detail {
#define DOCTEST_ITERATE_THROUGH_REPORTERS(function, ...)                                           \
    for(auto& curr_rep : g_cs->reporters_currently_used)                                           \
    curr_rep->function(__VA_ARGS__)

    bool checkIfShouldThrow(assertType::Enum at) {
        if(at & assertType::is_require) //!OCLINT bitwise operator in conditional
            return true;

        if((at & assertType::is_check) //!OCLINT bitwise operator in conditional
           && getContextOptions()->abort_after > 0 &&
           (g_cs->numAssertsFailed + g_cs->numAssertsFailedCurrentTest_atomic) >=
                   getContextOptions()->abort_after)
            return true;

        return false;
    }

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
    DOCTEST_NORETURN void throwException() {
        g_cs->shouldLogCurrentException = false;
        throw TestFailureException(); // NOLINT(hicpp-exception-baseclass)
    }
#else // DOCTEST_CONFIG_NO_EXCEPTIONS
    void throwException() {}
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
} // namespace detail

namespace {
    using namespace detail;
    // matching of a string against a wildcard mask (case sensitivity configurable) taken from
    // https://www.codeproject.com/Articles/1088/Wildcard-string-compare-globbing
    int wildcmp(const char* str, const char* wild, bool caseSensitive) {
        const char* cp = str;
        const char* mp = wild;

        while((*str) && (*wild != '*')) {
            if((caseSensitive ? (*wild != *str) : (tolower(*wild) != tolower(*str))) &&
               (*wild != '?')) {
                return 0;
            }
            wild++;
            str++;
        }

        while(*str) {
            if(*wild == '*') {
                if(!*++wild) {
                    return 1;
                }
                mp = wild;
                cp = str + 1;
            } else if((caseSensitive ? (*wild == *str) : (tolower(*wild) == tolower(*str))) ||
                      (*wild == '?')) {
                wild++;
                str++;
            } else {
                wild = mp;   //!OCLINT parameter reassignment
                str  = cp++; //!OCLINT parameter reassignment
            }
        }

        while(*wild == '*') {
            wild++;
        }
        return !*wild;
    }

    // checks if the name matches any of the filters (and can be configured what to do when empty)
    bool matchesAny(const char* name, const std::vector<String>& filters, bool matchEmpty,
        bool caseSensitive) {
        if (filters.empty() && matchEmpty)
            return true;
        for (auto& curr : filters)
            if (wildcmp(name, curr.c_str(), caseSensitive))
                return true;
        return false;
    }

    DOCTEST_NO_SANITIZE_INTEGER
    unsigned long long hash(unsigned long long a, unsigned long long b) {
        return (a << 5) + b;
    }

    // C string hash function (djb2) - taken from http://www.cse.yorku.ca/~oz/hash.html
    DOCTEST_NO_SANITIZE_INTEGER
    unsigned long long hash(const char* str) {
        unsigned long long hash = 5381;
        char c;
        while ((c = *str++))
            hash = ((hash << 5) + hash) + c; // hash * 33 + c
        return hash;
    }

    unsigned long long hash(const SubcaseSignature& sig) {
        return hash(hash(hash(sig.m_file), hash(sig.m_name.c_str())), sig.m_line);
    }

    unsigned long long hash(const std::vector<SubcaseSignature>& sigs, size_t count) {
        unsigned long long running = 0;
        auto end = sigs.begin() + count;
        for (auto it = sigs.begin(); it != end; it++) {
            running = hash(running, hash(*it));
        }
        return running;
    }

    unsigned long long hash(const std::vector<SubcaseSignature>& sigs) {
        unsigned long long running = 0;
        for (const SubcaseSignature& sig : sigs) {
            running = hash(running, hash(sig));
        }
        return running;
    }
} // namespace
namespace detail {
    bool Subcase::checkFilters() {
        if (g_cs->subcaseStack.size() < size_t(g_cs->subcase_filter_levels)) {
            if (!matchesAny(m_signature.m_name.c_str(), g_cs->filters[6], true, g_cs->case_sensitive))
                return true;
            if (matchesAny(m_signature.m_name.c_str(), g_cs->filters[7], false, g_cs->case_sensitive))
                return true;
        }
        return false;
    }

    Subcase::Subcase(const String& name, const char* file, int line)
            : m_signature({name, file, line}) {
        if (!g_cs->reachedLeaf) {
            if (g_cs->nextSubcaseStack.size() <= g_cs->subcaseStack.size()
                || g_cs->nextSubcaseStack[g_cs->subcaseStack.size()] == m_signature) {
                // Going down.
                if (checkFilters()) { return; }

                g_cs->subcaseStack.push_back(m_signature);
                g_cs->currentSubcaseDepth++;
                m_entered = true;
                DOCTEST_ITERATE_THROUGH_REPORTERS(subcase_start, m_signature);
            }
        } else {
            if (g_cs->subcaseStack[g_cs->currentSubcaseDepth] == m_signature) {
                // This subcase is reentered via control flow.
                g_cs->currentSubcaseDepth++;
                m_entered = true;
                DOCTEST_ITERATE_THROUGH_REPORTERS(subcase_start, m_signature);
            } else if (g_cs->nextSubcaseStack.size() <= g_cs->currentSubcaseDepth
                    && g_cs->fullyTraversedSubcases.find(hash(hash(g_cs->subcaseStack, g_cs->currentSubcaseDepth), hash(m_signature)))
                    == g_cs->fullyTraversedSubcases.end()) {
                if (checkFilters()) { return; }
                // This subcase is part of the one to be executed next.
                g_cs->nextSubcaseStack.clear();
                g_cs->nextSubcaseStack.insert(g_cs->nextSubcaseStack.end(),
                    g_cs->subcaseStack.begin(), g_cs->subcaseStack.begin() + g_cs->currentSubcaseDepth);
                g_cs->nextSubcaseStack.push_back(m_signature);
            }
        }
    }

    DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4996) // std::uncaught_exception is deprecated in C++17
    DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wdeprecated-declarations")
    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wdeprecated-declarations")

    Subcase::~Subcase() {
        if (m_entered) {
            g_cs->currentSubcaseDepth--;

            if (!g_cs->reachedLeaf) {
                // Leaf.
                g_cs->fullyTraversedSubcases.insert(hash(g_cs->subcaseStack));
                g_cs->nextSubcaseStack.clear();
                g_cs->reachedLeaf = true;
            } else if (g_cs->nextSubcaseStack.empty()) {
                // All children are finished.
                g_cs->fullyTraversedSubcases.insert(hash(g_cs->subcaseStack));
            }

#if defined(__cpp_lib_uncaught_exceptions) && __cpp_lib_uncaught_exceptions >= 201411L && (!defined(__MAC_OS_X_VERSION_MIN_REQUIRED) || __MAC_OS_X_VERSION_MIN_REQUIRED >= 101200)
            if(std::uncaught_exceptions() > 0
#else
            if(std::uncaught_exception()
#endif
                && g_cs->shouldLogCurrentException) {
                DOCTEST_ITERATE_THROUGH_REPORTERS(
                        test_case_exception, {"exception thrown in subcase - will translate later "
                                                "when the whole test case has been exited (cannot "
                                                "translate while there is an active exception)",
                                                false});
                g_cs->shouldLogCurrentException = false;
            }

            DOCTEST_ITERATE_THROUGH_REPORTERS(subcase_end, DOCTEST_EMPTY);
        }
    }

    DOCTEST_CLANG_SUPPRESS_WARNING_POP
    DOCTEST_GCC_SUPPRESS_WARNING_POP
    DOCTEST_MSVC_SUPPRESS_WARNING_POP

    Subcase::operator bool() const { return m_entered; }

    Result::Result(bool passed, const String& decomposition)
            : m_passed(passed)
            , m_decomp(decomposition) {}

    ExpressionDecomposer::ExpressionDecomposer(assertType::Enum at)
            : m_at(at) {}

    TestSuite& TestSuite::operator*(const char* in) {
        m_test_suite = in;
        return *this;
    }

    TestCase::TestCase(funcType test, const char* file, unsigned line, const TestSuite& test_suite,
                       const String& type, int template_id) {
        m_file              = file;
        m_line              = line;
        m_name              = nullptr; // will be later overridden in operator*
        m_test_suite        = test_suite.m_test_suite;
        m_description       = test_suite.m_description;
        m_skip              = test_suite.m_skip;
        m_no_breaks         = test_suite.m_no_breaks;
        m_no_output         = test_suite.m_no_output;
        m_may_fail          = test_suite.m_may_fail;
        m_should_fail       = test_suite.m_should_fail;
        m_expected_failures = test_suite.m_expected_failures;
        m_timeout           = test_suite.m_timeout;

        m_test        = test;
        m_type        = type;
        m_template_id = template_id;
    }

    TestCase::TestCase(const TestCase& other)
            : TestCaseData() {
        *this = other;
    }

    DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(26434) // hides a non-virtual function
    TestCase& TestCase::operator=(const TestCase& other) {
        TestCaseData::operator=(other);
        m_test        = other.m_test;
        m_type        = other.m_type;
        m_template_id = other.m_template_id;
        m_full_name   = other.m_full_name;

        if(m_template_id != -1)
            m_name = m_full_name.c_str();
        return *this;
    }
    DOCTEST_MSVC_SUPPRESS_WARNING_POP

    TestCase& TestCase::operator*(const char* in) {
        m_name = in;
        // make a new name with an appended type for templated test case
        if(m_template_id != -1) {
            m_full_name = String(m_name) + "<" + m_type + ">";
            // redirect the name to point to the newly constructed full name
            m_name = m_full_name.c_str();
        }
        return *this;
    }

    bool TestCase::operator<(const TestCase& other) const {
        // this will be used only to differentiate between test cases - not relevant for sorting
        if(m_line != other.m_line)
            return m_line < other.m_line;
        const int name_cmp = strcmp(m_name, other.m_name);
        if(name_cmp != 0)
            return name_cmp < 0;
        const int file_cmp = m_file.compare(other.m_file);
        if(file_cmp != 0)
            return file_cmp < 0;
        return m_template_id < other.m_template_id;
    }

    // all the registered tests
    std::set<TestCase>& getRegisteredTests() {
        static std::set<TestCase> data;
        return data;
    }
} // namespace detail
namespace {
    using namespace detail;
    // for sorting tests by file/line
    bool fileOrderComparator(const TestCase* lhs, const TestCase* rhs) {
        // this is needed because MSVC gives different case for drive letters
        // for __FILE__ when evaluated in a header and a source file
        const int res = lhs->m_file.compare(rhs->m_file, bool(DOCTEST_MSVC));
        if(res != 0)
            return res < 0;
        if(lhs->m_line != rhs->m_line)
            return lhs->m_line < rhs->m_line;
        return lhs->m_template_id < rhs->m_template_id;
    }

    // for sorting tests by suite/file/line
    bool suiteOrderComparator(const TestCase* lhs, const TestCase* rhs) {
        const int res = std::strcmp(lhs->m_test_suite, rhs->m_test_suite);
        if(res != 0)
            return res < 0;
        return fileOrderComparator(lhs, rhs);
    }

    // for sorting tests by name/suite/file/line
    bool nameOrderComparator(const TestCase* lhs, const TestCase* rhs) {
        const int res = std::strcmp(lhs->m_name, rhs->m_name);
        if(res != 0)
            return res < 0;
        return suiteOrderComparator(lhs, rhs);
    }

    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wdeprecated-declarations")
    void color_to_stream(std::ostream& s, Color::Enum code) {
        static_cast<void>(s);    // for DOCTEST_CONFIG_COLORS_NONE or DOCTEST_CONFIG_COLORS_WINDOWS
        static_cast<void>(code); // for DOCTEST_CONFIG_COLORS_NONE
#ifdef DOCTEST_CONFIG_COLORS_ANSI
        if(g_no_colors ||
           (isatty(STDOUT_FILENO) == false && getContextOptions()->force_colors == false))
            return;

        auto col = "";
        // clang-format off
            switch(code) { //!OCLINT missing break in switch statement / unnecessary default statement in covered switch statement
                case Color::Red:         col = "[0;31m"; break;
                case Color::Green:       col = "[0;32m"; break;
                case Color::Blue:        col = "[0;34m"; break;
                case Color::Cyan:        col = "[0;36m"; break;
                case Color::Yellow:      col = "[0;33m"; break;
                case Color::Grey:        col = "[1;30m"; break;
                case Color::LightGrey:   col = "[0;37m"; break;
                case Color::BrightRed:   col = "[1;31m"; break;
                case Color::BrightGreen: col = "[1;32m"; break;
                case Color::BrightWhite: col = "[1;37m"; break;
                case Color::Bright: // invalid
                case Color::None:
                case Color::White:
                default:                 col = "[0m";
            }
        // clang-format on
        s << "\033" << col;
#endif // DOCTEST_CONFIG_COLORS_ANSI

#ifdef DOCTEST_CONFIG_COLORS_WINDOWS
        if(g_no_colors ||
           (_isatty(_fileno(stdout)) == false && getContextOptions()->force_colors == false))
            return;

        static struct ConsoleHelper {
            HANDLE stdoutHandle;
            WORD   origFgAttrs;
            WORD   origBgAttrs;

            ConsoleHelper() {
                stdoutHandle = GetStdHandle(STD_OUTPUT_HANDLE);
                CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
                GetConsoleScreenBufferInfo(stdoutHandle, &csbiInfo);
                origFgAttrs = csbiInfo.wAttributes & ~(BACKGROUND_GREEN | BACKGROUND_RED |
                    BACKGROUND_BLUE | BACKGROUND_INTENSITY);
                origBgAttrs = csbiInfo.wAttributes & ~(FOREGROUND_GREEN | FOREGROUND_RED |
                    FOREGROUND_BLUE | FOREGROUND_INTENSITY);
            }
        } ch;

#define DOCTEST_SET_ATTR(x) SetConsoleTextAttribute(ch.stdoutHandle, x | ch.origBgAttrs)

        // clang-format off
        switch (code) {
            case Color::White:       DOCTEST_SET_ATTR(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE); break;
            case Color::Red:         DOCTEST_SET_ATTR(FOREGROUND_RED);                                      break;
            case Color::Green:       DOCTEST_SET_ATTR(FOREGROUND_GREEN);                                    break;
            case Color::Blue:        DOCTEST_SET_ATTR(FOREGROUND_BLUE);                                     break;
            case Color::Cyan:        DOCTEST_SET_ATTR(FOREGROUND_BLUE | FOREGROUND_GREEN);                  break;
            case Color::Yellow:      DOCTEST_SET_ATTR(FOREGROUND_RED | FOREGROUND_GREEN);                   break;
            case Color::Grey:        DOCTEST_SET_ATTR(0);                                                   break;
            case Color::LightGrey:   DOCTEST_SET_ATTR(FOREGROUND_INTENSITY);                                break;
            case Color::BrightRed:   DOCTEST_SET_ATTR(FOREGROUND_INTENSITY | FOREGROUND_RED);               break;
            case Color::BrightGreen: DOCTEST_SET_ATTR(FOREGROUND_INTENSITY | FOREGROUND_GREEN);             break;
            case Color::BrightWhite: DOCTEST_SET_ATTR(FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE); break;
            case Color::None:
            case Color::Bright: // invalid
            default:                 DOCTEST_SET_ATTR(ch.origFgAttrs);
        }
            // clang-format on
#endif // DOCTEST_CONFIG_COLORS_WINDOWS
    }
    DOCTEST_CLANG_SUPPRESS_WARNING_POP

    std::vector<const IExceptionTranslator*>& getExceptionTranslators() {
        static std::vector<const IExceptionTranslator*> data;
        return data;
    }

    String translateActiveException() {
#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
        String res;
        auto&  translators = getExceptionTranslators();
        for(auto& curr : translators)
            if(curr->translate(res))
                return res;
        // clang-format off
        DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wcatch-value")
        try {
            throw;
        } catch(std::exception& ex) {
            return ex.what();
        } catch(std::string& msg) {
            return msg.c_str();
        } catch(const char* msg) {
            return msg;
        } catch(...) {
            return "unknown exception";
        }
        DOCTEST_GCC_SUPPRESS_WARNING_POP
// clang-format on
#else  // DOCTEST_CONFIG_NO_EXCEPTIONS
        return "";
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
    }
} // namespace

namespace detail {
    // used by the macros for registering tests
    int regTest(const TestCase& tc) {
        getRegisteredTests().insert(tc);
        return 0;
    }

    // sets the current test suite
    int setTestSuite(const TestSuite& ts) {
        doctest_detail_test_suite_ns::getCurrentTestSuite() = ts;
        return 0;
    }

#ifdef DOCTEST_IS_DEBUGGER_ACTIVE
    bool isDebuggerActive() { return DOCTEST_IS_DEBUGGER_ACTIVE(); }
#else // DOCTEST_IS_DEBUGGER_ACTIVE
#ifdef DOCTEST_PLATFORM_LINUX
    class ErrnoGuard {
    public:
        ErrnoGuard() : m_oldErrno(errno) {}
        ~ErrnoGuard() { errno = m_oldErrno; }
    private:
        int m_oldErrno;
    };
    // See the comments in Catch2 for the reasoning behind this implementation:
    // https://github.com/catchorg/Catch2/blob/v2.13.1/include/internal/catch_debugger.cpp#L79-L102
    bool isDebuggerActive() {
        ErrnoGuard guard;
        std::ifstream in("/proc/self/status");
        for(std::string line; std::getline(in, line);) {
            static const int PREFIX_LEN = 11;
            if(line.compare(0, PREFIX_LEN, "TracerPid:\t") == 0) {
                return line.length() > PREFIX_LEN && line[PREFIX_LEN] != '0';
            }
        }
        return false;
    }
#elif defined(DOCTEST_PLATFORM_MAC)
    // The following function is taken directly from the following technical note:
    // https://developer.apple.com/library/archive/qa/qa1361/_index.html
    // Returns true if the current process is being debugged (either
    // running under the debugger or has a debugger attached post facto).
    bool isDebuggerActive() {
        int        mib[4];
        kinfo_proc info;
        size_t     size;
        // Initialize the flags so that, if sysctl fails for some bizarre
        // reason, we get a predictable result.
        info.kp_proc.p_flag = 0;
        // Initialize mib, which tells sysctl the info we want, in this case
        // we're looking for information about a specific process ID.
        mib[0] = CTL_KERN;
        mib[1] = KERN_PROC;
        mib[2] = KERN_PROC_PID;
        mib[3] = getpid();
        // Call sysctl.
        size = sizeof(info);
        if(sysctl(mib, DOCTEST_COUNTOF(mib), &info, &size, 0, 0) != 0) {
            std::cerr << "\nCall to sysctl failed - unable to determine if debugger is active **\n";
            return false;
        }
        // We're being debugged if the P_TRACED flag is set.
        return ((info.kp_proc.p_flag & P_TRACED) != 0);
    }
#elif DOCTEST_MSVC || defined(__MINGW32__) || defined(__MINGW64__)
    bool isDebuggerActive() { return ::IsDebuggerPresent() != 0; }
#else
    bool isDebuggerActive() { return false; }
#endif // Platform
#endif // DOCTEST_IS_DEBUGGER_ACTIVE

    void registerExceptionTranslatorImpl(const IExceptionTranslator* et) {
        if(std::find(getExceptionTranslators().begin(), getExceptionTranslators().end(), et) ==
           getExceptionTranslators().end())
            getExceptionTranslators().push_back(et);
    }

    DOCTEST_THREAD_LOCAL std::vector<IContextScope*> g_infoContexts; // for logging with INFO()

    ContextScopeBase::ContextScopeBase() {
        g_infoContexts.push_back(this);
    }

    ContextScopeBase::ContextScopeBase(ContextScopeBase&& other) noexcept {
        if (other.need_to_destroy) {
            other.destroy();
        }
        other.need_to_destroy = false;
        g_infoContexts.push_back(this);
    }

    DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4996) // std::uncaught_exception is deprecated in C++17
    DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wdeprecated-declarations")
    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wdeprecated-declarations")

    // destroy cannot be inlined into the destructor because that would mean calling stringify after
    // ContextScope has been destroyed (base class destructors run after derived class destructors).
    // Instead, ContextScope calls this method directly from its destructor.
    void ContextScopeBase::destroy() {
#if defined(__cpp_lib_uncaught_exceptions) && __cpp_lib_uncaught_exceptions >= 201411L && (!defined(__MAC_OS_X_VERSION_MIN_REQUIRED) || __MAC_OS_X_VERSION_MIN_REQUIRED >= 101200)
        if(std::uncaught_exceptions() > 0) {
#else
        if(std::uncaught_exception()) {
#endif
            std::ostringstream s;
            this->stringify(&s);
            g_cs->stringifiedContexts.push_back(s.str().c_str());
        }
        g_infoContexts.pop_back();
    }

    DOCTEST_CLANG_SUPPRESS_WARNING_POP
    DOCTEST_GCC_SUPPRESS_WARNING_POP
    DOCTEST_MSVC_SUPPRESS_WARNING_POP
} // namespace detail
namespace {
    using namespace detail;

#if !defined(DOCTEST_CONFIG_POSIX_SIGNALS) && !defined(DOCTEST_CONFIG_WINDOWS_SEH)
    struct FatalConditionHandler
    {
        static void reset() {}
        static void allocateAltStackMem() {}
        static void freeAltStackMem() {}
    };
#else // DOCTEST_CONFIG_POSIX_SIGNALS || DOCTEST_CONFIG_WINDOWS_SEH

    void reportFatal(const std::string&);

#ifdef DOCTEST_PLATFORM_WINDOWS

    struct SignalDefs
    {
        DWORD id;
        const char* name;
    };
    // There is no 1-1 mapping between signals and windows exceptions.
    // Windows can easily distinguish between SO and SigSegV,
    // but SigInt, SigTerm, etc are handled differently.
    SignalDefs signalDefs[] = {
            {static_cast<DWORD>(EXCEPTION_ILLEGAL_INSTRUCTION),
             "SIGILL - Illegal instruction signal"},
            {static_cast<DWORD>(EXCEPTION_STACK_OVERFLOW), "SIGSEGV - Stack overflow"},
            {static_cast<DWORD>(EXCEPTION_ACCESS_VIOLATION),
             "SIGSEGV - Segmentation violation signal"},
            {static_cast<DWORD>(EXCEPTION_INT_DIVIDE_BY_ZERO), "Divide by zero error"},
    };

    struct FatalConditionHandler
    {
        static LONG CALLBACK handleException(PEXCEPTION_POINTERS ExceptionInfo) {
            // Multiple threads may enter this filter/handler at once. We want the error message to be printed on the
            // console just once no matter how many threads have crashed.
            DOCTEST_DECLARE_STATIC_MUTEX(mutex)
            static bool execute = true;
            {
                DOCTEST_LOCK_MUTEX(mutex)
                if(execute) {
                    bool reported = false;
                    for(size_t i = 0; i < DOCTEST_COUNTOF(signalDefs); ++i) {
                        if(ExceptionInfo->ExceptionRecord->ExceptionCode == signalDefs[i].id) {
                            reportFatal(signalDefs[i].name);
                            reported = true;
                            break;
                        }
                    }
                    if(reported == false)
                        reportFatal("Unhandled SEH exception caught");
                    if(isDebuggerActive() && !g_cs->no_breaks)
                        DOCTEST_BREAK_INTO_DEBUGGER();
                }
                execute = false;
            }
            std::exit(EXIT_FAILURE);
        }

        static void allocateAltStackMem() {}
        static void freeAltStackMem() {}

        FatalConditionHandler() {
            isSet = true;
            // 32k seems enough for doctest to handle stack overflow,
            // but the value was found experimentally, so there is no strong guarantee
            guaranteeSize = 32 * 1024;
            // Register an unhandled exception filter
            previousTop = SetUnhandledExceptionFilter(handleException);
            // Pass in guarantee size to be filled
            SetThreadStackGuarantee(&guaranteeSize);

            // On Windows uncaught exceptions from another thread, exceptions from
            // destructors, or calls to std::terminate are not a SEH exception

            // The terminal handler gets called when:
            // - std::terminate is called FROM THE TEST RUNNER THREAD
            // - an exception is thrown from a destructor FROM THE TEST RUNNER THREAD
            original_terminate_handler = std::get_terminate();
            std::set_terminate([]() DOCTEST_NOEXCEPT {
                reportFatal("Terminate handler called");
                if(isDebuggerActive() && !g_cs->no_breaks)
                    DOCTEST_BREAK_INTO_DEBUGGER();
                std::exit(EXIT_FAILURE); // explicitly exit - otherwise the SIGABRT handler may be called as well
            });

            // SIGABRT is raised when:
            // - std::terminate is called FROM A DIFFERENT THREAD
            // - an exception is thrown from a destructor FROM A DIFFERENT THREAD
            // - an uncaught exception is thrown FROM A DIFFERENT THREAD
            prev_sigabrt_handler = std::signal(SIGABRT, [](int signal) DOCTEST_NOEXCEPT {
                if(signal == SIGABRT) {
                    reportFatal("SIGABRT - Abort (abnormal termination) signal");
                    if(isDebuggerActive() && !g_cs->no_breaks)
                        DOCTEST_BREAK_INTO_DEBUGGER();
                    std::exit(EXIT_FAILURE);
                }
            });

            // The following settings are taken from google test, and more
            // specifically from UnitTest::Run() inside of gtest.cc

            // the user does not want to see pop-up dialogs about crashes
            prev_error_mode_1 = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOALIGNMENTFAULTEXCEPT |
                                             SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX);
            // This forces the abort message to go to stderr in all circumstances.
            prev_error_mode_2 = _set_error_mode(_OUT_TO_STDERR);
            // In the debug version, Visual Studio pops up a separate dialog
            // offering a choice to debug the aborted program - we want to disable that.
            prev_abort_behavior = _set_abort_behavior(0x0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);
            // In debug mode, the Windows CRT can crash with an assertion over invalid
            // input (e.g. passing an invalid file descriptor). The default handling
            // for these assertions is to pop up a dialog and wait for user input.
            // Instead ask the CRT to dump such assertions to stderr non-interactively.
            prev_report_mode = _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
            prev_report_file = _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);
        }

        static void reset() {
            if(isSet) {
                // Unregister handler and restore the old guarantee
                SetUnhandledExceptionFilter(previousTop);
                SetThreadStackGuarantee(&guaranteeSize);
                std::set_terminate(original_terminate_handler);
                std::signal(SIGABRT, prev_sigabrt_handler);
                SetErrorMode(prev_error_mode_1);
                _set_error_mode(prev_error_mode_2);
                _set_abort_behavior(prev_abort_behavior, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);
                static_cast<void>(_CrtSetReportMode(_CRT_ASSERT, prev_report_mode));
                static_cast<void>(_CrtSetReportFile(_CRT_ASSERT, prev_report_file));
                isSet = false;
            }
        }

        ~FatalConditionHandler() { reset(); }

    private:
        static UINT         prev_error_mode_1;
        static int          prev_error_mode_2;
        static unsigned int prev_abort_behavior;
        static int          prev_report_mode;
        static _HFILE       prev_report_file;
        static void (DOCTEST_CDECL *prev_sigabrt_handler)(int);
        static std::terminate_handler original_terminate_handler;
        static bool isSet;
        static ULONG guaranteeSize;
        static LPTOP_LEVEL_EXCEPTION_FILTER previousTop;
    };

    UINT         FatalConditionHandler::prev_error_mode_1;
    int          FatalConditionHandler::prev_error_mode_2;
    unsigned int FatalConditionHandler::prev_abort_behavior;
    int          FatalConditionHandler::prev_report_mode;
    _HFILE       FatalConditionHandler::prev_report_file;
    void (DOCTEST_CDECL *FatalConditionHandler::prev_sigabrt_handler)(int);
    std::terminate_handler FatalConditionHandler::original_terminate_handler;
    bool FatalConditionHandler::isSet = false;
    ULONG FatalConditionHandler::guaranteeSize = 0;
    LPTOP_LEVEL_EXCEPTION_FILTER FatalConditionHandler::previousTop = nullptr;

#else // DOCTEST_PLATFORM_WINDOWS

    struct SignalDefs
    {
        int         id;
        const char* name;
    };
    SignalDefs signalDefs[] = {{SIGINT, "SIGINT - Terminal interrupt signal"},
                               {SIGILL, "SIGILL - Illegal instruction signal"},
                               {SIGFPE, "SIGFPE - Floating point error signal"},
                               {SIGSEGV, "SIGSEGV - Segmentation violation signal"},
                               {SIGTERM, "SIGTERM - Termination request signal"},
                               {SIGABRT, "SIGABRT - Abort (abnormal termination) signal"}};

    struct FatalConditionHandler
    {
        static bool             isSet;
        static struct sigaction oldSigActions[DOCTEST_COUNTOF(signalDefs)];
        static stack_t          oldSigStack;
        static size_t           altStackSize;
        static char*            altStackMem;

        static void handleSignal(int sig) {
            const char* name = "<unknown signal>";
            for(std::size_t i = 0; i < DOCTEST_COUNTOF(signalDefs); ++i) {
                SignalDefs& def = signalDefs[i];
                if(sig == def.id) {
                    name = def.name;
                    break;
                }
            }
            reset();
            reportFatal(name);
            raise(sig);
        }

        static void allocateAltStackMem() {
            altStackMem = new char[altStackSize];
        }

        static void freeAltStackMem() {
            delete[] altStackMem;
        }

        FatalConditionHandler() {
            isSet = true;
            stack_t sigStack;
            sigStack.ss_sp    = altStackMem;
            sigStack.ss_size  = altStackSize;
            sigStack.ss_flags = 0;
            sigaltstack(&sigStack, &oldSigStack);
            struct sigaction sa = {};
            sa.sa_handler       = handleSignal;
            sa.sa_flags         = SA_ONSTACK;
            for(std::size_t i = 0; i < DOCTEST_COUNTOF(signalDefs); ++i) {
                sigaction(signalDefs[i].id, &sa, &oldSigActions[i]);
            }
        }

        ~FatalConditionHandler() { reset(); }
        static void reset() {
            if(isSet) {
                // Set signals back to previous values -- hopefully nobody overwrote them in the meantime
                for(std::size_t i = 0; i < DOCTEST_COUNTOF(signalDefs); ++i) {
                    sigaction(signalDefs[i].id, &oldSigActions[i], nullptr);
                }
                // Return the old stack
                sigaltstack(&oldSigStack, nullptr);
                isSet = false;
            }
        }
    };

    bool             FatalConditionHandler::isSet = false;
    struct sigaction FatalConditionHandler::oldSigActions[DOCTEST_COUNTOF(signalDefs)] = {};
    stack_t          FatalConditionHandler::oldSigStack = {};
    size_t           FatalConditionHandler::altStackSize = 4 * SIGSTKSZ;
    char*            FatalConditionHandler::altStackMem = nullptr;

#endif // DOCTEST_PLATFORM_WINDOWS
#endif // DOCTEST_CONFIG_POSIX_SIGNALS || DOCTEST_CONFIG_WINDOWS_SEH

} // namespace

namespace {
    using namespace detail;

#ifdef DOCTEST_PLATFORM_WINDOWS
#define DOCTEST_OUTPUT_DEBUG_STRING(text) ::OutputDebugStringA(text)
#else
    // TODO: integration with XCode and other IDEs
#define DOCTEST_OUTPUT_DEBUG_STRING(text)
#endif // Platform

    void addAssert(assertType::Enum at) {
        if((at & assertType::is_warn) == 0) //!OCLINT bitwise operator in conditional
            g_cs->numAssertsCurrentTest_atomic++;
    }

    void addFailedAssert(assertType::Enum at) {
        if((at & assertType::is_warn) == 0) //!OCLINT bitwise operator in conditional
            g_cs->numAssertsFailedCurrentTest_atomic++;
    }

#if defined(DOCTEST_CONFIG_POSIX_SIGNALS) || defined(DOCTEST_CONFIG_WINDOWS_SEH)
    void reportFatal(const std::string& message) {
        g_cs->failure_flags |= TestCaseFailureReason::Crash;

        DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_exception, {message.c_str(), true});

        while (g_cs->subcaseStack.size()) {
            g_cs->subcaseStack.pop_back();
            DOCTEST_ITERATE_THROUGH_REPORTERS(subcase_end, DOCTEST_EMPTY);
        }

        g_cs->finalizeTestCaseData();

        DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_end, *g_cs);

        DOCTEST_ITERATE_THROUGH_REPORTERS(test_run_end, *g_cs);
    }
#endif // DOCTEST_CONFIG_POSIX_SIGNALS || DOCTEST_CONFIG_WINDOWS_SEH
} // namespace

AssertData::AssertData(assertType::Enum at, const char* file, int line, const char* expr,
    const char* exception_type, const StringContains& exception_string)
    : m_test_case(g_cs->currentTest), m_at(at), m_file(file), m_line(line), m_expr(expr),
    m_failed(true), m_threw(false), m_threw_as(false), m_exception_type(exception_type),
    m_exception_string(exception_string) {
#if DOCTEST_MSVC
    if (m_expr[0] == ' ') // this happens when variadic macros are disabled under MSVC
        ++m_expr;
#endif // MSVC
}

namespace detail {
    ResultBuilder::ResultBuilder(assertType::Enum at, const char* file, int line, const char* expr,
                                 const char* exception_type, const String& exception_string)
        : AssertData(at, file, line, expr, exception_type, exception_string) { }

    ResultBuilder::ResultBuilder(assertType::Enum at, const char* file, int line, const char* expr,
        const char* exception_type, const Contains& exception_string)
        : AssertData(at, file, line, expr, exception_type, exception_string) { }

    void ResultBuilder::setResult(const Result& res) {
        m_decomp = res.m_decomp;
        m_failed = !res.m_passed;
    }

    void ResultBuilder::translateException() {
        m_threw     = true;
        m_exception = translateActiveException();
    }

    bool ResultBuilder::log() {
        if(m_at & assertType::is_throws) { //!OCLINT bitwise operator in conditional
            m_failed = !m_threw;
        } else if((m_at & assertType::is_throws_as) && (m_at & assertType::is_throws_with)) { //!OCLINT
            m_failed = !m_threw_as || !m_exception_string.check(m_exception);
        } else if(m_at & assertType::is_throws_as) { //!OCLINT bitwise operator in conditional
            m_failed = !m_threw_as;
        } else if(m_at & assertType::is_throws_with) { //!OCLINT bitwise operator in conditional
            m_failed = !m_exception_string.check(m_exception);
        } else if(m_at & assertType::is_nothrow) { //!OCLINT bitwise operator in conditional
            m_failed = m_threw;
        }

        if(m_exception.size())
            m_exception = "\"" + m_exception + "\"";

        if(is_running_in_test) {
            addAssert(m_at);
            DOCTEST_ITERATE_THROUGH_REPORTERS(log_assert, *this);

            if(m_failed)
                addFailedAssert(m_at);
        } else if(m_failed) {
            failed_out_of_a_testing_context(*this);
        }

        return m_failed && isDebuggerActive() && !getContextOptions()->no_breaks &&
            (g_cs->currentTest == nullptr || !g_cs->currentTest->m_no_breaks); // break into debugger
    }

    void ResultBuilder::react() const {
        if(m_failed && checkIfShouldThrow(m_at))
            throwException();
    }

    void failed_out_of_a_testing_context(const AssertData& ad) {
        if(g_cs->ah)
            g_cs->ah(ad);
        else
            std::abort();
    }

    bool decomp_assert(assertType::Enum at, const char* file, int line, const char* expr,
                       const Result& result) {
        bool failed = !result.m_passed;

        // ###################################################################################
        // IF THE DEBUGGER BREAKS HERE - GO 1 LEVEL UP IN THE CALLSTACK FOR THE FAILING ASSERT
        // THIS IS THE EFFECT OF HAVING 'DOCTEST_CONFIG_SUPER_FAST_ASSERTS' DEFINED
        // ###################################################################################
        DOCTEST_ASSERT_OUT_OF_TESTS(result.m_decomp);
        DOCTEST_ASSERT_IN_TESTS(result.m_decomp);
        return !failed;
    }

    MessageBuilder::MessageBuilder(const char* file, int line, assertType::Enum severity) {
        m_stream   = tlssPush();
        m_file     = file;
        m_line     = line;
        m_severity = severity;
    }

    MessageBuilder::~MessageBuilder() {
        if (!logged)
            tlssPop();
    }

    DOCTEST_DEFINE_INTERFACE(IExceptionTranslator)

    bool MessageBuilder::log() {
        if (!logged) {
            m_string = tlssPop();
            logged = true;
        }

        DOCTEST_ITERATE_THROUGH_REPORTERS(log_message, *this);

        const bool isWarn = m_severity & assertType::is_warn;

        // warn is just a message in this context so we don't treat it as an assert
        if(!isWarn) {
            addAssert(m_severity);
            addFailedAssert(m_severity);
        }

        return isDebuggerActive() && !getContextOptions()->no_breaks && !isWarn &&
            (g_cs->currentTest == nullptr || !g_cs->currentTest->m_no_breaks); // break into debugger
    }

    void MessageBuilder::react() {
        if(m_severity & assertType::is_require) //!OCLINT bitwise operator in conditional
            throwException();
    }
} // namespace detail
namespace {
    using namespace detail;

    // clang-format off

// =================================================================================================
// The following code has been taken verbatim from Catch2/include/internal/catch_xmlwriter.h/cpp
// This is done so cherry-picking bug fixes is trivial - even the style/formatting is untouched.
// =================================================================================================

    class XmlEncode {
    public:
        enum ForWhat { ForTextNodes, ForAttributes };

        XmlEncode( std::string const& str, ForWhat forWhat = ForTextNodes );

        void encodeTo( std::ostream& os ) const;

        friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode );

    private:
        std::string m_str;
        ForWhat m_forWhat;
    };

    class XmlWriter {
    public:

        class ScopedElement {
        public:
            ScopedElement( XmlWriter* writer );

            ScopedElement( ScopedElement&& other ) DOCTEST_NOEXCEPT;
            ScopedElement& operator=( ScopedElement&& other ) DOCTEST_NOEXCEPT;

            ~ScopedElement();

            ScopedElement& writeText( std::string const& text, bool indent = true );

            template<typename T>
            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {
                m_writer->writeAttribute( name, attribute );
                return *this;
            }

        private:
            mutable XmlWriter* m_writer = nullptr;
        };

#ifndef DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
        XmlWriter( std::ostream& os = std::cout );
#else // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
        XmlWriter( std::ostream& os );
#endif // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
        ~XmlWriter();

        XmlWriter( XmlWriter const& ) = delete;
        XmlWriter& operator=( XmlWriter const& ) = delete;

        XmlWriter& startElement( std::string const& name );

        ScopedElement scopedElement( std::string const& name );

        XmlWriter& endElement();

        XmlWriter& writeAttribute( std::string const& name, std::string const& attribute );

        XmlWriter& writeAttribute( std::string const& name, const char* attribute );

        XmlWriter& writeAttribute( std::string const& name, bool attribute );

        template<typename T>
        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
        std::stringstream rss;
            rss << attribute;
            return writeAttribute( name, rss.str() );
        }

        XmlWriter& writeText( std::string const& text, bool indent = true );

        //XmlWriter& writeComment( std::string const& text );

        //void writeStylesheetRef( std::string const& url );

        //XmlWriter& writeBlankLine();

        void ensureTagClosed();

        void writeDeclaration();

    private:

        void newlineIfNecessary();

        bool m_tagIsOpen = false;
        bool m_needsNewline = false;
        std::vector<std::string> m_tags;
        std::string m_indent;
        std::ostream& m_os;
    };

// =================================================================================================
// The following code has been taken verbatim from Catch2/include/internal/catch_xmlwriter.h/cpp
// This is done so cherry-picking bug fixes is trivial - even the style/formatting is untouched.
// =================================================================================================

using uchar = unsigned char;

namespace {

    size_t trailingBytes(unsigned char c) {
        if ((c & 0xE0) == 0xC0) {
            return 2;
        }
        if ((c & 0xF0) == 0xE0) {
            return 3;
        }
        if ((c & 0xF8) == 0xF0) {
            return 4;
        }
        DOCTEST_INTERNAL_ERROR("Invalid multibyte utf-8 start byte encountered");
    }

    uint32_t headerValue(unsigned char c) {
        if ((c & 0xE0) == 0xC0) {
            return c & 0x1F;
        }
        if ((c & 0xF0) == 0xE0) {
            return c & 0x0F;
        }
        if ((c & 0xF8) == 0xF0) {
            return c & 0x07;
        }
        DOCTEST_INTERNAL_ERROR("Invalid multibyte utf-8 start byte encountered");
    }

    void hexEscapeChar(std::ostream& os, unsigned char c) {
        std::ios_base::fmtflags f(os.flags());
        os << "\\x"
            << std::uppercase << std::hex << std::setfill('0') << std::setw(2)
            << static_cast<int>(c);
        os.flags(f);
    }

} // anonymous namespace

    XmlEncode::XmlEncode( std::string const& str, ForWhat forWhat )
    :   m_str( str ),
        m_forWhat( forWhat )
    {}

    void XmlEncode::encodeTo( std::ostream& os ) const {
        // Apostrophe escaping not necessary if we always use " to write attributes
        // (see: https://www.w3.org/TR/xml/#syntax)

        for( std::size_t idx = 0; idx < m_str.size(); ++ idx ) {
            uchar c = m_str[idx];
            switch (c) {
            case '<':   os << "&lt;"; break;
            case '&':   os << "&amp;"; break;

            case '>':
                // See: https://www.w3.org/TR/xml/#syntax
                if (idx > 2 && m_str[idx - 1] == ']' && m_str[idx - 2] == ']')
                    os << "&gt;";
                else
                    os << c;
                break;

            case '\"':
                if (m_forWhat == ForAttributes)
                    os << "&quot;";
                else
                    os << c;
                break;

            default:
                // Check for control characters and invalid utf-8

                // Escape control characters in standard ascii
                // see https://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0
                if (c < 0x09 || (c > 0x0D && c < 0x20) || c == 0x7F) {
                    hexEscapeChar(os, c);
                    break;
                }

                // Plain ASCII: Write it to stream
                if (c < 0x7F) {
                    os << c;
                    break;
                }

                // UTF-8 territory
                // Check if the encoding is valid and if it is not, hex escape bytes.
                // Important: We do not check the exact decoded values for validity, only the encoding format
                // First check that this bytes is a valid lead byte:
                // This means that it is not encoded as 1111 1XXX
                // Or as 10XX XXXX
                if (c <  0xC0 ||
                    c >= 0xF8) {
                    hexEscapeChar(os, c);
                    break;
                }

                auto encBytes = trailingBytes(c);
                // Are there enough bytes left to avoid accessing out-of-bounds memory?
                if (idx + encBytes - 1 >= m_str.size()) {
                    hexEscapeChar(os, c);
                    break;
                }
                // The header is valid, check data
                // The next encBytes bytes must together be a valid utf-8
                // This means: bitpattern 10XX XXXX and the extracted value is sane (ish)
                bool valid = true;
                uint32_t value = headerValue(c);
                for (std::size_t n = 1; n < encBytes; ++n) {
                    uchar nc = m_str[idx + n];
                    valid &= ((nc & 0xC0) == 0x80);
                    value = (value << 6) | (nc & 0x3F);
                }

                if (
                    // Wrong bit pattern of following bytes
                    (!valid) ||
                    // Overlong encodings
                    (value < 0x80) ||
                    (                 value < 0x800   && encBytes > 2) || // removed "0x80 <= value &&" because redundant
                    (0x800 < value && value < 0x10000 && encBytes > 3) ||
                    // Encoded value out of range
                    (value >= 0x110000)
                    ) {
                    hexEscapeChar(os, c);
                    break;
                }

                // If we got here, this is in fact a valid(ish) utf-8 sequence
                for (std::size_t n = 0; n < encBytes; ++n) {
                    os << m_str[idx + n];
                }
                idx += encBytes - 1;
                break;
            }
        }
    }

    std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode ) {
        xmlEncode.encodeTo( os );
        return os;
    }

    XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer )
    :   m_writer( writer )
    {}

    XmlWriter::ScopedElement::ScopedElement( ScopedElement&& other ) DOCTEST_NOEXCEPT
    :   m_writer( other.m_writer ){
        other.m_writer = nullptr;
    }
    XmlWriter::ScopedElement& XmlWriter::ScopedElement::operator=( ScopedElement&& other ) DOCTEST_NOEXCEPT {
        if ( m_writer ) {
            m_writer->endElement();
        }
        m_writer = other.m_writer;
        other.m_writer = nullptr;
        return *this;
    }


    XmlWriter::ScopedElement::~ScopedElement() {
        if( m_writer )
            m_writer->endElement();
    }

    XmlWriter::ScopedElement& XmlWriter::ScopedElement::writeText( std::string const& text, bool indent ) {
        m_writer->writeText( text, indent );
        return *this;
    }

    XmlWriter::XmlWriter( std::ostream& os ) : m_os( os )
    {
        // writeDeclaration(); // called explicitly by the reporters that use the writer class - see issue #627
    }

    XmlWriter::~XmlWriter() {
        while( !m_tags.empty() )
            endElement();
    }

    XmlWriter& XmlWriter::startElement( std::string const& name ) {
        ensureTagClosed();
        newlineIfNecessary();
        m_os << m_indent << '<' << name;
        m_tags.push_back( name );
        m_indent += "  ";
        m_tagIsOpen = true;
        return *this;
    }

    XmlWriter::ScopedElement XmlWriter::scopedElement( std::string const& name ) {
        ScopedElement scoped( this );
        startElement( name );
        return scoped;
    }

    XmlWriter& XmlWriter::endElement() {
        newlineIfNecessary();
        m_indent = m_indent.substr( 0, m_indent.size()-2 );
        if( m_tagIsOpen ) {
            m_os << "/>";
            m_tagIsOpen = false;
        }
        else {
            m_os << m_indent << "</" << m_tags.back() << ">";
        }
        m_os << std::endl;
        m_tags.pop_back();
        return *this;
    }

    XmlWriter& XmlWriter::writeAttribute( std::string const& name, std::string const& attribute ) {
        if( !name.empty() && !attribute.empty() )
            m_os << ' ' << name << "=\"" << XmlEncode( attribute, XmlEncode::ForAttributes ) << '"';
        return *this;
    }

    XmlWriter& XmlWriter::writeAttribute( std::string const& name, const char* attribute ) {
        if( !name.empty() && attribute && attribute[0] != '\0' )
            m_os << ' ' << name << "=\"" << XmlEncode( attribute, XmlEncode::ForAttributes ) << '"';
        return *this;
    }

    XmlWriter& XmlWriter::writeAttribute( std::string const& name, bool attribute ) {
        m_os << ' ' << name << "=\"" << ( attribute ? "true" : "false" ) << '"';
        return *this;
    }

    XmlWriter& XmlWriter::writeText( std::string const& text, bool indent ) {
        if( !text.empty() ){
            bool tagWasOpen = m_tagIsOpen;
            ensureTagClosed();
            if( tagWasOpen && indent )
                m_os << m_indent;
            m_os << XmlEncode( text );
            m_needsNewline = true;
        }
        return *this;
    }

    //XmlWriter& XmlWriter::writeComment( std::string const& text ) {
    //    ensureTagClosed();
    //    m_os << m_indent << "<!--" << text << "-->";
    //    m_needsNewline = true;
    //    return *this;
    //}

    //void XmlWriter::writeStylesheetRef( std::string const& url ) {
    //    m_os << "<?xml-stylesheet type=\"text/xsl\" href=\"" << url << "\"?>\n";
    //}

    //XmlWriter& XmlWriter::writeBlankLine() {
    //    ensureTagClosed();
    //    m_os << '\n';
    //    return *this;
    //}

    void XmlWriter::ensureTagClosed() {
        if( m_tagIsOpen ) {
            m_os << ">" << std::endl;
            m_tagIsOpen = false;
        }
    }

    void XmlWriter::writeDeclaration() {
        m_os << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
    }

    void XmlWriter::newlineIfNecessary() {
        if( m_needsNewline ) {
            m_os << std::endl;
            m_needsNewline = false;
        }
    }

// =================================================================================================
// End of copy-pasted code from Catch
// =================================================================================================

    // clang-format on

    struct XmlReporter : public IReporter
    {
        XmlWriter xml;
        DOCTEST_DECLARE_MUTEX(mutex)

        // caching pointers/references to objects of these types - safe to do
        const ContextOptions& opt;
        const TestCaseData*   tc = nullptr;

        XmlReporter(const ContextOptions& co)
                : xml(*co.cout)
                , opt(co) {}

        void log_contexts() {
            int num_contexts = get_num_active_contexts();
            if(num_contexts) {
                auto              contexts = get_active_contexts();
                std::stringstream ss;
                for(int i = 0; i < num_contexts; ++i) {
                    contexts[i]->stringify(&ss);
                    xml.scopedElement("Info").writeText(ss.str());
                    ss.str("");
                }
            }
        }

        unsigned line(unsigned l) const { return opt.no_line_numbers ? 0 : l; }

        void test_case_start_impl(const TestCaseData& in) {
            bool open_ts_tag = false;
            if(tc != nullptr) { // we have already opened a test suite
                if(std::strcmp(tc->m_test_suite, in.m_test_suite) != 0) {
                    xml.endElement();
                    open_ts_tag = true;
                }
            }
            else {
                open_ts_tag = true; // first test case ==> first test suite
            }

            if(open_ts_tag) {
                xml.startElement("TestSuite");
                xml.writeAttribute("name", in.m_test_suite);
            }

            tc = &in;
            xml.startElement("TestCase")
                    .writeAttribute("name", in.m_name)
                    .writeAttribute("filename", skipPathFromFilename(in.m_file.c_str()))
                    .writeAttribute("line", line(in.m_line))
                    .writeAttribute("description", in.m_description);

            if(Approx(in.m_timeout) != 0)
                xml.writeAttribute("timeout", in.m_timeout);
            if(in.m_may_fail)
                xml.writeAttribute("may_fail", true);
            if(in.m_should_fail)
                xml.writeAttribute("should_fail", true);
        }

        // =========================================================================================
        // WHAT FOLLOWS ARE OVERRIDES OF THE VIRTUAL METHODS OF THE REPORTER INTERFACE
        // =========================================================================================

        void report_query(const QueryData& in) override {
            test_run_start();
            if(opt.list_reporters) {
                for(auto& curr : getListeners())
                    xml.scopedElement("Listener")
                            .writeAttribute("priority", curr.first.first)
                            .writeAttribute("name", curr.first.second);
                for(auto& curr : getReporters())
                    xml.scopedElement("Reporter")
                            .writeAttribute("priority", curr.first.first)
                            .writeAttribute("name", curr.first.second);
            } else if(opt.count || opt.list_test_cases) {
                for(unsigned i = 0; i < in.num_data; ++i) {
                    xml.scopedElement("TestCase").writeAttribute("name", in.data[i]->m_name)
                        .writeAttribute("testsuite", in.data[i]->m_test_suite)
                        .writeAttribute("filename", skipPathFromFilename(in.data[i]->m_file.c_str()))
                        .writeAttribute("line", line(in.data[i]->m_line))
                        .writeAttribute("skipped", in.data[i]->m_skip);
                }
                xml.scopedElement("OverallResultsTestCases")
                        .writeAttribute("unskipped", in.run_stats->numTestCasesPassingFilters);
            } else if(opt.list_test_suites) {
                for(unsigned i = 0; i < in.num_data; ++i)
                    xml.scopedElement("TestSuite").writeAttribute("name", in.data[i]->m_test_suite);
                xml.scopedElement("OverallResultsTestCases")
                        .writeAttribute("unskipped", in.run_stats->numTestCasesPassingFilters);
                xml.scopedElement("OverallResultsTestSuites")
                        .writeAttribute("unskipped", in.run_stats->numTestSuitesPassingFilters);
            }
            xml.endElement();
        }

        void test_run_start() override {
            xml.writeDeclaration();

            // remove .exe extension - mainly to have the same output on UNIX and Windows
            std::string binary_name = skipPathFromFilename(opt.binary_name.c_str());
#ifdef DOCTEST_PLATFORM_WINDOWS
            if(binary_name.rfind(".exe") != std::string::npos)
                binary_name = binary_name.substr(0, binary_name.length() - 4);
#endif // DOCTEST_PLATFORM_WINDOWS

            xml.startElement("doctest").writeAttribute("binary", binary_name);
            if(opt.no_version == false)
                xml.writeAttribute("version", DOCTEST_VERSION_STR);

            // only the consequential ones (TODO: filters)
            xml.scopedElement("Options")
                    .writeAttribute("order_by", opt.order_by.c_str())
                    .writeAttribute("rand_seed", opt.rand_seed)
                    .writeAttribute("first", opt.first)
                    .writeAttribute("last", opt.last)
                    .writeAttribute("abort_after", opt.abort_after)
                    .writeAttribute("subcase_filter_levels", opt.subcase_filter_levels)
                    .writeAttribute("case_sensitive", opt.case_sensitive)
                    .writeAttribute("no_throw", opt.no_throw)
                    .writeAttribute("no_skip", opt.no_skip);
        }

        void test_run_end(const TestRunStats& p) override {
            if(tc) // the TestSuite tag - only if there has been at least 1 test case
                xml.endElement();

            xml.scopedElement("OverallResultsAsserts")
                    .writeAttribute("successes", p.numAsserts - p.numAssertsFailed)
                    .writeAttribute("failures", p.numAssertsFailed);

            xml.startElement("OverallResultsTestCases")
                    .writeAttribute("successes",
                                    p.numTestCasesPassingFilters - p.numTestCasesFailed)
                    .writeAttribute("failures", p.numTestCasesFailed);
            if(opt.no_skipped_summary == false)
                xml.writeAttribute("skipped", p.numTestCases - p.numTestCasesPassingFilters);
            xml.endElement();

            xml.endElement();
        }

        void test_case_start(const TestCaseData& in) override {
            test_case_start_impl(in);
            xml.ensureTagClosed();
        }

        void test_case_reenter(const TestCaseData&) override {}

        void test_case_end(const CurrentTestCaseStats& st) override {
            xml.startElement("OverallResultsAsserts")
                    .writeAttribute("successes",
                                    st.numAssertsCurrentTest - st.numAssertsFailedCurrentTest)
                    .writeAttribute("failures", st.numAssertsFailedCurrentTest)
                    .writeAttribute("test_case_success", st.testCaseSuccess);
            if(opt.duration)
                xml.writeAttribute("duration", st.seconds);
            if(tc->m_expected_failures)
                xml.writeAttribute("expected_failures", tc->m_expected_failures);
            xml.endElement();

            xml.endElement();
        }

        void test_case_exception(const TestCaseException& e) override {
            DOCTEST_LOCK_MUTEX(mutex)

            xml.scopedElement("Exception")
                    .writeAttribute("crash", e.is_crash)
                    .writeText(e.error_string.c_str());
        }

        void subcase_start(const SubcaseSignature& in) override {
            xml.startElement("SubCase")
                    .writeAttribute("name", in.m_name)
                    .writeAttribute("filename", skipPathFromFilename(in.m_file))
                    .writeAttribute("line", line(in.m_line));
            xml.ensureTagClosed();
        }

        void subcase_end() override { xml.endElement(); }

        void log_assert(const AssertData& rb) override {
            if(!rb.m_failed && !opt.success)
                return;

            DOCTEST_LOCK_MUTEX(mutex)

            xml.startElement("Expression")
                    .writeAttribute("success", !rb.m_failed)
                    .writeAttribute("type", assertString(rb.m_at))
                    .writeAttribute("filename", skipPathFromFilename(rb.m_file))
                    .writeAttribute("line", line(rb.m_line));

            xml.scopedElement("Original").writeText(rb.m_expr);

            if(rb.m_threw)
                xml.scopedElement("Exception").writeText(rb.m_exception.c_str());

            if(rb.m_at & assertType::is_throws_as)
                xml.scopedElement("ExpectedException").writeText(rb.m_exception_type);
            if(rb.m_at & assertType::is_throws_with)
                xml.scopedElement("ExpectedExceptionString").writeText(rb.m_exception_string.c_str());
            if((rb.m_at & assertType::is_normal) && !rb.m_threw)
                xml.scopedElement("Expanded").writeText(rb.m_decomp.c_str());

            log_contexts();

            xml.endElement();
        }

        void log_message(const MessageData& mb) override {
            DOCTEST_LOCK_MUTEX(mutex)

            xml.startElement("Message")
                    .writeAttribute("type", failureString(mb.m_severity))
                    .writeAttribute("filename", skipPathFromFilename(mb.m_file))
                    .writeAttribute("line", line(mb.m_line));

            xml.scopedElement("Text").writeText(mb.m_string.c_str());

            log_contexts();

            xml.endElement();
        }

        void test_case_skipped(const TestCaseData& in) override {
            if(opt.no_skipped_summary == false) {
                test_case_start_impl(in);
                xml.writeAttribute("skipped", "true");
                xml.endElement();
            }
        }
    };

    DOCTEST_REGISTER_REPORTER("xml", 0, XmlReporter);

    void fulltext_log_assert_to_stream(std::ostream& s, const AssertData& rb) {
        if((rb.m_at & (assertType::is_throws_as | assertType::is_throws_with)) ==
            0) //!OCLINT bitwise operator in conditional
            s << Color::Cyan << assertString(rb.m_at) << "( " << rb.m_expr << " ) "
                << Color::None;

        if(rb.m_at & assertType::is_throws) { //!OCLINT bitwise operator in conditional
            s << (rb.m_threw ? "threw as expected!" : "did NOT throw at all!") << "\n";
        } else if((rb.m_at & assertType::is_throws_as) &&
                    (rb.m_at & assertType::is_throws_with)) { //!OCLINT
            s << Color::Cyan << assertString(rb.m_at) << "( " << rb.m_expr << ", \""
                << rb.m_exception_string.c_str()
                << "\", " << rb.m_exception_type << " ) " << Color::None;
            if(rb.m_threw) {
                if(!rb.m_failed) {
                    s << "threw as expected!\n";
                } else {
                    s << "threw a DIFFERENT exception! (contents: " << rb.m_exception << ")\n";
                }
            } else {
                s << "did NOT throw at all!\n";
            }
        } else if(rb.m_at &
                    assertType::is_throws_as) { //!OCLINT bitwise operator in conditional
            s << Color::Cyan << assertString(rb.m_at) << "( " << rb.m_expr << ", "
                << rb.m_exception_type << " ) " << Color::None
                << (rb.m_threw ? (rb.m_threw_as ? "threw as expected!" :
                                                "threw a DIFFERENT exception: ") :
                                "did NOT throw at all!")
                << Color::Cyan << rb.m_exception << "\n";
        } else if(rb.m_at &
                    assertType::is_throws_with) { //!OCLINT bitwise operator in conditional
            s << Color::Cyan << assertString(rb.m_at) << "( " << rb.m_expr << ", \""
                << rb.m_exception_string.c_str()
                << "\" ) " << Color::None
                << (rb.m_threw ? (!rb.m_failed ? "threw as expected!" :
                                                "threw a DIFFERENT exception: ") :
                                "did NOT throw at all!")
                << Color::Cyan << rb.m_exception << "\n";
        } else if(rb.m_at & assertType::is_nothrow) { //!OCLINT bitwise operator in conditional
            s << (rb.m_threw ? "THREW exception: " : "didn't throw!") << Color::Cyan
                << rb.m_exception << "\n";
        } else {
            s << (rb.m_threw ? "THREW exception: " :
                                (!rb.m_failed ? "is correct!\n" : "is NOT correct!\n"));
            if(rb.m_threw)
                s << rb.m_exception << "\n";
            else
                s << "  values: " << assertString(rb.m_at) << "( " << rb.m_decomp << " )\n";
        }
    }

    // TODO:
    // - log_message()
    // - respond to queries
    // - honor remaining options
    // - more attributes in tags
    struct JUnitReporter : public IReporter
    {
        XmlWriter xml;
        DOCTEST_DECLARE_MUTEX(mutex)
        Timer timer;
        std::vector<String> deepestSubcaseStackNames;

        struct JUnitTestCaseData
        {
            static std::string getCurrentTimestamp() {
                // Beware, this is not reentrant because of backward compatibility issues
                // Also, UTC only, again because of backward compatibility (%z is C++11)
                time_t rawtime;
                std::time(&rawtime);
                auto const timeStampSize = sizeof("2017-01-16T17:06:45Z");

                std::tm timeInfo;
#ifdef DOCTEST_PLATFORM_WINDOWS
                gmtime_s(&timeInfo, &rawtime);
#else // DOCTEST_PLATFORM_WINDOWS
                gmtime_r(&rawtime, &timeInfo);
#endif // DOCTEST_PLATFORM_WINDOWS

                char timeStamp[timeStampSize];
                const char* const fmt = "%Y-%m-%dT%H:%M:%SZ";

                std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);
                return std::string(timeStamp);
            }

            struct JUnitTestMessage
            {
                JUnitTestMessage(const std::string& _message, const std::string& _type, const std::string& _details)
                    : message(_message), type(_type), details(_details) {}

                JUnitTestMessage(const std::string& _message, const std::string& _details)
                    : message(_message), type(), details(_details) {}

                std::string message, type, details;
            };

            struct JUnitTestCase
            {
                JUnitTestCase(const std::string& _classname, const std::string& _name)
                    : classname(_classname), name(_name), time(0), failures() {}

                std::string classname, name;
                double time;
                std::vector<JUnitTestMessage> failures, errors;
            };

            void add(const std::string& classname, const std::string& name) {
                testcases.emplace_back(classname, name);
            }

            void appendSubcaseNamesToLastTestcase(std::vector<String> nameStack) {
                for(auto& curr: nameStack)
                    if(curr.size())
                        testcases.back().name += std::string("/") + curr.c_str();
            }

            void addTime(double time) {
                if(time < 1e-4)
                    time = 0;
                testcases.back().time = time;
                totalSeconds += time;
            }

            void addFailure(const std::string& message, const std::string& type, const std::string& details) {
                testcases.back().failures.emplace_back(message, type, details);
                ++totalFailures;
            }

            void addError(const std::string& message, const std::string& details) {
                testcases.back().errors.emplace_back(message, details);
                ++totalErrors;
            }

            std::vector<JUnitTestCase> testcases;
            double totalSeconds = 0;
            int totalErrors = 0, totalFailures = 0;
        };

        JUnitTestCaseData testCaseData;

        // caching pointers/references to objects of these types - safe to do
        const ContextOptions& opt;
        const TestCaseData*   tc = nullptr;

        JUnitReporter(const ContextOptions& co)
                : xml(*co.cout)
                , opt(co) {}

        unsigned line(unsigned l) const { return opt.no_line_numbers ? 0 : l; }

        // =========================================================================================
        // WHAT FOLLOWS ARE OVERRIDES OF THE VIRTUAL METHODS OF THE REPORTER INTERFACE
        // =========================================================================================

        void report_query(const QueryData&) override {
            xml.writeDeclaration();
        }

        void test_run_start() override {
            xml.writeDeclaration();
        }

        void test_run_end(const TestRunStats& p) override {
            // remove .exe extension - mainly to have the same output on UNIX and Windows
            std::string binary_name = skipPathFromFilename(opt.binary_name.c_str());
#ifdef DOCTEST_PLATFORM_WINDOWS
            if(binary_name.rfind(".exe") != std::string::npos)
                binary_name = binary_name.substr(0, binary_name.length() - 4);
#endif // DOCTEST_PLATFORM_WINDOWS
            xml.startElement("testsuites");
            xml.startElement("testsuite").writeAttribute("name", binary_name)
                    .writeAttribute("errors", testCaseData.totalErrors)
                    .writeAttribute("failures", testCaseData.totalFailures)
                    .writeAttribute("tests", p.numAsserts);
            if(opt.no_time_in_output == false) {
                xml.writeAttribute("time", testCaseData.totalSeconds);
                xml.writeAttribute("timestamp", JUnitTestCaseData::getCurrentTimestamp());
            }
            if(opt.no_version == false)
                xml.writeAttribute("doctest_version", DOCTEST_VERSION_STR);

            for(const auto& testCase : testCaseData.testcases) {
                xml.startElement("testcase")
                    .writeAttribute("classname", testCase.classname)
                    .writeAttribute("name", testCase.name);
                if(opt.no_time_in_output == false)
                    xml.writeAttribute("time", testCase.time);
                // This is not ideal, but it should be enough to mimic gtest's junit output.
                xml.writeAttribute("status", "run");

                for(const auto& failure : testCase.failures) {
                    xml.scopedElement("failure")
                        .writeAttribute("message", failure.message)
                        .writeAttribute("type", failure.type)
                        .writeText(failure.details, false);
                }

                for(const auto& error : testCase.errors) {
                    xml.scopedElement("error")
                        .writeAttribute("message", error.message)
                        .writeText(error.details);
                }

                xml.endElement();
            }
            xml.endElement();
            xml.endElement();
        }

        void test_case_start(const TestCaseData& in) override {
            testCaseData.add(skipPathFromFilename(in.m_file.c_str()), in.m_name);
            timer.start();
        }

        void test_case_reenter(const TestCaseData& in) override {
            testCaseData.addTime(timer.getElapsedSeconds());
            testCaseData.appendSubcaseNamesToLastTestcase(deepestSubcaseStackNames);
            deepestSubcaseStackNames.clear();

            timer.start();
            testCaseData.add(skipPathFromFilename(in.m_file.c_str()), in.m_name);
        }

        void test_case_end(const CurrentTestCaseStats&) override {
            testCaseData.addTime(timer.getElapsedSeconds());
            testCaseData.appendSubcaseNamesToLastTestcase(deepestSubcaseStackNames);
            deepestSubcaseStackNames.clear();
        }

        void test_case_exception(const TestCaseException& e) override {
            DOCTEST_LOCK_MUTEX(mutex)
            testCaseData.addError("exception", e.error_string.c_str());
        }

        void subcase_start(const SubcaseSignature& in) override {
            deepestSubcaseStackNames.push_back(in.m_name);
        }

        void subcase_end() override {}

        void log_assert(const AssertData& rb) override {
            if(!rb.m_failed) // report only failures & ignore the `success` option
                return;

            DOCTEST_LOCK_MUTEX(mutex)

            std::ostringstream os;
            os << skipPathFromFilename(rb.m_file) << (opt.gnu_file_line ? ":" : "(")
              << line(rb.m_line) << (opt.gnu_file_line ? ":" : "):") << std::endl;

            fulltext_log_assert_to_stream(os, rb);
            log_contexts(os);
            testCaseData.addFailure(rb.m_decomp.c_str(), assertString(rb.m_at), os.str());
        }

        void log_message(const MessageData& mb) override {
            if(mb.m_severity & assertType::is_warn) // report only failures
                return;

            DOCTEST_LOCK_MUTEX(mutex)

            std::ostringstream os;
            os << skipPathFromFilename(mb.m_file) << (opt.gnu_file_line ? ":" : "(")
              << line(mb.m_line) << (opt.gnu_file_line ? ":" : "):") << std::endl;

            os << mb.m_string.c_str() << "\n";
            log_contexts(os);

            testCaseData.addFailure(mb.m_string.c_str(),
                mb.m_severity & assertType::is_check ? "FAIL_CHECK" : "FAIL", os.str());
        }

        void test_case_skipped(const TestCaseData&) override {}

        void log_contexts(std::ostringstream& s) {
            int num_contexts = get_num_active_contexts();
            if(num_contexts) {
                auto contexts = get_active_contexts();

                s << "  logged: ";
                for(int i = 0; i < num_contexts; ++i) {
                    s << (i == 0 ? "" : "          ");
                    contexts[i]->stringify(&s);
                    s << std::endl;
                }
            }
        }
    };

    DOCTEST_REGISTER_REPORTER("junit", 0, JUnitReporter);

    struct Whitespace
    {
        int nrSpaces;
        explicit Whitespace(int nr)
                : nrSpaces(nr) {}
    };

    std::ostream& operator<<(std::ostream& out, const Whitespace& ws) {
        if(ws.nrSpaces != 0)
            out << std::setw(ws.nrSpaces) << ' ';
        return out;
    }

    struct ConsoleReporter : public IReporter
    {
        std::ostream&                 s;
        bool                          hasLoggedCurrentTestStart;
        std::vector<SubcaseSignature> subcasesStack;
        size_t                        currentSubcaseLevel;
        DOCTEST_DECLARE_MUTEX(mutex)

        // caching pointers/references to objects of these types - safe to do
        const ContextOptions& opt;
        const TestCaseData*   tc;

        ConsoleReporter(const ContextOptions& co)
                : s(*co.cout)
                , opt(co) {}

        ConsoleReporter(const ContextOptions& co, std::ostream& ostr)
                : s(ostr)
                , opt(co) {}

        // =========================================================================================
        // WHAT FOLLOWS ARE HELPERS USED BY THE OVERRIDES OF THE VIRTUAL METHODS OF THE INTERFACE
        // =========================================================================================

        void separator_to_stream() {
            s << Color::Yellow
              << "==============================================================================="
                 "\n";
        }

        const char* getSuccessOrFailString(bool success, assertType::Enum at,
                                           const char* success_str) {
            if(success)
                return success_str;
            return failureString(at);
        }

        Color::Enum getSuccessOrFailColor(bool success, assertType::Enum at) {
            return success ? Color::BrightGreen :
                             (at & assertType::is_warn) ? Color::Yellow : Color::Red;
        }

        void successOrFailColoredStringToStream(bool success, assertType::Enum at,
                                                const char* success_str = "SUCCESS") {
            s << getSuccessOrFailColor(success, at)
              << getSuccessOrFailString(success, at, success_str) << ": ";
        }

        void log_contexts() {
            int num_contexts = get_num_active_contexts();
            if(num_contexts) {
                auto contexts = get_active_contexts();

                s << Color::None << "  logged: ";
                for(int i = 0; i < num_contexts; ++i) {
                    s << (i == 0 ? "" : "          ");
                    contexts[i]->stringify(&s);
                    s << "\n";
                }
            }

            s << "\n";
        }

        // this was requested to be made virtual so users could override it
        virtual void file_line_to_stream(const char* file, int line,
                                        const char* tail = "") {
            s << Color::LightGrey << skipPathFromFilename(file) << (opt.gnu_file_line ? ":" : "(")
            << (opt.no_line_numbers ? 0 : line) // 0 or the real num depending on the option
            << (opt.gnu_file_line ? ":" : "):") << tail;
        }

        void logTestStart() {
            if(hasLoggedCurrentTestStart)
                return;

            separator_to_stream();
            file_line_to_stream(tc->m_file.c_str(), tc->m_line, "\n");
            if(tc->m_description)
                s << Color::Yellow << "DESCRIPTION: " << Color::None << tc->m_description << "\n";
            if(tc->m_test_suite && tc->m_test_suite[0] != '\0')
                s << Color::Yellow << "TEST SUITE: " << Color::None << tc->m_test_suite << "\n";
            if(strncmp(tc->m_name, "  Scenario:", 11) != 0)
                s << Color::Yellow << "TEST CASE:  ";
            s << Color::None << tc->m_name << "\n";

            for(size_t i = 0; i < currentSubcaseLevel; ++i) {
                if(subcasesStack[i].m_name[0] != '\0')
                    s << "  " << subcasesStack[i].m_name << "\n";
            }

            if(currentSubcaseLevel != subcasesStack.size()) {
                s << Color::Yellow << "\nDEEPEST SUBCASE STACK REACHED (DIFFERENT FROM THE CURRENT ONE):\n" << Color::None;
                for(size_t i = 0; i < subcasesStack.size(); ++i) {
                    if(subcasesStack[i].m_name[0] != '\0')
                        s << "  " << subcasesStack[i].m_name << "\n";
                }
            }

            s << "\n";

            hasLoggedCurrentTestStart = true;
        }

        void printVersion() {
            if(opt.no_version == false)
                s << Color::Cyan << "[doctest] " << Color::None << "doctest version is \""
                  << DOCTEST_VERSION_STR << "\"\n";
        }

        void printIntro() {
            if(opt.no_intro == false) {
                printVersion();
                s << Color::Cyan << "[doctest] " << Color::None
                  << "run with \"--" DOCTEST_OPTIONS_PREFIX_DISPLAY "help\" for options\n";
            }
        }

        void printHelp() {
            int sizePrefixDisplay = static_cast<int>(strlen(DOCTEST_OPTIONS_PREFIX_DISPLAY));
            printVersion();
            // clang-format off
            s << Color::Cyan << "[doctest]\n" << Color::None;
            s << Color::Cyan << "[doctest] " << Color::None;
            s << "boolean values: \"1/on/yes/true\" or \"0/off/no/false\"\n";
            s << Color::Cyan << "[doctest] " << Color::None;
            s << "filter  values: \"str1,str2,str3\" (comma separated strings)\n";
            s << Color::Cyan << "[doctest]\n" << Color::None;
            s << Color::Cyan << "[doctest] " << Color::None;
            s << "filters use wildcards for matching strings\n";
            s << Color::Cyan << "[doctest] " << Color::None;
            s << "something passes a filter if any of the strings in a filter matches\n";
#ifndef DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS
            s << Color::Cyan << "[doctest]\n" << Color::None;
            s << Color::Cyan << "[doctest] " << Color::None;
            s << "ALL FLAGS, OPTIONS AND FILTERS ALSO AVAILABLE WITH A \"" DOCTEST_CONFIG_OPTIONS_PREFIX "\" PREFIX!!!\n";
#endif
            s << Color::Cyan << "[doctest]\n" << Color::None;
            s << Color::Cyan << "[doctest] " << Color::None;
            s << "Query flags - the program quits after them. Available:\n\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "?,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "help, -" DOCTEST_OPTIONS_PREFIX_DISPLAY "h                      "
              << Whitespace(sizePrefixDisplay*0) <<  "prints this message\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "v,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "version                       "
              << Whitespace(sizePrefixDisplay*1) << "prints the version\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "c,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "count                         "
              << Whitespace(sizePrefixDisplay*1) << "prints the number of matching tests\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ltc, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "list-test-cases               "
              << Whitespace(sizePrefixDisplay*1) << "lists all matching tests by name\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "lts, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "list-test-suites              "
              << Whitespace(sizePrefixDisplay*1) << "lists all matching test suites\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "lr,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "list-reporters                "
              << Whitespace(sizePrefixDisplay*1) << "lists all registered reporters\n\n";
            // ================================================================================== << 79
            s << Color::Cyan << "[doctest] " << Color::None;
            s << "The available <int>/<string> options/filters are:\n\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "tc,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "test-case=<filters>           "
              << Whitespace(sizePrefixDisplay*1) << "filters     tests by their name\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "tce, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "test-case-exclude=<filters>   "
              << Whitespace(sizePrefixDisplay*1) << "filters OUT tests by their name\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "sf,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "source-file=<filters>         "
              << Whitespace(sizePrefixDisplay*1) << "filters     tests by their file\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "sfe, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "source-file-exclude=<filters> "
              << Whitespace(sizePrefixDisplay*1) << "filters OUT tests by their file\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ts,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "test-suite=<filters>          "
              << Whitespace(sizePrefixDisplay*1) << "filters     tests by their test suite\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "tse, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "test-suite-exclude=<filters>  "
              << Whitespace(sizePrefixDisplay*1) << "filters OUT tests by their test suite\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "sc,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "subcase=<filters>             "
              << Whitespace(sizePrefixDisplay*1) << "filters     subcases by their name\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "sce, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "subcase-exclude=<filters>     "
              << Whitespace(sizePrefixDisplay*1) << "filters OUT subcases by their name\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "r,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "reporters=<filters>           "
              << Whitespace(sizePrefixDisplay*1) << "reporters to use (console is default)\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "o,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "out=<string>                  "
              << Whitespace(sizePrefixDisplay*1) << "output filename\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ob,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "order-by=<string>             "
              << Whitespace(sizePrefixDisplay*1) << "how the tests should be ordered\n";
            s << Whitespace(sizePrefixDisplay*3) << "                                       <string> - [file/suite/name/rand/none]\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "rs,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "rand-seed=<int>               "
              << Whitespace(sizePrefixDisplay*1) << "seed for random ordering\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "f,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "first=<int>                   "
              << Whitespace(sizePrefixDisplay*1) << "the first test passing the filters to\n";
            s << Whitespace(sizePrefixDisplay*3) << "                                       execute - for range-based execution\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "l,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "last=<int>                    "
              << Whitespace(sizePrefixDisplay*1) << "the last test passing the filters to\n";
            s << Whitespace(sizePrefixDisplay*3) << "                                       execute - for range-based execution\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "aa,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "abort-after=<int>             "
              << Whitespace(sizePrefixDisplay*1) << "stop after <int> failed assertions\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "scfl,--" DOCTEST_OPTIONS_PREFIX_DISPLAY "subcase-filter-levels=<int>   "
              << Whitespace(sizePrefixDisplay*1) << "apply filters for the first <int> levels\n";
            s << Color::Cyan << "\n[doctest] " << Color::None;
            s << "Bool options - can be used like flags and true is assumed. Available:\n\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "s,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "success=<bool>                "
              << Whitespace(sizePrefixDisplay*1) << "include successful assertions in output\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "cs,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "case-sensitive=<bool>         "
              << Whitespace(sizePrefixDisplay*1) << "filters being treated as case sensitive\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "e,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "exit=<bool>                   "
              << Whitespace(sizePrefixDisplay*1) << "exits after the tests finish\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "d,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "duration=<bool>               "
              << Whitespace(sizePrefixDisplay*1) << "prints the time duration of each test\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "m,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "minimal=<bool>                "
              << Whitespace(sizePrefixDisplay*1) << "minimal console output (only failures)\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "q,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "quiet=<bool>                  "
              << Whitespace(sizePrefixDisplay*1) << "no console output\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nt,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-throw=<bool>               "
              << Whitespace(sizePrefixDisplay*1) << "skips exceptions-related assert checks\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ne,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-exitcode=<bool>            "
              << Whitespace(sizePrefixDisplay*1) << "returns (or exits) always with success\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nr,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-run=<bool>                 "
              << Whitespace(sizePrefixDisplay*1) << "skips all runtime doctest operations\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ni,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-intro=<bool>               "
              << Whitespace(sizePrefixDisplay*1) << "omit the framework intro in the output\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nv,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-version=<bool>             "
              << Whitespace(sizePrefixDisplay*1) << "omit the framework version in the output\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nc,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-colors=<bool>              "
              << Whitespace(sizePrefixDisplay*1) << "disables colors in output\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "fc,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "force-colors=<bool>           "
              << Whitespace(sizePrefixDisplay*1) << "use colors even when not in a tty\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nb,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-breaks=<bool>              "
              << Whitespace(sizePrefixDisplay*1) << "disables breakpoints in debuggers\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ns,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-skip=<bool>                "
              << Whitespace(sizePrefixDisplay*1) << "don't skip test cases marked as skip\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "gfl, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "gnu-file-line=<bool>          "
              << Whitespace(sizePrefixDisplay*1) << ":n: vs (n): for line numbers in output\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "npf, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-path-filenames=<bool>      "
              << Whitespace(sizePrefixDisplay*1) << "only filenames and no paths in output\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "spp, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "skip-path-prefixes=<p1:p2>    "
              << Whitespace(sizePrefixDisplay*1) << "whenever file paths start with this prefix, remove it from the output\n";
            s << " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nln, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-line-numbers=<bool>        "
              << Whitespace(sizePrefixDisplay*1) << "0 instead of real line numbers in output\n";
            // ================================================================================== << 79
            // clang-format on

            s << Color::Cyan << "\n[doctest] " << Color::None;
            s << "for more information visit the project documentation\n\n";
        }

        void printRegisteredReporters() {
            printVersion();
            auto printReporters = [this] (const reporterMap& reporters, const char* type) {
                if(reporters.size()) {
                    s << Color::Cyan << "[doctest] " << Color::None << "listing all registered " << type << "\n";
                    for(auto& curr : reporters)
                        s << "priority: " << std::setw(5) << curr.first.first
                          << " name: " << curr.first.second << "\n";
                }
            };
            printReporters(getListeners(), "listeners");
            printReporters(getReporters(), "reporters");
        }

        // =========================================================================================
        // WHAT FOLLOWS ARE OVERRIDES OF THE VIRTUAL METHODS OF THE REPORTER INTERFACE
        // =========================================================================================

        void report_query(const QueryData& in) override {
            if(opt.version) {
                printVersion();
            } else if(opt.help) {
                printHelp();
            } else if(opt.list_reporters) {
                printRegisteredReporters();
            } else if(opt.count || opt.list_test_cases) {
                if(opt.list_test_cases) {
                    s << Color::Cyan << "[doctest] " << Color::None
                      << "listing all test case names\n";
                    separator_to_stream();
                }

                for(unsigned i = 0; i < in.num_data; ++i)
                    s << Color::None << in.data[i]->m_name << "\n";

                separator_to_stream();

                s << Color::Cyan << "[doctest] " << Color::None
                  << "unskipped test cases passing the current filters: "
                  << g_cs->numTestCasesPassingFilters << "\n";

            } else if(opt.list_test_suites) {
                s << Color::Cyan << "[doctest] " << Color::None << "listing all test suites\n";
                separator_to_stream();

                for(unsigned i = 0; i < in.num_data; ++i)
                    s << Color::None << in.data[i]->m_test_suite << "\n";

                separator_to_stream();

                s << Color::Cyan << "[doctest] " << Color::None
                  << "unskipped test cases passing the current filters: "
                  << g_cs->numTestCasesPassingFilters << "\n";
                s << Color::Cyan << "[doctest] " << Color::None
                  << "test suites with unskipped test cases passing the current filters: "
                  << g_cs->numTestSuitesPassingFilters << "\n";
            }
        }

        void test_run_start() override {
            if(!opt.minimal)
                printIntro();
        }

        void test_run_end(const TestRunStats& p) override {
            if(opt.minimal && p.numTestCasesFailed == 0)
                return;

            separator_to_stream();
            s << std::dec;

            auto totwidth = int(std::ceil(log10(static_cast<double>(std::max(p.numTestCasesPassingFilters, static_cast<unsigned>(p.numAsserts))) + 1)));
            auto passwidth = int(std::ceil(log10(static_cast<double>(std::max(p.numTestCasesPassingFilters - p.numTestCasesFailed, static_cast<unsigned>(p.numAsserts - p.numAssertsFailed))) + 1)));
            auto failwidth = int(std::ceil(log10(static_cast<double>(std::max(p.numTestCasesFailed, static_cast<unsigned>(p.numAssertsFailed))) + 1)));
            const bool anythingFailed = p.numTestCasesFailed > 0 || p.numAssertsFailed > 0;
            s << Color::Cyan << "[doctest] " << Color::None << "test cases: " << std::setw(totwidth)
              << p.numTestCasesPassingFilters << " | "
              << ((p.numTestCasesPassingFilters == 0 || anythingFailed) ? Color::None :
                                                                          Color::Green)
              << std::setw(passwidth) << p.numTestCasesPassingFilters - p.numTestCasesFailed << " passed"
              << Color::None << " | " << (p.numTestCasesFailed > 0 ? Color::Red : Color::None)
              << std::setw(failwidth) << p.numTestCasesFailed << " failed" << Color::None << " |";
            if(opt.no_skipped_summary == false) {
                const int numSkipped = p.numTestCases - p.numTestCasesPassingFilters;
                s << " " << (numSkipped == 0 ? Color::None : Color::Yellow) << numSkipped
                  << " skipped" << Color::None;
            }
            s << "\n";
            s << Color::Cyan << "[doctest] " << Color::None << "assertions: " << std::setw(totwidth)
              << p.numAsserts << " | "
              << ((p.numAsserts == 0 || anythingFailed) ? Color::None : Color::Green)
              << std::setw(passwidth) << (p.numAsserts - p.numAssertsFailed) << " passed" << Color::None
              << " | " << (p.numAssertsFailed > 0 ? Color::Red : Color::None) << std::setw(failwidth)
              << p.numAssertsFailed << " failed" << Color::None << " |\n";
            s << Color::Cyan << "[doctest] " << Color::None
              << "Status: " << (p.numTestCasesFailed > 0 ? Color::Red : Color::Green)
              << ((p.numTestCasesFailed > 0) ? "FAILURE!" : "SUCCESS!") << Color::None << std::endl;
        }

        void test_case_start(const TestCaseData& in) override {
            hasLoggedCurrentTestStart = false;
            tc                        = &in;
            subcasesStack.clear();
            currentSubcaseLevel = 0;
        }

        void test_case_reenter(const TestCaseData&) override {
            subcasesStack.clear();
        }

        void test_case_end(const CurrentTestCaseStats& st) override {
            if(tc->m_no_output)
                return;

            // log the preamble of the test case only if there is something
            // else to print - something other than that an assert has failed
            if(opt.duration ||
               (st.failure_flags && st.failure_flags != static_cast<int>(TestCaseFailureReason::AssertFailure)))
                logTestStart();

            if(opt.duration)
                s << Color::None << std::setprecision(6) << std::fixed << st.seconds
                  << " s: " << tc->m_name << "\n";

            if(st.failure_flags & TestCaseFailureReason::Timeout)
                s << Color::Red << "Test case exceeded time limit of " << std::setprecision(6)
                  << std::fixed << tc->m_timeout << "!\n";

            if(st.failure_flags & TestCaseFailureReason::ShouldHaveFailedButDidnt) {
                s << Color::Red << "Should have failed but didn't! Marking it as failed!\n";
            } else if(st.failure_flags & TestCaseFailureReason::ShouldHaveFailedAndDid) {
                s << Color::Yellow << "Failed as expected so marking it as not failed\n";
            } else if(st.failure_flags & TestCaseFailureReason::CouldHaveFailedAndDid) {
                s << Color::Yellow << "Allowed to fail so marking it as not failed\n";
            } else if(st.failure_flags & TestCaseFailureReason::DidntFailExactlyNumTimes) {
                s << Color::Red << "Didn't fail exactly " << tc->m_expected_failures
                  << " times so marking it as failed!\n";
            } else if(st.failure_flags & TestCaseFailureReason::FailedExactlyNumTimes) {
                s << Color::Yellow << "Failed exactly " << tc->m_expected_failures
                  << " times as expected so marking it as not failed!\n";
            }
            if(st.failure_flags & TestCaseFailureReason::TooManyFailedAsserts) {
                s << Color::Red << "Aborting - too many failed asserts!\n";
            }
            s << Color::None; // lgtm [cpp/useless-expression]
        }

        void test_case_exception(const TestCaseException& e) override {
            DOCTEST_LOCK_MUTEX(mutex)
            if(tc->m_no_output)
                return;

            logTestStart();

            file_line_to_stream(tc->m_file.c_str(), tc->m_line, " ");
            successOrFailColoredStringToStream(false, e.is_crash ? assertType::is_require :
                                                                   assertType::is_check);
            s << Color::Red << (e.is_crash ? "test case CRASHED: " : "test case THREW exception: ")
              << Color::Cyan << e.error_string << "\n";

            int num_stringified_contexts = get_num_stringified_contexts();
            if(num_stringified_contexts) {
                auto stringified_contexts = get_stringified_contexts();
                s << Color::None << "  logged: ";
                for(int i = num_stringified_contexts; i > 0; --i) {
                    s << (i == num_stringified_contexts ? "" : "          ")
                      << stringified_contexts[i - 1] << "\n";
                }
            }
            s << "\n" << Color::None;
        }

        void subcase_start(const SubcaseSignature& subc) override {
            subcasesStack.push_back(subc);
            ++currentSubcaseLevel;
            hasLoggedCurrentTestStart = false;
        }

        void subcase_end() override {
            --currentSubcaseLevel;
            hasLoggedCurrentTestStart = false;
        }

        void log_assert(const AssertData& rb) override {
            if((!rb.m_failed && !opt.success) || tc->m_no_output)
                return;

            DOCTEST_LOCK_MUTEX(mutex)

            logTestStart();

            file_line_to_stream(rb.m_file, rb.m_line, " ");
            successOrFailColoredStringToStream(!rb.m_failed, rb.m_at);

            fulltext_log_assert_to_stream(s, rb);

            log_contexts();
        }

        void log_message(const MessageData& mb) override {
            if(tc->m_no_output)
                return;

            DOCTEST_LOCK_MUTEX(mutex)

            logTestStart();

            file_line_to_stream(mb.m_file, mb.m_line, " ");
            s << getSuccessOrFailColor(false, mb.m_severity)
              << getSuccessOrFailString(mb.m_severity & assertType::is_warn, mb.m_severity,
                                        "MESSAGE") << ": ";
            s << Color::None << mb.m_string << "\n";
            log_contexts();
        }

        void test_case_skipped(const TestCaseData&) override {}
    };

    DOCTEST_REGISTER_REPORTER("console", 0, ConsoleReporter);

#ifdef DOCTEST_PLATFORM_WINDOWS
    struct DebugOutputWindowReporter : public ConsoleReporter
    {
        DOCTEST_THREAD_LOCAL static std::ostringstream oss;

        DebugOutputWindowReporter(const ContextOptions& co)
                : ConsoleReporter(co, oss) {}

#define DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(func, type, arg)                                    \
    void func(type arg) override {                                                                 \
        bool with_col = g_no_colors;                                                               \
        g_no_colors   = false;                                                                     \
        ConsoleReporter::func(arg);                                                                \
        if(oss.tellp() != std::streampos{}) {                                                      \
            DOCTEST_OUTPUT_DEBUG_STRING(oss.str().c_str());                                        \
            oss.str("");                                                                           \
        }                                                                                          \
        g_no_colors = with_col;                                                                    \
    }

        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_run_start, DOCTEST_EMPTY, DOCTEST_EMPTY)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_run_end, const TestRunStats&, in)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_start, const TestCaseData&, in)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_reenter, const TestCaseData&, in)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_end, const CurrentTestCaseStats&, in)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_exception, const TestCaseException&, in)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(subcase_start, const SubcaseSignature&, in)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(subcase_end, DOCTEST_EMPTY, DOCTEST_EMPTY)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(log_assert, const AssertData&, in)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(log_message, const MessageData&, in)
        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_skipped, const TestCaseData&, in)
    };

    DOCTEST_THREAD_LOCAL std::ostringstream DebugOutputWindowReporter::oss;
#endif // DOCTEST_PLATFORM_WINDOWS

    // the implementation of parseOption()
    bool parseOptionImpl(int argc, const char* const* argv, const char* pattern, String* value) {
        // going from the end to the beginning and stopping on the first occurrence from the end
        for(int i = argc; i > 0; --i) {
            auto index = i - 1;
            auto temp = std::strstr(argv[index], pattern);
            if(temp && (value || strlen(temp) == strlen(pattern))) { //!OCLINT prefer early exits and continue
                // eliminate matches in which the chars before the option are not '-'
                bool noBadCharsFound = true;
                auto curr            = argv[index];
                while(curr != temp) {
                    if(*curr++ != '-') {
                        noBadCharsFound = false;
                        break;
                    }
                }
                if(noBadCharsFound && argv[index][0] == '-') {
                    if(value) {
                        // parsing the value of an option
                        temp += strlen(pattern);
                        const unsigned len = strlen(temp);
                        if(len) {
                            *value = temp;
                            return true;
                        }
                    } else {
                        // just a flag - no value
                        return true;
                    }
                }
            }
        }
        return false;
    }

    // parses an option and returns the string after the '=' character
    bool parseOption(int argc, const char* const* argv, const char* pattern, String* value = nullptr,
                     const String& defaultVal = String()) {
        if(value)
            *value = defaultVal;
#ifndef DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS
        // offset (normally 3 for "dt-") to skip prefix
        if(parseOptionImpl(argc, argv, pattern + strlen(DOCTEST_CONFIG_OPTIONS_PREFIX), value))
            return true;
#endif // DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS
        return parseOptionImpl(argc, argv, pattern, value);
    }

    // locates a flag on the command line
    bool parseFlag(int argc, const char* const* argv, const char* pattern) {
        return parseOption(argc, argv, pattern);
    }

    // parses a comma separated list of words after a pattern in one of the arguments in argv
    bool parseCommaSepArgs(int argc, const char* const* argv, const char* pattern,
                           std::vector<String>& res) {
        String filtersString;
        if(parseOption(argc, argv, pattern, &filtersString)) {
            // tokenize with "," as a separator, unless escaped with backslash
            std::ostringstream s;
            auto flush = [&s, &res]() {
                auto string = s.str();
                if(string.size() > 0) {
                    res.push_back(string.c_str());
                }
                s.str("");
            };

            bool seenBackslash = false;
            const char* current = filtersString.c_str();
            const char* end = current + strlen(current);
            while(current != end) {
                char character = *current++;
                if(seenBackslash) {
                    seenBackslash = false;
                    if(character == ',' || character == '\\') {
                        s.put(character);
                        continue;
                    }
                    s.put('\\');
                }
                if(character == '\\') {
                    seenBackslash = true;
                } else if(character == ',') {
                    flush();
                } else {
                    s.put(character);
                }
            }

            if(seenBackslash) {
                s.put('\\');
            }
            flush();
            return true;
        }
        return false;
    }

    enum optionType
    {
        option_bool,
        option_int
    };

    // parses an int/bool option from the command line
    bool parseIntOption(int argc, const char* const* argv, const char* pattern, optionType type,
                        int& res) {
        String parsedValue;
        if(!parseOption(argc, argv, pattern, &parsedValue))
            return false;

        if(type) {
            // integer
            // TODO: change this to use std::stoi or something else! currently it uses undefined behavior - assumes '0' on failed parse...
            int theInt = std::atoi(parsedValue.c_str());
            if (theInt != 0) {
                res = theInt; //!OCLINT parameter reassignment
                return true;
            }
        } else {
            // boolean
            const char positive[][5] = { "1", "true", "on", "yes" };  // 5 - strlen("true") + 1
            const char negative[][6] = { "0", "false", "off", "no" }; // 6 - strlen("false") + 1

            // if the value matches any of the positive/negative possibilities
            for (unsigned i = 0; i < 4; i++) {
                if (parsedValue.compare(positive[i], true) == 0) {
                    res = 1; //!OCLINT parameter reassignment
                    return true;
                }
                if (parsedValue.compare(negative[i], true) == 0) {
                    res = 0; //!OCLINT parameter reassignment
                    return true;
                }
            }
        }
        return false;
    }
} // namespace

Context::Context(int argc, const char* const* argv)
        : p(new detail::ContextState) {
    parseArgs(argc, argv, true);
    if(argc)
        p->binary_name = argv[0];
}

Context::~Context() {
    if(g_cs == p)
        g_cs = nullptr;
    delete p;
}

void Context::applyCommandLine(int argc, const char* const* argv) {
    parseArgs(argc, argv);
    if(argc)
        p->binary_name = argv[0];
}

// parses args
void Context::parseArgs(int argc, const char* const* argv, bool withDefaults) {
    using namespace detail;

    // clang-format off
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "source-file=",        p->filters[0]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "sf=",                 p->filters[0]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "source-file-exclude=",p->filters[1]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "sfe=",                p->filters[1]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "test-suite=",         p->filters[2]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "ts=",                 p->filters[2]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "test-suite-exclude=", p->filters[3]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "tse=",                p->filters[3]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "test-case=",          p->filters[4]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "tc=",                 p->filters[4]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "test-case-exclude=",  p->filters[5]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "tce=",                p->filters[5]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "subcase=",            p->filters[6]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "sc=",                 p->filters[6]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "subcase-exclude=",    p->filters[7]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "sce=",                p->filters[7]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "reporters=",          p->filters[8]);
    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "r=",                  p->filters[8]);
    // clang-format on

    int    intRes = 0;
    String strRes;

#define DOCTEST_PARSE_AS_BOOL_OR_FLAG(name, sname, var, default)                                   \
    if(parseIntOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX name "=", option_bool, intRes) ||  \
       parseIntOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX sname "=", option_bool, intRes))   \
        p->var = static_cast<bool>(intRes);                                                        \
    else if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX name) ||                           \
            parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX sname))                            \
        p->var = true;                                                                             \
    else if(withDefaults)                                                                          \
    p->var = default

#define DOCTEST_PARSE_INT_OPTION(name, sname, var, default)                                        \
    if(parseIntOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX name "=", option_int, intRes) ||   \
       parseIntOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX sname "=", option_int, intRes))    \
        p->var = intRes;                                                                           \
    else if(withDefaults)                                                                          \
    p->var = default

#define DOCTEST_PARSE_STR_OPTION(name, sname, var, default)                                        \
    if(parseOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX name "=", &strRes, default) ||        \
       parseOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX sname "=", &strRes, default) ||       \
       withDefaults)                                                                               \
    p->var = strRes

    // clang-format off
    DOCTEST_PARSE_STR_OPTION("out", "o", out, "");
    DOCTEST_PARSE_STR_OPTION("order-by", "ob", order_by, "file");
    DOCTEST_PARSE_INT_OPTION("rand-seed", "rs", rand_seed, 0);

    DOCTEST_PARSE_INT_OPTION("first", "f", first, 0);
    DOCTEST_PARSE_INT_OPTION("last", "l", last, UINT_MAX);

    DOCTEST_PARSE_INT_OPTION("abort-after", "aa", abort_after, 0);
    DOCTEST_PARSE_INT_OPTION("subcase-filter-levels", "scfl", subcase_filter_levels, INT_MAX);

    DOCTEST_PARSE_AS_BOOL_OR_FLAG("success", "s", success, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("case-sensitive", "cs", case_sensitive, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("exit", "e", exit, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("duration", "d", duration, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("minimal", "m", minimal, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("quiet", "q", quiet, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-throw", "nt", no_throw, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-exitcode", "ne", no_exitcode, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-run", "nr", no_run, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-intro", "ni", no_intro, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-version", "nv", no_version, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-colors", "nc", no_colors, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("force-colors", "fc", force_colors, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-breaks", "nb", no_breaks, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-skip", "ns", no_skip, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("gnu-file-line", "gfl", gnu_file_line, !bool(DOCTEST_MSVC));
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-path-filenames", "npf", no_path_in_filenames, false);
    DOCTEST_PARSE_STR_OPTION("strip-file-prefixes", "sfp", strip_file_prefixes, "");
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-line-numbers", "nln", no_line_numbers, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-debug-output", "ndo", no_debug_output, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-skipped-summary", "nss", no_skipped_summary, false);
    DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-time-in-output", "ntio", no_time_in_output, false);
    // clang-format on

    if(withDefaults) {
        p->help             = false;
        p->version          = false;
        p->count            = false;
        p->list_test_cases  = false;
        p->list_test_suites = false;
        p->list_reporters   = false;
    }
    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "help") ||
       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "h") ||
       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "?")) {
        p->help = true;
        p->exit = true;
    }
    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "version") ||
       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "v")) {
        p->version = true;
        p->exit    = true;
    }
    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "count") ||
       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "c")) {
        p->count = true;
        p->exit  = true;
    }
    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "list-test-cases") ||
       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "ltc")) {
        p->list_test_cases = true;
        p->exit            = true;
    }
    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "list-test-suites") ||
       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "lts")) {
        p->list_test_suites = true;
        p->exit             = true;
    }
    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "list-reporters") ||
       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "lr")) {
        p->list_reporters = true;
        p->exit           = true;
    }
}

// allows the user to add procedurally to the filters from the command line
void Context::addFilter(const char* filter, const char* value) { setOption(filter, value); }

// allows the user to clear all filters from the command line
void Context::clearFilters() {
    for(auto& curr : p->filters)
        curr.clear();
}

// allows the user to override procedurally the bool options from the command line
void Context::setOption(const char* option, bool value) {
    setOption(option, value ? "true" : "false");
}

// allows the user to override procedurally the int options from the command line
void Context::setOption(const char* option, int value) {
    setOption(option, toString(value).c_str());
}

// allows the user to override procedurally the string options from the command line
void Context::setOption(const char* option, const char* value) {
    auto argv   = String("-") + option + "=" + value;
    auto lvalue = argv.c_str();
    parseArgs(1, &lvalue);
}

// users should query this in their main() and exit the program if true
bool Context::shouldExit() { return p->exit; }

void Context::setAsDefaultForAssertsOutOfTestCases() { g_cs = p; }

void Context::setAssertHandler(detail::assert_handler ah) { p->ah = ah; }

void Context::setCout(std::ostream* out) { p->cout = out; }

static class DiscardOStream : public std::ostream
{
private:
    class : public std::streambuf
    {
    private:
        // allowing some buffering decreases the amount of calls to overflow
        char buf[1024];

    protected:
        std::streamsize xsputn(const char_type*, std::streamsize count) override { return count; }

        int_type overflow(int_type ch) override {
            setp(std::begin(buf), std::end(buf));
            return traits_type::not_eof(ch);
        }
    } discardBuf;

public:
    DiscardOStream()
            : std::ostream(&discardBuf) {}
} discardOut;

// the main function that does all the filtering and test running
int Context::run() {
    using namespace detail;

    // save the old context state in case such was setup - for using asserts out of a testing context
    auto old_cs = g_cs;
    // this is the current contest
    g_cs               = p;
    is_running_in_test = true;

    g_no_colors = p->no_colors;
    p->resetRunData();

    std::fstream fstr;
    if(p->cout == nullptr) {
        if(p->quiet) {
            p->cout = &discardOut;
        } else if(p->out.size()) {
            // to a file if specified
            fstr.open(p->out.c_str(), std::fstream::out);
            p->cout = &fstr;
        } else {
#ifndef DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
            // stdout by default
            p->cout = &std::cout;
#else // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
            return EXIT_FAILURE;
#endif // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
        }
    }

    FatalConditionHandler::allocateAltStackMem();

    auto cleanup_and_return = [&]() {
        FatalConditionHandler::freeAltStackMem();

        if(fstr.is_open())
            fstr.close();

        // restore context
        g_cs               = old_cs;
        is_running_in_test = false;

        // we have to free the reporters which were allocated when the run started
        for(auto& curr : p->reporters_currently_used)
            delete curr;
        p->reporters_currently_used.clear();

        if(p->numTestCasesFailed && !p->no_exitcode)
            return EXIT_FAILURE;
        return EXIT_SUCCESS;
    };

    // setup default reporter if none is given through the command line
    if(p->filters[8].empty())
        p->filters[8].push_back("console");

    // check to see if any of the registered reporters has been selected
    for(auto& curr : getReporters()) {
        if(matchesAny(curr.first.second.c_str(), p->filters[8], false, p->case_sensitive))
            p->reporters_currently_used.push_back(curr.second(*g_cs));
    }

    // TODO: check if there is nothing in reporters_currently_used

    // prepend all listeners
    for(auto& curr : getListeners())
        p->reporters_currently_used.insert(p->reporters_currently_used.begin(), curr.second(*g_cs));

#ifdef DOCTEST_PLATFORM_WINDOWS
    if(isDebuggerActive() && p->no_debug_output == false)
        p->reporters_currently_used.push_back(new DebugOutputWindowReporter(*g_cs));
#endif // DOCTEST_PLATFORM_WINDOWS

    // handle version, help and no_run
    if(p->no_run || p->version || p->help || p->list_reporters) {
        DOCTEST_ITERATE_THROUGH_REPORTERS(report_query, QueryData());

        return cleanup_and_return();
    }

    std::vector<const TestCase*> testArray;
    for(auto& curr : getRegisteredTests())
        testArray.push_back(&curr);
    p->numTestCases = testArray.size();

    // sort the collected records
    if(!testArray.empty()) {
        if(p->order_by.compare("file", true) == 0) {
            std::sort(testArray.begin(), testArray.end(), fileOrderComparator);
        } else if(p->order_by.compare("suite", true) == 0) {
            std::sort(testArray.begin(), testArray.end(), suiteOrderComparator);
        } else if(p->order_by.compare("name", true) == 0) {
            std::sort(testArray.begin(), testArray.end(), nameOrderComparator);
        } else if(p->order_by.compare("rand", true) == 0) {
            std::srand(p->rand_seed);

            // random_shuffle implementation
            const auto first = &testArray[0];
            for(size_t i = testArray.size() - 1; i > 0; --i) {
                int idxToSwap = std::rand() % (i + 1);

                const auto temp = first[i];

                first[i]         = first[idxToSwap];
                first[idxToSwap] = temp;
            }
        } else if(p->order_by.compare("none", true) == 0) {
            // means no sorting - beneficial for death tests which call into the executable
            // with a specific test case in mind - we don't want to slow down the startup times
        }
    }

    std::set<String> testSuitesPassingFilt;

    bool                             query_mode = p->count || p->list_test_cases || p->list_test_suites;
    std::vector<const TestCaseData*> queryResults;

    if(!query_mode)
        DOCTEST_ITERATE_THROUGH_REPORTERS(test_run_start, DOCTEST_EMPTY);

    // invoke the registered functions if they match the filter criteria (or just count them)
    for(auto& curr : testArray) {
        const auto& tc = *curr;

        bool skip_me = false;
        if(tc.m_skip && !p->no_skip)
            skip_me = true;

        if(!matchesAny(tc.m_file.c_str(), p->filters[0], true, p->case_sensitive))
            skip_me = true;
        if(matchesAny(tc.m_file.c_str(), p->filters[1], false, p->case_sensitive))
            skip_me = true;
        if(!matchesAny(tc.m_test_suite, p->filters[2], true, p->case_sensitive))
            skip_me = true;
        if(matchesAny(tc.m_test_suite, p->filters[3], false, p->case_sensitive))
            skip_me = true;
        if(!matchesAny(tc.m_name, p->filters[4], true, p->case_sensitive))
            skip_me = true;
        if(matchesAny(tc.m_name, p->filters[5], false, p->case_sensitive))
            skip_me = true;

        if(!skip_me)
            p->numTestCasesPassingFilters++;

        // skip the test if it is not in the execution range
        if((p->last < p->numTestCasesPassingFilters && p->first <= p->last) ||
           (p->first > p->numTestCasesPassingFilters))
            skip_me = true;

        if(skip_me) {
            if(!query_mode)
                DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_skipped, tc);
            continue;
        }

        // do not execute the test if we are to only count the number of filter passing tests
        if(p->count)
            continue;

        // print the name of the test and don't execute it
        if(p->list_test_cases) {
            queryResults.push_back(&tc);
            continue;
        }

        // print the name of the test suite if not done already and don't execute it
        if(p->list_test_suites) {
            if((testSuitesPassingFilt.count(tc.m_test_suite) == 0) && tc.m_test_suite[0] != '\0') {
                queryResults.push_back(&tc);
                testSuitesPassingFilt.insert(tc.m_test_suite);
                p->numTestSuitesPassingFilters++;
            }
            continue;
        }

        // execute the test if it passes all the filtering
        {
            p->currentTest = &tc;

            p->failure_flags = TestCaseFailureReason::None;
            p->seconds       = 0;

            // reset atomic counters
            p->numAssertsFailedCurrentTest_atomic = 0;
            p->numAssertsCurrentTest_atomic       = 0;

            p->fullyTraversedSubcases.clear();

            DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_start, tc);

            p->timer.start();

            bool run_test = true;

            do {
                // reset some of the fields for subcases (except for the set of fully passed ones)
                p->reachedLeaf = false;
                // May not be empty if previous subcase exited via exception.
                p->subcaseStack.clear();
                p->currentSubcaseDepth = 0;

                p->shouldLogCurrentException = true;

                // reset stuff for logging with INFO()
                p->stringifiedContexts.clear();

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
                try {
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
// MSVC 2015 diagnoses fatalConditionHandler as unused (because reset() is a static method)
DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4101) // unreferenced local variable
                    FatalConditionHandler fatalConditionHandler; // Handle signals
                    // execute the test
                    tc.m_test();
                    fatalConditionHandler.reset();
DOCTEST_MSVC_SUPPRESS_WARNING_POP
#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
                } catch(const TestFailureException&) {
                    p->failure_flags |= TestCaseFailureReason::AssertFailure;
                } catch(...) {
                    DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_exception,
                                                      {translateActiveException(), false});
                    p->failure_flags |= TestCaseFailureReason::Exception;
                }
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

                // exit this loop if enough assertions have failed - even if there are more subcases
                if(p->abort_after > 0 &&
                   p->numAssertsFailed + p->numAssertsFailedCurrentTest_atomic >= p->abort_after) {
                    run_test = false;
                    p->failure_flags |= TestCaseFailureReason::TooManyFailedAsserts;
                }

                if(!p->nextSubcaseStack.empty() && run_test)
                    DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_reenter, tc);
                if(p->nextSubcaseStack.empty())
                    run_test = false;
            } while(run_test);

            p->finalizeTestCaseData();

            DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_end, *g_cs);

            p->currentTest = nullptr;

            // stop executing tests if enough assertions have failed
            if(p->abort_after > 0 && p->numAssertsFailed >= p->abort_after)
                break;
        }
    }

    if(!query_mode) {
        DOCTEST_ITERATE_THROUGH_REPORTERS(test_run_end, *g_cs);
    } else {
        QueryData qdata;
        qdata.run_stats = g_cs;
        qdata.data      = queryResults.data();
        qdata.num_data  = unsigned(queryResults.size());
        DOCTEST_ITERATE_THROUGH_REPORTERS(report_query, qdata);
    }

    return cleanup_and_return();
}

DOCTEST_DEFINE_INTERFACE(IReporter)

int IReporter::get_num_active_contexts() { return detail::g_infoContexts.size(); }
const IContextScope* const* IReporter::get_active_contexts() {
    return get_num_active_contexts() ? &detail::g_infoContexts[0] : nullptr;
}

int IReporter::get_num_stringified_contexts() { return detail::g_cs->stringifiedContexts.size(); }
const String* IReporter::get_stringified_contexts() {
    return get_num_stringified_contexts() ? &detail::g_cs->stringifiedContexts[0] : nullptr;
}

namespace detail {
    void registerReporterImpl(const char* name, int priority, reporterCreatorFunc c, bool isReporter) {
        if(isReporter)
            getReporters().insert(reporterMap::value_type(reporterMap::key_type(priority, name), c));
        else
            getListeners().insert(reporterMap::value_type(reporterMap::key_type(priority, name), c));
    }
} // namespace detail

} // namespace doctest

#endif // DOCTEST_CONFIG_DISABLE

#ifdef DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4007) // 'function' : must be 'attribute' - see issue #182
int main(int argc, char** argv) { return doctest::Context(argc, argv).run(); }
DOCTEST_MSVC_SUPPRESS_WARNING_POP
#endif // DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN

DOCTEST_CLANG_SUPPRESS_WARNING_POP
DOCTEST_MSVC_SUPPRESS_WARNING_POP
DOCTEST_GCC_SUPPRESS_WARNING_POP

DOCTEST_SUPPRESS_COMMON_WARNINGS_POP

#endif // DOCTEST_LIBRARY_IMPLEMENTATION
#endif // DOCTEST_CONFIG_IMPLEMENT

#ifdef DOCTEST_UNDEF_WIN32_LEAN_AND_MEAN
#undef WIN32_LEAN_AND_MEAN
#undef DOCTEST_UNDEF_WIN32_LEAN_AND_MEAN
#endif // DOCTEST_UNDEF_WIN32_LEAN_AND_MEAN

#ifdef DOCTEST_UNDEF_NOMINMAX
#undef NOMINMAX
#undef DOCTEST_UNDEF_NOMINMAX
#endif // DOCTEST_UNDEF_NOMINMAX

```

`src/third_party/lua_headers/lua/lauxlib.h`:

```h
#pragma once

#include "../../luajit/src/lauxlib.h"

```

`src/third_party/lua_headers/lua/lua.h`:

```h
#pragma once

#include "../../luajit/src/lua.h"

```

`src/third_party/lua_headers/lua/lualib.h`:

```h
#pragma once

#include "../../luajit/src/lualib.h"

```

`src/tracers/CMakeLists.txt`:

```txt
# Tracers - w1 framework tracers

include("${W1_CMAKE_DIR}/W1Tracers.cmake")
w1_dep_qbdi()

# add tracer subdirectories
add_subdirectory(w1cov)
add_subdirectory(w1dump)
add_subdirectory(w1rewind)
add_subdirectory(w1xfer)
add_subdirectory(w1script)

```

`src/tracers/w1cov/CMakeLists.txt`:

```txt
w1_add_tracer(w1cov
    SOURCES
        entrypoints/preload.cpp
        engine/coverage_engine.cpp
        engine/coverage_store.cpp
        engine/coverage_exporter.cpp
        thread/coverage_thread_tracer.cpp
    LIBS
        w1formats
        w1runtime
        w1base
)

```

`src/tracers/w1cov/config/coverage_config.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>
#include <vector>

#include "w1base/env_config.hpp"
#include "w1instrument/config/tracer_common_config.hpp"

namespace w1cov {

enum class coverage_mode : uint8_t {
  basic_block,
  instruction,
};

inline constexpr const char* coverage_mode_name(coverage_mode mode) {
  switch (mode) {
  case coverage_mode::instruction:
    return "instruction";
  case coverage_mode::basic_block:
  default:
    return "basic_block";
  }
}

struct coverage_config {
  w1::instrument::config::tracer_common_config common{};
  w1::instrument::config::thread_attach_policy threads = w1::instrument::config::thread_attach_policy::auto_attach;
  std::string output_file = "coverage.drcov";
  coverage_mode mode = coverage_mode::basic_block;
  uint64_t buffer_flush_threshold = 0;

  static coverage_config from_environment() {
    w1::util::env_config loader("W1COV");

    coverage_config config;
    config.common = w1::instrument::config::load_common(loader);
    config.threads = w1::instrument::config::load_thread_attach_policy(
        loader, w1::instrument::config::thread_attach_policy::auto_attach
    );
    config.output_file = loader.get<std::string>("OUTPUT", "coverage.drcov");
    config.buffer_flush_threshold = loader.get<uint64_t>("BUFFER_FLUSH_THRESHOLD", 0);

    const std::string mode = loader.get<std::string>("MODE", "basic_block");
    if (mode == "instruction" || mode == "inst" || mode == "instruction_trace") {
      config.mode = coverage_mode::instruction;
    } else {
      config.mode = coverage_mode::basic_block;
    }

    auto module_filter_env = loader.get_list("MODULE_FILTER");
    if (!module_filter_env.empty()) {
      config.common.instrumentation.include_modules.insert(
          config.common.instrumentation.include_modules.end(), module_filter_env.begin(), module_filter_env.end()
      );
    }

    return config;
  }
};

} // namespace w1cov

```

`src/tracers/w1cov/coverage.hpp`:

```hpp
#pragma once

#include <utility>

#include "config/coverage_config.hpp"
#include "runtime/coverage_runtime.hpp"

namespace w1cov {

// Public helpers for standalone usage.
template <typename Fn> decltype(auto) with_process_runtime(coverage_config config, Fn&& fn) {
  auto runtime = make_process_runtime(std::move(config));
  return with_runtime(runtime, std::forward<Fn>(fn));
}

template <typename Fn> decltype(auto) with_thread_runtime(coverage_config config, Fn&& fn) {
  auto runtime = make_thread_runtime(std::move(config));
  return with_runtime(runtime, std::forward<Fn>(fn));
}

} // namespace w1cov

```

`src/tracers/w1cov/coverage_recipe.hpp`:

```hpp
#pragma once

#include <cstdint>

#include "QBDIPreload.h"
#include <QBDI.h>
#include <redlog.hpp>

#if defined(_WIN32) || defined(WIN32)
#include <w1base/windows_console.hpp>
#endif

#include "config/coverage_config.hpp"
#include "runtime/coverage_runtime.hpp"
#include "w1instrument/logging.hpp"
#include "w1instrument/self_exclude.hpp"

namespace w1cov {

struct coverage_recipe {
  using config_t = coverage_config;
  using runtime_t = coverage_process_runtime_any;

  static config_t load_config() { return coverage_config::from_environment(); }

  static void configure_logging(const config_t& config) {
    w1::instrument::configure_redlog_verbosity(config.common.verbose, true);
  }

  static void apply_self_excludes(config_t& config, const void* anchor) {
    if (config.common.exclude_self) {
      w1::util::append_self_excludes(config.common.instrumentation, anchor);
    }
  }

  static void log_config(const config_t& config) {
    auto log = redlog::get_logger("w1cov.preload");
    const char* threads = config.threads == w1::instrument::config::thread_attach_policy::auto_attach ? "auto" : "main";
    log.inf(
        "qbdipreload_on_run configured", redlog::field("mode", coverage_mode_name(config.mode)),
        redlog::field("output_file", config.output_file),
        redlog::field("buffer_flush_threshold", config.buffer_flush_threshold), redlog::field("threads", threads)
    );
  }

  static runtime_t make_runtime(const config_t& config) { return make_process_runtime(config); }

  static bool run_main(runtime_t& runtime, QBDI::VM* vm, uint64_t start, uint64_t stop) {
    return with_runtime(runtime, [&](auto& active) { return active.run_main(vm, start, stop); });
  }

  static void on_exit(runtime_t& runtime, const config_t& config, int status) {
    auto log = redlog::get_logger("w1cov.preload");
    log.inf("qbdipreload_on_exit called", redlog::field("status", status));

    with_runtime(runtime, [&](auto& active) {
      active.stop();

      if (!active.export_output()) {
        log.wrn("coverage export produced no output", redlog::field("output_file", config.output_file));
      } else {
        log.inf("coverage data export completed", redlog::field("output_file", config.output_file));
      }

      auto& engine = active.engine();
      log.inf(
          "coverage collection completed", redlog::field("coverage_units", engine.coverage_unit_count()),
          redlog::field("modules", engine.module_count()), redlog::field("total_hits", engine.total_hits())
      );
    });

    log.inf("qbdipreload_on_exit completed");
  }

  static int on_start(void* main) {
    (void) main;
#if defined(_WIN32) || defined(WIN32)
    w1::common::allocate_windows_console();
#endif
    return QBDIPRELOAD_NOT_HANDLED;
  }

  static int on_premain(void* gpr_ctx, void* fpu_ctx) {
    (void) gpr_ctx;
    (void) fpu_ctx;
    return QBDIPRELOAD_NOT_HANDLED;
  }

  static int on_main(int argc, char** argv) {
    (void) argc;
    (void) argv;
    return QBDIPRELOAD_NOT_HANDLED;
  }
};

} // namespace w1cov

```

`src/tracers/w1cov/engine/coverage_engine.cpp`:

```cpp
#include "coverage_engine.hpp"

namespace w1cov {

coverage_engine::coverage_engine(coverage_config config)
    : config_(std::move(config)), registry_(w1::core::instrumented_module_policy{config_.common.instrumentation}) {}

void coverage_engine::configure(w1::runtime::module_catalog& modules) {
  store_.reset();
  registry_.configure(modules);
  configured_.store(true, std::memory_order_release);
  exported_.store(false, std::memory_order_release);
}

bool coverage_engine::export_coverage() {
  if (exported_.exchange(true, std::memory_order_acq_rel)) {
    return true;
  }

  try {
    auto data = build_drcov_data();
    if (data.basic_blocks.empty()) {
      return false;
    }
    drcov::write(config_.output_file, data);
    return true;
  } catch (...) {
    return false;
  }
}

drcov::coverage_data coverage_engine::build_drcov_data() const {
  coverage_snapshot snapshot = store_.snapshot();
  auto modules = registry_.snapshot_modules();
  return exporter_.to_drcov(snapshot, modules);
}

size_t coverage_engine::coverage_unit_count() const { return store_.unit_count(); }

size_t coverage_engine::module_count() const { return registry_.tracked_module_count(); }

uint64_t coverage_engine::total_hits() const { return store_.total_hits(); }

uint64_t coverage_engine::module_epoch() const { return registry_.registry_version(); }

std::optional<w1::core::module_lookup<uint16_t>> coverage_engine::find_module(uint64_t address) const {
  return registry_.find(address);
}

void coverage_engine::merge_buffer(const coverage_buffer& buffer) { store_.merge(buffer); }

} // namespace w1cov

```

`src/tracers/w1cov/engine/coverage_engine.hpp`:

```hpp
#pragma once

#include <atomic>
#include <memory>
#include <optional>
#include <string_view>

#include <w1formats/drcov.hpp>

#include "config/coverage_config.hpp"
#include "coverage_exporter.hpp"
#include "coverage_store.hpp"
#include "w1instrument/core/module_registry.hpp"

namespace w1cov {

class coverage_engine {
public:
  explicit coverage_engine(coverage_config config);

  void configure(w1::runtime::module_catalog& modules);
  uint64_t module_epoch() const;
  std::optional<w1::core::module_lookup<uint16_t>> find_module(uint64_t address) const;
  void merge_buffer(const coverage_buffer& buffer);

  bool export_coverage();
  drcov::coverage_data build_drcov_data() const;

  size_t coverage_unit_count() const;
  size_t module_count() const;
  uint64_t total_hits() const;

  bool is_configured() const { return configured_.load(std::memory_order_acquire); }
  const coverage_config& config() const { return config_; }

private:
  using registry_type = w1::core::module_registry<w1::core::instrumented_module_policy, uint16_t>;

  coverage_config config_{};
  registry_type registry_{};
  coverage_store store_{};
  coverage_exporter exporter_{};

  std::atomic<bool> configured_{false};
  std::atomic<bool> exported_{false};
};

} // namespace w1cov

```

`src/tracers/w1cov/engine/coverage_exporter.cpp`:

```cpp
#include "coverage_exporter.hpp"

#include <iomanip>
#include <sstream>
#include <unordered_set>

namespace w1cov {

std::string coverage_exporter::format_hex(uint64_t value) {
  std::ostringstream oss;
  oss << "0x" << std::hex << std::setw(static_cast<int>(sizeof(uint64_t) * 2)) << std::setfill('0') << value;
  return oss.str();
}

drcov::coverage_data coverage_exporter::to_drcov(
    const coverage_snapshot& snapshot, const std::vector<w1::runtime::module_info>& modules
) const {
  if (modules.empty()) {
    log_.wrn("no modules to export");
    return drcov::coverage_data{};
  }

  log_.trc(
      "building drcov data", redlog::field("module_count", modules.size()),
      redlog::field("coverage_unit_count", snapshot.units.size()), redlog::field("total_hits", snapshot.total_hits)
  );

  std::unordered_set<uint16_t> used_module_ids;
  used_module_ids.reserve(snapshot.units.size());
  for (const auto& unit : snapshot.units) {
    if (unit.module_id < modules.size()) {
      used_module_ids.insert(unit.module_id);
    }
  }

  std::unordered_map<uint16_t, uint16_t> module_id_remap;
  module_id_remap.reserve(used_module_ids.size());
  uint16_t new_id = 0;
  for (uint16_t old_id = 0; old_id < modules.size(); ++old_id) {
    if (used_module_ids.count(old_id) > 0) {
      module_id_remap[old_id] = new_id++;
    }
  }

  auto builder =
      drcov::builder().set_flavor("w1cov").enable_hitcounts().set_module_version(drcov::module_table_version::v2);

  size_t valid_modules = 0;
  size_t invalid_modules = 0;
  size_t skipped_modules = 0;

  for (size_t i = 0; i < modules.size(); ++i) {
    if (used_module_ids.count(static_cast<uint16_t>(i)) == 0) {
      skipped_modules++;
      continue;
    }

    const auto& module = modules[i];
    uint64_t module_end = module.base_address + module.size;
    if (module.base_address >= module_end) {
      log_.wrn(
          "invalid module address range detected", redlog::field("id", i), redlog::field("name", module.name),
          redlog::field("base", module.base_address), redlog::field("end", module_end)
      );
      invalid_modules++;
      continue;
    }

    if (module.path.empty() && module.name.empty()) {
      log_.wrn("module has empty path and name", redlog::field("id", i), redlog::field("base", module.base_address));
      invalid_modules++;
      continue;
    }

    std::string module_path = !module.path.empty() ? module.path : module.name;
    builder.add_module(module_path, module.base_address, module.base_address + module.size, module.base_address);
    valid_modules++;
  }

  log_.inf(
      "module processing completed", redlog::field("valid", valid_modules), redlog::field("invalid", invalid_modules),
      redlog::field("skipped", skipped_modules)
  );

  size_t valid_units = 0;
  size_t invalid_units = 0;
  size_t orphaned_units = 0;

  for (const auto& unit : snapshot.units) {
    if (unit.module_id >= modules.size()) {
      orphaned_units++;
      continue;
    }

    auto remap_it = module_id_remap.find(unit.module_id);
    if (remap_it == module_id_remap.end()) {
      invalid_units++;
      continue;
    }

    const auto& module = modules[unit.module_id];
    if (unit.address < module.base_address || unit.address >= module.base_address + module.size) {
      log_.wrn(
          "coverage unit address outside module bounds", redlog::field("module_id", unit.module_id),
          redlog::field("address", format_hex(unit.address)), redlog::field("base", format_hex(module.base_address)),
          redlog::field("end", format_hex(module.base_address + module.size))
      );
      invalid_units++;
      continue;
    }

    uint32_t offset = static_cast<uint32_t>(unit.address - module.base_address);
    if (offset >= module.size) {
      invalid_units++;
      continue;
    }

    builder.add_coverage(remap_it->second, offset, unit.size, unit.hitcount);
    valid_units++;
  }

  log_.dbg(
      "coverage unit processing completed", redlog::field("valid", valid_units),
      redlog::field("invalid", invalid_units), redlog::field("orphaned", orphaned_units)
  );

  if (valid_units == 0 && !snapshot.units.empty()) {
    log_.wrn("no valid coverage units were exported despite having collected data");
  }

  return builder.build();
}

} // namespace w1cov

```

`src/tracers/w1cov/engine/coverage_exporter.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>
#include <unordered_map>
#include <vector>

#include <redlog.hpp>

#include <w1formats/drcov.hpp>

#include "coverage_snapshot.hpp"
#include "w1runtime/module_catalog.hpp"

namespace w1cov {

class coverage_exporter {
public:
  drcov::coverage_data to_drcov(
      const coverage_snapshot& snapshot, const std::vector<w1::runtime::module_info>& modules
  ) const;

private:
  static std::string format_hex(uint64_t value);
  redlog::logger log_ = redlog::get_logger("w1cov.exporter");
};

} // namespace w1cov

```

`src/tracers/w1cov/engine/coverage_snapshot.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <vector>

namespace w1cov {

struct coverage_unit {
  uint64_t address = 0;
  uint16_t size = 0;
  uint16_t module_id = 0;
  uint32_t hitcount = 0;
};

struct coverage_snapshot {
  std::vector<coverage_unit> units;
  uint64_t total_hits = 0;
};

} // namespace w1cov

```

`src/tracers/w1cov/engine/coverage_store.cpp`:

```cpp
#include "coverage_store.hpp"

namespace w1cov {

void coverage_store::reset() {
  std::lock_guard<std::mutex> lock(mutex_);
  entries_.clear();
}

void coverage_store::record(uint64_t address, uint16_t size, uint16_t module_id, uint32_t hits) {
  if (address == 0 || hits == 0) {
    return;
  }

  std::lock_guard<std::mutex> lock(mutex_);
  record_locked(address, size, module_id, hits);
}

void coverage_store::merge(const coverage_buffer& buffer) {
  if (buffer.empty()) {
    return;
  }

  std::lock_guard<std::mutex> lock(mutex_);
  for (const auto& [address, entry] : buffer) {
    if (entry.hits == 0 || address == 0) {
      continue;
    }
    record_locked(address, entry.size, entry.module_id, entry.hits);
  }
}

coverage_snapshot coverage_store::snapshot() const {
  std::lock_guard<std::mutex> lock(mutex_);

  coverage_snapshot snapshot;
  snapshot.units.reserve(entries_.size());

  uint64_t total_hits = 0;
  for (const auto& [address, entry] : entries_) {
    coverage_unit unit{};
    unit.address = address;
    unit.size = entry.size;
    unit.module_id = entry.module_id;
    unit.hitcount = entry.hitcount;
    snapshot.units.push_back(unit);
    total_hits += entry.hitcount;
  }

  snapshot.total_hits = total_hits;
  return snapshot;
}

size_t coverage_store::unit_count() const {
  std::lock_guard<std::mutex> lock(mutex_);
  return entries_.size();
}

uint64_t coverage_store::total_hits() const {
  std::lock_guard<std::mutex> lock(mutex_);
  uint64_t total = 0;
  for (const auto& [address, entry] : entries_) {
    (void) address;
    total += entry.hitcount;
  }
  return total;
}

void coverage_store::record_locked(uint64_t address, uint16_t size, uint16_t module_id, uint32_t hits) {
  auto& entry = entries_[address];
  if (entry.hitcount == 0) {
    entry.module_id = module_id;
    entry.size = size;
  } else if (entry.size == 0 && size != 0) {
    entry.size = size;
  }

  uint64_t new_total = static_cast<uint64_t>(entry.hitcount) + static_cast<uint64_t>(hits);
  if (new_total > std::numeric_limits<uint32_t>::max()) {
    entry.hitcount = std::numeric_limits<uint32_t>::max();
  } else {
    entry.hitcount = static_cast<uint32_t>(new_total);
  }
}

} // namespace w1cov

```

`src/tracers/w1cov/engine/coverage_store.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <limits>
#include <mutex>
#include <unordered_map>

#include "coverage_snapshot.hpp"

namespace w1cov {

struct coverage_buffer_entry {
  uint16_t module_id = 0;
  uint16_t size = 0;
  uint32_t hits = 0;
};

using coverage_buffer = std::unordered_map<uint64_t, coverage_buffer_entry>;

class coverage_store {
public:
  void reset();

  void record(uint64_t address, uint16_t size, uint16_t module_id, uint32_t hits = 1);
  void merge(const coverage_buffer& buffer);

  coverage_snapshot snapshot() const;
  size_t unit_count() const;
  uint64_t total_hits() const;

private:
  struct coverage_entry {
    uint16_t module_id = 0;
    uint16_t size = 0;
    uint32_t hitcount = 0;
  };

  void record_locked(uint64_t address, uint16_t size, uint16_t module_id, uint32_t hits);

  mutable std::mutex mutex_{};
  std::unordered_map<uint64_t, coverage_entry> entries_{};
};

} // namespace w1cov

```

`src/tracers/w1cov/entrypoints/preload.cpp`:

```cpp
#include "QBDIPreload.h"

#include "coverage_recipe.hpp"
#include "w1instrument/preload/entrypoints.hpp"

extern "C" {

QBDIPRELOAD_INIT;

QBDI_EXPORT int qbdipreload_on_run(QBDI::VMInstanceRef vm, QBDI::rword start, QBDI::rword stop) {
  return w1::instrument::preload_on_run<w1cov::coverage_recipe>(vm, start, stop);
}

QBDI_EXPORT int qbdipreload_on_exit(int status) {
  return w1::instrument::preload_on_exit<w1cov::coverage_recipe>(status);
}

QBDI_EXPORT int qbdipreload_on_start(void* main) {
  return w1::instrument::preload_on_start<w1cov::coverage_recipe>(main);
}

QBDI_EXPORT int qbdipreload_on_premain(void* gpr_ctx, void* fpu_ctx) {
  return w1::instrument::preload_on_premain<w1cov::coverage_recipe>(gpr_ctx, fpu_ctx);
}

QBDI_EXPORT int qbdipreload_on_main(int argc, char** argv) {
  return w1::instrument::preload_on_main<w1cov::coverage_recipe>(argc, argv);
}

} // extern "C"

```

`src/tracers/w1cov/runtime/coverage_runtime.hpp`:

```hpp
#pragma once

#include <memory>
#include <utility>
#include <variant>

#include "config/coverage_config.hpp"
#include "engine/coverage_engine.hpp"
#include "thread/coverage_thread_tracer.hpp"
#include "w1instrument/tracer/runtime.hpp"

namespace w1cov {

template <coverage_mode mode> struct coverage_traits {
  using tracer_type = coverage_thread_tracer<mode>;
  using process_config = typename w1::instrument::process_session<tracer_type>::config;

  static process_config make_process_config(const coverage_config& config, bool owns_observer) {
    process_config tracer_config{};
    tracer_config.instrumentation = config.common.instrumentation;
    tracer_config.attach_new_threads = config.threads == w1::instrument::config::thread_attach_policy::auto_attach;
    tracer_config.refresh_on_module_events = true;
    tracer_config.owns_observer = owns_observer;
    return tracer_config;
  }

  static w1::instrument::thread_session_config make_thread_config(const coverage_config& config) {
    w1::instrument::thread_session_config session_config{};
    session_config.instrumentation = config.common.instrumentation;
    return session_config;
  }

  static tracer_type make_tracer(
      std::shared_ptr<coverage_engine> engine, const coverage_config& config, const w1::runtime::thread_info&
  ) {
    return tracer_type(std::move(engine), config.buffer_flush_threshold);
  }

  static tracer_type make_tracer(std::shared_ptr<coverage_engine> engine, const coverage_config& config) {
    return tracer_type(std::move(engine), config.buffer_flush_threshold);
  }

  static void configure_engine(coverage_engine& engine, w1::runtime::module_catalog& modules) {
    engine.configure(modules);
  }

  static bool export_output(coverage_engine& engine) { return engine.export_coverage(); }
};

template <coverage_mode mode>
using coverage_process_runtime = w1::instrument::tracer_runtime<
    coverage_engine, coverage_thread_tracer<mode>, coverage_config, coverage_traits<mode>>;

template <coverage_mode mode>
using coverage_thread_runtime = w1::instrument::thread_runtime<
    coverage_engine, coverage_thread_tracer<mode>, coverage_config, coverage_traits<mode>>;

using coverage_process_runtime_any = std::variant<
    std::unique_ptr<coverage_process_runtime<coverage_mode::basic_block>>,
    std::unique_ptr<coverage_process_runtime<coverage_mode::instruction>>>;

using coverage_thread_runtime_any = std::variant<
    std::unique_ptr<coverage_thread_runtime<coverage_mode::basic_block>>,
    std::unique_ptr<coverage_thread_runtime<coverage_mode::instruction>>>;

inline coverage_process_runtime_any make_process_runtime(coverage_config config) {
  if (config.mode == coverage_mode::instruction) {
    return coverage_process_runtime_any{
        std::make_unique<coverage_process_runtime<coverage_mode::instruction>>(std::move(config))
    };
  }
  return coverage_process_runtime_any{
      std::make_unique<coverage_process_runtime<coverage_mode::basic_block>>(std::move(config))
  };
}

inline coverage_thread_runtime_any make_thread_runtime(coverage_config config) {
  if (config.mode == coverage_mode::instruction) {
    return coverage_thread_runtime_any{
        std::make_unique<coverage_thread_runtime<coverage_mode::instruction>>(std::move(config))
    };
  }
  return coverage_thread_runtime_any{
      std::make_unique<coverage_thread_runtime<coverage_mode::basic_block>>(std::move(config))
  };
}

template <typename Variant, typename Fn> decltype(auto) with_runtime(Variant& runtime, Fn&& fn) {
  return std::visit([&](auto& ptr) -> decltype(auto) { return fn(*ptr); }, runtime);
}

template <typename Variant, typename Fn> decltype(auto) with_runtime(const Variant& runtime, Fn&& fn) {
  return std::visit([&](const auto& ptr) -> decltype(auto) { return fn(*ptr); }, runtime);
}

} // namespace w1cov

```

`src/tracers/w1cov/thread/coverage_thread_tracer.cpp`:

```cpp
#include "coverage_thread_tracer.hpp"

#include <algorithm>
#include <optional>

namespace w1cov {

namespace {
constexpr size_t kDefaultBufferReserve = 4096;
}

template <coverage_mode mode>
coverage_thread_tracer<mode>::coverage_thread_tracer(std::shared_ptr<coverage_engine> engine, uint64_t flush_threshold)
    : engine_(std::move(engine)), module_epoch_(engine_ ? engine_->module_epoch() : 0),
      buffer_(buffer_merge{engine_.get()}, kDefaultBufferReserve, flush_threshold) {}

template <coverage_mode mode>
void coverage_thread_tracer<mode>::on_thread_start(w1::trace_context& ctx, const w1::thread_event& event) {
  (void) ctx;
  (void) event;
  if (engine_) {
    module_epoch_ = engine_->module_epoch();
  }
  module_cache_.reset();
  buffer_.clear();
}

template <coverage_mode mode>
void coverage_thread_tracer<mode>::on_thread_stop(w1::trace_context& ctx, const w1::thread_event& event) {
  (void) ctx;
  (void) event;
  if (!engine_) {
    return;
  }
  buffer_.flush();
  module_cache_.reset();
}

template <coverage_mode mode>
void coverage_thread_tracer<mode>::on_basic_block_entry(
    w1::trace_context& ctx, const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  (void) vm;
  (void) state;
  (void) gpr;
  (void) fpr;
  (void) ctx;

  if constexpr (mode == coverage_mode::basic_block) {
    if (event.address == 0 || event.size == 0) {
      return;
    }

    uint32_t size = std::min<uint32_t>(event.size, std::numeric_limits<uint16_t>::max());
    record_coverage(event.address, size);
  }
}

template <coverage_mode mode>
void coverage_thread_tracer<mode>::on_instruction_pre(
    w1::trace_context& ctx, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  (void) vm;
  (void) gpr;
  (void) fpr;
  (void) ctx;

  if constexpr (mode == coverage_mode::instruction) {
    if (event.address == 0) {
      return;
    }

    uint32_t size = event.size > 0 ? event.size : 1;
    size = std::min<uint32_t>(size, std::numeric_limits<uint16_t>::max());
    record_coverage(event.address, size);
  }
}

template <coverage_mode mode> void coverage_thread_tracer<mode>::record_coverage(uint64_t address, uint32_t size) {
  if (!engine_ || size == 0 || address == 0) {
    return;
  }

  const uint64_t current_epoch = engine_->module_epoch();
  if (current_epoch != module_epoch_) {
    buffer_.flush();
    module_cache_.reset();
    module_epoch_ = current_epoch;
  }

  buffer_.record(
      address,
      [&](coverage_buffer_entry& entry) {
        if (entry.size == 0 && size != 0) {
          entry.size = static_cast<uint16_t>(size);
        }
        entry.hits += 1;
      },
      [&]() -> std::optional<coverage_buffer_entry> {
        auto module_id =
            module_cache_.resolve(address, current_epoch, [&](uint64_t addr) { return engine_->find_module(addr); });
        if (!module_id) {
          return std::nullopt;
        }

        coverage_buffer_entry entry{};
        entry.module_id = *module_id;
        entry.size = static_cast<uint16_t>(size);
        entry.hits = 1;
        return entry;
      }
  );
}

template class coverage_thread_tracer<coverage_mode::basic_block>;
template class coverage_thread_tracer<coverage_mode::instruction>;

} // namespace w1cov

```

`src/tracers/w1cov/thread/coverage_thread_tracer.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <limits>
#include <memory>

#include <QBDI.h>

#include "w1instrument/core/module_cache.hpp"
#include "w1instrument/core/thread_buffer.hpp"
#include "w1instrument/tracer/event.hpp"
#include "w1instrument/tracer/trace_context.hpp"
#include "w1instrument/tracer/tracer.hpp"
#include "w1instrument/tracer/types.hpp"

#include "engine/coverage_engine.hpp"
#include "engine/coverage_store.hpp"
#include "config/coverage_config.hpp"

namespace w1cov {

template <coverage_mode mode> class coverage_thread_tracer {
public:
  explicit coverage_thread_tracer(std::shared_ptr<coverage_engine> engine, uint64_t flush_threshold = 0);

  const char* name() const { return "w1cov"; }

  static constexpr w1::event_mask requested_events() {
    constexpr w1::event_mask base = w1::event_mask_or(
        w1::event_mask_of(w1::event_kind::thread_start), w1::event_mask_of(w1::event_kind::thread_stop)
    );
    if constexpr (mode == coverage_mode::instruction) {
      return w1::event_mask_or(base, w1::event_mask_of(w1::event_kind::instruction_pre));
    }
    return w1::event_mask_or(base, w1::event_mask_of(w1::event_kind::basic_block_entry));
  }

  void on_thread_start(w1::trace_context& ctx, const w1::thread_event& event);
  void on_thread_stop(w1::trace_context& ctx, const w1::thread_event& event);

  void on_basic_block_entry(
      w1::trace_context& ctx, const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );
  void on_instruction_pre(
      w1::trace_context& ctx, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );

private:
  void record_coverage(uint64_t address, uint32_t size);

  struct buffer_merge {
    coverage_engine* engine = nullptr;

    void operator()(const coverage_buffer& buffer) const {
      if (engine) {
        engine->merge_buffer(buffer);
      }
    }
  };

  using buffer_type = w1::core::thread_buffer<uint64_t, coverage_buffer_entry, buffer_merge>;

  std::shared_ptr<coverage_engine> engine_{};
  uint64_t module_epoch_ = 0;
  w1::core::module_cache<uint16_t> module_cache_{};
  buffer_type buffer_;
};

} // namespace w1cov

```

`src/tracers/w1dump/CMakeLists.txt`:

```txt
w1_add_tracer(w1dump
    SOURCES
        preload.cpp
        engine/dump_engine.cpp
        instrument/dump_recorder.cpp
    LIBS w1dump
)

```

`src/tracers/w1dump/config/dump_config.hpp`:

```hpp
#pragma once

#include <cctype>
#include <cstdint>
#include <string>
#include <vector>

#include "w1instrument/config/tracer_common_config.hpp"
#include "w1base/env_config.hpp"

namespace w1dump {

struct dump_config {
  w1::instrument::config::tracer_common_config common{};
  std::string output = "process.w1dump";
  bool dump_memory_content = false;
  std::vector<std::string> filters;
  uint64_t max_region_size = 100 * 1024 * 1024;
  bool dump_on_entry = true;

  static dump_config from_environment() {
    w1::util::env_config loader("W1DUMP");

    dump_config config;
    config.common = w1::instrument::config::load_common(loader);
    config.output = loader.get<std::string>("OUTPUT", "process.w1dump");
    config.dump_memory_content = loader.get<bool>("DUMP_MEMORY_CONTENT", false);
    config.dump_on_entry = loader.get<bool>("DUMP_ON_ENTRY", true);

    config.filters = loader.get_list("FILTERS");
    int filter_count = loader.get<int>("FILTER_COUNT", 0);
    for (int i = 0; i < filter_count; ++i) {
      std::string key = "FILTER_" + std::to_string(i);
      std::string filter = loader.get<std::string>(key, "");
      if (!filter.empty()) {
        config.filters.push_back(filter);
      }
    }

    std::string max_size_str = loader.get<std::string>("MAX_REGION_SIZE", "");
    if (!max_size_str.empty()) {
      uint64_t value = 0;
      char unit = 0;
      size_t pos = 0;
      value = std::stoull(max_size_str, &pos);
      if (pos < max_size_str.size()) {
        unit = static_cast<char>(std::toupper(max_size_str[pos]));
      }

      switch (unit) {
      case 'K':
        value *= 1024;
        break;
      case 'M':
        value *= 1024 * 1024;
        break;
      case 'G':
        value *= 1024 * 1024 * 1024;
        break;
      default:
        break;
      }

      if (value > 0) {
        config.max_region_size = value;
      }
    }

    return config;
  }
};

} // namespace w1dump

```

`src/tracers/w1dump/dump_recipe.hpp`:

```hpp
#pragma once

#include <cstdint>

#include "QBDIPreload.h"
#include <QBDI.h>
#include <redlog.hpp>

#if defined(_WIN32) || defined(WIN32)
#include <w1base/windows_console.hpp>
#endif

#include "config/dump_config.hpp"
#include "runtime/dump_runtime.hpp"
#include "w1instrument/logging.hpp"
#include "w1instrument/self_exclude.hpp"

namespace w1dump {

struct dump_recipe {
  using config_t = dump_config;
  using runtime_t = dump_runtime;

  static config_t load_config() { return dump_config::from_environment(); }

  static void configure_logging(const config_t& config) {
    w1::instrument::configure_redlog_verbosity(config.common.verbose);
  }

  static void apply_self_excludes(config_t& config, const void* anchor) {
    if (config.common.exclude_self) {
      w1::util::append_self_excludes(config.common.instrumentation, anchor);
    }
  }

  static void log_config(const config_t& config) {
    auto log = redlog::get_logger("w1dump.preload");
    log.inf(
        "qbdipreload_on_run configured", redlog::field("output", config.output),
        redlog::field("dump_on_entry", config.dump_on_entry), redlog::field("dump_memory", config.dump_memory_content),
        redlog::field("filters", static_cast<uint64_t>(config.filters.size())),
        redlog::field("max_region_size", config.max_region_size)
    );
  }

  static runtime_t make_runtime(const config_t& config) { return make_dump_runtime(config); }

  static bool run_main(runtime_t& runtime, QBDI::VM* vm, uint64_t start, uint64_t stop) {
    auto log = redlog::get_logger("w1dump.preload");
    log.inf(
        "starting dump session", redlog::field("start", "0x%llx", static_cast<unsigned long long>(start)),
        redlog::field("stop", "0x%llx", static_cast<unsigned long long>(stop))
    );

    if (!runtime.session) {
      return false;
    }

    const bool run_ok = runtime.session->run(vm, start, stop, "main");
    const bool dump_ok = runtime.session->engine().dump_completed();
    if (!run_ok) {
      if (dump_ok) {
        log.inf("dump session stopped after snapshot");
      } else {
        log.wrn("dump session ended early");
      }
    }

    return run_ok || dump_ok;
  }

  static void on_exit(runtime_t& runtime, const config_t& config, int status) {
    auto log = redlog::get_logger("w1dump.preload");
    log.inf("qbdipreload_on_exit called", redlog::field("status", status));

    if (runtime.session) {
      runtime.session->stop();
      if (runtime.session->engine().dump_completed()) {
        log.inf("dump completed", redlog::field("output", config.output));
      } else {
        log.wrn("dump not completed", redlog::field("output", config.output));
      }
    }

    log.inf("qbdipreload_on_exit completed");
  }

  static int on_start(void* main) {
    (void) main;
#if defined(_WIN32) || defined(WIN32)
    w1::common::allocate_windows_console();
#endif
    return QBDIPRELOAD_NOT_HANDLED;
  }

  static int on_premain(void* gpr_ctx, void* fpu_ctx) {
    (void) gpr_ctx;
    (void) fpu_ctx;
    return QBDIPRELOAD_NOT_HANDLED;
  }

  static int on_main(int argc, char** argv) {
    (void) argc;
    (void) argv;
    return QBDIPRELOAD_NOT_HANDLED;
  }
};

} // namespace w1dump

```

`src/tracers/w1dump/engine/dump_engine.cpp`:

```cpp
#include "dump_engine.hpp"

#include <sstream>
#include <utility>

#include "w1dump/process_dumper.hpp"

namespace w1dump {

namespace {
void trim_in_place(std::string& value) {
  const auto start = value.find_first_not_of(" \t");
  if (start == std::string::npos) {
    value.clear();
    return;
  }
  const auto end = value.find_last_not_of(" \t");
  value = value.substr(start, end - start + 1);
}
} // namespace

dump_engine::dump_engine(dump_config config) : config_(std::move(config)) {
  options_.dump_memory_content = config_.dump_memory_content;
  options_.filters = parse_filters();
  options_.max_region_size = config_.max_region_size;

  log_.inf(
      "dump engine configured", redlog::field("output", config_.output),
      redlog::field("dump_memory", config_.dump_memory_content), redlog::field("filter_count", options_.filters.size())
  );
}

bool dump_engine::dump_once(w1::trace_context& ctx, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr) {
  if (dumped_) {
    return false;
  }

  QBDI::VM* qbdi_vm = static_cast<QBDI::VM*>(vm);
  if (!qbdi_vm) {
    log_.err("vm instance is null");
    return false;
  }

  QBDI::GPRState local_gpr{};
  QBDI::FPRState local_fpr{};
  const QBDI::GPRState* gpr_ptr = gpr;
  const QBDI::FPRState* fpr_ptr = fpr;

  if (!gpr_ptr) {
    local_gpr = *qbdi_vm->getGPRState();
    gpr_ptr = &local_gpr;
  }
  if (!fpr_ptr) {
    local_fpr = *qbdi_vm->getFPRState();
    fpr_ptr = &local_fpr;
  }

  try {
    auto dump = w1::dump::process_dumper::dump_current(vm, ctx.memory(), ctx.thread_id(), *gpr_ptr, *fpr_ptr, options_);
    w1::dump::process_dumper::save_dump(dump, config_.output);

    log_.inf(
        "dump completed", redlog::field("file", config_.output), redlog::field("modules", dump.modules.size()),
        redlog::field("regions", dump.regions.size())
    );
    dumped_ = true;
    return true;
  } catch (const std::exception& e) {
    log_.err("dump failed", redlog::field("error", e.what()));
  }

  return false;
}

std::vector<w1::dump::dump_options::filter> dump_engine::parse_filters() const {
  std::vector<w1::dump::dump_options::filter> result;

  for (const auto& filter_str : config_.filters) {
    w1::dump::dump_options::filter filter;

    size_t colon_pos = filter_str.find(':');
    std::string type_str = filter_str.substr(0, colon_pos);

    if (type_str == "all") {
      filter.type = w1::dump::dump_options::filter::region_type::all;
    } else if (type_str == "code") {
      filter.type = w1::dump::dump_options::filter::region_type::code;
    } else if (type_str == "data") {
      filter.type = w1::dump::dump_options::filter::region_type::data;
    } else if (type_str == "stack") {
      filter.type = w1::dump::dump_options::filter::region_type::stack;
    } else {
      log_.err("invalid filter type", redlog::field("type", type_str));
      continue;
    }

    if (colon_pos != std::string::npos) {
      std::string modules_str = filter_str.substr(colon_pos + 1);
      std::stringstream ss(modules_str);
      std::string module;

      while (std::getline(ss, module, ',')) {
        trim_in_place(module);
        if (!module.empty()) {
          filter.modules.insert(module);
        }
      }
    }

    result.push_back(std::move(filter));
  }

  return result;
}

} // namespace w1dump

```

`src/tracers/w1dump/engine/dump_engine.hpp`:

```hpp
#pragma once

#include <vector>

#include <QBDI.h>
#include <redlog.hpp>

#include "config/dump_config.hpp"
#include "w1dump/memory_dumper.hpp"
#include "w1instrument/tracer/trace_context.hpp"

namespace w1dump {

class dump_engine {
public:
  explicit dump_engine(dump_config config);

  const dump_config& config() const { return config_; }
  bool dump_completed() const { return dumped_; }

  bool dump_once(w1::trace_context& ctx, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr);

private:
  std::vector<w1::dump::dump_options::filter> parse_filters() const;

  dump_config config_{};
  w1::dump::dump_options options_{};
  redlog::logger log_ = redlog::get_logger("w1dump.engine");
  bool dumped_ = false;
};

} // namespace w1dump

```

`src/tracers/w1dump/instrument/dump_recorder.cpp`:

```cpp
#include "dump_recorder.hpp"

namespace w1dump {

dump_recorder::dump_recorder(std::shared_ptr<dump_engine> engine) : engine_(std::move(engine)) {}

QBDI::VMAction dump_recorder::on_vm_start(
    w1::trace_context& ctx, const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  (void) event;
  (void) state;

  if (engine_ && engine_->config().dump_on_entry && !engine_->dump_completed()) {
    engine_->dump_once(ctx, vm, gpr, fpr);
    return QBDI::VMAction::STOP;
  }

  return QBDI::VMAction::CONTINUE;
}

QBDI::VMAction dump_recorder::on_instruction_pre(
    w1::trace_context& ctx, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  (void) event;

  if (engine_ && !engine_->config().dump_on_entry && !engine_->dump_completed()) {
    engine_->dump_once(ctx, vm, gpr, fpr);
    return QBDI::VMAction::STOP;
  }

  return QBDI::VMAction::CONTINUE;
}

bool dump_recorder::dump_completed() const { return engine_ ? engine_->dump_completed() : false; }

} // namespace w1dump

```

`src/tracers/w1dump/instrument/dump_recorder.hpp`:

```hpp
#pragma once

#include <memory>

#include <QBDI.h>

#include "engine/dump_engine.hpp"
#include "w1instrument/tracer/event.hpp"
#include "w1instrument/tracer/trace_context.hpp"
#include "w1instrument/tracer/types.hpp"

namespace w1dump {

class dump_recorder {
public:
  explicit dump_recorder(std::shared_ptr<dump_engine> engine);

  const char* name() const { return "w1dump"; }
  static constexpr w1::event_mask requested_events() {
    using w1::event_kind;
    w1::event_mask mask = 0;
    mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::vm_start));
    mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::instruction_pre));
    return mask;
  }

  QBDI::VMAction on_vm_start(
      w1::trace_context& ctx, const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );

  QBDI::VMAction on_instruction_pre(
      w1::trace_context& ctx, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );

  bool dump_completed() const;

private:
  std::shared_ptr<dump_engine> engine_;
};

} // namespace w1dump

```

`src/tracers/w1dump/preload.cpp`:

```cpp
#include "QBDIPreload.h"

#include "dump_recipe.hpp"
#include "w1instrument/preload/entrypoints.hpp"

extern "C" {

QBDIPRELOAD_INIT;

QBDI_EXPORT int qbdipreload_on_run(QBDI::VMInstanceRef vm, QBDI::rword start, QBDI::rword stop) {
  return w1::instrument::preload_on_run<w1dump::dump_recipe>(vm, start, stop);
}

QBDI_EXPORT int qbdipreload_on_exit(int status) { return w1::instrument::preload_on_exit<w1dump::dump_recipe>(status); }

QBDI_EXPORT int qbdipreload_on_start(void* main) { return w1::instrument::preload_on_start<w1dump::dump_recipe>(main); }

QBDI_EXPORT int qbdipreload_on_premain(void* gpr_ctx, void* fpu_ctx) {
  return w1::instrument::preload_on_premain<w1dump::dump_recipe>(gpr_ctx, fpu_ctx);
}

QBDI_EXPORT int qbdipreload_on_main(int argc, char** argv) {
  return w1::instrument::preload_on_main<w1dump::dump_recipe>(argc, argv);
}

} // extern "C"

```

`src/tracers/w1dump/runtime/dump_runtime.hpp`:

```hpp
#pragma once

#include <memory>
#include <utility>

#include "config/dump_config.hpp"
#include "engine/dump_engine.hpp"
#include "instrument/dump_recorder.hpp"
#include "w1instrument/tracer/runtime.hpp"

namespace w1dump {

struct dump_traits {
  using tracer_type = dump_recorder;

  static w1::instrument::thread_session_config make_thread_config(const dump_config& config) {
    w1::instrument::thread_session_config session_config{};
    session_config.instrumentation = config.common.instrumentation;
    return session_config;
  }

  static tracer_type make_tracer(std::shared_ptr<dump_engine> engine, const dump_config&) {
    return tracer_type(std::move(engine));
  }

  static void configure_engine(dump_engine&, w1::runtime::module_catalog&) {}

  static bool export_output(dump_engine& engine) { return engine.dump_completed(); }
};

struct dump_runtime {
  using session_type = w1::instrument::thread_runtime<dump_engine, dump_recorder, dump_config, dump_traits>;

  std::unique_ptr<session_type> session;
};

inline dump_runtime make_dump_runtime(dump_config config) {
  dump_runtime runtime;
  runtime.session = std::make_unique<dump_runtime::session_type>(std::move(config));
  return runtime;
}

} // namespace w1dump

```

`src/tracers/w1rewind/CMakeLists.txt`:

```txt
w1_add_tracer(w1rewind
    SOURCES
        entrypoints/preload.cpp
        config/rewind_config.cpp
        engine/module_table_builder.cpp
        engine/register_schema.cpp
        engine/target_environment_provider.cpp
        engine/trace_emitter.cpp
        engine/rewind_engine.cpp
        thread/memory_access_builder.cpp
        thread/memory_filter.cpp
        thread/register_delta_builder.cpp
        thread/snapshot_builder.cpp
        thread/stack_window_policy.cpp
        thread/rewind_thread_tracer.cpp
    LIBS
        w1rewind_record
        w1rewind_trace
        w1::lief
)

```

`src/tracers/w1rewind/config/rewind_config.cpp`:

```cpp
#include "rewind_config.hpp"

#include <algorithm>
#include <cctype>
#include <sstream>

#include "w1base/env_config.hpp"

namespace w1rewind {
namespace {

std::string to_lower(std::string value) {
  std::transform(value.begin(), value.end(), value.begin(), [](unsigned char ch) {
    return static_cast<char>(std::tolower(ch));
  });
  return value;
}

std::string trim(const std::string& value) {
  size_t first = value.find_first_not_of(' ');
  if (first == std::string::npos) {
    return value;
  }
  size_t last = value.find_last_not_of(' ');
  return value.substr(first, last - first + 1);
}

template <typename Enum>
bool parse_enum_value(
    const std::string& value, const std::initializer_list<std::pair<const char*, Enum>>& mapping, Enum& out
) {
  std::string lower = to_lower(value);
  for (const auto& entry : mapping) {
    if (lower == entry.first) {
      out = entry.second;
      return true;
    }
  }
  return false;
}

bool parse_range(const std::string& text, w1::address_range& out, std::string& error) {
  const size_t dash = text.find('-');
  if (dash == std::string::npos) {
    error = "range must be in start-end form";
    return false;
  }
  std::string start_text = trim(text.substr(0, dash));
  std::string end_text = trim(text.substr(dash + 1));
  if (start_text.empty() || end_text.empty()) {
    error = "range start/end missing";
    return false;
  }

  try {
    uint64_t start = std::stoull(start_text, nullptr, 0);
    uint64_t end = std::stoull(end_text, nullptr, 0);
    if (end <= start) {
      error = "range end must be greater than start";
      return false;
    }
    out.start = start;
    out.end = end;
    return true;
  } catch (const std::exception& exc) {
    error = std::string("invalid range value: ") + exc.what();
    return false;
  }
}

void merge_ranges(std::vector<w1::address_range>& ranges) {
  if (ranges.empty()) {
    return;
  }
  std::sort(ranges.begin(), ranges.end(), [](const auto& left, const auto& right) { return left.start < right.start; });

  std::vector<w1::address_range> merged;
  merged.reserve(ranges.size());
  w1::address_range current = ranges.front();
  for (size_t i = 1; i < ranges.size(); ++i) {
    const auto& next = ranges[i];
    if (next.start > current.end) {
      merged.push_back(current);
      current = next;
      continue;
    }
    current.end = std::max(current.end, next.end);
  }
  merged.push_back(current);
  ranges.swap(merged);
}

bool has_filter(const std::vector<rewind_config::memory_filter_kind>& filters, rewind_config::memory_filter_kind kind) {
  for (const auto& entry : filters) {
    if (entry == kind) {
      return true;
    }
  }
  return false;
}

} // namespace

rewind_config rewind_config::from_environment(std::string& error) {
  error.clear();
  w1::util::env_config loader("W1REWIND");
  using flow_options = rewind_config::flow_options;
  using register_options = rewind_config::register_options;
  using stack_window_options = rewind_config::stack_window_options;
  using memory_access = rewind_config::memory_access;
  using memory_filter_kind = rewind_config::memory_filter_kind;

  rewind_config config;
  config.common = w1::instrument::config::load_common(loader);
  config.threads = w1::instrument::config::load_thread_attach_policy(
      loader, w1::instrument::config::thread_attach_policy::main_only
  );

  std::string flow_value = loader.get<std::string>("FLOW", "");
  if (!flow_value.empty()) {
    if (!parse_enum_value(
            flow_value,
            {{"instruction", flow_options::flow_mode::instruction}, {"block", flow_options::flow_mode::block}},
            config.flow.mode
        )) {
      error = "invalid W1REWIND_FLOW value";
      return config;
    }
  }

  std::string reg_capture = loader.get<std::string>("REG_CAPTURE", "");
  if (!reg_capture.empty()) {
    if (!parse_enum_value(reg_capture, {{"gpr", register_options::capture_kind::gpr}}, config.registers.capture)) {
      error = "invalid W1REWIND_REG_CAPTURE value";
      return config;
    }
  }

  config.registers.deltas = loader.get<bool>("REG_DELTAS", config.registers.deltas);
  config.registers.snapshot_interval =
      loader.get<uint64_t>("REG_SNAPSHOT_INTERVAL", config.registers.snapshot_interval);
  config.registers.bytes = loader.get<bool>("REG_BYTES", config.registers.bytes);

  std::string stack_mode = loader.get<std::string>("STACK_WINDOW_MODE", "");
  if (!stack_mode.empty()) {
    if (!parse_enum_value(
            stack_mode,
            {{"none", stack_window_options::window_mode::none},
             {"fixed", stack_window_options::window_mode::fixed},
             {"frame", stack_window_options::window_mode::frame}},
            config.stack_window.mode
        )) {
      error = "invalid W1REWIND_STACK_WINDOW_MODE value";
      return config;
    }
  }
  config.stack_window.above_bytes = loader.get<uint64_t>("STACK_WINDOW_ABOVE", config.stack_window.above_bytes);
  config.stack_window.below_bytes = loader.get<uint64_t>("STACK_WINDOW_BELOW", config.stack_window.below_bytes);
  config.stack_window.max_total_bytes = loader.get<uint64_t>("STACK_WINDOW_MAX", config.stack_window.max_total_bytes);
  config.stack_snapshots.interval = loader.get<uint64_t>("STACK_SNAPSHOT_INTERVAL", config.stack_snapshots.interval);

  std::string mem_access = loader.get<std::string>("MEM_ACCESS", "");
  if (!mem_access.empty()) {
    if (!parse_enum_value(
            mem_access,
            {{"none", memory_access::none},
             {"reads", memory_access::reads},
             {"writes", memory_access::writes},
             {"reads_writes", memory_access::reads_writes}},
            config.memory.access
        )) {
      error = "invalid W1REWIND_MEM_ACCESS value";
      return config;
    }
  }

  config.memory.values = loader.get<bool>("MEM_VALUES", config.memory.values);
  config.memory.max_value_bytes = loader.get<uint32_t>("MEM_MAX_BYTES", config.memory.max_value_bytes);

  auto filters = loader.get_list("MEM_FILTER");
  config.memory.filters.clear();
  if (filters.empty()) {
    config.memory.filters.push_back(memory_filter_kind::all);
  } else {
    bool saw_all = false;
    bool saw_ranges = false;
    bool saw_stack = false;
    for (const auto& entry : filters) {
      const std::string value = to_lower(entry);
      if (value == "all") {
        saw_all = true;
      } else if (value == "ranges") {
        saw_ranges = true;
      } else if (value == "stack_window") {
        saw_stack = true;
      } else {
        error = "invalid W1REWIND_MEM_FILTER value";
        return config;
      }
    }
    if (saw_all && (saw_ranges || saw_stack)) {
      error = "memory filter 'all' cannot be combined with other selectors";
      return config;
    }
    if (saw_all) {
      config.memory.filters.push_back(memory_filter_kind::all);
    } else {
      if (saw_ranges) {
        config.memory.filters.push_back(memory_filter_kind::ranges);
      }
      if (saw_stack) {
        config.memory.filters.push_back(memory_filter_kind::stack_window);
      }
    }
  }

  auto ranges = loader.get_list("MEM_RANGES");
  config.memory.ranges.clear();
  if (!ranges.empty()) {
    config.memory.ranges.reserve(ranges.size());
    for (const auto& entry : ranges) {
      w1::address_range range{};
      std::string parse_error;
      if (!parse_range(entry, range, parse_error)) {
        error = "invalid W1REWIND_MEM_RANGES entry: " + parse_error;
        return config;
      }
      config.memory.ranges.push_back(range);
    }
    merge_ranges(config.memory.ranges);
  }

  config.output_path = loader.get<std::string>("OUTPUT", "");
  config.compress_trace = loader.get<bool>("COMPRESS", config.compress_trace);
  config.chunk_size = loader.get<uint32_t>("CHUNK_SIZE", config.chunk_size);

  auto module_filter_env = loader.get_list("MODULE_FILTER");
  if (!module_filter_env.empty()) {
    config.common.instrumentation.include_modules.insert(
        config.common.instrumentation.include_modules.end(), module_filter_env.begin(), module_filter_env.end()
    );
  }

  if (!config.validate(error)) {
    return config;
  }

  return config;
}

bool rewind_config::validate(std::string& error) const {
  error.clear();
  using register_options = rewind_config::register_options;
  using stack_window_options = rewind_config::stack_window_options;
  using flow_options = rewind_config::flow_options;
  using memory_access = rewind_config::memory_access;
  using memory_filter_kind = rewind_config::memory_filter_kind;

  if (registers.capture != register_options::capture_kind::gpr) {
    error = "register capture mode not supported";
    return false;
  }

  if (registers.bytes) {
    error = "register byte capture not supported";
    return false;
  }

  if (flow.mode == flow_options::flow_mode::block) {
    if (registers.deltas) {
      error = "flow=block incompatible with reg_deltas";
      return false;
    }
    if (memory.access != memory_access::none) {
      error = "flow=block incompatible with mem_access";
      return false;
    }
  }

  if (stack_snapshots.interval > 0 && stack_window.mode == stack_window_options::window_mode::none) {
    error = "stack snapshots require stack window mode";
    return false;
  }

  if (stack_window.mode != stack_window_options::window_mode::none && stack_window.max_total_bytes == 0) {
    error = "stack window max_total_bytes must be non-zero";
    return false;
  }

  if (stack_window.mode == stack_window_options::window_mode::fixed &&
      (stack_window.above_bytes + stack_window.below_bytes) == 0) {
    error = "fixed stack window requires above or below bytes";
    return false;
  }

  if (stack_window.mode == stack_window_options::window_mode::frame && stack_window.max_total_bytes < 16) {
    error = "frame stack window requires max_total_bytes >= 16";
    return false;
  }

  if (memory.values && memory.access == memory_access::none) {
    error = "memory values require memory.access";
    return false;
  }

  bool filter_all = has_filter(memory.filters, memory_filter_kind::all);
  bool filter_ranges = has_filter(memory.filters, memory_filter_kind::ranges);
  bool filter_stack = has_filter(memory.filters, memory_filter_kind::stack_window);

  if (filter_all && (filter_ranges || filter_stack)) {
    error = "memory.filter=all cannot be combined with other filters";
    return false;
  }

  if (filter_ranges && memory.ranges.empty()) {
    error = "memory.filter=ranges requires MEM_RANGES";
    return false;
  }

  if (filter_stack && stack_window.mode == stack_window_options::window_mode::none) {
    error = "memory.filter=stack_window requires stack window mode";
    return false;
  }

  return true;
}

} // namespace w1rewind

```

`src/tracers/w1rewind/config/rewind_config.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>
#include <vector>

#include "w1instrument/config/tracer_common_config.hpp"
#include "w1rewind/format/trace_format.hpp"
#include "w1base/types.hpp"

namespace w1rewind {

struct rewind_config {
  w1::instrument::config::tracer_common_config common{};
  w1::instrument::config::thread_attach_policy threads = w1::instrument::config::thread_attach_policy::main_only;

  struct flow_options {
    enum class flow_mode { instruction, block };
    flow_mode mode = flow_mode::block;
  };

  struct register_options {
    enum class capture_kind { gpr };
    capture_kind capture = capture_kind::gpr;
    bool deltas = false;
    uint64_t snapshot_interval = 0;
    bool bytes = false;
  };

  struct stack_window_options {
    enum class window_mode { none, fixed, frame };
    window_mode mode = window_mode::none;
    uint64_t above_bytes = 512;
    uint64_t below_bytes = 2048;
    uint64_t max_total_bytes = 4096;
  };

  struct stack_snapshot_options {
    uint64_t interval = 0;
  };

  enum class memory_access { none, reads, writes, reads_writes };
  enum class memory_filter_kind { all, ranges, stack_window };

  struct memory_options {
    memory_access access = memory_access::none;
    bool values = false;
    uint32_t max_value_bytes = 32;
    std::vector<memory_filter_kind> filters = {memory_filter_kind::all};
    std::vector<w1::address_range> ranges{};
  };

  flow_options flow{};
  register_options registers{};
  stack_window_options stack_window{};
  stack_snapshot_options stack_snapshots{};
  memory_options memory{};
  std::string output_path;
  bool compress_trace = false;
  uint32_t chunk_size = w1::rewind::k_trace_chunk_bytes;

  static rewind_config from_environment(std::string& error);
  bool validate(std::string& error) const;
};

} // namespace w1rewind

```

`src/tracers/w1rewind/engine/module_table_builder.cpp`:

```cpp
#include "module_table_builder.hpp"

#include <algorithm>
#include <filesystem>
#include <limits>
#include <optional>

#include <QBDI.h>

#include "w1base/uuid_format.hpp"
#include "w1rewind/record/memory_map_utils.hpp"

#if defined(WITNESS_LIEF_ENABLED)
#include <LIEF/LIEF.hpp>
#include <LIEF/ELF/Note.hpp>
#include <LIEF/MachO/Binary.hpp>
#include <LIEF/MachO/FatBinary.hpp>
#include <LIEF/MachO/Header.hpp>
#include <LIEF/MachO/Parser.hpp>
#include <LIEF/MachO/UUIDCommand.hpp>
#include <LIEF/PE/Binary.hpp>
#include <LIEF/PE/debug/CodeViewPDB.hpp>
#endif

namespace {
w1::rewind::module_perm module_perm_from_qbdi(uint32_t perms) {
  w1::rewind::module_perm out = w1::rewind::module_perm::none;
  if (perms & QBDI::PF_READ) {
    out = out | w1::rewind::module_perm::read;
  }
  if (perms & QBDI::PF_WRITE) {
    out = out | w1::rewind::module_perm::write;
  }
  if (perms & QBDI::PF_EXEC) {
    out = out | w1::rewind::module_perm::exec;
  }
  return out;
}

bool path_exists(const std::string& path) {
  if (path.empty()) {
    return false;
  }
  std::error_code ec;
  return std::filesystem::exists(std::filesystem::path(path), ec);
}

#if defined(WITNESS_LIEF_ENABLED)
std::string hex_encode(LIEF::span<const uint8_t> bytes) {
  static const char k_hex[] = "0123456789abcdef";
  std::string out;
  out.reserve(bytes.size() * 2);
  for (uint8_t value : bytes) {
    out.push_back(k_hex[(value >> 4) & 0x0f]);
    out.push_back(k_hex[value & 0x0f]);
  }
  return out;
}

std::optional<uint64_t> elf_link_base(const LIEF::ELF::Binary& elf) {
  uint64_t link_base = std::numeric_limits<uint64_t>::max();
  for (const LIEF::ELF::Segment& segment : elf.segments()) {
    if (!segment.is_load()) {
      continue;
    }
    if (segment.virtual_size() == 0) {
      continue;
    }
    link_base = std::min(link_base, segment.virtual_address());
  }
  if (link_base == std::numeric_limits<uint64_t>::max()) {
    return std::nullopt;
  }
  return link_base;
}

std::optional<uint64_t> macho_link_base(const LIEF::MachO::Binary& macho) {
  uint64_t link_base = std::numeric_limits<uint64_t>::max();
  for (const LIEF::MachO::SegmentCommand& segment : macho.segments()) {
    if (segment.name() == "__PAGEZERO") {
      continue;
    }
    if (segment.virtual_size() == 0) {
      continue;
    }
    link_base = std::min(link_base, segment.virtual_address());
  }
  if (link_base == std::numeric_limits<uint64_t>::max()) {
    return std::nullopt;
  }
  return link_base;
}

std::optional<uint64_t> pe_link_base(const LIEF::PE::Binary& pe) { return pe.imagebase(); }

LIEF::MachO::Header::CPU_TYPE macho_cpu_type_for_arch(const w1::arch::arch_spec& arch) {
  using cpu_type = LIEF::MachO::Header::CPU_TYPE;
  switch (arch.arch_mode) {
  case w1::arch::mode::x86_64:
    return cpu_type::X86_64;
  case w1::arch::mode::x86_32:
    return cpu_type::X86;
  case w1::arch::mode::aarch64:
    return cpu_type::ARM64;
  case w1::arch::mode::arm:
  case w1::arch::mode::thumb:
    return cpu_type::ARM;
  default:
    break;
  }
  return cpu_type::ANY;
}

std::optional<std::string> read_macho_uuid(const std::string& path, const w1::arch::arch_spec& arch) {
  auto fat = LIEF::MachO::Parser::parse(path);
  if (!fat || fat->empty()) {
    return std::nullopt;
  }

  const auto target = macho_cpu_type_for_arch(arch);
  const LIEF::MachO::Binary* selected = nullptr;
  for (const auto& binary : *fat) {
    if (target == LIEF::MachO::Header::CPU_TYPE::ANY || binary.header().cpu_type() == target) {
      selected = &binary;
      break;
    }
  }
  if (!selected) {
    selected = fat->front();
  }
  if (!selected || !selected->has_uuid()) {
    return std::nullopt;
  }
  const auto* uuid_cmd = selected->uuid();
  if (!uuid_cmd) {
    return std::nullopt;
  }
  const auto& uuid_bytes = uuid_cmd->uuid();
  if (w1::util::is_all_zero_uuid(uuid_bytes)) {
    return std::nullopt;
  }
  return w1::util::format_uuid(uuid_bytes);
}

std::optional<uint64_t> read_macho_link_base(const std::string& path, const w1::arch::arch_spec& arch) {
  auto fat = LIEF::MachO::Parser::parse(path);
  if (!fat || fat->empty()) {
    return std::nullopt;
  }

  const auto target = macho_cpu_type_for_arch(arch);
  const LIEF::MachO::Binary* selected = nullptr;
  for (const auto& binary : *fat) {
    if (target == LIEF::MachO::Header::CPU_TYPE::ANY || binary.header().cpu_type() == target) {
      selected = &binary;
      break;
    }
  }
  if (!selected) {
    selected = fat->front();
  }
  if (!selected) {
    return std::nullopt;
  }
  return macho_link_base(*selected);
}

w1rewind::module_metadata resolve_module_metadata(const std::string& path, const w1::arch::arch_spec& arch) {
  w1rewind::module_metadata meta{};
  if (path.empty()) {
    return meta;
  }
  auto binary = LIEF::Parser::parse(path);
  if (!binary) {
    return meta;
  }

  switch (binary->format()) {
  case LIEF::Binary::FORMATS::ELF: {
    meta.format = w1::rewind::module_format::elf;
    auto* elf = dynamic_cast<LIEF::ELF::Binary*>(binary.get());
    if (!elf) {
      return meta;
    }
    meta.entry_point = elf->entrypoint();
    if (auto link_base = elf_link_base(*elf)) {
      meta.link_base = *link_base;
      meta.flags |= w1::rewind::module_record_flag_link_base_valid;
    }
    const auto* note = elf->get(LIEF::ELF::Note::TYPE::GNU_BUILD_ID);
    if (!note) {
      return meta;
    }
    auto desc = note->description();
    if (desc.empty()) {
      return meta;
    }
    meta.identity = hex_encode(desc);
    return meta;
  }
  case LIEF::Binary::FORMATS::MACHO: {
    meta.format = w1::rewind::module_format::macho;
    auto uuid = read_macho_uuid(path, arch);
    if (uuid.has_value()) {
      meta.identity = *uuid;
    }
    if (auto link_base = read_macho_link_base(path, arch)) {
      meta.link_base = *link_base;
      meta.flags |= w1::rewind::module_record_flag_link_base_valid;
    }
    auto* macho = dynamic_cast<LIEF::MachO::Binary*>(binary.get());
    if (!macho) {
      return meta;
    }
    meta.entry_point = macho->entrypoint();
    if (!macho->has_uuid()) {
      if ((meta.flags & w1::rewind::module_record_flag_link_base_valid) == 0) {
        if (auto link_base = macho_link_base(*macho)) {
          meta.link_base = *link_base;
          meta.flags |= w1::rewind::module_record_flag_link_base_valid;
        }
      }
      return meta;
    }
    if ((meta.flags & w1::rewind::module_record_flag_link_base_valid) == 0) {
      if (auto link_base = macho_link_base(*macho)) {
        meta.link_base = *link_base;
        meta.flags |= w1::rewind::module_record_flag_link_base_valid;
      }
    }
    const auto* uuid_cmd = macho->uuid();
    if (!uuid_cmd) {
      return meta;
    }
    const auto& uuid_bytes = uuid_cmd->uuid();
    if (w1::util::is_all_zero_uuid(uuid_bytes)) {
      return meta;
    }
    meta.identity = w1::util::format_uuid(uuid_bytes);
    return meta;
  }
  case LIEF::Binary::FORMATS::PE: {
    meta.format = w1::rewind::module_format::pe;
    auto* pe = dynamic_cast<LIEF::PE::Binary*>(binary.get());
    if (!pe) {
      return meta;
    }
    meta.entry_point = pe->entrypoint();
    if (auto link_base = pe_link_base(*pe)) {
      meta.link_base = *link_base;
      meta.flags |= w1::rewind::module_record_flag_link_base_valid;
    }
    const auto* pdb = pe->codeview_pdb();
    if (!pdb) {
      return meta;
    }
    auto guid = pdb->guid();
    if (!guid.empty()) {
      meta.identity = std::move(guid);
      meta.identity_age = pdb->age();
    }
    return meta;
  }
  default:
    break;
  }
  return meta;
}
#else
w1rewind::module_metadata resolve_module_metadata(const std::string&, const w1::arch::arch_spec&) {
  return w1rewind::module_metadata{};
}
#endif

} // namespace

namespace w1rewind {

module_metadata module_metadata_cache::lookup(const std::string& path) {
  if (path.empty()) {
    return module_metadata{};
  }

  std::lock_guard<std::mutex> lock(mutex_);
  auto it = cache_.find(path);
  if (it != cache_.end()) {
    return it->second;
  }

  module_metadata meta = resolve_module_metadata(path, arch_);
  cache_.emplace(path, meta);
  return meta;
}

w1::rewind::module_record build_module_record(
    const w1::runtime::module_info& module, uint64_t id, module_metadata_cache& cache
) {
  w1::rewind::module_record record{};
  record.id = id;
  record.base = module.base_address;
  record.size = module.size;
  record.permissions = module_perm_from_qbdi(module.permissions);
  record.path = module.path.empty() ? module.name : module.path;

  const module_metadata meta = cache.lookup(record.path);
  record.format = meta.format;
  record.identity = meta.identity;
  record.identity_age = meta.identity_age;
  record.flags = meta.flags;
  if (module.is_main) {
    record.flags |= w1::rewind::module_record_flag_main;
  }
  if (meta.format != w1::rewind::module_format::unknown || path_exists(record.path)) {
    record.flags |= w1::rewind::module_record_flag_file_backed;
  }
  if (meta.entry_point.has_value()) {
    record.entry_point = *meta.entry_point;
    record.flags |= w1::rewind::module_record_flag_entry_point_valid;
  }
  record.link_base = meta.link_base;
  return record;
}

std::vector<w1::rewind::memory_region_record> collect_memory_map(
    const std::vector<w1::rewind::module_record>& modules
) {
  std::vector<w1::rewind::memory_region_record> regions;
  auto maps = QBDI::getCurrentProcessMaps(true);
  regions.reserve(maps.size());
  for (const auto& map : maps) {
    uint64_t start = map.range.start();
    uint64_t end = map.range.end();
    if (end <= start) {
      continue;
    }
    w1::rewind::memory_region_record region{};
    region.base = start;
    region.size = end - start;
    region.permissions = module_perm_from_qbdi(map.permission);
    region.image_id = 0;
    region.name = map.name;
    regions.push_back(std::move(region));
  }
  w1::rewind::assign_memory_map_image_ids(regions, modules);
  std::sort(regions.begin(), regions.end(), [](const auto& left, const auto& right) { return left.base < right.base; });
  return regions;
}

} // namespace w1rewind

```

`src/tracers/w1rewind/engine/module_table_builder.hpp`:

```hpp
#pragma once

#include <mutex>
#include <optional>
#include <string>
#include <unordered_map>
#include <vector>

#include "w1base/arch_spec.hpp"
#include "w1rewind/format/trace_format.hpp"
#include "w1runtime/module_catalog.hpp"

namespace w1rewind {

struct module_metadata {
  w1::rewind::module_format format = w1::rewind::module_format::unknown;
  std::string identity;
  uint32_t identity_age = 0;
  uint32_t flags = 0;
  uint64_t link_base = 0;
  std::optional<uint64_t> entry_point;
};

class module_metadata_cache {
public:
  explicit module_metadata_cache(w1::arch::arch_spec arch) : arch_(arch) {}

  module_metadata lookup(const std::string& path);

private:
  w1::arch::arch_spec arch_{};
  std::mutex mutex_{};
  std::unordered_map<std::string, module_metadata> cache_{};
};

w1::rewind::module_record build_module_record(
    const w1::runtime::module_info& module, uint64_t id, module_metadata_cache& cache
);

std::vector<w1::rewind::memory_region_record> collect_memory_map(const std::vector<w1::rewind::module_record>& modules);

} // namespace w1rewind

```

`src/tracers/w1rewind/engine/register_schema.cpp`:

```cpp
#include "register_schema.hpp"

#include <cstddef>

#include "w1runtime/register_capture.hpp"
#include "w1rewind/format/register_metadata.hpp"

namespace w1rewind {

void register_schema::clear() {
  names_.clear();
  specs_.clear();
}

void register_schema::update(const w1::util::register_state& regs, const w1::arch::arch_spec& arch) {
  names_ = regs.get_register_names();
  specs_.clear();
  specs_.reserve(names_.size());

  uint32_t pointer_size = arch.pointer_bits == 0 ? static_cast<uint32_t>(sizeof(void*)) : arch.pointer_bits / 8;
  for (size_t i = 0; i < names_.size(); ++i) {
    specs_.push_back(w1::rewind::build_register_spec(arch, static_cast<uint16_t>(i), names_[i], pointer_size));
  }
}

} // namespace w1rewind

```

`src/tracers/w1rewind/engine/register_schema.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>

#include "w1base/arch_spec.hpp"
#include "w1rewind/format/trace_format.hpp"

namespace w1::util {
class register_state;
}

namespace w1rewind {

class register_schema {
public:
  void clear();
  void update(const w1::util::register_state& regs, const w1::arch::arch_spec& arch);
  bool empty() const { return specs_.empty(); }

  const std::vector<std::string>& names() const { return names_; }
  const std::vector<w1::rewind::register_spec>& specs() const { return specs_; }

private:
  std::vector<std::string> names_;
  std::vector<w1::rewind::register_spec> specs_;
};

} // namespace w1rewind

```

`src/tracers/w1rewind/engine/rewind_engine.cpp`:

```cpp
#include "rewind_engine.hpp"

#include <algorithm>
#include <string_view>
#include <utility>

#include "w1base/arch_spec.hpp"

namespace w1rewind {
namespace {

constexpr uint64_t k_module_id_offset = 1;

std::string_view basename_view(std::string_view path) {
  const auto pos = path.find_last_of("/\\");
  if (pos == std::string_view::npos) {
    return path;
  }
  return path.substr(pos + 1);
}

} // namespace

using module_record = w1::rewind::module_record;
using module_load_record = w1::rewind::module_load_record;
using module_unload_record = w1::rewind::module_unload_record;

rewind_engine::rewind_engine(rewind_config config)
    : config_(std::move(config)), registry_(w1::core::instrumented_module_policy{config_.common.instrumentation}),
      log_(redlog::get_logger("w1rewind.engine")),
      instruction_flow_(config_.flow.mode == rewind_config::flow_options::flow_mode::instruction) {}

void rewind_engine::configure(w1::runtime::module_catalog& modules) {
  std::lock_guard<std::mutex> lock(mutex_);

  modules_ = &modules;
  if (configured_) {
    return;
  }

  registry_.configure(modules);
  trace_ready_.store(false, std::memory_order_release);
  trace_failed_.store(false, std::memory_order_release);
  register_schema_.clear();
  module_table_.clear();

  if (writer_) {
    writer_->close();
  }
  writer_.reset();
  builder_.reset();
  emitter_.reset();

  arch_spec_ = w1::arch::detect_host_arch_spec();
  metadata_cache_.emplace(arch_spec_);

  rebuild_module_state_locked(modules);

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = config_.output_path;
  writer_config.log = redlog::get_logger("w1rewind.trace");
  writer_config.compression =
      config_.compress_trace ? w1::rewind::trace_compression::zstd : w1::rewind::trace_compression::none;
  writer_config.chunk_size = config_.chunk_size;

  writer_ = w1::rewind::make_trace_file_writer(writer_config);
  if (!writer_ || !writer_->open()) {
    trace_failed_.store(true, std::memory_order_release);
    log_.err("failed to open trace writer", redlog::field("path", writer_config.path));
    return;
  }

  w1::rewind::trace_builder_config builder_config;
  builder_config.sink = writer_;
  builder_config.log = writer_config.log;
  builder_config.options.record_instructions = instruction_flow_;
  builder_config.options.record_register_deltas = config_.registers.deltas;
  builder_config.options.record_memory_access = config_.memory.access != rewind_config::memory_access::none;
  builder_config.options.record_memory_values = config_.memory.values;
  builder_config.options.record_snapshots =
      config_.registers.snapshot_interval > 0 || config_.stack_snapshots.interval > 0;
  builder_config.options.record_stack_segments = config_.stack_snapshots.interval > 0;

  builder_ = std::make_unique<w1::rewind::trace_builder>(std::move(builder_config));
  emitter_ = std::make_unique<trace_emitter>(builder_.get(), config_, instruction_flow_);
  configured_ = true;
}

bool rewind_engine::ensure_trace_ready(w1::trace_context& ctx, const w1::util::register_state& regs) {
  if (trace_ready()) {
    return true;
  }
  if (trace_failed_.load(std::memory_order_acquire)) {
    return false;
  }

  std::lock_guard<std::mutex> lock(mutex_);
  if (trace_ready_.load(std::memory_order_acquire)) {
    return true;
  }
  if (trace_failed_.load(std::memory_order_acquire)) {
    return false;
  }

  if (!start_trace_locked(ctx, regs)) {
    trace_failed_.store(true, std::memory_order_release);
    return false;
  }

  trace_ready_.store(true, std::memory_order_release);
  return true;
}

bool rewind_engine::start_trace_locked(w1::trace_context& ctx, const w1::util::register_state& regs) {
  if (!builder_ || !builder_->good()) {
    log_.err("trace builder not ready");
    return false;
  }

  if (arch_spec_.arch_family == w1::arch::family::unknown || arch_spec_.arch_mode == w1::arch::mode::unknown) {
    log_.err("unsupported host architecture");
    return false;
  }

  register_schema_.update(regs, arch_spec_);
  if (register_schema_.empty()) {
    log_.err("register specs missing");
    return false;
  }

  ctx.modules().refresh();
  rebuild_module_state_locked(ctx.modules());

  auto memory_map = collect_memory_map(module_table_);

  w1::rewind::target_info_record target{};
  target.os = detect_os_id();

  auto environment = build_target_environment(memory_map, module_table_, arch_spec_);

  if (!builder_->begin_trace(arch_spec_, target, environment, register_schema_.specs())) {
    log_.err("failed to begin trace", redlog::field("error", builder_->error()));
    return false;
  }

  if (!module_table_.empty()) {
    if (!builder_->set_module_table(module_table_)) {
      log_.err("failed to write module table", redlog::field("error", builder_->error()));
      return false;
    }
  }

  if (!memory_map.empty()) {
    if (!builder_->set_memory_map(std::move(memory_map))) {
      log_.err("failed to write memory map", redlog::field("error", builder_->error()));
      return false;
    }
  }

  return true;
}

void rewind_engine::rebuild_module_state_locked(const w1::runtime::module_catalog& modules) {
  module_table_.clear();
  auto list = modules.list_modules();
  module_table_.reserve(list.size());

  if (!metadata_cache_.has_value()) {
    metadata_cache_.emplace(arch_spec_);
  }

  for (const auto& module : list) {
    auto lookup = registry_.find(module.base_address);
    if (!lookup) {
      continue;
    }

    const uint64_t id = lookup->value + k_module_id_offset;
    module_table_.push_back(build_module_record(module, id, *metadata_cache_));
  }
}

std::optional<w1::runtime::module_info> rewind_engine::find_module_info(const w1::monitor::module_event& event) const {
  if (!modules_) {
    return std::nullopt;
  }

  const uint64_t base = reinterpret_cast<uint64_t>(event.base);
  auto list = modules_->list_modules();

  if (base != 0) {
    auto it = std::find_if(list.begin(), list.end(), [&](const w1::runtime::module_info& module) {
      return module.full_range.start <= base && base < module.full_range.end;
    });
    if (it != list.end()) {
      return *it;
    }
  }

  if (!event.path.empty()) {
    const std::string_view event_path = event.path;
    const std::string_view event_name = basename_view(event_path);
    auto it = std::find_if(list.begin(), list.end(), [&](const w1::runtime::module_info& module) {
      if (module.path == event_path || module.name == event_path) {
        return true;
      }
      if (!event_name.empty() && (module.name == event_name || basename_view(module.path) == event_name)) {
        return true;
      }
      return false;
    });
    if (it != list.end()) {
      return *it;
    }
  }

  return std::nullopt;
}

bool rewind_engine::handle_module_loaded_locked(const w1::runtime::module_info& module) {
  if (!metadata_cache_.has_value()) {
    metadata_cache_.emplace(arch_spec_);
  }

  auto lookup = registry_.find(module.base_address);
  if (!lookup) {
    return false;
  }

  const uint64_t id = lookup->value + k_module_id_offset;
  module_record record = build_module_record(module, id, *metadata_cache_);
  upsert_module_record(record);

  if (trace_ready_.load(std::memory_order_acquire) && builder_ && builder_->good()) {
    if (!builder_->emit_module_load(module_load_record{record})) {
      log_.err("failed to write module load", redlog::field("error", builder_->error()));
    } else if (!emit_memory_map_locked()) {
      log_.err("failed to update memory map", redlog::field("error", builder_->error()));
    }
  }

  return true;
}

void rewind_engine::handle_module_unloaded_locked(const w1::monitor::module_event& event) {
  const uint64_t base = reinterpret_cast<uint64_t>(event.base);
  auto removed = remove_module_record(0, base, event.path);
  if (!removed.has_value()) {
    return;
  }

  module_unload_record record{};
  record.module_id = removed->id;
  record.base = removed->base;
  record.size = removed->size;
  record.path = removed->path;

  if (trace_ready_.load(std::memory_order_acquire) && builder_ && builder_->good()) {
    if (!builder_->emit_module_unload(record)) {
      log_.err("failed to write module unload", redlog::field("error", builder_->error()));
    } else if (!emit_memory_map_locked()) {
      log_.err("failed to update memory map", redlog::field("error", builder_->error()));
    }
  }
}

void rewind_engine::upsert_module_record(module_record record) {
  auto it = std::find_if(module_table_.begin(), module_table_.end(), [&](const module_record& entry) {
    return entry.id == record.id;
  });
  if (it == module_table_.end()) {
    it = std::find_if(module_table_.begin(), module_table_.end(), [&](const module_record& entry) {
      return entry.base == record.base && entry.base != 0;
    });
  }
  if (it != module_table_.end()) {
    *it = std::move(record);
    return;
  }
  module_table_.push_back(std::move(record));
}

std::optional<module_record> rewind_engine::remove_module_record(
    uint64_t module_id, uint64_t base, const std::string& path
) {
  auto it = module_table_.end();
  if (module_id != 0) {
    it = std::find_if(module_table_.begin(), module_table_.end(), [&](const module_record& entry) {
      return entry.id == module_id;
    });
  }

  if (it == module_table_.end() && base != 0) {
    it = std::find_if(module_table_.begin(), module_table_.end(), [&](const module_record& entry) {
      return entry.base == base;
    });
  }

  if (it == module_table_.end() && !path.empty()) {
    it = std::find_if(module_table_.begin(), module_table_.end(), [&](const module_record& entry) {
      return entry.path == path;
    });
  }

  if (it == module_table_.end()) {
    return std::nullopt;
  }

  module_record removed = *it;
  module_table_.erase(it);
  return removed;
}

bool rewind_engine::emit_memory_map_locked() {
  if (!builder_ || !builder_->good()) {
    return false;
  }
  auto memory_map = collect_memory_map(module_table_);
  if (memory_map.empty()) {
    return true;
  }
  return builder_->set_memory_map(std::move(memory_map));
}

bool rewind_engine::begin_thread(uint64_t thread_id, const std::string& name) {
  std::lock_guard<std::mutex> lock(mutex_);
  if (!emitter_) {
    return false;
  }
  return emitter_->begin_thread(thread_id, name);
}

bool rewind_engine::emit_block(
    uint64_t thread_id, uint64_t address, uint32_t size, uint32_t flags, uint64_t& sequence_out
) {
  std::lock_guard<std::mutex> lock(mutex_);
  if (!emitter_) {
    return false;
  }
  return emitter_->emit_block(thread_id, address, size, flags, sequence_out);
}

void rewind_engine::flush_pending(std::optional<pending_instruction>& pending) {
  std::lock_guard<std::mutex> lock(mutex_);
  if (emitter_) {
    emitter_->flush_pending(pending);
  }
}

bool rewind_engine::emit_snapshot(
    uint64_t thread_id, uint64_t sequence, uint64_t snapshot_id, std::span<const w1::rewind::register_delta> registers,
    std::span<const w1::rewind::stack_segment> stack_segments, std::string reason
) {
  std::lock_guard<std::mutex> lock(mutex_);
  if (!builder_ || !builder_->good()) {
    return false;
  }
  return builder_->emit_snapshot(thread_id, sequence, snapshot_id, registers, stack_segments, std::move(reason));
}

void rewind_engine::finalize_thread(
    uint64_t thread_id, const std::string& name, std::optional<pending_instruction>& pending
) {
  std::lock_guard<std::mutex> lock(mutex_);
  if (emitter_) {
    emitter_->flush_pending(pending);
    emitter_->finalize_thread(thread_id, name);
  }
}

void rewind_engine::on_process_event(const w1::runtime::process_event& event) {
  if (trace_failed_.load(std::memory_order_acquire)) {
    return;
  }

  if (event.type != w1::runtime::process_event::kind::module_loaded &&
      event.type != w1::runtime::process_event::kind::module_unloaded) {
    return;
  }

  std::lock_guard<std::mutex> lock(mutex_);
  auto info = find_module_info(event.module);

  if (event.type == w1::runtime::process_event::kind::module_loaded) {
    if (info.has_value()) {
      handle_module_loaded_locked(*info);
    } else {
      log_.wrn("module load event missing module info", redlog::field("path", event.module.path));
    }
  } else if (event.type == w1::runtime::process_event::kind::module_unloaded) {
    handle_module_unloaded_locked(event.module);
  }
}

bool rewind_engine::export_trace() {
  std::lock_guard<std::mutex> lock(mutex_);
  if (builder_) {
    builder_->flush();
  }
  bool ok = writer_ && writer_->good();
  if (writer_) {
    writer_->close();
  }
  configured_ = false;
  trace_ready_.store(false, std::memory_order_release);
  return ok;
}

size_t rewind_engine::module_count() const {
  std::lock_guard<std::mutex> lock(mutex_);
  return module_table_.size();
}

std::string rewind_engine::output_path() const {
  std::lock_guard<std::mutex> lock(mutex_);
  return writer_ ? writer_->path() : std::string{};
}

} // namespace w1rewind

```

`src/tracers/w1rewind/engine/rewind_engine.hpp`:

```hpp
#pragma once

#include <atomic>
#include <cstdint>
#include <memory>
#include <mutex>
#include <optional>
#include <span>
#include <string>
#include <vector>

#include <redlog.hpp>

#include "config/rewind_config.hpp"
#include "engine/module_table_builder.hpp"
#include "engine/register_schema.hpp"
#include "engine/trace_emitter.hpp"
#include "engine/target_environment_provider.hpp"
#include "w1instrument/core/module_registry.hpp"
#include "w1instrument/tracer/trace_context.hpp"
#include "w1runtime/process_event.hpp"
#include "w1rewind/record/trace_builder.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"

namespace w1::util {
class register_state;
}

namespace w1rewind {

class rewind_engine {
public:
  explicit rewind_engine(rewind_config config);

  void configure(w1::runtime::module_catalog& modules);
  bool ensure_trace_ready(w1::trace_context& ctx, const w1::util::register_state& regs);

  bool trace_ready() const { return trace_ready_.load(std::memory_order_acquire); }
  bool instruction_flow() const { return instruction_flow_; }

  const rewind_config& config() const { return config_; }
  const register_schema& schema() const { return register_schema_; }
  const w1::arch::arch_spec& arch_spec() const { return arch_spec_; }

  bool begin_thread(uint64_t thread_id, const std::string& name);
  bool emit_block(uint64_t thread_id, uint64_t address, uint32_t size, uint32_t flags, uint64_t& sequence_out);
  void flush_pending(std::optional<pending_instruction>& pending);
  bool emit_snapshot(
      uint64_t thread_id, uint64_t sequence, uint64_t snapshot_id,
      std::span<const w1::rewind::register_delta> registers, std::span<const w1::rewind::stack_segment> stack_segments,
      std::string reason
  );
  void finalize_thread(uint64_t thread_id, const std::string& name, std::optional<pending_instruction>& pending);

  void on_process_event(const w1::runtime::process_event& event);

  bool export_trace();
  size_t module_count() const;
  std::string output_path() const;

private:
  using registry_type = w1::core::module_registry<w1::core::instrumented_module_policy, uint64_t>;

  bool start_trace_locked(w1::trace_context& ctx, const w1::util::register_state& regs);
  void rebuild_module_state_locked(const w1::runtime::module_catalog& modules);
  std::optional<w1::runtime::module_info> find_module_info(const w1::monitor::module_event& event) const;
  bool handle_module_loaded_locked(const w1::runtime::module_info& module);
  void handle_module_unloaded_locked(const w1::monitor::module_event& event);

  void upsert_module_record(w1::rewind::module_record record);
  std::optional<w1::rewind::module_record> remove_module_record(
      uint64_t module_id, uint64_t base, const std::string& path
  );

  bool emit_memory_map_locked();

  rewind_config config_{};
  registry_type registry_{};
  w1::runtime::module_catalog* modules_ = nullptr;

  w1::arch::arch_spec arch_spec_{};
  std::optional<module_metadata_cache> metadata_cache_;
  register_schema register_schema_{};

  std::shared_ptr<w1::rewind::trace_file_writer> writer_{};
  std::unique_ptr<w1::rewind::trace_builder> builder_{};
  std::unique_ptr<trace_emitter> emitter_{};

  std::vector<w1::rewind::module_record> module_table_{};

  redlog::logger log_;
  bool instruction_flow_ = false;
  bool configured_ = false;
  std::atomic<bool> trace_ready_{false};
  std::atomic<bool> trace_failed_{false};

  mutable std::mutex mutex_{};
};

} // namespace w1rewind

```

`src/tracers/w1rewind/engine/target_environment_provider.cpp`:

```cpp
#include "target_environment_provider.hpp"

#include <algorithm>
#include <limits>

#if defined(_WIN32)
#include <windows.h>
#else
#include <unistd.h>
#include <sys/utsname.h>
#endif

#if defined(__APPLE__)
#include <sys/sysctl.h>
#endif

namespace {
struct addressing_bits_info {
  uint32_t addressing_bits = 0;
  uint32_t low_mem_addressing_bits = 0;
  uint32_t high_mem_addressing_bits = 0;
};

uint32_t bit_length_u64(uint64_t value) {
  uint32_t bits = 0;
  while (value != 0) {
    value >>= 1;
    ++bits;
  }
  return bits;
}

addressing_bits_info compute_addressing_bits(
    const std::vector<w1::rewind::memory_region_record>& memory_map,
    const std::vector<w1::rewind::module_record>& modules, uint32_t pointer_bits
) {
  addressing_bits_info out{};
  uint32_t address_bits = pointer_bits == 0 ? 64u : pointer_bits;
  if (address_bits <= 32) {
    out.addressing_bits = address_bits;
    out.low_mem_addressing_bits = address_bits;
    out.high_mem_addressing_bits = address_bits;
    return out;
  }

  bool found = false;
  uint32_t low_bits = 0;
  uint32_t high_bits = 0;

  auto consider_end = [&](uint64_t end) {
    found = true;
    if ((end & (1ull << 63)) != 0) {
      uint32_t bits = bit_length_u64(~end) + 1;
      high_bits = std::max(high_bits, bits);
    } else {
      uint32_t bits = bit_length_u64(end) + 1;
      low_bits = std::max(low_bits, bits);
    }
  };

  auto consider_range = [&](uint64_t base, uint64_t size) {
    if (size == 0) {
      return;
    }
    uint64_t end = base + size - 1;
    if (end < base) {
      end = std::numeric_limits<uint64_t>::max();
    }
    consider_end(end);
  };

  if (!memory_map.empty()) {
    for (const auto& region : memory_map) {
      consider_range(region.base, region.size);
    }
  } else {
    for (const auto& module : modules) {
      consider_range(module.base, module.size);
    }
  }

  if (!found) {
    out.addressing_bits = address_bits;
    out.low_mem_addressing_bits = address_bits;
    out.high_mem_addressing_bits = address_bits;
    return out;
  }

  if (low_bits == 0) {
    low_bits = high_bits;
  }
  if (high_bits == 0) {
    high_bits = low_bits;
  }
  if (low_bits == 0) {
    low_bits = address_bits;
  }
  if (high_bits == 0) {
    high_bits = address_bits;
  }

  if (low_bits > address_bits) {
    low_bits = address_bits;
  }
  if (high_bits > address_bits) {
    high_bits = address_bits;
  }

  uint32_t max_bits = std::max(low_bits, high_bits);
  if (max_bits == 0 || max_bits > address_bits) {
    max_bits = address_bits;
  }

  out.addressing_bits = max_bits;
  out.low_mem_addressing_bits = low_bits;
  out.high_mem_addressing_bits = high_bits;
  return out;
}

#if defined(__APPLE__)
std::string sysctl_string(const char* key) {
  size_t size = 0;
  if (sysctlbyname(key, nullptr, &size, nullptr, 0) != 0 || size == 0) {
    return {};
  }
  std::string out(size, '\0');
  if (sysctlbyname(key, out.data(), &size, nullptr, 0) != 0) {
    return {};
  }
  if (!out.empty() && out.back() == '\0') {
    out.pop_back();
  }
  return out;
}
#endif

std::string detect_host_name() {
#if defined(_WIN32)
  char buffer[MAX_COMPUTERNAME_LENGTH + 1] = {};
  DWORD size = MAX_COMPUTERNAME_LENGTH + 1;
  if (GetComputerNameA(buffer, &size)) {
    return std::string(buffer, size);
  }
#else
  char buffer[256] = {};
  if (gethostname(buffer, sizeof(buffer) - 1) == 0) {
    buffer[sizeof(buffer) - 1] = '\0';
    return buffer;
  }
#endif
  return {};
}

std::string detect_os_version() {
#if defined(__APPLE__)
  return sysctl_string("kern.osproductversion");
#elif !defined(_WIN32)
  struct utsname info{};
  if (uname(&info) == 0) {
    return info.release;
  }
#endif
  return {};
}

std::string detect_os_build() {
#if defined(__APPLE__)
  return sysctl_string("kern.osversion");
#elif !defined(_WIN32)
  struct utsname info{};
  if (uname(&info) == 0) {
    return info.version;
  }
#endif
  return {};
}

std::string detect_os_kernel() {
#if defined(__APPLE__)
  return sysctl_string("kern.osrelease");
#elif defined(_WIN32)
  return "windows";
#else
  struct utsname info{};
  if (uname(&info) == 0) {
    return info.sysname;
  }
#endif
  return {};
}

uint64_t detect_pid() {
#if defined(_WIN32)
  return static_cast<uint64_t>(GetCurrentProcessId());
#else
  return static_cast<uint64_t>(getpid());
#endif
}

} // namespace

namespace w1rewind {

std::string detect_os_id() {
#if defined(_WIN32)
  return "windows";
#elif defined(__APPLE__)
  return "macos";
#elif defined(__linux__)
  return "linux";
#else
  return {};
#endif
}

w1::rewind::target_environment_record build_target_environment(
    const std::vector<w1::rewind::memory_region_record>& memory_map,
    const std::vector<w1::rewind::module_record>& modules, const w1::arch::arch_spec& arch
) {
  w1::rewind::target_environment_record env{};
  env.os_version = detect_os_version();
  env.os_build = detect_os_build();
  env.os_kernel = detect_os_kernel();
  env.hostname = detect_host_name();
  if (env.hostname.empty()) {
    env.hostname = "w1rewind";
  }
  env.pid = detect_pid();
  auto bits = compute_addressing_bits(memory_map, modules, arch.pointer_bits);
  env.addressing_bits = bits.addressing_bits;
  env.low_mem_addressing_bits = bits.low_mem_addressing_bits;
  env.high_mem_addressing_bits = bits.high_mem_addressing_bits;
  return env;
}

} // namespace w1rewind

```

`src/tracers/w1rewind/engine/target_environment_provider.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>

#include "w1base/arch_spec.hpp"
#include "w1rewind/format/trace_format.hpp"

namespace w1rewind {

std::string detect_os_id();

w1::rewind::target_environment_record build_target_environment(
    const std::vector<w1::rewind::memory_region_record>& memory_map,
    const std::vector<w1::rewind::module_record>& modules, const w1::arch::arch_spec& arch
);

} // namespace w1rewind

```

`src/tracers/w1rewind/engine/trace_emitter.cpp`:

```cpp
#include "trace_emitter.hpp"

namespace w1rewind {

trace_emitter::trace_emitter(w1::rewind::trace_builder* builder, const rewind_config& config, bool instruction_flow)
    : builder_(builder), config_(&config), instruction_flow_(instruction_flow) {}

bool trace_emitter::begin_thread(uint64_t thread_id, const std::string& name) {
  if (!builder_ || !builder_->good()) {
    return false;
  }
  return builder_->begin_thread(thread_id, name);
}

bool trace_emitter::emit_block(
    uint64_t thread_id, uint64_t address, uint32_t size, uint32_t flags, uint64_t& sequence_out
) {
  if (!builder_ || !builder_->good()) {
    return false;
  }
  return builder_->emit_block(thread_id, address, size, flags, sequence_out);
}

void trace_emitter::flush_pending(std::optional<pending_instruction>& pending) {
  if (!pending.has_value()) {
    return;
  }

  pending_instruction record = std::move(*pending);
  pending.reset();

  if (!instruction_flow_) {
    return;
  }
  if (!builder_ || !builder_->good()) {
    return;
  }

  uint64_t sequence = 0;
  if (!builder_->emit_instruction(record.thread_id, record.address, record.size, record.flags, sequence)) {
    return;
  }

  if (config_->registers.deltas && !record.register_deltas.empty()) {
    if (!builder_->emit_register_deltas(record.thread_id, sequence, record.register_deltas)) {
      return;
    }
  }

  if (config_->memory.access != rewind_config::memory_access::none) {
    for (const auto& access : record.memory_accesses) {
      if (!builder_->emit_memory_access(
              record.thread_id, sequence, access.kind, access.address, access.size, access.value_known,
              access.value_truncated, access.data
          )) {
        return;
      }
    }
  }

  if (record.snapshot.has_value()) {
    builder_->emit_snapshot(
        record.thread_id, sequence, record.snapshot->snapshot_id, record.snapshot->registers,
        record.snapshot->stack_segments, std::move(record.snapshot->reason)
    );
  }
}

void trace_emitter::finalize_thread(uint64_t thread_id, const std::string& name) {
  if (!builder_ || !builder_->good()) {
    return;
  }
  builder_->begin_thread(thread_id, name);
  builder_->end_thread(thread_id);
  builder_->flush();
}

} // namespace w1rewind

```

`src/tracers/w1rewind/engine/trace_emitter.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include <string>
#include <vector>

#include "config/rewind_config.hpp"
#include "thread/memory_access_builder.hpp"
#include "thread/snapshot_builder.hpp"
#include "w1rewind/record/trace_builder.hpp"

namespace w1rewind {

struct pending_instruction {
  uint64_t thread_id = 0;
  uint64_t address = 0;
  uint32_t size = 0;
  uint32_t flags = 0;
  std::vector<w1::rewind::register_delta> register_deltas;
  std::vector<pending_memory_access> memory_accesses;
  std::optional<pending_snapshot> snapshot;
};

class trace_emitter {
public:
  trace_emitter(w1::rewind::trace_builder* builder, const rewind_config& config, bool instruction_flow);

  bool begin_thread(uint64_t thread_id, const std::string& name);
  bool emit_block(uint64_t thread_id, uint64_t address, uint32_t size, uint32_t flags, uint64_t& sequence_out);
  void flush_pending(std::optional<pending_instruction>& pending);
  void finalize_thread(uint64_t thread_id, const std::string& name);

private:
  w1::rewind::trace_builder* builder_ = nullptr;
  const rewind_config* config_ = nullptr;
  bool instruction_flow_ = false;
};

} // namespace w1rewind

```

`src/tracers/w1rewind/entrypoints/preload.cpp`:

```cpp
#include "QBDIPreload.h"

#include "rewind_recipe.hpp"
#include "w1instrument/preload/entrypoints.hpp"

extern "C" {

QBDIPRELOAD_INIT;

QBDI_EXPORT int qbdipreload_on_run(QBDI::VMInstanceRef vm, QBDI::rword start, QBDI::rword stop) {
  return w1::instrument::preload_on_run<w1rewind::rewind_recipe>(vm, start, stop);
}

QBDI_EXPORT int qbdipreload_on_exit(int status) {
  return w1::instrument::preload_on_exit<w1rewind::rewind_recipe>(status);
}

QBDI_EXPORT int qbdipreload_on_start(void* main) {
  return w1::instrument::preload_on_start<w1rewind::rewind_recipe>(main);
}

QBDI_EXPORT int qbdipreload_on_premain(void* gpr_ctx, void* fpu_ctx) {
  return w1::instrument::preload_on_premain<w1rewind::rewind_recipe>(gpr_ctx, fpu_ctx);
}

QBDI_EXPORT int qbdipreload_on_main(int argc, char** argv) {
  return w1::instrument::preload_on_main<w1rewind::rewind_recipe>(argc, argv);
}

} // extern "C"

```

`src/tracers/w1rewind/rewind_recipe.hpp`:

```hpp
#pragma once

#include <string>

#include "QBDIPreload.h"
#include <QBDI.h>
#include <redlog.hpp>

#if defined(_WIN32) || defined(WIN32)
#include <w1base/windows_console.hpp>
#endif

#include "config/rewind_config.hpp"
#include "runtime/rewind_runtime.hpp"
#include "w1instrument/logging.hpp"
#include "w1instrument/self_exclude.hpp"

namespace w1rewind {
namespace {

using flow_mode = rewind_config::flow_options::flow_mode;

const char* flow_name(flow_mode mode) {
  switch (mode) {
  case rewind_config::flow_options::flow_mode::instruction:
    return "instruction";
  case rewind_config::flow_options::flow_mode::block:
  default:
    return "block";
  }
}

const char* memory_access_name(rewind_config::memory_access access) {
  switch (access) {
  case rewind_config::memory_access::reads:
    return "reads";
  case rewind_config::memory_access::writes:
    return "writes";
  case rewind_config::memory_access::reads_writes:
    return "reads_writes";
  case rewind_config::memory_access::none:
  default:
    return "none";
  }
}

bool has_filter(const std::vector<rewind_config::memory_filter_kind>& filters, rewind_config::memory_filter_kind kind) {
  for (const auto& entry : filters) {
    if (entry == kind) {
      return true;
    }
  }
  return false;
}

} // namespace

struct rewind_recipe {
  using config_t = rewind_config;
  using runtime_t = rewind_process_runtime_any;

  static config_t load_config() {
    std::string error;
    auto config = config_t::from_environment(error);
    if (!error.empty()) {
      auto log = redlog::get_logger("w1rewind.preload");
      log.err("invalid rewind config", redlog::field("error", error));
    }
    return config;
  }

  static void configure_logging(const config_t& config) {
    w1::instrument::configure_redlog_verbosity(config.common.verbose, true);
  }

  static void apply_self_excludes(config_t& config, const void* anchor) {
    if (config.common.exclude_self) {
      w1::util::append_self_excludes(config.common.instrumentation, anchor);
    }
  }

  static void log_config(const config_t& config) {
    auto log = redlog::get_logger("w1rewind.preload");
    const char* threads = config.threads == w1::instrument::config::thread_attach_policy::auto_attach ? "auto" : "main";
    log.inf(
        "qbdipreload_on_run configured", redlog::field("flow", flow_name(config.flow.mode)),
        redlog::field("output", config.output_path.empty() ? "default" : config.output_path),
        redlog::field("threads", threads), redlog::field("memory", memory_access_name(config.memory.access)),
        redlog::field("reg_deltas", config.registers.deltas),
        redlog::field("snapshots", config.registers.snapshot_interval),
        redlog::field("stack_snapshots", config.stack_snapshots.interval)
    );

    if (config.memory.access != rewind_config::memory_access::none && !config.memory.values) {
      log.wrn("memory values disabled; replayable memory state will be incomplete");
    }
    if (!config.memory.ranges.empty() &&
        !has_filter(config.memory.filters, rewind_config::memory_filter_kind::ranges)) {
      log.wrn("memory ranges configured but ranges filter not enabled");
    }
  }

  static runtime_t make_runtime(const config_t& config) { return make_process_runtime(config); }

  static bool run_main(runtime_t& runtime, QBDI::VM* vm, uint64_t start, uint64_t stop) {
    return with_runtime(runtime, [&](auto& active) { return active.run_main(vm, start, stop); });
  }

  static void on_exit(runtime_t& runtime, const config_t& config, int status) {
    auto log = redlog::get_logger("w1rewind.preload");
    log.inf("qbdipreload_on_exit called", redlog::field("status", status));

    with_runtime(runtime, [&](auto& active) {
      active.stop();
      if (!active.export_output()) {
        log.err("trace export failed", redlog::field("output", config.output_path));
      } else {
        const std::string output = config.output_path.empty() ? active.engine().output_path() : config.output_path;
        log.inf("trace export completed", redlog::field("output", output));
      }
      auto& engine = active.engine();
      log.inf("trace summary", redlog::field("modules", engine.module_count()));
    });

    log.inf("qbdipreload_on_exit completed");
  }

  static int on_start(void* main) {
    (void) main;
#if defined(_WIN32) || defined(WIN32)
    w1::common::allocate_windows_console();
#endif
    return QBDIPRELOAD_NOT_HANDLED;
  }

  static int on_premain(void* gpr_ctx, void* fpu_ctx) {
    (void) gpr_ctx;
    (void) fpu_ctx;
    return QBDIPRELOAD_NOT_HANDLED;
  }

  static int on_main(int argc, char** argv) {
    (void) argc;
    (void) argv;
    return QBDIPRELOAD_NOT_HANDLED;
  }
};

} // namespace w1rewind

```

`src/tracers/w1rewind/runtime/rewind_runtime.hpp`:

```hpp
#pragma once

#include <memory>
#include <utility>
#include <variant>

#include "config/rewind_config.hpp"
#include "engine/rewind_engine.hpp"
#include "thread/rewind_thread_tracer.hpp"
#include "w1instrument/tracer/runtime.hpp"

namespace w1rewind {

template <rewind_flow Mode, bool CaptureMemory> struct rewind_traits {
  using tracer_type = rewind_thread_tracer<Mode, CaptureMemory>;
  using process_config = typename w1::instrument::process_session<tracer_type>::config;

  static process_config make_process_config(const rewind_config& config, bool owns_observer) {
    process_config tracer_config{};
    tracer_config.instrumentation = config.common.instrumentation;
    tracer_config.attach_new_threads = config.threads == w1::instrument::config::thread_attach_policy::auto_attach;
    tracer_config.refresh_on_module_events = true;
    tracer_config.owns_observer = owns_observer;
    return tracer_config;
  }

  static w1::instrument::thread_session_config make_thread_config(const rewind_config& config) {
    w1::instrument::thread_session_config session_config{};
    session_config.instrumentation = config.common.instrumentation;
    return session_config;
  }

  static tracer_type make_tracer(
      std::shared_ptr<rewind_engine> engine, const rewind_config& config, const w1::runtime::thread_info&
  ) {
    return tracer_type(std::move(engine), config);
  }

  static tracer_type make_tracer(std::shared_ptr<rewind_engine> engine, const rewind_config& config) {
    return tracer_type(std::move(engine), config);
  }

  static void configure_engine(rewind_engine& engine, w1::runtime::module_catalog& modules) {
    engine.configure(modules);
  }

  static bool export_output(rewind_engine& engine) { return engine.export_trace(); }

  static void configure_session(
      w1::instrument::process_session<tracer_type>& session, rewind_engine& engine, const rewind_config&
  ) {
    session.set_on_event([eng = &engine](const w1::runtime::process_event& event) { eng->on_process_event(event); });
  }
};

template <rewind_flow Mode, bool CaptureMemory>
using rewind_process_runtime = w1::instrument::tracer_runtime<
    rewind_engine, rewind_thread_tracer<Mode, CaptureMemory>, rewind_config, rewind_traits<Mode, CaptureMemory>>;

template <rewind_flow Mode, bool CaptureMemory>
using rewind_thread_runtime = w1::instrument::thread_runtime<
    rewind_engine, rewind_thread_tracer<Mode, CaptureMemory>, rewind_config, rewind_traits<Mode, CaptureMemory>>;

using rewind_process_runtime_any = std::variant<
    std::unique_ptr<rewind_process_runtime<rewind_flow::instruction, true>>,
    std::unique_ptr<rewind_process_runtime<rewind_flow::instruction, false>>,
    std::unique_ptr<rewind_process_runtime<rewind_flow::block, false>>>;

using rewind_thread_runtime_any = std::variant<
    std::unique_ptr<rewind_thread_runtime<rewind_flow::instruction, true>>,
    std::unique_ptr<rewind_thread_runtime<rewind_flow::instruction, false>>,
    std::unique_ptr<rewind_thread_runtime<rewind_flow::block, false>>>;

inline rewind_process_runtime_any make_process_runtime(rewind_config config) {
  if (config.flow.mode == rewind_config::flow_options::flow_mode::instruction) {
    if (config.memory.access != rewind_config::memory_access::none) {
      return rewind_process_runtime_any{
          std::make_unique<rewind_process_runtime<rewind_flow::instruction, true>>(std::move(config))
      };
    }
    return rewind_process_runtime_any{
        std::make_unique<rewind_process_runtime<rewind_flow::instruction, false>>(std::move(config))
    };
  }
  return rewind_process_runtime_any{
      std::make_unique<rewind_process_runtime<rewind_flow::block, false>>(std::move(config))
  };
}

inline rewind_thread_runtime_any make_thread_runtime(rewind_config config) {
  if (config.flow.mode == rewind_config::flow_options::flow_mode::instruction) {
    if (config.memory.access != rewind_config::memory_access::none) {
      return rewind_thread_runtime_any{
          std::make_unique<rewind_thread_runtime<rewind_flow::instruction, true>>(std::move(config))
      };
    }
    return rewind_thread_runtime_any{
        std::make_unique<rewind_thread_runtime<rewind_flow::instruction, false>>(std::move(config))
    };
  }
  return rewind_thread_runtime_any{
      std::make_unique<rewind_thread_runtime<rewind_flow::block, false>>(std::move(config))
  };
}

template <typename Variant, typename Fn> decltype(auto) with_runtime(Variant& runtime, Fn&& fn) {
  return std::visit([&](auto& ptr) -> decltype(auto) { return fn(*ptr); }, runtime);
}

template <typename Variant, typename Fn> decltype(auto) with_runtime(const Variant& runtime, Fn&& fn) {
  return std::visit([&](const auto& ptr) -> decltype(auto) { return fn(*ptr); }, runtime);
}

} // namespace w1rewind

```

`src/tracers/w1rewind/thread/memory_access_builder.cpp`:

```cpp
#include "memory_access_builder.hpp"

#include <algorithm>
#include <array>
#include <limits>

#include "w1runtime/memory_reader.hpp"

namespace w1rewind {

void append_memory_access(
    const rewind_config& config, w1::trace_context& ctx, const w1::memory_event& event,
    w1::rewind::memory_access_kind kind, std::span<const w1::address_range> segments,
    std::vector<pending_memory_access>& out, uint64_t& memory_events
) {
  if (segments.empty()) {
    return;
  }

  bool capture_values = config.memory.values && config.memory.max_value_bytes > 0;
  uint32_t max_bytes = config.memory.max_value_bytes;
  std::array<uint8_t, 8> value_bytes{};
  bool have_value_bytes = false;

  if (capture_values && event.value_valid) {
    uint64_t value = event.value;
    for (size_t i = 0; i < value_bytes.size(); ++i) {
      value_bytes[i] = static_cast<uint8_t>((value >> (8 * i)) & 0xFF);
    }
    have_value_bytes = true;
  }

  for (const auto& segment : segments) {
    if (segment.end <= segment.start) {
      continue;
    }
    uint64_t seg_size_u64 = segment.end - segment.start;
    if (seg_size_u64 > std::numeric_limits<uint32_t>::max()) {
      continue;
    }
    uint32_t seg_size = static_cast<uint32_t>(seg_size_u64);

    pending_memory_access record{};
    record.kind = kind;
    record.address = segment.start;
    record.size = seg_size;

    if (capture_values && seg_size > 0) {
      uint32_t capture_size = std::min(seg_size, max_bytes);
      if (capture_size > 0) {
        if (segment.start < event.address) {
          continue;
        }
        uint64_t offset = segment.start - event.address;
        if (have_value_bytes && (offset + capture_size) <= value_bytes.size()) {
          record.data.assign(
              value_bytes.begin() + static_cast<std::ptrdiff_t>(offset),
              value_bytes.begin() + static_cast<std::ptrdiff_t>(offset + capture_size)
          );
          record.value_known = true;
        } else {
          auto bytes = ctx.memory().read_bytes(segment.start, capture_size);
          if (bytes.has_value()) {
            record.data = std::move(*bytes);
            record.value_known = true;
          }
        }
        record.value_truncated = seg_size > capture_size;
      }
    }

    out.push_back(std::move(record));
    memory_events += 1;
  }
}

} // namespace w1rewind

```

`src/tracers/w1rewind/thread/memory_access_builder.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <span>
#include <vector>

#include "config/rewind_config.hpp"
#include "w1base/types.hpp"
#include "w1instrument/tracer/trace_context.hpp"
#include "w1instrument/tracer/types.hpp"
#include "w1rewind/format/trace_format.hpp"

namespace w1rewind {

struct pending_memory_access {
  w1::rewind::memory_access_kind kind = w1::rewind::memory_access_kind::read;
  uint64_t address = 0;
  uint32_t size = 0;
  bool value_known = false;
  bool value_truncated = false;
  std::vector<uint8_t> data;
};

void append_memory_access(
    const rewind_config& config, w1::trace_context& ctx, const w1::memory_event& event,
    w1::rewind::memory_access_kind kind, std::span<const w1::address_range> segments,
    std::vector<pending_memory_access>& out, uint64_t& memory_events
);

} // namespace w1rewind

```

`src/tracers/w1rewind/thread/memory_filter.cpp`:

```cpp
#include "memory_filter.hpp"

#include <algorithm>
#include <limits>

namespace w1rewind {
namespace {

uint64_t range_end(uint64_t start, uint64_t size) {
  uint64_t end = start + size;
  if (end < start) {
    return std::numeric_limits<uint64_t>::max();
  }
  return end;
}

void merge_ranges(std::vector<w1::address_range>& ranges) {
  if (ranges.empty()) {
    return;
  }
  std::sort(ranges.begin(), ranges.end(), [](const auto& left, const auto& right) { return left.start < right.start; });

  std::vector<w1::address_range> merged;
  merged.reserve(ranges.size());
  w1::address_range current = ranges.front();

  for (size_t i = 1; i < ranges.size(); ++i) {
    const auto& next = ranges[i];
    if (next.start > current.end) {
      merged.push_back(current);
      current = next;
      continue;
    }
    current.end = std::max(current.end, next.end);
  }

  merged.push_back(current);
  ranges.swap(merged);
}

} // namespace

memory_filter::memory_filter(const rewind_config::memory_options& options) : ranges_(options.ranges) {
  match_all_ = false;
  use_ranges_ = false;
  use_stack_window_ = false;

  if (options.filters.empty()) {
    match_all_ = true;
  } else {
    for (const auto& filter : options.filters) {
      switch (filter) {
      case rewind_config::memory_filter_kind::all:
        match_all_ = true;
        break;
      case rewind_config::memory_filter_kind::ranges:
        use_ranges_ = true;
        break;
      case rewind_config::memory_filter_kind::stack_window:
        use_stack_window_ = true;
        break;
      default:
        break;
      }
    }
  }

  if (match_all_) {
    use_ranges_ = false;
    use_stack_window_ = false;
  } else if (use_ranges_) {
    merge_ranges(ranges_);
  }
}

std::vector<w1::address_range> memory_filter::filter(
    uint64_t address, uint32_t size, std::span<const stack_window_segment> stack_segments
) const {
  std::vector<w1::address_range> out;
  if (size == 0) {
    return out;
  }

  uint64_t end = range_end(address, size);
  w1::address_range event{address, end};

  if (match_all_) {
    out.push_back(event);
    return out;
  }

  std::vector<w1::address_range> selectors;
  if (use_ranges_) {
    selectors.insert(selectors.end(), ranges_.begin(), ranges_.end());
  }
  if (use_stack_window_) {
    selectors.reserve(selectors.size() + stack_segments.size());
    for (const auto& segment : stack_segments) {
      if (segment.size == 0) {
        continue;
      }
      selectors.push_back(w1::address_range{segment.base, range_end(segment.base, segment.size)});
    }
  }

  if (selectors.empty()) {
    return out;
  }

  std::vector<w1::address_range> intersections;
  intersections.reserve(selectors.size());
  for (const auto& range : selectors) {
    uint64_t start = std::max(event.start, range.start);
    uint64_t stop = std::min(event.end, range.end);
    if (start < stop) {
      intersections.push_back(w1::address_range{start, stop});
    }
  }

  if (intersections.empty()) {
    return out;
  }

  merge_ranges(intersections);
  return intersections;
}

} // namespace w1rewind

```

`src/tracers/w1rewind/thread/memory_filter.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <span>
#include <vector>

#include "config/rewind_config.hpp"
#include "stack_window_policy.hpp"
#include "w1base/types.hpp"

namespace w1rewind {

class memory_filter {
public:
  explicit memory_filter(const rewind_config::memory_options& options);

  bool matches_all() const { return match_all_; }
  bool uses_ranges() const { return use_ranges_; }
  bool uses_stack_window() const { return use_stack_window_; }
  const std::vector<w1::address_range>& ranges() const { return ranges_; }

  std::vector<w1::address_range> filter(
      uint64_t address, uint32_t size, std::span<const stack_window_segment> stack_segments
  ) const;

private:
  bool match_all_ = true;
  bool use_ranges_ = false;
  bool use_stack_window_ = false;
  std::vector<w1::address_range> ranges_{};
};

} // namespace w1rewind

```

`src/tracers/w1rewind/thread/register_delta_builder.cpp`:

```cpp
#include "register_delta_builder.hpp"

namespace w1rewind {

std::vector<w1::rewind::register_delta> capture_register_deltas(
    const register_schema& schema, const w1::util::register_state& regs,
    std::optional<w1::util::register_state>& last_regs
) {
  const auto& current = regs.get_register_map();
  const auto* previous = last_regs ? &last_regs->get_register_map() : nullptr;

  std::vector<w1::rewind::register_delta> out;
  const auto& names = schema.names();
  out.reserve(names.size());

  for (size_t i = 0; i < names.size(); ++i) {
    const auto& name = names[i];
    auto current_it = current.find(name);
    if (current_it == current.end()) {
      continue;
    }
    bool changed = true;
    if (previous) {
      auto previous_it = previous->find(name);
      if (previous_it != previous->end() && previous_it->second == current_it->second) {
        changed = false;
      }
    }
    if (!changed) {
      continue;
    }

    w1::rewind::register_delta delta{};
    delta.reg_id = static_cast<uint16_t>(i);
    delta.value = current_it->second;
    out.push_back(delta);
  }

  last_regs = regs;
  return out;
}

std::vector<w1::rewind::register_delta> capture_register_snapshot(
    const register_schema& schema, const w1::util::register_state& regs
) {
  std::vector<w1::rewind::register_delta> out;
  const auto& current = regs.get_register_map();
  const auto& names = schema.names();
  out.reserve(names.size());

  for (size_t i = 0; i < names.size(); ++i) {
    const auto& name = names[i];
    auto current_it = current.find(name);
    if (current_it == current.end()) {
      continue;
    }

    w1::rewind::register_delta delta{};
    delta.reg_id = static_cast<uint16_t>(i);
    delta.value = current_it->second;
    out.push_back(delta);
  }

  return out;
}

} // namespace w1rewind

```

`src/tracers/w1rewind/thread/register_delta_builder.hpp`:

```hpp
#pragma once

#include <optional>
#include <vector>

#include "engine/register_schema.hpp"
#include "w1runtime/register_capture.hpp"
#include "w1rewind/format/trace_format.hpp"

namespace w1rewind {

std::vector<w1::rewind::register_delta> capture_register_deltas(
    const register_schema& schema, const w1::util::register_state& regs,
    std::optional<w1::util::register_state>& last_regs
);

std::vector<w1::rewind::register_delta> capture_register_snapshot(
    const register_schema& schema, const w1::util::register_state& regs
);

} // namespace w1rewind

```

`src/tracers/w1rewind/thread/rewind_thread_tracer.cpp`:

```cpp
#include "rewind_thread_tracer.hpp"

#include <optional>
#include <utility>

#include "thread/memory_access_builder.hpp"
#include "thread/register_delta_builder.hpp"
#include "thread/snapshot_builder.hpp"
#include "thread/stack_window_policy.hpp"

namespace w1rewind {
namespace {

std::optional<w1::util::register_state> capture_registers(const QBDI::GPRState* gpr) {
  if (!gpr) {
    return std::nullopt;
  }
  return w1::util::register_capturer::capture(gpr);
}

w1::instruction_event patch_instruction_event(const w1::instruction_event& event, QBDI::VMInstanceRef vm) {
  w1::instruction_event adjusted = event;
  if ((adjusted.address == 0 || adjusted.size == 0) && vm) {
    if (const auto* analysis = vm->getInstAnalysis(QBDI::ANALYSIS_INSTRUCTION)) {
      adjusted.address = analysis->address;
      adjusted.size = analysis->instSize;
    }
  }
  return adjusted;
}

uint32_t apply_arm_thumb_flags(
    const w1::util::register_state* regs, const w1::arch::arch_spec& arch, uint32_t flags, uint32_t valid_flag,
    uint32_t thumb_flag
) {
  if (!regs) {
    return flags;
  }
  if (arch.arch_family != w1::arch::family::arm) {
    return flags;
  }
  if (arch.arch_mode != w1::arch::mode::arm && arch.arch_mode != w1::arch::mode::thumb) {
    return flags;
  }

  uint64_t cpsr = 0;
  if (!regs->get_register("cpsr", cpsr)) {
    return flags;
  }
  flags |= valid_flag;
  if (((cpsr >> 5) & 1U) != 0) {
    flags |= thumb_flag;
  }
  return flags;
}

} // namespace

template <rewind_flow Mode, bool CaptureMemory>
rewind_thread_tracer<Mode, CaptureMemory>::rewind_thread_tracer(
    std::shared_ptr<rewind_engine> engine, const rewind_config& config
)
    : engine_(std::move(engine)), config_(config), memory_filter_(config_.memory),
      log_(redlog::get_logger("w1rewind.thread")) {}

template <rewind_flow Mode, bool CaptureMemory>
rewind_thread_tracer<Mode, CaptureMemory>::rewind_thread_tracer(
    std::shared_ptr<rewind_engine> engine, const rewind_config& config, const w1::runtime::thread_info&
)
    : rewind_thread_tracer(std::move(engine), config) {}

template <rewind_flow Mode, bool CaptureMemory>
void rewind_thread_tracer<Mode, CaptureMemory>::on_thread_start(w1::trace_context& ctx, const w1::thread_event& event) {
  (void) ctx;
  state_ = thread_state{};
  state_.thread_id = event.thread_id;
  if (event.name && *event.name != '\0') {
    state_.name = event.name;
  } else {
    state_.name = "thread";
  }
}

template <rewind_flow Mode, bool CaptureMemory>
void rewind_thread_tracer<Mode, CaptureMemory>::on_thread_stop(w1::trace_context& ctx, const w1::thread_event& event) {
  (void) ctx;

  if (state_.thread_id == 0) {
    state_.thread_id = event.thread_id;
  }
  if (state_.name.empty() && event.name) {
    state_.name = event.name;
  }
  if (state_.name.empty()) {
    state_.name = "thread";
  }

  if (engine_ && engine_->trace_ready()) {
    engine_->finalize_thread(state_.thread_id, state_.name.empty() ? "thread" : state_.name, state_.pending);
  }

  log_.inf(
      "rewind stats", redlog::field("thread_id", state_.thread_id),
      redlog::field("flow_kind", Mode == rewind_flow::instruction ? "instructions" : "blocks"),
      redlog::field("flow_events", state_.flow_count), redlog::field("snapshots", state_.snapshot_state.snapshot_count),
      redlog::field("memory_events", state_.memory_events)
  );
}

template <rewind_flow Mode, bool CaptureMemory>
void rewind_thread_tracer<Mode, CaptureMemory>::on_basic_block_entry(
    w1::trace_context& ctx, const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  (void) vm;
  (void) state;
  (void) fpr;

  if constexpr (Mode != rewind_flow::block) {
    return;
  }

  if (event.address == 0 || event.size == 0) {
    return;
  }

  if (state_.thread_id == 0) {
    state_.thread_id = event.thread_id;
  }

  std::optional<w1::util::register_state> regs;
  const bool need_regs = should_capture_registers();
  if (need_regs) {
    regs = capture_registers(gpr);
  }

  if (!ensure_trace_ready(ctx, regs)) {
    return;
  }

  if (engine_ && !engine_->begin_thread(state_.thread_id, state_.name)) {
    return;
  }

  const uint32_t flags = apply_arm_thumb_flags(
      regs ? &*regs : nullptr, engine_->arch_spec(), 0, w1::rewind::trace_block_flag_mode_valid,
      w1::rewind::trace_block_flag_thumb
  );

  uint64_t sequence = 0;
  if (!engine_->emit_block(state_.thread_id, event.address, event.size, flags, sequence)) {
    return;
  }

  state_.flow_count += 1;

  if ((config_.registers.snapshot_interval > 0 || config_.stack_snapshots.interval > 0) && regs.has_value()) {
    auto snapshot = maybe_capture_snapshot(ctx, *regs, engine_->schema(), config_, state_.snapshot_state, log_);
    if (snapshot.has_value()) {
      engine_->emit_snapshot(
          state_.thread_id, sequence, snapshot->snapshot_id, snapshot->registers, snapshot->stack_segments,
          std::move(snapshot->reason)
      );
    }
  }
}

template <rewind_flow Mode, bool CaptureMemory>
void rewind_thread_tracer<Mode, CaptureMemory>::on_instruction_post(
    w1::trace_context& ctx, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  (void) fpr;

  if constexpr (Mode != rewind_flow::instruction) {
    return;
  }

  auto adjusted = patch_instruction_event(event, vm);
  if (adjusted.address == 0) {
    return;
  }
  if (adjusted.size == 0) {
    adjusted.size = 1;
  }

  if (state_.thread_id == 0) {
    state_.thread_id = adjusted.thread_id;
  }

  std::optional<w1::util::register_state> regs;
  const bool need_regs = should_capture_registers() || !engine_ || !engine_->trace_ready();
  if (need_regs) {
    regs = capture_registers(gpr);
  }

  if (!ensure_trace_ready(ctx, regs)) {
    return;
  }

  if (engine_ && !engine_->begin_thread(state_.thread_id, state_.name)) {
    return;
  }

  if (engine_) {
    engine_->flush_pending(state_.pending);
  }

  pending_instruction pending{};
  pending.thread_id = state_.thread_id;
  pending.address = adjusted.address;
  pending.size = adjusted.size;
  pending.flags = apply_arm_thumb_flags(
      regs ? &*regs : nullptr, engine_->arch_spec(), 0, w1::rewind::trace_inst_flag_mode_valid,
      w1::rewind::trace_inst_flag_thumb
  );

  if (config_.registers.deltas && regs.has_value()) {
    pending.register_deltas = capture_register_deltas(engine_->schema(), *regs, state_.last_registers);
  }

  state_.flow_count += 1;
  if ((config_.registers.snapshot_interval > 0 || config_.stack_snapshots.interval > 0) && regs.has_value()) {
    auto snapshot = maybe_capture_snapshot(ctx, *regs, engine_->schema(), config_, state_.snapshot_state, log_);
    if (snapshot.has_value()) {
      pending.snapshot = std::move(snapshot);
    }
  }

  state_.pending = std::move(pending);
}

template <rewind_flow Mode, bool CaptureMemory>
void rewind_thread_tracer<Mode, CaptureMemory>::on_memory(
    w1::trace_context& ctx, const w1::memory_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  (void) vm;
  (void) fpr;

  if constexpr (!CaptureMemory) {
    return;
  }
  if constexpr (Mode != rewind_flow::instruction) {
    return;
  }

  if (config_.memory.access == rewind_config::memory_access::none) {
    return;
  }

  if (!state_.pending.has_value()) {
    return;
  }

  if (event.size == 0) {
    return;
  }

  std::optional<w1::util::register_state> regs;
  if (memory_filter_.uses_stack_window()) {
    regs = capture_registers(gpr);
    if (!regs.has_value()) {
      log_.err("missing register state for stack window filtering");
      return;
    }
  }

  std::vector<stack_window_segment> stack_segments;
  if (memory_filter_.uses_stack_window()) {
    auto window = compute_stack_window_segments(*regs, config_.stack_window);
    if (window.frame_window_missing && !state_.snapshot_state.warned_missing_frame) {
      log_.wrn("frame pointer not available; stack window will use SP-only segments");
      state_.snapshot_state.warned_missing_frame = true;
    }
    stack_segments = std::move(window.segments);
  }

  auto segments = memory_filter_.filter(event.address, event.size, stack_segments);
  if (segments.empty()) {
    return;
  }

  bool capture_reads = config_.memory.access == rewind_config::memory_access::reads ||
                       config_.memory.access == rewind_config::memory_access::reads_writes;
  bool capture_writes = config_.memory.access == rewind_config::memory_access::writes ||
                        config_.memory.access == rewind_config::memory_access::reads_writes;

  if (event.is_read && capture_reads) {
    append_memory_access(
        config_, ctx, event, w1::rewind::memory_access_kind::read, segments, state_.pending->memory_accesses,
        state_.memory_events
    );
  }
  if (event.is_write && capture_writes) {
    append_memory_access(
        config_, ctx, event, w1::rewind::memory_access_kind::write, segments, state_.pending->memory_accesses,
        state_.memory_events
    );
  }
}

template <rewind_flow Mode, bool CaptureMemory>
bool rewind_thread_tracer<Mode, CaptureMemory>::ensure_trace_ready(
    w1::trace_context& ctx, const std::optional<w1::util::register_state>& regs
) {
  if (!engine_) {
    return false;
  }
  if (engine_->trace_ready()) {
    return true;
  }
  if (!regs.has_value()) {
    log_.err("missing register state for trace start");
    return false;
  }
  return engine_->ensure_trace_ready(ctx, *regs);
}

template <rewind_flow Mode, bool CaptureMemory>
bool rewind_thread_tracer<Mode, CaptureMemory>::should_capture_registers() const {
  if (!engine_) {
    return true;
  }
  if (!engine_->trace_ready()) {
    return true;
  }
  if (uses_arm_flags()) {
    return true;
  }
  if (config_.registers.deltas || config_.registers.snapshot_interval > 0 || config_.stack_snapshots.interval > 0) {
    return true;
  }
  return false;
}

template <rewind_flow Mode, bool CaptureMemory> bool rewind_thread_tracer<Mode, CaptureMemory>::uses_arm_flags() const {
  if (!engine_) {
    return false;
  }
  return engine_->arch_spec().arch_family == w1::arch::family::arm;
}

template class rewind_thread_tracer<rewind_flow::instruction, true>;
template class rewind_thread_tracer<rewind_flow::instruction, false>;
template class rewind_thread_tracer<rewind_flow::block, false>;

} // namespace w1rewind

```

`src/tracers/w1rewind/thread/rewind_thread_tracer.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <memory>
#include <optional>
#include <string>

#include <QBDI.h>
#include <redlog.hpp>

#include "config/rewind_config.hpp"
#include "engine/rewind_engine.hpp"
#include "thread/memory_filter.hpp"
#include "w1instrument/tracer/event.hpp"
#include "w1instrument/tracer/trace_context.hpp"
#include "w1instrument/tracer/types.hpp"
#include "w1runtime/register_capture.hpp"

namespace w1::runtime {
struct thread_info;
}

namespace w1rewind {

enum class rewind_flow { instruction, block };

template <rewind_flow Mode, bool CaptureMemory> class rewind_thread_tracer {
public:
  explicit rewind_thread_tracer(std::shared_ptr<rewind_engine> engine, const rewind_config& config);
  rewind_thread_tracer(
      std::shared_ptr<rewind_engine> engine, const rewind_config& config, const w1::runtime::thread_info&
  );

  const char* name() const { return "w1rewind"; }

  static constexpr w1::event_mask requested_events() {
    using w1::event_kind;
    w1::event_mask mask =
        w1::event_mask_or(w1::event_mask_of(event_kind::thread_start), w1::event_mask_of(event_kind::thread_stop));

    if constexpr (Mode == rewind_flow::instruction) {
      mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::instruction_post));
      if constexpr (CaptureMemory) {
        mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::memory_read));
        mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::memory_write));
      }
    } else {
      mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::basic_block_entry));
    }

    return mask;
  }

  void on_thread_start(w1::trace_context& ctx, const w1::thread_event& event);
  void on_thread_stop(w1::trace_context& ctx, const w1::thread_event& event);

  void on_basic_block_entry(
      w1::trace_context& ctx, const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );
  void on_instruction_post(
      w1::trace_context& ctx, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );
  void on_memory(
      w1::trace_context& ctx, const w1::memory_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );

private:
  struct thread_state {
    uint64_t thread_id = 0;
    std::string name;
    uint64_t flow_count = 0;
    uint64_t memory_events = 0;
    snapshot_state snapshot_state{};
    std::optional<w1::util::register_state> last_registers;
    std::optional<pending_instruction> pending;
  };

  bool ensure_trace_ready(w1::trace_context& ctx, const std::optional<w1::util::register_state>& regs);
  bool should_capture_registers() const;
  bool uses_arm_flags() const;

  thread_state state_{};
  std::shared_ptr<rewind_engine> engine_{};
  rewind_config config_{};
  memory_filter memory_filter_;
  redlog::logger log_;
};

} // namespace w1rewind

```

`src/tracers/w1rewind/thread/snapshot_builder.cpp`:

```cpp
#include "snapshot_builder.hpp"

#include "register_delta_builder.hpp"
#include "stack_window_policy.hpp"
#include "w1runtime/memory_reader.hpp"

namespace w1rewind {

namespace {

std::vector<w1::rewind::stack_segment> capture_stack_segments(
    w1::trace_context& ctx, const w1::util::register_state& regs, const rewind_config& config, snapshot_state& state,
    redlog::logger log
) {
  std::vector<w1::rewind::stack_segment> out;
  if (config.stack_snapshots.interval == 0 ||
      config.stack_window.mode == rewind_config::stack_window_options::window_mode::none) {
    return out;
  }
  if (regs.get_register_map().empty()) {
    return out;
  }

  auto window = compute_stack_window_segments(regs, config.stack_window);
  if (window.frame_window_missing && !state.warned_missing_frame) {
    log.wrn("frame pointer not available; stack snapshot will use SP-only segments");
    state.warned_missing_frame = true;
  }

  out.reserve(window.segments.size());
  for (const auto& segment : window.segments) {
    if (segment.size == 0) {
      continue;
    }
    auto bytes = ctx.memory().read_bytes(segment.base, static_cast<size_t>(segment.size));
    if (!bytes.has_value()) {
      continue;
    }
    w1::rewind::stack_segment record{};
    record.base = segment.base;
    record.size = segment.size;
    record.bytes = std::move(*bytes);
    out.push_back(std::move(record));
  }

  return out;
}

} // namespace

std::optional<pending_snapshot> maybe_capture_snapshot(
    w1::trace_context& ctx, const w1::util::register_state& regs, const register_schema& schema,
    const rewind_config& config, snapshot_state& state, redlog::logger log
) {
  bool want_register_snapshot = config.registers.snapshot_interval > 0;
  bool want_stack_snapshot = config.stack_snapshots.interval > 0;

  bool register_due = false;
  bool stack_due = false;

  if (want_register_snapshot) {
    state.flow_since_register_snapshot += 1;
    if (state.flow_since_register_snapshot >= config.registers.snapshot_interval) {
      state.flow_since_register_snapshot = 0;
      register_due = true;
    }
  }

  if (want_stack_snapshot) {
    state.flow_since_stack_snapshot += 1;
    if (state.flow_since_stack_snapshot >= config.stack_snapshots.interval) {
      state.flow_since_stack_snapshot = 0;
      stack_due = true;
    }
  }

  if (!register_due && !stack_due) {
    return std::nullopt;
  }

  pending_snapshot snapshot{};
  snapshot.snapshot_id = state.snapshot_count++;
  if (register_due) {
    snapshot.registers = capture_register_snapshot(schema, regs);
  }
  if (stack_due) {
    snapshot.stack_segments = capture_stack_segments(ctx, regs, config, state, log);
  }
  snapshot.reason = "interval";
  return snapshot;
}

} // namespace w1rewind

```

`src/tracers/w1rewind/thread/snapshot_builder.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include <string>
#include <vector>

#include <redlog.hpp>

#include "engine/register_schema.hpp"
#include "config/rewind_config.hpp"
#include "w1instrument/tracer/trace_context.hpp"
#include "w1runtime/register_capture.hpp"
#include "w1rewind/format/trace_format.hpp"

namespace w1rewind {

struct pending_snapshot {
  uint64_t snapshot_id = 0;
  std::vector<w1::rewind::register_delta> registers;
  std::vector<w1::rewind::stack_segment> stack_segments;
  std::string reason;
};

struct snapshot_state {
  uint64_t snapshot_count = 0;
  uint64_t flow_since_register_snapshot = 0;
  uint64_t flow_since_stack_snapshot = 0;
  bool warned_missing_frame = false;
};

std::optional<pending_snapshot> maybe_capture_snapshot(
    w1::trace_context& ctx, const w1::util::register_state& regs, const register_schema& schema,
    const rewind_config& config, snapshot_state& state, redlog::logger log
);

} // namespace w1rewind

```

`src/tracers/w1rewind/thread/stack_window_policy.cpp`:

```cpp
#include "stack_window_policy.hpp"

#include <algorithm>
#include <limits>

namespace w1rewind {
namespace {

struct sp_window {
  uint64_t base = 0;
  uint64_t size = 0;
  uint64_t below = 0;
  uint64_t above = 0;
};

sp_window compute_sp_window(uint64_t sp, uint64_t above, uint64_t below) {
  sp_window window{};
  if (sp == 0) {
    return window;
  }
  uint64_t clamped_below = below;
  if (sp < clamped_below) {
    clamped_below = sp;
  }
  window.base = sp - clamped_below;
  window.size = clamped_below + above;
  window.below = clamped_below;
  window.above = above;
  return window;
}

sp_window clamp_sp_window(const sp_window& window, uint64_t max_size) {
  if (window.size == 0 || max_size == 0 || window.size <= max_size) {
    return window;
  }

  uint64_t excess = window.size - max_size;
  uint64_t new_above = window.above;
  uint64_t new_below = window.below;

  uint64_t reduce = std::min(new_above, excess);
  new_above -= reduce;
  excess -= reduce;
  if (excess > 0) {
    reduce = std::min(new_below, excess);
    new_below -= reduce;
    excess -= reduce;
  }

  sp_window clamped{};
  clamped.below = new_below;
  clamped.above = new_above;
  clamped.base = window.base + (window.below - new_below);
  clamped.size = new_below + new_above;
  return clamped;
}

uint64_t segment_end(uint64_t base, uint64_t size) {
  if (size == 0) {
    return base;
  }
  uint64_t end = base + size;
  if (end < base) {
    return std::numeric_limits<uint64_t>::max();
  }
  return end;
}

uint64_t overlap_size(const stack_window_segment& a, const stack_window_segment& b) {
  uint64_t a_end = segment_end(a.base, a.size);
  uint64_t b_end = segment_end(b.base, b.size);
  uint64_t start = std::max(a.base, b.base);
  uint64_t end = std::min(a_end, b_end);
  if (start >= end) {
    return 0;
  }
  return end - start;
}

stack_window_segment make_fp_window(const w1::util::register_state& regs, uint64_t sp, bool& valid) {
  stack_window_segment segment{};
  valid = false;
  uint64_t fp = regs.get_frame_pointer();
  if (fp == 0) {
    return segment;
  }

  switch (regs.get_architecture()) {
  case w1::util::register_state::architecture::x86_64:
    if (fp > sp) {
      segment.base = fp;
      segment.size = 16;
      valid = true;
    }
    break;
  case w1::util::register_state::architecture::x86:
    if (fp > sp) {
      segment.base = fp;
      segment.size = 8;
      valid = true;
    }
    break;
  case w1::util::register_state::architecture::aarch64:
    if (fp >= sp) {
      segment.base = fp;
      segment.size = 16;
      valid = true;
    }
    break;
  case w1::util::register_state::architecture::arm32:
    if (fp >= sp) {
      segment.base = fp;
      segment.size = 8;
      valid = true;
    }
    break;
  default:
    break;
  }

  return segment;
}

void merge_segments(std::vector<stack_window_segment>& segments) {
  if (segments.empty()) {
    return;
  }
  std::sort(segments.begin(), segments.end(), [](const auto& left, const auto& right) {
    return left.base < right.base;
  });

  std::vector<stack_window_segment> merged;
  merged.reserve(segments.size());
  stack_window_segment current = segments.front();
  uint64_t current_end = segment_end(current.base, current.size);

  for (size_t i = 1; i < segments.size(); ++i) {
    const auto& next = segments[i];
    uint64_t next_end = segment_end(next.base, next.size);
    if (next.base > current_end) {
      merged.push_back(current);
      current = next;
      current_end = next_end;
      continue;
    }

    current_end = std::max(current_end, next_end);
    current.size = current_end - current.base;
  }

  merged.push_back(current);
  segments.swap(merged);
}

} // namespace

stack_window_result compute_stack_window_segments(
    const w1::util::register_state& regs, const rewind_config::stack_window_options& options
) {
  stack_window_result result{};

  if (options.mode == rewind_config::stack_window_options::window_mode::none) {
    return result;
  }

  uint64_t sp = regs.get_stack_pointer();
  if (sp == 0) {
    return result;
  }

  sp_window sp_seg = compute_sp_window(sp, options.above_bytes, options.below_bytes);

  if (options.mode == rewind_config::stack_window_options::window_mode::fixed) {
    sp_seg = clamp_sp_window(sp_seg, options.max_total_bytes);
    if (sp_seg.size > 0) {
      result.segments.push_back(stack_window_segment{sp_seg.base, sp_seg.size});
    }
    return result;
  }

  bool fp_valid = false;
  stack_window_segment fp_seg = make_fp_window(regs, sp, fp_valid);
  if (!fp_valid) {
    result.frame_window_missing = true;
  }

  if (options.max_total_bytes > 0) {
    uint64_t max_sp_size = options.max_total_bytes;
    if (fp_valid) {
      uint64_t overlap = overlap_size(stack_window_segment{sp_seg.base, sp_seg.size}, fp_seg);
      uint64_t available = options.max_total_bytes > fp_seg.size ? options.max_total_bytes - fp_seg.size : 0;
      if (sp_seg.size > available + overlap) {
        max_sp_size = available + overlap;
      }
    }
    sp_seg = clamp_sp_window(sp_seg, max_sp_size);
  }

  if (sp_seg.size > 0) {
    result.segments.push_back(stack_window_segment{sp_seg.base, sp_seg.size});
  }
  if (fp_valid && fp_seg.size > 0) {
    result.segments.push_back(fp_seg);
  }

  merge_segments(result.segments);
  return result;
}

} // namespace w1rewind

```

`src/tracers/w1rewind/thread/stack_window_policy.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <vector>

#include "config/rewind_config.hpp"
#include "w1runtime/register_capture.hpp"

namespace w1rewind {

struct stack_window_segment {
  uint64_t base = 0;
  uint64_t size = 0;
};

struct stack_window_result {
  std::vector<stack_window_segment> segments;
  bool frame_window_missing = false;
};

stack_window_result compute_stack_window_segments(
    const w1::util::register_state& regs, const rewind_config::stack_window_options& options
);

} // namespace w1rewind

```

`src/tracers/w1script/CMakeLists.txt`:

```txt
if(WITNESS_SCRIPT)
    message(STATUS "building w1script tracer with lua support")
    w1_dep_lua()

    w1_add_tracer(w1script
        SOURCES
            entrypoints/preload.cpp
            thread/script_tracer.cpp
            runtime/lua_runtime.cpp
            runtime/callback_registry.cpp
            runtime/output_state.cpp
            runtime/script_context.cpp
            bindings/w1_bindings.cpp
            bindings/root.cpp
            bindings/util.cpp
            bindings/inst.cpp
            bindings/mem.cpp
            bindings/reg.cpp
            bindings/module.cpp
            bindings/symbol.cpp
            bindings/output.cpp
            bindings/abi.cpp
        LIBS w1analysis w1formats w1::lua
    )
else()
    message(STATUS "w1script tracer disabled (WITNESS_SCRIPT=OFF)")
endif()

```

`src/tracers/w1script/bindings/abi.cpp`:

```cpp
#include "abi.hpp"

namespace w1::tracers::script::bindings {

namespace {

std::string abi_name(w1::analysis::abi_kind kind) {
  switch (kind) {
  case w1::analysis::abi_kind::system_v_amd64:
    return "system_v_amd64";
  case w1::analysis::abi_kind::windows_amd64:
    return "windows_amd64";
  case w1::analysis::abi_kind::aarch64:
    return "aarch64";
  case w1::analysis::abi_kind::x86:
    return "x86";
  default:
    return "unknown";
  }
}

std::vector<std::string> abi_registers(w1::analysis::abi_kind kind) {
  switch (kind) {
  case w1::analysis::abi_kind::system_v_amd64:
    return {"rdi", "rsi", "rdx", "rcx", "r8", "r9"};
  case w1::analysis::abi_kind::windows_amd64:
    return {"rcx", "rdx", "r8", "r9"};
  case w1::analysis::abi_kind::aarch64:
    return {"x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7"};
  default:
    return {};
  }
}

} // namespace

void setup_abi_bindings(sol::state& lua, sol::table& w1_module, runtime::script_context& context) {
  sol::table abi = lua.create_table();

  abi.set_function("get_calling_convention", [&lua, &context]() -> sol::table {
    sol::table info = lua.create_table();
    auto kind = context.abi().kind();
    info["id"] = static_cast<int>(kind);
    info["name"] = abi_name(kind);

    sol::table regs = lua.create_table();
    auto reg_list = abi_registers(kind);
    for (size_t i = 0; i < reg_list.size(); ++i) {
      regs[i + 1] = reg_list[i];
    }
    info["argument_registers"] = regs;
    return info;
  });

  abi.set_function(
      "get_args", [&lua, &context](QBDI::VM*, QBDI::GPRState* gpr, QBDI::FPRState*, size_t count) -> sol::table {
        auto args = context.abi().extract_arguments(context.memory(), gpr, count);
        sol::table result = lua.create_table(args.size(), 0);
        for (size_t i = 0; i < args.size(); ++i) {
          sol::table entry = lua.create_table();
          entry["raw_value"] = args[i].raw_value;
          entry["from_register"] = args[i].from_register;
          entry["is_valid"] = args[i].is_valid;
          result[i + 1] = entry;
        }
        return result;
      }
  );

  abi.set_function("get_return_value", [&context](QBDI::GPRState* gpr) {
    return context.abi().extract_return_value(gpr);
  });

  w1_module["abi"] = abi;
}

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/abi.hpp`:

```hpp
#pragma once

#include "../runtime/script_context.hpp"

#include <sol/sol.hpp>

namespace w1::tracers::script::bindings {

void setup_abi_bindings(sol::state& lua, sol::table& w1_module, runtime::script_context& context);

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/inst.cpp`:

```cpp
#include "inst.hpp"

#include <QBDI.h>

namespace w1::tracers::script::bindings {

namespace {

constexpr QBDI::AnalysisType k_default_analysis = QBDI::AnalysisType::ANALYSIS_INSTRUCTION;

} // namespace

void setup_inst_bindings(sol::state& lua, sol::table& w1_module) {
  sol::table inst = lua.create_table();

  inst.set_function(
      "current", [](QBDI::VM* vm, sol::optional<QBDI::AnalysisType> analysis_type) -> const QBDI::InstAnalysis* {
        if (!vm) {
          return nullptr;
        }
        return vm->getInstAnalysis(analysis_type.value_or(k_default_analysis));
      }
  );

  inst.set_function("disasm", [](QBDI::VM* vm) -> sol::optional<std::string> {
    if (!vm) {
      return sol::nullopt;
    }
    auto analysis =
        vm->getInstAnalysis(QBDI::AnalysisType::ANALYSIS_INSTRUCTION | QBDI::AnalysisType::ANALYSIS_DISASSEMBLY);
    if (!analysis || !analysis->disassembly) {
      return sol::nullopt;
    }
    return std::string(analysis->disassembly);
  });

  w1_module["inst"] = inst;
}

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/inst.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>

namespace w1::tracers::script::bindings {

void setup_inst_bindings(sol::state& lua, sol::table& w1_module);

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/mem.cpp`:

```cpp
#include "mem.hpp"

#include <cstring>
#include <unordered_map>
#include <vector>

namespace w1::tracers::script::bindings {

void setup_mem_bindings(sol::state& lua, sol::table& w1_module, runtime::script_context& context) {
  sol::table mem = lua.create_table();

  mem.set_function("accesses", [&lua](QBDI::VM* vm) -> sol::table {
    if (!vm) {
      throw sol::error("w1.mem.accesses called with nil vm");
    }

    static std::unordered_map<QBDI::VM*, bool> recording_state;
    auto [it, inserted] = recording_state.emplace(vm, false);
    if (inserted) {
      it->second = vm->recordMemoryAccess(QBDI::MEMORY_READ_WRITE);
    }

    if (!it->second) {
      throw sol::error("memory access recording not supported on this platform");
    }

    std::vector<QBDI::MemoryAccess> accesses = vm->getInstMemoryAccess();

    sol::state_view lua_view = lua.lua_state();
    sol::table result = lua_view.create_table(accesses.size(), 0);
    for (size_t i = 0; i < accesses.size(); ++i) {
      const auto& access = accesses[i];
      sol::table entry = lua_view.create_table();

      bool is_read = (access.type & QBDI::MEMORY_READ) != 0;
      bool is_write = (access.type & QBDI::MEMORY_WRITE) != 0;
      bool value_known = (access.flags & QBDI::MEMORY_UNKNOWN_VALUE) == 0;

      entry["address"] = access.accessAddress;
      entry["inst_address"] = access.instAddress;
      entry["size"] = static_cast<uint32_t>(access.size);
      entry["type"] = static_cast<int>(access.type);
      entry["flags"] = static_cast<int>(access.flags);
      entry["is_read"] = is_read;
      entry["is_write"] = is_write;
      entry["value_known"] = value_known;
      entry["value"] = value_known ? sol::make_object(lua_view, access.value) : sol::lua_nil;

      result[i + 1] = entry;
    }

    return result;
  });

  mem.set_function(
      "read_bytes", [&lua, &context](QBDI::VM*, uint64_t address, size_t size) -> sol::optional<sol::table> {
        auto bytes = context.memory().read_bytes(address, size);
        if (!bytes) {
          return sol::nullopt;
        }

        sol::state_view lua_view = lua.lua_state();
        sol::table data_table = lua_view.create_table();
        for (size_t i = 0; i < bytes->size(); ++i) {
          data_table[i + 1] = (*bytes)[i];
        }

        return data_table;
      }
  );

  mem.set_function("read_hex", [&context](QBDI::VM*, uint64_t address, size_t size) -> sol::optional<std::string> {
    auto bytes = context.memory().read_bytes(address, size);
    if (!bytes) {
      return sol::nullopt;
    }

    std::string hex;
    hex.reserve(bytes->size() * 2);
    const char* hex_chars = "0123456789abcdef";
    for (uint8_t byte : *bytes) {
      hex += hex_chars[byte >> 4];
      hex += hex_chars[byte & 0xF];
    }
    return hex;
  });

  mem.set_function(
      "read_string",
      [&context](QBDI::VM*, uint64_t address, sol::optional<size_t> max_length) -> sol::optional<std::string> {
        size_t max_len = max_length.value_or(256);
        auto result = context.memory().read_string(address, max_len);
        if (!result) {
          return sol::nullopt;
        }
        return *result;
      }
  );

  mem.set_function(
      "read_wstring",
      [&context](QBDI::VM*, uint64_t address, sol::optional<size_t> max_length) -> sol::optional<std::string> {
        size_t max_len = max_length.value_or(256);
        auto bytes = context.memory().read_bytes(address, max_len * sizeof(wchar_t));
        if (!bytes || bytes->empty()) {
          return sol::nullopt;
        }

        std::string out;
        for (size_t i = 0; i + sizeof(wchar_t) <= bytes->size(); i += sizeof(wchar_t)) {
          wchar_t wc = 0;
          std::memcpy(&wc, bytes->data() + i, sizeof(wchar_t));
          if (wc == 0) {
            break;
          }
          if (wc <= 0x7F) {
            out.push_back(static_cast<char>(wc));
          } else {
            out.push_back('?');
          }
        }

        return out;
      }
  );

  w1_module["mem"] = mem;
}

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/mem.hpp`:

```hpp
#pragma once

#include "../runtime/script_context.hpp"

#include <sol/sol.hpp>

namespace w1::tracers::script::bindings {

void setup_mem_bindings(sol::state& lua, sol::table& w1_module, runtime::script_context& context);

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/module.cpp`:

```cpp
#include "module.hpp"

namespace w1::tracers::script::bindings {

namespace {

sol::table module_to_lua(sol::state& lua, const w1::runtime::module_info& module) {
  sol::table info = lua.create_table();
  info["name"] = module.name;
  info["path"] = module.path;
  info["base_address"] = module.base_address;
  info["size"] = module.size;
  info["is_system"] = module.is_system;
  info["start"] = module.full_range.start;
  info["end"] = module.full_range.end;
  return info;
}

} // namespace

void setup_module_bindings(sol::state& lua, sol::table& w1_module, runtime::script_context& context) {
  sol::table module = lua.create_table();

  module.set_function("name", [&context](uint64_t address) -> std::string {
    if (address == 0) {
      return "unknown";
    }
    const auto* info = context.modules().find_containing(address);
    return info ? info->name : "unknown";
  });

  module.set_function("info", [&lua, &context](uint64_t address) -> sol::object {
    if (address == 0) {
      return sol::lua_nil;
    }
    const auto* info = context.modules().find_containing(address);
    if (!info) {
      return sol::lua_nil;
    }
    return module_to_lua(lua, *info);
  });

  module.set_function("list", [&lua, &context](sol::optional<std::string> filter) -> sol::table {
    sol::table modules = lua.create_table();
    int index = 1;

    auto list = context.modules().list_modules();
    for (const auto& module_info : list) {
      if (filter.has_value()) {
        const std::string& search = filter.value();
        if (module_info.name.find(search) == std::string::npos && module_info.path.find(search) == std::string::npos) {
          continue;
        }
      }

      modules[index++] = module_to_lua(lua, module_info);
    }

    return modules;
  });

  module.set_function("count", [&context]() {
    auto list = context.modules().list_modules();
    return list.size();
  });

  module.set_function("refresh", [&context]() { return context.refresh_modules(); });

  w1_module["module"] = module;
}

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/module.hpp`:

```hpp
#pragma once

#include "../runtime/script_context.hpp"

#include <sol/sol.hpp>

namespace w1::tracers::script::bindings {

void setup_module_bindings(sol::state& lua, sol::table& w1_module, runtime::script_context& context);

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/output.cpp`:

```cpp
#include "output.hpp"

#include "util.hpp"

#include <chrono>
#include <iomanip>
#include <sstream>

namespace w1::tracers::script::bindings {

namespace {

std::string format_timestamp() {
  auto now = std::chrono::system_clock::now();
  auto time_t = std::chrono::system_clock::to_time_t(now);
  auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()) % 1000;

  std::stringstream ss;
  ss << std::put_time(std::gmtime(&time_t), "%Y-%m-%dT%H:%M:%S");
  ss << '.' << std::setfill('0') << std::setw(3) << ms.count() << 'Z';
  return ss.str();
}

} // namespace

void setup_output_bindings(sol::state& lua, sol::table& w1_module, runtime::script_context& context) {
  sol::table output = lua.create_table();

  output.set_function(
      "open", [&lua, &context](const std::string& filename, sol::optional<sol::table> metadata) -> bool {
        sol::table meta_table = metadata ? metadata.value() : lua.create_table();
        meta_table["type"] = "metadata";
        if (!meta_table["version"].valid()) {
          meta_table["version"] = "1.0";
        }
        if (!meta_table["timestamp"].valid()) {
          meta_table["timestamp"] = format_timestamp();
        }
        if (!meta_table["tracer"].valid()) {
          meta_table["tracer"] = "w1script";
        }

        std::string json_metadata = lua_table_to_json(meta_table);
        return context.output().open(filename, json_metadata);
      }
  );

  output.set_function("write", [&context](sol::object event_obj) -> bool {
    if (event_obj.is<sol::table>()) {
      std::string json = lua_table_to_json(event_obj.as<sol::table>());
      return context.output().write_event(json);
    }
    if (event_obj.is<std::string>()) {
      return context.output().write_event(event_obj.as<std::string>());
    }
    return false;
  });

  output.set_function("close", [&context]() { context.output().close(); });
  output.set_function("is_open", [&context]() { return context.output().is_open(); });
  output.set_function("count", [&context]() { return context.output().event_count(); });

  w1_module["output"] = output;
}

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/output.hpp`:

```hpp
#pragma once

#include "../runtime/script_context.hpp"

#include <sol/sol.hpp>

namespace w1::tracers::script::bindings {

void setup_output_bindings(sol::state& lua, sol::table& w1_module, runtime::script_context& context);

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/reg.cpp`:

```cpp
#include "reg.hpp"

#include "w1runtime/register_capture.hpp"

namespace w1::tracers::script::bindings {

void setup_reg_bindings(sol::state& lua, sol::table& w1_module) {
  sol::table reg = lua.create_table();

  reg.set_function("get", [](QBDI::GPRState* gpr, const std::string& name) -> sol::optional<uint64_t> {
    if (!gpr) {
      return sol::nullopt;
    }

    w1::util::register_state state = w1::util::register_capturer::capture(gpr);
    uint64_t value = 0;
    if (!state.get_register(name, value)) {
      return sol::nullopt;
    }
    return value;
  });

  reg.set_function("pc", [](QBDI::GPRState* gpr) -> sol::optional<uint64_t> {
    if (!gpr) {
      return sol::nullopt;
    }
    w1::util::register_state state = w1::util::register_capturer::capture(gpr);
    return state.get_instruction_pointer();
  });

  reg.set_function("sp", [](QBDI::GPRState* gpr) -> sol::optional<uint64_t> {
    if (!gpr) {
      return sol::nullopt;
    }
    w1::util::register_state state = w1::util::register_capturer::capture(gpr);
    return state.get_stack_pointer();
  });

  w1_module["reg"] = reg;
}

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/reg.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>

namespace w1::tracers::script::bindings {

void setup_reg_bindings(sol::state& lua, sol::table& w1_module);

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/root.cpp`:

```cpp
#include "root.hpp"

#include <QBDI.h>
#include <redlog.hpp>

#include <optional>
#include <string>
#include <vector>

namespace w1::tracers::script::bindings {

namespace {

using event_type = runtime::callback_registry::event_type;

const char* system_policy_name(w1::core::system_module_policy policy) {
  switch (policy) {
  case w1::core::system_module_policy::exclude_all:
    return "exclude_all";
  case w1::core::system_module_policy::include_critical:
    return "include_critical";
  case w1::core::system_module_policy::include_all:
    return "include_all";
  }
  return "exclude_all";
}

std::optional<event_type> parse_event(const sol::object& value) {
  if (!value.is<int>()) {
    return std::nullopt;
  }

  auto event = static_cast<event_type>(value.as<int>());
  switch (event) {
  case event_type::thread_start:
  case event_type::thread_stop:
  case event_type::vm_start:
  case event_type::vm_stop:
  case event_type::instruction_pre:
  case event_type::instruction_post:
  case event_type::basic_block_entry:
  case event_type::basic_block_exit:
  case event_type::exec_transfer_call:
  case event_type::exec_transfer_return:
  case event_type::memory_read:
  case event_type::memory_write:
  case event_type::memory_read_write:
    return event;
  }

  return std::nullopt;
}

runtime::callback_registry::registration_options parse_options(const sol::optional<sol::table>& opts) {
  runtime::callback_registry::registration_options options;

  if (!opts) {
    return options;
  }

  sol::table table = *opts;

  if (table["address"].valid()) {
    options.address = table["address"].get<uint64_t>();
  }
  if (table["start"].valid()) {
    options.start = table["start"].get<uint64_t>();
  }
  if (table["end"].valid()) {
    options.end = table["end"].get<uint64_t>();
  }
  if (table["mnemonic"].valid()) {
    options.mnemonic = table["mnemonic"].get<std::string>();
  }
  if (table["access_type"].valid()) {
    options.access_type = static_cast<QBDI::MemoryAccessType>(table["access_type"].get<int>());
  } else if (table["type"].valid()) {
    options.access_type = static_cast<QBDI::MemoryAccessType>(table["type"].get<int>());
  }

  return options;
}

void add_list_table(sol::table& table, const std::vector<std::string>& values) {
  for (size_t i = 0; i < values.size(); ++i) {
    table[i + 1] = values[i];
  }
}

} // namespace

void setup_root_bindings(
    sol::state& lua, sol::table& w1_module, runtime::script_context& context,
    runtime::callback_registry& callback_registry
) {
  auto logger = redlog::get_logger("w1script.bindings");
  logger.dbg("setting up root bindings");

  sol::table log_table = lua.create_table();
  log_table["info"] = [](const std::string& msg) { redlog::get_logger("w1script.lua").inf(msg); };
  log_table["debug"] = [](const std::string& msg) { redlog::get_logger("w1script.lua").dbg(msg); };
  log_table["warn"] = [](const std::string& msg) { redlog::get_logger("w1script.lua").wrn(msg); };
  log_table["error"] = [](const std::string& msg) { redlog::get_logger("w1script.lua").err(msg); };
  w1_module["log"] = log_table;

  w1_module.set_function(
      "on",
      [&callback_registry](sol::object event_obj, sol::protected_function callback, sol::optional<sol::table> opts)
          -> sol::optional<uint64_t> {
        auto event = parse_event(event_obj);
        if (!event) {
          return sol::nullopt;
        }

        auto options = parse_options(opts);
        uint64_t handle = callback_registry.register_callback(*event, std::move(callback), options);
        if (handle == 0) {
          return sol::nullopt;
        }
        return handle;
      }
  );

  w1_module.set_function("off", [&callback_registry](uint64_t handle) {
    return callback_registry.remove_callback(handle);
  });

  sol::table event_table = lua.create_table();
  event_table["THREAD_START"] = static_cast<int>(event_type::thread_start);
  event_table["THREAD_STOP"] = static_cast<int>(event_type::thread_stop);
  event_table["VM_START"] = static_cast<int>(event_type::vm_start);
  event_table["VM_STOP"] = static_cast<int>(event_type::vm_stop);
  event_table["INSTRUCTION_PRE"] = static_cast<int>(event_type::instruction_pre);
  event_table["INSTRUCTION_POST"] = static_cast<int>(event_type::instruction_post);
  event_table["BASIC_BLOCK_ENTRY"] = static_cast<int>(event_type::basic_block_entry);
  event_table["BASIC_BLOCK_EXIT"] = static_cast<int>(event_type::basic_block_exit);
  event_table["EXEC_TRANSFER_CALL"] = static_cast<int>(event_type::exec_transfer_call);
  event_table["EXEC_TRANSFER_RETURN"] = static_cast<int>(event_type::exec_transfer_return);
  event_table["MEMORY_READ"] = static_cast<int>(event_type::memory_read);
  event_table["MEMORY_WRITE"] = static_cast<int>(event_type::memory_write);
  event_table["MEMORY_READ_WRITE"] = static_cast<int>(event_type::memory_read_write);
  w1_module["event"] = event_table;

  sol::table enum_table = lua.create_table();

  sol::table vm_action = lua.create_table();
  vm_action["CONTINUE"] = QBDI::VMAction::CONTINUE;
  vm_action["SKIP_INST"] = QBDI::VMAction::SKIP_INST;
  vm_action["SKIP_PATCH"] = QBDI::VMAction::SKIP_PATCH;
  vm_action["BREAK_TO_VM"] = QBDI::VMAction::BREAK_TO_VM;
  vm_action["STOP"] = QBDI::VMAction::STOP;
  enum_table["vm_action"] = vm_action;

  sol::table inst_position = lua.create_table();
  inst_position["PREINST"] = QBDI::InstPosition::PREINST;
  inst_position["POSTINST"] = QBDI::InstPosition::POSTINST;
  enum_table["inst_position"] = inst_position;

  sol::table analysis_type = lua.create_table();
  analysis_type["ANALYSIS_INSTRUCTION"] = QBDI::AnalysisType::ANALYSIS_INSTRUCTION;
  analysis_type["ANALYSIS_DISASSEMBLY"] = QBDI::AnalysisType::ANALYSIS_DISASSEMBLY;
  analysis_type["ANALYSIS_OPERANDS"] = QBDI::AnalysisType::ANALYSIS_OPERANDS;
  analysis_type["ANALYSIS_SYMBOL"] = QBDI::AnalysisType::ANALYSIS_SYMBOL;
  analysis_type["ANALYSIS_JIT"] = QBDI::AnalysisType::ANALYSIS_JIT;
  enum_table["analysis_type"] = analysis_type;

  sol::table mem_access = lua.create_table();
  mem_access["MEMORY_READ"] = QBDI::MemoryAccessType::MEMORY_READ;
  mem_access["MEMORY_WRITE"] = QBDI::MemoryAccessType::MEMORY_WRITE;
  mem_access["MEMORY_READ_WRITE"] = QBDI::MemoryAccessType::MEMORY_READ_WRITE;
  enum_table["memory_access_type"] = mem_access;

  sol::table mem_flags = lua.create_table();
  mem_flags["MEMORY_NO_FLAGS"] = QBDI::MemoryAccessFlags::MEMORY_NO_FLAGS;
  mem_flags["MEMORY_UNKNOWN_SIZE"] = QBDI::MemoryAccessFlags::MEMORY_UNKNOWN_SIZE;
  mem_flags["MEMORY_MINIMUM_SIZE"] = QBDI::MemoryAccessFlags::MEMORY_MINIMUM_SIZE;
  mem_flags["MEMORY_UNKNOWN_VALUE"] = QBDI::MemoryAccessFlags::MEMORY_UNKNOWN_VALUE;
  enum_table["memory_access_flags"] = mem_flags;

  w1_module["enum"] = enum_table;

  sol::table config_table = lua.create_table();
  for (const auto& [key, value] : context.config().script_args) {
    config_table[key] = value;
  }
  w1_module["config"] = config_table;

  sol::table settings_table = lua.create_table();
  settings_table["script_path"] = context.config().script_path;
  const auto system_policy = context.config().common.instrumentation.system_policy;
  settings_table["system_policy"] = system_policy_name(system_policy);
  settings_table["include_unnamed_modules"] = context.config().common.instrumentation.include_unnamed_modules;
  settings_table["use_default_excludes"] = context.config().common.instrumentation.use_default_excludes;
  settings_table["verbose"] = context.config().common.verbose;

  sol::table include_modules = lua.create_table();
  add_list_table(include_modules, context.config().common.instrumentation.include_modules);
  settings_table["include_modules"] = include_modules;

  sol::table exclude_modules = lua.create_table();
  add_list_table(exclude_modules, context.config().common.instrumentation.exclude_modules);
  settings_table["exclude_modules"] = exclude_modules;

  w1_module["settings"] = settings_table;
}

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/root.hpp`:

```hpp
#pragma once

#include "../runtime/callback_registry.hpp"
#include "../runtime/script_context.hpp"

#include <sol/sol.hpp>

namespace w1::tracers::script::bindings {

void setup_root_bindings(
    sol::state& lua, sol::table& w1_module, runtime::script_context& context,
    runtime::callback_registry& callback_registry
);

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/symbol.cpp`:

```cpp
#include "symbol.hpp"

namespace w1::tracers::script::bindings {

namespace {

sol::table symbol_info_to_lua(sol::state& lua, const w1::analysis::symbol_info& info) {
  sol::table result = lua.create_table();
  result["module_name"] = info.module_name;
  result["module_path"] = info.module_path;
  result["name"] = info.symbol_name;
  result["demangled_name"] = info.demangled_name;
  result["address"] = info.address;
  result["module_offset"] = info.module_offset;
  result["symbol_address"] = info.symbol_address;
  result["symbol_offset"] = info.symbol_offset;
  result["offset"] = info.symbol_offset;
  result["is_exported"] = info.is_exported;
  result["is_imported"] = info.is_imported;
  result["has_symbol"] = info.has_symbol;
  return result;
}

} // namespace

void setup_symbol_bindings(sol::state& lua, sol::table& w1_module, runtime::script_context& context) {
  sol::table symbol = lua.create_table();

  symbol.set_function("resolve_address", [&lua, &context](uint64_t address) -> sol::object {
    if (address == 0) {
      return sol::lua_nil;
    }

    auto result = context.symbols().resolve(address);
    if (!result) {
      return sol::lua_nil;
    }
    return symbol_info_to_lua(lua, *result);
  });

  symbol.set_function("backend", []() { return std::string("native"); });

  symbol.set_function("clear_cache", [&context]() { context.symbols().clear_cache(); });
  symbol.set_function("cache_size", [&context]() { return context.symbols().cache_size(); });

  w1_module["symbol"] = symbol;
}

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/symbol.hpp`:

```hpp
#pragma once

#include "../runtime/script_context.hpp"

#include <sol/sol.hpp>

namespace w1::tracers::script::bindings {

void setup_symbol_bindings(sol::state& lua, sol::table& w1_module, runtime::script_context& context);

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/util.cpp`:

```cpp
#include "util.hpp"

#include <w1base/platform_utils.hpp>

#include <algorithm>
#include <cctype>
#include <cstdint>
#include <iomanip>
#include <sstream>
#include <string>
#include <vector>

namespace w1::tracers::script::bindings {

namespace {

constexpr char hex_digits[] = "0123456789abcdef";

std::string format_integer_hex(uint64_t value, size_t width) {
  std::string hex;
  if (value == 0) {
    hex = "0";
  } else {
    while (value > 0) {
      hex.push_back(hex_digits[value & 0xF]);
      value >>= 4;
    }
    std::reverse(hex.begin(), hex.end());
  }

  if (hex.size() < width) {
    hex.insert(hex.begin(), width - hex.size(), '0');
  }

  return hex;
}

std::string escape_json(const std::string& input) {
  std::string out;
  out.reserve(input.size() + 2);
  out.push_back('"');

  for (char ch : input) {
    switch (ch) {
    case '"':
      out += "\\\"";
      break;
    case '\\':
      out += "\\\\";
      break;
    case '\b':
      out += "\\b";
      break;
    case '\f':
      out += "\\f";
      break;
    case '\n':
      out += "\\n";
      break;
    case '\r':
      out += "\\r";
      break;
    case '\t':
      out += "\\t";
      break;
    default:
      if (static_cast<unsigned char>(ch) < 0x20) {
        std::ostringstream oss;
        oss << "\\u" << std::hex << std::setw(4) << std::setfill('0') << (static_cast<int>(ch) & 0xFF);
        out += oss.str();
      } else {
        out.push_back(ch);
      }
      break;
    }
  }

  out.push_back('"');
  return out;
}

bool is_array_table(const sol::table& table, size_t& length) {
  length = 0;
  size_t max_index = 0;
  size_t count = 0;

  for (const auto& pair : table) {
    sol::object key = pair.first;
    if (!key.is<int>()) {
      return false;
    }

    int index = key.as<int>();
    if (index <= 0) {
      return false;
    }

    max_index = std::max(max_index, static_cast<size_t>(index));
    ++count;
  }

  if (count == 0) {
    length = 0;
    return true;
  }

  if (max_index != count) {
    return false;
  }

  length = max_index;
  return true;
}

std::string lua_value_to_json(const sol::object& value, int depth);

std::string lua_table_to_json_internal(const sol::table& table, int depth) {
  if (depth > 8) {
    return "null";
  }

  size_t length = 0;
  if (is_array_table(table, length)) {
    std::string out = "[";
    for (size_t i = 1; i <= length; ++i) {
      sol::object item = table[i];
      if (i > 1) {
        out += ',';
      }
      out += lua_value_to_json(item, depth + 1);
    }
    out += "]";
    return out;
  }

  std::string out = "{";
  bool first = true;
  for (const auto& pair : table) {
    sol::object key = pair.first;
    sol::object val = pair.second;

    std::string key_str;
    if (key.is<std::string>()) {
      key_str = key.as<std::string>();
    } else if (key.is<int>()) {
      key_str = std::to_string(key.as<int>());
    } else {
      continue;
    }

    if (!first) {
      out += ',';
    }
    first = false;

    out += escape_json(key_str);
    out += ':';
    out += lua_value_to_json(val, depth + 1);
  }
  out += "}";
  return out;
}

std::string lua_value_to_json(const sol::object& value, int depth) {
  if (!value.valid() || value.get_type() == sol::type::nil) {
    return "null";
  }

  if (value.is<bool>()) {
    return value.as<bool>() ? "true" : "false";
  }

  if (value.is<lua_Number>()) {
    std::ostringstream oss;
    oss << std::setprecision(15) << value.as<lua_Number>();
    return oss.str();
  }

  if (value.is<std::string>()) {
    return escape_json(value.as<std::string>());
  }

  if (value.is<sol::table>()) {
    return lua_table_to_json_internal(value.as<sol::table>(), depth + 1);
  }

  return "null";
}

} // namespace

void setup_util_bindings(sol::state& lua, sol::table& w1_module, uint64_t thread_id) {
  sol::table util = lua.create_table();

  util.set_function("format_address", [](uint64_t address) -> std::string {
    size_t width = sizeof(uintptr_t) * 2;
    std::ostringstream oss;
    oss << "0x" << std::hex << std::setw(static_cast<int>(width)) << std::setfill('0') << address;
    return oss.str();
  });

  util.set_function(
      "format_hex", [](sol::object value, sol::optional<sol::table> options) -> sol::optional<std::string> {
        size_t width = 0;
        bool prefix = false;

        if (options) {
          if (sol::optional<int64_t> opt_width = (*options)["width"]; opt_width && *opt_width > 0) {
            width = static_cast<size_t>(*opt_width);
          }
          if (sol::optional<bool> opt_prefix = (*options)["prefix"]; opt_prefix) {
            prefix = *opt_prefix;
          }
        }

        if (value.get_type() == sol::type::number) {
          lua_Integer iv = value.as<lua_Integer>();
          bool negative = iv < 0;
          uint64_t magnitude = negative ? static_cast<uint64_t>(-iv) : static_cast<uint64_t>(iv);
          std::string hex = format_integer_hex(magnitude, width);
          if (prefix) {
            hex.insert(0, "0x");
          }
          if (negative) {
            hex.insert(hex.begin(), '-');
          }
          return sol::optional<std::string>(std::move(hex));
        }

        if (value.is<std::string>()) {
          const auto& str = value.as<const std::string&>();
          std::string hex;
          hex.reserve(str.size() * 2);
          for (unsigned char ch : str) {
            hex.push_back(hex_digits[ch >> 4]);
            hex.push_back(hex_digits[ch & 0x0F]);
          }
          if (prefix) {
            hex.insert(0, "0x");
          }
          return sol::optional<std::string>(std::move(hex));
        }

        if (value.is<sol::table>()) {
          sol::table table = value.as<sol::table>();
          std::string hex;
          for (size_t i = 1; i <= table.size(); ++i) {
            sol::optional<uint32_t> byte = table[i];
            if (!byte) {
              return sol::nullopt;
            }
            uint8_t b = static_cast<uint8_t>(*byte & 0xFF);
            hex.push_back(hex_digits[b >> 4]);
            hex.push_back(hex_digits[b & 0x0F]);
          }
          if (prefix) {
            hex.insert(0, "0x");
          }
          return sol::optional<std::string>(std::move(hex));
        }

        return sol::nullopt;
      }
  );

  util.set_function("thread_id", [thread_id]() { return thread_id; });
  util.set_function("platform", []() { return w1::common::platform_utils::get_platform_name(); });

  util.set_function("architecture", []() -> std::string {
#if defined(__x86_64__) || defined(_M_X64)
    return "x64";
#elif defined(__i386__) || defined(_M_IX86)
    return "x86";
#elif defined(__arm__) || defined(_M_ARM)
    return "arm";
#elif defined(__aarch64__) || defined(_M_ARM64)
    return "arm64";
#else
    return "unknown";
#endif
  });

  util.set_function("platform_info", [&lua]() -> sol::table {
    sol::table info = lua.create_table();
    info["os"] = w1::common::platform_utils::get_platform_name();

#if defined(__x86_64__) || defined(_M_X64)
    info["arch"] = "x64";
    info["bits"] = 64;
#elif defined(__i386__) || defined(_M_IX86)
    info["arch"] = "x86";
    info["bits"] = 32;
#elif defined(__arm__) || defined(_M_ARM)
    info["arch"] = "arm";
    info["bits"] = 32;
#elif defined(__aarch64__) || defined(_M_ARM64)
    info["arch"] = "arm64";
    info["bits"] = 64;
#else
    info["arch"] = "unknown";
    info["bits"] = 0;
#endif

    return info;
  });

  w1_module["util"] = util;
}

std::string lua_table_to_json(const sol::table& table) { return lua_table_to_json_internal(table, 0); }

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/util.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>

#include <string>

namespace w1::tracers::script::bindings {

void setup_util_bindings(sol::state& lua, sol::table& w1_module, uint64_t thread_id);
std::string lua_table_to_json(const sol::table& table);

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/w1_bindings.cpp`:

```cpp
#include "w1_bindings.hpp"

#include "abi.hpp"
#include "inst.hpp"
#include "mem.hpp"
#include "module.hpp"
#include "output.hpp"
#include "reg.hpp"
#include "root.hpp"
#include "symbol.hpp"
#include "util.hpp"

namespace w1::tracers::script::bindings {

bool setup_w1_bindings(
    sol::state& lua, runtime::script_context& context, runtime::callback_registry& callback_registry
) {
  sol::table w1_module = lua.create_table();

  setup_root_bindings(lua, w1_module, context, callback_registry);
  setup_util_bindings(lua, w1_module, context.thread_id());
  setup_inst_bindings(lua, w1_module);
  setup_mem_bindings(lua, w1_module, context);
  setup_reg_bindings(lua, w1_module);
  setup_module_bindings(lua, w1_module, context);
  setup_symbol_bindings(lua, w1_module, context);
  setup_output_bindings(lua, w1_module, context);
  setup_abi_bindings(lua, w1_module, context);

  lua["w1"] = w1_module;
  return true;
}

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/bindings/w1_bindings.hpp`:

```hpp
#pragma once

#include "../runtime/callback_registry.hpp"
#include "../runtime/script_context.hpp"

#include <sol/sol.hpp>

namespace w1::tracers::script::bindings {

bool setup_w1_bindings(
    sol::state& lua, runtime::script_context& context, runtime::callback_registry& callback_registry
);

} // namespace w1::tracers::script::bindings

```

`src/tracers/w1script/config/script_config.hpp`:

```hpp
#pragma once

#include <algorithm>
#include <cctype>
#include <cstdlib>
#include <string>
#include <string_view>
#include <unordered_map>
#include <vector>

#include "w1instrument/config/tracer_common_config.hpp"
#include "w1base/env_config.hpp"

#if !defined(_WIN32)
extern "C" char** environ;
#endif

namespace w1::tracers::script {

struct script_config {
  w1::instrument::config::tracer_common_config common{};
  std::string script_path;
  std::unordered_map<std::string, std::string> script_args;

  static script_config from_environment() {
    w1::util::env_config loader("W1SCRIPT");

    script_config config;
    config.common = w1::instrument::config::load_common(loader);
    config.script_path = loader.get<std::string>("SCRIPT", "");

    auto env_vars = []() -> std::vector<std::string_view> {
      std::vector<std::string_view> values;
#if defined(_WIN32)
      char** env = _environ;
#else
      char** env = environ;
#endif
      if (!env) {
        return values;
      }
      for (char** entry = env; *entry != nullptr; ++entry) {
        values.emplace_back(*entry);
      }
      return values;
    }();

    for (const auto& entry : env_vars) {
      auto pos = entry.find('=');
      if (pos == std::string_view::npos) {
        continue;
      }
      std::string_view key = entry.substr(0, pos);
      std::string_view value = entry.substr(pos + 1);

      constexpr std::string_view prefix = "W1SCRIPT_";
      if (key.size() <= prefix.size() || key.substr(0, prefix.size()) != prefix) {
        continue;
      }

      std::string suffix(key.substr(prefix.size()));
      if (suffix == "SCRIPT" || w1::instrument::config::is_common_reserved_key(suffix)) {
        continue;
      }

      std::string lower_key = suffix;
      std::transform(lower_key.begin(), lower_key.end(), lower_key.begin(), [](unsigned char ch) {
        return static_cast<char>(std::tolower(ch));
      });
      config.script_args[lower_key] = std::string(value);
    }

    return config;
  }

  bool is_valid() const { return !script_path.empty(); }
};

} // namespace w1::tracers::script

```

`src/tracers/w1script/entrypoints/preload.cpp`:

```cpp
#include "QBDIPreload.h"

#include "script_recipe.hpp"
#include "w1instrument/preload/entrypoints.hpp"

extern "C" {

QBDIPRELOAD_INIT;

QBDI_EXPORT int qbdipreload_on_run(QBDI::VMInstanceRef vm, QBDI::rword start, QBDI::rword stop) {
  return w1::instrument::preload_on_run<w1::tracers::script::script_recipe>(vm, start, stop);
}

QBDI_EXPORT int qbdipreload_on_exit(int status) {
  return w1::instrument::preload_on_exit<w1::tracers::script::script_recipe>(status);
}

QBDI_EXPORT int qbdipreload_on_start(void* main) {
  return w1::instrument::preload_on_start<w1::tracers::script::script_recipe>(main);
}

QBDI_EXPORT int qbdipreload_on_premain(void* gpr_ctx, void* fpu_ctx) {
  return w1::instrument::preload_on_premain<w1::tracers::script::script_recipe>(gpr_ctx, fpu_ctx);
}

QBDI_EXPORT int qbdipreload_on_main(int argc, char** argv) {
  return w1::instrument::preload_on_main<w1::tracers::script::script_recipe>(argc, argv);
}

} // extern "C"

```

`src/tracers/w1script/runtime/callback_registry.cpp`:

```cpp
#include "callback_registry.hpp"

#include <algorithm>
#include <cctype>
#include <string_view>

namespace w1::tracers::script::runtime {
namespace {

sol::table build_state_table(sol::state_view lua, const QBDI::VMState* state) {
  sol::table out = lua.create_table();
  if (!state) {
    return out;
  }

  out["sequenceStart"] = static_cast<uint64_t>(state->sequenceStart);
  out["sequenceEnd"] = static_cast<uint64_t>(state->sequenceEnd);
  out["basicBlockStart"] = static_cast<uint64_t>(state->basicBlockStart);
  out["basicBlockEnd"] = static_cast<uint64_t>(state->basicBlockEnd);
  return out;
}

} // namespace

namespace {

std::string to_lower(std::string_view value) {
  std::string out(value.begin(), value.end());
  std::transform(out.begin(), out.end(), out.begin(), [](unsigned char ch) {
    return static_cast<char>(std::tolower(ch));
  });
  return out;
}

bool has_wildcards(std::string_view pattern) { return pattern.find_first_of("*?") != std::string_view::npos; }

} // namespace

callback_registry::callback_registry() : logger_(redlog::get_logger("w1script.callbacks")) {}

uint64_t callback_registry::register_callback(
    event_type event, sol::protected_function callback, const registration_options& options
) {
  if (!callback.valid()) {
    return 0;
  }

  callback_entry entry;
  entry.id = next_id_++;
  entry.event = event;
  entry.options = options;
  if (!entry.options.mnemonic.empty()) {
    entry.options.mnemonic = to_lower(entry.options.mnemonic);
    entry.options.mnemonic_has_wildcards = has_wildcards(entry.options.mnemonic);
    mnemonic_filter_counts_[event_index(event)] += 1;
  }
  entry.callback = std::move(callback);

  callbacks_.emplace(entry.id, entry);
  if (dispatch_depth_ > 0) {
    pending_additions_.emplace_back(event, entry.id);
  } else {
    event_handlers_[event].push_back(entry.id);
  }

  return entry.id;
}

bool callback_registry::remove_callback(uint64_t handle) {
  auto it = callbacks_.find(handle);
  if (it == callbacks_.end()) {
    return false;
  }

  auto event = it->second.event;
  if (!it->second.options.mnemonic.empty()) {
    size_t index = event_index(event);
    if (mnemonic_filter_counts_[index] > 0) {
      mnemonic_filter_counts_[index] -= 1;
    }
  }

  callbacks_.erase(it);
  if (dispatch_depth_ > 0) {
    pending_prune_[event_index(event)] = true;
  } else {
    auto handler_it = event_handlers_.find(event);
    if (handler_it != event_handlers_.end()) {
      auto& list = handler_it->second;
      list.erase(std::remove(list.begin(), list.end(), handle), list.end());
    }
  }
  return true;
}

void callback_registry::shutdown() {
  callbacks_.clear();
  event_handlers_.clear();
  pending_additions_.clear();
  pending_prune_.fill(false);
  mnemonic_filter_counts_.fill(0);
  dispatch_depth_ = 0;
  next_id_ = 1;
}

QBDI::VMAction callback_registry::dispatch_thread_start(const w1::thread_event& event) {
  return dispatch_thread(event_type::thread_start, event);
}

QBDI::VMAction callback_registry::dispatch_thread_stop(const w1::thread_event& event) {
  return dispatch_thread(event_type::thread_stop, event);
}

QBDI::VMAction callback_registry::dispatch_vm_start(
    const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  return dispatch_sequence(event_type::vm_start, event, vm, state, gpr, fpr);
}

QBDI::VMAction callback_registry::dispatch_vm_stop(
    const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  return dispatch_sequence(event_type::vm_stop, event, vm, state, gpr, fpr);
}

QBDI::VMAction callback_registry::dispatch_instruction_pre(
    const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  return dispatch_instruction(event_type::instruction_pre, event, vm, gpr, fpr);
}

QBDI::VMAction callback_registry::dispatch_instruction_post(
    const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  return dispatch_instruction(event_type::instruction_post, event, vm, gpr, fpr);
}

QBDI::VMAction callback_registry::dispatch_basic_block_entry(
    const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  return dispatch_basic_block(event_type::basic_block_entry, event, vm, state, gpr, fpr);
}

QBDI::VMAction callback_registry::dispatch_basic_block_exit(
    const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  return dispatch_basic_block(event_type::basic_block_exit, event, vm, state, gpr, fpr);
}

QBDI::VMAction callback_registry::dispatch_exec_transfer_call(
    const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  return dispatch_exec_transfer(event_type::exec_transfer_call, event, vm, state, gpr, fpr);
}

QBDI::VMAction callback_registry::dispatch_exec_transfer_return(
    const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  return dispatch_exec_transfer(event_type::exec_transfer_return, event, vm, state, gpr, fpr);
}

QBDI::VMAction callback_registry::dispatch_memory(
    const w1::memory_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  if (event.is_read) {
    QBDI::VMAction action = dispatch_memory_event(event_type::memory_read, event, vm, gpr, fpr);
    if (action != QBDI::VMAction::CONTINUE) {
      return action;
    }
  }

  if (event.is_write) {
    QBDI::VMAction action = dispatch_memory_event(event_type::memory_write, event, vm, gpr, fpr);
    if (action != QBDI::VMAction::CONTINUE) {
      return action;
    }
  }

  if (event.is_read && event.is_write) {
    return dispatch_memory_event(event_type::memory_read_write, event, vm, gpr, fpr);
  }

  return QBDI::VMAction::CONTINUE;
}

QBDI::VMAction callback_registry::dispatch_instruction(
    event_type event_type, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  dispatch_scope guard(*this);
  auto handler_it = event_handlers_.find(event_type);
  if (handler_it == event_handlers_.end()) {
    return QBDI::VMAction::CONTINUE;
  }

  const auto& handlers = handler_it->second;
  std::string mnemonic_lower;
  if (mnemonic_filter_counts_[event_index(event_type)] > 0 && vm) {
    const QBDI::InstAnalysis* analysis = vm->getInstAnalysis(QBDI::ANALYSIS_INSTRUCTION);
    if (analysis && analysis->mnemonic) {
      mnemonic_lower = to_lower(analysis->mnemonic);
    }
  }

  for (uint64_t id : handlers) {
    auto entry_it = callbacks_.find(id);
    if (entry_it == callbacks_.end()) {
      continue;
    }
    const auto& entry = entry_it->second;
    if (!matches_address(entry.options, event.address)) {
      continue;
    }

    if (!entry.options.mnemonic.empty()) {
      if (mnemonic_lower.empty()) {
        continue;
      }
      if (entry.options.mnemonic_has_wildcards) {
        if (!is_mnemonic_match(entry.options.mnemonic, mnemonic_lower)) {
          continue;
        }
      } else if (entry.options.mnemonic != mnemonic_lower) {
        continue;
      }
    }

    auto result = entry.callback(vm, gpr, fpr);
    QBDI::VMAction action = resolve_action(result);
    if (action != QBDI::VMAction::CONTINUE) {
      return action;
    }
  }

  return QBDI::VMAction::CONTINUE;
}

QBDI::VMAction callback_registry::dispatch_basic_block(
    event_type event_type, const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  dispatch_scope guard(*this);
  auto handler_it = event_handlers_.find(event_type);
  if (handler_it == event_handlers_.end()) {
    return QBDI::VMAction::CONTINUE;
  }

  const auto& handlers = handler_it->second;
  for (uint64_t id : handlers) {
    auto entry_it = callbacks_.find(id);
    if (entry_it == callbacks_.end()) {
      continue;
    }
    const auto& entry = entry_it->second;
    if (!matches_address(entry.options, event.address)) {
      continue;
    }

    sol::state_view lua(entry.callback.lua_state());
    sol::table state_table = build_state_table(lua, state);
    auto result = entry.callback(vm, state_table, gpr, fpr);
    QBDI::VMAction action = resolve_action(result);
    if (action != QBDI::VMAction::CONTINUE) {
      return action;
    }
  }

  return QBDI::VMAction::CONTINUE;
}

QBDI::VMAction callback_registry::dispatch_exec_transfer(
    event_type event_type, [[maybe_unused]] const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm,
    const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  dispatch_scope guard(*this);
  auto handler_it = event_handlers_.find(event_type);
  if (handler_it == event_handlers_.end()) {
    return QBDI::VMAction::CONTINUE;
  }

  const auto& handlers = handler_it->second;
  for (uint64_t id : handlers) {
    auto entry_it = callbacks_.find(id);
    if (entry_it == callbacks_.end()) {
      continue;
    }
    const auto& entry = entry_it->second;
    sol::state_view lua(entry.callback.lua_state());
    sol::table state_table = build_state_table(lua, state);
    auto result = entry.callback(vm, state_table, gpr, fpr);
    QBDI::VMAction action = resolve_action(result);
    if (action != QBDI::VMAction::CONTINUE) {
      return action;
    }
  }

  return QBDI::VMAction::CONTINUE;
}

QBDI::VMAction callback_registry::dispatch_sequence(
    event_type event_type, [[maybe_unused]] const w1::sequence_event& event, QBDI::VMInstanceRef vm,
    const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  dispatch_scope guard(*this);
  auto handler_it = event_handlers_.find(event_type);
  if (handler_it == event_handlers_.end()) {
    return QBDI::VMAction::CONTINUE;
  }

  const auto& handlers = handler_it->second;
  for (uint64_t id : handlers) {
    auto entry_it = callbacks_.find(id);
    if (entry_it == callbacks_.end()) {
      continue;
    }
    const auto& entry = entry_it->second;
    sol::state_view lua(entry.callback.lua_state());
    sol::table state_table = build_state_table(lua, state);
    auto result = entry.callback(vm, state_table, gpr, fpr);
    QBDI::VMAction action = resolve_action(result);
    if (action != QBDI::VMAction::CONTINUE) {
      return action;
    }
  }

  return QBDI::VMAction::CONTINUE;
}

QBDI::VMAction callback_registry::dispatch_thread(event_type event_type, const w1::thread_event& event) {
  dispatch_scope guard(*this);
  auto handler_it = event_handlers_.find(event_type);
  if (handler_it == event_handlers_.end()) {
    return QBDI::VMAction::CONTINUE;
  }

  const auto& handlers = handler_it->second;
  for (uint64_t id : handlers) {
    auto entry_it = callbacks_.find(id);
    if (entry_it == callbacks_.end()) {
      continue;
    }
    const auto& entry = entry_it->second;
    sol::state_view lua(entry.callback.lua_state());
    sol::table thread_info = lua.create_table();
    thread_info["thread_id"] = event.thread_id;
    thread_info["name"] = event.name ? event.name : "";

    auto result = entry.callback(thread_info);
    QBDI::VMAction action = resolve_action(result);
    if (action != QBDI::VMAction::CONTINUE) {
      return action;
    }
  }

  return QBDI::VMAction::CONTINUE;
}

QBDI::VMAction callback_registry::dispatch_memory_event(
    event_type event_type, const w1::memory_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  dispatch_scope guard(*this);
  auto handler_it = event_handlers_.find(event_type);
  if (handler_it == event_handlers_.end()) {
    return QBDI::VMAction::CONTINUE;
  }

  const auto& handlers = handler_it->second;
  for (uint64_t id : handlers) {
    auto entry_it = callbacks_.find(id);
    if (entry_it == callbacks_.end()) {
      continue;
    }
    const auto& entry = entry_it->second;
    if (!matches_address(entry.options, event.address)) {
      continue;
    }

    if (entry.options.access_type) {
      auto access_type = *entry.options.access_type;
      if ((access_type & QBDI::MEMORY_READ) != 0 && !event.is_read) {
        continue;
      }
      if ((access_type & QBDI::MEMORY_WRITE) != 0 && !event.is_write) {
        continue;
      }
    }

    sol::state_view lua(entry.callback.lua_state());
    sol::table access = lua.create_table();
    access["address"] = event.address;
    access["instruction_address"] = event.instruction_address;
    access["size"] = event.size;
    access["flags"] = event.flags;
    access["value"] = event.value_valid ? sol::make_object(lua, event.value) : sol::lua_nil;
    access["value_valid"] = event.value_valid;
    access["is_read"] = event.is_read;
    access["is_write"] = event.is_write;

    auto result = entry.callback(vm, gpr, fpr, access);
    QBDI::VMAction action = resolve_action(result);
    if (action != QBDI::VMAction::CONTINUE) {
      return action;
    }
  }

  return QBDI::VMAction::CONTINUE;
}

QBDI::VMAction callback_registry::resolve_action(const sol::protected_function_result& result) {
  if (!result.valid()) {
    sol::error err = result;
    logger_.err("lua callback error", redlog::field("error", err.what()));
    return QBDI::VMAction::CONTINUE;
  }

  if (result.return_count() == 0) {
    return QBDI::VMAction::CONTINUE;
  }

  sol::object obj = result.get<sol::object>();
  if (obj.is<QBDI::VMAction>()) {
    return obj.as<QBDI::VMAction>();
  }
  if (obj.is<int>()) {
    return static_cast<QBDI::VMAction>(obj.as<int>());
  }
  if (obj.is<lua_Integer>()) {
    return static_cast<QBDI::VMAction>(obj.as<lua_Integer>());
  }

  return QBDI::VMAction::CONTINUE;
}

bool callback_registry::is_mnemonic_match(std::string_view pattern, std::string_view mnemonic) const {
  size_t p_index = 0;
  size_t m_index = 0;
  size_t star_index = std::string::npos;
  size_t match_index = 0;

  while (m_index < mnemonic.size()) {
    if (p_index < pattern.size() && (pattern[p_index] == mnemonic[m_index] || pattern[p_index] == '?')) {
      ++p_index;
      ++m_index;
      continue;
    }

    if (p_index < pattern.size() && pattern[p_index] == '*') {
      star_index = p_index++;
      match_index = m_index;
      continue;
    }

    if (star_index != std::string::npos) {
      p_index = star_index + 1;
      m_index = ++match_index;
      continue;
    }

    return false;
  }

  while (p_index < pattern.size() && pattern[p_index] == '*') {
    ++p_index;
  }

  return p_index == pattern.size();
}

bool callback_registry::matches_address(const registration_options& options, uint64_t address) const {
  if (options.address) {
    return address == *options.address;
  }

  if (options.start && options.end) {
    return address >= *options.start && address < *options.end;
  }

  return true;
}

void callback_registry::finish_dispatch() {
  if (dispatch_depth_ == 0) {
    return;
  }
  dispatch_depth_ -= 1;
  if (dispatch_depth_ == 0) {
    flush_pending();
  }
}

void callback_registry::flush_pending() {
  if (!pending_additions_.empty()) {
    for (const auto& entry : pending_additions_) {
      event_handlers_[entry.first].push_back(entry.second);
    }
    pending_additions_.clear();
  }

  for (size_t index = 0; index < pending_prune_.size(); ++index) {
    if (!pending_prune_[index]) {
      continue;
    }
    pending_prune_[index] = false;
    auto type = static_cast<event_type>(index);
    auto handler_it = event_handlers_.find(type);
    if (handler_it == event_handlers_.end()) {
      continue;
    }
    auto& handlers = handler_it->second;
    handlers.erase(
        std::remove_if(
            handlers.begin(), handlers.end(), [this](uint64_t id) { return callbacks_.find(id) == callbacks_.end(); }
        ),
        handlers.end()
    );
  }
}

} // namespace w1::tracers::script::runtime

```

`src/tracers/w1script/runtime/callback_registry.hpp`:

```hpp
#pragma once

#include "w1instrument/tracer/types.hpp"

#include <QBDI.h>
#include <redlog.hpp>
#include <sol/sol.hpp>

#include <array>
#include <cstddef>
#include <cstdint>
#include <optional>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

namespace w1::tracers::script::runtime {

class callback_registry {
public:
  enum class event_type {
    thread_start,
    thread_stop,
    vm_start,
    vm_stop,
    instruction_pre,
    instruction_post,
    basic_block_entry,
    basic_block_exit,
    exec_transfer_call,
    exec_transfer_return,
    memory_read,
    memory_write,
    memory_read_write
  };

  struct registration_options {
    std::optional<uint64_t> address;
    std::optional<uint64_t> start;
    std::optional<uint64_t> end;
    std::optional<QBDI::MemoryAccessType> access_type;
    std::string mnemonic;
    bool mnemonic_has_wildcards = false;
  };

  callback_registry();

  uint64_t register_callback(event_type event, sol::protected_function callback, const registration_options& options);
  bool remove_callback(uint64_t handle);
  void shutdown();

  QBDI::VMAction dispatch_thread_start(const w1::thread_event& event);
  QBDI::VMAction dispatch_thread_stop(const w1::thread_event& event);

  QBDI::VMAction dispatch_vm_start(
      const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );
  QBDI::VMAction dispatch_vm_stop(
      const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );

  QBDI::VMAction dispatch_instruction_pre(
      const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );
  QBDI::VMAction dispatch_instruction_post(
      const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );

  QBDI::VMAction dispatch_basic_block_entry(
      const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );
  QBDI::VMAction dispatch_basic_block_exit(
      const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );

  QBDI::VMAction dispatch_exec_transfer_call(
      const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );
  QBDI::VMAction dispatch_exec_transfer_return(
      const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );

  QBDI::VMAction dispatch_memory(
      const w1::memory_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );

private:
  static constexpr size_t event_type_count = static_cast<size_t>(event_type::memory_read_write) + 1;

  static constexpr size_t event_index(event_type value) { return static_cast<size_t>(value); }

  struct dispatch_scope {
    explicit dispatch_scope(callback_registry& registry) : registry_(registry) { registry_.dispatch_depth_ += 1; }
    ~dispatch_scope() { registry_.finish_dispatch(); }

  private:
    callback_registry& registry_;
  };

  struct event_hash {
    size_t operator()(event_type value) const { return static_cast<size_t>(value); }
  };

  struct callback_entry {
    uint64_t id = 0;
    event_type event{};
    registration_options options{};
    sol::protected_function callback{};
  };

  QBDI::VMAction dispatch_instruction(
      event_type event_type, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );
  QBDI::VMAction dispatch_basic_block(
      event_type event_type, const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );
  QBDI::VMAction dispatch_exec_transfer(
      event_type event_type, const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );
  QBDI::VMAction dispatch_sequence(
      event_type event_type, const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );
  QBDI::VMAction dispatch_thread(event_type event_type, const w1::thread_event& event);

  QBDI::VMAction dispatch_memory_event(
      event_type event_type, const w1::memory_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );

  QBDI::VMAction resolve_action(const sol::protected_function_result& result);
  bool is_mnemonic_match(std::string_view pattern, std::string_view mnemonic) const;
  bool matches_address(const registration_options& options, uint64_t address) const;
  void finish_dispatch();
  void flush_pending();

  uint64_t next_id_ = 1;
  std::unordered_map<uint64_t, callback_entry> callbacks_;
  std::unordered_map<event_type, std::vector<uint64_t>, event_hash> event_handlers_;
  std::vector<std::pair<event_type, uint64_t>> pending_additions_{};
  std::array<bool, event_type_count> pending_prune_{};
  std::array<size_t, event_type_count> mnemonic_filter_counts_{};
  size_t dispatch_depth_ = 0;
  redlog::logger logger_;
};

} // namespace w1::tracers::script::runtime

```

`src/tracers/w1script/runtime/callback_store.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>

#include <mutex>
#include <vector>

namespace w1::tracers::script::runtime {

class callback_store {
public:
  size_t add(sol::protected_function callback) {
    std::lock_guard<std::mutex> lock(mutex_);
    callbacks_.push_back(std::move(callback));
    return callbacks_.size() - 1;
  }

  sol::protected_function* get(size_t index) {
    std::lock_guard<std::mutex> lock(mutex_);
    if (index < callbacks_.size()) {
      return &callbacks_[index];
    }
    return nullptr;
  }

  void clear() {
    std::lock_guard<std::mutex> lock(mutex_);
    callbacks_.clear();
  }

private:
  std::mutex mutex_;
  std::vector<sol::protected_function> callbacks_;
};

} // namespace w1::tracers::script::runtime

```

`src/tracers/w1script/runtime/lua_runtime.cpp`:

```cpp
#include "lua_runtime.hpp"

#include "../bindings/w1_bindings.hpp"

#include <filesystem>

namespace w1::tracers::script::runtime {

lua_runtime::lua_runtime(script_context& context)
    : context_(context), logger_(redlog::get_logger("w1script.runtime")) {}

bool lua_runtime::initialize() {
  if (!open_libraries()) {
    return false;
  }

  configure_package_paths();

  if (!register_bindings()) {
    return false;
  }

  if (!load_script()) {
    return false;
  }

  if (!call_init()) {
    return false;
  }

  return true;
}

void lua_runtime::shutdown() {
  if (script_table_.valid()) {
    sol::optional<sol::function> shutdown_fn = script_table_["shutdown"];
    if (shutdown_fn) {
      auto result = shutdown_fn.value()();
      if (!result.valid()) {
        sol::error err = result;
        logger_.err("error in script shutdown", redlog::field("error", err.what()));
      }
    }
  }

  context_.shutdown();
  callback_registry_.shutdown();
}

QBDI::VMAction lua_runtime::dispatch_thread_start(const w1::thread_event& event) {
  return callback_registry_.dispatch_thread_start(event);
}

QBDI::VMAction lua_runtime::dispatch_thread_stop(const w1::thread_event& event) {
  return callback_registry_.dispatch_thread_stop(event);
}

QBDI::VMAction lua_runtime::dispatch_vm_start(
    const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  return callback_registry_.dispatch_vm_start(event, vm, state, gpr, fpr);
}

QBDI::VMAction lua_runtime::dispatch_vm_stop(
    const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  return callback_registry_.dispatch_vm_stop(event, vm, state, gpr, fpr);
}

QBDI::VMAction lua_runtime::dispatch_instruction_pre(
    const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  return callback_registry_.dispatch_instruction_pre(event, vm, gpr, fpr);
}

QBDI::VMAction lua_runtime::dispatch_instruction_post(
    const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  return callback_registry_.dispatch_instruction_post(event, vm, gpr, fpr);
}

QBDI::VMAction lua_runtime::dispatch_basic_block_entry(
    const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  return callback_registry_.dispatch_basic_block_entry(event, vm, state, gpr, fpr);
}

QBDI::VMAction lua_runtime::dispatch_basic_block_exit(
    const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  return callback_registry_.dispatch_basic_block_exit(event, vm, state, gpr, fpr);
}

QBDI::VMAction lua_runtime::dispatch_exec_transfer_call(
    const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  return callback_registry_.dispatch_exec_transfer_call(event, vm, state, gpr, fpr);
}

QBDI::VMAction lua_runtime::dispatch_exec_transfer_return(
    const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  return callback_registry_.dispatch_exec_transfer_return(event, vm, state, gpr, fpr);
}

QBDI::VMAction lua_runtime::dispatch_memory(
    const w1::memory_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  return callback_registry_.dispatch_memory(event, vm, gpr, fpr);
}

bool lua_runtime::open_libraries() {
  lua_.open_libraries(
      sol::lib::base, sol::lib::package, sol::lib::table, sol::lib::string, sol::lib::math, sol::lib::bit32,
      sol::lib::io, sol::lib::os
  );

  sol::table bit32 = lua_["bit32"];
  if (bit32.valid()) {
    lua_["bit"] = bit32;
    sol::table package = lua_["package"];
    if (package.valid()) {
      sol::table preload = package["preload"];
      if (preload.valid()) {
        preload.set_function("bit", [bit32]() -> sol::table { return bit32; });
      }
    }
  }

  return true;
}

void lua_runtime::configure_package_paths() {
  if (context_.config().script_path.empty()) {
    return;
  }

  std::filesystem::path script_path(context_.config().script_path);
  auto script_dir = script_path.parent_path();
  if (script_dir.empty()) {
    return;
  }

  std::string path_entry = script_dir.string();
  if (path_entry.empty()) {
    return;
  }

  sol::table package = lua_["package"];
  if (!package.valid()) {
    return;
  }

  std::string lua_path = package["path"].get_or(std::string{});
  std::string lua_cpath = package["cpath"].get_or(std::string{});

  std::string add_path = path_entry + "/?.lua;" + path_entry + "/?/init.lua";
  if (!lua_path.empty()) {
    lua_path += ";";
  }
  lua_path += add_path;
  package["path"] = lua_path;

#if defined(_WIN32)
  std::string so_ext = ".dll";
#elif defined(__APPLE__)
  std::string so_ext = ".dylib";
#else
  std::string so_ext = ".so";
#endif

  std::string add_cpath = path_entry + "/?" + so_ext;
  if (!lua_cpath.empty()) {
    lua_cpath += ";";
  }
  lua_cpath += add_cpath;
  package["cpath"] = lua_cpath;
}

bool lua_runtime::register_bindings() { return bindings::setup_w1_bindings(lua_, context_, callback_registry_); }

bool lua_runtime::load_script() {
  if (context_.config().script_path.empty()) {
    logger_.err("script path is empty");
    return false;
  }

  sol::load_result script = lua_.load_file(context_.config().script_path);
  if (!script.valid()) {
    sol::error err = script;
    logger_.err("failed to load script", redlog::field("error", err.what()));
    return false;
  }

  sol::protected_function_result exec_result = script();
  if (!exec_result.valid()) {
    sol::error err = exec_result;
    logger_.err("failed to execute script", redlog::field("error", err.what()));
    return false;
  }

  if (exec_result.return_count() == 0 || exec_result.get_type() == sol::type::lua_nil) {
    script_table_ = lua_.create_table();
    return true;
  }

  if (exec_result.get_type() != sol::type::table) {
    logger_.err("script must return a table or nil");
    return false;
  }

  script_table_ = exec_result;
  return true;
}

bool lua_runtime::call_init() {
  if (!script_table_.valid()) {
    return true;
  }

  sol::optional<sol::function> init_fn = script_table_["init"];
  if (!init_fn) {
    return true;
  }

  auto result = init_fn.value()();
  if (!result.valid()) {
    sol::error err = result;
    logger_.err("error in script init", redlog::field("error", err.what()));
    return false;
  }

  return true;
}

} // namespace w1::tracers::script::runtime

```

`src/tracers/w1script/runtime/lua_runtime.hpp`:

```hpp
#pragma once

#include "callback_registry.hpp"
#include "script_context.hpp"

#include <sol/sol.hpp>
#include <redlog.hpp>

#include <string>

namespace w1::tracers::script::runtime {

class lua_runtime {
public:
  explicit lua_runtime(script_context& context);

  bool initialize();
  void shutdown();

  QBDI::VMAction dispatch_thread_start(const w1::thread_event& event);
  QBDI::VMAction dispatch_thread_stop(const w1::thread_event& event);

  QBDI::VMAction dispatch_vm_start(
      const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );
  QBDI::VMAction dispatch_vm_stop(
      const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );

  QBDI::VMAction dispatch_instruction_pre(
      const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );
  QBDI::VMAction dispatch_instruction_post(
      const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );

  QBDI::VMAction dispatch_basic_block_entry(
      const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );
  QBDI::VMAction dispatch_basic_block_exit(
      const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );

  QBDI::VMAction dispatch_exec_transfer_call(
      const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );
  QBDI::VMAction dispatch_exec_transfer_return(
      const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );

  QBDI::VMAction dispatch_memory(
      const w1::memory_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );

private:
  bool open_libraries();
  void configure_package_paths();
  bool register_bindings();
  bool load_script();
  bool call_init();

  script_context& context_;
  sol::state lua_;
  sol::table script_table_;
  callback_registry callback_registry_;
  redlog::logger logger_;
};

} // namespace w1::tracers::script::runtime

```

`src/tracers/w1script/runtime/output_state.cpp`:

```cpp
#include "output_state.hpp"

#include <chrono>
#include <iomanip>
#include <sstream>

namespace w1::tracers::script::runtime {

namespace {

std::string format_timestamp() {
  auto now = std::chrono::system_clock::now();
  auto time_t = std::chrono::system_clock::to_time_t(now);
  auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()) % 1000;

  std::stringstream ss;
  ss << std::put_time(std::gmtime(&time_t), "%Y-%m-%dT%H:%M:%S");
  ss << '.' << std::setfill('0') << std::setw(3) << ms.count() << 'Z';
  return ss.str();
}

} // namespace

output_state::output_state() : logger_(redlog::get_logger("w1script.output")) {}

bool output_state::open(const std::string& filename, const std::string& metadata_json) {
  if (initialized_) {
    close();
  }

  writer_ = std::make_unique<w1::io::jsonl_writer>(filename);
  if (!writer_->is_open()) {
    logger_.err("failed to open output file", redlog::field("filename", filename));
    writer_.reset();
    return false;
  }

  if (!metadata_json.empty()) {
    if (!writer_->write_line(metadata_json)) {
      logger_.err("failed to write metadata", redlog::field("filename", filename));
      writer_->close();
      writer_.reset();
      return false;
    }
  }

  initialized_ = true;
  event_count_ = 0;
  logger_.inf("output initialized", redlog::field("filename", filename));
  return true;
}

bool output_state::write_event(const std::string& json_line) {
  if (!initialized_ || !writer_) {
    logger_.err("output not initialized");
    return false;
  }

  if (!writer_->write_line(json_line)) {
    return false;
  }

  event_count_++;
  return true;
}

void output_state::close() {
  if (!initialized_ || !writer_) {
    return;
  }

  if (event_count_ > 0) {
    auto summary = build_summary_json();
    if (!summary.empty()) {
      writer_->write_line(summary);
    }
  }

  writer_->close();
  writer_.reset();
  initialized_ = false;

  logger_.inf("output closed", redlog::field("events", event_count_));
}

std::string output_state::build_summary_json() const {
  std::stringstream summary;
  summary << "{\"type\":\"summary\",";
  summary << "\"event_count\":" << event_count_ << ',';
  summary << "\"end_timestamp\":\"" << format_timestamp() << "\"}";
  return summary.str();
}

} // namespace w1::tracers::script::runtime

```

`src/tracers/w1script/runtime/output_state.hpp`:

```hpp
#pragma once

#include "w1formats/jsonl_writer.hpp"

#include <memory>
#include <string>

#include <redlog.hpp>

namespace w1::tracers::script::runtime {

class output_state {
public:
  output_state();

  bool open(const std::string& filename, const std::string& metadata_json);
  bool write_event(const std::string& json_line);
  void close();

  bool is_open() const { return initialized_ && writer_ && writer_->is_open(); }
  size_t event_count() const { return event_count_; }

private:
  std::unique_ptr<w1::io::jsonl_writer> writer_;
  size_t event_count_ = 0;
  bool initialized_ = false;
  redlog::logger logger_;

  std::string build_summary_json() const;
};

} // namespace w1::tracers::script::runtime

```

`src/tracers/w1script/runtime/script_context.cpp`:

```cpp
#include "script_context.hpp"

#include <utility>

namespace w1::tracers::script::runtime {

script_context::script_context(
    QBDI::VM* vm, const script_config& config, w1::runtime::module_catalog* modules,
    const w1::util::memory_reader* memory, uint64_t thread_id, std::string thread_name
)
    : config_(config), vm_(vm), modules_(modules), memory_(memory), thread_id_(thread_id),
      thread_name_(std::move(thread_name)), logger_(redlog::get_logger("w1script.context")) {
  symbol_lookup_.set_module_catalog(modules_);
}

bool script_context::refresh_modules() {
  if (!modules_) {
    return false;
  }

  modules_->refresh();
  symbol_lookup_.clear_cache();
  return true;
}

void script_context::shutdown() { output_.close(); }

} // namespace w1::tracers::script::runtime

```

`src/tracers/w1script/runtime/script_context.hpp`:

```hpp
#pragma once

#include "../config/script_config.hpp"
#include "output_state.hpp"

#include "w1analysis/abi_dispatcher.hpp"
#include "w1analysis/symbol_lookup.hpp"
#include "w1runtime/module_catalog.hpp"
#include "w1runtime/memory_reader.hpp"

#include <QBDI.h>
#include <redlog.hpp>

#include <string>

namespace w1::tracers::script::runtime {

class script_context {
public:
  script_context(
      QBDI::VM* vm, const script_config& config, w1::runtime::module_catalog* modules,
      const w1::util::memory_reader* memory, uint64_t thread_id, std::string thread_name
  );

  QBDI::VM* vm() const { return vm_; }
  const script_config& config() const { return config_; }
  w1::runtime::module_catalog& modules() const { return *modules_; }
  const w1::util::memory_reader& memory() const { return *memory_; }
  w1::analysis::symbol_lookup& symbols() { return symbol_lookup_; }
  const w1::analysis::symbol_lookup& symbols() const { return symbol_lookup_; }
  w1::analysis::abi_dispatcher& abi() { return abi_dispatcher_; }
  output_state& output() { return output_; }
  uint64_t thread_id() const { return thread_id_; }
  const std::string& thread_name() const { return thread_name_; }

  bool refresh_modules();
  void shutdown();

private:
  script_config config_{};
  QBDI::VM* vm_ = nullptr;
  w1::runtime::module_catalog* modules_ = nullptr;
  const w1::util::memory_reader* memory_ = nullptr;
  w1::analysis::symbol_lookup symbol_lookup_{};
  w1::analysis::abi_dispatcher abi_dispatcher_{};
  output_state output_{};
  uint64_t thread_id_ = 0;
  std::string thread_name_;
  redlog::logger logger_;
};

} // namespace w1::tracers::script::runtime

```

`src/tracers/w1script/runtime/script_runtime.hpp`:

```hpp
#pragma once

#include <memory>
#include <utility>

#include "config/script_config.hpp"
#include "thread/script_tracer.hpp"
#include "w1instrument/tracer/runtime.hpp"

namespace w1::tracers::script {

class script_engine {
public:
  explicit script_engine(const script_config&) {}

  void configure(w1::runtime::module_catalog&) {}

  bool export_output() { return true; }
};

struct script_traits {
  using tracer_type = script_tracer;

  static w1::instrument::thread_session_config make_thread_config(const script_config& config) {
    w1::instrument::thread_session_config session_config{};
    session_config.instrumentation = config.common.instrumentation;
    return session_config;
  }

  static tracer_type make_tracer(std::shared_ptr<script_engine> engine, const script_config& config) {
    return tracer_type(std::move(engine), config);
  }

  static void configure_engine(script_engine& engine, w1::runtime::module_catalog& modules) {
    engine.configure(modules);
  }

  static bool export_output(script_engine& engine) { return engine.export_output(); }
};

struct script_runtime {
  using session_type = w1::instrument::thread_runtime<script_engine, script_tracer, script_config, script_traits>;

  std::unique_ptr<session_type> session;
};

inline script_runtime make_script_runtime(script_config config) {
  script_runtime runtime;
  runtime.session = std::make_unique<script_runtime::session_type>(std::move(config));
  return runtime;
}

} // namespace w1::tracers::script

```

`src/tracers/w1script/script.hpp`:

```hpp
#pragma once

#include <utility>

#include "config/script_config.hpp"
#include "runtime/script_runtime.hpp"

namespace w1::tracers::script {

// Public helpers for standalone usage.
template <typename Fn> decltype(auto) with_thread_runtime(script_config config, Fn&& fn) {
  auto runtime = make_script_runtime(std::move(config));
  return fn(runtime);
}

} // namespace w1::tracers::script

```

`src/tracers/w1script/script_recipe.hpp`:

```hpp
#pragma once

#include <cstdint>

#include "QBDIPreload.h"
#include <QBDI.h>
#include <redlog.hpp>

#if defined(_WIN32) || defined(WIN32)
#include <w1base/windows_console.hpp>
#endif

#include "config/script_config.hpp"
#include "runtime/script_runtime.hpp"
#include "w1instrument/logging.hpp"
#include "w1instrument/self_exclude.hpp"

namespace w1::tracers::script {

struct script_recipe {
  using config_t = script_config;
  using runtime_t = script_runtime;

  static config_t load_config() { return script_config::from_environment(); }

  static void configure_logging(const config_t& config) {
    w1::instrument::configure_redlog_verbosity(config.common.verbose);
  }

  static void apply_self_excludes(config_t& config, const void* anchor) {
    if (config.common.exclude_self) {
      w1::util::append_self_excludes(config.common.instrumentation, anchor);
    }
  }

  static void log_config(const config_t& config) {
    auto log = redlog::get_logger("w1script.preload");
    log.inf(
        "qbdipreload_on_run configured", redlog::field("script", config.script_path),
        redlog::field("script_args", static_cast<uint64_t>(config.script_args.size()))
    );
  }

  static runtime_t make_runtime(const config_t& config) { return make_script_runtime(config); }

  static bool run_main(runtime_t& runtime, QBDI::VM* vm, uint64_t start, uint64_t stop) {
    if (!runtime.session) {
      return false;
    }

    auto log = redlog::get_logger("w1script.preload");
    log.inf(
        "starting script session", redlog::field("start", "0x%llx", static_cast<unsigned long long>(start)),
        redlog::field("stop", "0x%llx", static_cast<unsigned long long>(stop))
    );

    return runtime.session->run(vm, start, stop, "main");
  }

  static void on_exit(runtime_t& runtime, const config_t& config, int status) {
    auto log = redlog::get_logger("w1script.preload");
    log.inf("qbdipreload_on_exit called", redlog::field("status", status));

    if (runtime.session) {
      runtime.session->export_output();
    }

    if (!config.script_path.empty()) {
      log.inf("script session completed", redlog::field("script", config.script_path));
    }

    log.inf("qbdipreload_on_exit completed");
  }

  static int on_start(void* main) {
    (void) main;
#if defined(_WIN32) || defined(WIN32)
    w1::common::allocate_windows_console();
#endif
    return QBDIPRELOAD_NOT_HANDLED;
  }

  static int on_premain(void* gpr_ctx, void* fpu_ctx) {
    (void) gpr_ctx;
    (void) fpu_ctx;
    return QBDIPRELOAD_NOT_HANDLED;
  }

  static int on_main(int argc, char** argv) {
    (void) argc;
    (void) argv;
    return QBDIPRELOAD_NOT_HANDLED;
  }
};

} // namespace w1::tracers::script

```

`src/tracers/w1script/thread/script_tracer.cpp`:

```cpp
#include "script_tracer.hpp"

#include "w1instrument/tracer/event.hpp"

#include <utility>

namespace w1::tracers::script {

script_tracer::script_tracer() : logger_(redlog::get_logger("w1script.thread")) {}

script_tracer::script_tracer(std::shared_ptr<script_engine> engine, script_config config)
    : config_(std::move(config)), logger_(redlog::get_logger("w1script.thread")) {
  (void) engine;
}

bool script_tracer::ensure_initialized(w1::trace_context& ctx, const w1::thread_event* event) {
  if (initialized_) {
    return true;
  }
  if (failed_) {
    return false;
  }

  if (config_.script_path.empty()) {
    config_ = script_config::from_environment();
  }

  if (!config_.is_valid()) {
    logger_.err("invalid configuration", redlog::field("script_path", config_.script_path));
    failed_ = true;
    return false;
  }

  QBDI::VM* vm = ctx.vm();
  if (!vm) {
    logger_.err("vm instance is null");
    failed_ = true;
    return false;
  }

  std::string thread_name = "main";
  if (event && event->name) {
    thread_name = event->name;
  }

  ctx.modules().refresh();

  context_ = std::make_unique<runtime::script_context>(
      vm, config_, &ctx.modules(), &ctx.memory(), ctx.thread_id(), thread_name
  );
  runtime_ = std::make_unique<runtime::lua_runtime>(*context_);

  if (!runtime_->initialize()) {
    logger_.err("lua runtime initialization failed");
    runtime_.reset();
    context_.reset();
    failed_ = true;
    return false;
  }

  logger_.inf("script runtime initialized", redlog::field("script", config_.script_path));
  initialized_ = true;
  return true;
}

QBDI::VMAction script_tracer::on_thread_start(w1::trace_context& ctx, const w1::thread_event& event) {
  if (!ensure_initialized(ctx, &event)) {
    return QBDI::VMAction::CONTINUE;
  }

  return runtime_->dispatch_thread_start(event);
}

QBDI::VMAction script_tracer::on_thread_stop(w1::trace_context& ctx, const w1::thread_event& event) {
  (void) ctx;
  if (!initialized_ || !runtime_) {
    return QBDI::VMAction::CONTINUE;
  }

  QBDI::VMAction action = runtime_->dispatch_thread_stop(event);
  runtime_->shutdown();
  runtime_.reset();
  context_.reset();
  initialized_ = false;
  failed_ = false;

  return action;
}

QBDI::VMAction script_tracer::on_vm_start(
    w1::trace_context& ctx, const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  if (!ensure_initialized(ctx, nullptr)) {
    return QBDI::VMAction::CONTINUE;
  }

  return runtime_->dispatch_vm_start(event, vm, state, gpr, fpr);
}

QBDI::VMAction script_tracer::on_vm_stop(
    w1::trace_context& ctx, const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  (void) ctx;
  if (!initialized_ || !runtime_) {
    return QBDI::VMAction::CONTINUE;
  }

  return runtime_->dispatch_vm_stop(event, vm, state, gpr, fpr);
}

QBDI::VMAction script_tracer::on_instruction_pre(
    w1::trace_context& ctx, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  if (!ensure_initialized(ctx, nullptr)) {
    return QBDI::VMAction::CONTINUE;
  }

  return runtime_->dispatch_instruction_pre(event, vm, gpr, fpr);
}

QBDI::VMAction script_tracer::on_instruction_post(
    w1::trace_context& ctx, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  if (!ensure_initialized(ctx, nullptr)) {
    return QBDI::VMAction::CONTINUE;
  }

  return runtime_->dispatch_instruction_post(event, vm, gpr, fpr);
}

QBDI::VMAction script_tracer::on_basic_block_entry(
    w1::trace_context& ctx, const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  if (!ensure_initialized(ctx, nullptr)) {
    return QBDI::VMAction::CONTINUE;
  }

  return runtime_->dispatch_basic_block_entry(event, vm, state, gpr, fpr);
}

QBDI::VMAction script_tracer::on_basic_block_exit(
    w1::trace_context& ctx, const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  if (!ensure_initialized(ctx, nullptr)) {
    return QBDI::VMAction::CONTINUE;
  }

  return runtime_->dispatch_basic_block_exit(event, vm, state, gpr, fpr);
}

QBDI::VMAction script_tracer::on_exec_transfer_call(
    w1::trace_context& ctx, const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  if (!ensure_initialized(ctx, nullptr)) {
    return QBDI::VMAction::CONTINUE;
  }

  return runtime_->dispatch_exec_transfer_call(event, vm, state, gpr, fpr);
}

QBDI::VMAction script_tracer::on_exec_transfer_return(
    w1::trace_context& ctx, const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  if (!ensure_initialized(ctx, nullptr)) {
    return QBDI::VMAction::CONTINUE;
  }

  return runtime_->dispatch_exec_transfer_return(event, vm, state, gpr, fpr);
}

QBDI::VMAction script_tracer::on_memory(
    w1::trace_context& ctx, const w1::memory_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  if (!ensure_initialized(ctx, nullptr)) {
    return QBDI::VMAction::CONTINUE;
  }

  return runtime_->dispatch_memory(event, vm, gpr, fpr);
}

} // namespace w1::tracers::script

```

`src/tracers/w1script/thread/script_tracer.hpp`:

```hpp
#pragma once

#include "runtime/lua_runtime.hpp"
#include "runtime/script_context.hpp"
#include "config/script_config.hpp"

#include "w1instrument/tracer/event.hpp"
#include "w1instrument/tracer/trace_context.hpp"

#include <QBDI.h>
#include <memory>
#include <redlog.hpp>

namespace w1::tracers::script {

class script_engine;

class script_tracer {
public:
  script_tracer();
  script_tracer(std::shared_ptr<script_engine> engine, script_config config);

  const char* name() const { return "w1script"; }
  static constexpr w1::event_mask requested_events() {
    using w1::event_kind;
    using w1::event_mask;

    event_mask mask = 0;
    mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::thread_start));
    mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::thread_stop));
    mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::vm_start));
    mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::vm_stop));
    mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::instruction_pre));
    mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::instruction_post));
    mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::basic_block_entry));
    mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::basic_block_exit));
    mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::exec_transfer_call));
    mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::exec_transfer_return));
    mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::memory_read));
    mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::memory_write));
    mask = w1::event_mask_or(mask, w1::event_mask_of(event_kind::memory_read_write));
    return mask;
  }

  QBDI::VMAction on_thread_start(w1::trace_context& ctx, const w1::thread_event& event);
  QBDI::VMAction on_thread_stop(w1::trace_context& ctx, const w1::thread_event& event);

  QBDI::VMAction on_vm_start(
      w1::trace_context& ctx, const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );
  QBDI::VMAction on_vm_stop(
      w1::trace_context& ctx, const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );

  QBDI::VMAction on_instruction_pre(
      w1::trace_context& ctx, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );
  QBDI::VMAction on_instruction_post(
      w1::trace_context& ctx, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );

  QBDI::VMAction on_basic_block_entry(
      w1::trace_context& ctx, const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );
  QBDI::VMAction on_basic_block_exit(
      w1::trace_context& ctx, const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );

  QBDI::VMAction on_exec_transfer_call(
      w1::trace_context& ctx, const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );
  QBDI::VMAction on_exec_transfer_return(
      w1::trace_context& ctx, const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );

  QBDI::VMAction on_memory(
      w1::trace_context& ctx, const w1::memory_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  );

private:
  bool ensure_initialized(w1::trace_context& ctx, const w1::thread_event* event);

  script_config config_{};
  redlog::logger logger_;
  bool initialized_ = false;
  bool failed_ = false;
  std::unique_ptr<runtime::script_context> context_;
  std::unique_ptr<runtime::lua_runtime> runtime_;
};

} // namespace w1::tracers::script

```

`src/tracers/w1xfer/CMakeLists.txt`:

```txt
w1_add_tracer(w1xfer
    SOURCES
        entrypoints/preload.cpp
        thread/transfer_tracer.cpp
        engine/transfer_engine.cpp
        io/transfer_writer_jsonl.cpp
    LIBS w1analysis w1formats
)

```

`src/tracers/w1xfer/config/transfer_config.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <string>

#include "w1instrument/config/tracer_common_config.hpp"
#include "w1base/env_config.hpp"

namespace w1xfer {

struct transfer_capture_config {
  bool registers = true;
  bool stack = true;
};

struct transfer_enrich_config {
  bool modules = true;
  bool symbols = true;
  bool analyze_apis = false;
  size_t api_argument_count = 0;
};

struct transfer_output_config {
  std::string path = "";
  bool emit_metadata = true;
};

struct transfer_config {
  w1::instrument::config::tracer_common_config common{};
  w1::instrument::config::thread_attach_policy threads = w1::instrument::config::thread_attach_policy::auto_attach;
  transfer_capture_config capture;
  transfer_enrich_config enrich;
  transfer_output_config output;

  static transfer_config from_environment() {
    w1::util::env_config loader("W1XFER");

    transfer_config config;
    config.common = w1::instrument::config::load_common(loader);
    config.threads = w1::instrument::config::load_thread_attach_policy(
        loader, w1::instrument::config::thread_attach_policy::auto_attach
    );

    config.capture.registers = loader.get<bool>("CAPTURE_REGISTERS", true);
    config.capture.stack = loader.get<bool>("CAPTURE_STACK", true);

    config.enrich.modules = loader.get<bool>("ENRICH_MODULES", true);
    config.enrich.symbols = loader.get<bool>("ENRICH_SYMBOLS", true);
    config.enrich.analyze_apis = loader.get<bool>("ANALYZE_APIS", false);
    config.enrich.api_argument_count = static_cast<size_t>(loader.get<uint64_t>("API_ARG_COUNT", 0));

    config.output.path = loader.get<std::string>("OUTPUT", "");
    config.output.emit_metadata = loader.get<bool>("EMIT_METADATA", true);

    if (config.enrich.analyze_apis) {
      config.enrich.modules = true;
      config.enrich.symbols = true;
    }

    return config;
  }
};

} // namespace w1xfer

```

`src/tracers/w1xfer/engine/transfer_engine.cpp`:

```cpp
#include "transfer_engine.hpp"

#include <chrono>
#include <string>
#include <utility>

namespace w1xfer {
namespace {

uint64_t current_timestamp() {
  return static_cast<uint64_t>(
      std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::steady_clock::now().time_since_epoch()).count()
  );
}

uint64_t read_link_register(const QBDI::GPRState* gpr) {
#if defined(QBDI_ARCH_AARCH64)
  return gpr ? gpr->lr : 0;
#elif defined(QBDI_ARCH_ARM)
  return gpr ? gpr->r14 : 0;
#else
  (void) gpr;
  return 0;
#endif
}

uint64_t resolve_callsite(const QBDI::GPRState* gpr, const std::optional<w1::util::stack_info>& stack_info) {
  uint64_t link = read_link_register(gpr);
  if (link != 0) {
    return link;
  }
  if (stack_info && stack_info->return_address != 0) {
    return stack_info->return_address;
  }
  return 0;
}

transfer_registers to_registers(const w1::util::register_state& regs) {
  transfer_registers out;
  out.values = regs.get_all_registers();
  return out;
}

transfer_stack to_stack(const w1::util::stack_info& stack) {
  transfer_stack out;
  out.stack_pointer = stack.stack_pointer;
  out.frame_pointer = stack.frame_pointer;
  out.return_address = stack.return_address;
  out.values.reserve(stack.values.size());
  for (const auto& entry : stack.values) {
    if (entry.is_valid) {
      out.values.push_back(entry.value);
    }
  }
  return out;
}

} // namespace

transfer_engine::transfer_engine(transfer_config config) : config_(std::move(config)) {
  capture_registers_ = config_.capture.registers || config_.capture.stack || config_.enrich.analyze_apis;
  capture_stack_ = config_.capture.stack;
  enrich_modules_ = config_.enrich.modules;
  enrich_symbols_ = config_.enrich.symbols;
  analyze_apis_ = config_.enrich.analyze_apis;
  emit_metadata_ = config_.output.emit_metadata;

  if (!config_.output.path.empty()) {
    writer_ = std::make_unique<transfer_writer_jsonl>(config_.output.path, config_.output.emit_metadata);
  }
}

transfer_engine::transfer_thread_state transfer_engine::make_thread_state() const {
  transfer_thread_state state;
  if (analyze_apis_) {
    w1::analysis::abi_dispatcher_config cfg;
    cfg.enable_stack_reads = true;
    state.abi_dispatcher = std::make_unique<w1::analysis::abi_dispatcher>(cfg);
  }
  return state;
}

void transfer_engine::configure(w1::runtime::module_catalog& modules) {
  modules_ = &modules;
  if (enrich_modules_ || enrich_symbols_ || emit_metadata_) {
    symbol_lookup_.set_module_catalog(modules_);
  }
}

bool transfer_engine::export_output() {
  std::lock_guard<std::mutex> lock(writer_mutex_);
  const bool had_output = writer_ && writer_->is_open();
  if (writer_) {
    writer_->flush();
    writer_->close();
    writer_.reset();
  }
  return had_output;
}

void transfer_engine::update_call_depth(transfer_stats& stats, transfer_type type) {
  if (type == transfer_type::CALL) {
    stats.current_call_depth++;
    if (stats.current_call_depth > stats.max_call_depth) {
      stats.max_call_depth = stats.current_call_depth;
    }
  } else if (type == transfer_type::RETURN && stats.current_call_depth > 0) {
    stats.current_call_depth--;
  }
}

void transfer_engine::record_call(
    transfer_thread_state& state, const w1::trace_context& ctx, const w1::exec_transfer_event& event,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  (void) fpr;
  record_transfer(state, transfer_type::CALL, ctx, event, gpr, fpr);
}

void transfer_engine::record_return(
    transfer_thread_state& state, const w1::trace_context& ctx, const w1::exec_transfer_event& event,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  (void) fpr;
  record_transfer(state, transfer_type::RETURN, ctx, event, gpr, fpr);
}

std::optional<transfer_endpoint> transfer_engine::resolve_endpoint(uint64_t address) const {
  return build_endpoint(address);
}

void transfer_engine::merge_thread_stats(const transfer_thread_state& state) {
  std::lock_guard<std::mutex> lock(stats_mutex_);

  stats_.total_calls += state.stats.total_calls;
  stats_.total_returns += state.stats.total_returns;
  if (state.stats.max_call_depth > stats_.max_call_depth) {
    stats_.max_call_depth = state.stats.max_call_depth;
  }

  if (!state.unique_call_targets.empty()) {
    unique_call_targets_.insert(state.unique_call_targets.begin(), state.unique_call_targets.end());
    stats_.unique_call_targets = unique_call_targets_.size();
  }
  if (!state.unique_return_sources.empty()) {
    unique_return_sources_.insert(state.unique_return_sources.begin(), state.unique_return_sources.end());
    stats_.unique_return_sources = unique_return_sources_.size();
  }
}

transfer_stats transfer_engine::stats() const {
  std::lock_guard<std::mutex> lock(stats_mutex_);
  return stats_;
}

void transfer_engine::write_record(const transfer_record& record) {
  std::lock_guard<std::mutex> lock(writer_mutex_);
  if (!writer_ || !writer_->is_open()) {
    return;
  }

  writer_->write_record(record);
}

void transfer_engine::ensure_metadata(const w1::runtime::module_catalog& modules) {
  if (!emit_metadata_ || !writer_ || !writer_->is_open()) {
    return;
  }

  std::call_once(metadata_once_, [&]() {
    std::lock_guard<std::mutex> lock(writer_mutex_);
    if (writer_) {
      writer_->ensure_metadata(modules);
    }
  });
}

void transfer_engine::record_transfer(
    transfer_thread_state& state, transfer_type type, const w1::trace_context& ctx,
    const w1::exec_transfer_event& event, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  (void) fpr;

  if (type == transfer_type::CALL) {
    state.stats.total_calls++;
    update_call_depth(state.stats, transfer_type::CALL);
    state.unique_call_targets.insert(event.target_address);
    state.stats.unique_call_targets = state.unique_call_targets.size();
  } else {
    state.stats.total_returns++;
    update_call_depth(state.stats, transfer_type::RETURN);
    state.unique_return_sources.insert(event.source_address);
    state.stats.unique_return_sources = state.unique_return_sources.size();
  }

  ensure_metadata(ctx.modules());

  std::optional<w1::util::register_state> regs;
  if (capture_registers_) {
    regs = w1::util::register_capturer::capture(gpr);
  }

  std::optional<w1::util::stack_info> stack_info;
  if (capture_stack_ && regs && regs->get_architecture() != w1::util::register_state::architecture::unknown) {
    stack_info = w1::util::stack_capturer::capture(ctx.memory(), *regs);
  }

  uint64_t resolved_source = event.source_address;
  if (type == transfer_type::CALL) {
    uint64_t callsite = resolve_callsite(gpr, stack_info);
    if (callsite != 0) {
      resolved_source = callsite;
    }
  }

  transfer_record record;
  record.event.type = type;
  record.event.source_address = resolved_source;
  record.event.target_address = event.target_address;
  record.event.instruction_index = instruction_index_.fetch_add(1, std::memory_order_relaxed);
  record.event.timestamp = current_timestamp();
  record.event.thread_id = ctx.thread_id();
  record.event.call_depth = state.stats.current_call_depth;

  if (config_.capture.registers && regs) {
    record.registers = to_registers(*regs);
  }

  if (capture_stack_ && stack_info) {
    record.stack = to_stack(*stack_info);
  }

  if (enrich_modules_ || enrich_symbols_) {
    record.source = build_endpoint(resolved_source);
    record.target = build_endpoint(event.target_address);
  }

  if (analyze_apis_) {
    record.api = analyze_api_event(type, state, ctx.memory(), resolved_source, event.target_address, gpr);
  }

  write_record(record);
}

std::optional<transfer_endpoint> transfer_engine::build_endpoint(uint64_t address) const {
  if (!modules_) {
    return std::nullopt;
  }

  if (!enrich_modules_ && !enrich_symbols_) {
    return std::nullopt;
  }

  transfer_endpoint endpoint;
  endpoint.address = address;

  if (const auto* module = modules_->find_containing(address)) {
    if (enrich_modules_) {
      endpoint.module_name = module->name;
      endpoint.module_offset = address - module->base_address;
    }
  }

  if (enrich_symbols_) {
    if (auto symbol = symbol_lookup_.resolve(address); symbol && symbol->has_symbol) {
      transfer_symbol out;
      out.module_name = symbol->module_name;
      out.symbol_name = symbol->symbol_name;
      out.demangled_name = symbol->demangled_name;
      out.symbol_offset = symbol->symbol_offset;
      out.module_offset = symbol->module_offset;
      out.is_exported = symbol->is_exported;
      out.is_imported = symbol->is_imported;
      endpoint.symbol = out;

      if (endpoint.module_name.empty()) {
        endpoint.module_name = symbol->module_name;
        endpoint.module_offset = symbol->module_offset;
      }
    }
  }

  if (endpoint.module_name.empty() && !endpoint.symbol.has_value()) {
    return std::nullopt;
  }

  return endpoint;
}

std::optional<transfer_api_info> transfer_engine::analyze_api_event(
    transfer_type type, transfer_thread_state& state, const w1::util::memory_reader& memory, uint64_t source_addr,
    uint64_t target_addr, QBDI::GPRState* gpr
) {
  (void) source_addr;
  (void) target_addr;

  if (!state.abi_dispatcher || !gpr) {
    return std::nullopt;
  }

  transfer_api_info info;
  info.category = "raw";
  info.description = "raw abi values";
  info.analysis_complete = false;
  info.formatted_call = "";

  if (type == transfer_type::CALL) {
    size_t arg_count = config_.enrich.api_argument_count;
    if (arg_count == 0) {
      arg_count = default_argument_count(*state.abi_dispatcher);
    }

    auto args = state.abi_dispatcher->extract_arguments(memory, gpr, arg_count);
    info.arguments.reserve(args.size());
    for (size_t i = 0; i < args.size(); ++i) {
      const auto& arg = args[i];
      if (!arg.is_valid) {
        continue;
      }
      transfer_api_argument out;
      out.raw_value = arg.raw_value;
      out.name = "arg" + std::to_string(i);
      out.type = "raw";
      out.interpreted_value = "";
      out.is_pointer = false;
      info.arguments.push_back(std::move(out));
    }
  } else {
    transfer_api_return ret;
    ret.raw_value = state.abi_dispatcher->extract_return_value(gpr);
    ret.type = "raw";
    ret.interpreted_value = "";
    ret.is_pointer = false;
    ret.is_null = ret.raw_value == 0;
    info.return_value = ret;
    info.has_return_value = true;
  }

  return info;
}

size_t transfer_engine::default_argument_count(const w1::analysis::abi_dispatcher& dispatcher) const {
  switch (dispatcher.kind()) {
  case w1::analysis::abi_kind::system_v_amd64:
    return 6;
  case w1::analysis::abi_kind::windows_amd64:
    return 4;
  case w1::analysis::abi_kind::aarch64:
    return 8;
  case w1::analysis::abi_kind::x86:
    return 4;
  default:
    return 0;
  }
}

} // namespace w1xfer

```

`src/tracers/w1xfer/engine/transfer_engine.hpp`:

```hpp
#pragma once

#include <atomic>
#include <memory>
#include <mutex>
#include <optional>
#include <unordered_set>

#include <QBDI.h>

#include "w1analysis/abi_dispatcher.hpp"
#include "w1analysis/symbol_lookup.hpp"
#include "w1instrument/tracer/types.hpp"
#include "w1instrument/tracer/trace_context.hpp"
#include "w1runtime/module_catalog.hpp"
#include "w1runtime/memory_reader.hpp"
#include "w1runtime/register_capture.hpp"
#include "w1runtime/stack_capture.hpp"

#include "config/transfer_config.hpp"
#include "io/transfer_writer_jsonl.hpp"
#include "model/transfer_types.hpp"

namespace w1xfer {

class transfer_engine {
public:
  explicit transfer_engine(transfer_config config);

  void configure(w1::runtime::module_catalog& modules);

  struct transfer_thread_state {
    transfer_stats stats{};
    std::unordered_set<uint64_t> unique_call_targets;
    std::unordered_set<uint64_t> unique_return_sources;
    std::unique_ptr<w1::analysis::abi_dispatcher> abi_dispatcher{};
  };

  transfer_thread_state make_thread_state() const;

  bool export_output();

  void record_call(
      transfer_thread_state& state, const w1::trace_context& ctx, const w1::exec_transfer_event& event,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );
  void record_return(
      transfer_thread_state& state, const w1::trace_context& ctx, const w1::exec_transfer_event& event,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );

  std::optional<transfer_endpoint> resolve_endpoint(uint64_t address) const;

  void merge_thread_stats(const transfer_thread_state& state);
  transfer_stats stats() const;

  bool capture_registers() const { return capture_registers_; }
  bool capture_stack() const { return capture_stack_; }
  bool enrich_modules() const { return enrich_modules_; }
  bool enrich_symbols() const { return enrich_symbols_; }
  bool analyze_apis() const { return analyze_apis_; }
  bool emit_metadata() const { return emit_metadata_; }

private:
  void update_call_depth(transfer_stats& stats, transfer_type type);
  void record_transfer(
      transfer_thread_state& state, transfer_type type, const w1::trace_context& ctx,
      const w1::exec_transfer_event& event, QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );
  void write_record(const transfer_record& record);
  void ensure_metadata(const w1::runtime::module_catalog& modules);

  std::optional<transfer_endpoint> build_endpoint(uint64_t address) const;
  std::optional<transfer_api_info> analyze_api_event(
      transfer_type type, transfer_thread_state& state, const w1::util::memory_reader& memory, uint64_t source_addr,
      uint64_t target_addr, QBDI::GPRState* gpr
  );

  size_t default_argument_count(const w1::analysis::abi_dispatcher& dispatcher) const;

  transfer_config config_;
  mutable std::mutex stats_mutex_{};
  transfer_stats stats_{};
  std::unordered_set<uint64_t> unique_call_targets_{};
  std::unordered_set<uint64_t> unique_return_sources_{};
  std::atomic<uint64_t> instruction_index_{0};

  const w1::runtime::module_catalog* modules_ = nullptr;

  w1::analysis::symbol_lookup symbol_lookup_{};
  std::unique_ptr<transfer_writer_jsonl> writer_{};

  std::once_flag metadata_once_{};
  mutable std::mutex writer_mutex_{};

  bool capture_registers_ = false;
  bool capture_stack_ = false;
  bool enrich_modules_ = false;
  bool enrich_symbols_ = false;
  bool analyze_apis_ = false;
  bool emit_metadata_ = false;
};

} // namespace w1xfer

```

`src/tracers/w1xfer/entrypoints/preload.cpp`:

```cpp
#include "QBDIPreload.h"

#include "transfer_recipe.hpp"
#include "w1instrument/preload/entrypoints.hpp"

extern "C" {

QBDIPRELOAD_INIT;

QBDI_EXPORT int qbdipreload_on_run(QBDI::VMInstanceRef vm, QBDI::rword start, QBDI::rword stop) {
  return w1::instrument::preload_on_run<w1xfer::transfer_recipe>(vm, start, stop);
}

QBDI_EXPORT int qbdipreload_on_exit(int status) {
  return w1::instrument::preload_on_exit<w1xfer::transfer_recipe>(status);
}

QBDI_EXPORT int qbdipreload_on_start(void* main) {
  return w1::instrument::preload_on_start<w1xfer::transfer_recipe>(main);
}

QBDI_EXPORT int qbdipreload_on_premain(void* gpr_ctx, void* fpu_ctx) {
  return w1::instrument::preload_on_premain<w1xfer::transfer_recipe>(gpr_ctx, fpu_ctx);
}

QBDI_EXPORT int qbdipreload_on_main(int argc, char** argv) {
  return w1::instrument::preload_on_main<w1xfer::transfer_recipe>(argc, argv);
}

} // extern "C"

```

`src/tracers/w1xfer/io/transfer_writer_jsonl.cpp`:

```cpp
#include "transfer_writer_jsonl.hpp"

#include <sstream>
#include <string_view>

namespace w1xfer {
namespace {

void append_field(std::stringstream& json, bool& first, const std::string& field) {
  if (!first) {
    json << ",";
  }
  json << field;
  first = false;
}

std::string escape(std::string_view value) {
  std::string out;
  out.reserve(value.size());
  for (char ch : value) {
    switch (ch) {
    case '"':
      out += "\\\"";
      break;
    case '\\':
      out += "\\\\";
      break;
    case '\b':
      out += "\\b";
      break;
    case '\f':
      out += "\\f";
      break;
    case '\n':
      out += "\\n";
      break;
    case '\r':
      out += "\\r";
      break;
    case '\t':
      out += "\\t";
      break;
    default: {
      unsigned char uch = static_cast<unsigned char>(ch);
      if (uch < 0x20) {
        constexpr char hex[] = "0123456789abcdef";
        out += "\\u00";
        out += hex[(uch >> 4) & 0xF];
        out += hex[uch & 0xF];
      } else {
        out += ch;
      }
      break;
    }
    }
  }
  return out;
}

} // namespace

transfer_writer_jsonl::transfer_writer_jsonl(const std::string& output_path, bool emit_metadata)
    : emit_metadata_(emit_metadata) {
  if (!output_path.empty()) {
    writer_ = std::make_unique<w1::io::jsonl_writer>(output_path);
    if (!writer_->is_open()) {
      writer_.reset();
    }
  }
}

bool transfer_writer_jsonl::is_open() const { return writer_ && writer_->is_open(); }

void transfer_writer_jsonl::ensure_metadata(const w1::runtime::module_catalog& modules) {
  if (!emit_metadata_ || metadata_written_ || !is_open()) {
    return;
  }

  write_metadata(modules);
  metadata_written_ = true;
}

void transfer_writer_jsonl::write_record(const transfer_record& record) {
  if (!is_open()) {
    return;
  }

  write_event(record);
}

void transfer_writer_jsonl::flush() {
  if (writer_) {
    writer_->flush();
  }
}

void transfer_writer_jsonl::close() {
  if (!writer_) {
    return;
  }

  writer_->close();
  writer_.reset();
  metadata_written_ = false;
}

void transfer_writer_jsonl::write_metadata(const w1::runtime::module_catalog& modules) {
  if (!is_open()) {
    return;
  }

  std::stringstream json;
  json << "{\"type\":\"metadata\",\"tracer\":\"w1xfer\",\"version\":2";
  json << ",\"modules\":[";

  bool first = true;
  size_t module_id = 0;
  for (const auto& mod : modules.list_modules()) {
    if (!first) {
      json << ",";
    }
    first = false;

    json << "{\"id\":" << module_id++ << ",\"name\":\"" << escape(mod.name) << "\""
         << ",\"path\":\"" << escape(mod.path) << "\""
         << ",\"base\":" << mod.base_address << ",\"size\":" << mod.size
         << ",\"is_system\":" << (mod.is_system ? "true" : "false") << "}";
  }

  json << "]}";
  writer_->write_line(json.str());
}

void transfer_writer_jsonl::write_event(const transfer_record& record) {
  std::stringstream json;
  json << "{\"type\":\"event\"";
  json << ",\"event\":\"" << (record.event.type == transfer_type::CALL ? "call" : "return") << "\"";
  json << ",\"source_address\":" << record.event.source_address;
  json << ",\"target_address\":" << record.event.target_address;
  json << ",\"instruction_index\":" << record.event.instruction_index;
  json << ",\"timestamp\":" << record.event.timestamp;
  json << ",\"thread_id\":" << record.event.thread_id;
  json << ",\"call_depth\":" << record.event.call_depth;

  bool first = false;

  if (record.source) {
    std::stringstream src_json;
    src_json << "{";
    bool src_first = true;
    if (!record.source->module_name.empty()) {
      append_field(src_json, src_first, "\"module\":\"" + escape(record.source->module_name) + "\"");
      append_field(src_json, src_first, "\"module_offset\":" + std::to_string(record.source->module_offset));
    }
    if (record.source->symbol && !record.source->symbol->symbol_name.empty()) {
      std::stringstream sym_json;
      sym_json << "{";
      bool sym_first = true;
      append_field(sym_json, sym_first, "\"name\":\"" + escape(record.source->symbol->symbol_name) + "\"");
      if (!record.source->symbol->demangled_name.empty()) {
        append_field(sym_json, sym_first, "\"demangled\":\"" + escape(record.source->symbol->demangled_name) + "\"");
      }
      append_field(sym_json, sym_first, "\"symbol_offset\":" + std::to_string(record.source->symbol->symbol_offset));
      append_field(sym_json, sym_first, "\"module_offset\":" + std::to_string(record.source->symbol->module_offset));
      append_field(
          sym_json, sym_first, "\"is_exported\":" + std::string(record.source->symbol->is_exported ? "true" : "false")
      );
      append_field(
          sym_json, sym_first, "\"is_imported\":" + std::string(record.source->symbol->is_imported ? "true" : "false")
      );
      sym_json << "}";
      append_field(src_json, src_first, "\"symbol\":" + sym_json.str());
    }
    src_json << "}";
    append_field(json, first, "\"source\":" + src_json.str());
  }

  if (record.target) {
    std::stringstream tgt_json;
    tgt_json << "{";
    bool tgt_first = true;
    if (!record.target->module_name.empty()) {
      append_field(tgt_json, tgt_first, "\"module\":\"" + escape(record.target->module_name) + "\"");
      append_field(tgt_json, tgt_first, "\"module_offset\":" + std::to_string(record.target->module_offset));
    }
    if (record.target->symbol && !record.target->symbol->symbol_name.empty()) {
      std::stringstream sym_json;
      sym_json << "{";
      bool sym_first = true;
      append_field(sym_json, sym_first, "\"name\":\"" + escape(record.target->symbol->symbol_name) + "\"");
      if (!record.target->symbol->demangled_name.empty()) {
        append_field(sym_json, sym_first, "\"demangled\":\"" + escape(record.target->symbol->demangled_name) + "\"");
      }
      append_field(sym_json, sym_first, "\"symbol_offset\":" + std::to_string(record.target->symbol->symbol_offset));
      append_field(sym_json, sym_first, "\"module_offset\":" + std::to_string(record.target->symbol->module_offset));
      append_field(
          sym_json, sym_first, "\"is_exported\":" + std::string(record.target->symbol->is_exported ? "true" : "false")
      );
      append_field(
          sym_json, sym_first, "\"is_imported\":" + std::string(record.target->symbol->is_imported ? "true" : "false")
      );
      sym_json << "}";
      append_field(tgt_json, tgt_first, "\"symbol\":" + sym_json.str());
    }
    tgt_json << "}";
    append_field(json, first, "\"target\":" + tgt_json.str());
  }

  if (record.registers && !record.registers->values.empty()) {
    std::stringstream regs_json;
    regs_json << "{";
    bool reg_first = true;
    for (const auto& [name, value] : record.registers->values) {
      if (!reg_first) {
        regs_json << ",";
      }
      regs_json << "\"" << escape(name) << "\":" << value;
      reg_first = false;
    }
    regs_json << "}";
    append_field(json, first, "\"registers\":" + regs_json.str());
  }

  if (record.stack) {
    std::stringstream stack_json;
    stack_json << "{";
    bool stack_first = true;
    append_field(stack_json, stack_first, "\"stack_pointer\":" + std::to_string(record.stack->stack_pointer));
    append_field(stack_json, stack_first, "\"frame_pointer\":" + std::to_string(record.stack->frame_pointer));
    append_field(stack_json, stack_first, "\"return_address\":" + std::to_string(record.stack->return_address));

    std::stringstream values_json;
    values_json << "[";
    for (size_t i = 0; i < record.stack->values.size(); ++i) {
      if (i > 0) {
        values_json << ",";
      }
      values_json << record.stack->values[i];
    }
    values_json << "]";

    append_field(stack_json, stack_first, "\"values\":" + values_json.str());
    stack_json << "}";
    append_field(json, first, "\"stack\":" + stack_json.str());
  }

  if (record.api) {
    std::stringstream api_json;
    api_json << "{";
    bool api_first = true;

    if (!record.api->category.empty()) {
      append_field(api_json, api_first, "\"category\":\"" + escape(record.api->category) + "\"");
    }
    if (!record.api->description.empty()) {
      append_field(api_json, api_first, "\"description\":\"" + escape(record.api->description) + "\"");
    }
    if (!record.api->formatted_call.empty()) {
      append_field(api_json, api_first, "\"formatted_call\":\"" + escape(record.api->formatted_call) + "\"");
    }

    append_field(
        api_json, api_first, "\"analysis_complete\":" + std::string(record.api->analysis_complete ? "true" : "false")
    );
    append_field(
        api_json, api_first, "\"has_return_value\":" + std::string(record.api->has_return_value ? "true" : "false")
    );

    if (!record.api->arguments.empty()) {
      std::stringstream args_json;
      args_json << "[";
      for (size_t i = 0; i < record.api->arguments.size(); ++i) {
        if (i > 0) {
          args_json << ",";
        }
        const auto& arg = record.api->arguments[i];
        args_json << "{\"name\":\"" << escape(arg.name) << "\""
                  << ",\"type\":\"" << escape(arg.type) << "\""
                  << ",\"raw_value\":" << arg.raw_value << ",\"interpreted_value\":\"" << escape(arg.interpreted_value)
                  << "\""
                  << ",\"is_pointer\":" << (arg.is_pointer ? "true" : "false") << "}";
      }
      args_json << "]";
      append_field(api_json, api_first, "\"arguments\":" + args_json.str());
    }

    if (record.api->return_value) {
      const auto& ret = record.api->return_value.value();
      std::stringstream ret_json;
      ret_json << "{\"type\":\"" << escape(ret.type) << "\""
               << ",\"raw_value\":" << ret.raw_value << ",\"interpreted_value\":\"" << escape(ret.interpreted_value)
               << "\""
               << ",\"is_pointer\":" << (ret.is_pointer ? "true" : "false")
               << ",\"is_null\":" << (ret.is_null ? "true" : "false") << "}";
      append_field(api_json, api_first, "\"return_value\":" + ret_json.str());
    }

    api_json << "}";
    append_field(json, first, "\"api\":" + api_json.str());
  }

  json << "}";
  writer_->write_line(json.str());
}

} // namespace w1xfer

```

`src/tracers/w1xfer/io/transfer_writer_jsonl.hpp`:

```hpp
#pragma once

#include <memory>
#include <string>

#include "w1formats/jsonl_writer.hpp"
#include "w1runtime/module_catalog.hpp"

#include "model/transfer_types.hpp"

namespace w1xfer {

class transfer_writer_jsonl {
public:
  transfer_writer_jsonl(const std::string& output_path, bool emit_metadata);

  bool is_open() const;

  void ensure_metadata(const w1::runtime::module_catalog& modules);
  void write_record(const transfer_record& record);
  void flush();
  void close();

private:
  std::unique_ptr<w1::io::jsonl_writer> writer_;
  bool emit_metadata_ = true;
  bool metadata_written_ = false;

  void write_metadata(const w1::runtime::module_catalog& modules);
  void write_event(const transfer_record& record);
};

} // namespace w1xfer

```

`src/tracers/w1xfer/model/transfer_types.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include <string>
#include <unordered_map>
#include <vector>

namespace w1xfer {

enum class transfer_type { CALL = 0, RETURN = 1 };

struct transfer_event {
  transfer_type type = transfer_type::CALL;
  uint64_t source_address = 0;
  uint64_t target_address = 0;
  uint64_t instruction_index = 0;
  uint64_t timestamp = 0;
  uint64_t thread_id = 0;
  uint64_t call_depth = 0;
};

struct transfer_registers {
  std::unordered_map<std::string, uint64_t> values;
};

struct transfer_stack {
  uint64_t stack_pointer = 0;
  uint64_t frame_pointer = 0;
  uint64_t return_address = 0;
  std::vector<uint64_t> values;
};

struct transfer_symbol {
  std::string module_name;
  std::string symbol_name;
  std::string demangled_name;
  uint64_t symbol_offset = 0;
  uint64_t module_offset = 0;
  bool is_exported = false;
  bool is_imported = false;
};

struct transfer_endpoint {
  uint64_t address = 0;
  std::string module_name;
  uint64_t module_offset = 0;
  std::optional<transfer_symbol> symbol;
};

struct transfer_api_argument {
  uint64_t raw_value = 0;
  std::string name;
  std::string type;
  std::string interpreted_value;
  bool is_pointer = false;
};

struct transfer_api_return {
  uint64_t raw_value = 0;
  std::string type;
  std::string interpreted_value;
  bool is_pointer = false;
  bool is_null = false;
};

struct transfer_api_info {
  std::string category;
  std::string description;
  std::string formatted_call;
  bool analysis_complete = false;
  bool has_return_value = false;
  std::vector<transfer_api_argument> arguments;
  std::optional<transfer_api_return> return_value;
};

struct transfer_record {
  transfer_event event;
  std::optional<transfer_registers> registers;
  std::optional<transfer_stack> stack;
  std::optional<transfer_endpoint> source;
  std::optional<transfer_endpoint> target;
  std::optional<transfer_api_info> api;
};

struct transfer_stats {
  uint64_t total_calls = 0;
  uint64_t total_returns = 0;
  uint64_t unique_call_targets = 0;
  uint64_t unique_return_sources = 0;
  uint64_t max_call_depth = 0;
  uint64_t current_call_depth = 0;
};

} // namespace w1xfer

```

`src/tracers/w1xfer/runtime/transfer_runtime.hpp`:

```hpp
#pragma once

#include <memory>
#include <utility>

#include "config/transfer_config.hpp"
#include "engine/transfer_engine.hpp"
#include "thread/transfer_tracer.hpp"
#include "w1instrument/tracer/runtime.hpp"
#include "w1runtime/thread_catalog.hpp"

namespace w1xfer {

struct transfer_traits {
  using tracer_type = transfer_tracer;
  using process_config = typename w1::instrument::process_session<tracer_type>::config;

  static process_config make_process_config(const transfer_config& config, bool owns_observer) {
    process_config session_config{};
    session_config.instrumentation = config.common.instrumentation;
    session_config.attach_new_threads = config.threads == w1::instrument::config::thread_attach_policy::auto_attach;
    session_config.refresh_on_module_events = true;
    session_config.owns_observer = owns_observer;
    return session_config;
  }

  static tracer_type make_tracer(
      std::shared_ptr<transfer_engine> engine, const transfer_config& config, const w1::runtime::thread_info& info
  ) {
    return tracer_type(std::move(engine), config, info);
  }

  static void configure_engine(transfer_engine& engine, w1::runtime::module_catalog& modules) {
    engine.configure(modules);
  }

  static bool export_output(transfer_engine& engine) { return engine.export_output(); }
};

struct transfer_runtime {
  using session_type =
      w1::instrument::tracer_runtime<transfer_engine, transfer_tracer, transfer_config, transfer_traits>;

  std::unique_ptr<session_type> session;
};

inline transfer_runtime make_transfer_runtime(transfer_config config) {
  transfer_runtime runtime;
  runtime.session = std::make_unique<transfer_runtime::session_type>(std::move(config));
  return runtime;
}

} // namespace w1xfer

```

`src/tracers/w1xfer/thread/transfer_tracer.cpp`:

```cpp
#include "transfer_tracer.hpp"

#include <sstream>
#include <utility>

#include "w1runtime/thread_catalog.hpp"

namespace w1xfer {
namespace {

std::string format_hex(uint64_t value) {
  std::ostringstream oss;
  oss << "0x" << std::hex << value;
  return oss.str();
}

std::string format_symbol_name(const transfer_symbol& symbol) {
  std::string name = symbol.demangled_name.empty() ? symbol.symbol_name : symbol.demangled_name;
  if (symbol.symbol_offset != 0) {
    name += "+";
    name += format_hex(symbol.symbol_offset);
  }
  return name;
}

struct endpoint_summary {
  std::string module;
  std::string symbol;
};

endpoint_summary describe_endpoint(const transfer_engine& engine, const transfer_config& config, uint64_t address) {
  endpoint_summary out;
  if (!config.enrich.modules && !config.enrich.symbols) {
    return out;
  }

  auto endpoint = engine.resolve_endpoint(address);
  if (!endpoint) {
    return out;
  }

  if (!endpoint->module_name.empty()) {
    out.module = endpoint->module_name;
    if (!endpoint->symbol && endpoint->module_offset != 0) {
      out.module += "+";
      out.module += format_hex(endpoint->module_offset);
    }
  }

  if (endpoint->symbol) {
    out.symbol = format_symbol_name(*endpoint->symbol);
  }

  return out;
}

void log_transfer_event(
    redlog::logger& log, const char* label, const transfer_engine& engine, const transfer_config& config,
    uint64_t source, uint64_t target
) {
  endpoint_summary source_info = describe_endpoint(engine, config, source);
  endpoint_summary target_info = describe_endpoint(engine, config, target);

  if (!source_info.module.empty() || !target_info.module.empty() || !source_info.symbol.empty() ||
      !target_info.symbol.empty()) {
    log.vrb(
        label, redlog::field("source", "0x%016llx", source), redlog::field("target", "0x%016llx", target),
        redlog::field("source_module", source_info.module), redlog::field("source_symbol", source_info.symbol),
        redlog::field("target_module", target_info.module), redlog::field("target_symbol", target_info.symbol)
    );
  } else {
    log.vrb(label, redlog::field("source", "0x%016llx", source), redlog::field("target", "0x%016llx", target));
  }
}

} // namespace

transfer_tracer::transfer_tracer(
    std::shared_ptr<transfer_engine> engine, transfer_config config, const w1::runtime::thread_info& info
)
    : engine_(std::move(engine)), config_(std::move(config)) {
  if (config_.common.verbose > 0) {
    log_.inf(
        "transfer tracer created", redlog::field("thread_id", info.tid), redlog::field("thread_name", info.name),
        redlog::field("output", config_.output.path), redlog::field("capture_registers", config_.capture.registers),
        redlog::field("capture_stack", config_.capture.stack), redlog::field("enrich_modules", config_.enrich.modules),
        redlog::field("enrich_symbols", config_.enrich.symbols),
        redlog::field("analyze_apis", config_.enrich.analyze_apis)
    );
  }
}

void transfer_tracer::on_thread_start(w1::trace_context& ctx, const w1::thread_event& event) {
  (void) event;
  if (initialized_ || !engine_) {
    return;
  }

  state_ = engine_->make_thread_state();
  if (config_.common.verbose > 0) {
    log_.inf("transfer tracer initialized", redlog::field("thread_id", ctx.thread_id()));
  }
  initialized_ = true;
}

void transfer_tracer::on_thread_stop(w1::trace_context& ctx, const w1::thread_event& event) {
  (void) ctx;
  (void) event;
  if (!engine_) {
    return;
  }

  engine_->merge_thread_stats(state_);
  if (config_.common.verbose > 0) {
    log_.inf(
        "transfer thread completed", redlog::field("thread_id", ctx.thread_id()),
        redlog::field("total_calls", state_.stats.total_calls),
        redlog::field("total_returns", state_.stats.total_returns),
        redlog::field("unique_targets", state_.stats.unique_call_targets),
        redlog::field("max_depth", state_.stats.max_call_depth)
    );
  }
}

void transfer_tracer::on_exec_transfer_call(
    w1::trace_context& ctx, const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  (void) vm;
  (void) state;
  if (!engine_) {
    return;
  }

  if (!initialized_) {
    state_ = engine_->make_thread_state();
    initialized_ = true;
  }
  engine_->record_call(state_, ctx, event, gpr, fpr);

  if (config_.common.verbose > 0) {
    log_transfer_event(log_, "call transfer detected", *engine_, config_, event.source_address, event.target_address);
  }
}

void transfer_tracer::on_exec_transfer_return(
    w1::trace_context& ctx, const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  (void) vm;
  (void) state;
  if (!engine_) {
    return;
  }

  if (!initialized_) {
    state_ = engine_->make_thread_state();
    initialized_ = true;
  }
  engine_->record_return(state_, ctx, event, gpr, fpr);

  if (config_.common.verbose > 0) {
    log_transfer_event(log_, "return transfer detected", *engine_, config_, event.source_address, event.target_address);
  }
}

} // namespace w1xfer

```

`src/tracers/w1xfer/thread/transfer_tracer.hpp`:

```hpp
#pragma once

#include <memory>

#include <QBDI.h>
#include <redlog.hpp>

#include "w1instrument/tracer/event.hpp"
#include "w1instrument/tracer/trace_context.hpp"
#include "w1instrument/tracer/tracer.hpp"
#include "w1instrument/tracer/types.hpp"

#include "config/transfer_config.hpp"
#include "engine/transfer_engine.hpp"

namespace w1::runtime {
struct thread_info;
}

namespace w1xfer {

class transfer_tracer {
public:
  transfer_tracer(
      std::shared_ptr<transfer_engine> engine, transfer_config config, const w1::runtime::thread_info& info
  );

  const char* name() const { return "w1xfer"; }
  static constexpr w1::event_mask requested_events() {
    return w1::event_mask_or(
        w1::event_mask_or(
            w1::event_mask_of(w1::event_kind::exec_transfer_call),
            w1::event_mask_of(w1::event_kind::exec_transfer_return)
        ),
        w1::event_mask_or(
            w1::event_mask_of(w1::event_kind::thread_start), w1::event_mask_of(w1::event_kind::thread_stop)
        )
    );
  }

  void on_thread_start(w1::trace_context& ctx, const w1::thread_event& event);
  void on_thread_stop(w1::trace_context& ctx, const w1::thread_event& event);

  void on_exec_transfer_call(
      w1::trace_context& ctx, const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );
  void on_exec_transfer_return(
      w1::trace_context& ctx, const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );

private:
  std::shared_ptr<transfer_engine> engine_{};
  transfer_config config_{};
  transfer_engine::transfer_thread_state state_{};
  redlog::logger log_ = redlog::get_logger("w1xfer.thread");
  bool initialized_ = false;
};

} // namespace w1xfer

```

`src/tracers/w1xfer/transfer.hpp`:

```hpp
#pragma once

#include <utility>

#include "config/transfer_config.hpp"
#include "runtime/transfer_runtime.hpp"

namespace w1xfer {

// public helpers for standalone usage
template <typename Fn> decltype(auto) with_runtime(transfer_config config, Fn&& fn) {
  auto runtime = make_transfer_runtime(std::move(config));
  return fn(runtime);
}

} // namespace w1xfer

```

`src/tracers/w1xfer/transfer_recipe.hpp`:

```hpp
#pragma once

#include <cstdint>

#include "QBDIPreload.h"
#include <QBDI.h>
#include <redlog.hpp>

#if defined(_WIN32) || defined(WIN32)
#include <w1base/windows_console.hpp>
#endif

#include "config/transfer_config.hpp"
#include "runtime/transfer_runtime.hpp"
#include "w1instrument/logging.hpp"
#include "w1instrument/self_exclude.hpp"

namespace w1xfer {

struct transfer_recipe {
  using config_t = transfer_config;
  using runtime_t = transfer_runtime;

  static config_t load_config() { return transfer_config::from_environment(); }

  static void configure_logging(const config_t& config) {
    w1::instrument::configure_redlog_verbosity(config.common.verbose);
  }

  static void apply_self_excludes(config_t& config, const void* anchor) {
    if (config.common.exclude_self) {
      w1::util::append_self_excludes(config.common.instrumentation, anchor);
    }
  }

  static void log_config(const config_t& config) {
    auto log = redlog::get_logger("w1xfer.preload");
    const char* threads = config.threads == w1::instrument::config::thread_attach_policy::auto_attach ? "auto" : "main";
    log.inf(
        "qbdipreload_on_run configured", redlog::field("output", config.output.path),
        redlog::field("capture_registers", config.capture.registers),
        redlog::field("capture_stack", config.capture.stack), redlog::field("enrich_modules", config.enrich.modules),
        redlog::field("enrich_symbols", config.enrich.symbols),
        redlog::field("analyze_apis", config.enrich.analyze_apis), redlog::field("threads", threads),
        redlog::field("api_arg_count", static_cast<uint64_t>(config.enrich.api_argument_count))
    );
  }

  static runtime_t make_runtime(const config_t& config) { return make_transfer_runtime(config); }

  static bool run_main(runtime_t& runtime, QBDI::VM* vm, uint64_t start, uint64_t stop) {
    auto log = redlog::get_logger("w1xfer.preload");
    log.inf(
        "starting transfer session", redlog::field("start", "0x%llx", static_cast<unsigned long long>(start)),
        redlog::field("stop", "0x%llx", static_cast<unsigned long long>(stop))
    );

    if (!runtime.session) {
      return false;
    }

    return runtime.session->run_main(vm, start, stop, "main");
  }

  static void on_exit(runtime_t& runtime, const config_t& config, int status) {
    auto log = redlog::get_logger("w1xfer.preload");
    log.inf("qbdipreload_on_exit called", redlog::field("status", status));

    if (!runtime.session) {
      log.inf("qbdipreload_on_exit completed");
      return;
    }

    runtime.session->stop();
    const bool exported = runtime.session->export_output();
    const auto stats = runtime.session->engine().stats();

    if (!exported && !config.output.path.empty()) {
      log.wrn("transfer export produced no output", redlog::field("output", config.output.path));
    } else if (exported) {
      log.inf("transfer export completed", redlog::field("output", config.output.path));
    }

    log.inf(
        "transfer collection completed", redlog::field("total_calls", stats.total_calls),
        redlog::field("total_returns", stats.total_returns), redlog::field("unique_targets", stats.unique_call_targets),
        redlog::field("max_depth", stats.max_call_depth)
    );

    log.inf("qbdipreload_on_exit completed");
  }

  static int on_start(void* main) {
    (void) main;
#if defined(_WIN32) || defined(WIN32)
    w1::common::allocate_windows_console();
#endif
    return QBDIPRELOAD_NOT_HANDLED;
  }

  static int on_premain(void* gpr_ctx, void* fpu_ctx) {
    (void) gpr_ctx;
    (void) fpu_ctx;
    return QBDIPRELOAD_NOT_HANDLED;
  }

  static int on_main(int argc, char** argv) {
    (void) argc;
    (void) argv;
    return QBDIPRELOAD_NOT_HANDLED;
  }
};

} // namespace w1xfer

```

`src/w1analysis/CMakeLists.txt`:

```txt
w1_add_static_library(w1analysis
    abi_dispatcher.cpp
    symbol_lookup.cpp
)
add_library(w1::analysis ALIAS w1analysis)

target_link_libraries(w1analysis PUBLIC w1runtime)

```

`src/w1analysis/abi_dispatcher.cpp`:

```cpp
#include "w1analysis/abi_dispatcher.hpp"

namespace w1::analysis {
namespace {

#if defined(QBDI_ARCH_X86_64)
constexpr size_t word_size_bytes = 8;
#elif defined(QBDI_ARCH_AARCH64)
constexpr size_t word_size_bytes = 8;
#elif defined(QBDI_ARCH_X86)
constexpr size_t word_size_bytes = 4;
#else
constexpr size_t word_size_bytes = sizeof(uint64_t);
#endif

} // namespace

abi_dispatcher::abi_dispatcher() { config_.kind = detect_native_kind(); }

abi_dispatcher::abi_dispatcher(abi_dispatcher_config config) : config_(config) {
  if (config_.kind == abi_kind::unknown) {
    config_.kind = detect_native_kind();
  }
}

std::vector<call_argument> abi_dispatcher::extract_arguments(
    const util::memory_reader& memory, const QBDI::GPRState* gpr, size_t argument_count
) const {
  std::vector<call_argument> args;
  args.reserve(argument_count);

  if (!gpr) {
    return args;
  }

  for (size_t index = 0; index < argument_count; ++index) {
    call_argument arg{};

    switch (config_.kind) {
#if defined(QBDI_ARCH_X86_64)
    case abi_kind::system_v_amd64: {
      constexpr size_t reg_count = 6;
      if (index < reg_count) {
        const uint64_t values[] = {gpr->rdi, gpr->rsi, gpr->rdx, gpr->rcx, gpr->r8, gpr->r9};
        arg.raw_value = values[index];
        arg.from_register = true;
        arg.is_valid = true;
      } else if (config_.enable_stack_reads) {
        uint64_t stack_address = gpr->rsp + word_size_bytes + (index - reg_count) * word_size_bytes;
        if (auto value = read_stack_value(memory, stack_address, word_size_bytes)) {
          arg.raw_value = *value;
          arg.is_valid = true;
        }
      }
      break;
    }
    case abi_kind::windows_amd64: {
      constexpr size_t reg_count = 4;
      if (index < reg_count) {
        const uint64_t values[] = {gpr->rcx, gpr->rdx, gpr->r8, gpr->r9};
        arg.raw_value = values[index];
        arg.from_register = true;
        arg.is_valid = true;
      } else if (config_.enable_stack_reads) {
        uint64_t stack_address = gpr->rsp + 0x28 + (index - reg_count) * word_size_bytes;
        if (auto value = read_stack_value(memory, stack_address, word_size_bytes)) {
          arg.raw_value = *value;
          arg.is_valid = true;
        }
      }
      break;
    }
#endif
#if defined(QBDI_ARCH_AARCH64)
    case abi_kind::aarch64: {
      constexpr size_t reg_count = 8;
      if (index < reg_count) {
        const uint64_t values[] = {gpr->x0, gpr->x1, gpr->x2, gpr->x3, gpr->x4, gpr->x5, gpr->x6, gpr->x7};
        arg.raw_value = values[index];
        arg.from_register = true;
        arg.is_valid = true;
      } else if (config_.enable_stack_reads) {
        uint64_t stack_address = gpr->sp + (index - reg_count) * word_size_bytes;
        if (auto value = read_stack_value(memory, stack_address, word_size_bytes)) {
          arg.raw_value = *value;
          arg.is_valid = true;
        }
      }
      break;
    }
#endif
#if defined(QBDI_ARCH_X86)
    case abi_kind::x86: {
      if (config_.enable_stack_reads) {
        uint64_t stack_address = gpr->esp + word_size_bytes + index * word_size_bytes;
        if (auto value = read_stack_value(memory, stack_address, word_size_bytes)) {
          arg.raw_value = *value;
          arg.is_valid = true;
        }
      }
      break;
    }
#endif
    default:
      break;
    }

    args.push_back(arg);
  }

  return args;
}

uint64_t abi_dispatcher::extract_return_value(const QBDI::GPRState* gpr) const {
  if (!gpr) {
    return 0;
  }

  switch (config_.kind) {
#if defined(QBDI_ARCH_X86_64)
  case abi_kind::system_v_amd64:
  case abi_kind::windows_amd64:
    return gpr->rax;
#endif
#if defined(QBDI_ARCH_AARCH64)
  case abi_kind::aarch64:
    return gpr->x0;
#endif
#if defined(QBDI_ARCH_X86)
  case abi_kind::x86:
    return gpr->eax;
#endif
  default:
    return 0;
  }
}

abi_kind abi_dispatcher::detect_native_kind() {
#if defined(_WIN32) && defined(QBDI_ARCH_X86_64)
  return abi_kind::windows_amd64;
#elif defined(QBDI_ARCH_X86_64)
  return abi_kind::system_v_amd64;
#elif defined(QBDI_ARCH_AARCH64)
  return abi_kind::aarch64;
#elif defined(QBDI_ARCH_X86)
  return abi_kind::x86;
#else
  return abi_kind::unknown;
#endif
}

std::optional<uint64_t> abi_dispatcher::read_stack_value(
    const util::memory_reader& memory, uint64_t stack_address, size_t word_size
) const {
  auto bytes = memory.read_bytes(stack_address, word_size);
  if (!bytes || bytes->size() != word_size) {
    return std::nullopt;
  }

  uint64_t value = 0;
  for (size_t i = 0; i < bytes->size(); ++i) {
    value |= static_cast<uint64_t>((*bytes)[i]) << (8 * i);
  }

  return value;
}

} // namespace w1::analysis

```

`src/w1analysis/abi_dispatcher.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <optional>
#include <vector>

#include <QBDI.h>

#include "w1runtime/memory_reader.hpp"

namespace w1::analysis {

enum class abi_kind { system_v_amd64, windows_amd64, aarch64, x86, unknown };

struct call_argument {
  uint64_t raw_value = 0;
  bool from_register = false;
  bool is_valid = false;
};

struct abi_dispatcher_config {
  abi_kind kind = abi_kind::unknown;
  bool enable_stack_reads = true;
};

class abi_dispatcher {
public:
  abi_dispatcher();
  explicit abi_dispatcher(abi_dispatcher_config config);

  abi_kind kind() const { return config_.kind; }

  std::vector<call_argument> extract_arguments(
      const util::memory_reader& memory, const QBDI::GPRState* gpr, size_t argument_count
  ) const;

  uint64_t extract_return_value(const QBDI::GPRState* gpr) const;

  static abi_kind detect_native_kind();

private:
  std::optional<uint64_t> read_stack_value(
      const util::memory_reader& memory, uint64_t stack_address, size_t word_size
  ) const;

  abi_dispatcher_config config_{};
};

} // namespace w1::analysis

```

`src/w1analysis/symbol_lookup.cpp`:

```cpp
#include "w1analysis/symbol_lookup.hpp"

#include <cstdlib>
#include <cstring>

#if !defined(_WIN32)
#include <dlfcn.h>
#endif

#if defined(__APPLE__) || defined(__linux__)
#include <cxxabi.h>
#endif

namespace w1::analysis {

symbol_lookup::symbol_lookup(const runtime::module_catalog* modules, symbol_lookup_config config)
    : modules_(modules), config_(config) {}

void symbol_lookup::set_module_catalog(const runtime::module_catalog* modules) { modules_ = modules; }

void symbol_lookup::set_config(symbol_lookup_config config) { config_ = config; }

std::optional<symbol_info> symbol_lookup::resolve(uint64_t address) const {
  if (config_.enable_cache) {
    std::lock_guard<std::mutex> lock(cache_mutex_);
    auto it = cache_.find(address);
    if (it != cache_.end()) {
      return it->second;
    }
  }

  if (!modules_) {
    return std::nullopt;
  }

  auto module = modules_->find_containing(address);
  if (!module) {
    return std::nullopt;
  }

  symbol_info info{};
  info.address = address;
  info.module_name = module->name;
  info.module_path = module->path;
  info.module_offset = address - module->base_address;

  if (auto native = resolve_native(address)) {
    info.symbol_name = native->symbol_name;
    info.demangled_name = native->demangled_name;
    info.symbol_address = native->symbol_address;
    info.symbol_offset = native->symbol_address ? (address - native->symbol_address) : 0;
    info.is_exported = native->is_exported;
    info.is_imported = native->is_imported;
    info.has_symbol = !info.symbol_name.empty();
  }

  std::optional<symbol_info> result = info;

  if (config_.enable_cache) {
    std::lock_guard<std::mutex> lock(cache_mutex_);
    if (cache_.size() >= config_.max_cache_entries) {
      cache_.clear();
    }
    cache_[address] = result;
  }

  return result;
}

std::vector<std::optional<symbol_info>> symbol_lookup::resolve_many(const std::vector<uint64_t>& addresses) const {
  std::vector<std::optional<symbol_info>> results;
  results.reserve(addresses.size());

  for (uint64_t address : addresses) {
    results.push_back(resolve(address));
  }

  return results;
}

void symbol_lookup::clear_cache() {
  std::lock_guard<std::mutex> lock(cache_mutex_);
  cache_.clear();
}

size_t symbol_lookup::cache_size() const {
  std::lock_guard<std::mutex> lock(cache_mutex_);
  return cache_.size();
}

std::optional<symbol_lookup::native_symbol_result> symbol_lookup::resolve_native(uint64_t address) const {
#if !defined(_WIN32)
  Dl_info info;
  std::memset(&info, 0, sizeof(info));

  if (dladdr(reinterpret_cast<void*>(address), &info) == 0) {
    return std::nullopt;
  }

  native_symbol_result result{};
  if (info.dli_sname) {
    result.symbol_name = info.dli_sname;
    result.demangled_name = maybe_demangle(info.dli_sname);
    result.is_exported = true;
  } else {
    result.demangled_name.clear();
  }

  if (info.dli_saddr) {
    result.symbol_address = reinterpret_cast<uint64_t>(info.dli_saddr);
  }

  return result;
#else
  (void) address;
  return std::nullopt;
#endif
}

std::string symbol_lookup::maybe_demangle(const char* name) const {
  if (!config_.enable_demangle || !name) {
    return name ? std::string{name} : std::string{};
  }

#if defined(__APPLE__) || defined(__linux__)
  int status = 0;
  char* demangled = abi::__cxa_demangle(name, nullptr, nullptr, &status);
  if (status == 0 && demangled) {
    std::string result{demangled};
    std::free(demangled);
    return result;
  }
  std::free(demangled);
#endif

  return std::string{name};
}

} // namespace w1::analysis

```

`src/w1analysis/symbol_lookup.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <mutex>
#include <optional>
#include <string>
#include <unordered_map>
#include <vector>

#include "w1runtime/module_catalog.hpp"

namespace w1::analysis {

struct symbol_info {
  std::string module_name;
  std::string module_path;
  std::string symbol_name;
  std::string demangled_name;
  uint64_t address = 0;
  uint64_t module_offset = 0;
  uint64_t symbol_address = 0;
  uint64_t symbol_offset = 0;
  bool is_exported = false;
  bool is_imported = false;
  bool has_symbol = false;
};

struct symbol_lookup_config {
  size_t max_cache_entries = 10000;
  bool enable_cache = true;
  bool enable_demangle = true;
};

class symbol_lookup {
public:
  symbol_lookup() = default;
  explicit symbol_lookup(const runtime::module_catalog* modules, symbol_lookup_config config = {});

  void set_module_catalog(const runtime::module_catalog* modules);
  void set_config(symbol_lookup_config config);

  std::optional<symbol_info> resolve(uint64_t address) const;
  std::vector<std::optional<symbol_info>> resolve_many(const std::vector<uint64_t>& addresses) const;

  void clear_cache();
  size_t cache_size() const;

private:
  struct native_symbol_result {
    std::string symbol_name;
    std::string demangled_name;
    uint64_t symbol_address = 0;
    bool is_exported = false;
    bool is_imported = false;
  };

  std::optional<native_symbol_result> resolve_native(uint64_t address) const;
  std::string maybe_demangle(const char* name) const;

  const runtime::module_catalog* modules_ = nullptr;
  symbol_lookup_config config_{};

  mutable std::unordered_map<uint64_t, std::optional<symbol_info>> cache_{};
  mutable std::mutex cache_mutex_{};
};

} // namespace w1::analysis

```

`src/w1asmr/CMakeLists.txt`:

```txt
w1_dep_asmr()

if(NOT WITNESS_ASMR)
    message(STATUS "w1asmr disabled (WITNESS_ASMR=OFF)")
else()
    w1_add_static_library(w1asmr
        asmr.cpp
        arch.cpp
    )
    add_library(w1::asmr ALIAS w1asmr)

    target_link_libraries(w1asmr PUBLIC w1base w1::asmr_deps)

    if(DEFINED WITNESS_ASMR_CAPSTONE_INCLUDE_DIR)
        target_include_directories(w1asmr PRIVATE ${WITNESS_ASMR_CAPSTONE_INCLUDE_DIR})
    endif()
    if(DEFINED WITNESS_ASMR_KEYSTONE_INCLUDE_DIR)
        target_include_directories(w1asmr PRIVATE ${WITNESS_ASMR_KEYSTONE_INCLUDE_DIR})
    endif()
endif()

```

`src/w1asmr/arch.cpp`:

```cpp
#include "w1asmr/arch.hpp"

#include <string>

namespace w1::asmr {

result<arch_spec> parse_arch_spec(std::string_view text) {
  arch_spec spec{};
  std::string error;
  if (!w1::arch::parse_arch_spec(text, spec, error)) {
    auto code = error_code::invalid_argument;
    if (error.find("unsupported architecture") != std::string::npos) {
      code = error_code::unsupported;
    }
    return error_result<arch_spec>(code, std::move(error));
  }
  return ok_result(spec);
}

result<arch_spec> detect_host_arch_spec() {
  arch_spec spec = w1::arch::detect_host_arch_spec();
  if (spec.arch_mode == mode::unknown) {
    return error_result<arch_spec>(error_code::unsupported, "unsupported host architecture");
  }
  return ok_result(spec);
}

arch_capabilities arch_capabilities_for(const arch_spec& spec) {
  if (spec.arch_mode == mode::unknown) {
    return {};
  }

  arch_capabilities caps{};
  caps.disasm = true;

  switch (spec.arch_mode) {
  case mode::x86_32:
  case mode::x86_64:
  case mode::aarch64:
  case mode::arm:
  case mode::thumb:
  case mode::riscv32:
  case mode::riscv64:
  case mode::mips32:
  case mode::mips64:
    caps.assemble = true;
    break;
  default:
    caps.assemble = false;
    break;
  }
  return caps;
}

} // namespace w1::asmr

```

`src/w1asmr/arch.hpp`:

```hpp
#pragma once

#include <string_view>

#include "w1asmr/result.hpp"
#include "w1base/arch_spec.hpp"

namespace w1::asmr {

using w1::arch::arch_spec;
using w1::arch::byte_order;
using w1::arch::family;
using w1::arch::mode;

result<arch_spec> parse_arch_spec(std::string_view text);
result<arch_spec> detect_host_arch_spec();

struct arch_capabilities {
  bool disasm = false;
  bool assemble = false;
};

arch_capabilities arch_capabilities_for(const arch_spec& spec);

} // namespace w1::asmr

```

`src/w1asmr/asmr.cpp`:

```cpp
#include "asmr.hpp"

#include <capstone/arm.h>
#include <capstone/arm64.h>
#include <capstone/capstone.h>
#include <capstone/mips.h>
#include <capstone/ppc.h>
#include <capstone/riscv.h>
#include <capstone/sparc.h>
#include <capstone/systemz.h>
#include <capstone/wasm.h>
#include <capstone/x86.h>
#include <keystone/keystone.h>

#include <memory>
#include <string>
#include <utility>

namespace w1::asmr {

namespace {

struct capstone_config {
  cs_arch arch = CS_ARCH_X86;
  cs_mode mode = CS_MODE_64;
  arch_spec normalized{};
};

struct keystone_config {
  ks_arch arch = KS_ARCH_X86;
  ks_mode mode = KS_MODE_64;
  arch_spec normalized{};
};

cs_mode endian_mode(byte_order order) {
  switch (order) {
  case byte_order::big:
    return CS_MODE_BIG_ENDIAN;
  case byte_order::little:
    return CS_MODE_LITTLE_ENDIAN;
  case byte_order::unknown:
    break;
  }
  return static_cast<cs_mode>(0);
}

ks_mode keystone_endian_mode(byte_order order) {
  switch (order) {
  case byte_order::big:
    return KS_MODE_BIG_ENDIAN;
  case byte_order::little:
  case byte_order::unknown:
    break;
  }
  return KS_MODE_LITTLE_ENDIAN;
}

arch_spec normalize_spec(arch_spec spec) {
  if (spec.pointer_bits == 0) {
    spec.pointer_bits = w1::arch::default_pointer_bits(spec.arch_mode);
  }
  if (spec.arch_byte_order == byte_order::unknown) {
    spec.arch_byte_order = w1::arch::default_byte_order(spec.arch_family, spec.arch_mode);
  }
  return spec;
}

result<capstone_config> capstone_config_for(const arch_spec& input) {
  arch_spec spec = normalize_spec(input);
  capstone_config cfg{};
  cfg.normalized = spec;

  if (spec.arch_family == family::x86 && spec.arch_byte_order == byte_order::big) {
    return error_result<capstone_config>(error_code::unsupported, "x86 does not support big endian");
  }
  if ((spec.arch_mode == mode::wasm32 || spec.arch_mode == mode::wasm64) && spec.arch_byte_order == byte_order::big) {
    return error_result<capstone_config>(error_code::unsupported, "wasm does not support big endian");
  }
  if (spec.arch_mode == mode::systemz && spec.arch_byte_order == byte_order::little) {
    return error_result<capstone_config>(error_code::unsupported, "systemz does not support little endian");
  }

  switch (spec.arch_mode) {
  case mode::x86_32:
    cfg.arch = CS_ARCH_X86;
    cfg.mode = CS_MODE_32;
    break;
  case mode::x86_64:
    cfg.arch = CS_ARCH_X86;
    cfg.mode = CS_MODE_64;
    break;
  case mode::arm:
    cfg.arch = CS_ARCH_ARM;
    cfg.mode = static_cast<cs_mode>(CS_MODE_ARM | endian_mode(spec.arch_byte_order));
    break;
  case mode::thumb:
    cfg.arch = CS_ARCH_ARM;
    cfg.mode = static_cast<cs_mode>(CS_MODE_THUMB | endian_mode(spec.arch_byte_order));
    break;
  case mode::aarch64:
#ifdef CAPSTONE_AARCH64_COMPAT_HEADER
    cfg.arch = CS_ARCH_ARM64;
#else
    cfg.arch = CS_ARCH_AARCH64;
#endif
    cfg.mode = endian_mode(spec.arch_byte_order);
    break;
  case mode::riscv32:
    cfg.arch = CS_ARCH_RISCV;
    cfg.mode = static_cast<cs_mode>(CS_MODE_RISCV32 | endian_mode(spec.arch_byte_order));
    break;
  case mode::riscv64:
    cfg.arch = CS_ARCH_RISCV;
    cfg.mode = static_cast<cs_mode>(CS_MODE_RISCV64 | endian_mode(spec.arch_byte_order));
    break;
  case mode::mips32:
    cfg.arch = CS_ARCH_MIPS;
    cfg.mode = static_cast<cs_mode>(CS_MODE_MIPS32 | endian_mode(spec.arch_byte_order));
    break;
  case mode::mips64:
    cfg.arch = CS_ARCH_MIPS;
    cfg.mode = static_cast<cs_mode>(CS_MODE_MIPS64 | endian_mode(spec.arch_byte_order));
    break;
  case mode::ppc32:
    cfg.arch = CS_ARCH_PPC;
    cfg.mode = static_cast<cs_mode>(CS_MODE_32 | endian_mode(spec.arch_byte_order));
    break;
  case mode::ppc64:
    cfg.arch = CS_ARCH_PPC;
    cfg.mode = static_cast<cs_mode>(CS_MODE_64 | endian_mode(spec.arch_byte_order));
    break;
  case mode::sparc32:
    cfg.arch = CS_ARCH_SPARC;
    cfg.mode = static_cast<cs_mode>(CS_MODE_32 | endian_mode(spec.arch_byte_order));
    break;
  case mode::sparc64:
    cfg.arch = CS_ARCH_SPARC;
    cfg.mode = static_cast<cs_mode>(CS_MODE_V9 | endian_mode(spec.arch_byte_order));
    break;
  case mode::systemz:
    cfg.arch = CS_ARCH_SYSTEMZ;
    cfg.mode = endian_mode(spec.arch_byte_order);
    break;
  case mode::wasm32:
    cfg.arch = CS_ARCH_WASM;
    cfg.mode = static_cast<cs_mode>(CS_MODE_32 | endian_mode(spec.arch_byte_order));
    break;
  case mode::wasm64:
    cfg.arch = CS_ARCH_WASM;
    cfg.mode = static_cast<cs_mode>(CS_MODE_64 | endian_mode(spec.arch_byte_order));
    break;
  case mode::unknown:
    return error_result<capstone_config>(error_code::unsupported, "unknown architecture");
  }
  return ok_result(cfg);
}

result<keystone_config> keystone_config_for(const arch_spec& input) {
  arch_spec spec = normalize_spec(input);
  keystone_config cfg{};
  cfg.normalized = spec;

  if (spec.arch_family == family::x86 && spec.arch_byte_order == byte_order::big) {
    return error_result<keystone_config>(error_code::unsupported, "x86 does not support big endian");
  }

  switch (spec.arch_mode) {
  case mode::x86_32:
    cfg.arch = KS_ARCH_X86;
    cfg.mode = KS_MODE_32;
    break;
  case mode::x86_64:
    cfg.arch = KS_ARCH_X86;
    cfg.mode = KS_MODE_64;
    break;
  case mode::arm:
    cfg.arch = KS_ARCH_ARM;
    cfg.mode = static_cast<ks_mode>(KS_MODE_ARM | keystone_endian_mode(spec.arch_byte_order));
    break;
  case mode::thumb:
    cfg.arch = KS_ARCH_ARM;
    cfg.mode = static_cast<ks_mode>(KS_MODE_THUMB | keystone_endian_mode(spec.arch_byte_order));
    break;
  case mode::aarch64:
    cfg.arch = KS_ARCH_ARM64;
    cfg.mode = keystone_endian_mode(spec.arch_byte_order);
    break;
  case mode::riscv32:
    cfg.arch = KS_ARCH_RISCV;
    cfg.mode = static_cast<ks_mode>(KS_MODE_RISCV32 | keystone_endian_mode(spec.arch_byte_order));
    break;
  case mode::riscv64:
    cfg.arch = KS_ARCH_RISCV;
    cfg.mode = static_cast<ks_mode>(KS_MODE_RISCV64 | keystone_endian_mode(spec.arch_byte_order));
    break;
  case mode::mips32:
    cfg.arch = KS_ARCH_MIPS;
    cfg.mode = static_cast<ks_mode>(KS_MODE_MIPS32 | keystone_endian_mode(spec.arch_byte_order));
    break;
  case mode::mips64:
    cfg.arch = KS_ARCH_MIPS;
    cfg.mode = static_cast<ks_mode>(KS_MODE_MIPS64 | keystone_endian_mode(spec.arch_byte_order));
    break;
  default:
    return error_result<keystone_config>(error_code::unsupported, "unsupported architecture for assembly");
  }
  return ok_result(cfg);
}

void append_reg_name(csh handle, uint32_t reg_id, std::string& out) {
  if (reg_id == 0) {
    return;
  }
  const char* name = cs_reg_name(handle, reg_id);
  if (name) {
    out = name;
  }
}

void append_x86_operands(csh handle, const cs_x86& detail, instruction& inst) {
  inst.encoding_info.imm_offset = detail.encoding.imm_offset;
  inst.encoding_info.imm_size = detail.encoding.imm_size;
  inst.encoding_info.disp_offset = detail.encoding.disp_offset;
  inst.encoding_info.disp_size = detail.encoding.disp_size;
  inst.encoding_info.modrm_offset = detail.encoding.modrm_offset;

  inst.operand_details.reserve(detail.op_count);
  for (uint8_t i = 0; i < detail.op_count; ++i) {
    const auto& op = detail.operands[i];
    operand out;
    int type = static_cast<int>(op.type);
    switch (type) {
    case X86_OP_REG:
      out.kind = operand_kind::reg;
      out.reg_id = op.reg;
      append_reg_name(handle, op.reg, out.reg_name);
      break;
    case X86_OP_IMM:
      out.kind = operand_kind::imm;
      out.imm = op.imm;
      break;
    case X86_OP_MEM:
      out.kind = operand_kind::mem;
      out.mem_base = op.mem.base;
      out.mem_index = op.mem.index;
      out.mem_scale = op.mem.scale;
      out.mem_disp = op.mem.disp;
      out.is_pc_relative = (op.mem.base == X86_REG_RIP || op.mem.base == X86_REG_EIP);
      break;
    default:
      continue;
    }
    inst.operand_details.push_back(std::move(out));
  }
}

void append_arm_operands(csh handle, const cs_arm& detail, instruction& inst) {
  inst.operand_details.reserve(detail.op_count);
  for (uint8_t i = 0; i < detail.op_count; ++i) {
    const auto& op = detail.operands[i];
    operand out;
    int type = static_cast<int>(op.type);
    switch (type) {
    case ARM_OP_REG:
      out.kind = operand_kind::reg;
      out.reg_id = op.reg;
      append_reg_name(handle, op.reg, out.reg_name);
      break;
    case ARM_OP_IMM:
    case ARM_OP_CIMM:
    case ARM_OP_PIMM:
      out.kind = operand_kind::imm;
      out.imm = op.imm;
      break;
    case ARM_OP_FP:
      out.kind = operand_kind::imm;
      out.imm = static_cast<int64_t>(op.fp);
      break;
    case ARM_OP_MEM:
      out.kind = operand_kind::mem;
      out.mem_base = op.mem.base;
      out.mem_index = op.mem.index;
      out.mem_scale = op.mem.scale;
      out.mem_disp = op.mem.disp;
      out.is_pc_relative = (op.mem.base == ARM_REG_PC);
      break;
    default:
      continue;
    }
    inst.operand_details.push_back(std::move(out));
  }
}

void append_arm64_operands(csh handle, const cs_arm64& detail, instruction& inst) {
  inst.operand_details.reserve(detail.op_count);
  for (uint8_t i = 0; i < detail.op_count; ++i) {
    const auto& op = detail.operands[i];
    operand out;
    int type = static_cast<int>(op.type);
    switch (type) {
    case ARM64_OP_REG:
    case ARM64_OP_REG_MRS:
    case ARM64_OP_REG_MSR:
    case ARM64_OP_SYSREG:
      out.kind = operand_kind::reg;
      out.reg_id = op.reg;
      append_reg_name(handle, op.reg, out.reg_name);
      break;
    case ARM64_OP_MEM:
    case ARM64_OP_MEM_REG:
    case ARM64_OP_MEM_IMM:
      out.kind = operand_kind::mem;
      out.mem_base = op.mem.base;
      out.mem_index = op.mem.index;
      out.mem_disp = op.mem.disp;
      out.is_pc_relative = false;
      break;
    case ARM64_OP_IMM:
    case ARM64_OP_CIMM:
      out.kind = operand_kind::imm;
      out.imm = op.imm;
      break;
    case ARM64_OP_IMPLICIT_IMM_0:
    case ARM64_OP_IMM_RANGE:
    case ARM64_OP_SYSIMM:
    case ARM64_OP_PSTATEIMM0_15:
    case ARM64_OP_PSTATEIMM0_1:
    case ARM64_OP_EXACTFPIMM:
      out.kind = operand_kind::imm;
      out.imm = 0;
      break;
    case ARM64_OP_FP:
      out.kind = operand_kind::imm;
      out.imm = static_cast<int64_t>(op.fp);
      break;
    default:
      continue;
    }
    inst.operand_details.push_back(std::move(out));
  }
}

const cs_arm64& arm64_detail(const cs_detail& detail) {
#ifdef CAPSTONE_AARCH64_COMPAT_HEADER
  return detail.arm64;
#else
  return detail.aarch64;
#endif
}

} // namespace

struct disasm_context::backend {
  csh capstone = 0;
  arch_spec arch_value{};

  ~backend() {
    if (capstone) {
      cs_close(&capstone);
      capstone = 0;
    }
  }
};

struct asm_context::backend {
  ks_engine* keystone = nullptr;
  arch_spec arch_value{};

  ~backend() {
    if (keystone) {
      ks_close(keystone);
      keystone = nullptr;
    }
  }
};

disasm_context::~disasm_context() = default;
disasm_context::disasm_context(disasm_context&&) noexcept = default;
disasm_context& disasm_context::operator=(disasm_context&&) noexcept = default;

asm_context::~asm_context() = default;
asm_context::asm_context(asm_context&&) noexcept = default;
asm_context& asm_context::operator=(asm_context&&) noexcept = default;

disasm_context::disasm_context(const arch_spec& arch_value, std::unique_ptr<backend> backend)
    : backend_(std::move(backend)), arch_(arch_value) {}

asm_context::asm_context(const arch_spec& arch_value, std::unique_ptr<backend> backend)
    : backend_(std::move(backend)), arch_(arch_value) {}

result<disasm_context> disasm_context::for_arch(const arch_spec& spec) {
  auto caps = arch_capabilities_for(spec);
  if (!caps.disasm) {
    return error_result<disasm_context>(error_code::unsupported, "disassembly not supported for this architecture");
  }

  auto capstone_cfg = capstone_config_for(spec);
  if (!capstone_cfg.ok()) {
    return error_result<disasm_context>(capstone_cfg.status_info.code, capstone_cfg.status_info.message);
  }

  auto backend = std::make_unique<disasm_context::backend>();
  backend->arch_value = capstone_cfg.value.normalized;

  cs_err cs_status = cs_open(capstone_cfg.value.arch, capstone_cfg.value.mode, &backend->capstone);
  if (cs_status != CS_ERR_OK) {
    return error_result<disasm_context>(
        error_code::internal_error, std::string("capstone init failed: ") + cs_strerror(cs_status)
    );
  }

  cs_status = cs_option(backend->capstone, CS_OPT_DETAIL, CS_OPT_ON);
  if (cs_status != CS_ERR_OK) {
    return error_result<disasm_context>(
        error_code::internal_error, std::string("capstone option failed: ") + cs_strerror(cs_status)
    );
  }

  if (backend->arch_value.arch_family == family::x86) {
    cs_option(backend->capstone, CS_OPT_SYNTAX, CS_OPT_SYNTAX_INTEL);
  }

  arch_spec arch_value = backend->arch_value;
  return ok_result(disasm_context(arch_value, std::move(backend)));
}

result<disasm_context> disasm_context::for_host() {
  auto detected = detect_host_arch_spec();
  if (!detected.ok()) {
    return error_result<disasm_context>(detected.status_info.code, detected.status_info.message);
  }
  return for_arch(detected.value);
}

result<std::vector<instruction>> disasm_context::disassemble(
    std::span<const uint8_t> bytes,
    uint64_t address
) const {
  if (!backend_ || !backend_->capstone) {
    return error_result<std::vector<instruction>>(error_code::invalid_context, "asmr context not initialized");
  }

  if (bytes.empty()) {
    return error_result<std::vector<instruction>>(error_code::invalid_argument, "disassembly input is empty");
  }

  cs_insn* insn = nullptr;
  size_t count = cs_disasm(backend_->capstone, bytes.data(), bytes.size(), address, 0, &insn);
  if (count == 0 || !insn) {
    return error_result<std::vector<instruction>>(error_code::not_found, "no instructions decoded");
  }

  std::vector<instruction> output;
  output.reserve(count);
  for (size_t i = 0; i < count; ++i) {
    const auto& entry = insn[i];
    instruction inst;
    inst.address = entry.address;
    inst.bytes.assign(entry.bytes, entry.bytes + entry.size);
    inst.mnemonic = entry.mnemonic;
    inst.operands = entry.op_str;
    inst.id = entry.id;
    inst.is_branch_relative = cs_insn_group(backend_->capstone, &entry, CS_GRP_BRANCH_RELATIVE);

    if (entry.detail) {
      if (arch_.arch_family == family::x86) {
        append_x86_operands(backend_->capstone, entry.detail->x86, inst);
      } else if (arch_.arch_mode == mode::aarch64) {
        append_arm64_operands(backend_->capstone, arm64_detail(*entry.detail), inst);
      } else if (arch_.arch_mode == mode::arm || arch_.arch_mode == mode::thumb) {
        append_arm_operands(backend_->capstone, entry.detail->arm, inst);
      }
    }

    output.push_back(std::move(inst));
  }

  cs_free(insn, count);
  return ok_result(std::move(output));
}

result<asm_context> asm_context::for_arch(const arch_spec& spec) {
  auto caps = arch_capabilities_for(spec);
  if (!caps.assemble) {
    return error_result<asm_context>(error_code::unsupported, "assembly not supported for this architecture");
  }

  auto keystone_cfg = keystone_config_for(spec);
  if (!keystone_cfg.ok()) {
    return error_result<asm_context>(keystone_cfg.status_info.code, keystone_cfg.status_info.message);
  }
  if (!ks_arch_supported(keystone_cfg.value.arch)) {
    return error_result<asm_context>(
        error_code::unsupported, "keystone backend not built for requested architecture"
    );
  }

  auto backend = std::make_unique<asm_context::backend>();
  backend->arch_value = keystone_cfg.value.normalized;

  ks_err ks_status = ks_open(keystone_cfg.value.arch, keystone_cfg.value.mode, &backend->keystone);
  if (ks_status != KS_ERR_OK) {
    return error_result<asm_context>(
        error_code::internal_error, std::string("keystone init failed: ") + ks_strerror(ks_status)
    );
  }
  if (!backend->keystone) {
    return error_result<asm_context>(error_code::internal_error, "keystone returned null engine");
  }

  // Keystone defaults to Intel syntax on x86, so no explicit option is required here.

  arch_spec arch_value = backend->arch_value;
  return ok_result(asm_context(arch_value, std::move(backend)));
}

result<asm_context> asm_context::for_host() {
  auto detected = detect_host_arch_spec();
  if (!detected.ok()) {
    return error_result<asm_context>(detected.status_info.code, detected.status_info.message);
  }
  return for_arch(detected.value);
}

result<std::vector<uint8_t>> asm_context::assemble(std::string_view text, uint64_t address) const {
  if (!backend_ || !backend_->keystone) {
    return error_result<std::vector<uint8_t>>(error_code::invalid_context, "asmr context not initialized");
  }

  if (text.empty()) {
    return error_result<std::vector<uint8_t>>(error_code::invalid_argument, "assembly input is empty");
  }

  std::string input(text);
  unsigned char* encode = nullptr;
  size_t size = 0;
  size_t count = 0;

  int status = ks_asm(backend_->keystone, input.c_str(), address, &encode, &size, &count);
  if (status != 0) {
    ks_err ks_error = ks_errno(backend_->keystone);
    return error_result<std::vector<uint8_t>>(
        error_code::invalid_argument, std::string("keystone assemble failed: ") + ks_strerror(ks_error)
    );
  }

  std::vector<uint8_t> output;
  output.reserve(size);
  output.insert(output.end(), encode, encode + size);
  ks_free(encode);
  return ok_result(std::move(output));
}

} // namespace w1::asmr

```

`src/w1asmr/asmr.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <memory>
#include <span>
#include <string>
#include <string_view>
#include <vector>

#include "w1asmr/arch.hpp"
#include "w1asmr/result.hpp"

namespace w1::asmr {

enum class operand_kind { reg, imm, mem };

struct encoding {
  uint8_t imm_offset = 0;
  uint8_t imm_size = 0;
  uint8_t disp_offset = 0;
  uint8_t disp_size = 0;
  uint8_t modrm_offset = 0;
};

struct operand {
  operand_kind kind = operand_kind::reg;
  uint32_t reg_id = 0;
  std::string reg_name;
  int64_t imm = 0;
  uint32_t mem_base = 0;
  uint32_t mem_index = 0;
  int32_t mem_scale = 0;
  int64_t mem_disp = 0;
  bool is_pc_relative = false;
};

struct instruction {
  uint64_t address = 0;
  std::vector<uint8_t> bytes;
  std::string mnemonic;
  std::string operands;
  uint32_t id = 0;
  std::vector<operand> operand_details;
  encoding encoding_info;
  bool is_branch_relative = false;
};

class disasm_context {
public:
  disasm_context() = default;
  ~disasm_context();
  disasm_context(disasm_context&&) noexcept;
  disasm_context& operator=(disasm_context&&) noexcept;
  disasm_context(const disasm_context&) = delete;
  disasm_context& operator=(const disasm_context&) = delete;

  static result<disasm_context> for_arch(const arch_spec& spec);
  static result<disasm_context> for_host();

  result<std::vector<instruction>> disassemble(std::span<const uint8_t> bytes, uint64_t address) const;

  const arch_spec& architecture() const noexcept { return arch_; }

private:
  struct backend;

  explicit disasm_context(const arch_spec& arch_value, std::unique_ptr<backend> backend);

  std::unique_ptr<backend> backend_;
  arch_spec arch_{};
};

class asm_context {
public:
  asm_context() = default;
  ~asm_context();
  asm_context(asm_context&&) noexcept;
  asm_context& operator=(asm_context&&) noexcept;
  asm_context(const asm_context&) = delete;
  asm_context& operator=(const asm_context&) = delete;

  static result<asm_context> for_arch(const arch_spec& spec);
  static result<asm_context> for_host();

  result<std::vector<uint8_t>> assemble(std::string_view text, uint64_t address) const;

  const arch_spec& architecture() const noexcept { return arch_; }

private:
  struct backend;

  explicit asm_context(const arch_spec& arch_value, std::unique_ptr<backend> backend);

  std::unique_ptr<backend> backend_;
  arch_spec arch_{};
};

} // namespace w1::asmr

```

`src/w1asmr/result.hpp`:

```hpp
#pragma once

#include <string>
#include <utility>

namespace w1::asmr {

// asmr error codes for structured results
enum class error_code {
  ok,
  invalid_argument,
  not_found,
  unsupported,
  invalid_context,
  internal_error
};

// status holds an error code and a human-readable message
struct status {
  error_code code = error_code::ok;
  std::string message;

  bool ok() const noexcept { return code == error_code::ok; }
};

inline status ok_status() { return {}; }

inline status make_status(error_code code, std::string message) { return status{code, std::move(message)}; }

// result carries a value and a status; value is default-initialized on errors
template <typename T> struct result {
  T value{};
  status status_info{};

  bool ok() const noexcept { return status_info.ok(); }
};

template <typename T> inline result<T> ok_result(T value) { return result<T>{std::move(value), ok_status()}; }

template <typename T> inline result<T> error_result(error_code code, std::string message) {
  return result<T>{T{}, make_status(code, std::move(message))};
}

} // namespace w1::asmr

```

`src/w1base/CMakeLists.txt`:

```txt
w1_dep_redlog()

w1_add_static_library(w1base
    arch_spec.cpp
    env_config.cpp
    module_identity.cpp
    signal_handler.cpp
    uuid_format.cpp
)
add_library(w1::base ALIAS w1base)

target_link_libraries(w1base PUBLIC redlog::redlog)

```

`src/w1base/arch_spec.cpp`:

```cpp
#include "w1base/arch_spec.hpp"

#include <cctype>
#include <string>

namespace w1::arch {

namespace {

std::string trim_lower(std::string_view input) {
  size_t start = 0;
  while (start < input.size() && std::isspace(static_cast<unsigned char>(input[start])) != 0) {
    ++start;
  }
  size_t end = input.size();
  while (end > start && std::isspace(static_cast<unsigned char>(input[end - 1])) != 0) {
    --end;
  }

  std::string output;
  output.reserve(end - start);
  for (size_t i = start; i < end; ++i) {
    output.push_back(static_cast<char>(std::tolower(static_cast<unsigned char>(input[i]))));
  }
  return output;
}

bool strip_suffix(std::string& value, std::string_view suffix) {
  if (value.size() < suffix.size()) {
    return false;
  }
  if (value.compare(value.size() - suffix.size(), suffix.size(), suffix) != 0) {
    return false;
  }
  value.erase(value.size() - suffix.size());
  return true;
}

byte_order detect_native_byte_order() {
  uint16_t value = 0x0102;
  auto* bytes = reinterpret_cast<const uint8_t*>(&value);
  if (bytes[0] == 0x02) {
    return byte_order::little;
  }
  if (bytes[0] == 0x01) {
    return byte_order::big;
  }
  return byte_order::unknown;
}

bool allow_override(byte_order order, family fam, mode mode_value, std::string& error) {
  if (order == byte_order::unknown) {
    return true;
  }
  if (fam == family::x86 || mode_value == mode::wasm32 || mode_value == mode::wasm64) {
    if (order == byte_order::big) {
      error = "big endian is not supported for this architecture";
      return false;
    }
  }
  if (fam == family::systemz) {
    if (order == byte_order::little) {
      error = "little endian is not supported for systemz";
      return false;
    }
  }
  return true;
}

} // namespace

uint32_t default_pointer_bits(mode mode_value) {
  switch (mode_value) {
  case mode::x86_32:
  case mode::arm:
  case mode::thumb:
  case mode::riscv32:
  case mode::mips32:
  case mode::ppc32:
  case mode::sparc32:
  case mode::wasm32:
    return 32;
  case mode::x86_64:
  case mode::aarch64:
  case mode::riscv64:
  case mode::mips64:
  case mode::ppc64:
  case mode::sparc64:
  case mode::systemz:
  case mode::wasm64:
    return 64;
  case mode::unknown:
    break;
  }
  return 0;
}

byte_order default_byte_order(family fam, mode mode_value) {
  switch (fam) {
  case family::x86:
  case family::arm:
  case family::riscv:
  case family::wasm:
    return byte_order::little;
  case family::mips:
  case family::ppc:
  case family::sparc:
  case family::systemz:
    return byte_order::big;
  case family::unknown:
    break;
  }

  if (mode_value == mode::systemz) {
    return byte_order::big;
  }
  return byte_order::unknown;
}

bool parse_arch_spec(std::string_view text, arch_spec& out, std::string& error) {
  error.clear();
  std::string value = trim_lower(text);
  if (value.empty()) {
    error = "architecture value is empty";
    return false;
  }

  byte_order override_order = byte_order::unknown;
  size_t colon = value.find(':');
  if (colon != std::string::npos) {
    std::string suffix = value.substr(colon + 1);
    value.resize(colon);
    if (suffix == "le" || suffix == "little") {
      override_order = byte_order::little;
    } else if (suffix == "be" || suffix == "big") {
      override_order = byte_order::big;
    } else {
      error = "unknown endianness override";
      return false;
    }
  }

  if (override_order == byte_order::unknown) {
    if (strip_suffix(value, "le")) {
      override_order = byte_order::little;
    } else if (strip_suffix(value, "be")) {
      override_order = byte_order::big;
    }
  }

  if (value.empty()) {
    error = "architecture value is empty";
    return false;
  }

  arch_spec spec{};
  if (value == "x86" || value == "i386" || value == "i486" || value == "i586" || value == "i686" || value == "x86_32" ||
      value == "x86-32") {
    spec.arch_family = family::x86;
    spec.arch_mode = mode::x86_32;
  } else if (value == "x64" || value == "x86_64" || value == "x86-64" || value == "amd64") {
    spec.arch_family = family::x86;
    spec.arch_mode = mode::x86_64;
  } else if (value == "arm" || value == "arm32" || value == "armv7" || value == "armv7l") {
    spec.arch_family = family::arm;
    spec.arch_mode = mode::arm;
  } else if (value == "thumb" || value == "thumb2") {
    spec.arch_family = family::arm;
    spec.arch_mode = mode::thumb;
  } else if (value == "arm64" || value == "aarch64") {
    spec.arch_family = family::arm;
    spec.arch_mode = mode::aarch64;
  } else if (value == "riscv32" || value == "rv32") {
    spec.arch_family = family::riscv;
    spec.arch_mode = mode::riscv32;
  } else if (value == "riscv64" || value == "rv64") {
    spec.arch_family = family::riscv;
    spec.arch_mode = mode::riscv64;
  } else if (value == "mips32" || value == "mips") {
    spec.arch_family = family::mips;
    spec.arch_mode = mode::mips32;
  } else if (value == "mips64") {
    spec.arch_family = family::mips;
    spec.arch_mode = mode::mips64;
  } else if (value == "ppc32" || value == "ppc" || value == "powerpc") {
    spec.arch_family = family::ppc;
    spec.arch_mode = mode::ppc32;
  } else if (value == "ppc64" || value == "powerpc64") {
    spec.arch_family = family::ppc;
    spec.arch_mode = mode::ppc64;
  } else if (value == "sparc32" || value == "sparc") {
    spec.arch_family = family::sparc;
    spec.arch_mode = mode::sparc32;
  } else if (value == "sparc64") {
    spec.arch_family = family::sparc;
    spec.arch_mode = mode::sparc64;
  } else if (value == "systemz" || value == "s390x" || value == "s390") {
    spec.arch_family = family::systemz;
    spec.arch_mode = mode::systemz;
  } else if (value == "wasm32") {
    spec.arch_family = family::wasm;
    spec.arch_mode = mode::wasm32;
  } else if (value == "wasm64") {
    spec.arch_family = family::wasm;
    spec.arch_mode = mode::wasm64;
  } else {
    error = "unsupported architecture: " + value;
    return false;
  }

  spec.pointer_bits = default_pointer_bits(spec.arch_mode);
  spec.arch_byte_order = default_byte_order(spec.arch_family, spec.arch_mode);
  if (!allow_override(override_order, spec.arch_family, spec.arch_mode, error)) {
    return false;
  }
  if (override_order != byte_order::unknown) {
    spec.arch_byte_order = override_order;
  }

  out = spec;
  return true;
}

arch_spec detect_host_arch_spec() {
  arch_spec spec{};
#if defined(__x86_64__) || defined(_M_X64)
  spec.arch_family = family::x86;
  spec.arch_mode = mode::x86_64;
#elif defined(__i386__) || defined(_M_IX86)
  spec.arch_family = family::x86;
  spec.arch_mode = mode::x86_32;
#elif defined(__aarch64__) || defined(_M_ARM64)
  spec.arch_family = family::arm;
  spec.arch_mode = mode::aarch64;
#elif defined(__arm__) || defined(_M_ARM)
  spec.arch_family = family::arm;
#if defined(__thumb__)
  spec.arch_mode = mode::thumb;
#else
  spec.arch_mode = mode::arm;
#endif
#else
  spec.arch_family = family::unknown;
  spec.arch_mode = mode::unknown;
#endif

  spec.pointer_bits = static_cast<uint32_t>(sizeof(void*) * 8);
  spec.arch_byte_order = detect_native_byte_order();
  if (spec.arch_byte_order == byte_order::unknown) {
    spec.arch_byte_order = default_byte_order(spec.arch_family, spec.arch_mode);
  }
  spec.flags = 0;
  return spec;
}

std::string_view gdb_arch_name(const arch_spec& spec) {
  switch (spec.arch_mode) {
  case mode::x86_64:
    return "i386:x86-64";
  case mode::x86_32:
    return "i386";
  case mode::aarch64:
    return "aarch64";
  case mode::arm:
  case mode::thumb:
    return "arm";
  default:
    break;
  }
  return {};
}

std::string_view gdb_feature_name(const arch_spec& spec) {
  switch (spec.arch_mode) {
  case mode::x86_64:
  case mode::x86_32:
    return "org.gnu.gdb.i386.core";
  case mode::aarch64:
    return "org.gnu.gdb.aarch64.core";
  case mode::arm:
  case mode::thumb:
    return "org.gnu.gdb.arm.core";
  default:
    break;
  }
  return "org.w1tn3ss.rewind";
}

} // namespace w1::arch

```

`src/w1base/arch_spec.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>
#include <string_view>

namespace w1::arch {

enum class family : uint16_t { unknown, x86, arm, riscv, mips, ppc, sparc, systemz, wasm };

enum class mode : uint16_t {
  unknown,
  x86_32,
  x86_64,
  arm,
  thumb,
  aarch64,
  riscv32,
  riscv64,
  mips32,
  mips64,
  ppc32,
  ppc64,
  sparc32,
  sparc64,
  systemz,
  wasm32,
  wasm64
};

enum class byte_order : uint8_t { unknown, little, big };

struct arch_spec {
  family arch_family = family::unknown;
  mode arch_mode = mode::unknown;
  byte_order arch_byte_order = byte_order::unknown;
  uint32_t pointer_bits = 0;
  uint32_t flags = 0;
};

inline constexpr bool operator==(const arch_spec& lhs, const arch_spec& rhs) noexcept {
  return lhs.arch_family == rhs.arch_family && lhs.arch_mode == rhs.arch_mode &&
         lhs.arch_byte_order == rhs.arch_byte_order && lhs.pointer_bits == rhs.pointer_bits && lhs.flags == rhs.flags;
}

inline constexpr bool operator!=(const arch_spec& lhs, const arch_spec& rhs) noexcept { return !(lhs == rhs); }

bool parse_arch_spec(std::string_view text, arch_spec& out, std::string& error);
arch_spec detect_host_arch_spec();
uint32_t default_pointer_bits(mode mode_value);
byte_order default_byte_order(family fam, mode mode_value);
std::string_view gdb_arch_name(const arch_spec& spec);
std::string_view gdb_feature_name(const arch_spec& spec);

} // namespace w1::arch

```

`src/w1base/cli/verbosity.hpp`:

```hpp
#pragma once

#include <redlog.hpp>

namespace w1::cli {

inline redlog::level level_from_verbosity(int count) {
  if (count <= 0) {
    return redlog::level::info;
  }
  if (count == 1) {
    return redlog::level::verbose;
  }
  if (count == 2) {
    return redlog::level::trace;
  }
  if (count == 3) {
    return redlog::level::debug;
  }
  return redlog::level::pedantic;
}

inline void apply_verbosity(int count) { redlog::set_level(level_from_verbosity(count)); }

} // namespace w1::cli

```

`src/w1base/env_config.cpp`:

```cpp
#include "w1base/env_config.hpp"

#include <algorithm>
#include <cctype>
#include <cstdint>
#include <cstdlib>
#include <iostream>
#include <sstream>

namespace w1::util {

env_config::env_config(const std::string& prefix) : prefix_(prefix) {
  if (!prefix_.empty() && prefix_.back() != '_') {
    prefix_ += "_";
  }
}

std::string env_config::build_env_name(const std::string& name) const { return prefix_ + name; }

std::string env_config::get_env_value(const std::string& name) const {
  const char* value = std::getenv(build_env_name(name).c_str());
  return value ? std::string(value) : std::string();
}

std::string env_config::to_lower(const std::string& value) const {
  std::string result = value;
  std::transform(result.begin(), result.end(), result.begin(), [](unsigned char ch) {
    return static_cast<char>(std::tolower(ch));
  });
  return result;
}

std::string env_config::trim(const std::string& value) const {
  size_t first = value.find_first_not_of(' ');
  if (first == std::string::npos) {
    return value;
  }
  size_t last = value.find_last_not_of(' ');
  return value.substr(first, last - first + 1);
}

template <> std::string env_config::get<std::string>(const std::string& name, std::string default_value) const {
  std::string value = get_env_value(name);
  return value.empty() ? default_value : value;
}

template <> bool env_config::get<bool>(const std::string& name, bool default_value) const {
  std::string value = get_env_value(name);
  if (value.empty()) {
    return default_value;
  }

  std::string lower_value = to_lower(value);
  return (lower_value == "1" || lower_value == "true" || lower_value == "yes" || lower_value == "on");
}

template <> int env_config::get<int>(const std::string& name, int default_value) const {
  std::string value = get_env_value(name);
  if (value.empty()) {
    return default_value;
  }

  try {
    return std::stoi(value);
  } catch (const std::exception& error) {
    std::cerr << "warning: failed to parse " << build_env_name(name) << " as int: " << error.what()
              << ", using default\n";
    return default_value;
  }
}

template <> long env_config::get<long>(const std::string& name, long default_value) const {
  std::string value = get_env_value(name);
  if (value.empty()) {
    return default_value;
  }

  try {
    return std::stol(value);
  } catch (const std::exception& error) {
    std::cerr << "warning: failed to parse " << build_env_name(name) << " as long: " << error.what()
              << ", using default\n";
    return default_value;
  }
}

template <> uint32_t env_config::get<uint32_t>(const std::string& name, uint32_t default_value) const {
  std::string value = get_env_value(name);
  if (value.empty()) {
    return default_value;
  }

  try {
    return static_cast<uint32_t>(std::stoul(value));
  } catch (const std::exception& error) {
    std::cerr << "warning: failed to parse " << build_env_name(name) << " as uint32_t: " << error.what()
              << ", using default\n";
    return default_value;
  }
}

template <> uint64_t env_config::get<uint64_t>(const std::string& name, uint64_t default_value) const {
  std::string value = get_env_value(name);
  if (value.empty()) {
    return default_value;
  }

  try {
    return std::stoull(value);
  } catch (const std::exception& error) {
    std::cerr << "warning: failed to parse " << build_env_name(name) << " as uint64_t: " << error.what()
              << ", using default\n";
    return default_value;
  }
}

template <> float env_config::get<float>(const std::string& name, float default_value) const {
  std::string value = get_env_value(name);
  if (value.empty()) {
    return default_value;
  }

  try {
    return std::stof(value);
  } catch (const std::exception& error) {
    std::cerr << "warning: failed to parse " << build_env_name(name) << " as float: " << error.what()
              << ", using default\n";
    return default_value;
  }
}

template <> double env_config::get<double>(const std::string& name, double default_value) const {
  std::string value = get_env_value(name);
  if (value.empty()) {
    return default_value;
  }

  try {
    return std::stod(value);
  } catch (const std::exception& error) {
    std::cerr << "warning: failed to parse " << build_env_name(name) << " as double: " << error.what()
              << ", using default\n";
    return default_value;
  }
}

std::vector<std::string> env_config::get_list(const std::string& name, char delimiter) const {
  std::string value = get_env_value(name);
  std::vector<std::string> result;

  if (value.empty()) {
    return result;
  }

  std::stringstream ss(value);
  std::string item;

  while (std::getline(ss, item, delimiter)) {
    result.push_back(trim(item));
  }

  return result;
}

} // namespace w1::util

```

`src/w1base/env_config.hpp`:

```hpp
#pragma once

#include <initializer_list>
#include <iostream>
#include <string>
#include <utility>
#include <vector>

namespace w1::util {

class env_config {
public:
  explicit env_config(const std::string& prefix = "");

  template <typename T> T get(const std::string& name, T default_value) const;

  std::vector<std::string> get_list(const std::string& name, char delimiter = ',') const;

  template <typename enum_type>
  enum_type get_enum(
      const std::initializer_list<std::pair<const char*, enum_type>>& mapping, const std::string& name,
      enum_type default_value
  ) const;

private:
  std::string prefix_;
  std::string build_env_name(const std::string& name) const;
  std::string get_env_value(const std::string& name) const;
  std::string to_lower(const std::string& value) const;
  std::string trim(const std::string& value) const;
};

template <typename enum_type>
enum_type env_config::get_enum(
    const std::initializer_list<std::pair<const char*, enum_type>>& mapping, const std::string& name,
    enum_type default_value
) const {
  std::string value = get_env_value(name);
  if (value.empty()) {
    return default_value;
  }

  std::string lower_value = to_lower(value);

  for (const auto& pair : mapping) {
    if (to_lower(pair.first) == lower_value) {
      return pair.second;
    }
  }

  std::cerr << "warning: unknown value '" << value << "' for " << build_env_name(name) << ", using default\n";
  return default_value;
}

} // namespace w1::util

```

`src/w1base/ext/args.hpp`:

```hpp
/* A simple header-only C++ argument parser library.
 *
 * https://github.com/Taywee/args
 *
 * Copyright (c) 2016-2024 Taylor C. Richberger <taylor@axfive.net> and Pavel
 * Belikov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

/** \file args.hxx
 * \brief this single-header lets you use all of the args functionality
 *
 * The important stuff is done inside the args namespace
 */

#ifndef ARGS_HXX
#define ARGS_HXX

#define ARGS_VERSION "6.4.7"
#define ARGS_VERSION_MAJOR 6
#define ARGS_VERSION_MINOR 4
#define ARGS_VERSION_PATCH 7

#include <algorithm>
#include <cctype>
#include <cstddef>
#include <exception>
#include <functional>
#include <iostream>
#include <iterator>
#include <sstream>
#include <string>
#include <tuple>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#if defined(_MSC_VER) && _MSC_VER <= 1800
#define noexcept
#endif

#ifdef ARGS_TESTNAMESPACE
namespace argstest {
#else

/** \namespace args
 * \brief contains all the functionality of the args library
 */
namespace args {
#endif
/** Getter to grab the value from the argument type.
 *
 * If the Get() function of the type returns a reference, so does this, and
 * the value will be modifiable.
 */
template <typename Option> auto get(Option& option_) -> decltype(option_.Get()) { return option_.Get(); }

/** (INTERNAL) Count UTF-8 glyphs
 *
 * This is not reliable, and will fail for combinatory glyphs, but it's
 * good enough here for now.
 *
 * \param string The string to count glyphs from
 * \return The UTF-8 glyphs in the string
 */
inline std::string::size_type Glyphs(const std::string& string_) {
  std::string::size_type length = 0;
  for (const char c : string_) {
    if ((c & 0xc0) != 0x80) {
      ++length;
    }
  }
  return length;
}

/** (INTERNAL) Wrap a vector of words into a vector of lines
 *
 * Empty words are skipped. Word "\n" forces wrapping.
 *
 * \param begin The begin iterator
 * \param end The end iterator
 * \param width The width of the body
 * \param firstlinewidth the width of the first line, defaults to the width of the body
 * \param firstlineindent the indent of the first line, defaults to 0
 * \return the vector of lines
 */
template <typename It>
inline std::vector<std::string> Wrap(
    It begin, It end, const std::string::size_type width, std::string::size_type firstlinewidth = 0,
    std::string::size_type firstlineindent = 0
) {
  std::vector<std::string> output;
  std::string line(firstlineindent, ' ');
  bool empty = true;

  if (firstlinewidth == 0) {
    firstlinewidth = width;
  }

  auto currentwidth = firstlinewidth;

  for (auto it = begin; it != end; ++it) {
    if (it->empty()) {
      continue;
    }

    if (*it == "\n") {
      if (!empty) {
        output.push_back(line);
        line.clear();
        empty = true;
        currentwidth = width;
      }

      continue;
    }

    auto itemsize = Glyphs(*it);
    if ((line.length() + 1 + itemsize) > currentwidth) {
      if (!empty) {
        output.push_back(line);
        line.clear();
        empty = true;
        currentwidth = width;
      }
    }

    if (itemsize > 0) {
      if (!empty) {
        line += ' ';
      }

      line += *it;
      empty = false;
    }
  }

  if (!empty) {
    output.push_back(line);
  }

  return output;
}

namespace detail {
template <typename T> std::string Join(const T& array, const std::string& delimiter) {
  std::string res;
  for (auto& element : array) {
    if (!res.empty()) {
      res += delimiter;
    }

    res += element;
  }

  return res;
}
} // namespace detail

/** (INTERNAL) Wrap a string into a vector of lines
 *
 * This is quick and hacky, but works well enough.  You can specify a
 * different width for the first line
 *
 * \param width The width of the body
 * \param firstlinewid the width of the first line, defaults to the width of the body
 * \return the vector of lines
 */
inline std::vector<std::string> Wrap(
    const std::string& in, const std::string::size_type width, std::string::size_type firstlinewidth = 0
) {
  // Preserve existing line breaks
  const auto newlineloc = in.find('\n');
  if (newlineloc != in.npos) {
    auto first = Wrap(std::string(in, 0, newlineloc), width);
    auto second = Wrap(std::string(in, newlineloc + 1), width);
    first.insert(
        std::end(first), std::make_move_iterator(std::begin(second)), std::make_move_iterator(std::end(second))
    );
    return first;
  }

  std::istringstream stream(in);
  std::string::size_type indent = 0;

  for (auto c : in) {
    if (!std::isspace(static_cast<unsigned char>(c))) {
      break;
    }
    ++indent;
  }

  return Wrap(
      std::istream_iterator<std::string>(stream), std::istream_iterator<std::string>(), width, firstlinewidth, indent
  );
}

#ifdef ARGS_NOEXCEPT
/// Error class, for when ARGS_NOEXCEPT is defined
enum class Error {
  None,
  Usage,
  Parse,
  Validation,
  Required,
  Map,
  Extra,
  Help,
  Subparser,
  Completion,
};
#else
/** Base error class
 */
class Error : public std::runtime_error {
public:
  Error(const std::string& problem) : std::runtime_error(problem) {}
  virtual ~Error() {}
};

/** Errors that occur during usage
 */
class UsageError : public Error {
public:
  UsageError(const std::string& problem) : Error(problem) {}
  virtual ~UsageError() {}
};

/** Errors that occur during regular parsing
 */
class ParseError : public Error {
public:
  ParseError(const std::string& problem) : Error(problem) {}
  virtual ~ParseError() {}
};

/** Errors that are detected from group validation after parsing finishes
 */
class ValidationError : public Error {
public:
  ValidationError(const std::string& problem) : Error(problem) {}
  virtual ~ValidationError() {}
};

/** Errors that when a required flag is omitted
 */
class RequiredError : public ValidationError {
public:
  RequiredError(const std::string& problem) : ValidationError(problem) {}
  virtual ~RequiredError() {}
};

/** Errors in map lookups
 */
class MapError : public ParseError {
public:
  MapError(const std::string& problem) : ParseError(problem) {}
  virtual ~MapError() {}
};

/** Error that occurs when a singular flag is specified multiple times
 */
class ExtraError : public ParseError {
public:
  ExtraError(const std::string& problem) : ParseError(problem) {}
  virtual ~ExtraError() {}
};

/** An exception that indicates that the user has requested help
 */
class Help : public Error {
public:
  Help(const std::string& flag) : Error(flag) {}
  virtual ~Help() {}
};

/** (INTERNAL) An exception that emulates coroutine-like control flow for subparsers.
 */
class SubparserError : public Error {
public:
  SubparserError() : Error("") {}
  virtual ~SubparserError() {}
};

/** An exception that contains autocompletion reply
 */
class Completion : public Error {
public:
  Completion(const std::string& flag) : Error(flag) {}
  virtual ~Completion() {}
};
#endif

/** A simple unified option type for unified initializer lists for the Matcher class.
 */
struct EitherFlag {
  const bool isShort;
  const char shortFlag;
  const std::string longFlag;
  EitherFlag(const std::string& flag) : isShort(false), shortFlag(), longFlag(flag) {}
  EitherFlag(const char* flag) : isShort(false), shortFlag(), longFlag(flag) {}
  EitherFlag(const char flag) : isShort(true), shortFlag(flag), longFlag() {}

  /** Get just the long flags from an initializer list of EitherFlags
   */
  static std::unordered_set<std::string> GetLong(std::initializer_list<EitherFlag> flags) {
    std::unordered_set<std::string> longFlags;
    for (const EitherFlag& flag : flags) {
      if (!flag.isShort) {
        longFlags.insert(flag.longFlag);
      }
    }
    return longFlags;
  }

  /** Get just the short flags from an initializer list of EitherFlags
   */
  static std::unordered_set<char> GetShort(std::initializer_list<EitherFlag> flags) {
    std::unordered_set<char> shortFlags;
    for (const EitherFlag& flag : flags) {
      if (flag.isShort) {
        shortFlags.insert(flag.shortFlag);
      }
    }
    return shortFlags;
  }

  std::string str() const { return isShort ? std::string(1, shortFlag) : longFlag; }

  std::string str(const std::string& shortPrefix, const std::string& longPrefix) const {
    return isShort ? shortPrefix + std::string(1, shortFlag) : longPrefix + longFlag;
  }
};

/** A class of "matchers", specifying short and flags that can possibly be
 * matched.
 *
 * This is supposed to be constructed and then passed in, not used directly
 * from user code.
 */
class Matcher {
private:
  const std::unordered_set<char> shortFlags;
  const std::unordered_set<std::string> longFlags;

public:
  /** Specify short and long flags separately as iterators
   *
   * ex: `args::Matcher(shortFlags.begin(), shortFlags.end(), longFlags.begin(), longFlags.end())`
   */
  template <typename ShortIt, typename LongIt>
  Matcher(ShortIt shortFlagsStart, ShortIt shortFlagsEnd, LongIt longFlagsStart, LongIt longFlagsEnd)
      : shortFlags(shortFlagsStart, shortFlagsEnd), longFlags(longFlagsStart, longFlagsEnd) {
    if (shortFlags.empty() && longFlags.empty()) {
#ifndef ARGS_NOEXCEPT
      throw UsageError("empty Matcher");
#endif
    }
  }

#ifdef ARGS_NOEXCEPT
  /// Only for ARGS_NOEXCEPT
  Error GetError() const noexcept { return shortFlags.empty() && longFlags.empty() ? Error::Usage : Error::None; }
#endif

  /** Specify short and long flags separately as iterables
   *
   * ex: `args::Matcher(shortFlags, longFlags)`
   */
  template <typename Short, typename Long>
  Matcher(Short&& shortIn, Long&& longIn)
      : Matcher(std::begin(shortIn), std::end(shortIn), std::begin(longIn), std::end(longIn)) {}

  /** Specify a mixed single initializer-list of both short and long flags
   *
   * This is the fancy one.  It takes a single initializer list of
   * any number of any mixed kinds of flags.  Chars are
   * automatically interpreted as short flags, and strings are
   * automatically interpreted as long flags:
   *
   *     args::Matcher{'a'}
   *     args::Matcher{"foo"}
   *     args::Matcher{'h', "help"}
   *     args::Matcher{"foo", 'f', 'F', "FoO"}
   */
  Matcher(std::initializer_list<EitherFlag> in) : Matcher(EitherFlag::GetShort(in), EitherFlag::GetLong(in)) {}

  Matcher(Matcher&& other) noexcept : shortFlags(std::move(other.shortFlags)), longFlags(std::move(other.longFlags)) {}

  ~Matcher() {}

  /** (INTERNAL) Check if there is a match of a short flag
   */
  bool Match(const char flag) const { return shortFlags.find(flag) != shortFlags.end(); }

  /** (INTERNAL) Check if there is a match of a long flag
   */
  bool Match(const std::string& flag) const { return longFlags.find(flag) != longFlags.end(); }

  /** (INTERNAL) Check if there is a match of a flag
   */
  bool Match(const EitherFlag& flag) const { return flag.isShort ? Match(flag.shortFlag) : Match(flag.longFlag); }

  /** (INTERNAL) Get all flag strings as a vector, with the prefixes embedded
   */
  std::vector<EitherFlag> GetFlagStrings() const {
    std::vector<EitherFlag> flagStrings;
    flagStrings.reserve(shortFlags.size() + longFlags.size());
    for (const char flag : shortFlags) {
      flagStrings.emplace_back(flag);
    }
    for (const std::string& flag : longFlags) {
      flagStrings.emplace_back(flag);
    }
    return flagStrings;
  }

  /** (INTERNAL) Get long flag if it exists or any short flag
   */
  EitherFlag GetLongOrAny() const {
    if (!longFlags.empty()) {
      return *longFlags.begin();
    }

    if (!shortFlags.empty()) {
      return *shortFlags.begin();
    }

    // should be unreachable
    return ' ';
  }

  /** (INTERNAL) Get short flag if it exists or any long flag
   */
  EitherFlag GetShortOrAny() const {
    if (!shortFlags.empty()) {
      return *shortFlags.begin();
    }

    if (!longFlags.empty()) {
      return *longFlags.begin();
    }

    // should be unreachable
    return ' ';
  }
};

/** Attributes for flags.
 */
enum class Options {
  /** Default options.
   */
  None = 0x0,

  /** Flag can't be passed multiple times.
   */
  Single = 0x01,

  /** Flag can't be omitted.
   */
  Required = 0x02,

  /** Flag is excluded from usage line.
   */
  HiddenFromUsage = 0x04,

  /** Flag is excluded from options help.
   */
  HiddenFromDescription = 0x08,

  /** Flag is global and can be used in any subcommand.
   */
  Global = 0x10,

  /** Flag stops a parser.
   */
  KickOut = 0x20,

  /** Flag is excluded from auto completion.
   */
  HiddenFromCompletion = 0x40,

  /** Flag is excluded from options help and usage line
   */
  Hidden = HiddenFromUsage | HiddenFromDescription | HiddenFromCompletion,
};

inline Options operator|(Options lhs, Options rhs) {
  return static_cast<Options>(static_cast<int>(lhs) | static_cast<int>(rhs));
}

inline Options operator&(Options lhs, Options rhs) {
  return static_cast<Options>(static_cast<int>(lhs) & static_cast<int>(rhs));
}

class FlagBase;
class PositionalBase;
class Command;
class ArgumentParser;

/** A simple structure of parameters for easy user-modifyable help menus
 */
struct HelpParams {
  /** The width of the help menu
   */
  unsigned int width = 80;
  /** The indent of the program line
   */
  unsigned int progindent = 2;
  /** The indent of the program trailing lines for long parameters
   */
  unsigned int progtailindent = 4;
  /** The indent of the description and epilogs
   */
  unsigned int descriptionindent = 4;
  /** The indent of the flags
   */
  unsigned int flagindent = 6;
  /** The indent of the flag descriptions
   */
  unsigned int helpindent = 40;
  /** The additional indent each group adds
   */
  unsigned int eachgroupindent = 2;

  /** The minimum gutter between each flag and its help
   */
  unsigned int gutter = 1;

  /** Show the terminator when both options and positional parameters are present
   */
  bool showTerminator = true;

  /** Show the {OPTIONS} on the prog line when this is true
   */
  bool showProglineOptions = true;

  /** Show the positionals on the prog line when this is true
   */
  bool showProglinePositionals = true;

  /** The prefix for short flags
   */
  std::string shortPrefix;

  /** The prefix for long flags
   */
  std::string longPrefix;

  /** The separator for short flags
   */
  std::string shortSeparator;

  /** The separator for long flags
   */
  std::string longSeparator;

  /** The program name for help generation
   */
  std::string programName;

  /** Show command's flags
   */
  bool showCommandChildren = false;

  /** Show command's descriptions and epilog
   */
  bool showCommandFullHelp = false;

  /** The postfix for progline when showProglineOptions is true and command has any flags
   */
  std::string proglineOptions = "{OPTIONS}";

  /** The prefix for progline when command has any subcommands
   */
  std::string proglineCommand = "COMMAND";

  /** The prefix for progline value
   */
  std::string proglineValueOpen = " <";

  /** The postfix for progline value
   */
  std::string proglineValueClose = ">";

  /** The prefix for progline required argument
   */
  std::string proglineRequiredOpen = "";

  /** The postfix for progline required argument
   */
  std::string proglineRequiredClose = "";

  /** The prefix for progline non-required argument
   */
  std::string proglineNonrequiredOpen = "[";

  /** The postfix for progline non-required argument
   */
  std::string proglineNonrequiredClose = "]";

  /** Show flags in program line
   */
  bool proglineShowFlags = false;

  /** Use short flags in program lines when possible
   */
  bool proglinePreferShortFlags = false;

  /** Program line prefix
   */
  std::string usageString;

  /** String shown in help before flags descriptions
   */
  std::string optionsString = "OPTIONS:";

  /** Display value name after all the long and short flags
   */
  bool useValueNameOnce = false;

  /** Show value name
   */
  bool showValueName = true;

  /** Add newline before flag description
   */
  bool addNewlineBeforeDescription = false;

  /** The prefix for option value
   */
  std::string valueOpen = "[";

  /** The postfix for option value
   */
  std::string valueClose = "]";

  /** Add choices to argument description
   */
  bool addChoices = false;

  /** The prefix for choices
   */
  std::string choiceString = "\nOne of: ";

  /** Add default values to argument description
   */
  bool addDefault = false;

  /** The prefix for default values
   */
  std::string defaultString = "\nDefault: ";
};

/** A number of arguments which can be consumed by an option.
 *
 * Represents a closed interval [min, max].
 */
struct Nargs {
  const size_t min;
  const size_t max;

  Nargs(size_t min_, size_t max_) : min{min_}, max{max_} {
#ifndef ARGS_NOEXCEPT
    if (max < min) {
      throw UsageError("Nargs: max > min");
    }
#endif
  }

  Nargs(size_t num_) : min{num_}, max{num_} {}

  friend bool operator==(const Nargs& lhs, const Nargs& rhs) { return lhs.min == rhs.min && lhs.max == rhs.max; }

  friend bool operator!=(const Nargs& lhs, const Nargs& rhs) { return !(lhs == rhs); }
};

/** Base class for all match types
 */
class Base {
private:
  Options options = {};

protected:
  bool matched = false;
  const std::string help;
#ifdef ARGS_NOEXCEPT
  /// Only for ARGS_NOEXCEPT
  mutable Error error = Error::None;
  mutable std::string errorMsg;
#endif

public:
  Base(const std::string& help_, Options options_ = {}) : options(options_), help(help_) {}
  virtual ~Base() {}

  Options GetOptions() const noexcept { return options; }

  bool IsRequired() const noexcept { return (GetOptions() & Options::Required) != Options::None; }

  virtual bool Matched() const noexcept { return matched; }

  virtual void Validate(const std::string&, const std::string&) const {}

  operator bool() const noexcept { return Matched(); }

  virtual std::vector<std::tuple<std::string, std::string, unsigned>> GetDescription(
      const HelpParams&, const unsigned indentLevel
  ) const {
    std::tuple<std::string, std::string, unsigned> description;
    std::get<1>(description) = help;
    std::get<2>(description) = indentLevel;
    return {std::move(description)};
  }

  virtual std::vector<Command*> GetCommands() { return {}; }

  virtual bool IsGroup() const { return false; }

  virtual FlagBase* Match(const EitherFlag&) { return nullptr; }

  virtual PositionalBase* GetNextPositional() { return nullptr; }

  virtual std::vector<FlagBase*> GetAllFlags() { return {}; }

  virtual bool HasFlag() const { return false; }

  virtual bool HasPositional() const { return false; }

  virtual bool HasCommand() const { return false; }

  virtual std::vector<std::string> GetProgramLine(const HelpParams&) const { return {}; }

  /// Sets a kick-out value for building subparsers
  void KickOut(bool kickout_) noexcept {
    if (kickout_) {
      options = options | Options::KickOut;
    } else {
      options = static_cast<Options>(static_cast<int>(options) & ~static_cast<int>(Options::KickOut));
    }
  }

  /// Gets the kick-out value for building subparsers
  bool KickOut() const noexcept { return (options & Options::KickOut) != Options::None; }

  virtual void Reset() noexcept {
    matched = false;
#ifdef ARGS_NOEXCEPT
    error = Error::None;
    errorMsg.clear();
#endif
  }

#ifdef ARGS_NOEXCEPT
  /// Only for ARGS_NOEXCEPT
  virtual Error GetError() const { return error; }

  /// Only for ARGS_NOEXCEPT
  virtual std::string GetErrorMsg() const { return errorMsg; }
#endif
};

/** Base class for all match types that have a name
 */
class NamedBase : public Base {
protected:
  const std::string name;
  bool kickout = false;
  std::string defaultString;
  bool defaultStringManual = false;
  std::vector<std::string> choicesStrings;
  bool choicesStringManual = false;

  virtual std::string GetDefaultString(const HelpParams&) const { return {}; }

  virtual std::vector<std::string> GetChoicesStrings(const HelpParams&) const { return {}; }

  virtual std::string GetNameString(const HelpParams&) const { return Name(); }

  void AddDescriptionPostfix(
      std::string& dest, const bool isManual, const std::string& manual, bool isGenerated, const std::string& generated,
      const std::string& str
  ) const {
    if (isManual && !manual.empty()) {
      dest += str;
      dest += manual;
    } else if (!isManual && isGenerated && !generated.empty()) {
      dest += str;
      dest += generated;
    }
  }

public:
  NamedBase(const std::string& name_, const std::string& help_, Options options_ = {})
      : Base(help_, options_), name(name_) {}
  virtual ~NamedBase() {}

  /** Sets default value string that will be added to argument description.
   *  Use empty string to disable it for this argument.
   */
  void HelpDefault(const std::string& str) {
    defaultStringManual = true;
    defaultString = str;
  }

  /** Gets default value string that will be added to argument description.
   */
  std::string HelpDefault(const HelpParams& params) const {
    return defaultStringManual ? defaultString : GetDefaultString(params);
  }

  /** Sets choices strings that will be added to argument description.
   *  Use empty vector to disable it for this argument.
   */
  void HelpChoices(const std::vector<std::string>& array) {
    choicesStringManual = true;
    choicesStrings = array;
  }

  /** Gets choices strings that will be added to argument description.
   */
  std::vector<std::string> HelpChoices(const HelpParams& params) const {
    return choicesStringManual ? choicesStrings : GetChoicesStrings(params);
  }

  virtual std::vector<std::tuple<std::string, std::string, unsigned>> GetDescription(
      const HelpParams& params, const unsigned indentLevel
  ) const override {
    std::tuple<std::string, std::string, unsigned> description;
    std::get<0>(description) = GetNameString(params);
    std::get<1>(description) = help;
    std::get<2>(description) = indentLevel;

    AddDescriptionPostfix(
        std::get<1>(description), choicesStringManual, detail::Join(choicesStrings, ", "), params.addChoices,
        detail::Join(GetChoicesStrings(params), ", "), params.choiceString
    );
    AddDescriptionPostfix(
        std::get<1>(description), defaultStringManual, defaultString, params.addDefault, GetDefaultString(params),
        params.defaultString
    );

    return {std::move(description)};
  }

  virtual std::string Name() const { return name; }
};

namespace detail {
template <typename T> using vector = std::vector<T, std::allocator<T>>;

template <typename K, typename T>
using unordered_map = std::unordered_map<K, T, std::hash<K>, std::equal_to<K>, std::allocator<std::pair<const K, T>>>;

template <typename S, typename T> class is_streamable {
  template <typename SS, typename TT>
  static auto test(int) -> decltype(std::declval<SS&>() << std::declval<TT>(), std::true_type());

  template <typename, typename> static auto test(...) -> std::false_type;

public:
  using type = decltype(test<S, T>(0));
};

template <typename T> using IsConvertableToString = typename is_streamable<std::ostringstream, T>::type;

template <typename T>
typename std::enable_if<IsConvertableToString<T>::value, std::string>::type ToString(const T& value) {
  std::ostringstream s;
  s << value;
  return s.str();
}

template <typename T> typename std::enable_if<!IsConvertableToString<T>::value, std::string>::type ToString(const T&) {
  return {};
}

template <typename T> std::vector<std::string> MapKeysToStrings(const T& map) {
  std::vector<std::string> res;
  using K = typename std::decay<decltype(std::begin(map)->first)>::type;
  if (IsConvertableToString<K>::value) {
    for (const auto& p : map) {
      res.push_back(detail::ToString(p.first));
    }

    std::sort(res.begin(), res.end());
  }
  return res;
}
} // namespace detail

/** Base class for all flag options
 */
class FlagBase : public NamedBase {
protected:
  const Matcher matcher;

  virtual std::string GetNameString(const HelpParams& params) const override {
    const std::string postfix = !params.showValueName || NumberOfArguments() == 0 ? std::string() : Name();
    std::string flags;
    const auto flagStrings = matcher.GetFlagStrings();
    const bool useValueNameOnce = flagStrings.size() == 1 ? false : params.useValueNameOnce;
    for (auto it = flagStrings.begin(); it != flagStrings.end(); ++it) {
      auto& flag = *it;
      if (it != flagStrings.begin()) {
        flags += ", ";
      }

      flags += flag.isShort ? params.shortPrefix : params.longPrefix;
      flags += flag.str();

      if (!postfix.empty() && (!useValueNameOnce || it + 1 == flagStrings.end())) {
        flags += flag.isShort ? params.shortSeparator : params.longSeparator;
        flags += params.valueOpen + postfix + params.valueClose;
      }
    }

    return flags;
  }

public:
  FlagBase(const std::string& name_, const std::string& help_, Matcher&& matcher_, const bool extraError_ = false)
      : NamedBase(name_, help_, extraError_ ? Options::Single : Options()), matcher(std::move(matcher_)) {}

  FlagBase(const std::string& name_, const std::string& help_, Matcher&& matcher_, Options options_)
      : NamedBase(name_, help_, options_), matcher(std::move(matcher_)) {}

  virtual ~FlagBase() {}

  virtual FlagBase* Match(const EitherFlag& flag) override {
    if (matcher.Match(flag)) {
      if ((GetOptions() & Options::Single) != Options::None && matched) {
        std::ostringstream problem;
        problem << "Flag '" << flag.str() << "' was passed multiple times, but is only allowed to be passed once";
#ifdef ARGS_NOEXCEPT
        error = Error::Extra;
        errorMsg = problem.str();
#else
        throw ExtraError(problem.str());
#endif
      }
      matched = true;
      return this;
    }
    return nullptr;
  }

  virtual std::vector<FlagBase*> GetAllFlags() override { return {this}; }

  const Matcher& GetMatcher() const { return matcher; }

  virtual void Validate(const std::string& shortPrefix, const std::string& longPrefix) const override {
    if (!Matched() && IsRequired()) {
      std::ostringstream problem;
      problem << "Flag '" << matcher.GetLongOrAny().str(shortPrefix, longPrefix) << "' is required";
#ifdef ARGS_NOEXCEPT
      error = Error::Required;
      errorMsg = problem.str();
#else
      throw RequiredError(problem.str());
#endif
    }
  }

  virtual std::vector<std::string> GetProgramLine(const HelpParams& params) const override {
    if (!params.proglineShowFlags) {
      return {};
    }

    const std::string postfix = NumberOfArguments() == 0 ? std::string() : Name();
    const EitherFlag flag = params.proglinePreferShortFlags ? matcher.GetShortOrAny() : matcher.GetLongOrAny();
    std::string res = flag.str(params.shortPrefix, params.longPrefix);
    if (!postfix.empty()) {
      res += params.proglineValueOpen + postfix + params.proglineValueClose;
    }

    return {
        IsRequired() ? params.proglineRequiredOpen + res + params.proglineRequiredClose
                     : params.proglineNonrequiredOpen + res + params.proglineNonrequiredClose
    };
  }

  virtual bool HasFlag() const override { return true; }

#ifdef ARGS_NOEXCEPT
  /// Only for ARGS_NOEXCEPT
  virtual Error GetError() const override {
    const auto nargs = NumberOfArguments();
    if (nargs.min > nargs.max) {
      return Error::Usage;
    }

    const auto matcherError = matcher.GetError();
    if (matcherError != Error::None) {
      return matcherError;
    }

    return error;
  }
#endif

  /** Defines how many values can be consumed by this option.
   *
   * \return closed interval [min, max]
   */
  virtual Nargs NumberOfArguments() const noexcept = 0;

  /** Parse values of this option.
   *
   * \param value Vector of values. It's size must be in NumberOfArguments() interval.
   */
  virtual void ParseValue(const std::vector<std::string>& value) = 0;
};

/** Base class for value-accepting flag options
 */
class ValueFlagBase : public FlagBase {
public:
  ValueFlagBase(const std::string& name_, const std::string& help_, Matcher&& matcher_, const bool extraError_ = false)
      : FlagBase(name_, help_, std::move(matcher_), extraError_) {}
  ValueFlagBase(const std::string& name_, const std::string& help_, Matcher&& matcher_, Options options_)
      : FlagBase(name_, help_, std::move(matcher_), options_) {}
  virtual ~ValueFlagBase() {}

  virtual Nargs NumberOfArguments() const noexcept override { return 1; }
};

class CompletionFlag : public ValueFlagBase {
public:
  std::vector<std::string> reply;
  size_t cword = 0;
  std::string syntax;

  template <typename GroupClass>
  CompletionFlag(GroupClass& group_, Matcher&& matcher_)
      : ValueFlagBase("completion", "completion flag", std::move(matcher_), Options::Hidden) {
    group_.AddCompletion(*this);
  }

  virtual ~CompletionFlag() {}

  virtual Nargs NumberOfArguments() const noexcept override { return 2; }

  virtual void ParseValue(const std::vector<std::string>& value_) override {
    syntax = value_.at(0);
    std::istringstream(value_.at(1)) >> cword;
  }

  /** Get the completion reply
   */
  std::string Get() noexcept { return detail::Join(reply, "\n"); }

  virtual void Reset() noexcept override {
    ValueFlagBase::Reset();
    cword = 0;
    syntax.clear();
    reply.clear();
  }
};

/** Base class for positional options
 */
class PositionalBase : public NamedBase {
protected:
  bool ready;

public:
  PositionalBase(const std::string& name_, const std::string& help_, Options options_ = {})
      : NamedBase(name_, help_, options_), ready(true) {}
  virtual ~PositionalBase() {}

  bool Ready() { return ready; }

  virtual void ParseValue(const std::string& value_) = 0;

  virtual void Reset() noexcept override {
    matched = false;
    ready = true;
#ifdef ARGS_NOEXCEPT
    error = Error::None;
    errorMsg.clear();
#endif
  }

  virtual PositionalBase* GetNextPositional() override { return Ready() ? this : nullptr; }

  virtual bool HasPositional() const override { return true; }

  virtual std::vector<std::string> GetProgramLine(const HelpParams& params) const override {
    return {
        IsRequired() ? params.proglineRequiredOpen + Name() + params.proglineRequiredClose
                     : params.proglineNonrequiredOpen + Name() + params.proglineNonrequiredClose
    };
  }

  virtual void Validate(const std::string&, const std::string&) const override {
    if (IsRequired() && !Matched()) {
      std::ostringstream problem;
      problem << "Option '" << Name() << "' is required";
#ifdef ARGS_NOEXCEPT
      error = Error::Required;
      errorMsg = problem.str();
#else
      throw RequiredError(problem.str());
#endif
    }
  }
};

/** Class for all kinds of validating groups, including ArgumentParser
 */
class Group : public Base {
private:
  std::vector<Base*> children;
  std::function<bool(const Group&)> validator;

public:
  /** Default validators
   */
  struct Validators {
    static bool Xor(const Group& group) { return group.MatchedChildren() == 1; }

    static bool AtLeastOne(const Group& group) { return group.MatchedChildren() >= 1; }

    static bool AtMostOne(const Group& group) { return group.MatchedChildren() <= 1; }

    static bool All(const Group& group) { return group.Children().size() == group.MatchedChildren(); }

    static bool AllOrNone(const Group& group) { return (All(group) || None(group)); }

    static bool AllChildGroups(const Group& group) {
      return std::none_of(std::begin(group.Children()), std::end(group.Children()), [](const Base* child) -> bool {
        return child->IsGroup() && !child->Matched();
      });
    }

    static bool DontCare(const Group&) { return true; }

    static bool CareTooMuch(const Group&) { return false; }

    static bool None(const Group& group) { return group.MatchedChildren() == 0; }
  };
  /// If help is empty, this group will not be printed in help output
  Group(
      const std::string& help_ = std::string(),
      const std::function<bool(const Group&)>& validator_ = Validators::DontCare, Options options_ = {}
  )
      : Base(help_, options_), validator(validator_) {}
  /// If help is empty, this group will not be printed in help output
  Group(
      Group& group_, const std::string& help_ = std::string(),
      const std::function<bool(const Group&)>& validator_ = Validators::DontCare, Options options_ = {}
  )
      : Base(help_, options_), validator(validator_) {
    group_.Add(*this);
  }
  virtual ~Group() {}

  /** Append a child to this Group.
   */
  void Add(Base& child) { children.emplace_back(&child); }

  /** Get all this group's children
   */
  const std::vector<Base*>& Children() const { return children; }

  /** Return the first FlagBase that matches flag, or nullptr
   *
   * \param flag The flag with prefixes stripped
   * \return the first matching FlagBase pointer, or nullptr if there is no match
   */
  virtual FlagBase* Match(const EitherFlag& flag) override {
    for (Base* child : Children()) {
      if (FlagBase* match = child->Match(flag)) {
        return match;
      }
    }
    return nullptr;
  }

  virtual std::vector<FlagBase*> GetAllFlags() override {
    std::vector<FlagBase*> res;
    for (Base* child : Children()) {
      auto childRes = child->GetAllFlags();
      res.insert(res.end(), childRes.begin(), childRes.end());
    }
    return res;
  }

  virtual void Validate(const std::string& shortPrefix, const std::string& longPrefix) const override {
    for (Base* child : Children()) {
      child->Validate(shortPrefix, longPrefix);
    }
  }

  /** Get the next ready positional, or nullptr if there is none
   *
   * \return the first ready PositionalBase pointer, or nullptr if there is no match
   */
  virtual PositionalBase* GetNextPositional() override {
    for (Base* child : Children()) {
      if (auto next = child->GetNextPositional()) {
        return next;
      }
    }
    return nullptr;
  }

  /** Get whether this has any FlagBase children
   *
   * \return Whether or not there are any FlagBase children
   */
  virtual bool HasFlag() const override {
    return std::any_of(Children().begin(), Children().end(), [](Base* child) { return child->HasFlag(); });
  }

  /** Get whether this has any PositionalBase children
   *
   * \return Whether or not there are any PositionalBase children
   */
  virtual bool HasPositional() const override {
    return std::any_of(Children().begin(), Children().end(), [](Base* child) { return child->HasPositional(); });
  }

  /** Get whether this has any Command children
   *
   * \return Whether or not there are any Command children
   */
  virtual bool HasCommand() const override {
    return std::any_of(Children().begin(), Children().end(), [](Base* child) { return child->HasCommand(); });
  }

  /** Count the number of matched children this group has
   */
  std::vector<Base*>::size_type MatchedChildren() const {
    // Cast to avoid warnings from -Wsign-conversion
    return static_cast<std::vector<Base*>::size_type>(
        std::count_if(std::begin(Children()), std::end(Children()), [](const Base* child) { return child->Matched(); })
    );
  }

  /** Whether or not this group matches validation
   */
  virtual bool Matched() const noexcept override { return validator(*this); }

  /** Get validation
   */
  bool Get() const { return Matched(); }

  /** Get all the child descriptions for help generation
   */
  virtual std::vector<std::tuple<std::string, std::string, unsigned>> GetDescription(
      const HelpParams& params, const unsigned int indent
  ) const override {
    std::vector<std::tuple<std::string, std::string, unsigned int>> descriptions;

    // Push that group description on the back if not empty
    unsigned addindent = 0;
    if (!help.empty()) {
      descriptions.emplace_back(help, "", indent);
      addindent = 1;
    }

    for (Base* child : Children()) {
      if ((child->GetOptions() & Options::HiddenFromDescription) != Options::None) {
        continue;
      }

      auto groupDescriptions = child->GetDescription(params, indent + addindent);
      descriptions.insert(
          std::end(descriptions), std::make_move_iterator(std::begin(groupDescriptions)),
          std::make_move_iterator(std::end(groupDescriptions))
      );
    }
    return descriptions;
  }

  /** Get the names of positional parameters
   */
  virtual std::vector<std::string> GetProgramLine(const HelpParams& params) const override {
    std::vector<std::string> names;
    for (Base* child : Children()) {
      if ((child->GetOptions() & Options::HiddenFromUsage) != Options::None) {
        continue;
      }

      auto groupNames = child->GetProgramLine(params);
      names.insert(
          std::end(names), std::make_move_iterator(std::begin(groupNames)),
          std::make_move_iterator(std::end(groupNames))
      );
    }
    return names;
  }

  virtual std::vector<Command*> GetCommands() override {
    std::vector<Command*> res;
    for (const auto& child : Children()) {
      auto subparsers = child->GetCommands();
      res.insert(std::end(res), std::begin(subparsers), std::end(subparsers));
    }
    return res;
  }

  virtual bool IsGroup() const override { return true; }

  virtual void Reset() noexcept override {
    Base::Reset();

    for (auto& child : Children()) {
      child->Reset();
    }
#ifdef ARGS_NOEXCEPT
    error = Error::None;
    errorMsg.clear();
#endif
  }

#ifdef ARGS_NOEXCEPT
  /// Only for ARGS_NOEXCEPT
  virtual Error GetError() const override {
    if (error != Error::None) {
      return error;
    }

    auto it = std::find_if(Children().begin(), Children().end(), [](const Base* child) {
      return child->GetError() != Error::None;
    });
    if (it == Children().end()) {
      return Error::None;
    } else {
      return (*it)->GetError();
    }
  }

  /// Only for ARGS_NOEXCEPT
  virtual std::string GetErrorMsg() const override {
    if (error != Error::None) {
      return errorMsg;
    }

    auto it = std::find_if(Children().begin(), Children().end(), [](const Base* child) {
      return child->GetError() != Error::None;
    });
    if (it == Children().end()) {
      return "";
    } else {
      return (*it)->GetErrorMsg();
    }
  }
#endif
};

/** Class for using global options in ArgumentParser.
 */
class GlobalOptions : public Group {
public:
  GlobalOptions(Group& base, Base& options_) : Group(base, {}, Group::Validators::DontCare, Options::Global) {
    Add(options_);
  }
};

/** Utility class for building subparsers with coroutines/callbacks.
 *
 * Brief example:
 * \code
 * Command command(argumentParser, "command", "my command", [](args::Subparser &s)
 * {
 *      // your command flags/positionals
 *      s.Parse(); //required
 *      //your command code
 * });
 * \endcode
 *
 * For ARGS_NOEXCEPT mode don't forget to check `s.GetError()` after `s.Parse()`
 * and return if it isn't equals to args::Error::None.
 *
 * \sa Command
 */
class Subparser : public Group {
private:
  std::vector<std::string> args;
  std::vector<std::string> kicked;
  ArgumentParser* parser = nullptr;
  const HelpParams& helpParams;
  const Command& command;
  bool isParsed = false;

public:
  Subparser(
      std::vector<std::string> args_, ArgumentParser& parser_, const Command& command_, const HelpParams& helpParams_
  )
      : Group({}, Validators::AllChildGroups), args(std::move(args_)), parser(&parser_), helpParams(helpParams_),
        command(command_) {}

  Subparser(const Command& command_, const HelpParams& helpParams_)
      : Group({}, Validators::AllChildGroups), helpParams(helpParams_), command(command_) {}

  Subparser(const Subparser&) = delete;
  Subparser(Subparser&&) = delete;
  Subparser& operator=(const Subparser&) = delete;
  Subparser& operator=(Subparser&&) = delete;

  const Command& GetCommand() { return command; }

  /** (INTERNAL) Determines whether Parse was called or not.
   */
  bool IsParsed() const { return isParsed; }

  /** Continue parsing arguments for new command.
   */
  void Parse();

  /** Returns a vector of kicked out arguments.
   *
   * \sa Base::KickOut
   */
  const std::vector<std::string>& KickedOut() const noexcept { return kicked; }
};

/** Main class for building subparsers.
 *
 * /sa Subparser
 */
class Command : public Group {
private:
  friend class Subparser;

  std::string name;
  std::string help;
  std::string description;
  std::string epilog;
  std::string proglinePostfix;

  std::function<void(Subparser&)> parserCoroutine;
  bool commandIsRequired = true;
  Command* selectedCommand = nullptr;

  mutable std::vector<std::tuple<std::string, std::string, unsigned>> subparserDescription;
  mutable std::vector<std::string> subparserProgramLine;
  mutable bool subparserHasFlag = false;
  mutable bool subparserHasPositional = false;
  mutable bool subparserHasCommand = false;
#ifdef ARGS_NOEXCEPT
  mutable Error subparserError = Error::None;
#endif
  mutable Subparser* subparser = nullptr;

protected:
  class RaiiSubparser {
  public:
    RaiiSubparser(ArgumentParser& parser_, std::vector<std::string> args_);
    RaiiSubparser(const Command& command_, const HelpParams& params_);

    ~RaiiSubparser() { command.subparser = oldSubparser; }

    Subparser& Parser() { return parser; }

  private:
    const Command& command;
    Subparser parser;
    Subparser* oldSubparser;
  };

  Command() = default;

  std::function<void(Subparser&)>& GetCoroutine() {
    return selectedCommand != nullptr ? selectedCommand->GetCoroutine() : parserCoroutine;
  }

  Command& SelectedCommand() {
    Command* res = this;
    while (res->selectedCommand != nullptr) {
      res = res->selectedCommand;
    }

    return *res;
  }

  const Command& SelectedCommand() const {
    const Command* res = this;
    while (res->selectedCommand != nullptr) {
      res = res->selectedCommand;
    }

    return *res;
  }

  void UpdateSubparserHelp(const HelpParams& params) const {
    if (parserCoroutine) {
      RaiiSubparser coro(*this, params);
#ifndef ARGS_NOEXCEPT
      try {
        parserCoroutine(coro.Parser());
      } catch (args::SubparserError&) {
      }
#else
      parserCoroutine(coro.Parser());
#endif
    }
  }

public:
  Command(Group& base_, std::string name_, std::string help_, std::function<void(Subparser&)> coroutine_ = {})
      : name(std::move(name_)), help(std::move(help_)), parserCoroutine(std::move(coroutine_)) {
    base_.Add(*this);
  }

  /** The description that appears on the prog line after options
   */
  const std::string& ProglinePostfix() const { return proglinePostfix; }

  /** The description that appears on the prog line after options
   */
  void ProglinePostfix(const std::string& proglinePostfix_) { this->proglinePostfix = proglinePostfix_; }

  /** The description that appears above options
   */
  const std::string& Description() const { return description; }
  /** The description that appears above options
   */

  void Description(const std::string& description_) { this->description = description_; }

  /** The description that appears below options
   */
  const std::string& Epilog() const { return epilog; }

  /** The description that appears below options
   */
  void Epilog(const std::string& epilog_) { this->epilog = epilog_; }

  /** The name of command
   */
  const std::string& Name() const { return name; }

  /** The description of command
   */
  const std::string& Help() const { return help; }

  /** If value is true, parser will fail if no command was parsed.
   *
   * Default: true.
   */
  void RequireCommand(bool value) { commandIsRequired = value; }

  virtual bool IsGroup() const override { return false; }

  virtual bool Matched() const noexcept override { return Base::Matched(); }

  operator bool() const noexcept { return Matched(); }

  void Match() noexcept { matched = true; }

  void SelectCommand(Command* c) noexcept {
    selectedCommand = c;

    if (c != nullptr) {
      c->Match();
    }
  }

  virtual FlagBase* Match(const EitherFlag& flag) override {
    if (selectedCommand != nullptr) {
      if (auto* res = selectedCommand->Match(flag)) {
        return res;
      }

      for (auto* child : Children()) {
        if ((child->GetOptions() & Options::Global) != Options::None) {
          if (auto* res = child->Match(flag)) {
            return res;
          }
        }
      }

      return nullptr;
    }

    if (subparser != nullptr) {
      return subparser->Match(flag);
    }

    return Matched() ? Group::Match(flag) : nullptr;
  }

  virtual std::vector<FlagBase*> GetAllFlags() override {
    std::vector<FlagBase*> res;

    if (!Matched()) {
      return res;
    }

    for (auto* child : Children()) {
      if (selectedCommand == nullptr || (child->GetOptions() & Options::Global) != Options::None) {
        auto childFlags = child->GetAllFlags();
        res.insert(res.end(), childFlags.begin(), childFlags.end());
      }
    }

    if (selectedCommand != nullptr) {
      auto childFlags = selectedCommand->GetAllFlags();
      res.insert(res.end(), childFlags.begin(), childFlags.end());
    }

    if (subparser != nullptr) {
      auto childFlags = subparser->GetAllFlags();
      res.insert(res.end(), childFlags.begin(), childFlags.end());
    }

    return res;
  }

  virtual PositionalBase* GetNextPositional() override {
    if (selectedCommand != nullptr) {
      if (auto* res = selectedCommand->GetNextPositional()) {
        return res;
      }

      for (auto* child : Children()) {
        if ((child->GetOptions() & Options::Global) != Options::None) {
          if (auto* res = child->GetNextPositional()) {
            return res;
          }
        }
      }

      return nullptr;
    }

    if (subparser != nullptr) {
      return subparser->GetNextPositional();
    }

    return Matched() ? Group::GetNextPositional() : nullptr;
  }

  virtual bool HasFlag() const override { return subparserHasFlag || Group::HasFlag(); }

  virtual bool HasPositional() const override { return subparserHasPositional || Group::HasPositional(); }

  virtual bool HasCommand() const override { return true; }

  std::vector<std::string> GetCommandProgramLine(const HelpParams& params) const {
    UpdateSubparserHelp(params);

    std::vector<std::string> res;

    if ((subparserHasFlag || Group::HasFlag()) && params.showProglineOptions && !params.proglineShowFlags) {
      res.push_back(params.proglineOptions);
    }

    auto group_res = Group::GetProgramLine(params);
    std::move(std::move(group_res).begin(), std::move(group_res).end(), std::back_inserter(res));

    res.insert(res.end(), subparserProgramLine.begin(), subparserProgramLine.end());

    if (!params.proglineCommand.empty() && (Group::HasCommand() || subparserHasCommand)) {
      res.insert(res.begin(), commandIsRequired ? params.proglineCommand : "[" + params.proglineCommand + "]");
    }

    if (!Name().empty()) {
      res.insert(res.begin(), Name());
    }

    if (!ProglinePostfix().empty()) {
      std::string line;
      for (auto c : ProglinePostfix()) {
        if (std::isspace(static_cast<unsigned char>(c))) {
          if (!line.empty()) {
            res.push_back(line);
            line.clear();
          }

          if (c == '\n') {
            res.push_back("\n");
          }
        } else {
          line += c;
        }
      }

      if (!line.empty()) {
        res.push_back(line);
      }
    }

    return res;
  }

  virtual std::vector<std::string> GetProgramLine(const HelpParams& params) const override {
    if (!Matched()) {
      return {};
    }

    return GetCommandProgramLine(params);
  }

  virtual std::vector<Command*> GetCommands() override {
    if (selectedCommand != nullptr) {
      return selectedCommand->GetCommands();
    }

    if (Matched()) {
      return Group::GetCommands();
    }

    return {this};
  }

  virtual std::vector<std::tuple<std::string, std::string, unsigned>> GetDescription(
      const HelpParams& params, const unsigned int indent
  ) const override {
    std::vector<std::tuple<std::string, std::string, unsigned>> descriptions;
    unsigned addindent = 0;

    UpdateSubparserHelp(params);

    if (!Matched()) {
      if (params.showCommandFullHelp) {
        std::ostringstream s;
        bool empty = true;
        for (const auto& progline : GetCommandProgramLine(params)) {
          if (!empty) {
            s << ' ';
          } else {
            empty = false;
          }

          s << progline;
        }

        descriptions.emplace_back(s.str(), "", indent);
      } else {
        descriptions.emplace_back(Name(), help, indent);
      }

      if (!params.showCommandChildren && !params.showCommandFullHelp) {
        return descriptions;
      }

      addindent = 1;
    }

    if (params.showCommandFullHelp && !Matched()) {
      descriptions.emplace_back("", "", indent + addindent);
      descriptions.emplace_back(Description().empty() ? Help() : Description(), "", indent + addindent);
      descriptions.emplace_back("", "", indent + addindent);
    }

    for (Base* child : Children()) {
      if ((child->GetOptions() & Options::HiddenFromDescription) != Options::None) {
        continue;
      }

      auto groupDescriptions = child->GetDescription(params, indent + addindent);
      descriptions.insert(
          std::end(descriptions), std::make_move_iterator(std::begin(groupDescriptions)),
          std::make_move_iterator(std::end(groupDescriptions))
      );
    }

    for (auto childDescription : subparserDescription) {
      std::get<2>(childDescription) += indent + addindent;
      descriptions.push_back(std::move(childDescription));
    }

    if (params.showCommandFullHelp && !Matched()) {
      descriptions.emplace_back("", "", indent + addindent);
      if (!Epilog().empty()) {
        descriptions.emplace_back(Epilog(), "", indent + addindent);
        descriptions.emplace_back("", "", indent + addindent);
      }
    }

    return descriptions;
  }

  virtual void Validate(const std::string& shortprefix, const std::string& longprefix) const override {
    if (!Matched()) {
      return;
    }

    auto onValidationError = [&] {
      std::ostringstream problem;
      problem << "Group validation failed somewhere!";
#ifdef ARGS_NOEXCEPT
      error = Error::Validation;
      errorMsg = problem.str();
#else
      throw ValidationError(problem.str());
#endif
    };

    for (Base* child : Children()) {
      if (child->IsGroup() && !child->Matched()) {
        onValidationError();
      }

      child->Validate(shortprefix, longprefix);
    }

    if (subparser != nullptr) {
      subparser->Validate(shortprefix, longprefix);
      if (!subparser->Matched()) {
        onValidationError();
      }
    }

    if (selectedCommand == nullptr && commandIsRequired && (Group::HasCommand() || subparserHasCommand)) {
      std::ostringstream problem;
      problem << "Command is required";
#ifdef ARGS_NOEXCEPT
      error = Error::Validation;
      errorMsg = problem.str();
#else
      throw ValidationError(problem.str());
#endif
    }
  }

  virtual void Reset() noexcept override {
    Group::Reset();
    selectedCommand = nullptr;
    subparserProgramLine.clear();
    subparserDescription.clear();
    subparserHasFlag = false;
    subparserHasPositional = false;
    subparserHasCommand = false;
#ifdef ARGS_NOEXCEPT
    subparserError = Error::None;
#endif
  }

#ifdef ARGS_NOEXCEPT
  /// Only for ARGS_NOEXCEPT
  virtual Error GetError() const override {
    if (!Matched()) {
      return Error::None;
    }

    if (error != Error::None) {
      return error;
    }

    if (subparserError != Error::None) {
      return subparserError;
    }

    return Group::GetError();
  }
#endif
};

/** The main user facing command line argument parser class
 */
class ArgumentParser : public Command {
  friend class Subparser;

private:
  std::string longprefix;
  std::string shortprefix;

  std::string longseparator;

  std::string terminator;

  bool allowJoinedShortValue = true;
  bool allowJoinedLongValue = true;
  bool allowSeparateShortValue = true;
  bool allowSeparateLongValue = true;

  CompletionFlag* completion = nullptr;
  bool readCompletion = false;

protected:
  enum class OptionType { LongFlag, ShortFlag, Positional };

  OptionType ParseOption(const std::string& s, bool allowEmpty = false) {
    if (s.find(longprefix) == 0 && (allowEmpty || s.length() > longprefix.length())) {
      return OptionType::LongFlag;
    }

    if (s.find(shortprefix) == 0 && (allowEmpty || s.length() > shortprefix.length())) {
      return OptionType::ShortFlag;
    }

    return OptionType::Positional;
  }

  template <typename It> bool Complete(FlagBase& flag, It it, It end) {
    auto nextIt = it;
    if (!readCompletion || (++nextIt != end)) {
      return false;
    }

    const auto& chunk = *it;
    for (auto& choice : flag.HelpChoices(helpParams)) {
      AddCompletionReply(chunk, choice);
    }

#ifndef ARGS_NOEXCEPT
    throw Completion(completion->Get());
#else
    return true;
#endif
  }

  /** (INTERNAL) Parse flag's values
   *
   * \param arg The string to display in error message as a flag name
   * \param[in, out] it The iterator to first value. It will point to the last value
   * \param end The end iterator
   * \param joinedArg Joined value (e.g. bar in --foo=bar)
   * \param canDiscardJoined If true joined value can be parsed as flag not as a value (as in -abcd)
   * \param[out] values The vector to store parsed arg's values
   */
  template <typename It>
  std::string ParseArgsValues(
      FlagBase& flag, const std::string& arg, It& it, It end, const bool allowSeparate, const bool allowJoined,
      const bool hasJoined, const std::string& joinedArg, const bool canDiscardJoined, std::vector<std::string>& values
  ) {
    values.clear();

    Nargs nargs = flag.NumberOfArguments();

    if (hasJoined && !allowJoined && nargs.min != 0) {
      return "Flag '" + arg + "' was passed a joined argument, but these are disallowed";
    }

    if (hasJoined) {
      if (!canDiscardJoined || nargs.max != 0) {
        values.push_back(joinedArg);
      }
    } else if (!allowSeparate) {
      if (nargs.min != 0) {
        return "Flag '" + arg + "' was passed a separate argument, but these are disallowed";
      }
    } else {
      auto valueIt = it;
      ++valueIt;

      while (valueIt != end && values.size() < nargs.max &&
             (values.size() < nargs.min || ParseOption(*valueIt) == OptionType::Positional)) {
        if (Complete(flag, valueIt, end)) {
          it = end;
          return "";
        }

        values.push_back(*valueIt);
        ++it;
        ++valueIt;
      }
    }

    if (values.size() > nargs.max) {
      return "Passed an argument into a non-argument flag: " + arg;
    } else if (values.size() < nargs.min) {
      if (nargs.min == 1 && nargs.max == 1) {
        return "Flag '" + arg + "' requires an argument but received none";
      } else if (nargs.min == 1) {
        return "Flag '" + arg + "' requires at least one argument but received none";
      } else if (nargs.min != nargs.max) {
        return "Flag '" + arg + "' requires at least " + std::to_string(nargs.min) + " arguments but received " +
               std::to_string(values.size());
      } else {
        return "Flag '" + arg + "' requires " + std::to_string(nargs.min) + " arguments but received " +
               std::to_string(values.size());
      }
    }

    return {};
  }

  template <typename It> bool ParseLong(It& it, It end) {
    const auto& chunk = *it;
    const auto argchunk = chunk.substr(longprefix.size());
    // Try to separate it, in case of a separator:
    const auto separator = longseparator.empty() ? argchunk.npos : argchunk.find(longseparator);
    // If the separator is in the argument, separate it.
    const auto arg = (separator != argchunk.npos ? std::string(argchunk, 0, separator) : argchunk);
    const auto joined =
        (separator != argchunk.npos ? argchunk.substr(separator + longseparator.size()) : std::string());

    if (auto flag = Match(arg)) {
      std::vector<std::string> values;
      const std::string errorMessage = ParseArgsValues(
          *flag, arg, it, end, allowSeparateLongValue, allowJoinedLongValue, separator != argchunk.npos, joined, false,
          values
      );
      if (!errorMessage.empty()) {
#ifndef ARGS_NOEXCEPT
        throw ParseError(errorMessage);
#else
        error = Error::Parse;
        errorMsg = errorMessage;
        return false;
#endif
      }

      if (!readCompletion) {
        flag->ParseValue(values);
      }

      if (flag->KickOut()) {
        ++it;
        return false;
      }
    } else {
      const std::string errorMessage("Flag could not be matched: " + arg);
#ifndef ARGS_NOEXCEPT
      throw ParseError(errorMessage);
#else
      error = Error::Parse;
      errorMsg = errorMessage;
      return false;
#endif
    }

    return true;
  }

  template <typename It> bool ParseShort(It& it, It end) {
    const auto& chunk = *it;
    const auto argchunk = chunk.substr(shortprefix.size());
    for (auto argit = std::begin(argchunk); argit != std::end(argchunk); ++argit) {
      const auto arg = *argit;

      if (auto flag = Match(arg)) {
        const std::string value(argit + 1, std::end(argchunk));
        std::vector<std::string> values;
        const std::string errorMessage = ParseArgsValues(
            *flag, std::string(1, arg), it, end, allowSeparateShortValue, allowJoinedShortValue, !value.empty(), value,
            !value.empty(), values
        );

        if (!errorMessage.empty()) {
#ifndef ARGS_NOEXCEPT
          throw ParseError(errorMessage);
#else
          error = Error::Parse;
          errorMsg = errorMessage;
          return false;
#endif
        }

        if (!readCompletion) {
          flag->ParseValue(values);
        }

        if (flag->KickOut()) {
          ++it;
          return false;
        }

        if (!values.empty()) {
          break;
        }
      } else {
        const std::string errorMessage("Flag could not be matched: '" + std::string(1, arg) + "'");
#ifndef ARGS_NOEXCEPT
        throw ParseError(errorMessage);
#else
        error = Error::Parse;
        errorMsg = errorMessage;
        return false;
#endif
      }
    }

    return true;
  }

  bool AddCompletionReply(const std::string& cur, const std::string& choice) {
    if (cur.empty() || choice.find(cur) == 0) {
      if (completion->syntax == "bash" && ParseOption(choice) == OptionType::LongFlag &&
          choice.find(longseparator) != std::string::npos) {
        completion->reply.push_back(choice.substr(choice.find(longseparator) + 1));
      } else {
        completion->reply.push_back(choice);
      }
      return true;
    }

    return false;
  }

  template <typename It> bool Complete(It it, It end) {
    auto nextIt = it;
    if (!readCompletion || (++nextIt != end)) {
      return false;
    }

    const auto& chunk = *it;
    auto pos = GetNextPositional();
    std::vector<Command*> commands = GetCommands();
    const auto optionType = ParseOption(chunk, true);

    if (!commands.empty() && (chunk.empty() || optionType == OptionType::Positional)) {
      for (auto& cmd : commands) {
        if ((cmd->GetOptions() & Options::HiddenFromCompletion) == Options::None) {
          AddCompletionReply(chunk, cmd->Name());
        }
      }
    } else {
      bool hasPositionalCompletion = true;

      if (!commands.empty()) {
        for (auto& cmd : commands) {
          if ((cmd->GetOptions() & Options::HiddenFromCompletion) == Options::None) {
            AddCompletionReply(chunk, cmd->Name());
          }
        }
      } else if (pos) {
        if ((pos->GetOptions() & Options::HiddenFromCompletion) == Options::None) {
          auto choices = pos->HelpChoices(helpParams);
          hasPositionalCompletion = !choices.empty() || optionType != OptionType::Positional;
          for (auto& choice : choices) {
            AddCompletionReply(chunk, choice);
          }
        }
      }

      if (hasPositionalCompletion) {
        auto flags = GetAllFlags();
        for (auto flag : flags) {
          if ((flag->GetOptions() & Options::HiddenFromCompletion) != Options::None) {
            continue;
          }

          auto& matcher = flag->GetMatcher();
          if (!AddCompletionReply(chunk, matcher.GetShortOrAny().str(shortprefix, longprefix))) {
            for (auto& flagName : matcher.GetFlagStrings()) {
              if (AddCompletionReply(chunk, flagName.str(shortprefix, longprefix))) {
                break;
              }
            }
          }
        }

        if (optionType == OptionType::LongFlag && allowJoinedLongValue) {
          const auto separator = longseparator.empty() ? chunk.npos : chunk.find(longseparator);
          if (separator != chunk.npos) {
            std::string arg(chunk, 0, separator);
            if (auto flag = this->Match(arg.substr(longprefix.size()))) {
              for (auto& choice : flag->HelpChoices(helpParams)) {
                AddCompletionReply(chunk, arg + longseparator + choice);
              }
            }
          }
        } else if (optionType == OptionType::ShortFlag && allowJoinedShortValue) {
          if (chunk.size() > shortprefix.size() + 1) {
            auto arg = chunk.at(shortprefix.size());
            // TODO: support -abcVALUE where a and b take no value
            if (auto flag = this->Match(arg)) {
              for (auto& choice : flag->HelpChoices(helpParams)) {
                AddCompletionReply(chunk, shortprefix + arg + choice);
              }
            }
          }
        }
      }
    }

#ifndef ARGS_NOEXCEPT
    throw Completion(completion->Get());
#else
    return true;
#endif
  }

  template <typename It> It Parse(It begin, It end) {
    bool terminated = false;
    std::vector<Command*> commands = GetCommands();

    // Check all arg chunks
    for (auto it = begin; it != end; ++it) {
      if (Complete(it, end)) {
        return end;
      }

      const auto& chunk = *it;

      if (!terminated && chunk == terminator) {
        terminated = true;
      } else if (!terminated && ParseOption(chunk) == OptionType::LongFlag) {
        if (!ParseLong(it, end)) {
          return it;
        }
      } else if (!terminated && ParseOption(chunk) == OptionType::ShortFlag) {
        if (!ParseShort(it, end)) {
          return it;
        }
      } else if (!terminated && !commands.empty()) {
        auto itCommand =
            std::find_if(commands.begin(), commands.end(), [&chunk](Command* c) { return c->Name() == chunk; });
        if (itCommand == commands.end()) {
          const std::string errorMessage("Unknown command: " + chunk);
#ifndef ARGS_NOEXCEPT
          throw ParseError(errorMessage);
#else
          error = Error::Parse;
          errorMsg = errorMessage;
          return it;
#endif
        }

        SelectCommand(*itCommand);

        if (const auto& coroutine = GetCoroutine()) {
          ++it;
          RaiiSubparser coro(*this, std::vector<std::string>(it, end));
          coroutine(coro.Parser());
#ifdef ARGS_NOEXCEPT
          error = GetError();
          if (error != Error::None) {
            return end;
          }

          if (!coro.Parser().IsParsed()) {
            error = Error::Usage;
            return end;
          }
#else
          if (!coro.Parser().IsParsed()) {
            throw UsageError("Subparser::Parse was not called");
          }
#endif

          break;
        }

        commands = GetCommands();
      } else {
        auto pos = GetNextPositional();
        if (pos) {
          pos->ParseValue(chunk);

          if (pos->KickOut()) {
            return ++it;
          }
        } else {
          const std::string errorMessage(
              "Passed in argument, but no positional arguments were ready to receive it: " + chunk
          );
#ifndef ARGS_NOEXCEPT
          throw ParseError(errorMessage);
#else
          error = Error::Parse;
          errorMsg = errorMessage;
          return it;
#endif
        }
      }

      if (!readCompletion && completion != nullptr && completion->Matched()) {
#ifdef ARGS_NOEXCEPT
        error = Error::Completion;
#endif
        readCompletion = true;
        ++it;
        const auto argsLeft = static_cast<size_t>(std::distance(it, end));
        if (completion->cword == 0 || argsLeft <= 1 || completion->cword >= argsLeft) {
#ifndef ARGS_NOEXCEPT
          throw Completion("");
#endif
        }

        std::vector<std::string> curArgs(++it, end);
        curArgs.resize(completion->cword);

        if (completion->syntax == "bash") {
          // bash tokenizes --flag=value as --flag=value
          for (size_t idx = 0; idx < curArgs.size();) {
            if (idx > 0 && curArgs[idx] == "=") {
              curArgs[idx - 1] += "=";
              // Avoid warnings from -Wsign-conversion
              const auto signedIdx = static_cast<std::ptrdiff_t>(idx);
              if (idx + 1 < curArgs.size()) {
                curArgs[idx - 1] += curArgs[idx + 1];
                curArgs.erase(curArgs.begin() + signedIdx, curArgs.begin() + signedIdx + 2);
              } else {
                curArgs.erase(curArgs.begin() + signedIdx);
              }
            } else {
              ++idx;
            }
          }
        }
#ifndef ARGS_NOEXCEPT
        try {
          Parse(curArgs.begin(), curArgs.end());
          throw Completion("");
        } catch (Completion&) {
          throw;
        } catch (args::Error&) {
          throw Completion("");
        }
#else
        return Parse(curArgs.begin(), curArgs.end());
#endif
      }
    }

    Validate(shortprefix, longprefix);
    return end;
  }

public:
  HelpParams helpParams;

  ArgumentParser(const std::string& description_, const std::string& epilog_ = std::string()) {
    Description(description_);
    Epilog(epilog_);
    LongPrefix("--");
    ShortPrefix("-");
    LongSeparator("=");
    Terminator("--");
    SetArgumentSeparations(true, true, true, true);
    matched = true;
  }

  void AddCompletion(CompletionFlag& completionFlag) {
    completion = &completionFlag;
    Add(completionFlag);
  }

  /** The program name for help generation
   */
  const std::string& Prog() const { return helpParams.programName; }
  /** The program name for help generation
   */
  void Prog(const std::string& prog_) { this->helpParams.programName = prog_; }

  /** The prefix for long flags
   */
  const std::string& LongPrefix() const { return longprefix; }
  /** The prefix for long flags
   */
  void LongPrefix(const std::string& longprefix_) {
    this->longprefix = longprefix_;
    this->helpParams.longPrefix = longprefix_;
  }

  /** The prefix for short flags
   */
  const std::string& ShortPrefix() const { return shortprefix; }
  /** The prefix for short flags
   */
  void ShortPrefix(const std::string& shortprefix_) {
    this->shortprefix = shortprefix_;
    this->helpParams.shortPrefix = shortprefix_;
  }

  /** The separator for long flags
   */
  const std::string& LongSeparator() const { return longseparator; }
  /** The separator for long flags
   */
  void LongSeparator(const std::string& longseparator_) {
    if (longseparator_.empty()) {
      const std::string errorMessage("longseparator can not be set to empty");
#ifdef ARGS_NOEXCEPT
      error = Error::Usage;
      errorMsg = errorMessage;
#else
      throw UsageError(errorMessage);
#endif
    } else {
      this->longseparator = longseparator_;
      this->helpParams.longSeparator = allowJoinedLongValue ? longseparator_ : " ";
    }
  }

  /** The terminator that forcibly separates flags from positionals
   */
  const std::string& Terminator() const { return terminator; }
  /** The terminator that forcibly separates flags from positionals
   */
  void Terminator(const std::string& terminator_) { this->terminator = terminator_; }

  /** Get the current argument separation parameters.
   *
   * See SetArgumentSeparations for details on what each one means.
   */
  void GetArgumentSeparations(
      bool& allowJoinedShortValue_, bool& allowJoinedLongValue_, bool& allowSeparateShortValue_,
      bool& allowSeparateLongValue_
  ) const {
    allowJoinedShortValue_ = this->allowJoinedShortValue;
    allowJoinedLongValue_ = this->allowJoinedLongValue;
    allowSeparateShortValue_ = this->allowSeparateShortValue;
    allowSeparateLongValue_ = this->allowSeparateLongValue;
  }

  /** Change allowed option separation.
   *
   * \param allowJoinedShortValue_ Allow a short flag that accepts an argument to be passed its argument immediately
   * next to it (ie. in the same argv field)
   * \param allowJoinedLongValue_ Allow a long flag that accepts an argument to be passed its argument separated by the
   * longseparator (ie. in the same argv field)
   * \param allowSeparateShortValue_ Allow a short flag that accepts an argument to be passed its argument separated by
   * whitespace (ie. in the next argv field)
   * \param allowSeparateLongValue_ Allow a long flag that accepts an argument to be passed its argument separated by
   * whitespace (ie. in the next argv field)
   */
  void SetArgumentSeparations(
      const bool allowJoinedShortValue_, const bool allowJoinedLongValue_, const bool allowSeparateShortValue_,
      const bool allowSeparateLongValue_
  ) {
    this->allowJoinedShortValue = allowJoinedShortValue_;
    this->allowJoinedLongValue = allowJoinedLongValue_;
    this->allowSeparateShortValue = allowSeparateShortValue_;
    this->allowSeparateLongValue = allowSeparateLongValue_;

    this->helpParams.longSeparator = allowJoinedLongValue ? longseparator : " ";
    this->helpParams.shortSeparator = allowJoinedShortValue ? "" : " ";
  }

  /** Pass the help menu into an ostream
   */
  void Help(std::ostream& help_) const {
    auto& command = SelectedCommand();
    const auto& commandDescription = command.Description().empty() ? command.Help() : command.Description();
    const auto description_text = Wrap(commandDescription, helpParams.width - helpParams.descriptionindent);
    const auto epilog_text = Wrap(command.Epilog(), helpParams.width - helpParams.descriptionindent);

    const bool hasoptions = command.HasFlag();
    const bool hasarguments = command.HasPositional();

    std::vector<std::string> prognameline;
    prognameline.push_back(helpParams.usageString);
    prognameline.push_back(Prog());
    auto commandProgLine = command.GetProgramLine(helpParams);
    prognameline.insert(prognameline.end(), commandProgLine.begin(), commandProgLine.end());

    const auto proglines = Wrap(
        prognameline.begin(), prognameline.end(),
        helpParams.width - (helpParams.progindent + helpParams.progtailindent), helpParams.width - helpParams.progindent
    );
    auto progit = std::begin(proglines);
    if (progit != std::end(proglines)) {
      help_ << std::string(helpParams.progindent, ' ') << *progit << '\n';
      ++progit;
    }
    for (; progit != std::end(proglines); ++progit) {
      help_ << std::string(helpParams.progtailindent, ' ') << *progit << '\n';
    }

    help_ << '\n';

    if (!description_text.empty()) {
      for (const auto& line : description_text) {
        help_ << std::string(helpParams.descriptionindent, ' ') << line << "\n";
      }
      help_ << "\n";
    }

    bool lastDescriptionIsNewline = false;

    if (!helpParams.optionsString.empty()) {
      help_ << std::string(helpParams.progindent, ' ') << helpParams.optionsString << "\n\n";
    }

    for (const auto& desc : command.GetDescription(helpParams, 0)) {
      lastDescriptionIsNewline = std::get<0>(desc).empty() && std::get<1>(desc).empty();
      const auto groupindent = std::get<2>(desc) * helpParams.eachgroupindent;
      const auto flags = Wrap(
          std::get<0>(desc), helpParams.width - (helpParams.flagindent + helpParams.helpindent + helpParams.gutter)
      );
      const auto info = Wrap(std::get<1>(desc), helpParams.width - (helpParams.helpindent + groupindent));

      std::string::size_type flagssize = 0;
      for (auto flagsit = std::begin(flags); flagsit != std::end(flags); ++flagsit) {
        if (flagsit != std::begin(flags)) {
          help_ << '\n';
        }
        help_ << std::string(groupindent + helpParams.flagindent, ' ') << *flagsit;
        flagssize = Glyphs(*flagsit);
      }

      auto infoit = std::begin(info);
      // groupindent is on both sides of this inequality, and therefore can be removed
      if ((helpParams.flagindent + flagssize + helpParams.gutter) > helpParams.helpindent || infoit == std::end(info) ||
          helpParams.addNewlineBeforeDescription) {
        help_ << '\n';
      } else {
        // groupindent is on both sides of the minus sign, and therefore doesn't actually need to be in here
        help_ << std::string(helpParams.helpindent - (helpParams.flagindent + flagssize), ' ') << *infoit << '\n';
        ++infoit;
      }
      for (; infoit != std::end(info); ++infoit) {
        help_ << std::string(groupindent + helpParams.helpindent, ' ') << *infoit << '\n';
      }
    }
    if (hasoptions && hasarguments && helpParams.showTerminator) {
      lastDescriptionIsNewline = false;
      for (const auto& item : Wrap(
               std::string("\"") + terminator +
                   "\" can be used to terminate flag options and force all following arguments to be treated as "
                   "positional options",
               helpParams.width - helpParams.flagindent
           )) {
        help_ << std::string(helpParams.flagindent, ' ') << item << '\n';
      }
    }

    if (!lastDescriptionIsNewline) {
      help_ << "\n";
    }

    for (const auto& line : epilog_text) {
      help_ << std::string(helpParams.descriptionindent, ' ') << line << "\n";
    }
  }

  /** Generate a help menu as a string.
   *
   * \return the help text as a single string
   */
  std::string Help() const {
    std::ostringstream help_;
    Help(help_);
    return help_.str();
  }

  virtual void Reset() noexcept override {
    Command::Reset();
    matched = true;
    readCompletion = false;
  }

  /** Parse all arguments.
   *
   * \param begin an iterator to the beginning of the argument list
   * \param end an iterator to the past-the-end element of the argument list
   * \return the iterator after the last parsed value.  Only useful for kick-out
   */
  template <typename It> It ParseArgs(It begin, It end) {
    // Reset all Matched statuses and errors
    Reset();
#ifdef ARGS_NOEXCEPT
    error = GetError();
    if (error != Error::None) {
      return end;
    }
#endif
    return Parse(begin, end);
  }

  /** Parse all arguments.
   *
   * \param args an iterable of the arguments
   * \return the iterator after the last parsed value.  Only useful for kick-out
   */
  template <typename T> auto ParseArgs(const T& args) -> decltype(std::begin(args)) {
    return ParseArgs(std::begin(args), std::end(args));
  }

  /** Convenience function to parse the CLI from argc and argv
   *
   * Just assigns the program name and vectorizes arguments for passing into ParseArgs()
   *
   * \return whether or not all arguments were parsed.  This works for detecting kick-out, but is generally useless as
   * it can't do anything with it.
   */
  bool ParseCLI(const int argc, const char* const* argv) {
    if (Prog().empty()) {
      Prog(argv[0]);
    }
    const std::vector<std::string> args(argv + 1, argv + argc);
    return ParseArgs(args) == std::end(args);
  }

  template <typename T> bool ParseCLI(const T& args) { return ParseArgs(args) == std::end(args); }
};

inline Command::RaiiSubparser::RaiiSubparser(ArgumentParser& parser_, std::vector<std::string> args_)
    : command(parser_.SelectedCommand()), parser(std::move(args_), parser_, command, parser_.helpParams),
      oldSubparser(command.subparser) {
  command.subparser = &parser;
}

inline Command::RaiiSubparser::RaiiSubparser(const Command& command_, const HelpParams& params_)
    : command(command_), parser(command, params_), oldSubparser(command.subparser) {
  command.subparser = &parser;
}

inline void Subparser::Parse() {
  isParsed = true;
  Reset();
  command.subparserDescription = GetDescription(helpParams, 0);
  command.subparserHasFlag = HasFlag();
  command.subparserHasPositional = HasPositional();
  command.subparserHasCommand = HasCommand();
  command.subparserProgramLine = GetProgramLine(helpParams);
  if (parser == nullptr) {
#ifndef ARGS_NOEXCEPT
    throw args::SubparserError();
#else
    error = Error::Subparser;
    return;
#endif
  }

  auto it = parser->Parse(args.begin(), args.end());
  command.Validate(parser->ShortPrefix(), parser->LongPrefix());
  kicked.assign(it, args.end());

#ifdef ARGS_NOEXCEPT
  command.subparserError = GetError();
#endif
}

inline std::ostream& operator<<(std::ostream& os, const ArgumentParser& parser) {
  parser.Help(os);
  return os;
}

/** Boolean argument matcher
 */
class Flag : public FlagBase {
public:
  Flag(Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, Options options_)
      : FlagBase(name_, help_, std::move(matcher_), options_) {
    group_.Add(*this);
  }

  Flag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_,
      const bool extraError_ = false
  )
      : Flag(group_, name_, help_, std::move(matcher_), extraError_ ? Options::Single : Options::None) {}

  virtual ~Flag() {}

  /** Get whether this was matched
   */
  bool Get() const { return Matched(); }

  virtual Nargs NumberOfArguments() const noexcept override { return 0; }

  virtual void ParseValue(const std::vector<std::string>&) override {}
};

/** Help flag class
 *
 * Works like a regular flag, but throws an instance of Help when it is matched
 */
class HelpFlag : public Flag {
public:
  HelpFlag(Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, Options options_ = {})
      : Flag(group_, name_, help_, std::move(matcher_), options_) {}

  virtual ~HelpFlag() {}

  virtual void ParseValue(const std::vector<std::string>&) {
#ifdef ARGS_NOEXCEPT
    error = Error::Help;
    errorMsg = Name();
#else
    throw Help(Name());
#endif
  }

  /** Get whether this was matched
   */
  bool Get() const noexcept { return Matched(); }
};

/** A flag class that simply counts the number of times it's matched
 */
class CounterFlag : public Flag {
private:
  const int startcount;
  int count;

public:
  CounterFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, const int startcount_ = 0,
      Options options_ = {}
  )
      : Flag(group_, name_, help_, std::move(matcher_), options_), startcount(startcount_), count(startcount_) {}

  virtual ~CounterFlag() {}

  virtual FlagBase* Match(const EitherFlag& arg) override {
    auto me = FlagBase::Match(arg);
    if (me) {
      ++count;
    }
    return me;
  }

  /** Get the count
   */
  int& Get() noexcept { return count; }

  int& operator*() noexcept { return count; }

  const int& operator*() const noexcept { return count; }

  virtual void Reset() noexcept override {
    FlagBase::Reset();
    count = startcount;
  }
};

/** A flag class that calls a function when it's matched
 */
class ActionFlag : public FlagBase {
private:
  std::function<void(const std::vector<std::string>&)> action;
  Nargs nargs;

public:
  ActionFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, Nargs nargs_,
      std::function<void(const std::vector<std::string>&)> action_, Options options_ = {}
  )
      : FlagBase(name_, help_, std::move(matcher_), options_), action(std::move(action_)), nargs(nargs_) {
    group_.Add(*this);
  }

  ActionFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_,
      std::function<void(const std::string&)> action_, Options options_ = {}
  )
      : FlagBase(name_, help_, std::move(matcher_), options_), nargs(1) {
    group_.Add(*this);
    action = [action_](const std::vector<std::string>& a) { return action_(a.at(0)); };
  }

  ActionFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_,
      std::function<void()> action_, Options options_ = {}
  )
      : FlagBase(name_, help_, std::move(matcher_), options_), nargs(0) {
    group_.Add(*this);
    action = [action_](const std::vector<std::string>&) { return action_(); };
  }

  virtual Nargs NumberOfArguments() const noexcept override { return nargs; }

  virtual void ParseValue(const std::vector<std::string>& value) override { action(value); }
};

/** A default Reader class for argument classes
 *
 * If destination type is assignable to std::string it uses an assignment to std::string.
 * Otherwise ValueReader simply uses a std::istringstream to read into the destination type, and
 * raises a ParseError if there are any characters left.
 */
struct ValueReader {
  template <typename T>
  typename std::enable_if<!std::is_assignable<T, std::string>::value, bool>::type operator()(
      const std::string& name, const std::string& value, T& destination
  ) {
    std::istringstream ss(value);
    bool failed = !(ss >> destination);

    if (!failed) {
      ss >> std::ws;
    }

    if (ss.rdbuf()->in_avail() > 0 || failed) {
#ifdef ARGS_NOEXCEPT
      (void) name;
      return false;
#else
      std::ostringstream problem;
      problem << "Argument '" << name << "' received invalid value type '" << value << "'";
      throw ParseError(problem.str());
#endif
    }
    return true;
  }

  template <typename T>
  typename std::enable_if<std::is_assignable<T, std::string>::value, bool>::type operator()(
      const std::string&, const std::string& value, T& destination
  ) {
    destination = value;
    return true;
  }
};

/** An argument-accepting flag class
 *
 * \tparam T the type to extract the argument as
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 */
template <typename T, typename Reader = ValueReader> class ValueFlag : public ValueFlagBase {
protected:
  T value;
  T defaultValue;

  virtual std::string GetDefaultString(const HelpParams&) const override { return detail::ToString(defaultValue); }

private:
  Reader reader;

public:
  ValueFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, const T& defaultValue_,
      Options options_
  )
      : ValueFlagBase(name_, help_, std::move(matcher_), options_), value(defaultValue_), defaultValue(defaultValue_) {
    group_.Add(*this);
  }

  ValueFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_,
      const T& defaultValue_ = T(), const bool extraError_ = false
  )
      : ValueFlag(
            group_, name_, help_, std::move(matcher_), defaultValue_, extraError_ ? Options::Single : Options::None
        ) {}

  ValueFlag(Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, Options options_)
      : ValueFlag(group_, name_, help_, std::move(matcher_), T(), options_) {}

  virtual ~ValueFlag() {}

  virtual void ParseValue(const std::vector<std::string>& values_) override {
    const std::string& value_ = values_.at(0);

#ifdef ARGS_NOEXCEPT
    if (!reader(name, value_, this->value)) {
      error = Error::Parse;
    }
#else
    reader(name, value_, this->value);
#endif
  }

  virtual void Reset() noexcept override {
    ValueFlagBase::Reset();
    value = defaultValue;
  }

  /** Get the value
   */
  T& Get() noexcept { return value; }

  /** Get the value
   */
  T& operator*() noexcept { return value; }

  /** Get the value
   */
  const T& operator*() const noexcept { return value; }

  /** Get the value
   */
  T* operator->() noexcept { return &value; }

  /** Get the value
   */
  const T* operator->() const noexcept { return &value; }

  /** Get the default value
   */
  const T& GetDefault() noexcept { return defaultValue; }
};

/** An optional argument-accepting flag class
 *
 * \tparam T the type to extract the argument as
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 */
template <typename T, typename Reader = ValueReader> class ImplicitValueFlag : public ValueFlag<T, Reader> {
protected:
  T implicitValue;

public:
  ImplicitValueFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, const T& implicitValue_,
      const T& defaultValue_ = T(), Options options_ = {}
  )
      : ValueFlag<T, Reader>(group_, name_, help_, std::move(matcher_), defaultValue_, options_),
        implicitValue(implicitValue_) {}

  ImplicitValueFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_,
      const T& defaultValue_ = T(), Options options_ = {}
  )
      : ValueFlag<T, Reader>(group_, name_, help_, std::move(matcher_), defaultValue_, options_),
        implicitValue(defaultValue_) {}

  ImplicitValueFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, Options options_
  )
      : ValueFlag<T, Reader>(group_, name_, help_, std::move(matcher_), {}, options_), implicitValue() {}

  virtual ~ImplicitValueFlag() {}

  virtual Nargs NumberOfArguments() const noexcept override { return {0, 1}; }

  virtual void ParseValue(const std::vector<std::string>& value_) override {
    if (value_.empty()) {
      this->value = implicitValue;
    } else {
      ValueFlag<T, Reader>::ParseValue(value_);
    }
  }
};

/** A variadic arguments accepting flag class
 *
 * \tparam T the type to extract the argument as
 * \tparam List the list type that houses the values
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 */
template <typename T, template <typename...> class List = detail::vector, typename Reader = ValueReader>
class NargsValueFlag : public FlagBase {
protected:
  List<T> values;
  const List<T> defaultValues;
  Nargs nargs;
  Reader reader;

public:
  typedef List<T> Container;
  typedef T value_type;
  typedef typename Container::allocator_type allocator_type;
  typedef typename Container::pointer pointer;
  typedef typename Container::const_pointer const_pointer;
  typedef T& reference;
  typedef const T& const_reference;
  typedef typename Container::size_type size_type;
  typedef typename Container::difference_type difference_type;
  typedef typename Container::iterator iterator;
  typedef typename Container::const_iterator const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  NargsValueFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, Nargs nargs_,
      const List<T>& defaultValues_ = {}, Options options_ = {}
  )
      : FlagBase(name_, help_, std::move(matcher_), options_), values(defaultValues_), defaultValues(defaultValues_),
        nargs(nargs_) {
    group_.Add(*this);
  }

  virtual ~NargsValueFlag() {}

  virtual Nargs NumberOfArguments() const noexcept override { return nargs; }

  virtual void ParseValue(const std::vector<std::string>& values_) override {
    values.clear();

    for (const std::string& value : values_) {
      T v;
#ifdef ARGS_NOEXCEPT
      if (!reader(name, value, v)) {
        error = Error::Parse;
      }
#else
      reader(name, value, v);
#endif
      values.insert(std::end(values), v);
    }
  }

  List<T>& Get() noexcept { return values; }

  /** Get the value
   */
  List<T>& operator*() noexcept { return values; }

  /** Get the values
   */
  const List<T>& operator*() const noexcept { return values; }

  /** Get the values
   */
  List<T>* operator->() noexcept { return &values; }

  /** Get the values
   */
  const List<T>* operator->() const noexcept { return &values; }

  iterator begin() noexcept { return values.begin(); }

  const_iterator begin() const noexcept { return values.begin(); }

  const_iterator cbegin() const noexcept { return values.cbegin(); }

  iterator end() noexcept { return values.end(); }

  const_iterator end() const noexcept { return values.end(); }

  const_iterator cend() const noexcept { return values.cend(); }

  virtual void Reset() noexcept override {
    FlagBase::Reset();
    values = defaultValues;
  }

  virtual FlagBase* Match(const EitherFlag& arg) override {
    const bool wasMatched = Matched();
    auto me = FlagBase::Match(arg);
    if (me && !wasMatched) {
      values.clear();
    }
    return me;
  }
};

/** An argument-accepting flag class that pushes the found values into a list
 *
 * \tparam T the type to extract the argument as
 * \tparam List the list type that houses the values
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 */
template <typename T, template <typename...> class List = detail::vector, typename Reader = ValueReader>
class ValueFlagList : public ValueFlagBase {
private:
  using Container = List<T>;
  Container values;
  const Container defaultValues;
  Reader reader;

public:
  typedef T value_type;
  typedef typename Container::allocator_type allocator_type;
  typedef typename Container::pointer pointer;
  typedef typename Container::const_pointer const_pointer;
  typedef T& reference;
  typedef const T& const_reference;
  typedef typename Container::size_type size_type;
  typedef typename Container::difference_type difference_type;
  typedef typename Container::iterator iterator;
  typedef typename Container::const_iterator const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  ValueFlagList(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_,
      const Container& defaultValues_ = Container(), Options options_ = {}
  )
      : ValueFlagBase(name_, help_, std::move(matcher_), options_), values(defaultValues_),
        defaultValues(defaultValues_) {
    group_.Add(*this);
  }

  virtual ~ValueFlagList() {}

  virtual void ParseValue(const std::vector<std::string>& values_) override {
    const std::string& value_ = values_.at(0);

    T v;
#ifdef ARGS_NOEXCEPT
    if (!reader(name, value_, v)) {
      error = Error::Parse;
    }
#else
    reader(name, value_, v);
#endif
    values.insert(std::end(values), v);
  }

  /** Get the values
   */
  Container& Get() noexcept { return values; }

  /** Get the value
   */
  Container& operator*() noexcept { return values; }

  /** Get the values
   */
  const Container& operator*() const noexcept { return values; }

  /** Get the values
   */
  Container* operator->() noexcept { return &values; }

  /** Get the values
   */
  const Container* operator->() const noexcept { return &values; }

  virtual std::string Name() const override { return name + std::string("..."); }

  virtual void Reset() noexcept override {
    ValueFlagBase::Reset();
    values = defaultValues;
  }

  virtual FlagBase* Match(const EitherFlag& arg) override {
    const bool wasMatched = Matched();
    auto me = FlagBase::Match(arg);
    if (me && !wasMatched) {
      values.clear();
    }
    return me;
  }

  iterator begin() noexcept { return values.begin(); }

  const_iterator begin() const noexcept { return values.begin(); }

  const_iterator cbegin() const noexcept { return values.cbegin(); }

  iterator end() noexcept { return values.end(); }

  const_iterator end() const noexcept { return values.end(); }

  const_iterator cend() const noexcept { return values.cend(); }
};

/** A mapping value flag class
 *
 * \tparam K the type to extract the argument as
 * \tparam T the type to store the result as
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 * \tparam Map The Map type.  Should operate like std::map or std::unordered_map
 */
template <
    typename K, typename T, typename Reader = ValueReader, template <typename...> class Map = detail::unordered_map>
class MapFlag : public ValueFlagBase {
private:
  const Map<K, T> map;
  T value;
  const T defaultValue;
  Reader reader;

protected:
  virtual std::vector<std::string> GetChoicesStrings(const HelpParams&) const override {
    return detail::MapKeysToStrings(map);
  }

public:
  MapFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, const Map<K, T>& map_,
      const T& defaultValue_, Options options_
  )
      : ValueFlagBase(name_, help_, std::move(matcher_), options_), map(map_), value(defaultValue_),
        defaultValue(defaultValue_) {
    group_.Add(*this);
  }

  MapFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, const Map<K, T>& map_,
      const T& defaultValue_ = T(), const bool extraError_ = false
  )
      : MapFlag(
            group_, name_, help_, std::move(matcher_), map_, defaultValue_,
            extraError_ ? Options::Single : Options::None
        ) {}

  MapFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, const Map<K, T>& map_,
      Options options_
  )
      : MapFlag(group_, name_, help_, std::move(matcher_), map_, T(), options_) {}

  virtual ~MapFlag() {}

  virtual void ParseValue(const std::vector<std::string>& values_) override {
    const std::string& value_ = values_.at(0);

    K key;
#ifdef ARGS_NOEXCEPT
    if (!reader(name, value_, key)) {
      error = Error::Parse;
    }
#else
    reader(name, value_, key);
#endif
    auto it = map.find(key);
    if (it == std::end(map)) {
      std::ostringstream problem;
      problem << "Could not find key '" << key << "' in map for arg '" << name << "'";
#ifdef ARGS_NOEXCEPT
      error = Error::Map;
      errorMsg = problem.str();
#else
      throw MapError(problem.str());
#endif
    } else {
      this->value = it->second;
    }
  }

  /** Get the value
   */
  T& Get() noexcept { return value; }

  /** Get the value
   */
  T& operator*() noexcept { return value; }

  /** Get the value
   */
  const T& operator*() const noexcept { return value; }

  /** Get the value
   */
  T* operator->() noexcept { return &value; }

  /** Get the value
   */
  const T* operator->() const noexcept { return &value; }

  virtual void Reset() noexcept override {
    ValueFlagBase::Reset();
    value = defaultValue;
  }
};

/** A mapping value flag list class
 *
 * \tparam K the type to extract the argument as
 * \tparam T the type to store the result as
 * \tparam List the list type that houses the values
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 * \tparam Map The Map type.  Should operate like std::map or std::unordered_map
 */
template <
    typename K, typename T, template <typename...> class List = detail::vector, typename Reader = ValueReader,
    template <typename...> class Map = detail::unordered_map>
class MapFlagList : public ValueFlagBase {
private:
  using Container = List<T>;
  const Map<K, T> map;
  Container values;
  const Container defaultValues;
  Reader reader;

protected:
  virtual std::vector<std::string> GetChoicesStrings(const HelpParams&) const override {
    return detail::MapKeysToStrings(map);
  }

public:
  typedef T value_type;
  typedef typename Container::allocator_type allocator_type;
  typedef typename Container::pointer pointer;
  typedef typename Container::const_pointer const_pointer;
  typedef T& reference;
  typedef const T& const_reference;
  typedef typename Container::size_type size_type;
  typedef typename Container::difference_type difference_type;
  typedef typename Container::iterator iterator;
  typedef typename Container::const_iterator const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  MapFlagList(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, const Map<K, T>& map_,
      const Container& defaultValues_ = Container()
  )
      : ValueFlagBase(name_, help_, std::move(matcher_)), map(map_), values(defaultValues_),
        defaultValues(defaultValues_) {
    group_.Add(*this);
  }

  virtual ~MapFlagList() {}

  virtual void ParseValue(const std::vector<std::string>& values_) override {
    const std::string& value = values_.at(0);

    K key;
#ifdef ARGS_NOEXCEPT
    if (!reader(name, value, key)) {
      error = Error::Parse;
    }
#else
    reader(name, value, key);
#endif
    auto it = map.find(key);
    if (it == std::end(map)) {
      std::ostringstream problem;
      problem << "Could not find key '" << key << "' in map for arg '" << name << "'";
#ifdef ARGS_NOEXCEPT
      error = Error::Map;
      errorMsg = problem.str();
#else
      throw MapError(problem.str());
#endif
    } else {
      this->values.emplace_back(it->second);
    }
  }

  /** Get the value
   */
  Container& Get() noexcept { return values; }

  /** Get the value
   */
  Container& operator*() noexcept { return values; }

  /** Get the values
   */
  const Container& operator*() const noexcept { return values; }

  /** Get the values
   */
  Container* operator->() noexcept { return &values; }

  /** Get the values
   */
  const Container* operator->() const noexcept { return &values; }

  virtual std::string Name() const override { return name + std::string("..."); }

  virtual void Reset() noexcept override {
    ValueFlagBase::Reset();
    values = defaultValues;
  }

  virtual FlagBase* Match(const EitherFlag& arg) override {
    const bool wasMatched = Matched();
    auto me = FlagBase::Match(arg);
    if (me && !wasMatched) {
      values.clear();
    }
    return me;
  }

  iterator begin() noexcept { return values.begin(); }

  const_iterator begin() const noexcept { return values.begin(); }

  const_iterator cbegin() const noexcept { return values.cbegin(); }

  iterator end() noexcept { return values.end(); }

  const_iterator end() const noexcept { return values.end(); }

  const_iterator cend() const noexcept { return values.cend(); }
};

/** A positional argument class
 *
 * \tparam T the type to extract the argument as
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 */
template <typename T, typename Reader = ValueReader> class Positional : public PositionalBase {
private:
  T value;
  const T defaultValue;
  Reader reader;

public:
  Positional(
      Group& group_, const std::string& name_, const std::string& help_, const T& defaultValue_ = T(),
      Options options_ = {}
  )
      : PositionalBase(name_, help_, options_), value(defaultValue_), defaultValue(defaultValue_) {
    group_.Add(*this);
  }

  Positional(Group& group_, const std::string& name_, const std::string& help_, Options options_)
      : Positional(group_, name_, help_, T(), options_) {}

  virtual ~Positional() {}

  virtual void ParseValue(const std::string& value_) override {
#ifdef ARGS_NOEXCEPT
    if (!reader(name, value_, this->value)) {
      error = Error::Parse;
    }
#else
    reader(name, value_, this->value);
#endif
    ready = false;
    matched = true;
  }

  /** Get the value
   */
  T& Get() noexcept { return value; }

  /** Get the value
   */
  T& operator*() noexcept { return value; }

  /** Get the value
   */
  const T& operator*() const noexcept { return value; }

  /** Get the value
   */
  T* operator->() noexcept { return &value; }

  /** Get the value
   */
  const T* operator->() const noexcept { return &value; }

  virtual void Reset() noexcept override {
    PositionalBase::Reset();
    value = defaultValue;
  }
};

/** A positional argument class that pushes the found values into a list
 *
 * \tparam T the type to extract the argument as
 * \tparam List the list type that houses the values
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 */
template <typename T, template <typename...> class List = detail::vector, typename Reader = ValueReader>
class PositionalList : public PositionalBase {
private:
  using Container = List<T>;
  Container values;
  const Container defaultValues;
  Reader reader;

public:
  typedef T value_type;
  typedef typename Container::allocator_type allocator_type;
  typedef typename Container::pointer pointer;
  typedef typename Container::const_pointer const_pointer;
  typedef T& reference;
  typedef const T& const_reference;
  typedef typename Container::size_type size_type;
  typedef typename Container::difference_type difference_type;
  typedef typename Container::iterator iterator;
  typedef typename Container::const_iterator const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  PositionalList(
      Group& group_, const std::string& name_, const std::string& help_, const Container& defaultValues_ = Container(),
      Options options_ = {}
  )
      : PositionalBase(name_, help_, options_), values(defaultValues_), defaultValues(defaultValues_) {
    group_.Add(*this);
  }

  PositionalList(Group& group_, const std::string& name_, const std::string& help_, Options options_)
      : PositionalList(group_, name_, help_, {}, options_) {}

  virtual ~PositionalList() {}

  virtual void ParseValue(const std::string& value_) override {
    T v;
#ifdef ARGS_NOEXCEPT
    if (!reader(name, value_, v)) {
      error = Error::Parse;
    }
#else
    reader(name, value_, v);
#endif
    values.insert(std::end(values), v);
    matched = true;
  }

  virtual std::string Name() const override { return name + std::string("..."); }

  /** Get the values
   */
  Container& Get() noexcept { return values; }

  /** Get the value
   */
  Container& operator*() noexcept { return values; }

  /** Get the values
   */
  const Container& operator*() const noexcept { return values; }

  /** Get the values
   */
  Container* operator->() noexcept { return &values; }

  /** Get the values
   */
  const Container* operator->() const noexcept { return &values; }

  virtual void Reset() noexcept override {
    PositionalBase::Reset();
    values = defaultValues;
  }

  virtual PositionalBase* GetNextPositional() override {
    const bool wasMatched = Matched();
    auto me = PositionalBase::GetNextPositional();
    if (me && !wasMatched) {
      values.clear();
    }
    return me;
  }

  iterator begin() noexcept { return values.begin(); }

  const_iterator begin() const noexcept { return values.begin(); }

  const_iterator cbegin() const noexcept { return values.cbegin(); }

  iterator end() noexcept { return values.end(); }

  const_iterator end() const noexcept { return values.end(); }

  const_iterator cend() const noexcept { return values.cend(); }
};

/** A positional argument mapping class
 *
 * \tparam K the type to extract the argument as
 * \tparam T the type to store the result as
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 * \tparam Map The Map type.  Should operate like std::map or std::unordered_map
 */
template <
    typename K, typename T, typename Reader = ValueReader, template <typename...> class Map = detail::unordered_map>
class MapPositional : public PositionalBase {
private:
  const Map<K, T> map;
  T value;
  const T defaultValue;
  Reader reader;

protected:
  virtual std::vector<std::string> GetChoicesStrings(const HelpParams&) const override {
    return detail::MapKeysToStrings(map);
  }

public:
  MapPositional(
      Group& group_, const std::string& name_, const std::string& help_, const Map<K, T>& map_,
      const T& defaultValue_ = T(), Options options_ = {}
  )
      : PositionalBase(name_, help_, options_), map(map_), value(defaultValue_), defaultValue(defaultValue_) {
    group_.Add(*this);
  }

  virtual ~MapPositional() {}

  virtual void ParseValue(const std::string& value_) override {
    K key;
#ifdef ARGS_NOEXCEPT
    if (!reader(name, value_, key)) {
      error = Error::Parse;
    }
#else
    reader(name, value_, key);
#endif
    auto it = map.find(key);
    if (it == std::end(map)) {
      std::ostringstream problem;
      problem << "Could not find key '" << key << "' in map for arg '" << name << "'";
#ifdef ARGS_NOEXCEPT
      error = Error::Map;
      errorMsg = problem.str();
#else
      throw MapError(problem.str());
#endif
    } else {
      this->value = it->second;
      ready = false;
      matched = true;
    }
  }

  /** Get the value
   */
  T& Get() noexcept { return value; }

  /** Get the value
   */
  T& operator*() noexcept { return value; }

  /** Get the value
   */
  const T& operator*() const noexcept { return value; }

  /** Get the value
   */
  T* operator->() noexcept { return &value; }

  /** Get the value
   */
  const T* operator->() const noexcept { return &value; }

  virtual void Reset() noexcept override {
    PositionalBase::Reset();
    value = defaultValue;
  }
};

/** A positional argument mapping list class
 *
 * \tparam K the type to extract the argument as
 * \tparam T the type to store the result as
 * \tparam List the list type that houses the values
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 * \tparam Map The Map type.  Should operate like std::map or std::unordered_map
 */
template <
    typename K, typename T, template <typename...> class List = detail::vector, typename Reader = ValueReader,
    template <typename...> class Map = detail::unordered_map>
class MapPositionalList : public PositionalBase {
private:
  using Container = List<T>;

  const Map<K, T> map;
  Container values;
  const Container defaultValues;
  Reader reader;

protected:
  virtual std::vector<std::string> GetChoicesStrings(const HelpParams&) const override {
    return detail::MapKeysToStrings(map);
  }

public:
  typedef T value_type;
  typedef typename Container::allocator_type allocator_type;
  typedef typename Container::pointer pointer;
  typedef typename Container::const_pointer const_pointer;
  typedef T& reference;
  typedef const T& const_reference;
  typedef typename Container::size_type size_type;
  typedef typename Container::difference_type difference_type;
  typedef typename Container::iterator iterator;
  typedef typename Container::const_iterator const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  MapPositionalList(
      Group& group_, const std::string& name_, const std::string& help_, const Map<K, T>& map_,
      const Container& defaultValues_ = Container(), Options options_ = {}
  )
      : PositionalBase(name_, help_, options_), map(map_), values(defaultValues_), defaultValues(defaultValues_) {
    group_.Add(*this);
  }

  virtual ~MapPositionalList() {}

  virtual void ParseValue(const std::string& value_) override {
    K key;
#ifdef ARGS_NOEXCEPT
    if (!reader(name, value_, key)) {
      error = Error::Parse;
    }
#else
    reader(name, value_, key);
#endif
    auto it = map.find(key);
    if (it == std::end(map)) {
      std::ostringstream problem;
      problem << "Could not find key '" << key << "' in map for arg '" << name << "'";
#ifdef ARGS_NOEXCEPT
      error = Error::Map;
      errorMsg = problem.str();
#else
      throw MapError(problem.str());
#endif
    } else {
      this->values.emplace_back(it->second);
      matched = true;
    }
  }

  /** Get the value
   */
  Container& Get() noexcept { return values; }

  /** Get the value
   */
  Container& operator*() noexcept { return values; }

  /** Get the values
   */
  const Container& operator*() const noexcept { return values; }

  /** Get the values
   */
  Container* operator->() noexcept { return &values; }

  /** Get the values
   */
  const Container* operator->() const noexcept { return &values; }

  virtual std::string Name() const override { return name + std::string("..."); }

  virtual void Reset() noexcept override {
    PositionalBase::Reset();
    values = defaultValues;
  }

  virtual PositionalBase* GetNextPositional() override {
    const bool wasMatched = Matched();
    auto me = PositionalBase::GetNextPositional();
    if (me && !wasMatched) {
      values.clear();
    }
    return me;
  }

  iterator begin() noexcept { return values.begin(); }

  const_iterator begin() const noexcept { return values.begin(); }

  const_iterator cbegin() const noexcept { return values.cbegin(); }

  iterator end() noexcept { return values.end(); }

  const_iterator end() const noexcept { return values.end(); }

  const_iterator cend() const noexcept { return values.cend(); }
};
}

#endif

```

`src/w1base/ext/jsonstruct.hpp`:

```hpp
/*
* Copyright © 2020 Jørgen Lind

* Permission to use, copy, modify, distribute, and sell this software and its
* documentation for any purpose is hereby granted without fee, provided that
* the above copyright notice appear in all copies and that both that copyright
* notice and this permission notice appear in supporting documentation, and
* that the name of the copyright holders not be used in advertising or
* publicity pertaining to distribution of the software without specific,
* written prior permission.  The copyright holders make no representations
* about the suitability of this software for any purpose.  It is provided "as
* is" without express or implied warranty.

* THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
* INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
* EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
* CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
* DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
* TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
* OF THIS SOFTWARE.
*/

/*
README:

json_struct is a single header only library that parses JSON to C++ structs/classes
and serializing structs/classes to JSON.

It is intended to be used by copying the json_struct.h file from the include
folder into the include path for the project. It is only the json_struct.h file
that is needed to serialize and deserialize json from structures.

It is dependent on some C++11 features and is tested on newer versions of gcc
and clang. It is also tested on VS 2015 and newer.

### Structs

json_struct can parse JSON and automatically populate structures with content
by adding some metadata to the C++ structs.

```json
{
    "One" : 1,
    "Two" : "two",
    "Three" : 3.333
}
```

can be parsed into a structure defined like this:

```c++
struct JsonObject
{
    int One;
    std::string Two;
    double Three;

    JS_OBJ(One, Two, Three);
};
```

or

```c++
struct JsonObject
{
    int One;
    std::string Two;
    double Three;
};
JS_OBJ_EXT(JsonObject, One, Two, Three);
```

Populating the struct would look like this:

```c++
JS::ParseContext context(json_data);
JsonObject obj;
context.parseTo(obj);
```

Serializing the struct to json could be done like this:

```c++
std::string pretty_json = JS::serializeStruct(obj);
// or
std::string compact_json = JS::serializeStruct(obj, JS::SerializerOptions(JS::SerializerOptions::Compact));

*/

/*! \file */

/*! \mainpage json_struct
 *
 * json_struct is a set of classes meant for simple and efficient parse,
 * tokenize and validate json.
 *
 * json_struct support parsing json into a stream of tokens using the \ref
 * tokenizer "JS::Tokenizer" api, or parsing json into c++ structures using the
 * \ref js_struct "JS_OBJECT" api.
 */

/*! \page tokenizer Parsing json using JS::Tokenizer
 *
 * Tokenizing json JS::Tokenizer can be used to extract tokens
 * from a json stream.  Tokens does not describe a full object, but only
 * key-value pairs. So a object would be: "some key" and object start. Then the
 * next token would be the first key value pair of that object. Then at some
 * point the object is finished, and an object end value with no key would be
 * the token.
 *
 * Arrays would be expressed in a similar fashion, but the tokens would have no
 * key, and each element in the array would be tokens with only a value
 * specified.
 *
 * The root object would be a token with no key data, but only object or array
 * start
 *
 * A crude example of this is viewed in \ref simple_tokenize.cpp here:
 * \include simple_tokenize.cpp
 *
 * Tokenizing json in this way allows you parse arbitrary large json data.
 * Also the tokenizer has mechanisms for asking for more data, making it easy
 * to stream json data. Using this interface to parse json is a bit verbose and
 * requires the application code to keep some extra state. json_struct also has
 * functionality for parsing json data directly into c++ structures. This is
 * done by adding some metadata to the structure, or by adding a template
 * specialisation of a class.  \ref js_struct "describes this" in more detail.
 */

/*! \example simple_tokenize.cpp
 *
 * This example show very basic usage of how JS::Tokenizer can be used
 */

/*! \example simple_struct.cpp
 *
 * This example shows basic usage of parsing Json directly into structs
 */

/*! \page js_struct Parsing json into C++ structs
 *
 * json_struct makes it very easy to put your json data into c++ structures or
 * take data from c++ structures and generate json.
 *
 * This is best shown with an example: \include simple_struct.cpp
 *
 * The two interesting sections here are the lines are the:
 * \code{.cpp}
 *    JS_OBJECT(JS_MEMBER(key),
 *              JS_MEMBER(number),
 *              JS_MEMBER(boolean));
 * \endcode
 *
 * and
 *
 * \code{.cpp}
 *    JS::ParseContext parseContext(json);
 *    JsonData dataStruct;
 *    parseContext.parseTo(dataStruct);
 * \endcode
 *
 * The JS_OBJECT call inside the JsonData struct will create a nested struct
 * declaration inside the JsonData struct. This nested struct will expose some
 * meta data about the struct, exposing the names of the members at runtime.
 * json_struct can then use this runtime information to populate the struct.
 *
 * Populating the struct is done by first creating a JS::ParseContext. The
 * JS::ParseContext contains a JS::Tokenizer. This tokenizer is what the actual
 * state holder for the parsing. If allowing using '\n' instead of ',' to
 * seperate object and array elements, then this should be set on the
 * JS::Tokenizer.
 *
 * Since types will dictate the schema of the input json, the JS::ParseContext
 * will expose a list containing what members where not populated by the input
 * json, and what member in the input json that did not have any member to
 * populate.
 */

#ifndef JSON_STRUCT_H
#define JSON_STRUCT_H

#include <algorithm>
#include <assert.h>
#include <atomic>
#include <cmath>
#include <cstring>
#include <functional>
#include <limits>
#include <memory>
#include <stddef.h>
#include <stdlib.h>
#include <string>
#include <vector>

#ifdef _MSC_VER
#include <intrin.h>
#endif

#if __cplusplus > 199711L || (defined(_MSC_VER) && _MSC_VER > 1800)
#define JS_STD_UNORDERED_MAP 1
#endif
#ifdef JS_STD_UNORDERED_MAP
#include <unordered_map>
#endif

#ifndef JS_STD_OPTIONAL
#if defined(__APPLE__)
#if __clang_major__ > 9 && __cplusplus >= 201703L
#define JS_STD_OPTIONAL 1
#endif
#elif defined(_MSC_VER) && _MSC_VER >= 1910 && _HAS_CXX17
#define JS_STD_OPTIONAL 1
#elif __cplusplus >= 201703L
#define JS_STD_OPTIONAL 1
#endif
#endif

#ifdef JS_STD_OPTIONAL
#include <optional>
#endif

#ifdef JS_STD_TIMEPOINT
#include <chrono>
#include <type_traits>
#endif

#ifndef JS_IF_CONSTEXPR
#if __cpp_if_constexpr
#define JS_IF_CONSTEXPR(exp) if constexpr (exp)
#elif defined(_MSC_VER)
#define JS_IF_CONSTEXPR(exp) __pragma(warning(push)) __pragma(warning(disable : 4127)) if (exp) __pragma(warning(pop))
#else
#define JS_IF_CONSTEXPR(exp) if (exp)
#endif
#endif

#if JS_NO_NODISCARD
#define JS_NODISCARD
#else
#if __cplusplus >= 201703L
#define JS_NODISCARD [[nodiscard]]
#else
#define JS_NODISCARD
#endif
#endif

#if defined(min) || defined(max)
#error min or max macro is defined. Make sure these are not defined before including json_struct.h.\
 Use "#define NOMINMAX 1" before including Windows.h
#endif

#define JS_UNUSED(x) (void) (x)

#ifndef JS
#define JS JS
#endif

namespace JS {
/*!
 *  \brief Pointer to data
 *
 *  DataRef is used to refere to some data inside a json string. It holds the
 *  start posisition of the data, and its size.
 */
struct DataRef {
  /*!
   * Constructs a null Dataref pointing to "" with size 0.
   */
  constexpr explicit DataRef() : data(""), size(0) {}

  /*!
   * Constructs a DataRef pointing to data and size.
   * \param data points to start of data.
   * \param size size of data.
   */
  constexpr explicit DataRef(const char* data, size_t size) : data(data), size(size) {}

  /*!  Cobstructs a DataRef pointing to an array. This will \b NOT look for
   * the null terminator, but just initialize the DataRef to the size of the
   * array - 1. This function is intended to be used with string literals.
   * \param data  start of the data.
   */
  template <size_t N> constexpr explicit DataRef(const char (&data)[N]) : data(data), size(N - 1) {}

  explicit DataRef(const std::string& str) : data(&str[0]), size(str.size()) {}

  explicit DataRef(const char* data) : data(data), size(strlen(data)) {}

  const char* data;
  size_t size;
};

enum class Type : unsigned char {
  Error,
  String,
  Ascii,
  Number,
  ObjectStart,
  ObjectEnd,
  ArrayStart,
  ArrayEnd,
  Bool,
  Null,
  Verbatim
};

struct Token {
  Token();

  DataRef name;
  DataRef value;
  Type name_type;
  Type value_type;
};

namespace Internal {
struct IntermediateToken {
  IntermediateToken() : active(false), name_type_set(false), data_type_set(false) {}

  void clear() {
    if (!active) {
      return;
    }
    active = false;
    name_type_set = false;
    data_type_set = false;
    name_type = Type::Error;
    data_type = Type::Error;
    name.clear();
    data.clear();
  }

  bool active : 1;
  bool name_type_set : 1;
  bool data_type_set : 1;
  Type name_type = Type::Error;
  Type data_type = Type::Error;
  std::string name;
  std::string data;
};
enum Lookup {
  StrEndOrBackSlash = 1,
  AsciiLetters = 2,
  WhiteSpaceOrNull = 4,
  PlusOrMinus = 8,
  Digits = 16,
  HatUnderscoreAprostoph = 32,
  NumberEnd = 64
};

static inline const unsigned char* lookup() {
  static const unsigned char tmp[] = {
      /*0*/ 4,        0,       0,       0,       0,       0,       0,       0,
      /*8*/ 0,        4,       4,       0,       0,       4,       0,       0,
      /*16*/ 0,       0,       0,       0,       0,       0,       0,       0,
      /*24*/ 0,       0,       0,       0,       0,       0,       0,       0,
      /*32*/ 4,       0,       1,       0,       0,       0,       0,       0,
      /*40*/ 0,       0,       0,       8 | 64,  0,       8 | 64,  64,      0,
      /*48*/ 16 | 64, 16 | 64, 16 | 64, 16 | 64, 16 | 64, 16 | 64, 16 | 64, 16 | 64,
      /*56*/ 16 | 64, 16 | 64, 0,       0,       0,       0,       0,       0,
      /*64*/ 0,       2,       2,       2,       2,       2 | 64,  2,       2,
      /*72*/ 2,       2,       2,       2,       2,       2,       2,       2,
      /*80*/ 2,       2,       2,       2,       2,       2,       2,       2,
      /*88*/ 2,       2,       2,       0,       1,       0,       32,      32,
      /*96*/ 32,      2,       2,       2,       2,       2 | 64,  2,       2,
      /*104*/ 2,      2,       2,       2,       2,       2,       2,       2,
      /*112*/ 2,      2,       2,       2,       2,       2,       2,       2,
      /*120*/ 2,      2,       2,       0,       0,       0,       0,       0,
      /*128*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*136*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*144*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*152*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*160*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*168*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*176*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*184*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*192*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*200*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*208*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*216*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*224*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*232*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*240*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*248*/ 0,      0,       0,       0,       0,       0,       0,       0
  };
  return tmp;
}
} // namespace Internal

enum class Error : unsigned char {
  NoError,
  NeedMoreData,
  InvalidToken,
  ExpectedPropertyName,
  ExpectedDelimiter,
  ExpectedDataToken,
  ExpectedObjectStart,
  ExpectedObjectEnd,
  ExpectedArrayStart,
  ExpectedArrayEnd,
  UnexpectedArrayEnd,
  UnexpectedObjectEnd,
  IllegalPropertyName,
  IllegalPropertyType,
  IllegalDataValue,
  EncounteredIllegalChar,
  NodeNotFound,
  MissingPropertyMember,
  MissingFunction,
  FailedToParseBoolean,
  FailedToParseDouble,
  FailedToParseFloat,
  FailedToParseInt,
  UnassignedRequiredMember,
  NonContigiousMemory,
  ScopeHasEnded,
  KeyNotFound,
  DuplicateInSet,
  UnknownError,
  UserDefinedErrors
};

namespace Internal {
class ErrorContext {
public:
  size_t line = 0;
  size_t character = 0;
  Error error = Error::NoError;
  std::string custom_message;
  std::vector<std::string> lines;

  void clear() {
    line = 0;
    character = 0;
    error = Error::NoError;
    lines.clear();
  }
};

} // namespace Internal

namespace Internal {
struct ScopeCounter {
  JS::Type type;
  uint16_t depth;
  inline void handleType(JS::Type in_type) {
    if (type == JS::Type::ArrayStart || type == JS::Type::ObjectStart) {
      if (in_type == type) {
        depth++;
      } else if (in_type == JS::Type(static_cast<int>(type) + 1)) {
        depth--;
      }
    } else {
      depth--;
    }
  }
};
} // namespace Internal

class Tokenizer {
public:
  Tokenizer();

  void allowAsciiType(bool allow);
  void allowNewLineAsTokenDelimiter(bool allow);
  void allowSuperfluousComma(bool allow);

  void addData(const char* data, size_t size);
  template <size_t N> void addData(const char (&data)[N]);
  void addData(const std::vector<Token>* parsedData);
  void resetData(const char* data, size_t size, size_t index);
  void resetData(const std::vector<Token>* parsedData, size_t index);
  size_t registeredBuffers() const;

  void setNeedMoreDataCallback(std::function<void(Tokenizer&)> callback);
  void setReleaseCallback(std::function<void(const char*)>& callback);
  Error nextToken(Token& next_token);
  const char* currentPosition() const;

  void copyFromValue(const Token& token, std::string& to_buffer);
  void copyIncludingValue(const Token& token, std::string& to_buffer);

  void pushScope(JS::Type type);
  void popScope();
  JS::Error goToEndOfScope(JS::Token& token);

  std::string makeErrorString() const;
  void setErrorContextConfig(size_t lineContext, size_t rangeContext);
  Error updateErrorContext(Error error, const std::string& custom_message = std::string());
  const Internal::ErrorContext& errorContext() const { return error_context; }

private:
  enum class InTokenState : unsigned char { FindingName, FindingDelimiter, FindingData, FindingTokenEnd };

  enum class InPropertyState : unsigned char { NoStartFound, FindingEnd, FoundEnd };

  void resetForNewToken();
  void resetForNewValue();
  Error findStringEnd(const DataRef& json_data, size_t* chars_ahead);
  Error findAsciiEnd(const DataRef& json_data, size_t* chars_ahead);
  Error findNumberEnd(const DataRef& json_data, size_t* chars_ahead);
  Error findStartOfNextValue(Type* type, const DataRef& json_data, size_t* chars_ahead);
  Error findDelimiter(const DataRef& json_data, size_t* chars_ahead);
  Error findTokenEnd(const DataRef& json_data, size_t* chars_ahead);
  void requestMoreData();
  void releaseFirstDataRef();
  Error populateFromDataRef(DataRef& data, Type& type, const DataRef& json_data);
  static void populate_annonymous_token(const DataRef& data, Type type, Token& token);
  Error populateNextTokenFromDataRef(Token& next_token, const DataRef& json_data);

  InTokenState token_state = InTokenState::FindingName;
  InPropertyState property_state = InPropertyState::NoStartFound;
  Type property_type = Type::Error;
  bool is_escaped : 1;
  bool allow_ascii_properties : 1;
  bool allow_new_lines : 1;
  bool allow_superfluous_comma : 1;
  bool expecting_prop_or_annonymous_data : 1;
  bool continue_after_need_more_data : 1;
  size_t cursor_index;
  size_t current_data_start;
  size_t line_context;
  size_t line_range_context;
  size_t range_context;
  Internal::IntermediateToken intermediate_token;
  std::vector<DataRef> data_list;
  std::vector<Internal::ScopeCounter> scope_counter;
  std::vector<Type> container_stack;
  std::function<void(const char*)> release_callback;
  std::function<void(Tokenizer&)> need_more_data_callback;
  std::vector<std::pair<size_t, std::string*>> copy_buffers;
  const std::vector<Token>* parsed_data_vector;
  Internal::ErrorContext error_context;
};

namespace Internal {
template <size_t SIZE> struct StringLiteral {
  const char* data;
  enum size_enum { size = SIZE };
};
template <size_t SIZE> constexpr StringLiteral<SIZE - 1> makeStringLiteral(const char (&literal)[SIZE]) {
  return {literal};
}
} // namespace Internal

class SerializerOptions {
public:
  enum Style : unsigned char { Pretty, Compact };

  SerializerOptions(Style style = Style::Pretty);

  int shiftSize() const;
  void setShiftSize(unsigned char set);

  Style style() const;
  void setStyle(Style style);

  bool convertAsciiToString() const;
  void setConvertAsciiToString(bool set);

  unsigned char depth() const;
  void setDepth(int depth);

  void skipDelimiter(bool skip);

  const std::string& prefix() const;
  const std::string& tokenDelimiter() const;
  const std::string& valueDelimiter() const;
  const std::string& postfix() const;

private:
  uint8_t m_shift_size;
  uint8_t m_depth;
  Style m_style;
  bool m_convert_ascii_to_string;

  std::string m_prefix;
  std::string m_token_delimiter;
  std::string m_value_delimiter;
  std::string m_postfix;
};

class SerializerBuffer {
public:
  SerializerBuffer() : buffer(nullptr), size(0), used(0) {}
  SerializerBuffer(char* buffer, size_t size) : buffer(buffer), size(size), used(0) {}
  size_t free() const { return size - used; }
  void append(const char* data, size_t size);
  template <size_t SIZE> void append(const char* data);
  char* buffer;
  size_t size;
  size_t used;
};

class Serializer {
public:
  Serializer();
  Serializer(char* buffer, size_t size);

  void setBuffer(char* buffer, size_t size);
  void setOptions(const SerializerOptions& option);
  SerializerOptions options() const { return m_option; }

  bool write(const Token& token);
  bool write(const char* data, size_t size);
  bool write(const std::string& str) { return write(str.c_str(), str.size()); }
  template <size_t SIZE> inline bool write(const Internal::StringLiteral<SIZE>& strLiteral);

  void setRequestBufferCallback(std::function<void(Serializer&)> callback);
  const SerializerBuffer& currentBuffer() const;

private:
  void askForMoreBuffers();
  void markCurrentSerializerBufferFull();
  bool writeAsString(const DataRef& data);
  bool write(Type type, const DataRef& data);

  std::function<void(Serializer&)> m_request_buffer_callback;
  SerializerBuffer m_current_buffer;

  bool m_first;
  bool m_token_start;
  SerializerOptions m_option;
};

// IMPLEMENTATION

inline Token::Token() : name(), value(), name_type(Type::String), value_type(Type::String) {}

inline Tokenizer::Tokenizer()
    : is_escaped(false), allow_ascii_properties(false), allow_new_lines(false), allow_superfluous_comma(false),
      expecting_prop_or_annonymous_data(false), continue_after_need_more_data(false), cursor_index(0),
      current_data_start(0), line_context(4), line_range_context(256), range_context(38), parsed_data_vector(nullptr) {
  container_stack.reserve(16);
}

inline void Tokenizer::allowAsciiType(bool allow) { allow_ascii_properties = allow; }

inline void Tokenizer::allowNewLineAsTokenDelimiter(bool allow) { allow_new_lines = allow; }

inline void Tokenizer::allowSuperfluousComma(bool allow) { allow_superfluous_comma = allow; }
inline void Tokenizer::addData(const char* data, size_t data_size) { data_list.push_back(DataRef(data, data_size)); }

template <size_t N> inline void Tokenizer::addData(const char (&data)[N]) { data_list.push_back(DataRef(data)); }

inline void Tokenizer::addData(const std::vector<Token>* parsedData) {
  assert(parsed_data_vector == 0);
  parsed_data_vector = parsedData;
  cursor_index = 0;
}

inline void Tokenizer::resetData(const char* data, size_t size, size_t index) {

  if (release_callback) {
    for (auto& data_buffer : data_list) {
      release_callback(data_buffer.data);
    }
  }
  data_list.clear();
  parsed_data_vector = nullptr;
  cursor_index = index;
  addData(data, size);
  resetForNewToken();
}

inline void Tokenizer::resetData(const std::vector<Token>* parsedData, size_t index) {
  if (release_callback) {
    for (auto& data_buffer : data_list) {
      release_callback(data_buffer.data);
    }
  }
  data_list.clear();
  parsed_data_vector = parsedData;
  cursor_index = index;
  resetForNewToken();
}

inline size_t Tokenizer::registeredBuffers() const { return data_list.size(); }

inline void Tokenizer::setNeedMoreDataCallback(std::function<void(Tokenizer&)> callback) {
  need_more_data_callback = callback;
}

inline void Tokenizer::setReleaseCallback(std::function<void(const char*)>& callback) { release_callback = callback; }

inline Error Tokenizer::nextToken(Token& next_token) {
  assert(
      !scope_counter.size() ||
      (scope_counter.back().type != JS::Type::ArrayEnd && scope_counter.back().type != JS::Type::ObjectEnd)
  );
  if (scope_counter.size() && scope_counter.back().depth == 0) {
    return Error::ScopeHasEnded;
  }
  if (parsed_data_vector) {
    next_token = (*parsed_data_vector)[cursor_index];
    cursor_index++;
    if (cursor_index == parsed_data_vector->size()) {
      cursor_index = 0;
      parsed_data_vector = nullptr;
    }
    if (scope_counter.size()) {
      scope_counter.back().handleType(next_token.value_type);
    }
    return Error::NoError;
  }
  if (data_list.empty()) {
    requestMoreData();
  }

  error_context.clear();

  if (data_list.empty()) {
    return Error::NeedMoreData;
  }

  if (!continue_after_need_more_data) {
    resetForNewToken();
  }

  Error error = Error::NeedMoreData;
  while (error == Error::NeedMoreData && data_list.size()) {
    const DataRef& json_data = data_list.front();
    error = populateNextTokenFromDataRef(next_token, json_data);

    if (error != Error::NoError && error != Error::NeedMoreData) {
      updateErrorContext(error);
    }

    if (error == Error::NeedMoreData) {
      releaseFirstDataRef();
      requestMoreData();
    }
  }

  continue_after_need_more_data = error == Error::NeedMoreData;
  if (error == JS::Error::NoError) {
    if (next_token.value_type == Type::ArrayStart || next_token.value_type == Type::ObjectStart) {
      container_stack.push_back(next_token.value_type);
    }
    if (next_token.value_type == Type::ArrayEnd) {
      if (!container_stack.size() || container_stack.back() != JS::Type::ArrayStart) {
        error = Error::UnexpectedArrayEnd;
        updateErrorContext(error);
        return error;
      }
      container_stack.pop_back();
    }
    if (next_token.value_type == Type::ObjectEnd) {
      if (!container_stack.size() || container_stack.back() != JS::Type::ObjectStart) {
        error = Error::UnexpectedObjectEnd;
        updateErrorContext(error);
        return error;
      }
      container_stack.pop_back();
    }
    if (scope_counter.size()) {
      scope_counter.back().handleType(next_token.value_type);
    }
  }
  return error;
}

inline const char* Tokenizer::currentPosition() const {
  if (parsed_data_vector) {
    return reinterpret_cast<const char*>(cursor_index);
  }

  if (data_list.empty()) {
    return nullptr;
  }

  return data_list.front().data + cursor_index;
}

static bool isValueInIntermediateToken(const Token& token, const Internal::IntermediateToken& intermediate) {
  if (intermediate.data.size()) {
    return token.value.data >= &intermediate.data[0] &&
           token.value.data < &intermediate.data[0] + intermediate.data.size();
  }
  return false;
}

inline void Tokenizer::copyFromValue(const Token& token, std::string& to_buffer) {
  if (isValueInIntermediateToken(token, intermediate_token)) {
    std::string data(token.value.data, token.value.size);
    to_buffer += data;
    auto pair = std::make_pair(cursor_index, &to_buffer);
    copy_buffers.push_back(pair);
  } else {
    assert(
        token.value.data >= data_list.front().data && token.value.data < data_list.front().data + data_list.front().size
    );
    ptrdiff_t index = token.value.data - data_list.front().data;
    auto pair = std::make_pair(index, &to_buffer);
    copy_buffers.push_back(pair);
  }
}

inline void Tokenizer::copyIncludingValue(const Token&, std::string& to_buffer) {
  auto it =
      std::find_if(copy_buffers.begin(), copy_buffers.end(), [&to_buffer](const std::pair<size_t, std::string*>& pair) {
        return &to_buffer == pair.second;
      });
  assert(it != copy_buffers.end());
  assert(it->first <= cursor_index);
  if (cursor_index - it->first != 0) {
    to_buffer.append(data_list.front().data + it->first, cursor_index - it->first);
  }
  copy_buffers.erase(it);
}

inline void Tokenizer::pushScope(JS::Type type) {
  scope_counter.push_back({type, 1});
  if (type != Type::ArrayStart && type != Type::ObjectStart) {
    scope_counter.back().depth--;
  }
}

inline void Tokenizer::popScope() {
  assert(scope_counter.size() && scope_counter.back().depth == 0);
  scope_counter.pop_back();
}

inline JS::Error Tokenizer::goToEndOfScope(JS::Token& token) {
  JS::Error error = JS::Error::NoError;
  while (scope_counter.back().depth && error == JS::Error::NoError) {
    error = nextToken(token);
  }
  return error;
}

namespace Internal {
static const char* error_strings[] = {
    "NoError",
    "NeedMoreData",
    "InvalidToken",
    "ExpectedPropertyName",
    "ExpectedDelimiter",
    "ExpectedDataToken",
    "ExpectedObjectStart",
    "ExpectedObjectEnd",
    "ExpectedArrayStart",
    "ExpectedArrayEnd",
    "UnexpectedArrayEnd",
    "UnexpectedObjectEnd",
    "IllegalPropertyName",
    "IllegalPropertyType",
    "IllegalDataValue",
    "EncounteredIllegalChar",
    "NodeNotFound",
    "MissingPropertyMember",
    "MissingFunction",
    "FailedToParseBoolean",
    "FailedToParseDouble",
    "FailedToParseFloat",
    "FailedToParseInt",
    "UnassignedRequiredMember",
    "NonContigiousMemory",
    "ScopeHasEnded",
    "KeyNotFound",
    "DuplicateInSet",
    "UnknownError",
    "UserDefinedErrors",
};
}

inline std::string Tokenizer::makeErrorString() const {
  static_assert(
      sizeof(Internal::error_strings) / sizeof *Internal::error_strings == size_t(Error::UserDefinedErrors) + 1,
      "Please add missing error message"
  );

  std::string retString("Error");
  if (error_context.error < Error::UserDefinedErrors) {
    retString += std::string(" ") + Internal::error_strings[int(error_context.error)];
  }
  if (error_context.custom_message.size()) {
    retString += " " + error_context.custom_message;
  }
  retString += std::string(":\n");
  for (size_t i = 0; i < error_context.lines.size(); i++) {
    retString += error_context.lines[i] + "\n";
    if (i == error_context.line) {
      std::string pointing(error_context.character + 2, ' ');
      pointing[error_context.character] = '^';
      pointing[error_context.character + 1] = '\n';
      retString += pointing;
    }
  }
  return retString;
}

inline void Tokenizer::setErrorContextConfig(size_t lineContext, size_t rangeContext) {
  line_context = lineContext;
  range_context = rangeContext;
}

inline void Tokenizer::resetForNewToken() {
  intermediate_token.clear();
  resetForNewValue();
}

inline void Tokenizer::resetForNewValue() {
  property_state = InPropertyState::NoStartFound;
  property_type = Type::Error;
  current_data_start = 0;
}

inline Error Tokenizer::findStringEnd(const DataRef& json_data, size_t* chars_ahead) {
  size_t end = cursor_index;
  while (end < json_data.size) {
    if (is_escaped) {
      is_escaped = false;
      end++;
      continue;
    }
    while (end + 4 < json_data.size) {
      unsigned char lc = Internal::lookup()[(unsigned char) json_data.data[end]];
      if (lc == Internal::StrEndOrBackSlash) {
        break;
      }
      lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
      if (lc == Internal::StrEndOrBackSlash) {
        break;
      }
      lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
      if (lc == Internal::StrEndOrBackSlash) {
        break;
      }
      lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
      if (lc == Internal::StrEndOrBackSlash) {
        break;
      }
      end++;
    }
    if (end >= json_data.size) {
      break;
    }
    char c = json_data.data[end];
    if (c == '\\') {
      is_escaped = true;
    } else if (c == '"') {
      *chars_ahead = end + 1 - cursor_index;
      return Error::NoError;
    }
    end++;
  }
  return Error::NeedMoreData;
}

inline Error Tokenizer::findAsciiEnd(const DataRef& json_data, size_t* chars_ahead) {
  assert(property_type == Type::Ascii);
  size_t end = cursor_index;
  while (end < json_data.size) {
    while (end + 4 < json_data.size) {
      unsigned char lc = Internal::lookup()[(unsigned char) json_data.data[end]];
      if (!(lc & (Internal::AsciiLetters | Internal::Digits | Internal::HatUnderscoreAprostoph))) {
        break;
      }
      lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
      if (!(lc & (Internal::AsciiLetters | Internal::Digits | Internal::HatUnderscoreAprostoph))) {
        break;
      }
      lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
      if (!(lc & (Internal::AsciiLetters | Internal::Digits | Internal::HatUnderscoreAprostoph))) {
        break;
      }
      lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
      if (!(lc & (Internal::AsciiLetters | Internal::Digits | Internal::HatUnderscoreAprostoph))) {
        break;
      }
      end++;
    }

    char ascii_code = json_data.data[end];
    if ((ascii_code >= 'A' && ascii_code <= 'Z') || (ascii_code >= '^' && ascii_code <= 'z') ||
        (ascii_code >= '0' && ascii_code <= '9')) {
      end++;
      continue;
    } else if (ascii_code == '\0') {
      *chars_ahead = end - cursor_index;
      return Error::NeedMoreData;
    } else {
      *chars_ahead = end - cursor_index;
      return Error::NoError;
    }
  }
  return Error::NeedMoreData;
}

inline Error Tokenizer::findNumberEnd(const DataRef& json_data, size_t* chars_ahead) {
  size_t end = cursor_index;
  while (end + 4 < json_data.size) {
    unsigned char lc = Internal::lookup()[(unsigned char) json_data.data[end]];
    if (!(lc & (Internal::NumberEnd))) {
      break;
    }
    lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
    if (!(lc & (Internal::NumberEnd))) {
      break;
    }
    lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
    if (!(lc & (Internal::NumberEnd))) {
      break;
    }
    lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
    if (!(lc & (Internal::NumberEnd))) {
      break;
    }
    end++;
  }
  while (end < json_data.size) {
    unsigned char lc = Internal::lookup()[(unsigned char) json_data.data[end]];
    if (lc & (Internal::NumberEnd)) {
      end++;
    } else {
      *chars_ahead = end - cursor_index;
      return Error::NoError;
    }
  }
  return Error::NeedMoreData;
}

inline Error Tokenizer::findStartOfNextValue(Type* type, const DataRef& json_data, size_t* chars_ahead) {

  assert(property_state == InPropertyState::NoStartFound);

  for (size_t current_pos = cursor_index; current_pos < json_data.size; current_pos++) {
    const char c = json_data.data[current_pos];
    unsigned char lc = Internal::lookup()[(unsigned char) c];
    if (c == '"') {
      *type = Type::String;
      *chars_ahead = current_pos - cursor_index;
      return Error::NoError;
    } else if (c == '{') {
      *type = Type::ObjectStart;
      *chars_ahead = current_pos - cursor_index;
      return Error::NoError;
    } else if (c == '}') {
      *type = Type::ObjectEnd;
      *chars_ahead = current_pos - cursor_index;
      return Error::NoError;
    } else if (c == '[') {
      *type = Type::ArrayStart;
      *chars_ahead = current_pos - cursor_index;
      return Error::NoError;
    } else if (c == ']') {
      *type = Type::ArrayEnd;
      *chars_ahead = current_pos - cursor_index;
      return Error::NoError;
    } else if (lc & (Internal::PlusOrMinus | Internal::Digits)) {
      *type = Type::Number;
      *chars_ahead = current_pos - cursor_index;
      return Error::NoError;
    } else if (lc & Internal::AsciiLetters) {
      *type = Type::Ascii;
      *chars_ahead = current_pos - cursor_index;
      return Error::NoError;
    } else if (lc == 0) {
      *chars_ahead = current_pos - cursor_index;
      return Error::EncounteredIllegalChar;
    }
  }
  return Error::NeedMoreData;
}

inline Error Tokenizer::findDelimiter(const DataRef& json_data, size_t* chars_ahead) {
  if (container_stack.empty()) {
    return Error::IllegalPropertyType;
  }
  for (size_t end = cursor_index; end < json_data.size; end++) {
    const char c = json_data.data[end];
    if (c == ':') {
      if (container_stack.back() != Type::ObjectStart) {
        return Error::ExpectedDelimiter;
      }
      token_state = InTokenState::FindingData;
      *chars_ahead = end + 1 - cursor_index;
      return Error::NoError;
    } else if (c == ',') {
      if (container_stack.back() != Type::ArrayStart) {
        return Error::ExpectedDelimiter;
      }
      token_state = InTokenState::FindingName;
      *chars_ahead = end + 1 - cursor_index;
      return Error::NoError;
    } else if (c == ']') {
      if (container_stack.back() != Type::ArrayStart) {
        return Error::ExpectedDelimiter;
      }
      token_state = InTokenState::FindingName;
      *chars_ahead = end - cursor_index;
      return Error::NoError;
    } else if (!(Internal::lookup()[(unsigned char) c] & Internal::WhiteSpaceOrNull)) {
      return Error::ExpectedDelimiter;
    }
  }
  return Error::NeedMoreData;
}

inline Error Tokenizer::findTokenEnd(const DataRef& json_data, size_t* chars_ahead) {
  if (container_stack.empty()) {
    return Error::NoError;
  }
  for (size_t end = cursor_index; end < json_data.size; end++) {
    const char c = json_data.data[end];
    if (c == ',') {
      expecting_prop_or_annonymous_data = true;
      *chars_ahead = end + 1 - cursor_index;
      return Error::NoError;
    } else if (c == ']' || c == '}') {
      *chars_ahead = end - cursor_index;
      return Error::NoError;
    } else if (c == '\n') {
      if (allow_new_lines) {
        *chars_ahead = end + 1 - cursor_index;
        return Error::NoError;
      }
    } else if (Internal::lookup()[(unsigned char) c] & Internal::WhiteSpaceOrNull) {
      continue;
    } else {
      *chars_ahead = end + 1 - cursor_index;
      return Error::InvalidToken;
    }
  }
  return Error::NeedMoreData;
}

inline void Tokenizer::requestMoreData() {
  if (need_more_data_callback) {
    need_more_data_callback(*this);
  }
}

inline void Tokenizer::releaseFirstDataRef() {
  if (data_list.empty()) {
    return;
  }

  const DataRef& json_data = data_list.front();

  for (auto& copy_pair : copy_buffers) {
    std::string data(json_data.data + copy_pair.first, json_data.size - copy_pair.first);
    *copy_pair.second += data;
    copy_pair.first = 0;
  }

  cursor_index = 0;
  current_data_start = 0;

  const char* data_to_release = json_data.data;
  data_list.erase(data_list.begin());
  if (release_callback) {
    release_callback(data_to_release);
  }
}

inline Error Tokenizer::populateFromDataRef(DataRef& data, Type& type, const DataRef& json_data) {
  size_t diff = 0;
  Error error = Error::NoError;
  data.size = 0;
  data.data = json_data.data + cursor_index;
  if (property_state == InPropertyState::NoStartFound) {
    error = findStartOfNextValue(&type, json_data, &diff);
    if (error != Error::NoError) {
      type = Type::Error;
      return error;
    }

    data.data = json_data.data + cursor_index + diff;
    current_data_start = cursor_index + diff;
    if (type == Type::String) {
      data.data++;
      current_data_start++;
    }
    cursor_index += diff + 1;
    property_type = type;

    if (type == Type::ObjectStart || type == Type::ObjectEnd || type == Type::ArrayStart || type == Type::ArrayEnd) {
      data.size = 1;
      property_state = InPropertyState::FoundEnd;
    } else {
      property_state = InPropertyState::FindingEnd;
    }
  }

  size_t negative_size_adjustment = 0;
  if (property_state == InPropertyState::FindingEnd) {
    switch (type) {
    case Type::String:
      error = findStringEnd(json_data, &diff);
      negative_size_adjustment = 1;
      break;
    case Type::Ascii:
      error = findAsciiEnd(json_data, &diff);
      break;
    case Type::Number:
      error = findNumberEnd(json_data, &diff);
      break;
    default:
      return Error::InvalidToken;
    }

    if (error != Error::NoError) {
      return error;
    }

    cursor_index += diff;
    data.size = cursor_index - current_data_start - negative_size_adjustment;
    property_state = InPropertyState::FoundEnd;
  }

  return Error::NoError;
}

inline void Tokenizer::populate_annonymous_token(const DataRef& data, Type type, Token& token) {
  token.name = DataRef();
  token.name_type = Type::Ascii;
  token.value = data;
  token.value_type = type;
}

namespace Internal {
static Type getType(Type type, const char* data, size_t length) {
  static const char m_null[] = "null";
  static const char m_true[] = "true";
  static const char m_false[] = "false";
  if (type != Type::Ascii) {
    return type;
  }
  if (sizeof(m_null) - 1 == length) {
    if (memcmp(m_null, data, length) == 0) {
      return Type::Null;
    } else if (memcmp(m_true, data, length) == 0) {
      return Type::Bool;
    }
  }
  if (sizeof(m_false) - 1 == length) {
    if (memcmp(m_false, data, length) == 0) {
      return Type::Bool;
    }
  }
  return Type::Ascii;
}

inline size_t strnlen(const char* data, size_t size) {
  auto it = std::find(data, data + size, '\0');
  return it - data;
}

} // namespace Internal

inline Error Tokenizer::populateNextTokenFromDataRef(Token& next_token, const DataRef& json_data) {
  Token tmp_token;
  while (cursor_index < json_data.size) {
    size_t diff = 0;
    DataRef data;
    Type type;
    Error error;
    switch (token_state) {
    case InTokenState::FindingName:
      type = intermediate_token.name_type;
      error = populateFromDataRef(data, type, json_data);
      if (error == Error::NeedMoreData) {
        if (property_state > InPropertyState::NoStartFound) {
          intermediate_token.active = true;
          size_t to_null = Internal::strnlen(data.data, json_data.size - current_data_start);
          intermediate_token.name.append(data.data, to_null);
          if (!intermediate_token.name_type_set) {
            intermediate_token.name_type = type;
            intermediate_token.name_type_set = true;
          }
        }
        return error;
      } else if (error != Error::NoError) {
        return error;
      }

      if (intermediate_token.active) {
        intermediate_token.name.append(data.data, data.size);
        data = DataRef(intermediate_token.name);
        type = intermediate_token.name_type;
      }

      if (type == Type::ObjectEnd || type == Type::ArrayEnd || type == Type::ArrayStart || type == Type::ObjectStart) {
        switch (type) {
        case Type::ObjectEnd:
        case Type::ArrayEnd:
          if (expecting_prop_or_annonymous_data && !allow_superfluous_comma) {
            return Error::ExpectedDataToken;
          }
          populate_annonymous_token(data, type, next_token);
          token_state = InTokenState::FindingTokenEnd;
          return Error::NoError;

        case Type::ObjectStart:
        case Type::ArrayStart:
          populate_annonymous_token(data, type, next_token);
          expecting_prop_or_annonymous_data = false;
          token_state = InTokenState::FindingName;
          return Error::NoError;
        default:
          return Error::UnknownError;
        }
      } else {
        tmp_token.name = data;
      }

      tmp_token.name_type = Internal::getType(type, tmp_token.name.data, tmp_token.name.size);
      token_state = InTokenState::FindingDelimiter;
      resetForNewValue();
      break;

    case InTokenState::FindingDelimiter:
      error = findDelimiter(json_data, &diff);
      if (error != Error::NoError) {
        if (intermediate_token.active == false) {
          intermediate_token.name.append(tmp_token.name.data, tmp_token.name.size);
          intermediate_token.name_type = tmp_token.name_type;
          intermediate_token.active = true;
        }
        return error;
      }
      cursor_index += diff;
      resetForNewValue();
      expecting_prop_or_annonymous_data = false;
      if (token_state == InTokenState::FindingName) {
        populate_annonymous_token(tmp_token.name, tmp_token.name_type, next_token);
        return Error::NoError;
      } else {
        if (tmp_token.name_type != Type::String) {
          if (!allow_ascii_properties || tmp_token.name_type != Type::Ascii) {
            return Error::IllegalPropertyName;
          }
        }
      }
      break;

    case InTokenState::FindingData:
      type = intermediate_token.data_type;
      error = populateFromDataRef(data, type, json_data);
      if (error == Error::NeedMoreData) {
        if (intermediate_token.active == false) {
          intermediate_token.name.append(tmp_token.name.data, tmp_token.name.size);
          intermediate_token.name_type = tmp_token.name_type;
          intermediate_token.active = true;
        }
        if (property_state > InPropertyState::NoStartFound) {
          size_t data_length = Internal::strnlen(data.data, json_data.size - current_data_start);
          intermediate_token.data.append(data.data, data_length);
          if (!intermediate_token.data_type_set) {
            intermediate_token.data_type = type;
            intermediate_token.data_type_set = true;
          }
        }
        return error;
      } else if (error != Error::NoError) {
        return error;
      }

      if (intermediate_token.active) {
        intermediate_token.data.append(data.data, data.size);
        if (!intermediate_token.data_type_set) {
          intermediate_token.data_type = type;
          intermediate_token.data_type_set = true;
        }
        tmp_token.name = DataRef(intermediate_token.name);
        tmp_token.name_type = intermediate_token.name_type;
        data = DataRef(intermediate_token.data);
        type = intermediate_token.data_type;
      }

      tmp_token.value = data;
      tmp_token.value_type = Internal::getType(type, tmp_token.value.data, tmp_token.value.size);

      if (tmp_token.value_type == Type::Ascii && !allow_ascii_properties) {
        return Error::IllegalDataValue;
      }

      if (type == Type::ObjectStart || type == Type::ArrayStart) {
        token_state = InTokenState::FindingName;
      } else {
        token_state = InTokenState::FindingTokenEnd;
      }
      next_token = tmp_token;
      return Error::NoError;
    case InTokenState::FindingTokenEnd:
      error = findTokenEnd(json_data, &diff);
      if (error != Error::NoError) {
        return error;
      }
      cursor_index += diff;
      token_state = InTokenState::FindingName;
      break;
    }
  }
  return Error::NeedMoreData;
}

namespace Internal {
struct Lines {
  size_t start;
  size_t end;
};
} // namespace Internal

inline Error Tokenizer::updateErrorContext(Error error, const std::string& custom_message) {
  error_context.error = error;
  error_context.custom_message = custom_message;
  if ((!parsed_data_vector || parsed_data_vector->empty()) && data_list.empty()) {
    return error;
  }

  const DataRef json_data =
      parsed_data_vector && parsed_data_vector->size()
          ? DataRef(
                parsed_data_vector->front().value.data,
                size_t(parsed_data_vector->back().value.data - parsed_data_vector->front().value.data)
            )
          : data_list.front();
  int64_t real_cursor_index = parsed_data_vector && parsed_data_vector->size()
                                  ? int64_t(parsed_data_vector->at(cursor_index).value.data - json_data.data)
                                  : int64_t(cursor_index);
  const int64_t stop_back = real_cursor_index - std::min(int64_t(real_cursor_index), int64_t(line_range_context));
  const int64_t stop_forward = std::min(real_cursor_index + int64_t(line_range_context), int64_t(json_data.size));
  std::vector<Internal::Lines> lines;
  lines.push_back({0, size_t(real_cursor_index)});
  assert(real_cursor_index <= int64_t(json_data.size));
  int64_t lines_back = 0;
  int64_t lines_forward = 0;
  int64_t cursor_back;
  int64_t cursor_forward;
  for (cursor_back = real_cursor_index - 1; cursor_back > stop_back; cursor_back--) {
    if (*(json_data.data + cursor_back) == '\n') {
      lines.front().start = size_t(cursor_back + 1);
      lines_back++;
      if (lines_back == 1) {
        error_context.character = size_t(real_cursor_index - cursor_back);
      }
      if (lines_back == int64_t(line_context)) {
        lines_back--;
        break;
      }

      lines.insert(lines.begin(), {0, size_t(cursor_back)});
    }
  }
  if (lines.front().start == 0 && cursor_back > 0) {
    lines.front().start = size_t(cursor_back);
  }
  bool add_new_line = false;
  for (cursor_forward = real_cursor_index; cursor_forward < stop_forward; cursor_forward++) {
    if (add_new_line) {
      lines.push_back({size_t(cursor_forward), 0});
      add_new_line = false;
    }
    if (*(json_data.data + cursor_forward) == '\n') {
      lines.back().end = size_t(cursor_forward);
      lines_forward++;
      if (lines_forward == int64_t(line_context)) {
        break;
      }
      add_new_line = true;
    }
  }
  if (lines.back().end == 0) {
    lines.back().end = size_t(cursor_forward - 1);
  }

  if (lines.size() > 1) {
    error_context.lines.reserve(lines.size());
    for (auto& line : lines) {
      error_context.lines.push_back(std::string(json_data.data + line.start, line.end - line.start));
    }
    error_context.line = size_t(lines_back);
  } else {
    error_context.line = 0;

    int64_t left = real_cursor_index > int64_t(range_context) ? real_cursor_index - int64_t(range_context) : 0;
    int64_t right = real_cursor_index + int64_t(range_context) > int64_t(json_data.size)
                        ? int64_t(json_data.size)
                        : real_cursor_index + int64_t(range_context);
    error_context.character = size_t(real_cursor_index - left);
    error_context.lines.push_back(std::string(json_data.data + left, size_t(right - left)));
  }
  return error;
}

static inline JS::Error reformat(
    const char* data, size_t size, std::string& out, const SerializerOptions& options = SerializerOptions()
) {
  Token token;
  Tokenizer tokenizer;
  tokenizer.addData(data, size);
  Error error = Error::NoError;

  Serializer serializer;
  serializer.setOptions(options);
  size_t last_pos = 0;
  serializer.setRequestBufferCallback([&out, &last_pos](Serializer& serializer_p) {
    size_t end = out.size();
    out.resize(end * 2);
    serializer_p.setBuffer(&out[0] + end, end);
    last_pos = end;
  });
  if (out.empty()) {
    out.resize(4096);
  }
  serializer.setBuffer(&out[0], out.size());

  while (error == Error::NoError) {
    error = tokenizer.nextToken(token);
    if (error != Error::NoError) {
      break;
    }
    serializer.write(token);
  }
  out.resize(last_pos + serializer.currentBuffer().used);
  if (error == Error::NeedMoreData) {
    return Error::NoError;
  }

  return error;
}
static inline JS::Error reformat(
    const std::string& in, std::string& out, const SerializerOptions& options = SerializerOptions()
) {
  return reformat(in.c_str(), in.size(), out, options);
}

// Tuple start
namespace Internal {
template <size_t...> struct Sequence {
  using type = Sequence;
};

template <typename A, typename B> struct Merge;
template <size_t... Is1, size_t... Is2> struct Merge<Sequence<Is1...>, Sequence<Is2...>> {
  using type = Sequence<Is1..., (sizeof...(Is1) + Is2)...>;
};

template <size_t size> struct GenSequence;
template <> struct GenSequence<0> {
  using type = Sequence<>;
};
template <> struct GenSequence<1> {
  using type = Sequence<0>;
};
template <size_t size> struct GenSequence {
  using type = typename Merge<
      typename GenSequence<size / size_t(2)>::type, typename GenSequence<size - size / size_t(2)>::type>::type;
};

template <size_t index, typename T> struct Element {
  constexpr Element() : data() {}

  constexpr Element(const T& t) : data(t) {}
  using type = T;
  T data;
};

template <typename A, typename... Bs> struct TupleImpl;

template <size_t... indices, typename... Ts>
struct TupleImpl<Sequence<indices...>, Ts...> : public Element<indices, Ts>... {
  constexpr TupleImpl() : Element<indices, Ts>()... {}

  constexpr TupleImpl(Ts... args) : Element<indices, Ts>(args)... {}
};
} // namespace Internal

template <size_t I, typename... Ts> struct TypeAt {
  template <typename T> static Internal::Element<I, T> deduce(Internal::Element<I, T>);

  using tuple_impl = Internal::TupleImpl<typename Internal::GenSequence<sizeof...(Ts)>::type, Ts...>;
  using element = decltype(deduce(tuple_impl()));
  using type = typename element::type;
};

template <typename... Ts> struct Tuple {
  constexpr Tuple() : impl() {}

  constexpr Tuple(Ts... args) : impl(args...) {}

  using Seq = typename Internal::GenSequence<sizeof...(Ts)>::type;
  Internal::TupleImpl<Seq, Ts...> impl;
  static constexpr const size_t size = sizeof...(Ts);

  template <size_t Index> constexpr const typename TypeAt<Index, Ts...>::type& get() const {
    return static_cast<const typename TypeAt<Index, Ts...>::element&>(impl).data;
  }

  template <size_t Index> typename TypeAt<Index, Ts...>::type& get() {
    return static_cast<typename TypeAt<Index, Ts...>::element&>(impl).data;
  }
};

/// \private
template <size_t I, typename... Ts> struct TypeAt<I, const Tuple<Ts...>> {
  template <typename T> static Internal::Element<I, T> deduce(Internal::Element<I, T>);

  using tuple_impl = Internal::TupleImpl<typename Internal::GenSequence<sizeof...(Ts)>::type, Ts...>;
  using element = decltype(deduce(tuple_impl()));
  using type = typename element::type;
};

/// \private
template <size_t I, typename... Ts> struct TypeAt<I, Tuple<Ts...>> {
  template <typename T> static Internal::Element<I, T> deduce(Internal::Element<I, T>);

  using tuple_impl = Internal::TupleImpl<typename Internal::GenSequence<sizeof...(Ts)>::type, Ts...>;
  using element = decltype(deduce(tuple_impl()));
  using type = typename element::type;
};

/*!  \private
 */
template <> struct Tuple<> {
  static constexpr const size_t size = 0;
};

template <typename... Ts> constexpr Tuple<Ts...> makeTuple(Ts... args) { return Tuple<Ts...>(args...); }
// Tuple end

inline SerializerOptions::SerializerOptions(Style style)

    : m_shift_size(style == Compact ? 0 : 2), m_depth(0), m_style(style), m_convert_ascii_to_string(true),
      m_token_delimiter(","), m_value_delimiter(style == Pretty ? ": " : ":"), m_postfix(style == Pretty ? "\n" : "") {}

inline int SerializerOptions::shiftSize() const { return m_shift_size; }

inline void SerializerOptions::setShiftSize(unsigned char set) { m_shift_size = set; }

inline unsigned char SerializerOptions::depth() const { return m_depth; }

inline SerializerOptions::Style SerializerOptions::style() const { return m_style; }

inline bool SerializerOptions::convertAsciiToString() const { return m_convert_ascii_to_string; }

inline void SerializerOptions::setConvertAsciiToString(bool set) { m_convert_ascii_to_string = set; }

inline void SerializerOptions::setStyle(Style style) {
  m_style = style;
  m_postfix = m_style == Pretty ? std::string("\n") : std::string("");
  m_value_delimiter = m_style == Pretty ? std::string(" : ") : std::string(":");
  setDepth(m_depth);
}

inline void SerializerOptions::skipDelimiter(bool skip) {
  if (skip) {
    m_token_delimiter = "";
  } else {
    m_token_delimiter = ",";
  }
}

inline void SerializerOptions::setDepth(int depth) {
  m_depth = (unsigned char) depth;
  m_prefix = m_style == Pretty ? std::string(depth * size_t(m_shift_size), ' ') : std::string();
}

inline const std::string& SerializerOptions::prefix() const { return m_prefix; }
inline const std::string& SerializerOptions::tokenDelimiter() const { return m_token_delimiter; }
inline const std::string& SerializerOptions::valueDelimiter() const { return m_value_delimiter; }
inline const std::string& SerializerOptions::postfix() const { return m_postfix; }

inline void SerializerBuffer::append(const char* data, size_t data_size) {
  assert(used + data_size <= size);
  memcpy(buffer + used, data, data_size);
  used += data_size;
}

template <size_t SIZE> inline void SerializerBuffer::append(const char* data) {
  assert(used + SIZE <= size);
  memcpy(buffer + used, data, SIZE);
  used += SIZE;
}

inline Serializer::Serializer() : m_first(true), m_token_start(true) {}

inline Serializer::Serializer(char* buffer, size_t size)
    : m_current_buffer(buffer, size), m_first(true), m_token_start(true)

{}

inline void Serializer::setBuffer(char* buffer, size_t size) { m_current_buffer = SerializerBuffer(buffer, size); }

inline void Serializer::setOptions(const SerializerOptions& option) { m_option = option; }

inline bool Serializer::write(const Token& in_token) {
  auto begining_literals = makeTuple(
      JS::Internal::makeStringLiteral("\n  "), Internal::makeStringLiteral("\n    "),
      Internal::makeStringLiteral("\n      "), Internal::makeStringLiteral("\n        "),
      Internal::makeStringLiteral("\n          "), Internal::makeStringLiteral(",\n  "),
      Internal::makeStringLiteral(",\n    "), Internal::makeStringLiteral(",\n      "),
      Internal::makeStringLiteral(",\n        "), Internal::makeStringLiteral(",\n          ")
  );
  // auto begining_literals_compat = makeTuple( Internal::makeStringLiteral(",\""));
  const Token& token = in_token;

  bool isEnd = token.value_type == Type::ObjectEnd || token.value_type == Type::ArrayEnd;
  if (isEnd) {
    if (m_option.depth() <= 0) {
      return false;
    }
    m_option.setDepth(m_option.depth() - 1);
  }

  bool shortcut_front = false;
  if (m_option.shiftSize() == 2 && !m_first) {
    if (!m_token_start && !isEnd) {
      if (m_option.depth() == 1) {
        shortcut_front = write(begining_literals.get<5>());
      } else if (m_option.depth() == 2) {
        shortcut_front = write(begining_literals.get<6>());
      } else if (m_option.depth() == 3) {
        shortcut_front = write(begining_literals.get<7>());
      } else if (m_option.depth() == 4) {
        shortcut_front = write(begining_literals.get<8>());
      } else if (m_option.depth() == 5) {
        shortcut_front = write(begining_literals.get<9>());
      }
    } else {
      if (m_option.depth() == 1) {
        shortcut_front = write(begining_literals.get<0>());
      } else if (m_option.depth() == 2) {
        shortcut_front = write(begining_literals.get<1>());
      } else if (m_option.depth() == 3) {
        shortcut_front = write(begining_literals.get<2>());
      } else if (m_option.depth() == 4) {
        shortcut_front = write(begining_literals.get<3>());
      } else if (m_option.depth() == 5) {
        shortcut_front = write(begining_literals.get<4>());
      }
    }
  }

  if (!shortcut_front) {
    if (!m_token_start) {
      if (!isEnd) {
        if (!m_option.tokenDelimiter().empty()) {
          if (!write(Internal::makeStringLiteral(","))) {
            return false;
          }
        }
      }
    }

    if (m_first) {
      m_first = false;
    } else {
      if (!m_option.postfix().empty()) {
        if (!write(m_option.postfix())) {
          return false;
        }
      }
    }

    if (!m_option.prefix().empty()) {
      if (!write(m_option.prefix())) {
        return false;
      }
    }
  }
  if (token.name.size) {
    if (!write(token.name_type, token.name)) {
      return false;
    }

    if (m_option.style() == SerializerOptions::Pretty) {
      if (!write(Internal::makeStringLiteral(": "))) {
        return false;
      }
    } else {
      if (!write(Internal::makeStringLiteral(":"))) {
        return false;
      }
    }
  }

  if (!write(token.value_type, token.value)) {
    return false;
  }

  m_token_start = (token.value_type == Type::ObjectStart || token.value_type == Type::ArrayStart);
  if (m_token_start) {
    m_option.setDepth(m_option.depth() + 1);
  }
  return true;
}

inline void Serializer::setRequestBufferCallback(std::function<void(Serializer&)> callback) {
  m_request_buffer_callback = callback;
}

inline const SerializerBuffer& Serializer::currentBuffer() const { return m_current_buffer; }

inline void Serializer::askForMoreBuffers() {
  if (m_request_buffer_callback) {
    m_request_buffer_callback(*this);
  }
}

inline void Serializer::markCurrentSerializerBufferFull() {
  m_current_buffer = SerializerBuffer();
  askForMoreBuffers();
}

inline bool Serializer::writeAsString(const DataRef& data) {
  bool written;
  written = write(Internal::makeStringLiteral("\""));
  if (!written) {
    return false;
  }

  written = write(data.data, data.size);
  if (!written) {
    return false;
  }

  written = write(Internal::makeStringLiteral("\""));

  return written;
}

inline bool Serializer::write(Type type, const DataRef& data) {
  bool written;
  switch (type) {
  case Type::String:
    written = writeAsString(data);
    break;
  case Type::Ascii:
    if (m_option.convertAsciiToString()) {
      written = writeAsString(data);
    } else {
      written = write(data.data, data.size);
    }
    break;
  case Type::Null:
    written = write("null", 4);
    break;
  default:
    written = write(data.data, data.size);
    break;
  }
  return written;
}

inline bool Serializer::write(const char* data, size_t size) {
  if (!size) {
    return true;
  }
  size_t written = 0;
  while (written < size) {
    size_t free = m_current_buffer.free();
    if (free == 0) {
      markCurrentSerializerBufferFull();
      if (!m_current_buffer.free()) {
        return false;
      }
      continue;
    }
    size_t to_write = std::min(size - written, free);
    m_current_buffer.append(data + written, to_write);
    written += to_write;
  }
  return written == size;
}

template <size_t SIZE> inline bool Serializer::write(const Internal::StringLiteral<SIZE>& strLiteral) {
  if (m_current_buffer.free() < SIZE) {
    return write(strLiteral.data, SIZE);
  }

  m_current_buffer.append<SIZE>(strLiteral.data);
  return true;
}

template <typename T> struct Nullable {
  Nullable() : data() {}
  Nullable(const T& t) : data(t) {}
  Nullable(T&& t) : data(std::move(t)) {}

  Nullable(Nullable<T>&& t) : data(std::move(t.data)) {}
  Nullable(const Nullable<T>& t) : data(t.data) {}

  Nullable<T>& operator=(const T& other) {
    data = other;
    return *this;
  }
  Nullable<T>& operator=(T&& other) {
    data = std::move(other);
    return *this;
  }

  Nullable<T>& operator=(const Nullable<T>& other) {
    data = other.data;
    return *this;
  }
  Nullable<T>& operator=(Nullable<T>&& other) {
    data = std::move(other.data);
    return *this;
  }

  T data;
  T& operator()() { return data; }
  const T& operator()() const { return data; }
};

template <typename T> struct NullableChecked {
  NullableChecked() : data(), null(true) {}
  NullableChecked(const T& t) : data(t), null(false) {}
  NullableChecked(T&& t) : data(std::move(t)), null(false) {}
  NullableChecked(const NullableChecked<T>& t) : data(t.data), null(t.null) {}
  NullableChecked(NullableChecked<T>&& t) : data(std::move(t.data)), null(t.null) {}
  NullableChecked<T>& operator=(const T& other) {
    data = other;
    null = false;
    return *this;
  }
  NullableChecked<T>& operator=(T&& other) {
    data = std::move(other);
    null = false;
    return *this;
  }

  NullableChecked<T>& operator=(const NullableChecked<T>& other) {
    data = other.data;
    null = other.null;
    return *this;
  }
  NullableChecked<T>& operator=(NullableChecked<T>&& other) {
    data = std::move(other.data);
    null = other.null;
    return *this;
  }

  T& operator()() { return data; }
  const T& operator()() const { return data; }
  T data;
  bool null;
};

template <typename T> struct Optional {
  Optional() : data() {}
  Optional(const T& t) : data(t) {}
  Optional(T&& t) : data(std::move(t)) {}

  Optional(const Optional<T>& t) : data(t.data) {}
  Optional(Optional<T>&& t) : data(std::move(t.data)) {}
  Optional<T>& operator=(const T& other) {
    data = other;
    return *this;
  }

  Optional<T>& operator=(T&& other) {
    data = std::move(other);
    return *this;
  }

  Optional<T>& operator=(const Optional<T>& other) {
    data = other.data;
    return *this;
  }

  Optional<T>& operator=(Optional<T>&& other) {
    data = std::move(other.data);
    return *this;
  }

  T data;
  T& operator()() { return data; }
  const T& operator()() const { return data; }
  typedef bool IsOptionalType;
};

template <typename T> struct OptionalChecked {
  OptionalChecked() : data(), assigned(false) {}
  OptionalChecked(const T& t) : data(t), assigned(true) {}
  OptionalChecked(T&& t) : data(std::move(t)), assigned(true) {}
  OptionalChecked(const OptionalChecked<T>& t) : data(t.data), assigned(t.assigned) {}
  OptionalChecked(OptionalChecked<T>&& t) : data(std::move(t.data)), assigned(t.assigned) {}
  OptionalChecked<T>& operator=(const T& other) {
    data = other;
    assigned = true;
    return *this;
  }
  OptionalChecked<T>& operator=(T&& other) {
    data = std::move(other);
    assigned = true;
    return *this;
  }
  OptionalChecked<T>& operator=(const OptionalChecked<T>& other) {
    data = other.data;
    assigned = other.assigned;
    return *this;
  }
  OptionalChecked<T>& operator=(OptionalChecked<T>&& other) {
    data = std::move(other.data);
    assigned = other.assigned;
    return *this;
  }

  T& operator()() { return data; }
  const T& operator()() const { return data; }
#ifdef JS_STD_OPTIONAL
  std::optional<T> opt() const { return assigned ? std::optional<T>(data) : std::nullopt; }
#endif
  T data;
  bool assigned;
  typedef bool IsOptionalType;
};

struct SilentString {
  std::string data;
  typedef bool IsOptionalType;
};

template <typename T, typename A = std::allocator<T>> struct SilentVector {
  std::vector<T, A> data;
  typedef bool IsOptionalType;
};

template <typename T, typename Deleter = std::default_delete<T>> struct SilentUniquePtr {
  std::unique_ptr<T, Deleter> data;
  typedef bool IsOptionalType;
};

struct JsonObjectRef {
  DataRef ref;
};

struct JsonObject {
  std::string data;
};

struct JsonArrayRef {
  DataRef ref;
};

struct JsonArray {
  std::string data;
};

struct JsonObjectOrArrayRef {
  DataRef ref;
};

struct JsonObjectOrArray {
  std::string data;
};

struct JsonTokens {
  std::vector<JS::Token> data;
};

struct JsonMeta {
  JsonMeta(size_t pos, bool is_array)
      : position(pos), size(1), skip(1), children(0), complex_children(0), is_array(is_array), has_data(false) {}

  size_t position;
  uint32_t size;
  uint32_t skip;
  uint32_t children;
  uint32_t complex_children;
  bool is_array : 1;
  bool has_data : 1;
};

static inline std::vector<JsonMeta> metaForTokens(const JsonTokens& tokens) {
  std::vector<JsonMeta> meta;
  meta.reserve(tokens.data.size() / 4);
  std::vector<size_t> parent;
  for (size_t i = 0; i < tokens.data.size(); i++) {
    for (size_t parent_index : parent) {
      meta[parent_index].size++;
    }
    const JS::Token& token = tokens.data.at(i);
    if (token.value_type == Type::ArrayEnd || token.value_type == Type::ObjectEnd) {
      assert(parent.size());
      assert(meta[parent.back()].is_array == (token.value_type == Type::ArrayEnd));
      parent.pop_back();
    } else {
      if (parent.size()) {
        meta[parent.back()].children++;
      }
    }

    if (token.value_type == Type::ArrayStart || token.value_type == Type::ObjectStart) {
      if (parent.size()) {
        meta[parent.back()].complex_children++;
      }
      for (size_t parent_index : parent) {
        meta[parent_index].skip++;
      }
      meta.push_back(JsonMeta(i, token.value_type == Type::ArrayStart));
      parent.push_back(meta.size() - 1);
    } else if (token.value_type != JS::Type::ArrayEnd && token.value_type != JS::Type::ObjectEnd) {
      for (size_t parent_index : parent) {
        meta[parent_index].has_data = true;
      }
    }
  }
  assert(!parent.size()); // This assert may be triggered when JSON is invalid (e.g. when creating a DiffContext).
  return meta;
}

namespace Internal {
static inline size_t findFirstChildWithData(const std::vector<JsonMeta>& meta_vec, size_t start_index) {
  const JsonMeta& meta = meta_vec[start_index];
  if (!meta.has_data) {
    return size_t(-1);
  }

  size_t skip_size = 0;
  for (uint32_t i = 0; i < meta.complex_children; i++) {
    auto& current_child = meta_vec[start_index + skip_size + 1];
    skip_size += current_child.skip;
    if (current_child.has_data) {
      return i;
    }
  }
  return size_t(-1);
}
} // namespace Internal

template <typename T> struct IsOptionalType {
  typedef char yes[1];
  typedef char no[2];

  template <typename C> static constexpr yes& test_in_optional(typename C::IsOptionalType*);

  template <typename> static constexpr no& test_in_optional(...);

  static constexpr const bool value = sizeof(test_in_optional<T>(0)) == sizeof(yes);
};

/// \private
template <typename T> struct IsOptionalType<std::unique_ptr<T>> {
  static constexpr const bool value = true;
};

#ifdef JS_STD_OPTIONAL
/// \private
template <typename T> struct IsOptionalType<std::optional<T>> {
  static constexpr const bool value = true;
};
#endif

struct ParseContext {
  ParseContext() {}
  explicit ParseContext(const char* data, size_t size) { tokenizer.addData(data, size); }

  explicit ParseContext(const char* data) {
    size_t size = strlen(data);
    tokenizer.addData(data, size);
  }

  explicit ParseContext(const std::string& data) { tokenizer.addData(&data[0], data.size()); }

  template <typename T> explicit ParseContext(const char* data, size_t size, T& to_type) {
    tokenizer.addData(data, size);
    auto this_error = parseTo(to_type);
    (void) this_error;
  }
  template <size_t SIZE> explicit ParseContext(const char (&data)[SIZE]) { tokenizer.addData(data); }

  template <typename T> Error parseTo(T& to_type);

  Error nextToken() {
    error = tokenizer.nextToken(token);
    return error;
  }

  std::string makeErrorString() const {
    if (error == Error::MissingPropertyMember) {
      if (missing_members.size() == 0) {
        return "";
      } else if (missing_members.size() == 1) {
        return std::string("JSON Object contained member not found in C++ struct/class. JSON Object member is: ") +
               missing_members.front();
      }
      std::string member_string = missing_members.front();
      for (int i = 1; i < int(missing_members.size()); i++) {
        member_string += std::string(", ") + missing_members[i];
      }
      return std::string("JSON Object contained members not found in C++ struct/class. JSON Object members are: ") +
             member_string;
    } else if (error == Error::UnassignedRequiredMember) {
      if (unassigned_required_members.size() == 0) {
        return "";
      } else if (unassigned_required_members.size() == 1) {
        return std::string(
                   "C++ struct/class has a required member that is not present in input JSON. The unassigned "
                   "C++ member is: "
               ) +
               unassigned_required_members.front();
      }
      std::string required_string = unassigned_required_members.front();
      for (int i = 1; i < int(unassigned_required_members.size()); i++) {
        required_string += std::string(", ") + unassigned_required_members[i];
      }
      return std::string(
                 "C++ struct/class has required members that are not present in the input JSON. The unassigned "
                 "C++ members are: "
             ) +
             required_string;
    }
    if (tokenizer.errorContext().error == Error::NoError && error != Error::NoError) {
      std::string retString("Error:");
      if (error <= Error::UserDefinedErrors) {
        retString += Internal::error_strings[int(error)];
      } else {
        retString += "Unknown error";
      }
      return retString;
    }
    return tokenizer.makeErrorString();
  }

  Tokenizer tokenizer;
  Token token;
  Error error = Error::NoError;
  std::vector<std::string> missing_members;
  std::vector<std::string> unassigned_required_members;
  bool allow_missing_members = true;
  bool allow_unasigned_required_members = true;
  bool track_member_assignement_state = true;
  void* user_data = nullptr;
};

/*! \def JS_MEMBER
 *
 * Create meta information of the member with the same name as
 * the member.
 */
/*! \def JS_MEMBER_ALIASES
 *
 * Create meta information where the primary name is the same as the member and
 * the subsequent names are aliases.
 */
/*! \def JS_MEMBER_WITH_NAME
 *
 * Create meta information where the primary name is argument name, and the subsequent
 * names are aliases.
 */
/*! \def JS_MEMBER_WITH_NAME_AND_ALIASES
 *
 * Creates meta information where the primary name is argument name, a
 * and subsequent names are aliases
 */

/*! \def JS_SUPER_CLASS
 *
 * Creates superclass meta data which is used inside the JS_SUPER_CLASSES macro
 */

/*! \def JS_SUPER_CLASSES
 *
 * Macro to contain the super class definitions
 */

namespace Internal {
template <typename T> struct HasJsonStructBase {
  typedef char yes[1];
  typedef char no[2];

  template <typename C> static constexpr yes& test_in_base(typename C::template JsonStructBase<C>*);

  template <typename> static constexpr no& test_in_base(...);
};

template <typename JS_BASE_STRUCT_T, typename JS_OBJECT_T> struct JsonStructBaseDummy {
  static_assert(
      sizeof(HasJsonStructBase<JS_OBJECT_T>::template test_in_base<JS_OBJECT_T>(nullptr)) ==
          sizeof(typename HasJsonStructBase<JS_OBJECT_T>::yes),
      "Missing JS_OBJECT JS_OBJECT_EXTERNAL or TypeHandler specialisation\n"
  );
  using TT = decltype(JS_OBJECT_T::template JsonStructBase<JS_OBJECT_T>::js_static_meta_data_info());
  using ST = decltype(JS_OBJECT_T::template JsonStructBase<JS_OBJECT_T>::js_static_meta_super_info());
  static inline constexpr const TT js_static_meta_data_info() {
    return JS_OBJECT_T::template JsonStructBase<JS_OBJECT_T>::js_static_meta_data_info();
  }

  static inline constexpr const ST js_static_meta_super_info() {
    return JS_OBJECT_T::template JsonStructBase<JS_OBJECT_T>::js_static_meta_super_info();
  }
};
} // namespace Internal

#define JS_INTERNAL_EXPAND(x) x
#define JS_INTERNAL_FIRST_(a, ...) a
#define JS_INTERNAL_SECOND_(a, b, ...) b
#define JS_INTERNAL_FIRST(...) JS_INTERNAL_EXPAND(JS_INTERNAL_FIRST_(__VA_ARGS__))
#define JS_INTERNAL_SECOND(...) JS_INTERNAL_EXPAND(JS_INTERNAL_SECOND_(__VA_ARGS__))
#define JS_INTERNAL_EMPTY()
#define JS_INTERNAL_EVAL(...) JS_INTERNAL_EVAL1024(__VA_ARGS__)
#define JS_INTERNAL_EVAL1024(...) JS_INTERNAL_EVAL512(JS_INTERNAL_EVAL512(__VA_ARGS__))
#define JS_INTERNAL_EVAL512(...) JS_INTERNAL_EVAL256(JS_INTERNAL_EVAL256(__VA_ARGS__))
#define JS_INTERNAL_EVAL256(...) JS_INTERNAL_EVAL128(JS_INTERNAL_EVAL128(__VA_ARGS__))
#define JS_INTERNAL_EVAL128(...) JS_INTERNAL_EVAL64(JS_INTERNAL_EVAL64(__VA_ARGS__))
#define JS_INTERNAL_EVAL64(...) JS_INTERNAL_EVAL32(JS_INTERNAL_EVAL32(__VA_ARGS__))
#define JS_INTERNAL_EVAL32(...) JS_INTERNAL_EVAL16(JS_INTERNAL_EVAL16(__VA_ARGS__))
#define JS_INTERNAL_EVAL16(...) JS_INTERNAL_EVAL8(JS_INTERNAL_EVAL8(__VA_ARGS__))
#define JS_INTERNAL_EVAL8(...) JS_INTERNAL_EVAL4(JS_INTERNAL_EVAL4(__VA_ARGS__))
#define JS_INTERNAL_EVAL4(...) JS_INTERNAL_EVAL2(JS_INTERNAL_EVAL2(__VA_ARGS__))
#define JS_INTERNAL_EVAL2(...) JS_INTERNAL_EVAL1(JS_INTERNAL_EVAL1(__VA_ARGS__))
#define JS_INTERNAL_EVAL1(...) __VA_ARGS__

#define JS_INTERNAL_DEFER1(m) m JS_INTERNAL_EMPTY()
#define JS_INTERNAL_DEFER2(m) m JS_INTERNAL_EMPTY JS_INTERNAL_EMPTY()()

#define JS_INTERNAL_IS_PROBE(...) JS_INTERNAL_SECOND(__VA_ARGS__, 0, 0)
#define JS_INTERNAL_PROBE() ~, 1

#define JS_INTERNAL_CAT(a, b) a##b

#define JS_INTERNAL_NOT(x) JS_INTERNAL_IS_PROBE(JS_INTERNAL_CAT(JS_INTERNAL__NOT_, x))
#define JS_INTERNAL__NOT_0 JS_INTERNAL_PROBE()

#define JS_INTERNAL_BOOL(x) JS_INTERNAL_NOT(JS_INTERNAL_NOT(x))

#define JS_INTERNAL_IF_ELSE(condition) JS_INTERNAL__IF_ELSE(JS_INTERNAL_BOOL(condition))
#define JS_INTERNAL__IF_ELSE(condition) JS_INTERNAL_CAT(JS_INTERNAL__IF_, condition)

#define JS_INTERNAL__IF_1(...) __VA_ARGS__ JS_INTERNAL__IF_1_ELSE
#define JS_INTERNAL__IF_0(...) JS_INTERNAL__IF_0_ELSE

#define JS_INTERNAL__IF_1_ELSE(...)
#define JS_INTERNAL__IF_0_ELSE(...) __VA_ARGS__

#define JS_INTERNAL_HAS_MORE_THAN_ONE_ARGS(...)                                                                        \
  JS_INTERNAL_BOOL(JS_INTERNAL_SECOND(JS_INTERNAL__END_OF_ARGUMENTS_ __VA_ARGS__, 0, 0)())
#define JS_INTERNAL__END_OF_ARGUMENTS_() 0

#define JS_MEMBER(member) JS::makeMemberInfo(#member, &JS_OBJECT_T::member)
#define JS_MEMBER_ALIASES(member, ...)                                                                                 \
  JS_INTERNAL_EXPAND(JS::makeMemberInfo(#member, &JS_OBJECT_T::member, __VA_ARGS__))
#define JS_MEMBER_WITH_NAME(member, name) JS::makeMemberInfo(name, &JS_OBJECT_T::member)
#define JS_MEMBER_WITH_NAME_AND_ALIASES(member, name, ...) JS::makeMemberInfo(name, &JS_OBJECT_T::member, __VA_ARGS__)

#define JS_SUPER_CLASS(super) JS::makeSuperInfo<super>(#super)

#define JS_SUPER_CLASSES(...) JS::makeTuple(__VA_ARGS__)
#define JS_INTERNAL__MAP_MEMBER() JS_INTERNAL_MAP_MEMBER

#define JS_INTERNAL_MAKE_MEMBERS(...)                                                                                  \
  JS_INTERNAL_IF_ELSE(JS_INTERNAL_HAS_MORE_THAN_ONE_ARGS(__VA_ARGS__))                                                 \
  (JS_INTERNAL_EXPAND(JS_INTERNAL_EVAL(JS_INTERNAL_MAP_MEMBER(JS::makeMemberInfo, __VA_ARGS__))))(                     \
      JS_INTERNAL_MAP_APPLY_MEMBER(JS::makeMemberInfo, __VA_ARGS__)                                                    \
  )

#define JS_INTERNAL_MAP_APPLY_MEMBER(m, first) m(#first, &JS_OBJECT_T::first)

#define JS_INTERNAL_MAP_MEMBER(m, first, ...)                                                                          \
  JS_INTERNAL_MAP_APPLY_MEMBER(m, first)                                                                               \
  JS_INTERNAL_IF_ELSE(JS_INTERNAL_HAS_MORE_THAN_ONE_ARGS(__VA_ARGS__))                                                 \
  (, JS_INTERNAL_DEFER2(JS_INTERNAL__MAP_MEMBER)()(m, __VA_ARGS__))(, JS_INTERNAL_MAP_APPLY_MEMBER(m, __VA_ARGS__))

#define JS_INTERNAL_MAP_APPLY_SUPER(m, first) m<first>(#first)

#define JS_INTERNAL_MAP_SUPER(m, first, ...)                                                                           \
  JS_INTERNAL_MAP_APPLY_SUPER(m, first)                                                                                \
  JS_INTERNAL_IF_ELSE(JS_INTERNAL_HAS_MORE_THAN_ONE_ARGS(__VA_ARGS__))                                                 \
  (, JS_INTERNAL_DEFER2(JS_INTERNAL__MAP_SUPER)()(m, __VA_ARGS__))(, JS_INTERNAL_MAP_APPLY_SUPER(m, __VA_ARGS__))

#define JS_INTERNAL__MAP_SUPER() JS_INTERNAL_MAP_SUPER

#define JS_INTERNAL_MAKE_SUPER_CLASSES(...)                                                                            \
  JS_INTERNAL_IF_ELSE(JS_INTERNAL_HAS_MORE_THAN_ONE_ARGS(__VA_ARGS__))                                                 \
  (JS_INTERNAL_EXPAND(JS_INTERNAL_EVAL(JS_INTERNAL_MAP_SUPER(JS::makeSuperInfo, __VA_ARGS__))))(                       \
      JS_INTERNAL_MAP_APPLY_SUPER(JS::makeSuperInfo, __VA_ARGS__)                                                      \
  )

#define JS_SUPER(...) JS::makeTuple(JS_INTERNAL_EXPAND(JS_INTERNAL_MAKE_SUPER_CLASSES(__VA_ARGS__)))

#define JS_OBJECT_INTERNAL_IMPL(super_list, member_list)                                                               \
  template <typename JS_OBJECT_T> struct JsonStructBase {                                                              \
    using TT = decltype(member_list);                                                                                  \
    static inline constexpr const TT js_static_meta_data_info() { return member_list; }                                \
    static inline constexpr const decltype(super_list) js_static_meta_super_info() { return super_list; }              \
  }

#define JS_OBJECT_EXTERNAL_INTERNAL_IMPL(Type, super_list, member_list)                                                \
  namespace JS {                                                                                                       \
  namespace Internal {                                                                                                 \
  template <typename JS_OBJECT_T> struct JsonStructBaseDummy<Type, JS_OBJECT_T> {                                      \
    using TT = decltype(member_list);                                                                                  \
    static constexpr const TT js_static_meta_data_info() { return member_list; }                                       \
    static constexpr const decltype(super_list) js_static_meta_super_info() { return super_list; }                     \
  };                                                                                                                   \
  }                                                                                                                    \
  }

#define JS_OBJECT(...) JS_OBJECT_INTERNAL_IMPL(JS::makeTuple(), JS::makeTuple(__VA_ARGS__))
#define JS_OBJECT_WITH_SUPER(super_list, ...) JS_OBJECT_INTERNAL_IMPL(super_list, JS::makeTuple(__VA_ARGS__))

#define JS_OBJECT_EXTERNAL(Type, ...)                                                                                  \
  JS_OBJECT_EXTERNAL_INTERNAL_IMPL(Type, JS::makeTuple(), JS::makeTuple(__VA_ARGS__))
#define JS_OBJECT_EXTERNAL_WITH_SUPER(Type, super_list, ...)                                                           \
  JS_OBJECT_EXTERNAL_INTERNAL_IMPL(Type, super_list, JS::makeTuple(__VA_ARGS__))

#define JS_OBJ(...) JS_OBJECT_INTERNAL_IMPL(JS::makeTuple(), JS::makeTuple(JS_INTERNAL_MAKE_MEMBERS(__VA_ARGS__)))
#define JS_OBJ_SUPER(super_list, ...)                                                                                  \
  JS_OBJECT_INTERNAL_IMPL(super_list, JS::makeTuple(JS_INTERNAL_MAKE_MEMBERS(__VA_ARGS__)))

#define JS_OBJ_EXT(Type, ...)                                                                                          \
  JS_OBJECT_EXTERNAL_INTERNAL_IMPL(Type, JS::makeTuple(), JS::makeTuple(JS_INTERNAL_MAKE_MEMBERS(__VA_ARGS__)))
#define JS_OBJ_EXT_SUPER(Type, super_list, ...)                                                                        \
  JS_OBJECT_EXTERNAL_INTERNAL_IMPL(Type, super_list, JS::makeTuple(JS_INTERNAL_MAKE_MEMBERS(__VA_ARGS__)))

/*!
 * \private
 */
template <typename T, typename U, typename NAMETUPLE> struct MI {
  NAMETUPLE names;
  T U::* member;
  typedef T type;
};

namespace Internal {
template <typename T, typename U, typename NAMETUPLE> using MemberInfo = MI<T, U, NAMETUPLE>;

template <typename T> struct SuperInfo {
  constexpr explicit SuperInfo() : name() {}
  constexpr explicit SuperInfo(const DataRef& name) : name(name) {}
  const DataRef name;
  typedef T type;
};
} // namespace Internal

template <typename T, typename U, size_t NAME_SIZE, typename... Aliases>
constexpr auto makeMemberInfo(
    const char (&name)[NAME_SIZE], T U::* member, Aliases&... aliases
) -> MI<T, U, decltype(makeTuple(JS::Internal::makeStringLiteral(name), JS::Internal::makeStringLiteral(aliases)...))> {
  return {makeTuple(JS::Internal::makeStringLiteral(name), JS::Internal::makeStringLiteral(aliases)...), member};
}

template <typename T, size_t NAME_SIZE>
constexpr const Internal::SuperInfo<T> makeSuperInfo(const char (&name)[NAME_SIZE]) {
  return Internal::SuperInfo<T>(DataRef(name));
}

template <typename T, typename Enable = void> struct TypeHandler {
  static inline Error to(T& to_type, ParseContext& context);
  static inline void from(const T& from_type, Token& token, Serializer& serializer);
};

namespace Internal {
template <size_t STRINGSIZE>
inline bool compareDataRefWithStringLiteral(const StringLiteral<STRINGSIZE>& memberName, const DataRef& jsonName) {
  return jsonName.size == STRINGSIZE && memcmp(memberName.data, jsonName.data, STRINGSIZE) == 0;
}

template <typename NameTuple, size_t index> struct NameChecker {
  static bool compare(const NameTuple& tuple, const DataRef& name) {

    JS_IF_CONSTEXPR(index != NameTuple::size) {
      auto& stringLiteral = tuple.template get<NameTuple::size - index>();
      if (compareDataRefWithStringLiteral(stringLiteral, name)) {
        return true;
      }
    }
    return NameChecker<NameTuple, index - 1>::compare(tuple, name);
  }
};
template <typename NameTuple> struct NameChecker<NameTuple, 0> {
  static bool compare(const NameTuple& tuple, const DataRef& name) {
    JS_UNUSED(tuple);
    JS_UNUSED(name);
    return false;
  }
};

template <typename T, typename MI_T, typename MI_M, typename MI_NC>
inline Error unpackMember(
    T& to_type, const MemberInfo<MI_T, MI_M, MI_NC>& memberInfo, ParseContext& context, size_t index, bool primary,
    bool* assigned_members
) {
  if (primary) {
    if (compareDataRefWithStringLiteral(memberInfo.names.template get<0>(), context.token.name)) {
      assigned_members[index] = true;
      return TypeHandler<MI_T>::to(to_type.*memberInfo.member, context);
    }
  } else {
    if (NameChecker<MI_NC, MI_NC::size>::compare(memberInfo.names, context.token.name)) {
      assigned_members[index] = true;
      return TypeHandler<MI_T>::to(to_type.*memberInfo.member, context);
    }
  }
  return Error::MissingPropertyMember;
}

template <typename MI_T, typename MI_M, typename MI_NC>
inline Error verifyMember(
    const MemberInfo<MI_T, MI_M, MI_NC>& memberInfo, size_t index, bool* assigned_members, bool track_missing_members,
    std::vector<std::string>& missing_members, const char* super_name
) {
  if (assigned_members[index]) {
    return Error::NoError;
  }
  if (IsOptionalType<MI_T>::value) {
    return Error::NoError;
  }

  if (track_missing_members) {
    std::string to_push = strlen(super_name) ? std::string(super_name) + "::" : std::string();
    to_push += std::string(memberInfo.names.template get<0>().data, memberInfo.names.template get<0>().size);
    missing_members.push_back(to_push);
  }
  return Error::UnassignedRequiredMember;
}

template <typename T, typename MI_T, typename MI_M, typename MI_NC>
inline void serializeMember(
    const T& from_type, const MemberInfo<MI_T, MI_M, MI_NC>& memberInfo, Token& token, Serializer& serializer,
    const char* super_name
) {
  JS_UNUSED(super_name);
  token.name.data = memberInfo.names.template get<0>().data;
  token.name.size = memberInfo.names.template get<0>().size;
  token.name_type = Type::Ascii;

  TypeHandler<MI_T>::from(from_type.*memberInfo.member, token, serializer);
}

template <typename T, size_t PAGE, size_t INDEX> struct SuperClassHandler {
  static Error handleSuperClasses(T& to_type, ParseContext& context, bool primary, bool* assigned_members);
  static Error verifyMembers(
      bool* assigned_members, bool track_missing_members, std::vector<std::string>& missing_members
  );
  static constexpr size_t membersInSuperClasses();
  static void serializeMembers(const T& from_type, Token& token, Serializer& serializer);
};

template <typename T, size_t PAGE, size_t SIZE> struct StartSuperRecursion {
  static Error start(T& to_type, ParseContext& context, bool primary, bool* assigned) {
    return SuperClassHandler<T, PAGE, SIZE - 1>::handleSuperClasses(to_type, context, primary, assigned);
  }

  static Error verifyMembers(
      bool* assigned_members, bool track_missing_members, std::vector<std::string>& missing_members
  ) {
    return SuperClassHandler<T, PAGE, SIZE - 1>::verifyMembers(
        assigned_members, track_missing_members, missing_members
    );
  }

  static constexpr size_t membersInSuperClasses() {
    return SuperClassHandler<T, PAGE, SIZE - 1>::membersInSuperClasses();
  }

  static void serializeMembers(const T& from_type, Token& token, Serializer& serializer) {
    return SuperClassHandler<T, PAGE, SIZE - 1>::serializeMembers(from_type, token, serializer);
  }
};

template <typename T, size_t PAGE> constexpr size_t memberCount() {
  using Members = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_data_info());
  using SuperMeta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
  return Members::size + StartSuperRecursion<T, PAGE + Members::size, SuperMeta::size>::membersInSuperClasses();
}

template <typename T, size_t PAGE> struct StartSuperRecursion<T, PAGE, 0> {
  static Error start(T& to_type, ParseContext& context, bool primary, bool* assigned) {
    JS_UNUSED(to_type);
    JS_UNUSED(context);
    JS_UNUSED(primary);
    JS_UNUSED(assigned);
    return Error::MissingPropertyMember;
  }

  static Error verifyMembers(
      bool* assigned_members, bool track_missing_members, std::vector<std::string>& missing_members
  ) {
    JS_UNUSED(assigned_members);
    JS_UNUSED(track_missing_members);
    JS_UNUSED(missing_members);
    return Error::NoError;
  }

  static constexpr size_t membersInSuperClasses() { return 0; }

  static void serializeMembers(const T& from_type, Token& token, Serializer& serializer) {
    JS_UNUSED(from_type);
    JS_UNUSED(token);
    JS_UNUSED(serializer);
  }
};

template <typename T, typename Members, size_t PAGE, size_t INDEX> struct MemberChecker {
  inline static Error unpackMembers(
      T& to_type, const Members& members, ParseContext& context, bool primary, bool* assigned_members
  ) {
    Error error =
        unpackMember(to_type, members.template get<INDEX>(), context, PAGE + INDEX, primary, assigned_members);
    if (error != Error::MissingPropertyMember) {
      return error;
    }

    return MemberChecker<T, Members, PAGE, INDEX - 1>::unpackMembers(
        to_type, members, context, primary, assigned_members
    );
  }

  inline static Error verifyMembers(
      const Members& members, bool* assigned_members, bool track_missing_members,
      std::vector<std::string>& missing_members, const char* super_name
  ) {
    Error memberError = verifyMember(
        members.template get<INDEX>(), PAGE + INDEX, assigned_members, track_missing_members, missing_members,
        super_name
    );
    Error error = MemberChecker<T, Members, PAGE, INDEX - 1>::verifyMembers(
        members, assigned_members, track_missing_members, missing_members, super_name
    );
    if (memberError != Error::NoError) {
      return memberError;
    }
    return error;
  }
  inline static void serializeMembers(
      const T& from_type, const Members& members, Token& token, Serializer& serializer, const char* super_name
  ) {
    serializeMember(from_type, members.template get<Members::size - INDEX - 1>(), token, serializer, super_name);
    MemberChecker<T, Members, PAGE, INDEX - 1>::serializeMembers(from_type, members, token, serializer, super_name);
  }
};

template <typename T, typename Members, size_t PAGE> struct MemberChecker<T, Members, PAGE, 0> {
  inline static Error unpackMembers(
      T& to_type, const Members& members, ParseContext& context, bool primary, bool* assigned_members
  ) {
    Error error = unpackMember(to_type, members.template get<0>(), context, PAGE, primary, assigned_members);
    if (error != Error::MissingPropertyMember) {
      return error;
    }

    using Super = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
    return StartSuperRecursion<T, PAGE + Members::size, Super::size>::start(
        to_type, context, primary, assigned_members
    );
  }

  inline static Error verifyMembers(
      const Members& members, bool* assigned_members, bool track_missing_members,
      std::vector<std::string>& missing_members, const char* super_name
  ) {
    Error memberError = verifyMember(
        members.template get<0>(), PAGE, assigned_members, track_missing_members, missing_members, super_name
    );
    using Super = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
    Error superError = StartSuperRecursion<T, PAGE + Members::size, Super::size>::verifyMembers(
        assigned_members, track_missing_members, missing_members
    );
    if (memberError !=
        Error::NoError) { //-V1051 memberError is correct, but we have to allways call supers verifyMembers first
      return memberError;
    }
    return superError;
  }

  inline static void serializeMembers(
      const T& from_type, const Members& members, Token& token, Serializer& serializer, const char* super_name
  ) {
    serializeMember(from_type, members.template get<Members::size - 1>(), token, serializer, super_name);
    using Super = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
    StartSuperRecursion<T, PAGE + Members::size, Super::size>::serializeMembers(from_type, token, serializer);
  }
};

template <typename T, size_t PAGE, size_t INDEX>
Error SuperClassHandler<T, PAGE, INDEX>::handleSuperClasses(
    T& to_type, ParseContext& context, bool primary, bool* assigned_members
) {
  using SuperMeta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
  using Super = typename JS::TypeAt<INDEX, SuperMeta>::type::type;
  using Members = decltype(Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info());
  auto members = Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info();
  Error error = MemberChecker<Super, Members, PAGE, Members::size - 1>::unpackMembers(
      static_cast<Super&>(to_type), members, context, primary, assigned_members
  );
  if (error != Error::MissingPropertyMember) {
    return error;
  }
  return SuperClassHandler<T, PAGE + memberCount<Super, 0>(), INDEX - 1>::handleSuperClasses(
      to_type, context, primary, assigned_members
  );
}

template <typename T, size_t PAGE, size_t INDEX>
Error SuperClassHandler<T, PAGE, INDEX>::verifyMembers(
    bool* assigned_members, bool track_missing_members, std::vector<std::string>& missing_members
) {
  using SuperMeta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
  using Super = typename TypeAt<INDEX, SuperMeta>::type::type;
  using Members = decltype(Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info());
  auto members = Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info();
  const char* super_name =
      Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info().template get<INDEX>().name.data;
  Error error = MemberChecker<Super, Members, PAGE, Members::size - 1>::verifyMembers(
      members, assigned_members, track_missing_members, missing_members, super_name
  );
  Error superError = SuperClassHandler<T, PAGE + memberCount<Super, 0>(), INDEX - 1>::verifyMembers(
      assigned_members, track_missing_members, missing_members
  );
  if (error != Error::NoError) {
    return error;
  }
  return superError;
}

template <typename T, size_t PAGE, size_t INDEX>
size_t constexpr SuperClassHandler<T, PAGE, INDEX>::membersInSuperClasses() {
  using SuperMeta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
  using Super = typename TypeAt<INDEX, SuperMeta>::type::type;
  return memberCount<Super, PAGE>() +
         SuperClassHandler<T, PAGE + memberCount<Super, PAGE>(), INDEX - 1>::membersInSuperClasses();
}

template <typename T, size_t PAGE, size_t INDEX>
void SuperClassHandler<T, PAGE, INDEX>::serializeMembers(const T& from_type, Token& token, Serializer& serializer) {
  using SuperMeta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
  using Super = typename TypeAt<INDEX, SuperMeta>::type::type;
  using Members = decltype(Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info());
  auto members = Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info();
  MemberChecker<Super, Members, PAGE, Members::size - 1>::serializeMembers(from_type, members, token, serializer, "");
  SuperClassHandler<T, PAGE + memberCount<Super, 0>(), INDEX - 1>::serializeMembers(from_type, token, serializer);
}

template <typename T, size_t PAGE> struct SuperClassHandler<T, PAGE, 0> {
  static Error handleSuperClasses(T& to_type, ParseContext& context, bool primary, bool* assigned_members) {
    using Meta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
    using Super = typename TypeAt<0, Meta>::type::type;
    using Members = decltype(Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info());
    auto members = Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info();
    return MemberChecker<Super, Members, PAGE, Members::size - 1>::unpackMembers(
        static_cast<Super&>(to_type), members, context, primary, assigned_members
    );
  }
  static Error verifyMembers(
      bool* assigned_members, bool track_missing_members, std::vector<std::string>& missing_members
  ) {
    using SuperMeta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
    using Super = typename TypeAt<0, SuperMeta>::type::type;
    using Members = decltype(Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info());
    auto members = Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info();
    const char* super_name =
        Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info().template get<0>().name.data;
    return MemberChecker<Super, Members, PAGE, Members::size - 1>::verifyMembers(
        members, assigned_members, track_missing_members, missing_members, super_name
    );
  }
  constexpr static size_t membersInSuperClasses() {
    using SuperMeta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
    using Super = typename TypeAt<0, SuperMeta>::type::type;
    return memberCount<Super, PAGE>();
  }
  static void serializeMembers(const T& from_type, Token& token, Serializer& serializer) {
    using SuperMeta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
    using Super = typename TypeAt<0, SuperMeta>::type::type;
    using Members = decltype(Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info());
    auto members = Internal::JsonStructBaseDummy<Super, Super>::js_static_meta_data_info();
    MemberChecker<Super, Members, PAGE, Members::size - 1>::serializeMembers(from_type, members, token, serializer, "");
  }
};

static bool skipArrayOrObject(ParseContext& context) {
  assert(context.error == Error::NoError);
  Type start_type = context.token.value_type;
  Type end_type;
  if (context.token.value_type == Type::ObjectStart) {
    end_type = Type::ObjectEnd;
  } else if (context.token.value_type == Type::ArrayStart) {
    end_type = Type::ArrayEnd;
  } else {
    return false;
  }

  int depth = 1;
  while (depth > 0) {
    context.nextToken();
    if (context.error != Error::NoError) {
      return false;
    }
    if (context.token.value_type == start_type) {
      depth++;
    } else if (context.token.value_type == end_type) {
      depth--;
    }
  }

  return context.token.value_type == end_type && context.error == Error::NoError;
}
} // namespace Internal

template <typename T> JS_NODISCARD inline Error ParseContext::parseTo(T& to_type) {
  missing_members.reserve(10);
  unassigned_required_members.reserve(10);
  error = tokenizer.nextToken(token);
  if (error != JS::Error::NoError) {
    return error;
  }
  error = TypeHandler<T>::to(to_type, *this);
  if (error != JS::Error::NoError && tokenizer.errorContext().error == JS::Error::NoError) {
    tokenizer.updateErrorContext(error);
  }
  return error;
}

struct SerializerContext {
  SerializerContext(std::string& json_out_p) : serializer(), json_out(json_out_p), last_pos(0) {
    if (json_out.empty()) {
      json_out.resize(4096);
    }
    serializer.setBuffer(&json_out[0], json_out.size());
    serializer.setRequestBufferCallback([this](Serializer& serializer_p) {
      size_t end = this->json_out.size();
      this->json_out.resize(end * 2);
      serializer_p.setBuffer(&(this->json_out[0]) + end, end);
      this->last_pos = end;
    });
  }

  ~SerializerContext() { flush(); }

  template <typename T> void serialize(const T& type) {
    JS::Token token;
    JS::TypeHandler<T>::from(type, token, serializer);
    flush();
  }

  void flush() { json_out.resize(last_pos + serializer.currentBuffer().used); }

  Serializer serializer;
  std::string& json_out;
  size_t last_pos;
};

template <typename T> JS_NODISCARD std::string serializeStruct(const T& from_type) {
  std::string ret_string;
  SerializerContext serializeContext(ret_string);
  Token token;
  TypeHandler<T>::from(from_type, token, serializeContext.serializer);
  serializeContext.flush();
  return ret_string;
}

template <typename T> JS_NODISCARD std::string serializeStruct(const T& from_type, const SerializerOptions& options) {
  std::string ret_string;
  SerializerContext serializeContext(ret_string);
  serializeContext.serializer.setOptions(options);
  Token token;
  TypeHandler<T>::from(from_type, token, serializeContext.serializer);
  serializeContext.flush();
  return ret_string;
}

template <> struct TypeHandler<Error> {
  static inline Error to(Error& to_type, ParseContext& context) {
    (void) to_type;
    (void) context;
    //		if (context.token.value_type == JS::Type::Number) {
    //			int x;
    //			Error error = TypeHandler<int>::to(x, context);
    //			for (int i = 0; i < )
    //		}

    //        size_t level = 1;
    //        Error error = Error::NoError;
    //        while (error == JS::Error::NoError && level) {
    //            error = context.nextToken();
    //            if (context.token.value_type == Type::ObjectStart)
    //                level++;
    //            else if (context.token.value_type == Type::ObjectEnd)
    //                level--;
    //        }

    //        context.tokenizer.copyIncludingValue(context.token, to_type.data);

    return Error::NoError;
  }

  static inline void from(const Error& from_type, Token& token, Serializer& serializer) {
    token.value_type = JS::Type::String;
    if (from_type < JS::Error::UserDefinedErrors) {
      token.value = DataRef(Internal::error_strings[(int) from_type]);
    } else {
      token.value = DataRef("UserDefinedError");
    }
    serializer.write(token);
  }
};

struct CallFunctionExecutionState {
  explicit CallFunctionExecutionState(const std::string& name) : name(name), error(Error::NoError) {}
  std::string name;
  SilentString context;
  Error error;
  SilentString error_string;
  SilentVector<std::string> missing_members;
  SilentVector<std::string> unassigned_required_members;
  SilentVector<CallFunctionExecutionState> child_states;
  JS_OBJECT(
      JS_MEMBER(name), JS_MEMBER(context), JS_MEMBER(error), JS_MEMBER(error_string), JS_MEMBER(missing_members),
      JS_MEMBER(unassigned_required_members), JS_MEMBER(child_states)
  );
};

struct CallFunctionContext;

struct CallFunctionErrorContext {
  CallFunctionErrorContext(CallFunctionContext& context) : context(context) {}

  Error setError(Error error, const std::string& error_string);
  Error setError(const std::string& error_string) { return setError(Error::UserDefinedErrors, error_string); }
  Error getLatestError() const;

private:
  CallFunctionContext& context;
};

struct CallFunctionContext {
  CallFunctionContext(ParseContext& parser_context, Serializer& return_serializer)
      : parse_context(parser_context), return_serializer(return_serializer), error_context(*this) {}

  virtual ~CallFunctionContext() {}
  template <typename T> Error callFunctions(T& container);

  ParseContext& parse_context;
  Serializer& return_serializer;
  CallFunctionErrorContext error_context;
  std::vector<CallFunctionExecutionState> execution_list;
  std::string user_context;
  bool allow_missing = false;
  bool stop_execute_on_fail = false;
  void* user_handle = nullptr;

protected:
  virtual void beforeCallFunctions() {}
  virtual void afterCallFunctions() {}
};

inline Error CallFunctionErrorContext::setError(Error error, const std::string& errorString) {
  context.parse_context.error = error;
  if (context.execution_list.size()) {
    context.execution_list.back().error = error;
    context.execution_list.back().error_string.data = context.parse_context.tokenizer.makeErrorString();
  }
  context.parse_context.tokenizer.updateErrorContext(error, errorString);
  return error;
}

inline Error CallFunctionErrorContext::getLatestError() const { return context.parse_context.error; }

template <typename T, typename Ret, typename Arg, size_t NAME_COUNT, size_t TAKES_CONTEXT> struct FunctionInfo {
  typedef Ret (T::*Function)(Arg);
  typedef Ret returnType;
  DataRef name[NAME_COUNT];
  Function function;
};

/// \private
template <typename T, typename Ret, typename Arg, size_t NAME_COUNT> struct FunctionInfo<T, Ret, Arg, NAME_COUNT, 1> {
  typedef Ret (T::*Function)(Arg, CallFunctionErrorContext&);
  typedef Ret returnType;
  DataRef name[NAME_COUNT];
  Function function;
};

/// \private
template <typename T, typename Ret, typename Arg, size_t NAME_COUNT> struct FunctionInfo<T, Ret, Arg, NAME_COUNT, 2> {
  typedef Ret (T::*Function)(Arg, CallFunctionContext&);
  typedef Ret returnType;
  DataRef name[NAME_COUNT];
  Function function;
};

/// \private
template <typename T, typename Ret, size_t NAME_COUNT, size_t TAKES_CONTEXT>
struct FunctionInfo<T, Ret, void, NAME_COUNT, TAKES_CONTEXT> {
  typedef Ret (T::*Function)(void);
  typedef Ret returnType;
  DataRef name[NAME_COUNT];
  Function function;
};

/// \private
template <typename T, typename Ret, size_t NAME_COUNT> struct FunctionInfo<T, Ret, void, NAME_COUNT, 1> {
  typedef Ret (T::*Function)(CallFunctionErrorContext&);
  typedef Ret returnType;
  DataRef name[NAME_COUNT];
  Function function;
};

/// \private
template <typename T, typename Ret, size_t NAME_COUNT> struct FunctionInfo<T, Ret, void, NAME_COUNT, 2> {
  typedef Ret (T::*Function)(CallFunctionContext&);
  typedef Ret returnType;
  DataRef name[NAME_COUNT];
  Function function;
};

/// \private
template <typename T, typename Ret, typename Arg, size_t NAME_SIZE, typename... Aliases>
constexpr FunctionInfo<T, Ret, Arg, sizeof...(Aliases) + 1, 0> makeFunctionInfo(
    const char (&name)[NAME_SIZE], Ret (T::*function)(Arg), Aliases... aliases
) {
  return {{DataRef(name), DataRef(aliases)...}, function};
}

/// \private
template <typename T, typename Ret, typename Arg, size_t NAME_SIZE, typename... Aliases>
constexpr FunctionInfo<T, Ret, Arg, sizeof...(Aliases) + 1, 1> makeFunctionInfo(
    const char (&name)[NAME_SIZE], Ret (T::*function)(Arg, CallFunctionErrorContext&), Aliases... aliases
) {
  return {{DataRef(name), DataRef(aliases)...}, function};
}

/// \private
template <typename T, typename Ret, typename Arg, size_t NAME_SIZE, typename... Aliases>
constexpr FunctionInfo<T, Ret, Arg, sizeof...(Aliases) + 1, 2> makeFunctionInfo(
    const char (&name)[NAME_SIZE], Ret (T::*function)(Arg, CallFunctionContext&), Aliases... aliases
) {
  return {{DataRef(name), DataRef(aliases)...}, function};
}

/// \private
template <typename T, typename Ret, size_t NAME_SIZE, typename... Aliases>
constexpr FunctionInfo<T, Ret, void, sizeof...(Aliases) + 1, 0> makeFunctionInfo(
    const char (&name)[NAME_SIZE], Ret (T::*function)(void), Aliases... aliases
) {
  return {{DataRef(name), DataRef(aliases)...}, function};
}

/// \private
template <typename T, typename Ret, size_t NAME_SIZE, typename... Aliases>
constexpr FunctionInfo<T, Ret, void, sizeof...(Aliases) + 1, 1> makeFunctionInfo(
    const char (&name)[NAME_SIZE], Ret (T::*function)(CallFunctionErrorContext&), Aliases... aliases
) {
  return {{DataRef(name), DataRef(aliases)...}, function};
}

/// \private
template <typename T, typename Ret, size_t NAME_SIZE, typename... Aliases>
constexpr FunctionInfo<T, Ret, void, sizeof...(Aliases) + 1, 2> makeFunctionInfo(
    const char (&name)[NAME_SIZE], Ret (T::*function)(CallFunctionContext&), Aliases... aliases
) {
  return {{DataRef(name), DataRef(aliases)...}, function};
}

namespace Internal {
template <typename T> struct HasJsonStructFunctionContainer {
  typedef char yes[1];
  typedef char no[2];

  template <typename C> static constexpr yes& test_in_base(typename C::template JsonStructFunctionContainer<C>*);

  template <typename> static constexpr no& test_in_base(...);
};

template <typename JS_BASE_CONTAINER_STRUCT_T, typename JS_CONTAINER_STRUCT_T> struct JsonStructFunctionContainerDummy {
  using TT = decltype(JS_CONTAINER_STRUCT_T::template JsonStructFunctionContainer<
                      JS_CONTAINER_STRUCT_T>::js_static_meta_functions_info());
  using ST = decltype(JS_CONTAINER_STRUCT_T::template JsonStructFunctionContainer<
                      JS_CONTAINER_STRUCT_T>::js_static_meta_super_info());
  static const TT& js_static_meta_functions_info() {
    return JS_CONTAINER_STRUCT_T::template JsonStructFunctionContainer<
        JS_CONTAINER_STRUCT_T>::js_static_meta_functions_info();
  }

  static const ST js_static_meta_super_info() {
    return JS_CONTAINER_STRUCT_T::template JsonStructFunctionContainer<
        JS_CONTAINER_STRUCT_T>::js_static_meta_super_info();
  }
};

} // namespace Internal

#define JS_FUNCTION(name) JS::makeFunctionInfo(#name, &JS_CONTAINER_STRUCT_T::name)
#define JS_FUNCTION_ALIASES(name, ...) JS::makeFunctionInfo(#name, &JS_CONTAINER_STRUCT_T::name, __VA_ARGS__)
#define JS_FUNCTION_WITH_NAME(member, name) JS::makeFunctionInfo(name, &JS_CONTAINER_STRUCT_T::member)
#define JS_FUNCTION_WITH_NAME_ALIASES(member, name, ...)                                                               \
  JS::makeFunctionInfo(name, &JS_CONTAINER_STRUCT_T::member, __VA_ARGS__)

#define JS_INTERNAL_MAP_APPLY_FUNCTION(m, first) m(#first, &JS_CONTAINER_STRUCT_T::first)

#define JS_INTERNAL_MAP_FUNCTION(m, first, ...)                                                                        \
  JS_INTERNAL_MAP_APPLY_FUNCTION(m, first)                                                                             \
  JS_INTERNAL_IF_ELSE(JS_INTERNAL_HAS_MORE_THAN_ONE_ARGS(__VA_ARGS__))                                                 \
  (, JS_INTERNAL_DEFER2(JS_INTERNAL__MAP_FUNCTION)()(m, __VA_ARGS__))(, JS_INTERNAL_MAP_APPLY_FUNCTION(m, __VA_ARGS__))

#define JS_INTERNAL__MAP_FUNCTION() JS_INTERNAL_MAP_FUNCTION

#define JS_INTERNAL_MAKE_FUNCTIONS(...)                                                                                \
  JS_INTERNAL_IF_ELSE(JS_INTERNAL_HAS_MORE_THAN_ONE_ARGS(__VA_ARGS__))                                                 \
  (JS_INTERNAL_EXPAND(JS_INTERNAL_EVAL(JS_INTERNAL_MAP_FUNCTION(JS::makeFunctionInfo, __VA_ARGS__))))(                 \
      JS_INTERNAL_MAP_APPLY_FUNCTION(JS::makeFunctionInfo, __VA_ARGS__)                                                \
  )

#define JS_FUNCTION_CONTAINER_INTERNAL_IMPL(super_list, function_list)                                                 \
  template <typename JS_CONTAINER_STRUCT_T> struct JsonStructFunctionContainer {                                       \
    using TT = decltype(function_list);                                                                                \
    static const TT& js_static_meta_functions_info() {                                                                 \
      static auto ret = function_list;                                                                                 \
      return ret;                                                                                                      \
    }                                                                                                                  \
    static const decltype(super_list) js_static_meta_super_info() { return super_list; }                               \
  }

#define JS_FUNCTION_CONTAINER_EXTERNAL_INTERNAL_IMPL(Type, super_list, function_list)                                  \
  namespace JS {                                                                                                       \
  namespace Internal {                                                                                                 \
  template <typename JS_CONTAINER_STRUCT_T> struct JsonStructFunctionContainerDummy<Type, JS_CONTAINER_STRUCT_T> {     \
    using TT = decltype(function_list);                                                                                \
    static const TT& js_static_meta_functions_info() {                                                                 \
      static auto ret = function_list;                                                                                 \
      return ret;                                                                                                      \
    }                                                                                                                  \
    static const decltype(super_list) js_static_meta_super_info() { return super_list; }                               \
  };                                                                                                                   \
  }                                                                                                                    \
  }

#define JS_FUNC_OBJ(...)                                                                                               \
  JS_FUNCTION_CONTAINER_INTERNAL_IMPL(JS::makeTuple(), JS::makeTuple(JS_INTERNAL_MAKE_FUNCTIONS(__VA_ARGS__)))
#define JS_FUNCTION_CONTAINER(...) JS_FUNCTION_CONTAINER_INTERNAL_IMPL(JS::makeTuple(), JS::makeTuple(__VA_ARGS__))
#define JS_FUNC_OBJ_SUPER(super_list, ...)                                                                             \
  JS_FUNCTION_CONTAINER_INTERNAL_IMPL(super_list, JS::makeTuple(JS_INTERNAL_MAKE_FUNCTIONS(__VA_ARGS__)))
#define JS_FUNCTION_CONTAINER_WITH_SUPER(super_list, ...)                                                              \
  JS_FUNCTION_CONTAINER_INTERNAL_IMPL(super_list, JS::makeTuple(__VA_ARGS__))
#define JS_FUNCTION_CONTAINER_WITH_SUPER_WITHOUT_MEMBERS(super_list)                                                   \
  JS_FUNCTION_CONTAINER_INTERNAL_IMPL(super_list, JS::makeTuple())

#define JS_FUNC_OBJ_EXTERNAL(Type, ...)                                                                                \
  JS_FUNCTION_CONTAINER_EXTERNAL_INTERNAL_IMPL(                                                                        \
      Type, JS::makeTuple(), JS::makeTuple(JS_INTERNAL_MAKE_FUNCTIONS(__VA_ARGS__))                                    \
  )
#define JS_FUNCTION_CONTAINER_EXTERNAL(Type, ...)                                                                      \
  JS_FUNCTION_CONTAINER_EXTERNAL_INTERNAL_IMPL(Type, JS::makeTuple(), JS::makeTuple(__VA_ARGS__))
#define JS_FUNC_OBJ_EXTERNAL_SUPER(Type, super_list, ...)                                                              \
  JS_FUNCTION_CONTAINER_EXTERNAL_INTERNAL_IMPL(Type, super_list, JS::makeTuple(JS_INTERNAL_MAKE_FUNCTIONS(__VA_ARGS__)))
#define JS_FUNCTION_CONTAINER_EXTERNAL_WITH_SUPER(Type, super_list, ...)                                               \
  JS_FUNCTION_CONTAINER_EXTERNAL_INTERNAL_IMPL(Type, super_list, JS::makeTuple(__VA_ARGS__))

#define JS_FUNCTION_CONTAINER_EXTERNAL_WITH_SUPER_WITHOUT_MEMBERS(Type, super_list)                                    \
  JS_FUNCTION_CONTAINER_EXTERNAL_INTERNAL_IMPL(Type, super_list, JS::makeTuple())

#if !defined(__clang__) && defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Warray-bounds"
#pragma GCC diagnostic ignored "-Wstringop-overflow"
#endif

namespace Internal {
template <typename T, typename U, typename Ret, typename Arg, size_t NAME_COUNT, size_t TAKES_CONTEXT>
struct FunctionCaller {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, Ret, Arg, NAME_COUNT, TAKES_CONTEXT>& functionInfo, CallFunctionContext& context
  ) {
    typedef typename std::remove_reference<Arg>::type NonRefArg;
    typedef typename std::remove_cv<NonRefArg>::type PureArg;
    PureArg arg;
    context.parse_context.error = TypeHandler<PureArg>::to(arg, context.parse_context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    Token token;
    TypeHandler<Ret>::from((container.*functionInfo.function)(arg), token, context.return_serializer);
    return Error::NoError;
  }
};

template <typename T, typename U, typename Ret, typename Arg, size_t NAME_COUNT>
struct FunctionCaller<T, U, Ret, Arg, NAME_COUNT, 1> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, Ret, Arg, NAME_COUNT, 1>& functionInfo, CallFunctionContext& context
  ) {
    typedef typename std::remove_reference<Arg>::type NonRefArg;
    typedef typename std::remove_cv<NonRefArg>::type PureArg;
    PureArg arg;
    context.parse_context.error = TypeHandler<PureArg>::to(arg, context.parse_context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    Token token;
    Ret ret = (container.*functionInfo.function)(arg, context.error_context);
    if (context.execution_list.back().error == Error::NoError) {
      TypeHandler<Ret>::from(ret, token, context.return_serializer);
    }
    return context.execution_list.back().error;
  }
};

template <typename T, typename U, typename Ret, typename Arg, size_t NAME_COUNT>
struct FunctionCaller<T, U, Ret, Arg, NAME_COUNT, 2> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, Ret, Arg, NAME_COUNT, 2>& functionInfo, CallFunctionContext& context
  ) {
    typedef typename std::remove_reference<Arg>::type NonRefArg;
    typedef typename std::remove_cv<NonRefArg>::type PureArg;
    PureArg arg;
    context.parse_context.error = TypeHandler<PureArg>::to(arg, context.parse_context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    Token token;
    Ret ret = (container.*functionInfo.function)(arg, context);
    if (context.execution_list.back().error == Error::NoError) {
      TypeHandler<Ret>::from(ret, token, context.return_serializer);
    }
    return context.execution_list.back().error;
  }
};

template <typename T, typename U, typename Arg, size_t NAME_COUNT, size_t TAKES_CONTEXT>
struct FunctionCaller<T, U, void, Arg, NAME_COUNT, TAKES_CONTEXT> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, void, Arg, NAME_COUNT, TAKES_CONTEXT>& functionInfo, CallFunctionContext& context
  ) {
    typedef typename std::remove_reference<Arg>::type NonRefArg;
    typedef typename std::remove_cv<NonRefArg>::type PureArg;
    PureArg arg;
    context.parse_context.error = TypeHandler<PureArg>::to(arg, context.parse_context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    (container.*functionInfo.function)(arg);
    return Error::NoError;
  }
};

template <typename T, typename U, typename Arg, size_t NAME_COUNT>
struct FunctionCaller<T, U, void, Arg, NAME_COUNT, 1> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, void, Arg, NAME_COUNT, 1>& functionInfo, CallFunctionContext& context
  ) {
    typedef typename std::remove_reference<Arg>::type NonRefArg;
    typedef typename std::remove_cv<NonRefArg>::type PureArg;
    PureArg arg;
    context.parse_context.error = TypeHandler<PureArg>::to(arg, context.parse_context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    (container.*functionInfo.function)(arg, context.error_context);
    return context.execution_list.back().error;
  }
};

template <typename T, typename U, typename Arg, size_t NAME_COUNT>
struct FunctionCaller<T, U, void, Arg, NAME_COUNT, 2> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, void, Arg, NAME_COUNT, 2>& functionInfo, CallFunctionContext& context
  ) {
    typedef typename std::remove_reference<Arg>::type NonRefArg;
    typedef typename std::remove_cv<NonRefArg>::type PureArg;
    PureArg arg;
    context.parse_context.error = TypeHandler<PureArg>::to(arg, context.parse_context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    (container.*functionInfo.function)(arg, context);
    return context.execution_list.back().error;
  }
};

static inline void checkValidVoidParameter(CallFunctionContext& context) {
  if (context.parse_context.token.value_type != Type::Null &&
      context.parse_context.token.value_type != Type::ArrayStart &&
      context.parse_context.token.value_type != Type::ObjectStart &&
      context.parse_context.token.value_type != Type::Bool) {
    // what to do
    fprintf(stderr, "Passing data arguments to a void function\n");
  }
  skipArrayOrObject(context.parse_context);
}

template <typename T, typename U, typename Ret, size_t NAME_COUNT, size_t TAKES_CONTEXT>
struct FunctionCaller<T, U, Ret, void, NAME_COUNT, TAKES_CONTEXT> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, Ret, void, NAME_COUNT, TAKES_CONTEXT>& functionInfo, CallFunctionContext& context
  ) {
    checkValidVoidParameter(context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }
    Token token;
    TypeHandler<Ret>::from((container.*functionInfo.function)(), token, context.return_serializer);
    return Error::NoError;
  }
};

template <typename T, typename U, typename Ret, size_t NAME_COUNT>
struct FunctionCaller<T, U, Ret, void, NAME_COUNT, 1> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, Ret, void, NAME_COUNT, 1>& functionInfo, CallFunctionContext& context
  ) {
    checkValidVoidParameter(context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    Token token;
    Ret ret = (container.*functionInfo.function)(context.error_context);
    if (context.execution_list.back().error == Error::NoError) {
      TypeHandler<Ret>::from(ret, token, context.return_serializer);
    }
    return context.execution_list.back().error;
  }
};

template <typename T, typename U, typename Ret, size_t NAME_COUNT>
struct FunctionCaller<T, U, Ret, void, NAME_COUNT, 2> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, Ret, void, NAME_COUNT, 2>& functionInfo, CallFunctionContext& context
  ) {
    checkValidVoidParameter(context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    Token token;
    Ret ret = (container.*functionInfo.function)(context);
    if (context.execution_list.back().error == Error::NoError) {
      TypeHandler<Ret>::from(ret, token, context.return_serializer);
    }
    return context.execution_list.back().error;
  }
};

template <typename T, typename U, size_t NAME_COUNT, size_t TAKES_CONTEXT>
struct FunctionCaller<T, U, void, void, NAME_COUNT, TAKES_CONTEXT> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, void, void, NAME_COUNT, TAKES_CONTEXT>& functionInfo, CallFunctionContext& context
  ) {
    checkValidVoidParameter(context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    (container.*functionInfo.function)();
    return Error::NoError;
  }
};

template <typename T, typename U, size_t NAME_COUNT> struct FunctionCaller<T, U, void, void, NAME_COUNT, 1> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, void, void, NAME_COUNT, 1>& functionInfo, CallFunctionContext& context
  ) {
    checkValidVoidParameter(context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    (container.*functionInfo.function)(context.error_context);
    return context.execution_list.back().error;
  }
};

template <typename T, typename U, size_t NAME_COUNT> struct FunctionCaller<T, U, void, void, NAME_COUNT, 2> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, void, void, NAME_COUNT, 2>& functionInfo, CallFunctionContext& context
  ) {
    checkValidVoidParameter(context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    (container.*functionInfo.function)(context);
    return context.execution_list.back().error;
  }
};
} // namespace Internal

#if !defined(__clang__) && defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

template <typename T, typename U, typename Ret, typename Arg, size_t NAME_COUNT, size_t TAKES_CONTEXT>
Error matchAndCallFunction(
    T& container, CallFunctionContext& context, FunctionInfo<U, Ret, Arg, NAME_COUNT, TAKES_CONTEXT>& functionInfo,
    bool primary
) {
  if (primary && context.parse_context.token.name.size == functionInfo.name[0].size &&
      memcmp(functionInfo.name[0].data, context.parse_context.token.name.data, functionInfo.name[0].size) == 0) {
    return Internal::FunctionCaller<T, U, Ret, Arg, NAME_COUNT, TAKES_CONTEXT>::callFunctionAndSerializeReturn(
        container, functionInfo, context
    );
  } else if (!primary) {
    for (size_t i = 1; i < NAME_COUNT; i++) {
      if (context.parse_context.token.name.size == functionInfo.name[i].size &&
          memcmp(functionInfo.name[i].data, context.parse_context.token.name.data, functionInfo.name[i].size) == 0) {
        return Internal::FunctionCaller<T, U, Ret, Arg, NAME_COUNT, TAKES_CONTEXT>::callFunctionAndSerializeReturn(
            container, functionInfo, context
        );
      }
    }
  }
  return Error::MissingFunction;
}

namespace Internal {
template <typename T, size_t INDEX> struct FunctionalSuperRecursion {
  static Error callFunction(T& container, CallFunctionContext& context, bool primary);
};

template <typename T, size_t SIZE> struct StartFunctionalSuperRecursion {
  static Error callFunction(T& container, CallFunctionContext& context, bool primary) {
    return FunctionalSuperRecursion<T, SIZE - 1>::callFunction(container, context, primary);
  }
};
template <typename T> struct StartFunctionalSuperRecursion<T, 0> {
  static Error callFunction(T& container, CallFunctionContext& context, bool primary) {
    JS_UNUSED(container);
    JS_UNUSED(context);
    JS_UNUSED(primary);
    return Error::MissingFunction;
  }
};

template <typename T, typename Functions, size_t INDEX> struct FunctionObjectTraverser {
  static Error call(T& container, CallFunctionContext& context, Functions& functions, bool primary) {
    auto function = functions.template get<INDEX>();
    Error error = matchAndCallFunction(container, context, function, primary);
    if (error == Error::NoError) {
      return Error::NoError;
    }
    if (error != Error::MissingFunction) {
      return context.parse_context.error;
    }
    return FunctionObjectTraverser<T, Functions, INDEX - 1>::call(container, context, functions, primary);
  }
};

template <typename T, typename Functions> struct FunctionObjectTraverser<T, Functions, 0> {
  static Error call(T& container, CallFunctionContext& context, Functions& functions, bool primary) {
    auto function = functions.template get<0>();
    Error error = matchAndCallFunction(container, context, function, primary);
    if (error == Error::NoError) {
      return Error::NoError;
    }
    if (error != Error::MissingFunction) {
      return error;
    }
    using SuperMeta = decltype(Internal::template JsonStructFunctionContainerDummy<T, T>::js_static_meta_super_info());
    return StartFunctionalSuperRecursion<T, SuperMeta::size>::callFunction(container, context, primary);
  }
};

template <typename T, typename Functions> struct FunctionObjectTraverser<T, Functions, size_t(-1)> {
  static Error call(T& container, CallFunctionContext& context, Functions&, bool primary) {
    using SuperMeta = decltype(Internal::template JsonStructFunctionContainerDummy<T, T>::js_static_meta_super_info());
    return StartFunctionalSuperRecursion<T, SuperMeta::size>::callFunction(container, context, primary);
  }
};

static inline void add_error(CallFunctionExecutionState& executionState, ParseContext& context) {
  executionState.error = context.error;
  if (context.error != Error::NoError) {
    if (context.tokenizer.errorContext().custom_message.empty()) {
      context.tokenizer.updateErrorContext(context.error);
    }
    executionState.error_string.data = context.tokenizer.makeErrorString();
  }
  if (context.missing_members.size()) {
    std::swap(executionState.missing_members.data, context.missing_members);
  }
  if (context.unassigned_required_members.size()) {
    std::swap(executionState.unassigned_required_members.data, context.unassigned_required_members);
  }
}
} // namespace Internal

namespace Internal {
typedef void (CallFunctionContext::*AfterCallFunction)();

struct RAICallFunctionOnExit {
  RAICallFunctionOnExit(CallFunctionContext& context, AfterCallFunction after) : context(context), after(after) {}
  ~RAICallFunctionOnExit() { (context.*after)(); }
  CallFunctionContext& context;
  AfterCallFunction after;
};
} // namespace Internal

namespace Internal {
struct ArrayEndWriter {
  ArrayEndWriter(Serializer& serializer, Token& token) : serializer(serializer), token(token) {}

  ~ArrayEndWriter() {
    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }

  Serializer& serializer;
  Token& token;
};
} // namespace Internal

template <typename T> inline Error CallFunctionContext::callFunctions(T& container) {
  beforeCallFunctions();
  Internal::RAICallFunctionOnExit callOnExit(*this, &CallFunctionContext::afterCallFunctions);
  JS::Error error = parse_context.nextToken();
  if (error != JS::Error::NoError) {
    return error;
  }
  if (parse_context.token.value_type != JS::Type::ObjectStart) {
    return error_context.setError(Error::ExpectedObjectStart, "Can only call functions on objects with members");
  }
  error = parse_context.nextToken();
  if (error != JS::Error::NoError) {
    return error;
  }
  Token token;
  token.value_type = Type::ArrayStart;
  token.value = DataRef("[");
  Internal::ArrayEndWriter endWriter(return_serializer, token);
  return_serializer.write(token);
  auto& functions = Internal::JsonStructFunctionContainerDummy<T, T>::js_static_meta_functions_info();
  using FunctionsType = typename std::remove_reference<decltype(functions)>::type;
  while (parse_context.token.value_type != JS::Type::ObjectEnd) {
    parse_context.tokenizer.pushScope(parse_context.token.value_type);
    execution_list.push_back(
        CallFunctionExecutionState(std::string(parse_context.token.name.data, parse_context.token.name.size))
    );
    execution_list.back().context.data = user_context;
    error = Internal::FunctionObjectTraverser<T, FunctionsType, FunctionsType::size - 1>::call(
        container, *this, functions, true
    );
    if (error == Error::MissingFunction) {
      error = Internal::FunctionObjectTraverser<T, FunctionsType, FunctionsType::size - 1>::call(
          container, *this, functions, false
      );
    }
    if (error != Error::NoError) {
      assert(error == parse_context.error || parse_context.error == Error::NoError);
      parse_context.error = error;
    }
    Internal::add_error(execution_list.back(), parse_context);
    parse_context.tokenizer.goToEndOfScope(parse_context.token);
    parse_context.tokenizer.popScope();
    if (error == Error::MissingFunction && allow_missing) {
      error = Error::NoError;
    }
    if (stop_execute_on_fail && error != Error::NoError) {
      return error;
    }

    error = parse_context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
  }

  return Error::NoError;
}

struct DefaultCallFunctionContext : public CallFunctionContext {
  DefaultCallFunctionContext(std::string& json_out)
      : CallFunctionContext(
            p_context, s_context.serializer
        ) //-V1050 The super class only store the reference so we don't mind its not initialized
        ,
        s_context(json_out) {}

  DefaultCallFunctionContext(const char* data, size_t size, std::string& json_out)
      : CallFunctionContext(
            p_context, s_context.serializer
        ) //-V1050 The super class only store the reference so we don't mind its not initialized
        ,
        p_context(data, size), s_context(json_out) {}

  template <size_t SIZE>
  DefaultCallFunctionContext(const char (&data)[SIZE], std::string& json_out)
      : CallFunctionContext(p_context, s_context.serializer), p_context(data), s_context(json_out) {}

  ParseContext p_context;
  SerializerContext s_context;

protected:
  void afterCallFunctions() { s_context.flush(); }
};
namespace Internal {
template <typename T, size_t INDEX>
Error FunctionalSuperRecursion<T, INDEX>::callFunction(T& container, CallFunctionContext& context, bool primary) {
  using SuperMeta = decltype(Internal::template JsonStructFunctionContainerDummy<T, T>::js_static_meta_super_info());
  using Super = typename TypeAt<INDEX, SuperMeta>::type::type;
  auto& functions = Internal::template JsonStructFunctionContainerDummy<Super, Super>::js_static_meta_functions_info();
  using FunctionsType = typename std::remove_reference<decltype(functions)>::type;
  Error error = FunctionObjectTraverser<Super, FunctionsType, FunctionsType::size - 1>::call(
      container, context, functions, primary
  );
  if (error != Error::MissingFunction) {
    return error;
  }

  return FunctionalSuperRecursion<T, INDEX - 1>::callFunction(container, context, primary);
}

template <typename T> struct FunctionalSuperRecursion<T, 0> {
  static Error callFunction(T& container, CallFunctionContext& context, bool primary) {
    using SuperMeta = decltype(Internal::template JsonStructFunctionContainerDummy<T, T>::js_static_meta_super_info());
    using Super = typename TypeAt<0, SuperMeta>::type::type;
    auto& functions =
        Internal::template JsonStructFunctionContainerDummy<Super, Super>::js_static_meta_functions_info();
    using FunctionsType = typename std::remove_reference<decltype(functions)>::type;
    return FunctionObjectTraverser<Super, FunctionsType, FunctionsType::size - 1>::call(
        container, context, functions, primary
    );
  }
};
} // namespace Internal
namespace Internal {
enum class ParseEnumStringState { FindingNameStart, FindingNameEnd, FindingSeperator };
template <size_t N> void populateEnumNames(std::vector<DataRef>& names, const char (&data)[N]) {
  size_t name_starts_at = 0;
  ParseEnumStringState state = ParseEnumStringState::FindingNameStart;
  for (size_t i = 0; i < N; i++) {
    char c = data[i];
    assert(c != '=');
    switch (state) {
    case ParseEnumStringState::FindingNameStart:
      if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
        name_starts_at = i;
        state = ParseEnumStringState::FindingNameEnd;
      }
      break;
    case ParseEnumStringState::FindingNameEnd:
      if (c == '\0' || c == '\t' || c == '\n' || c == '\r' || c == ' ' || c == ',') {
        names.push_back(DataRef(data + name_starts_at, i - name_starts_at));
        state = c == ',' ? ParseEnumStringState::FindingNameStart : ParseEnumStringState::FindingSeperator;
      }
      break;
    case ParseEnumStringState::FindingSeperator:
      if (c == ',') {
        state = ParseEnumStringState::FindingNameStart;
      }
      break;
    }
  }
}
} // namespace Internal
} // namespace JS

#define JS_ENUM(name, ...)                                                                                             \
  enum class name { __VA_ARGS__ };                                                                                     \
  struct js_##name##_string_struct {                                                                                   \
    template <size_t N> explicit js_##name##_string_struct(const char (&data)[N]) {                                    \
      JS::Internal::populateEnumNames(_strings, data);                                                                 \
    }                                                                                                                  \
    std::vector<JS::DataRef> _strings;                                                                                 \
                                                                                                                       \
    static const std::vector<JS::DataRef>& strings() {                                                                 \
      static js_##name##_string_struct ret(#__VA_ARGS__);                                                              \
      return ret._strings;                                                                                             \
    }                                                                                                                  \
  };

#define JS_ENUM_DECLARE_STRING_PARSER(name)                                                                            \
  namespace JS {                                                                                                       \
  template <> struct TypeHandler<name> {                                                                               \
    static inline Error to(name& to_type, ParseContext& context) {                                                     \
      return Internal::EnumHandler<name, js_##name##_string_struct>::to(to_type, context);                             \
    }                                                                                                                  \
    static inline void from(const name& from_type, Token& token, Serializer& serializer) {                             \
      return Internal::EnumHandler<name, js_##name##_string_struct>::from(from_type, token, serializer);               \
    }                                                                                                                  \
  };                                                                                                                   \
  }

#define JS_ENUM_NAMESPACE_DECLARE_STRING_PARSER(ns, name)                                                              \
  namespace JS {                                                                                                       \
  template <> struct TypeHandler<ns::name> {                                                                           \
    static inline Error to(ns::name& to_type, ParseContext& context) {                                                 \
      return Internal::EnumHandler<ns::name, ns::js_##name##_string_struct>::to(to_type, context);                     \
    }                                                                                                                  \
    static inline void from(const ns::name& from_type, Token& token, Serializer& serializer) {                         \
      return Internal::EnumHandler<ns::name, ns::js_##name##_string_struct>::from(from_type, token, serializer);       \
    }                                                                                                                  \
  };                                                                                                                   \
  }

#define JS_ENUM_DECLARE_VALUE_PARSER(name)                                                                             \
  namespace JS {                                                                                                       \
  template <> struct TypeHandler<name> {                                                                               \
    typedef std::underlying_type<name>::type utype;                                                                    \
    static inline Error to(name& to_type, ParseContext& context) {                                                     \
      utype to_value;                                                                                                  \
      JS::Error result = TypeHandler<utype>::to(to_value, context);                                                    \
      if (result == JS::Error::NoError)                                                                                \
        to_type = static_cast<name>(to_value);                                                                         \
      return result;                                                                                                   \
    }                                                                                                                  \
    static inline void from(const name& from_type, Token& token, Serializer& serializer) {                             \
      const utype from_value = static_cast<utype>(from_type);                                                          \
      TypeHandler<utype>::from(from_value, token, serializer);                                                         \
    }                                                                                                                  \
  };                                                                                                                   \
  }

#define JS_ENUM_NAMESPACE_DECLARE_VALUE_PARSER(ns, name)                                                               \
  namespace JS {                                                                                                       \
  template <> struct TypeHandler<ns::name> {                                                                           \
    typedef std::underlying_type<ns::name>::type utype;                                                                \
    static inline Error to(ns::name& to_type, ParseContext& context) {                                                 \
      utype to_value;                                                                                                  \
      JS::Error result = TypeHandler<utype>::to(to_value, context);                                                    \
      if (result == JS::Error::NoError)                                                                                \
        to_type = static_cast<ns::name>(to_value);                                                                     \
      return result;                                                                                                   \
    }                                                                                                                  \
    static inline void from(const ns::name& from_type, Token& token, Serializer& serializer) {                         \
      const utype from_value = static_cast<utype>(from_type);                                                          \
      TypeHandler<utype>::from(from_value, token, serializer);                                                         \
    }                                                                                                                  \
  };                                                                                                                   \
  }

namespace JS {
template <typename T, typename Enable> inline Error TypeHandler<T, Enable>::to(T& to_type, ParseContext& context) {
  if (context.token.value_type != JS::Type::ObjectStart) {
    return Error::ExpectedObjectStart;
  }
  Error error = context.tokenizer.nextToken(context.token);
  if (error != JS::Error::NoError) {
    return error;
  }
  auto members = Internal::JsonStructBaseDummy<T, T>::js_static_meta_data_info();
  using MembersType = decltype(members);
  bool assigned_members[Internal::memberCount<T, 0>()];
  memset(assigned_members, 0, sizeof(assigned_members));
  while (context.token.value_type != JS::Type::ObjectEnd)

  {
    DataRef token_name = context.token.name;
    error = Internal::MemberChecker<T, MembersType, 0, MembersType::size - 1>::unpackMembers(
        to_type, members, context, true, assigned_members
    );
    if (error == Error::MissingPropertyMember) {
      error = Internal::MemberChecker<T, MembersType, 0, MembersType::size - 1>::unpackMembers(
          to_type, members, context, false, assigned_members
      );
    }
    if (error == Error::MissingPropertyMember) {

      if (context.track_member_assignement_state) {
        context.missing_members.emplace_back(token_name.data, token_name.data + token_name.size);
      }
      if (context.allow_missing_members) {
        Internal::skipArrayOrObject(context);
        if (context.error != Error::NoError) {
          return context.error;
        }
      } else {
        return error;
      }
    } else if (error != Error::NoError) {
      return error;
    }
    context.nextToken();
    if (context.error != Error::NoError) {
      return context.error;
    }
  }
  std::vector<std::string> unassigned_required_members;
  error = Internal::MemberChecker<T, MembersType, 0, MembersType::size - 1>::verifyMembers(
      members, assigned_members, context.track_member_assignement_state, unassigned_required_members, ""
  );
  if (error == Error::UnassignedRequiredMember) {
    if (context.track_member_assignement_state) {
      context.unassigned_required_members.insert(
          context.unassigned_required_members.end(), unassigned_required_members.begin(),
          unassigned_required_members.end()
      );
    }
    if (context.allow_unasigned_required_members) {
      error = Error::NoError;
    }
  }
  return error;
}

template <typename T, typename Enable>
void TypeHandler<T, Enable>::from(const T& from_type, Token& token, Serializer& serializer) {
  static const char objectStart[] = "{";
  static const char objectEnd[] = "}";
  token.value_type = Type::ObjectStart;
  token.value = DataRef(objectStart);
  serializer.write(token);
  auto members = Internal::JsonStructBaseDummy<T, T>::js_static_meta_data_info();
  using MembersType = decltype(members);
  Internal::MemberChecker<T, MembersType, 0, MembersType::size - 1>::serializeMembers(
      from_type, members, token, serializer, ""
  );
  token.name.size = 0;
  token.name.data = "";
  token.name_type = Type::String;
  token.value_type = Type::ObjectEnd;
  token.value = DataRef(objectEnd);
  serializer.write(token);
}

namespace Internal {
template <typename T, typename F> struct EnumHandler {
  static inline Error to(T& to_type, ParseContext& context) {
    if (context.token.value_type == Type::String) {
      auto& strings = F::strings();
      for (size_t i = 0; i < strings.size(); i++) {
        const DataRef& ref = strings[i];
        if (ref.size == context.token.value.size) {
          if (memcmp(ref.data, context.token.value.data, ref.size) == 0) {
            to_type = static_cast<T>(i);
            return Error::NoError;
          }
        }
      }
    } else if (context.token.value_type == Type::Number) {
      using enum_int_t = typename std::underlying_type<T>::type;
      enum_int_t tmp;
      auto err = TypeHandler<enum_int_t>::to(tmp, context);
      if (err != Error::NoError) {
        return err;
      }
      to_type = static_cast<T>(tmp);
      return Error::NoError;
    }

    return Error::IllegalDataValue;
  }

  static inline void from(const T& from_type, Token& token, Serializer& serializer) {
    size_t i = static_cast<size_t>(from_type);
    token.value = F::strings()[i];
    token.value_type = Type::String;
    serializer.write(token);
  }
};
} // namespace Internal

namespace Internal {
static void push_back_escape(char current_char, std::string& to_type) {
  static const char escaped_table[] = {'b', 'f', 'n', 'r', 't', '\"', '\\', '/'};
  static const char replace_table[] = {'\b', '\f', '\n', '\r', '\t', '\"', '\\', '/'};
  static_assert(sizeof(escaped_table) == sizeof(replace_table), "Static tables have to be the same.");
  const char* it = static_cast<const char*>(memchr(escaped_table, current_char, sizeof(escaped_table)));
  if (it) {
    to_type.push_back(replace_table[(it - escaped_table)]);
  } else {
    to_type.push_back('\\');
    to_type.push_back(current_char);
  }
}

static void handle_json_escapes_in(const DataRef& ref, std::string& to_type) {
  to_type.reserve(ref.size);
  const char* it = ref.data;
  size_t size = ref.size;
  while (size) {
    const char* next_it = static_cast<const char*>(memchr(it, '\\', size));
    if (!next_it) {
      to_type.insert(to_type.end(), it, it + size);
      break;
    }
    to_type.insert(to_type.end(), it, next_it);
    size -= next_it - it;
    if (!size) {
      break;
    }
    size -= 2;
    const char current_char = *(next_it + 1);
    // we assume utf-8 encoding when this notation is used and parsing into std::string
    if (current_char == 'u') // hexadecimal escaped unicode character
    {
      // first convert hex ascii digits to values between 0 and 15, then create
      // UTF-8 bit patterns according to https://en.wikipedia.org/wiki/UTF-8
      bool ok = (size >= 4);
      unsigned char hex[4];
      for (int k = 0; ok && k < 4; k++) {
        const char d = *(next_it + k + 2);
        if (d >= '0' && d <= '9') {
          hex[k] = (d - '0');
        } else if (d >= 'A' && d <= 'F') {
          hex[k] = (d - 'A') + 10;
        } else if (d >= 'a' && d <= 'f') {
          hex[k] = (d - 'a') + 10;
        } else {
          ok = false; // stop parsing and revert to fallback
        }
      }
      if (ok) {
        if (hex[0] || hex[1] & 0x08) {
          // code points: 0x0800 .. 0xffff
          to_type.push_back(0xd0 | hex[0]);
          to_type.push_back(0x80 | (hex[1] << 2) | ((hex[2] & 0x0c) >> 2));
          to_type.push_back(0x80 | ((hex[2] & 0x03) << 4) | hex[3]);
        } else if (hex[1] || hex[2] & 0x08) {
          // code points: 0x0080 .. 0x07ff
          to_type.push_back(0xc0 | (hex[1] << 2) | ((hex[2] & 0x0c) >> 2));
          to_type.push_back(0x80 | ((hex[2] & 0x03) << 4) | hex[3]);
        } else {
          // code points: 0x0000 .. 0x007f
          to_type.push_back((hex[2] << 4) | hex[3]);
        }
        it = next_it + 6; // advance past hex digits
        size -= 4;
      } else {
        // fallback is to simply push characters as is
        to_type.push_back('\\');
        to_type.push_back(current_char);
        it = next_it + 2;
      }
    } else {
      push_back_escape(current_char, to_type);
      it = next_it + 2;
    }
    if (!size) {
      break;
    }
  }
}

static DataRef handle_json_escapes_out(const std::string& data, std::string& buffer) {
  int start_index = 0;
  for (size_t i = 0; i < data.size(); i++) {
    const char cur = data[i];
    if (static_cast<uint8_t>(cur) <= uint8_t('\r') || cur == '\"' || cur == '\\') {
      if (buffer.empty()) {
        buffer.reserve(data.size() + 10);
      }
      size_t diff = i - start_index;
      if (diff > 0) {
        buffer.insert(buffer.end(), data.data() + start_index, data.data() + start_index + diff);
      }
      start_index = int(i) + 1;

      switch (cur) {
      case '\b':
        buffer += std::string("\\b");
        break;
      case '\t':
        buffer += std::string("\\t");
        break;
      case '\n':
        buffer += std::string("\\n");
        break;
      case '\f':
        buffer += std::string("\\f");
        break;
      case '\r':
        buffer += std::string("\\r");
        break;
      case '\"':
        buffer += std::string("\\\"");
        break;
      case '\\':
        buffer += std::string("\\\\");
        break;
      default:
        buffer.push_back(cur);
        break;
      }
    }
  }
  if (buffer.size()) {
    size_t diff = data.size() - start_index;
    if (diff > 0) {
      buffer.insert(buffer.end(), data.data() + start_index, data.data() + start_index + diff);
    }
    return DataRef(buffer.data(), buffer.size());
  }
  return DataRef(data.data(), data.size());
}
} // namespace Internal
/// \private
template <> struct TypeHandler<std::string> {
  static inline Error to(std::string& to_type, ParseContext& context) {
    to_type.clear();
    Internal::handle_json_escapes_in(context.token.value, to_type);
    return Error::NoError;
  }

  static inline void from(const std::string& str, Token& token, Serializer& serializer) {
    std::string buffer;
    DataRef ref = Internal::handle_json_escapes_out(str, buffer);
    token.value_type = Type::String;
    token.value.data = ref.data;
    token.value.size = ref.size;
    serializer.write(token);
  }
};

namespace Internal {
// This code is taken from https://github.com/jorgen/float_tools
namespace ft {
template <typename T> struct float_base10 {
  uint8_t negative;
  uint8_t inf;
  uint8_t nan;
  uint8_t significand_digit_count;
  int exp;
  T significand;
};

template <typename T> struct parsed_string : float_base10<T> {
  const char* endptr;
};

enum class parse_string_error { ok, invalid_format, multiple_commas, empty_string, illegal_exponent_value };

constexpr static inline uint64_t high(uint64_t x) { return x >> 32; }
constexpr static inline uint64_t low(uint64_t x) { return x & ~uint32_t(0); }

template <int shift = 1> inline void left_shift(uint64_t (&a)[2]) {
  static_assert(
      shift < sizeof(*a) * 8, "This functions does only support shifting by sizes smaller than sizeof(*a) * 8"
  );
  a[1] = a[1] << shift | (a[0] >> (int(sizeof(uint64_t) * 8) - shift));
  a[0] = a[0] << shift;
}

template <int shift = 1> inline void left_shift(uint64_t& a) {
  static_assert(
      shift < sizeof(a) * 8, "This functions does only support shifting by sizes smaller than sizeof(*a) * 8"
  );
  a = a << shift;
}

inline void left_shift(uint64_t (&a)[2], int shift) {
  if (shift > int(sizeof(*a)) * 8) {
    auto shift_0 = (int(sizeof(uint64_t) * 8) - shift);
    a[1] = a[0] << -shift_0;

    a[0] = 0;
  } else {
    a[1] = a[1] << shift | (a[0] >> (int(sizeof(uint64_t) * 8) - shift));
    a[0] = a[0] << shift;
  }
}

inline void left_shift(uint64_t& a, int shift) { a = a << shift; }

inline void right_shift(uint64_t (&a)[2]) {
  a[0] = a[0] >> 1 | (a[1] << ((sizeof(uint64_t) * 8) - 1));
  a[1] = a[1] >> 1;
}

inline void right_shift(uint64_t& a) { a = a >> 1; }

inline uint64_t mask32(uint64_t a) { return a & ((uint64_t(1) << 32) - 1); }

inline void add(const uint64_t (&a)[2], uint64_t (&b)[2]) {
  uint64_t tmplow[2];
  uint64_t tmphigh[2];
  tmplow[0] = low(a[0]) + low(b[0]);
  tmplow[1] = low(a[1]) + low(b[1]);
  tmphigh[0] = high(a[0]) + high(b[0]);
  tmphigh[1] = high(a[1]) + high(b[1]);

  tmphigh[0] += tmplow[0] >> 32;
  tmplow[1] += tmphigh[0] >> 32;
  tmphigh[1] += tmplow[1] >> 32;

  b[0] = mask32(tmplow[0]) | (tmphigh[0] << 32);
  b[1] = mask32(tmplow[1]) | (tmphigh[1] << 32);
}

inline void add(const uint64_t& a, uint64_t& b) { b += a; }

inline void divide_by_10(uint64_t (&a)[2]) {
  uint64_t remainder = a[1] % 10;
  a[1] /= 10;
  uint64_t high_pluss_reminder = high(a[0]) + (remainder << 32);
  uint64_t high_d = high_pluss_reminder / 10;
  uint64_t high_r = high_pluss_reminder % 10;
  uint64_t low_d = (low(a[0]) + (high_r << 32)) / 10;
  a[0] = high_d << 32 | low_d;
}

inline void divide_by_10(uint64_t& a) { a /= 10; }

template <typename T> struct float_info {};

static inline int bit_scan_reverse(uint64_t a) {
  assert(a);
#ifdef _MSC_VER
  unsigned long index;
#ifdef _WIN64
  _BitScanReverse64(&index, a);
#else
  if (_BitScanReverse(&index, a >> 32)) {
    index += 32;
  } else {
    _BitScanReverse(&index, a & (~uint32_t(0)));
  }
#endif
  return int(index);
#else
  static_assert(sizeof(unsigned long long) == sizeof(uint64_t), "Wrong size for builtin_clzll");
  return 63 - __builtin_clzll(a);
#endif
}

template <> struct float_info<double> {
  static inline constexpr int mentissa_width() noexcept { return 52; }
  static inline constexpr int exponent_width() noexcept { return 11; }
  static inline constexpr int bias() noexcept { return (1 << (exponent_width() - 1)) - 1; }
  static inline constexpr int max_base10_exponent() noexcept { return 308; }
  static inline constexpr int min_base10_exponent() noexcept { return -324; }
  static inline constexpr int max_double_5_pow_q() noexcept { return 23; } // floor(log_5(1 << (mentissawidth + 2)))
  static inline constexpr int max_double_2_pow_q() noexcept { return 54; } // floor(log_2(1 << (mentissawidth + 2)))

  using str_to_float_conversion_type = uint64_t[2];
  using uint_alias = uint64_t;
  static inline constexpr int str_to_float_binary_exponent_init() noexcept { return 64 + 60; }
  static inline constexpr uint64_t str_to_float_mask() noexcept { return ~((uint64_t(1) << 60) - 1); }
  static inline constexpr uint64_t str_to_float_top_bit_in_mask() noexcept { return uint64_t(1) << 63; }
  static inline constexpr int str_to_float_expanded_length() noexcept { return 19; }
  static inline constexpr bool conversion_type_has_mask(const str_to_float_conversion_type& a) noexcept {
    return a[1] & str_to_float_mask();
  }
  static inline constexpr bool conversion_type_has_top_bit_in_mask(const str_to_float_conversion_type& a) noexcept {
    return a[1] & str_to_float_top_bit_in_mask();
  }
  static inline constexpr bool conversion_type_is_null(const str_to_float_conversion_type& a) noexcept {
    return !a[0] && !a[1];
  }
  static inline int shift_left_msb_to_index(str_to_float_conversion_type& a, int index) {
    if (a[1]) {
      int msb = bit_scan_reverse(a[1]);
      int shift_count = index - (msb + 64);
      if (shift_count < 0) {
        return 0;
      }
      left_shift(a, shift_count);
      return shift_count;
    } else if (a[0]) {
      int msb = bit_scan_reverse(a[0]);
      int shift_count = index - msb;
      if (shift_count < 0) {
        return 0;
      }
      left_shift(a, shift_count);
      return shift_count;
    }
    return 0;
  }
  static inline void copy_denormal_to_type(
      const str_to_float_conversion_type& a, int binary_exponent, bool negative, double& to_digit
  ) {
    uint64_t q = a[1];
    int expo_shift = -binary_exponent + 9;
    if (expo_shift) {
      q += uint64_t(1) << (expo_shift - 1);
      q >>= expo_shift;
    }
    if (negative) {
      q |= uint64_t(1) << 63;
    }
    memcpy(&to_digit, &q, sizeof(q));
  }

  static inline void copy_normal_to_type(
      const str_to_float_conversion_type& a, int binary_exponent, bool negative, double& to_digit
  ) {
    uint64_t q = a[1] & ~str_to_float_mask();
    uint64_t to_round_off = (q & ((uint64_t(1) << 8) - 1));
    bool bigger = to_round_off > (uint64_t(1) << (8 - 1)) || (to_round_off == (uint64_t(1) << (8 - 1)) && a[0]);
    bool tie_odd = (!(q & ((uint64_t(1) << 7) - 1))) && (q & (uint64_t(1) << 8)) && !a[0];
    if (bigger || tie_odd) {
      q += uint64_t(1) << (8 - 1);
    }
    q >>= 8;
    q += uint64_t(binary_exponent) << mentissa_width();
    if (negative) {
      q |= uint64_t(1) << 63;
    }
    memcpy(&to_digit, &q, sizeof(q));
  }
};

template <typename T> inline void get_parts(T f, bool& negative, int& exp, uint64_t& mentissa) {
  uint64_t bits = 0;
  static_assert(sizeof(bits) >= sizeof(f), "Incompatible size");
  memcpy(&bits, &f, sizeof(f));
  exp = int((bits >> float_info<T>::mentissa_width()) & (((uint64_t(1) << float_info<T>::exponent_width()) - 1)));
  mentissa = bits & ((uint64_t(1) << float_info<T>::mentissa_width()) - 1);
  negative = bits >> ((sizeof(f) * 8) - 1);
}

template <typename T>
inline void assign_significand_to_float_conversion_type(const float_base10<T>& significand, uint64_t (&a)[2]) {
  a[0] = significand.significand;
  a[1] = 0;
}

inline void copy_conversion_type(const uint64_t (&a)[2], uint64_t (&b)[2]) { memcpy(&b, &a, sizeof(b)); }

template <> struct float_info<float> {
  static inline constexpr int mentissa_width() noexcept { return 23; }
  static inline constexpr int exponent_width() noexcept { return 8; }
  static inline constexpr int bias() noexcept { return (1 << (exponent_width() - 1)) - 1; }
  static inline constexpr int max_base10_exponent() noexcept { return 38; }
  static inline constexpr int min_base10_exponent() noexcept { return -45; }
  static inline constexpr int max_double_5_pow_q() noexcept { return 10; } // floor(log_5(1 << (mentissawidth + 2)))
  static inline constexpr int max_double_2_pow_q() noexcept { return 25; } // floor(log_2(1 << (mentissawidth + 2)))

  using str_to_float_conversion_type = uint64_t;
  using uint_alias = uint32_t;
  static inline constexpr int str_to_float_binary_exponent_init() noexcept { return 60; }
  static inline constexpr uint64_t str_to_float_mask() noexcept { return ~((uint64_t(1) << 60) - 1); }
  static inline constexpr uint64_t str_to_float_top_bit_in_mask() noexcept { return uint64_t(1) << 63; }
  static inline constexpr int str_to_float_expanded_length() noexcept { return 10; }
  static inline constexpr bool conversion_type_has_mask(const str_to_float_conversion_type& a) noexcept {
    return a & str_to_float_mask();
  }
  static inline constexpr bool conversion_type_has_top_bit_in_mask(const str_to_float_conversion_type& a) noexcept {
    return a & str_to_float_top_bit_in_mask();
  }
  static inline constexpr bool conversion_type_is_null(const str_to_float_conversion_type& a) noexcept { return !a; }
  static inline int shift_left_msb_to_index(str_to_float_conversion_type& a, int index) {
    if (a) {
      int msb = bit_scan_reverse(a);
      int shift_count = index - msb;
      if (shift_count < 0) {
        return 0;
      }
      left_shift(a, shift_count);
      return shift_count;
    }
    return 0;
  }
  static inline void copy_denormal_to_type(
      const str_to_float_conversion_type& a, int binary_exponent, bool negative, float& to_digit
  ) {
    uint64_t q = a;
    int expo_shift = -binary_exponent + 38;
    if (expo_shift) {
      q += uint64_t(1) << (expo_shift - 1);
      q >>= expo_shift;
    }
    if (negative) {
      q |= uint64_t(1) << 31;
    }
    uint32_t to_copy = uint32_t(q);
    memcpy(&to_digit, &to_copy, sizeof(to_copy));
  }
  static inline void copy_normal_to_type(
      const str_to_float_conversion_type& a, int binary_exponent, bool negative, float& to_digit
  ) {
    uint64_t q = a & ~str_to_float_mask();
    bool bigger = (q & ((uint64_t(1) << 37) - 1)) > (uint64_t(1) << (37 - 1));
    bool tie_odd = (!(q & ((uint64_t(1) << 36) - 1))) && (q & (uint64_t(1) << 37));
    if (bigger || tie_odd) {
      q += (uint64_t(1) << (37 - 1));
    }
    q >>= 37;
    q += uint64_t(binary_exponent) << mentissa_width();
    if (negative) {
      q |= uint64_t(1) << 31;
    }
    uint32_t to_copy = uint32_t(q);
    memcpy(&to_digit, &to_copy, sizeof(to_digit));
  }
};

template <typename T> inline T make_zero(bool negative) {
  using uint_ft = typename float_info<T>::uint_alias;
  uint_ft tmp = 0;
  tmp = uint_ft(negative) << ((sizeof(T) * 8) - 1);
  T ret;
  memcpy(&ret, &tmp, sizeof(ret));
  return ret;
}

template <typename T> inline T make_inf(bool negative) {
  using uint_ft = typename float_info<T>::uint_alias;
  uint_ft tmp = (uint_ft(1) << float_info<T>::exponent_width()) - 1;
  tmp <<= float_info<T>::mentissa_width();
  tmp += uint_ft(negative) << ((sizeof(T) * 8) - 1);
  T ret;
  memcpy(&ret, &tmp, sizeof(ret));
  return ret;
}

template <typename T> inline T make_nan(bool positive, uint64_t pos = 1) {
  if (pos == 0) {
    pos++;
  }
  using uint_ft = typename float_info<T>::uint_alias;
  uint_ft tmp = (uint_ft(1) << float_info<T>::exponent_width()) - 1;
  tmp <<= float_info<T>::mentissa_width();
  tmp |= pos;
  tmp |= uint_ft(!positive) << ((sizeof(T) * 8) - 1);
  T ret;
  memcpy(&ret, &tmp, sizeof(ret));
  return ret;
}

template <typename T> inline bool is_nan(T t) {
  bool negative;
  int exp;
  uint64_t mentissa;
  get_parts(t, negative, exp, mentissa);
  return exp == ((int(1) << float_info<T>::exponent_width()) - 1) && mentissa > 0;
}

template <typename T> inline bool is_inf(T t) {
  bool negative;
  int exp;
  uint64_t mentissa;
  get_parts(t, negative, exp, mentissa);
  return exp == ((int(1) << float_info<T>::exponent_width()) - 1) && mentissa == 0;
}

template <typename T> const T& max(const T& a, const T& b) { return (a < b) ? b : a; }

template <typename T> const T& min(const T& a, const T& b) { return (b < a) ? b : a; }

template <typename I, typename P> I find_if(I first, I last, P p) {
  for (; first != last; ++first) {
    if (p(*first)) {
      return first;
    }
  }
  return last;
}

template <typename T>
inline void assign_significand_to_float_conversion_type(const float_base10<T>& significand, uint64_t& a) {
  a = significand.significand;
}

inline void copy_conversion_type(const uint64_t& a, uint64_t& b) { b = a; }

template <typename T, int COUNT, T SUM> struct Pow10 {
  static inline T get() noexcept { return Pow10<T, COUNT - 1, SUM * T(10)>::get(); }
};
template <typename T, T SUM> struct Pow10<T, 1, SUM> {
  static inline T get() noexcept { return SUM; }
};
template <typename T, T SUM> struct Pow10<T, 0, SUM> {
  static inline T get() noexcept { return 1; }
};

template <typename T, T VALUE, int SUM, T ABORT_VALUE, bool CONTINUE> struct StaticLog10 {
  constexpr static int get() noexcept {
    return StaticLog10<T, VALUE / 10, SUM + 1, ABORT_VALUE, VALUE / 10 != ABORT_VALUE>::get();
  }
};

template <typename T, T VALUE, T ABORT_VALUE, int SUM> struct StaticLog10<T, VALUE, SUM, ABORT_VALUE, false> {
  constexpr static int get() noexcept { return SUM; }
};

template <typename T, int WIDTH, int CURRENT> struct CharsInDigit {
  static int lower_bounds(T t) noexcept {
    if (Pow10<T, CURRENT + WIDTH / 2, 1>::get() - 1 < t) {
      return CharsInDigit<T, WIDTH - (WIDTH / 2 + 1), CURRENT + WIDTH / 2 + 1>::lower_bounds(t);
    }
    return CharsInDigit<T, WIDTH / 2, CURRENT>::lower_bounds(t);
  }
};
template <typename T, int CURRENT> struct CharsInDigit<T, 0, CURRENT> {
  static int lower_bounds(T) noexcept { return CURRENT; }
};
template <typename T, int CURRENT> struct CharsInDigit<T, -1, CURRENT> {
  static int lower_bounds(T) noexcept { return CURRENT; }
};

template <typename T> T iabs(typename std::enable_if<std::is_unsigned<T>::value, T>::type a) { return a; }

template <typename T> T iabs(typename std::enable_if<std::is_signed<T>::value, T>::type a) {
  // this
  if (a > 0) {
    return a;
  }
  if (a == std::numeric_limits<T>::min()) {
    a++;
  }
  return -a;
}

template <typename T> int count_chars(T t) noexcept {
  if (iabs<T>(t) < T(10)) {
    return 1;
  }
  constexpr int maxChars = StaticLog10<T, std::numeric_limits<T>::max(), 0, 0, true>::get() + 1;
  return CharsInDigit<T, maxChars, 0>::lower_bounds(iabs<T>(t)) - 1;
}

namespace ryu {
template <typename T> struct cache_values {};

template <> struct cache_values<double> {
  constexpr static const int b0 = 124;
  constexpr static const int b1 = 124;

  static const uint64_t* less_than(int index) {
    static const uint64_t data[326][2] = {
        {/*  0*/ UINT64_C(0), UINT64_C(1152921504606846976)},
        {/*  1*/ UINT64_C(0), UINT64_C(720575940379279360)},
        {/*  2*/ UINT64_C(0), UINT64_C(900719925474099200)},
        {/*  3*/ UINT64_C(0), UINT64_C(1125899906842624000)},
        {/*  4*/ UINT64_C(0), UINT64_C(703687441776640000)},
        {/*  5*/ UINT64_C(0), UINT64_C(879609302220800000)},
        {/*  6*/ UINT64_C(0), UINT64_C(1099511627776000000)},
        {/*  7*/ UINT64_C(0), UINT64_C(687194767360000000)},
        {/*  8*/ UINT64_C(0), UINT64_C(858993459200000000)},
        {/*  9*/ UINT64_C(0), UINT64_C(1073741824000000000)},
        {/* 10*/ UINT64_C(0), UINT64_C(671088640000000000)},
        {/* 11*/ UINT64_C(0), UINT64_C(838860800000000000)},
        {/* 12*/ UINT64_C(0), UINT64_C(1048576000000000000)},
        {/* 13*/ UINT64_C(0), UINT64_C(655360000000000000)},
        {/* 14*/ UINT64_C(0), UINT64_C(819200000000000000)},
        {/* 15*/ UINT64_C(0), UINT64_C(1024000000000000000)},
        {/* 16*/ UINT64_C(0), UINT64_C(640000000000000000)},
        {/* 17*/ UINT64_C(0), UINT64_C(800000000000000000)},
        {/* 18*/ UINT64_C(0), UINT64_C(1000000000000000000)},
        {/* 19*/ UINT64_C(0), UINT64_C(625000000000000000)},
        {/* 20*/ UINT64_C(0), UINT64_C(781250000000000000)},
        {/* 21*/ UINT64_C(0), UINT64_C(976562500000000000)},
        {/* 22*/ UINT64_C(0), UINT64_C(610351562500000000)},
        {/* 23*/ UINT64_C(0), UINT64_C(762939453125000000)},
        {/* 24*/ UINT64_C(0), UINT64_C(953674316406250000)},
        {/* 25*/ UINT64_C(0), UINT64_C(596046447753906250)},
        {/* 26*/ UINT64_C(9223372036854775808), UINT64_C(745058059692382812)},
        {/* 27*/ UINT64_C(11529215046068469760), UINT64_C(931322574615478515)},
        {/* 28*/ UINT64_C(4899916394579099648), UINT64_C(582076609134674072)},
        {/* 29*/ UINT64_C(6124895493223874560), UINT64_C(727595761418342590)},
        {/* 30*/ UINT64_C(16879491403384619008), UINT64_C(909494701772928237)},
        {/* 31*/ UINT64_C(7264306198948610048), UINT64_C(1136868377216160297)},
        {/* 32*/ UINT64_C(16069406420411351040), UINT64_C(710542735760100185)},
        {/* 33*/ UINT64_C(6251699970232025088), UINT64_C(888178419700125232)},
        {/* 34*/ UINT64_C(7814624962790031360), UINT64_C(1110223024625156540)},
        {/* 35*/ UINT64_C(14107512638598545408), UINT64_C(693889390390722837)},
        {/* 36*/ UINT64_C(3799332742966018048), UINT64_C(867361737988403547)},
        {/* 37*/ UINT64_C(137479910280134656), UINT64_C(1084202172485504434)},
        {/* 38*/ UINT64_C(4697610962352472064), UINT64_C(677626357803440271)},
        {/* 39*/ UINT64_C(1260327684513202176), UINT64_C(847032947254300339)},
        {/* 40*/ UINT64_C(15410467660923666432), UINT64_C(1058791184067875423)},
        {/* 41*/ UINT64_C(16549071315718373376), UINT64_C(661744490042422139)},
        {/* 42*/ UINT64_C(16074653126220578816), UINT64_C(827180612553027674)},
        {/* 43*/ UINT64_C(10869944370920947712), UINT64_C(1033975765691284593)},
        {/* 44*/ UINT64_C(18322930277894062080), UINT64_C(646234853557052870)},
        {/* 45*/ UINT64_C(13680290810512801792), UINT64_C(807793566946316088)},
        {/* 46*/ UINT64_C(17100363513141002240), UINT64_C(1009741958682895110)},
        {/* 47*/ UINT64_C(6076041177285738496), UINT64_C(631088724176809444)},
        {/* 48*/ UINT64_C(7595051471607173120), UINT64_C(788860905221011805)},
        {/* 49*/ UINT64_C(14105500357936354304), UINT64_C(986076131526264756)},
        {/* 50*/ UINT64_C(18039309760564997248), UINT64_C(616297582203915472)},
        {/* 51*/ UINT64_C(4102393126996694944), UINT64_C(770371977754894341)},
        {/* 52*/ UINT64_C(9739677427173256584), UINT64_C(962964972193617926)},
        {/* 53*/ UINT64_C(1475612373555897461), UINT64_C(601853107621011204)},
        {/* 54*/ UINT64_C(1844515466944871826), UINT64_C(752316384526264005)},
        {/* 55*/ UINT64_C(6917330352108477686), UINT64_C(940395480657830006)},
        {/* 56*/ UINT64_C(18158389525349962266), UINT64_C(587747175411143753)},
        {/* 57*/ UINT64_C(8862928851405289120), UINT64_C(734683969263929692)},
        {/* 58*/ UINT64_C(11078661064256611401), UINT64_C(918354961579912115)},
        {/* 59*/ UINT64_C(9236640311893376347), UINT64_C(1147943701974890144)},
        {/* 60*/ UINT64_C(5772900194933360217), UINT64_C(717464813734306340)},
        {/* 61*/ UINT64_C(7216125243666700271), UINT64_C(896831017167882925)},
        {/* 62*/ UINT64_C(13631842573010763243), UINT64_C(1121038771459853656)},
        {/* 63*/ UINT64_C(8519901608131727026), UINT64_C(700649232162408535)},
        {/* 64*/ UINT64_C(6038190991737270879), UINT64_C(875811540203010669)},
        {/* 65*/ UINT64_C(12159424758098976503), UINT64_C(1094764425253763336)},
        {/* 66*/ UINT64_C(7599640473811860314), UINT64_C(684227765783602085)},
        {/* 67*/ UINT64_C(14111236610692213297), UINT64_C(855284707229502606)},
        {/* 68*/ UINT64_C(8415673726510490813), UINT64_C(1069105884036878258)},
        {/* 69*/ UINT64_C(9871482097496444662), UINT64_C(668191177523048911)},
        {/* 70*/ UINT64_C(7727666603443167924), UINT64_C(835238971903811139)},
        {/* 71*/ UINT64_C(5047897235876572001), UINT64_C(1044048714879763924)},
        {/* 72*/ UINT64_C(12378307809277633308), UINT64_C(652530446799852452)},
        {/* 73*/ UINT64_C(15472884761597041636), UINT64_C(815663058499815565)},
        {/* 74*/ UINT64_C(5506047896714138333), UINT64_C(1019578823124769457)},
        {/* 75*/ UINT64_C(14970494981514806218), UINT64_C(637236764452980910)},
        {/* 76*/ UINT64_C(9489746690038731964), UINT64_C(796545955566226138)},
        {/* 77*/ UINT64_C(2638811325693639147), UINT64_C(995682444457782673)},
        {/* 78*/ UINT64_C(13178472124626994227), UINT64_C(622301527786114170)},
        {/* 79*/ UINT64_C(7249718118928966976), UINT64_C(777876909732642713)},
        {/* 80*/ UINT64_C(13673833667088596624), UINT64_C(972346137165803391)},
        {/* 81*/ UINT64_C(15463675069571454746), UINT64_C(607716335728627119)},
        {/* 82*/ UINT64_C(14717907818536930528), UINT64_C(759645419660783899)},
        {/* 83*/ UINT64_C(13785698754743775257), UINT64_C(949556774575979874)},
        {/* 84*/ UINT64_C(13227747740142247439), UINT64_C(593472984109987421)},
        {/* 85*/ UINT64_C(2699626619895645587), UINT64_C(741841230137484277)},
        {/* 86*/ UINT64_C(7986219293296944888), UINT64_C(927301537671855346)},
        {/* 87*/ UINT64_C(9603073076737978459), UINT64_C(579563461044909591)},
        {/* 88*/ UINT64_C(7392155327495085170), UINT64_C(724454326306136989)},
        {/* 89*/ UINT64_C(13851880177796244366), UINT64_C(905567907882671236)},
        {/* 90*/ UINT64_C(17314850222245305458), UINT64_C(1131959884853339045)},
        {/* 91*/ UINT64_C(13127624398117009863), UINT64_C(707474928033336903)},
        {/* 92*/ UINT64_C(11797844479218874425), UINT64_C(884343660041671129)},
        {/* 93*/ UINT64_C(912247543741429319), UINT64_C(1105429575052088912)},
        {/* 94*/ UINT64_C(570154714838393324), UINT64_C(690893484407555570)},
        {/* 95*/ UINT64_C(9936065430402767463), UINT64_C(863616855509444462)},
        {/* 96*/ UINT64_C(3196709751148683521), UINT64_C(1079521069386805578)},
        {/* 97*/ UINT64_C(6609629612895315105), UINT64_C(674700668366753486)},
        {/* 98*/ UINT64_C(17485409052973919689), UINT64_C(843375835458441857)},
        {/* 99*/ UINT64_C(8021703260935235899), UINT64_C(1054219794323052322)},
        {/*100*/ UINT64_C(9625250556511910341), UINT64_C(658887371451907701)},
        {/*101*/ UINT64_C(16643249214067275830), UINT64_C(823609214314884626)},
        {/*102*/ UINT64_C(11580689480729318980), UINT64_C(1029511517893605783)},
        {/*103*/ UINT64_C(14155459953096906218), UINT64_C(643444698683503614)},
        {/*104*/ UINT64_C(8470952904516356965), UINT64_C(804305873354379518)},
        {/*105*/ UINT64_C(1365319093790670398), UINT64_C(1005382341692974398)},
        {/*106*/ UINT64_C(14688382488901332711), UINT64_C(628363963558108998)},
        {/*107*/ UINT64_C(9137106074271890081), UINT64_C(785454954447636248)},
        {/*108*/ UINT64_C(11421382592839862601), UINT64_C(981818693059545310)},
        {/*109*/ UINT64_C(2526678102097526221), UINT64_C(613636683162215819)},
        {/*110*/ UINT64_C(16993405682904071489), UINT64_C(767045853952769773)},
        {/*111*/ UINT64_C(7406699048347925649), UINT64_C(958807317440962217)},
        {/*112*/ UINT64_C(16158401951285923291), UINT64_C(599254573400601385)},
        {/*113*/ UINT64_C(6362944383825240401), UINT64_C(749068216750751732)},
        {/*114*/ UINT64_C(7953680479781550502), UINT64_C(936335270938439665)},
        {/*115*/ UINT64_C(16500265345931938823), UINT64_C(585209544336524790)},
        {/*116*/ UINT64_C(11401959645560147721), UINT64_C(731511930420655988)},
        {/*117*/ UINT64_C(14252449556950184652), UINT64_C(914389913025819985)},
        {/*118*/ UINT64_C(3980503890905567103), UINT64_C(1142987391282274982)},
        {/*119*/ UINT64_C(16322872987098143151), UINT64_C(714367119551421863)},
        {/*120*/ UINT64_C(15791905215445291035), UINT64_C(892958899439277329)},
        {/*121*/ UINT64_C(5904823464024450082), UINT64_C(1116198624299096662)},
        {/*122*/ UINT64_C(17525572720297445013), UINT64_C(697624140186935413)},
        {/*123*/ UINT64_C(8071907845089642554), UINT64_C(872030175233669267)},
        {/*124*/ UINT64_C(5478198787934665289), UINT64_C(1090037719042086584)},
        {/*125*/ UINT64_C(3423874242459165806), UINT64_C(681273574401304115)},
        {/*126*/ UINT64_C(18114900858356120969), UINT64_C(851591968001630143)},
        {/*127*/ UINT64_C(18031940054517763307), UINT64_C(1064489960002037679)},
        {/*128*/ UINT64_C(18187491561714683923), UINT64_C(665306225001273549)},
        {/*129*/ UINT64_C(8899306396861191192), UINT64_C(831632781251591937)},
        {/*130*/ UINT64_C(15735819014503876894), UINT64_C(1039540976564489921)},
        {/*131*/ UINT64_C(2917357856423841202), UINT64_C(649713110352806201)},
        {/*132*/ UINT64_C(8258383338957189407), UINT64_C(812141387941007751)},
        {/*133*/ UINT64_C(5711293155269098855), UINT64_C(1015176734926259689)},
        {/*134*/ UINT64_C(15098773268111656544), UINT64_C(634485459328912305)},
        {/*135*/ UINT64_C(5038408529857406968), UINT64_C(793106824161140382)},
        {/*136*/ UINT64_C(15521382699176534519), UINT64_C(991383530201425477)},
        {/*137*/ UINT64_C(12006707196199028026), UINT64_C(619614706375890923)},
        {/*138*/ UINT64_C(10396697976821397129), UINT64_C(774518382969863654)},
        {/*139*/ UINT64_C(3772500434171970603), UINT64_C(968147978712329568)},
        {/*140*/ UINT64_C(2357812771357481627), UINT64_C(605092486695205980)},
        {/*141*/ UINT64_C(2947265964196852033), UINT64_C(756365608369007475)},
        {/*142*/ UINT64_C(17519140510528228754), UINT64_C(945457010461259343)},
        {/*143*/ UINT64_C(17866991846721224827), UINT64_C(590910631538287089)},
        {/*144*/ UINT64_C(8498681753119367322), UINT64_C(738638289422858862)},
        {/*145*/ UINT64_C(1399980154544433344), UINT64_C(923297861778573578)},
        {/*146*/ UINT64_C(5486673615017658744), UINT64_C(577061163611608486)},
        {/*147*/ UINT64_C(16081714055626849238), UINT64_C(721326454514510607)},
        {/*148*/ UINT64_C(15490456551106173644), UINT64_C(901658068143138259)},
        {/*149*/ UINT64_C(14751384670455329151), UINT64_C(1127072585178922824)},
        {/*150*/ UINT64_C(9219615419034580719), UINT64_C(704420365736826765)},
        {/*151*/ UINT64_C(16136205292220613803), UINT64_C(880525457171033456)},
        {/*152*/ UINT64_C(1723512541566215638), UINT64_C(1100656821463791821)},
        {/*153*/ UINT64_C(3383038347692578726), UINT64_C(687910513414869888)},
        {/*154*/ UINT64_C(4228797934615723407), UINT64_C(859888141768587360)},
        {/*155*/ UINT64_C(5285997418269654259), UINT64_C(1074860177210734200)},
        {/*156*/ UINT64_C(3303748386418533912), UINT64_C(671787610756708875)},
        {/*157*/ UINT64_C(17964743538305331102), UINT64_C(839734513445886093)},
        {/*158*/ UINT64_C(8620871367599500165), UINT64_C(1049668141807357617)},
        {/*159*/ UINT64_C(16917259650818157363), UINT64_C(656042588629598510)},
        {/*160*/ UINT64_C(11923202526667920896), UINT64_C(820053235786998138)},
        {/*161*/ UINT64_C(5680631121480125312), UINT64_C(1025066544733747673)},
        {/*162*/ UINT64_C(15079609496993548080), UINT64_C(640666590458592295)},
        {/*163*/ UINT64_C(14237825852814547196), UINT64_C(800833238073240369)},
        {/*164*/ UINT64_C(3962224260736020283), UINT64_C(1001041547591550462)},
        {/*165*/ UINT64_C(16311448218242176389), UINT64_C(625650967244719038)},
        {/*166*/ UINT64_C(11165938235947944678), UINT64_C(782063709055898798)},
        {/*167*/ UINT64_C(4734050758080155040), UINT64_C(977579636319873498)},
        {/*168*/ UINT64_C(7570467742227484804), UINT64_C(610987272699920936)},
        {/*169*/ UINT64_C(9463084677784356005), UINT64_C(763734090874901170)},
        {/*170*/ UINT64_C(2605483810375669198), UINT64_C(954667613593626463)},
        {/*171*/ UINT64_C(8545956409125875105), UINT64_C(596667258496016539)},
        {/*172*/ UINT64_C(6070759492979955977), UINT64_C(745834073120020674)},
        {/*173*/ UINT64_C(16811821403079720779), UINT64_C(932292591400025842)},
        {/*174*/ UINT64_C(15119074395352213391), UINT64_C(582682869625016151)},
        {/*175*/ UINT64_C(14287156975762878835), UINT64_C(728353587031270189)},
        {/*176*/ UINT64_C(4023888164421434831), UINT64_C(910441983789087737)},
        {/*177*/ UINT64_C(9641546223954181443), UINT64_C(1138052479736359671)},
        {/*178*/ UINT64_C(12943495417612445258), UINT64_C(711282799835224794)},
        {/*179*/ UINT64_C(6955997235160780765), UINT64_C(889103499794030993)},
        {/*180*/ UINT64_C(13306682562378363860), UINT64_C(1111379374742538741)},
        {/*181*/ UINT64_C(10622519610700171364), UINT64_C(694612109214086713)},
        {/*182*/ UINT64_C(17889835531802602109), UINT64_C(868265136517608391)},
        {/*183*/ UINT64_C(17750608396325864733), UINT64_C(1085331420647010489)},
        {/*184*/ UINT64_C(4176601220062583602), UINT64_C(678332137904381556)},
        {/*185*/ UINT64_C(5220751525078229502), UINT64_C(847915172380476945)},
        {/*186*/ UINT64_C(11137625424775174782), UINT64_C(1059893965475596181)},
        {/*187*/ UINT64_C(9266858899698178191), UINT64_C(662433728422247613)},
        {/*188*/ UINT64_C(16195259643050110642), UINT64_C(828042160527809516)},
        {/*189*/ UINT64_C(1797330480103086687), UINT64_C(1035052700659761896)},
        {/*190*/ UINT64_C(1123331550064429179), UINT64_C(646907937912351185)},
        {/*191*/ UINT64_C(6015850456007924378), UINT64_C(808634922390438981)},
        {/*192*/ UINT64_C(12131499088437293377), UINT64_C(1010793652988048726)},
        {/*193*/ UINT64_C(2970500911845920456), UINT64_C(631746033117530454)},
        {/*194*/ UINT64_C(12936498176662176379), UINT64_C(789682541396913067)},
        {/*195*/ UINT64_C(11558936702400332569), UINT64_C(987103176746141334)},
        {/*196*/ UINT64_C(2612649420572819952), UINT64_C(616939485466338334)},
        {/*197*/ UINT64_C(12489183812570800748), UINT64_C(771174356832922917)},
        {/*198*/ UINT64_C(1776421710431337223), UINT64_C(963967946041153647)},
        {/*199*/ UINT64_C(8027792596660667620), UINT64_C(602479966275721029)},
        {/*200*/ UINT64_C(14646426764253222429), UINT64_C(753099957844651286)},
        {/*201*/ UINT64_C(9084661418461752229), UINT64_C(941374947305814108)},
        {/*202*/ UINT64_C(14901285423393370951), UINT64_C(588359342066133817)},
        {/*203*/ UINT64_C(4791548723959549977), UINT64_C(735449177582667272)},
        {/*204*/ UINT64_C(5989435904949437471), UINT64_C(919311471978334090)},
        {/*205*/ UINT64_C(16710166918041572647), UINT64_C(1149139339972917612)},
        {/*206*/ UINT64_C(1220482286921207096), UINT64_C(718212087483073508)},
        {/*207*/ UINT64_C(1525602858651508870), UINT64_C(897765109353841885)},
        {/*208*/ UINT64_C(6518689591741773992), UINT64_C(1122206386692302356)},
        {/*209*/ UINT64_C(13297553031693384553), UINT64_C(701378991682688972)},
        {/*210*/ UINT64_C(16621941289616730691), UINT64_C(876723739603361215)},
        {/*211*/ UINT64_C(16165740593593525460), UINT64_C(1095904674504201519)},
        {/*212*/ UINT64_C(17021116898637035268), UINT64_C(684940421565125949)},
        {/*213*/ UINT64_C(7441338068014130373), UINT64_C(856175526956407437)},
        {/*214*/ UINT64_C(13913358603445050871), UINT64_C(1070219408695509296)},
        {/*215*/ UINT64_C(8695849127153156794), UINT64_C(668887130434693310)},
        {/*216*/ UINT64_C(1646439372086670185), UINT64_C(836108913043366638)},
        {/*217*/ UINT64_C(11281421251963113539), UINT64_C(1045136141304208297)},
        {/*218*/ UINT64_C(133359254835864106), UINT64_C(653210088315130186)},
        {/*219*/ UINT64_C(9390071105399605940), UINT64_C(816512610393912732)},
        {/*220*/ UINT64_C(11737588881749507425), UINT64_C(1020640762992390915)},
        {/*221*/ UINT64_C(5030150041879748189), UINT64_C(637900476870244322)},
        {/*222*/ UINT64_C(15511059589204461044), UINT64_C(797375596087805402)},
        {/*223*/ UINT64_C(10165452449650800497), UINT64_C(996719495109756753)},
        {/*224*/ UINT64_C(17882622827100220070), UINT64_C(622949684443597970)},
        {/*225*/ UINT64_C(13129906497020499280), UINT64_C(778687105554497463)},
        {/*226*/ UINT64_C(11800697102848236196), UINT64_C(973358881943121829)},
        {/*227*/ UINT64_C(9681278698493841575), UINT64_C(608349301214451143)},
        {/*228*/ UINT64_C(7489912354689914064), UINT64_C(760436626518063929)},
        {/*229*/ UINT64_C(13974076461789780485), UINT64_C(950545783147579911)},
        {/*230*/ UINT64_C(15651326816259694659), UINT64_C(594091114467237444)},
        {/*231*/ UINT64_C(1117414446615066707), UINT64_C(742613893084046806)},
        {/*232*/ UINT64_C(10620140095123609192), UINT64_C(928267366355058507)},
        {/*233*/ UINT64_C(4331744550238561793), UINT64_C(580167103971911567)},
        {/*234*/ UINT64_C(802994669370814337), UINT64_C(725208879964889459)},
        {/*235*/ UINT64_C(14838801391995681634), UINT64_C(906511099956111823)},
        {/*236*/ UINT64_C(13936815721567214139), UINT64_C(1133138874945139779)},
        {/*237*/ UINT64_C(6404666816765814884), UINT64_C(708211796840712362)},
        {/*238*/ UINT64_C(17229205557812044414), UINT64_C(885264746050890452)},
        {/*239*/ UINT64_C(3089762873555503901), UINT64_C(1106580932563613066)},
        {/*240*/ UINT64_C(6542787814399577842), UINT64_C(691613082852258166)},
        {/*241*/ UINT64_C(17401856804854248111), UINT64_C(864516353565322707)},
        {/*242*/ UINT64_C(17140634987640422235), UINT64_C(1080645441956653384)},
        {/*243*/ UINT64_C(10712896867275263896), UINT64_C(675403401222908365)},
        {/*244*/ UINT64_C(18002807102521467775), UINT64_C(844254251528635456)},
        {/*245*/ UINT64_C(4056764804442283102), UINT64_C(1055317814410794321)},
        {/*246*/ UINT64_C(14064693048844896699), UINT64_C(659573634006746450)},
        {/*247*/ UINT64_C(8357494274201345066), UINT64_C(824467042508433063)},
        {/*248*/ UINT64_C(5835181824324293428), UINT64_C(1030583803135541329)},
        {/*249*/ UINT64_C(15176203686271153152), UINT64_C(644114876959713330)},
        {/*250*/ UINT64_C(9746882570984165633), UINT64_C(805143596199641663)},
        {/*251*/ UINT64_C(7571917195302819137), UINT64_C(1006429495249552079)},
        {/*252*/ UINT64_C(11649977274705343816), UINT64_C(629018434530970049)},
        {/*253*/ UINT64_C(727413538099516059), UINT64_C(786273043163712562)},
        {/*254*/ UINT64_C(10132638959479170881), UINT64_C(982841303954640702)},
        {/*255*/ UINT64_C(1721213331247093897), UINT64_C(614275814971650439)},
        {/*256*/ UINT64_C(15986574719341031083), UINT64_C(767844768714563048)},
        {/*257*/ UINT64_C(1536474325466737238), UINT64_C(959805960893203811)},
        {/*258*/ UINT64_C(17101197517912568437), UINT64_C(599878725558252381)},
        {/*259*/ UINT64_C(7541438842108546835), UINT64_C(749848406947815477)},
        {/*260*/ UINT64_C(14038484571063071448), UINT64_C(937310508684769346)},
        {/*261*/ UINT64_C(13385738875341807559), UINT64_C(585819067927980841)},
        {/*262*/ UINT64_C(2897115538895095736), UINT64_C(732273834909976052)},
        {/*263*/ UINT64_C(3621394423618869671), UINT64_C(915342293637470065)},
        {/*264*/ UINT64_C(9138429047950974993), UINT64_C(1144177867046837581)},
        {/*265*/ UINT64_C(8017361164183053322), UINT64_C(715111166904273488)},
        {/*266*/ UINT64_C(10021701455228816653), UINT64_C(893888958630341860)},
        {/*267*/ UINT64_C(12527126819036020816), UINT64_C(1117361198287927325)},
        {/*268*/ UINT64_C(10135297271111206962), UINT64_C(698350748929954578)},
        {/*269*/ UINT64_C(3445749552034232895), UINT64_C(872938436162443223)},
        {/*270*/ UINT64_C(18142244995324954830), UINT64_C(1091173045203054028)},
        {/*271*/ UINT64_C(2115531085223320961), UINT64_C(681983153251908768)},
        {/*272*/ UINT64_C(2644413856529151201), UINT64_C(852478941564885960)},
        {/*273*/ UINT64_C(3305517320661439001), UINT64_C(1065598676956107450)},
        {/*274*/ UINT64_C(6677634343840787280), UINT64_C(665999173097567156)},
        {/*275*/ UINT64_C(8347042929800984100), UINT64_C(832498966371958945)},
        {/*276*/ UINT64_C(15045489680678618029), UINT64_C(1040623707964948681)},
        {/*277*/ UINT64_C(2485902022783054412), UINT64_C(650389817478092926)},
        {/*278*/ UINT64_C(12330749565333593823), UINT64_C(812987271847616157)},
        {/*279*/ UINT64_C(1578378901384828567), UINT64_C(1016234089809520197)},
        {/*280*/ UINT64_C(3292329822579211806), UINT64_C(635146306130950123)},
        {/*281*/ UINT64_C(17950470333506178470), UINT64_C(793932882663687653)},
        {/*282*/ UINT64_C(8603029861600559375), UINT64_C(992416103329609567)},
        {/*283*/ UINT64_C(12294422691141431465), UINT64_C(620260064581005979)},
        {/*284*/ UINT64_C(10756342345499401428), UINT64_C(775325080726257474)},
        {/*285*/ UINT64_C(4222055895019475977), UINT64_C(969156350907821843)},
        {/*286*/ UINT64_C(332941925173478533), UINT64_C(605722719317388652)},
        {/*287*/ UINT64_C(416177406466848167), UINT64_C(757153399146735815)},
        {/*288*/ UINT64_C(14355279813365723921), UINT64_C(946441748933419768)},
        {/*289*/ UINT64_C(8972049883353577450), UINT64_C(591526093083387355)},
        {/*290*/ UINT64_C(6603376335764583909), UINT64_C(739407616354234194)},
        {/*291*/ UINT64_C(17477592456560505694), UINT64_C(924259520442792742)},
        {/*292*/ UINT64_C(6311809266922928155), UINT64_C(577662200276745464)},
        {/*293*/ UINT64_C(7889761583653660193), UINT64_C(722077750345931830)},
        {/*294*/ UINT64_C(638829942712299434), UINT64_C(902597187932414788)},
        {/*295*/ UINT64_C(798537428390374293), UINT64_C(1128246484915518485)},
        {/*296*/ UINT64_C(2804928901957677885), UINT64_C(705154053072199053)},
        {/*297*/ UINT64_C(8117847145874485260), UINT64_C(881442566340248816)},
        {/*298*/ UINT64_C(10147308932343106575), UINT64_C(1101803207925311020)},
        {/*299*/ UINT64_C(15565440119569217417), UINT64_C(688627004953319387)},
        {/*300*/ UINT64_C(14845114131034133868), UINT64_C(860783756191649234)},
        {/*301*/ UINT64_C(9333020626937891527), UINT64_C(1075979695239561543)},
        {/*302*/ UINT64_C(12750666919477264060), UINT64_C(672487309524725964)},
        {/*303*/ UINT64_C(15938333649346580075), UINT64_C(840609136905907455)},
        {/*304*/ UINT64_C(15311231043255837190), UINT64_C(1050761421132384319)},
        {/*305*/ UINT64_C(16487048429675980100), UINT64_C(656725888207740199)},
        {/*306*/ UINT64_C(15997124518667587221), UINT64_C(820907360259675249)},
        {/*307*/ UINT64_C(6161347593052320314), UINT64_C(1026134200324594062)},
        {/*308*/ UINT64_C(17685900300939863908), UINT64_C(641333875202871288)},
        {/*309*/ UINT64_C(3660631302465278269), UINT64_C(801667344003589111)},
        {/*310*/ UINT64_C(18410847183363761549), UINT64_C(1002084180004486388)},
        {/*311*/ UINT64_C(2283407452747575160), UINT64_C(626302612502803993)},
        {/*312*/ UINT64_C(7465945334361856854), UINT64_C(782878265628504991)},
        {/*313*/ UINT64_C(4720745649524933163), UINT64_C(978597832035631239)},
        {/*314*/ UINT64_C(9867995058594165083), UINT64_C(611623645022269524)},
        {/*315*/ UINT64_C(12334993823242706354), UINT64_C(764529556277836905)},
        {/*316*/ UINT64_C(1583684223771219230), UINT64_C(955661945347296132)},
        {/*317*/ UINT64_C(10213174676711787827), UINT64_C(597288715842060082)},
        {/*318*/ UINT64_C(3543096309034958976), UINT64_C(746610894802575103)},
        {/*319*/ UINT64_C(18263928441575862432), UINT64_C(933263618503218878)},
        {/*320*/ UINT64_C(6803269257557526116), UINT64_C(583289761564511799)},
        {/*321*/ UINT64_C(3892400553519519741), UINT64_C(729112201955639749)},
        {/*322*/ UINT64_C(9477186710326787580), UINT64_C(911390252444549686)},
        {/*323*/ UINT64_C(2623111351053708667), UINT64_C(1139237815555687108)},
        {/*324*/ UINT64_C(10862816631263343725), UINT64_C(712023634722304442)},
        {/*325*/ UINT64_C(4355148752224403848), UINT64_C(890029543402880553)}
    };
    return &data[index][0];
  }

  static const uint64_t* greater_than_equals(int index) {
    static const uint64_t data[291][2] = {
        {/*  0*/ UINT64_C(0), UINT64_C(1152921504606846976)},
        {/*  1*/ UINT64_C(14757395258967641292), UINT64_C(922337203685477580)},
        {/*  2*/ UINT64_C(11805916207174113034), UINT64_C(737869762948382064)},
        {/*  3*/ UINT64_C(13134081780481200750), UINT64_C(590295810358705651)},
        {/*  4*/ UINT64_C(13635833219286100554), UINT64_C(944473296573929042)},
        {/*  5*/ UINT64_C(3529968945945059797), UINT64_C(755578637259143234)},
        {/*  6*/ UINT64_C(6513323971497958160), UINT64_C(604462909807314587)},
        {/*  7*/ UINT64_C(14110667169138643380), UINT64_C(967140655691703339)},
        {/*  8*/ UINT64_C(14977882550052825027), UINT64_C(773712524553362671)},
        {/*  9*/ UINT64_C(8292957225300349699), UINT64_C(618970019642690137)},
        {/* 10*/ UINT64_C(16958080375222469841), UINT64_C(990352031428304219)},
        {/* 11*/ UINT64_C(17255813114919886196), UINT64_C(792281625142643375)},
        {/* 12*/ UINT64_C(13804650491935908957), UINT64_C(633825300114114700)},
        {/* 13*/ UINT64_C(3640696713387902715), UINT64_C(1014120480182583521)},
        {/* 14*/ UINT64_C(17669952629677963465), UINT64_C(811296384146066816)},
        {/* 15*/ UINT64_C(10446613289000460449), UINT64_C(649037107316853453)},
        {/* 16*/ UINT64_C(13025232447658826395), UINT64_C(1038459371706965525)},
        {/* 17*/ UINT64_C(10420185958127061116), UINT64_C(830767497365572420)},
        {/* 18*/ UINT64_C(8336148766501648892), UINT64_C(664613997892457936)},
        {/* 19*/ UINT64_C(5959140396918817582), UINT64_C(1063382396627932698)},
        {/* 20*/ UINT64_C(12146009947018874712), UINT64_C(850705917302346158)},
        {/* 21*/ UINT64_C(17095505587098920416), UINT64_C(680564733841876926)},
        {/* 22*/ UINT64_C(1527367236164900403), UINT64_C(1088903574147003083)},
        {/* 23*/ UINT64_C(8600591418415740969), UINT64_C(871122859317602466)},
        {/* 24*/ UINT64_C(3191124319990682452), UINT64_C(696898287454081973)},
        {/* 25*/ UINT64_C(1416450097243181600), UINT64_C(1115037259926531157)},
        {/* 26*/ UINT64_C(12201206522020276249), UINT64_C(892029807941224925)},
        {/* 27*/ UINT64_C(9760965217616220999), UINT64_C(713623846352979940)},
        {/* 28*/ UINT64_C(15617544348185953599), UINT64_C(1141798154164767904)},
        {/* 29*/ UINT64_C(16183384293290673203), UINT64_C(913438523331814323)},
        {/* 30*/ UINT64_C(1878660990406807592), UINT64_C(730750818665451459)},
        {/* 31*/ UINT64_C(5192277607067356397), UINT64_C(584600654932361167)},
        {/* 32*/ UINT64_C(11996992986049680559), UINT64_C(935361047891777867)},
        {/* 33*/ UINT64_C(2218896759355923800), UINT64_C(748288838313422294)},
        {/* 34*/ UINT64_C(5464466222226649363), UINT64_C(598631070650737835)},
        {/* 35*/ UINT64_C(8743145955562638982), UINT64_C(957809713041180536)},
        {/* 36*/ UINT64_C(3305167949708200862), UINT64_C(766247770432944429)},
        {/* 37*/ UINT64_C(6333483174508471013), UINT64_C(612998216346355543)},
        {/* 38*/ UINT64_C(6444224264471643298), UINT64_C(980797146154168869)},
        {/* 39*/ UINT64_C(8844728226319224961), UINT64_C(784637716923335095)},
        {/* 40*/ UINT64_C(7075782581055379969), UINT64_C(627710173538668076)},
        {/* 41*/ UINT64_C(3942554500204787304), UINT64_C(1004336277661868922)},
        {/* 42*/ UINT64_C(14222090044389560813), UINT64_C(803469022129495137)},
        {/* 43*/ UINT64_C(3998974406027828004), UINT64_C(642775217703596110)},
        {/* 44*/ UINT64_C(6398359049644524806), UINT64_C(1028440348325753776)},
        {/* 45*/ UINT64_C(1429338424973709522), UINT64_C(822752278660603021)},
        {/* 46*/ UINT64_C(15900865998946608910), UINT64_C(658201822928482416)},
        {/* 47*/ UINT64_C(18062687968830753610), UINT64_C(1053122916685571866)},
        {/* 48*/ UINT64_C(10760801560322692565), UINT64_C(842498333348457493)},
        {/* 49*/ UINT64_C(15987338877741974698), UINT64_C(673998666678765994)},
        {/* 50*/ UINT64_C(14511695760161428548), UINT64_C(1078397866686025591)},
        {/* 51*/ UINT64_C(7920007793387232515), UINT64_C(862718293348820473)},
        {/* 52*/ UINT64_C(13714703864193606658), UINT64_C(690174634679056378)},
        {/* 53*/ UINT64_C(18254177367967860330), UINT64_C(1104279415486490205)},
        {/* 54*/ UINT64_C(14603341894374288264), UINT64_C(883423532389192164)},
        {/* 55*/ UINT64_C(15372022330241340934), UINT64_C(706738825911353731)},
        {/* 56*/ UINT64_C(17216538098902324849), UINT64_C(1130782121458165970)},
        {/* 57*/ UINT64_C(13773230479121859879), UINT64_C(904625697166532776)},
        {/* 58*/ UINT64_C(7329235568555577580), UINT64_C(723700557733226221)},
        {/* 59*/ UINT64_C(2174039640102551741), UINT64_C(578960446186580977)},
        {/* 60*/ UINT64_C(7167812238905993108), UINT64_C(926336713898529563)},
        {/* 61*/ UINT64_C(13112947420608615133), UINT64_C(741069371118823650)},
        {/* 62*/ UINT64_C(10490357936486892106), UINT64_C(592855496895058920)},
        {/* 63*/ UINT64_C(16784572698379027370), UINT64_C(948568795032094272)},
        {/* 64*/ UINT64_C(6048960529219401250), UINT64_C(758855036025675418)},
        {/* 65*/ UINT64_C(12217866052859341646), UINT64_C(607084028820540334)},
        {/* 66*/ UINT64_C(8480539240349215664), UINT64_C(971334446112864535)},
        {/* 67*/ UINT64_C(6784431392279372531), UINT64_C(777067556890291628)},
        {/* 68*/ UINT64_C(12806242743307318671), UINT64_C(621654045512233302)},
        {/* 69*/ UINT64_C(5732593130324068582), UINT64_C(994646472819573284)},
        {/* 70*/ UINT64_C(8275423319001165189), UINT64_C(795717178255658627)},
        {/* 71*/ UINT64_C(17688385099426663120), UINT64_C(636573742604526901)},
        {/* 72*/ UINT64_C(2475974455889288731), UINT64_C(1018517988167243043)},
        {/* 73*/ UINT64_C(9359477194195251631), UINT64_C(814814390533794434)},
        {/* 74*/ UINT64_C(11176930570098111628), UINT64_C(651851512427035547)},
        {/* 75*/ UINT64_C(3125693653189337312), UINT64_C(1042962419883256876)},
        {/* 76*/ UINT64_C(17257950181519111142), UINT64_C(834369935906605500)},
        {/* 77*/ UINT64_C(13806360145215288914), UINT64_C(667495948725284400)},
        {/* 78*/ UINT64_C(3643432158634910646), UINT64_C(1067993517960455041)},
        {/* 79*/ UINT64_C(17672140985875569810), UINT64_C(854394814368364032)},
        {/* 80*/ UINT64_C(6759015159216635201), UINT64_C(683515851494691226)},
        {/* 81*/ UINT64_C(3435726625262795676), UINT64_C(1093625362391505962)},
        {/* 82*/ UINT64_C(13816627744435967510), UINT64_C(874900289913204769)},
        {/* 83*/ UINT64_C(14742651010290684331), UINT64_C(699920231930563815)},
        {/* 84*/ UINT64_C(5141497542755543314), UINT64_C(1119872371088902105)},
        {/* 85*/ UINT64_C(4113198034204434651), UINT64_C(895897896871121684)},
        {/* 86*/ UINT64_C(6979907242105458044), UINT64_C(716718317496897347)},
        {/* 87*/ UINT64_C(14857200402110643194), UINT64_C(1146749307995035755)},
        {/* 88*/ UINT64_C(11885760321688514555), UINT64_C(917399446396028604)},
        {/* 89*/ UINT64_C(13197957072092721967), UINT64_C(733919557116822883)},
        {/* 90*/ UINT64_C(17937063287157998220), UINT64_C(587135645693458306)},
        {/* 91*/ UINT64_C(2873859556259424890), UINT64_C(939417033109533291)},
        {/* 92*/ UINT64_C(17056482903975181205), UINT64_C(751533626487626632)},
        {/* 93*/ UINT64_C(6266488693696324317), UINT64_C(601226901190101306)},
        {/* 94*/ UINT64_C(2647684280430298261), UINT64_C(961963041904162090)},
        {/* 95*/ UINT64_C(2118147424344238609), UINT64_C(769570433523329672)},
        {/* 96*/ UINT64_C(12762564383701121857), UINT64_C(615656346818663737)},
        {/* 97*/ UINT64_C(5662707754954153678), UINT64_C(985050154909861980)},
        {/* 98*/ UINT64_C(4530166203963322943), UINT64_C(788040123927889584)},
        {/* 99*/ UINT64_C(7313481777912568677), UINT64_C(630432099142311667)},
        {/*100*/ UINT64_C(15390919659402020207), UINT64_C(1008691358627698667)},
        {/*101*/ UINT64_C(4934038098037795519), UINT64_C(806953086902158934)},
        {/*102*/ UINT64_C(7636579293172146738), UINT64_C(645562469521727147)},
        {/*103*/ UINT64_C(15907875683817345105), UINT64_C(1032899951234763435)},
        {/*104*/ UINT64_C(12726300547053876084), UINT64_C(826319960987810748)},
        {/*105*/ UINT64_C(17559738067126921513), UINT64_C(661055968790248598)},
        {/*106*/ UINT64_C(5959488018951612482), UINT64_C(1057689550064397758)},
        {/*107*/ UINT64_C(12146288044645110632), UINT64_C(846151640051518206)},
        {/*108*/ UINT64_C(6027681620974178182), UINT64_C(676921312041214565)},
        {/*109*/ UINT64_C(9644290593558685092), UINT64_C(1083074099265943304)},
        {/*110*/ UINT64_C(11404781289588858397), UINT64_C(866459279412754643)},
        {/*111*/ UINT64_C(16502522661154907364), UINT64_C(693167423530203714)},
        {/*112*/ UINT64_C(15335989813622120813), UINT64_C(1109067877648325943)},
        {/*113*/ UINT64_C(1200745406671965681), UINT64_C(887254302118660755)},
        {/*114*/ UINT64_C(960596325337572544), UINT64_C(709803441694928604)},
        {/*115*/ UINT64_C(8915651750023936718), UINT64_C(1135685506711885766)},
        {/*116*/ UINT64_C(3443172585277239051), UINT64_C(908548405369508613)},
        {/*117*/ UINT64_C(10133235697705611887), UINT64_C(726838724295606890)},
        {/*118*/ UINT64_C(8106588558164489509), UINT64_C(581470979436485512)},
        {/*119*/ UINT64_C(16659890507805093539), UINT64_C(930353567098376819)},
        {/*120*/ UINT64_C(17017261220985985154), UINT64_C(744282853678701455)},
        {/*121*/ UINT64_C(13613808976788788123), UINT64_C(595426282942961164)},
        {/*122*/ UINT64_C(10714047918636330028), UINT64_C(952682052708737863)},
        {/*123*/ UINT64_C(15949935964392884668), UINT64_C(762145642166990290)},
        {/*124*/ UINT64_C(12759948771514307735), UINT64_C(609716513733592232)},
        {/*125*/ UINT64_C(5658522775455251083), UINT64_C(975546421973747572)},
        {/*126*/ UINT64_C(15594864664589931836), UINT64_C(780437137578998057)},
        {/*127*/ UINT64_C(5097194102188124822), UINT64_C(624349710063198446)},
        {/*128*/ UINT64_C(776812934017179069), UINT64_C(998959536101117514)},
        {/*129*/ UINT64_C(4310799161955653579), UINT64_C(799167628880894011)},
        {/*130*/ UINT64_C(18206034588532164156), UINT64_C(639334103104715208)},
        {/*131*/ UINT64_C(6993562453200000710), UINT64_C(1022934564967544334)},
        {/*132*/ UINT64_C(9284198777301910891), UINT64_C(818347651974035467)},
        {/*133*/ UINT64_C(48661392357708066), UINT64_C(654678121579228374)},
        {/*134*/ UINT64_C(7456555857256153553), UINT64_C(1047484994526765398)},
        {/*135*/ UINT64_C(13343942315288743489), UINT64_C(837987995621412318)},
        {/*136*/ UINT64_C(18053851481714815437), UINT64_C(670390396497129854)},
        {/*137*/ UINT64_C(17818115926517973730), UINT64_C(1072624634395407767)},
        {/*138*/ UINT64_C(6875795111730558338), UINT64_C(858099707516326214)},
        {/*139*/ UINT64_C(9189984904126356993), UINT64_C(686479766013060971)},
        {/*140*/ UINT64_C(7325278217118350543), UINT64_C(1098367625620897554)},
        {/*141*/ UINT64_C(9549571388436590758), UINT64_C(878694100496718043)},
        {/*142*/ UINT64_C(15018354740233093252), UINT64_C(702955280397374434)},
        {/*143*/ UINT64_C(12961321140147218235), UINT64_C(1124728448635799095)},
        {/*144*/ UINT64_C(10369056912117774588), UINT64_C(899782758908639276)},
        {/*145*/ UINT64_C(4605896714952309347), UINT64_C(719826207126911421)},
        {/*146*/ UINT64_C(18437481188149425925), UINT64_C(1151721931403058273)},
        {/*147*/ UINT64_C(3681938506293809770), UINT64_C(921377545122446619)},
        {/*148*/ UINT64_C(6634899619776958139), UINT64_C(737102036097957295)},
        {/*149*/ UINT64_C(5307919695821566511), UINT64_C(589681628878365836)},
        {/*150*/ UINT64_C(1113973883830685772), UINT64_C(943490606205385338)},
        {/*151*/ UINT64_C(8269876736548369264), UINT64_C(754792484964308270)},
        {/*152*/ UINT64_C(6615901389238695411), UINT64_C(603833987971446616)},
        {/*153*/ UINT64_C(3206744593298092011), UINT64_C(966134380754314586)},
        {/*154*/ UINT64_C(17322790933606114902), UINT64_C(772907504603451668)},
        {/*155*/ UINT64_C(2790186302659160952), UINT64_C(618326003682761335)},
        {/*156*/ UINT64_C(4464298084254657523), UINT64_C(989321605892418136)},
        {/*157*/ UINT64_C(18328833726371367311), UINT64_C(791457284713934508)},
        {/*158*/ UINT64_C(3595020536871362879), UINT64_C(633165827771147607)},
        {/*159*/ UINT64_C(9441381673736090930), UINT64_C(1013065324433836171)},
        {/*160*/ UINT64_C(3863756524246962421), UINT64_C(810452259547068937)},
        {/*161*/ UINT64_C(14159051663623300906), UINT64_C(648361807637655149)},
        {/*162*/ UINT64_C(11586436217571550481), UINT64_C(1037378892220248239)},
        {/*163*/ UINT64_C(12958497788799150708), UINT64_C(829903113776198591)},
        {/*164*/ UINT64_C(6677449416297410243), UINT64_C(663922491020958873)},
        {/*165*/ UINT64_C(6994570251333946066), UINT64_C(1062275985633534197)},
        {/*166*/ UINT64_C(16663702645292887822), UINT64_C(849820788506827357)},
        {/*167*/ UINT64_C(5952264486750489611), UINT64_C(679856630805461886)},
        {/*168*/ UINT64_C(2144925549316962732), UINT64_C(1087770609288739018)},
        {/*169*/ UINT64_C(9094638068937390832), UINT64_C(870216487430991214)},
        {/*170*/ UINT64_C(10965059269891822988), UINT64_C(696173189944792971)},
        {/*171*/ UINT64_C(10165397202343096135), UINT64_C(1113877103911668754)},
        {/*172*/ UINT64_C(11821666576616387231), UINT64_C(891101683129335003)},
        {/*173*/ UINT64_C(16836030890776930431), UINT64_C(712881346503468002)},
        {/*174*/ UINT64_C(12180254166275447398), UINT64_C(1140610154405548804)},
        {/*175*/ UINT64_C(13433552147762268241), UINT64_C(912488123524439043)},
        {/*176*/ UINT64_C(18125539347693635239), UINT64_C(729990498819551234)},
        {/*177*/ UINT64_C(18189780292896818515), UINT64_C(583992399055640987)},
        {/*178*/ UINT64_C(14346253209667268331), UINT64_C(934387838489025580)},
        {/*179*/ UINT64_C(11477002567733814665), UINT64_C(747510270791220464)},
        {/*180*/ UINT64_C(12870950868928962055), UINT64_C(598008216632976371)},
        {/*181*/ UINT64_C(13214823760802518641), UINT64_C(956813146612762194)},
        {/*182*/ UINT64_C(14261207823383925236), UINT64_C(765450517290209755)},
        {/*183*/ UINT64_C(11408966258707140189), UINT64_C(612360413832167804)},
        {/*184*/ UINT64_C(7186299569705693333), UINT64_C(979776662131468487)},
        {/*185*/ UINT64_C(16817086099990285636), UINT64_C(783821329705174789)},
        {/*186*/ UINT64_C(17143017694734138832), UINT64_C(627057063764139831)},
        {/*187*/ UINT64_C(1603386608381249869), UINT64_C(1003291302022623731)},
        {/*188*/ UINT64_C(16040104545672641188), UINT64_C(802633041618098984)},
        {/*189*/ UINT64_C(16521432451280023273), UINT64_C(642106433294479187)},
        {/*190*/ UINT64_C(11676896663080395945), UINT64_C(1027370293271166700)},
        {/*191*/ UINT64_C(9341517330464316756), UINT64_C(821896234616933360)},
        {/*192*/ UINT64_C(7473213864371453404), UINT64_C(657516987693546688)},
        {/*193*/ UINT64_C(8267793368252415124), UINT64_C(1052027180309674701)},
        {/*194*/ UINT64_C(2924885879860021776), UINT64_C(841621744247739761)},
        {/*195*/ UINT64_C(17097303962855658714), UINT64_C(673297395398191808)},
        {/*196*/ UINT64_C(5219593452117592003), UINT64_C(1077275832637106894)},
        {/*197*/ UINT64_C(7865023576435983925), UINT64_C(861820666109685515)},
        {/*198*/ UINT64_C(6292018861148787140), UINT64_C(689456532887748412)},
        {/*199*/ UINT64_C(13756578992579969748), UINT64_C(1103130452620397459)},
        {/*200*/ UINT64_C(14694612008805886121), UINT64_C(882504362096317967)},
        {/*201*/ UINT64_C(4376991977560888251), UINT64_C(706003489677054374)},
        {/*202*/ UINT64_C(14381884793581241848), UINT64_C(1129605583483286998)},
        {/*203*/ UINT64_C(437461390639262508), UINT64_C(903684466786629599)},
        {/*204*/ UINT64_C(4039317927253320330), UINT64_C(722947573429303679)},
        {/*205*/ UINT64_C(6920803156544566587), UINT64_C(578358058743442943)},
        {/*206*/ UINT64_C(7383936235729396216), UINT64_C(925372893989508709)},
        {/*207*/ UINT64_C(9596497803325427296), UINT64_C(740298315191606967)},
        {/*208*/ UINT64_C(298500613176521190), UINT64_C(592238652153285574)},
        {/*209*/ UINT64_C(7856298610566254551), UINT64_C(947581843445256918)},
        {/*210*/ UINT64_C(13663736517936824287), UINT64_C(758065474756205534)},
        {/*211*/ UINT64_C(14620338029091369753), UINT64_C(606452379804964427)},
        {/*212*/ UINT64_C(8635145587578550312), UINT64_C(970323807687943084)},
        {/*213*/ UINT64_C(10597465284804750573), UINT64_C(776259046150354467)},
        {/*214*/ UINT64_C(1099274598359979812), UINT64_C(621007236920283574)},
        {/*215*/ UINT64_C(9137536986859788346), UINT64_C(993611579072453718)},
        {/*216*/ UINT64_C(14688727218971651323), UINT64_C(794889263257962974)},
        {/*217*/ UINT64_C(15440330589919231381), UINT64_C(635911410606370379)},
        {/*218*/ UINT64_C(13636482499645039241), UINT64_C(1017458256970192607)},
        {/*219*/ UINT64_C(3530488370232210746), UINT64_C(813966605576154086)},
        {/*220*/ UINT64_C(17581785955153409890), UINT64_C(651173284460923268)},
        {/*221*/ UINT64_C(5994764639793993884), UINT64_C(1041877255137477230)},
        {/*222*/ UINT64_C(4795811711835195107), UINT64_C(833501804109981784)},
        {/*223*/ UINT64_C(7525998184210066409), UINT64_C(666801443287985427)},
        {/*224*/ UINT64_C(15730945909478016578), UINT64_C(1066882309260776683)},
        {/*225*/ UINT64_C(1516710283356682293), UINT64_C(853505847408621347)},
        {/*226*/ UINT64_C(12281414670911076804), UINT64_C(682804677926897077)},
        {/*227*/ UINT64_C(4892868214490081593), UINT64_C(1092487484683035324)},
        {/*228*/ UINT64_C(7603643386333975598), UINT64_C(873989987746428259)},
        {/*229*/ UINT64_C(9772263523809090801), UINT64_C(699191990197142607)},
        {/*230*/ UINT64_C(878226379126903990), UINT64_C(1118707184315428172)},
        {/*231*/ UINT64_C(11770627547527254161), UINT64_C(894965747452342537)},
        {/*232*/ UINT64_C(2037804408537982682), UINT64_C(715972597961874030)},
        {/*233*/ UINT64_C(3260487053660772292), UINT64_C(1145556156738998448)},
        {/*234*/ UINT64_C(9987087272412438480), UINT64_C(916444925391198758)},
        {/*235*/ UINT64_C(15368367447413771430), UINT64_C(733155940312959006)},
        {/*236*/ UINT64_C(8605345143189106821), UINT64_C(586524752250367205)},
        {/*237*/ UINT64_C(13768552229102570914), UINT64_C(938439603600587528)},
        {/*238*/ UINT64_C(18393539412765877377), UINT64_C(750751682880470022)},
        {/*239*/ UINT64_C(7336133900728881255), UINT64_C(600601346304376018)},
        {/*240*/ UINT64_C(8048465426424299686), UINT64_C(960962154087001629)},
        {/*241*/ UINT64_C(10128121155881350072), UINT64_C(768769723269601303)},
        {/*242*/ UINT64_C(15481194554188900704), UINT64_C(615015778615681042)},
        {/*243*/ UINT64_C(10012516027734599833), UINT64_C(984025245785089668)},
        {/*244*/ UINT64_C(15388710451671500513), UINT64_C(787220196628071734)},
        {/*245*/ UINT64_C(16000317176079110734), UINT64_C(629776157302457387)},
        {/*246*/ UINT64_C(10843112222758935881), UINT64_C(1007641851683931820)},
        {/*247*/ UINT64_C(8674489778207148705), UINT64_C(806113481347145456)},
        {/*248*/ UINT64_C(3250243007823808641), UINT64_C(644890785077716365)},
        {/*249*/ UINT64_C(5200388812518093825), UINT64_C(1031825256124346184)},
        {/*250*/ UINT64_C(7849659864756385383), UINT64_C(825460204899476947)},
        {/*251*/ UINT64_C(17347774336030839276), UINT64_C(660368163919581557)},
        {/*252*/ UINT64_C(12999043678681701549), UINT64_C(1056589062271330492)},
        {/*253*/ UINT64_C(3020537313461540593), UINT64_C(845271249817064394)},
        {/*254*/ UINT64_C(6105778665511142797), UINT64_C(676216999853651515)},
        {/*255*/ UINT64_C(9769245864817828476), UINT64_C(1081947199765842424)},
        {/*256*/ UINT64_C(11504745506596173104), UINT64_C(865557759812673939)},
        {/*257*/ UINT64_C(12893145220018848806), UINT64_C(692446207850139151)},
        {/*258*/ UINT64_C(13250334722546337444), UINT64_C(1107913932560222642)},
        {/*259*/ UINT64_C(3221570148553249309), UINT64_C(886331146048178114)},
        {/*260*/ UINT64_C(6266604933584509770), UINT64_C(709064916838542491)},
        {/*261*/ UINT64_C(2647870264251394986), UINT64_C(1134503866941667986)},
        {/*262*/ UINT64_C(16875691470368757282), UINT64_C(907603093553334388)},
        {/*263*/ UINT64_C(2432506732069274856), UINT64_C(726082474842667511)},
        {/*264*/ UINT64_C(16703400644623061177), UINT64_C(580865979874134008)},
        {/*265*/ UINT64_C(4589348142945435944), UINT64_C(929385567798614414)},
        {/*266*/ UINT64_C(7360827329098259079), UINT64_C(743508454238891531)},
        {/*267*/ UINT64_C(2199313048536696940), UINT64_C(594806763391113225)},
        {/*268*/ UINT64_C(3518900877658715104), UINT64_C(951690821425781160)},
        {/*269*/ UINT64_C(2815120702126972083), UINT64_C(761352657140624928)},
        {/*270*/ UINT64_C(9630794191185398313), UINT64_C(609082125712499942)},
        {/*271*/ UINT64_C(651875446928996008), UINT64_C(974531401139999908)},
        {/*272*/ UINT64_C(7900197987027017452), UINT64_C(779625120911999926)},
        {/*273*/ UINT64_C(2630809574879703639), UINT64_C(623700096729599941)},
        {/*274*/ UINT64_C(15277341764033256792), UINT64_C(997920154767359905)},
        {/*275*/ UINT64_C(12221873411226605433), UINT64_C(798336123813887924)},
        {/*276*/ UINT64_C(13466847543723194670), UINT64_C(638668899051110339)},
        {/*277*/ UINT64_C(10478909625731380502), UINT64_C(1021870238481776543)},
        {/*278*/ UINT64_C(15761825330068925048), UINT64_C(817496190785421234)},
        {/*279*/ UINT64_C(16298809078797050362), UINT64_C(653996952628336987)},
        {/*280*/ UINT64_C(11320699267107639286), UINT64_C(1046395124205339180)},
        {/*281*/ UINT64_C(9056559413686111429), UINT64_C(837116099364271344)},
        {/*282*/ UINT64_C(10934596345690799466), UINT64_C(669692879491417075)},
        {/*283*/ UINT64_C(17495354153105279146), UINT64_C(1071508607186267320)},
        {/*284*/ UINT64_C(13996283322484223317), UINT64_C(857206885749013856)},
        {/*285*/ UINT64_C(7507677843245468330), UINT64_C(685765508599211085)},
        {/*286*/ UINT64_C(12012284549192749328), UINT64_C(1097224813758737736)},
        {/*287*/ UINT64_C(5920478824612289139), UINT64_C(877779851006990189)},
        {/*288*/ UINT64_C(8425731874431741635), UINT64_C(702223880805592151)},
        {/*289*/ UINT64_C(6102473369606965969), UINT64_C(1123558209288947442)},
        {/*290*/ UINT64_C(15950025139911303745), UINT64_C(898846567431157953)}
    };
    return &data[index][0];
  }
};

template <> struct cache_values<float> {
  constexpr static const int b0 = 59;
  constexpr static const int b1 = 61;

  static const uint64_t* less_than(int index) {
    static const uint64_t data[48] = {
        /*  0*/ UINT64_C(2305843009213693952), /*  1*/ UINT64_C(1441151880758558720),
        /*  2*/ UINT64_C(1801439850948198400), /*  3*/ UINT64_C(2251799813685248000),
        /*  4*/ UINT64_C(1407374883553280000), /*  5*/ UINT64_C(1759218604441600000),
        /*  6*/ UINT64_C(2199023255552000000), /*  7*/ UINT64_C(1374389534720000000),
        /*  8*/ UINT64_C(1717986918400000000), /*  9*/ UINT64_C(2147483648000000000),
        /* 10*/ UINT64_C(1342177280000000000), /* 11*/ UINT64_C(1677721600000000000),
        /* 12*/ UINT64_C(2097152000000000000), /* 13*/ UINT64_C(1310720000000000000),
        /* 14*/ UINT64_C(1638400000000000000), /* 15*/ UINT64_C(2048000000000000000),
        /* 16*/ UINT64_C(1280000000000000000), /* 17*/ UINT64_C(1600000000000000000),
        /* 18*/ UINT64_C(2000000000000000000), /* 19*/ UINT64_C(1250000000000000000),
        /* 20*/ UINT64_C(1562500000000000000), /* 21*/ UINT64_C(1953125000000000000),
        /* 22*/ UINT64_C(1220703125000000000), /* 23*/ UINT64_C(1525878906250000000),
        /* 24*/ UINT64_C(1907348632812500000), /* 25*/ UINT64_C(1192092895507812500),
        /* 26*/ UINT64_C(1490116119384765625), /* 27*/ UINT64_C(1862645149230957031),
        /* 28*/ UINT64_C(1164153218269348144), /* 29*/ UINT64_C(1455191522836685180),
        /* 30*/ UINT64_C(1818989403545856475), /* 31*/ UINT64_C(2273736754432320594),
        /* 32*/ UINT64_C(1421085471520200371), /* 33*/ UINT64_C(1776356839400250464),
        /* 34*/ UINT64_C(2220446049250313080), /* 35*/ UINT64_C(1387778780781445675),
        /* 36*/ UINT64_C(1734723475976807094), /* 37*/ UINT64_C(2168404344971008868),
        /* 38*/ UINT64_C(1355252715606880542), /* 39*/ UINT64_C(1694065894508600678),
        /* 40*/ UINT64_C(2117582368135750847), /* 41*/ UINT64_C(1323488980084844279),
        /* 42*/ UINT64_C(1654361225106055349), /* 43*/ UINT64_C(2067951531382569187),
        /* 44*/ UINT64_C(1292469707114105741), /* 45*/ UINT64_C(1615587133892632177),
        /* 46*/ UINT64_C(2019483917365790221), /* 47*/ UINT64_C(1262177448353618888)
    };
    return &data[index];
  }

  static const uint64_t* greater_than_equals(int index) {
    static const uint64_t data[30] = {
        /*  0*/ UINT64_C(576460752303423488), /*  1*/ UINT64_C(461168601842738790),
        /*  2*/ UINT64_C(368934881474191032), /*  3*/ UINT64_C(295147905179352825),
        /*  4*/ UINT64_C(472236648286964521), /*  5*/ UINT64_C(377789318629571617),
        /*  6*/ UINT64_C(302231454903657293), /*  7*/ UINT64_C(483570327845851669),
        /*  8*/ UINT64_C(386856262276681335), /*  9*/ UINT64_C(309485009821345068),
        /* 10*/ UINT64_C(495176015714152109), /* 11*/ UINT64_C(396140812571321687),
        /* 12*/ UINT64_C(316912650057057350), /* 13*/ UINT64_C(507060240091291760),
        /* 14*/ UINT64_C(405648192073033408), /* 15*/ UINT64_C(324518553658426726),
        /* 16*/ UINT64_C(519229685853482762), /* 17*/ UINT64_C(415383748682786210),
        /* 18*/ UINT64_C(332306998946228968), /* 19*/ UINT64_C(531691198313966349),
        /* 20*/ UINT64_C(425352958651173079), /* 21*/ UINT64_C(340282366920938463),
        /* 22*/ UINT64_C(544451787073501541), /* 23*/ UINT64_C(435561429658801233),
        /* 24*/ UINT64_C(348449143727040986), /* 25*/ UINT64_C(557518629963265578),
        /* 26*/ UINT64_C(446014903970612462), /* 27*/ UINT64_C(356811923176489970),
        /* 28*/ UINT64_C(570899077082383952), /* 29*/ UINT64_C(456719261665907161)
    };
    return &data[index];
  }
};

constexpr static const double log_10_2 = 0.30102999566398114;
constexpr static const double log_10_5 = 0.6989700043360189;
constexpr static const double log_2_5 = 2.321928094887362;

template <typename T> inline void normalize(int& exp, uint64_t& mentissa) {
  if (exp) {
    mentissa += uint64_t(1) << float_info<T>::mentissa_width();
    exp = exp - float_info<T>::bias() - float_info<T>::mentissa_width();
  } else {
    exp = 1 - float_info<T>::bias() - float_info<T>::mentissa_width();
  }
}

inline void compute_shortest(
    uint64_t a, uint64_t b, uint64_t c, bool accept_smaller, bool accept_larger, bool break_tie_down,
    int& exponent_adjuster, uint64_t& shortest_base10
) {
  int i = 0;
  if (!accept_larger) {
    c -= 1;
  }

  bool all_a_zero = true;
  bool all_b_zero = true;
  uint64_t a_next = a / 10;
  uint32_t a_remainder = a % 10;
  uint64_t b_next = b / 10;
  uint32_t b_remainder = b % 10;
  uint64_t c_next = c / 10;
  while (a_next < c_next) {
    a_remainder = a % 10;
    b_remainder = b % 10;

    all_b_zero &= bool(!b_remainder);
    all_a_zero &= bool(!a_remainder);

    a = a_next;
    b = b_next;
    c = c_next;
    a_next = a / 10;
    b_next = b / 10;
    c_next = c / 10;
    i++;
  }
  if (accept_smaller && all_a_zero && a % 10 == 0) {
    while (!(a_next % 10)) {
      b_remainder = b % 10;

      all_b_zero &= bool(!b_remainder);

      a = a_next;
      b = b_next;
      c = c_next;
      a_next = a / 10;
      b_next = b / 10;
      c_next = c / 10;
      i++;
    }
  }
  exponent_adjuster = i;

  bool is_tie = b_remainder == 5 && all_b_zero;
  bool want_to_round_down = b_remainder < 5 || (is_tie && break_tie_down);
  bool round_down = (want_to_round_down && (a != b || all_a_zero)) || (b + 1 > c);
  if (round_down) {
    shortest_base10 = b;
  } else {
    shortest_base10 = b + 1;
  }
}

template <typename T>
inline uint64_t multiply_and_shift(uint64_t a, const uint64_t* b, int shift_right, bool round_up) {
  (void) a;
  (void) b;
  (void) shift_right;
  (void) round_up;
  return 0;
}
template <> inline uint64_t multiply_and_shift<double>(uint64_t a, const uint64_t* b, int shift_right, bool round_up) {
  uint64_t a0, a1, b0, b1, b2, b3, a0b0, a0b1, a0b2, a0b3, a1b0, a1b1, a1b2, a1b3;
  a0 = low(a);
  a1 = high(a);
  b0 = low(b[0]);
  b1 = high(b[0]);
  b2 = low(b[1]);
  b3 = high(b[1]);

  a0b0 = a0 * b0;
  a0b1 = a0 * b1;
  a0b2 = a0 * b2;
  a0b3 = a0 * b3;
  a1b0 = a1 * b0;
  a1b1 = a1 * b1;
  a1b2 = a1 * b2;
  a1b3 = a1 * b3;

  uint64_t result[6];
  result[0] = low(a0b0);
  result[1] = low(a0b1) + low(a1b0) + high(a0b0);
  result[2] = low(a0b2) + low(a1b1) + high(a0b1) + high(a1b0);
  result[3] = low(a0b3) + low(a1b2) + high(a0b2) + high(a1b1);
  result[4] = a1b3 + high(a0b3) + high(a1b2);

  result[1] += high(result[0]);
  result[2] += high(result[1]);
  result[3] += high(result[2]);
  result[4] += high(result[3]);
  result[5] = high(result[4]);

  uint64_t ret[4];
  ret[0] = low(result[0]) | ((low(result[1]) << 32) + high(result[0]));
  ret[1] = low(result[2]) | (low(result[3]) << 32);
  ret[2] = low(result[4]) | (low(result[5]) << 32);

  int index = shift_right / 64;
  int shift_right_in_index = shift_right - (index * 64);
  if (round_up) {
    if (shift_right_in_index) {
      if (!(ret[index] & (uint64_t(1) << (shift_right_in_index - 1)))) {
        round_up = false;
      }
    } else {
      if (!(index > 0 && ret[index] & uint64_t(1) << 63)) {
        round_up = false;
      }
    }
  }
  ret[index] >>= shift_right_in_index;
  ret[index] |= (ret[index + 1] & ((uint64_t(1) << shift_right_in_index) - 1)) << (64 - shift_right_in_index);
  ret[index] += round_up;
  return ret[index];
}

template <> inline uint64_t multiply_and_shift<float>(uint64_t a, const uint64_t* b, int shift_right, bool round_up) {
  uint64_t a0, a1, b0, b1, a0b0, a0b1, a1b0, a1b1;
  a0 = low(a);
  a1 = high(a);
  b0 = low(*b);
  b1 = high(*b);

  a0b0 = a0 * b0;
  a0b1 = a0 * b1;
  a1b0 = a1 * b0;
  a1b1 = a1 * b1;

  uint64_t result[4] = {};
  result[0] = low(a0b0);
  result[1] = low(a0b1) + low(a1b0) + high(a0b0);
  result[2] = low(a1b1) + high(a0b1) + high(a1b0);
  result[3] = high(a1b1);

  result[1] += high(result[0]);
  result[2] += high(result[1]);
  result[3] += high(result[2]);

  uint64_t ret[4];
  ret[0] = low(result[0]) | ((low(result[1]) << 32) + high(result[0]));
  ret[1] = low(result[2]) | (low(result[3]) << 32);

  int index = shift_right / 64;
  int shift_right_in_index = shift_right - (index * 64);
  if (round_up) {
    if (shift_right_in_index) {
      if (!(ret[index] & (uint64_t(1) << (shift_right_in_index - 1)))) {
        round_up = false;
      }
    } else {
      if (!(index > 0 && ret[index] & uint64_t(1) << 63)) {
        round_up = false;
      }
    }
  }
  ret[index] >>= shift_right_in_index;
  ret[index] |= (ret[index + 1] & ((uint64_t(1) << shift_right_in_index) - 1)) << (64 - shift_right_in_index);
  ret[index] += round_up;
  return ret[index];
}

inline uint64_t pow_int(int n, int exp) {
  if (!exp) {
    return 1;
  }
  uint64_t ret = uint64_t(n);
  for (int i = 0; i < exp; i++) {
    ret *= ret;
  }
  return ret;
}

template <typename T, typename SignificandType> static float_base10<SignificandType> decode(T f) {
  bool negative;
  int exp;
  uint64_t mentissa;
  get_parts(f, negative, exp, mentissa);
  bool shift_u_with_one = mentissa == 0 && exp > 1;

  if (is_nan(f)) {
    return {negative, false, true, 0, 0, 0};
  }
  if (is_inf(f)) {
    return {negative, true, false, 0, 0, 0};
  }
  if (!exp && !mentissa) {
    return {negative, false, false, 1, 0, 0};
  }

  bool accept_larger = (mentissa % 2 == 0);
  bool accept_smaller = accept_larger;

  normalize<T>(exp, mentissa);

  exp -= 2;
  mentissa *= 4;

  uint64_t u = mentissa;
  if (shift_u_with_one) {
    u -= 1;
  } else {
    u -= 2;
  }

  uint64_t w = mentissa + 2;

  int e10 = exp < 0 ? exp : 0;

  int q;
  int shift_right;
  bool zero[3] = {};
  if (exp >= 0) {
    q = max(0, int(exp * log_10_2) - 1);
    int k = cache_values<T>::b0 + int(q * log_2_5);
    shift_right = -exp + q + k;
    if (q - 1 <= float_info<T>::max_double_5_pow_q()) {
      uint64_t mod = pow_int(5, q - 1);
      if (mod) {
        zero[1] = (mentissa % mod) == 0;
      }
      if (q <= float_info<T>::max_double_5_pow_q()) {
        mod = pow_int(5, q);
        zero[0] = (u % mod) == 0;
        zero[2] = (w % mod) == 0;
      }
    }
  } else {
    q = max(0, int(-exp * log_10_5) - 1);
    int k = int(std::ceil((double(-exp) - double(q)) * log_2_5)) - cache_values<T>::b1;
    shift_right = q - k;
    if (q && q - 1 <= float_info<T>::max_double_2_pow_q()) {
      uint64_t mod = uint64_t(1) << int(q - 1);
      zero[1] = (mentissa % mod) == 0;

      if (q <= float_info<T>::max_double_2_pow_q()) {
        mod <<= 1;
        if (mod) {
          zero[0] = (u % mod) == 0;
          zero[2] = (w % mod) == 0;
        }
      }
    }
  }
  auto cache_value = exp >= 0 ? cache_values<T>::greater_than_equals(q) : cache_values<T>::less_than(-exp - q);
  uint64_t a = multiply_and_shift<T>(u, cache_value, shift_right, true);
  uint64_t b = multiply_and_shift<T>(mentissa, cache_value, shift_right, false);
  uint64_t c = multiply_and_shift<T>(w, cache_value, shift_right, false);

  int exponent_adjust;
  uint64_t shortest_base10;
  compute_shortest(
      a, b, c, accept_smaller && zero[0], accept_larger || !zero[2], zero[1], exponent_adjust, shortest_base10
  );
  int significand_digit_count = count_chars(shortest_base10);
  int e = exponent_adjust + e10 + q;
  return {negative, false, false, uint8_t(significand_digit_count), e, shortest_base10};
}

template <typename T>
inline int convert_parsed_to_buffer(
    const float_base10<T>& result, char* buffer, int buffer_size, int max_expanded_length,
    int* digits_truncated = nullptr
) {
  if (buffer_size < 1) {
    return 0;
  }
  int offset = 0;
  if (result.nan) {
    if (buffer_size >= 3) {
      buffer[offset++] = 'n';
      buffer[offset++] = 'a';
      buffer[offset++] = 'n';
    }
    return offset;
  }

  if (result.negative) {
    buffer[offset++] = '-';
    buffer_size--;
  }

  if (result.inf) {
    if (buffer_size >= 3) {
      buffer[offset++] = 'i';
      buffer[offset++] = 'n';
      buffer[offset++] = 'f';
    }
    return offset;
  }

  char significan_buffer[17] = {};
  assert(result.significand_digit_count <= uint8_t(17));
  int digits_before_decimals = result.significand_digit_count + result.exp;
  int digits_after_decimals = result.exp < 0 ? -result.exp : 0;
  int complete_digits = max(1, digits_before_decimals) + max(1, digits_after_decimals) + 1;
  if (complete_digits < max_expanded_length) {
    char* target_buffer = buffer + offset;
    uint64_t significand = result.significand;
    bool print_desimal_seperator = true;
    if (buffer_size < complete_digits) {
      int to_remove = complete_digits - buffer_size;
      if (digits_truncated) {
        *digits_truncated = to_remove;
      }

      int to_remove_after_decimals = std::min(to_remove, digits_after_decimals);
      for (int i = 0; i < to_remove_after_decimals; i++) {
        complete_digits--;
        digits_after_decimals--;
        significand /= 10;
      }
      to_remove -= to_remove_after_decimals;
      if (to_remove > 0) {
        print_desimal_seperator = false;
        if (!digits_after_decimals) {
          complete_digits--;
          to_remove--;
        }
        complete_digits--;
        to_remove--;
        if (to_remove > 0) {
          int to_remove_before_decimals = std::min(to_remove, digits_before_decimals);
          for (int i = 0; i < to_remove_before_decimals; i++) {
            complete_digits--;
            digits_before_decimals--;
            significand /= 10;
          }
        }
      } else if (to_remove == 0 && digits_after_decimals == 0) {
        print_desimal_seperator = false;
        complete_digits--;
      }
    }
    int index_pos = std::max(complete_digits - 1, 0);
    for (int i = 0; i < digits_after_decimals; i++, index_pos--) {
      char remainder = char(significand % 10);
      significand /= 10;
      target_buffer[index_pos] = '0' + remainder;
    }
    if (print_desimal_seperator) {
      if (digits_after_decimals == 0) {
        target_buffer[index_pos--] = '0';
      }
      target_buffer[index_pos--] = '.';
    }
    int add_zeros_before_decimal = std::max(result.exp, 0);
    for (int i = 0; i < add_zeros_before_decimal; i++, index_pos--) {
      target_buffer[index_pos] = '0';
      digits_before_decimals--;
    }
    for (int i = 0; i < digits_before_decimals; i++, index_pos--) {
      char remainder = char(significand % 10);
      significand /= 10;
      target_buffer[index_pos] = '0' + remainder;
    }
    if (digits_before_decimals <= 0) {
      target_buffer[index_pos] = '0';
    }
    return complete_digits + offset;
  } else {
    uint64_t significand = result.significand;
    int exp = result.exp;
    for (int i = 0; i < result.significand_digit_count; i++) {
      significan_buffer[result.significand_digit_count - i - 1] = '0' + significand % 10;
      significand /= 10;
    }

    exp += result.significand_digit_count;
    exp--;
    char exponent_buffer[4] = {};
    int exponent_digit_count = count_chars(exp);
    if (exp < 0) {
      exponent_buffer[0] = '-';
    }
    int abs_exp = std::abs(exp);
    for (int i = 0; i < exponent_digit_count; i++) {
      exponent_buffer[exponent_digit_count + (exp < 0) - i - 1] = '0' + abs_exp % 10;
      abs_exp /= 10;
    }
    exponent_digit_count += exp < 0;

    if (offset < buffer_size) {
      buffer[offset++] = significan_buffer[0];
    } else {
      return offset;
    }

    if (result.significand_digit_count > 1) {
      if (offset < buffer_size) {
        buffer[offset++] = '.';
      } else {
        return offset;
      }
    }
    int to_copy = min(buffer_size - offset, int(result.significand_digit_count) - 1);
    for (int i = 0; i < to_copy; i++) {
      buffer[offset++] = significan_buffer[1 + i];
    }

    if (offset >= buffer_size) {
      return offset;
    }

    buffer[offset++] = 'e';

    to_copy = min(buffer_size - offset, exponent_digit_count);
    for (int i = 0; i < to_copy; i++) {
      buffer[offset++] = exponent_buffer[i];
    }
  }

  return offset;
}

} // namespace ryu

template <typename T> struct set_end_ptr {
  set_end_ptr(parsed_string<T>& parsedString, const char*& current) : parsedString(parsedString), current(current) {}
  ~set_end_ptr() { parsedString.endptr = current; }
  parsed_string<T>& parsedString;
  const char*& current;
};

inline bool is_space(char a) {
  if (a == 0x20 || a == 0x09 || a == 0x0a || a == 0x0b || a == 0x0c || a == 0x0d) {
    return true;
  }
  return false;
}

template <typename T, bool NoDigitCount>
inline parse_string_error parseNumber(const char* number, size_t size, parsed_string<T>& parsedString) {
  const char* current;
  set_end_ptr<T> setendptr(parsedString, current);
  int desimal_position = -1;
  bool increase_significand = true;

  parsedString.negative = 0;
  parsedString.inf = 0;
  parsedString.nan = 0;
  parsedString.significand_digit_count = 0;
  parsedString.significand = 0;
  parsedString.exp = 0;

  const char* number_end = number + size;
  current = find_if(number, number_end, [](const char a) { return !is_space(a); });
  if (number_end == current) {
    return parse_string_error::empty_string;
  }
  if (*current == '-') {
    parsedString.negative = 1;
    current++;
  }
  while (current < number_end) {
    if ((*current < '0' || *current > '9') && *current != '.') {
      break;
    }

    if (*current == '.') {
      if (desimal_position >= 0) {
        return parse_string_error::multiple_commas;
      }
      desimal_position = parsedString.significand_digit_count;
    } else {
#ifdef _MSC_VER
      bool localDigitCount = NoDigitCount;
      if (localDigitCount || parsedString.significand_digit_count < 19)
#else
      if (NoDigitCount || parsedString.significand_digit_count < 19)
#endif
      {
        parsedString.significand = parsedString.significand * T(10) + T(int(*current) - '0');
        parsedString.significand_digit_count++;
      } else if (increase_significand && parsedString.significand_digit_count < 20) {
        increase_significand = false;
        uint64_t digit = uint64_t(*current) - '0';
        static_assert(
            NoDigitCount || std::is_same<T, uint64_t>::value,
            "When NoDigitCount is used the significand type has to be uint64_t"
        );
        auto biggest_multiplier = (std::numeric_limits<uint64_t>::max() - digit) / parsedString.significand;

        if (biggest_multiplier >= 10) {
          parsedString.significand = parsedString.significand * T(10) + T(digit);
          parsedString.significand_digit_count++;
        }
      }
    }
    current++;
  }
  if (*current != 'e' && *current != 'E') {
    if (desimal_position >= 0) {
      parsedString.exp = desimal_position - parsedString.significand_digit_count;
    }
    return parse_string_error::ok;
  }
  current++;
  if (current == number_end) {
    return parse_string_error::illegal_exponent_value;
  }
  bool exponent_nagative = false;
  if (*current == '-') {
    exponent_nagative = true;
    current++;
  } else if (*current == '+') {
    current++;
  }
  if (current == number_end) {
    return parse_string_error::illegal_exponent_value;
  }
  int exponent = 0;
  bool exponent_assigned = false;
  while (current < number_end) {
    if ((*current < '0' || *current > '9')) {
      break;
    }
    exponent_assigned = true;
    exponent = exponent * 10 + (*current - '0');
    current++;
  }
  if (!exponent_assigned) {
    return parse_string_error::illegal_exponent_value;
  }

  if (exponent_nagative) {
    exponent = -exponent;
  }

  if (desimal_position >= 0) {
    parsedString.exp = desimal_position - parsedString.significand_digit_count + exponent;
  } else {
    parsedString.exp = exponent;
  }
  return parse_string_error::ok;
}

inline uint64_t getPow10(uint32_t pow) {
  static uint64_t data[] = {
      UINT64_C(1),
      UINT64_C(10),
      UINT64_C(100),
      UINT64_C(1000),
      UINT64_C(10000),
      UINT64_C(100000),
      UINT64_C(1000000),
      UINT64_C(10000000),
      UINT64_C(100000000),
      UINT64_C(1000000000),
      UINT64_C(10000000000),
      UINT64_C(100000000000),
      UINT64_C(1000000000000),
      UINT64_C(10000000000000),
      UINT64_C(100000000000000),
      UINT64_C(1000000000000000),
      UINT64_C(10000000000000000),
      UINT64_C(100000000000000000),
      UINT64_C(1000000000000000000),
      UINT64_C(10000000000000000000)
  };
  return data[pow];
}

template <typename T, typename SignificandType> inline T convertToNumber(const parsed_string<SignificandType>& parsed) {
  int base10exponent = parsed.exp + parsed.significand_digit_count - 1;
  if (base10exponent > float_info<T>::max_base10_exponent()) {
    return make_inf<T>(parsed.negative);
  } else if (base10exponent < float_info<T>::min_base10_exponent()) {
    return make_zero<T>(parsed.negative);
  }
  if (parsed.significand == 0) {
    return make_zero<T>(parsed.negative);
  }

#if 1
  if (parsed.significand < ((uint64_t(1) << 53)) && iabs<int>(parsed.exp) < count_chars((uint64_t(1) << 53))) {
    double ds(double(parsed.significand));
    double de(double(getPow10(iabs<int>(parsed.exp))));
    if (parsed.negative) {
      ds = -ds;
    }
    return parsed.exp < 0 ? T(ds / de) : T(ds * de);
  }
#endif

  using uint_conversion_type = typename float_info<T>::str_to_float_conversion_type;
  uint_conversion_type a;
  uint_conversion_type b;
  assign_significand_to_float_conversion_type(parsed, a);
  int desimal_exponent = parsed.exp;
  auto binary_exponent = float_info<T>::str_to_float_binary_exponent_init();
  for (; desimal_exponent > 0; desimal_exponent--) {
    left_shift(a);
    copy_conversion_type(a, b);
    left_shift<2>(b);
    add(b, a);

    while (float_info<T>::conversion_type_has_mask(a)) {
      right_shift(a);
      binary_exponent++;
    }
  }

  for (; desimal_exponent < 0; desimal_exponent++) {
    binary_exponent -= float_info<T>::shift_left_msb_to_index(a, float_info<T>::str_to_float_binary_exponent_init());

    divide_by_10(a);
  }

  binary_exponent -= float_info<T>::shift_left_msb_to_index(a, float_info<T>::str_to_float_binary_exponent_init());

  binary_exponent += float_info<T>::bias();
  T to_digit;
  if (binary_exponent <= 0) {
    float_info<T>::copy_denormal_to_type(a, binary_exponent, parsed.negative, to_digit);
  } else if (binary_exponent < (int(1) << float_info<T>::exponent_width()) - 1) {
    float_info<T>::copy_normal_to_type(a, binary_exponent, parsed.negative, to_digit);
  } else {
    to_digit = make_inf<T>(parsed.negative);
  }
  return to_digit;
}

namespace ryu {
template <typename T> int to_buffer(T d, char* buffer, int buffer_size, int* digits_truncated = nullptr) {
  auto decoded = decode<T, uint64_t>(d);
  return convert_parsed_to_buffer(
      decoded, buffer, buffer_size, float_info<T>::str_to_float_expanded_length(), digits_truncated
  );
}

template <typename T> inline std::string to_string(T f) {
  auto decoded = decode<T, uint64_t>(f);
  std::string ret;
  ret.resize(25);
  ret.resize(
      size_t(convert_parsed_to_buffer(decoded, &ret[0], int(ret.size()), float_info<T>::str_to_float_expanded_length()))
  );
  return ret;
}
} // namespace ryu

namespace integer {
template <typename T> inline int to_buffer(T integer, char* buffer, int buffer_size, int* digits_truncated = nullptr) {
  static_assert(std::is_integral<T>::value, "Tryint to convert non int to string");
  int chars_to_write = ft::count_chars(integer);
  char* target_buffer = buffer;
  bool negative = false;
  if (std::is_signed<T>::value) {
    if (integer < 0) {
      target_buffer[0] = '-';
      target_buffer++;
      buffer_size--;
      negative = true;
    }
  }
  int to_remove = chars_to_write - buffer_size;
  if (to_remove > 0) {
    for (int i = 0; i < to_remove; i++) {
      integer /= 10;
    }
    if (digits_truncated) {
      *digits_truncated = to_remove;
    }
    chars_to_write -= to_remove;
  } else if (digits_truncated) {
    *digits_truncated = 0;
  }

  for (int i = 0; i < chars_to_write; i++) {
    int remainder = integer % 10;
    if (std::is_signed<T>::value) {
      if (negative) {
        remainder = -remainder;
      }
    }
    integer /= 10;
    target_buffer[chars_to_write - 1 - i] = '0' + char(remainder);
  }

  return chars_to_write + negative;
}

template <typename T, typename SignificandType>
inline typename std::enable_if<std::is_signed<T>::value, T>::type make_integer_return_value(
    SignificandType significand, bool negative
) {
  return negative ? -T(significand) : T(significand);
}

template <typename T, typename SignificandType>
inline typename std::enable_if<std::is_unsigned<T>::value, T>::type make_integer_return_value(
    SignificandType significand, bool
) {
  return T(significand);
}

template <typename T, typename SignificandType>
inline T convert_to_integer(const parsed_string<SignificandType>& parsed) {
  if (parsed.inf) {
    return parsed.negative ? std::numeric_limits<T>::min() : std::numeric_limits<T>::max();
  }
  if (parsed.nan) {
    return T(0);
  }

  int exp = parsed.exp;
  auto significand = parsed.significand;
  if (exp < 0) {
    int chars_in_sig = count_chars(significand);
    if (-exp >= chars_in_sig) {
      return T(0);
    }
    while (exp < 0) {
      significand /= 10;
      exp++;
    }
  } else if (exp > 0) {
    int chars_in_sig = count_chars(significand);
    if (exp > ft::StaticLog10<T, std::numeric_limits<T>::max(), 0, 0, true>::get() - chars_in_sig) {
      return parsed.negative ? std::numeric_limits<T>::min() : std::numeric_limits<T>::max();
    }
    while (exp > 0) {
      significand *= 10;
      exp--;
    }
  }
  return make_integer_return_value<T>(significand, bool(parsed.negative));
}

template <typename T>
inline parse_string_error to_integer(const char* str, size_t size, T& target, const char*(&endptr)) {
  using SignificandType = typename std::make_unsigned<T>::type;
  parsed_string<SignificandType> ps;
  auto parseResult = parseNumber<SignificandType, true>(str, size, ps);
  endptr = ps.endptr;
  if (parseResult != parse_string_error::ok) {
    target = 0;
  } else {
    target = convert_to_integer<T>(ps);
  }
  return parseResult;
}

template <typename T> inline parse_string_error to_integer(const std::string& str, T& target, const char*(&endptr)) {
  return to_integer(str.c_str(), str.size(), target, endptr);
}
} // namespace integer

template <typename T>
inline parse_string_error to_ieee_t(const char* str, size_t size, T& target, const char*(&endptr)) {
  parsed_string<uint64_t> ps;
  auto parseResult = parseNumber<uint64_t, false>(str, size, ps);
  endptr = ps.endptr;
  if (parseResult != parse_string_error::ok) {
    target = make_nan<T>(true, 1);
  } else {
    target = convertToNumber<T>(ps);
  }
  return parseResult;
}

inline parse_string_error to_float(const char* str, size_t size, float& target, const char*(&endptr)) {
  return to_ieee_t(str, size, target, endptr);
}

inline parse_string_error to_double(const char* str, size_t size, double& target, const char*(&endptr)) {
  return to_ieee_t(str, size, target, endptr);
}

} // namespace ft
} // namespace Internal
/// \private
template <> struct TypeHandler<double> {
  static inline Error to(double& to_type, ParseContext& context) {
    const char* pointer;
    auto result = Internal::ft::to_double(context.token.value.data, context.token.value.size, to_type, pointer);
    if (result != Internal::ft::parse_string_error::ok ||
        context.token.value.data + context.token.value.size != pointer) {
      return Error::FailedToParseDouble;
    }
    return Error::NoError;
  }

  static inline void from(const double& d, Token& token, Serializer& serializer) {
    // char buf[1/*'-'*/ + (DBL_MAX_10_EXP+1)/*308+1 digits*/ + 1/*'.'*/ + 6/*Default? precision*/ + 1/*\0*/];
    char buf[32];
    int size;
    size = Internal::ft::ryu::to_buffer(d, buf, sizeof(buf));

    if (size <= 0) {
      return;
    }

    token.value_type = Type::Number;
    token.value.data = buf;
    token.value.size = size_t(size);
    serializer.write(token);
  }
};

/// \private
template <> struct TypeHandler<float> {
  static inline Error to(float& to_type, ParseContext& context) {
    const char* pointer;
    auto result = Internal::ft::to_float(context.token.value.data, context.token.value.size, to_type, pointer);
    if (result != Internal::ft::parse_string_error::ok ||
        context.token.value.data + context.token.value.size != pointer) {
      return Error::FailedToParseFloat;
    }
    return Error::NoError;
  }

  static inline void from(const float& f, Token& token, Serializer& serializer) {
    char buf[16];
    int size;
    size = Internal::ft::ryu::to_buffer(f, buf, sizeof(buf));
    if (size < 0) {
      return;
    }

    token.value_type = Type::Number;
    token.value.data = buf;
    token.value.size = size_t(size);
    serializer.write(token);
  }
};

/// \private
template <typename T> struct TypeHandlerIntType {
  static inline Error to(T& to_type, ParseContext& context) {
    const char* pointer;
    auto parse_error =
        Internal::ft::integer::to_integer(context.token.value.data, context.token.value.size, to_type, pointer);
    if (parse_error != Internal::ft::parse_string_error::ok || context.token.value.data == pointer) {
      return Error::FailedToParseInt;
    }
    return Error::NoError;
  }

  static inline void from(const T& from_type, Token& token, Serializer& serializer) {
    char buf[40];
    int digits_truncated;
    int size = Internal::ft::integer::to_buffer(from_type, buf, sizeof(buf), &digits_truncated);
    if (size <= 0 || digits_truncated) {
      fprintf(stderr, "error serializing int token\n");
      return;
    }

    token.value_type = Type::Number;
    token.value.data = buf;
    token.value.size = size_t(size);
    serializer.write(token);
  }
};

/// \private
template <> struct TypeHandler<short int> : TypeHandlerIntType<short int> {};

/// \private
template <> struct TypeHandler<unsigned short int> : TypeHandlerIntType<unsigned short int> {};

/// \private
template <> struct TypeHandler<int> : TypeHandlerIntType<int> {};

/// \private
template <> struct TypeHandler<unsigned int> : TypeHandlerIntType<unsigned int> {};

/// \private
template <> struct TypeHandler<long int> : TypeHandlerIntType<long int> {};

/// \private
template <> struct TypeHandler<unsigned long int> : TypeHandlerIntType<unsigned long int> {};

/// \private
template <> struct TypeHandler<long long int> : TypeHandlerIntType<long long int> {};

/// \private
template <> struct TypeHandler<unsigned long long int> : TypeHandlerIntType<unsigned long long int> {};

template <> struct TypeHandler<uint8_t> : TypeHandlerIntType<uint8_t> {};

template <> struct TypeHandler<int8_t> : TypeHandlerIntType<int8_t> {};

template <> struct TypeHandler<char> : TypeHandlerIntType<char> {};

/// \private
template <typename T> struct TypeHandler<Nullable<T>> {
public:
  static inline Error to(Nullable<T>& to_type, ParseContext& context) {
    if (context.token.value_type == Type::Null) {
      return Error::NoError;
    }
    return TypeHandler<T>::to(to_type.data, context);
  }

  static inline void from(const Nullable<T>& opt, Token& token, Serializer& serializer) {
    TypeHandler<T>::from(opt(), token, serializer);
  }
};

/// \private
template <typename T> struct TypeHandler<NullableChecked<T>> {
public:
  static inline Error to(NullableChecked<T>& to_type, ParseContext& context) {
    if (context.token.value_type == Type::Null) {
      to_type.null = true;
      return Error::NoError;
    }
    to_type.null = false;
    return TypeHandler<T>::to(to_type.data, context);
  }

  static inline void from(const NullableChecked<T>& opt, Token& token, Serializer& serializer) {
    if (opt.null) {
      const char nullChar[] = "null";
      token.value_type = Type::Null;
      token.value = DataRef(nullChar);
      serializer.write(token);
    } else {
      TypeHandler<T>::from(opt(), token, serializer);
    }
  }
};

/// \private
template <typename T> struct TypeHandler<Optional<T>> {
public:
  static inline Error to(Optional<T>& to_type, ParseContext& context) {
    return TypeHandler<T>::to(to_type.data, context);
  }

  static inline void from(const Optional<T>& opt, Token& token, Serializer& serializer) {
    TypeHandler<T>::from(opt(), token, serializer);
  }
};

/// \private
template <typename T> struct TypeHandler<OptionalChecked<T>> {
public:
  static inline Error to(OptionalChecked<T>& to_type, ParseContext& context) {
    to_type.assigned = true;
    return TypeHandler<T>::to(to_type.data, context);
  }

  static inline void from(const OptionalChecked<T>& opt, Token& token, Serializer& serializer) {
    if (opt.assigned) {
      TypeHandler<T>::from(opt(), token, serializer);
    }
  }
};

#ifdef JS_STD_OPTIONAL
/// \private
template <typename T> struct TypeHandler<std::optional<T>> {
public:
  static inline Error to(std::optional<T>& to_type, ParseContext& context) {
    to_type.emplace();
    return TypeHandler<T>::to(to_type.value(), context);
  }

  static inline void from(const std::optional<T>& opt, Token& token, Serializer& serializer) {
    if (opt.has_value()) {
      TypeHandler<T>::from(opt.value(), token, serializer);
    }
  }
};
#endif

/// \private
template <typename T> struct TypeHandler<std::shared_ptr<T>> {
public:
  static inline Error to(std::shared_ptr<T>& to_type, ParseContext& context) {
    if (context.token.value_type != Type::Null) {
      if (!to_type) {
        to_type = std::make_shared<T>();
      }
      return TypeHandler<T>::to(*to_type.get(), context);
    }
    to_type.reset();
    return Error::NoError;
  }

  static inline void from(const std::shared_ptr<T>& unique, Token& token, Serializer& serializer) {
    if (unique) {
      TypeHandler<T>::from(*unique.get(), token, serializer);
    } else {
      const char nullChar[] = "null";
      token.value_type = Type::Null;
      token.value = DataRef(nullChar);
      serializer.write(token);
    }
  }
};

/// \private
template <typename T> struct TypeHandler<std::unique_ptr<T>> {
public:
  static inline Error to(std::unique_ptr<T>& to_type, ParseContext& context) {
    if (context.token.value_type != Type::Null) {
      if (!to_type) {
        to_type.reset(new T());
      }
      return TypeHandler<T>::to(*to_type.get(), context);
    }
    to_type.reset(nullptr);
    return Error::NoError;
  }

  static inline void from(const std::unique_ptr<T>& unique, Token& token, Serializer& serializer) {
    if (unique) {
      TypeHandler<T>::from(*unique.get(), token, serializer);
    } else {
      const char nullChar[] = "null";
      token.value_type = Type::Null;
      token.value = DataRef(nullChar);
      serializer.write(token);
    }
  }
};

/// \private
template <> struct TypeHandler<bool> {
  static inline Error to(bool& to_type, ParseContext& context) {
    if (context.token.value.size == sizeof("true") - 1 &&
        memcmp("true", context.token.value.data, sizeof("true") - 1) == 0) {
      to_type = true;
    } else if (context.token.value.size == sizeof("false") - 1 &&
               memcmp("false", context.token.value.data, sizeof("false") - 1) == 0) {
      to_type = false;
    } else {
      return Error::FailedToParseBoolean;
    }

    return Error::NoError;
  }

  static inline void from(const bool& b, Token& token, Serializer& serializer) {
    const char trueChar[] = "true";
    const char falseChar[] = "false";
    token.value_type = Type::Bool;
    if (b) {
      token.value = DataRef(trueChar);
    } else {
      token.value = DataRef(falseChar);
    }
    serializer.write(token);
  }
};

#ifdef JS_STD_TIMEPOINT
/// \private
namespace Internal {
template <class T, template <class...> class Template> struct is_specialization : std::false_type {};

template <template <class...> class Template, class... Args>
struct is_specialization<Template<Args...>, Template> : std::true_type {};
} // namespace Internal

/// \private
template <class T>
struct TypeHandler<T, typename std::enable_if_t<Internal::is_specialization<T, std::chrono::time_point>::value>> {
  static inline Error to(T& to_type, ParseContext& context) {
    uint64_t t;
    Error err = TypeHandler<uint64_t>::to(t, context);
    if (err != Error::NoError) {
      return err;
    }

    if (t <= 1e11) { // Seconds => 10 digits, normally
      to_type = T{std::chrono::seconds{t}};
    } else if (t <= 1e14) { // Milliseconds => 13 digits, normally
      to_type = T{std::chrono::milliseconds{t}};
    } else if (t <= 1e17) { // Microseconds
      to_type = T{std::chrono::microseconds{t}};
    } else if (t <= 1e20) { // Nanoseconds
      if constexpr (std::is_same_v<std::chrono::high_resolution_clock::time_point, T>) {
        to_type = T{std::chrono::nanoseconds{t}};
      } else {
        return JS::Error::IllegalDataValue;
      }
    } else {
      return JS::Error::IllegalDataValue;
    }

    return JS::Error::NoError;
  }

  static inline void from(const T& val, Token& token, Serializer& serializer) {
    uint64_t t;
    if constexpr (std::is_same_v<std::chrono::high_resolution_clock::time_point, T>) {
      t = std::chrono::duration_cast<std::chrono::nanoseconds>(val.time_since_epoch()).count();
    } else {
      t = std::chrono::duration_cast<std::chrono::microseconds>(val.time_since_epoch()).count();
    }
    while (t % 1000 == 0 && t > (uint64_t) 1e10) {
      t /= 1000;
    }
    TypeHandler<uint64_t>::from(t, token, serializer);
  }
};
#endif

/// \private
template <typename T, typename A> struct TypeHandler<std::vector<T, A>> {
  static inline Error to(std::vector<T, A>& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ArrayStart) {
      return Error::ExpectedArrayStart;
    }
    Error error = context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
    to_type.clear();
    to_type.reserve(10);
    while (context.token.value_type != JS::Type::ArrayEnd) {
      to_type.push_back(T());
      error = TypeHandler<T>::to(to_type.back(), context);
      if (error != JS::Error::NoError) {
        break;
      }
      error = context.nextToken();
      if (error != JS::Error::NoError) {
        break;
      }
    }

    return error;
  }

  static inline void from(const std::vector<T, A>& vec, Token& token, Serializer& serializer) {
    token.value_type = Type::ArrayStart;
    token.value = DataRef("[");
    serializer.write(token);

    token.name = DataRef("");

    for (auto& index : vec) {
      TypeHandler<T>::from(index, token, serializer);
    }

    token.name = DataRef("");

    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }
};

/// \private
template <typename A> struct TypeHandler<std::vector<bool, A>> {
public:
  static inline Error to(std::vector<bool, A>& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ArrayStart) {
      return Error::ExpectedArrayStart;
    }
    Error error = context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
    to_type.clear();
    to_type.reserve(10);
    while (context.token.value_type != JS::Type::ArrayEnd) {

      bool toBool;
      error = TypeHandler<bool>::to(toBool, context);
      to_type.push_back(toBool);
      if (error != JS::Error::NoError) {
        break;
      }
      error = context.nextToken();
      if (error != JS::Error::NoError) {
        break;
      }
    }

    return error;
  }

  static inline void from(const std::vector<bool, A>& vec, Token& token, Serializer& serializer) {
    token.value_type = Type::ArrayStart;
    token.value = DataRef("[");
    serializer.write(token);

    token.name = DataRef("");

    for (bool index : vec) {
      TypeHandler<bool>::from(index, token, serializer);
    }

    token.name = DataRef("");

    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }
};

/// \private
template <> struct TypeHandler<SilentString> {
  static inline Error to(SilentString& to_type, ParseContext& context) {
    return TypeHandler<std::string>::to(to_type.data, context);
  }
  static inline void from(const SilentString& str, Token& token, Serializer& serializer) {
    if (str.data.size()) {
      TypeHandler<std::string>::from(str.data, token, serializer);
    }
  }
};

/// \private
template <typename T, typename A> struct TypeHandler<SilentVector<T, A>> {
public:
  static inline Error to(SilentVector<T, A>& to_type, ParseContext& context) {
    return TypeHandler<std::vector<T, A>>::to(to_type.data, context);
  }

  static inline void from(const SilentVector<T, A>& vec, Token& token, Serializer& serializer) {
    if (vec.data.size()) {
      TypeHandler<std::vector<T, A>>::from(vec.data, token, serializer);
    }
  }
};

/// \private
template <typename T> struct TypeHandler<SilentUniquePtr<T>> {
public:
  static inline Error to(SilentUniquePtr<T>& to_type, ParseContext& context) {
    return TypeHandler<std::unique_ptr<T>>::to(to_type.data, context);
  }

  static inline void from(const SilentUniquePtr<T>& ptr, Token& token, Serializer& serializer) {
    if (ptr.data) {
      TypeHandler<std::unique_ptr<T>>::from(ptr.data, token, serializer);
    }
  }
};

/// \private
template <typename A> struct TypeHandler<std::vector<Token, A>> {
public:
  static inline Error to(std::vector<Token, A>& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ArrayStart && context.token.value_type != JS::Type::ObjectStart) {
      to_type.push_back(context.token);
      return context.error;
    }
    to_type.clear();
    to_type.push_back(context.token);

    size_t level = 1;
    Error error = Error::NoError;
    while (error == JS::Error::NoError && level) {
      error = context.nextToken();
      to_type.push_back(context.token);
      if (context.token.value_type == Type::ArrayStart || context.token.value_type == Type::ObjectStart) {
        level++;
      } else if (context.token.value_type == Type::ArrayEnd || context.token.value_type == Type::ObjectEnd) {
        level--;
      }
    }

    return error;
  }

  static inline void from(const std::vector<Token, A>& from_type, Token& token, Serializer& serializer) {
    for (auto& t : from_type) {
      token = t;
      serializer.write(token);
    }
  }
};

/// \private
template <> struct TypeHandler<JsonTokens> {
public:
  static inline Error to(JsonTokens& to_type, ParseContext& context) {
    return TypeHandler<std::vector<Token>>::to(to_type.data, context);
  }
  static inline void from(const JsonTokens& from, Token& token, Serializer& serializer) {
    return TypeHandler<std::vector<Token>>::from(from.data, token, serializer);
  }
};

/// \private
template <> struct TypeHandler<JsonArrayRef> {
  static inline Error to(JsonArrayRef& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ArrayStart) {
      return Error::ExpectedArrayStart;
    }

    to_type.ref.data = context.token.value.data;

    size_t level = 1;
    Error error = Error::NoError;
    while (error == JS::Error::NoError && level) {
      error = context.nextToken();
      if (context.token.value_type == Type::ArrayStart) {
        level++;
      } else if (context.token.value_type == Type::ArrayEnd) {
        level--;
      }
    }

    to_type.ref.size = size_t(context.token.value.data + context.token.value.size - to_type.ref.data);

    return error;
  }

  static inline void from(const JsonArrayRef& from_type, Token& token, Serializer& serializer) {
    token.value = from_type.ref;
    token.value_type = Type::Verbatim;
    serializer.write(token);
  }
};

/// \private
template <> struct TypeHandler<JsonArray> {
  static inline Error to(JsonArray& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ArrayStart) {
      return Error::ExpectedArrayStart;
    }

    context.tokenizer.copyFromValue(context.token, to_type.data);

    size_t level = 1;
    Error error = Error::NoError;
    while (error == JS::Error::NoError && level) {
      error = context.nextToken();
      if (context.token.value_type == Type::ArrayStart) {
        level++;
      } else if (context.token.value_type == Type::ArrayEnd) {
        level--;
      }
    }

    if (error == JS::Error::NoError) {
      context.tokenizer.copyIncludingValue(context.token, to_type.data);
    }

    return error;
  }

  static inline void from(const JsonArray& from_type, Token& token, Serializer& serializer) {
    token.value_type = JS::Type::Verbatim; // Need to fool the serializer to just write value as verbatim

    if (from_type.data.empty()) {
      std::string emptyArray("[]");
      token.value = DataRef(emptyArray);
      serializer.write(token);
    } else {
      token.value = DataRef(from_type.data);
      serializer.write(token);
    }
  }
};

/// \private
template <> struct TypeHandler<JsonObjectRef> {
  static inline Error to(JsonObjectRef& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ObjectStart) {
      return Error::ExpectedObjectStart;
    }

    to_type.ref.data = context.token.value.data;
    size_t level = 1;
    Error error = Error::NoError;
    while (error == JS::Error::NoError && level) {
      error = context.nextToken();
      if (context.token.value_type == Type::ObjectStart) {
        level++;
      } else if (context.token.value_type == Type::ObjectEnd) {
        level--;
      }
    }

    to_type.ref.size = size_t(context.token.value.data + context.token.value.size - to_type.ref.data);
    return error;
  }

  static inline void from(const JsonObjectRef& from_type, Token& token, Serializer& serializer) {
    token.value = from_type.ref;
    token.value_type = Type::Verbatim;
    serializer.write(token);
  }
};

/// \private
template <> struct TypeHandler<JsonObject> {
  static inline Error to(JsonObject& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ObjectStart) {
      return Error::ExpectedObjectStart;
    }

    context.tokenizer.copyFromValue(context.token, to_type.data);

    size_t level = 1;
    Error error = Error::NoError;
    while (error == JS::Error::NoError && level) {
      error = context.nextToken();
      if (context.token.value_type == Type::ObjectStart) {
        level++;
      } else if (context.token.value_type == Type::ObjectEnd) {
        level--;
      }
    }

    context.tokenizer.copyIncludingValue(context.token, to_type.data);

    return error;
  }

  static inline void from(const JsonObject& from_type, Token& token, Serializer& serializer) {
    token.value_type = JS::Type::Verbatim; // Need to fool the serializer to just write value as verbatim

    if (from_type.data.empty()) {
      std::string emptyObject("{}");
      token.value = DataRef(emptyObject);
      serializer.write(token);
    } else {
      token.value = DataRef(from_type.data);
      serializer.write(token);
    }
  }
};

/// \private
template <> struct TypeHandler<JsonObjectOrArrayRef> {
  static inline Error to(JsonObjectOrArrayRef& to_type, ParseContext& context) {
    JS::Type openType;
    JS::Type closeType;
    if (context.token.value_type == JS::Type::ObjectStart) {
      openType = JS::Type::ObjectStart;
      closeType = JS::Type::ObjectEnd;
    } else if (context.token.value_type == JS::Type::ArrayStart) {
      openType = JS::Type::ArrayStart;
      closeType = JS::Type::ArrayEnd;
    } else {
      return Error::ExpectedObjectStart;
    }

    to_type.ref.data = context.token.value.data;
    size_t level = 1;
    Error error = Error::NoError;
    while (error == JS::Error::NoError && level) {
      error = context.nextToken();
      if (context.token.value_type == openType) {
        level++;
      } else if (context.token.value_type == closeType) {
        level--;
      }
    }

    to_type.ref.size = size_t(context.token.value.data + context.token.value.size - to_type.ref.data);
    return error;
  }

  static inline void from(const JsonObjectOrArrayRef& from_type, Token& token, Serializer& serializer) {
    token.value = from_type.ref;
    token.value_type = Type::Verbatim;
    serializer.write(token);
  }
};

/// \private
template <> struct TypeHandler<JsonObjectOrArray> {
  static inline Error to(JsonObjectOrArray& to_type, ParseContext& context) {
    JS::Type openType;
    JS::Type closeType;
    if (context.token.value_type == JS::Type::ObjectStart) {
      openType = JS::Type::ObjectStart;
      closeType = JS::Type::ObjectEnd;
    } else if (context.token.value_type == JS::Type::ArrayStart) {
      openType = JS::Type::ArrayStart;
      closeType = JS::Type::ArrayEnd;
    } else {
      return Error::ExpectedObjectStart;
    }

    context.tokenizer.copyFromValue(context.token, to_type.data);

    size_t level = 1;
    Error error = Error::NoError;
    while (error == JS::Error::NoError && level) {
      error = context.nextToken();
      if (context.token.value_type == openType) {
        level++;
      } else if (context.token.value_type == closeType) {
        level--;
      }
    }

    context.tokenizer.copyIncludingValue(context.token, to_type.data);

    return error;
  }

  static inline void from(const JsonObjectOrArray& from_type, Token& token, Serializer& serializer) {
    token.value_type = JS::Type::Verbatim; // Need to fool the serializer to just write value as verbatim

    if (from_type.data.empty()) {
      std::string emptyObjectOrArray("{}"); // Use object as default
      token.value = DataRef(emptyObjectOrArray);
      serializer.write(token);
    } else {
      token.value = DataRef(from_type.data);
      serializer.write(token);
    }
  }
};

namespace Internal {
template <size_t INDEX, typename... Ts> struct TupleTypeHandler {
  static inline Error to(JS::Tuple<Ts...>& to_type, ParseContext& context) {
    using Type = typename JS::TypeAt<sizeof...(Ts) - INDEX, Ts...>::type;
    Error error = TypeHandler<Type>::to(to_type.template get<sizeof...(Ts) - INDEX>(), context);
    if (error != JS::Error::NoError) {
      return error;
    }
    error = context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
    return TupleTypeHandler<INDEX - 1, Ts...>::to(to_type, context);
  }

  static inline void from(const JS::Tuple<Ts...>& from_type, Token& token, Serializer& serializer) {
    using Type = typename JS::TypeAt<sizeof...(Ts) - INDEX, Ts...>::type;
    TypeHandler<Type>::from(from_type.template get<sizeof...(Ts) - INDEX>(), token, serializer);
    TupleTypeHandler<INDEX - 1, Ts...>::from(from_type, token, serializer);
  }
};

/// \private
template <typename... Ts> struct TupleTypeHandler<0, Ts...> {
  static inline Error to(JS::Tuple<Ts...>, ParseContext& context) {
    JS_UNUSED(context);
    return Error::NoError;
  }

  static inline void from(const JS::Tuple<Ts...>& from_type, Token& token, Serializer& serializer) {
    JS_UNUSED(from_type);
    JS_UNUSED(token);
    JS_UNUSED(serializer);
  }
};
} // namespace Internal

/// \private
template <typename... Ts> struct TypeHandler<JS::Tuple<Ts...>> {
  static inline Error to(JS::Tuple<Ts...>& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ArrayStart) {
      return Error::ExpectedArrayStart;
    }
    Error error = context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
    error = JS::Internal::TupleTypeHandler<sizeof...(Ts), Ts...>::to(to_type, context);
    if (error != JS::Error::NoError) {
      return error;
    }
    if (context.token.value_type != JS::Type::ArrayEnd) {
      return Error::ExpectedArrayEnd;
    }
    return Error::NoError;
  }

  static inline void from(const JS::Tuple<Ts...>& from_type, Token& token, Serializer& serializer) {
    token.value_type = Type::ArrayStart;
    token.value = DataRef("[");
    serializer.write(token);

    token.name = DataRef("");

    JS::Internal::TupleTypeHandler<sizeof...(Ts), Ts...>::from(from_type, token, serializer);
    token.name = DataRef("");

    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }
};

namespace Internal {
template <size_t INDEX, typename... Ts> struct StdTupleTypeHandler {
  static inline Error to(std::tuple<Ts...>& to_type, ParseContext& context) {
    using Type = typename std::tuple_element<sizeof...(Ts) - INDEX, std::tuple<Ts...>>::type;
    Error error = TypeHandler<Type>::to(std::get<sizeof...(Ts) - INDEX>(to_type), context);
    if (error != JS::Error::NoError) {
      return error;
    }
    error = context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
    return StdTupleTypeHandler<INDEX - 1, Ts...>::to(to_type, context);
  }

  static inline void from(const std::tuple<Ts...>& from_type, Token& token, Serializer& serializer) {
    using Type = typename std::tuple_element<sizeof...(Ts) - INDEX, std::tuple<Ts...>>::type;
    TypeHandler<Type>::from(std::get<sizeof...(Ts) - INDEX>(from_type), token, serializer);
    StdTupleTypeHandler<INDEX - 1, Ts...>::from(from_type, token, serializer);
  }
};

/// \private
template <typename... Ts> struct StdTupleTypeHandler<0, Ts...> {
  static inline Error to(std::tuple<Ts...>&, ParseContext& context) {
    JS_UNUSED(context);
    return Error::NoError;
  }

  static inline void from(const std::tuple<Ts...>& from_type, Token& token, Serializer& serializer) {
    JS_UNUSED(from_type);
    JS_UNUSED(token);
    JS_UNUSED(serializer);
  }
};
} // namespace Internal
/// \private
template <typename... Ts> struct TypeHandler<std::tuple<Ts...>> {
  static inline Error to(std::tuple<Ts...>& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ArrayStart) {
      return Error::ExpectedArrayStart;
    }
    Error error = context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
    error = JS::Internal::StdTupleTypeHandler<sizeof...(Ts), Ts...>::to(to_type, context);
    if (error != JS::Error::NoError) {
      return error;
    }
    if (context.token.value_type != JS::Type::ArrayEnd) {
      return Error::ExpectedArrayEnd;
    }
    return Error::NoError;
  }

  static inline void from(const std::tuple<Ts...>& from_type, Token& token, Serializer& serializer) {
    token.value_type = Type::ArrayStart;
    token.value = DataRef("[");
    serializer.write(token);

    token.name = DataRef("");

    JS::Internal::StdTupleTypeHandler<sizeof...(Ts), Ts...>::from(from_type, token, serializer);
    token.name = DataRef("");

    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }
};

template <typename T> struct OneOrMany {
  std::vector<T> data;
};

template <typename T> struct TypeHandler<OneOrMany<T>> {
public:
  static inline Error to(OneOrMany<T>& to_type, ParseContext& context) {
    if (context.token.value_type == Type::ArrayStart) {
      context.error = TypeHandler<std::vector<T>>::to(to_type.data, context);
    } else {
      to_type.data.push_back(T());
      context.error = TypeHandler<T>::to(to_type.data.back(), context);
    }
    return context.error;
  }
  static void from(const OneOrMany<T>& from, Token& token, Serializer& serializer) {
    if (from.data.empty()) {
      return;
    }
    if (from.data.size() > 1) {
      TypeHandler<std::vector<T>>::from(from.data, token, serializer);
    } else {
      TypeHandler<T>::from(from.data.front(), token, serializer);
    }
  }
};

template <typename T, size_t N> struct TypeHandler<T[N]> {
public:
  static inline Error to(T (&to_type)[N], ParseContext& context) {
    if (context.token.value_type != Type::ArrayStart) {
      return JS::Error::ExpectedArrayStart;
    }

    context.nextToken();
    for (size_t i = 0; i < N; i++) {
      if (context.error != JS::Error::NoError) {
        return context.error;
      }
      context.error = TypeHandler<T>::to(to_type[i], context);
      if (context.error != JS::Error::NoError) {
        return context.error;
      }

      context.nextToken();
    }

    if (context.token.value_type != Type::ArrayEnd) {
      return JS::Error::ExpectedArrayEnd;
    }
    return context.error;
  }
  static void from(const T (&from)[N], Token& token, Serializer& serializer) {
    token.value_type = Type::ArrayStart;
    token.value = DataRef("[");
    serializer.write(token);

    token.name = DataRef("");
    for (size_t i = 0; i < N; i++) {
      TypeHandler<T>::from(from[i], token, serializer);
    }

    token.name = DataRef("");
    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }
};

template <typename Key, typename Value, typename Map> struct TypeHandlerMap {
  static inline Error to(Map& to_type, ParseContext& context) {
    if (context.token.value_type != Type::ObjectStart) {
      return JS::Error::ExpectedObjectStart;
    }

    Error error = context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
    while (context.token.value_type != Type::ObjectEnd) {
      std::string str;
      Internal::handle_json_escapes_in(context.token.name, str);
      Key key(str.data(), str.size());
      Value v;
      error = TypeHandler<Value>::to(v, context);
      to_type[std::move(key)] = std::move(v);
      if (error != JS::Error::NoError) {
        return error;
      }
      error = context.nextToken();
    }

    return error;
  }

  static void from(const Map& from, Token& token, Serializer& serializer) {
    token.value_type = Type::ObjectStart;
    token.value = DataRef("{");
    serializer.write(token);
    for (auto it = from.begin(); it != from.end(); ++it) {
      token.name = DataRef(it->first);
      token.name_type = Type::String;
      TypeHandler<Value>::from(it->second, token, serializer);
    }
    token.name.size = 0;
    token.name.data = "";
    token.name_type = Type::String;
    token.value_type = Type::ObjectEnd;
    token.value = DataRef("}");
    serializer.write(token);
  }
};

#ifdef JS_STD_UNORDERED_MAP
template <typename Key, typename Value>
struct TypeHandler<std::unordered_map<Key, Value>> : TypeHandlerMap<Key, Value, std::unordered_map<Key, Value>> {};

#endif

namespace Internal {
inline bool compareDataRefWithString(const DataRef& a, const std::string& b) {
  return a.size == b.size() && memcmp(a.data, b.data(), a.size) == 0;
}
} // namespace Internal
struct Map {
  struct It {
    using iterator_category = std::forward_iterator_tag;
    using difference_type = int;
    using value_type = Token;
    using pointer = Token*;
    using reference = Token&;
    const Map& map;
    uint32_t index = 0;
    uint32_t next_meta = 0;
    uint32_t next_complex = 0;

    It(const Map& map) : map(map) {}
    It(const It& other)
        : map(other.map), index(other.index), next_meta(other.next_meta), next_complex(other.next_complex) {}
    inline const Token& operator*() { return map.tokens.data[index]; }

    inline const Token* operator->() { return &map.tokens.data[index]; }

    inline It& operator++() {
      if (index == next_complex) {
        index += map.meta[next_meta].size;
        next_meta += map.meta[next_meta].skip;
        next_complex = next_meta < uint32_t(map.meta.size()) ? uint32_t(map.meta[next_meta].position)
                                                             : uint32_t(map.tokens.data.size());
      } else {
        index++;
      }
      return *this;
    }
    inline bool operator==(const It& other) const { return index == other.index; }
    inline bool operator!=(const It& other) const { return index != other.index; }

    inline void operator=(const It& other) {
      assert(&map == &other.map);
      index = other.index;
      next_meta = other.next_meta;
      next_complex = other.next_complex;
    }
  };

  JS::JsonTokens tokens;
  std::vector<JsonMeta> meta;
  std::vector<std::pair<int, std::string>> json_data;

  inline It begin() const {
    It b(*this);
    b.index = 1;
    b.next_meta = 1;
    b.next_complex =
        b.next_meta < uint32_t(meta.size()) ? uint32_t(meta[b.next_meta].position) : uint32_t(tokens.data.size());
    return b;
  }

  inline It end() const {
    It e(*this);
    e.index = uint32_t(tokens.data.size());
    e.next_meta = 0;
    e.next_complex = 0;
    return e;
  }

  inline It find(const std::string& name) const {
    return std::find_if(begin(), end(), [&name](const Token& token) {
      return Internal::compareDataRefWithString(token.name, name);
    });
  }

  template <typename T> JS::Error castToType(JS::ParseContext& parseContext, T& to) const {
    parseContext.tokenizer.resetData(&tokens.data, 0);
    parseContext.nextToken();
    return JS::TypeHandler<T>::to(to, parseContext);
  }

  template <typename T> JS::Error castToType(const It& iterator, JS::ParseContext& parseContext, T& to) const {
    assert(iterator.index < tokens.data.size());
    parseContext.tokenizer.resetData(&tokens.data, iterator.index);
    parseContext.nextToken();
    return JS::TypeHandler<T>::to(to, parseContext);
  }

  template <typename T> JS::Error castToType(const std::string& name, JS::ParseContext& parseContext, T& to) const {
    if (tokens.data.empty() || tokens.data.front().value_type != JS::Type::ObjectStart) {
      parseContext.error = JS::Error::ExpectedObjectStart;
      return parseContext.error;
    }

    It it = find(name);
    if (it != end()) {
      return castToType(it, parseContext, to);
    }
    parseContext.error = JS::Error::KeyNotFound;
    return parseContext.error;
  }

  template <typename T> T castTo(JS::ParseContext& parseContext) const {
    T t = {};
    castToType<T>(parseContext, t);
    return t;
  }

  template <typename T> T castTo(const std::string& name, JS::ParseContext& parseContext) const {
    T t = {};
    castToType<T>(name, parseContext, t);
    return t;
  }

  template <typename T> JS::Error setValue(JS::ParseContext& parseContext, const T& value) {
    static_assert(
        sizeof(JS::Internal::HasJsonStructBase<T>::template test_in_base<T>(nullptr)) ==
            sizeof(typename JS::Internal::HasJsonStructBase<T>::yes),
        "Not a Json Object type\n"
    );
    std::string obj = JS::serializeStruct(value);
    parseContext.tokenizer.resetData(obj.data(), obj.size(), 0);
    tokens.data.clear();
    meta.clear();
    json_data.clear();
    auto error = parseContext.parseTo(tokens);
    if (error == JS::Error::NoError) {
      assert(tokens.data.size() && tokens.data[0].value_type == JS::Type::ObjectStart);
    }

    meta = metaForTokens(tokens);
    json_data.emplace_back(0, std::move(obj));
    return parseContext.error;
  }

  template <typename T> JS::Error setValue(const std::string& name, JS::ParseContext& parseContext, const T& value) {
    (void) parseContext;
    if (tokens.data.empty()) {
      tokens.data.reserve(10);
      meta.reserve(10);
      JS::Token token;
      token.value_type = JS::Type::ObjectStart;
      token.value = JS::DataRef("{");
      tokens.data.push_back(token);
      token.value_type = JS::Type::ObjectEnd;
      token.value = JS::DataRef("}");
      tokens.data.push_back(token);
      meta = JS::metaForTokens(tokens);
    }

    auto it = find(name);
    if (it != end()) {
      meta[0].children--;
      int tokens_removed = 0;
      if (it.index == it.next_complex) {
        auto theMeta = meta[it.next_meta];
        tokens_removed = theMeta.size;
        meta[0].complex_children--;
        meta[0].size -= theMeta.size;
        meta[0].skip -= theMeta.skip;
        auto start_token = tokens.data.begin() + it.index;
        tokens.data.erase(start_token, start_token + theMeta.size);
        int to_adjust_index = it.next_meta;
        auto start_meta = meta.begin() + it.next_meta;
        meta.erase(start_meta, start_meta + theMeta.skip);
        for (int i = to_adjust_index; i < int(meta.size()); i++) {
          meta[i].position -= theMeta.size;
        }
      } else {
        meta[0].size--;
        tokens.data.erase(tokens.data.begin() + it.index);
        tokens_removed = 1;
      }
      {
        int index_to_remove = -1;
        for (int i = 0; i < int(json_data.size()); i++) {
          if (uint32_t(json_data[i].first) == it.index) {
            index_to_remove = i;
          } else if (uint32_t(json_data[i].first) > it.index) {
            json_data[i].first -= tokens_removed;
          }
        }
        if (index_to_remove >= 0) {
          json_data.erase(json_data.begin() + index_to_remove);
        }
      }
    }
    static const char objectStart[] = "{";
    static const char objectEnd[] = "}";
    std::string out;
    JS::SerializerContext serializeContext(out);
    serializeContext.serializer.setOptions(SerializerOptions(JS::SerializerOptions::Compact));
    JS::Token token;
    token.value_type = Type::ObjectStart;
    token.value = DataRef(objectStart);
    serializeContext.serializer.write(token);

    token.name = DataRef(name);
    token.name_type = Type::String;
    JS::TypeHandler<T>::from(value, token, serializeContext.serializer);

    token.name = DataRef();
    token.value_type = Type::ObjectEnd;
    token.value = DataRef(objectEnd);
    serializeContext.serializer.write(token);

    serializeContext.flush();
    JS::JsonTokens new_tokens;
    JS::ParseContext pc(out.c_str(), out.size(), new_tokens);
    auto new_meta = metaForTokens(new_tokens);

    json_data.emplace_back(int(tokens.data.size() - 1), std::move(out));
    int old_tokens_size = int(tokens.data.size());
    tokens.data.insert(tokens.data.end() - 1, new_tokens.data.begin() + 1, new_tokens.data.end() - 1);
    meta[0].children++;
    if (new_meta[0].complex_children) {
      meta[0].complex_children++;
      meta[0].size += new_meta[1].size;
      meta[0].skip += new_meta[1].skip;
      int old_meta_size = int(meta.size());
      meta.insert(meta.end(), new_meta.begin() + 1, new_meta.end());
      for (int new_meta_i = old_meta_size; new_meta_i < int(meta.size()); new_meta_i++) {
        meta[new_meta_i].position +=
            old_tokens_size - 1 - 1; // position contains an extra and old_tokens_size has another extra
      }
    } else {
      meta[0].size++;
    }

    return JS::Error::NoError;
  }
};

template <> struct TypeHandler<Map> {
  static inline Error to(Map& to_type, ParseContext& context) {
    Error error = TypeHandler<JS::JsonTokens>::to(to_type.tokens, context);
    if (error == Error::NoError) {
      to_type.meta = metaForTokens(to_type.tokens);
    }

    return error;
  }

  static inline void from(const Map& from_type, Token& token, Serializer& serializer) {
    if (from_type.tokens.data.empty()) {
      token.value_type = Type::ObjectStart;
      token.value = DataRef("{");
      serializer.write(token);
      token.name = DataRef("");
      token.value_type = Type::ObjectEnd;
      token.value = DataRef("}");
      serializer.write(token);
      return;
    }

    Token first_token = from_type.tokens.data.front();
    first_token.name = token.name;
    serializer.write(first_token);
    for (int i = 1; i < int(from_type.tokens.data.size()); i++) {
      serializer.write(from_type.tokens.data[i]);
    }
  }
};

template <typename T, size_t COUNT>
struct ArrayVariableContent //-V730
{
  T data[COUNT];
  size_t size = 0;
};

template <typename T, size_t COUNT> struct TypeHandler<ArrayVariableContent<T, COUNT>> {
  static inline Error to(ArrayVariableContent<T, COUNT>& to_type, ParseContext& context) {
    if (context.token.value_type != Type::ArrayStart) {
      return JS::Error::ExpectedArrayStart;
    }

    context.nextToken();
    for (size_t i = 0; i < COUNT; i++) {
      if (context.error != JS::Error::NoError) {
        return context.error;
      }
      if (context.token.value_type == Type::ArrayEnd) {
        to_type.size = i;
        break;
      }
      context.error = TypeHandler<T>::to(to_type.data[i], context);
      if (context.error != JS::Error::NoError) {
        return context.error;
      }

      context.nextToken();
    }

    if (context.token.value_type != Type::ArrayEnd) {
      return JS::Error::ExpectedArrayEnd;
    }
    return context.error;
  }

  static inline void from(const ArrayVariableContent<T, COUNT>& from_type, Token& token, Serializer& serializer) {
    token.value_type = Type::ArrayStart;
    token.value = DataRef("[");
    serializer.write(token);

    token.name = DataRef("");
    for (size_t i = 0; i < from_type.size; i++) {
      TypeHandler<T>::from(from_type.data[i], token, serializer);
    }

    token.name = DataRef("");
    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }
};

template <typename T, typename Set> struct TypeHandlerSet {
  static inline Error to(Set& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ArrayStart) {
      return Error::ExpectedArrayStart;
    }
    Error error = context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
    to_type.clear();
    while (context.token.value_type != JS::Type::ArrayEnd) {
      T t;
      error = TypeHandler<T>::to(t, context);
      if (error != JS::Error::NoError) {
        break;
      }
      auto insert_ret = to_type.insert(std::move(t));
      if (!insert_ret.second) {
        return JS::Error::DuplicateInSet;
      }

      error = context.nextToken();
      if (error != JS::Error::NoError) {
        break;
      }
    }

    return error;
  }

  static inline void from(const Set& set, Token& token, Serializer& serializer) {
    token.value_type = Type::ArrayStart;
    token.value = DataRef("[");
    serializer.write(token);

    token.name = DataRef("");

    for (auto& index : set) {
      TypeHandler<T>::from(index, token, serializer);
    }

    token.name = DataRef("");

    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }
};
} // namespace JS
#endif // JSON_STRUCT_H

#if defined(JS_STL_MAP) && !defined(JS_STL_MAP_INCLUDE)
#define JS_STL_MAP_INCLUDE
#include <map>
namespace JS {
template <typename Key, typename Value>
struct TypeHandler<std::map<Key, Value>> : TypeHandlerMap<Key, Value, std::map<Key, Value>> {};
} // namespace JS
#endif

#if defined(JS_STL_SET) && !defined(JS_STL_SET_INCLUDE)
#define JS_STL_SET_INCLUDE
#include <set>
namespace JS {
template <typename Key> struct TypeHandler<std::set<Key>> : TypeHandlerSet<Key, std::set<Key>> {};
} // namespace JS
#endif

#if defined(JS_STL_UNORDERED_SET) && !defined(JS_STL_UNORDERED_SET_INCLUDE)
#define JS_STL_UNORDERED_SET_INCLUDE
#include <unordered_set>
namespace JS {
template <typename Key> struct TypeHandler<std::unordered_set<Key>> : TypeHandlerSet<Key, std::unordered_set<Key>> {};
} // namespace JS
#endif

#if defined(JS_STL_ARRAY) && !defined(JS_STL_ARRAY_INCLUDE)
#define JS_STL_ARRAY_INCLUDE
#include <array>
namespace JS {
template <typename T, size_t N> struct TypeHandler<std::array<T, N>> {
public:
  static inline Error to(std::array<T, N>& to_type, ParseContext& context) {
    if (context.token.value_type != Type::ArrayStart) {
      return JS::Error::ExpectedArrayStart;
    }

    context.nextToken();
    for (size_t i = 0; i < N; i++) {
      if (context.error != JS::Error::NoError) {
        return context.error;
      }
      context.error = TypeHandler<T>::to(to_type[i], context);
      if (context.error != JS::Error::NoError) {
        return context.error;
      }

      context.nextToken();
    }

    if (context.token.value_type != Type::ArrayEnd) {
      return JS::Error::ExpectedArrayEnd;
    }
    return context.error;
  }
  static void from(const std::array<T, N>& from, Token& token, Serializer& serializer) {
    token.value_type = Type::ArrayStart;
    token.value = DataRef("[");
    serializer.write(token);

    token.name = DataRef("");
    for (size_t i = 0; i < N; i++) {
      TypeHandler<T>::from(from[i], token, serializer);
    }

    token.name = DataRef("");
    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }
};
} // namespace JS
#endif

#if defined(JS_INT_128) && !defined(JS_INT_128_INCLUDE)
#define JS_INT_128_INCLUDE 1
// Compiler support check
#if defined(__SIZEOF_INT128__) && !defined(JS_NO_INT128_TYPEDEF)
namespace JS {
__extension__ using js_int128_t = __int128;
__extension__ using js_uint128_t = unsigned __int128;
} // namespace JS
#endif

namespace JS {
/// \private
template <> struct TypeHandler<js_int128_t> : TypeHandlerIntType<js_int128_t> {};

/// \private
template <> struct TypeHandler<js_uint128_t> : TypeHandlerIntType<js_uint128_t> {};
} // namespace JS
#endif

```

`src/w1base/ext/tinyformat.hpp`:

```hpp
// tinyformat.h
// Copyright (C) 2011, Chris Foster [chris42f (at) gmail (d0t) com]
//
// Boost Software License - Version 1.0
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//------------------------------------------------------------------------------
// Tinyformat: A minimal type safe printf replacement
//
// tinyformat.h is a type safe printf replacement library in a single C++
// header file.  Design goals include:
//
// * Type safety and extensibility for user defined types.
// * C99 printf() compatibility, to the extent possible using std::ostream
// * POSIX extension for positional arguments
// * Simplicity and minimalism.  A single header file to include and distribute
//   with your projects.
// * Augment rather than replace the standard stream formatting mechanism
// * C++98 support, with optional C++11 niceties
//
//
// Main interface example usage
// ----------------------------
//
// To print a date to std::cout for American usage:
//
//   std::string weekday = "Wednesday";
//   const char* month = "July";
//   size_t day = 27;
//   long hour = 14;
//   int min = 44;
//
//   tfm::printf("%s, %s %d, %.2d:%.2d\n", weekday, month, day, hour, min);
//
// POSIX extension for positional arguments is available.
// The ability to rearrange formatting arguments is an important feature
// for localization because the word order may vary in different languages.
//
// Previous example for German usage. Arguments are reordered:
//
//   tfm::printf("%1$s, %3$d. %2$s, %4$d:%5$.2d\n", weekday, month, day, hour, min);
//
// The strange types here emphasize the type safety of the interface; it is
// possible to print a std::string using the "%s" conversion, and a
// size_t using the "%d" conversion.  A similar result could be achieved
// using either of the tfm::format() functions.  One prints on a user provided
// stream:
//
//   tfm::format(std::cerr, "%s, %s %d, %.2d:%.2d\n",
//               weekday, month, day, hour, min);
//
// The other returns a std::string:
//
//   std::string date = tfm::format("%s, %s %d, %.2d:%.2d\n",
//                                  weekday, month, day, hour, min);
//   std::cout << date;
//
// These are the three primary interface functions.  There is also a
// convenience function printfln() which appends a newline to the usual result
// of printf() for super simple logging.
//
//
// User defined format functions
// -----------------------------
//
// Simulating variadic templates in C++98 is pretty painful since it requires
// writing out the same function for each desired number of arguments.  To make
// this bearable tinyformat comes with a set of macros which are used
// internally to generate the API, but which may also be used in user code.
//
// The three macros TINYFORMAT_ARGTYPES(n), TINYFORMAT_VARARGS(n) and
// TINYFORMAT_PASSARGS(n) will generate a list of n argument types,
// type/name pairs and argument names respectively when called with an integer
// n between 1 and 16.  We can use these to define a macro which generates the
// desired user defined function with n arguments.  To generate all 16 user
// defined function bodies, use the macro TINYFORMAT_FOREACH_ARGNUM.  For an
// example, see the implementation of printf() at the end of the source file.
//
// Sometimes it's useful to be able to pass a list of format arguments through
// to a non-template function.  The FormatList class is provided as a way to do
// this by storing the argument list in a type-opaque way.  Continuing the
// example from above, we construct a FormatList using makeFormatList():
//
//   FormatListRef formatList = tfm::makeFormatList(weekday, month, day, hour, min);
//
// The format list can now be passed into any non-template function and used
// via a call to the vformat() function:
//
//   tfm::vformat(std::cout, "%s, %s %d, %.2d:%.2d\n", formatList);
//
//
// Additional API information
// --------------------------
//
// Error handling: Define TINYFORMAT_ERROR to customize the error handling for
// format strings which are unsupported or have the wrong number of format
// specifiers (calls assert() by default).
//
// User defined types: Uses operator<< for user defined types by default.
// Overload formatValue() for more control.

#ifndef TINYFORMAT_H_INCLUDED
#define TINYFORMAT_H_INCLUDED

namespace tinyformat {}
//------------------------------------------------------------------------------
// Config section.  Customize to your liking!

// Namespace alias to encourage brevity
namespace tfm = tinyformat;

// Error handling; calls assert() by default.
// #define TINYFORMAT_ERROR(reasonString) your_error_handler(reasonString)

// Define for C++11 variadic templates which make the code shorter & more
// general.  If you don't define this, C++11 support is autodetected below.
// #define TINYFORMAT_USE_VARIADIC_TEMPLATES

//------------------------------------------------------------------------------
// Implementation details.
#include <algorithm>
#include <cmath>
#include <iostream>
#include <sstream>

#ifndef TINYFORMAT_ASSERT
#include <cassert>
#define TINYFORMAT_ASSERT(cond) assert(cond)
#endif

#ifndef TINYFORMAT_ERROR
#include <cassert>
#define TINYFORMAT_ERROR(reason) assert(0 && reason)
#endif

#if !defined(TINYFORMAT_USE_VARIADIC_TEMPLATES) && !defined(TINYFORMAT_NO_VARIADIC_TEMPLATES)
#ifdef __GXX_EXPERIMENTAL_CXX0X__
#define TINYFORMAT_USE_VARIADIC_TEMPLATES
#endif
#endif

#if defined(__GLIBCXX__) && __GLIBCXX__ < 20080201
//  std::showpos is broken on old libstdc++ as provided with macOS.  See
//  http://gcc.gnu.org/ml/libstdc++/2007-11/msg00075.html
#define TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
#endif

#ifdef __APPLE__
// Workaround macOS linker warning: Xcode uses different default symbol
// visibilities for static libs vs executables (see issue #25)
#define TINYFORMAT_HIDDEN __attribute__((visibility("hidden")))
#else
#define TINYFORMAT_HIDDEN
#endif

namespace tinyformat {

//------------------------------------------------------------------------------
namespace detail {

// Test whether type T1 is convertible to type T2
template <typename T1, typename T2> struct is_convertible {
private:
  // two types of different size
  struct fail {
    char dummy[2];
  };
  struct succeed {
    char dummy;
  };
  // Try to convert a T1 to a T2 by plugging into tryConvert
  static fail tryConvert(...);
  static succeed tryConvert(const T2&);
  static const T1& makeT1();

public:
#ifdef _MSC_VER
  // Disable spurious loss of precision warnings in tryConvert(makeT1())
#pragma warning(push)
#pragma warning(disable : 4244)
#pragma warning(disable : 4267)
#endif
  // Standard trick: the (...) version of tryConvert will be chosen from
  // the overload set only if the version taking a T2 doesn't match.
  // Then we compare the sizes of the return types to check which
  // function matched.  Very neat, in a disgusting kind of way :)
  static const bool value = sizeof(tryConvert(makeT1())) == sizeof(succeed);
#ifdef _MSC_VER
#pragma warning(pop)
#endif
};

// Detect when a type is not a wchar_t string
template <typename T> struct is_wchar {
  typedef int tinyformat_wchar_is_not_supported;
};
template <> struct is_wchar<wchar_t*> {};
template <> struct is_wchar<const wchar_t*> {};
template <int n> struct is_wchar<const wchar_t[n]> {};
template <int n> struct is_wchar<wchar_t[n]> {};

// Format the value by casting to type fmtT.  This default implementation
// should never be called.
template <typename T, typename fmtT, bool convertible = is_convertible<T, fmtT>::value> struct formatValueAsType {
  static void invoke(std::ostream& /*out*/, const T& /*value*/) { TINYFORMAT_ASSERT(0); }
};
// Specialized version for types that can actually be converted to fmtT, as
// indicated by the "convertible" template parameter.
template <typename T, typename fmtT> struct formatValueAsType<T, fmtT, true> {
  static void invoke(std::ostream& out, const T& value) { out << static_cast<fmtT>(value); }
};

#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
template <typename T, bool convertible = is_convertible<T, int>::value> struct formatZeroIntegerWorkaround {
  static bool invoke(std::ostream& /**/, const T& /**/) { return false; }
};
template <typename T> struct formatZeroIntegerWorkaround<T, true> {
  static bool invoke(std::ostream& out, const T& value) {
    if (static_cast<int>(value) == 0 && out.flags() & std::ios::showpos) {
      out << "+0";
      return true;
    }
    return false;
  }
};
#endif // TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND

// Convert an arbitrary type to integer.  The version with convertible=false
// throws an error.
template <typename T, bool convertible = is_convertible<T, int>::value> struct convertToInt {
  static int invoke(const T& /*value*/) {
    TINYFORMAT_ERROR(
        "tinyformat: Cannot convert from argument type to "
        "integer for use as variable width or precision"
    );
    return 0;
  }
};
// Specialization for convertToInt when conversion is possible
template <typename T> struct convertToInt<T, true> {
  static int invoke(const T& value) { return static_cast<int>(value); }
};

// Format at most ntrunc characters to the given stream.
template <typename T> inline void formatTruncated(std::ostream& out, const T& value, int ntrunc) {
  std::ostringstream tmp;
  tmp << value;
  std::string result = tmp.str();
  out.write(result.c_str(), (std::min) (ntrunc, static_cast<int>(result.size())));
}
#define TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(type)                                                                  \
  inline void formatTruncated(std::ostream& out, type* value, int ntrunc) {                                            \
    std::streamsize len = 0;                                                                                           \
    while (len < ntrunc && value[len] != 0)                                                                            \
      ++len;                                                                                                           \
    out.write(value, len);                                                                                             \
  }
// Overload for const char* and char*.  Could overload for signed & unsigned
// char too, but these are technically unneeded for printf compatibility.
TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(const char)
TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(char)
#undef TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR

template <typename T> void spaceFillIfNotFinite(std::ostream& out, const T& value) {}
// TODO: type_traits would clearly be better here. Should consider moving all
// these workarounds into a big pre-C++11 section.
#define TINYFORMAT_SETFILL_NOT_FINITE_FLOATING(type)                                                                   \
  inline void spaceFillIfNotFinite(std::ostream& out, type value) {                                                    \
    if (out.fill() == '0' && !std::isfinite(value))                                                                    \
      out.fill(' ');                                                                                                   \
  }
TINYFORMAT_SETFILL_NOT_FINITE_FLOATING(float)
TINYFORMAT_SETFILL_NOT_FINITE_FLOATING(double)
TINYFORMAT_SETFILL_NOT_FINITE_FLOATING(long double)
#undef TINYFORMAT_SETFILL_NOT_FINITE_FLOATING

} // namespace detail

//------------------------------------------------------------------------------
// Variable formatting functions.  May be overridden for user-defined types if
// desired.

/// Format a value into a stream, delegating to operator<< by default.
///
/// Users may override this for their own types.  When this function is called,
/// the stream flags will have been modified according to the format string.
/// The format specification is provided in the range [fmtBegin, fmtEnd).  For
/// truncating conversions, ntrunc is set to the desired maximum number of
/// characters, for example "%.7s" calls formatValue with ntrunc = 7.
///
/// By default, formatValue() uses the usual stream insertion operator
/// operator<< to format the type T, with special cases for the %c and %p
/// conversions.
template <typename T>
inline void formatValue(std::ostream& out, const char* /*fmtBegin*/, const char* fmtEnd, int ntrunc, const T& value) {
#ifndef TINYFORMAT_ALLOW_WCHAR_STRINGS
  // Since we don't support printing of wchar_t using "%ls", make it fail at
  // compile time in preference to printing as a void* at runtime.
  typedef typename detail::is_wchar<T>::tinyformat_wchar_is_not_supported DummyType;
  (void) DummyType(); // avoid unused type warning with gcc-4.8
#endif
  // The mess here is to support the %c and %p conversions: if these
  // conversions are active we try to convert the type to a char or const
  // void* respectively and format that instead of the value itself.  For the
  // %p conversion it's important to avoid dereferencing the pointer, which
  // could otherwise lead to a crash when printing a dangling (const char*).
  const bool canConvertToChar = detail::is_convertible<T, char>::value;
  const bool canConvertToVoidPtr = detail::is_convertible<T, const void*>::value;
  detail::spaceFillIfNotFinite(out, value);
  if (canConvertToChar && *(fmtEnd - 1) == 'c') {
    detail::formatValueAsType<T, char>::invoke(out, value);
  } else if (canConvertToVoidPtr && *(fmtEnd - 1) == 'p') {
    detail::formatValueAsType<T, const void*>::invoke(out, value);
  }
#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
  else if (detail::formatZeroIntegerWorkaround<T>::invoke(out, value)) /**/
    ;
#endif
  else if (ntrunc >= 0) {
    // Take care not to overread C strings in truncating conversions like
    // "%.4s" where at most 4 characters may be read.
    detail::formatTruncated(out, value, ntrunc);
  } else {
    out << value;
  }
}

// Overloaded version for char types to support printing as an integer
#define TINYFORMAT_DEFINE_FORMATVALUE_CHAR(charType)                                                                   \
  inline void formatValue(std::ostream& out, const char* /*fmtBegin*/, const char* fmtEnd, int /**/, charType value) { \
    switch (*(fmtEnd - 1)) {                                                                                           \
    case 'u':                                                                                                          \
    case 'd':                                                                                                          \
    case 'i':                                                                                                          \
    case 'o':                                                                                                          \
    case 'X':                                                                                                          \
    case 'x':                                                                                                          \
      out << static_cast<int>(value);                                                                                  \
      break;                                                                                                           \
    default:                                                                                                           \
      out << value;                                                                                                    \
      break;                                                                                                           \
    }                                                                                                                  \
  }
// per 3.9.1: char, signed char and unsigned char are all distinct types
TINYFORMAT_DEFINE_FORMATVALUE_CHAR(char)
TINYFORMAT_DEFINE_FORMATVALUE_CHAR(signed char)
TINYFORMAT_DEFINE_FORMATVALUE_CHAR(unsigned char)
#undef TINYFORMAT_DEFINE_FORMATVALUE_CHAR

//------------------------------------------------------------------------------
// Tools for emulating variadic templates in C++98.  The basic idea here is
// stolen from the boost preprocessor metaprogramming library and cut down to
// be just general enough for what we need.

#define TINYFORMAT_ARGTYPES(n) TINYFORMAT_ARGTYPES_##n
#define TINYFORMAT_VARARGS(n) TINYFORMAT_VARARGS_##n
#define TINYFORMAT_PASSARGS(n) TINYFORMAT_PASSARGS_##n
#define TINYFORMAT_PASSARGS_TAIL(n) TINYFORMAT_PASSARGS_TAIL_##n

// To keep it as transparent as possible, the macros below have been generated
// using python via the excellent cog code generation script.  This avoids
// the need for a bunch of complex (but more general) preprocessor tricks as
// used in boost.preprocessor.
//
// To rerun the code generation in place, use `cog -r tinyformat.h`
// (see http://nedbatchelder.com/code/cog).  Alternatively you can just create
// extra versions by hand.

/*[[[cog
maxParams = 16

def makeCommaSepLists(lineTemplate, elemTemplate, startInd=1):
    for j in range(startInd,maxParams+1):
        list = ', '.join([elemTemplate % {'i':i} for i in range(startInd,j+1)])
        cog.outl(lineTemplate % {'j':j, 'list':list})

makeCommaSepLists('#define TINYFORMAT_ARGTYPES_%(j)d %(list)s',
                  'class T%(i)d')

cog.outl()
makeCommaSepLists('#define TINYFORMAT_VARARGS_%(j)d %(list)s',
                  'const T%(i)d& v%(i)d')

cog.outl()
makeCommaSepLists('#define TINYFORMAT_PASSARGS_%(j)d %(list)s', 'v%(i)d')

cog.outl()
cog.outl('#define TINYFORMAT_PASSARGS_TAIL_1')
makeCommaSepLists('#define TINYFORMAT_PASSARGS_TAIL_%(j)d , %(list)s',
                  'v%(i)d', startInd = 2)

cog.outl()
cog.outl('#define TINYFORMAT_FOREACH_ARGNUM(m) \\\n    ' +
         ' '.join(['m(%d)' % (j,) for j in range(1,maxParams+1)]))
]]]*/
#define TINYFORMAT_ARGTYPES_1 class T1
#define TINYFORMAT_ARGTYPES_2 class T1, class T2
#define TINYFORMAT_ARGTYPES_3 class T1, class T2, class T3
#define TINYFORMAT_ARGTYPES_4 class T1, class T2, class T3, class T4
#define TINYFORMAT_ARGTYPES_5 class T1, class T2, class T3, class T4, class T5
#define TINYFORMAT_ARGTYPES_6 class T1, class T2, class T3, class T4, class T5, class T6
#define TINYFORMAT_ARGTYPES_7 class T1, class T2, class T3, class T4, class T5, class T6, class T7
#define TINYFORMAT_ARGTYPES_8 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8
#define TINYFORMAT_ARGTYPES_9 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9
#define TINYFORMAT_ARGTYPES_10                                                                                         \
  class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10
#define TINYFORMAT_ARGTYPES_11                                                                                         \
  class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11
#define TINYFORMAT_ARGTYPES_12                                                                                         \
  class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11,      \
      class T12
#define TINYFORMAT_ARGTYPES_13                                                                                         \
  class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11,      \
      class T12, class T13
#define TINYFORMAT_ARGTYPES_14                                                                                         \
  class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11,      \
      class T12, class T13, class T14
#define TINYFORMAT_ARGTYPES_15                                                                                         \
  class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11,      \
      class T12, class T13, class T14, class T15
#define TINYFORMAT_ARGTYPES_16                                                                                         \
  class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11,      \
      class T12, class T13, class T14, class T15, class T16

#define TINYFORMAT_VARARGS_1 const T1& v1
#define TINYFORMAT_VARARGS_2 const T1 &v1, const T2 &v2
#define TINYFORMAT_VARARGS_3 const T1 &v1, const T2 &v2, const T3 &v3
#define TINYFORMAT_VARARGS_4 const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4
#define TINYFORMAT_VARARGS_5 const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5
#define TINYFORMAT_VARARGS_6 const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6
#define TINYFORMAT_VARARGS_7                                                                                           \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7
#define TINYFORMAT_VARARGS_8                                                                                           \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8
#define TINYFORMAT_VARARGS_9                                                                                           \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8,      \
      const T9 &v9
#define TINYFORMAT_VARARGS_10                                                                                          \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8,      \
      const T9 &v9, const T10 &v10
#define TINYFORMAT_VARARGS_11                                                                                          \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8,      \
      const T9 &v9, const T10 &v10, const T11 &v11
#define TINYFORMAT_VARARGS_12                                                                                          \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8,      \
      const T9 &v9, const T10 &v10, const T11 &v11, const T12 &v12
#define TINYFORMAT_VARARGS_13                                                                                          \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8,      \
      const T9 &v9, const T10 &v10, const T11 &v11, const T12 &v12, const T13 &v13
#define TINYFORMAT_VARARGS_14                                                                                          \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8,      \
      const T9 &v9, const T10 &v10, const T11 &v11, const T12 &v12, const T13 &v13, const T14 &v14
#define TINYFORMAT_VARARGS_15                                                                                          \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8,      \
      const T9 &v9, const T10 &v10, const T11 &v11, const T12 &v12, const T13 &v13, const T14 &v14, const T15 &v15
#define TINYFORMAT_VARARGS_16                                                                                          \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8,      \
      const T9 &v9, const T10 &v10, const T11 &v11, const T12 &v12, const T13 &v13, const T14 &v14, const T15 &v15,    \
      const T16 &v16

#define TINYFORMAT_PASSARGS_1 v1
#define TINYFORMAT_PASSARGS_2 v1, v2
#define TINYFORMAT_PASSARGS_3 v1, v2, v3
#define TINYFORMAT_PASSARGS_4 v1, v2, v3, v4
#define TINYFORMAT_PASSARGS_5 v1, v2, v3, v4, v5
#define TINYFORMAT_PASSARGS_6 v1, v2, v3, v4, v5, v6
#define TINYFORMAT_PASSARGS_7 v1, v2, v3, v4, v5, v6, v7
#define TINYFORMAT_PASSARGS_8 v1, v2, v3, v4, v5, v6, v7, v8
#define TINYFORMAT_PASSARGS_9 v1, v2, v3, v4, v5, v6, v7, v8, v9
#define TINYFORMAT_PASSARGS_10 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10
#define TINYFORMAT_PASSARGS_11 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11
#define TINYFORMAT_PASSARGS_12 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
#define TINYFORMAT_PASSARGS_13 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13
#define TINYFORMAT_PASSARGS_14 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14
#define TINYFORMAT_PASSARGS_15 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15
#define TINYFORMAT_PASSARGS_16 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16

#define TINYFORMAT_PASSARGS_TAIL_1
#define TINYFORMAT_PASSARGS_TAIL_2 , v2
#define TINYFORMAT_PASSARGS_TAIL_3 , v2, v3
#define TINYFORMAT_PASSARGS_TAIL_4 , v2, v3, v4
#define TINYFORMAT_PASSARGS_TAIL_5 , v2, v3, v4, v5
#define TINYFORMAT_PASSARGS_TAIL_6 , v2, v3, v4, v5, v6
#define TINYFORMAT_PASSARGS_TAIL_7 , v2, v3, v4, v5, v6, v7
#define TINYFORMAT_PASSARGS_TAIL_8 , v2, v3, v4, v5, v6, v7, v8
#define TINYFORMAT_PASSARGS_TAIL_9 , v2, v3, v4, v5, v6, v7, v8, v9
#define TINYFORMAT_PASSARGS_TAIL_10 , v2, v3, v4, v5, v6, v7, v8, v9, v10
#define TINYFORMAT_PASSARGS_TAIL_11 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11
#define TINYFORMAT_PASSARGS_TAIL_12 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
#define TINYFORMAT_PASSARGS_TAIL_13 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13
#define TINYFORMAT_PASSARGS_TAIL_14 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14
#define TINYFORMAT_PASSARGS_TAIL_15 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15
#define TINYFORMAT_PASSARGS_TAIL_16 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16

#define TINYFORMAT_FOREACH_ARGNUM(m)                                                                                   \
  m(1) m(2) m(3) m(4) m(5) m(6) m(7) m(8) m(9) m(10) m(11) m(12) m(13) m(14) m(15) m(16)
//[[[end]]]

namespace detail {

// Type-opaque holder for an argument to format(), with associated actions on
// the type held as explicit function pointers.  This allows FormatArg's for
// each argument to be allocated as a homogeneous array inside FormatList
// whereas a naive implementation based on inheritance does not.
class FormatArg {
public:
  FormatArg() : m_value(NULL), m_formatImpl(NULL), m_toIntImpl(NULL) {}

  template <typename T>
  FormatArg(const T& value)
      // C-style cast here allows us to also remove volatile; we put it
      // back in the *Impl functions before dereferencing to avoid UB.
      : m_value((const void*) (&value)), m_formatImpl(&formatImpl<T>), m_toIntImpl(&toIntImpl<T>) {}

  void format(std::ostream& out, const char* fmtBegin, const char* fmtEnd, int ntrunc) const {
    TINYFORMAT_ASSERT(m_value);
    TINYFORMAT_ASSERT(m_formatImpl);
    m_formatImpl(out, fmtBegin, fmtEnd, ntrunc, m_value);
  }

  int toInt() const {
    TINYFORMAT_ASSERT(m_value);
    TINYFORMAT_ASSERT(m_toIntImpl);
    return m_toIntImpl(m_value);
  }

private:
  template <typename T>
  TINYFORMAT_HIDDEN static void formatImpl(
      std::ostream& out, const char* fmtBegin, const char* fmtEnd, int ntrunc, const void* value
  ) {
    formatValue(out, fmtBegin, fmtEnd, ntrunc, *static_cast<const T*>(value));
  }

  template <typename T> TINYFORMAT_HIDDEN static int toIntImpl(const void* value) {
    return convertToInt<T>::invoke(*static_cast<const T*>(value));
  }

  const void* m_value;
  void (*m_formatImpl)(std::ostream& out, const char* fmtBegin, const char* fmtEnd, int ntrunc, const void* value);
  int (*m_toIntImpl)(const void* value);
};

// Parse and return an integer from the string c, as atoi()
// On return, c is set to one past the end of the integer.
inline int parseIntAndAdvance(const char*& c) {
  int i = 0;
  for (; *c >= '0' && *c <= '9'; ++c) {
    i = 10 * i + (*c - '0');
  }
  return i;
}

// Parse width or precision `n` from format string pointer `c`, and advance it
// to the next character. If an indirection is requested with `*`, the argument
// is read from `args[argIndex]` and `argIndex` is incremented (or read
// from `args[n]` in positional mode). Returns true if one or more
// characters were read.
inline bool parseWidthOrPrecision(
    int& n, const char*& c, bool positionalMode, const detail::FormatArg* args, int& argIndex, int numArgs
) {
  if (*c >= '0' && *c <= '9') {
    n = parseIntAndAdvance(c);
  } else if (*c == '*') {
    ++c;
    n = 0;
    if (positionalMode) {
      int pos = parseIntAndAdvance(c) - 1;
      if (*c != '$') {
        TINYFORMAT_ERROR("tinyformat: Non-positional argument used after a positional one");
      }
      if (pos >= 0 && pos < numArgs) {
        n = args[pos].toInt();
      } else {
        TINYFORMAT_ERROR("tinyformat: Positional argument out of range");
      }
      ++c;
    } else {
      if (argIndex < numArgs) {
        n = args[argIndex++].toInt();
      } else {
        TINYFORMAT_ERROR("tinyformat: Not enough arguments to read variable width or precision");
      }
    }
  } else {
    return false;
  }
  return true;
}

// Print literal part of format string and return next format spec position.
//
// Skips over any occurrences of '%%', printing a literal '%' to the output.
// The position of the first % character of the next nontrivial format spec is
// returned, or the end of string.
inline const char* printFormatStringLiteral(std::ostream& out, const char* fmt) {
  const char* c = fmt;
  for (;; ++c) {
    if (*c == '\0') {
      out.write(fmt, c - fmt);
      return c;
    } else if (*c == '%') {
      out.write(fmt, c - fmt);
      if (*(c + 1) != '%') {
        return c;
      }
      // for "%%", tack trailing % onto next literal section.
      fmt = ++c;
    }
  }
}

// Parse a format string and set the stream state accordingly.
//
// The format mini-language recognized here is meant to be the one from C99,
// with the form "%[flags][width][.precision][length]type" with POSIX
// positional arguments extension.
//
// POSIX positional arguments extension:
// Conversions can be applied to the nth argument after the format in
// the argument list, rather than to the next unused argument. In this case,
// the conversion specifier character % (see below) is replaced by the sequence
// "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}],
// giving the position of the argument in the argument list. This feature
// provides for the definition of format strings that select arguments
// in an order appropriate to specific languages.
//
// The format can contain either numbered argument conversion specifications
// (that is, "%n$" and "*m$"), or unnumbered argument conversion specifications
// (that is, % and * ), but not both. The only exception to this is that %%
// can be mixed with the "%n$" form. The results of mixing numbered and
// unnumbered argument specifications in a format string are undefined.
// When numbered argument specifications are used, specifying the Nth argument
// requires that all the leading arguments, from the first to the (N-1)th,
// are specified in the format string.
//
// In format strings containing the "%n$" form of conversion specification,
// numbered arguments in the argument list can be referenced from the format
// string as many times as required.
//
// Formatting options which can't be natively represented using the ostream
// state are returned in spacePadPositive (for space padded positive numbers)
// and ntrunc (for truncating conversions).  argIndex is incremented if
// necessary to pull out variable width and precision.  The function returns a
// pointer to the character after the end of the current format spec.
inline const char* streamStateFromFormat(
    std::ostream& out, bool& positionalMode, bool& spacePadPositive, int& ntrunc, const char* fmtStart,
    const detail::FormatArg* args, int& argIndex, int numArgs
) {
  TINYFORMAT_ASSERT(*fmtStart == '%');
  // Reset stream state to defaults.
  out.width(0);
  out.precision(6);
  out.fill(' ');
  // Reset most flags; ignore irrelevant unitbuf & skipws.
  out.unsetf(
      std::ios::adjustfield | std::ios::basefield | std::ios::floatfield | std::ios::showbase | std::ios::boolalpha |
      std::ios::showpoint | std::ios::showpos | std::ios::uppercase
  );
  bool precisionSet = false;
  bool widthSet = false;
  int widthExtra = 0;
  const char* c = fmtStart + 1;

  // 1) Parse an argument index (if followed by '$') or a width possibly
  // preceded with '0' flag.
  if (*c >= '0' && *c <= '9') {
    const char tmpc = *c;
    int value = parseIntAndAdvance(c);
    if (*c == '$') {
      // value is an argument index
      if (value > 0 && value <= numArgs) {
        argIndex = value - 1;
      } else {
        TINYFORMAT_ERROR("tinyformat: Positional argument out of range");
      }
      ++c;
      positionalMode = true;
    } else if (positionalMode) {
      TINYFORMAT_ERROR("tinyformat: Non-positional argument used after a positional one");
    } else {
      if (tmpc == '0') {
        // Use internal padding so that numeric values are
        // formatted correctly, eg -00010 rather than 000-10
        out.fill('0');
        out.setf(std::ios::internal, std::ios::adjustfield);
      }
      if (value != 0) {
        // Nonzero value means that we parsed width.
        widthSet = true;
        out.width(value);
      }
    }
  } else if (positionalMode) {
    TINYFORMAT_ERROR("tinyformat: Non-positional argument used after a positional one");
  }
  // 2) Parse flags and width if we did not do it in previous step.
  if (!widthSet) {
    // Parse flags
    for (;; ++c) {
      switch (*c) {
      case '#':
        out.setf(std::ios::showpoint | std::ios::showbase);
        continue;
      case '0':
        // overridden by left alignment ('-' flag)
        if (!(out.flags() & std::ios::left)) {
          // Use internal padding so that numeric values are
          // formatted correctly, eg -00010 rather than 000-10
          out.fill('0');
          out.setf(std::ios::internal, std::ios::adjustfield);
        }
        continue;
      case '-':
        out.fill(' ');
        out.setf(std::ios::left, std::ios::adjustfield);
        continue;
      case ' ':
        // overridden by show positive sign, '+' flag.
        if (!(out.flags() & std::ios::showpos)) {
          spacePadPositive = true;
        }
        continue;
      case '+':
        out.setf(std::ios::showpos);
        spacePadPositive = false;
        widthExtra = 1;
        continue;
      default:
        break;
      }
      break;
    }
    // Parse width
    int width = 0;
    widthSet = parseWidthOrPrecision(width, c, positionalMode, args, argIndex, numArgs);
    if (widthSet) {
      if (width < 0) {
        // negative widths correspond to '-' flag set
        out.fill(' ');
        out.setf(std::ios::left, std::ios::adjustfield);
        width = -width;
      }
      out.width(width);
    }
  }
  // 3) Parse precision
  if (*c == '.') {
    ++c;
    int precision = 0;
    parseWidthOrPrecision(precision, c, positionalMode, args, argIndex, numArgs);
    // Presence of `.` indicates precision set, unless the inferred value
    // was negative in which case the default is used.
    precisionSet = precision >= 0;
    if (precisionSet) {
      out.precision(precision);
    }
  }
  // 4) Ignore any C99 length modifier
  while (*c == 'l' || *c == 'h' || *c == 'L' || *c == 'j' || *c == 'z' || *c == 't') {
    ++c;
  }
  // 5) We're up to the conversion specifier character.
  // Set stream flags based on conversion specifier (thanks to the
  // boost::format class for forging the way here).
  bool intConversion = false;
  switch (*c) {
  case 'u':
  case 'd':
  case 'i':
    out.setf(std::ios::dec, std::ios::basefield);
    intConversion = true;
    break;
  case 'o':
    out.setf(std::ios::oct, std::ios::basefield);
    intConversion = true;
    break;
  case 'X':
    out.setf(std::ios::uppercase);
    // Falls through
  case 'x':
  case 'p':
    out.setf(std::ios::hex, std::ios::basefield);
    intConversion = true;
    break;
  case 'E':
    out.setf(std::ios::uppercase);
    // Falls through
  case 'e':
    out.setf(std::ios::scientific, std::ios::floatfield);
    out.setf(std::ios::dec, std::ios::basefield);
    break;
  case 'F':
    out.setf(std::ios::uppercase);
    // Falls through
  case 'f':
    out.setf(std::ios::fixed, std::ios::floatfield);
    break;
  case 'A':
    out.setf(std::ios::uppercase);
    // Falls through
  case 'a':
#ifdef _MSC_VER
    // Workaround
    // https://developercommunity.visualstudio.com/content/problem/520472/hexfloat-stream-output-does-not-ignore-precision-a.html
    // by always setting maximum precision on MSVC to avoid precision
    // loss for doubles.
    out.precision(13);
#endif
    out.setf(std::ios::fixed | std::ios::scientific, std::ios::floatfield);
    break;
  case 'G':
    out.setf(std::ios::uppercase);
    // Falls through
  case 'g':
    out.setf(std::ios::dec, std::ios::basefield);
    // As in boost::format, let stream decide float format.
    out.flags(out.flags() & ~std::ios::floatfield);
    break;
  case 'c':
    // Handled as special case inside formatValue()
    break;
  case 's':
    if (precisionSet) {
      ntrunc = static_cast<int>(out.precision());
    }
    // Make %s print Booleans as "true" and "false"
    out.setf(std::ios::boolalpha);
    break;
  case 'n':
    // Not supported - will cause problems!
    TINYFORMAT_ERROR("tinyformat: %n conversion spec not supported");
    break;
  case '\0':
    TINYFORMAT_ERROR(
        "tinyformat: Conversion spec incorrectly "
        "terminated by end of string"
    );
    return c;
  default:
    break;
  }
  if (intConversion && precisionSet && !widthSet) {
    // "precision" for integers gives the minimum number of digits (to be
    // padded with zeros on the left).  This isn't really supported by the
    // iostreams, but we can approximately simulate it with the width if
    // the width isn't otherwise used.
    out.width(out.precision() + widthExtra);
    out.setf(std::ios::internal, std::ios::adjustfield);
    out.fill('0');
  }
  return c + 1;
}

//------------------------------------------------------------------------------
inline void formatImpl(std::ostream& out, const char* fmt, const detail::FormatArg* args, int numArgs) {
  // Saved stream state
  std::streamsize origWidth = out.width();
  std::streamsize origPrecision = out.precision();
  std::ios::fmtflags origFlags = out.flags();
  char origFill = out.fill();

  // "Positional mode" means all format specs should be of the form "%n$..."
  // with `n` an integer. We detect this in `streamStateFromFormat`.
  bool positionalMode = false;
  int argIndex = 0;
  while (true) {
    fmt = printFormatStringLiteral(out, fmt);
    if (*fmt == '\0') {
      if (!positionalMode && argIndex < numArgs) {
        TINYFORMAT_ERROR("tinyformat: Not enough conversion specifiers in format string");
      }
      break;
    }
    bool spacePadPositive = false;
    int ntrunc = -1;
    const char* fmtEnd =
        streamStateFromFormat(out, positionalMode, spacePadPositive, ntrunc, fmt, args, argIndex, numArgs);
    // NB: argIndex may be incremented by reading variable width/precision
    // in `streamStateFromFormat`, so do the bounds check here.
    if (argIndex >= numArgs) {
      TINYFORMAT_ERROR("tinyformat: Too many conversion specifiers in format string");
      return;
    }
    const FormatArg& arg = args[argIndex];
    // Format the arg into the stream.
    if (!spacePadPositive) {
      arg.format(out, fmt, fmtEnd, ntrunc);
    } else {
      // The following is a special case with no direct correspondence
      // between stream formatting and the printf() behaviour.  Simulate
      // it crudely by formatting into a temporary string stream and
      // munging the resulting string.
      std::ostringstream tmpStream;
      tmpStream.copyfmt(out);
      tmpStream.setf(std::ios::showpos);
      arg.format(tmpStream, fmt, fmtEnd, ntrunc);
      std::string result = tmpStream.str(); // allocates... yuck.
      for (size_t i = 0, iend = result.size(); i < iend; ++i) {
        if (result[i] == '+') {
          result[i] = ' ';
        }
      }
      out << result;
    }
    if (!positionalMode) {
      ++argIndex;
    }
    fmt = fmtEnd;
  }

  // Restore stream state
  out.width(origWidth);
  out.precision(origPrecision);
  out.flags(origFlags);
  out.fill(origFill);
}

} // namespace detail

/// List of template arguments format(), held in a type-opaque way.
///
/// A const reference to FormatList (typedef'd as FormatListRef) may be
/// conveniently used to pass arguments to non-template functions: All type
/// information has been stripped from the arguments, leaving just enough of a
/// common interface to perform formatting as required.
class FormatList {
public:
  FormatList(detail::FormatArg* args, int N) : m_args(args), m_N(N) {}

  friend void vformat(std::ostream& out, const char* fmt, const FormatList& list);

private:
  const detail::FormatArg* m_args;
  int m_N;
};

/// Reference to type-opaque format list for passing to vformat()
typedef const FormatList& FormatListRef;

namespace detail {

// Format list subclass with fixed storage to avoid dynamic allocation
template <std::size_t N> class FormatListN : public FormatList {
public:
#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES
  template <typename... Args>
  FormatListN(const Args&... args) : FormatList(&m_formatterStore[0], N), m_formatterStore{FormatArg(args)...} {
    static_assert(sizeof...(args) == N, "Number of args must be N");
  }
#else // C++98 version
  void init(int) {}
#define TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR(n)                                                                      \
                                                                                                                       \
  template <TINYFORMAT_ARGTYPES(n)> FormatListN(TINYFORMAT_VARARGS(n)) : FormatList(&m_formatterStore[0], n) {         \
    TINYFORMAT_ASSERT(n == N);                                                                                         \
    init(0, TINYFORMAT_PASSARGS(n));                                                                                   \
  }                                                                                                                    \
                                                                                                                       \
  template <TINYFORMAT_ARGTYPES(n)> void init(int i, TINYFORMAT_VARARGS(n)) {                                          \
    m_formatterStore[i] = FormatArg(v1);                                                                               \
    init(i + 1 TINYFORMAT_PASSARGS_TAIL(n));                                                                           \
  }

  TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR)
#undef TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR
#endif
  FormatListN(const FormatListN& other) : FormatList(&m_formatterStore[0], N) {
    std::copy(&other.m_formatterStore[0], &other.m_formatterStore[N], &m_formatterStore[0]);
  }

private:
  FormatArg m_formatterStore[N];
};

// Special 0-arg version - MSVC says zero-sized C array in struct is nonstandard
template <> class FormatListN<0> : public FormatList {
public:
  FormatListN() : FormatList(0, 0) {}
};

} // namespace detail

//------------------------------------------------------------------------------
// Primary API functions

#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES

/// Make type-agnostic format list from list of template arguments.
///
/// The exact return type of this function is an implementation detail and
/// shouldn't be relied upon.  Instead it should be stored as a FormatListRef:
///
///   FormatListRef formatList = makeFormatList( /*...*/ );
template <typename... Args> detail::FormatListN<sizeof...(Args)> makeFormatList(const Args&... args) {
  return detail::FormatListN<sizeof...(args)>(args...);
}

#else // C++98 version

inline detail::FormatListN<0> makeFormatList() { return detail::FormatListN<0>(); }
#define TINYFORMAT_MAKE_MAKEFORMATLIST(n)                                                                              \
  template <TINYFORMAT_ARGTYPES(n)> detail::FormatListN<n> makeFormatList(TINYFORMAT_VARARGS(n)) {                     \
    return detail::FormatListN<n>(TINYFORMAT_PASSARGS(n));                                                             \
  }
TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_MAKEFORMATLIST)
#undef TINYFORMAT_MAKE_MAKEFORMATLIST

#endif

/// Format list of arguments to the stream according to the given format string.
///
/// The name vformat() is chosen for the semantic similarity to vprintf(): the
/// list of format arguments is held in a single function argument.
inline void vformat(std::ostream& out, const char* fmt, FormatListRef list) {
  detail::formatImpl(out, fmt, list.m_args, list.m_N);
}

#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES

/// Format list of arguments to the stream according to given format string.
template <typename... Args> void format(std::ostream& out, const char* fmt, const Args&... args) {
  vformat(out, fmt, makeFormatList(args...));
}

/// Format list of arguments according to the given format string and return
/// the result as a string.
template <typename... Args> std::string format(const char* fmt, const Args&... args) {
  std::ostringstream oss;
  format(oss, fmt, args...);
  return oss.str();
}

/// Format list of arguments to std::cout, according to the given format string
template <typename... Args> void printf(const char* fmt, const Args&... args) { format(std::cout, fmt, args...); }

template <typename... Args> void printfln(const char* fmt, const Args&... args) {
  format(std::cout, fmt, args...);
  std::cout << '\n';
}

#else // C++98 version

inline void format(std::ostream& out, const char* fmt) { vformat(out, fmt, makeFormatList()); }

inline std::string format(const char* fmt) {
  std::ostringstream oss;
  format(oss, fmt);
  return oss.str();
}

inline void printf(const char* fmt) { format(std::cout, fmt); }

inline void printfln(const char* fmt) {
  format(std::cout, fmt);
  std::cout << '\n';
}

#define TINYFORMAT_MAKE_FORMAT_FUNCS(n)                                                                                \
                                                                                                                       \
  template <TINYFORMAT_ARGTYPES(n)> void format(std::ostream& out, const char* fmt, TINYFORMAT_VARARGS(n)) {           \
    vformat(out, fmt, makeFormatList(TINYFORMAT_PASSARGS(n)));                                                         \
  }                                                                                                                    \
                                                                                                                       \
  template <TINYFORMAT_ARGTYPES(n)> std::string format(const char* fmt, TINYFORMAT_VARARGS(n)) {                       \
    std::ostringstream oss;                                                                                            \
    format(oss, fmt, TINYFORMAT_PASSARGS(n));                                                                          \
    return oss.str();                                                                                                  \
  }                                                                                                                    \
                                                                                                                       \
  template <TINYFORMAT_ARGTYPES(n)> void printf(const char* fmt, TINYFORMAT_VARARGS(n)) {                              \
    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                                                                    \
  }                                                                                                                    \
                                                                                                                       \
  template <TINYFORMAT_ARGTYPES(n)> void printfln(const char* fmt, TINYFORMAT_VARARGS(n)) {                            \
    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                                                                    \
    std::cout << '\n';                                                                                                 \
  }

TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMAT_FUNCS)
#undef TINYFORMAT_MAKE_FORMAT_FUNCS

#endif

} // namespace tinyformat

#endif // TINYFORMAT_H_INCLUDED

```

`src/w1base/interval.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <cstddef>

#include "w1base/types.hpp"

namespace w1::util {

constexpr bool range_is_valid(uint64_t start, uint64_t end) { return start < end; }

constexpr uint64_t range_size(uint64_t start, uint64_t end) { return end > start ? end - start : 0; }

constexpr bool range_contains(uint64_t start, uint64_t end, uint64_t address) {
  return address >= start && address < end;
}

constexpr bool range_overlaps(uint64_t start, uint64_t end, uint64_t other_start, uint64_t other_end) {
  return start < other_end && other_start < end;
}

constexpr bool range_contains(const address_range& range, uint64_t address) {
  return range_contains(range.start, range.end, address);
}

constexpr bool range_overlaps(const address_range& left, const address_range& right) {
  return range_overlaps(left.start, left.end, right.start, right.end);
}

constexpr uint64_t range_size(const address_range& range) { return range_size(range.start, range.end); }

constexpr bool range_is_valid(const address_range& range) { return range_is_valid(range.start, range.end); }

inline bool compute_end(uint64_t start, size_t size, uint64_t* end) {
  if (!end) {
    return false;
  }

  if (size == 0) {
    *end = start;
    return true;
  }

  uint64_t end_value = start + static_cast<uint64_t>(size);
  if (end_value < start) {
    return false;
  }

  *end = end_value;
  return true;
}

} // namespace w1::util

```

`src/w1base/module_identity.cpp`:

```cpp
#include "w1base/module_identity.hpp"

#include <cstring>

#if defined(_WIN32)
#include <w1base/windows_clean.hpp>
#else
#include <dlfcn.h>
#endif

namespace w1::util {
namespace {

std::string basename_from_path(const std::string& path) {
  if (path.empty()) {
    return path;
  }

  size_t pos = path.find_last_of("/\\");
  if (pos == std::string::npos) {
    return path;
  }

  return path.substr(pos + 1);
}

} // namespace

module_identity module_identity_from_address(const void* address) {
  module_identity result{};
  if (!address) {
    return result;
  }

#if defined(_WIN32)
  HMODULE module = nullptr;
  if (!GetModuleHandleExA(
          GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
          reinterpret_cast<LPCSTR>(address), &module
      )) {
    return result;
  }

  char buffer[MAX_PATH] = {};
  DWORD length = GetModuleFileNameA(module, buffer, MAX_PATH);
  if (length == 0) {
    return result;
  }

  result.path.assign(buffer, length);
  result.name = basename_from_path(result.path);
#else
  Dl_info info;
  std::memset(&info, 0, sizeof(info));
  if (dladdr(address, &info) == 0) {
    return result;
  }

  if (info.dli_fname) {
    result.path = info.dli_fname;
    result.name = basename_from_path(result.path);
  }
#endif

  return result;
}

} // namespace w1::util

```

`src/w1base/module_identity.hpp`:

```hpp
#pragma once

#include <string>

namespace w1::util {

struct module_identity {
  std::string name;
  std::string path;
};

module_identity module_identity_from_address(const void* address);

} // namespace w1::util

```

`src/w1base/platform_utils.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>

#ifdef _WIN32
#define NEED_PSAPI
#define NEED_TLHELP32
#include <w1base/windows_clean.hpp>
#endif

namespace w1::common {

/**
 * @brief Cross-platform utility functions for platform detection and path handling
 */
namespace platform_utils {

/**
 * @brief Get the current platform name as a string
 * @return Platform name ("darwin", "linux", "windows", or "unknown")
 */
inline std::string get_platform_name() {
#ifdef __APPLE__
  return "darwin";
#elif defined(__linux__)
  return "linux";
#elif defined(_WIN32)
  return "windows";
#else
  return "unknown";
#endif
}

/**
 * @brief Get the appropriate dynamic library file extension for the current platform
 * @return Library extension including the dot (e.g., ".dylib", ".so", ".dll")
 */
inline std::string get_library_extension() {
#ifdef __APPLE__
  return ".dylib";
#elif defined(__linux__)
  return ".so";
#elif defined(_WIN32)
  return ".dll";
#else
#error "Unsupported platform for dynamic library loading"
#endif
}

/**
 * @brief Get standard system library paths for the current platform
 * @return Vector of system library directory paths
 */
inline std::vector<std::string> get_system_library_paths() {
  std::vector<std::string> paths;

#ifdef __APPLE__
  paths = {"/System/Library/", "/usr/lib/", "/usr/local/lib/", "/Library/Frameworks/"};
#elif defined(__linux__)
  paths = {
      "/lib/",
      "/lib64/",
      "/usr/lib/",
      "/usr/lib64/",
      "/usr/local/lib/",
      "/usr/lib/x86_64-linux-gnu/",
      "/lib/x86_64-linux-gnu/"
  };
#elif defined(_WIN32)
  paths = {"C:\\Windows\\System32\\", "C:\\Windows\\SysWOW64\\", "C:\\Program Files\\", "C:\\Program Files (x86)\\"};
#endif

  return paths;
}

/**
 * @brief Check if a given path represents a system library/module
 * @param path The path to check
 * @return True if the path appears to be a system library
 */
inline bool is_system_library_path(const std::string& path) {
  if (path.empty() || path == "[anonymous]" || path.find("[") == 0) {
    return true; // anonymous mappings are usually system
  }

  auto system_paths = get_system_library_paths();
  for (const auto& sys_path : system_paths) {
    if (path.find(sys_path) != std::string::npos) {
      return true;
    }
  }

  // check for common system library name patterns
#ifdef __APPLE__
  return path.find("libsystem_") != std::string::npos || path.find("libc++") != std::string::npos ||
         path.find("libdyld") != std::string::npos || path.find(".framework/") != std::string::npos;
#elif defined(__linux__)
  return path.find("ld-linux") != std::string::npos || path.find("libc.so") != std::string::npos ||
         path.find("libstdc++") != std::string::npos || path.find("libgcc") != std::string::npos;
#elif defined(_WIN32)
  return path.find("ntdll.dll") != std::string::npos || path.find("kernel32.dll") != std::string::npos ||
         path.find("msvcrt.dll") != std::string::npos || path.find("vcruntime") != std::string::npos;
#else
  return false;
#endif
}

/**
 * @brief Get the platform-specific process ID type size
 * @return Size of process ID in bytes
 */
inline size_t get_pid_size() {
#ifdef _WIN32
  return sizeof(DWORD);
#else
  return sizeof(pid_t);
#endif
}

/**
 * @brief Check if the current platform supports runtime library injection
 * @return True if runtime injection is supported
 */
inline bool supports_runtime_injection() {
#ifdef __APPLE__
  return true; // DYLD_INSERT_LIBRARIES
#elif defined(__linux__)
  return true; // LD_PRELOAD
#elif defined(_WIN32)
  return true; // DLL injection via CreateRemoteThread/SetWindowsHookEx
#else
  return false;
#endif
}

/**
 * @brief Get the environment variable name for library preloading
 * @return Environment variable name for the current platform
 */
inline std::string get_preload_env_var() {
#ifdef __APPLE__
  return "DYLD_INSERT_LIBRARIES";
#elif defined(__linux__)
  return "LD_PRELOAD";
#elif defined(_WIN32)
  return ""; // windows doesn't use environment variables for DLL injection
#else
  return "";
#endif
}

} // namespace platform_utils
} // namespace w1::common
```

`src/w1base/signal_handler.cpp`:

```cpp
#include "w1base/signal_handler.hpp"
#include "w1base/stderr_write.hpp"

#include <algorithm>
#include <atomic>
#include <chrono>
#include <cstring>
#include <mutex>
#include <vector>

#ifdef _WIN32
#include <w1base/windows_clean.hpp>
#else
#include <errno.h>
#include <sys/wait.h>
#include <unistd.h>
#endif

#include <redlog.hpp>

namespace w1::tn3ss::signal_handler {

namespace {

struct handler_entry {
  signal_callback callback;
  std::string context;
};

struct cleanup_entry {
  cleanup_callback callback;
  int priority;
  std::string context;
};

// global state
std::mutex g_mutex;
std::vector<handler_entry> g_handlers;
std::vector<cleanup_entry> g_cleanups;
std::vector<int> g_forwarding_pids;
config g_config;
std::atomic<bool> g_initialized{false};
redlog::logger g_log("w1.signal_handler");

void perform_cleanup() {
  // copy cleanup handlers and sort by priority (highest first)
  std::vector<cleanup_entry> cleanups;
  {
    std::lock_guard<std::mutex> lock(g_mutex);
    cleanups = g_cleanups;
  }

  std::sort(cleanups.begin(), cleanups.end(), [](const cleanup_entry& a, const cleanup_entry& b) {
    return a.priority > b.priority;
  });

  // execute cleanup handlers
  for (const auto& cleanup : cleanups) {
    try {
      cleanup.callback();
    } catch (...) {
      // can't safely log in signal context
    }
  }
}

#ifdef _WIN32
BOOL WINAPI console_handler(DWORD ctrl_type) {
  if (ctrl_type != CTRL_C_EVENT) {
    return FALSE;
  }

  if (g_config.log_signals) {
    const char* msg = "received ctrl+c signal\n";
    w1::util::stderr_write(msg);
  }

  // forward to child processes
  std::vector<int> pids;
  {
    std::lock_guard<std::mutex> lock(g_mutex);
    pids = g_forwarding_pids;
  }

  for (int pid : pids) {
    HANDLE process = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
    if (process) {
      TerminateProcess(process, 1);
      CloseHandle(process);
    }
  }

  // call registered handlers
  std::vector<handler_entry> handlers;
  {
    std::lock_guard<std::mutex> lock(g_mutex);
    handlers = g_handlers;
  }

  for (const auto& handler : handlers) {
    try {
      handler.callback(handler.context);
    } catch (...) {
      // can't safely log
    }
  }

  perform_cleanup();
  ExitProcess(1);
  return TRUE;
}

#else
void unix_handler(int signum, [[maybe_unused]] siginfo_t* info, [[maybe_unused]] void* context) {
  if (signum != SIGINT) {
    return;
  }

  if (g_config.log_signals) {
    const char* msg = "received sigint signal\n";
    w1::util::stderr_write(msg);
  }

  // forward to child processes
  std::vector<int> pids;
  {
    std::lock_guard<std::mutex> lock(g_mutex);
    pids = g_forwarding_pids;
  }

  for (int pid : pids) {
    kill(pid, SIGINT);
  }

  // call registered handlers
  std::vector<handler_entry> handlers;
  {
    std::lock_guard<std::mutex> lock(g_mutex);
    handlers = g_handlers;
  }

  for (const auto& handler : handlers) {
    try {
      handler.callback(handler.context);
    } catch (...) {
      // can't safely log
    }
  }

  perform_cleanup();

  // restore default handler and re-raise to actually terminate
  signal(SIGINT, SIG_DFL);
  raise(SIGINT);
}
#endif

} // anonymous namespace

bool initialize(const config& cfg) {
  if (g_initialized.exchange(true)) {
    return true; // already initialized
  }

  {
    std::lock_guard<std::mutex> lock(g_mutex);
    g_config = cfg;
    g_log = redlog::logger("w1.signal_handler." + cfg.context_name);
  }

  g_log.info("initializing signal handler system", redlog::field("context", cfg.context_name));

#ifdef _WIN32
  if (!SetConsoleCtrlHandler(console_handler, TRUE)) {
    g_log.err("failed to install console control handler");
    g_initialized = false;
    return false;
  }
#else
  struct sigaction sa;
  sa.sa_sigaction = unix_handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = SA_SIGINFO | SA_RESTART;

  if (sigaction(SIGINT, &sa, nullptr) != 0) {
    g_log.err("failed to install signal handler", redlog::field("error", strerror(errno)));
    g_initialized = false;
    return false;
  }
#endif

  return true;
}

bool register_handler(signal_callback callback, const std::string& context) {
  if (!g_initialized) {
    return false;
  }

  std::lock_guard<std::mutex> lock(g_mutex);
  g_handlers.push_back({callback, context});

  g_log.dbg("registered signal handler", redlog::field("context", context));
  return true;
}

bool register_cleanup(cleanup_callback callback, int priority, const std::string& context) {
  if (!g_initialized) {
    return false;
  }

  std::lock_guard<std::mutex> lock(g_mutex);
  g_cleanups.push_back({callback, priority, context});

  g_log.dbg("registered cleanup handler", redlog::field("context", context), redlog::field("priority", priority));
  return true;
}

bool setup_forwarding(int child_pid) {
  if (!g_initialized) {
    return false;
  }

  std::lock_guard<std::mutex> lock(g_mutex);

  auto it = std::find(g_forwarding_pids.begin(), g_forwarding_pids.end(), child_pid);
  if (it == g_forwarding_pids.end()) {
    g_forwarding_pids.push_back(child_pid);
    g_log.dbg("setup signal forwarding", redlog::field("child_pid", child_pid));
  }

  return true;
}

void remove_forwarding(int child_pid) {
  std::lock_guard<std::mutex> lock(g_mutex);

  auto it = std::find(g_forwarding_pids.begin(), g_forwarding_pids.end(), child_pid);
  if (it != g_forwarding_pids.end()) {
    g_forwarding_pids.erase(it);
    g_log.dbg("removed signal forwarding", redlog::field("child_pid", child_pid));
  }
}

void shutdown() {
  if (!g_initialized.exchange(false)) {
    return; // not initialized
  }

  g_log.info("shutting down signal handler system");

  {
    std::lock_guard<std::mutex> lock(g_mutex);
    g_handlers.clear();
    g_cleanups.clear();
    g_forwarding_pids.clear();
  }

#ifdef _WIN32
  SetConsoleCtrlHandler(console_handler, FALSE);
#else
  signal(SIGINT, SIG_DFL);
#endif
}

// raii guard implementation
guard::guard(const config& cfg) : initialized_(initialize(cfg)) {}

guard::~guard() {
  if (initialized_) {
    shutdown();
  }
}

bool guard::is_initialized() const { return initialized_; }

} // namespace w1::tn3ss::signal_handler

```

`src/w1base/signal_handler.hpp`:

```hpp
#pragma once

#include <functional>
#include <string>
#include <vector>

#ifdef _WIN32
#include <w1base/windows_clean.hpp>
#else
#include <signal.h>
#include <sys/types.h>
#endif

namespace w1::tn3ss::signal_handler {

/**
 * @brief callback function for signal handlers
 * @param context optional context string for debugging
 */
using signal_callback = std::function<void(const std::string& context)>;

/**
 * @brief cleanup function for graceful shutdown
 * should be signal-safe and fast
 */
using cleanup_callback = std::function<void()>;

/**
 * @brief configuration for signal handling behavior
 */
struct config {
  std::string context_name = "w1tool"; ///< context name for logging
  bool log_signals = false;            ///< log signal reception for debugging
};

/**
 * @brief initialize signal handling system
 * @param cfg configuration for signal handling behavior
 * @return true if initialization succeeded
 */
bool initialize(const config& cfg = {});

/**
 * @brief register a signal handler for SIGINT (ctrl+c)
 * @param callback function to call when signal is received
 * @param context context string for debugging/logging
 * @return true if registration succeeded
 */
bool register_handler(signal_callback callback, const std::string& context = "");

/**
 * @brief register a cleanup function to be called during graceful shutdown
 * @param callback cleanup function (should be signal-safe)
 * @param priority priority for cleanup order (higher = called first)
 * @param context context string for debugging/logging
 * @return true if registration succeeded
 */
bool register_cleanup(cleanup_callback callback, int priority = 0, const std::string& context = "");

/**
 * @brief set up signal forwarding from parent to child process
 * @param child_pid child process ID to forward signals to
 * @return true if forwarding was set up successfully
 */
bool setup_forwarding(int child_pid);

/**
 * @brief remove signal forwarding for a specific child process
 * @param child_pid child process ID to stop forwarding to
 */
void remove_forwarding(int child_pid);

/**
 * @brief cleanup and shutdown the signal handling system
 */
void shutdown();

/**
 * @brief raii helper for signal handling setup/cleanup
 */
class guard {
public:
  explicit guard(const config& cfg = {});
  ~guard();

  guard(const guard&) = delete;
  guard& operator=(const guard&) = delete;
  guard(guard&&) = delete;
  guard& operator=(guard&&) = delete;

  bool is_initialized() const;

private:
  bool initialized_;
};

} // namespace w1::tn3ss::signal_handler
```

`src/w1base/stderr_write.hpp`:

```hpp
#pragma once

#include <cstring>

#ifdef _WIN32
#include <w1base/windows_clean.hpp>
#else
#include <unistd.h>
#endif

namespace w1::util {

/**
 * @brief Platform-agnostic function to write to stderr
 *
 * This function is signal-safe and can be used in signal handlers
 * or exception catch blocks where regular I/O might not be safe.
 *
 * @param message The message to write to stderr
 */
inline void stderr_write(const char* message) {
  if (!message) {
    return;
  }

#ifdef _WIN32
  HANDLE hStderr = GetStdHandle(STD_ERROR_HANDLE);
  if (hStderr != INVALID_HANDLE_VALUE) {
    DWORD written;
    WriteFile(hStderr, message, static_cast<DWORD>(strlen(message)), &written, NULL);
  }
#else
  write(STDERR_FILENO, message, strlen(message));
#endif
}

/**
 * @brief Platform-agnostic function to write to stderr with size
 *
 * @param message The message to write to stderr
 * @param size The size of the message
 */
inline void stderr_write(const char* message, size_t size) {
  if (!message || size == 0) {
    return;
  }

#ifdef _WIN32
  HANDLE hStderr = GetStdHandle(STD_ERROR_HANDLE);
  if (hStderr != INVALID_HANDLE_VALUE) {
    DWORD written;
    WriteFile(hStderr, message, static_cast<DWORD>(size), &written, NULL);
  }
#else
  write(STDERR_FILENO, message, size);
#endif
}

} // namespace w1::util
```

`src/w1base/thread_utils.hpp`:

```hpp
#pragma once

#include <cstdint>

#if defined(_WIN32)
#include <windows.h>
#elif defined(__APPLE__)
#include <pthread.h>
#else
#include <sys/syscall.h>
#include <unistd.h>
#endif

namespace w1::util {

inline uint64_t current_thread_id() {
#if defined(_WIN32)
  return static_cast<uint64_t>(GetCurrentThreadId());
#elif defined(__APPLE__)
  return static_cast<uint64_t>(pthread_mach_thread_np(pthread_self()));
#else
  return static_cast<uint64_t>(syscall(SYS_gettid));
#endif
}

} // namespace w1::util

```

`src/w1base/types.hpp`:

```hpp
#pragma once

#include <cstdint>

namespace w1 {

struct address_range {
  uint64_t start = 0;
  uint64_t end = 0;
};

} // namespace w1

```

`src/w1base/uuid_format.cpp`:

```cpp
#include "uuid_format.hpp"

namespace w1::util {

bool is_all_zero_uuid(std::span<const uint8_t, k_uuid_byte_count> bytes) {
  for (uint8_t value : bytes) {
    if (value != 0) {
      return false;
    }
  }
  return true;
}

std::string format_uuid(std::span<const uint8_t, k_uuid_byte_count> bytes) {
  static constexpr char k_hex[] = "0123456789abcdef";
  std::string out;
  out.reserve(36);
  auto append_byte = [&](uint8_t value) {
    out.push_back(k_hex[(value >> 4) & 0x0f]);
    out.push_back(k_hex[value & 0x0f]);
  };
  size_t idx = 0;
  const size_t groups[] = {4, 2, 2, 2, 6};
  for (size_t group = 0; group < 5; ++group) {
    if (group > 0) {
      out.push_back('-');
    }
    for (size_t i = 0; i < groups[group]; ++i) {
      append_byte(bytes[idx++]);
    }
  }
  return out;
}

} // namespace w1::util

```

`src/w1base/uuid_format.hpp`:

```hpp
#pragma once

#include <array>
#include <cstddef>
#include <cstdint>
#include <span>
#include <string>

namespace w1::util {

constexpr size_t k_uuid_byte_count = 16;

bool is_all_zero_uuid(std::span<const uint8_t, k_uuid_byte_count> bytes);
std::string format_uuid(std::span<const uint8_t, k_uuid_byte_count> bytes);

inline bool is_all_zero_uuid(const std::array<uint8_t, k_uuid_byte_count>& bytes) {
  return is_all_zero_uuid(std::span<const uint8_t, k_uuid_byte_count>(bytes));
}

inline std::string format_uuid(const std::array<uint8_t, k_uuid_byte_count>& bytes) {
  return format_uuid(std::span<const uint8_t, k_uuid_byte_count>(bytes));
}

} // namespace w1::util

```

`src/w1base/windows_clean.hpp`:

```hpp
#pragma once

/**
 * @brief Clean Windows headers without macro pollution
 *
 * This header provides access to Windows APIs while preventing
 * the numerous macro definitions that pollute the global namespace
 * and conflict with modern C++ code.
 *
 * Usage: Include this instead of <windows.h> directly.
 */

#ifdef _WIN32

// Prevent Windows from defining min/max macros and other pollution
#ifndef NOMINMAX
#define NOMINMAX
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

// Prevent common macro conflicts
#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN
#endif

// Include Windows headers
#include <windows.h>

// Additional Windows headers that might be needed
#ifdef NEED_PSAPI
#include <psapi.h>
#endif

#ifdef NEED_TLHELP32
#include <tlhelp32.h>
#endif

// Undefine the most problematic macros that conflict with modern C++
#ifdef IN
#undef IN
#endif

#ifdef OUT
#undef OUT
#endif

#ifdef VOID
#undef VOID
#endif

#ifdef ERROR
#undef ERROR
#endif

#ifdef DELETE
#undef DELETE
#endif

#ifdef OPTIONAL
#undef OPTIONAL
#endif

#ifdef CONST
#undef CONST
#endif

#ifdef CALLBACK
#undef CALLBACK
#endif

#ifdef STRICT
#undef STRICT
#endif

// Common function name conflicts
#ifdef CreateWindow
#undef CreateWindow
#endif

#ifdef CreateFile
#undef CreateFile
#endif

#ifdef LoadLibrary
#undef LoadLibrary
#endif

#ifdef GetMessage
#undef GetMessage
#endif

#ifdef SendMessage
#undef SendMessage
#endif

#ifdef MessageBox
#undef MessageBox
#endif

#ifdef CreateProcess
#undef CreateProcess
#endif

#ifdef CreateMutex
#undef CreateMutex
#endif

#ifdef min
#undef min
#endif

#ifdef max
#undef max
#endif

// If specific Windows types or functions are needed, they should be
// explicitly declared here with proper C++ naming conventions

#endif // _WIN32
```

`src/w1base/windows_console.hpp`:

```hpp
#pragma once

#if defined(_WIN32) || defined(WIN32)

#include <windows.h>
#include <io.h>
#include <fcntl.h>
#include <cstdio>

namespace w1::common {

/**
 * @brief allocate and configure a windows console for gui applications
 *
 * this function:
 * - allocates a new console window
 * - redirects stdout/stderr to the console
 * - enables ansi escape code support for colors
 * - sets streams to unbuffered for immediate output
 *
 * @return true if console was successfully allocated and configured
 */
inline bool allocate_windows_console() {
  if (!AllocConsole()) {
    return false;
  }

  // redirect stdout and stderr to console
  FILE* pCout;
  FILE* pCerr;
  freopen_s(&pCout, "CONOUT$", "w", stdout);
  freopen_s(&pCerr, "CONOUT$", "w", stderr);

  // ensure streams are unbuffered for immediate output
  setvbuf(stdout, NULL, _IONBF, 0);
  setvbuf(stderr, NULL, _IONBF, 0);

  // enable ansi escape codes for color output
  HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
  HANDLE hErr = GetStdHandle(STD_ERROR_HANDLE);

  if (hOut != INVALID_HANDLE_VALUE) {
    DWORD dwMode = 0;
    if (GetConsoleMode(hOut, &dwMode)) {
      dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
      SetConsoleMode(hOut, dwMode);
    }
  }

  if (hErr != INVALID_HANDLE_VALUE) {
    DWORD dwMode = 0;
    if (GetConsoleMode(hErr, &dwMode)) {
      dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
      SetConsoleMode(hErr, dwMode);
    }
  }

  return true;
}

} // namespace w1::common

#endif // _WIN32 || WIN32
```

`src/w1debugger/CMakeLists.txt`:

```txt
# common source files
set(COMMON_SOURCES 
    w1debugger.cpp 
    error.cpp
)

# platform-specific sources
set(PLATFORM_SOURCES "")

if(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
    list(APPEND PLATFORM_SOURCES
        platform/darwin/darwin_session.cpp
        platform/darwin/entitlement_check.cpp
        platform/darwin/process_control.cpp
        platform/darwin/thread_context.cpp
        platform/darwin/memory_ops.cpp
    )
elseif(CMAKE_SYSTEM_NAME STREQUAL "Linux")
    list(APPEND PLATFORM_SOURCES
        platform/linux/linux_debugger.cpp
    )
elseif(CMAKE_SYSTEM_NAME STREQUAL "Windows")
    list(APPEND PLATFORM_SOURCES
        platform/windows/windows_debugger.cpp
    )
endif()

w1_add_static_library(w1debugger ${COMMON_SOURCES} ${PLATFORM_SOURCES})
add_library(w1::debugger ALIAS w1debugger)

# platform-specific libraries
if(APPLE)
    find_library(CORE_FOUNDATION CoreFoundation)
    find_library(SECURITY Security)
    target_link_libraries(w1debugger PRIVATE ${CORE_FOUNDATION} ${SECURITY})
elseif(WIN32)
    target_link_libraries(w1debugger PRIVATE psapi kernel32 advapi32)
elseif(UNIX)
    find_package(Threads REQUIRED)
    target_link_libraries(w1debugger PRIVATE Threads::Threads)
endif()

install(TARGETS w1debugger
    EXPORT w1debuggerTargets
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    RUNTIME DESTINATION bin
    COMPONENT ${W1_INSTALL_COMPONENT}
)

```

`src/w1debugger/error.cpp`:

```cpp
#include "error.hpp"

namespace w1::debugger {

std::string error_code_to_string(error_code code) {
  switch (code) {
  case error_code::success:
    return "success";
  case error_code::target_not_found:
    return "target not found";
  case error_code::target_access_denied:
    return "target access denied";
  case error_code::target_invalid_arch:
    return "target invalid architecture";
  case error_code::insufficient_privileges:
    return "insufficient privileges";
  case error_code::debugger_entitlement_missing:
    return "debugger entitlement missing";
  case error_code::ptrace_scope_restricted:
    return "ptrace scope restricted";
  case error_code::debug_privilege_missing:
    return "debug privilege missing";
  case error_code::operation_failed:
    return "operation failed";
  case error_code::not_implemented:
    return "not implemented";
  case error_code::invalid_state:
    return "invalid state";
  case error_code::timeout:
    return "timeout";
  case error_code::out_of_memory:
    return "out of memory";
  case error_code::system_error:
    return "system error";
  case error_code::unknown_error:
    return "unknown error";
  default:
    return "unknown error code";
  }
}

result make_error_result(error_code code, const std::string& context, int system_error) {
  result r;
  r.code = code;
  r.error_message = error_code_to_string(code);
  if (!context.empty()) {
    r.error_message += ": " + context;
  }
  if (system_error != 0) {
    r.system_error_code = system_error;
    r.error_message += " (system error: " + std::to_string(system_error) + ")";
  }
  return r;
}

result make_success_result() { return result{error_code::success, "", std::nullopt}; }

bool is_recoverable_error(error_code code) {
  switch (code) {
  case error_code::timeout:
  case error_code::target_not_found:
    return true;
  default:
    return false;
  }
}

} // namespace w1::debugger

```

`src/w1debugger/error.hpp`:

```hpp
#pragma once

#include <string>
#include <optional>

namespace w1::debugger {

// error codes matching w1nj3ct pattern
enum class error_code {
  success,

  // target errors
  target_not_found,
  target_access_denied,
  target_invalid_arch,

  // permission errors
  insufficient_privileges,
  debugger_entitlement_missing, // macos
  ptrace_scope_restricted,      // linux yama
  debug_privilege_missing,      // windows sedebugprivilege

  // operation errors
  operation_failed,
  not_implemented,
  invalid_state,
  timeout,

  // system errors
  out_of_memory,
  system_error,

  unknown_error
};

// result type
struct result {
  error_code code;
  std::string error_message;
  std::optional<int> system_error_code;

  bool success() const { return code == error_code::success; }
  operator bool() const { return success(); }
};

// error utilities
std::string error_code_to_string(error_code code);
result make_error_result(error_code code, const std::string& context = "", int system_error = 0);
result make_success_result();
bool is_recoverable_error(error_code code);

} // namespace w1::debugger

```

`src/w1debugger/platform/darwin/darwin_debugger.hpp`:

```hpp
#pragma once

#include "../../w1debugger.hpp"

namespace w1::debugger::darwin {

std::unique_ptr<session> session_attach(pid target_pid, const config& cfg, result& out_result);
std::unique_ptr<session> session_launch(const std::string& path, const config& cfg, result& out_result);

std::vector<process_info> list_processes();
bool check_debugger_capability();

} // namespace w1::debugger::darwin
```

`src/w1debugger/platform/darwin/darwin_internal.hpp`:

```hpp
#pragma once

#include "../../w1debugger.hpp"
#include "../../session_impl.hpp"

#include <mach/mach.h>
#include <mach/mach_vm.h>
#include <mach/thread_state.h>

namespace w1::debugger::darwin {

// debug session impl for darwin
class darwin_session : public session_impl {
private:
  mach_port_t task_port = MACH_PORT_NULL;
  pid target_pid;
  arch target_arch;
  mach_port_t exception_port = MACH_PORT_NULL;

public:
  darwin_session(pid pid, mach_port_t task);
  ~darwin_session() override;

  result detach() override;
  result kill() override;
  pid get_pid() const override;
  arch get_arch() const override;
  capabilities get_capabilities() const override;

  result get_threads(std::vector<tid>& out_threads) const override;
  result suspend_thread(tid thread_id) override;
  result resume_thread(tid thread_id) override;
  result continue_execution() override;
  result single_step(tid thread_id) override;

  result get_registers(tid thread_id, register_context& out_regs) const override;
  result set_registers(tid thread_id, const register_context& regs) override;

  result read_memory(addr address, size_t size, std::vector<uint8_t>& out_data) const override;
  result write_memory(addr address, const std::vector<uint8_t>& data) override;
  result get_memory_regions(std::vector<memory_region>& out_regions) const override;
  result allocate_memory(size_t size, memory_prot prot, addr& out_address) override;
  result protect_memory(addr address, size_t size, memory_prot prot) override;

  result wait_for_event(debug_event& out_event, std::optional<std::chrono::milliseconds> timeout) override;
  result set_breakpoint(addr address) override;
  result remove_breakpoint(addr address) override;
};

// entitlement checking
bool check_has_debugger_entitlement();

// process control operations
std::unique_ptr<session> session_attach(pid target_pid, const config& cfg, result& out_result);
std::unique_ptr<session> session_launch(const std::string& path, const config& cfg, result& out_result);
std::vector<process_info> list_processes();
bool check_debugger_capability();

// memory operations
result read_memory_impl(mach_port_t task_port, addr address, size_t size, std::vector<uint8_t>& out_data);
result write_memory_impl(mach_port_t task_port, addr address, const std::vector<uint8_t>& data);
result get_memory_regions_impl(mach_port_t task_port, std::vector<memory_region>& out_regions);
result allocate_memory_impl(mach_port_t task_port, size_t size, memory_prot prot, addr& out_address);
result protect_memory_impl(mach_port_t task_port, addr address, size_t size, memory_prot prot);

// thread context operations
result get_registers_impl(tid thread_id, register_context& out_regs);
result set_registers_impl(tid thread_id, const register_context& regs);
result single_step_impl(tid thread_id);
result suspend_thread_impl(tid thread_id);
result resume_thread_impl(tid thread_id);

} // namespace w1::debugger::darwin

```

`src/w1debugger/platform/darwin/darwin_session.cpp`:

```cpp
#include "darwin_internal.hpp"
#include <signal.h>

namespace w1::debugger::darwin {

darwin_session::darwin_session(pid pid, mach_port_t task) : target_pid(pid), task_port(task) {
  // detect architecture
#ifdef __arm64__
  target_arch = arch::arm64;
#elif __x86_64__
  target_arch = arch::x86_64;
#else
  target_arch = arch::x86;
#endif
}

darwin_session::~darwin_session() {
  if (exception_port != MACH_PORT_NULL) {
    mach_port_deallocate(mach_task_self(), exception_port);
  }
  if (task_port != MACH_PORT_NULL) {
    mach_port_deallocate(mach_task_self(), task_port);
  }
}

result darwin_session::detach() {
  // detach from process
  if (task_port != MACH_PORT_NULL) {
    kern_return_t kr = mach_port_deallocate(mach_task_self(), task_port);
    if (kr != KERN_SUCCESS) {
      return make_error_result(error_code::operation_failed, "failed to detach", kr);
    }
    task_port = MACH_PORT_NULL;
  }
  return make_success_result();
}

result darwin_session::kill() {
  // send sigkill to process
  if (::kill(target_pid.native, SIGKILL) != 0) {
    return make_error_result(error_code::operation_failed, "failed to kill process", errno);
  }
  return make_success_result();
}

pid darwin_session::get_pid() const { return target_pid; }

arch darwin_session::get_arch() const { return target_arch; }

capabilities darwin_session::get_capabilities() const {
  capabilities caps;
  caps.hardware_breakpoints = true;
  caps.watchpoints = true;
  caps.remote_allocation = true;
  caps.thread_suspension = true;
  caps.single_stepping = true;
  return caps;
}

result darwin_session::get_threads(std::vector<tid>& out_threads) const {
  thread_array_t thread_list;
  mach_msg_type_number_t thread_count;

  kern_return_t kr = task_threads(task_port, &thread_list, &thread_count);
  if (kr != KERN_SUCCESS) {
    return make_error_result(error_code::operation_failed, "failed to get threads", kr);
  }

  out_threads.clear();
  for (mach_msg_type_number_t i = 0; i < thread_count; i++) {
    out_threads.push_back(tid{static_cast<uint64_t>(thread_list[i])});
    mach_port_deallocate(mach_task_self(), thread_list[i]);
  }

  vm_deallocate(mach_task_self(), (vm_address_t) thread_list, thread_count * sizeof(thread_t));
  return make_success_result();
}

result darwin_session::suspend_thread(tid thread_id) { return suspend_thread_impl(thread_id); }

result darwin_session::resume_thread(tid thread_id) { return resume_thread_impl(thread_id); }

result darwin_session::continue_execution() {
  // resume the entire task (all threads)
  kern_return_t kr = task_resume(task_port);
  if (kr != KERN_SUCCESS) {
    return make_error_result(error_code::operation_failed, "failed to resume task", kr);
  }
  return make_success_result();
}

result darwin_session::single_step(tid thread_id) { return single_step_impl(thread_id); }

result darwin_session::get_registers(tid thread_id, register_context& out_regs) const {
  return get_registers_impl(thread_id, out_regs);
}

result darwin_session::set_registers(tid thread_id, const register_context& regs) {
  return set_registers_impl(thread_id, regs);
}

result darwin_session::read_memory(addr address, size_t size, std::vector<uint8_t>& out_data) const {
  return read_memory_impl(task_port, address, size, out_data);
}

result darwin_session::write_memory(addr address, const std::vector<uint8_t>& data) {
  return write_memory_impl(task_port, address, data);
}

result darwin_session::get_memory_regions(std::vector<memory_region>& out_regions) const {
  return get_memory_regions_impl(task_port, out_regions);
}

result darwin_session::allocate_memory(size_t size, memory_prot prot, addr& out_address) {
  return allocate_memory_impl(task_port, size, prot, out_address);
}

result darwin_session::protect_memory(addr address, size_t size, memory_prot prot) {
  return protect_memory_impl(task_port, address, size, prot);
}

result darwin_session::wait_for_event(debug_event& out_event, std::optional<std::chrono::milliseconds> timeout) {
  (void) out_event;
  (void) timeout;
  return make_error_result(error_code::not_implemented);
}

result darwin_session::set_breakpoint(addr address) {
  (void) address;
  return make_error_result(error_code::not_implemented);
}

result darwin_session::remove_breakpoint(addr address) {
  (void) address;
  return make_error_result(error_code::not_implemented);
}

} // namespace w1::debugger::darwin

```

`src/w1debugger/platform/darwin/entitlement_check.cpp`:

```cpp
#include "darwin_internal.hpp"
#include <Security/Security.h>
#include <CoreFoundation/CoreFoundation.h>

namespace w1::debugger::darwin {

bool check_has_debugger_entitlement() {
  // check if we're running with the debugger entitlement
  // we can check this by attempting to get our own code signing info
  SecCodeRef code = nullptr;
  OSStatus status = SecCodeCopySelf(kSecCSDefaultFlags, &code);
  if (status != errSecSuccess) {
    return false;
  }

  CFDictionaryRef info = nullptr;
  status = SecCodeCopySigningInformation(code, kSecCSSigningInformation, &info);
  CFRelease(code);

  if (status != errSecSuccess) {
    return false;
  }

  bool has_entitlement = false;
  if (info) {
    // check for entitlements dictionary
    CFDictionaryRef entitlements = (CFDictionaryRef) CFDictionaryGetValue(info, kSecCodeInfoEntitlementsDict);
    if (entitlements) {
      // look for com.apple.security.cs.debugger
      CFStringRef key = CFSTR("com.apple.security.cs.debugger");
      if (CFDictionaryContainsKey(entitlements, key)) {
        CFBooleanRef value = (CFBooleanRef) CFDictionaryGetValue(entitlements, key);
        has_entitlement = (value == kCFBooleanTrue);
      }
    }
    CFRelease(info);
  }

  return has_entitlement;
}

} // namespace w1::debugger::darwin

```

`src/w1debugger/platform/darwin/memory_ops.cpp`:

```cpp
#include "darwin_internal.hpp"

namespace w1::debugger::darwin {

result read_memory_impl(mach_port_t task_port, addr address, size_t size, std::vector<uint8_t>& out_data) {
  out_data.resize(size);
  mach_vm_size_t read_size = size;

  kern_return_t kr =
      mach_vm_read_overwrite(task_port, address.value, read_size, (mach_vm_address_t) out_data.data(), &read_size);

  if (kr != KERN_SUCCESS) {
    return make_error_result(error_code::operation_failed, "failed to read memory", kr);
  }

  out_data.resize(read_size);
  return make_success_result();
}

result write_memory_impl(mach_port_t task_port, addr address, const std::vector<uint8_t>& data) {
  kern_return_t kr = mach_vm_write(task_port, address.value, (vm_offset_t) data.data(), data.size());

  if (kr != KERN_SUCCESS) {
    return make_error_result(error_code::operation_failed, "failed to write memory", kr);
  }

  return make_success_result();
}

result get_memory_regions_impl(mach_port_t task_port, std::vector<memory_region>& out_regions) {
  (void) task_port;
  (void) out_regions;
  return make_error_result(error_code::not_implemented);
}

result allocate_memory_impl(mach_port_t task_port, size_t size, memory_prot prot, addr& out_address) {
  (void) task_port;
  (void) size;
  (void) prot;
  (void) out_address;
  return make_error_result(error_code::not_implemented);
}

result protect_memory_impl(mach_port_t task_port, addr address, size_t size, memory_prot prot) {
  (void) task_port;
  (void) address;
  (void) size;
  (void) prot;
  return make_error_result(error_code::not_implemented);
}

} // namespace w1::debugger::darwin

```

`src/w1debugger/platform/darwin/process_control.cpp`:

```cpp
#include "darwin_internal.hpp"
#include <spawn.h>
#include <signal.h>
#include <sys/sysctl.h>
#include <unistd.h>
#include <cstring>

extern char** environ;

#ifndef _POSIX_SPAWN_DISABLE_ASLR
#define _POSIX_SPAWN_DISABLE_ASLR 0x100
#endif

namespace w1::debugger::darwin {

std::unique_ptr<session> session_attach(pid target_pid, const config& cfg, result& out_result) {
  (void) cfg;

  // get task port for target process
  mach_port_t task;
  kern_return_t kr = task_for_pid(mach_task_self(), target_pid.native, &task);

  if (kr != KERN_SUCCESS) {
    // analyze the error more carefully
    if (kr == KERN_FAILURE) {
      // could be multiple reasons, try to figure out what went wrong

      // check if we have the debugger entitlement
      if (!check_has_debugger_entitlement()) {
        // we don't have the entitlement!
        out_result = make_error_result(
            error_code::debugger_entitlement_missing, "missing com.apple.security.cs.debugger entitlement", kr
        );
      } else {
        // generic failure
        out_result = make_error_result(error_code::target_access_denied, "task_for_pid failed", kr);
      }
    } else if (kr == KERN_INVALID_ARGUMENT) {
      out_result = make_error_result(error_code::target_not_found, "invalid pid", kr);
    } else {
      out_result = make_error_result(error_code::operation_failed, "task_for_pid failed", kr);
    }
    return nullptr;
  }

  // create darwin_session with task port - we'll need to forward declare this
  auto impl = std::make_unique<darwin_session>(target_pid, task);
  out_result = make_success_result();
  return session::create_from_impl(std::move(impl));
}

std::unique_ptr<session> session_launch(const std::string& path, const config& cfg, result& out_result) {
  posix_spawnattr_t attr;
  posix_spawn_file_actions_t file_actions;

  // initialize spawn attributes
  if (posix_spawnattr_init(&attr) != 0) {
    out_result = make_error_result(error_code::system_error, "failed to init spawn attributes", errno);
    return nullptr;
  }

  // initialize file actions
  if (posix_spawn_file_actions_init(&file_actions) != 0) {
    posix_spawnattr_destroy(&attr);
    out_result = make_error_result(error_code::system_error, "failed to init file actions", errno);
    return nullptr;
  }

  // set flags - start suspended if requested
  short flags = 0;
  if (cfg.start_suspended) {
    flags |= POSIX_SPAWN_START_SUSPENDED;
  }
  if (cfg.disable_aslr) {
    flags |= _POSIX_SPAWN_DISABLE_ASLR;
  }

  if (posix_spawnattr_setflags(&attr, flags) != 0) {
    posix_spawn_file_actions_destroy(&file_actions);
    posix_spawnattr_destroy(&attr);
    out_result = make_error_result(error_code::system_error, "failed to set spawn flags", errno);
    return nullptr;
  }

  // prepare arguments
  std::vector<char*> argv;
  argv.push_back(const_cast<char*>(path.c_str()));
  for (const auto& arg : cfg.args) {
    argv.push_back(const_cast<char*>(arg.c_str()));
  }
  argv.push_back(nullptr);

  // prepare environment - use current if not specified
  std::vector<char*> envp;
  if (!cfg.env_vars.empty()) {
    for (const auto& [key, value] : cfg.env_vars) {
      std::string env_str = key + "=" + value;
      char* env_copy = strdup(env_str.c_str());
      envp.push_back(env_copy);
    }
    envp.push_back(nullptr);
  }

  // spawn the process
  pid_t child_pid;
  int spawn_result = posix_spawn(
      &child_pid, path.c_str(), &file_actions, &attr, argv.data(), cfg.env_vars.empty() ? environ : envp.data()
  );

  // cleanup environment strings if we allocated them
  for (char* env_str : envp) {
    if (env_str) {
      free(env_str);
    }
  }

  // cleanup spawn attributes
  posix_spawn_file_actions_destroy(&file_actions);
  posix_spawnattr_destroy(&attr);

  if (spawn_result != 0) {
    out_result = make_error_result(error_code::operation_failed, "failed to spawn process", spawn_result);
    return nullptr;
  }

  // now attach to the spawned process
  return session_attach(pid{child_pid}, cfg, out_result);
}

std::vector<process_info> list_processes() {
  std::vector<process_info> procs;

  // use sysctl to get process list
  int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0};
  size_t size;

  if (sysctl(mib, 4, nullptr, &size, nullptr, 0) < 0) {
    return procs;
  }

  std::vector<uint8_t> buffer(size);
  if (sysctl(mib, 4, buffer.data(), &size, nullptr, 0) < 0) {
    return procs;
  }

  // parse the results
  struct kinfo_proc* proc_list = (struct kinfo_proc*) buffer.data();
  size_t proc_count = size / sizeof(struct kinfo_proc);

  for (size_t i = 0; i < proc_count; i++) {
    process_info info;
    info.process_id = pid{proc_list[i].kp_proc.p_pid};
    info.name = proc_list[i].kp_proc.p_comm;
    // full path would require proc_pidpath
    procs.push_back(info);
  }

  return procs;
}

bool check_debugger_capability() {
  // check if we have the necessary entitlements
  return check_has_debugger_entitlement();
}

} // namespace w1::debugger::darwin

```

`src/w1debugger/platform/darwin/thread_context.cpp`:

```cpp
#include "darwin_internal.hpp"
#include <mach/arm/thread_state.h>
#include <mach/arm/thread_status.h>
#include <mach/i386/thread_state.h>

namespace w1::debugger::darwin {

result get_registers_impl(tid thread_id, register_context& out_regs) {
#ifdef __arm64__
  // arm64 implementation
  arm_thread_state64_t state;
  mach_msg_type_number_t state_count = ARM_THREAD_STATE64_COUNT;

  kern_return_t kr = thread_get_state(
      static_cast<thread_t>(thread_id.native), ARM_THREAD_STATE64, (thread_state_t) &state, &state_count
  );

  if (kr != KERN_SUCCESS) {
    return make_error_result(error_code::operation_failed, "failed to get thread state", kr);
  }

  // map to our arm64_regs structure
  arm64_regs regs;
  for (int i = 0; i < 29; i++) {
    regs.x[i] = state.__x[i];
  }
  regs.x[29] = state.__fp; // frame pointer
  regs.x[30] = state.__lr; // link register
  regs.sp = state.__sp;
  regs.pc = state.__pc;
  regs.pstate = state.__cpsr;

  out_regs = regs;
  return make_success_result();
#elif __x86_64__
  // x86_64 implementation
  x86_thread_state64_t state;
  mach_msg_type_number_t state_count = x86_THREAD_STATE64_COUNT;

  kern_return_t kr = thread_get_state(
      static_cast<thread_t>(thread_id.native), x86_THREAD_STATE64, (thread_state_t) &state, &state_count
  );

  if (kr != KERN_SUCCESS) {
    return make_error_result(error_code::operation_failed, "failed to get thread state", kr);
  }

  // map to our x64_regs structure
  x64_regs regs;
  regs.rax = state.__rax;
  regs.rbx = state.__rbx;
  regs.rcx = state.__rcx;
  regs.rdx = state.__rdx;
  regs.rsi = state.__rsi;
  regs.rdi = state.__rdi;
  regs.rbp = state.__rbp;
  regs.rsp = state.__rsp;
  regs.r8 = state.__r8;
  regs.r9 = state.__r9;
  regs.r10 = state.__r10;
  regs.r11 = state.__r11;
  regs.r12 = state.__r12;
  regs.r13 = state.__r13;
  regs.r14 = state.__r14;
  regs.r15 = state.__r15;
  regs.rip = state.__rip;
  regs.rflags = state.__rflags;

  out_regs = regs;
  return make_success_result();
#else
  return make_error_result(error_code::not_implemented, "unsupported architecture");
#endif
}

result set_registers_impl(tid thread_id, const register_context& regs) {
#ifdef __arm64__
  // arm64 implementation
  if (!std::holds_alternative<arm64_regs>(regs)) {
    return make_error_result(error_code::invalid_state, "wrong register type for architecture");
  }

  const auto& arm_regs = std::get<arm64_regs>(regs);
  arm_thread_state64_t state;

  // populate state from our structure
  for (int i = 0; i < 29; i++) {
    state.__x[i] = arm_regs.x[i];
  }
  state.__fp = arm_regs.x[29]; // frame pointer
  state.__lr = arm_regs.x[30]; // link register
  state.__sp = arm_regs.sp;
  state.__pc = arm_regs.pc;
  state.__cpsr = arm_regs.pstate;

  kern_return_t kr = thread_set_state(
      static_cast<thread_t>(thread_id.native), ARM_THREAD_STATE64, (thread_state_t) &state, ARM_THREAD_STATE64_COUNT
  );

  if (kr != KERN_SUCCESS) {
    return make_error_result(error_code::operation_failed, "failed to set thread state", kr);
  }

  return make_success_result();
#elif __x86_64__
  // x86_64 implementation
  if (!std::holds_alternative<x64_regs>(regs)) {
    return make_error_result(error_code::invalid_state, "wrong register type for architecture");
  }

  const auto& x64_regs_val = std::get<x64_regs>(regs);
  x86_thread_state64_t state;

  // populate state from our structure
  state.__rax = x64_regs_val.rax;
  state.__rbx = x64_regs_val.rbx;
  state.__rcx = x64_regs_val.rcx;
  state.__rdx = x64_regs_val.rdx;
  state.__rsi = x64_regs_val.rsi;
  state.__rdi = x64_regs_val.rdi;
  state.__rbp = x64_regs_val.rbp;
  state.__rsp = x64_regs_val.rsp;
  state.__r8 = x64_regs_val.r8;
  state.__r9 = x64_regs_val.r9;
  state.__r10 = x64_regs_val.r10;
  state.__r11 = x64_regs_val.r11;
  state.__r12 = x64_regs_val.r12;
  state.__r13 = x64_regs_val.r13;
  state.__r14 = x64_regs_val.r14;
  state.__r15 = x64_regs_val.r15;
  state.__rip = x64_regs_val.rip;
  state.__rflags = x64_regs_val.rflags;

  kern_return_t kr = thread_set_state(
      static_cast<thread_t>(thread_id.native), x86_THREAD_STATE64, (thread_state_t) &state, x86_THREAD_STATE64_COUNT
  );

  if (kr != KERN_SUCCESS) {
    return make_error_result(error_code::operation_failed, "failed to set thread state", kr);
  }

  return make_success_result();
#else
  return make_error_result(error_code::not_implemented, "unsupported architecture");
#endif
}

result single_step_impl(tid thread_id) {
#ifdef __arm64__
  // arm64: use debug state to enable single stepping
  arm_debug_state64_t debug_state;
  mach_msg_type_number_t debug_state_count = ARM_DEBUG_STATE64_COUNT;

  // get current debug state
  kern_return_t kr = thread_get_state(
      static_cast<thread_t>(thread_id.native), ARM_DEBUG_STATE64, (thread_state_t) &debug_state, &debug_state_count
  );

  if (kr != KERN_SUCCESS) {
    return make_error_result(error_code::operation_failed, "failed to get debug state", kr);
  }

  // enable single step in mdscr_el1
  debug_state.__mdscr_el1 |= 1; // set SS bit (bit 0)

  // set the modified state
  kr = thread_set_state(
      static_cast<thread_t>(thread_id.native), ARM_DEBUG_STATE64, (thread_state_t) &debug_state, ARM_DEBUG_STATE64_COUNT
  );

  if (kr != KERN_SUCCESS) {
    return make_error_result(error_code::operation_failed, "failed to set debug state", kr);
  }

  // resume the thread to execute one instruction
  kr = thread_resume(static_cast<thread_t>(thread_id.native));
  if (kr != KERN_SUCCESS) {
    return make_error_result(error_code::operation_failed, "failed to resume thread for single step", kr);
  }

  return make_success_result();
#else
  // x86_64: use rflags trap flag
  x86_thread_state64_t state;
  mach_msg_type_number_t state_count = x86_THREAD_STATE64_COUNT;

  kern_return_t kr = thread_get_state(
      static_cast<thread_t>(thread_id.native), x86_THREAD_STATE64, (thread_state_t) &state, &state_count
  );

  if (kr != KERN_SUCCESS) {
    return make_error_result(error_code::operation_failed, "failed to get thread state", kr);
  }

  // set trap flag (bit 8) in rflags
  state.__rflags |= 0x100;

  kr = thread_set_state(
      static_cast<thread_t>(thread_id.native), x86_THREAD_STATE64, (thread_state_t) &state, x86_THREAD_STATE64_COUNT
  );

  if (kr != KERN_SUCCESS) {
    return make_error_result(error_code::operation_failed, "failed to set thread state", kr);
  }

  // resume the thread
  kr = thread_resume(static_cast<thread_t>(thread_id.native));
  if (kr != KERN_SUCCESS) {
    return make_error_result(error_code::operation_failed, "failed to resume thread for single step", kr);
  }

  return make_success_result();
#endif
}

result suspend_thread_impl(tid thread_id) {
  kern_return_t kr = thread_suspend(static_cast<thread_t>(thread_id.native));
  if (kr != KERN_SUCCESS) {
    return make_error_result(error_code::operation_failed, "failed to suspend thread", kr);
  }
  return make_success_result();
}

result resume_thread_impl(tid thread_id) {
  kern_return_t kr = thread_resume(static_cast<thread_t>(thread_id.native));
  if (kr != KERN_SUCCESS) {
    return make_error_result(error_code::operation_failed, "failed to resume thread", kr);
  }
  return make_success_result();
}

} // namespace w1::debugger::darwin

```

`src/w1debugger/platform/linux/linux_debugger.cpp`:

```cpp
#include "linux_debugger.hpp"
#include "../../error.hpp"

namespace w1::debugger::linux_os {

std::unique_ptr<session> session_attach(pid target_pid, const config& cfg, result& out_result) {
  out_result = make_error_result(error_code::not_implemented, "linux debugger not yet implemented");
  return nullptr;
}

std::unique_ptr<session> session_launch(const std::string& path, const config& cfg, result& out_result) {
  out_result = make_error_result(error_code::not_implemented, "linux debugger not yet implemented");
  return nullptr;
}

std::vector<process_info> list_processes() { return {}; }

bool check_debugger_capability() { return false; }

} // namespace w1::debugger::linux_os
```

`src/w1debugger/platform/linux/linux_debugger.hpp`:

```hpp
#pragma once

#include "../../w1debugger.hpp"

namespace w1::debugger::linux_os {

std::unique_ptr<session> session_attach(pid target_pid, const config& cfg, result& out_result);
std::unique_ptr<session> session_launch(const std::string& path, const config& cfg, result& out_result);

std::vector<process_info> list_processes();
bool check_debugger_capability();

} // namespace w1::debugger::linux_os
```

`src/w1debugger/platform/windows/windows_debugger.cpp`:

```cpp
#include "windows_debugger.hpp"
#include "../../error.hpp"

namespace w1::debugger::windows {

std::unique_ptr<session> session_attach(pid target_pid, const config& cfg, result& out_result) {
  out_result = make_error_result(error_code::not_implemented, "windows debugger not yet implemented");
  return nullptr;
}

std::unique_ptr<session> session_launch(const std::string& path, const config& cfg, result& out_result) {
  out_result = make_error_result(error_code::not_implemented, "windows debugger not yet implemented");
  return nullptr;
}

std::vector<process_info> list_processes() { return {}; }

bool check_debugger_capability() { return false; }

} // namespace w1::debugger::windows
```

`src/w1debugger/platform/windows/windows_debugger.hpp`:

```hpp
#pragma once

#include "../../w1debugger.hpp"

namespace w1::debugger::windows {

std::unique_ptr<session> session_attach(pid target_pid, const config& cfg, result& out_result);
std::unique_ptr<session> session_launch(const std::string& path, const config& cfg, result& out_result);

std::vector<process_info> list_processes();
bool check_debugger_capability();

} // namespace w1::debugger::windows
```

`src/w1debugger/session_impl.hpp`:

```hpp
#pragma once

#include "types.hpp"
#include "error.hpp"

namespace w1::debugger {

// platform-specific session implementation base
class session_impl {
public:
  virtual ~session_impl() = default;

  virtual result detach() = 0;
  virtual result kill() = 0;
  virtual result continue_execution() = 0;
  virtual pid get_pid() const = 0;
  virtual arch get_arch() const = 0;
  virtual capabilities get_capabilities() const = 0;
  virtual result get_threads(std::vector<tid>& out_threads) const = 0;
  virtual result suspend_thread(tid thread_id) = 0;
  virtual result resume_thread(tid thread_id) = 0;
  virtual result single_step(tid thread_id) = 0;
  virtual result get_registers(tid thread_id, register_context& out_regs) const = 0;
  virtual result set_registers(tid thread_id, const register_context& regs) = 0;
  virtual result read_memory(addr address, size_t size, std::vector<uint8_t>& out_data) const = 0;
  virtual result write_memory(addr address, const std::vector<uint8_t>& data) = 0;
  virtual result get_memory_regions(std::vector<memory_region>& out_regions) const = 0;
  virtual result allocate_memory(size_t size, memory_prot prot, addr& out_address) = 0;
  virtual result protect_memory(addr address, size_t size, memory_prot prot) = 0;
  virtual result wait_for_event(debug_event& out_event, std::optional<std::chrono::milliseconds> timeout) = 0;
  virtual result set_breakpoint(addr address) = 0;
  virtual result remove_breakpoint(addr address) = 0;
};

} // namespace w1::debugger

```

`src/w1debugger/types.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>
#include <variant>
#include <vector>
#include <optional>
#include <chrono>
#include <map>

namespace w1::debugger {

// architecture enumeration
enum class arch { x86, x86_64, arm64 };

// memory protection flags (can be OR'd together)
enum class memory_prot : uint32_t { none = 0, read = 1, write = 2, exec = 4 };

// process id wrapper
struct pid {
  int native;
  bool operator==(const pid& other) const { return native == other.native; }
};

// thread id wrapper
struct tid {
  uint64_t native;
  bool operator==(const tid& other) const { return native == other.native; }
};

// address wrapper
struct addr {
  uint64_t value;
  bool operator==(const addr& other) const { return value == other.value; }
};

// memory region information
struct memory_region {
  addr start;
  uint64_t size;
  memory_prot prot;
  std::string module_path; // empty if not file-backed
};

// x86 32-bit registers
struct x86_regs {
  uint32_t eax, ebx, ecx, edx;
  uint32_t esi, edi, ebp, esp;
  uint32_t eip;
  uint32_t eflags;
  // other regs?
};

// x86_64 registers
struct x64_regs {
  uint64_t rax, rbx, rcx, rdx;
  uint64_t rsi, rdi, rbp, rsp;
  uint64_t r8, r9, r10, r11;
  uint64_t r12, r13, r14, r15;
  uint64_t rip;
  uint64_t rflags;
  // other regs?
};

// arm64 registers
struct arm64_regs {
  uint64_t x[31];  // x0-x30
  uint64_t sp;     // stack pointer
  uint64_t pc;     // program counter
  uint64_t pstate; // processor state
                   // other regs?
};

// unified register context
using register_context = std::variant<x86_regs, x64_regs, arm64_regs>;

// event types
enum class event_type {
  breakpoint_hit,
  single_step,
  access_violation,
  thread_create,
  thread_exit,
  process_exit,
  library_load,
  library_unload,
  exception
};

// debug event
struct debug_event {
  event_type type;
  tid thread_id;
  addr address;     // fault/breakpoint address
  uint64_t code;    // os-specific code
  std::string info; // additional context
};

// process information for discovery
struct process_info {
  pid process_id;
  std::string name;
  std::string full_path;
  std::string command_line;
};

// capabilities query
struct capabilities {
  bool hardware_breakpoints = false;
  bool watchpoints = false;
  bool remote_allocation = false;
  bool thread_suspension = false;
  bool single_stepping = false;
};

// configuration
struct config {
  // target specification
  std::optional<pid> target_pid;
  std::optional<std::string> executable_path;
  std::vector<std::string> args;
  std::map<std::string, std::string> env_vars;

  // launch options
  bool start_suspended = true;
  bool disable_aslr = false;

  // behavior
  std::chrono::milliseconds timeout{5000};
  bool verbose = false;
};

} // namespace w1::debugger

```

`src/w1debugger/w1debugger.cpp`:

```cpp
#include "w1debugger.hpp"
#include "session_impl.hpp"

#ifdef __APPLE__
#include "platform/darwin/darwin_debugger.hpp"
#elif __linux__
#include "platform/linux/linux_debugger.hpp"
#elif _WIN32
#include "platform/windows/windows_debugger.hpp"
#endif

namespace w1::debugger {

session::session(std::unique_ptr<session_impl> impl) : pimpl(std::move(impl)) {}

session::~session() = default;

std::unique_ptr<session> session::create_from_impl(std::unique_ptr<session_impl> impl) {
  return std::unique_ptr<session>(new session(std::move(impl)));
}

std::unique_ptr<session> session::attach(pid target_pid, const config& cfg, result& out_result) {
#ifdef __APPLE__
  return darwin::session_attach(target_pid, cfg, out_result);
#elif __linux__
  return linux_os::session_attach(target_pid, cfg, out_result);
#elif _WIN32
  return windows::session_attach(target_pid, cfg, out_result);
#else
  out_result = make_error_result(error_code::not_implemented, "platform not supported");
  return nullptr;
#endif
}

std::unique_ptr<session> session::launch(const std::string& path, const config& cfg, result& out_result) {
#ifdef __APPLE__
  return darwin::session_launch(path, cfg, out_result);
#elif __linux__
  return linux_os::session_launch(path, cfg, out_result);
#elif _WIN32
  return windows::session_launch(path, cfg, out_result);
#else
  out_result = make_error_result(error_code::not_implemented, "platform not supported");
  return nullptr;
#endif
}

// delegate all methods to pimpl
result session::detach() { return pimpl->detach(); }
result session::kill() { return pimpl->kill(); }
result session::continue_execution() { return pimpl->continue_execution(); }
pid session::get_pid() const { return pimpl->get_pid(); }
arch session::get_arch() const { return pimpl->get_arch(); }
capabilities session::get_capabilities() const { return pimpl->get_capabilities(); }

result session::get_threads(std::vector<tid>& out_threads) const { return pimpl->get_threads(out_threads); }

result session::suspend_thread(tid thread_id) { return pimpl->suspend_thread(thread_id); }

result session::resume_thread(tid thread_id) { return pimpl->resume_thread(thread_id); }

result session::single_step(tid thread_id) { return pimpl->single_step(thread_id); }

result session::get_registers(tid thread_id, register_context& out_regs) const {
  return pimpl->get_registers(thread_id, out_regs);
}

result session::set_registers(tid thread_id, const register_context& regs) {
  return pimpl->set_registers(thread_id, regs);
}

result session::read_memory(addr address, size_t size, std::vector<uint8_t>& out_data) const {
  return pimpl->read_memory(address, size, out_data);
}

result session::write_memory(addr address, const std::vector<uint8_t>& data) {
  return pimpl->write_memory(address, data);
}

result session::get_memory_regions(std::vector<memory_region>& out_regions) const {
  return pimpl->get_memory_regions(out_regions);
}

result session::allocate_memory(size_t size, memory_prot prot, addr& out_address) {
  return pimpl->allocate_memory(size, prot, out_address);
}

result session::protect_memory(addr address, size_t size, memory_prot prot) {
  return pimpl->protect_memory(address, size, prot);
}

result session::wait_for_event(debug_event& out_event, std::optional<std::chrono::milliseconds> timeout) {
  return pimpl->wait_for_event(out_event, timeout);
}

result session::set_breakpoint(addr address) { return pimpl->set_breakpoint(address); }

result session::remove_breakpoint(addr address) { return pimpl->remove_breakpoint(address); }

// utility functions
std::vector<process_info> list_processes() {
#ifdef __APPLE__
  return darwin::list_processes();
#elif __linux__
  return linux_os::list_processes();
#elif _WIN32
  return windows::list_processes();
#else
  return {};
#endif
}

bool check_debugger_capability() {
#ifdef __APPLE__
  return darwin::check_debugger_capability();
#elif __linux__
  return linux_os::check_debugger_capability();
#elif _WIN32
  return windows::check_debugger_capability();
#else
  return false;
#endif
}

} // namespace w1::debugger
```

`src/w1debugger/w1debugger.hpp`:

```hpp
#pragma once

#include "types.hpp"
#include "error.hpp"

#include <memory>

namespace w1::debugger {

// forward decl
class session_impl;

// main debugger session class
class session {
public:
  static std::unique_ptr<session> attach(pid target_pid, const config& cfg, result& out_result);
  static std::unique_ptr<session> launch(const std::string& path, const config& cfg, result& out_result);

  ~session();

  // control
  result detach();
  result kill();
  result continue_execution();

  // process info
  pid get_pid() const;
  arch get_arch() const;
  capabilities get_capabilities() const;

  // thread management
  result get_threads(std::vector<tid>& out_threads) const;
  result suspend_thread(tid thread_id);
  result resume_thread(tid thread_id);
  result single_step(tid thread_id);

  // register access
  result get_registers(tid thread_id, register_context& out_regs) const;
  result set_registers(tid thread_id, const register_context& regs);

  // memory operations
  result read_memory(addr address, size_t size, std::vector<uint8_t>& out_data) const;
  result write_memory(addr address, const std::vector<uint8_t>& data);
  result get_memory_regions(std::vector<memory_region>& out_regions) const;
  result allocate_memory(size_t size, memory_prot prot, addr& out_address);
  result protect_memory(addr address, size_t size, memory_prot prot);

  // event handling
  result wait_for_event(debug_event& out_event, std::optional<std::chrono::milliseconds> timeout = {});

  // breakpoints
  result set_breakpoint(addr address);
  result remove_breakpoint(addr address);

  static std::unique_ptr<session> create_from_impl(std::unique_ptr<session_impl> impl);

private:
  session(std::unique_ptr<session_impl> impl);
  std::unique_ptr<session_impl> pimpl;
};

// utility functions
std::vector<process_info> list_processes();
bool check_debugger_capability();

} // namespace w1::debugger

```

`src/w1dump/CMakeLists.txt`:

```txt
w1_dep_redlog()

w1_add_static_library(w1dump
    memory_dumper.cpp
    process_dumper.cpp
    register_dumper.cpp
)
add_library(w1::dump ALIAS w1dump)

target_link_libraries(w1dump PUBLIC w1formats w1runtime redlog::redlog)

```

`src/w1dump/memory_dumper.cpp`:

```cpp
#include "w1dump/memory_dumper.hpp"

#include <algorithm>

#include "w1runtime/module_catalog.hpp"

namespace w1::dump {

redlog::logger memory_dumper::log_ = redlog::get_logger("w1.dump.memory");

std::vector<memory_region> memory_dumper::dump_memory_regions(
    QBDI::VMInstanceRef vm, const util::memory_reader& memory, const QBDI::GPRState& gpr, const dump_options& options
) {
  log_.vrb("dumping memory regions");
  (void) vm;

  auto maps = QBDI::getCurrentProcessMaps(false);
  log_.dbg("retrieved memory maps", redlog::field("count", maps.size()));

  std::vector<memory_region> regions;
  regions.reserve(maps.size());

  uint64_t stack_pointer = QBDI_GPR_GET(&gpr, QBDI::REG_SP);

  for (const auto& map : maps) {
    memory_region region;
    region.start = map.range.start();
    region.end = map.range.end();
    region.permissions = static_cast<uint32_t>(map.permission);

    classify_region(region, map, stack_pointer);

    if (!should_include_region(region, options)) {
      continue;
    }

    uint64_t size = region.end > region.start ? region.end - region.start : 0;
    if (options.dump_memory_content) {
      bool should_dump_content = true;
      if (size > options.max_region_size && !region.is_stack) {
        should_dump_content = false;
      }

      if (should_dump_content && size > 0) {
        region.data = read_memory_region(memory, region.start, size);
      }
    }

    regions.push_back(std::move(region));
  }

  log_.inf("dumped memory regions", redlog::field("included", regions.size()), redlog::field("total", maps.size()));

  return regions;
}

std::vector<module_info> memory_dumper::dump_modules() {
  log_.vrb("dumping module information");

  runtime::module_catalog registry;
  registry.refresh();
  auto runtime_modules = registry.list_modules();

  std::vector<module_info> modules;
  modules.reserve(runtime_modules.size());

  for (const auto& module : runtime_modules) {
    if (module.size == 0) {
      continue;
    }
    if (module.name.rfind("_unnamed_", 0) == 0) {
      continue;
    }

    module_info info;
    info.path = module.path.empty() ? module.name : module.path;
    info.name = module.name.empty() ? info.path : module.name;
    info.base_address = module.base_address;
    info.size = module.size;
    info.type = "unknown";
    info.is_system = module.is_system;
    info.permissions = module.permissions;

    modules.push_back(std::move(info));
  }

  std::sort(modules.begin(), modules.end(), [](const module_info& left, const module_info& right) {
    return left.base_address < right.base_address;
  });

  log_.inf("dumped modules", redlog::field("total", modules.size()));

  return modules;
}

void memory_dumper::classify_region(memory_region& region, const QBDI::MemoryMap& map, uint64_t stack_pointer) {
  region.module_name = map.name.empty() ? "" : extract_basename(map.name);
  region.is_anonymous = region.module_name.empty();

  if (stack_pointer >= region.start && stack_pointer < region.end) {
    region.is_stack = true;
  }

  if (map.permission & QBDI::PF_EXEC) {
    region.is_code = true;
  } else {
    region.is_data = true;
  }
}

bool memory_dumper::should_include_region(const memory_region& region, const dump_options& options) {
  if (!options.dump_memory_content) {
    return true;
  }

  if (region.is_stack) {
    return true;
  }

  if (options.filters.empty()) {
    return true;
  }

  for (const auto& filter : options.filters) {
    bool type_matches = false;
    switch (filter.type) {
    case dump_options::filter::region_type::all:
      type_matches = true;
      break;
    case dump_options::filter::region_type::code:
      type_matches = region.is_code;
      break;
    case dump_options::filter::region_type::data:
      type_matches = region.is_data;
      break;
    case dump_options::filter::region_type::stack:
      type_matches = region.is_stack;
      break;
    }

    if (!type_matches) {
      continue;
    }

    if (filter.modules.empty()) {
      return true;
    }

    for (const auto& mod : filter.modules) {
      if (mod == "_anon") {
        if (region.module_name.empty()) {
          return true;
        }
      } else {
        if (!region.module_name.empty() && region.module_name.find(mod) != std::string::npos) {
          return true;
        }
      }
    }
  }

  return false;
}

std::vector<uint8_t> memory_dumper::read_memory_region(
    const util::memory_reader& memory, uint64_t start, uint64_t size
) {
  if (size == 0) {
    return {};
  }

  auto bytes = memory.read_bytes(start, static_cast<size_t>(size));
  if (!bytes) {
    log_.err("failed to read memory region", redlog::field("start", "0x%llx", start));
    return {};
  }

  return *bytes;
}

std::string memory_dumper::extract_basename(const std::string& path) {
  if (path.empty()) {
    return path;
  }

  size_t pos = path.find_last_of("/\\");
  if (pos != std::string::npos) {
    return path.substr(pos + 1);
  }

  return path;
}

} // namespace w1::dump

```

`src/w1dump/memory_dumper.hpp`:

```hpp
#pragma once

#include "w1formats/dump_format.hpp"
#include "w1runtime/memory_reader.hpp"

#include <QBDI.h>
#include <redlog.hpp>

#include <string>
#include <unordered_set>
#include <vector>

namespace w1::dump {

struct dump_options {
  bool dump_memory_content = false;

  struct filter {
    enum class region_type { all, code, data, stack };
    region_type type = region_type::all;
    std::unordered_set<std::string> modules;
  };

  std::vector<filter> filters;
  uint64_t max_region_size = 100 * 1024 * 1024;
};

class memory_dumper {
public:
  static std::vector<memory_region> dump_memory_regions(
      QBDI::VMInstanceRef vm, const util::memory_reader& memory, const QBDI::GPRState& gpr,
      const dump_options& options = {}
  );

  static std::vector<module_info> dump_modules();

private:
  static redlog::logger log_;

  static void classify_region(memory_region& region, const QBDI::MemoryMap& map, uint64_t stack_pointer);
  static bool should_include_region(const memory_region& region, const dump_options& options);
  static std::vector<uint8_t> read_memory_region(const util::memory_reader& memory, uint64_t start, uint64_t size);
  static std::string extract_basename(const std::string& path);
};

} // namespace w1::dump

```

`src/w1dump/process_dumper.cpp`:

```cpp
#include "w1dump/process_dumper.hpp"

#include "w1dump/register_dumper.hpp"

#include <chrono>
#include <fstream>
#include <vector>

#ifdef __APPLE__
#include <mach-o/dyld.h>
#endif

#ifdef _WIN32
#include <w1base/windows_clean.hpp>
#include <process.h>
#else
#include <unistd.h>
#endif

namespace w1::dump {

redlog::logger process_dumper::log_ = redlog::get_logger("w1.dump.process");

process_dump process_dumper::dump_current(
    QBDI::VMInstanceRef vm, const util::memory_reader& memory, uint64_t thread_id, const QBDI::GPRState& gpr,
    const QBDI::FPRState& fpr, const dump_options& options
) {
  log_.inf("starting process dump");

  process_dump dump;

  auto now = std::chrono::system_clock::now();
  auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch());

  dump.metadata.version = 1;
  dump.metadata.timestamp = duration.count();
  dump.metadata.os = get_os_name();
  dump.metadata.arch = get_arch_name();
  dump.metadata.pointer_size = get_pointer_size();
  dump.metadata.pid = get_pid();
  dump.metadata.process_name = get_process_name();

  dump.thread = register_dumper::capture_thread_state(gpr, fpr, thread_id);
  dump.modules = memory_dumper::dump_modules();
  dump.regions = memory_dumper::dump_memory_regions(vm, memory, gpr, options);

  log_.inf(
      "process dump completed", redlog::field("modules", dump.modules.size()),
      redlog::field("regions", dump.regions.size())
  );

  return dump;
}

void process_dumper::save_dump(const process_dump& dump, const std::string& path) {
  log_.inf("saving dump to file", redlog::field("path", path));

  try {
    nlohmann::json json = dump;
    auto msgpack = nlohmann::json::to_msgpack(json);

    std::ofstream file(path, std::ios::binary);
    if (!file) {
      log_.err("failed to open file for writing", redlog::field("path", path));
      throw std::runtime_error("failed to open dump file");
    }

    file.write(reinterpret_cast<const char*>(msgpack.data()), static_cast<std::streamsize>(msgpack.size()));
    file.close();

    log_.inf("dump saved", redlog::field("path", path), redlog::field("size", msgpack.size()));
  } catch (const std::exception& e) {
    log_.err("failed to save dump", redlog::field("path", path), redlog::field("error", e.what()));
    throw;
  }
}

process_dump process_dumper::load_dump(const std::string& path) {
  log_.inf("loading dump from file", redlog::field("path", path));

  try {
    std::ifstream file(path, std::ios::binary);
    if (!file) {
      log_.err("failed to open file for reading", redlog::field("path", path));
      throw std::runtime_error("failed to open dump file");
    }

    std::vector<uint8_t> msgpack((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
    file.close();

    auto json = nlohmann::json::from_msgpack(msgpack);
    process_dump dump = json.get<process_dump>();

    log_.inf(
        "dump loaded", redlog::field("path", path), redlog::field("version", dump.metadata.version),
        redlog::field("modules", dump.modules.size()), redlog::field("regions", dump.regions.size())
    );

    return dump;
  } catch (const std::exception& e) {
    log_.err("failed to load dump", redlog::field("path", path), redlog::field("error", e.what()));
    throw;
  }
}

std::string process_dumper::get_os_name() {
#if defined(_WIN32) || defined(_WIN64)
  return "windows";
#elif defined(__linux__)
  return "linux";
#elif defined(__APPLE__)
  return "darwin";
#else
  return "unknown";
#endif
}

std::string process_dumper::get_arch_name() {
#if defined(__x86_64__) || defined(_M_X64)
  return "x86_64";
#elif defined(__i386__) || defined(_M_IX86)
  return "x86";
#elif defined(__aarch64__) || defined(_M_ARM64)
  return "arm64";
#elif defined(__arm__) || defined(_M_ARM)
  return "arm";
#else
  return "unknown";
#endif
}

uint32_t process_dumper::get_pointer_size() { return static_cast<uint32_t>(sizeof(void*)); }

uint64_t process_dumper::get_pid() {
#ifdef _WIN32
  return static_cast<uint64_t>(_getpid());
#else
  return static_cast<uint64_t>(getpid());
#endif
}

std::string process_dumper::get_process_name() {
  char process_name[512] = {0};

#ifdef __APPLE__
  uint32_t size = sizeof(process_name);
  if (_NSGetExecutablePath(process_name, &size) == 0) {
    std::string full_path(process_name);
    size_t pos = full_path.find_last_of("/");
    if (pos != std::string::npos) {
      return full_path.substr(pos + 1);
    }
    return full_path;
  }
#elif defined(__linux__)
  if (readlink("/proc/self/exe", process_name, sizeof(process_name) - 1) > 0) {
    std::string full_path(process_name);
    size_t pos = full_path.find_last_of("/");
    if (pos != std::string::npos) {
      return full_path.substr(pos + 1);
    }
    return full_path;
  }
#elif defined(_WIN32)
  char full_path[MAX_PATH];
  if (GetModuleFileNameA(NULL, full_path, MAX_PATH) > 0) {
    std::string path_str(full_path);
    size_t pos = path_str.find_last_of("\\");
    if (pos != std::string::npos) {
      return path_str.substr(pos + 1);
    }
    return path_str;
  }
#else
  return "unknown";
#endif

  return "unknown";
}

} // namespace w1::dump

```

`src/w1dump/process_dumper.hpp`:

```hpp
#pragma once

#include "w1formats/dump_format.hpp"
#include "w1dump/memory_dumper.hpp"

#include <QBDI.h>
#include <redlog.hpp>

#include <string>

namespace w1::dump {

class process_dumper {
public:
  static process_dump dump_current(
      QBDI::VMInstanceRef vm, const util::memory_reader& memory, uint64_t thread_id, const QBDI::GPRState& gpr,
      const QBDI::FPRState& fpr, const dump_options& options = {}
  );

  static void save_dump(const process_dump& dump, const std::string& path);
  static process_dump load_dump(const std::string& path);

private:
  static redlog::logger log_;

  static std::string get_os_name();
  static std::string get_arch_name();
  static uint32_t get_pointer_size();
  static std::string get_process_name();
  static uint64_t get_pid();
};

} // namespace w1::dump

```

`src/w1dump/register_dumper.cpp`:

```cpp
#include "w1dump/register_dumper.hpp"

#include <cstddef>

namespace w1::dump {

redlog::logger register_dumper::log_ = redlog::get_logger("w1.dump.register");

thread_state register_dumper::capture_thread_state(
    const QBDI::GPRState& gpr, const QBDI::FPRState& fpr, uint64_t thread_id
) {
  log_.vrb("capturing thread state");

  thread_state state;
  state.thread_id = thread_id;

  const size_t gpr_count = sizeof(QBDI::GPRState) / sizeof(QBDI::rword);
  const QBDI::rword* gpr_array = reinterpret_cast<const QBDI::rword*>(&gpr);
  state.gpr_values.assign(gpr_array, gpr_array + gpr_count);

#if defined(QBDI_ARCH_X86_64) || defined(QBDI_ARCH_X86) || defined(QBDI_ARCH_AARCH64)
  const size_t fpr_size = sizeof(QBDI::FPRState);
  const uint64_t* fpr_array = reinterpret_cast<const uint64_t*>(&fpr);
  const size_t fpr_count = fpr_size / sizeof(uint64_t);
  state.fpr_values.assign(fpr_array, fpr_array + fpr_count);
#endif

  log_.trc(
      "captured thread state", redlog::field("thread_id", state.thread_id),
      redlog::field("gpr_count", state.gpr_values.size()), redlog::field("fpr_count", state.fpr_values.size())
  );

  return state;
}

} // namespace w1::dump

```

`src/w1dump/register_dumper.hpp`:

```hpp
#pragma once

#include "w1formats/dump_format.hpp"

#include <QBDI.h>
#include <redlog.hpp>

#include <cstdint>

namespace w1::dump {

class register_dumper {
public:
  static thread_state capture_thread_state(const QBDI::GPRState& gpr, const QBDI::FPRState& fpr, uint64_t thread_id);

private:
  static redlog::logger log_;
};

} // namespace w1::dump

```

`src/w1formats/CMakeLists.txt`:

```txt
w1_dep_nlohmann_json()

w1_add_static_library(w1formats
    jsonl_writer.cpp
)
add_library(w1::formats ALIAS w1formats)

target_link_libraries(w1formats PUBLIC nlohmann_json::nlohmann_json)

```

`src/w1formats/drcov.hpp`:

```hpp
/**
 * @file drcov.hpp
 * @brief Header-only C++17 library for parsing and writing DrCov coverage files
 *
 * This library provides a complete implementation for reading and writing
 * DrCov coverage files, supporting format version 2 with module table versions 2-4
 * and legacy module tables. It is designed to be portable and robust.
 *
 * References:
 * - DrCov format analysis: https://www.ayrx.me/drcov-file-format/
 * - DynamoRIO drcov tool: https://dynamorio.org/
 * - Lighthouse plugin: https://github.com/gaasedelen/lighthouse
 *
 * Example usage:
 * @code
 * // Reading a file
 * auto coverage = drcov::read("coverage.drcov");
 * if (coverage.has_hitcounts()) {
 *   // Process hitcount data
 *   for (size_t i = 0; i < coverage.basic_blocks.size(); ++i) {
 *     auto& bb = coverage.basic_blocks[i];
 *     auto hitcount = coverage.hitcounts[i];
 *     // Process basic block with its hitcount
 *   }
 * }
 *
 * // Creating coverage data with hitcounts
 * auto builder = drcov::builder()
 *     .enable_hitcounts()  // Sets flavor to "drcov-hits"
 *     .set_module_version(drcov::module_table_version::v4)
 *     .add_module("/bin/program", 0x400000, 0x450000)
 *     .add_module("/lib/libc.so", 0x7fff00000000, 0x7fff00100000)
 *     .add_coverage(0, 0x1000, 32, 5)  // module 0, offset 0x1000, 32 bytes, hit 5 times
 *     .add_coverage(0, 0x1020, 16, 1000)  // Hot path hit 1000 times
 *     .build();
 *
 * // Writing to file
 * drcov::write("output.drcov", builder);
 * @endcode
 */

#ifndef DRCOV_HPP
#define DRCOV_HPP

#include <algorithm>
#include <cstdint>
#include <cstring>
#include <fstream>
#include <iomanip>
#include <memory>
#include <optional>
#include <sstream>
#include <stdexcept>
#include <string>
#include <string_view>
#include <unordered_map>
#include <variant>
#include <vector>

// endianness detection for portable binary I/O
#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
#define DRCOV_LITTLE_ENDIAN 1
#elif defined(_WIN32)
#define DRCOV_LITTLE_ENDIAN 1
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
#define DRCOV_LITTLE_ENDIAN 0
#else
#warning "Could not determine endianness. Assuming little-endian."
#define DRCOV_LITTLE_ENDIAN 1
#endif

namespace drcov {

// forward declarations
class parse_error;
struct module_entry;
struct basic_block;
struct file_header;
struct coverage_data;
class coverage_builder;

/**
 * @brief Constants used throughout the library
 */
namespace constants {
constexpr uint32_t supported_file_version = 2;
constexpr size_t bb_entry_size = 8;
constexpr std::string_view version_prefix = "DRCOV VERSION: ";
constexpr std::string_view flavor_prefix = "DRCOV FLAVOR: ";
constexpr std::string_view module_table_prefix = "Module Table: ";
constexpr std::string_view bb_table_prefix = "BB Table: ";
constexpr std::string_view columns_prefix = "Columns: ";
constexpr std::string_view hitcount_table_prefix = "Hit Count Table: ";
constexpr std::string_view drcov_hits_flavor = "drcov-hits";
} // namespace constants

/**
 * @brief Error codes for parse operations
 */
enum class error_code {
  success = 0,
  file_not_found,
  invalid_format,
  unsupported_version,
  invalid_module_table,
  invalid_bb_table,
  invalid_hitcount_table,
  io_error,
  memory_error,
  invalid_binary_data,
  validation_error
};

/**
 * @brief Exception thrown by parse/write operations
 */
class parse_error : public std::runtime_error {
public:
  explicit parse_error(error_code code, const std::string& message) : std::runtime_error(message), code_(code) {}

  error_code code() const noexcept { return code_; }

private:
  error_code code_;
};

// internal utility functions
namespace detail {
inline std::string trim(const std::string& str) {
  auto start = str.find_first_not_of(" \t\r\n");
  auto end = str.find_last_not_of(" \t\r\n");
  return (start == std::string::npos) ? "" : str.substr(start, end - start + 1);
}

inline std::vector<std::string> split(const std::string& str, char delimiter) {
  std::vector<std::string> tokens;
  std::stringstream ss(str);
  std::string token;
  while (std::getline(ss, token, delimiter)) {
    tokens.push_back(trim(token));
  }
  return tokens;
}

template <typename T> inline T read_le(const uint8_t* data) {
  T value{};
#if DRCOV_LITTLE_ENDIAN
  std::memcpy(&value, data, sizeof(T));
#else
  for (size_t i = 0; i < sizeof(T); ++i) {
    value |= static_cast<T>(data[i]) << (i * 8);
  }
#endif
  return value;
}

template <typename T> inline void write_le(uint8_t* data, T value) {
#if DRCOV_LITTLE_ENDIAN
  std::memcpy(data, &value, sizeof(T));
#else
  for (size_t i = 0; i < sizeof(T); ++i) {
    data[i] = static_cast<uint8_t>((value >> (i * 8)) & 0xFF);
  }
#endif
}
} // namespace detail

/**
 * @brief DrCov file header containing version and tool information
 */
struct file_header {
  uint32_t version{constants::supported_file_version};
  std::string flavor{"drcov"};

  std::string to_string() const {
    std::stringstream ss;
    ss << constants::version_prefix << version << "\n";
    ss << constants::flavor_prefix << flavor << "\n";
    return ss.str();
  }
};

/**
 * @brief Module table format versions
 */
enum class module_table_version : uint32_t { legacy = 1, v2 = 2, v3 = 3, v4 = 4 };

/**
 * @brief Represents a loaded module/library in the traced process
 */
struct module_entry {
  uint32_t id{0};
  uint64_t base{0};
  uint64_t end{0};
  uint64_t entry{0};
  std::string path;

  std::optional<int32_t> containing_id;
  std::optional<uint64_t> offset;
  std::optional<uint32_t> checksum;
  std::optional<uint32_t> timestamp;

  uint64_t size() const noexcept { return end - base; }

  bool contains_address(uint64_t addr) const noexcept { return addr >= base && addr < end; }

  module_entry() = default;

  module_entry(uint32_t id, const std::string& path, uint64_t base, uint64_t end, uint64_t entry = 0)
      : id(id), base(base), end(end), entry(entry), path(path) {}
};

/**
 * @brief Represents an executed basic block
 */
struct basic_block {
  uint32_t start{0};
  uint16_t size{0};
  uint16_t module_id{0};

  uint64_t absolute_address(const module_entry& module) const noexcept { return module.base + start; }

  basic_block() = default;

  basic_block(uint32_t start, uint16_t size, uint16_t module_id) : start(start), size(size), module_id(module_id) {}
};

/**
 * @brief Complete coverage data structure
 */
struct coverage_data {
  file_header header;
  module_table_version module_version{module_table_version::v2};
  std::vector<module_entry> modules;
  std::vector<basic_block> basic_blocks;
  std::vector<uint32_t> hitcounts; // Optional hitcount data, parallel to basic_blocks

  std::optional<std::reference_wrapper<const module_entry>> find_module(uint16_t id) const {
    if (id < modules.size() && modules[id].id == id) {
      return std::cref(modules[id]);
    }
    auto it = std::find_if(modules.begin(), modules.end(), [id](const auto& m) { return m.id == id; });
    return it != modules.end() ? std::optional<std::reference_wrapper<const module_entry>>(*it) : std::nullopt;
  }

  std::optional<std::reference_wrapper<const module_entry>> find_module_by_address(uint64_t addr) const {
    auto it = std::find_if(modules.begin(), modules.end(), [addr](const auto& m) { return m.contains_address(addr); });
    return it != modules.end() ? std::optional<std::reference_wrapper<const module_entry>>(*it) : std::nullopt;
  }

  std::unordered_map<uint16_t, size_t> get_coverage_stats() const {
    std::unordered_map<uint16_t, size_t> stats;
    for (const auto& bb : basic_blocks) {
      stats[bb.module_id]++;
    }
    return stats;
  }

  bool has_hitcounts() const noexcept { return !hitcounts.empty() && hitcounts.size() == basic_blocks.size(); }

  void validate() const {
    for (size_t i = 0; i < modules.size(); ++i) {
      if (modules[i].id != i) {
        throw parse_error(
            error_code::validation_error,
            "Non-sequential module ID " + std::to_string(modules[i].id) + " at index " + std::to_string(i)
        );
      }
    }

    for (const auto& bb : basic_blocks) {
      if (bb.module_id >= modules.size()) {
        throw parse_error(
            error_code::validation_error, "Basic block references invalid module ID: " + std::to_string(bb.module_id)
        );
      }
    }

    // validate hitcount data if present
    if (!hitcounts.empty() && hitcounts.size() != basic_blocks.size()) {
      throw parse_error(
          error_code::validation_error, "Hitcount array size (" + std::to_string(hitcounts.size()) +
                                            ") does not match basic blocks count (" +
                                            std::to_string(basic_blocks.size()) + ")"
      );
    }
  }
};

/**
 * @brief Builder pattern for creating coverage data
 */
class coverage_builder {
public:
  coverage_builder() {
    data_.header.version = constants::supported_file_version;
    data_.header.flavor = "drcov";
    data_.module_version = module_table_version::v2;
  }

  coverage_builder& set_flavor(const std::string& flavor) {
    data_.header.flavor = flavor;
    return *this;
  }

  coverage_builder& enable_hitcounts() {
    data_.header.flavor = std::string(constants::drcov_hits_flavor);
    return *this;
  }

  coverage_builder& set_module_version(module_table_version version) {
    data_.module_version = version;
    return *this;
  }

  coverage_builder& add_module(const std::string& path, uint64_t base, uint64_t end, uint64_t entry = 0) {
    uint32_t id = static_cast<uint32_t>(data_.modules.size());
    data_.modules.emplace_back(id, path, base, end, entry);
    return *this;
  }

  coverage_builder& add_module(module_entry module) {
    data_.modules.push_back(std::move(module));
    return *this;
  }

  coverage_builder& add_coverage(uint16_t module_id, uint32_t offset, uint16_t size, uint32_t hitcount = 1) {
    data_.basic_blocks.emplace_back(offset, size, module_id);
    if (data_.header.flavor == constants::drcov_hits_flavor) {
      data_.hitcounts.push_back(hitcount);
    }
    return *this;
  }

  coverage_builder& add_basic_block(basic_block block, uint32_t hitcount = 1) {
    data_.basic_blocks.push_back(std::move(block));
    if (data_.header.flavor == constants::drcov_hits_flavor) {
      data_.hitcounts.push_back(hitcount);
    }
    return *this;
  }

  coverage_builder& add_basic_blocks(const std::vector<basic_block>& blocks) {
    data_.basic_blocks.insert(data_.basic_blocks.end(), blocks.begin(), blocks.end());
    if (data_.header.flavor == constants::drcov_hits_flavor) {
      data_.hitcounts.resize(data_.basic_blocks.size(), 1); // Default hitcount of 1
    }
    return *this;
  }

  coverage_builder& add_basic_blocks_with_hitcounts(
      const std::vector<basic_block>& blocks, const std::vector<uint32_t>& hitcounts
  ) {
    if (blocks.size() != hitcounts.size()) {
      throw std::invalid_argument("Blocks and hitcounts arrays must have the same size");
    }
    data_.basic_blocks.insert(data_.basic_blocks.end(), blocks.begin(), blocks.end());
    data_.hitcounts.insert(data_.hitcounts.end(), hitcounts.begin(), hitcounts.end());
    if (data_.header.flavor != constants::drcov_hits_flavor) {
      data_.header.flavor = std::string(constants::drcov_hits_flavor);
    }
    return *this;
  }

  coverage_builder& clear_coverage() {
    data_.basic_blocks.clear();
    data_.hitcounts.clear();
    return *this;
  }

  coverage_data build() {
    data_.validate();
    return std::move(data_);
  }

  coverage_data& data() { return data_; }
  const coverage_data& data() const { return data_; }

private:
  coverage_data data_;
};

// parser implementation
class parser {
public:
  static coverage_data parse_file(const std::string& filepath) {
    std::ifstream file(filepath, std::ios::binary);
    if (!file) {
      throw parse_error(error_code::file_not_found, "Cannot open file: " + filepath);
    }
    return parse_stream(file);
  }

  static coverage_data parse_stream(std::istream& stream) {
    coverage_data data;
    data.header = parse_header(stream);
    std::tie(data.modules, data.module_version) = parse_module_table(stream);
    data.basic_blocks = parse_bb_table(stream);

    // try to parse hitcount table if the flavor indicates hits support
    if (data.header.flavor == constants::drcov_hits_flavor) {
      data.hitcounts = parse_hitcount_table(stream, data.basic_blocks.size());
    }

    data.validate();
    return data;
  }

private:
  static file_header parse_header(std::istream& stream) {
    file_header header;
    std::string line;

    if (!std::getline(stream, line)) {
      throw parse_error(error_code::invalid_format, "Missing version header");
    }
    if (line.rfind(constants::version_prefix, 0) != 0) {
      throw parse_error(error_code::invalid_format, "Invalid version header format");
    }
    try {
      header.version = std::stoul(line.substr(constants::version_prefix.length()));
    } catch (const std::exception& e) {
      throw parse_error(error_code::invalid_format, "Malformed version number: " + std::string(e.what()));
    }

    if (!std::getline(stream, line)) {
      throw parse_error(error_code::invalid_format, "Missing flavor header");
    }
    if (line.rfind(constants::flavor_prefix, 0) != 0) {
      throw parse_error(error_code::invalid_format, "Invalid flavor header format");
    }
    header.flavor = detail::trim(line.substr(constants::flavor_prefix.length()));

    return header;
  }

  static std::pair<std::vector<module_entry>, module_table_version> parse_module_table(std::istream& stream) {
    std::string line;

    if (!std::getline(stream, line)) {
      throw parse_error(error_code::invalid_format, "Missing module table header");
    }
    if (line.rfind(constants::module_table_prefix, 0) != 0) {
      throw parse_error(error_code::invalid_format, "Invalid module table header");
    }

    auto [version, count] = parse_module_header(line);

    std::vector<std::string> columns;
    if (version != module_table_version::legacy) {
      if (!std::getline(stream, line)) {
        throw parse_error(error_code::invalid_format, "Missing columns header");
      }
      columns = parse_columns_header(line);
    } else {
      columns = {"id", "base", "end", "entry", "path"};
    }

    std::vector<module_entry> modules;
    modules.reserve(count);
    size_t modules_read = 0;

    while (modules_read < count && std::getline(stream, line)) {
      auto trimmed_line = detail::trim(line);
      if (trimmed_line.empty()) {
        continue;
      }

      auto module = parse_module_entry(trimmed_line, columns);
      if (module.id != modules_read) {
        throw parse_error(
            error_code::invalid_module_table,
            "Non-sequential module ID. Expected " + std::to_string(modules_read) + ", got " + std::to_string(module.id)
        );
      }

      modules.push_back(std::move(module));
      modules_read++;
    }

    if (modules_read != count) {
      throw parse_error(
          error_code::invalid_module_table, "Module table entry count mismatch. Expected " + std::to_string(count) +
                                                ", but found " + std::to_string(modules_read)
      );
    }

    return {modules, version};
  }

  static std::pair<module_table_version, size_t> parse_module_header(const std::string& line) {
    auto content = line.substr(constants::module_table_prefix.length());
    try {
      if (content.find("version") == std::string::npos) {
        return {module_table_version::legacy, std::stoul(content)};
      }
      auto parts = detail::split(content, ',');
      if (parts.size() != 2) {
        throw parse_error(error_code::invalid_format, "Invalid module table header format");
      }
      auto version_str = parts[0].substr(parts[0].find("version") + 8);
      auto count_str = parts[1].substr(parts[1].find("count") + 6);
      return {static_cast<module_table_version>(std::stoul(version_str)), std::stoul(count_str)};
    } catch (const std::exception& e) {
      throw parse_error(error_code::invalid_format, "Failed to parse module table header: " + std::string(e.what()));
    }
  }

  static std::vector<std::string> parse_columns_header(const std::string& line) {
    if (line.rfind(constants::columns_prefix, 0) != 0) {
      throw parse_error(error_code::invalid_format, "Invalid columns header");
    }
    return detail::split(line.substr(constants::columns_prefix.length()), ',');
  }

  static std::vector<std::string> parse_module_line(const std::string& line, size_t num_columns) {
    std::vector<std::string> values;
    if (num_columns == 0) {
      return values;
    }
    values.reserve(num_columns);
    std::string::size_type current_pos = 0;
    for (size_t i = 0; i < num_columns - 1; ++i) {
      auto comma_pos = line.find(',', current_pos);
      if (comma_pos == std::string::npos) {
        throw parse_error(error_code::invalid_module_table, "Module entry has too few columns");
      }
      values.push_back(detail::trim(line.substr(current_pos, comma_pos - current_pos)));
      current_pos = comma_pos + 1;
    }
    values.push_back(detail::trim(line.substr(current_pos)));
    return values;
  }

  static module_entry parse_module_entry(const std::string& line, const std::vector<std::string>& columns) {
    auto values = parse_module_line(line, columns.size());
    if (values.size() != columns.size()) {
      throw parse_error(error_code::invalid_module_table, "Module entry column count mismatch");
    }

    module_entry entry;
    std::unordered_map<std::string, std::string> value_map;
    for (size_t i = 0; i < columns.size(); ++i) {
      value_map[columns[i]] = values[i];
    }

    auto get_val = [&](const std::string& key) -> std::optional<std::string> {
      auto it = value_map.find(key);
      return (it != value_map.end()) ? std::optional(it->second) : std::nullopt;
    };

    try {
      if (auto val = get_val("id")) {
        entry.id = std::stoul(*val);
      }
      if (auto val = get_val("base")) {
        entry.base = std::stoull(*val, nullptr, 16);
      }
      if (auto val = get_val("start")) {
        entry.base = std::stoull(*val, nullptr, 16);
      }
      if (auto val = get_val("end")) {
        entry.end = std::stoull(*val, nullptr, 16);
      }
      if (auto val = get_val("entry")) {
        entry.entry = std::stoull(*val, nullptr, 16);
      }
      if (auto val = get_val("path")) {
        entry.path = *val;
      }
      if (auto val = get_val("containing_id")) {
        entry.containing_id = std::stol(*val);
      }
      if (auto val = get_val("offset")) {
        entry.offset = std::stoull(*val, nullptr, 16);
      }
      if (auto val = get_val("checksum")) {
        entry.checksum = std::stoul(*val, nullptr, 16);
      }
      if (auto val = get_val("timestamp")) {
        entry.timestamp = std::stoul(*val, nullptr, 16);
      }
    } catch (const std::exception& e) {
      throw parse_error(
          error_code::invalid_module_table, "Malformed numeric value in module entry '" + line + "': " + e.what()
      );
    }
    return entry;
  }

  static std::vector<basic_block> parse_bb_table(std::istream& stream) {
    std::string line;

    if (!std::getline(stream, line)) {
      if (stream.eof() && stream.gcount() == 0) {
        return {};
      }
      throw parse_error(error_code::invalid_format, "Missing BB table header");
    }

    if (line.rfind(constants::bb_table_prefix, 0) != 0) {
      throw parse_error(error_code::invalid_format, "Invalid BB table header");
    }

    size_t count = 0;
    try {
      auto content = line.substr(constants::bb_table_prefix.length());
      count = std::stoul(content.substr(0, content.find(' ')));
    } catch (const std::exception& e) {
      throw parse_error(error_code::invalid_bb_table, "Malformed BB table count: " + std::string(e.what()));
    }

    if (count == 0) {
      return {};
    }

    std::vector<uint8_t> binary_data(count * constants::bb_entry_size);
    stream.read(reinterpret_cast<char*>(binary_data.data()), binary_data.size());
    if (static_cast<size_t>(stream.gcount()) != binary_data.size()) {
      throw parse_error(error_code::invalid_binary_data, "Failed to read complete BB table binary data");
    }

    std::vector<basic_block> blocks;
    blocks.reserve(count);
    for (size_t i = 0; i < count; ++i) {
      const uint8_t* entry_data = binary_data.data() + (i * constants::bb_entry_size);
      blocks.emplace_back(
          detail::read_le<uint32_t>(entry_data), detail::read_le<uint16_t>(entry_data + 4),
          detail::read_le<uint16_t>(entry_data + 6)
      );
    }
    return blocks;
  }

  static std::vector<uint32_t> parse_hitcount_table(std::istream& stream, size_t expected_count) {
    std::string line;

    // try to read hitcount table header
    if (!std::getline(stream, line)) {
      // no hitcount table found - this is OK for backward compatibility
      return {};
    }

    // check if this is actually a hitcount table header
    if (line.rfind(constants::hitcount_table_prefix, 0) != 0) {
      // not a hitcount table - put the line back and return empty
      // note: In practice this is difficult to do with ifstream, but we can return empty
      return {};
    }

    // parse hitcount table header: "Hit Count Table: version 1, count <N>"
    size_t version = 0;
    size_t count = 0;
    try {
      auto content = line.substr(constants::hitcount_table_prefix.length());
      auto parts = detail::split(content, ',');
      if (parts.size() != 2) {
        throw parse_error(error_code::invalid_hitcount_table, "Invalid hitcount table header format");
      }

      // parse version
      auto version_part = detail::trim(parts[0]);
      if (version_part.find("version") != 0) {
        throw parse_error(error_code::invalid_hitcount_table, "Missing version in hitcount table header");
      }
      version = std::stoul(version_part.substr(8)); // "version ".length()

      // parse count
      auto count_part = detail::trim(parts[1]);
      if (count_part.find("count") != 0) {
        throw parse_error(error_code::invalid_hitcount_table, "Missing count in hitcount table header");
      }
      count = std::stoul(count_part.substr(6)); // "count ".length()

    } catch (const std::exception& e) {
      throw parse_error(
          error_code::invalid_hitcount_table, "Failed to parse hitcount table header: " + std::string(e.what())
      );
    }

    // validate version
    if (version != 1) {
      throw parse_error(
          error_code::invalid_hitcount_table, "Unsupported hitcount table version: " + std::to_string(version)
      );
    }

    // validate count matches basic blocks
    if (count != expected_count) {
      throw parse_error(
          error_code::invalid_hitcount_table, "Hitcount table count (" + std::to_string(count) +
                                                  ") does not match basic blocks count (" +
                                                  std::to_string(expected_count) + ")"
      );
    }

    if (count == 0) {
      return {};
    }

    // read binary hitcount data
    std::vector<uint8_t> binary_data(count * sizeof(uint32_t));
    stream.read(reinterpret_cast<char*>(binary_data.data()), binary_data.size());
    if (static_cast<size_t>(stream.gcount()) != binary_data.size()) {
      throw parse_error(error_code::invalid_binary_data, "Failed to read complete hitcount table binary data");
    }

    // convert binary data to hitcounts
    std::vector<uint32_t> hitcounts;
    hitcounts.reserve(count);
    for (size_t i = 0; i < count; ++i) {
      const uint8_t* hitcount_data = binary_data.data() + (i * sizeof(uint32_t));
      hitcounts.push_back(detail::read_le<uint32_t>(hitcount_data));
    }

    return hitcounts;
  }
};

// writer implementation
class writer {
public:
  static void write_file(const coverage_data& data, const std::string& filepath) {
    std::ofstream file(filepath, std::ios::binary);
    if (!file) {
      throw parse_error(error_code::io_error, "Cannot create file: " + filepath);
    }
    write_stream(data, file);
  }

  static void write_stream(const coverage_data& data, std::ostream& stream) {
    data.validate();
    stream << data.header.to_string();
    write_module_table(data, stream);
    write_bb_table(data.basic_blocks, stream);

    // write hitcount table if present
    if (data.has_hitcounts()) {
      write_hitcount_table(data.hitcounts, stream);
    }

    if (!stream) {
      throw parse_error(error_code::io_error, "Error writing to stream");
    }
  }

private:
  static void write_module_table(const coverage_data& data, std::ostream& stream) {
    if (data.module_version == module_table_version::legacy) {
      stream << constants::module_table_prefix << data.modules.size() << "\n";
      for (const auto& module : data.modules) {
        write_module_entry(module, data.module_version, false, stream);
        stream << "\n";
      }
    } else {
      stream << constants::module_table_prefix << "version " << static_cast<uint32_t>(data.module_version) << ", count "
             << data.modules.size() << "\n";
      std::string columns_str = get_columns_string(data);
      stream << constants::columns_prefix << columns_str << "\n";
      bool has_windows_fields = columns_str.find("checksum") != std::string::npos;
      for (const auto& module : data.modules) {
        write_module_entry(module, data.module_version, has_windows_fields, stream);
        stream << "\n";
      }
    }
  }

  static std::string get_columns_string(const coverage_data& data) {
    const bool has_windows_fields = std::any_of(data.modules.begin(), data.modules.end(), [](const auto& m) {
      return m.checksum.has_value() || m.timestamp.has_value();
    });

    switch (data.module_version) {
    case module_table_version::legacy:
      return "id, base, end, entry, path"; // Enforce fixed legacy format
    case module_table_version::v2:
      return has_windows_fields ? "id, base, end, entry, checksum, timestamp, path" : "id, base, end, entry, path";
    case module_table_version::v3:
      return has_windows_fields ? "id, containing_id, start, end, entry, checksum, timestamp, path"
                                : "id, containing_id, start, end, entry, path";
    case module_table_version::v4:
      return has_windows_fields ? "id, containing_id, start, end, entry, offset, checksum, timestamp, path"
                                : "id, containing_id, start, end, entry, offset, path";
    default: // Should be unreachable
      return "id, base, end, entry, path";
    }
  }

  static void write_module_entry(
      const module_entry& module, module_table_version version, bool has_windows_fields, std::ostream& stream
  ) {
    auto original_flags = stream.flags();
    auto original_fill = stream.fill();
    stream << std::dec << module.id;

    if (version >= module_table_version::v3) {
      stream << ", " << module.containing_id.value_or(-1);
    }

    stream << ", 0x" << std::hex << std::setfill('0') << std::setw(16) << module.base;
    stream << ", 0x" << std::hex << std::setfill('0') << std::setw(16) << module.end;
    stream << ", 0x" << std::hex << std::setfill('0') << std::setw(16) << module.entry;

    if (version >= module_table_version::v4) {
      stream << ", ";
      if (module.offset) {
        stream << "0x" << std::hex << std::setfill('0') << std::setw(16) << *module.offset;
      } else {
        stream << "0x0";
      }
    }

    if (has_windows_fields) {
      stream << ", 0x" << std::hex << std::setfill('0') << std::setw(8) << module.checksum.value_or(0);
      stream << ", 0x" << std::hex << std::setfill('0') << std::setw(8) << module.timestamp.value_or(0);
    }

    stream << ", " << module.path;
    stream.flags(original_flags);
    stream.fill(original_fill);
  }

  static void write_bb_table(const std::vector<basic_block>& blocks, std::ostream& stream) {
    stream << constants::bb_table_prefix << blocks.size() << " bbs\n";
    if (blocks.empty()) {
      return;
    }
    std::vector<uint8_t> binary_data(blocks.size() * constants::bb_entry_size);
    for (size_t i = 0; i < blocks.size(); ++i) {
      uint8_t* entry_data = binary_data.data() + (i * constants::bb_entry_size);
      detail::write_le<uint32_t>(entry_data, blocks[i].start);
      detail::write_le<uint16_t>(entry_data + 4, blocks[i].size);
      detail::write_le<uint16_t>(entry_data + 6, blocks[i].module_id);
    }
    stream.write(reinterpret_cast<const char*>(binary_data.data()), binary_data.size());
  }

  static void write_hitcount_table(const std::vector<uint32_t>& hitcounts, std::ostream& stream) {
    if (hitcounts.empty()) {
      return;
    }

    // write hitcount table header
    stream << constants::hitcount_table_prefix << "version 1, count " << hitcounts.size() << "\n";

    // write binary hitcount data
    std::vector<uint8_t> binary_data(hitcounts.size() * sizeof(uint32_t));
    for (size_t i = 0; i < hitcounts.size(); ++i) {
      uint8_t* hitcount_data = binary_data.data() + (i * sizeof(uint32_t));
      detail::write_le<uint32_t>(hitcount_data, hitcounts[i]);
    }
    stream.write(reinterpret_cast<const char*>(binary_data.data()), binary_data.size());
  }
};

inline coverage_data read(const std::string& filepath) { return parser::parse_file(filepath); }
inline coverage_data read(std::istream& stream) { return parser::parse_stream(stream); }
inline void write(const std::string& filepath, const coverage_data& data) { writer::write_file(data, filepath); }
inline void write(std::ostream& stream, const coverage_data& data) { writer::write_stream(data, stream); }
inline coverage_builder builder() { return coverage_builder(); }

} // namespace drcov

#undef DRCOV_LITTLE_ENDIAN

#endif // DRCOV_HPP
```

`src/w1formats/dump_format.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>
#include <vector>

#include <nlohmann/json.hpp>

namespace w1::dump {

struct dump_metadata {
  uint32_t version = 1;
  uint64_t timestamp = 0;
  std::string os;
  std::string arch;
  uint32_t pointer_size = 0;
  uint64_t pid = 0;
  std::string process_name;
};

struct thread_state {
  uint64_t thread_id = 0;
  std::vector<uint64_t> gpr_values;
  std::vector<uint64_t> fpr_values;
};

struct memory_region {
  uint64_t start = 0;
  uint64_t end = 0;
  uint32_t permissions = 0;
  std::string module_name;
  bool is_stack = false;
  bool is_code = false;
  bool is_data = false;
  bool is_anonymous = false;
  std::vector<uint8_t> data;
};

struct module_info {
  std::string path;
  std::string name;
  uint64_t base_address = 0;
  uint64_t size = 0;
  std::string type;
  bool is_system = false;
  uint32_t permissions = 0;
};

struct process_dump {
  dump_metadata metadata;
  thread_state thread;
  std::vector<memory_region> regions;
  std::vector<module_info> modules;
};

NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(dump_metadata, version, timestamp, os, arch, pointer_size, pid, process_name)

NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(thread_state, thread_id, gpr_values, fpr_values)

NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(
    memory_region, start, end, permissions, module_name, is_stack, is_code, is_data, is_anonymous, data
)

NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(module_info, path, name, base_address, size, type, is_system, permissions)

NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(process_dump, metadata, thread, regions, modules)

} // namespace w1::dump

```

`src/w1formats/jsonl_writer.cpp`:

```cpp
#include "w1formats/jsonl_writer.hpp"

#include <algorithm>
#include <cstring>

namespace w1::io {
namespace {

size_t sanitize_buffer_size(size_t size) {
  if (size == 0) {
    return 1;
  }
  return size;
}

} // namespace

jsonl_writer::jsonl_writer() : config_(), buffer_size_bytes_(sanitize_buffer_size(config_.buffer_size_bytes)) {
  buffer_.resize(buffer_size_bytes_);
  reset_state();
}

jsonl_writer::jsonl_writer(const std::string& path, jsonl_writer_config config)
    : config_(config), buffer_size_bytes_(sanitize_buffer_size(config.buffer_size_bytes)) {
  buffer_.resize(buffer_size_bytes_);
  reset_state();

  if (!path.empty()) {
    open(path);
  }
}

jsonl_writer::~jsonl_writer() { close(); }

bool jsonl_writer::open(const std::string& path) {
  std::lock_guard<std::mutex> lock(mutex_);

  close_locked();

  file_.open(path, std::ios::out | std::ios::binary | std::ios::trunc);
  if (!file_.is_open()) {
    return false;
  }

  reset_state();
  return true;
}

void jsonl_writer::close() {
  std::lock_guard<std::mutex> lock(mutex_);

  close_locked();
}

void jsonl_writer::close_locked() {
  if (!file_.is_open()) {
    return;
  }

  flush_internal();
  file_.close();
}

bool jsonl_writer::write_line(std::string_view json) {
  std::lock_guard<std::mutex> lock(mutex_);

  if (!file_.is_open()) {
    return false;
  }

  if (!json.empty()) {
    if (!append_bytes(json.data(), json.size())) {
      return false;
    }
  }

  if (json.empty() || json.back() != '\n') {
    if (!append_bytes("\n", 1)) {
      return false;
    }
  }

  event_count_ += 1;
  return update_flush_thresholds();
}

bool jsonl_writer::write_raw(const char* data, size_t len) {
  std::lock_guard<std::mutex> lock(mutex_);

  if (!file_.is_open() || !data || len == 0) {
    return false;
  }

  if (!append_bytes(data, len)) {
    return false;
  }

  size_t newline_count = static_cast<size_t>(std::count(data, data + len, '\n'));
  if (newline_count > 0) {
    event_count_ += newline_count;
  }

  return update_flush_thresholds();
}

void jsonl_writer::flush() {
  std::lock_guard<std::mutex> lock(mutex_);
  flush_internal();
}

bool jsonl_writer::append_bytes(const char* data, size_t len) {
  if (len == 0) {
    return true;
  }

  if (len > buffer_size_bytes_) {
    if (!flush_internal()) {
      return false;
    }

    file_.write(data, static_cast<std::streamsize>(len));
    if (!file_) {
      return false;
    }

    bytes_written_ += len;
    return flush_file();
  }

  if (buffer_pos_ + len > buffer_size_bytes_) {
    if (!flush_internal()) {
      return false;
    }
  }

  std::memcpy(buffer_.data() + buffer_pos_, data, len);
  buffer_pos_ += len;
  return true;
}

bool jsonl_writer::flush_internal() {
  if (!file_.is_open()) {
    return false;
  }

  if (buffer_pos_ == 0) {
    return true;
  }

  file_.write(buffer_.data(), static_cast<std::streamsize>(buffer_pos_));
  if (!file_) {
    return false;
  }

  bytes_written_ += buffer_pos_;
  buffer_pos_ = 0;

  return flush_file();
}

bool jsonl_writer::flush_file() {
  file_.flush();
  if (!file_) {
    return false;
  }

  flush_count_ += 1;
  return true;
}

void jsonl_writer::reset_state() {
  buffer_pos_ = 0;
  event_count_ = 0;
  flush_count_ = 0;
  bytes_written_ = 0;
  next_event_flush_ = config_.flush_event_count > 0 ? config_.flush_event_count : 0;
}

bool jsonl_writer::update_flush_thresholds() {
  bool should_flush = false;

  if (config_.flush_event_count > 0 && event_count_ >= next_event_flush_) {
    should_flush = true;
    while (event_count_ >= next_event_flush_) {
      next_event_flush_ += config_.flush_event_count;
    }
  }

  if (config_.flush_byte_count > 0 && buffer_pos_ >= config_.flush_byte_count) {
    should_flush = true;
  }

  if (should_flush) {
    return flush_internal();
  }

  return true;
}

} // namespace w1::io

```

`src/w1formats/jsonl_writer.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <fstream>
#include <mutex>
#include <string>
#include <string_view>
#include <vector>

namespace w1::io {

struct jsonl_writer_config {
  size_t buffer_size_bytes = 4 * 1024 * 1024;
  size_t flush_event_count = 1'000'000;
  size_t flush_byte_count = 0;
};

class jsonl_writer {
public:
  jsonl_writer();
  explicit jsonl_writer(const std::string& path, jsonl_writer_config config = {});
  ~jsonl_writer();

  jsonl_writer(const jsonl_writer&) = delete;
  jsonl_writer& operator=(const jsonl_writer&) = delete;
  jsonl_writer(jsonl_writer&&) = delete;
  jsonl_writer& operator=(jsonl_writer&&) = delete;

  bool open(const std::string& path);
  void close();
  bool is_open() const { return file_.is_open(); }

  bool write_line(std::string_view json);
  bool write_raw(const char* data, size_t len);

  void flush();

  size_t event_count() const { return event_count_; }
  size_t flush_count() const { return flush_count_; }
  size_t bytes_written() const { return bytes_written_; }
  size_t buffered_bytes() const { return buffer_pos_; }

private:
  bool append_bytes(const char* data, size_t len);
  bool flush_internal();
  bool flush_file();
  void reset_state();
  bool update_flush_thresholds();
  void close_locked();

  std::ofstream file_{};
  jsonl_writer_config config_{};
  std::vector<char> buffer_{};
  size_t buffer_size_bytes_ = 0;
  size_t buffer_pos_ = 0;
  size_t next_event_flush_ = 0;

  size_t event_count_ = 0;
  size_t flush_count_ = 0;
  size_t bytes_written_ = 0;

  mutable std::mutex mutex_{};
};

} // namespace w1::io

```

`src/w1gadget/CMakeLists.txt`:

```txt
w1_dep_redlog()
w1_dep_qbdi()

w1_add_static_library(w1gadget
    gadget_executor.cpp
)
add_library(w1::gadget ALIAS w1gadget)

target_link_libraries(w1gadget PUBLIC QBDI::QBDI redlog::redlog)

```

`src/w1gadget/gadget_executor.cpp`:

```cpp
#include "w1gadget/gadget_executor.hpp"

#include <cstdio>
#include <string>

#include "w1base/interval.hpp"

namespace {

// Guard to avoid truncating disassembly at the end of an instrumented range.
constexpr size_t k_range_guard_bytes = 16;

} // namespace

namespace w1::gadget {

gadget_executor::gadget_executor(QBDI::VM* parent_vm, config cfg) : parent_vm_(parent_vm), config_(cfg) {
  auto log = redlog::get_logger("w1.gadget.executor");
  log.dbg("initialized", redlog::field("parent_vm", "%p", parent_vm_), redlog::field("debug", config_.debug));
}

gadget_executor::stack_guard::~stack_guard() {
  if (stack) {
    QBDI::alignedFree(stack);
  }
}

bool gadget_executor::stack_guard::allocate(QBDI::GPRState* gpr, size_t stack_size) {
  if (!gpr || stack_size == 0) {
    return false;
  }

  return QBDI::allocateVirtualStack(gpr, static_cast<uint32_t>(stack_size), &stack);
}

std::unique_ptr<QBDI::VM> gadget_executor::create_sub_vm() {
  auto sub_vm = std::make_unique<QBDI::VM>();

  if (parent_vm_) {
    sub_vm->setOptions(parent_vm_->getOptions());
  }

  auto log = redlog::get_logger("w1.gadget.executor");
  log.dbg("created sub-vm", redlog::field("sub_vm", "%p", sub_vm.get()), redlog::field("parent_vm", "%p", parent_vm_));

  setup_debug_callback(sub_vm.get());
  return sub_vm;
}

void gadget_executor::setup_debug_callback(QBDI::VM* vm) {
  if (!config_.debug || !vm) {
    return;
  }

  vm->addCodeCB(
      QBDI::PREINST,
      [](QBDI::VMInstanceRef vm_ref, QBDI::GPRState*, QBDI::FPRState*, void*) -> QBDI::VMAction {
        const QBDI::InstAnalysis* inst = vm_ref->getInstAnalysis();
        if (inst && inst->disassembly) {
          std::printf("[gadget debug] 0x%llx: %s\n", static_cast<unsigned long long>(inst->address), inst->disassembly);
        }
        return QBDI::VMAction::CONTINUE;
      },
      nullptr
  );

  auto log = redlog::get_logger("w1.gadget.executor");
  log.dbg("enabled debug callback for sub-vm");
}

instrumentation_scope gadget_executor::resolve_scope(
    instrumentation_scope requested, instrumentation_scope fallback
) const {
  return requested == instrumentation_scope::inherit ? fallback : requested;
}

size_t gadget_executor::resolve_stack_size(size_t requested) const {
  return requested == 0 ? config_.stack_size : requested;
}

size_t gadget_executor::resolve_range_size(size_t requested, size_t fallback) const {
  return requested == 0 ? fallback : requested;
}

size_t gadget_executor::resolve_max_instructions(size_t requested) const {
  return requested == 0 ? config_.max_instructions : requested;
}

bool gadget_executor::prepare_vm_state(
    QBDI::VM* vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, size_t stack_size, stack_guard& stack
) {
  if (!vm || !gpr || !fpr || !parent_vm_) {
    return false;
  }

  *gpr = *parent_vm_->getGPRState();
  *fpr = *parent_vm_->getFPRState();

  if (!stack.allocate(gpr, stack_size)) {
    return false;
  }

  vm->setGPRState(gpr);
  vm->setFPRState(fpr);
  return true;
}

bool gadget_executor::configure_instrumentation(
    QBDI::VM* vm, instrumentation_scope scope, QBDI::rword start_addr, QBDI::rword stop_addr, size_t range_size,
    std::string* error
) {
  if (!vm) {
    if (error) {
      *error = "vm is null";
    }
    return false;
  }

  switch (scope) {
  case instrumentation_scope::range: {
    uint64_t range_end = 0;
    if (stop_addr > start_addr) {
      range_end = static_cast<uint64_t>(stop_addr);
      if (!w1::util::compute_end(range_end, k_range_guard_bytes, &range_end)) {
        if (error) {
          *error = "range size overflow";
        }
        return false;
      }
    } else if (!w1::util::compute_end(static_cast<uint64_t>(start_addr), range_size, &range_end)) {
      if (error) {
        *error = "range size overflow";
      }
      return false;
    }

    if (range_end <= start_addr) {
      if (error) {
        *error = "invalid instrumentation range";
      }
      return false;
    }

    vm->addInstrumentedRange(start_addr, static_cast<QBDI::rword>(range_end));
    return true;
  }
  case instrumentation_scope::module: {
    if (!vm->addInstrumentedModuleFromAddr(start_addr)) {
      if (error) {
        *error = "failed to instrument module from address";
      }
      return false;
    }
    return true;
  }
  case instrumentation_scope::all_executable: {
    if (!vm->instrumentAllExecutableMaps()) {
      if (error) {
        *error = "failed to instrument executable maps";
      }
      return false;
    }
    return true;
  }
  case instrumentation_scope::inherit:
    break;
  }

  if (error) {
    *error = "invalid instrumentation scope";
  }
  return false;
}

bool gadget_executor::install_stop_callback(QBDI::VM* vm, stop_state& state) {
  if (!vm) {
    return false;
  }

  uint32_t id = vm->addCodeCB(
      QBDI::PREINST,
      [](QBDI::VMInstanceRef, QBDI::GPRState* gpr, QBDI::FPRState*, void* data) -> QBDI::VMAction {
        auto* stop = static_cast<stop_state*>(data);
        stop->instruction_count += 1;
        stop->stop_pc = QBDI_GPR_GET(gpr, QBDI::REG_PC);

        if (stop->max_instructions != 0 && stop->instruction_count >= stop->max_instructions) {
          return QBDI::VMAction::STOP;
        }

        if (stop->stop_addr != 0 && stop->stop_pc >= stop->stop_addr) {
          return QBDI::VMAction::STOP;
        }

        return QBDI::VMAction::CONTINUE;
      },
      &state
  );

  return id != QBDI::INVALID_EVENTID;
}

bool gadget_executor::execute_call(
    QBDI::rword addr, std::span<const QBDI::rword> args, const call_options& options, QBDI::rword* result,
    std::string* error
) {
  if (!parent_vm_) {
    if (error) {
      *error = "parent vm is null";
    }
    return false;
  }

  auto sub_vm = create_sub_vm();
  if (!sub_vm) {
    if (error) {
      *error = "failed to create sub-vm";
    }
    return false;
  }

  QBDI::GPRState gpr{};
  QBDI::FPRState fpr{};
  stack_guard stack;
  size_t stack_size = resolve_stack_size(options.stack_size);
  if (!prepare_vm_state(sub_vm.get(), &gpr, &fpr, stack_size, stack)) {
    if (error) {
      *error = "failed to prepare vm state";
    }
    return false;
  }

  instrumentation_scope scope = resolve_scope(options.scope, config_.call_scope);
  size_t range_size = resolve_range_size(options.range_size, config_.call_range_size);
  if (!configure_instrumentation(sub_vm.get(), scope, addr, 0, range_size, error)) {
    return false;
  }

  stop_state stop{};
  stop.max_instructions = resolve_max_instructions(options.max_instructions);
  if (stop.max_instructions != 0 && !install_stop_callback(sub_vm.get(), stop)) {
    if (error) {
      *error = "failed to install stop callback";
    }
    return false;
  }

  QBDI::rword return_value = 0;
  bool call_success = sub_vm->callA(&return_value, addr, static_cast<uint32_t>(args.size()), args.data());
  if (!call_success) {
    if (error) {
      *error = "vm call failed";
    }
    return false;
  }

  if (result) {
    *result = return_value;
  }

  return true;
}

gadget_result gadget_executor::gadget_run(QBDI::rword start_addr, QBDI::rword stop_addr, run_options options) {
  gadget_result result;

  if (!parent_vm_) {
    result.error = "parent vm is null";
    return result;
  }

  if (stop_addr <= start_addr) {
    result.error = "stop address must be greater than start address";
    return result;
  }

  auto sub_vm = create_sub_vm();
  if (!sub_vm) {
    result.error = "failed to create sub-vm";
    return result;
  }

  QBDI::GPRState gpr{};
  QBDI::FPRState fpr{};
  stack_guard stack;
  size_t stack_size = resolve_stack_size(options.stack_size);
  if (!prepare_vm_state(sub_vm.get(), &gpr, &fpr, stack_size, stack)) {
    result.error = "failed to prepare vm state";
    return result;
  }

  instrumentation_scope scope = resolve_scope(options.scope, config_.run_scope);
  size_t range_size = resolve_range_size(options.range_size, config_.run_range_size);
  if (!configure_instrumentation(sub_vm.get(), scope, start_addr, stop_addr, range_size, &result.error)) {
    return result;
  }

  stop_state stop{};
  stop.stop_addr = stop_addr;
  stop.max_instructions = resolve_max_instructions(options.max_instructions);
  if (!install_stop_callback(sub_vm.get(), stop)) {
    result.error = "failed to install stop callback";
    return result;
  }

  auto log = redlog::get_logger("w1.gadget.executor");
  log.dbg(
      "executing raw gadget", redlog::field("start", "0x%llx", start_addr), redlog::field("stop", "0x%llx", stop_addr)
  );

  bool run_success = sub_vm->run(start_addr, stop_addr);
  if (!run_success) {
    result.error = "vm run failed";
    log.err("raw gadget execution failed", redlog::field("addr", "0x%llx", start_addr));
    return result;
  }

  result.gpr = *sub_vm->getGPRState();
  result.fpr = *sub_vm->getFPRState();
  result.instruction_count = stop.instruction_count;
  result.stop_address = stop.stop_pc;
  result.success = true;

  log.dbg("raw gadget execution succeeded", redlog::field("instructions", stop.instruction_count));
  return result;
}

gadget_result gadget_executor::run_with_vm(QBDI::VM* vm, QBDI::rword start_addr, QBDI::rword stop_addr) {
  gadget_result result;

  if (!vm) {
    result.error = "vm is null";
    return result;
  }

  if (stop_addr <= start_addr) {
    result.error = "stop address must be greater than start address";
    return result;
  }

  stop_state stop{};
  stop.stop_addr = stop_addr;
  stop.max_instructions = config_.max_instructions;
  if (!install_stop_callback(vm, stop)) {
    result.error = "failed to install stop callback";
    return result;
  }

  try {
    auto log = redlog::get_logger("w1.gadget.executor");
    log.dbg(
        "running with custom vm", redlog::field("vm", "%p", vm), redlog::field("start", "0x%llx", start_addr),
        redlog::field("stop", "0x%llx", stop_addr)
    );

    bool run_success = vm->run(start_addr, stop_addr);
    if (!run_success) {
      result.error = "vm run failed";
      log.err("custom vm run failed", redlog::field("addr", "0x%llx", start_addr));
      return result;
    }

    result.gpr = *vm->getGPRState();
    result.fpr = *vm->getFPRState();
    result.instruction_count = stop.instruction_count;
    result.stop_address = stop.stop_pc;
    result.success = true;

    log.dbg("custom vm execution succeeded");
  } catch (const std::exception& e) {
    result.error = std::string("exception: ") + e.what();
    auto log = redlog::get_logger("w1.gadget.executor");
    log.err("custom vm execution exception", redlog::field("error", e.what()));
  }

  return result;
}

} // namespace w1::gadget

```

`src/w1gadget/gadget_executor.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <initializer_list>
#include <memory>
#include <span>
#include <string>
#include <type_traits>
#include <vector>

#include <QBDI.h>
#include <redlog.hpp>

namespace w1::gadget {

enum class instrumentation_scope { inherit, range, module, all_executable };

struct gadget_result {
  bool success = false;
  std::string error;
  QBDI::GPRState gpr{};
  QBDI::FPRState fpr{};
  size_t instruction_count = 0;
  QBDI::rword stop_address = 0;
};

struct call_options {
  instrumentation_scope scope = instrumentation_scope::inherit;
  size_t stack_size = 0;
  size_t range_size = 0;
  size_t max_instructions = 0;
};

struct run_options {
  instrumentation_scope scope = instrumentation_scope::inherit;
  size_t stack_size = 0;
  size_t range_size = 0;
  size_t max_instructions = 0;
};

class gadget_executor {
public:
  static constexpr size_t default_stack_size = 0x10000;
  static constexpr size_t default_range_size = 0x10000;

  struct config {
    bool debug;
    size_t stack_size;
    size_t call_range_size;
    size_t run_range_size;
    size_t max_instructions;
    instrumentation_scope call_scope;
    instrumentation_scope run_scope;

    constexpr config()
        : debug(false), stack_size(default_stack_size), call_range_size(default_range_size),
          run_range_size(default_range_size), max_instructions(0), call_scope(instrumentation_scope::module),
          run_scope(instrumentation_scope::range) {}
  };

  explicit gadget_executor(QBDI::VM* parent_vm, config cfg = config{});

  gadget_executor(const gadget_executor&) = delete;
  gadget_executor& operator=(const gadget_executor&) = delete;
  gadget_executor(gadget_executor&&) = delete;
  gadget_executor& operator=(gadget_executor&&) = delete;

  template <typename RetType = QBDI::rword>
  RetType gadget_call(QBDI::rword addr, std::span<const QBDI::rword> args = {}, call_options options = {});

  template <typename RetType = QBDI::rword>
  RetType gadget_call(QBDI::rword addr, std::initializer_list<QBDI::rword> args, call_options options = {});

  gadget_result gadget_run(QBDI::rword start_addr, QBDI::rword stop_addr, run_options options = {});

  std::unique_ptr<QBDI::VM> create_sub_vm();

  gadget_result run_with_vm(QBDI::VM* vm, QBDI::rword start_addr, QBDI::rword stop_addr);

private:
  struct stack_guard {
    uint8_t* stack = nullptr;

    stack_guard() = default;
    stack_guard(const stack_guard&) = delete;
    stack_guard& operator=(const stack_guard&) = delete;
    ~stack_guard();

    bool allocate(QBDI::GPRState* gpr, size_t stack_size);
  };

  struct stop_state {
    QBDI::rword stop_addr = 0;
    size_t max_instructions = 0;
    size_t instruction_count = 0;
    QBDI::rword stop_pc = 0;
  };

  void setup_debug_callback(QBDI::VM* vm);
  bool configure_instrumentation(
      QBDI::VM* vm, instrumentation_scope scope, QBDI::rword start_addr, QBDI::rword stop_addr, size_t range_size,
      std::string* error
  );
  bool prepare_vm_state(QBDI::VM* vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, size_t stack_size, stack_guard& stack);
  bool install_stop_callback(QBDI::VM* vm, stop_state& state);
  bool execute_call(
      QBDI::rword addr, std::span<const QBDI::rword> args, const call_options& options, QBDI::rword* result,
      std::string* error
  );

  instrumentation_scope resolve_scope(instrumentation_scope requested, instrumentation_scope fallback) const;
  size_t resolve_stack_size(size_t requested) const;
  size_t resolve_range_size(size_t requested, size_t fallback) const;
  size_t resolve_max_instructions(size_t requested) const;

  QBDI::VM* parent_vm_ = nullptr;
  config config_{};
};

template <typename RetType>
RetType gadget_executor::gadget_call(QBDI::rword addr, std::span<const QBDI::rword> args, call_options options) {
  auto log = redlog::get_logger("w1.gadget.executor");
  QBDI::rword result = 0;
  std::string error;
  bool success = execute_call(addr, args, options, &result, &error);

  if (!success) {
    log.err("gadget call failed", redlog::field("addr", "0x%llx", addr), redlog::field("error", error));
    if constexpr (std::is_same_v<RetType, void>) {
      return;
    } else {
      return RetType{};
    }
  }

  log.dbg("gadget call succeeded", redlog::field("addr", "0x%llx", addr));
  if constexpr (std::is_same_v<RetType, void>) {
    return;
  } else {
    return static_cast<RetType>(result);
  }
}

template <typename RetType>
RetType gadget_executor::gadget_call(QBDI::rword addr, std::initializer_list<QBDI::rword> args, call_options options) {
  return gadget_call<RetType>(addr, std::span<const QBDI::rword>(args.begin(), args.size()), options);
}

} // namespace w1::gadget

```

`src/w1h00k/CMakeLists.txt`:

```txt
w1_add_static_library(w1h00k_reloc
    reloc/relocator.cpp
    reloc/x86.cpp
    reloc/arm64.cpp
)
target_link_libraries(w1h00k_reloc PUBLIC w1asmr)

w1_add_static_library(w1h00k_os
    os/os.cpp
)

set(W1H00K_RESOLVE_SOURCES "")
if(WIN32)
    list(APPEND W1H00K_RESOLVE_SOURCES resolve/windows.cpp)
else()
    list(APPEND W1H00K_RESOLVE_SOURCES resolve/posix.cpp)
endif()

w1_add_static_library(w1h00k_resolve ${W1H00K_RESOLVE_SOURCES})

set(W1H00K_MEMORY_SOURCES "")
if(WIN32)
    list(APPEND W1H00K_MEMORY_SOURCES memory/windows.cpp)
else()
    list(APPEND W1H00K_MEMORY_SOURCES memory/posix.cpp)
endif()

w1_add_static_library(w1h00k_memory ${W1H00K_MEMORY_SOURCES})

set(W1H00K_PATCHER_SOURCES "")
if(WIN32)
    list(APPEND W1H00K_PATCHER_SOURCES patcher/windows.cpp)
else()
    list(APPEND W1H00K_PATCHER_SOURCES patcher/posix.cpp)
endif()

w1_add_static_library(w1h00k_patcher ${W1H00K_PATCHER_SOURCES})

w1_add_static_library(w1h00k_backend
    backend/registry.cpp
    backend/inline/inline_backend.cpp
    backend/inline/inline_detour.cpp
    backend/inline/inline_instrumentation.cpp
    backend/interpose/interpose_backend.cpp
    backend/import_table/import_table_backend.cpp
)

w1_add_static_library(w1h00k_core
    core/hook_manager.cpp
    core/hook_transaction.cpp
)

w1_add_static_library(w1h00k
    hook.cpp
    errors.cpp
)
add_library(w1::h00k ALIAS w1h00k)

target_link_libraries(w1h00k_backend
    PUBLIC
        w1h00k_reloc
        w1h00k_resolve
        w1h00k_memory
        w1h00k_patcher
)

target_link_libraries(w1h00k_resolve
    PUBLIC
        w1h00k_os
)

target_link_libraries(w1h00k_core
    PUBLIC
        w1h00k_backend
)

target_link_libraries(w1h00k
    PUBLIC
        w1h00k_core
        w1base
)

```

`src/w1h00k/backend/backend.hpp`:

```hpp
#pragma once

#include <vector>

#include "w1h00k/hook.hpp"

namespace w1::h00k::backend {

struct patch_entry {
  void* target = nullptr;
  std::vector<uint8_t> patch_bytes{};
  std::vector<uint8_t> restore_bytes{};
};

struct hook_plan {
  hook_request request{};
  void* resolved_target = nullptr;
  std::vector<uint8_t> patch_bytes{};
  std::vector<uint8_t> restore_bytes{};
  std::vector<patch_entry> patches{};
  void* trampoline = nullptr;
  size_t trampoline_size = 0;
};

struct prepare_result {
  hook_plan plan{};
  hook_error_info error{};
};

class hook_backend {
public:
  virtual ~hook_backend() = default;
  virtual hook_technique technique() const = 0;
  virtual bool supports(const hook_request& request) const = 0;
  virtual prepare_result prepare(const hook_request& request, void* resolved_target) = 0;
  virtual hook_error commit(const hook_plan& plan) = 0;
  virtual hook_error revert(const hook_plan& plan) = 0;
};

} // namespace w1::h00k::backend

```

`src/w1h00k/backend/import_table/import_table_backend.cpp`:

```cpp
#include "w1h00k/backend/import_table/import_table_backend.hpp"

#include <cstring>

#include "w1h00k/backend/pointer_auth.hpp"
#include "w1h00k/patcher/patcher.hpp"
#include "w1h00k/resolve/resolve.hpp"

namespace w1::h00k::backend {
namespace {

hook_technique backend_technique() {
#if defined(_WIN32)
  return hook_technique::iat;
#else
  return hook_technique::plt_got;
#endif
}

} // namespace

class import_table_backend final : public hook_backend {
public:
  hook_technique technique() const override { return backend_technique(); }

  bool supports(const hook_request& request) const override {
    if (request.kind == hook_kind::instrument || request.prehook != nullptr) {
      return false;
    }
    if (request.replacement == nullptr) {
      return false;
    }
    return request.target.kind == hook_target_kind::import_slot;
  }

  prepare_result prepare(const hook_request& request, void* resolved_target) override {
    prepare_result result{};
    if (!supports(request)) {
      result.error.code = hook_error::unsupported;
      return result;
    }
    if (!resolved_target) {
      result.error.code = hook_error::not_found;
      return result;
    }

    auto* slot = reinterpret_cast<void**>(resolved_target);
    void* original = *slot;
    void* replacement = sign_replacement_pointer(request.replacement, slot);

    std::vector<uint8_t> patch_bytes(sizeof(void*));
    std::memcpy(patch_bytes.data(), &replacement, sizeof(void*));

    std::vector<uint8_t> restore_bytes(sizeof(void*));
    std::memcpy(restore_bytes.data(), &original, sizeof(void*));

    result.plan.request = request;
    result.plan.resolved_target = resolved_target;
    result.plan.patch_bytes = std::move(patch_bytes);
    result.plan.restore_bytes = std::move(restore_bytes);
    result.plan.trampoline = sanitize_original_pointer(original);
    result.error.code = hook_error::ok;
    return result;
  }

  hook_error commit(const hook_plan& plan) override {
    if (!plan.resolved_target || plan.patch_bytes.empty()) {
      return hook_error::invalid_target;
    }
    data_patcher patcher;
    if (!patcher.write(plan.resolved_target, plan.patch_bytes.data(), plan.patch_bytes.size())) {
      return hook_error::patch_failed;
    }
    return hook_error::ok;
  }

  hook_error revert(const hook_plan& plan) override {
    if (!plan.resolved_target || plan.restore_bytes.empty()) {
      return hook_error::invalid_target;
    }
    data_patcher patcher;
    if (!patcher.restore(plan.resolved_target, plan.restore_bytes.data(), plan.restore_bytes.size())) {
      return hook_error::patch_failed;
    }
    return hook_error::ok;
  }
};

std::unique_ptr<hook_backend> make_import_table_backend() {
  return std::make_unique<import_table_backend>();
}

} // namespace w1::h00k::backend

```

`src/w1h00k/backend/import_table/import_table_backend.hpp`:

```hpp
#pragma once

#include <memory>

#include "w1h00k/backend/backend.hpp"

namespace w1::h00k::backend {

std::unique_ptr<hook_backend> make_import_table_backend();

} // namespace w1::h00k::backend

```

`src/w1h00k/backend/inline/inline_backend.cpp`:

```cpp
#include "w1h00k/backend/inline/inline_backend.hpp"

#include <cstring>

#include "w1base/arch_spec.hpp"
#include "w1h00k/backend/inline/inline_detour.hpp"
#include "w1h00k/backend/inline/inline_instrumentation.hpp"
#include "w1h00k/memory/memory.hpp"
#include "w1h00k/patcher/patcher.hpp"
#include "w1h00k/reloc/relocator.hpp"

#ifndef __has_feature
#define __has_feature(x) 0
#endif

#if defined(__APPLE__) && __has_feature(ptrauth_calls)
#include <ptrauth.h>
#endif

namespace w1::h00k::backend {

class inline_trampoline_backend final : public hook_backend {
public:
  hook_technique technique() const override { return hook_technique::inline_trampoline; }

  bool supports(const hook_request& request) const override {
    const bool wants_instrument = request.kind == hook_kind::instrument || request.prehook != nullptr;
    if (wants_instrument) {
      if (request.kind != hook_kind::instrument) {
        return false;
      }
      if (request.prehook == nullptr || request.replacement != nullptr) {
        return false;
      }
      if (request.target.kind != hook_target_kind::address && request.target.kind != hook_target_kind::symbol) {
        return false;
      }
      const auto arch = w1::arch::detect_host_arch_spec();
      const auto abi = instrument::resolve_call_abi(request.call_abi, arch);
      return instrument::abi_supported(abi, arch);
    }

    if (request.replacement == nullptr) {
      return false;
    }
    return request.target.kind == hook_target_kind::address || request.target.kind == hook_target_kind::symbol;
  }

  prepare_result prepare(const hook_request& request, void* resolved_target) override {
    prepare_result result{};
    auto set_error = [&](hook_error code, const char* detail = nullptr) {
      result.error.code = code;
      result.error.detail = detail;
    };

    if (!supports(request)) {
      set_error(hook_error::unsupported);
      return result;
    }
    if (resolved_target == nullptr) {
      set_error(hook_error::not_found);
      return result;
    }

    const auto arch = w1::arch::detect_host_arch_spec();
    const bool wants_instrument = request.kind == hook_kind::instrument;
    if (wants_instrument) {
      const auto abi = instrument::resolve_call_abi(request.call_abi, arch);
      if (!instrument::abi_supported(abi, arch)) {
        set_error(hook_error::unsupported);
        return result;
      }

      size_t max_patch = 0;
      size_t min_patch = 0;
      switch (arch.arch_mode) {
        case w1::arch::mode::x86_32:
          max_patch = 5;
          min_patch = 5;
          break;
        case w1::arch::mode::x86_64:
          max_patch = 14;
          min_patch = 5;
          break;
        case w1::arch::mode::aarch64:
          max_patch = 16;
          min_patch = 16;
          break;
        default:
          set_error(hook_error::unsupported);
          return result;
      }

      const size_t reloc_size = reloc::max_trampoline_size(max_patch, arch);
      if (reloc_size == 0) {
        set_error(hook_error::unsupported);
        return result;
      }

      const size_t stub_reserve = instrument::stub_reserve_size(arch, abi);
      const size_t alloc_size = reloc_size + stub_reserve;
      auto block = memory::allocate_trampoline(resolved_target, alloc_size, arch);
      if (!block.ok()) {
        set_error(hook_error::near_alloc_failed);
        return result;
      }

      auto reloc_result =
          reloc::relocate(resolved_target, min_patch, reinterpret_cast<uint64_t>(block.address), arch);
      if (!reloc_result.ok()) {
        memory::free_executable(block);
        set_error(hook_error::relocation_failed, reloc::to_string(reloc_result.error));
        return result;
      }

      auto plan_hint = inline_hook::plan_for(arch, reinterpret_cast<uint64_t>(resolved_target),
                                             reinterpret_cast<uint64_t>(resolved_target));
      if (plan_hint.arch == inline_hook::arch_kind::unknown || plan_hint.tail_size == 0) {
        memory::free_executable(block);
        set_error(hook_error::unsupported);
        return result;
      }

      uint64_t stub_addr =
          reinterpret_cast<uint64_t>(block.address) + reloc_result.trampoline_bytes.size() + plan_hint.tail_size;
      auto plan = inline_hook::plan_for(arch, reinterpret_cast<uint64_t>(resolved_target), stub_addr);
      if (plan.arch == inline_hook::arch_kind::unknown || plan.min_patch == 0 || plan.tail_size == 0) {
        memory::free_executable(block);
        set_error(hook_error::unsupported);
        return result;
      }

      if (plan.min_patch > reloc_result.patch_size) {
        reloc_result =
            reloc::relocate(resolved_target, plan.min_patch, reinterpret_cast<uint64_t>(block.address), arch);
        if (!reloc_result.ok()) {
          memory::free_executable(block);
          set_error(hook_error::relocation_failed, reloc::to_string(reloc_result.error));
          return result;
        }
        stub_addr =
            reinterpret_cast<uint64_t>(block.address) + reloc_result.trampoline_bytes.size() + plan.tail_size;
        plan = inline_hook::plan_for(arch, reinterpret_cast<uint64_t>(resolved_target), stub_addr);
        if (plan.arch == inline_hook::arch_kind::unknown || plan.min_patch == 0 || plan.tail_size == 0 ||
            plan.min_patch > reloc_result.patch_size) {
          memory::free_executable(block);
          set_error(hook_error::unsupported);
          return result;
        }
      }

      auto* original_bytes = reinterpret_cast<const uint8_t*>(resolved_target);
      if (!inline_hook::prologue_safe(plan, original_bytes, reloc_result.patch_size)) {
        memory::free_executable(block);
        set_error(hook_error::relocation_failed);
        return result;
      }

      const uint64_t resume_addr = reinterpret_cast<uint64_t>(resolved_target) + reloc_result.patch_size;
      std::vector<uint8_t> trampoline_bytes = std::move(reloc_result.trampoline_bytes);
      const uint64_t tramp_end = reinterpret_cast<uint64_t>(block.address) + trampoline_bytes.size();
      if (!inline_hook::append_trampoline_tail(plan, tramp_end, resume_addr, trampoline_bytes)) {
        memory::free_executable(block);
        set_error(hook_error::relocation_failed);
        return result;
      }

      stub_addr = reinterpret_cast<uint64_t>(block.address) + trampoline_bytes.size();

      code_patcher patcher;
      if (!patcher.write(block.address, trampoline_bytes.data(), trampoline_bytes.size())) {
        memory::free_executable(block);
        set_error(hook_error::patch_failed);
        return result;
      }

      bool layout_ok = false;
      const auto layout = instrument::make_layout(arch, abi, layout_ok);
      if (!layout_ok) {
        memory::free_executable(block);
        set_error(hook_error::unsupported);
        return result;
      }

      instrument::stub_request stub_req{};
      stub_req.arch = arch;
      stub_req.abi = abi;
      stub_req.target = reinterpret_cast<uint64_t>(resolved_target);
      stub_req.trampoline = reinterpret_cast<uint64_t>(block.address);
      stub_req.replacement = reinterpret_cast<uint64_t>(request.replacement);
#if defined(__APPLE__) && __has_feature(ptrauth_calls)
      auto stripped = ptrauth_strip(request.prehook, ptrauth_key_function_pointer);
      stub_req.prehook = reinterpret_cast<uint64_t>(stripped);
#else
      stub_req.prehook = reinterpret_cast<uint64_t>(request.prehook);
#endif
      stub_req.user_data = reinterpret_cast<uint64_t>(request.user_data);
      stub_req.stub_address = stub_addr;

      std::vector<uint8_t> stub_bytes;
      if (!instrument::build_stub(stub_req, layout, stub_bytes)) {
        memory::free_executable(block);
        set_error(hook_error::unsupported);
        return result;
      }

      if (trampoline_bytes.size() + stub_bytes.size() > block.size) {
        memory::free_executable(block);
        set_error(hook_error::patch_failed);
        return result;
      }

      if (!patcher.write(reinterpret_cast<void*>(stub_addr), stub_bytes.data(), stub_bytes.size())) {
        memory::free_executable(block);
        set_error(hook_error::patch_failed);
        return result;
      }

      std::vector<uint8_t> patch_bytes;
      if (!inline_hook::build_detour_patch(plan, reinterpret_cast<uint64_t>(resolved_target), stub_addr,
                                           reloc_result.patch_size, patch_bytes)) {
        memory::free_executable(block);
        set_error(hook_error::patch_failed);
        return result;
      }

      std::vector<uint8_t> restore_bytes(reloc_result.patch_size);
      std::memcpy(restore_bytes.data(), resolved_target, restore_bytes.size());

      result.plan.request = request;
      result.plan.resolved_target = resolved_target;
      result.plan.patch_bytes = std::move(patch_bytes);
      result.plan.restore_bytes = std::move(restore_bytes);
      result.plan.trampoline = block.address;
      result.plan.trampoline_size = block.size;
      set_error(hook_error::ok);
      return result;
    }

    const auto plan = inline_hook::plan_for(arch, reinterpret_cast<uint64_t>(resolved_target),
                                            reinterpret_cast<uint64_t>(request.replacement));
    if (plan.arch == inline_hook::arch_kind::unknown || plan.min_patch == 0 || plan.tail_size == 0) {
      set_error(hook_error::unsupported);
      return result;
    }

    const size_t reloc_size = reloc::max_trampoline_size(plan.min_patch, arch);
    if (reloc_size == 0) {
      set_error(hook_error::unsupported);
      return result;
    }

    const size_t alloc_size = reloc_size + plan.tail_size;
    auto block = memory::allocate_trampoline(resolved_target, alloc_size, arch);
    if (!block.ok()) {
      set_error(hook_error::near_alloc_failed);
      return result;
    }

    auto reloc_result = reloc::relocate(resolved_target, plan.min_patch, reinterpret_cast<uint64_t>(block.address),
                                        arch);
    if (!reloc_result.ok()) {
      memory::free_executable(block);
      set_error(hook_error::relocation_failed, reloc::to_string(reloc_result.error));
      return result;
    }

    auto* original_bytes = reinterpret_cast<const uint8_t*>(resolved_target);
    if (!inline_hook::prologue_safe(plan, original_bytes, reloc_result.patch_size)) {
      memory::free_executable(block);
      set_error(hook_error::relocation_failed);
      return result;
    }

    const uint64_t resume_addr = reinterpret_cast<uint64_t>(resolved_target) + reloc_result.patch_size;
    std::vector<uint8_t> trampoline_bytes = std::move(reloc_result.trampoline_bytes);
    const uint64_t tramp_end = reinterpret_cast<uint64_t>(block.address) + trampoline_bytes.size();
    if (!inline_hook::append_trampoline_tail(plan, tramp_end, resume_addr, trampoline_bytes)) {
      memory::free_executable(block);
      set_error(hook_error::relocation_failed);
      return result;
    }

    code_patcher patcher;
    if (!patcher.write(block.address, trampoline_bytes.data(), trampoline_bytes.size())) {
      memory::free_executable(block);
      set_error(hook_error::patch_failed);
      return result;
    }

    std::vector<uint8_t> patch_bytes;
    if (!inline_hook::build_detour_patch(plan, reinterpret_cast<uint64_t>(resolved_target),
                                         reinterpret_cast<uint64_t>(request.replacement), reloc_result.patch_size,
                                         patch_bytes)) {
      memory::free_executable(block);
      set_error(hook_error::patch_failed);
      return result;
    }

    std::vector<uint8_t> restore_bytes(reloc_result.patch_size);
    std::memcpy(restore_bytes.data(), resolved_target, restore_bytes.size());

    result.plan.request = request;
    result.plan.resolved_target = resolved_target;
    result.plan.patch_bytes = std::move(patch_bytes);
    result.plan.restore_bytes = std::move(restore_bytes);
    result.plan.trampoline = block.address;
    result.plan.trampoline_size = block.size;
    set_error(hook_error::ok);
    return result;
  }

  hook_error commit(const hook_plan& plan) override {
    if (!plan.resolved_target || plan.patch_bytes.empty()) {
      return hook_error::invalid_target;
    }
    code_patcher patcher;
    if (!patcher.write(plan.resolved_target, plan.patch_bytes.data(), plan.patch_bytes.size())) {
      return hook_error::patch_failed;
    }
    return hook_error::ok;
  }

  hook_error revert(const hook_plan& plan) override {
    if (!plan.resolved_target || plan.restore_bytes.empty()) {
      return hook_error::invalid_target;
    }
    code_patcher patcher;
    if (!patcher.restore(plan.resolved_target, plan.restore_bytes.data(), plan.restore_bytes.size())) {
      return hook_error::patch_failed;
    }
    return hook_error::ok;
  }
};

std::unique_ptr<hook_backend> make_inline_trampoline_backend() {
  return std::make_unique<inline_trampoline_backend>();
}

} // namespace w1::h00k::backend

```

`src/w1h00k/backend/inline/inline_backend.hpp`:

```hpp
#pragma once

#include <memory>

#include "w1h00k/backend/backend.hpp"

namespace w1::h00k::backend {

std::unique_ptr<hook_backend> make_inline_trampoline_backend();

} // namespace w1::h00k::backend

```

`src/w1h00k/backend/inline/inline_detour.cpp`:

```cpp
#include "w1h00k/backend/inline/inline_detour.hpp"

#include <cstring>

#include "w1h00k/reloc/common.hpp"

namespace w1::h00k::backend::inline_hook {
namespace {

arch_kind classify_arch(const w1::arch::arch_spec& spec) {
  switch (spec.arch_mode) {
    case w1::arch::mode::x86_32:
      return arch_kind::x86_32;
    case w1::arch::mode::x86_64:
      return arch_kind::x86_64;
    case w1::arch::mode::aarch64:
      return arch_kind::arm64;
    default:
      return arch_kind::unknown;
  }
}

void append_u32(std::vector<uint8_t>& out, uint32_t value) {
  const size_t offset = out.size();
  out.resize(offset + sizeof(value));
  std::memcpy(out.data() + offset, &value, sizeof(value));
}

void append_u64(std::vector<uint8_t>& out, uint64_t value) {
  const size_t offset = out.size();
  out.resize(offset + sizeof(value));
  std::memcpy(out.data() + offset, &value, sizeof(value));
}

uint32_t arm64_encode_ldr_literal(uint8_t rt, int32_t imm19) {
  return 0x58000000u | ((static_cast<uint32_t>(imm19) & 0x7FFFFu) << 5) | (rt & 0x1Fu);
}

uint32_t arm64_encode_br(uint8_t rn) { return 0xD61F0000u | ((rn & 0x1Fu) << 5); }

bool emit_x86_rel32_jump(std::vector<uint8_t>& out, uint64_t from, uint64_t to) {
  const int64_t disp = static_cast<int64_t>(to) - static_cast<int64_t>(from + 5);
  if (!reloc::detail::fits_signed(disp, 32)) {
    return false;
  }
  out.push_back(0xE9);
  const int32_t imm = static_cast<int32_t>(disp);
  append_u32(out, static_cast<uint32_t>(imm));
  return true;
}

void emit_x86_abs_jump(std::vector<uint8_t>& out, uint64_t to) {
  out.push_back(0xFF);
  out.push_back(0x25);
  out.insert(out.end(), {0x00, 0x00, 0x00, 0x00});
  append_u64(out, to);
}

void emit_arm64_abs_jump(std::vector<uint8_t>& out, uint64_t to) {
  constexpr uint8_t scratch = 16;
  constexpr int32_t imm19 = 2;
  append_u32(out, arm64_encode_ldr_literal(scratch, imm19));
  append_u32(out, arm64_encode_br(scratch));
  append_u64(out, to);
}

std::vector<uint8_t> nop_bytes_for_arch(arch_kind kind) {
  switch (kind) {
    case arch_kind::arm64:
      return {0x1F, 0x20, 0x03, 0xD5};
    case arch_kind::x86_32:
    case arch_kind::x86_64:
      return {0x90};
    default:
      return {};
  }
}

bool arm64_patch_crosses_return(const uint8_t* bytes, size_t size) {
  if (!bytes || size < 4) {
    return false;
  }
  const uint32_t ret_inst = 0xD65F03C0u;
  const uint32_t nop_inst = 0xD503201Fu;
  for (size_t offset = 0; offset + 4 <= size; offset += 4) {
    uint32_t inst = 0;
    std::memcpy(&inst, bytes + offset, sizeof(inst));
    if (inst != ret_inst) {
      continue;
    }
    for (size_t tail = offset + 4; tail + 4 <= size; tail += 4) {
      uint32_t tail_inst = 0;
      std::memcpy(&tail_inst, bytes + tail, sizeof(tail_inst));
      if (tail_inst != nop_inst) {
        return true;
      }
    }
    break;
  }
  return false;
}

} // namespace

detour_plan plan_for(const w1::arch::arch_spec& spec, uint64_t from, uint64_t to) {
  detour_plan plan{};
  plan.arch = classify_arch(spec);
  switch (plan.arch) {
    case arch_kind::x86_32:
      plan.kind = detour_kind::rel32;
      plan.min_patch = 5;
      plan.tail_size = 5;
      break;
    case arch_kind::x86_64: {
      const int64_t disp = static_cast<int64_t>(to) - static_cast<int64_t>(from + 5);
      if (reloc::detail::fits_signed(disp, 32)) {
        plan.kind = detour_kind::rel32;
        plan.min_patch = 5;
      } else {
        plan.kind = detour_kind::absolute;
        plan.min_patch = 14;
      }
      plan.tail_size = 14;
      break;
    }
    case arch_kind::arm64:
      plan.kind = detour_kind::absolute;
      plan.min_patch = 16;
      plan.tail_size = 16;
      break;
    default:
      break;
  }
  return plan;
}

bool build_detour_patch(const detour_plan& plan, uint64_t from, uint64_t to, size_t patch_size,
                        std::vector<uint8_t>& out) {
  out.clear();
  switch (plan.arch) {
    case arch_kind::x86_32:
      if (!emit_x86_rel32_jump(out, from, to)) {
        return false;
      }
      break;
    case arch_kind::x86_64:
      if (plan.kind == detour_kind::rel32) {
        if (!emit_x86_rel32_jump(out, from, to)) {
          return false;
        }
      } else {
        emit_x86_abs_jump(out, to);
      }
      break;
    case arch_kind::arm64:
      emit_arm64_abs_jump(out, to);
      break;
    default:
      return false;
  }

  if (out.size() > patch_size) {
    return false;
  }

  auto nops = nop_bytes_for_arch(plan.arch);
  while (out.size() < patch_size) {
    out.insert(out.end(), nops.begin(), nops.end());
  }
  return true;
}

bool append_trampoline_tail(const detour_plan& plan, uint64_t tramp_end, uint64_t resume_addr,
                            std::vector<uint8_t>& out) {
  switch (plan.arch) {
    case arch_kind::x86_32:
      return emit_x86_rel32_jump(out, tramp_end, resume_addr);
    case arch_kind::x86_64:
      emit_x86_abs_jump(out, resume_addr);
      return true;
    case arch_kind::arm64:
      emit_arm64_abs_jump(out, resume_addr);
      return true;
    default:
      return false;
  }
}

bool prologue_safe(const detour_plan& plan, const uint8_t* bytes, size_t size) {
  if (plan.arch == arch_kind::arm64) {
    return !arm64_patch_crosses_return(bytes, size);
  }
  return true;
}

} // namespace w1::h00k::backend::inline_hook

```

`src/w1h00k/backend/inline/inline_detour.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <vector>

#include "w1base/arch_spec.hpp"

namespace w1::h00k::backend::inline_hook {

enum class arch_kind {
  x86_32,
  x86_64,
  arm64,
  unknown
};

enum class detour_kind {
  rel32,
  absolute
};

struct detour_plan {
  arch_kind arch = arch_kind::unknown;
  detour_kind kind = detour_kind::absolute;
  size_t min_patch = 0;
  size_t tail_size = 0;
};

detour_plan plan_for(const w1::arch::arch_spec& spec, uint64_t from, uint64_t to);
bool build_detour_patch(const detour_plan& plan, uint64_t from, uint64_t to, size_t patch_size,
                        std::vector<uint8_t>& out);
bool append_trampoline_tail(const detour_plan& plan, uint64_t tramp_end, uint64_t resume_addr,
                            std::vector<uint8_t>& out);
bool prologue_safe(const detour_plan& plan, const uint8_t* bytes, size_t size);

} // namespace w1::h00k::backend::inline_hook

```

`src/w1h00k/backend/inline/inline_instrumentation.cpp`:

```cpp
#include "w1h00k/backend/inline/inline_instrumentation.hpp"

#include <array>
#include <sstream>
#include <string>

#include "w1asmr/asmr.hpp"
#include "w1h00k/core/hook_args.hpp"

namespace w1::h00k::backend::instrument {
namespace {

struct abi_plan {
  const char* const* gpr = nullptr;
  size_t gpr_count = 0;
  const char* const* fpr = nullptr;
  size_t fpr_count = 0;
  size_t gpr_size = 0;
  size_t fpr_size = 0;
  size_t shadow_size = 0;
  size_t stack_align = 16;
  const char* arg_reg = nullptr;
};

constexpr std::array<const char*, 9> kSysvGpr = {
    "rdi", "rsi", "rdx", "rcx", "r8", "r9", "rax", "r10", "r11"};
constexpr std::array<const char*, 8> kSysvFpr = {
    "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6", "xmm7"};
constexpr std::array<const char*, 7> kWin64Gpr = {"rcx", "rdx", "r8", "r9", "rax", "r10", "r11"};
constexpr std::array<const char*, 4> kWin64Fpr = {"xmm0", "xmm1", "xmm2", "xmm3"};
constexpr std::array<const char*, 6> kWin64FprVector = {"xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5"};
constexpr std::array<const char*, 3> kX86Gpr = {"ecx", "edx", "eax"};
constexpr std::array<const char*, 20> kArm64Gpr = {
    "x0",  "x1",  "x2",  "x3",  "x4",  "x5",  "x6",  "x7",  "x8",  "x9",
    "x10", "x11", "x12", "x13", "x14", "x15", "x16", "x17", "x18", "x30"};
constexpr std::array<const char*, 8> kArm64Fpr = {"q0", "q1", "q2", "q3", "q4", "q5", "q6", "q7"};

size_t align_up(size_t value, size_t alignment) {
  if (alignment == 0) {
    return value;
  }
  const size_t mask = alignment - 1;
  return (value + mask) & ~mask;
}

std::string hex(uint64_t value) {
  std::ostringstream oss;
  oss << "0x" << std::hex << value;
  return oss.str();
}

void append_mov_imm64(std::ostringstream& oss, const char* reg, uint64_t value) {
  const uint16_t part0 = static_cast<uint16_t>(value & 0xFFFFu);
  const uint16_t part1 = static_cast<uint16_t>((value >> 16) & 0xFFFFu);
  const uint16_t part2 = static_cast<uint16_t>((value >> 32) & 0xFFFFu);
  const uint16_t part3 = static_cast<uint16_t>((value >> 48) & 0xFFFFu);
  oss << "movz " << reg << ", #" << hex(part0) << "\n";
  oss << "movk " << reg << ", #" << hex(part1) << ", lsl #16\n";
  oss << "movk " << reg << ", #" << hex(part2) << ", lsl #32\n";
  oss << "movk " << reg << ", #" << hex(part3) << ", lsl #48\n";
}

abi_plan plan_for(const w1::arch::arch_spec& arch, hook_call_abi abi, bool& ok) {
  ok = true;
  abi_plan plan{};
  switch (arch.arch_mode) {
    case w1::arch::mode::x86_64:
      plan.gpr_size = 8;
      plan.fpr_size = 16;
      if (abi == hook_call_abi::win64 || abi == hook_call_abi::win64_vectorcall) {
        plan.gpr = kWin64Gpr.data();
        plan.gpr_count = kWin64Gpr.size();
        if (abi == hook_call_abi::win64_vectorcall) {
          plan.fpr = kWin64FprVector.data();
          plan.fpr_count = kWin64FprVector.size();
        } else {
          plan.fpr = kWin64Fpr.data();
          plan.fpr_count = kWin64Fpr.size();
        }
        plan.shadow_size = 32;
        plan.arg_reg = "rcx";
      } else if (abi == hook_call_abi::sysv) {
        plan.gpr = kSysvGpr.data();
        plan.gpr_count = kSysvGpr.size();
        plan.fpr = kSysvFpr.data();
        plan.fpr_count = kSysvFpr.size();
        plan.arg_reg = "rdi";
      } else {
        ok = false;
      }
      return plan;
    case w1::arch::mode::x86_32:
      if (abi != hook_call_abi::sysv && abi != hook_call_abi::win32_cdecl && abi != hook_call_abi::win32_stdcall &&
          abi != hook_call_abi::win32_fastcall && abi != hook_call_abi::win32_thiscall) {
        ok = false;
        return plan;
      }
      plan.gpr = kX86Gpr.data();
      plan.gpr_count = kX86Gpr.size();
      plan.gpr_size = 4;
      plan.fpr_size = 16;
      return plan;
    case w1::arch::mode::aarch64:
      if (abi != hook_call_abi::aapcs64) {
        ok = false;
        return plan;
      }
      plan.gpr = kArm64Gpr.data();
      plan.gpr_count = kArm64Gpr.size();
      plan.gpr_size = 8;
      plan.fpr = kArm64Fpr.data();
      plan.fpr_count = kArm64Fpr.size();
      plan.fpr_size = 16;
      plan.arg_reg = "x0";
      return plan;
    default:
      ok = false;
      return plan;
  }
}

bool assemble_stub(const w1::arch::arch_spec& arch,
                   const std::string& text,
                   uint64_t address,
                   std::vector<uint8_t>& out) {
  auto ctx = w1::asmr::asm_context::for_arch(arch);
  if (!ctx.ok()) {
    return false;
  }
  auto bytes = ctx.value.assemble(text, address);
  if (!bytes.ok()) {
    return false;
  }
  out = std::move(bytes.value);
  return true;
}

bool build_x86_64_stub(const stub_request& request, const stub_layout& layout, const abi_plan& plan,
                       std::vector<uint8_t>& out) {
  const size_t args_abi_off = offsetof(hook_arg_handle, abi);
  const size_t args_reserved_off = offsetof(hook_arg_handle, reserved);
  const size_t args_int_off = offsetof(hook_arg_handle, int_regs);
  const size_t args_flt_off = offsetof(hook_arg_handle, flt_regs);
  const size_t args_stack_off = offsetof(hook_arg_handle, stack);

  const size_t info_original_off = offsetof(hook_info, original_target);
  const size_t info_target_off = offsetof(hook_info, target);
  const size_t info_trampoline_off = offsetof(hook_info, trampoline);
  const size_t info_replacement_off = offsetof(hook_info, replacement);
  const size_t info_user_data_off = offsetof(hook_info, user_data);
  const size_t info_args_off = offsetof(hook_info, args);

  std::ostringstream oss;
  oss << "sub rsp, " << layout.stack_size << "\n";
  for (size_t i = 0; i < plan.gpr_count; ++i) {
    oss << "mov qword ptr [rsp + " << (layout.gpr_offset + i * plan.gpr_size) << "], " << plan.gpr[i] << "\n";
  }
  for (size_t i = 0; i < plan.fpr_count; ++i) {
    oss << "movdqu [rsp + " << (layout.fpr_offset + i * plan.fpr_size) << "], " << plan.fpr[i] << "\n";
  }

  oss << "mov dword ptr [rsp + " << (layout.args_offset + args_abi_off) << "], "
      << static_cast<uint32_t>(request.abi) << "\n";
  oss << "mov dword ptr [rsp + " << (layout.args_offset + args_reserved_off) << "], 0\n";

  oss << "lea rax, [rsp + " << layout.gpr_offset << "]\n";
  oss << "mov qword ptr [rsp + " << (layout.args_offset + args_int_off) << "], rax\n";
  if (layout.fpr_count > 0) {
    oss << "lea rax, [rsp + " << layout.fpr_offset << "]\n";
  } else {
    oss << "xor rax, rax\n";
  }
  oss << "mov qword ptr [rsp + " << (layout.args_offset + args_flt_off) << "], rax\n";
  oss << "lea rax, [rsp + " << layout.stack_size << "]\n";
  oss << "mov qword ptr [rsp + " << (layout.args_offset + args_stack_off) << "], rax\n";

  oss << "lea rax, [rsp + " << layout.args_offset << "]\n";
  oss << "mov qword ptr [rsp + " << (layout.info_offset + info_args_off) << "], rax\n";
  oss << "mov rax, " << hex(request.target) << "\n";
  oss << "mov qword ptr [rsp + " << (layout.info_offset + info_original_off) << "], rax\n";
  oss << "mov qword ptr [rsp + " << (layout.info_offset + info_target_off) << "], rax\n";
  oss << "mov rax, " << hex(request.trampoline) << "\n";
  oss << "mov qword ptr [rsp + " << (layout.info_offset + info_trampoline_off) << "], rax\n";
  oss << "mov rax, " << hex(request.replacement) << "\n";
  oss << "mov qword ptr [rsp + " << (layout.info_offset + info_replacement_off) << "], rax\n";
  oss << "mov rax, " << hex(request.user_data) << "\n";
  oss << "mov qword ptr [rsp + " << (layout.info_offset + info_user_data_off) << "], rax\n";

  oss << "lea " << plan.arg_reg << ", [rsp + " << layout.info_offset << "]\n";
  oss << "mov rax, " << hex(request.prehook) << "\n";
  oss << "call rax\n";

  for (size_t i = 0; i < plan.fpr_count; ++i) {
    oss << "movdqu " << plan.fpr[i] << ", [rsp + " << (layout.fpr_offset + i * plan.fpr_size) << "]\n";
  }
  for (size_t i = 0; i < plan.gpr_count; ++i) {
    oss << "mov " << plan.gpr[i] << ", qword ptr [rsp + " << (layout.gpr_offset + i * plan.gpr_size) << "]\n";
  }

  oss << "add rsp, " << layout.stack_size << "\n";
  oss << "jmp " << hex(request.trampoline) << "\n";

  return assemble_stub(request.arch, oss.str(), request.stub_address, out);
}

bool build_x86_32_stub(const stub_request& request, const stub_layout& layout, const abi_plan& plan,
                       std::vector<uint8_t>& out) {
  const size_t args_abi_off = offsetof(hook_arg_handle, abi);
  const size_t args_reserved_off = offsetof(hook_arg_handle, reserved);
  const size_t args_int_off = offsetof(hook_arg_handle, int_regs);
  const size_t args_flt_off = offsetof(hook_arg_handle, flt_regs);
  const size_t args_stack_off = offsetof(hook_arg_handle, stack);

  const size_t info_original_off = offsetof(hook_info, original_target);
  const size_t info_target_off = offsetof(hook_info, target);
  const size_t info_trampoline_off = offsetof(hook_info, trampoline);
  const size_t info_replacement_off = offsetof(hook_info, replacement);
  const size_t info_user_data_off = offsetof(hook_info, user_data);
  const size_t info_args_off = offsetof(hook_info, args);

  std::ostringstream oss;
  oss << "sub esp, " << layout.stack_size << "\n";
  for (size_t i = 0; i < plan.gpr_count; ++i) {
    oss << "mov dword ptr [esp + " << (layout.gpr_offset + i * plan.gpr_size) << "], " << plan.gpr[i] << "\n";
  }

  oss << "mov dword ptr [esp + " << (layout.args_offset + args_abi_off) << "], "
      << static_cast<uint32_t>(request.abi) << "\n";
  oss << "mov dword ptr [esp + " << (layout.args_offset + args_reserved_off) << "], 0\n";

  oss << "lea eax, [esp + " << layout.gpr_offset << "]\n";
  oss << "mov dword ptr [esp + " << (layout.args_offset + args_int_off) << "], eax\n";
  oss << "xor eax, eax\n";
  oss << "mov dword ptr [esp + " << (layout.args_offset + args_flt_off) << "], eax\n";
  oss << "lea eax, [esp + " << layout.stack_size << "]\n";
  oss << "mov dword ptr [esp + " << (layout.args_offset + args_stack_off) << "], eax\n";

  oss << "lea eax, [esp + " << layout.args_offset << "]\n";
  oss << "mov dword ptr [esp + " << (layout.info_offset + info_args_off) << "], eax\n";
  oss << "mov eax, " << hex(static_cast<uint32_t>(request.target)) << "\n";
  oss << "mov dword ptr [esp + " << (layout.info_offset + info_original_off) << "], eax\n";
  oss << "mov dword ptr [esp + " << (layout.info_offset + info_target_off) << "], eax\n";
  oss << "mov eax, " << hex(static_cast<uint32_t>(request.trampoline)) << "\n";
  oss << "mov dword ptr [esp + " << (layout.info_offset + info_trampoline_off) << "], eax\n";
  oss << "mov eax, " << hex(static_cast<uint32_t>(request.replacement)) << "\n";
  oss << "mov dword ptr [esp + " << (layout.info_offset + info_replacement_off) << "], eax\n";
  oss << "mov eax, " << hex(static_cast<uint32_t>(request.user_data)) << "\n";
  oss << "mov dword ptr [esp + " << (layout.info_offset + info_user_data_off) << "], eax\n";

  oss << "lea eax, [esp + " << layout.info_offset << "]\n";
  oss << "push eax\n";
  oss << "mov eax, " << hex(static_cast<uint32_t>(request.prehook)) << "\n";
  oss << "call eax\n";
  oss << "add esp, 4\n";

  for (size_t i = 0; i < plan.gpr_count; ++i) {
    oss << "mov " << plan.gpr[i] << ", dword ptr [esp + " << (layout.gpr_offset + i * plan.gpr_size) << "]\n";
  }

  oss << "add esp, " << layout.stack_size << "\n";
  oss << "jmp " << hex(static_cast<uint32_t>(request.trampoline)) << "\n";

  return assemble_stub(request.arch, oss.str(), request.stub_address, out);
}

bool build_arm64_stub(const stub_request& request, const stub_layout& layout, const abi_plan& plan,
                      std::vector<uint8_t>& out) {
  const size_t args_abi_off = offsetof(hook_arg_handle, abi);
  const size_t args_reserved_off = offsetof(hook_arg_handle, reserved);
  const size_t args_int_off = offsetof(hook_arg_handle, int_regs);
  const size_t args_flt_off = offsetof(hook_arg_handle, flt_regs);
  const size_t args_stack_off = offsetof(hook_arg_handle, stack);

  const size_t info_original_off = offsetof(hook_info, original_target);
  const size_t info_target_off = offsetof(hook_info, target);
  const size_t info_trampoline_off = offsetof(hook_info, trampoline);
  const size_t info_replacement_off = offsetof(hook_info, replacement);
  const size_t info_user_data_off = offsetof(hook_info, user_data);
  const size_t info_args_off = offsetof(hook_info, args);

  std::ostringstream oss;
  oss << "sub sp, sp, #" << layout.stack_size << "\n";
  size_t gpr_offset = layout.gpr_offset;
  for (size_t i = 0; i + 1 < plan.gpr_count; i += 2) {
    oss << "stp " << plan.gpr[i] << ", " << plan.gpr[i + 1] << ", [sp, #" << gpr_offset << "]\n";
    gpr_offset += 16;
  }
  if ((plan.gpr_count % 2) != 0) {
    oss << "str " << plan.gpr[plan.gpr_count - 1] << ", [sp, #" << gpr_offset << "]\n";
  }

  size_t fpr_offset = layout.fpr_offset;
  for (size_t i = 0; i + 1 < plan.fpr_count; i += 2) {
    oss << "stp " << plan.fpr[i] << ", " << plan.fpr[i + 1] << ", [sp, #" << fpr_offset << "]\n";
    fpr_offset += 32;
  }
  if ((plan.fpr_count % 2) != 0) {
    oss << "str " << plan.fpr[plan.fpr_count - 1] << ", [sp, #" << fpr_offset << "]\n";
  }

  oss << "mov w16, #" << static_cast<uint32_t>(request.abi) << "\n";
  oss << "str w16, [sp, #" << (layout.args_offset + args_abi_off) << "]\n";
  oss << "mov w16, #0\n";
  oss << "str w16, [sp, #" << (layout.args_offset + args_reserved_off) << "]\n";
  oss << "add x16, sp, #" << layout.gpr_offset << "\n";
  oss << "str x16, [sp, #" << (layout.args_offset + args_int_off) << "]\n";
  if (layout.fpr_count > 0) {
    oss << "add x16, sp, #" << layout.fpr_offset << "\n";
  } else {
    oss << "mov x16, #0\n";
  }
  oss << "str x16, [sp, #" << (layout.args_offset + args_flt_off) << "]\n";
  oss << "add x16, sp, #" << layout.stack_size << "\n";
  oss << "str x16, [sp, #" << (layout.args_offset + args_stack_off) << "]\n";

  oss << "add x16, sp, #" << layout.args_offset << "\n";
  oss << "str x16, [sp, #" << (layout.info_offset + info_args_off) << "]\n";
  append_mov_imm64(oss, "x16", request.target);
  oss << "str x16, [sp, #" << (layout.info_offset + info_original_off) << "]\n";
  oss << "str x16, [sp, #" << (layout.info_offset + info_target_off) << "]\n";
  append_mov_imm64(oss, "x16", request.trampoline);
  oss << "str x16, [sp, #" << (layout.info_offset + info_trampoline_off) << "]\n";
  append_mov_imm64(oss, "x16", request.replacement);
  oss << "str x16, [sp, #" << (layout.info_offset + info_replacement_off) << "]\n";
  append_mov_imm64(oss, "x16", request.user_data);
  oss << "str x16, [sp, #" << (layout.info_offset + info_user_data_off) << "]\n";

  oss << "add x0, sp, #" << layout.info_offset << "\n";
  append_mov_imm64(oss, "x16", request.prehook);
  oss << "blr x16\n";

  fpr_offset = layout.fpr_offset;
  for (size_t i = 0; i + 1 < plan.fpr_count; i += 2) {
    oss << "ldp " << plan.fpr[i] << ", " << plan.fpr[i + 1] << ", [sp, #" << fpr_offset << "]\n";
    fpr_offset += 32;
  }
  if ((plan.fpr_count % 2) != 0) {
    oss << "ldr " << plan.fpr[plan.fpr_count - 1] << ", [sp, #" << fpr_offset << "]\n";
  }

  gpr_offset = layout.gpr_offset;
  for (size_t i = 0; i + 1 < plan.gpr_count; i += 2) {
    oss << "ldp " << plan.gpr[i] << ", " << plan.gpr[i + 1] << ", [sp, #" << gpr_offset << "]\n";
    gpr_offset += 16;
  }
  if ((plan.gpr_count % 2) != 0) {
    oss << "ldr " << plan.gpr[plan.gpr_count - 1] << ", [sp, #" << gpr_offset << "]\n";
  }

  oss << "add sp, sp, #" << layout.stack_size << "\n";
  oss << "b " << hex(request.trampoline) << "\n";

  return assemble_stub(request.arch, oss.str(), request.stub_address, out);
}

} // namespace

hook_call_abi resolve_call_abi(hook_call_abi requested, const w1::arch::arch_spec& arch) {
  if (requested != hook_call_abi::native) {
    return requested;
  }

  switch (arch.arch_mode) {
    case w1::arch::mode::aarch64:
      return hook_call_abi::aapcs64;
    case w1::arch::mode::x86_64:
#if defined(_WIN32)
      return hook_call_abi::win64;
#else
      return hook_call_abi::sysv;
#endif
    case w1::arch::mode::x86_32:
      return
#if defined(_WIN32)
          hook_call_abi::win32_cdecl;
#else
          hook_call_abi::sysv;
#endif
    default:
      return hook_call_abi::native;
  }
}

bool abi_supported(hook_call_abi abi, const w1::arch::arch_spec& arch) {
  switch (arch.arch_mode) {
    case w1::arch::mode::x86_64:
#if defined(_WIN32)
      return abi == hook_call_abi::win64 || abi == hook_call_abi::win64_vectorcall;
#else
      return abi == hook_call_abi::sysv;
#endif
    case w1::arch::mode::x86_32:
      return
#if defined(_WIN32)
          (abi == hook_call_abi::win32_cdecl || abi == hook_call_abi::win32_stdcall ||
           abi == hook_call_abi::win32_fastcall || abi == hook_call_abi::win32_thiscall);
#else
          abi == hook_call_abi::sysv;
#endif
    case w1::arch::mode::aarch64:
      return abi == hook_call_abi::aapcs64;
    default:
      return false;
  }
}

stub_layout make_layout(const w1::arch::arch_spec& arch, hook_call_abi abi, bool& ok) {
  abi_plan plan = plan_for(arch, abi, ok);
  stub_layout layout{};
  if (!ok) {
    return layout;
  }

  size_t offset = plan.shadow_size;
  if (plan.gpr_count > 0) {
    offset = align_up(offset, plan.gpr_size);
    layout.gpr_offset = offset;
    layout.gpr_count = plan.gpr_count;
    offset += plan.gpr_count * plan.gpr_size;
  }

  if (plan.fpr_count > 0) {
    offset = align_up(offset, plan.fpr_size);
    layout.fpr_offset = offset;
    layout.fpr_count = plan.fpr_count;
    offset += plan.fpr_count * plan.fpr_size;
  }

  offset = align_up(offset, alignof(hook_arg_handle));
  layout.args_offset = offset;
  offset += sizeof(hook_arg_handle);

  offset = align_up(offset, alignof(hook_info));
  layout.info_offset = offset;
  offset += sizeof(hook_info);

  layout.shadow_size = plan.shadow_size;
  layout.stack_size = align_up(offset, plan.stack_align);
  if (arch.arch_mode == w1::arch::mode::x86_64) {
    // Keep RSP 16-byte aligned before the prehook call (entry RSP is 8 mod 16).
    if ((layout.stack_size % 16) == 0) {
      layout.stack_size += 8;
    }
  }
  return layout;
}

size_t stub_reserve_size(const w1::arch::arch_spec& arch, hook_call_abi abi) {
  (void)arch;
  (void)abi;
  return 512;
}

bool build_stub(const stub_request& request, const stub_layout& layout, std::vector<uint8_t>& out) {
  bool ok = false;
  abi_plan plan = plan_for(request.arch, request.abi, ok);
  if (!ok) {
    return false;
  }

  switch (request.arch.arch_mode) {
    case w1::arch::mode::x86_64:
      return build_x86_64_stub(request, layout, plan, out);
    case w1::arch::mode::x86_32:
      return build_x86_32_stub(request, layout, plan, out);
    case w1::arch::mode::aarch64:
      return build_arm64_stub(request, layout, plan, out);
    default:
      return false;
  }
}

} // namespace w1::h00k::backend::instrument

```

`src/w1h00k/backend/inline/inline_instrumentation.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <vector>

#include "w1base/arch_spec.hpp"
#include "w1h00k/hook.hpp"

namespace w1::h00k::backend::instrument {

struct stub_layout {
  size_t stack_size = 0;
  size_t gpr_offset = 0;
  size_t fpr_offset = 0;
  size_t args_offset = 0;
  size_t info_offset = 0;
  size_t shadow_size = 0;
  size_t gpr_count = 0;
  size_t fpr_count = 0;
};

struct stub_request {
  w1::arch::arch_spec arch{};
  hook_call_abi abi = hook_call_abi::native;
  uintptr_t target = 0;
  uintptr_t trampoline = 0;
  uintptr_t replacement = 0;
  uintptr_t prehook = 0;
  uintptr_t user_data = 0;
  uintptr_t stub_address = 0;
};

hook_call_abi resolve_call_abi(hook_call_abi requested, const w1::arch::arch_spec& arch);
bool abi_supported(hook_call_abi abi, const w1::arch::arch_spec& arch);
stub_layout make_layout(const w1::arch::arch_spec& arch, hook_call_abi abi, bool& ok);
size_t stub_reserve_size(const w1::arch::arch_spec& arch, hook_call_abi abi);
bool build_stub(const stub_request& request, const stub_layout& layout, std::vector<uint8_t>& out);

} // namespace w1::h00k::backend::instrument

```

`src/w1h00k/backend/interpose/interpose_backend.cpp`:

```cpp
#include "w1h00k/backend/interpose/interpose_backend.hpp"

#include <cstring>
#include <unordered_set>

#include "w1h00k/backend/patch_batch.hpp"
#include "w1h00k/backend/pointer_auth.hpp"
#include "w1h00k/resolve/resolve.hpp"

namespace w1::h00k::backend {

class interpose_backend final : public hook_backend {
public:
  hook_technique technique() const override { return hook_technique::interpose; }

  bool supports(const hook_request& request) const override {
    if (request.kind == hook_kind::instrument || request.prehook != nullptr) {
      return false;
    }
    if (request.replacement == nullptr) {
      return false;
    }
    return request.target.kind == hook_target_kind::symbol;
  }

  prepare_result prepare(const hook_request& request, void* resolved_target) override {
    prepare_result result{};
    if (!supports(request)) {
      result.error.code = hook_error::unsupported;
      return result;
    }
    if (!request.target.symbol || request.target.symbol[0] == '\0') {
      result.error.code = hook_error::invalid_target;
      return result;
    }

    std::vector<patch_entry> patches;
    auto resolutions =
        resolve::resolve_imports(request.target.symbol, request.target.module, request.target.import_module);
    if (resolutions.empty()) {
      result.error.code = hook_error::not_found;
      return result;
    }

    patches.reserve(resolutions.size());
    std::unordered_set<void*> seen_slots;

    void* first_original = nullptr;
    for (const auto& resolved : resolutions) {
      if (!resolved.error.ok() || !resolved.slot) {
        continue;
      }

      void** slot = resolved.slot;
      if (!seen_slots.insert(slot).second) {
        continue;
      }

      void* original = *slot;
      void* replacement = sign_replacement_pointer(request.replacement, slot);

      patch_entry entry{};
      entry.target = slot;
      entry.patch_bytes.resize(sizeof(void*));
      std::memcpy(entry.patch_bytes.data(), &replacement, sizeof(void*));

      entry.restore_bytes.resize(sizeof(void*));
      std::memcpy(entry.restore_bytes.data(), &original, sizeof(void*));

      patches.push_back(std::move(entry));
      if (!first_original) {
        first_original = sanitize_original_pointer(original);
      }
    }

    if (patches.empty()) {
      result.error.code = hook_error::not_found;
      return result;
    }

    result.plan.request = request;
    result.plan.patches = std::move(patches);
    result.plan.resolved_target = resolved_target ? resolved_target : result.plan.patches.front().target;
    void* resolved_trampoline = resolved_target ? sanitize_original_pointer(resolved_target) : nullptr;
    result.plan.trampoline = resolved_trampoline ? resolved_trampoline : first_original;
    result.error.code = hook_error::ok;
    return result;
  }

  hook_error commit(const hook_plan& plan) override {
    return apply_patch_entries(plan.patches);
  }

  hook_error revert(const hook_plan& plan) override {
    return revert_patch_entries(plan.patches);
  }
};

std::unique_ptr<hook_backend> make_interpose_backend() {
  return std::make_unique<interpose_backend>();
}

} // namespace w1::h00k::backend

```

`src/w1h00k/backend/interpose/interpose_backend.hpp`:

```hpp
#pragma once

#include <memory>

#include "w1h00k/backend/backend.hpp"

namespace w1::h00k::backend {

std::unique_ptr<hook_backend> make_interpose_backend();

} // namespace w1::h00k::backend

```

`src/w1h00k/backend/patch_batch.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <vector>

#include "w1h00k/backend/backend.hpp"
#include "w1h00k/patcher/patcher.hpp"

namespace w1::h00k::backend {

inline hook_error apply_patch_entries(const std::vector<patch_entry>& entries) {
  if (entries.empty()) {
    return hook_error::invalid_target;
  }

  data_patcher patcher;
  size_t applied = 0;
  for (const auto& entry : entries) {
    if (!entry.target || entry.patch_bytes.empty()) {
      return hook_error::invalid_target;
    }
    if (!patcher.write(entry.target, entry.patch_bytes.data(), entry.patch_bytes.size())) {
      for (size_t i = 0; i < applied; ++i) {
        const auto& restore_entry = entries[i];
        if (restore_entry.target && !restore_entry.restore_bytes.empty()) {
          patcher.restore(restore_entry.target, restore_entry.restore_bytes.data(),
                          restore_entry.restore_bytes.size());
        }
      }
      return hook_error::patch_failed;
    }
    ++applied;
  }
  return hook_error::ok;
}

inline hook_error revert_patch_entries(const std::vector<patch_entry>& entries) {
  if (entries.empty()) {
    return hook_error::invalid_target;
  }

  data_patcher patcher;
  bool ok = true;
  for (const auto& entry : entries) {
    if (!entry.target || entry.restore_bytes.empty()) {
      ok = false;
      continue;
    }
    if (!patcher.restore(entry.target, entry.restore_bytes.data(), entry.restore_bytes.size())) {
      ok = false;
    }
  }
  return ok ? hook_error::ok : hook_error::patch_failed;
}

} // namespace w1::h00k::backend

```

`src/w1h00k/backend/pointer_auth.hpp`:

```hpp
#pragma once

#ifndef __has_feature
#define __has_feature(x) 0
#endif

#if defined(__APPLE__) && __has_feature(ptrauth_calls)
#include <ptrauth.h>
#endif

namespace w1::h00k::backend {

inline void* sanitize_original_pointer(void* value) {
#if defined(__APPLE__) && __has_feature(ptrauth_calls)
  value = ptrauth_strip(value, ptrauth_key_asia);
  value = ptrauth_sign_unauthenticated(value, ptrauth_key_asia, 0);
  return value;
#else
  return value;
#endif
}

inline void* sign_replacement_pointer(void* value, void* slot) {
#if defined(__APPLE__) && __has_feature(ptrauth_calls)
  value = ptrauth_strip(value, ptrauth_key_asia);
  value = ptrauth_sign_unauthenticated(value, ptrauth_key_asia, slot);
  return value;
#else
  (void)slot;
  return value;
#endif
}

} // namespace w1::h00k::backend

```

`src/w1h00k/backend/registry.cpp`:

```cpp
#include "w1h00k/backend/registry.hpp"

namespace w1::h00k::backend {

namespace {

constexpr std::array<hook_technique, static_cast<size_t>(hook_technique::count)> kTechniqueOrder = {
    hook_technique::inline_trampoline,
    hook_technique::interpose,
    hook_technique::plt_got,
    hook_technique::iat,
    hook_technique::table_swap,
};

} // namespace

void backend_registry::register_backend(std::unique_ptr<hook_backend> backend) {
  if (!backend) {
    return;
  }
  const auto index = static_cast<size_t>(backend->technique());
  if (index >= backends_.size()) {
    return;
  }
  backends_[index] = std::move(backend);
}

hook_backend* backend_registry::find(hook_technique technique) const {
  const auto index = static_cast<size_t>(technique);
  if (index >= backends_.size()) {
    return nullptr;
  }
  const auto& backend = backends_[index];
  return backend ? backend.get() : nullptr;
}

hook_backend* backend_registry::select(const hook_request& request) const {
  if (request.preferred == hook_technique::count) {
    return nullptr;
  }

  if (request.selection == hook_selection::strict) {
    if (!technique_allowed(request.allowed, request.preferred)) {
      return nullptr;
    }
    auto* backend = find(request.preferred);
    if (!backend || !backend->supports(request)) {
      return nullptr;
    }
    return backend;
  }

  if (technique_allowed(request.allowed, request.preferred)) {
    if (auto* backend = find(request.preferred); backend && backend->supports(request)) {
      return backend;
    }
  }

  for (auto technique : kTechniqueOrder) {
    if (technique == request.preferred) {
      continue;
    }
    if (!technique_allowed(request.allowed, technique)) {
      continue;
    }
    auto* backend = find(technique);
    if (backend && backend->supports(request)) {
      return backend;
    }
  }

  return nullptr;
}

} // namespace w1::h00k::backend

```

`src/w1h00k/backend/registry.hpp`:

```hpp
#pragma once

#include <array>
#include <memory>

#include "w1h00k/backend/backend.hpp"

namespace w1::h00k::backend {

class backend_registry {
public:
  void register_backend(std::unique_ptr<hook_backend> backend);
  hook_backend* find(hook_technique technique) const;
  hook_backend* select(const hook_request& request) const;

private:
  std::array<std::unique_ptr<hook_backend>, static_cast<size_t>(hook_technique::count)> backends_{};
};

} // namespace w1::h00k::backend

```

`src/w1h00k/core/hook_args.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <type_traits>

#include "w1h00k/hook.hpp"

namespace w1::h00k {

struct hook_arg_handle {
  hook_call_abi abi = hook_call_abi::native;
  uint32_t reserved = 0;
  const void* int_regs = nullptr;
  const void* flt_regs = nullptr;
  const void* stack = nullptr;
};

static_assert(std::is_standard_layout_v<hook_arg_handle>);
static_assert(std::is_trivially_copyable_v<hook_arg_handle>);

} // namespace w1::h00k

```

`src/w1h00k/core/hook_manager.cpp`:

```cpp
#include "w1h00k/core/hook_manager.hpp"

#include <utility>

#include "w1h00k/backend/import_table/import_table_backend.hpp"
#include "w1h00k/backend/inline/inline_backend.hpp"
#include "w1h00k/backend/interpose/interpose_backend.hpp"
#include "w1h00k/memory/memory.hpp"
#include "w1h00k/core/plan_targets.hpp"
#include "w1h00k/resolve/resolve.hpp"

namespace w1::h00k::core {
namespace {

void free_trampoline(const backend::hook_plan& plan) {
  if (!plan.trampoline || plan.trampoline_size == 0) {
    return;
  }
  memory::free_executable({plan.trampoline, plan.trampoline_size});
}

} // namespace

hook_manager::hook_manager() {
  registry_.register_backend(backend::make_inline_trampoline_backend());
  registry_.register_backend(backend::make_interpose_backend());
  registry_.register_backend(backend::make_import_table_backend());
}

bool hook_manager::is_valid_target(const hook_target& target) const {
  switch (target.kind) {
    case hook_target_kind::address:
      return target.address != nullptr;
    case hook_target_kind::symbol:
      return target.symbol != nullptr;
    case hook_target_kind::import_slot:
      return target.slot != nullptr || target.symbol != nullptr;
    case hook_target_kind::table_slot:
      return target.table != nullptr;
  }
  return false;
}

hook_technique_mask hook_manager::normalize_allowed(const hook_request& request) const {
  if (request.allowed == 0) {
    return technique_mask(request.preferred);
  }
  return request.allowed;
}

void* hook_manager::resolve_target(const hook_target& target) const {
  switch (target.kind) {
    case hook_target_kind::address:
      return target.address;
    case hook_target_kind::symbol:
      return resolve::symbol_address(target.symbol, target.module);
    case hook_target_kind::import_slot:
      if (target.slot) {
        return target.slot;
      }
      if (target.symbol) {
        auto resolved = resolve::resolve_import(target.symbol, target.module, target.import_module);
        return resolved.slot;
      }
      return nullptr;
    case hook_target_kind::table_slot:
      if (!target.table) {
        return nullptr;
      }
      return static_cast<void*>(target.table + target.index);
  }
  return nullptr;
}

hook_handle hook_manager::reserve_handle() {
  return {next_id_++};
}

hook_error hook_manager::prepare_attach(const hook_request& request, prepared_hook& out, void** original,
                                        hook_error_info* out_error) {
  auto set_error = [&](hook_error code, const char* detail = nullptr) {
    if (out_error) {
      *out_error = {};
      out_error->code = code;
      out_error->detail = detail;
    }
  };

  if (!is_valid_target(request.target)) {
    if (original) {
      *original = nullptr;
    }
    set_error(hook_error::invalid_target);
    return hook_error::invalid_target;
  }

  hook_request normalized = request;
  normalized.allowed = normalize_allowed(request);

  auto* backend = registry_.select(normalized);
  if (!backend) {
    if (original) {
      *original = nullptr;
    }
    set_error(hook_error::unsupported);
    return hook_error::unsupported;
  }

  void* resolved = resolve_target(normalized.target);

  if (resolved && backend->technique() != hook_technique::interpose) {
    if (target_to_handle_.find(resolved) != target_to_handle_.end()) {
      if (original) {
        *original = nullptr;
      }
      set_error(hook_error::already_hooked);
      return hook_error::already_hooked;
    }
  }

  auto prepared = backend->prepare(normalized, resolved);
  if (!prepared.error.ok()) {
    if (original) {
      *original = nullptr;
    }
    if (out_error) {
      *out_error = prepared.error;
    }
    return prepared.error.code;
  }

  if (!prepared.plan.resolved_target) {
    prepared.plan.resolved_target = resolved;
  }
  bool has_target = false;
  bool collision = false;
  core::for_each_plan_target(prepared.plan, [&](void* target) {
    has_target = true;
    if (target_to_handle_.find(target) != target_to_handle_.end()) {
      collision = true;
    }
  });
  if (!has_target) {
    if (original) {
      *original = nullptr;
    }
    free_trampoline(prepared.plan);
    set_error(hook_error::invalid_target);
    return hook_error::invalid_target;
  }
  if (collision) {
    if (original) {
      *original = nullptr;
    }
    free_trampoline(prepared.plan);
    set_error(hook_error::already_hooked);
    return hook_error::already_hooked;
  }

  out.plan = std::move(prepared.plan);
  out.backend = backend;
  if (original) {
    *original = out.plan.trampoline;
  }
  set_error(hook_error::ok);
  return hook_error::ok;
}

hook_error hook_manager::prepare_detach(hook_handle handle, prepared_hook& out) {
  auto it = hooks_.find(handle.id);
  if (it == hooks_.end()) {
    return hook_error::not_found;
  }
  out = it->second;
  return hook_error::ok;
}

hook_error hook_manager::commit_attach(prepared_hook& prepared) {
  if (!prepared.backend) {
    return hook_error::unsupported;
  }
  auto err = prepared.backend->commit(prepared.plan);
  if (err != hook_error::ok) {
    return err;
  }

  if (prepared.handle.id == 0) {
    prepared.handle = reserve_handle();
  }

  hooks_[prepared.handle.id] = prepared;
  core::for_each_plan_target(prepared.plan, [&](void* target) {
    target_to_handle_[target] = prepared.handle.id;
  });
  return hook_error::ok;
}

hook_error hook_manager::commit_detach(const prepared_hook& prepared) {
  if (!prepared.backend) {
    return hook_error::not_found;
  }
  return prepared.backend->revert(prepared.plan);
}

void hook_manager::rollback_attach(const prepared_hook& prepared) {
  if (!prepared.backend) {
    return;
  }
  prepared.backend->revert(prepared.plan);
  if (prepared.handle.id != 0) {
    hooks_.erase(prepared.handle.id);
    core::for_each_plan_target(prepared.plan, [&](void* target) { target_to_handle_.erase(target); });
  }
  free_trampoline(prepared.plan);
}

void hook_manager::rollback_detach(const prepared_hook& prepared) {
  if (!prepared.backend) {
    return;
  }
  prepared.backend->commit(prepared.plan);
}

void hook_manager::finalize_detach(const prepared_hook& prepared) {
  if (prepared.handle.id != 0) {
    hooks_.erase(prepared.handle.id);
    core::for_each_plan_target(prepared.plan, [&](void* target) { target_to_handle_.erase(target); });
  }
  free_trampoline(prepared.plan);
}

hook_result hook_manager::attach(const hook_request& request, void** original) {
  std::lock_guard lock(mutex_);

  prepared_hook prepared{};
  hook_error_info error_info{};
  auto err = prepare_attach(request, prepared, original, &error_info);
  if (err != hook_error::ok) {
    return {{}, error_info};
  }

  err = commit_attach(prepared);
  if (err != hook_error::ok) {
    if (original) {
      *original = nullptr;
    }
    rollback_attach(prepared);
    return {{}, {err}};
  }

  hook_error_info ok_info{};
  ok_info.code = hook_error::ok;
  return {prepared.handle, ok_info};
}

hook_error hook_manager::detach(hook_handle handle) {
  std::lock_guard lock(mutex_);

  prepared_hook prepared{};
  auto err = prepare_detach(handle, prepared);
  if (err != hook_error::ok) {
    return err;
  }

  err = commit_detach(prepared);
  if (err != hook_error::ok) {
    return err;
  }

  finalize_detach(prepared);
  return hook_error::ok;
}

bool hook_manager::supports(const hook_request& request) const {
  if (!is_valid_target(request.target)) {
    return false;
  }
  hook_request normalized = request;
  normalized.allowed = normalize_allowed(request);
  auto* backend = registry_.select(normalized);
  return backend != nullptr;
}

} // namespace w1::h00k::core

```

`src/w1h00k/core/hook_manager.hpp`:

```hpp
#pragma once

#include <atomic>
#include <mutex>
#include <unordered_map>

#include "w1h00k/backend/registry.hpp"
#include "w1h00k/hook.hpp"

namespace w1::h00k::core {

struct prepared_hook {
  backend::hook_plan plan{};
  backend::hook_backend* backend = nullptr;
  hook_handle handle{};
};

class hook_manager {
public:
  hook_manager();

  hook_result attach(const hook_request& request, void** original);
  hook_error detach(hook_handle handle);
  bool supports(const hook_request& request) const;

  hook_error prepare_attach(const hook_request& request, prepared_hook& out, void** original,
                            hook_error_info* out_error = nullptr);
  hook_error prepare_detach(hook_handle handle, prepared_hook& out);
  hook_error commit_attach(prepared_hook& prepared);
  hook_error commit_detach(const prepared_hook& prepared);
  void rollback_attach(const prepared_hook& prepared);
  void rollback_detach(const prepared_hook& prepared);
  void finalize_detach(const prepared_hook& prepared);

  hook_handle reserve_handle();

  std::mutex& mutex() { return mutex_; }

private:
  bool is_valid_target(const hook_target& target) const;
  hook_technique_mask normalize_allowed(const hook_request& request) const;
  void* resolve_target(const hook_target& target) const;

  mutable std::mutex mutex_{};
  backend::backend_registry registry_{};
  std::unordered_map<uintptr_t, prepared_hook> hooks_{};
  std::unordered_map<void*, uintptr_t> target_to_handle_{};
  std::atomic<uintptr_t> next_id_{1};

  friend class hook_transaction;
};

} // namespace w1::h00k::core

```

`src/w1h00k/core/hook_transaction.cpp`:

```cpp
#include "w1h00k/core/hook_transaction.hpp"

#include "w1h00k/memory/memory.hpp"
#include "w1h00k/core/plan_targets.hpp"

#include <unordered_set>

namespace w1::h00k::core {

namespace {

void release_prepared(const prepared_hook& prepared) {
  if (!prepared.plan.trampoline || prepared.plan.trampoline_size == 0) {
    return;
  }
  memory::free_executable({prepared.plan.trampoline, prepared.plan.trampoline_size});
}

} // namespace

hook_transaction::hook_transaction(hook_manager& manager) : manager_(&manager) {}

hook_transaction::~hook_transaction() {
  for (const auto& prepared : pending_attaches_) {
    release_prepared(prepared);
  }
}

hook_result hook_transaction::attach(const hook_request& request, void** original) {
  if (last_error_ != hook_error::ok) {
    if (original) {
      *original = nullptr;
    }
    return {{}, {last_error_}};
  }

  std::lock_guard lock(manager_->mutex());
  prepared_hook prepared{};
  hook_error_info error_info{};
  auto err = manager_->prepare_attach(request, prepared, original, &error_info);
  if (err != hook_error::ok) {
    last_error_ = err;
    return {{}, error_info};
  }

  std::unordered_set<void*> new_targets;
  core::for_each_plan_target(prepared.plan, [&](void* target) { new_targets.insert(target); });
  if (new_targets.empty()) {
    release_prepared(prepared);
    last_error_ = hook_error::invalid_target;
    return {{}, {last_error_}};
  }

  for (const auto& existing : pending_attaches_) {
    bool collision = false;
    core::for_each_plan_target(existing.plan, [&](void* target) {
      if (new_targets.find(target) != new_targets.end()) {
        collision = true;
      }
    });
    if (collision) {
      release_prepared(prepared);
      last_error_ = hook_error::already_hooked;
      return {{}, {last_error_}};
    }
  }

  prepared.handle = manager_->reserve_handle();
  pending_attaches_.push_back(std::move(prepared));
  hook_error_info ok_info{};
  ok_info.code = hook_error::ok;
  return {pending_attaches_.back().handle, ok_info};
}

hook_error hook_transaction::detach(hook_handle handle) {
  if (last_error_ != hook_error::ok) {
    return last_error_;
  }

  std::lock_guard lock(manager_->mutex());
  prepared_hook prepared{};
  auto err = manager_->prepare_detach(handle, prepared);
  if (err != hook_error::ok) {
    last_error_ = err;
    return err;
  }

  for (const auto& existing : pending_detaches_) {
    if (existing.handle.id == prepared.handle.id) {
      last_error_ = hook_error::not_found;
      return last_error_;
    }
  }

  pending_detaches_.push_back(std::move(prepared));
  return hook_error::ok;
}

hook_error hook_transaction::commit() {
  if (last_error_ != hook_error::ok) {
    return last_error_;
  }

  std::lock_guard lock(manager_->mutex());
  std::vector<const prepared_hook*> committed_attaches;
  std::vector<const prepared_hook*> committed_detaches;

  for (auto& prepared : pending_attaches_) {
    auto err = manager_->commit_attach(prepared);
    if (err != hook_error::ok) {
      for (const auto* applied : committed_attaches) {
        manager_->rollback_attach(*applied);
      }
      last_error_ = err;
      return err;
    }
    committed_attaches.push_back(&prepared);
  }

  for (auto& prepared : pending_detaches_) {
    auto err = manager_->commit_detach(prepared);
    if (err != hook_error::ok) {
      for (const auto* applied : committed_detaches) {
        manager_->rollback_detach(*applied);
      }
      for (const auto* applied : committed_attaches) {
        manager_->rollback_attach(*applied);
      }
      last_error_ = err;
      return err;
    }
    committed_detaches.push_back(&prepared);
  }

  for (const auto& prepared : pending_detaches_) {
    manager_->finalize_detach(prepared);
  }

  pending_attaches_.clear();
  pending_detaches_.clear();
  return hook_error::ok;
}

} // namespace w1::h00k::core

```

`src/w1h00k/core/hook_transaction.hpp`:

```hpp
#pragma once

#include <vector>

#include "w1h00k/core/hook_manager.hpp"
#include "w1h00k/hook.hpp"

namespace w1::h00k::core {

class hook_transaction {
public:
  explicit hook_transaction(hook_manager& manager);
  ~hook_transaction();

  hook_result attach(const hook_request& request, void** original);
  hook_error detach(hook_handle handle);
  hook_error commit();

private:
  hook_manager* manager_ = nullptr;
  std::vector<prepared_hook> pending_attaches_{};
  std::vector<prepared_hook> pending_detaches_{};
  hook_error last_error_ = hook_error::ok;
};

} // namespace w1::h00k::core

```

`src/w1h00k/core/plan_targets.hpp`:

```hpp
#pragma once

#include "w1h00k/backend/backend.hpp"

namespace w1::h00k::core {

template <typename Fn>
inline void for_each_plan_target(const backend::hook_plan& plan, Fn&& fn) {
  if (!plan.patches.empty()) {
    for (const auto& entry : plan.patches) {
      if (entry.target) {
        fn(entry.target);
      }
    }
    return;
  }
  if (plan.resolved_target) {
    fn(plan.resolved_target);
  }
}

} // namespace w1::h00k::core

```

`src/w1h00k/errors.cpp`:

```cpp
#include "w1h00k/errors.hpp"

namespace w1::h00k {

const char* to_string(hook_error error) {
  switch (error) {
    case hook_error::ok:
      return "ok";
    case hook_error::unsupported:
      return "unsupported";
    case hook_error::invalid_target:
      return "invalid_target";
    case hook_error::relocation_failed:
      return "relocation_failed";
    case hook_error::near_alloc_failed:
      return "near_alloc_failed";
    case hook_error::patch_failed:
      return "patch_failed";
    case hook_error::already_hooked:
      return "already_hooked";
    case hook_error::not_found:
      return "not_found";
    case hook_error::access_denied:
      return "access_denied";
  }
  return "unknown";
}

} // namespace w1::h00k

```

`src/w1h00k/errors.hpp`:

```hpp
#pragma once

#include "w1h00k/hook.hpp"

namespace w1::h00k {

const char* to_string(hook_error error);

} // namespace w1::h00k

```

`src/w1h00k/hook.cpp`:

```cpp
#include "w1h00k/hook.hpp"

#include "w1h00k/core/hook_args.hpp"
#include "w1h00k/core/hook_manager.hpp"
#include "w1h00k/core/hook_transaction.hpp"

namespace w1::h00k {
namespace {

struct abi_layout {
  size_t int_reg_count = 0;
  size_t flt_reg_count = 0;
  size_t int_stride = 0;
  size_t flt_stride = 0;
  size_t stack_offset = 0;
  size_t stack_slot = 0;
};

hook_call_abi resolve_native_abi() {
#if defined(_WIN32)
#if defined(_M_X64) || defined(__x86_64__)
  return hook_call_abi::win64;
#elif defined(_M_IX86) || defined(__i386__)
  return hook_call_abi::win32_cdecl;
#elif defined(_M_ARM64) || defined(__aarch64__)
  return hook_call_abi::aapcs64;
#else
  return hook_call_abi::sysv;
#endif
#else
#if defined(__aarch64__)
  return hook_call_abi::aapcs64;
#else
  return hook_call_abi::sysv;
#endif
#endif
}

bool layout_for(hook_call_abi abi, abi_layout& out) {
  const size_t ptr_size = sizeof(void*);
  out.int_stride = ptr_size;
  out.flt_stride = 16;
  out.stack_slot = ptr_size;

  switch (abi) {
    case hook_call_abi::sysv:
      if (ptr_size == 4) {
        out.int_reg_count = 0;
        out.flt_reg_count = 0;
        out.stack_offset = 4;
        out.stack_slot = 4;
      } else {
        out.int_reg_count = 6;
        out.flt_reg_count = 8;
        out.stack_offset = 8;
      }
      return true;
    case hook_call_abi::win64:
      if (ptr_size != 8) {
        return false;
      }
      out.int_reg_count = 4;
      out.flt_reg_count = 4;
      out.stack_offset = 8 + 32;
      return true;
    case hook_call_abi::win64_vectorcall:
      if (ptr_size != 8) {
        return false;
      }
      out.int_reg_count = 4;
      out.flt_reg_count = 6;
      out.stack_offset = 8 + 32;
      return true;
    case hook_call_abi::win32_cdecl:
    case hook_call_abi::win32_stdcall:
      if (ptr_size != 4) {
        return false;
      }
      out.int_reg_count = 0;
      out.flt_reg_count = 0;
      out.stack_offset = 4;
      out.stack_slot = 4;
      return true;
    case hook_call_abi::win32_fastcall:
      if (ptr_size != 4) {
        return false;
      }
      out.int_reg_count = 2;
      out.flt_reg_count = 0;
      out.stack_offset = 4;
      out.stack_slot = 4;
      return true;
    case hook_call_abi::win32_thiscall:
      if (ptr_size != 4) {
        return false;
      }
      out.int_reg_count = 1;
      out.flt_reg_count = 0;
      out.stack_offset = 4;
      out.stack_slot = 4;
      return true;
    case hook_call_abi::aapcs64:
      if (ptr_size != 8) {
        return false;
      }
      out.int_reg_count = 8;
      out.flt_reg_count = 8;
      out.stack_offset = 0;
      return true;
    case hook_call_abi::native:
      return layout_for(resolve_native_abi(), out);
    default:
      return false;
  }
}

core::hook_manager& global_manager() {
  // intentionally leaked to avoid shutdown-order issues in preload/teardown
  static core::hook_manager* manager = new core::hook_manager();
  return *manager;
}

} // namespace

struct hook_transaction::impl {
  core::hook_transaction transaction;

  explicit impl(core::hook_manager& manager) : transaction(manager) {}
};

hook_transaction::hook_transaction() : impl_(std::make_unique<impl>(global_manager())) {}

hook_transaction::~hook_transaction() = default;

hook_transaction::hook_transaction(hook_transaction&&) noexcept = default;
hook_transaction& hook_transaction::operator=(hook_transaction&&) noexcept = default;

hook_result hook_transaction::attach(const hook_request& request, void** original) {
  return impl_->transaction.attach(request, original);
}

hook_error hook_transaction::detach(hook_handle handle) {
  return impl_->transaction.detach(handle);
}

hook_error hook_transaction::commit() {
  return impl_->transaction.commit();
}

hook_result attach(const hook_request& request, void** original) {
  return global_manager().attach(request, original);
}

hook_error detach(hook_handle handle) {
  return global_manager().detach(handle);
}

bool supports(const hook_request& request) {
  return global_manager().supports(request);
}

void* arg_get_int_reg_addr(const hook_arg_handle* args, int pos) {
  if (!args || pos < 0 || !args->int_regs) {
    return nullptr;
  }

  abi_layout layout{};
  if (!layout_for(args->abi, layout)) {
    return nullptr;
  }

  if (static_cast<size_t>(pos) >= layout.int_reg_count) {
    return nullptr;
  }

  auto* base = static_cast<uint8_t*>(const_cast<void*>(args->int_regs));
  return base + (static_cast<size_t>(pos) * layout.int_stride);
}

void* arg_get_flt_reg_addr(const hook_arg_handle* args, int pos) {
  if (!args || pos < 0 || !args->flt_regs) {
    return nullptr;
  }

  abi_layout layout{};
  if (!layout_for(args->abi, layout)) {
    return nullptr;
  }

  if (static_cast<size_t>(pos) >= layout.flt_reg_count) {
    return nullptr;
  }

  auto* base = static_cast<uint8_t*>(const_cast<void*>(args->flt_regs));
  return base + (static_cast<size_t>(pos) * layout.flt_stride);
}

void* arg_get_stack_addr(const hook_arg_handle* args, int pos) {
  if (!args || pos < 0 || !args->stack) {
    return nullptr;
  }

  abi_layout layout{};
  if (!layout_for(args->abi, layout)) {
    return nullptr;
  }

  auto* base = static_cast<uint8_t*>(const_cast<void*>(args->stack));
  return base + layout.stack_offset + (static_cast<size_t>(pos) * layout.stack_slot);
}

void register_interpose(const interpose_pair* pairs, size_t count) {
  if (!pairs || count == 0) {
    return;
  }
  for (size_t i = 0; i < count; ++i) {
    const auto& entry = pairs[i];
    if (!entry.first || !entry.second) {
      continue;
    }
    hook_request request{};
    request.target.kind = hook_target_kind::symbol;
    request.target.symbol = entry.first;
    request.replacement = entry.second;
    request.preferred = hook_technique::interpose;
    request.allowed = technique_mask(hook_technique::interpose);
    request.selection = hook_selection::strict;
    (void)attach(request, nullptr);
  }
}

} // namespace w1::h00k

```

`src/w1h00k/hook.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <memory>
#include <utility>

namespace w1::h00k {

enum class hook_technique {
  inline_trampoline = 0,
  interpose,
  plt_got,
  iat,
  table_swap,
  count
};

enum class hook_kind {
  replace,
  instrument
};

using hook_technique_mask = uint32_t;

constexpr hook_technique_mask technique_mask(hook_technique technique) {
  if (technique == hook_technique::count) {
    return 0;
  }
  return static_cast<hook_technique_mask>(1u << static_cast<uint32_t>(technique));
}

constexpr bool technique_allowed(hook_technique_mask mask, hook_technique technique) {
  return (mask & technique_mask(technique)) != 0;
}

enum class hook_selection {
  strict,
  allow_fallback
};

enum class hook_target_kind {
  address,
  symbol,
  import_slot,
  table_slot
};

enum class hook_call_abi {
  native,
  sysv,
  win64,
  aapcs64,
  win64_vectorcall,
  win32_cdecl,
  win32_stdcall,
  win32_fastcall,
  win32_thiscall
};

enum class hook_error {
  ok,
  unsupported,
  invalid_target,
  relocation_failed,
  near_alloc_failed,
  patch_failed,
  already_hooked,
  not_found,
  access_denied
};

struct hook_target {
  hook_target_kind kind = hook_target_kind::address;
  void* address = nullptr;
  const char* symbol = nullptr;
  const char* module = nullptr;
  const char* import_module = nullptr;
  void** slot = nullptr;
  void** table = nullptr;
  size_t index = 0;
};

struct hook_arg_handle;

struct hook_info {
  void* original_target = nullptr;
  void* target = nullptr;
  void* trampoline = nullptr;
  void* replacement = nullptr;
  void* user_data = nullptr;
  hook_arg_handle* args = nullptr;
};

using prehook_fn = void (*)(hook_info*);

struct hook_request {
  hook_target target{};
  void* replacement = nullptr;
  hook_technique preferred = hook_technique::inline_trampoline;
  hook_technique_mask allowed = 0;
  hook_selection selection = hook_selection::strict;
  hook_kind kind = hook_kind::replace;
  hook_call_abi call_abi = hook_call_abi::native;
  prehook_fn prehook = nullptr;
  void* user_data = nullptr;
};

struct hook_handle {
  uintptr_t id = 0;
};

struct hook_error_info {
  hook_error code = hook_error::unsupported;
  int os_error = 0;
  const char* detail = nullptr;

  constexpr bool ok() const { return code == hook_error::ok; }
};

struct hook_result {
  hook_handle handle{};
  hook_error_info error{};
};

class hook_transaction {
public:
  hook_transaction();
  ~hook_transaction();
  hook_transaction(hook_transaction&&) noexcept;
  hook_transaction& operator=(hook_transaction&&) noexcept;
  hook_transaction(const hook_transaction&) = delete;
  hook_transaction& operator=(const hook_transaction&) = delete;

  hook_result attach(const hook_request& request, void** original);
  hook_error detach(hook_handle handle);
  hook_error commit();

private:
  struct impl;
  std::unique_ptr<impl> impl_{};
};

hook_result attach(const hook_request& request, void** original);
hook_error detach(hook_handle handle);
bool supports(const hook_request& request);

void* arg_get_int_reg_addr(const hook_arg_handle* args, int pos);
void* arg_get_flt_reg_addr(const hook_arg_handle* args, int pos);
void* arg_get_stack_addr(const hook_arg_handle* args, int pos);

using interpose_pair = std::pair<const char*, void*>;
void register_interpose(const interpose_pair* pairs, size_t count);

} // namespace w1::h00k

```

`src/w1h00k/memory/memory.hpp`:

```hpp
#pragma once

#include <cstddef>

#include "w1base/arch_spec.hpp"

namespace w1::h00k::memory {

struct exec_block {
  void* address = nullptr;
  size_t size = 0;

  bool ok() const { return address != nullptr && size > 0; }
};

size_t page_size();
exec_block allocate_executable(size_t size);
exec_block allocate_near(void* target, size_t size, size_t range);
void free_executable(exec_block block);

inline exec_block allocate_trampoline(void* target, size_t size, const w1::arch::arch_spec& arch) {
  if (arch.arch_mode == w1::arch::mode::x86_64) {
    constexpr size_t kNearRange = 0x7FFFFFFF; // 2GB - 1 for RIP-relative reach
    auto block = allocate_near(target, size, kNearRange);
    if (block.ok()) {
      return block;
    }
  }
  return allocate_executable(size);
}

} // namespace w1::h00k::memory

```

`src/w1h00k/memory/posix.cpp`:

```cpp
#include "w1h00k/memory/memory.hpp"

#include <cstdint>

#include <sys/mman.h>
#include <unistd.h>

namespace w1::h00k::memory {
namespace {

size_t align_up(size_t value, size_t alignment) {
  if (alignment == 0) {
    return value;
  }
  const size_t mask = alignment - 1;
  return (value + mask) & ~mask;
}

uintptr_t align_down(uintptr_t value, size_t alignment) {
  if (alignment == 0) {
    return value;
  }
  const uintptr_t mask = static_cast<uintptr_t>(alignment - 1);
  return value & ~mask;
}

} // namespace

size_t page_size() {
  long size = sysconf(_SC_PAGESIZE);
  if (size <= 0) {
    return 4096;
  }
  return static_cast<size_t>(size);
}

exec_block allocate_executable(size_t size) {
  if (size == 0) {
    return {};
  }

  const size_t page = page_size();
  const size_t aligned = align_up(size, page);

  int prot = PROT_READ | PROT_WRITE | PROT_EXEC;
  int flags = MAP_PRIVATE | MAP_ANON;
#if defined(__APPLE__) && defined(MAP_JIT)
  flags |= MAP_JIT;
#endif

  void* addr = mmap(nullptr, aligned, prot, flags, -1, 0);
  if (addr == MAP_FAILED) {
    return {};
  }
  return {addr, aligned};
}

exec_block allocate_near(void* target, size_t size, size_t range) {
  if (!target || size == 0 || range == 0) {
    return {};
  }

  const size_t page = page_size();
  const size_t aligned = align_up(size, page);

  uintptr_t origin = reinterpret_cast<uintptr_t>(target);
  uintptr_t min_addr = origin > range ? origin - range : 0;
  uintptr_t max_addr = origin + range;
  if (max_addr < origin) {
    max_addr = UINTPTR_MAX;
  }
  if (max_addr < min_addr + aligned) {
    return {};
  }
  uintptr_t max_start = max_addr >= aligned ? max_addr - aligned : 0;
  min_addr = align_down(min_addr, page);
  max_start = align_down(max_start, page);

  int prot = PROT_READ | PROT_WRITE | PROT_EXEC;
  int flags = MAP_PRIVATE | MAP_ANON;
#if defined(__APPLE__) && defined(MAP_JIT)
  flags |= MAP_JIT;
#endif

  auto try_map = [&](uintptr_t hint) -> void* {
    void* addr = nullptr;
#if defined(MAP_FIXED_NOREPLACE)
    addr = mmap(reinterpret_cast<void*>(hint), aligned, prot, flags | MAP_FIXED_NOREPLACE, -1, 0);
    if (addr != MAP_FAILED) {
      return addr;
    }
#endif
    addr = mmap(reinterpret_cast<void*>(hint), aligned, prot, flags, -1, 0);
    if (addr == MAP_FAILED) {
      return nullptr;
    }
    uintptr_t addr_value = reinterpret_cast<uintptr_t>(addr);
    if (addr_value < min_addr || addr_value > max_start) {
      munmap(addr, aligned);
      return nullptr;
    }
    return addr;
  };

  constexpr size_t kMaxAttempts = 4096;
  size_t step = range / kMaxAttempts;
  if (step < page) {
    step = page;
  }
  step = align_up(step, page);

  for (size_t offset = 0; offset <= range; offset += step) {
    uintptr_t high = origin + offset;
    if (high <= max_start) {
      if (void* addr = try_map(high)) {
        return {addr, aligned};
      }
    }
    if (offset == 0) {
      continue;
    }
    if (origin >= offset) {
      uintptr_t low = origin - offset;
      if (low >= min_addr && low <= max_start) {
        if (void* addr = try_map(low)) {
          return {addr, aligned};
        }
      }
    }
  }

  return {};
}

void free_executable(exec_block block) {
  if (!block.address || block.size == 0) {
    return;
  }
  munmap(block.address, block.size);
}

} // namespace w1::h00k::memory

```

`src/w1h00k/memory/windows.cpp`:

```cpp
#include "w1h00k/memory/memory.hpp"

#include <algorithm>
#include <cstdint>

#include <windows.h>

namespace w1::h00k::memory {
namespace {

size_t align_up(size_t value, size_t alignment) {
  if (alignment == 0) {
    return value;
  }
  const size_t mask = alignment - 1;
  return (value + mask) & ~mask;
}

uintptr_t align_up_ptr(uintptr_t value, size_t alignment) {
  if (alignment == 0) {
    return value;
  }
  const uintptr_t mask = static_cast<uintptr_t>(alignment - 1);
  return (value + mask) & ~mask;
}

uintptr_t align_down_ptr(uintptr_t value, size_t alignment) {
  if (alignment == 0) {
    return value;
  }
  const uintptr_t mask = static_cast<uintptr_t>(alignment - 1);
  return value & ~mask;
}

} // namespace

size_t page_size() {
  SYSTEM_INFO info{};
  GetSystemInfo(&info);
  return static_cast<size_t>(info.dwPageSize);
}

exec_block allocate_executable(size_t size) {
  if (size == 0) {
    return {};
  }

  const size_t page = page_size();
  const size_t aligned = align_up(size, page);

  void* addr = VirtualAlloc(nullptr, aligned, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
  if (!addr) {
    return {};
  }
  return {addr, aligned};
}

exec_block allocate_near(void* target, size_t size, size_t range) {
  if (!target || size == 0 || range == 0) {
    return {};
  }

  SYSTEM_INFO info{};
  GetSystemInfo(&info);
  const size_t page = static_cast<size_t>(info.dwPageSize);
  const size_t granularity = static_cast<size_t>(info.dwAllocationGranularity);
  const size_t aligned = align_up(size, page);

  uintptr_t origin = reinterpret_cast<uintptr_t>(target);
  uintptr_t min_addr = origin > range ? origin - range : 0;
  uintptr_t max_addr = origin + range;
  if (max_addr < origin) {
    max_addr = UINTPTR_MAX;
  }

  const uintptr_t min_app = reinterpret_cast<uintptr_t>(info.lpMinimumApplicationAddress);
  const uintptr_t max_app = reinterpret_cast<uintptr_t>(info.lpMaximumApplicationAddress);
  min_addr = std::max(min_addr, min_app);
  max_addr = std::min(max_addr, max_app);

  if (max_addr < min_addr + aligned) {
    return {};
  }
  uintptr_t max_start = max_addr >= aligned ? max_addr - aligned : 0;
  min_addr = align_down_ptr(min_addr, granularity);
  max_start = align_down_ptr(max_start, granularity);

  auto region_fits = [&](uintptr_t addr, size_t request) -> bool {
    MEMORY_BASIC_INFORMATION mbi{};
    if (VirtualQuery(reinterpret_cast<void*>(addr), &mbi, sizeof(mbi)) != sizeof(mbi)) {
      return false;
    }
    if (mbi.State != MEM_FREE) {
      return false;
    }
    uintptr_t region_base = reinterpret_cast<uintptr_t>(mbi.BaseAddress);
    uintptr_t region_end = region_base + mbi.RegionSize;
    if (region_end < region_base) {
      return false;
    }
    if (addr < region_base) {
      return false;
    }
    size_t offset = static_cast<size_t>(addr - region_base);
    if (mbi.RegionSize < offset + request) {
      return false;
    }
    return true;
  };

  auto try_alloc = [&](uintptr_t addr) -> void* {
    if (addr < min_addr || addr > max_start) {
      return nullptr;
    }
    if (!region_fits(addr, aligned)) {
      return nullptr;
    }
    return VirtualAlloc(reinterpret_cast<void*>(addr), aligned, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
  };

  uintptr_t origin_aligned = align_down_ptr(origin, granularity);

  bool found = false;
  uintptr_t best = 0;
  uintptr_t best_distance = UINTPTR_MAX;
  uintptr_t cursor = align_down_ptr(min_addr, granularity);
  while (cursor <= max_addr) {
    MEMORY_BASIC_INFORMATION mbi{};
    if (VirtualQuery(reinterpret_cast<void*>(cursor), &mbi, sizeof(mbi)) != sizeof(mbi)) {
      break;
    }
    uintptr_t region_base = reinterpret_cast<uintptr_t>(mbi.BaseAddress);
    uintptr_t region_end = region_base + mbi.RegionSize;
    if (region_end < region_base) {
      break;
    }
    if (mbi.State == MEM_FREE) {
      uintptr_t region_start = std::max(region_base, min_addr);
      uintptr_t region_limit = std::min(region_end, max_addr + 1);
      if (region_limit > region_start && region_limit - region_start >= aligned) {
        uintptr_t candidate_min = align_up_ptr(region_start, granularity);
        uintptr_t candidate_max = align_down_ptr(region_limit - aligned, granularity);
        if (candidate_min <= candidate_max) {
          uintptr_t candidate = origin_aligned;
          if (candidate < candidate_min) {
            candidate = candidate_min;
          } else if (candidate > candidate_max) {
            candidate = candidate_max;
          }
          uintptr_t distance = candidate >= origin ? candidate - origin : origin - candidate;
          if (!found || distance < best_distance) {
            best = candidate;
            best_distance = distance;
            found = true;
            if (distance == 0) {
              break;
            }
          }
        }
      }
    }
    if (region_end <= cursor) {
      break;
    }
    cursor = region_end;
  }

  if (found) {
    if (void* addr = try_alloc(best)) {
      return {addr, aligned};
    }
  }

  for (cursor = align_down_ptr(min_addr, granularity); cursor <= max_addr;) {
    MEMORY_BASIC_INFORMATION mbi{};
    if (VirtualQuery(reinterpret_cast<void*>(cursor), &mbi, sizeof(mbi)) != sizeof(mbi)) {
      break;
    }
    uintptr_t region_base = reinterpret_cast<uintptr_t>(mbi.BaseAddress);
    uintptr_t region_end = region_base + mbi.RegionSize;
    if (region_end < region_base) {
      break;
    }
    if (mbi.State == MEM_FREE) {
      uintptr_t region_start = std::max(region_base, min_addr);
      uintptr_t region_limit = std::min(region_end, max_addr + 1);
      if (region_limit > region_start && region_limit - region_start >= aligned) {
        uintptr_t candidate = align_up_ptr(region_start, granularity);
        if (candidate <= align_down_ptr(region_limit - aligned, granularity)) {
          if (void* addr = try_alloc(candidate)) {
            return {addr, aligned};
          }
        }
      }
    }
    if (region_end <= cursor) {
      break;
    }
    cursor = region_end;
  }

  return {};
}

void free_executable(exec_block block) {
  if (!block.address || block.size == 0) {
    return;
  }
  VirtualFree(block.address, 0, MEM_RELEASE);
}

} // namespace w1::h00k::memory

```

`src/w1h00k/os/os.cpp`:

```cpp
#include "w1h00k/os/os.hpp"

namespace w1::h00k::os {

void stub() {}

} // namespace w1::h00k::os

```

`src/w1h00k/os/os.hpp`:

```hpp
#pragma once

namespace w1::h00k::os {

void stub();

} // namespace w1::h00k::os

```

`src/w1h00k/patcher/patcher.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>

namespace w1::h00k {

class code_patcher {
public:
  bool write(void* address, const uint8_t* bytes, size_t size);
  bool restore(void* address, const uint8_t* bytes, size_t size);
};

class data_patcher {
public:
  bool write(void* address, const uint8_t* bytes, size_t size);
  bool restore(void* address, const uint8_t* bytes, size_t size);
};

} // namespace w1::h00k

```

`src/w1h00k/patcher/posix.cpp`:

```cpp
#include "w1h00k/patcher/patcher.hpp"

#include <cstdio>
#include <cstdint>
#include <cstring>

#include <sys/mman.h>
#include <unistd.h>

#if defined(__APPLE__)
#include <mach/mach.h>
#include <mach/mach_vm.h>
#include <mach/vm_region.h>
#include <pthread.h>
#endif

namespace w1::h00k {
namespace {

size_t page_size() {
  long size = sysconf(_SC_PAGESIZE);
  if (size <= 0) {
    return 4096;
  }
  return static_cast<size_t>(size);
}

bool protect_region(void* address, size_t size, bool writable) {
  if (!address || size == 0) {
    return false;
  }

  const size_t page = page_size();
  const uintptr_t start = reinterpret_cast<uintptr_t>(address);
  const uintptr_t page_start = start & ~(static_cast<uintptr_t>(page) - 1);
  const uintptr_t end = start + size;
  const uintptr_t page_end = (end + page - 1) & ~(static_cast<uintptr_t>(page) - 1);
  const size_t total = page_end - page_start;

#if defined(__APPLE__)
  vm_prot_t prot = writable ? (VM_PROT_READ | VM_PROT_WRITE | VM_PROT_COPY) : (VM_PROT_READ | VM_PROT_EXECUTE);
  return vm_protect(mach_task_self(), page_start, total, false, prot) == KERN_SUCCESS;
#else
  int prot = writable ? (PROT_READ | PROT_WRITE) : (PROT_READ | PROT_EXEC);
  return mprotect(reinterpret_cast<void*>(page_start), total, prot) == 0;
#endif
}

bool apply_region_protection(void* address, size_t size,
#if defined(__APPLE__)
                             vm_prot_t prot
#else
                             int prot
#endif
) {
  if (!address || size == 0) {
    return false;
  }

  const size_t page = page_size();
  const uintptr_t start = reinterpret_cast<uintptr_t>(address);
  const uintptr_t page_start = start & ~(static_cast<uintptr_t>(page) - 1);
  const uintptr_t end = start + size;
  const uintptr_t page_end = (end + page - 1) & ~(static_cast<uintptr_t>(page) - 1);
  const size_t total = page_end - page_start;

#if defined(__APPLE__)
  return vm_protect(mach_task_self(), page_start, total, false, prot) == KERN_SUCCESS;
#else
  return mprotect(reinterpret_cast<void*>(page_start), total, prot) == 0;
#endif
}

void flush_icache(void* address, size_t size) {
  if (!address || size == 0) {
    return;
  }
  auto start = reinterpret_cast<char*>(address);
  __builtin___clear_cache(start, start + size);
}

#if defined(__APPLE__)
bool region_is_writable(void* address) {
  mach_vm_address_t query_address = reinterpret_cast<mach_vm_address_t>(address);
  mach_vm_size_t size = 0;
  vm_region_extended_info_data_t info{};
  mach_msg_type_number_t count = VM_REGION_EXTENDED_INFO_COUNT;
  memory_object_name_t object = MACH_PORT_NULL;

  const kern_return_t status = mach_vm_region(mach_task_self(), &query_address, &size, VM_REGION_EXTENDED_INFO,
                                              reinterpret_cast<vm_region_info_t>(&info), &count, &object);
  if (status != KERN_SUCCESS) {
    return false;
  }
  return (info.protection & VM_PROT_WRITE) != 0;
}

bool query_region_protection(void* address, vm_prot_t& prot_out) {
  mach_vm_address_t query_address = reinterpret_cast<mach_vm_address_t>(address);
  mach_vm_size_t size = 0;
  vm_region_basic_info_data_64_t info{};
  mach_msg_type_number_t count = VM_REGION_BASIC_INFO_COUNT_64;
  memory_object_name_t object = MACH_PORT_NULL;

  const kern_return_t status = mach_vm_region(mach_task_self(), &query_address, &size, VM_REGION_BASIC_INFO_64,
                                              reinterpret_cast<vm_region_info_t>(&info), &count, &object);
  if (status != KERN_SUCCESS) {
    return false;
  }
  prot_out = info.protection;
  return true;
}
#else
bool query_region_protection(void* address, int& prot_out) {
  FILE* maps = std::fopen("/proc/self/maps", "r");
  if (!maps) {
    return false;
  }

  char line[512];
  const uintptr_t addr = reinterpret_cast<uintptr_t>(address);
  while (std::fgets(line, sizeof(line), maps)) {
    unsigned long start = 0;
    unsigned long end = 0;
    char perms[5] = {};
    if (std::sscanf(line, "%lx-%lx %4s", &start, &end, perms) != 3) {
      continue;
    }
    if (addr < start || addr >= end) {
      continue;
    }
    int prot = 0;
    if (perms[0] == 'r') {
      prot |= PROT_READ;
    }
    if (perms[1] == 'w') {
      prot |= PROT_WRITE;
    }
    if (perms[2] == 'x') {
      prot |= PROT_EXEC;
    }
    std::fclose(maps);
    prot_out = prot;
    return true;
  }
  std::fclose(maps);
  return false;
}
#endif

class jit_write_guard {
public:
  jit_write_guard() {
#if defined(__APPLE__)
    pthread_jit_write_protect_np(0);
#endif
  }

  ~jit_write_guard() {
#if defined(__APPLE__)
    pthread_jit_write_protect_np(1);
#endif
  }
};

} // namespace

bool code_patcher::write(void* address, const uint8_t* bytes, size_t size) {
  if (!address || !bytes || size == 0) {
    return false;
  }
#if defined(__APPLE__)
  const bool needs_protection = !region_is_writable(address);
#else
  const bool needs_protection = true;
#endif
  if (needs_protection && !protect_region(address, size, true)) {
    return false;
  }
  jit_write_guard guard;
  std::memcpy(address, bytes, size);
  flush_icache(address, size);
  if (needs_protection) {
    return protect_region(address, size, false);
  }
  return true;
}

bool code_patcher::restore(void* address, const uint8_t* bytes, size_t size) {
  return write(address, bytes, size);
}

bool data_patcher::write(void* address, const uint8_t* bytes, size_t size) {
  if (!address || !bytes || size == 0) {
    return false;
  }

#if defined(__APPLE__)
  vm_prot_t original = VM_PROT_READ;
  if (!query_region_protection(address, original)) {
    return false;
  }
  const vm_prot_t writable = original | VM_PROT_WRITE | VM_PROT_COPY;
  if (!apply_region_protection(address, size, writable)) {
    return false;
  }
#else
  int original = PROT_READ;
  if (!query_region_protection(address, original)) {
    return false;
  }
  const int writable = original | PROT_WRITE;
  if (!apply_region_protection(address, size, writable)) {
    return false;
  }
#endif

  jit_write_guard guard;
  std::memcpy(address, bytes, size);
  flush_icache(address, size);

#if defined(__APPLE__)
  return apply_region_protection(address, size, original);
#else
  return apply_region_protection(address, size, original);
#endif
}

bool data_patcher::restore(void* address, const uint8_t* bytes, size_t size) {
  return write(address, bytes, size);
}

} // namespace w1::h00k

```

`src/w1h00k/patcher/windows.cpp`:

```cpp
#include "w1h00k/patcher/patcher.hpp"

#include <cstdint>
#include <cstring>

#include <windows.h>

namespace w1::h00k {
namespace {

bool protect_region(void* address, size_t size, bool writable) {
  if (!address || size == 0) {
    return false;
  }

  DWORD old_protect = 0;
  DWORD new_protect = writable ? PAGE_READWRITE : PAGE_EXECUTE_READ;
  return VirtualProtect(address, size, new_protect, &old_protect) != 0;
}

bool query_region_protection(void* address, DWORD& prot_out) {
  MEMORY_BASIC_INFORMATION info{};
  if (!VirtualQuery(address, &info, sizeof(info))) {
    return false;
  }
  prot_out = info.Protect;
  return true;
}

DWORD make_writable_protect(DWORD original) {
  const DWORD flags = original & 0xFFFFFF00u;
  const DWORD base = original & 0xFFu;
  switch (base) {
    case PAGE_EXECUTE:
    case PAGE_EXECUTE_READ:
    case PAGE_EXECUTE_READWRITE:
    case PAGE_EXECUTE_WRITECOPY:
      return PAGE_EXECUTE_READWRITE | flags;
    default:
      return PAGE_READWRITE | flags;
  }
}

void flush_icache(void* address, size_t size) {
  if (!address || size == 0) {
    return;
  }
  FlushInstructionCache(GetCurrentProcess(), address, size);
}

} // namespace

bool code_patcher::write(void* address, const uint8_t* bytes, size_t size) {
  if (!address || !bytes || size == 0) {
    return false;
  }
  if (!protect_region(address, size, true)) {
    return false;
  }
  std::memcpy(address, bytes, size);
  flush_icache(address, size);
  return protect_region(address, size, false);
}

bool code_patcher::restore(void* address, const uint8_t* bytes, size_t size) {
  return write(address, bytes, size);
}

bool data_patcher::write(void* address, const uint8_t* bytes, size_t size) {
  if (!address || !bytes || size == 0) {
    return false;
  }

  DWORD original = 0;
  if (!query_region_protection(address, original)) {
    return false;
  }
  const DWORD writable = make_writable_protect(original);
  DWORD old_protect = 0;
  if (!VirtualProtect(address, size, writable, &old_protect)) {
    return false;
  }

  std::memcpy(address, bytes, size);
  flush_icache(address, size);

  DWORD ignored = 0;
  return VirtualProtect(address, size, original, &ignored) != 0;
}

bool data_patcher::restore(void* address, const uint8_t* bytes, size_t size) {
  return write(address, bytes, size);
}

} // namespace w1::h00k

```

`src/w1h00k/reloc/arm64.cpp`:

```cpp
#include "w1h00k/reloc/arm64.hpp"

#include <span>

#include "w1asmr/asmr.hpp"
#include "w1h00k/reloc/common.hpp"

namespace w1::h00k::reloc::detail {
namespace {

uint32_t read_u32_le(const uint8_t* bytes) {
  uint32_t value = 0;
  std::memcpy(&value, bytes, sizeof(value));
  return value;
}

void write_u32_le(std::vector<uint8_t>& out, size_t offset, uint32_t value) {
  std::memcpy(out.data() + offset, &value, sizeof(value));
}

void append_u32(std::vector<uint8_t>& out, uint32_t value) {
  const size_t offset = out.size();
  out.resize(offset + sizeof(value));
  std::memcpy(out.data() + offset, &value, sizeof(value));
}

void append_u64(std::vector<uint8_t>& out, uint64_t value) {
  const size_t offset = out.size();
  out.resize(offset + sizeof(value));
  std::memcpy(out.data() + offset, &value, sizeof(value));
}

bool arm64_is_b(uint32_t inst) { return (inst & 0xFC000000u) == 0x14000000u; }
bool arm64_is_bl(uint32_t inst) { return (inst & 0xFC000000u) == 0x94000000u; }
bool arm64_is_bcond(uint32_t inst) { return (inst & 0xFF000010u) == 0x54000000u; }
bool arm64_is_cbz(uint32_t inst) { return (inst & 0x7F000000u) == 0x34000000u; }
bool arm64_is_cbnz(uint32_t inst) { return (inst & 0x7F000000u) == 0x35000000u; }
bool arm64_is_tbz(uint32_t inst) { return (inst & 0x7F000000u) == 0x36000000u; }
bool arm64_is_tbnz(uint32_t inst) { return (inst & 0x7F000000u) == 0x37000000u; }
bool arm64_is_adr(uint32_t inst) { return (inst & 0x9F000000u) == 0x10000000u; }
bool arm64_is_adrp(uint32_t inst) { return (inst & 0x9F000000u) == 0x90000000u; }

enum class arm64_fixup_kind {
  none,
  b,
  bl,
  bcond,
  cbz,
  cbnz,
  tbz,
  tbnz,
  adr,
  adrp
};

arm64_fixup_kind classify_arm64(uint32_t inst) {
  if (arm64_is_b(inst)) {
    return arm64_fixup_kind::b;
  }
  if (arm64_is_bl(inst)) {
    return arm64_fixup_kind::bl;
  }
  if (arm64_is_bcond(inst)) {
    return arm64_fixup_kind::bcond;
  }
  if (arm64_is_cbz(inst)) {
    return arm64_fixup_kind::cbz;
  }
  if (arm64_is_cbnz(inst)) {
    return arm64_fixup_kind::cbnz;
  }
  if (arm64_is_tbz(inst)) {
    return arm64_fixup_kind::tbz;
  }
  if (arm64_is_tbnz(inst)) {
    return arm64_fixup_kind::tbnz;
  }
  if (arm64_is_adr(inst)) {
    return arm64_fixup_kind::adr;
  }
  if (arm64_is_adrp(inst)) {
    return arm64_fixup_kind::adrp;
  }
  return arm64_fixup_kind::none;
}

uint64_t arm64_branch_target(uint32_t inst, uint64_t pc) {
  if (arm64_is_b(inst) || arm64_is_bl(inst)) {
    const int64_t imm26 = detail::sign_extend(inst & 0x03FFFFFFu, 26) << 2;
    return pc + static_cast<uint64_t>(imm26);
  }
  if (arm64_is_bcond(inst) || arm64_is_cbz(inst) || arm64_is_cbnz(inst)) {
    const int64_t imm19 = detail::sign_extend((inst >> 5) & 0x7FFFFu, 19) << 2;
    return pc + static_cast<uint64_t>(imm19);
  }
  if (arm64_is_tbz(inst) || arm64_is_tbnz(inst)) {
    const int64_t imm14 = detail::sign_extend((inst >> 5) & 0x3FFFu, 14) << 2;
    return pc + static_cast<uint64_t>(imm14);
  }
  if (arm64_is_adr(inst)) {
    const uint32_t immlo = (inst >> 29) & 0x3u;
    const uint32_t immhi = (inst >> 5) & 0x7FFFFu;
    const int64_t imm = detail::sign_extend((immhi << 2) | immlo, 21);
    return pc + static_cast<uint64_t>(imm);
  }
  if (arm64_is_adrp(inst)) {
    const uint32_t immlo = (inst >> 29) & 0x3u;
    const uint32_t immhi = (inst >> 5) & 0x7FFFFu;
    const int64_t imm = detail::sign_extend((immhi << 2) | immlo, 21) << 12;
    const uint64_t page = pc & ~0xFFFULL;
    return page + static_cast<uint64_t>(imm);
  }
  return pc;
}

bool arm64_patch_imm26(uint32_t& inst, int64_t offset) {
  if (offset % 4 != 0) {
    return false;
  }
  const int64_t imm = offset >> 2;
  if (!detail::fits_signed(imm, 26)) {
    return false;
  }
  inst = (inst & 0xFC000000u) | (static_cast<uint32_t>(imm) & 0x03FFFFFFu);
  return true;
}

bool arm64_patch_imm19(uint32_t& inst, int64_t offset) {
  if (offset % 4 != 0) {
    return false;
  }
  const int64_t imm = offset >> 2;
  if (!detail::fits_signed(imm, 19)) {
    return false;
  }
  inst &= ~(0x7FFFFu << 5);
  inst |= (static_cast<uint32_t>(imm) & 0x7FFFFu) << 5;
  return true;
}

bool arm64_patch_imm14(uint32_t& inst, int64_t offset) {
  if (offset % 4 != 0) {
    return false;
  }
  const int64_t imm = offset >> 2;
  if (!detail::fits_signed(imm, 14)) {
    return false;
  }
  inst &= ~(0x3FFFu << 5);
  inst |= (static_cast<uint32_t>(imm) & 0x3FFFu) << 5;
  return true;
}

bool arm64_patch_adr(uint32_t& inst, int64_t offset) {
  if (!detail::fits_signed(offset, 21)) {
    return false;
  }
  uint32_t imm = static_cast<uint32_t>(offset) & 0x1FFFFF;
  uint32_t immlo = imm & 0x3u;
  uint32_t immhi = (imm >> 2) & 0x7FFFFu;
  inst &= ~((0x3u << 29) | (0x7FFFFu << 5));
  inst |= (immlo << 29) | (immhi << 5);
  return true;
}

bool arm64_patch_adrp(uint32_t& inst, int64_t page_delta) {
  const int64_t imm = page_delta >> 12;
  if (!detail::fits_signed(imm, 21)) {
    return false;
  }
  uint32_t imm21 = static_cast<uint32_t>(imm) & 0x1FFFFF;
  uint32_t immlo = imm21 & 0x3u;
  uint32_t immhi = (imm21 >> 2) & 0x7FFFFu;
  inst &= ~((0x3u << 29) | (0x7FFFFu << 5));
  inst |= (immlo << 29) | (immhi << 5);
  return true;
}

uint32_t arm64_encode_ldr_literal(uint8_t rt, int32_t imm19) {
  return 0x58000000u | ((static_cast<uint32_t>(imm19) & 0x7FFFFu) << 5) | (rt & 0x1Fu);
}

uint32_t arm64_encode_br(uint8_t rn) { return 0xD61F0000u | ((rn & 0x1Fu) << 5); }
uint32_t arm64_encode_blr(uint8_t rn) { return 0xD63F0000u | ((rn & 0x1Fu) << 5); }

bool emit_arm64_ldr_literal(std::vector<uint8_t>& out, uint8_t rt, uint64_t value) {
  const int32_t imm19 = 1; // literal at +4 bytes
  if (!detail::fits_signed(imm19, 19)) {
    return false;
  }
  append_u32(out, arm64_encode_ldr_literal(rt, imm19));
  append_u64(out, value);
  return true;
}

bool emit_arm64_abs_branch(std::vector<uint8_t>& out, uint64_t target, bool is_call) {
  constexpr uint8_t scratch = 16;
  const int32_t imm19 = 2; // literal at +8 bytes
  append_u32(out, arm64_encode_ldr_literal(scratch, imm19));
  append_u32(out, is_call ? arm64_encode_blr(scratch) : arm64_encode_br(scratch));
  append_u64(out, target);
  return true;
}

bool emit_arm64_cond_stub(std::vector<uint8_t>& out, uint32_t inst, uint64_t target) {
  constexpr int64_t stub_len = 16;
  constexpr int64_t skip = stub_len;
  uint32_t skip_inst = inst;
  if (arm64_is_bcond(inst)) {
    const uint32_t cond = inst & 0xFu;
    skip_inst = (inst & ~0xFu) | ((cond ^ 1u) & 0xFu);
    if (!arm64_patch_imm19(skip_inst, skip)) {
      return false;
    }
  } else if (arm64_is_cbz(inst) || arm64_is_cbnz(inst)) {
    skip_inst = inst ^ 0x01000000u;
    if (!arm64_patch_imm19(skip_inst, skip)) {
      return false;
    }
  } else if (arm64_is_tbz(inst) || arm64_is_tbnz(inst)) {
    skip_inst = inst ^ 0x01000000u;
    if (!arm64_patch_imm14(skip_inst, skip)) {
      return false;
    }
  } else {
    return false;
  }

  append_u32(out, skip_inst);
  return emit_arm64_abs_branch(out, target, false);
}

} // namespace

reloc_result relocate_arm64(const w1::asmr::disasm_context& disasm, const void* target, size_t min_patch_size,
                            uint64_t trampoline_address) {
  auto fail = [](reloc_error error) {
    reloc_result out{};
    out.error = error;
    return out;
  };

  reloc_result result{};
  result.error = reloc_error::ok;

  auto bytes = std::span<const uint8_t>(reinterpret_cast<const uint8_t*>(target), kMaxPatchBytes);
  auto decoded = disasm.disassemble(bytes, reinterpret_cast<uint64_t>(target));
  if (!decoded.ok()) {
    return fail(reloc_error::decode_failed);
  }

  size_t consumed = 0;
  for (const auto& insn : decoded.value) {
    if (insn.bytes.empty()) {
      break;
    }

    const size_t insn_len = insn.bytes.size();
    if (insn_len != 4) {
      return fail(reloc_error::unsupported_instruction);
    }

    const size_t out_base = result.trampoline_bytes.size();
    result.trampoline_bytes.insert(result.trampoline_bytes.end(), insn.bytes.begin(), insn.bytes.end());

    uint32_t inst = read_u32_le(insn.bytes.data());
    const arm64_fixup_kind kind = classify_arm64(inst);
    const bool needs_fixup = kind != arm64_fixup_kind::none;

    if (needs_fixup) {
      if (trampoline_address == 0) {
        return fail(reloc_error::missing_trampoline);
      }
      const uint64_t insn_addr = insn.address;
      const uint64_t new_addr = trampoline_address + out_base;
      const uint64_t target_addr = arm64_branch_target(inst, insn_addr);

      if (kind == arm64_fixup_kind::b || kind == arm64_fixup_kind::bl) {
        const int64_t offset = static_cast<int64_t>(target_addr) - static_cast<int64_t>(new_addr);
        if (!arm64_patch_imm26(inst, offset)) {
          result.trampoline_bytes.resize(out_base);
          const bool is_call = kind == arm64_fixup_kind::bl;
          if (!emit_arm64_abs_branch(result.trampoline_bytes, target_addr, is_call)) {
            return fail(reloc_error::out_of_range);
          }
          consumed += insn_len;
          if (consumed >= min_patch_size) {
            break;
          }
          continue;
        }
      } else if (kind == arm64_fixup_kind::bcond || kind == arm64_fixup_kind::cbz || kind == arm64_fixup_kind::cbnz) {
        const int64_t offset = static_cast<int64_t>(target_addr) - static_cast<int64_t>(new_addr);
        if (!arm64_patch_imm19(inst, offset)) {
          result.trampoline_bytes.resize(out_base);
          if (!emit_arm64_cond_stub(result.trampoline_bytes, inst, target_addr)) {
            return fail(reloc_error::out_of_range);
          }
          consumed += insn_len;
          if (consumed >= min_patch_size) {
            break;
          }
          continue;
        }
      } else if (kind == arm64_fixup_kind::tbz || kind == arm64_fixup_kind::tbnz) {
        const int64_t offset = static_cast<int64_t>(target_addr) - static_cast<int64_t>(new_addr);
        if (!arm64_patch_imm14(inst, offset)) {
          result.trampoline_bytes.resize(out_base);
          if (!emit_arm64_cond_stub(result.trampoline_bytes, inst, target_addr)) {
            return fail(reloc_error::out_of_range);
          }
          consumed += insn_len;
          if (consumed >= min_patch_size) {
            break;
          }
          continue;
        }
      } else if (kind == arm64_fixup_kind::adr) {
        const int64_t offset = static_cast<int64_t>(target_addr) - static_cast<int64_t>(new_addr);
        if (!arm64_patch_adr(inst, offset)) {
          result.trampoline_bytes.resize(out_base);
          const uint8_t rt = static_cast<uint8_t>(inst & 0x1Fu);
          if (!emit_arm64_ldr_literal(result.trampoline_bytes, rt, target_addr)) {
            return fail(reloc_error::out_of_range);
          }
          consumed += insn_len;
          if (consumed >= min_patch_size) {
            break;
          }
          continue;
        }
      } else if (kind == arm64_fixup_kind::adrp) {
        const uint64_t target_page = target_addr & ~0xFFFULL;
        const uint64_t new_page = new_addr & ~0xFFFULL;
        const int64_t page_delta = static_cast<int64_t>(target_page) - static_cast<int64_t>(new_page);
        if (!arm64_patch_adrp(inst, page_delta)) {
          result.trampoline_bytes.resize(out_base);
          const uint8_t rt = static_cast<uint8_t>(inst & 0x1Fu);
          if (!emit_arm64_ldr_literal(result.trampoline_bytes, rt, target_page)) {
            return fail(reloc_error::out_of_range);
          }
          consumed += insn_len;
          if (consumed >= min_patch_size) {
            break;
          }
          continue;
        }
      }

      write_u32_le(result.trampoline_bytes, out_base, inst);
    }

    consumed += insn_len;
    if (consumed >= min_patch_size) {
      break;
    }
  }

  if (consumed < min_patch_size) {
    return fail(reloc_error::insufficient_bytes);
  }

  result.patch_size = consumed;
  return result;
}

} // namespace w1::h00k::reloc::detail

```

`src/w1h00k/reloc/arm64.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>

#include "w1h00k/reloc/relocator.hpp"

namespace w1::asmr {
class disasm_context;
}

namespace w1::h00k::reloc::detail {

reloc_result relocate_arm64(const w1::asmr::disasm_context& disasm, const void* target, size_t min_patch_size,
                            uint64_t trampoline_address);

} // namespace w1::h00k::reloc::detail

```

`src/w1h00k/reloc/common.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <vector>

namespace w1::h00k::reloc::detail {

inline constexpr size_t kMaxPatchBytes = 64;

inline int64_t sign_extend(uint64_t value, unsigned bits) {
  if (bits == 0 || bits >= 64) {
    return static_cast<int64_t>(value);
  }
  const uint64_t mask = 1ULL << (bits - 1);
  return static_cast<int64_t>((value ^ mask) - mask);
}

inline bool fits_signed(int64_t value, unsigned bits) {
  if (bits == 0 || bits >= 64) {
    return true;
  }
  const int64_t min = -(1LL << (bits - 1));
  const int64_t max = (1LL << (bits - 1)) - 1;
  return value >= min && value <= max;
}

inline int64_t read_signed_le(const uint8_t* bytes, size_t size) {
  uint64_t value = 0;
  std::memcpy(&value, bytes, size);
  return sign_extend(value, static_cast<unsigned>(size * 8));
}

inline bool write_signed_le(std::vector<uint8_t>& out, size_t offset, size_t size, int64_t value) {
  if (size == 0 || offset + size > out.size()) {
    return false;
  }
  if (size < sizeof(int64_t) && !fits_signed(value, static_cast<unsigned>(size * 8))) {
    return false;
  }
  uint64_t raw = static_cast<uint64_t>(value);
  std::memcpy(out.data() + offset, &raw, size);
  return true;
}

} // namespace w1::h00k::reloc::detail

```

`src/w1h00k/reloc/relocator.cpp`:

```cpp
#include "w1h00k/reloc/relocator.hpp"

#include "w1asmr/asmr.hpp"
#include "w1asmr/result.hpp"
#include "w1base/arch_spec.hpp"
#include "w1h00k/reloc/arm64.hpp"
#include "w1h00k/reloc/common.hpp"
#include "w1h00k/reloc/x86.hpp"

namespace w1::h00k::reloc {

reloc_result relocate(const void* target, size_t min_patch_size) {
  return relocate(target, min_patch_size, 0, w1::arch::detect_host_arch_spec());
}

reloc_result relocate(const void* target, size_t min_patch_size, uint64_t trampoline_address) {
  return relocate(target, min_patch_size, trampoline_address, w1::arch::detect_host_arch_spec());
}

reloc_result relocate(const void* target, size_t min_patch_size, uint64_t trampoline_address,
                      const w1::arch::arch_spec& arch) {
  auto fail = [](reloc_error error) {
    reloc_result out{};
    out.error = error;
    return out;
  };

  if (!target) {
    return fail(reloc_error::invalid_target);
  }
  if (min_patch_size == 0 || min_patch_size > detail::kMaxPatchBytes) {
    return fail(reloc_error::invalid_request);
  }

  auto disasm = w1::asmr::disasm_context::for_arch(arch);
  if (!disasm.ok()) {
    if (disasm.status_info.code == w1::asmr::error_code::unsupported) {
      return fail(reloc_error::unsupported_arch);
    }
    return fail(reloc_error::decode_failed);
  }

  switch (arch.arch_mode) {
    case w1::arch::mode::x86_32:
    case w1::arch::mode::x86_64:
      return detail::relocate_x86(disasm.value, target, min_patch_size, trampoline_address);
    case w1::arch::mode::aarch64:
      return detail::relocate_arm64(disasm.value, target, min_patch_size, trampoline_address);
    default:
      return fail(reloc_error::unsupported_arch);
  }
}

size_t max_trampoline_size(size_t min_patch_size, const w1::arch::arch_spec& arch) {
  if (min_patch_size == 0 || min_patch_size > detail::kMaxPatchBytes) {
    return 0;
  }

  constexpr size_t kX86MinRelocInsn = 2;
  constexpr size_t kX86MaxStubX64 = 16;
  constexpr size_t kX86MaxStubX86 = 12;
  constexpr size_t kArm64InsnBytes = 4;
  constexpr size_t kArm64MaxStub = 20;

  const size_t patch_bytes = detail::kMaxPatchBytes;
  auto ceil_div = [](size_t num, size_t den) {
    return (num + den - 1) / den;
  };

  switch (arch.arch_mode) {
    case w1::arch::mode::x86_32: {
      const size_t max_insns = ceil_div(patch_bytes, kX86MinRelocInsn);
      return max_insns * kX86MaxStubX86;
    }
    case w1::arch::mode::x86_64: {
      const size_t max_insns = ceil_div(patch_bytes, kX86MinRelocInsn);
      return max_insns * kX86MaxStubX64;
    }
    case w1::arch::mode::aarch64: {
      const size_t max_insns = ceil_div(patch_bytes, kArm64InsnBytes);
      return max_insns * kArm64MaxStub;
    }
    default:
      break;
  }

  return 0;
}

const char* to_string(reloc_error error) {
  switch (error) {
    case reloc_error::ok:
      return "ok";
    case reloc_error::invalid_target:
      return "invalid_target";
    case reloc_error::invalid_request:
      return "invalid_request";
    case reloc_error::unsupported_arch:
      return "unsupported_arch";
    case reloc_error::decode_failed:
      return "decode_failed";
    case reloc_error::insufficient_bytes:
      return "insufficient_bytes";
    case reloc_error::missing_trampoline:
      return "missing_trampoline";
    case reloc_error::unsupported_instruction:
      return "unsupported_instruction";
    case reloc_error::out_of_range:
      return "out_of_range";
  }
  return "unknown";
}

} // namespace w1::h00k::reloc

```

`src/w1h00k/reloc/relocator.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <vector>

#include "w1base/arch_spec.hpp"

namespace w1::h00k::reloc {

enum class reloc_error {
  ok,
  invalid_target,
  invalid_request,
  unsupported_arch,
  decode_failed,
  insufficient_bytes,
  missing_trampoline,
  unsupported_instruction,
  out_of_range
};

const char* to_string(reloc_error error);

struct reloc_result {
  std::vector<uint8_t> trampoline_bytes{};
  size_t patch_size = 0;
  reloc_error error = reloc_error::invalid_request;

  bool ok() const { return error == reloc_error::ok; }
};

reloc_result relocate(const void* target, size_t min_patch_size);
reloc_result relocate(const void* target, size_t min_patch_size, uint64_t trampoline_address);
reloc_result relocate(const void* target, size_t min_patch_size, uint64_t trampoline_address,
                      const w1::arch::arch_spec& arch);
size_t max_trampoline_size(size_t min_patch_size, const w1::arch::arch_spec& arch);

} // namespace w1::h00k::reloc

```

`src/w1h00k/reloc/x86.cpp`:

```cpp
#include "w1h00k/reloc/x86.hpp"

#include <span>

#include "w1asmr/asmr.hpp"
#include "w1base/arch_spec.hpp"
#include "w1h00k/reloc/common.hpp"

namespace w1::h00k::reloc::detail {
namespace {

enum class branch_kind {
  none,
  jmp,
  call,
  jcc
};

struct branch_info {
  branch_kind kind = branch_kind::none;
  uint8_t cond = 0;
  size_t imm_offset = 0;
  size_t imm_size = 0;
  size_t insn_len = 0;
  uint64_t target = 0;
};

bool has_pc_relative_mem(const w1::asmr::instruction& insn) {
  for (const auto& operand : insn.operand_details) {
    if (operand.kind != w1::asmr::operand_kind::mem) {
      continue;
    }
    if (operand.is_pc_relative) {
      return true;
    }
  }
  return false;
}

branch_kind classify_branch(const w1::asmr::instruction& insn, uint8_t& cond_out) {
  cond_out = 0;
  if (insn.bytes.empty()) {
    return branch_kind::none;
  }
  const uint8_t op0 = insn.bytes[0];
  if (op0 == 0xE9) {
    return branch_kind::jmp;
  }
  if (op0 == 0xE8) {
    return branch_kind::call;
  }
  if (op0 >= 0x70 && op0 <= 0x7F) {
    cond_out = static_cast<uint8_t>(op0 & 0x0F);
    return branch_kind::jcc;
  }
  if (op0 == 0x0F && insn.bytes.size() >= 2) {
    const uint8_t op1 = insn.bytes[1];
    if (op1 >= 0x80 && op1 <= 0x8F) {
      cond_out = static_cast<uint8_t>(op1 & 0x0F);
      return branch_kind::jcc;
    }
  }
  return branch_kind::none;
}

bool emit_abs_branch(std::vector<uint8_t>& out, uint64_t trampoline_address, uint64_t target, bool is_call,
                     bool is_x64) {
  if (is_x64) {
    out.push_back(0xFF);
    out.push_back(is_call ? 0x15 : 0x25);
    out.insert(out.end(), {0x00, 0x00, 0x00, 0x00});
    for (int i = 0; i < 8; ++i) {
      out.push_back(static_cast<uint8_t>((target >> (i * 8)) & 0xFFu));
    }
    return true;
  }

  const uint64_t literal_addr = trampoline_address + out.size() + 6;
  if (literal_addr > 0xFFFFFFFFu) {
    return false;
  }
  out.push_back(0xFF);
  out.push_back(is_call ? 0x15 : 0x25);
  const uint32_t addr32 = static_cast<uint32_t>(literal_addr);
  for (int i = 0; i < 4; ++i) {
    out.push_back(static_cast<uint8_t>((addr32 >> (i * 8)) & 0xFFu));
  }
  const uint32_t target32 = static_cast<uint32_t>(target & 0xFFFFFFFFu);
  for (int i = 0; i < 4; ++i) {
    out.push_back(static_cast<uint8_t>((target32 >> (i * 8)) & 0xFFu));
  }
  return true;
}

bool emit_jcc_stub(std::vector<uint8_t>& out, uint64_t trampoline_address, uint64_t target, uint8_t cond,
                   bool is_x64) {
  const uint8_t inverted = static_cast<uint8_t>(cond ^ 0x1);
  const size_t stub_len = is_x64 ? 14 : 10;
  if (stub_len > 0x7F) {
    return false;
  }
  out.push_back(static_cast<uint8_t>(0x70 | inverted));
  out.push_back(static_cast<uint8_t>(stub_len));
  return emit_abs_branch(out, trampoline_address, target, false, is_x64);
}

bool apply_branch_fixup(std::vector<uint8_t>& out, const branch_info& branch, uint64_t trampoline_address,
                        size_t out_base, bool is_x64, reloc_error& error) {
  const uint64_t insn_end = trampoline_address + out_base + branch.insn_len;
  const int64_t new_disp = static_cast<int64_t>(branch.target) - static_cast<int64_t>(insn_end);
  if (write_signed_le(out, out_base + branch.imm_offset, branch.imm_size, new_disp)) {
    return true;
  }

  out.resize(out_base);
  bool stub_ok = false;
  if (branch.kind == branch_kind::jmp || branch.kind == branch_kind::call) {
    stub_ok = emit_abs_branch(out, trampoline_address, branch.target, branch.kind == branch_kind::call, is_x64);
  } else if (branch.kind == branch_kind::jcc) {
    stub_ok = emit_jcc_stub(out, trampoline_address, branch.target, branch.cond, is_x64);
  }
  if (!stub_ok) {
    error = reloc_error::out_of_range;
    return false;
  }
  return true;
}

bool apply_pc_relative_fixup(std::vector<uint8_t>& out, const w1::asmr::instruction& insn, uint64_t trampoline_address,
                             size_t out_base, reloc_error& error) {
  if (insn.encoding_info.disp_size == 0) {
    error = reloc_error::unsupported_instruction;
    return false;
  }
  const int64_t orig_disp = read_signed_le(insn.bytes.data() + insn.encoding_info.disp_offset,
                                           insn.encoding_info.disp_size);
  const uint64_t target_addr = insn.address + insn.bytes.size() + static_cast<int64_t>(orig_disp);
  const uint64_t insn_end = trampoline_address + out_base + insn.bytes.size();
  const int64_t new_disp = static_cast<int64_t>(target_addr) - static_cast<int64_t>(insn_end);
  if (!write_signed_le(out, out_base + insn.encoding_info.disp_offset, insn.encoding_info.disp_size, new_disp)) {
    error = reloc_error::out_of_range;
    return false;
  }
  return true;
}

} // namespace

reloc_result relocate_x86(const w1::asmr::disasm_context& disasm, const void* target, size_t min_patch_size,
                          uint64_t trampoline_address) {
  auto fail = [](reloc_error error) {
    reloc_result out{};
    out.error = error;
    return out;
  };

  reloc_result result{};
  result.error = reloc_error::ok;

  auto bytes = std::span<const uint8_t>(reinterpret_cast<const uint8_t*>(target), kMaxPatchBytes);
  auto decoded = disasm.disassemble(bytes, reinterpret_cast<uint64_t>(target));
  if (!decoded.ok()) {
    return fail(reloc_error::decode_failed);
  }

  size_t consumed = 0;
  const bool is_x64 = disasm.architecture().arch_mode == w1::arch::mode::x86_64;
  for (const auto& insn : decoded.value) {
    if (insn.bytes.empty()) {
      break;
    }

    const size_t insn_len = insn.bytes.size();
    const size_t out_base = result.trampoline_bytes.size();
    const bool pc_relative_mem = has_pc_relative_mem(insn);
    const bool branch_relative = insn.is_branch_relative;
    branch_info branch{};
    if (branch_relative) {
      branch.cond = 0;
      branch.kind = classify_branch(insn, branch.cond);
      branch.imm_offset = insn.encoding_info.imm_offset;
      branch.imm_size = insn.encoding_info.imm_size;
      branch.insn_len = insn_len;
    }

    if (branch_relative && branch.kind == branch_kind::none) {
      return fail(reloc_error::unsupported_instruction);
    }

    if (pc_relative_mem || branch_relative) {
      if (trampoline_address == 0) {
        return fail(reloc_error::missing_trampoline);
      }
    }

    result.trampoline_bytes.insert(result.trampoline_bytes.end(), insn.bytes.begin(), insn.bytes.end());

    if (branch_relative) {
      if (branch.imm_size == 0) {
        return fail(reloc_error::unsupported_instruction);
      }
      const int64_t orig_disp = read_signed_le(insn.bytes.data() + branch.imm_offset, branch.imm_size);
      branch.target = insn.address + insn_len + static_cast<int64_t>(orig_disp);
      reloc_error error = reloc_error::ok;
      if (!apply_branch_fixup(result.trampoline_bytes, branch, trampoline_address, out_base, is_x64, error)) {
        return fail(error);
      }
    }

    if (pc_relative_mem) {
      reloc_error error = reloc_error::ok;
      if (!apply_pc_relative_fixup(result.trampoline_bytes, insn, trampoline_address, out_base, error)) {
        return fail(error);
      }
    }

    consumed += insn_len;
    if (consumed >= min_patch_size) {
      break;
    }
  }

  if (consumed < min_patch_size) {
    return fail(reloc_error::insufficient_bytes);
  }

  result.patch_size = consumed;
  return result;
}

} // namespace w1::h00k::reloc::detail

```

`src/w1h00k/reloc/x86.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>

#include "w1h00k/reloc/relocator.hpp"

namespace w1::asmr {
class disasm_context;
}

namespace w1::h00k::reloc::detail {

reloc_result relocate_x86(const w1::asmr::disasm_context& disasm, const void* target, size_t min_patch_size,
                          uint64_t trampoline_address);

} // namespace w1::h00k::reloc::detail

```

`src/w1h00k/resolve/module_match.hpp`:

```hpp
#pragma once

#include <cctype>
#include <string>
#include <string_view>

namespace w1::h00k::resolve {

inline std::string_view basename_view(std::string_view path) {
  const size_t pos = path.find_last_of("/\\");
  if (pos == std::string_view::npos) {
    return path;
  }
  return path.substr(pos + 1);
}

enum class module_match_mode {
  auto_detect,
  basename,
  full_path,
};

inline bool has_path_separator(std::string_view value) {
  return value.find('/') != std::string_view::npos || value.find('\\') != std::string_view::npos;
}

inline module_match_mode normalize_match_mode(std::string_view requested, module_match_mode mode) {
  if (mode == module_match_mode::auto_detect) {
    return has_path_separator(requested) ? module_match_mode::full_path : module_match_mode::basename;
  }
  return mode;
}

#if defined(_WIN32)
inline std::string to_lower(std::string_view value) {
  std::string out(value.begin(), value.end());
  for (auto& ch : out) {
    ch = static_cast<char>(std::tolower(static_cast<unsigned char>(ch)));
  }
  return out;
}

inline bool module_matches(const char* requested,
                           std::string_view path,
                           module_match_mode mode = module_match_mode::auto_detect) {
  if (!requested || requested[0] == '\0') {
    return true;
  }
  if (path.empty()) {
    return false;
  }
  const std::string req_lower = to_lower(requested);
  const std::string full_lower = to_lower(path);
  const auto match_mode = normalize_match_mode(std::string_view(requested), mode);
  if (match_mode == module_match_mode::full_path) {
    return full_lower == req_lower;
  }
  const std::string_view base = basename_view(full_lower);
  const std::string_view req_base = basename_view(req_lower);
  return base == req_base;
}
#else
inline bool module_matches(const char* requested,
                           std::string_view path,
                           module_match_mode mode = module_match_mode::auto_detect) {
  if (!requested || requested[0] == '\0') {
    return true;
  }
  if (path.empty()) {
    return false;
  }
  const std::string_view req_view(requested);
  const auto match_mode = normalize_match_mode(req_view, mode);
  if (match_mode == module_match_mode::full_path) {
    return path == req_view;
  }
  return basename_view(path) == basename_view(req_view);
}
#endif

} // namespace w1::h00k::resolve

```

`src/w1h00k/resolve/posix.cpp`:

```cpp
#include "w1h00k/resolve/resolve.hpp"

#include <algorithm>
#include <cstring>
#include <dlfcn.h>
#include <string_view>

#include "w1h00k/resolve/module_match.hpp"
#if defined(__linux__)
#include <elf.h>
#include <link.h>
#include <unistd.h>
#endif

#if defined(__APPLE__)
#include <mach-o/dyld.h>
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#endif

namespace w1::h00k::resolve {
namespace {

hook_error_info make_error(hook_error code, const char* detail) {
  hook_error_info info{};
  info.code = code;
  info.detail = detail;
  return info;
}

module_info module_from_dladdr(void* address) {
  module_info out{};
  Dl_info info{};
  if (address && dladdr(address, &info) != 0) {
    out.base = info.dli_fbase;
    if (info.dli_fname) {
      out.path = info.dli_fname;
    }
  }
  return out;
}

std::string find_module_path(const char* module) {
  if (!module || module[0] == '\0') {
    return {};
  }
  auto modules = enumerate_modules();
  const std::string_view requested(module);
  if (has_path_separator(requested)) {
    for (const auto& entry : modules) {
      if (module_matches(module, entry.path, module_match_mode::full_path)) {
        return entry.path;
      }
    }
    std::string fallback{};
    for (const auto& entry : modules) {
      if (module_matches(module, entry.path, module_match_mode::basename)) {
        if (!fallback.empty()) {
          return {};
        }
        fallback = entry.path;
      }
    }
    return fallback;
  }
  for (const auto& entry : modules) {
    if (module_matches(module, entry.path, module_match_mode::basename)) {
      return entry.path;
    }
  }
  return {};
}

#if defined(__linux__)
struct elf_module_snapshot {
  const dl_phdr_info* info = nullptr;
  std::string path{};
  uintptr_t base = 0;
  size_t size = 0;
};

struct elf_snapshot_view {
  const elf_module_snapshot* snapshot = nullptr;

  bool contains(const void* address, size_t size) const {
    if (!snapshot || !address || size == 0 || snapshot->base == 0 || snapshot->size == 0) {
      return false;
    }
    const uintptr_t start = reinterpret_cast<uintptr_t>(address);
    const uintptr_t base = snapshot->base;
    const uintptr_t end = base + snapshot->size;
    if (start < base || start >= end) {
      return false;
    }
    const uintptr_t last = start + size;
    if (last < start || last > end) {
      return false;
    }
    return true;
  }

  size_t max_span_from(const void* address) const {
    if (!contains(address, 1)) {
      return 0;
    }
    const uintptr_t start = reinterpret_cast<uintptr_t>(address);
    const uintptr_t end = snapshot->base + snapshot->size;
    return end > start ? static_cast<size_t>(end - start) : 0;
  }

  bool string_view_at(const char* name, std::string_view& out) const {
    return string_view_at(name, 0, out);
  }

  bool string_view_at(const char* name, size_t max_len, std::string_view& out) const {
    if (!name) {
      return false;
    }
    size_t limit = max_len;
    if (limit == 0) {
      limit = max_span_from(name);
    } else if (!contains(name, limit)) {
      return false;
    }
    if (limit == 0) {
      return false;
    }
    const void* terminator = std::memchr(name, '\0', limit);
    if (!terminator) {
      return false;
    }
    out = std::string_view(name, static_cast<const char*>(terminator) - name);
    return true;
  }

  uintptr_t resolve_ptr(ElfW(Addr) value) const {
    const uintptr_t addr = static_cast<uintptr_t>(value);
    if (contains(reinterpret_cast<const void*>(addr), 1)) {
      return addr;
    }
    if (!snapshot || !snapshot->info) {
      return addr;
    }
    return static_cast<uintptr_t>(snapshot->info->dlpi_addr) + addr;
  }

  uintptr_t module_offset(ElfW(Addr) value) const {
    if (!snapshot || !snapshot->info) {
      return static_cast<uintptr_t>(value);
    }
    return static_cast<uintptr_t>(snapshot->info->dlpi_addr) + static_cast<uintptr_t>(value);
  }

  bool table_in_module(const void* table, size_t bytes) const {
    if (!table || bytes == 0) {
      return false;
    }
    return contains(table, bytes);
  }
};

std::string resolve_linux_main_path() {
  char buffer[4096] = {};
  const ssize_t len = readlink("/proc/self/exe", buffer, sizeof(buffer) - 1);
  if (len <= 0) {
    return {};
  }
  buffer[len] = '\0';
  return std::string(buffer);
}

elf_module_snapshot snapshot_module(const dl_phdr_info* info) {
  elf_module_snapshot snapshot{};
  snapshot.info = info;

  if (info->dlpi_name && info->dlpi_name[0] != '\0') {
    snapshot.path = info->dlpi_name;
  } else {
    snapshot.path = resolve_linux_main_path();
  }

  uintptr_t low = UINTPTR_MAX;
  uintptr_t high = 0;
  for (size_t i = 0; i < info->dlpi_phnum; ++i) {
    const ElfW(Phdr)& phdr = info->dlpi_phdr[i];
    if (phdr.p_type != PT_LOAD) {
      continue;
    }
    low = std::min(low, static_cast<uintptr_t>(phdr.p_vaddr));
    high = std::max(high, static_cast<uintptr_t>(phdr.p_vaddr + phdr.p_memsz));
  }
  if (low == UINTPTR_MAX) {
    snapshot.base = 0;
    snapshot.size = 0;
    return snapshot;
  }

  snapshot.base = static_cast<uintptr_t>(info->dlpi_addr) + low;
  snapshot.size = high - low;
  return snapshot;
}

uint32_t elf_r_sym(ElfW(Xword) info) {
#if __ELF_NATIVE_CLASS == 64
  return ELF64_R_SYM(info);
#else
  return ELF32_R_SYM(info);
#endif
}

uint32_t elf_r_type(ElfW(Xword) info) {
#if __ELF_NATIVE_CLASS == 64
  return ELF64_R_TYPE(info);
#else
  return ELF32_R_TYPE(info);
#endif
}

bool elf_symbol_matches(std::string_view candidate, std::string_view target) {
  if (candidate.empty() || target.empty()) {
    return false;
  }
  if (candidate == target) {
    return true;
  }
  const size_t at = candidate.find('@');
  if (at == std::string_view::npos) {
    return false;
  }
  return candidate.substr(0, at) == target;
}

bool elf_import_type_supported(uint32_t type) {
#if defined(__x86_64__)
  return type == R_X86_64_JUMP_SLOT || type == R_X86_64_GLOB_DAT;
#elif defined(__i386__)
  return type == R_386_JMP_SLOT || type == R_386_GLOB_DAT;
#elif defined(__aarch64__)
  return type == R_AARCH64_JUMP_SLOT || type == R_AARCH64_GLOB_DAT;
#elif defined(__arm__)
  return type == R_ARM_JUMP_SLOT || type == R_ARM_GLOB_DAT;
#else
  (void)type;
  return false;
#endif
}

bool elf_module_has_needed(const elf_snapshot_view& view, const ElfW(Dyn)* dyn, size_t dyn_count,
                           const char* strtab, size_t strtab_size, const char* needed) {
  if (!needed || needed[0] == '\0') {
    return true;
  }
  if (!dyn || !strtab || dyn_count == 0) {
    return false;
  }
  if (!view.contains(strtab, 1)) {
    return false;
  }
  if (strtab_size != 0 && !view.contains(strtab, strtab_size)) {
    return false;
  }
  if (!view.contains(dyn, dyn_count * sizeof(ElfW(Dyn)))) {
    return false;
  }
  for (size_t i = 0; i < dyn_count; ++i) {
    const ElfW(Dyn)& entry = dyn[i];
    if (entry.d_tag == DT_NULL) {
      break;
    }
    if (entry.d_tag == DT_NEEDED) {
      const size_t offset = entry.d_un.d_val;
      std::string_view name{};
      if (strtab_size != 0) {
        if (offset >= strtab_size) {
          continue;
        }
        if (!view.string_view_at(strtab + offset, strtab_size - offset, name)) {
          continue;
        }
      } else if (!view.string_view_at(strtab + offset, name)) {
        continue;
      }
      if (module_matches(needed, name, module_match_mode::basename)) {
        return true;
      }
    }
  }
  return false;
}

template <typename Reloc>
void** elf_find_import_slot(const elf_snapshot_view& view, const Reloc* relocs, size_t count,
                            const ElfW(Sym)* symtab, const char* strtab, size_t strtab_size,
                            const char* symbol, size_t sym_entry_size) {
  if (!relocs || !symtab || !strtab || !symbol || sym_entry_size == 0) {
    return nullptr;
  }
  if (!view.contains(relocs, count * sizeof(Reloc))) {
    return nullptr;
  }
  if (!view.contains(symtab, sym_entry_size) || !view.contains(strtab, 1)) {
    return nullptr;
  }
  if (strtab_size != 0 && !view.contains(strtab, strtab_size)) {
    return nullptr;
  }
  for (size_t i = 0; i < count; ++i) {
    const Reloc& reloc = relocs[i];
    const uint32_t type = elf_r_type(reloc.r_info);
    if (!elf_import_type_supported(type)) {
      continue;
    }
    const uint32_t sym_index = elf_r_sym(reloc.r_info);
    const uintptr_t sym_offset = static_cast<uintptr_t>(sym_index) * sym_entry_size;
    if (sym_offset / sym_entry_size != sym_index) {
      continue;
    }
    const uintptr_t sym_addr = reinterpret_cast<uintptr_t>(symtab) + sym_offset;
    if (!view.contains(reinterpret_cast<const void*>(sym_addr), sym_entry_size)) {
      continue;
    }
    const auto* sym = reinterpret_cast<const ElfW(Sym)*>(sym_addr);
    const size_t name_offset = sym->st_name;
    std::string_view candidate{};
    if (strtab_size != 0) {
      if (name_offset >= strtab_size) {
        continue;
      }
      if (!view.string_view_at(strtab + name_offset, strtab_size - name_offset, candidate)) {
        continue;
      }
    } else if (!view.string_view_at(strtab + name_offset, candidate)) {
      continue;
    }
    if (!elf_symbol_matches(candidate, std::string_view(symbol))) {
      continue;
    }
    const uintptr_t addr = view.module_offset(reloc.r_offset);
    return reinterpret_cast<void**>(addr);
  }
  return nullptr;
}

import_resolution resolve_import_elf(const char* symbol, const char* module, const char* import_module) {
  import_resolution result{};
  if (!symbol || symbol[0] == '\0') {
    result.error = make_error(hook_error::invalid_target, "missing_symbol");
    return result;
  }

  struct context {
    const char* symbol = nullptr;
    const char* module = nullptr;
    const char* import_module = nullptr;
    import_resolution result{};
    bool found = false;
  } ctx;
  ctx.symbol = symbol;
  ctx.module = module;
  ctx.import_module = import_module;

  auto callback = [](struct dl_phdr_info* info, size_t, void* data) -> int {
    auto* ctx = static_cast<context*>(data);
    const elf_module_snapshot snapshot = snapshot_module(info);
    const elf_snapshot_view view{&snapshot};
    const bool want_main = (!ctx->module || ctx->module[0] == '\0');
    if (want_main) {
      if (info->dlpi_name && info->dlpi_name[0] != '\0') {
        return 0;
      }
    } else {
      if (!module_matches(ctx->module, snapshot.path)) {
        return 0;
      }
    }

    const ElfW(Phdr)* dynamic_phdr = nullptr;
    for (size_t i = 0; i < info->dlpi_phnum; ++i) {
      if (info->dlpi_phdr[i].p_type == PT_DYNAMIC) {
        dynamic_phdr = &info->dlpi_phdr[i];
        break;
      }
    }
    if (!dynamic_phdr) {
      return 0;
    }

    const ElfW(Dyn)* dyn = reinterpret_cast<const ElfW(Dyn)*>(info->dlpi_addr + dynamic_phdr->p_vaddr);
    const size_t dyn_bytes = dynamic_phdr->p_memsz;
    const size_t dyn_count = dyn_bytes / sizeof(ElfW(Dyn));
    if (dyn_count == 0 || !view.contains(dyn, dyn_bytes)) {
      return 0;
    }
    const ElfW(Sym)* symtab = nullptr;
    const char* strtab = nullptr;
    const void* jmprel = nullptr;
    size_t pltrelsz = 0;
    bool pltrel_rela = true;
    const ElfW(Rela)* rela = nullptr;
    size_t relasz = 0;
    size_t relaent = sizeof(ElfW(Rela));
    size_t syment = sizeof(ElfW(Sym));
    size_t strsz = 0;
    const ElfW(Rel)* rel = nullptr;
    size_t relsz = 0;
    size_t relent = sizeof(ElfW(Rel));

    for (size_t i = 0; i < dyn_count; ++i) {
      const ElfW(Dyn)& entry = dyn[i];
      if (entry.d_tag == DT_NULL) {
        break;
      }
      switch (entry.d_tag) {
        case DT_SYMTAB:
          symtab = reinterpret_cast<const ElfW(Sym)*>(view.resolve_ptr(entry.d_un.d_ptr));
          break;
        case DT_STRTAB:
          strtab = reinterpret_cast<const char*>(view.resolve_ptr(entry.d_un.d_ptr));
          break;
        case DT_JMPREL:
          jmprel = reinterpret_cast<const void*>(view.resolve_ptr(entry.d_un.d_ptr));
          break;
        case DT_PLTRELSZ:
          pltrelsz = entry.d_un.d_val;
          break;
        case DT_PLTREL:
          pltrel_rela = (entry.d_un.d_val == DT_RELA);
          break;
        case DT_RELA:
          rela = reinterpret_cast<const ElfW(Rela)*>(view.resolve_ptr(entry.d_un.d_ptr));
          break;
        case DT_RELASZ:
          relasz = entry.d_un.d_val;
          break;
        case DT_RELAENT:
          relaent = entry.d_un.d_val;
          break;
        case DT_SYMENT:
          syment = entry.d_un.d_val;
          break;
        case DT_STRSZ:
          strsz = entry.d_un.d_val;
          break;
        case DT_REL:
          rel = reinterpret_cast<const ElfW(Rel)*>(view.resolve_ptr(entry.d_un.d_ptr));
          break;
        case DT_RELSZ:
          relsz = entry.d_un.d_val;
          break;
        case DT_RELENT:
          relent = entry.d_un.d_val;
          break;
        default:
          break;
      }
    }

    if (relaent == 0) {
      relaent = sizeof(ElfW(Rela));
    }
    if (relent == 0) {
      relent = sizeof(ElfW(Rel));
    }
    if (syment < sizeof(ElfW(Sym))) {
      syment = sizeof(ElfW(Sym));
    }

    if (ctx->import_module && ctx->import_module[0] != '\0') {
      if (!strtab || !view.contains(strtab, 1)) {
        return 0;
      }
      if (!elf_module_has_needed(view, dyn, dyn_count, strtab, strsz, ctx->import_module)) {
        return 0;
      }
    }

    if (!symtab || !strtab) {
      return 0;
    }
    if (!view.contains(symtab, syment) || !view.contains(strtab, 1)) {
      return 0;
    }
    if (strsz != 0 && !view.contains(strtab, strsz)) {
      return 0;
    }

    auto table_in_module = [&](const void* table, size_t bytes) {
      return view.table_in_module(table, bytes);
    };

    void** slot = nullptr;
    if (jmprel && pltrelsz > 0 && table_in_module(jmprel, pltrelsz)) {
      if (pltrel_rela) {
        const size_t count = pltrelsz / relaent;
        slot = elf_find_import_slot(view, reinterpret_cast<const ElfW(Rela)*>(jmprel), count, symtab, strtab, strsz,
                                    ctx->symbol, syment);
      } else {
        const size_t count = pltrelsz / relent;
        slot = elf_find_import_slot(view, reinterpret_cast<const ElfW(Rel)*>(jmprel), count, symtab, strtab, strsz,
                                    ctx->symbol, syment);
      }
    }

    if (!slot && rela && relasz > 0 && table_in_module(rela, relasz)) {
      const size_t count = relasz / relaent;
      slot = elf_find_import_slot(view, rela, count, symtab, strtab, strsz, ctx->symbol, syment);
    }

    if (!slot && rel && relsz > 0 && table_in_module(rel, relsz)) {
      const size_t count = relsz / relent;
      slot = elf_find_import_slot(view, rel, count, symtab, strtab, strsz, ctx->symbol, syment);
    }

    if (slot) {
      ctx->result.slot = slot;
      ctx->result.module.base = reinterpret_cast<void*>(snapshot.base);
      ctx->result.module.size = snapshot.size;
      ctx->result.module.path = snapshot.path;
      ctx->result.error = make_error(hook_error::ok, nullptr);
      ctx->found = true;
      return 1;
    }

    return 0;
  };

  dl_iterate_phdr(callback, &ctx);

  if (!ctx.found) {
    ctx.result.error = make_error(hook_error::not_found, "import_not_found");
  }
  return ctx.result;
}
#endif

#if defined(__APPLE__)
#if defined(__LP64__)
using mach_header_t = mach_header_64;
using segment_command_t = segment_command_64;
using section_t = section_64;
using nlist_t = nlist_64;
static constexpr uint32_t kSegmentCommand = LC_SEGMENT_64;
#else
using mach_header_t = mach_header;
using segment_command_t = segment_command;
using section_t = section;
using nlist_t = nlist;
static constexpr uint32_t kSegmentCommand = LC_SEGMENT;
#endif

bool macho_range(const mach_header* header, intptr_t slide, uintptr_t& base, size_t& size) {
  const auto* mh = reinterpret_cast<const mach_header_t*>(header);
  const uint8_t* cursor = reinterpret_cast<const uint8_t*>(mh) + sizeof(mach_header_t);

  uintptr_t low = UINTPTR_MAX;
  uintptr_t high = 0;
  for (uint32_t i = 0; i < mh->ncmds; ++i) {
    const auto* lc = reinterpret_cast<const load_command*>(cursor);
    if (lc->cmd == kSegmentCommand) {
      const auto* seg = reinterpret_cast<const segment_command_t*>(cursor);
      const uintptr_t seg_start = static_cast<uintptr_t>(seg->vmaddr) + static_cast<uintptr_t>(slide);
      const uintptr_t seg_end = seg_start + static_cast<uintptr_t>(seg->vmsize);
      low = std::min(low, seg_start);
      high = std::max(high, seg_end);
    }
    cursor += lc->cmdsize;
  }

  if (low == UINTPTR_MAX || high <= low) {
    return false;
  }
  base = low;
  size = high - low;
  return true;
}

void** macho_find_symbol_ptr(const mach_header* header, intptr_t slide, const char* symbol) {
  if (!header || !symbol || symbol[0] == '\0') {
    return nullptr;
  }

  const auto* mh = reinterpret_cast<const mach_header_t*>(header);
  const uint8_t* cursor = reinterpret_cast<const uint8_t*>(mh) + sizeof(mach_header_t);

  const segment_command_t* text = nullptr;
  const segment_command_t* linkedit = nullptr;
  const struct symtab_command* symtab_cmd = nullptr;
  const struct dysymtab_command* dysymtab_cmd = nullptr;

  for (uint32_t i = 0; i < mh->ncmds; ++i) {
    const auto* lc = reinterpret_cast<const load_command*>(cursor);
    if (lc->cmd == kSegmentCommand) {
      const auto* seg = reinterpret_cast<const segment_command_t*>(cursor);
      if (std::strcmp(seg->segname, "__TEXT") == 0) {
        text = seg;
      } else if (std::strcmp(seg->segname, "__LINKEDIT") == 0) {
        linkedit = seg;
      }
    } else if (lc->cmd == LC_SYMTAB) {
      symtab_cmd = reinterpret_cast<const symtab_command*>(cursor);
    } else if (lc->cmd == LC_DYSYMTAB) {
      dysymtab_cmd = reinterpret_cast<const dysymtab_command*>(cursor);
    }
    cursor += lc->cmdsize;
  }

  if (!text || !linkedit || !symtab_cmd || !dysymtab_cmd) {
    return nullptr;
  }

  const uintptr_t slide_base = static_cast<uintptr_t>(slide);
  const uintptr_t linkedit_base =
      slide_base + static_cast<uintptr_t>(linkedit->vmaddr) - static_cast<uintptr_t>(linkedit->fileoff);
  const nlist_t* symtab = reinterpret_cast<const nlist_t*>(linkedit_base + symtab_cmd->symoff);
  const char* strtab = reinterpret_cast<const char*>(linkedit_base + symtab_cmd->stroff);
  const uint32_t* indirect_symtab =
      reinterpret_cast<const uint32_t*>(linkedit_base + dysymtab_cmd->indirectsymoff);

  cursor = reinterpret_cast<const uint8_t*>(mh) + sizeof(mach_header_t);
  for (uint32_t i = 0; i < mh->ncmds; ++i) {
    const auto* lc = reinterpret_cast<const load_command*>(cursor);
    if (lc->cmd == kSegmentCommand) {
      const auto* seg = reinterpret_cast<const segment_command_t*>(cursor);
      if (std::strcmp(seg->segname, "__DATA") != 0 && std::strcmp(seg->segname, "__DATA_CONST") != 0) {
        cursor += lc->cmdsize;
        continue;
      }
      const section_t* sect = reinterpret_cast<const section_t*>(cursor + sizeof(segment_command_t));
      for (uint32_t j = 0; j < seg->nsects; ++j) {
        const uint32_t type = sect[j].flags & SECTION_TYPE;
        if (type != S_LAZY_SYMBOL_POINTERS && type != S_NON_LAZY_SYMBOL_POINTERS) {
          continue;
        }
        const uint32_t* indices = indirect_symtab + sect[j].reserved1;
        void** bindings =
            reinterpret_cast<void**>(static_cast<uintptr_t>(slide) + static_cast<uintptr_t>(sect[j].addr));
        const uint32_t count = static_cast<uint32_t>(sect[j].size / sizeof(void*));
        for (uint32_t k = 0; k < count; ++k) {
          const uint32_t sym_index = indices[k];
          if (sym_index == INDIRECT_SYMBOL_ABS || sym_index == INDIRECT_SYMBOL_LOCAL ||
              sym_index == (INDIRECT_SYMBOL_LOCAL | INDIRECT_SYMBOL_ABS)) {
            continue;
          }
          const uint32_t str_offset = symtab[sym_index].n_un.n_strx;
          const char* name = strtab + str_offset;
          if (name && std::strcmp(name, symbol) == 0) {
            return &bindings[k];
          }
          if (name && name[0] == '_' && std::strcmp(name + 1, symbol) == 0) {
            return &bindings[k];
          }
        }
      }
    }
    cursor += lc->cmdsize;
  }

  return nullptr;
}

import_resolution resolve_import_macho(const char* symbol, const char* module) {
  import_resolution result{};
  if (!symbol || symbol[0] == '\0') {
    result.error = make_error(hook_error::invalid_target, "missing_symbol");
    return result;
  }

  const uint32_t count = _dyld_image_count();
  for (uint32_t i = 0; i < count; ++i) {
    const char* name = _dyld_get_image_name(i);
    if (!module || module[0] == '\0') {
      if (i != 0) {
        continue;
      }
    } else if (!module_matches(module, name ? std::string_view(name) : std::string_view{})) {
      continue;
    }
    const mach_header* header = _dyld_get_image_header(i);
    const intptr_t slide = _dyld_get_image_vmaddr_slide(i);
    void** slot = macho_find_symbol_ptr(header, slide, symbol);
    if (!slot) {
      continue;
    }
    uintptr_t base = 0;
    size_t size = 0;
    if (macho_range(header, slide, base, size)) {
      result.module.base = reinterpret_cast<void*>(base);
      result.module.size = size;
    }
    if (name) {
      result.module.path = name;
    }
    result.slot = slot;
    result.error = make_error(hook_error::ok, nullptr);
    return result;
  }

  result.error = make_error(hook_error::not_found, "import_not_found");
  return result;
}
#endif

} // namespace

std::vector<module_info> enumerate_modules() {
  std::vector<module_info> modules;
#if defined(__APPLE__)
  const uint32_t count = _dyld_image_count();
  modules.reserve(count);
  for (uint32_t i = 0; i < count; ++i) {
    const mach_header* header = _dyld_get_image_header(i);
    const intptr_t slide = _dyld_get_image_vmaddr_slide(i);
    module_info info{};
    uintptr_t base = 0;
    size_t size = 0;
    if (header && macho_range(header, slide, base, size)) {
      info.base = reinterpret_cast<void*>(base);
      info.size = size;
    }
    const char* name = _dyld_get_image_name(i);
    if (name) {
      info.path = name;
    }
    modules.push_back(std::move(info));
  }
#elif defined(__linux__)
  dl_iterate_phdr(
      [](struct dl_phdr_info* info, size_t, void* data) -> int {
        auto* out = static_cast<std::vector<module_info>*>(data);
        const elf_module_snapshot snapshot = snapshot_module(info);
        module_info mod{};
        mod.base = reinterpret_cast<void*>(snapshot.base);
        mod.size = snapshot.size;
        mod.path = snapshot.path;
        out->push_back(std::move(mod));
        return 0;
      },
      &modules);
#endif
  return modules;
}

symbol_resolution resolve_symbol(const char* symbol, const char* module) {
  symbol_resolution result{};
  if (!symbol || symbol[0] == '\0') {
    result.error = make_error(hook_error::invalid_target, "missing_symbol");
    return result;
  }

  void* handle = RTLD_DEFAULT;
  if (module && module[0] != '\0') {
    const std::string path = find_module_path(module);
    if (path.empty()) {
      result.error = make_error(hook_error::not_found, "module_not_found");
      return result;
    }
    handle = dlopen(path.c_str(), RTLD_LAZY | RTLD_NOLOAD);
    if (!handle) {
      result.error = make_error(hook_error::not_found, "module_not_loaded");
      return result;
    }
  }

  void* address = dlsym(handle, symbol);
  if (handle != RTLD_DEFAULT) {
    dlclose(handle);
  }

  if (!address) {
    result.error = make_error(hook_error::not_found, "symbol_not_found");
    return result;
  }

  result.address = address;
  result.error = make_error(hook_error::ok, nullptr);
  result.module = module_from_dladdr(address);
  if (result.module.path.empty() && module && module[0] != '\0') {
    result.module.path = find_module_path(module);
  }
  if (result.module.size == 0 && !result.module.path.empty()) {
    auto modules = enumerate_modules();
    for (const auto& entry : modules) {
      if (module_matches(result.module.path.c_str(), entry.path)) {
        result.module.size = entry.size;
        if (!result.module.base) {
          result.module.base = entry.base;
        }
        break;
      }
    }
  }
  return result;
}

symbol_resolution resolve_symbol(const hook_target& target) {
  if (target.kind == hook_target_kind::address) {
    symbol_resolution result{};
    result.address = target.address;
    result.error = make_error(target.address ? hook_error::ok : hook_error::invalid_target, "address_target");
    if (result.address) {
      result.module = module_from_dladdr(result.address);
    }
    return result;
  }
  if (target.kind != hook_target_kind::symbol) {
    symbol_resolution result{};
    result.error = make_error(hook_error::invalid_target, "invalid_target_kind");
    return result;
  }
  return resolve_symbol(target.symbol, target.module);
}

import_resolution resolve_import(const char* symbol, const char* module, const char* import_module) {
#if defined(__APPLE__)
  (void)import_module;
  return resolve_import_macho(symbol, module);
#elif defined(__linux__)
  return resolve_import_elf(symbol, module, import_module);
#else
  import_resolution result{};
  result.error = make_error(hook_error::unsupported, "unsupported_platform");
  (void)symbol;
  (void)module;
  (void)import_module;
  return result;
#endif
}

import_resolution resolve_import(const hook_target& target) {
  if (target.kind != hook_target_kind::import_slot) {
    import_resolution result{};
    result.error = make_error(hook_error::invalid_target, "invalid_target_kind");
    return result;
  }
  if (target.slot) {
    import_resolution result{};
    result.slot = target.slot;
    result.error = make_error(hook_error::ok, nullptr);
    return result;
  }
  return resolve_import(target.symbol, target.module, target.import_module);
}

void* symbol_address(const char* symbol, const char* module) {
  auto resolved = resolve_symbol(symbol, module);
  return resolved.address;
}

} // namespace w1::h00k::resolve

```

`src/w1h00k/resolve/resolve.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <string>
#include <vector>

#include "w1h00k/hook.hpp"

namespace w1::h00k::resolve {

struct module_info {
  void* base = nullptr;
  size_t size = 0;
  std::string path{};
};

struct symbol_resolution {
  void* address = nullptr;
  module_info module{};
  hook_error_info error{};
};

struct import_resolution {
  void** slot = nullptr;
  module_info module{};
  hook_error_info error{};
};

std::vector<module_info> enumerate_modules();
symbol_resolution resolve_symbol(const char* symbol, const char* module);
symbol_resolution resolve_symbol(const hook_target& target);
import_resolution resolve_import(const char* symbol, const char* module, const char* import_module);
import_resolution resolve_import(const hook_target& target);

void* symbol_address(const char* symbol, const char* module);

inline std::vector<import_resolution> resolve_imports(const char* symbol, const char* module,
                                                      const char* import_module) {
  std::vector<import_resolution> matches;
  if (module && module[0] != '\0') {
    auto resolved = resolve_import(symbol, module, import_module);
    if (resolved.error.ok() && resolved.slot) {
      matches.push_back(resolved);
    }
    return matches;
  }

  auto modules = enumerate_modules();
  for (const auto& entry : modules) {
    const char* module_path = entry.path.empty() ? nullptr : entry.path.c_str();
    auto resolved = resolve_import(symbol, module_path, import_module);
    if (resolved.error.ok() && resolved.slot) {
      matches.push_back(resolved);
    }
  }
  return matches;
}

} // namespace w1::h00k::resolve

```

`src/w1h00k/resolve/windows.cpp`:

```cpp
#include "w1h00k/resolve/resolve.hpp"

#include <algorithm>
#include <cstring>
#include <string_view>

#include "w1h00k/resolve/module_match.hpp"

#if defined(_WIN32)
#include <windows.h>
#include <tlhelp32.h>
#endif

namespace w1::h00k::resolve {
namespace {

hook_error_info make_error(hook_error code, const char* detail) {
  hook_error_info info{};
  info.code = code;
  info.detail = detail;
  return info;
}

#if defined(_WIN32)
bool module_info_from_entry(const MODULEENTRY32& entry, module_info& out) {
  out.base = entry.modBaseAddr;
  out.size = entry.modBaseSize;
  out.path = entry.szExePath;
  return true;
}

module_info module_info_from_handle(HMODULE module) {
  module_info out{};
  if (!module) {
    return out;
  }
  char buffer[MAX_PATH] = {};
  const DWORD len = GetModuleFileNameA(module, buffer, MAX_PATH);
  if (len != 0) {
    out.path.assign(buffer, len);
  }
  out.base = module;
  return out;
}

HMODULE find_module_handle(const char* module, module_info& out_info) {
  if (!module || module[0] == '\0') {
    HMODULE handle = GetModuleHandleA(nullptr);
    out_info = module_info_from_handle(handle);
    return handle;
  }

  auto modules = enumerate_modules();
  for (const auto& entry : modules) {
    if (module_matches(module, entry.path)) {
      out_info = entry;
      return reinterpret_cast<HMODULE>(entry.base);
    }
  }

  HMODULE handle = GetModuleHandleA(module);
  out_info = module_info_from_handle(handle);
  return handle;
}

void** resolve_import_from_module(HMODULE module, const char* symbol, const char* import_module) {
  if (!module || !symbol || symbol[0] == '\0') {
    return nullptr;
  }

  auto* base = reinterpret_cast<uint8_t*>(module);
  auto* dos = reinterpret_cast<IMAGE_DOS_HEADER*>(base);
  if (dos->e_magic != IMAGE_DOS_SIGNATURE) {
    return nullptr;
  }

  auto* nt = reinterpret_cast<IMAGE_NT_HEADERS*>(base + dos->e_lfanew);
  if (nt->Signature != IMAGE_NT_SIGNATURE) {
    return nullptr;
  }

  auto& directory = nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
  if (directory.VirtualAddress == 0) {
    return nullptr;
  }

  auto* import_desc = reinterpret_cast<IMAGE_IMPORT_DESCRIPTOR*>(base + directory.VirtualAddress);
  for (; import_desc->Name != 0; ++import_desc) {
    const char* name = reinterpret_cast<const char*>(base + import_desc->Name);
    if (!module_matches(import_module,
                        name ? std::string_view(name) : std::string_view{},
                        module_match_mode::basename)) {
      continue;
    }

    if (nt->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
      auto* thunk_iat = reinterpret_cast<IMAGE_THUNK_DATA64*>(base + import_desc->FirstThunk);
      auto* thunk_orig = import_desc->OriginalFirstThunk != 0
                             ? reinterpret_cast<IMAGE_THUNK_DATA64*>(base + import_desc->OriginalFirstThunk)
                             : nullptr;
      for (; thunk_iat->u1.AddressOfData != 0; ++thunk_iat) {
        auto* thunk_lookup = thunk_orig ? thunk_orig : thunk_iat;
        if (IMAGE_SNAP_BY_ORDINAL64(thunk_lookup->u1.Ordinal)) {
          if (thunk_orig) {
            ++thunk_orig;
          }
          continue;
        }
        auto* import_by_name =
            reinterpret_cast<IMAGE_IMPORT_BY_NAME*>(base + thunk_lookup->u1.AddressOfData);
        if (import_by_name && std::strcmp(import_by_name->Name, symbol) == 0) {
          return reinterpret_cast<void**>(&thunk_iat->u1.Function);
        }
        if (thunk_orig) {
          ++thunk_orig;
        }
      }
    } else {
      auto* thunk_iat = reinterpret_cast<IMAGE_THUNK_DATA32*>(base + import_desc->FirstThunk);
      auto* thunk_orig = import_desc->OriginalFirstThunk != 0
                             ? reinterpret_cast<IMAGE_THUNK_DATA32*>(base + import_desc->OriginalFirstThunk)
                             : nullptr;
      for (; thunk_iat->u1.AddressOfData != 0; ++thunk_iat) {
        auto* thunk_lookup = thunk_orig ? thunk_orig : thunk_iat;
        if (IMAGE_SNAP_BY_ORDINAL32(thunk_lookup->u1.Ordinal)) {
          if (thunk_orig) {
            ++thunk_orig;
          }
          continue;
        }
        auto* import_by_name =
            reinterpret_cast<IMAGE_IMPORT_BY_NAME*>(base + thunk_lookup->u1.AddressOfData);
        if (import_by_name && std::strcmp(import_by_name->Name, symbol) == 0) {
          return reinterpret_cast<void**>(&thunk_iat->u1.Function);
        }
        if (thunk_orig) {
          ++thunk_orig;
        }
      }
    }
  }

  return nullptr;
}
#endif

} // namespace

std::vector<module_info> enumerate_modules() {
  std::vector<module_info> modules;
#if defined(_WIN32)
  HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, GetCurrentProcessId());
  if (snapshot == INVALID_HANDLE_VALUE) {
    return modules;
  }

  MODULEENTRY32 entry{};
  entry.dwSize = sizeof(entry);
  if (Module32First(snapshot, &entry)) {
    do {
      module_info info{};
      module_info_from_entry(entry, info);
      modules.push_back(std::move(info));
    } while (Module32Next(snapshot, &entry));
  }

  CloseHandle(snapshot);
#endif
  return modules;
}

symbol_resolution resolve_symbol(const char* symbol, const char* module) {
  symbol_resolution result{};
#if defined(_WIN32)
  if (!symbol || symbol[0] == '\0') {
    result.error = make_error(hook_error::invalid_target, "missing_symbol");
    return result;
  }

  if (!module || module[0] == '\0') {
    auto modules = enumerate_modules();
    for (const auto& entry : modules) {
      auto* handle = reinterpret_cast<HMODULE>(entry.base);
      auto* address = reinterpret_cast<void*>(GetProcAddress(handle, symbol));
      if (address) {
        result.address = address;
        result.module = entry;
        result.error = make_error(hook_error::ok, nullptr);
        return result;
      }
    }
    result.error = make_error(hook_error::not_found, "symbol_not_found");
    return result;
  }

  module_info module_info{};
  HMODULE handle = find_module_handle(module, module_info);
  if (!handle) {
    result.error = make_error(hook_error::not_found, "module_not_found");
    return result;
  }

  void* address = reinterpret_cast<void*>(GetProcAddress(handle, symbol));
  if (!address) {
    result.error = make_error(hook_error::not_found, "symbol_not_found");
    return result;
  }

  result.address = address;
  result.module = module_info;
  result.error = make_error(hook_error::ok, nullptr);
  return result;
#else
  (void)symbol;
  (void)module;
  result.error = make_error(hook_error::unsupported, "unsupported_platform");
  return result;
#endif
}

symbol_resolution resolve_symbol(const hook_target& target) {
  if (target.kind == hook_target_kind::address) {
    symbol_resolution result{};
    result.address = target.address;
    result.error = make_error(target.address ? hook_error::ok : hook_error::invalid_target, "address_target");
    return result;
  }
  if (target.kind != hook_target_kind::symbol) {
    symbol_resolution result{};
    result.error = make_error(hook_error::invalid_target, "invalid_target_kind");
    return result;
  }
  return resolve_symbol(target.symbol, target.module);
}

import_resolution resolve_import(const char* symbol, const char* module, const char* import_module) {
  import_resolution result{};
#if defined(_WIN32)
  module_info module_info{};
  HMODULE handle = find_module_handle(module, module_info);
  if (!handle) {
    result.error = make_error(hook_error::not_found, "module_not_found");
    return result;
  }

  void** slot = resolve_import_from_module(handle, symbol, import_module);
  if (!slot) {
    result.error = make_error(hook_error::not_found, "import_not_found");
    return result;
  }

  result.slot = slot;
  result.module = module_info;
  result.error = make_error(hook_error::ok, nullptr);
  return result;
#else
  (void)symbol;
  (void)module;
  (void)import_module;
  result.error = make_error(hook_error::unsupported, "unsupported_platform");
  return result;
#endif
}

import_resolution resolve_import(const hook_target& target) {
  if (target.kind != hook_target_kind::import_slot) {
    import_resolution result{};
    result.error = make_error(hook_error::invalid_target, "invalid_target_kind");
    return result;
  }
  if (target.slot) {
    import_resolution result{};
    result.slot = target.slot;
    result.error = make_error(hook_error::ok, nullptr);
    return result;
  }
  return resolve_import(target.symbol, target.module, target.import_module);
}

void* symbol_address(const char* symbol, const char* module) {
  auto resolved = resolve_symbol(symbol, module);
  return resolved.address;
}

} // namespace w1::h00k::resolve

```

`src/w1import/CMakeLists.txt`:

```txt
w1_dep_redlog()
w1_dep_lief()

set(W1IMPORT_SOURCES
    import_insertion.cpp
)

if(APPLE)
    list(APPEND W1IMPORT_SOURCES
        platform/macos/macos_import_inserter.cpp
        backend/macos/macho_processor.cpp
    )
elseif(WIN32)
    list(APPEND W1IMPORT_SOURCES
        platform/windows/windows_import_inserter.cpp
    )
else()
    list(APPEND W1IMPORT_SOURCES
        platform/linux/linux_import_inserter.cpp
    )
endif()

w1_add_static_library(w1import ${W1IMPORT_SOURCES})
add_library(w1::import ALIAS w1import)

target_link_libraries(w1import PUBLIC w1::lief)
target_link_libraries(w1import PRIVATE redlog::redlog)

```

`src/w1import/backend/macos/macho_processor.cpp`:

```cpp
#include "macho_processor.hpp"

#include <iostream>
#include <memory>
#include <vector>

#include <mach-o/fat.h>
#include <mach-o/loader.h>
#include <libkern/OSByteOrder.h>

#include <redlog.hpp>

namespace w1::import_insertion::backend::macos {

namespace {
auto log_processor = redlog::get_logger("w1.import_insertion.macho_processor");

// byte swapping helpers (extracted from insert_dylib)
#define IS_64_BIT(x) ((x) == MH_MAGIC_64 || (x) == MH_CIGAM_64)
#define IS_LITTLE_ENDIAN(x) ((x) == FAT_CIGAM || (x) == MH_CIGAM_64 || (x) == MH_CIGAM)
#define SWAP32(x, magic) (IS_LITTLE_ENDIAN(magic) ? OSSwapInt32(x) : (x))
#define SWAP64(x, magic) (IS_LITTLE_ENDIAN(magic) ? OSSwapInt64(x) : (x))
#define ROUND_UP(x, y) (((x) + (y) - 1) & -(y))
} // namespace

void MachOProcessor::zero_fill(std::streamoff offset, size_t len) {
  static constexpr size_t buffer_size = 512;
  static char zeros[buffer_size] = {0};

  file_.seekp(offset);
  while (len > 0) {
    size_t size = std::min(len, buffer_size);
    file_.write(zeros, size);
    len -= size;
  }
}

void MachOProcessor::memory_move(std::streamoff dst, std::streamoff src, size_t len) {
  static constexpr size_t buffer_size = 512;
  static char buffer[buffer_size];

  while (len > 0) {
    size_t size = std::min(len, buffer_size);
    file_.seekg(src);
    file_.read(buffer, size);
    file_.seekp(dst);
    file_.write(buffer, size);

    len -= size;
    src += size;
    dst += size;
  }
}

template <typename T> T MachOProcessor::peek_at(std::streamoff pos) {
  T result;
  auto current_pos = file_.tellg();
  file_.seekg(pos);
  file_.read(reinterpret_cast<char*>(&result), sizeof(T));
  file_.seekg(current_pos);
  return result;
}

bool MachOProcessor::ask_user(const std::string& question) {
  if (!ask_mode_) {
    return true;
  }

  std::cout << question << " [y/n] ";
  std::string response;
  while (true) {
    std::getline(std::cin, response);
    if (!response.empty()) {
      char c = std::tolower(response[0]);
      if (c == 'y') {
        return true;
      }
      if (c == 'n') {
        return false;
      }
    }
    std::cout << "Please enter y or n: ";
  }
}

bool MachOProcessor::check_load_commands(
    struct mach_header* mh, [[maybe_unused]] size_t header_offset, size_t commands_offset,
    const std::string& dylib_path, [[maybe_unused]] std::streamoff* slice_size
) {
  file_.seekg(commands_offset);
  uint32_t ncmds = SWAP32(mh->ncmds, mh->magic);

  log_processor.trc(
      "checking load commands", redlog::field("count", ncmds), redlog::field("commands_offset", commands_offset)
  );

  [[maybe_unused]] std::streamoff linkedit_32_pos = -1;
  [[maybe_unused]] std::streamoff linkedit_64_pos = -1;
  [[maybe_unused]] struct segment_command linkedit_32;
  [[maybe_unused]] struct segment_command_64 linkedit_64;

  for (uint32_t i = 0; i < ncmds; i++) {
    auto lc_pos = file_.tellg();
    struct load_command lc;
    file_.read(reinterpret_cast<char*>(&lc), sizeof(lc));

    uint32_t cmdsize = SWAP32(lc.cmdsize, mh->magic);
    uint32_t cmd = SWAP32(lc.cmd, mh->magic);

    log_processor.dbg(
        "processing load command", redlog::field("index", i), redlog::field("cmd", cmd), redlog::field("size", cmdsize)
    );

    switch (cmd) {
    case LC_CODE_SIGNATURE:
      log_processor.trc("found code signature", redlog::field("position", i), redlog::field("is_last", i == ncmds - 1));
      if (i == ncmds - 1) {
        if (strip_codesig_ || ask_user("LC_CODE_SIGNATURE found. Remove it?")) {
          // handle code signature removal
          log_processor.inf("removing code signature", redlog::field("size", cmdsize));
          zero_fill(lc_pos, cmdsize);
          mh->ncmds = SWAP32(ncmds - 1, mh->magic);
          mh->sizeofcmds = SWAP32(SWAP32(mh->sizeofcmds, mh->magic) - cmdsize, mh->magic);
          return true;
        } else {
          log_processor.dbg("user declined code signature removal");
          return true;
        }
      } else {
        log_processor.warn("code signature not at end, cannot remove", redlog::field("position", i));
      }
      break;

    case LC_LOAD_DYLIB:
    case LC_LOAD_WEAK_DYLIB: {
      file_.seekg(lc_pos);
      std::vector<char> cmd_data(cmdsize);
      file_.read(cmd_data.data(), cmdsize);

      auto dylib_cmd = reinterpret_cast<struct dylib_command*>(cmd_data.data());
      uint32_t name_offset = SWAP32(dylib_cmd->dylib.name.offset, mh->magic);
      std::string existing_path(cmd_data.data() + name_offset);

      log_processor.dbg(
          "found existing dylib load command", redlog::field("path", existing_path),
          redlog::field("weak", cmd == LC_LOAD_WEAK_DYLIB)
      );

      if (existing_path == dylib_path) {
        log_processor.trc("duplicate dylib detected", redlog::field("path", dylib_path));
        if (!ask_user("Binary already contains load command for " + dylib_path + ". Continue?")) {
          return false;
        }
      }
      break;
    }

    case LC_SEGMENT:
    case LC_SEGMENT_64:
      // track __LINKEDIT segment for code signature handling
      if (cmd == LC_SEGMENT) {
        file_.seekg(lc_pos);
        struct segment_command seg_cmd;
        file_.read(reinterpret_cast<char*>(&seg_cmd), sizeof(seg_cmd));
        log_processor.dbg(
            "found 32-bit segment", redlog::field("name", std::string(seg_cmd.segname, strnlen(seg_cmd.segname, 16)))
        );
        if (strncmp(seg_cmd.segname, "__LINKEDIT", 16) == 0) {
          log_processor.trc(
              "found __LINKEDIT segment (32-bit)", redlog::field("fileoff", SWAP32(seg_cmd.fileoff, mh->magic)),
              redlog::field("filesize", SWAP32(seg_cmd.filesize, mh->magic))
          );
          linkedit_32_pos = lc_pos;
          linkedit_32 = seg_cmd;
        }
      } else {
        file_.seekg(lc_pos);
        struct segment_command_64 seg_cmd;
        file_.read(reinterpret_cast<char*>(&seg_cmd), sizeof(seg_cmd));
        log_processor.dbg(
            "found 64-bit segment", redlog::field("name", std::string(seg_cmd.segname, strnlen(seg_cmd.segname, 16)))
        );
        if (strncmp(seg_cmd.segname, "__LINKEDIT", 16) == 0) {
          log_processor.trc(
              "found __LINKEDIT segment (64-bit)", redlog::field("fileoff", SWAP64(seg_cmd.fileoff, mh->magic)),
              redlog::field("filesize", SWAP64(seg_cmd.filesize, mh->magic))
          );
          linkedit_64_pos = lc_pos;
          linkedit_64 = seg_cmd;
        }
      }
      break;
    }

    file_.seekg(lc_pos + static_cast<std::streamoff>(cmdsize));
  }

  return true;
}

MachOProcessor::MachOProcessor(const std::string& filepath, bool weak, bool strip_codesig, bool ask)
    : weak_flag_(weak), strip_codesig_(strip_codesig), ask_mode_(ask) {
  file_.open(filepath, std::ios::in | std::ios::out | std::ios::binary);
  if (!file_.is_open()) {
    throw std::runtime_error("failed to open file: " + filepath);
  }
}

MachOProcessor::~MachOProcessor() {
  if (file_.is_open()) {
    file_.close();
  }
}

bool MachOProcessor::insert_dylib_load_command(const std::string& dylib_path) {
  // get file size
  file_.seekg(0, std::ios::end);
  std::streamoff file_size = file_.tellg();
  file_.seekg(0, std::ios::beg);

  // read magic number
  uint32_t magic;
  file_.read(reinterpret_cast<char*>(&magic), sizeof(magic));

  switch (magic) {
  case FAT_MAGIC:
  case FAT_CIGAM:
    return process_fat_binary(dylib_path, magic);

  case MH_MAGIC_64:
  case MH_CIGAM_64:
  case MH_MAGIC:
  case MH_CIGAM:
    return process_mach_o(dylib_path, 0, &file_size);

  default:
    log_processor.error("unknown magic number", redlog::field("magic", magic));
    return false;
  }
}

bool MachOProcessor::process_fat_binary(const std::string& dylib_path, uint32_t magic) {
  file_.seekg(0);
  struct fat_header fh;
  file_.read(reinterpret_cast<char*>(&fh), sizeof(fh));

  uint32_t nfat_arch = SWAP32(fh.nfat_arch, magic);
  log_processor.inf("processing fat binary", redlog::field("architectures", nfat_arch));
  log_processor.trc(
      "fat binary details", redlog::field("magic", magic), redlog::field("little_endian", IS_LITTLE_ENDIAN(magic))
  );

  std::vector<struct fat_arch> archs(nfat_arch);
  file_.read(reinterpret_cast<char*>(archs.data()), sizeof(struct fat_arch) * nfat_arch);

  int failures = 0;
  for (uint32_t i = 0; i < nfat_arch; i++) {
    std::streamoff offset = SWAP32(archs[i].offset, magic);
    std::streamoff slice_size = SWAP32(archs[i].size, magic);

    log_processor.trc(
        "processing architecture", redlog::field("index", i), redlog::field("offset", offset),
        redlog::field("size", slice_size), redlog::field("cputype", SWAP32(archs[i].cputype, magic))
    );

    if (!process_mach_o(dylib_path, offset, &slice_size)) {
      log_processor.error("failed to process architecture", redlog::field("arch_index", i + 1));
      failures++;
    } else {
      log_processor.dbg(
          "architecture processed successfully", redlog::field("index", i), redlog::field("new_size", slice_size)
      );
    }

    archs[i].size = SWAP32(static_cast<uint32_t>(slice_size), magic);
  }

  // update fat header
  log_processor.trc("updating fat binary header");
  file_.seekp(sizeof(struct fat_header));
  file_.write(reinterpret_cast<const char*>(archs.data()), sizeof(struct fat_arch) * nfat_arch);

  if (failures == 0) {
    log_processor.info("added dylib load command to all architectures");
    return true;
  } else if (static_cast<uint32_t>(failures) == nfat_arch) {
    log_processor.error("failed to add dylib load command to any architectures");
    return false;
  } else {
    log_processor.warn(
        "added dylib load command to some architectures", redlog::field("successful", nfat_arch - failures),
        redlog::field("total", nfat_arch)
    );
    return true;
  }
}

bool MachOProcessor::process_mach_o(
    const std::string& dylib_path, std::streamoff header_offset, std::streamoff* slice_size
) {
  file_.seekg(header_offset);
  struct mach_header mh;
  file_.read(reinterpret_cast<char*>(&mh), sizeof(mh));

  log_processor.trc(
      "processing mach-o binary", redlog::field("header_offset", header_offset), redlog::field("magic", mh.magic),
      redlog::field("is_64bit", IS_64_BIT(mh.magic))
  );

  if (mh.magic != MH_MAGIC_64 && mh.magic != MH_CIGAM_64 && mh.magic != MH_MAGIC && mh.magic != MH_CIGAM) {
    log_processor.error("unknown mach-o magic", redlog::field("magic", mh.magic));
    return false;
  }

  size_t commands_offset =
      header_offset + (IS_64_BIT(mh.magic) ? sizeof(struct mach_header_64) : sizeof(struct mach_header));

  log_processor.dbg(
      "mach-o header parsed", redlog::field("ncmds", SWAP32(mh.ncmds, mh.magic)),
      redlog::field("sizeofcmds", SWAP32(mh.sizeofcmds, mh.magic)), redlog::field("commands_offset", commands_offset)
  );

  // check existing load commands
  if (!check_load_commands(&mh, header_offset, commands_offset, dylib_path, slice_size)) {
    return false;
  }

  // create new dylib load command
  constexpr size_t path_padding = 8;
  size_t dylib_path_size = (dylib_path.length() & ~(path_padding - 1)) + path_padding;
  uint32_t cmdsize = static_cast<uint32_t>(sizeof(struct dylib_command) + dylib_path_size);

  log_processor.trc(
      "creating dylib load command", redlog::field("dylib_path", dylib_path), redlog::field("weak", weak_flag_),
      redlog::field("cmdsize", cmdsize), redlog::field("padded_path_size", dylib_path_size)
  );

  struct dylib_command dylib_cmd = {
      .cmd = SWAP32(weak_flag_ ? LC_LOAD_WEAK_DYLIB : LC_LOAD_DYLIB, mh.magic),
      .cmdsize = SWAP32(cmdsize, mh.magic),
      .dylib = {
          .name = {static_cast<uint32_t>(SWAP32(sizeof(struct dylib_command), mh.magic))},
          .timestamp = 0,
          .current_version = 0,
          .compatibility_version = 0
      }
  };

  // find insertion point
  uint32_t sizeofcmds = SWAP32(mh.sizeofcmds, mh.magic);
  std::streamoff insert_pos = commands_offset + sizeofcmds;

  // check if there's enough space
  file_.seekg(insert_pos);
  std::vector<char> space_check(cmdsize);
  file_.read(space_check.data(), cmdsize);

  bool has_space = true;
  for (char c : space_check) {
    if (c != 0) {
      has_space = false;
      break;
    }
  }

  log_processor.dbg(
      "space check at insertion point", redlog::field("position", insert_pos), redlog::field("required_size", cmdsize),
      redlog::field("has_space", has_space)
  );

  if (!has_space && !ask_user("Not enough empty space detected. Continue anyway?")) {
    log_processor.trc("user declined to continue without sufficient space");
    return false;
  }

  // write the new load command
  log_processor.trc("writing dylib load command", redlog::field("position", insert_pos));
  file_.seekp(insert_pos);
  file_.write(reinterpret_cast<const char*>(&dylib_cmd), sizeof(dylib_cmd));

  // write padded dylib path
  std::vector<char> padded_path(dylib_path_size, 0);
  std::copy(dylib_path.begin(), dylib_path.end(), padded_path.begin());
  file_.write(padded_path.data(), dylib_path_size);

  log_processor.dbg(
      "wrote dylib path", redlog::field("original_length", dylib_path.length()),
      redlog::field("padded_length", dylib_path_size)
  );

  // update mach-o header
  uint32_t new_ncmds = SWAP32(mh.ncmds, mh.magic) + 1;
  uint32_t new_sizeofcmds = sizeofcmds + cmdsize;

  mh.ncmds = SWAP32(new_ncmds, mh.magic);
  mh.sizeofcmds = SWAP32(new_sizeofcmds, mh.magic);

  log_processor.trc(
      "updating mach-o header", redlog::field("old_ncmds", SWAP32(mh.ncmds, mh.magic) - 1),
      redlog::field("new_ncmds", new_ncmds), redlog::field("new_sizeofcmds", new_sizeofcmds)
  );

  file_.seekp(header_offset);
  file_.write(reinterpret_cast<const char*>(&mh), sizeof(mh));

  return true;
}

} // namespace w1::import_insertion::backend::macos

```

`src/w1import/backend/macos/macho_processor.hpp`:

```hpp
#pragma once

#include <fstream>
#include <string>
#include <vector>

#include <mach-o/fat.h>
#include <mach-o/loader.h>

namespace w1::import_insertion::backend::macos {

// extracted and refactored from tools/insert_dylib/main.cpp
class MachOProcessor {
private:
  std::fstream file_;
  bool weak_flag_;
  bool strip_codesig_;
  bool ask_mode_; // false = assume yes to all questions

  void zero_fill(std::streamoff offset, size_t len);
  void memory_move(std::streamoff dst, std::streamoff src, size_t len);

  template <typename T> T peek_at(std::streamoff pos);

  bool ask_user(const std::string& question);

  bool check_load_commands(
      struct mach_header* mh, size_t header_offset, size_t commands_offset, const std::string& dylib_path,
      std::streamoff* slice_size
  );

  bool process_fat_binary(const std::string& dylib_path, uint32_t magic);
  bool process_mach_o(const std::string& dylib_path, std::streamoff header_offset, std::streamoff* slice_size);

public:
  MachOProcessor(const std::string& filepath, bool weak, bool strip_codesig, bool ask);
  ~MachOProcessor();

  bool insert_dylib_load_command(const std::string& dylib_path);
};

} // namespace w1::import_insertion::backend::macos
```

`src/w1import/import_insertion.cpp`:

```cpp
#include "import_insertion.hpp"
#include <redlog.hpp>

// platform-specific includes
#ifdef __APPLE__
#include "platform/macos/macos_import_inserter.hpp"
#elif defined(__linux__)
#include "platform/linux/linux_import_inserter.hpp"
#elif defined(_WIN32)
#include "platform/windows/windows_import_inserter.hpp"
#endif

#include <filesystem>

namespace fs = std::filesystem;

namespace w1::import_insertion {

// validate configuration before import insertion
error_code validate_config(const config& cfg) {
  auto log = redlog::get_logger("w1.import_insertion.validation");

  log.debug("validating import insertion configuration");

  // validate required fields
  if (cfg.library_path.empty()) {
    log.error("library_path is required");
    return error_code::configuration_invalid;
  }

  if (cfg.target_binary.empty()) {
    log.error("target_binary is required");
    return error_code::configuration_invalid;
  }

  log.debug(
      "validating paths", redlog::field("library_path", cfg.library_path),
      redlog::field("target_binary", cfg.target_binary)
  );

  // validate target binary exists
  if (!fs::exists(cfg.target_binary)) {
    log.error("target binary does not exist", redlog::field("path", cfg.target_binary));
    return error_code::file_not_found;
  }

  // validate output path configuration
  if (cfg.in_place && cfg.output_path.has_value()) {
    log.error("in_place=true is incompatible with output_path");
    return error_code::configuration_invalid;
  }

  // validate library path (special paths starting with @ are allowed even if they don't exist)
  if (cfg.library_path[0] != '@' && !fs::exists(cfg.library_path)) {
    if (!cfg.assume_yes) {
      log.error("library path does not exist", redlog::field("path", cfg.library_path));
      return error_code::library_path_invalid;
    } else {
      log.debug("library path does not exist but assume_yes=true", redlog::field("path", cfg.library_path));
    }
  }

  log.debug("configuration validation completed successfully");
  return error_code::success;
}

result insert_library_import(const config& cfg) {
  auto log = redlog::get_logger("w1.import_insertion");

  log.info(
      "starting library import insertion", redlog::field("library_path", cfg.library_path),
      redlog::field("target_binary", cfg.target_binary), redlog::field("weak_import", cfg.weak_import)
  );

  // validate configuration
  auto validation_error = validate_config(cfg);
  if (validation_error != error_code::success) {
    log.error("configuration validation failed");
    return result{.code = validation_error, .error_message = "configuration validation failed"};
  }

  // determine platform for logging
  const char* platform_str =
#ifdef __APPLE__
      "macos";
#elif defined(__linux__)
      "linux";
#elif defined(_WIN32)
      "windows";
#else
      "unknown";
#endif

  log.debug("performing platform-specific import insertion", redlog::field("platform", platform_str));

  // platform dispatch
  result insertion_result;

#ifdef __APPLE__
  insertion_result = macos::insert_library_import(cfg);
#elif defined(__linux__)
  insertion_result = linux_impl::insert_library_import(cfg);
#elif defined(_WIN32)
  insertion_result = windows::insert_library_import(cfg);
#else
  log.error("platform not supported for library import insertion", redlog::field("platform", platform_str));
  insertion_result = result{
      .code = error_code::platform_not_supported, .error_message = "platform not supported for library import insertion"
  };
#endif

  if (insertion_result.success()) {
    log.info("library import insertion completed successfully");
  } else {
    log.error(
        "library import insertion failed", redlog::field("error_code", static_cast<int>(insertion_result.code)),
        redlog::field("error_message", insertion_result.error_message)
    );
  }

  return insertion_result;
}

std::string error_code_to_string(error_code code) {
  switch (code) {
  case error_code::success:
    return "success";
  case error_code::file_not_found:
    return "file_not_found";
  case error_code::file_access_denied:
    return "file_access_denied";
  case error_code::invalid_output_path:
    return "invalid_output_path";
  case error_code::output_already_exists:
    return "output_already_exists";
  case error_code::invalid_binary_format:
    return "invalid_binary_format";
  case error_code::unknown_magic_number:
    return "unknown_magic_number";
  case error_code::unsupported_architecture:
    return "unsupported_architecture";
  case error_code::corrupted_header:
    return "corrupted_header";
  case error_code::duplicate_library:
    return "duplicate_library";
  case error_code::library_path_invalid:
    return "library_path_invalid";
  case error_code::insufficient_space:
    return "insufficient_space";
  case error_code::code_signature_conflict:
    return "code_signature_conflict";
  case error_code::code_signature_removal_failed:
    return "code_signature_removal_failed";
  case error_code::user_declined:
    return "user_declined";
  case error_code::interactive_prompt_failed:
    return "interactive_prompt_failed";
  case error_code::platform_not_supported:
    return "platform_not_supported";
  case error_code::insufficient_privileges:
    return "insufficient_privileges";
  case error_code::out_of_memory:
    return "out_of_memory";
  case error_code::system_error:
    return "system_error";
  case error_code::configuration_invalid:
    return "configuration_invalid";
  case error_code::unknown_error:
    return "unknown_error";
  default:
    return "unknown_error_code";
  }
}

bool is_recoverable_error(error_code code) {
  switch (code) {
  case error_code::success:
  case error_code::file_not_found:
  case error_code::invalid_binary_format:
  case error_code::platform_not_supported:
  case error_code::configuration_invalid:
    return false;

  case error_code::file_access_denied:
  case error_code::output_already_exists:
  case error_code::duplicate_library:
  case error_code::insufficient_space:
  case error_code::code_signature_conflict:
  case error_code::user_declined:
    return true;

  default:
    return false;
  }
}

bool is_platform_supported() {
#ifdef __APPLE__
  return macos::check_import_capabilities(); // always available on macos via native macho processor
#elif defined(__linux__)
  return linux_impl::check_import_capabilities(); // available when LIEF is enabled
#elif defined(_WIN32)
  return windows::check_import_capabilities(); // available when LIEF is enabled
#else
  return false; // unsupported platform
#endif
}

std::string get_platform_support_info() {
  std::string info = "platform support status:\n";

#ifdef __APPLE__
  info += "  macos (mach-o): supported (native implementation)\n";
#else
  info += "  macos (mach-o): not available (only on macos)\n";
#endif

#ifdef WITNESS_LIEF_ENABLED
  info += "  windows (pe): supported (via LIEF)\n";
  info += "  linux (elf): supported (via LIEF)\n";
#else
  info += "  windows (pe): requires LIEF (build with -DWITNESS_LIEF=ON)\n";
  info += "  linux (elf): requires LIEF (build with -DWITNESS_LIEF=ON)\n";
#endif

  const char* current_platform =
#ifdef __APPLE__
      "macos";
#elif defined(__linux__)
      "linux";
#elif defined(_WIN32)
      "windows";
#else
      "unknown";
#endif

  info += "  current platform: ";
  info += current_platform;
  info += " (";
  info += (is_platform_supported() ? "supported" : "not supported");
  info += ")";

  return info;
}

} // namespace w1::import_insertion
```

`src/w1import/import_insertion.hpp`:

```hpp
#pragma once

#include <optional>
#include <string>

namespace w1::import_insertion {

// comprehensive cross-platform error codes
enum class error_code {
  success,

  // file errors
  file_not_found,
  file_access_denied,
  invalid_output_path,
  output_already_exists,

  // binary format errors
  invalid_binary_format,
  unknown_magic_number,
  unsupported_architecture,
  corrupted_header,

  // library import errors
  duplicate_library,
  library_path_invalid,
  insufficient_space,

  // code signature errors
  code_signature_conflict,
  code_signature_removal_failed,

  // user interaction errors
  user_declined,
  interactive_prompt_failed,

  // platform errors
  platform_not_supported,
  insufficient_privileges,

  // system errors
  out_of_memory,
  system_error,
  configuration_invalid,

  unknown_error
};

// configuration for library import insertion
struct config {
  // REQUIRED
  std::string library_path;  // path to library to insert
  std::string target_binary; // path to target binary

  // OUTPUT HANDLING
  std::optional<std::string> output_path; // if not set, uses target_binary + "_patched"
  bool in_place = false;                  // modify target_binary directly
  bool overwrite_existing = false;        // overwrite output file if it exists

  // LIBRARY IMPORT OPTIONS
  bool weak_import = false;          // use weak import (LC_LOAD_WEAK_DYLIB on macos)
  bool strip_code_signature = false; // automatically remove code signature if present

  // USER INTERACTION
  bool assume_yes = false; // answer yes to all prompts (equivalent to --all-yes)
};

// result of library import insertion
struct result {
  error_code code;
  std::string error_message;
  std::optional<int> system_error_code;

  // convenience
  bool success() const { return code == error_code::success; }
  operator bool() const { return success(); }
};

// MAIN LIBRARY IMPORT INSERTION FUNCTION
result insert_library_import(const config& cfg);

// UTILITIES
std::string error_code_to_string(error_code code);
bool is_recoverable_error(error_code code);
bool is_platform_supported();
std::string get_platform_support_info();

} // namespace w1::import_insertion
```

`src/w1import/platform/linux/linux_import_inserter.cpp`:

```cpp
#include "linux_import_inserter.hpp"
#include <filesystem>
#include <redlog.hpp>

#ifdef WITNESS_LIEF_ENABLED
#include <LIEF/ELF.hpp>
#endif

namespace fs = std::filesystem;

namespace w1::import_insertion::linux_impl {

result insert_library_import(const config& cfg) {
  auto log = redlog::get_logger("w1.import_insertion.linux");

#ifndef WITNESS_LIEF_ENABLED
  log.error("linux library import insertion requires LIEF support");
  return result{
      .code = error_code::platform_not_supported,
      .error_message = "linux library import insertion requires LIEF library support (build with -DWITNESS_LIEF=ON)"
  };
#else

  log.inf(
      "starting linux elf library import insertion", redlog::field("library_path", cfg.library_path),
      redlog::field("target_binary", cfg.target_binary), redlog::field("in_place", cfg.in_place)
  );

  // validate binary exists
  if (!fs::exists(cfg.target_binary)) {
    log.error("binary path does not exist", redlog::field("path", cfg.target_binary));
    return result{
        .code = error_code::file_not_found,
        .error_message = "target binary not found: " + cfg.target_binary,
        .system_error_code = {}
    };
  }

  // determine output path
  std::string final_binary_path;
  if (cfg.in_place) {
    final_binary_path = cfg.target_binary;
    log.trc("using in-place modification");
  } else if (cfg.output_path) {
    final_binary_path = *cfg.output_path;
    log.trc("using specified output path", redlog::field("output_path", final_binary_path));
  } else {
    final_binary_path = cfg.target_binary + "_patched";
    log.trc("using default output path", redlog::field("output_path", final_binary_path));
  }

  // check if output already exists
  if (final_binary_path != cfg.target_binary && fs::exists(final_binary_path) && !cfg.overwrite_existing) {
    if (!cfg.assume_yes) {
      return result{
          .code = error_code::output_already_exists,
          .error_message = "output file already exists: " + final_binary_path + " (use overwrite_existing=true)",
          .system_error_code = {}
      };
    } else {
      log.info("overwriting existing output file (assume_yes=true)");
    }
  }

  try {
    // parse elf binary
    log.trc("parsing elf binary", redlog::field("file", cfg.target_binary));
    auto elf = LIEF::ELF::Parser::parse(cfg.target_binary);
    if (!elf) {
      log.error("failed to parse elf binary", redlog::field("file", cfg.target_binary));
      return result{
          .code = error_code::invalid_binary_format,
          .error_message = "failed to parse ELF binary - invalid format or corrupted file",
          .system_error_code = {}
      };
    }

    // validate architecture and type compatibility
    log.dbg(
        "elf binary details", redlog::field("class", static_cast<int>(elf->header().identity_class())),
        redlog::field("machine", static_cast<int>(elf->header().machine_type())),
        redlog::field("type", static_cast<int>(elf->header().file_type())),
        redlog::field("is_64bit", elf->header().identity_class() == LIEF::ELF::Header::CLASS::ELF64)
    );

    // check if this is a dynamic executable/shared library
    if (elf->header().file_type() != LIEF::ELF::Header::FILE_TYPE::EXEC &&
        elf->header().file_type() != LIEF::ELF::Header::FILE_TYPE::DYN) {
      log.error("unsupported elf file type", redlog::field("type", static_cast<int>(elf->header().file_type())));
      return result{
          .code = error_code::unsupported_architecture,
          .error_message = "only dynamic executables and shared libraries are supported for library import insertion",
          .system_error_code = {}
      };
    }

    // check for existing library dependency
    bool already_imported = false;
    for (const auto& entry : elf->dynamic_entries()) {
      if (entry.tag() == LIEF::ELF::DynamicEntry::TAG::NEEDED) {
        auto* lib_entry = dynamic_cast<const LIEF::ELF::DynamicEntryLibrary*>(&entry);
        if (lib_entry && lib_entry->name() == cfg.library_path) {
          already_imported = true;
          log.trc("duplicate library detected", redlog::field("library", cfg.library_path));
          if (!cfg.assume_yes) {
            return result{
                .code = error_code::duplicate_library,
                .error_message = "binary already depends on " + cfg.library_path + " (use assume_yes=true to continue)",
                .system_error_code = {}
            };
          } else {
            log.info("continuing with duplicate library dependency (assume_yes=true)");
          }
          break;
        }
      }
    }

    // add library dependency
    if (!already_imported) {
      log.trc("adding library dependency", redlog::field("library", cfg.library_path));
      elf->add_library(cfg.library_path);

      log.dbg("library dependency added successfully", redlog::field("library", cfg.library_path));
    }

    // note about weak imports - elf doesn't have direct equivalent to weak dylib imports
    if (cfg.weak_import) {
      log.warn("weak imports not supported for elf format - library will be added as regular dependency");
    }

    // write modified binary
    log.trc("writing modified elf binary", redlog::field("output", final_binary_path));
    LIEF::ELF::Builder builder(*elf);
    builder.write(final_binary_path);

    log.inf(
        "successfully added library dependency", redlog::field("library", cfg.library_path),
        redlog::field("binary", final_binary_path)
    );

    return result{
        .code = error_code::success, .error_message = "library import inserted successfully", .system_error_code = {}
    };

  } catch (const std::exception& e) {
    log.error("error processing elf binary", redlog::field("error", e.what()));
    return result{
        .code = error_code::invalid_binary_format,
        .error_message = std::string("LIEF ELF processing error: ") + e.what(),
        .system_error_code = {}
    };
  }
#endif
}

bool check_import_capabilities() {
#ifdef WITNESS_LIEF_ENABLED
  return true; // linux elf support available via LIEF
#else
  return false; // requires LIEF library
#endif
}

} // namespace w1::import_insertion::linux_impl
```

`src/w1import/platform/linux/linux_import_inserter.hpp`:

```hpp
#pragma once

#include "w1import/import_insertion.hpp"

namespace w1::import_insertion::linux_impl {

// stub implementation for linux platform
result insert_library_import(const config& cfg);

// capabilities check
bool check_import_capabilities();

} // namespace w1::import_insertion::linux_impl
```

`src/w1import/platform/macos/macos_import_inserter.cpp`:

```cpp
#include "macos_import_inserter.hpp"
#include "../../backend/macos/macho_processor.hpp"
#include <filesystem>
#include <redlog.hpp>

// macOS-specific includes
#include <copyfile.h>

namespace fs = std::filesystem;

namespace w1::import_insertion::macos {

result insert_library_import(const config& cfg) {
  auto log = redlog::get_logger("w1.import_insertion.macos");

  log.inf(
      "starting macos library import insertion", redlog::field("library_path", cfg.library_path),
      redlog::field("target_binary", cfg.target_binary), redlog::field("in_place", cfg.in_place),
      redlog::field("weak", cfg.weak_import)
  );

  // check if dylib exists (unless it's a special path like @rpath)
  if (cfg.library_path[0] != '@' && !fs::exists(cfg.library_path)) {
    log.warn("dylib path does not exist", redlog::field("path", cfg.library_path));
    if (!cfg.assume_yes) {
      return result{
          .code = error_code::library_path_invalid, .error_message = "library path does not exist: " + cfg.library_path
      };
    } else {
      log.info("continuing anyway (assume_yes=true)");
    }
  }

  // check if binary exists
  if (!fs::exists(cfg.target_binary)) {
    log.error("binary path does not exist", redlog::field("path", cfg.target_binary));
    return result{.code = error_code::file_not_found, .error_message = "target binary not found: " + cfg.target_binary};
  }

  // determine output path
  std::string final_binary_path;
  if (cfg.in_place) {
    final_binary_path = cfg.target_binary;
    log.trc("using in-place modification");
  } else if (cfg.output_path) {
    final_binary_path = *cfg.output_path;
    log.trc("using specified output path", redlog::field("output_path", final_binary_path));
  } else {
    final_binary_path = cfg.target_binary + "_patched";
    log.trc("using default output path", redlog::field("output_path", final_binary_path));
  }

  // copy file if not in-place
  if (!cfg.in_place) {
    if (fs::exists(final_binary_path) && !cfg.overwrite_existing) {
      if (!cfg.assume_yes) {
        return result{
            .code = error_code::output_already_exists,
            .error_message = "output file already exists: " + final_binary_path + " (use overwrite_existing=true)"
        };
      } else {
        log.info("overwriting existing output file (assume_yes=true)");
      }
    }

    // use copyfile for proper macOS file copying
    if (copyfile(cfg.target_binary.c_str(), final_binary_path.c_str(), nullptr, COPYFILE_DATA | COPYFILE_UNLINK) != 0) {
      log.error(
          "failed to copy file", redlog::field("source", cfg.target_binary),
          redlog::field("destination", final_binary_path)
      );
      return result{
          .code = error_code::system_error,
          .error_message = "failed to copy binary to output path",
          .system_error_code = errno
      };
    }
    log.info(
        "copied file", redlog::field("source", cfg.target_binary), redlog::field("destination", final_binary_path)
    );
  }

  try {
    // process the binary
    log.trc("initializing mach-o processor", redlog::field("file", final_binary_path));
    backend::macos::MachOProcessor processor(
        final_binary_path, cfg.weak_import, cfg.strip_code_signature, !cfg.assume_yes
    );

    log.trc("beginning dylib insertion process");
    if (processor.insert_dylib_load_command(cfg.library_path)) {
      std::string lc_name = cfg.weak_import ? "LC_LOAD_WEAK_DYLIB" : "LC_LOAD_DYLIB";
      log.inf(
          "successfully added dylib load command", redlog::field("dylib", cfg.library_path),
          redlog::field("binary", final_binary_path), redlog::field("load_command", lc_name)
      );
      return result{.code = error_code::success, .error_message = "library import inserted successfully"};
    } else {
      log.error("failed to insert dylib load command");
      if (!cfg.in_place) {
        log.dbg("cleaning up failed output file", redlog::field("file", final_binary_path));
        fs::remove(final_binary_path);
      }
      return result{
          .code = error_code::unknown_error, .error_message = "mach-o processor failed to insert library import"
      };
    }
  } catch (const std::exception& e) {
    log.error("error processing binary", redlog::field("error", e.what()));
    if (!cfg.in_place) {
      fs::remove(final_binary_path);
    }
    return result{
        .code = error_code::system_error, .error_message = std::string("binary processing error: ") + e.what()
    };
  }
}

bool check_import_capabilities() {
  return true; // macOS is fully supported
}

} // namespace w1::import_insertion::macos
```

`src/w1import/platform/macos/macos_import_inserter.hpp`:

```hpp
#pragma once

#include "w1import/import_insertion.hpp"

namespace w1::import_insertion::macos {

// wrapper around the macos backend implementation
result insert_library_import(const config& cfg);

// capabilities check
bool check_import_capabilities();

} // namespace w1::import_insertion::macos
```

`src/w1import/platform/windows/windows_import_inserter.cpp`:

```cpp
#include "windows_import_inserter.hpp"
#include <filesystem>
#include <redlog.hpp>

#ifdef WITNESS_LIEF_ENABLED
#include <LIEF/PE.hpp>
#endif

namespace fs = std::filesystem;

namespace w1::import_insertion::windows {

result insert_library_import(const config& cfg) {
  auto log = redlog::get_logger("w1.import_insertion.windows");

#ifndef WITNESS_LIEF_ENABLED
  log.error("windows library import insertion requires LIEF support");
  return result{
      .code = error_code::platform_not_supported,
      .error_message = "windows library import insertion requires LIEF library support (build with -DWITNESS_LIEF=ON)"
  };
#else

  log.inf(
      "starting windows pe library import insertion", redlog::field("library_path", cfg.library_path),
      redlog::field("target_binary", cfg.target_binary), redlog::field("in_place", cfg.in_place)
  );

  // validate binary exists
  if (!fs::exists(cfg.target_binary)) {
    log.error("binary path does not exist", redlog::field("path", cfg.target_binary));
    return result{.code = error_code::file_not_found, .error_message = "target binary not found: " + cfg.target_binary};
  }

  // determine output path
  std::string final_binary_path;
  if (cfg.in_place) {
    final_binary_path = cfg.target_binary;
    log.trc("using in-place modification");
  } else if (cfg.output_path) {
    final_binary_path = *cfg.output_path;
    log.trc("using specified output path", redlog::field("output_path", final_binary_path));
  } else {
    final_binary_path = cfg.target_binary + "_patched";
    log.trc("using default output path", redlog::field("output_path", final_binary_path));
  }

  // check if output already exists
  if (final_binary_path != cfg.target_binary && fs::exists(final_binary_path) && !cfg.overwrite_existing) {
    if (!cfg.assume_yes) {
      return result{
          .code = error_code::output_already_exists,
          .error_message = "output file already exists: " + final_binary_path + " (use overwrite_existing=true)"
      };
    } else {
      log.info("overwriting existing output file (assume_yes=true)");
    }
  }

  try {
    // parse pe binary
    log.trc("parsing pe binary", redlog::field("file", cfg.target_binary));
    auto pe = LIEF::PE::Parser::parse(cfg.target_binary);
    if (!pe) {
      log.error("failed to parse pe binary", redlog::field("file", cfg.target_binary));
      return result{
          .code = error_code::invalid_binary_format,
          .error_message = "failed to parse PE binary - invalid format or corrupted file"
      };
    }

    // validate architecture compatibility if needed
    log.dbg(
        "pe binary details", redlog::field("machine_type", static_cast<int>(pe->header().machine())),
        redlog::field("is_32bit", pe->type() == LIEF::PE::PE_TYPE::PE32),
        redlog::field("is_64bit", pe->type() == LIEF::PE::PE_TYPE::PE32_PLUS)
    );

    // check for existing import
    bool already_imported = false;
    for (const auto& import : pe->imports()) {
      if (import.name() == cfg.library_path) {
        already_imported = true;
        log.trc("duplicate dll detected", redlog::field("dll", cfg.library_path));
        if (!cfg.assume_yes) {
          return result{
              .code = error_code::duplicate_library,
              .error_message = "binary already imports " + cfg.library_path + " (use assume_yes=true to continue)"
          };
        } else {
          log.info("continuing with duplicate dll import (assume_yes=true)");
        }
        break;
      }
    }

    // add library import
    if (!already_imported) {
      log.trc("adding dll import", redlog::field("dll", cfg.library_path));
      pe->add_import(cfg.library_path);

      log.dbg("dll import added successfully", redlog::field("dll", cfg.library_path));
    }

    // write modified binary
    log.trc("writing modified pe binary", redlog::field("output", final_binary_path));
    LIEF::PE::Builder::config_t builder_config{};
    builder_config.imports = true;
    pe->write(final_binary_path, builder_config);

    log.inf(
        "successfully added dll import", redlog::field("dll", cfg.library_path),
        redlog::field("binary", final_binary_path)
    );

    return result{.code = error_code::success, .error_message = "library import inserted successfully"};

  } catch (const std::exception& e) {
    log.error("error processing pe binary", redlog::field("error", e.what()));
    return result{
        .code = error_code::system_error, .error_message = std::string("PE binary processing error: ") + e.what()
    };
  }
#endif
}

bool check_import_capabilities() {
#ifdef WITNESS_LIEF_ENABLED
  return true; // windows pe support available via LIEF
#else
  return false; // requires LIEF library
#endif
}

} // namespace w1::import_insertion::windows

```

`src/w1import/platform/windows/windows_import_inserter.hpp`:

```hpp
#pragma once

#include "w1import/import_insertion.hpp"

namespace w1::import_insertion::windows {

// stub implementation for windows platform
result insert_library_import(const config& cfg);

// capabilities check
bool check_import_capabilities();

} // namespace w1::import_insertion::windows
```

`src/w1instrument/CMakeLists.txt`:

```txt
w1_add_static_library(w1instrument
    core/instrumentation_policy.cpp
    core/vm_controller.cpp
)
add_library(w1::instrument ALIAS w1instrument)

target_link_libraries(w1instrument PUBLIC w1runtime w1base)

```

`src/w1instrument/config/tracer_common_config.hpp`:

```hpp
#pragma once

#include <array>
#include <string_view>

#include "w1base/env_config.hpp"
#include "w1instrument/core/instrumentation_policy.hpp"

namespace w1::instrument::config {

enum class thread_attach_policy {
  main_only,
  auto_attach,
};

struct tracer_common_config {
  w1::core::instrumentation_policy instrumentation{};
  bool exclude_self = true;
  int verbose = 0;
};

inline w1::core::instrumentation_policy load_instrumentation_policy(w1::util::env_config& loader) {
  w1::core::instrumentation_policy policy{};
  using system_policy = w1::core::system_module_policy;

  system_policy system = system_policy::exclude_all;
  system = loader.get_enum<system_policy>(
      {
          {"exclude", system_policy::exclude_all},
          {"exclude_all", system_policy::exclude_all},
          {"none", system_policy::exclude_all},
          {"critical", system_policy::include_critical},
          {"include_critical", system_policy::include_critical},
          {"all", system_policy::include_all},
          {"include_all", system_policy::include_all},
          {"include", system_policy::include_all},
      },
      "SYSTEM_POLICY", system
  );

  policy.system_policy = system;
  policy.include_unnamed_modules = loader.get<bool>("INCLUDE_UNNAMED", false);
  policy.use_default_excludes = loader.get<bool>("USE_DEFAULT_EXCLUDES", true);
  policy.include_modules = loader.get_list("INCLUDE");
  policy.exclude_modules = loader.get_list("EXCLUDE");
  return policy;
}

inline tracer_common_config load_common(w1::util::env_config& loader) {
  tracer_common_config config;
  config.instrumentation = load_instrumentation_policy(loader);
  config.exclude_self = loader.get<bool>("EXCLUDE_SELF", true);
  config.verbose = loader.get<int>("VERBOSE", 0);
  return config;
}

inline thread_attach_policy load_thread_attach_policy(
    w1::util::env_config& loader, thread_attach_policy fallback = thread_attach_policy::auto_attach
) {
  return loader.get_enum<thread_attach_policy>(
      {
          {"main", thread_attach_policy::main_only},
          {"auto", thread_attach_policy::auto_attach},
      },
      "THREADS", fallback
  );
}

inline constexpr std::array<std::string_view, 8> common_reserved_keys() {
  return {
      "SYSTEM_POLICY", "INCLUDE_UNNAMED", "USE_DEFAULT_EXCLUDES", "INCLUDE", "EXCLUDE", "EXCLUDE_SELF",
      "VERBOSE",       "THREADS",
  };
}

inline bool is_common_reserved_key(std::string_view key) {
  for (auto entry : common_reserved_keys()) {
    if (entry == key) {
      return true;
    }
  }
  return false;
}

} // namespace w1::instrument::config

```

`src/w1instrument/core/instrumentation_policy.cpp`:

```cpp
#include "w1instrument/core/instrumentation_policy.hpp"

#include <algorithm>
#include <string_view>

namespace w1::core {
namespace {

std::vector<std::string> default_exclude_modules() {
#ifdef __APPLE__
  return {"libQBDI",          "qbdipreload",       "libsystem_malloc",   "libsystem_c",
          "libsystem_kernel", "libsystem_pthread", "libsystem_platform", "libobjc"};
#elif defined(__linux__)
  return {"libQBDI",  "qbdipreload", "libc-2.", "libc.so.", "ld-2.",
          "ld-linux", "libpthread-", "libcofi", "libdl",    "librt"};
#elif defined(_WIN32)
  return {"QBDI",    "qbdipreload", "advapi",   "combase", "comctl32", "comdlg",    "gdi32", "gdiplus", "imm32",
          "kernel",  "msvcp",       "msvcrt",   "ntdll",   "ole32",    "oleaut",    "rpcrt", "sechost", "shcore",
          "shell32", "shlwapi",     "ucrtbase", "user32",  "uxtheme",  "vcruntime", "win32u"};
#else
  return {};
#endif
}

std::vector<std::string> critical_system_modules() {
#ifdef __APPLE__
  return {"libSystem", "libdispatch", "libc++", "libc++abi", "libdyld", "dyld"};
#elif defined(__linux__)
  return {"ld-linux", "ld-2.", "libc.so.", "libpthread", "libdl", "librt"};
#elif defined(_WIN32)
  return {"ntdll", "kernel", "kernel32", "user32"};
#else
  return {};
#endif
}

bool matches_any(std::string_view name, std::string_view path, const std::vector<std::string>& patterns) {
  for (const auto& pattern : patterns) {
    if (!pattern.empty() &&
        (name.find(pattern) != std::string_view::npos || path.find(pattern) != std::string_view::npos)) {
      return true;
    }
  }
  return false;
}

} // namespace

bool instrumentation_policy::should_instrument(const runtime::module_info& module) const {
  std::string_view name = module.name;
  std::string_view path = module.path;

  if (!include_unnamed_modules && name.rfind("_unnamed_", 0) == 0) {
    return false;
  }

  if (use_default_excludes && matches_any(name, path, default_exclude_modules())) {
    return false;
  }

  if (!exclude_modules.empty() && matches_any(name, path, exclude_modules)) {
    return false;
  }

  if (!include_modules.empty() && !matches_any(name, path, include_modules)) {
    return false;
  }

  if (module.is_system) {
    switch (system_policy) {
    case system_module_policy::exclude_all:
      return false;
    case system_module_policy::include_critical:
      return matches_any(name, path, critical_system_modules());
    case system_module_policy::include_all:
      return true;
    default:
      return false;
    }
  }

  return true;
}

} // namespace w1::core

```

`src/w1instrument/core/instrumentation_policy.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>

#include "w1runtime/module_catalog.hpp"

namespace w1::core {

enum class system_module_policy { exclude_all, include_critical, include_all };

struct instrumentation_policy {
  system_module_policy system_policy = system_module_policy::exclude_all;
  bool include_unnamed_modules = false;
  bool use_default_excludes = true;
  std::vector<std::string> include_modules;
  std::vector<std::string> exclude_modules;

  bool should_instrument(const runtime::module_info& module) const;
};

} // namespace w1::core

```

`src/w1instrument/core/module_cache.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include <utility>

namespace w1::core {

template <typename ValueT> struct module_lookup {
  ValueT value{};
  uint64_t base = 0;
  uint64_t end = 0;
  uint64_t epoch = 0;
};

template <typename ValueT> class module_cache {
public:
  module_cache() = default;

  void reset() { entry_ = {}; }

  template <typename Resolver> std::optional<ValueT> resolve(uint64_t address, uint64_t epoch, Resolver&& resolver) {
    if (entry_.valid && entry_.epoch == epoch && address >= entry_.base && address < entry_.end) {
      return entry_.value;
    }

    auto lookup = resolver(address);
    if (!lookup) {
      return std::nullopt;
    }

    entry_.value = lookup->value;
    entry_.base = lookup->base;
    entry_.end = lookup->end;
    entry_.epoch = lookup->epoch;
    entry_.valid = true;
    return entry_.value;
  }

private:
  struct cache_entry {
    ValueT value{};
    uint64_t base = 0;
    uint64_t end = 0;
    uint64_t epoch = 0;
    bool valid = false;
  };

  cache_entry entry_{};
};

} // namespace w1::core

```

`src/w1instrument/core/module_id_map.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <mutex>
#include <optional>
#include <shared_mutex>
#include <string>
#include <string_view>
#include <unordered_map>
#include <utility>
#include <vector>

#include "w1instrument/core/module_cache.hpp"
#include "w1runtime/module_catalog.hpp"

namespace w1::core {

// PolicyT must provide:
//  - bool include(const w1::runtime::module_info&) const
//  - std::string_view identity(const w1::runtime::module_info&) const
// The identity is used to keep module IDs stable across refreshes.
template <typename PolicyT, typename IdT = uint16_t> class module_id_map {
public:
  explicit module_id_map(PolicyT policy = {}) : policy_(std::move(policy)) {}

  void configure(const runtime::module_catalog& modules) {
    modules_ = &modules;
    {
      std::unique_lock<std::shared_mutex> lock(mutex_);
      modules_by_id_.clear();
      module_map_.clear();
    }
    seed_from_catalog();
  }

  std::optional<module_lookup<IdT>> find(uint64_t address) const {
    if (!modules_ || address == 0) {
      return std::nullopt;
    }

    const auto* module = modules_->find_containing(address);
    if (!module || !policy_.include(*module)) {
      return std::nullopt;
    }

    const uint64_t version = modules_->version();
    const uint64_t base = module->base_address;
    const uint64_t end = module->base_address + module->size;
    const std::string_view identity = policy_.identity(*module);

    {
      std::shared_lock<std::shared_mutex> lock(mutex_);
      auto it = module_map_.find(base);
      if (it != module_map_.end() && it->second.identity == identity && it->second.size == module->size) {
        return module_lookup<IdT>{it->second.id, base, end, version};
      }
    }

    std::unique_lock<std::shared_mutex> lock(mutex_);
    auto it = module_map_.find(base);
    if (it != module_map_.end() && it->second.identity == identity && it->second.size == module->size) {
      return module_lookup<IdT>{it->second.id, base, end, version};
    }

    IdT id = register_module_locked(*module);
    module_map_[base] = module_entry{id, std::string(identity), module->size};
    return module_lookup<IdT>{id, base, end, version};
  }

  uint64_t registry_version() const { return modules_ ? modules_->version() : 0; }

  std::vector<runtime::module_info> snapshot_modules() const {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    return modules_by_id_;
  }

  size_t tracked_module_count() const {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    return modules_by_id_.size();
  }

  PolicyT& policy() { return policy_; }
  const PolicyT& policy() const { return policy_; }

private:
  struct module_entry {
    IdT id{};
    std::string identity;
    uint64_t size = 0;
  };

  void seed_from_catalog() {
    if (!modules_) {
      return;
    }

    auto list = modules_->list_modules();

    std::unique_lock<std::shared_mutex> lock(mutex_);
    modules_by_id_.reserve(list.size());
    module_map_.reserve(list.size());

    for (const auto& module : list) {
      if (!policy_.include(module)) {
        continue;
      }

      const uint64_t base = module.base_address;
      const std::string_view identity = policy_.identity(module);

      auto it = module_map_.find(base);
      if (it != module_map_.end() && it->second.identity == identity && it->second.size == module.size) {
        continue;
      }

      const IdT id = register_module_locked(module);
      module_map_[base] = module_entry{id, std::string(identity), module.size};
    }
  }

  IdT register_module_locked(const runtime::module_info& module) const {
    modules_by_id_.push_back(module);
    return static_cast<IdT>(modules_by_id_.size() - 1);
  }

  PolicyT policy_{};
  const runtime::module_catalog* modules_ = nullptr;

  mutable std::shared_mutex mutex_{};
  mutable std::vector<runtime::module_info> modules_by_id_{};
  mutable std::unordered_map<uint64_t, module_entry> module_map_{};
};

} // namespace w1::core

```

`src/w1instrument/core/module_registry.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <mutex>
#include <optional>
#include <shared_mutex>
#include <string>
#include <string_view>
#include <unordered_map>
#include <utility>
#include <vector>

#include "w1instrument/core/instrumentation_policy.hpp"
#include "w1instrument/core/module_cache.hpp"
#include "w1runtime/module_catalog.hpp"

namespace w1::core {

struct instrumented_module_policy {
  instrumentation_policy instrumentation{};

  bool include(const runtime::module_info& module) const { return instrumentation.should_instrument(module); }

  std::string_view identity(const runtime::module_info& module) const {
    return module.path.empty() ? module.name : module.path;
  }
};

// PolicyT must provide:
//  - bool include(const w1::runtime::module_info&) const
//  - std::string_view identity(const w1::runtime::module_info&) const
// The identity is used to keep module IDs stable across refreshes.
//
// IdT should fit module table size constraints (e.g. uint16_t for drcov).
template <typename PolicyT = instrumented_module_policy, typename IdT = uint16_t> class module_registry {
public:
  explicit module_registry(PolicyT policy = {}) : policy_(std::move(policy)) {}

  void configure(runtime::module_catalog& modules) {
    modules_ = &modules;
    {
      std::unique_lock<std::shared_mutex> lock(mutex_);
      modules_by_id_.clear();
      module_map_.clear();
    }
    seed_from_catalog();
  }

  std::optional<module_lookup<IdT>> find(uint64_t address) const {
    if (!modules_ || address == 0) {
      return std::nullopt;
    }

    const auto* module = modules_->find_containing(address);
    if (!module || !policy_.include(*module)) {
      return std::nullopt;
    }

    const uint64_t version = modules_->version();
    const uint64_t base = module->base_address;
    const uint64_t end = module->base_address + module->size;
    const std::string_view identity = policy_.identity(*module);

    {
      std::shared_lock<std::shared_mutex> lock(mutex_);
      auto it = module_map_.find(base);
      if (it != module_map_.end() && it->second.identity == identity && it->second.size == module->size) {
        return module_lookup<IdT>{it->second.id, base, end, version};
      }
    }

    std::unique_lock<std::shared_mutex> lock(mutex_);
    auto it = module_map_.find(base);
    if (it != module_map_.end() && it->second.identity == identity && it->second.size == module->size) {
      return module_lookup<IdT>{it->second.id, base, end, version};
    }

    IdT id = register_module_locked(*module);
    module_map_[base] = module_entry{id, std::string(identity), module->size};
    return module_lookup<IdT>{id, base, end, version};
  }

  uint64_t registry_version() const { return modules_ ? modules_->version() : 0; }

  std::vector<runtime::module_info> snapshot_modules() const {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    return modules_by_id_;
  }

  size_t tracked_module_count() const {
    std::shared_lock<std::shared_mutex> lock(mutex_);
    return modules_by_id_.size();
  }

  PolicyT& policy() { return policy_; }
  const PolicyT& policy() const { return policy_; }

private:
  struct module_entry {
    IdT id{};
    std::string identity;
    uint64_t size = 0;
  };

  void seed_from_catalog() {
    if (!modules_) {
      return;
    }

    auto list = modules_->list_modules();

    std::unique_lock<std::shared_mutex> lock(mutex_);
    modules_by_id_.reserve(list.size());
    module_map_.reserve(list.size());

    for (const auto& module : list) {
      if (!policy_.include(module)) {
        continue;
      }

      const uint64_t base = module.base_address;
      const std::string_view identity = policy_.identity(module);

      auto it = module_map_.find(base);
      if (it != module_map_.end() && it->second.identity == identity && it->second.size == module.size) {
        continue;
      }

      const IdT id = register_module_locked(module);
      module_map_[base] = module_entry{id, std::string(identity), module.size};
    }
  }

  IdT register_module_locked(const runtime::module_info& module) const {
    modules_by_id_.push_back(module);
    return static_cast<IdT>(modules_by_id_.size() - 1);
  }

  PolicyT policy_{};
  runtime::module_catalog* modules_ = nullptr;

  mutable std::shared_mutex mutex_{};
  mutable std::vector<runtime::module_info> modules_by_id_{};
  mutable std::unordered_map<uint64_t, module_entry> module_map_{};
};

} // namespace w1::core

```

`src/w1instrument/core/thread_buffer.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <optional>
#include <unordered_map>
#include <utility>

namespace w1::core {

template <typename KeyT, typename EntryT, typename MergeT> class thread_buffer {
public:
  thread_buffer(MergeT merge, size_t reserve = 0, size_t flush_threshold = 0)
      : merge_(std::move(merge)), flush_threshold_(flush_threshold) {
    if (reserve > 0) {
      buffer_.reserve(reserve);
    }
  }

  void clear() { buffer_.clear(); }

  void flush() {
    if (buffer_.empty()) {
      return;
    }
    merge_(buffer_);
    buffer_.clear();
  }

  size_t size() const { return buffer_.size(); }

  template <typename UpdateFn, typename CreateFn> void record(const KeyT& key, UpdateFn&& update, CreateFn&& create) {
    auto it = buffer_.find(key);
    if (it != buffer_.end()) {
      update(it->second);
      return;
    }

    auto created = create();
    if (!created) {
      return;
    }

    buffer_.emplace(key, std::move(*created));
    if (flush_threshold_ != 0 && buffer_.size() >= flush_threshold_) {
      flush();
    }
  }

private:
  std::unordered_map<KeyT, EntryT> buffer_{};
  MergeT merge_;
  size_t flush_threshold_ = 0;
};

} // namespace w1::core

```

`src/w1instrument/core/vm_controller.cpp`:

```cpp
#include "w1instrument/core/vm_controller.hpp"

namespace w1::core {

vm_controller::vm_controller() : owned_vm_(std::make_unique<QBDI::VM>()), vm_(owned_vm_.get()), owns_vm_(true) {}

vm_controller::vm_controller(QBDI::VM* borrowed_vm) : vm_(borrowed_vm), owns_vm_(false) {}

} // namespace w1::core

```

`src/w1instrument/core/vm_controller.hpp`:

```hpp
#pragma once

#include <memory>

#include <QBDI.h>

namespace w1::core {

class vm_controller {
public:
  vm_controller();
  explicit vm_controller(QBDI::VM* borrowed_vm);

  vm_controller(const vm_controller&) = delete;
  vm_controller& operator=(const vm_controller&) = delete;

  QBDI::VM* vm() const { return vm_; }
  bool owns_vm() const { return owns_vm_; }

private:
  std::unique_ptr<QBDI::VM> owned_vm_{};
  QBDI::VM* vm_ = nullptr;
  bool owns_vm_ = false;
};

} // namespace w1::core

```

`src/w1instrument/logging.hpp`:

```hpp
#pragma once

#include <redlog.hpp>

namespace w1::instrument {

inline void configure_redlog_verbosity(int verbose, bool allow_annoying = false) {
  if (allow_annoying && verbose >= 5) {
    redlog::set_level(redlog::level::annoying);
  } else if (verbose >= 4) {
    redlog::set_level(redlog::level::pedantic);
  } else if (verbose >= 3) {
    redlog::set_level(redlog::level::debug);
  } else if (verbose >= 2) {
    redlog::set_level(redlog::level::trace);
  } else if (verbose >= 1) {
    redlog::set_level(redlog::level::verbose);
  } else {
    redlog::set_level(redlog::level::info);
  }
}

} // namespace w1::instrument

```

`src/w1instrument/preload/entrypoints.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <memory>
#include <utility>

#include "QBDIPreload.h"

#include "w1instrument/preload/immortal_state.hpp"
#include "w1instrument/tracer/recipe.hpp"

namespace w1::instrument {

namespace detail {

template <tracer_recipe Recipe> struct preload_state {
  using config_t = typename Recipe::config_t;
  using runtime_t = typename Recipe::runtime_t;

  std::unique_ptr<config_t> config;
  std::unique_ptr<runtime_t> runtime;
};

template <tracer_recipe Recipe> preload_state<Recipe>& state() {
  return immortal_preload_state<preload_state<Recipe>>();
}

template <typename Recipe>
concept has_on_start = requires(void* main) {
  { Recipe::on_start(main) } -> std::same_as<int>;
};

template <typename Recipe>
concept has_on_premain = requires(void* gpr_ctx, void* fpu_ctx) {
  { Recipe::on_premain(gpr_ctx, fpu_ctx) } -> std::same_as<int>;
};

template <typename Recipe>
concept has_on_main = requires(int argc, char** argv) {
  { Recipe::on_main(argc, argv) } -> std::same_as<int>;
};

} // namespace detail

template <tracer_recipe Recipe> int preload_on_run(QBDI::VMInstanceRef vm, QBDI::rword start, QBDI::rword stop) {
  using config_t = typename Recipe::config_t;
  using runtime_t = typename Recipe::runtime_t;

  auto& st = detail::state<Recipe>();
  st.config = std::make_unique<config_t>(Recipe::load_config());
  Recipe::configure_logging(*st.config);
  Recipe::apply_self_excludes(*st.config, reinterpret_cast<const void*>(&preload_on_run<Recipe>));
  Recipe::log_config(*st.config);

  st.runtime = std::make_unique<runtime_t>(Recipe::make_runtime(*st.config));
  if (!Recipe::run_main(
          *st.runtime, static_cast<QBDI::VM*>(vm), static_cast<uint64_t>(start), static_cast<uint64_t>(stop)
      )) {
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  return QBDIPRELOAD_NO_ERROR;
}

template <tracer_recipe Recipe> int preload_on_exit(int status) {
  auto& st = detail::state<Recipe>();
  if (st.runtime && st.config) {
    Recipe::on_exit(*st.runtime, *st.config, status);
  }

  st.runtime.release();
  st.config.release();
  return QBDIPRELOAD_NO_ERROR;
}

template <tracer_recipe Recipe> int preload_on_start(void* main) {
  if constexpr (detail::has_on_start<Recipe>) {
    return Recipe::on_start(main);
  }
  (void) main;
  return QBDIPRELOAD_NOT_HANDLED;
}

template <tracer_recipe Recipe> int preload_on_premain(void* gpr_ctx, void* fpu_ctx) {
  if constexpr (detail::has_on_premain<Recipe>) {
    return Recipe::on_premain(gpr_ctx, fpu_ctx);
  }
  (void) gpr_ctx;
  (void) fpu_ctx;
  return QBDIPRELOAD_NOT_HANDLED;
}

template <tracer_recipe Recipe> int preload_on_main(int argc, char** argv) {
  if constexpr (detail::has_on_main<Recipe>) {
    return Recipe::on_main(argc, argv);
  }
  (void) argc;
  (void) argv;
  return QBDIPRELOAD_NOT_HANDLED;
}

} // namespace w1::instrument

```

`src/w1instrument/preload/immortal_state.hpp`:

```hpp
#pragma once

namespace w1::instrument {

// return a reference to a heap-allocated state object that intentionally
// survives static destruction, to avoid shutdown-order teardown issues in preload
template <typename State> State& immortal_preload_state() {
  static State* state = new State();
  return *state;
}

} // namespace w1::instrument

```

`src/w1instrument/process/process_session.hpp`:

```hpp
#pragma once

#include <atomic>
#include <functional>
#include <memory>
#include <mutex>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

#include <QBDI.h>

#include "w1base/thread_utils.hpp"
#include "w1instrument/trace/thread_session.hpp"
#include "w1runtime/process_observer.hpp"

namespace w1::instrument {

template <tracer tracer_t> class process_session {
public:
  struct hooks {
    std::function<void(const runtime::process_event&)> on_event;
    std::function<void(const runtime::thread_info&)> on_thread_attach;
    std::function<void(const runtime::thread_info&)> on_thread_detach;
  };

  struct config {
    core::instrumentation_policy instrumentation{};
    QBDI::Options vm_options = QBDI::Options::NO_OPT;
    bool attach_new_threads = true;
    bool refresh_on_module_events = true;
    bool owns_observer = true;
    hooks callbacks{};
  };

  using session_type = thread_session<tracer_t>;
  using tracer_factory = std::function<tracer_t(const runtime::thread_info&)>;

  process_session(runtime::process_observer& observer, config cfg, tracer_factory factory)
      : observer_(observer), config_(std::move(cfg)), factory_(std::move(factory)) {
    callback_state_ = std::make_shared<callback_state>();
    callback_state_->owner = this;
  }

  process_session(const process_session&) = delete;
  process_session& operator=(const process_session&) = delete;
  process_session(process_session&&) = delete;
  process_session& operator=(process_session&&) = delete;

  ~process_session() { stop(); }

  void set_callbacks(hooks callbacks) { config_.callbacks = std::move(callbacks); }
  void set_on_event(std::function<void(const runtime::process_event&)> callback) {
    config_.callbacks.on_event = std::move(callback);
  }
  void set_on_thread_attach(std::function<void(const runtime::thread_info&)> callback) {
    config_.callbacks.on_thread_attach = std::move(callback);
  }
  void set_on_thread_detach(std::function<void(const runtime::thread_info&)> callback) {
    config_.callbacks.on_thread_detach = std::move(callback);
  }

  void start() {
    if (started_.exchange(true, std::memory_order_acq_rel)) {
      return;
    }

    if (config_.owns_observer && !observer_.running()) {
      observer_.start();
      started_observer_ = true;
    }

    observer_.modules().refresh();

    callback_state_->active.store(true, std::memory_order_release);
    auto weak_state = std::weak_ptr<callback_state>(callback_state_);

    if (subscription_id_ == 0) {
      subscription_id_ = observer_.subscribe([weak_state](const runtime::process_event& event) {
        auto state = weak_state.lock();
        if (!state || !state->active.load(std::memory_order_acquire) || !state->owner) {
          return;
        }
        state->owner->handle_event(event);
      });
    }

    if (config_.attach_new_threads) {
      observer_.set_thread_entry_callback([weak_state](const monitor::thread_entry_context& ctx, uint64_t& result_out) {
        auto state = weak_state.lock();
        if (!state || !state->active.load(std::memory_order_acquire) || !state->owner) {
          return false;
        }
        return state->owner->handle_thread_entry(ctx, result_out);
      });
    }
  }

  void stop() {
    if (!started_.exchange(false, std::memory_order_acq_rel)) {
      return;
    }

    callback_state_->active.store(false, std::memory_order_release);
    observer_.set_thread_entry_callback({});

    if (subscription_id_ != 0) {
      observer_.unsubscribe(subscription_id_);
      subscription_id_ = 0;
    }

    auto sessions = take_all_sessions();
    for (auto& entry : sessions) {
      if (entry.second) {
        entry.second->shutdown();
      }
    }

    if (started_observer_) {
      observer_.stop();
      started_observer_ = false;
    }
  }

  std::shared_ptr<session_type> attach_thread(const runtime::thread_info& info, QBDI::VM* borrowed_vm = nullptr) {
    start();
    auto session = attach_session(info, borrowed_vm);
    if (session && config_.callbacks.on_thread_attach) {
      config_.callbacks.on_thread_attach(info);
    }
    return session;
  }

  std::shared_ptr<session_type> attach_current_thread(std::string name = "main") {
    runtime::thread_info info{};
    info.tid = w1::util::current_thread_id();
    info.name = std::move(name);
    return attach_thread(info);
  }

  std::shared_ptr<session_type> attach_current_thread(QBDI::VM* vm, std::string name = "main") {
    runtime::thread_info info{};
    info.tid = w1::util::current_thread_id();
    info.name = std::move(name);
    return attach_thread(info, vm);
  }

  bool run_main(QBDI::VM* vm, uint64_t start, uint64_t stop, std::string name = "main") {
    auto session = attach_current_thread(vm, std::move(name));
    if (!session) {
      return false;
    }

    const uint64_t tid = w1::util::current_thread_id();
    bool ok = session->run(start, stop);
    detach_thread(tid);
    return ok;
  }

  bool call_current_thread(
      uint64_t function_ptr, const std::vector<uint64_t>& args, uint64_t* result = nullptr, std::string name = "main"
  ) {
    auto session = attach_current_thread(std::move(name));
    if (!session) {
      return false;
    }

    const uint64_t tid = w1::util::current_thread_id();
    bool ok = session->call(function_ptr, args, result);
    detach_thread(tid);
    return ok;
  }

  void detach_thread(uint64_t tid) {
    std::shared_ptr<session_type> session;
    {
      std::lock_guard<std::mutex> lock(mutex_);
      auto it = sessions_.find(tid);
      if (it == sessions_.end()) {
        return;
      }
      session = std::move(it->second);
      sessions_.erase(it);
    }

    if (session) {
      session->shutdown();
    }

    if (config_.callbacks.on_thread_detach) {
      runtime::thread_info info = make_thread_info(tid, "thread");
      config_.callbacks.on_thread_detach(info);
    }
  }

  void refresh_all() {
    std::lock_guard<std::mutex> lock(mutex_);
    for (auto& entry : sessions_) {
      if (entry.second) {
        entry.second->request_refresh();
      }
    }
  }

  size_t session_count() const {
    std::lock_guard<std::mutex> lock(mutex_);
    return sessions_.size();
  }

private:
  struct callback_state {
    std::atomic<bool> active{false};
    process_session* owner = nullptr;
  };

  thread_session_config build_base_config() const {
    thread_session_config config{};
    config.instrumentation = config_.instrumentation;
    config.vm_options = config_.vm_options;
    config.shared_modules = &observer_.modules();
    return config;
  }

  runtime::thread_info make_thread_info(uint64_t tid, const char* fallback_name) {
    runtime::thread_info info{};
    info.tid = tid;
    info.name = fallback_name ? fallback_name : "thread";
    if (const auto* existing = observer_.threads().find(tid)) {
      info = *existing;
      if (info.name.empty()) {
        info.name = fallback_name ? fallback_name : "thread";
      }
    }
    return info;
  }

  std::shared_ptr<session_type> attach_session(const runtime::thread_info& info, QBDI::VM* borrowed_vm) {
    if (!factory_ || info.tid == 0) {
      return {};
    }

    if (auto existing = find_session(info.tid)) {
      return existing;
    }

    runtime::thread_info normalized = info;
    if (normalized.name.empty()) {
      normalized.name = "thread";
    }

    thread_session_config config = build_base_config();
    config.thread_id = normalized.tid;
    config.thread_name = normalized.name;

    tracer_t tracer_instance = factory_(normalized);
    std::shared_ptr<session_type> session;
    if (borrowed_vm) {
      session = std::make_shared<session_type>(config, std::move(tracer_instance), borrowed_vm);
    } else {
      session = std::make_shared<session_type>(config, std::move(tracer_instance));
    }

    return insert_session(normalized.tid, std::move(session));
  }

  std::shared_ptr<session_type> find_session(uint64_t tid) const {
    std::lock_guard<std::mutex> lock(mutex_);
    auto it = sessions_.find(tid);
    return it != sessions_.end() ? it->second : nullptr;
  }

  std::shared_ptr<session_type> insert_session(uint64_t tid, std::shared_ptr<session_type> session) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto [it, inserted] = sessions_.emplace(tid, std::move(session));
    return it->second;
  }

  std::unordered_map<uint64_t, std::shared_ptr<session_type>> take_all_sessions() {
    std::lock_guard<std::mutex> lock(mutex_);
    std::unordered_map<uint64_t, std::shared_ptr<session_type>> out;
    out.swap(sessions_);
    return out;
  }

  void handle_event(const runtime::process_event& event) {
    if (config_.callbacks.on_event) {
      config_.callbacks.on_event(event);
    }

    switch (event.type) {
    case runtime::process_event::kind::module_loaded:
    case runtime::process_event::kind::module_unloaded:
      if (config_.refresh_on_module_events) {
        refresh_all();
      }
      break;
    case runtime::process_event::kind::thread_stopped:
      detach_thread(event.thread.tid);
      break;
    default:
      break;
    }
  }

  bool handle_thread_entry(const monitor::thread_entry_context& ctx, uint64_t& result_out) {
    if (!ctx.start_routine) {
      return false;
    }

    auto info = make_thread_info(ctx.tid, "thread");
    auto session = attach_session(info, nullptr);
    if (!session) {
      return false;
    }

    if (config_.callbacks.on_thread_attach) {
      config_.callbacks.on_thread_attach(info);
    }

    if (!session->instrument()) {
      detach_thread(ctx.tid);
      return false;
    }

    std::vector<uint64_t> args(1, reinterpret_cast<uint64_t>(ctx.arg));
    uint64_t result = 0;
    bool ok = session->call(reinterpret_cast<uint64_t>(ctx.start_routine), args, &result);

    detach_thread(ctx.tid);
    if (!ok) {
      return false;
    }

    result_out = result;
    return true;
  }

  runtime::process_observer& observer_;
  config config_{};
  tracer_factory factory_{};

  std::shared_ptr<callback_state> callback_state_{};
  std::atomic<bool> started_{false};
  bool started_observer_ = false;
  runtime::process_observer::subscription_id subscription_id_ = 0;

  mutable std::mutex mutex_{};
  std::unordered_map<uint64_t, std::shared_ptr<session_type>> sessions_{};
};

} // namespace w1::instrument

```

`src/w1instrument/self_exclude.hpp`:

```hpp
#pragma once

#include "w1instrument/core/instrumentation_policy.hpp"
#include "w1base/module_identity.hpp"

namespace w1::util {

inline void append_self_excludes(core::instrumentation_policy& policy, const void* address) {
  module_identity identity = module_identity_from_address(address);
  if (!identity.path.empty()) {
    policy.exclude_modules.push_back(identity.path);
  }
  if (!identity.name.empty()) {
    policy.exclude_modules.push_back(identity.name);
  }
}

} // namespace w1::util

```

`src/w1instrument/trace/event_dispatcher.hpp`:

```hpp
#pragma once

#include <concepts>
#include <cstdint>
#include <type_traits>
#include <vector>

#include <QBDI.h>

#include "w1instrument/tracer/event.hpp"
#include "w1instrument/tracer/trace_context.hpp"
#include "w1instrument/tracer/tracer.hpp"
#include "w1instrument/tracer/types.hpp"

namespace w1::instrument {

// route qbdi callbacks to a thread tracer instance based on the requested event mask
template <tracer tracer_t> class event_dispatcher {
public:
  explicit event_dispatcher(QBDI::VM* vm) : vm_(vm) {}

  event_dispatcher(const event_dispatcher&) = delete;
  event_dispatcher& operator=(const event_dispatcher&) = delete;
  event_dispatcher(event_dispatcher&&) = delete;
  event_dispatcher& operator=(event_dispatcher&&) = delete;

  ~event_dispatcher() { clear(); }

  bool bind(event_mask mask, tracer_t& tracer_instance, trace_context& ctx) {
    if (!vm_) {
      return false;
    }

    clear();
    state_.tracer = &tracer_instance;
    state_.ctx = &ctx;
    state_.mask = mask;
    state_.memory_recording_enabled = false;
    state_.memory_recording_requested = false;

    bool ok = true;

    const bool wants_memory = event_mask_has(mask, event_kind::memory_read) ||
                              event_mask_has(mask, event_kind::memory_write) ||
                              event_mask_has(mask, event_kind::memory_read_write);

    if (wants_memory) {
      state_.memory_recording_requested = true;
      if (!ensure_memory_recording()) {
        ok = false;
      }
    }

    ok = ok && register_instruction_pre();
    ok = ok && register_postinst();
    ok = ok && register_basic_block_entry();
    ok = ok && register_basic_block_exit();
    ok = ok && register_exec_transfer_call();
    ok = ok && register_exec_transfer_return();
    ok = ok && register_vm_start();
    ok = ok && register_vm_stop();

    if (!ok) {
      clear();
      return false;
    }

    return true;
  }

  void clear() {
    if (vm_) {
      for (uint32_t id : callback_ids_) {
        vm_->deleteInstrumentation(id);
      }
    }
    callback_ids_.clear();
    state_ = {};
  }

  void detach() {
    callback_ids_.clear();
    state_ = {};
    vm_ = nullptr;
  }

  bool ensure_memory_recording() {
    if (!vm_ || !state_.memory_recording_requested) {
      return true;
    }
    if (state_.memory_recording_enabled) {
      return true;
    }

    QBDI::MemoryAccessType type = static_cast<QBDI::MemoryAccessType>(0);
    if (event_mask_has(state_.mask, event_kind::memory_read) ||
        event_mask_has(state_.mask, event_kind::memory_read_write)) {
      type = static_cast<QBDI::MemoryAccessType>(type | QBDI::MEMORY_READ);
    }
    if (event_mask_has(state_.mask, event_kind::memory_write) ||
        event_mask_has(state_.mask, event_kind::memory_read_write)) {
      type = static_cast<QBDI::MemoryAccessType>(type | QBDI::MEMORY_WRITE);
    }
    if (type == static_cast<QBDI::MemoryAccessType>(0)) {
      return true;
    }

    state_.memory_recording_enabled = vm_->recordMemoryAccess(type);
    return state_.memory_recording_enabled;
  }

private:
  struct callback_state {
    tracer_t* tracer = nullptr;
    trace_context* ctx = nullptr;
    event_mask mask = 0;
    bool memory_recording_requested = false;
    bool memory_recording_enabled = false;
  };

  bool register_instruction_pre() {
    if (!event_mask_has(state_.mask, event_kind::instruction_pre)) {
      return true;
    }
    if constexpr (has_on_instruction_pre<tracer_t>) {
      uint32_t id = vm_->addCodeCB(
          QBDI::PREINST,
          [](QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, void* data) -> QBDI::VMAction {
            auto* state = static_cast<callback_state*>(data);
            const QBDI::InstAnalysis* inst = vm->getInstAnalysis(QBDI::AnalysisType::ANALYSIS_INSTRUCTION);

            instruction_event event{};
            event.address = inst ? inst->address : QBDI_GPR_GET(gpr, QBDI::REG_PC);
            event.size = inst ? inst->instSize : 0;
            event.thread_id = state->ctx->thread_id();

            if constexpr (std::same_as<
                              decltype(state->tracer->on_instruction_pre(*state->ctx, event, vm, gpr, fpr)),
                              QBDI::VMAction>) {
              return state->tracer->on_instruction_pre(*state->ctx, event, vm, gpr, fpr);
            }
            state->tracer->on_instruction_pre(*state->ctx, event, vm, gpr, fpr);
            return QBDI::VMAction::CONTINUE;
          },
          &state_
      );

      if (id != QBDI::INVALID_EVENTID) {
        callback_ids_.push_back(id);
        return true;
      }
      return false;
    } else {
      return false;
    }
  }

  bool register_postinst() {
    const bool wants_postinst = event_mask_has(state_.mask, event_kind::instruction_post);
    const bool wants_memory = event_mask_has(state_.mask, event_kind::memory_read) ||
                              event_mask_has(state_.mask, event_kind::memory_write) ||
                              event_mask_has(state_.mask, event_kind::memory_read_write);

    if (!wants_postinst && !wants_memory) {
      return true;
    }

    if (wants_postinst && !has_on_instruction_post<tracer_t>) {
      return false;
    }
    if (wants_memory && !has_on_memory<tracer_t>) {
      return false;
    }

    uint32_t id = vm_->addCodeCB(
        QBDI::POSTINST,
        [](QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, void* data) -> QBDI::VMAction {
          auto* state = static_cast<callback_state*>(data);
          const bool postinst_enabled = event_mask_has(state->mask, event_kind::instruction_post);
          const bool memory_enabled = event_mask_has(state->mask, event_kind::memory_read) ||
                                      event_mask_has(state->mask, event_kind::memory_write) ||
                                      event_mask_has(state->mask, event_kind::memory_read_write);

          const QBDI::InstAnalysis* inst = nullptr;
          uint64_t inst_addr = 0;
          uint32_t inst_size = 0;
          if (postinst_enabled || memory_enabled) {
            inst = vm->getInstAnalysis(QBDI::AnalysisType::ANALYSIS_INSTRUCTION);
            if (inst) {
              inst_addr = inst->address;
              inst_size = inst->instSize;
            }
          }

          if constexpr (has_on_instruction_post<tracer_t>) {
            if (postinst_enabled) {
              instruction_event event{};
              event.address = inst_addr != 0 ? inst_addr : QBDI_GPR_GET(gpr, QBDI::REG_PC);
              event.size = inst_size;
              event.thread_id = state->ctx->thread_id();

              if constexpr (std::same_as<
                                decltype(state->tracer->on_instruction_post(*state->ctx, event, vm, gpr, fpr)),
                                QBDI::VMAction>) {
                QBDI::VMAction action = state->tracer->on_instruction_post(*state->ctx, event, vm, gpr, fpr);
                if (action != QBDI::VMAction::CONTINUE) {
                  return action;
                }
              } else {
                state->tracer->on_instruction_post(*state->ctx, event, vm, gpr, fpr);
              }
            }
          }

          if constexpr (has_on_memory<tracer_t>) {
            if (memory_enabled && state->memory_recording_enabled) {
              bool wants_read = event_mask_has(state->mask, event_kind::memory_read);
              bool wants_write = event_mask_has(state->mask, event_kind::memory_write);
              bool wants_read_write = event_mask_has(state->mask, event_kind::memory_read_write);

              auto accesses = vm->getInstMemoryAccess();
              for (const auto& access : accesses) {
                bool is_read = (access.type & QBDI::MEMORY_READ) != 0;
                bool is_write = (access.type & QBDI::MEMORY_WRITE) != 0;

                if ((is_read && wants_read) || (is_write && wants_write) ||
                    ((is_read && is_write) && wants_read_write)) {
                  memory_event event{};
                  event.instruction_address = access.instAddress != 0 ? access.instAddress : inst_addr;
                  event.address = access.accessAddress;
                  event.size = access.size;
                  event.flags = static_cast<uint32_t>(access.flags);
                  event.value = (access.flags & QBDI::MEMORY_UNKNOWN_VALUE) ? 0 : access.value;
                  event.is_read = is_read;
                  event.is_write = is_write;
                  event.value_valid = (access.flags & QBDI::MEMORY_UNKNOWN_VALUE) == 0;
                  event.thread_id = state->ctx->thread_id();

                  if constexpr (std::same_as<
                                    decltype(state->tracer->on_memory(*state->ctx, event, vm, gpr, fpr)),
                                    QBDI::VMAction>) {
                    QBDI::VMAction action = state->tracer->on_memory(*state->ctx, event, vm, gpr, fpr);
                    if (action != QBDI::VMAction::CONTINUE) {
                      return action;
                    }
                  } else {
                    state->tracer->on_memory(*state->ctx, event, vm, gpr, fpr);
                  }
                }
              }
            }
          }

          return QBDI::VMAction::CONTINUE;
        },
        &state_
    );

    if (id != QBDI::INVALID_EVENTID) {
      callback_ids_.push_back(id);
      return true;
    }
    return false;
  }

  bool register_basic_block_entry() {
    if (!event_mask_has(state_.mask, event_kind::basic_block_entry)) {
      return true;
    }
    if constexpr (has_on_basic_block_entry<tracer_t>) {
      uint32_t id = vm_->addVMEventCB(
          QBDI::BASIC_BLOCK_ENTRY,
          [](QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr,
             void* data) -> QBDI::VMAction {
            auto* callback = static_cast<callback_state*>(data);
            uint64_t start = state ? state->basicBlockStart : 0;
            uint64_t end = state ? state->basicBlockEnd : start;

            basic_block_event event{};
            event.address = start;
            event.size = end > start ? static_cast<uint32_t>(end - start) : 0;
            event.thread_id = callback->ctx->thread_id();

            if constexpr (std::same_as<
                              decltype(callback->tracer
                                           ->on_basic_block_entry(*callback->ctx, event, vm, state, gpr, fpr)),
                              QBDI::VMAction>) {
              return callback->tracer->on_basic_block_entry(*callback->ctx, event, vm, state, gpr, fpr);
            }
            callback->tracer->on_basic_block_entry(*callback->ctx, event, vm, state, gpr, fpr);
            return QBDI::VMAction::CONTINUE;
          },
          &state_
      );

      if (id != QBDI::INVALID_EVENTID) {
        callback_ids_.push_back(id);
        return true;
      }
      return false;
    } else {
      return false;
    }
  }

  bool register_basic_block_exit() {
    if (!event_mask_has(state_.mask, event_kind::basic_block_exit)) {
      return true;
    }
    if constexpr (has_on_basic_block_exit<tracer_t>) {
      uint32_t id = vm_->addVMEventCB(
          QBDI::BASIC_BLOCK_EXIT,
          [](QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr,
             void* data) -> QBDI::VMAction {
            auto* callback = static_cast<callback_state*>(data);
            uint64_t start = state ? state->basicBlockStart : 0;
            uint64_t end = state ? state->basicBlockEnd : start;

            basic_block_event event{};
            event.address = start;
            event.size = end > start ? static_cast<uint32_t>(end - start) : 0;
            event.thread_id = callback->ctx->thread_id();

            if constexpr (std::same_as<
                              decltype(callback->tracer
                                           ->on_basic_block_exit(*callback->ctx, event, vm, state, gpr, fpr)),
                              QBDI::VMAction>) {
              return callback->tracer->on_basic_block_exit(*callback->ctx, event, vm, state, gpr, fpr);
            }
            callback->tracer->on_basic_block_exit(*callback->ctx, event, vm, state, gpr, fpr);
            return QBDI::VMAction::CONTINUE;
          },
          &state_
      );

      if (id != QBDI::INVALID_EVENTID) {
        callback_ids_.push_back(id);
        return true;
      }
      return false;
    } else {
      return false;
    }
  }

  bool register_exec_transfer_call() {
    if (!event_mask_has(state_.mask, event_kind::exec_transfer_call)) {
      return true;
    }
    if constexpr (has_on_exec_transfer_call<tracer_t>) {
      uint32_t id = vm_->addVMEventCB(
          QBDI::EXEC_TRANSFER_CALL,
          [](QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr,
             void* data) -> QBDI::VMAction {
            auto* callback = static_cast<callback_state*>(data);
            uint64_t source = state ? state->sequenceStart : 0;
            uint64_t target = gpr ? QBDI_GPR_GET(gpr, QBDI::REG_PC) : 0;

            exec_transfer_event event{};
            event.source_address = source;
            event.target_address = target;
            event.thread_id = callback->ctx->thread_id();

            if constexpr (std::same_as<
                              decltype(callback->tracer
                                           ->on_exec_transfer_call(*callback->ctx, event, vm, state, gpr, fpr)),
                              QBDI::VMAction>) {
              return callback->tracer->on_exec_transfer_call(*callback->ctx, event, vm, state, gpr, fpr);
            }
            callback->tracer->on_exec_transfer_call(*callback->ctx, event, vm, state, gpr, fpr);
            return QBDI::VMAction::CONTINUE;
          },
          &state_
      );

      if (id != QBDI::INVALID_EVENTID) {
        callback_ids_.push_back(id);
        return true;
      }
      return false;
    } else {
      return false;
    }
  }

  bool register_exec_transfer_return() {
    if (!event_mask_has(state_.mask, event_kind::exec_transfer_return)) {
      return true;
    }
    if constexpr (has_on_exec_transfer_return<tracer_t>) {
      uint32_t id = vm_->addVMEventCB(
          QBDI::EXEC_TRANSFER_RETURN,
          [](QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr,
             void* data) -> QBDI::VMAction {
            auto* callback = static_cast<callback_state*>(data);
            uint64_t source = state ? state->sequenceStart : 0;
            uint64_t target = gpr ? QBDI_GPR_GET(gpr, QBDI::REG_PC) : 0;

            exec_transfer_event event{};
            event.source_address = source;
            event.target_address = target;
            event.thread_id = callback->ctx->thread_id();

            if constexpr (std::same_as<
                              decltype(callback->tracer
                                           ->on_exec_transfer_return(*callback->ctx, event, vm, state, gpr, fpr)),
                              QBDI::VMAction>) {
              return callback->tracer->on_exec_transfer_return(*callback->ctx, event, vm, state, gpr, fpr);
            }
            callback->tracer->on_exec_transfer_return(*callback->ctx, event, vm, state, gpr, fpr);
            return QBDI::VMAction::CONTINUE;
          },
          &state_
      );

      if (id != QBDI::INVALID_EVENTID) {
        callback_ids_.push_back(id);
        return true;
      }
      return false;
    } else {
      return false;
    }
  }

  bool register_vm_start() {
    if (!event_mask_has(state_.mask, event_kind::vm_start)) {
      return true;
    }
    if constexpr (has_on_vm_start<tracer_t>) {
      uint32_t id = vm_->addVMEventCB(
          QBDI::SEQUENCE_ENTRY,
          [](QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr,
             void* data) -> QBDI::VMAction {
            auto* callback = static_cast<callback_state*>(data);
            uint64_t start = state ? state->sequenceStart : 0;
            uint64_t end = state ? state->sequenceEnd : start;

            sequence_event event{};
            event.start = start;
            event.end = end;
            event.thread_id = callback->ctx->thread_id();

            if constexpr (std::same_as<
                              decltype(callback->tracer->on_vm_start(*callback->ctx, event, vm, state, gpr, fpr)),
                              QBDI::VMAction>) {
              return callback->tracer->on_vm_start(*callback->ctx, event, vm, state, gpr, fpr);
            }
            callback->tracer->on_vm_start(*callback->ctx, event, vm, state, gpr, fpr);
            return QBDI::VMAction::CONTINUE;
          },
          &state_
      );

      if (id != QBDI::INVALID_EVENTID) {
        callback_ids_.push_back(id);
        return true;
      }
      return false;
    } else {
      return false;
    }
  }

  bool register_vm_stop() {
    if (!event_mask_has(state_.mask, event_kind::vm_stop)) {
      return true;
    }
    if constexpr (has_on_vm_stop<tracer_t>) {
      uint32_t id = vm_->addVMEventCB(
          QBDI::SEQUENCE_EXIT,
          [](QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr,
             void* data) -> QBDI::VMAction {
            auto* callback = static_cast<callback_state*>(data);
            uint64_t start = state ? state->sequenceStart : 0;
            uint64_t end = state ? state->sequenceEnd : start;

            sequence_event event{};
            event.start = start;
            event.end = end;
            event.thread_id = callback->ctx->thread_id();

            if constexpr (std::same_as<
                              decltype(callback->tracer->on_vm_stop(*callback->ctx, event, vm, state, gpr, fpr)),
                              QBDI::VMAction>) {
              return callback->tracer->on_vm_stop(*callback->ctx, event, vm, state, gpr, fpr);
            }
            callback->tracer->on_vm_stop(*callback->ctx, event, vm, state, gpr, fpr);
            return QBDI::VMAction::CONTINUE;
          },
          &state_
      );

      if (id != QBDI::INVALID_EVENTID) {
        callback_ids_.push_back(id);
        return true;
      }
      return false;
    } else {
      return false;
    }
  }

  QBDI::VM* vm_ = nullptr;
  callback_state state_{};
  std::vector<uint32_t> callback_ids_{};
};

} // namespace w1::instrument

```

`src/w1instrument/trace/thread_session.hpp`:

```hpp
#pragma once

#include <atomic>
#include <cstdint>
#include <string>
#include <utility>
#include <vector>

#include <QBDI.h>
#include <redlog.hpp>

#include "w1base/thread_utils.hpp"
#include "w1instrument/core/instrumentation_policy.hpp"
#include "w1instrument/core/vm_controller.hpp"
#include "w1instrument/trace/event_dispatcher.hpp"
#include "w1instrument/tracer/event.hpp"
#include "w1instrument/tracer/trace_context.hpp"
#include "w1instrument/tracer/tracer.hpp"
#include "w1runtime/memory_reader.hpp"
#include "w1runtime/module_catalog.hpp"

namespace w1::instrument {

struct thread_session_config {
  core::instrumentation_policy instrumentation{};
  uint64_t thread_id = 0;
  std::string thread_name = "thread";
  QBDI::Options vm_options = QBDI::Options::NO_OPT;
  runtime::module_catalog* shared_modules = nullptr;
};

// Per-thread QBDI session wired to a tracer instance.
template <tracer tracer_t> class thread_session {
public:
  explicit thread_session(thread_session_config config, tracer_t tracer_instance)
      : config_(std::move(config)), tracer_(std::move(tracer_instance)), vm_controller_(),
        dispatcher_(vm_controller_.vm()) {
    init_shared_state();
    apply_options();
  }

  thread_session(thread_session_config config, tracer_t tracer_instance, QBDI::VM* borrowed_vm)
      : config_(std::move(config)), tracer_(std::move(tracer_instance)), vm_controller_(borrowed_vm),
        dispatcher_(vm_controller_.vm()) {
    init_shared_state();
    apply_options();
  }

  template <typename... Args>
  explicit thread_session(thread_session_config config, std::in_place_t, Args&&... args)
      : config_(std::move(config)), tracer_(std::forward<Args>(args)...), vm_controller_(),
        dispatcher_(vm_controller_.vm()) {
    init_shared_state();
    apply_options();
  }

  template <typename... Args>
  thread_session(thread_session_config config, QBDI::VM* borrowed_vm, std::in_place_t, Args&&... args)
      : config_(std::move(config)), tracer_(std::forward<Args>(args)...), vm_controller_(borrowed_vm),
        dispatcher_(vm_controller_.vm()) {
    init_shared_state();
    apply_options();
  }

  thread_session(const thread_session&) = delete;
  thread_session& operator=(const thread_session&) = delete;
  thread_session(thread_session&&) = delete;
  thread_session& operator=(thread_session&&) = delete;

  ~thread_session() { shutdown(); }

  tracer_t& tracer() { return tracer_; }
  const tracer_t& tracer() const { return tracer_; }

  trace_context& context() { return *context_; }
  const trace_context& context() const { return *context_; }

  void request_refresh() { refresh_requested_.store(true, std::memory_order_release); }

  bool initialize() {
    if (initialized_) {
      return true;
    }

    validate_tracer<tracer_t>();

    QBDI::VM* vm = vm_controller_.vm();
    if (!vm) {
      return false;
    }

    if (owned_modules_) {
      modules_->refresh();
    }

    event_mask mask = tracer_t::requested_events();
    if (!dispatcher_.bind(mask, tracer_, *context_)) {
      return false;
    }

    if (event_mask_has(mask, event_kind::thread_start)) {
      if constexpr (has_on_thread_start<tracer_t>) {
        thread_event event{};
        event.thread_id = context_->thread_id();
        event.name = config_.thread_name.c_str();
        tracer_.on_thread_start(*context_, event);
      }
    }

    if (refresh_callback_id_ == QBDI::INVALID_EVENTID) {
      refresh_callback_id_ = vm->addCodeCB(
          QBDI::PREINST,
          [](QBDI::VMInstanceRef, QBDI::GPRState*, QBDI::FPRState*, void* data) -> QBDI::VMAction {
            auto* session = static_cast<thread_session*>(data);
            if (session->refresh_requested_.exchange(false, std::memory_order_acq_rel)) {
              session->refresh_instrumentation();
            }
            return QBDI::VMAction::CONTINUE;
          },
          this
      );
      if (refresh_callback_id_ == QBDI::INVALID_EVENTID) {
        return false;
      }
    }

    initialized_ = true;
    return true;
  }

  bool instrument() {
    if (!initialize()) {
      return false;
    }

    if (instrumented_) {
      return true;
    }

    QBDI::VM* vm = vm_controller_.vm();
    if (!vm) {
      return false;
    }

    size_t added = refresh_instrumentation();
    if (!dispatcher_.ensure_memory_recording()) {
      return false;
    }

    instrumented_ = added > 0;
    return instrumented_;
  }

  bool run(uint64_t start, uint64_t stop) {
    if (!instrument()) {
      return false;
    }

    QBDI::VM* vm = vm_controller_.vm();
    if (!vm) {
      return false;
    }

    bool ok = vm->run(static_cast<QBDI::rword>(start), static_cast<QBDI::rword>(stop));
    if (!ok) {
      auto log = redlog::get_logger("w1instrument.thread_session");
      log.wrn(
          "qbdi run returned false", redlog::field("thread_id", config_.thread_id), redlog::field("start", start),
          redlog::field("stop", stop), redlog::field("include_filters", config_.instrumentation.include_modules.size()),
          redlog::field("exclude_filters", config_.instrumentation.exclude_modules.size()),
          redlog::field("use_default_excludes", config_.instrumentation.use_default_excludes),
          redlog::field("include_unnamed", config_.instrumentation.include_unnamed_modules),
          redlog::field("system_policy", static_cast<int>(config_.instrumentation.system_policy))
      );
    }
    return ok;
  }

  bool call(uint64_t function_ptr, const std::vector<uint64_t>& args, uint64_t* result) {
    if (!instrument()) {
      return false;
    }

    QBDI::VM* vm = vm_controller_.vm();
    if (!vm) {
      return false;
    }

    std::vector<QBDI::rword> qbdi_args;
    qbdi_args.reserve(args.size());
    for (uint64_t arg : args) {
      qbdi_args.push_back(static_cast<QBDI::rword>(arg));
    }

    QBDI::rword retval = 0;
    bool success = vm->switchStackAndCall(&retval, static_cast<QBDI::rword>(function_ptr), qbdi_args);
    if (success && result) {
      *result = static_cast<uint64_t>(retval);
    }

    return success;
  }

  void shutdown(bool clear_callbacks = true) {
    if (!initialized_) {
      return;
    }

    event_mask mask = tracer_t::requested_events();
    if (event_mask_has(mask, event_kind::thread_stop)) {
      if constexpr (has_on_thread_stop<tracer_t>) {
        thread_event event{};
        event.thread_id = context_->thread_id();
        event.name = config_.thread_name.c_str();
        tracer_.on_thread_stop(*context_, event);
      }
    }

    if (clear_callbacks) {
      dispatcher_.clear();
      if (refresh_callback_id_ != QBDI::INVALID_EVENTID) {
        vm_controller_.vm()->deleteInstrumentation(refresh_callback_id_);
      }
    } else {
      dispatcher_.detach();
    }

    refresh_callback_id_ = QBDI::INVALID_EVENTID;
    initialized_ = false;
    instrumented_ = false;
  }

private:
  void init_shared_state() {
    if (config_.thread_id == 0) {
      config_.thread_id = w1::util::current_thread_id();
    }

    if (config_.shared_modules) {
      modules_ = config_.shared_modules;
    } else {
      owned_modules_ = std::make_unique<runtime::module_catalog>();
      modules_ = owned_modules_.get();
    }

    memory_reader_ = std::make_unique<util::memory_reader>(vm_controller_.vm(), *modules_);
    context_ = std::make_unique<trace_context>(config_.thread_id, vm_controller_.vm(), modules_, memory_reader_.get());
  }

  size_t refresh_instrumentation() {
    QBDI::VM* vm = vm_controller_.vm();
    if (!vm || !modules_) {
      return 0;
    }

    if (owned_modules_) {
      modules_->refresh();
    }

    vm->removeAllInstrumentedRanges();

    auto modules = modules_->list_modules();
    size_t added = 0;
    size_t eligible_modules = 0;
    size_t eligible_ranges = 0;

    for (const auto& module : modules) {
      if (!config_.instrumentation.should_instrument(module)) {
        continue;
      }
      ++eligible_modules;

      for (const auto& range : module.exec_ranges) {
        if (range.end <= range.start) {
          continue;
        }
        vm->addInstrumentedRange(range.start, range.end);
        ++added;
        ++eligible_ranges;
      }
    }

    vm->clearAllCache();

    instrumented_ = added > 0;
    if (!instrumented_) {
      auto log = redlog::get_logger("w1instrument.thread_session");
      log.wrn(
          "no instrumented ranges; tracer may exit immediately", redlog::field("thread_id", config_.thread_id),
          redlog::field("module_count", modules.size()), redlog::field("eligible_modules", eligible_modules),
          redlog::field("eligible_ranges", eligible_ranges),
          redlog::field("include_filters", config_.instrumentation.include_modules.size()),
          redlog::field("exclude_filters", config_.instrumentation.exclude_modules.size()),
          redlog::field("use_default_excludes", config_.instrumentation.use_default_excludes),
          redlog::field("include_unnamed", config_.instrumentation.include_unnamed_modules),
          redlog::field("system_policy", static_cast<int>(config_.instrumentation.system_policy))
      );
    }
    return added;
  }

  void apply_options() {
    QBDI::VM* vm = vm_controller_.vm();
    if (vm && config_.vm_options != QBDI::Options::NO_OPT) {
      vm->setOptions(config_.vm_options);
    }
  }

  thread_session_config config_{};
  tracer_t tracer_{};
  core::vm_controller vm_controller_{};
  std::unique_ptr<runtime::module_catalog> owned_modules_{};
  runtime::module_catalog* modules_ = nullptr;
  std::unique_ptr<util::memory_reader> memory_reader_{};
  std::unique_ptr<trace_context> context_{};
  event_dispatcher<tracer_t> dispatcher_;
  bool initialized_ = false;
  bool instrumented_ = false;
  std::atomic<bool> refresh_requested_{false};
  uint32_t refresh_callback_id_ = QBDI::INVALID_EVENTID;
};

} // namespace w1::instrument

```

`src/w1instrument/tracer/event.hpp`:

```hpp
#pragma once

#include <cstdint>

namespace w1 {

enum class event_kind : uint32_t {
  instruction_pre = 0,
  instruction_post,
  basic_block_entry,
  basic_block_exit,
  memory_read,
  memory_write,
  memory_read_write,
  exec_transfer_call,
  exec_transfer_return,
  vm_start,
  vm_stop,
  thread_start,
  thread_stop
};

using event_mask = uint64_t;

constexpr event_mask event_mask_of(event_kind kind) { return event_mask{1} << static_cast<event_mask>(kind); }

constexpr bool event_mask_has(event_mask mask, event_kind kind) { return (mask & event_mask_of(kind)) != 0; }

constexpr event_mask event_mask_or(event_mask left, event_mask right) { return left | right; }

} // namespace w1

```

`src/w1instrument/tracer/recipe.hpp`:

```hpp
#pragma once

#include <concepts>
#include <cstdint>
#include <utility>

#include <QBDI.h>

namespace w1::instrument {

template <typename Recipe>
concept tracer_recipe = requires {
  typename Recipe::config_t;
  typename Recipe::runtime_t;

  requires std::move_constructible<typename Recipe::config_t>;
  requires std::move_constructible<typename Recipe::runtime_t>;

  { Recipe::load_config() } -> std::same_as<typename Recipe::config_t>;
  { Recipe::configure_logging(std::declval<const typename Recipe::config_t&>()) } -> std::same_as<void>;
  {
    Recipe::apply_self_excludes(std::declval<typename Recipe::config_t&>(), (const void*) nullptr)
  } -> std::same_as<void>;
  { Recipe::log_config(std::declval<const typename Recipe::config_t&>()) } -> std::same_as<void>;

  {
    Recipe::make_runtime(std::declval<const typename Recipe::config_t&>())
  } -> std::same_as<typename Recipe::runtime_t>;
  {
    Recipe::run_main(std::declval<typename Recipe::runtime_t&>(), (QBDI::VM*) nullptr, uint64_t{}, uint64_t{})
  } -> std::same_as<bool>;
  {
    Recipe::on_exit(std::declval<typename Recipe::runtime_t&>(), std::declval<const typename Recipe::config_t&>(), 0)
  } -> std::same_as<void>;
};

} // namespace w1::instrument

```

`src/w1instrument/tracer/runtime.hpp`:

```hpp
#pragma once

#include <concepts>
#include <cstdint>
#include <memory>
#include <string>
#include <utility>
#include <vector>

#include <QBDI.h>

#include "w1base/thread_utils.hpp"
#include "w1instrument/process/process_session.hpp"
#include "w1instrument/trace/thread_session.hpp"
#include "w1runtime/module_catalog.hpp"
#include "w1runtime/process_observer.hpp"

namespace w1::instrument {

template <typename Traits, typename Engine, typename ThreadTracer, typename Config>
concept process_runtime_traits =
    requires(Engine& engine, const Config& config, const runtime::thread_info& info, bool owns_observer) {
      {
        Traits::make_process_config(config, owns_observer)
      } -> std::same_as<typename process_session<ThreadTracer>::config>;
      { Traits::make_tracer(std::declval<std::shared_ptr<Engine>>(), config, info) } -> std::same_as<ThreadTracer>;
      { Traits::configure_engine(engine, std::declval<runtime::module_catalog&>()) } -> std::same_as<void>;
      { Traits::export_output(engine) } -> std::same_as<bool>;
    };

template <typename Traits, typename Engine, typename ThreadTracer, typename Config>
concept thread_runtime_traits = requires(Engine& engine, const Config& config) {
  { Traits::make_thread_config(config) } -> std::same_as<thread_session_config>;
  { Traits::make_tracer(std::declval<std::shared_ptr<Engine>>(), config) } -> std::same_as<ThreadTracer>;
  { Traits::configure_engine(engine, std::declval<runtime::module_catalog&>()) } -> std::same_as<void>;
  { Traits::export_output(engine) } -> std::same_as<bool>;
};

template <typename Traits, typename Engine, typename ThreadTracer, typename Config>
concept process_runtime_session_config =
    requires(process_session<ThreadTracer>& session, Engine& engine, const Config& config) {
      { Traits::configure_session(session, engine, config) } -> std::same_as<void>;
    };

template <typename Engine, typename ThreadTracer, typename Config, typename Traits>
  requires process_runtime_traits<Traits, Engine, ThreadTracer, Config>
class tracer_runtime {
public:
  using session_type = process_session<ThreadTracer>;

  explicit tracer_runtime(Config config)
      : owned_observer_{}, observer_(&owned_observer_), config_(std::move(config)),
        engine_(std::make_shared<Engine>(config_)),
        session_(
            *observer_, Traits::make_process_config(config_, true),
            [engine = engine_, config_ptr = &config_](const runtime::thread_info& info) {
              return Traits::make_tracer(engine, *config_ptr, info);
            }
        ) {
    configure_session();
    configure_engine();
  }

  tracer_runtime(Config config, runtime::process_observer& observer)
      : observer_(&observer), config_(std::move(config)), engine_(std::make_shared<Engine>(config_)),
        session_(
            observer, Traits::make_process_config(config_, false),
            [engine = engine_, config_ptr = &config_](const runtime::thread_info& info) {
              return Traits::make_tracer(engine, *config_ptr, info);
            }
        ) {
    configure_session();
    configure_engine();
  }

  tracer_runtime(const tracer_runtime&) = delete;
  tracer_runtime& operator=(const tracer_runtime&) = delete;
  tracer_runtime(tracer_runtime&&) = delete;
  tracer_runtime& operator=(tracer_runtime&&) = delete;

  ~tracer_runtime() { stop(); }

  bool run_main(QBDI::VM* vm, uint64_t start, uint64_t stop, std::string name = "main") {
    configure_engine();
    return session_.run_main(vm, start, stop, std::move(name));
  }

  bool call_current_thread(
      uint64_t function_ptr, const std::vector<uint64_t>& args, uint64_t* result = nullptr, std::string name = "main"
  ) {
    configure_engine();
    return session_.call_current_thread(function_ptr, args, result, std::move(name));
  }

  void stop() { session_.stop(); }

  bool export_output() { return engine_ ? Traits::export_output(*engine_) : false; }

  Engine& engine() const { return *engine_; }
  std::shared_ptr<Engine> engine_shared() const { return engine_; }
  session_type& session() { return session_; }
  const session_type& session() const { return session_; }
  runtime::process_observer& observer() { return *observer_; }
  const runtime::process_observer& observer() const { return *observer_; }

  void refresh_modules() {
    if (observer_) {
      observer_->modules().refresh();
    }
    session_.refresh_all();
  }

private:
  void configure_session() {
    if constexpr (process_runtime_session_config<Traits, Engine, ThreadTracer, Config>) {
      Traits::configure_session(session_, *engine_, config_);
    }
  }

  void configure_engine() {
    if (!observer_ || !engine_) {
      return;
    }
    observer_->modules().refresh();
    Traits::configure_engine(*engine_, observer_->modules());
  }

  runtime::process_observer owned_observer_{};
  runtime::process_observer* observer_ = nullptr;
  Config config_{};
  std::shared_ptr<Engine> engine_{};
  session_type session_;
};

template <typename Engine, typename ThreadTracer, typename Config, typename Traits>
  requires thread_runtime_traits<Traits, Engine, ThreadTracer, Config>
class thread_runtime {
public:
  using session_type = thread_session<ThreadTracer>;

  explicit thread_runtime(Config config) : config_(std::move(config)), engine_(std::make_shared<Engine>(config_)) {
    configure_engine();
  }

  thread_runtime(const thread_runtime&) = delete;
  thread_runtime& operator=(const thread_runtime&) = delete;
  thread_runtime(thread_runtime&&) = delete;
  thread_runtime& operator=(thread_runtime&&) = delete;

  ~thread_runtime() { stop(); }

  bool run(QBDI::VM* vm, uint64_t start, uint64_t stop_address, std::string name = "thread") {
    configure_engine();

    thread_session_config session_config = Traits::make_thread_config(config_);
    if (session_config.thread_id == 0) {
      session_config.thread_id = w1::util::current_thread_id();
    }
    session_config.thread_name = name.empty() ? "thread" : std::move(name);
    session_config.shared_modules = &modules_;

    ThreadTracer tracer_instance = Traits::make_tracer(engine_, config_);
    if (vm) {
      session_ = std::make_unique<session_type>(session_config, std::move(tracer_instance), vm);
    } else {
      session_ = std::make_unique<session_type>(session_config, std::move(tracer_instance));
    }

    const bool ok = session_->run(start, stop_address);
    stop();
    return ok;
  }

  bool call(
      uint64_t function_ptr, const std::vector<uint64_t>& args, uint64_t* result = nullptr, std::string name = "thread"
  ) {
    configure_engine();

    thread_session_config session_config = Traits::make_thread_config(config_);
    if (session_config.thread_id == 0) {
      session_config.thread_id = w1::util::current_thread_id();
    }
    session_config.thread_name = name.empty() ? "thread" : std::move(name);
    session_config.shared_modules = &modules_;

    ThreadTracer tracer_instance = Traits::make_tracer(engine_, config_);
    session_ = std::make_unique<session_type>(session_config, std::move(tracer_instance));

    const bool ok = session_->call(function_ptr, args, result);
    stop();
    return ok;
  }

  void stop() {
    if (session_) {
      session_->shutdown();
      session_.reset();
    }
  }

  bool export_output() {
    stop();
    return engine_ ? Traits::export_output(*engine_) : false;
  }

  Engine& engine() const { return *engine_; }
  std::shared_ptr<Engine> engine_shared() const { return engine_; }

private:
  void configure_engine() {
    modules_.refresh();
    if (engine_) {
      Traits::configure_engine(*engine_, modules_);
    }
  }

  Config config_{};
  std::shared_ptr<Engine> engine_{};
  runtime::module_catalog modules_{};
  std::unique_ptr<session_type> session_{};
};

} // namespace w1::instrument

```

`src/w1instrument/tracer/trace_context.hpp`:

```hpp
#pragma once

#include <cstdint>

#include <QBDI.h>

namespace w1 {
namespace runtime {
class module_catalog;
} // namespace runtime
namespace util {
class memory_reader;
} // namespace util

class trace_context {
public:
  trace_context(uint64_t thread_id, QBDI::VM* vm, runtime::module_catalog* modules, const util::memory_reader* memory)
      : thread_id_(thread_id), vm_(vm), modules_(modules), memory_(memory) {}

  uint64_t thread_id() const { return thread_id_; }
  runtime::module_catalog& modules() { return *modules_; }
  const runtime::module_catalog& modules() const { return *modules_; }
  const util::memory_reader& memory() const { return *memory_; }
  QBDI::VM* vm() const { return vm_; }

private:
  uint64_t thread_id_ = 0;
  QBDI::VM* vm_ = nullptr;
  runtime::module_catalog* modules_ = nullptr;
  const util::memory_reader* memory_ = nullptr;
};

} // namespace w1

```

`src/w1instrument/tracer/tracer.hpp`:

```hpp
#pragma once

#include <concepts>
#include <type_traits>

#include <QBDI.h>

#include "w1instrument/tracer/event.hpp"
#include "w1instrument/tracer/types.hpp"

namespace w1 {

class trace_context;

template <typename result_t>
concept handler_result = std::same_as<result_t, void> || std::same_as<result_t, QBDI::VMAction>;

template <typename t>
concept tracer = requires(t& value) {
  { value.name() } -> std::same_as<const char*>;
  { t::requested_events() } -> std::same_as<event_mask>;
};

template <typename t>
concept has_on_instruction_pre = requires(
    t& value, trace_context& ctx, const instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  { value.on_instruction_pre(ctx, event, vm, gpr, fpr) } -> handler_result;
};

template <typename t>
concept has_on_instruction_post = requires(
    t& value, trace_context& ctx, const instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  { value.on_instruction_post(ctx, event, vm, gpr, fpr) } -> handler_result;
};

template <typename t>
concept has_on_basic_block_entry = requires(
    t& value, trace_context& ctx, const basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  { value.on_basic_block_entry(ctx, event, vm, state, gpr, fpr) } -> handler_result;
};

template <typename t>
concept has_on_basic_block_exit = requires(
    t& value, trace_context& ctx, const basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  { value.on_basic_block_exit(ctx, event, vm, state, gpr, fpr) } -> handler_result;
};

template <typename t>
concept has_on_exec_transfer_call = requires(
    t& value, trace_context& ctx, const exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  { value.on_exec_transfer_call(ctx, event, vm, state, gpr, fpr) } -> handler_result;
};

template <typename t>
concept has_on_exec_transfer_return = requires(
    t& value, trace_context& ctx, const exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  { value.on_exec_transfer_return(ctx, event, vm, state, gpr, fpr) } -> handler_result;
};

template <typename t>
concept has_on_vm_start = requires(
    t& value, trace_context& ctx, const sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  { value.on_vm_start(ctx, event, vm, state, gpr, fpr) } -> handler_result;
};

template <typename t>
concept has_on_vm_stop = requires(
    t& value, trace_context& ctx, const sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
    QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  { value.on_vm_stop(ctx, event, vm, state, gpr, fpr) } -> handler_result;
};

template <typename t>
concept has_on_memory = requires(
    t& value, trace_context& ctx, const memory_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  { value.on_memory(ctx, event, vm, gpr, fpr) } -> handler_result;
};

template <typename t>
concept has_on_thread_start = requires(t& value, trace_context& ctx, const thread_event& event) {
  { value.on_thread_start(ctx, event) } -> handler_result;
};

template <typename t>
concept has_on_thread_stop = requires(t& value, trace_context& ctx, const thread_event& event) {
  { value.on_thread_stop(ctx, event) } -> handler_result;
};

template <typename t> constexpr void validate_tracer() {
  static_assert(tracer<t>, "tracer must define name() and static requested_events()");
  constexpr event_mask mask = t::requested_events();

  if constexpr (event_mask_has(mask, event_kind::instruction_pre)) {
    static_assert(has_on_instruction_pre<t>, "tracer requests instruction_pre but lacks on_instruction_pre");
  }
  if constexpr (event_mask_has(mask, event_kind::instruction_post)) {
    static_assert(has_on_instruction_post<t>, "tracer requests instruction_post but lacks on_instruction_post");
  }
  if constexpr (event_mask_has(mask, event_kind::basic_block_entry)) {
    static_assert(has_on_basic_block_entry<t>, "tracer requests basic_block_entry but lacks on_basic_block_entry");
  }
  if constexpr (event_mask_has(mask, event_kind::basic_block_exit)) {
    static_assert(has_on_basic_block_exit<t>, "tracer requests basic_block_exit but lacks on_basic_block_exit");
  }
  if constexpr (event_mask_has(mask, event_kind::exec_transfer_call)) {
    static_assert(has_on_exec_transfer_call<t>, "tracer requests exec_transfer_call but lacks on_exec_transfer_call");
  }
  if constexpr (event_mask_has(mask, event_kind::exec_transfer_return)) {
    static_assert(
        has_on_exec_transfer_return<t>, "tracer requests exec_transfer_return but lacks on_exec_transfer_return"
    );
  }
  if constexpr (event_mask_has(mask, event_kind::vm_start)) {
    static_assert(has_on_vm_start<t>, "tracer requests vm_start but lacks on_vm_start");
  }
  if constexpr (event_mask_has(mask, event_kind::vm_stop)) {
    static_assert(has_on_vm_stop<t>, "tracer requests vm_stop but lacks on_vm_stop");
  }
  if constexpr (event_mask_has(mask, event_kind::memory_read) || event_mask_has(mask, event_kind::memory_write) ||
                event_mask_has(mask, event_kind::memory_read_write)) {
    static_assert(has_on_memory<t>, "tracer requests memory events but lacks on_memory");
  }
  if constexpr (event_mask_has(mask, event_kind::thread_start)) {
    static_assert(has_on_thread_start<t>, "tracer requests thread_start but lacks on_thread_start");
  }
  if constexpr (event_mask_has(mask, event_kind::thread_stop)) {
    static_assert(has_on_thread_stop<t>, "tracer requests thread_stop but lacks on_thread_stop");
  }
}

} // namespace w1

```

`src/w1instrument/tracer/types.hpp`:

```hpp
#pragma once

#include <cstdint>

#include "w1base/types.hpp"

namespace w1 {

struct instruction_event {
  uint64_t address;
  uint32_t size;
  uint64_t thread_id;
};

struct basic_block_event {
  uint64_t address;
  uint32_t size;
  uint64_t thread_id;
};

struct sequence_event {
  uint64_t start;
  uint64_t end;
  uint64_t thread_id;
};

struct exec_transfer_event {
  uint64_t source_address;
  uint64_t target_address;
  uint64_t thread_id;
};

struct memory_event {
  uint64_t instruction_address;
  uint64_t address;
  uint32_t size;
  uint32_t flags;
  uint64_t value;
  bool is_read;
  bool is_write;
  bool value_valid;
  uint64_t thread_id;
};

struct thread_event {
  uint64_t thread_id;
  const char* name;
};

struct trace_summary {
  uint64_t instructions;
  uint64_t basic_blocks;
  uint64_t memory_events;
};

} // namespace w1

```

`src/w1monitor/CMakeLists.txt`:

```txt
set(W1MONITOR_SOURCES
    monitor_factory.cpp
    backend/null/null_module_monitor.cpp
    backend/null/null_thread_monitor.cpp
)

if(APPLE)
    list(APPEND W1MONITOR_SOURCES
        backend/darwin/darwin_module_monitor.cpp
        backend/darwin/darwin_thread_monitor.cpp
    )
elseif(WIN32)
    list(APPEND W1MONITOR_SOURCES
        backend/windows/windows_module_monitor.cpp
        backend/windows/windows_thread_monitor.cpp
    )
elseif(UNIX)
    list(APPEND W1MONITOR_SOURCES
        backend/linux/linux_module_monitor.cpp
        backend/linux/linux_thread_monitor.cpp
    )
endif()

w1_add_static_library(w1monitor ${W1MONITOR_SOURCES})
add_library(w1::monitor ALIAS w1monitor)

target_link_libraries(w1monitor PUBLIC w1base w1h00k)

if(UNIX)
    find_package(Threads REQUIRED)
    target_link_libraries(w1monitor PUBLIC Threads::Threads)
endif()

```

`src/w1monitor/backend/darwin/darwin_module_monitor.cpp`:

```cpp
#include "w1monitor/backend/darwin/darwin_module_monitor.hpp"

#include <algorithm>
#include <cstdint>
#include <cstring>

#include <dlfcn.h>
#include <mach-o/dyld.h>
#include <mach-o/loader.h>

#include "w1monitor/event_queue.hpp"

namespace w1::monitor::backend::darwin {
namespace {

#if defined(__LP64__)
using mach_header_t = mach_header_64;
using segment_command_t = segment_command_64;
static constexpr uint32_t kSegmentCommand = LC_SEGMENT_64;
#else
using mach_header_t = mach_header;
using segment_command_t = segment_command;
static constexpr uint32_t kSegmentCommand = LC_SEGMENT;
#endif

bool macho_range(const mach_header* header, intptr_t slide, uintptr_t& base, size_t& size) {
  if (!header) {
    return false;
  }

  const auto* mh = reinterpret_cast<const mach_header_t*>(header);
  const uint8_t* cursor = reinterpret_cast<const uint8_t*>(mh) + sizeof(mach_header_t);

  uintptr_t low = UINTPTR_MAX;
  uintptr_t high = 0;
  for (uint32_t i = 0; i < mh->ncmds; ++i) {
    const auto* lc = reinterpret_cast<const load_command*>(cursor);
    if (lc->cmd == kSegmentCommand) {
      const auto* seg = reinterpret_cast<const segment_command_t*>(cursor);
      const uintptr_t seg_start = static_cast<uintptr_t>(seg->vmaddr) + static_cast<uintptr_t>(slide);
      const uintptr_t seg_end = seg_start + static_cast<uintptr_t>(seg->vmsize);
      low = std::min(low, seg_start);
      high = std::max(high, seg_end);
    }
    cursor += lc->cmdsize;
  }

  if (low == UINTPTR_MAX || high <= low) {
    return false;
  }

  base = low;
  size = high - low;
  return true;
}

class darwin_module_monitor final : public module_monitor {
public:
  darwin_module_monitor() = default;

  void start() override {
    if (active_) {
      return;
    }
    active_ = true;
    active_monitor = this;

    const uint32_t count = _dyld_image_count();
    for (uint32_t i = 0; i < count; ++i) {
      const mach_header* header = _dyld_get_image_header(i);
      const intptr_t slide = _dyld_get_image_vmaddr_slide(i);
      emit_event(header, slide, module_event::kind::loaded);
    }

    _dyld_register_func_for_add_image(&darwin_module_monitor::on_image_added);
    _dyld_register_func_for_remove_image(&darwin_module_monitor::on_image_removed);
  }

  void stop() override {
    active_ = false;
    if (active_monitor == this) {
      active_monitor = nullptr;
    }
    queue_.clear();
  }

  bool poll(module_event& out) override { return queue_.poll(out); }

private:
  static void on_image_added(const mach_header* mh, intptr_t slide) {
    if (!active_monitor || !active_monitor->active_) {
      return;
    }
    active_monitor->emit_event(mh, slide, module_event::kind::loaded);
  }

  static void on_image_removed(const mach_header* mh, intptr_t slide) {
    if (!active_monitor || !active_monitor->active_) {
      return;
    }
    active_monitor->emit_event(mh, slide, module_event::kind::unloaded);
  }

  void emit_event(const mach_header* header, intptr_t slide, module_event::kind kind) {
    module_event event{};
    event.type = kind;

    Dl_info info{};
    if (header && dladdr(header, &info) != 0 && info.dli_fname) {
      event.path = info.dli_fname;
    }

    uintptr_t base = 0;
    size_t size = 0;
    if (macho_range(header, slide, base, size)) {
      event.base = reinterpret_cast<void*>(base);
      event.size = size;
    } else {
      event.base = const_cast<void*>(reinterpret_cast<const void*>(header));
      event.size = 0;
    }

    queue_.push(event);
  }

  static inline darwin_module_monitor* active_monitor = nullptr;
  bool active_ = false;
  event_queue queue_{};
};

} // namespace

std::unique_ptr<module_monitor> make_module_monitor() {
  return std::make_unique<darwin_module_monitor>();
}

} // namespace w1::monitor::backend::darwin

```

`src/w1monitor/backend/darwin/darwin_module_monitor.hpp`:

```hpp
#pragma once

#include <memory>

#include "w1monitor/module_monitor.hpp"

namespace w1::monitor::backend::darwin {

std::unique_ptr<module_monitor> make_module_monitor();

} // namespace w1::monitor::backend::darwin

```

`src/w1monitor/backend/darwin/darwin_thread_monitor.cpp`:

```cpp
#include "w1monitor/backend/darwin/darwin_thread_monitor.hpp"

#include <cerrno>
#include <memory>
#include <pthread.h>
#include <pthread/introspection.h>

#include "w1h00k/hook.hpp"
#include "w1monitor/backend/hook_helpers.hpp"
#include "w1monitor/backend/thread_entry.hpp"
#include "w1monitor/backend/thread_event_helpers.hpp"
#include "w1monitor/event_queue.hpp"

namespace w1::monitor::backend::darwin {
namespace {

using pthread_setname_fn = int (*)(const char*);
using pthread_create_fn = int (*)(pthread_t*, const pthread_attr_t*, void* (*)(void*), void*);

struct start_payload {
  void* (*start_routine)(void*) = nullptr;
  void* arg = nullptr;
  class darwin_thread_monitor* monitor = nullptr;
};

class darwin_thread_monitor final : public thread_monitor {
public:
  darwin_thread_monitor() = default;

  void start() override {
    if (active_) {
      return;
    }
    active_ = true;
    active_monitor = this;

    previous_hook_ = pthread_introspection_hook_install(&darwin_thread_monitor::on_thread_event);

    install_setname_hook();
    install_create_hook();
  }

  void stop() override {
    active_ = false;
    if (active_monitor == this) {
      active_monitor = nullptr;
    }

    if (previous_hook_) {
      (void)pthread_introspection_hook_install(previous_hook_);
      previous_hook_ = nullptr;
    }

    hook_helpers::detach_if_attached(setname_handle_);
    original_setname_ = nullptr;
    hook_helpers::detach_if_attached(create_handle_);
    original_create_ = nullptr;

    queue_.clear();
  }

  bool poll(thread_event& out) override { return queue_.poll(out); }
  void set_entry_callback(thread_entry_callback callback) override { entry_callback_ = std::move(callback); }

private:
  static void on_thread_event(unsigned int event, pthread_t thread, void* addr, size_t size) {
    if (active_monitor && active_monitor->active_) {
      active_monitor->handle_thread_event(event, thread);
    }

    if (active_monitor && active_monitor->previous_hook_) {
      active_monitor->previous_hook_(event, thread, addr, size);
    }
  }

  static int replacement_setname(const char* name) {
    darwin_thread_monitor* monitor = active_monitor;
    if (monitor && monitor->active_) {
      monitor->emitter_.renamed(static_cast<uint64_t>(pthread_mach_thread_np(pthread_self())),
                                name ? std::string_view(name) : std::string_view{});
    }

    if (monitor && monitor->original_setname_) {
      return monitor->original_setname_(name);
    }
    return 0;
  }

  static void* start_trampoline(void* arg) {
    std::unique_ptr<start_payload> payload(static_cast<start_payload*>(arg));
    darwin_thread_monitor* monitor = payload->monitor;
    void* (*start_routine)(void*) = payload->start_routine;
    void* start_arg = payload->arg;

    void* result = nullptr;
    if (monitor) {
      const uint64_t result_value = backend::dispatch_thread_entry(
          monitor->entry_callback_,
          thread_entry_kind::posix,
          static_cast<uint64_t>(pthread_mach_thread_np(pthread_self())),
          reinterpret_cast<void*>(start_routine),
          start_arg,
          [&]() -> uint64_t {
            if (start_routine) {
              return static_cast<uint64_t>(reinterpret_cast<uintptr_t>(start_routine(start_arg)));
            }
            return 0;
          });
      result = reinterpret_cast<void*>(static_cast<uintptr_t>(result_value));
    } else if (start_routine) {
      result = start_routine(start_arg);
    }

    return result;
  }

  static int replacement_pthread_create(pthread_t* thread, const pthread_attr_t* attr,
                                        void* (*start_routine)(void*), void* arg) {
    auto* monitor = active_monitor;
    if (!monitor || !monitor->original_create_) {
      return EINVAL;
    }

    auto* payload = new start_payload{};
    payload->start_routine = start_routine;
    payload->arg = arg;
    payload->monitor = monitor;

    const int result = monitor->original_create_(thread, attr, &darwin_thread_monitor::start_trampoline, payload);
    if (result != 0) {
      delete payload;
    }
    return result;
  }

  void handle_thread_event(unsigned int event, pthread_t thread) {
    switch (event) {
      case PTHREAD_INTROSPECTION_THREAD_START:
        emitter_.started(static_cast<uint64_t>(pthread_mach_thread_np(thread)));
        break;
      case PTHREAD_INTROSPECTION_THREAD_TERMINATE:
        emitter_.stopped(static_cast<uint64_t>(pthread_mach_thread_np(thread)));
        break;
      default:
        return;
    }
  }

  void install_setname_hook() {
    if (setname_handle_.id != 0) {
      return;
    }
    if (!hook_helpers::attach_interpose_symbol(
            "pthread_setname_np",
            &darwin_thread_monitor::replacement_setname,
            setname_handle_, original_setname_)) {
      return;
    }
  }

  void install_create_hook() {
    if (create_handle_.id != 0) {
      return;
    }
    if (!hook_helpers::attach_interpose_symbol(
            "pthread_create",
            &darwin_thread_monitor::replacement_pthread_create,
            create_handle_, original_create_)) {
      return;
    }
  }

  static inline darwin_thread_monitor* active_monitor = nullptr;
  bool active_ = false;
  pthread_introspection_hook_t previous_hook_ = nullptr;
  w1::h00k::hook_handle setname_handle_{};
  w1::h00k::hook_handle create_handle_{};
  pthread_setname_fn original_setname_ = nullptr;
  pthread_create_fn original_create_ = nullptr;
  event_queue queue_{};
  thread_event_emitter emitter_{queue_};
  thread_entry_callback entry_callback_{};
};

} // namespace

std::unique_ptr<thread_monitor> make_thread_monitor() {
  return std::make_unique<darwin_thread_monitor>();
}

} // namespace w1::monitor::backend::darwin

```

`src/w1monitor/backend/darwin/darwin_thread_monitor.hpp`:

```hpp
#pragma once

#include <memory>

#include "w1monitor/thread_monitor.hpp"

namespace w1::monitor::backend::darwin {

std::unique_ptr<thread_monitor> make_thread_monitor();

} // namespace w1::monitor::backend::darwin

```

`src/w1monitor/backend/hook_helpers.hpp`:

```hpp
#pragma once

#include "w1h00k/hook.hpp"

namespace w1::monitor::backend::hook_helpers {

inline bool attach_interpose_symbol(const char* symbol,
                                    void* replacement,
                                    w1::h00k::hook_handle& handle_out,
                                    void*& original_out) {
  w1::h00k::hook_request request{};
  request.target.kind = w1::h00k::hook_target_kind::symbol;
  request.target.symbol = symbol;
  request.replacement = replacement;
  request.preferred = w1::h00k::hook_technique::interpose;
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::interpose);
  request.selection = w1::h00k::hook_selection::strict;

  void* original = nullptr;
  auto result = w1::h00k::attach(request, &original);
  if (!result.error.ok()) {
    return false;
  }

  handle_out = result.handle;
  original_out = original;
  return true;
}

template <typename Fn>
inline bool attach_interpose_symbol(const char* symbol,
                                    void* replacement,
                                    w1::h00k::hook_handle& handle_out,
                                    Fn& original_out) {
  void* original = nullptr;
  if (!attach_interpose_symbol(symbol, replacement, handle_out, original)) {
    return false;
  }
  original_out = reinterpret_cast<Fn>(original);
  return true;
}

template <typename Replacement, typename Original>
inline bool attach_interpose_symbol(const char* symbol,
                                    Replacement replacement,
                                    w1::h00k::hook_handle& handle_out,
                                    Original& original_out) {
  return attach_interpose_symbol(symbol, reinterpret_cast<void*>(replacement), handle_out, original_out);
}

inline bool attach_inline_instrument(const char* symbol,
                                     const char* module,
                                     w1::h00k::prehook_fn prehook,
                                     w1::h00k::hook_handle& handle_out) {
  w1::h00k::hook_request request{};
  request.target.kind = w1::h00k::hook_target_kind::symbol;
  request.target.symbol = symbol;
  request.target.module = module;
  request.kind = w1::h00k::hook_kind::instrument;
  request.prehook = prehook;
  request.preferred = w1::h00k::hook_technique::inline_trampoline;
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::inline_trampoline);
  request.selection = w1::h00k::hook_selection::strict;

  auto result = w1::h00k::attach(request, nullptr);
  if (!result.error.ok()) {
    return false;
  }

  handle_out = result.handle;
  return true;
}

inline bool attach_inline_replace(const char* symbol,
                                  const char* module,
                                  void* replacement,
                                  w1::h00k::hook_handle& handle_out,
                                  void*& original_out) {
  w1::h00k::hook_request request{};
  request.target.kind = w1::h00k::hook_target_kind::symbol;
  request.target.symbol = symbol;
  request.target.module = module;
  request.replacement = replacement;
  request.preferred = w1::h00k::hook_technique::inline_trampoline;
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::inline_trampoline);
  request.selection = w1::h00k::hook_selection::strict;

  void* original = nullptr;
  auto result = w1::h00k::attach(request, &original);
  if (!result.error.ok()) {
    return false;
  }

  handle_out = result.handle;
  original_out = original;
  return true;
}

template <typename Fn>
inline bool attach_inline_replace(const char* symbol,
                                  const char* module,
                                  void* replacement,
                                  w1::h00k::hook_handle& handle_out,
                                  Fn& original_out) {
  void* original = nullptr;
  if (!attach_inline_replace(symbol, module, replacement, handle_out, original)) {
    return false;
  }
  original_out = reinterpret_cast<Fn>(original);
  return true;
}

template <typename Replacement, typename Original>
inline bool attach_inline_replace(const char* symbol,
                                  const char* module,
                                  Replacement replacement,
                                  w1::h00k::hook_handle& handle_out,
                                  Original& original_out) {
  return attach_inline_replace(symbol, module, reinterpret_cast<void*>(replacement), handle_out, original_out);
}

inline bool attach_symbol_replace_prefer_inline(const char* symbol,
                                                const char* module,
                                                void* replacement,
                                                w1::h00k::hook_handle& handle_out,
                                                void*& original_out) {
  w1::h00k::hook_request request{};
  request.target.kind = w1::h00k::hook_target_kind::symbol;
  request.target.symbol = symbol;
  request.target.module = module;
  request.replacement = replacement;
  request.preferred = w1::h00k::hook_technique::inline_trampoline;
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::inline_trampoline) |
                    w1::h00k::technique_mask(w1::h00k::hook_technique::interpose);
  request.selection = w1::h00k::hook_selection::allow_fallback;

  void* original = nullptr;
  auto result = w1::h00k::attach(request, &original);
  if (!result.error.ok()) {
    return false;
  }

  handle_out = result.handle;
  original_out = original;
  return true;
}

template <typename Fn>
inline bool attach_symbol_replace_prefer_inline(const char* symbol,
                                                const char* module,
                                                void* replacement,
                                                w1::h00k::hook_handle& handle_out,
                                                Fn& original_out) {
  void* original = nullptr;
  if (!attach_symbol_replace_prefer_inline(symbol, module, replacement, handle_out, original)) {
    return false;
  }
  original_out = reinterpret_cast<Fn>(original);
  return true;
}

template <typename Replacement, typename Original>
inline bool attach_symbol_replace_prefer_inline(const char* symbol,
                                                const char* module,
                                                Replacement replacement,
                                                w1::h00k::hook_handle& handle_out,
                                                Original& original_out) {
  return attach_symbol_replace_prefer_inline(symbol, module, reinterpret_cast<void*>(replacement), handle_out,
                                             original_out);
}

inline void detach_if_attached(w1::h00k::hook_handle& handle) {
  if (handle.id == 0) {
    return;
  }
  (void)w1::h00k::detach(handle);
  handle = {};
}

} // namespace w1::monitor::backend::hook_helpers

```

`src/w1monitor/backend/linux/linux_module_monitor.cpp`:

```cpp
#include "w1monitor/backend/linux/linux_module_monitor.hpp"

#include <utility>

#include <dlfcn.h>

#include "w1h00k/hook.hpp"
#include "w1h00k/resolve/resolve.hpp"
#include "w1monitor/backend/module_snapshot.hpp"
#include "w1monitor/backend/hook_helpers.hpp"
#include "w1monitor/event_queue.hpp"

namespace w1::monitor::backend::linux_backend {
namespace {

using dlopen_fn = void* (*)(const char*, int);
using dlclose_fn = int (*)(void*);

class linux_module_monitor final : public module_monitor {
public:
  void start() override {
    if (active_) {
      return;
    }
    active_ = true;
    active_monitor = this;

    refresh_snapshot(false);
    install_hooks();
  }

  void stop() override {
    active_ = false;
    if (active_monitor == this) {
      active_monitor = nullptr;
    }

    hook_helpers::detach_if_attached(dlopen_handle_);
    original_dlopen_ = nullptr;
    hook_helpers::detach_if_attached(dlclose_handle_);
    original_dlclose_ = nullptr;

    queue_.clear();
    snapshot_.clear();
  }

  bool poll(module_event& out) override { return queue_.poll(out); }

private:
  static void* replacement_dlopen(const char* path, int mode) {
    auto* monitor = active_monitor;
    void* handle = nullptr;
    if (monitor && monitor->original_dlopen_) {
      handle = monitor->original_dlopen_(path, mode);
      if (monitor->active_) {
        monitor->refresh_snapshot(true);
      }
    }
    return handle;
  }

  static int replacement_dlclose(void* handle) {
    auto* monitor = active_monitor;
    int result = 0;
    if (monitor && monitor->original_dlclose_) {
      result = monitor->original_dlclose_(handle);
      if (monitor->active_) {
        monitor->refresh_snapshot(true);
      }
    }
    return result;
  }

  void install_hooks() {
    if (dlopen_handle_.id == 0) {
      (void)hook_helpers::attach_symbol_replace_prefer_inline(
          "dlopen",
          nullptr,
          &linux_module_monitor::replacement_dlopen,
          dlopen_handle_, original_dlopen_);
    }

    if (dlclose_handle_.id == 0) {
      (void)hook_helpers::attach_symbol_replace_prefer_inline(
          "dlclose",
          nullptr,
          &linux_module_monitor::replacement_dlclose,
          dlclose_handle_, original_dlclose_);
    }
  }

  void refresh_snapshot(bool emit_events) {
    const auto modules = w1::h00k::resolve::enumerate_modules();
    std::vector<module_snapshot_entry> next;
    next.reserve(modules.size());
    for (const auto& entry : modules) {
      if (!entry.base) {
        continue;
      }
      module_snapshot_entry snapshot{};
      snapshot.base = entry.base;
      snapshot.size = entry.size;
      snapshot.path = entry.path;
      next.push_back(std::move(snapshot));
    }

    snapshot_.refresh(next, emit_events, [&](const module_event& event) {
      queue_.push(event);
    });
  }

  static inline linux_module_monitor* active_monitor = nullptr;
  bool active_ = false;
  event_queue queue_{};
  module_snapshot_tracker snapshot_{};

  w1::h00k::hook_handle dlopen_handle_{};
  w1::h00k::hook_handle dlclose_handle_{};
  dlopen_fn original_dlopen_ = nullptr;
  dlclose_fn original_dlclose_ = nullptr;
};

} // namespace

std::unique_ptr<module_monitor> make_module_monitor() {
  return std::make_unique<linux_module_monitor>();
}

} // namespace w1::monitor::backend::linux_backend

```

`src/w1monitor/backend/linux/linux_module_monitor.hpp`:

```hpp
#pragma once

#include <memory>

#include "w1monitor/module_monitor.hpp"

namespace w1::monitor::backend::linux_backend {

std::unique_ptr<module_monitor> make_module_monitor();

} // namespace w1::monitor::backend::linux_backend

```

`src/w1monitor/backend/linux/linux_thread_monitor.cpp`:

```cpp
#if defined(__linux__) && !defined(_GNU_SOURCE)
#define _GNU_SOURCE
#endif

#include "w1monitor/backend/linux/linux_thread_monitor.hpp"

#include <atomic>
#include <cerrno>
#include <memory>

#include <pthread.h>
#include <sys/syscall.h>
#include <unistd.h>

#include "w1h00k/hook.hpp"
#include "w1monitor/backend/hook_helpers.hpp"
#include "w1monitor/backend/thread_entry.hpp"
#include "w1monitor/backend/thread_event_helpers.hpp"
#include "w1monitor/event_queue.hpp"

namespace w1::monitor::backend::linux_backend {
namespace {

using pthread_create_fn = int (*)(pthread_t*, const pthread_attr_t*, void* (*)(void*), void*);
using pthread_exit_fn = void (*)(void*);
using pthread_setname_fn = int (*)(pthread_t, const char*);

uint64_t current_tid() {
  return static_cast<uint64_t>(syscall(SYS_gettid));
}

struct start_payload {
  void* (*start_routine)(void*) = nullptr;
  void* arg = nullptr;
  class linux_thread_monitor* monitor = nullptr;
};

struct stop_cleanup_context {
  linux_thread_monitor* monitor = nullptr;
  uint64_t tid = 0;
  start_payload* payload = nullptr;
};

class linux_thread_monitor final : public thread_monitor {
public:
  void start() override {
    if (active_) {
      return;
    }
    active_ = true;
    active_monitor = this;

    install_hooks();
  }

  void stop() override {
    active_ = false;
    if (active_monitor == this) {
      active_monitor = nullptr;
    }

    hook_helpers::detach_if_attached(pthread_create_handle_);
    original_pthread_create_ = nullptr;
    hook_helpers::detach_if_attached(pthread_exit_handle_);
    original_pthread_exit_ = nullptr;
    hook_helpers::detach_if_attached(pthread_setname_handle_);
    original_pthread_setname_ = nullptr;

    queue_.clear();
  }

  bool poll(thread_event& out) override { return queue_.poll(out); }
  void set_entry_callback(thread_entry_callback callback) override { entry_callback_ = std::move(callback); }

private:
  static void stop_cleanup(void* arg) {
    auto* ctx = static_cast<stop_cleanup_context*>(arg);
    if (!ctx || !ctx->monitor) {
      if (ctx && ctx->payload) {
        delete ctx->payload;
      }
      return;
    }
    auto* monitor = ctx->monitor;
    if (monitor->active_ && monitor->stop_tracker_.should_emit()) {
      monitor->emitter_.stopped(ctx->tid);
    }
    if (ctx->payload) {
      delete ctx->payload;
    }
  }

  static void* start_trampoline(void* arg) {
    auto* payload = static_cast<start_payload*>(arg);
    linux_thread_monitor* monitor = payload ? payload->monitor : nullptr;
    void* (*start_routine)(void*) = payload ? payload->start_routine : nullptr;
    void* start_arg = payload ? payload->arg : nullptr;

    const uint64_t tid = current_tid();
    if (monitor && monitor->active_) {
      monitor->emitter_.started(tid);
    }
    if (monitor) {
      monitor->stop_tracker_.reset();
    }

    void* result = nullptr;
    if (monitor) {
      stop_cleanup_context cleanup{monitor, tid, payload};
      uint64_t result_value = 0;
      pthread_cleanup_push(&linux_thread_monitor::stop_cleanup, &cleanup);
      result_value = backend::dispatch_thread_entry(
          monitor->entry_callback_,
          thread_entry_kind::posix,
          tid,
          reinterpret_cast<void*>(start_routine),
          start_arg,
          [&]() -> uint64_t {
            if (start_routine) {
              return static_cast<uint64_t>(reinterpret_cast<uintptr_t>(start_routine(start_arg)));
            }
            return 0;
          });
      pthread_cleanup_pop(0);
      result = reinterpret_cast<void*>(static_cast<uintptr_t>(result_value));
      delete payload;
    } else if (start_routine) {
      result = start_routine(start_arg);
      if (payload) {
        delete payload;
      }
    } else if (payload) {
      delete payload;
    }

    if (monitor && monitor->active_ && monitor->stop_tracker_.should_emit()) {
      monitor->emitter_.stopped(tid);
    }

    return result;
  }

  static int replacement_pthread_create(pthread_t* thread, const pthread_attr_t* attr,
                                        void* (*start_routine)(void*), void* arg) {
    auto* monitor = active_monitor;
    if (!monitor || !monitor->original_pthread_create_) {
      return EINVAL;
    }

    auto* payload = new start_payload{};
    payload->start_routine = start_routine;
    payload->arg = arg;
    payload->monitor = monitor;

    const int result =
        monitor->original_pthread_create_(thread, attr, &linux_thread_monitor::start_trampoline, payload);
    if (result != 0) {
      delete payload;
    }
    return result;
  }

  static void replacement_pthread_exit(void* value) {
    auto* monitor = active_monitor;
    if (monitor && monitor->active_ && monitor->stop_tracker_.should_emit()) {
      monitor->emitter_.stopped(current_tid());
    }
    if (monitor && monitor->original_pthread_exit_) {
      monitor->original_pthread_exit_(value);
    }
  }

  static int replacement_pthread_setname(pthread_t thread, const char* name) {
    auto* monitor = active_monitor;
    int result = 0;
    if (monitor && monitor->original_pthread_setname_) {
      result = monitor->original_pthread_setname_(thread, name);
    }
    if (monitor && monitor->active_ && result == 0 && name &&
        pthread_equal(thread, pthread_self())) {
      monitor->emitter_.renamed(current_tid(), name);
    }
    return result;
  }

  void install_hooks() {
    if (pthread_create_handle_.id == 0) {
      (void)hook_helpers::attach_symbol_replace_prefer_inline(
          "pthread_create",
          nullptr,
          &linux_thread_monitor::replacement_pthread_create,
          pthread_create_handle_, original_pthread_create_);
    }

    if (pthread_exit_handle_.id == 0) {
      (void)hook_helpers::attach_symbol_replace_prefer_inline(
          "pthread_exit",
          nullptr,
          &linux_thread_monitor::replacement_pthread_exit,
          pthread_exit_handle_, original_pthread_exit_);
    }

    if (pthread_setname_handle_.id == 0) {
      (void)hook_helpers::attach_symbol_replace_prefer_inline(
          "pthread_setname_np",
          nullptr,
          &linux_thread_monitor::replacement_pthread_setname,
          pthread_setname_handle_, original_pthread_setname_);
    }
  }

  static inline linux_thread_monitor* active_monitor = nullptr;
  bool active_ = false;
  event_queue queue_{};
  thread_event_emitter emitter_{queue_};
  thread_stop_tracker stop_tracker_{};

  w1::h00k::hook_handle pthread_create_handle_{};
  w1::h00k::hook_handle pthread_exit_handle_{};
  w1::h00k::hook_handle pthread_setname_handle_{};

  pthread_create_fn original_pthread_create_ = nullptr;
  pthread_exit_fn original_pthread_exit_ = nullptr;
  pthread_setname_fn original_pthread_setname_ = nullptr;
  thread_entry_callback entry_callback_{};
};

} // namespace

std::unique_ptr<thread_monitor> make_thread_monitor() {
  return std::make_unique<linux_thread_monitor>();
}

} // namespace w1::monitor::backend::linux_backend

```

`src/w1monitor/backend/linux/linux_thread_monitor.hpp`:

```hpp
#pragma once

#include <memory>

#include "w1monitor/thread_monitor.hpp"

namespace w1::monitor::backend::linux_backend {

std::unique_ptr<thread_monitor> make_thread_monitor();

} // namespace w1::monitor::backend::linux_backend

```

`src/w1monitor/backend/module_snapshot.hpp`:

```hpp
#pragma once

#include <mutex>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

#include "w1monitor/module_monitor.hpp"

namespace w1::monitor::backend {

struct module_snapshot_entry {
  void* base = nullptr;
  size_t size = 0;
  std::string path{};
};

class module_snapshot_tracker {
public:
  void clear() {
    std::lock_guard<std::mutex> lock(mutex_);
    modules_.clear();
  }

  void seed(const std::vector<module_snapshot_entry>& modules) {
    refresh(modules, false, [](const module_event&) {});
  }

  template <typename EmitFn>
  void refresh(const std::vector<module_snapshot_entry>& modules, bool emit_events, EmitFn emit) {
    std::unordered_map<void*, module_snapshot_entry> next;
    next.reserve(modules.size());
    for (const auto& entry : modules) {
      if (!entry.base) {
        continue;
      }
      next[entry.base] = entry;
    }

    std::lock_guard<std::mutex> lock(mutex_);
    if (emit_events) {
      for (const auto& [base, entry] : next) {
        if (modules_.find(base) == modules_.end()) {
          emit(make_event(module_event::kind::loaded, entry));
        }
      }
      for (const auto& [base, entry] : modules_) {
        if (next.find(base) == next.end()) {
          emit(make_event(module_event::kind::unloaded, entry));
        }
      }
    }

    modules_ = std::move(next);
  }

  void track(void* base, std::string path, size_t size) {
    if (!base) {
      return;
    }
    std::lock_guard<std::mutex> lock(mutex_);
    auto& entry = modules_[base];
    if (!entry.base) {
      entry.base = base;
    }
    if (!path.empty()) {
      entry.path = std::move(path);
    }
    if (size != 0) {
      entry.size = size;
    }
  }

  void untrack(void* base) {
    if (!base) {
      return;
    }
    std::lock_guard<std::mutex> lock(mutex_);
    modules_.erase(base);
  }

  bool fill_missing(module_event& event) const {
    if (!event.base) {
      return false;
    }
    std::lock_guard<std::mutex> lock(mutex_);
    auto it = modules_.find(event.base);
    if (it == modules_.end()) {
      return false;
    }
    if (event.path.empty()) {
      event.path = it->second.path;
    }
    if (event.size == 0) {
      event.size = it->second.size;
    }
    return true;
  }

private:
  static module_event make_event(module_event::kind kind, const module_snapshot_entry& entry) {
    module_event event{};
    event.type = kind;
    event.path = entry.path;
    event.base = entry.base;
    event.size = entry.size;
    return event;
  }

  mutable std::mutex mutex_{};
  std::unordered_map<void*, module_snapshot_entry> modules_{};
};

} // namespace w1::monitor::backend

```

`src/w1monitor/backend/null/null_module_monitor.cpp`:

```cpp
#include "w1monitor/backend/null/null_module_monitor.hpp"

namespace w1::monitor::backend::null_backend {
namespace {

class null_module_monitor final : public module_monitor {
public:
  void start() override {}
  void stop() override {}
  bool poll(module_event&) override { return false; }
};

} // namespace

std::unique_ptr<module_monitor> make_module_monitor() {
  return std::make_unique<null_module_monitor>();
}

} // namespace w1::monitor::backend::null_backend

```

`src/w1monitor/backend/null/null_module_monitor.hpp`:

```hpp
#pragma once

#include <memory>

#include "w1monitor/module_monitor.hpp"

namespace w1::monitor::backend::null_backend {

std::unique_ptr<module_monitor> make_module_monitor();

} // namespace w1::monitor::backend::null_backend

```

`src/w1monitor/backend/null/null_thread_monitor.cpp`:

```cpp
#include "w1monitor/backend/null/null_thread_monitor.hpp"

namespace w1::monitor::backend::null_backend {
namespace {

class null_thread_monitor final : public thread_monitor {
public:
  void start() override {}
  void stop() override {}
  bool poll(thread_event&) override { return false; }
};

} // namespace

std::unique_ptr<thread_monitor> make_thread_monitor() {
  return std::make_unique<null_thread_monitor>();
}

} // namespace w1::monitor::backend::null_backend

```

`src/w1monitor/backend/null/null_thread_monitor.hpp`:

```hpp
#pragma once

#include <memory>

#include "w1monitor/thread_monitor.hpp"

namespace w1::monitor::backend::null_backend {

std::unique_ptr<thread_monitor> make_thread_monitor();

} // namespace w1::monitor::backend::null_backend

```

`src/w1monitor/backend/thread_entry.hpp`:

```hpp
#pragma once

#include <cstdint>

#include "w1monitor/thread_monitor.hpp"

namespace w1::monitor::backend {

template <typename InvokeFn>
uint64_t dispatch_thread_entry(thread_entry_callback& callback,
                               thread_entry_kind kind,
                               uint64_t tid,
                               void* start_routine,
                               void* arg,
                               InvokeFn invoke_start) {
  if (callback) {
    thread_entry_context ctx{};
    ctx.kind = kind;
    ctx.tid = tid;
    ctx.start_routine = start_routine;
    ctx.arg = arg;
    uint64_t callback_result = 0;
    if (callback(ctx, callback_result)) {
      return callback_result;
    }
  }
  return invoke_start();
}

} // namespace w1::monitor::backend

```

`src/w1monitor/backend/thread_event_helpers.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string_view>

#include "w1monitor/event_queue.hpp"
#include "w1monitor/thread_monitor.hpp"

namespace w1::monitor::backend {

class thread_event_emitter {
public:
  explicit thread_event_emitter(event_queue& queue) : queue_(queue) {}

  void started(uint64_t tid) { push(thread_event::kind::started, tid, {}); }
  void stopped(uint64_t tid) { push(thread_event::kind::stopped, tid, {}); }
  void renamed(uint64_t tid, std::string_view name) { push(thread_event::kind::renamed, tid, name); }

private:
  void push(thread_event::kind kind, uint64_t tid, std::string_view name) {
    thread_event event{};
    event.type = kind;
    event.tid = tid;
    if (!name.empty()) {
      event.name.assign(name.begin(), name.end());
    }
    queue_.push(event);
  }

  event_queue& queue_;
};

class thread_stop_tracker {
public:
  void reset() { emitted_ = false; }
  bool should_emit() {
    if (emitted_) {
      return false;
    }
    emitted_ = true;
    return true;
  }

private:
  static thread_local bool emitted_;
};

inline thread_local bool thread_stop_tracker::emitted_ = false;

} // namespace w1::monitor::backend

```

`src/w1monitor/backend/windows/windows_module_monitor.cpp`:

```cpp
#include "w1monitor/backend/windows/windows_module_monitor.hpp"

#include <memory>
#include <windows.h>
#include <tlhelp32.h>
#include <winternl.h>

#include "w1h00k/hook.hpp"
#include "w1monitor/backend/module_snapshot.hpp"
#include "w1monitor/backend/hook_helpers.hpp"
#include "w1monitor/backend/windows/windows_string_utils.hpp"
#include "w1monitor/event_queue.hpp"

namespace w1::monitor::backend::windows {
namespace {

struct ldr_dll_notification_data {
  ULONG Flags;
  union {
    struct {
      const UNICODE_STRING* FullDllName;
      const UNICODE_STRING* BaseDllName;
      PVOID DllBase;
      ULONG SizeOfImage;
    } Loaded;
    struct {
      const UNICODE_STRING* FullDllName;
      const UNICODE_STRING* BaseDllName;
      PVOID DllBase;
      ULONG SizeOfImage;
    } Unloaded;
  };
};

using ldr_dll_notify_fn = VOID (CALLBACK*)(ULONG reason, const ldr_dll_notification_data* data, void* context);
using ldr_register_fn = NTSTATUS (NTAPI*)(ULONG, ldr_dll_notify_fn, void*, void**);
using ldr_unregister_fn = NTSTATUS (NTAPI*)(void*);

static constexpr ULONG kLdrLoaded = 1;
static constexpr ULONG kLdrUnloaded = 2;

using loadlibrarya_fn = HMODULE(WINAPI*)(LPCSTR);
using loadlibraryw_fn = HMODULE(WINAPI*)(LPCWSTR);
using loadlibraryexa_fn = HMODULE(WINAPI*)(LPCSTR, HANDLE, DWORD);
using loadlibraryexw_fn = HMODULE(WINAPI*)(LPCWSTR, HANDLE, DWORD);
using freelibrary_fn = BOOL(WINAPI*)(HMODULE);

static thread_local bool g_snapshot_active = false;
static thread_local bool g_loader_hook_active = false;

struct loader_hook_guard {
  bool& flag;
  bool active = false;

  explicit loader_hook_guard(bool& flag_ref) : flag(flag_ref), active(!flag_ref) {
    if (active) {
      flag = true;
    }
  }

  ~loader_hook_guard() {
    if (active) {
      flag = false;
    }
  }
};

class windows_module_monitor final : public module_monitor {
public:
  void start() override {
    if (active_) {
      return;
    }
    active_ = true;
    active_monitor = this;

    refresh_snapshot(false);
    if (!register_notifications()) {
      install_hooks();
    }
  }

  void stop() override {
    active_ = false;
    if (active_monitor == this) {
      active_monitor = nullptr;
    }

    if (cookie_ && unregister_fn_) {
      unregister_fn_(cookie_);
      cookie_ = nullptr;
    }

    detach_hooks();

    queue_.clear();
    snapshot_.clear();
  }

  bool poll(module_event& out) override { return queue_.poll(out); }

private:
  static void CALLBACK on_dll_notification(ULONG reason, const ldr_dll_notification_data* data, void* context) {
    auto* monitor = static_cast<windows_module_monitor*>(context);
    if (!monitor || !monitor->active_ || !data) {
      return;
    }
    if (reason == kLdrLoaded) {
      monitor->emit_module(data->Loaded.FullDllName, data->Loaded.DllBase, data->Loaded.SizeOfImage,
                           module_event::kind::loaded);
      monitor->track_module(data->Loaded.DllBase, data->Loaded.FullDllName, data->Loaded.SizeOfImage);
    } else if (reason == kLdrUnloaded) {
      monitor->emit_module(data->Unloaded.FullDllName, data->Unloaded.DllBase, data->Unloaded.SizeOfImage,
                           module_event::kind::unloaded);
      monitor->untrack_module(data->Unloaded.DllBase);
    }
  }

  static HMODULE WINAPI replacement_loadlibrarya(LPCSTR name) {
    auto* monitor = active_monitor;
    HMODULE handle = nullptr;
    if (monitor && monitor->original_loadlibrarya_) {
      loader_hook_guard guard(g_loader_hook_active);
      if (!guard.active) {
        return monitor->original_loadlibrarya_(name);
      }
      handle = monitor->original_loadlibrarya_(name);
      if (monitor->active_ && !g_snapshot_active) {
        g_snapshot_active = true;
        monitor->refresh_snapshot(true);
        g_snapshot_active = false;
      }
    }
    return handle;
  }

  static HMODULE WINAPI replacement_loadlibraryw(LPCWSTR name) {
    auto* monitor = active_monitor;
    HMODULE handle = nullptr;
    if (monitor && monitor->original_loadlibraryw_) {
      loader_hook_guard guard(g_loader_hook_active);
      if (!guard.active) {
        return monitor->original_loadlibraryw_(name);
      }
      handle = monitor->original_loadlibraryw_(name);
      if (monitor->active_ && !g_snapshot_active) {
        g_snapshot_active = true;
        monitor->refresh_snapshot(true);
        g_snapshot_active = false;
      }
    }
    return handle;
  }

  static HMODULE WINAPI replacement_loadlibraryexa(LPCSTR name, HANDLE file, DWORD flags) {
    auto* monitor = active_monitor;
    HMODULE handle = nullptr;
    if (monitor && monitor->original_loadlibraryexa_) {
      loader_hook_guard guard(g_loader_hook_active);
      if (!guard.active) {
        return monitor->original_loadlibraryexa_(name, file, flags);
      }
      handle = monitor->original_loadlibraryexa_(name, file, flags);
      if (monitor->active_ && !g_snapshot_active) {
        g_snapshot_active = true;
        monitor->refresh_snapshot(true);
        g_snapshot_active = false;
      }
    }
    return handle;
  }

  static HMODULE WINAPI replacement_loadlibraryexw(LPCWSTR name, HANDLE file, DWORD flags) {
    auto* monitor = active_monitor;
    HMODULE handle = nullptr;
    if (monitor && monitor->original_loadlibraryexw_) {
      loader_hook_guard guard(g_loader_hook_active);
      if (!guard.active) {
        return monitor->original_loadlibraryexw_(name, file, flags);
      }
      handle = monitor->original_loadlibraryexw_(name, file, flags);
      if (monitor->active_ && !g_snapshot_active) {
        g_snapshot_active = true;
        monitor->refresh_snapshot(true);
        g_snapshot_active = false;
      }
    }
    return handle;
  }

  static BOOL WINAPI replacement_freelibrary(HMODULE module) {
    auto* monitor = active_monitor;
    BOOL result = FALSE;
    if (monitor && monitor->original_freelibrary_) {
      loader_hook_guard guard(g_loader_hook_active);
      if (!guard.active) {
        return monitor->original_freelibrary_(module);
      }
      result = monitor->original_freelibrary_(module);
      if (monitor->active_ && !g_snapshot_active) {
        g_snapshot_active = true;
        monitor->refresh_snapshot(true);
        g_snapshot_active = false;
      }
    }
    return result;
  }

  bool register_notifications() {
    HMODULE ntdll = GetModuleHandleW(L"ntdll.dll");
    if (!ntdll) {
      return false;
    }

    auto register_fn = reinterpret_cast<ldr_register_fn>(GetProcAddress(ntdll, "LdrRegisterDllNotification"));
    unregister_fn_ = reinterpret_cast<ldr_unregister_fn>(GetProcAddress(ntdll, "LdrUnregisterDllNotification"));
    if (!register_fn || !unregister_fn_) {
      return false;
    }

    NTSTATUS status = register_fn(0, &windows_module_monitor::on_dll_notification, this, &cookie_);
    if (status != 0) {
      cookie_ = nullptr;
      return false;
    }

    return true;
  }

  void install_hooks() {
    if (loadlibrarya_handle_.id == 0) {
      (void)hook_helpers::attach_interpose_symbol(
          "LoadLibraryA", &windows_module_monitor::replacement_loadlibrarya,
          loadlibrarya_handle_, original_loadlibrarya_);
    }

    if (loadlibraryw_handle_.id == 0) {
      (void)hook_helpers::attach_interpose_symbol(
          "LoadLibraryW", &windows_module_monitor::replacement_loadlibraryw,
          loadlibraryw_handle_, original_loadlibraryw_);
    }

    if (loadlibraryexa_handle_.id == 0) {
      (void)hook_helpers::attach_interpose_symbol(
          "LoadLibraryExA", &windows_module_monitor::replacement_loadlibraryexa,
          loadlibraryexa_handle_, original_loadlibraryexa_);
    }

    if (loadlibraryexw_handle_.id == 0) {
      (void)hook_helpers::attach_interpose_symbol(
          "LoadLibraryExW", &windows_module_monitor::replacement_loadlibraryexw,
          loadlibraryexw_handle_, original_loadlibraryexw_);
    }

    if (freelibrary_handle_.id == 0) {
      (void)hook_helpers::attach_interpose_symbol(
          "FreeLibrary", &windows_module_monitor::replacement_freelibrary,
          freelibrary_handle_, original_freelibrary_);
    }
  }

  void detach_hooks() {
    hook_helpers::detach_if_attached(loadlibrarya_handle_);
    original_loadlibrarya_ = nullptr;
    hook_helpers::detach_if_attached(loadlibraryw_handle_);
    original_loadlibraryw_ = nullptr;
    hook_helpers::detach_if_attached(loadlibraryexa_handle_);
    original_loadlibraryexa_ = nullptr;
    hook_helpers::detach_if_attached(loadlibraryexw_handle_);
    original_loadlibraryexw_ = nullptr;
    hook_helpers::detach_if_attached(freelibrary_handle_);
    original_freelibrary_ = nullptr;
  }

  void refresh_snapshot(bool emit_events) {
    std::vector<module_snapshot_entry> next;

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, GetCurrentProcessId());
    if (snapshot == INVALID_HANDLE_VALUE) {
      return;
    }

    MODULEENTRY32 entry{};
    entry.dwSize = sizeof(entry);
    if (Module32First(snapshot, &entry)) {
      do {
        module_snapshot_entry event{};
        event.path = entry.szExePath;
        event.base = entry.modBaseAddr;
        event.size = entry.modBaseSize;
        if (event.base) {
          next.push_back(std::move(event));
        }
        entry.dwSize = sizeof(entry);
      } while (Module32Next(snapshot, &entry));
    }

    CloseHandle(snapshot);

    snapshot_.refresh(next, emit_events, [&](const module_event& event) {
      queue_.push(event);
    });
  }

  void emit_module(const UNICODE_STRING* full_name, void* base, size_t size, module_event::kind kind) {
    if (!base) {
      return;
    }
    module_event event{};
    event.type = kind;
    event.path = utf16_to_utf8(full_name);
    event.base = base;
    event.size = size;
    snapshot_.fill_missing(event);
    queue_.push(event);
  }

  void track_module(void* base, const UNICODE_STRING* full_name, size_t size) {
    snapshot_.track(base, utf16_to_utf8(full_name), size);
  }

  void untrack_module(void* base) {
    snapshot_.untrack(base);
  }

  static inline windows_module_monitor* active_monitor = nullptr;
  bool active_ = false;
  event_queue queue_{};
  module_snapshot_tracker snapshot_{};

  void* cookie_ = nullptr;
  ldr_unregister_fn unregister_fn_ = nullptr;

  w1::h00k::hook_handle loadlibrarya_handle_{};
  w1::h00k::hook_handle loadlibraryw_handle_{};
  w1::h00k::hook_handle loadlibraryexa_handle_{};
  w1::h00k::hook_handle loadlibraryexw_handle_{};
  w1::h00k::hook_handle freelibrary_handle_{};

  loadlibrarya_fn original_loadlibrarya_ = nullptr;
  loadlibraryw_fn original_loadlibraryw_ = nullptr;
  loadlibraryexa_fn original_loadlibraryexa_ = nullptr;
  loadlibraryexw_fn original_loadlibraryexw_ = nullptr;
  freelibrary_fn original_freelibrary_ = nullptr;
};

} // namespace

std::unique_ptr<module_monitor> make_module_monitor() {
  return std::make_unique<windows_module_monitor>();
}

} // namespace w1::monitor::backend::windows

```

`src/w1monitor/backend/windows/windows_module_monitor.hpp`:

```hpp
#pragma once

#include <memory>

#include "w1monitor/module_monitor.hpp"

namespace w1::monitor::backend::windows {

std::unique_ptr<module_monitor> make_module_monitor();

} // namespace w1::monitor::backend::windows

```

`src/w1monitor/backend/windows/windows_string_utils.hpp`:

```hpp
#pragma once

#include <string>
#include <cwchar>

#include <windows.h>
#include <winternl.h>

namespace w1::monitor::backend::windows {

inline std::string utf16_to_utf8(const wchar_t* value, size_t length) {
  if (!value || length == 0) {
    return {};
  }
  const int wchar_len = static_cast<int>(length);
  if (wchar_len <= 0) {
    return {};
  }
  const int required = WideCharToMultiByte(CP_UTF8, 0, value, wchar_len, nullptr, 0, nullptr, nullptr);
  if (required <= 0) {
    return {};
  }
  std::string out(static_cast<size_t>(required), '\0');
  WideCharToMultiByte(CP_UTF8, 0, value, wchar_len, out.data(), required, nullptr, nullptr);
  return out;
}

inline std::string utf16_to_utf8(const UNICODE_STRING* value) {
  if (!value || !value->Buffer || value->Length == 0) {
    return {};
  }
  const size_t wchar_len = static_cast<size_t>(value->Length / sizeof(WCHAR));
  return utf16_to_utf8(value->Buffer, wchar_len);
}

inline std::string utf16_to_utf8(PCWSTR value) {
  if (!value) {
    return {};
  }
  const size_t wchar_len = std::wcslen(value);
  return utf16_to_utf8(value, wchar_len);
}

} // namespace w1::monitor::backend::windows

```

`src/w1monitor/backend/windows/windows_thread_monitor.cpp`:

```cpp
#include "w1monitor/backend/windows/windows_thread_monitor.hpp"

#include <memory>
#include <windows.h>

#include "w1h00k/hook.hpp"
#include "w1monitor/backend/hook_helpers.hpp"
#include "w1monitor/backend/thread_entry.hpp"
#include "w1monitor/backend/thread_event_helpers.hpp"
#include "w1monitor/backend/windows/windows_string_utils.hpp"
#include "w1monitor/event_queue.hpp"

namespace w1::monitor::backend::windows {
namespace {

using create_thread_fn = HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD);
using exit_thread_fn = VOID(WINAPI*)(DWORD);
using set_thread_description_fn = HRESULT(WINAPI*)(HANDLE, PCWSTR);

class windows_thread_monitor final : public thread_monitor {
public:
  void start() override {
    if (active_) {
      return;
    }
    active_ = true;
    active_monitor = this;
    install_hooks();
  }

  void stop() override {
    active_ = false;
    if (active_monitor == this) {
      active_monitor = nullptr;
    }

    hook_helpers::detach_if_attached(base_thread_init_handle_);
    hook_helpers::detach_if_attached(rtl_exit_user_handle_);
    hook_helpers::detach_if_attached(create_thread_handle_);
    original_create_thread_ = nullptr;
    hook_helpers::detach_if_attached(exit_thread_handle_);
    original_exit_thread_ = nullptr;
    hook_helpers::detach_if_attached(set_description_handle_);
    original_set_description_ = nullptr;

    use_native_start_ = false;
    use_native_stop_ = false;

    queue_.clear();
  }

  bool poll(thread_event& out) override { return queue_.poll(out); }
  void set_entry_callback(thread_entry_callback callback) override { entry_callback_ = std::move(callback); }

private:
  struct start_payload {
    LPTHREAD_START_ROUTINE start_routine = nullptr;
    void* arg = nullptr;
    class windows_thread_monitor* monitor = nullptr;
  };

  static void prehook_base_thread_init_thunk(w1::h00k::hook_info* info) {
    (void)info;
    auto* monitor = active_monitor;
    if (!monitor || !monitor->active_) {
      return;
    }
    monitor->emitter_.started(static_cast<uint64_t>(GetCurrentThreadId()));
  }

  static void prehook_rtl_exit_user_thread(w1::h00k::hook_info* info) {
    (void)info;
    auto* monitor = active_monitor;
    if (!monitor || !monitor->active_) {
      return;
    }
    monitor->emitter_.stopped(static_cast<uint64_t>(GetCurrentThreadId()));
  }

  static DWORD WINAPI start_trampoline(LPVOID param) {
    std::unique_ptr<start_payload> payload(static_cast<start_payload*>(param));
    windows_thread_monitor* monitor = payload->monitor;
    LPTHREAD_START_ROUTINE start_routine = payload->start_routine;
    void* start_arg = payload->arg;

    if (monitor) {
      monitor->stop_tracker_.reset();
    }
    if (monitor && monitor->active_ && !monitor->use_native_start_) {
      monitor->emitter_.started(static_cast<uint64_t>(GetCurrentThreadId()));
    }

    DWORD result = 0;
    if (monitor) {
      const uint64_t result_value = backend::dispatch_thread_entry(
          monitor->entry_callback_,
          thread_entry_kind::win32,
          static_cast<uint64_t>(GetCurrentThreadId()),
          reinterpret_cast<void*>(start_routine),
          start_arg,
          [&]() -> uint64_t {
            if (start_routine) {
              return static_cast<uint64_t>(start_routine(start_arg));
            }
            return 0;
          });
      result = static_cast<DWORD>(result_value);
    } else if (start_routine) {
      result = start_routine(start_arg);
    }

    if (monitor && monitor->active_ && !monitor->use_native_stop_ && monitor->stop_tracker_.should_emit()) {
      monitor->emitter_.stopped(static_cast<uint64_t>(GetCurrentThreadId()));
    }

    return result;
  }

  static HANDLE WINAPI replacement_create_thread(LPSECURITY_ATTRIBUTES attrs, SIZE_T stack,
                                                 LPTHREAD_START_ROUTINE start, LPVOID param,
                                                 DWORD flags, LPDWORD thread_id) {
    auto* monitor = active_monitor;
    HANDLE handle = nullptr;
    if (monitor && monitor->original_create_thread_) {
      auto* payload = new start_payload{};
      payload->start_routine = start;
      payload->arg = param;
      payload->monitor = monitor;
      handle = monitor->original_create_thread_(attrs, stack, &windows_thread_monitor::start_trampoline, payload,
                                                flags, thread_id);
      if (!handle) {
        delete payload;
      }
    }
    return handle;
  }

  static VOID WINAPI replacement_exit_thread(DWORD code) {
    auto* monitor = active_monitor;
    if (monitor && monitor->active_ && !monitor->use_native_stop_ && monitor->stop_tracker_.should_emit()) {
      monitor->emitter_.stopped(static_cast<uint64_t>(GetCurrentThreadId()));
    }
    if (monitor && monitor->original_exit_thread_) {
      monitor->original_exit_thread_(code);
    }
  }

  static HRESULT WINAPI replacement_set_thread_description(HANDLE thread, PCWSTR name) {
    auto* monitor = active_monitor;
    HRESULT hr = E_FAIL;
    if (monitor && monitor->original_set_description_) {
      hr = monitor->original_set_description_(thread, name);
    }
    if (monitor && monitor->active_ && SUCCEEDED(hr) && name) {
      DWORD tid = GetThreadId(thread);
      if (tid != 0) {
        monitor->emitter_.renamed(static_cast<uint64_t>(tid), utf16_to_utf8(name));
      }
    }
    return hr;
  }

  void install_native_hooks() {
    if (base_thread_init_handle_.id == 0) {
      if (hook_helpers::attach_inline_instrument("BaseThreadInitThunk", "kernel32.dll",
                                                 &windows_thread_monitor::prehook_base_thread_init_thunk,
                                                 base_thread_init_handle_)) {
        use_native_start_ = true;
      }
    }

    if (rtl_exit_user_handle_.id == 0) {
      if (hook_helpers::attach_inline_instrument("RtlExitUserThread", "ntdll.dll",
                                                 &windows_thread_monitor::prehook_rtl_exit_user_thread,
                                                 rtl_exit_user_handle_)) {
        use_native_stop_ = true;
      }
    }
  }

  void install_create_hook() {
    if (create_thread_handle_.id != 0) {
      return;
    }

    (void)hook_helpers::attach_interpose_symbol(
        "CreateThread", &windows_thread_monitor::replacement_create_thread,
        create_thread_handle_, original_create_thread_);
  }

  void install_exit_hook() {
    if (exit_thread_handle_.id != 0) {
      return;
    }

    (void)hook_helpers::attach_interpose_symbol(
        "ExitThread", &windows_thread_monitor::replacement_exit_thread,
        exit_thread_handle_, original_exit_thread_);
  }

  void install_set_description_hook() {
    if (set_description_handle_.id != 0) {
      return;
    }

    if (hook_helpers::attach_inline_replace(
            "SetThreadDescription", "kernel32.dll",
            &windows_thread_monitor::replacement_set_thread_description,
            set_description_handle_, original_set_description_)) {
      return;
    }

    HMODULE kernel32 = GetModuleHandleW(L"kernel32.dll");
    if (!kernel32 || !GetProcAddress(kernel32, "SetThreadDescription")) {
      return;
    }

    (void)hook_helpers::attach_interpose_symbol(
        "SetThreadDescription",
        &windows_thread_monitor::replacement_set_thread_description,
        set_description_handle_, original_set_description_);
  }

  void install_hooks() {
    install_native_hooks();
    install_create_hook();
    if (!use_native_stop_) {
      install_exit_hook();
    }
    install_set_description_hook();
  }

  static inline windows_thread_monitor* active_monitor = nullptr;
  bool active_ = false;
  bool use_native_start_ = false;
  bool use_native_stop_ = false;
  event_queue queue_{};
  thread_event_emitter emitter_{queue_};
  thread_stop_tracker stop_tracker_{};

  w1::h00k::hook_handle base_thread_init_handle_{};
  w1::h00k::hook_handle rtl_exit_user_handle_{};
  w1::h00k::hook_handle create_thread_handle_{};
  w1::h00k::hook_handle exit_thread_handle_{};
  w1::h00k::hook_handle set_description_handle_{};

  create_thread_fn original_create_thread_ = nullptr;
  exit_thread_fn original_exit_thread_ = nullptr;
  set_thread_description_fn original_set_description_ = nullptr;
  thread_entry_callback entry_callback_{};
};

} // namespace

std::unique_ptr<thread_monitor> make_thread_monitor() {
  return std::make_unique<windows_thread_monitor>();
}

} // namespace w1::monitor::backend::windows

```

`src/w1monitor/backend/windows/windows_thread_monitor.hpp`:

```hpp
#pragma once

#include <memory>

#include "w1monitor/thread_monitor.hpp"

namespace w1::monitor::backend::windows {

std::unique_ptr<thread_monitor> make_thread_monitor();

} // namespace w1::monitor::backend::windows

```

`src/w1monitor/event_queue.hpp`:

```hpp
#pragma once

#include <deque>
#include <mutex>

#include "w1monitor/module_monitor.hpp"
#include "w1monitor/thread_monitor.hpp"

namespace w1::monitor {

class event_queue {
public:
  void push(const module_event& event) {
    std::lock_guard<std::mutex> lock(mutex_);
    module_events_.push_back(event);
  }

  void push(const thread_event& event) {
    std::lock_guard<std::mutex> lock(mutex_);
    thread_events_.push_back(event);
  }

  bool poll(module_event& out) {
    std::lock_guard<std::mutex> lock(mutex_);
    if (module_events_.empty()) {
      return false;
    }
    out = module_events_.front();
    module_events_.pop_front();
    return true;
  }

  bool poll(thread_event& out) {
    std::lock_guard<std::mutex> lock(mutex_);
    if (thread_events_.empty()) {
      return false;
    }
    out = thread_events_.front();
    thread_events_.pop_front();
    return true;
  }

  void clear() {
    std::lock_guard<std::mutex> lock(mutex_);
    module_events_.clear();
    thread_events_.clear();
  }

private:
  std::mutex mutex_{};
  std::deque<module_event> module_events_{};
  std::deque<thread_event> thread_events_{};
};

} // namespace w1::monitor

```

`src/w1monitor/module_monitor.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <string>

namespace w1::monitor {

struct module_event {
  enum class kind { loaded, unloaded };
  kind type = kind::loaded;
  std::string path{};
  void* base = nullptr;
  size_t size = 0;
};

class module_monitor {
public:
  virtual ~module_monitor() = default;
  virtual void start() = 0;
  virtual void stop() = 0;
  virtual bool poll(module_event& out) = 0;
};

} // namespace w1::monitor

```

`src/w1monitor/monitor_factory.cpp`:

```cpp
#include "w1monitor/monitor_factory.hpp"

#if defined(__APPLE__)
#include "w1monitor/backend/darwin/darwin_module_monitor.hpp"
#include "w1monitor/backend/darwin/darwin_thread_monitor.hpp"
#elif defined(_WIN32)
#include "w1monitor/backend/windows/windows_module_monitor.hpp"
#include "w1monitor/backend/windows/windows_thread_monitor.hpp"
#elif defined(__linux__)
#include "w1monitor/backend/linux/linux_module_monitor.hpp"
#include "w1monitor/backend/linux/linux_thread_monitor.hpp"
#else
#include "w1monitor/backend/null/null_module_monitor.hpp"
#include "w1monitor/backend/null/null_thread_monitor.hpp"
#endif

namespace w1::monitor {

std::unique_ptr<module_monitor> make_module_monitor() {
#if defined(__APPLE__)
  return backend::darwin::make_module_monitor();
#elif defined(_WIN32)
  return backend::windows::make_module_monitor();
#elif defined(__linux__)
  return backend::linux_backend::make_module_monitor();
#else
  return backend::null_backend::make_module_monitor();
#endif
}

std::unique_ptr<thread_monitor> make_thread_monitor() {
#if defined(__APPLE__)
  return backend::darwin::make_thread_monitor();
#elif defined(_WIN32)
  return backend::windows::make_thread_monitor();
#elif defined(__linux__)
  return backend::linux_backend::make_thread_monitor();
#else
  return backend::null_backend::make_thread_monitor();
#endif
}

} // namespace w1::monitor

```

`src/w1monitor/monitor_factory.hpp`:

```hpp
#pragma once

#include <memory>

#include "w1monitor/module_monitor.hpp"
#include "w1monitor/thread_monitor.hpp"

namespace w1::monitor {

std::unique_ptr<module_monitor> make_module_monitor();
std::unique_ptr<thread_monitor> make_thread_monitor();

} // namespace w1::monitor

```

`src/w1monitor/thread_monitor.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <functional>
#include <string>

namespace w1::monitor {

struct thread_event {
  enum class kind { started, stopped, renamed };
  kind type = kind::started;
  uint64_t tid = 0;
  std::string name{};
};

enum class thread_entry_kind { posix, win32 };

struct thread_entry_context {
  thread_entry_kind kind = thread_entry_kind::posix;
  uint64_t tid = 0;
  void* start_routine = nullptr;
  void* arg = nullptr;
};

using thread_entry_callback = std::function<bool(const thread_entry_context&, uint64_t& result_out)>;

class thread_monitor {
public:
  virtual ~thread_monitor() = default;
  virtual void start() = 0;
  virtual void stop() = 0;
  virtual bool poll(thread_event& out) = 0;
  virtual void set_entry_callback(thread_entry_callback callback) { (void)callback; }
};

} // namespace w1::monitor

```

`src/w1nj3ct/CMakeLists.txt`:

```txt
w1_dep_redlog()

# platform-specific source files
set(COMMON_SOURCES w1nj3ct.cpp error.cpp)
set(PLATFORM_SOURCES "")

if(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
    list(APPEND PLATFORM_SOURCES
        platform/darwin/darwin_injector.cpp
        platform/darwin/impl/injector.c platform/darwin/impl/mach.c platform/darwin/impl/ptrace.c
        platform/darwin/impl/remote_call.c platform/darwin/impl/util.c platform/darwin/impl/exc_handler.c
        platform/darwin/impl/mach_excServer.c
    )
elseif(CMAKE_SYSTEM_NAME STREQUAL "Linux")
    list(APPEND PLATFORM_SOURCES
        platform/linux/linux_injector.cpp
        platform/linux/impl/injector.c platform/linux/impl/elf.c platform/linux/impl/ptrace.c
        platform/linux/impl/remote_call.c platform/linux/impl/util.c platform/linux/impl/shellcode.S
    )
elseif(CMAKE_SYSTEM_NAME STREQUAL "Windows")
    list(APPEND PLATFORM_SOURCES
        platform/windows/windows_injector.cpp platform/windows/error_windows.cpp
        platform/windows/impl/inject_createremotethread.cpp platform/windows/impl/inject_setwindowshook.cpp
        platform/windows/impl/inject_rtlcreateuserthread.cpp platform/windows/impl/inject_reflective.cpp
        platform/windows/impl/inject_launch.cpp platform/windows/impl/auxiliary.cpp
    )
endif()

w1_add_static_library(w1nj3ct ${COMMON_SOURCES} ${PLATFORM_SOURCES})
add_library(w1::nj3ct ALIAS w1nj3ct)

target_link_libraries(w1nj3ct PUBLIC redlog::redlog)

# platform-specific libraries
if(WIN32)
    target_link_libraries(w1nj3ct PRIVATE advapi32 ntdll)
elseif(UNIX AND NOT APPLE)
    find_package(Threads REQUIRED)
    target_link_libraries(w1nj3ct PRIVATE Threads::Threads)
endif()

install(TARGETS w1nj3ct
    EXPORT w1nj3ctTargets
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    RUNTIME DESTINATION bin
    COMPONENT ${W1_INSTALL_COMPONENT}
)

```

`src/w1nj3ct/error.cpp`:

```cpp
#include "error.hpp"

#ifdef _WIN32
#include <w1base/windows_clean.hpp>
#elif defined(__APPLE__)
#include <errno.h>
#include <mach/mach.h>
#elif defined(__linux__)
#include <errno.h>
#endif

namespace w1::inject {

std::string error_code_to_string(error_code code) {
  switch (code) {
  case error_code::success:
    return "success";
  case error_code::target_not_found:
    return "target process not found";
  case error_code::multiple_targets_found:
    return "multiple target processes found";
  case error_code::target_access_denied:
    return "access denied to target process";
  case error_code::target_invalid_architecture:
    return "target process has incompatible architecture";
  case error_code::library_not_found:
    return "library file not found";
  case error_code::library_invalid:
    return "library file is invalid";
  case error_code::library_incompatible:
    return "library is incompatible with target process";
  case error_code::injection_failed:
    return "injection operation failed";
  case error_code::injection_timeout:
    return "injection operation timed out";
  case error_code::injection_already_loaded:
    return "library is already loaded in target process";
  case error_code::platform_not_supported:
    return "platform not supported";
  case error_code::technique_not_supported:
    return "injection technique not supported";
  case error_code::insufficient_privileges:
    return "insufficient privileges for injection";
  case error_code::out_of_memory:
    return "out of memory";
  case error_code::system_error:
    return "system error";
  case error_code::configuration_invalid:
    return "invalid configuration";
  case error_code::launch_failed:
    return "failed to launch process";
  case error_code::launch_timeout:
    return "process launch timed out";
  case error_code::unknown_error:
  default:
    return "unknown error";
  }
}

error_code translate_platform_error(int platform_error) {
#ifdef _WIN32
  switch (platform_error) {
  case ERROR_ACCESS_DENIED:
    return error_code::target_access_denied;
  case ERROR_FILE_NOT_FOUND:
  case ERROR_PATH_NOT_FOUND:
    return error_code::library_not_found;
  case ERROR_INVALID_HANDLE:
    return error_code::target_not_found;
  case ERROR_NOT_ENOUGH_MEMORY:
  case ERROR_OUTOFMEMORY:
    return error_code::out_of_memory;
  case ERROR_INVALID_PARAMETER:
    return error_code::configuration_invalid;
  case ERROR_TIMEOUT:
    return error_code::injection_timeout;
  default:
    return error_code::system_error;
  }
#elif defined(__APPLE__)
  switch (platform_error) {
  case KERN_PROTECTION_FAILURE:
    return error_code::target_access_denied;
  case KERN_INVALID_ARGUMENT:
    return error_code::configuration_invalid;
  case KERN_NO_SPACE:
  case KERN_RESOURCE_SHORTAGE:
    return error_code::out_of_memory;
  case KERN_FAILURE:
    return error_code::injection_failed;
  default:
    // also check errno for posix errors
    switch (errno) {
    case EACCES:
    case EPERM:
      return error_code::target_access_denied;
    case ENOENT:
      return error_code::library_not_found;
    case ESRCH:
      return error_code::target_not_found;
    case ENOMEM:
      return error_code::out_of_memory;
    case ETIMEDOUT:
      return error_code::injection_timeout;
    default:
      return error_code::system_error;
    }
  }
#elif defined(__linux__)
  switch (platform_error) {
  case EACCES:
  case EPERM:
    return error_code::target_access_denied;
  case ENOENT:
    return error_code::library_not_found;
  case ESRCH:
    return error_code::target_not_found;
  case ENOMEM:
    return error_code::out_of_memory;
  case EINVAL:
    return error_code::configuration_invalid;
  case ETIMEDOUT:
    return error_code::injection_timeout;
  default:
    return error_code::system_error;
  }
#endif
  return error_code::system_error;
}

bool is_recoverable_error(error_code code) {
  switch (code) {
  case error_code::injection_timeout:
  case error_code::target_not_found:
  case error_code::multiple_targets_found:
  case error_code::library_not_found:
  case error_code::injection_already_loaded:
    return true;
  default:
    return false;
  }
}

std::string format_error_message(error_code code, const std::string& context) {
  std::string base_message = error_code_to_string(code);

  switch (code) {
  case error_code::insufficient_privileges:
#ifdef _WIN32
    return base_message + ". try running as administrator";
#else
    return base_message + ". try running as root or with appropriate capabilities";
#endif
  case error_code::multiple_targets_found:
    return base_message + ". use find_processes() to list all matches and select specific pid";
  case error_code::target_access_denied:
#ifdef __APPLE__
    return base_message + ". check code signing entitlements and sip status";
#else
    return base_message + ". check process permissions and ptrace scope";
#endif
  case error_code::platform_not_supported:
    return base_message + ". this platform is not yet supported by w1nj3ct";
  case error_code::technique_not_supported:
#ifdef _WIN32
    return base_message + ". try a different windows_technique";
#else
    return base_message + ". preload injection not supported on this platform";
#endif
  default:
    break;
  }

  return base_message + (context.empty() ? "" : " (" + context + ")");
}

result make_error_result(error_code code, const std::string& context, int platform_error) {
  result res;
  res.code = code;
  res.error_message = format_error_message(code, context);
  if (platform_error != 0) {
    res.system_error_code = platform_error;
  }
  return res;
}

result make_success_result(int target_pid) {
  result res;
  res.code = error_code::success;
  res.target_pid = target_pid;
  return res;
}

} // namespace w1::inject
```

`src/w1nj3ct/error.hpp`:

```hpp
#pragma once

#include "w1nj3ct.hpp"
#include <string>

#ifdef _WIN32
#include <w1base/windows_clean.hpp>
#endif

namespace w1::inject {
// error code to string conversion
std::string error_code_to_string(error_code code);

// platform-specific error translation
error_code translate_platform_error(int platform_error);

#ifdef _WIN32
std::string translate_platform_error(DWORD error_code);
#endif

// recoverable vs non-recoverable error classification
bool is_recoverable_error(error_code code);

// detailed error message formatting with context
std::string format_error_message(error_code code, const std::string& context = "");

// create result with platform error translation
result make_error_result(error_code code, const std::string& context = "", int platform_error = 0);

// helper for creating success result
result make_success_result(int target_pid = -1);
} // namespace w1::inject
```

`src/w1nj3ct/platform/darwin/darwin_injector.cpp`:

```cpp
#include "darwin_injector.hpp"
#include "error.hpp"
#include <chrono>
#include <redlog.hpp>

// include the darwin injection backend
extern "C" {
#include "impl/injector.h"
}

#include <crt_externs.h>
#include <cstdlib>
#include <iostream>
#include <libproc.h>
#include <signal.h>
#include <spawn.h>
#include <sys/sysctl.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#ifndef _POSIX_SPAWN_DISABLE_ASLR
#define _POSIX_SPAWN_DISABLE_ASLR 0x100
#endif

#ifndef POSIX_SPAWN_START_SUSPENDED
#define POSIX_SPAWN_START_SUSPENDED 0x0080
#endif

namespace w1::inject::darwin {

result inject_runtime(const config& cfg) {
  auto log = redlog::get_logger("w1nj3ct.darwin");

  log.info("darwin runtime injection starting", redlog::field("library_path", cfg.library_path));

  // validate we have a target
  if (!cfg.pid && !cfg.process_name) {
    log.error("no target specified for runtime injection");
    return make_error_result(error_code::configuration_invalid, "no target specified");
  }

  int target_pid = -1;

  // resolve process name to pid if needed
  if (cfg.process_name) {
    log.debug("resolving process name to pid", redlog::field("name", *cfg.process_name));

    auto processes = find_processes_by_name(*cfg.process_name);
    if (processes.empty()) {
      log.error("no processes found with specified name", redlog::field("name", *cfg.process_name));
      return make_error_result(error_code::target_not_found, *cfg.process_name);
    }
    if (processes.size() > 1) {
      log.error(
          "multiple processes found with specified name", redlog::field("name", *cfg.process_name),
          redlog::field("count", processes.size())
      );
      for (const auto& proc : processes) {
        log.verbose(
            "found process", redlog::field("pid", proc.pid), redlog::field("name", proc.name),
            redlog::field("path", proc.full_path)
        );
      }
      return make_error_result(error_code::multiple_targets_found, *cfg.process_name);
    }
    target_pid = processes[0].pid;
    log.info(
        "resolved process name to pid", redlog::field("name", *cfg.process_name), redlog::field("pid", target_pid),
        redlog::field("path", processes[0].full_path)
    );
  } else {
    target_pid = *cfg.pid;
    log.debug("using specified pid", redlog::field("pid", target_pid));

    // validate target process exists
    auto proc_info = get_process_info(target_pid);
    if (proc_info) {
      log.verbose(
          "target process validated", redlog::field("pid", target_pid), redlog::field("name", proc_info->name),
          redlog::field("path", proc_info->full_path)
      );
    } else {
      log.warn("target process info not available", redlog::field("pid", target_pid));
    }
  }

  // use existing injector backend
  auto attach_start = std::chrono::steady_clock::now();
  log.debug("attaching to target process", redlog::field("pid", target_pid));

  injector_t* injector = nullptr;
  int err = injector_attach(&injector, target_pid);
  if (err != INJERR_SUCCESS) {
    error_code mapped_error;
    std::string error_detail = injector_error();

    switch (err) {
    case INJERR_NO_PROCESS:
      mapped_error = error_code::target_not_found;
      log.error(
          "target process not found during attach", redlog::field("pid", target_pid),
          redlog::field("injector_error", error_detail), redlog::field("error_code", err)
      );
      break;
    case INJERR_PERMISSION:
      mapped_error = error_code::target_access_denied;
      log.error(
          "permission denied attaching to target process", redlog::field("pid", target_pid),
          redlog::field("injector_error", error_detail), redlog::field("error_code", err),
          redlog::field("uid", getuid()), redlog::field("euid", geteuid())
      );
      break;
    case INJERR_NO_MEMORY:
      mapped_error = error_code::out_of_memory;
      log.error(
          "out of memory during process attach", redlog::field("pid", target_pid),
          redlog::field("injector_error", error_detail), redlog::field("error_code", err)
      );
      break;
    default:
      mapped_error = error_code::injection_failed;
      log.error(
          "unknown error during process attach", redlog::field("pid", target_pid),
          redlog::field("injector_error", error_detail), redlog::field("error_code", err)
      );
      break;
    }
    return make_error_result(mapped_error, error_detail, err);
  }

  auto attach_duration = std::chrono::steady_clock::now() - attach_start;
  auto attach_ms = std::chrono::duration_cast<std::chrono::milliseconds>(attach_duration).count();

  log.info(
      "successfully attached to target process", redlog::field("pid", target_pid),
      redlog::field("attach_time_ms", attach_ms)
  );

  // inject the library
  auto inject_start = std::chrono::steady_clock::now();
  log.debug(
      "injecting library into target process", redlog::field("pid", target_pid),
      redlog::field("library_path", cfg.library_path)
  );

  void* handle = nullptr;
  err = injector_inject(injector, cfg.library_path.c_str(), &handle);

  // cleanup injector regardless of result
  injector_detach(injector);
  log.trace("detached from target process", redlog::field("pid", target_pid));

  if (err != INJERR_SUCCESS) {
    error_code mapped_error;
    std::string error_detail = injector_error();

    switch (err) {
    case INJERR_FILE_NOT_FOUND:
      mapped_error = error_code::library_not_found;
      log.error(
          "library file not found during injection", redlog::field("pid", target_pid),
          redlog::field("library_path", cfg.library_path), redlog::field("injector_error", error_detail),
          redlog::field("error_code", err)
      );
      break;
    case INJERR_NO_MEMORY:
      mapped_error = error_code::out_of_memory;
      log.error(
          "out of memory during library injection", redlog::field("pid", target_pid),
          redlog::field("library_path", cfg.library_path), redlog::field("injector_error", error_detail),
          redlog::field("error_code", err)
      );
      break;
    case INJERR_ERROR_IN_TARGET:
      mapped_error = error_code::injection_failed;
      log.error(
          "error in target process during injection", redlog::field("pid", target_pid),
          redlog::field("library_path", cfg.library_path), redlog::field("injector_error", error_detail),
          redlog::field("error_code", err)
      );
      break;
    case INJERR_PERMISSION:
      mapped_error = error_code::target_access_denied;
      log.error(
          "permission denied during library injection", redlog::field("pid", target_pid),
          redlog::field("library_path", cfg.library_path), redlog::field("injector_error", error_detail),
          redlog::field("error_code", err)
      );
      break;
    case INJERR_UNSUPPORTED_TARGET:
      mapped_error = error_code::target_invalid_architecture;
      log.error(
          "unsupported target architecture", redlog::field("pid", target_pid),
          redlog::field("library_path", cfg.library_path), redlog::field("injector_error", error_detail),
          redlog::field("error_code", err)
      );
      break;
    default:
      mapped_error = error_code::injection_failed;
      log.error(
          "unknown error during library injection", redlog::field("pid", target_pid),
          redlog::field("library_path", cfg.library_path), redlog::field("injector_error", error_detail),
          redlog::field("error_code", err)
      );
      break;
    }
    return make_error_result(mapped_error, error_detail, err);
  }

  auto inject_duration = std::chrono::steady_clock::now() - inject_start;
  auto inject_ms = std::chrono::duration_cast<std::chrono::milliseconds>(inject_duration).count();
  auto total_ms =
      std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - attach_start).count();

  log.info(
      "runtime injection completed successfully", redlog::field("pid", target_pid),
      redlog::field("library_path", cfg.library_path), redlog::field("handle", handle),
      redlog::field("inject_time_ms", inject_ms), redlog::field("total_time_ms", total_ms)
  );

  return make_success_result(target_pid);
}

result inject_preload(const config& cfg) {
  auto log = redlog::get_logger("w1nj3ct.darwin");

  log.info(
      "darwin preload injection starting", redlog::field("binary_path", cfg.binary_path ? *cfg.binary_path : "null"),
      redlog::field("library_path", cfg.library_path), redlog::field("disable_aslr", cfg.disable_aslr)
  );

  if (!cfg.binary_path) {
    log.error("binary_path required for preload injection");
    return make_error_result(error_code::configuration_invalid, "binary_path required for preload injection");
  }

  // validate binary exists and is executable
  if (access(cfg.binary_path->c_str(), F_OK) != 0) {
    log.error("target binary not found", redlog::field("binary_path", *cfg.binary_path), redlog::field("errno", errno));
    return make_error_result(error_code::target_not_found, "binary not found: " + *cfg.binary_path);
  }

  if (access(cfg.binary_path->c_str(), X_OK) != 0) {
    log.error(
        "target binary not executable", redlog::field("binary_path", *cfg.binary_path), redlog::field("errno", errno)
    );
    return make_error_result(error_code::target_access_denied, "binary not executable: " + *cfg.binary_path);
  }

  log.debug("target binary validated", redlog::field("binary_path", *cfg.binary_path));

  // set up environment with DYLD_INSERT_LIBRARIES
  log.debug("setting up injection environment");

  // start with current environment
  std::map<std::string, std::string> env;
  char*** environ_ptr = _NSGetEnviron();
  size_t base_env_count = 0;

  if (environ_ptr && *environ_ptr) {
    for (char** ep = *environ_ptr; *ep; ep++) {
      std::string env_var(*ep);
      size_t eq_pos = env_var.find('=');
      if (eq_pos != std::string::npos) {
        std::string key = env_var.substr(0, eq_pos);
        std::string value = env_var.substr(eq_pos + 1);
        env[key] = value;
        base_env_count++;
      }
    }
  }

  log.trace("inherited environment variables", redlog::field("count", base_env_count));

  // add/override with cfg.env_vars
  for (const auto& [key, value] : cfg.env_vars) {
    env[key] = value;
    log.verbose("adding environment variable", redlog::field("key", key), redlog::field("value", value));
  }

  // add DYLD_INSERT_LIBRARIES
  env["DYLD_INSERT_LIBRARIES"] = cfg.library_path;
  log.info("configured DYLD_INSERT_LIBRARIES", redlog::field("library_path", cfg.library_path));

  // warn about potential SIP issues
  if (cfg.binary_path->find("/System/") == 0 || cfg.binary_path->find("/usr/bin/") == 0 ||
      cfg.binary_path->find("/bin/") == 0) {
    log.warn("injecting into system binary may fail due to SIP", redlog::field("binary_path", *cfg.binary_path));
  }

  // build command line
  std::vector<const char*> argv;
  argv.push_back(cfg.binary_path->c_str());
  for (const auto& arg : cfg.args) {
    argv.push_back(arg.c_str());
    log.trace("adding command argument", redlog::field("arg", arg));
  }
  argv.push_back(nullptr);

  log.debug("command line prepared", redlog::field("argc", argv.size() - 1));

  // build environment
  std::vector<std::string> env_strings;
  std::vector<const char*> envp;

  // first pass: populate all strings to avoid reallocation
  env_strings.reserve(env.size());
  for (const auto& [key, value] : env) {
    env_strings.push_back(key + "=" + value);
  }

  // second pass: collect pointers after all strings are in place
  envp.reserve(env.size() + 1);
  for (const auto& env_str : env_strings) {
    envp.push_back(env_str.c_str());
  }
  envp.push_back(nullptr);

  log.debug("environment prepared", redlog::field("vars", env.size()), redlog::field("total_vars", envp.size() - 1));

  // initialize spawn attributes
  posix_spawnattr_t attrs;
  int ret = posix_spawnattr_init(&attrs);
  if (ret != 0) {
    log.error("posix_spawnattr_init failed", redlog::field("error", strerror(ret)));
    return make_error_result(error_code::launch_failed, "posix_spawnattr_init failed", ret);
  }

  // build flags based on configuration
  short ps_flags = 0;
  if (cfg.disable_aslr) {
    ps_flags |= _POSIX_SPAWN_DISABLE_ASLR;
    log.debug("ASLR will be disabled for spawned process");
  }
  if (cfg.suspended) {
    ps_flags |= POSIX_SPAWN_START_SUSPENDED;
    log.debug("process will be spawned in suspended state");
  }

  // set flags if any
  if (ps_flags != 0) {
    ret = posix_spawnattr_setflags(&attrs, ps_flags);
    if (ret != 0) {
      posix_spawnattr_destroy(&attrs);
      log.error("posix_spawnattr_setflags failed", redlog::field("error", strerror(ret)));
      return make_error_result(error_code::launch_failed, "posix_spawnattr_setflags failed", ret);
    }
  }

  // spawn the process
  pid_t child_pid;
  log.debug("spawning process with posix_spawn", redlog::field("binary_path", *cfg.binary_path));

  ret = posix_spawn(
      &child_pid, cfg.binary_path->c_str(), NULL, &attrs, const_cast<char**>(argv.data()),
      const_cast<char**>(envp.data())
  );

  // clean up spawn attributes
  posix_spawnattr_destroy(&attrs);

  // check if spawn succeeded
  if (ret != 0) {
    log.error(
        "posix_spawn failed", redlog::field("binary_path", *cfg.binary_path), redlog::field("error", strerror(ret)),
        redlog::field("errno", ret)
    );
    return make_error_result(error_code::launch_failed, "posix_spawn failed: " + std::string(strerror(ret)), ret);
  }

  log.info(
      "preload injection started successfully", redlog::field("pid", child_pid),
      redlog::field("binary_path", *cfg.binary_path), redlog::field("library_path", cfg.library_path)
  );

  // handle suspended launch
  if (cfg.suspended) {
    log.info("process spawned in suspended state", redlog::field("pid", child_pid));

    // output to console for user interaction
    std::cout << "Process created and suspended (PID: " << child_pid << ")" << std::endl;
    std::cout << "Binary: " << *cfg.binary_path << std::endl;
    std::cout << "Library: " << cfg.library_path << std::endl;
    std::cout << "Attach debugger and press Enter to resume process..." << std::endl;
    std::cin.get();

    // resume child process
    log.info("resuming child process", redlog::field("pid", child_pid));
    if (kill(child_pid, SIGCONT) == -1) {
      int kill_errno = errno;
      log.error(
          "failed to resume child process", redlog::field("pid", child_pid), redlog::field("errno", kill_errno),
          redlog::field("error", strerror(kill_errno))
      );
      // kill the suspended process to avoid leaving it hanging
      kill(child_pid, SIGKILL);
      return make_error_result(error_code::launch_failed, "failed to resume suspended process", kill_errno);
    }
    log.debug("child process resumed successfully");
  }

  // handle wait for completion
  if (cfg.wait_for_completion) {
    log.debug("waiting for child process to complete", redlog::field("pid", child_pid));

    int status;
    pid_t wait_result = waitpid(child_pid, &status, 0);

    if (wait_result == -1) {
      int wait_errno = errno;
      log.error(
          "failed to wait for child process", redlog::field("pid", child_pid), redlog::field("errno", wait_errno),
          redlog::field("error", strerror(wait_errno))
      );
      return make_error_result(error_code::launch_failed, "waitpid failed", wait_errno);
    }

    if (WIFEXITED(status)) {
      int exit_code = WEXITSTATUS(status);
      log.info(
          "preload injection completed, child process exited", redlog::field("pid", child_pid),
          redlog::field("exit_code", exit_code)
      );

      // injection was successful regardless of target exit code
      auto result = make_success_result(child_pid);
      result.target_exit_code = exit_code;
      return result;
    } else if (WIFSIGNALED(status)) {
      int signal = WTERMSIG(status);
      log.error(
          "child process terminated by signal", redlog::field("pid", child_pid), redlog::field("signal", signal),
          redlog::field("signal_name", strsignal(signal))
      );
      return make_error_result(
          error_code::launch_failed, "child process terminated by signal " + std::to_string(signal)
      );
    } else {
      log.error(
          "child process exited with unknown status", redlog::field("pid", child_pid), redlog::field("status", status)
      );
      return make_error_result(error_code::launch_failed, "child process exited with unknown status");
    }
  } else {
    log.info("preload injection started successfully, not waiting for completion", redlog::field("pid", child_pid));
    return make_success_result(child_pid);
  }
}

std::vector<process_info> list_processes() {
  auto log = redlog::get_logger("w1nj3ct.darwin");
  std::vector<process_info> processes;

  log.trace("listing all processes");

  // get process count
  int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0};
  size_t size = 0;
  if (sysctl(mib, 4, nullptr, &size, nullptr, 0) != 0) {
    log.error("failed to get process list size", redlog::field("errno", errno));
    return processes;
  }

  // get process list
  size_t count = size / sizeof(struct kinfo_proc);
  log.debug("retrieving process list", redlog::field("estimated", count));

  std::vector<struct kinfo_proc> procs(count);
  if (sysctl(mib, 4, procs.data(), &size, nullptr, 0) != 0) {
    log.error("failed to retrieve process list", redlog::field("errno", errno));
    return processes;
  }

  // convert to our format
  size_t path_failures = 0;
  for (const auto& proc : procs) {
    process_info info;
    info.pid = proc.kp_proc.p_pid;
    info.name = proc.kp_proc.p_comm;

    // get full path using libproc
    char pathbuf[PROC_PIDPATHINFO_MAXSIZE];
    if (proc_pidpath(info.pid, pathbuf, sizeof(pathbuf)) > 0) {
      info.full_path = pathbuf;
    } else {
      path_failures++;
    }

    processes.push_back(info);
  }

  log.debug(
      "process list retrieved", redlog::field("total_processes", processes.size()),
      redlog::field("path_lookup_failures", path_failures)
  );

  return processes;
}

std::vector<process_info> find_processes_by_name(const std::string& name) {
  auto log = redlog::get_logger("w1nj3ct.darwin");

  log.debug("searching for processes by name", redlog::field("target_name", name));

  std::vector<process_info> matches;
  auto all_processes = list_processes();

  for (const auto& proc : all_processes) {
    if (proc.name == name) {
      matches.push_back(proc);
      log.verbose(
          "found matching process", redlog::field("pid", proc.pid), redlog::field("name", proc.name),
          redlog::field("path", proc.full_path)
      );
    }
  }

  log.debug(
      "process search completed", redlog::field("target_name", name), redlog::field("matches_found", matches.size()),
      redlog::field("total_searched", all_processes.size())
  );

  return matches;
}

std::optional<process_info> get_process_info(int pid) {
  auto log = redlog::get_logger("w1nj3ct.darwin");

  log.trace("looking up process info", redlog::field("pid", pid));

  auto all_processes = list_processes();

  for (const auto& proc : all_processes) {
    if (proc.pid == pid) {
      log.trace(
          "found process info", redlog::field("pid", proc.pid), redlog::field("name", proc.name),
          redlog::field("path", proc.full_path)
      );
      return proc;
    }
  }

  log.debug("process not found", redlog::field("pid", pid), redlog::field("searched", all_processes.size()));

  return std::nullopt;
}

bool check_injection_capabilities() {
  auto log = redlog::get_logger("w1nj3ct.darwin");

  log.debug("checking darwin injection capabilities");

  // try to create a test injector to check permissions
  injector_t* injector = nullptr;
  int current_pid = getpid();

  log.trace("attempting self-injection test", redlog::field("pid", current_pid));

  int err = injector_attach(&injector, current_pid);

  if (err == INJERR_SUCCESS) {
    injector_detach(injector);
    log.debug("injection capabilities verified, self-attach successful");
    return true;
  } else {
    log.warn(
        "injection capabilities limited, self-attach failed", redlog::field("error_code", err),
        redlog::field("injector_error", injector_error()), redlog::field("uid", getuid()),
        redlog::field("euid", geteuid())
    );
    return false;
  }
}

} // namespace w1::inject::darwin
```

`src/w1nj3ct/platform/darwin/darwin_injector.hpp`:

```hpp
#pragma once

#include "w1nj3ct.hpp"

namespace w1::inject::darwin {
// wrapper around the existing darwin_inject backend
result inject_runtime(const config& cfg);
result inject_preload(const config& cfg);

// process discovery using existing backend
std::vector<process_info> list_processes();
std::vector<process_info> find_processes_by_name(const std::string& name);
std::optional<process_info> get_process_info(int pid);

// capabilities check
bool check_injection_capabilities();
} // namespace w1::inject::darwin
```

`src/w1nj3ct/platform/darwin/impl/exc_handler.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2022 TheOiseth
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "injector_internal.h"
#include <mach/exception_types.h>
#include <sys/types.h>
#include <sys/ptrace.h>
#include <signal.h>
#include <stdbool.h>
#define HANDLE_EXC                                                                                                     \
  EXC_MASK_BAD_ACCESS | EXC_MASK_BAD_INSTRUCTION | EXC_MASK_SOFTWARE | EXC_MASK_BREAKPOINT | EXC_MASK_CRASH |          \
      EXC_MASK_CORPSE_NOTIFY
boolean_t mach_exc_server(mach_msg_header_t* InHeadP, mach_msg_header_t* OutHeadP);
int injector__create_exc_handler(injector_t* injector) {
  mach_port_name_t exc_port = 0;
  mach_msg_type_number_t exception_types_count;
  int rv;
  injector->exc_port = 0;
  injector->saved_exception_types_count = 0;
  rv = task_get_exception_ports(
      injector->remote_task, EXC_MASK_ALL, injector->saved_masks, &exception_types_count, injector->saved_ports,
      injector->saved_behaviors, injector->saved_flavors
  );

  injector->saved_exception_types_count = exception_types_count;
  if (rv != 0) {
    injector__set_errmsg("%s error : %s", "EXC_GET_PORTS", mach_error_string(rv));
    return INJERR_OTHER;
  }

  rv = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &exc_port);
  injector->exc_port = exc_port;
  if (rv != 0) {
    injector__set_errmsg("%s error : %s", "EXC_PORT_ALLOCATE", mach_error_string(rv));
    rv = INJERR_OTHER;
    goto cleanup;
  }
  rv = mach_port_insert_right(mach_task_self(), exc_port, exc_port, MACH_MSG_TYPE_MAKE_SEND);
  if (rv != 0) {
    injector__set_errmsg("%s error : %s", "EXC_INSERT_RIGHTS", mach_error_string(rv));
    rv = INJERR_OTHER;
    goto cleanup;
  }

  rv = task_set_exception_ports(
      injector->remote_task, HANDLE_EXC, exc_port, EXCEPTION_DEFAULT | MACH_EXCEPTION_CODES, THREAD_STATE_NONE
  );
  if (rv != 0) {
    injector__set_errmsg("%s error : %s", "EXC_SET_PORTS", mach_error_string(rv));
    rv = INJERR_OTHER;
    goto cleanup;
  }

  return 0;
cleanup:
  injector__release_exc_handler(injector);
  return rv;
}
int injector__handle_exc(injector_t* injector) {
  char req[128], rpl[128];
  mach_msg_header_with_injector* mmhwi;
  int rv;

  mmhwi = (mach_msg_header_with_injector*) req;
  mmhwi->injector = injector;
  rv = mach_msg(
      (mach_msg_header_t*) req, MACH_RCV_MSG, 0, sizeof(req), injector->exc_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL
  );
  if (rv != KERN_SUCCESS) {
    injector__set_errmsg("%s error : %s", "EXC_RECV_MACH_MSG", mach_error_string(rv));
    return INJERR_OTHER;
  }
  /* suspend all threads in the process after an exception was received */

  task_suspend(injector->remote_task);

  boolean_t message_parsed_correctly = mach_exc_server((mach_msg_header_t*) req, (mach_msg_header_t*) rpl);
  if (!message_parsed_correctly) {

    size_t parse_exc = ((mig_reply_error_t*) rpl)->RetCode;
    if (parse_exc != 0) {
      injector__set_errmsg("%s error : %s", "mach_exc_server", mach_error_string(parse_exc));
    }
  }
  task_resume(injector->remote_task);
  mach_msg_size_t send_sz = ((mach_msg_header_t*) rpl)->msgh_size;

  rv = mach_msg(
      (mach_msg_header_t*) rpl, MACH_SEND_MSG, send_sz, 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL
  );
  if (rv != KERN_SUCCESS) {
    injector__set_errmsg("%s error : %s", "EXC_SEND_MACH_MSG", mach_error_string(rv));
    return INJERR_OTHER;
  }
  return 0;
}

__attribute__((no_sanitize("alignment"))) static bool isSIGSTOP(
    exception_type_t exception_type, mach_exception_data_t codes
) {
  return exception_type == EXC_SOFTWARE && codes[0] == EXC_SOFT_SIGNAL && codes[1] == SIGSTOP;
}

kern_return_t catch_mach_exception_raise(
    mach_port_t exception_port, mach_port_t thread_port, mach_port_t task_port, exception_type_t exception_type,
    mach_exception_data_t codes, mach_msg_type_number_t num_codes, injector_t* injector
) {
  injector->handle_err = 0;
  bool bad_exc = true;
  int rv;
  switch (injector->handle_action) {
  case STOP_CONTINUE:
    if (isSIGSTOP(exception_type, codes)) {
      bad_exc = false;
      injector__ptrace_update(injector, thread_port);
    }
    break;
  case STOP_DETACH:
    if (isSIGSTOP(exception_type, codes)) {
      bad_exc = false;
      injector__ptrace_detach(injector);
    }
    break;
  case TRAP_GETREGS:
    if (exception_type == EXC_BREAKPOINT) {
      bad_exc = false;
#if defined(__arm64__) || defined(__aarch64__)
      mach_msg_type_number_t thread_state_count = ARM_THREAD_STATE64_COUNT;
      arm_thread_state64_t state;
      rv = thread_get_state(thread_port, ARM_THREAD_STATE64, (thread_state_t) &state, &thread_state_count);
      if (rv == KERN_SUCCESS) {
        injector->retval = state.__x[0];
      } else {
        injector__set_errmsg("%s error : %s", "GET_THREAD_STATE", mach_error_string(rv));
        injector->handle_err = INJERR_ERROR_IN_TARGET;
      }
#else
      mach_msg_type_number_t thread_state_count = x86_THREAD_STATE64_COUNT;
      x86_thread_state64_t state;
      rv = thread_get_state(thread_port, x86_THREAD_STATE64, (thread_state_t) &state, &thread_state_count);
      if (rv == KERN_SUCCESS) {
        injector->retval = state.__rax;
      } else {
        injector__set_errmsg("%s error : %s", "GET_THREAD_STATE", mach_error_string(rv));
        injector->handle_err = INJERR_ERROR_IN_TARGET;
      }
#endif
      if (injector->mach_thread != 0) {
        rv = thread_terminate(injector->mach_thread);
        injector->mach_thread = 0;
      }
      rv = thread_suspend(thread_port);
      if (rv != KERN_SUCCESS) {
        injector__set_errmsg("%s error : %s", "THREAD_SUSPEND", mach_error_string(rv));
        injector->handle_err = INJERR_ERROR_IN_TARGET;
      }
      // we don't need to continue since we already called task_resume and mach_msg later
      // rv = injector__ptrace_continue(injector);
    }
    break;
  case TRAP_SETREGS:
    if (exception_type == EXC_BREAKPOINT) {
      bad_exc = false;
      bool thread_init = false;
      if (thread_port != injector->mach_thread) {
        thread_init = injector->remote_thread == 0;
        injector->remote_thread = thread_port;
      }
#if defined(__arm64__) || defined(__aarch64__)
      mach_msg_type_number_t thread_state_count = ARM_THREAD_STATE64_COUNT;
      arm_thread_state64_t state;
      rv = thread_get_state(thread_port, ARM_THREAD_STATE64, (thread_state_t) &state, &thread_state_count);
      if (rv != KERN_SUCCESS) {
        injector__set_errmsg("%s error : %s", "GET_THREAD_STATE", mach_error_string(rv));
        injector->handle_err = INJERR_ERROR_IN_TARGET;
        goto exit;
      }
      if (thread_init) {
        memcpy(&injector->remote_thread_saved_state, &state, sizeof(state));
        injector->state_saved = 1;
      }
      state.__x[0] = injector->arg1;
      state.__x[1] = injector->arg2;
      state.__x[2] = injector->arg3;
      state.__x[3] = injector->arg4;
      state.__x[4] = injector->arg5;
      state.__x[5] = injector->arg6;
      state.__x[8] = injector->func_addr;
      state.__sp = injector->stack;
      state.__pc = injector->code2_addr + 4;
      rv = thread_set_state(thread_port, ARM_THREAD_STATE64, (thread_state_t) &state, ARM_THREAD_STATE64_COUNT);
      if (rv != KERN_SUCCESS) {
        injector__set_errmsg("%s error : %s", "SET_THREAD_STATE", mach_error_string(rv));
        injector->handle_err = INJERR_ERROR_IN_TARGET;
      }
#else
      mach_msg_type_number_t thread_state_count = x86_THREAD_STATE64_COUNT;
      x86_thread_state64_t state;

      rv = thread_get_state(thread_port, x86_THREAD_STATE64, (thread_state_t) &state, &thread_state_count);
      if (rv != KERN_SUCCESS) {
        injector__set_errmsg("%s error : %s", "GET_THREAD_STATE", mach_error_string(rv));
        injector->handle_err = INJERR_ERROR_IN_TARGET;
        goto exit;
      }
      if (thread_init) {
        memcpy(&injector->remote_thread_saved_state, &state, sizeof(state));
        injector->state_saved = 1;
      }
      state.__rax = injector->func_addr;
      state.__rdi = injector->arg1;
      state.__rsi = injector->arg2;
      state.__rdx = injector->arg3;
      state.__rcx = injector->arg4;
      state.__r8 = injector->arg5;
      state.__r9 = injector->arg6;
      state.__rsp = injector->stack;
      state.__rbp = injector->stack;
      rv = thread_set_state(thread_port, x86_THREAD_STATE64, (thread_state_t) &state, x86_THREAD_STATE64_COUNT);
      if (rv != KERN_SUCCESS) {
        injector__set_errmsg("%s error : %s", "SET_THREAD_STATE", mach_error_string(rv));
        injector->handle_err = INJERR_ERROR_IN_TARGET;
      }
#endif
      // we don't need to continue since we already called task_resume and mach_msg later
      // rv = injector__ptrace_continue(injector);
    }
    break;
  }

  if (bad_exc) {
    if (exception_type == EXC_SOFTWARE) {
      injector__set_errmsg("The target process got an unexpected signal %i.", codes[1]);
    } else {
      injector__set_errmsg("Got unhandled exception %i.", exception_type);
    }
    injector->handle_err = INJERR_OTHER;
  }
exit:
  return KERN_SUCCESS;
}

kern_return_t catch_mach_exception_raise_state(
    mach_port_t exception_port, exception_type_t exception, const mach_exception_data_t code,
    mach_msg_type_number_t codeCnt, int* flavor, const thread_state_t old_state, mach_msg_type_number_t old_stateCnt,
    thread_state_t new_state, mach_msg_type_number_t* new_stateCnt
) {
  return MACH_RCV_INVALID_TYPE;
}

kern_return_t catch_mach_exception_raise_state_identity(
    mach_port_t exception_port, mach_port_t thread, mach_port_t task, exception_type_t exception,
    mach_exception_data_t code, mach_msg_type_number_t codeCnt, int* flavor, thread_state_t old_state,
    mach_msg_type_number_t old_stateCnt, thread_state_t new_state, mach_msg_type_number_t* new_stateCnt
) {
  return MACH_RCV_INVALID_TYPE;
}

int injector__release_exc_handler(injector_t* injector) {
  for (int i = 0; i < injector->saved_exception_types_count; i++) {
    task_set_exception_ports(
        injector->remote_task, injector->saved_masks[i], injector->saved_ports[i], injector->saved_behaviors[i],
        injector->saved_flavors[i]
    );
  }
  injector->saved_exception_types_count = 0;
  if (injector->exc_port != 0) {
    mach_port_deallocate(mach_task_self(), injector->exc_port);
    injector->exc_port = 0;
  }
  return 0;
}
```

`src/w1nj3ct/platform/darwin/impl/injector.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2022 TheOiseth
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "injector_internal.h"
#include <stdlib.h>
#include <unistd.h>
#include <dlfcn.h>
#include <sys/syslimits.h>
#include <signal.h>

#define STACK_SIZE 2 * 1024 * 1024
#define CODE_SIZE 512
int injector_attach(injector_t** injector_out, pid_t pid) {
  injector_t* injector;
  arch_t self_arch, target_arch;
  int rv = 0;

  injector__errmsg_is_set = 0;

  injector = calloc(1, sizeof(injector_t));
  if (injector == NULL) {
    injector__set_errmsg("malloc error: %s", strerror(errno));
    return INJERR_NO_MEMORY;
  }
  injector->pid = pid;
  rv = injector__get_process_arch(getpid(), &self_arch);
  if (rv != 0) {
    goto error_exit;
  }
  rv = injector__get_process_arch(pid, &target_arch);
  if (rv != 0) {
    goto error_exit;
  }
  arch_t sys_arch = injector__get_system_arch();

  if (self_arch != ARCH_UNKNOWN && target_arch != ARCH_UNKNOWN) {
    if (self_arch != target_arch) {
      injector__set_errmsg(
          "%s target process isn't supported by %s process.", injector__arch2name(target_arch),
          injector__arch2name(self_arch)
      );
      rv = INJERR_UNSUPPORTED_TARGET;
      goto error_exit;
    }
    if (sys_arch == ARCH_ARM64 && self_arch != ARCH_ARM64) {
      injector__set_errmsg(
          "%s target process isn't supported by %s process on ARM64 machine.", injector__arch2name(target_arch),
          injector__arch2name(self_arch)
      );
      rv = INJERR_UNSUPPORTED_TARGET;
      goto error_exit;
    }
  }

  rv = injector__task_pid(injector);
  if (rv != 0) {
    goto error_exit;
  }
  injector->attached = 1;

  rv = injector__create_exc_handler(injector);

  if (rv != 0) {
    goto error_exit;
  }
  rv = injector__ptrace_attach(injector);
  if (rv != 0) {
    return rv;
  }
  injector->handle_action = STOP_CONTINUE;
  injector->handle_err = 0;
  do {
    injector__handle_exc(injector);
  } while (injector->handle_err != 0);

  injector->ptrace_attached = 1;

  injector->text_size = sysconf(_SC_PAGESIZE);
  injector->stack_size = STACK_SIZE;
  injector->code_size = CODE_SIZE;

  size_t alloc_size = injector->text_size + injector->stack_size;

  mach_vm_address_t addr = (vm_address_t) NULL;
  rv = injector__allocate(injector, &addr, alloc_size, VM_FLAGS_ANYWHERE);
  if (rv != 0) {
    goto error_exit;
  }

  mach_vm_address_t code_addr = (vm_address_t) NULL;
  rv = injector__allocate(injector, &code_addr, CODE_SIZE, VM_FLAGS_ANYWHERE);
  if (rv != 0) {
    goto error_exit;
  }

  injector->allocated = 1;
  injector->text = (size_t) addr;
  injector->stack = injector->text + injector->text_size + injector->stack_size / 2;
  injector->stack &= 0xFFFFFFFFFFFFFFF0; // alignment
  injector->code_addr = (size_t) code_addr;

  rv = injector__protect(injector, addr, alloc_size, FALSE, VM_PROT_READ | VM_PROT_WRITE);
  if (rv != 0) {
    goto error_exit;
  }

  rv = injector__protect(injector, code_addr, CODE_SIZE, FALSE, VM_PROT_READ | VM_PROT_WRITE);
  if (rv != 0) {
    goto error_exit;
  }
  *injector_out = injector;
  return 0;
error_exit:
  injector_detach(injector);
  return rv;
}

int injector_inject(injector_t* injector, const char* path, void** handle) {
  char abspath[PATH_MAX];
  int dlflags = RTLD_LAZY;
  size_t len;
  int rv;
  long retval;
  injector__errmsg_is_set = 0;
  if (realpath(path, abspath) == NULL) {
    injector__set_errmsg("failed to get the full path of '%s': %s", path, strerror(errno));
    return INJERR_FILE_NOT_FOUND;
  }
  len = strlen(abspath) + 1;
  if (len > injector->text_size) {
    injector__set_errmsg("too long file path: %s", path);
    return INJERR_FILE_NOT_FOUND;
  }

  rv = injector__write(injector, injector->text, abspath, len);
  if (rv != 0) {
    return rv;
  }

  rv = injector__call_function(injector, &retval, (long) dlopen, injector->text, dlflags);
  if (rv != 0) {
    return rv;
  }
  if (retval == 0) {
    char buf[256 + 1] = {
        0,
    };
    rv = injector__call_function(injector, &retval, (long) dlerror);
    if (rv == 0 && retval != 0) {
      injector__read(injector, retval, buf, sizeof(buf) - 1);
    }

    if (buf[0] != '\0') {
      injector__set_errmsg("dlopen failed: %s", buf);
    } else {
      injector__set_errmsg("dlopen failed");
    }

    return INJERR_ERROR_IN_TARGET;
  }
  if (handle != NULL) {
    *handle = (void*) retval;
  }
  return 0;
}

int injector_call(injector_t* injector, void* handle, const char* name) {
  int rv;
  long retval;
  size_t len = strlen(name) + 1;

  injector__errmsg_is_set = 0;

  if (len > injector->text_size) {
    injector__set_errmsg("too long function name: %s", name);
    return INJERR_FUNCTION_MISSING;
  }
  rv = injector__write(injector, injector->text, name, len);
  if (rv != 0) {
    return rv;
  }
  rv = injector__call_function(injector, &retval, (long) dlsym, handle, injector->text);
  if (retval == 0) {
    injector__set_errmsg("function not found: %s", name);
    return INJERR_FUNCTION_MISSING;
  }
  return injector__call_function(injector, &retval, retval);
}

int injector_uninject(injector_t* injector, void* handle) {
  int rv;
  long retval;

  injector__errmsg_is_set = 0;

  rv = injector__call_function(injector, &retval, (long) dlclose, handle);
  if (rv != 0) {
    return rv;
  }
  if (retval != 0) {
    injector__set_errmsg("dlclose failed");
    return INJERR_ERROR_IN_TARGET;
  }
  return 0;
}

int injector_detach(injector_t* injector) {
  int rv = 0;
  injector__errmsg_is_set = 0;
  if (injector->remote_thread != 0) {
    // For some reasons on MacOS ARM64 (tested on 12.0.1) thread_terminate() returns unknown error, so let it end by
    // itslef
    if (injector->state_saved) {
#if defined(__arm64__) || defined(__aarch64__)
      injector->remote_thread_saved_state.__pc = injector->code2_addr + 12;
      rv = thread_set_state(
          injector->remote_thread, ARM_THREAD_STATE64, (thread_state_t) &injector->remote_thread_saved_state,
          ARM_THREAD_STATE64_COUNT
      );
      if (rv != KERN_SUCCESS) {
        injector__set_errmsg("%s error : %s", "GET_THREAD_STATE", mach_error_string(rv));
        rv = INJERR_ERROR_IN_TARGET;
      }
#else
      injector->remote_thread_saved_state.__rip = injector->code2_addr + 4;
      rv = thread_set_state(
          injector->remote_thread, x86_THREAD_STATE64, (thread_state_t) &injector->remote_thread_saved_state,
          x86_THREAD_STATE64_COUNT
      );
      if (rv != KERN_SUCCESS) {
        injector__set_errmsg("%s error : %s", "GET_THREAD_STATE", mach_error_string(rv));
        rv = INJERR_ERROR_IN_TARGET;
      }
#endif
      rv = thread_resume(injector->remote_thread);
      if (rv != 0) {
        injector__set_errmsg("Remote thread resume error: %s\n", mach_error_string(rv));
        rv = INJERR_ERROR_IN_TARGET;
      }

      // wait thread for end
#if defined(__arm64__) || defined(__aarch64__)
      thread_state_flavor_t flavor = ARM_THREAD_STATE64;
#else
      thread_state_flavor_t flavor = x86_THREAD_STATE64;
#endif
      mach_msg_type_number_t state_count;
      int counter = 0;
      while (thread_get_state(
                 injector->remote_thread, flavor, (thread_state_t) &injector->remote_thread_saved_state, &state_count
             ) == 0) {
        counter++;
        usleep(10);
        if (counter > 1000) {
          break;
        }
      }
    }
  }

  if (injector->ptrace_attached) {
    injector->handle_action = STOP_DETACH;
    kill(injector->pid, SIGSTOP);
    injector->handle_err = 0;
    do {
      injector__handle_exc(injector);
    } while (injector->handle_err != 0);
    injector__release_exc_handler(injector);
  }

  if (injector->allocated) {
    injector__deallocate(injector, injector->text, injector->text_size + injector->stack_size);
    injector__deallocate(injector, injector->code_addr, injector->code_size);
  }
  if (injector->attached) {
    mach_port_deallocate(mach_task_self(), injector->remote_task);
  }

  free(injector);
  return rv;
}
const char* injector_error(void) { return injector__errmsg; }
```

`src/w1nj3ct/platform/darwin/impl/injector.h`:

```h
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2018-2023 Kubo Takehiro <kubo@jiubao.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

/*!
 * \file injector.h
 * \brief Library for injecting a shared library into a Linux, Windows and macOS process
 */
#ifndef INJECTOR_H
#define INJECTOR_H

#if defined(_WIN32)
#include <windows.h>
typedef DWORD injector_pid_t;
#else
#include <sys/types.h>

/*!
 * \brief Platform-dependent process id type (\c pid_t on Unix. \c DWORD on Windows)
 */
typedef pid_t injector_pid_t;
#endif

#ifdef __cplusplus
extern "C" {
#endif
#if 0
}
#endif

#define INJERR_SUCCESS 0              /* linux, windows, macos */
#define INJERR_OTHER -1               /* linux, windows, macos */
#define INJERR_NO_MEMORY -2           /* linux, windows, macos */
#define INJERR_NO_PROCESS -3          /* linux, windows, macos */
#define INJERR_NO_LIBRARY -4          /* linux */
#define INJERR_NO_FUNCTION -4         /* linux */
#define INJERR_ERROR_IN_TARGET -5     /* linux, windows, macos */
#define INJERR_FILE_NOT_FOUND -6      /* linux, windows, macos */
#define INJERR_INVALID_MEMORY_AREA -7 /* linux, macos */
#define INJERR_PERMISSION -8          /* linux, windows, macos */
#define INJERR_UNSUPPORTED_TARGET -9  /* linux, windows, macos */
#define INJERR_INVALID_ELF_FORMAT -10 /* linux */
#define INJERR_WAIT_TRACEE -11        /* linux */
#define INJERR_FUNCTION_MISSING -12   /* linux, windows, macos */

typedef struct injector injector_t;

/*!
 * \brief Attach to the specified process.
 * \param[out]  injector the address where the newly created injector handle will be stored
 * \param[in]   pid      the process id to be attached
 * \return               zero on success. Otherwise, error code
 */
int injector_attach(injector_t** injector, injector_pid_t pid);

/*!
 * \brief Detach from the attached process and destroy the specified handle.
 * \param[in]   injector the injector handle to destroy
 * \return               zero on success. Otherwise, error code
 */
int injector_detach(injector_t* injector);

/*!
 * \brief Inject the specified shared library into the target process.
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   path     the path name of the shared library
 * \param[out]  handle   the address where the newly created module handle will be stored
 * \return               zero on success. Otherwise, error code
 *
 * Note on Linux:
 * This calls functions inside of the target process interrupted by \c ptrace().
 * If the target process is interrupted while holding a non-reentrant lock and
 * injector calls a function requiring the same lock, the process stops forever.
 * If the lock type is reentrant, the status guarded by the lock may become inconsistent.
 * As far as I checked, \c dlopen() internally calls \c malloc() requiring non-reentrant
 * locks. \c dlopen() also uses a reentrant lock to guard information about loaded files.
 */
int injector_inject(injector_t* injector, const char* path, void** handle);

/*!
 * \brief Uninject the shared library specified by \c handle.
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   handle   the module handle created by \c injector_inject
 * \return               zero on success. Otherwise, error code
 * \remarks This fearute isn't supported for musl-libc processes.
 *     See [Functional differences from
 * glibc](https://wiki.musl-libc.org/functional-differences-from-glibc.html#Unloading_libraries).
 */
int injector_uninject(injector_t* injector, void* handle);

#if defined(INJECTOR_DOC) || defined(__linux__) || defined(__APPLE__)
/*!
 * \brief Call the specified function taking no arguments in the target process (Linux and macOS only)
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   handle   the module handle created by \c injector_inject or special-handles such as \c RTLD_DEFAULT
 * \param[in]   name     the function name
 *
 * The \c handle and \c name arguments are passed to \c dlsym
 * ([Linux](https://man7.org/linux/man-pages/man3/dlvsym.3.html),
 * [macOS](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlsym.3.html))
 * and then the return value of \c dlsym is called without arguments in the target process.
 *
 * This is same with the combination of injector_remote_func_addr() and injector_remote_call() without extra arguments.
 *
 * \note
 *   (Linux only)
 *   If the function in the target process internally calls
 * non-[async-signal-safe]((https://man7.org/linux/man-pages/man7/signal-safety.7.html)) functions, it may stop the
 * target process or cause unexpected behaviour.
 * \sa injector_remote_func_addr(), injector_remote_call(), injector_remote_vcall()
 */
int injector_call(injector_t* injector, void* handle, const char* name);
#endif

/*!
 * \brief Get the message of the last error.
 * \remarks The message is updated only when \c injector functions return non-zero.
 */
const char* injector_error(void);

#if defined(INJECTOR_DOC) || defined(__linux__) || defined(_WIN32)
#define INJECTOR_HAS_REMOTE_CALL_FUNCS 1
#include <stdarg.h>
#include <stdint.h>

/*!
 * \brief Get the function address in the target process (Linux and Windows only)
 * \param[in]   injector      the injector handle specifying the target process
 * \param[in]   handle        the module handle created by \c injector_inject or special-handles such as \c RTLD_DEFAULT
 * \param[in]   name          the function name
 * \param[out]  func_addr_out the address where the function address in the target process will be stored
 * \return                    zero on success. Otherwise, error code
 *
 * \b Example
 *
 * Inject libfoo.so and then call foo_func(1, 2, 3) in it.
 * \code
 * void *handle;
 * // inject libfoo.so and get the handle
 * if (injector_inject(injector, "libfoo.so", &handle) != 0) {
 *    return;
 * }
 * size_t func_addr;
 * // get the address of foo_func in the handle
 * if (injector_remote_func_addr(injector, handle, "foo_func", &func_addr) != 0) {
 *    return;
 * }
 * intptr_t retval;
 * // call foo_func
 * if (injector_remote_call(injector, &retval, func_addr, 1, 2, 3) != 0) {
 *    return;
 * }
 * printf("The return value of foo_func(1, 2, 3) is %ld.\n", retval);
 * \endcode
 */
int injector_remote_func_addr(injector_t* injector, void* handle, const char* name, size_t* func_addr_out);

/*!
 * \brief Call the function in the target process (Linux and Windows only)
 * \param[in]   injector  the injector handle specifying the target process
 * \param[out]  retval    \c NULL or the address where the return value of the function call will be stored
 * \param[in]   func_addr the function address in the target process
 * \param[in]   ...       arguments passed to the function
 * \return                zero on success. Otherwise, error code
 * \remarks
 *   The types of the arguments must be integer or pointer.
 *   If it is a pointer, it must point to a valid address in the target process.
 *   The number of arguments must be less than or equal to six.
 * \note
 *   If the function in the target process internally calls
 * non-[async-signal-safe]((https://man7.org/linux/man-pages/man7/signal-safety.7.html)) functions, it may stop the
 * target process or cause unexpected behaviour.
 * \sa injector_remote_func_addr(), injector_remote_vcall()
 */
int injector_remote_call(injector_t* injector, intptr_t* retval, size_t func_addr, ...);

/*!
 * \brief Call the function in the target process (Linux and Windows only)
 * \param[in]   injector  the injector handle specifying the target process
 * \param[out]  retval    \c NULL or the address where the return value of the function call will be stored
 * \param[in]   func_addr the function address in the target process
 * \param[in]   ap        arguments passed to the function
 * \return                zero on success. Otherwise, error code
 * \remarks
 *   The types of the arguments must be integer or pointer.
 *   If it is a pointer, it must point to a valid address in the target process.
 *   The number of arguments must be less than or equal to six.
 * \note
 *   If the function in the target process internally calls
 * non-[async-signal-safe]((https://man7.org/linux/man-pages/man7/signal-safety.7.html)) functions, it may stop the
 * target process or cause unexpected behaviour.
 * \sa injector_remote_func_addr(), injector_remote_call()
 */
int injector_remote_vcall(injector_t* injector, intptr_t* retval, size_t func_addr, va_list ap);
#endif

#if defined(INJECTOR_DOC) || defined(_WIN32)
/*!
 * \brief Same with \c injector_inject except the type of the \c path argument. (Windows only)
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   path     the path name of the shared library
 * \param[out]  handle   the address where the newly created module handle will be stored
 * \return               zero on success. Otherwise, error code
 */
int injector_inject_w(injector_t* injector, const wchar_t* path, void** handle);
#endif

#if defined(INJECTOR_DOC) || (defined(__linux__) && defined(__x86_64__))
#define INJECTOR_HAS_INJECT_IN_CLONED_THREAD 1 // feature test macro
/*!
 * \brief Inject the specified shared library into the target process by the \c clone system call. (Linux x86_64 only)
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   path     the path name of the shared library
 * \param[out]  handle   the address where the newly created module handle will be stored
 * \return               zero on success. Otherwise, error code
 *
 * This calls `dlopen()` in a thread created by \c [clone()](https://man7.org/linux/man-pages/man2/clone.2.html). Note
 * that no wonder there are unexpected pitfalls because some resources allocated in \c
 * [pthread_create()](https://man7.org/linux/man-pages/man3/pthread_create.3.html) lack in the \c clone()-ed thread. Use
 * it at your own risk.
 */
int injector_inject_in_cloned_thread(injector_t* injector, const char* path, void** handle);
#endif

#if 0
{
#endif
#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif

```

`src/w1nj3ct/platform/darwin/impl/injector_internal.h`:

```h
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2022 TheOiseth
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "injector.h"
#include <stdint.h>
#include <stdbool.h>
#include <mach/mach_vm.h>
#include <mach/mach.h>
#include <errno.h>

typedef enum { STOP_CONTINUE, STOP_DETACH, TRAP_SETREGS, TRAP_GETREGS } handle_action_t;

struct injector {
  pid_t pid;
  uint8_t attached;
  uint8_t allocated;
  uint8_t ptrace_attached;
  uint8_t shellcode_writed;
  task_t remote_task;
  size_t code_addr;
  size_t code2_addr;
  size_t code_size;
  size_t text;
  size_t text_size;
  size_t stack;
  size_t stack_size;

  thread_act_t mach_thread;
  thread_act_t remote_thread;
#if defined(__arm64__) || defined(__aarch64__)
  arm_thread_state64_t remote_thread_saved_state;
#else
  x86_thread_state64_t remote_thread_saved_state;
#endif
  uint8_t state_saved;
  long func_addr;
  long arg1;
  long arg2;
  long arg3;
  long arg4;
  long arg5;
  long arg6;
  mach_port_name_t exc_port;
  exception_mask_t saved_masks[EXC_TYPES_COUNT];
  mach_port_t saved_ports[EXC_TYPES_COUNT];
  exception_behavior_t saved_behaviors[EXC_TYPES_COUNT];
  thread_state_flavor_t saved_flavors[EXC_TYPES_COUNT];
  mach_msg_type_number_t saved_exception_types_count;
  handle_action_t handle_action;
  long retval;
  int handle_err;
};

typedef struct {
  char stub[120];
  injector_t* injector;
} mach_msg_header_with_injector;

typedef enum { ARCH_X86_64, ARCH_I386, ARCH_ARM64, ARCH_POWERPC_64, ARCH_POWERPC, ARCH_UNKNOWN } arch_t;

typedef int (*pcfmt_t)(pthread_t*, pthread_attr_t*, void*, void*);

int injector__task_pid(injector_t* injector);
int injector__allocate(const injector_t* injector, mach_vm_address_t* address, mach_vm_size_t size, int flags);
int injector__deallocate(const injector_t* injector, mach_vm_address_t address, mach_vm_size_t size);
int injector__protect(
    const injector_t* injector, mach_vm_address_t address, mach_vm_size_t size, boolean_t set_maximum,
    vm_prot_t new_protection
);
int injector__write(const injector_t* injector, size_t addr, const void* buf, size_t len);
int injector__read(const injector_t* injector, size_t addr, void* buf, size_t len);
int injector__ptrace_attach(const injector_t* injector);
int injector__ptrace_detach(const injector_t* injector);
int injector__ptrace_continue(const injector_t* injector);
int injector__ptrace_update(const injector_t* injector, long thread_port);

int injector__create_exc_handler(injector_t* injector);
int injector__release_exc_handler(injector_t* injector);
int injector__handle_exc(injector_t* injector);

int injector__call_function(injector_t* injector, long* retval, long function_addr, ...);
/* util.c */
extern char injector__errmsg[];
extern char injector__errmsg_is_set;
void injector__set_errmsg(const char* format, ...);
const char* injector__arch2name(arch_t arch);
int injector__get_process_arch(pid_t pid, arch_t* arch);
arch_t injector__get_system_arch();
```

`src/w1nj3ct/platform/darwin/impl/mach.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2022 TheOiseth
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "injector_internal.h"
#include <libproc.h>
#include <signal.h>
static int set_mach_error(const char* request_name, int err) {
  injector__set_errmsg("%s error : %s", request_name, mach_error_string(err));
  switch (err) {
  case KERN_INVALID_ADDRESS:
    return INJERR_INVALID_MEMORY_AREA;
  case KERN_NO_ACCESS:
    return INJERR_PERMISSION;
  }
  return INJERR_OTHER;
}

static int set_error(const char* request_name) {
  int err = errno;
  injector__set_errmsg("%s error : %s", request_name, strerror(errno));
  switch (err) {
  case EFAULT:
    return INJERR_INVALID_MEMORY_AREA;
  case EPERM:
    return INJERR_PERMISSION;
  case ESRCH:
    return INJERR_NO_PROCESS;
  }
  return INJERR_OTHER;
}

int injector__task_pid(injector_t* injector) {
  int rv = kill(injector->pid, 0);
  if (rv != 0) {
    return set_error("TASK_FOR_PID");
  }
  task_t remote_task;
  rv = task_for_pid(mach_task_self(), injector->pid, &remote_task);

  if (rv != KERN_SUCCESS) {
    return set_mach_error("TASK_FOR_PID", rv);
  }
  injector->remote_task = remote_task;
  return 0;
}

int injector__allocate(const injector_t* injector, mach_vm_address_t* address, mach_vm_size_t size, int flags) {
  int rv = mach_vm_allocate(injector->remote_task, address, size, flags);
  if (rv != KERN_SUCCESS) {
    return set_mach_error("ALLOCATE", rv);
  }
  return 0;
}

int injector__deallocate(const injector_t* injector, mach_vm_address_t address, mach_vm_size_t size) {
  int rv = mach_vm_deallocate(injector->remote_task, address, size);
  if (rv != KERN_SUCCESS) {
    return set_mach_error("DEALLOCATE", rv);
  }
  return 0;
}

int injector__protect(
    const injector_t* injector, mach_vm_address_t address, mach_vm_size_t size, boolean_t set_maximum,
    vm_prot_t new_protection
) {
  int rv = mach_vm_protect(injector->remote_task, address, size, set_maximum, new_protection);
  if (rv != KERN_SUCCESS) {
    return set_mach_error("PROTECT", rv);
  }
  return 0;
}

int injector__write(const injector_t* injector, size_t addr, const void* buf, size_t len) {
  int rv = mach_vm_write(injector->remote_task, addr, (vm_offset_t) buf, len);
  if (rv != KERN_SUCCESS) {
    return set_mach_error("WRITE", rv);
  }
  return 0;
}
int injector__read(const injector_t* injector, size_t addr, void* buf, size_t len) {
  mach_vm_size_t readed;
  int rv = mach_vm_read_overwrite(injector->remote_task, addr, len, (mach_vm_address_t) buf, &readed);
  if (rv != KERN_SUCCESS) {
    return set_mach_error("READ", rv);
  }
  return 0;
}

```

`src/w1nj3ct/platform/darwin/impl/mach_exc.h`:

```h
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * this code is generated automatically by mig
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#ifndef _mach_exc_user_
#define _mach_exc_user_

/* Module mach_exc */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>

/* BEGIN VOUCHER CODE */

#ifndef KERNEL
#if defined(__has_include)
#if __has_include(<mach/mig_voucher_support.h>)
#ifndef USING_VOUCHERS
#define USING_VOUCHERS
#endif
#ifndef __VOUCHER_FORWARD_TYPE_DECLS__
#define __VOUCHER_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
extern boolean_t voucher_mach_msg_set(mach_msg_header_t* msg) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif // __VOUCHER_FORWARD_TYPE_DECLS__
#endif // __has_include(<mach/mach_voucher_types.h>)
#endif // __has_include
#endif // !KERNEL

/* END VOUCHER CODE */

/* BEGIN MIG_STRNCPY_ZEROFILL CODE */

#if defined(__has_include)
#if __has_include(<mach/mig_strncpy_zerofill_support.h>)
#ifndef USING_MIG_STRNCPY_ZEROFILL
#define USING_MIG_STRNCPY_ZEROFILL
#endif
#ifndef __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#define __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
extern int mig_strncpy_zerofill(char* dest, const char* src, int len) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif /* __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__ */
#endif /* __has_include(<mach/mig_strncpy_zerofill_support.h>) */
#endif /* __has_include */

/* END MIG_STRNCPY_ZEROFILL CODE */

#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char*, mach_msg_type_number_t);
typedef struct {
  char* name;
  function_ptr_t function;
} function_table_entry;
typedef function_table_entry* function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef mach_exc_MSG_COUNT
#define mach_exc_MSG_COUNT 3
#endif /* mach_exc_MSG_COUNT */

#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mig.h>
#include <mach/mach_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
    __BEGIN_DECLS

/* Routine mach_exception_raise */
#ifdef mig_external
        mig_external
#else
extern
#endif /* mig_external */
            kern_return_t mach_exception_raise(
                mach_port_t exception_port, mach_port_t thread, mach_port_t task, exception_type_t exception,
                mach_exception_data_t code, mach_msg_type_number_t codeCnt
            );

/* Routine mach_exception_raise_state */
#ifdef mig_external
mig_external
#else
extern
#endif /* mig_external */
    kern_return_t mach_exception_raise_state(
        mach_port_t exception_port, exception_type_t exception, const mach_exception_data_t code,
        mach_msg_type_number_t codeCnt, int* flavor, const thread_state_t old_state,
        mach_msg_type_number_t old_stateCnt, thread_state_t new_state, mach_msg_type_number_t* new_stateCnt
    );

/* Routine mach_exception_raise_state_identity */
#ifdef mig_external
mig_external
#else
extern
#endif /* mig_external */
    kern_return_t mach_exception_raise_state_identity(
        mach_port_t exception_port, mach_port_t thread, mach_port_t task, exception_type_t exception,
        mach_exception_data_t code, mach_msg_type_number_t codeCnt, int* flavor, thread_state_t old_state,
        mach_msg_type_number_t old_stateCnt, thread_state_t new_state, mach_msg_type_number_t* new_stateCnt
    );

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__mach_exc_subsystem__defined
#define __Request__mach_exc_subsystem__defined

#ifdef __MigPackStructs
#pragma pack(push, 4)
#endif
typedef struct {
  mach_msg_header_t Head;
  /* start of the kernel processed data */
  mach_msg_body_t msgh_body;
  mach_msg_port_descriptor_t thread;
  mach_msg_port_descriptor_t task;
  /* end of the kernel processed data */
  NDR_record_t NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
} __Request__mach_exception_raise_t __attribute__((unused));
#ifdef __MigPackStructs
#pragma pack(pop)
#endif

#ifdef __MigPackStructs
#pragma pack(push, 4)
#endif
typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[614];
} __Request__mach_exception_raise_state_t __attribute__((unused));
#ifdef __MigPackStructs
#pragma pack(pop)
#endif

#ifdef __MigPackStructs
#pragma pack(push, 4)
#endif
typedef struct {
  mach_msg_header_t Head;
  /* start of the kernel processed data */
  mach_msg_body_t msgh_body;
  mach_msg_port_descriptor_t thread;
  mach_msg_port_descriptor_t task;
  /* end of the kernel processed data */
  NDR_record_t NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[614];
} __Request__mach_exception_raise_state_identity_t __attribute__((unused));
#ifdef __MigPackStructs
#pragma pack(pop)
#endif
#endif /* !__Request__mach_exc_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__mach_exc_subsystem__defined
#define __RequestUnion__mach_exc_subsystem__defined
union __RequestUnion__mach_exc_subsystem {
  __Request__mach_exception_raise_t Request_mach_exception_raise;
  __Request__mach_exception_raise_state_t Request_mach_exception_raise_state;
  __Request__mach_exception_raise_state_identity_t Request_mach_exception_raise_state_identity;
};
#endif /* !__RequestUnion__mach_exc_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__mach_exc_subsystem__defined
#define __Reply__mach_exc_subsystem__defined

#ifdef __MigPackStructs
#pragma pack(push, 4)
#endif
typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
} __Reply__mach_exception_raise_t __attribute__((unused));
#ifdef __MigPackStructs
#pragma pack(pop)
#endif

#ifdef __MigPackStructs
#pragma pack(push, 4)
#endif
typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
  int flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[614];
} __Reply__mach_exception_raise_state_t __attribute__((unused));
#ifdef __MigPackStructs
#pragma pack(pop)
#endif

#ifdef __MigPackStructs
#pragma pack(push, 4)
#endif
typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
  int flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[614];
} __Reply__mach_exception_raise_state_identity_t __attribute__((unused));
#ifdef __MigPackStructs
#pragma pack(pop)
#endif
#endif /* !__Reply__mach_exc_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__mach_exc_subsystem__defined
#define __ReplyUnion__mach_exc_subsystem__defined
union __ReplyUnion__mach_exc_subsystem {
  __Reply__mach_exception_raise_t Reply_mach_exception_raise;
  __Reply__mach_exception_raise_state_t Reply_mach_exception_raise_state;
  __Reply__mach_exception_raise_state_identity_t Reply_mach_exception_raise_state_identity;
};
#endif /* !__RequestUnion__mach_exc_subsystem__defined */

#ifndef subsystem_to_name_map_mach_exc
#define subsystem_to_name_map_mach_exc                                                                                 \
  {"mach_exception_raise", 2405}, {"mach_exception_raise_state", 2406}, {"mach_exception_raise_state_identity", 2407}
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif /* _mach_exc_user_ */

```

`src/w1nj3ct/platform/darwin/impl/mach_excServer.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * this code is generated automatically by mig
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
/*
 * IDENTIFICATION:
 * stub generated Mon Nov  7 09:48:39 2022
 * with a MiG generated by bootstrap_cmds-117
 * OPTIONS:
 */

/* Module mach_exc */

#define __MIG_check__Request__mach_exc_subsystem__ 1
#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>
#include "injector_internal.h"
/* BEGIN VOUCHER CODE */

#ifndef KERNEL
#if defined(__has_include)
#if __has_include(<mach/mig_voucher_support.h>)
#ifndef USING_VOUCHERS
#define USING_VOUCHERS
#endif
#ifndef __VOUCHER_FORWARD_TYPE_DECLS__
#define __VOUCHER_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
extern boolean_t voucher_mach_msg_set(mach_msg_header_t* msg) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif // __VOUCHER_FORWARD_TYPE_DECLS__
#endif // __has_include(<mach/mach_voucher_types.h>)
#endif // __has_include
#endif // !KERNEL

/* END VOUCHER CODE */

/* BEGIN MIG_STRNCPY_ZEROFILL CODE */

#if defined(__has_include)
#if __has_include(<mach/mig_strncpy_zerofill_support.h>)
#ifndef USING_MIG_STRNCPY_ZEROFILL
#define USING_MIG_STRNCPY_ZEROFILL
#endif
#ifndef __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#define __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
extern int mig_strncpy_zerofill(char* dest, const char* src, int len) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif /* __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__ */
#endif /* __has_include(<mach/mig_strncpy_zerofill_support.h>) */
#endif /* __has_include */

/* END MIG_STRNCPY_ZEROFILL CODE */

#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mig.h>
#include <mach/mach_types.h>

#ifndef mig_internal
#define mig_internal static __inline__
#endif /* mig_internal */

#ifndef mig_external
#define mig_external
#endif /* mig_external */

#if !defined(__MigTypeCheck) && defined(TypeCheck)
#define __MigTypeCheck TypeCheck /* Legacy setting */
#endif                           /* !defined(__MigTypeCheck) */

#if !defined(__MigKernelSpecificCode) && defined(_MIG_KERNEL_SPECIFIC_CODE_)
#define __MigKernelSpecificCode _MIG_KERNEL_SPECIFIC_CODE_ /* Legacy setting */
#endif                                                     /* !defined(__MigKernelSpecificCode) */

#ifndef LimitCheck
#define LimitCheck 0
#endif /* LimitCheck */

#ifndef min
#define min(a, b) (((a) < (b)) ? (a) : (b))
#endif /* min */

#if !defined(_WALIGN_)
#define _WALIGN_(x) (((x) + 3) & ~3)
#endif /* !defined(_WALIGN_) */

#if !defined(_WALIGNSZ_)
#define _WALIGNSZ_(x) _WALIGN_(sizeof(x))
#endif /* !defined(_WALIGNSZ_) */

#ifndef UseStaticTemplates
#define UseStaticTemplates 0
#endif /* UseStaticTemplates */

#ifndef MIG_SERVER_ROUTINE
#define MIG_SERVER_ROUTINE
#endif

#ifndef __DeclareRcvRpc
#define __DeclareRcvRpc(_NUM_, _NAME_)
#endif /* __DeclareRcvRpc */

#ifndef __BeforeRcvRpc
#define __BeforeRcvRpc(_NUM_, _NAME_)
#endif /* __BeforeRcvRpc */

#ifndef __AfterRcvRpc
#define __AfterRcvRpc(_NUM_, _NAME_)
#endif /* __AfterRcvRpc */

#ifndef __DeclareRcvSimple
#define __DeclareRcvSimple(_NUM_, _NAME_)
#endif /* __DeclareRcvSimple */

#ifndef __BeforeRcvSimple
#define __BeforeRcvSimple(_NUM_, _NAME_)
#endif /* __BeforeRcvSimple */

#ifndef __AfterRcvSimple
#define __AfterRcvSimple(_NUM_, _NAME_)
#endif /* __AfterRcvSimple */

#define novalue void

#define msgh_request_port msgh_local_port
#define MACH_MSGH_BITS_REQUEST(bits) MACH_MSGH_BITS_LOCAL(bits)
#define msgh_reply_port msgh_remote_port
#define MACH_MSGH_BITS_REPLY(bits) MACH_MSGH_BITS_REMOTE(bits)

#define MIG_RETURN_ERROR(X, code)                                                                                      \
  {                                                                                                                    \
    ((mig_reply_error_t*) X)->RetCode = code;                                                                          \
    ((mig_reply_error_t*) X)->NDR = NDR_record;                                                                        \
    return;                                                                                                            \
  }

/* typedefs for all requests */

#ifndef __Request__mach_exc_subsystem__defined
#define __Request__mach_exc_subsystem__defined

#ifdef __MigPackStructs
#pragma pack(push, 4)
#endif
typedef struct {
  mach_msg_header_t Head;
  /* start of the kernel processed data */
  mach_msg_body_t msgh_body;
  mach_msg_port_descriptor_t thread;
  mach_msg_port_descriptor_t task;
  /* end of the kernel processed data */
  NDR_record_t NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
} __Request__mach_exception_raise_t __attribute__((unused));
#ifdef __MigPackStructs
#pragma pack(pop)
#endif

#ifdef __MigPackStructs
#pragma pack(push, 4)
#endif
typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[614];
} __Request__mach_exception_raise_state_t __attribute__((unused));
#ifdef __MigPackStructs
#pragma pack(pop)
#endif

#ifdef __MigPackStructs
#pragma pack(push, 4)
#endif
typedef struct {
  mach_msg_header_t Head;
  /* start of the kernel processed data */
  mach_msg_body_t msgh_body;
  mach_msg_port_descriptor_t thread;
  mach_msg_port_descriptor_t task;
  /* end of the kernel processed data */
  NDR_record_t NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[614];
} __Request__mach_exception_raise_state_identity_t __attribute__((unused));
#ifdef __MigPackStructs
#pragma pack(pop)
#endif
#endif /* !__Request__mach_exc_subsystem__defined */

/* typedefs for all replies */

#ifndef __Reply__mach_exc_subsystem__defined
#define __Reply__mach_exc_subsystem__defined

#ifdef __MigPackStructs
#pragma pack(push, 4)
#endif
typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
} __Reply__mach_exception_raise_t __attribute__((unused));
#ifdef __MigPackStructs
#pragma pack(pop)
#endif

#ifdef __MigPackStructs
#pragma pack(push, 4)
#endif
typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
  int flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[614];
} __Reply__mach_exception_raise_state_t __attribute__((unused));
#ifdef __MigPackStructs
#pragma pack(pop)
#endif

#ifdef __MigPackStructs
#pragma pack(push, 4)
#endif
typedef struct {
  mach_msg_header_t Head;
  NDR_record_t NDR;
  kern_return_t RetCode;
  int flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[614];
} __Reply__mach_exception_raise_state_identity_t __attribute__((unused));
#ifdef __MigPackStructs
#pragma pack(pop)
#endif
#endif /* !__Reply__mach_exc_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__catch_mach_exc_subsystem__defined
#define __ReplyUnion__catch_mach_exc_subsystem__defined
union __ReplyUnion__catch_mach_exc_subsystem {
  __Reply__mach_exception_raise_t Reply_mach_exception_raise;
  __Reply__mach_exception_raise_state_t Reply_mach_exception_raise_state;
  __Reply__mach_exception_raise_state_identity_t Reply_mach_exception_raise_state_identity;
};
#endif /* __ReplyUnion__catch_mach_exc_subsystem__defined */
/* Forward Declarations */

mig_internal novalue _Xmach_exception_raise(mach_msg_header_t* InHeadP, mach_msg_header_t* OutHeadP);

mig_internal novalue _Xmach_exception_raise_state(mach_msg_header_t* InHeadP, mach_msg_header_t* OutHeadP);

mig_internal novalue _Xmach_exception_raise_state_identity(mach_msg_header_t* InHeadP, mach_msg_header_t* OutHeadP);

#if (__MigTypeCheck)
#if __MIG_check__Request__mach_exc_subsystem__
#if !defined(__MIG_check__Request__mach_exception_raise_t__defined)
#define __MIG_check__Request__mach_exception_raise_t__defined

mig_internal kern_return_t
__MIG_check__Request__mach_exception_raise_t(__attribute__((__unused__)) __Request__mach_exception_raise_t* In0P) {

  typedef __Request__mach_exception_raise_t __Request;
#if __MigTypeCheck
  unsigned int msgh_size;
#endif /* __MigTypeCheck */

#if __MigTypeCheck
  msgh_size = In0P->Head.msgh_size;
  if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) || (In0P->msgh_body.msgh_descriptor_count != 2) ||
      (msgh_size < (mach_msg_size_t) (sizeof(__Request) - 16)) || (msgh_size > (mach_msg_size_t) sizeof(__Request))) {
    return MIG_BAD_ARGUMENTS;
  }
#endif /* __MigTypeCheck */

#if __MigTypeCheck
  if (In0P->thread.type != MACH_MSG_PORT_DESCRIPTOR || In0P->thread.disposition != 17) {
    return MIG_TYPE_ERROR;
  }
#endif /* __MigTypeCheck */

#if __MigTypeCheck
  if (In0P->task.type != MACH_MSG_PORT_DESCRIPTOR || In0P->task.disposition != 17) {
    return MIG_TYPE_ERROR;
  }
#endif /* __MigTypeCheck */

#if defined(__NDR_convert__int_rep__Request__mach_exception_raise_t__codeCnt__defined)
  if (In0P->NDR.int_rep != NDR_record.int_rep) {
    __NDR_convert__int_rep__Request__mach_exception_raise_t__codeCnt(&In0P->codeCnt, In0P->NDR.int_rep);
  }
#endif /* __NDR_convert__int_rep__Request__mach_exception_raise_t__codeCnt__defined */
#if __MigTypeCheck
  if (In0P->codeCnt > 2) {
    return MIG_BAD_ARGUMENTS;
  }
  if (((msgh_size - (mach_msg_size_t) (sizeof(__Request) - 16)) / 8 < In0P->codeCnt) ||
      (msgh_size != (mach_msg_size_t) (sizeof(__Request) - 16) + (8 * In0P->codeCnt))) {
    return MIG_BAD_ARGUMENTS;
  }
#endif /* __MigTypeCheck */

  return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__mach_exception_raise_t__defined) */
#endif /* __MIG_check__Request__mach_exc_subsystem__ */
#endif /* ( __MigTypeCheck ) */

/* Routine mach_exception_raise */
#ifdef mig_external
mig_external
#else
extern
#endif /* mig_external */
    MIG_SERVER_ROUTINE kern_return_t catch_mach_exception_raise(
        mach_port_t exception_port, mach_port_t thread, mach_port_t task, exception_type_t exception,
        mach_exception_data_t code, mach_msg_type_number_t codeCnt, injector_t* injector
    );

/* Routine mach_exception_raise */
mig_internal novalue _Xmach_exception_raise(mach_msg_header_t* InHeadP, mach_msg_header_t* OutHeadP) {

#ifdef __MigPackStructs
#pragma pack(push, 4)
#endif
  typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_port_descriptor_t thread;
    mach_msg_port_descriptor_t task;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    exception_type_t exception;
    mach_msg_type_number_t codeCnt;
    int64_t code[2];
    mach_msg_trailer_t trailer;
  } Request __attribute__((unused));
#ifdef __MigPackStructs
#pragma pack(pop)
#endif
  typedef __Request__mach_exception_raise_t __Request;
  typedef __Reply__mach_exception_raise_t Reply __attribute__((unused));

  /*
   * typedef struct {
   * 	mach_msg_header_t Head;
   * 	NDR_record_t NDR;
   * 	kern_return_t RetCode;
   * } mig_reply_error_t;
   */
  Request* In0P = (Request*) InHeadP;
  Reply* OutP = (Reply*) OutHeadP;
#ifdef __MIG_check__Request__mach_exception_raise_t__defined
  kern_return_t check_result;
#endif /* __MIG_check__Request__mach_exception_raise_t__defined */

  __DeclareRcvRpc(2405, "mach_exception_raise") __BeforeRcvRpc(2405, "mach_exception_raise")

#if defined(__MIG_check__Request__mach_exception_raise_t__defined)
      check_result = __MIG_check__Request__mach_exception_raise_t((__Request*) In0P);
  if (check_result != MACH_MSG_SUCCESS) {
    MIG_RETURN_ERROR(OutP, check_result);
  }
#endif /* defined(__MIG_check__Request__mach_exception_raise_t__defined) */
  mach_msg_header_with_injector* mmhwi = (mach_msg_header_with_injector*) In0P;
  OutP->RetCode = catch_mach_exception_raise(
      In0P->Head.msgh_request_port, In0P->thread.name, In0P->task.name, In0P->exception, In0P->code, In0P->codeCnt,
      mmhwi->injector
  );

  OutP->NDR = NDR_record;

  __AfterRcvRpc(2405, "mach_exception_raise")
}

#if (__MigTypeCheck)
#if __MIG_check__Request__mach_exc_subsystem__
#if !defined(__MIG_check__Request__mach_exception_raise_state_t__defined)
#define __MIG_check__Request__mach_exception_raise_state_t__defined

mig_internal kern_return_t __MIG_check__Request__mach_exception_raise_state_t(
    __attribute__((__unused__)) __Request__mach_exception_raise_state_t* In0P,
    __attribute__((__unused__)) __Request__mach_exception_raise_state_t** In1PP
) {

  typedef __Request__mach_exception_raise_state_t __Request;
  __Request* In1P;
#if __MigTypeCheck
  unsigned int msgh_size;
#endif /* __MigTypeCheck */
  unsigned int msgh_size_delta;

#if __MigTypeCheck
  msgh_size = In0P->Head.msgh_size;
  if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) || (msgh_size < (mach_msg_size_t) (sizeof(__Request) - 2472)) ||
      (msgh_size > (mach_msg_size_t) sizeof(__Request))) {
    return MIG_BAD_ARGUMENTS;
  }
#endif /* __MigTypeCheck */

#if defined(__NDR_convert__int_rep__Request__mach_exception_raise_state_t__codeCnt__defined)
  if (In0P->NDR.int_rep != NDR_record.int_rep) {
    __NDR_convert__int_rep__Request__mach_exception_raise_state_t__codeCnt(&In0P->codeCnt, In0P->NDR.int_rep);
  }
#endif /* __NDR_convert__int_rep__Request__mach_exception_raise_state_t__codeCnt__defined */
  msgh_size_delta = (8 * In0P->codeCnt);
#if __MigTypeCheck
  if (In0P->codeCnt > 2) {
    return MIG_BAD_ARGUMENTS;
  }
  if (((msgh_size - (mach_msg_size_t) (sizeof(__Request) - 2472)) / 8 < In0P->codeCnt) ||
      (msgh_size < (mach_msg_size_t) (sizeof(__Request) - 2472) + (8 * In0P->codeCnt))) {
    return MIG_BAD_ARGUMENTS;
  }
  msgh_size -= msgh_size_delta;
#endif /* __MigTypeCheck */

  *In1PP = In1P = (__Request*) ((pointer_t) In0P + msgh_size_delta - 16);

#if defined(__NDR_convert__int_rep__Request__mach_exception_raise_state_t__old_stateCnt__defined)
  if (In0P->NDR.int_rep != NDR_record.int_rep) {
    __NDR_convert__int_rep__Request__mach_exception_raise_state_t__old_stateCnt(&In1P->old_stateCnt, In1P->NDR.int_rep);
  }
#endif /* __NDR_convert__int_rep__Request__mach_exception_raise_state_t__old_stateCnt__defined */
#if __MigTypeCheck
  if (In1P->old_stateCnt > 614) {
    return MIG_BAD_ARGUMENTS;
  }
  if (((msgh_size - (mach_msg_size_t) (sizeof(__Request) - 2472)) / 4 < In1P->old_stateCnt) ||
      (msgh_size != (mach_msg_size_t) (sizeof(__Request) - 2472) + (4 * In1P->old_stateCnt))) {
    return MIG_BAD_ARGUMENTS;
  }
#endif /* __MigTypeCheck */

  return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__mach_exception_raise_state_t__defined) */
#endif /* __MIG_check__Request__mach_exc_subsystem__ */
#endif /* ( __MigTypeCheck ) */

/* Routine mach_exception_raise_state */
#ifdef mig_external
mig_external
#else
extern
#endif /* mig_external */
    MIG_SERVER_ROUTINE kern_return_t catch_mach_exception_raise_state(
        mach_port_t exception_port, exception_type_t exception, const mach_exception_data_t code,
        mach_msg_type_number_t codeCnt, int* flavor, const thread_state_t old_state,
        mach_msg_type_number_t old_stateCnt, thread_state_t new_state, mach_msg_type_number_t* new_stateCnt
    );

/* Routine mach_exception_raise_state */
mig_internal novalue _Xmach_exception_raise_state(mach_msg_header_t* InHeadP, mach_msg_header_t* OutHeadP) {

#ifdef __MigPackStructs
#pragma pack(push, 4)
#endif
  typedef struct {
    mach_msg_header_t Head;
    NDR_record_t NDR;
    exception_type_t exception;
    mach_msg_type_number_t codeCnt;
    int64_t code[2];
    int flavor;
    mach_msg_type_number_t old_stateCnt;
    natural_t old_state[614];
    mach_msg_trailer_t trailer;
  } Request __attribute__((unused));
#ifdef __MigPackStructs
#pragma pack(pop)
#endif
  typedef __Request__mach_exception_raise_state_t __Request;
  typedef __Reply__mach_exception_raise_state_t Reply __attribute__((unused));

  /*
   * typedef struct {
   * 	mach_msg_header_t Head;
   * 	NDR_record_t NDR;
   * 	kern_return_t RetCode;
   * } mig_reply_error_t;
   */

  Request* In0P = (Request*) InHeadP;
  Request* In1P;
  Reply* OutP = (Reply*) OutHeadP;
#ifdef __MIG_check__Request__mach_exception_raise_state_t__defined
  kern_return_t check_result;
#endif /* __MIG_check__Request__mach_exception_raise_state_t__defined */

  __DeclareRcvRpc(2406, "mach_exception_raise_state") __BeforeRcvRpc(2406, "mach_exception_raise_state")

#if defined(__MIG_check__Request__mach_exception_raise_state_t__defined)
      check_result = __MIG_check__Request__mach_exception_raise_state_t((__Request*) In0P, (__Request**) &In1P);
  if (check_result != MACH_MSG_SUCCESS) {
    MIG_RETURN_ERROR(OutP, check_result);
  }
#endif /* defined(__MIG_check__Request__mach_exception_raise_state_t__defined) */

  OutP->new_stateCnt = 614;

  OutP->RetCode = catch_mach_exception_raise_state(
      In0P->Head.msgh_request_port, In0P->exception, In0P->code, In0P->codeCnt, &In1P->flavor, In1P->old_state,
      In1P->old_stateCnt, OutP->new_state, &OutP->new_stateCnt
  );
  if (OutP->RetCode != KERN_SUCCESS) {
    MIG_RETURN_ERROR(OutP, OutP->RetCode);
  }

  OutP->NDR = NDR_record;

  OutP->flavor = In1P->flavor;
  OutP->Head.msgh_size = (mach_msg_size_t) (sizeof(Reply) - 2456) + (((4 * OutP->new_stateCnt)));

  __AfterRcvRpc(2406, "mach_exception_raise_state")
}

#if (__MigTypeCheck)
#if __MIG_check__Request__mach_exc_subsystem__
#if !defined(__MIG_check__Request__mach_exception_raise_state_identity_t__defined)
#define __MIG_check__Request__mach_exception_raise_state_identity_t__defined

mig_internal kern_return_t __MIG_check__Request__mach_exception_raise_state_identity_t(
    __attribute__((__unused__)) __Request__mach_exception_raise_state_identity_t* In0P,
    __attribute__((__unused__)) __Request__mach_exception_raise_state_identity_t** In1PP
) {

  typedef __Request__mach_exception_raise_state_identity_t __Request;
  __Request* In1P;
#if __MigTypeCheck
  unsigned int msgh_size;
#endif /* __MigTypeCheck */
  unsigned int msgh_size_delta;

#if __MigTypeCheck
  msgh_size = In0P->Head.msgh_size;
  if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) || (In0P->msgh_body.msgh_descriptor_count != 2) ||
      (msgh_size < (mach_msg_size_t) (sizeof(__Request) - 2472)) || (msgh_size > (mach_msg_size_t) sizeof(__Request))) {
    return MIG_BAD_ARGUMENTS;
  }
#endif /* __MigTypeCheck */

#if __MigTypeCheck
  if (In0P->thread.type != MACH_MSG_PORT_DESCRIPTOR || In0P->thread.disposition != 17) {
    return MIG_TYPE_ERROR;
  }
#endif /* __MigTypeCheck */

#if __MigTypeCheck
  if (In0P->task.type != MACH_MSG_PORT_DESCRIPTOR || In0P->task.disposition != 17) {
    return MIG_TYPE_ERROR;
  }
#endif /* __MigTypeCheck */

#if defined(__NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__codeCnt__defined)
  if (In0P->NDR.int_rep != NDR_record.int_rep) {
    __NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__codeCnt(&In0P->codeCnt, In0P->NDR.int_rep);
  }
#endif /* __NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__codeCnt__defined */
  msgh_size_delta = (8 * In0P->codeCnt);
#if __MigTypeCheck
  if (In0P->codeCnt > 2) {
    return MIG_BAD_ARGUMENTS;
  }
  if (((msgh_size - (mach_msg_size_t) (sizeof(__Request) - 2472)) / 8 < In0P->codeCnt) ||
      (msgh_size < (mach_msg_size_t) (sizeof(__Request) - 2472) + (8 * In0P->codeCnt))) {
    return MIG_BAD_ARGUMENTS;
  }
  msgh_size -= msgh_size_delta;
#endif /* __MigTypeCheck */

  *In1PP = In1P = (__Request*) ((pointer_t) In0P + msgh_size_delta - 16);

#if defined(__NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__old_stateCnt__defined)
  if (In0P->NDR.int_rep != NDR_record.int_rep) {
    __NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__old_stateCnt(
        &In1P->old_stateCnt, In1P->NDR.int_rep
    );
  }
#endif /* __NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__old_stateCnt__defined */
#if __MigTypeCheck
  if (In1P->old_stateCnt > 614) {
    return MIG_BAD_ARGUMENTS;
  }
  if (((msgh_size - (mach_msg_size_t) (sizeof(__Request) - 2472)) / 4 < In1P->old_stateCnt) ||
      (msgh_size != (mach_msg_size_t) (sizeof(__Request) - 2472) + (4 * In1P->old_stateCnt))) {
    return MIG_BAD_ARGUMENTS;
  }
#endif /* __MigTypeCheck */

  return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__mach_exception_raise_state_identity_t__defined) */
#endif /* __MIG_check__Request__mach_exc_subsystem__ */
#endif /* ( __MigTypeCheck ) */

/* Routine mach_exception_raise_state_identity */
#ifdef mig_external
mig_external
#else
extern
#endif /* mig_external */
    MIG_SERVER_ROUTINE kern_return_t catch_mach_exception_raise_state_identity(
        mach_port_t exception_port, mach_port_t thread, mach_port_t task, exception_type_t exception,
        mach_exception_data_t code, mach_msg_type_number_t codeCnt, int* flavor, thread_state_t old_state,
        mach_msg_type_number_t old_stateCnt, thread_state_t new_state, mach_msg_type_number_t* new_stateCnt
    );

/* Routine mach_exception_raise_state_identity */
mig_internal novalue _Xmach_exception_raise_state_identity(mach_msg_header_t* InHeadP, mach_msg_header_t* OutHeadP) {

#ifdef __MigPackStructs
#pragma pack(push, 4)
#endif
  typedef struct {
    mach_msg_header_t Head;
    /* start of the kernel processed data */
    mach_msg_body_t msgh_body;
    mach_msg_port_descriptor_t thread;
    mach_msg_port_descriptor_t task;
    /* end of the kernel processed data */
    NDR_record_t NDR;
    exception_type_t exception;
    mach_msg_type_number_t codeCnt;
    int64_t code[2];
    int flavor;
    mach_msg_type_number_t old_stateCnt;
    natural_t old_state[614];
    mach_msg_trailer_t trailer;
  } Request __attribute__((unused));
#ifdef __MigPackStructs
#pragma pack(pop)
#endif
  typedef __Request__mach_exception_raise_state_identity_t __Request;
  typedef __Reply__mach_exception_raise_state_identity_t Reply __attribute__((unused));

  /*
   * typedef struct {
   * 	mach_msg_header_t Head;
   * 	NDR_record_t NDR;
   * 	kern_return_t RetCode;
   * } mig_reply_error_t;
   */

  Request* In0P = (Request*) InHeadP;
  Request* In1P;
  Reply* OutP = (Reply*) OutHeadP;
#ifdef __MIG_check__Request__mach_exception_raise_state_identity_t__defined
  kern_return_t check_result;
#endif /* __MIG_check__Request__mach_exception_raise_state_identity_t__defined */

  __DeclareRcvRpc(2407, "mach_exception_raise_state_identity")
      __BeforeRcvRpc(2407, "mach_exception_raise_state_identity")

#if defined(__MIG_check__Request__mach_exception_raise_state_identity_t__defined)
          check_result =
              __MIG_check__Request__mach_exception_raise_state_identity_t((__Request*) In0P, (__Request**) &In1P);
  if (check_result != MACH_MSG_SUCCESS) {
    MIG_RETURN_ERROR(OutP, check_result);
  }
#endif /* defined(__MIG_check__Request__mach_exception_raise_state_identity_t__defined) */

  OutP->new_stateCnt = 614;

  OutP->RetCode = catch_mach_exception_raise_state_identity(
      In0P->Head.msgh_request_port, In0P->thread.name, In0P->task.name, In0P->exception, In0P->code, In0P->codeCnt,
      &In1P->flavor, In1P->old_state, In1P->old_stateCnt, OutP->new_state, &OutP->new_stateCnt
  );
  if (OutP->RetCode != KERN_SUCCESS) {
    MIG_RETURN_ERROR(OutP, OutP->RetCode);
  }

  OutP->NDR = NDR_record;

  OutP->flavor = In1P->flavor;
  OutP->Head.msgh_size = (mach_msg_size_t) (sizeof(Reply) - 2456) + (((4 * OutP->new_stateCnt)));

  __AfterRcvRpc(2407, "mach_exception_raise_state_identity")
}

#ifdef mig_external
mig_external
#else
extern
#endif /* mig_external */
    boolean_t mach_exc_server(mach_msg_header_t* InHeadP, mach_msg_header_t* OutHeadP);

#ifdef mig_external
mig_external
#else
extern
#endif /* mig_external */
    mig_routine_t mach_exc_server_routine(mach_msg_header_t* InHeadP);

/* Description of this subsystem, for use in direct RPC */
const struct catch_mach_exc_subsystem {
  mig_server_routine_t server; /* Server routine */
  mach_msg_id_t start;         /* Min routine number */
  mach_msg_id_t end;           /* Max routine number + 1 */
  unsigned int maxsize;        /* Max msg size */
  vm_address_t reserved;       /* Reserved */
  struct routine_descriptor    /*Array of routine descriptors */
      routine[3];
} catch_mach_exc_subsystem = {
    mach_exc_server_routine,
    2405,
    2408,
    (mach_msg_size_t) sizeof(union __ReplyUnion__catch_mach_exc_subsystem),
    (vm_address_t) 0,
    {
        {(mig_impl_routine_t) 0, (mig_stub_routine_t) _Xmach_exception_raise, 6, 0, (routine_arg_descriptor_t) 0,
         (mach_msg_size_t) sizeof(__Reply__mach_exception_raise_t)},
        {(mig_impl_routine_t) 0, (mig_stub_routine_t) _Xmach_exception_raise_state, 9, 0, (routine_arg_descriptor_t) 0,
         (mach_msg_size_t) sizeof(__Reply__mach_exception_raise_state_t)},
        {(mig_impl_routine_t) 0, (mig_stub_routine_t) _Xmach_exception_raise_state_identity, 11, 0,
         (routine_arg_descriptor_t) 0, (mach_msg_size_t) sizeof(__Reply__mach_exception_raise_state_identity_t)},
    }
};

mig_external boolean_t mach_exc_server(mach_msg_header_t* InHeadP, mach_msg_header_t* OutHeadP) {
  /*
   * typedef struct {
   * 	mach_msg_header_t Head;
   * 	NDR_record_t NDR;
   * 	kern_return_t RetCode;
   * } mig_reply_error_t;
   */

  mig_routine_t routine;

  OutHeadP->msgh_bits = MACH_MSGH_BITS(MACH_MSGH_BITS_REPLY(InHeadP->msgh_bits), 0);
  OutHeadP->msgh_remote_port = InHeadP->msgh_reply_port;
  /* Minimal size: routine() will update it if different */
  OutHeadP->msgh_size = (mach_msg_size_t) sizeof(mig_reply_error_t);
  OutHeadP->msgh_local_port = MACH_PORT_NULL;
  OutHeadP->msgh_id = InHeadP->msgh_id + 100;
  OutHeadP->msgh_reserved = 0;

  if ((InHeadP->msgh_id > 2407) || (InHeadP->msgh_id < 2405) ||
      ((routine = catch_mach_exc_subsystem.routine[InHeadP->msgh_id - 2405].stub_routine) == 0)) {
    ((mig_reply_error_t*) OutHeadP)->NDR = NDR_record;
    ((mig_reply_error_t*) OutHeadP)->RetCode = MIG_BAD_ID;
    return FALSE;
  }
  (*routine)(InHeadP, OutHeadP);
  return TRUE;
}

mig_external mig_routine_t mach_exc_server_routine(mach_msg_header_t* InHeadP) {
  int msgh_id;

  msgh_id = InHeadP->msgh_id - 2405;

  if ((msgh_id > 2) || (msgh_id < 0)) {
    return 0;
  }

  return catch_mach_exc_subsystem.routine[msgh_id].stub_routine;
}

```

`src/w1nj3ct/platform/darwin/impl/ptrace.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2022 TheOiseth
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "injector_internal.h"
#include <libproc.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/ptrace.h>
#define PTRACE_OR_RETURN(request, injector, addr, data)                                                                \
  do {                                                                                                                 \
    int rv = injector__ptrace(request, injector->pid, addr, data, #request);                                           \
    if (rv != 0) {                                                                                                     \
      return rv;                                                                                                       \
    }                                                                                                                  \
  } while (0)
static int set_ptrace_error(const char* request_name) {
  int err = errno;
  injector__set_errmsg("%s error : %s", request_name, strerror(errno));
  switch (err) {
  case EFAULT:
    return INJERR_INVALID_MEMORY_AREA;
  case EPERM:
    return INJERR_PERMISSION;
  case ESRCH:
    return INJERR_NO_PROCESS;
  }
  return INJERR_OTHER;
}

int injector__ptrace(int request, pid_t pid, long addr, long data, const char* request_name) {
  if (ptrace(request, pid, (caddr_t) addr, data) != 0) {
    return set_ptrace_error(request_name);
  }
  return 0;
}

int injector__ptrace_attach(const injector_t* injector) {
  PTRACE_OR_RETURN(PT_ATTACHEXC, injector, 0, 0);
  return 0;
}

int injector__ptrace_detach(const injector_t* injector) {
  PTRACE_OR_RETURN(PT_DETACH, injector, 0, 0);
  return 0;
}

int injector__ptrace_continue(const injector_t* injector) {
  PTRACE_OR_RETURN(PT_CONTINUE, injector, 1, 0);
  return 0;
}

int injector__ptrace_update(const injector_t* injector, long thread_port) {
  PTRACE_OR_RETURN(PT_THUPDATE, injector, thread_port, 0);
  return 0;
}
```

`src/w1nj3ct/platform/darwin/impl/remote_call.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2022 TheOiseth
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "injector_internal.h"
#include "mach_exc.h"
#include <stdlib.h>
#include <dlfcn.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/ptrace.h>
#include <signal.h>

// Before change shellcode, see:
// injector.c -> injector_detach
// exc_handler.c -> catch_mach_exception_raise
#if defined(__arm64__) || defined(__aarch64__)
char* shellcode = "\x00\x01\x3f\xd6" // blr x8
                  "\x00\x00\x00\x14" // b	   //infinity loop, we will terminate this thread later

                  // second thread
                  "\x00\x00\x20\xd4" // brk 0
                  "\x00\x01\x3f\xd6" // blr x8
                  "\x00\x00\x20\xd4" // brk 0
                  "\xc0\x03\x5f\xd6" // ret
    ;
int shellcode1_len = 8;
int shellcode_length = 24;
#else

char* shellcode =
    //"\x55"				//push   rbp
    //"\x48\x89\xE5"		//mov    rbp, rsp
    //"\x48\x83\xEC\x10"	//sub    rsp, 0x10
    //"\x48\x8D\x7D\xF8"	//lea    rdi, [rbp - 8]
    "\x90"     // nop
    "\x90"     // nop
    "\x90"     // nop
    "\xFF\xD0" // call   rax
    //"\x48\x83\xC4\x10"	//add    rsp, 0x10
    //"\x5D"				//pop    rbp
    "\xeb\xfe" // jmp 0	   //infinity loop, we will terminate this thread later

    // second thread
    "\xcc" // int3
    //"\x55"				//push   rbp
    //"\x48\x89\xe5"		//mov  rbp, rsp
    "\xff\xd0" // call rax
    //"\x5D" 				//pop    rbp
    "\xcc" // int3
    "\xc3" // ret
    ;
int shellcode1_len = 7;
int shellcode_length = 12;
#endif
int injector__call_function(injector_t* injector, long* retval, long function_addr, ...) {
  va_list ap;
  va_start(ap, function_addr);
  long arg1, arg2, arg3, arg4, arg5, arg6;
  arg1 = va_arg(ap, long);
  arg2 = va_arg(ap, long);
  arg3 = va_arg(ap, long);
  arg4 = va_arg(ap, long);
  arg5 = va_arg(ap, long);
  arg6 = va_arg(ap, long);
  va_end(ap);
  int rv;

  if (injector->shellcode_writed == 0) {
    pcfmt_t pcfmt = (pcfmt_t) dlsym(RTLD_DEFAULT, "pthread_create_from_mach_thread");

    rv = injector__write(injector, injector->code_addr, shellcode, shellcode_length);
    if (rv != 0) {
      return rv;
    }
    if (pcfmt == 0) {
      // char* legacy_append =
      //"\xFF\xD0"		//call rax
      //"\xcc"			//int3
      //;
      // rv = injector__write(injector, injector->code_addr, legacy_append, 3);

      // It turns out that we can call pthread_create in mach thread without _pthread_set_self on MacOS < 10.12
      pcfmt = (pcfmt_t) dlsym(RTLD_DEFAULT, "pthread_create");
    }
    rv = injector__protect(injector, injector->code_addr, injector->code_size, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);
    if (rv != 0) {
      return rv;
    }
    injector->shellcode_writed = 1;
    injector->code2_addr = injector->code_addr + shellcode1_len;

    thread_act_t mach_thread;
#if defined(__arm64__) || defined(__aarch64__)
    arm_thread_state64_t state;
    memset(&state, '\0', sizeof(state));
    state.__pc = injector->code_addr;
    state.__sp = injector->stack;
    state.__x[8] = (uint64_t) pcfmt;
    state.__x[0] = injector->stack - 32;

    state.__x[1] = 0;
    state.__x[2] = injector->code2_addr;
    state.__x[3] = 0;
    rv = thread_create_running(
        injector->remote_task, ARM_THREAD_STATE64, (thread_state_t) &state, ARM_THREAD_STATE64_COUNT, &mach_thread
    );
#else
    x86_thread_state64_t state;
    memset(&state, '\0', sizeof(state));
    state.__rip = injector->code_addr;
    state.__rsp = injector->stack - 0x10;
    state.__rbp = injector->stack;
    if (pcfmt == NULL) {
      state.__rax = (uint64_t) dlsym(RTLD_DEFAULT, "_pthread_set_self");
      state.__rdi = 0;
      injector->func_addr = (uint64_t) dlsym(RTLD_DEFAULT, "pthread_create");
      injector->arg1 = injector->stack - 0x8;
      injector->arg2 = 0;
      injector->arg3 = injector->code2_addr;
      injector->arg4 = 0;
    } else {
      state.__rax = (uint64_t) pcfmt;
      state.__rdi = injector->stack - 0x8; //&thread
    }

    state.__rsi = 0;
    state.__rdx = injector->code2_addr;
    state.__rcx = 0;

    rv = thread_create_running(
        injector->remote_task, x86_THREAD_STATE64, (thread_state_t) &state, x86_THREAD_STATE64_COUNT, &mach_thread
    );
#endif
    if (rv != 0) {
      injector__set_errmsg("%s error : %s", "CREATE_THREAD", mach_error_string(rv));
      return INJERR_ERROR_IN_TARGET;
    }
    injector->mach_thread = mach_thread;
    if (pcfmt == NULL) {
      injector->handle_action = TRAP_SETREGS;
      injector__handle_exc(injector);
    }
    injector->func_addr = function_addr;
    injector->arg1 = arg1;
    injector->arg2 = arg2;
    injector->arg3 = arg3;
    injector->arg4 = arg4;
    injector->arg5 = arg5;
    injector->arg6 = arg6;

    injector->handle_action = TRAP_SETREGS;
    injector__handle_exc(injector);
  } else {
#if defined(__arm64__) || defined(__aarch64__)

    mach_msg_type_number_t state_count = ARM_THREAD_STATE64_COUNT;
    arm_thread_state64_t state;
    rv = thread_get_state(injector->remote_thread, ARM_THREAD_STATE64, (thread_state_t) &state, &state_count);
    if (rv != 0) {
      injector__set_errmsg("%s error : %s", "THREAD_GET_STATE", mach_error_string(rv));
      return INJERR_ERROR_IN_TARGET;
    }
    state.__pc = injector->code2_addr + 4;
    state.__x[0] = arg1;
    state.__x[1] = arg2;
    state.__x[2] = arg3;
    state.__x[3] = arg4;
    state.__x[4] = arg5;
    state.__x[5] = arg6;
    state.__x[8] = function_addr;
    rv = thread_set_state(
        injector->remote_thread, ARM_THREAD_STATE64, (thread_state_t) &state, ARM_THREAD_STATE64_COUNT
    );
#else
    mach_msg_type_number_t state_count = x86_THREAD_STATE64_COUNT;
    x86_thread_state64_t state;
    rv = thread_get_state(injector->remote_thread, x86_THREAD_STATE64, (thread_state_t) &state, &state_count);
    if (rv != 0) {
      injector__set_errmsg("%s error : %s", "THREAD_GET_STATE", mach_error_string(rv));
      return INJERR_ERROR_IN_TARGET;
    }
    state.__rip = injector->code2_addr + 1;
    state.__rax = function_addr;
    state.__rdi = arg1;
    state.__rsi = arg2;
    state.__rdx = arg3;
    state.__rcx = arg4;
    state.__r8 = arg5;
    state.__r9 = arg6;
    rv = thread_set_state(
        injector->remote_thread, x86_THREAD_STATE64, (thread_state_t) &state, x86_THREAD_STATE64_COUNT
    );
#endif
    if (rv != 0) {
      injector__set_errmsg("%s error : %s", "THREAD_SET_STATE", mach_error_string(rv));
      return INJERR_ERROR_IN_TARGET;
    }
    rv = thread_resume(injector->remote_thread);
    if (rv != 0) {
      injector__set_errmsg("%s error : %s", "THREAD_RESUME", mach_error_string(rv));
      return INJERR_ERROR_IN_TARGET;
    }
  }

  injector->handle_action = TRAP_GETREGS;
  injector__handle_exc(injector);
  if (injector->handle_err != 0) {
    return injector->handle_err;
  }
  *retval = injector->retval;
  return 0;
}

```

`src/w1nj3ct/platform/darwin/impl/util.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2022 TheOiseth
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "injector_internal.h"
#include <stdarg.h>
#include <libproc.h>
#include <bsm/libbsm.h>
#include <sys/sysctl.h>
#include <sys/types.h>
#include <unistd.h>

char injector__errmsg[512];
char injector__errmsg_is_set;

void injector__set_errmsg(const char* format, ...) {
  va_list ap;
  int rv;

  /* prevent the error message from being overwritten. */
  if (injector__errmsg_is_set) {
    return;
  }
  injector__errmsg_is_set = 1;

  va_start(ap, format);
  rv = vsnprintf(injector__errmsg, sizeof(injector__errmsg), format, ap);
  va_end(ap);
  if (rv == -1 || rv >= sizeof(injector__errmsg)) {
    injector__errmsg[sizeof(injector__errmsg) - 1] = '\0';
  }
}
#ifndef P_TRANSLATED
#define P_TRANSLATED 0x00020000
#endif
int injector__get_process_arch(pid_t pid, arch_t* arch) {
  int mib[CTL_MAXNAME] = {0};
  mib[0] = CTL_KERN;
  mib[1] = KERN_PROC;
  mib[2] = KERN_PROC_PID;
  mib[3] = pid;
  size_t length = 4;
  struct kinfo_proc proc_info = {0};
  size_t size = sizeof(proc_info);

  if (sysctl(mib, (u_int) length, &proc_info, &size, NULL, 0) != 0) {
    *arch = ARCH_UNKNOWN;
    return INJERR_SUCCESS;
  }
  if (size == 0) {
    injector__set_errmsg("Process %d not found", pid);
    return INJERR_NO_PROCESS;
  }

  if (P_TRANSLATED == (P_TRANSLATED & proc_info.kp_proc.p_flag)) {
    if (P_LP64 == (P_LP64 & proc_info.kp_proc.p_flag)) {
      *arch = ARCH_X86_64;
      return INJERR_SUCCESS;
    } else {
      *arch = ARCH_I386;
      return INJERR_SUCCESS;
    }
  } else {
    arch_t sys_arch = injector__get_system_arch();
    if (sys_arch == ARCH_ARM64) {
      *arch = ARCH_ARM64;
      return INJERR_SUCCESS;
    }
#if defined(__arm64__) || defined(__aarch64__)
    if (sys_arch == ARCH_UNKNOWN) {
      *arch = ARCH_ARM64;
      return INJERR_SUCCESS;
    }
#endif
  }

  if (P_LP64 == (P_LP64 & proc_info.kp_proc.p_flag)) {
    *arch = ARCH_X86_64;
    return INJERR_SUCCESS;
  }
  *arch = ARCH_I386;
  return INJERR_SUCCESS;
}

#ifndef CPU_TYPE_ARM64
#define CPU_TYPE_ARM ((cpu_type_t) 12)
#define CPU_ARCH_ABI64 0x01000000
#define CPU_TYPE_ARM64 (CPU_TYPE_ARM | CPU_ARCH_ABI64)
#endif
arch_t injector__get_system_arch() {
  size_t size;
  cpu_type_t type = -1;
  int mib[CTL_MAXNAME] = {0};
  size_t length = CTL_MAXNAME;

  if (sysctlnametomib("sysctl.proc_cputype", mib, &length) != 0) {
    return ARCH_UNKNOWN;
  }

  mib[length] = getpid();
  length++;
  size = sizeof(cpu_type_t);

  if (sysctl(mib, (u_int) length, &type, &size, 0, 0) != 0) {
    return ARCH_UNKNOWN;
  }
  if (CPU_TYPE_X86_64 == type) {
    return ARCH_X86_64;
  }

  if (CPU_TYPE_ARM64 == type) {
    return ARCH_ARM64;
  }
  return ARCH_UNKNOWN;
}
const char* injector__arch2name(arch_t arch) {
  switch (arch) {
  case ARCH_X86_64:
    return "x86_64";
  case ARCH_I386:
    return "i386";
  case ARCH_ARM64:
    return "ARM64";
  case ARCH_POWERPC_64:
    return "PowerPC 64-bit";
  case ARCH_POWERPC:
    return "PowerPC";
  case ARCH_UNKNOWN:
    return "Unknown";
  }
  return "?";
}
```

`src/w1nj3ct/platform/linux/impl/elf.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2018 Kubo Takehiro <kubo@jiubao.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <regex.h>
#include <elf.h>
#include <glob.h>
#include <sys/sysmacros.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/statfs.h>
#include <limits.h>
#include <unistd.h>
#include "injector_internal.h"

#ifdef __LP64__
#define Elf_Ehdr Elf64_Ehdr
#define Elf_Shdr Elf64_Shdr
#define Elf_Sym Elf64_Sym
#else
#define Elf_Ehdr Elf32_Ehdr
#define Elf_Shdr Elf32_Shdr
#define Elf_Sym Elf32_Sym
#endif

// #define INJECTOR_DEBUG_ELF_C 1

#ifdef INJECTOR_DEBUG_ELF_C
#undef DEBUG
#define DEBUG(...) fprintf(stderr, __VA_ARGS__)
#else
#undef DEBUG
#define DEBUG(...)                                                                                                     \
  do {                                                                                                                 \
  } while (0)
#endif

typedef struct {
  int dlfunc_type; /* -1, DLFUNC_POSIX or DLFUNC_INTERNAL */
  FILE* fp;
  size_t libc_addr;
  size_t str_offset;
  size_t str_size;
  size_t sym_offset;
  size_t sym_num;
  size_t sym_entsize;
} param_t;

static int search_and_open_libc(FILE** fp_out, pid_t pid, size_t* addr, libc_type_t* libc_type);
static int open_libc(FILE** fp_out, const char* path, pid_t pid, dev_t dev, ino_t ino);
static FILE* fopen_with_ino(const char* path, dev_t dev, ino_t ino);
static int read_elf_ehdr(FILE* fp, Elf_Ehdr* ehdr);
static int read_elf_shdr(FILE* fp, Elf_Shdr* shdr, size_t shdr_size);
static int read_elf_sym(FILE* fp, Elf_Sym* sym, size_t sym_size);
static int find_symbol_addr(size_t* addr, param_t* prm, const char* posix_name, const char* internal_name);
static size_t find_strtab_offset(const param_t* prm, const char* name);

int injector__collect_libc_information(injector_t* injector) {
  pid_t pid = injector->pid;
  FILE* fp;
  Elf_Ehdr ehdr;
  Elf_Shdr shdr;
  param_t prm = {
      -1,
  };
  size_t shstrtab_offset;
  int idx;
  int rv;

  rv = search_and_open_libc(&fp, pid, &prm.libc_addr, &injector->libc_type);
  if (rv != 0) {
    return rv;
  }
  rv = read_elf_ehdr(fp, &ehdr);
  if (rv != 0) {
    goto cleanup;
  }
  fseek(fp, ehdr.e_shoff + ehdr.e_shstrndx * ehdr.e_shentsize, SEEK_SET);
  rv = read_elf_shdr(fp, &shdr, ehdr.e_shentsize);
  if (rv != 0) {
    goto cleanup;
  }
  shstrtab_offset = shdr.sh_offset;

  fseek(fp, ehdr.e_shoff, SEEK_SET);
  for (idx = 0; idx < ehdr.e_shnum; idx++) {
    fpos_t pos;
    char buf[8];

    rv = read_elf_shdr(fp, &shdr, ehdr.e_shentsize);
    if (rv != 0) {
      goto cleanup;
    }
    switch (shdr.sh_type) {
    case SHT_STRTAB:
      fgetpos(fp, &pos);
      fseek(fp, shstrtab_offset + shdr.sh_name, SEEK_SET);
      fgets(buf, sizeof(buf), fp);
      fsetpos(fp, &pos);
      if (strcmp(buf, ".dynstr") == 0) {
        prm.str_offset = shdr.sh_offset;
        prm.str_size = shdr.sh_size;
      }
      break;
    case SHT_DYNSYM:
      fgetpos(fp, &pos);
      fseek(fp, shstrtab_offset + shdr.sh_name, SEEK_SET);
      fgets(buf, sizeof(buf), fp);
      fsetpos(fp, &pos);
      if (strcmp(buf, ".dynsym") == 0) {
        prm.sym_offset = shdr.sh_offset;
        prm.sym_entsize = shdr.sh_entsize;
        prm.sym_num = shdr.sh_size / shdr.sh_entsize;
      }
      break;
    }
    if (prm.sym_offset != 0 && prm.str_offset != 0) {
      break;
    }
  }
  if (idx == ehdr.e_shnum) {
    injector__set_errmsg("failed to find the .dynstr and .dynsym sections.");
    rv = INJERR_INVALID_ELF_FORMAT;
    goto cleanup;
  }

  prm.fp = fp;

  rv = find_symbol_addr(&injector->dlopen_addr, &prm, "dlopen", "__libc_dlopen_mode");
  if (rv != 0) {
    goto cleanup;
  }

  rv = find_symbol_addr(&injector->dlclose_addr, &prm, "dlclose", "__libc_dlclose");
  if (rv != 0) {
    goto cleanup;
  }

  rv = find_symbol_addr(&injector->dlsym_addr, &prm, "dlsym", "__libc_dlsym");
  if (rv != 0) {
    goto cleanup;
  }

  if (prm.dlfunc_type != DLFUNC_INTERNAL) {
    rv = find_symbol_addr(&injector->dlerror_addr, &prm, "dlerror", NULL);
    if (rv != 0) {
      goto cleanup;
    }
  } else {
    injector->dlerror_addr = 0;
  }

#ifdef INJECTOR_HAS_INJECT_IN_CLONED_THREAD
  rv = find_symbol_addr(&injector->clone_addr, &prm, "clone", "clone");
  if (rv != 0) {
    goto cleanup;
  }
#endif

  rv = find_symbol_addr(NULL, &prm, "gnu_get_libc_release", "gnu_get_libc_release");
  if (rv == 0) {
    /* GNU libc */
    injector->libc_type = LIBC_TYPE_GNU;
  }

  injector->dlfunc_type = prm.dlfunc_type;
  injector->code_addr = prm.libc_addr + ehdr.e_entry;

  switch (ehdr.e_machine) {
  case EM_X86_64:
    if (ehdr.e_ident[EI_CLASS] == ELFCLASS64) {
      /* LP64 */
      injector->arch = ARCH_X86_64;
      injector->sys_mmap = 9;
      injector->sys_mprotect = 10;
      injector->sys_munmap = 11;
    } else {
      /* ILP32 */
      injector->arch = ARCH_X86_64_X32;
      injector->sys_mmap = 0x40000000 + 9;
      injector->sys_mprotect = 0x40000000 + 10;
      injector->sys_munmap = 0x40000000 + 11;
    }
    break;
  case EM_386:
    injector->arch = ARCH_I386;
    injector->sys_mmap = 192;
    injector->sys_mprotect = 125;
    injector->sys_munmap = 91;
    break;
  case EM_AARCH64:
    injector->arch = ARCH_ARM64;
    injector->sys_mmap = 222;
    injector->sys_mprotect = 226;
    injector->sys_munmap = 215;
    break;
  case EM_ARM:
    if (EF_ARM_EABI_VERSION(ehdr.e_flags) == 0) {
      injector__set_errmsg("ARM OABI target process isn't supported.");
      rv = INJERR_UNSUPPORTED_TARGET;
      goto cleanup;
    }
    if (injector->code_addr & 1u) {
      injector->code_addr &= ~1u;
      injector->arch = ARCH_ARM_EABI_THUMB;
    } else {
      injector->arch = ARCH_ARM_EABI;
    }
    injector->sys_mmap = 192;
    injector->sys_mprotect = 125;
    injector->sys_munmap = 91;
    break;
  case EM_MIPS:
    if (ehdr.e_ident[EI_CLASS] == ELFCLASS64) {
      /* MIPS 64 */
      injector->arch = ARCH_MIPS_64;
      injector->sys_mmap = 5000 + 9;
      injector->sys_mprotect = 5000 + 10;
      injector->sys_munmap = 5000 + 11;
    } else if (ehdr.e_flags & EF_MIPS_ABI2) {
      /* MIPS N32 */
      injector->arch = ARCH_MIPS_N32;
      injector->sys_mmap = 6000 + 9;
      injector->sys_mprotect = 6000 + 10;
      injector->sys_munmap = 6000 + 11;
    } else {
      /* MIPS O32 */
      injector->arch = ARCH_MIPS_O32;
      injector->sys_mmap = 4000 + 90;
      injector->sys_mprotect = 4000 + 125;
      injector->sys_munmap = 4000 + 91;
    }
    break;
  case EM_PPC64:
    injector->arch = ARCH_POWERPC_64;
    injector->sys_mmap = 90;
    injector->sys_mprotect = 125;
    injector->sys_munmap = 91;
    break;
  case EM_PPC:
    injector->arch = ARCH_POWERPC;
    injector->sys_mmap = 90;
    injector->sys_mprotect = 125;
    injector->sys_munmap = 91;
    break;
#ifdef EM_RISCV
  case EM_RISCV:
    if (ehdr.e_ident[EI_CLASS] == ELFCLASS64) {
      injector->arch = ARCH_RISCV_64;
    } else {
      injector->arch = ARCH_RISCV_32;
    }
    injector->sys_mmap = 222;
    injector->sys_mprotect = 226;
    injector->sys_munmap = 215;
    break;
#endif
  default:
    injector__set_errmsg("Unknown target process architecture: 0x%04x", ehdr.e_machine);
    rv = INJERR_UNSUPPORTED_TARGET;
    goto cleanup;
  }
  rv = 0;
cleanup:
  fclose(fp);
  return rv;
}

static int search_and_open_libc(FILE** fp_out, pid_t pid, size_t* addr, libc_type_t* libc_type) {
  char buf[512];
  FILE* fp = NULL;
  regex_t reg;
  regmatch_t match;

  sprintf(buf, "/proc/%d/maps", pid);
  fp = fopen(buf, "r");
  if (fp == NULL) {
    injector__set_errmsg("failed to open %s. (error: %s)", buf, strerror(errno));
    return INJERR_OTHER;
  }
  DEBUG("Open %s\n", buf);
  /* /libc.so.6 or /libc-2.{DIGITS}.so or /ld-musl-{arch}.so.1 */
  if (regcomp(&reg, "/libc(\\.so\\.6|-2\\.[0-9]+\\.so)|/ld-musl-.+?\\.so\\.1", REG_EXTENDED) != 0) {
    injector__set_errmsg("regcomp failed!");
    return INJERR_OTHER;
  }
  while (fgets(buf, sizeof(buf), fp) != NULL) {
    unsigned long saddr, eaddr;
    unsigned long long offset, inode;
    unsigned int dev_major, dev_minor;
    DEBUG("   %s", buf);
    if (sscanf(buf, "%lx-%lx %*s %llx %x:%x %llu", &saddr, &eaddr, &offset, &dev_major, &dev_minor, &inode) != 6) {
      continue;
    }
    if (offset != 0) {
      continue;
    }
    if (regexec(&reg, buf, 1, &match, 0) != 0) {
      continue;
    }
    char* p = buf + match.rm_eo;
    if (strcmp(p, " (deleted)\n") == 0) {
      injector__set_errmsg("The C library when the process started was removed");
      fclose(fp);
      regfree(&reg);
      return INJERR_NO_LIBRARY;
    }
    if (strcmp(p, "\n") != 0) {
      continue;
    }
    fclose(fp);
    *addr = saddr;
    if (strstr(buf, "/ld-musl-") != NULL) {
      *libc_type = LIBC_TYPE_MUSL;
    } else {
      *libc_type = LIBC_TYPE_GNU;
    }
    regfree(&reg);
    *p = '\0';
    p = strchr(buf, '/');
    DEBUG(" libc in /proc/PID/maps: '%s'\n", p);
    return open_libc(fp_out, p, pid, makedev(dev_major, dev_minor), inode);
  }
  fclose(fp);
  injector__set_errmsg("Could not find libc");
  regfree(&reg);
  return INJERR_NO_LIBRARY;
}

static int open_libc(FILE** fp_out, const char* path, pid_t pid, dev_t dev, ino_t ino) {
  FILE* fp = fopen_with_ino(path, dev, ino);

  if (fp != NULL) {
    goto found;
  }

  /* workaround for LXD */
  const char* p = strstr(path, "/rootfs/");
  if (p != NULL) {
    fp = fopen_with_ino(p + 7, dev, ino);
    if (fp != NULL) {
      goto found;
    }
  }

  // workaround for Flatpak (https://flatpak.org/)
  //
  // libc is under /proc/<PID>/root.
  // The idea came from https://github.com/kubo/injector/pull/36.
  char buf[PATH_MAX];
  snprintf(buf, sizeof(buf), "/proc/%d/root%s", pid, path);
  buf[sizeof(buf) - 1] = '\0';
  fp = fopen_with_ino(buf, dev, ino);
  if (fp != NULL) {
    goto found;
  }

  // workaround for Snap
  //
  // libc is in a base snap (https://snapcraft.io/docs/base-snaps),
  glob_t globbuf;
  if (glob("/snap/core*/*", GLOB_NOSORT, NULL, &globbuf) == 0) {
    size_t idx;
    for (idx = 0; idx < globbuf.gl_pathc; idx++) {
      char buf[512];
      snprintf(buf, sizeof(buf), "%s%s", globbuf.gl_pathv[idx], path);
      buf[sizeof(buf) - 1] = '\0';
      fp = fopen_with_ino(buf, dev, ino);
      if (fp != NULL) {
        globfree(&globbuf);
        goto found;
      }
    }
    globfree(&globbuf);
  }
  injector__set_errmsg("failed to open %s. (dev:0x%" PRIx64 ", ino:%lu)", path, dev, ino);
  return INJERR_NO_LIBRARY;
found:
  *fp_out = fp;
  return 0;
}

static inline int is_on_overlay_fs(int fd) {
  struct statfs sbuf;
  if (fstatfs(fd, &sbuf) != 0) {
    DEBUG(" fstatfs() error %s\n", strerror(errno));
    return -1;
  }
#ifndef OVERLAYFS_SUPER_MAGIC
#define OVERLAYFS_SUPER_MAGIC 0x794c7630
#endif
  return (sbuf.f_type == OVERLAYFS_SUPER_MAGIC) ? 1 : 0;
}

static FILE* fopen_with_ino(const char* path, dev_t dev, ino_t ino) {
  DEBUG("   checking: '%s' ...", path);
  struct stat sbuf;
  FILE* fp = fopen(path, "r");

  if (fp == NULL) {
    DEBUG(" fopen() error %s\n", strerror(errno));
    return NULL;
  }

  if (fstat(fileno(fp), &sbuf) != 0) {
    DEBUG(" fstat() error %s\n", strerror(errno));
    goto cleanup;
  }
  if (sbuf.st_ino != ino) {
    DEBUG(
        " unexpected inode number: expected %llu but %llu\n", (unsigned long long) ino, (unsigned long long) sbuf.st_ino
    );
    goto cleanup;
  }
  if (sbuf.st_dev != dev) {
    int rv = is_on_overlay_fs(fileno(fp));
    if (rv < 0) {
      goto cleanup;
    }
    if (rv != 1) {
      DEBUG(
          " unexpected device number: expected %llu but %llu\n", (unsigned long long) dev,
          (unsigned long long) sbuf.st_dev
      );
      goto cleanup;
    }
    DEBUG(
        " ignore device number mismatch (expected %llu but %llu) on overlay file system  ... ",
        (unsigned long long) dev, (unsigned long long) sbuf.st_dev
    );
  }

  DEBUG(" OK\n");
  return fp;
cleanup:
  fclose(fp);
  return NULL;
}

static int read_elf_ehdr(FILE* fp, Elf_Ehdr* ehdr) {
  if (fread(ehdr, sizeof(*ehdr), 1, fp) != 1) {
    injector__set_errmsg("failed to read ELF header. (error: %s)", strerror(errno));
    return INJERR_INVALID_ELF_FORMAT;
  }
  if (memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0) {
    injector__set_errmsg(
        "Invalid ELF header: 0x%02x,0x%02x,0x%02x,0x%02x", ehdr->e_ident[0], ehdr->e_ident[1], ehdr->e_ident[2],
        ehdr->e_ident[3]
    );
    return INJERR_INVALID_ELF_FORMAT;
  }
  switch (ehdr->e_ident[EI_CLASS]) {
  case ELFCLASS32:
#ifdef __LP64__
  {
    Elf32_Ehdr* ehdr32 = (Elf32_Ehdr*) ehdr;
    /* copy from last */
    ehdr->e_shstrndx = ehdr32->e_shstrndx;
    ehdr->e_shnum = ehdr32->e_shnum;
    ehdr->e_shentsize = ehdr32->e_shentsize;
    ehdr->e_phnum = ehdr32->e_phnum;
    ehdr->e_phentsize = ehdr32->e_phentsize;
    ehdr->e_ehsize = ehdr32->e_ehsize;
    ehdr->e_flags = ehdr32->e_flags;
    ehdr->e_shoff = ehdr32->e_shoff;
    ehdr->e_phoff = ehdr32->e_phoff;
    ehdr->e_entry = ehdr32->e_entry;
    ehdr->e_version = ehdr32->e_version;
    ehdr->e_machine = ehdr32->e_machine;
    ehdr->e_type = ehdr32->e_type;
  }
#endif
  break;
  case ELFCLASS64:
#ifndef __LP64__
    injector__set_errmsg("64-bit target process isn't supported by 32-bit process.");
    return INJERR_UNSUPPORTED_TARGET;
#endif
    break;
  default:
    injector__set_errmsg("Invalid ELF class: 0x%x", ehdr->e_ident[EI_CLASS]);
    return INJERR_UNSUPPORTED_TARGET;
  }
  return 0;
}

static int read_elf_shdr(FILE* fp, Elf_Shdr* shdr, size_t shdr_size) {
  if (fread(shdr, shdr_size, 1, fp) != 1) {
    injector__set_errmsg("failed to read a section header. (error: %s)", strerror(errno));
    return INJERR_INVALID_ELF_FORMAT;
  }
#ifdef __LP64__
  if (shdr_size == sizeof(Elf32_Shdr)) {
    Elf32_Shdr shdr32 = *(Elf32_Shdr*) shdr;
    shdr->sh_name = shdr32.sh_name;
    shdr->sh_type = shdr32.sh_type;
    shdr->sh_flags = shdr32.sh_flags;
    shdr->sh_addr = shdr32.sh_addr;
    shdr->sh_offset = shdr32.sh_offset;
    shdr->sh_size = shdr32.sh_size;
    shdr->sh_link = shdr32.sh_link;
    shdr->sh_info = shdr32.sh_info;
    shdr->sh_addralign = shdr32.sh_addralign;
    shdr->sh_entsize = shdr32.sh_entsize;
  }
#endif
  return 0;
}

static int read_elf_sym(FILE* fp, Elf_Sym* sym, size_t sym_size) {
  if (fread(sym, sym_size, 1, fp) != 1) {
    injector__set_errmsg("failed to read a symbol table entry. (error: %s)", strerror(errno));
    return INJERR_INVALID_ELF_FORMAT;
  }
#ifdef __LP64__
  if (sym_size == sizeof(Elf32_Sym)) {
    Elf32_Sym sym32 = *(Elf32_Sym*) sym;
    sym->st_name = sym32.st_name;
    sym->st_value = sym32.st_value;
    sym->st_size = sym32.st_size;
    sym->st_info = sym32.st_info;
    sym->st_other = sym32.st_other;
    sym->st_shndx = sym32.st_shndx;
  }
#endif
  return 0;
}

static int find_symbol_addr(size_t* addr, param_t* prm, const char* posix_name, const char* internal_name) {
  size_t st_name;

  switch (prm->dlfunc_type) {
  case -1:
    st_name = find_strtab_offset(prm, posix_name);
    if (st_name != 0) {
      prm->dlfunc_type = DLFUNC_POSIX;
    } else {
      prm->dlfunc_type = DLFUNC_INTERNAL;
      st_name = find_strtab_offset(prm, internal_name);
    }
    break;
  case DLFUNC_POSIX:
    st_name = find_strtab_offset(prm, posix_name);
    break;
  case DLFUNC_INTERNAL:
    st_name = find_strtab_offset(prm, internal_name);
    break;
  }

  if (addr == NULL) {
    return st_name != 0 ? 0 : INJERR_NO_FUNCTION;
  }

  if (st_name != 0) {
    Elf_Sym sym;
    int idx;
    int rv;

    fseek(prm->fp, prm->sym_offset, SEEK_SET);
    for (idx = 0; idx < prm->sym_num; idx++) {
      rv = read_elf_sym(prm->fp, &sym, prm->sym_entsize);
      if (rv != 0) {
        return rv;
      }
      if (sym.st_name == st_name) {
        *addr = prm->libc_addr + sym.st_value;
        return 0;
      }
    }
  }
  injector__set_errmsg(
      "failed to find %s%s%s in the .dynstr section.", posix_name, internal_name ? "/" : "",
      internal_name ? internal_name : ""
  );
  return INJERR_NO_FUNCTION;
}

static size_t find_strtab_offset(const param_t* prm, const char* name) {
  size_t off;
  size_t idx = 0;

  fseek(prm->fp, prm->str_offset, SEEK_SET);
  for (off = 0; off < prm->str_size; off++) {
    int c = fgetc(prm->fp);
    if (c == EOF) {
      return 0;
    }
    if (c == name[idx]) {
      if (c == 0) {
        return off - idx;
      }
      idx++;
    } else {
      idx = 0;
    }
  }
  return 0;
}

```

`src/w1nj3ct/platform/linux/impl/injector.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2018-2023 Kubo Takehiro <kubo@jiubao.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif
#include <alloca.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <errno.h>
#include <dlfcn.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>
#include "injector_internal.h"

static inline size_t remote_mem_size(injector_t* injector) { return 2 * injector->data_size + injector->stack_size; }

int injector_attach(injector_t** injector_out, pid_t pid) {
  injector_t* injector;
  int status;
  intptr_t retval;
  int prot;
  int rv = 0;

  injector__errmsg_is_set = 0;

  injector = calloc(1, sizeof(injector_t));
  if (injector == NULL) {
    injector__set_errmsg("malloc error: %s", strerror(errno));
    return INJERR_NO_MEMORY;
  }
  injector->pid = pid;
  rv = injector__attach_process(injector);
  if (rv != 0) {
    goto error_exit;
  }
  injector->attached = 1;

  do {
    rv = waitpid(pid, &status, 0);
  } while (rv == -1 && errno == EINTR);
  if (rv == -1) {
    injector__set_errmsg("waitpid error while attaching: %s", strerror(errno));
    rv = INJERR_WAIT_TRACEE;
    goto error_exit;
  }

  rv = injector__collect_libc_information(injector);
  if (rv != 0) {
    goto error_exit;
  }
  rv = injector__get_regs(injector, &injector->regs);
  if (rv != 0) {
    goto error_exit;
  }
  rv = injector__read(injector, injector->code_addr, &injector->backup_code, sizeof(injector->backup_code));
  if (rv != 0) {
    goto error_exit;
  }

  injector->data_size = sysconf(_SC_PAGESIZE);
  injector->stack_size = 2 * 1024 * 1024;

  rv = injector__call_syscall(
      injector, &retval, injector->sys_mmap, 0, remote_mem_size(injector), PROT_READ | PROT_WRITE,
      MAP_PRIVATE | MAP_ANONYMOUS | MAP_GROWSDOWN, -1, 0
  );
  if (rv != 0) {
    goto error_exit;
  }
  if (retval == -1) {
    injector__set_errmsg("mmap error: %s", strerror(errno));
    rv = INJERR_ERROR_IN_TARGET;
    goto error_exit;
  }
  injector->mmapped = 1;
  injector->data = (size_t) retval;
  injector->stack = (size_t) retval + 2 * injector->data_size;
#ifdef INJECTOR_HAS_INJECT_IN_CLONED_THREAD
  injector->shellcode = (size_t) retval + 1 * injector->data_size;
  prot = PROT_READ | PROT_EXEC;
#else
  prot = PROT_NONE;
#endif
  rv = injector__call_syscall(
      injector, &retval, injector->sys_mprotect, injector->data + injector->data_size, injector->data_size, prot
  );
  if (rv != 0) {
    goto error_exit;
  }
  if (retval != 0) {
    injector__set_errmsg("mprotect error: %s", strerror(errno));
    rv = INJERR_ERROR_IN_TARGET;
    goto error_exit;
  }
#ifdef INJECTOR_HAS_INJECT_IN_CLONED_THREAD
  rv = injector__write(injector, injector->shellcode, &injector_shellcode, injector_shellcode_size);
  if (rv != 0) {
    return rv;
  }
#endif

  *injector_out = injector;
  return 0;
error_exit:
  injector_detach(injector);
  return rv;
}

int injector_inject(injector_t* injector, const char* path, void** handle) {
  char abspath[PATH_MAX];
  int dlflags = RTLD_LAZY;
  size_t len;
  int rv;
  intptr_t retval;

  injector__errmsg_is_set = 0;

  if (path[0] == '/') {
    len = strlen(path) + 1;
  } else if (realpath(path, abspath) != NULL) {
    path = abspath;
    len = strlen(abspath) + 1;
  } else {
    injector__set_errmsg("failed to get the full path of '%s': %s", path, strerror(errno));
    return INJERR_FILE_NOT_FOUND;
  }

  if (len > injector->data_size) {
    injector__set_errmsg("too long file path: %s", path);
    return INJERR_FILE_NOT_FOUND;
  }

  rv = injector__write(injector, injector->data, path, len);
  if (rv != 0) {
    return rv;
  }
  if (injector->dlfunc_type == DLFUNC_INTERNAL) {
#define __RTLD_DLOPEN 0x80000000 // glibc internal flag
    dlflags |= __RTLD_DLOPEN;
  }
  rv = injector__call_function(injector, &retval, injector->dlopen_addr, injector->data, dlflags);
  if (rv != 0) {
    return rv;
  }
  if (retval == 0) {
    char buf[256 + 1] = {
        0,
    };
    if (injector->dlerror_addr != 0) {
      rv = injector__call_function(injector, &retval, injector->dlerror_addr);
      if (rv == 0 && retval != 0) {
        injector__read(injector, retval, buf, sizeof(buf) - 1);
      }
    }
    if (buf[0] != '\0') {
      injector__set_errmsg("dlopen failed: %s", buf);
    } else {
      injector__set_errmsg("dlopen failed");
    }
    return INJERR_ERROR_IN_TARGET;
  }
  if (handle != NULL) {
    *handle = (void*) retval;
  }
  return 0;
}

#ifdef INJECTOR_HAS_INJECT_IN_CLONED_THREAD
int injector_inject_in_cloned_thread(injector_t* injector, const char* path, void** handle_out) {
  void* data;
  injector_shellcode_arg_t* arg;
  const size_t file_path_offset = offsetof(injector_shellcode_arg_t, file_path);
  void* const invalid_handle = (void*) -3;
  char abspath[PATH_MAX];
  size_t pathlen;
  int rv;
  intptr_t retval;

  injector__errmsg_is_set = 0;

  if (injector->arch != ARCH_X86_64) {
    injector__set_errmsg("injector_inject_in_cloned_thread doesn't support %s.", injector__arch2name(injector->arch));
    return INJERR_UNSUPPORTED_TARGET;
  }

  if (realpath(path, abspath) == NULL) {
    injector__set_errmsg("failed to get the full path of '%s': %s", path, strerror(errno));
    return INJERR_FILE_NOT_FOUND;
  }
  pathlen = strlen(abspath) + 1;

  if (file_path_offset + pathlen > injector->data_size) {
    injector__set_errmsg("too long path name: %s", path);
    return INJERR_FILE_NOT_FOUND;
  }

  data = alloca(injector->data_size);
  memset(data, 0, injector->data_size);
  arg = (injector_shellcode_arg_t*) data;

  arg->handle = invalid_handle;
  arg->dlopen_addr = injector->dlopen_addr;
  arg->dlerror_addr = injector->dlerror_addr;
  arg->dlflags = RTLD_LAZY;
  if (injector->dlfunc_type == DLFUNC_INTERNAL) {
    arg->dlflags |= __RTLD_DLOPEN;
  }
  memcpy(arg->file_path, abspath, pathlen);

  rv = injector__write(injector, injector->data, data, injector->data_size);
  if (rv != 0) {
    return rv;
  }
  rv = injector__call_function(
      injector, &retval, injector->clone_addr, injector->shellcode, injector->stack + injector->stack_size - 4096,
      // CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID,
      CLONE_VM, injector->data
  );
  if (rv != 0) {
    return rv;
  }
  if (retval == -1) {
    injector__set_errmsg("clone error: %s", strerror(errno));
    return INJERR_ERROR_IN_TARGET;
  }
  const struct timespec ts = {0, 100000000}; /* 0.1 second */
  void* handle;
  int cnt = 0;

retry:
  nanosleep(&ts, NULL);
  rv = injector__read(injector, injector->data, &handle, sizeof(handle));
  if (rv != 0) {
    return rv;
  }
  if (handle == invalid_handle) {
    int max_retyr_cnt = 50;
    if (++cnt <= max_retyr_cnt) {
      goto retry;
    }
    injector__set_errmsg("dlopen doesn't return in %d seconds.", max_retyr_cnt / 10);
    return INJERR_ERROR_IN_TARGET;
  }
  if (handle_out != NULL) {
    *handle_out = handle;
  }
  if (handle == NULL) {
    arg->file_path[0] = '\0';
    injector__read(injector, injector->data, data, injector->data_size);
    if (arg->file_path[0] != '\0') {
      injector__set_errmsg("%s", arg->file_path);
    } else {
      injector__set_errmsg("dlopen error");
    }
    return INJERR_ERROR_IN_TARGET;
  }
  return 0;
}
#endif

int injector_remote_func_addr(injector_t* injector, void* handle, const char* name, size_t* func_addr_out) {
  int rv;
  intptr_t retval;
  size_t len = strlen(name) + 1;

  injector__errmsg_is_set = 0;

  if (len > injector->data_size) {
    injector__set_errmsg("too long function name: %s", name);
    return INJERR_FUNCTION_MISSING;
  }
  rv = injector__write(injector, injector->data, name, len);
  if (rv != 0) {
    return rv;
  }
  rv = injector__call_function(injector, &retval, injector->dlsym_addr, handle, injector->data);
  if (rv != 0) {
    return rv;
  }
  if (retval == 0) {
    injector__set_errmsg("function not found: %s", name);
    return INJERR_FUNCTION_MISSING;
  }
  *func_addr_out = (size_t) retval;
  return 0;
}

int injector_remote_call(injector_t* injector, intptr_t* retval, size_t func_addr, ...) {
  va_list ap;
  int rv;
  injector__errmsg_is_set = 0;
  va_start(ap, func_addr);
  rv = injector__call_function_va_list(injector, retval, func_addr, ap);
  va_end(ap);
  return rv;
}

int injector_remote_vcall(injector_t* injector, intptr_t* retval, size_t func_addr, va_list ap) {
  injector__errmsg_is_set = 0;
  return injector__call_function_va_list(injector, retval, func_addr, ap);
}

int injector_call(injector_t* injector, void* handle, const char* name) {
  size_t func_addr;
  int rv = injector_remote_func_addr(injector, handle, name, &func_addr);
  if (rv != 0) {
    return rv;
  }
  return injector__call_function(injector, NULL, func_addr);
}

int injector_uninject(injector_t* injector, void* handle) {
  int rv;
  intptr_t retval;

  injector__errmsg_is_set = 0;
  if (injector->libc_type == LIBC_TYPE_MUSL) {
    /* Assume that libc is musl. */
    injector__set_errmsg(
        "Cannot uninject libraries under musl libc. See: "
        "https://wiki.musl-libc.org/functional-differences-from-glibc.html#Unloading_libraries"
    );
    return INJERR_UNSUPPORTED_TARGET;
  }

  rv = injector__call_function(injector, &retval, injector->dlclose_addr, handle);
  if (rv != 0) {
    return rv;
  }
  if (retval != 0) {
    injector__set_errmsg("dlclose failed");
    return INJERR_ERROR_IN_TARGET;
  }
  return 0;
}

int injector_detach(injector_t* injector) {
  injector__errmsg_is_set = 0;

  if (injector->mmapped) {
    injector__call_syscall(injector, NULL, injector->sys_munmap, injector->data, remote_mem_size(injector));
  }
  if (injector->attached) {
    injector__detach_process(injector);
  }
  free(injector);
  return 0;
}

const char* injector_error(void) { return injector__errmsg; }

```

`src/w1nj3ct/platform/linux/impl/injector.h`:

```h
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2018-2023 Kubo Takehiro <kubo@jiubao.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

/*!
 * \file injector.h
 * \brief Library for injecting a shared library into a Linux, Windows and macOS process
 */
#ifndef INJECTOR_H
#define INJECTOR_H

#if defined(_WIN32)
#include <windows.h>
typedef DWORD injector_pid_t;
#else
#include <sys/types.h>

/*!
 * \brief Platform-dependent process id type (\c pid_t on Unix. \c DWORD on Windows)
 */
typedef pid_t injector_pid_t;
#endif

#ifdef __cplusplus
extern "C" {
#endif
#if 0
}
#endif

#define INJERR_SUCCESS 0              /* linux, windows, macos */
#define INJERR_OTHER -1               /* linux, windows, macos */
#define INJERR_NO_MEMORY -2           /* linux, windows, macos */
#define INJERR_NO_PROCESS -3          /* linux, windows, macos */
#define INJERR_NO_LIBRARY -4          /* linux */
#define INJERR_NO_FUNCTION -4         /* linux */
#define INJERR_ERROR_IN_TARGET -5     /* linux, windows, macos */
#define INJERR_FILE_NOT_FOUND -6      /* linux, windows, macos */
#define INJERR_INVALID_MEMORY_AREA -7 /* linux, macos */
#define INJERR_PERMISSION -8          /* linux, windows, macos */
#define INJERR_UNSUPPORTED_TARGET -9  /* linux, windows, macos */
#define INJERR_INVALID_ELF_FORMAT -10 /* linux */
#define INJERR_WAIT_TRACEE -11        /* linux */
#define INJERR_FUNCTION_MISSING -12   /* linux, windows, macos */

typedef struct injector injector_t;

/*!
 * \brief Attach to the specified process.
 * \param[out]  injector the address where the newly created injector handle will be stored
 * \param[in]   pid      the process id to be attached
 * \return               zero on success. Otherwise, error code
 */
int injector_attach(injector_t** injector, injector_pid_t pid);

/*!
 * \brief Detach from the attached process and destroy the specified handle.
 * \param[in]   injector the injector handle to destroy
 * \return               zero on success. Otherwise, error code
 */
int injector_detach(injector_t* injector);

/*!
 * \brief Inject the specified shared library into the target process.
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   path     the path name of the shared library
 * \param[out]  handle   the address where the newly created module handle will be stored
 * \return               zero on success. Otherwise, error code
 *
 * Note on Linux:
 * This calls functions inside of the target process interrupted by \c ptrace().
 * If the target process is interrupted while holding a non-reentrant lock and
 * injector calls a function requiring the same lock, the process stops forever.
 * If the lock type is reentrant, the status guarded by the lock may become inconsistent.
 * As far as I checked, \c dlopen() internally calls \c malloc() requiring non-reentrant
 * locks. \c dlopen() also uses a reentrant lock to guard information about loaded files.
 */
int injector_inject(injector_t* injector, const char* path, void** handle);

/*!
 * \brief Uninject the shared library specified by \c handle.
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   handle   the module handle created by \c injector_inject
 * \return               zero on success. Otherwise, error code
 * \remarks This fearute isn't supported for musl-libc processes.
 *     See [Functional differences from
 * glibc](https://wiki.musl-libc.org/functional-differences-from-glibc.html#Unloading_libraries).
 */
int injector_uninject(injector_t* injector, void* handle);

#if defined(INJECTOR_DOC) || defined(__linux__) || defined(__APPLE__)
/*!
 * \brief Call the specified function taking no arguments in the target process (Linux and macOS only)
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   handle   the module handle created by \c injector_inject or special-handles such as \c RTLD_DEFAULT
 * \param[in]   name     the function name
 *
 * The \c handle and \c name arguments are passed to \c dlsym
 * ([Linux](https://man7.org/linux/man-pages/man3/dlvsym.3.html),
 * [macOS](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlsym.3.html))
 * and then the return value of \c dlsym is called without arguments in the target process.
 *
 * This is same with the combination of injector_remote_func_addr() and injector_remote_call() without extra arguments.
 *
 * \note
 *   (Linux only)
 *   If the function in the target process internally calls
 * non-[async-signal-safe]((https://man7.org/linux/man-pages/man7/signal-safety.7.html)) functions, it may stop the
 * target process or cause unexpected behaviour.
 * \sa injector_remote_func_addr(), injector_remote_call(), injector_remote_vcall()
 */
int injector_call(injector_t* injector, void* handle, const char* name);
#endif

/*!
 * \brief Get the message of the last error.
 * \remarks The message is updated only when \c injector functions return non-zero.
 */
const char* injector_error(void);

#if defined(INJECTOR_DOC) || defined(__linux__) || defined(_WIN32)
#define INJECTOR_HAS_REMOTE_CALL_FUNCS 1
#include <stdarg.h>
#include <stdint.h>

/*!
 * \brief Get the function address in the target process (Linux and Windows only)
 * \param[in]   injector      the injector handle specifying the target process
 * \param[in]   handle        the module handle created by \c injector_inject or special-handles such as \c RTLD_DEFAULT
 * \param[in]   name          the function name
 * \param[out]  func_addr_out the address where the function address in the target process will be stored
 * \return                    zero on success. Otherwise, error code
 *
 * \b Example
 *
 * Inject libfoo.so and then call foo_func(1, 2, 3) in it.
 * \code
 * void *handle;
 * // inject libfoo.so and get the handle
 * if (injector_inject(injector, "libfoo.so", &handle) != 0) {
 *    return;
 * }
 * size_t func_addr;
 * // get the address of foo_func in the handle
 * if (injector_remote_func_addr(injector, handle, "foo_func", &func_addr) != 0) {
 *    return;
 * }
 * intptr_t retval;
 * // call foo_func
 * if (injector_remote_call(injector, &retval, func_addr, 1, 2, 3) != 0) {
 *    return;
 * }
 * printf("The return value of foo_func(1, 2, 3) is %ld.\n", retval);
 * \endcode
 */
int injector_remote_func_addr(injector_t* injector, void* handle, const char* name, size_t* func_addr_out);

/*!
 * \brief Call the function in the target process (Linux and Windows only)
 * \param[in]   injector  the injector handle specifying the target process
 * \param[out]  retval    \c NULL or the address where the return value of the function call will be stored
 * \param[in]   func_addr the function address in the target process
 * \param[in]   ...       arguments passed to the function
 * \return                zero on success. Otherwise, error code
 * \remarks
 *   The types of the arguments must be integer or pointer.
 *   If it is a pointer, it must point to a valid address in the target process.
 *   The number of arguments must be less than or equal to six.
 * \note
 *   If the function in the target process internally calls
 * non-[async-signal-safe]((https://man7.org/linux/man-pages/man7/signal-safety.7.html)) functions, it may stop the
 * target process or cause unexpected behaviour.
 * \sa injector_remote_func_addr(), injector_remote_vcall()
 */
int injector_remote_call(injector_t* injector, intptr_t* retval, size_t func_addr, ...);

/*!
 * \brief Call the function in the target process (Linux and Windows only)
 * \param[in]   injector  the injector handle specifying the target process
 * \param[out]  retval    \c NULL or the address where the return value of the function call will be stored
 * \param[in]   func_addr the function address in the target process
 * \param[in]   ap        arguments passed to the function
 * \return                zero on success. Otherwise, error code
 * \remarks
 *   The types of the arguments must be integer or pointer.
 *   If it is a pointer, it must point to a valid address in the target process.
 *   The number of arguments must be less than or equal to six.
 * \note
 *   If the function in the target process internally calls
 * non-[async-signal-safe]((https://man7.org/linux/man-pages/man7/signal-safety.7.html)) functions, it may stop the
 * target process or cause unexpected behaviour.
 * \sa injector_remote_func_addr(), injector_remote_call()
 */
int injector_remote_vcall(injector_t* injector, intptr_t* retval, size_t func_addr, va_list ap);
#endif

#if defined(INJECTOR_DOC) || defined(_WIN32)
/*!
 * \brief Same with \c injector_inject except the type of the \c path argument. (Windows only)
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   path     the path name of the shared library
 * \param[out]  handle   the address where the newly created module handle will be stored
 * \return               zero on success. Otherwise, error code
 */
int injector_inject_w(injector_t* injector, const wchar_t* path, void** handle);
#endif

#if defined(INJECTOR_DOC) || (defined(__linux__) && defined(__x86_64__))
#define INJECTOR_HAS_INJECT_IN_CLONED_THREAD 1 // feature test macro
/*!
 * \brief Inject the specified shared library into the target process by the \c clone system call. (Linux x86_64 only)
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   path     the path name of the shared library
 * \param[out]  handle   the address where the newly created module handle will be stored
 * \return               zero on success. Otherwise, error code
 *
 * This calls `dlopen()` in a thread created by \c [clone()](https://man7.org/linux/man-pages/man2/clone.2.html). Note
 * that no wonder there are unexpected pitfalls because some resources allocated in \c
 * [pthread_create()](https://man7.org/linux/man-pages/man3/pthread_create.3.html) lack in the \c clone()-ed thread. Use
 * it at your own risk.
 */
int injector_inject_in_cloned_thread(injector_t* injector, const char* path, void** handle);
#endif

#if 0
{
#endif
#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif

```

`src/w1nj3ct/platform/linux/impl/injector_internal.h`:

```h
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2018-2023 Kubo Takehiro <kubo@jiubao.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#ifndef INJECTOR_INTERNAL_H
#define INJECTOR_INTERNAL_H 1
#include <stdarg.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>
#include <sys/user.h>
#include <sys/ptrace.h>
#include <errno.h>
#include "injector.h"

#ifdef __LP64__
#define SIZE_T_FMT "l"
#else
#define SIZE_T_FMT ""
#endif

#ifdef __arm__
#define user_regs_struct user_regs
#endif

#ifdef __mips__
#include <asm/ptrace.h>
#define user_regs_struct pt_regs
#endif

#ifdef __powerpc__
#include <asm/ptrace.h>
#define user_regs_struct pt_regs
#endif

#ifdef __riscv
#include <asm/ptrace.h>
#endif

#define PTRACE_OR_RETURN(request, injector, addr, data)                                                                \
  do {                                                                                                                 \
    int rv = injector__ptrace(request, injector->pid, addr, data, #request);                                           \
    if (rv != 0) {                                                                                                     \
      return rv;                                                                                                       \
    }                                                                                                                  \
  } while (0)

typedef enum {
  /* use dlopen/dlsym/dlclose (glibc 2.34 or later) */
  DLFUNC_POSIX,
  /* use __libc_dlopen_mode/__libc_dlsym/__libc_dlclose" (glibc 2.33 or earlier) */
  DLFUNC_INTERNAL,
} dlfunc_type_t;

typedef enum {
  LIBC_TYPE_UNKNOWN = 0,
  LIBC_TYPE_GNU,
  LIBC_TYPE_MUSL,
} libc_type_t;

typedef enum {
  ARCH_X86_64,
  ARCH_X86_64_X32,
  ARCH_I386,
  ARCH_ARM64,
  ARCH_ARM_EABI_THUMB,
  ARCH_ARM_EABI,
  ARCH_MIPS_64,
  ARCH_MIPS_N32,
  ARCH_MIPS_O32,
  ARCH_POWERPC_64,
  ARCH_POWERPC,
  ARCH_RISCV_64,
  ARCH_RISCV_32,
} arch_t;

typedef union {
#if defined(__x86_64__) || defined(__i386__)
  uint8_t u8[sizeof(long)];
#elif defined(__aarch64__) || defined(__arm__)
  uint16_t u16[4];
  uint32_t u32[2];
#elif defined(__mips__)
  uint32_t u32[4];
#elif defined(__powerpc__)
  uint32_t u32[2];
#elif defined(__riscv)
  uint32_t u32[2];
#endif
  long dummy;
} code_t;

struct injector {
  pid_t pid;
  uint8_t attached;
  uint8_t mmapped;
  arch_t arch;
  libc_type_t libc_type;
  struct user_regs_struct regs;
  dlfunc_type_t dlfunc_type;
  size_t dlopen_addr;
  size_t dlclose_addr;
  size_t dlsym_addr;
  size_t dlerror_addr;
#ifdef INJECTOR_HAS_INJECT_IN_CLONED_THREAD
  size_t clone_addr;
#endif
  size_t code_addr; /* address where instructions are written */
  code_t backup_code;
  long sys_mmap;
  long sys_mprotect;
  long sys_munmap;

  /* memory layout allocated in the target process
   *
   *  high +----------------------+
   *       |     stack area       |
   *       |      size: 2MB       |
   *       |----------------------|
   *       |  inaccessible area   |
   *       |      size: 4096      |
   *       |----------------------|
   *       |      data area       |
   *       |      size: 4096      |
   *  low  +----------------------+
   */
  size_t data;       /* read-write region */
  size_t data_size;  /* page size */
  size_t stack;      /* stack area */
  size_t stack_size; /* 2MB */
#ifdef INJECTOR_HAS_INJECT_IN_CLONED_THREAD
  size_t shellcode;
#endif
};

/* elf.c */
int injector__collect_libc_information(injector_t* injector);

/* ptrace.c */
int injector__ptrace(int request, pid_t pid, long addr, long data, const char* request_name);
int injector__attach_process(const injector_t* injector);
int injector__detach_process(const injector_t* injector);
int injector__get_regs(const injector_t* injector, struct user_regs_struct* regs);
int injector__set_regs(const injector_t* injector, const struct user_regs_struct* regs);
int injector__read(const injector_t* injector, size_t addr, void* buf, size_t len);
int injector__write(const injector_t* injector, size_t addr, const void* buf, size_t len);
int injector__continue(const injector_t* injector);

/* remote_call.c - call functions and syscalls in the target process */
int injector__call_syscall(const injector_t* injector, intptr_t* retval, long syscall_number, ...);
int injector__call_function(const injector_t* injector, intptr_t* retval, long function_addr, ...);
int injector__call_function_va_list(const injector_t* injector, intptr_t* retval, long function_addr, va_list ap);

/* util.c */
extern char injector__errmsg[];
extern char injector__errmsg_is_set;
void injector__set_errmsg(const char* format, ...) __attribute__((format(printf, 1, 2)));
const char* injector__arch2name(arch_t arch);

/* shellcode.S */
#ifdef INJECTOR_HAS_INJECT_IN_CLONED_THREAD
typedef struct {
  void* handle;
  size_t dlopen_addr;
  size_t dlerror_addr;
  int dlflags;
  char file_path[0]; // dummy size.
} injector_shellcode_arg_t;

void* injector_shellcode(injector_shellcode_arg_t* arg);
extern int injector_shellcode_size;
#endif

#endif

```

`src/w1nj3ct/platform/linux/impl/ptrace.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2018 Kubo Takehiro <kubo@jiubao.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "injector_internal.h"

#if defined(__aarch64__) || defined(__riscv)
#define USE_REGSET
#include <elf.h>     /* for NT_PRSTATUS */
#include <sys/uio.h> /* for struct iovec */
#endif

static int set_ptrace_error(const char* request_name) {
  int err = errno;
  injector__set_errmsg("%s error : %s", request_name, strerror(errno));
  switch (err) {
  case EFAULT:
    return INJERR_INVALID_MEMORY_AREA;
  case EPERM:
    return INJERR_PERMISSION;
  case ESRCH:
    return INJERR_NO_PROCESS;
  }
  return INJERR_OTHER;
}

int injector__ptrace(int request, pid_t pid, long addr, long data, const char* request_name) {
  if (ptrace(request, pid, addr, data) != 0) {
    return set_ptrace_error(request_name);
  }
  return 0;
}

int injector__attach_process(const injector_t* injector) {
  PTRACE_OR_RETURN(PTRACE_ATTACH, injector, 0, 0);
  return 0;
}

int injector__detach_process(const injector_t* injector) {
  PTRACE_OR_RETURN(PTRACE_DETACH, injector, 0, 0);
  return 0;
}

int injector__get_regs(const injector_t* injector, struct user_regs_struct* regs) {
#ifdef USE_REGSET
  struct iovec iovec = {regs, sizeof(*regs)};
  PTRACE_OR_RETURN(PTRACE_GETREGSET, injector, NT_PRSTATUS, (long) &iovec);
#else
  PTRACE_OR_RETURN(PTRACE_GETREGS, injector, 0, (long) regs);
#endif
  return 0;
}

int injector__set_regs(const injector_t* injector, const struct user_regs_struct* regs) {
#ifdef USE_REGSET
  struct iovec iovec = {(void*) regs, sizeof(*regs)};
  PTRACE_OR_RETURN(PTRACE_SETREGSET, injector, NT_PRSTATUS, (long) &iovec);
#else
  PTRACE_OR_RETURN(PTRACE_SETREGS, injector, 0, (long) regs);
#endif
  return 0;
}

int injector__read(const injector_t* injector, size_t addr, void* buf, size_t len) {
  pid_t pid = injector->pid;
  long word;
  char* dest = (char*) buf;

  errno = 0;
  while (len >= sizeof(long)) {
    word = ptrace(PTRACE_PEEKTEXT, pid, addr, 0);
    if (word == -1 && errno != 0) {
      return set_ptrace_error("PTRACE_PEEKTEXT");
    }
    *(long*) dest = word;
    addr += sizeof(long);
    dest += sizeof(long);
    len -= sizeof(long);
  }
  if (len != 0) {
    char* src = (char*) &word;
    word = ptrace(PTRACE_PEEKTEXT, pid, addr, 0);
    if (word == -1 && errno != 0) {
      return set_ptrace_error("PTRACE_PEEKTEXT");
    }
    while (len--) {
      *(dest++) = *(src++);
    }
  }
  return 0;
}

int injector__write(const injector_t* injector, size_t addr, const void* buf, size_t len) {
  pid_t pid = injector->pid;
  const char* src = (const char*) buf;

  while (len >= sizeof(long)) {
    PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, addr, *(long*) src);
    addr += sizeof(long);
    src += sizeof(long);
    len -= sizeof(long);
  }
  if (len != 0) {
    long word = ptrace(PTRACE_PEEKTEXT, pid, addr, 0);
    char* dest = (char*) &word;
    if (word == -1 && errno != 0) {
      return set_ptrace_error("PTRACE_PEEKTEXT");
    }
    while (len--) {
      *(dest++) = *(src++);
    }
    PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, addr, word);
  }
  return 0;
}

int injector__continue(const injector_t* injector) {
  PTRACE_OR_RETURN(PTRACE_CONT, injector, 0, 0);
  return 0;
}

```

`src/w1nj3ct/platform/linux/impl/remote_call.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2018-2023 Kubo Takehiro <kubo@jiubao.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#if defined __linux__
/* Detect musl libc. See https://stackoverflow.com/a/70211227/985524  */
#define _GNU_SOURCE
#include <features.h>
#ifndef __USE_GNU
#define MUSL_LIBC
#endif // __USE_GNU
#endif // __linux__

#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <inttypes.h>
#include "injector_internal.h"

// #define INJECTOR_DEBUG_REMOTE_CALL 1

#ifdef INJECTOR_DEBUG_REMOTE_CALL
#undef DEBUG
#define DEBUG(...) fprintf(stderr, __VA_ARGS__)
#else
#undef DEBUG
#define DEBUG(...)                                                                                                     \
  do {                                                                                                                 \
  } while (0)
#endif

#ifdef __x86_64__
#define eip rip
#define ebp rbp
#define esp rsp
#define eax rax
#define ebx rbx
#define ecx rcx
#define edx rdx
#define esi rsi
#define edi rdi
#define ebp rbp
#endif

#if defined(__arm__)
#define reg32_return reg_return
#define uregs regs.uregs
#endif

#define THUMB_MODE_BIT (1u << 5)
#define BREAKINST_THUMB 0xde01     /* in linux-source-tree/arch/arm/kernel/ptrace.c */
#define BREAKINST_ARM 0xe7f001f0   /* in linux-source-tree/arch/arm/kernel/ptrace.c */
#define BREAKINST_ARM64 0xd4200000 /* asm("brk #0") */

#ifdef __mips__
#define REG_V0 2
#define REG_A0 4
#define REG_A1 5
#define REG_A2 6
#define REG_A3 7
#define REG_A4 8
#define REG_A5 9
#define REG_T4 12
#define REG_T9 25
#define REG_SP 29
#define REG_FP 30
#define REG_RA 31

static void print_regs(const injector_t* injector, const struct pt_regs* regs) {
  DEBUG("  Registers:\n");
  DEBUG(
      "    -- at v0 v1: %016" PRIx64 " %016" PRIx64 " %016" PRIx64 " %016" PRIx64 "\n", regs->regs[0], regs->regs[1],
      regs->regs[2], regs->regs[3]
  );
  DEBUG(
      "    a0 a1 a2 a3: %016" PRIx64 " %016" PRIx64 " %016" PRIx64 " %016" PRIx64 "\n", regs->regs[4], regs->regs[5],
      regs->regs[6], regs->regs[7]
  );
  DEBUG(
      "    %s: %016" PRIx64 " %016" PRIx64 " %016" PRIx64 " %016" PRIx64 "\n",
      (injector->arch != ARCH_MIPS_O32) ? "a4 a5 a6 a7" : "t0 t1 t2 t3", regs->regs[8], regs->regs[9], regs->regs[10],
      regs->regs[11]
  );
  DEBUG(
      "    t4 t5 t6 t7: %016" PRIx64 " %016" PRIx64 " %016" PRIx64 " %016" PRIx64 "\n", regs->regs[12], regs->regs[13],
      regs->regs[14], regs->regs[15]
  );
  DEBUG(
      "    s0 s1 s2 s3: %016" PRIx64 " %016" PRIx64 " %016" PRIx64 " %016" PRIx64 "\n", regs->regs[16], regs->regs[17],
      regs->regs[18], regs->regs[19]
  );
  DEBUG(
      "    s4 s5 s6 s7: %016" PRIx64 " %016" PRIx64 " %016" PRIx64 " %016" PRIx64 "\n", regs->regs[20], regs->regs[21],
      regs->regs[22], regs->regs[23]
  );
  DEBUG(
      "    t8 t9 k0 k1: %016" PRIx64 " %016" PRIx64 " %016" PRIx64 " %016" PRIx64 "\n", regs->regs[24], regs->regs[25],
      regs->regs[26], regs->regs[27]
  );
  DEBUG(
      "    gp sp s8 ra: %016" PRIx64 " %016" PRIx64 " %016" PRIx64 " %016" PRIx64 "\n", regs->regs[28], regs->regs[29],
      regs->regs[30], regs->regs[31]
  );
  DEBUG(
      "    lo hi epc:                    %016" PRIx64 " %016" PRIx64 " %016" PRIx64 "\n", regs->lo, regs->hi,
      regs->cp0_epc
  );
  DEBUG(
      "    badvaddr status cause:        %016" PRIx64 " %016" PRIx64 " %016" PRIx64 "\n", regs->cp0_badvaddr,
      regs->cp0_status, regs->cp0_cause
  );
}
#define PRINT_REGS(injector, regs) print_regs((injector), (regs))
#endif /* __mips__ */

#ifdef __powerpc__
static void print_regs(const injector_t* injector, const struct pt_regs* regs) {
#undef WIDTH
#ifdef __LP64__
#define WIDTH "016"
#define softe_or_mq_str "softe"
#define softe_or_mq softe
#else
#define WIDTH "08"
#define softe_or_mq_str "mq   "
#define softe_or_mq mq
#endif
  DEBUG("  Registers:\n");
  DEBUG(
      "    gpr0  gpr1  gpr2   gpr3   : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->gpr[0],
      regs->gpr[1], regs->gpr[2], regs->gpr[3]
  );
  DEBUG(
      "    gpr4  gpr5  gpr6   gpr7   : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->gpr[4],
      regs->gpr[5], regs->gpr[6], regs->gpr[7]
  );
  DEBUG(
      "    gpr8  gpr9  gpr10  gpr11  : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->gpr[8],
      regs->gpr[9], regs->gpr[10], regs->gpr[11]
  );
  DEBUG(
      "    gpr12 gpr13 gpr14  gpr15  : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->gpr[12],
      regs->gpr[13], regs->gpr[14], regs->gpr[15]
  );
  DEBUG(
      "    gpr16 gpr17 gpr18  gpr19  : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->gpr[16],
      regs->gpr[17], regs->gpr[18], regs->gpr[19]
  );
  DEBUG(
      "    gpr20 gpr21 gpr22  gpr23  : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->gpr[20],
      regs->gpr[21], regs->gpr[22], regs->gpr[23]
  );
  DEBUG(
      "    gpr24 gpr25 gpr26  gpr27  : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->gpr[24],
      regs->gpr[25], regs->gpr[26], regs->gpr[27]
  );
  DEBUG(
      "    gpr28 gpr29 gpr30  gpr31  : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->gpr[28],
      regs->gpr[29], regs->gpr[30], regs->gpr[31]
  );
  DEBUG(
      "    nip   msr   orig_gpr3 ctr : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->nip, regs->msr,
      regs->orig_gpr3, regs->ctr
  );
  DEBUG(
      "    link  xer   ccr    " softe_or_mq_str "  : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->link,
      regs->xer, regs->ccr, regs->softe_or_mq
  );
  DEBUG(
      "    trap  dar   dsisr  result : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->trap, regs->dar,
      regs->dsisr, regs->result
  );
#undef WIDTH
}
#define PRINT_REGS(injector, regs) print_regs((injector), (regs))
#endif

#ifdef __riscv
#define REG_RA 1
#define REG_T1 6
#ifdef __LP64__
#define WIDTH "016"
#else
#define WIDTH "08"
#endif
static void print_regs(const injector_t* injector, const struct user_regs_struct* regs) {
  DEBUG("  Registers:\n");
  DEBUG(
      "    pc  ra  sp  gp  : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->pc, regs->ra, regs->sp,
      regs->gp
  );
  DEBUG(
      "    tp  t0  t1  t2  : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->tp, regs->t0, regs->t1,
      regs->t2
  );
  DEBUG(
      "    s0  s1  a0  a1  : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->s0, regs->s1, regs->a0,
      regs->a1
  );
  DEBUG(
      "    a2  a3  a4  a5  : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->a2, regs->a3, regs->a4,
      regs->a5
  );
  DEBUG(
      "    a6  a7  s2  s3  : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->a6, regs->a7, regs->s2,
      regs->s3
  );
  DEBUG(
      "    s4  s5  s6  s7  : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->s4, regs->s5, regs->s6,
      regs->s7
  );
  DEBUG(
      "    s8  s9  s10 s11 : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->s8, regs->s9, regs->s10,
      regs->s11
  );
  DEBUG(
      "    t3  t4  t5  t6  : %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx %" WIDTH "lx\n", regs->t3, regs->t4, regs->t5,
      regs->t6
  );
}
#define PRINT_REGS(injector, regs) print_regs((injector), (regs))
#endif

/* register type used in struct user_regs_struct */
#if defined(__mips__)
typedef uint64_t user_reg_t;
#elif defined(__riscv)
typedef unsigned long user_reg_t;
#elif defined(__LP64__) && !defined(MUSL_LIBC)
typedef unsigned long long user_reg_t;
#elif defined(__i386__)
typedef long user_reg_t;
#else
typedef unsigned long user_reg_t;
#endif

static int kick_then_wait_sigtrap(
    const injector_t* injector, struct user_regs_struct* regs, code_t* code, size_t code_size
);

#ifndef PRINT_REGS
#define PRINT_REGS(injector, regs)                                                                                     \
  do {                                                                                                                 \
  } while (0)
#endif

/*
 * Call the specified system call in the target process.
 *
 * The arguments after syscall_number must be integer types and
 * the size must not be greater than the size of long.
 */
int injector__call_syscall(const injector_t* injector, intptr_t* retval, long syscall_number, ...) {
  struct user_regs_struct regs = injector->regs;
  code_t code;
  size_t code_size;
  long arg1, arg2, arg3, arg4, arg5, arg6;
  va_list ap;
  int rv;
#if !defined(__mips__) && !defined(__powerpc__)
  user_reg_t* reg_return = NULL;
#if defined(__aarch64__)
  uint32_t* reg32_return = NULL;
  uint32_t* uregs = (uint32_t*) &regs;
#endif
#endif

  va_start(ap, syscall_number);
  arg1 = va_arg(ap, long);
  arg2 = va_arg(ap, long);
  arg3 = va_arg(ap, long);
  arg4 = va_arg(ap, long);
  arg5 = va_arg(ap, long);
  arg6 = va_arg(ap, long);
  va_end(ap);

  DEBUG("injector__call_syscall:\n");
  DEBUG("  args: %ld, %lx, %lx, %lx, %lx, %lx, %lx\n", syscall_number, arg1, arg2, arg3, arg4, arg5, arg6);

#if !(defined(__x86_64__) && defined(__LP64__))
  if (injector->arch == ARCH_X86_64_X32) {
    injector__set_errmsg("x32-ABI target process is supported only by x86_64.");
    return INJERR_UNSUPPORTED_TARGET;
  }
#endif

  switch (injector->arch) {
#if defined(__x86_64__) && defined(__LP64__)
  case ARCH_X86_64:
  case ARCH_X86_64_X32:
    /* setup instructions */
    code.u8[0] = 0x0f;
    code.u8[1] = 0x05;                           /* 0f 05 : syscall */
    code.u8[2] = 0xcc;                           /* cc    : int3    */
    memset(&code.u8[3], 0x90, sizeof(long) - 3); /* fill the rests with `nop` */
    code_size = sizeof(long);
    /* setup registers */
    regs.rip = injector->code_addr;
    regs.rax = syscall_number;
    regs.rdi = arg1;
    regs.rsi = arg2;
    regs.rdx = arg3;
    regs.r10 = arg4;
    regs.r8 = arg5;
    regs.r9 = arg6;
    reg_return = &regs.rax;
    break;
#endif
#if defined(__x86_64__) || defined(__i386__)
  case ARCH_I386:
    /* setup instructions */
    code.u8[0] = 0xcd;
    code.u8[1] = 0x80;                           /* cd 80 : int $80 */
    code.u8[2] = 0xcc;                           /* cc    : int3    */
    memset(&code.u8[3], 0x90, sizeof(long) - 3); /* fill the rests with `nop` */
    code_size = sizeof(long);
    /* setup registers */
    regs.eip = injector->code_addr;
    regs.eax = syscall_number;
    regs.ebx = arg1;
    regs.ecx = arg2;
    regs.edx = arg3;
    regs.esi = arg4;
    regs.edi = arg5;
    regs.ebp = arg6;
    reg_return = &regs.eax;
    break;
#endif
#if defined(__aarch64__)
  case ARCH_ARM64:
    /* setup instructions */
    code.u32[0] = 0xd4000001; /* svc #0 */
    code.u32[1] = BREAKINST_ARM64;
    code_size = 2 * 4;
    /* setup registers */
    regs.pc = injector->code_addr;
    regs.regs[8] = syscall_number;
    regs.regs[0] = arg1;
    regs.regs[1] = arg2;
    regs.regs[2] = arg3;
    regs.regs[3] = arg4;
    regs.regs[4] = arg5;
    regs.regs[5] = arg6;
    reg_return = &regs.regs[0];
    break;
#endif
#if defined(__aarch64__) || defined(__arm__)
  case ARCH_ARM_EABI_THUMB:
    /* setup instructions */
    code.u16[0] = 0xdf00; /* svc #0 */
    code.u16[1] = BREAKINST_THUMB;
#ifdef __LP64__
    code.u16[2] = 0x46c0; /* nop (mov r8, r8) */
    code.u16[3] = 0x46c0; /* nop (mov r8, r8) */
#endif
    code_size = sizeof(long);
    /* setup registers */
    uregs[16] |= THUMB_MODE_BIT;
    uregs[15] = injector->code_addr;
    uregs[7] = syscall_number;
    uregs[0] = arg1;
    uregs[1] = arg2;
    uregs[2] = arg3;
    uregs[3] = arg4;
    uregs[4] = arg5;
    uregs[5] = arg6;
    reg32_return = &uregs[0];
    break;
  case ARCH_ARM_EABI:
    /* setup instructions */
    code.u32[0] = 0xef000000; /* svc #0 */
    code.u32[1] = BREAKINST_ARM;
    code_size = 2 * 4;
    /* setup registers */
    uregs[16] &= ~THUMB_MODE_BIT;
    uregs[15] = injector->code_addr;
    uregs[7] = syscall_number;
    uregs[0] = arg1;
    uregs[1] = arg2;
    uregs[2] = arg3;
    uregs[3] = arg4;
    uregs[4] = arg5;
    uregs[5] = arg6;
    reg32_return = &uregs[0];
    break;
#endif
#if defined(__mips__)
  case ARCH_MIPS_64:
  case ARCH_MIPS_N32:
  case ARCH_MIPS_O32:
    /* setup instructions */
    if (syscall_number > 0xffff) {
      injector__set_errmsg("too large system call number: %d", syscall_number);
      return INJERR_OTHER;
    }
    code.u32[0] = 0x00000025 | (REG_A3 << 11) | (REG_T4 << 21); /* or $a3, $t4, $zero; move $a3, $t4 */
    code.u32[1] = 0x24000000 | (REG_V0 << 16) | syscall_number; /* addiu $v0, $zero, syscall_number */
    code.u32[2] = 0x0000000c;                                   /* syscall */
    code.u32[3] = 0x0000000d;                                   /* break */
    code_size = 4 * 4;
    DEBUG(
        "  Code: %08" PRIx32 " %08" PRIx32 " %08" PRIx32 " %08" PRIx32 "\n", code.u32[0], code.u32[1], code.u32[2],
        code.u32[3]
    );
    /* setup registers */
    regs.cp0_epc = injector->code_addr;
    regs.regs[REG_A0] = arg1;
    regs.regs[REG_A1] = arg2;
    regs.regs[REG_A2] = arg3;
    // Use the combination of "regs.regs[REG_T4] = arg4" and "move $a3, $t4"
    // instead of "regs.regs[REG_A3] = arg4". I don't know why the latter
    // doesn't work.
    regs.regs[REG_T4] = arg4;
    if (injector->arch != ARCH_MIPS_O32) {
      /* ARCH_MIPS_64 or ARCH_MIPS_N32 */
      regs.regs[REG_A4] = arg5;
      regs.regs[REG_A5] = arg6;
    } else {
      /* ARCH_MIPS_O32 */
      regs.regs[REG_SP] -= 32;
      PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.regs[REG_SP] + 16, arg5);
      PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.regs[REG_SP] + 20, arg6);
    }
    break;
#endif
#if defined(__powerpc__)
#ifdef __LP64__
  case ARCH_POWERPC_64:
#endif
  case ARCH_POWERPC:
    /* setup instructions */
    code.u32[0] = 0x44000002; /* sc */
    code.u32[1] = 0x7fe00008; /* trap */
    code_size = 2 * 4;
    /* setup registers */
    regs.nip = injector->code_addr;
    regs.gpr[PT_R0] = syscall_number;
    regs.gpr[PT_R3] = arg1;
    regs.gpr[PT_R4] = arg2;
    regs.gpr[PT_R5] = arg3;
    regs.gpr[PT_R6] = arg4;
    regs.gpr[PT_R7] = arg5;
    regs.gpr[PT_R8] = arg6;
    break;
#endif
#if defined(__riscv)
#ifdef __LP64__
  case ARCH_RISCV_64:
#endif
  case ARCH_RISCV_32:
    /* setup instructions */
    code.u32[0] = 0x00000073; /* ecall */
    code.u32[1] = 0x00100073; /* ebreak */
    code_size = 2 * 4;
    DEBUG("  Code: %08" PRIx32 " %08" PRIx32 "\n", code.u32[0], code.u32[1]);
    /* setup registers */
    regs.pc = injector->code_addr;
    regs.a0 = arg1;
    regs.a1 = arg2;
    regs.a2 = arg3;
    regs.a3 = arg4;
    regs.a4 = arg5;
    regs.a5 = arg6;
    regs.a7 = syscall_number;
    reg_return = &regs.a0;
    break;
#endif
  default:
    injector__set_errmsg("Unexpected architecture: %s", injector__arch2name(injector->arch));
    return INJERR_UNSUPPORTED_TARGET;
  }

  PRINT_REGS(injector, &regs);
  rv = kick_then_wait_sigtrap(injector, &regs, &code, code_size);
  if (rv != 0) {
    return rv;
  }
  PRINT_REGS(injector, &regs);

  if (retval != NULL) {
#if defined(__mips__)
    if (regs.regs[REG_A3] == 0) {
      *retval = (intptr_t) regs.regs[REG_V0];
    } else {
      errno = (int) regs.regs[REG_V0];
      *retval = -1;
    }
#elif defined(__powerpc__)
    /* https://github.com/strace/strace/blob/v5.19/src/linux/powerpc/get_error.c#L21-L26 */
    if (regs.ccr & 0x10000000) {
      errno = (int) regs.gpr[PT_R3];
      *retval = -1;
    } else {
      *retval = (intptr_t) regs.gpr[PT_R3];
    }
#else
#if defined(__aarch64__)
    if (reg32_return != NULL) {
      if (*reg32_return <= -4096u) {
        *retval = (intptr_t) *reg32_return;
      } else {
        errno = -((int) *reg32_return);
        *retval = -1;
      }
    } else {
#endif
      if ((unsigned long) *reg_return <= -4096ul) {
        *retval = (intptr_t) *reg_return;
      } else {
        errno = -((int) *reg_return);
        *retval = -1;
      }
#if defined(__aarch64__)
    }
#endif
#endif /* defined(__mips__) */
  }
  return 0;
}

/*
 * Call the function at the specified address in the target process.
 *
 * The arguments after function_addr must be integer types and
 * the size must not be greater than the size of long.
 */
int injector__call_function(const injector_t* injector, intptr_t* retval, long function_addr, ...) {
  va_list ap;
  int rv;
  va_start(ap, function_addr);
  rv = injector__call_function_va_list(injector, retval, function_addr, ap);
  va_end(ap);
  return rv;
}

/*
 * Call the function at the specified address in the target process.
 *
 * The arguments after function_addr must be integer types and
 * the size must not be greater than the size of long.
 */
int injector__call_function_va_list(const injector_t* injector, intptr_t* retval, long function_addr, va_list ap) {
  struct user_regs_struct regs = injector->regs;
  code_t code;
  size_t code_size;
  long arg1, arg2, arg3, arg4, arg5, arg6;
  int rv;
  user_reg_t* reg_return = NULL;
#if defined(__aarch64__)
  uint32_t* reg32_return = NULL;
  uint32_t* uregs = (uint32_t*) &regs;
#endif

  arg1 = va_arg(ap, long);
  arg2 = va_arg(ap, long);
  arg3 = va_arg(ap, long);
  arg4 = va_arg(ap, long);
  arg5 = va_arg(ap, long);
  arg6 = va_arg(ap, long);

  DEBUG("injector__call_function:\n");
  DEBUG("  args: %lx, %lx, %lx, %lx, %lx, %lx, %lx\n", function_addr, arg1, arg2, arg3, arg4, arg5, arg6);

  switch (injector->arch) {
#if defined(__x86_64__) && defined(__LP64__)
  case ARCH_X86_64:
  case ARCH_X86_64_X32:
    /* setup instructions */
    code.u8[0] = 0xff;
    code.u8[1] = 0xd0;                           /* ff d0 : callq *%rax */
    code.u8[2] = 0xcc;                           /* cc    : int3        */
    memset(&code.u8[3], 0x90, sizeof(long) - 3); /* fill the rests with `nop` */
    code_size = sizeof(long);
    /* setup registers */
    regs.rip = injector->code_addr;
    regs.rbp = injector->stack + injector->stack_size - 16;
    /* rsp must be aligned to a 16-byte boundary. */
    regs.rsp = injector->stack + injector->stack_size - (2 * 16);
    regs.rax = function_addr;
    regs.rdi = arg1;
    regs.rsi = arg2;
    regs.rdx = arg3;
    regs.rcx = arg4;
    regs.r8 = arg5;
    regs.r9 = arg6;
    reg_return = &regs.rax;
    break;
#endif
#if defined(__x86_64__) || defined(__i386__)
  case ARCH_I386:
    /* setup instructions */
    code.u8[0] = 0xff;
    code.u8[1] = 0xd0;                           /* ff d0 : call *%eax */
    code.u8[2] = 0xcc;                           /* cc    : int3       */
    memset(&code.u8[3], 0x90, sizeof(long) - 3); /* fill the rests with `nop` */
    code_size = sizeof(long);
    /* setup registers */
    regs.eip = injector->code_addr;
    regs.ebp = injector->stack + injector->stack_size - 16;
    /* esp should be at 16-byte boundary after call instruction.*/
    regs.esp = injector->stack + injector->stack_size - (3 * 16) + 4;
    regs.eax = function_addr;
    PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.esp + 0, arg1);
    PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.esp + 4, arg2);
    PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.esp + 8, arg3);
    PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.esp + 12, arg4);
    PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.esp + 16, arg5);
    PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.esp + 20, arg6);
    reg_return = &regs.eax;
    break;
#endif
#if defined(__aarch64__)
  case ARCH_ARM64:
    /* setup instructions */
    code.u32[0] = 0xd63f00c0; /* blr x6 */
    code.u32[1] = BREAKINST_ARM64;
    code_size = 2 * 4;
    /* setup registers */
    regs.pc = injector->code_addr;
    regs.sp = injector->stack + injector->stack_size - 16;
    regs.regs[6] = function_addr;
    regs.regs[0] = arg1;
    regs.regs[1] = arg2;
    regs.regs[2] = arg3;
    regs.regs[3] = arg4;
    regs.regs[4] = arg5;
    regs.regs[5] = arg6;
    reg_return = &regs.regs[0];
    break;
#endif
#if defined(__aarch64__) || defined(__arm__)
  case ARCH_ARM_EABI_THUMB:
    /* setup instructions */
    code.u16[0] = 0x47a0; /* blx r4 */
    code.u16[1] = BREAKINST_THUMB;
#ifdef __LP64__
    code.u16[2] = 0x46c0; /* nop (mov r8, r8) */
    code.u16[3] = 0x46c0; /* nop (mov r8, r8) */
#endif
    code_size = sizeof(long);
    /* setup registers */
    uregs[16] |= THUMB_MODE_BIT;
    uregs[15] = injector->code_addr;
    uregs[13] = injector->stack + injector->stack_size - 16;
    uregs[4] = function_addr;
    uregs[0] = arg1;
    uregs[1] = arg2;
    uregs[2] = arg3;
    uregs[3] = arg4;
    PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, uregs[13] + 0, arg5);
    PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, uregs[13] + 4, arg6);
    reg32_return = &uregs[0];
    break;
  case ARCH_ARM_EABI:
    /* setup instructions */
    code.u32[0] = 0xe12fff34; /* blx r4 */
    code.u32[1] = BREAKINST_ARM;
    code_size = 2 * 4;
    /* setup registers */
    uregs[16] &= ~THUMB_MODE_BIT;
    uregs[15] = injector->code_addr;
    uregs[13] = injector->stack + injector->stack_size - 16;
    uregs[4] = function_addr;
    uregs[0] = arg1;
    uregs[1] = arg2;
    uregs[2] = arg3;
    uregs[3] = arg4;
    PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, uregs[13] + 0, arg5);
    PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, uregs[13] + 4, arg6);
    reg32_return = &uregs[0];
    break;
#endif
#if defined(__mips__)
  case ARCH_MIPS_64:
  case ARCH_MIPS_N32:
  case ARCH_MIPS_O32:
    /* setup instructions */
    code.u32[0] = 0x00000009 | (REG_RA << 11) | (REG_T9 << 21); /* jalr $t9;  */
    code.u32[1] = 0x00000025 | (REG_A3 << 11) | (REG_T4 << 21); /* or $a3, $t4, $zero; in a delay slot */
    code.u32[2] = 0x0000000d;                                   /* break */
    code.u32[3] = 0x00000000;                                   /* nop */
    code_size = 4 * 4;
    DEBUG(
        "  Code: %08" PRIx32 " %08" PRIx32 " %08" PRIx32 " %08" PRIx32 "\n", code.u32[0], code.u32[1], code.u32[2],
        code.u32[3]
    );
    /* setup registers */
    regs.cp0_epc = injector->code_addr;
    regs.regs[REG_FP] = injector->stack + injector->stack_size - 32;
    regs.regs[REG_SP] = injector->stack + injector->stack_size - 64;
    regs.regs[REG_T9] = function_addr;
    regs.regs[REG_A0] = arg1;
    regs.regs[REG_A1] = arg2;
    regs.regs[REG_A2] = arg3;
    regs.regs[REG_T4] = arg4;
    if (injector->arch != ARCH_MIPS_O32) {
      /* ARCH_MIPS_64 or ARCH_MIPS_N32 */
      regs.regs[REG_A4] = arg5;
      regs.regs[REG_A5] = arg6;
    } else {
      /* ARCH_MIPS_O32 */
      PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.regs[REG_SP] + 16, arg5);
      PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.regs[REG_SP] + 20, arg6);
    }
    reg_return = &regs.regs[REG_V0];
    break;
#endif
#if defined(__powerpc__)
#ifdef __LP64__
  case ARCH_POWERPC_64:
#endif
  case ARCH_POWERPC:
    /* setup instructions */
    code.u32[0] = 0x4e800421; /* bctrl */
    code.u32[1] = 0x7fe00008; /* trap */
    code_size = 2 * 4;
    /* setup registers */
    regs.nip = injector->code_addr;
    regs.gpr[PT_R1] = injector->stack + injector->stack_size - 256;
    regs.ctr = function_addr;
    regs.gpr[PT_R3] = arg1;
    regs.gpr[PT_R4] = arg2;
    regs.gpr[PT_R5] = arg3;
    regs.gpr[PT_R6] = arg4;
    regs.gpr[PT_R7] = arg5;
    regs.gpr[PT_R8] = arg6;
    regs.gpr[PT_R12] = function_addr;
    reg_return = &regs.gpr[PT_R3];
    break;
#endif
#if defined(__riscv)
#ifdef __LP64__
  case ARCH_RISCV_64:
#endif
  case ARCH_RISCV_32:
    /* setup instructions */
    code.u32[0] = 0x00000067 | (REG_RA << 7) | (REG_T1 << 15); /* jalr t1 */
    code.u32[1] = 0x00100073;                                  /* ebreak */
    code_size = 2 * 4;
    DEBUG("  Code: %08" PRIx32 " %08" PRIx32 "\n", code.u32[0], code.u32[1]);
    /* setup registers */
    regs.pc = injector->code_addr;
    regs.sp = injector->stack + injector->stack_size - 16;
    regs.t1 = function_addr;
    regs.a0 = arg1;
    regs.a1 = arg2;
    regs.a2 = arg3;
    regs.a3 = arg4;
    regs.a4 = arg5;
    regs.a5 = arg6;
    reg_return = &regs.a0;
    break;
#endif
  default:
    injector__set_errmsg("Unexpected architecture: %s", injector__arch2name(injector->arch));
    return -1;
  }

  PRINT_REGS(injector, &regs);
  rv = kick_then_wait_sigtrap(injector, &regs, &code, code_size);
  if (rv != 0) {
    return rv;
  }
  PRINT_REGS(injector, &regs);

  if (retval != NULL) {
#if defined(__aarch64__)
    if (reg32_return != NULL) {
      *retval = (long) *reg32_return;
    } else {
      *retval = (long) *reg_return;
    }
#else
    *retval = (long) *reg_return;
#endif
  }
  return 0;
}

static int kick_then_wait_sigtrap(
    const injector_t* injector, struct user_regs_struct* regs, code_t* code, size_t code_size
) {
  int status;
  int rv;

  rv = injector__set_regs(injector, regs);
  if (rv != 0) {
    return rv;
  }
  rv = injector__write(injector, injector->code_addr, code, code_size);
  if (rv != 0) {
    injector__set_regs(injector, &injector->regs);
    return rv;
  }

  rv = injector__continue(injector);
  if (rv != 0) {
    goto cleanup;
  }
  while (1) {
    pid_t pid = waitpid(injector->pid, &status, 0);
    if (pid == -1) {
      if (errno == EINTR) {
        continue;
      }
      injector__set_errmsg("waitpid error: %s", strerror(errno));
      rv = INJERR_WAIT_TRACEE;
      goto cleanup;
    }
    if (WIFSTOPPED(status)) {
#if defined(PT_GETSIGINFO)
      siginfo_t si = {
          0,
      };
#endif
      switch (WSTOPSIG(status)) {
      case SIGTRAP:
        goto got_sigtrap;
      case SIGSTOP:
        rv = injector__continue(injector);
        if (rv != 0) {
          goto cleanup;
        }
        break;
#if defined(PT_GETSIGINFO)
      case SIGSYS:
        PTRACE_OR_RETURN(PT_GETSIGINFO, injector, 0, (long) &si);
        if (si.si_signo == SIGSYS && si.si_code == 1) {
          injector__set_errmsg(
              "Got SIGSYS. System call %d at address %p might be blocked by seccomp.", si.si_syscall,
              (void*) si.si_call_addr
          );
          rv = INJERR_OTHER;
          goto cleanup;
        }
        // FALL THROUGH */
#endif
      default:
        injector__set_errmsg("The target process unexpectedly stopped by signal %d.", WSTOPSIG(status));
        rv = INJERR_OTHER;
        goto cleanup;
      }
    } else if (WIFEXITED(status)) {
      injector__set_errmsg("The target process unexpectedly terminated with exit code %d.", WEXITSTATUS(status));
      rv = INJERR_OTHER;
      goto cleanup;
    } else if (WIFSIGNALED(status)) {
      injector__set_errmsg("The target process unexpectedly terminated by signal %d.", WTERMSIG(status));
      rv = INJERR_OTHER;
      goto cleanup;
    } else {
      /* never reach here */
      injector__set_errmsg("Unexpected waitpid status: 0x%x", status);
      rv = INJERR_OTHER;
      goto cleanup;
    }
  }
got_sigtrap:
  /* success */
  rv = injector__get_regs(injector, regs);
cleanup:
  injector__set_regs(injector, &injector->regs);
  injector__write(injector, injector->code_addr, &injector->backup_code, code_size);
  return rv;
}

```

`src/w1nj3ct/platform/linux/impl/shellcode.S`:

```S
#if defined(__x86_64__)
#define handle_offset 0
#define dlopen_addr_offset 8
#define dlerror_addr_offset 16
#define dlflags_offset 24
#define file_path_offset 28
#define page_size 4096
	.text
	.global	injector_shellcode
	.hidden	injector_shellcode
	.type	injector_shellcode, @function
	// void *injector_shellcode(injector_shellcode_arg_t *arg) {
injector_shellcode:
	//   // prolog
	pushq	%rbx
	movq	%rdi, %rbx
	//   int dlflags = arg->dlflags;
	movl	dlflags_offset(%rbx), %esi
	//   const char *file_path = arg->file_path;
	leaq	file_path_offset(%rbx), %rdi
	//   void *handle = dlopen(file_path, dlflags);
	call	*dlopen_addr_offset(%rbx)
	//   arg->handle = handle;
	movq	%rax, handle_offset(%rbx)
	//   arg->file_path[0] = '\0';
	movb	$0, file_path_offset(%rbx)
	//   if (handle != NULL) return;
	test	%rax, %rax
	jnz	.exit
	//   if (arg->dlerror_addr == 0) return;
	cmpq	$0, dlerror_addr_offset(%rbx)
	je	.exit
	//   char *errmsg = dlerror();
	call	*dlerror_addr_offset(%rbx)
	//   if (errmsg == NULL) return;
	test	%rax, %rax
	jz	.exit
	//   char *dest = arg->file_path
	leaq	file_path_offset(%rbx), %rdi
	//   char *end = (char*)arg + page_size;
	leaq	page_size(%rbx), %rcx
.loop:
	//   char c = *(errmsg++);
	movb	(%rax), %dl
	addq	$1, %rax
	//   *(dest++) = c;
	movb	%dl, (%rdi)
	addq	$1, %rdi
	//   if (c == 0) return;
	testb	%dl, %dl
	jz	.exit
	//   if (dest < end) goto loop;
	cmpq	%rdi, %rcx
	ja	.loop
.exit:
	//   // epilog
	popq	%rbx
	ret
	// }
	.size	injector_shellcode, . - injector_shellcode

	.balign  4
	.global	injector_shellcode_size
	.hidden	injector_shellcode_size
	.type	injector_shellcode_size, @object
	.size	injector_shellcode_size, 4
injector_shellcode_size:
	// distance from injector_shellcode to current.
	.int	. - injector_shellcode
#endif

```

`src/w1nj3ct/platform/linux/impl/util.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2018 Kubo Takehiro <kubo@jiubao.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include <stdio.h>
#include <stdarg.h>
#include "injector_internal.h"

char injector__errmsg[512];
char injector__errmsg_is_set;

void injector__set_errmsg(const char* format, ...) {
  va_list ap;
  int rv;

  /* prevent the error message from being overwritten. */
  if (injector__errmsg_is_set) {
    return;
  }
  injector__errmsg_is_set = 1;

  va_start(ap, format);
  rv = vsnprintf(injector__errmsg, sizeof(injector__errmsg), format, ap);
  va_end(ap);
  if (rv == -1 || rv >= sizeof(injector__errmsg)) {
    injector__errmsg[sizeof(injector__errmsg) - 1] = '\0';
  }
}

const char* injector__arch2name(arch_t arch) {
  switch (arch) {
  case ARCH_X86_64:
    return "x86_64";
  case ARCH_X86_64_X32:
    return "x86_64 x32-ABI";
  case ARCH_I386:
    return "i386";
  case ARCH_ARM64:
    return "ARM64";
  case ARCH_ARM_EABI_THUMB:
    return "ARM EABI thumb";
  case ARCH_ARM_EABI:
    return "ARM EABI";
  case ARCH_MIPS_64:
    return "MIPS 64";
  case ARCH_MIPS_N32:
    return "MIPS N32 ABI";
  case ARCH_MIPS_O32:
    return "MIPS O32 ABI";
  case ARCH_POWERPC_64:
    return "PowerPC 64-bit";
  case ARCH_POWERPC:
    return "PowerPC";
  case ARCH_RISCV_64:
    return "RISC-V 64";
  case ARCH_RISCV_32:
    return "RISC-V 32";
  }
  return "?";
}

```

`src/w1nj3ct/platform/linux/linux_injector.cpp`:

```cpp
#include "linux_injector.hpp"
#include "error.hpp"
#include <chrono>
#include <redlog.hpp>

// include the kubo injector backend
extern "C" {
#include "impl/injector.h"
}

#include <cerrno>
#include <cstdlib>
#include <cstring>
#include <dirent.h>
#include <fstream>
#include <sstream>
#include <sys/personality.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#ifndef ADDR_NO_RANDOMIZE
#define ADDR_NO_RANDOMIZE 0x0040000
#endif

namespace w1::inject::linux_impl {

result inject_runtime(const config& cfg) {
  auto log = redlog::get_logger("w1nj3ct.linux");

  log.info("linux runtime injection starting", redlog::field("library_path", cfg.library_path));

  // validate we have a target
  if (!cfg.pid && !cfg.process_name) {
    log.error("no target specified for runtime injection");
    return make_error_result(error_code::configuration_invalid, "no target specified");
  }

  int target_pid = -1;

  // resolve process name to pid if needed
  if (cfg.process_name) {
    log.debug("resolving process name to pid", redlog::field("name", *cfg.process_name));

    auto processes = find_processes_by_name(*cfg.process_name);
    if (processes.empty()) {
      log.error("no processes found with specified name", redlog::field("name", *cfg.process_name));
      return make_error_result(error_code::target_not_found, *cfg.process_name);
    }
    if (processes.size() > 1) {
      log.error(
          "multiple processes found with specified name", redlog::field("name", *cfg.process_name),
          redlog::field("count", processes.size())
      );
      return make_error_result(error_code::multiple_targets_found, *cfg.process_name);
    }
    target_pid = processes[0].pid;
  } else {
    target_pid = *cfg.pid;
  }

  log.info("targeting process for injection", redlog::field("pid", target_pid));

  // validate library exists
  if (access(cfg.library_path.c_str(), F_OK) != 0) {
    log.error("library file not found", redlog::field("library_path", cfg.library_path), redlog::field("errno", errno));
    return make_error_result(error_code::library_not_found, "library not found: " + cfg.library_path);
  }

  log.debug("library file validated", redlog::field("library_path", cfg.library_path));

  // attach to process using kubo injector
  auto attach_start = std::chrono::steady_clock::now();
  injector_t* injector = nullptr;
  int attach_result = injector_attach(&injector, target_pid);

  if (attach_result != INJERR_SUCCESS) {
    const char* error_msg = injector_error();
    log.error(
        "failed to attach to target process", redlog::field("pid", target_pid),
        redlog::field("error_code", attach_result), redlog::field("error_msg", error_msg ? error_msg : "unknown")
    );

    // map injector error codes to our error codes
    error_code mapped_error;
    switch (attach_result) {
    case INJERR_NO_PROCESS:
      mapped_error = error_code::target_not_found;
      break;
    case INJERR_PERMISSION:
      mapped_error = error_code::target_access_denied;
      break;
    case INJERR_NO_MEMORY:
      mapped_error = error_code::out_of_memory;
      break;
    case INJERR_UNSUPPORTED_TARGET:
      mapped_error = error_code::target_invalid_architecture;
      break;
    default:
      mapped_error = error_code::injection_failed;
      break;
    }

    return make_error_result(mapped_error, error_msg ? error_msg : "attach failed", attach_result);
  }

  auto attach_duration = std::chrono::steady_clock::now() - attach_start;
  auto attach_ms = std::chrono::duration_cast<std::chrono::milliseconds>(attach_duration).count();
  log.debug(
      "successfully attached to target process", redlog::field("pid", target_pid),
      redlog::field("attach_time_ms", attach_ms)
  );

  // inject library
  auto inject_start = std::chrono::steady_clock::now();
  void* handle = nullptr;
  int inject_result = injector_inject(injector, cfg.library_path.c_str(), &handle);

  if (inject_result != INJERR_SUCCESS) {
    const char* error_msg = injector_error();
    log.error(
        "library injection failed", redlog::field("pid", target_pid), redlog::field("library_path", cfg.library_path),
        redlog::field("error_code", inject_result), redlog::field("error_msg", error_msg ? error_msg : "unknown")
    );

    // detach before returning error
    injector_detach(injector);

    // map injector error codes to our error codes
    error_code mapped_error;
    switch (inject_result) {
    case INJERR_FILE_NOT_FOUND:
      mapped_error = error_code::library_not_found;
      break;
    case INJERR_NO_MEMORY:
      mapped_error = error_code::out_of_memory;
      break;
    case INJERR_ERROR_IN_TARGET:
      mapped_error = error_code::injection_failed;
      break;
    case INJERR_PERMISSION:
      mapped_error = error_code::target_access_denied;
      break;
    case INJERR_UNSUPPORTED_TARGET:
      mapped_error = error_code::target_invalid_architecture;
      break;
    default:
      mapped_error = error_code::injection_failed;
      break;
    }

    return make_error_result(mapped_error, error_msg ? error_msg : "injection failed", inject_result);
  }

  // detach from process
  int detach_result = injector_detach(injector);
  if (detach_result != INJERR_SUCCESS) {
    const char* error_msg = injector_error();
    log.warn(
        "failed to detach from target process", redlog::field("pid", target_pid),
        redlog::field("error_code", detach_result), redlog::field("error_msg", error_msg ? error_msg : "unknown")
    );
    // continue anyway since injection succeeded
  }

  auto inject_duration = std::chrono::steady_clock::now() - inject_start;
  auto inject_ms = std::chrono::duration_cast<std::chrono::milliseconds>(inject_duration).count();
  auto total_ms =
      std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - attach_start).count();

  log.info(
      "runtime injection completed successfully", redlog::field("pid", target_pid),
      redlog::field("library_path", cfg.library_path), redlog::field("handle", handle),
      redlog::field("inject_time_ms", inject_ms), redlog::field("total_time_ms", total_ms)
  );

  return make_success_result(target_pid);
}

result inject_preload(const config& cfg) {
  auto log = redlog::get_logger("w1nj3ct.linux");

  log.info(
      "linux preload injection starting", redlog::field("binary_path", cfg.binary_path ? *cfg.binary_path : "null"),
      redlog::field("library_path", cfg.library_path), redlog::field("disable_aslr", cfg.disable_aslr)
  );

  if (!cfg.binary_path) {
    log.error("binary_path required for preload injection");
    return make_error_result(error_code::configuration_invalid, "binary_path required for preload injection");
  }

  // validate binary exists and is executable
  if (access(cfg.binary_path->c_str(), F_OK) != 0) {
    log.error("target binary not found", redlog::field("binary_path", *cfg.binary_path), redlog::field("errno", errno));
    return make_error_result(error_code::target_not_found, "binary not found: " + *cfg.binary_path);
  }

  if (access(cfg.binary_path->c_str(), X_OK) != 0) {
    log.error(
        "target binary not executable", redlog::field("binary_path", *cfg.binary_path), redlog::field("errno", errno)
    );
    return make_error_result(error_code::target_access_denied, "binary not executable: " + *cfg.binary_path);
  }

  log.debug("target binary validated", redlog::field("binary_path", *cfg.binary_path));

  // set up environment with LD_PRELOAD
  log.debug("setting up injection environment");

  // start with current environment - use same approach as Darwin version
  std::map<std::string, std::string> env;
  size_t base_env_count = 0;

  for (char** env_var = environ; *env_var != nullptr; env_var++) {
    std::string env_str(*env_var);
    std::string::size_type eq_pos = env_str.find('=');
    if (eq_pos != std::string::npos) {
      std::string key = env_str.substr(0, eq_pos);
      std::string value = env_str.substr(eq_pos + 1);
      env[key] = value;
      base_env_count++;
    }
  }

  log.trace("inherited environment variables", redlog::field("count", base_env_count));

  // add/override with cfg.env_vars
  for (const auto& [key, value] : cfg.env_vars) {
    env[key] = value;
    log.verbose("adding environment variable", redlog::field("key", key), redlog::field("value", value));
  }

  // add LD_PRELOAD
  env["LD_PRELOAD"] = cfg.library_path;
  log.info("configured LD_PRELOAD", redlog::field("library_path", cfg.library_path));

  // build command line
  std::vector<const char*> argv;
  argv.push_back(cfg.binary_path->c_str());
  for (const auto& arg : cfg.args) {
    argv.push_back(arg.c_str());
    log.trace("adding command argument", redlog::field("arg", arg));
  }
  argv.push_back(nullptr);

  log.debug("command line prepared", redlog::field("argc", argv.size() - 1));

  // build environment
  std::vector<std::string> env_strings;
  std::vector<const char*> envp;
  for (const auto& [key, value] : env) {
    env_strings.push_back(key + "=" + value);
    envp.push_back(env_strings.back().c_str());
  }
  envp.push_back(nullptr);

  log.debug("environment prepared", redlog::field("env_count", env.size()));

  // fork and exec with modified environment
  if (cfg.disable_aslr) {
    log.debug("launching target process with ASLR disabled");
  } else {
    log.debug("launching target process");
  }
  auto launch_start = std::chrono::steady_clock::now();

  pid_t child_pid = fork();
  if (child_pid == 0) {
    // child process

    // disable ASLR if requested
    if (cfg.disable_aslr) {
      log.trace("disabling ASLR using personality()");
      unsigned long pers_value = PER_LINUX | ADDR_NO_RANDOMIZE;

      if (personality(pers_value) < 0) {
        // try again to confirm error
        if (personality(pers_value) < 0) {
          int pers_errno = errno;
          fprintf(
              stderr, "[w1nj3ct.linux] personality failed to disable ASLR: %s (errno=%d)\n", strerror(pers_errno),
              pers_errno
          );
          // continue anyway - some systems may not support this
        }
      }
    }

    log.trace("child process starting execve", redlog::field("binary_path", *cfg.binary_path));
    execve(cfg.binary_path->c_str(), const_cast<char**>(argv.data()), const_cast<char**>(envp.data()));
    // execve only returns on error
    _exit(1);
  } else if (child_pid > 0) {
    // parent process - conditionally wait for child to complete
    if (cfg.wait_for_completion) {
      log.debug("waiting for child process", redlog::field("child_pid", child_pid));

      int status;
      pid_t wait_result = waitpid(child_pid, &status, 0);

      auto launch_duration = std::chrono::steady_clock::now() - launch_start;
      auto launch_ms = std::chrono::duration_cast<std::chrono::milliseconds>(launch_duration).count();

      if (wait_result == -1) {
        log.error("waitpid failed", redlog::field("child_pid", child_pid), redlog::field("errno", errno));
        return make_error_result(error_code::launch_failed, "waitpid failed", errno);
      }

      if (WIFEXITED(status)) {
        int exit_code = WEXITSTATUS(status);
        log.info(
            "child process exited", redlog::field("child_pid", child_pid), redlog::field("exit_code", exit_code),
            redlog::field("execution_time_ms", launch_ms)
        );

        // injection was successful regardless of target exit code
        auto result = make_success_result(child_pid);
        result.target_exit_code = exit_code;
        return result;
      } else if (WIFSIGNALED(status)) {
        int signal = WTERMSIG(status);
        log.error(
            "child process terminated by signal", redlog::field("child_pid", child_pid),
            redlog::field("signal", signal), redlog::field("execution_time_ms", launch_ms)
        );
        return make_error_result(
            error_code::launch_failed, "child process terminated by signal " + std::to_string(signal)
        );
      } else {
        log.error(
            "child process exited with unknown status", redlog::field("child_pid", child_pid),
            redlog::field("status", status)
        );
        return make_error_result(error_code::launch_failed, "child process exited with unknown status");
      }
    } else {
      log.info(
          "preload injection started successfully - not waiting for completion", redlog::field("child_pid", child_pid)
      );
      return make_success_result(child_pid);
    }
  } else {
    // fork failed
    log.error("fork failed", redlog::field("errno", errno));
    return make_error_result(error_code::launch_failed, "fork failed", errno);
  }
}

std::vector<process_info> list_processes() {
  std::vector<process_info> processes;

  DIR* proc_dir = opendir("/proc");
  if (!proc_dir) {
    return processes;
  }

  struct dirent* entry;
  while ((entry = readdir(proc_dir)) != nullptr) {
    // check if directory name is a number (pid)
    char* endptr;
    int pid = strtol(entry->d_name, &endptr, 10);
    if (*endptr != '\0' || pid <= 0) {
      continue;
    }

    process_info info;
    info.pid = pid;

    // read process name from /proc/pid/comm
    std::string comm_path = "/proc/" + std::string(entry->d_name) + "/comm";
    std::ifstream comm_file(comm_path);
    if (comm_file.is_open()) {
      std::getline(comm_file, info.name);
      // remove trailing newline if present
      if (!info.name.empty() && info.name.back() == '\n') {
        info.name.pop_back();
      }
    }

    // read command line from /proc/pid/cmdline
    std::string cmdline_path = "/proc/" + std::string(entry->d_name) + "/cmdline";
    std::ifstream cmdline_file(cmdline_path, std::ios::binary);
    if (cmdline_file.is_open()) {
      std::string cmdline;
      std::getline(cmdline_file, cmdline, '\0'); // first argument is the executable
      if (!cmdline.empty()) {
        info.full_path = cmdline;

        // rebuild full command line with spaces
        std::string full_cmdline;
        cmdline_file.seekg(0);
        char c;
        while (cmdline_file.get(c)) {
          if (c == '\0') {
            full_cmdline += ' ';
          } else {
            full_cmdline += c;
          }
        }
        if (!full_cmdline.empty() && full_cmdline.back() == ' ') {
          full_cmdline.pop_back();
        }
        info.command_line = full_cmdline;
      }
    }

    processes.push_back(info);
  }

  closedir(proc_dir);
  return processes;
}

std::vector<process_info> find_processes_by_name(const std::string& name) {
  std::vector<process_info> matches;
  auto all_processes = list_processes();

  for (const auto& proc : all_processes) {
    // match by process name (comm)
    if (proc.name == name) {
      matches.push_back(proc);
      continue;
    }

    // also try matching by executable path basename
    if (!proc.full_path.empty()) {
      size_t last_slash = proc.full_path.find_last_of('/');
      std::string basename = (last_slash != std::string::npos) ? proc.full_path.substr(last_slash + 1) : proc.full_path;
      if (basename == name) {
        matches.push_back(proc);
      }
    }
  }

  return matches;
}

std::optional<process_info> get_process_info(int pid) {
  auto all_processes = list_processes();

  for (const auto& proc : all_processes) {
    if (proc.pid == pid) {
      return proc;
    }
  }

  return std::nullopt;
}

bool check_injection_capabilities() {
  // use the kubo injector's capability check if available
  // for now, do a basic ptrace capability test
  pid_t child_pid = fork();
  if (child_pid == 0) {
    // child process - sleep briefly then exit
    usleep(100000); // 100ms
    _exit(0);
  } else if (child_pid > 0) {
    // parent process - try to attach to child using kubo injector
    usleep(10000); // 10ms - give child time to start

    injector_t* injector = nullptr;
    int attach_result = injector_attach(&injector, child_pid);
    if (attach_result == INJERR_SUCCESS) {
      injector_detach(injector);

      // wait for child to exit
      int status;
      waitpid(child_pid, &status, 0);
      return true;
    }

    // wait for child to exit even if attach failed
    int status;
    waitpid(child_pid, &status, 0);
    return false;
  } else {
    // fork failed
    return false;
  }
}

} // namespace w1::inject::linux_impl
```

`src/w1nj3ct/platform/linux/linux_injector.hpp`:

```hpp
#pragma once

#include "w1nj3ct.hpp"

namespace w1::inject::linux_impl {
// wrapper for linux injection (using kubo/injector backend when available)
result inject_runtime(const config& cfg);
result inject_preload(const config& cfg);

// process discovery
std::vector<process_info> list_processes();
std::vector<process_info> find_processes_by_name(const std::string& name);
std::optional<process_info> get_process_info(int pid);

// capabilities check
bool check_injection_capabilities();
} // namespace w1::inject::linux_impl
```

`src/w1nj3ct/platform/windows/error_windows.cpp`:

```cpp
#include "error.hpp"
#include <string>
#include <windows.h>

std::string translate_platform_error(DWORD error_code) {
  LPSTR messageBuffer = nullptr;
  size_t size = FormatMessageA(
      FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, error_code,
      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) &messageBuffer, 0, NULL
  );

  std::string message(messageBuffer, size);
  LocalFree(messageBuffer);
  return message;
}
```

`src/w1nj3ct/platform/windows/impl/auxiliary.cpp`:

```cpp
#include <windows.h>
#include <TlHelp32.h>
#include <sstream>
#include "inject.hpp"
#include "util.hpp"

DWORD find_pid_by_name(const std::wstring& process_name) {
  log_msg("searching for process ID by name");

  HANDLE h_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (h_snapshot == INVALID_HANDLE_VALUE) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to create process snapshot. Error code: " << error;
    log_msg(ss.str());
    return 0;
  }

  PROCESSENTRY32 pe32;
  pe32.dwSize = sizeof(PROCESSENTRY32);

  if (!Process32First(h_snapshot, &pe32)) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to get first process. Error code: " << error;
    log_msg(ss.str());
    CloseHandle(h_snapshot);
    return 0;
  }

  DWORD pid = 0;
  do {
    if (_wcsicmp((wchar_t*) pe32.szExeFile, process_name.c_str()) == 0) {
      pid = pe32.th32ProcessID;
      break;
    }
  } while (Process32Next(h_snapshot, &pe32));

  CloseHandle(h_snapshot);

  if (pid != 0) {
    std::stringstream ss;
    ss << "process ID found: " << pid;
    log_msg(ss.str());
  } else {
    log_msg("process not found");
  }

  return pid;
}

DWORD get_thread_id(DWORD pid) {
  log_msg("searching for thread ID");

  HANDLE h_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
  if (h_snapshot == INVALID_HANDLE_VALUE) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to create thread snapshot. Error code: " << error;
    log_msg(ss.str());
    return 0;
  }

  THREADENTRY32 te32;
  te32.dwSize = sizeof(THREADENTRY32);

  if (!Thread32First(h_snapshot, &te32)) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to get first thread. Error code: " << error;
    log_msg(ss.str());
    CloseHandle(h_snapshot);
    return 0;
  }

  DWORD thread_id = 0;
  do {
    if (te32.th32OwnerProcessID == pid) {
      HANDLE h_thread = OpenThread(READ_CONTROL, FALSE, te32.th32ThreadID);
      if (h_thread == NULL) {
        DWORD error = GetLastError();
        std::stringstream ss;
        ss << "Failed to open thread. Error code: " << error;
        log_msg(ss.str());
      } else {
        thread_id = te32.th32ThreadID;
        CloseHandle(h_thread);
        break;
      }
    }
  } while (Thread32Next(h_snapshot, &te32));

  CloseHandle(h_snapshot);

  if (thread_id != 0) {
    std::stringstream ss;
    ss << "thread ID found: " << thread_id;
    log_msg(ss.str());
  } else {
    log_msg("thread not found");
  }

  return thread_id;
}

BOOL set_se_debug_privilege() {
  log_msg("attempting to set SeDebugPrivilege");

  HANDLE h_token = NULL;
  TOKEN_PRIVILEGES tp;
  LUID luid;

  if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &h_token)) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to open process token. Error code: " << error;
    log_msg(ss.str());
    return FALSE;
  }

  if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid)) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to lookup privilege value. Error code: " << error;
    log_msg(ss.str());
    CloseHandle(h_token);
    return FALSE;
  }

  tp.PrivilegeCount = 1;
  tp.Privileges[0].Luid = luid;
  tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

  if (!AdjustTokenPrivileges(h_token, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to adjust token privileges. Error code: " << error;
    log_msg(ss.str());
    CloseHandle(h_token);
    return FALSE;
  }

  if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) {
    log_msg("warning: the token does not have the specified privilege");
    CloseHandle(h_token);
    return FALSE;
  }

  log_msg("SeDebugPrivilege enabled successfully");
  CloseHandle(h_token);
  return TRUE;
}

```

`src/w1nj3ct/platform/windows/impl/auxiliary.hpp`:

```hpp
#pragma once

#include <string>
#include <w1base/windows_clean.hpp>

// find the process ID of a given process name
// returns 0 if the process is not found
DWORD find_pid_by_name(const std::wstring& process_name);

// get the thread ID of the first thread in a given process
// returns 0 if no thread is found
DWORD get_thread_id(DWORD pid);

// set the SeDebugPrivilege for the current process
// returns TRUE if successful, FALSE otherwise
BOOL set_se_debug_privilege();
```

`src/w1nj3ct/platform/windows/impl/inject.hpp`:

```hpp
#pragma once

#include <map>
#include <string>
#include <vector>

// completely clean interface, no windows dependencies
namespace w1::inject::windows {

// opaque types for clean interface
using process_handle = void*;
using process_id = unsigned long;

// injection methods
bool inject_dll_create_remote_thread(process_handle h_process, const std::wstring& dll_path);
bool inject_dll_set_windows_hook_ex(process_handle h_process, process_id pid, const std::wstring& dll_path);
bool inject_dll_rtl_create_user_thread(process_handle h_process, const std::wstring& dll_path);
bool inject_dll_reflective_loader(process_handle h_process, const std::wstring& dll_path);
bool inject_dll_launch_suspended(
    const std::wstring& binary_path, const std::wstring& dll_path, const std::vector<std::string>& args,
    const std::map<std::string, std::string>& env_vars, process_id* out_pid, bool interactive_resume,
    bool wait_for_completion, bool disable_aslr = false, int* out_exit_code = nullptr
);

} // namespace w1::inject::windows

```

`src/w1nj3ct/platform/windows/impl/inject_createremotethread.cpp`:

```cpp
#include <sstream>

#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "winapis.h"
#include "inject.hpp"
#include "util.hpp"

// internal windows implementation
static BOOL inject_dll_create_remote_thread_impl(HANDLE h_process, const std::wstring& dll_path) {
  // this function injects a dll into a target process using the createremotethread method
  log_msg("starting CreateRemoteThread injection method");

  // allocate memory in the target process for the dll path
  log_msg("allocating memory in the target process");
  LPVOID remote_memory = VirtualAllocEx(h_process, NULL, dll_path.size() * sizeof(wchar_t), MEM_COMMIT, PAGE_READWRITE);
  if (!remote_memory) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to allocate memory in the target process. Error code: " << error;
    log_msg(ss.str());
    return FALSE;
  }
  log_msg("memory allocated successfully");

  // write the dll path to the allocated memory in the target process
  log_msg("writing DLL path to the allocated memory");
  SIZE_T bytes_written;
  if (!WriteProcessMemory(
          h_process, remote_memory, dll_path.c_str(), dll_path.size() * sizeof(wchar_t), &bytes_written
      )) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to write to process memory. Error code: " << error;
    log_msg(ss.str());
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  if (bytes_written != dll_path.size() * sizeof(wchar_t)) {
    log_msg("incomplete write to process memory");
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  log_msg("DLL path written successfully");

  // get the address of LoadLibraryW function, which we'll use to load our dll in the target process
  log_msg("getting address of LoadLibraryW");
  LPTHREAD_START_ROUTINE load_library_addr =
      (LPTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "LoadLibraryW");
  if (!load_library_addr) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to get address of LoadLibraryW. Error code: " << error;
    log_msg(ss.str());
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  // log_msg("LoadLibraryW address obtained");
  {
    std::stringstream ss;
    ss << "loadLibraryW address obtained: " << std::hex << load_library_addr;
    log_msg(ss.str());
  }

  // create a remote thread in the target process that calls LoadLibraryW with our dll path
  log_msg("creating remote thread");
  HANDLE h_thread = CreateRemoteThread(h_process, NULL, 0, load_library_addr, remote_memory, 0, NULL);
  if (!h_thread) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to create remote thread. Error code: " << error;
    log_msg(ss.str());
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  log_msg("remote thread created successfully");

  // wait for the remote thread to finish executing
  log_msg("waiting for remote thread to finish");
  DWORD wait_result = WaitForSingleObject(h_thread, INFINITE);
  if (wait_result != WAIT_OBJECT_0) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "WaitForSingleObject failed. Error code: " << error;
    log_msg(ss.str());
    CloseHandle(h_thread);
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  log_msg("remote thread finished execution");

  // get the exit code of the remote thread to check if dll injection was successful
  DWORD exit_code;
  if (GetExitCodeThread(h_thread, &exit_code)) {
    std::stringstream ss;
    ss << "remote thread exit code: " << exit_code;
    log_msg(ss.str());
    if (exit_code == 0) {
      log_msg("DLL injection may have failed (exit code is 0)");
    }
  } else {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to get remote thread exit code. Error code: " << error;
    log_msg(ss.str());
  }

  // clean up resources
  log_msg("cleaning up");
  if (!VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE)) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to free memory in target process. Error code: " << error;
    log_msg(ss.str());
  }
  CloseHandle(h_thread);

  log_msg("CreateRemoteThread injection completed");
  return TRUE;
}

// clean wrapper for the public api
bool w1::inject::windows::inject_dll_create_remote_thread(process_handle h_process, const std::wstring& dll_path) {
  HANDLE win_handle = static_cast<HANDLE>(h_process);
  BOOL result = inject_dll_create_remote_thread_impl(win_handle, dll_path);
  return result != FALSE;
}

```

`src/w1nj3ct/platform/windows/impl/inject_launch.cpp`:

```cpp
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <sstream>
#include <string>

#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

// Windows version constants for process mitigation
#ifndef PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_OFF
#define PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_OFF (0x00000001ULL << 56)
#endif

#ifndef PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY
#define PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY 0x00020007
#endif

#include "winapis.h"
#include "inject.hpp"
#include "util.hpp"

// convert std::string to std::wstring
std::wstring string_to_wstring(const std::string& str) {
  if (str.empty()) {
    return std::wstring();
  }
  int size = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, nullptr, 0);
  std::wstring result(size - 1, 0);
  MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, &result[0], size);
  return result;
}

// build command line string from binary path and arguments
std::wstring build_command_line(const std::wstring& binary_path, const std::vector<std::string>& args) {
  std::wstring cmd_line = L"\"" + binary_path + L"\"";

  for (const auto& arg : args) {
    cmd_line += L" \"" + string_to_wstring(arg) + L"\"";
  }

  return cmd_line;
}

// internal windows implementation
static BOOL inject_dll_launch_suspended_impl(
    const std::wstring& binary_path, const std::wstring& dll_path, const std::vector<std::string>& args,
    const std::map<std::string, std::string>& env_vars, DWORD* out_pid, bool interactive_resume,
    bool wait_for_completion, bool disable_aslr, int* out_exit_code
) {
  if (disable_aslr) {
    log_msg("starting Windows launch injection with suspended process (ASLR disabled)");
  } else {
    log_msg("starting Windows launch injection with suspended process");
  }

  // validate library exists
  if (GetFileAttributesW(dll_path.c_str()) == INVALID_FILE_ATTRIBUTES) {
    std::stringstream ss;
    ss << "Library not found at path: " << std::string(dll_path.begin(), dll_path.end());
    log_msg(ss.str());
    return FALSE;
  }

  // validate binary exists
  if (GetFileAttributesW(binary_path.c_str()) == INVALID_FILE_ATTRIBUTES) {
    std::stringstream ss;
    ss << "Binary not found at path: " << std::string(binary_path.begin(), binary_path.end());
    log_msg(ss.str());
    return FALSE;
  }

  // build command line
  std::wstring command_line = build_command_line(binary_path, args);

  {
    std::stringstream ss;
    ss << "Target binary: " << std::string(binary_path.begin(), binary_path.end());
    log_msg(ss.str());
  }

  // build environment block
  LPVOID environment_block = nullptr;
  if (!env_vars.empty()) {
    log_msg("building environment block");

    // Get current environment
    LPWCH current_env = GetEnvironmentStringsW();
    if (!current_env) {
      log_msg("failed to get current environment");
      return FALSE;
    }

    // parse current environment into a map
    std::map<std::wstring, std::wstring> env_map;
    LPWCH env_ptr = current_env;
    while (*env_ptr) {
      std::wstring env_entry(env_ptr);
      size_t eq_pos = env_entry.find(L'=');
      if (eq_pos != std::wstring::npos) {
        std::wstring key = env_entry.substr(0, eq_pos);
        std::wstring value = env_entry.substr(eq_pos + 1);
        env_map[key] = value;
      }
      env_ptr += env_entry.length() + 1;
    }
    FreeEnvironmentStringsW(current_env);

    // add/override with custom environment variables
    for (const auto& [key, value] : env_vars) {
      std::wstring wkey = string_to_wstring(key);
      std::wstring wvalue = string_to_wstring(value);
      env_map[wkey] = wvalue;

      std::stringstream ss;
      ss << "setting environment variable: " << key << "=" << value;
      log_msg(ss.str());
    }

    // build environment block
    std::wstring env_block;
    for (const auto& [key, value] : env_map) {
      env_block += key + L"=" + value + L'\0';
    }
    env_block += L'\0'; // Double null terminator

    // Allocate memory for environment block
    size_t env_size = env_block.size() * sizeof(wchar_t);
    environment_block = malloc(env_size);
    if (!environment_block) {
      log_msg("failed to allocate memory for environment block");
      return FALSE;
    }
    memcpy(environment_block, env_block.c_str(), env_size);

    std::stringstream ss;
    ss << "environment block created with " << env_map.size() << " variables";
    log_msg(ss.str());
  }

  {
    std::stringstream ss;
    ss << "command line: " << std::string(command_line.begin(), command_line.end());
    log_msg(ss.str());
  }

  {
    std::stringstream ss;
    ss << "library to inject: " << std::string(dll_path.begin(), dll_path.end());
    log_msg(ss.str());
  }

  // create process in suspended state
  PROCESS_INFORMATION pi = {0};

  // createProcessW modifies the command line, so we need a mutable copy
  std::vector<wchar_t> cmd_line_buffer(command_line.begin(), command_line.end());
  cmd_line_buffer.push_back(L'\0');

  DWORD creation_flags = CREATE_SUSPENDED;
  if (environment_block) {
    creation_flags |= CREATE_UNICODE_ENVIRONMENT;
  }

  BOOL create_result = FALSE;

  if (disable_aslr) {
    log_msg("creating suspended process with ASLR disabled");

    // Use extended startup info for process mitigation policy
    STARTUPINFOEXW siex = {0};
    siex.StartupInfo.cb = sizeof(STARTUPINFOEXW);

    // Initialize attribute list
    SIZE_T attr_size = 0;
    InitializeProcThreadAttributeList(NULL, 1, 0, &attr_size);

    LPPROC_THREAD_ATTRIBUTE_LIST attr_list = (LPPROC_THREAD_ATTRIBUTE_LIST) malloc(attr_size);
    if (!attr_list) {
      log_msg("failed to allocate memory for attribute list");
      if (environment_block) {
        free(environment_block);
      }
      return FALSE;
    }

    if (!InitializeProcThreadAttributeList(attr_list, 1, 0, &attr_size)) {
      DWORD error = GetLastError();
      std::stringstream ss;
      ss << "Failed to initialize attribute list. Error code: " << error;
      log_msg(ss.str());
      free(attr_list);
      if (environment_block) {
        free(environment_block);
      }
      return FALSE;
    }

    // Set mitigation policy to disable ASLR
    DWORD64 mitigation_policy = PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_OFF;

    if (!UpdateProcThreadAttribute(
            attr_list, 0, PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, &mitigation_policy, sizeof(mitigation_policy), NULL,
            NULL
        )) {
      DWORD error = GetLastError();
      std::stringstream ss;
      ss << "Failed to update mitigation policy attribute. Error code: " << error;
      log_msg(ss.str());
      DeleteProcThreadAttributeList(attr_list);
      free(attr_list);
      if (environment_block) {
        free(environment_block);
      }
      return FALSE;
    }

    siex.lpAttributeList = attr_list;
    creation_flags |= EXTENDED_STARTUPINFO_PRESENT;

    create_result = CreateProcessW(
        binary_path.c_str(),    // lpApplicationName
        cmd_line_buffer.data(), // lpCommandLine (must be mutable)
        NULL,                   // lpProcessAttributes
        NULL,                   // lpThreadAttributes
        TRUE,                   // bInheritHandles
        creation_flags,         // dwCreationFlags
        environment_block,      // lpEnvironment
        NULL,                   // lpCurrentDirectory
        (LPSTARTUPINFOW) &siex, // lpStartupInfo
        &pi                     // lpProcessInformation
    );

    // Clean up attribute list
    DeleteProcThreadAttributeList(attr_list);
    free(attr_list);

  } else {
    log_msg("creating suspended process");

    STARTUPINFOW si = {0};
    si.cb = sizeof(si);

    create_result = CreateProcessW(
        binary_path.c_str(),    // lpApplicationName
        cmd_line_buffer.data(), // lpCommandLine (must be mutable)
        NULL,                   // lpProcessAttributes
        NULL,                   // lpThreadAttributes
        TRUE,                   // bInheritHandles
        creation_flags,         // dwCreationFlags
        environment_block,      // lpEnvironment
        NULL,                   // lpCurrentDirectory
        &si,                    // lpStartupInfo
        &pi                     // lpProcessInformation
    );
  }

  if (!create_result) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to create suspended process. Error code: " << error;
    log_msg(ss.str());
    if (environment_block) {
      free(environment_block);
    }
    return FALSE;
  }

  {
    std::stringstream ss;
    ss << "process created successfully with PID: " << pi.dwProcessId;
    log_msg(ss.str());
  }

  // get address of LoadLibraryW function
  log_msg("getting address of LoadLibraryW");
  LPTHREAD_START_ROUTINE load_library_addr =
      (LPTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "LoadLibraryW");

  if (!load_library_addr) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to get address of LoadLibraryW. Error code: " << error;
    log_msg(ss.str());
    TerminateProcess(pi.hProcess, -1);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    if (environment_block) {
      free(environment_block);
    }
    return FALSE;
  }

  {
    std::stringstream ss;
    ss << "loadLibraryW address obtained: " << std::hex << load_library_addr;
    log_msg(ss.str());
  }

  // allocate memory in the target process for the DLL path
  log_msg("allocating memory in suspended process");
  SIZE_T dll_path_size = (dll_path.length() + 1) * sizeof(wchar_t);
  LPVOID remote_memory = VirtualAllocEx(pi.hProcess, NULL, dll_path_size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

  if (!remote_memory) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to allocate memory in suspended process. Error code: " << error;
    log_msg(ss.str());
    TerminateProcess(pi.hProcess, -1);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    if (environment_block) {
      free(environment_block);
    }
    return FALSE;
  }

  log_msg("memory allocated successfully");

  // write the DLL path to the allocated memory
  log_msg("writing DLL path to process memory");
  SIZE_T bytes_written;
  if (!WriteProcessMemory(pi.hProcess, remote_memory, dll_path.c_str(), dll_path_size, &bytes_written)) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to write DLL path to process memory. Error code: " << error;
    log_msg(ss.str());
    VirtualFreeEx(pi.hProcess, remote_memory, 0, MEM_RELEASE);
    TerminateProcess(pi.hProcess, -1);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    if (environment_block) {
      free(environment_block);
    }
    return FALSE;
  }

  if (bytes_written != dll_path_size) {
    log_msg("incomplete write to process memory");
    VirtualFreeEx(pi.hProcess, remote_memory, 0, MEM_RELEASE);
    TerminateProcess(pi.hProcess, -1);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    if (environment_block) {
      free(environment_block);
    }
    return FALSE;
  }

  log_msg("DLL path written successfully");

  // create remote thread to load the library
  log_msg("creating remote thread to load library");
  HANDLE remote_thread = CreateRemoteThread(pi.hProcess, NULL, 0, load_library_addr, remote_memory, 0, NULL);

  if (!remote_thread) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to create remote thread. Error code: " << error;
    log_msg(ss.str());
    VirtualFreeEx(pi.hProcess, remote_memory, 0, MEM_RELEASE);
    TerminateProcess(pi.hProcess, -1);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    if (environment_block) {
      free(environment_block);
    }
    return FALSE;
  }

  log_msg("remote thread created successfully");

  // wait for the remote thread to complete (library loading)
  log_msg("waiting for library loading to complete");
  DWORD wait_result = WaitForSingleObject(remote_thread, INFINITE);
  if (wait_result != WAIT_OBJECT_0) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Wait for remote thread failed. Error code: " << error;
    log_msg(ss.str());
    CloseHandle(remote_thread);
    VirtualFreeEx(pi.hProcess, remote_memory, 0, MEM_RELEASE);
    TerminateProcess(pi.hProcess, -1);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    if (environment_block) {
      free(environment_block);
    }
    return FALSE;
  }

  // check if library loading was successful
  DWORD exit_code;
  if (GetExitCodeThread(remote_thread, &exit_code)) {
    std::stringstream ss;
    ss << "library loading thread exit code: " << exit_code;
    log_msg(ss.str());
    if (exit_code == 0) {
      log_msg("warning: library loading may have failed (exit code is 0)");
    }
  }

  CloseHandle(remote_thread);
  VirtualFreeEx(pi.hProcess, remote_memory, 0, MEM_RELEASE);

  log_msg("library loading completed");

  if (interactive_resume) {
    std::stringstream ss;
    ss << "process created and suspended (PID: " << pi.dwProcessId << ")";
    log_msg(ss.str());

    // output to console for user interaction
    std::cout << "process created and suspended (PID: " << pi.dwProcessId << ")" << std::endl;
    std::cout << "binary: " << std::string(binary_path.begin(), binary_path.end()) << std::endl;
    std::cout << "DLL injected successfully. Press Enter to resume process..." << std::endl;

    // wait for user input
    std::cin.get();

    log_msg("user resumed process, continuing execution");
  }

  // resume the main thread
  ResumeThread(pi.hThread);

  log_msg("process resumed successfully");

  // set output PID if requested
  if (out_pid) {
    *out_pid = pi.dwProcessId;
  }

  // conditionally wait for process completion based on configuration
  if (wait_for_completion) {
    log_msg("waiting for target process to complete");
    DWORD wait_result = WaitForSingleObject(pi.hProcess, INFINITE);

    if (wait_result != WAIT_OBJECT_0) {
      DWORD error = GetLastError();
      std::stringstream ss;
      ss << "Wait for process completion failed. Error code: " << error;
      log_msg(ss.str());
      // continue with cleanup, but note the error
    }

    // get process exit code
    DWORD process_exit_code = 0;
    if (GetExitCodeProcess(pi.hProcess, &process_exit_code)) {
      std::stringstream ss;
      ss << "target process completed with exit code: " << process_exit_code;
      log_msg(ss.str());
      if (out_exit_code) {
        *out_exit_code = static_cast<int>(process_exit_code);
      }
    } else {
      log_msg("failed to get process exit code");
    }
  } else {
    log_msg("process launched successfully - not waiting for completion");
  }

  // clean up handles
  CloseHandle(pi.hThread);
  CloseHandle(pi.hProcess);

  // clean up environment block
  if (environment_block) {
    free(environment_block);
  }

  {
    std::stringstream ss;
    ss << "launch injection completed successfully for PID: " << pi.dwProcessId;
    log_msg(ss.str());
  }

  return TRUE;
}

// clean wrapper for the public api
bool w1::inject::windows::inject_dll_launch_suspended(
    const std::wstring& binary_path, const std::wstring& dll_path, const std::vector<std::string>& args,
    const std::map<std::string, std::string>& env_vars, process_id* out_pid, bool interactive_resume,
    bool wait_for_completion, bool disable_aslr, int* out_exit_code
) {
  DWORD win_pid;
  BOOL result = inject_dll_launch_suspended_impl(
      binary_path, dll_path, args, env_vars, &win_pid, interactive_resume, wait_for_completion, disable_aslr,
      out_exit_code
  );
  if (out_pid) {
    *out_pid = static_cast<process_id>(win_pid);
  }
  return result != FALSE;
}
```

`src/w1nj3ct/platform/windows/impl/inject_reflective.cpp`:

```cpp
#include <fstream>
#include <iostream>
#include <string>
#include <vector>

#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "winapis.h"
#include "inject.hpp"
#include "util.hpp"

/**
 * reflective loader implementation:
 * based on https://github.com/Allevon412/ReflectiveDLLInjector
 */

// declare windows API prototypes that will be passed to our loaderstub.
typedef HINSTANCE(WINAPI* f_LoadLibraryA)(const char* lpLibFileName);
typedef UINT_PTR(WINAPI* f_GetProcAddress)(HINSTANCE hModule, const char* lpProcName);
using f_DLL_ENTRY_POINT = BOOL(WINAPI*)(void* hDll, DWORD dwReason, void* pReserved);
using f_OpenProcess = HANDLE(WINAPI*)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
using f_VirtualALlocEx =
    LPVOID(WINAPI*)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);

// declare structure that will be passed to our loader stub that contains necessary information for loading.
struct MANUAL_MAPPING_DATA {
  f_LoadLibraryA pLoadLibraryA;
  f_GetProcAddress pGetProcAddress;
  HINSTANCE hMod;
};

// declare functions.
// perform memory mapping manually in remote process.
BOOL ManualMap(HANDLE hProc, const char* szDllFile);

// performs relocations and loading of dll into process from within the process itself.
void __stdcall LoaderStub(BYTE* imageBase);

// internal windows implementation
static BOOL inject_dll_reflective_loader_impl(HANDLE h_process, const std::wstring& dll_path) {
  // call manual map injection
  // (we need to convert the dll path to a narrow string)
  std::string narrow_dll_path(dll_path.begin(), dll_path.end());
  return ManualMap(h_process, narrow_dll_path.c_str());
}

// function declaration.
BOOL ManualMap(HANDLE hProc, const char* szDllFile) {
  // declare necessary variables.
  BYTE* pSrcData = nullptr;
  IMAGE_NT_HEADERS* pOldNtHeader = nullptr;
  IMAGE_OPTIONAL_HEADER* pOldOptHeader = nullptr;
  IMAGE_FILE_HEADER* pOldFileHeader = nullptr;
  BYTE* pTargetBase = nullptr;

  // ensure that our file exists on disc.
  if (GetFileAttributesA(szDllFile) == INVALID_FILE_ATTRIBUTES) {
    printf("[!] File doesn't exist\n");
    return false;
  }
  printf("[*] Attempting to open file handle\n");
  std::ifstream File(szDllFile, std::ios::binary | std::ios::ate);

  // ensure that we are able to open a file handle.
  if (File.fail()) {
    printf("[!] Opening the file failed: [%X]\n", (DWORD) File.rdstate());
    File.close();
    return false;
  }

  // ensure that our file has a valid size.
  auto FileSize = File.tellg();
  if (FileSize < 0x1000) {
    printf("[!] Filesize is invalid.\n");
    File.close();
    return false;
  }

  // allocate memory for our file using the size as a measure.
  printf("[*] Allocating memory for the dll.\n");
  pSrcData = new BYTE[static_cast<UINT_PTR>(FileSize)];
  if (!pSrcData) {
    printf("[!] Memory Allocation Failed\n");
    File.close();
    return false;
  }

  // read the file into our allocated buffer.
  printf("[*] Memory allocated at location: [0x%p], attempting to read file contents into memory\n", pSrcData);
  File.seekg(0, std::ios::beg);
  File.read(reinterpret_cast<char*>(pSrcData), FileSize);
  File.close();

  // ensure that our file is in the pe format.
  if (reinterpret_cast<IMAGE_DOS_HEADER*>(pSrcData)->e_magic != 0x5A4D) {
    printf("[!] File is not a valid PE file Magic Bytes do not equal \"MZ\"\n");
    delete[] pSrcData;
    return false;
  }

  // create pointers to the PE Optional Header, NtHeaders, and FileHeaders for mapping usage.
  pOldNtHeader =
      reinterpret_cast<IMAGE_NT_HEADERS*>(pSrcData + reinterpret_cast<IMAGE_DOS_HEADER*>(pSrcData)->e_lfanew);
  pOldOptHeader = &pOldNtHeader->OptionalHeader;
  pOldFileHeader = &pOldNtHeader->FileHeader;

#ifdef _WIN64
  if (pOldFileHeader->Machine != IMAGE_FILE_MACHINE_AMD64) {
    printf("[!] Invalid Platform in target DLL: [%x]\n", pOldFileHeader->Machine);
    delete[] pSrcData;
    return false;
  }
#else
  if (pOldFileHeader->Machine != IMAGE_FILE_MACHINE_I386) {
    printf("[!] Invalid Platform in target DLL: [%x]\n", pOldFileHeader->Machine);
    delete[] pSrcData;
    return false;
  }

#endif
  // create a map data structure that will be passed to our LoaderStub.
  MANUAL_MAPPING_DATA mData{0};
  mData.pLoadLibraryA = LoadLibraryA;
  mData.pGetProcAddress = reinterpret_cast<f_GetProcAddress>(GetProcAddress);

  // allocate memory in the target process the size of the image plus the size of the mapping data which will be passed
  // to our loader stub.
  printf(
      "[*] Allocating memory in the size of: [0x%zx] in remote process.\n", pOldOptHeader->SizeOfImage + sizeof(mData)
  );
  pTargetBase = reinterpret_cast<BYTE*>(VirtualAllocEx(
      hProc, nullptr, pOldOptHeader->SizeOfImage + sizeof(mData), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE
  ));

  // if the memory allocation failed.
  if (!pTargetBase) {
    printf("[!] Memory Allocation Failed [0x%X]\n", GetLastError());
    delete[] pSrcData;
    return false;
  }
  printf("[*] Memory Allocation successful. Memory located at: [0x%p]\n", pTargetBase);

  // next we write the headers of our dll into the remote process.
  printf("[*] Writing the Headers of our DLL into target process\n");
  if (!WriteProcessMemory(hProc, pTargetBase, pSrcData, pOldOptHeader->SizeOfHeaders, nullptr)) {
    printf("[!] Error Mapping the Headers into memory please read error code: [0x%X]\n", GetLastError());
    return false;
  }

  // write our sections into the remote process.
  auto* pSectionHeader = IMAGE_FIRST_SECTION(pOldNtHeader);

  // for each section write it into the virtual address of our allocated memory in the remote process using the raw data
  // from our dll file.
  printf("[*] Attempting to write our sections into the remote process\n");
  for (UINT i = 0; i != pOldFileHeader->NumberOfSections; i++, pSectionHeader++) {
    if (pSectionHeader->SizeOfRawData) {
      printf(
          "%5s%s%s%p%s", "[*] Attempting to write section: [", pSectionHeader->Name, "] at location: [0x",
          pTargetBase + pSectionHeader->VirtualAddress, "]\n"
      );
      if (!WriteProcessMemory(
              hProc, pTargetBase + pSectionHeader->VirtualAddress, pSrcData + pSectionHeader->PointerToRawData,
              pSectionHeader->SizeOfRawData, nullptr
          )) {
        printf("[!] Error Mapping the sections error code [0x%X]\n", GetLastError());
        delete[] pSrcData;
        VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
        return false;
      }
    }
  }

  printf(
      "[*] Sections written into memory.\n[*]Attempting to write our mapping data at end of image location: [0x%p]\n",
      pTargetBase + pOldOptHeader->SizeOfImage
  );
  WriteProcessMemory(hProc, pTargetBase + pOldOptHeader->SizeOfImage, &mData, sizeof(mData), nullptr);

  DWORD ImageSize = pOldOptHeader->SizeOfImage;
  delete[] pSrcData;

  // allocate memory in our remote process for our loader stub.
  printf("[*] Attemtping to allocate memory in the remote process for our Loader Stub.\n");
  void* pLoaderStub = VirtualAllocEx(hProc, nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
  if (!pLoaderStub) {
    printf("[!] Loader Memory Allocation Failed [0x%X]\n", GetLastError());
    free(pLoaderStub);
    return false;
  }

  printf(
      "[*] Allocation successful. Loaderstub memory location: [0x%p]\n[*] Attempting to Write LoaderStub\n", pLoaderStub
  );
  // write our loader stub into remote process' memory.
  WriteProcessMemory(hProc, pLoaderStub, LoaderStub, 0x1000, nullptr);

  // create thread in remote process that will start the loader using our DLL and the map data structure as an argument.
  printf("[*] Creating Thread in remote process that will start the loading routine\n");
  HANDLE hThread = CreateRemoteThread(
      hProc, nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(pLoaderStub), pTargetBase, 0, NULL
  );
  if (!hThread) {
    printf("[!] Thread Creation failed exiting: [0x%x]", GetLastError());
    VirtualFreeEx(hProc, pLoaderStub, 0, MEM_RELEASE);
    VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
    return false;
  }
  printf("%5s", "[*] Checking for completion of the loading routine\n");
  HINSTANCE hCheck = NULL;
  while (!hCheck) {
    MANUAL_MAPPING_DATA mapData = {0};
    ReadProcessMemory(hProc, pTargetBase + ImageSize, &mapData, sizeof(mapData), nullptr);
    hCheck = mapData.hMod;
    Sleep(10);
  }

  printf("[*] Loading routine successfully completed. Cleaning up!\n");
  CloseHandle(hThread);

  return true;
}

// clean wrapper for the public api
bool w1::inject::windows::inject_dll_reflective_loader(process_handle h_process, const std::wstring& dll_path) {
  HANDLE win_handle = static_cast<HANDLE>(h_process);
  BOOL result = inject_dll_reflective_loader_impl(win_handle, dll_path);
  return result != FALSE;
}

#define RELOC_FLAG32(relInfo) ((relInfo >> 0xC) == IMAGE_REL_BASED_HIGHLOW)
#define RELOC_FLAG64(relInfo) ((relInfo >> 0xC) == IMAGE_REL_BASED_DIR64)

#ifdef _WIN64
#define RELOC_FLAG RELOC_FLAG64
#else
#define RELOC_FLAG RELOC_FLAG32
#endif

void __stdcall LoaderStub(BYTE* imageBase) {
  if (!imageBase) {
    return;
  }

  // obtain pointers to the base address, optional header, and DLLMain function using the library mapped in memory as
  // our argument.
  BYTE* pBase = imageBase;
  auto* pOpt = &reinterpret_cast<IMAGE_NT_HEADERS*>(pBase + reinterpret_cast<IMAGE_DOS_HEADER*>(imageBase)->e_lfanew)
                    ->OptionalHeader;
  auto _DllMain = reinterpret_cast<f_DLL_ENTRY_POINT>(pBase + pOpt->AddressOfEntryPoint);

  // create a pointer to our mapping data by offsetting the size of the image.
  MANUAL_MAPPING_DATA* pMapData = reinterpret_cast<MANUAL_MAPPING_DATA*>(imageBase + pOpt->SizeOfImage);

  // obtain pointers to tthe LoadLibrary and GetProcAddress functions.
  auto _LoadLibraryA = pMapData->pLoadLibraryA;
  auto _GetProcAddress = pMapData->pGetProcAddress;

  // obtain Relocation Delta.
  BYTE* LocationDelta = pBase - pOpt->ImageBase;
  if (LocationDelta) {
    // ensure there is entries in the relocation table. If not just continue.
    if (!pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size) {
      return;
    }

    // obtain a pointer to the relocation data. Using our mapped image + offset of relocation table's virtual address.
    auto* pRelocData = reinterpret_cast<IMAGE_BASE_RELOCATION*>(
        pBase + pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress
    );

    // while there are entires in the relocation table:
    while (pRelocData->VirtualAddress) {
      // obtain amount of entries for this part of the table.
      UINT AmountOfEntries = (pRelocData->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
      WORD* pRelativeInfo = reinterpret_cast<WORD*>(pRelocData + 1); // obtain the relocation type.
      for (UINT i = 0; i != AmountOfEntries; i++, pRelativeInfo++) {
        if (RELOC_FLAG(*pRelativeInfo)) {
          // obtain the virtual address for our relocation entry.
          UINT_PTR* pPatch =
              reinterpret_cast<UINT_PTR*>(pBase + pRelocData->VirtualAddress + ((*pRelativeInfo) & 0xFFF));
          // add the delta to relocate it to the correct location of the module mapped in the current memory space.
          *pPatch += reinterpret_cast<UINT_PTR>(LocationDelta);
        }
      }
      // obtain next entry in the table.
      pRelocData =
          reinterpret_cast<IMAGE_BASE_RELOCATION*>(reinterpret_cast<BYTE*>(pRelocData) + pRelocData->SizeOfBlock);
    }
  }

  // obtain entries from the import table/
  if (pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size) {
    // obtain the virtual address of the importDescriptor table.
    auto* pImportDescriptor = reinterpret_cast<IMAGE_IMPORT_DESCRIPTOR*>(
        pBase + pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress
    );
    while (pImportDescriptor->Name) {
      // setup pointers to the imported library / function name.
      char* szMod = reinterpret_cast<char*>(pBase + pImportDescriptor->Name);
      HINSTANCE hDLL = _LoadLibraryA(szMod);
      ULONG_PTR* pThunkRef = reinterpret_cast<ULONG_PTR*>(pBase + pImportDescriptor->OriginalFirstThunk);
      ULONG_PTR* pFuncRef = reinterpret_cast<ULONG_PTR*>(pBase + pImportDescriptor->FirstThunk);

      // if the First thunk is null use the next one.
      if (!pThunkRef) {
        pThunkRef = pFuncRef;
      }

      // loop through each function.
      for (; *pThunkRef; ++pThunkRef, ++pFuncRef) {
        // GetProceAddress(lib, "ReadProcessMemory"); name
        // GetProcAddress(lib, (char*)42); ordinal

        // import the functions by ordinal or name.
        if (IMAGE_SNAP_BY_ORDINAL(*pThunkRef)) {
          *pFuncRef = _GetProcAddress(hDLL, reinterpret_cast<char*>(*pThunkRef & 0xFFFF));
        } else {
          auto pImport = reinterpret_cast<IMAGE_IMPORT_BY_NAME*>(pBase + (*pThunkRef));
          *pFuncRef = _GetProcAddress(hDLL, pImport->Name);
        }
      }
      // obtain the next descriptor entry.
      ++pImportDescriptor;
    }
  }

  // find the callback routines and attach them.
  if (pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size) {
    auto* pTLS =
        reinterpret_cast<IMAGE_TLS_DIRECTORY*>(pBase + pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
    auto* pCallBack = reinterpret_cast<PIMAGE_TLS_CALLBACK*>(pTLS->AddressOfCallBacks);
    for (; pCallBack && *pCallBack; ++pCallBack) {
      (*pCallBack)(pBase, DLL_PROCESS_ATTACH, nullptr);
    }
  }

  // execute our DLL by calling the entrypoint address with the argument of DLL_PROCESS_ATTACH.

  // TODO: Write Code that will accept arguments and pass them to the DLLMain function.
  _DllMain(pBase, DLL_PROCESS_ATTACH, nullptr);

  // set our hMod value in our map data so that we can read it from our original process and determine that DLL has been
  // executed properly.
  pMapData->hMod = reinterpret_cast<HINSTANCE>(pBase);
}

```

`src/w1nj3ct/platform/windows/impl/inject_rtlcreateuserthread.cpp`:

```cpp
#include <sstream>

#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "winapis.h"
#include "inject.hpp"
#include "util.hpp"

// internal windows implementation
static BOOL inject_dll_rtl_create_user_thread_impl(HANDLE h_process, const std::wstring& dll_path) {
  log_msg("starting RtlCreateUserThread injection method");

  // allocate memory in the target process for the dll path
  log_msg("allocating memory in the target process");
  LPVOID remote_memory = VirtualAllocEx(h_process, NULL, dll_path.size() * sizeof(wchar_t), MEM_COMMIT, PAGE_READWRITE);
  if (!remote_memory) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to allocate memory in the target process. Error code: " << error;
    log_msg(ss.str());
    return FALSE;
  }
  log_msg("memory allocated successfully");

  // write the dll path to the allocated memory in the target process
  log_msg("writing DLL path to the allocated memory");
  SIZE_T bytes_written;
  if (!WriteProcessMemory(
          h_process, remote_memory, dll_path.c_str(), dll_path.size() * sizeof(wchar_t), &bytes_written
      )) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to write to process memory. Error code: " << error;
    log_msg(ss.str());
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  if (bytes_written != dll_path.size() * sizeof(wchar_t)) {
    log_msg("incomplete write to process memory");
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  log_msg("DLL path written successfully");

  // get the address of LoadLibraryW function
  log_msg("getting address of LoadLibraryW");
  LPTHREAD_START_ROUTINE load_library_addr =
      (LPTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "LoadLibraryW");
  if (!load_library_addr) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to get address of LoadLibraryW. Error code: " << error;
    log_msg(ss.str());
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  {
    std::stringstream ss;
    ss << "loadLibraryW address obtained: " << std::hex << load_library_addr;
    log_msg(ss.str());
  }

  // get the address of RtlCreateUserThread function
  log_msg("getting address of RtlCreateUserThread");
  pRtlCreateUserThread RtlCreateUserThread =
      (pRtlCreateUserThread) GetProcAddress(GetModuleHandle(TEXT("ntdll.dll")), "RtlCreateUserThread");
  if (!RtlCreateUserThread) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to get address of RtlCreateUserThread. Error code: " << error;
    log_msg(ss.str());
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  {
    std::stringstream ss;
    ss << "rtlCreateUserThread address obtained: " << std::hex << (void*) RtlCreateUserThread;
    log_msg(ss.str());
  }

  // create a remote thread using RtlCreateUserThread
  log_msg("creating remote thread using RtlCreateUserThread");
  HANDLE h_thread = NULL;
  DWORD status =
      RtlCreateUserThread(h_process, NULL, FALSE, 0, NULL, NULL, load_library_addr, remote_memory, &h_thread, NULL);

  if (status != 0) {
    std::stringstream ss;
    ss << "Failed to create remote thread. Status: " << std::hex << status;
    log_msg(ss.str());
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  log_msg("remote thread created successfully");

  // wait for the remote thread to finish executing
  log_msg("waiting for remote thread to finish");
  DWORD wait_result = WaitForSingleObject(h_thread, INFINITE);
  if (wait_result != WAIT_OBJECT_0) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "WaitForSingleObject failed. Error code: " << error;
    log_msg(ss.str());
    CloseHandle(h_thread);
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  log_msg("remote thread finished execution");

  // get the exit code of the remote thread to check if dll injection was successful
  DWORD exit_code;
  if (GetExitCodeThread(h_thread, &exit_code)) {
    std::stringstream ss;
    ss << "remote thread exit code: " << exit_code;
    log_msg(ss.str());
    if (exit_code == 0) {
      log_msg("DLL injection may have failed (exit code is 0)");
    }
  } else {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to get remote thread exit code. Error code: " << error;
    log_msg(ss.str());
  }

  // clean up resources
  log_msg("cleaning up");
  if (!VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE)) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to free memory in target process. Error code: " << error;
    log_msg(ss.str());
  }
  CloseHandle(h_thread);

  log_msg("RtlCreateUserThread injection completed");
  return TRUE;
}

// clean wrapper for the public api
bool w1::inject::windows::inject_dll_rtl_create_user_thread(process_handle h_process, const std::wstring& dll_path) {
  HANDLE win_handle = static_cast<HANDLE>(h_process);
  BOOL result = inject_dll_rtl_create_user_thread_impl(win_handle, dll_path);
  return result != FALSE;
}

```

`src/w1nj3ct/platform/windows/impl/inject_setwindowshook.cpp`:

```cpp
#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <tlhelp32.h>
#include <sstream>
#include "util.hpp"
#include "inject.hpp"

// hook procedure that will be called by the windows hook
LRESULT CALLBACK hook_proc(int n_code, WPARAM w_param, LPARAM l_param) {
  log_msg("hook_proc called");
  return CallNextHookEx(NULL, n_code, w_param, l_param);
}

// internal windows implementation
static BOOL inject_dll_set_windows_hook_ex_impl(HANDLE h_process, DWORD process_id, const std::wstring& dll_path) {
  // this function injects a dll into a target process using the setwindowshookex method
  log_msg("starting setwindowshookex injection method");

  // load the dll into the current process
  log_msg("loading dll into current process");
  HMODULE h_module = LoadLibraryW(dll_path.c_str());
  if (!h_module) {
    log_msg("failed to load dll");
    return FALSE;
  }
  log_msg("dll loaded successfully");

  // get the address of the hook procedure from the loaded dll
  log_msg("getting address of hook_proc");
  HOOKPROC hook_proc = (HOOKPROC) GetProcAddress(h_module, "hook_proc");
  if (!hook_proc) {
    log_msg("failed to get address of hook_proc");
    FreeLibrary(h_module);
    return FALSE;
  }
  log_msg("hook_proc address obtained");

  // resume the main thread of the target process
  log_msg("resuming main thread of target process");
  if (ResumeThread(h_process) == -1) {
    log_msg("failed to resume thread");
    FreeLibrary(h_module);
    return FALSE;
  }

  // wait a bit to ensure the process has started
  Sleep(1000);

  // find a thread id for the target process
  log_msg("finding a thread id for the target process");
  DWORD thread_id = 0;
  HANDLE h_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
  if (h_snapshot == INVALID_HANDLE_VALUE) {
    log_msg("failed to create thread snapshot");
    FreeLibrary(h_module);
    return FALSE;
  }

  THREADENTRY32 te;
  te.dwSize = sizeof(THREADENTRY32);
  if (Thread32First(h_snapshot, &te)) {
    do {
      if (te.th32OwnerProcessID == process_id) {
        thread_id = te.th32ThreadID;
        break;
      }
    } while (Thread32Next(h_snapshot, &te));
  }
  CloseHandle(h_snapshot);

  if (thread_id == 0) {
    log_msg("failed to find a thread for the target process");
    FreeLibrary(h_module);
    return FALSE;
  }
  log_msg("found thread id: " + std::to_string(thread_id));

  // set the windows hook
  log_msg("setting windows hook");
  HHOOK hook = SetWindowsHookEx(WH_GETMESSAGE, hook_proc, h_module, thread_id);
  if (!hook) {
    log_msg("failed to set windows hook");
    FreeLibrary(h_module);
    return FALSE;
  }
  log_msg("windows hook set successfully");

  // post a message to the thread to trigger the hook
  log_msg("posting message to trigger hook");
  if (!PostThreadMessage(thread_id, WM_NULL, 0, 0)) {
    log_msg("failed to post thread message");
    // continue anyway, as the hook might still work
  }

  // wait a bit to ensure the hook has been triggered
  Sleep(1000);

  // unhook and clean up
  log_msg("unhooking and cleaning up");
  UnhookWindowsHookEx(hook);
  FreeLibrary(h_module);

  log_msg("setwindowshookex injection completed successfully");
  return TRUE;
}

// clean wrapper for the public api
bool w1::inject::windows::inject_dll_set_windows_hook_ex(
    process_handle h_process, process_id pid, const std::wstring& dll_path
) {
  HANDLE win_handle = static_cast<HANDLE>(h_process);
  DWORD win_pid = static_cast<DWORD>(pid);
  BOOL result = inject_dll_set_windows_hook_ex_impl(win_handle, win_pid, dll_path);
  return result != FALSE;
}

```

`src/w1nj3ct/platform/windows/impl/util.hpp`:

```hpp
#pragma once

#include <iostream>
#include <string>

// log helpers
static inline void log_msg(const std::string& msg) { std::cout << msg << std::endl; }
static inline void log_path(const std::string& msg, const std::string& path) { log_msg(msg + " [" + path + "]"); }

```

`src/w1nj3ct/platform/windows/impl/winapis.h`:

```h
#pragma once

// This file needs raw Windows headers for API definitions
// It should only be included by inject.hpp which isolates the pollution
#ifndef NOMINMAX
#define NOMINMAX
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

// define NTSTATUS if not already defined
#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif

/**
 * some windows api function pointers for "less documented" functions
 */

struct NtCreateThreadExBuffer {
  ULONG Size;
  ULONG Unknown1;
  ULONG Unknown2;
  PULONG Unknown3;
  ULONG Unknown4;
  ULONG Unknown5;
  ULONG Unknown6;
  PULONG Unknown7;
  ULONG Unknown8;
};

typedef NTSTATUS(WINAPI* LPFUN_NtCreateThreadEx)(
    PHANDLE hThread, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle,
    LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, ULONG StackZeroBits,
    ULONG SizeOfStackCommit, ULONG SizeOfStackReserve, LPVOID lpBytesBuffer
);
// function Pointer Typedef for RtlCreateUserThread
typedef DWORD(WINAPI* pRtlCreateUserThread)(
    HANDLE ProcessHandle, PSECURITY_DESCRIPTOR SecurityDescriptor, BOOL CreateSuspended, ULONG StackZeroBits,
    PULONG StackReserved, PULONG StackCommit, LPVOID StartAddress, LPVOID StartParameter, HANDLE ThreadHandle,
    LPVOID ClientID
);

```

`src/w1nj3ct/platform/windows/windows_injector.cpp`:

```cpp
#include "windows_injector.hpp"
#include "error.hpp"

// include windows injection backend
#include "impl/auxiliary.hpp"
#include "impl/inject.hpp"

#include <string>

#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <psapi.h>
#include <tlhelp32.h>

namespace w1::inject::windows {

// helper to convert string to wstring
std::wstring string_to_wstring(const std::string& str) {
  if (str.empty()) {
    return std::wstring();
  }
  int size = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, nullptr, 0);
  std::wstring result(size - 1, 0);
  MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, &result[0], size);
  return result;
}

// helper to convert wstring to string
std::string wstring_to_string(const std::wstring& wstr) {
  if (wstr.empty()) {
    return std::string();
  }
  int size = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, nullptr, 0, nullptr, nullptr);
  std::string result(size - 1, 0);
  WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, &result[0], size, nullptr, nullptr);
  return result;
}

result inject_runtime(const config& cfg) {
  // validate we have a target
  if (!cfg.pid && !cfg.process_name) {
    return make_error_result(error_code::configuration_invalid, "no target specified");
  }

  DWORD target_pid = 0;

  // resolve process name to pid if needed
  if (cfg.process_name) {
    auto processes = find_processes_by_name(*cfg.process_name);
    if (processes.empty()) {
      return make_error_result(error_code::target_not_found, *cfg.process_name);
    }
    if (processes.size() > 1) {
      return make_error_result(error_code::multiple_targets_found, *cfg.process_name);
    }
    target_pid = processes[0].pid;
  } else {
    target_pid = *cfg.pid;
  }

  // open process handle
  HANDLE h_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, target_pid);
  if (h_process == NULL) {
    DWORD err = GetLastError();
    return make_error_result(translate_platform_error(static_cast<int>(err)), "failed to open process", err);
  }

  // convert library path to wide string
  std::wstring dll_path = string_to_wstring(cfg.library_path);

  // choose injection technique and inject
  bool success = false;
  switch (cfg.windows_technique) {
  case windows_technique::create_remote_thread:
    success = w1::inject::windows::inject_dll_create_remote_thread(h_process, dll_path);
    break;
  case windows_technique::set_windows_hook:
    success = w1::inject::windows::inject_dll_set_windows_hook_ex(h_process, target_pid, dll_path);
    break;
  case windows_technique::rtl_create_user_thread:
    success = w1::inject::windows::inject_dll_rtl_create_user_thread(h_process, dll_path);
    break;
  case windows_technique::reflective_loader:
    success = w1::inject::windows::inject_dll_reflective_loader(h_process, dll_path);
    break;
  default:
    CloseHandle(h_process);
    return make_error_result(error_code::technique_not_supported, "unknown windows technique");
  }

  CloseHandle(h_process);

  if (!success) {
    DWORD err = GetLastError();
    return make_error_result(translate_platform_error(static_cast<int>(err)), "injection failed", err);
  }

  return make_success_result(target_pid);
}

result inject_preload(const config& cfg) {
  // windows launch injection using suspended process approach

  // validate we have a binary path for launch injection
  if (!cfg.binary_path) {
    return make_error_result(error_code::configuration_invalid, "binary_path required for launch injection");
  }

  // convert paths to wide strings
  std::wstring binary_path = string_to_wstring(*cfg.binary_path);
  std::wstring dll_path = string_to_wstring(cfg.library_path);

  // perform launch injection
  w1::inject::windows::process_id target_pid = 0;
  int exit_code = 0;
  bool success = w1::inject::windows::inject_dll_launch_suspended(
      binary_path, dll_path, cfg.args, cfg.env_vars, &target_pid, cfg.suspended, cfg.wait_for_completion,
      cfg.disable_aslr, &exit_code
  );

  if (!success) {
    DWORD err = GetLastError();
    return make_error_result(translate_platform_error(static_cast<int>(err)), "launch injection failed", err);
  }

  auto result = make_success_result(target_pid);
  if (cfg.wait_for_completion) {
    result.target_exit_code = exit_code;
  }
  return result;
}

std::vector<process_info> list_processes() {
  std::vector<process_info> processes;

  HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (snapshot == INVALID_HANDLE_VALUE) {
    return processes;
  }

  PROCESSENTRY32W pe32;
  pe32.dwSize = sizeof(PROCESSENTRY32W);

  if (Process32FirstW(snapshot, &pe32)) {
    do {
      process_info info;
      info.pid = pe32.th32ProcessID;
      info.name = wstring_to_string(pe32.szExeFile);

      // get full path
      HANDLE h_process = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, pe32.th32ProcessID);
      if (h_process != NULL) {
        wchar_t path[MAX_PATH];
        DWORD path_len = MAX_PATH;
        if (QueryFullProcessImageNameW(h_process, 0, path, &path_len)) {
          info.full_path = wstring_to_string(path);
        }
        CloseHandle(h_process);
      }

      processes.push_back(info);
    } while (Process32NextW(snapshot, &pe32));
  }

  CloseHandle(snapshot);
  return processes;
}

std::vector<process_info> find_processes_by_name(const std::string& name) {
  std::vector<process_info> matches;
  auto all_processes = list_processes();

  for (const auto& proc : all_processes) {
    if (proc.name == name) {
      matches.push_back(proc);
    }
  }

  return matches;
}

std::optional<process_info> get_process_info(int pid) {
  auto all_processes = list_processes();

  for (const auto& proc : all_processes) {
    if (proc.pid == pid) {
      return proc;
    }
  }

  return std::nullopt;
}

bool check_injection_capabilities() {
  // check if we can open a process with required permissions
  HANDLE h_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());
  if (h_process != NULL) {
    CloseHandle(h_process);
    return true;
  }

  return false;
}

} // namespace w1::inject::windows
```

`src/w1nj3ct/platform/windows/windows_injector.hpp`:

```hpp
#pragma once

#include "w1nj3ct.hpp"

namespace w1::inject::windows {
// wrapper around the existing win_inject backend
result inject_runtime(const config& cfg);
result inject_preload(const config& cfg); // not supported, returns error

// process discovery using existing backend
std::vector<process_info> list_processes();
std::vector<process_info> find_processes_by_name(const std::string& name);
std::optional<process_info> get_process_info(int pid);

// capabilities check
bool check_injection_capabilities();
} // namespace w1::inject::windows
```

`src/w1nj3ct/w1nj3ct.cpp`:

```cpp
#include "w1nj3ct.hpp"
#include "error.hpp"
#include <redlog.hpp>

// platform-specific includes
#ifdef __APPLE__
#include "platform/darwin/darwin_injector.hpp"
#elif defined(__linux__)
#include "platform/linux/linux_injector.hpp"
#elif defined(_WIN32)
#include "platform/windows/windows_injector.hpp"
#endif

#include <filesystem>

namespace w1::inject {

// validate configuration before injection
error_code validate_config(const config& cfg) {
  auto log = redlog::get_logger("w1nj3ct.validation");

  log.debug("validating injection configuration");

  // check exactly one target specified
  int target_count = 0;
  if (cfg.pid) {
    target_count++;
  }
  if (cfg.process_name) {
    target_count++;
  }
  if (cfg.binary_path) {
    target_count++;
  }

  log.trace(
      "target specification check", redlog::field("targets", target_count),
      redlog::field("has_pid", static_cast<bool>(cfg.pid)),
      redlog::field("has_process_name", static_cast<bool>(cfg.process_name)),
      redlog::field("has_binary_path", static_cast<bool>(cfg.binary_path))
  );

  if (target_count != 1) {
    log.error("invalid target specification - exactly one target required", redlog::field("targets", target_count));
    return error_code::configuration_invalid;
  }

  // validate library path exists and is accessible
  log.debug("validating library path", redlog::field("library_path", cfg.library_path));

  if (!std::filesystem::exists(cfg.library_path)) {
    log.error("injection library not found", redlog::field("library_path", cfg.library_path));
    return error_code::library_not_found;
  }

  // check library permissions
  std::error_code fs_error;
  auto file_status = std::filesystem::status(cfg.library_path, fs_error);
  if (fs_error) {
    log.error(
        "failed to get library file status", redlog::field("library_path", cfg.library_path),
        redlog::field("error", fs_error.message())
    );
    return error_code::library_not_found;
  }

  if (!std::filesystem::is_regular_file(file_status)) {
    log.error("library path is not a regular file", redlog::field("library_path", cfg.library_path));
    return error_code::library_not_found;
  }

  log.verbose(
      "library validation passed", redlog::field("library_path", cfg.library_path),
      redlog::field("bytes", std::filesystem::file_size(cfg.library_path, fs_error))
  );

  // check method compatibility with target type
  const char* method_str = (cfg.injection_method == method::runtime) ? "runtime" : "preload";
  log.debug("validating method compatibility", redlog::field("method", method_str));

  if (cfg.injection_method == method::preload && !cfg.binary_path) {
    log.error("launch injection method requires binary_path", redlog::field("method", method_str));
    return error_code::configuration_invalid;
  }

  if (cfg.injection_method == method::runtime && cfg.binary_path) {
    log.error("runtime injection method incompatible with binary_path", redlog::field("method", method_str));
    return error_code::configuration_invalid;
  }

  if (cfg.injection_method == method::runtime && cfg.wait_for_completion) {
    log.error("wait_for_completion only supported with launch injection method", redlog::field("method", method_str));
    return error_code::configuration_invalid;
  }

  // platform-specific validation
  const char* platform_str =
#ifdef __APPLE__
      "darwin";
#elif defined(__linux__)
      "linux";
#elif defined(_WIN32)
      "windows";
#else
      "unknown";
#endif

  log.debug(
      "performing platform-specific validation", redlog::field("platform", platform_str),
      redlog::field("method", method_str)
  );

  log.debug("configuration validation completed successfully");
  return error_code::success;
}

result inject(const config& cfg) {
  auto log = redlog::get_logger("w1nj3ct");

  const char* method_str = (cfg.injection_method == method::runtime) ? "runtime" : "preload";
  const char* platform_str =
#ifdef __APPLE__
      "darwin";
#elif defined(__linux__)
      "linux";
#elif defined(_WIN32)
      "windows";
#else
      "unknown";
#endif

  log.info(
      "injection request received", redlog::field("method", method_str), redlog::field("platform", platform_str),
      redlog::field("library_path", cfg.library_path)
  );

  // log target information
  if (cfg.pid) {
    log.debug("target specified by pid", redlog::field("pid", *cfg.pid));
  } else if (cfg.process_name) {
    log.debug("target specified by process name", redlog::field("name", *cfg.process_name));
  } else if (cfg.binary_path) {
    log.debug("target specified by binary path", redlog::field("path", *cfg.binary_path));
  }

  // log environment configuration if present
  if (!cfg.env_vars.empty()) {
    log.verbose("environment variables configured", redlog::field("vars", cfg.env_vars.size()));
    for (const auto& [key, value] : cfg.env_vars) {
      log.trace("environment variable", redlog::field("key", key), redlog::field("value", value));
    }
  }

  // 1. validate configuration
  log.debug("validating injection configuration");
  error_code validation_result = validate_config(cfg);
  if (validation_result != error_code::success) {
    std::string error_detail = error_code_to_string(validation_result);
    log.error(
        "configuration validation failed", redlog::field("error_code", static_cast<int>(validation_result)),
        redlog::field("detail", error_detail), redlog::field("method", method_str),
        redlog::field("library_path", cfg.library_path)
    );
    return make_error_result(validation_result, "configuration validation failed: " + error_detail);
  }

  log.debug("configuration validated successfully");

  // 2. check platform capabilities (only for runtime injection)
  if (cfg.injection_method == method::runtime) {
    log.debug("checking injection capabilities for platform", redlog::field("platform", platform_str));

    bool capabilities_ok = check_injection_capabilities();
    if (!capabilities_ok) {
      log.warn(
          "injection capabilities limited on this platform", redlog::field("platform", platform_str),
          redlog::field("method", method_str)
      );
    }
  }

  // 3. platform detection and dispatch
  log.debug(
      "dispatching to platform-specific injection implementation", redlog::field("platform", platform_str),
      redlog::field("method", method_str)
  );

  result injection_result;

#ifdef __APPLE__
  if (cfg.injection_method == method::runtime) {
    injection_result = darwin::inject_runtime(cfg);
  } else {
    injection_result = darwin::inject_preload(cfg);
  }
#elif defined(__linux__)
  if (cfg.injection_method == method::runtime) {
    injection_result = linux_impl::inject_runtime(cfg);
  } else {
    injection_result = linux_impl::inject_preload(cfg);
  }
#elif defined(_WIN32)
  if (cfg.injection_method == method::runtime) {
    injection_result = windows::inject_runtime(cfg);
  } else {
    injection_result = windows::inject_preload(cfg);
  }
#else
  log.error("platform not supported for injection", redlog::field("platform", platform_str));
  injection_result = make_error_result(
      error_code::platform_not_supported, "injection not supported on platform: " + std::string(platform_str)
  );
#endif

  // 4. log final result
  if (injection_result.success()) {
    log.info(
        "injection completed successfully", redlog::field("method", method_str),
        redlog::field("platform", platform_str), redlog::field("pid", injection_result.target_pid),
        redlog::field("library_path", cfg.library_path)
    );
  } else {
    log.error(
        "injection failed", redlog::field("method", method_str), redlog::field("platform", platform_str),
        redlog::field("error_code", static_cast<int>(injection_result.code)),
        redlog::field("error_msg", injection_result.error_message),
        redlog::field("system_error", injection_result.system_error_code),
        redlog::field("library_path", cfg.library_path)
    );
  }

  return injection_result;
}

std::vector<process_info> list_processes() {
#ifdef __APPLE__
  return darwin::list_processes();
#elif defined(__linux__)
  return linux_impl::list_processes();
#elif defined(_WIN32)
  return windows::list_processes();
#else
  return {};
#endif
}

std::vector<process_info> find_processes(const std::string& name) {
#ifdef __APPLE__
  return darwin::find_processes_by_name(name);
#elif defined(__linux__)
  return linux_impl::find_processes_by_name(name);
#elif defined(_WIN32)
  return windows::find_processes_by_name(name);
#else
  return {};
#endif
}

std::optional<process_info> get_process_info(int pid) {
#ifdef __APPLE__
  return darwin::get_process_info(pid);
#elif defined(__linux__)
  return linux_impl::get_process_info(pid);
#elif defined(_WIN32)
  return windows::get_process_info(pid);
#else
  return std::nullopt;
#endif
}

bool check_injection_capabilities() {
#ifdef __APPLE__
  return darwin::check_injection_capabilities();
#elif defined(__linux__)
  return linux_impl::check_injection_capabilities();
#elif defined(_WIN32)
  return windows::check_injection_capabilities();
#else
  return false;
#endif
}

std::vector<std::string> get_supported_platforms() {
  std::vector<std::string> platforms;
#ifdef __APPLE__
  platforms.push_back("macOS");
#endif
#ifdef __linux__
  platforms.push_back("Linux");
#endif
#ifdef _WIN32
  platforms.push_back("Windows");
#endif
  return platforms;
}

bool is_library_compatible(const std::string& library_path, [[maybe_unused]] int pid) {
  // basic check - library exists
  if (!std::filesystem::exists(library_path)) {
    return false;
  }

  // TODO: implement architecture compatibility checking
  // for now, assume compatible
  return true;
}

} // namespace w1::inject

```

`src/w1nj3ct/w1nj3ct.hpp`:

```hpp
#pragma once

#include <chrono>
#include <map>
#include <optional>
#include <string>
#include <vector>

namespace w1::inject {
// injection methods
enum class method {
  runtime, // inject into running process
  preload  // launch new process with library preloaded
};

// platform-specific technique enums
#ifdef _WIN32
enum class windows_technique {
  create_remote_thread,
  set_windows_hook,
  rtl_create_user_thread,
  reflective_loader,
  launch_suspended
};
#endif

// comprehensive cross-platform error codes
enum class error_code {
  success,

  // target errors
  target_not_found,
  multiple_targets_found,
  target_access_denied,
  target_invalid_architecture,

  // library errors
  library_not_found,
  library_invalid,
  library_incompatible,

  // injection errors
  injection_failed,
  injection_timeout,
  injection_already_loaded,

  // platform errors
  platform_not_supported,
  technique_not_supported,
  insufficient_privileges,

  // system errors
  out_of_memory,
  system_error,
  configuration_invalid,

  // launch errors
  launch_failed,
  launch_timeout,

  unknown_error
};

// process info for discovery
struct process_info {
  int pid;
  std::string name;
  std::string full_path;
  std::string command_line;

  bool operator==(const process_info& other) const { return pid == other.pid; }
};

// configuration
struct config {
  // REQUIRED
  std::string library_path;
  method injection_method; // user must explicitly choose

  // TARGET (exactly one required)
  std::optional<int> pid;
  std::optional<std::string> process_name;
  std::optional<std::string> binary_path;

  // BEHAVIOR
  std::chrono::milliseconds timeout{5000};
  bool suspended = false;           // start process in suspended state (launch method only)
  bool wait_for_completion = false; // wait for process completion (launch method only)
  bool disable_aslr = false;        // disable ASLR when launching process (launch method only)

  // LAUNCH OPTIONS (when using binary_path)
  std::vector<std::string> args;
  std::map<std::string, std::string> env_vars;

  // PLATFORM-SPECIFIC
#ifdef _WIN32
  windows_technique windows_technique = windows_technique::create_remote_thread;
  bool windows_elevate = false;
#endif

#ifdef __linux__
  std::string linux_namespace;
#endif

  // DEBUGGING
  bool verbose = false;
};

// result
struct result {
  error_code code;
  int target_pid = -1;
  std::string error_message;
  std::optional<int> system_error_code;
  std::optional<int> target_exit_code; // exit code of target process (only set when wait_for_completion=true)

  // convenience
  bool success() const { return code == error_code::success; }
  operator bool() const { return success(); }
};

// MAIN INJECTION FUNCTION
result inject(const config& cfg);

// CONVENIENCE FUNCTIONS
inline result inject_library_runtime(const std::string& library_path, int pid);
inline result inject_library_runtime(const std::string& library_path, const std::string& process_name);
inline result inject_library_launch(
    const std::string& binary_path, const std::string& library_path, const std::vector<std::string>& args = {}
);

// PROCESS DISCOVERY
std::vector<process_info> list_processes();
std::vector<process_info> find_processes(const std::string& name);
std::optional<process_info> get_process_info(int pid);

// UTILITIES
bool check_injection_capabilities();
std::vector<std::string> get_supported_platforms();
bool is_library_compatible(const std::string& library_path, int pid);
std::string error_code_to_string(error_code code);
bool is_recoverable_error(error_code code);

// CONVENIENCE FUNCTION IMPLEMENTATIONS
inline result inject_library_runtime(const std::string& library_path, int pid) {
  config cfg;
  cfg.library_path = library_path;
  cfg.injection_method = method::runtime;
  cfg.pid = pid;
  return inject(cfg);
}

inline result inject_library_runtime(const std::string& library_path, const std::string& process_name) {
  config cfg;
  cfg.library_path = library_path;
  cfg.injection_method = method::runtime;
  cfg.process_name = process_name;
  return inject(cfg);
}

inline result inject_library_launch(
    const std::string& binary_path, const std::string& library_path, const std::vector<std::string>& args
) {
  config cfg;
  cfg.library_path = library_path;
  cfg.injection_method = method::preload;
  cfg.binary_path = binary_path;
  cfg.args = args;
  return inject(cfg);
}
} // namespace w1::inject
```

`src/w1replay/CMakeLists.txt`:

```txt
w1_dep_lief()
w1_dep_gdbstub()

find_package(Threads REQUIRED)

w1_add_executable(w1replay
    cli/main.cpp
    cli/commands/checkpoint.cpp
    cli/commands/inspect.cpp
    cli/commands/server.cpp
    cli/commands/summary.cpp
    cli/commands/threads.cpp
    modules/asmr_block_decoder.cpp
    modules/address_index.cpp
    modules/module_image.cpp
    modules/module_image_lief.cpp
    modules/lief_module_provider.cpp
    modules/path_resolver.cpp
    trace_loader/trace_loader.cpp
    gdb/adapter.cpp
    gdb/loaded_libraries_provider.cpp
    gdb/triple_utils.cpp
    gdb/components/regs_component.cpp
    gdb/components/mem_component.cpp
    gdb/components/run_component.cpp
    gdb/components/breakpoints_component.cpp
    gdb/components/threads_component.cpp
    gdb/components/host_info_component.cpp
    gdb/components/memory_layout_component.cpp
    gdb/components/libraries_component.cpp
    gdb/components/loaded_libraries_component.cpp
    gdb/components/process_info_component.cpp
    gdb/components/auxv_component.cpp
    gdb/components/offsets_component.cpp
    gdb/components/register_info_component.cpp
    gdb/lldb/darwin_loaded_libraries.cpp
    gdb/layout.cpp
    gdb/target_xml.cpp
    gdb/memory_map.cpp
    memory/memory_view.cpp
    gdb/value_codec.cpp
    gdb/stepper.cpp
)

target_link_libraries(w1replay PRIVATE
    w1base
    w1rewind_replay
    gdbstub::gdbstub
    Threads::Threads
    w1::lief
)

if(TARGET w1asmr)
    target_link_libraries(w1replay PRIVATE w1asmr)
endif()

install(TARGETS w1replay RUNTIME DESTINATION bin COMPONENT ${W1_INSTALL_COMPONENT})

```

`src/w1replay/cli/commands/checkpoint.cpp`:

```cpp
#include "checkpoint.hpp"

#include <iostream>

#include <redlog.hpp>

#include "w1rewind/trace/replay_checkpoint.hpp"

namespace w1replay::commands {

int checkpoint(const checkpoint_options& options) {
  auto log = redlog::get_logger("w1replay.checkpoint");

  if (options.trace_path.empty()) {
    log.err("trace path required");
    std::cerr << "error: --trace is required" << std::endl;
    return 1;
  }
  if (options.stride == 0) {
    log.err("checkpoint stride must be non-zero");
    std::cerr << "error: --stride must be > 0" << std::endl;
    return 1;
  }

  w1::rewind::replay_checkpoint_config config{};
  config.trace_path = options.trace_path;
  config.output_path = options.output_path;
  config.stride = options.stride;
  config.include_memory = options.include_memory;
  config.thread_id = options.thread_id;

  w1::rewind::replay_checkpoint_index index;
  std::string error;
  if (!w1::rewind::build_replay_checkpoint(config, &index, error)) {
    log.err("failed to build checkpoint", redlog::field("error", error));
    std::cerr << "error: " << (error.empty() ? "failed to build checkpoint" : error) << std::endl;
    return 1;
  }

  std::string output = options.output_path.empty() ? w1::rewind::default_replay_checkpoint_path(options.trace_path)
                                                   : options.output_path;

  log.inf("checkpoint written", redlog::field("path", output));
  std::cout << "wrote checkpoint: " << output << std::endl;
  return 0;
}

} // namespace w1replay::commands

```

`src/w1replay/cli/commands/checkpoint.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>

namespace w1replay::commands {

struct checkpoint_options {
  std::string trace_path;
  std::string output_path;
  uint32_t stride = 50000;
  bool include_memory = false;
  uint64_t thread_id = 0;
};

int checkpoint(const checkpoint_options& options);

} // namespace w1replay::commands

```

`src/w1replay/cli/commands/inspect.cpp`:

```cpp
#include "inspect.hpp"

#include <cstddef>
#include <filesystem>
#include <iomanip>
#include <iostream>
#include <memory>
#include <optional>
#include <span>
#include <sstream>

#include <redlog.hpp>

#include "w1replay/memory/memory_view.hpp"
#include "w1replay/modules/address_index.hpp"
#include "w1replay/modules/asmr_block_decoder.hpp"
#include "w1replay/modules/lief_module_provider.hpp"
#include "w1replay/modules/path_resolver.hpp"
#include "w1replay/trace_loader/trace_loader.hpp"
#include "w1rewind/replay/replay_session.hpp"

namespace w1replay::commands {

namespace {

std::string format_address(uint64_t address) {
  std::ostringstream out;
  out << "0x" << std::hex << address;
  return out.str();
}

std::string format_byte(std::byte value, bool known) {
  if (!known) {
    return "??";
  }
  std::ostringstream out;
  out << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(std::to_integer<uint8_t>(value));
  return out.str();
}

std::string format_bytes(std::span<const std::byte> bytes) {
  std::ostringstream out;
  for (size_t i = 0; i < bytes.size(); ++i) {
    if (i > 0) {
      out << " ";
    }
    out << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(std::to_integer<uint8_t>(bytes[i]));
  }
  return out.str();
}

const w1::rewind::module_record* find_module_for_address(
    const std::vector<w1::rewind::module_record>& modules, uint64_t address, uint64_t size, uint64_t& module_offset
) {
  if (size == 0) {
    return nullptr;
  }

  for (const auto& module : modules) {
    if (address < module.base) {
      continue;
    }
    uint64_t offset = address - module.base;
    if (module.size < size) {
      continue;
    }
    if (offset > module.size - size) {
      continue;
    }
    module_offset = offset;
    return &module;
  }
  return nullptr;
}

struct memory_query {
  uint64_t address = 0;
  size_t size = 0;
};

std::optional<memory_query> parse_memory_query(const std::string& input, std::string& error) {
  if (input.empty()) {
    return std::nullopt;
  }
  auto sep = input.find(':');
  if (sep == std::string::npos) {
    error = "invalid --mem format (expected addr:size)";
    return std::nullopt;
  }
  auto addr_text = input.substr(0, sep);
  auto size_text = input.substr(sep + 1);
  if (addr_text.empty() || size_text.empty()) {
    error = "invalid --mem format (expected addr:size)";
    return std::nullopt;
  }
  try {
    uint64_t address = std::stoull(addr_text, nullptr, 0);
    uint64_t size = std::stoull(size_text, nullptr, 0);
    if (size == 0) {
      error = "--mem size must be > 0";
      return std::nullopt;
    }
    return memory_query{address, static_cast<size_t>(size)};
  } catch (const std::exception&) {
    error = "invalid --mem format (expected addr:size)";
    return std::nullopt;
  }
}

} // namespace

int inspect(const inspect_options& options) {
  auto log = redlog::get_logger("w1replay.inspect");

  if (options.trace_path.empty()) {
    log.err("trace path required");
    std::cerr << "error: --trace is required" << std::endl;
    return 1;
  }
  if (options.thread_id == 0) {
    log.err("thread id required");
    std::cerr << "error: --thread is required" << std::endl;
    return 1;
  }

  std::string mem_error;
  auto mem_query = parse_memory_query(options.memory_range, mem_error);
  if (!mem_error.empty()) {
    log.err("invalid memory range", redlog::field("error", mem_error));
    std::cerr << "error: " << mem_error << std::endl;
    return 1;
  }

  w1replay::trace_loader::trace_load_options load_options{};
  load_options.trace_path = options.trace_path;
  load_options.index_path = options.index_path;
  load_options.checkpoint_path = options.checkpoint_path;
  load_options.auto_build_checkpoint = false;

  w1replay::trace_loader::trace_load_result load_result;
  if (!w1replay::trace_loader::load_trace(load_options, load_result)) {
    log.err("failed to load trace", redlog::field("error", load_result.error));
    std::cerr << "error: " << load_result.error << std::endl;
    return 1;
  }

  auto resolver = make_module_path_resolver(options.module_mappings, options.module_dirs);
  w1replay::module_address_index module_index(load_result.context);
  w1replay::lief_module_provider_config provider_config{};
  provider_config.resolver = resolver.get();
  provider_config.address_index = &module_index;
  w1replay::lief_module_provider provider(provider_config);

  w1::rewind::replay_session_config config{};
  config.stream = load_result.stream;
  config.index = load_result.index;
  config.checkpoint = load_result.checkpoint;
  config.context = load_result.context;
  config.history_size = options.history_size;
  config.track_registers = options.show_registers;
  config.track_memory = mem_query.has_value();
  config.thread_id = options.thread_id;
  config.start_sequence = options.start_sequence;

  std::optional<asmr_block_decoder> decoder;
  if (options.instruction_steps) {
    if (asmr_decoder_available()) {
      decoder.emplace();
      config.block_decoder = &*decoder;
    }
  }

  w1::rewind::replay_session session(config);
  if (!session.open()) {
    log.err("failed to open trace", redlog::field("error", session.error()));
    std::cerr << "error: " << session.error() << std::endl;
    return 1;
  }

  w1replay::replay_memory_view memory_view(&session.context(), session.state(), &provider);
  if (decoder.has_value()) {
    decoder->set_memory_view(&memory_view);
  }

  auto print_step = [&](const w1::rewind::flow_step& step) {
    uint64_t module_offset = 0;
    std::string module_label = "?";
    if (auto* module = find_module_for_address(session.modules(), step.address, step.size, module_offset)) {
      std::string module_path = module->path;
      if (resolver) {
        if (auto resolved = resolver->resolve_module_path(*module)) {
          module_path = *resolved;
        }
      }
      if (!module_path.empty()) {
        module_label = std::filesystem::path(module_path).filename().string();
      } else {
        module_label = format_address(module->base);
      }
      if (module_offset != 0) {
        std::ostringstream with_offset;
        with_offset << module_label << "+0x" << std::hex << module_offset;
        module_label = with_offset.str();
      }
    }

    std::cout << "seq=" << step.sequence << " addr=" << format_address(step.address) << " module=" << module_label
              << " kind=" << (step.is_block ? "block" : "instruction") << std::endl;

    if (options.show_registers) {
      const auto& names = session.register_names();
      const auto& specs = session.register_specs();
      auto regs = session.read_registers();
      if (names.empty()) {
        std::cout << "  regs: unknown" << std::endl;
      } else {
        bool wrote_any = false;
        std::ostringstream out;
        out << "  regs:";
        for (size_t i = 0; i < names.size() && i < specs.size(); ++i) {
          const auto& spec = specs[i];
          if (spec.value_kind == w1::rewind::register_value_kind::bytes) {
            size_t size = (spec.bits + 7u) / 8u;
            std::vector<std::byte> buffer(size);
            bool known = false;
            if (!session.read_register_bytes(static_cast<uint16_t>(i), buffer, known) || !known) {
              continue;
            }
            out << " " << names[i] << "=" << format_bytes(buffer);
            wrote_any = true;
            continue;
          }

          if (i >= regs.size() || !regs[i].has_value()) {
            continue;
          }
          out << " " << names[i] << "=" << format_address(*regs[i]);
          wrote_any = true;
        }
        if (!wrote_any) {
          out << " unknown";
        }
        std::cout << out.str() << std::endl;
      }
    }

    if (mem_query.has_value()) {
      auto bytes = memory_view.read(mem_query->address, mem_query->size);
      std::ostringstream out;
      out << "  mem[" << format_address(mem_query->address) << ":" << mem_query->size << "]:";
      for (size_t i = 0; i < bytes.bytes.size(); ++i) {
        bool known = i < bytes.known.size() && bytes.known[i] != 0;
        out << " " << format_byte(bytes.bytes[i], known);
      }
      std::cout << out.str() << std::endl;
    }
  };

  if (options.count == 0) {
    return 0;
  }

  w1::rewind::flow_step step{};
  auto emit_notice = [&]() {
    auto notice = session.take_notice();
    if (!notice.has_value()) {
      return;
    }
    log.warn("replay notice", redlog::field("message", notice->message));
    std::cerr << "warning: " << notice->message << std::endl;
  };

  if (options.reverse) {
    if (options.instruction_steps) {
      if (!session.step_flow()) {
        log.err("failed to read step", redlog::field("error", session.error()));
        std::cerr << "error: " << session.error() << std::endl;
        return 1;
      }
      step = session.current_step();
      if (!step.is_block) {
        print_step(step);
        emit_notice();
        for (uint32_t i = 1; i < options.count; ++i) {
          if (!session.step_instruction_backward()) {
            log.err("failed to step backward", redlog::field("error", session.error()));
            std::cerr << "error: " << session.error() << std::endl;
            return 1;
          }
          step = session.current_step();
          print_step(step);
          emit_notice();
        }
        return 0;
      }

      if (!session.step_instruction_backward()) {
        log.err("failed to step backward", redlog::field("error", session.error()));
        std::cerr << "error: " << session.error() << std::endl;
        return 1;
      }
      step = session.current_step();
      print_step(step);
      emit_notice();
      for (uint32_t i = 1; i < options.count; ++i) {
        if (!session.step_instruction_backward()) {
          log.err("failed to step backward", redlog::field("error", session.error()));
          std::cerr << "error: " << session.error() << std::endl;
          return 1;
        }
        step = session.current_step();
        print_step(step);
        emit_notice();
      }
      return 0;
    }

    if (!session.step_flow()) {
      log.err("failed to read step", redlog::field("error", session.error()));
      std::cerr << "error: " << session.error() << std::endl;
      return 1;
    }
    step = session.current_step();
    print_step(step);
    emit_notice();
    for (uint32_t i = 1; i < options.count; ++i) {
      if (!session.step_backward()) {
        log.err("failed to step backward", redlog::field("error", session.error()));
        std::cerr << "error: " << session.error() << std::endl;
        return 1;
      }
      step = session.current_step();
      print_step(step);
      emit_notice();
    }
    return 0;
  }

  for (uint32_t i = 0; i < options.count; ++i) {
    bool ok = options.instruction_steps ? session.step_instruction() : session.step_flow();
    if (!ok) {
      log.err("failed to read step", redlog::field("error", session.error()));
      std::cerr << "error: " << session.error() << std::endl;
      return 1;
    }
    step = session.current_step();
    print_step(step);
    emit_notice();
  }

  return 0;
}

} // namespace w1replay::commands

```

`src/w1replay/cli/commands/inspect.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>
#include <vector>

namespace w1replay::commands {

struct inspect_options {
  std::string trace_path;
  std::string index_path;
  uint64_t thread_id = 0;
  uint64_t start_sequence = 0;
  uint32_t count = 10;
  uint32_t history_size = 1024;
  bool reverse = false;
  bool instruction_steps = false;
  bool show_registers = false;
  std::string memory_range;
  std::string checkpoint_path;
  std::vector<std::string> module_mappings;
  std::vector<std::string> module_dirs;
};

int inspect(const inspect_options& options);

} // namespace w1replay::commands

```

`src/w1replay/cli/commands/server.cpp`:

```cpp
#include "server.hpp"

#include <iostream>
#include <memory>

#include <redlog.hpp>

#include "gdbstub/server/server.hpp"
#include "gdbstub/transport/transport_tcp.hpp"

#include "w1replay/gdb/adapter.hpp"

namespace w1replay::commands {

namespace {

constexpr const char* k_default_gdb_listen = "127.0.0.1:51234";

} // namespace

int server(const server_options& options) {
  auto log = redlog::get_logger("w1replay.server");

  if (options.trace_path.empty()) {
    log.err("trace path required");
    std::cerr << "error: --trace is required" << std::endl;
    return 1;
  }

  std::string listen_addr = options.gdb_listen.empty() ? k_default_gdb_listen : options.gdb_listen;

  gdb::adapter::config config;
  config.trace_path = options.trace_path;
  config.index_path = options.index_path;
  config.checkpoint_path = options.checkpoint_path;
  config.thread_id = options.thread_id;
  config.start_sequence = options.start_sequence;
  config.prefer_instruction_steps = options.instruction_steps;
  config.module_mappings = options.module_mappings;
  config.module_dirs = options.module_dirs;

  gdb::adapter adapter(std::move(config));
  if (!adapter.open()) {
    log.err("failed to open trace", redlog::field("error", adapter.error()));
    std::cerr << "error: " << adapter.error() << std::endl;
    return 1;
  }
  if (!adapter.track_memory()) {
    log.warn("trace has no memory tracking; memory reads (including stack) may fail");
  } else if (!adapter.has_stack_snapshot()) {
    log.warn("trace has no stack snapshot; finish may fail without recorded stack bytes");
  }

  auto transport = std::make_unique<gdbstub::transport_tcp>();
  gdbstub::server server(adapter.make_target(), adapter.arch_spec(), std::move(transport));
  if (!server.listen(listen_addr)) {
    log.err("failed to listen", redlog::field("address", listen_addr));
    std::cerr << "error: failed to listen on " << listen_addr << std::endl;
    return 1;
  }

  log.info("listening", redlog::field("address", listen_addr));
  std::cout << "listening on " << listen_addr << std::endl;
  server.serve_forever();
  return 0;
}

} // namespace w1replay::commands

```

`src/w1replay/cli/commands/server.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>
#include <vector>

namespace w1replay::commands {

struct server_options {
  std::string trace_path;
  std::string index_path;
  std::string checkpoint_path;
  std::string gdb_listen;
  uint64_t thread_id = 0;
  uint64_t start_sequence = 0;
  bool instruction_steps = false;
  std::vector<std::string> module_mappings;
  std::vector<std::string> module_dirs;
};

int server(const server_options& options);

} // namespace w1replay::commands

```

`src/w1replay/cli/commands/summary.cpp`:

```cpp
#include "summary.hpp"

#include <algorithm>
#include <array>
#include <cstdint>
#include <cstring>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <limits>
#include <map>
#include <optional>
#include <sstream>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

#include <redlog.hpp>

#include "w1rewind/format/register_metadata.hpp"
#include "w1rewind/format/trace_format.hpp"
#include "w1rewind/format/trace_io.hpp"
#include "w1rewind/format/trace_validator.hpp"
#include "w1rewind/replay/replay_context.hpp"
#include "w1rewind/trace/replay_checkpoint.hpp"
#include "w1rewind/trace/trace_index.hpp"
#include "w1rewind/trace/trace_reader.hpp"

namespace w1replay::commands {

namespace summary_detail {

constexpr const char* k_indent1 = "  ";
constexpr const char* k_indent2 = "    ";
constexpr const char* k_indent3 = "      ";

struct address_span {
  bool has = false;
  uint64_t min = 0;
  uint64_t max = 0;

  void update(uint64_t address, uint64_t size) {
    if (size == 0) {
      return;
    }
    uint64_t end = address + size;
    if (end < address) {
      end = std::numeric_limits<uint64_t>::max();
    }
    if (!has) {
      min = address;
      max = end;
      has = true;
      return;
    }
    min = std::min(min, address);
    max = std::max(max, end);
  }
};

struct record_counters {
  uint64_t total = 0;
  uint64_t target_info = 0;
  uint64_t target_environment = 0;
  uint64_t register_spec = 0;
  uint64_t module_table = 0;
  uint64_t module_load = 0;
  uint64_t module_unload = 0;
  uint64_t memory_map = 0;
  uint64_t thread_start = 0;
  uint64_t thread_end = 0;
  uint64_t instruction = 0;
  uint64_t block_definition = 0;
  uint64_t block_exec = 0;
  uint64_t register_deltas = 0;
  uint64_t register_bytes = 0;
  uint64_t memory_access = 0;
  uint64_t snapshot = 0;
};

struct thread_stats {
  bool has_flow = false;
  uint64_t flow_count = 0;
  uint64_t first_seq = 0;
  uint64_t last_seq = 0;
  uint64_t mem_access = 0;
  uint64_t mem_read = 0;
  uint64_t mem_write = 0;
  uint64_t mem_bytes = 0;
  uint64_t mem_known = 0;
  uint64_t mem_truncated = 0;
  uint64_t snapshots = 0;
  uint64_t snapshot_stack_bytes = 0;
  uint64_t reg_delta_records = 0;
  uint64_t reg_delta_entries = 0;
  uint64_t reg_bytes_records = 0;
  uint64_t reg_bytes_entries = 0;
  uint64_t reg_bytes_data = 0;
};

struct module_hit_stats {
  uint64_t flow_hits = 0;
  uint64_t mem_hits = 0;
  uint64_t mem_bytes = 0;
};

struct scan_stats {
  record_counters records{};
  uint64_t instruction_bytes = 0;
  uint64_t block_bytes = 0;
  uint64_t register_delta_entries = 0;
  uint64_t register_bytes_entries = 0;
  uint64_t register_bytes_data = 0;
  uint64_t memory_access_bytes = 0;
  uint64_t memory_access_known = 0;
  uint64_t memory_access_truncated = 0;
  uint64_t memory_access_reads = 0;
  uint64_t memory_access_writes = 0;
  uint64_t snapshot_stack_bytes = 0;
  uint64_t snapshot_register_entries = 0;
  uint64_t chunk_count = 0;
  uint64_t compressed_bytes = 0;
  uint64_t uncompressed_bytes = 0;
  uint64_t flow_records = 0;
  uint64_t flow_mapped = 0;
  uint64_t flow_unmapped = 0;
  uint64_t memory_mapped = 0;
  uint64_t memory_unmapped = 0;
  address_span flow_span{};
  std::unordered_map<uint64_t, thread_stats> threads{};
  std::unordered_map<uint64_t, module_hit_stats> module_hits{};
};

struct scan_result {
  w1::rewind::replay_context context;
  scan_stats stats;
};

struct checkpoint_info {
  bool exists = false;
  bool valid = false;
  std::string path;
  std::string error;
  w1::rewind::replay_checkpoint_header header{};
  uint32_t thread_count = 0;
  uint32_t entry_count = 0;
};

struct index_info {
  w1::rewind::trace_index_status status = w1::rewind::trace_index_status::missing;
  std::string path;
  std::string error;
  std::optional<w1::rewind::trace_index> index;
};

struct column_spec {
  std::string header;
  bool right = false;
  size_t width = 0;
};

struct summary_context {
  const summary_options& options;
  const scan_result& scan;
  const index_info& index;
  const checkpoint_info& checkpoint;
  const std::vector<std::string>& warnings;
};

std::string format_number(uint64_t value) {
  std::string out = std::to_string(value);
  for (std::ptrdiff_t i = static_cast<std::ptrdiff_t>(out.size()) - 3; i > 0; i -= 3) {
    out.insert(static_cast<size_t>(i), ",");
  }
  return out;
}

std::string format_decimal(double value, int precision) {
  std::ostringstream out;
  out << std::fixed << std::setprecision(precision) << value;
  std::string text = out.str();
  if (precision > 0) {
    while (!text.empty() && text.back() == '0') {
      text.pop_back();
    }
    if (!text.empty() && text.back() == '.') {
      text.pop_back();
    }
  }
  if (text.empty()) {
    return "0";
  }
  return text;
}

std::string format_bytes(uint64_t bytes) {
  static constexpr const char* suffixes[] = {"b", "kb", "mb", "gb", "tb", "pb"};
  constexpr size_t suffix_count = sizeof(suffixes) / sizeof(suffixes[0]);
  double value = static_cast<double>(bytes);
  size_t suffix_index = 0;
  while (value >= 1024.0 && suffix_index + 1 < suffix_count) {
    value /= 1024.0;
    ++suffix_index;
  }
  if (suffix_index == 0) {
    return format_number(bytes) + "b";
  }
  return format_decimal(value, 1) + suffixes[suffix_index];
}

std::string format_address(uint64_t address) {
  std::ostringstream out;
  out << "0x" << std::hex << address;
  return out.str();
}

std::string format_bool(bool value) { return value ? "true" : "false"; }

std::string format_byte_order(w1::arch::byte_order order) {
  switch (order) {
  case w1::arch::byte_order::little:
    return "little";
  case w1::arch::byte_order::big:
    return "big";
  default:
    return "unknown";
  }
}

std::string format_arch_family(w1::arch::family family) {
  switch (family) {
  case w1::arch::family::x86:
    return "x86";
  case w1::arch::family::arm:
    return "arm";
  case w1::arch::family::riscv:
    return "riscv";
  case w1::arch::family::mips:
    return "mips";
  case w1::arch::family::ppc:
    return "ppc";
  case w1::arch::family::sparc:
    return "sparc";
  case w1::arch::family::systemz:
    return "systemz";
  case w1::arch::family::wasm:
    return "wasm";
  default:
    return "unknown";
  }
}

std::string format_arch_mode(w1::arch::mode mode) {
  switch (mode) {
  case w1::arch::mode::x86_32:
    return "x86";
  case w1::arch::mode::x86_64:
    return "x86_64";
  case w1::arch::mode::arm:
    return "arm";
  case w1::arch::mode::thumb:
    return "thumb";
  case w1::arch::mode::aarch64:
    return "arm64";
  case w1::arch::mode::riscv32:
    return "riscv32";
  case w1::arch::mode::riscv64:
    return "riscv64";
  case w1::arch::mode::mips32:
    return "mips32";
  case w1::arch::mode::mips64:
    return "mips64";
  case w1::arch::mode::ppc32:
    return "ppc32";
  case w1::arch::mode::ppc64:
    return "ppc64";
  case w1::arch::mode::sparc32:
    return "sparc32";
  case w1::arch::mode::sparc64:
    return "sparc64";
  case w1::arch::mode::systemz:
    return "systemz";
  case w1::arch::mode::wasm32:
    return "wasm32";
  case w1::arch::mode::wasm64:
    return "wasm64";
  default:
    return "unknown";
  }
}

std::string format_trace_flags(uint64_t flags) {
  std::vector<std::string> parts;
  if ((flags & w1::rewind::trace_flag_instructions) != 0) {
    parts.emplace_back("instruction");
  }
  if ((flags & w1::rewind::trace_flag_blocks) != 0) {
    parts.emplace_back("blocks");
  }
  if ((flags & w1::rewind::trace_flag_register_deltas) != 0) {
    parts.emplace_back("reg_deltas");
  }
  if ((flags & w1::rewind::trace_flag_memory_access) != 0) {
    parts.emplace_back("mem_access");
  }
  if ((flags & w1::rewind::trace_flag_memory_values) != 0) {
    parts.emplace_back("mem_values");
  }
  if ((flags & w1::rewind::trace_flag_snapshots) != 0) {
    parts.emplace_back("snapshots");
  }
  if ((flags & w1::rewind::trace_flag_stack_snapshot) != 0) {
    parts.emplace_back("stack_snapshots");
  }
  if (parts.empty()) {
    return "none";
  }
  std::ostringstream out;
  for (size_t i = 0; i < parts.size(); ++i) {
    if (i > 0) {
      out << "|";
    }
    out << parts[i];
  }
  return out.str();
}

std::string format_compression(w1::rewind::trace_compression compression) {
  switch (compression) {
  case w1::rewind::trace_compression::none:
    return "none";
  case w1::rewind::trace_compression::zstd:
    return "zstd";
  default:
    return "unknown";
  }
}

std::string format_module_format(w1::rewind::module_format format) {
  switch (format) {
  case w1::rewind::module_format::elf:
    return "elf";
  case w1::rewind::module_format::macho:
    return "macho";
  case w1::rewind::module_format::pe:
    return "pe";
  default:
    return "unknown";
  }
}

std::string format_perms(w1::rewind::module_perm perms) {
  std::string out = "---";
  if ((perms & w1::rewind::module_perm::read) != w1::rewind::module_perm::none) {
    out[0] = 'r';
  }
  if ((perms & w1::rewind::module_perm::write) != w1::rewind::module_perm::none) {
    out[1] = 'w';
  }
  if ((perms & w1::rewind::module_perm::exec) != w1::rewind::module_perm::none) {
    out[2] = 'x';
  }
  return out;
}

std::string format_flow_kind(uint64_t flags) {
  bool use_blocks = (flags & w1::rewind::trace_flag_blocks) != 0;
  bool use_instructions = (flags & w1::rewind::trace_flag_instructions) != 0;
  if (use_blocks == use_instructions) {
    return "unknown";
  }
  return use_blocks ? "blocks" : "instruction";
}

std::string format_index_status(w1::rewind::trace_index_status status) {
  switch (status) {
  case w1::rewind::trace_index_status::ok:
    return "ok";
  case w1::rewind::trace_index_status::missing:
    return "missing";
  case w1::rewind::trace_index_status::stale:
    return "stale";
  case w1::rewind::trace_index_status::incompatible:
    return "incompatible";
  default:
    return "unknown";
  }
}

std::string format_span(const address_span& span) {
  if (!span.has) {
    return "n/a";
  }
  std::ostringstream out;
  out << format_address(span.min) << "-" << format_address(span.max);
  return out.str();
}

std::string format_reg_class(w1::rewind::register_class cls) {
  switch (cls) {
  case w1::rewind::register_class::gpr:
    return "gpr";
  case w1::rewind::register_class::fpr:
    return "fpr";
  case w1::rewind::register_class::simd:
    return "simd";
  case w1::rewind::register_class::flags:
    return "flags";
  case w1::rewind::register_class::system:
    return "system";
  default:
    return "unknown";
  }
}

std::string format_reg_classes(const std::vector<w1::rewind::register_spec>& specs) {
  std::map<std::string, uint64_t> counts;
  for (const auto& spec : specs) {
    counts[format_reg_class(spec.reg_class)] += 1;
  }
  if (counts.empty()) {
    return "none";
  }
  std::ostringstream out;
  bool first = true;
  for (const auto& [name, count] : counts) {
    if (!first) {
      out << " ";
    }
    first = false;
    out << name << ":" << format_number(count);
  }
  return out.str();
}

std::string format_permissions_summary(const std::vector<w1::rewind::memory_region_record>& regions) {
  if (regions.empty()) {
    return "none";
  }
  struct bucket {
    uint64_t count = 0;
    uint64_t bytes = 0;
  };
  std::map<std::string, bucket> buckets;
  for (const auto& region : regions) {
    auto key = format_perms(region.permissions);
    buckets[key].count += 1;
    buckets[key].bytes += region.size;
  }
  std::ostringstream out;
  bool first = true;
  for (const auto& [perm, info] : buckets) {
    if (!first) {
      out << " ";
    }
    first = false;
    out << perm << ":" << format_number(info.count) << "(" << format_bytes(info.bytes) << ")";
  }
  return out.str();
}

void push_if(std::vector<std::string>& items, bool cond, std::string value) {
  if (cond) {
    items.push_back(std::move(value));
  }
}

void print_kv_line(const std::vector<std::string>& items) {
  if (items.empty()) {
    return;
  }
  std::cout << k_indent2 << items.front();
  for (size_t i = 1; i < items.size(); ++i) {
    std::cout << "  " << items[i];
  }
  std::cout << "\n";
}

void print_table(const std::vector<column_spec>& columns, const std::vector<std::vector<std::string>>& rows) {
  if (columns.empty()) {
    return;
  }
  std::vector<column_spec> resolved = columns;
  for (auto& column : resolved) {
    column.width = column.header.size();
  }
  for (const auto& row : rows) {
    for (size_t i = 0; i < resolved.size() && i < row.size(); ++i) {
      resolved[i].width = std::max(resolved[i].width, row[i].size());
    }
  }

  std::cout << k_indent2;
  for (size_t i = 0; i < resolved.size(); ++i) {
    const auto& column = resolved[i];
    std::ostringstream cell;
    cell << (column.right ? std::right : std::left) << std::setw(static_cast<int>(column.width)) << column.header;
    std::cout << cell.str();
    if (i + 1 < resolved.size()) {
      std::cout << "  ";
    }
  }
  std::cout << "\n";

  for (const auto& row : rows) {
    std::cout << k_indent2;
    for (size_t i = 0; i < resolved.size(); ++i) {
      const auto& column = resolved[i];
      std::string value = i < row.size() ? row[i] : "";
      std::ostringstream cell;
      cell << (column.right ? std::right : std::left) << std::setw(static_cast<int>(column.width)) << value;
      std::cout << cell.str();
      if (i + 1 < resolved.size()) {
        std::cout << "  ";
      }
    }
    std::cout << "\n";
  }
}

void apply_module_load(std::vector<w1::rewind::module_record>& modules, w1::rewind::module_record module) {
  auto it = std::find_if(modules.begin(), modules.end(), [&](const w1::rewind::module_record& entry) {
    return entry.id == module.id;
  });
  if (it != modules.end()) {
    *it = std::move(module);
    return;
  }
  modules.push_back(std::move(module));
}

void apply_module_unload(
    std::vector<w1::rewind::module_record>& modules, const w1::rewind::module_unload_record& record
) {
  auto it = std::find_if(modules.begin(), modules.end(), [&](const w1::rewind::module_record& entry) {
    return entry.id == record.module_id;
  });
  if (it != modules.end()) {
    modules.erase(it);
    return;
  }

  if (record.base == 0 && record.size == 0 && record.path.empty()) {
    return;
  }

  auto fallback = std::find_if(modules.begin(), modules.end(), [&](const w1::rewind::module_record& entry) {
    if (record.base != 0 && entry.base != record.base) {
      return false;
    }
    if (record.size != 0 && entry.size != record.size) {
      return false;
    }
    if (!record.path.empty() && entry.path != record.path) {
      return false;
    }
    return true;
  });

  if (fallback != modules.end()) {
    modules.erase(fallback);
  }
}

std::optional<uint16_t> find_register_with_flag(const std::vector<w1::rewind::register_spec>& specs, uint16_t flag) {
  for (const auto& spec : specs) {
    if ((spec.flags & flag) != 0) {
      return spec.reg_id;
    }
  }
  return std::nullopt;
}

bool read_checkpoint_header(
    std::istream& in, w1::rewind::replay_checkpoint_header& header, uint32_t& thread_count, uint32_t& entry_count
) {
  std::array<uint8_t, 8> magic{};
  if (!w1::rewind::read_stream_bytes(in, magic.data(), magic.size())) {
    return false;
  }
  if (std::memcmp(
          magic.data(), w1::rewind::k_replay_checkpoint_magic.data(), w1::rewind::k_replay_checkpoint_magic.size()
      ) != 0) {
    return false;
  }

  uint16_t arch_family = 0;
  uint16_t arch_mode = 0;
  uint8_t arch_order = 0;
  uint8_t reserved = 0;
  if (!w1::rewind::read_stream_u16(in, header.version) || !w1::rewind::read_stream_u16(in, header.trace_version) ||
      !w1::rewind::read_stream_u16(in, arch_family) || !w1::rewind::read_stream_u16(in, arch_mode) ||
      !w1::rewind::read_stream_bytes(in, &arch_order, sizeof(arch_order)) ||
      !w1::rewind::read_stream_bytes(in, &reserved, sizeof(reserved)) ||
      !w1::rewind::read_stream_u32(in, header.arch.pointer_bits) ||
      !w1::rewind::read_stream_u32(in, header.arch.flags) || !w1::rewind::read_stream_u64(in, header.trace_flags) ||
      !w1::rewind::read_stream_u32(in, header.register_count) || !w1::rewind::read_stream_u32(in, header.stride) ||
      !w1::rewind::read_stream_u32(in, thread_count) || !w1::rewind::read_stream_u32(in, entry_count)) {
    return false;
  }

  header.arch.arch_family = static_cast<w1::arch::family>(arch_family);
  header.arch.arch_mode = static_cast<w1::arch::mode>(arch_mode);
  header.arch.arch_byte_order = static_cast<w1::arch::byte_order>(arch_order);
  return true;
}

bool load_checkpoint_info(const std::string& trace_path, const std::string& checkpoint_path, checkpoint_info& out) {
  out = checkpoint_info{};
  out.path = checkpoint_path.empty() ? w1::rewind::default_replay_checkpoint_path(trace_path) : checkpoint_path;

  std::error_code ec;
  out.exists = std::filesystem::exists(out.path, ec);
  if (ec || !out.exists) {
    out.exists = false;
    return true;
  }

  std::ifstream in(out.path, std::ios::binary);
  if (!in.is_open()) {
    out.error = "failed to open";
    return true;
  }

  if (!read_checkpoint_header(in, out.header, out.thread_count, out.entry_count)) {
    out.error = "invalid header";
    return true;
  }

  out.valid = (out.header.version == w1::rewind::k_replay_checkpoint_version);
  if (!out.valid) {
    out.error = "unsupported version";
  }
  return true;
}

index_info load_index_info(const std::string& trace_path, const std::string& index_path, bool allow_build) {
  index_info out{};
  out.path = index_path.empty() ? w1::rewind::default_trace_index_path(trace_path) : index_path;

  std::error_code ec;
  bool exists = std::filesystem::exists(out.path, ec);
  if (ec) {
    out.status = w1::rewind::trace_index_status::missing;
    out.error = "failed to stat index";
    return out;
  }

  auto log = redlog::get_logger("w1replay.summary");

  if (allow_build) {
    w1::rewind::trace_index index;
    std::string error;
    if (w1::rewind::ensure_trace_index(trace_path, out.path, w1::rewind::trace_index_options{}, index, error, true)) {
      out.status = w1::rewind::trace_index_status::ok;
      out.index = std::move(index);
      return out;
    }
    out.status = w1::rewind::trace_index_status::missing;
    out.error = error.empty() ? "failed to build index" : error;
    return out;
  }

  if (!exists) {
    out.status = w1::rewind::trace_index_status::missing;
    return out;
  }

  w1::rewind::trace_index index;
  if (!w1::rewind::load_trace_index(out.path, index, log)) {
    out.status = w1::rewind::trace_index_status::incompatible;
    out.error = "failed to load index";
    return out;
  }

  std::string status_error;
  out.status = w1::rewind::evaluate_trace_index(trace_path, index, status_error);
  if (out.status == w1::rewind::trace_index_status::ok) {
    std::error_code trace_ec;
    std::error_code index_ec;
    auto trace_time = std::filesystem::last_write_time(trace_path, trace_ec);
    auto index_time = std::filesystem::last_write_time(out.path, index_ec);
    if (!trace_ec && !index_ec && trace_time > index_time) {
      out.status = w1::rewind::trace_index_status::stale;
      status_error = "trace index stale";
    }
  }

  if (out.status != w1::rewind::trace_index_status::ok) {
    out.error = status_error;
  }
  out.index = std::move(index);
  return out;
}

class trace_scanner {
public:
  explicit trace_scanner(bool full) : full_(full) {}

  bool scan(const std::string& path, scan_result& out, std::string& error) {
    error.clear();
    result_ = scan_result{};
    thread_map_.clear();
    last_chunk_index_ = std::numeric_limits<uint32_t>::max();

    w1::rewind::trace_reader reader(path);
    if (!reader.open()) {
      error = reader.error().empty() ? "failed to open trace" : std::string(reader.error());
      return false;
    }

    result_.context.header = reader.header();

    w1::rewind::trace_record record;
    w1::rewind::trace_record_location location{};
    while (reader.read_next(record, &location)) {
      result_.stats.records.total += 1;
      account_chunk(reader, location);
      std::visit([this](const auto& entry) { handle(entry); }, record);
    }

    if (!reader.error().empty()) {
      error = std::string(reader.error());
      return false;
    }

    if (!finalize(error)) {
      return false;
    }

    out = std::move(result_);
    return true;
  }

private:
  void account_chunk(const w1::rewind::trace_reader& reader, const w1::rewind::trace_record_location& location) {
    if (location.chunk_index == last_chunk_index_) {
      return;
    }
    result_.stats.chunk_count += 1;
    if (auto info = reader.last_chunk_info()) {
      result_.stats.compressed_bytes += info->compressed_size;
      result_.stats.uncompressed_bytes += info->uncompressed_size;
    }
    last_chunk_index_ = location.chunk_index;
  }

  void note_flow(uint64_t thread_id, uint64_t sequence) {
    auto& thread = result_.stats.threads[thread_id];
    if (!thread.has_flow) {
      thread.has_flow = true;
      thread.first_seq = sequence;
      thread.last_seq = sequence;
    } else {
      thread.first_seq = std::min(thread.first_seq, sequence);
      thread.last_seq = std::max(thread.last_seq, sequence);
    }
    thread.flow_count += 1;
  }

  void map_flow(uint64_t address, uint32_t size) {
    result_.stats.flow_span.update(address, size);
    uint64_t offset = 0;
    if (auto* module = result_.context.find_module_for_address(address, size, offset)) {
      result_.stats.flow_mapped += 1;
      result_.stats.module_hits[module->id].flow_hits += 1;
    } else {
      result_.stats.flow_unmapped += 1;
    }
  }

  void map_memory(uint64_t address, uint32_t size) {
    uint64_t offset = 0;
    if (auto* module = result_.context.find_module_for_address(address, size, offset)) {
      result_.stats.memory_mapped += 1;
      auto& hits = result_.stats.module_hits[module->id];
      hits.mem_hits += 1;
      hits.mem_bytes += size;
    } else {
      result_.stats.memory_unmapped += 1;
    }
  }

  void handle(const w1::rewind::target_info_record& record) {
    result_.stats.records.target_info += 1;
    result_.context.target_info = record;
  }

  void handle(const w1::rewind::target_environment_record& record) {
    result_.stats.records.target_environment += 1;
    result_.context.target_environment = record;
  }

  void handle(const w1::rewind::register_spec_record& record) {
    result_.stats.records.register_spec += 1;
    result_.context.register_specs = record.registers;
  }

  void handle(const w1::rewind::module_table_record& record) {
    result_.stats.records.module_table += 1;
    result_.context.modules = record.modules;
  }

  void handle(const w1::rewind::module_load_record& record) {
    result_.stats.records.module_load += 1;
    apply_module_load(result_.context.modules, record.module);
  }

  void handle(const w1::rewind::module_unload_record& record) {
    result_.stats.records.module_unload += 1;
    apply_module_unload(result_.context.modules, record);
  }

  void handle(const w1::rewind::memory_map_record& record) {
    result_.stats.records.memory_map += 1;
    result_.context.memory_map = record.regions;
  }

  void handle(const w1::rewind::block_definition_record& record) {
    result_.stats.records.block_definition += 1;
    result_.context.blocks_by_id[record.block_id] = record;
    result_.stats.block_bytes += record.size;
  }

  void handle(const w1::rewind::thread_start_record& record) {
    result_.stats.records.thread_start += 1;
    auto& info = thread_map_[record.thread_id];
    info.thread_id = record.thread_id;
    info.started = true;
    if (!record.name.empty() && info.name.empty()) {
      info.name = record.name;
    }
  }

  void handle(const w1::rewind::thread_end_record& record) {
    result_.stats.records.thread_end += 1;
    auto& info = thread_map_[record.thread_id];
    info.thread_id = record.thread_id;
    info.ended = true;
  }

  void handle(const w1::rewind::instruction_record& record) {
    result_.stats.records.instruction += 1;
    result_.stats.flow_records += 1;
    result_.stats.instruction_bytes += record.size;
    note_flow(record.thread_id, record.sequence);
    if (full_) {
      map_flow(record.address, record.size);
    }
  }

  void handle(const w1::rewind::block_exec_record& record) {
    result_.stats.records.block_exec += 1;
    result_.stats.flow_records += 1;
    note_flow(record.thread_id, record.sequence);
    if (full_) {
      auto def_it = result_.context.blocks_by_id.find(record.block_id);
      if (def_it != result_.context.blocks_by_id.end()) {
        map_flow(def_it->second.address, def_it->second.size);
      } else {
        result_.stats.flow_unmapped += 1;
      }
    }
  }

  void handle(const w1::rewind::register_delta_record& record) {
    result_.stats.records.register_deltas += 1;
    result_.stats.register_delta_entries += record.deltas.size();
    auto& thread = result_.stats.threads[record.thread_id];
    thread.reg_delta_records += 1;
    thread.reg_delta_entries += record.deltas.size();
  }

  void handle(const w1::rewind::register_bytes_record& record) {
    result_.stats.records.register_bytes += 1;
    result_.stats.register_bytes_entries += record.entries.size();
    result_.stats.register_bytes_data += record.data.size();
    auto& thread = result_.stats.threads[record.thread_id];
    thread.reg_bytes_records += 1;
    thread.reg_bytes_entries += record.entries.size();
    thread.reg_bytes_data += record.data.size();
  }

  void handle(const w1::rewind::memory_access_record& record) {
    result_.stats.records.memory_access += 1;
    result_.stats.memory_access_bytes += record.size;
    if (record.kind == w1::rewind::memory_access_kind::read) {
      result_.stats.memory_access_reads += 1;
    } else {
      result_.stats.memory_access_writes += 1;
    }
    if (record.value_known) {
      result_.stats.memory_access_known += 1;
    }
    if (record.value_truncated) {
      result_.stats.memory_access_truncated += 1;
    }
    auto& thread = result_.stats.threads[record.thread_id];
    thread.mem_access += 1;
    if (record.kind == w1::rewind::memory_access_kind::read) {
      thread.mem_read += 1;
    } else {
      thread.mem_write += 1;
    }
    thread.mem_bytes += record.size;
    if (record.value_known) {
      thread.mem_known += 1;
    }
    if (record.value_truncated) {
      thread.mem_truncated += 1;
    }
    if (full_) {
      map_memory(record.address, record.size);
    }
  }

  void handle(const w1::rewind::snapshot_record& record) {
    result_.stats.records.snapshot += 1;
    result_.stats.snapshot_register_entries += record.registers.size();
    uint64_t snapshot_bytes = 0;
    for (const auto& segment : record.stack_segments) {
      snapshot_bytes += segment.bytes.size();
    }
    result_.stats.snapshot_stack_bytes += snapshot_bytes;
    auto& thread = result_.stats.threads[record.thread_id];
    thread.snapshots += 1;
    thread.snapshot_stack_bytes += snapshot_bytes;
  }

  bool finalize(std::string& error) {
    if (!w1::rewind::validate_trace_arch(result_.context.header.arch, error)) {
      return false;
    }

    w1::rewind::register_spec_validation_options reg_options{};
    reg_options.allow_empty = (result_.context.header.flags & w1::rewind::trace_flag_register_deltas) == 0;
    if (!w1::rewind::normalize_register_specs(result_.context.register_specs, error, reg_options)) {
      return false;
    }

    result_.context.register_names.clear();
    result_.context.register_names.reserve(result_.context.register_specs.size());
    for (const auto& spec : result_.context.register_specs) {
      result_.context.register_names.push_back(spec.name);
    }

    result_.context.modules_by_id.clear();
    result_.context.modules_by_id.reserve(result_.context.modules.size());
    for (const auto& module : result_.context.modules) {
      result_.context.modules_by_id[module.id] = module;
    }

    for (const auto& [thread_id, stats] : result_.stats.threads) {
      if (thread_map_.find(thread_id) == thread_map_.end()) {
        w1::rewind::replay_thread_info info{};
        info.thread_id = thread_id;
        thread_map_.emplace(thread_id, std::move(info));
      }
    }

    result_.context.threads.clear();
    result_.context.threads.reserve(thread_map_.size());
    for (const auto& [_, info] : thread_map_) {
      result_.context.threads.push_back(info);
    }
    std::sort(
        result_.context.threads.begin(), result_.context.threads.end(),
        [](const w1::rewind::replay_thread_info& lhs, const w1::rewind::replay_thread_info& rhs) {
          return lhs.thread_id < rhs.thread_id;
        }
    );

    if (!result_.context.register_names.empty()) {
      result_.context.sp_reg_id = find_register_with_flag(result_.context.register_specs, w1::rewind::register_flag_sp);
      if (!result_.context.sp_reg_id.has_value()) {
        result_.context.sp_reg_id =
            w1::rewind::resolve_sp_reg_id(result_.context.header.arch, result_.context.register_names);
      }
    }

    return true;
  }

  bool full_ = false;
  scan_result result_{};
  std::unordered_map<uint64_t, w1::rewind::replay_thread_info> thread_map_{};
  uint32_t last_chunk_index_ = std::numeric_limits<uint32_t>::max();
};

std::vector<std::string> build_warnings(
    const scan_result& scan, const index_info& index, const checkpoint_info& checkpoint
) {
  std::vector<std::string> warnings;
  bool use_blocks = (scan.context.header.flags & w1::rewind::trace_flag_blocks) != 0;
  bool use_instructions = (scan.context.header.flags & w1::rewind::trace_flag_instructions) != 0;
  if (use_blocks == use_instructions) {
    warnings.emplace_back("flow flags ambiguous");
  }
  if (scan.context.threads.empty()) {
    warnings.emplace_back("no thread records");
  }
  if (scan.context.modules.empty()) {
    warnings.emplace_back("no module records");
  }
  if ((scan.context.header.flags & w1::rewind::trace_flag_register_deltas) != 0 &&
      scan.context.register_specs.empty()) {
    warnings.emplace_back("register specs missing");
  }
  if ((scan.context.header.flags & w1::rewind::trace_flag_blocks) != 0 && scan.context.blocks_by_id.empty()) {
    warnings.emplace_back("block definitions missing");
  }
  if (index.status != w1::rewind::trace_index_status::ok) {
    warnings.emplace_back("index " + format_index_status(index.status));
  }
  if (checkpoint.exists && !checkpoint.valid) {
    warnings.emplace_back("checkpoint invalid");
  }
  return warnings;
}

void render_trace_section(const summary_context& ctx, uint64_t file_size, bool has_file_size) {
  const auto& header = ctx.scan.context.header;
  std::cout << k_indent1 << "trace\n";

  std::vector<std::string> line;
  line.push_back("path=" + ctx.options.trace_path);
  if (has_file_size) {
    line.push_back("size=" + format_bytes(file_size));
  }
  line.push_back("version=" + format_number(header.version));
  line.push_back("arch=" + format_arch_mode(header.arch.arch_mode));
  line.push_back("family=" + format_arch_family(header.arch.arch_family));
  line.push_back("endian=" + format_byte_order(header.arch.arch_byte_order));
  if (header.arch.pointer_bits != 0) {
    line.push_back("ptr=" + format_number(header.arch.pointer_bits / 8));
  }
  print_kv_line(line);

  std::vector<std::string> line2;
  line2.push_back("flags=" + format_trace_flags(header.flags));
  line2.push_back("compression=" + format_compression(header.compression));
  if (header.chunk_size != 0) {
    line2.push_back("chunk_size=" + format_number(header.chunk_size));
  }
  if (ctx.scan.stats.chunk_count != 0) {
    line2.push_back("chunks=" + format_number(ctx.scan.stats.chunk_count));
  }
  if (ctx.scan.stats.compressed_bytes != 0) {
    line2.push_back("compressed=" + format_bytes(ctx.scan.stats.compressed_bytes));
  }
  if (ctx.scan.stats.uncompressed_bytes != 0) {
    line2.push_back("uncompressed=" + format_bytes(ctx.scan.stats.uncompressed_bytes));
  }
  print_kv_line(line2);
}

void render_index_section(const summary_context& ctx) {
  std::cout << k_indent1 << "index\n";

  std::vector<std::string> line;
  line.push_back("status=" + format_index_status(ctx.index.status));
  line.push_back("path=" + ctx.index.path);
  if (ctx.index.index.has_value()) {
    line.push_back("anchor_stride=" + format_number(ctx.index.index->header.anchor_stride));
    line.push_back("anchors=" + format_number(ctx.index.index->anchors.size()));
    line.push_back("snapshots=" + format_number(ctx.index.index->snapshots.size()));
  }
  if (ctx.index.status != w1::rewind::trace_index_status::ok && !ctx.index.error.empty()) {
    line.push_back("error=" + ctx.index.error);
  }
  print_kv_line(line);
}

void render_checkpoint_section(const summary_context& ctx) {
  std::cout << k_indent1 << "checkpoints\n";

  std::vector<std::string> line;
  if (!ctx.checkpoint.exists) {
    line.push_back("status=missing");
    line.push_back("path=" + ctx.checkpoint.path);
    print_kv_line(line);
    return;
  }
  if (!ctx.checkpoint.valid) {
    line.push_back("status=invalid");
    line.push_back("path=" + ctx.checkpoint.path);
    if (!ctx.checkpoint.error.empty()) {
      line.push_back("error=" + ctx.checkpoint.error);
    }
    print_kv_line(line);
    return;
  }

  line.push_back("status=ok");
  line.push_back("path=" + ctx.checkpoint.path);
  line.push_back("version=" + format_number(ctx.checkpoint.header.version));
  line.push_back("trace_version=" + format_number(ctx.checkpoint.header.trace_version));
  line.push_back("trace_flags=" + format_trace_flags(ctx.checkpoint.header.trace_flags));
  line.push_back("stride=" + format_number(ctx.checkpoint.header.stride));
  line.push_back("threads=" + format_number(ctx.checkpoint.thread_count));
  line.push_back("entries=" + format_number(ctx.checkpoint.entry_count));
  line.push_back("registers=" + format_number(ctx.checkpoint.header.register_count));
  print_kv_line(line);
}

void render_flow_section(const summary_context& ctx) {
  std::cout << k_indent1 << "flow\n";

  std::vector<std::string> line;
  line.push_back("kind=" + format_flow_kind(ctx.scan.context.header.flags));
  line.push_back("records=" + format_number(ctx.scan.stats.flow_records));
  line.push_back("threads=" + format_number(ctx.scan.context.threads.size()));
  line.push_back("modules=" + format_number(ctx.scan.context.modules.size()));
  push_if(line, ctx.options.full, "addr_span=" + format_span(ctx.scan.stats.flow_span));
  print_kv_line(line);

  if (!ctx.options.full) {
    return;
  }

  bool use_blocks = (ctx.scan.context.header.flags & w1::rewind::trace_flag_blocks) != 0;
  bool use_instructions = (ctx.scan.context.header.flags & w1::rewind::trace_flag_instructions) != 0;

  std::vector<std::string> line2;
  if (use_instructions) {
    line2.push_back("inst_bytes=" + format_bytes(ctx.scan.stats.instruction_bytes));
  }
  if (use_blocks) {
    line2.push_back("block_defs=" + format_number(ctx.scan.context.blocks_by_id.size()));
    line2.push_back("block_bytes=" + format_bytes(ctx.scan.stats.block_bytes));
  }
  if (ctx.scan.stats.flow_records != 0) {
    line2.push_back("mapped=" + format_number(ctx.scan.stats.flow_mapped));
    line2.push_back("unmapped=" + format_number(ctx.scan.stats.flow_unmapped));
  }
  print_kv_line(line2);
}

void render_threads_section(const summary_context& ctx) {
  std::cout << k_indent1 << "threads\n";

  std::unordered_map<uint64_t, w1::rewind::trace_thread_index> index_threads;
  if (ctx.index.index.has_value()) {
    for (const auto& entry : ctx.index.index->threads) {
      index_threads.emplace(entry.thread_id, entry);
    }
  }

  std::vector<column_spec> columns{
      {"id", true},        {"name", false},    {"started", false}, {"ended", false},    {"flow_count", true},
      {"first_seq", true}, {"last_seq", true}, {"anchors", true},  {"snapshots", true}, {"mem_access", true},
  };
  std::vector<std::vector<std::string>> rows;
  rows.reserve(ctx.scan.context.threads.size());

  for (const auto& info : ctx.scan.context.threads) {
    thread_stats stats{};
    if (auto it = ctx.scan.stats.threads.find(info.thread_id); it != ctx.scan.stats.threads.end()) {
      stats = it->second;
    }

    std::string anchor_value = "n/a";
    if (auto it = index_threads.find(info.thread_id); it != index_threads.end()) {
      anchor_value = format_number(it->second.anchor_count);
    }

    std::vector<std::string> row;
    row.push_back(format_number(info.thread_id));
    row.push_back(info.name.empty() ? "unknown" : info.name);
    row.push_back(format_bool(info.started));
    row.push_back(format_bool(info.ended));
    row.push_back(format_number(stats.flow_count));
    row.push_back(stats.has_flow ? format_number(stats.first_seq) : "n/a");
    row.push_back(stats.has_flow ? format_number(stats.last_seq) : "n/a");
    row.push_back(anchor_value);
    row.push_back(format_number(stats.snapshots));
    row.push_back(format_number(stats.mem_access));
    rows.push_back(std::move(row));
  }

  print_table(columns, rows);

  if (!ctx.options.full) {
    return;
  }

  for (const auto& info : ctx.scan.context.threads) {
    auto stats_it = ctx.scan.stats.threads.find(info.thread_id);
    if (stats_it == ctx.scan.stats.threads.end()) {
      continue;
    }
    const auto& stats = stats_it->second;
    std::vector<std::string> detail;
    detail.push_back("mem=r:" + format_number(stats.mem_read));
    detail.push_back("w:" + format_number(stats.mem_write));
    detail.push_back("mem_bytes=" + format_bytes(stats.mem_bytes));
    if (stats.mem_access != 0) {
      detail.push_back("known=" + format_number(stats.mem_known));
      detail.push_back("trunc=" + format_number(stats.mem_truncated));
    }
    detail.push_back("reg_deltas=" + format_number(stats.reg_delta_records));
    detail.push_back("delta_entries=" + format_number(stats.reg_delta_entries));
    detail.push_back("reg_bytes=" + format_number(stats.reg_bytes_records));
    detail.push_back("byte_entries=" + format_number(stats.reg_bytes_entries));
    detail.push_back("reg_bytes_data=" + format_bytes(stats.reg_bytes_data));
    detail.push_back("snapshots=" + format_number(stats.snapshots));
    detail.push_back("stack=" + format_bytes(stats.snapshot_stack_bytes));

    std::cout << k_indent3 << "thread=" << format_number(info.thread_id) << " ";
    for (size_t i = 0; i < detail.size(); ++i) {
      if (i > 0) {
        std::cout << "  ";
      }
      std::cout << detail[i];
    }
    std::cout << "\n";
  }
}

void render_modules_section(const summary_context& ctx) {
  std::cout << k_indent1 << "modules\n";

  uint64_t unresolved = 0;
  std::vector<w1::rewind::module_record> modules = ctx.scan.context.modules;
  for (const auto& module : modules) {
    if (module.path.empty()) {
      unresolved += 1;
    }
  }
  std::sort(modules.begin(), modules.end(), [](const auto& lhs, const auto& rhs) { return lhs.base < rhs.base; });

  std::vector<std::string> line;
  line.push_back("count=" + format_number(modules.size()));
  line.push_back("unresolved=" + format_number(unresolved));
  push_if(line, ctx.options.full, "loads=" + format_number(ctx.scan.stats.records.module_load));
  push_if(line, ctx.options.full, "unloads=" + format_number(ctx.scan.stats.records.module_unload));
  print_kv_line(line);

  std::vector<column_spec> columns{{"base", true}, {"size", true}, {"perms", false}, {"fmt", false}, {"path", false}};
  std::vector<std::vector<std::string>> rows;
  rows.reserve(modules.size());

  for (const auto& module : modules) {
    std::vector<std::string> row;
    row.push_back(format_address(module.base));
    row.push_back(format_bytes(module.size));
    row.push_back(format_perms(module.permissions));
    row.push_back(format_module_format(module.format));
    row.push_back(module.path.empty() ? "unknown" : module.path);
    rows.push_back(std::move(row));
  }

  print_table(columns, rows);

  if (!ctx.options.full || modules.empty()) {
    return;
  }

  for (const auto& module : modules) {
    std::vector<std::string> detail;
    detail.push_back("id=" + format_number(module.id));
    if ((module.flags & w1::rewind::module_record_flag_link_base_valid) != 0) {
      detail.push_back("link_base=" + format_address(module.link_base));
    }
    if (!module.identity.empty()) {
      detail.push_back("identity=" + module.identity);
    }
    if (module.identity_age != 0) {
      detail.push_back("age=" + format_number(module.identity_age));
    }
    auto hit_it = ctx.scan.stats.module_hits.find(module.id);
    if (hit_it != ctx.scan.stats.module_hits.end()) {
      detail.push_back("flow_hits=" + format_number(hit_it->second.flow_hits));
      detail.push_back("mem_hits=" + format_number(hit_it->second.mem_hits));
      detail.push_back("mem_bytes=" + format_bytes(hit_it->second.mem_bytes));
    }
    if (!detail.empty()) {
      std::cout << k_indent3 << "module=" << format_address(module.base) << " ";
      for (size_t i = 0; i < detail.size(); ++i) {
        if (i > 0) {
          std::cout << "  ";
        }
        std::cout << detail[i];
      }
      std::cout << "\n";
    }
  }
}

void render_state_section(const summary_context& ctx) {
  std::cout << k_indent1 << "state\n";

  std::vector<std::string> line;
  line.push_back(
      "registers=" +
      std::string((ctx.scan.context.header.flags & w1::rewind::trace_flag_register_deltas) != 0 ? "on" : "off")
  );
  line.push_back("reg_specs=" + format_number(ctx.scan.context.register_specs.size()));
  if (!ctx.scan.context.register_specs.empty()) {
    line.push_back("reg_classes=" + format_reg_classes(ctx.scan.context.register_specs));
  }
  line.push_back(
      "mem_access=" +
      std::string((ctx.scan.context.header.flags & w1::rewind::trace_flag_memory_access) != 0 ? "on" : "off")
  );
  line.push_back(
      "mem_values=" +
      std::string((ctx.scan.context.header.flags & w1::rewind::trace_flag_memory_values) != 0 ? "on" : "off")
  );
  line.push_back(
      "stack_snapshots=" +
      std::string((ctx.scan.context.header.flags & w1::rewind::trace_flag_stack_snapshot) != 0 ? "on" : "off")
  );
  print_kv_line(line);

  if (!ctx.scan.context.register_names.empty()) {
    std::vector<std::string> line2;
    if (auto pc_id = w1::rewind::resolve_pc_reg_id(ctx.scan.context.header.arch, ctx.scan.context.register_names)) {
      line2.push_back("pc=" + ctx.scan.context.register_names[*pc_id]);
    }
    if (ctx.scan.context.sp_reg_id.has_value()) {
      line2.push_back("sp=" + ctx.scan.context.register_names[*ctx.scan.context.sp_reg_id]);
    }
    print_kv_line(line2);
  }

  if (ctx.options.full) {
    std::vector<std::string> line3;
    line3.push_back("reg_deltas=" + format_number(ctx.scan.stats.records.register_deltas));
    line3.push_back("delta_entries=" + format_number(ctx.scan.stats.register_delta_entries));
    line3.push_back("reg_bytes=" + format_number(ctx.scan.stats.records.register_bytes));
    line3.push_back("byte_entries=" + format_number(ctx.scan.stats.register_bytes_entries));
    line3.push_back("byte_data=" + format_bytes(ctx.scan.stats.register_bytes_data));
    print_kv_line(line3);
  }
}

void render_memory_section(const summary_context& ctx) {
  std::cout << k_indent1 << "memory\n";

  uint64_t total = 0;
  for (const auto& region : ctx.scan.context.memory_map) {
    total += region.size;
  }
  std::vector<std::string> line;
  line.push_back("regions=" + format_number(ctx.scan.context.memory_map.size()));
  push_if(line, total != 0, "total=" + format_bytes(total));
  push_if(
      line, !ctx.scan.context.memory_map.empty(), "perms=" + format_permissions_summary(ctx.scan.context.memory_map)
  );
  print_kv_line(line);

  if (!ctx.options.full) {
    return;
  }

  std::vector<std::string> line2;
  line2.push_back("access=" + format_number(ctx.scan.stats.records.memory_access));
  line2.push_back("reads=" + format_number(ctx.scan.stats.memory_access_reads));
  line2.push_back("writes=" + format_number(ctx.scan.stats.memory_access_writes));
  line2.push_back("known=" + format_number(ctx.scan.stats.memory_access_known));
  line2.push_back("trunc=" + format_number(ctx.scan.stats.memory_access_truncated));
  line2.push_back("bytes=" + format_bytes(ctx.scan.stats.memory_access_bytes));
  if (ctx.scan.stats.records.memory_access != 0) {
    line2.push_back("mapped=" + format_number(ctx.scan.stats.memory_mapped));
    line2.push_back("unmapped=" + format_number(ctx.scan.stats.memory_unmapped));
  }
  line2.push_back("snapshots=" + format_number(ctx.scan.stats.records.snapshot));
  push_if(
      line2, ctx.scan.stats.snapshot_stack_bytes != 0,
      "stack_bytes=" + format_bytes(ctx.scan.stats.snapshot_stack_bytes)
  );
  push_if(
      line2, ctx.scan.stats.snapshot_register_entries != 0,
      "snapshot_regs=" + format_number(ctx.scan.stats.snapshot_register_entries)
  );
  print_kv_line(line2);
}

void render_records_section(const summary_context& ctx) {
  if (!ctx.options.full) {
    return;
  }

  std::cout << k_indent1 << "records\n";

  std::vector<std::string> line;
  line.push_back("total=" + format_number(ctx.scan.stats.records.total));
  line.push_back("instruction=" + format_number(ctx.scan.stats.records.instruction));
  line.push_back("block_exec=" + format_number(ctx.scan.stats.records.block_exec));
  line.push_back("register_deltas=" + format_number(ctx.scan.stats.records.register_deltas));
  line.push_back("register_bytes=" + format_number(ctx.scan.stats.records.register_bytes));
  line.push_back("memory_access=" + format_number(ctx.scan.stats.records.memory_access));
  line.push_back("snapshot=" + format_number(ctx.scan.stats.records.snapshot));
  print_kv_line(line);

  std::vector<std::string> line2;
  line2.push_back("module_table=" + format_number(ctx.scan.stats.records.module_table));
  line2.push_back("module_load=" + format_number(ctx.scan.stats.records.module_load));
  line2.push_back("module_unload=" + format_number(ctx.scan.stats.records.module_unload));
  line2.push_back("memory_map=" + format_number(ctx.scan.stats.records.memory_map));
  line2.push_back("thread_start=" + format_number(ctx.scan.stats.records.thread_start));
  line2.push_back("thread_end=" + format_number(ctx.scan.stats.records.thread_end));
  print_kv_line(line2);

  std::vector<std::string> line3;
  line3.push_back("target_info=" + format_number(ctx.scan.stats.records.target_info));
  line3.push_back("target_env=" + format_number(ctx.scan.stats.records.target_environment));
  line3.push_back("register_spec=" + format_number(ctx.scan.stats.records.register_spec));
  line3.push_back("block_def=" + format_number(ctx.scan.stats.records.block_definition));
  print_kv_line(line3);
}

void render_environment_section(const summary_context& ctx) {
  std::cout << k_indent1 << "environment\n";

  bool wrote_any = false;
  if (ctx.scan.context.target_info.has_value()) {
    const auto& info = ctx.scan.context.target_info.value();
    std::vector<std::string> line;
    push_if(line, !info.os.empty(), "os=" + info.os);
    push_if(line, !info.abi.empty(), "abi=" + info.abi);
    push_if(line, !info.cpu.empty(), "cpu=" + info.cpu);
    print_kv_line(line);
    wrote_any = wrote_any || !line.empty();
  }

  if (ctx.scan.context.target_environment.has_value()) {
    const auto& env = ctx.scan.context.target_environment.value();
    std::vector<std::string> line;
    push_if(line, !env.os_version.empty(), "os_version=" + env.os_version);
    push_if(line, !env.os_build.empty(), "os_build=" + env.os_build);
    push_if(line, !env.os_kernel.empty(), "kernel=" + env.os_kernel);
    push_if(line, !env.hostname.empty(), "host=" + env.hostname);
    push_if(line, env.pid != 0, "pid=" + format_number(env.pid));
    push_if(line, env.addressing_bits != 0, "addr_bits=" + format_number(env.addressing_bits));
    push_if(line, env.low_mem_addressing_bits != 0, "low_addr_bits=" + format_number(env.low_mem_addressing_bits));
    push_if(line, env.high_mem_addressing_bits != 0, "high_addr_bits=" + format_number(env.high_mem_addressing_bits));
    print_kv_line(line);
    wrote_any = wrote_any || !line.empty();
  }

  if (!wrote_any) {
    std::cout << k_indent2 << "none\n";
  }
}

void render_warnings_section(const summary_context& ctx) {
  std::cout << k_indent1 << "warnings\n";
  if (ctx.warnings.empty()) {
    std::cout << k_indent2 << "none\n";
    return;
  }
  for (const auto& warning : ctx.warnings) {
    std::cout << k_indent2 << warning << "\n";
  }
}

} // namespace summary_detail

int summary(const summary_options& options) {
  using namespace summary_detail;

  auto log = redlog::get_logger("w1replay.summary");

  if (options.trace_path.empty()) {
    log.err("trace path required");
    std::cerr << "error: --trace is required" << std::endl;
    return 1;
  }

  scan_result scan;
  std::string error;
  trace_scanner scanner(options.full);
  if (!scanner.scan(options.trace_path, scan, error)) {
    log.err("failed to scan trace", redlog::field("error", error));
    std::cerr << "error: " << error << std::endl;
    return 1;
  }

  std::error_code size_ec;
  uint64_t file_size = static_cast<uint64_t>(std::filesystem::file_size(options.trace_path, size_ec));
  bool has_file_size = !size_ec;

  index_info index = load_index_info(options.trace_path, options.index_path, options.full);
  checkpoint_info checkpoint;
  load_checkpoint_info(options.trace_path, options.checkpoint_path, checkpoint);

  std::vector<std::string> warnings = build_warnings(scan, index, checkpoint);

  summary_context ctx{options, scan, index, checkpoint, warnings};

  std::cout << "summary\n";
  render_trace_section(ctx, file_size, has_file_size);
  render_index_section(ctx);
  render_checkpoint_section(ctx);
  render_flow_section(ctx);
  render_threads_section(ctx);
  render_modules_section(ctx);
  render_state_section(ctx);
  render_memory_section(ctx);
  render_records_section(ctx);
  render_environment_section(ctx);
  render_warnings_section(ctx);

  return 0;
}

} // namespace w1replay::commands

```

`src/w1replay/cli/commands/summary.hpp`:

```hpp
#pragma once

#include <string>

namespace w1replay::commands {

struct summary_options {
  std::string trace_path;
  std::string index_path;
  std::string checkpoint_path;
  bool full = false;
};

int summary(const summary_options& options);

} // namespace w1replay::commands

```

`src/w1replay/cli/commands/threads.cpp`:

```cpp
#include "threads.hpp"

#include <iostream>
#include <vector>

#include <redlog.hpp>

#include "w1rewind/replay/replay_context.hpp"

namespace w1replay::commands {

int threads(const threads_options& options) {
  auto log = redlog::get_logger("w1replay.threads");

  if (options.trace_path.empty()) {
    log.err("trace path required");
    std::cerr << "error: --trace is required" << std::endl;
    return 1;
  }

  w1::rewind::replay_context context;
  std::string error;
  if (!w1::rewind::load_replay_context(options.trace_path, context, error)) {
    log.err("failed to load trace metadata", redlog::field("error", error));
    std::cerr << "error: " << error << std::endl;
    return 1;
  }

  if (context.threads.empty()) {
    std::cout << "no thread records found" << std::endl;
    return 0;
  }

  for (const auto& info : context.threads) {
    std::cout << "thread=" << info.thread_id;
    if (!info.name.empty()) {
      std::cout << " name=" << info.name;
    } else {
      std::cout << " name=unknown";
    }
    std::cout << " started=" << (info.started ? "true" : "false") << " ended=" << (info.ended ? "true" : "false")
              << std::endl;
  }

  return 0;
}

} // namespace w1replay::commands

```

`src/w1replay/cli/commands/threads.hpp`:

```hpp
#pragma once

#include <string>

namespace w1replay::commands {

struct threads_options {
  std::string trace_path;
};

int threads(const threads_options& options);

} // namespace w1replay::commands

```

`src/w1replay/cli/main.cpp`:

```cpp
#include <exception>
#include <iostream>
#include <string>

#include <redlog.hpp>
#include "w1base/ext/args.hpp"

#include "w1base/cli/verbosity.hpp"

#include "w1replay/cli/commands/checkpoint.hpp"
#include "w1replay/cli/commands/inspect.hpp"
#include "w1replay/cli/commands/server.hpp"
#include "w1replay/cli/commands/summary.hpp"
#include "w1replay/cli/commands/threads.hpp"

namespace cli {
args::Group arguments("arguments");
args::HelpFlag help_flag(arguments, "help", "help", {'h', "help"});
args::CounterFlag verbosity_flag(arguments, "verbosity", "verbosity level", {'v'});

void apply_verbosity() { w1::cli::apply_verbosity(args::get(verbosity_flag)); }
} // namespace cli

namespace {
auto log_main = redlog::get_logger("w1replay");
int g_exit_code = 0;
} // namespace

void cmd_inspect(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> trace_flag(parser, "path", "path to trace file", {'t', "trace"});
  args::ValueFlag<std::string> index_flag(parser, "path", "path to index file", {'i', "index"});
  args::ValueFlag<uint64_t> thread_flag(parser, "thread", "thread id", {'T', "thread"});
  args::ValueFlag<uint64_t> start_flag(parser, "sequence", "start sequence", {'s', "start"});
  args::ValueFlag<uint32_t> count_flag(parser, "count", "number of steps", {'n', "count"});
  args::ValueFlag<uint32_t> history_flag(parser, "size", "history size", {"history"});
  args::Flag reverse_flag(parser, "reverse", "step backward", {"reverse"});
  args::Flag inst_flag(parser, "inst", "step instructions (decode block traces)", {"inst"});
  args::Flag regs_flag(parser, "regs", "show register state", {"regs"});
  args::ValueFlag<std::string> mem_flag(
      parser, "range", "show memory bytes at addr:size (example: 0x1000:32)", {"mem"}
  );
  args::ValueFlagList<std::string> module_flag(parser, "mapping", "module mapping name=path (repeatable)", {"module"});
  args::ValueFlagList<std::string> module_dir_flag(
      parser, "dir", "module search directory (repeatable)", {"module-dir"}
  );
  args::ValueFlag<std::string> checkpoint_flag(parser, "path", "path to replay checkpoint file", {"checkpoint"});
  parser.Parse();

  if (!trace_flag) {
    log_main.err("trace path required");
    std::cerr << "error: --trace is required" << std::endl;
    g_exit_code = 1;
    return;
  }
  if (!thread_flag) {
    log_main.err("thread id required");
    std::cerr << "error: --thread is required" << std::endl;
    g_exit_code = 1;
    return;
  }

  w1replay::commands::inspect_options options;
  options.trace_path = *trace_flag;
  options.index_path = index_flag ? *index_flag : "";
  options.thread_id = *thread_flag;
  options.start_sequence = start_flag ? *start_flag : 0;
  options.count = count_flag ? *count_flag : 10;
  options.history_size = history_flag ? *history_flag : 1024;
  options.reverse = reverse_flag;
  options.instruction_steps = inst_flag;
  options.show_registers = regs_flag;
  options.memory_range = mem_flag ? *mem_flag : "";
  options.checkpoint_path = checkpoint_flag ? *checkpoint_flag : "";
  if (module_flag) {
    options.module_mappings = args::get(module_flag);
  }
  if (module_dir_flag) {
    options.module_dirs = args::get(module_dir_flag);
  }

  g_exit_code = w1replay::commands::inspect(options);
}

void cmd_threads(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> trace_flag(parser, "path", "path to trace file", {'t', "trace"});
  parser.Parse();

  if (!trace_flag) {
    log_main.err("trace path required");
    std::cerr << "error: --trace is required" << std::endl;
    g_exit_code = 1;
    return;
  }

  w1replay::commands::threads_options options;
  options.trace_path = *trace_flag;

  g_exit_code = w1replay::commands::threads(options);
}

void cmd_summary(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> trace_flag(parser, "path", "path to trace file", {'t', "trace"});
  args::ValueFlag<std::string> index_flag(parser, "path", "path to index file", {'i', "index"});
  args::ValueFlag<std::string> checkpoint_flag(parser, "path", "path to replay checkpoint file", {"checkpoint"});
  args::Flag full_flag(parser, "full", "scan full trace details", {'f', "full"});
  parser.Parse();

  if (!trace_flag) {
    log_main.err("trace path required");
    std::cerr << "error: --trace is required" << std::endl;
    g_exit_code = 1;
    return;
  }

  w1replay::commands::summary_options options;
  options.trace_path = *trace_flag;
  options.index_path = index_flag ? *index_flag : "";
  options.checkpoint_path = checkpoint_flag ? *checkpoint_flag : "";
  options.full = full_flag;

  g_exit_code = w1replay::commands::summary(options);
}

void cmd_checkpoint(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> trace_flag(parser, "path", "path to trace file", {'t', "trace"});
  args::ValueFlag<std::string> output_flag(parser, "path", "output checkpoint path", {'o', "output"});
  args::ValueFlag<uint32_t> stride_flag(parser, "count", "checkpoint stride (flow records)", {"stride"});
  args::ValueFlag<uint64_t> thread_flag(parser, "thread", "thread id (default: all)", {'T', "thread"});
  args::Flag mem_flag(parser, "memory", "include memory bytes in checkpoints", {"mem"});
  parser.Parse();

  if (!trace_flag) {
    log_main.err("trace path required");
    std::cerr << "error: --trace is required" << std::endl;
    g_exit_code = 1;
    return;
  }

  w1replay::commands::checkpoint_options options;
  options.trace_path = *trace_flag;
  options.output_path = output_flag ? *output_flag : "";
  options.stride = stride_flag ? *stride_flag : 50000;
  options.thread_id = thread_flag ? *thread_flag : 0;
  options.include_memory = mem_flag;

  g_exit_code = w1replay::commands::checkpoint(options);
}

void cmd_server(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> trace_flag(parser, "path", "path to trace file", {'t', "trace"});
  args::ValueFlag<std::string> index_flag(parser, "path", "path to index file", {'i', "index"});
  args::ValueFlag<std::string> checkpoint_flag(parser, "path", "path to replay checkpoint file", {"checkpoint"});
  args::ValueFlag<std::string> gdb_flag(parser, "addr", "gdb listen address", {"gdb"});
  args::ValueFlag<uint64_t> thread_flag(parser, "thread", "thread id", {'T', "thread"});
  args::ValueFlag<uint64_t> start_flag(parser, "sequence", "start sequence", {'s', "start"});
  args::Flag inst_flag(parser, "inst", "prefer instruction steps when possible", {"inst"});
  args::ValueFlagList<std::string> module_flag(parser, "mapping", "module mapping name=path (repeatable)", {"module"});
  args::ValueFlagList<std::string> module_dir_flag(
      parser, "dir", "module search directory (repeatable)", {"module-dir"}
  );
  parser.Parse();

  if (!trace_flag) {
    log_main.err("trace path required");
    std::cerr << "error: --trace is required" << std::endl;
    g_exit_code = 1;
    return;
  }

  w1replay::commands::server_options options;
  options.trace_path = *trace_flag;
  options.index_path = index_flag ? *index_flag : "";
  options.checkpoint_path = checkpoint_flag ? *checkpoint_flag : "";
  options.gdb_listen = gdb_flag ? *gdb_flag : "";
  options.thread_id = thread_flag ? *thread_flag : 0;
  options.start_sequence = start_flag ? *start_flag : 0;
  options.instruction_steps = inst_flag;
  if (module_flag) {
    options.module_mappings = args::get(module_flag);
  }
  if (module_dir_flag) {
    options.module_dirs = args::get(module_dir_flag);
  }

  g_exit_code = w1replay::commands::server(options);
}

int main(int argc, char* argv[]) {
  args::ArgumentParser parser("w1replay - rewind trace explorer", "inspect and replay rewind traces");
  parser.helpParams.showTerminator = false;

  args::GlobalOptions globals(parser, cli::arguments);
  args::Group commands(parser, "commands");

  args::Command inspect_cmd(commands, "inspect", "inspect a rewind trace", &cmd_inspect);
  args::Command threads_cmd(commands, "threads", "list threads in a rewind trace", &cmd_threads);
  args::Command summary_cmd(commands, "summary", "summarize a rewind trace", &cmd_summary);
  args::Command checkpoint_cmd(commands, "checkpoint", "build a replay checkpoint file", &cmd_checkpoint);
  args::Command server_cmd(commands, "server", "run gdbstub server for a rewind trace", &cmd_server);

  try {
    parser.ParseCLI(argc, argv);
  } catch (args::Help) {
    std::cout << parser;
    return 0;
  } catch (args::Error& e) {
    std::cerr << e.what() << std::endl << parser;
    return 1;
  }

  return g_exit_code;
}

```

`src/w1replay/gdb/adapter.cpp`:

```cpp
#include "adapter.hpp"

#include "w1replay/modules/asmr_block_decoder.hpp"
#include "w1replay/modules/lief_module_provider.hpp"
#include "w1replay/memory/memory_view.hpp"
#include "target_xml.hpp"
#include "loaded_libraries_provider.hpp"
#include "w1replay/trace_loader/trace_loader.hpp"

namespace w1replay::gdb {

adapter::adapter(config config) : config_(std::move(config)) {}

adapter::~adapter() = default;

bool adapter::open() {
  error_.clear();
  context_ = w1::rewind::replay_context{};
  stream_.reset();
  index_.reset();
  checkpoint_.reset();
  session_.reset();
  layout_ = register_layout{};
  target_xml_.clear();
  arch_spec_ = gdbstub::arch_spec{};
  pc_reg_num_ = -1;
  target_endian_ = endian::little;
  trace_is_block_ = false;
  decoder_available_ = false;
  track_memory_ = false;
  has_stack_snapshot_ = false;
  breakpoints_ = breakpoint_store{};
  decoder_.reset();
  module_resolver_.reset();
  module_image_reader_.reset();
  module_metadata_provider_.reset();
  memory_view_.reset();
  loaded_libraries_provider_.reset();
  module_index_.reset();
  services_ = adapter_services{};
  thread_state_ = thread_state{};
  module_resolver_ = make_module_path_resolver(config_.module_mappings, config_.module_dirs);

  if (!load_context()) {
    return false;
  }
  module_index_ = std::make_unique<module_address_index>(context_);

  w1replay::lief_module_provider_config provider_config{};
  provider_config.resolver = module_resolver_.get();
  provider_config.address_index = module_index_.get();
  provider_config.address_reader = config_.module_reader;
  auto provider = std::make_shared<w1replay::lief_module_provider>(std::move(provider_config));
  module_image_reader_ = provider;
  module_metadata_provider_ = provider;

  if (!open_session()) {
    return false;
  }
  if (!prime_position()) {
    return false;
  }
  if (!build_layout()) {
    return false;
  }
  if (!build_target_xml()) {
    return false;
  }
  if (!build_arch_spec()) {
    return false;
  }

  services_.session = session_ ? &*session_ : nullptr;
  services_.context = &context_;
  services_.layout = &layout_;
  services_.arch_spec = &arch_spec_;
  services_.module_resolver = module_resolver_.get();
  services_.module_reader = module_image_reader_.get();
  services_.module_metadata = module_metadata_provider_.get();
  services_.module_index = module_index_.get();
  services_.memory = memory_view_.get();
  services_.breakpoints = &breakpoints_;
  services_.target_endian = target_endian_;
  services_.track_memory = track_memory_;
  services_.run_policy.trace_is_block = trace_is_block_;
  services_.run_policy.decoder_available = decoder_available_;
  services_.run_policy.prefer_instruction_steps = config_.prefer_instruction_steps;

  regs_component_ = std::make_unique<regs_component>(services_);
  mem_component_ = std::make_unique<mem_component>(services_);
  run_component_ = std::make_unique<run_component>(services_, thread_state_);
  breakpoints_component_ = std::make_unique<breakpoints_component>(services_);
  threads_component_ = std::make_unique<threads_component>(services_, thread_state_);
  host_info_component_ = std::make_unique<host_info_component>(services_);
  memory_layout_component_ = std::make_unique<memory_layout_component>(services_);
  loaded_libraries_component_.reset();
  libraries_component_ = std::make_unique<libraries_component>(services_);
  if (module_metadata_provider_ && module_resolver_) {
    loaded_libraries_provider_ =
        make_loaded_libraries_provider(context_, *module_metadata_provider_, *module_resolver_);
  }
  if (loaded_libraries_provider_ && !loaded_libraries_provider_->has_loaded_images()) {
    loaded_libraries_provider_.reset();
  }
  services_.loaded_libraries = loaded_libraries_provider_.get();
  if (loaded_libraries_provider_) {
    loaded_libraries_component_ = std::make_unique<loaded_libraries_component>(services_);
  }
  process_info_component_ = std::make_unique<process_info_component>(services_);
  auxv_component_ = std::make_unique<auxv_component>(services_);
  if (!auxv_component_->auxv_data()) {
    auxv_component_.reset();
  }
  offsets_component_ = std::make_unique<offsets_component>(services_);
  register_info_component_ = std::make_unique<register_info_component>(services_);

  return true;
}

gdbstub::target adapter::make_target() {
  if (loaded_libraries_component_) {
    if (auxv_component_) {
      return gdbstub::make_target(
          *regs_component_, *mem_component_, *run_component_, *breakpoints_component_, *threads_component_,
          *host_info_component_, *memory_layout_component_, *libraries_component_, *loaded_libraries_component_,
          *process_info_component_, *auxv_component_, *offsets_component_, *register_info_component_
      );
    }
    return gdbstub::make_target(
        *regs_component_, *mem_component_, *run_component_, *breakpoints_component_, *threads_component_,
        *host_info_component_, *memory_layout_component_, *libraries_component_, *loaded_libraries_component_,
        *process_info_component_, *offsets_component_, *register_info_component_
    );
  }
  if (auxv_component_) {
    return gdbstub::make_target(
        *regs_component_, *mem_component_, *run_component_, *breakpoints_component_, *threads_component_,
        *host_info_component_, *memory_layout_component_, *libraries_component_, *process_info_component_,
        *auxv_component_, *offsets_component_, *register_info_component_
    );
  }
  return gdbstub::make_target(
      *regs_component_, *mem_component_, *run_component_, *breakpoints_component_, *threads_component_,
      *host_info_component_, *memory_layout_component_, *libraries_component_, *process_info_component_,
      *offsets_component_, *register_info_component_
  );
}

const w1::rewind::replay_session& adapter::session() const { return *session_; }

w1::rewind::replay_session& adapter::session() { return *session_; }

bool adapter::load_context() {
  if (config_.trace_path.empty()) {
    error_ = "trace path required";
    return false;
  }

  w1replay::trace_loader::trace_load_options load_options{};
  load_options.trace_path = config_.trace_path;
  load_options.index_path = config_.index_path;
  load_options.checkpoint_path = config_.checkpoint_path;
  load_options.auto_build_checkpoint = false;

  w1replay::trace_loader::trace_load_result load_result;
  if (!w1replay::trace_loader::load_trace(load_options, load_result)) {
    error_ = load_result.error;
    return false;
  }

  context_ = std::move(load_result.context);
  stream_ = std::move(load_result.stream);
  index_ = std::move(load_result.index);
  checkpoint_ = std::move(load_result.checkpoint);

  if (context_.threads.empty()) {
    error_ = "trace has no thread records";
    return false;
  }

  if (config_.thread_id != 0) {
    thread_state_.active_thread_id = config_.thread_id;
    bool found = false;
    for (const auto& info : context_.threads) {
      if (info.thread_id == thread_state_.active_thread_id) {
        found = true;
        break;
      }
    }
    if (!found) {
      error_ = "thread id not found";
      return false;
    }
  } else {
    thread_state_.active_thread_id = context_.threads.front().thread_id;
  }

  auto features = context_.features();
  trace_is_block_ = features.has_blocks;
  track_memory_ = features.track_memory;
  has_stack_snapshot_ = features.has_stack_snapshot;
  switch (context_.header.arch.arch_byte_order) {
  case w1::arch::byte_order::big:
    target_endian_ = endian::big;
    break;
  case w1::arch::byte_order::little:
  case w1::arch::byte_order::unknown:
  default:
    target_endian_ = endian::little;
    break;
  }

  return true;
}

bool adapter::open_session() {
  if (asmr_decoder_available()) {
    decoder_ = std::make_unique<w1replay::asmr_block_decoder>();
  }
  decoder_available_ = decoder_ != nullptr;

  bool has_registers = context_.features().has_registers;

  if (!stream_ || !index_) {
    error_ = "trace loader not ready";
    return false;
  }

  w1::rewind::replay_session_config config{};
  config.stream = stream_;
  config.index = index_;
  config.checkpoint = checkpoint_;
  config.context = context_;
  config.thread_id = thread_state_.active_thread_id;
  config.start_sequence = config_.start_sequence;
  config.track_registers = has_registers;
  config.track_memory = track_memory_;
  if (decoder_) {
    config.block_decoder = decoder_.get();
  }

  session_.emplace(config);
  if (!session_->open()) {
    error_ = session_->error();
    return false;
  }

  memory_view_ =
      std::make_unique<w1replay::replay_memory_view>(&context_, session_->state(), module_image_reader_.get());
  if (decoder_ && memory_view_) {
    decoder_->set_memory_view(memory_view_.get());
  }

  return true;
}

bool adapter::prime_position() {
  if (!session_) {
    error_ = "session not ready";
    return false;
  }
  if (!session_->step_instruction()) {
    auto kind = session_->error_kind();
    if (kind == w1::rewind::replay_session::replay_error_kind::begin_of_trace ||
        kind == w1::rewind::replay_session::replay_error_kind::end_of_trace) {
      error_ = "trace has no flow records";
    } else {
      error_ = session_->error();
    }
    return false;
  }
  return true;
}

bool adapter::build_layout() {
  layout_ = build_register_layout(context_.header.arch, context_.register_specs);
  if (layout_.architecture.empty() || layout_.registers.empty()) {
    error_ = "unsupported trace architecture";
    return false;
  }
  if (layout_.pc_reg_num < 0) {
    error_ = "pc register missing";
    return false;
  }
  pc_reg_num_ = layout_.pc_reg_num;
  return true;
}

bool adapter::build_target_xml() {
  target_xml_ = ::w1replay::gdb::build_target_xml(layout_);
  if (target_xml_.empty()) {
    error_ = "failed to build target xml";
    return false;
  }
  return true;
}

bool adapter::build_arch_spec() {
  arch_spec_ = gdbstub::arch_spec{};
  arch_spec_.target_xml = target_xml_;
  if (!layout_.feature_name.empty()) {
    arch_spec_.xml_arch_name = layout_.feature_name;
  } else {
    arch_spec_.xml_arch_name = "org.w1tn3ss.rewind";
  }
  arch_spec_.osabi.clear();
  arch_spec_.reg_count = static_cast<int>(layout_.registers.size());
  arch_spec_.pc_reg_num = pc_reg_num_;
  arch_spec_.address_bits = static_cast<int>(context_.header.arch.pointer_bits);
  arch_spec_.swap_register_endianness = false;
  return true;
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/adapter.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <memory>
#include <string>
#include <vector>

#include "gdbstub/server/server.hpp"
#include "gdbstub/target/target.hpp"

#include "adapter_components.hpp"
#include "adapter_services.hpp"
#include "thread_state.hpp"
#include "w1replay/modules/image_reader.hpp"
#include "w1replay/modules/address_index.hpp"

namespace w1replay {
class asmr_block_decoder;
}

namespace w1replay::gdb {

class adapter {
public:
  struct config {
    std::string trace_path;
    std::string index_path;
    std::string checkpoint_path;
    uint64_t thread_id = 0;
    uint64_t start_sequence = 0;
    bool prefer_instruction_steps = false;
    std::vector<std::string> module_mappings;
    std::vector<std::string> module_dirs;
    module_address_reader module_reader;
  };

  explicit adapter(config config);
  ~adapter();

  bool open();
  const std::string& error() const { return error_; }

  gdbstub::target make_target();
  const gdbstub::arch_spec& arch_spec() const { return arch_spec_; }
  bool track_memory() const { return track_memory_; }
  bool has_stack_snapshot() const { return has_stack_snapshot_; }

  const w1::rewind::replay_session& session() const;
  w1::rewind::replay_session& session();

private:
  bool load_context();
  bool open_session();
  bool prime_position();
  bool build_layout();
  bool build_arch_spec();
  bool build_target_xml();

  config config_;
  std::string error_;
  w1::rewind::replay_context context_{};
  std::shared_ptr<w1::rewind::trace_record_stream> stream_;
  std::shared_ptr<w1::rewind::trace_index> index_;
  std::shared_ptr<w1::rewind::replay_checkpoint_index> checkpoint_;
  std::optional<w1::rewind::replay_session> session_;
  register_layout layout_{};
  std::string target_xml_;
  gdbstub::arch_spec arch_spec_{};
  int pc_reg_num_ = -1;
  endian target_endian_ = endian::little;
  bool trace_is_block_ = false;
  bool decoder_available_ = false;
  bool track_memory_ = false;
  bool has_stack_snapshot_ = false;
  breakpoint_store breakpoints_{};
  std::unique_ptr<w1replay::asmr_block_decoder> decoder_;
  std::unique_ptr<module_path_resolver> module_resolver_;
  std::shared_ptr<module_image_reader> module_image_reader_;
  std::shared_ptr<module_metadata_provider> module_metadata_provider_;
  std::unique_ptr<memory_view> memory_view_;
  std::unique_ptr<loaded_libraries_provider> loaded_libraries_provider_;
  std::unique_ptr<module_address_index> module_index_;
  adapter_services services_{};
  thread_state thread_state_{};

  std::unique_ptr<regs_component> regs_component_;
  std::unique_ptr<mem_component> mem_component_;
  std::unique_ptr<run_component> run_component_;
  std::unique_ptr<breakpoints_component> breakpoints_component_;
  std::unique_ptr<threads_component> threads_component_;
  std::unique_ptr<host_info_component> host_info_component_;
  std::unique_ptr<memory_layout_component> memory_layout_component_;
  std::unique_ptr<libraries_component> libraries_component_;
  std::unique_ptr<loaded_libraries_component> loaded_libraries_component_;
  std::unique_ptr<process_info_component> process_info_component_;
  std::unique_ptr<auxv_component> auxv_component_;
  std::unique_ptr<offsets_component> offsets_component_;
  std::unique_ptr<register_info_component> register_info_component_;
};

} // namespace w1replay::gdb

```

`src/w1replay/gdb/adapter_components.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <optional>
#include <span>
#include <string>
#include <vector>

#include "gdbstub/target/target.hpp"

#include "adapter_services.hpp"
#include "thread_state.hpp"

namespace w1replay::gdb {

class regs_component {
public:
  explicit regs_component(const adapter_services& services);

  size_t reg_size(int regno) const;
  gdbstub::target_status read_reg(int regno, std::span<std::byte> out);
  gdbstub::target_status write_reg(int regno, std::span<const std::byte> data);

private:
  const adapter_services& services_;
};

class mem_component {
public:
  explicit mem_component(const adapter_services& services);

  gdbstub::target_status read_mem(uint64_t addr, std::span<std::byte> out);
  gdbstub::target_status write_mem(uint64_t addr, std::span<const std::byte> data);

private:
  const adapter_services& services_;
};

class run_component {
public:
  run_component(const adapter_services& services, thread_state& thread);

  gdbstub::run_capabilities capabilities() const;
  gdbstub::resume_result resume(const gdbstub::resume_request& request);

private:
  const adapter_services& services_;
  thread_state& thread_;
};

class breakpoints_component {
public:
  explicit breakpoints_component(const adapter_services& services);

  gdbstub::target_status set_breakpoint(const gdbstub::breakpoint_request& request);
  gdbstub::target_status remove_breakpoint(const gdbstub::breakpoint_request& request);

private:
  const adapter_services& services_;
};

class threads_component {
public:
  threads_component(const adapter_services& services, thread_state& thread);

  std::vector<uint64_t> thread_ids() const;
  uint64_t current_thread() const;
  gdbstub::target_status set_current_thread(uint64_t tid);
  std::optional<uint64_t> thread_pc(uint64_t tid) const;
  std::optional<std::string> thread_name(uint64_t tid) const;
  std::optional<gdbstub::stop_reason> thread_stop_reason(uint64_t tid) const;

private:
  const adapter_services& services_;
  thread_state& thread_;
};

class host_info_component {
public:
  explicit host_info_component(const adapter_services& services);

  std::optional<gdbstub::host_info> get_host_info() const;

private:
  const adapter_services& services_;
};

class memory_layout_component {
public:
  explicit memory_layout_component(const adapter_services& services);

  std::vector<gdbstub::memory_region> memory_map() const;

private:
  const adapter_services& services_;
};

class libraries_component {
public:
  explicit libraries_component(const adapter_services& services);

  std::vector<gdbstub::library_entry> libraries() const;
  std::optional<uint64_t> libraries_generation() const;

private:
  std::optional<uint64_t> resolve_main_module_id() const;

  const adapter_services& services_;
  mutable std::optional<uint64_t> main_module_id_;
};

class loaded_libraries_component {
public:
  explicit loaded_libraries_component(const adapter_services& services);

  std::optional<std::string> loaded_libraries_json(const gdbstub::lldb::loaded_libraries_request& request);
  std::optional<std::vector<gdbstub::lldb::process_kv_pair>> process_info_extras() const;
  bool has_loaded_images() const;

private:
  const adapter_services& services_;
};

class process_info_component {
public:
  explicit process_info_component(const adapter_services& services);

  std::optional<gdbstub::process_info> get_process_info() const;

private:
  const adapter_services& services_;
};

class auxv_component {
public:
  explicit auxv_component(const adapter_services& services);

  std::optional<std::vector<std::byte>> auxv_data() const;

private:
  std::optional<std::vector<std::byte>> build_auxv() const;

  const adapter_services& services_;
  mutable bool auxv_cached_ = false;
  mutable std::optional<std::vector<std::byte>> auxv_data_;
};

class offsets_component {
public:
  explicit offsets_component(const adapter_services& services);

  std::optional<gdbstub::offsets_info> get_offsets_info() const;

private:
  const adapter_services& services_;
};

class register_info_component {
public:
  explicit register_info_component(const adapter_services& services);

  std::optional<gdbstub::register_info> get_register_info(int regno) const;

private:
  const adapter_services& services_;
};

} // namespace w1replay::gdb

```

`src/w1replay/gdb/adapter_services.hpp`:

```hpp
#pragma once

#include <cstdint>

namespace gdbstub {
struct arch_spec;
}

#include "breakpoint_store.hpp"
#include "run_policy.hpp"
#include "value_codec.hpp"
#include "w1rewind/replay/replay_session.hpp"
#include "w1replay/memory/memory_view.hpp"
#include "w1replay/modules/address_index.hpp"
#include "w1replay/modules/image_reader.hpp"
#include "w1replay/modules/metadata_provider.hpp"
#include "w1replay/modules/path_resolver.hpp"
#include "loaded_libraries_provider.hpp"
#include "layout.hpp"

namespace w1replay::gdb {

struct adapter_services {
  w1::rewind::replay_session* session = nullptr;
  const w1::rewind::replay_context* context = nullptr;
  const register_layout* layout = nullptr;
  const gdbstub::arch_spec* arch_spec = nullptr;
  module_path_resolver* module_resolver = nullptr;
  module_image_reader* module_reader = nullptr;
  module_metadata_provider* module_metadata = nullptr;
  module_address_index* module_index = nullptr;
  memory_view* memory = nullptr;
  loaded_libraries_provider* loaded_libraries = nullptr;
  breakpoint_store* breakpoints = nullptr;
  run_policy run_policy{};
  endian target_endian = endian::little;
  bool track_memory = false;
};

} // namespace w1replay::gdb

```

`src/w1replay/gdb/breakpoint_store.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <unordered_set>

namespace w1replay::gdb {

class breakpoint_store {
public:
  void add(uint64_t address) { breakpoints_.insert(address); }
  void remove(uint64_t address) { breakpoints_.erase(address); }
  bool contains(uint64_t address) const { return breakpoints_.find(address) != breakpoints_.end(); }
  const std::unordered_set<uint64_t>& all() const { return breakpoints_; }

private:
  std::unordered_set<uint64_t> breakpoints_;
};

} // namespace w1replay::gdb

```

`src/w1replay/gdb/components/auxv_component.cpp`:

```cpp
#include "w1replay/gdb/adapter_components.hpp"

#include <limits>
#include "w1rewind/format/trace_format.hpp"

namespace w1replay::gdb {

namespace {

constexpr uint64_t k_auxv_at_null = 0;
constexpr uint64_t k_auxv_at_entry = 9;

bool entry_in_module(const w1::rewind::module_record& module, uint64_t entry) {
  if (module.size == 0) {
    return true;
  }
  if (entry < module.base) {
    return false;
  }
  uint64_t end = module.base + module.size;
  if (end < module.base) {
    return false;
  }
  return entry < end;
}

std::optional<uint64_t> compute_runtime_entrypoint(const w1::rewind::module_record& module) {
  if ((module.flags & w1::rewind::module_record_flag_entry_point_valid) == 0) {
    return std::nullopt;
  }
  if ((module.flags & w1::rewind::module_record_flag_link_base_valid) == 0) {
    return std::nullopt;
  }
  const uint64_t entry = module.entry_point;
  const uint64_t link_base = module.link_base;
  if (entry < link_base) {
    return std::nullopt;
  }
  uint64_t offset = entry - link_base;
  if (module.base > std::numeric_limits<uint64_t>::max() - offset) {
    return std::nullopt;
  }
  uint64_t runtime_entry = module.base + offset;
  if (!entry_in_module(module, runtime_entry)) {
    return std::nullopt;
  }
  return runtime_entry;
}

bool is_elf_file_backed(const w1::rewind::module_record& module) {
  return (module.flags & w1::rewind::module_record_flag_file_backed) != 0 &&
         module.format == w1::rewind::module_format::elf;
}

std::optional<uint64_t> select_entrypoint(const adapter_services& services) {
  if (!services.context) {
    return std::nullopt;
  }

  const auto& modules = services.context->modules;
  for (const auto& module : modules) {
    if ((module.flags & w1::rewind::module_record_flag_main) == 0) {
      continue;
    }
    if (!is_elf_file_backed(module)) {
      return std::nullopt;
    }
    return compute_runtime_entrypoint(module);
  }

  if (services.session && services.module_index) {
    uint64_t pc = services.session->current_step().address;
    auto match = services.module_index->find(pc, 1);
    if (match && match->module && is_elf_file_backed(*match->module)) {
      if (auto entry = compute_runtime_entrypoint(*match->module)) {
        return entry;
      }
    }
  }

  std::optional<uint64_t> best;
  uint64_t best_base = 0;
  for (const auto& module : modules) {
    if (!is_elf_file_backed(module)) {
      continue;
    }
    auto entry = compute_runtime_entrypoint(module);
    if (!entry) {
      continue;
    }
    if (!best || module.base < best_base) {
      best = entry;
      best_base = module.base;
    }
  }

  return best;
}

bool append_auxv_entry(std::vector<std::byte>& out, uint64_t type, uint64_t value, size_t word_size, endian order) {
  size_t offset = out.size();
  out.resize(offset + word_size * 2);
  auto type_span = std::span<std::byte>(out.data() + offset, word_size);
  auto value_span = std::span<std::byte>(out.data() + offset + word_size, word_size);
  if (!encode_uint64(type, word_size, type_span, order)) {
    return false;
  }
  if (!encode_uint64(value, word_size, value_span, order)) {
    return false;
  }
  return true;
}

} // namespace

auxv_component::auxv_component(const adapter_services& services) : services_(services) {}

std::optional<std::vector<std::byte>> auxv_component::auxv_data() const {
  if (auxv_cached_) {
    return auxv_data_;
  }
  auxv_cached_ = true;
  auxv_data_ = build_auxv();
  return auxv_data_;
}

std::optional<std::vector<std::byte>> auxv_component::build_auxv() const {
  if (!services_.context || !services_.context->target_info) {
    return std::nullopt;
  }
  if (services_.context->target_info->os != "linux") {
    return std::nullopt;
  }

  uint32_t pointer_bits = services_.context->header.arch.pointer_bits;
  if (pointer_bits == 0 || pointer_bits % 8 != 0) {
    return std::nullopt;
  }
  size_t word_size = pointer_bits / 8;
  if (word_size == 0 || word_size > sizeof(uint64_t)) {
    return std::nullopt;
  }

  auto entry = select_entrypoint(services_);
  if (!entry) {
    return std::nullopt;
  }

  std::vector<std::byte> auxv;
  auxv.reserve(word_size * 4);
  if (!append_auxv_entry(auxv, k_auxv_at_entry, *entry, word_size, services_.target_endian)) {
    return std::nullopt;
  }
  if (!append_auxv_entry(auxv, k_auxv_at_null, 0, word_size, services_.target_endian)) {
    return std::nullopt;
  }
  return auxv;
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/components/breakpoints_component.cpp`:

```cpp
#include "w1replay/gdb/adapter_components.hpp"

namespace w1replay::gdb {

breakpoints_component::breakpoints_component(const adapter_services& services) : services_(services) {}

gdbstub::target_status breakpoints_component::set_breakpoint(const gdbstub::breakpoint_request& request) {
  if (request.spec.type != gdbstub::breakpoint_type::software &&
      request.spec.type != gdbstub::breakpoint_type::hardware) {
    return gdbstub::target_status::unsupported;
  }
  if (!services_.breakpoints) {
    return gdbstub::target_status::unsupported;
  }
  services_.breakpoints->add(request.spec.addr);
  return gdbstub::target_status::ok;
}

gdbstub::target_status breakpoints_component::remove_breakpoint(const gdbstub::breakpoint_request& request) {
  if (request.spec.type != gdbstub::breakpoint_type::software &&
      request.spec.type != gdbstub::breakpoint_type::hardware) {
    return gdbstub::target_status::unsupported;
  }
  if (!services_.breakpoints) {
    return gdbstub::target_status::unsupported;
  }
  services_.breakpoints->remove(request.spec.addr);
  return gdbstub::target_status::ok;
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/components/host_info_component.cpp`:

```cpp
#include "w1replay/gdb/adapter_components.hpp"

#include "w1replay/gdb/triple_utils.hpp"

namespace w1replay::gdb {

host_info_component::host_info_component(const adapter_services& services) : services_(services) {}

std::optional<gdbstub::host_info> host_info_component::get_host_info() const {
  if (!services_.context) {
    return std::nullopt;
  }
  gdbstub::host_info info{};
  const auto& context = *services_.context;
  const auto* env = context.target_environment ? &*context.target_environment : nullptr;
  std::string os_id;
  std::string abi;
  if (context.target_info) {
    os_id = context.target_info->os;
    abi = context.target_info->abi;
  }
  info.triple = build_process_triple(context.header.arch, os_id, abi);
  info.endian = (services_.target_endian == endian::big) ? "big" : "little";
  info.ptr_size = static_cast<int>(context.header.arch.pointer_bits / 8);
  info.hostname = (env && !env->hostname.empty()) ? env->hostname : "w1replay";
  if (env && env->addressing_bits > 0) {
    info.addressing_bits = static_cast<int>(env->addressing_bits);
  }
  if (env && env->low_mem_addressing_bits > 0) {
    info.low_mem_addressing_bits = static_cast<int>(env->low_mem_addressing_bits);
  }
  if (env && env->high_mem_addressing_bits > 0) {
    info.high_mem_addressing_bits = static_cast<int>(env->high_mem_addressing_bits);
  }
  if (env && !env->os_version.empty()) {
    info.os_version = env->os_version;
  }
  if (env && !env->os_build.empty()) {
    info.os_build = env->os_build;
  }
  if (env && !env->os_kernel.empty()) {
    info.os_kernel = env->os_kernel;
  }
  if (info.ptr_size <= 0 || info.triple.empty()) {
    return std::nullopt;
  }
  return info;
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/components/libraries_component.cpp`:

```cpp
#include "w1replay/gdb/adapter_components.hpp"

namespace w1replay::gdb {

libraries_component::libraries_component(const adapter_services& services) : services_(services) {}

std::optional<uint64_t> libraries_component::resolve_main_module_id() const {
  if (main_module_id_.has_value()) {
    return main_module_id_;
  }
  if (services_.context) {
    for (const auto& module : services_.context->modules) {
      if ((module.flags & w1::rewind::module_record_flag_main) != 0) {
        main_module_id_ = module.id;
        return main_module_id_;
      }
    }
  }
  if (!services_.session || !services_.module_index) {
    return std::nullopt;
  }
  uint64_t pc = services_.session->current_step().address;
  auto match = services_.module_index->find(pc, 1);
  if (!match || !match->module) {
    return std::nullopt;
  }
  const auto& module = *match->module;
  const bool file_backed = (module.flags & w1::rewind::module_record_flag_file_backed) != 0 ||
                           module.format != w1::rewind::module_format::unknown;
  if (!file_backed) {
    return std::nullopt;
  }
  main_module_id_ = module.id;
  return main_module_id_;
}

std::vector<gdbstub::library_entry> libraries_component::libraries() const {
  if (!services_.context) {
    return {};
  }
  const auto& modules = services_.context->modules;
  const auto main_module_id = resolve_main_module_id();
  std::vector<gdbstub::library_entry> out;
  out.reserve(modules.size());
  for (const auto& module : modules) {
    if (main_module_id && module.id == *main_module_id) {
      continue;
    }
    const bool file_backed = (module.flags & w1::rewind::module_record_flag_file_backed) != 0 ||
                             module.format != w1::rewind::module_format::unknown;
    if (!file_backed) {
      continue;
    }
    std::string path = module.path;
    if (path.empty()) {
      continue;
    }
    if (services_.module_resolver) {
      if (auto resolved = services_.module_resolver->resolve_module_path(module)) {
        path = *resolved;
      }
    }
    if (path.empty()) {
      continue;
    }
    out.push_back(gdbstub::library_entry::section(path, {module.base}));
  }
  return out;
}

std::optional<uint64_t> libraries_component::libraries_generation() const {
  if (!services_.context) {
    return std::nullopt;
  }
  const auto& modules = services_.context->modules;
  const auto main_module_id = resolve_main_module_id();
  size_t count = 0;
  for (const auto& module : modules) {
    if (main_module_id && module.id == *main_module_id) {
      continue;
    }
    const bool file_backed = (module.flags & w1::rewind::module_record_flag_file_backed) != 0 ||
                             module.format != w1::rewind::module_format::unknown;
    if (!file_backed) {
      continue;
    }
    if (module.path.empty()) {
      continue;
    }
    ++count;
  }
  return static_cast<uint64_t>(count);
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/components/loaded_libraries_component.cpp`:

```cpp
#include "w1replay/gdb/adapter_components.hpp"

namespace w1replay::gdb {

loaded_libraries_component::loaded_libraries_component(const adapter_services& services) : services_(services) {}

std::optional<std::string> loaded_libraries_component::loaded_libraries_json(
    const gdbstub::lldb::loaded_libraries_request& request
) {
  if (!services_.loaded_libraries) {
    return std::nullopt;
  }
  return services_.loaded_libraries->loaded_libraries_json(request);
}

std::optional<std::vector<gdbstub::lldb::process_kv_pair>> loaded_libraries_component::process_info_extras() const {
  if (!services_.loaded_libraries || !services_.session) {
    return std::nullopt;
  }
  return services_.loaded_libraries->process_info_extras(services_.session->current_step().address);
}

bool loaded_libraries_component::has_loaded_images() const {
  if (!services_.loaded_libraries) {
    return false;
  }
  return services_.loaded_libraries->has_loaded_images();
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/components/mem_component.cpp`:

```cpp
#include "w1replay/gdb/adapter_components.hpp"

#include <algorithm>

#include "w1replay/memory/memory_view.hpp"

namespace w1replay::gdb {

mem_component::mem_component(const adapter_services& services) : services_(services) {}

gdbstub::target_status mem_component::read_mem(uint64_t addr, std::span<std::byte> out) {
  if (!services_.memory) {
    return gdbstub::target_status::unsupported;
  }

  auto read = services_.memory->read(addr, out.size());
  if (read.bytes.size() < out.size()) {
    return gdbstub::target_status::fault;
  }
  std::copy(read.bytes.begin(), read.bytes.begin() + static_cast<std::ptrdiff_t>(out.size()), out.begin());

  if (read.complete() || read.any_known()) {
    // lldb issues aligned reads that can extend beyond recorded snapshot windows
    // return best-effort data when any bytes are known so the debugger keeps the
    // valid portion instead of treating the whole read as unavailable
    return gdbstub::target_status::ok;
  }
  return gdbstub::target_status::unsupported;
}

gdbstub::target_status mem_component::write_mem(uint64_t, std::span<const std::byte>) {
  return gdbstub::target_status::unsupported;
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/components/memory_layout_component.cpp`:

```cpp
#include "w1replay/gdb/adapter_components.hpp"

#include "w1replay/gdb/memory_map.hpp"

namespace w1replay::gdb {

memory_layout_component::memory_layout_component(const adapter_services& services) : services_(services) {}

std::vector<gdbstub::memory_region> memory_layout_component::memory_map() const {
  if (!services_.context) {
    return {};
  }
  const auto* replay_state = (services_.session && services_.track_memory) ? services_.session->state() : nullptr;
  return build_memory_map(
      services_.context->modules, services_.context->memory_map, replay_state, services_.module_resolver
  );
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/components/offsets_component.cpp`:

```cpp
#include "w1replay/gdb/adapter_components.hpp"

namespace w1replay::gdb {

offsets_component::offsets_component(const adapter_services& services) : services_(services) {}

std::optional<gdbstub::offsets_info> offsets_component::get_offsets_info() const {
  if (!services_.session || !services_.context || !services_.module_index) {
    return std::nullopt;
  }

  uint64_t pc = services_.session->current_step().address;
  auto match = services_.module_index->find(pc, 1);
  if (!match.has_value() || !match->module) {
    return std::nullopt;
  }
  const auto& module = *match->module;
  if ((module.flags & w1::rewind::module_record_flag_link_base_valid) == 0) {
    return std::nullopt;
  }
  const uint64_t link_base = module.link_base;
  if (module.base < link_base) {
    return std::nullopt;
  }
  uint64_t slide = module.base - link_base;
  return gdbstub::offsets_info::section(slide, slide, slide);
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/components/process_info_component.cpp`:

```cpp
#include "w1replay/gdb/adapter_components.hpp"

#include "w1replay/gdb/triple_utils.hpp"

namespace w1replay::gdb {

process_info_component::process_info_component(const adapter_services& services) : services_(services) {}

std::optional<gdbstub::process_info> process_info_component::get_process_info() const {
  if (!services_.context) {
    return std::nullopt;
  }
  gdbstub::process_info info{};
  const auto& context = *services_.context;
  const auto* env = context.target_environment ? &*context.target_environment : nullptr;
  std::string os_id;
  std::string abi;
  if (context.target_info) {
    os_id = context.target_info->os;
    abi = context.target_info->abi;
  }
  info.pid = (env && env->pid != 0) ? static_cast<int>(env->pid) : 1;
  info.endian = (services_.target_endian == endian::big) ? "big" : "little";
  info.ptr_size = static_cast<int>(context.header.arch.pointer_bits / 8);
  info.ostype = os_id.empty() ? "unknown" : os_id;
  info.triple = build_process_triple(context.header.arch, os_id, abi);
  if (info.ptr_size <= 0 || info.triple.empty()) {
    return std::nullopt;
  }
  return info;
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/components/register_info_component.cpp`:

```cpp
#include "w1replay/gdb/adapter_components.hpp"

namespace w1replay::gdb {

namespace {
bool is_frame_pointer_name(const std::string& name) {
  return name == "fp" || name == "x29" || name == "rbp" || name == "ebp" || name == "r11" || name == "r7";
}
} // namespace

register_info_component::register_info_component(const adapter_services& services) : services_(services) {}

std::optional<gdbstub::register_info> register_info_component::get_register_info(int regno) const {
  if (!services_.layout) {
    return std::nullopt;
  }
  if (regno < 0 || static_cast<size_t>(regno) >= services_.layout->registers.size()) {
    return std::nullopt;
  }
  const auto& reg = services_.layout->registers[static_cast<size_t>(regno)];
  gdbstub::register_info info{};
  info.name = reg.name;
  info.bitsize = static_cast<int>(reg.bits);
  switch (reg.reg_class) {
  case w1::rewind::register_class::fpr:
    info.encoding = "ieee754";
    info.format = "float";
    info.set = "float";
    break;
  case w1::rewind::register_class::simd:
    info.encoding = "vector";
    info.format = "vector-uint8";
    info.set = "vector";
    break;
  case w1::rewind::register_class::gpr:
  case w1::rewind::register_class::flags:
  case w1::rewind::register_class::system:
  case w1::rewind::register_class::unknown:
  default:
    info.encoding = "uint";
    info.format = "hex";
    info.set = "general";
    break;
  }
  if (reg.is_pc) {
    info.generic = "pc";
  } else if (reg.is_sp) {
    info.generic = "sp";
  } else if (reg.is_flags) {
    info.generic = "flags";
  } else if (is_frame_pointer_name(reg.name)) {
    info.generic = "fp";
  }
  if (reg.dwarf_regnum) {
    info.dwarf_regnum = *reg.dwarf_regnum;
  }
  if (reg.ehframe_regnum) {
    info.gcc_regnum = *reg.ehframe_regnum;
  }
  return info;
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/components/regs_component.cpp`:

```cpp
#include "w1replay/gdb/adapter_components.hpp"

#include "w1replay/gdb/value_codec.hpp"

#include <algorithm>

namespace w1replay::gdb {

regs_component::regs_component(const adapter_services& services) : services_(services) {}

size_t regs_component::reg_size(int regno) const {
  if (!services_.layout) {
    return 0;
  }
  if (regno < 0 || static_cast<size_t>(regno) >= services_.layout->registers.size()) {
    return 0;
  }
  return static_cast<size_t>(services_.layout->registers[static_cast<size_t>(regno)].bits / 8);
}

gdbstub::target_status regs_component::read_reg(int regno, std::span<std::byte> out) {
  if (!services_.layout) {
    return gdbstub::target_status::invalid;
  }
  if (regno < 0 || static_cast<size_t>(regno) >= services_.layout->registers.size()) {
    return gdbstub::target_status::invalid;
  }

  size_t size = reg_size(regno);
  if (size == 0 || out.size() < size) {
    return gdbstub::target_status::invalid;
  }

  auto fill_unknown = [&](std::span<std::byte> buffer) { std::fill(buffer.begin(), buffer.end(), std::byte{0xcc}); };

  const auto& reg = services_.layout->registers[static_cast<size_t>(regno)];
  if (reg.is_pc) {
    if (!services_.session) {
      fill_unknown(out);
      return gdbstub::target_status::ok;
    }
    uint64_t pc = services_.session->current_step().address;
    if (!encode_uint64(pc, size, out, services_.target_endian)) {
      return gdbstub::target_status::invalid;
    }
    return gdbstub::target_status::ok;
  }

  if (!reg.trace_index.has_value()) {
    fill_unknown(out);
    return gdbstub::target_status::ok;
  }
  if (!services_.session) {
    fill_unknown(out);
    return gdbstub::target_status::ok;
  }

  if (reg.value_kind == w1::rewind::register_value_kind::bytes) {
    bool known = false;
    if (!services_.session->read_register_bytes(static_cast<uint16_t>(*reg.trace_index), out, known)) {
      return gdbstub::target_status::invalid;
    }
    if (!known) {
      fill_unknown(out);
    }
    return gdbstub::target_status::ok;
  }

  auto regs = services_.session->read_registers();
  if (*reg.trace_index >= regs.size()) {
    fill_unknown(out);
    return gdbstub::target_status::ok;
  }
  if (!regs[*reg.trace_index].has_value()) {
    fill_unknown(out);
    return gdbstub::target_status::ok;
  }
  if (!encode_uint64(*regs[*reg.trace_index], size, out, services_.target_endian)) {
    return gdbstub::target_status::invalid;
  }
  return gdbstub::target_status::ok;
}

gdbstub::target_status regs_component::write_reg(int, std::span<const std::byte>) {
  return gdbstub::target_status::unsupported;
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/components/run_component.cpp`:

```cpp
#include "w1replay/gdb/adapter_components.hpp"

#include "w1replay/gdb/stepper.hpp"

namespace w1replay::gdb {

run_component::run_component(const adapter_services& services, thread_state& thread)
    : services_(services), thread_(thread) {}

gdbstub::run_capabilities run_component::capabilities() const {
  gdbstub::run_capabilities caps{};
  caps.reverse_step = true;
  caps.reverse_continue = true;
  return caps;
}

gdbstub::resume_result run_component::resume(const gdbstub::resume_request& request) {
  if (!services_.session) {
    gdbstub::resume_result result{};
    result.state = gdbstub::resume_result::state::exited;
    gdbstub::stop_reason stop{};
    stop.kind = gdbstub::stop_kind::exited;
    stop.exit_code = 0;
    if (thread_.active_thread_id != 0) {
      stop.thread_id = thread_.active_thread_id;
    }
    result.stop = stop;
    result.exit_code = 0;
    return result;
  }

  run_policy policy = services_.run_policy;
  static const breakpoint_store empty_breakpoints{};
  const breakpoint_store& breakpoints = services_.breakpoints ? *services_.breakpoints : empty_breakpoints;

  stepper_result result{};
  if (request.action == gdbstub::resume_action::step) {
    result = resume_step(*services_.session, policy, breakpoints, thread_.active_thread_id, request.direction);
  } else if (request.action == gdbstub::resume_action::cont) {
    result = resume_continue(*services_.session, policy, breakpoints, thread_.active_thread_id, request.direction);
  } else {
    result = resume_step(*services_.session, policy, breakpoints, thread_.active_thread_id, request.direction);
  }
  thread_.last_stop = result.last_stop;
  return result.resume;
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/components/threads_component.cpp`:

```cpp
#include "w1replay/gdb/adapter_components.hpp"

namespace w1replay::gdb {

threads_component::threads_component(const adapter_services& services, thread_state& thread)
    : services_(services), thread_(thread) {}

std::vector<uint64_t> threads_component::thread_ids() const { return {thread_.active_thread_id}; }

uint64_t threads_component::current_thread() const { return thread_.active_thread_id; }

gdbstub::target_status threads_component::set_current_thread(uint64_t) { return gdbstub::target_status::unsupported; }

std::optional<uint64_t> threads_component::thread_pc(uint64_t tid) const {
  if (tid != thread_.active_thread_id) {
    return std::nullopt;
  }
  if (!services_.session) {
    return std::nullopt;
  }
  return services_.session->current_step().address;
}

std::optional<std::string> threads_component::thread_name(uint64_t tid) const {
  if (!services_.context) {
    return std::nullopt;
  }
  for (const auto& info : services_.context->threads) {
    if (info.thread_id == tid) {
      return info.name;
    }
  }
  return std::nullopt;
}

std::optional<gdbstub::stop_reason> threads_component::thread_stop_reason(uint64_t tid) const {
  if (tid != thread_.active_thread_id) {
    return std::nullopt;
  }
  return thread_.last_stop;
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/layout.cpp`:

```cpp
#include "layout.hpp"

#include <algorithm>
#include <limits>

#include "w1rewind/format/register_metadata.hpp"

namespace w1replay::gdb {

namespace {

std::vector<std::string> minimal_register_names(const w1::arch::arch_spec& arch) {
  switch (arch.arch_mode) {
  case w1::arch::mode::x86_64:
    return {"rip", "rsp", "rflags"};
  case w1::arch::mode::x86_32:
    return {"eip", "esp", "eflags"};
  case w1::arch::mode::aarch64:
    return {"pc", "sp", "nzcv"};
  case w1::arch::mode::arm:
  case w1::arch::mode::thumb:
    return {"pc", "sp", "cpsr"};
  default:
    break;
  }
  return {"pc", "sp"};
}

std::vector<w1::rewind::register_spec> build_minimal_register_specs(const w1::arch::arch_spec& arch) {
  uint32_t pointer_size = arch.pointer_bits == 0 ? 0 : arch.pointer_bits / 8;
  if (pointer_size == 0) {
    return {};
  }
  auto names = minimal_register_names(arch);
  std::vector<w1::rewind::register_spec> specs;
  specs.reserve(names.size());
  for (size_t i = 0; i < names.size(); ++i) {
    specs.push_back(w1::rewind::build_register_spec(arch, static_cast<uint16_t>(i), names[i], pointer_size));
  }
  return specs;
}

} // namespace

register_layout build_register_layout(
    const w1::arch::arch_spec& arch, const std::vector<w1::rewind::register_spec>& register_specs
) {
  register_layout layout{};
  layout.architecture = std::string(w1::arch::gdb_arch_name(arch));
  layout.feature_name = std::string(w1::arch::gdb_feature_name(arch));
  if (layout.feature_name.empty()) {
    layout.feature_name = "org.w1tn3ss.rewind";
  }

  if (layout.architecture.empty()) {
    return layout;
  }

  std::vector<w1::rewind::register_spec> fallback_specs;
  const auto* specs = &register_specs;
  if (specs->empty()) {
    fallback_specs = build_minimal_register_specs(arch);
    specs = &fallback_specs;
  }
  if (specs->empty()) {
    return layout;
  }

  layout.registers.reserve(specs->size());
  for (size_t i = 0; i < specs->size(); ++i) {
    const auto& spec = (*specs)[i];
    register_desc desc{};
    desc.name = spec.gdb_name.empty() ? spec.name : spec.gdb_name;
    desc.bits = spec.bits;
    desc.trace_index = static_cast<size_t>(spec.reg_id);
    desc.is_pc = (spec.flags & w1::rewind::register_flag_pc) != 0;
    desc.is_sp = (spec.flags & w1::rewind::register_flag_sp) != 0;
    desc.is_flags = (spec.flags & w1::rewind::register_flag_flags) != 0;
    desc.is_fp = (spec.flags & w1::rewind::register_flag_fp) != 0;
    if (spec.dwarf_regnum != w1::rewind::k_register_regnum_unknown &&
        spec.dwarf_regnum <= static_cast<uint32_t>(std::numeric_limits<int>::max())) {
      desc.dwarf_regnum = static_cast<int>(spec.dwarf_regnum);
    }
    if (spec.ehframe_regnum != w1::rewind::k_register_regnum_unknown &&
        spec.ehframe_regnum <= static_cast<uint32_t>(std::numeric_limits<int>::max())) {
      desc.ehframe_regnum = static_cast<int>(spec.ehframe_regnum);
    }
    desc.reg_class = spec.reg_class;
    desc.value_kind = spec.value_kind;
    layout.registers.push_back(std::move(desc));
    if (layout.registers.back().is_pc) {
      layout.pc_reg_num = static_cast<int>(i);
    }
    if (layout.registers.back().is_sp) {
      layout.sp_reg_num = static_cast<int>(i);
    }
  }

  if (layout.pc_reg_num < 0) {
    for (size_t i = 0; i < layout.registers.size(); ++i) {
      if (w1::rewind::is_pc_name(layout.registers[i].name)) {
        layout.pc_reg_num = static_cast<int>(i);
        layout.registers[i].is_pc = true;
        break;
      }
    }
  }

  if (layout.sp_reg_num < 0) {
    for (size_t i = 0; i < layout.registers.size(); ++i) {
      if (w1::rewind::is_sp_name(layout.registers[i].name)) {
        layout.sp_reg_num = static_cast<int>(i);
        layout.registers[i].is_sp = true;
        break;
      }
    }
  }

  return layout;
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/layout.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <optional>
#include <string>
#include <vector>

#include "w1rewind/format/trace_format.hpp"

namespace w1replay::gdb {

struct register_desc {
  std::string name;
  uint32_t bits = 0;
  std::optional<size_t> trace_index;
  bool is_pc = false;
  bool is_sp = false;
  bool is_flags = false;
  bool is_fp = false;
  std::optional<int> dwarf_regnum;
  std::optional<int> ehframe_regnum;
  w1::rewind::register_class reg_class = w1::rewind::register_class::unknown;
  w1::rewind::register_value_kind value_kind = w1::rewind::register_value_kind::unknown;
};

struct register_layout {
  std::vector<register_desc> registers;
  int pc_reg_num = -1;
  int sp_reg_num = -1;
  std::string architecture;
  std::string feature_name;
};

register_layout build_register_layout(
    const w1::arch::arch_spec& arch, const std::vector<w1::rewind::register_spec>& register_specs
);

} // namespace w1replay::gdb

```

`src/w1replay/gdb/lldb/darwin_loaded_libraries.cpp`:

```cpp
#include "darwin_loaded_libraries.hpp"

#include <cstdio>
#include <string_view>
#include <unordered_set>

#include "w1rewind/replay/replay_context.hpp"

namespace w1replay::gdb {

namespace {
void append_json_string(std::string& out, std::string_view value) {
  out.push_back('"');
  for (char ch : value) {
    switch (ch) {
    case '"':
      out += "\\\"";
      break;
    case '\\':
      out += "\\\\";
      break;
    case '\b':
      out += "\\b";
      break;
    case '\f':
      out += "\\f";
      break;
    case '\n':
      out += "\\n";
      break;
    case '\r':
      out += "\\r";
      break;
    case '\t':
      out += "\\t";
      break;
    default:
      if (static_cast<unsigned char>(ch) < 0x20) {
        char buf[7];
        std::snprintf(buf, sizeof(buf), "\\u%04x", static_cast<unsigned int>(static_cast<unsigned char>(ch)));
        out += buf;
      } else {
        out.push_back(ch);
      }
      break;
    }
  }
  out.push_back('"');
}

void append_json_key(std::string& out, std::string_view key) {
  append_json_string(out, key);
  out.push_back(':');
}
} // namespace

darwin_loaded_libraries_provider::darwin_loaded_libraries_provider(
    const w1::rewind::replay_context& context, module_metadata_provider& metadata_provider,
    module_path_resolver& resolver
)
    : context_(context), metadata_provider_(metadata_provider), resolver_(resolver) {}

std::vector<darwin_loaded_image> darwin_loaded_libraries_provider::collect_loaded_images(
    const gdbstub::lldb::loaded_libraries_request& request
) const {
  std::unordered_set<uint64_t> filter;
  if (request.kind == gdbstub::lldb::loaded_libraries_request::kind::addresses) {
    filter.insert(request.addresses.begin(), request.addresses.end());
  }

  bool include_load_commands = request.report_load_commands;
  std::vector<darwin_loaded_image> images;
  const auto& modules = context_.modules;
  images.reserve(modules.size());

  for (const auto& module : modules) {
    if (!filter.empty() && filter.find(module.base) == filter.end()) {
      continue;
    }

    darwin_loaded_image image{};
    image.load_address = module.base;
    if (!module.path.empty()) {
      if (auto resolved = resolver_.resolve_module_path(module)) {
        image.pathname = *resolved;
      } else {
        image.pathname = module.path;
      }
    }

    std::string error;
    auto uuid = metadata_provider_.module_uuid(module, error);
    if (uuid) {
      image.uuid = *uuid;
    }

    if (include_load_commands) {
      auto header = metadata_provider_.macho_header(module, error);
      if (header) {
        image.header = *header;
      }
      auto segments = metadata_provider_.macho_segments(module, error);
      if (!segments.empty()) {
        image.segments = std::move(segments);
      }
    }

    images.push_back(std::move(image));
  }

  return images;
}

std::string build_darwin_loaded_libraries_json(
    const std::vector<darwin_loaded_image>& images, const gdbstub::lldb::loaded_libraries_request& request
) {
  std::string json;
  json.reserve(256 * (images.size() + 1));
  json += "{\"images\":[";
  for (size_t i = 0; i < images.size(); ++i) {
    if (i > 0) {
      json += ",";
    }
    json += "{";
    append_json_key(json, "load_address");
    json += std::to_string(images[i].load_address);
    json += ",\"mod_date\":0";
    if (!images[i].pathname.empty()) {
      json += ",";
      append_json_key(json, "pathname");
      append_json_string(json, images[i].pathname);
    }
    if (images[i].uuid.has_value()) {
      json += ",";
      append_json_key(json, "uuid");
      append_json_string(json, *images[i].uuid);
    }
    if (request.report_load_commands && images[i].header.has_value()) {
      const auto& header = *images[i].header;
      json += ",\"mach_header\":{";
      append_json_key(json, "magic");
      json += std::to_string(header.magic);
      json += ",";
      append_json_key(json, "cputype");
      json += std::to_string(header.cputype);
      json += ",";
      append_json_key(json, "cpusubtype");
      json += std::to_string(header.cpusubtype);
      json += ",";
      append_json_key(json, "filetype");
      json += std::to_string(header.filetype);
      json += "}";

      json += ",\"segments\":[";
      for (size_t j = 0; j < images[i].segments.size(); ++j) {
        if (j > 0) {
          json += ",";
        }
        const auto& segment = images[i].segments[j];
        json += "{";
        append_json_key(json, "name");
        append_json_string(json, segment.name);
        json += ",";
        append_json_key(json, "vmaddr");
        json += std::to_string(segment.vmaddr);
        json += ",";
        append_json_key(json, "vmsize");
        json += std::to_string(segment.vmsize);
        json += ",";
        append_json_key(json, "fileoff");
        json += std::to_string(segment.fileoff);
        json += ",";
        append_json_key(json, "filesize");
        json += std::to_string(segment.filesize);
        json += ",";
        append_json_key(json, "maxprot");
        json += std::to_string(segment.maxprot);
        json += "}";
      }
      json += "]";
    }
    json += "}";
  }
  json += "]}";
  return json;
}

std::optional<std::string> darwin_loaded_libraries_provider::loaded_libraries_json(
    const gdbstub::lldb::loaded_libraries_request& request
) {
  auto images = collect_loaded_images(request);
  return build_darwin_loaded_libraries_json(images, request);
}

std::optional<std::vector<gdbstub::lldb::process_kv_pair>> darwin_loaded_libraries_provider::process_info_extras(
    std::optional<uint64_t> current_pc
) const {
  std::vector<gdbstub::lldb::process_kv_pair> extras;
  if (!current_pc.has_value()) {
    return extras;
  }

  uint64_t module_offset = 0;
  auto* module = context_.find_module_for_address(*current_pc, 1, module_offset);
  if (!module || module->path.empty()) {
    return extras;
  }

  gdbstub::lldb::process_kv_pair addr{};
  addr.key = "main-binary-address";
  addr.u64_value = module->base;
  addr.encoding = gdbstub::lldb::kv_encoding::hex_u64;
  extras.push_back(std::move(addr));

  std::string uuid_error;
  auto uuid = metadata_provider_.module_uuid(*module, uuid_error);
  if (uuid) {
    gdbstub::lldb::process_kv_pair uuid_pair{};
    uuid_pair.key = "main-binary-uuid";
    uuid_pair.value = *uuid;
    uuid_pair.encoding = gdbstub::lldb::kv_encoding::raw;
    extras.push_back(std::move(uuid_pair));
  }

  return extras;
}

bool darwin_loaded_libraries_provider::has_loaded_images() const {
  gdbstub::lldb::loaded_libraries_request request{};
  request.kind = gdbstub::lldb::loaded_libraries_request::kind::all;
  return !collect_loaded_images(request).empty();
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/lldb/darwin_loaded_libraries.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include <string>
#include <vector>

#include "gdbstub/lldb/types.hpp"

#include "w1replay/gdb/loaded_libraries_provider.hpp"
#include "w1replay/modules/metadata_provider.hpp"
#include "w1replay/modules/path_resolver.hpp"

namespace w1replay::gdb {

struct darwin_loaded_image {
  uint64_t load_address = 0;
  std::string pathname;
  std::optional<std::string> uuid;
  std::optional<macho_header_info> header;
  std::vector<macho_segment_info> segments;
};

std::string build_darwin_loaded_libraries_json(
    const std::vector<darwin_loaded_image>& images, const gdbstub::lldb::loaded_libraries_request& request
);

class darwin_loaded_libraries_provider final : public loaded_libraries_provider {
public:
  darwin_loaded_libraries_provider(
      const w1::rewind::replay_context& context, module_metadata_provider& metadata_provider,
      module_path_resolver& resolver
  );

  std::optional<std::string> loaded_libraries_json(const gdbstub::lldb::loaded_libraries_request& request) override;
  std::optional<std::vector<gdbstub::lldb::process_kv_pair>> process_info_extras(
      std::optional<uint64_t> current_pc
  ) const override;
  bool has_loaded_images() const override;

private:
  std::vector<darwin_loaded_image> collect_loaded_images(const gdbstub::lldb::loaded_libraries_request& request) const;

  const w1::rewind::replay_context& context_;
  module_metadata_provider& metadata_provider_;
  module_path_resolver& resolver_;
};

} // namespace w1replay::gdb

```

`src/w1replay/gdb/loaded_libraries_provider.cpp`:

```cpp
#include "loaded_libraries_provider.hpp"

#include "w1rewind/replay/replay_context.hpp"

#include "w1replay/modules/metadata_provider.hpp"
#include "w1replay/modules/path_resolver.hpp"
#include "w1replay/gdb/lldb/darwin_loaded_libraries.hpp"

namespace w1replay::gdb {

std::unique_ptr<loaded_libraries_provider> make_loaded_libraries_provider(
    const w1::rewind::replay_context& context, module_metadata_provider& metadata_provider,
    module_path_resolver& resolver
) {
  if (context.target_info.has_value() && context.target_info->os == "macos") {
    return std::make_unique<darwin_loaded_libraries_provider>(context, metadata_provider, resolver);
  }
  return nullptr;
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/loaded_libraries_provider.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "gdbstub/lldb/types.hpp"

namespace w1::rewind {
struct replay_context;
}

namespace w1replay {
class module_metadata_provider;
class module_path_resolver;
} // namespace w1replay

namespace w1replay::gdb {

class loaded_libraries_provider {
public:
  virtual ~loaded_libraries_provider() = default;

  virtual std::optional<std::string> loaded_libraries_json(const gdbstub::lldb::loaded_libraries_request& request) = 0;
  virtual std::optional<std::vector<gdbstub::lldb::process_kv_pair>> process_info_extras(
      std::optional<uint64_t> current_pc
  ) const = 0;
  virtual bool has_loaded_images() const = 0;
};

std::unique_ptr<loaded_libraries_provider> make_loaded_libraries_provider(
    const w1::rewind::replay_context& context, module_metadata_provider& metadata_provider,
    module_path_resolver& resolver
);

} // namespace w1replay::gdb

```

`src/w1replay/gdb/memory_map.cpp`:

```cpp
#include "memory_map.hpp"

#include <algorithm>
#include <limits>

#include "w1rewind/format/trace_format.hpp"

#include "w1replay/modules/path_resolver.hpp"

namespace w1replay::gdb {

namespace {

struct range {
  uint64_t start = 0;
  uint64_t end = 0;
};

gdbstub::mem_perm perms_from_module(w1::rewind::module_perm perms) {
  gdbstub::mem_perm out = gdbstub::mem_perm::none;
  if ((perms & w1::rewind::module_perm::read) != w1::rewind::module_perm::none) {
    out |= gdbstub::mem_perm::read;
  }
  if ((perms & w1::rewind::module_perm::write) != w1::rewind::module_perm::none) {
    out |= gdbstub::mem_perm::write;
  }
  if ((perms & w1::rewind::module_perm::exec) != w1::rewind::module_perm::none) {
    out |= gdbstub::mem_perm::exec;
  }
  return out;
}

std::string resolve_module_path(const module_path_resolver* resolver, const w1::rewind::module_record& module) {
  if (!resolver || module.path.empty()) {
    return module.path;
  }
  auto resolved = resolver->resolve_module_path(module);
  if (resolved.has_value()) {
    return *resolved;
  }
  return module.path;
}

std::string resolve_region_name(const module_path_resolver* resolver, const std::string& name) {
  if (!resolver || name.empty()) {
    return name;
  }
  auto resolved = resolver->resolve_region_name(name);
  if (resolved.has_value()) {
    return *resolved;
  }
  return name;
}

std::vector<range> build_module_ranges(const std::vector<w1::rewind::module_record>& modules) {
  std::vector<range> ranges;
  ranges.reserve(modules.size());
  for (const auto& module : modules) {
    range r{};
    r.start = module.base;
    r.end = module.base + module.size;
    ranges.push_back(r);
  }
  std::sort(ranges.begin(), ranges.end(), [](const range& a, const range& b) { return a.start < b.start; });
  return ranges;
}

std::vector<range> build_memory_ranges(const std::vector<w1::rewind::memory_region_record>& regions) {
  std::vector<range> ranges;
  ranges.reserve(regions.size());
  for (const auto& region : regions) {
    range r{};
    r.start = region.base;
    r.end = region.base + region.size;
    ranges.push_back(r);
  }
  std::sort(ranges.begin(), ranges.end(), [](const range& a, const range& b) { return a.start < b.start; });
  return ranges;
}

std::vector<gdbstub::memory_region> build_recorded_regions(
    const w1::rewind::replay_state* state, const std::vector<range>& module_ranges
) {
  if (!state) {
    return {};
  }
  auto spans = state->memory_store().spans();
  if (spans.empty()) {
    return {};
  }

  auto safe_end = [](uint64_t base, size_t size) {
    if (size == 0) {
      return base;
    }
    uint64_t end = base + static_cast<uint64_t>(size);
    if (end < base) {
      return std::numeric_limits<uint64_t>::max();
    }
    return end;
  };

  std::vector<gdbstub::memory_region> regions;
  size_t range_index = 0;

  auto append_region = [&](uint64_t start, uint64_t end) {
    if (end <= start) {
      return;
    }
    gdbstub::memory_region region{};
    region.start = start;
    region.size = end - start;
    region.perms = gdbstub::mem_perm::read | gdbstub::mem_perm::write;
    region.name = "rewind.recorded";
    regions.push_back(std::move(region));
  };

  for (const auto& span : spans) {
    if (span.bytes.empty()) {
      continue;
    }
    uint64_t span_start = span.base;
    uint64_t span_end = safe_end(span.base, span.bytes.size());
    if (span_end <= span_start) {
      continue;
    }

    uint64_t cursor = span_start;
    while (range_index < module_ranges.size() && module_ranges[range_index].end <= cursor) {
      ++range_index;
    }

    size_t scan_index = range_index;
    while (scan_index < module_ranges.size() && module_ranges[scan_index].start < span_end) {
      const auto& range = module_ranges[scan_index];
      if (range.start > cursor) {
        append_region(cursor, std::min(range.start, span_end));
      }
      if (range.end >= span_end) {
        cursor = span_end;
        break;
      }
      cursor = std::max(cursor, range.end);
      ++scan_index;
    }

    if (cursor < span_end) {
      append_region(cursor, span_end);
    }

    range_index = scan_index;
  }

  return regions;
}

} // namespace

std::vector<gdbstub::memory_region> build_memory_map(
    const std::vector<w1::rewind::module_record>& modules,
    const std::vector<w1::rewind::memory_region_record>& memory_map, const w1::rewind::replay_state* state,
    const module_path_resolver* resolver
) {
  std::vector<gdbstub::memory_region> regions;
  const bool use_memory_map = !memory_map.empty();
  if (use_memory_map) {
    regions.reserve(memory_map.size());
    for (const auto& region_info : memory_map) {
      gdbstub::memory_region region{};
      region.start = region_info.base;
      region.size = region_info.size;
      region.perms = perms_from_module(region_info.permissions);
      region.name = resolve_region_name(resolver, region_info.name);
      regions.push_back(std::move(region));
    }
  } else if (!modules.empty()) {
    regions.reserve(modules.size());
    for (const auto& module : modules) {
      gdbstub::memory_region region{};
      region.start = module.base;
      region.size = module.size;
      region.perms = perms_from_module(module.permissions);
      if (!module.path.empty()) {
        region.name = resolve_module_path(resolver, module);
      }
      regions.push_back(std::move(region));
    }
  }

  auto ranges = use_memory_map ? build_memory_ranges(memory_map) : build_module_ranges(modules);
  auto recorded = build_recorded_regions(state, ranges);
  if (!recorded.empty()) {
    regions.insert(regions.end(), recorded.begin(), recorded.end());
  }

  return regions;
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/memory_map.hpp`:

```hpp
#pragma once

#include <vector>

#include "gdbstub/target/target.hpp"

#include "w1rewind/replay/replay_state.hpp"
#include "w1rewind/format/trace_format.hpp"

namespace w1replay {
class module_path_resolver;
}

namespace w1replay::gdb {

std::vector<gdbstub::memory_region> build_memory_map(
    const std::vector<w1::rewind::module_record>& modules,
    const std::vector<w1::rewind::memory_region_record>& memory_map, const w1::rewind::replay_state* state,
    const module_path_resolver* resolver
);

} // namespace w1replay::gdb

```

`src/w1replay/gdb/run_policy.hpp`:

```hpp
#pragma once

#include "gdbstub/target/target.hpp"

namespace w1replay::gdb {

enum class step_mode { flow, instruction };

struct run_policy {
  bool trace_is_block = false;
  bool decoder_available = false;
  bool prefer_instruction_steps = false;

  bool can_instruction_step() const { return trace_is_block && decoder_available; }

  step_mode choose_step_mode(gdbstub::resume_action action, bool has_breakpoints) const {
    if (!can_instruction_step()) {
      return step_mode::flow;
    }
    if (action == gdbstub::resume_action::cont) {
      return (prefer_instruction_steps || has_breakpoints) ? step_mode::instruction : step_mode::flow;
    }
    return step_mode::instruction;
  }
};

} // namespace w1replay::gdb

```

`src/w1replay/gdb/stepper.cpp`:

```cpp
#include "stepper.hpp"

namespace w1replay::gdb {

namespace {

constexpr int k_sigtrap = 5;

gdbstub::stop_reason make_stop_reason(gdbstub::stop_kind kind, int signal, uint64_t addr, uint64_t thread_id) {
  gdbstub::stop_reason stop{};
  stop.kind = kind;
  stop.signal = signal;
  stop.addr = addr;
  stop.thread_id = thread_id;
  return stop;
}

stepper_result make_signal_result(uint64_t thread_id) {
  stepper_result out{};
  out.resume.state = gdbstub::resume_result::state::stopped;
  out.resume.stop = make_stop_reason(gdbstub::stop_kind::signal, k_sigtrap, 0, thread_id);
  out.last_stop = out.resume.stop;
  return out;
}

stepper_result make_replay_log_result(gdbstub::replay_log_boundary boundary, uint64_t thread_id) {
  stepper_result out = make_signal_result(thread_id);
  out.resume.stop.replay_log = boundary;
  out.last_stop = out.resume.stop;
  return out;
}

stepper_result make_break_result(uint64_t address, uint64_t thread_id) {
  stepper_result out{};
  out.resume.state = gdbstub::resume_result::state::stopped;
  out.resume.stop = make_stop_reason(gdbstub::stop_kind::sw_break, k_sigtrap, address, thread_id);
  out.last_stop = out.resume.stop;
  return out;
}

bool step_once(w1::rewind::replay_session& session, bool instruction, gdbstub::resume_direction direction) {
  if (direction == gdbstub::resume_direction::reverse) {
    if (instruction) {
      return session.step_instruction_backward();
    }
    return session.step_backward();
  }
  if (instruction) {
    return session.step_instruction();
  }
  return session.step_flow();
}

} // namespace

stepper_result resume_step(
    w1::rewind::replay_session& session, const run_policy& policy, const breakpoint_store& breakpoints,
    uint64_t thread_id, gdbstub::resume_direction direction
) {
  bool instruction =
      policy.choose_step_mode(gdbstub::resume_action::step, !breakpoints.all().empty()) == step_mode::instruction;
  if (!step_once(session, instruction, direction)) {
    auto kind = session.error_kind();
    if (kind == w1::rewind::replay_session::replay_error_kind::begin_of_trace) {
      return make_replay_log_result(gdbstub::replay_log_boundary::begin, thread_id);
    }
    if (kind == w1::rewind::replay_session::replay_error_kind::end_of_trace) {
      return make_replay_log_result(gdbstub::replay_log_boundary::end, thread_id);
    }
    return make_signal_result(thread_id);
  }

  uint64_t address = session.current_step().address;
  if (breakpoints.contains(address)) {
    return make_break_result(address, thread_id);
  }
  return make_signal_result(thread_id);
}

stepper_result resume_continue(
    w1::rewind::replay_session& session, const run_policy& policy, const breakpoint_store& breakpoints,
    uint64_t thread_id, gdbstub::resume_direction direction
) {
  bool instruction =
      policy.choose_step_mode(gdbstub::resume_action::cont, !breakpoints.all().empty()) == step_mode::instruction;

  for (;;) {
    if (!step_once(session, instruction, direction)) {
      auto kind = session.error_kind();
      if (kind == w1::rewind::replay_session::replay_error_kind::begin_of_trace) {
        return make_replay_log_result(gdbstub::replay_log_boundary::begin, thread_id);
      }
      if (kind == w1::rewind::replay_session::replay_error_kind::end_of_trace) {
        return make_replay_log_result(gdbstub::replay_log_boundary::end, thread_id);
      }
      return make_signal_result(thread_id);
    }

    uint64_t address = session.current_step().address;
    if (breakpoints.contains(address)) {
      return make_break_result(address, thread_id);
    }
  }
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/stepper.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include "gdbstub/target/target.hpp"

#include "w1rewind/replay/replay_session.hpp"

#include "breakpoint_store.hpp"
#include "run_policy.hpp"

namespace w1replay::gdb {

struct stepper_result {
  gdbstub::resume_result resume;
  std::optional<gdbstub::stop_reason> last_stop;
};

stepper_result resume_step(
    w1::rewind::replay_session& session, const run_policy& policy, const breakpoint_store& breakpoints,
    uint64_t thread_id, gdbstub::resume_direction direction
);

stepper_result resume_continue(
    w1::rewind::replay_session& session, const run_policy& policy, const breakpoint_store& breakpoints,
    uint64_t thread_id, gdbstub::resume_direction direction
);

} // namespace w1replay::gdb

```

`src/w1replay/gdb/target_xml.cpp`:

```cpp
#include "target_xml.hpp"

#include <algorithm>
#include <sstream>

namespace w1replay::gdb {

namespace {

const char* group_for_class(w1::rewind::register_class cls) {
  switch (cls) {
  case w1::rewind::register_class::fpr:
    return "float";
  case w1::rewind::register_class::simd:
    return "vector";
  case w1::rewind::register_class::gpr:
  case w1::rewind::register_class::flags:
  case w1::rewind::register_class::system:
  case w1::rewind::register_class::unknown:
  default:
    return "general";
  }
}

const char* type_for_reg(const register_desc& reg) {
  if (reg.is_pc) {
    return "code_ptr";
  }
  if (reg.is_sp) {
    return "data_ptr";
  }
  if (reg.reg_class == w1::rewind::register_class::fpr) {
    return "float";
  }
  return "int";
}

const char* generic_for_reg(const register_desc& reg) {
  if (reg.is_pc) {
    return "pc";
  }
  if (reg.is_sp) {
    return "sp";
  }
  if (reg.is_flags) {
    return "flags";
  }
  if (reg.is_fp) {
    return "fp";
  }
  return nullptr;
}

} // namespace

std::string build_target_xml(const register_layout& layout) {
  if (layout.architecture.empty() || layout.registers.empty()) {
    return {};
  }

  struct xml_reg_entry {
    const register_desc* reg = nullptr;
    size_t remote_regnum = 0;
    std::optional<int> dwarf_regnum;
    std::optional<int> ehframe_regnum;
  };

  std::vector<xml_reg_entry> entries;
  entries.reserve(layout.registers.size());
  for (size_t i = 0; i < layout.registers.size(); ++i) {
    const auto& reg = layout.registers[i];
    xml_reg_entry entry{};
    entry.reg = &reg;
    entry.remote_regnum = i;
    entry.dwarf_regnum = reg.dwarf_regnum;
    entry.ehframe_regnum = reg.ehframe_regnum;
    entries.push_back(entry);
  }

  std::stable_sort(entries.begin(), entries.end(), [](const xml_reg_entry& lhs, const xml_reg_entry& rhs) {
    if (lhs.dwarf_regnum && rhs.dwarf_regnum) {
      return *lhs.dwarf_regnum < *rhs.dwarf_regnum;
    }
    if (lhs.dwarf_regnum) {
      return true;
    }
    if (rhs.dwarf_regnum) {
      return false;
    }
    return lhs.remote_regnum < rhs.remote_regnum;
  });

  std::ostringstream xml;
  xml << "<?xml version=\"1.0\"?>\n";
  xml << "<!DOCTYPE target SYSTEM \"gdb-target.dtd\">\n";
  xml << "<target version=\"1.0\">\n";
  xml << "  <architecture>" << layout.architecture << "</architecture>\n";
  xml << "  <feature name=\"" << layout.feature_name << "\">\n";
  for (const auto& entry : entries) {
    const auto& reg = *entry.reg;
    xml << "    <reg name=\"" << reg.name << "\" bitsize=\"" << reg.bits << "\" regnum=\"" << entry.remote_regnum
        << "\"";
    if (entry.dwarf_regnum) {
      xml << " dwarf_regnum=\"" << *entry.dwarf_regnum << "\"";
    }
    if (entry.ehframe_regnum) {
      xml << " gcc_regnum=\"" << *entry.ehframe_regnum << "\"";
    }
    xml << " type=\"" << type_for_reg(reg) << "\"";
    if (const char* generic = generic_for_reg(reg)) {
      xml << " generic=\"" << generic << "\"";
    }
    xml << " group=\"" << group_for_class(reg.reg_class) << "\"";
    xml << "/>\n";
  }
  xml << "  </feature>\n";
  xml << "</target>\n";
  return xml.str();
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/target_xml.hpp`:

```hpp
#pragma once

#include <string>

#include "layout.hpp"

namespace w1replay::gdb {

std::string build_target_xml(const register_layout& layout);

} // namespace w1replay::gdb

```

`src/w1replay/gdb/thread_state.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>

#include "gdbstub/target/target.hpp"

namespace w1replay::gdb {

struct thread_state {
  uint64_t active_thread_id = 0;
  std::optional<gdbstub::stop_reason> last_stop;
};

} // namespace w1replay::gdb

```

`src/w1replay/gdb/triple_utils.cpp`:

```cpp
#include "triple_utils.hpp"

namespace w1replay::gdb {

namespace {
std::string triple_arch_from_spec(const w1::arch::arch_spec& spec) {
  using w1::arch::family;
  using w1::arch::mode;
  switch (spec.arch_mode) {
  case mode::x86_64:
    return "x86_64";
  case mode::x86_32:
    return "i386";
  case mode::arm:
    return "arm";
  case mode::thumb:
    return "thumb";
  case mode::aarch64:
    return "aarch64";
  case mode::riscv32:
    return "riscv32";
  case mode::riscv64:
    return "riscv64";
  case mode::mips32:
    return "mips";
  case mode::mips64:
    return "mips64";
  case mode::ppc32:
    return "powerpc";
  case mode::ppc64:
    return "powerpc64";
  case mode::sparc32:
    return "sparc";
  case mode::sparc64:
    return "sparcv9";
  case mode::systemz:
    return "s390x";
  case mode::wasm32:
    return "wasm32";
  case mode::wasm64:
    return "wasm64";
  default:
    break;
  }

  switch (spec.arch_family) {
  case family::x86:
    return spec.pointer_bits == 64 ? "x86_64" : "i386";
  case family::arm:
    return spec.pointer_bits == 64 ? "aarch64" : "arm";
  case family::riscv:
    return spec.pointer_bits == 64 ? "riscv64" : "riscv32";
  case family::mips:
    return spec.pointer_bits == 64 ? "mips64" : "mips";
  case family::ppc:
    return spec.pointer_bits == 64 ? "powerpc64" : "powerpc";
  case family::sparc:
    return spec.pointer_bits == 64 ? "sparcv9" : "sparc";
  case family::systemz:
    return "s390x";
  case family::wasm:
    return spec.pointer_bits == 64 ? "wasm64" : "wasm32";
  default:
    break;
  }

  return {};
}
} // namespace

std::string build_process_triple(const w1::arch::arch_spec& spec, const std::string& os_id, const std::string& abi) {
  std::string arch = triple_arch_from_spec(spec);
  if (arch.empty()) {
    return {};
  }

  std::string vendor = "unknown";
  std::string os = "unknown";
  std::string env;
  if (os_id == "linux") {
    os = "linux";
    env = abi.empty() ? "gnu" : abi;
  } else if (os_id == "macos") {
    vendor = "apple";
    os = "macosx";
    env = abi;
  } else if (os_id == "windows") {
    vendor = "pc";
    os = "windows";
    env = abi.empty() ? "msvc" : abi;
  } else if (!os_id.empty()) {
    os = os_id;
    env = abi;
  }

  std::string triple = arch + "-" + vendor + "-" + os;
  if (!env.empty()) {
    triple += "-";
    triple += env;
  }
  return triple;
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/triple_utils.hpp`:

```hpp
#pragma once

#include <string>

#include "w1base/arch_spec.hpp"

namespace w1replay::gdb {

std::string build_process_triple(const w1::arch::arch_spec& spec, const std::string& os_id, const std::string& abi);

} // namespace w1replay::gdb

```

`src/w1replay/gdb/value_codec.cpp`:

```cpp
#include "value_codec.hpp"

#include <limits>

namespace w1replay::gdb {

bool encode_uint64(uint64_t value, size_t size, std::span<std::byte> out, endian order) {
  if (size > sizeof(uint64_t) || out.size() < size) {
    return false;
  }
  uint64_t masked = value;
  if (size < sizeof(uint64_t)) {
    uint64_t mask = (size == 8) ? std::numeric_limits<uint64_t>::max() : ((uint64_t{1} << (size * 8)) - 1);
    masked &= mask;
  }
  for (size_t i = 0; i < size; ++i) {
    size_t shift = (order == endian::little) ? (i * 8) : ((size - 1 - i) * 8);
    out[i] = static_cast<std::byte>((masked >> shift) & 0xff);
  }
  return true;
}

} // namespace w1replay::gdb

```

`src/w1replay/gdb/value_codec.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <span>

namespace w1replay::gdb {

enum class endian { little, big };

bool encode_uint64(uint64_t value, size_t size, std::span<std::byte> out, endian order = endian::little);

} // namespace w1replay::gdb

```

`src/w1replay/memory/memory_view.cpp`:

```cpp
#include "memory_view.hpp"

#include <algorithm>

#include "w1replay/modules/image_reader.hpp"
#include "w1rewind/replay/replay_context.hpp"
#include "w1rewind/replay/replay_state.hpp"

namespace w1replay {

replay_memory_view::replay_memory_view(
    const w1::rewind::replay_context* context, const w1::rewind::replay_state* state, module_image_reader* module_reader
)
    : context_(context), state_(state), module_reader_(module_reader) {}

void replay_memory_view::set_state(const w1::rewind::replay_state* state) { state_ = state; }

w1::rewind::memory_read replay_memory_view::read(uint64_t address, size_t size) {
  w1::rewind::memory_read out;
  if (state_) {
    out = state_->read_memory(address, size);
  } else {
    out.bytes.assign(size, std::byte{0});
    out.known.assign(size, 0);
  }

  if (!context_ || !module_reader_ || size == 0) {
    return out;
  }

  auto module_bytes = module_reader_->read_address_bytes(*context_, address, size);
  if (!module_bytes.error.empty()) {
    return out;
  }

  size_t limit = std::min({size, module_bytes.bytes.size(), module_bytes.known.size()});
  for (size_t i = 0; i < limit; ++i) {
    if (out.known[i] == 0 && module_bytes.known[i]) {
      out.bytes[i] = module_bytes.bytes[i];
      out.known[i] = 1;
    }
  }

  return out;
}

} // namespace w1replay

```

`src/w1replay/memory/memory_view.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>

#include "w1rewind/replay/memory_store.hpp"

namespace w1::rewind {
struct replay_context;
class replay_state;
} // namespace w1::rewind

namespace w1replay {

class module_image_reader;

class memory_view {
public:
  virtual ~memory_view() = default;
  virtual w1::rewind::memory_read read(uint64_t address, size_t size) = 0;
};

class replay_memory_view final : public memory_view {
public:
  replay_memory_view(
      const w1::rewind::replay_context* context, const w1::rewind::replay_state* state,
      module_image_reader* module_reader
  );

  void set_state(const w1::rewind::replay_state* state);
  w1::rewind::memory_read read(uint64_t address, size_t size) override;

private:
  const w1::rewind::replay_context* context_ = nullptr;
  const w1::rewind::replay_state* state_ = nullptr;
  module_image_reader* module_reader_ = nullptr;
};

} // namespace w1replay

```

`src/w1replay/modules/address_index.cpp`:

```cpp
#include "address_index.hpp"

#include <algorithm>
#include <limits>
#include <unordered_map>

namespace w1replay {

namespace {
uint64_t safe_end(uint64_t base, uint64_t size) {
  if (size == 0) {
    return base;
  }
  uint64_t end = base + size;
  if (end < base) {
    return std::numeric_limits<uint64_t>::max();
  }
  return end;
}

bool contains_range(uint64_t start, uint64_t end, uint64_t address, uint64_t range_end) {
  return address >= start && range_end <= end;
}
} // namespace

module_address_index::module_address_index(const w1::rewind::replay_context& context) {
  std::unordered_map<uint64_t, const w1::rewind::module_record*> modules_by_id;
  modules_by_id.reserve(context.modules.size());
  for (const auto& module : context.modules) {
    modules_by_id.emplace(module.id, &module);
    if (module.size == 0) {
      continue;
    }
    uint64_t end = safe_end(module.base, module.size);
    if (end <= module.base) {
      continue;
    }
    module_ranges_.push_back(address_range{module.base, end, &module});
  }

  if (!context.memory_map.empty()) {
    region_ranges_.reserve(context.memory_map.size());
    for (const auto& region : context.memory_map) {
      if (region.size == 0 || region.image_id == 0) {
        continue;
      }
      auto it = modules_by_id.find(region.image_id);
      if (it == modules_by_id.end()) {
        continue;
      }
      uint64_t end = safe_end(region.base, region.size);
      if (end <= region.base) {
        continue;
      }
      region_ranges_.push_back(address_range{region.base, end, it->second});
    }
  }

  auto by_start = [](const address_range& left, const address_range& right) { return left.start < right.start; };
  std::sort(region_ranges_.begin(), region_ranges_.end(), by_start);
  std::sort(module_ranges_.begin(), module_ranges_.end(), by_start);
}

std::optional<module_address_match> module_address_index::find(uint64_t address, uint64_t size) const {
  if (size == 0) {
    return std::nullopt;
  }
  uint64_t end = safe_end(address, size);
  if (end <= address) {
    return std::nullopt;
  }

  if (auto match = find_in_ranges(region_ranges_, address, end)) {
    return match;
  }
  return find_in_ranges(module_ranges_, address, end);
}

std::optional<module_address_match> module_address_index::find_in_ranges(
    const std::vector<address_range>& ranges, uint64_t address, uint64_t end
) const {
  for (const auto& range : ranges) {
    if (end <= range.start) {
      break;
    }
    if (!contains_range(range.start, range.end, address, end)) {
      continue;
    }
    const auto* module = range.module;
    if (!module || module->size == 0) {
      continue;
    }
    uint64_t module_end = safe_end(module->base, module->size);
    if (module_end <= module->base) {
      continue;
    }
    if (!contains_range(module->base, module_end, address, end)) {
      continue;
    }
    module_address_match match{};
    match.module = module;
    match.module_offset = address - module->base;
    return match;
  }
  return std::nullopt;
}

} // namespace w1replay

```

`src/w1replay/modules/address_index.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include <vector>

#include "w1rewind/replay/replay_context.hpp"

namespace w1replay {

struct module_address_match {
  const w1::rewind::module_record* module = nullptr;
  uint64_t module_offset = 0;
};

class module_address_index {
public:
  explicit module_address_index(const w1::rewind::replay_context& context);

  std::optional<module_address_match> find(uint64_t address, uint64_t size) const;

private:
  struct address_range {
    uint64_t start = 0;
    uint64_t end = 0;
    const w1::rewind::module_record* module = nullptr;
  };

  std::optional<module_address_match> find_in_ranges(
      const std::vector<address_range>& ranges, uint64_t address, uint64_t end
  ) const;

  std::vector<address_range> region_ranges_;
  std::vector<address_range> module_ranges_;
};

} // namespace w1replay

```

`src/w1replay/modules/asmr_block_decoder.cpp`:

```cpp
#include "asmr_block_decoder.hpp"

#include "w1replay/memory/memory_view.hpp"

#include <cstddef>
#include <optional>
#include <vector>

#if defined(WITNESS_ASMR_ENABLED)
#include "w1asmr/asmr.hpp"
#endif

namespace w1replay {

namespace {} // namespace

bool asmr_decoder_available() {
#if defined(WITNESS_ASMR_ENABLED) && defined(WITNESS_LIEF_ENABLED)
  return true;
#else
  return false;
#endif
}

asmr_block_decoder::~asmr_block_decoder() = default;

bool asmr_block_decoder::decode_block(
    const w1::rewind::replay_context& context, const w1::rewind::flow_step& flow, w1::rewind::decoded_block& out,
    std::string& error
) {
#if !defined(WITNESS_ASMR_ENABLED)
  (void) context;
  (void) flow;
  (void) out;
  error = "asmr decoder unavailable (build with WITNESS_ASMR=ON)";
  return false;
#elif !defined(WITNESS_LIEF_ENABLED)
  (void) context;
  (void) flow;
  (void) out;
  error = "asmr decoder unavailable (build with WITNESS_LIEF=ON)";
  return false;
#else
  if (!view_) {
    error = "memory view missing";
    return false;
  }

  if (flow.size == 0) {
    error = "block size is zero";
    return false;
  }

  auto read = view_->read(flow.address, flow.size);
  if (!read.complete()) {
    error = "code bytes incomplete";
    return false;
  }
  if (read.bytes.size() < flow.size) {
    error = "code bytes truncated";
    return false;
  }
  std::vector<uint8_t> buffer;
  buffer.resize(read.bytes.size());
  for (size_t i = 0; i < read.bytes.size(); ++i) {
    buffer[i] = std::to_integer<uint8_t>(read.bytes[i]);
  }
  uint64_t base_address = flow.address;

  w1::arch::arch_spec spec = context.header.arch;
  if ((flow.flags & w1::rewind::trace_block_flag_mode_valid) != 0) {
    if ((flow.flags & w1::rewind::trace_block_flag_thumb) != 0) {
      spec.arch_mode = w1::arch::mode::thumb;
    } else {
      spec.arch_mode = w1::arch::mode::arm;
    }
  }

  auto ctx = w1::asmr::disasm_context::for_arch(spec);
  if (!ctx.ok()) {
    error = ctx.status_info.message;
    return false;
  }

  auto decoded = ctx.value.disassemble(buffer, base_address);
  if (!decoded.ok()) {
    error = decoded.status_info.message;
    return false;
  }

  if (decoded.value.empty()) {
    error = "disassembly produced no instructions";
    return false;
  }

  out = w1::rewind::decoded_block{};
  out.start = flow.address;
  out.size = flow.size;
  out.instructions.reserve(decoded.value.size());

  uint64_t expected_address = base_address;
  for (const auto& inst : decoded.value) {
    if (inst.bytes.empty()) {
      error = "decoded instruction missing bytes";
      return false;
    }

    uint32_t inst_size = static_cast<uint32_t>(inst.bytes.size());

    if (inst.address != expected_address) {
      error = "decoded instructions are not contiguous";
      return false;
    }

    if (inst.address + inst_size < inst.address) {
      error = "decoded instruction address overflow";
      return false;
    }

    if (inst.address + inst_size > base_address + flow.size) {
      error = "decoded instruction exceeds block size";
      return false;
    }

    w1::rewind::decoded_instruction out_inst{};
    out_inst.address = inst.address;
    out_inst.size = inst_size;
    out_inst.bytes = inst.bytes;
    out.instructions.push_back(std::move(out_inst));

    expected_address = inst.address + inst_size;
  }

  if (expected_address != base_address + flow.size) {
    error = "decoded instructions do not cover block size";
    return false;
  }

  return true;
#endif
}

} // namespace w1replay

```

`src/w1replay/modules/asmr_block_decoder.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>

#include "w1rewind/replay/block_decoder.hpp"

namespace w1replay {

class memory_view;

class asmr_block_decoder final : public w1::rewind::block_decoder {
public:
  ~asmr_block_decoder();

  void set_memory_view(memory_view* view) { view_ = view; }

  bool decode_block(
      const w1::rewind::replay_context& context, const w1::rewind::flow_step& flow, w1::rewind::decoded_block& out,
      std::string& error
  ) override;

private:
  memory_view* view_ = nullptr;
};

bool asmr_decoder_available();

} // namespace w1replay

```

`src/w1replay/modules/image_reader.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <functional>
#include <span>
#include <string>

#include "module_image.hpp"

namespace w1::rewind {
struct module_record;
struct replay_context;
} // namespace w1::rewind

namespace w1replay {

using module_address_reader = std::function<bool(uint64_t address, std::span<std::byte> out, std::string& error)>;

class module_image_reader {
public:
  virtual ~module_image_reader() = default;

  virtual image_read_result read_module_bytes(
      const w1::rewind::module_record& module, uint64_t offset, size_t size
  ) = 0;
  virtual image_read_result read_address_bytes(
      const w1::rewind::replay_context& context, uint64_t address, size_t size
  ) = 0;
  virtual const image_layout* module_layout(const w1::rewind::module_record& module, std::string& error) = 0;
};

} // namespace w1replay

```

`src/w1replay/modules/lief_module_provider.cpp`:

```cpp
#include "lief_module_provider.hpp"

#include "module_image_lief.hpp"
#include "w1base/uuid_format.hpp"

#include <algorithm>
#include <unordered_map>

#include "w1rewind/format/trace_format.hpp"
#include "w1rewind/replay/replay_context.hpp"

namespace w1replay {

lief_module_provider::lief_module_provider(lief_module_provider_config config)
    : resolver_(config.resolver), address_index_(config.address_index),
      address_reader_(std::move(config.address_reader)) {}

std::string lief_module_provider::resolved_module_path(const w1::rewind::module_record& module) const {
  if (resolver_) {
    if (auto resolved = resolver_->resolve_module_path(module)) {
      return *resolved;
    }
  }
  return module.path;
}

image_read_result lief_module_provider::read_module_bytes(
    const w1::rewind::module_record& module, uint64_t offset, size_t size
) {
  image_read_result result;

  if (size == 0) {
    result.error = "module read size is zero";
    return result;
  }

#if !defined(WITNESS_LIEF_ENABLED)
  (void) module;
  (void) offset;
  result.error = "module bytes unavailable (build with WITNESS_LIEF=ON)";
  return result;
#else
  std::string layout_error;
  const auto* layout = module_layout(module, layout_error);
  if (!layout) {
    result.error = layout_error.empty() ? "module layout unavailable" : layout_error;
    return result;
  }

  result = read_image_bytes(*layout, offset, size);
  if (!result.error.empty()) {
    result.error = "module image read failed: " + result.error;
  }
  return result;
#endif
}

image_read_result lief_module_provider::read_address_bytes(
    const w1::rewind::replay_context& context, uint64_t address, size_t size
) {
  image_read_result result;

  if (size == 0) {
    result.error = "empty read";
    return result;
  }

  if (address_reader_) {
    result.bytes.assign(size, std::byte{0});
    result.known.assign(size, 0);
    std::string reader_error;
    if (!address_reader_(address, result.bytes, reader_error)) {
      result.error = reader_error.empty() ? "address reader failed" : reader_error;
      return result;
    }
    std::fill(result.known.begin(), result.known.end(), 1);
    result.complete = true;
    return result;
  }

  std::optional<module_address_match> match;
  if (address_index_) {
    match = address_index_->find(address, static_cast<uint64_t>(size));
  } else {
    module_address_index fallback(context);
    match = fallback.find(address, static_cast<uint64_t>(size));
  }
  if (!match.has_value() || !match->module) {
    result.error = "address not in module";
    return result;
  }

  w1::rewind::module_record resolved = *match->module;
  std::string resolved_path = resolved_module_path(*match->module);
  if (!resolved_path.empty()) {
    resolved.path = std::move(resolved_path);
  }
  return read_module_bytes(resolved, match->module_offset, size);
}

const image_layout* lief_module_provider::module_layout(const w1::rewind::module_record& module, std::string& error) {
  error.clear();
#if !defined(WITNESS_LIEF_ENABLED)
  (void) module;
  error = "module bytes unavailable (build with WITNESS_LIEF=ON)";
  return nullptr;
#else
  auto* entry = get_or_load_entry(module, error);
  if (!entry) {
    return nullptr;
  }
  return &entry->layout;
#endif
}

std::optional<std::string> lief_module_provider::module_uuid(
    const w1::rewind::module_record& module, std::string& error
) {
  error.clear();
  if (module.format == w1::rewind::module_format::macho && !module.identity.empty()) {
    return module.identity;
  }

#if !defined(WITNESS_LIEF_ENABLED)
  (void) module;
  error = "module uuid unavailable (build with WITNESS_LIEF=ON)";
  return std::nullopt;
#else
  auto* entry = get_or_load_entry(module, error);
  if (!entry || !entry->binary) {
    return std::nullopt;
  }
  if (entry->binary->format() != LIEF::Binary::FORMATS::MACHO) {
    error = "module is not Mach-O";
    return std::nullopt;
  }
  auto* macho = dynamic_cast<LIEF::MachO::Binary*>(entry->binary.get());
  if (!macho || !macho->has_uuid()) {
    error = "Mach-O UUID unavailable";
    return std::nullopt;
  }
  const auto* uuid_cmd = macho->uuid();
  if (!uuid_cmd) {
    error = "Mach-O UUID unavailable";
    return std::nullopt;
  }
  const auto& uuid_bytes = uuid_cmd->uuid();
  if (w1::util::is_all_zero_uuid(uuid_bytes)) {
    error = "Mach-O UUID is zero";
    return std::nullopt;
  }
  return w1::util::format_uuid(uuid_bytes);
#endif
}

std::optional<macho_header_info> lief_module_provider::macho_header(
    const w1::rewind::module_record& module, std::string& error
) {
  error.clear();
#if !defined(WITNESS_LIEF_ENABLED)
  (void) module;
  error = "module header unavailable (build with WITNESS_LIEF=ON)";
  return std::nullopt;
#else
  auto* entry = get_or_load_entry(module, error);
  if (!entry || !entry->binary) {
    return std::nullopt;
  }
  if (entry->binary->format() != LIEF::Binary::FORMATS::MACHO) {
    error = "module is not Mach-O";
    return std::nullopt;
  }
  auto* macho = dynamic_cast<LIEF::MachO::Binary*>(entry->binary.get());
  if (!macho) {
    error = "invalid Mach-O binary";
    return std::nullopt;
  }
  const auto& header = macho->header();
  macho_header_info info{};
  info.magic = static_cast<uint32_t>(header.magic());
  info.cputype = static_cast<uint32_t>(header.cpu_type());
  info.cpusubtype = header.cpu_subtype();
  info.filetype = static_cast<uint32_t>(header.file_type());
  return info;
#endif
}

std::vector<macho_segment_info> lief_module_provider::macho_segments(
    const w1::rewind::module_record& module, std::string& error
) {
  error.clear();
#if !defined(WITNESS_LIEF_ENABLED)
  (void) module;
  error = "module segments unavailable (build with WITNESS_LIEF=ON)";
  return {};
#else
  auto* entry = get_or_load_entry(module, error);
  if (!entry || !entry->binary) {
    return {};
  }
  if (entry->binary->format() != LIEF::Binary::FORMATS::MACHO) {
    error = "module is not Mach-O";
    return {};
  }
  auto* macho = dynamic_cast<LIEF::MachO::Binary*>(entry->binary.get());
  if (!macho) {
    error = "invalid Mach-O binary";
    return {};
  }

  std::vector<macho_segment_info> segments;
  segments.reserve(macho->segments().size());
  for (const auto& segment : macho->segments()) {
    macho_segment_info info{};
    info.name = segment.name();
    info.vmaddr = segment.virtual_address();
    info.vmsize = segment.virtual_size();
    info.fileoff = segment.file_offset();
    info.filesize = segment.file_size();
    info.maxprot = static_cast<uint32_t>(segment.max_protection());
    segments.push_back(std::move(info));
  }
  return segments;
#endif
}

#if defined(WITNESS_LIEF_ENABLED)
lief_module_provider::module_entry* lief_module_provider::get_or_load_entry(
    const w1::rewind::module_record& module, std::string& error
) {
  std::string path = resolved_module_path(module);
  if (path.empty()) {
    error = "module path missing";
    return nullptr;
  }

  auto& entry = modules_[path];
  if (!entry.binary) {
    auto binary = LIEF::Parser::parse(path);
    if (!binary) {
      error = "failed to parse module: " + path;
      return nullptr;
    }
    entry.binary = std::move(binary);
    if (!build_image_layout(*entry.binary, entry.layout, error)) {
      error = "failed to build module layout: " + error;
      entry.binary.reset();
      entry.layout = image_layout{};
      return nullptr;
    }
  }
  return &entry;
}
#endif

} // namespace w1replay

```

`src/w1replay/modules/lief_module_provider.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <unordered_map>
#include <vector>

#include "address_index.hpp"
#include "image_reader.hpp"
#include "metadata_provider.hpp"
#include "path_resolver.hpp"

#if defined(WITNESS_LIEF_ENABLED)
#include <LIEF/LIEF.hpp>
#endif

namespace w1replay {

struct lief_module_provider_config {
  const module_path_resolver* resolver = nullptr;
  const module_address_index* address_index = nullptr;
  module_address_reader address_reader{};
};

class lief_module_provider final : public module_image_reader, public module_metadata_provider {
public:
  explicit lief_module_provider(lief_module_provider_config config);

  image_read_result read_module_bytes(const w1::rewind::module_record& module, uint64_t offset, size_t size) override;
  image_read_result read_address_bytes(
      const w1::rewind::replay_context& context, uint64_t address, size_t size
  ) override;
  const image_layout* module_layout(const w1::rewind::module_record& module, std::string& error) override;

  std::optional<std::string> module_uuid(const w1::rewind::module_record& module, std::string& error) override;
  std::optional<macho_header_info> macho_header(const w1::rewind::module_record& module, std::string& error) override;
  std::vector<macho_segment_info> macho_segments(const w1::rewind::module_record& module, std::string& error) override;

private:
  std::string resolved_module_path(const w1::rewind::module_record& module) const;

  const module_path_resolver* resolver_ = nullptr;
  const module_address_index* address_index_ = nullptr;
  module_address_reader address_reader_{};

#if defined(WITNESS_LIEF_ENABLED)
  struct module_entry {
    std::unique_ptr<LIEF::Binary> binary;
    image_layout layout;
  };

  std::unordered_map<std::string, module_entry> modules_;

  module_entry* get_or_load_entry(const w1::rewind::module_record& module, std::string& error);
#endif
};

} // namespace w1replay

```

`src/w1replay/modules/metadata_provider.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include <string>
#include <vector>

namespace w1::rewind {
struct module_record;
}

namespace w1replay {

struct macho_header_info {
  uint32_t magic = 0;
  uint32_t cputype = 0;
  uint32_t cpusubtype = 0;
  uint32_t filetype = 0;
};

struct macho_segment_info {
  std::string name;
  uint64_t vmaddr = 0;
  uint64_t vmsize = 0;
  uint64_t fileoff = 0;
  uint64_t filesize = 0;
  uint32_t maxprot = 0;
};

class module_metadata_provider {
public:
  virtual ~module_metadata_provider() = default;

  virtual std::optional<std::string> module_uuid(const w1::rewind::module_record& module, std::string& error) = 0;
  virtual std::optional<macho_header_info> macho_header(
      const w1::rewind::module_record& module, std::string& error
  ) = 0;
  virtual std::vector<macho_segment_info> macho_segments(
      const w1::rewind::module_record& module, std::string& error
  ) = 0;
};

} // namespace w1replay

```

`src/w1replay/modules/module_image.cpp`:

```cpp
#include "module_image.hpp"

#include <algorithm>
#include <limits>

namespace w1replay {

namespace {

bool add_overflows(uint64_t base, uint64_t addend) { return base > std::numeric_limits<uint64_t>::max() - addend; }

} // namespace

image_read_result read_image_bytes(const image_layout& layout, uint64_t module_offset, size_t size) {
  image_read_result result;

  if (size == 0) {
    result.error = "read size is zero";
    return result;
  }

  if (layout.ranges.empty()) {
    result.error = "no image ranges";
    return result;
  }

  if (add_overflows(layout.link_base, module_offset)) {
    result.error = "module offset overflows link base";
    return result;
  }
  const uint64_t start = layout.link_base + module_offset;
  if (add_overflows(start, size)) {
    result.error = "read size overflows address";
    return result;
  }
  const uint64_t end = start + size;

  result.bytes.assign(size, std::byte{0});
  result.known.assign(size, 0);

  for (const auto& range : layout.ranges) {
    if (range.mem_size == 0) {
      continue;
    }
    if (add_overflows(range.va_start, range.mem_size)) {
      result.error = "image range overflows address space";
      return result;
    }

    const uint64_t range_start = range.va_start;
    const uint64_t range_end = range.va_start + range.mem_size;
    if (range_end <= start || range_start >= end) {
      continue;
    }

    const uint64_t overlap_start = std::max(range_start, start);
    const uint64_t overlap_end = std::min(range_end, end);
    const uint64_t overlap_size64 = overlap_end - overlap_start;
    const uint64_t output_offset64 = overlap_start - start;
    const uint64_t range_offset64 = overlap_start - range_start;

    if (overlap_size64 == 0) {
      continue;
    }
    if (overlap_size64 > std::numeric_limits<size_t>::max() || output_offset64 > std::numeric_limits<size_t>::max() ||
        range_offset64 > std::numeric_limits<size_t>::max()) {
      result.error = "read size exceeds host limits";
      return result;
    }

    const size_t overlap_size = static_cast<size_t>(overlap_size64);
    const size_t output_offset = static_cast<size_t>(output_offset64);
    const size_t range_offset = static_cast<size_t>(range_offset64);

    const size_t file_size = range.file_bytes.size();
    size_t file_available = 0;
    if (range_offset < file_size) {
      file_available = std::min(file_size - range_offset, overlap_size);
    }

    if (file_available > 0) {
      const std::byte* src = range.file_bytes.data() + range_offset;
      std::byte* dest = result.bytes.data() + output_offset;
      std::copy(src, src + file_available, dest);
      std::fill(
          result.known.begin() + static_cast<std::vector<uint8_t>::difference_type>(output_offset),
          result.known.begin() + static_cast<std::vector<uint8_t>::difference_type>(output_offset + file_available), 1
      );
    }

    const size_t bss_size = overlap_size - file_available;
    if (bss_size > 0) {
      const size_t bss_offset = output_offset + file_available;
      std::fill(
          result.known.begin() + static_cast<std::vector<uint8_t>::difference_type>(bss_offset),
          result.known.begin() + static_cast<std::vector<uint8_t>::difference_type>(bss_offset + bss_size), 1
      );
    }
  }

  result.complete = std::all_of(result.known.begin(), result.known.end(), [](uint8_t value) { return value != 0; });

  return result;
}

} // namespace w1replay

```

`src/w1replay/modules/module_image.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <span>
#include <string>
#include <vector>

namespace w1replay {

struct image_range {
  uint64_t va_start = 0;
  uint64_t mem_size = 0;
  std::span<const std::byte> file_bytes{};
};

struct image_layout {
  uint64_t link_base = 0;
  std::vector<image_range> ranges;
};

struct image_read_result {
  std::vector<std::byte> bytes;
  std::vector<uint8_t> known;
  std::string error;
  bool complete = false;
};

image_read_result read_image_bytes(const image_layout& layout, uint64_t module_offset, size_t size);

} // namespace w1replay

```

`src/w1replay/modules/module_image_lief.cpp`:

```cpp
#include "module_image_lief.hpp"

#if defined(WITNESS_LIEF_ENABLED)

#include <algorithm>
#include <limits>
#include <span>

namespace w1replay {

namespace {

std::span<const std::byte> as_byte_span(LIEF::span<const uint8_t> data) {
  return std::as_bytes(std::span<const uint8_t>(data.data(), data.size()));
}

bool build_elf_layout(const LIEF::ELF::Binary& elf, image_layout& layout, std::string& error) {
  uint64_t link_base = std::numeric_limits<uint64_t>::max();
  layout.ranges.clear();

  for (const LIEF::ELF::Segment& segment : elf.segments()) {
    if (!segment.is_load()) {
      continue;
    }
    if (segment.virtual_size() == 0) {
      continue;
    }
    link_base = std::min(link_base, segment.virtual_address());
  }

  if (link_base == std::numeric_limits<uint64_t>::max()) {
    error = "no loadable segments";
    return false;
  }

  layout.link_base = link_base;
  for (const LIEF::ELF::Segment& segment : elf.segments()) {
    if (!segment.is_load()) {
      continue;
    }
    const uint64_t mem_size = segment.virtual_size();
    if (mem_size == 0) {
      continue;
    }
    image_range range{};
    range.va_start = segment.virtual_address();
    range.mem_size = mem_size;
    range.file_bytes = as_byte_span(segment.content());
    layout.ranges.push_back(range);
  }

  std::sort(layout.ranges.begin(), layout.ranges.end(), [](const image_range& a, const image_range& b) {
    return a.va_start < b.va_start;
  });
  return true;
}

bool build_macho_layout(const LIEF::MachO::Binary& macho, image_layout& layout, std::string& error) {
  uint64_t link_base = std::numeric_limits<uint64_t>::max();
  layout.ranges.clear();

  for (const LIEF::MachO::SegmentCommand& segment : macho.segments()) {
    if (segment.name() == "__PAGEZERO") {
      continue;
    }
    const uint64_t mem_size = segment.virtual_size();
    if (mem_size == 0) {
      continue;
    }
    link_base = std::min(link_base, segment.virtual_address());
  }

  if (link_base == std::numeric_limits<uint64_t>::max()) {
    error = "no loadable segments";
    return false;
  }

  layout.link_base = link_base;
  for (const LIEF::MachO::SegmentCommand& segment : macho.segments()) {
    if (segment.name() == "__PAGEZERO") {
      continue;
    }
    uint64_t mem_size = segment.virtual_size();
    if (mem_size == 0) {
      continue;
    }
    image_range range{};
    range.va_start = segment.virtual_address();
    range.mem_size = mem_size;
    range.file_bytes = as_byte_span(segment.content());
    layout.ranges.push_back(range);
  }

  std::sort(layout.ranges.begin(), layout.ranges.end(), [](const image_range& a, const image_range& b) {
    return a.va_start < b.va_start;
  });
  return true;
}

bool build_pe_layout(const LIEF::PE::Binary& pe, image_layout& layout, std::string& error) {
  layout.link_base = 0;
  layout.ranges.clear();

  for (const LIEF::PE::Section& section : pe.sections()) {
    auto content = section.content();
    uint64_t mem_size = std::max<uint64_t>(section.virtual_size(), content.size());
    if (mem_size == 0) {
      continue;
    }
    image_range range{};
    range.va_start = section.virtual_address();
    range.mem_size = mem_size;
    range.file_bytes = as_byte_span(content);
    layout.ranges.push_back(range);
  }

  if (layout.ranges.empty()) {
    error = "no sections";
    return false;
  }

  std::sort(layout.ranges.begin(), layout.ranges.end(), [](const image_range& a, const image_range& b) {
    return a.va_start < b.va_start;
  });
  return true;
}

} // namespace

bool build_image_layout(const LIEF::Binary& binary, image_layout& layout, std::string& error) {
  switch (binary.format()) {
  case LIEF::Binary::FORMATS::ELF: {
    auto* elf = dynamic_cast<const LIEF::ELF::Binary*>(&binary);
    if (!elf) {
      error = "invalid ELF binary";
      return false;
    }
    return build_elf_layout(*elf, layout, error);
  }
  case LIEF::Binary::FORMATS::MACHO: {
    auto* macho = dynamic_cast<const LIEF::MachO::Binary*>(&binary);
    if (!macho) {
      error = "invalid Mach-O binary";
      return false;
    }
    return build_macho_layout(*macho, layout, error);
  }
  case LIEF::Binary::FORMATS::PE: {
    auto* pe = dynamic_cast<const LIEF::PE::Binary*>(&binary);
    if (!pe) {
      error = "invalid PE binary";
      return false;
    }
    return build_pe_layout(*pe, layout, error);
  }
  default:
    error = "unsupported binary format";
    return false;
  }
}

} // namespace w1replay

#endif

```

`src/w1replay/modules/module_image_lief.hpp`:

```hpp
#pragma once

#include "module_image.hpp"

#if defined(WITNESS_LIEF_ENABLED)
#include <LIEF/LIEF.hpp>
#include <string>

namespace w1replay {

bool build_image_layout(const LIEF::Binary& binary, image_layout& layout, std::string& error);

} // namespace w1replay
#endif

```

`src/w1replay/modules/path_resolver.cpp`:

```cpp
#include "path_resolver.hpp"

#include <filesystem>

#include "w1rewind/format/trace_format.hpp"

namespace w1replay {

namespace {

std::string basename_for_path(std::string_view path) {
  if (path.empty()) {
    return {};
  }
  size_t end = path.find_last_not_of("/\\");
  if (end == std::string_view::npos) {
    return {};
  }
  size_t start = path.find_last_of("/\\", end);
  if (start == std::string_view::npos) {
    return std::string(path.substr(0, end + 1));
  }
  return std::string(path.substr(start + 1, end - start));
}

bool parse_mapping(const std::string& mapping, std::string& name, std::string& path) {
  auto eq_pos = mapping.find('=');
  if (eq_pos == std::string::npos || eq_pos == 0 || eq_pos + 1 >= mapping.size()) {
    return false;
  }
  name = mapping.substr(0, eq_pos);
  path = mapping.substr(eq_pos + 1);
  return !(name.empty() || path.empty());
}

} // namespace

default_module_path_resolver::default_module_path_resolver(
    std::vector<std::string> module_mappings, std::vector<std::string> module_dirs
)
    : module_dirs_(std::move(module_dirs)) {
  overrides_.reserve(module_mappings.size());
  for (const auto& mapping : module_mappings) {
    std::string name;
    std::string path;
    if (!parse_mapping(mapping, name, path)) {
      continue;
    }
    overrides_[name] = std::move(path);
  }
}

std::optional<std::string> default_module_path_resolver::resolve_module_path(
    const w1::rewind::module_record& module
) const {
  if (module.path.empty()) {
    return std::nullopt;
  }
  return resolve_name(module.path);
}

std::optional<std::string> default_module_path_resolver::resolve_region_name(std::string_view recorded_name) const {
  if (recorded_name.empty()) {
    return std::nullopt;
  }
  return resolve_name(recorded_name);
}

std::optional<std::string> default_module_path_resolver::resolve_name(std::string_view name) const {
  std::string module_name = basename_for_path(name);
  if (module_name.empty()) {
    return std::nullopt;
  }

  auto it = overrides_.find(module_name);
  if (it != overrides_.end()) {
    return it->second;
  }

  for (const auto& dir : module_dirs_) {
    if (dir.empty()) {
      continue;
    }
    std::filesystem::path candidate = std::filesystem::path(dir) / module_name;
    std::error_code ec;
    if (std::filesystem::exists(candidate, ec) && std::filesystem::is_regular_file(candidate, ec)) {
      return candidate.string();
    }
  }

  return std::nullopt;
}

std::unique_ptr<module_path_resolver> make_module_path_resolver(
    std::vector<std::string> module_mappings, std::vector<std::string> module_dirs
) {
  return std::make_unique<default_module_path_resolver>(std::move(module_mappings), std::move(module_dirs));
}

} // namespace w1replay

```

`src/w1replay/modules/path_resolver.hpp`:

```hpp
#pragma once

#include <memory>
#include <optional>
#include <string>
#include <string_view>
#include <unordered_map>
#include <vector>

namespace w1::rewind {
struct module_record;
}

namespace w1replay {

class module_path_resolver {
public:
  virtual ~module_path_resolver() = default;
  virtual std::optional<std::string> resolve_module_path(const w1::rewind::module_record& module) const = 0;
  virtual std::optional<std::string> resolve_region_name(std::string_view recorded_name) const = 0;
};

class default_module_path_resolver final : public module_path_resolver {
public:
  default_module_path_resolver(std::vector<std::string> module_mappings, std::vector<std::string> module_dirs);

  std::optional<std::string> resolve_module_path(const w1::rewind::module_record& module) const override;
  std::optional<std::string> resolve_region_name(std::string_view recorded_name) const override;

private:
  std::optional<std::string> resolve_name(std::string_view name) const;

  std::vector<std::string> module_dirs_;
  std::unordered_map<std::string, std::string> overrides_;
};

std::unique_ptr<module_path_resolver> make_module_path_resolver(
    std::vector<std::string> module_mappings, std::vector<std::string> module_dirs
);

} // namespace w1replay

```

`src/w1replay/trace_loader/trace_loader.cpp`:

```cpp
#include "trace_loader.hpp"

#include <filesystem>

#include <redlog.hpp>

#include "w1rewind/replay/replay_context_builder.hpp"
#include "w1rewind/trace/trace_reader.hpp"

namespace w1replay::trace_loader {

namespace {

bool path_exists(const std::filesystem::path& path) {
  std::error_code error;
  return std::filesystem::exists(path, error);
}

} // namespace

bool load_trace(const trace_load_options& options, trace_load_result& out) {
  out = trace_load_result{};
  out.error.clear();

  if (options.trace_path.empty()) {
    out.error = "trace path required";
    return false;
  }

  auto stream = std::make_shared<w1::rewind::trace_reader>(options.trace_path);
  if (!stream->open()) {
    out.error = stream->error().empty() ? "failed to open trace" : std::string(stream->error());
    return false;
  }

  w1::rewind::replay_context context;
  std::string context_error;
  if (!w1::rewind::build_replay_context(*stream, context, context_error)) {
    stream->close();
    out.error = context_error.empty() ? "failed to build replay context" : context_error;
    return false;
  }

  stream->close();

  w1::rewind::trace_index index;
  w1::rewind::trace_index_options index_options;
  std::string index_error;
  if (!w1::rewind::ensure_trace_index(
          std::filesystem::path(options.trace_path), std::filesystem::path(options.index_path), index_options, index,
          index_error, options.auto_build_index
      )) {
    out.error = index_error.empty() ? "failed to load trace index" : index_error;
    return false;
  }

  std::shared_ptr<w1::rewind::replay_checkpoint_index> checkpoint_ptr;
  bool wants_checkpoint = !options.checkpoint_path.empty() || options.checkpoint_stride > 0;
  if (wants_checkpoint) {
    std::filesystem::path checkpoint_path = options.checkpoint_path.empty()
                                                ? w1::rewind::default_replay_checkpoint_path(options.trace_path)
                                                : options.checkpoint_path;
    bool checkpoint_exists = path_exists(checkpoint_path);

    auto checkpoint = std::make_shared<w1::rewind::replay_checkpoint_index>();
    std::string checkpoint_error;

    if (checkpoint_exists) {
      if (!w1::rewind::load_replay_checkpoint(checkpoint_path.string(), *checkpoint, checkpoint_error)) {
        if (!options.auto_build_checkpoint || options.checkpoint_stride == 0) {
          out.error = checkpoint_error.empty() ? "failed to load checkpoints" : checkpoint_error;
          return false;
        }
        checkpoint_exists = false;
      }
    }

    if (!checkpoint_exists) {
      if (!options.auto_build_checkpoint) {
        out.error = "checkpoint file missing";
        return false;
      }
      if (options.checkpoint_stride == 0) {
        out.error = "checkpoint stride required";
        return false;
      }

      w1::rewind::replay_checkpoint_config config{};
      config.trace_path = options.trace_path;
      config.output_path = checkpoint_path.string();
      config.stride = options.checkpoint_stride;
      config.include_memory = options.checkpoint_include_memory;

      if (!w1::rewind::build_replay_checkpoint(config, checkpoint.get(), checkpoint_error)) {
        out.error = checkpoint_error.empty() ? "failed to build checkpoints" : checkpoint_error;
        return false;
      }
    }

    checkpoint_ptr = std::move(checkpoint);
  }

  out.stream = std::move(stream);
  out.index = std::make_shared<w1::rewind::trace_index>(std::move(index));
  out.checkpoint = std::move(checkpoint_ptr);
  out.context = std::move(context);
  return true;
}

} // namespace w1replay::trace_loader

```

`src/w1replay/trace_loader/trace_loader.hpp`:

```hpp
#pragma once

#include <memory>
#include <string>

#include "w1rewind/replay/replay_context.hpp"
#include "w1rewind/trace/record_stream.hpp"
#include "w1rewind/trace/replay_checkpoint.hpp"
#include "w1rewind/trace/trace_index.hpp"

namespace w1replay::trace_loader {

struct trace_load_options {
  std::string trace_path;
  std::string index_path;
  std::string checkpoint_path;
  bool auto_build_index = true;
  bool auto_build_checkpoint = true;
  uint32_t checkpoint_stride = 0;
  bool checkpoint_include_memory = false;
};

struct trace_load_result {
  std::shared_ptr<w1::rewind::trace_record_stream> stream;
  std::shared_ptr<w1::rewind::trace_index> index;
  std::shared_ptr<w1::rewind::replay_checkpoint_index> checkpoint;
  w1::rewind::replay_context context;
  std::string error;
};

bool load_trace(const trace_load_options& options, trace_load_result& out);

} // namespace w1replay::trace_loader

```

`src/w1rewind/CMakeLists.txt`:

```txt
w1_dep_redlog()
w1_dep_zstd()

w1_add_static_library(w1rewind_format
    format/register_numbering.cpp
    format/trace_validator.cpp
)
add_library(w1rewind::format ALIAS w1rewind_format)
add_library(w1::rewind::format ALIAS w1rewind_format)

target_include_directories(w1rewind_format
    PUBLIC $<BUILD_INTERFACE:${W1_SOURCE_DIR}/src>
)

target_link_libraries(w1rewind_format PUBLIC w1base redlog::redlog)

w1_add_static_library(w1rewind_trace
    trace/trace_reader.cpp
    trace/trace_index.cpp
    trace/replay_checkpoint.cpp
    trace/trace_file_writer.cpp
)
add_library(w1rewind::trace ALIAS w1rewind_trace)
add_library(w1::rewind::trace ALIAS w1rewind_trace)

target_link_libraries(w1rewind_trace PUBLIC w1base w1rewind_format redlog::redlog w1::zstd)

w1_add_static_library(w1rewind_record
    record/memory_map_utils.cpp
    record/trace_builder.cpp
)
add_library(w1rewind::record ALIAS w1rewind_record)
add_library(w1::rewind::record ALIAS w1rewind_record)

target_link_libraries(w1rewind_record PUBLIC w1base w1rewind_format redlog::redlog)

w1_add_static_library(w1rewind_replay
    replay/replay_context.cpp
    replay/replay_context_builder.cpp
    replay/memory_store.cpp
    replay/replay_state.cpp
    replay/replay_state_applier.cpp
    replay/replay_position.cpp
    replay/record_stream_cursor.cpp
    replay/flow_extractor.cpp
    replay/history_window.cpp
    replay/flow_cursor.cpp
    replay/stateful_flow_cursor.cpp
    replay/replay_instruction_cursor.cpp
    replay/replay_session.cpp
)
add_library(w1rewind::replay ALIAS w1rewind_replay)
add_library(w1::rewind::replay ALIAS w1rewind_replay)

target_link_libraries(w1rewind_replay PUBLIC w1base w1rewind_format w1rewind_trace redlog::redlog)

```

`src/w1rewind/format/register_metadata.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include <string>
#include <string_view>
#include <vector>

#include "w1base/arch_spec.hpp"
#include "w1rewind/format/register_numbering.hpp"
#include "w1rewind/format/trace_format.hpp"

namespace w1::rewind {

inline bool is_pc_name(std::string_view name) { return name == "pc" || name == "rip" || name == "eip"; }

inline bool is_sp_name(std::string_view name) { return name == "sp" || name == "rsp" || name == "esp"; }

inline bool is_flags_name(std::string_view name) {
  return name == "eflags" || name == "rflags" || name == "nzcv" || name == "cpsr";
}

inline bool is_fp_name(const w1::arch::arch_spec& arch, std::string_view name) {
  switch (arch.arch_mode) {
  case w1::arch::mode::x86_64:
    return name == "rbp";
  case w1::arch::mode::x86_32:
    return name == "ebp";
  case w1::arch::mode::aarch64:
    return name == "x29" || name == "fp";
  default:
    break;
  }
  return false;
}

inline uint16_t register_flags_for_name(const w1::arch::arch_spec& arch, std::string_view name) {
  uint16_t flags = 0;
  if (is_pc_name(name)) {
    flags |= register_flag_pc;
  }
  if (is_sp_name(name)) {
    flags |= register_flag_sp;
  }
  if (is_flags_name(name)) {
    flags |= register_flag_flags;
  }
  if (is_fp_name(arch, name)) {
    flags |= register_flag_fp;
  }
  return flags;
}

inline register_class register_class_for_name(std::string_view name) {
  if (is_flags_name(name)) {
    return register_class::flags;
  }
  return register_class::gpr;
}

inline register_value_kind register_value_kind_for_name(std::string_view name) {
  (void) name;
  return register_value_kind::u64;
}

inline uint32_t register_bitsize(const w1::arch::arch_spec& arch, std::string_view name, uint32_t pointer_size_bytes) {
  uint32_t pointer_bits = pointer_size_bytes * 8;
  if (arch.arch_mode == w1::arch::mode::x86_64 || arch.arch_mode == w1::arch::mode::x86_32) {
    if (name == "eflags" || name == "rflags") {
      return 32;
    }
    if (name == "fs" || name == "gs") {
      return 16;
    }
  }
  if (arch.arch_mode == w1::arch::mode::aarch64) {
    if (name == "nzcv") {
      return 32;
    }
  }
  if (arch.arch_mode == w1::arch::mode::arm || arch.arch_mode == w1::arch::mode::thumb) {
    if (name == "cpsr") {
      return 32;
    }
  }
  return pointer_bits;
}

inline std::string gdb_name_for_register(std::string_view name, const w1::arch::arch_spec& arch) {
  if (arch.arch_mode == w1::arch::mode::aarch64 && name == "nzcv") {
    return "cpsr";
  }
  if (name == "rflags") {
    return "eflags";
  }
  return std::string(name);
}

inline std::optional<uint16_t> find_register_id(const std::vector<std::string>& names, std::string_view target) {
  for (size_t i = 0; i < names.size(); ++i) {
    if (names[i] == target) {
      return static_cast<uint16_t>(i);
    }
  }
  return std::nullopt;
}

inline std::optional<uint16_t> resolve_sp_reg_id(
    const w1::arch::arch_spec& arch, const std::vector<std::string>& names
) {
  switch (arch.arch_mode) {
  case w1::arch::mode::x86_64:
    return find_register_id(names, "rsp");
  case w1::arch::mode::x86_32:
    return find_register_id(names, "esp");
  case w1::arch::mode::aarch64:
  case w1::arch::mode::arm:
  case w1::arch::mode::thumb:
    return find_register_id(names, "sp");
  default:
    break;
  }
  auto candidate = find_register_id(names, "sp");
  if (candidate.has_value()) {
    return candidate;
  }
  candidate = find_register_id(names, "rsp");
  if (candidate.has_value()) {
    return candidate;
  }
  return find_register_id(names, "esp");
}

inline std::optional<uint16_t> resolve_pc_reg_id(
    const w1::arch::arch_spec& arch, const std::vector<std::string>& names
) {
  switch (arch.arch_mode) {
  case w1::arch::mode::x86_64:
    return find_register_id(names, "rip");
  case w1::arch::mode::x86_32:
    return find_register_id(names, "eip");
  case w1::arch::mode::aarch64:
  case w1::arch::mode::arm:
  case w1::arch::mode::thumb:
    return find_register_id(names, "pc");
  default:
    break;
  }
  auto candidate = find_register_id(names, "pc");
  if (candidate.has_value()) {
    return candidate;
  }
  candidate = find_register_id(names, "rip");
  if (candidate.has_value()) {
    return candidate;
  }
  return find_register_id(names, "eip");
}

inline register_spec build_register_spec(
    const w1::arch::arch_spec& arch, uint16_t reg_id, std::string_view name, uint32_t pointer_size_bytes
) {
  register_spec spec{};
  spec.reg_id = reg_id;
  spec.name = std::string(name);
  spec.bits = static_cast<uint16_t>(register_bitsize(arch, spec.name, pointer_size_bytes));
  spec.flags = register_flags_for_name(arch, spec.name);
  spec.gdb_name = gdb_name_for_register(spec.name, arch);
  spec.reg_class = register_class_for_name(spec.name);
  spec.value_kind = register_value_kind_for_name(spec.name);
  if (auto numbering = lookup_register_numbering(arch, spec.gdb_name)) {
    spec.dwarf_regnum = numbering->dwarf_regnum;
    spec.ehframe_regnum = numbering->ehframe_regnum;
  }
  return spec;
}

} // namespace w1::rewind

```

`src/w1rewind/format/register_numbering.cpp`:

```cpp
#include "w1rewind/format/register_numbering.hpp"

#include <array>
#include <charconv>
#include <string_view>
#include <system_error>

namespace w1::rewind {
namespace {

// DWARF/EHFrame numbering derived from lldb register tables
std::optional<uint32_t> parse_prefixed_number(
    std::string_view name, char prefix, uint32_t min_value, uint32_t max_value
) {
  if (name.size() < 2 || name.front() != prefix) {
    return std::nullopt;
  }
  uint32_t value = 0;
  const char* start = name.data() + 1;
  const char* end = name.data() + name.size();
  auto [ptr, ec] = std::from_chars(start, end, value);
  if (ec != std::errc() || ptr != end) {
    return std::nullopt;
  }
  if (value < min_value || value > max_value) {
    return std::nullopt;
  }
  return value;
}

register_numbering make_numbering(uint32_t regnum) {
  register_numbering numbering{};
  numbering.dwarf_regnum = regnum;
  numbering.ehframe_regnum = regnum;
  return numbering;
}

std::optional<register_numbering> lookup_aarch64(std::string_view name) {
  if (name == "sp") {
    return make_numbering(31);
  }
  if (name == "pc") {
    return make_numbering(32);
  }
  if (name == "cpsr" || name == "nzcv") {
    return make_numbering(33);
  }
  if (name == "fp") {
    return make_numbering(29);
  }
  if (name == "lr") {
    return make_numbering(30);
  }
  if (auto value = parse_prefixed_number(name, 'x', 0, 31)) {
    return make_numbering(*value);
  }
  return std::nullopt;
}

std::optional<register_numbering> lookup_arm32(std::string_view name) {
  if (name == "sp") {
    return make_numbering(13);
  }
  if (name == "lr") {
    return make_numbering(14);
  }
  if (name == "pc") {
    return make_numbering(15);
  }
  if (name == "cpsr") {
    return make_numbering(16);
  }
  if (auto value = parse_prefixed_number(name, 'r', 0, 15)) {
    return make_numbering(*value);
  }
  return std::nullopt;
}

std::optional<register_numbering> lookup_x86_32(std::string_view name) {
  static constexpr std::array<std::pair<std::string_view, uint32_t>, 10> kMap = {{
      {"eax", 0},
      {"ecx", 1},
      {"edx", 2},
      {"ebx", 3},
      {"esp", 4},
      {"ebp", 5},
      {"esi", 6},
      {"edi", 7},
      {"eip", 8},
      {"eflags", 9},
  }};
  for (const auto& [reg_name, regnum] : kMap) {
    if (name == reg_name) {
      return make_numbering(regnum);
    }
  }
  return std::nullopt;
}

std::optional<register_numbering> lookup_x86_64(std::string_view name) {
  static constexpr std::array<std::pair<std::string_view, uint32_t>, 25> kMap = {{
      {"rax", 0},  {"rdx", 1},  {"rcx", 2},  {"rbx", 3},     {"rsi", 4},     {"rdi", 5},  {"rbp", 6},
      {"rsp", 7},  {"r8", 8},   {"r9", 9},   {"r10", 10},    {"r11", 11},    {"r12", 12}, {"r13", 13},
      {"r14", 14}, {"r15", 15}, {"rip", 16}, {"rflags", 49}, {"eflags", 49}, {"es", 50},  {"cs", 51},
      {"ss", 52},  {"ds", 53},  {"fs", 54},  {"gs", 55},
  }};
  for (const auto& [reg_name, regnum] : kMap) {
    if (name == reg_name) {
      return make_numbering(regnum);
    }
  }
  return std::nullopt;
}

} // namespace

std::optional<register_numbering> lookup_register_numbering(const w1::arch::arch_spec& arch, std::string_view name) {
  switch (arch.arch_mode) {
  case w1::arch::mode::aarch64:
    return lookup_aarch64(name);
  case w1::arch::mode::arm:
  case w1::arch::mode::thumb:
    return lookup_arm32(name);
  case w1::arch::mode::x86_64:
    return lookup_x86_64(name);
  case w1::arch::mode::x86_32:
    return lookup_x86_32(name);
  default:
    break;
  }
  return std::nullopt;
}

} // namespace w1::rewind

```

`src/w1rewind/format/register_numbering.hpp`:

```hpp
#pragma once

#include <optional>
#include <string_view>

#include "w1base/arch_spec.hpp"
#include "w1rewind/format/trace_format.hpp"

namespace w1::rewind {

struct register_numbering {
  uint32_t dwarf_regnum = k_register_regnum_unknown;
  uint32_t ehframe_regnum = k_register_regnum_unknown;
};

std::optional<register_numbering> lookup_register_numbering(const w1::arch::arch_spec& arch, std::string_view name);

} // namespace w1::rewind

```

`src/w1rewind/format/trace_codec.hpp`:

```hpp
#pragma once

#include <limits>

#include <redlog.hpp>

#include "trace_format.hpp"
#include "trace_io.hpp"

namespace w1::rewind {

inline bool encode_target_info(const target_info_record& record, trace_buffer_writer& writer, redlog::logger& log) {
  if (!writer.write_string(record.os)) {
    log.err("trace string too long", redlog::field("length", record.os.size()));
    return false;
  }
  if (!writer.write_string(record.abi)) {
    log.err("trace string too long", redlog::field("length", record.abi.size()));
    return false;
  }
  if (!writer.write_string(record.cpu)) {
    log.err("trace string too long", redlog::field("length", record.cpu.size()));
    return false;
  }
  return true;
}

inline bool decode_target_info(trace_buffer_reader& reader, target_info_record& out) {
  if (!reader.read_string(out.os) || !reader.read_string(out.abi) || !reader.read_string(out.cpu)) {
    return false;
  }
  return true;
}

inline bool encode_target_environment(
    const target_environment_record& record, trace_buffer_writer& writer, redlog::logger& log
) {
  if (!writer.write_string(record.os_version)) {
    log.err("trace string too long", redlog::field("length", record.os_version.size()));
    return false;
  }
  if (!writer.write_string(record.os_build)) {
    log.err("trace string too long", redlog::field("length", record.os_build.size()));
    return false;
  }
  if (!writer.write_string(record.os_kernel)) {
    log.err("trace string too long", redlog::field("length", record.os_kernel.size()));
    return false;
  }
  if (!writer.write_string(record.hostname)) {
    log.err("trace string too long", redlog::field("length", record.hostname.size()));
    return false;
  }
  writer.write_u64(record.pid);
  writer.write_u32(record.addressing_bits);
  writer.write_u32(record.low_mem_addressing_bits);
  writer.write_u32(record.high_mem_addressing_bits);
  return true;
}

inline bool decode_target_environment(trace_buffer_reader& reader, target_environment_record& out) {
  if (!reader.read_string(out.os_version) || !reader.read_string(out.os_build) || !reader.read_string(out.os_kernel) ||
      !reader.read_string(out.hostname) || !reader.read_u64(out.pid) || !reader.read_u32(out.addressing_bits) ||
      !reader.read_u32(out.low_mem_addressing_bits) || !reader.read_u32(out.high_mem_addressing_bits)) {
    return false;
  }
  return true;
}

inline bool encode_register_spec(const register_spec_record& record, trace_buffer_writer& writer, redlog::logger& log) {
  if (record.registers.size() > std::numeric_limits<uint16_t>::max()) {
    log.err("register spec list too large", redlog::field("count", record.registers.size()));
    return false;
  }
  writer.write_u16(static_cast<uint16_t>(record.registers.size()));
  for (const auto& reg : record.registers) {
    writer.write_u16(reg.reg_id);
    writer.write_u16(reg.bits);
    writer.write_u16(reg.flags);
    writer.write_u8(static_cast<uint8_t>(reg.reg_class));
    writer.write_u8(static_cast<uint8_t>(reg.value_kind));
    writer.write_u32(reg.dwarf_regnum);
    writer.write_u32(reg.ehframe_regnum);
    if (!writer.write_string(reg.name)) {
      log.err("trace string too long", redlog::field("length", reg.name.size()));
      return false;
    }
    if (!writer.write_string(reg.gdb_name)) {
      log.err("trace string too long", redlog::field("length", reg.gdb_name.size()));
      return false;
    }
  }
  return true;
}

inline bool decode_register_spec(trace_buffer_reader& reader, register_spec_record& out) {
  uint16_t count = 0;
  if (!reader.read_u16(count)) {
    return false;
  }
  out.registers.reserve(count);
  for (uint16_t i = 0; i < count; ++i) {
    register_spec spec{};
    uint8_t reg_class = 0;
    uint8_t value_kind = 0;
    uint32_t dwarf_regnum = 0;
    uint32_t ehframe_regnum = 0;
    if (!reader.read_u16(spec.reg_id) || !reader.read_u16(spec.bits) || !reader.read_u16(spec.flags) ||
        !reader.read_u8(reg_class) || !reader.read_u8(value_kind) || !reader.read_u32(dwarf_regnum) ||
        !reader.read_u32(ehframe_regnum) || !reader.read_string(spec.name) || !reader.read_string(spec.gdb_name)) {
      return false;
    }
    spec.reg_class = static_cast<register_class>(reg_class);
    spec.value_kind = static_cast<register_value_kind>(value_kind);
    spec.dwarf_regnum = dwarf_regnum;
    spec.ehframe_regnum = ehframe_regnum;
    out.registers.push_back(std::move(spec));
  }
  return true;
}

inline bool encode_module_record(const module_record& module, trace_buffer_writer& writer, redlog::logger& log);
inline bool decode_module_record(trace_buffer_reader& reader, module_record& module);

inline bool encode_module_table(const module_table_record& record, trace_buffer_writer& writer, redlog::logger& log) {
  if (record.modules.size() > std::numeric_limits<uint32_t>::max()) {
    log.err("module table too large", redlog::field("count", record.modules.size()));
    return false;
  }
  writer.write_u32(static_cast<uint32_t>(record.modules.size()));
  for (const auto& module : record.modules) {
    if (!encode_module_record(module, writer, log)) {
      return false;
    }
  }
  return true;
}

inline bool encode_module_record(const module_record& module, trace_buffer_writer& writer, redlog::logger& log) {
  writer.write_u64(module.id);
  writer.write_u64(module.base);
  writer.write_u64(module.size);
  writer.write_u32(static_cast<uint32_t>(module.permissions));
  writer.write_u8(static_cast<uint8_t>(module.format));
  writer.write_u32(module.identity_age);
  writer.write_u32(module.flags);
  writer.write_u64(module.link_base);
  writer.write_u64(module.entry_point);
  if (!writer.write_string(module.identity)) {
    log.err("trace string too long", redlog::field("length", module.identity.size()));
    return false;
  }
  if (!writer.write_string(module.path)) {
    log.err("trace string too long", redlog::field("length", module.path.size()));
    return false;
  }
  return true;
}

inline bool encode_module_load(const module_load_record& record, trace_buffer_writer& writer, redlog::logger& log) {
  return encode_module_record(record.module, writer, log);
}

inline bool encode_module_unload(const module_unload_record& record, trace_buffer_writer& writer, redlog::logger& log) {
  writer.write_u64(record.module_id);
  writer.write_u64(record.base);
  writer.write_u64(record.size);
  if (!writer.write_string(record.path)) {
    log.err("trace string too long", redlog::field("length", record.path.size()));
    return false;
  }
  return true;
}

inline bool encode_memory_map(const memory_map_record& record, trace_buffer_writer& writer, redlog::logger& log) {
  if (record.regions.size() > std::numeric_limits<uint32_t>::max()) {
    log.err("memory map too large", redlog::field("count", record.regions.size()));
    return false;
  }
  writer.write_u32(static_cast<uint32_t>(record.regions.size()));
  for (const auto& region : record.regions) {
    writer.write_u64(region.base);
    writer.write_u64(region.size);
    writer.write_u32(static_cast<uint32_t>(region.permissions));
    writer.write_u64(region.image_id);
    if (!writer.write_string(region.name)) {
      log.err("trace string too long", redlog::field("length", region.name.size()));
      return false;
    }
  }
  return true;
}

inline bool decode_memory_map(trace_buffer_reader& reader, memory_map_record& out) {
  uint32_t count = 0;
  if (!reader.read_u32(count)) {
    return false;
  }
  out.regions.reserve(count);
  for (uint32_t i = 0; i < count; ++i) {
    memory_region_record region{};
    uint32_t perms = 0;
    if (!reader.read_u64(region.base) || !reader.read_u64(region.size) || !reader.read_u32(perms) ||
        !reader.read_u64(region.image_id) || !reader.read_string(region.name)) {
      return false;
    }
    region.permissions = static_cast<module_perm>(perms);
    out.regions.push_back(std::move(region));
  }
  return true;
}

inline bool decode_module_record(trace_buffer_reader& reader, module_record& module) {
  uint32_t perms = 0;
  uint32_t flags = 0;
  uint8_t format = 0;
  if (!reader.read_u64(module.id) || !reader.read_u64(module.base) || !reader.read_u64(module.size) ||
      !reader.read_u32(perms) || !reader.read_u8(format) || !reader.read_u32(module.identity_age) ||
      !reader.read_u32(flags) || !reader.read_u64(module.link_base) || !reader.read_u64(module.entry_point) ||
      !reader.read_string(module.identity) || !reader.read_string(module.path)) {
    return false;
  }
  module.permissions = static_cast<module_perm>(perms);
  module.format = static_cast<module_format>(format);
  module.flags = flags;
  return true;
}

inline bool decode_module_table(trace_buffer_reader& reader, module_table_record& out) {
  uint32_t count = 0;
  if (!reader.read_u32(count)) {
    return false;
  }
  out.modules.reserve(count);
  for (uint32_t i = 0; i < count; ++i) {
    module_record module{};
    if (!decode_module_record(reader, module)) {
      return false;
    }
    out.modules.push_back(std::move(module));
  }
  return true;
}

inline bool decode_module_load(trace_buffer_reader& reader, module_load_record& out) {
  module_record module{};
  if (!decode_module_record(reader, module)) {
    return false;
  }
  out.module = std::move(module);
  return true;
}

inline bool decode_module_unload(trace_buffer_reader& reader, module_unload_record& out) {
  if (!reader.read_u64(out.module_id) || !reader.read_u64(out.base) || !reader.read_u64(out.size) ||
      !reader.read_string(out.path)) {
    return false;
  }
  return true;
}

inline bool encode_thread_start(const thread_start_record& record, trace_buffer_writer& writer, redlog::logger& log) {
  writer.write_u64(record.thread_id);
  if (!writer.write_string(record.name)) {
    log.err("trace string too long", redlog::field("length", record.name.size()));
    return false;
  }
  return true;
}

inline bool decode_thread_start(trace_buffer_reader& reader, thread_start_record& out) {
  return reader.read_u64(out.thread_id) && reader.read_string(out.name);
}

inline bool encode_instruction(const instruction_record& record, trace_buffer_writer& writer) {
  writer.write_u64(record.sequence);
  writer.write_u64(record.thread_id);
  writer.write_u64(record.address);
  writer.write_u32(record.size);
  writer.write_u32(record.flags);
  return true;
}

inline bool decode_instruction(trace_buffer_reader& reader, instruction_record& out) {
  return reader.read_u64(out.sequence) && reader.read_u64(out.thread_id) && reader.read_u64(out.address) &&
         reader.read_u32(out.size) && reader.read_u32(out.flags);
}

inline bool encode_block_definition(const block_definition_record& record, trace_buffer_writer& writer) {
  writer.write_u64(record.block_id);
  writer.write_u64(record.address);
  writer.write_u32(record.size);
  writer.write_u32(record.flags);
  return true;
}

inline bool decode_block_definition(trace_buffer_reader& reader, block_definition_record& out) {
  return reader.read_u64(out.block_id) && reader.read_u64(out.address) && reader.read_u32(out.size) &&
         reader.read_u32(out.flags);
}

inline bool encode_block_exec(const block_exec_record& record, trace_buffer_writer& writer) {
  writer.write_u64(record.sequence);
  writer.write_u64(record.thread_id);
  writer.write_u64(record.block_id);
  return true;
}

inline bool decode_block_exec(trace_buffer_reader& reader, block_exec_record& out) {
  return reader.read_u64(out.sequence) && reader.read_u64(out.thread_id) && reader.read_u64(out.block_id);
}

inline bool encode_register_deltas(
    const register_delta_record& record, trace_buffer_writer& writer, redlog::logger& log
) {
  if (record.deltas.size() > std::numeric_limits<uint16_t>::max()) {
    log.err("register delta list too large", redlog::field("count", record.deltas.size()));
    return false;
  }
  writer.write_u64(record.sequence);
  writer.write_u64(record.thread_id);
  writer.write_u16(static_cast<uint16_t>(record.deltas.size()));
  for (const auto& delta : record.deltas) {
    writer.write_u16(delta.reg_id);
    writer.write_u64(delta.value);
  }
  return true;
}

inline bool decode_register_deltas(trace_buffer_reader& reader, register_delta_record& out) {
  uint16_t count = 0;
  if (!reader.read_u64(out.sequence) || !reader.read_u64(out.thread_id) || !reader.read_u16(count)) {
    return false;
  }
  out.deltas.reserve(count);
  for (uint16_t i = 0; i < count; ++i) {
    register_delta delta{};
    if (!reader.read_u16(delta.reg_id) || !reader.read_u64(delta.value)) {
      return false;
    }
    out.deltas.push_back(delta);
  }
  return true;
}

inline bool encode_register_bytes(
    const register_bytes_record& record, trace_buffer_writer& writer, redlog::logger& log
) {
  if (record.entries.size() > std::numeric_limits<uint16_t>::max()) {
    log.err("register bytes entry list too large", redlog::field("count", record.entries.size()));
    return false;
  }
  if (record.data.size() > std::numeric_limits<uint32_t>::max()) {
    log.err("register bytes data too large", redlog::field("size", record.data.size()));
    return false;
  }
  writer.write_u64(record.sequence);
  writer.write_u64(record.thread_id);
  writer.write_u16(static_cast<uint16_t>(record.entries.size()));
  for (const auto& entry : record.entries) {
    writer.write_u16(entry.reg_id);
    writer.write_u32(entry.offset);
    writer.write_u16(entry.size);
  }
  writer.write_u32(static_cast<uint32_t>(record.data.size()));
  if (!record.data.empty()) {
    writer.write_bytes(record.data.data(), record.data.size());
  }
  return true;
}

inline bool decode_register_bytes(trace_buffer_reader& reader, register_bytes_record& out) {
  uint16_t count = 0;
  uint32_t data_size = 0;
  if (!reader.read_u64(out.sequence) || !reader.read_u64(out.thread_id) || !reader.read_u16(count)) {
    return false;
  }
  out.entries.reserve(count);
  for (uint16_t i = 0; i < count; ++i) {
    register_bytes_entry entry{};
    if (!reader.read_u16(entry.reg_id) || !reader.read_u32(entry.offset) || !reader.read_u16(entry.size)) {
      return false;
    }
    out.entries.push_back(entry);
  }
  if (!reader.read_u32(data_size)) {
    return false;
  }
  if (data_size > 0) {
    if (!reader.read_bytes(out.data, data_size)) {
      return false;
    }
  }
  return true;
}

inline bool encode_memory_access(const memory_access_record& record, trace_buffer_writer& writer, redlog::logger& log) {
  if (record.data.size() > std::numeric_limits<uint32_t>::max()) {
    log.err("memory record data too large", redlog::field("size", record.data.size()));
    return false;
  }
  writer.write_u64(record.sequence);
  writer.write_u64(record.thread_id);
  writer.write_u8(static_cast<uint8_t>(record.kind));
  writer.write_u8(record.value_known ? 1 : 0);
  writer.write_u8(record.value_truncated ? 1 : 0);
  writer.write_u8(0);
  writer.write_u64(record.address);
  writer.write_u32(record.size);
  writer.write_u32(static_cast<uint32_t>(record.data.size()));
  if (!record.data.empty()) {
    writer.write_bytes(record.data.data(), record.data.size());
  }
  return true;
}

inline bool decode_memory_access(trace_buffer_reader& reader, memory_access_record& out) {
  uint8_t kind = 0;
  uint8_t value_known = 0;
  uint8_t value_truncated = 0;
  uint8_t reserved = 0;
  uint32_t data_size = 0;
  if (!reader.read_u64(out.sequence) || !reader.read_u64(out.thread_id) || !reader.read_u8(kind) ||
      !reader.read_u8(value_known) || !reader.read_u8(value_truncated) || !reader.read_u8(reserved) ||
      !reader.read_u64(out.address) || !reader.read_u32(out.size) || !reader.read_u32(data_size)) {
    return false;
  }
  out.kind = static_cast<memory_access_kind>(kind);
  out.value_known = value_known != 0;
  out.value_truncated = value_truncated != 0;
  (void) reserved;
  if (data_size > 0) {
    if (!reader.read_bytes(out.data, data_size)) {
      return false;
    }
  }
  return true;
}

inline bool encode_snapshot(const snapshot_record& record, trace_buffer_writer& writer, redlog::logger& log) {
  if (record.registers.size() > std::numeric_limits<uint16_t>::max()) {
    log.err("snapshot register list too large", redlog::field("count", record.registers.size()));
    return false;
  }
  if (record.stack_segments.size() > std::numeric_limits<uint16_t>::max()) {
    log.err("snapshot stack segment list too large", redlog::field("count", record.stack_segments.size()));
    return false;
  }
  writer.write_u64(record.snapshot_id);
  writer.write_u64(record.sequence);
  writer.write_u64(record.thread_id);
  writer.write_u16(static_cast<uint16_t>(record.registers.size()));
  for (const auto& reg : record.registers) {
    writer.write_u16(reg.reg_id);
    writer.write_u64(reg.value);
  }
  writer.write_u16(static_cast<uint16_t>(record.stack_segments.size()));
  for (const auto& segment : record.stack_segments) {
    if (segment.size != segment.bytes.size()) {
      log.err("snapshot stack segment size mismatch", redlog::field("size", segment.size));
      return false;
    }
    writer.write_u64(segment.base);
    writer.write_u64(segment.size);
    if (!segment.bytes.empty()) {
      writer.write_bytes(segment.bytes.data(), segment.bytes.size());
    }
  }
  if (!writer.write_string(record.reason)) {
    log.err("trace string too long", redlog::field("length", record.reason.size()));
    return false;
  }
  return true;
}

inline bool decode_snapshot(trace_buffer_reader& reader, snapshot_record& out) {
  uint16_t reg_count = 0;
  uint16_t segment_count = 0;
  if (!reader.read_u64(out.snapshot_id) || !reader.read_u64(out.sequence) || !reader.read_u64(out.thread_id) ||
      !reader.read_u16(reg_count)) {
    return false;
  }
  out.registers.reserve(reg_count);
  for (uint16_t i = 0; i < reg_count; ++i) {
    register_delta delta{};
    if (!reader.read_u16(delta.reg_id) || !reader.read_u64(delta.value)) {
      return false;
    }
    out.registers.push_back(delta);
  }
  if (!reader.read_u16(segment_count)) {
    return false;
  }
  out.stack_segments.reserve(segment_count);
  for (uint16_t i = 0; i < segment_count; ++i) {
    stack_segment segment{};
    if (!reader.read_u64(segment.base) || !reader.read_u64(segment.size)) {
      return false;
    }
    if (segment.size > 0) {
      if (!reader.read_bytes(segment.bytes, static_cast<size_t>(segment.size))) {
        return false;
      }
    }
    out.stack_segments.push_back(std::move(segment));
  }
  if (!reader.read_string(out.reason)) {
    return false;
  }
  return true;
}

inline bool encode_thread_end(const thread_end_record& record, trace_buffer_writer& writer) {
  writer.write_u64(record.thread_id);
  return true;
}

inline bool decode_thread_end(trace_buffer_reader& reader, thread_end_record& out) {
  return reader.read_u64(out.thread_id);
}

} // namespace w1::rewind

```

`src/w1rewind/format/trace_format.hpp`:

```hpp
#pragma once

#include <array>
#include <cstdint>
#include <string>
#include <variant>
#include <vector>

#include "w1base/arch_spec.hpp"

namespace w1::rewind {

constexpr uint16_t k_trace_version = 17;
constexpr std::array<uint8_t, 8> k_trace_magic = {'W', '1', 'R', 'W', 'N', 'D', '1', '1'};
constexpr uint32_t k_trace_chunk_bytes = 8 * 1024 * 1024;
constexpr uint32_t k_register_regnum_unknown = 0xFFFFFFFFu;

enum class module_perm : uint32_t {
  none = 0,
  read = 1u << 0,
  write = 1u << 1,
  exec = 1u << 2,
};

enum class module_format : uint8_t {
  unknown = 0,
  elf = 1,
  macho = 2,
  pe = 3,
};

inline module_perm operator|(module_perm lhs, module_perm rhs) {
  return static_cast<module_perm>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

inline module_perm operator&(module_perm lhs, module_perm rhs) {
  return static_cast<module_perm>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}

enum trace_flags : uint64_t {
  trace_flag_instructions = 1ull << 0,
  trace_flag_register_deltas = 1ull << 1,
  trace_flag_memory_access = 1ull << 2,
  trace_flag_memory_values = 1ull << 3,
  trace_flag_snapshots = 1ull << 4,
  trace_flag_stack_snapshot = 1ull << 5,
  trace_flag_blocks = 1ull << 6,
};

enum class trace_compression : uint32_t {
  none = 0,
  zstd = 1,
};

enum class record_kind : uint16_t {
  module_table = 2,
  thread_start = 3,
  instruction = 4,
  register_deltas = 5,
  memory_access = 6,
  snapshot = 7,
  thread_end = 8,
  block_definition = 9,
  block_exec = 10,
  target_info = 11,
  register_spec = 12,
  memory_map = 13,
  register_bytes = 14,
  target_environment = 15,
  module_load = 16,
  module_unload = 17,
};

struct trace_header {
  uint16_t version = k_trace_version;
  w1::arch::arch_spec arch{};
  uint64_t flags = 0;
  trace_compression compression = trace_compression::none;
  uint32_t chunk_size = 0;
};

struct record_header {
  record_kind kind = record_kind::instruction;
  uint16_t flags = 0;
  uint32_t size = 0;
};

struct target_info_record {
  std::string os;
  std::string abi;
  std::string cpu;
};

struct target_environment_record {
  std::string os_version;
  std::string os_build;
  std::string os_kernel;
  std::string hostname;
  uint64_t pid = 0;
  uint32_t addressing_bits = 0;
  uint32_t low_mem_addressing_bits = 0;
  uint32_t high_mem_addressing_bits = 0;
};

enum register_flags : uint16_t {
  register_flag_pc = 1u << 0,
  register_flag_sp = 1u << 1,
  register_flag_flags = 1u << 2,
  register_flag_fp = 1u << 3,
};

enum class register_class : uint8_t {
  unknown = 0,
  gpr = 1,
  fpr = 2,
  simd = 3,
  flags = 4,
  system = 5,
};

enum class register_value_kind : uint8_t {
  unknown = 0,
  u64 = 1,
  bytes = 2,
};

struct register_spec {
  uint16_t reg_id = 0;
  std::string name;
  uint16_t bits = 0;
  uint16_t flags = 0;
  std::string gdb_name;
  register_class reg_class = register_class::unknown;
  register_value_kind value_kind = register_value_kind::unknown;
  uint32_t dwarf_regnum = k_register_regnum_unknown;
  uint32_t ehframe_regnum = k_register_regnum_unknown;
};

struct register_spec_record {
  std::vector<register_spec> registers;
};

enum module_record_flags : uint32_t {
  module_record_flag_link_base_valid = 1u << 0,
  module_record_flag_main = 1u << 1,
  module_record_flag_file_backed = 1u << 2,
  module_record_flag_entry_point_valid = 1u << 3,
};

struct module_record {
  uint64_t id = 0;
  uint64_t base = 0;
  uint64_t size = 0;
  module_perm permissions = module_perm::none;
  module_format format = module_format::unknown;
  std::string identity;
  uint32_t identity_age = 0;
  uint32_t flags = 0;
  uint64_t link_base = 0;
  uint64_t entry_point = 0;
  std::string path;
};

struct module_table_record {
  std::vector<module_record> modules;
};

struct module_load_record {
  module_record module;
};

struct module_unload_record {
  uint64_t module_id = 0;
  uint64_t base = 0;
  uint64_t size = 0;
  std::string path;
};

struct memory_region_record {
  uint64_t base = 0;
  uint64_t size = 0;
  module_perm permissions = module_perm::none;
  uint64_t image_id = 0;
  std::string name;
};

struct memory_map_record {
  std::vector<memory_region_record> regions;
};

struct thread_start_record {
  uint64_t thread_id = 0;
  std::string name;
};

struct instruction_record {
  uint64_t sequence = 0;
  uint64_t thread_id = 0;
  uint64_t address = 0;
  uint32_t size = 0;
  uint32_t flags = 0;
};

enum instruction_flags : uint32_t {
  trace_inst_flag_mode_valid = 1u << 0,
  trace_inst_flag_thumb = 1u << 1,
};

struct block_definition_record {
  uint64_t block_id = 0;
  uint64_t address = 0;
  uint32_t size = 0;
  uint32_t flags = 0;
};

enum block_flags : uint32_t {
  trace_block_flag_mode_valid = 1u << 0,
  trace_block_flag_thumb = 1u << 1,
};

struct block_exec_record {
  uint64_t sequence = 0;
  uint64_t thread_id = 0;
  uint64_t block_id = 0;
};

struct register_delta {
  uint16_t reg_id = 0;
  uint64_t value = 0;
};

struct register_delta_record {
  uint64_t sequence = 0;
  uint64_t thread_id = 0;
  std::vector<register_delta> deltas;
};

struct register_bytes_entry {
  uint16_t reg_id = 0;
  uint32_t offset = 0;
  uint16_t size = 0;
};

struct register_bytes_record {
  uint64_t sequence = 0;
  uint64_t thread_id = 0;
  std::vector<register_bytes_entry> entries;
  std::vector<uint8_t> data;
};

enum class memory_access_kind : uint8_t { read = 1, write = 2 };

struct memory_access_record {
  uint64_t sequence = 0;
  uint64_t thread_id = 0;
  memory_access_kind kind = memory_access_kind::read;
  uint64_t address = 0;
  uint32_t size = 0;
  bool value_known = false;
  bool value_truncated = false;
  std::vector<uint8_t> data;
};

struct stack_segment {
  uint64_t base = 0;
  uint64_t size = 0;
  std::vector<uint8_t> bytes;
};

struct snapshot_record {
  uint64_t snapshot_id = 0;
  uint64_t sequence = 0;
  uint64_t thread_id = 0;
  std::vector<register_delta> registers;
  std::vector<stack_segment> stack_segments;
  std::string reason;
};

struct thread_end_record {
  uint64_t thread_id = 0;
};

using trace_record = std::variant<
    target_info_record, target_environment_record, register_spec_record, module_table_record, module_load_record,
    module_unload_record, memory_map_record, thread_start_record, instruction_record, block_definition_record,
    block_exec_record, register_delta_record, register_bytes_record, memory_access_record, snapshot_record,
    thread_end_record>;

} // namespace w1::rewind

```

`src/w1rewind/format/trace_io.hpp`:

```hpp
#pragma once

#include <array>
#include <cstddef>
#include <cstdint>
#include <istream>
#include <ostream>
#include <span>
#include <string>
#include <vector>

namespace w1::rewind {

constexpr size_t k_trace_string_max = 0xFFFFu;

class trace_buffer_writer {
public:
  explicit trace_buffer_writer(std::vector<uint8_t>& out) : out_(out) {}

  void write_u8(uint8_t value) { out_.push_back(value); }

  void write_u16(uint16_t value) {
    out_.push_back(static_cast<uint8_t>(value & 0xFFu));
    out_.push_back(static_cast<uint8_t>((value >> 8) & 0xFFu));
  }

  void write_u32(uint32_t value) {
    for (size_t i = 0; i < 4; ++i) {
      out_.push_back(static_cast<uint8_t>((value >> (i * 8)) & 0xFFu));
    }
  }

  void write_u64(uint64_t value) {
    for (size_t i = 0; i < 8; ++i) {
      out_.push_back(static_cast<uint8_t>((value >> (i * 8)) & 0xFFu));
    }
  }

  void write_bytes(const uint8_t* data, size_t size) {
    if (size == 0) {
      return;
    }
    out_.insert(out_.end(), data, data + static_cast<std::ptrdiff_t>(size));
  }

  bool write_string(const std::string& value) {
    if (value.size() > k_trace_string_max) {
      return false;
    }
    write_u16(static_cast<uint16_t>(value.size()));
    if (!value.empty()) {
      const auto* data = reinterpret_cast<const uint8_t*>(value.data());
      write_bytes(data, value.size());
    }
    return true;
  }

private:
  std::vector<uint8_t>& out_;
};

class trace_buffer_reader {
public:
  explicit trace_buffer_reader(std::span<const uint8_t> data) : data_(data) {}

  bool read_u8(uint8_t& value) { return read_scalar(value); }
  bool read_u16(uint16_t& value) { return read_scalar(value); }
  bool read_u32(uint32_t& value) { return read_scalar(value); }
  bool read_u64(uint64_t& value) { return read_scalar(value); }

  bool read_string(std::string& value) {
    uint16_t len = 0;
    if (!read_u16(len)) {
      return false;
    }
    if (cursor_ + len > data_.size()) {
      return false;
    }
    value.assign(reinterpret_cast<const char*>(data_.data() + cursor_), len);
    cursor_ += len;
    return true;
  }

  bool read_bytes(std::vector<uint8_t>& out, size_t size) {
    if (cursor_ + size > data_.size()) {
      return false;
    }
    auto start = data_.begin() + static_cast<std::ptrdiff_t>(cursor_);
    auto end = start + static_cast<std::ptrdiff_t>(size);
    out.assign(start, end);
    cursor_ += size;
    return true;
  }

  size_t remaining() const { return data_.size() - cursor_; }

private:
  template <typename T> bool read_scalar(T& value) {
    constexpr size_t size = sizeof(T);
    if (cursor_ + size > data_.size()) {
      return false;
    }
    T out = 0;
    for (size_t i = 0; i < size; ++i) {
      out |= static_cast<T>(data_[cursor_ + i]) << (8 * i);
    }
    value = out;
    cursor_ += size;
    return true;
  }

  std::span<const uint8_t> data_;
  size_t cursor_ = 0;
};

inline bool read_stream_bytes(std::istream& in, void* data, size_t size) {
  if (size == 0) {
    return true;
  }
  in.read(reinterpret_cast<char*>(data), static_cast<std::streamsize>(size));
  return in.gcount() == static_cast<std::streamsize>(size);
}

inline bool read_stream_u16(std::istream& in, uint16_t& value) {
  std::array<uint8_t, 2> buf{};
  if (!read_stream_bytes(in, buf.data(), buf.size())) {
    return false;
  }
  value = static_cast<uint16_t>(buf[0] | (static_cast<uint16_t>(buf[1]) << 8));
  return true;
}

inline bool read_stream_u32(std::istream& in, uint32_t& value) {
  std::array<uint8_t, 4> buf{};
  if (!read_stream_bytes(in, buf.data(), buf.size())) {
    return false;
  }
  value = static_cast<uint32_t>(buf[0]) | (static_cast<uint32_t>(buf[1]) << 8) | (static_cast<uint32_t>(buf[2]) << 16) |
          (static_cast<uint32_t>(buf[3]) << 24);
  return true;
}

inline bool read_stream_u64(std::istream& in, uint64_t& value) {
  std::array<uint8_t, 8> buf{};
  if (!read_stream_bytes(in, buf.data(), buf.size())) {
    return false;
  }
  value = 0;
  for (size_t i = 0; i < buf.size(); ++i) {
    value |= static_cast<uint64_t>(buf[i]) << (8 * i);
  }
  return true;
}

inline bool write_stream_bytes(std::ostream& out, const void* data, size_t size) {
  if (size == 0) {
    return true;
  }
  out.write(reinterpret_cast<const char*>(data), static_cast<std::streamsize>(size));
  return out.good();
}

inline bool write_stream_u16(std::ostream& out, uint16_t value) {
  std::array<uint8_t, 2> buf{};
  buf[0] = static_cast<uint8_t>(value & 0xFFu);
  buf[1] = static_cast<uint8_t>((value >> 8) & 0xFFu);
  return write_stream_bytes(out, buf.data(), buf.size());
}

inline bool write_stream_u32(std::ostream& out, uint32_t value) {
  std::array<uint8_t, 4> buf{};
  for (size_t i = 0; i < buf.size(); ++i) {
    buf[i] = static_cast<uint8_t>((value >> (i * 8)) & 0xFFu);
  }
  return write_stream_bytes(out, buf.data(), buf.size());
}

inline bool write_stream_u64(std::ostream& out, uint64_t value) {
  std::array<uint8_t, 8> buf{};
  for (size_t i = 0; i < buf.size(); ++i) {
    buf[i] = static_cast<uint8_t>((value >> (i * 8)) & 0xFFu);
  }
  return write_stream_bytes(out, buf.data(), buf.size());
}

} // namespace w1::rewind

```

`src/w1rewind/format/trace_validator.cpp`:

```cpp
#include "trace_validator.hpp"

#include <algorithm>

namespace w1::rewind {

bool validate_trace_arch(const w1::arch::arch_spec& arch, std::string& error) {
  if (arch.arch_family == w1::arch::family::unknown || arch.arch_mode == w1::arch::mode::unknown) {
    error = "trace arch spec missing";
    return false;
  }
  if (arch.pointer_bits == 0 || (arch.pointer_bits % 8) != 0) {
    error = "trace pointer bits invalid";
    return false;
  }
  if (arch.arch_byte_order == w1::arch::byte_order::unknown) {
    error = "trace byte order missing";
    return false;
  }
  return true;
}

bool normalize_register_specs(
    std::vector<register_spec>& specs, std::string& error, register_spec_validation_options options
) {
  if (specs.empty()) {
    if (options.allow_empty) {
      return true;
    }
    error = "register specs missing";
    return false;
  }

  uint16_t max_id = 0;
  for (const auto& spec : specs) {
    if (spec.name.empty()) {
      error = "register spec name missing";
      return false;
    }
    if (spec.bits == 0) {
      error = "register spec bits missing";
      return false;
    }
    max_id = std::max(max_id, spec.reg_id);
  }

  size_t expected = static_cast<size_t>(max_id) + 1;
  if (expected != specs.size()) {
    error = "register ids must be contiguous";
    return false;
  }

  std::vector<register_spec> ordered(expected);
  std::vector<bool> seen(expected, false);
  for (auto& spec : specs) {
    if (spec.reg_id >= expected) {
      error = "register id out of range";
      return false;
    }
    if (seen[spec.reg_id]) {
      error = "duplicate register id";
      return false;
    }
    seen[spec.reg_id] = true;
    ordered[spec.reg_id] = std::move(spec);
  }
  specs = std::move(ordered);
  return true;
}

} // namespace w1::rewind

```

`src/w1rewind/format/trace_validator.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>

#include "w1base/arch_spec.hpp"
#include "w1rewind/format/trace_format.hpp"

namespace w1::rewind {

struct register_spec_validation_options {
  bool allow_empty = false;
};

bool validate_trace_arch(const w1::arch::arch_spec& arch, std::string& error);
bool normalize_register_specs(
    std::vector<register_spec>& specs, std::string& error, register_spec_validation_options options = {}
);

} // namespace w1::rewind

```

`src/w1rewind/record/memory_map_utils.cpp`:

```cpp
#include "memory_map_utils.hpp"

#include <limits>

namespace w1::rewind {

namespace {
bool add_overflows(uint64_t base, uint64_t addend) { return base > std::numeric_limits<uint64_t>::max() - addend; }

uint64_t range_end(uint64_t base, uint64_t size) {
  if (size == 0) {
    return base;
  }
  if (add_overflows(base, size)) {
    return std::numeric_limits<uint64_t>::max();
  }
  return base + size;
}

uint64_t overlap_size(uint64_t base_a, uint64_t size_a, uint64_t base_b, uint64_t size_b) {
  if (size_a == 0 || size_b == 0) {
    return 0;
  }
  uint64_t end_a = range_end(base_a, size_a);
  uint64_t end_b = range_end(base_b, size_b);
  if (end_a <= base_b || end_b <= base_a) {
    return 0;
  }
  uint64_t start = std::max(base_a, base_b);
  uint64_t end = std::min(end_a, end_b);
  if (end <= start) {
    return 0;
  }
  return end - start;
}
} // namespace

void assign_memory_map_image_ids(
    std::vector<memory_region_record>& regions, const std::vector<module_record>& modules
) {
  if (regions.empty() || modules.empty()) {
    return;
  }

  for (auto& region : regions) {
    if (region.image_id != 0 || region.size == 0) {
      continue;
    }
    uint64_t best_overlap = 0;
    uint64_t best_id = 0;
    for (const auto& module : modules) {
      uint64_t overlap = overlap_size(region.base, region.size, module.base, module.size);
      if (overlap == 0) {
        continue;
      }
      if (overlap > best_overlap) {
        best_overlap = overlap;
        best_id = module.id;
      }
    }
    if (best_id != 0) {
      region.image_id = best_id;
    }
  }
}

} // namespace w1::rewind

```

`src/w1rewind/record/memory_map_utils.hpp`:

```hpp
#pragma once

#include <vector>

#include "w1rewind/format/trace_format.hpp"

namespace w1::rewind {

void assign_memory_map_image_ids(std::vector<memory_region_record>& regions, const std::vector<module_record>& modules);

} // namespace w1::rewind

```

`src/w1rewind/record/trace_builder.cpp`:

```cpp
#include "trace_builder.hpp"

#include "w1rewind/format/trace_validator.hpp"

namespace w1::rewind {

trace_builder::trace_builder(trace_builder_config config) : config_(std::move(config)) {}

bool trace_builder::begin_trace(
    const w1::arch::arch_spec& arch, const target_info_record& target, const target_environment_record& environment,
    const std::vector<register_spec>& register_specs
) {
  if (started_) {
    error_ = "trace already started";
    return false;
  }
  if (!config_.sink) {
    error_ = "trace sink missing";
    return false;
  }
  if (!config_.sink->good()) {
    error_ = "trace sink not ready";
    return false;
  }
  if (!validate_trace_arch(arch, error_)) {
    return false;
  }
  register_specs_ = register_specs;
  if (!normalize_register_specs(register_specs_, error_)) {
    return false;
  }

  target_info_ = target;
  target_environment_ = environment;

  trace_header header{};
  header.arch = arch;
  header.flags = 0;
  if (config_.options.record_instructions) {
    header.flags |= trace_flag_instructions;
  } else {
    header.flags |= trace_flag_blocks;
  }
  if (config_.options.record_register_deltas) {
    header.flags |= trace_flag_register_deltas;
  }
  if (config_.options.record_memory_access) {
    header.flags |= trace_flag_memory_access;
    if (config_.options.record_memory_values) {
      header.flags |= trace_flag_memory_values;
    }
  }
  if (config_.options.record_snapshots || config_.options.record_stack_segments) {
    header.flags |= trace_flag_snapshots;
  }
  if (config_.options.record_stack_segments) {
    header.flags |= trace_flag_stack_snapshot;
  }

  if (!config_.sink->write_header(header)) {
    error_ = "failed to write trace header";
    return false;
  }

  if (!config_.sink->write_target_info(target_info_)) {
    error_ = "failed to write target info";
    return false;
  }
  if (!config_.sink->write_target_environment(target_environment_)) {
    error_ = "failed to write target environment";
    return false;
  }

  register_spec_record spec_record{};
  spec_record.registers = register_specs_;
  if (!config_.sink->write_register_spec(spec_record)) {
    error_ = "failed to write register specs";
    return false;
  }

  started_ = true;
  if (module_table_pending_) {
    if (!write_module_table()) {
      return false;
    }
  }
  if (memory_map_pending_) {
    if (!write_memory_map()) {
      return false;
    }
  }

  return true;
}

bool trace_builder::set_module_table(std::vector<module_record> modules) {
  modules_ = std::move(modules);
  module_table_pending_ = true;
  if (!started_) {
    return true;
  }
  return write_module_table();
}

bool trace_builder::set_memory_map(std::vector<memory_region_record> regions) {
  memory_map_ = std::move(regions);
  memory_map_pending_ = true;
  if (!started_) {
    return true;
  }
  return write_memory_map();
}

bool trace_builder::emit_module_load(const module_load_record& record) {
  if (!ensure_trace_started()) {
    return false;
  }
  if (!config_.sink->write_module_load(record)) {
    error_ = "failed to write module load";
    return false;
  }
  return true;
}

bool trace_builder::emit_module_unload(const module_unload_record& record) {
  if (!ensure_trace_started()) {
    return false;
  }
  if (!config_.sink->write_module_unload(record)) {
    error_ = "failed to write module unload";
    return false;
  }
  return true;
}

bool trace_builder::begin_thread(uint64_t thread_id, std::string name) {
  if (!ensure_trace_started()) {
    return false;
  }
  auto& state = threads_[thread_id];
  if (!name.empty() && state.name.empty()) {
    state.name = std::move(name);
  }
  return ensure_thread_started(state, thread_id);
}

bool trace_builder::end_thread(uint64_t thread_id) {
  if (!ensure_trace_started()) {
    return false;
  }
  auto& state = threads_[thread_id];
  if (!ensure_thread_started(state, thread_id)) {
    return false;
  }
  if (state.ended) {
    return true;
  }
  thread_end_record end{};
  end.thread_id = thread_id;
  if (!config_.sink->write_thread_end(end)) {
    error_ = "failed to write thread end";
    return false;
  }
  state.ended = true;
  return true;
}

bool trace_builder::emit_instruction(
    uint64_t thread_id, uint64_t address, uint32_t size, uint32_t flags, uint64_t& sequence_out
) {
  if (!ensure_trace_started()) {
    return false;
  }
  if (!config_.options.record_instructions) {
    error_ = "instruction flow not enabled";
    return false;
  }
  auto& state = threads_[thread_id];
  if (!ensure_thread_started(state, thread_id)) {
    return false;
  }

  instruction_record record{};
  record.sequence = state.next_sequence++;
  record.thread_id = thread_id;
  record.address = address;
  record.size = size;
  record.flags = flags;

  if (!config_.sink->write_instruction(record)) {
    error_ = "failed to write instruction record";
    return false;
  }

  sequence_out = record.sequence;
  return true;
}

bool trace_builder::emit_block(
    uint64_t thread_id, uint64_t address, uint32_t size, uint32_t flags, uint64_t& sequence_out
) {
  if (!ensure_trace_started()) {
    return false;
  }
  if (config_.options.record_instructions) {
    error_ = "block flow not enabled";
    return false;
  }
  auto& state = threads_[thread_id];
  if (!ensure_thread_started(state, thread_id)) {
    return false;
  }

  block_key key{};
  key.address = address;
  key.size = size;
  key.flags = flags;

  uint64_t block_id = 0;
  auto it = block_ids_.find(key);
  if (it == block_ids_.end()) {
    block_id = next_block_id_++;
    block_ids_[key] = block_id;
    block_definition_record def{};
    def.block_id = block_id;
    def.address = address;
    def.size = size;
    def.flags = flags;
    if (!config_.sink->write_block_definition(def)) {
      error_ = "failed to write block definition";
      return false;
    }
  } else {
    block_id = it->second;
  }

  block_exec_record exec{};
  exec.sequence = state.next_sequence++;
  exec.thread_id = thread_id;
  exec.block_id = block_id;
  if (!config_.sink->write_block_exec(exec)) {
    error_ = "failed to write block exec";
    return false;
  }

  sequence_out = exec.sequence;
  return true;
}

bool trace_builder::emit_register_deltas(
    uint64_t thread_id, uint64_t sequence, std::span<const register_delta> deltas
) {
  if (!config_.options.record_register_deltas || deltas.empty()) {
    return true;
  }
  if (!ensure_trace_started()) {
    return false;
  }

  register_delta_record record{};
  record.sequence = sequence;
  record.thread_id = thread_id;
  record.deltas.assign(deltas.begin(), deltas.end());

  if (!config_.sink->write_register_deltas(record)) {
    error_ = "failed to write register deltas";
    return false;
  }
  return true;
}

bool trace_builder::emit_register_bytes(
    uint64_t thread_id, uint64_t sequence, std::span<const register_bytes_entry> entries, std::span<const uint8_t> data
) {
  if (!config_.options.record_register_deltas || entries.empty()) {
    return true;
  }
  if (!ensure_trace_started()) {
    return false;
  }
  if (data.empty()) {
    error_ = "register bytes data missing";
    return false;
  }

  for (const auto& entry : entries) {
    if (entry.reg_id >= register_specs_.size()) {
      error_ = "register bytes reg_id out of range";
      return false;
    }
    const auto& spec = register_specs_[entry.reg_id];
    if (spec.value_kind != register_value_kind::bytes) {
      error_ = "register bytes value_kind mismatch";
      return false;
    }
    uint32_t expected = (spec.bits + 7u) / 8u;
    if (entry.size != expected) {
      error_ = "register bytes size mismatch";
      return false;
    }
    uint64_t end = static_cast<uint64_t>(entry.offset) + static_cast<uint64_t>(entry.size);
    if (end > data.size()) {
      error_ = "register bytes data out of range";
      return false;
    }
  }

  register_bytes_record record{};
  record.sequence = sequence;
  record.thread_id = thread_id;
  record.entries.assign(entries.begin(), entries.end());
  record.data.assign(data.begin(), data.end());

  if (!config_.sink->write_register_bytes(record)) {
    error_ = "failed to write register bytes";
    return false;
  }
  return true;
}

bool trace_builder::emit_memory_access(
    uint64_t thread_id, uint64_t sequence, memory_access_kind kind, uint64_t address, uint32_t size, bool value_known,
    bool value_truncated, std::span<const uint8_t> data
) {
  if (!config_.options.record_memory_access) {
    return true;
  }
  if (!ensure_trace_started()) {
    return false;
  }

  memory_access_record record{};
  record.sequence = sequence;
  record.thread_id = thread_id;
  record.kind = kind;
  record.address = address;
  record.size = size;

  if (!config_.options.record_memory_values) {
    record.value_known = false;
    record.value_truncated = false;
  } else {
    record.value_known = value_known;
    record.value_truncated = value_truncated;
    record.data.assign(data.begin(), data.end());
  }

  if (!config_.sink->write_memory_access(record)) {
    error_ = "failed to write memory access";
    return false;
  }
  return true;
}

bool trace_builder::emit_snapshot(
    uint64_t thread_id, uint64_t sequence, uint64_t snapshot_id, std::span<const register_delta> registers,
    std::span<const stack_segment> stack_segments, std::string reason
) {
  if (!config_.options.record_snapshots && !config_.options.record_stack_segments) {
    return true;
  }
  if (!ensure_trace_started()) {
    return false;
  }

  snapshot_record record{};
  record.snapshot_id = snapshot_id;
  record.sequence = sequence;
  record.thread_id = thread_id;
  record.registers.assign(registers.begin(), registers.end());
  record.stack_segments.assign(stack_segments.begin(), stack_segments.end());
  record.reason = std::move(reason);

  if (!config_.sink->write_snapshot(record)) {
    error_ = "failed to write snapshot";
    return false;
  }
  return true;
}

void trace_builder::flush() {
  if (config_.sink) {
    config_.sink->flush();
  }
}

bool trace_builder::good() const {
  if (!config_.sink) {
    return false;
  }
  return config_.sink->good();
}

bool trace_builder::ensure_trace_started() {
  if (started_) {
    return true;
  }
  error_ = "trace not started";
  return false;
}

bool trace_builder::ensure_thread_started(thread_state& state, uint64_t thread_id) {
  if (state.started) {
    return true;
  }

  thread_start_record start{};
  start.thread_id = thread_id;
  start.name = state.name;
  if (!config_.sink->write_thread_start(start)) {
    error_ = "failed to write thread start";
    return false;
  }
  state.started = true;
  return true;
}

bool trace_builder::write_module_table() {
  if (module_table_written_) {
    return true;
  }
  if (!ensure_trace_started()) {
    return false;
  }
  module_table_record record{};
  record.modules = modules_;
  if (!config_.sink->write_module_table(record)) {
    error_ = "failed to write module table";
    return false;
  }
  module_table_written_ = true;
  module_table_pending_ = false;
  return true;
}

bool trace_builder::write_memory_map() {
  if (!ensure_trace_started()) {
    return false;
  }
  memory_map_record record{};
  record.regions = memory_map_;
  if (!config_.sink->write_memory_map(record)) {
    error_ = "failed to write memory map";
    return false;
  }
  memory_map_pending_ = false;
  return true;
}

} // namespace w1::rewind

```

`src/w1rewind/record/trace_builder.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <optional>
#include <span>
#include <string>
#include <unordered_map>
#include <vector>

#include "trace_builder_types.hpp"

namespace w1::rewind {

class trace_builder {
public:
  explicit trace_builder(trace_builder_config config);

  bool begin_trace(
      const w1::arch::arch_spec& arch, const target_info_record& target, const target_environment_record& environment,
      const std::vector<register_spec>& register_specs
  );
  bool set_module_table(std::vector<module_record> modules);
  bool set_memory_map(std::vector<memory_region_record> regions);
  bool emit_module_load(const module_load_record& record);
  bool emit_module_unload(const module_unload_record& record);

  bool begin_thread(uint64_t thread_id, std::string name = {});
  bool end_thread(uint64_t thread_id);

  bool emit_instruction(uint64_t thread_id, uint64_t address, uint32_t size, uint32_t flags, uint64_t& sequence_out);
  bool emit_block(uint64_t thread_id, uint64_t address, uint32_t size, uint32_t flags, uint64_t& sequence_out);

  bool emit_register_deltas(uint64_t thread_id, uint64_t sequence, std::span<const register_delta> deltas);
  bool emit_register_bytes(
      uint64_t thread_id, uint64_t sequence, std::span<const register_bytes_entry> entries,
      std::span<const uint8_t> data
  );
  bool emit_memory_access(
      uint64_t thread_id, uint64_t sequence, memory_access_kind kind, uint64_t address, uint32_t size, bool value_known,
      bool value_truncated, std::span<const uint8_t> data
  );
  bool emit_snapshot(
      uint64_t thread_id, uint64_t sequence, uint64_t snapshot_id, std::span<const register_delta> registers,
      std::span<const stack_segment> stack_segments, std::string reason
  );

  void flush();
  bool good() const;
  const std::string& error() const { return error_; }

private:
  struct thread_state {
    uint64_t next_sequence = 0;
    bool started = false;
    bool ended = false;
    std::string name;
  };

  struct block_key {
    uint64_t address = 0;
    uint32_t size = 0;
    uint32_t flags = 0;

    bool operator==(const block_key& other) const {
      return address == other.address && size == other.size && flags == other.flags;
    }
  };

  struct block_key_hash {
    size_t operator()(const block_key& key) const noexcept {
      size_t seed = std::hash<uint64_t>{}(key.address);
      seed ^= std::hash<uint32_t>{}(key.size) + 0x9e3779b97f4a7c15ULL + (seed << 6) + (seed >> 2);
      seed ^= std::hash<uint32_t>{}(key.flags) + 0x9e3779b97f4a7c15ULL + (seed << 6) + (seed >> 2);
      return seed;
    }
  };

  bool ensure_trace_started();
  bool ensure_thread_started(thread_state& state, uint64_t thread_id);
  bool write_module_table();
  bool write_memory_map();

  trace_builder_config config_;
  bool started_ = false;
  bool module_table_written_ = false;
  bool module_table_pending_ = false;
  bool memory_map_pending_ = false;

  target_info_record target_info_{};
  target_environment_record target_environment_{};
  std::vector<register_spec> register_specs_{};
  std::vector<module_record> modules_{};
  std::vector<memory_region_record> memory_map_{};

  std::unordered_map<uint64_t, thread_state> threads_{};
  std::unordered_map<block_key, uint64_t, block_key_hash> block_ids_{};
  uint64_t next_block_id_ = 1;

  std::string error_;
};

} // namespace w1::rewind

```

`src/w1rewind/record/trace_builder_types.hpp`:

```hpp
#pragma once

#include <memory>

#include <redlog.hpp>

#include "w1rewind/trace/record_sink.hpp"

namespace w1::rewind {

struct trace_builder_options {
  bool record_instructions = false;
  bool record_register_deltas = false;
  bool record_memory_access = false;
  bool record_memory_values = false;
  bool record_snapshots = false;
  bool record_stack_segments = false;
};

struct trace_builder_config {
  std::shared_ptr<trace_record_sink> sink;
  redlog::logger log;
  trace_builder_options options;
};

} // namespace w1::rewind

```

`src/w1rewind/replay/block_decoder.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>
#include <vector>

#include "flow_types.hpp"
#include "replay_context.hpp"

namespace w1::rewind {

struct decoded_instruction {
  uint64_t address = 0;
  uint32_t size = 0;
  std::vector<uint8_t> bytes;
};

struct decoded_block {
  uint64_t start = 0;
  uint32_t size = 0;
  std::vector<decoded_instruction> instructions;
};

class block_decoder {
public:
  virtual ~block_decoder() = default;

  virtual bool decode_block(
      const replay_context& context, const flow_step& flow, decoded_block& out, std::string& error
  ) = 0;
};

} // namespace w1::rewind

```

`src/w1rewind/replay/flow_cursor.cpp`:

```cpp
#include "flow_cursor.hpp"

#include <algorithm>

namespace w1::rewind {

flow_cursor::flow_cursor(
    record_stream_cursor stream, flow_extractor extractor, history_window history, std::shared_ptr<trace_index> index
)
    : stream_(std::move(stream)), extractor_(std::move(extractor)), history_(std::move(history)), index_(std::move(index)) {
  history_size_ = static_cast<uint32_t>(history_.capacity());
}

void flow_cursor::set_observer(flow_record_observer* observer) { observer_ = observer; }

void flow_cursor::set_history_enabled(bool enabled) { history_enabled_ = enabled; }

void flow_cursor::set_history_size(uint32_t size) {
  history_size_ = size == 0 ? 1 : size;
  history_.resize(history_size_);
}

void flow_cursor::set_cancel_checker(std::function<bool()> checker) { cancel_checker_ = std::move(checker); }

void flow_cursor::clear_error() {
  error_.clear();
  error_kind_ = flow_error_kind::none;
}

void flow_cursor::set_error(flow_error_kind kind, const std::string& message) {
  error_ = message;
  error_kind_ = kind;
}

bool flow_cursor::check_cancel() {
  if (cancel_checker_ && cancel_checker_()) {
    set_error(flow_error_kind::other, "cancelled");
    return true;
  }
  return false;
}

void flow_cursor::reset_position_state() {
  history_.reset();
  current_step_ = flow_step{};
  has_position_ = false;
  clear_buffered_flow();
  stream_desynced_ = false;
}

void flow_cursor::clear_buffered_flow() { buffered_flow_.reset(); }

bool flow_cursor::uses_history_only() const { return history_enabled_ && observer_ == nullptr; }

bool flow_cursor::ensure_stream_synced() {
  if (!stream_desynced_) {
    return true;
  }
  if (history_.empty()) {
    stream_desynced_ = false;
    return true;
  }
  return seek_to_history(history_.current_index());
}

bool flow_cursor::open() {
  close();

  clear_error();

  std::string error;
  if (!stream_.open(error)) {
    set_error(flow_error_kind::other, error);
    return false;
  }
  if (!index_) {
    set_error(flow_error_kind::other, "trace index missing");
    return false;
  }
  if (!extractor_.context()) {
    set_error(flow_error_kind::other, "replay context missing");
    return false;
  }

  const auto& header = stream_.header();
  if (index_->header.trace_version != header.version) {
    set_error(flow_error_kind::other, "trace index version mismatch");
    return false;
  }
  if (index_->header.trace_flags != header.flags) {
    set_error(flow_error_kind::other, "trace index flags mismatch");
    return false;
  }
  if (index_->header.chunk_size != header.chunk_size) {
    set_error(flow_error_kind::other, "trace index chunk size mismatch");
    return false;
  }

  bool use_blocks = (header.flags & trace_flag_blocks) != 0;
  bool use_instructions = (header.flags & trace_flag_instructions) != 0;
  if (use_blocks == use_instructions) {
    set_error(flow_error_kind::other, "trace has unsupported flow flags");
    return false;
  }
  extractor_.set_flow_kind(use_blocks ? flow_kind::blocks : flow_kind::instructions);

  const auto& context = *extractor_.context();
  if (context.header.version != header.version || context.header.flags != header.flags ||
      context.header.arch != header.arch) {
    set_error(flow_error_kind::other, "replay context header mismatch");
    return false;
  }
  if (extractor_.kind() == flow_kind::blocks && context.blocks_by_id.empty()) {
    set_error(flow_error_kind::other, "block definitions missing");
    return false;
  }

  open_ = true;
  return true;
}

void flow_cursor::close() {
  stream_.close();
  active_thread_id_ = 0;
  reset_position_state();
  open_ = false;
  clear_error();
}

bool flow_cursor::seek(uint64_t thread_id, uint64_t sequence) {
  clear_error();

  if (!open_) {
    set_error(flow_error_kind::other, "trace not open");
    return false;
  }
  if (!index_) {
    set_error(flow_error_kind::other, "trace index missing");
    return false;
  }
  if (thread_id == 0) {
    set_error(flow_error_kind::other, "thread not selected");
    return false;
  }

  active_thread_id_ = thread_id;
  reset_position_state();

  auto anchor = index_->find_anchor(thread_id, sequence);
  if (!anchor.has_value()) {
    set_error(flow_error_kind::other, "no anchor for thread");
    return false;
  }

  std::string error;
  if (!stream_.seek({anchor->chunk_index, anchor->record_offset}, error)) {
    set_error(flow_error_kind::other, error);
    return false;
  }

  return scan_until_sequence(thread_id, sequence);
}

bool flow_cursor::seek_from_location(uint64_t thread_id, uint64_t sequence, const trace_record_location& location) {
  clear_error();

  if (!open_) {
    set_error(flow_error_kind::other, "trace not open");
    return false;
  }
  if (thread_id == 0) {
    set_error(flow_error_kind::other, "thread not selected");
    return false;
  }

  active_thread_id_ = thread_id;
  reset_position_state();

  std::string error;
  if (!stream_.seek(location, error)) {
    set_error(flow_error_kind::other, error);
    return false;
  }

  return scan_until_sequence(thread_id, sequence);
}

bool flow_cursor::step_forward(flow_step& out, trace_record_location* location) {
  clear_error();

  if (!open_) {
    set_error(flow_error_kind::other, "trace not open");
    return false;
  }
  if (active_thread_id_ == 0) {
    set_error(flow_error_kind::other, "thread not selected");
    return false;
  }

  bool has_future = history_enabled_ && has_position_ && history_.has_future();

  if (has_future && uses_history_only()) {
    history_.forward();
    const auto& entry = history_.current();
    current_step_ = entry.step;
    has_position_ = true;
    out = entry.step;
    if (location) {
      *location = entry.location;
    }
    stream_desynced_ = true;
    return true;
  }

  if (!ensure_stream_synced()) {
    return false;
  }

  flow_step step{};
  trace_record_location loc{};
  if (!read_next_flow(step, &loc)) {
    return false;
  }

  if (has_future) {
    const auto& expected = history_.entry_at(history_.current_index() + 1);
    if (expected.step.thread_id != step.thread_id || expected.step.sequence != step.sequence) {
      set_error(flow_error_kind::other, "history mismatch");
      return false;
    }
    history_.forward();
    current_step_ = expected.step;
    has_position_ = true;
    out = expected.step;
    if (location) {
      *location = expected.location;
    }
  } else {
    if (observer_ != nullptr) {
      if (!consume_sequence_records(step.thread_id, step.sequence)) {
        return false;
      }
    }
    history_.push(step, loc);
    current_step_ = step;
    has_position_ = true;
    out = step;
    if (location) {
      *location = loc;
    }
    return true;
  }

  if (observer_ != nullptr) {
    if (!consume_sequence_records(step.thread_id, step.sequence)) {
      return false;
    }
  }

  return true;
}

bool flow_cursor::step_backward(flow_step& out) {
  clear_error();

  if (!open_) {
    set_error(flow_error_kind::other, "trace not open");
    return false;
  }
  if (!has_position_) {
    set_error(flow_error_kind::other, "no current position");
    return false;
  }
  if (current_step_.sequence == 0) {
    set_error(flow_error_kind::begin_of_trace, "at start of trace");
    return false;
  }

  uint64_t target = current_step_.sequence - 1;

  if (!history_enabled_) {
    if (!seek(active_thread_id_, target)) {
      return false;
    }
    return step_forward(out);
  }

  if (!history_.empty() && history_.has_past()) {
    history_.rewind();
    const auto& entry = history_.current();
    if (uses_history_only()) {
      stream_desynced_ = true;
    } else {
      if (!seek_to_history(history_.current_index())) {
        return false;
      }
    }
    current_step_ = entry.step;
    has_position_ = true;
    out = entry.step;
    return true;
  }

  return prefill_history_window(target, out);
}

bool flow_cursor::scan_until_sequence(uint64_t thread_id, uint64_t sequence) {
  trace_record record;
  trace_record_location location{};

  while (true) {
    std::string error;
    if (!stream_.read_next(record, location, error)) {
      if (!error.empty()) {
        set_error(flow_error_kind::other, error);
      } else {
        set_error(flow_error_kind::end_of_trace, "end of trace");
      }
      return false;
    }
    if (check_cancel()) {
      return false;
    }
    bool is_flow = false;
    flow_step step{};
    if (!extractor_.try_extract(record, step, is_flow, error)) {
      set_error(flow_error_kind::other, error);
      return false;
    }

    if (!is_flow) {
      if (!extractor_.handle_non_flow(record, observer_, active_thread_id_, error)) {
        set_error(flow_error_kind::other, error);
        return false;
      }
      continue;
    }

    if (step.thread_id != thread_id) {
      continue;
    }
    if (step.sequence < sequence) {
      continue;
    }
    if (step.sequence > sequence) {
      set_error(flow_error_kind::other, "flow sequence not found");
      return false;
    }

    buffered_flow_ = buffered_flow{step, location};
    return true;
  }
}

bool flow_cursor::read_next_flow(flow_step& out, trace_record_location* location) {
  if (buffered_flow_.has_value()) {
    out = buffered_flow_->step;
    if (location) {
      *location = buffered_flow_->location;
    }
    buffered_flow_.reset();
    return true;
  }

  trace_record record;
  trace_record_location loc{};

  while (true) {
    std::string error;
    if (!stream_.read_next(record, loc, error)) {
      if (!error.empty()) {
        set_error(flow_error_kind::other, error);
      } else {
        set_error(flow_error_kind::end_of_trace, "end of trace");
      }
      return false;
    }
    if (check_cancel()) {
      return false;
    }
    bool is_flow = false;
    if (!extractor_.try_extract(record, out, is_flow, error)) {
      set_error(flow_error_kind::other, error);
      return false;
    }
    if (!is_flow) {
      if (!extractor_.handle_non_flow(record, observer_, active_thread_id_, error)) {
        set_error(flow_error_kind::other, error);
        return false;
      }
      continue;
    }
    if (out.thread_id != active_thread_id_) {
      continue;
    }
    if (location) {
      *location = loc;
    }
    return true;
  }
}

bool flow_cursor::consume_sequence_records(uint64_t thread_id, uint64_t sequence) {
  trace_record record;
  trace_record_location loc{};

  while (true) {
    std::string error;
    if (!stream_.read_next(record, loc, error)) {
      if (!error.empty()) {
        set_error(flow_error_kind::other, error);
        return false;
      }
      return true;
    }
    if (check_cancel()) {
      return false;
    }
    bool is_flow = false;
    flow_step step{};
    if (!extractor_.try_extract(record, step, is_flow, error)) {
      set_error(flow_error_kind::other, error);
      return false;
    }

    if (!is_flow) {
      if (!extractor_.handle_non_flow(record, observer_, active_thread_id_, error)) {
        set_error(flow_error_kind::other, error);
        return false;
      }
      continue;
    }

    if (step.thread_id != thread_id) {
      continue;
    }

    if (step.sequence <= sequence) {
      continue;
    }

    buffered_flow_ = buffered_flow{step, loc};
    return true;
  }
}

bool flow_cursor::seek_to_history(size_t index) {
  if (index >= history_.size()) {
    set_error(flow_error_kind::other, "history index out of range");
    return false;
  }

  const auto& entry = history_.entry_at(index);
  clear_buffered_flow();

  std::string error;
  if (!stream_.seek(entry.location, error)) {
    set_error(flow_error_kind::other, error);
    return false;
  }

  trace_record record;
  trace_record_location location{};
  if (!stream_.read_next(record, location, error)) {
    if (error.empty()) {
      error = "failed to read trace record";
    }
    set_error(flow_error_kind::other, error);
    return false;
  }

  stream_desynced_ = false;
  return true;
}

uint64_t flow_cursor::window_start_sequence(uint64_t target) const {
  if (history_size_ <= 1) {
    return target;
  }
  uint64_t window = static_cast<uint64_t>(history_size_);
  if (target + 1 <= window) {
    return 0;
  }
  return target + 1 - window;
}

bool flow_cursor::prefill_history_window(uint64_t target, flow_step& out) {
  uint64_t start = window_start_sequence(target);
  if (!seek(active_thread_id_, start)) {
    return false;
  }

  flow_step step{};
  trace_record_location loc{};
  while (true) {
    if (check_cancel()) {
      return false;
    }
    if (!ensure_stream_synced()) {
      return false;
    }
    if (!read_next_flow(step, &loc)) {
      return false;
    }
    if (observer_ != nullptr) {
      if (!consume_sequence_records(step.thread_id, step.sequence)) {
        return false;
      }
    }
    history_.push(step, loc);
    current_step_ = step;
    has_position_ = true;
    if (step.sequence == target) {
      out = step;
      return true;
    }
    if (step.sequence > target) {
      set_error(flow_error_kind::other, "flow sequence not found");
      return false;
    }
  }
}

} // namespace w1::rewind

```

`src/w1rewind/replay/flow_cursor.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <string_view>

#include "flow_extractor.hpp"
#include "flow_types.hpp"
#include "history_window.hpp"
#include "record_stream_cursor.hpp"
#include "w1rewind/trace/trace_index.hpp"

namespace w1::rewind {

enum class flow_error_kind { none, begin_of_trace, end_of_trace, other };

class flow_cursor {
public:
  flow_cursor(
      record_stream_cursor stream, flow_extractor extractor, history_window history, std::shared_ptr<trace_index> index
  );

  void set_observer(flow_record_observer* observer);
  void set_history_enabled(bool enabled);
  void set_history_size(uint32_t size);
  void set_cancel_checker(std::function<bool()> checker);

  bool open();
  void close();

  bool seek(uint64_t thread_id, uint64_t sequence);
  bool seek_from_location(uint64_t thread_id, uint64_t sequence, const trace_record_location& location);

  bool step_forward(flow_step& out, trace_record_location* location = nullptr);
  bool step_backward(flow_step& out);

  const replay_context& context() const { return *extractor_.context(); }
  bool has_position() const { return has_position_; }
  const flow_step& current_step() const { return current_step_; }
  std::string_view error() const { return error_; }
  flow_error_kind error_kind() const { return error_kind_; }

private:
  struct buffered_flow {
    flow_step step;
    trace_record_location location;
  };

  void clear_error();
  void set_error(flow_error_kind kind, const std::string& message);
  bool check_cancel();
  void reset_position_state();
  void clear_buffered_flow();
  bool uses_history_only() const;
  bool ensure_stream_synced();
  bool scan_until_sequence(uint64_t thread_id, uint64_t sequence);
  bool read_next_flow(flow_step& out, trace_record_location* location);
  bool consume_sequence_records(uint64_t thread_id, uint64_t sequence);
  bool seek_to_history(size_t index);
  uint64_t window_start_sequence(uint64_t target) const;
  bool prefill_history_window(uint64_t target, flow_step& out);

  record_stream_cursor stream_;
  flow_extractor extractor_;
  history_window history_;
  std::shared_ptr<trace_index> index_;
  uint32_t history_size_ = 1024;
  uint64_t active_thread_id_ = 0;
  flow_step current_step_{};
  std::optional<buffered_flow> buffered_flow_{};
  bool has_position_ = false;
  bool open_ = false;
  bool history_enabled_ = true;
  flow_record_observer* observer_ = nullptr;
  std::function<bool()> cancel_checker_{};
  bool stream_desynced_ = false;
  std::string error_;
  flow_error_kind error_kind_ = flow_error_kind::none;
};

} // namespace w1::rewind

```

`src/w1rewind/replay/flow_extractor.cpp`:

```cpp
#include "flow_extractor.hpp"

namespace w1::rewind {

flow_extractor::flow_extractor(const replay_context* context) : context_(context) {}

void flow_extractor::set_flow_kind(flow_kind kind) { kind_ = kind; }

bool flow_extractor::try_extract(
    const trace_record& record, flow_step& out, bool& is_flow, std::string& error
) const {
  is_flow = false;
  if (!context_) {
    error = "replay context missing";
    return false;
  }

  if (kind_ == flow_kind::instructions) {
    if (!std::holds_alternative<instruction_record>(record)) {
      return true;
    }
    const auto& inst = std::get<instruction_record>(record);
    out.thread_id = inst.thread_id;
    out.sequence = inst.sequence;
    out.size = inst.size;
    out.address = inst.address;
    out.block_id = 0;
    out.flags = inst.flags;
    out.is_block = false;
    is_flow = true;
    return true;
  }

  if (!std::holds_alternative<block_exec_record>(record)) {
    return true;
  }

  const auto& exec = std::get<block_exec_record>(record);
  auto it = context_->blocks_by_id.find(exec.block_id);
  if (it == context_->blocks_by_id.end()) {
    error = "block id not found";
    return false;
  }

  const auto& def = it->second;
  out.thread_id = exec.thread_id;
  out.sequence = exec.sequence;
  out.size = def.size;
  out.address = def.address;
  out.block_id = exec.block_id;
  out.flags = def.flags;
  out.is_block = true;
  is_flow = true;
  return true;
}

bool flow_extractor::handle_non_flow(
    const trace_record& record, flow_record_observer* observer, uint64_t active_thread_id, std::string& error
) const {
  if (!observer) {
    return true;
  }
  if (!observer->on_record(record, active_thread_id, error)) {
    if (error.empty()) {
      error = "failed to apply trace record";
    }
    return false;
  }
  return true;
}

} // namespace w1::rewind

```

`src/w1rewind/replay/flow_extractor.hpp`:

```hpp
#pragma once

#include <string>

#include "flow_types.hpp"
#include "replay_context.hpp"

namespace w1::rewind {

enum class flow_kind { instructions, blocks };

class flow_extractor {
public:
  explicit flow_extractor(const replay_context* context);

  void set_flow_kind(flow_kind kind);
  flow_kind kind() const { return kind_; }
  const replay_context* context() const { return context_; }

  bool try_extract(const trace_record& record, flow_step& out, bool& is_flow, std::string& error) const;
  bool handle_non_flow(
      const trace_record& record, flow_record_observer* observer, uint64_t active_thread_id, std::string& error
  ) const;

private:
  const replay_context* context_ = nullptr;
  flow_kind kind_ = flow_kind::instructions;
};

} // namespace w1::rewind

```

`src/w1rewind/replay/flow_types.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>

#include "w1rewind/format/trace_format.hpp"

namespace w1::rewind {

struct flow_step {
  uint64_t thread_id = 0;
  uint64_t sequence = 0;
  uint32_t size = 0;
  uint64_t address = 0;
  uint64_t block_id = 0;
  uint32_t flags = 0;
  bool is_block = false;
};

class flow_record_observer {
public:
  virtual ~flow_record_observer() = default;
  virtual bool on_record(const trace_record& record, uint64_t active_thread_id, std::string& error) = 0;
};

} // namespace w1::rewind

```

`src/w1rewind/replay/history_window.cpp`:

```cpp
#include "history_window.hpp"

#include <algorithm>

namespace w1::rewind {

history_window::history_window(size_t capacity) { resize(capacity); }

void history_window::reset() {
  entries_.clear();
  current_index_ = 0;
}

void history_window::resize(size_t capacity) {
  capacity_ = std::max<size_t>(1, capacity);
  if (entries_.size() <= capacity_) {
    return;
  }

  size_t desired = capacity_;
  size_t current_index = current_index_;
  size_t remove_front = std::min(entries_.size() - desired, current_index);
  for (size_t i = 0; i < remove_front; ++i) {
    entries_.pop_front();
  }
  current_index -= remove_front;

  while (entries_.size() > desired) {
    entries_.pop_back();
  }

  if (entries_.empty()) {
    current_index_ = 0;
    return;
  }
  current_index_ = std::min(current_index, entries_.size() - 1);
}

const history_window::entry& history_window::current() const { return entries_[current_index_]; }

const history_window::entry& history_window::entry_at(size_t index) const { return entries_[index]; }

bool history_window::has_past() const { return !entries_.empty() && current_index_ > 0; }

bool history_window::has_future() const { return !entries_.empty() && current_index_ + 1 < entries_.size(); }

bool history_window::rewind() {
  if (!has_past()) {
    return false;
  }
  current_index_ -= 1;
  return true;
}

bool history_window::forward() {
  if (!has_future()) {
    return false;
  }
  current_index_ += 1;
  return true;
}

void history_window::push(const flow_step& step, const trace_record_location& location) {
  if (entries_.size() == capacity_) {
    entries_.pop_front();
    if (current_index_ > 0) {
      current_index_ -= 1;
    }
  }

  entries_.push_back(entry{step, location});
  current_index_ = entries_.size() - 1;
}

} // namespace w1::rewind

```

`src/w1rewind/replay/history_window.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <deque>

#include "flow_types.hpp"
#include "w1rewind/trace/record_stream.hpp"

namespace w1::rewind {

class history_window {
public:
  struct entry {
    flow_step step;
    trace_record_location location;
  };

  explicit history_window(size_t capacity);

  void reset();
  void resize(size_t capacity);

  bool empty() const { return entries_.empty(); }
  size_t size() const { return entries_.size(); }
  size_t capacity() const { return capacity_; }
  size_t current_index() const { return current_index_; }

  const entry& current() const;
  const entry& entry_at(size_t index) const;

  bool has_past() const;
  bool has_future() const;
  bool rewind();
  bool forward();

  void push(const flow_step& step, const trace_record_location& location);

private:
  std::deque<entry> entries_;
  size_t current_index_ = 0;
  size_t capacity_ = 1;
};

} // namespace w1::rewind

```

`src/w1rewind/replay/memory_store.cpp`:

```cpp
#include "memory_store.hpp"

#include <algorithm>
#include <limits>

namespace w1::rewind {

namespace {

uint64_t safe_end(uint64_t base, size_t size) {
  if (size == 0) {
    return base;
  }
  uint64_t end = base + static_cast<uint64_t>(size);
  if (end < base) {
    return std::numeric_limits<uint64_t>::max();
  }
  return end;
}

} // namespace

void memory_store::clear() { spans_.clear(); }

void memory_store::apply_bytes(uint64_t address, std::span<const uint8_t> bytes) {
  if (bytes.empty()) {
    return;
  }

  uint64_t start = address;
  uint64_t end = safe_end(address, bytes.size());
  if (end == std::numeric_limits<uint64_t>::max() && start != 0) {
    return;
  }

  std::vector<memory_span> merged;
  merged.reserve(spans_.size() + 1);

  size_t index = 0;
  while (index < spans_.size()) {
    const auto& span = spans_[index];
    uint64_t span_end = safe_end(span.base, span.bytes.size());
    if (span_end < start) {
      merged.push_back(span);
      ++index;
      continue;
    }
    break;
  }

  uint64_t merged_start = start;
  uint64_t merged_end = end;
  size_t merge_start = index;
  while (index < spans_.size()) {
    const auto& span = spans_[index];
    if (span.base > merged_end) {
      break;
    }
    uint64_t span_end = safe_end(span.base, span.bytes.size());
    if (span.base < merged_start) {
      merged_start = span.base;
    }
    if (span_end > merged_end) {
      merged_end = span_end;
    }
    ++index;
  }

  size_t merge_end = index;
  if (merge_start == merge_end) {
    memory_span span{};
    span.base = start;
    span.bytes.assign(bytes.begin(), bytes.end());
    merged.push_back(std::move(span));
  } else {
    size_t merged_size = static_cast<size_t>(merged_end - merged_start);
    std::vector<uint8_t> merged_bytes(merged_size, 0);

    for (size_t i = merge_start; i < merge_end; ++i) {
      const auto& span = spans_[i];
      size_t offset = static_cast<size_t>(span.base - merged_start);
      std::copy(span.bytes.begin(), span.bytes.end(), merged_bytes.begin() + static_cast<std::ptrdiff_t>(offset));
    }

    size_t incoming_offset = static_cast<size_t>(start - merged_start);
    std::copy(bytes.begin(), bytes.end(), merged_bytes.begin() + static_cast<std::ptrdiff_t>(incoming_offset));

    memory_span span{};
    span.base = merged_start;
    span.bytes = std::move(merged_bytes);
    merged.push_back(std::move(span));
  }

  merged.insert(merged.end(), spans_.begin() + static_cast<std::ptrdiff_t>(merge_end), spans_.end());
  spans_ = std::move(merged);
}

void memory_store::apply_segments(std::span<const memory_span> segments) {
  for (const auto& segment : segments) {
    apply_bytes(segment.base, segment.bytes);
  }
}

memory_read memory_store::read(uint64_t address, size_t size) const {
  memory_read out;
  out.bytes.assign(size, std::byte{0});
  out.known.assign(size, 0);

  if (size == 0 || spans_.empty()) {
    return out;
  }

  uint64_t start = address;
  uint64_t end = safe_end(address, size);
  if (end == std::numeric_limits<uint64_t>::max() && start != 0) {
    return out;
  }

  for (const auto& span : spans_) {
    uint64_t span_end = safe_end(span.base, span.bytes.size());
    if (span_end <= start) {
      continue;
    }
    if (span.base >= end) {
      break;
    }

    uint64_t overlap_start = std::max(start, span.base);
    uint64_t overlap_end = std::min(end, span_end);
    if (overlap_end <= overlap_start) {
      continue;
    }

    size_t out_offset = static_cast<size_t>(overlap_start - start);
    size_t span_offset = static_cast<size_t>(overlap_start - span.base);
    size_t overlap_size = static_cast<size_t>(overlap_end - overlap_start);

    for (size_t i = 0; i < overlap_size; ++i) {
      out.bytes[out_offset + i] = std::byte{span.bytes[span_offset + i]};
      out.known[out_offset + i] = 1;
    }
  }

  return out;
}

std::vector<memory_span> memory_store::spans() const { return spans_; }

} // namespace w1::rewind

```

`src/w1rewind/replay/memory_store.hpp`:

```hpp
#pragma once

#include <algorithm>
#include <cstddef>
#include <cstdint>
#include <span>
#include <vector>

namespace w1::rewind {

struct memory_span {
  uint64_t base = 0;
  std::vector<uint8_t> bytes;
};

struct memory_read {
  std::vector<std::byte> bytes;
  std::vector<uint8_t> known;

  bool complete() const {
    if (known.empty()) {
      return true;
    }
    return std::all_of(known.begin(), known.end(), [](uint8_t value) { return value != 0; });
  }

  bool any_known() const {
    return std::any_of(known.begin(), known.end(), [](uint8_t value) { return value != 0; });
  }
};

class memory_store {
public:
  void clear();
  void apply_bytes(uint64_t address, std::span<const uint8_t> bytes);
  void apply_segments(std::span<const memory_span> segments);
  memory_read read(uint64_t address, size_t size) const;
  std::vector<memory_span> spans() const;

private:
  std::vector<memory_span> spans_;
};

} // namespace w1::rewind

```

`src/w1rewind/replay/record_stream_cursor.cpp`:

```cpp
#include "record_stream_cursor.hpp"

namespace w1::rewind {

record_stream_cursor::record_stream_cursor(std::shared_ptr<trace_record_stream> stream)
    : stream_(std::move(stream)) {}

bool record_stream_cursor::open(std::string& error) {
  if (!stream_) {
    error = "trace stream missing";
    return false;
  }
  if (!stream_->open()) {
    error = std::string(stream_->error());
    return false;
  }
  open_ = true;
  return true;
}

void record_stream_cursor::close() {
  if (stream_) {
    stream_->close();
  }
  open_ = false;
}

bool record_stream_cursor::seek(const trace_record_location& location, std::string& error) {
  if (!stream_) {
    error = "trace stream missing";
    return false;
  }
  if (!stream_->seek_to_location(location)) {
    error = std::string(stream_->error());
    return false;
  }
  return true;
}

bool record_stream_cursor::read_next(trace_record& out, trace_record_location& location, std::string& error) {
  if (!stream_) {
    error = "trace stream missing";
    return false;
  }
  if (!stream_->read_next(out, &location)) {
    if (!stream_->error().empty()) {
      error = std::string(stream_->error());
    }
    return false;
  }
  return true;
}

const trace_header& record_stream_cursor::header() const { return stream_->header(); }

} // namespace w1::rewind

```

`src/w1rewind/replay/record_stream_cursor.hpp`:

```hpp
#pragma once

#include <memory>
#include <string>

#include "w1rewind/trace/record_stream.hpp"

namespace w1::rewind {

class record_stream_cursor {
public:
  explicit record_stream_cursor(std::shared_ptr<trace_record_stream> stream);

  bool open(std::string& error);
  void close();

  bool seek(const trace_record_location& location, std::string& error);
  bool read_next(trace_record& out, trace_record_location& location, std::string& error);

  const trace_header& header() const;
  bool is_open() const { return open_; }

private:
  std::shared_ptr<trace_record_stream> stream_;
  bool open_ = false;
};

} // namespace w1::rewind

```

`src/w1rewind/replay/replay_context.cpp`:

```cpp
#include "replay_context.hpp"

#include "replay_context_builder.hpp"
#include "w1rewind/trace/trace_reader.hpp"

namespace w1::rewind {

const module_record* replay_context::find_module_for_address(
    uint64_t address, uint64_t size, uint64_t& module_offset
) const {
  if (size == 0) {
    return nullptr;
  }

  for (const auto& module : modules) {
    if (address < module.base) {
      continue;
    }
    uint64_t offset = address - module.base;
    if (module.size < size) {
      continue;
    }
    if (offset > module.size - size) {
      continue;
    }
    module_offset = offset;
    return &module;
  }

  return nullptr;
}

bool replay_context::has_blocks() const { return (header.flags & trace_flag_blocks) != 0; }

bool replay_context::has_registers() const { return !register_specs.empty(); }

replay_context::trace_features replay_context::features() const {
  trace_features out{};
  out.has_registers = has_registers();
  out.has_memory_access = (header.flags & trace_flag_memory_access) != 0;
  out.has_memory_values = (header.flags & trace_flag_memory_values) != 0;
  out.has_stack_snapshot = (header.flags & trace_flag_stack_snapshot) != 0;
  out.has_blocks = has_blocks();
  out.track_memory = (out.has_memory_access && out.has_memory_values) || out.has_stack_snapshot;
  return out;
}

bool load_replay_context(const std::string& trace_path, replay_context& out, std::string& error) {
  error.clear();

  trace_reader reader(trace_path);
  if (!reader.open()) {
    error = reader.error();
    return false;
  }
  return build_replay_context(reader, out, error);
}

} // namespace w1::rewind

```

`src/w1rewind/replay/replay_context.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include <string>
#include <unordered_map>
#include <vector>

#include "w1rewind/format/trace_format.hpp"

namespace w1::rewind {

struct replay_thread_info {
  uint64_t thread_id = 0;
  std::string name;
  bool started = false;
  bool ended = false;
};

struct replay_context {
  trace_header header{};
  std::optional<target_info_record> target_info;
  std::optional<target_environment_record> target_environment;
  std::vector<register_spec> register_specs;
  std::vector<std::string> register_names;
  std::vector<module_record> modules;
  std::vector<memory_region_record> memory_map;
  std::unordered_map<uint64_t, module_record> modules_by_id;
  std::unordered_map<uint64_t, block_definition_record> blocks_by_id;
  std::vector<replay_thread_info> threads;
  std::optional<uint16_t> sp_reg_id;

  struct trace_features {
    bool has_registers = false;
    bool has_memory_access = false;
    bool has_memory_values = false;
    bool has_stack_snapshot = false;
    bool has_blocks = false;
    bool track_memory = false;
  };

  bool has_blocks() const;
  bool has_registers() const;
  trace_features features() const;

  const module_record* find_module_for_address(uint64_t address, uint64_t size, uint64_t& module_offset) const;
};

bool load_replay_context(const std::string& trace_path, replay_context& out, std::string& error);

} // namespace w1::rewind

```

`src/w1rewind/replay/replay_context_builder.cpp`:

```cpp
#include "replay_context_builder.hpp"

#include <algorithm>
#include <unordered_map>

#include "w1rewind/format/register_metadata.hpp"
#include "w1rewind/format/trace_validator.hpp"

namespace w1::rewind {

namespace {

std::optional<uint16_t> find_register_with_flag(const std::vector<register_spec>& specs, uint16_t flag) {
  for (const auto& spec : specs) {
    if ((spec.flags & flag) != 0) {
      return spec.reg_id;
    }
  }
  return std::nullopt;
}

void apply_module_load(std::vector<module_record>& modules, module_record module) {
  auto it =
      std::find_if(modules.begin(), modules.end(), [&](const module_record& entry) { return entry.id == module.id; });
  if (it != modules.end()) {
    *it = std::move(module);
    return;
  }
  modules.push_back(std::move(module));
}

void apply_module_unload(std::vector<module_record>& modules, const module_unload_record& record) {
  auto it = std::find_if(modules.begin(), modules.end(), [&](const module_record& entry) {
    return entry.id == record.module_id;
  });
  if (it != modules.end()) {
    modules.erase(it);
    return;
  }

  if (record.base == 0 && record.size == 0 && record.path.empty()) {
    return;
  }

  auto fallback = std::find_if(modules.begin(), modules.end(), [&](const module_record& entry) {
    if (record.base != 0 && entry.base != record.base) {
      return false;
    }
    if (record.size != 0 && entry.size != record.size) {
      return false;
    }
    if (!record.path.empty() && entry.path != record.path) {
      return false;
    }
    return true;
  });

  if (fallback != modules.end()) {
    modules.erase(fallback);
  }
}

} // namespace

bool build_replay_context(trace_record_stream& stream, replay_context& out, std::string& error) {
  error.clear();

  replay_context context;
  context.header = stream.header();

  std::unordered_map<uint64_t, replay_thread_info> thread_map;

  trace_record record;
  while (stream.read_next(record, nullptr)) {
    if (std::holds_alternative<target_info_record>(record)) {
      context.target_info = std::get<target_info_record>(record);
    } else if (std::holds_alternative<target_environment_record>(record)) {
      context.target_environment = std::get<target_environment_record>(record);
    } else if (std::holds_alternative<register_spec_record>(record)) {
      context.register_specs = std::get<register_spec_record>(record).registers;
    } else if (std::holds_alternative<module_table_record>(record)) {
      context.modules = std::get<module_table_record>(record).modules;
    } else if (std::holds_alternative<module_load_record>(record)) {
      apply_module_load(context.modules, std::get<module_load_record>(record).module);
    } else if (std::holds_alternative<module_unload_record>(record)) {
      apply_module_unload(context.modules, std::get<module_unload_record>(record));
    } else if (std::holds_alternative<memory_map_record>(record)) {
      context.memory_map = std::get<memory_map_record>(record).regions;
    } else if (std::holds_alternative<block_definition_record>(record)) {
      const auto& def = std::get<block_definition_record>(record);
      context.blocks_by_id[def.block_id] = def;
    } else if (std::holds_alternative<thread_start_record>(record)) {
      const auto& start = std::get<thread_start_record>(record);
      auto& info = thread_map[start.thread_id];
      info.thread_id = start.thread_id;
      info.started = true;
      if (!start.name.empty() && info.name.empty()) {
        info.name = start.name;
      }
    } else if (std::holds_alternative<thread_end_record>(record)) {
      const auto& end = std::get<thread_end_record>(record);
      auto& info = thread_map[end.thread_id];
      info.thread_id = end.thread_id;
      info.ended = true;
    }
  }

  if (!stream.error().empty()) {
    error = std::string(stream.error());
    return false;
  }

  if (!validate_trace_arch(context.header.arch, error)) {
    return false;
  }

  register_spec_validation_options reg_options{};
  reg_options.allow_empty = (context.header.flags & trace_flag_register_deltas) == 0;
  if (!normalize_register_specs(context.register_specs, error, reg_options)) {
    return false;
  }
  context.register_names.clear();
  context.register_names.reserve(context.register_specs.size());
  for (const auto& spec : context.register_specs) {
    context.register_names.push_back(spec.name);
  }

  context.modules_by_id.clear();
  context.modules_by_id.reserve(context.modules.size());
  for (const auto& module : context.modules) {
    context.modules_by_id[module.id] = module;
  }

  context.threads.reserve(thread_map.size());
  for (const auto& [_, info] : thread_map) {
    context.threads.push_back(info);
  }
  std::sort(
      context.threads.begin(), context.threads.end(),
      [](const replay_thread_info& lhs, const replay_thread_info& rhs) { return lhs.thread_id < rhs.thread_id; }
  );

  if (!context.register_names.empty()) {
    context.sp_reg_id = find_register_with_flag(context.register_specs, register_flag_sp);
    if (!context.sp_reg_id.has_value()) {
      context.sp_reg_id = resolve_sp_reg_id(context.header.arch, context.register_names);
    }
  }

  out = std::move(context);
  return true;
}

} // namespace w1::rewind

```

`src/w1rewind/replay/replay_context_builder.hpp`:

```hpp
#pragma once

#include <string>

#include "replay_context.hpp"
#include "w1rewind/trace/record_stream.hpp"

namespace w1::rewind {

bool build_replay_context(trace_record_stream& stream, replay_context& out, std::string& error);

} // namespace w1::rewind

```

`src/w1rewind/replay/replay_instruction_cursor.cpp`:

```cpp
#include "replay_instruction_cursor.hpp"

namespace w1::rewind {

namespace {

replay_notice make_notice(replay_notice_kind kind, const std::string& message) {
  replay_notice notice{};
  notice.kind = kind;
  notice.message = message;
  return notice;
}

} // namespace

replay_instruction_cursor::replay_instruction_cursor(stateful_flow_cursor& flow) : flow_(flow) {}

void replay_instruction_cursor::reset() {
  instruction_state_ = instruction_state{};
  current_step_ = flow_step{};
  has_position_ = false;
  notice_.reset();
  error_.clear();
}

void replay_instruction_cursor::sync_with_flow_step(const flow_step& step) {
  instruction_state_ = instruction_state{};
  current_step_ = step;
  has_position_ = true;
  notice_.reset();
  error_.clear();
}

bool replay_instruction_cursor::set_position(const flow_step& step, position_bias bias) {
  instruction_state_ = instruction_state{};
  current_step_ = step;
  has_position_ = true;
  notice_.reset();
  error_.clear();

  if (!is_block_trace()) {
    return true;
  }
  if (decoder_ == nullptr) {
    notice_ = make_notice(replay_notice_kind::decode_unavailable, "block decoder unavailable; using flow steps");
    return true;
  }
  if (step.block_id == 0) {
    return true;
  }

  auto it = flow_.context().blocks_by_id.find(step.block_id);
  if (it == flow_.context().blocks_by_id.end()) {
    notice_ = make_notice(replay_notice_kind::decode_failed, "block id not found");
    return true;
  }

  flow_step base = step;
  base.is_block = true;
  base.address = it->second.address;
  base.size = it->second.size;

  if (!set_instruction_state(base, 0, true)) {
    return true;
  }

  size_t index = 0;
  if (!step.is_block) {
    bool found = false;
    for (size_t i = 0; i < instruction_state_.block.instructions.size(); ++i) {
      if (instruction_state_.block.instructions[i].address == step.address) {
        index = i;
        found = true;
        break;
      }
    }
    if (!found) {
      notice_ = make_notice(replay_notice_kind::decode_failed, "instruction address not found in block");
      instruction_state_ = instruction_state{};
      return true;
    }
  } else if (bias == position_bias::end) {
    if (!instruction_state_.block.instructions.empty()) {
      index = instruction_state_.block.instructions.size() - 1;
    }
  }

  instruction_state_.instruction_index = index;
  flow_step inst_step{};
  if (build_instruction_step(instruction_state_, inst_step)) {
    current_step_ = inst_step;
  }
  return true;
}

bool replay_instruction_cursor::step_forward(flow_step& out) {
  error_.clear();

  if (!is_block_trace()) {
    return fallback_to_flow_forward(out, replay_notice{});
  }
  if (decoder_ == nullptr) {
    return fallback_to_flow_forward(
        out, make_notice(replay_notice_kind::decode_unavailable, "block decoder unavailable; using flow steps")
    );
  }

  if (instruction_state_.active) {
    auto next_index = instruction_state_.instruction_index + 1;
    if (next_index < instruction_state_.block.instructions.size()) {
      instruction_state_.instruction_index = next_index;
      flow_step step{};
      if (!build_instruction_step(instruction_state_, step)) {
        return false;
      }
      current_step_ = step;
      has_position_ = true;
      out = step;
      return true;
    }
    instruction_state_ = instruction_state{};
  }

  flow_step flow{};
  if (!flow_.step_forward(flow)) {
    error_ = flow_.error();
    return false;
  }

  if (!flow.is_block) {
    current_step_ = flow;
    has_position_ = true;
    out = flow;
    return true;
  }

  if (!set_instruction_state(flow, 0, true)) {
    current_step_ = flow;
    has_position_ = true;
    out = flow;
    return true;
  }

  flow_step step{};
  if (!build_instruction_step(instruction_state_, step)) {
    current_step_ = flow;
    has_position_ = true;
    out = flow;
    return true;
  }

  current_step_ = step;
  has_position_ = true;
  out = step;
  return true;
}

bool replay_instruction_cursor::step_backward(flow_step& out) {
  error_.clear();

  if (!flow_.has_position()) {
    error_ = "no current position";
    return false;
  }

  if (!is_block_trace()) {
    return fallback_to_flow_backward(out, replay_notice{});
  }
  if (decoder_ == nullptr) {
    return fallback_to_flow_backward(
        out, make_notice(replay_notice_kind::decode_unavailable, "block decoder unavailable; using flow steps")
    );
  }

  if (instruction_state_.active) {
    if (instruction_state_.instruction_index > 0) {
      instruction_state_.instruction_index -= 1;
      flow_step step{};
      if (!build_instruction_step(instruction_state_, step)) {
        return false;
      }
      current_step_ = step;
      has_position_ = true;
      out = step;
      return true;
    }
    instruction_state_ = instruction_state{};
  }

  if (has_position_ && current_step_.is_block) {
    if (set_instruction_state(current_step_, 0, true)) {
      instruction_state_.instruction_index = instruction_state_.block.instructions.size() - 1;
      flow_step step{};
      if (!build_instruction_step(instruction_state_, step)) {
        return false;
      }
      current_step_ = step;
      has_position_ = true;
      out = step;
      return true;
    }
  }

  flow_step flow{};
  if (!flow_.step_backward(flow)) {
    error_ = flow_.error();
    return false;
  }

  if (!flow.is_block) {
    current_step_ = flow;
    has_position_ = true;
    out = flow;
    return true;
  }

  if (!set_instruction_state(flow, 0, true)) {
    current_step_ = flow;
    has_position_ = true;
    out = flow;
    return true;
  }

  instruction_state_.instruction_index = instruction_state_.block.instructions.size() - 1;
  flow_step step{};
  if (!build_instruction_step(instruction_state_, step)) {
    current_step_ = flow;
    has_position_ = true;
    out = flow;
    return true;
  }

  current_step_ = step;
  has_position_ = true;
  out = step;
  return true;
}

std::optional<replay_notice> replay_instruction_cursor::take_notice() {
  if (!notice_.has_value()) {
    return std::nullopt;
  }
  auto out = *notice_;
  notice_.reset();
  return out;
}

bool replay_instruction_cursor::is_block_trace() const { return flow_.context().has_blocks(); }

bool replay_instruction_cursor::set_instruction_state(
    const flow_step& flow, size_t instruction_index, bool set_notice_on_failure
) {
  if (!flow.is_block) {
    return false;
  }
  decoded_block decoded{};
  std::string decode_error;
  if (!decoder_ || !decoder_->decode_block(flow_.context(), flow, decoded, decode_error) ||
      decoded.instructions.empty()) {
    if (set_notice_on_failure) {
      std::string message = decode_error.empty() ? "block decode failed; using flow steps" : decode_error;
      notice_ = make_notice(replay_notice_kind::decode_failed, message);
    }
    return false;
  }

  if (instruction_index >= decoded.instructions.size()) {
    if (set_notice_on_failure) {
      notice_ = make_notice(replay_notice_kind::decode_failed, "decoded instruction index out of range");
    }
    return false;
  }

  instruction_state_.active = true;
  instruction_state_.base_step = flow;
  instruction_state_.block = std::move(decoded);
  instruction_state_.instruction_index = instruction_index;
  return true;
}

bool replay_instruction_cursor::build_instruction_step(const instruction_state& state, flow_step& out) const {
  if (!state.active || state.block.instructions.empty()) {
    return false;
  }
  const auto& inst = state.block.instructions[state.instruction_index];
  flow_step step = state.base_step;
  step.is_block = false;
  step.size = inst.size;
  step.address = inst.address;
  out = step;
  return true;
}

bool replay_instruction_cursor::fallback_to_flow_forward(flow_step& out, replay_notice notice) {
  if (notice.kind != replay_notice_kind::none) {
    notice_ = notice;
  }
  flow_step flow{};
  if (!flow_.step_forward(flow)) {
    error_ = flow_.error();
    return false;
  }
  current_step_ = flow;
  has_position_ = true;
  out = flow;
  return true;
}

bool replay_instruction_cursor::fallback_to_flow_backward(flow_step& out, replay_notice notice) {
  if (notice.kind != replay_notice_kind::none) {
    notice_ = notice;
  }
  flow_step flow{};
  if (!flow_.step_backward(flow)) {
    error_ = flow_.error();
    return false;
  }
  current_step_ = flow;
  has_position_ = true;
  out = flow;
  return true;
}

} // namespace w1::rewind

```

`src/w1rewind/replay/replay_instruction_cursor.hpp`:

```hpp
#pragma once

#include <optional>
#include <string>

#include "block_decoder.hpp"
#include "stateful_flow_cursor.hpp"

namespace w1::rewind {

enum class replay_notice_kind { none, decode_unavailable, decode_failed };

struct replay_notice {
  replay_notice_kind kind = replay_notice_kind::none;
  std::string message;
};

class replay_instruction_cursor {
public:
  explicit replay_instruction_cursor(stateful_flow_cursor& flow);

  void set_decoder(block_decoder* decoder) { decoder_ = decoder; }
  void reset();
  void sync_with_flow_step(const flow_step& step);
  enum class position_bias { start, end };
  bool set_position(const flow_step& step, position_bias bias = position_bias::start);

  bool step_forward(flow_step& out);
  bool step_backward(flow_step& out);

  std::optional<replay_notice> take_notice();
  const std::string& error() const { return error_; }
  bool has_position() const { return has_position_; }
  const flow_step& current_step() const { return current_step_; }

private:
  struct instruction_state {
    flow_step base_step{};
    decoded_block block{};
    size_t instruction_index = 0;
    bool active = false;
  };

  bool is_block_trace() const;
  bool set_instruction_state(const flow_step& flow, size_t instruction_index, bool set_notice_on_failure);
  bool build_instruction_step(const instruction_state& state, flow_step& out) const;
  bool fallback_to_flow_forward(flow_step& out, replay_notice notice);
  bool fallback_to_flow_backward(flow_step& out, replay_notice notice);

  stateful_flow_cursor& flow_;
  block_decoder* decoder_ = nullptr;
  instruction_state instruction_state_{};
  flow_step current_step_{};
  bool has_position_ = false;
  std::optional<replay_notice> notice_;
  std::string error_;
};

} // namespace w1::rewind

```

`src/w1rewind/replay/replay_position.cpp`:

```cpp
#include "replay_position.hpp"

namespace w1::rewind {

bool position_normalizer::normalize(
    const replay_context& context, replay_position& pos, bool forward_bias, std::string& error
) const {
  error.clear();

  if (pos.kind == position_kind::instruction && pos.instruction.has_value()) {
    return true;
  }

  if (!pos.flow.is_block) {
    pos.kind = position_kind::instruction;
    pos.instruction = pos.flow;
    return true;
  }

  if (!decoder_) {
    error = "block decoder unavailable";
    return false;
  }

  decoded_block decoded{};
  if (!decoder_->decode_block(context, pos.flow, decoded, error)) {
    if (error.empty()) {
      error = "block decode failed";
    }
    return false;
  }

  if (decoded.instructions.empty()) {
    error = "decoded block has no instructions";
    return false;
  }

  size_t index = forward_bias ? 0 : decoded.instructions.size() - 1;
  const auto& inst = decoded.instructions[index];

  flow_step instruction = pos.flow;
  instruction.is_block = false;
  instruction.address = inst.address;
  instruction.size = inst.size;

  pos.kind = position_kind::instruction;
  pos.instruction = instruction;
  return true;
}

} // namespace w1::rewind

```

`src/w1rewind/replay/replay_position.hpp`:

```hpp
#pragma once

#include <optional>
#include <string>

#include "block_decoder.hpp"
#include "flow_types.hpp"
#include "replay_context.hpp"

namespace w1::rewind {

enum class position_kind { block, instruction };

struct replay_position {
  flow_step flow{};
  position_kind kind = position_kind::block;
  std::optional<flow_step> instruction;
};

class position_normalizer {
public:
  explicit position_normalizer(block_decoder* decoder) : decoder_(decoder) {}

  bool normalize(const replay_context& context, replay_position& pos, bool forward_bias, std::string& error) const;

private:
  block_decoder* decoder_ = nullptr;
};

} // namespace w1::rewind

```

`src/w1rewind/replay/replay_session.cpp`:

```cpp
#include "replay_session.hpp"

#include <cstddef>

namespace w1::rewind {

namespace {

std::vector<std::optional<uint64_t>> build_unknown_registers(size_t count) {
  return std::vector<std::optional<uint64_t>>(count, std::nullopt);
}

memory_read build_unknown_memory(size_t count) {
  memory_read out;
  out.bytes.assign(count, std::byte{0});
  out.known.assign(count, 0);
  return out;
}

replay_session::replay_error_kind map_flow_error_kind(flow_error_kind kind) {
  switch (kind) {
  case flow_error_kind::begin_of_trace:
    return replay_session::replay_error_kind::begin_of_trace;
  case flow_error_kind::end_of_trace:
    return replay_session::replay_error_kind::end_of_trace;
  case flow_error_kind::none:
    return replay_session::replay_error_kind::none;
  default:
    return replay_session::replay_error_kind::other;
  }
}

} // namespace

replay_session::replay_session(replay_session_config config) : config_(std::move(config)) {
  block_decoder_ = config_.block_decoder;
}

bool replay_session::open() {
  close();
  clear_error();

  if (!config_.stream) {
    set_error("trace stream required");
    return false;
  }
  if (!config_.index) {
    set_error("trace index required");
    return false;
  }
  if (config_.context.header.version == 0) {
    set_error("replay context required");
    return false;
  }

  context_ = config_.context;
  block_decoder_ = config_.block_decoder;

  if (config_.track_registers && context_.register_specs.empty() &&
      (context_.header.flags & trace_flag_register_deltas) != 0) {
    set_error("register specs missing");
    return false;
  }

  state_applier_.emplace(context_);
  record_stream_cursor stream_cursor(config_.stream);
  flow_extractor extractor(&context_);
  history_window history(config_.history_size);
  flow_cursor_.emplace(std::move(stream_cursor), std::move(extractor), std::move(history), config_.index);
  if (!flow_cursor_->open()) {
    set_error(map_flow_error_kind(flow_cursor_->error_kind()), std::string(flow_cursor_->error()));
    return false;
  }

  stateful_flow_cursor_.emplace(*flow_cursor_, *state_applier_, state_);
  stateful_flow_cursor_->configure(context_, config_.track_registers, config_.track_memory);
  instruction_cursor_.emplace(*stateful_flow_cursor_);
  instruction_cursor_->set_decoder(block_decoder_);

  if (config_.checkpoint) {
    checkpoint_index_ = config_.checkpoint;
    if (!validate_checkpoint(*checkpoint_index_)) {
      return false;
    }
  }

  open_ = true;

  if (config_.thread_id != 0) {
    if (!select_thread(config_.thread_id, config_.start_sequence)) {
      return false;
    }
  }

  return true;
}

void replay_session::close() {
  flow_cursor_.reset();
  stateful_flow_cursor_.reset();
  state_applier_.reset();
  instruction_cursor_.reset();
  context_ = replay_context{};
  state_.reset();
  current_position_ = replay_position{};
  current_step_ = flow_step{};
  active_thread_id_ = 0;
  checkpoint_index_.reset();
  notice_.reset();
  open_ = false;
  has_position_ = false;
  clear_error();
}

bool replay_session::select_thread(uint64_t thread_id, uint64_t sequence) {
  clear_error();

  if (!open_) {
    set_error("session not open");
    return false;
  }
  if (!flow_cursor_.has_value()) {
    set_error("flow cursor not ready");
    return false;
  }
  if (!stateful_flow_cursor_.has_value()) {
    set_error("stateful flow cursor not ready");
    return false;
  }

  stateful_flow_cursor_->configure(context_, config_.track_registers, config_.track_memory);

  bool used_checkpoint = false;
  if (checkpoint_index_ && (config_.track_registers || config_.track_memory)) {
    const auto* checkpoint = find_checkpoint(thread_id, sequence);
    if (checkpoint) {
      if (!apply_checkpoint(*checkpoint)) {
        return false;
      }
      if (!flow_cursor_->seek_from_location(thread_id, sequence, checkpoint->location)) {
        set_error(map_flow_error_kind(flow_cursor_->error_kind()), std::string(flow_cursor_->error()));
        return false;
      }
      used_checkpoint = true;
    }
  }

  bool used_snapshot = false;
  if (!used_checkpoint && (config_.track_registers || config_.track_memory) && config_.index) {
    auto snapshot = config_.index->find_snapshot(thread_id, sequence);
    if (snapshot.has_value() && snapshot->sequence == sequence) {
      if (sequence > 0) {
        snapshot = config_.index->find_snapshot(thread_id, sequence - 1);
      } else {
        snapshot.reset();
      }
    }
    if (snapshot.has_value()) {
      if (!flow_cursor_->seek_from_location(thread_id, sequence, {snapshot->chunk_index, snapshot->record_offset})) {
        set_error(map_flow_error_kind(flow_cursor_->error_kind()), std::string(flow_cursor_->error()));
        return false;
      }
      used_snapshot = true;
    }
  }

  if (!used_checkpoint && !used_snapshot) {
    if (!flow_cursor_->seek(thread_id, sequence)) {
      set_error(map_flow_error_kind(flow_cursor_->error_kind()), std::string(flow_cursor_->error()));
      return false;
    }
  }

  active_thread_id_ = thread_id;
  reset_instruction_cursor();
  has_position_ = false;
  current_position_ = replay_position{};
  current_step_ = flow_step{};
  return true;
}

bool replay_session::step_flow() {
  flow_step step{};
  if (!step_flow_internal(step)) {
    return false;
  }

  reset_instruction_cursor();
  if (instruction_cursor_.has_value()) {
    instruction_cursor_->sync_with_flow_step(step);
  }
  current_position_.flow = step;
  if (step.is_block) {
    current_position_.kind = position_kind::block;
    current_position_.instruction.reset();
    current_step_ = step;
  } else {
    current_position_.kind = position_kind::instruction;
    current_position_.instruction = step;
    current_step_ = step;
  }
  has_position_ = true;
  return true;
}

bool replay_session::step_backward() {
  reset_instruction_cursor();

  flow_step step{};
  if (!step_flow_backward_internal(step)) {
    return false;
  }

  if (instruction_cursor_.has_value()) {
    instruction_cursor_->sync_with_flow_step(step);
  }
  current_position_.flow = step;
  if (step.is_block) {
    current_position_.kind = position_kind::block;
    current_position_.instruction.reset();
    current_step_ = step;
  } else {
    current_position_.kind = position_kind::instruction;
    current_position_.instruction = step;
    current_step_ = step;
  }
  has_position_ = true;
  return true;
}

bool replay_session::step_instruction() {
  clear_error();

  if (!open_) {
    set_error("session not open");
    return false;
  }
  if (!instruction_cursor_.has_value()) {
    set_error("instruction cursor not ready");
    return false;
  }

  flow_step step{};
  if (!instruction_cursor_->step_forward(step)) {
    auto kind = replay_error_kind::other;
    if (flow_cursor_.has_value()) {
      auto mapped = map_flow_error_kind(flow_cursor_->error_kind());
      kind = mapped == replay_error_kind::none ? replay_error_kind::other : mapped;
    }
    set_error(kind, instruction_cursor_->error());
    return false;
  }

  if (auto notice = instruction_cursor_->take_notice(); notice.has_value()) {
    notice_ = notice;
  }

  if (stateful_flow_cursor_.has_value()) {
    current_position_.flow = stateful_flow_cursor_->current_step();
  } else {
    current_position_.flow = step;
  }
  if (step.is_block) {
    current_position_.kind = position_kind::block;
    current_position_.instruction.reset();
    current_step_ = step;
  } else {
    current_position_.kind = position_kind::instruction;
    current_position_.instruction = step;
    current_step_ = step;
  }
  has_position_ = true;
  return true;
}

bool replay_session::step_instruction_backward() {
  clear_error();

  if (!open_) {
    set_error("session not open");
    return false;
  }
  if (!instruction_cursor_.has_value()) {
    set_error("instruction cursor not ready");
    return false;
  }
  if (!has_position_) {
    set_error("no current position");
    return false;
  }

  flow_step step{};
  if (!instruction_cursor_->step_backward(step)) {
    auto kind = replay_error_kind::other;
    if (flow_cursor_.has_value()) {
      auto mapped = map_flow_error_kind(flow_cursor_->error_kind());
      kind = mapped == replay_error_kind::none ? replay_error_kind::other : mapped;
    }
    set_error(kind, instruction_cursor_->error());
    return false;
  }

  if (auto notice = instruction_cursor_->take_notice(); notice.has_value()) {
    notice_ = notice;
  }

  if (stateful_flow_cursor_.has_value()) {
    current_position_.flow = stateful_flow_cursor_->current_step();
  } else {
    current_position_.flow = step;
  }
  if (step.is_block) {
    current_position_.kind = position_kind::block;
    current_position_.instruction.reset();
    current_step_ = step;
  } else {
    current_position_.kind = position_kind::instruction;
    current_position_.instruction = step;
    current_step_ = step;
  }
  has_position_ = true;
  return true;
}

bool replay_session::sync_instruction_position(bool forward) {
  clear_error();

  if (!open_) {
    set_error("session not open");
    return false;
  }
  if (!instruction_cursor_.has_value()) {
    set_error("instruction cursor not ready");
    return false;
  }
  if (!has_position_) {
    set_error("no current position");
    return false;
  }

  replay_position normalized = current_position_;
  position_normalizer normalizer(block_decoder_);
  std::string error;
  if (!normalizer.normalize(context_, normalized, forward, error)) {
    set_error(error.empty() ? "failed to normalize position" : error);
    return false;
  }

  if (normalized.instruction.has_value()) {
    instruction_cursor_->set_position(
        *normalized.instruction,
        forward ? replay_instruction_cursor::position_bias::start : replay_instruction_cursor::position_bias::end
    );
    if (auto notice = instruction_cursor_->take_notice(); notice.has_value()) {
      notice_ = notice;
    }
    current_step_ = *normalized.instruction;
  } else {
    current_step_ = normalized.flow;
  }

  current_position_ = normalized;
  has_position_ = true;
  return true;
}

std::vector<std::optional<uint64_t>> replay_session::read_registers() const {
  const size_t count = context_.register_specs.size();
  if (!config_.track_registers || !stateful_flow_cursor_.has_value()) {
    return build_unknown_registers(count);
  }
  const auto& regs = state_.registers();
  if (regs.size() == count) {
    return regs;
  }

  auto out = build_unknown_registers(count);
  size_t copy_count = std::min(out.size(), regs.size());
  for (size_t i = 0; i < copy_count; ++i) {
    out[i] = regs[i];
  }
  return out;
}

bool replay_session::read_register_bytes(uint16_t reg_id, std::span<std::byte> out, bool& known) const {
  known = false;
  if (!config_.track_registers || !stateful_flow_cursor_.has_value()) {
    return true;
  }
  if (reg_id >= context_.register_specs.size()) {
    return false;
  }
  const auto& spec = context_.register_specs[reg_id];
  if (spec.value_kind != register_value_kind::bytes) {
    return false;
  }
  size_t size = (spec.bits + 7u) / 8u;
  if (size == 0 || out.size() < size) {
    return false;
  }
  return state_.copy_register_bytes(reg_id, out, known);
}

memory_read replay_session::read_memory(uint64_t address, size_t size) const {
  if (!config_.track_memory || !stateful_flow_cursor_.has_value()) {
    return build_unknown_memory(size);
  }
  return state_.read_memory(address, size);
}

const replay_state* replay_session::state() const {
  if (!stateful_flow_cursor_.has_value() || (!config_.track_registers && !config_.track_memory)) {
    return nullptr;
  }
  return &state_;
}

bool replay_session::apply_checkpoint(const replay_checkpoint_entry& checkpoint) {
  state_.reset();
  if (config_.track_registers) {
    state_.set_register_specs(context_.register_specs);
    state_.apply_register_snapshot(checkpoint.registers);
    if (!checkpoint.register_bytes_entries.empty()) {
      if (!state_.apply_register_bytes(checkpoint.register_bytes_entries, checkpoint.register_bytes)) {
        set_error("checkpoint register bytes mismatch");
        return false;
      }
    }
  }
  if (config_.track_memory) {
    state_.set_memory_spans(checkpoint.memory);
  }
  return true;
}

bool replay_session::validate_checkpoint(const replay_checkpoint_index& index) {
  if (index.header.trace_version != context_.header.version) {
    set_error("checkpoint trace version mismatch");
    return false;
  }
  if (index.header.trace_flags != context_.header.flags) {
    set_error("checkpoint trace flags mismatch");
    return false;
  }
  if (index.header.arch != context_.header.arch) {
    set_error("checkpoint architecture mismatch");
    return false;
  }
  if (!context_.register_specs.empty() && index.header.register_count != context_.register_specs.size()) {
    set_error("checkpoint register count mismatch");
    return false;
  }
  return true;
}

const replay_checkpoint_entry* replay_session::find_checkpoint(uint64_t thread_id, uint64_t sequence) const {
  if (!checkpoint_index_) {
    return nullptr;
  }
  return checkpoint_index_->find_checkpoint(thread_id, sequence);
}

std::optional<replay_notice> replay_session::take_notice() {
  if (!notice_.has_value()) {
    return std::nullopt;
  }
  auto out = *notice_;
  notice_.reset();
  return out;
}

void replay_session::reset_instruction_cursor() {
  if (instruction_cursor_.has_value()) {
    instruction_cursor_->reset();
  }
  notice_.reset();
}

bool replay_session::step_flow_internal(flow_step& out) {
  clear_error();

  if (!open_) {
    set_error("session not open");
    return false;
  }
  if (!stateful_flow_cursor_.has_value()) {
    set_error("flow cursor not ready");
    return false;
  }

  flow_step step{};
  if (!stateful_flow_cursor_->step_forward(step)) {
    set_error(map_flow_error_kind(stateful_flow_cursor_->error_kind()), std::string(stateful_flow_cursor_->error()));
    return false;
  }

  out = step;
  return true;
}

bool replay_session::step_flow_backward_internal(flow_step& out) {
  clear_error();

  if (!open_) {
    set_error("session not open");
    return false;
  }
  if (!flow_cursor_.has_value() || !stateful_flow_cursor_.has_value()) {
    set_error("flow cursor not ready");
    return false;
  }
  if (!has_position_) {
    set_error("no current position");
    return false;
  }
  if (current_step_.sequence == 0) {
    set_error(replay_error_kind::begin_of_trace, "at start of trace");
    return false;
  }

  bool track_state = config_.track_registers || config_.track_memory;
  uint64_t target = current_step_.sequence - 1;

  if (track_state) {
    if (checkpoint_index_) {
      const auto* checkpoint = find_checkpoint(active_thread_id_, target);
      if (checkpoint) {
        stateful_flow_cursor_->configure(context_, config_.track_registers, config_.track_memory);
        if (!apply_checkpoint(*checkpoint)) {
          return false;
        }
        if (!flow_cursor_->seek_from_location(active_thread_id_, target, checkpoint->location)) {
          set_error(map_flow_error_kind(flow_cursor_->error_kind()), std::string(flow_cursor_->error()));
          return false;
        }
        flow_step step{};
        if (!stateful_flow_cursor_->step_forward(step)) {
          set_error(
              map_flow_error_kind(stateful_flow_cursor_->error_kind()), std::string(stateful_flow_cursor_->error())
          );
          return false;
        }
        out = step;
        return true;
      }
    }

    std::optional<trace_anchor> snapshot;
    if (config_.index) {
      snapshot = config_.index->find_snapshot(active_thread_id_, target);
      if (snapshot.has_value() && snapshot->sequence == target) {
        if (target > 0) {
          snapshot = config_.index->find_snapshot(active_thread_id_, target - 1);
        } else {
          snapshot.reset();
        }
      }
    }

    stateful_flow_cursor_->configure(context_, config_.track_registers, config_.track_memory);
    if (snapshot.has_value()) {
      if (!flow_cursor_->seek_from_location(
              active_thread_id_, target, {snapshot->chunk_index, snapshot->record_offset}
          )) {
        set_error(map_flow_error_kind(flow_cursor_->error_kind()), std::string(flow_cursor_->error()));
        return false;
      }
    } else {
      if (!flow_cursor_->seek(active_thread_id_, target)) {
        set_error(map_flow_error_kind(flow_cursor_->error_kind()), std::string(flow_cursor_->error()));
        return false;
      }
    }

    flow_step step{};
    if (!stateful_flow_cursor_->step_forward(step)) {
      set_error(map_flow_error_kind(stateful_flow_cursor_->error_kind()), std::string(stateful_flow_cursor_->error()));
      return false;
    }
    out = step;
    return true;
  }

  flow_step step{};
  if (!stateful_flow_cursor_->step_backward(step)) {
    set_error(map_flow_error_kind(stateful_flow_cursor_->error_kind()), std::string(stateful_flow_cursor_->error()));
    return false;
  }

  out = step;
  return true;
}

void replay_session::clear_error() {
  error_.clear();
  error_kind_ = replay_error_kind::none;
}

void replay_session::set_error(const std::string& message) { set_error(replay_error_kind::other, message); }

void replay_session::set_error(replay_error_kind kind, const std::string& message) {
  error_ = message;
  error_kind_ = kind;
}

} // namespace w1::rewind

```

`src/w1rewind/replay/replay_session.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <memory>
#include <optional>
#include <span>
#include <string>
#include <vector>

#include "flow_cursor.hpp"
#include "w1rewind/trace/replay_checkpoint.hpp"
#include "w1rewind/trace/record_stream.hpp"
#include "replay_context.hpp"
#include "block_decoder.hpp"
#include "replay_instruction_cursor.hpp"
#include "replay_position.hpp"
#include "replay_state.hpp"
#include "replay_state_applier.hpp"
#include "stateful_flow_cursor.hpp"

namespace w1::rewind {

struct replay_session_config {
  std::shared_ptr<trace_record_stream> stream;
  std::shared_ptr<trace_index> index;
  std::shared_ptr<replay_checkpoint_index> checkpoint;
  replay_context context;
  uint32_t history_size = 1024;
  bool track_registers = false;
  bool track_memory = false;
  uint64_t thread_id = 0;
  uint64_t start_sequence = 0;
  block_decoder* block_decoder = nullptr;
};

class replay_session {
public:
  explicit replay_session(replay_session_config config);

  bool open();
  void close();

  bool select_thread(uint64_t thread_id, uint64_t sequence);
  bool step_flow();
  bool step_backward();
  bool step_instruction();
  bool step_instruction_backward();
  bool sync_instruction_position(bool forward = true);

  const flow_step& current_step() const { return current_step_; }
  const replay_context& context() const { return context_; }
  const std::vector<std::string>& register_names() const { return context_.register_names; }
  const std::vector<register_spec>& register_specs() const { return context_.register_specs; }
  std::vector<std::optional<uint64_t>> read_registers() const;
  bool read_register_bytes(uint16_t reg_id, std::span<std::byte> out, bool& known) const;
  memory_read read_memory(uint64_t address, size_t size) const;
  const trace_header& header() const { return context_.header; }
  const std::vector<module_record>& modules() const { return context_.modules; }
  const std::vector<replay_thread_info>& threads() const { return context_.threads; }
  const replay_state* state() const;
  std::optional<replay_notice> take_notice();
  const std::string& error() const { return error_; }
  enum class replay_error_kind { none, begin_of_trace, end_of_trace, other };
  replay_error_kind error_kind() const { return error_kind_; }
  const replay_position& current_position() const { return current_position_; }

private:
  bool apply_checkpoint(const replay_checkpoint_entry& checkpoint);
  bool validate_checkpoint(const replay_checkpoint_index& index);
  const replay_checkpoint_entry* find_checkpoint(uint64_t thread_id, uint64_t sequence) const;
  bool step_flow_backward_internal(flow_step& out);
  bool step_flow_internal(flow_step& out);
  void reset_instruction_cursor();
  void clear_error();
  void set_error(const std::string& message);
  void set_error(replay_error_kind kind, const std::string& message);

  replay_session_config config_;
  replay_context context_{};
  std::optional<flow_cursor> flow_cursor_;
  std::optional<stateful_flow_cursor> stateful_flow_cursor_;
  std::optional<replay_state_applier> state_applier_;
  replay_state state_{};
  std::optional<replay_instruction_cursor> instruction_cursor_;
  std::optional<replay_notice> notice_;
  replay_position current_position_{};
  flow_step current_step_{};
  uint64_t active_thread_id_ = 0;
  block_decoder* block_decoder_ = nullptr;
  std::shared_ptr<replay_checkpoint_index> checkpoint_index_;
  bool open_ = false;
  bool has_position_ = false;
  std::string error_;
  replay_error_kind error_kind_ = replay_error_kind::none;
};

} // namespace w1::rewind

```

`src/w1rewind/replay/replay_state.cpp`:

```cpp
#include "replay_state.hpp"

#include <algorithm>
#include <cstddef>
#include <cstring>

namespace w1::rewind {

void replay_state::reset() {
  registers_.clear();
  reset_register_bytes();
  memory_.clear();
}

void replay_state::set_register_specs(const std::vector<register_spec>& specs) {
  registers_.assign(specs.size(), std::nullopt);
  register_byte_offsets_.assign(specs.size(), 0);
  register_byte_sizes_.assign(specs.size(), 0);
  register_bytes_known_.assign(specs.size(), 0);
  register_bytes_.clear();

  for (size_t i = 0; i < specs.size(); ++i) {
    const auto& spec = specs[i];
    if (spec.value_kind != register_value_kind::bytes) {
      continue;
    }
    uint32_t size = (spec.bits + 7u) / 8u;
    register_byte_offsets_[i] = static_cast<uint32_t>(register_bytes_.size());
    register_byte_sizes_[i] = static_cast<uint16_t>(size);
    register_bytes_.resize(register_bytes_.size() + size, 0);
  }
}

void replay_state::set_register_count(size_t count) {
  registers_.assign(count, std::nullopt);
  reset_register_bytes();
}

void replay_state::ensure_register_capacity(size_t count) {
  if (registers_.size() < count) {
    registers_.resize(count, std::nullopt);
  }
}

void replay_state::apply_register_snapshot(const std::vector<register_delta>& regs) {
  size_t max_id = 0;
  for (const auto& reg : regs) {
    max_id = std::max(max_id, static_cast<size_t>(reg.reg_id));
  }
  ensure_register_capacity(max_id + 1);
  for (auto& value : registers_) {
    value.reset();
  }
  for (const auto& reg : regs) {
    registers_[reg.reg_id] = reg.value;
  }
}

void replay_state::apply_register_deltas(const std::vector<register_delta>& regs) {
  size_t max_id = 0;
  for (const auto& reg : regs) {
    max_id = std::max(max_id, static_cast<size_t>(reg.reg_id));
  }
  ensure_register_capacity(max_id + 1);
  for (const auto& reg : regs) {
    registers_[reg.reg_id] = reg.value;
  }
}

bool replay_state::apply_register_bytes(
    const std::vector<register_bytes_entry>& entries, const std::vector<uint8_t>& data
) {
  if (entries.empty()) {
    return true;
  }
  if (register_byte_sizes_.empty()) {
    return false;
  }

  for (const auto& entry : entries) {
    if (entry.reg_id >= register_byte_sizes_.size()) {
      return false;
    }
    uint16_t expected = register_byte_sizes_[entry.reg_id];
    if (expected == 0 || entry.size != expected) {
      return false;
    }
    uint64_t end = static_cast<uint64_t>(entry.offset) + static_cast<uint64_t>(entry.size);
    if (end > data.size()) {
      return false;
    }
  }

  for (const auto& entry : entries) {
    uint32_t offset = register_byte_offsets_[entry.reg_id];
    uint16_t size = entry.size;
    std::memcpy(register_bytes_.data() + offset, data.data() + entry.offset, size);
    register_bytes_known_[entry.reg_id] = 1;
  }
  return true;
}

void replay_state::collect_register_bytes(
    std::vector<register_bytes_entry>& entries, std::vector<uint8_t>& data
) const {
  entries.clear();
  data.clear();
  if (register_byte_sizes_.empty()) {
    return;
  }

  size_t total = 0;
  size_t count = 0;
  for (size_t i = 0; i < register_byte_sizes_.size(); ++i) {
    uint16_t size = register_byte_sizes_[i];
    if (size == 0 || register_bytes_known_[i] == 0) {
      continue;
    }
    total += size;
    count += 1;
  }

  if (count == 0) {
    return;
  }

  entries.reserve(count);
  data.reserve(total);

  for (size_t i = 0; i < register_byte_sizes_.size(); ++i) {
    uint16_t size = register_byte_sizes_[i];
    if (size == 0 || register_bytes_known_[i] == 0) {
      continue;
    }

    register_bytes_entry entry{};
    entry.reg_id = static_cast<uint16_t>(i);
    entry.offset = static_cast<uint32_t>(data.size());
    entry.size = size;

    uint32_t offset = register_byte_offsets_[i];
    data.insert(
        data.end(), register_bytes_.begin() + static_cast<std::ptrdiff_t>(offset),
        register_bytes_.begin() + static_cast<std::ptrdiff_t>(offset + size)
    );

    entries.push_back(entry);
  }
}

std::optional<uint64_t> replay_state::register_value(uint16_t reg_id) const {
  if (reg_id >= registers_.size()) {
    return std::nullopt;
  }
  return registers_[reg_id];
}

bool replay_state::copy_register_bytes(uint16_t reg_id, std::span<std::byte> out, bool& known) const {
  if (reg_id >= register_byte_sizes_.size()) {
    return false;
  }
  uint16_t size = register_byte_sizes_[reg_id];
  if (size == 0 || out.size() < size) {
    return false;
  }
  known = register_bytes_known_[reg_id] != 0;
  if (!known) {
    return true;
  }
  uint32_t offset = register_byte_offsets_[reg_id];
  std::memcpy(out.data(), register_bytes_.data() + offset, size);
  return true;
}

void replay_state::apply_memory_bytes(uint64_t address, std::span<const uint8_t> data) {
  memory_.apply_bytes(address, data);
}

void replay_state::apply_stack_segments(const std::vector<stack_segment>& segments) {
  if (segments.empty()) {
    return;
  }
  for (const auto& segment : segments) {
    if (segment.bytes.empty() || segment.size == 0) {
      continue;
    }
    if (segment.size != segment.bytes.size()) {
      continue;
    }
    memory_.apply_bytes(segment.base, segment.bytes);
  }
}

void replay_state::set_memory_spans(std::span<const memory_span> spans) {
  memory_.clear();
  memory_.apply_segments(spans);
}

memory_read replay_state::read_memory(uint64_t address, size_t size) const { return memory_.read(address, size); }

void replay_state::reset_register_bytes() {
  register_byte_offsets_.clear();
  register_byte_sizes_.clear();
  register_bytes_.clear();
  register_bytes_known_.clear();
}

} // namespace w1::rewind

```

`src/w1rewind/replay/replay_state.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>
#include <span>
#include <vector>

#include "w1rewind/format/trace_format.hpp"
#include "w1rewind/replay/memory_store.hpp"

namespace w1::rewind {

class replay_state {
public:
  void reset();
  void set_register_specs(const std::vector<register_spec>& specs);
  void set_register_count(size_t count);
  void apply_register_snapshot(const std::vector<register_delta>& regs);
  void apply_register_deltas(const std::vector<register_delta>& regs);
  bool apply_register_bytes(const std::vector<register_bytes_entry>& entries, const std::vector<uint8_t>& data);
  void collect_register_bytes(std::vector<register_bytes_entry>& entries, std::vector<uint8_t>& data) const;
  std::optional<uint64_t> register_value(uint16_t reg_id) const;
  bool copy_register_bytes(uint16_t reg_id, std::span<std::byte> out, bool& known) const;
  const std::vector<std::optional<uint64_t>>& registers() const { return registers_; }
  const memory_store& memory_store() const { return memory_; }
  void set_memory_spans(std::span<const memory_span> spans);

  void apply_memory_bytes(uint64_t address, std::span<const uint8_t> data);
  void apply_stack_segments(const std::vector<stack_segment>& segments);
  memory_read read_memory(uint64_t address, size_t size) const;

private:
  void ensure_register_capacity(size_t count);
  void reset_register_bytes();

  std::vector<std::optional<uint64_t>> registers_;
  std::vector<uint32_t> register_byte_offsets_;
  std::vector<uint16_t> register_byte_sizes_;
  std::vector<uint8_t> register_bytes_;
  std::vector<uint8_t> register_bytes_known_;
  w1::rewind::memory_store memory_;
};

} // namespace w1::rewind

```

`src/w1rewind/replay/replay_state_applier.cpp`:

```cpp
#include "replay_state_applier.hpp"

namespace w1::rewind {

bool replay_state_applier::apply_record(
    const trace_record& record, uint64_t active_thread_id, bool track_registers, bool track_memory, replay_state& state
) const {
  if (!(track_registers || track_memory) || active_thread_id == 0) {
    return true;
  }

  if (std::holds_alternative<register_delta_record>(record)) {
    return apply_register_deltas(std::get<register_delta_record>(record), active_thread_id, track_registers, state);
  }
  if (std::holds_alternative<register_bytes_record>(record)) {
    return apply_register_bytes(std::get<register_bytes_record>(record), active_thread_id, track_registers, state);
  }
  if (std::holds_alternative<memory_access_record>(record)) {
    return apply_memory_access(std::get<memory_access_record>(record), active_thread_id, track_memory, state);
  }
  if (std::holds_alternative<snapshot_record>(record)) {
    return apply_snapshot(std::get<snapshot_record>(record), active_thread_id, track_registers, track_memory, state);
  }

  return true;
}

bool replay_state_applier::apply_register_deltas(
    const register_delta_record& record, uint64_t active_thread_id, bool track_registers, replay_state& state
) const {
  if (!track_registers) {
    return true;
  }
  if (record.thread_id != active_thread_id) {
    return true;
  }
  state.apply_register_deltas(record.deltas);
  return true;
}

bool replay_state_applier::apply_register_bytes(
    const register_bytes_record& record, uint64_t active_thread_id, bool track_registers, replay_state& state
) const {
  if (!track_registers) {
    return true;
  }
  if (record.thread_id != active_thread_id) {
    return true;
  }
  return state.apply_register_bytes(record.entries, record.data);
}

bool replay_state_applier::apply_memory_access(
    const memory_access_record& record, uint64_t active_thread_id, bool track_memory, replay_state& state
) const {
  if (!track_memory) {
    return true;
  }
  if (record.thread_id != active_thread_id) {
    return true;
  }
  if (!record.value_known || record.data.empty()) {
    return true;
  }
  state.apply_memory_bytes(record.address, record.data);
  return true;
}

bool replay_state_applier::apply_snapshot(
    const snapshot_record& record, uint64_t active_thread_id, bool track_registers, bool track_memory,
    replay_state& state
) const {
  if (record.thread_id != active_thread_id) {
    return true;
  }

  if (track_registers && !record.registers.empty()) {
    state.apply_register_snapshot(record.registers);
  }

  if (!track_memory || record.stack_segments.empty()) {
    return true;
  }

  state.apply_stack_segments(record.stack_segments);

  return true;
}

} // namespace w1::rewind

```

`src/w1rewind/replay/replay_state_applier.hpp`:

```hpp
#pragma once

#include <cstdint>

#include "replay_context.hpp"
#include "replay_state.hpp"
#include "w1rewind/format/trace_format.hpp"

namespace w1::rewind {

class replay_state_applier {
public:
  explicit replay_state_applier(const replay_context& context) : context_(context) {}

  bool apply_record(
      const trace_record& record, uint64_t active_thread_id, bool track_registers, bool track_memory,
      replay_state& state
  ) const;

  bool apply_snapshot(
      const snapshot_record& record, uint64_t active_thread_id, bool track_registers, bool track_memory,
      replay_state& state
  ) const;

  bool apply_register_deltas(
      const register_delta_record& record, uint64_t active_thread_id, bool track_registers, replay_state& state
  ) const;

  bool apply_register_bytes(
      const register_bytes_record& record, uint64_t active_thread_id, bool track_registers, replay_state& state
  ) const;

  bool apply_memory_access(
      const memory_access_record& record, uint64_t active_thread_id, bool track_memory, replay_state& state
  ) const;

private:
  [[maybe_unused]] const replay_context& context_;
};

} // namespace w1::rewind

```

`src/w1rewind/replay/stateful_flow_cursor.cpp`:

```cpp
#include "stateful_flow_cursor.hpp"

namespace w1::rewind {

stateful_flow_cursor::stateful_flow_cursor(flow_cursor& flow, replay_state_applier& applier, replay_state& state)
    : flow_(flow), applier_(applier), state_(state) {
  flow_.set_observer(this);
}

stateful_flow_cursor::~stateful_flow_cursor() { flow_.set_observer(nullptr); }

void stateful_flow_cursor::configure(const replay_context& context, bool track_registers, bool track_memory) {
  track_registers_ = track_registers;
  track_memory_ = track_memory;
  flow_.set_history_enabled(!(track_registers_ || track_memory_));
  reset_state(context);
}

bool stateful_flow_cursor::step_forward(flow_step& out) { return flow_.step_forward(out); }

bool stateful_flow_cursor::step_backward(flow_step& out) {
  if (track_registers_ || track_memory_) {
    reset_state(flow_.context());
  }
  return flow_.step_backward(out);
}

bool stateful_flow_cursor::on_record(const trace_record& record, uint64_t active_thread_id, std::string& error) {
  if (!track_registers_ && !track_memory_) {
    return true;
  }
  if (!applier_.apply_record(record, active_thread_id, track_registers_, track_memory_, state_)) {
    error = "failed to apply trace record";
    return false;
  }
  return true;
}

void stateful_flow_cursor::reset_state(const replay_context& context) {
  state_.reset();
  if (track_registers_) {
    state_.set_register_specs(context.register_specs);
  }
}

} // namespace w1::rewind

```

`src/w1rewind/replay/stateful_flow_cursor.hpp`:

```hpp
#pragma once

#include <string_view>

#include "flow_cursor.hpp"
#include "replay_state.hpp"
#include "replay_state_applier.hpp"

namespace w1::rewind {

class stateful_flow_cursor final : private flow_record_observer {
public:
  explicit stateful_flow_cursor(flow_cursor& flow, replay_state_applier& applier, replay_state& state);
  ~stateful_flow_cursor() override;

  void configure(const replay_context& context, bool track_registers, bool track_memory);

  bool step_forward(flow_step& out);
  bool step_backward(flow_step& out);

  const replay_state& state() const { return state_; }
  const replay_context& context() const { return flow_.context(); }
  bool has_position() const { return flow_.has_position(); }
  const flow_step& current_step() const { return flow_.current_step(); }
  std::string_view error() const { return flow_.error(); }
  flow_error_kind error_kind() const { return flow_.error_kind(); }

private:
  bool on_record(const trace_record& record, uint64_t active_thread_id, std::string& error) override;
  void reset_state(const replay_context& context);

  flow_cursor& flow_;
  replay_state_applier& applier_;
  replay_state& state_;
  bool track_registers_ = false;
  bool track_memory_ = false;
};

} // namespace w1::rewind

```

`src/w1rewind/trace/flow_classifier.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <optional>

#include "w1rewind/format/trace_format.hpp"

namespace w1::rewind {

enum class flow_record_kind { instruction, block_exec };

struct flow_record_key {
  flow_record_kind kind = flow_record_kind::instruction;
  uint64_t sequence = 0;
  uint64_t thread_id = 0;
};

inline std::optional<flow_record_key> classify_flow_record(const trace_record& record, bool use_blocks) {
  if (use_blocks) {
    if (const auto* exec = std::get_if<block_exec_record>(&record)) {
      return flow_record_key{flow_record_kind::block_exec, exec->sequence, exec->thread_id};
    }
    return std::nullopt;
  }
  if (const auto* inst = std::get_if<instruction_record>(&record)) {
    return flow_record_key{flow_record_kind::instruction, inst->sequence, inst->thread_id};
  }
  return std::nullopt;
}

} // namespace w1::rewind

```

`src/w1rewind/trace/record_sink.hpp`:

```hpp
#pragma once

#include "w1rewind/format/trace_format.hpp"

namespace w1::rewind {

class trace_record_sink {
public:
  virtual ~trace_record_sink() = default;

  virtual bool good() const = 0;
  virtual bool write_header(const trace_header& header) = 0;
  virtual bool write_target_info(const target_info_record& record) = 0;
  virtual bool write_target_environment(const target_environment_record& record) = 0;
  virtual bool write_register_spec(const register_spec_record& record) = 0;
  virtual bool write_module_table(const module_table_record& record) = 0;
  virtual bool write_module_load(const module_load_record& record) = 0;
  virtual bool write_module_unload(const module_unload_record& record) = 0;
  virtual bool write_memory_map(const memory_map_record& record) = 0;
  virtual bool write_thread_start(const thread_start_record& record) = 0;
  virtual bool write_instruction(const instruction_record& record) = 0;
  virtual bool write_block_definition(const block_definition_record& record) = 0;
  virtual bool write_block_exec(const block_exec_record& record) = 0;
  virtual bool write_register_deltas(const register_delta_record& record) = 0;
  virtual bool write_register_bytes(const register_bytes_record& record) = 0;
  virtual bool write_memory_access(const memory_access_record& record) = 0;
  virtual bool write_snapshot(const snapshot_record& record) = 0;
  virtual bool write_thread_end(const thread_end_record& record) = 0;
  virtual void flush() = 0;
};

} // namespace w1::rewind

```

`src/w1rewind/trace/record_stream.hpp`:

```hpp
#pragma once

#include <optional>
#include <string_view>

#include "w1rewind/format/trace_format.hpp"

namespace w1::rewind {

struct trace_chunk_info {
  uint64_t file_offset = 0;
  uint32_t compressed_size = 0;
  uint32_t uncompressed_size = 0;
};

struct trace_record_location {
  uint32_t chunk_index = 0;
  uint32_t record_offset = 0;
};

class trace_record_stream {
public:
  virtual ~trace_record_stream() = default;
  virtual bool open() = 0;
  virtual void close() = 0;
  virtual bool read_next(trace_record& record, trace_record_location* location) = 0;
  virtual bool seek_to_location(const trace_record_location& location) = 0;
  virtual const trace_header& header() const = 0;
  virtual const std::optional<trace_chunk_info>& last_chunk_info() const = 0;
  virtual std::string_view error() const = 0;
};

} // namespace w1::rewind

```

`src/w1rewind/trace/replay_checkpoint.cpp`:

```cpp
#include "replay_checkpoint.hpp"

#include <algorithm>
#include <cstring>
#include <fstream>
#include <limits>
#include <map>

#include "w1rewind/format/trace_io.hpp"
#include "w1rewind/trace/flow_classifier.hpp"
#include "w1rewind/replay/replay_context.hpp"
#include "w1rewind/replay/replay_state_applier.hpp"

namespace w1::rewind {

namespace {

struct thread_build_state {
  uint64_t flow_count = 0;
  replay_state state{};
  std::vector<replay_checkpoint_entry> entries;
};

replay_checkpoint_entry snapshot_entry(
    uint64_t thread_id, uint64_t sequence, const trace_record_location& location, const replay_state& state,
    bool include_memory
) {
  replay_checkpoint_entry entry{};
  entry.thread_id = thread_id;
  entry.sequence = sequence;
  entry.location = location;

  const auto& regs = state.registers();
  entry.registers.reserve(regs.size());
  for (size_t i = 0; i < regs.size(); ++i) {
    if (!regs[i].has_value()) {
      continue;
    }
    register_delta delta{};
    delta.reg_id = static_cast<uint16_t>(i);
    delta.value = *regs[i];
    entry.registers.push_back(delta);
  }

  state.collect_register_bytes(entry.register_bytes_entries, entry.register_bytes);

  if (include_memory) {
    entry.memory = state.memory_store().spans();
  }

  return entry;
}

bool write_checkpoint_header(
    std::ostream& out, const replay_checkpoint_header& header, uint32_t thread_count, uint32_t entry_count
) {
  if (!write_stream_bytes(out, k_replay_checkpoint_magic.data(), k_replay_checkpoint_magic.size())) {
    return false;
  }
  uint8_t arch_order = static_cast<uint8_t>(header.arch.arch_byte_order);
  uint8_t reserved = 0;
  return write_stream_u16(out, header.version) && write_stream_u16(out, header.trace_version) &&
         write_stream_u16(out, static_cast<uint16_t>(header.arch.arch_family)) &&
         write_stream_u16(out, static_cast<uint16_t>(header.arch.arch_mode)) &&
         write_stream_bytes(out, &arch_order, sizeof(arch_order)) &&
         write_stream_bytes(out, &reserved, sizeof(reserved)) && write_stream_u32(out, header.arch.pointer_bits) &&
         write_stream_u32(out, header.arch.flags) && write_stream_u64(out, header.trace_flags) &&
         write_stream_u32(out, header.register_count) && write_stream_u32(out, header.stride) &&
         write_stream_u32(out, thread_count) && write_stream_u32(out, entry_count);
}

bool read_checkpoint_header(
    std::istream& in, replay_checkpoint_header& header, uint32_t& thread_count, uint32_t& entry_count
) {
  std::array<uint8_t, 8> magic{};
  if (!read_stream_bytes(in, magic.data(), magic.size())) {
    return false;
  }
  if (std::memcmp(magic.data(), k_replay_checkpoint_magic.data(), k_replay_checkpoint_magic.size()) != 0) {
    return false;
  }

  uint16_t arch_family = 0;
  uint16_t arch_mode = 0;
  uint8_t arch_order = 0;
  uint8_t reserved = 0;
  if (!read_stream_u16(in, header.version) || !read_stream_u16(in, header.trace_version) ||
      !read_stream_u16(in, arch_family) || !read_stream_u16(in, arch_mode) ||
      !read_stream_bytes(in, &arch_order, sizeof(arch_order)) || !read_stream_bytes(in, &reserved, sizeof(reserved)) ||
      !read_stream_u32(in, header.arch.pointer_bits) || !read_stream_u32(in, header.arch.flags) ||
      !read_stream_u64(in, header.trace_flags) || !read_stream_u32(in, header.register_count) ||
      !read_stream_u32(in, header.stride) || !read_stream_u32(in, thread_count) || !read_stream_u32(in, entry_count)) {
    return false;
  }

  header.arch.arch_family = static_cast<w1::arch::family>(arch_family);
  header.arch.arch_mode = static_cast<w1::arch::mode>(arch_mode);
  header.arch.arch_byte_order = static_cast<w1::arch::byte_order>(arch_order);
  return true;
}

} // namespace

const replay_checkpoint_entry* replay_checkpoint_index::find_checkpoint(uint64_t thread_id, uint64_t sequence) const {
  auto thread_it = std::lower_bound(
      threads.begin(), threads.end(), thread_id,
      [](const replay_checkpoint_thread_index& entry, uint64_t value) { return entry.thread_id < value; }
  );
  if (thread_it == threads.end() || thread_it->thread_id != thread_id) {
    return nullptr;
  }
  if (thread_it->entry_count == 0) {
    return nullptr;
  }

  auto begin =
      entries.begin() + static_cast<std::vector<replay_checkpoint_entry>::difference_type>(thread_it->entry_start);
  auto end = begin + static_cast<std::vector<replay_checkpoint_entry>::difference_type>(thread_it->entry_count);
  auto it = std::lower_bound(begin, end, sequence, [](const replay_checkpoint_entry& entry, uint64_t value) {
    return entry.sequence < value;
  });
  if (it == begin) {
    if (it->sequence > sequence) {
      return nullptr;
    }
    return &(*it);
  }
  if (it == end) {
    return &(*(end - 1));
  }
  if (it->sequence == sequence) {
    return &(*it);
  }
  return &(*(it - 1));
}

std::string default_replay_checkpoint_path(const std::string& trace_path) { return trace_path + ".w1rchk"; }

bool build_replay_checkpoint(const replay_checkpoint_config& config, replay_checkpoint_index* out, std::string& error) {
  error.clear();
  if (!out) {
    error = "checkpoint output required";
    return false;
  }
  if (config.trace_path.empty()) {
    error = "trace path required";
    return false;
  }
  if (config.stride == 0) {
    error = "checkpoint stride must be non-zero";
    return false;
  }

  std::string output_path =
      config.output_path.empty() ? default_replay_checkpoint_path(config.trace_path) : config.output_path;

  trace_reader reader(config.trace_path);
  if (!reader.open()) {
    error = reader.error().empty() ? "failed to open trace" : reader.error();
    return false;
  }

  replay_context context;
  if (!load_replay_context(config.trace_path, context, error)) {
    return false;
  }

  bool use_blocks = (reader.header().flags & trace_flag_blocks) != 0;
  bool use_instructions = (reader.header().flags & trace_flag_instructions) != 0;
  if (use_blocks == use_instructions) {
    error = "trace has unsupported flow flags";
    return false;
  }

  uint32_t max_register_id = 0;
  bool have_register_specs = !context.register_specs.empty();
  bool have_registers = false;

  std::map<uint64_t, thread_build_state> threads;
  replay_state_applier applier(context);

  trace_record record;
  trace_record_location location{};
  while (reader.read_next(record, &location)) {
    if (std::holds_alternative<register_delta_record>(record)) {
      const auto& deltas = std::get<register_delta_record>(record);
      if (config.thread_id != 0 && deltas.thread_id != config.thread_id) {
        continue;
      }
      auto& state = threads[deltas.thread_id];
      if (state.state.registers().empty() && !context.register_specs.empty()) {
        state.state.set_register_specs(context.register_specs);
      }
      applier.apply_register_deltas(deltas, deltas.thread_id, true, state.state);
      for (const auto& delta : deltas.deltas) {
        max_register_id = std::max(max_register_id, static_cast<uint32_t>(delta.reg_id));
        have_registers = true;
      }
      continue;
    }

    if (std::holds_alternative<register_bytes_record>(record)) {
      const auto& bytes = std::get<register_bytes_record>(record);
      if (config.thread_id != 0 && bytes.thread_id != config.thread_id) {
        continue;
      }
      auto& state = threads[bytes.thread_id];
      if (state.state.registers().empty() && !context.register_specs.empty()) {
        state.state.set_register_specs(context.register_specs);
      }
      applier.apply_register_bytes(bytes, bytes.thread_id, true, state.state);
      have_registers = true;
      for (const auto& entry : bytes.entries) {
        max_register_id = std::max(max_register_id, static_cast<uint32_t>(entry.reg_id));
      }
      continue;
    }

    if (std::holds_alternative<memory_access_record>(record)) {
      if (!config.include_memory) {
        continue;
      }
      const auto& access = std::get<memory_access_record>(record);
      if (config.thread_id != 0 && access.thread_id != config.thread_id) {
        continue;
      }
      auto& state = threads[access.thread_id];
      if (state.state.registers().empty() && !context.register_specs.empty()) {
        state.state.set_register_specs(context.register_specs);
      }
      applier.apply_memory_access(access, access.thread_id, config.include_memory, state.state);
      continue;
    }

    if (std::holds_alternative<snapshot_record>(record)) {
      const auto& snapshot = std::get<snapshot_record>(record);
      if (config.thread_id != 0 && snapshot.thread_id != config.thread_id) {
        continue;
      }
      auto& state = threads[snapshot.thread_id];
      if (state.state.registers().empty() && !context.register_specs.empty()) {
        state.state.set_register_specs(context.register_specs);
      }
      applier.apply_snapshot(snapshot, snapshot.thread_id, true, config.include_memory, state.state);
      for (const auto& delta : snapshot.registers) {
        max_register_id = std::max(max_register_id, static_cast<uint32_t>(delta.reg_id));
        have_registers = true;
      }
      continue;
    }

    auto flow = classify_flow_record(record, use_blocks);
    if (!flow) {
      continue;
    }

    if (config.thread_id != 0 && flow->thread_id != config.thread_id) {
      continue;
    }

    auto& state = threads[flow->thread_id];
    if (state.flow_count % config.stride == 0) {
      state.entries.push_back(
          snapshot_entry(flow->thread_id, flow->sequence, location, state.state, config.include_memory)
      );
    }
    state.flow_count += 1;
  }

  if (!reader.error().empty()) {
    error = reader.error();
    return false;
  }

  replay_checkpoint_index index;
  index.header.trace_version = context.header.version;
  index.header.arch = context.header.arch;
  index.header.trace_flags = context.header.flags;
  index.header.stride = config.stride;

  if (have_register_specs) {
    index.header.register_count = static_cast<uint32_t>(context.register_specs.size());
  } else if (have_registers) {
    index.header.register_count = max_register_id + 1;
  }

  for (const auto& [thread_id, state] : threads) {
    replay_checkpoint_thread_index entry{};
    entry.thread_id = thread_id;
    entry.entry_start = static_cast<uint32_t>(index.entries.size());
    entry.entry_count = static_cast<uint32_t>(state.entries.size());
    index.entries.insert(index.entries.end(), state.entries.begin(), state.entries.end());
    index.threads.push_back(entry);
  }

  std::ofstream out_stream(output_path, std::ios::binary | std::ios::out | std::ios::trunc);
  if (!out_stream.is_open()) {
    error = "failed to open checkpoint output";
    return false;
  }

  if (!write_checkpoint_header(
          out_stream, index.header, static_cast<uint32_t>(index.threads.size()),
          static_cast<uint32_t>(index.entries.size())
      )) {
    error = "failed to write checkpoint header";
    return false;
  }

  for (const auto& thread : index.threads) {
    if (!write_stream_u64(out_stream, thread.thread_id) || !write_stream_u32(out_stream, thread.entry_start) ||
        !write_stream_u32(out_stream, thread.entry_count)) {
      error = "failed to write checkpoint thread index";
      return false;
    }
  }

  for (const auto& entry : index.entries) {
    if (!write_stream_u64(out_stream, entry.thread_id) || !write_stream_u64(out_stream, entry.sequence) ||
        !write_stream_u32(out_stream, entry.location.chunk_index) ||
        !write_stream_u32(out_stream, entry.location.record_offset)) {
      error = "failed to write checkpoint entry header";
      return false;
    }

    uint32_t reg_count = static_cast<uint32_t>(entry.registers.size());
    uint32_t reg_bytes_count = static_cast<uint32_t>(entry.register_bytes_entries.size());
    uint32_t reg_bytes_size = static_cast<uint32_t>(entry.register_bytes.size());
    uint32_t mem_span_count = static_cast<uint32_t>(entry.memory.size());
    if (!write_stream_u32(out_stream, reg_count) || !write_stream_u32(out_stream, reg_bytes_count) ||
        !write_stream_u32(out_stream, reg_bytes_size) || !write_stream_u32(out_stream, mem_span_count)) {
      error = "failed to write checkpoint entry counts";
      return false;
    }

    for (const auto& reg : entry.registers) {
      if (!write_stream_u16(out_stream, reg.reg_id) || !write_stream_u64(out_stream, reg.value)) {
        error = "failed to write checkpoint register entry";
        return false;
      }
    }

    for (const auto& reg : entry.register_bytes_entries) {
      if (!write_stream_u16(out_stream, reg.reg_id) || !write_stream_u32(out_stream, reg.offset) ||
          !write_stream_u16(out_stream, reg.size)) {
        error = "failed to write checkpoint register bytes entry";
        return false;
      }
    }

    if (!entry.register_bytes.empty()) {
      if (!write_stream_bytes(out_stream, entry.register_bytes.data(), entry.register_bytes.size())) {
        error = "failed to write checkpoint register bytes data";
        return false;
      }
    }

    for (const auto& mem : entry.memory) {
      uint64_t span_size = static_cast<uint64_t>(mem.bytes.size());
      if (!write_stream_u64(out_stream, mem.base) || !write_stream_u64(out_stream, span_size)) {
        error = "failed to write checkpoint memory entry";
        return false;
      }
      if (span_size > 0) {
        if (!write_stream_bytes(out_stream, mem.bytes.data(), mem.bytes.size())) {
          error = "failed to write checkpoint memory bytes";
          return false;
        }
      }
    }
  }

  if (!out_stream.good()) {
    error = "failed to write checkpoint";
    return false;
  }

  *out = std::move(index);
  return true;
}

bool load_replay_checkpoint(const std::string& path, replay_checkpoint_index& out, std::string& error) {
  error.clear();
  std::ifstream in(path, std::ios::binary | std::ios::in);
  if (!in.is_open()) {
    error = "failed to open checkpoint file";
    return false;
  }

  replay_checkpoint_index index;
  uint32_t thread_count = 0;
  uint32_t entry_count = 0;
  if (!read_checkpoint_header(in, index.header, thread_count, entry_count)) {
    error = "invalid checkpoint header";
    return false;
  }
  if (index.header.version != k_replay_checkpoint_version) {
    error = "checkpoint version mismatch";
    return false;
  }

  index.threads.resize(thread_count);
  for (uint32_t i = 0; i < thread_count; ++i) {
    auto& thread = index.threads[i];
    if (!read_stream_u64(in, thread.thread_id) || !read_stream_u32(in, thread.entry_start) ||
        !read_stream_u32(in, thread.entry_count)) {
      error = "failed to read checkpoint thread index";
      return false;
    }
  }

  index.entries.resize(entry_count);
  for (uint32_t i = 0; i < entry_count; ++i) {
    auto& entry = index.entries[i];
    uint32_t reg_count = 0;
    uint32_t reg_bytes_count = 0;
    uint32_t reg_bytes_size = 0;
    uint32_t mem_span_count = 0;

    if (!read_stream_u64(in, entry.thread_id) || !read_stream_u64(in, entry.sequence) ||
        !read_stream_u32(in, entry.location.chunk_index) || !read_stream_u32(in, entry.location.record_offset) ||
        !read_stream_u32(in, reg_count) || !read_stream_u32(in, reg_bytes_count) ||
        !read_stream_u32(in, reg_bytes_size) || !read_stream_u32(in, mem_span_count)) {
      error = "failed to read checkpoint entry header";
      return false;
    }

    entry.registers.resize(reg_count);
    for (uint32_t j = 0; j < reg_count; ++j) {
      uint16_t reg_id = 0;
      uint64_t value = 0;
      if (!read_stream_u16(in, reg_id) || !read_stream_u64(in, value)) {
        error = "failed to read checkpoint register entry";
        return false;
      }
      entry.registers[j] = register_delta{reg_id, value};
    }

    entry.register_bytes_entries.resize(reg_bytes_count);
    for (uint32_t j = 0; j < reg_bytes_count; ++j) {
      register_bytes_entry reg{};
      if (!read_stream_u16(in, reg.reg_id) || !read_stream_u32(in, reg.offset) || !read_stream_u16(in, reg.size)) {
        error = "failed to read checkpoint register bytes entry";
        return false;
      }
      entry.register_bytes_entries[j] = reg;
    }

    entry.register_bytes.resize(reg_bytes_size);
    if (reg_bytes_size > 0) {
      if (!read_stream_bytes(in, entry.register_bytes.data(), entry.register_bytes.size())) {
        error = "failed to read checkpoint register bytes data";
        return false;
      }
    }

    entry.memory.resize(mem_span_count);
    for (uint32_t j = 0; j < mem_span_count; ++j) {
      uint64_t base = 0;
      uint64_t span_size = 0;
      if (!read_stream_u64(in, base) || !read_stream_u64(in, span_size)) {
        error = "failed to read checkpoint memory entry";
        return false;
      }
      if (span_size > static_cast<uint64_t>(std::numeric_limits<size_t>::max())) {
        error = "checkpoint memory span too large";
        return false;
      }
      entry.memory[j].base = base;
      entry.memory[j].bytes.resize(static_cast<size_t>(span_size));
      if (span_size > 0) {
        if (!read_stream_bytes(in, entry.memory[j].bytes.data(), entry.memory[j].bytes.size())) {
          error = "failed to read checkpoint memory bytes";
          return false;
        }
      }
    }

    for (const auto& reg : entry.register_bytes_entries) {
      uint64_t end = static_cast<uint64_t>(reg.offset) + static_cast<uint64_t>(reg.size);
      if (end > entry.register_bytes.size()) {
        error = "checkpoint register bytes entry out of range";
        return false;
      }
    }
  }

  for (const auto& thread : index.threads) {
    if (thread.entry_start + thread.entry_count > index.entries.size()) {
      error = "checkpoint thread index out of range";
      return false;
    }
  }

  out = std::move(index);
  return true;
}

} // namespace w1::rewind

```

`src/w1rewind/trace/replay_checkpoint.hpp`:

```hpp
#pragma once

#include <array>
#include <cstdint>
#include <string>
#include <vector>

#include "trace_reader.hpp"
#include "w1rewind/replay/memory_store.hpp"

namespace w1::rewind {

constexpr uint16_t k_replay_checkpoint_version = 4;
constexpr std::array<uint8_t, 8> k_replay_checkpoint_magic = {'W', '1', 'R', 'C', 'H', 'K', '4', '\0'};

struct replay_checkpoint_header {
  uint16_t version = k_replay_checkpoint_version;
  uint16_t trace_version = 0;
  w1::arch::arch_spec arch{};
  uint64_t trace_flags = 0;
  uint32_t register_count = 0;
  uint32_t stride = 0;
};

struct replay_checkpoint_entry {
  uint64_t thread_id = 0;
  uint64_t sequence = 0;
  trace_record_location location{};
  std::vector<register_delta> registers;
  std::vector<register_bytes_entry> register_bytes_entries;
  std::vector<uint8_t> register_bytes;
  std::vector<memory_span> memory;
};

struct replay_checkpoint_thread_index {
  uint64_t thread_id = 0;
  uint32_t entry_start = 0;
  uint32_t entry_count = 0;
};

struct replay_checkpoint_index {
  replay_checkpoint_header header{};
  std::vector<replay_checkpoint_thread_index> threads;
  std::vector<replay_checkpoint_entry> entries;

  const replay_checkpoint_entry* find_checkpoint(uint64_t thread_id, uint64_t sequence) const;
};

struct replay_checkpoint_config {
  std::string trace_path;
  std::string output_path;
  uint32_t stride = 50000;
  bool include_memory = false;
  uint64_t thread_id = 0;
};

std::string default_replay_checkpoint_path(const std::string& trace_path);

bool build_replay_checkpoint(const replay_checkpoint_config& config, replay_checkpoint_index* out, std::string& error);

bool load_replay_checkpoint(const std::string& path, replay_checkpoint_index& out, std::string& error);

} // namespace w1::rewind

```

`src/w1rewind/trace/trace_file_writer.cpp`:

```cpp
#include "trace_file_writer.hpp"

#include <filesystem>
#include <limits>
#include <sstream>
#include <system_error>

#include "w1rewind/format/trace_codec.hpp"
#include "w1rewind/format/trace_io.hpp"

#if defined(W1_REWIND_HAVE_ZSTD)
#include <zstd.h>
#endif

#if defined(_WIN32)
#include <process.h>
#else
#include <unistd.h>
#endif

namespace w1::rewind {

namespace {

constexpr int k_zstd_level = 3;

} // namespace

trace_file_writer::trace_file_writer(trace_file_writer_config config) : config_(std::move(config)) {}

trace_file_writer::~trace_file_writer() { close(); }

std::shared_ptr<trace_file_writer> make_trace_file_writer(trace_file_writer_config config) {
  return std::make_shared<trace_file_writer>(std::move(config));
}

bool trace_file_writer::open() {
  std::lock_guard<std::mutex> guard(mutex_);
#if !defined(W1_REWIND_HAVE_ZSTD)
  if (config_.compression == trace_compression::zstd) {
    config_.log.err("zstd compression requested but zstd is not available");
    good_ = false;
    return false;
  }
#endif

  if (config_.chunk_size == 0) {
    config_.chunk_size = k_trace_chunk_bytes;
  }
  if (stream_.is_open()) {
    stream_.close();
  }

  path_ = config_.path;
  if (path_.empty()) {
    path_ = make_default_path();
  }

  std::error_code ec;
  std::filesystem::path fs_path(path_);
  if (fs_path.has_parent_path()) {
    std::filesystem::create_directories(fs_path.parent_path(), ec);
    if (ec) {
      config_.log.err(
          "failed to create trace directory", redlog::field("path", fs_path.parent_path().string()),
          redlog::field("error", ec.message())
      );
      good_ = false;
      return false;
    }
  }

  stream_.open(fs_path, std::ios::binary | std::ios::out | std::ios::trunc);
  good_ = stream_.good();
  header_written_ = false;
  chunk_buffer_.clear();
  chunk_encoded_.clear();

  if (!good_) {
    config_.log.err("failed to open trace", redlog::field("path", path_));
    return false;
  }

  config_.log.inf("trace writer ready", redlog::field("path", path_));
  return true;
}

void trace_file_writer::close() {
  std::lock_guard<std::mutex> guard(mutex_);
  if (stream_.is_open()) {
    if (good_ && header_written_) {
      flush_chunk_locked();
      stream_.flush();
    }
    stream_.close();
  }
  good_ = false;
  header_written_ = false;
  chunk_buffer_.clear();
  chunk_encoded_.clear();
}

bool trace_file_writer::write_header(const trace_header& header) {
  std::lock_guard<std::mutex> guard(mutex_);
  if (!stream_.is_open()) {
    config_.log.err("trace writer not open");
    return false;
  }
  if (header_written_) {
    return true;
  }

  trace_header updated = header;
  updated.compression = config_.compression;
  updated.chunk_size = config_.chunk_size;

  write_bytes(k_trace_magic.data(), k_trace_magic.size());
  write_u16(updated.version);
  write_u16(static_cast<uint16_t>(updated.arch.arch_family));
  write_u16(static_cast<uint16_t>(updated.arch.arch_mode));
  uint8_t byte_order = static_cast<uint8_t>(updated.arch.arch_byte_order);
  write_bytes(&byte_order, sizeof(byte_order));
  uint8_t reserved = 0;
  write_bytes(&reserved, sizeof(reserved));
  write_u32(updated.arch.pointer_bits);
  write_u32(updated.arch.flags);
  write_u64(updated.flags);
  write_u32(static_cast<uint32_t>(updated.compression));
  write_u32(updated.chunk_size);

  if (good_) {
    header_written_ = true;
  } else {
    config_.log.err("failed to write trace header", redlog::field("path", path_));
  }

  return good_;
}

bool trace_file_writer::write_target_info(const target_info_record& record) {
  std::vector<uint8_t> payload;
  trace_buffer_writer writer(payload);
  if (!encode_target_info(record, writer, config_.log)) {
    return false;
  }
  return write_record(record_kind::target_info, 0, payload);
}

bool trace_file_writer::write_target_environment(const target_environment_record& record) {
  std::vector<uint8_t> payload;
  trace_buffer_writer writer(payload);
  if (!encode_target_environment(record, writer, config_.log)) {
    return false;
  }
  return write_record(record_kind::target_environment, 0, payload);
}

bool trace_file_writer::write_register_spec(const register_spec_record& record) {
  std::vector<uint8_t> payload;
  trace_buffer_writer writer(payload);
  if (!encode_register_spec(record, writer, config_.log)) {
    return false;
  }
  return write_record(record_kind::register_spec, 0, payload);
}

bool trace_file_writer::write_module_table(const module_table_record& record) {
  std::vector<uint8_t> payload;
  trace_buffer_writer writer(payload);
  if (!encode_module_table(record, writer, config_.log)) {
    return false;
  }
  return write_record(record_kind::module_table, 0, payload);
}

bool trace_file_writer::write_module_load(const module_load_record& record) {
  std::vector<uint8_t> payload;
  trace_buffer_writer writer(payload);
  if (!encode_module_load(record, writer, config_.log)) {
    return false;
  }
  return write_record(record_kind::module_load, 0, payload);
}

bool trace_file_writer::write_module_unload(const module_unload_record& record) {
  std::vector<uint8_t> payload;
  trace_buffer_writer writer(payload);
  if (!encode_module_unload(record, writer, config_.log)) {
    return false;
  }
  return write_record(record_kind::module_unload, 0, payload);
}

bool trace_file_writer::write_memory_map(const memory_map_record& record) {
  std::vector<uint8_t> payload;
  trace_buffer_writer writer(payload);
  if (!encode_memory_map(record, writer, config_.log)) {
    return false;
  }
  return write_record(record_kind::memory_map, 0, payload);
}

bool trace_file_writer::write_thread_start(const thread_start_record& record) {
  std::vector<uint8_t> payload;
  trace_buffer_writer writer(payload);
  if (!encode_thread_start(record, writer, config_.log)) {
    return false;
  }
  return write_record(record_kind::thread_start, 0, payload);
}

bool trace_file_writer::write_instruction(const instruction_record& record) {
  std::vector<uint8_t> payload;
  trace_buffer_writer writer(payload);
  encode_instruction(record, writer);
  return write_record(record_kind::instruction, 0, payload);
}

bool trace_file_writer::write_block_definition(const block_definition_record& record) {
  std::vector<uint8_t> payload;
  trace_buffer_writer writer(payload);
  encode_block_definition(record, writer);
  return write_record(record_kind::block_definition, 0, payload);
}

bool trace_file_writer::write_block_exec(const block_exec_record& record) {
  std::vector<uint8_t> payload;
  trace_buffer_writer writer(payload);
  encode_block_exec(record, writer);
  return write_record(record_kind::block_exec, 0, payload);
}

bool trace_file_writer::write_register_deltas(const register_delta_record& record) {
  std::vector<uint8_t> payload;
  trace_buffer_writer writer(payload);
  if (!encode_register_deltas(record, writer, config_.log)) {
    return false;
  }
  return write_record(record_kind::register_deltas, 0, payload);
}

bool trace_file_writer::write_register_bytes(const register_bytes_record& record) {
  std::vector<uint8_t> payload;
  trace_buffer_writer writer(payload);
  if (!encode_register_bytes(record, writer, config_.log)) {
    return false;
  }
  return write_record(record_kind::register_bytes, 0, payload);
}

bool trace_file_writer::write_memory_access(const memory_access_record& record) {
  std::vector<uint8_t> payload;
  trace_buffer_writer writer(payload);
  if (!encode_memory_access(record, writer, config_.log)) {
    return false;
  }
  return write_record(record_kind::memory_access, 0, payload);
}

bool trace_file_writer::write_snapshot(const snapshot_record& record) {
  std::vector<uint8_t> payload;
  trace_buffer_writer writer(payload);
  if (!encode_snapshot(record, writer, config_.log)) {
    return false;
  }
  return write_record(record_kind::snapshot, 0, payload);
}

bool trace_file_writer::write_thread_end(const thread_end_record& record) {
  std::vector<uint8_t> payload;
  trace_buffer_writer writer(payload);
  encode_thread_end(record, writer);
  return write_record(record_kind::thread_end, 0, payload);
}

void trace_file_writer::flush() {
  std::lock_guard<std::mutex> guard(mutex_);
  if (!good_) {
    return;
  }
  flush_chunk_locked();
  stream_.flush();
  if (!stream_.good()) {
    mark_failure();
  }
}

bool trace_file_writer::write_record(record_kind kind, uint16_t flags, const std::vector<uint8_t>& payload) {
  std::lock_guard<std::mutex> guard(mutex_);
  if (!good_) {
    return false;
  }
  if (!header_written_) {
    config_.log.err("trace header not written", redlog::field("path", path_));
    mark_failure();
    return false;
  }

  trace_buffer_writer writer(chunk_buffer_);
  writer.write_u16(static_cast<uint16_t>(kind));
  writer.write_u16(flags);
  writer.write_u32(static_cast<uint32_t>(payload.size()));
  if (!payload.empty()) {
    writer.write_bytes(payload.data(), payload.size());
  }

  if (chunk_buffer_.size() >= config_.chunk_size) {
    return flush_chunk_locked();
  }

  return good_;
}

bool trace_file_writer::flush_chunk_locked() {
  if (!good_) {
    return false;
  }
  if (chunk_buffer_.empty()) {
    return true;
  }
  if (chunk_buffer_.size() > std::numeric_limits<uint32_t>::max()) {
    config_.log.err("trace chunk too large", redlog::field("size", chunk_buffer_.size()));
    mark_failure();
    return false;
  }

  uint32_t uncompressed_size = static_cast<uint32_t>(chunk_buffer_.size());
  if (config_.compression == trace_compression::none) {
    write_u32(uncompressed_size);
    write_u32(uncompressed_size);
    write_bytes(chunk_buffer_.data(), chunk_buffer_.size());
    chunk_buffer_.clear();
    return good_;
  }

  if (config_.compression != trace_compression::zstd) {
    config_.log.err("unsupported trace compression mode");
    mark_failure();
    return false;
  }

#if defined(W1_REWIND_HAVE_ZSTD)
  size_t bound = ZSTD_compressBound(chunk_buffer_.size());
  if (bound > std::numeric_limits<uint32_t>::max()) {
    config_.log.err("compressed chunk bound too large", redlog::field("size", bound));
    mark_failure();
    return false;
  }
  chunk_encoded_.resize(bound);
  size_t compressed_size =
      ZSTD_compress(chunk_encoded_.data(), bound, chunk_buffer_.data(), chunk_buffer_.size(), k_zstd_level);
  if (ZSTD_isError(compressed_size)) {
    config_.log.err("zstd compression failed", redlog::field("error", ZSTD_getErrorName(compressed_size)));
    mark_failure();
    return false;
  }
  if (compressed_size > std::numeric_limits<uint32_t>::max()) {
    config_.log.err("compressed chunk too large", redlog::field("size", compressed_size));
    mark_failure();
    return false;
  }
  write_u32(static_cast<uint32_t>(compressed_size));
  write_u32(uncompressed_size);
  write_bytes(chunk_encoded_.data(), compressed_size);
  chunk_buffer_.clear();
  return good_;
#else
  config_.log.err("zstd compression requested but zstd is not available");
  mark_failure();
  return false;
#endif
}

void trace_file_writer::write_u16(uint16_t value) {
  if (!good_) {
    return;
  }
  if (!write_stream_u16(stream_, value)) {
    mark_failure();
  }
}

void trace_file_writer::write_u32(uint32_t value) {
  if (!good_) {
    return;
  }
  if (!write_stream_u32(stream_, value)) {
    mark_failure();
  }
}

void trace_file_writer::write_u64(uint64_t value) {
  if (!good_) {
    return;
  }
  if (!write_stream_u64(stream_, value)) {
    mark_failure();
  }
}

void trace_file_writer::write_bytes(const void* data, size_t size) {
  if (!good_ || size == 0) {
    return;
  }
  if (!write_stream_bytes(stream_, data, size)) {
    mark_failure();
  }
}

void trace_file_writer::mark_failure() { good_ = false; }

std::string trace_file_writer::make_default_path() const {
#if defined(_WIN32)
  std::filesystem::path base = std::filesystem::temp_directory_path();
#else
  std::filesystem::path base = std::filesystem::path("/tmp");
#endif
#if defined(_WIN32)
  int pid = static_cast<int>(_getpid());
#else
  int pid = static_cast<int>(getpid());
#endif

  std::ostringstream name;
  name << "w1rewind_" << pid << ".w1r";
  base /= name.str();
  return base.string();
}

} // namespace w1::rewind

```

`src/w1rewind/trace/trace_file_writer.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <fstream>
#include <memory>
#include <mutex>
#include <string>
#include <vector>

#include <redlog.hpp>

#include "w1rewind/format/trace_format.hpp"
#include "w1rewind/trace/record_sink.hpp"

namespace w1::rewind {

struct trace_file_writer_config {
  std::string path;
  redlog::logger log;
  trace_compression compression = trace_compression::none;
  uint32_t chunk_size = k_trace_chunk_bytes;
};

class trace_file_writer : public trace_record_sink {
public:
  explicit trace_file_writer(trace_file_writer_config config);
  ~trace_file_writer() override;

  bool open();
  void close();
  bool good() const override { return good_; }

  const std::string& path() const { return path_; }

  bool write_header(const trace_header& header) override;
  bool write_target_info(const target_info_record& record) override;
  bool write_target_environment(const target_environment_record& record) override;
  bool write_register_spec(const register_spec_record& record) override;
  bool write_module_table(const module_table_record& record) override;
  bool write_module_load(const module_load_record& record) override;
  bool write_module_unload(const module_unload_record& record) override;
  bool write_memory_map(const memory_map_record& record) override;
  bool write_thread_start(const thread_start_record& record) override;
  bool write_instruction(const instruction_record& record) override;
  bool write_block_definition(const block_definition_record& record) override;
  bool write_block_exec(const block_exec_record& record) override;
  bool write_register_deltas(const register_delta_record& record) override;
  bool write_register_bytes(const register_bytes_record& record) override;
  bool write_memory_access(const memory_access_record& record) override;
  bool write_snapshot(const snapshot_record& record) override;
  bool write_thread_end(const thread_end_record& record) override;
  void flush() override;

private:
  bool write_record(record_kind kind, uint16_t flags, const std::vector<uint8_t>& payload);
  bool flush_chunk_locked();
  void write_u16(uint16_t value);
  void write_u32(uint32_t value);
  void write_u64(uint64_t value);
  void write_bytes(const void* data, size_t size);
  void mark_failure();
  std::string make_default_path() const;

  trace_file_writer_config config_;
  std::ofstream stream_;
  std::string path_;
  bool good_ = false;
  bool header_written_ = false;
  std::vector<uint8_t> chunk_buffer_;
  std::vector<uint8_t> chunk_encoded_;
  std::mutex mutex_;
};

std::shared_ptr<trace_file_writer> make_trace_file_writer(trace_file_writer_config config);

} // namespace w1::rewind

```

`src/w1rewind/trace/trace_index.cpp`:

```cpp
#include "trace_index.hpp"

#include <algorithm>
#include <array>
#include <cstring>
#include <filesystem>
#include <fstream>
#include <limits>
#include <map>

#include "w1rewind/format/trace_io.hpp"
#include "w1rewind/trace/flow_classifier.hpp"
#include "w1rewind/trace/trace_reader.hpp"

namespace w1::rewind {

namespace {

struct thread_build_state {
  uint64_t flow_count = 0;
  std::vector<trace_anchor> anchors;
  std::vector<trace_anchor> snapshots;
};

bool write_index_header(
    std::ostream& out, const trace_index_header& header, uint32_t chunk_count, uint32_t thread_count,
    uint32_t anchor_count, uint32_t snapshot_count
) {
  if (!write_stream_bytes(out, k_trace_index_magic.data(), k_trace_index_magic.size())) {
    return false;
  }
  return write_stream_u16(out, header.version) && write_stream_u16(out, header.trace_version) &&
         write_stream_u32(out, header.chunk_size) && write_stream_u64(out, header.trace_flags) &&
         write_stream_u32(out, header.anchor_stride) && write_stream_u32(out, chunk_count) &&
         write_stream_u32(out, thread_count) && write_stream_u32(out, anchor_count) &&
         write_stream_u32(out, snapshot_count);
}

bool read_index_header(
    std::istream& in, trace_index_header& header, uint32_t& chunk_count, uint32_t& thread_count, uint32_t& anchor_count,
    uint32_t& snapshot_count
) {
  std::array<uint8_t, 8> magic{};
  if (!read_stream_bytes(in, magic.data(), magic.size())) {
    return false;
  }
  if (std::memcmp(magic.data(), k_trace_index_magic.data(), k_trace_index_magic.size()) != 0) {
    return false;
  }
  return read_stream_u16(in, header.version) && read_stream_u16(in, header.trace_version) &&
         read_stream_u32(in, header.chunk_size) && read_stream_u64(in, header.trace_flags) &&
         read_stream_u32(in, header.anchor_stride) && read_stream_u32(in, chunk_count) &&
         read_stream_u32(in, thread_count) && read_stream_u32(in, anchor_count) && read_stream_u32(in, snapshot_count);
}

std::optional<trace_anchor> find_anchor_in_span(
    const std::vector<trace_anchor>& anchors, uint32_t start, uint32_t count, uint64_t sequence
) {
  if (count == 0) {
    return std::nullopt;
  }
  auto begin = anchors.begin() + static_cast<std::vector<trace_anchor>::difference_type>(start);
  auto end = begin + static_cast<std::vector<trace_anchor>::difference_type>(count);
  auto it = std::lower_bound(begin, end, sequence, [](const trace_anchor& anchor, uint64_t value) {
    return anchor.sequence < value;
  });
  if (it == begin) {
    if (it->sequence > sequence) {
      return std::nullopt;
    }
    return *it;
  }
  if (it == end) {
    return *(end - 1);
  }
  if (it->sequence == sequence) {
    return *it;
  }
  return *(it - 1);
}

} // namespace

const trace_thread_index* trace_index::find_thread(uint64_t thread_id) const {
  auto it =
      std::lower_bound(threads.begin(), threads.end(), thread_id, [](const trace_thread_index& entry, uint64_t value) {
        return entry.thread_id < value;
      });
  if (it == threads.end() || it->thread_id != thread_id) {
    return nullptr;
  }
  return &(*it);
}

std::optional<trace_anchor> trace_index::find_anchor(uint64_t thread_id, uint64_t sequence) const {
  const trace_thread_index* entry = find_thread(thread_id);
  if (!entry) {
    return std::nullopt;
  }
  return find_anchor_in_span(anchors, entry->anchor_start, entry->anchor_count, sequence);
}

std::optional<trace_anchor> trace_index::find_snapshot(uint64_t thread_id, uint64_t sequence) const {
  const trace_thread_index* entry = find_thread(thread_id);
  if (!entry) {
    return std::nullopt;
  }
  return find_anchor_in_span(snapshots, entry->snapshot_start, entry->snapshot_count, sequence);
}

std::string default_trace_index_path(const std::string& trace_path) { return trace_path + ".idx"; }

bool build_trace_index(
    const std::string& trace_path, const std::string& index_path, const trace_index_options& options, trace_index* out,
    redlog::logger log
) {
  if (options.anchor_stride == 0) {
    log.err("trace index anchor stride must be non-zero");
    return false;
  }

  trace_reader reader(trace_path);
  if (!reader.open()) {
    log.err(
        "failed to open trace for indexing", redlog::field("path", trace_path), redlog::field("error", reader.error())
    );
    return false;
  }

  trace_index index;
  index.header.trace_version = reader.header().version;
  index.header.trace_flags = reader.header().flags;
  index.header.chunk_size = reader.header().chunk_size;
  index.header.anchor_stride = options.anchor_stride;

  bool use_blocks = (reader.header().flags & trace_flag_blocks) != 0;
  bool use_instructions = (reader.header().flags & trace_flag_instructions) != 0;
  enum class flow_kind { blocks, instructions } flow = flow_kind::blocks;
  if (use_blocks) {
    flow = flow_kind::blocks;
  } else if (use_instructions) {
    flow = flow_kind::instructions;
  } else {
    log.err("trace has no flow records to index", redlog::field("path", trace_path));
    return false;
  }

  std::map<uint64_t, thread_build_state> threads;
  uint32_t last_chunk_index = std::numeric_limits<uint32_t>::max();

  trace_record record;
  trace_record_location location{};
  while (reader.read_next(record, &location)) {
    if (location.chunk_index != last_chunk_index) {
      const auto& chunk_info = reader.last_chunk_info();
      if (!chunk_info) {
        log.err("trace reader missing chunk info", redlog::field("chunk", location.chunk_index));
        return false;
      }
      if (location.chunk_index != index.chunks.size()) {
        log.err("trace chunk index out of order", redlog::field("chunk", location.chunk_index));
        return false;
      }
      index.chunks.push_back(*chunk_info);
      last_chunk_index = location.chunk_index;
    }

    auto flow_record = classify_flow_record(record, flow == flow_kind::blocks);
    if (flow_record) {
      auto& state = threads[flow_record->thread_id];
      if (state.flow_count % options.anchor_stride == 0) {
        state.anchors.push_back(trace_anchor{flow_record->sequence, location.chunk_index, location.record_offset});
      }
      state.flow_count += 1;
    } else if (options.include_snapshots && std::holds_alternative<snapshot_record>(record)) {
      const auto& snapshot = std::get<snapshot_record>(record);
      auto& state = threads[snapshot.thread_id];
      state.snapshots.push_back(trace_anchor{snapshot.sequence, location.chunk_index, location.record_offset});
    }
  }

  if (!reader.error().empty()) {
    log.err("trace reader error", redlog::field("error", reader.error()));
    return false;
  }

  for (const auto& [thread_id, state] : threads) {
    trace_thread_index entry{};
    entry.thread_id = thread_id;
    entry.anchor_start = static_cast<uint32_t>(index.anchors.size());
    entry.anchor_count = static_cast<uint32_t>(state.anchors.size());
    index.anchors.insert(index.anchors.end(), state.anchors.begin(), state.anchors.end());
    entry.snapshot_start = static_cast<uint32_t>(index.snapshots.size());
    entry.snapshot_count = static_cast<uint32_t>(state.snapshots.size());
    index.snapshots.insert(index.snapshots.end(), state.snapshots.begin(), state.snapshots.end());
    index.threads.push_back(entry);
  }

  std::ofstream out_stream(index_path, std::ios::binary | std::ios::out | std::ios::trunc);
  if (!out_stream.is_open()) {
    log.err("failed to open trace index output", redlog::field("path", index_path));
    return false;
  }

  if (!write_index_header(
          out_stream, index.header, static_cast<uint32_t>(index.chunks.size()),
          static_cast<uint32_t>(index.threads.size()), static_cast<uint32_t>(index.anchors.size()),
          static_cast<uint32_t>(index.snapshots.size())
      )) {
    log.err("failed to write trace index header", redlog::field("path", index_path));
    return false;
  }

  for (const auto& chunk : index.chunks) {
    if (!write_stream_u64(out_stream, chunk.file_offset) || !write_stream_u32(out_stream, chunk.compressed_size) ||
        !write_stream_u32(out_stream, chunk.uncompressed_size)) {
      log.err("failed to write trace chunk index", redlog::field("path", index_path));
      return false;
    }
  }

  for (const auto& thread : index.threads) {
    if (!write_stream_u64(out_stream, thread.thread_id) || !write_stream_u32(out_stream, thread.anchor_start) ||
        !write_stream_u32(out_stream, thread.anchor_count) || !write_stream_u32(out_stream, thread.snapshot_start) ||
        !write_stream_u32(out_stream, thread.snapshot_count)) {
      log.err("failed to write trace thread index", redlog::field("path", index_path));
      return false;
    }
  }

  for (const auto& anchor : index.anchors) {
    if (!write_stream_u64(out_stream, anchor.sequence) || !write_stream_u32(out_stream, anchor.chunk_index) ||
        !write_stream_u32(out_stream, anchor.record_offset)) {
      log.err("failed to write trace anchor index", redlog::field("path", index_path));
      return false;
    }
  }

  for (const auto& anchor : index.snapshots) {
    if (!write_stream_u64(out_stream, anchor.sequence) || !write_stream_u32(out_stream, anchor.chunk_index) ||
        !write_stream_u32(out_stream, anchor.record_offset)) {
      log.err("failed to write trace snapshot index", redlog::field("path", index_path));
      return false;
    }
  }

  if (!out_stream.good()) {
    log.err("failed to flush trace index", redlog::field("path", index_path));
    return false;
  }

  if (out) {
    *out = std::move(index);
  }
  return true;
}

bool load_trace_index(const std::string& index_path, trace_index& out, redlog::logger log) {
  std::ifstream in(index_path, std::ios::binary | std::ios::in);
  if (!in.is_open()) {
    log.err("failed to open trace index", redlog::field("path", index_path));
    return false;
  }

  trace_index index;
  uint32_t chunk_count = 0;
  uint32_t thread_count = 0;
  uint32_t anchor_count = 0;
  uint32_t snapshot_count = 0;

  if (!read_index_header(in, index.header, chunk_count, thread_count, anchor_count, snapshot_count)) {
    log.err("invalid trace index header", redlog::field("path", index_path));
    return false;
  }

  if (index.header.version != k_trace_index_version) {
    log.err("unsupported trace index version", redlog::field("version", index.header.version));
    return false;
  }

  index.chunks.resize(chunk_count);
  for (auto& chunk : index.chunks) {
    if (!read_stream_u64(in, chunk.file_offset) || !read_stream_u32(in, chunk.compressed_size) ||
        !read_stream_u32(in, chunk.uncompressed_size)) {
      log.err("failed to read trace chunk index", redlog::field("path", index_path));
      return false;
    }
  }

  index.threads.resize(thread_count);
  for (auto& thread : index.threads) {
    if (!read_stream_u64(in, thread.thread_id) || !read_stream_u32(in, thread.anchor_start) ||
        !read_stream_u32(in, thread.anchor_count) || !read_stream_u32(in, thread.snapshot_start) ||
        !read_stream_u32(in, thread.snapshot_count)) {
      log.err("failed to read trace thread index", redlog::field("path", index_path));
      return false;
    }
  }

  index.anchors.resize(anchor_count);
  for (auto& anchor : index.anchors) {
    if (!read_stream_u64(in, anchor.sequence) || !read_stream_u32(in, anchor.chunk_index) ||
        !read_stream_u32(in, anchor.record_offset)) {
      log.err("failed to read trace anchor index", redlog::field("path", index_path));
      return false;
    }
  }

  index.snapshots.resize(snapshot_count);
  for (auto& anchor : index.snapshots) {
    if (!read_stream_u64(in, anchor.sequence) || !read_stream_u32(in, anchor.chunk_index) ||
        !read_stream_u32(in, anchor.record_offset)) {
      log.err("failed to read trace snapshot index", redlog::field("path", index_path));
      return false;
    }
  }

  for (const auto& thread : index.threads) {
    if (thread.anchor_start + thread.anchor_count > index.anchors.size()) {
      log.err("trace index anchor range out of bounds", redlog::field("thread_id", thread.thread_id));
      return false;
    }
    if (thread.snapshot_start + thread.snapshot_count > index.snapshots.size()) {
      log.err("trace index snapshot range out of bounds", redlog::field("thread_id", thread.thread_id));
      return false;
    }
  }

  out = std::move(index);
  return true;
}

trace_index_status evaluate_trace_index(
    const std::filesystem::path& trace_path, const trace_index& index, std::string& error
) {
  error.clear();

  if (!std::filesystem::exists(trace_path)) {
    error = "trace file missing";
    return trace_index_status::missing;
  }

  trace_reader reader(trace_path.string());
  if (!reader.open()) {
    error = reader.error().empty() ? "failed to open trace" : std::string(reader.error());
    return trace_index_status::incompatible;
  }

  if (index.header.version != k_trace_index_version) {
    error = "trace index version mismatch";
    return trace_index_status::incompatible;
  }
  if (index.header.trace_version != reader.header().version) {
    error = "trace index trace version mismatch";
    return trace_index_status::incompatible;
  }
  if (index.header.trace_flags != reader.header().flags) {
    error = "trace index flags mismatch";
    return trace_index_status::incompatible;
  }
  if (index.header.chunk_size != reader.header().chunk_size) {
    error = "trace index chunk size mismatch";
    return trace_index_status::incompatible;
  }

  if (!index.chunks.empty()) {
    std::error_code ec;
    uint64_t file_size = static_cast<uint64_t>(std::filesystem::file_size(trace_path, ec));
    if (!ec) {
      const auto& last = index.chunks.back();
      uint64_t last_end = last.file_offset + 8u + last.compressed_size;
      if (file_size > last_end) {
        error = "trace index stale";
        return trace_index_status::stale;
      }
      if (file_size < last_end) {
        error = "trace index exceeds trace size";
        return trace_index_status::incompatible;
      }
    }
  }

  return trace_index_status::ok;
}

bool ensure_trace_index(
    const std::filesystem::path& trace_path, const std::filesystem::path& index_path,
    const trace_index_options& options, trace_index& out, std::string& error, bool allow_build
) {
  error.clear();

  if (trace_path.empty()) {
    error = "trace path required";
    return false;
  }
  if (!std::filesystem::exists(trace_path)) {
    error = "trace file missing";
    return false;
  }

  std::filesystem::path resolved_index = index_path;
  if (resolved_index.empty()) {
    resolved_index = default_trace_index_path(trace_path.string());
  }

  auto log = redlog::get_logger("w1rewind.trace_index");
  trace_index loaded;
  bool index_available = std::filesystem::exists(resolved_index);

  if (index_available) {
    if (!load_trace_index(resolved_index.string(), loaded, log)) {
      if (!allow_build) {
        error = "failed to load trace index";
        return false;
      }
      index_available = false;
    }
  }

  if (index_available) {
    std::string status_error;
    trace_index_status status = evaluate_trace_index(trace_path, loaded, status_error);

    if (status == trace_index_status::ok) {
      std::error_code trace_ec;
      std::error_code index_ec;
      auto trace_time = std::filesystem::last_write_time(trace_path, trace_ec);
      auto index_time = std::filesystem::last_write_time(resolved_index, index_ec);
      if (!trace_ec && !index_ec && trace_time > index_time) {
        status = trace_index_status::stale;
        status_error = "trace index stale";
      }
    }

    if (status == trace_index_status::ok) {
      out = std::move(loaded);
      return true;
    }
    if (!allow_build) {
      error = status_error.empty() ? "trace index invalid" : status_error;
      return false;
    }
  } else if (!allow_build) {
    error = "trace index missing";
    return false;
  }

  if (!build_trace_index(trace_path.string(), resolved_index.string(), options, &out, log)) {
    error = "failed to build trace index";
    return false;
  }

  return true;
}

} // namespace w1::rewind

```

`src/w1rewind/trace/trace_index.hpp`:

```hpp
#pragma once

#include <array>
#include <cstdint>
#include <filesystem>
#include <optional>
#include <string>
#include <vector>

#include <redlog.hpp>

#include "record_stream.hpp"

namespace w1::rewind {

constexpr uint16_t k_trace_index_version = 1;
constexpr std::array<uint8_t, 8> k_trace_index_magic = {'W', '1', 'R', 'N', 'D', 'X', '1', '\0'};

struct trace_index_header {
  uint16_t version = k_trace_index_version;
  uint16_t trace_version = 0;
  uint32_t chunk_size = 0;
  uint64_t trace_flags = 0;
  uint32_t anchor_stride = 0;
};

struct trace_anchor {
  uint64_t sequence = 0;
  uint32_t chunk_index = 0;
  uint32_t record_offset = 0;
};

struct trace_thread_index {
  uint64_t thread_id = 0;
  uint32_t anchor_start = 0;
  uint32_t anchor_count = 0;
  uint32_t snapshot_start = 0;
  uint32_t snapshot_count = 0;
};

struct trace_index_options {
  uint32_t anchor_stride = 50000;
  bool include_snapshots = true;
};

struct trace_index {
  trace_index_header header{};
  std::vector<trace_chunk_info> chunks{};
  std::vector<trace_thread_index> threads{};
  std::vector<trace_anchor> anchors{};
  std::vector<trace_anchor> snapshots{};

  const trace_thread_index* find_thread(uint64_t thread_id) const;
  std::optional<trace_anchor> find_anchor(uint64_t thread_id, uint64_t sequence) const;
  std::optional<trace_anchor> find_snapshot(uint64_t thread_id, uint64_t sequence) const;
};

std::string default_trace_index_path(const std::string& trace_path);

enum class trace_index_status {
  ok,
  missing,
  stale,
  incompatible,
};

bool build_trace_index(
    const std::string& trace_path, const std::string& index_path, const trace_index_options& options, trace_index* out,
    redlog::logger log
);

bool load_trace_index(const std::string& index_path, trace_index& out, redlog::logger log);

trace_index_status evaluate_trace_index(
    const std::filesystem::path& trace_path, const trace_index& index, std::string& error
);

bool ensure_trace_index(
    const std::filesystem::path& trace_path, const std::filesystem::path& index_path,
    const trace_index_options& options, trace_index& out, std::string& error, bool allow_build = true
);

} // namespace w1::rewind

```

`src/w1rewind/trace/trace_reader.cpp`:

```cpp
#include "trace_reader.hpp"

#include <algorithm>
#include <array>
#include <cstring>
#include <limits>

#if defined(W1_REWIND_HAVE_ZSTD)
#include <zstd.h>
#endif

#include "w1rewind/format/trace_codec.hpp"
#include "w1rewind/format/trace_io.hpp"

namespace w1::rewind {

trace_reader::trace_reader(std::string path) : path_(std::move(path)) {}

bool trace_reader::open() {
  close();
  stream_.open(path_, std::ios::binary | std::ios::in);
  if (!stream_.is_open()) {
    error_ = "failed to open trace file";
    return false;
  }

  return read_header();
}

void trace_reader::close() {
  if (stream_.is_open()) {
    stream_.close();
  }
  header_read_ = false;
  chunk_buffer_.clear();
  chunk_offset_ = 0;
  next_chunk_index_ = 0;
  current_chunk_index_ = 0;
  last_chunk_info_.reset();
  chunks_.clear();
  header_end_offset_ = 0;
  target_info_.reset();
  target_environment_.reset();
  register_specs_.clear();
  module_table_.clear();
  memory_map_.clear();
  error_.clear();
}

void trace_reader::reset() {
  if (!stream_.is_open()) {
    return;
  }
  stream_.clear();
  stream_.seekg(0, std::ios::beg);
  header_read_ = false;
  chunk_buffer_.clear();
  chunk_offset_ = 0;
  next_chunk_index_ = 0;
  current_chunk_index_ = 0;
  last_chunk_info_.reset();
  chunks_.clear();
  header_end_offset_ = 0;
  target_info_.reset();
  target_environment_.reset();
  register_specs_.clear();
  module_table_.clear();
  memory_map_.clear();
  error_.clear();
  read_header();
}

bool trace_reader::read_next(trace_record& record) { return read_next(record, nullptr); }

bool trace_reader::read_next(trace_record& record, trace_record_location* location) {
  if (!error_.empty()) {
    return false;
  }
  if (!header_read_) {
    if (!read_header()) {
      return false;
    }
  }

  if (chunk_offset_ >= chunk_buffer_.size()) {
    chunk_buffer_.clear();
    chunk_offset_ = 0;
    if (!read_chunk()) {
      return false;
    }
  }

  size_t record_offset = chunk_offset_;
  record_header header{};
  if (!read_record_header(header)) {
    return false;
  }

  std::vector<uint8_t> payload(header.size);
  if (header.size > 0) {
    if (!read_bytes(payload.data(), payload.size())) {
      error_ = "truncated record payload";
      return false;
    }
  }

  if (!parse_record(header, payload, record)) {
    if (error_.empty()) {
      error_ = "failed to parse record payload";
    }
    return false;
  }

  if (location) {
    if (record_offset > std::numeric_limits<uint32_t>::max()) {
      error_ = "record offset too large";
      return false;
    }
    location->chunk_index = current_chunk_index_;
    location->record_offset = static_cast<uint32_t>(record_offset);
  }

  return true;
}

bool trace_reader::seek_to_location(const trace_record_location& location) {
  if (!error_.empty()) {
    return false;
  }
  if (!stream_.is_open()) {
    error_ = "trace file not open";
    return false;
  }
  if (!header_read_) {
    stream_.clear();
    stream_.seekg(0, std::ios::beg);
    header_read_ = false;
    if (!read_header()) {
      return false;
    }
  }

  if (location.chunk_index == current_chunk_index_ && last_chunk_info_.has_value()) {
    return seek_to_chunk(*last_chunk_info_, location.chunk_index, location.record_offset);
  }
  if (!ensure_chunk_info(location.chunk_index)) {
    return false;
  }
  if (location.chunk_index >= chunks_.size()) {
    error_ = "trace chunk not cached";
    return false;
  }
  return seek_to_chunk(chunks_[location.chunk_index], location.chunk_index, location.record_offset);
}

bool trace_reader::seek_to_chunk(const trace_chunk_info& chunk, uint32_t chunk_index, uint32_t record_offset) {
  if (!error_.empty()) {
    return false;
  }
  if (!stream_.is_open()) {
    error_ = "trace file not open";
    return false;
  }
  if (!header_read_) {
    stream_.clear();
    stream_.seekg(0, std::ios::beg);
    header_read_ = false;
    if (!read_header()) {
      return false;
    }
  }
  if (!read_chunk_at(chunk.file_offset, chunk_index, &chunk)) {
    return false;
  }
  if (record_offset > chunk_buffer_.size()) {
    error_ = "record offset out of range";
    return false;
  }
  chunk_offset_ = record_offset;
  return true;
}

bool trace_reader::read_header() {
  if (!stream_.is_open()) {
    error_ = "trace file not open";
    return false;
  }

  std::array<uint8_t, 8> magic{};
  if (!read_stream_bytes(magic.data(), magic.size())) {
    if (error_.empty()) {
      error_ = "truncated trace header";
    }
    return false;
  }
  if (std::memcmp(magic.data(), k_trace_magic.data(), k_trace_magic.size()) != 0) {
    error_ = "unexpected trace magic";
    return false;
  }

  uint16_t version = 0;
  uint16_t arch_family = 0;
  uint16_t arch_mode = 0;
  uint8_t arch_order = 0;
  uint8_t reserved = 0;
  uint32_t arch_pointer_bits = 0;
  uint32_t arch_flags = 0;
  uint64_t flags = 0;
  uint32_t compression = 0;
  uint32_t chunk_size = 0;

  if (!read_stream_u16(stream_, version) || !read_stream_u16(stream_, arch_family) ||
      !read_stream_u16(stream_, arch_mode) || !read_stream_bytes(&arch_order, sizeof(arch_order)) ||
      !read_stream_bytes(&reserved, sizeof(reserved)) || !read_stream_u32(stream_, arch_pointer_bits) ||
      !read_stream_u32(stream_, arch_flags) || !read_stream_u64(stream_, flags) ||
      !read_stream_u32(stream_, compression) || !read_stream_u32(stream_, chunk_size)) {
    error_ = "truncated trace header fields";
    return false;
  }

  if (version != k_trace_version) {
    error_ = "unsupported trace version";
    return false;
  }

  header_.version = version;
  header_.arch.arch_family = static_cast<w1::arch::family>(arch_family);
  header_.arch.arch_mode = static_cast<w1::arch::mode>(arch_mode);
  header_.arch.arch_byte_order = static_cast<w1::arch::byte_order>(arch_order);
  header_.arch.pointer_bits = arch_pointer_bits;
  header_.arch.flags = arch_flags;
  header_.flags = flags;
  header_.compression = static_cast<trace_compression>(compression);
  header_.chunk_size = chunk_size;
  auto header_end = stream_.tellg();
  if (header_end >= 0) {
    header_end_offset_ = static_cast<uint64_t>(header_end);
  }

  if (header_.chunk_size == 0) {
    error_ = "invalid trace chunk size";
    return false;
  }
  if (header_.compression != trace_compression::none && header_.compression != trace_compression::zstd) {
    error_ = "unsupported trace compression mode";
    return false;
  }
#if !defined(W1_REWIND_HAVE_ZSTD)
  if (header_.compression == trace_compression::zstd) {
    error_ = "trace requires zstd support";
    return false;
  }
#endif

  header_read_ = true;
  return true;
}

bool trace_reader::ensure_chunk_info(uint32_t chunk_index) {
  if (!header_read_) {
    if (!read_header()) {
      return false;
    }
  }
  if (chunks_.size() > chunk_index) {
    return true;
  }
  if (header_end_offset_ == 0) {
    error_ = "trace header offset unknown";
    return false;
  }
  if (!stream_.is_open()) {
    error_ = "trace file not open";
    return false;
  }

  uint32_t start_index = static_cast<uint32_t>(chunks_.size());
  uint64_t offset = header_end_offset_;
  if (start_index > 0) {
    const auto& last = chunks_.back();
    offset = last.file_offset + 8u + last.compressed_size;
  }

  stream_.clear();
  stream_.seekg(static_cast<std::streamoff>(offset), std::ios::beg);
  if (!stream_) {
    error_ = "failed to seek to chunk";
    return false;
  }

  for (uint32_t current = start_index; current <= chunk_index; ++current) {
    std::streampos header_pos = stream_.tellg();
    if (header_pos < 0) {
      error_ = "failed to read chunk header offset";
      return false;
    }

    uint32_t compressed_size = 0;
    uint32_t uncompressed_size = 0;
    if (!read_stream_u32(stream_, compressed_size) || !read_stream_u32(stream_, uncompressed_size)) {
      if (error_.empty()) {
        error_ = "truncated chunk header";
      }
      return false;
    }
    if (compressed_size == 0 || uncompressed_size == 0) {
      error_ = "invalid chunk header";
      return false;
    }

    if (chunks_.size() <= current) {
      chunks_.resize(current + 1);
    }
    chunks_[current] = trace_chunk_info{
        static_cast<uint64_t>(header_pos),
        compressed_size,
        uncompressed_size,
    };

    stream_.seekg(static_cast<std::streamoff>(compressed_size), std::ios::cur);
    if (!stream_) {
      error_ = "failed to seek to next chunk";
      return false;
    }
  }

  return true;
}

bool trace_reader::read_chunk() {
  if (!stream_.is_open()) {
    error_ = "trace file not open";
    return false;
  }

  int next = stream_.peek();
  if (next == std::char_traits<char>::eof()) {
    return false;
  }

  std::streampos header_pos = stream_.tellg();
  if (header_pos < 0) {
    error_ = "failed to read chunk header offset";
    return false;
  }
  return read_chunk_at(static_cast<uint64_t>(header_pos), next_chunk_index_, nullptr);
}

bool trace_reader::read_chunk_at(uint64_t file_offset, uint32_t chunk_index, const trace_chunk_info* expected) {
  if (!stream_.is_open()) {
    error_ = "trace file not open";
    return false;
  }

  stream_.clear();
  stream_.seekg(static_cast<std::streamoff>(file_offset), std::ios::beg);
  if (!stream_) {
    error_ = "failed to seek to chunk";
    return false;
  }

  std::streampos header_pos = stream_.tellg();
  if (header_pos < 0) {
    error_ = "failed to read chunk header offset";
    return false;
  }

  uint32_t compressed_size = 0;
  uint32_t uncompressed_size = 0;
  if (!read_stream_u32(stream_, compressed_size) || !read_stream_u32(stream_, uncompressed_size)) {
    if (error_.empty()) {
      error_ = "truncated chunk header";
    }
    return false;
  }

  if (compressed_size == 0 || uncompressed_size == 0) {
    error_ = "invalid chunk header";
    return false;
  }

  if (expected) {
    if (expected->file_offset != static_cast<uint64_t>(header_pos)) {
      error_ = "trace chunk offset mismatch";
      return false;
    }
    if (expected->compressed_size != compressed_size || expected->uncompressed_size != uncompressed_size) {
      error_ = "trace chunk size mismatch";
      return false;
    }
  }

  std::vector<uint8_t> compressed(compressed_size);
  if (!read_stream_bytes(compressed.data(), compressed.size())) {
    if (error_.empty()) {
      error_ = "truncated chunk payload";
    }
    return false;
  }

  last_chunk_info_ = trace_chunk_info{
      static_cast<uint64_t>(header_pos),
      compressed_size,
      uncompressed_size,
  };
  if (chunks_.size() <= chunk_index) {
    chunks_.resize(chunk_index + 1);
  }
  chunks_[chunk_index] = *last_chunk_info_;
  current_chunk_index_ = chunk_index;
  next_chunk_index_ = chunk_index + 1;

  if (header_.compression == trace_compression::none) {
    if (compressed_size != uncompressed_size) {
      error_ = "uncompressed chunk size mismatch";
      return false;
    }
    chunk_buffer_ = std::move(compressed);
    chunk_offset_ = 0;
    return true;
  }

  if (header_.compression != trace_compression::zstd) {
    error_ = "unsupported trace compression mode";
    return false;
  }

#if defined(W1_REWIND_HAVE_ZSTD)
  chunk_buffer_.assign(uncompressed_size, 0);
  size_t result = ZSTD_decompress(chunk_buffer_.data(), chunk_buffer_.size(), compressed.data(), compressed.size());
  if (ZSTD_isError(result)) {
    error_ = std::string("zstd decompression failed: ") + ZSTD_getErrorName(result);
    return false;
  }
  if (result != uncompressed_size) {
    error_ = "zstd decompressed size mismatch";
    return false;
  }
  chunk_offset_ = 0;
  return true;
#else
  error_ = "trace requires zstd support";
  return false;
#endif
}

bool trace_reader::read_stream_bytes(void* data, size_t size) {
  if (!w1::rewind::read_stream_bytes(stream_, data, size)) {
    error_ = "truncated trace data";
    return false;
  }
  return true;
}

bool trace_reader::read_bytes(void* data, size_t size) {
  if (size == 0) {
    return true;
  }

  if (chunk_offset_ >= chunk_buffer_.size()) {
    chunk_buffer_.clear();
    chunk_offset_ = 0;
    if (!read_chunk()) {
      return false;
    }
  }

  if (chunk_offset_ + size > chunk_buffer_.size()) {
    error_ = "record spans chunk boundary";
    return false;
  }

  std::memcpy(data, chunk_buffer_.data() + chunk_offset_, size);
  chunk_offset_ += size;
  return true;
}

bool trace_reader::read_record_header(record_header& header) {
  std::array<uint8_t, 8> buf{};
  if (!read_bytes(buf.data(), buf.size())) {
    return false;
  }
  trace_buffer_reader reader(std::span<const uint8_t>(buf.data(), buf.size()));
  uint16_t kind_value = 0;
  uint16_t flags = 0;
  uint32_t size = 0;
  if (!reader.read_u16(kind_value) || !reader.read_u16(flags) || !reader.read_u32(size)) {
    return false;
  }

  header.kind = static_cast<record_kind>(kind_value);
  header.flags = flags;
  header.size = size;
  return true;
}

bool trace_reader::parse_record(
    const record_header& header, const std::vector<uint8_t>& payload, trace_record& record
) {
  trace_buffer_reader reader(std::span<const uint8_t>(payload.data(), payload.size()));

  switch (header.kind) {
  case record_kind::target_info: {
    target_info_record out{};
    if (!decode_target_info(reader, out)) {
      return false;
    }
    target_info_ = out;
    record = std::move(out);
    return true;
  }
  case record_kind::target_environment: {
    target_environment_record out{};
    if (!decode_target_environment(reader, out)) {
      return false;
    }
    target_environment_ = out;
    record = std::move(out);
    return true;
  }
  case record_kind::register_spec: {
    register_spec_record out{};
    if (!decode_register_spec(reader, out)) {
      return false;
    }
    register_specs_ = out.registers;
    record = std::move(out);
    return true;
  }
  case record_kind::module_table: {
    module_table_record out{};
    if (!decode_module_table(reader, out)) {
      return false;
    }
    module_table_ = out.modules;
    record = std::move(out);
    return true;
  }
  case record_kind::module_load: {
    module_load_record out{};
    if (!decode_module_load(reader, out)) {
      return false;
    }
    apply_module_load(out.module);
    record = std::move(out);
    return true;
  }
  case record_kind::module_unload: {
    module_unload_record out{};
    if (!decode_module_unload(reader, out)) {
      return false;
    }
    apply_module_unload(out);
    record = std::move(out);
    return true;
  }
  case record_kind::memory_map: {
    memory_map_record out{};
    if (!decode_memory_map(reader, out)) {
      return false;
    }
    memory_map_ = out.regions;
    record = std::move(out);
    return true;
  }
  case record_kind::thread_start: {
    thread_start_record out{};
    if (!decode_thread_start(reader, out)) {
      return false;
    }
    record = std::move(out);
    return true;
  }
  case record_kind::instruction: {
    instruction_record out{};
    if (!decode_instruction(reader, out)) {
      return false;
    }
    record = std::move(out);
    return true;
  }
  case record_kind::block_definition: {
    block_definition_record out{};
    if (!decode_block_definition(reader, out)) {
      return false;
    }
    record = std::move(out);
    return true;
  }
  case record_kind::block_exec: {
    block_exec_record out{};
    if (!decode_block_exec(reader, out)) {
      return false;
    }
    record = std::move(out);
    return true;
  }
  case record_kind::register_deltas: {
    register_delta_record out{};
    if (!decode_register_deltas(reader, out)) {
      return false;
    }
    record = std::move(out);
    return true;
  }
  case record_kind::register_bytes: {
    register_bytes_record out{};
    if (!decode_register_bytes(reader, out)) {
      return false;
    }
    record = std::move(out);
    return true;
  }
  case record_kind::memory_access: {
    memory_access_record out{};
    if (!decode_memory_access(reader, out)) {
      return false;
    }
    record = std::move(out);
    return true;
  }
  case record_kind::snapshot: {
    snapshot_record out{};
    if (!decode_snapshot(reader, out)) {
      return false;
    }
    record = std::move(out);
    return true;
  }
  case record_kind::thread_end: {
    thread_end_record out{};
    if (!decode_thread_end(reader, out)) {
      return false;
    }
    record = std::move(out);
    return true;
  }
  default:
    error_ = "unknown record kind";
    return false;
  }
}

void trace_reader::apply_module_load(module_record module) {
  auto it = std::find_if(module_table_.begin(), module_table_.end(), [&](const module_record& entry) {
    return entry.id == module.id;
  });
  if (it != module_table_.end()) {
    *it = std::move(module);
    return;
  }
  module_table_.push_back(std::move(module));
}

void trace_reader::apply_module_unload(const module_unload_record& record) {
  auto it = std::find_if(module_table_.begin(), module_table_.end(), [&](const module_record& entry) {
    return entry.id == record.module_id;
  });
  if (it != module_table_.end()) {
    module_table_.erase(it);
    return;
  }

  if (record.base == 0 && record.size == 0 && record.path.empty()) {
    return;
  }

  auto fallback = std::find_if(module_table_.begin(), module_table_.end(), [&](const module_record& entry) {
    if (record.base != 0 && entry.base != record.base) {
      return false;
    }
    if (record.size != 0 && entry.size != record.size) {
      return false;
    }
    if (!record.path.empty() && entry.path != record.path) {
      return false;
    }
    return true;
  });

  if (fallback != module_table_.end()) {
    module_table_.erase(fallback);
  }
}

} // namespace w1::rewind

```

`src/w1rewind/trace/trace_reader.hpp`:

```hpp
#pragma once

#include <fstream>
#include <optional>
#include <string>
#include <vector>

#include "record_stream.hpp"

namespace w1::rewind {

class trace_reader final : public trace_record_stream {
public:
  explicit trace_reader(std::string path);

  bool open() override;
  void close() override;
  void reset();

  bool read_next(trace_record& record);
  bool read_next(trace_record& record, trace_record_location* location) override;
  bool seek_to_location(const trace_record_location& location) override;
  bool seek_to_chunk(const trace_chunk_info& chunk, uint32_t chunk_index, uint32_t record_offset);

  const trace_header& header() const override { return header_; }
  const std::optional<target_info_record>& target_info() const { return target_info_; }
  const std::optional<target_environment_record>& target_environment() const { return target_environment_; }
  const std::vector<register_spec>& register_specs() const { return register_specs_; }
  const std::vector<module_record>& module_table() const { return module_table_; }
  const std::vector<memory_region_record>& memory_map() const { return memory_map_; }
  std::string_view error() const override { return error_; }
  const std::optional<trace_chunk_info>& last_chunk_info() const override { return last_chunk_info_; }
  uint32_t current_chunk_index() const { return current_chunk_index_; }

private:
  bool read_header();
  bool read_chunk();
  bool read_chunk_at(uint64_t file_offset, uint32_t chunk_index, const trace_chunk_info* expected);
  bool read_stream_bytes(void* data, size_t size);
  bool read_bytes(void* data, size_t size);
  bool read_record_header(record_header& header);
  bool ensure_chunk_info(uint32_t chunk_index);

  bool parse_record(const record_header& header, const std::vector<uint8_t>& payload, trace_record& record);
  void apply_module_load(module_record module);
  void apply_module_unload(const module_unload_record& record);

  std::string path_;
  std::ifstream stream_;
  trace_header header_{};
  bool header_read_ = false;
  std::vector<uint8_t> chunk_buffer_{};
  size_t chunk_offset_ = 0;
  uint32_t next_chunk_index_ = 0;
  uint32_t current_chunk_index_ = 0;
  std::optional<trace_chunk_info> last_chunk_info_{};
  std::vector<trace_chunk_info> chunks_{};
  uint64_t header_end_offset_ = 0;
  std::optional<target_info_record> target_info_{};
  std::optional<target_environment_record> target_environment_{};
  std::vector<register_spec> register_specs_{};
  std::vector<module_record> module_table_{};
  std::vector<memory_region_record> memory_map_{};
  std::string error_;
};

} // namespace w1::rewind

```

`src/w1runtime/CMakeLists.txt`:

```txt
w1_dep_qbdi()

w1_add_static_library(w1runtime
    module_catalog.cpp
    memory_reader.cpp
    register_capture.cpp
    stack_capture.cpp
    thread_catalog.cpp
    process_observer.cpp
)
add_library(w1::runtime ALIAS w1runtime)

target_link_libraries(w1runtime PUBLIC QBDI::QBDI w1monitor)

```

`src/w1runtime/memory_reader.cpp`:

```cpp
#include "w1runtime/memory_reader.hpp"

#include <algorithm>
#include <cstring>

#include "w1base/interval.hpp"
#include <mutex>

namespace w1::util {

std::optional<std::vector<uint8_t>> memory_reader::read_bytes(uint64_t address, size_t size) const {
  if (address == 0) {
    return std::nullopt;
  }

  if (size == 0) {
    return std::vector<uint8_t>{};
  }

  uint64_t end = 0;
  if (!compute_end(address, size, &end)) {
    return std::nullopt;
  }

  refresh_maps(false);
  if (!is_readable_range(address, end)) {
    refresh_maps(true);
    if (!is_readable_range(address, end)) {
      return std::nullopt;
    }
  }

  std::vector<uint8_t> data(size);
  std::memcpy(data.data(), reinterpret_cast<const void*>(address), size);
  return data;
}

std::optional<std::string> memory_reader::read_string(uint64_t address, size_t max_len) const {
  if (address == 0) {
    return std::nullopt;
  }

  if (max_len == 0) {
    return std::string{};
  }

  auto bytes = read_bytes(address, max_len);
  if (!bytes) {
    return std::nullopt;
  }

  auto end = std::find(bytes->begin(), bytes->end(), '\0');
  return std::string(bytes->begin(), end);
}

bool memory_reader::is_readable_range(uint64_t address, uint64_t end) const {
  std::shared_lock lock(maps_mutex_);
  return is_readable_range_locked(address, end);
}

bool memory_reader::is_readable_range_locked(uint64_t address, uint64_t end) const {
  if (address >= end) {
    return false;
  }

  auto it = std::upper_bound(
      readable_maps_.begin(), readable_maps_.end(), address,
      [](uint64_t value, const QBDI::MemoryMap& map) { return value < map.range.start(); }
  );

  if (it == readable_maps_.begin()) {
    return false;
  }

  --it;
  if (address < it->range.start() || end > it->range.end()) {
    return false;
  }

  return true;
}

void memory_reader::refresh_maps(bool force) const {
  auto now = std::chrono::steady_clock::now();
  {
    std::shared_lock lock(maps_mutex_);
    if (!force && !readable_maps_.empty() && (now - last_refresh_) < min_refresh_interval) {
      return;
    }
  }

  auto maps = QBDI::getCurrentProcessMaps(true);
  std::vector<QBDI::MemoryMap> readable;
  readable.reserve(maps.size());

  for (const auto& map : maps) {
    if (map.permission & QBDI::PF_READ) {
      readable.push_back(map);
    }
  }

  std::sort(readable.begin(), readable.end(), [](const QBDI::MemoryMap& left, const QBDI::MemoryMap& right) {
    return left.range.start() < right.range.start();
  });

  std::unique_lock lock(maps_mutex_);
  readable_maps_ = std::move(readable);
  last_refresh_ = now;
}

} // namespace w1::util

```

`src/w1runtime/memory_reader.hpp`:

```hpp
#pragma once

#include <chrono>
#include <cstdint>
#include <optional>
#include <shared_mutex>
#include <string>
#include <vector>

#include <QBDI.h>
#include <QBDI/Memory.hpp>

namespace w1 {
namespace runtime {
class module_catalog;
} // namespace runtime

namespace util {

class memory_reader {
public:
  explicit memory_reader(QBDI::VM* vm, const runtime::module_catalog& modules) : vm_(vm), modules_(&modules) {}

  std::optional<std::vector<uint8_t>> read_bytes(uint64_t address, size_t size) const;
  std::optional<std::string> read_string(uint64_t address, size_t max_len) const;

private:
  bool is_readable_range(uint64_t address, uint64_t end) const;
  bool is_readable_range_locked(uint64_t address, uint64_t end) const;
  void refresh_maps(bool force) const;

  [[maybe_unused]] QBDI::VM* vm_ = nullptr;
  [[maybe_unused]] const runtime::module_catalog* modules_ = nullptr;
  mutable std::shared_mutex maps_mutex_{};
  mutable std::vector<QBDI::MemoryMap> readable_maps_{};
  mutable std::chrono::steady_clock::time_point last_refresh_{};
  static constexpr auto min_refresh_interval = std::chrono::milliseconds(100);
};

} // namespace util
} // namespace w1

```

`src/w1runtime/module_catalog.cpp`:

```cpp
#include "w1runtime/module_catalog.hpp"

#include <algorithm>
#include <cctype>
#include <cstdio>
#include <filesystem>
#include <optional>
#include <unordered_map>

#include <QBDI/Memory.hpp>
#include <mutex>

#if defined(_WIN32)
#include <w1base/windows_clean.hpp>
#elif defined(__APPLE__)
#include <mach-o/dyld.h>
#include <cstring>
#elif defined(__linux__)
#include <limits.h>
#include <unistd.h>
#endif

namespace w1::runtime {
namespace {

struct module_span {
  std::string name;
  std::string path;
  uint64_t start = 0;
  uint64_t end = 0;
  uint32_t permissions = 0;
  bool is_system = false;
  std::vector<address_range> mapped_ranges;
  std::vector<address_range> exec_ranges;
};

std::string extract_basename(const std::string& path) {
  if (path.empty()) {
    return path;
  }

  size_t pos = path.find_last_of("/\\");
  if (pos != std::string::npos) {
    return path.substr(pos + 1);
  }

  return path;
}

std::string make_unnamed_name(uint64_t start) {
  char buffer[32];
  std::snprintf(buffer, sizeof(buffer), "_unnamed_0x%llx", static_cast<unsigned long long>(start));
  return buffer;
}

#if defined(_WIN32)
std::string utf16_to_utf8(const wchar_t* value, size_t length) {
  if (!value || length == 0) {
    return {};
  }
  const int wchar_len = static_cast<int>(length);
  if (wchar_len <= 0) {
    return {};
  }
  const int required = WideCharToMultiByte(CP_UTF8, 0, value, wchar_len, nullptr, 0, nullptr, nullptr);
  if (required <= 0) {
    return {};
  }
  std::string out(static_cast<size_t>(required), '\0');
  WideCharToMultiByte(CP_UTF8, 0, value, wchar_len, out.data(), required, nullptr, nullptr);
  return out;
}
#endif

std::optional<std::string> detect_main_executable_path() {
#if defined(_WIN32)
  std::wstring buffer;
  DWORD size = MAX_PATH;
  buffer.resize(size);
  DWORD length = GetModuleFileNameW(nullptr, buffer.data(), size);
  if (length == 0) {
    return std::nullopt;
  }
  while (length == size) {
    size *= 2;
    buffer.resize(size);
    length = GetModuleFileNameW(nullptr, buffer.data(), size);
    if (length == 0) {
      return std::nullopt;
    }
  }
  buffer.resize(length);
  return utf16_to_utf8(buffer.data(), buffer.size());
#elif defined(__APPLE__)
  uint32_t size = 0;
  if (_NSGetExecutablePath(nullptr, &size) != -1 || size == 0) {
    return std::nullopt;
  }
  std::string path(size, '\0');
  if (_NSGetExecutablePath(path.data(), &size) != 0) {
    return std::nullopt;
  }
  path.resize(std::strlen(path.c_str()));
  return path;
#elif defined(__linux__)
  char buffer[PATH_MAX];
  const ssize_t len = readlink("/proc/self/exe", buffer, sizeof(buffer) - 1);
  if (len <= 0) {
    return std::nullopt;
  }
  buffer[len] = '\0';
  return std::string(buffer, static_cast<size_t>(len));
#else
  return std::nullopt;
#endif
}

std::string normalize_path(const std::string& path) {
  if (path.empty()) {
    return {};
  }
  std::error_code ec;
  auto canonical = std::filesystem::weakly_canonical(std::filesystem::path(path), ec);
  if (!ec) {
    return canonical.string();
  }
  return path;
}

bool path_equal(const std::string& left, const std::string& right) {
  if (left.empty() || right.empty()) {
    return false;
  }
#if defined(_WIN32)
  auto normalize_for_compare = [](std::string value) {
    std::replace(value.begin(), value.end(), '/', '\\');
    std::transform(value.begin(), value.end(), value.begin(), [](unsigned char ch) {
      return static_cast<char>(std::tolower(ch));
    });
    return value;
  };
  return normalize_for_compare(left) == normalize_for_compare(right);
#else
  return left == right;
#endif
}

bool is_system_library(const std::string& path) {
  if (path.empty()) {
    return false;
  }

#ifdef __APPLE__
  if (path.rfind("/usr/lib/", 0) == 0 || path.rfind("/System/Library/", 0) == 0 || path.rfind("/Library/", 0) == 0) {
    return true;
  }
  if (path.rfind("libsystem", 0) == 0 || path.rfind("libc++", 0) == 0 || path.rfind("libobjc", 0) == 0 ||
      path.rfind("libdispatch", 0) == 0 || path.rfind("libxpc", 0) == 0 || path.rfind("libcorecrypto", 0) == 0 ||
      path.rfind("libcompiler_rt", 0) == 0 || path.rfind("libdyld", 0) == 0 || path.rfind("dyld", 0) == 0 ||
      path.rfind("libquarantine", 0) == 0 || path.rfind("libmacho", 0) == 0 || path.rfind("libcommonCrypto", 0) == 0 ||
      path.rfind("libunwind", 0) == 0 || path.rfind("libcopyfile", 0) == 0 || path.rfind("libremovefile", 0) == 0 ||
      path.rfind("libkeymgr", 0) == 0 || path.rfind("libcache", 0) == 0 || path.rfind("libSystem", 0) == 0 ||
      path.rfind("libRosetta", 0) == 0) {
    return true;
  }
  return false;
#elif defined(__linux__)
  return (
      path.rfind("/lib/", 0) == 0 || path.rfind("/usr/lib/", 0) == 0 || path.rfind("/lib64/", 0) == 0 ||
      path.rfind("/usr/lib64/", 0) == 0
  );
#elif defined(_WIN32)
  std::string lower_path = path;
  std::transform(lower_path.begin(), lower_path.end(), lower_path.begin(), [](unsigned char value) {
    return static_cast<char>(std::tolower(value));
  });
  return (
      lower_path.rfind("c:\\windows\\", 0) == 0 || lower_path.rfind("c:\\program files\\", 0) == 0 ||
      lower_path.rfind("c:\\program files (x86)\\", 0) == 0
  );
#else
  return false;
#endif
}

} // namespace

void module_catalog::refresh() {
  auto maps = QBDI::getCurrentProcessMaps(true);
  std::unordered_map<std::string, module_span> spans;
  spans.reserve(maps.size());

  for (const auto& map : maps) {
    uint64_t start = map.range.start();
    uint64_t end = map.range.end();
    if (end <= start) {
      continue;
    }

    std::string key = map.name;
    if (key.empty()) {
      key = make_unnamed_name(start);
    }

    auto [it, inserted] = spans.emplace(key, module_span{});
    module_span& span = it->second;

    if (inserted) {
      span.path = map.name;
      span.name = map.name.empty() ? key : extract_basename(map.name);
      span.start = start;
      span.end = end;
      span.permissions = static_cast<uint32_t>(map.permission);
      span.is_system = is_system_library(map.name);
    } else {
      span.start = std::min(span.start, start);
      span.end = std::max(span.end, end);
      span.permissions |= static_cast<uint32_t>(map.permission);
    }

    span.mapped_ranges.push_back(address_range{start, end});
    if (map.permission & QBDI::PF_EXEC) {
      span.exec_ranges.push_back(address_range{start, end});
    }
  }

  std::vector<module_info> modules;
  modules.reserve(spans.size());

  for (auto& [key, span] : spans) {
    if (span.end <= span.start) {
      continue;
    }

    std::sort(
        span.mapped_ranges.begin(), span.mapped_ranges.end(),
        [](const address_range& left, const address_range& right) { return left.start < right.start; }
    );
    std::sort(
        span.exec_ranges.begin(), span.exec_ranges.end(),
        [](const address_range& left, const address_range& right) { return left.start < right.start; }
    );

    module_info info{};
    info.name = span.name.empty() ? key : span.name;
    info.path = span.path.empty() ? info.name : span.path;
    info.base_address = span.start;
    info.size = span.end - span.start;
    info.permissions = span.permissions;
    info.is_system = span.is_system;
    info.full_range = address_range{span.start, span.end};
    info.mapped_ranges = std::move(span.mapped_ranges);
    info.exec_ranges = std::move(span.exec_ranges);

    modules.push_back(std::move(info));
  }

  std::sort(modules.begin(), modules.end(), [](const module_info& left, const module_info& right) {
    return left.full_range.start < right.full_range.start;
  });

  auto main_path = detect_main_executable_path();
  if (main_path && !main_path->empty()) {
    const std::string normalized_main = normalize_path(*main_path);
    const std::string main_basename = extract_basename(normalized_main.empty() ? *main_path : normalized_main);
    const std::string canonical_main = normalized_main.empty() ? *main_path : normalized_main;
    std::optional<size_t> main_index;
    for (size_t index = 0; index < modules.size(); ++index) {
      const auto& candidate = modules[index];
      if (path_equal(candidate.path, *main_path) ||
          (!normalized_main.empty() && path_equal(candidate.path, normalized_main))) {
        main_index = index;
        break;
      }
    }
    if (!main_index && !main_basename.empty()) {
      for (size_t index = 0; index < modules.size(); ++index) {
        if (extract_basename(modules[index].path) == main_basename) {
          main_index = index;
          break;
        }
      }
    }
    if (main_index) {
      auto& entry = modules[*main_index];
      entry.is_main = true;
      entry.path = canonical_main;
      if (entry.name.empty()) {
        entry.name = extract_basename(entry.path);
      }
    }
  }

  std::vector<range_index_entry> range_index;
  size_t total_ranges = 0;
  for (const auto& module : modules) {
    total_ranges += module.mapped_ranges.size();
  }
  range_index.reserve(total_ranges);

  for (size_t index = 0; index < modules.size(); ++index) {
    const auto& module = modules[index];
    for (const auto& range : module.mapped_ranges) {
      if (range.end <= range.start) {
        continue;
      }
      range_index.push_back(range_index_entry{range, index});
    }
  }

  std::sort(range_index.begin(), range_index.end(), [](const range_index_entry& left, const range_index_entry& right) {
    return left.range.start < right.range.start;
  });

  std::unique_lock lock(mutex_);
  modules_ = std::move(modules);
  range_index_ = std::move(range_index);
  version_.fetch_add(1, std::memory_order_release);
}

const module_info* module_catalog::find_containing(uint64_t address) const {
  std::shared_lock lock(mutex_);
  if (modules_.empty() || range_index_.empty()) {
    return nullptr;
  }

  auto it = std::upper_bound(
      range_index_.begin(), range_index_.end(), address,
      [](uint64_t value, const range_index_entry& entry) { return value < entry.range.start; }
  );

  if (it == range_index_.begin()) {
    return nullptr;
  }

  --it;
  if (address >= it->range.start && address < it->range.end) {
    return &modules_[it->module_index];
  }

  return nullptr;
}

std::vector<module_info> module_catalog::list_modules() const {
  std::shared_lock lock(mutex_);
  return modules_;
}

} // namespace w1::runtime

```

`src/w1runtime/module_catalog.hpp`:

```hpp
#pragma once

#include <atomic>
#include <cstddef>
#include <cstdint>
#include <shared_mutex>
#include <string>
#include <vector>

#include "w1base/types.hpp"

namespace w1::runtime {

struct module_info {
  std::string name;
  std::string path;
  uint64_t base_address = 0;
  uint64_t size = 0;
  uint32_t permissions = 0;
  bool is_system = false;
  bool is_main = false;
  address_range full_range{};
  std::vector<address_range> mapped_ranges;
  std::vector<address_range> exec_ranges;
};

class module_catalog {
public:
  void refresh();
  const module_info* find_containing(uint64_t address) const;
  std::vector<module_info> list_modules() const;
  uint64_t version() const { return version_.load(std::memory_order_acquire); }

private:
  struct range_index_entry {
    address_range range{};
    size_t module_index = 0;
  };

  mutable std::shared_mutex mutex_{};
  std::vector<module_info> modules_;
  std::vector<range_index_entry> range_index_;
  std::atomic<uint64_t> version_{0};
};

} // namespace w1::runtime

```

`src/w1runtime/process_event.hpp`:

```hpp
#pragma once

#include "w1monitor/module_monitor.hpp"
#include "w1monitor/thread_monitor.hpp"

namespace w1::runtime {

struct process_event {
  enum class kind { module_loaded, module_unloaded, thread_started, thread_stopped, thread_renamed };
  kind type = kind::module_loaded;
  w1::monitor::module_event module{};
  w1::monitor::thread_event thread{};
};

} // namespace w1::runtime

```

`src/w1runtime/process_observer.cpp`:

```cpp
#include "w1runtime/process_observer.hpp"

#include <chrono>

namespace w1::runtime {
namespace {
constexpr auto kPollInterval = std::chrono::milliseconds(5);
}

process_observer::process_observer() = default;

process_observer::~process_observer() { stop(); }

void process_observer::start() {
  if (running_.exchange(true, std::memory_order_acq_rel)) {
    return;
  }

  {
    std::lock_guard<std::mutex> lock(monitor_mutex_);
    module_monitor_ = w1::monitor::make_module_monitor();
    thread_monitor_ = w1::monitor::make_thread_monitor();
    if (thread_monitor_) {
      thread_monitor_->set_entry_callback(entry_callback_);
    }
    if (module_monitor_) {
      module_monitor_->start();
    }
    if (thread_monitor_) {
      thread_monitor_->start();
    }
  }

  pump_thread_ = std::thread(&process_observer::pump, this);
}

void process_observer::stop() {
  if (!running_.exchange(false, std::memory_order_acq_rel)) {
    return;
  }

  if (pump_thread_.joinable()) {
    pump_thread_.join();
  }

  std::lock_guard<std::mutex> lock(monitor_mutex_);
  if (module_monitor_) {
    module_monitor_->stop();
  }
  if (thread_monitor_) {
    thread_monitor_->stop();
  }
  module_monitor_.reset();
  thread_monitor_.reset();
}

void process_observer::poll_once() {
  w1::monitor::module_event module_event{};
  w1::monitor::thread_event thread_event{};

  std::unique_lock<std::mutex> lock(monitor_mutex_);
  if (module_monitor_) {
    while (module_monitor_->poll(module_event)) {
      lock.unlock();
      handle_module_event(module_event);
      lock.lock();
    }
  }
  if (thread_monitor_) {
    while (thread_monitor_->poll(thread_event)) {
      lock.unlock();
      handle_thread_event(thread_event);
      lock.lock();
    }
  }
}

process_observer::subscription_id process_observer::subscribe(event_callback callback) {
  std::lock_guard<std::mutex> lock(callback_mutex_);
  subscription_id id = next_callback_id_.fetch_add(1, std::memory_order_relaxed);
  callbacks_.emplace(id, std::move(callback));
  return id;
}

void process_observer::unsubscribe(subscription_id id) {
  std::lock_guard<std::mutex> lock(callback_mutex_);
  callbacks_.erase(id);
}

void process_observer::set_thread_entry_callback(w1::monitor::thread_entry_callback callback) {
  std::lock_guard<std::mutex> lock(monitor_mutex_);
  entry_callback_ = std::move(callback);
  if (thread_monitor_) {
    thread_monitor_->set_entry_callback(entry_callback_);
  }
}

void process_observer::pump() {
  while (running_.load(std::memory_order_acquire)) {
    poll_once();
    std::this_thread::sleep_for(kPollInterval);
  }
}

void process_observer::emit_event(const process_event& event) {
  std::vector<event_callback> callbacks_copy;
  {
    std::lock_guard<std::mutex> lock(callback_mutex_);
    callbacks_copy.reserve(callbacks_.size());
    for (const auto& [id, callback] : callbacks_) {
      (void) id;
      callbacks_copy.push_back(callback);
    }
  }

  for (const auto& callback : callbacks_copy) {
    if (callback) {
      callback(event);
    }
  }
}

void process_observer::handle_module_event(const w1::monitor::module_event& event) {
  modules_.refresh();

  process_event out{};
  out.module = event;
  out.type = (event.type == w1::monitor::module_event::kind::loaded) ? process_event::kind::module_loaded
                                                                     : process_event::kind::module_unloaded;
  emit_event(out);
}

void process_observer::handle_thread_event(const w1::monitor::thread_event& event) {
  threads_.apply(event);

  process_event out{};
  out.thread = event;
  switch (event.type) {
  case w1::monitor::thread_event::kind::started:
    out.type = process_event::kind::thread_started;
    break;
  case w1::monitor::thread_event::kind::stopped:
    out.type = process_event::kind::thread_stopped;
    break;
  case w1::monitor::thread_event::kind::renamed:
    out.type = process_event::kind::thread_renamed;
    break;
  default:
    return;
  }
  emit_event(out);
}

} // namespace w1::runtime

```

`src/w1runtime/process_observer.hpp`:

```hpp
#pragma once

#include <atomic>
#include <functional>
#include <mutex>
#include <thread>
#include <unordered_map>
#include <vector>

#include "w1monitor/monitor_factory.hpp"
#include "w1runtime/module_catalog.hpp"
#include "w1runtime/process_event.hpp"
#include "w1runtime/thread_catalog.hpp"

namespace w1::runtime {

class process_observer {
public:
  using subscription_id = uint64_t;
  using event_callback = std::function<void(const process_event&)>;

  process_observer();
  ~process_observer();

  void start();
  void stop();
  void poll_once();

  subscription_id subscribe(event_callback callback);
  void unsubscribe(subscription_id id);
  void set_thread_entry_callback(w1::monitor::thread_entry_callback callback);

  module_catalog& modules() { return modules_; }
  thread_catalog& threads() { return threads_; }

  bool running() const { return running_.load(std::memory_order_acquire); }

private:
  void pump();
  void emit_event(const process_event& event);
  void handle_module_event(const w1::monitor::module_event& event);
  void handle_thread_event(const w1::monitor::thread_event& event);

  std::atomic<bool> running_{false};
  std::thread pump_thread_{};

  std::mutex callback_mutex_{};
  std::unordered_map<subscription_id, event_callback> callbacks_{};
  std::atomic<subscription_id> next_callback_id_{1};

  std::mutex monitor_mutex_{};
  std::unique_ptr<w1::monitor::module_monitor> module_monitor_{};
  std::unique_ptr<w1::monitor::thread_monitor> thread_monitor_{};
  w1::monitor::thread_entry_callback entry_callback_{};

  module_catalog modules_{};
  thread_catalog threads_{};
};

} // namespace w1::runtime

```

`src/w1runtime/register_capture.cpp`:

```cpp
#include "w1runtime/register_capture.hpp"

#include <algorithm>

namespace w1::util {

bool register_state::get_register(const std::string& name, uint64_t& value) const {
  auto it = registers_.find(name);
  if (it != registers_.end()) {
    value = it->second;
    return true;
  }
  return false;
}

uint64_t register_state::get_stack_pointer() const {
#if defined(QBDI_ARCH_X86_64)
  return registers_.at("rsp");
#elif defined(QBDI_ARCH_AARCH64) || defined(QBDI_ARCH_ARM)
  return registers_.at("sp");
#elif defined(QBDI_ARCH_X86)
  return registers_.at("esp");
#else
  return 0;
#endif
}

uint64_t register_state::get_instruction_pointer() const {
#if defined(QBDI_ARCH_X86_64)
  return registers_.at("rip");
#elif defined(QBDI_ARCH_AARCH64) || defined(QBDI_ARCH_ARM)
  return registers_.at("pc");
#elif defined(QBDI_ARCH_X86)
  return registers_.at("eip");
#else
  return 0;
#endif
}

uint64_t register_state::get_frame_pointer() const {
#if defined(QBDI_ARCH_X86_64)
  return registers_.at("rbp");
#elif defined(QBDI_ARCH_AARCH64)
  return registers_.at("x29");
#elif defined(QBDI_ARCH_ARM)
  return registers_.at("r11");
#elif defined(QBDI_ARCH_X86)
  return registers_.at("ebp");
#else
  return 0;
#endif
}

std::vector<std::string> register_state::get_register_names() const {
  std::vector<std::string> names;
  names.reserve(registers_.size());

  for (const auto& [name, _] : registers_) {
    names.push_back(name);
  }

  std::sort(names.begin(), names.end());
  return names;
}

std::unordered_map<std::string, uint64_t> register_state::get_all_registers() const { return registers_; }

register_state register_capturer::capture(const QBDI::GPRState* gpr) {
  register_state state;

  if (!gpr) {
    return state;
  }

#if defined(QBDI_ARCH_X86_64)
  capture_x86_64(state, gpr);
#elif defined(QBDI_ARCH_AARCH64)
  capture_aarch64(state, gpr);
#elif defined(QBDI_ARCH_ARM)
  capture_arm32(state, gpr);
#elif defined(QBDI_ARCH_X86)
  capture_x86(state, gpr);
#endif

  return state;
}

void register_capturer::capture_x86_64(register_state& state, [[maybe_unused]] const QBDI::GPRState* gpr) {
#if defined(QBDI_ARCH_X86_64)
  state.arch_ = register_state::architecture::x86_64;

  state.registers_["rax"] = gpr->rax;
  state.registers_["rbx"] = gpr->rbx;
  state.registers_["rcx"] = gpr->rcx;
  state.registers_["rdx"] = gpr->rdx;
  state.registers_["rsi"] = gpr->rsi;
  state.registers_["rdi"] = gpr->rdi;
  state.registers_["r8"] = gpr->r8;
  state.registers_["r9"] = gpr->r9;
  state.registers_["r10"] = gpr->r10;
  state.registers_["r11"] = gpr->r11;
  state.registers_["r12"] = gpr->r12;
  state.registers_["r13"] = gpr->r13;
  state.registers_["r14"] = gpr->r14;
  state.registers_["r15"] = gpr->r15;

  state.registers_["rbp"] = gpr->rbp;
  state.registers_["rsp"] = gpr->rsp;
  state.registers_["rip"] = gpr->rip;
  state.registers_["eflags"] = gpr->eflags;
  state.registers_["fs"] = gpr->fs;
  state.registers_["gs"] = gpr->gs;
#else
  state.arch_ = register_state::architecture::unknown;
#endif
}

void register_capturer::capture_aarch64(register_state& state, [[maybe_unused]] const QBDI::GPRState* gpr) {
#if defined(QBDI_ARCH_AARCH64)
  state.arch_ = register_state::architecture::aarch64;

  for (int i = 0; i < 29; ++i) {
    state.registers_["x" + std::to_string(i)] = (&gpr->x0)[i];
  }

  state.registers_["x29"] = gpr->x29;
  state.registers_["lr"] = gpr->lr;
  state.registers_["sp"] = gpr->sp;
  state.registers_["pc"] = gpr->pc;
  state.registers_["nzcv"] = gpr->nzcv;
#else
  state.arch_ = register_state::architecture::unknown;
#endif
}

void register_capturer::capture_arm32(register_state& state, [[maybe_unused]] const QBDI::GPRState* gpr) {
#if defined(QBDI_ARCH_ARM)
  state.arch_ = register_state::architecture::arm32;

  state.registers_["r0"] = gpr->r0;
  state.registers_["r1"] = gpr->r1;
  state.registers_["r2"] = gpr->r2;
  state.registers_["r3"] = gpr->r3;
  state.registers_["r4"] = gpr->r4;
  state.registers_["r5"] = gpr->r5;
  state.registers_["r6"] = gpr->r6;
  state.registers_["r7"] = gpr->r7;
  state.registers_["r8"] = gpr->r8;
  state.registers_["r9"] = gpr->r9;
  state.registers_["r10"] = gpr->r10;
  state.registers_["r11"] = gpr->r11;
  state.registers_["r12"] = gpr->r12;

  state.registers_["sp"] = gpr->sp;
  state.registers_["lr"] = gpr->lr;
  state.registers_["pc"] = gpr->pc;
  state.registers_["cpsr"] = gpr->cpsr;
#else
  state.arch_ = register_state::architecture::unknown;
#endif
}

void register_capturer::capture_x86(register_state& state, [[maybe_unused]] const QBDI::GPRState* gpr) {
#if defined(QBDI_ARCH_X86)
  state.arch_ = register_state::architecture::x86;

  state.registers_["eax"] = gpr->eax;
  state.registers_["ebx"] = gpr->ebx;
  state.registers_["ecx"] = gpr->ecx;
  state.registers_["edx"] = gpr->edx;
  state.registers_["esi"] = gpr->esi;
  state.registers_["edi"] = gpr->edi;

  state.registers_["ebp"] = gpr->ebp;
  state.registers_["esp"] = gpr->esp;
  state.registers_["eip"] = gpr->eip;
  state.registers_["eflags"] = gpr->eflags;
#else
  state.arch_ = register_state::architecture::unknown;
#endif
}

} // namespace w1::util

```

`src/w1runtime/register_capture.hpp`:

```hpp
#pragma once

#include <QBDI.h>

#include <cstdint>
#include <string>
#include <unordered_map>
#include <vector>

namespace w1::util {

class register_state {
public:
  enum class architecture { x86_64, aarch64, arm32, x86, unknown };

  architecture get_architecture() const { return arch_; }

  bool get_register(const std::string& name, uint64_t& value) const;
  uint64_t get_stack_pointer() const;
  uint64_t get_instruction_pointer() const;
  uint64_t get_frame_pointer() const;

  std::vector<std::string> get_register_names() const;
  std::unordered_map<std::string, uint64_t> get_all_registers() const;

  // direct const access used for delta calculations to avoid copies
  const std::unordered_map<std::string, uint64_t>& get_register_map() const { return registers_; }
  friend class register_capturer;

private:
  architecture arch_ = architecture::unknown;
  std::unordered_map<std::string, uint64_t> registers_;
};

class register_capturer {
public:
  static register_state capture(const QBDI::GPRState* gpr);

private:
  static void capture_x86_64(register_state& state, const QBDI::GPRState* gpr);
  static void capture_aarch64(register_state& state, const QBDI::GPRState* gpr);
  static void capture_arm32(register_state& state, const QBDI::GPRState* gpr);
  static void capture_x86(register_state& state, const QBDI::GPRState* gpr);
};

} // namespace w1::util

```

`src/w1runtime/stack_capture.cpp`:

```cpp
#include "w1runtime/stack_capture.hpp"

#include <algorithm>
#include <cstring>

namespace w1::util {

stack_info stack_capturer::capture(
    const memory_reader& memory, const register_state& regs, const capture_options& options
) {
  memory_reader_fn reader = [&memory](uint64_t addr, void* buffer, size_t size) -> bool {
    auto bytes = memory.read_bytes(addr, size);
    if (!bytes || bytes->size() != size) {
      return false;
    }
    std::memcpy(buffer, bytes->data(), size);
    return true;
  };

  return capture_with_reader(regs, reader, options);
}

stack_info stack_capturer::capture_with_reader(
    const register_state& regs, memory_reader_fn reader, const capture_options& options
) {
  stack_info info;

  info.stack_pointer = regs.get_stack_pointer();
  info.frame_pointer = regs.get_frame_pointer();

  if (info.stack_pointer == 0) {
    return info;
  }

  info.values.reserve(options.num_values);

  for (size_t i = 0; i < options.num_values; ++i) {
    stack_info::stack_entry entry;
    entry.offset = options.start_offset + static_cast<int64_t>(i * options.value_spacing);

    uint64_t addr = info.stack_pointer;
    if (entry.offset >= 0) {
      addr += static_cast<uint64_t>(entry.offset);
    } else {
      uint64_t delta = static_cast<uint64_t>(-entry.offset);
      if (delta > addr) {
        entry.is_valid = false;
        entry.value = 0;
        info.values.push_back(entry);
        continue;
      }
      addr -= delta;
    }
    entry.is_valid = read_stack_value(reader, addr, entry.value);

    info.values.push_back(entry);
  }

  if (!info.values.empty() && info.values[0].offset == 0 && info.values[0].is_valid) {
    info.return_address = info.values[0].value;
  } else {
    read_stack_value(reader, info.stack_pointer, info.return_address);
  }

  if (options.analyze_frame) {
    switch (regs.get_architecture()) {
    case register_state::architecture::x86_64:
      analyze_x86_64_frame(info, regs, reader);
      break;
    case register_state::architecture::aarch64:
      analyze_aarch64_frame(info, regs, reader);
      break;
    case register_state::architecture::arm32:
      analyze_arm32_frame(info, regs, reader);
      break;
    case register_state::architecture::x86:
      analyze_x86_frame(info, regs, reader);
      break;
    default:
      break;
    }
  }

  return info;
}

void stack_capturer::analyze_x86_64_frame(stack_info& info, const register_state&, memory_reader_fn& reader) {
  if (info.frame_pointer != 0 && info.frame_pointer > info.stack_pointer) {
    info.has_frame_pointer = true;
    info.estimated_frame_size = info.frame_pointer - info.stack_pointer;

    uint64_t saved_rbp = 0;
    uint64_t saved_rip = 0;

    if (read_stack_value(reader, info.frame_pointer, saved_rbp) &&
        read_stack_value(reader, info.frame_pointer + 8, saved_rip)) {
      if (info.return_address == 0) {
        info.return_address = saved_rip;
      }
    }
  }
}

void stack_capturer::analyze_aarch64_frame(stack_info& info, const register_state& regs, memory_reader_fn& reader) {
  if (info.frame_pointer != 0 && info.frame_pointer >= info.stack_pointer) {
    info.has_frame_pointer = true;
    info.estimated_frame_size = info.frame_pointer - info.stack_pointer + 16;

    uint64_t saved_fp = 0;
    uint64_t saved_lr = 0;

    if (read_stack_value(reader, info.frame_pointer - 16, saved_fp) &&
        read_stack_value(reader, info.frame_pointer - 8, saved_lr)) {
      if (info.return_address == 0) {
        info.return_address = saved_lr;
      }
    }
  }

  uint64_t lr_value = 0;
  if (info.return_address == 0 && regs.get_register("lr", lr_value)) {
    info.return_address = lr_value;
  }
}

void stack_capturer::analyze_arm32_frame(stack_info& info, const register_state& regs, memory_reader_fn& reader) {
  if (info.frame_pointer != 0 && info.frame_pointer >= info.stack_pointer) {
    info.has_frame_pointer = true;
    info.estimated_frame_size = info.frame_pointer - info.stack_pointer + 8;

    uint64_t saved_fp = 0;
    uint64_t saved_lr = 0;

    if (read_stack_value(reader, info.frame_pointer - 8, saved_fp) &&
        read_stack_value(reader, info.frame_pointer - 4, saved_lr)) {
      if (info.return_address == 0) {
        info.return_address = saved_lr & 0xFFFFFFFF;
      }
    }
  }

  uint64_t lr_value = 0;
  if (info.return_address == 0 && regs.get_register("lr", lr_value)) {
    info.return_address = lr_value & 0xFFFFFFFF;
  }
}

void stack_capturer::analyze_x86_frame(stack_info& info, const register_state&, memory_reader_fn& reader) {
  if (info.frame_pointer != 0 && info.frame_pointer > info.stack_pointer) {
    info.has_frame_pointer = true;
    info.estimated_frame_size = info.frame_pointer - info.stack_pointer;

    uint64_t saved_ebp = 0;
    uint64_t saved_eip = 0;

    if (read_stack_value(reader, info.frame_pointer, saved_ebp) &&
        read_stack_value(reader, info.frame_pointer + 4, saved_eip)) {
      if (info.return_address == 0) {
        info.return_address = saved_eip & 0xFFFFFFFF;
      }
    }
  }
}

bool stack_capturer::read_stack_value(memory_reader_fn& reader, uint64_t addr, uint64_t& value) {
  constexpr size_t ptr_size = 8;
  uint8_t buffer[ptr_size] = {0};

  if (reader(addr, buffer, ptr_size)) {
    value = 0;
    for (size_t i = 0; i < ptr_size; ++i) {
      value |= static_cast<uint64_t>(buffer[i]) << (i * 8);
    }
    return true;
  }

  value = 0;
  return false;
}

std::vector<stack_walker::frame> stack_walker::walk(
    const memory_reader& memory, const register_state& regs, size_t max_frames
) {
  std::vector<frame> frames;
  frames.reserve(max_frames);

  stack_capturer::memory_reader_fn reader = [&memory](uint64_t addr, void* buffer, size_t size) -> bool {
    auto bytes = memory.read_bytes(addr, size);
    if (!bytes || bytes->size() != size) {
      return false;
    }
    std::memcpy(buffer, bytes->data(), size);
    return true;
  };

  frame current;
  current.sp = regs.get_stack_pointer();
  current.fp = regs.get_frame_pointer();

  if (current.sp != 0) {
    uint64_t ret_addr = 0;
    if (stack_capturer::read_stack_value(reader, current.sp, ret_addr)) {
      current.return_address = ret_addr;
    }

    current.frame_size = (current.fp > current.sp) ? (current.fp - current.sp) : 0;
    frames.push_back(current);
  }

  return frames;
}

} // namespace w1::util

```

`src/w1runtime/stack_capture.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <functional>
#include <vector>

#include "w1runtime/memory_reader.hpp"
#include "w1runtime/register_capture.hpp"

namespace w1::util {

struct stack_info {
  uint64_t stack_pointer = 0;
  uint64_t frame_pointer = 0;
  uint64_t return_address = 0;

  struct stack_entry {
    int64_t offset = 0;
    uint64_t value = 0;
    bool is_valid = false;
  };

  std::vector<stack_entry> values;
  size_t estimated_frame_size = 0;
  bool has_frame_pointer = false;
};

class stack_capturer {
public:
  struct capture_options {
    size_t num_values;
    int64_t start_offset;
    size_t value_spacing;
    bool analyze_frame;
    bool capture_args;

    constexpr capture_options(
        size_t num_values_value = 8, int64_t start_offset_value = -8, size_t value_spacing_value = 8,
        bool analyze_frame_value = true, bool capture_args_value = true
    )
        : num_values(num_values_value), start_offset(start_offset_value), value_spacing(value_spacing_value),
          analyze_frame(analyze_frame_value), capture_args(capture_args_value) {}
  };

  using memory_reader_fn = std::function<bool(uint64_t addr, void* buffer, size_t size)>;

  static stack_info capture(
      const memory_reader& memory, const register_state& regs, const capture_options& options = capture_options{}
  );

  static stack_info capture_with_reader(
      const register_state& regs, memory_reader_fn reader, const capture_options& options = capture_options{}
  );

  static bool read_stack_value(memory_reader_fn& reader, uint64_t addr, uint64_t& value);

private:
  static void analyze_x86_64_frame(stack_info& info, const register_state& regs, memory_reader_fn& reader);
  static void analyze_aarch64_frame(stack_info& info, const register_state& regs, memory_reader_fn& reader);
  static void analyze_arm32_frame(stack_info& info, const register_state& regs, memory_reader_fn& reader);
  static void analyze_x86_frame(stack_info& info, const register_state& regs, memory_reader_fn& reader);
};

class stack_walker {
public:
  struct frame {
    uint64_t sp = 0;
    uint64_t fp = 0;
    uint64_t return_address = 0;
    size_t frame_size = 0;
  };

  static std::vector<frame> walk(const memory_reader& memory, const register_state& regs, size_t max_frames = 32);
};

} // namespace w1::util

```

`src/w1runtime/thread_catalog.cpp`:

```cpp
#include "w1runtime/thread_catalog.hpp"

namespace w1::runtime {

void thread_catalog::apply(const w1::monitor::thread_event& event) {
  if (event.tid == 0) {
    return;
  }

  std::unique_lock lock(mutex_);
  auto& entry = threads_[event.tid];
  entry.tid = event.tid;

  switch (event.type) {
  case w1::monitor::thread_event::kind::started:
    entry.alive = true;
    break;
  case w1::monitor::thread_event::kind::stopped:
    entry.alive = false;
    break;
  case w1::monitor::thread_event::kind::renamed:
    entry.name = event.name;
    break;
  default:
    break;
  }
}

std::vector<thread_info> thread_catalog::list_threads() const {
  std::shared_lock lock(mutex_);
  std::vector<thread_info> result;
  result.reserve(threads_.size());
  for (const auto& [tid, info] : threads_) {
    result.push_back(info);
  }
  return result;
}

const thread_info* thread_catalog::find(uint64_t tid) const {
  std::shared_lock lock(mutex_);
  auto it = threads_.find(tid);
  if (it == threads_.end()) {
    return nullptr;
  }
  return &it->second;
}

} // namespace w1::runtime

```

`src/w1runtime/thread_catalog.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <mutex>
#include <shared_mutex>
#include <string>
#include <unordered_map>
#include <vector>

#include "w1monitor/thread_monitor.hpp"

namespace w1::runtime {

struct thread_info {
  uint64_t tid = 0;
  std::string name{};
  bool alive = false;
};

class thread_catalog {
public:
  void apply(const w1::monitor::thread_event& event);
  std::vector<thread_info> list_threads() const;
  const thread_info* find(uint64_t tid) const;

private:
  mutable std::shared_mutex mutex_{};
  std::unordered_map<uint64_t, thread_info> threads_{};
};

} // namespace w1::runtime

```

`src/w1tool/CMakeLists.txt`:

```txt
w1_dep_lief()

w1_add_executable(w1tool
    main.cpp
    commands/debug.cpp
    commands/inject.cpp
    commands/insert_library.cpp
    commands/inspect.cpp
    commands/cover.cpp
    commands/rewind.cpp
    commands/read_drcov.cpp
    commands/dump.cpp
    commands/read_dump.cpp
    commands/tracer.cpp
    tracer_discovery.cpp
)

target_link_libraries(w1tool PRIVATE
    w1base
    w1dump
    w1formats
    w1import
    w1nj3ct
    w1debugger
    w1::lief
)

install(TARGETS w1tool RUNTIME DESTINATION bin COMPONENT ${W1_INSTALL_COMPONENT})

```

`src/w1tool/commands/cover.cpp`:

```cpp
#include "cover.hpp"
#include "tracer.hpp"
#include "w1base/ext/args.hpp"
#include <cstdlib>
#include <filesystem>
#include <iostream>
#include <redlog.hpp>

// forward declare CLI symbols from main.cpp
namespace cli {
extern args::CounterFlag verbosity_flag;
}

namespace w1tool::commands {

int cover(
    args::ValueFlag<std::string>& library_flag, args::Flag& spawn_flag, args::ValueFlag<int>& pid_flag,
    args::ValueFlag<std::string>& name_flag, args::ValueFlag<std::string>& output_flag,
    args::ValueFlag<std::string>& system_policy_flag, args::Flag& inst_trace_flag,
    args::ValueFlagList<std::string>& config_flags, args::ValueFlag<std::string>& module_filter_flag,
    args::ValueFlag<int>& debug_level_flag, args::ValueFlag<std::string>& format_flag, args::Flag& suspended_flag,
    args::Flag& no_aslr_flag, args::PositionalList<std::string>& args_list, const std::string& executable_path
) {
  auto log = redlog::get_logger("w1tool.cover");

  // validate output format
  std::string format = "drcov"; // default
  if (format_flag) {
    format = args::get(format_flag);
    if (format != "drcov" && format != "text") {
      log.err("invalid format, supported: drcov, text", redlog::field("format", format));
      return 1;
    }
    if (format == "text") {
      log.warn("text format not yet implemented, using drcov format");
      format = "drcov";
    }
  }

  // build execution parameters
  tracer_execution_params params;
  params.tracer_name = "w1cov";
  params.executable_path = executable_path;

  if (library_flag) {
    params.library_path = args::get(library_flag);
  }

  // set debug level
  apply_debug_level(params, debug_level_flag, args::get(cli::verbosity_flag));

  // process config
  std::string config_error;
  if (!apply_config_flags(config_flags, params.config_map, &config_error)) {
    log.err("invalid config format, expected key=value", redlog::field("config", config_error));
    return 1;
  }

  // determine output file
  std::string output_file;
  if (output_flag) {
    output_file = args::get(output_flag);
  } else if (auto it = params.config_map.find("output"); it != params.config_map.end()) {
    output_file = it->second;
  } else {
    output_file = default_output_path(
        spawn_flag, args_list, std::string("_coverage.") + format, std::string("coverage.") + format
    );
  }

  // translate cover flags to w1cov config
  if (system_policy_flag) {
    params.config_map["system_policy"] = args::get(system_policy_flag);
  }
  if (inst_trace_flag) {
    params.config_map["mode"] = "instruction";
  } else if (params.config_map.find("mode") == params.config_map.end()) {
    params.config_map["mode"] = "basic_block";
  }
  params.config_map["output"] = output_file;

  if (module_filter_flag) {
    params.config_map["module_filter"] = args::get(module_filter_flag);
  }

  // set target
  std::string target_error;
  target_args target{spawn_flag, pid_flag, name_flag, suspended_flag, no_aslr_flag, args_list};
  if (!apply_target(params, target, &target_error)) {
    log.err(target_error);
    return 1;
  }

  std::string system_policy = "default";
  if (auto it = params.config_map.find("system_policy"); it != params.config_map.end()) {
    system_policy = it->second;
  }
  std::string mode = "basic_block";
  if (auto it = params.config_map.find("mode"); it != params.config_map.end()) {
    mode = it->second;
  }
  log.info(
      "coverage tracing configuration", redlog::field("output_file", output_file), redlog::field("format", format),
      redlog::field("system_policy", system_policy), redlog::field("mode", mode),
      redlog::field("debug_level", params.debug_level)
  );

  // execute w1cov tracing
  int result = execute_tracer_impl(params);

  // handle cover post-processing
  if (result == 0) {
    // check output file created
    if (!std::filesystem::exists(output_file)) {
      log.err("output file not created", redlog::field("output_file", output_file));
      return 1;
    }

    std::cout << "coverage tracing completed successfully.\n";
    std::cout << "output file: " << output_file << "\n";
    if (format == "drcov") {
      std::cout << "use 'w1tool read-drcov --file " << output_file << "' to analyze results.\n";
    }
  }

  return result;
}

} // namespace w1tool::commands

```

`src/w1tool/commands/cover.hpp`:

```hpp
#pragma once

#include "w1base/ext/args.hpp"

namespace w1tool::commands {

/**
 * cover command - performs coverage tracing with configurable options
 *
 * @param library_flag path to w1cov library (auto-detected if not specified)
 * @param spawn_flag spawn new process for tracing
 * @param pid_flag process id to attach to for runtime tracing
 * @param name_flag process name to attach to for runtime tracing
 * @param output_flag output file path for coverage data (optional)
 * @param system_policy_flag system module policy (exclude_all, include_critical, include_all) (optional)
 * @param config_flags configuration key=value pairs (optional)
 * @param module_filter_flag comma-separated list of modules to filter (optional)
 * @param debug_level_flag debug level override - defaults to passthrough verbosity (optional)
 * @param format_flag output format (drcov, text) (optional)
 * @param suspended_flag start process in suspended state (optional)
 * @param no_aslr_flag disable ASLR when launching process (optional)
 * @param args_list binary and arguments (use -- to separate w1tool args from target args)
 * @param executable_path path to the current executable (for auto-discovery)
 * @return exit code (0 for success, 1 for failure)
 */
int cover(
    args::ValueFlag<std::string>& library_flag, args::Flag& spawn_flag, args::ValueFlag<int>& pid_flag,
    args::ValueFlag<std::string>& name_flag, args::ValueFlag<std::string>& output_flag,
    args::ValueFlag<std::string>& system_policy_flag, args::Flag& inst_trace_flag,
    args::ValueFlagList<std::string>& config_flags, args::ValueFlag<std::string>& module_filter_flag,
    args::ValueFlag<int>& debug_level_flag, args::ValueFlag<std::string>& format_flag, args::Flag& suspended_flag,
    args::Flag& no_aslr_flag, args::PositionalList<std::string>& args_list, const std::string& executable_path
);

} // namespace w1tool::commands

```

`src/w1tool/commands/debug.cpp`:

```cpp
#include "debug.hpp"
#include <w1debugger/w1debugger.hpp>
#include <redlog.hpp>
#include <iostream>
#include <sstream>
#include <iomanip>

namespace w1tool::commands {

// interactive debugger commands
class interactive_debugger {
private:
  std::unique_ptr<w1::debugger::session> session;
  redlog::logger log;
  bool running = true;

public:
  interactive_debugger(std::unique_ptr<w1::debugger::session> sess)
      : session(std::move(sess)), log(redlog::get_logger("w1tool.debug.interactive")) {}

  void run() {
    log.info("entering interactive mode, type 'help' for commands");

    while (running && session) {
      std::cout << "w1dbg> " << std::flush;

      std::string line;
      if (!std::getline(std::cin, line)) {
        break;
      }

      if (line.empty()) {
        continue;
      }

      // parse command
      std::istringstream iss(line);
      std::string cmd;
      iss >> cmd;

      if (cmd == "help" || cmd == "h") {
        print_help();
      } else if (cmd == "quit" || cmd == "q") {
        handle_quit();
      } else if (cmd == "continue" || cmd == "c") {
        handle_continue();
      } else if (cmd == "threads" || cmd == "t") {
        handle_threads();
      } else if (cmd == "regs" || cmd == "printregs") {
        handle_printregs(iss);
      } else if (cmd == "read" || cmd == "r") {
        handle_read(iss);
      } else if (cmd == "write" || cmd == "w") {
        handle_write(iss);
      } else if (cmd == "step" || cmd == "s") {
        handle_step(iss);
      } else if (cmd == "info") {
        handle_info();
      } else {
        std::cout << "unknown command: " << cmd << "\n";
        std::cout << "type 'help' for available commands\n";
      }
    }
  }

private:
  void print_help() {
    std::cout << "available commands:\n";
    std::cout << "  help, h              - show this help\n";
    std::cout << "  quit, q              - detach and quit\n";
    std::cout << "  continue, c          - continue execution\n";
    std::cout << "  threads, t           - list threads\n";
    std::cout << "  regs, printregs [tid] - print registers (optional thread id)\n";
    std::cout << "  read <addr> <size>   - read memory\n";
    std::cout << "  write <addr> <hex>   - write memory\n";
    std::cout << "  step [tid]           - single step (optional thread id)\n";
    std::cout << "  info                 - show process info\n";
  }

  void handle_quit() {
    log.info("detaching from process");
    auto result = session->detach();
    if (!result.success()) {
      log.err("failed to detach", redlog::field("error", result.error_message));
    }
    running = false;
  }

  void handle_continue() {
    auto result = session->continue_execution();
    if (result.success()) {
      log.info("continued execution");
    } else {
      log.err("failed to continue", redlog::field("error", result.error_message));
    }
  }

  void handle_threads() {
    std::vector<w1::debugger::tid> threads;
    auto result = session->get_threads(threads);
    if (!result.success()) {
      log.err("failed to get threads", redlog::field("error", result.error_message));
      return;
    }
    std::cout << "threads (" << threads.size() << "):\n";
    for (const auto& tid : threads) {
      std::cout << "  tid: 0x" << std::hex << tid.native << std::dec << "\n";
    }
  }

  void handle_printregs(std::istringstream& args) {
    // optional thread id
    uint64_t tid_value = 0;
    if (args >> std::hex >> tid_value) {
      // specific thread
    } else {
      // use first thread
      std::vector<w1::debugger::tid> threads;
      auto result = session->get_threads(threads);
      if (!result.success() || threads.empty()) {
        log.err("no threads available");
        return;
      }
      tid_value = threads[0].native;
    }

    w1::debugger::tid tid{tid_value};
    w1::debugger::register_context regs;
    auto result = session->get_registers(tid, regs);
    if (!result.success()) {
      log.err("failed to get registers", redlog::field("error", result.error_message));
      return;
    }

    // print based on variant type
    std::visit(
        [](const auto& regs) {
          using T = std::decay_t<decltype(regs)>;
          if constexpr (std::is_same_v<T, w1::debugger::arm64_regs>) {
            std::cout << "arm64 registers:\n";
            for (int i = 0; i < 31; i++) {
              std::cout << "  x" << i << ": 0x" << std::hex << std::setw(16) << std::setfill('0') << regs.x[i] << "\n";
            }
            std::cout << "  sp: 0x" << std::hex << std::setw(16) << std::setfill('0') << regs.sp << "\n";
            std::cout << "  pc: 0x" << std::hex << std::setw(16) << std::setfill('0') << regs.pc << "\n";
            std::cout << "  pstate: 0x" << std::hex << regs.pstate << std::dec << "\n";
          } else if constexpr (std::is_same_v<T, w1::debugger::x64_regs>) {
            std::cout << "x64 registers:\n";
            std::cout << "  rax: 0x" << std::hex << std::setw(16) << std::setfill('0') << regs.rax << "\n";
            std::cout << "  rbx: 0x" << std::hex << std::setw(16) << std::setfill('0') << regs.rbx << "\n";
            std::cout << "  rcx: 0x" << std::hex << std::setw(16) << std::setfill('0') << regs.rcx << "\n";
            std::cout << "  rdx: 0x" << std::hex << std::setw(16) << std::setfill('0') << regs.rdx << "\n";
            std::cout << "  rsi: 0x" << std::hex << std::setw(16) << std::setfill('0') << regs.rsi << "\n";
            std::cout << "  rdi: 0x" << std::hex << std::setw(16) << std::setfill('0') << regs.rdi << "\n";
            std::cout << "  rbp: 0x" << std::hex << std::setw(16) << std::setfill('0') << regs.rbp << "\n";
            std::cout << "  rsp: 0x" << std::hex << std::setw(16) << std::setfill('0') << regs.rsp << "\n";
            std::cout << "  rip: 0x" << std::hex << std::setw(16) << std::setfill('0') << regs.rip << "\n";
            std::cout << std::dec;
          }
        },
        regs
    );
  }

  void handle_read(std::istringstream& args) {
    uint64_t addr;
    size_t size;

    if (!(args >> std::hex >> addr >> std::dec >> size)) {
      std::cout << "usage: read <hex_addr> <size>\n";
      return;
    }

    std::vector<uint8_t> data;
    auto result = session->read_memory(w1::debugger::addr{addr}, size, data);
    if (!result.success()) {
      log.err("failed to read memory", redlog::field("error", result.error_message));
      return;
    }
    std::cout << "memory at 0x" << std::hex << addr << ":\n";

    // hex dump format
    for (size_t i = 0; i < data.size(); i += 16) {
      std::cout << "  " << std::hex << std::setw(8) << std::setfill('0') << (addr + i) << ": ";

      // hex bytes
      for (size_t j = 0; j < 16 && i + j < data.size(); j++) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(data[i + j]) << " ";
      }

      // padding
      for (size_t j = data.size() - i; j < 16; j++) {
        std::cout << "   ";
      }

      std::cout << " ";

      // ascii representation
      for (size_t j = 0; j < 16 && i + j < data.size(); j++) {
        char c = static_cast<char>(data[i + j]);
        std::cout << (std::isprint(c) ? c : '.');
      }

      std::cout << "\n";
    }
    std::cout << std::dec;
  }

  void handle_write(std::istringstream& args) {
    uint64_t addr;
    std::string hex_data;

    if (!(args >> std::hex >> addr >> hex_data)) {
      std::cout << "usage: write <hex_addr> <hex_bytes>\n";
      std::cout << "example: write 0x100000000 deadbeef\n";
      return;
    }

    // parse hex string to bytes
    std::vector<uint8_t> bytes;
    for (size_t i = 0; i < hex_data.length(); i += 2) {
      std::string byte_str = hex_data.substr(i, 2);
      uint8_t byte = static_cast<uint8_t>(std::stoi(byte_str, nullptr, 16));
      bytes.push_back(byte);
    }

    auto result = session->write_memory(w1::debugger::addr{addr}, bytes);
    if (result.success()) {
      log.info("wrote memory", redlog::field("addr", addr), redlog::field("size", bytes.size()));
    } else {
      log.err("failed to write memory", redlog::field("error", result.error_message));
    }
  }

  void handle_step(std::istringstream& args) {
    // optional thread id
    uint64_t tid_value = 0;
    if (args >> std::hex >> tid_value) {
      // specific thread
    } else {
      // use first thread
      std::vector<w1::debugger::tid> threads;
      auto result = session->get_threads(threads);
      if (!result.success() || threads.empty()) {
        log.err("no threads available");
        return;
      }
      tid_value = threads[0].native;
    }

    w1::debugger::tid tid{tid_value};
    auto result = session->single_step(tid);
    if (result.success()) {
      log.info("single stepped thread", redlog::field("tid", tid_value));
    } else {
      log.err("failed to single step", redlog::field("error", result.error_message));
    }
  }

  void handle_info() {
    auto pid = session->get_pid();
    auto arch = session->get_arch();
    auto caps = session->get_capabilities();

    std::cout << "process info:\n";
    std::cout << "  pid: " << pid.native << "\n";
    std::cout << "  arch: ";
    switch (arch) {
    case w1::debugger::arch::x86:
      std::cout << "x86\n";
      break;
    case w1::debugger::arch::x86_64:
      std::cout << "x86_64\n";
      break;
    case w1::debugger::arch::arm64:
      std::cout << "arm64\n";
      break;
    }

    std::cout << "  capabilities:\n";
    std::cout << "    hardware breakpoints: " << (caps.hardware_breakpoints ? "yes" : "no") << "\n";
    std::cout << "    watchpoints: " << (caps.watchpoints ? "yes" : "no") << "\n";
    std::cout << "    remote allocation: " << (caps.remote_allocation ? "yes" : "no") << "\n";
    std::cout << "    thread suspension: " << (caps.thread_suspension ? "yes" : "no") << "\n";
    std::cout << "    single stepping: " << (caps.single_stepping ? "yes" : "no") << "\n";
  }
};

int debug(
    args::ValueFlag<int>& pid_flag, args::Flag& spawn_flag, args::Flag& interactive_flag, args::Flag& suspended_flag,
    args::PositionalList<std::string>& args_list
) {
  auto log = redlog::get_logger("w1tool.debug");

  // validate target specification
  int target_count = 0;
  if (spawn_flag) {
    target_count++;
  }
  if (pid_flag) {
    target_count++;
  }

  if (target_count != 1) {
    log.err("exactly one target required: specify --spawn or --pid");
    return 1;
  }

  // validate suspended flag usage
  if (suspended_flag && !spawn_flag) {
    log.err("--suspended can only be used with --spawn");
    return 1;
  }

  std::unique_ptr<w1::debugger::session> session;

  if (spawn_flag) {
    // launch target
    if (args_list.Get().empty()) {
      log.err("binary path required when using --spawn flag");
      return 1;
    }

    std::vector<std::string> all_args = args::get(args_list);
    std::string binary_path = all_args[0];

    // extract arguments after the binary
    std::vector<std::string> binary_args;
    if (all_args.size() > 1) {
      binary_args.assign(all_args.begin() + 1, all_args.end());
    }

    w1::debugger::config cfg;
    cfg.executable_path = binary_path;
    cfg.args = binary_args;
    cfg.start_suspended = suspended_flag;

    log.info(
        "launching target", redlog::field("binary", binary_path), redlog::field("args_count", binary_args.size()),
        redlog::field("suspended", suspended_flag ? "true" : "false")
    );

    w1::debugger::result result;
    session = w1::debugger::session::launch(binary_path, cfg, result);
    if (!result.success()) {
      log.err("failed to launch target", redlog::field("error", result.error_message));
      return 1;
    }
    log.info("launched successfully", redlog::field("pid", session->get_pid().native));

  } else if (pid_flag) {
    // attach to existing process
    int target_pid = args::get(pid_flag);

    w1::debugger::config cfg;
    log.info("attaching to process", redlog::field("pid", target_pid));

    w1::debugger::result result;
    session = w1::debugger::session::attach(w1::debugger::pid{target_pid}, cfg, result);
    if (!result.success()) {
      log.err("failed to attach", redlog::field("error", result.error_message));
      return 1;
    }
    log.info("attached successfully");
  }

  // run interactive mode if requested
  if (interactive_flag) {
    interactive_debugger debugger(std::move(session));
    debugger.run();
  } else {
    // non-interactive mode - just detach
    session->detach();
  }

  return 0;
}

} // namespace w1tool::commands

```

`src/w1tool/commands/debug.hpp`:

```hpp
#pragma once

#include "w1base/ext/args.hpp"

namespace w1tool::commands {

int debug(
    args::ValueFlag<int>& pid_flag, args::Flag& spawn_flag, args::Flag& interactive_flag, args::Flag& suspended_flag,
    args::PositionalList<std::string>& args_list
);

} // namespace w1tool::commands

```

`src/w1tool/commands/dump.cpp`:

```cpp
#include "dump.hpp"
#include "tracer.hpp"
#include "w1base/ext/args.hpp"
#include <cstdlib>
#include <filesystem>
#include <iostream>
#include <redlog.hpp>

// forward declare cli symbols from main.cpp
namespace cli {
extern args::CounterFlag verbosity_flag;
}

namespace w1tool::commands {

int dump(
    args::ValueFlag<std::string>& library_flag, args::Flag& spawn_flag, args::ValueFlag<int>& pid_flag,
    args::ValueFlag<std::string>& name_flag, args::ValueFlag<std::string>& output_flag, args::Flag& memory_flag,
    args::ValueFlagList<std::string>& config_flags, args::ValueFlagList<std::string>& filter_flag,
    args::ValueFlag<std::string>& max_region_size_flag, args::ValueFlag<int>& debug_level_flag,
    args::Flag& suspended_flag, args::Flag& no_aslr_flag, args::PositionalList<std::string>& args_list,
    const std::string& executable_path
) {
  auto log = redlog::get_logger("w1tool.dump");

  // build execution parameters
  tracer_execution_params params;
  params.tracer_name = "w1dump";
  params.executable_path = executable_path;

  if (library_flag) {
    params.library_path = args::get(library_flag);
  }

  std::string config_error;
  if (!apply_config_flags(config_flags, params.config_map, &config_error)) {
    log.err("invalid config format, expected key=value", redlog::field("config", config_error));
    return 1;
  }

  // determine output file
  std::string output_file;
  if (output_flag) {
    output_file = args::get(output_flag);
  } else if (auto it = params.config_map.find("output"); it != params.config_map.end()) {
    output_file = it->second;
  } else {
    output_file = default_output_path(spawn_flag, args_list, ".w1dump", "process.w1dump");
  }

  // set debug level
  apply_debug_level(params, debug_level_flag, args::get(cli::verbosity_flag));

  // translate dump flags to w1dump config
  params.config_map["output"] = output_file;
  if (memory_flag) {
    params.config_map["dump_memory_content"] = "true";
  } else if (params.config_map.find("dump_memory_content") == params.config_map.end()) {
    params.config_map["dump_memory_content"] = "false";
  }

  // parse and validate filters
  if (filter_flag) {
    std::vector<std::string> filter_strings = args::get(filter_flag);
    for (size_t i = 0; i < filter_strings.size(); i++) {
      // filters are passed as filter_0, filter_1, etc.
      params.config_map["filter_" + std::to_string(i)] = filter_strings[i];
    }
    params.config_map["filter_count"] = std::to_string(filter_strings.size());
  }

  // parse max region size
  if (max_region_size_flag) {
    std::string size_str = args::get(max_region_size_flag);
    params.config_map["max_region_size"] = size_str;
  }

  // dump on entry is always true for this command
  params.config_map["dump_on_entry"] = "true";

  // set target
  std::string target_error;
  target_args target{spawn_flag, pid_flag, name_flag, suspended_flag, no_aslr_flag, args_list};
  if (!apply_target(params, target, &target_error)) {
    log.err(target_error);
    return 1;
  }

  std::string dump_memory = "false";
  if (auto it = params.config_map.find("dump_memory_content"); it != params.config_map.end()) {
    dump_memory = it->second;
  }
  size_t filter_count = 0;
  if (auto it = params.config_map.find("filter_count"); it != params.config_map.end()) {
    try {
      filter_count = static_cast<size_t>(std::stoull(it->second));
    } catch (...) {
      filter_count = 0;
    }
  }
  log.info(
      "process dump configuration", redlog::field("output_file", output_file),
      redlog::field("dump_memory", dump_memory), redlog::field("filter_count", filter_count),
      redlog::field("debug_level", params.debug_level)
  );

  // execute w1dump tracing
  int result = execute_tracer_impl(params);

  // handle dump post-processing
  if (result == 0) {
    // check output file created
    if (!std::filesystem::exists(output_file)) {
      log.err("output file not created", redlog::field("output_file", output_file));
      return 1;
    }

    std::cout << "process dump completed successfully.\n";
    std::cout << "output file: " << output_file << "\n";
    std::cout << "use 'w1tool read-dump --file " << output_file << "' to analyze results.\n";
  }

  return result;
}

} // namespace w1tool::commands

```

`src/w1tool/commands/dump.hpp`:

```hpp
#pragma once

#include "w1base/ext/args.hpp"
#include <string>

namespace w1tool::commands {

int dump(
    args::ValueFlag<std::string>& library_flag, args::Flag& spawn_flag, args::ValueFlag<int>& pid_flag,
    args::ValueFlag<std::string>& name_flag, args::ValueFlag<std::string>& output_flag, args::Flag& memory_flag,
    args::ValueFlagList<std::string>& config_flags, args::ValueFlagList<std::string>& filter_flag,
    args::ValueFlag<std::string>& max_region_size_flag, args::ValueFlag<int>& debug_level_flag,
    args::Flag& suspended_flag, args::Flag& no_aslr_flag, args::PositionalList<std::string>& args_list,
    const std::string& executable_path
);

} // namespace w1tool::commands

```

`src/w1tool/commands/inject.cpp`:

```cpp
#include "inject.hpp"
#include <w1nj3ct/w1nj3ct.hpp>
#include <redlog.hpp>

namespace w1tool::commands {

int inject(
    args::ValueFlag<std::string>& library_flag, args::Flag& spawn_flag, args::ValueFlag<int>& pid_flag,
    args::ValueFlag<std::string>& process_name_flag, args::Flag& suspended_flag, args::Flag& no_aslr_flag,
    args::PositionalList<std::string>& args_list
) {

  auto log = redlog::get_logger("w1tool.inject");

  // validate required arguments
  if (!library_flag) {
    log.err("library path required");
    return 1;
  }

  // validate target specification
  int target_count = 0;
  if (spawn_flag) {
    target_count++;
  }
  if (pid_flag) {
    target_count++;
  }
  if (process_name_flag) {
    target_count++;
  }

  if (target_count != 1) {
    log.err("exactly one target required: specify -s/--spawn, --pid, or --process-name");
    return 1;
  }

  // validate suspended flag usage
  if (suspended_flag && !spawn_flag) {
    log.err("--suspended can only be used with -s/--spawn (launch injection)");
    return 1;
  }

  // validate no_aslr flag usage
  if (no_aslr_flag && !spawn_flag) {
    log.err("--no-aslr can only be used with -s/--spawn (launch injection)");
    return 1;
  }

  std::string lib_path = args::get(library_flag);
  w1::inject::result result;

  // determine injection method based on arguments
  if (spawn_flag) {
    // launch injection with positional arguments
    if (args_list.Get().empty()) {
      log.err("binary path required when using -s/--spawn flag");
      return 1;
    }

    std::vector<std::string> all_args = args::get(args_list);
    std::string binary_path = all_args[0];

    // extract arguments after the binary (everything after first arg)
    std::vector<std::string> binary_args;
    if (all_args.size() > 1) {
      binary_args.assign(all_args.begin() + 1, all_args.end());
    }

    // spawn always uses preload injection
    w1::inject::method injection_method = w1::inject::method::preload;
    std::string method_name = "preload";

    log.info(
        "spawn injection starting", redlog::field("method", method_name), redlog::field("binary", binary_path),
        redlog::field("library", lib_path), redlog::field("args_count", binary_args.size()),
        redlog::field("suspended", suspended_flag ? "true" : "false"),
        redlog::field("no_aslr", no_aslr_flag ? "true" : "false")
    );

    // use full config for spawn injection to support arguments and suspended flag
    w1::inject::config cfg;
    cfg.library_path = lib_path;
    cfg.injection_method = injection_method;
    cfg.binary_path = binary_path;
    cfg.args = binary_args;
    cfg.suspended = suspended_flag;
    cfg.disable_aslr = no_aslr_flag;
    cfg.wait_for_completion = true; // inject command should wait for completion

    result = w1::inject::inject(cfg);

  } else if (pid_flag) {
    // runtime injection by pid
    int target_pid = args::get(pid_flag);
    log.info(
        "runtime injection starting", redlog::field("method", "pid"), redlog::field("target_pid", target_pid),
        redlog::field("library", lib_path)
    );

    w1::inject::config cfg;
    cfg.library_path = lib_path;
    cfg.injection_method = w1::inject::method::runtime;
    cfg.pid = target_pid;

    result = w1::inject::inject(cfg);

  } else if (process_name_flag) {
    // runtime injection by process name
    std::string process_name = args::get(process_name_flag);
    log.info(
        "runtime injection starting", redlog::field("method", "name"), redlog::field("process_name", process_name),
        redlog::field("library", lib_path)
    );

    w1::inject::config cfg;
    cfg.library_path = lib_path;
    cfg.injection_method = w1::inject::method::runtime;
    cfg.process_name = process_name;

    result = w1::inject::inject(cfg);

  } else {
    log.err("target required: specify -s/--spawn, --pid, or --process-name");
    return 1;
  }

  // handle result
  if (result.success()) {
    if (result.target_pid > 0) {
      log.info("injection completed successfully", redlog::field("target_pid", result.target_pid));
    } else {
      log.info("injection completed successfully");
    }
    return 0;
  } else {
    log.err("injection failed", redlog::field("error", result.error_message));
    return 1;
  }
}

} // namespace w1tool::commands
```

`src/w1tool/commands/inject.hpp`:

```hpp
#pragma once

#include "w1base/ext/args.hpp"

namespace w1tool::commands {

/**
 * inject command - injects libraries into target processes with modern CLI
 *
 * @param library_flag path to injection library
 * @param spawn_flag spawn new process for injection (uses preload)
 * @param pid_flag target process ID (uses runtime injection)
 * @param process_name_flag target process name (uses runtime injection)
 * @param suspended_flag start process in suspended state (only with spawn)
 * @param no_aslr_flag disable ASLR when launching process (only with spawn)
 * @param args_list binary and arguments (use -- to separate w1tool args from target args)
 * @return exit code (0 for success, 1 for failure)
 */
int inject(
    args::ValueFlag<std::string>& library_flag, args::Flag& spawn_flag, args::ValueFlag<int>& pid_flag,
    args::ValueFlag<std::string>& process_name_flag, args::Flag& suspended_flag, args::Flag& no_aslr_flag,
    args::PositionalList<std::string>& args_list
);

} // namespace w1tool::commands
```

`src/w1tool/commands/insert_library.cpp`:

```cpp
#include "insert_library.hpp"
#include "w1import/import_insertion.hpp"
#include <redlog.hpp>

namespace w1tool::commands {

int insert_library(
    args::Positional<std::string>& dylib_path, args::Positional<std::string>& binary_path,
    args::Positional<std::string>& output_path, args::Flag& inplace, args::Flag& weak, args::Flag& overwrite,
    args::Flag& strip_codesig, args::Flag& all_yes, args::Flag& show_platforms
) {
  auto log = redlog::get_logger("w1tool.insert_library");

  // handle --show-platforms flag
  if (show_platforms) {
    std::cout << w1::import_insertion::get_platform_support_info() << std::endl;
    return 0;
  }

  // validate required arguments
  if (!dylib_path) {
    log.err("dylib_path is required");
    return 1;
  }

  if (!binary_path) {
    log.err("binary_path is required");
    return 1;
  }

  // validate inplace and output_path combination
  if (args::get(inplace) && output_path) {
    log.err("--inplace cannot be used with output_path");
    return 1;
  }

  std::string dylib_path_str = args::get(dylib_path);
  std::string binary_path_str = args::get(binary_path);

  // create configuration
  w1::import_insertion::config cfg;
  cfg.library_path = dylib_path_str;
  cfg.target_binary = binary_path_str;
  cfg.in_place = args::get(inplace);
  cfg.weak_import = args::get(weak);
  cfg.overwrite_existing = args::get(overwrite);
  cfg.strip_code_signature = args::get(strip_codesig);
  cfg.assume_yes = args::get(all_yes);

  if (output_path) {
    cfg.output_path = args::get(output_path);
  }

  log.info(
      "insert library starting", redlog::field("dylib_path", cfg.library_path),
      redlog::field("binary_path", cfg.target_binary), redlog::field("in_place", cfg.in_place),
      redlog::field("weak_import", cfg.weak_import), redlog::field("overwrite_existing", cfg.overwrite_existing),
      redlog::field("strip_code_signature", cfg.strip_code_signature), redlog::field("assume_yes", cfg.assume_yes)
  );

  if (output_path) {
    log.info("output path specified", redlog::field("output_path", args::get(output_path)));
  }

  // perform library import insertion
  auto result = w1::import_insertion::insert_library_import(cfg);

  // handle result
  if (result.success()) {
    log.info("library import insertion completed successfully");
    return 0;
  } else {
    log.err(
        "library import insertion failed",
        redlog::field("error_code", w1::import_insertion::error_code_to_string(result.code)),
        redlog::field("error_message", result.error_message)
    );

    if (result.system_error_code.has_value()) {
      log.err("system error code", redlog::field("code", *result.system_error_code));
    }

    return 1;
  }
}

} // namespace w1tool::commands

```

`src/w1tool/commands/insert_library.hpp`:

```hpp
#pragma once

#include "w1base/ext/args.hpp"

namespace w1tool::commands {

int insert_library(
    args::Positional<std::string>& dylib_path, args::Positional<std::string>& binary_path,
    args::Positional<std::string>& output_path, args::Flag& inplace, args::Flag& weak, args::Flag& overwrite,
    args::Flag& strip_codesig, args::Flag& all_yes, args::Flag& show_platforms
);

} // namespace w1tool::commands
```

`src/w1tool/commands/inspect.cpp`:

```cpp
#include "inspect.hpp"

#include <redlog.hpp>
#include <algorithm>
#include <cctype>
#include <filesystem>
#include <iomanip>
#include <iostream>
#include <optional>
#include <sstream>
#include <vector>

#include "w1base/uuid_format.hpp"

#ifdef WITNESS_LIEF_ENABLED
#include <LIEF/LIEF.hpp>
#include <LIEF/ELF/DynamicEntryRpath.hpp>
#include <LIEF/ELF/DynamicEntryRunPath.hpp>
#include <LIEF/ELF/DynamicSharedObject.hpp>
#include <LIEF/ELF/Parser.hpp>
#include <LIEF/ELF/Relocation.hpp>
#include <LIEF/MachO/BuildVersion.hpp>
#include <LIEF/MachO/DylinkerCommand.hpp>
#include <LIEF/MachO/Parser.hpp>
#include <LIEF/MachO/RPathCommand.hpp>
#include <LIEF/MachO/Relocation.hpp>
#include <LIEF/MachO/UUIDCommand.hpp>
#include <LIEF/PE/Parser.hpp>
#include <LIEF/PE/RelocationEntry.hpp>
#include <nlohmann/json.hpp>
#endif

namespace fs = std::filesystem;

namespace w1tool::commands {

#ifndef WITNESS_LIEF_ENABLED

int inspect(const inspect_request&) {
  auto log = redlog::get_logger("w1tool.inspect");
  log.error("binary inspection requires LIEF support");
  log.error("build with -DWITNESS_LIEF=ON to enable this feature");
  return 1;
}

#else

namespace detail {

struct summary_info {
  std::string path;
  std::string format;
  std::string architecture;
  std::string bitness;
  std::string endianness;
  std::string file_type;
  uint64_t entrypoint = 0;
  bool has_entrypoint = false;
  uint64_t imagebase = 0;
  bool has_imagebase = false;
  uint64_t file_size = 0;
  size_t sections = 0;
  size_t segments = 0;
  bool segments_supported = true;
  size_t imports = 0;
  size_t exports = 0;
  size_t symbols = 0;
  size_t relocations = 0;
  size_t libraries = 0;
};

struct elf_header_info {
  std::string os_abi;
  uint32_t abi_version = 0;
  std::string class_type;
  std::string data_encoding;
  std::string machine;
  std::string interpreter;
  std::string soname;
  std::string rpath;
  std::string runpath;
  std::string build_id;
};

struct pe_header_info {
  std::string machine;
  std::string subsystem;
  uint32_t timestamp = 0;
  uint8_t linker_major = 0;
  uint8_t linker_minor = 0;
  uint64_t imagebase = 0;
  uint32_t entrypoint_rva = 0;
  uint64_t entrypoint = 0;
  uint32_t section_alignment = 0;
  uint32_t file_alignment = 0;
  std::vector<std::string> dll_characteristics;
};

struct macho_header_info {
  std::string cpu_type;
  uint32_t cpu_subtype = 0;
  std::string file_type;
  std::vector<std::string> flags;
  uint32_t load_commands = 0;
  std::string uuid;
  std::string build_platform;
  std::string build_minos;
  std::string build_sdk;
  std::string dylinker;
  std::vector<std::string> rpaths;
};

struct section_info {
  std::string name;
  uint64_t address = 0;
  uint64_t size = 0;
  uint64_t offset = 0;
  std::string perms;
  std::string kind;
};

struct segment_info {
  std::string name;
  uint64_t address = 0;
  uint64_t vsize = 0;
  uint64_t offset = 0;
  uint64_t fsize = 0;
  std::string perms;
  std::string kind;
};

struct symbol_info {
  std::string name;
  uint64_t address = 0;
  uint64_t size = 0;
};

struct function_info {
  std::string name;
  uint64_t address = 0;
};

struct relocation_info {
  uint64_t address = 0;
  size_t size = 0;
  std::string type;
  std::string symbol;
  std::string origin;
};

struct inspect_report {
  summary_info summary;
  std::vector<section_info> sections;
  std::vector<segment_info> segments;
  std::vector<symbol_info> symbols;
  std::vector<function_info> imports;
  std::vector<function_info> exports;
  std::vector<relocation_info> relocations;
  std::vector<std::string> libraries;
  std::optional<elf_header_info> elf_header;
  std::optional<pe_header_info> pe_header;
  std::optional<macho_header_info> macho_header;
};

std::string to_lower(std::string value) {
  std::transform(value.begin(), value.end(), value.begin(), [](unsigned char c) {
    return static_cast<char>(std::tolower(c));
  });
  return value;
}

std::string format_address(uint64_t addr) {
  std::ostringstream out;
  out << "0x" << std::hex << addr;
  return out.str();
}

std::string format_bytes(uint64_t bytes) {
  if (bytes >= 1024ULL * 1024 * 1024) {
    double gb = static_cast<double>(bytes) / (1024.0 * 1024.0 * 1024.0);
    std::ostringstream out;
    out << std::fixed << std::setprecision(1) << gb << " GB";
    return out.str();
  }
  if (bytes >= 1024ULL * 1024) {
    double mb = static_cast<double>(bytes) / (1024.0 * 1024.0);
    std::ostringstream out;
    out << std::fixed << std::setprecision(1) << mb << " MB";
    return out.str();
  }
  if (bytes >= 1024ULL) {
    double kb = static_cast<double>(bytes) / 1024.0;
    std::ostringstream out;
    out << std::fixed << std::setprecision(1) << kb << " KB";
    return out.str();
  }
  return std::to_string(bytes) + " B";
}

std::string format_permissions(bool read, bool write, bool exec) {
  std::string perms = "---";
  if (read) {
    perms[0] = 'r';
  }
  if (write) {
    perms[1] = 'w';
  }
  if (exec) {
    perms[2] = 'x';
  }
  return perms;
}

std::string format_version(const LIEF::MachO::BuildVersion::version_t& version) {
  std::ostringstream out;
  out << version[0] << "." << version[1] << "." << version[2];
  return out.str();
}

std::string format_build_id(LIEF::span<const uint8_t> bytes) {
  std::ostringstream out;
  out << std::hex << std::setfill('0');
  for (uint8_t byte : bytes) {
    out << std::setw(2) << static_cast<int>(byte);
  }
  return out.str();
}

std::string macho_endianness(const LIEF::MachO::Header& header) {
  using LIEF::MachO::MACHO_TYPES;
  auto magic = header.magic();
  if (magic == MACHO_TYPES::MAGIC || magic == MACHO_TYPES::MAGIC_64 || magic == MACHO_TYPES::MAGIC_FAT) {
    return "big-endian";
  }
  if (magic == MACHO_TYPES::CIGAM || magic == MACHO_TYPES::CIGAM_64 || magic == MACHO_TYPES::CIGAM_FAT) {
    return "little-endian";
  }
  return "unknown";
}

std::unique_ptr<LIEF::Binary> parse_binary(const inspect_request& request, redlog::logger& log) {
  if (request.forced_format.empty()) {
    return LIEF::Parser::parse(request.binary_path);
  }

  std::string format = to_lower(request.forced_format);
  if (format == "elf") {
    return LIEF::ELF::Parser::parse(request.binary_path);
  }
  if (format == "pe") {
    return LIEF::PE::Parser::parse(request.binary_path);
  }
  if (format == "macho" || format == "mach-o" || format == "mach") {
    auto fat = LIEF::MachO::Parser::parse(request.binary_path);
    if (!fat || fat->empty()) {
      return nullptr;
    }
    return fat->take(fat->size() - 1);
  }

  log.error("unsupported format override", redlog::field("format", request.forced_format));
  return nullptr;
}

std::string format_name_or_placeholder(const std::string& name) { return name.empty() ? "-" : name; }

inspect_report build_report(const inspect_request& request, LIEF::Binary& binary) {
  inspect_report report;

  report.summary.path = request.binary_path;
  report.summary.file_size = fs::file_size(request.binary_path);

  switch (binary.format()) {
  case LIEF::Binary::FORMATS::ELF:
    report.summary.format = "ELF";
    break;
  case LIEF::Binary::FORMATS::PE:
    report.summary.format = "PE";
    break;
  case LIEF::Binary::FORMATS::MACHO:
    report.summary.format = "Mach-O";
    break;
  default:
    report.summary.format = "Unknown";
    break;
  }

  for (const auto& section : binary.sections()) {
    report.summary.sections++;
    if (request.show_sections) {
      section_info info;
      info.name = section.name();
      info.address = section.virtual_address();
      info.size = section.size();
      info.offset = section.offset();
      info.perms = "---";
      info.kind = "";

      if (auto elf_section = dynamic_cast<const LIEF::ELF::Section*>(&section)) {
        bool read = elf_section->has(LIEF::ELF::Section::FLAGS::ALLOC);
        bool write = elf_section->has(LIEF::ELF::Section::FLAGS::WRITE);
        bool exec = elf_section->has(LIEF::ELF::Section::FLAGS::EXECINSTR);
        info.perms = format_permissions(read, write, exec);
        info.kind = LIEF::ELF::to_string(elf_section->type());
      } else if (auto pe_section = dynamic_cast<const LIEF::PE::Section*>(&section)) {
        bool read = pe_section->has_characteristic(LIEF::PE::Section::CHARACTERISTICS::MEM_READ);
        bool write = pe_section->has_characteristic(LIEF::PE::Section::CHARACTERISTICS::MEM_WRITE);
        bool exec = pe_section->has_characteristic(LIEF::PE::Section::CHARACTERISTICS::MEM_EXECUTE);
        info.perms = format_permissions(read, write, exec);
        if (pe_section->has_characteristic(LIEF::PE::Section::CHARACTERISTICS::CNT_CODE)) {
          info.kind = "CODE";
        } else if (pe_section->has_characteristic(LIEF::PE::Section::CHARACTERISTICS::CNT_INITIALIZED_DATA)) {
          info.kind = "DATA";
        } else if (pe_section->has_characteristic(LIEF::PE::Section::CHARACTERISTICS::CNT_UNINITIALIZED_DATA)) {
          info.kind = "BSS";
        } else {
          info.kind = "OTHER";
        }
      } else if (auto macho_section = dynamic_cast<const LIEF::MachO::Section*>(&section)) {
        bool read = false;
        bool write = false;
        bool exec = false;
        if (macho_section->has_segment()) {
          const auto* segment = macho_section->segment();
          if (segment != nullptr) {
            uint32_t init = segment->init_protection();
            read = (init & static_cast<uint32_t>(LIEF::MachO::SegmentCommand::VM_PROTECTIONS::READ)) != 0;
            write = (init & static_cast<uint32_t>(LIEF::MachO::SegmentCommand::VM_PROTECTIONS::WRITE)) != 0;
            exec = (init & static_cast<uint32_t>(LIEF::MachO::SegmentCommand::VM_PROTECTIONS::EXECUTE)) != 0;
          }
        }
        info.perms = format_permissions(read, write, exec);
        info.kind = LIEF::MachO::to_string(macho_section->type());
      }

      report.sections.push_back(std::move(info));
    }
  }

  for (const auto& symbol : binary.symbols()) {
    report.summary.symbols++;
    if (request.show_symbols) {
      symbol_info info;
      info.name = symbol.name();
      info.address = symbol.value();
      info.size = symbol.size();
      report.symbols.push_back(std::move(info));
    }
  }

  auto imported_functions = binary.imported_functions();
  auto exported_functions = binary.exported_functions();
  auto imported_libraries = binary.imported_libraries();

  report.summary.imports = imported_functions.size();
  report.summary.exports = exported_functions.size();
  report.summary.libraries = imported_libraries.size();

  if (request.show_imports) {
    for (const auto& func : imported_functions) {
      function_info info;
      info.name = func.name();
      info.address = func.address();
      report.imports.push_back(std::move(info));
    }
  }

  if (request.show_exports) {
    for (const auto& func : exported_functions) {
      function_info info;
      info.name = func.name();
      info.address = func.address();
      report.exports.push_back(std::move(info));
    }
  }

  if (request.show_libraries) {
    report.libraries = imported_libraries;
  }

  size_t relocation_count = 0;
  for (const auto& reloc : binary.relocations()) {
    relocation_count++;
    if (request.show_relocations) {
      relocation_info info;
      info.address = reloc.address();
      info.size = reloc.size();

      if (auto elf_reloc = dynamic_cast<const LIEF::ELF::Relocation*>(&reloc)) {
        info.type = LIEF::ELF::to_string(elf_reloc->type());
        if (elf_reloc->has_symbol() && elf_reloc->symbol() != nullptr) {
          info.symbol = elf_reloc->symbol()->name();
        }
      } else if (auto pe_reloc = dynamic_cast<const LIEF::PE::RelocationEntry*>(&reloc)) {
        info.type = LIEF::PE::to_string(pe_reloc->type());
      } else if (auto macho_reloc = dynamic_cast<const LIEF::MachO::Relocation*>(&reloc)) {
        info.type = std::to_string(macho_reloc->type());
        info.origin = LIEF::MachO::to_string(macho_reloc->origin());
        if (macho_reloc->has_symbol() && macho_reloc->symbol() != nullptr) {
          info.symbol = macho_reloc->symbol()->name();
        }
      }

      report.relocations.push_back(std::move(info));
    }
  }
  report.summary.relocations = relocation_count;

  if (binary.format() == LIEF::Binary::FORMATS::ELF) {
    const auto& elf = static_cast<const LIEF::ELF::Binary&>(binary);
    const auto& header = elf.header();

    report.summary.architecture = LIEF::ELF::to_string(header.machine_type());
    report.summary.bitness = header.identity_class() == LIEF::ELF::Header::CLASS::ELF64 ? "64-bit" : "32-bit";
    report.summary.endianness =
        header.identity_data() == LIEF::ELF::Header::ELF_DATA::LSB ? "little-endian" : "big-endian";
    report.summary.file_type = LIEF::ELF::to_string(header.file_type());
    report.summary.entrypoint = elf.entrypoint();
    report.summary.has_entrypoint = true;
    report.summary.imagebase = elf.imagebase();
    report.summary.has_imagebase = report.summary.imagebase != 0;

    if (request.show_segments) {
      for (const auto& segment : elf.segments()) {
        report.summary.segments++;
        segment_info info;
        info.name = LIEF::ELF::to_string(segment.type());
        info.address = segment.virtual_address();
        info.vsize = segment.virtual_size();
        info.offset = segment.file_offset();
        info.fsize = segment.physical_size();
        bool read = segment.has(LIEF::ELF::Segment::FLAGS::R);
        bool write = segment.has(LIEF::ELF::Segment::FLAGS::W);
        bool exec = segment.has(LIEF::ELF::Segment::FLAGS::X);
        info.perms = format_permissions(read, write, exec);
        info.kind = "ELF";
        report.segments.push_back(std::move(info));
      }
    } else {
      for (const auto& segment : elf.segments()) {
        report.summary.segments++;
        (void) segment;
      }
    }

    if (request.show_headers) {
      elf_header_info header_info;
      header_info.os_abi = LIEF::ELF::to_string(header.identity_os_abi());
      header_info.abi_version = header.identity_abi_version();
      header_info.class_type = LIEF::ELF::to_string(header.identity_class());
      header_info.data_encoding = LIEF::ELF::to_string(header.identity_data());
      header_info.machine = LIEF::ELF::to_string(header.machine_type());
      if (elf.has_interpreter()) {
        header_info.interpreter = elf.interpreter();
      }
      if (elf.has(LIEF::ELF::DynamicEntry::TAG::SONAME)) {
        if (const auto* soname =
                dynamic_cast<const LIEF::ELF::DynamicSharedObject*>(elf.get(LIEF::ELF::DynamicEntry::TAG::SONAME))) {
          header_info.soname = soname->name();
        }
      }
      if (elf.has(LIEF::ELF::DynamicEntry::TAG::RPATH)) {
        if (const auto* rpath =
                dynamic_cast<const LIEF::ELF::DynamicEntryRpath*>(elf.get(LIEF::ELF::DynamicEntry::TAG::RPATH))) {
          header_info.rpath = rpath->rpath();
        }
      }
      if (elf.has(LIEF::ELF::DynamicEntry::TAG::RUNPATH)) {
        if (const auto* runpath =
                dynamic_cast<const LIEF::ELF::DynamicEntryRunPath*>(elf.get(LIEF::ELF::DynamicEntry::TAG::RUNPATH))) {
          header_info.runpath = runpath->runpath();
        }
      }
      if (elf.has_notes()) {
        for (const auto& note : elf.notes()) {
          if (note.type() == LIEF::ELF::Note::TYPE::GNU_BUILD_ID) {
            header_info.build_id = format_build_id(note.description());
            break;
          }
        }
      }

      report.elf_header = header_info;
    }
  } else if (binary.format() == LIEF::Binary::FORMATS::PE) {
    const auto& pe = static_cast<const LIEF::PE::Binary&>(binary);
    const auto& header = pe.header();
    const auto& optional = pe.optional_header();

    report.summary.architecture = LIEF::PE::to_string(header.machine());
    report.summary.bitness = pe.type() == LIEF::PE::PE_TYPE::PE32_PLUS ? "64-bit" : "32-bit";
    report.summary.endianness = "little-endian";
    report.summary.file_type = header.has_characteristic(LIEF::PE::Header::CHARACTERISTICS::DLL) ? "DLL" : "Executable";
    report.summary.entrypoint = pe.entrypoint();
    report.summary.has_entrypoint = optional.addressof_entrypoint() != 0;
    report.summary.imagebase = pe.imagebase();
    report.summary.has_imagebase = report.summary.imagebase != 0;
    report.summary.segments_supported = false;

    if (request.show_headers) {
      pe_header_info header_info;
      header_info.machine = LIEF::PE::to_string(header.machine());
      header_info.subsystem = LIEF::PE::to_string(optional.subsystem());
      header_info.timestamp = header.time_date_stamp();
      header_info.linker_major = optional.major_linker_version();
      header_info.linker_minor = optional.minor_linker_version();
      header_info.imagebase = optional.imagebase();
      header_info.entrypoint_rva = optional.addressof_entrypoint();
      header_info.entrypoint = pe.entrypoint();
      header_info.section_alignment = optional.section_alignment();
      header_info.file_alignment = optional.file_alignment();
      for (auto flag : optional.dll_characteristics_list()) {
        header_info.dll_characteristics.emplace_back(LIEF::PE::to_string(flag));
      }
      report.pe_header = header_info;
    }
  } else if (binary.format() == LIEF::Binary::FORMATS::MACHO) {
    const auto& macho = static_cast<const LIEF::MachO::Binary&>(binary);
    const auto& header = macho.header();

    report.summary.architecture = LIEF::MachO::to_string(header.cpu_type());
    report.summary.bitness = header.is_64bit() ? "64-bit" : "32-bit";
    report.summary.endianness = macho_endianness(header);
    report.summary.file_type = LIEF::MachO::to_string(header.file_type());
    report.summary.entrypoint = macho.entrypoint();
    report.summary.has_entrypoint = macho.has_entrypoint();
    report.summary.imagebase = macho.imagebase();
    report.summary.has_imagebase = report.summary.imagebase != 0;

    if (request.show_segments) {
      for (const auto& segment : macho.segments()) {
        report.summary.segments++;
        segment_info info;
        info.name = segment.name();
        info.address = segment.virtual_address();
        info.vsize = segment.virtual_size();
        info.offset = segment.file_offset();
        info.fsize = segment.file_size();
        bool read =
            (segment.init_protection() & static_cast<uint32_t>(LIEF::MachO::SegmentCommand::VM_PROTECTIONS::READ)) != 0;
        bool write = (segment.init_protection() &
                      static_cast<uint32_t>(LIEF::MachO::SegmentCommand::VM_PROTECTIONS::WRITE)) != 0;
        bool exec = (segment.init_protection() &
                     static_cast<uint32_t>(LIEF::MachO::SegmentCommand::VM_PROTECTIONS::EXECUTE)) != 0;
        info.perms = format_permissions(read, write, exec);
        info.kind = "Mach-O";
        report.segments.push_back(std::move(info));
      }
    } else {
      for (const auto& segment : macho.segments()) {
        report.summary.segments++;
        (void) segment;
      }
    }

    if (request.show_headers) {
      macho_header_info header_info;
      header_info.cpu_type = LIEF::MachO::to_string(header.cpu_type());
      header_info.cpu_subtype = header.cpu_subtype();
      header_info.file_type = LIEF::MachO::to_string(header.file_type());
      header_info.load_commands = header.nb_cmds();
      for (auto flag : header.flags_list()) {
        header_info.flags.emplace_back(LIEF::MachO::to_string(flag));
      }
      if (macho.has_uuid()) {
        if (const auto* uuid = macho.uuid()) {
          header_info.uuid = w1::util::format_uuid(uuid->uuid());
        }
      }
      if (macho.has_build_version()) {
        if (const auto* build = macho.build_version()) {
          header_info.build_platform = LIEF::MachO::to_string(build->platform());
          header_info.build_minos = format_version(build->minos());
          header_info.build_sdk = format_version(build->sdk());
        }
      }
      if (macho.has_dylinker()) {
        if (const auto* dylinker = macho.dylinker()) {
          header_info.dylinker = dylinker->name();
        }
      }
      if (macho.has_rpath()) {
        for (const auto& rpath : macho.rpaths()) {
          header_info.rpaths.push_back(rpath.path());
        }
      }
      report.macho_header = header_info;
    }
  }

  return report;
}

namespace {
constexpr const char* kIndent = "  ";
constexpr const char* kSubIndent = "    ";

void print_section_title(const std::string& title) { std::cout << title << ":\n"; }

template <typename T> void print_kv(const std::string& key, const T& value, const char* indent = kIndent) {
  std::cout << indent << key << "=" << value << "\n";
}

void print_line(const std::string& line, const char* indent = kIndent) { std::cout << indent << line << "\n"; }

std::string join_csv(const std::vector<std::string>& items) {
  std::ostringstream out;
  for (size_t i = 0; i < items.size(); ++i) {
    if (i != 0) {
      out << ", ";
    }
    out << items[i];
  }
  return out.str();
}
} // namespace

void render_summary(const summary_info& summary) {
  print_section_title("binary");
  print_kv("path", summary.path);
  print_kv("format", summary.format);

  std::ostringstream arch_line;
  arch_line << "arch=" << summary.architecture << " bitness=" << summary.bitness << " endianness=" << summary.endianness
            << " type=" << summary.file_type;
  print_line(arch_line.str());

  std::ostringstream entry_line;
  entry_line << "entry=" << (summary.has_entrypoint ? format_address(summary.entrypoint) : "n/a")
             << " image_base=" << (summary.has_imagebase ? format_address(summary.imagebase) : "n/a");
  print_line(entry_line.str());

  std::ostringstream stats_line;
  stats_line << "size=" << format_bytes(summary.file_size) << " sections=" << summary.sections << " segments=";
  if (summary.segments_supported) {
    stats_line << summary.segments;
  } else {
    stats_line << "n/a";
  }
  stats_line << " imports=" << summary.imports << " exports=" << summary.exports << " symbols=" << summary.symbols
             << " relocs=" << summary.relocations << " libraries=" << summary.libraries;
  print_line(stats_line.str());
  std::cout << "\n";
}

void render_headers(const inspect_report& report) {
  print_section_title("headers");
  bool wrote_any = false;
  if (report.elf_header) {
    wrote_any = true;
    const auto& info = *report.elf_header;
    std::ostringstream base;
    base << "elf: os_abi=" << info.os_abi << " abi_version=" << info.abi_version << " class=" << info.class_type
         << " data=" << info.data_encoding << " machine=" << info.machine;
    print_line(base.str());
    if (!info.interpreter.empty()) {
      print_kv("interpreter", info.interpreter);
    }
    if (!info.soname.empty()) {
      print_kv("soname", info.soname);
    }
    if (!info.rpath.empty()) {
      print_kv("rpath", info.rpath);
    }
    if (!info.runpath.empty()) {
      print_kv("runpath", info.runpath);
    }
    if (!info.build_id.empty()) {
      print_kv("build_id", info.build_id);
    }
  } else if (report.pe_header) {
    wrote_any = true;
    const auto& info = *report.pe_header;
    std::ostringstream base;
    base << "pe: machine=" << info.machine << " subsystem=" << info.subsystem << " timestamp=" << info.timestamp;
    print_line(base.str());
    std::ostringstream entry_line;
    entry_line << "image_base=" << format_address(info.imagebase)
               << " entry_rva=" << format_address(info.entrypoint_rva)
               << " entry_va=" << format_address(info.entrypoint);
    print_line(entry_line.str());
    std::ostringstream align_line;
    align_line << "align_section=" << info.section_alignment << " align_file=" << info.file_alignment
               << " linker=" << static_cast<int>(info.linker_major) << "." << static_cast<int>(info.linker_minor);
    print_line(align_line.str());
    if (!info.dll_characteristics.empty()) {
      print_kv("dll_chars", join_csv(info.dll_characteristics));
    }
  } else if (report.macho_header) {
    wrote_any = true;
    const auto& info = *report.macho_header;
    std::ostringstream base;
    base << "macho: cpu=" << info.cpu_type << " subtype=" << info.cpu_subtype << " file_type=" << info.file_type
         << " load_cmds=" << info.load_commands;
    print_line(base.str());
    if (!info.flags.empty()) {
      print_kv("flags", join_csv(info.flags));
    }
    if (!info.uuid.empty()) {
      print_kv("uuid", info.uuid);
    }
    if (!info.build_platform.empty()) {
      print_kv("build_platform", info.build_platform);
    }
    if (!info.build_minos.empty()) {
      print_kv("build_minos", info.build_minos);
    }
    if (!info.build_sdk.empty()) {
      print_kv("build_sdk", info.build_sdk);
    }
    if (!info.dylinker.empty()) {
      print_kv("dylinker", info.dylinker);
    }
    if (!info.rpaths.empty()) {
      print_line("rpaths:");
      for (const auto& rpath : info.rpaths) {
        print_line(rpath, kSubIndent);
      }
    }
  }
  if (!wrote_any) {
    print_line("none");
  }
  std::cout << "\n";
}

void render_sections(const std::vector<section_info>& sections) {
  print_section_title("sections");
  if (sections.empty()) {
    print_line("none");
    std::cout << "\n";
    return;
  }
  print_line("name vaddr size offset perm type");
  for (const auto& section : sections) {
    std::cout << kIndent << std::left << std::setw(24) << format_name_or_placeholder(section.name) << std::setw(18)
              << format_address(section.address) << std::setw(12) << format_bytes(section.size) << std::setw(12)
              << format_address(section.offset) << std::setw(6) << section.perms << section.kind << "\n";
  }
  std::cout << "\n";
}

void render_segments(const inspect_report& report) {
  print_section_title("segments");
  if (!report.summary.segments_supported) {
    print_kv("status", "unsupported");
    std::cout << "\n";
    return;
  }
  if (report.segments.empty()) {
    print_line("none");
    std::cout << "\n";
    return;
  }
  print_line("name vaddr vsize offset fsize perm kind");
  for (const auto& segment : report.segments) {
    std::cout << kIndent << std::left << std::setw(18) << format_name_or_placeholder(segment.name) << std::setw(18)
              << format_address(segment.address) << std::setw(12) << format_bytes(segment.vsize) << std::setw(12)
              << format_address(segment.offset) << std::setw(12) << format_bytes(segment.fsize) << std::setw(6)
              << segment.perms << segment.kind << "\n";
  }
  std::cout << "\n";
}

void render_libraries(const std::vector<std::string>& libraries) {
  print_section_title("libraries");
  if (libraries.empty()) {
    print_line("none");
    std::cout << "\n";
    return;
  }
  for (const auto& lib : libraries) {
    print_line(lib);
  }
  std::cout << "\n";
}

void render_functions(const std::vector<function_info>& functions, const std::string& title) {
  print_section_title(title);
  if (functions.empty()) {
    print_line("none");
    std::cout << "\n";
    return;
  }
  print_line("address name");
  for (const auto& func : functions) {
    std::cout << kIndent << std::left << std::setw(18) << format_address(func.address)
              << format_name_or_placeholder(func.name) << "\n";
  }
  std::cout << "\n";
}

void render_symbols(const std::vector<symbol_info>& symbols) {
  print_section_title("symbols");
  if (symbols.empty()) {
    print_line("none");
    std::cout << "\n";
    return;
  }
  print_line("address size name");
  for (const auto& symbol : symbols) {
    std::cout << kIndent << std::left << std::setw(18) << format_address(symbol.address) << std::setw(12)
              << format_bytes(symbol.size) << format_name_or_placeholder(symbol.name) << "\n";
  }
  std::cout << "\n";
}

void render_relocations(const std::vector<relocation_info>& relocations) {
  print_section_title("relocations");
  if (relocations.empty()) {
    print_line("none");
    std::cout << "\n";
    return;
  }
  print_line("address size type symbol origin");
  for (const auto& reloc : relocations) {
    std::cout << kIndent << std::left << std::setw(18) << format_address(reloc.address) << std::setw(8) << reloc.size
              << std::setw(18) << reloc.type << std::setw(24) << format_name_or_placeholder(reloc.symbol)
              << reloc.origin << "\n";
  }
  std::cout << "\n";
}

void render_text(const inspect_report& report, const inspect_request& request) {
  render_summary(report.summary);

  if (request.show_headers) {
    render_headers(report);
  }
  if (request.show_sections) {
    render_sections(report.sections);
  }
  if (request.show_segments) {
    render_segments(report);
  }
  if (request.show_libraries) {
    render_libraries(report.libraries);
  }
  if (request.show_imports) {
    render_functions(report.imports, "imports");
  }
  if (request.show_exports) {
    render_functions(report.exports, "exports");
  }
  if (request.show_symbols) {
    render_symbols(report.symbols);
  }
  if (request.show_relocations) {
    render_relocations(report.relocations);
  }
}

nlohmann::json render_json(const inspect_report& report, const inspect_request& request) {
  nlohmann::json output;
  const auto& summary = report.summary;

  output["path"] = summary.path;
  output["format"] = summary.format;
  output["summary"] = {
      {"architecture", summary.architecture},
      {"bitness", summary.bitness},
      {"endianness", summary.endianness},
      {"file_type", summary.file_type},
      {"entrypoint", summary.entrypoint},
      {"has_entrypoint", summary.has_entrypoint},
      {"imagebase", summary.imagebase},
      {"has_imagebase", summary.has_imagebase},
      {"file_size", summary.file_size},
      {"sections", summary.sections},
      {"segments", summary.segments_supported ? nlohmann::json(summary.segments) : nlohmann::json()},
      {"segments_supported", summary.segments_supported},
      {"imports", summary.imports},
      {"exports", summary.exports},
      {"symbols", summary.symbols},
      {"relocations", summary.relocations},
      {"libraries", summary.libraries},
  };

  if (request.show_headers) {
    if (report.elf_header) {
      const auto& info = *report.elf_header;
      output["headers"]["elf"] = {
          {"os_abi", info.os_abi},    {"abi_version", info.abi_version},
          {"class", info.class_type}, {"data", info.data_encoding},
          {"machine", info.machine},  {"interpreter", info.interpreter},
          {"soname", info.soname},    {"rpath", info.rpath},
          {"runpath", info.runpath},  {"build_id", info.build_id},
      };
    } else if (report.pe_header) {
      const auto& info = *report.pe_header;
      output["headers"]["pe"] = {
          {"machine", info.machine},
          {"subsystem", info.subsystem},
          {"timestamp", info.timestamp},
          {"linker_major", info.linker_major},
          {"linker_minor", info.linker_minor},
          {"imagebase", info.imagebase},
          {"entrypoint_rva", info.entrypoint_rva},
          {"entrypoint", info.entrypoint},
          {"section_alignment", info.section_alignment},
          {"file_alignment", info.file_alignment},
          {"dll_characteristics", info.dll_characteristics},
      };
    } else if (report.macho_header) {
      const auto& info = *report.macho_header;
      output["headers"]["macho"] = {
          {"cpu_type", info.cpu_type},
          {"cpu_subtype", info.cpu_subtype},
          {"file_type", info.file_type},
          {"flags", info.flags},
          {"load_commands", info.load_commands},
          {"uuid", info.uuid},
          {"build_platform", info.build_platform},
          {"build_minos", info.build_minos},
          {"build_sdk", info.build_sdk},
          {"dylinker", info.dylinker},
          {"rpaths", info.rpaths},
      };
    }
  }

  if (request.show_sections) {
    nlohmann::json sections = nlohmann::json::array();
    for (const auto& section : report.sections) {
      sections.push_back({
          {"name", section.name},
          {"address", section.address},
          {"size", section.size},
          {"offset", section.offset},
          {"perms", section.perms},
          {"type", section.kind},
      });
    }
    output["sections"] = std::move(sections);
  }

  if (request.show_segments) {
    nlohmann::json segments = nlohmann::json::array();
    for (const auto& segment : report.segments) {
      segments.push_back({
          {"name", segment.name},
          {"address", segment.address},
          {"virtual_size", segment.vsize},
          {"offset", segment.offset},
          {"file_size", segment.fsize},
          {"perms", segment.perms},
          {"kind", segment.kind},
      });
    }
    output["segments"] = std::move(segments);
  }

  if (request.show_libraries) {
    output["libraries"] = report.libraries;
  }

  if (request.show_imports) {
    nlohmann::json imports = nlohmann::json::array();
    for (const auto& func : report.imports) {
      imports.push_back({
          {"name", func.name},
          {"address", func.address},
      });
    }
    output["imports"] = std::move(imports);
  }

  if (request.show_exports) {
    nlohmann::json exports = nlohmann::json::array();
    for (const auto& func : report.exports) {
      exports.push_back({
          {"name", func.name},
          {"address", func.address},
      });
    }
    output["exports"] = std::move(exports);
  }

  if (request.show_symbols) {
    nlohmann::json symbols = nlohmann::json::array();
    for (const auto& symbol : report.symbols) {
      symbols.push_back({
          {"name", symbol.name},
          {"address", symbol.address},
          {"size", symbol.size},
      });
    }
    output["symbols"] = std::move(symbols);
  }

  if (request.show_relocations) {
    nlohmann::json relocs = nlohmann::json::array();
    for (const auto& reloc : report.relocations) {
      relocs.push_back({
          {"address", reloc.address},
          {"size", reloc.size},
          {"type", reloc.type},
          {"symbol", reloc.symbol},
          {"origin", reloc.origin},
      });
    }
    output["relocations"] = std::move(relocs);
  }

  return output;
}

} // namespace detail

int inspect(const inspect_request& request) {
  auto log = redlog::get_logger("w1tool.inspect");

  if (request.binary_path.empty()) {
    log.error("binary path required for inspection");
    return 1;
  }

  if (!fs::exists(request.binary_path)) {
    log.error("binary file does not exist", redlog::field("path", request.binary_path));
    return 1;
  }

  try {
    auto binary = detail::parse_binary(request, log);
    if (!binary) {
      log.error("failed to parse binary - invalid format or corrupted file");
      return 1;
    }

    auto report = detail::build_report(request, *binary);
    if (request.json_output) {
      nlohmann::json output = detail::render_json(report, request);
      if (request.json_pretty) {
        std::cout << output.dump(2) << "\n";
      } else {
        std::cout << output.dump() << "\n";
      }
    } else {
      detail::render_text(report, request);
    }
    return 0;
  } catch (const std::exception& e) {
    log.error("analysis failed", redlog::field("error", e.what()));
    return 1;
  }
}

#endif // WITNESS_LIEF_ENABLED

} // namespace w1tool::commands

```

`src/w1tool/commands/inspect.hpp`:

```hpp
#pragma once

#include <string>

namespace w1tool::commands {

struct inspect_request {
  std::string binary_path;
  bool show_headers = false;
  bool show_sections = false;
  bool show_segments = false;
  bool show_symbols = false;
  bool show_imports = false;
  bool show_exports = false;
  bool show_relocations = false;
  bool show_libraries = false;
  bool json_output = false;
  bool json_pretty = false;
  bool show_all = false;
  std::string forced_format;
};

/**
 * inspect command - binary summary
 *
 * @param request resolved inspect configuration
 * @return exit code (0 for success, 1 for failure)
 */
int inspect(const inspect_request& request);

} // namespace w1tool::commands

```

`src/w1tool/commands/read_drcov.cpp`:

```cpp
#include "read_drcov.hpp"
#include <w1formats/drcov.hpp>
#include <iomanip>
#include <iostream>
#include <locale>
#include <redlog.hpp>
#include <sstream>

namespace w1tool::commands {

std::string format_address(uint64_t address) {
  std::ostringstream out;
  out << "0x" << std::hex << address;
  return out.str();
}

// helper function to format hit counts with K/M/B suffixes
std::string format_hits(uint64_t hits) {
  if (hits >= 1000000000) {
    double b = static_cast<double>(hits) / 1000000000.0;
    std::stringstream ss;
    ss << std::fixed << std::setprecision(1) << b << "B";
    return ss.str();
  } else if (hits >= 1000000) {
    double m = static_cast<double>(hits) / 1000000.0;
    std::stringstream ss;
    ss << std::fixed << std::setprecision(1) << m << "M";
    return ss.str();
  } else if (hits >= 1000) {
    double k = static_cast<double>(hits) / 1000.0;
    std::stringstream ss;
    ss << std::fixed << std::setprecision(1) << k << "K";
    return ss.str();
  } else {
    return std::to_string(hits);
  }
}

// helper function to format byte sizes with KB/MB/GB suffixes
std::string format_bytes(uint64_t bytes) {
  if (bytes >= 1024ULL * 1024 * 1024) {
    double gb = static_cast<double>(bytes) / (1024.0 * 1024.0 * 1024.0);
    std::stringstream ss;
    ss << std::fixed << std::setprecision(1) << gb << " GB";
    return ss.str();
  } else if (bytes >= 1024 * 1024) {
    double mb = static_cast<double>(bytes) / (1024.0 * 1024.0);
    std::stringstream ss;
    ss << std::fixed << std::setprecision(1) << mb << " MB";
    return ss.str();
  } else if (bytes >= 1024) {
    double kb = static_cast<double>(bytes) / 1024.0;
    std::stringstream ss;
    ss << std::fixed << std::setprecision(1) << kb << " KB";
    return ss.str();
  } else {
    return std::to_string(bytes) + " B";
  }
}

// helper function to format plain numbers (for counts)
std::string format_number(uint64_t number) {
  try {
    std::stringstream ss;
    ss.imbue(std::locale(""));
    ss << number;
    return ss.str();
  } catch (...) {
    // fallback: manual formatting with commas
    std::string str = std::to_string(number);
    std::string result;
    int count = 0;
    for (auto it = str.rbegin(); it != str.rend(); ++it) {
      if (count > 0 && count % 3 == 0) {
        result = ',' + result;
      }
      result = *it + result;
      count++;
    }
    return result;
  }
}

std::string format_average(double value) {
  std::ostringstream out;
  out << std::fixed << std::setprecision(2) << value;
  return out.str();
}

int read_drcov(
    args::ValueFlag<std::string>& file_flag, args::Flag& summary_flag, args::Flag& detailed_flag,
    args::ValueFlag<std::string>& module_flag
) {

  auto log = redlog::get_logger("w1tool.read-drcov");

  if (!file_flag) {
    log.error("drCov file path required");
    return 1;
  }

  std::string file_path = args::get(file_flag);
  log.info("analyzing DrCov file", redlog::field("file", file_path));

  try {
    // read and parse the DrCov file
    auto coverage_data = drcov::read(file_path);

    const bool has_hitcounts = coverage_data.has_hitcounts();

    std::cout << "drcov:\n";
    std::cout << "  file=" << file_path << "\n";
    std::cout << "  version=" << coverage_data.header.version << "\n";
    std::cout << "  flavor=" << coverage_data.header.flavor << "\n";
    std::cout << "  module_version=" << static_cast<uint32_t>(coverage_data.module_version) << "\n";
    std::cout << "  hitcounts=" << (has_hitcounts ? "yes" : "no") << "\n";
    std::cout << "\n";

    // calculate coverage stats
    uint64_t total_coverage_bytes = 0;
    uint64_t total_hitcount = 0;

    for (size_t i = 0; i < coverage_data.basic_blocks.size(); ++i) {
      const auto& bb = coverage_data.basic_blocks[i];
      total_coverage_bytes += bb.size;

      if (has_hitcounts && i < coverage_data.hitcounts.size()) {
        total_hitcount += coverage_data.hitcounts[i];
      }
    }

    std::cout << "summary:\n";
    std::cout << "  modules=" << format_number(coverage_data.modules.size())
              << " blocks=" << format_number(coverage_data.basic_blocks.size()) << "\n";
    std::cout << "  coverage=" << format_bytes(total_coverage_bytes);
    if (has_hitcounts) {
      double avg_hits = coverage_data.basic_blocks.empty()
                            ? 0.0
                            : static_cast<double>(total_hitcount) / coverage_data.basic_blocks.size();
      std::cout << " hits=" << format_hits(total_hitcount) << " avg_hits=" << format_average(avg_hits);
    }
    std::cout << "\n\n";

    if (summary_flag) {
      return 0;
    }

    auto stats = coverage_data.get_coverage_stats();

    // module summary
    std::cout << "modules:\n";
    if (coverage_data.modules.empty()) {
      std::cout << "  none\n\n";
    } else {
      std::cout << "  " << std::left << std::setw(4) << "id" << std::setw(8) << "blocks" << std::setw(12) << "size";
      if (has_hitcounts) {
        std::cout << std::setw(10) << "hits";
      }
      std::cout << std::setw(18) << "base"
                << "name\n";
    }

    if (!coverage_data.modules.empty()) {
      for (const auto& module : coverage_data.modules) {
        auto it = stats.find(module.id);
        size_t block_count = (it != stats.end()) ? it->second : 0;

        uint64_t module_bytes = 0;
        uint64_t module_hits = 0;

        for (size_t i = 0; i < coverage_data.basic_blocks.size(); ++i) {
          const auto& bb = coverage_data.basic_blocks[i];
          if (bb.module_id == module.id) {
            module_bytes += bb.size;
            if (has_hitcounts && i < coverage_data.hitcounts.size()) {
              module_hits += coverage_data.hitcounts[i];
            }
          }
        }

        std::cout << "  " << std::left << std::setw(4) << module.id << std::setw(8) << format_number(block_count)
                  << std::setw(12) << format_bytes(module_bytes);
        if (has_hitcounts) {
          std::cout << std::setw(10) << format_hits(module_hits);
        }
        std::cout << std::setw(18) << format_address(module.base) << module.path << "\n";
      }
      std::cout << "\n";
    }

    // detailed analysis if requested
    if (detailed_flag) {
      std::cout << "blocks:\n";
      if (coverage_data.basic_blocks.empty()) {
        std::cout << "  none\n\n";
      } else {
        std::cout << "  " << std::left << std::setw(8) << "module" << std::setw(14) << "offset" << std::setw(8)
                  << "size";
        if (has_hitcounts) {
          std::cout << std::setw(10) << "hits";
        }
        std::cout << std::setw(18) << "addr"
                  << "name\n";

        for (size_t i = 0; i < coverage_data.basic_blocks.size(); ++i) {
          const auto& bb = coverage_data.basic_blocks[i];
          if (bb.module_id < coverage_data.modules.size()) {
            const auto& module = coverage_data.modules[bb.module_id];
            uint64_t abs_addr = bb.absolute_address(module);

            std::cout << "  " << std::left << std::setw(8) << bb.module_id << std::setw(14) << format_address(bb.start)
                      << std::setw(8) << bb.size;
            if (has_hitcounts && i < coverage_data.hitcounts.size()) {
              std::cout << std::setw(10) << coverage_data.hitcounts[i];
            }
            std::cout << std::setw(18) << format_address(abs_addr) << module.path << "\n";
          }
        }
        std::cout << "\n";
      }
    }

    // module-specific analysis if requested
    if (module_flag) {
      std::string module_filter = args::get(module_flag);
      std::cout << "module:\n";
      std::cout << "  filter=" << module_filter << "\n";

      // find matching modules (by name substring)
      bool found = false;
      for (const auto& module : coverage_data.modules) {
        if (module.path.find(module_filter) != std::string::npos) {
          found = true;

          // count blocks for this module
          auto it = stats.find(module.id);
          size_t block_count = (it != stats.end()) ? it->second : 0;

          uint64_t module_bytes = 0;
          uint64_t module_hits = 0;

          for (size_t i = 0; i < coverage_data.basic_blocks.size(); ++i) {
            const auto& bb = coverage_data.basic_blocks[i];
            if (bb.module_id == module.id) {
              module_bytes += bb.size;
              if (has_hitcounts && i < coverage_data.hitcounts.size()) {
                module_hits += coverage_data.hitcounts[i];
              }
            }
          }

          std::cout << "  id=" << module.id << " name=" << module.path << "\n";
          std::cout << "  base=" << format_address(module.base) << " end=" << format_address(module.end)
                    << " size=" << format_bytes(module.end - module.base) << "\n";
          std::cout << "  blocks=" << format_number(block_count) << " coverage=" << format_bytes(module_bytes);
          if (has_hitcounts) {
            double avg_hits = (block_count == 0) ? 0.0 : static_cast<double>(module_hits) / block_count;
            std::cout << " hits=" << format_hits(module_hits) << " avg_hits=" << format_average(avg_hits);
          }
          std::cout << "\n\n";
        }
      }

      if (!found) {
        std::cout << "  result=none\n";
      }
    }

    return 0;

  } catch (const drcov::parse_error& e) {
    log.error(
        "failed to parse DrCov file", redlog::field("error", e.what()),
        redlog::field("code", static_cast<int>(e.code()))
    );
    return 1;
  } catch (const std::exception& e) {
    log.error("error analyzing DrCov file", redlog::field("error", e.what()));
    return 1;
  }
}

} // namespace w1tool::commands

```

`src/w1tool/commands/read_drcov.hpp`:

```hpp
#pragma once

#include "w1base/ext/args.hpp"

namespace w1tool::commands {

/**
 * read-DrCov command - analyzes drcov coverage files
 *
 * @param file_flag path to DrCov file to analyze
 * @param summary_flag show summary only (optional)
 * @param detailed_flag show detailed basic block listing (optional)
 * @param module_flag filter by module name substring (optional)
 * @return exit code (0 for success, 1 for failure)
 */
int read_drcov(
    args::ValueFlag<std::string>& file_flag, args::Flag& summary_flag, args::Flag& detailed_flag,
    args::ValueFlag<std::string>& module_flag
);

} // namespace w1tool::commands
```

`src/w1tool/commands/read_dump.cpp`:

```cpp
#include "read_dump.hpp"
#include <w1dump/process_dumper.hpp>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <chrono>
#include <redlog.hpp>

namespace w1tool::commands {

using namespace w1::dump;

// helper function to format timestamp
std::string format_timestamp(uint64_t timestamp) {
  // timestamp is in milliseconds since epoch
  auto duration = std::chrono::milliseconds(timestamp);
  auto tp = std::chrono::system_clock::time_point(duration);
  auto time_t = std::chrono::system_clock::to_time_t(tp);

  std::stringstream ss;
  ss << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S");
  return ss.str();
}

// helper function to format byte sizes
static std::string format_bytes_dump(uint64_t bytes) {
  if (bytes >= 1024ULL * 1024 * 1024) {
    double gb = static_cast<double>(bytes) / (1024.0 * 1024.0 * 1024.0);
    std::stringstream ss;
    ss << std::fixed << std::setprecision(1) << gb << " GB";
    return ss.str();
  } else if (bytes >= 1024 * 1024) {
    double mb = static_cast<double>(bytes) / (1024.0 * 1024.0);
    std::stringstream ss;
    ss << std::fixed << std::setprecision(1) << mb << " MB";
    return ss.str();
  } else if (bytes >= 1024) {
    double kb = static_cast<double>(bytes) / 1024.0;
    std::stringstream ss;
    ss << std::fixed << std::setprecision(1) << kb << " KB";
    return ss.str();
  } else {
    return std::to_string(bytes) + " B";
  }
}

// helper to format permissions
std::string format_permissions(uint32_t perms) {
  std::string result;
  result += (perms & 1) ? "r" : "-"; // read
  result += (perms & 2) ? "w" : "-"; // write
  result += (perms & 4) ? "x" : "-"; // execute
  return result;
}

int read_dump(
    args::ValueFlag<std::string>& file_flag, args::Flag& detailed_flag, args::ValueFlag<std::string>& module_flag
) {
  auto log = redlog::get_logger("w1tool.read_dump");

  if (!file_flag) {
    log.err("--file argument required");
    return 1;
  }

  std::string file_path = args::get(file_flag);

  try {
    // load the dump
    auto dump = w1::dump::process_dumper::load_dump(file_path);

    // always show the metadata overview
    {
      // better organized output
      std::cout << "W1DUMP Process Snapshot\n";
      std::cout << "═══════════════════════\n";

      // metadata section
      std::cout << "├─ Metadata\n";
      std::cout << "│  ├─ Timestamp: " << format_timestamp(dump.metadata.timestamp) << "\n";
      std::cout << "│  ├─ Platform:  " << dump.metadata.os << "/" << dump.metadata.arch << " ("
                << static_cast<int>(dump.metadata.pointer_size) * 8 << "-bit)\n";
      std::cout << "│  └─ Process:   " << dump.metadata.process_name << " [pid:" << dump.metadata.pid << "]\n";

      // module statistics
      size_t user_modules = 0;
      size_t system_modules = 0;
      for (const auto& mod : dump.modules) {
        if (mod.is_system) {
          system_modules++;
        } else {
          user_modules++;
        }
      }

      std::cout << "├─ Modules (" << dump.modules.size() << " total)\n";
      std::cout << "│  ├─ User:   " << user_modules << "\n";
      std::cout << "│  └─ System: " << system_modules << "\n";

      // memory statistics with proper calculation
      size_t stack_count = 0, code_count = 0, data_count = 0;
      uint64_t stack_size = 0, code_size = 0, data_size = 0;
      size_t mapped_regions = 0;
      size_t reserved_regions = 0;

      for (const auto& region : dump.regions) {
        uint64_t size = region.end - region.start;

        // count mapped vs reserved regions
        if (region.permissions != 0) {
          mapped_regions++;

          if (region.is_stack) {
            stack_count++;
            stack_size += size;
          } else if (region.is_code) {
            code_count++;
            code_size += size;
          } else if (region.is_data) {
            data_count++;
            data_size += size;
          }
        } else {
          reserved_regions++;
        }
      }

      uint64_t total_mapped = stack_size + code_size + data_size;

      std::cout << "├─ Memory Regions (" << dump.regions.size() << " total, " << mapped_regions << " mapped, "
                << reserved_regions << " reserved)\n";
      std::cout << "│  ├─ Stack: " << std::setw(3) << stack_count << " regions (" << format_bytes_dump(stack_size)
                << ")\n";
      std::cout << "│  ├─ Code:  " << std::setw(3) << code_count << " regions (" << format_bytes_dump(code_size)
                << ")\n";
      std::cout << "│  ├─ Data:  " << std::setw(3) << data_count << " regions (" << format_bytes_dump(data_size)
                << ")\n";
      std::cout << "│  └─ Total: " << format_bytes_dump(total_mapped) << " mapped\n";

      // thread state
      std::cout << "└─ Thread State\n";
      std::cout << "   ├─ Thread ID: " << dump.thread.thread_id << "\n";
      std::cout << "   ├─ Registers: " << dump.thread.gpr_values.size() << " GPR, " << dump.thread.fpr_values.size()
                << " FPR\n";
      std::cout << "   └─ Captured:  " << (dump.regions.size() > 0 ? "✓" : "✗") << " memory, "
                << (!dump.thread.gpr_values.empty() ? "✓" : "✗") << " registers\n";
    }

    // show detailed view - compact and information-dense
    if (detailed_flag) {
      // filter by module if specified
      std::string module_filter;
      if (module_flag) {
        module_filter = args::get(module_flag);
      }

      // modules section
      std::cout << "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n";
      std::cout << "MODULES (" << dump.modules.size() << " total)\n";
      std::cout << "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n";

      // collect modules by type for better organization
      std::vector<const module_info*> user_mods, system_mods;
      for (const auto& mod : dump.modules) {
        if (!module_filter.empty() && mod.name.find(module_filter) == std::string::npos) {
          continue;
        }

        if (mod.is_system) {
          system_mods.push_back(&mod);
        } else {
          user_mods.push_back(&mod);
        }
      }

      // compact module display
      auto print_module_line = [](const module_info* mod, bool show_system) {
        std::cout << std::hex << std::setw(12) << mod->base_address << std::dec << " " << std::setw(8) << std::right
                  << format_bytes_dump(mod->size) << " " << std::setw(3) << format_permissions(mod->permissions) << " "
                  << std::left << std::setw(32) << mod->name;
        if (show_system) {
          std::cout << " [sys]";
        }
        std::cout << "\n";
      };

      // headers
      std::cout << "BASE         SIZE     PRM NAME\n";
      std::cout << "────────────────────────────────────────────────────────────────────────────────────────────────\n";

      // user modules first
      for (const auto* mod : user_mods) {
        print_module_line(mod, false);
      }

      // separator if both exist
      if (!user_mods.empty() && !system_mods.empty()) {
        std::cout
            << "── system ──────────────────────────────────────────────────────────────────────────────────────\n";
      }

      // system modules
      for (const auto* mod : system_mods) {
        print_module_line(mod, true);
      }

      // memory regions section
      std::cout << "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n";
      std::cout << "MEMORY REGIONS (" << dump.regions.size() << " total)\n";
      std::cout << "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n";

      // group regions by type
      struct RegionGroup {
        std::string name;
        std::vector<const memory_region*> regions;
        uint64_t total_size = 0;
      };

      RegionGroup stack{"STACK", {}, 0};
      RegionGroup code{"CODE", {}, 0};
      RegionGroup data{"DATA", {}, 0};

      for (const auto& region : dump.regions) {
        if (region.permissions == 0) {
          continue; // skip unmapped
        }

        uint64_t size = region.end - region.start;
        if (region.is_stack) {
          stack.regions.push_back(&region);
          stack.total_size += size;
        } else if (region.is_code) {
          code.regions.push_back(&region);
          code.total_size += size;
        } else if (region.is_data) {
          data.regions.push_back(&region);
          data.total_size += size;
        }
      }

      // headers
      std::cout << "START        END          SIZE     PRM TYPE MODULE\n";
      std::cout << "────────────────────────────────────────────────────────────────────────────────────────────────\n";

      auto print_region_group = [](const RegionGroup& group) {
        if (group.regions.empty()) {
          return;
        }

        std::cout << "── " << group.name << " (" << group.regions.size() << " regions, "
                  << format_bytes_dump(group.total_size) << ") ";
        size_t padding = 0;
        const size_t base_width = 70;
        const size_t used_width = group.name.length() + 20;
        if (base_width > used_width) {
          padding = base_width - used_width;
        }
        for (size_t i = 0; i < padding; ++i) {
          std::cout << "─";
        }
        std::cout << "\n";

        for (const auto* region : group.regions) {
          std::cout << std::hex << std::setw(12) << region->start << " " << std::setw(12) << region->end << std::dec
                    << " " << std::setw(8) << format_bytes_dump(region->end - region->start) << " " << std::setw(3)
                    << format_permissions(region->permissions) << " " << std::setw(4)
                    << (region->is_stack  ? "STK"
                        : region->is_code ? "CODE"
                                          : "DATA");

          if (!region->module_name.empty() && region->module_name.find("_unnamed") == std::string::npos) {
            std::cout << " " << region->module_name;
          }

          if (!region->data.empty()) {
            std::cout << " [" << format_bytes_dump(region->data.size()) << " captured]";
          }

          std::cout << "\n";
        }
      };

      print_region_group(stack);
      print_region_group(code);
      print_region_group(data);
    }

  } catch (const std::exception& e) {
    log.err("failed to read dump", redlog::field("file", file_path), redlog::field("error", e.what()));
    return 1;
  }

  return 0;
}

} // namespace w1tool::commands

```

`src/w1tool/commands/read_dump.hpp`:

```hpp
#pragma once

#include "w1base/ext/args.hpp"
#include <string>

namespace w1tool::commands {

int read_dump(
    args::ValueFlag<std::string>& file_flag, args::Flag& detailed_flag, args::ValueFlag<std::string>& module_flag
);

} // namespace w1tool::commands
```

`src/w1tool/commands/rewind.cpp`:

```cpp
#include "rewind.hpp"
#include "tracer.hpp"
#include "w1base/ext/args.hpp"

#include <algorithm>
#include <cctype>
#include <cstdlib>
#include <filesystem>
#include <iostream>
#include <sstream>

#include <redlog.hpp>

// forward declare CLI symbols from main.cpp
namespace cli {
extern args::CounterFlag verbosity_flag;
}

namespace w1tool::commands {
namespace {

std::string normalize_token(const std::string& value) {
  std::string out;
  out.reserve(value.size());
  for (unsigned char ch : value) {
    if (ch == '-' || ch == '_' || ch == ' ') {
      continue;
    }
    out.push_back(static_cast<char>(std::tolower(ch)));
  }
  return out;
}

bool normalize_flow(const std::string& value, std::string& out) {
  const std::string token = normalize_token(value);
  if (token == "instruction" || token == "inst" || token == "instr") {
    out = "instruction";
    return true;
  }
  if (token == "block" || token == "basicblock" || token == "basic") {
    out = "block";
    return true;
  }
  return false;
}

bool normalize_stack_window(const std::string& value, std::string& out) {
  const std::string token = normalize_token(value);
  if (token == "none") {
    out = "none";
    return true;
  }
  if (token == "fixed") {
    out = "fixed";
    return true;
  }
  if (token == "frame") {
    out = "frame";
    return true;
  }
  return false;
}

bool normalize_mem_access(const std::string& value, std::string& out) {
  const std::string token = normalize_token(value);
  if (token == "none") {
    out = "none";
    return true;
  }
  if (token == "reads" || token == "read") {
    out = "reads";
    return true;
  }
  if (token == "writes" || token == "write") {
    out = "writes";
    return true;
  }
  if (token == "readswrites" || token == "readwrite" || token == "rw") {
    out = "reads_writes";
    return true;
  }
  return false;
}

bool normalize_threads(const std::string& value, std::string& out) {
  const std::string token = normalize_token(value);
  if (token == "main" || token == "mainonly") {
    out = "main";
    return true;
  }
  if (token == "auto" || token == "autoattach") {
    out = "auto";
    return true;
  }
  return false;
}

bool normalize_mem_filter(const std::string& value, std::string& out) {
  const std::string token = normalize_token(value);
  if (token == "all") {
    out = "all";
    return true;
  }
  if (token == "ranges" || token == "range") {
    out = "ranges";
    return true;
  }
  if (token == "stackwindow" || token == "stack") {
    out = "stack_window";
    return true;
  }
  return false;
}

std::string join_list(const std::vector<std::string>& items, char delimiter = ',') {
  if (items.empty()) {
    return "";
  }
  std::ostringstream joined;
  for (size_t i = 0; i < items.size(); ++i) {
    if (i != 0) {
      joined << delimiter;
    }
    joined << items[i];
  }
  return joined.str();
}

std::string get_config_value_or(const std::map<std::string, std::string>& config, const char* key,
                                const char* fallback) {
  auto it = config.find(key);
  if (it != config.end()) {
    return it->second;
  }
  return fallback;
}

} // namespace

int rewind(
    args::ValueFlag<std::string>& library_flag, args::Flag& spawn_flag, args::ValueFlag<int>& pid_flag,
    args::ValueFlag<std::string>& name_flag, args::ValueFlag<std::string>& output_flag,
    args::ValueFlag<std::string>& flow_flag, args::Flag& reg_deltas_flag,
    args::ValueFlag<uint64_t>& reg_snapshot_interval_flag, args::ValueFlag<std::string>& stack_window_mode_flag,
    args::ValueFlag<uint64_t>& stack_above_flag, args::ValueFlag<uint64_t>& stack_below_flag,
    args::ValueFlag<uint64_t>& stack_max_flag, args::ValueFlag<uint64_t>& stack_snapshot_interval_flag,
    args::ValueFlag<std::string>& mem_access_flag, args::Flag& mem_values_flag,
    args::ValueFlag<uint32_t>& mem_max_bytes_flag, args::ValueFlagList<std::string>& mem_filter_flag,
    args::ValueFlagList<std::string>& mem_ranges_flag, args::ValueFlag<std::string>& module_filter_flag,
    args::ValueFlag<std::string>& system_policy_flag, args::ValueFlag<std::string>& threads_flag,
    args::Flag& compress_flag, args::ValueFlag<uint32_t>& chunk_size_flag,
    args::ValueFlagList<std::string>& config_flags, args::ValueFlag<int>& debug_level_flag,
    args::Flag& suspended_flag, args::Flag& no_aslr_flag, args::PositionalList<std::string>& args_list,
    const std::string& executable_path
) {
  auto log = redlog::get_logger("w1tool.rewind");

  // build execution parameters
  tracer_execution_params params;
  params.tracer_name = "w1rewind";
  params.executable_path = executable_path;

  if (library_flag) {
    params.library_path = args::get(library_flag);
  }

  std::string config_error;
  if (!apply_config_flags(config_flags, params.config_map, &config_error)) {
    log.err("invalid config format, expected key=value", redlog::field("config", config_error));
    return 1;
  }

  // determine output file
  std::string output_file;
  if (output_flag) {
    output_file = args::get(output_flag);
  } else if (auto it = params.config_map.find("output"); it != params.config_map.end()) {
    output_file = it->second;
  } else {
    output_file = default_output_path(spawn_flag, args_list, ".w1r", "trace.w1r");
  }
  params.config_map["output"] = output_file;

  // set debug level
  apply_debug_level(params, debug_level_flag, args::get(cli::verbosity_flag));

  // set common config flags
  if (system_policy_flag) {
    params.config_map["system_policy"] = args::get(system_policy_flag);
  }
  if (module_filter_flag) {
    params.config_map["module_filter"] = args::get(module_filter_flag);
  }
  if (threads_flag) {
    std::string normalized;
    if (!normalize_threads(args::get(threads_flag), normalized)) {
      log.err("invalid threads value, expected: main, auto", redlog::field("threads", args::get(threads_flag)));
      return 1;
    }
    params.config_map["threads"] = normalized;
  }

  // flow and register options
  if (flow_flag) {
    std::string normalized;
    if (!normalize_flow(args::get(flow_flag), normalized)) {
      log.err("invalid flow value, expected: block, instruction", redlog::field("flow", args::get(flow_flag)));
      return 1;
    }
    params.config_map["flow"] = normalized;
  }
  if (reg_deltas_flag) {
    params.config_map["reg_deltas"] = "true";
  }
  if (reg_snapshot_interval_flag) {
    params.config_map["reg_snapshot_interval"] = std::to_string(args::get(reg_snapshot_interval_flag));
  }

  // stack options
  if (stack_window_mode_flag) {
    std::string normalized;
    if (!normalize_stack_window(args::get(stack_window_mode_flag), normalized)) {
      log.err(
          "invalid stack window mode, expected: none, fixed, frame",
          redlog::field("stack_window_mode", args::get(stack_window_mode_flag))
      );
      return 1;
    }
    params.config_map["stack_window_mode"] = normalized;
  }
  if (stack_above_flag) {
    params.config_map["stack_window_above"] = std::to_string(args::get(stack_above_flag));
  }
  if (stack_below_flag) {
    params.config_map["stack_window_below"] = std::to_string(args::get(stack_below_flag));
  }
  if (stack_max_flag) {
    params.config_map["stack_window_max"] = std::to_string(args::get(stack_max_flag));
  }
  if (stack_snapshot_interval_flag) {
    params.config_map["stack_snapshot_interval"] = std::to_string(args::get(stack_snapshot_interval_flag));
  }

  // memory options
  if (mem_access_flag) {
    std::string normalized;
    if (!normalize_mem_access(args::get(mem_access_flag), normalized)) {
      log.err(
          "invalid mem-access value, expected: none, reads, writes, reads_writes",
          redlog::field("mem_access", args::get(mem_access_flag))
      );
      return 1;
    }
    params.config_map["mem_access"] = normalized;
  }
  if (mem_values_flag) {
    params.config_map["mem_values"] = "true";
  }
  if (mem_max_bytes_flag) {
    params.config_map["mem_max_bytes"] = std::to_string(args::get(mem_max_bytes_flag));
  }
  if (mem_filter_flag) {
    std::vector<std::string> normalized_filters;
    for (const auto& entry : args::get(mem_filter_flag)) {
      std::string normalized;
      if (!normalize_mem_filter(entry, normalized)) {
        log.err(
            "invalid mem-filter value, expected: all, ranges, stack_window", redlog::field("mem_filter", entry)
        );
        return 1;
      }
      normalized_filters.push_back(normalized);
    }
    params.config_map["mem_filter"] = join_list(normalized_filters);
  }
  if (mem_ranges_flag) {
    params.config_map["mem_ranges"] = join_list(args::get(mem_ranges_flag));
    if (!mem_filter_flag && params.config_map.find("mem_filter") == params.config_map.end()) {
      params.config_map["mem_filter"] = "ranges";
    }
  }

  if (compress_flag) {
    params.config_map["compress"] = "true";
  }
  if (chunk_size_flag) {
    params.config_map["chunk_size"] = std::to_string(args::get(chunk_size_flag));
  }

  // set target
  std::string target_error;
  target_args target{spawn_flag, pid_flag, name_flag, suspended_flag, no_aslr_flag, args_list};
  if (!apply_target(params, target, &target_error)) {
    log.err(target_error);
    return 1;
  }

  const std::string flow = get_config_value_or(params.config_map, "flow", "block");
  const std::string mem_access = get_config_value_or(params.config_map, "mem_access", "none");
  const std::string stack_window = get_config_value_or(params.config_map, "stack_window_mode", "none");
  const std::string threads = get_config_value_or(params.config_map, "threads", "main");
  const std::string reg_deltas = get_config_value_or(params.config_map, "reg_deltas", "false");
  const std::string compress = get_config_value_or(params.config_map, "compress", "false");
  const std::string chunk_size = get_config_value_or(params.config_map, "chunk_size", "default");

  log.info(
      "rewind tracing configuration", redlog::field("output_file", output_file), redlog::field("flow", flow),
      redlog::field("mem_access", mem_access), redlog::field("stack_window", stack_window),
      redlog::field("threads", threads), redlog::field("reg_deltas", reg_deltas),
      redlog::field("compress", compress), redlog::field("chunk_size", chunk_size),
      redlog::field("debug_level", params.debug_level)
  );

  int result = execute_tracer_impl(params);

  if (result == 0) {
    if (!std::filesystem::exists(output_file)) {
      log.err("output file not created", redlog::field("output_file", output_file));
      return 1;
    }

    std::cout << "rewind trace completed successfully.\n";
    std::cout << "output file: " << output_file << "\n";
    std::cout << "use 'w1replay inspect -t " << output_file << "' to analyze results.\n";
  }

  return result;
}

} // namespace w1tool::commands

```

`src/w1tool/commands/rewind.hpp`:

```hpp
#pragma once

#include "w1base/ext/args.hpp"
#include <cstdint>

namespace w1tool::commands {

/**
 * rewind command - records rewind traces with convenient options
 *
 * @param library_flag path to w1rewind library (auto-detected if not specified)
 * @param spawn_flag spawn new process for tracing
 * @param pid_flag process id to attach to for runtime tracing
 * @param name_flag process name to attach to for runtime tracing
 * @param output_flag output file path for trace data (optional)
 * @param flow_flag flow mode (block, instruction) (optional)
 * @param reg_deltas_flag enable register delta capture (optional)
 * @param reg_snapshot_interval_flag register snapshot interval (optional)
 * @param stack_window_mode_flag stack window mode (none, fixed, frame) (optional)
 * @param stack_above_flag stack window bytes above SP (optional)
 * @param stack_below_flag stack window bytes below SP (optional)
 * @param stack_max_flag stack window max bytes (optional)
 * @param stack_snapshot_interval_flag stack snapshot interval (optional)
 * @param mem_access_flag memory access capture (none, reads, writes, reads_writes) (optional)
 * @param mem_values_flag capture memory values (optional)
 * @param mem_max_bytes_flag max bytes per memory value (optional)
 * @param mem_filter_flag memory filter list (all, ranges, stack_window) (optional)
 * @param mem_ranges_flag memory ranges start-end (optional)
 * @param module_filter_flag comma-separated list of modules to filter (optional)
 * @param system_policy_flag system module policy (exclude_all, include_critical, include_all) (optional)
 * @param threads_flag thread attach policy (main, auto) (optional)
 * @param compress_flag enable zstd compression (optional)
 * @param chunk_size_flag trace chunk size (optional)
 * @param config_flags configuration key=value pairs (optional)
 * @param debug_level_flag debug level override - defaults to passthrough verbosity (optional)
 * @param suspended_flag start process in suspended state (optional)
 * @param no_aslr_flag disable ASLR when launching process (optional)
 * @param args_list binary and arguments (use -- to separate w1tool args from target args)
 * @param executable_path path to the current executable (for auto-discovery)
 * @return exit code (0 for success, 1 for failure)
 */
int rewind(
    args::ValueFlag<std::string>& library_flag, args::Flag& spawn_flag, args::ValueFlag<int>& pid_flag,
    args::ValueFlag<std::string>& name_flag, args::ValueFlag<std::string>& output_flag,
    args::ValueFlag<std::string>& flow_flag, args::Flag& reg_deltas_flag,
    args::ValueFlag<uint64_t>& reg_snapshot_interval_flag, args::ValueFlag<std::string>& stack_window_mode_flag,
    args::ValueFlag<uint64_t>& stack_above_flag, args::ValueFlag<uint64_t>& stack_below_flag,
    args::ValueFlag<uint64_t>& stack_max_flag, args::ValueFlag<uint64_t>& stack_snapshot_interval_flag,
    args::ValueFlag<std::string>& mem_access_flag, args::Flag& mem_values_flag,
    args::ValueFlag<uint32_t>& mem_max_bytes_flag, args::ValueFlagList<std::string>& mem_filter_flag,
    args::ValueFlagList<std::string>& mem_ranges_flag, args::ValueFlag<std::string>& module_filter_flag,
    args::ValueFlag<std::string>& system_policy_flag, args::ValueFlag<std::string>& threads_flag,
    args::Flag& compress_flag, args::ValueFlag<uint32_t>& chunk_size_flag,
    args::ValueFlagList<std::string>& config_flags, args::ValueFlag<int>& debug_level_flag,
    args::Flag& suspended_flag, args::Flag& no_aslr_flag, args::PositionalList<std::string>& args_list,
    const std::string& executable_path
);

} // namespace w1tool::commands

```

`src/w1tool/commands/tracer.cpp`:

```cpp
#include "tracer.hpp"

#include <algorithm>
#include <cstdlib>
#include <filesystem>
#include <iostream>

#include <redlog.hpp>

#include <w1base/platform_utils.hpp>
#include "tracer_discovery.hpp"
#include <w1nj3ct/w1nj3ct.hpp>
#include "w1base/signal_handler.hpp"

// forward declare CLI symbols from main.cpp
namespace cli {
extern args::CounterFlag verbosity_flag;
}

namespace w1tool::commands {

/**
 * convert tracer config key to environment variable name
 */
std::string make_env_var_name(const std::string& tracer_name, const std::string& config_key) {
  std::string env_name = tracer_name;

  // convert to uppercase
  std::transform(env_name.begin(), env_name.end(), env_name.begin(), ::toupper);

  // add config key in uppercase
  std::string upper_key = config_key;
  std::transform(upper_key.begin(), upper_key.end(), upper_key.begin(), ::toupper);

  return env_name + "_" + upper_key;
}

/**
 * parse config string in format "key=value"
 */
std::pair<std::string, std::string> parse_config_string(const std::string& config_str) {
  const size_t eq_pos = config_str.find('=');
  if (eq_pos == std::string::npos || eq_pos == 0 || eq_pos == config_str.length() - 1) {
    return {"", ""};
  }

  const std::string key = config_str.substr(0, eq_pos);
  const std::string value = config_str.substr(eq_pos + 1);

  return {key, value};
}

bool apply_config_flags(
    args::ValueFlagList<std::string>& config_flags, std::map<std::string, std::string>& config_map,
    std::string* error_out
) {
  if (!config_flags) {
    return true;
  }

  for (const std::string& config_str : args::get(config_flags)) {
    auto [key, value] = parse_config_string(config_str);

    if (key.empty() || value.empty()) {
      if (error_out) {
        *error_out = config_str;
      }
      return false;
    }

    config_map[key] = value;
  }

  return true;
}

void apply_debug_level(tracer_execution_params& params, args::ValueFlag<int>& debug_level_flag, int fallback_level) {
  if (debug_level_flag) {
    params.debug_level = args::get(debug_level_flag);
  } else {
    params.debug_level = fallback_level;
  }
}

bool apply_target(
    tracer_execution_params& params, const target_args& args, std::string* error_out, std::string_view name_flag
) {
  int target_count = 0;
  if (args.spawn_flag) {
    target_count++;
  }
  if (args.pid_flag) {
    target_count++;
  }
  if (args.name_flag) {
    target_count++;
  }

  if (target_count != 1) {
    if (error_out) {
      *error_out = "exactly one target required: specify -s/--spawn, --pid, or " + std::string(name_flag);
    }
    return false;
  }

  if (args.suspended_flag && !args.spawn_flag) {
    if (error_out) {
      *error_out = "--suspended can only be used with -s/--spawn (launch tracing)";
    }
    return false;
  }

  if (args.no_aslr_flag && !args.spawn_flag) {
    if (error_out) {
      *error_out = "--no-aslr can only be used with -s/--spawn (launch tracing)";
    }
    return false;
  }

  if (args.spawn_flag) {
    if (args.args_list.Get().empty()) {
      if (error_out) {
        *error_out = "binary path required when using -s/--spawn flag";
      }
      return false;
    }

    std::vector<std::string> all_args = args::get(args.args_list);
    params.spawn_target = true;
    params.binary_path = all_args[0];
    params.suspended = args.suspended_flag;
    params.disable_aslr = args.no_aslr_flag;

    if (all_args.size() > 1) {
      params.binary_args.assign(all_args.begin() + 1, all_args.end());
    }
  } else if (args.pid_flag) {
    params.target_pid = args::get(args.pid_flag);
  } else if (args.name_flag) {
    params.process_name = args::get(args.name_flag);
  }

  return true;
}

std::string default_output_path(
    bool spawn_flag, args::PositionalList<std::string>& args_list, std::string_view suffix, std::string_view fallback
) {
  if (spawn_flag && !args_list.Get().empty()) {
    std::vector<std::string> all_args = args::get(args_list);
    std::filesystem::path fs_path(all_args[0]);
    std::string binary_name = fs_path.filename().string();
    return binary_name + std::string(suffix);
  }

  return std::string(fallback);
}

int tracer(
    args::ValueFlag<std::string>& library_flag, args::ValueFlag<std::string>& name_flag, args::Flag& spawn_flag,
    args::ValueFlag<int>& pid_flag, args::ValueFlag<std::string>& process_name_flag,
    args::ValueFlag<std::string>& output_flag, args::ValueFlagList<std::string>& config_flags,
    args::ValueFlag<int>& debug_level_flag, args::Flag& list_tracers_flag, args::Flag& suspended_flag,
    args::Flag& no_aslr_flag, args::PositionalList<std::string>& args_list, const std::string& executable_path
) {
  auto log = redlog::get_logger("w1tool.tracer");

  // handle --list-tracers flag
  if (list_tracers_flag) {
    const auto available_tracers = w1tool::tracer_discovery::list_available_tracers(executable_path);

    if (available_tracers.empty()) {
      std::cout << "no tracer libraries found\n";
      std::cout << "searched paths relative to: " << executable_path << "\n";
      return 0;
    }

    std::cout << "available tracers:\n";
    for (const auto& tracer : available_tracers) {
      std::cout << "  " << tracer.name << " - " << tracer.library_path << "\n";
    }
    return 0;
  }

  // validate tracer name
  if (!name_flag) {
    log.err("tracer name required: specify -n/--name (use --list-tracers to see available options)");
    return 1;
  }

  const std::string tracer_name = args::get(name_flag);

  // build execution parameters
  tracer_execution_params params;
  params.tracer_name = tracer_name;
  params.executable_path = executable_path;

  if (library_flag) {
    params.library_path = args::get(library_flag);
  }

  // set debug level
  apply_debug_level(params, debug_level_flag, args::get(cli::verbosity_flag));

  // process config
  std::string config_error;
  if (!apply_config_flags(config_flags, params.config_map, &config_error)) {
    log.err("invalid config format, expected key=value", redlog::field("config", config_error));
    return 1;
  }

  // process output flag
  if (output_flag) {
    params.config_map["output"] = args::get(output_flag);
  }

  // set target
  std::string target_error;
  target_args target{spawn_flag, pid_flag, process_name_flag, suspended_flag, no_aslr_flag, args_list};
  if (!apply_target(params, target, &target_error, "--process-name")) {
    log.err(target_error);
    return 1;
  }

  return execute_tracer_impl(params);
}

int execute_tracer_impl(const tracer_execution_params& params) {
  auto log = redlog::get_logger("w1tool.tracer");

  // log platform info
  const std::string platform = w1::common::platform_utils::get_platform_name();
  log.debug("platform detected", redlog::field("platform", platform));

  if (!w1::common::platform_utils::supports_runtime_injection()) {
    log.warn("runtime injection may not be supported on this platform", redlog::field("platform", platform));
  }

  // initialize signal handling
  w1::tn3ss::signal_handler::config sig_config;
  sig_config.context_name = "w1tool";
  sig_config.log_signals = (args::get(cli::verbosity_flag) >= 1);

  w1::tn3ss::signal_handler::guard signal_guard(sig_config);
  if (!signal_guard.is_initialized()) {
    log.warn("failed to initialize signal handling system");
  }

  // register signal handler
  w1::tn3ss::signal_handler::register_handler(
      [](const std::string& context) {
        auto signal_log = redlog::get_logger("w1tool.signal");
        signal_log.info("received shutdown signal", redlog::field("context", context));
      },
      "tracer"
  );

  // determine library path
  std::string lib_path = params.library_path;
  if (lib_path.empty()) {
    // auto-discover path
    log.debug("attempting to auto-discover tracer library", redlog::field("tracer_name", params.tracer_name));

    lib_path = w1tool::tracer_discovery::find_tracer_library(params.executable_path, params.tracer_name);

    if (lib_path.empty()) {
      log.err("tracer library not found", redlog::field("tracer_name", params.tracer_name));
      log.info("use --list-tracers to see available options, or specify path with -L/--library");
      return 1;
    }

    log.info(
        "auto-discovered library", redlog::field("tracer_name", params.tracer_name), redlog::field("path", lib_path)
    );
  } else {
    log.debug("using explicit tracer library", redlog::field("path", lib_path));
  }

  // validate library path exists
  if (!std::filesystem::exists(lib_path)) {
    log.err("tracer library does not exist", redlog::field("path", lib_path));
    return 1;
  }

  // prepare injection configuration
  w1::inject::config cfg;
  cfg.library_path = lib_path;

  // set debug level for tracer
  std::string debug_env_var = make_env_var_name(params.tracer_name, "verbose");
  cfg.env_vars[debug_env_var] = std::to_string(params.debug_level);

  // add config entries
  for (const auto& [key, value] : params.config_map) {
    std::string env_var = make_env_var_name(params.tracer_name, key);
    cfg.env_vars[env_var] = value;

    log.debug(
        "added config", redlog::field("key", key), redlog::field("value", value), redlog::field("env_var", env_var)
    );
  }

  log.info(
      "tracer configuration", redlog::field("tracer", params.tracer_name), redlog::field("library", lib_path),
      redlog::field("debug_level", params.debug_level), redlog::field("env_vars_count", cfg.env_vars.size())
  );

  w1::inject::result result;

  // execute tracing
  if (params.spawn_target) {
    // launch tracing
    log.info(
        "starting launch-time tracing", redlog::field("tracer", params.tracer_name),
        redlog::field("binary", params.binary_path), redlog::field("args_count", params.binary_args.size()),
        redlog::field("suspended", params.suspended ? "true" : "false"),
        redlog::field("disable_aslr", params.disable_aslr ? "true" : "false")
    );

    cfg.injection_method = w1::inject::method::preload;
    cfg.binary_path = params.binary_path;
    cfg.args = params.binary_args;
    cfg.suspended = params.suspended;
    cfg.disable_aslr = params.disable_aslr;
    cfg.wait_for_completion = true;

    result = w1::inject::inject(cfg);

    // setup signal forwarding
    if (result.success() && result.target_pid > 0) {
      w1::tn3ss::signal_handler::setup_forwarding(result.target_pid);

      // register cleanup handler
      w1::tn3ss::signal_handler::register_cleanup(
          [target_pid = result.target_pid]() { w1::tn3ss::signal_handler::remove_forwarding(target_pid); },
          100, // high priority
          "tracer_cleanup_" + std::to_string(result.target_pid)
      );

      log.debug("signal forwarding established", redlog::field("target_pid", result.target_pid));
    }

  } else if (params.target_pid > 0) {
    // runtime tracing by pid
    log.info(
        "starting runtime tracing", redlog::field("tracer", params.tracer_name), redlog::field("method", "pid"),
        redlog::field("target_pid", params.target_pid)
    );

    cfg.injection_method = w1::inject::method::runtime;
    cfg.pid = params.target_pid;
    result = w1::inject::inject(cfg);

    // setup signal forwarding
    if (result.success() && result.target_pid > 0) {
      w1::tn3ss::signal_handler::setup_forwarding(result.target_pid);

      // register cleanup handler
      w1::tn3ss::signal_handler::register_cleanup(
          [target_pid = result.target_pid]() { w1::tn3ss::signal_handler::remove_forwarding(target_pid); },
          100, // high priority
          "tracer_cleanup_" + std::to_string(result.target_pid)
      );

      log.debug("signal forwarding established", redlog::field("target_pid", result.target_pid));
    }

  } else if (!params.process_name.empty()) {
    // runtime tracing by name
    log.info(
        "starting runtime tracing", redlog::field("tracer", params.tracer_name), redlog::field("method", "name"),
        redlog::field("process_name", params.process_name)
    );

    cfg.injection_method = w1::inject::method::runtime;
    cfg.process_name = params.process_name;
    result = w1::inject::inject(cfg);

    // setup signal forwarding
    if (result.success() && result.target_pid > 0) {
      w1::tn3ss::signal_handler::setup_forwarding(result.target_pid);

      // register cleanup handler
      w1::tn3ss::signal_handler::register_cleanup(
          [target_pid = result.target_pid]() { w1::tn3ss::signal_handler::remove_forwarding(target_pid); },
          100, // high priority
          "tracer_cleanup_" + std::to_string(result.target_pid)
      );

      log.debug("signal forwarding established", redlog::field("target_pid", result.target_pid));
    }
  } else {
    log.err("no valid target specified");
    return 1;
  }

  // handle result
  if (result.success()) {
    log.info("tracing completed successfully", redlog::field("tracer", params.tracer_name));
    if (result.target_pid > 0) {
      log.info("target process", redlog::field("pid", result.target_pid));
    }
    if (result.target_exit_code.has_value()) {
      log.info("target process exit code", redlog::field("exit_code", result.target_exit_code.value()));
    }

    std::cout << "tracing with " << params.tracer_name << " completed successfully.\n";
    if (result.target_exit_code.has_value()) {
      std::cout << "target process exited with code: " << result.target_exit_code.value() << "\n";
    }
    return 0;
  } else {
    log.err(
        "tracing failed", redlog::field("tracer", params.tracer_name), redlog::field("error", result.error_message)
    );
    return 1;
  }
}

} // namespace w1tool::commands

```

`src/w1tool/commands/tracer.hpp`:

```hpp
#pragma once

#include "w1base/ext/args.hpp"
#include <map>
#include <string>
#include <string_view>
#include <utility>
#include <vector>

namespace w1tool::commands {

/**
 * tracer execution parameters
 */
struct tracer_execution_params {
  std::string tracer_name;
  std::string library_path; // optional, empty for auto-discovery
  std::map<std::string, std::string> config_map;
  int debug_level = 0;

  // target specification (exactly one should be set)
  bool spawn_target = false;
  std::string binary_path;
  std::vector<std::string> binary_args;
  bool suspended = false;
  bool disable_aslr = false;

  int target_pid = -1;
  std::string process_name;

  std::string executable_path; // for auto-discovery
};

/**
 * convert tracer config key to environment variable name
 */
std::string make_env_var_name(const std::string& tracer_name, const std::string& config_key);

/**
 * parse config string in format "key=value"
 */
std::pair<std::string, std::string> parse_config_string(const std::string& config_str);

/**
 * apply config key=value flags into config map
 * returns false and sets error_out to the bad entry on parse failure
 */
bool apply_config_flags(
    args::ValueFlagList<std::string>& config_flags, std::map<std::string, std::string>& config_map,
    std::string* error_out = nullptr
);

void apply_debug_level(tracer_execution_params& params, args::ValueFlag<int>& debug_level_flag, int fallback_level);

struct target_args {
  args::Flag& spawn_flag;
  args::ValueFlag<int>& pid_flag;
  args::ValueFlag<std::string>& name_flag;
  args::Flag& suspended_flag;
  args::Flag& no_aslr_flag;
  args::PositionalList<std::string>& args_list;
};

bool apply_target(
    tracer_execution_params& params, const target_args& args, std::string* error_out = nullptr,
    std::string_view name_flag = "--name"
);

std::string default_output_path(
    bool spawn_flag, args::PositionalList<std::string>& args_list, std::string_view suffix, std::string_view fallback
);

/**
 * execute tracer with given parameters (shared implementation)
 */
int execute_tracer_impl(const tracer_execution_params& params);

/**
 * tracer command - generic tracer launcher with flexible configuration
 */
int tracer(
    args::ValueFlag<std::string>& library_flag, args::ValueFlag<std::string>& name_flag, args::Flag& spawn_flag,
    args::ValueFlag<int>& pid_flag, args::ValueFlag<std::string>& process_name_flag,
    args::ValueFlag<std::string>& output_flag, args::ValueFlagList<std::string>& config_flags,
    args::ValueFlag<int>& debug_level_flag, args::Flag& list_tracers_flag, args::Flag& suspended_flag,
    args::Flag& no_aslr_flag, args::PositionalList<std::string>& args_list, const std::string& executable_path
);

} // namespace w1tool::commands

```

`src/w1tool/main.cpp`:

```cpp
#include <cstdlib>
#include <exception>
#include <iostream>
#include <string>

#include <redlog.hpp>
#include "w1base/ext/args.hpp"

#include "w1base/cli/verbosity.hpp"

#include "commands/cover.hpp"
#include "commands/debug.hpp"
#include "commands/dump.hpp"
#include "commands/inject.hpp"
#include "commands/insert_library.hpp"
#include "commands/inspect.hpp"
#include "commands/rewind.hpp"
#include "commands/read_drcov.hpp"
#include "commands/read_dump.hpp"
#include "commands/tracer.hpp"

namespace cli {
args::Group arguments("arguments");
args::HelpFlag help_flag(arguments, "help", "help", {'h', "help"});
args::CounterFlag verbosity_flag(arguments, "verbosity", "verbosity level", {'v'});

void apply_verbosity() { w1::cli::apply_verbosity(args::get(verbosity_flag)); }
} // namespace cli

namespace {
auto log_main = redlog::get_logger("w1tool");
std::string g_executable_path;
} // namespace

void cmd_inject(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> library(parser, "path", "path to injection library", {'L', "library"});
  args::Flag spawn(parser, "spawn", "spawn new process for injection (uses preload)", {'s', "spawn"});
  args::ValueFlag<int> pid(parser, "pid", "target process id (uses runtime injection)", {'p', "pid"});
  args::ValueFlag<std::string> process_name(
      parser, "process", "target process name (uses runtime injection)", {"process-name"}
  );
  args::Flag suspended(parser, "suspended", "start process in suspended state (only with --spawn)", {"suspended"});
  args::Flag no_aslr(parser, "no-aslr", "disable aslr when launching process (only with --spawn)", {"no-aslr"});
  args::PositionalList<std::string> args(parser, "args", "binary -- arguments");
  parser.Parse();

  w1tool::commands::inject(library, spawn, pid, process_name, suspended, no_aslr, args);
}

void cmd_insert_library(args::Subparser& parser) {
  cli::apply_verbosity();

  args::Positional<std::string> dylib_path(parser, "dylib_path", "path to library to insert");
  args::Positional<std::string> binary_path(parser, "binary_path", "path to target binary");
  args::Positional<std::string> output_path(parser, "output_path", "path to output binary (optional)");
  args::Flag inplace(parser, "inplace", "modify binary in-place", {"inplace"});
  args::Flag weak(parser, "weak", "insert as weak import", {"weak"});
  args::Flag overwrite(parser, "overwrite", "overwrite existing output file", {"overwrite"});
  args::Flag strip_codesig(parser, "strip-codesig", "automatically strip code signature", {"strip-codesig"});
  args::Flag all_yes(parser, "all-yes", "answer yes to all prompts", {"all-yes"});
  args::Flag show_platforms(parser, "show-platforms", "show platform support information", {"show-platforms"});
  parser.Parse();

  w1tool::commands::insert_library(
      dylib_path, binary_path, output_path, inplace, weak, overwrite, strip_codesig, all_yes, show_platforms
  );
}

void cmd_inspect(args::Subparser& parser) {
  cli::apply_verbosity();

  args::Positional<std::string> binary_positional(parser, "binary", "path to binary file");
  args::ValueFlag<std::string> binary_flag(parser, "path", "path to binary file", {'b', "binary"});
  args::Flag headers(parser, "headers", "show header details", {'d', "detailed", "headers"});
  args::Flag sections(parser, "sections", "show section listing", {"sections"});
  args::Flag segments(parser, "segments", "show segment listing", {"segments"});
  args::Flag symbols(parser, "symbols", "show symbol table listing", {"symbols"});
  args::Flag imports(parser, "imports", "show import listings", {"imports"});
  args::Flag exports(parser, "exports", "show export listings", {"exports"});
  args::Flag relocations(parser, "relocs", "show relocation entries", {"relocs", "relocations"});
  args::Flag libraries(parser, "libraries", "show imported libraries", {"libraries", "libs"});
  args::Flag all(parser, "all", "show all details", {"all"});
  args::Flag security(parser, "security", "deprecated: use --headers", {"security"});
  args::Flag json(parser, "json", "output results in JSON format", {'j', "json"});
  args::Flag json_pretty(parser, "json-pretty", "pretty-print JSON output", {"json-pretty"});
  args::ValueFlag<std::string> format(parser, "format", "force format (elf/pe/macho)", {"format"});
  parser.Parse();

  w1tool::commands::inspect_request request;
  if (binary_positional) {
    request.binary_path = args::get(binary_positional);
  } else if (binary_flag) {
    request.binary_path = args::get(binary_flag);
  }

  request.show_headers = headers || security;
  request.show_sections = sections;
  request.show_segments = segments;
  request.show_symbols = symbols;
  request.show_imports = imports;
  request.show_exports = exports;
  request.show_relocations = relocations;
  request.show_libraries = libraries;
  request.json_output = json;
  request.json_pretty = json_pretty;
  request.show_all = all;
  if (format) {
    request.forced_format = args::get(format);
  }

  if (request.show_all) {
    request.show_headers = true;
    request.show_sections = true;
    request.show_segments = true;
    request.show_symbols = true;
    request.show_imports = true;
    request.show_exports = true;
    request.show_relocations = true;
    request.show_libraries = true;
  } else if (request.show_imports) {
    request.show_libraries = true;
  }

  w1tool::commands::inspect(request);
}

void cmd_cover(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> library(parser, "path", "path to w1cov library", {'L', "w1cov-library"});
  args::Flag spawn(parser, "spawn", "spawn new process for tracing", {'s', "spawn"});
  args::ValueFlag<int> pid(parser, "pid", "process id to attach to", {'p', "pid"});
  args::ValueFlag<std::string> name(parser, "name", "process name to attach to", {'n', "name"});
  args::ValueFlag<std::string> output(parser, "path", "output file path", {'o', "output"});
  args::ValueFlag<std::string> system_policy(
      parser, "policy", "system module policy (exclude_all, include_critical, include_all)", {"system-policy"}
  );
  args::Flag inst_trace(parser, "inst-trace", "enable instruction-level tracing (default: basic block)", {"inst"});
  args::ValueFlagList<std::string> config(parser, "config", "configuration key=value pairs", {'c', "config"});
  args::ValueFlag<std::string> module_filter(
      parser, "modules", "comma-separated list of modules to filter", {'m', "module-filter"}
  );
  args::ValueFlag<int> debug_level(parser, "level", "debug level override", {"debug"});
  args::ValueFlag<std::string> format(parser, "format", "output format (drcov, text)", {"format"});
  args::Flag suspended(parser, "suspended", "start process in suspended state (only with --spawn)", {"suspended"});
  args::Flag no_aslr(parser, "no-aslr", "disable aslr when launching process (only with --spawn)", {"no-aslr"});
  args::PositionalList<std::string> args(parser, "args", "binary -- arguments");
  parser.Parse();

  w1tool::commands::cover(
      library, spawn, pid, name, output, system_policy, inst_trace, config, module_filter, debug_level, format,
      suspended, no_aslr, args, g_executable_path
  );
}

void cmd_rewind(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> library(parser, "path", "path to w1rewind library", {'L', "w1rewind-library"});
  args::Flag spawn(parser, "spawn", "spawn new process for tracing", {'s', "spawn"});
  args::ValueFlag<int> pid(parser, "pid", "process id to attach to", {'p', "pid"});
  args::ValueFlag<std::string> name(parser, "name", "process name to attach to", {'n', "name"});
  args::ValueFlag<std::string> output(parser, "path", "output file path", {'o', "output"});
  args::ValueFlag<std::string> flow(parser, "mode", "flow mode (block, instruction)", {"flow"});
  args::Flag reg_deltas(parser, "reg-deltas", "enable register delta capture", {"reg-deltas"});
  args::ValueFlag<uint64_t> reg_snapshot_interval(
      parser, "count", "register snapshot interval (instructions)", {"reg-snapshot-interval"}
  );
  args::ValueFlag<std::string> stack_window(parser, "mode", "stack window mode (none, fixed, frame)", {"stack-window"});
  args::ValueFlag<uint64_t> stack_above(parser, "bytes", "stack window bytes above SP", {"stack-above"});
  args::ValueFlag<uint64_t> stack_below(parser, "bytes", "stack window bytes below SP", {"stack-below"});
  args::ValueFlag<uint64_t> stack_max(parser, "bytes", "stack window max bytes", {"stack-max"});
  args::ValueFlag<uint64_t> stack_snapshot_interval(
      parser, "count", "stack snapshot interval (instructions)", {"stack-snapshot-interval"}
  );
  args::ValueFlag<std::string> mem_access(
      parser, "mode", "memory access capture (none, reads, writes, reads_writes)", {"mem-access"}
  );
  args::Flag mem_values(parser, "mem-values", "capture memory values", {"mem-values"});
  args::ValueFlag<uint32_t> mem_max_bytes(parser, "bytes", "max bytes per memory value", {"mem-max-bytes"});
  args::ValueFlagList<std::string> mem_filter(
      parser, "filter", "memory filter (all, ranges, stack_window)", {"mem-filter"}
  );
  args::ValueFlagList<std::string> mem_ranges(
      parser, "range", "memory ranges in start-end form (repeatable)", {"mem-range", "mem-ranges"}
  );
  args::ValueFlag<std::string> module_filter(
      parser, "modules", "comma-separated list of modules to filter", {'m', "module-filter"}
  );
  args::ValueFlag<std::string> system_policy(
      parser, "policy", "system module policy (exclude_all, include_critical, include_all)", {"system-policy"}
  );
  args::ValueFlag<std::string> threads(parser, "policy", "thread attach policy (main, auto)", {"threads"});
  args::Flag compress(parser, "compress", "enable zstd compression (if available)", {"compress"});
  args::ValueFlag<uint32_t> chunk_size(parser, "bytes", "trace chunk size", {"chunk-size"});
  args::ValueFlagList<std::string> config(parser, "config", "configuration key=value pairs", {'c', "config"});
  args::ValueFlag<int> debug_level(parser, "level", "debug level override", {"debug"});
  args::Flag suspended(parser, "suspended", "start process in suspended state (only with --spawn)", {"suspended"});
  args::Flag no_aslr(parser, "no-aslr", "disable aslr when launching process (only with --spawn)", {"no-aslr"});
  args::PositionalList<std::string> args(parser, "args", "binary -- arguments");
  parser.Parse();

  w1tool::commands::rewind(
      library, spawn, pid, name, output, flow, reg_deltas, reg_snapshot_interval, stack_window, stack_above,
      stack_below, stack_max, stack_snapshot_interval, mem_access, mem_values, mem_max_bytes, mem_filter, mem_ranges,
      module_filter, system_policy, threads, compress, chunk_size, config, debug_level, suspended, no_aslr, args,
      g_executable_path
  );
}

void cmd_read_drcov(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> file(parser, "path", "path to DrCov file", {'f', "file"});
  args::Flag summary(parser, "summary", "show summary only", {'s', "summary"});
  args::Flag detailed(parser, "detailed", "show detailed basic block listing", {'d', "detailed"});
  args::ValueFlag<std::string> module(parser, "module", "filter by module name (substring match)", {'m', "module"});
  parser.Parse();

  w1tool::commands::read_drcov(file, summary, detailed, module);
}

void cmd_dump(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> library(parser, "path", "path to w1dump library", {'L', "w1dump-library"});
  args::Flag spawn(parser, "spawn", "spawn new process for dumping", {'s', "spawn"});
  args::ValueFlag<int> pid(parser, "pid", "process id to attach to", {'p', "pid"});
  args::ValueFlag<std::string> name(parser, "name", "process name to attach to", {'n', "name"});
  args::ValueFlag<std::string> output(parser, "path", "output file path", {'o', "output"});
  args::Flag memory(parser, "memory", "dump memory content", {"memory"});
  args::ValueFlagList<std::string> config(parser, "config", "configuration key=value pairs", {'c', "config"});
  args::ValueFlagList<std::string> filter(
      parser, "filter", "filter regions (format: type[:module1,module2])", {'f', "filter"}
  );
  args::ValueFlag<std::string> max_region_size(
      parser, "size", "max region size to dump (e.g. 10M, 1G)", {"max-region-size"}
  );
  args::ValueFlag<int> debug_level(parser, "level", "debug level override", {"debug"});
  args::Flag suspended(parser, "suspended", "start process in suspended state (only with --spawn)", {"suspended"});
  args::Flag no_aslr(parser, "no-aslr", "disable aslr when launching process (only with --spawn)", {"no-aslr"});
  args::PositionalList<std::string> args(parser, "args", "binary -- arguments");
  parser.Parse();

  w1tool::commands::dump(
      library, spawn, pid, name, output, memory, config, filter, max_region_size, debug_level, suspended, no_aslr, args,
      g_executable_path
  );
}

void cmd_read_dump(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> file(parser, "path", "path to dump file", {'f', "file"});
  args::Flag detailed(parser, "detailed", "show detailed module and region listings", {'d', "detailed"});
  args::ValueFlag<std::string> module(parser, "module", "filter by module name (substring match)", {'m', "module"});
  parser.Parse();

  w1tool::commands::read_dump(file, detailed, module);
}

void cmd_tracer(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> library(parser, "path", "path to tracer library", {'L', "library"});
  args::ValueFlag<std::string> name(parser, "name", "tracer name (w1cov, w1mem, mintrace, etc.)", {'n', "name"});
  args::Flag spawn(parser, "spawn", "spawn new process for tracing", {'s', "spawn"});
  args::ValueFlag<int> pid(parser, "pid", "process id to attach to", {'p', "pid"});
  args::ValueFlag<std::string> process_name(parser, "process", "process name to attach to", {"process-name"});
  args::ValueFlag<std::string> output(parser, "path", "output file path", {'o', "output"});
  args::ValueFlagList<std::string> config(parser, "config", "configuration key=value pairs", {'c', "config"});
  args::ValueFlag<int> debug_level(parser, "level", "debug level override", {"debug"});
  args::Flag list_tracers(parser, "list", "list available tracers", {"list-tracers"});
  args::Flag suspended(parser, "suspended", "start process in suspended state (only with --spawn)", {"suspended"});
  args::Flag no_aslr(parser, "no-aslr", "disable aslr when launching process (only with --spawn)", {"no-aslr"});
  args::PositionalList<std::string> args(parser, "args", "binary -- arguments");
  parser.Parse();

  w1tool::commands::tracer(
      library, name, spawn, pid, process_name, output, config, debug_level, list_tracers, suspended, no_aslr, args,
      g_executable_path
  );
}

void cmd_debug(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<int> pid(parser, "pid", "process id to attach to", {'p', "pid"});
  args::Flag spawn(parser, "spawn", "spawn new process for debugging", {'s', "spawn"});
  args::Flag interactive(parser, "interactive", "interactive debugging mode", {'i', "interactive"});
  args::Flag suspended(parser, "suspended", "start process in suspended state (only with --spawn)", {"suspended"});
  args::PositionalList<std::string> args(parser, "args", "binary -- arguments");
  parser.Parse();

  w1tool::commands::debug(pid, spawn, interactive, suspended, args);
}

int main(int argc, char* argv[]) {
  // store executable path for library auto-discovery
  g_executable_path = argv[0];

  args::ArgumentParser parser(
      "w1tool - cross-platform dynamic binary analysis tool", "inject libraries, trace coverage, and analyze binaries"
  );
  parser.helpParams.showTerminator = false;

  args::GlobalOptions globals(parser, cli::arguments);
  args::Group commands(parser, "commands");

  args::Command inject_cmd(commands, "inject", "inject library into target process", &cmd_inject);
  args::Command insert_library_cmd(
      commands, "insert-library", "insert library import into binary file", &cmd_insert_library
  );
  args::Command inspect_cmd(commands, "inspect", "binary summary", &cmd_inspect);
  args::Command cover_cmd(commands, "cover", "run coverage tracer", &cmd_cover);
  args::Command rewind_cmd(commands, "rewind", "record trace for replay", &cmd_rewind);
  args::Command read_drcov_cmd(commands, "read-drcov", "analyze drcov coverage files", &cmd_read_drcov);
  args::Command dump_cmd(commands, "dump", "dump process state", &cmd_dump);
  args::Command read_dump_cmd(commands, "read-dump", "analyze process dump", &cmd_read_dump);
  args::Command tracer_cmd(commands, "tracer", "run tracer", &cmd_tracer);
  args::Command debug_cmd(commands, "debug", "interactive debugger", &cmd_debug);

  try {
    parser.ParseCLI(argc, argv);
  } catch (args::Help) {
    std::cout << parser;
  } catch (args::Error& e) {
    std::cerr << e.what() << std::endl << parser;
    return 1;
  }

  return 0;
}

```

`src/w1tool/tracer_discovery.cpp`:

```cpp
#include "tracer_discovery.hpp"

#include <algorithm>
#include <filesystem>

#include <redlog.hpp>

#include <w1base/platform_utils.hpp>

namespace w1tool::tracer_discovery {

std::string extract_tracer_name(const std::string& library_filename) {
  auto log = redlog::get_logger("w1tool.tracer_discovery");

  // expect format: {tracer_name}_qbdipreload.{ext}
  const std::string suffix = "_qbdipreload";

  // find the suffix in the filename
  size_t suffix_pos = library_filename.find(suffix);
  if (suffix_pos == std::string::npos) {
    log.dbg(
        "library filename does not match expected pattern", redlog::field("filename", library_filename),
        redlog::field("expected_pattern", "*_qbdipreload.*")
    );
    return "";
  }

  // extract tracer name (everything before the suffix)
  std::string tracer_name = library_filename.substr(0, suffix_pos);

  if (tracer_name.empty()) {
    log.dbg("extracted empty tracer name", redlog::field("filename", library_filename));
    return "";
  }

  log.dbg(
      "extracted tracer name", redlog::field("filename", library_filename), redlog::field("tracer_name", tracer_name)
  );

  return tracer_name;
}

std::map<std::string, std::string> find_tracer_libraries(const std::string& executable_path) {
  auto log = redlog::get_logger("w1tool.tracer_discovery");
  std::map<std::string, std::string> tracers;

  // convert executable path to absolute path
  std::filesystem::path exec_path;
  try {
    exec_path = std::filesystem::canonical(executable_path);
  } catch (const std::exception& e) {
    log.dbg(
        "failed to canonicalize executable path, using as-is", redlog::field("path", executable_path),
        redlog::field("error", e.what())
    );
    exec_path = std::filesystem::path(executable_path);
  }

  std::filesystem::path exec_dir = exec_path.parent_path();
  std::string lib_ext = w1::common::platform_utils::get_library_extension();

  log.dbg(
      "searching for tracer libraries", redlog::field("exec_dir", exec_dir.string()), redlog::field("lib_ext", lib_ext)
  );

  // search paths relative to executable directory
  std::vector<std::filesystem::path> search_dirs = {
      exec_dir,                // same directory as executable
      exec_dir / "lib",        // lib/ subdirectory
      exec_dir / ".." / "lib", // ../lib/ (for installed layouts)
      exec_dir / "..",         // parent directory
  };

  for (const auto& search_dir : search_dirs) {
    if (!std::filesystem::exists(search_dir) || !std::filesystem::is_directory(search_dir)) {
      continue;
    }

    log.dbg("scanning directory", redlog::field("dir", search_dir.string()));

    try {
      for (const auto& entry : std::filesystem::directory_iterator(search_dir)) {
        if (!entry.is_regular_file()) {
          continue;
        }

        std::string filename = entry.path().filename().string();

        // check if it matches the pattern *_qbdipreload{lib_ext}
        if (filename.find("_qbdipreload") == std::string::npos || !filename.ends_with(lib_ext)) {
          continue;
        }

        std::string tracer_name = extract_tracer_name(filename);
        if (tracer_name.empty()) {
          continue;
        }

        // if we haven't found this tracer yet, add it
        if (tracers.count(tracer_name) == 0) {
          std::string canonical_path = std::filesystem::canonical(entry.path()).string();
          tracers[tracer_name] = canonical_path;

          log.dbg("found tracer library", redlog::field("tracer", tracer_name), redlog::field("path", canonical_path));
        }
      }
    } catch (const std::exception& e) {
      log.dbg("error scanning directory", redlog::field("dir", search_dir.string()), redlog::field("error", e.what()));
    }
  }

  log.trc("tracer discovery complete", redlog::field("tracers_found", tracers.size()));

  return tracers;
}

std::string find_tracer_library(const std::string& executable_path, const std::string& tracer_name) {
  const auto tracers = find_tracer_libraries(executable_path);
  const auto it = tracers.find(tracer_name);
  return it != tracers.end() ? it->second : "";
}

std::vector<tracer_info> list_available_tracers(const std::string& executable_path) {
  const auto tracers = find_tracer_libraries(executable_path);
  std::vector<tracer_info> result;
  result.reserve(tracers.size());

  for (const auto& [name, path] : tracers) {
    result.push_back({name, path});
  }

  // sort by tracer name for consistent output
  std::sort(result.begin(), result.end(), [](const tracer_info& a, const tracer_info& b) -> bool {
    return a.name < b.name;
  });

  return result;
}

} // namespace w1tool::tracer_discovery
```

`src/w1tool/tracer_discovery.hpp`:

```hpp
#pragma once

#include <map>
#include <string>
#include <vector>

namespace w1tool::tracer_discovery {

/**
 * @brief Discovery result containing tracer name and library path
 */
struct tracer_info {
  std::string name;
  std::string library_path;
};

/**
 * @brief Find all available tracer libraries relative to the executable
 * @param executable_path path to the current executable
 * @return map of tracer names to their library paths
 */
std::map<std::string, std::string> find_tracer_libraries(const std::string& executable_path);

/**
 * @brief Find a specific tracer library by name
 * @param executable_path path to the current executable
 * @param tracer_name name of the tracer to find (e.g., "w1cov", "w1mem")
 * @return path to the library if found, empty string otherwise
 */
std::string find_tracer_library(const std::string& executable_path, const std::string& tracer_name);

/**
 * @brief Extract tracer name from library filename
 * @param library_filename filename of the library (e.g., "w1cov_qbdipreload.so")
 * @return tracer name (e.g., "w1cov") or empty string if invalid format
 */
std::string extract_tracer_name(const std::string& library_filename);

/**
 * @brief Get list of all available tracers
 * @param executable_path path to the current executable
 * @return vector of tracer information
 */
std::vector<tracer_info> list_available_tracers(const std::string& executable_path);

} // namespace w1tool::tracer_discovery
```

`test/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_subdirectory(w1base)
add_subdirectory(w1formats)
add_subdirectory(w1runtime)
add_subdirectory(w1instrument)
add_subdirectory(w1analysis)
add_subdirectory(w1rewind)
add_subdirectory(w1monitor)
if(WITNESS_ASMR)
    add_subdirectory(w1asmr)
endif()
add_subdirectory(p1ll)
add_subdirectory(w1replay)
add_subdirectory(w1h00k)

```

`test/common/test_main.cpp`:

```cpp
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "doctest/doctest.hpp"

```

`test/common/test_paths.hpp`:

```hpp
#pragma once

#include <cstring>
#include <string>

#if defined(_WIN32)
#include <windows.h>
#elif defined(__APPLE__)
#include <mach-o/dyld.h>
#include <unistd.h>
#else
#include <unistd.h>
#endif

namespace w1::test_paths {

inline std::string executable_path() {
#if defined(_WIN32)
  char buffer[MAX_PATH] = {};
  const DWORD len = GetModuleFileNameA(nullptr, buffer, MAX_PATH);
  return len ? std::string(buffer, len) : std::string{};
#elif defined(__APPLE__)
  uint32_t size = 0;
  _NSGetExecutablePath(nullptr, &size);
  std::string path(size, '\0');
  if (_NSGetExecutablePath(path.data(), &size) != 0) {
    return {};
  }
  path.resize(std::strlen(path.c_str()));
  return path;
#else
  char buffer[4096] = {};
  const ssize_t len = readlink("/proc/self/exe", buffer, sizeof(buffer) - 1);
  if (len <= 0) {
    return {};
  }
  buffer[len] = '\0';
  return std::string(buffer);
#endif
}

inline std::string directory_from_path(const std::string& path) {
  const size_t pos = path.find_last_of("/\\");
  if (pos == std::string::npos) {
    return ".";
  }
  return path.substr(0, pos);
}

inline std::string test_library_path(const char* name) {
  const auto exe_path = executable_path();
  const auto exe_dir = directory_from_path(exe_path);
#if defined(_WIN32)
  return exe_dir + "\\..\\libraries\\" + name;
#else
  return exe_dir + "/../libraries/" + name;
#endif
}

inline const char* interpose_library_name() {
#if defined(_WIN32)
  return "w1h00k_interpose_lib.dll";
#elif defined(__APPLE__)
  return "w1h00k_interpose_lib.dylib";
#else
  return "w1h00k_interpose_lib.so";
#endif
}

inline std::string interpose_library_path() { return test_library_path(interpose_library_name()); }

inline const char* monitor_thread_library_name() {
#if defined(__linux__)
  return "w1monitor_thread_lib.so";
#else
  return "";
#endif
}

inline std::string monitor_thread_library_path() {
  const char* name = monitor_thread_library_name();
  if (!name || name[0] == '\0') {
    return {};
  }
  return test_library_path(name);
}

} // namespace w1::test_paths

```

`test/p1ll/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_subdirectory(core)

if(WITNESS_ASMR)
    add_subdirectory(heur)
endif()

```

`test/p1ll/core/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${W1_SOURCE_DIR}/cmake/TestConfig.cmake)

set(P1LL_TEST_SOURCES
    test_main.cpp
    pattern_test.cpp
    pattern_matcher_test.cpp
    scanner_test.cpp
    plan_builder_test.cpp
    apply_test.cpp
    address_space_test.cpp
    platform_test.cpp
    session_test.cpp
)

w1_add_doctest_suite(p1ll_unit_tests
    SOURCES ${P1LL_TEST_SOURCES}
    INCLUDE_DIRS
        ${CMAKE_CURRENT_SOURCE_DIR}
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/third_party
    LIBS p1ll_core
    OUTPUT_SUBDIR p1ll/core
)

```

`test/p1ll/core/address_space_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "p1ll/engine/address_space.hpp"
#include "p1ll/engine/types.hpp"
#include "test_helpers.hpp"

#include <array>
#include <span>

namespace {

using p1ll::engine::buffer_address_space;
using p1ll::engine::error_code;
using p1ll::engine::process_address_space;
using p1ll::test_helpers::make_buffer;

} // namespace

TEST_CASE("buffer address space reads and writes") {
  auto buffer = make_buffer(8, 0x11);
  buffer_address_space space(std::span<uint8_t>(buffer.data(), buffer.size()));

  auto read = space.read(0, 4);
  REQUIRE(read.ok());
  CHECK(read.value.size() == 4);
  CHECK(read.value[0] == 0x11);

  std::array<uint8_t, 2> bytes = {0x22, 0x33};
  auto write_status = space.write(2, bytes);
  CHECK(write_status.ok());
  CHECK(buffer[2] == 0x22);
  CHECK(buffer[3] == 0x33);
}

TEST_CASE("buffer address space rejects out-of-bounds") {
  auto buffer = make_buffer(4, 0x00);
  buffer_address_space space(std::span<uint8_t>(buffer.data(), buffer.size()));

  auto read = space.read(4, 1);
  CHECK_FALSE(read.ok());
  CHECK(read.status_info.code == error_code::invalid_argument);

  std::array<uint8_t, 1> bytes = {0xaa};
  auto write_status = space.write(4, bytes);
  CHECK_FALSE(write_status.ok());
  CHECK(write_status.code == error_code::invalid_argument);
}

TEST_CASE("buffer address space region info handles missing") {
  auto buffer = make_buffer(4, 0x00);
  buffer_address_space space(std::span<uint8_t>(buffer.data(), buffer.size()));

  auto region = space.region_info(4);
  CHECK_FALSE(region.ok());
  CHECK(region.status_info.code == error_code::not_found);
}

TEST_CASE("buffer address space allocation is unsupported") {
  auto buffer = make_buffer(4, 0x00);
  buffer_address_space space(std::span<uint8_t>(buffer.data(), buffer.size()));

  auto alloc = space.allocate(16, p1ll::engine::memory_protection::read_write);
  CHECK_FALSE(alloc.ok());
  CHECK(alloc.status_info.code == error_code::unsupported);
}

TEST_CASE("process address space exposes page size") {
  process_address_space space;
  auto page = space.page_size();
  CHECK(page.ok());
  CHECK(page.value > 0);
}

TEST_CASE("process address space region enumeration is best-effort") {
  process_address_space space;
  auto regions = space.regions({});
  if (!regions.ok()) {
    INFO("region enumeration unavailable: " << regions.status_info.message);
    return;
  }
  CHECK_FALSE(regions.value.empty());
}

```

`test/p1ll/core/apply_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "p1ll/engine/address_space.hpp"
#include "p1ll/engine/apply.hpp"
#include "p1ll/engine/types.hpp"
#include "test_helpers.hpp"

#include <span>

namespace {

using p1ll::engine::apply_options;
using p1ll::engine::apply_plan;
using p1ll::engine::buffer_address_space;
using p1ll::engine::error_code;
using p1ll::engine::plan_entry;
using p1ll::test_helpers::make_buffer;
using p1ll::test_helpers::write_bytes;

} // namespace

TEST_CASE("apply writes masked bytes") {
  auto buffer = make_buffer(16, 0x00);
  buffer_address_space space(std::span<uint8_t>(buffer.data(), buffer.size()));

  plan_entry entry;
  entry.address = 4;
  entry.patch_bytes = {0xaa, 0xbb, 0xcc};
  entry.patch_mask = {1, 0, 1};
  entry.spec.required = true;

  auto result = apply_plan(space, {entry}, apply_options{});
  REQUIRE(result.ok());
  CHECK(result.value.success);
  CHECK(buffer[4] == 0xaa);
  CHECK(buffer[5] == 0x00);
  CHECK(buffer[6] == 0xcc);
}

TEST_CASE("apply returns error for invalid address") {
  auto buffer = make_buffer(8, 0x90);
  buffer_address_space space(std::span<uint8_t>(buffer.data(), buffer.size()));

  plan_entry entry;
  entry.address = 16;
  entry.patch_bytes = {0x11, 0x22};
  entry.patch_mask = {1, 1};
  entry.spec.required = true;

  auto result = apply_plan(space, {entry}, apply_options{});
  CHECK_FALSE(result.ok());
  CHECK(result.status_info.code == error_code::not_found);
}

TEST_CASE("apply reports optional failure without aborting") {
  auto buffer = make_buffer(8, 0x90);
  buffer_address_space space(std::span<uint8_t>(buffer.data(), buffer.size()));

  plan_entry required_entry;
  required_entry.address = 2;
  required_entry.patch_bytes = {0x11, 0x22};
  required_entry.patch_mask = {1, 1};
  required_entry.spec.required = true;

  plan_entry optional_entry;
  optional_entry.address = 32;
  optional_entry.patch_bytes = {0x33, 0x44};
  optional_entry.patch_mask = {1, 1};
  optional_entry.spec.required = false;

  auto result = apply_plan(space, {required_entry, optional_entry}, apply_options{});
  REQUIRE(result.ok());
  CHECK_FALSE(result.value.success);
  CHECK(result.value.applied == 1);
  CHECK(result.value.failed == 1);
  CHECK(buffer[2] == 0x11);
  CHECK(buffer[3] == 0x22);
}

TEST_CASE("apply skips writes for empty masks") {
  auto buffer = make_buffer(8, 0x90);
  buffer_address_space space(std::span<uint8_t>(buffer.data(), buffer.size()));

  plan_entry entry;
  entry.address = 1;
  entry.patch_bytes = {0xff, 0xee};
  entry.patch_mask = {0, 0};
  entry.spec.required = true;

  auto result = apply_plan(space, {entry}, apply_options{});
  REQUIRE(result.ok());
  CHECK(result.value.success);
  CHECK(buffer[1] == 0x90);
  CHECK(buffer[2] == 0x90);
}

```

`test/p1ll/core/pattern_matcher_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "p1ll/engine/pattern.hpp"
#include "p1ll/engine/pattern_matcher.hpp"

#include <vector>

namespace {

using p1ll::engine::parse_signature;
using p1ll::engine::pattern_matcher;

} // namespace

TEST_CASE("pattern matcher finds exact matches") {
  std::vector<uint8_t> data = {0x90, 0x48, 0x89, 0xe5, 0x90};
  auto parsed = parse_signature("48 89 e5");
  REQUIRE(parsed.ok());

  pattern_matcher matcher(parsed.value);
  auto matches = matcher.search(data.data(), data.size());
  REQUIRE(matches.size() == 1);
  CHECK(matches[0] == 1);
}

TEST_CASE("pattern matcher supports wildcards") {
  std::vector<uint8_t> data = {0x48, 0x89, 0xe5, 0x12, 0x90};
  auto parsed = parse_signature("48 89 ?? 12 90");
  REQUIRE(parsed.ok());

  pattern_matcher matcher(parsed.value);
  auto matches = matcher.search(data.data(), data.size());
  REQUIRE(matches.size() == 1);
  CHECK(matches[0] == 0);
}

TEST_CASE("pattern matcher handles overlapping matches") {
  std::vector<uint8_t> data = {0x90, 0x90, 0x90};
  auto parsed = parse_signature("90 90");
  REQUIRE(parsed.ok());

  pattern_matcher matcher(parsed.value);
  auto matches = matcher.search(data.data(), data.size());
  REQUIRE(matches.size() == 2);
  CHECK(matches[0] == 0);
  CHECK(matches[1] == 1);
}

TEST_CASE("pattern matcher reports single match only when unique") {
  std::vector<uint8_t> data = {0x90, 0x90, 0x90};
  auto parsed = parse_signature("90 90");
  REQUIRE(parsed.ok());

  pattern_matcher matcher(parsed.value);
  auto match = matcher.search_single(data.data(), data.size());
  CHECK_FALSE(match.has_value());
}

```

`test/p1ll/core/pattern_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "p1ll/engine/pattern.hpp"

namespace {

using p1ll::engine::error_code;
using p1ll::engine::parse_patch;
using p1ll::engine::parse_signature;

} // namespace

TEST_CASE("pattern parsing handles valid signatures") {
  auto parsed = parse_signature("48 89 e5 ?? 90");
  CHECK(parsed.ok());
  CHECK(parsed.value.bytes.size() == 5);
  CHECK(parsed.value.mask.size() == 5);
  CHECK(parsed.value.bytes[0] == 0x48);
  CHECK(parsed.value.bytes[1] == 0x89);
  CHECK(parsed.value.bytes[2] == 0xe5);
  CHECK(parsed.value.bytes[3] == 0x00);
  CHECK(parsed.value.bytes[4] == 0x90);
  CHECK(parsed.value.mask[3] == 0);
}

TEST_CASE("pattern parsing rejects invalid signatures") {
  auto parsed = parse_signature("zz 90");
  CHECK_FALSE(parsed.ok());
  CHECK(parsed.status_info.code == error_code::invalid_pattern);
}

TEST_CASE("pattern parsing normalizes whitespace") {
  auto parsed = parse_signature("  48\t89  e5\n90 ");
  CHECK(parsed.ok());
  CHECK(parsed.value.bytes.size() == 4);
}

TEST_CASE("pattern parsing handles patches") {
  auto parsed = parse_patch("ff ?? 0a");
  CHECK(parsed.ok());
  CHECK(parsed.value.bytes.size() == 3);
  CHECK(parsed.value.mask[1] == 0);
}

```

`test/p1ll/core/plan_builder_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "p1ll/engine/session.hpp"
#include "p1ll/engine/types.hpp"
#include "p1ll/engine/platform/platform.hpp"
#include "test_helpers.hpp"

#include <span>

namespace {

using p1ll::engine::error_code;
using p1ll::engine::patch_spec;
using p1ll::engine::recipe;
using p1ll::engine::scan_options;
using p1ll::engine::session;
using p1ll::engine::signature_spec;
using p1ll::engine::platform::platform_key;
using p1ll::test_helpers::make_buffer;
using p1ll::test_helpers::write_bytes;

} // namespace

TEST_CASE("plan builder produces entries for required patches") {
  auto buffer = make_buffer(64, 0x90);
  write_bytes(buffer, 8, {0xde, 0xad, 0xbe, 0xef});
  write_bytes(buffer, 24, {0x48, 0x89, 0xe5});

  signature_spec validation;
  validation.pattern = "de ad be ef";
  validation.options.single = true;

  patch_spec patch;
  patch.signature.pattern = "48 89 e5";
  patch.signature.options.single = true;
  patch.patch = "11 22 33";
  patch.required = true;

  recipe plan_recipe;
  plan_recipe.name = "basic";
  plan_recipe.validations.push_back(validation);
  plan_recipe.patches.push_back(patch);

  auto sess = session::for_buffer(std::span<uint8_t>(buffer.data(), buffer.size()));
  auto plan = sess.plan(plan_recipe);
  REQUIRE(plan.ok());
  REQUIRE(plan.value.size() == 1);
  CHECK(plan.value[0].address == 24);
  CHECK(plan.value[0].patch_bytes.size() == 3);
  CHECK(plan.value[0].patch_mask.size() == 3);
}

TEST_CASE("plan builder skips optional missing patches") {
  auto buffer = make_buffer(64, 0x90);
  write_bytes(buffer, 16, {0x48, 0x89, 0xe5});

  patch_spec required_patch;
  required_patch.signature.pattern = "48 89 e5";
  required_patch.signature.options.single = true;
  required_patch.patch = "11 22 33";
  required_patch.required = true;

  patch_spec optional_patch;
  optional_patch.signature.pattern = "ff ee dd";
  optional_patch.signature.options.single = true;
  optional_patch.patch = "aa bb cc";
  optional_patch.required = false;

  recipe plan_recipe;
  plan_recipe.patches.push_back(required_patch);
  plan_recipe.patches.push_back(optional_patch);

  auto sess = session::for_buffer(std::span<uint8_t>(buffer.data(), buffer.size()));
  auto plan = sess.plan(plan_recipe);
  REQUIRE(plan.ok());
  CHECK(plan.value.size() == 1);
}

TEST_CASE("plan builder reports missing required validations") {
  auto buffer = make_buffer(32, 0x90);

  signature_spec validation;
  validation.pattern = "de ad be ef";
  validation.options.single = true;
  validation.required = true;

  patch_spec patch;
  patch.signature.pattern = "48 89 e5";
  patch.signature.options.single = true;
  patch.patch = "11 22 33";
  patch.required = true;

  recipe plan_recipe;
  plan_recipe.validations.push_back(validation);
  plan_recipe.patches.push_back(patch);

  auto sess = session::for_buffer(std::span<uint8_t>(buffer.data(), buffer.size()));
  auto plan = sess.plan(plan_recipe);
  CHECK_FALSE(plan.ok());
  CHECK(plan.status_info.code == error_code::not_found);
}

TEST_CASE("plan builder enforces platform selectors") {
  auto buffer = make_buffer(32, 0x90);
  write_bytes(buffer, 4, {0x48, 0x89, 0xe5});

  patch_spec patch;
  patch.signature.pattern = "48 89 e5";
  patch.signature.options.single = true;
  patch.patch = "11 22 33";

  recipe plan_recipe;
  plan_recipe.platforms.push_back("linux:x64");
  plan_recipe.patches.push_back(patch);

  platform_key target{"darwin", "arm64"};
  auto sess = session::for_buffer(std::span<uint8_t>(buffer.data(), buffer.size()), target);
  auto plan = sess.plan(plan_recipe);
  CHECK_FALSE(plan.ok());
  CHECK(plan.status_info.code == error_code::platform_mismatch);
}

TEST_CASE("plan builder detects overlapping patches") {
  auto buffer = make_buffer(32, 0x90);
  write_bytes(buffer, 8, {0x48, 0x89, 0xe5});

  patch_spec patch_a;
  patch_a.signature.pattern = "48 89 e5";
  patch_a.signature.options.single = true;
  patch_a.patch = "11 22 33";
  patch_a.offset = 0;

  patch_spec patch_b;
  patch_b.signature.pattern = "48 89 e5";
  patch_b.signature.options.single = true;
  patch_b.patch = "aa bb cc";
  patch_b.offset = 1;

  recipe plan_recipe;
  plan_recipe.patches.push_back(patch_a);
  plan_recipe.patches.push_back(patch_b);

  auto sess = session::for_buffer(std::span<uint8_t>(buffer.data(), buffer.size()));
  auto plan = sess.plan(plan_recipe);
  CHECK_FALSE(plan.ok());
  CHECK(plan.status_info.code == error_code::overlap);
}

TEST_CASE("plan builder rejects invalid patch patterns") {
  auto buffer = make_buffer(32, 0x90);
  write_bytes(buffer, 4, {0x48, 0x89, 0xe5});

  patch_spec patch;
  patch.signature.pattern = "48 89 e5";
  patch.signature.options.single = true;
  patch.patch = "zz";
  patch.required = true;

  recipe plan_recipe;
  plan_recipe.patches.push_back(patch);

  auto sess = session::for_buffer(std::span<uint8_t>(buffer.data(), buffer.size()));
  auto plan = sess.plan(plan_recipe);
  CHECK_FALSE(plan.ok());
  CHECK(plan.status_info.code == error_code::invalid_pattern);
}

TEST_CASE("plan builder detects offset underflow") {
  auto buffer = make_buffer(32, 0x90);
  write_bytes(buffer, 2, {0x48, 0x89, 0xe5});

  patch_spec patch;
  patch.signature.pattern = "48 89 e5";
  patch.signature.options.single = true;
  patch.patch = "11 22 33";
  patch.offset = -8;

  recipe plan_recipe;
  plan_recipe.patches.push_back(patch);

  auto sess = session::for_buffer(std::span<uint8_t>(buffer.data(), buffer.size()));
  auto plan = sess.plan(plan_recipe);
  CHECK_FALSE(plan.ok());
  CHECK(plan.status_info.code == error_code::invalid_argument);
}

```

`test/p1ll/core/platform_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "p1ll/engine/platform/platform.hpp"

namespace {

using p1ll::engine::platform::any_platform_matches;
using p1ll::engine::platform::detect_platform;
using p1ll::engine::platform::parse_platform;
using p1ll::engine::platform::platform_key;
using p1ll::engine::platform::platform_matches;

} // namespace

TEST_CASE("platform parsing handles wildcards") {
  auto parsed = parse_platform("*");
  REQUIRE(parsed.ok());
  CHECK(parsed.value.os == "*");
  CHECK(parsed.value.arch == "*");
}

TEST_CASE("platform parsing handles os-only selectors") {
  auto parsed = parse_platform("darwin");
  REQUIRE(parsed.ok());
  CHECK(parsed.value.os == "darwin");
  CHECK(parsed.value.arch == "*");
}

TEST_CASE("platform parsing treats blank as wildcard") {
  auto parsed = parse_platform(" ");
  REQUIRE(parsed.ok());
  CHECK(parsed.value.os == "*");
  CHECK(parsed.value.arch == "*");
}

TEST_CASE("platform matching respects wildcards") {
  platform_key target{"darwin", "arm64"};
  CHECK(platform_matches("*", target));
  CHECK(platform_matches("darwin:*", target));
  CHECK_FALSE(platform_matches("linux:x64", target));
}

TEST_CASE("any_platform_matches accepts empty list") {
  platform_key target{"darwin", "arm64"};
  CHECK(any_platform_matches({}, target));
}

TEST_CASE("detect_platform returns non-empty values") {
  auto detected = detect_platform();
  CHECK_FALSE(detected.os.empty());
  CHECK_FALSE(detected.arch.empty());
}

```

`test/p1ll/core/scanner_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "p1ll/engine/address_space.hpp"
#include "p1ll/engine/pattern.hpp"
#include "p1ll/engine/scanner.hpp"
#include "p1ll/engine/types.hpp"
#include "test_helpers.hpp"

#include <span>

namespace {

using p1ll::engine::buffer_address_space;
using p1ll::engine::error_code;
using p1ll::engine::parse_signature;
using p1ll::engine::scan_options;
using p1ll::engine::scanner;
using p1ll::test_helpers::make_buffer;
using p1ll::test_helpers::write_bytes;

} // namespace

TEST_CASE("scanner finds matches in buffer") {
  auto buffer = make_buffer(64, 0x90);
  write_bytes(buffer, 8, {0x48, 0x89, 0xe5});
  write_bytes(buffer, 32, {0x48, 0x89, 0xe5});

  buffer_address_space space(std::span<uint8_t>(buffer.data(), buffer.size()));
  auto parsed = parse_signature("48 89 e5");
  REQUIRE(parsed.ok());

  scanner scan(space);
  auto results = scan.scan(parsed.value, scan_options{});
  REQUIRE(results.ok());
  CHECK(results.value.size() == 2);
  CHECK(results.value[0].address == 8);
  CHECK(results.value[1].address == 32);
}

TEST_CASE("scanner respects single match option") {
  auto buffer = make_buffer(64, 0x90);
  write_bytes(buffer, 8, {0x48, 0x89, 0xe5});
  write_bytes(buffer, 32, {0x48, 0x89, 0xe5});

  buffer_address_space space(std::span<uint8_t>(buffer.data(), buffer.size()));
  auto parsed = parse_signature("48 89 e5");
  REQUIRE(parsed.ok());

  scanner scan(space);
  scan_options options;
  options.single = true;

  auto results = scan.scan(parsed.value, options);
  CHECK_FALSE(results.ok());
  CHECK(results.status_info.code == error_code::multiple_matches);
}

TEST_CASE("scanner returns not found when single match required") {
  auto buffer = make_buffer(32, 0x90);

  buffer_address_space space(std::span<uint8_t>(buffer.data(), buffer.size()));
  auto parsed = parse_signature("48 89 e5");
  REQUIRE(parsed.ok());

  scanner scan(space);
  scan_options options;
  options.single = true;

  auto results = scan.scan(parsed.value, options);
  CHECK_FALSE(results.ok());
  CHECK(results.status_info.code == error_code::not_found);
}

TEST_CASE("scanner respects max_matches") {
  auto buffer = make_buffer(64, 0x90);
  write_bytes(buffer, 8, {0x48, 0x89, 0xe5});
  write_bytes(buffer, 32, {0x48, 0x89, 0xe5});

  buffer_address_space space(std::span<uint8_t>(buffer.data(), buffer.size()));
  auto parsed = parse_signature("48 89 e5");
  REQUIRE(parsed.ok());

  scanner scan(space);
  scan_options options;
  options.max_matches = 1;

  auto results = scan.scan(parsed.value, options);
  REQUIRE(results.ok());
  CHECK(results.value.size() == 1);
}

TEST_CASE("scanner ignores invalid name filters in static buffers") {
  auto buffer = make_buffer(32, 0x90);
  write_bytes(buffer, 4, {0xde, 0xad, 0xbe, 0xef});

  buffer_address_space space(std::span<uint8_t>(buffer.data(), buffer.size()));
  auto parsed = parse_signature("de ad be ef");
  REQUIRE(parsed.ok());

  scanner scan(space);
  scan_options options;
  options.filter.name_regex = "[";

  auto results = scan.scan(parsed.value, options);
  REQUIRE(results.ok());
  CHECK(results.value.size() == 1);
}

TEST_CASE("scanner filter excludes non-executable buffers") {
  auto buffer = make_buffer(32, 0x90);
  write_bytes(buffer, 4, {0xde, 0xad, 0xbe, 0xef});

  buffer_address_space space(std::span<uint8_t>(buffer.data(), buffer.size()));
  auto parsed = parse_signature("de ad be ef");
  REQUIRE(parsed.ok());

  scanner scan(space);
  scan_options options;
  options.filter.only_executable = true;

  auto results = scan.scan(parsed.value, options);
  REQUIRE(results.ok());
  CHECK(results.value.empty());
}

```

`test/p1ll/core/session_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "p1ll/engine/session.hpp"
#include "p1ll/engine/types.hpp"
#include "test_helpers.hpp"

#include <span>

namespace {

using p1ll::engine::error_code;
using p1ll::engine::session;
using p1ll::test_helpers::make_buffer;
using p1ll::test_helpers::write_bytes;

} // namespace

TEST_CASE("session scan rejects invalid patterns") {
  auto buffer = make_buffer(16, 0x90);
  auto sess = session::for_buffer(std::span<uint8_t>(buffer.data(), buffer.size()));

  p1ll::engine::scan_options options;
  auto result = sess.scan("zz", options);
  CHECK_FALSE(result.ok());
  CHECK(result.status_info.code == error_code::invalid_pattern);
}

TEST_CASE("session scan returns matches for valid patterns") {
  auto buffer = make_buffer(16, 0x90);
  write_bytes(buffer, 4, {0x48, 0x89, 0xe5});
  auto sess = session::for_buffer(std::span<uint8_t>(buffer.data(), buffer.size()));

  p1ll::engine::scan_options options;
  auto result = sess.scan("48 89 e5", options);
  REQUIRE(result.ok());
  CHECK(result.value.size() == 1);
  CHECK(result.value[0].address == 4);
}

```

`test/p1ll/core/test_helpers.hpp`:

```hpp
#pragma once

#include <algorithm>
#include <cstddef>
#include <cstdint>
#include <initializer_list>
#include <vector>

namespace p1ll::test_helpers {

inline std::vector<uint8_t> make_buffer(size_t size, uint8_t fill = 0x90) { return std::vector<uint8_t>(size, fill); }

inline void write_bytes(std::vector<uint8_t>& buffer, size_t offset, std::initializer_list<uint8_t> bytes) {
  if (offset >= buffer.size()) {
    return;
  }
  size_t count = std::min(buffer.size() - offset, bytes.size());
  std::copy(bytes.begin(), bytes.begin() + static_cast<std::ptrdiff_t>(count), buffer.begin() + offset);
}

} // namespace p1ll::test_helpers

```

`test/p1ll/core/test_main.cpp`:

```cpp
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "doctest/doctest.hpp"

```

`test/p1ll/heur/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${W1_SOURCE_DIR}/cmake/TestConfig.cmake)

set(P1LL_HEUR_TEST_SOURCES
    test_main.cpp
    heur_test.cpp
)

w1_add_doctest_suite(p1ll_heur_tests
    SOURCES ${P1LL_HEUR_TEST_SOURCES}
    INCLUDE_DIRS
        ${CMAKE_CURRENT_SOURCE_DIR}
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/third_party
    LIBS p1ll_heur
    OUTPUT_SUBDIR p1ll/heur
)

```

`test/p1ll/heur/heur_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "p1ll/heur/code_signature.hpp"
#include "w1asmr/asmr.hpp"

using p1ll::engine::platform::platform_key;
using p1ll::heur::code_signature;
using p1ll::heur::policy;
using w1::asmr::asm_context;
using w1::asmr::parse_arch_spec;

TEST_CASE("p1ll heuristic signature masks x64 immediates") {
  auto spec = parse_arch_spec("x64");
  REQUIRE(spec.ok());
  auto ctx = asm_context::for_arch(spec.value);
  REQUIRE(ctx.ok());

  auto bytes = ctx.value.assemble("mov eax, 0x11223344; ret", 0x4000);
  REQUIRE(bytes.ok());

  platform_key platform{"linux", "x64"};
  auto sig = code_signature(bytes.value, 0x4000, platform, policy::balanced);
  REQUIRE(sig.ok());
  CHECK(sig.value.pattern.find("??") != std::string::npos);
  CHECK(sig.value.pretty.find("//") != std::string::npos);
}

TEST_CASE("p1ll heuristic strict policy keeps x64 immediates") {
  auto spec = parse_arch_spec("x64");
  REQUIRE(spec.ok());
  auto ctx = asm_context::for_arch(spec.value);
  REQUIRE(ctx.ok());

  auto bytes = ctx.value.assemble("mov eax, 0x11223344; ret", 0x5000);
  REQUIRE(bytes.ok());

  platform_key platform{"linux", "x64"};
  auto sig = code_signature(bytes.value, 0x5000, platform, policy::strict);
  REQUIRE(sig.ok());
  CHECK(sig.value.pattern.find("??") == std::string::npos);
}

TEST_CASE("p1ll heuristic signature masks arm64 immediates") {
  auto spec = parse_arch_spec("arm64");
  REQUIRE(spec.ok());
  auto ctx = asm_context::for_arch(spec.value);
  REQUIRE(ctx.ok());

  auto bytes = ctx.value.assemble("mov x0, #0x1234; ret", 0x6000);
  REQUIRE(bytes.ok());

  platform_key platform{"darwin", "arm64"};
  auto sig = code_signature(bytes.value, 0x6000, platform, policy::balanced);
  REQUIRE(sig.ok());
  CHECK(sig.value.pattern.find("??") != std::string::npos);
}

```

`test/p1ll/heur/test_main.cpp`:

```cpp
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "doctest/doctest.hpp"

```

`test/w1analysis/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${W1_SOURCE_DIR}/cmake/TestConfig.cmake)

set(W1ANALYSIS_TEST_SOURCES
    ${W1_SOURCE_DIR}/test/common/test_main.cpp
    abi_dispatcher_test.cpp
    symbol_lookup_test.cpp
)

w1_add_doctest_suite(w1analysis_unit_tests
    SOURCES ${W1ANALYSIS_TEST_SOURCES}
    INCLUDE_DIRS
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/third_party
    LIBS
        w1analysis
    OUTPUT_SUBDIR w1analysis
)

```

`test/w1analysis/abi_dispatcher_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <array>

#include "w1analysis/abi_dispatcher.hpp"
#include "w1runtime/module_catalog.hpp"
#include "w1runtime/memory_reader.hpp"

TEST_CASE("abi_dispatcher extracts register arguments") {
  w1::runtime::module_catalog modules;
  w1::util::memory_reader memory(nullptr, modules);
  w1::analysis::abi_dispatcher dispatcher;

  QBDI::GPRState gpr{};

#if defined(QBDI_ARCH_X86_64)
  gpr.rdi = 11;
  gpr.rsi = 22;
  gpr.rdx = 33;
  gpr.rcx = 44;
  gpr.r8 = 55;
  gpr.r9 = 66;

  auto args = dispatcher.extract_arguments(memory, &gpr, 3);
  REQUIRE(args.size() == 3);
#if defined(_WIN32)
  CHECK(args[0].raw_value == 44);
  CHECK(args[1].raw_value == 33);
  CHECK(args[2].raw_value == 55);
#else
  CHECK(args[0].raw_value == 11);
  CHECK(args[1].raw_value == 22);
  CHECK(args[2].raw_value == 33);
#endif
#elif defined(QBDI_ARCH_AARCH64)
  gpr.x0 = 11;
  gpr.x1 = 22;
  gpr.x2 = 33;
  gpr.x3 = 44;

  auto args = dispatcher.extract_arguments(memory, &gpr, 3);
  REQUIRE(args.size() == 3);
  CHECK(args[0].raw_value == 11);
  CHECK(args[1].raw_value == 22);
  CHECK(args[2].raw_value == 33);
#elif defined(QBDI_ARCH_X86)
  auto args = dispatcher.extract_arguments(memory, &gpr, 1);
  REQUIRE(args.size() == 1);
  CHECK(args[0].is_valid == false);
#else
  auto args = dispatcher.extract_arguments(memory, &gpr, 1);
  CHECK(args.empty() || args[0].is_valid == false);
#endif
}

TEST_CASE("abi_dispatcher extracts stack arguments") {
  w1::runtime::module_catalog modules;
  w1::util::memory_reader memory(nullptr, modules);
  w1::analysis::abi_dispatcher dispatcher;

  QBDI::GPRState gpr{};

#if defined(QBDI_ARCH_X86_64) && !defined(_WIN32)
  std::array<uint64_t, 4> stack = {0xdead, 70, 80, 90};
  gpr.rsp = static_cast<QBDI::rword>(reinterpret_cast<uintptr_t>(stack.data()));

  auto args = dispatcher.extract_arguments(memory, &gpr, 7);
  REQUIRE(args.size() == 7);
  CHECK(args[6].raw_value == 70);
#elif defined(QBDI_ARCH_X86_64) && defined(_WIN32)
  std::array<uint64_t, 6> stack = {0xdead, 0, 0, 0, 0, 111};
  gpr.rsp = static_cast<QBDI::rword>(reinterpret_cast<uintptr_t>(stack.data()));

  auto args = dispatcher.extract_arguments(memory, &gpr, 5);
  REQUIRE(args.size() == 5);
  CHECK(args[4].raw_value == 111);
#elif defined(QBDI_ARCH_AARCH64)
  std::array<uint64_t, 2> stack = {99, 100};
  gpr.sp = static_cast<QBDI::rword>(reinterpret_cast<uintptr_t>(stack.data()));

  auto args = dispatcher.extract_arguments(memory, &gpr, 9);
  REQUIRE(args.size() == 9);
  CHECK(args[8].raw_value == 99);
#elif defined(QBDI_ARCH_X86)
  std::array<uint32_t, 3> stack = {0xdead, 123, 456};
  gpr.esp = static_cast<QBDI::rword>(reinterpret_cast<uintptr_t>(stack.data()));

  auto args = dispatcher.extract_arguments(memory, &gpr, 1);
  REQUIRE(args.size() == 1);
  CHECK(args[0].raw_value == 123);
#else
  auto args = dispatcher.extract_arguments(memory, &gpr, 1);
  CHECK(args.empty() || args[0].is_valid == false);
#endif
}

```

`test/w1analysis/symbol_lookup_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "w1analysis/symbol_lookup.hpp"
#include "w1runtime/module_catalog.hpp"

namespace {

int symbol_lookup_target(int value) { return value + 1; }

} // namespace

TEST_CASE("symbol_lookup resolves current symbol") {
  w1::runtime::module_catalog registry;
  registry.refresh();

  auto modules = registry.list_modules();
  if (modules.empty()) {
    WARN("module_catalog returned no modules; module scanning may be blocked");
    return;
  }

  w1::analysis::symbol_lookup lookup(&registry);
  uint64_t address = reinterpret_cast<uint64_t>(&symbol_lookup_target);

  auto module = registry.find_containing(address);
  REQUIRE(module != nullptr);

  auto info = lookup.resolve(address);
  REQUIRE(info.has_value());
  CHECK(info->address == address);
  CHECK(info->module_name.empty() == false);
  CHECK(info->module_offset == address - module->base_address);
  CHECK(info->module_offset < module->size);

  if (!info->has_symbol) {
    WARN("symbol_lookup did not resolve a symbol name for the target function");
  } else {
    CHECK(info->symbol_name.empty() == false);
  }

  CHECK(lookup.cache_size() > 0);
}

```

`test/w1asmr/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${W1_SOURCE_DIR}/cmake/TestConfig.cmake)

set(W1ASMR_TEST_SOURCES
    test_main.cpp
    asmr_test.cpp
)

w1_add_doctest_suite(w1asmr_tests
    SOURCES ${W1ASMR_TEST_SOURCES}
    INCLUDE_DIRS
        ${CMAKE_CURRENT_SOURCE_DIR}
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/third_party
    LIBS w1asmr
    OUTPUT_SUBDIR w1asmr
)

```

`test/w1asmr/asmr_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "w1asmr/asmr.hpp"

using w1::asmr::asm_context;
using w1::asmr::detect_host_arch_spec;
using w1::asmr::disasm_context;
using w1::asmr::parse_arch_spec;

TEST_CASE("w1asmr assembles and disassembles x64") {
  auto spec = parse_arch_spec("x64");
  REQUIRE(spec.ok());

  auto asm_ctx = asm_context::for_arch(spec.value);
  REQUIRE(asm_ctx.ok());
  auto dis_ctx = disasm_context::for_arch(spec.value);
  REQUIRE(dis_ctx.ok());

  auto bytes = asm_ctx.value.assemble("mov eax, 1; ret", 0x1000);
  REQUIRE(bytes.ok());
  CHECK(bytes.value.size() >= 2);

  auto disasm = dis_ctx.value.disassemble(bytes.value, 0x1000);
  REQUIRE(disasm.ok());
  REQUIRE(disasm.value.size() >= 2);
  CHECK(disasm.value.front().mnemonic == "mov");
  CHECK(disasm.value.back().mnemonic == "ret");
}

TEST_CASE("w1asmr assembles and disassembles x86") {
  auto spec = parse_arch_spec("x86");
  REQUIRE(spec.ok());

  auto asm_ctx = asm_context::for_arch(spec.value);
  REQUIRE(asm_ctx.ok());
  auto dis_ctx = disasm_context::for_arch(spec.value);
  REQUIRE(dis_ctx.ok());

  auto bytes = asm_ctx.value.assemble("mov eax, 1; ret", 0x2000);
  REQUIRE(bytes.ok());
  CHECK(bytes.value.size() >= 2);

  auto disasm = dis_ctx.value.disassemble(bytes.value, 0x2000);
  REQUIRE(disasm.ok());
  REQUIRE(disasm.value.size() >= 2);
  CHECK(disasm.value.front().mnemonic == "mov");
  CHECK(disasm.value.back().mnemonic == "ret");
}

TEST_CASE("w1asmr assembles and disassembles arm64") {
  auto spec = parse_arch_spec("arm64");
  REQUIRE(spec.ok());

  auto asm_ctx = asm_context::for_arch(spec.value);
  REQUIRE(asm_ctx.ok());
  auto dis_ctx = disasm_context::for_arch(spec.value);
  REQUIRE(dis_ctx.ok());

  auto bytes = asm_ctx.value.assemble("mov x0, #1; ret", 0x3000);
  REQUIRE(bytes.ok());
  CHECK(bytes.value.size() >= 4);

  auto disasm = dis_ctx.value.disassemble(bytes.value, 0x3000);
  REQUIRE(disasm.ok());
  REQUIRE(disasm.value.size() >= 2);
  CHECK(disasm.value.back().mnemonic == "ret");
}

TEST_CASE("w1asmr disassembles arm32 and thumb") {
  auto arm_spec = parse_arch_spec("arm");
  REQUIRE(arm_spec.ok());
  auto arm_ctx = disasm_context::for_arch(arm_spec.value);
  REQUIRE(arm_ctx.ok());

  std::vector<uint8_t> arm_bytes = {0x01, 0x00, 0xA0, 0xE3, 0x1E, 0xFF, 0x2F, 0xE1};
  auto arm_disasm = arm_ctx.value.disassemble(arm_bytes, 0x4000);
  REQUIRE(arm_disasm.ok());
  CHECK_FALSE(arm_disasm.value.empty());

  auto thumb_spec = parse_arch_spec("thumb");
  REQUIRE(thumb_spec.ok());
  auto thumb_ctx = disasm_context::for_arch(thumb_spec.value);
  REQUIRE(thumb_ctx.ok());

  std::vector<uint8_t> thumb_bytes = {0x01, 0x20, 0x70, 0x47};
  auto thumb_disasm = thumb_ctx.value.disassemble(thumb_bytes, 0x5000);
  REQUIRE(thumb_disasm.ok());
  CHECK_FALSE(thumb_disasm.value.empty());
}

TEST_CASE("w1asmr disassembles riscv64") {
  auto spec = parse_arch_spec("riscv64");
  REQUIRE(spec.ok());

  auto dis_ctx = disasm_context::for_arch(spec.value);
  REQUIRE(dis_ctx.ok());

  std::vector<uint8_t> bytes = {0x13, 0x00, 0x00, 0x00};
  auto disasm = dis_ctx.value.disassemble(bytes, 0x6000);
  REQUIRE(disasm.ok());
  CHECK_FALSE(disasm.value.empty());
}

TEST_CASE("w1asmr reports unsupported assembly targets") {
  auto spec = parse_arch_spec("systemz");
  REQUIRE(spec.ok());

  auto asm_ctx = asm_context::for_arch(spec.value);
  CHECK_FALSE(asm_ctx.ok());
  CHECK(asm_ctx.status_info.code == w1::asmr::error_code::unsupported);
}

TEST_CASE("w1asmr parses architecture aliases") {
  CHECK(parse_arch_spec("x86").ok());
  CHECK(parse_arch_spec("i386").ok());
  CHECK(parse_arch_spec("x64").ok());
  CHECK(parse_arch_spec("x86_64").ok());
  CHECK(parse_arch_spec("amd64").ok());
  CHECK(parse_arch_spec("arm64").ok());
  CHECK(parse_arch_spec("aarch64").ok());
  CHECK(parse_arch_spec("thumb:le").ok());

  CHECK(parse_arch_spec("x86_64").value.arch_mode == w1::arch::mode::x86_64);
  CHECK(parse_arch_spec("aarch64").value.arch_mode == w1::arch::mode::aarch64);
  CHECK(parse_arch_spec("i386").value.arch_mode == w1::arch::mode::x86_32);

  auto bad = parse_arch_spec("mystery");
  CHECK_FALSE(bad.ok());
}

TEST_CASE("w1asmr reports host architecture") {
  auto detected = detect_host_arch_spec();
  REQUIRE(detected.ok());
  CHECK(detected.value.arch_mode != w1::arch::mode::unknown);
}

```

`test/w1asmr/test_main.cpp`:

```cpp
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "doctest/doctest.hpp"

```

`test/w1base/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${W1_SOURCE_DIR}/cmake/TestConfig.cmake)

set(W1BASE_TEST_SOURCES
    ${W1_SOURCE_DIR}/test/common/test_main.cpp
    interval_test.cpp
)

w1_add_doctest_suite(w1base_unit_tests
    SOURCES ${W1BASE_TEST_SOURCES}
    INCLUDE_DIRS
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/third_party
    LIBS
        w1base
    OUTPUT_SUBDIR w1base
)

```

`test/w1base/interval_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "w1base/interval.hpp"

TEST_CASE("interval helpers validate ranges") {
  CHECK(w1::util::range_is_valid(0x1000, 0x2000) == true);
  CHECK(w1::util::range_is_valid(0x2000, 0x2000) == false);
  CHECK(w1::util::range_is_valid(0x3000, 0x2000) == false);
}

TEST_CASE("interval helpers compute size and containment") {
  CHECK(w1::util::range_size(0x1000, 0x1800) == 0x800);
  CHECK(w1::util::range_contains(0x1000, 0x2000, 0x1000) == true);
  CHECK(w1::util::range_contains(0x1000, 0x2000, 0x1fff) == true);
  CHECK(w1::util::range_contains(0x1000, 0x2000, 0x2000) == false);
}

TEST_CASE("interval helpers detect overlap") {
  CHECK(w1::util::range_overlaps(0x1000, 0x2000, 0x1800, 0x3000) == true);
  CHECK(w1::util::range_overlaps(0x1000, 0x2000, 0x2000, 0x3000) == false);
}

TEST_CASE("interval helpers compute end safely") {
  uint64_t end = 0;
  CHECK(w1::util::compute_end(0x1000, 0x200, &end));
  CHECK(end == 0x1200);

  uint64_t overflow_end = 0;
  CHECK(w1::util::compute_end(UINT64_MAX, 1, &overflow_end) == false);
}

```

`test/w1formats/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${W1_SOURCE_DIR}/cmake/TestConfig.cmake)

set(W1FORMATS_TEST_SOURCES
    ${W1_SOURCE_DIR}/test/common/test_main.cpp
    jsonl_writer_test.cpp
)

w1_add_doctest_suite(w1formats_unit_tests
    SOURCES ${W1FORMATS_TEST_SOURCES}
    INCLUDE_DIRS
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/third_party
    LIBS
        w1formats
    OUTPUT_SUBDIR w1formats
)

```

`test/w1formats/jsonl_writer_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <chrono>
#include <cstring>
#include <filesystem>
#include <fstream>
#include <string>

#if defined(_WIN32)
#include <process.h>
#else
#include <unistd.h>
#endif

#include "w1formats/jsonl_writer.hpp"

namespace {

std::filesystem::path make_temp_path() {
#if defined(_WIN32)
  int pid = _getpid();
#else
  int pid = getpid();
#endif

  auto now = std::chrono::steady_clock::now().time_since_epoch().count();
  std::string name =
      "w1formats_jsonl_writer_" + std::to_string(pid) + "_" + std::to_string(static_cast<long long>(now)) + ".jsonl";
  return std::filesystem::temp_directory_path() / name;
}

std::string read_file(const std::filesystem::path& path) {
  std::ifstream input(path, std::ios::in | std::ios::binary);
  std::string contents;
  std::string line;
  while (std::getline(input, line)) {
    contents += line;
    contents += '\n';
  }
  return contents;
}

} // namespace

TEST_CASE("jsonl_writer writes lines with newlines") {
  auto path = make_temp_path();
  w1::io::jsonl_writer_config config;
  config.buffer_size_bytes = 32;
  config.flush_event_count = 0;

  w1::io::jsonl_writer writer(path.string(), config);
  REQUIRE(writer.is_open());

  CHECK(writer.write_line("{\"a\":1}"));
  CHECK(writer.write_line("{\"b\":2}\n"));
  writer.flush();
  writer.close();

  std::string contents = read_file(path);
  CHECK(contents == "{\"a\":1}\n{\"b\":2}\n");

  std::filesystem::remove(path);
}

TEST_CASE("jsonl_writer counts events for raw writes") {
  auto path = make_temp_path();
  w1::io::jsonl_writer_config config;
  config.buffer_size_bytes = 64;
  config.flush_event_count = 0;

  w1::io::jsonl_writer writer(path.string(), config);
  REQUIRE(writer.is_open());

  const char* data = "alpha\nbeta\n";
  CHECK(writer.write_raw(data, std::strlen(data)));
  CHECK(writer.event_count() == 2);
  writer.flush();
  writer.close();

  std::filesystem::remove(path);
}

TEST_CASE("jsonl_writer flushes on byte threshold") {
  auto path = make_temp_path();
  w1::io::jsonl_writer_config config;
  config.buffer_size_bytes = 8;
  config.flush_event_count = 0;
  config.flush_byte_count = 4;

  w1::io::jsonl_writer writer(path.string(), config);
  REQUIRE(writer.is_open());

  const char* data = "abcd";
  CHECK(writer.write_raw(data, 4));
  CHECK(writer.flush_count() == 1);
  writer.close();

  std::filesystem::remove(path);
}

```

`test/w1h00k/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${W1_SOURCE_DIR}/cmake/TestConfig.cmake)

set(W1H00K_TEST_SOURCES
    test_main.cpp
    reloc_tests.cpp
    patcher_tests.cpp
    memory_tests.cpp
    resolve_tests.cpp
    module_match_tests.cpp
    inline_tests.cpp
    inline_detour_tests.cpp
    arg_access_tests.cpp
    instrument_tests.cpp
    import_table_tests.cpp
    interpose_tests.cpp
)

w1_add_doctest_suite(w1h00k_tests
    SOURCES ${W1H00K_TEST_SOURCES}
    INCLUDE_DIRS
        ${CMAKE_CURRENT_SOURCE_DIR}
        ${W1_SOURCE_DIR}/test/common
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/third_party
    LIBS w1h00k ${CMAKE_DL_LIBS}
    OUTPUT_SUBDIR w1h00k
)

```

`test/w1h00k/arg_access_tests.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <cstdint>

#include "w1h00k/core/hook_args.hpp"
#include "w1h00k/hook.hpp"

namespace {

uintptr_t addr(const void* ptr) { return reinterpret_cast<uintptr_t>(ptr); }

} // namespace

TEST_CASE("w1h00k arg accessors honor ABI layouts") {
  alignas(16) uint8_t int_regs[8 * sizeof(void*)] = {};
  alignas(16) uint8_t flt_regs[16 * 8] = {};
  alignas(16) uint8_t stack[128] = {};

  w1::h00k::hook_arg_handle args{};
  args.int_regs = int_regs;
  args.flt_regs = flt_regs;
  args.stack = stack;

  if constexpr (sizeof(void*) == 8) {
    args.abi = w1::h00k::hook_call_abi::sysv;
    CHECK(addr(w1::h00k::arg_get_int_reg_addr(&args, 0)) == addr(int_regs));
    CHECK(addr(w1::h00k::arg_get_int_reg_addr(&args, 5)) == addr(int_regs + 5 * 8));
    CHECK(w1::h00k::arg_get_int_reg_addr(&args, 6) == nullptr);
    CHECK(addr(w1::h00k::arg_get_flt_reg_addr(&args, 7)) == addr(flt_regs + 7 * 16));
    CHECK(w1::h00k::arg_get_flt_reg_addr(&args, 8) == nullptr);
    CHECK(addr(w1::h00k::arg_get_stack_addr(&args, 0)) == addr(stack + 8));

    args.abi = w1::h00k::hook_call_abi::win64;
    CHECK(addr(w1::h00k::arg_get_int_reg_addr(&args, 3)) == addr(int_regs + 3 * 8));
    CHECK(w1::h00k::arg_get_int_reg_addr(&args, 4) == nullptr);
    CHECK(addr(w1::h00k::arg_get_flt_reg_addr(&args, 3)) == addr(flt_regs + 3 * 16));
    CHECK(w1::h00k::arg_get_flt_reg_addr(&args, 4) == nullptr);
    CHECK(addr(w1::h00k::arg_get_stack_addr(&args, 0)) == addr(stack + 40));

    args.abi = w1::h00k::hook_call_abi::win64_vectorcall;
    CHECK(addr(w1::h00k::arg_get_flt_reg_addr(&args, 5)) == addr(flt_regs + 5 * 16));
    CHECK(w1::h00k::arg_get_flt_reg_addr(&args, 6) == nullptr);

    args.abi = w1::h00k::hook_call_abi::aapcs64;
    CHECK(addr(w1::h00k::arg_get_int_reg_addr(&args, 7)) == addr(int_regs + 7 * 8));
    CHECK(addr(w1::h00k::arg_get_flt_reg_addr(&args, 7)) == addr(flt_regs + 7 * 16));
    CHECK(addr(w1::h00k::arg_get_stack_addr(&args, 0)) == addr(stack));
  } else {
    args.abi = w1::h00k::hook_call_abi::sysv;
    CHECK(w1::h00k::arg_get_int_reg_addr(&args, 0) == nullptr);
    CHECK(addr(w1::h00k::arg_get_stack_addr(&args, 0)) == addr(stack + 4));

    args.abi = w1::h00k::hook_call_abi::win32_cdecl;
    CHECK(w1::h00k::arg_get_int_reg_addr(&args, 0) == nullptr);
    CHECK(addr(w1::h00k::arg_get_stack_addr(&args, 0)) == addr(stack + 4));

    args.abi = w1::h00k::hook_call_abi::win32_fastcall;
    CHECK(addr(w1::h00k::arg_get_int_reg_addr(&args, 1)) == addr(int_regs + 1 * 4));
    CHECK(w1::h00k::arg_get_int_reg_addr(&args, 2) == nullptr);
    CHECK(addr(w1::h00k::arg_get_stack_addr(&args, 0)) == addr(stack + 4));

    args.abi = w1::h00k::hook_call_abi::win32_thiscall;
    CHECK(addr(w1::h00k::arg_get_int_reg_addr(&args, 0)) == addr(int_regs));
    CHECK(w1::h00k::arg_get_int_reg_addr(&args, 1) == nullptr);
  }
}

```

`test/w1h00k/import_table_tests.cpp`:

```cpp
#include "doctest/doctest.hpp"

#if defined(_WIN32)
#include <windows.h>
#else
#include <unistd.h>
#endif

#include "w1h00k/hook.hpp"

namespace {

#if defined(_WIN32)
static HMODULE g_expected_handle = nullptr;
static HMODULE WINAPI replacement_get_module_handle(LPCSTR) { return g_expected_handle; }
#else
static pid_t g_expected_pid = 0;
static pid_t replacement_getpid() { return g_expected_pid; }
#endif

w1::h00k::hook_request make_import_request(const char* symbol, void* replacement) {
  w1::h00k::hook_request request{};
  request.target.kind = w1::h00k::hook_target_kind::import_slot;
  request.target.symbol = symbol;
  request.replacement = replacement;
#if defined(_WIN32)
  request.preferred = w1::h00k::hook_technique::iat;
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::iat);
#else
  request.preferred = w1::h00k::hook_technique::plt_got;
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::plt_got);
#endif
  return request;
}

} // namespace

TEST_CASE("w1h00k import-table hook replaces slot") {
#if defined(_WIN32)
  const HMODULE original = GetModuleHandleA(nullptr);
  g_expected_handle = reinterpret_cast<HMODULE>(0x12345678);
  REQUIRE(original != g_expected_handle);

  auto request = make_import_request("GetModuleHandleA", reinterpret_cast<void*>(&replacement_get_module_handle));
  void* original_ptr = nullptr;
  auto result = w1::h00k::attach(request, &original_ptr);
  REQUIRE(result.error.ok());

  CHECK(GetModuleHandleA(nullptr) == g_expected_handle);
  CHECK(w1::h00k::detach(result.handle) == w1::h00k::hook_error::ok);
  CHECK(GetModuleHandleA(nullptr) == original);
#else
  const pid_t original = getpid();
  g_expected_pid = original + 1;

  auto request = make_import_request("getpid", reinterpret_cast<void*>(&replacement_getpid));
  void* original_ptr = nullptr;
  auto result = w1::h00k::attach(request, &original_ptr);
  REQUIRE(result.error.ok());

  CHECK(getpid() == g_expected_pid);
  CHECK(w1::h00k::detach(result.handle) == w1::h00k::hook_error::ok);
  CHECK(getpid() == original);
#endif
}

```

`test/w1h00k/inline_detour_tests.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <array>
#include <string>

#include "w1base/arch_spec.hpp"
#include "w1h00k/backend/inline/inline_detour.hpp"

namespace {

w1::arch::arch_spec parse_arch_or(const char* name, const w1::arch::arch_spec& fallback) {
  w1::arch::arch_spec spec{};
  std::string error;
  if (!w1::arch::parse_arch_spec(name, spec, error)) {
    return fallback;
  }
  return spec;
}

} // namespace

TEST_CASE("w1h00k inline detour plans rel32 for x86_32") {
  auto spec = parse_arch_or("x86", w1::arch::detect_host_arch_spec());

  auto plan = w1::h00k::backend::inline_hook::plan_for(spec, 0x1000, 0x2000);
  CHECK(plan.arch == w1::h00k::backend::inline_hook::arch_kind::x86_32);
  CHECK(plan.kind == w1::h00k::backend::inline_hook::detour_kind::rel32);
  CHECK(plan.min_patch == 5);
  CHECK(plan.tail_size == 5);
}

TEST_CASE("w1h00k inline detour plans rel32 for x86_64 when near") {
  auto spec = parse_arch_or("x86_64", w1::arch::detect_host_arch_spec());

  auto plan = w1::h00k::backend::inline_hook::plan_for(spec, 0x1000, 0x2000);
  CHECK(plan.arch == w1::h00k::backend::inline_hook::arch_kind::x86_64);
  CHECK(plan.kind == w1::h00k::backend::inline_hook::detour_kind::rel32);
  CHECK(plan.min_patch == 5);
  CHECK(plan.tail_size == 14);
}

TEST_CASE("w1h00k inline detour plans absolute for x86_64 when far") {
  auto spec = parse_arch_or("x86_64", w1::arch::detect_host_arch_spec());

  const uint64_t from = 0x1000;
  const uint64_t to = from + 0x1'0000'0000ULL;
  auto plan = w1::h00k::backend::inline_hook::plan_for(spec, from, to);
  CHECK(plan.kind == w1::h00k::backend::inline_hook::detour_kind::absolute);
  CHECK(plan.min_patch == 14);
  CHECK(plan.tail_size == 14);
}

TEST_CASE("w1h00k inline detour plans absolute for arm64") {
  auto spec = parse_arch_or("arm64", w1::arch::detect_host_arch_spec());

  auto plan = w1::h00k::backend::inline_hook::plan_for(spec, 0x1000, 0x2000);
  CHECK(plan.arch == w1::h00k::backend::inline_hook::arch_kind::arm64);
  CHECK(plan.kind == w1::h00k::backend::inline_hook::detour_kind::absolute);
  CHECK(plan.min_patch == 16);
  CHECK(plan.tail_size == 16);
}

TEST_CASE("w1h00k inline detour prologue safety for arm64") {
  auto spec = parse_arch_or("arm64", w1::arch::detect_host_arch_spec());

  auto plan = w1::h00k::backend::inline_hook::plan_for(spec, 0x1000, 0x2000);
  const std::array<uint8_t, 16> ret_then_nops = {
      0xC0, 0x03, 0x5F, 0xD6, // ret
      0x1F, 0x20, 0x03, 0xD5, // nop
      0x1F, 0x20, 0x03, 0xD5, // nop
      0x1F, 0x20, 0x03, 0xD5  // nop
  };
  CHECK(w1::h00k::backend::inline_hook::prologue_safe(plan, ret_then_nops.data(), ret_then_nops.size()));

  const std::array<uint8_t, 16> ret_then_data = {
      0xC0, 0x03, 0x5F, 0xD6, // ret
      0x00, 0x00, 0x00, 0x58, // ldr x0, #0
      0x00, 0x00, 0x00, 0x58, // ldr x0, #0
      0x00, 0x00, 0x00, 0x58  // ldr x0, #0
  };
  CHECK_FALSE(w1::h00k::backend::inline_hook::prologue_safe(plan, ret_then_data.data(), ret_then_data.size()));
}

```

`test/w1h00k/inline_tests.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <cstdint>
#include <string>

#if defined(_WIN32)
#include <windows.h>
#else
#include <dlfcn.h>
#include <unistd.h>
#endif

#include "w1h00k/hook.hpp"
#include "test_paths.hpp"

namespace {

#if defined(_MSC_VER)
#define W1_NO_INLINE __declspec(noinline)
#else
#define W1_NO_INLINE __attribute__((noinline))
#endif

volatile int g_sink = 0;

W1_NO_INLINE int add_one(int value) {
  int result = value + 1;
  g_sink = result;
  return result;
}

W1_NO_INLINE int add_ten(int value) {
  int result = value + 10;
  g_sink = result;
  return result;
}

W1_NO_INLINE int mul_two(int value) {
  int result = value * 2;
  g_sink = result;
  return result;
}

W1_NO_INLINE int mul_three(int value) {
  int result = value * 3;
  g_sink = result;
  return result;
}

#if defined(_WIN32)
using interpose_lib_fn = HMODULE (*)();
static HMODULE g_expected_handle = nullptr;

static HMODULE WINAPI replacement_interpose() { return g_expected_handle; }
#else
using interpose_lib_fn = pid_t (*)();
static pid_t g_expected_pid = 0;

static pid_t replacement_interpose() { return g_expected_pid; }
#endif

struct interpose_library {
#if defined(_WIN32)
  HMODULE handle = nullptr;
#else
  void* handle = nullptr;
#endif

  explicit interpose_library(const std::string& path) {
#if defined(_WIN32)
    handle = LoadLibraryA(path.c_str());
#else
    handle = dlopen(path.c_str(), RTLD_NOW);
#endif
  }

  ~interpose_library() {
#if defined(_WIN32)
    if (handle) {
      FreeLibrary(handle);
    }
#else
    if (handle) {
      dlclose(handle);
    }
#endif
  }

  interpose_library(const interpose_library&) = delete;
  interpose_library& operator=(const interpose_library&) = delete;
};

interpose_lib_fn load_interpose_symbol(
#if defined(_WIN32)
    HMODULE handle
#else
    void* handle
#endif
) {
  if (!handle) {
    return nullptr;
  }
#if defined(_WIN32)
  return reinterpret_cast<interpose_lib_fn>(GetProcAddress(handle, "w1h00k_interpose_get_module_handle_inline"));
#else
  return reinterpret_cast<interpose_lib_fn>(dlsym(handle, "w1h00k_interpose_getpid_inline"));
#endif
}

w1::h00k::hook_request make_inline_request(void* target, void* replacement) {
  w1::h00k::hook_request request{};
  request.target.kind = w1::h00k::hook_target_kind::address;
  request.target.address = target;
  request.replacement = replacement;
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::inline_trampoline);
  return request;
}

} // namespace

TEST_CASE("w1h00k inline hook replaces and detaches") {
  using fn_t = int (*)(int);
  fn_t target = &add_one;
  fn_t replacement = &add_ten;

  auto request = make_inline_request(reinterpret_cast<void*>(target), reinterpret_cast<void*>(replacement));

  void* original = nullptr;
  auto result = w1::h00k::attach(request, &original);
  REQUIRE(result.error.ok());
  REQUIRE(original != nullptr);

  CHECK(target(1) == 11);
  auto orig_fn = reinterpret_cast<fn_t>(original);
  CHECK(orig_fn(1) == 2);

  CHECK(w1::h00k::detach(result.handle) == w1::h00k::hook_error::ok);
  CHECK(target(1) == 2);
}

TEST_CASE("w1h00k inline hook rejects invalid target") {
  w1::h00k::hook_request request{};
  request.replacement = reinterpret_cast<void*>(&add_ten);

  void* original = nullptr;
  auto result = w1::h00k::attach(request, &original);
  CHECK(result.error.code == w1::h00k::hook_error::invalid_target);
  CHECK(original == nullptr);
}

TEST_CASE("w1h00k inline hook respects allowed mask") {
  auto request = make_inline_request(reinterpret_cast<void*>(&add_one), reinterpret_cast<void*>(&add_ten));
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::interpose);

  void* original = nullptr;
  auto result = w1::h00k::attach(request, &original);
  CHECK(result.error.code == w1::h00k::hook_error::unsupported);
  CHECK(original == nullptr);
}

TEST_CASE("w1h00k inline hook rejects missing preferred backend") {
  auto request = make_inline_request(reinterpret_cast<void*>(&add_one), reinterpret_cast<void*>(&add_ten));
  request.preferred = w1::h00k::hook_technique::interpose;
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::interpose) |
                    w1::h00k::technique_mask(w1::h00k::hook_technique::inline_trampoline);

  void* original = nullptr;
  auto result = w1::h00k::attach(request, &original);
  CHECK(result.error.code == w1::h00k::hook_error::unsupported);
  CHECK(original == nullptr);
}

TEST_CASE("w1h00k inline hook falls back when allowed") {
  auto request = make_inline_request(reinterpret_cast<void*>(&add_one), reinterpret_cast<void*>(&add_ten));
  request.preferred = w1::h00k::hook_technique::interpose;
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::interpose) |
                    w1::h00k::technique_mask(w1::h00k::hook_technique::inline_trampoline);
  request.selection = w1::h00k::hook_selection::allow_fallback;

  void* original = nullptr;
  auto result = w1::h00k::attach(request, &original);
  REQUIRE(result.error.ok());
  CHECK(original != nullptr);
  CHECK(w1::h00k::detach(result.handle) == w1::h00k::hook_error::ok);
}

TEST_CASE("w1h00k inline hook reports unresolved symbol") {
  w1::h00k::hook_request request{};
  request.target.kind = w1::h00k::hook_target_kind::symbol;
  request.target.symbol = "w1h00k_missing_symbol";
  request.replacement = reinterpret_cast<void*>(&add_ten);
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::inline_trampoline);

  void* original = nullptr;
  auto result = w1::h00k::attach(request, &original);
  CHECK(result.error.code == w1::h00k::hook_error::not_found);
  CHECK(original == nullptr);
}

TEST_CASE("w1h00k inline hook rejects duplicate attach") {
  auto request = make_inline_request(reinterpret_cast<void*>(&add_one), reinterpret_cast<void*>(&add_ten));

  void* original = nullptr;
  auto result = w1::h00k::attach(request, &original);
  REQUIRE(result.error.ok());

  auto duplicate = w1::h00k::attach(request, nullptr);
  CHECK(duplicate.error.code == w1::h00k::hook_error::already_hooked);

  CHECK(w1::h00k::detach(result.handle) == w1::h00k::hook_error::ok);
}

TEST_CASE("w1h00k inline hook detach handles missing handle") {
  w1::h00k::hook_handle handle{};
  handle.id = 9999;
  CHECK(w1::h00k::detach(handle) == w1::h00k::hook_error::not_found);
}

TEST_CASE("w1h00k inline hook transaction attach") {
  using fn_t = int (*)(int);
  fn_t target = &mul_two;
  fn_t replacement = &mul_three;

  auto request = make_inline_request(reinterpret_cast<void*>(target), reinterpret_cast<void*>(replacement));

  w1::h00k::hook_transaction txn;
  void* original = nullptr;
  auto result = txn.attach(request, &original);
  REQUIRE(result.error.ok());
  REQUIRE(original != nullptr);
  REQUIRE(result.handle.id != 0);

  CHECK(txn.commit() == w1::h00k::hook_error::ok);
  CHECK(target(3) == 9);

  CHECK(w1::h00k::detach(result.handle) == w1::h00k::hook_error::ok);
  CHECK(target(3) == 6);
}

TEST_CASE("w1h00k inline transaction abort leaves target untouched") {
  using fn_t = int (*)(int);
  fn_t target = &add_one;
  fn_t replacement = &add_ten;

  auto request = make_inline_request(reinterpret_cast<void*>(target), reinterpret_cast<void*>(replacement));

  w1::h00k::hook_handle handle{};
  {
    w1::h00k::hook_transaction txn;
    auto result = txn.attach(request, nullptr);
    REQUIRE(result.error.ok());
    handle = result.handle;
  }

  CHECK(target(1) == 2);
  CHECK(w1::h00k::detach(handle) == w1::h00k::hook_error::not_found);
}

TEST_CASE("w1h00k inline hook stress") {
  using fn_t = int (*)(int);
  fn_t target = &add_one;
  fn_t replacement = &add_ten;

  auto request = make_inline_request(reinterpret_cast<void*>(target), reinterpret_cast<void*>(replacement));

  void* original = nullptr;
  auto result = w1::h00k::attach(request, &original);
  REQUIRE(result.error.ok());

  int sum = 0;
  for (int i = 0; i < 10000; ++i) {
    sum += target(i);
  }
  CHECK(sum > 0);

  CHECK(w1::h00k::detach(result.handle) == w1::h00k::hook_error::ok);
}

TEST_CASE("w1h00k inline hook resolves symbols in loaded modules") {
  const auto lib_path = w1::test_paths::interpose_library_path();
  interpose_library lib(lib_path);
  REQUIRE(lib.handle != nullptr);
  auto entry = load_interpose_symbol(lib.handle);
  REQUIRE(entry != nullptr);

#if defined(_WIN32)
  const HMODULE original = entry();
  g_expected_handle = reinterpret_cast<HMODULE>(0x12345678);
  REQUIRE(original != g_expected_handle);

  w1::h00k::hook_request request{};
  request.target.kind = w1::h00k::hook_target_kind::symbol;
  request.target.symbol = "w1h00k_interpose_get_module_handle_inline";
  request.target.module = w1::test_paths::interpose_library_name();
  request.replacement = reinterpret_cast<void*>(&replacement_interpose);
  request.preferred = w1::h00k::hook_technique::inline_trampoline;
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::inline_trampoline);
  request.selection = w1::h00k::hook_selection::strict;
#else
  const pid_t original = entry();
  g_expected_pid = original + 1;

  w1::h00k::hook_request request{};
  request.target.kind = w1::h00k::hook_target_kind::symbol;
  request.target.symbol = "w1h00k_interpose_getpid_inline";
  request.target.module = w1::test_paths::interpose_library_name();
  request.replacement = reinterpret_cast<void*>(&replacement_interpose);
  request.preferred = w1::h00k::hook_technique::inline_trampoline;
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::inline_trampoline);
  request.selection = w1::h00k::hook_selection::strict;
#endif

  void* original_ptr = nullptr;
  auto result = w1::h00k::attach(request, &original_ptr);
  std::string error_detail = result.error.detail ? result.error.detail : "(none)";
  CAPTURE(static_cast<int>(result.error.code));
  CAPTURE(error_detail);
  CAPTURE(result.error.os_error);
  REQUIRE(result.error.ok());
  REQUIRE(original_ptr != nullptr);

#if defined(_WIN32)
  CHECK(entry() == g_expected_handle);
  auto orig_fn = reinterpret_cast<interpose_lib_fn>(original_ptr);
  CHECK(orig_fn() == original);
#else
  CHECK(entry() == g_expected_pid);
  auto orig_fn = reinterpret_cast<interpose_lib_fn>(original_ptr);
  CHECK(orig_fn() == original);
#endif

  CHECK(w1::h00k::detach(result.handle) == w1::h00k::hook_error::ok);
  CHECK(entry() == original);
}

```

`test/w1h00k/instrument_tests.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <cstdint>
#include <cstring>

#include "w1h00k/hook.hpp"

namespace {

#if defined(_MSC_VER)
#define W1_NO_INLINE __declspec(noinline)
#else
#define W1_NO_INLINE __attribute__((noinline))
#endif

volatile int g_int_sink = 0;
volatile double g_fp_sink = 0.0;

W1_NO_INLINE double mixed_args(
    int a0, double f0, int a1, float f1, int a2, int a3, int a4, int a5, int a6, int a7, int a8
) {
  int sum = a0 + a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8;
  double fsum = f0 + static_cast<double>(f1);
  g_int_sink = sum;
  g_fp_sink = fsum;
  return static_cast<double>(sum) + fsum;
}

struct capture_state {
  bool called = false;
  bool has_int0 = false;
  bool has_int1 = false;
  bool has_f0 = false;
  bool has_f1 = false;
  bool has_stack0 = false;
  int int0 = 0;
  int int1 = 0;
  int stack0 = 0;
  double f0 = 0.0;
  float f1 = 0.0f;
};

capture_state g_capture{};

int read_int_arg(const void* addr) {
  if (!addr) {
    return 0;
  }
  if constexpr (sizeof(void*) == 4) {
    int32_t value = 0;
    std::memcpy(&value, addr, sizeof(value));
    return static_cast<int>(value);
  }
  int64_t value = 0;
  std::memcpy(&value, addr, sizeof(value));
  return static_cast<int>(value);
}

double read_double_arg(const void* addr) {
  double value = 0.0;
  if (addr) {
    std::memcpy(&value, addr, sizeof(value));
  }
  return value;
}

float read_float_arg(const void* addr) {
  float value = 0.0f;
  if (addr) {
    std::memcpy(&value, addr, sizeof(value));
  }
  return value;
}

void prehook(w1::h00k::hook_info* info) {
  g_capture = {};
  g_capture.called = true;

  if (auto* ptr = w1::h00k::arg_get_int_reg_addr(info->args, 0)) {
    g_capture.int0 = read_int_arg(ptr);
    g_capture.has_int0 = true;
  }

  int int1_index = 1;
  int f0_index = 0;
  int f1_index = 1;

#if defined(_WIN32) && (defined(_M_X64) || defined(__x86_64__))
  int1_index = 2;
  f0_index = 1;
  f1_index = 3;
#endif

  if (auto* ptr = w1::h00k::arg_get_int_reg_addr(info->args, int1_index)) {
    g_capture.int1 = read_int_arg(ptr);
    g_capture.has_int1 = true;
  }

  if (auto* ptr = w1::h00k::arg_get_flt_reg_addr(info->args, f0_index)) {
    g_capture.f0 = read_double_arg(ptr);
    g_capture.has_f0 = true;
  }
  if (auto* ptr = w1::h00k::arg_get_flt_reg_addr(info->args, f1_index)) {
    g_capture.f1 = read_float_arg(ptr);
    g_capture.has_f1 = true;
  }

  if (auto* ptr = w1::h00k::arg_get_stack_addr(info->args, 0)) {
    g_capture.stack0 = read_int_arg(ptr);
    g_capture.has_stack0 = true;
  }
}

} // namespace

TEST_CASE("w1h00k instrumentation prehook captures arguments") {
  constexpr int a0 = 1;
  constexpr double f0 = 2.5;
  constexpr int a1 = 3;
  constexpr float f1 = 4.25f;
  constexpr int a2 = 5;
  constexpr int a3 = 6;
  constexpr int a4 = 7;
  constexpr int a5 = 8;
  constexpr int a6 = 9;
  constexpr int a7 = 10;
  constexpr int a8 = 11;

  w1::h00k::hook_request request{};
  request.target.kind = w1::h00k::hook_target_kind::address;
  request.target.address = reinterpret_cast<void*>(&mixed_args);
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::inline_trampoline);
  request.kind = w1::h00k::hook_kind::instrument;
  request.prehook = &prehook;

  void* original = nullptr;
  auto result = w1::h00k::attach(request, &original);
  REQUIRE(result.error.ok());
  REQUIRE(original != nullptr);

  const double expected =
      static_cast<double>(a0 + a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8) + f0 + static_cast<double>(f1);

  g_capture = {};
  double out = mixed_args(a0, f0, a1, f1, a2, a3, a4, a5, a6, a7, a8);
  CHECK(doctest::Approx(out) == expected);

  CHECK(g_capture.called);
#if defined(__aarch64__) || defined(_M_ARM64)
  const int expected_stack0 = a8;
#elif defined(_WIN32) && (defined(_M_X64) || defined(__x86_64__))
  const int expected_stack0 = a2;
#elif defined(__x86_64__) || defined(_M_X64)
  const int expected_stack0 = a6;
#else
  const int expected_stack0 = a0;
#endif

#if defined(__x86_64__) || defined(_M_X64) || defined(__aarch64__) || defined(_M_ARM64)
  CHECK(g_capture.has_int0);
  CHECK(g_capture.int0 == a0);
  CHECK(g_capture.has_int1);
  CHECK(g_capture.int1 == a1);
  CHECK(g_capture.has_f0);
  CHECK(doctest::Approx(g_capture.f0) == f0);
  CHECK(g_capture.has_f1);
  CHECK(doctest::Approx(static_cast<double>(g_capture.f1)) == static_cast<double>(f1));
#else
  CHECK(!g_capture.has_int0);
  CHECK(!g_capture.has_int1);
  CHECK(!g_capture.has_f0);
  CHECK(!g_capture.has_f1);
#endif

  CHECK(g_capture.has_stack0);
  CHECK(g_capture.stack0 == expected_stack0);

  CHECK(w1::h00k::detach(result.handle) == w1::h00k::hook_error::ok);

  g_capture = {};
  out = mixed_args(a0, f0, a1, f1, a2, a3, a4, a5, a6, a7, a8);
  CHECK(doctest::Approx(out) == expected);
  CHECK(!g_capture.called);
}

#if defined(_WIN32) && defined(_M_IX86)
W1_NO_INLINE int __fastcall fastcall_add(int a, int b, int c) {
  int result = a + b + c;
  g_int_sink = result;
  return result;
}

struct fastcall_state {
  bool called = false;
  int a = 0;
  int b = 0;
};

fastcall_state g_fastcall{};

void prehook_fastcall(w1::h00k::hook_info* info) {
  g_fastcall = {};
  g_fastcall.called = true;
  if (auto* ptr = w1::h00k::arg_get_int_reg_addr(info->args, 0)) {
    g_fastcall.a = read_int_arg(ptr);
  }
  if (auto* ptr = w1::h00k::arg_get_int_reg_addr(info->args, 1)) {
    g_fastcall.b = read_int_arg(ptr);
  }
}

TEST_CASE("w1h00k instrumentation supports win32 fastcall") {
  w1::h00k::hook_request request{};
  request.target.kind = w1::h00k::hook_target_kind::address;
  request.target.address = reinterpret_cast<void*>(&fastcall_add);
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::inline_trampoline);
  request.kind = w1::h00k::hook_kind::instrument;
  request.call_abi = w1::h00k::hook_call_abi::win32_fastcall;
  request.prehook = &prehook_fastcall;

  void* original = nullptr;
  auto result = w1::h00k::attach(request, &original);
  REQUIRE(result.error.ok());

  g_fastcall = {};
  CHECK(fastcall_add(1, 2, 3) == 6);
  CHECK(g_fastcall.called);
  CHECK(g_fastcall.a == 1);
  CHECK(g_fastcall.b == 2);

  CHECK(w1::h00k::detach(result.handle) == w1::h00k::hook_error::ok);
}
#endif

#if defined(_WIN32) && defined(_M_X64) && defined(_MSC_VER)
W1_NO_INLINE double __vectorcall vectorcall_sum(double a, double b, double c, double d, double e, double f) {
  double result = a + b + c + d + e + f;
  g_fp_sink = result;
  return result;
}

struct vectorcall_state {
  bool called = false;
  double e = 0.0;
  double f = 0.0;
};

vectorcall_state g_vectorcall{};

void prehook_vectorcall(w1::h00k::hook_info* info) {
  g_vectorcall = {};
  g_vectorcall.called = true;
  if (auto* ptr = w1::h00k::arg_get_flt_reg_addr(info->args, 4)) {
    g_vectorcall.e = read_double_arg(ptr);
  }
  if (auto* ptr = w1::h00k::arg_get_flt_reg_addr(info->args, 5)) {
    g_vectorcall.f = read_double_arg(ptr);
  }
}

TEST_CASE("w1h00k instrumentation supports win64 vectorcall registers") {
  w1::h00k::hook_request request{};
  request.target.kind = w1::h00k::hook_target_kind::address;
  request.target.address = reinterpret_cast<void*>(&vectorcall_sum);
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::inline_trampoline);
  request.kind = w1::h00k::hook_kind::instrument;
  request.call_abi = w1::h00k::hook_call_abi::win64_vectorcall;
  request.prehook = &prehook_vectorcall;

  void* original = nullptr;
  auto result = w1::h00k::attach(request, &original);
  REQUIRE(result.error.ok());

  g_vectorcall = {};
  CHECK(doctest::Approx(vectorcall_sum(1.0, 2.0, 3.0, 4.0, 5.0, 6.0)) == 21.0);
  CHECK(g_vectorcall.called);
  CHECK(doctest::Approx(g_vectorcall.e) == 5.0);
  CHECK(doctest::Approx(g_vectorcall.f) == 6.0);

  CHECK(w1::h00k::detach(result.handle) == w1::h00k::hook_error::ok);
}
#endif

```

`test/w1h00k/interpose_tests.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <string>

#if defined(_WIN32)
#include <windows.h>
#else
#include <dlfcn.h>
#include <unistd.h>
#endif

#include "w1h00k/hook.hpp"
#include "test_paths.hpp"

namespace {

#if defined(_WIN32)
using interpose_lib_fn = HMODULE (*)();
static HMODULE g_expected_handle = nullptr;

static HMODULE WINAPI replacement_get_module_handle(LPCSTR) { return g_expected_handle; }
#else
using interpose_lib_fn = pid_t (*)();
static pid_t g_expected_pid = 0;

static pid_t replacement_getpid() { return g_expected_pid; }
#endif

std::string interpose_library_path() { return w1::test_paths::interpose_library_path(); }

struct interpose_library {
#if defined(_WIN32)
  HMODULE handle = nullptr;
#else
  void* handle = nullptr;
#endif

  explicit interpose_library(const std::string& path) {
#if defined(_WIN32)
    handle = LoadLibraryA(path.c_str());
#else
    handle = dlopen(path.c_str(), RTLD_NOW);
#endif
  }

  ~interpose_library() {
#if defined(_WIN32)
    if (handle) {
      FreeLibrary(handle);
    }
#else
    if (handle) {
      dlclose(handle);
    }
#endif
  }

  interpose_library(const interpose_library&) = delete;
  interpose_library& operator=(const interpose_library&) = delete;
};

interpose_lib_fn load_interpose_entry(
#if defined(_WIN32)
    HMODULE handle
#else
    void* handle
#endif
) {
  if (!handle) {
    return nullptr;
  }
#if defined(_WIN32)
  return reinterpret_cast<interpose_lib_fn>(GetProcAddress(handle, "w1h00k_interpose_get_module_handle"));
#else
  return reinterpret_cast<interpose_lib_fn>(dlsym(handle, "w1h00k_interpose_getpid"));
#endif
}

w1::h00k::hook_request make_interpose_request(const char* symbol, void* replacement) {
  w1::h00k::hook_request request{};
  request.target.kind = w1::h00k::hook_target_kind::symbol;
  request.target.symbol = symbol;
  request.replacement = replacement;
  request.preferred = w1::h00k::hook_technique::interpose;
  request.allowed = w1::h00k::technique_mask(w1::h00k::hook_technique::interpose);
  return request;
}

} // namespace

TEST_CASE("w1h00k interpose hooks loaded modules") {
  const auto lib_path = interpose_library_path();
  interpose_library lib(lib_path);
  REQUIRE(lib.handle != nullptr);
  auto entry = load_interpose_entry(lib.handle);
  REQUIRE(entry != nullptr);

#if defined(_WIN32)
  const HMODULE original_main = GetModuleHandleA(nullptr);
  const HMODULE original_lib = entry();
  g_expected_handle = reinterpret_cast<HMODULE>(0x12345678);
  REQUIRE(original_main != g_expected_handle);

  auto request = make_interpose_request("GetModuleHandleA", reinterpret_cast<void*>(&replacement_get_module_handle));
#else
  const pid_t original_main = getpid();
  const pid_t original_lib = entry();
  g_expected_pid = original_main + 1;

  auto request = make_interpose_request("getpid", reinterpret_cast<void*>(&replacement_getpid));
#endif

  void* original_ptr = nullptr;
  auto result = w1::h00k::attach(request, &original_ptr);
  REQUIRE(result.error.ok());

#if defined(_WIN32)
  CHECK(GetModuleHandleA(nullptr) == g_expected_handle);
  CHECK(entry() == g_expected_handle);
#else
  CHECK(getpid() == g_expected_pid);
  CHECK(entry() == g_expected_pid);
#endif

  CHECK(w1::h00k::detach(result.handle) == w1::h00k::hook_error::ok);

#if defined(_WIN32)
  CHECK(GetModuleHandleA(nullptr) == original_main);
  CHECK(entry() == original_lib);
#else
  CHECK(getpid() == original_main);
  CHECK(entry() == original_lib);
#endif
}

TEST_CASE("w1h00k interpose respects module filter") {
  const auto lib_path = interpose_library_path();
  interpose_library lib(lib_path);
  REQUIRE(lib.handle != nullptr);
  auto entry = load_interpose_entry(lib.handle);
  REQUIRE(entry != nullptr);

#if defined(_WIN32)
  const HMODULE original_main = GetModuleHandleA(nullptr);
  const HMODULE original_lib = entry();
  g_expected_handle = reinterpret_cast<HMODULE>(0x76543210);
  REQUIRE(original_main != g_expected_handle);

  auto request = make_interpose_request("GetModuleHandleA", reinterpret_cast<void*>(&replacement_get_module_handle));
#else
  const pid_t original_main = getpid();
  const pid_t original_lib = entry();
  g_expected_pid = original_main + 2;

  auto request = make_interpose_request("getpid", reinterpret_cast<void*>(&replacement_getpid));
#endif

  request.target.module = w1::test_paths::interpose_library_name();

  auto result = w1::h00k::attach(request, nullptr);
  REQUIRE(result.error.ok());

#if defined(_WIN32)
  CHECK(GetModuleHandleA(nullptr) == original_main);
  CHECK(entry() == g_expected_handle);
#else
  CHECK(getpid() == original_main);
  CHECK(entry() == g_expected_pid);
#endif

  CHECK(w1::h00k::detach(result.handle) == w1::h00k::hook_error::ok);

#if defined(_WIN32)
  CHECK(GetModuleHandleA(nullptr) == original_main);
  CHECK(entry() == original_lib);
#else
  CHECK(getpid() == original_main);
  CHECK(entry() == original_lib);
#endif
}

```

`test/w1h00k/memory_tests.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <cstdint>

#include "w1h00k/memory/memory.hpp"
#include "w1h00k/patcher/patcher.hpp"

TEST_CASE("w1h00k executable allocation basics") {
  const size_t request_size = 64;
  auto block = w1::h00k::memory::allocate_executable(request_size);
  REQUIRE(block.ok());
  CHECK(block.size >= request_size);

  auto* bytes = static_cast<uint8_t*>(block.address);
  w1::h00k::code_patcher patcher;
  const uint8_t payload[4] = {0x5A, 0x5A, 0x5A, 0x5A};
  CHECK(patcher.write(bytes, payload, sizeof(payload)));
  CHECK(bytes[0] == 0x5A);

  w1::h00k::memory::free_executable(block);
}

TEST_CASE("w1h00k executable allocation rejects zero size") {
  auto block = w1::h00k::memory::allocate_executable(0);
  CHECK_FALSE(block.ok());
  CHECK(block.address == nullptr);
  CHECK(block.size == 0);
}

TEST_CASE("w1h00k near allocation returns memory") {
  uint8_t anchor = 0;
  constexpr size_t range = 256 * 1024 * 1024;
  auto block = w1::h00k::memory::allocate_near(&anchor, 128, range);
  if (!block.ok()) {
    WARN("allocate_near failed; no suitable region found within range");
    return;
  }

  const uintptr_t anchor_addr = reinterpret_cast<uintptr_t>(&anchor);
  const uintptr_t block_addr = reinterpret_cast<uintptr_t>(block.address);
  const uintptr_t distance = block_addr >= anchor_addr ? block_addr - anchor_addr : anchor_addr - block_addr;
  CHECK(distance <= range);

  w1::h00k::memory::free_executable(block);
}

TEST_CASE("w1h00k near allocation validates inputs") {
  uint8_t anchor = 0;
  CHECK_FALSE(w1::h00k::memory::allocate_near(nullptr, 16, 1024).ok());
  CHECK_FALSE(w1::h00k::memory::allocate_near(&anchor, 0, 1024).ok());
  CHECK_FALSE(w1::h00k::memory::allocate_near(&anchor, 16, 0).ok());
}

TEST_CASE("w1h00k near allocation rejects too-small range") {
  uint8_t anchor = 0;
  auto block = w1::h00k::memory::allocate_near(&anchor, 4096, 1);
  CHECK_FALSE(block.ok());
}

```

`test/w1h00k/module_match_tests.cpp`:

```cpp
#include <ostream>
#include <string_view>

#include "doctest/doctest.hpp"

#include "w1h00k/resolve/module_match.hpp"

using w1::h00k::resolve::basename_view;
using w1::h00k::resolve::has_path_separator;
using w1::h00k::resolve::module_match_mode;
using w1::h00k::resolve::module_matches;
using w1::h00k::resolve::normalize_match_mode;

TEST_CASE("w1h00k module_match basename_view strips path") {
  CHECK(basename_view("libfoo.so") == std::string_view("libfoo.so"));
  CHECK(basename_view("/usr/lib/libfoo.so") == std::string_view("libfoo.so"));
  CHECK(basename_view("C:\\Windows\\System32\\kernel32.dll") == std::string_view("kernel32.dll"));
}

TEST_CASE("w1h00k module_match detects path separators") {
  CHECK_FALSE(has_path_separator("libfoo.so"));
  CHECK(has_path_separator("/usr/lib/libfoo.so"));
  CHECK(has_path_separator("C:\\Windows\\System32\\kernel32.dll"));
}

TEST_CASE("w1h00k module_match normalizes auto-detect") {
  CHECK(normalize_match_mode("libfoo.so", module_match_mode::auto_detect) == module_match_mode::basename);
  CHECK(normalize_match_mode("/usr/lib/libfoo.so", module_match_mode::auto_detect) == module_match_mode::full_path);
  CHECK(normalize_match_mode("libfoo.so", module_match_mode::full_path) == module_match_mode::full_path);
}

TEST_CASE("w1h00k module_matches honors mode selection") {
  CHECK(module_matches("libfoo.so", "/usr/lib/libfoo.so"));
  CHECK_FALSE(module_matches("libfoo.so", "/usr/lib/libfoo.so", module_match_mode::full_path));
  CHECK(module_matches("/usr/lib/libfoo.so", "/usr/lib/libfoo.so", module_match_mode::full_path));
  CHECK_FALSE(module_matches("/usr/lib/libfoo.so", "/usr/lib/libbar.so", module_match_mode::full_path));
  CHECK(module_matches("/usr/lib/libfoo.so", "/usr/lib/libfoo.so", module_match_mode::basename));
}

TEST_CASE("w1h00k module_matches handles empty request") {
  CHECK(module_matches("", "/usr/lib/libfoo.so"));
  CHECK(module_matches(nullptr, "/usr/lib/libfoo.so"));
  CHECK(module_matches("", ""));
}

TEST_CASE("w1h00k module_matches rejects empty path") { CHECK_FALSE(module_matches("libfoo.so", "")); }

TEST_CASE("w1h00k module_matches casing behavior") {
#if defined(_WIN32)
  CHECK(module_matches("KERNEL32.DLL", "C:\\Windows\\System32\\kernel32.dll"));
  CHECK(module_matches("C:\\WINDOWS\\SYSTEM32\\KERNEL32.DLL", "C:\\Windows\\System32\\kernel32.dll"));
#else
  CHECK_FALSE(module_matches("LIBFOO.SO", "/usr/lib/libfoo.so"));
#endif
}

```

`test/w1h00k/patcher_tests.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <cstdint>
#include <cstring>

#include "w1h00k/memory/memory.hpp"
#include "w1h00k/patcher/patcher.hpp"

TEST_CASE("w1h00k patcher writes and restores bytes") {
  auto block = w1::h00k::memory::allocate_executable(w1::h00k::memory::page_size());
  REQUIRE(block.ok());

  auto* bytes = static_cast<uint8_t*>(block.address);

  w1::h00k::code_patcher patcher;

  const uint8_t initial[4] = {0xAA, 0xAA, 0xAA, 0xAA};
  CHECK(patcher.write(bytes, initial, sizeof(initial)));

  const uint8_t patch[4] = {0x11, 0x22, 0x33, 0x44};
  CHECK(patcher.write(bytes, patch, sizeof(patch)));
  CHECK(std::memcmp(bytes, patch, sizeof(patch)) == 0);

  CHECK(patcher.restore(bytes, initial, sizeof(initial)));
  CHECK(std::memcmp(bytes, initial, sizeof(initial)) == 0);

  w1::h00k::memory::free_executable(block);
}

TEST_CASE("w1h00k patcher rejects invalid inputs") {
  w1::h00k::code_patcher patcher;
  uint8_t data[4] = {0, 1, 2, 3};
  CHECK_FALSE(patcher.write(nullptr, data, sizeof(data)));
  CHECK_FALSE(patcher.write(data, nullptr, sizeof(data)));
  CHECK_FALSE(patcher.write(data, data, 0));
}

TEST_CASE("w1h00k patcher handles zero-sized restore") {
  w1::h00k::code_patcher patcher;
  uint8_t data[1] = {0x90};
  CHECK_FALSE(patcher.restore(data, data, 0));
}

TEST_CASE("w1h00k data patcher writes and restores values") {
  uint32_t value = 0x11111111u;
  w1::h00k::data_patcher patcher;

  const uint32_t patch = 0x22222222u;
  CHECK(patcher.write(&value, reinterpret_cast<const uint8_t*>(&patch), sizeof(patch)));
  CHECK(value == patch);

  const uint32_t restore = 0x11111111u;
  CHECK(patcher.restore(&value, reinterpret_cast<const uint8_t*>(&restore), sizeof(restore)));
  CHECK(value == restore);
}

```

`test/w1h00k/reloc_tests.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <algorithm>
#include <cstdint>
#include <cstring>
#include <sstream>
#include <string>
#include <vector>

#include "w1asmr/asmr.hpp"
#include "w1base/arch_spec.hpp"
#include "w1h00k/reloc/common.hpp"
#include "w1h00k/reloc/relocator.hpp"

namespace {

bool disasm_supported(const w1::arch::arch_spec& spec) {
  auto ctx = w1::asmr::disasm_context::for_arch(spec);
  return ctx.ok();
}

std::vector<uint8_t> assemble_or_empty(const w1::arch::arch_spec& spec, std::string_view text, uint64_t address) {
  auto ctx = w1::asmr::asm_context::for_arch(spec);
  if (!ctx.ok()) {
    return {};
  }
  auto bytes = ctx.value.assemble(text, address);
  if (!bytes.ok()) {
    return {};
  }
  return bytes.value;
}

std::string hex_addr(uint64_t value) {
  std::ostringstream oss;
  oss << "0x" << std::hex << value;
  return oss.str();
}

w1::arch::arch_spec parse_arch_or(const char* name, const w1::arch::arch_spec& fallback) {
  w1::arch::arch_spec spec{};
  std::string error;
  if (!w1::arch::parse_arch_spec(name, spec, error)) {
    return fallback;
  }
  return spec;
}

std::vector<uint8_t> nop_bytes_for_arch(const w1::arch::arch_spec& spec) {
  switch (spec.arch_mode) {
  case w1::arch::mode::aarch64:
    return {0x1F, 0x20, 0x03, 0xD5};
  case w1::arch::mode::x86_64:
  case w1::arch::mode::x86_32:
    return {0x90};
  default:
    return {};
  }
}

std::vector<uint8_t> branch_bytes_for_arch(const w1::arch::arch_spec& spec) {
  switch (spec.arch_mode) {
  case w1::arch::mode::aarch64:
    return {0x02, 0x00, 0x00, 0x14}; // b #8
  case w1::arch::mode::x86_64:
  case w1::arch::mode::x86_32:
    return {0xE9, 0x01, 0x00, 0x00, 0x00}; // jmp rel32
  default:
    return {};
  }
}

std::vector<uint8_t> pc_relative_bytes_for_arch(const w1::arch::arch_spec& spec) {
  switch (spec.arch_mode) {
  case w1::arch::mode::aarch64:
    return {0x00, 0x00, 0x00, 0x10}; // adr x0, #0
  case w1::arch::mode::x86_64:
    return {0x8B, 0x05, 0x00, 0x00, 0x00, 0x00}; // mov eax, dword ptr [rip+0]
  default:
    return {};
  }
}

std::vector<uint8_t> arm64_bcond_bytes() {
  return {0x40, 0x00, 0x00, 0x54}; // b.eq #8
}

std::vector<uint8_t> arm64_adrp_bytes() {
  return {0x00, 0x00, 0x00, 0x90}; // adrp x0, #0
}

uint32_t read_u32_le(const uint8_t* bytes) {
  uint32_t value = 0;
  std::memcpy(&value, bytes, sizeof(value));
  return value;
}

uint64_t read_u64_le(const uint8_t* bytes) {
  uint64_t value = 0;
  std::memcpy(&value, bytes, sizeof(value));
  return value;
}

int64_t sign_extend(uint64_t value, unsigned bits) {
  if (bits == 0 || bits >= 64) {
    return static_cast<int64_t>(value);
  }
  const uint64_t mask = 1ULL << (bits - 1);
  return static_cast<int64_t>((value ^ mask) - mask);
}

uint64_t arm64_decode_target(uint32_t inst, uint64_t pc) {
  if ((inst & 0xFC000000u) == 0x14000000u || (inst & 0xFC000000u) == 0x94000000u) {
    const int64_t imm26 = sign_extend(inst & 0x03FFFFFFu, 26) << 2;
    return pc + static_cast<uint64_t>(imm26);
  }
  if ((inst & 0xFF000010u) == 0x54000000u || (inst & 0x7F000000u) == 0x34000000u ||
      (inst & 0x7F000000u) == 0x35000000u) {
    const int64_t imm19 = sign_extend((inst >> 5) & 0x7FFFFu, 19) << 2;
    return pc + static_cast<uint64_t>(imm19);
  }
  if ((inst & 0x7F000000u) == 0x36000000u || (inst & 0x7F000000u) == 0x37000000u) {
    const int64_t imm14 = sign_extend((inst >> 5) & 0x3FFFu, 14) << 2;
    return pc + static_cast<uint64_t>(imm14);
  }
  if ((inst & 0x9F000000u) == 0x10000000u) { // adr
    const uint32_t immlo = (inst >> 29) & 0x3u;
    const uint32_t immhi = (inst >> 5) & 0x7FFFFu;
    const int64_t imm = sign_extend((immhi << 2) | immlo, 21);
    return pc + static_cast<uint64_t>(imm);
  }
  if ((inst & 0x9F000000u) == 0x90000000u) { // adrp
    const uint32_t immlo = (inst >> 29) & 0x3u;
    const uint32_t immhi = (inst >> 5) & 0x7FFFFu;
    const int64_t imm = sign_extend((immhi << 2) | immlo, 21) << 12;
    const uint64_t page = pc & ~0xFFFULL;
    return page + static_cast<uint64_t>(imm);
  }
  return pc;
}

int32_t read_s32_le(const uint8_t* bytes) {
  int32_t value = 0;
  std::memcpy(&value, bytes, sizeof(value));
  return value;
}

std::vector<uint8_t> make_filled_buffer(
    const std::vector<uint8_t>& code, size_t total_size, const std::vector<uint8_t>& filler
) {
  REQUIRE(!filler.empty());
  std::vector<uint8_t> buffer(total_size, 0);
  size_t offset = 0;
  while (offset + filler.size() <= buffer.size()) {
    std::copy(filler.begin(), filler.end(), buffer.begin() + static_cast<std::ptrdiff_t>(offset));
    offset += filler.size();
  }
  if (!code.empty()) {
    const size_t copy_size = std::min(code.size(), buffer.size());
    std::copy(code.begin(), code.begin() + static_cast<std::ptrdiff_t>(copy_size), buffer.begin());
  }
  return buffer;
}

} // namespace

TEST_CASE("w1h00k relocator copies simple instructions") {
  auto spec = w1::arch::detect_host_arch_spec();
  auto nop = nop_bytes_for_arch(spec);
  if (nop.empty()) {
    CHECK(true);
    return;
  }

  std::vector<uint8_t> code;
  for (int i = 0; i < 4; ++i) {
    code.insert(code.end(), nop.begin(), nop.end());
  }
  auto buffer = make_filled_buffer(code, 64, nop);

  const uint64_t tramp = reinterpret_cast<uint64_t>(buffer.data()) + 0x1000;
  auto result = w1::h00k::reloc::relocate(buffer.data(), 4, tramp);

  CHECK(result.ok());
  CHECK(result.patch_size >= 4);
  CHECK(result.trampoline_bytes.size() == result.patch_size);
  CHECK(std::equal(result.trampoline_bytes.begin(), result.trampoline_bytes.end(), buffer.begin()));
}

TEST_CASE("w1h00k relocator rejects null target") {
  auto result = w1::h00k::reloc::relocate(nullptr, 4);
  CHECK(result.patch_size == 0);
  CHECK(result.error == w1::h00k::reloc::reloc_error::invalid_target);
}

TEST_CASE("w1h00k relocator rejects unsupported arch") {
  auto spec = parse_arch_or("riscv64", w1::arch::detect_host_arch_spec());
  if (!disasm_supported(spec)) {
    CHECK(true);
    return;
  }
  const std::vector<uint8_t> filler = {0x90, 0x90, 0x90, 0x90};
  auto result = w1::h00k::reloc::relocate(filler.data(), 4, 0, spec);
  CHECK(result.patch_size == 0);
  CHECK(result.error == w1::h00k::reloc::reloc_error::unsupported_arch);
}

TEST_CASE("w1h00k relocator reports conservative trampoline bound") {
  auto spec = w1::arch::detect_host_arch_spec();
  const size_t bound = w1::h00k::reloc::max_trampoline_size(4, spec);
  CHECK(bound > 0);

  const size_t patch_bytes = w1::h00k::reloc::detail::kMaxPatchBytes;
  auto ceil_div = [](size_t num, size_t den) { return (num + den - 1) / den; };

  switch (spec.arch_mode) {
  case w1::arch::mode::x86_32: {
    const size_t max_insns = ceil_div(patch_bytes, 2);
    CHECK(bound >= max_insns * 12);
    break;
  }
  case w1::arch::mode::x86_64: {
    const size_t max_insns = ceil_div(patch_bytes, 2);
    CHECK(bound >= max_insns * 16);
    break;
  }
  case w1::arch::mode::aarch64: {
    const size_t max_insns = ceil_div(patch_bytes, 4);
    CHECK(bound >= max_insns * 20);
    break;
  }
  default:
    CHECK(true);
    break;
  }
}

TEST_CASE("w1h00k relocator requires trampoline address for pc-relative") {
  auto spec = w1::arch::detect_host_arch_spec();
  auto pc_relative = pc_relative_bytes_for_arch(spec);
  if (pc_relative.empty()) {
    CHECK(true);
    return;
  }

  auto filler = nop_bytes_for_arch(spec);
  auto buffer = make_filled_buffer(pc_relative, 64, filler);

  auto result = w1::h00k::reloc::relocate(buffer.data(), pc_relative.size());

  CHECK(result.patch_size == 0);
  CHECK(result.trampoline_bytes.empty());
  CHECK(result.error == w1::h00k::reloc::reloc_error::missing_trampoline);
}

TEST_CASE("w1h00k relocator requires trampoline address for branch-relative") {
  auto spec = parse_arch_or("x86_64", w1::arch::detect_host_arch_spec());
  if (spec.arch_mode != w1::arch::mode::x86_64 || !disasm_supported(spec)) {
    CHECK(true);
    return;
  }

  const std::vector<uint8_t> jmp = {0xE9, 0x05, 0x00, 0x00, 0x00};
  const std::vector<uint8_t> filler = {0x90};
  auto buffer = make_filled_buffer(jmp, 64, filler);

  auto result = w1::h00k::reloc::relocate(buffer.data(), jmp.size(), 0, spec);

  CHECK(result.patch_size == 0);
  CHECK(result.trampoline_bytes.empty());
  CHECK(result.error == w1::h00k::reloc::reloc_error::missing_trampoline);
}

TEST_CASE("w1h00k relocator adjusts x86_64 rel32 branches") {
  auto spec = parse_arch_or("x86_64", w1::arch::detect_host_arch_spec());
  if (spec.arch_mode != w1::arch::mode::x86_64 || !disasm_supported(spec)) {
    CHECK(true);
    return;
  }

  const std::vector<uint8_t> jmp = {0xE9, 0x05, 0x00, 0x00, 0x00};
  const std::vector<uint8_t> filler = {0x90};
  auto buffer = make_filled_buffer(jmp, 64, filler);

  const uint64_t origin = reinterpret_cast<uint64_t>(buffer.data());
  const uint64_t tramp = origin + 0x2000;
  auto result = w1::h00k::reloc::relocate(buffer.data(), jmp.size(), tramp, spec);

  CHECK(result.ok());
  REQUIRE(result.patch_size == jmp.size());
  const int32_t disp = read_s32_le(result.trampoline_bytes.data() + 1);
  const int64_t expected = static_cast<int64_t>(origin + 10) - static_cast<int64_t>(tramp + 5);
  CHECK(disp == expected);
}

TEST_CASE("w1h00k relocator adjusts x86_64 call rel32 (asmr)") {
  auto spec = parse_arch_or("x86_64", w1::arch::detect_host_arch_spec());
  if (spec.arch_mode != w1::arch::mode::x86_64 || !disasm_supported(spec)) {
    CHECK(true);
    return;
  }

  std::vector<uint8_t> filler = {0x90};
  auto buffer = make_filled_buffer({}, 64, filler);
  const uint64_t origin = reinterpret_cast<uint64_t>(buffer.data());
  const uint64_t target_addr = origin + 0x20;
  auto bytes = assemble_or_empty(spec, "call " + hex_addr(target_addr), origin);
  if (bytes.empty()) {
    WARN("asmr assembly unavailable for x86_64 call");
    return;
  }
  std::copy(bytes.begin(), bytes.end(), buffer.begin());

  const uint64_t tramp = origin + 0x4000;
  auto result = w1::h00k::reloc::relocate(buffer.data(), bytes.size(), tramp, spec);

  CHECK(result.ok());
  REQUIRE(result.patch_size == bytes.size());
  const int32_t disp = read_s32_le(result.trampoline_bytes.data() + 1);
  const int64_t expected = static_cast<int64_t>(target_addr) - static_cast<int64_t>(tramp + bytes.size());
  CHECK(disp == expected);
}

TEST_CASE("w1h00k relocator adjusts x86_64 rip-relative memory") {
  auto spec = parse_arch_or("x86_64", w1::arch::detect_host_arch_spec());
  if (spec.arch_mode != w1::arch::mode::x86_64 || !disasm_supported(spec)) {
    CHECK(true);
    return;
  }

  const std::vector<uint8_t> mov = {0x8B, 0x05, 0x00, 0x00, 0x00, 0x00};
  const std::vector<uint8_t> filler = {0x90};
  auto buffer = make_filled_buffer(mov, 64, filler);

  const uint64_t origin = reinterpret_cast<uint64_t>(buffer.data());
  const uint64_t tramp = origin + 0x3000;
  auto result = w1::h00k::reloc::relocate(buffer.data(), mov.size(), tramp, spec);

  CHECK(result.ok());
  REQUIRE(result.patch_size == mov.size());
  const int32_t disp = read_s32_le(result.trampoline_bytes.data() + 2);
  const int64_t expected = static_cast<int64_t>(origin + 6) - static_cast<int64_t>(tramp + 6);
  CHECK(disp == expected);
}

TEST_CASE("w1h00k relocator adjusts x86_32 rel32 branches") {
  auto spec = parse_arch_or("x86", w1::arch::detect_host_arch_spec());
  if (spec.arch_mode != w1::arch::mode::x86_32 || !disasm_supported(spec)) {
    CHECK(true);
    return;
  }

  const std::vector<uint8_t> jmp = {0xE9, 0x05, 0x00, 0x00, 0x00};
  const std::vector<uint8_t> filler = {0x90};
  auto buffer = make_filled_buffer(jmp, 64, filler);

  const uint64_t origin = reinterpret_cast<uint64_t>(buffer.data());
  const uint64_t tramp = origin + 0x1000;
  auto result = w1::h00k::reloc::relocate(buffer.data(), jmp.size(), tramp, spec);

  CHECK(result.ok());
  REQUIRE(result.patch_size == jmp.size());
  const int32_t disp = read_s32_le(result.trampoline_bytes.data() + 1);
  const int64_t expected = static_cast<int64_t>(origin + 10) - static_cast<int64_t>(tramp + 5);
  CHECK(disp == expected);
}

TEST_CASE("w1h00k relocator adjusts arm64 branch targets") {
  auto spec = w1::arch::detect_host_arch_spec();
  if (spec.arch_mode != w1::arch::mode::aarch64) {
    CHECK(true);
    return;
  }

  auto branch = branch_bytes_for_arch(spec);
  auto filler = nop_bytes_for_arch(spec);
  auto buffer = make_filled_buffer(branch, 64, filler);

  const uint64_t target_addr = reinterpret_cast<uint64_t>(buffer.data());
  const uint64_t tramp = target_addr + 0x1000;
  auto result = w1::h00k::reloc::relocate(buffer.data(), branch.size(), tramp);

  CHECK(result.ok());
  REQUIRE(result.patch_size == branch.size());
  const uint32_t relocated = read_u32_le(result.trampoline_bytes.data());
  const uint64_t relocated_target = arm64_decode_target(relocated, tramp);

  CHECK(relocated_target == target_addr + 8);
}

TEST_CASE("w1h00k relocator emits arm64 branch stub when out of range") {
  auto spec = w1::arch::detect_host_arch_spec();
  if (spec.arch_mode != w1::arch::mode::aarch64) {
    CHECK(true);
    return;
  }

  auto branch = branch_bytes_for_arch(spec);
  auto filler = nop_bytes_for_arch(spec);
  auto buffer = make_filled_buffer(branch, 64, filler);

  const uint64_t origin = reinterpret_cast<uint64_t>(buffer.data());
  const uint64_t tramp = origin + 0x20000000ULL; // beyond +/-128MB branch range
  auto result = w1::h00k::reloc::relocate(buffer.data(), branch.size(), tramp);

  CHECK(result.ok());
  REQUIRE(result.patch_size == branch.size());
  REQUIRE(result.trampoline_bytes.size() == 16);

  const uint32_t ldr = read_u32_le(result.trampoline_bytes.data());
  CHECK((ldr & 0xFF000000u) == 0x58000000u);
  CHECK((ldr & 0x1Fu) == 16u);
  CHECK(((ldr >> 5) & 0x7FFFFu) == 2u);

  const uint32_t br = read_u32_le(result.trampoline_bytes.data() + 4);
  CHECK(br == 0xD61F0200u);

  const uint64_t literal = read_u64_le(result.trampoline_bytes.data() + 8);
  CHECK(literal == origin + 8);
}

TEST_CASE("w1h00k relocator adjusts arm64 conditional branches") {
  auto spec = w1::arch::detect_host_arch_spec();
  if (spec.arch_mode != w1::arch::mode::aarch64) {
    CHECK(true);
    return;
  }

  auto bcond = arm64_bcond_bytes();
  auto filler = nop_bytes_for_arch(spec);
  auto buffer = make_filled_buffer(bcond, 64, filler);

  const uint64_t target_addr = reinterpret_cast<uint64_t>(buffer.data());
  const uint64_t tramp = target_addr + 0x1000;
  auto result = w1::h00k::reloc::relocate(buffer.data(), bcond.size(), tramp);

  CHECK(result.ok());
  REQUIRE(result.patch_size == bcond.size());
  const uint32_t relocated = read_u32_le(result.trampoline_bytes.data());
  const uint64_t relocated_target = arm64_decode_target(relocated, tramp);

  CHECK(relocated_target == target_addr + 8);
}

TEST_CASE("w1h00k relocator adjusts arm64 CBZ via asmr") {
  auto spec = w1::arch::detect_host_arch_spec();
  if (spec.arch_mode != w1::arch::mode::aarch64) {
    CHECK(true);
    return;
  }

  auto filler = nop_bytes_for_arch(spec);
  auto buffer = make_filled_buffer({}, 64, filler);

  const uint64_t origin = reinterpret_cast<uint64_t>(buffer.data());
  auto cbz = assemble_or_empty(spec, "cbz x0, #8", origin);
  if (cbz.empty()) {
    WARN("asmr assembly unavailable for arm64 cbz");
    return;
  }
  std::copy(cbz.begin(), cbz.end(), buffer.begin());

  const uint64_t tramp = origin + 0x1000;
  auto result = w1::h00k::reloc::relocate(buffer.data(), cbz.size(), tramp);

  CHECK(result.ok());
  REQUIRE(result.patch_size == cbz.size());
  const uint32_t relocated = read_u32_le(result.trampoline_bytes.data());
  const uint32_t original = read_u32_le(cbz.data());
  const uint64_t original_target = arm64_decode_target(original, origin);
  const uint64_t relocated_target = arm64_decode_target(relocated, tramp);
  CHECK(relocated_target == original_target);
}

TEST_CASE("w1h00k relocator emits arm64 CBZ stub when out of range") {
  auto spec = w1::arch::detect_host_arch_spec();
  if (spec.arch_mode != w1::arch::mode::aarch64) {
    CHECK(true);
    return;
  }

  auto filler = nop_bytes_for_arch(spec);
  auto buffer = make_filled_buffer({}, 64, filler);

  const uint64_t origin = reinterpret_cast<uint64_t>(buffer.data());
  auto cbz = assemble_or_empty(spec, "cbz x0, #8", origin);
  if (cbz.empty()) {
    WARN("asmr assembly unavailable for arm64 cbz");
    return;
  }
  std::copy(cbz.begin(), cbz.end(), buffer.begin());

  const uint64_t tramp = origin + 0x20000000ULL;
  auto result = w1::h00k::reloc::relocate(buffer.data(), cbz.size(), tramp);

  CHECK(result.ok());
  REQUIRE(result.patch_size == cbz.size());
  REQUIRE(result.trampoline_bytes.size() == 20);

  const uint32_t skip = read_u32_le(result.trampoline_bytes.data());
  const uint32_t original = read_u32_le(cbz.data());
  CHECK(((skip ^ original) & 0x01000000u) != 0);
  const uint64_t skip_target = arm64_decode_target(skip, tramp);
  CHECK(skip_target == tramp + 16);

  const uint64_t literal = read_u64_le(result.trampoline_bytes.data() + 12);
  const uint64_t original_target = arm64_decode_target(original, origin);
  CHECK(literal == original_target);
}
TEST_CASE("w1h00k relocator emits arm64 conditional stub when out of range") {
  auto spec = w1::arch::detect_host_arch_spec();
  if (spec.arch_mode != w1::arch::mode::aarch64) {
    CHECK(true);
    return;
  }

  auto bcond = arm64_bcond_bytes();
  auto filler = nop_bytes_for_arch(spec);
  auto buffer = make_filled_buffer(bcond, 64, filler);

  const uint64_t origin = reinterpret_cast<uint64_t>(buffer.data());
  const uint64_t tramp = origin + 0x20000000ULL;
  auto result = w1::h00k::reloc::relocate(buffer.data(), bcond.size(), tramp);

  CHECK(result.ok());
  REQUIRE(result.patch_size == bcond.size());
  REQUIRE(result.trampoline_bytes.size() == 20);

  const uint32_t skip = read_u32_le(result.trampoline_bytes.data());
  CHECK((skip & 0xFF000010u) == 0x54000000u);
  CHECK((skip & 0xFu) == 0x1u);
  const uint64_t skip_target = arm64_decode_target(skip, tramp);
  CHECK(skip_target == tramp + 16);

  const uint32_t ldr = read_u32_le(result.trampoline_bytes.data() + 4);
  CHECK((ldr & 0xFF000000u) == 0x58000000u);
  CHECK((ldr & 0x1Fu) == 16u);
  CHECK(((ldr >> 5) & 0x7FFFFu) == 2u);

  const uint32_t br = read_u32_le(result.trampoline_bytes.data() + 8);
  CHECK(br == 0xD61F0200u);

  const uint64_t literal = read_u64_le(result.trampoline_bytes.data() + 12);
  CHECK(literal == origin + 8);
}

TEST_CASE("w1h00k relocator adjusts arm64 ADR/ADRP") {
  auto spec = w1::arch::detect_host_arch_spec();
  if (spec.arch_mode != w1::arch::mode::aarch64) {
    CHECK(true);
    return;
  }

  auto adr = pc_relative_bytes_for_arch(spec);
  auto adrp = arm64_adrp_bytes();
  auto filler = nop_bytes_for_arch(spec);

  auto buffer = make_filled_buffer(adr, 64, filler);
  const uint64_t target_addr = reinterpret_cast<uint64_t>(buffer.data());
  const uint64_t tramp = target_addr + 0x1000;
  auto adr_result = w1::h00k::reloc::relocate(buffer.data(), adr.size(), tramp);

  CHECK(adr_result.ok());
  REQUIRE(adr_result.patch_size == adr.size());
  const uint32_t adr_relocated = read_u32_le(adr_result.trampoline_bytes.data());
  const uint64_t adr_target = arm64_decode_target(adr_relocated, tramp);
  CHECK(adr_target == target_addr);

  auto buffer2 = make_filled_buffer(adrp, 64, filler);
  const uint64_t target_addr2 = reinterpret_cast<uint64_t>(buffer2.data());
  const uint64_t tramp2 = target_addr2 + 0x2000;
  auto adrp_result = w1::h00k::reloc::relocate(buffer2.data(), adrp.size(), tramp2);

  CHECK(adrp_result.ok());
  REQUIRE(adrp_result.patch_size == adrp.size());
  const uint32_t adrp_relocated = read_u32_le(adrp_result.trampoline_bytes.data());
  const uint64_t adrp_target = arm64_decode_target(adrp_relocated, tramp2);
  CHECK((adrp_target & ~0xFFFULL) == (target_addr2 & ~0xFFFULL));
}

TEST_CASE("w1h00k relocator emits arm64 ADR stub when out of range") {
  auto spec = w1::arch::detect_host_arch_spec();
  if (spec.arch_mode != w1::arch::mode::aarch64) {
    CHECK(true);
    return;
  }

  auto adr = pc_relative_bytes_for_arch(spec);
  auto filler = nop_bytes_for_arch(spec);
  auto buffer = make_filled_buffer(adr, 64, filler);

  const uint64_t origin = reinterpret_cast<uint64_t>(buffer.data());
  const uint64_t tramp = origin + 0x200000ULL;
  auto result = w1::h00k::reloc::relocate(buffer.data(), adr.size(), tramp);

  CHECK(result.ok());
  REQUIRE(result.patch_size == adr.size());
  REQUIRE(result.trampoline_bytes.size() == 12);

  const uint32_t ldr = read_u32_le(result.trampoline_bytes.data());
  CHECK((ldr & 0xFF000000u) == 0x58000000u);
  CHECK((ldr & 0x1Fu) == 0u);
  CHECK(((ldr >> 5) & 0x7FFFFu) == 1u);

  const uint64_t literal = read_u64_le(result.trampoline_bytes.data() + 4);
  CHECK(literal == origin);
}

TEST_CASE("w1h00k relocator emits arm64 ADRP stub when out of range") {
  auto spec = w1::arch::detect_host_arch_spec();
  if (spec.arch_mode != w1::arch::mode::aarch64) {
    CHECK(true);
    return;
  }

  auto adrp = arm64_adrp_bytes();
  auto filler = nop_bytes_for_arch(spec);
  auto buffer = make_filled_buffer(adrp, 64, filler);

  const uint64_t origin = reinterpret_cast<uint64_t>(buffer.data());
  const uint64_t tramp = origin + 0x200000000ULL;
  auto result = w1::h00k::reloc::relocate(buffer.data(), adrp.size(), tramp);

  CHECK(result.ok());
  REQUIRE(result.patch_size == adrp.size());
  REQUIRE(result.trampoline_bytes.size() == 12);

  const uint32_t ldr = read_u32_le(result.trampoline_bytes.data());
  CHECK((ldr & 0xFF000000u) == 0x58000000u);
  CHECK((ldr & 0x1Fu) == 0u);
  CHECK(((ldr >> 5) & 0x7FFFFu) == 1u);

  const uint64_t literal = read_u64_le(result.trampoline_bytes.data() + 4);
  CHECK(literal == (origin & ~0xFFFULL));
}

TEST_CASE("w1h00k relocator enforces max patch size") {
  auto spec = w1::arch::detect_host_arch_spec();
  auto nop = nop_bytes_for_arch(spec);
  if (nop.empty()) {
    CHECK(true);
    return;
  }

  auto buffer = make_filled_buffer(nop, 128, nop);

  auto result = w1::h00k::reloc::relocate(buffer.data(), 128);

  CHECK(result.patch_size == 0);
  CHECK(result.trampoline_bytes.empty());
  CHECK(result.error == w1::h00k::reloc::reloc_error::invalid_request);
}

TEST_CASE("w1h00k relocator emits x86_64 jmp stub when out of range") {
  auto spec = parse_arch_or("x86_64", w1::arch::detect_host_arch_spec());
  if (spec.arch_mode != w1::arch::mode::x86_64 || !disasm_supported(spec)) {
    CHECK(true);
    return;
  }

  const std::vector<uint8_t> jmp = {0xE9, 0x05, 0x00, 0x00, 0x00};
  const std::vector<uint8_t> filler = {0x90};
  auto buffer = make_filled_buffer(jmp, 64, filler);

  const uint64_t origin = reinterpret_cast<uint64_t>(buffer.data());
  const uint64_t tramp = origin + 0x100000000ULL;
  auto result = w1::h00k::reloc::relocate(buffer.data(), jmp.size(), tramp, spec);

  CHECK(result.ok());
  REQUIRE(result.patch_size == jmp.size());
  REQUIRE(result.trampoline_bytes.size() == 14);

  CHECK(result.trampoline_bytes[0] == 0xFF);
  CHECK(result.trampoline_bytes[1] == 0x25);
  CHECK(result.trampoline_bytes[2] == 0x00);
  CHECK(result.trampoline_bytes[3] == 0x00);
  CHECK(result.trampoline_bytes[4] == 0x00);
  CHECK(result.trampoline_bytes[5] == 0x00);

  const uint64_t literal = read_u64_le(result.trampoline_bytes.data() + 6);
  CHECK(literal == origin + 10);
}

TEST_CASE("w1h00k relocator emits x86_64 jcc stub when out of range") {
  auto spec = parse_arch_or("x86_64", w1::arch::detect_host_arch_spec());
  if (spec.arch_mode != w1::arch::mode::x86_64 || !disasm_supported(spec)) {
    CHECK(true);
    return;
  }

  const std::vector<uint8_t> je = {0x74, 0x02};
  const std::vector<uint8_t> filler = {0x90};
  auto buffer = make_filled_buffer(je, 64, filler);

  const uint64_t origin = reinterpret_cast<uint64_t>(buffer.data());
  const uint64_t tramp = origin + 0x100000000ULL;
  auto result = w1::h00k::reloc::relocate(buffer.data(), je.size(), tramp, spec);

  CHECK(result.ok());
  REQUIRE(result.patch_size == je.size());
  REQUIRE(result.trampoline_bytes.size() == 16);

  CHECK(result.trampoline_bytes[0] == 0x75);
  CHECK(result.trampoline_bytes[1] == 0x0E);
  CHECK(result.trampoline_bytes[2] == 0xFF);
  CHECK(result.trampoline_bytes[3] == 0x25);
  CHECK(result.trampoline_bytes[4] == 0x00);
  CHECK(result.trampoline_bytes[5] == 0x00);
  CHECK(result.trampoline_bytes[6] == 0x00);
  CHECK(result.trampoline_bytes[7] == 0x00);

  const uint64_t literal = read_u64_le(result.trampoline_bytes.data() + 8);
  CHECK(literal == origin + 4);
}

```

`test/w1h00k/resolve_tests.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <cstdlib>

#if defined(_WIN32)
#include <windows.h>
#endif

#include "w1h00k/resolve/resolve.hpp"

namespace {

void touch_imports() {
#if defined(_WIN32)
  (void) GetModuleHandleA(nullptr);
#else
  void* ptr = std::malloc(32);
  std::free(ptr);
#endif
}

} // namespace

TEST_CASE("w1h00k resolves known symbol") {
#if defined(_WIN32)
  auto result = w1::h00k::resolve::resolve_symbol("GetModuleHandleA", "kernel32.dll");
#else
  auto result = w1::h00k::resolve::resolve_symbol("malloc", nullptr);
#endif
  CHECK(result.error.ok());
  CHECK(result.address != nullptr);
}

TEST_CASE("w1h00k enumerates modules") {
  auto modules = w1::h00k::resolve::enumerate_modules();
  CHECK(!modules.empty());
}

TEST_CASE("w1h00k resolves import slot in current module") {
  touch_imports();
#if defined(_WIN32)
  auto result = w1::h00k::resolve::resolve_import("GetModuleHandleA", nullptr, "kernel32.dll");
#else
  auto result = w1::h00k::resolve::resolve_import("malloc", nullptr, nullptr);
#endif
  CHECK(result.error.ok());
  CHECK(result.slot != nullptr);
  if (result.slot) {
    CHECK(*result.slot != nullptr);
  }
}

```

`test/w1h00k/test_main.cpp`:

```cpp
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "doctest/doctest.hpp"

```

`test/w1instrument/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${W1_SOURCE_DIR}/cmake/TestConfig.cmake)

set(W1INSTRUMENT_TEST_SOURCES
    ${W1_SOURCE_DIR}/test/common/test_main.cpp
    event_router_test.cpp
    instrumentation_policy_test.cpp
    thread_session_simple_test.cpp
)

w1_add_doctest_suite(w1instrument_unit_tests
    SOURCES ${W1INSTRUMENT_TEST_SOURCES}
    INCLUDE_DIRS
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/third_party
    LIBS
        w1instrument
    OUTPUT_SUBDIR w1instrument
)

```

`test/w1instrument/event_router_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <cstdint>
#include <vector>

#include <QBDI.h>

#include "w1instrument/trace/event_dispatcher.hpp"
#include "w1runtime/module_catalog.hpp"
#include "w1instrument/tracer/event.hpp"
#include "w1instrument/tracer/trace_context.hpp"
#include "w1runtime/memory_reader.hpp"

namespace {

int test_add(int value) { return value + 1; }
int test_call_chain(int value) { return test_add(value); }

volatile int g_value = 0;
int test_load() { return g_value; }
int test_store(int value) {
  g_value = value;
  return g_value;
}

struct counting_tracer {
  size_t count = 0;

  const char* name() const { return "counting_tracer"; }
  static constexpr w1::event_mask requested_events() { return w1::event_mask_of(w1::event_kind::instruction_pre); }

  void on_instruction_pre(
      w1::trace_context& ctx, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  ) {
    (void) ctx;
    (void) event;
    (void) vm;
    (void) gpr;
    (void) fpr;
    ++count;
  }
};

struct silent_tracer {
  size_t count = 0;

  const char* name() const { return "silent_tracer"; }
  static constexpr w1::event_mask requested_events() { return 0; }

  void on_instruction_pre(
      w1::trace_context& ctx, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  ) {
    (void) ctx;
    (void) event;
    (void) vm;
    (void) gpr;
    (void) fpr;
    ++count;
  }
};

struct dual_tracer {
  size_t pre_count = 0;
  size_t post_count = 0;

  const char* name() const { return "dual_tracer"; }
  static constexpr w1::event_mask requested_events() {
    return w1::event_mask_or(
        w1::event_mask_of(w1::event_kind::instruction_pre), w1::event_mask_of(w1::event_kind::instruction_post)
    );
  }

  void on_instruction_pre(
      w1::trace_context& ctx, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  ) {
    (void) ctx;
    (void) event;
    (void) vm;
    (void) gpr;
    (void) fpr;
    ++pre_count;
  }

  void on_instruction_post(
      w1::trace_context& ctx, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  ) {
    (void) ctx;
    (void) event;
    (void) vm;
    (void) gpr;
    (void) fpr;
    ++post_count;
  }
};

struct basic_block_tracer {
  size_t entry_count = 0;
  size_t exit_count = 0;

  const char* name() const { return "basic_block_tracer"; }
  static constexpr w1::event_mask requested_events() {
    return w1::event_mask_or(
        w1::event_mask_of(w1::event_kind::basic_block_entry), w1::event_mask_of(w1::event_kind::basic_block_exit)
    );
  }

  void on_basic_block_entry(
      w1::trace_context& ctx, const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  ) {
    (void) ctx;
    (void) event;
    (void) vm;
    (void) state;
    (void) gpr;
    (void) fpr;
    ++entry_count;
  }

  void on_basic_block_exit(
      w1::trace_context& ctx, const w1::basic_block_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  ) {
    (void) ctx;
    (void) event;
    (void) vm;
    (void) state;
    (void) gpr;
    (void) fpr;
    ++exit_count;
  }
};

struct sequence_tracer {
  size_t start_count = 0;
  size_t stop_count = 0;

  const char* name() const { return "sequence_tracer"; }
  static constexpr w1::event_mask requested_events() {
    return w1::event_mask_or(w1::event_mask_of(w1::event_kind::vm_start), w1::event_mask_of(w1::event_kind::vm_stop));
  }

  void on_vm_start(
      w1::trace_context& ctx, const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  ) {
    (void) ctx;
    (void) event;
    (void) vm;
    (void) state;
    (void) gpr;
    (void) fpr;
    ++start_count;
  }

  void on_vm_stop(
      w1::trace_context& ctx, const w1::sequence_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  ) {
    (void) ctx;
    (void) event;
    (void) vm;
    (void) state;
    (void) gpr;
    (void) fpr;
    ++stop_count;
  }
};

struct memory_tracer {
  size_t read_count = 0;
  size_t write_count = 0;

  const char* name() const { return "memory_tracer"; }
  static constexpr w1::event_mask requested_events() {
    return w1::event_mask_or(
        w1::event_mask_of(w1::event_kind::memory_read), w1::event_mask_of(w1::event_kind::memory_write)
    );
  }

  void on_memory(
      w1::trace_context& ctx, const w1::memory_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  ) {
    (void) ctx;
    (void) event;
    (void) vm;
    (void) gpr;
    (void) fpr;
    if (event.is_read) {
      ++read_count;
    }
    if (event.is_write) {
      ++write_count;
    }
  }
};

struct exec_transfer_tracer {
  size_t call_count = 0;
  size_t return_count = 0;

  const char* name() const { return "exec_transfer_tracer"; }
  static constexpr w1::event_mask requested_events() {
    return w1::event_mask_or(
        w1::event_mask_of(w1::event_kind::exec_transfer_call), w1::event_mask_of(w1::event_kind::exec_transfer_return)
    );
  }

  void on_exec_transfer_call(
      w1::trace_context& ctx, const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  ) {
    (void) ctx;
    (void) event;
    (void) vm;
    (void) state;
    (void) gpr;
    (void) fpr;
    ++call_count;
  }

  void on_exec_transfer_return(
      w1::trace_context& ctx, const w1::exec_transfer_event& event, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  ) {
    (void) ctx;
    (void) event;
    (void) vm;
    (void) state;
    (void) gpr;
    (void) fpr;
    ++return_count;
  }
};

} // namespace

TEST_CASE("event_router registers instruction_pre callbacks") {
  QBDI::VM vm;

  w1::runtime::module_catalog modules;
  w1::util::memory_reader memory(&vm, modules);
  w1::trace_context ctx(0, &vm, &modules, &memory);

  counting_tracer tracer;
  w1::instrument::event_dispatcher<counting_tracer> router(&vm);

  REQUIRE(router.bind(counting_tracer::requested_events(), tracer, ctx));
  REQUIRE(vm.addInstrumentedModuleFromAddr(reinterpret_cast<QBDI::rword>(&test_add)));

  QBDI::rword result = 0;
  std::vector<QBDI::rword> args;
  args.push_back(1);
  REQUIRE(vm.switchStackAndCall(&result, reinterpret_cast<QBDI::rword>(&test_add), args));
  CHECK(tracer.count > 0);

  router.clear();
}

TEST_CASE("event_router skips callbacks when event mask is empty") {
  QBDI::VM vm;

  w1::runtime::module_catalog modules;
  w1::util::memory_reader memory(&vm, modules);
  w1::trace_context ctx(0, &vm, &modules, &memory);

  silent_tracer tracer;
  w1::instrument::event_dispatcher<silent_tracer> router(&vm);

  REQUIRE(router.bind(silent_tracer::requested_events(), tracer, ctx));
  REQUIRE(vm.addInstrumentedModuleFromAddr(reinterpret_cast<QBDI::rword>(&test_add)));

  QBDI::rword result = 0;
  std::vector<QBDI::rword> args;
  args.push_back(2);
  REQUIRE(vm.switchStackAndCall(&result, reinterpret_cast<QBDI::rword>(&test_add), args));
  CHECK(tracer.count == 0);

  router.clear();
}

TEST_CASE("event_router registers instruction_post callbacks") {
  QBDI::VM vm;

  w1::runtime::module_catalog modules;
  w1::util::memory_reader memory(&vm, modules);
  w1::trace_context ctx(0, &vm, &modules, &memory);

  dual_tracer tracer;
  w1::instrument::event_dispatcher<dual_tracer> router(&vm);

  REQUIRE(router.bind(dual_tracer::requested_events(), tracer, ctx));
  REQUIRE(vm.addInstrumentedModuleFromAddr(reinterpret_cast<QBDI::rword>(&test_add)));

  QBDI::rword result = 0;
  std::vector<QBDI::rword> args;
  args.push_back(3);
  REQUIRE(vm.switchStackAndCall(&result, reinterpret_cast<QBDI::rword>(&test_add), args));
  CHECK(tracer.pre_count > 0);
  CHECK(tracer.post_count > 0);

  router.clear();
}

TEST_CASE("event_router registers basic block callbacks") {
  QBDI::VM vm;

  w1::runtime::module_catalog modules;
  w1::util::memory_reader memory(&vm, modules);
  w1::trace_context ctx(0, &vm, &modules, &memory);

  basic_block_tracer tracer;
  w1::instrument::event_dispatcher<basic_block_tracer> router(&vm);

  REQUIRE(router.bind(basic_block_tracer::requested_events(), tracer, ctx));
  REQUIRE(vm.addInstrumentedModuleFromAddr(reinterpret_cast<QBDI::rword>(&test_add)));

  QBDI::rword result = 0;
  std::vector<QBDI::rword> args;
  args.push_back(4);
  REQUIRE(vm.switchStackAndCall(&result, reinterpret_cast<QBDI::rword>(&test_add), args));
  CHECK(tracer.entry_count > 0);
  CHECK(tracer.exit_count > 0);

  router.clear();
}

TEST_CASE("event_router registers vm start and stop callbacks") {
  QBDI::VM vm;

  w1::runtime::module_catalog modules;
  w1::util::memory_reader memory(&vm, modules);
  w1::trace_context ctx(0, &vm, &modules, &memory);

  sequence_tracer tracer;
  w1::instrument::event_dispatcher<sequence_tracer> router(&vm);

  REQUIRE(router.bind(sequence_tracer::requested_events(), tracer, ctx));
  REQUIRE(vm.addInstrumentedModuleFromAddr(reinterpret_cast<QBDI::rword>(&test_add)));

  QBDI::rword result = 0;
  std::vector<QBDI::rword> args;
  args.push_back(5);
  REQUIRE(vm.switchStackAndCall(&result, reinterpret_cast<QBDI::rword>(&test_add), args));
  CHECK(tracer.start_count > 0);
  CHECK(tracer.stop_count > 0);

  router.clear();
}

TEST_CASE("event_router registers memory callbacks") {
  QBDI::VM vm;

  w1::runtime::module_catalog modules;
  w1::util::memory_reader memory(&vm, modules);
  w1::trace_context ctx(0, &vm, &modules, &memory);

  memory_tracer tracer;
  w1::instrument::event_dispatcher<memory_tracer> router(&vm);

  REQUIRE(router.bind(memory_tracer::requested_events(), tracer, ctx));
  REQUIRE(vm.addInstrumentedModuleFromAddr(reinterpret_cast<QBDI::rword>(&test_load)));
  REQUIRE(router.ensure_memory_recording());

  QBDI::rword result = 0;
  std::vector<QBDI::rword> args;
  REQUIRE(vm.switchStackAndCall(&result, reinterpret_cast<QBDI::rword>(&test_load), args));
  args.clear();
  args.push_back(42);
  REQUIRE(vm.switchStackAndCall(&result, reinterpret_cast<QBDI::rword>(&test_store), args));
  CHECK(tracer.read_count > 0);
  CHECK(tracer.write_count > 0);

  router.clear();
}

TEST_CASE("event_router registers exec transfer callbacks") {
  QBDI::VM vm;

  w1::runtime::module_catalog modules;
  w1::util::memory_reader memory(&vm, modules);
  w1::trace_context ctx(0, &vm, &modules, &memory);

  exec_transfer_tracer tracer;
  w1::instrument::event_dispatcher<exec_transfer_tracer> router(&vm);

  REQUIRE(router.bind(exec_transfer_tracer::requested_events(), tracer, ctx));
  REQUIRE(vm.addInstrumentedModuleFromAddr(reinterpret_cast<QBDI::rword>(&test_call_chain)));

  QBDI::rword result = 0;
  std::vector<QBDI::rword> args;
  args.push_back(6);
  REQUIRE(vm.switchStackAndCall(&result, reinterpret_cast<QBDI::rword>(&test_call_chain), args));
  if (tracer.call_count == 0 && tracer.return_count == 0) {
    WARN("exec transfer callbacks did not fire; QBDI ExecBroker events may be disabled for this build");
  } else {
    CHECK(tracer.call_count > 0);
    CHECK(tracer.return_count > 0);
  }

  router.clear();
}

```

`test/w1instrument/instrumentation_policy_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <string>

#include "w1instrument/core/instrumentation_policy.hpp"

namespace {

w1::runtime::module_info make_module(
    std::string name, std::string path, bool is_system, uint64_t start = 0x1000, uint64_t end = 0x2000
) {
  w1::runtime::module_info module{};
  module.name = std::move(name);
  module.path = std::move(path);
  module.base_address = start;
  module.size = end - start;
  module.is_system = is_system;
  module.full_range = w1::address_range{start, end};
  module.mapped_ranges = {module.full_range};
  module.exec_ranges = {module.full_range};
  return module;
}

} // namespace

TEST_CASE("instrumentation_policy excludes unnamed modules by default") {
  w1::core::instrumentation_policy policy;
  auto module = make_module("_unnamed_0x1000", "", false);
  CHECK(policy.should_instrument(module) == false);

  policy.include_unnamed_modules = true;
  CHECK(policy.should_instrument(module) == true);
}

TEST_CASE("instrumentation_policy applies default excludes") {
  w1::core::instrumentation_policy policy;
  auto module = make_module("libQBDI", "libQBDI.so", false);
  CHECK(policy.should_instrument(module) == false);

  policy.use_default_excludes = false;
  CHECK(policy.should_instrument(module) == true);
}

TEST_CASE("instrumentation_policy honors include and exclude lists") {
  w1::core::instrumentation_policy policy;
  policy.use_default_excludes = false;
  policy.include_modules = {"target"};
  policy.exclude_modules = {"deny"};

  auto included = make_module("target_mod", "/tmp/target_mod", false);
  auto excluded = make_module("deny_mod", "/tmp/deny_mod", false);
  auto other = make_module("other_mod", "/tmp/other_mod", false);

  CHECK(policy.should_instrument(included) == true);
  CHECK(policy.should_instrument(excluded) == false);
  CHECK(policy.should_instrument(other) == false);
}

TEST_CASE("instrumentation_policy gates system modules") {
  w1::core::instrumentation_policy policy;
  policy.use_default_excludes = false;

  auto system_module = make_module("system_lib", "/usr/lib/system_lib", true);
#if defined(__APPLE__)
  auto critical_module = make_module("libSystem.B.dylib", "/usr/lib/libSystem.B.dylib", true);
#elif defined(__linux__)
  auto critical_module = make_module("libc.so.6", "/usr/lib/libc.so.6", true);
#elif defined(_WIN32)
  auto critical_module = make_module("kernel32.dll", "C:\\Windows\\System32\\kernel32.dll", true);
#else
  auto critical_module = make_module("critical_system", "/critical/system", true);
#endif
  CHECK(policy.should_instrument(system_module) == false);

  policy.system_policy = w1::core::system_module_policy::include_critical;
  CHECK(policy.should_instrument(system_module) == false);
  CHECK(policy.should_instrument(critical_module) == true);

  policy.system_policy = w1::core::system_module_policy::include_all;
  CHECK(policy.should_instrument(system_module) == true);
}

```

`test/w1instrument/thread_session_simple_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <cstdint>
#include <vector>

#include "w1instrument/trace/thread_session.hpp"

namespace {

int thread_session_add(int value) { return value + 1; }

struct simple_tracer {
  size_t count = 0;

  const char* name() const { return "simple_tracer"; }
  static constexpr w1::event_mask requested_events() { return w1::event_mask_of(w1::event_kind::instruction_pre); }

  void on_instruction_pre(
      w1::trace_context& ctx, const w1::instruction_event& event, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr,
      QBDI::FPRState* fpr
  ) {
    (void) ctx;
    (void) event;
    (void) vm;
    (void) gpr;
    (void) fpr;
    ++count;
  }
};

} // namespace

TEST_CASE("thread_session runs a minimal tracer") {
  w1::instrument::thread_session_config config;
  config.thread_id = 1;
  config.thread_name = "unit_main";

  w1::instrument::thread_session<simple_tracer> session(config, simple_tracer{});

  if (!session.instrument()) {
    WARN("vm_session could not instrument modules; module scanning may be blocked");
    return;
  }

  std::vector<uint64_t> args;
  args.push_back(1);
  uint64_t result = 0;

  REQUIRE(session.call(reinterpret_cast<uint64_t>(&thread_session_add), args, &result));
  CHECK(result == 2);
  CHECK(session.tracer().count > 0);

  session.shutdown();
}

```

`test/w1monitor/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${W1_SOURCE_DIR}/cmake/TestConfig.cmake)

set(W1MONITOR_TEST_SOURCES
    test_main.cpp
    backend_helpers_tests.cpp
    event_queue_tests.cpp
    monitor_tests.cpp
)

if(APPLE)
    list(APPEND W1MONITOR_TEST_SOURCES monitor_tests_darwin.cpp)
elseif(WIN32)
    list(APPEND W1MONITOR_TEST_SOURCES monitor_tests_windows.cpp)
elseif(UNIX)
    list(APPEND W1MONITOR_TEST_SOURCES monitor_tests_linux.cpp)
endif()

w1_add_doctest_suite(w1monitor_tests
    SOURCES ${W1MONITOR_TEST_SOURCES}
    INCLUDE_DIRS
        ${CMAKE_CURRENT_SOURCE_DIR}
        ${W1_SOURCE_DIR}/test/common
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/third_party
    LIBS w1monitor ${CMAKE_DL_LIBS}
    OUTPUT_SUBDIR w1monitor
)

```

`test/w1monitor/backend_helpers_tests.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <cstdint>
#include <string>
#include <thread>
#include <vector>

#include "w1monitor/backend/module_snapshot.hpp"
#include "w1monitor/backend/thread_entry.hpp"
#include "w1monitor/backend/thread_event_helpers.hpp"

using w1::monitor::event_queue;
using w1::monitor::module_event;
using w1::monitor::thread_entry_context;
using w1::monitor::thread_entry_kind;
using w1::monitor::thread_event;
using w1::monitor::backend::dispatch_thread_entry;
using w1::monitor::backend::module_snapshot_entry;
using w1::monitor::backend::module_snapshot_tracker;
using w1::monitor::backend::thread_event_emitter;
using w1::monitor::backend::thread_stop_tracker;

TEST_CASE("w1monitor module_snapshot_tracker reports load/unload") {
  module_snapshot_tracker tracker;
  std::vector<module_snapshot_entry> initial{
      {reinterpret_cast<void*>(0x1000), 64, "a"},
      {reinterpret_cast<void*>(0x2000), 128, "b"},
  };
  tracker.seed(initial);

  std::vector<module_snapshot_entry> next{
      {reinterpret_cast<void*>(0x1000), 64, "a"},
      {reinterpret_cast<void*>(0x3000), 256, "c"},
  };

  bool saw_loaded = false;
  bool saw_unloaded = false;
  tracker.refresh(next, true, [&](const module_event& event) {
    if (event.type == module_event::kind::loaded && event.base == reinterpret_cast<void*>(0x3000)) {
      saw_loaded = true;
    }
    if (event.type == module_event::kind::unloaded && event.base == reinterpret_cast<void*>(0x2000)) {
      saw_unloaded = true;
    }
  });

  CHECK(saw_loaded);
  CHECK(saw_unloaded);
}

TEST_CASE("w1monitor module_snapshot_tracker respects emit flag") {
  module_snapshot_tracker tracker;
  std::vector<module_snapshot_entry> modules{
      {reinterpret_cast<void*>(0x1111), 64, "a"},
  };

  bool emitted = false;
  tracker.refresh(modules, false, [&](const module_event&) { emitted = true; });
  CHECK_FALSE(emitted);
}

TEST_CASE("w1monitor module_snapshot_tracker fills missing data") {
  module_snapshot_tracker tracker;
  tracker.track(reinterpret_cast<void*>(0x4000), "unit_test", 512);

  module_event event{};
  event.type = module_event::kind::loaded;
  event.base = reinterpret_cast<void*>(0x4000);

  REQUIRE(tracker.fill_missing(event));
  CHECK(event.path == "unit_test");
  CHECK(event.size == 512);

  module_event missing{};
  missing.type = module_event::kind::loaded;
  missing.base = reinterpret_cast<void*>(0x5000);
  CHECK_FALSE(tracker.fill_missing(missing));
}

TEST_CASE("w1monitor module_snapshot_tracker does not override set fields") {
  module_snapshot_tracker tracker;
  tracker.track(reinterpret_cast<void*>(0x6000), "tracked", 256);

  module_event event{};
  event.type = module_event::kind::loaded;
  event.base = reinterpret_cast<void*>(0x6000);
  event.path = "already_set";
  event.size = 128;

  REQUIRE(tracker.fill_missing(event));
  CHECK(event.path == "already_set");
  CHECK(event.size == 128);
}

TEST_CASE("w1monitor module_snapshot_tracker untrack removes entry") {
  module_snapshot_tracker tracker;
  tracker.track(reinterpret_cast<void*>(0x7000), "to_remove", 64);
  tracker.untrack(reinterpret_cast<void*>(0x7000));

  module_event event{};
  event.type = module_event::kind::loaded;
  event.base = reinterpret_cast<void*>(0x7000);
  CHECK_FALSE(tracker.fill_missing(event));
}

TEST_CASE("w1monitor thread_stop_tracker emits once per reset") {
  thread_stop_tracker tracker;
  tracker.reset();
  CHECK(tracker.should_emit());
  CHECK_FALSE(tracker.should_emit());
  tracker.reset();
  CHECK(tracker.should_emit());
}

TEST_CASE("w1monitor thread_stop_tracker is thread local") {
  thread_stop_tracker tracker;
  tracker.reset();
  CHECK(tracker.should_emit());
  CHECK_FALSE(tracker.should_emit());

  bool other_thread_emitted = false;
  std::thread worker([&]() { other_thread_emitted = tracker.should_emit(); });
  worker.join();

  CHECK(other_thread_emitted);
}

TEST_CASE("w1monitor thread_event_emitter enqueues events") {
  event_queue queue;
  thread_event_emitter emitter(queue);

  emitter.started(11);
  emitter.renamed(12, "worker");
  emitter.stopped(13);

  thread_event event{};
  REQUIRE(queue.poll(event));
  CHECK(event.type == thread_event::kind::started);
  CHECK(event.tid == 11);

  REQUIRE(queue.poll(event));
  CHECK(event.type == thread_event::kind::renamed);
  CHECK(event.tid == 12);
  CHECK(event.name == "worker");

  REQUIRE(queue.poll(event));
  CHECK(event.type == thread_event::kind::stopped);
  CHECK(event.tid == 13);
}

TEST_CASE("w1monitor dispatch_thread_entry honors callback") {
  thread_entry_context captured{};
  bool callback_called = false;
  int start_calls = 0;

  w1::monitor::thread_entry_callback callback = [&](const thread_entry_context& ctx, uint64_t& result) {
    callback_called = true;
    captured = ctx;
    result = 42;
    return true;
  };

  const uint64_t result = dispatch_thread_entry(
      callback, thread_entry_kind::posix, 99, reinterpret_cast<void*>(0x1234), reinterpret_cast<void*>(0x5678),
      [&]() -> uint64_t {
        ++start_calls;
        return 7;
      }
  );

  CHECK(callback_called);
  CHECK(start_calls == 0);
  CHECK(result == 42);
  CHECK(captured.kind == thread_entry_kind::posix);
  CHECK(captured.tid == 99);
  CHECK(captured.start_routine == reinterpret_cast<void*>(0x1234));
  CHECK(captured.arg == reinterpret_cast<void*>(0x5678));
}

TEST_CASE("w1monitor dispatch_thread_entry falls back when callback declines") {
  int start_calls = 0;

  w1::monitor::thread_entry_callback callback = [&](const thread_entry_context&, uint64_t& result) {
    result = 0;
    return false;
  };

  const uint64_t result = dispatch_thread_entry(
      callback, thread_entry_kind::win32, 123, reinterpret_cast<void*>(0x1111), reinterpret_cast<void*>(0x2222),
      [&]() -> uint64_t {
        ++start_calls;
        return 99;
      }
  );

  CHECK(start_calls == 1);
  CHECK(result == 99);
}

TEST_CASE("w1monitor dispatch_thread_entry invokes when no callback") {
  int start_calls = 0;
  w1::monitor::thread_entry_callback callback{};

  const uint64_t result =
      dispatch_thread_entry(callback, thread_entry_kind::posix, 777, nullptr, nullptr, [&]() -> uint64_t {
        ++start_calls;
        return 1234;
      });

  CHECK(start_calls == 1);
  CHECK(result == 1234);
}

```

`test/w1monitor/event_queue_tests.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <thread>

#include "w1monitor/event_queue.hpp"

TEST_CASE("w1monitor event_queue stores module events") {
  w1::monitor::event_queue queue;
  w1::monitor::module_event event{};
  event.type = w1::monitor::module_event::kind::loaded;
  event.path = "unit_test_module";
  event.base = reinterpret_cast<void*>(0x1234);
  event.size = 16;

  queue.push(event);

  w1::monitor::module_event out{};
  REQUIRE(queue.poll(out));
  CHECK(out.type == w1::monitor::module_event::kind::loaded);
  CHECK(out.path == "unit_test_module");
  CHECK(out.base == reinterpret_cast<void*>(0x1234));
  CHECK(out.size == 16);
  CHECK_FALSE(queue.poll(out));
}

TEST_CASE("w1monitor event_queue stores thread events") {
  w1::monitor::event_queue queue;
  w1::monitor::thread_event event{};
  event.type = w1::monitor::thread_event::kind::renamed;
  event.tid = 42;
  event.name = "worker";

  queue.push(event);

  w1::monitor::thread_event out{};
  REQUIRE(queue.poll(out));
  CHECK(out.type == w1::monitor::thread_event::kind::renamed);
  CHECK(out.tid == 42);
  CHECK(out.name == "worker");
  CHECK_FALSE(queue.poll(out));
}

TEST_CASE("w1monitor event_queue preserves FIFO order") {
  w1::monitor::event_queue queue;
  w1::monitor::module_event mod_a{};
  mod_a.type = w1::monitor::module_event::kind::loaded;
  mod_a.base = reinterpret_cast<void*>(0x1111);
  w1::monitor::module_event mod_b{};
  mod_b.type = w1::monitor::module_event::kind::unloaded;
  mod_b.base = reinterpret_cast<void*>(0x2222);

  queue.push(mod_a);
  queue.push(mod_b);

  w1::monitor::module_event out{};
  REQUIRE(queue.poll(out));
  CHECK(out.base == mod_a.base);
  REQUIRE(queue.poll(out));
  CHECK(out.base == mod_b.base);
}

TEST_CASE("w1monitor event_queue keeps module and thread events independent") {
  w1::monitor::event_queue queue;
  w1::monitor::module_event module{};
  module.type = w1::monitor::module_event::kind::loaded;
  module.base = reinterpret_cast<void*>(0x3333);
  w1::monitor::thread_event thread{};
  thread.type = w1::monitor::thread_event::kind::started;
  thread.tid = 77;

  queue.push(module);
  queue.push(thread);

  w1::monitor::module_event out_module{};
  w1::monitor::thread_event out_thread{};
  REQUIRE(queue.poll(out_module));
  CHECK(out_module.base == module.base);
  REQUIRE(queue.poll(out_thread));
  CHECK(out_thread.tid == thread.tid);
}

TEST_CASE("w1monitor event_queue clear removes queued events") {
  w1::monitor::event_queue queue;
  w1::monitor::module_event module{};
  module.type = w1::monitor::module_event::kind::loaded;
  module.base = reinterpret_cast<void*>(0x4444);
  w1::monitor::thread_event thread{};
  thread.type = w1::monitor::thread_event::kind::stopped;
  thread.tid = 88;

  queue.push(module);
  queue.push(thread);
  queue.clear();

  w1::monitor::module_event out_module{};
  w1::monitor::thread_event out_thread{};
  CHECK_FALSE(queue.poll(out_module));
  CHECK_FALSE(queue.poll(out_thread));
}

TEST_CASE("w1monitor event_queue supports concurrent pushes") {
  w1::monitor::event_queue queue;
  constexpr int kPerThread = 50;

  auto push_events = [&](int base_start) {
    for (int i = 0; i < kPerThread; ++i) {
      w1::monitor::module_event event{};
      event.type = w1::monitor::module_event::kind::loaded;
      event.base = reinterpret_cast<void*>(static_cast<uintptr_t>(base_start + i));
      queue.push(event);
    }
  };

  std::thread t1(push_events, 1000);
  std::thread t2(push_events, 2000);
  t1.join();
  t2.join();

  int count = 0;
  w1::monitor::module_event out{};
  while (queue.poll(out)) {
    ++count;
  }

  CHECK(count == kPerThread * 2);
}

```

`test/w1monitor/monitor_test_helpers.hpp`:

```hpp
#pragma once

#include <chrono>
#include <thread>

namespace w1::monitor::test {

template <typename Event, typename Monitor, typename Predicate>
bool wait_for_event(Monitor& monitor, Event& out, Predicate predicate, std::chrono::milliseconds timeout) {
  const auto deadline = std::chrono::steady_clock::now() + timeout;
  while (std::chrono::steady_clock::now() < deadline) {
    while (monitor.poll(out)) {
      if (predicate(out)) {
        return true;
      }
    }
    std::this_thread::sleep_for(std::chrono::milliseconds(5));
  }
  return false;
}

} // namespace w1::monitor::test

```

`test/w1monitor/monitor_tests.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "w1monitor/monitor_factory.hpp"

TEST_CASE("w1monitor factory returns monitors") {
  auto module_monitor = w1::monitor::make_module_monitor();
  auto thread_monitor = w1::monitor::make_thread_monitor();
  CHECK(module_monitor != nullptr);
  CHECK(thread_monitor != nullptr);
}

```

`test/w1monitor/monitor_tests_darwin.cpp`:

```cpp
#if defined(__APPLE__)

#include "doctest/doctest.hpp"

#include <atomic>
#include <chrono>
#include <string>
#include <thread>

#include <dlfcn.h>
#include <pthread.h>

#include "w1monitor/monitor_factory.hpp"
#include "w1monitor/module_monitor.hpp"
#include "w1monitor/thread_monitor.hpp"
#include "monitor_test_helpers.hpp"
#include "test_paths.hpp"

namespace {

using w1::monitor::test::wait_for_event;

} // namespace

TEST_CASE("w1monitor darwin module monitor reports load/unload") {
  auto monitor = w1::monitor::make_module_monitor();
  REQUIRE(monitor != nullptr);
  monitor->start();

  const char* lib_name = w1::test_paths::interpose_library_name();
  const auto lib_path = w1::test_paths::interpose_library_path();
  void* handle = dlopen(lib_path.c_str(), RTLD_NOW);
  REQUIRE(handle != nullptr);

  w1::monitor::module_event event{};
  const auto has_loaded = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::module_event& e) {
        return e.type == w1::monitor::module_event::kind::loaded && !e.path.empty() &&
               e.path.find(lib_name) != std::string::npos;
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(has_loaded);

  dlclose(handle);

  const auto has_unloaded = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::module_event& e) {
        return e.type == w1::monitor::module_event::kind::unloaded && !e.path.empty() &&
               e.path.find(lib_name) != std::string::npos;
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(has_unloaded);

  monitor->stop();
}

TEST_CASE("w1monitor darwin thread monitor reports start/stop/rename") {
  auto monitor = w1::monitor::make_thread_monitor();
  REQUIRE(monitor != nullptr);
  monitor->start();

  std::atomic<uint64_t> worker_tid{0};
  std::atomic<bool> ready{false};

  std::thread worker([&]() {
    worker_tid.store(static_cast<uint64_t>(pthread_mach_thread_np(pthread_self())), std::memory_order_release);
    pthread_setname_np("w1mon_worker");
    ready.store(true, std::memory_order_release);
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
  });

  while (worker_tid.load(std::memory_order_acquire) == 0) {
    std::this_thread::yield();
  }

  w1::monitor::thread_event event{};
  const uint64_t tid = worker_tid.load(std::memory_order_acquire);

  const auto saw_started = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::thread_event& e) {
        return e.type == w1::monitor::thread_event::kind::started && e.tid == tid;
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(saw_started);

  const auto saw_rename = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::thread_event& e) {
        return e.type == w1::monitor::thread_event::kind::renamed && e.tid == tid && e.name == "w1mon_worker";
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(saw_rename);

  worker.join();

  const auto saw_stopped = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::thread_event& e) {
        return e.type == w1::monitor::thread_event::kind::stopped && e.tid == tid;
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(saw_stopped);

  monitor->stop();
}

#endif

```

`test/w1monitor/monitor_tests_linux.cpp`:

```cpp
#if defined(__linux__)

#if !defined(_GNU_SOURCE)
#define _GNU_SOURCE
#endif

#include "doctest/doctest.hpp"

#include <atomic>
#include <chrono>
#include <string>
#include <thread>

#include <dlfcn.h>
#include <pthread.h>
#include <sys/syscall.h>
#include <unistd.h>

#include "w1monitor/monitor_factory.hpp"
#include "w1monitor/module_monitor.hpp"
#include "w1monitor/thread_monitor.hpp"
#include "monitor_test_helpers.hpp"
#include "test_paths.hpp"

namespace {

using w1::monitor::test::wait_for_event;

using spawn_thread_fn = int (*)(pthread_t*, uint64_t*, const char*);
using join_thread_fn = int (*)(pthread_t);

constexpr uintptr_t kOverrideResult = 0x1234;

void* entry_callback_start(void* arg) {
  auto* ran_ptr = static_cast<std::atomic<bool>*>(arg);
  ran_ptr->store(true, std::memory_order_release);
  return reinterpret_cast<void*>(static_cast<uintptr_t>(0x7777));
}

} // namespace

TEST_CASE("w1monitor linux module monitor reports load/unload") {
  auto monitor = w1::monitor::make_module_monitor();
  REQUIRE(monitor != nullptr);
  monitor->start();

  const char* lib_name = w1::test_paths::interpose_library_name();
  const auto lib_path = w1::test_paths::interpose_library_path();
  void* handle = dlopen(lib_path.c_str(), RTLD_NOW);
  REQUIRE(handle != nullptr);

  w1::monitor::module_event event{};
  const auto has_loaded = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::module_event& e) {
        return e.type == w1::monitor::module_event::kind::loaded && !e.path.empty() &&
               e.path.find(lib_name) != std::string::npos;
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(has_loaded);

  dlclose(handle);

  const auto has_unloaded = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::module_event& e) {
        return e.type == w1::monitor::module_event::kind::unloaded && !e.path.empty() &&
               e.path.find(lib_name) != std::string::npos;
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(has_unloaded);

  monitor->stop();
}

TEST_CASE("w1monitor linux thread entry callback can override start routine") {
  auto monitor = w1::monitor::make_thread_monitor();
  REQUIRE(monitor != nullptr);

  std::atomic<bool> ran{false};
  std::atomic<int> observed_kind{-1};
  std::atomic<uint64_t> observed_tid{0};
  std::atomic<void*> observed_start{nullptr};
  std::atomic<void*> observed_arg{nullptr};

  monitor->set_entry_callback([&](const w1::monitor::thread_entry_context& ctx, uint64_t& result_out) {
    observed_kind.store(static_cast<int>(ctx.kind), std::memory_order_release);
    observed_tid.store(ctx.tid, std::memory_order_release);
    observed_start.store(ctx.start_routine, std::memory_order_release);
    observed_arg.store(ctx.arg, std::memory_order_release);
    result_out = static_cast<uint64_t>(kOverrideResult);
    return true;
  });

  monitor->start();

  pthread_t thread{};
  REQUIRE(pthread_create(&thread, nullptr, &entry_callback_start, &ran) == 0);

  void* thread_result = nullptr;
  pthread_join(thread, &thread_result);

  CHECK(thread_result == reinterpret_cast<void*>(kOverrideResult));
  CHECK(ran.load(std::memory_order_acquire) == false);
  CHECK(observed_kind.load(std::memory_order_acquire) == static_cast<int>(w1::monitor::thread_entry_kind::posix));
  CHECK(observed_tid.load(std::memory_order_acquire) != 0);
  CHECK(observed_start.load(std::memory_order_acquire) == reinterpret_cast<void*>(entry_callback_start));
  CHECK(observed_arg.load(std::memory_order_acquire) == &ran);

  monitor->stop();
}

TEST_CASE("w1monitor linux thread monitor reports start/stop/rename") {
  auto monitor = w1::monitor::make_thread_monitor();
  REQUIRE(monitor != nullptr);
  monitor->start();

  std::atomic<uint64_t> worker_tid{0};

  pthread_t thread{};
  auto start_fn = [](void* data) -> void* {
    auto* tid_ptr = static_cast<std::atomic<uint64_t>*>(data);
    const uint64_t tid = static_cast<uint64_t>(syscall(SYS_gettid));
    tid_ptr->store(tid, std::memory_order_release);
    pthread_setname_np(pthread_self(), "w1mon_worker");
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
    return nullptr;
  };

  REQUIRE(pthread_create(&thread, nullptr, start_fn, &worker_tid) == 0);

  while (worker_tid.load(std::memory_order_acquire) == 0) {
    std::this_thread::yield();
  }

  const uint64_t tid = worker_tid.load(std::memory_order_acquire);
  w1::monitor::thread_event event{};

  const auto saw_started = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::thread_event& e) {
        return e.type == w1::monitor::thread_event::kind::started && e.tid == tid;
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(saw_started);

  const auto saw_rename = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::thread_event& e) {
        return e.type == w1::monitor::thread_event::kind::renamed && e.tid == tid && e.name == "w1mon_worker";
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(saw_rename);

  pthread_join(thread, nullptr);

  const auto saw_stopped = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::thread_event& e) {
        return e.type == w1::monitor::thread_event::kind::stopped && e.tid == tid;
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(saw_stopped);

  monitor->stop();
}

TEST_CASE("w1monitor linux thread monitor captures dlopen thread start/stop") {
  auto monitor = w1::monitor::make_thread_monitor();
  REQUIRE(monitor != nullptr);
  monitor->start();

  const auto lib_path = w1::test_paths::monitor_thread_library_path();
  REQUIRE(!lib_path.empty());

  void* handle = dlopen(lib_path.c_str(), RTLD_NOW);
  REQUIRE(handle != nullptr);

  auto spawn_thread = reinterpret_cast<spawn_thread_fn>(dlsym(handle, "w1monitor_spawn_thread"));
  auto join_thread = reinterpret_cast<join_thread_fn>(dlsym(handle, "w1monitor_join_thread"));
  REQUIRE(spawn_thread != nullptr);
  REQUIRE(join_thread != nullptr);

  pthread_t thread{};
  uint64_t tid = 0;
  REQUIRE(spawn_thread(&thread, &tid, "w1mon_plugin") == 0);
  REQUIRE(tid != 0);

  w1::monitor::thread_event event{};
  const auto saw_started = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::thread_event& e) {
        return e.type == w1::monitor::thread_event::kind::started && e.tid == tid;
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(saw_started);

  const auto saw_rename = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::thread_event& e) {
        return e.type == w1::monitor::thread_event::kind::renamed && e.tid == tid && e.name == "w1mon_plugin";
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(saw_rename);

  CHECK(join_thread(thread) == 0);

  const auto saw_stopped = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::thread_event& e) {
        return e.type == w1::monitor::thread_event::kind::stopped && e.tid == tid;
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(saw_stopped);

  dlclose(handle);
  monitor->stop();
}

#endif

```

`test/w1monitor/monitor_tests_windows.cpp`:

```cpp
#if defined(_WIN32)

#include "doctest/doctest.hpp"

#include <atomic>
#include <chrono>
#include <mutex>
#include <string>
#include <thread>

#include <windows.h>

#include "w1monitor/monitor_factory.hpp"
#include "w1monitor/module_monitor.hpp"
#include "w1monitor/thread_monitor.hpp"
#include "monitor_test_helpers.hpp"
#include "test_paths.hpp"

namespace {

using w1::monitor::test::wait_for_event;

struct thread_name_params {
  std::atomic<uint64_t>* tid_out = nullptr;
  const wchar_t* name = nullptr;
  DWORD sleep_ms = 0;
};

DWORD WINAPI thread_start_with_name(LPVOID param) {
  auto* params = static_cast<thread_name_params*>(param);
  if (params && params->tid_out) {
    params->tid_out->store(static_cast<uint64_t>(GetCurrentThreadId()), std::memory_order_release);
  }
  if (params && params->name) {
    HMODULE kernel32 = GetModuleHandleW(L"kernel32.dll");
    if (kernel32) {
      auto set_desc =
          reinterpret_cast<HRESULT(WINAPI*)(HANDLE, PCWSTR)>(GetProcAddress(kernel32, "SetThreadDescription"));
      if (set_desc) {
        set_desc(GetCurrentThread(), params->name);
      }
    }
  }
  if (params && params->sleep_ms > 0) {
    Sleep(params->sleep_ms);
  }
  return 0;
}

DWORD WINAPI thread_start_record_tid(LPVOID param) {
  auto* tid_ptr = static_cast<std::atomic<uint64_t>*>(param);
  if (tid_ptr) {
    tid_ptr->store(static_cast<uint64_t>(GetCurrentThreadId()), std::memory_order_release);
  }
  Sleep(25);
  return 0;
}

DWORD WINAPI thread_start_set_flag(LPVOID param) {
  auto* flag = static_cast<std::atomic<bool>*>(param);
  if (flag) {
    flag->store(true, std::memory_order_release);
  }
  return 7;
}

} // namespace

TEST_CASE("w1monitor windows module monitor reports load/unload") {
  auto monitor = w1::monitor::make_module_monitor();
  REQUIRE(monitor != nullptr);
  monitor->start();

  const char* lib_name = w1::test_paths::interpose_library_name();
  const auto lib_path = w1::test_paths::interpose_library_path();
  HMODULE handle = LoadLibraryA(lib_path.c_str());
  REQUIRE(handle != nullptr);

  w1::monitor::module_event event{};
  void* loaded_base = nullptr;
  size_t loaded_size = 0;
  const auto saw_loaded = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::module_event& e) {
        return e.type == w1::monitor::module_event::kind::loaded && !e.path.empty() &&
               e.path.find(lib_name) != std::string::npos;
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(saw_loaded);
  if (saw_loaded) {
    loaded_base = event.base;
    loaded_size = event.size;
    CHECK(loaded_base != nullptr);
    CHECK(loaded_size > 0);
  }

  FreeLibrary(handle);

  const auto saw_unloaded = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::module_event& e) {
        if (e.type != w1::monitor::module_event::kind::unloaded) {
          return false;
        }
        if (loaded_base && e.base == loaded_base) {
          return true;
        }
        return !e.path.empty() && e.path.find(lib_name) != std::string::npos;
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(saw_unloaded);
  if (saw_unloaded && loaded_base && event.base == loaded_base) {
    CHECK(event.size == loaded_size);
  }

  monitor->stop();
}

TEST_CASE("w1monitor windows thread monitor reports start/stop/rename") {
  auto monitor = w1::monitor::make_thread_monitor();
  REQUIRE(monitor != nullptr);
  monitor->start();

  std::atomic<uint64_t> worker_tid{0};
  thread_name_params params{};
  params.tid_out = &worker_tid;
  params.name = L"w1mon_worker";
  params.sleep_ms = 50;

  DWORD thread_id = 0;
  HANDLE thread = CreateThread(nullptr, 0, thread_start_with_name, &params, 0, &thread_id);
  REQUIRE(thread != nullptr);

  while (worker_tid.load(std::memory_order_acquire) == 0) {
    std::this_thread::yield();
  }
  const uint64_t tid = worker_tid.load(std::memory_order_acquire);

  w1::monitor::thread_event event{};
  const auto saw_started = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::thread_event& e) {
        return e.type == w1::monitor::thread_event::kind::started && e.tid == tid;
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(saw_started);

  HMODULE kernel32 = GetModuleHandleW(L"kernel32.dll");
  const bool has_set_description = kernel32 && GetProcAddress(kernel32, "SetThreadDescription") != nullptr;

  if (has_set_description) {
    const auto saw_rename = wait_for_event(
        *monitor, event,
        [&](const w1::monitor::thread_event& e) {
          return e.type == w1::monitor::thread_event::kind::renamed && e.tid == tid && e.name == "w1mon_worker";
        },
        std::chrono::milliseconds(1000)
    );
    CHECK(saw_rename);
  }

  WaitForSingleObject(thread, INFINITE);
  CloseHandle(thread);

  const auto saw_stopped = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::thread_event& e) {
        return e.type == w1::monitor::thread_event::kind::stopped && e.tid == tid;
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(saw_stopped);

  monitor->stop();
}

TEST_CASE("w1monitor windows thread monitor captures GetProcAddress thread start/stop") {
  auto monitor = w1::monitor::make_thread_monitor();
  REQUIRE(monitor != nullptr);
  monitor->start();

  std::atomic<uint64_t> worker_tid{0};

  HMODULE kernel32 = GetModuleHandleW(L"kernel32.dll");
  REQUIRE(kernel32 != nullptr);
  auto create_thread = reinterpret_cast<decltype(&CreateThread)>(GetProcAddress(kernel32, "CreateThread"));
  REQUIRE(create_thread != nullptr);

  DWORD thread_id = 0;
  HANDLE thread = create_thread(nullptr, 0, thread_start_record_tid, &worker_tid, 0, &thread_id);
  REQUIRE(thread != nullptr);

  while (worker_tid.load(std::memory_order_acquire) == 0) {
    std::this_thread::yield();
  }
  const uint64_t tid = worker_tid.load(std::memory_order_acquire);

  w1::monitor::thread_event event{};
  const auto saw_started = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::thread_event& e) {
        return e.type == w1::monitor::thread_event::kind::started && e.tid == tid;
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(saw_started);

  WaitForSingleObject(thread, INFINITE);
  CloseHandle(thread);

  const auto saw_stopped = wait_for_event(
      *monitor, event,
      [&](const w1::monitor::thread_event& e) {
        return e.type == w1::monitor::thread_event::kind::stopped && e.tid == tid;
      },
      std::chrono::milliseconds(1000)
  );
  CHECK(saw_stopped);

  monitor->stop();
}

TEST_CASE("w1monitor windows thread monitor entry callback can override") {
  auto monitor = w1::monitor::make_thread_monitor();
  REQUIRE(monitor != nullptr);
  monitor->start();

  std::atomic<bool> start_called{false};
  std::atomic<bool> callback_called{false};
  std::mutex capture_mutex;
  w1::monitor::thread_entry_context captured{};

  monitor->set_entry_callback([&](const w1::monitor::thread_entry_context& ctx, uint64_t& result) {
    {
      std::lock_guard<std::mutex> lock(capture_mutex);
      captured = ctx;
    }
    callback_called.store(true, std::memory_order_release);
    result = 0xBEEF;
    return true;
  });

  DWORD thread_id = 0;
  HANDLE thread = CreateThread(nullptr, 0, thread_start_set_flag, &start_called, 0, &thread_id);
  REQUIRE(thread != nullptr);

  WaitForSingleObject(thread, INFINITE);

  DWORD exit_code = 0;
  CHECK(GetExitCodeThread(thread, &exit_code));
  CloseHandle(thread);

  CHECK(callback_called.load(std::memory_order_acquire));
  CHECK_FALSE(start_called.load(std::memory_order_acquire));
  CHECK(exit_code == 0xBEEF);

  {
    std::lock_guard<std::mutex> lock(capture_mutex);
    CHECK(captured.kind == w1::monitor::thread_entry_kind::win32);
    CHECK(captured.tid == static_cast<uint64_t>(thread_id));
    CHECK(captured.start_routine == reinterpret_cast<void*>(&thread_start_set_flag));
    CHECK(captured.arg == &start_called);
  }

  monitor->stop();
}

#endif

```

`test/w1monitor/test_main.cpp`:

```cpp
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "doctest/doctest.hpp"

```

`test/w1replay/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${W1_SOURCE_DIR}/cmake/TestConfig.cmake)

find_package(Threads REQUIRED)
find_package(Python3 COMPONENTS Interpreter REQUIRED)

set(W1REPLAY_TEST_SOURCES
    test_main.cpp
    gdb_adapter_test.cpp
    gdb_layout_test.cpp
    gdb_target_xml_test.cpp
    gdb_memory_map_test.cpp
    gdb_memory_read_test.cpp
    gdb_pc_only_test.cpp
    gdb_host_process_info_test.cpp
    gdb_run_policy_test.cpp
    gdb_register_info_test.cpp
    gdb_stepper_test.cpp
    gdb_value_codec_test.cpp
    gdb_loaded_libraries_test.cpp
    gdb_libraries_component_test.cpp
    module_image_test.cpp
    module_address_index_test.cpp
    module_path_resolver_test.cpp
    replay_context_test.cpp
    ${W1_SOURCE_DIR}/src/w1replay/modules/address_index.cpp
    ${W1_SOURCE_DIR}/src/w1replay/modules/module_image.cpp
    ${W1_SOURCE_DIR}/src/w1replay/modules/module_image_lief.cpp
    ${W1_SOURCE_DIR}/src/w1replay/modules/asmr_block_decoder.cpp
    ${W1_SOURCE_DIR}/src/w1replay/modules/lief_module_provider.cpp
    ${W1_SOURCE_DIR}/src/w1replay/modules/path_resolver.cpp
    ${W1_SOURCE_DIR}/src/w1replay/trace_loader/trace_loader.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/adapter.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/loaded_libraries_provider.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/triple_utils.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/components/regs_component.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/components/mem_component.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/components/run_component.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/components/breakpoints_component.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/components/threads_component.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/components/host_info_component.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/components/memory_layout_component.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/components/libraries_component.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/components/loaded_libraries_component.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/components/process_info_component.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/components/auxv_component.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/components/offsets_component.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/components/register_info_component.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/lldb/darwin_loaded_libraries.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/layout.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/target_xml.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/memory_map.cpp
    ${W1_SOURCE_DIR}/src/w1replay/memory/memory_view.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/value_codec.cpp
    ${W1_SOURCE_DIR}/src/w1replay/gdb/stepper.cpp
)

w1_add_doctest_suite(w1replay_unit_tests
    SOURCES ${W1REPLAY_TEST_SOURCES}
    INCLUDE_DIRS
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/third_party
        ${W1_SOURCE_DIR}/test
    LIBS
        w1rewind_record
        w1rewind_replay
        gdbstub::gdbstub
        Threads::Threads
    OUTPUT_SUBDIR w1replay
)

add_test(
    NAME w1replay_trace_e2e
    COMMAND ${Python3_EXECUTABLE}
        ${CMAKE_CURRENT_LIST_DIR}/e2e/trace_e2e_test.py
        --w1tool ${W1_OUTPUT_BIN_DIR}/w1tool${CMAKE_EXECUTABLE_SUFFIX}
        --w1replay ${W1_OUTPUT_BIN_DIR}/w1replay${CMAKE_EXECUTABLE_SUFFIX}
        --samples-dir ${W1_OUTPUT_SAMPLE_DIR}/programs
)
set_tests_properties(w1replay_trace_e2e PROPERTIES
    WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
    LABELS \"trace\"
)

if(WITNESS_LIEF)
    add_test(
        NAME w1replay_lldb_flow_e2e
        COMMAND ${Python3_EXECUTABLE}
            ${CMAKE_CURRENT_LIST_DIR}/e2e/lldb_flow_e2e_test.py
            --w1tool ${W1_OUTPUT_BIN_DIR}/w1tool${CMAKE_EXECUTABLE_SUFFIX}
            --w1replay ${W1_OUTPUT_BIN_DIR}/w1replay${CMAKE_EXECUTABLE_SUFFIX}
            --samples-dir ${W1_OUTPUT_SAMPLE_DIR}/programs
    )
    set_tests_properties(w1replay_lldb_flow_e2e PROPERTIES
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
        LABELS \"lldb\"
    )
endif()

add_test(
    NAME w1replay_lldb_state_e2e
    COMMAND ${Python3_EXECUTABLE}
        ${CMAKE_CURRENT_LIST_DIR}/e2e/lldb_state_e2e_test.py
        --w1tool ${W1_OUTPUT_BIN_DIR}/w1tool${CMAKE_EXECUTABLE_SUFFIX}
        --w1replay ${W1_OUTPUT_BIN_DIR}/w1replay${CMAKE_EXECUTABLE_SUFFIX}
        --samples-dir ${W1_OUTPUT_SAMPLE_DIR}/programs
)
set_tests_properties(w1replay_lldb_state_e2e PROPERTIES
    WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
    LABELS \"lldb\"
)

```

`test/w1replay/e2e/common.py`:

```py
#!/usr/bin/env python3

from __future__ import annotations

import os
import queue
import re
import shutil
import socket
import subprocess
import tempfile
import threading
import time
from dataclasses import dataclass
from typing import Callable, Dict, Iterable, List, Optional, Sequence, Tuple


@dataclass
class ProcessResult:
    proc: subprocess.Popen[str]
    output_queue: "queue.Queue[str]"
    thread: threading.Thread

    def terminate(self, timeout: float) -> None:
        if self.proc.poll() is not None:
            return
        self.proc.terminate()
        try:
            self.proc.wait(timeout=timeout)
        except subprocess.TimeoutExpired:
            self.proc.kill()
            self.proc.wait(timeout=timeout)

    def drain_output(self) -> str:
        lines: list[str] = []
        while True:
            try:
                lines.append(self.output_queue.get_nowait())
            except queue.Empty:
                break
        return "".join(lines)


@dataclass
class MemoryDump:
    address: int
    bytes: List[Optional[int]]


@dataclass
class InspectStep:
    seq: int
    addr: int
    kind: str
    regs: Dict[str, int]
    memory: Optional[MemoryDump]


@dataclass
class InspectTrace:
    steps: List[InspectStep]

    def addresses(self) -> List[int]:
        return [step.addr for step in self.steps]


def run_cmd(args: Sequence[str], timeout: float) -> subprocess.CompletedProcess[str]:
    return subprocess.run(list(args), text=True, capture_output=True, timeout=timeout)


def start_process(args: Sequence[str]) -> ProcessResult:
    proc = subprocess.Popen(
        list(args),
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        bufsize=1,
    )
    assert proc.stdout is not None
    output_queue: "queue.Queue[str]" = queue.Queue()

    def reader() -> None:
        for line in proc.stdout:
            output_queue.put(line)

    thread = threading.Thread(target=reader, daemon=True)
    thread.start()
    return ProcessResult(proc=proc, output_queue=output_queue, thread=thread)


def wait_for_output_line(
    result: ProcessResult, predicate: Callable[[str], bool], timeout: float
) -> Optional[str]:
    deadline = time.monotonic() + timeout
    while time.monotonic() < deadline:
        if result.proc.poll() is not None:
            return None
        try:
            line = result.output_queue.get(timeout=0.1)
        except queue.Empty:
            continue
        if predicate(line):
            return line
    return None


def next_available_port(host: str) -> int:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.bind((host, 0))
        return int(sock.getsockname()[1])


def record_trace(
    w1tool: str,
    trace_path: str,
    configs: Iterable[str],
    sample_path: str,
    timeout: float,
) -> None:
    sample_path = resolve_executable_path(sample_path)
    cmd = [w1tool, "tracer", "-n", "w1rewind", "-s", "-o", trace_path]
    for cfg in configs:
        cmd.extend(["-c", cfg])
    cmd.extend(["--", sample_path])
    result = run_cmd(cmd, timeout=timeout)
    if result.returncode != 0:
        raise RuntimeError(
            "trace recording failed: {code}\nstdout:\n{out}\nstderr:\n{err}".format(
                code=result.returncode, out=result.stdout, err=result.stderr
            )
        )


def select_thread_id(w1replay: str, trace_path: str, timeout: float) -> int:
    result = run_cmd([w1replay, "threads", "--trace", trace_path], timeout=timeout)
    if result.returncode != 0:
        raise RuntimeError(
            f"threads failed: {result.returncode}\nstdout:\n{result.stdout}\nstderr:\n{result.stderr}"
        )
    for line in (result.stdout + result.stderr).splitlines():
        match = re.search(r"thread=(\d+)", line)
        if match:
            return int(match.group(1))
    raise RuntimeError("no thread id found in w1replay threads output")


def run_inspect(
    w1replay: str,
    trace_path: str,
    thread_id: int,
    count: int,
    timeout: float,
    inst: bool = False,
    regs: bool = False,
    mem: Optional[str] = None,
    start: Optional[int] = None,
) -> str:
    cmd = [
        w1replay,
        "inspect",
        "--trace",
        trace_path,
        "--thread",
        str(thread_id),
        "--count",
        str(count),
    ]
    if inst:
        cmd.append("--inst")
    if regs:
        cmd.append("--regs")
    if mem:
        cmd.extend(["--mem", mem])
    if start is not None:
        cmd.extend(["--start", str(start)])
    result = run_cmd(cmd, timeout=timeout)
    if result.returncode != 0:
        raise RuntimeError(
            "inspect failed: {code}\nstdout:\n{out}\nstderr:\n{err}".format(
                code=result.returncode, out=result.stdout, err=result.stderr
            )
        )
    return result.stdout + result.stderr


def parse_inspect_output(output: str) -> InspectTrace:
    steps: List[InspectStep] = []
    current: Optional[InspectStep] = None

    step_re = re.compile(
        r"seq=(\d+)\s+addr=(0x[0-9a-fA-F]+)\s+module=(.+?)\s+kind=(\w+)"
    )
    regs_re = re.compile(r"^\s*regs:\s*(.*)$")
    mem_re = re.compile(r"^\s*mem\[(0x[0-9a-fA-F]+):(\d+)\]:\s*(.*)$")

    for line in output.splitlines():
        match = step_re.search(line)
        if match:
            seq = int(match.group(1))
            addr = int(match.group(2), 16)
            kind = match.group(4)
            current = InspectStep(seq=seq, addr=addr, kind=kind, regs={}, memory=None)
            steps.append(current)
            continue
        match = regs_re.search(line)
        if match and current is not None:
            payload = match.group(1)
            if payload and payload not in {"unknown", "unavailable"}:
                for token in payload.split():
                    if "=" not in token:
                        continue
                    name, value = token.split("=", 1)
                    try:
                        current.regs[name] = int(value, 16)
                    except ValueError:
                        continue
            continue
        match = mem_re.search(line)
        if match and current is not None:
            address = int(match.group(1), 16)
            bytes_part = match.group(3).strip()
            parsed: List[Optional[int]] = []
            if bytes_part:
                for token in bytes_part.split():
                    if token == "??":
                        parsed.append(None)
                    else:
                        try:
                            parsed.append(int(token, 16))
                        except ValueError:
                            parsed.append(None)
            current.memory = MemoryDump(address=address, bytes=parsed)
            continue

    return InspectTrace(steps=steps)


def find_first_matching_index(values: List[int], target: int) -> Optional[int]:
    for idx, value in enumerate(values):
        if value == target:
            return idx
    return None


def parse_lldb_register_values(output: str) -> Dict[str, int]:
    reg_re = re.compile(r"^\s*([a-zA-Z0-9_]+)\s*=\s*0x([0-9a-fA-F]+)")
    regs: Dict[str, int] = {}
    for line in output.splitlines():
        match = reg_re.match(line)
        if match:
            regs[match.group(1)] = int(match.group(2), 16)
    return regs


def parse_lldb_pc_values(output: str) -> List[int]:
    pc_re = re.compile(r"^\s*(pc|rip|eip)\s*=\s*0x([0-9a-fA-F]+)")
    pcs: List[int] = []
    for line in output.splitlines():
        match = pc_re.match(line)
        if match:
            pcs.append(int(match.group(2), 16))
    return pcs


def parse_lldb_memory_bytes(output: str, count: int) -> List[int]:
    line_re = re.compile(r"^0x[0-9a-fA-F]+:\s*(.*)$")
    bytes_out: List[int] = []
    for line in output.splitlines():
        match = line_re.match(line.strip())
        if not match:
            continue
        for token in match.group(1).split():
            if len(token) != 2:
                continue
            try:
                bytes_out.append(int(token, 16))
            except ValueError:
                continue
            if len(bytes_out) >= count:
                return bytes_out
    return bytes_out


def run_lldb(
    lldb_path: str, commands: Sequence[str], timeout: float
) -> subprocess.CompletedProcess[str]:
    args = [lldb_path, "--no-lldbinit", "-b"]
    for cmd in commands:
        args.extend(["-o", cmd])
    return subprocess.run(args, text=True, capture_output=True, timeout=timeout)


def resolve_lldb_path(lldb_arg: str) -> Optional[str]:
    return shutil.which(lldb_arg)


def lldb_connect_commands(sample_path: str, host: str, port: int) -> List[str]:
    return [
        f"target create {sample_path}",
        f"process connect --plugin gdb-remote connect://{host}:{port}",
    ]


def resolve_executable_path(path: str) -> str:
    if os.name != "nt":
        return path
    root, ext = os.path.splitext(path)
    if ext:
        return path
    candidate = path + ".exe"
    if os.path.exists(candidate):
        return candidate
    return path


def start_server(
    w1replay: str,
    trace_path: str,
    port: int,
    inst: bool,
    timeout: float,
    start: Optional[int] = None,
    thread_id: Optional[int] = None,
    module_mappings: Optional[Sequence[str]] = None,
    module_dirs: Optional[Sequence[str]] = None,
) -> ProcessResult:
    cmd = [w1replay, "server", "--gdb", f"127.0.0.1:{port}", "--trace", trace_path]
    if inst:
        cmd.append("--inst")
    if start is not None:
        cmd.extend(["--start", str(start)])
    if thread_id is not None and thread_id != 0:
        cmd.extend(["--thread", str(thread_id)])
    if module_mappings:
        for mapping in module_mappings:
            cmd.extend(["--module", mapping])
    if module_dirs:
        for directory in module_dirs:
            cmd.extend(["--module-dir", directory])
    result = start_process(cmd)
    line = wait_for_output_line(result, lambda l: "listening" in l, timeout)
    if line is None:
        output = result.drain_output()
        result.terminate(timeout=1.0)
        raise RuntimeError(f"server did not start\noutput:\n{output}")
    return result


def make_temp_trace_path(name: str) -> str:
    return os.path.join(tempfile.gettempdir(), f"w1replay_{name}.trace")


def ensure_binaries_exist(paths: Iterable[str]) -> None:
    missing = [path for path in paths if not os.path.exists(path)]
    if missing:
        raise RuntimeError("missing binaries: " + ", ".join(missing))


def pick_known_registers(regs: Dict[str, int], count: int) -> List[Tuple[str, int]]:
    exclude = {
        "pc",
        "sp",
        "nzcv",
        "cpsr",
        "rflags",
        "eflags",
        "cs",
        "ss",
        "ds",
        "es",
        "fs",
        "gs",
        "lr",
    }
    general = set()
    for i in range(31):
        general.add(f"x{i}")
    for i in range(13):
        general.add(f"r{i}")
    for i in range(8, 16):
        general.add(f"r{i}")
    general.update(
        {
            "rax",
            "rbx",
            "rcx",
            "rdx",
            "rsi",
            "rdi",
            "rbp",
            "r8",
            "r9",
            "r10",
            "r11",
            "r12",
            "r13",
            "r14",
            "r15",
            "eax",
            "ebx",
            "ecx",
            "edx",
            "esi",
            "edi",
            "ebp",
        }
    )
    items = [
        (name, value)
        for name, value in regs.items()
        if name not in exclude and name in general
    ]
    items.sort(key=lambda item: item[0])
    if len(items) >= count:
        return items[:count]
    fallback = [
        (name, value) for name, value in regs.items() if name not in exclude
    ]
    fallback.sort(key=lambda item: item[0])
    return fallback[:count]


def find_stack_pointer(regs: Dict[str, int]) -> Optional[int]:
    for name in ("sp", "rsp", "esp"):
        if name in regs:
            return regs[name]
    return None

```

`test/w1replay/e2e/lldb_flow_e2e_test.py`:

```py
#!/usr/bin/env python3

from __future__ import annotations

import argparse
import os
import re
import sys
import tempfile
from typing import List, Tuple

from common import (
    ensure_binaries_exist,
    find_first_matching_index,
    make_temp_trace_path,
    parse_inspect_output,
    parse_lldb_pc_values,
    record_trace,
    resolve_executable_path,
    resolve_lldb_path,
    run_inspect,
    run_lldb,
    select_thread_id,
    start_server,
    next_available_port,
    lldb_connect_commands,
)


class Scenario:
    def __init__(
        self,
        name: str,
        configs: List[str],
        sample: str,
        inspect_inst: bool,
        server_inst: bool,
    ) -> None:
        self.name = name
        self.configs = configs
        self.sample = sample
        self.inspect_inst = inspect_inst
        self.server_inst = server_inst


def parse_reverse_pc(log_text: str) -> int:
    matches = re.findall(r"thread-pcs:([0-9a-fA-F]+)", log_text)
    if not matches:
        raise AssertionError("no thread-pcs entries in gdb-remote log")
    return int(matches[-1], 16)


def run_step_session(
    lldb_path: str,
    host: str,
    port: int,
    step_count: int,
    timeout: float,
    log_path: str,
    sample_path: str,
) -> Tuple[List[int], int]:
    commands = [
        f"target create {sample_path}",
        f"log enable -f {log_path} gdb-remote packets",
        f"process connect --plugin gdb-remote connect://{host}:{port}",
        "register read pc",
    ]
    for _ in range(step_count):
        commands.append("thread step-inst -c 1")
        commands.append("register read pc")
    commands.append("process plugin packet send bs")
    commands.append("register read pc")

    commands.append("disassemble -c 1 -s $pc")
    result = run_lldb(lldb_path, commands, timeout)
    output = result.stdout + result.stderr
    if result.returncode != 0:
        raise RuntimeError(f"lldb step session failed: {result.returncode}\n{output}")
    if "disassembly unavailable" in output:
        raise AssertionError("lldb disassembly unavailable in step session")
    pcs = parse_lldb_pc_values(output)
    if len(pcs) < step_count + 2:
        raise AssertionError(f"expected {step_count + 2} pc reads, got {len(pcs)}")
    try:
        with open(log_path, "r") as handle:
            log_text = handle.read()
    except OSError as exc:
        raise RuntimeError(f"failed to read gdb-remote log: {exc}") from exc
    reverse_pc = parse_reverse_pc(log_text)
    return pcs, reverse_pc


def run_break_session(
    lldb_path: str,
    sample_path: str,
    host: str,
    port: int,
    break_addr: int,
    timeout: float,
) -> int:
    commands = lldb_connect_commands(sample_path, host, port)
    commands.extend(
        [
            f"breakpoint set -a 0x{break_addr:x}",
            "process continue",
            "register read pc",
        ]
    )
    result = run_lldb(lldb_path, commands, timeout)
    output = result.stdout + result.stderr
    if result.returncode != 0:
        raise RuntimeError(f"lldb break session failed: {result.returncode}\n{output}")
    pcs = parse_lldb_pc_values(output)
    if not pcs:
        raise AssertionError("no pc read after breakpoint")
    return pcs[-1]


def main() -> int:
    parser = argparse.ArgumentParser(description="w1replay LLDB flow end-to-end test")
    parser.add_argument("--w1tool", required=True)
    parser.add_argument("--w1replay", required=True)
    parser.add_argument("--samples-dir", required=True)
    parser.add_argument("--lldb", default=os.environ.get("LLDB_PATH", "lldb"))
    parser.add_argument("--timeout", type=float, default=60.0)
    args = parser.parse_args()

    ensure_binaries_exist([args.w1tool, args.w1replay])

    lldb_path = resolve_lldb_path(args.lldb)
    if lldb_path is None:
        print("skipping: lldb not found", file=sys.stderr)
        return 0

    scenarios = [
        Scenario(
            name="block_inst",
            configs=[
                "flow=block",
                "reg_deltas=false",
                "mem_access=none",
            ],
            sample="simple_demo",
            inspect_inst=True,
            server_inst=True,
        ),
        Scenario(
            name="instruction",
            configs=[
                "flow=instruction",
                "reg_deltas=false",
                "mem_access=none",
            ],
            sample="rewind_demo_basic",
            inspect_inst=False,
            server_inst=False,
        ),
    ]

    for scenario in scenarios:
        trace_path = make_temp_trace_path(f"flow_{scenario.name}")
        sample_path = resolve_executable_path(os.path.join(args.samples_dir, scenario.sample))
        record_trace(args.w1tool, trace_path, scenario.configs, sample_path, args.timeout)
        thread_id = select_thread_id(args.w1replay, trace_path, args.timeout)

        inspect_output = run_inspect(
            args.w1replay,
            trace_path,
            thread_id,
            count=10,
            timeout=args.timeout,
            inst=scenario.inspect_inst,
        )
        inspect_trace = parse_inspect_output(inspect_output)
        expected_pcs = inspect_trace.addresses()
        if len(expected_pcs) < 6:
            raise AssertionError(f"{scenario.name}: need at least 6 inspect steps")

        host = "127.0.0.1"
        module_mapping = f"{os.path.basename(sample_path)}={sample_path}"
        port = next_available_port(host)
        server = start_server(
            args.w1replay,
            trace_path,
            port,
            scenario.server_inst,
            args.timeout,
            module_mappings=[module_mapping],
        )
        try:
            step_count = 4
            log_path = os.path.join(tempfile.gettempdir(), f"w1replay_flow_{scenario.name}_{port}.log")
            pcs, reverse_pc = run_step_session(
                lldb_path, host, port, step_count, args.timeout, log_path, sample_path
            )
        finally:
            server.terminate(timeout=1.0)

        start_pc = pcs[0]
        align = find_first_matching_index(expected_pcs, start_pc)
        if align is None:
            raise AssertionError(f"{scenario.name}: current pc not found in inspect list")
        if align + step_count >= len(expected_pcs):
            raise AssertionError(f"{scenario.name}: inspect list too short for steps")

        for i in range(1, step_count + 1):
            expected = expected_pcs[align + i]
            if pcs[i] != expected:
                raise AssertionError(
                    f"{scenario.name}: step {i} pc mismatch: got 0x{pcs[i]:x}, expected 0x{expected:x}"
                )

        reverse_expected = expected_pcs[align + step_count - 1]
        if reverse_pc != reverse_expected:
            raise AssertionError(
                f"{scenario.name}: reverse step pc mismatch: got 0x{reverse_pc:x}, expected 0x{reverse_expected:x}"
            )

        break_target = expected_pcs[align + 3]
        port = next_available_port(host)
        server = start_server(
            args.w1replay,
            trace_path,
            port,
            scenario.server_inst,
            args.timeout,
            module_mappings=[module_mapping],
        )
        try:
            hit_pc = run_break_session(
                lldb_path, sample_path, host, port, break_target, args.timeout
            )
        finally:
            server.terminate(timeout=1.0)
        if hit_pc != break_target:
            raise AssertionError(
                f"{scenario.name}: breakpoint pc mismatch: got 0x{hit_pc:x}, expected 0x{break_target:x}"
            )

    return 0


if __name__ == "__main__":
    raise SystemExit(main())

```

`test/w1replay/e2e/lldb_state_e2e_test.py`:

```py
#!/usr/bin/env python3

from __future__ import annotations

import argparse
import os
import sys
from typing import Dict, List, Optional, Tuple

from common import (
    ensure_binaries_exist,
    find_first_matching_index,
    find_stack_pointer,
    make_temp_trace_path,
    parse_inspect_output,
    parse_lldb_memory_bytes,
    parse_lldb_pc_values,
    parse_lldb_register_values,
    pick_known_registers,
    record_trace,
    resolve_executable_path,
    resolve_lldb_path,
    run_inspect,
    run_lldb,
    select_thread_id,
    start_server,
    next_available_port,
    lldb_connect_commands,
)


def read_initial_pc(
    lldb_path: str, sample_path: str, host: str, port: int, timeout: float
) -> int:
    commands = lldb_connect_commands(sample_path, host, port)
    commands.append("register read pc")
    result = run_lldb(lldb_path, commands, timeout)
    output = result.stdout + result.stderr
    if result.returncode != 0:
        raise RuntimeError(f"lldb initial pc failed: {result.returncode}\n{output}")
    pcs = parse_lldb_pc_values(output)
    if not pcs:
        raise AssertionError("no pc read in lldb output")
    return pcs[-1]


def step_and_read_registers(
    lldb_path: str,
    sample_path: str,
    host: str,
    port: int,
    steps: int,
    reg_names: List[str],
    timeout: float,
) -> Dict[str, int]:
    commands = lldb_connect_commands(sample_path, host, port)
    for _ in range(steps):
        commands.append("thread step-inst -c 1")
    commands.append("register read " + " ".join(reg_names))
    result = run_lldb(lldb_path, commands, timeout)
    output = result.stdout + result.stderr
    if result.returncode != 0:
        raise RuntimeError(f"lldb register read failed: {result.returncode}\n{output}")
    return parse_lldb_register_values(output)


def step_and_read_memory(
    lldb_path: str,
    sample_path: str,
    host: str,
    port: int,
    steps: int,
    address: int,
    count: int,
    timeout: float,
) -> List[int]:
    commands = lldb_connect_commands(sample_path, host, port)
    for _ in range(steps):
        commands.append("thread step-inst -c 1")
    commands.append(f"memory read 0x{address:x} -c {count}")
    result = run_lldb(lldb_path, commands, timeout)
    output = result.stdout + result.stderr
    if result.returncode != 0:
        raise RuntimeError(f"lldb memory read failed: {result.returncode}\n{output}")
    return parse_lldb_memory_bytes(output, count)


def find_reg_step_index(steps, start_index: int) -> Tuple[int, Dict[str, int]]:
    for idx in range(start_index, len(steps)):
        if steps[idx].regs:
            picked = pick_known_registers(steps[idx].regs, 2)
            if len(picked) >= 2:
                return idx, dict(picked)
    raise AssertionError("no suitable register step found")


def find_mem_step_index(steps, start_index: int) -> Tuple[int, int]:
    for idx in range(start_index, len(steps)):
        sp = find_stack_pointer(steps[idx].regs)
        if sp is not None:
            return idx, sp
    raise AssertionError("no stack pointer found in inspect output")


def main() -> int:
    parser = argparse.ArgumentParser(description="w1replay LLDB state end-to-end test")
    parser.add_argument("--w1tool", required=True)
    parser.add_argument("--w1replay", required=True)
    parser.add_argument("--samples-dir", required=True)
    parser.add_argument("--lldb", default=os.environ.get("LLDB_PATH", "lldb"))
    parser.add_argument("--timeout", type=float, default=60.0)
    args = parser.parse_args()

    ensure_binaries_exist([args.w1tool, args.w1replay])

    lldb_path = resolve_lldb_path(args.lldb)
    if lldb_path is None:
        print("skipping: lldb not found", file=sys.stderr)
        return 0

    host = "127.0.0.1"

    # Register trace scenario
    reg_trace = make_temp_trace_path("state_regs")
    reg_sample = resolve_executable_path(os.path.join(args.samples_dir, "rewind_demo_calls"))
    record_trace(
        args.w1tool,
        reg_trace,
        [
            "flow=instruction",
            "reg_deltas=true",
            "mem_access=none",
        ],
        reg_sample,
        args.timeout,
    )
    thread_id = select_thread_id(args.w1replay, reg_trace, args.timeout)
    inspect_output = run_inspect(
        args.w1replay,
        reg_trace,
        thread_id,
        count=12,
        timeout=args.timeout,
        regs=True,
    )
    inspect_trace = parse_inspect_output(inspect_output)
    expected_pcs = inspect_trace.addresses()

    port = next_available_port(host)
    server = start_server(args.w1replay, reg_trace, port, inst=False, timeout=args.timeout)
    try:
        initial_pc = read_initial_pc(lldb_path, reg_sample, host, port, args.timeout)
    finally:
        server.terminate(timeout=1.0)
    align = find_first_matching_index(expected_pcs, initial_pc)
    if align is None:
        raise AssertionError("register trace: initial pc not found in inspect list")

    reg_step_index, expected_regs = find_reg_step_index(inspect_trace.steps, align)
    reg_names = list(expected_regs.keys())
    if reg_step_index < align:
        raise AssertionError("register trace: reg step index before align")
    delta = reg_step_index - align

    port = next_available_port(host)
    server = start_server(args.w1replay, reg_trace, port, inst=False, timeout=args.timeout)
    try:
        actual_regs = step_and_read_registers(
            lldb_path, reg_sample, host, port, delta, reg_names, args.timeout
        )
    finally:
        server.terminate(timeout=1.0)

    for name, expected in expected_regs.items():
        actual = actual_regs.get(name)
        if actual is None:
            raise AssertionError(f"register trace: missing {name} in LLDB output")
        if actual != expected:
            raise AssertionError(
                f"register trace: {name} mismatch: got 0x{actual:x}, expected 0x{expected:x}"
            )

    # Memory trace scenario
    mem_trace = make_temp_trace_path("state_mem")
    mem_sample = resolve_executable_path(os.path.join(args.samples_dir, "rewind_demo_memops"))
    record_trace(
        args.w1tool,
        mem_trace,
        [
            "flow=instruction",
            "reg_deltas=true",
            "mem_access=reads_writes",
            "mem_values=true",
            "stack_window_mode=frame",
            "stack_window_above=64",
            "stack_window_below=192",
            "stack_window_max=256",
            "stack_snapshot_interval=1",
        ],
        mem_sample,
        args.timeout,
    )
    thread_id = select_thread_id(args.w1replay, mem_trace, args.timeout)
    inspect_output = run_inspect(
        args.w1replay,
        mem_trace,
        thread_id,
        count=12,
        timeout=args.timeout,
        regs=True,
    )
    inspect_trace = parse_inspect_output(inspect_output)
    expected_pcs = inspect_trace.addresses()

    port = next_available_port(host)
    server = start_server(args.w1replay, mem_trace, port, inst=False, timeout=args.timeout)
    try:
        initial_pc = read_initial_pc(lldb_path, mem_sample, host, port, args.timeout)
    finally:
        server.terminate(timeout=1.0)
    align = find_first_matching_index(expected_pcs, initial_pc)
    if align is None:
        raise AssertionError("memory trace: initial pc not found in inspect list")

    mem_step_index, sp_value = find_mem_step_index(inspect_trace.steps, align)
    mem_output = run_inspect(
        args.w1replay,
        mem_trace,
        thread_id,
        count=mem_step_index + 1,
        timeout=args.timeout,
        mem=f"{hex(sp_value)}:16",
    )
    mem_trace_inspect = parse_inspect_output(mem_output)
    if mem_step_index >= len(mem_trace_inspect.steps):
        raise AssertionError("memory trace: missing expected mem step")
    mem_step = mem_trace_inspect.steps[mem_step_index]
    if mem_step.memory is None:
        raise AssertionError("memory trace: no memory data for expected step")
    expected_bytes = mem_step.memory.bytes

    delta = mem_step_index - align
    port = next_available_port(host)
    server = start_server(args.w1replay, mem_trace, port, inst=False, timeout=args.timeout)
    try:
        actual_bytes = step_and_read_memory(
            lldb_path, mem_sample, host, port, delta, sp_value, len(expected_bytes), args.timeout
        )
    finally:
        server.terminate(timeout=1.0)

    if len(actual_bytes) < len(expected_bytes):
        raise AssertionError("memory trace: LLDB returned fewer bytes than expected")
    for idx, expected in enumerate(expected_bytes):
        if expected is None:
            continue
        if actual_bytes[idx] != expected:
            raise AssertionError(
                f"memory trace: byte {idx} mismatch: got 0x{actual_bytes[idx]:02x}, expected 0x{expected:02x}"
            )

    return 0


if __name__ == "__main__":
    raise SystemExit(main())

```

`test/w1replay/e2e/trace_e2e_test.py`:

```py
#!/usr/bin/env python3

from __future__ import annotations

import argparse
import os
import sys
from typing import List

from common import (
    ensure_binaries_exist,
    make_temp_trace_path,
    parse_inspect_output,
    record_trace,
    run_inspect,
    select_thread_id,
)


def require_steps(steps, name: str) -> None:
    if not steps:
        raise AssertionError(f"{name}: no inspect steps found")
    if any(step.addr == 0 for step in steps):
        raise AssertionError(f"{name}: found zero address in steps")


def main() -> int:
    parser = argparse.ArgumentParser(description="w1replay trace end-to-end test")
    parser.add_argument("--w1tool", required=True)
    parser.add_argument("--w1replay", required=True)
    parser.add_argument("--samples-dir", required=True)
    parser.add_argument("--timeout", type=float, default=40.0)
    args = parser.parse_args()

    ensure_binaries_exist([args.w1tool, args.w1replay])

    scenarios = [
        {
            "name": "pc_only",
            "configs": [
                "flow=block",
                "reg_deltas=false",
                "mem_access=none",
            ],
            "sample": "simple_demo",
            "expect_kind": "block",
            "check_regs": False,
            "check_mem": False,
        },
        {
            "name": "instruction",
            "configs": [
                "flow=instruction",
                "reg_deltas=false",
                "mem_access=none",
            ],
            "sample": "rewind_demo_basic",
            "expect_kind": "instruction",
            "check_regs": False,
            "check_mem": False,
        },
        {
            "name": "regs",
            "configs": [
                "flow=instruction",
                "reg_deltas=true",
                "mem_access=none",
            ],
            "sample": "rewind_demo_calls",
            "expect_kind": "instruction",
            "check_regs": True,
            "check_mem": False,
        },
        {
            "name": "memory",
            "configs": [
                "flow=instruction",
                "reg_deltas=true",
                "mem_access=reads_writes",
                "mem_values=true",
                "stack_window_mode=frame",
                "stack_window_above=64",
                "stack_window_below=192",
                "stack_window_max=256",
                "stack_snapshot_interval=1",
            ],
            "sample": "rewind_demo_memops",
            "expect_kind": "instruction",
            "check_regs": True,
            "check_mem": True,
        },
    ]

    for scenario in scenarios:
        trace_path = make_temp_trace_path(scenario["name"])
        sample_path = os.path.join(args.samples_dir, scenario["sample"])
        record_trace(args.w1tool, trace_path, scenario["configs"], sample_path, args.timeout)

        thread_id = select_thread_id(args.w1replay, trace_path, args.timeout)
        output = run_inspect(
            args.w1replay,
            trace_path,
            thread_id,
            count=6,
            timeout=args.timeout,
            inst=False,
            regs=scenario["check_regs"],
        )
        trace = parse_inspect_output(output)
        require_steps(trace.steps, scenario["name"])
        if scenario["expect_kind"]:
            if any(step.kind != scenario["expect_kind"] for step in trace.steps):
                raise AssertionError(
                    f"{scenario['name']}: expected kind {scenario['expect_kind']} for all steps"
                )

        if scenario["check_regs"]:
            if not any(step.regs for step in trace.steps):
                raise AssertionError(f"{scenario['name']}: expected at least one register value")

        if scenario["check_mem"]:
            first_with_regs = next((step for step in trace.steps if step.regs), None)
            if first_with_regs is None:
                raise AssertionError(f"{scenario['name']}: no registers to locate stack pointer")
            sp = first_with_regs.regs.get("sp") or first_with_regs.regs.get("rsp") or first_with_regs.regs.get("esp")
            if sp is None:
                raise AssertionError(f"{scenario['name']}: no stack pointer register found")
            mem_output = run_inspect(
                args.w1replay,
                trace_path,
                thread_id,
                count=1,
                timeout=args.timeout,
                regs=False,
                mem=f"{hex(sp)}:16",
            )
            mem_trace = parse_inspect_output(mem_output)
            if not mem_trace.steps or mem_trace.steps[0].memory is None:
                raise AssertionError(f"{scenario['name']}: memory output missing")
            if not any(byte is not None for byte in mem_trace.steps[0].memory.bytes):
                raise AssertionError(f"{scenario['name']}: memory output contains no concrete bytes")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())

```

`test/w1replay/gdb_adapter_test.cpp`:

```cpp
#include <filesystem>
#include <string>
#include <vector>

#include "doctest/doctest.hpp"

#include <redlog.hpp>

#include "w1replay/gdb/adapter.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"

#include "w1rewind/rewind_test_helpers.hpp"

namespace {

std::filesystem::path write_trace(
    const char* name, const w1::arch::arch_spec& arch, std::vector<std::string> registers, uint64_t module_offset,
    uint64_t module_base = 0x1000
) {
  using namespace w1::rewind::test_helpers;

  std::filesystem::path trace_path = temp_path(name);

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1replay.gdb");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, arch, registers);
  write_module_table(*writer, 1, module_base);
  write_thread_start(*writer, 1, "thread1");
  write_instruction(*writer, 1, 0, module_base + module_offset);
  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();
  return trace_path;
}

bool has_reg_bitsize(const std::string& xml, const std::string& name, uint32_t bitsize) {
  std::string needle = "name=\"" + name + "\" bitsize=\"" + std::to_string(bitsize) + "\"";
  return xml.find(needle) != std::string::npos;
}

} // namespace

TEST_CASE("w1replay gdb adapter builds x86_64 target xml and pc") {
  auto trace_path = write_trace(
      "w1replay_gdb_x86_64.trace", w1::rewind::test_helpers::parse_arch_or_fail("x86_64"),
      {"rax", "rflags", "fs", "gs", "rip", "rsp"}, 0x1234
  );

  w1replay::gdb::adapter::config config;
  config.trace_path = trace_path.string();

  w1replay::gdb::adapter adapter(std::move(config));
  REQUIRE(adapter.open());

  CHECK(adapter.session().current_step().address == 0x2234);

  const auto& arch = adapter.arch_spec();
  CHECK(arch.address_bits.has_value());
  CHECK(*arch.address_bits == 64);
  CHECK(arch.target_xml.find("<architecture>i386:x86-64</architecture>") != std::string::npos);
  CHECK(has_reg_bitsize(arch.target_xml, "eflags", 32));
  CHECK(has_reg_bitsize(arch.target_xml, "fs", 16));
  CHECK(has_reg_bitsize(arch.target_xml, "gs", 16));
}

TEST_CASE("w1replay gdb adapter encodes arm64 register sizes") {
  auto trace_path = write_trace(
      "w1replay_gdb_arm64.trace", w1::rewind::test_helpers::parse_arch_or_fail("arm64"), {"x0", "sp", "pc", "nzcv"},
      0x2000
  );

  w1replay::gdb::adapter::config config;
  config.trace_path = trace_path.string();

  w1replay::gdb::adapter adapter(std::move(config));
  REQUIRE(adapter.open());

  const auto& arch = adapter.arch_spec();
  CHECK(arch.address_bits.has_value());
  CHECK(*arch.address_bits == 64);
  CHECK(arch.target_xml.find("<architecture>aarch64</architecture>") != std::string::npos);
  CHECK(has_reg_bitsize(arch.target_xml, "x0", 64));
  CHECK(has_reg_bitsize(arch.target_xml, "cpsr", 32));
}

```

`test/w1replay/gdb_host_process_info_test.cpp`:

```cpp
#include <filesystem>
#include <string>

#include "doctest/doctest.hpp"

#include <redlog.hpp>

#include "w1replay/gdb/adapter.hpp"
#include "w1rewind/rewind_test_helpers.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"

TEST_CASE("gdb host/process info returns best-effort data without target metadata") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1replay_gdb_missing_meta.trace");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1replay.gdb");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("arm64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions;
  REQUIRE(writer->write_header(header));

  write_thread_start(*writer, 1, "thread1");
  write_instruction(*writer, 1, 0, 0x1000);
  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1replay::gdb::adapter::config config;
  config.trace_path = trace_path.string();

  w1replay::gdb::adapter adapter(std::move(config));
  REQUIRE(adapter.open());

  auto target = adapter.make_target();

  const auto& view = target.view();
  REQUIRE(view.host.has_value());
  auto host_info = view.host->get_host_info();
  REQUIRE(host_info.has_value());
  CHECK(host_info->ptr_size == 8);
  CHECK(host_info->hostname == "w1replay");
  CHECK(host_info->triple.find("aarch64") != std::string::npos);

  REQUIRE(view.process.has_value());
  auto process_info = view.process->get_process_info();
  REQUIRE(process_info.has_value());
  CHECK(process_info->ptr_size == 8);
  CHECK(process_info->pid == 1);
  CHECK(process_info->triple.find("aarch64") != std::string::npos);
}

```

`test/w1replay/gdb_layout_test.cpp`:

```cpp
#include <optional>
#include <string>
#include <vector>

#include "doctest/doctest.hpp"

#include "w1replay/gdb/layout.hpp"
#include "w1rewind/rewind_test_helpers.hpp"

namespace {

std::optional<size_t> find_reg_index(const w1replay::gdb::register_layout& layout, const std::string& name) {
  for (size_t i = 0; i < layout.registers.size(); ++i) {
    if (layout.registers[i].name == name) {
      return i;
    }
  }
  return std::nullopt;
}

} // namespace

TEST_CASE("gdb register layout for arm64 is canonical and mapped") {
  std::vector<std::string> trace_regs = {"x0", "x1", "lr", "sp", "pc", "nzcv"};
  auto arch = w1::rewind::test_helpers::parse_arch_or_fail("arm64");
  auto specs = w1::rewind::test_helpers::make_register_specs(trace_regs, arch);
  auto layout = w1replay::gdb::build_register_layout(arch, specs);

  CHECK(layout.architecture == "aarch64");
  CHECK(layout.feature_name == "org.gnu.gdb.aarch64.core");
  REQUIRE(layout.registers.size() == 6);
  CHECK(layout.pc_reg_num == 4);
  CHECK(layout.sp_reg_num == 3);

  auto cpsr_idx = find_reg_index(layout, "cpsr");
  REQUIRE(cpsr_idx.has_value());
  REQUIRE(layout.registers[*cpsr_idx].trace_index.has_value());
  CHECK(trace_regs[*layout.registers[*cpsr_idx].trace_index] == "nzcv");
}

TEST_CASE("gdb register layout for x86_64 uses eflags and segments") {
  std::vector<std::string> trace_regs = {"rax", "rflags", "fs", "gs", "rip", "rsp"};
  auto arch = w1::rewind::test_helpers::parse_arch_or_fail("x86_64");
  auto specs = w1::rewind::test_helpers::make_register_specs(trace_regs, arch);
  auto layout = w1replay::gdb::build_register_layout(arch, specs);

  CHECK(layout.architecture == "i386:x86-64");
  CHECK(layout.feature_name == "org.gnu.gdb.i386.core");
  REQUIRE(layout.registers.size() == 6);
  CHECK(layout.pc_reg_num == 4);
  CHECK(layout.sp_reg_num == 5);

  auto eflags_idx = find_reg_index(layout, "eflags");
  REQUIRE(eflags_idx.has_value());
  REQUIRE(layout.registers[*eflags_idx].trace_index.has_value());
  CHECK(trace_regs[*layout.registers[*eflags_idx].trace_index] == "rflags");
}

TEST_CASE("gdb register layout falls back to minimal registers when specs are missing") {
  auto arch = w1::rewind::test_helpers::parse_arch_or_fail("arm64");
  std::vector<w1::rewind::register_spec> specs;
  auto layout = w1replay::gdb::build_register_layout(arch, specs);

  REQUIRE(layout.registers.size() == 3);
  auto pc_idx = find_reg_index(layout, "pc");
  auto sp_idx = find_reg_index(layout, "sp");
  auto cpsr_idx = find_reg_index(layout, "cpsr");
  REQUIRE(pc_idx.has_value());
  REQUIRE(sp_idx.has_value());
  REQUIRE(cpsr_idx.has_value());
  CHECK(layout.registers[*pc_idx].is_pc);
  CHECK(layout.registers[*sp_idx].is_sp);
  CHECK(layout.registers[*cpsr_idx].is_flags);
}

```

`test/w1replay/gdb_libraries_component_test.cpp`:

```cpp
#include <filesystem>
#include <vector>

#include "doctest/doctest.hpp"

#include <redlog.hpp>

#include "w1replay/gdb/adapter.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"
#include "w1rewind/rewind_test_helpers.hpp"

namespace {

std::filesystem::path write_trace_with_modules(const char* name) {
  using namespace w1::rewind::test_helpers;

  std::filesystem::path trace_path = temp_path(name);

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1replay.gdb");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, arch, minimal_registers(arch));

  w1::rewind::module_table_record table{};
  w1::rewind::module_record main{};
  main.id = 1;
  main.base = 0x400000;
  main.size = 0x1000;
  main.permissions = w1::rewind::module_perm::read | w1::rewind::module_perm::exec;
  main.path = "/tmp/main.exe";
  main.flags = w1::rewind::module_record_flag_main | w1::rewind::module_record_flag_file_backed;
  table.modules.push_back(main);

  w1::rewind::module_record shared{};
  shared.id = 2;
  shared.base = 0x500000;
  shared.size = 0x1000;
  shared.permissions = w1::rewind::module_perm::read | w1::rewind::module_perm::exec;
  shared.path = "/lib/libfoo.so";
  shared.flags = w1::rewind::module_record_flag_file_backed;
  table.modules.push_back(shared);

  w1::rewind::module_record heap{};
  heap.id = 3;
  heap.base = 0x600000;
  heap.size = 0x1000;
  heap.permissions = w1::rewind::module_perm::read | w1::rewind::module_perm::write;
  heap.path = "[heap]";
  table.modules.push_back(heap);

  w1::rewind::module_record stack{};
  stack.id = 4;
  stack.base = 0x700000;
  stack.size = 0x1000;
  stack.permissions = w1::rewind::module_perm::read | w1::rewind::module_perm::write;
  stack.path = "[stack]";
  table.modules.push_back(stack);
  REQUIRE(writer->write_module_table(table));

  write_thread_start(*writer, 1, "thread1");
  write_instruction(*writer, 1, 0, 0x400100);
  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();
  return trace_path;
}

} // namespace

TEST_CASE("gdb libraries list omits main module and pseudo entries") {
  auto trace_path = write_trace_with_modules("w1replay_gdb_libraries.trace");

  w1replay::gdb::adapter::config config;
  config.trace_path = trace_path.string();

  w1replay::gdb::adapter adapter(std::move(config));
  REQUIRE(adapter.open());

  auto target = adapter.make_target();
  REQUIRE(target.view().libraries.has_value());

  auto entries = target.view().libraries->libraries();
  REQUIRE(entries.size() == 1);
  CHECK(entries[0].name == "/lib/libfoo.so");

  auto generation = target.view().libraries->generation();
  REQUIRE(generation.has_value());
  CHECK(*generation == 1);
}

```

`test/w1replay/gdb_loaded_libraries_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "w1replay/gdb/lldb/darwin_loaded_libraries.hpp"
#include "w1replay/gdb/loaded_libraries_provider.hpp"
#include "w1replay/modules/metadata_provider.hpp"
#include "w1replay/modules/path_resolver.hpp"
#include "w1rewind/replay/replay_context.hpp"

namespace w1replay::gdb {

namespace {

struct stub_metadata_provider final : public module_metadata_provider {
  std::optional<std::string> module_uuid(const w1::rewind::module_record&, std::string&) override {
    return std::nullopt;
  }
  std::optional<macho_header_info> macho_header(const w1::rewind::module_record&, std::string&) override {
    return std::nullopt;
  }
  std::vector<macho_segment_info> macho_segments(const w1::rewind::module_record&, std::string&) override { return {}; }
};

struct stub_path_resolver final : public module_path_resolver {
  std::optional<std::string> resolve_module_path(const w1::rewind::module_record&) const override {
    return std::nullopt;
  }
  std::optional<std::string> resolve_region_name(std::string_view) const override { return std::nullopt; }
};

} // namespace

TEST_CASE("darwin loaded libraries json includes load commands when requested") {
  gdbstub::lldb::loaded_libraries_request request{};
  request.report_load_commands = true;

  darwin_loaded_image image{};
  image.load_address = 0x1000;
  image.pathname = "/tmp/example";
  image.uuid = "TEST-UUID";
  image.header = macho_header_info{1u, 2u, 3u, 4u};
  image.segments.push_back(macho_segment_info{"__TEXT", 0x1000, 0x2000, 0, 0x2000, 7});

  std::vector<darwin_loaded_image> images{image};
  auto json = build_darwin_loaded_libraries_json(images, request);

  CHECK(json.find("\"load_address\":4096") != std::string::npos);
  CHECK(json.find("\"pathname\"") != std::string::npos);
  CHECK(json.find("\"uuid\"") != std::string::npos);
  CHECK(json.find("\"mach_header\"") != std::string::npos);
  CHECK(json.find("\"segments\"") != std::string::npos);
}

TEST_CASE("darwin loaded libraries json omits load commands when disabled") {
  gdbstub::lldb::loaded_libraries_request request{};
  request.report_load_commands = false;

  darwin_loaded_image image{};
  image.load_address = 0x2000;
  image.pathname = "/tmp/example";
  image.uuid = "TEST-UUID";
  image.header = macho_header_info{1u, 2u, 3u, 4u};
  image.segments.push_back(macho_segment_info{"__TEXT", 0x1000, 0x2000, 0, 0x2000, 7});

  std::vector<darwin_loaded_image> images{image};
  auto json = build_darwin_loaded_libraries_json(images, request);

  CHECK(json.find("\"mach_header\"") == std::string::npos);
  CHECK(json.find("\"segments\"") == std::string::npos);
}

TEST_CASE("loaded libraries provider selection respects target os") {
  w1::rewind::replay_context context{};
  context.target_info = w1::rewind::target_info_record{};
  stub_metadata_provider metadata_provider;
  stub_path_resolver resolver;

  context.target_info->os = "macos";
  auto darwin_provider = make_loaded_libraries_provider(context, metadata_provider, resolver);
  CHECK(darwin_provider != nullptr);

  context.target_info->os = "linux";
  auto linux_provider = make_loaded_libraries_provider(context, metadata_provider, resolver);
  CHECK(linux_provider == nullptr);
}

} // namespace w1replay::gdb

```

`test/w1replay/gdb_memory_map_test.cpp`:

```cpp
#include <vector>

#include "doctest/doctest.hpp"

#include "w1replay/gdb/memory_map.hpp"

TEST_CASE("gdb memory map skips recorded bytes inside module ranges") {
  w1::rewind::module_record module{};
  module.id = 1;
  module.base = 0x1000;
  module.size = 0x100;
  module.permissions = w1::rewind::module_perm::read | w1::rewind::module_perm::exec;
  module.path = "mod";

  w1::rewind::replay_state state;
  state.apply_memory_bytes(0x1010, std::vector<uint8_t>{0xAA});
  state.apply_memory_bytes(0x3000, std::vector<uint8_t>{0xBB, 0xCC});

  auto regions = w1replay::gdb::build_memory_map({module}, {}, &state, nullptr);

  bool saw_module = false;
  bool saw_recorded = false;
  for (const auto& region : regions) {
    if (region.start == 0x1000 && region.size == 0x100) {
      saw_module = true;
    }
    if (region.name == "rewind.recorded") {
      saw_recorded = true;
      CHECK(region.start == 0x3000);
      CHECK(region.size == 2);
    }
  }

  CHECK(saw_module);
  CHECK(saw_recorded);
}

TEST_CASE("gdb memory map prefers explicit memory map ranges over module spans") {
  w1::rewind::module_record module{};
  module.id = 1;
  module.base = 0x1000;
  module.size = 0x100;
  module.permissions = w1::rewind::module_perm::read;
  module.path = "mod";

  w1::rewind::memory_region_record region{};
  region.base = 0x1000;
  region.size = 0x80;
  region.permissions = w1::rewind::module_perm::read;
  region.name = "mod";

  w1::rewind::replay_state state;
  state.apply_memory_bytes(0x1010, std::vector<uint8_t>{0xAA});
  state.apply_memory_bytes(0x3000, std::vector<uint8_t>{0xBB});

  auto regions = w1replay::gdb::build_memory_map({module}, {region}, &state, nullptr);

  bool saw_map = false;
  bool saw_span = false;
  bool saw_recorded = false;
  for (const auto& entry : regions) {
    if (entry.start == 0x1000 && entry.size == 0x80) {
      saw_map = true;
    }
    if (entry.start == 0x1000 && entry.size == 0x100) {
      saw_span = true;
    }
    if (entry.name == "rewind.recorded") {
      saw_recorded = true;
      CHECK(entry.start == 0x3000);
      CHECK(entry.size == 1);
    }
  }

  CHECK(saw_map);
  CHECK(!saw_span);
  CHECK(saw_recorded);
}

```

`test/w1replay/gdb_memory_read_test.cpp`:

```cpp
#include <array>
#include <cstddef>
#include <filesystem>
#include <string>
#include <vector>

#include "doctest/doctest.hpp"

#include <redlog.hpp>

#include "w1replay/gdb/adapter.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"
#include "w1rewind/rewind_test_helpers.hpp"

TEST_CASE("gdb adapter reads recorded memory bytes") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1replay_gdb_mem_read.trace");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1replay.gdb");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("arm64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags =
      w1::rewind::trace_flag_instructions | w1::rewind::trace_flag_memory_access | w1::rewind::trace_flag_memory_values;
  REQUIRE(writer->write_header(header));

  std::vector<std::string> registers = {"pc", "sp"};
  write_basic_metadata(*writer, arch, registers);
  write_module_table(*writer, 1, 0x1000);
  write_thread_start(*writer, 1, "thread1");
  write_instruction(*writer, 1, 0, 0x1000 + 0x10);

  w1::rewind::memory_access_record access{};
  access.sequence = 0;
  access.thread_id = 1;
  access.kind = w1::rewind::memory_access_kind::write;
  access.address = 0x3000;
  access.size = 4;
  access.value_known = true;
  access.value_truncated = false;
  access.data = {0xDE, 0xAD, 0xBE, 0xEF};
  REQUIRE(writer->write_memory_access(access));

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1replay::gdb::adapter::config config;
  config.trace_path = trace_path.string();

  w1replay::gdb::adapter adapter(std::move(config));
  REQUIRE(adapter.open());

  auto target = adapter.make_target();
  std::array<std::byte, 4> buffer{};
  auto status = target.view().mem.read_mem(0x3000, buffer);
  CHECK(status == gdbstub::target_status::ok);
  CHECK(buffer[0] == std::byte{0xDE});
  CHECK(buffer[1] == std::byte{0xAD});
  CHECK(buffer[2] == std::byte{0xBE});
  CHECK(buffer[3] == std::byte{0xEF});
}

TEST_CASE("gdb adapter reads memory access read values") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1replay_gdb_mem_read_access.trace");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1replay.gdb");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("arm64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags =
      w1::rewind::trace_flag_instructions | w1::rewind::trace_flag_memory_access | w1::rewind::trace_flag_memory_values;
  REQUIRE(writer->write_header(header));

  std::vector<std::string> registers = {"pc"};
  write_basic_metadata(*writer, arch, registers);
  write_module_table(*writer, 1, 0x1000);
  write_thread_start(*writer, 1, "thread1");
  write_instruction(*writer, 1, 0, 0x1000 + 0x10);

  w1::rewind::memory_access_record access{};
  access.sequence = 0;
  access.thread_id = 1;
  access.kind = w1::rewind::memory_access_kind::read;
  access.address = 0x4000;
  access.size = 2;
  access.value_known = true;
  access.value_truncated = false;
  access.data = {0xFE, 0xED};
  REQUIRE(writer->write_memory_access(access));

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1replay::gdb::adapter::config config;
  config.trace_path = trace_path.string();

  w1replay::gdb::adapter adapter(std::move(config));
  REQUIRE(adapter.open());

  auto target = adapter.make_target();
  std::array<std::byte, 2> buffer{};
  auto status = target.view().mem.read_mem(0x4000, buffer);
  CHECK(status == gdbstub::target_status::ok);
  CHECK(buffer[0] == std::byte{0xFE});
  CHECK(buffer[1] == std::byte{0xED});
}

TEST_CASE("gdb adapter reads module bytes when memory missing") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1replay_gdb_module_mem.trace");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1replay.gdb");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("arm64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions;
  REQUIRE(writer->write_header(header));

  std::vector<std::string> registers = {"pc"};
  write_basic_metadata(*writer, arch, registers);
  write_module_table(*writer, 1, 0x1000);
  write_thread_start(*writer, 1, "thread1");
  write_instruction(*writer, 1, 0, 0x1000 + 0x10);
  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1replay::gdb::adapter::config config;
  config.trace_path = trace_path.string();
  config.module_reader = [](uint64_t addr, std::span<std::byte> out, std::string& error) {
    error.clear();
    for (size_t i = 0; i < out.size(); ++i) {
      out[i] = static_cast<std::byte>(0xA0 + (addr + i) % 16);
    }
    return true;
  };

  w1replay::gdb::adapter adapter(std::move(config));
  REQUIRE(adapter.open());

  auto target = adapter.make_target();
  std::array<std::byte, 4> buffer{};
  auto status = target.view().mem.read_mem(0x1010, buffer);
  CHECK(status == gdbstub::target_status::ok);
  CHECK(buffer[0] == std::byte{0xA0});
}

TEST_CASE("gdb adapter prefers recorded memory over module bytes") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1replay_gdb_recorded_overrides.trace");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1replay.gdb");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("arm64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags =
      w1::rewind::trace_flag_instructions | w1::rewind::trace_flag_memory_access | w1::rewind::trace_flag_memory_values;
  REQUIRE(writer->write_header(header));

  std::vector<std::string> registers = {"pc", "sp"};
  write_basic_metadata(*writer, arch, registers);
  write_module_table(*writer, 1, 0x1000);
  write_thread_start(*writer, 1, "thread1");
  write_instruction(*writer, 1, 0, 0x1000 + 0x10);

  w1::rewind::memory_access_record access{};
  access.sequence = 0;
  access.thread_id = 1;
  access.kind = w1::rewind::memory_access_kind::write;
  access.address = 0x1010;
  access.size = 4;
  access.value_known = true;
  access.value_truncated = false;
  access.data = {0x11, 0x22, 0x33, 0x44};
  REQUIRE(writer->write_memory_access(access));

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1replay::gdb::adapter::config config;
  config.trace_path = trace_path.string();
  config.module_reader = [](uint64_t, std::span<std::byte> out, std::string& error) {
    error.clear();
    for (auto& byte : out) {
      byte = std::byte{0xFF};
    }
    return true;
  };

  w1replay::gdb::adapter adapter(std::move(config));
  REQUIRE(adapter.open());

  auto target = adapter.make_target();
  std::array<std::byte, 4> buffer{};
  auto status = target.view().mem.read_mem(0x1010, buffer);
  CHECK(status == gdbstub::target_status::ok);
  CHECK(buffer[0] == std::byte{0x11});
  CHECK(buffer[1] == std::byte{0x22});
  CHECK(buffer[2] == std::byte{0x33});
  CHECK(buffer[3] == std::byte{0x44});
}

```

`test/w1replay/gdb_pc_only_test.cpp`:

```cpp
#include <cstddef>
#include <filesystem>
#include <vector>

#include "doctest/doctest.hpp"

#include <redlog.hpp>

#include "w1replay/gdb/adapter.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"
#include "w1rewind/rewind_test_helpers.hpp"

TEST_CASE("gdb adapter opens pc-only trace with minimal register specs") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1replay_gdb_pc_only.trace");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1replay.gdb");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("arm64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions;
  REQUIRE(writer->write_header(header));

  std::vector<std::string> registers = {"x0", "pc"};
  write_basic_metadata(*writer, arch, registers);
  write_module_table(*writer, 1, 0x1000);
  write_thread_start(*writer, 1, "thread1");
  write_instruction(*writer, 1, 0, 0x1000 + 0x40);
  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1replay::gdb::adapter::config config;
  config.trace_path = trace_path.string();

  w1replay::gdb::adapter adapter(std::move(config));
  REQUIRE(adapter.open());
  CHECK(adapter.session().current_step().address == 0x1040);
  CHECK(adapter.arch_spec().pc_reg_num >= 0);
  CHECK(!adapter.arch_spec().target_xml.empty());

  auto target = adapter.make_target();
  int pc_reg = adapter.arch_spec().pc_reg_num;
  REQUIRE(pc_reg >= 0);
  size_t pc_size = target.view().regs.reg_size(pc_reg);
  REQUIRE(pc_size == 8);
  std::vector<std::byte> buffer(pc_size);
  auto status = target.view().regs.read_reg(pc_reg, buffer);
  CHECK(status == gdbstub::target_status::ok);
  uint64_t pc_value = 0;
  for (size_t i = 0; i < buffer.size(); ++i) {
    pc_value |= static_cast<uint64_t>(std::to_integer<uint8_t>(buffer[i])) << (i * 8);
  }
  CHECK(pc_value == adapter.session().current_step().address);

  std::vector<std::byte> reg0(pc_size);
  auto reg0_status = target.view().regs.read_reg(0, reg0);
  CHECK(reg0_status == gdbstub::target_status::ok);
  for (auto byte : reg0) {
    CHECK(std::to_integer<uint8_t>(byte) == 0xcc);
  }
}

```

`test/w1replay/gdb_register_info_test.cpp`:

```cpp
#include <filesystem>
#include <memory>
#include <string>
#include <vector>

#include "doctest/doctest.hpp"

#include <redlog.hpp>

#include "w1replay/gdb/adapter.hpp"
#include "w1replay/gdb/layout.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"
#include "w1rewind/rewind_test_helpers.hpp"

namespace {
std::unique_ptr<w1replay::gdb::adapter> open_adapter_with_registers(
    const char* trace_name, const w1::arch::arch_spec& arch, const std::vector<std::string>& registers
) {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path(trace_name);

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1replay.gdb");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, arch, registers);
  write_module_table(*writer, 1, 0x1000);
  write_thread_start(*writer, 1, "thread1");
  write_instruction(*writer, 1, 0, 0x1000 + 0x10);
  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1replay::gdb::adapter::config config;
  config.trace_path = trace_path.string();

  auto adapter = std::make_unique<w1replay::gdb::adapter>(std::move(config));
  REQUIRE(adapter->open());
  return adapter;
}

int find_reg_num(const w1replay::gdb::register_layout& layout, std::string_view name) {
  for (size_t i = 0; i < layout.registers.size(); ++i) {
    if (layout.registers[i].name == name) {
      return static_cast<int>(i);
    }
  }
  return -1;
}
} // namespace

TEST_CASE("gdb adapter exposes register info with pc/sp generics") {
  using namespace w1::rewind::test_helpers;

  auto arch = parse_arch_or_fail("arm64");

  std::vector<std::string> registers = {"x0", "sp", "pc", "nzcv"};
  auto adapter = open_adapter_with_registers("w1replay_gdb_reginfo.trace", arch, registers);

  auto gdb_target = adapter->make_target();
  REQUIRE(gdb_target.view().reg_info.has_value());

  auto specs = w1::rewind::test_helpers::make_register_specs(registers, arch);
  auto layout = w1replay::gdb::build_register_layout(arch, specs);
  REQUIRE(layout.pc_reg_num >= 0);
  REQUIRE(layout.sp_reg_num >= 0);

  auto pc_info = gdb_target.view().reg_info->get_register_info(layout.pc_reg_num);
  REQUIRE(pc_info.has_value());
  CHECK(pc_info->generic.has_value());
  CHECK(*pc_info->generic == "pc");
  CHECK(pc_info->dwarf_regnum.has_value());
  CHECK(*pc_info->dwarf_regnum == 32);
  CHECK(pc_info->gcc_regnum.has_value());
  CHECK(*pc_info->gcc_regnum == 32);

  auto sp_info = gdb_target.view().reg_info->get_register_info(layout.sp_reg_num);
  REQUIRE(sp_info.has_value());
  CHECK(sp_info->generic.has_value());
  CHECK(*sp_info->generic == "sp");
  CHECK(sp_info->dwarf_regnum.has_value());
  CHECK(*sp_info->dwarf_regnum == 31);
  CHECK(sp_info->gcc_regnum.has_value());
  CHECK(*sp_info->gcc_regnum == 31);

  int x0_reg_num = find_reg_num(layout, "x0");
  REQUIRE(x0_reg_num >= 0);
  auto x0_info = gdb_target.view().reg_info->get_register_info(x0_reg_num);
  REQUIRE(x0_info.has_value());
  CHECK(x0_info->dwarf_regnum.has_value());
  CHECK(*x0_info->dwarf_regnum == 0);
  CHECK(x0_info->gcc_regnum.has_value());
  CHECK(*x0_info->gcc_regnum == 0);

  int cpsr_reg_num = find_reg_num(layout, "cpsr");
  REQUIRE(cpsr_reg_num >= 0);
  auto cpsr_info = gdb_target.view().reg_info->get_register_info(cpsr_reg_num);
  REQUIRE(cpsr_info.has_value());
  CHECK(cpsr_info->dwarf_regnum.has_value());
  CHECK(*cpsr_info->dwarf_regnum == 33);
  CHECK(cpsr_info->gcc_regnum.has_value());
  CHECK(*cpsr_info->gcc_regnum == 33);
}

TEST_CASE("gdb adapter exposes dwarf numbers for x86_64 gprs") {
  using namespace w1::rewind::test_helpers;

  auto arch = parse_arch_or_fail("x86_64");
  std::vector<std::string> registers = {"rax", "rbp", "rsp", "rip", "eflags"};

  auto adapter = open_adapter_with_registers("w1replay_gdb_reginfo_x86_64.trace", arch, registers);
  auto gdb_target = adapter->make_target();
  REQUIRE(gdb_target.view().reg_info.has_value());

  auto specs = w1::rewind::test_helpers::make_register_specs(registers, arch);
  auto layout = w1replay::gdb::build_register_layout(arch, specs);

  int rip_reg_num = find_reg_num(layout, "rip");
  REQUIRE(rip_reg_num >= 0);
  auto rip_info = gdb_target.view().reg_info->get_register_info(rip_reg_num);
  REQUIRE(rip_info.has_value());
  CHECK(rip_info->dwarf_regnum.has_value());
  CHECK(*rip_info->dwarf_regnum == 16);
  CHECK(rip_info->gcc_regnum.has_value());
  CHECK(*rip_info->gcc_regnum == 16);

  int rsp_reg_num = find_reg_num(layout, "rsp");
  REQUIRE(rsp_reg_num >= 0);
  auto rsp_info = gdb_target.view().reg_info->get_register_info(rsp_reg_num);
  REQUIRE(rsp_info.has_value());
  CHECK(rsp_info->dwarf_regnum.has_value());
  CHECK(*rsp_info->dwarf_regnum == 7);
  CHECK(rsp_info->gcc_regnum.has_value());
  CHECK(*rsp_info->gcc_regnum == 7);

  int rax_reg_num = find_reg_num(layout, "rax");
  REQUIRE(rax_reg_num >= 0);
  auto rax_info = gdb_target.view().reg_info->get_register_info(rax_reg_num);
  REQUIRE(rax_info.has_value());
  CHECK(rax_info->dwarf_regnum.has_value());
  CHECK(*rax_info->dwarf_regnum == 0);
  CHECK(rax_info->gcc_regnum.has_value());
  CHECK(*rax_info->gcc_regnum == 0);

  int rbp_reg_num = find_reg_num(layout, "rbp");
  REQUIRE(rbp_reg_num >= 0);
  auto rbp_info = gdb_target.view().reg_info->get_register_info(rbp_reg_num);
  REQUIRE(rbp_info.has_value());
  CHECK(rbp_info->dwarf_regnum.has_value());
  CHECK(*rbp_info->dwarf_regnum == 6);
  CHECK(rbp_info->gcc_regnum.has_value());
  CHECK(*rbp_info->gcc_regnum == 6);

  int eflags_reg_num = find_reg_num(layout, "eflags");
  REQUIRE(eflags_reg_num >= 0);
  auto eflags_info = gdb_target.view().reg_info->get_register_info(eflags_reg_num);
  REQUIRE(eflags_info.has_value());
  CHECK(eflags_info->dwarf_regnum.has_value());
  CHECK(*eflags_info->dwarf_regnum == 49);
  CHECK(eflags_info->gcc_regnum.has_value());
  CHECK(*eflags_info->gcc_regnum == 49);
}

```

`test/w1replay/gdb_run_policy_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "w1replay/gdb/run_policy.hpp"

using w1replay::gdb::run_policy;
using w1replay::gdb::step_mode;

TEST_CASE("run_policy chooses flow when instruction stepping is unavailable") {
  run_policy policy{};
  policy.trace_is_block = true;
  policy.decoder_available = false;

  CHECK(!policy.can_instruction_step());
  CHECK(policy.choose_step_mode(gdbstub::resume_action::step, false) == step_mode::flow);
  CHECK(policy.choose_step_mode(gdbstub::resume_action::cont, false) == step_mode::flow);
}

TEST_CASE("run_policy prefers instruction stepping for step actions") {
  run_policy policy{};
  policy.trace_is_block = true;
  policy.decoder_available = true;

  CHECK(policy.can_instruction_step());
  CHECK(policy.choose_step_mode(gdbstub::resume_action::step, false) == step_mode::instruction);
}

TEST_CASE("run_policy chooses instruction stepping for continue when needed") {
  run_policy policy{};
  policy.trace_is_block = true;
  policy.decoder_available = true;

  CHECK(policy.choose_step_mode(gdbstub::resume_action::cont, false) == step_mode::flow);

  policy.prefer_instruction_steps = true;
  CHECK(policy.choose_step_mode(gdbstub::resume_action::cont, false) == step_mode::instruction);

  policy.prefer_instruction_steps = false;
  CHECK(policy.choose_step_mode(gdbstub::resume_action::cont, true) == step_mode::instruction);
}

```

`test/w1replay/gdb_stepper_test.cpp`:

```cpp
#include <filesystem>
#include <memory>
#include <string>

#include "doctest/doctest.hpp"

#include <redlog.hpp>

#include "w1replay/gdb/stepper.hpp"
#include "w1rewind/replay/replay_context.hpp"
#include "w1rewind/replay/replay_session.hpp"
#include "w1rewind/trace/trace_index.hpp"
#include "w1rewind/trace/trace_reader.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"

#include "w1rewind/rewind_test_helpers.hpp"

namespace {

class test_block_decoder final : public w1::rewind::block_decoder {
public:
  bool decode_block(
      const w1::rewind::replay_context&, const w1::rewind::flow_step& flow, w1::rewind::decoded_block& out, std::string&
  ) override {
    uint64_t address = flow.address;
    uint32_t size = flow.size;
    if (size == 0 || (size % 2) != 0) {
      return false;
    }

    out.start = address;
    out.size = size;

    uint32_t offset = 0;
    while (offset < size) {
      w1::rewind::decoded_instruction inst{};
      inst.address = address + offset;
      inst.size = 2;
      inst.bytes = {0x90, 0x90};
      out.instructions.push_back(inst);
      offset += 2;
    }

    return true;
  }
};

struct session_inputs {
  std::shared_ptr<w1::rewind::trace_reader> stream;
  std::shared_ptr<w1::rewind::trace_index> index;
  w1::rewind::replay_context context;
};

session_inputs build_session_inputs(const std::filesystem::path& trace_path) {
  session_inputs inputs;
  inputs.stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());

  std::string error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), inputs.context, error));

  w1::rewind::trace_index_options options;
  w1::rewind::trace_index index;
  error.clear();
  REQUIRE(w1::rewind::ensure_trace_index(trace_path, {}, options, index, error));
  inputs.index = std::make_shared<w1::rewind::trace_index>(std::move(index));
  return inputs;
}

std::filesystem::path write_block_trace(const char* name) {
  using namespace w1::rewind::test_helpers;
  namespace fs = std::filesystem;

  fs::path trace_path = temp_path(name);

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1replay.gdb");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("arm64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_blocks;
  REQUIRE(writer->write_header(header));

  std::vector<std::string> registers = {"pc"};
  write_basic_metadata(*writer, arch, registers);
  write_module_table(*writer, 1, 0x1000);
  write_thread_start(*writer, 1, "thread1");

  write_block_def(*writer, 1, 0x1000 + 0x10, 4);
  write_block_def(*writer, 2, 0x1000 + 0x20, 4);
  write_block_exec(*writer, 1, 0, 1);
  write_block_exec(*writer, 1, 1, 2);

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();
  return trace_path;
}

std::filesystem::path write_instruction_trace(const char* name) {
  using namespace w1::rewind::test_helpers;
  namespace fs = std::filesystem;

  fs::path trace_path = temp_path(name);

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1replay.gdb");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("arm64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions;
  REQUIRE(writer->write_header(header));

  std::vector<std::string> registers = {"pc"};
  write_basic_metadata(*writer, arch, registers);
  write_module_table(*writer, 1, 0x2000);
  write_thread_start(*writer, 1, "thread1");
  write_instruction(*writer, 1, 0, 0x2000 + 0x10);
  write_instruction(*writer, 1, 1, 0x2000 + 0x14);
  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();
  return trace_path;
}

} // namespace

TEST_CASE("gdb stepper uses instruction stepping when block decoder is available") {
  auto trace_path = write_block_trace("w1replay_gdb_stepper_block.trace");

  auto inputs = build_session_inputs(trace_path);

  test_block_decoder decoder;
  w1::rewind::replay_session_config session_config{};
  session_config.stream = inputs.stream;
  session_config.index = inputs.index;
  session_config.context = inputs.context;
  session_config.thread_id = 1;
  session_config.track_registers = false;
  session_config.track_memory = false;
  session_config.block_decoder = &decoder;

  w1::rewind::replay_session session(session_config);
  REQUIRE(session.open());

  w1replay::gdb::run_policy policy{};
  policy.trace_is_block = true;
  policy.decoder_available = true;

  auto result = w1replay::gdb::resume_step(session, policy, {}, 1, gdbstub::resume_direction::forward);
  CHECK(result.resume.state == gdbstub::resume_result::state::stopped);
  CHECK(session.current_step().address == 0x1010);
  CHECK(!session.current_step().is_block);
}

TEST_CASE("gdb stepper continues until breakpoint using instruction stepping") {
  auto trace_path = write_block_trace("w1replay_gdb_stepper_break.trace");

  auto inputs = build_session_inputs(trace_path);

  test_block_decoder decoder;
  w1::rewind::replay_session_config session_config{};
  session_config.stream = inputs.stream;
  session_config.index = inputs.index;
  session_config.context = inputs.context;
  session_config.thread_id = 1;
  session_config.track_registers = false;
  session_config.track_memory = false;
  session_config.block_decoder = &decoder;

  w1::rewind::replay_session session(session_config);
  REQUIRE(session.open());

  w1replay::gdb::run_policy policy{};
  policy.trace_is_block = true;
  policy.decoder_available = true;

  w1replay::gdb::breakpoint_store breakpoints;
  breakpoints.add(0x1020);
  auto result = w1replay::gdb::resume_continue(session, policy, breakpoints, 1, gdbstub::resume_direction::forward);
  CHECK(result.resume.stop.kind == gdbstub::stop_kind::sw_break);
  CHECK(result.resume.stop.addr == 0x1020);
  CHECK(session.current_step().address == 0x1020);
}

TEST_CASE("gdb stepper falls back to flow stepping without decoder") {
  auto trace_path = write_block_trace("w1replay_gdb_stepper_flow.trace");

  auto inputs = build_session_inputs(trace_path);

  w1::rewind::replay_session_config session_config{};
  session_config.stream = inputs.stream;
  session_config.index = inputs.index;
  session_config.context = inputs.context;
  session_config.thread_id = 1;
  session_config.track_registers = false;
  session_config.track_memory = false;

  w1::rewind::replay_session session(session_config);
  REQUIRE(session.open());

  w1replay::gdb::run_policy policy{};
  policy.trace_is_block = true;
  policy.decoder_available = false;

  auto result = w1replay::gdb::resume_step(session, policy, {}, 1, gdbstub::resume_direction::forward);
  CHECK(result.resume.state == gdbstub::resume_result::state::stopped);
  CHECK(session.current_step().address == 0x1010);
  CHECK(session.current_step().is_block);
}

TEST_CASE("gdb stepper uses flow stepping for instruction traces") {
  auto trace_path = write_instruction_trace("w1replay_gdb_stepper_inst.trace");

  auto inputs = build_session_inputs(trace_path);

  w1::rewind::replay_session_config session_config{};
  session_config.stream = inputs.stream;
  session_config.index = inputs.index;
  session_config.context = inputs.context;
  session_config.thread_id = 1;
  session_config.track_registers = false;
  session_config.track_memory = false;

  w1::rewind::replay_session session(session_config);
  REQUIRE(session.open());

  w1replay::gdb::run_policy policy{};
  policy.trace_is_block = false;
  policy.decoder_available = false;

  auto result = w1replay::gdb::resume_step(session, policy, {}, 1, gdbstub::resume_direction::forward);
  CHECK(result.resume.state == gdbstub::resume_result::state::stopped);
  CHECK(session.current_step().address == 0x2010);
  CHECK(!session.current_step().is_block);
}

TEST_CASE("gdb stepper reports replay-log end at forward trace boundary") {
  auto trace_path = write_instruction_trace("w1replay_gdb_stepper_end.trace");

  auto inputs = build_session_inputs(trace_path);

  w1::rewind::replay_session_config session_config{};
  session_config.stream = inputs.stream;
  session_config.index = inputs.index;
  session_config.context = inputs.context;
  session_config.thread_id = 1;
  session_config.track_registers = false;
  session_config.track_memory = false;

  w1::rewind::replay_session session(session_config);
  REQUIRE(session.open());

  w1replay::gdb::run_policy policy{};
  policy.trace_is_block = false;
  policy.decoder_available = false;

  auto result = w1replay::gdb::resume_continue(session, policy, {}, 1, gdbstub::resume_direction::forward);

  CHECK(result.resume.state == gdbstub::resume_result::state::stopped);
  REQUIRE(result.resume.stop.replay_log.has_value());
  CHECK(*result.resume.stop.replay_log == gdbstub::replay_log_boundary::end);
  CHECK(session.current_step().address == 0x2014);
}

TEST_CASE("gdb stepper supports reverse instruction stepping") {
  auto trace_path = write_block_trace("w1replay_gdb_stepper_reverse.trace");

  auto inputs = build_session_inputs(trace_path);

  test_block_decoder decoder;
  w1::rewind::replay_session_config session_config{};
  session_config.stream = inputs.stream;
  session_config.index = inputs.index;
  session_config.context = inputs.context;
  session_config.thread_id = 1;
  session_config.track_registers = false;
  session_config.track_memory = false;
  session_config.block_decoder = &decoder;

  w1::rewind::replay_session session(session_config);
  REQUIRE(session.open());

  REQUIRE(session.step_instruction());
  REQUIRE(session.step_instruction());
  CHECK(session.current_step().address == 0x1012);

  w1replay::gdb::run_policy policy{};
  policy.trace_is_block = true;
  policy.decoder_available = true;

  auto result = w1replay::gdb::resume_step(session, policy, {}, 1, gdbstub::resume_direction::reverse);

  CHECK(result.resume.state == gdbstub::resume_result::state::stopped);
  CHECK(session.current_step().address == 0x1010);
}

TEST_CASE("gdb stepper reports replay-log begin when reversing past start") {
  auto trace_path = write_block_trace("w1replay_gdb_stepper_reverse_begin.trace");

  auto inputs = build_session_inputs(trace_path);

  test_block_decoder decoder;
  w1::rewind::replay_session_config session_config{};
  session_config.stream = inputs.stream;
  session_config.index = inputs.index;
  session_config.context = inputs.context;
  session_config.thread_id = 1;
  session_config.track_registers = false;
  session_config.track_memory = false;
  session_config.block_decoder = &decoder;

  w1::rewind::replay_session session(session_config);
  REQUIRE(session.open());

  REQUIRE(session.step_instruction());
  CHECK(session.current_step().address == 0x1010);

  w1replay::gdb::run_policy policy{};
  policy.trace_is_block = true;
  policy.decoder_available = true;

  auto result = w1replay::gdb::resume_step(session, policy, {}, 1, gdbstub::resume_direction::reverse);

  CHECK(result.resume.state == gdbstub::resume_result::state::stopped);
  REQUIRE(result.resume.stop.replay_log.has_value());
  CHECK(*result.resume.stop.replay_log == gdbstub::replay_log_boundary::begin);
}

TEST_CASE("gdb stepper reverse-continues to breakpoint") {
  auto trace_path = write_block_trace("w1replay_gdb_stepper_reverse_break.trace");

  auto inputs = build_session_inputs(trace_path);

  test_block_decoder decoder;
  w1::rewind::replay_session_config session_config{};
  session_config.stream = inputs.stream;
  session_config.index = inputs.index;
  session_config.context = inputs.context;
  session_config.thread_id = 1;
  session_config.track_registers = false;
  session_config.track_memory = false;
  session_config.block_decoder = &decoder;

  w1::rewind::replay_session session(session_config);
  REQUIRE(session.open());

  REQUIRE(session.step_instruction());
  REQUIRE(session.step_instruction());
  CHECK(session.current_step().address == 0x1012);

  w1replay::gdb::run_policy policy{};
  policy.trace_is_block = true;
  policy.decoder_available = true;

  w1replay::gdb::breakpoint_store breakpoints;
  breakpoints.add(0x1010);
  auto result = w1replay::gdb::resume_continue(session, policy, breakpoints, 1, gdbstub::resume_direction::reverse);

  CHECK(result.resume.stop.kind == gdbstub::stop_kind::sw_break);
  CHECK(result.resume.stop.addr == 0x1010);
  CHECK(session.current_step().address == 0x1010);
}

```

`test/w1replay/gdb_target_xml_test.cpp`:

```cpp
#include <string>

#include "doctest/doctest.hpp"

#include "w1replay/gdb/layout.hpp"
#include "w1replay/gdb/target_xml.hpp"
#include "w1rewind/rewind_test_helpers.hpp"

namespace {

bool xml_has_reg(const std::string& xml, const std::string& name, size_t regnum) {
  std::string needle = "name=\"" + name + "\"";
  std::string regnum_text = "regnum=\"" + std::to_string(regnum) + "\"";
  auto pos = xml.find(needle);
  if (pos == std::string::npos) {
    return false;
  }
  return xml.find(regnum_text, pos) != std::string::npos;
}

bool xml_has_reg_attr(const std::string& xml, const std::string& name, const std::string& attr) {
  std::string needle = "name=\"" + name + "\"";
  auto pos = xml.find(needle);
  if (pos == std::string::npos) {
    return false;
  }
  return xml.find(attr, pos) != std::string::npos;
}

} // namespace

TEST_CASE("gdb target xml encodes architecture and regnums") {
  std::vector<std::string> regs = {"x0", "x1", "lr", "sp", "pc", "nzcv"};
  auto arch = w1::rewind::test_helpers::parse_arch_or_fail("arm64");
  auto specs = w1::rewind::test_helpers::make_register_specs(regs, arch);
  auto layout = w1replay::gdb::build_register_layout(arch, specs);

  auto xml = w1replay::gdb::build_target_xml(layout);
  CHECK(xml.find("<architecture>aarch64</architecture>") != std::string::npos);
  CHECK(xml_has_reg(xml, "x0", 0));
  CHECK(xml_has_reg(xml, "lr", 2));
  CHECK(xml_has_reg(xml, "sp", 3));
  CHECK(xml_has_reg(xml, "pc", 4));
  CHECK(xml_has_reg(xml, "cpsr", 5));
  CHECK(xml_has_reg_attr(xml, "pc", "dwarf_regnum=\"32\""));
  CHECK(xml_has_reg_attr(xml, "pc", "gcc_regnum=\"32\""));
  CHECK(xml_has_reg_attr(xml, "sp", "dwarf_regnum=\"31\""));
  CHECK(xml_has_reg_attr(xml, "lr", "dwarf_regnum=\"30\""));
}

TEST_CASE("gdb target xml uses explicit generic register flags") {
  std::vector<std::string> regs = {"rip", "rsp", "rbp", "rflags"};
  auto arch = w1::rewind::test_helpers::parse_arch_or_fail("x86_64");
  auto specs = w1::rewind::test_helpers::make_register_specs(regs, arch);
  auto layout = w1replay::gdb::build_register_layout(arch, specs);

  auto xml = w1replay::gdb::build_target_xml(layout);
  CHECK(xml_has_reg_attr(xml, "rip", "generic=\"pc\""));
  CHECK(xml_has_reg_attr(xml, "rsp", "generic=\"sp\""));
  CHECK(xml_has_reg_attr(xml, "rbp", "generic=\"fp\""));
  CHECK(xml_has_reg_attr(xml, "eflags", "generic=\"flags\""));
}

```

`test/w1replay/gdb_value_codec_test.cpp`:

```cpp
#include <array>
#include <cstddef>
#include <cstdint>

#include "doctest/doctest.hpp"

#include "w1replay/gdb/value_codec.hpp"

TEST_CASE("gdb value codec encodes big endian values") {
  std::array<std::byte, 4> out{};
  REQUIRE(w1replay::gdb::encode_uint64(0x11223344u, out.size(), out, w1replay::gdb::endian::big));
  CHECK(out[0] == std::byte{0x11});
  CHECK(out[1] == std::byte{0x22});
  CHECK(out[2] == std::byte{0x33});
  CHECK(out[3] == std::byte{0x44});
}

TEST_CASE("gdb value codec encodes little endian values") {
  std::array<std::byte, 4> out{};
  REQUIRE(w1replay::gdb::encode_uint64(0x11223344u, out.size(), out, w1replay::gdb::endian::little));
  CHECK(out[0] == std::byte{0x44});
  CHECK(out[1] == std::byte{0x33});
  CHECK(out[2] == std::byte{0x22});
  CHECK(out[3] == std::byte{0x11});
}

```

`test/w1replay/module_address_index_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "w1replay/modules/address_index.hpp"

TEST_CASE("module address index prefers memory map image ids") {
  w1::rewind::replay_context context{};

  w1::rewind::module_record module_a{};
  module_a.id = 1;
  module_a.base = 0x1000;
  module_a.size = 0x1000;

  w1::rewind::module_record module_b{};
  module_b.id = 2;
  module_b.base = 0x3000;
  module_b.size = 0x1000;

  context.modules = {module_a, module_b};

  w1::rewind::memory_region_record region{};
  region.base = 0x3200;
  region.size = 0x100;
  region.image_id = 2;
  context.memory_map = {region};

  w1replay::module_address_index index(context);
  auto match = index.find(0x3200, 4);
  REQUIRE(match.has_value());
  REQUIRE(match->module);
  CHECK(match->module->id == 2);
  CHECK(match->module_offset == 0x200);
}

TEST_CASE("module address index falls back to module ranges") {
  w1::rewind::replay_context context{};

  w1::rewind::module_record module{};
  module.id = 5;
  module.base = 0x4000;
  module.size = 0x200;

  context.modules = {module};

  w1replay::module_address_index index(context);
  auto match = index.find(0x4010, 8);
  REQUIRE(match.has_value());
  REQUIRE(match->module);
  CHECK(match->module->id == 5);
  CHECK(match->module_offset == 0x10);
}

```

`test/w1replay/module_image_test.cpp`:

```cpp
#include <array>
#include <cstddef>
#include <vector>

#include "doctest/doctest.hpp"

#include "w1replay/modules/module_image.hpp"

TEST_CASE("module_image reads file-backed bytes") {
  w1replay::image_layout layout;
  layout.link_base = 0x1000;
  std::array<std::byte, 4> bytes = {std::byte{0x1}, std::byte{0x2}, std::byte{0x3}, std::byte{0x4}};
  w1replay::image_range range{};
  range.va_start = 0x1000;
  range.mem_size = 4;
  range.file_bytes = std::span<const std::byte>(bytes.data(), bytes.size());
  layout.ranges = {range};

  auto result = w1replay::read_image_bytes(layout, 0, 4);
  CHECK(result.error.empty());
  CHECK(result.complete);
  CHECK(result.bytes.size() == 4);
  CHECK(result.known.size() == 4);
  CHECK(result.bytes[0] == std::byte{0x1});
  CHECK(result.bytes[3] == std::byte{0x4});
}

TEST_CASE("module_image zero-fills bss") {
  w1replay::image_layout layout;
  layout.link_base = 0x2000;
  std::array<std::byte, 4> bytes = {std::byte{0xAA}, std::byte{0xBB}, std::byte{0xCC}, std::byte{0xDD}};
  w1replay::image_range range{};
  range.va_start = 0x2000;
  range.mem_size = 8;
  range.file_bytes = std::span<const std::byte>(bytes.data(), bytes.size());
  layout.ranges = {range};

  auto result = w1replay::read_image_bytes(layout, 0, 8);
  CHECK(result.error.empty());
  CHECK(result.complete);
  CHECK(result.bytes.size() == 8);
  CHECK(result.bytes[0] == std::byte{0xAA});
  CHECK(result.bytes[3] == std::byte{0xDD});
  CHECK(result.bytes[4] == std::byte{0x00});
  CHECK(result.bytes[7] == std::byte{0x00});
}

TEST_CASE("module_image tracks unknown ranges") {
  w1replay::image_layout layout;
  layout.link_base = 0x3000;
  std::array<std::byte, 2> bytes = {std::byte{0x10}, std::byte{0x20}};
  w1replay::image_range range{};
  range.va_start = 0x3000;
  range.mem_size = 2;
  range.file_bytes = std::span<const std::byte>(bytes.data(), bytes.size());
  layout.ranges = {range};

  auto result = w1replay::read_image_bytes(layout, 0, 4);
  CHECK(result.error.empty());
  CHECK(!result.complete);
  CHECK(result.known.size() == 4);
  CHECK(result.known[0] == 1);
  CHECK(result.known[1] == 1);
  CHECK(result.known[2] == 0);
  CHECK(result.known[3] == 0);
}

TEST_CASE("module_image stitches across ranges") {
  w1replay::image_layout layout;
  layout.link_base = 0x4000;
  std::array<std::byte, 2> bytes_a = {std::byte{0x1}, std::byte{0x2}};
  std::array<std::byte, 2> bytes_b = {std::byte{0x3}, std::byte{0x4}};
  w1replay::image_range range_a{};
  range_a.va_start = 0x4000;
  range_a.mem_size = 2;
  range_a.file_bytes = std::span<const std::byte>(bytes_a.data(), bytes_a.size());
  w1replay::image_range range_b{};
  range_b.va_start = 0x4002;
  range_b.mem_size = 2;
  range_b.file_bytes = std::span<const std::byte>(bytes_b.data(), bytes_b.size());
  layout.ranges = {range_a, range_b};

  auto result = w1replay::read_image_bytes(layout, 0, 4);
  CHECK(result.error.empty());
  CHECK(result.complete);
  CHECK(result.bytes[0] == std::byte{0x1});
  CHECK(result.bytes[3] == std::byte{0x4});
}

```

`test/w1replay/module_path_resolver_test.cpp`:

```cpp
#include <filesystem>
#include <fstream>

#include "doctest/doctest.hpp"

#include "w1replay/modules/path_resolver.hpp"
#include "w1rewind/format/trace_format.hpp"

TEST_CASE("module_path_resolver applies overrides and search directories") {
  namespace fs = std::filesystem;

  w1::rewind::module_record mod1;
  mod1.path = "/old/path/libfoo.so";

  w1::rewind::module_record mod2;
  mod2.path = "bar.dylib";

  fs::path temp_dir = fs::temp_directory_path() / "w1replay_module_resolver";
  fs::create_directories(temp_dir);
  fs::path bar_path = temp_dir / "bar.dylib";
  {
    std::ofstream out(bar_path.string(), std::ios::binary);
    out << "x";
  }

  w1replay::default_module_path_resolver resolver({"libfoo.so=/tmp/libfoo.so"}, {temp_dir.string()});

  auto resolved1 = resolver.resolve_module_path(mod1);
  REQUIRE(resolved1.has_value());
  CHECK(*resolved1 == "/tmp/libfoo.so");

  auto resolved2 = resolver.resolve_module_path(mod2);
  REQUIRE(resolved2.has_value());
  CHECK(*resolved2 == bar_path.string());

  auto region1 = resolver.resolve_region_name("/old/path/libfoo.so");
  REQUIRE(region1.has_value());
  CHECK(*region1 == "/tmp/libfoo.so");

  auto region2 = resolver.resolve_region_name("bar.dylib");
  REQUIRE(region2.has_value());
  CHECK(*region2 == bar_path.string());

  std::error_code ec;
  fs::remove(bar_path, ec);
  fs::remove(temp_dir, ec);
}

```

`test/w1replay/replay_context_test.cpp`:

```cpp
#include <string>
#include <vector>

#include "doctest/doctest.hpp"

#include "w1rewind/replay/replay_context.hpp"

TEST_CASE("replay_context finds module for address") {
  w1::rewind::replay_context context;

  w1::rewind::module_record mod1;
  mod1.id = 1;
  mod1.base = 0x1000;
  mod1.size = 0x200;
  mod1.path = "mod1";

  w1::rewind::module_record mod2;
  mod2.id = 2;
  mod2.base = 0x2000;
  mod2.size = 0x100;
  mod2.path = "mod2";

  context.modules = {mod1, mod2};

  uint64_t offset = 0;
  auto* found = context.find_module_for_address(0x1000, 1, offset);
  CHECK(found != nullptr);
  CHECK(found->id == 1);
  CHECK(offset == 0);

  offset = 0;
  found = context.find_module_for_address(0x11FF, 1, offset);
  CHECK(found != nullptr);
  CHECK(found->id == 1);
  CHECK(offset == 0x1FF);

  offset = 0;
  found = context.find_module_for_address(0x11FF, 2, offset);
  CHECK(found == nullptr);

  offset = 0;
  found = context.find_module_for_address(0x2000, 0x100, offset);
  CHECK(found != nullptr);
  CHECK(found->id == 2);
  CHECK(offset == 0);

  offset = 0;
  found = context.find_module_for_address(0x3000, 4, offset);
  CHECK(found == nullptr);

  offset = 123;
  found = context.find_module_for_address(0x1000, 0, offset);
  CHECK(found == nullptr);
}

```

`test/w1replay/test_main.cpp`:

```cpp
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "doctest/doctest.hpp"

```

`test/w1rewind/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${W1_SOURCE_DIR}/cmake/TestConfig.cmake)

set(W1REWIND_TEST_SOURCES
    ${W1_SOURCE_DIR}/test/common/test_main.cpp
    rewind_trace_io_test.cpp
    rewind_recorder_recording_test.cpp
    rewind_recorder_block_recording_test.cpp
    rewind_recorder_helpers_test.cpp
    rewind_config_validation_test.cpp
    rewind_memory_filter_test.cpp
    rewind_memory_map_mapping_test.cpp
    rewind_module_event_test.cpp
    rewind_snapshot_codec_test.cpp
    rewind_stack_window_policy_test.cpp
    rewind_trace_index_test.cpp
    rewind_history_window_test.cpp
    rewind_flow_extractor_test.cpp
    rewind_replay_position_test.cpp
    rewind_replay_cursor_property_test.cpp
    rewind_replay_cursor_test.cpp
    rewind_replay_session_position_test.cpp
    rewind_replay_run_invariants_test.cpp
    rewind_replay_cursor_semantics_test.cpp
    rewind_replay_instruction_cursor_test.cpp
    rewind_replay_checkpoint_test.cpp
    rewind_replay_session_test.cpp
    rewind_replay_state_applier_test.cpp
    rewind_replay_state_test.cpp
    rewind_minimal_trace_test.cpp
)

set(W1REWIND_TEST_LIBS
    w1rewind_record
    w1rewind_replay
)

if(TARGET w1rewind_static)
    list(APPEND W1REWIND_TEST_LIBS w1rewind_static)
elseif(TARGET w1rewind_qbdipreload)
    list(APPEND W1REWIND_TEST_LIBS w1rewind_qbdipreload)
endif()

w1_add_doctest_suite(w1rewind_unit_tests
    SOURCES ${W1REWIND_TEST_SOURCES}
    INCLUDE_DIRS
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/third_party
        ${W1_SOURCE_DIR}/src/tracers/w1rewind
        ${W1_SOURCE_DIR}/test
    LIBS
        ${W1REWIND_TEST_LIBS}
    OUTPUT_SUBDIR w1rewind
)

```

`test/w1rewind/rewind_config_validation_test.cpp`:

```cpp
#include <string>

#include "doctest/doctest.hpp"

#include "tracers/w1rewind/config/rewind_config.hpp"

TEST_CASE("rewind config rejects invalid combinations") {
  std::string error;
  w1rewind::rewind_config config;

  config.registers.bytes = true;
  CHECK(!config.validate(error));
  CHECK(error.find("register byte capture") != std::string::npos);

  config = w1rewind::rewind_config{};
  config.flow.mode = w1rewind::rewind_config::flow_options::flow_mode::block;
  config.registers.deltas = true;
  CHECK(!config.validate(error));
  CHECK(error.find("flow=block") != std::string::npos);

  config = w1rewind::rewind_config{};
  config.stack_snapshots.interval = 1;
  config.stack_window.mode = w1rewind::rewind_config::stack_window_options::window_mode::none;
  CHECK(!config.validate(error));
  CHECK(error.find("stack snapshots") != std::string::npos);

  config = w1rewind::rewind_config{};
  config.memory.values = true;
  config.memory.access = w1rewind::rewind_config::memory_access::none;
  CHECK(!config.validate(error));
  CHECK(error.find("memory values") != std::string::npos);

  config = w1rewind::rewind_config{};
  config.memory.filters = {w1rewind::rewind_config::memory_filter_kind::ranges};
  config.memory.ranges.clear();
  CHECK(!config.validate(error));
  CHECK(error.find("MEM_RANGES") != std::string::npos);

  config = w1rewind::rewind_config{};
  config.memory.filters = {w1rewind::rewind_config::memory_filter_kind::stack_window};
  config.stack_window.mode = w1rewind::rewind_config::stack_window_options::window_mode::none;
  CHECK(!config.validate(error));
  CHECK(error.find("stack window") != std::string::npos);
}

TEST_CASE("rewind config accepts valid combinations") {
  std::string error;
  w1rewind::rewind_config config;
  config.flow.mode = w1rewind::rewind_config::flow_options::flow_mode::instruction;
  config.registers.deltas = true;
  config.registers.snapshot_interval = 4;
  config.stack_window.mode = w1rewind::rewind_config::stack_window_options::window_mode::fixed;
  config.stack_window.above_bytes = 16;
  config.stack_window.below_bytes = 32;
  config.stack_window.max_total_bytes = 64;
  config.stack_snapshots.interval = 1;
  config.memory.access = w1rewind::rewind_config::memory_access::reads_writes;
  config.memory.values = true;
  config.memory.filters = {w1rewind::rewind_config::memory_filter_kind::stack_window};

  CHECK(config.validate(error));
  CHECK(error.empty());
}

```

`test/w1rewind/rewind_flow_extractor_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "w1rewind/replay/flow_extractor.hpp"

namespace {

struct test_observer final : public w1::rewind::flow_record_observer {
  size_t seen = 0;
  bool on_record(const w1::rewind::trace_record&, uint64_t, std::string&) override {
    ++seen;
    return true;
  }
};

} // namespace

TEST_CASE("w1rewind flow_extractor parses instruction records") {
  w1::rewind::replay_context context;
  w1::rewind::flow_extractor extractor(&context);

  w1::rewind::instruction_record inst{};
  inst.thread_id = 7;
  inst.sequence = 9;
  inst.address = 0x401000;
  inst.size = 4;
  inst.flags = 0x12;

  w1::rewind::trace_record record = inst;
  w1::rewind::flow_step step{};
  bool is_flow = false;
  std::string error;

  REQUIRE(extractor.try_extract(record, step, is_flow, error));
  CHECK(is_flow);
  CHECK(step.thread_id == 7);
  CHECK(step.sequence == 9);
  CHECK(step.address == 0x401000);
  CHECK(step.size == 4);
  CHECK(step.flags == 0x12);
  CHECK_FALSE(step.is_block);
}

TEST_CASE("w1rewind flow_extractor skips non-flow records") {
  w1::rewind::replay_context context;
  w1::rewind::flow_extractor extractor(&context);

  w1::rewind::module_table_record table{};
  w1::rewind::trace_record record = table;
  w1::rewind::flow_step step{};
  bool is_flow = true;
  std::string error;

  REQUIRE(extractor.try_extract(record, step, is_flow, error));
  CHECK_FALSE(is_flow);
}

TEST_CASE("w1rewind flow_extractor parses block records") {
  w1::rewind::replay_context context;
  w1::rewind::block_definition_record def{};
  def.address = 0x5000;
  def.size = 8;
  def.flags = 0;
  context.blocks_by_id[42] = def;

  w1::rewind::flow_extractor extractor(&context);
  extractor.set_flow_kind(w1::rewind::flow_kind::blocks);

  w1::rewind::block_exec_record exec{};
  exec.thread_id = 3;
  exec.sequence = 11;
  exec.block_id = 42;

  w1::rewind::trace_record record = exec;
  w1::rewind::flow_step step{};
  bool is_flow = false;
  std::string error;

  REQUIRE(extractor.try_extract(record, step, is_flow, error));
  CHECK(is_flow);
  CHECK(step.thread_id == 3);
  CHECK(step.sequence == 11);
  CHECK(step.address == 0x5000);
  CHECK(step.size == 8);
  CHECK(step.block_id == 42);
  CHECK(step.is_block);
}

TEST_CASE("w1rewind flow_extractor errors on missing block id") {
  w1::rewind::replay_context context;
  w1::rewind::flow_extractor extractor(&context);
  extractor.set_flow_kind(w1::rewind::flow_kind::blocks);

  w1::rewind::block_exec_record exec{};
  exec.thread_id = 1;
  exec.sequence = 0;
  exec.block_id = 99;

  w1::rewind::trace_record record = exec;
  w1::rewind::flow_step step{};
  bool is_flow = false;
  std::string error;

  CHECK_FALSE(extractor.try_extract(record, step, is_flow, error));
  CHECK(error == "block id not found");
}

TEST_CASE("w1rewind flow_extractor forwards non-flow records to observer") {
  w1::rewind::replay_context context;
  w1::rewind::flow_extractor extractor(&context);

  w1::rewind::module_table_record table{};
  w1::rewind::trace_record record = table;
  test_observer observer;
  std::string error;

  REQUIRE(extractor.handle_non_flow(record, &observer, 1, error));
  CHECK(observer.seen == 1);
}

```

`test/w1rewind/rewind_history_window_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "w1rewind/replay/history_window.hpp"

namespace {

w1::rewind::history_window::entry make_entry(uint64_t sequence) {
  w1::rewind::history_window::entry entry{};
  entry.step.thread_id = 1;
  entry.step.sequence = sequence;
  entry.location.chunk_index = static_cast<uint32_t>(sequence);
  entry.location.record_offset = 0;
  return entry;
}

void push_entry(w1::rewind::history_window& window, uint64_t sequence) {
  auto entry = make_entry(sequence);
  window.push(entry.step, entry.location);
}

} // namespace

TEST_CASE("w1rewind history_window pushes and navigates") {
  w1::rewind::history_window window(3);

  push_entry(window, 0);
  push_entry(window, 1);
  push_entry(window, 2);

  CHECK_FALSE(window.empty());
  CHECK(window.current().step.sequence == 2);
  CHECK(window.has_past());
  CHECK_FALSE(window.has_future());

  REQUIRE(window.rewind());
  CHECK(window.current().step.sequence == 1);
  CHECK(window.has_past());
  CHECK(window.has_future());

  REQUIRE(window.forward());
  CHECK(window.current().step.sequence == 2);
}

TEST_CASE("w1rewind history_window resizes while keeping current") {
  w1::rewind::history_window window(4);

  push_entry(window, 0);
  push_entry(window, 1);
  push_entry(window, 2);
  push_entry(window, 3);

  REQUIRE(window.rewind());
  REQUIRE(window.rewind());
  CHECK(window.current().step.sequence == 1);

  window.resize(2);
  CHECK(window.size() == 2);
  CHECK(window.current().step.sequence == 1);
  CHECK_FALSE(window.has_past());
  CHECK(window.has_future());
}

TEST_CASE("w1rewind history_window enforces minimum capacity") {
  w1::rewind::history_window window(0);
  CHECK(window.capacity() == 1);

  window.resize(0);
  CHECK(window.capacity() == 1);
}

```

`test/w1rewind/rewind_memory_filter_test.cpp`:

```cpp
#include <vector>

#include "doctest/doctest.hpp"

#include "tracers/w1rewind/thread/memory_filter.hpp"
#include "tracers/w1rewind/thread/stack_window_policy.hpp"

TEST_CASE("memory filter matches all selectors") {
  w1rewind::rewind_config::memory_options options{};
  options.filters.clear();
  w1rewind::memory_filter filter(options);

  auto out = filter.filter(0x1000, 0x20, {});
  REQUIRE(out.size() == 1);
  CHECK(out[0].start == 0x1000);
  CHECK(out[0].end == 0x1020);
}

TEST_CASE("memory filter intersects explicit ranges") {
  w1rewind::rewind_config::memory_options options{};
  options.filters = {w1rewind::rewind_config::memory_filter_kind::ranges};
  options.ranges = {
      {0x1000, 0x1100},
      {0x1200, 0x1300},
  };
  w1rewind::memory_filter filter(options);

  auto out = filter.filter(0x1050, 0x200, {});
  REQUIRE(out.size() == 2);
  CHECK(out[0].start == 0x1050);
  CHECK(out[0].end == 0x1100);
  CHECK(out[1].start == 0x1200);
  CHECK(out[1].end == 0x1250);
}

TEST_CASE("memory filter intersects stack window segments") {
  w1rewind::rewind_config::memory_options options{};
  options.filters = {w1rewind::rewind_config::memory_filter_kind::stack_window};
  w1rewind::memory_filter filter(options);

  std::vector<w1rewind::stack_window_segment> segments = {
      {0x2000, 0x40},
      {0x2100, 0x20},
  };

  auto out = filter.filter(0x1FF0, 0x40, segments);
  REQUIRE(out.size() == 1);
  CHECK(out[0].start == 0x2000);
  CHECK(out[0].end == 0x2030);
}

TEST_CASE("memory filter merges overlapping selectors") {
  w1rewind::rewind_config::memory_options options{};
  options.filters = {
      w1rewind::rewind_config::memory_filter_kind::ranges,
      w1rewind::rewind_config::memory_filter_kind::stack_window,
  };
  options.ranges = {
      {0x1000, 0x1100},
  };
  w1rewind::memory_filter filter(options);

  std::vector<w1rewind::stack_window_segment> segments = {
      {0x1080, 0x40},
  };

  auto out = filter.filter(0x1050, 0x100, segments);
  REQUIRE(out.size() == 1);
  CHECK(out[0].start == 0x1050);
  CHECK(out[0].end == 0x1100);
}

TEST_CASE("memory filter splits access across disjoint segments") {
  w1rewind::rewind_config::memory_options options{};
  options.filters = {w1rewind::rewind_config::memory_filter_kind::stack_window};
  w1rewind::memory_filter filter(options);

  std::vector<w1rewind::stack_window_segment> segments = {
      {0x2000, 0x10},
      {0x2020, 0x10},
  };

  auto out = filter.filter(0x1FF0, 0x50, segments);
  REQUIRE(out.size() == 2);
  CHECK(out[0].start == 0x2000);
  CHECK(out[0].end == 0x2010);
  CHECK(out[1].start == 0x2020);
  CHECK(out[1].end == 0x2030);
}

```

`test/w1rewind/rewind_memory_map_mapping_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "w1rewind/record/memory_map_utils.hpp"

TEST_CASE("assign_memory_map_image_ids matches regions to modules") {
  w1::rewind::module_record mod1{};
  mod1.id = 1;
  mod1.base = 0x1000;
  mod1.size = 0x100;

  w1::rewind::module_record mod2{};
  mod2.id = 2;
  mod2.base = 0x2000;
  mod2.size = 0x80;

  std::vector<w1::rewind::module_record> modules{mod1, mod2};

  w1::rewind::memory_region_record region1{};
  region1.base = 0x1000;
  region1.size = 0x10;

  w1::rewind::memory_region_record region2{};
  region2.base = 0x2050;
  region2.size = 0x10;

  w1::rewind::memory_region_record region3{};
  region3.base = 0x3000;
  region3.size = 0x10;

  w1::rewind::memory_region_record region4{};
  region4.base = 0x1008;
  region4.size = 0x8;
  region4.image_id = 99;

  w1::rewind::memory_region_record region5{};
  region5.base = 0x0FF0;
  region5.size = 0x30;

  std::vector<w1::rewind::memory_region_record> regions{region1, region2, region3, region4, region5};

  w1::rewind::assign_memory_map_image_ids(regions, modules);

  CHECK(regions[0].image_id == 1);
  CHECK(regions[1].image_id == 2);
  CHECK(regions[2].image_id == 0);
  CHECK(regions[3].image_id == 99);
  CHECK(regions[4].image_id == 1);
}

```

`test/w1rewind/rewind_minimal_trace_test.cpp`:

```cpp
#include <cstddef>
#include <filesystem>
#include <memory>
#include <string>

#include "doctest/doctest.hpp"

#include <redlog.hpp>

#include "w1rewind/rewind_test_helpers.hpp"
#include "w1rewind/replay/replay_context.hpp"
#include "w1rewind/replay/replay_session.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"
#include "w1rewind/trace/trace_index.hpp"
#include "w1rewind/trace/trace_reader.hpp"

TEST_CASE("replay context loads minimal trace without metadata") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_minimal_context.trace");

  w1::rewind::trace_file_writer_config config;
  config.path = trace_path.string();
  config.log = redlog::get_logger("test.w1rewind.minimal");
  config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("arm64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions;
  REQUIRE(writer->write_header(header));

  write_thread_start(*writer, 1, "main");
  write_instruction(*writer, 1, 0, 0x1000);
  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::replay_context context;
  std::string error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, error));
  CHECK(!context.target_info.has_value());
  CHECK(!context.target_environment.has_value());
  CHECK(context.register_specs.empty());
  CHECK(context.register_names.empty());
  CHECK(context.threads.size() == 1);

  auto features = context.features();
  CHECK(!features.has_registers);
  CHECK(!features.track_memory);
}

TEST_CASE("replay session tracks memory without register specs") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_minimal_memory.trace");
  fs::path index_path = temp_path("w1rewind_minimal_memory.trace.idx");

  w1::rewind::trace_file_writer_config config;
  config.path = trace_path.string();
  config.log = redlog::get_logger("test.w1rewind.minimal");
  config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("arm64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags =
      w1::rewind::trace_flag_instructions | w1::rewind::trace_flag_memory_access | w1::rewind::trace_flag_memory_values;
  REQUIRE(writer->write_header(header));

  write_thread_start(*writer, 1, "main");
  write_instruction(*writer, 1, 1, 0x1000);

  w1::rewind::memory_access_record mem{};
  mem.sequence = 1;
  mem.thread_id = 1;
  mem.kind = w1::rewind::memory_access_kind::write;
  mem.address = 0x2000;
  mem.size = 2;
  mem.value_known = true;
  mem.data = {0xAA, 0xBB};
  REQUIRE(writer->write_memory_access(mem));

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(trace_path.string(), index_path.string(), index_options, index.get(), config.log)
  );

  w1::rewind::replay_context context;
  std::string error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, error));

  auto stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());
  w1::rewind::replay_session_config session_config{};
  session_config.stream = stream;
  session_config.index = index;
  session_config.context = context;
  session_config.thread_id = 1;
  session_config.start_sequence = 1;
  session_config.track_registers = false;
  session_config.track_memory = true;

  w1::rewind::replay_session session(session_config);
  bool opened = session.open();
  INFO(session.error());
  REQUIRE(opened);
  REQUIRE(session.step_flow());

  auto bytes = session.read_memory(0x2000, 2);
  REQUIRE(bytes.bytes.size() == 2);
  REQUIRE(bytes.known.size() == 2);
  CHECK(bytes.known[0] == 1);
  CHECK(bytes.known[1] == 1);
  CHECK(std::to_integer<uint8_t>(bytes.bytes[0]) == 0xAA);
  CHECK(std::to_integer<uint8_t>(bytes.bytes[1]) == 0xBB);
}

```

`test/w1rewind/rewind_module_event_test.cpp`:

```cpp
#include <filesystem>

#include "doctest/doctest.hpp"

#include "w1rewind/trace/trace_file_writer.hpp"
#include "w1rewind/trace/trace_reader.hpp"
#include "w1rewind/rewind_test_helpers.hpp"

TEST_CASE("trace reader applies module load and unload records") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_module_events.trace");

  w1::rewind::trace_file_writer_config config;
  config.path = trace_path.string();
  config.log = redlog::get_logger("test.w1rewind.module_events");
  config.chunk_size = 128;

  auto writer = w1::rewind::make_trace_file_writer(config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("arm64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, arch, minimal_registers(arch));

  write_module_table(*writer, 1, 0x1000, "module_a");

  w1::rewind::module_record module_b{};
  module_b.id = 2;
  module_b.base = 0x2000;
  module_b.size = 0x1000;
  module_b.permissions = w1::rewind::module_perm::read | w1::rewind::module_perm::exec;
  module_b.path = "module_b";

  w1::rewind::module_load_record load{};
  load.module = module_b;
  REQUIRE(writer->write_module_load(load));

  w1::rewind::module_unload_record unload{};
  unload.module_id = 1;
  unload.base = 0x1000;
  unload.size = 0x1000;
  unload.path = "module_a";
  REQUIRE(writer->write_module_unload(unload));

  writer->flush();
  writer->close();

  w1::rewind::trace_reader reader(trace_path.string());
  REQUIRE(reader.open());

  w1::rewind::trace_record record;
  while (reader.read_next(record)) {
  }

  CHECK(reader.error().empty());
  REQUIRE(reader.module_table().size() == 1);
  CHECK(reader.module_table().front().id == 2);
  CHECK(reader.module_table().front().path == "module_b");

  reader.close();
  fs::remove(trace_path);
}

```

`test/w1rewind/rewind_recorder_block_recording_test.cpp`:

```cpp
#include <filesystem>
#include <unordered_set>
#include <vector>

#include "doctest/doctest.hpp"

#include "tracers/w1rewind/runtime/rewind_runtime.hpp"
#include "w1rewind/trace/trace_reader.hpp"

namespace {

int rewind_block_test_worker(int count) {
  uint64_t buffer[8] = {2, 4, 6, 8, 10, 12, 14, 16};
  uint64_t total = 0;

  for (int i = 0; i < count; ++i) {
    uint64_t value = buffer[static_cast<size_t>(i) & 7u];
    total += value;
    buffer[static_cast<size_t>(i) & 7u] = value ^ total;
  }

  return static_cast<int>(total & 0xFFFFu);
}

} // namespace

TEST_CASE("w1rewind records block flow and snapshots") {
  namespace fs = std::filesystem;

  fs::path path = fs::temp_directory_path() / "w1rewind_recorder_blocks.trace";

  w1rewind::rewind_config config;
  config.output_path = path.string();
  config.flow.mode = w1rewind::rewind_config::flow_options::flow_mode::block;
  config.registers.deltas = false;
  config.registers.snapshot_interval = 1;
  config.stack_window.mode = w1rewind::rewind_config::stack_window_options::window_mode::none;
  config.stack_snapshots.interval = 0;
  config.memory.access = w1rewind::rewind_config::memory_access::none;
  config.common.instrumentation.include_modules = {"w1rewind_unit_tests"};

  auto runtime = w1rewind::make_thread_runtime(config);
  std::vector<uint64_t> args;
  args.push_back(64);
  uint64_t result = 0;
  bool ok = w1rewind::with_runtime(runtime, [&](auto& active) {
    return active.call(reinterpret_cast<uint64_t>(&rewind_block_test_worker), args, &result, "unit_main");
  });
  if (!ok) {
    WARN("thread runtime could not instrument modules; module scanning may be blocked");
    return;
  }
  REQUIRE(w1rewind::with_runtime(runtime, [](auto& active) { return active.export_output(); }));

  w1::rewind::trace_reader reader(path.string());
  REQUIRE(reader.open());

  size_t block_exec_count = 0;
  size_t block_def_count = 0;
  size_t snapshot_count = 0;
  size_t thread_start_count = 0;
  size_t thread_end_count = 0;
  size_t instruction_count = 0;
  uint64_t last_sequence = 0;
  bool first_block = true;
  std::unordered_set<uint64_t> block_ids;
  std::unordered_set<uint64_t> block_sequences;

  w1::rewind::trace_record record;
  while (reader.read_next(record)) {
    if (std::holds_alternative<w1::rewind::block_definition_record>(record)) {
      const auto& def = std::get<w1::rewind::block_definition_record>(record);
      block_ids.insert(def.block_id);
      block_def_count += 1;
    } else if (std::holds_alternative<w1::rewind::block_exec_record>(record)) {
      const auto& exec = std::get<w1::rewind::block_exec_record>(record);
      if (first_block) {
        first_block = false;
      } else {
        CHECK(exec.sequence == last_sequence + 1);
      }
      last_sequence = exec.sequence;
      block_exec_count += 1;
      block_sequences.insert(exec.sequence);
      CHECK(block_ids.find(exec.block_id) != block_ids.end());
    } else if (std::holds_alternative<w1::rewind::snapshot_record>(record)) {
      const auto& snapshot = std::get<w1::rewind::snapshot_record>(record);
      CHECK(block_sequences.find(snapshot.sequence) != block_sequences.end());
      snapshot_count += 1;
    } else if (std::holds_alternative<w1::rewind::instruction_record>(record)) {
      instruction_count += 1;
    } else if (std::holds_alternative<w1::rewind::thread_start_record>(record)) {
      thread_start_count += 1;
    } else if (std::holds_alternative<w1::rewind::thread_end_record>(record)) {
      thread_end_count += 1;
    }
  }

  CHECK(reader.error().empty());
  CHECK(reader.header().version == w1::rewind::k_trace_version);
  CHECK((reader.header().flags & w1::rewind::trace_flag_blocks) != 0);
  CHECK((reader.header().flags & w1::rewind::trace_flag_instructions) == 0);
  CHECK((reader.header().flags & w1::rewind::trace_flag_register_deltas) == 0);
  CHECK((reader.header().flags & w1::rewind::trace_flag_memory_access) == 0);
  CHECK((reader.header().flags & w1::rewind::trace_flag_snapshots) != 0);
  CHECK(reader.target_info().has_value());
  CHECK(reader.target_environment().has_value());
  CHECK(!reader.register_specs().empty());
  CHECK(!reader.module_table().empty());

  CHECK(block_def_count > 0);
  CHECK(block_exec_count > 0);
  CHECK(instruction_count == 0);
  CHECK(snapshot_count > 0);
  CHECK(thread_start_count == 1);
  CHECK(thread_end_count == 1);
  CHECK(snapshot_count == block_exec_count / config.registers.snapshot_interval);

  reader.close();
  fs::remove(path);
}

```

`test/w1rewind/rewind_recorder_helpers_test.cpp`:

```cpp
#include <algorithm>
#include <string>
#include <vector>

#include "doctest/doctest.hpp"

#include "tracers/w1rewind/thread/memory_access_builder.hpp"
#include "tracers/w1rewind/thread/register_delta_builder.hpp"
#include "tracers/w1rewind/engine/register_schema.hpp"
#include "tracers/w1rewind/config/rewind_config.hpp"
#include "tracers/w1rewind/thread/snapshot_builder.hpp"
#include "w1base/arch_spec.hpp"
#include "w1instrument/tracer/trace_context.hpp"
#include "w1runtime/memory_reader.hpp"
#include "w1runtime/module_catalog.hpp"
#include "w1runtime/register_capture.hpp"

namespace {

const char* set_test_register(QBDI::GPRState& gpr, uint64_t value) {
#if defined(QBDI_ARCH_X86_64)
  gpr.rax = value;
  return "rax";
#elif defined(QBDI_ARCH_X86)
  gpr.eax = static_cast<uint32_t>(value);
  return "eax";
#elif defined(QBDI_ARCH_AARCH64)
  gpr.x0 = value;
  return "x0";
#elif defined(QBDI_ARCH_ARM)
  gpr.r0 = static_cast<uint32_t>(value);
  return "r0";
#else
  (void) gpr;
  (void) value;
  return "";
#endif
}

struct register_capture_result {
  std::string name;
  w1::util::register_state regs;
};

register_capture_result capture_test_state(uint64_t value) {
  QBDI::GPRState gpr{};
  const char* name = set_test_register(gpr, value);
  return {name, w1::util::register_capturer::capture(&gpr)};
}

size_t find_register_index(const std::vector<std::string>& names, const std::string& target) {
  auto it = std::find(names.begin(), names.end(), target);
  if (it == names.end()) {
    return names.size();
  }
  return static_cast<size_t>(std::distance(names.begin(), it));
}

} // namespace

TEST_CASE("register schema and delta builder track changes") {
  auto capture1 = capture_test_state(0x1111);
  auto capture2 = capture_test_state(0x2222);

  REQUIRE(!capture1.name.empty());
  REQUIRE(capture1.name == capture2.name);

  auto arch = w1::arch::detect_host_arch_spec();
  w1rewind::register_schema schema;
  schema.update(capture1.regs, arch);

  size_t reg_index = find_register_index(schema.names(), capture1.name);
  REQUIRE(reg_index < schema.names().size());

  std::optional<w1::util::register_state> last;
  auto deltas1 = w1rewind::capture_register_deltas(schema, capture1.regs, last);
  auto it1 = std::find_if(deltas1.begin(), deltas1.end(), [reg_index](const auto& delta) {
    return delta.reg_id == reg_index;
  });
  REQUIRE(it1 != deltas1.end());
  CHECK(it1->value == 0x1111);

  auto deltas2 = w1rewind::capture_register_deltas(schema, capture2.regs, last);
  CHECK(deltas2.size() == 1);
  CHECK(deltas2[0].reg_id == reg_index);
  CHECK(deltas2[0].value == 0x2222);
}

TEST_CASE("snapshot builder emits register snapshots on interval") {
  auto capture = capture_test_state(0xABCD);
  REQUIRE(!capture.name.empty());

  auto arch = w1::arch::detect_host_arch_spec();
  w1rewind::register_schema schema;
  schema.update(capture.regs, arch);

  w1rewind::rewind_config config;
  config.registers.snapshot_interval = 2;
  config.stack_snapshots.interval = 0;
  config.stack_window.mode = w1rewind::rewind_config::stack_window_options::window_mode::none;

  w1::runtime::module_catalog modules;
  w1::util::memory_reader reader(nullptr, modules);
  w1::trace_context ctx(1, nullptr, &modules, &reader);

  w1rewind::snapshot_state state{};
  auto first = w1rewind::maybe_capture_snapshot(ctx, capture.regs, schema, config, state, redlog::get_logger("test"));
  CHECK(!first.has_value());

  auto second = w1rewind::maybe_capture_snapshot(ctx, capture.regs, schema, config, state, redlog::get_logger("test"));
  REQUIRE(second.has_value());
  CHECK(second->snapshot_id == 0);
  CHECK(state.snapshot_count == 1);

  size_t reg_index = find_register_index(schema.names(), capture.name);
  REQUIRE(reg_index < schema.names().size());
  auto it = std::find_if(second->registers.begin(), second->registers.end(), [reg_index](const auto& delta) {
    return delta.reg_id == reg_index;
  });
  REQUIRE(it != second->registers.end());
  CHECK(it->value == 0xABCD);
}

TEST_CASE("memory access builder captures inline values and truncation") {
  w1rewind::rewind_config config;
  config.memory.values = true;
  config.memory.max_value_bytes = 4;

  w1::runtime::module_catalog modules;
  w1::util::memory_reader reader(nullptr, modules);
  w1::trace_context ctx(1, nullptr, &modules, &reader);

  w1::memory_event event{};
  event.address = 0x1000;
  event.size = 8;
  event.value_valid = true;
  event.value = 0x1122334455667788ULL;
  event.is_read = true;
  event.is_write = false;

  std::vector<w1::address_range> segments = {
      {0x0FFF, 0x1000},
      {0x1000, 0x1008},
  };

  std::vector<w1rewind::pending_memory_access> out;
  uint64_t memory_events = 0;
  w1rewind::append_memory_access(
      config, ctx, event, w1::rewind::memory_access_kind::read, segments, out, memory_events
  );

  REQUIRE(out.size() == 1);
  const auto& record = out.front();
  CHECK(record.address == 0x1000);
  CHECK(record.size == 8);
  CHECK(record.value_known);
  CHECK(record.value_truncated);
  CHECK(record.data.size() == 4);
  CHECK(record.data[0] == 0x88);
  CHECK(record.data[1] == 0x77);
  CHECK(record.data[2] == 0x66);
  CHECK(record.data[3] == 0x55);
  CHECK(memory_events == 1);
}

```

`test/w1rewind/rewind_recorder_recording_test.cpp`:

```cpp
#include <filesystem>
#include <unordered_set>
#include <vector>

#include "doctest/doctest.hpp"

#include "tracers/w1rewind/runtime/rewind_runtime.hpp"
#include "w1rewind/trace/trace_reader.hpp"

namespace {

int rewind_test_worker(int count) {
  uint64_t buffer[8] = {1, 3, 5, 7, 11, 13, 17, 19};
  uint64_t total = 0;

  for (int i = 0; i < count; ++i) {
    uint64_t value = buffer[static_cast<size_t>(i) & 7u];
    total += value;
    buffer[static_cast<size_t>(i) & 7u] = value ^ total;
  }

  return static_cast<int>(total & 0xFFFFu);
}

} // namespace

TEST_CASE("w1rewind records instruction flow, memory, and snapshots") {
  namespace fs = std::filesystem;

  fs::path path = fs::temp_directory_path() / "w1rewind_recorder_recording.trace";

  w1rewind::rewind_config config;
  config.output_path = path.string();
  config.flow.mode = w1rewind::rewind_config::flow_options::flow_mode::instruction;
  config.registers.deltas = true;
  config.registers.snapshot_interval = 8;
  config.stack_window.mode = w1rewind::rewind_config::stack_window_options::window_mode::none;
  config.stack_snapshots.interval = 0;
  config.memory.access = w1rewind::rewind_config::memory_access::reads_writes;
  config.memory.values = true;
  config.memory.max_value_bytes = 4;
  config.common.instrumentation.include_modules = {"w1rewind_unit_tests"};

  auto runtime = w1rewind::make_thread_runtime(config);
  std::vector<uint64_t> args;
  args.push_back(64);
  uint64_t result = 0;
  bool ok = w1rewind::with_runtime(runtime, [&](auto& active) {
    return active.call(reinterpret_cast<uint64_t>(&rewind_test_worker), args, &result, "unit_main");
  });
  if (!ok) {
    WARN("thread runtime could not instrument modules; module scanning may be blocked");
    return;
  }
  REQUIRE(w1rewind::with_runtime(runtime, [](auto& active) { return active.export_output(); }));

  w1::rewind::trace_reader reader(path.string());
  REQUIRE(reader.open());

  size_t instruction_count = 0;
  size_t delta_count = 0;
  size_t memory_count = 0;
  size_t snapshot_count = 0;
  size_t thread_start_count = 0;
  size_t thread_end_count = 0;
  bool saw_truncated = false;
  bool first_instruction = true;
  uint64_t last_sequence = 0;
  std::unordered_set<uint64_t> instruction_sequences;
  const uint32_t memory_max_bytes = config.memory.max_value_bytes;

  w1::rewind::trace_record record;
  while (reader.read_next(record)) {
    if (std::holds_alternative<w1::rewind::instruction_record>(record)) {
      const auto& inst = std::get<w1::rewind::instruction_record>(record);
      if (first_instruction) {
        first_instruction = false;
      } else {
        CHECK(inst.sequence == last_sequence + 1);
      }
      last_sequence = inst.sequence;
      instruction_sequences.insert(inst.sequence);
      instruction_count += 1;
    } else if (std::holds_alternative<w1::rewind::register_delta_record>(record)) {
      const auto& deltas = std::get<w1::rewind::register_delta_record>(record);
      CHECK(instruction_sequences.find(deltas.sequence) != instruction_sequences.end());
      delta_count += 1;
    } else if (std::holds_alternative<w1::rewind::memory_access_record>(record)) {
      const auto& mem = std::get<w1::rewind::memory_access_record>(record);
      CHECK(instruction_sequences.find(mem.sequence) != instruction_sequences.end());
      if (mem.size > memory_max_bytes) {
        CHECK(mem.value_truncated);
        saw_truncated = true;
      }
      if (mem.value_known) {
        CHECK(!mem.data.empty());
        CHECK(mem.data.size() <= memory_max_bytes);
      }
      memory_count += 1;
    } else if (std::holds_alternative<w1::rewind::snapshot_record>(record)) {
      const auto& snapshot = std::get<w1::rewind::snapshot_record>(record);
      CHECK(instruction_sequences.find(snapshot.sequence) != instruction_sequences.end());
      snapshot_count += 1;
    } else if (std::holds_alternative<w1::rewind::thread_start_record>(record)) {
      thread_start_count += 1;
    } else if (std::holds_alternative<w1::rewind::thread_end_record>(record)) {
      thread_end_count += 1;
    }
  }

  CHECK(reader.error().empty());
  CHECK(reader.header().version == w1::rewind::k_trace_version);
  CHECK((reader.header().flags & w1::rewind::trace_flag_instructions) != 0);
  CHECK((reader.header().flags & w1::rewind::trace_flag_blocks) == 0);
  CHECK((reader.header().flags & w1::rewind::trace_flag_register_deltas) != 0);
  CHECK((reader.header().flags & w1::rewind::trace_flag_memory_access) != 0);
  CHECK((reader.header().flags & w1::rewind::trace_flag_memory_values) != 0);
  CHECK((reader.header().flags & w1::rewind::trace_flag_snapshots) != 0);
  CHECK(reader.target_info().has_value());
  CHECK(reader.target_environment().has_value());
  CHECK(!reader.register_specs().empty());
  CHECK(!reader.module_table().empty());
  CHECK(!reader.memory_map().empty());

  CHECK(instruction_count > 0);
  CHECK(delta_count > 0);
  CHECK(memory_count > 0);
  CHECK(snapshot_count > 0);
  CHECK(thread_start_count == 1);
  CHECK(thread_end_count == 1);
  CHECK(delta_count <= instruction_count);
  CHECK(saw_truncated);
  CHECK(snapshot_count == instruction_count / config.registers.snapshot_interval);

  reader.close();
  fs::remove(path);
}

```

`test/w1rewind/rewind_replay_checkpoint_test.cpp`:

```cpp
#include <array>
#include <cstddef>
#include <filesystem>
#include <memory>
#include <string>

#include "doctest/doctest.hpp"

#include "w1rewind/rewind_test_helpers.hpp"
#include "w1rewind/replay/flow_cursor.hpp"
#include "w1rewind/replay/replay_context.hpp"
#include "w1rewind/replay/replay_state.hpp"
#include "w1rewind/replay/replay_state_applier.hpp"
#include "w1rewind/replay/stateful_flow_cursor.hpp"
#include "w1rewind/trace/replay_checkpoint.hpp"
#include "w1rewind/replay/replay_session.hpp"
#include "w1rewind/trace/trace_index.hpp"
#include "w1rewind/trace/trace_reader.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"

TEST_CASE("w1rewind replay checkpoint restores register state") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_checkpoint.trace");
  fs::path index_path = temp_path("w1rewind_replay_checkpoint.trace.idx");
  fs::path checkpoint_path = temp_path("w1rewind_replay_checkpoint.trace.w1rchk");

  w1::rewind::trace_file_writer_config config;
  config.path = trace_path.string();
  config.log = redlog::get_logger("test.w1rewind.replay_checkpoint");
  config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  w1::rewind::trace_header header{};
  header.arch = parse_arch_or_fail("x86_64");
  header.flags = w1::rewind::trace_flag_instructions | w1::rewind::trace_flag_register_deltas;
  REQUIRE(writer->write_header(header));

  write_target_info(*writer);
  write_target_environment(*writer);
  w1::rewind::register_spec_record specs{};
  w1::rewind::register_spec gpr{};
  gpr.reg_id = 0;
  gpr.name = "r0";
  gpr.bits = static_cast<uint16_t>(header.arch.pointer_bits);
  gpr.gdb_name = "r0";
  gpr.reg_class = w1::rewind::register_class::gpr;
  gpr.value_kind = w1::rewind::register_value_kind::u64;
  w1::rewind::register_spec vec{};
  vec.reg_id = 1;
  vec.name = "v0";
  vec.bits = 128;
  vec.gdb_name = "v0";
  vec.reg_class = w1::rewind::register_class::simd;
  vec.value_kind = w1::rewind::register_value_kind::bytes;
  specs.registers = {gpr, vec};
  REQUIRE(writer->write_register_spec(specs));
  write_module_table(*writer, 1, 0x1000);

  write_thread_start(*writer, 1, "main");

  for (uint64_t seq = 0; seq < 4; ++seq) {
    write_instruction(*writer, 1, seq, 0x1000 + 0x10 + seq * 4);
    write_register_delta(*writer, 1, seq, 0, 0x1000 + seq);
    if (seq == 0) {
      w1::rewind::register_bytes_record bytes{};
      bytes.sequence = seq;
      bytes.thread_id = 1;
      bytes.entries = {w1::rewind::register_bytes_entry{1, 0, 16}};
      bytes.data = {0x10, 0x11, 0x12, 0x13, 0x20, 0x21, 0x22, 0x23, 0x30, 0x31, 0x32, 0x33, 0x40, 0x41, 0x42, 0x43};
      REQUIRE(writer->write_register_bytes(bytes));
    }
  }

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(trace_path.string(), index_path.string(), index_options, index.get(), config.log)
  );

  w1::rewind::replay_context context;
  std::string context_error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, context_error));

  w1::rewind::replay_checkpoint_config checkpoint_config{};
  checkpoint_config.trace_path = trace_path.string();
  checkpoint_config.output_path = checkpoint_path.string();
  checkpoint_config.stride = 2;

  w1::rewind::replay_checkpoint_index checkpoint_index;
  std::string error;
  REQUIRE(w1::rewind::build_replay_checkpoint(checkpoint_config, &checkpoint_index, error));

  w1::rewind::replay_checkpoint_index loaded;
  REQUIRE(w1::rewind::load_replay_checkpoint(checkpoint_path.string(), loaded, error));

  auto* checkpoint = loaded.find_checkpoint(1, 2);
  REQUIRE(checkpoint != nullptr);
  CHECK(checkpoint->sequence == 2);

  {
    auto stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());
    w1::rewind::record_stream_cursor stream_cursor(stream);
    w1::rewind::flow_extractor extractor(&context);
    w1::rewind::history_window history(4);
    w1::rewind::flow_cursor cursor(std::move(stream_cursor), std::move(extractor), std::move(history), index);
    REQUIRE(cursor.open());

    w1::rewind::replay_state state;
    w1::rewind::replay_state_applier applier(context);
    w1::rewind::stateful_flow_cursor stateful_cursor(cursor, applier, state);
    stateful_cursor.configure(context, true, false);

    state.reset();
    state.set_register_specs(context.register_specs);
    state.apply_register_snapshot(checkpoint->registers);
    if (!checkpoint->register_bytes_entries.empty()) {
      REQUIRE(state.apply_register_bytes(checkpoint->register_bytes_entries, checkpoint->register_bytes));
    }

    REQUIRE(cursor.seek_from_location(1, 2, checkpoint->location));

    w1::rewind::flow_step step{};
    REQUIRE(stateful_cursor.step_forward(step));
    CHECK(step.sequence == 2);

    const auto& state_view = stateful_cursor.state();
    CHECK(state_view.register_value(0) == 0x1000 + 2);
    std::array<std::byte, 16> byte_out{};
    bool known = false;
    REQUIRE(state_view.copy_register_bytes(1, byte_out, known));
    CHECK(known);
    CHECK(byte_out[0] == std::byte{0x10});
    CHECK(byte_out[15] == std::byte{0x43});

    auto session_stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());
    auto checkpoint_ptr = std::make_shared<w1::rewind::replay_checkpoint_index>(loaded);

    w1::rewind::replay_session_config session_config{};
    session_config.stream = session_stream;
    session_config.index = index;
    session_config.checkpoint = checkpoint_ptr;
    session_config.context = context;
    session_config.thread_id = 1;
    session_config.start_sequence = 2;
    session_config.track_registers = true;
    session_config.track_memory = false;

    w1::rewind::replay_session session(session_config);
    REQUIRE(session.open());
    REQUIRE(session.step_flow());
    CHECK(session.current_step().sequence == 2);
    auto regs = session.read_registers();
    REQUIRE(!regs.empty());
    CHECK(regs[0].has_value());
    CHECK(regs[0].value() == 0x1000 + 2);
    std::array<std::byte, 16> session_bytes{};
    bool session_known = false;
    REQUIRE(session.read_register_bytes(1, session_bytes, session_known));
    CHECK(session_known);
    CHECK(session_bytes[0] == std::byte{0x10});
    CHECK(session_bytes[15] == std::byte{0x43});

    cursor.close();
    session.close();
  }
  fs::remove(trace_path);
  fs::remove(index_path);
  fs::remove(checkpoint_path);
}

```

`test/w1rewind/rewind_replay_cursor_property_test.cpp`:

```cpp
#include <random>

#include "doctest/doctest.hpp"

#include "w1rewind/rewind_test_helpers.hpp"
#include "w1rewind/replay/flow_cursor.hpp"
#include "w1rewind/replay/replay_context.hpp"
#include "w1rewind/trace/trace_index.hpp"
#include "w1rewind/trace/trace_reader.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"

namespace {

struct trace_bundle {
  std::filesystem::path trace_path;
  std::filesystem::path index_path;
  w1::rewind::trace_file_writer_config writer_config;
  std::shared_ptr<w1::rewind::trace_index> index;
  w1::rewind::replay_context context;
  std::shared_ptr<w1::rewind::trace_reader> stream;
};

w1::rewind::flow_cursor make_flow_cursor(trace_bundle& bundle, size_t history_size) {
  w1::rewind::record_stream_cursor stream_cursor(bundle.stream);
  w1::rewind::flow_extractor extractor(&bundle.context);
  w1::rewind::history_window history(history_size);
  return w1::rewind::flow_cursor(std::move(stream_cursor), std::move(extractor), std::move(history), bundle.index);
}

trace_bundle build_instruction_trace(const char* name, uint64_t count) {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  trace_bundle out;
  out.trace_path = temp_path(name);
  out.index_path = temp_path((std::string(name) + ".idx").c_str());

  out.writer_config.path = out.trace_path.string();
  out.writer_config.log = redlog::get_logger("test.w1rewind.cursor_property");
  out.writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(out.writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_module_table(*writer, 1, 0x1000);
  write_thread_start(*writer, 1, "thread1");

  for (uint64_t i = 0; i < count; ++i) {
    write_instruction(*writer, 1, i, 0x1000 + i * 4);
  }

  write_thread_end(*writer, 1);
  writer->flush();
  writer->close();

  w1::rewind::trace_index_options options;
  out.index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          out.trace_path.string(), out.index_path.string(), options, out.index.get(), out.writer_config.log
      )
  );

  std::string error;
  REQUIRE(w1::rewind::load_replay_context(out.trace_path.string(), out.context, error));
  out.stream = std::make_shared<w1::rewind::trace_reader>(out.trace_path.string());
  return out;
}

trace_bundle build_block_trace(const char* name, uint64_t count) {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  trace_bundle out;
  out.trace_path = temp_path(name);
  out.index_path = temp_path((std::string(name) + ".idx").c_str());

  out.writer_config.path = out.trace_path.string();
  out.writer_config.log = redlog::get_logger("test.w1rewind.cursor_property");
  out.writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(out.writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_blocks;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_module_table(*writer, 1, 0x2000);
  write_thread_start(*writer, 1, "thread1");

  for (uint64_t i = 0; i < count; ++i) {
    write_block_def(*writer, i + 1, 0x2000 + i * 8, 4);
    write_block_exec(*writer, 1, i, i + 1);
  }

  write_thread_end(*writer, 1);
  writer->flush();
  writer->close();

  w1::rewind::trace_index_options options;
  out.index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          out.trace_path.string(), out.index_path.string(), options, out.index.get(), out.writer_config.log
      )
  );

  std::string error;
  REQUIRE(w1::rewind::load_replay_context(out.trace_path.string(), out.context, error));
  out.stream = std::make_shared<w1::rewind::trace_reader>(out.trace_path.string());
  return out;
}

void run_random_walk(w1::rewind::flow_cursor& cursor, uint64_t count, uint32_t seed) {
  std::mt19937 rng(seed);
  std::uniform_int_distribution<int> pick(0, 1);

  REQUIRE(cursor.open());
  REQUIRE(cursor.seek(1, 0));

  w1::rewind::flow_step step{};
  REQUIRE(cursor.step_forward(step));
  uint64_t model = 0;
  CHECK(step.sequence == model);

  for (size_t i = 0; i < 200; ++i) {
    bool forward = pick(rng) == 1;
    if (forward && model + 1 < count) {
      REQUIRE(cursor.step_forward(step));
      model += 1;
      CHECK(step.sequence == model);
    } else if (!forward && model > 0) {
      REQUIRE(cursor.step_backward(step));
      model -= 1;
      CHECK(step.sequence == model);
    } else if (forward && model + 1 >= count) {
      CHECK_FALSE(cursor.step_forward(step));
      CHECK(cursor.error_kind() == w1::rewind::flow_error_kind::end_of_trace);
    } else if (!forward && model == 0) {
      CHECK_FALSE(cursor.step_backward(step));
      CHECK(cursor.error_kind() == w1::rewind::flow_error_kind::begin_of_trace);
    }
  }
}

} // namespace

TEST_CASE("w1rewind replay cursor random walk on instruction trace") {
  auto trace = build_instruction_trace("w1rewind_cursor_property_inst.trace", 12);
  auto cursor = make_flow_cursor(trace, 4);
  run_random_walk(cursor, 12, 1337);
}

TEST_CASE("w1rewind replay cursor random walk on block trace") {
  auto trace = build_block_trace("w1rewind_cursor_property_block.trace", 10);
  auto cursor = make_flow_cursor(trace, 3);
  run_random_walk(cursor, 10, 4242);
}

```

`test/w1rewind/rewind_replay_cursor_semantics_test.cpp`:

```cpp
#include <filesystem>
#include <functional>
#include <memory>
#include <string>

#include "doctest/doctest.hpp"

#include "w1rewind/rewind_test_helpers.hpp"
#include "w1rewind/replay/flow_cursor.hpp"
#include "w1rewind/replay/replay_context.hpp"
#include "w1rewind/trace/trace_index.hpp"
#include "w1rewind/trace/trace_reader.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"

namespace {

struct trace_bundle {
  std::filesystem::path trace_path;
  std::filesystem::path index_path;
  w1::rewind::trace_file_writer_config writer_config;
  std::shared_ptr<w1::rewind::trace_index> index;
  w1::rewind::replay_context context;
  std::shared_ptr<w1::rewind::trace_reader> stream;
};

w1::rewind::flow_cursor make_flow_cursor(trace_bundle& bundle, size_t history_size) {
  w1::rewind::record_stream_cursor stream_cursor(bundle.stream);
  w1::rewind::flow_extractor extractor(&bundle.context);
  w1::rewind::history_window history(history_size);
  return w1::rewind::flow_cursor(std::move(stream_cursor), std::move(extractor), std::move(history), bundle.index);
}

trace_bundle build_instruction_trace(
    const char* name, size_t count, bool with_deltas, bool with_module = true, uint64_t thread_id = 1
) {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  trace_bundle out;
  out.trace_path = temp_path(name);
  out.index_path = temp_path((std::string(name) + ".idx").c_str());

  out.writer_config.path = out.trace_path.string();
  out.writer_config.log = redlog::get_logger("test.w1rewind.cursor_semantics");
  out.writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(out.writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions;
  if (with_deltas) {
    header.flags |= w1::rewind::trace_flag_register_deltas;
  }
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  if (with_module) {
    write_module_table(*writer, 1, 0x1000);
  }
  write_thread_start(*writer, thread_id, "thread1");

  for (uint64_t i = 0; i < count; ++i) {
    write_instruction(*writer, thread_id, i, 0x1000 + 0x10 + i * 4);
    if (with_deltas) {
      write_register_delta(*writer, thread_id, i, 0, 0x1000 + i);
    }
  }

  write_thread_end(*writer, thread_id);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  out.index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          out.trace_path.string(), out.index_path.string(), index_options, out.index.get(), out.writer_config.log
      )
  );

  std::string error;
  REQUIRE(w1::rewind::load_replay_context(out.trace_path.string(), out.context, error));
  out.stream = std::make_shared<w1::rewind::trace_reader>(out.trace_path.string());

  return out;
}

trace_bundle build_block_trace(const char* name, size_t count, uint64_t thread_id = 1) {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  trace_bundle out;
  out.trace_path = temp_path(name);
  out.index_path = temp_path((std::string(name) + ".idx").c_str());

  out.writer_config.path = out.trace_path.string();
  out.writer_config.log = redlog::get_logger("test.w1rewind.cursor_semantics");
  out.writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(out.writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_blocks;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_module_table(*writer, 1, 0x5000);
  write_thread_start(*writer, thread_id, "thread1");

  for (uint64_t i = 0; i < count; ++i) {
    write_block_def(*writer, i + 1, 0x5000 + 0x10 + i * 0x10, 4);
    write_block_exec(*writer, thread_id, i, i + 1);
  }

  write_thread_end(*writer, thread_id);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  out.index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          out.trace_path.string(), out.index_path.string(), index_options, out.index.get(), out.writer_config.log
      )
  );

  std::string error;
  REQUIRE(w1::rewind::load_replay_context(out.trace_path.string(), out.context, error));
  out.stream = std::make_shared<w1::rewind::trace_reader>(out.trace_path.string());

  return out;
}

} // namespace

TEST_CASE("w1rewind replay cursor reports begin/end of trace errors") {
  auto trace = build_instruction_trace("w1rewind_replay_bounds.trace", 1, false);

  w1::rewind::flow_cursor cursor = make_flow_cursor(trace, 4);
  REQUIRE(cursor.open());
  REQUIRE(cursor.seek(1, 0));

  w1::rewind::flow_step step{};
  REQUIRE(cursor.step_forward(step));
  CHECK(step.sequence == 0);

  CHECK_FALSE(cursor.step_backward(step));
  CHECK(cursor.error_kind() == w1::rewind::flow_error_kind::begin_of_trace);

  CHECK_FALSE(cursor.step_forward(step));
  CHECK(cursor.error_kind() == w1::rewind::flow_error_kind::end_of_trace);
}

TEST_CASE("w1rewind replay cursor shrinks history without losing position") {
  auto trace = build_instruction_trace("w1rewind_replay_history_resize.trace", 6, false);

  w1::rewind::flow_cursor cursor = make_flow_cursor(trace, 5);
  REQUIRE(cursor.open());
  REQUIRE(cursor.seek(1, 0));

  w1::rewind::flow_step step{};
  for (uint64_t i = 0; i <= 4; ++i) {
    REQUIRE(cursor.step_forward(step));
    CHECK(step.sequence == i);
  }

  cursor.set_history_size(2);

  REQUIRE(cursor.step_backward(step));
  CHECK(step.sequence == 3);
  REQUIRE(cursor.step_backward(step));
  CHECK(step.sequence == 2);
}

TEST_CASE("w1rewind replay cursor handles history size one") {
  auto trace = build_instruction_trace("w1rewind_replay_history_one.trace", 3, false);

  w1::rewind::flow_cursor cursor = make_flow_cursor(trace, 1);
  REQUIRE(cursor.open());
  REQUIRE(cursor.seek(1, 0));

  w1::rewind::flow_step step{};
  REQUIRE(cursor.step_forward(step));
  REQUIRE(cursor.step_forward(step));
  CHECK(step.sequence == 1);
  REQUIRE(cursor.step_forward(step));
  CHECK(step.sequence == 2);

  REQUIRE(cursor.step_backward(step));
  CHECK(step.sequence == 1);
  REQUIRE(cursor.step_backward(step));
  CHECK(step.sequence == 0);
}

TEST_CASE("w1rewind replay cursor seek fails for missing thread") {
  auto trace = build_instruction_trace("w1rewind_replay_missing_thread.trace", 2, false);

  w1::rewind::flow_cursor cursor = make_flow_cursor(trace, 4);
  REQUIRE(cursor.open());
  CHECK_FALSE(cursor.seek(2, 0));
  CHECK(cursor.error() == "no anchor for thread");
}

TEST_CASE("w1rewind replay cursor seek_from_location resets to prior step") {
  auto trace = build_instruction_trace("w1rewind_replay_seek_location.trace", 3, false);

  w1::rewind::flow_cursor cursor = make_flow_cursor(trace, 4);
  REQUIRE(cursor.open());
  REQUIRE(cursor.seek(1, 0));

  w1::rewind::flow_step step{};
  w1::rewind::trace_record_location loc{};
  REQUIRE(cursor.step_forward(step, &loc));
  CHECK(step.sequence == 0);

  REQUIRE(cursor.step_forward(step));
  CHECK(step.sequence == 1);

  REQUIRE(cursor.seek_from_location(1, 0, loc));
  REQUIRE(cursor.step_forward(step));
  CHECK(step.sequence == 0);
}

TEST_CASE("w1rewind replay cursor can cancel during seek") {
  auto trace = build_instruction_trace("w1rewind_replay_cancel_seek.trace", 2, false);

  w1::rewind::flow_cursor cursor = make_flow_cursor(trace, 4);
  cursor.set_cancel_checker([]() { return true; });
  REQUIRE(cursor.open());
  CHECK_FALSE(cursor.seek(1, 0));
  CHECK(cursor.error() == "cancelled");
}

TEST_CASE("w1rewind replay cursor can cancel during observer consume") {
  auto trace = build_instruction_trace("w1rewind_replay_cancel_consume.trace", 2, true);

  w1::rewind::flow_cursor cursor = make_flow_cursor(trace, 4);
  struct noop_observer final : public w1::rewind::flow_record_observer {
    bool on_record(const w1::rewind::trace_record&, uint64_t, std::string&) override { return true; }
  } observer;
  cursor.set_observer(&observer);

  auto counter = std::make_shared<int>(0);
  cursor.set_cancel_checker([counter]() {
    (*counter)++;
    return *counter > 1;
  });

  REQUIRE(cursor.open());
  REQUIRE(cursor.seek(1, 0));

  w1::rewind::flow_step step{};
  CHECK_FALSE(cursor.step_forward(step));
  CHECK(cursor.error() == "cancelled");
}

TEST_CASE("w1rewind replay cursor history-only stays consistent across back/forward") {
  auto trace = build_instruction_trace("w1rewind_replay_history_consistent.trace", 6, false);

  w1::rewind::flow_cursor cursor = make_flow_cursor(trace, 3);
  REQUIRE(cursor.open());
  REQUIRE(cursor.seek(1, 0));

  w1::rewind::flow_step step{};
  for (uint64_t i = 0; i <= 3; ++i) {
    REQUIRE(cursor.step_forward(step));
    CHECK(step.sequence == i);
  }

  REQUIRE(cursor.step_backward(step));
  CHECK(step.sequence == 2);
  REQUIRE(cursor.step_backward(step));
  CHECK(step.sequence == 1);

  REQUIRE(cursor.step_forward(step));
  CHECK(step.sequence == 2);
  REQUIRE(cursor.step_forward(step));
  CHECK(step.sequence == 3);

  REQUIRE(cursor.step_forward(step));
  CHECK(step.sequence == 4);
}

TEST_CASE("w1rewind replay cursor supports history-disabled backward stepping") {
  auto trace = build_instruction_trace("w1rewind_replay_history_disabled.trace", 4, false);

  w1::rewind::flow_cursor cursor = make_flow_cursor(trace, 4);
  cursor.set_history_enabled(false);
  REQUIRE(cursor.open());
  REQUIRE(cursor.seek(1, 0));

  w1::rewind::flow_step step{};
  REQUIRE(cursor.step_forward(step));
  REQUIRE(cursor.step_forward(step));
  REQUIRE(cursor.step_forward(step));
  CHECK(step.sequence == 2);

  REQUIRE(cursor.step_backward(step));
  CHECK(step.sequence == 1);
  REQUIRE(cursor.step_backward(step));
  CHECK(step.sequence == 0);

  CHECK_FALSE(cursor.step_backward(step));
  CHECK(cursor.error_kind() == w1::rewind::flow_error_kind::begin_of_trace);
}

TEST_CASE("w1rewind replay cursor cancels during backward prefill") {
  auto trace = build_instruction_trace("w1rewind_replay_cancel_prefill.trace", 3, false);

  w1::rewind::flow_cursor cursor = make_flow_cursor(trace, 2);
  REQUIRE(cursor.open());
  REQUIRE(cursor.seek(1, 2));

  w1::rewind::flow_step step{};
  REQUIRE(cursor.step_forward(step));

  cursor.set_cancel_checker([]() { return true; });
  CHECK_FALSE(cursor.step_backward(step));
  CHECK(cursor.error() == "cancelled");
}

TEST_CASE("w1rewind replay cursor errors when stepping without seek") {
  auto trace = build_instruction_trace("w1rewind_replay_no_seek.trace", 1, false);

  w1::rewind::flow_cursor cursor = make_flow_cursor(trace, 4);
  REQUIRE(cursor.open());

  w1::rewind::flow_step step{};
  CHECK_FALSE(cursor.step_forward(step));
  CHECK(cursor.error() == "thread not selected");

  CHECK_FALSE(cursor.step_backward(step));
  CHECK(cursor.error() == "no current position");
}

TEST_CASE("w1rewind replay cursor supports block flow backward prefill") {
  auto trace = build_block_trace("w1rewind_replay_block_backward.trace", 3);

  w1::rewind::flow_cursor cursor = make_flow_cursor(trace, 2);
  REQUIRE(cursor.open());
  REQUIRE(cursor.seek(1, 0));

  w1::rewind::flow_step step{};
  REQUIRE(cursor.step_forward(step));
  REQUIRE(cursor.step_forward(step));
  REQUIRE(cursor.step_forward(step));
  CHECK(step.sequence == 2);
  CHECK(step.is_block);

  REQUIRE(cursor.step_backward(step));
  CHECK(step.sequence == 1);
  REQUIRE(cursor.step_backward(step));
  CHECK(step.sequence == 0);
}

```

`test/w1rewind/rewind_replay_cursor_test.cpp`:

```cpp
#include <filesystem>
#include <memory>
#include <string>
#include <variant>

#include "doctest/doctest.hpp"

#include "w1rewind/rewind_test_helpers.hpp"
#include "w1rewind/replay/flow_cursor.hpp"
#include "w1rewind/replay/replay_context.hpp"
#include "w1rewind/trace/trace_index.hpp"
#include "w1rewind/trace/trace_reader.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"

namespace {

w1::rewind::flow_cursor make_flow_cursor(
    const std::shared_ptr<w1::rewind::trace_record_stream>& stream,
    const std::shared_ptr<w1::rewind::trace_index>& index, w1::rewind::replay_context& context, size_t history_size
) {
  w1::rewind::record_stream_cursor stream_cursor(stream);
  w1::rewind::flow_extractor extractor(&context);
  w1::rewind::history_window history(history_size);
  return w1::rewind::flow_cursor(std::move(stream_cursor), std::move(extractor), std::move(history), index);
}

} // namespace

TEST_CASE("w1rewind replay cursor steps through instruction flow") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_inst.trace");
  fs::path index_path = temp_path("w1rewind_replay_inst.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_module_table(*writer, 1, 0x1000);
  write_thread_start(*writer, 1, "thread1");
  write_thread_start(*writer, 2, "thread2");

  for (uint64_t i = 0; i < 4; ++i) {
    write_instruction(*writer, 1, i, 0x1000 + 0x10 + i * 4);
    if (i < 2) {
      write_instruction(*writer, 2, i, 0x1000 + 0x40 + i * 4);
    }
  }

  write_thread_end(*writer, 1);
  write_thread_end(*writer, 2);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          trace_path.string(), index_path.string(), index_options, index.get(), writer_config.log
      )
  );

  w1::rewind::replay_context context;
  std::string error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, error));

  auto stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());
  w1::rewind::flow_cursor cursor = make_flow_cursor(stream, index, context, 4);
  REQUIRE(cursor.open());
  REQUIRE(cursor.seek(1, 2));

  w1::rewind::flow_step step{};
  REQUIRE(cursor.step_forward(step));
  CHECK(step.thread_id == 1);
  CHECK(step.sequence == 2);
  CHECK(step.address == 0x1000 + 0x10 + 2 * 4);

  REQUIRE(cursor.step_forward(step));
  CHECK(step.sequence == 3);

  REQUIRE(cursor.step_backward(step));
  CHECK(step.sequence == 2);
}

TEST_CASE("w1rewind replay cursor resolves block flow addresses") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_block.trace");
  fs::path index_path = temp_path("w1rewind_replay_block.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_blocks;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_module_table(*writer, 7, 0x2000);
  write_thread_start(*writer, 1, "thread1");

  write_block_def(*writer, 1, 0x2000 + 0x10, 4);
  write_block_def(*writer, 2, 0x2000 + 0x20, 4);
  write_block_exec(*writer, 1, 0, 1);
  write_block_exec(*writer, 1, 1, 2);

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          trace_path.string(), index_path.string(), index_options, index.get(), writer_config.log
      )
  );

  w1::rewind::replay_context context;
  std::string error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, error));

  auto stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());
  w1::rewind::flow_cursor cursor = make_flow_cursor(stream, index, context, 4);
  REQUIRE(cursor.open());
  REQUIRE(cursor.seek(1, 0));

  w1::rewind::flow_step step{};
  REQUIRE(cursor.step_forward(step));
  CHECK(step.sequence == 0);
  CHECK(step.is_block);
  CHECK(step.address == 0x2000 + 0x10);

  REQUIRE(cursor.step_forward(step));
  CHECK(step.sequence == 1);
  CHECK(step.address == 0x2000 + 0x20);
}

TEST_CASE("w1rewind replay cursor handles module-less traces") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_moduleless.trace");
  fs::path index_path = temp_path("w1rewind_replay_moduleless.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_thread_start(*writer, 1, "thread1");
  write_instruction(*writer, 1, 0, 0x4000);
  write_instruction(*writer, 1, 1, 0x4004);
  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          trace_path.string(), index_path.string(), index_options, index.get(), writer_config.log
      )
  );

  w1::rewind::replay_context context;
  std::string error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, error));

  auto stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());
  w1::rewind::flow_cursor cursor = make_flow_cursor(stream, index, context, 4);
  REQUIRE(cursor.open());
  REQUIRE(cursor.seek(1, 0));

  w1::rewind::flow_step step{};
  REQUIRE(cursor.step_forward(step));
  CHECK(step.sequence == 0);
  CHECK(step.address == 0x4000);
  REQUIRE(cursor.step_forward(step));
  CHECK(step.sequence == 1);
  CHECK(step.address == 0x4004);
}

struct cursor_delta_observer final : public w1::rewind::flow_record_observer {
  size_t delta_count = 0;

  bool on_record(const w1::rewind::trace_record& record, uint64_t, std::string&) override {
    if (std::holds_alternative<w1::rewind::register_delta_record>(record)) {
      delta_count += 1;
    }
    return true;
  }
};

TEST_CASE("w1rewind replay cursor backfills history window when stepping backward") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_history.trace");
  fs::path index_path = temp_path("w1rewind_replay_history.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_module_table(*writer, 1, 0x1000);
  write_thread_start(*writer, 1, "thread1");

  for (uint64_t i = 0; i < 8; ++i) {
    write_instruction(*writer, 1, i, 0x1000 + 0x10 + i * 4);
  }

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          trace_path.string(), index_path.string(), index_options, index.get(), writer_config.log
      )
  );

  w1::rewind::replay_context context;
  std::string error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, error));

  auto stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());
  w1::rewind::flow_cursor cursor = make_flow_cursor(stream, index, context, 3);
  REQUIRE(cursor.open());
  REQUIRE(cursor.seek(1, 0));

  w1::rewind::flow_step step{};
  for (uint64_t i = 0; i <= 6; ++i) {
    REQUIRE(cursor.step_forward(step));
    CHECK(step.sequence == i);
  }

  REQUIRE(cursor.step_backward(step));
  CHECK(step.sequence == 5);
  REQUIRE(cursor.step_backward(step));
  CHECK(step.sequence == 4);
  REQUIRE(cursor.step_backward(step));
  CHECK(step.sequence == 3);
  REQUIRE(cursor.step_backward(step));
  CHECK(step.sequence == 2);
}

TEST_CASE("w1rewind replay cursor supports history with observer") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_observer.trace");
  fs::path index_path = temp_path("w1rewind_replay_observer.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_module_table(*writer, 1, 0x2000);
  write_thread_start(*writer, 1, "thread1");

  for (uint64_t i = 0; i < 4; ++i) {
    write_instruction(*writer, 1, i, 0x2000 + 0x10 + i * 4);
    write_register_delta(*writer, 1, i, 0, 0x1000 + i);
  }

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          trace_path.string(), index_path.string(), index_options, index.get(), writer_config.log
      )
  );

  w1::rewind::replay_context context;
  std::string error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, error));

  auto stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());
  w1::rewind::flow_cursor cursor = make_flow_cursor(stream, index, context, 4);
  cursor_delta_observer observer;
  cursor.set_observer(&observer);

  REQUIRE(cursor.open());
  REQUIRE(cursor.seek(1, 0));

  w1::rewind::flow_step step{};
  REQUIRE(cursor.step_forward(step));
  REQUIRE(cursor.step_forward(step));
  REQUIRE(cursor.step_backward(step));
  REQUIRE(cursor.step_forward(step));
  REQUIRE(cursor.step_forward(step));
  REQUIRE(cursor.step_forward(step));

  CHECK(observer.delta_count == 6);
}

TEST_CASE("w1rewind replay cursor cancels during forward step") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_cancel.trace");
  fs::path index_path = temp_path("w1rewind_replay_cancel.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_thread_start(*writer, 1, "thread1");

  for (uint64_t i = 0; i < 3; ++i) {
    write_instruction(*writer, 1, i, 0x3000 + 0x10 + i * 4);
  }

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          trace_path.string(), index_path.string(), index_options, index.get(), writer_config.log
      )
  );

  w1::rewind::replay_context context;
  std::string error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, error));

  auto stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());
  w1::rewind::flow_cursor cursor = make_flow_cursor(stream, index, context, 4);
  REQUIRE(cursor.open());
  REQUIRE(cursor.seek(1, 0));

  w1::rewind::flow_step step{};
  REQUIRE(cursor.step_forward(step));

  cursor.set_cancel_checker([]() { return true; });
  CHECK_FALSE(cursor.step_forward(step));
  CHECK(cursor.error_kind() == w1::rewind::flow_error_kind::other);
  CHECK(cursor.error() == "cancelled");
}

```

`test/w1rewind/rewind_replay_instruction_cursor_test.cpp`:

```cpp
#include <filesystem>
#include <memory>
#include <string>

#include "doctest/doctest.hpp"

#include "w1rewind/rewind_test_helpers.hpp"
#include "w1rewind/replay/flow_cursor.hpp"
#include "w1rewind/replay/replay_context.hpp"
#include "w1rewind/replay/replay_instruction_cursor.hpp"
#include "w1rewind/replay/replay_state.hpp"
#include "w1rewind/replay/replay_state_applier.hpp"
#include "w1rewind/replay/stateful_flow_cursor.hpp"
#include "w1rewind/trace/trace_index.hpp"
#include "w1rewind/trace/trace_reader.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"

namespace {

class test_block_decoder final : public w1::rewind::block_decoder {
public:
  bool decode_block(
      const w1::rewind::replay_context&, const w1::rewind::flow_step& flow, w1::rewind::decoded_block& out, std::string&
  ) override {
    uint64_t address = flow.address;
    uint32_t size = flow.size;
    if (size == 0 || (size % 2) != 0) {
      return false;
    }

    out.start = address;
    out.size = size;

    uint32_t offset = 0;
    while (offset < size) {
      w1::rewind::decoded_instruction inst{};
      inst.address = address + offset;
      inst.size = 2;
      inst.bytes = {0x90, 0x90};
      out.instructions.push_back(inst);
      offset += 2;
    }

    return true;
  }
};

} // namespace

TEST_CASE("w1rewind replay instruction cursor decodes blocks and steps backward") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_instruction_cursor.trace");
  fs::path index_path = temp_path("w1rewind_replay_instruction_cursor.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay.instruction_cursor");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_blocks;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_module_table(*writer, 1, 0x2000);
  write_thread_start(*writer, 1, "thread1");
  write_block_def(*writer, 1, 0x2000 + 0x20, 4);
  write_block_exec(*writer, 1, 0, 1);
  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  w1::rewind::trace_index index;
  REQUIRE(
      w1::rewind::build_trace_index(trace_path.string(), index_path.string(), index_options, &index, writer_config.log)
  );

  auto index_ptr = std::make_shared<w1::rewind::trace_index>(index);

  w1::rewind::replay_context context;
  std::string error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, error));

  auto stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());
  w1::rewind::record_stream_cursor stream_cursor(stream);
  w1::rewind::flow_extractor extractor(&context);
  w1::rewind::history_window history(4);
  w1::rewind::flow_cursor flow_cursor(std::move(stream_cursor), std::move(extractor), std::move(history), index_ptr);
  REQUIRE(flow_cursor.open());

  w1::rewind::replay_state state;
  w1::rewind::replay_state_applier applier(context);
  w1::rewind::stateful_flow_cursor stateful_cursor(flow_cursor, applier, state);
  stateful_cursor.configure(context, false, false);
  REQUIRE(flow_cursor.seek(1, 0));

  test_block_decoder decoder;
  w1::rewind::replay_instruction_cursor instruction_cursor(stateful_cursor);
  instruction_cursor.set_decoder(&decoder);

  w1::rewind::flow_step step{};
  REQUIRE(instruction_cursor.step_forward(step));
  CHECK(step.address == 0x2000 + 0x20);

  REQUIRE(instruction_cursor.step_forward(step));
  CHECK(step.address == 0x2000 + 0x22);

  REQUIRE(instruction_cursor.step_backward(step));
  CHECK(step.address == 0x2000 + 0x20);
}

TEST_CASE("w1rewind replay instruction cursor reports missing decoder") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_instruction_cursor_notice.trace");
  fs::path index_path = temp_path("w1rewind_replay_instruction_cursor_notice.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay.instruction_cursor");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_blocks;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_module_table(*writer, 2, 0x4000);
  write_thread_start(*writer, 1, "thread1");
  write_block_def(*writer, 1, 0x4000 + 0x10, 4);
  write_block_exec(*writer, 1, 0, 1);
  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  w1::rewind::trace_index index;
  REQUIRE(
      w1::rewind::build_trace_index(trace_path.string(), index_path.string(), index_options, &index, writer_config.log)
  );

  auto index_ptr = std::make_shared<w1::rewind::trace_index>(index);

  w1::rewind::replay_context context;
  std::string error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, error));

  auto stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());
  w1::rewind::record_stream_cursor stream_cursor(stream);
  w1::rewind::flow_extractor extractor(&context);
  w1::rewind::history_window history(4);
  w1::rewind::flow_cursor flow_cursor(std::move(stream_cursor), std::move(extractor), std::move(history), index_ptr);
  REQUIRE(flow_cursor.open());

  w1::rewind::replay_state state;
  w1::rewind::replay_state_applier applier(context);
  w1::rewind::stateful_flow_cursor stateful_cursor(flow_cursor, applier, state);
  stateful_cursor.configure(context, false, false);
  REQUIRE(flow_cursor.seek(1, 0));

  w1::rewind::replay_instruction_cursor instruction_cursor(stateful_cursor);

  w1::rewind::flow_step step{};
  REQUIRE(instruction_cursor.step_forward(step));
  CHECK(step.is_block);

  auto notice = instruction_cursor.take_notice();
  REQUIRE(notice.has_value());
  CHECK(notice->kind == w1::rewind::replay_notice_kind::decode_unavailable);
}

```

`test/w1rewind/rewind_replay_position_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "w1rewind/replay/replay_position.hpp"

namespace {

class test_decoder final : public w1::rewind::block_decoder {
public:
  bool decode_block(
      const w1::rewind::replay_context&, const w1::rewind::flow_step& flow, w1::rewind::decoded_block& out,
      std::string& error
  ) override {
    if (flow.size == 0) {
      error = "block size is zero";
      return false;
    }
    out.start = flow.address;
    out.size = flow.size;
    out.instructions.clear();

    w1::rewind::decoded_instruction first{};
    first.address = flow.address;
    first.size = 2;
    w1::rewind::decoded_instruction second{};
    second.address = flow.address + 2;
    second.size = 2;
    out.instructions.push_back(first);
    out.instructions.push_back(second);
    return true;
  }
};

class failing_decoder final : public w1::rewind::block_decoder {
public:
  bool decode_block(
      const w1::rewind::replay_context&, const w1::rewind::flow_step&, w1::rewind::decoded_block&, std::string& error
  ) override {
    error = "decode failed";
    return false;
  }
};

} // namespace

TEST_CASE("w1rewind replay_position normalizes instruction flow without decoder") {
  w1::rewind::replay_context context;
  w1::rewind::replay_position pos{};
  pos.flow.thread_id = 1;
  pos.flow.sequence = 2;
  pos.flow.address = 0x1000;
  pos.flow.size = 4;
  pos.flow.is_block = false;
  pos.kind = w1::rewind::position_kind::block;

  w1::rewind::position_normalizer normalizer(nullptr);
  std::string error;
  REQUIRE(normalizer.normalize(context, pos, true, error));
  CHECK(pos.kind == w1::rewind::position_kind::instruction);
  REQUIRE(pos.instruction.has_value());
  CHECK(pos.instruction->address == 0x1000);
  CHECK_FALSE(pos.instruction->is_block);
}

TEST_CASE("w1rewind replay_position normalizes block with forward/backward bias") {
  w1::rewind::replay_context context;
  test_decoder decoder;
  w1::rewind::position_normalizer normalizer(&decoder);

  w1::rewind::replay_position pos{};
  pos.flow.address = 0x2000;
  pos.flow.size = 4;
  pos.flow.is_block = true;
  pos.kind = w1::rewind::position_kind::block;

  std::string error;
  REQUIRE(normalizer.normalize(context, pos, true, error));
  CHECK(pos.kind == w1::rewind::position_kind::instruction);
  REQUIRE(pos.instruction.has_value());
  CHECK(pos.instruction->address == 0x2000);

  pos.kind = w1::rewind::position_kind::block;
  pos.instruction.reset();
  REQUIRE(normalizer.normalize(context, pos, false, error));
  REQUIRE(pos.instruction.has_value());
  CHECK(pos.instruction->address == 0x2002);
}

TEST_CASE("w1rewind replay_position reports decode failure") {
  w1::rewind::replay_context context;
  failing_decoder decoder;
  w1::rewind::position_normalizer normalizer(&decoder);

  w1::rewind::replay_position pos{};
  pos.flow.address = 0x3000;
  pos.flow.size = 4;
  pos.flow.is_block = true;
  pos.kind = w1::rewind::position_kind::block;

  std::string error;
  CHECK_FALSE(normalizer.normalize(context, pos, true, error));
  CHECK(error == "decode failed");
  CHECK(pos.kind == w1::rewind::position_kind::block);
  CHECK_FALSE(pos.instruction.has_value());
}

```

`test/w1rewind/rewind_replay_run_invariants_test.cpp`:

```cpp
#include <filesystem>
#include <memory>
#include <string>

#include "doctest/doctest.hpp"

#include "w1rewind/rewind_test_helpers.hpp"
#include "w1rewind/replay/block_decoder.hpp"
#include "w1rewind/replay/replay_session.hpp"
#include "w1rewind/trace/trace_index.hpp"
#include "w1rewind/trace/trace_reader.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"

namespace {

class test_block_decoder final : public w1::rewind::block_decoder {
public:
  bool decode_block(
      const w1::rewind::replay_context&, const w1::rewind::flow_step& flow, w1::rewind::decoded_block& out,
      std::string&
  ) override {
    out.start = flow.address;
    out.size = flow.size;
    out.instructions.clear();

    w1::rewind::decoded_instruction first{};
    first.address = flow.address;
    first.size = 2;
    w1::rewind::decoded_instruction second{};
    second.address = flow.address + 2;
    second.size = 2;
    out.instructions.push_back(first);
    out.instructions.push_back(second);
    return true;
  }
};

} // namespace

TEST_CASE("w1rewind replay session steps across block boundaries") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_run_invariants.trace");
  fs::path index_path = temp_path("w1rewind_replay_run_invariants.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay.run_invariants");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_blocks;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_module_table(*writer, 1, 0x1000);
  write_thread_start(*writer, 1, "thread1");

  write_block_def(*writer, 1, 0x1000, 4);
  write_block_exec(*writer, 1, 0, 1);
  write_block_def(*writer, 2, 0x2000, 4);
  write_block_exec(*writer, 1, 1, 2);

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          trace_path.string(), index_path.string(), index_options, index.get(), writer_config.log
      )
  );

  w1::rewind::replay_context context;
  std::string error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, error));

  test_block_decoder decoder;
  w1::rewind::replay_session_config config;
  config.stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());
  config.index = index;
  config.context = context;
  config.block_decoder = &decoder;

  w1::rewind::replay_session session(config);
  REQUIRE(session.open());
  REQUIRE(session.select_thread(1, 0));
  REQUIRE(session.step_flow());
  REQUIRE(session.sync_instruction_position(true));

  CHECK(session.current_step().address == 0x1000);
  CHECK(session.current_step().sequence == 0);

  REQUIRE(session.step_instruction());
  CHECK(session.current_step().address == 0x1002);
  CHECK(session.current_step().sequence == 0);

  REQUIRE(session.step_instruction());
  CHECK(session.current_step().address == 0x2000);
  CHECK(session.current_step().sequence == 1);

  REQUIRE(session.step_instruction_backward());
  CHECK(session.current_step().address == 0x1002);
  CHECK(session.current_step().sequence == 0);

  REQUIRE(session.step_instruction_backward());
  CHECK(session.current_step().address == 0x1000);
  CHECK(session.current_step().sequence == 0);
}

```

`test/w1rewind/rewind_replay_session_position_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "w1rewind/rewind_test_helpers.hpp"
#include "w1rewind/replay/replay_session.hpp"
#include "w1rewind/trace/trace_index.hpp"
#include "w1rewind/trace/trace_reader.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"

namespace {

class test_block_decoder final : public w1::rewind::block_decoder {
public:
  bool decode_block(
      const w1::rewind::replay_context&, const w1::rewind::flow_step& flow, w1::rewind::decoded_block& out,
      std::string&
  ) override {
    out.start = flow.address;
    out.size = flow.size;
    out.instructions.clear();

    w1::rewind::decoded_instruction first{};
    first.address = flow.address;
    first.size = 2;
    w1::rewind::decoded_instruction second{};
    second.address = flow.address + 2;
    second.size = 2;
    out.instructions.push_back(first);
    out.instructions.push_back(second);
    return true;
  }
};

} // namespace

TEST_CASE("w1rewind replay session normalizes to instruction start/end") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_session_pos.trace");
  fs::path index_path = temp_path("w1rewind_replay_session_pos.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay.session_position");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_blocks;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_module_table(*writer, 1, 0x2000);
  write_thread_start(*writer, 1, "thread1");
  write_block_def(*writer, 1, 0x2000 + 0x20, 4);
  write_block_exec(*writer, 1, 0, 1);
  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          trace_path.string(), index_path.string(), index_options, index.get(), writer_config.log
      )
  );

  w1::rewind::replay_context context;
  std::string error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, error));

  test_block_decoder decoder;
  w1::rewind::replay_session_config config;
  config.stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());
  config.index = index;
  config.context = context;
  config.block_decoder = &decoder;

  w1::rewind::replay_session session(config);
  REQUIRE(session.open());
  REQUIRE(session.select_thread(1, 0));
  REQUIRE(session.step_flow());

  REQUIRE(session.sync_instruction_position(true));
  CHECK(session.current_step().address == 0x2000 + 0x20);
  CHECK_FALSE(session.current_step().is_block);

  REQUIRE(session.select_thread(1, 0));
  REQUIRE(session.step_flow());
  REQUIRE(session.sync_instruction_position(false));
  CHECK(session.current_step().address == 0x2000 + 0x22);
  CHECK_FALSE(session.current_step().is_block);
}

```

`test/w1rewind/rewind_replay_session_test.cpp`:

```cpp
#include <chrono>
#include <filesystem>
#include <memory>
#include <string>

#include "doctest/doctest.hpp"

#include "w1rewind/rewind_test_helpers.hpp"
#include "w1rewind/replay/block_decoder.hpp"
#include "w1rewind/replay/replay_session.hpp"
#include "w1rewind/trace/trace_index.hpp"
#include "w1rewind/trace/trace_reader.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"

namespace {

class test_block_decoder final : public w1::rewind::block_decoder {
public:
  bool decode_block(
      const w1::rewind::replay_context&, const w1::rewind::flow_step& flow, w1::rewind::decoded_block& out, std::string&
  ) override {
    if (flow.size == 0 || (flow.size % 2) != 0) {
      return false;
    }

    out.start = flow.address;
    out.size = flow.size;

    uint32_t offset = 0;
    while (offset < flow.size) {
      w1::rewind::decoded_instruction inst{};
      inst.address = flow.address + offset;
      inst.size = 2;
      inst.bytes = {0x90, 0x90};
      out.instructions.push_back(inst);
      offset += 2;
    }

    return true;
  }
};

} // namespace

TEST_CASE("w1rewind replay session steps through decoded block instructions") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_session_block.trace");
  fs::path index_path = temp_path("w1rewind_replay_session_block.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay.session");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_blocks;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_module_table(*writer, 7, 0x2000);

  write_thread_start(*writer, 1, "thread1");

  write_block_def(*writer, 1, 0x2000 + 0x20, 4);
  write_block_def(*writer, 2, 0x2000 + 0x40, 4);
  write_block_exec(*writer, 1, 0, 1);
  write_block_exec(*writer, 1, 1, 2);

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          trace_path.string(), index_path.string(), index_options, index.get(), writer_config.log
      )
  );

  w1::rewind::replay_context context;
  std::string context_error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, context_error));

  auto stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());

  test_block_decoder decoder;
  w1::rewind::replay_session_config config{};
  config.stream = stream;
  config.index = index;
  config.context = context;
  config.thread_id = 1;
  config.track_registers = false;
  config.track_memory = false;
  config.block_decoder = &decoder;

  w1::rewind::replay_session session(config);
  REQUIRE(session.open());

  REQUIRE(session.step_instruction());
  auto step = session.current_step();
  CHECK(!step.is_block);
  CHECK(step.sequence == 0);
  CHECK(step.address == 0x2000 + 0x20);

  REQUIRE(session.step_instruction());
  step = session.current_step();
  CHECK(step.address == 0x2000 + 0x22);

  REQUIRE(session.step_instruction());
  step = session.current_step();
  CHECK(step.sequence == 1);
  CHECK(step.address == 0x2000 + 0x40);

  REQUIRE(session.step_instruction());
  step = session.current_step();
  CHECK(step.address == 0x2000 + 0x42);
}

TEST_CASE("w1rewind replay session instruction stepping falls back without decoder") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_session_fallback.trace");
  fs::path index_path = temp_path("w1rewind_replay_session_fallback.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay.session");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_blocks;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_module_table(*writer, 9, 0x3000);

  write_thread_start(*writer, 1, "thread1");

  write_block_def(*writer, 1, 0x3000 + 0x10, 4);
  write_block_exec(*writer, 1, 0, 1);

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          trace_path.string(), index_path.string(), index_options, index.get(), writer_config.log
      )
  );

  w1::rewind::replay_context context;
  std::string context_error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, context_error));

  auto stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());

  w1::rewind::replay_session_config config{};
  config.stream = stream;
  config.index = index;
  config.context = context;
  config.thread_id = 1;
  config.track_registers = false;
  config.track_memory = false;

  w1::rewind::replay_session session(config);
  REQUIRE(session.open());

  REQUIRE(session.step_instruction());
  auto step = session.current_step();
  CHECK(step.is_block);
  CHECK(step.sequence == 0);
  CHECK(step.address == 0x3000 + 0x10);
}

TEST_CASE("w1rewind trace index rebuilds stale index when trace changes") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_session_rebuild.trace");
  fs::path index_path = temp_path("w1rewind_replay_session_rebuild.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay.session");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_blocks;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_module_table(*writer, 5, 0x1000);
  write_thread_start(*writer, 1, "thread1");
  write_block_def(*writer, 1, 0x1000 + 0x10, 4);
  write_block_exec(*writer, 1, 0, 1);
  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          trace_path.string(), index_path.string(), index_options, index.get(), writer_config.log
      )
  );

  w1::rewind::trace_file_writer_config new_writer_config = writer_config;
  new_writer_config.chunk_size = 128;
  auto new_writer = w1::rewind::make_trace_file_writer(new_writer_config);
  REQUIRE(new_writer);
  REQUIRE(new_writer->open());

  w1::rewind::trace_header new_header{};
  new_header.arch = header.arch;
  new_header.flags = w1::rewind::trace_flag_blocks;
  REQUIRE(new_writer->write_header(new_header));

  write_basic_metadata(*new_writer, new_header.arch, minimal_registers(new_header.arch));
  write_module_table(*new_writer, 5, 0x1000);
  write_thread_start(*new_writer, 1, "thread1");
  write_block_def(*new_writer, 1, 0x1000 + 0x20, 4);
  write_block_exec(*new_writer, 1, 0, 1);
  write_thread_end(*new_writer, 1);

  new_writer->flush();
  new_writer->close();

  auto new_time = fs::file_time_type::clock::now() + std::chrono::seconds(2);
  std::error_code time_error;
  fs::last_write_time(trace_path, new_time, time_error);
  REQUIRE(!time_error);

  w1::rewind::trace_index rebuilt;
  std::string ensure_error;
  REQUIRE(w1::rewind::ensure_trace_index(trace_path, index_path, index_options, rebuilt, ensure_error));
  CHECK(rebuilt.header.chunk_size == new_writer_config.chunk_size);
}

TEST_CASE("w1rewind trace index rebuilds index on mismatch even if trace is older") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_session_rebuild_mismatch.trace");
  fs::path index_path = temp_path("w1rewind_replay_session_rebuild_mismatch.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay.session");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_blocks;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_module_table(*writer, 6, 0x1000);
  write_thread_start(*writer, 1, "thread1");
  write_block_def(*writer, 1, 0x1000 + 0x10, 4);
  write_block_exec(*writer, 1, 0, 1);
  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          trace_path.string(), index_path.string(), index_options, index.get(), writer_config.log
      )
  );

  auto index_time = fs::last_write_time(index_path);

  w1::rewind::trace_file_writer_config new_writer_config = writer_config;
  new_writer_config.chunk_size = 128;
  auto new_writer = w1::rewind::make_trace_file_writer(new_writer_config);
  REQUIRE(new_writer);
  REQUIRE(new_writer->open());

  w1::rewind::trace_header new_header{};
  new_header.arch = header.arch;
  new_header.flags = w1::rewind::trace_flag_blocks;
  REQUIRE(new_writer->write_header(new_header));

  write_basic_metadata(*new_writer, new_header.arch, minimal_registers(new_header.arch));
  write_module_table(*new_writer, 6, 0x1000);
  write_thread_start(*new_writer, 1, "thread1");
  write_block_def(*new_writer, 1, 0x1000 + 0x20, 4);
  write_block_exec(*new_writer, 1, 0, 1);
  write_thread_end(*new_writer, 1);

  new_writer->flush();
  new_writer->close();

  std::error_code time_error;
  fs::last_write_time(trace_path, index_time - std::chrono::seconds(2), time_error);
  REQUIRE(!time_error);

  w1::rewind::trace_index rebuilt;
  std::string ensure_error;
  REQUIRE(w1::rewind::ensure_trace_index(trace_path, index_path, index_options, rebuilt, ensure_error));
  CHECK(rebuilt.header.chunk_size == new_writer_config.chunk_size);
}

TEST_CASE("w1rewind replay session supports reverse instruction stepping on block traces") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_session_reverse.trace");
  fs::path index_path = temp_path("w1rewind_replay_session_reverse.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay.session");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_blocks;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  write_module_table(*writer, 11, 0x5000);

  write_thread_start(*writer, 1, "thread1");

  write_block_def(*writer, 1, 0x5000 + 0x20, 4);
  write_block_exec(*writer, 1, 0, 1);

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          trace_path.string(), index_path.string(), index_options, index.get(), writer_config.log
      )
  );

  w1::rewind::replay_context context;
  std::string context_error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, context_error));

  auto stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());

  test_block_decoder decoder;
  w1::rewind::replay_session_config config{};
  config.stream = stream;
  config.index = index;
  config.context = context;
  config.thread_id = 1;
  config.track_registers = false;
  config.track_memory = false;
  config.block_decoder = &decoder;

  w1::rewind::replay_session session(config);
  REQUIRE(session.open());

  REQUIRE(session.step_flow());
  auto flow = session.current_step();
  CHECK(flow.is_block);

  REQUIRE(session.step_instruction_backward());
  auto step = session.current_step();
  CHECK(step.sequence == 0);
  CHECK(step.address == 0x5000 + 0x22);

  REQUIRE(session.step_instruction_backward());
  step = session.current_step();
  CHECK(step.address == 0x5000 + 0x20);
}

TEST_CASE("w1rewind replay session preserves state across intra-block steps") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_session_state.trace");
  fs::path index_path = temp_path("w1rewind_replay_session_state.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay.session");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_blocks | w1::rewind::trace_flag_register_deltas;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, {"r0"});
  write_module_table(*writer, 12, 0x6000);

  write_thread_start(*writer, 1, "thread1");

  write_block_def(*writer, 1, 0x6000 + 0x20, 4);
  write_block_def(*writer, 2, 0x6000 + 0x40, 4);
  write_block_exec(*writer, 1, 0, 1);
  write_register_delta(*writer, 1, 0, 0, 0x1000);
  write_block_exec(*writer, 1, 1, 2);
  write_register_delta(*writer, 1, 1, 0, 0x1001);

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          trace_path.string(), index_path.string(), index_options, index.get(), writer_config.log
      )
  );

  w1::rewind::replay_context context;
  std::string context_error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, context_error));

  auto stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());

  test_block_decoder decoder;
  w1::rewind::replay_session_config config{};
  config.stream = stream;
  config.index = index;
  config.context = context;
  config.thread_id = 1;
  config.track_registers = true;
  config.track_memory = false;
  config.block_decoder = &decoder;

  w1::rewind::replay_session session(config);
  REQUIRE(session.open());

  REQUIRE(session.step_instruction());
  auto regs = session.read_registers();
  REQUIRE(regs.size() >= 1);
  CHECK(regs[0].has_value());
  CHECK(regs[0].value() == 0x1000);

  REQUIRE(session.step_instruction());
  regs = session.read_registers();
  CHECK(regs[0].has_value());
  CHECK(regs[0].value() == 0x1000);

  REQUIRE(session.step_instruction());
  regs = session.read_registers();
  CHECK(regs[0].has_value());
  CHECK(regs[0].value() == 0x1001);

  REQUIRE(session.step_instruction_backward());
  regs = session.read_registers();
  CHECK(regs[0].has_value());
  CHECK(regs[0].value() == 0x1000);
}

TEST_CASE("w1rewind replay session reverse instruction stepping on instruction traces") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_session_reverse_inst.trace");
  fs::path index_path = temp_path("w1rewind_replay_session_reverse_inst.trace.idx");

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.replay.session");
  writer_config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions | w1::rewind::trace_flag_register_deltas;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, {"r0"});
  write_module_table(*writer, 13, 0x7000);

  write_thread_start(*writer, 1, "thread1");

  for (uint64_t seq = 0; seq < 3; ++seq) {
    write_instruction(*writer, 1, seq, 0x7000 + 0x10 + seq * 4);
    write_register_delta(*writer, 1, seq, 0, 0x2000 + seq);
  }

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(
          trace_path.string(), index_path.string(), index_options, index.get(), writer_config.log
      )
  );

  w1::rewind::replay_context context;
  std::string context_error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, context_error));

  auto stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());

  w1::rewind::replay_session_config config{};
  config.stream = stream;
  config.index = index;
  config.context = context;
  config.thread_id = 1;
  config.track_registers = true;
  config.track_memory = false;

  w1::rewind::replay_session session(config);
  REQUIRE(session.open());

  REQUIRE(session.step_flow());
  auto step = session.current_step();
  CHECK(!step.is_block);
  CHECK(step.sequence == 0);
  auto regs = session.read_registers();
  CHECK(regs[0].has_value());
  CHECK(regs[0].value() == 0x2000);

  REQUIRE(session.step_flow());
  step = session.current_step();
  CHECK(step.sequence == 1);
  regs = session.read_registers();
  CHECK(regs[0].has_value());
  CHECK(regs[0].value() == 0x2001);

  REQUIRE(session.step_instruction_backward());
  step = session.current_step();
  CHECK(step.sequence == 0);
  regs = session.read_registers();
  CHECK(regs[0].has_value());
  CHECK(regs[0].value() == 0x2000);
}

```

`test/w1rewind/rewind_replay_state_applier_test.cpp`:

```cpp
#include <array>
#include <cstddef>

#include "doctest/doctest.hpp"

#include "w1rewind/replay/replay_state_applier.hpp"
#include "w1rewind/format/trace_format.hpp"

TEST_CASE("w1rewind replay state applier applies snapshot state and stack segments") {
  w1::rewind::replay_context context{};
  context.register_specs = {
      w1::rewind::register_spec{
          0, "r0", 64, 0, "", w1::rewind::register_class::gpr, w1::rewind::register_value_kind::u64
      },
      w1::rewind::register_spec{
          1, "sp", 64, w1::rewind::register_flag_sp, "", w1::rewind::register_class::gpr,
          w1::rewind::register_value_kind::u64
      },
  };
  context.register_names = {"r0", "sp"};
  context.sp_reg_id = 1;

  w1::rewind::replay_state state;
  state.set_register_specs(context.register_specs);

  w1::rewind::snapshot_record snapshot{};
  snapshot.thread_id = 1;
  snapshot.registers = {
      w1::rewind::register_delta{0, 0x1111},
      w1::rewind::register_delta{1, 0x2000},
  };
  w1::rewind::stack_segment segment{};
  segment.base = 0x2000;
  segment.size = 2;
  segment.bytes = {0xAA, 0xBB};
  snapshot.stack_segments.push_back(std::move(segment));

  w1::rewind::replay_state_applier applier(context);
  REQUIRE(applier.apply_snapshot(snapshot, 1, true, true, state));

  CHECK(state.register_value(0) == 0x1111);
  CHECK(state.register_value(1) == 0x2000);

  auto mem = state.read_memory(0x2000, 2);
  REQUIRE(mem.bytes.size() == 2);
  REQUIRE(mem.known.size() == 2);
  CHECK(mem.known[0] == 1);
  CHECK(mem.known[1] == 1);
  CHECK(std::to_integer<uint8_t>(mem.bytes[0]) == 0xAA);
  CHECK(std::to_integer<uint8_t>(mem.bytes[1]) == 0xBB);
}

TEST_CASE("w1rewind replay state applier applies read accesses with known values") {
  w1::rewind::replay_context context{};
  context.register_specs = {
      w1::rewind::register_spec{
          0, "r0", 64, 0, "", w1::rewind::register_class::gpr, w1::rewind::register_value_kind::u64
      },
      w1::rewind::register_spec{
          1, "sp", 64, w1::rewind::register_flag_sp, "", w1::rewind::register_class::gpr,
          w1::rewind::register_value_kind::u64
      },
  };
  context.register_names = {"r0", "sp"};
  context.sp_reg_id = 1;

  w1::rewind::replay_state state;
  state.set_register_specs(context.register_specs);

  w1::rewind::register_delta_record deltas{};
  deltas.thread_id = 2;
  deltas.deltas = {w1::rewind::register_delta{0, 0x2222}};

  w1::rewind::memory_access_record mem{};
  mem.thread_id = 1;
  mem.kind = w1::rewind::memory_access_kind::read;
  mem.address = 0x3000;
  mem.size = 1;
  mem.value_known = true;
  mem.data = {0xCC};

  w1::rewind::replay_state_applier applier(context);
  REQUIRE(applier.apply_record(deltas, 1, true, true, state));
  REQUIRE(applier.apply_record(mem, 1, true, true, state));

  CHECK(!state.register_value(0).has_value());
  auto mem_bytes = state.read_memory(0x3000, 1);
  REQUIRE(mem_bytes.bytes.size() == 1);
  REQUIRE(mem_bytes.known.size() == 1);
  CHECK(mem_bytes.known[0] == 1);
  CHECK(std::to_integer<uint8_t>(mem_bytes.bytes[0]) == 0xCC);
}

TEST_CASE("w1rewind replay state applier applies register byte values") {
  w1::rewind::replay_context context{};
  context.register_specs = {
      w1::rewind::register_spec{
          0, "r0", 64, 0, "", w1::rewind::register_class::gpr, w1::rewind::register_value_kind::u64
      },
      w1::rewind::register_spec{
          1, "v0", 128, 0, "", w1::rewind::register_class::simd, w1::rewind::register_value_kind::bytes
      },
  };
  context.register_names = {"r0", "v0"};

  w1::rewind::replay_state state;
  state.set_register_specs(context.register_specs);

  w1::rewind::register_bytes_record bytes{};
  bytes.thread_id = 1;
  bytes.sequence = 0;
  bytes.entries = {w1::rewind::register_bytes_entry{1, 0, 16}};
  bytes.data = {
      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  };

  w1::rewind::replay_state_applier applier(context);
  REQUIRE(applier.apply_record(bytes, 1, true, false, state));

  std::array<std::byte, 16> buffer{};
  bool known = false;
  REQUIRE(state.copy_register_bytes(1, buffer, known));
  CHECK(known);
  CHECK(std::to_integer<uint8_t>(buffer[0]) == 0x00);
  CHECK(std::to_integer<uint8_t>(buffer[15]) == 0x0f);
}

```

`test/w1rewind/rewind_replay_state_test.cpp`:

```cpp
#include <cstddef>
#include <filesystem>
#include <memory>
#include <string>

#include "doctest/doctest.hpp"

#include "w1rewind/rewind_test_helpers.hpp"
#include "w1rewind/replay/flow_cursor.hpp"
#include "w1rewind/replay/replay_context.hpp"
#include "w1rewind/replay/replay_state.hpp"
#include "w1rewind/replay/replay_state_applier.hpp"
#include "w1rewind/replay/stateful_flow_cursor.hpp"
#include "w1rewind/format/trace_format.hpp"
#include "w1rewind/trace/trace_index.hpp"
#include "w1rewind/trace/trace_reader.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"

namespace {

std::vector<std::string> make_register_names(const w1::arch::arch_spec& arch) {
  switch (arch.arch_mode) {
  case w1::arch::mode::x86_64:
    return {"rax", "rsp"};
  case w1::arch::mode::x86_32:
    return {"eax", "esp"};
  case w1::arch::mode::aarch64:
  case w1::arch::mode::arm:
  case w1::arch::mode::thumb:
    return {"x0", "sp"};
  default:
    break;
  }
  return {"r0", "sp"};
}

} // namespace

TEST_CASE("w1rewind replay cursor applies register and memory state") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = temp_path("w1rewind_replay_state.trace");
  fs::path index_path = temp_path("w1rewind_replay_state.trace.idx");

  w1::rewind::trace_file_writer_config config;
  config.path = trace_path.string();
  config.log = redlog::get_logger("test.w1rewind.replay_state");
  config.chunk_size = 64;

  auto writer = w1::rewind::make_trace_file_writer(config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  w1::rewind::trace_header header{};
  header.arch = w1::arch::detect_host_arch_spec();
  header.flags = w1::rewind::trace_flag_instructions | w1::rewind::trace_flag_register_deltas |
                 w1::rewind::trace_flag_memory_access | w1::rewind::trace_flag_memory_values |
                 w1::rewind::trace_flag_snapshots | w1::rewind::trace_flag_stack_snapshot;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, make_register_names(header.arch));
  write_module_table(*writer, 1, 0x1000);

  write_thread_start(*writer, 1, "main");

  write_instruction(*writer, 1, 1, 0x1000 + 0x10);

  w1::rewind::register_delta_record deltas{};
  deltas.sequence = 1;
  deltas.thread_id = 1;
  deltas.deltas = {
      w1::rewind::register_delta{0, 0x1111},
      w1::rewind::register_delta{1, 0x9000},
  };
  REQUIRE(writer->write_register_deltas(deltas));

  w1::rewind::memory_access_record mem{};
  mem.sequence = 1;
  mem.thread_id = 1;
  mem.kind = w1::rewind::memory_access_kind::write;
  mem.address = 0x2000;
  mem.size = 2;
  mem.value_known = true;
  mem.data = {0xDE, 0xAD};
  REQUIRE(writer->write_memory_access(mem));

  w1::rewind::snapshot_record snapshot{};
  snapshot.snapshot_id = 1;
  snapshot.sequence = 1;
  snapshot.thread_id = 1;
  snapshot.registers = {
      w1::rewind::register_delta{0, 0x2222},
      w1::rewind::register_delta{1, 0x3000},
  };
  w1::rewind::stack_segment stack_segment{};
  stack_segment.base = 0x3000;
  stack_segment.size = 2;
  stack_segment.bytes = {0x10, 0x20};
  snapshot.stack_segments.push_back(std::move(stack_segment));
  snapshot.reason = "test";
  REQUIRE(writer->write_snapshot(snapshot));

  write_thread_end(*writer, 1);

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options index_options;
  auto index = std::make_shared<w1::rewind::trace_index>();
  REQUIRE(
      w1::rewind::build_trace_index(trace_path.string(), index_path.string(), index_options, index.get(), config.log)
  );

  w1::rewind::replay_context context;
  std::string error;
  REQUIRE(w1::rewind::load_replay_context(trace_path.string(), context, error));

  auto stream = std::make_shared<w1::rewind::trace_reader>(trace_path.string());
  w1::rewind::record_stream_cursor stream_cursor(stream);
  w1::rewind::flow_extractor extractor(&context);
  w1::rewind::history_window history(4);
  w1::rewind::flow_cursor cursor(std::move(stream_cursor), std::move(extractor), std::move(history), index);
  REQUIRE(cursor.open());

  w1::rewind::replay_state state;
  w1::rewind::replay_state_applier applier(context);
  w1::rewind::stateful_flow_cursor stateful_cursor(cursor, applier, state);
  stateful_cursor.configure(context, true, true);
  REQUIRE(cursor.seek(1, 1));

  w1::rewind::flow_step step{};
  REQUIRE(cursor.step_forward(step));

  const auto& state_view = stateful_cursor.state();
  CHECK(state_view.register_value(0) == 0x2222);
  CHECK(state_view.register_value(1) == 0x3000);

  auto mem_bytes = state_view.read_memory(0x2000, 2);
  REQUIRE(mem_bytes.bytes.size() == 2);
  REQUIRE(mem_bytes.known.size() == 2);
  CHECK(mem_bytes.known[0] == 1);
  CHECK(mem_bytes.known[1] == 1);
  CHECK(std::to_integer<uint8_t>(mem_bytes.bytes[0]) == 0xDE);
  CHECK(std::to_integer<uint8_t>(mem_bytes.bytes[1]) == 0xAD);

  auto stack_bytes = state_view.read_memory(0x3000, 2);
  REQUIRE(stack_bytes.bytes.size() == 2);
  REQUIRE(stack_bytes.known.size() == 2);
  CHECK(stack_bytes.known[0] == 1);
  CHECK(stack_bytes.known[1] == 1);
  CHECK(std::to_integer<uint8_t>(stack_bytes.bytes[0]) == 0x10);
  CHECK(std::to_integer<uint8_t>(stack_bytes.bytes[1]) == 0x20);

  auto unknown = state_view.read_memory(0x2002, 1);
  REQUIRE(unknown.bytes.size() == 1);
  REQUIRE(unknown.known.size() == 1);
  CHECK(unknown.known[0] == 0);

  cursor.close();
  fs::remove(trace_path);
  fs::remove(index_path);
}

```

`test/w1rewind/rewind_snapshot_codec_test.cpp`:

```cpp
#include <cstdint>
#include <vector>

#include "doctest/doctest.hpp"

#include "w1rewind/format/trace_codec.hpp"

TEST_CASE("snapshot codec round trip with stack segments") {
  w1::rewind::snapshot_record input{};
  input.snapshot_id = 42;
  input.sequence = 7;
  input.thread_id = 1;
  input.registers = {
      w1::rewind::register_delta{0, 0x1111},
      w1::rewind::register_delta{1, 0x2222},
  };

  w1::rewind::stack_segment seg0{};
  seg0.base = 0x2000;
  seg0.size = 4;
  seg0.bytes = {0xAA, 0xBB, 0xCC, 0xDD};
  input.stack_segments.push_back(seg0);

  w1::rewind::stack_segment seg1{};
  seg1.base = 0x3000;
  seg1.size = 2;
  seg1.bytes = {0x11, 0x22};
  input.stack_segments.push_back(seg1);

  input.reason = "interval";

  std::vector<uint8_t> buffer;
  w1::rewind::trace_buffer_writer writer(buffer);
  auto log = redlog::get_logger("test.snapshot_codec");

  REQUIRE(w1::rewind::encode_snapshot(input, writer, log));

  w1::rewind::snapshot_record output{};
  w1::rewind::trace_buffer_reader reader(buffer);
  REQUIRE(w1::rewind::decode_snapshot(reader, output));
  CHECK(reader.remaining() == 0);

  CHECK(output.snapshot_id == input.snapshot_id);
  CHECK(output.sequence == input.sequence);
  CHECK(output.thread_id == input.thread_id);
  CHECK(output.registers.size() == input.registers.size());
  CHECK(output.stack_segments.size() == input.stack_segments.size());
  CHECK(output.reason == input.reason);

  for (size_t i = 0; i < input.registers.size(); ++i) {
    CHECK(output.registers[i].reg_id == input.registers[i].reg_id);
    CHECK(output.registers[i].value == input.registers[i].value);
  }

  for (size_t i = 0; i < input.stack_segments.size(); ++i) {
    CHECK(output.stack_segments[i].base == input.stack_segments[i].base);
    CHECK(output.stack_segments[i].size == input.stack_segments[i].size);
    CHECK(output.stack_segments[i].bytes == input.stack_segments[i].bytes);
  }
}

TEST_CASE("snapshot codec rejects size mismatch") {
  w1::rewind::snapshot_record input{};
  input.snapshot_id = 1;
  input.sequence = 1;
  input.thread_id = 1;
  input.reason = "bad";

  w1::rewind::stack_segment seg{};
  seg.base = 0x4000;
  seg.size = 4;
  seg.bytes = {0x00, 0x01};
  input.stack_segments.push_back(seg);

  std::vector<uint8_t> buffer;
  w1::rewind::trace_buffer_writer writer(buffer);
  auto log = redlog::get_logger("test.snapshot_codec");

  CHECK_FALSE(w1::rewind::encode_snapshot(input, writer, log));
}

```

`test/w1rewind/rewind_stack_window_policy_test.cpp`:

```cpp
#include <cstdint>

#include <QBDI.h>
#include "doctest/doctest.hpp"

#include "tracers/w1rewind/thread/stack_window_policy.hpp"
#include "w1runtime/register_capture.hpp"

TEST_CASE("stack window policy clamps fixed window size") {
  QBDI::GPRState gpr{};
#if defined(QBDI_ARCH_X86_64)
  gpr.rsp = 0x2000;
#elif defined(QBDI_ARCH_AARCH64)
  gpr.sp = 0x2000;
#elif defined(QBDI_ARCH_ARM)
  gpr.sp = 0x2000;
#elif defined(QBDI_ARCH_X86)
  gpr.esp = 0x2000;
#else
  return;
#endif

  auto regs = w1::util::register_capturer::capture(&gpr);
  w1rewind::rewind_config::stack_window_options options{};
  options.mode = w1rewind::rewind_config::stack_window_options::window_mode::fixed;
  options.above_bytes = 16;
  options.below_bytes = 32;
  options.max_total_bytes = 40;

  auto result = w1rewind::compute_stack_window_segments(regs, options);
  REQUIRE(result.segments.size() == 1);
  CHECK(result.segments[0].base == 0x2000 - 32);
  CHECK(result.segments[0].size == 40);
}

TEST_CASE("stack window policy emits frame window segment") {
  QBDI::GPRState gpr{};
  uint64_t sp = 0x2000;
  uint64_t fp = 0x2100;
  uint64_t expected_fp_base = 0;
  uint64_t expected_fp_size = 0;

#if defined(QBDI_ARCH_X86_64)
  gpr.rsp = sp;
  gpr.rbp = fp;
  expected_fp_base = fp;
  expected_fp_size = 16;
#elif defined(QBDI_ARCH_AARCH64)
  gpr.sp = sp;
  gpr.x29 = fp;
  expected_fp_base = fp;
  expected_fp_size = 16;
#elif defined(QBDI_ARCH_ARM)
  gpr.sp = sp;
  gpr.r11 = fp;
  expected_fp_base = fp;
  expected_fp_size = 8;
#elif defined(QBDI_ARCH_X86)
  gpr.esp = sp;
  gpr.ebp = fp;
  expected_fp_base = fp;
  expected_fp_size = 8;
#else
  return;
#endif

  auto regs = w1::util::register_capturer::capture(&gpr);
  w1rewind::rewind_config::stack_window_options options{};
  options.mode = w1rewind::rewind_config::stack_window_options::window_mode::frame;
  options.above_bytes = 16;
  options.below_bytes = 32;
  options.max_total_bytes = 128;

  auto result = w1rewind::compute_stack_window_segments(regs, options);
  REQUIRE(result.segments.size() == 2);

  bool saw_fp = false;
  for (const auto& segment : result.segments) {
    if (segment.base == expected_fp_base && segment.size == expected_fp_size) {
      saw_fp = true;
    }
  }
  CHECK(saw_fp);
  CHECK(!result.frame_window_missing);
}

```

`test/w1rewind/rewind_test_helpers.hpp`:

```hpp
#pragma once

#include <filesystem>
#include <string>
#include <string_view>
#include <vector>

#include "doctest/doctest.hpp"

#include "w1rewind/format/register_metadata.hpp"
#include "w1rewind/format/trace_format.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"

namespace w1::rewind::test_helpers {

inline std::filesystem::path temp_path(const char* name) { return std::filesystem::temp_directory_path() / name; }

inline w1::arch::arch_spec parse_arch_or_fail(std::string_view text) {
  w1::arch::arch_spec spec{};
  std::string error;
  REQUIRE(w1::arch::parse_arch_spec(text, spec, error));
  return spec;
}

inline target_info_record make_target_info() {
  target_info_record target{};
  target.os = "test";
  target.abi = "test";
  target.cpu = "test";
  return target;
}

inline target_environment_record make_target_environment() {
  target_environment_record env{};
  env.os_version = "1.0";
  env.os_build = "test-build";
  env.os_kernel = "test-kernel";
  env.hostname = "test-host";
  env.pid = 42;
  env.addressing_bits = 48;
  env.low_mem_addressing_bits = 48;
  env.high_mem_addressing_bits = 48;
  return env;
}

inline std::vector<register_spec> make_register_specs(
    const std::vector<std::string>& names, const w1::arch::arch_spec& arch
) {
  uint32_t pointer_size = arch.pointer_bits == 0 ? 0 : arch.pointer_bits / 8;
  std::vector<register_spec> specs;
  specs.reserve(names.size());
  for (size_t i = 0; i < names.size(); ++i) {
    specs.push_back(build_register_spec(arch, static_cast<uint16_t>(i), names[i], pointer_size));
  }
  return specs;
}

inline std::vector<std::string> minimal_registers(const w1::arch::arch_spec& arch) {
  switch (arch.arch_mode) {
  case w1::arch::mode::x86_64:
    return {"rip"};
  case w1::arch::mode::x86_32:
    return {"eip"};
  case w1::arch::mode::aarch64:
  case w1::arch::mode::arm:
  case w1::arch::mode::thumb:
    return {"pc"};
  default:
    break;
  }
  return {"pc"};
}

inline void write_target_info(trace_file_writer& writer) {
  auto target = make_target_info();
  REQUIRE(writer.write_target_info(target));
}

inline void write_target_environment(trace_file_writer& writer) {
  auto env = make_target_environment();
  REQUIRE(writer.write_target_environment(env));
}

inline void write_register_specs(
    trace_file_writer& writer, const std::vector<std::string>& names, const w1::arch::arch_spec& arch
) {
  register_spec_record record{};
  record.registers = make_register_specs(names, arch);
  REQUIRE(writer.write_register_spec(record));
}

inline void write_basic_metadata(
    trace_file_writer& writer, const w1::arch::arch_spec& arch, const std::vector<std::string>& names
) {
  write_target_info(writer);
  write_target_environment(writer);
  write_register_specs(writer, names, arch);
}

inline void write_module_table(
    trace_file_writer& writer, uint64_t module_id, uint64_t base, const std::string& path = "test_module"
) {
  module_record module{};
  module.id = module_id;
  module.base = base;
  module.size = 0x1000;
  module.permissions = module_perm::read | module_perm::exec;
  module.path = path;

  module_table_record table{};
  table.modules.push_back(module);
  REQUIRE(writer.write_module_table(table));
}

inline void write_thread_start(trace_file_writer& writer, uint64_t thread_id, const std::string& name) {
  thread_start_record start{};
  start.thread_id = thread_id;
  start.name = name;
  REQUIRE(writer.write_thread_start(start));
}

inline void write_thread_end(trace_file_writer& writer, uint64_t thread_id) {
  thread_end_record end{};
  end.thread_id = thread_id;
  REQUIRE(writer.write_thread_end(end));
}

inline void write_block_def(
    trace_file_writer& writer, uint64_t block_id, uint64_t address, uint32_t size, uint32_t flags = 0
) {
  block_definition_record record{};
  record.block_id = block_id;
  record.address = address;
  record.size = size;
  record.flags = flags;
  REQUIRE(writer.write_block_definition(record));
}

inline void write_block_exec(trace_file_writer& writer, uint64_t thread_id, uint64_t sequence, uint64_t block_id) {
  block_exec_record record{};
  record.sequence = sequence;
  record.thread_id = thread_id;
  record.block_id = block_id;
  REQUIRE(writer.write_block_exec(record));
}

inline void write_instruction(
    trace_file_writer& writer, uint64_t thread_id, uint64_t sequence, uint64_t address, uint32_t flags = 0
) {
  instruction_record record{};
  record.sequence = sequence;
  record.thread_id = thread_id;
  record.address = address;
  record.size = 4;
  record.flags = flags;
  REQUIRE(writer.write_instruction(record));
}

inline void write_register_delta(
    trace_file_writer& writer, uint64_t thread_id, uint64_t sequence, uint16_t reg_id, uint64_t value
) {
  register_delta_record deltas{};
  deltas.sequence = sequence;
  deltas.thread_id = thread_id;
  deltas.deltas = {register_delta{reg_id, value}};
  REQUIRE(writer.write_register_deltas(deltas));
}

} // namespace w1::rewind::test_helpers

```

`test/w1rewind/rewind_trace_index_test.cpp`:

```cpp
#include <filesystem>

#include "doctest/doctest.hpp"

#include "w1rewind/rewind_test_helpers.hpp"
#include "w1rewind/trace/trace_index.hpp"
#include "w1rewind/trace/trace_reader.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"

namespace {

void write_instruction_range(
    w1::rewind::trace_file_writer& writer, uint64_t thread_id, uint64_t start_seq, uint64_t count, uint64_t base_address
) {
  for (uint64_t i = 0; i < count; ++i) {
    w1::rewind::instruction_record record{};
    record.sequence = start_seq + i;
    record.thread_id = thread_id;
    record.address = base_address + 0x100 + i * 4;
    record.size = 4;
    record.flags = 0;
    REQUIRE(writer.write_instruction(record));
  }
}

} // namespace

TEST_CASE("w1rewind trace index builds anchors for instruction flow") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path trace_path = fs::temp_directory_path() / "w1rewind_index.trace";
  fs::path index_path = fs::temp_directory_path() / "w1rewind_index.trace.idx";

  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = trace_path.string();
  writer_config.log = redlog::get_logger("test.w1rewind.index");

  auto writer = w1::rewind::make_trace_file_writer(writer_config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  w1::rewind::trace_header header{};
  header.arch = w1::arch::detect_host_arch_spec();
  header.flags = w1::rewind::trace_flag_instructions;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, minimal_registers(header.arch));
  w1::rewind::thread_start_record start1{};
  start1.thread_id = 1;
  start1.name = "thread1";
  REQUIRE(writer->write_thread_start(start1));

  w1::rewind::thread_start_record start2{};
  start2.thread_id = 2;
  start2.name = "thread2";
  REQUIRE(writer->write_thread_start(start2));

  write_instruction_range(*writer, 1, 0, 10, 0x1000);
  write_instruction_range(*writer, 2, 0, 5, 0x2000);

  w1::rewind::thread_end_record end1{};
  end1.thread_id = 1;
  REQUIRE(writer->write_thread_end(end1));

  w1::rewind::thread_end_record end2{};
  end2.thread_id = 2;
  REQUIRE(writer->write_thread_end(end2));

  writer->flush();
  writer->close();

  w1::rewind::trace_index_options options;
  options.anchor_stride = 3;
  options.include_snapshots = false;

  w1::rewind::trace_index index;
  REQUIRE(w1::rewind::build_trace_index(trace_path.string(), index_path.string(), options, &index, writer_config.log));

  w1::rewind::trace_index loaded;
  REQUIRE(w1::rewind::load_trace_index(index_path.string(), loaded, writer_config.log));

  CHECK(loaded.header.trace_flags == header.flags);
  CHECK(!loaded.chunks.empty());
  CHECK(loaded.threads.size() == 2);

  auto anchor1 = loaded.find_anchor(1, 5);
  REQUIRE(anchor1.has_value());
  CHECK(anchor1->sequence == 3);

  auto anchor2 = loaded.find_anchor(1, 9);
  REQUIRE(anchor2.has_value());
  CHECK(anchor2->sequence == 9);

  auto anchor3 = loaded.find_anchor(2, 2);
  REQUIRE(anchor3.has_value());
  CHECK(anchor3->sequence == 0);
}

```

`test/w1rewind/rewind_trace_io_test.cpp`:

```cpp
#include <filesystem>

#include "doctest/doctest.hpp"

#include "w1rewind/rewind_test_helpers.hpp"
#include "w1rewind/trace/trace_reader.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"

namespace {

std::filesystem::path make_temp_path(const char* name) { return std::filesystem::temp_directory_path() / name; }

} // namespace

TEST_CASE("rewind trace writer and reader round trip (instructions)") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path path = make_temp_path("w1rewind_trace_io_instruction.trace");

  w1::rewind::trace_file_writer_config config;
  config.path = path.string();
  config.log = redlog::get_logger("test.w1rewind.trace");

  auto writer = w1::rewind::make_trace_file_writer(config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions | w1::rewind::trace_flag_register_deltas |
                 w1::rewind::trace_flag_memory_access | w1::rewind::trace_flag_memory_values |
                 w1::rewind::trace_flag_snapshots | w1::rewind::trace_flag_stack_snapshot;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, {"r0", "r1"});

  w1::rewind::module_record module{};
  module.id = 1;
  module.base = 0x1000;
  module.size = 0x2000;
  module.permissions = w1::rewind::module_perm::read | w1::rewind::module_perm::exec;
  module.format = w1::rewind::module_format::elf;
  module.identity = "deadbeef";
  module.identity_age = 0;
  module.flags = w1::rewind::module_record_flag_link_base_valid;
  module.link_base = 0x800;
  module.path = "/bin/test_module";

  w1::rewind::module_table_record mod_table{};
  mod_table.modules = {module};
  REQUIRE(writer->write_module_table(mod_table));

  w1::rewind::thread_start_record start{};
  start.thread_id = 1;
  start.name = "main";
  REQUIRE(writer->write_thread_start(start));

  w1::rewind::instruction_record instruction{};
  instruction.sequence = 1;
  instruction.thread_id = 1;
  instruction.address = module.base + 0x10;
  instruction.size = 4;
  REQUIRE(writer->write_instruction(instruction));

  w1::rewind::register_delta_record deltas{};
  deltas.sequence = 1;
  deltas.thread_id = 1;
  deltas.deltas = {
      w1::rewind::register_delta{0, 0x1111},
      w1::rewind::register_delta{1, 0x2222},
  };
  REQUIRE(writer->write_register_deltas(deltas));

  w1::rewind::memory_access_record mem{};
  mem.sequence = 1;
  mem.thread_id = 1;
  mem.kind = w1::rewind::memory_access_kind::write;
  mem.address = 0x2000;
  mem.size = 4;
  mem.value_known = true;
  mem.data = {0x01, 0x02, 0x03, 0x04};
  REQUIRE(writer->write_memory_access(mem));

  w1::rewind::snapshot_record snapshot{};
  snapshot.snapshot_id = 7;
  snapshot.sequence = 1;
  snapshot.thread_id = 1;
  snapshot.registers = {
      w1::rewind::register_delta{0, 0xAAAA},
      w1::rewind::register_delta{1, 0xBBBB},
  };
  w1::rewind::stack_segment stack_segment{};
  stack_segment.base = 0x3000;
  stack_segment.size = 2;
  stack_segment.bytes = {0x10, 0x20};
  snapshot.stack_segments.push_back(std::move(stack_segment));
  snapshot.reason = "interval";
  REQUIRE(writer->write_snapshot(snapshot));

  w1::rewind::thread_end_record end{};
  end.thread_id = 1;
  REQUIRE(writer->write_thread_end(end));

  writer->flush();
  writer->close();

  w1::rewind::trace_reader reader(path.string());
  REQUIRE(reader.open());
  CHECK(reader.header().version == w1::rewind::k_trace_version);
  CHECK(reader.header().arch == arch);
  CHECK(reader.header().compression == w1::rewind::trace_compression::none);
  CHECK(reader.header().chunk_size == w1::rewind::k_trace_chunk_bytes);
  CHECK((reader.header().flags & w1::rewind::trace_flag_instructions) != 0);
  CHECK((reader.header().flags & w1::rewind::trace_flag_blocks) == 0);

  std::vector<w1::rewind::trace_record> records;
  w1::rewind::trace_record record;
  while (reader.read_next(record)) {
    records.push_back(record);
  }
  CHECK(reader.error().empty());
  REQUIRE(records.size() == 10);

  CHECK(std::holds_alternative<w1::rewind::target_info_record>(records[0]));
  CHECK(std::holds_alternative<w1::rewind::target_environment_record>(records[1]));
  CHECK(std::holds_alternative<w1::rewind::register_spec_record>(records[2]));
  CHECK(std::holds_alternative<w1::rewind::module_table_record>(records[3]));
  const auto& modules = std::get<w1::rewind::module_table_record>(records[3]).modules;
  REQUIRE(modules.size() == 1);
  CHECK(modules[0].format == w1::rewind::module_format::elf);
  CHECK(modules[0].identity == "deadbeef");
  CHECK(modules[0].identity_age == 0);
  CHECK(modules[0].flags == w1::rewind::module_record_flag_link_base_valid);
  CHECK(modules[0].link_base == 0x800);
  CHECK(std::holds_alternative<w1::rewind::thread_start_record>(records[4]));
  CHECK(std::holds_alternative<w1::rewind::instruction_record>(records[5]));
  CHECK(std::holds_alternative<w1::rewind::register_delta_record>(records[6]));
  CHECK(std::holds_alternative<w1::rewind::memory_access_record>(records[7]));
  CHECK(std::holds_alternative<w1::rewind::snapshot_record>(records[8]));
  CHECK(std::holds_alternative<w1::rewind::thread_end_record>(records[9]));

  reader.close();
  fs::remove(path);
}

#if defined(W1_REWIND_HAVE_ZSTD)
TEST_CASE("rewind trace writer and reader round trip (compressed blocks)") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path path = make_temp_path("w1rewind_trace_io_compressed_block.trace");

  w1::rewind::trace_file_writer_config config;
  config.path = path.string();
  config.log = redlog::get_logger("test.w1rewind.trace");
  config.compression = w1::rewind::trace_compression::zstd;

  auto writer = w1::rewind::make_trace_file_writer(config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_blocks;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, {"r0"});

  w1::rewind::module_record module{};
  module.id = 1;
  module.base = 0x1000;
  module.size = 0x2000;
  module.permissions = w1::rewind::module_perm::read | w1::rewind::module_perm::exec;
  module.path = "/bin/test_module";

  w1::rewind::module_table_record mod_table{};
  mod_table.modules = {module};
  REQUIRE(writer->write_module_table(mod_table));

  w1::rewind::thread_start_record start{};
  start.thread_id = 1;
  start.name = "main";
  REQUIRE(writer->write_thread_start(start));

  w1::rewind::block_definition_record block_def{};
  block_def.block_id = 10;
  block_def.address = module.base + 0x80;
  block_def.size = 12;
  REQUIRE(writer->write_block_definition(block_def));

  w1::rewind::block_exec_record block_exec{};
  block_exec.sequence = 1;
  block_exec.thread_id = 1;
  block_exec.block_id = 10;
  REQUIRE(writer->write_block_exec(block_exec));

  w1::rewind::thread_end_record end{};
  end.thread_id = 1;
  REQUIRE(writer->write_thread_end(end));

  writer->flush();
  writer->close();

  w1::rewind::trace_reader reader(path.string());
  REQUIRE(reader.open());
  CHECK(reader.header().version == w1::rewind::k_trace_version);
  CHECK(reader.header().compression == w1::rewind::trace_compression::zstd);
  CHECK((reader.header().flags & w1::rewind::trace_flag_blocks) != 0);

  std::vector<w1::rewind::trace_record> records;
  w1::rewind::trace_record record;
  while (reader.read_next(record)) {
    records.push_back(record);
  }
  CHECK(reader.error().empty());
  REQUIRE(records.size() == 8);

  CHECK(std::holds_alternative<w1::rewind::target_info_record>(records[0]));
  CHECK(std::holds_alternative<w1::rewind::target_environment_record>(records[1]));
  CHECK(std::holds_alternative<w1::rewind::register_spec_record>(records[2]));
  CHECK(std::holds_alternative<w1::rewind::module_table_record>(records[3]));
  CHECK(std::holds_alternative<w1::rewind::thread_start_record>(records[4]));
  CHECK(std::holds_alternative<w1::rewind::block_definition_record>(records[5]));
  CHECK(std::holds_alternative<w1::rewind::block_exec_record>(records[6]));
  CHECK(std::holds_alternative<w1::rewind::thread_end_record>(records[7]));

  reader.close();
  fs::remove(path);
}
#endif

TEST_CASE("rewind trace writer and reader round trip (blocks)") {
  namespace fs = std::filesystem;
  using namespace w1::rewind::test_helpers;

  fs::path path = make_temp_path("w1rewind_trace_io_block.trace");

  w1::rewind::trace_file_writer_config config;
  config.path = path.string();
  config.log = redlog::get_logger("test.w1rewind.trace");

  auto writer = w1::rewind::make_trace_file_writer(config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_blocks | w1::rewind::trace_flag_snapshots;
  REQUIRE(writer->write_header(header));

  write_basic_metadata(*writer, header.arch, {"r0", "r1"});

  w1::rewind::module_record module{};
  module.id = 1;
  module.base = 0x5000;
  module.size = 0x2000;
  module.permissions = w1::rewind::module_perm::read | w1::rewind::module_perm::exec;
  module.path = "/bin/test_module";

  w1::rewind::module_table_record mod_table{};
  mod_table.modules = {module};
  REQUIRE(writer->write_module_table(mod_table));

  w1::rewind::thread_start_record start{};
  start.thread_id = 1;
  start.name = "main";
  REQUIRE(writer->write_thread_start(start));

  w1::rewind::block_definition_record block_def{};
  block_def.block_id = 10;
  block_def.address = module.base + 0x100;
  block_def.size = 12;
  REQUIRE(writer->write_block_definition(block_def));

  w1::rewind::block_exec_record block_exec{};
  block_exec.sequence = 1;
  block_exec.thread_id = 1;
  block_exec.block_id = 10;
  REQUIRE(writer->write_block_exec(block_exec));

  w1::rewind::snapshot_record snapshot{};
  snapshot.snapshot_id = 3;
  snapshot.sequence = 1;
  snapshot.thread_id = 1;
  snapshot.registers = {
      w1::rewind::register_delta{0, 0xAAAA},
      w1::rewind::register_delta{1, 0xBBBB},
  };
  snapshot.stack_segments.clear();
  snapshot.reason = "interval";
  REQUIRE(writer->write_snapshot(snapshot));

  w1::rewind::thread_end_record end{};
  end.thread_id = 1;
  REQUIRE(writer->write_thread_end(end));

  writer->flush();
  writer->close();

  w1::rewind::trace_reader reader(path.string());
  REQUIRE(reader.open());
  CHECK(reader.header().version == w1::rewind::k_trace_version);
  CHECK(reader.header().compression == w1::rewind::trace_compression::none);
  CHECK(reader.header().chunk_size == w1::rewind::k_trace_chunk_bytes);
  CHECK((reader.header().flags & w1::rewind::trace_flag_blocks) != 0);
  CHECK((reader.header().flags & w1::rewind::trace_flag_instructions) == 0);

  std::vector<w1::rewind::trace_record> records;
  w1::rewind::trace_record record;
  while (reader.read_next(record)) {
    records.push_back(record);
  }
  CHECK(reader.error().empty());
  REQUIRE(records.size() == 9);

  CHECK(std::holds_alternative<w1::rewind::target_info_record>(records[0]));
  CHECK(std::holds_alternative<w1::rewind::target_environment_record>(records[1]));
  CHECK(std::holds_alternative<w1::rewind::register_spec_record>(records[2]));
  CHECK(std::holds_alternative<w1::rewind::module_table_record>(records[3]));
  CHECK(std::holds_alternative<w1::rewind::thread_start_record>(records[4]));
  CHECK(std::holds_alternative<w1::rewind::block_definition_record>(records[5]));
  CHECK(std::holds_alternative<w1::rewind::block_exec_record>(records[6]));
  CHECK(std::holds_alternative<w1::rewind::snapshot_record>(records[7]));
  CHECK(std::holds_alternative<w1::rewind::thread_end_record>(records[8]));

  reader.close();
  fs::remove(path);
}

TEST_CASE("rewind trace writer and reader round trip (register bytes)") {
  namespace fs = std::filesystem;

  fs::path path = make_temp_path("w1rewind_trace_io_regbytes.trace");

  w1::rewind::trace_file_writer_config config;
  config.path = path.string();
  config.log = redlog::get_logger("test.w1rewind.trace");

  auto writer = w1::rewind::make_trace_file_writer(config);
  REQUIRE(writer);
  REQUIRE(writer->open());

  using namespace w1::rewind::test_helpers;
  auto arch = parse_arch_or_fail("x86_64");
  w1::rewind::trace_header header{};
  header.arch = arch;
  header.flags = w1::rewind::trace_flag_instructions | w1::rewind::trace_flag_register_deltas;
  REQUIRE(writer->write_header(header));

  auto target = make_target_info();
  REQUIRE(writer->write_target_info(target));
  auto environment = make_target_environment();
  REQUIRE(writer->write_target_environment(environment));

  w1::rewind::register_spec_record specs{};
  specs.registers = {
      w1::rewind::register_spec{
          0, "r0", 64, 0, "r0", w1::rewind::register_class::gpr, w1::rewind::register_value_kind::u64
      },
      w1::rewind::register_spec{
          1, "v0", 128, 0, "v0", w1::rewind::register_class::simd, w1::rewind::register_value_kind::bytes
      },
  };
  REQUIRE(writer->write_register_spec(specs));

  w1::rewind::register_bytes_record bytes{};
  bytes.sequence = 0;
  bytes.thread_id = 1;
  bytes.entries = {w1::rewind::register_bytes_entry{1, 0, 16}};
  bytes.data = {
      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  };
  REQUIRE(writer->write_register_bytes(bytes));

  writer->flush();
  writer->close();

  w1::rewind::trace_reader reader(path.string());
  REQUIRE(reader.open());

  bool saw_bytes = false;
  w1::rewind::trace_record record;
  while (reader.read_next(record)) {
    if (std::holds_alternative<w1::rewind::register_bytes_record>(record)) {
      const auto& decoded = std::get<w1::rewind::register_bytes_record>(record);
      REQUIRE(decoded.entries.size() == 1);
      CHECK(decoded.entries[0].reg_id == 1);
      CHECK(decoded.entries[0].size == 16);
      CHECK(decoded.data.size() == 16);
      CHECK(decoded.data[0] == 0x00);
      CHECK(decoded.data[15] == 0x0f);
      saw_bytes = true;
    }
  }
  CHECK(reader.error().empty());
  CHECK(saw_bytes);

  reader.close();
  fs::remove(path);
}

```

`test/w1runtime/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${W1_SOURCE_DIR}/cmake/TestConfig.cmake)

set(W1RUNTIME_TEST_SOURCES
    ${W1_SOURCE_DIR}/test/common/test_main.cpp
    memory_reader_test.cpp
    module_catalog_test.cpp
)

w1_add_doctest_suite(w1runtime_unit_tests
    SOURCES ${W1RUNTIME_TEST_SOURCES}
    INCLUDE_DIRS
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/third_party
    LIBS
        w1runtime
    OUTPUT_SUBDIR w1runtime
)

```

`test/w1runtime/memory_reader_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include <array>
#include <cstdint>

#include "w1runtime/module_catalog.hpp"
#include "w1runtime/memory_reader.hpp"

TEST_CASE("memory_reader reads bytes") {
  std::array<uint8_t, 4> buffer = {1, 2, 3, 4};
  w1::runtime::module_catalog modules;
  w1::util::memory_reader reader(nullptr, modules);

  auto result = reader.read_bytes(reinterpret_cast<uint64_t>(buffer.data()), buffer.size());
  REQUIRE(result.has_value());
  CHECK(result->size() == buffer.size());
  CHECK((*result)[0] == 1);
  CHECK((*result)[3] == 4);
}

TEST_CASE("memory_reader reads string") {
  const char message[] = "hello";
  w1::runtime::module_catalog modules;
  w1::util::memory_reader reader(nullptr, modules);

  auto result = reader.read_string(reinterpret_cast<uint64_t>(message), 16);
  REQUIRE(result.has_value());
  CHECK(*result == "hello");
}

TEST_CASE("memory_reader rejects null address") {
  w1::runtime::module_catalog modules;
  w1::util::memory_reader reader(nullptr, modules);

  auto bytes = reader.read_bytes(0, 4);
  CHECK(bytes.has_value() == false);

  auto text = reader.read_string(0, 4);
  CHECK(text.has_value() == false);
}

```

`test/w1runtime/module_catalog_test.cpp`:

```cpp
#include "doctest/doctest.hpp"

#include "w1runtime/module_catalog.hpp"

namespace {

void module_catalog_marker() {}
int module_catalog_data_marker = 0;

} // namespace

TEST_CASE("module_catalog finds current module") {
  w1::runtime::module_catalog catalog;
  catalog.refresh();

  auto modules = catalog.list_modules();
  if (modules.empty()) {
    WARN("module_catalog returned no modules; module scanning may be blocked");
    return;
  }

  auto address = reinterpret_cast<uint64_t>(&module_catalog_marker);
  auto info = catalog.find_containing(address);
  REQUIRE(info != nullptr);
  CHECK(info->full_range.start <= address);
  CHECK(address < info->full_range.end);

  bool in_mapped_range = false;
  for (const auto& range : info->mapped_ranges) {
    if (range.start <= address && address < range.end) {
      in_mapped_range = true;
      break;
    }
  }
  CHECK(in_mapped_range == true);
}

TEST_CASE("module_catalog resolves data address to module") {
  w1::runtime::module_catalog catalog;
  catalog.refresh();

  auto modules = catalog.list_modules();
  if (modules.empty()) {
    WARN("module_catalog returned no modules; module scanning may be blocked");
    return;
  }

  auto address = reinterpret_cast<uint64_t>(&module_catalog_data_marker);
  auto info = catalog.find_containing(address);
  REQUIRE(info != nullptr);
  CHECK(info->full_range.start <= address);
  CHECK(address < info->full_range.end);
}

```

`tests/CMakeLists.txt`:

```txt
# integration tests and harness binaries
add_subdirectory(libraries)
add_subdirectory(harness)

```

`tests/cmake_embed/w1rewind/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

project(embed_w1rewind LANGUAGES CXX)

set(W1TN3SS_ROOT "${CMAKE_CURRENT_LIST_DIR}/../../..")
get_filename_component(W1TN3SS_ROOT "${W1TN3SS_ROOT}" REALPATH)

set(W1_BUILD_ALL OFF CACHE BOOL "Build all w1tn3ss components" FORCE)
set(W1_BUILD_W1REWIND ON CACHE BOOL "Build w1rewind component" FORCE)

add_subdirectory("${W1TN3SS_ROOT}" w1tn3ss_build)

add_executable(embed_w1rewind main.cpp)
set_property(TARGET embed_w1rewind PROPERTY CXX_STANDARD 20)
set_property(TARGET embed_w1rewind PROPERTY CXX_STANDARD_REQUIRED ON)

target_link_libraries(embed_w1rewind PRIVATE w1::rewind::replay)

```

`tests/cmake_embed/w1rewind/main.cpp`:

```cpp
#include "w1rewind/format/trace_format.hpp"

int main() { return 0; }

```

`tests/harness/CMakeLists.txt`:

```txt
include(${W1_SOURCE_DIR}/cmake/TestConfig.cmake)

w1_add_harness_test(test_w1xfer
    SOURCES test_w1xfer.cpp
    INCLUDE_DIRS
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/tracers/w1xfer
    LIBS w1xfer_static
    OUTPUT_SUBDIR harness
)

if(WITNESS_SCRIPT AND TARGET w1script_static)
    w1_add_harness_test(test_w1script
        SOURCES test_w1script.cpp
        INCLUDE_DIRS
            ${W1_SOURCE_DIR}/src
            ${W1_SOURCE_DIR}/src/tracers/w1script
        LIBS w1script_static
        OUTPUT_SUBDIR harness
    )
endif()

w1_add_harness_test(test_gadget_executor
    SOURCES test_gadget_executor.cpp
    INCLUDE_DIRS ${W1_SOURCE_DIR}/src
    LIBS w1gadget
    OUTPUT_SUBDIR harness
)

w1_add_harness_test(test_rewind_format
    SOURCES test_rewind_format.cpp
    INCLUDE_DIRS ${W1_SOURCE_DIR}/src
    LIBS w1rewind_record w1rewind_replay
    OUTPUT_SUBDIR harness
)

w1_add_harness_test(test_monitor_demo
    SOURCES test_monitor_demo.cpp
    INCLUDE_DIRS
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/test/common
    LIBS w1monitor ${CMAKE_DL_LIBS}
    OUTPUT_SUBDIR harness
)

w1_add_harness_test(test_w1cov_multithread_demo
    SOURCES test_w1cov_multithread_demo.cpp
    INCLUDE_DIRS
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/tracers/w1cov
        ${W1_SOURCE_DIR}/test/common
    LIBS w1cov_static ${CMAKE_DL_LIBS}
    OUTPUT_SUBDIR harness
)

if(TARGET w1cov_demo_lib)
    add_dependencies(test_w1cov_multithread_demo w1cov_demo_lib)
endif()

w1_add_harness_test(test_w1cov_components
    SOURCES test_w1cov_components.cpp
    INCLUDE_DIRS
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/tracers/w1cov
    LIBS w1cov_static
    OUTPUT_SUBDIR harness
)

w1_add_harness_test(test_w1cov_single_thread
    SOURCES
        test_w1cov_single_thread.cpp
        w1cov_test_targets.cpp
    INCLUDE_DIRS
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/tracers/w1cov
    LIBS w1cov_static
    OUTPUT_SUBDIR harness
)

w1_add_harness_test(test_w1cov_module_filtering
    SOURCES test_w1cov_module_filtering.cpp
    INCLUDE_DIRS
        ${W1_SOURCE_DIR}/src
        ${W1_SOURCE_DIR}/src/tracers/w1cov
        ${W1_SOURCE_DIR}/test/common
    LIBS w1cov_static ${CMAKE_DL_LIBS}
    OUTPUT_SUBDIR harness
)

if(TARGET w1cov_demo_lib)
    add_dependencies(test_w1cov_module_filtering w1cov_demo_lib)
endif()

set_tests_properties(test_gadget_executor PROPERTIES
    LABELS "harness;unit;gadget;executor"
)

set_tests_properties(test_w1xfer PROPERTIES
    LABELS "harness;tracers;w1xfer"
)

if(TARGET test_w1script)
    set_tests_properties(test_w1script PROPERTIES
        LABELS "harness;tracers;w1script"
    )
endif()

set_tests_properties(test_rewind_format PROPERTIES
    LABELS "harness;rewind"
)

set_tests_properties(test_monitor_demo PROPERTIES
    LABELS "harness;monitor"
)

set_tests_properties(test_w1cov_components PROPERTIES
    LABELS "harness;w1cov;components"
)

set_tests_properties(test_w1cov_single_thread PROPERTIES
    LABELS "harness;w1cov;single_thread"
)

set_tests_properties(test_w1cov_multithread_demo PROPERTIES
    LABELS "harness;w1cov;multithread"
)

set_tests_properties(test_w1cov_module_filtering PROPERTIES
    LABELS "harness;w1cov;module_filtering"
)

```

`tests/harness/test_gadget_executor.cpp`:

```cpp
/**
 * Comprehensive test suite for w1gadget gadget_executor
 *
 * This test validates the gadget execution capability that allows
 * calling arbitrary code from within QBDI VM callbacks.
 */

#include "w1gadget/gadget_executor.hpp"
#include <QBDI.h>
#include <cassert>
#include <chrono>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>

// === Test Infrastructure ===

class TestHarness {
private:
  int tests_run = 0;
  int tests_passed = 0;
  [[maybe_unused]] bool verbose = false;

public:
  TestHarness(bool verbose = false) : verbose(verbose) {}

  ~TestHarness() {
    printf("\n=== Test Summary ===\n");
    printf("Total tests: %d\n", tests_run);
    printf("Passed: %d\n", tests_passed);
    printf("Failed: %d\n", tests_run - tests_passed);
    if (tests_run > 0) {
      printf("Success rate: %.1f%%\n", 100.0 * tests_passed / tests_run);
    }
  }

  void test(const char* name, bool condition, const char* error = nullptr) {
    tests_run++;
    if (condition) {
      tests_passed++;
      printf("  ✓ %s\n", name);
    } else {
      printf("  ✗ %s", name);
      if (error) {
        printf(" - %s", error);
      }
      printf("\n");
    }
  }

  bool all_passed() const { return tests_run > 0 && tests_run == tests_passed; }
};

// === Test Gadgets ===

// Global state for testing side effects
struct TestState {
  int counter;
  char buffer[256];
  double sum;
  bool flag;
} g_state = {0, "", 0.0, false};

extern "C" {
// Basic void function
void gadget_increment() { g_state.counter++; }

// Function with return value
int gadget_add(int a, int b) { return a + b; }

// Function with many arguments (tests calling convention)
int gadget_sum8(int a, int b, int c, int d, int e, int f, int g, int h) { return a + b + c + d + e + f + g + h; }

// String operations
int gadget_strlen(const char* str) { return static_cast<int>(strlen(str)); }

void gadget_strcpy(const char* src) {
  if (src) {
    strcpy(g_state.buffer, src);
  }
}

// Floating point
double gadget_multiply_double(double x, double y) {
  g_state.sum = x * y;
  return g_state.sum;
}

// Complex function that uses stack - prevent inlining
QBDI_NOINLINE int gadget_fibonacci(int n) {
  if (n <= 1) {
    return n;
  }
  return gadget_fibonacci(n - 1) + gadget_fibonacci(n - 2);
}

// Helper function for testing calls - prevent inlining
QBDI_NOINLINE int gadget_add_helper(int a, int b) { return a + b; }

// Function that calls another function - prevent inlining
QBDI_NOINLINE int gadget_call_helper(int x, int y) { return gadget_add_helper(x, y) + 1; }

// Function that modifies multiple globals
void gadget_complex_state(int value, const char* str, bool flag) {
  g_state.counter = value;
  strcpy(g_state.buffer, str);
  g_state.flag = flag;
}

// Raw execution test function - make it longer to avoid hitting ret
QBDI_NOINLINE void gadget_raw_manip() {
  // Make this function longer so we don't hit the ret before stop_addr
  volatile int* ptr = &g_state.counter;
  *ptr = 0x1234;

  // Add more operations to make the function longer
  for (int i = 0; i < 10; ++i) {
    *ptr += 1;
  }

  // More operations to ensure we have enough instructions
  g_state.sum = 3.14159;
  g_state.flag = true;

  // Even more to be safe
  for (int j = 0; j < 5; ++j) {
    g_state.buffer[j] = 'A' + j;
  }
}
}

// Target function for VM instrumentation
void target_function(int iterations) {
  for (int i = 0; i < iterations; i++) {
#ifdef _MSC_VER
    __nop();
#else
    asm volatile("nop");
#endif
  }
}

// === Test Cases ===

void test_basic_functionality() {
  printf("\n[1] Testing Basic Functionality\n");
  TestHarness harness;

  // Create parent VM
  QBDI::VM vm("", {});
  uint8_t* stack = nullptr;
  QBDI::allocateVirtualStack(vm.getGPRState(), 0x100000, &stack);

  printf("  Parent VM created: %p\n", &vm);
  printf("  Parent VM stack: %p (size: 0x100000)\n", stack);
  printf("  Parent VM SP: 0x%llx\n", static_cast<unsigned long long>(QBDI_GPR_GET(vm.getGPRState(), QBDI::REG_SP)));

  w1::gadget::gadget_executor executor(&vm);

  // Reset state
  g_state = {0, "", 0.0, false};

  // Test void function
  printf("\n  Testing void function (gadget_increment):\n");
  printf("    Gadget address: %p\n", gadget_increment);
  printf("    State before: counter=%d\n", g_state.counter);
  executor.gadget_call<void>(reinterpret_cast<QBDI::rword>(gadget_increment));
  printf("    State after: counter=%d\n", g_state.counter);
  harness.test("void function execution", g_state.counter == 1);

  // Test function with return
  printf("\n  Testing function with return (gadget_add):\n");
  printf("    Gadget address: %p\n", gadget_add);
  printf("    Arguments: 10, 20\n");
  int result = executor.gadget_call<int>(reinterpret_cast<QBDI::rword>(gadget_add), {10, 20});
  printf("    Return value: %d\n", result);
  harness.test("return value capture", result == 30);

  // Test multiple arguments
  result = executor.gadget_call<int>(reinterpret_cast<QBDI::rword>(gadget_sum8), {1, 2, 3, 4, 5, 6, 7, 8});
  harness.test("8 argument passing", result == 36);

  // Test recursive function base cases
  printf("\n  Testing recursive function base cases:\n");
  result = executor.gadget_call<int>(reinterpret_cast<QBDI::rword>(gadget_fibonacci), {0});
  printf("    fibonacci(0) = %d\n", result);
  harness.test("fibonacci(0)", result == 0);

  result = executor.gadget_call<int>(reinterpret_cast<QBDI::rword>(gadget_fibonacci), {1});
  printf("    fibonacci(1) = %d\n", result);
  harness.test("fibonacci(1)", result == 1);

  // Test function call (non-recursive)
  printf("\n  Testing function that calls another function:\n");
  printf("    gadget_call_helper address: %p\n", gadget_call_helper);
  printf("    gadget_add_helper address: %p\n", gadget_add_helper);
  result = executor.gadget_call<int>(reinterpret_cast<QBDI::rword>(gadget_call_helper), {10, 20});
  printf(
      "    gadget_call_helper(10, 20) = %d (should be add_helper(10,20) + 1 "
      "= 31)\n",
      result
  );
  harness.test("function call", result == 31);

  // Test recursive function complex case
  printf("\n  Testing complex recursive function:\n");
  result = executor.gadget_call<int>(reinterpret_cast<QBDI::rword>(gadget_fibonacci), {5});
  printf("    fibonacci(5) = %d (expected: 5)\n", result);
  printf("    This tests multiple recursive calls within the sub-VM\n");
  harness.test("fibonacci(5)", result == 5);

  // Test multiple gadgets in sequence to show VM isolation
  printf("\n  Testing multiple gadgets in sequence (VM isolation):\n");
  g_state.counter = 100;
  printf("    Initial counter: %d\n", g_state.counter);

  executor.gadget_call<void>(reinterpret_cast<QBDI::rword>(gadget_increment));
  printf("    After first increment: %d\n", g_state.counter);

  executor.gadget_call<void>(reinterpret_cast<QBDI::rword>(gadget_increment));
  printf("    After second increment: %d\n", g_state.counter);

  int sum = executor.gadget_call<int>(
      reinterpret_cast<QBDI::rword>(gadget_add), {static_cast<QBDI::rword>(g_state.counter), 10}
  );
  printf("    add(%d, 10) = %d\n", g_state.counter, sum);

  harness.test("sequential gadget calls", g_state.counter == 102 && sum == 112);

  QBDI::alignedFree(stack);
}

void test_within_vm_callback() {
  printf("\n[2] Testing Execution Within VM Callbacks\n");
  TestHarness harness;

  printf("  Creating parent VM for instrumentation...\n");
  QBDI::VM vm("", {});
  uint8_t* stack = nullptr;
  QBDI::allocateVirtualStack(vm.getGPRState(), 0x100000, &stack);
  printf("  Parent VM: %p, stack: %p\n", &vm, stack);

  struct CallbackContext {
    int instruction_count;
    bool gadget_executed;
    int gadget_result;
    TestHarness* harness;
  } ctx = {0, false, 0, &harness};

  // Reset state
  g_state = {0, "", 0.0, false};

  vm.addCodeCB(
      QBDI::PREINST,
      [](QBDI::VM* vm, QBDI::GPRState* gpr, [[maybe_unused]] QBDI::FPRState* fpr, void* data) {
        auto* ctx = static_cast<CallbackContext*>(data);
        ctx->instruction_count++;

        // Execute gadgets at specific instruction counts
        if (ctx->instruction_count == 3) {
          printf(
              "\n  [Callback] Instruction #3 - executing gadgets from "
              "within VM callback:\n"
          );
          printf("    Parent VM (in callback): %p\n", vm);
          printf("    Parent VM SP: 0x%llx\n", (unsigned long long) QBDI_GPR_GET(gpr, QBDI::REG_SP));

          w1::gadget::gadget_executor executor(vm);

          // Test basic execution
          printf("    Calling gadget_increment from callback...\n");
          executor.gadget_call<void>(reinterpret_cast<QBDI::rword>(gadget_increment));
          printf("    Global counter after gadget: %d\n", g_state.counter);
          ctx->harness->test("callback: increment executed", g_state.counter == 1);

          // Test with return value
          printf("    Calling gadget_add(50, 50) from callback...\n");
          ctx->gadget_result = executor.gadget_call<int>(reinterpret_cast<QBDI::rword>(gadget_add), {50, 50});
          printf("    Result: %d\n", ctx->gadget_result);
          ctx->gadget_executed = true;
        }

        if (ctx->instruction_count == 5) {
          printf(
              "\n  [Callback] Instruction #5 - testing complex state "
              "modification:\n"
          );
          w1::gadget::gadget_executor executor(vm);

          // Test complex state modification
          printf(
              "    Calling gadget_complex_state(42, \"from callback\", "
              "true)...\n"
          );
          executor.gadget_call<void>(
              reinterpret_cast<QBDI::rword>(gadget_complex_state),
              {42, reinterpret_cast<QBDI::rword>("from callback"), 1}
          );
          printf(
              "    State after: counter=%d, buffer=\"%s\", flag=%d\n", g_state.counter, g_state.buffer, g_state.flag
          );
        }

        return QBDI::CONTINUE;
      },
      &ctx
  );

  // Run instrumented function
  vm.addInstrumentedModuleFromAddr(reinterpret_cast<QBDI::rword>(target_function));
  vm.call(nullptr, reinterpret_cast<QBDI::rword>(target_function), {10});

  harness.test("gadget executed in callback", ctx.gadget_executed);
  harness.test("callback: return value", ctx.gadget_result == 100);
  harness.test("callback: complex state.counter", g_state.counter == 42);
  harness.test("callback: complex state.buffer", strcmp(g_state.buffer, "from callback") == 0);
  harness.test("callback: complex state.flag", g_state.flag == true);

  QBDI::alignedFree(stack);
}

void test_state_management() {
  printf("\n[3] Testing State Management\n");
  TestHarness harness;

  // Create parent VM with stack like other working tests
  QBDI::VM vm("", {});
  uint8_t* stack = nullptr;
  QBDI::allocateVirtualStack(vm.getGPRState(), 0x100000, &stack);

  w1::gadget::gadget_executor executor(&vm);

  // Test gadget_call (clean function call api)
  printf("  Testing gadget_call...\n");
  int call_result = executor.gadget_call<int>(reinterpret_cast<QBDI::rword>(gadget_add), {15, 25});
  harness.test("gadget_call success", call_result == 40);

  // Test gadget_run (clean raw execution api)
  printf("  Testing gadget_run...\n");
  g_state.counter = 0; // reset global state

  QBDI::rword start_addr = reinterpret_cast<QBDI::rword>(gadget_raw_manip);
  QBDI::rword end_addr = start_addr + 32; // smaller range to avoid hitting ret

  printf("  raw gadget: 0x%llx - 0x%llx\n", (unsigned long long) start_addr, (unsigned long long) end_addr);

  // use null state to let gadget_run use parent vm state
  auto raw_result = executor.gadget_run(start_addr, end_addr);

  if (!raw_result.success) {
    printf("  gadget_run failed: %s\n", raw_result.error.c_str());
  }

  harness.test("gadget_run success", raw_result.success);

  // raw execution should start, but stop before the loop completes
  const int base_value = 0x1234;
  const int loop_complete_value = base_value + 10;
  harness.test("gadget_run modifies global state", g_state.counter >= base_value);
  harness.test("gadget_run respects stop address", g_state.counter < loop_complete_value);

  printf("  counter after raw execution: %d\n", g_state.counter);
  printf("  raw execution correctly stopped at specified address range\n");

  QBDI::alignedFree(stack);
}

void test_error_handling() {
  printf("\n[4] Testing Error Handling\n");
  TestHarness harness;

  QBDI::VM vm("", {});
  w1::gadget::gadget_executor executor(&vm);

  // Test invalid address - gadget_call should return default value
  int invalid_result = executor.gadget_call<int>(0x0, {});
  harness.test("null address returns default", invalid_result == 0);

  // Test unmapped address
  invalid_result = executor.gadget_call<int>(0xdeadbeef, {});
  harness.test("invalid address returns default", invalid_result == 0);
}

void test_performance() {
  printf("\n[5] Testing Performance\n");
  TestHarness harness;

  QBDI::VM vm("", {});
  w1::gadget::gadget_executor executor(&vm);

  const int iterations = 1000;

  // Time direct calls
  auto start = std::chrono::high_resolution_clock::now();
  int sum = 0;
  for (int i = 0; i < iterations; i++) {
    sum += gadget_add(i, i);
  }
  auto direct_time = std::chrono::high_resolution_clock::now() - start;
  static_cast<void>(sum);

  // Time gadget calls
  start = std::chrono::high_resolution_clock::now();
  sum = 0;
  for (int i = 0; i < iterations; i++) {
    sum += executor.gadget_call<int>(
        reinterpret_cast<QBDI::rword>(gadget_add), {static_cast<QBDI::rword>(i), static_cast<QBDI::rword>(i)}
    );
  }
  auto gadget_time = std::chrono::high_resolution_clock::now() - start;
  static_cast<void>(sum);

  auto direct_us = std::chrono::duration_cast<std::chrono::microseconds>(direct_time).count();
  auto gadget_us = std::chrono::duration_cast<std::chrono::microseconds>(gadget_time).count();

  printf("  Direct calls: %lld µs (%.2f µs/call)\n", direct_us, direct_us / (double) iterations);
  printf("  Gadget calls: %lld µs (%.2f µs/call)\n", gadget_us, gadget_us / (double) iterations);
  printf("  Overhead: %.1fx\n", gadget_us / (double) direct_us);

  harness.test("performance test completed", true);
}

void test_nested_execution() {
  printf("\n[6] Testing Nested Gadget Execution\n");
  TestHarness harness;

  // This tests the key fix - executing gadgets from within VM callbacks
  // should not cause bus errors due to stack switching

  QBDI::VM outer_vm("", {});
  uint8_t* outer_stack = nullptr;
  QBDI::allocateVirtualStack(outer_vm.getGPRState(), 0x100000, &outer_stack);

  struct NestedContext {
    bool outer_executed;
    bool inner_executed;
    int inner_result;
  } ctx = {false, false, 0};

  outer_vm.addCodeCB(
      QBDI::PREINST,
      []([[maybe_unused]] QBDI::VM* vm, [[maybe_unused]] QBDI::GPRState* gpr, [[maybe_unused]] QBDI::FPRState* fpr,
         void* data) {
        static int count = 0;
        if (++count == 2) {
          auto* ctx = static_cast<NestedContext*>(data);
          ctx->outer_executed = true;

          // Create inner VM and execute gadget
          QBDI::VM inner_vm("", {});
          uint8_t* inner_stack = nullptr;
          QBDI::allocateVirtualStack(inner_vm.getGPRState(), 0x100000, &inner_stack);

          inner_vm.addCodeCB(
              QBDI::PREINST,
              [](QBDI::VM* vm, [[maybe_unused]] QBDI::GPRState* gpr, [[maybe_unused]] QBDI::FPRState* fpr, void* data) {
                static int inner_count = 0;
                if (++inner_count == 2) {
                  auto* ctx = static_cast<NestedContext*>(data);

                  // Execute gadget from within nested VM callback
                  w1::gadget::gadget_executor executor(vm);
                  ctx->inner_result = executor.gadget_call<int>(reinterpret_cast<QBDI::rword>(gadget_add), {123, 456});
                  ctx->inner_executed = true;
                }
                return QBDI::CONTINUE;
              },
              ctx
          );

          inner_vm.addInstrumentedModuleFromAddr(reinterpret_cast<QBDI::rword>(target_function));
          inner_vm.call(nullptr, reinterpret_cast<QBDI::rword>(target_function), {5});

          QBDI::alignedFree(inner_stack);
        }
        return QBDI::CONTINUE;
      },
      &ctx
  );

  outer_vm.addInstrumentedModuleFromAddr(reinterpret_cast<QBDI::rword>(target_function));
  outer_vm.call(nullptr, reinterpret_cast<QBDI::rword>(target_function), {5});

  harness.test("outer VM callback executed", ctx.outer_executed);
  harness.test("inner VM callback executed", ctx.inner_executed);
  harness.test("nested gadget result", ctx.inner_result == 579);
  harness.test("no bus error in nested execution", true);

  QBDI::alignedFree(outer_stack);
}

// === Main ===

int main(int argc, char* argv[]) {
  printf("=== W1TN3SS Gadget Executor Test Suite ===\n");
  fflush(stdout);
  printf("Testing gadget execution capability for QBDI\n");
  fflush(stdout);

  bool verbose = argc > 1 && strcmp(argv[1], "-v") == 0;
  if (verbose) {
    printf("Verbose mode enabled\n");
  }

  // Run core test suites
  test_basic_functionality();
  test_within_vm_callback();
  test_state_management();
  // test_error_handling();
  // test_performance();
  // test_nested_execution();

  printf("\n=== Test Complete ===\n");
  return 0;
}

```

`tests/harness/test_monitor_demo.cpp`:

```cpp
#if defined(__linux__) && !defined(_GNU_SOURCE)
#define _GNU_SOURCE
#endif

#include <atomic>
#include <chrono>
#include <cstdint>
#include <cstdlib>
#include <iostream>
#include <string>
#include <thread>

#if defined(_WIN32)
#include <windows.h>
#elif defined(__APPLE__)
#include <dlfcn.h>
#include <pthread.h>
#else
#include <dlfcn.h>
#include <pthread.h>
#include <sys/syscall.h>
#include <unistd.h>
#endif

#include "w1monitor/monitor_factory.hpp"
#include "w1monitor/module_monitor.hpp"
#include "w1monitor/thread_monitor.hpp"

#include "test_paths.hpp"

namespace {

template <typename Event, typename Monitor, typename Predicate>
bool wait_for_event(Monitor& monitor, Event& out, Predicate predicate, std::chrono::milliseconds timeout) {
  const auto deadline = std::chrono::steady_clock::now() + timeout;
  while (std::chrono::steady_clock::now() < deadline) {
    while (monitor.poll(out)) {
      if (predicate(out)) {
        return true;
      }
    }
    std::this_thread::sleep_for(std::chrono::milliseconds(5));
  }
  return false;
}

} // namespace

int main(int argc, char** argv) {
  auto module_monitor = w1::monitor::make_module_monitor();
  auto thread_monitor = w1::monitor::make_thread_monitor();

  if (!module_monitor || !thread_monitor) {
    std::cerr << "failed to create w1monitor backends\n";
    return 1;
  }

  module_monitor->start();
  thread_monitor->start();

#if defined(_WIN32)
  constexpr const char* kLibName = "w1h00k_interpose_lib.dll";
#elif defined(__APPLE__)
  constexpr const char* kLibName = "w1h00k_interpose_lib.dylib";
#else
  constexpr const char* kLibName = "w1h00k_interpose_lib.so";
#endif

  std::string lib_path;
  if (argc > 1 && argv[1] != nullptr && argv[1][0] != '\0') {
    lib_path = argv[1];
  } else if (const char* env_path = std::getenv("W1MONITOR_DEMO_LIB")) {
    lib_path = env_path;
  } else {
    lib_path = w1::test_paths::test_library_path(kLibName);
  }

  int failures = 0;

#if defined(_WIN32)
  HMODULE lib_handle = LoadLibraryA(lib_path.c_str());
  if (!lib_handle) {
    std::cerr << "failed to load library: " << lib_path << "\n";
    failures++;
  } else {
    w1::monitor::module_event event{};
    const bool loaded = wait_for_event(
        *module_monitor, event,
        [&](const w1::monitor::module_event& e) {
          return e.type == w1::monitor::module_event::kind::loaded && !e.path.empty() &&
                 e.path.find(kLibName) != std::string::npos;
        },
        std::chrono::milliseconds(1000)
    );
    if (loaded) {
      std::cout << "module loaded: " << event.path << "\n";
    } else {
      std::cerr << "module load not observed\n";
      failures++;
    }
  }
#else
  void* lib_handle = dlopen(lib_path.c_str(), RTLD_NOW);
  if (!lib_handle) {
    std::cerr << "failed to load library: " << lib_path << "\n";
    failures++;
  } else {
    w1::monitor::module_event event{};
    const bool loaded = wait_for_event(
        *module_monitor, event,
        [&](const w1::monitor::module_event& e) {
          return e.type == w1::monitor::module_event::kind::loaded && !e.path.empty() &&
                 e.path.find(kLibName) != std::string::npos;
        },
        std::chrono::milliseconds(1000)
    );
    if (loaded) {
      std::cout << "module loaded: " << event.path << "\n";
    } else {
      std::cerr << "module load not observed\n";
      failures++;
    }
  }
#endif

  std::atomic<uint64_t> worker_tid{0};

#if defined(_WIN32)
  auto thread_fn = [](LPVOID param) -> DWORD {
    auto* tid_ptr = static_cast<std::atomic<uint64_t>*>(param);
    tid_ptr->store(static_cast<uint64_t>(GetCurrentThreadId()), std::memory_order_release);
    HMODULE kernel32 = GetModuleHandleW(L"kernel32.dll");
    if (kernel32) {
      auto set_desc =
          reinterpret_cast<HRESULT(WINAPI*)(HANDLE, PCWSTR)>(GetProcAddress(kernel32, "SetThreadDescription"));
      if (set_desc) {
        set_desc(GetCurrentThread(), L"w1mon_worker");
      }
    }
    Sleep(50);
    return 0;
  };

  HANDLE thread = CreateThread(nullptr, 0, thread_fn, &worker_tid, 0, nullptr);
  if (!thread) {
    std::cerr << "failed to create thread\n";
    failures++;
  }
#else
  std::thread worker([&]() {
#if defined(__APPLE__)
    worker_tid.store(static_cast<uint64_t>(pthread_mach_thread_np(pthread_self())), std::memory_order_release);
    pthread_setname_np("w1mon_worker");
#else
    worker_tid.store(static_cast<uint64_t>(syscall(SYS_gettid)), std::memory_order_release);
    pthread_setname_np(pthread_self(), "w1mon_worker");
#endif
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
  });
#endif

  bool thread_created = true;
#if defined(_WIN32)
  thread_created = (thread != nullptr);
#endif

  if (thread_created) {
    while (worker_tid.load(std::memory_order_acquire) == 0) {
      std::this_thread::yield();
    }

    const uint64_t tid = worker_tid.load(std::memory_order_acquire);
    w1::monitor::thread_event thread_event{};

    const bool saw_started = wait_for_event(
        *thread_monitor, thread_event,
        [&](const w1::monitor::thread_event& e) {
          return e.type == w1::monitor::thread_event::kind::started && e.tid == tid;
        },
        std::chrono::milliseconds(1000)
    );
    if (saw_started) {
      std::cout << "thread started: " << thread_event.tid << "\n";
    } else {
      std::cerr << "thread start not observed\n";
      failures++;
    }

    bool expect_rename = true;
#if defined(_WIN32)
    HMODULE kernel32 = GetModuleHandleW(L"kernel32.dll");
    expect_rename = kernel32 && GetProcAddress(kernel32, "SetThreadDescription") != nullptr;
#endif

    if (expect_rename) {
      const bool saw_rename = wait_for_event(
          *thread_monitor, thread_event,
          [&](const w1::monitor::thread_event& e) {
            return e.type == w1::monitor::thread_event::kind::renamed && e.tid == tid && e.name == "w1mon_worker";
          },
          std::chrono::milliseconds(1000)
      );
      if (saw_rename) {
        std::cout << "thread renamed: " << thread_event.name << "\n";
      } else {
        std::cerr << "thread rename not observed\n";
        failures++;
      }
    } else {
      std::cout << "thread rename not supported\n";
    }

#if defined(_WIN32)
    WaitForSingleObject(thread, INFINITE);
    CloseHandle(thread);
#else
    worker.join();
#endif

    const bool saw_stopped = wait_for_event(
        *thread_monitor, thread_event,
        [&](const w1::monitor::thread_event& e) {
          return e.type == w1::monitor::thread_event::kind::stopped && e.tid == tid;
        },
        std::chrono::milliseconds(1000)
    );
    if (saw_stopped) {
      std::cout << "thread stopped: " << thread_event.tid << "\n";
    } else {
      std::cerr << "thread stop not observed\n";
      failures++;
    }
  } else {
    std::cerr << "skipping thread event checks\n";
  }

#if defined(_WIN32)
  if (lib_handle) {
    FreeLibrary(lib_handle);
    w1::monitor::module_event event{};
    const bool unloaded = wait_for_event(
        *module_monitor, event,
        [&](const w1::monitor::module_event& e) {
          return e.type == w1::monitor::module_event::kind::unloaded && !e.path.empty() &&
                 e.path.find(kLibName) != std::string::npos;
        },
        std::chrono::milliseconds(1000)
    );
    if (unloaded) {
      std::cout << "module unloaded: " << event.path << "\n";
    } else {
      std::cerr << "module unload not observed\n";
      failures++;
    }
  }
#else
  if (lib_handle) {
    dlclose(lib_handle);
    w1::monitor::module_event event{};
    const bool unloaded = wait_for_event(
        *module_monitor, event,
        [&](const w1::monitor::module_event& e) {
          return e.type == w1::monitor::module_event::kind::unloaded && !e.path.empty() &&
                 e.path.find(kLibName) != std::string::npos;
        },
        std::chrono::milliseconds(1000)
    );
    if (unloaded) {
      std::cout << "module unloaded: " << event.path << "\n";
    } else {
      std::cerr << "module unload not observed\n";
      failures++;
    }
  }
#endif

  thread_monitor->stop();
  module_monitor->stop();

  if (failures != 0) {
    std::cerr << "monitor demo failed (" << failures << " issues)\n";
  }

  return failures == 0 ? 0 : 1;
}

```

`tests/harness/test_rewind_format.cpp`:

```cpp
#include <cstdio>
#include <filesystem>
#include <iostream>
#include <span>
#include <string>
#include <vector>

#include <redlog.hpp>

#include "w1rewind/format/trace_format.hpp"
#include "w1rewind/record/trace_builder.hpp"
#include "w1rewind/trace/trace_file_writer.hpp"
#include "w1rewind/trace/trace_reader.hpp"

namespace {

std::string make_temp_path() {
  auto base = std::filesystem::temp_directory_path() / "w1rewind_format_test.w1r";
  return base.string();
}

bool write_sample_trace(const std::string& path, bool include_modules, bool include_byte_reg) {
  w1::rewind::trace_file_writer_config writer_config;
  writer_config.path = path;
  writer_config.log = redlog::get_logger("w1rewind.test.trace");
  auto writer = w1::rewind::make_trace_file_writer(std::move(writer_config));
  if (!writer || !writer->open()) {
    std::cerr << "failed to open trace writer\n";
    return false;
  }

  w1::rewind::trace_builder_config builder_config;
  builder_config.sink = writer;
  builder_config.log = redlog::get_logger("w1rewind.test.builder");
  builder_config.options.record_instructions = true;
  builder_config.options.record_register_deltas = true;
  builder_config.options.record_memory_access = true;
  builder_config.options.record_memory_values = true;
  builder_config.options.record_snapshots = true;
  builder_config.options.record_stack_segments = true;

  w1::rewind::trace_builder builder(std::move(builder_config));

  w1::arch::arch_spec arch{};
  std::string arch_error;
  if (!w1::arch::parse_arch_spec("x86_64", arch, arch_error)) {
    std::cerr << "failed to parse arch spec: " << arch_error << "\n";
    return false;
  }

  w1::rewind::target_info_record target{};
  target.os = "test";
  target.abi = "test";
  target.cpu = "test";

  w1::rewind::target_environment_record environment{};
  environment.os_version = "1.0";
  environment.os_build = "test-build";
  environment.os_kernel = "test-kernel";
  environment.hostname = "test-host";
  environment.pid = 123;
  environment.addressing_bits = 48;
  environment.low_mem_addressing_bits = 48;
  environment.high_mem_addressing_bits = 48;

  std::vector<w1::rewind::register_spec> regs;
  regs.push_back(
      w1::rewind::register_spec{
          0, "rax", 64, 0, "rax", w1::rewind::register_class::gpr, w1::rewind::register_value_kind::u64
      }
  );
  regs.push_back(
      w1::rewind::register_spec{
          1, "rsp", 64, w1::rewind::register_flag_sp, "rsp", w1::rewind::register_class::gpr,
          w1::rewind::register_value_kind::u64
      }
  );
  regs.push_back(
      w1::rewind::register_spec{
          2, "rip", 64, w1::rewind::register_flag_pc, "rip", w1::rewind::register_class::gpr,
          w1::rewind::register_value_kind::u64
      }
  );
  if (include_byte_reg) {
    regs.push_back(
        w1::rewind::register_spec{
            3, "v0", 128, 0, "v0", w1::rewind::register_class::simd, w1::rewind::register_value_kind::bytes
        }
    );
  }

  if (!builder.begin_trace(arch, target, environment, regs)) {
    std::cerr << "failed to begin trace: " << builder.error() << "\n";
    return false;
  }

  if (include_modules) {
    w1::rewind::module_record module{};
    module.id = 1;
    module.base = 0x1000;
    module.size = 0x2000;
    module.permissions = w1::rewind::module_perm::read | w1::rewind::module_perm::exec;
    module.path = "test_module";
    builder.set_module_table({module});
  }

  if (!builder.begin_thread(1, "main")) {
    std::cerr << "failed to write thread start: " << builder.error() << "\n";
    return false;
  }

  uint64_t sequence = 0;
  if (!builder.emit_instruction(1, 0x1000 + 0x10, 4, 0, sequence)) {
    std::cerr << "failed to emit instruction: " << builder.error() << "\n";
    return false;
  }

  std::vector<w1::rewind::register_delta> deltas;
  deltas.push_back({0, 0x1234});
  deltas.push_back({1, 0x2000});
  deltas.push_back({2, 0x1010});
  if (!builder.emit_register_deltas(1, sequence, std::span<const w1::rewind::register_delta>(deltas))) {
    std::cerr << "failed to emit register deltas: " << builder.error() << "\n";
    return false;
  }

  if (include_byte_reg) {
    std::vector<uint8_t> reg_bytes = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    };
    std::vector<w1::rewind::register_bytes_entry> entries;
    entries.push_back(w1::rewind::register_bytes_entry{3, 0, 16});
    if (!builder.emit_register_bytes(
            1, sequence, std::span<const w1::rewind::register_bytes_entry>(entries), std::span<const uint8_t>(reg_bytes)
        )) {
      std::cerr << "failed to emit register bytes: " << builder.error() << "\n";
      return false;
    }
  }

  std::vector<uint8_t> bytes = {0x11, 0x22, 0x33, 0x44};
  if (!builder.emit_memory_access(
          1, sequence, w1::rewind::memory_access_kind::write, 0x2000, 4, true, false, std::span<const uint8_t>(bytes)
      )) {
    std::cerr << "failed to emit memory access: " << builder.error() << "\n";
    return false;
  }

  std::vector<uint8_t> stack = {0xaa, 0xbb, 0xcc, 0xdd};
  std::vector<w1::rewind::stack_segment> segments;
  w1::rewind::stack_segment segment{};
  segment.base = 0x3000;
  segment.size = stack.size();
  segment.bytes = stack;
  segments.push_back(std::move(segment));
  if (!builder.emit_snapshot(
          1, sequence, 0, std::span<const w1::rewind::register_delta>(deltas),
          std::span<const w1::rewind::stack_segment>(segments), "test"
      )) {
    std::cerr << "failed to emit snapshot: " << builder.error() << "\n";
    return false;
  }

  builder.end_thread(1);
  builder.flush();
  return true;
}

int run_test() {
  std::string path = make_temp_path();
  std::error_code ec;
  std::filesystem::remove(path, ec);

  if (!write_sample_trace(path, true, false)) {
    return 1;
  }

  w1::rewind::trace_reader reader(path);
  if (!reader.open()) {
    std::cerr << "failed to open trace reader: " << reader.error() << "\n";
    return 1;
  }

  bool saw_target = false;
  bool saw_environment = false;
  bool saw_regs = false;
  bool saw_instruction = false;
  bool saw_memory = false;
  bool saw_snapshot = false;

  w1::rewind::trace_record record;
  while (reader.read_next(record)) {
    if (std::holds_alternative<w1::rewind::target_info_record>(record)) {
      const auto& info = std::get<w1::rewind::target_info_record>(record);
      if (info.os != "test" || info.abi != "test" || info.cpu != "test") {
        std::cerr << "target info mismatch\n";
        return 1;
      }
      saw_target = true;
    } else if (std::holds_alternative<w1::rewind::target_environment_record>(record)) {
      const auto& env = std::get<w1::rewind::target_environment_record>(record);
      if (env.hostname != "test-host" || env.pid != 123 || env.addressing_bits != 48) {
        std::cerr << "target environment mismatch\n";
        return 1;
      }
      saw_environment = true;
    } else if (std::holds_alternative<w1::rewind::register_spec_record>(record)) {
      const auto& specs = std::get<w1::rewind::register_spec_record>(record).registers;
      if (specs.size() != 3 || specs[1].name != "rsp") {
        std::cerr << "register specs mismatch\n";
        return 1;
      }
      saw_regs = true;
    } else if (std::holds_alternative<w1::rewind::instruction_record>(record)) {
      saw_instruction = true;
    } else if (std::holds_alternative<w1::rewind::memory_access_record>(record)) {
      saw_memory = true;
    } else if (std::holds_alternative<w1::rewind::snapshot_record>(record)) {
      saw_snapshot = true;
    }
  }

  if (!reader.error().empty()) {
    std::cerr << "trace reader error: " << reader.error() << "\n";
    return 1;
  }

  const auto& header = reader.header();
  if (header.arch.arch_mode != w1::arch::mode::x86_64 || header.arch.pointer_bits != 64 ||
      header.arch.arch_byte_order != w1::arch::byte_order::little) {
    std::cerr << "trace header arch mismatch\n";
    return 1;
  }

  if (!saw_target || !saw_environment || !saw_regs || !saw_instruction || !saw_memory || !saw_snapshot) {
    std::cerr << "missing expected records\n";
    return 1;
  }

  std::filesystem::remove(path, ec);
  return 0;
}

} // namespace

int main(int argc, char** argv) {
  if (argc > 1) {
    std::string path = argv[1];
    bool include_modules = true;
    bool include_byte_reg = false;
    for (int i = 2; i < argc; ++i) {
      std::string arg = argv[i];
      if (arg == "--moduleless") {
        include_modules = false;
      } else if (arg == "--byte-reg") {
        include_byte_reg = true;
      }
    }
    return write_sample_trace(path, include_modules, include_byte_reg) ? 0 : 1;
  }
  return run_test();
}

```

`tests/harness/test_w1cov_components.cpp`:

```cpp
#include <iostream>
#include <vector>

#include "engine/coverage_exporter.hpp"
#include "engine/coverage_store.hpp"
#include "w1runtime/module_catalog.hpp"

int main() {
  w1cov::coverage_store store;

  w1cov::coverage_buffer buffer;
  buffer[0x1000] = w1cov::coverage_buffer_entry{0, 4, 2};
  buffer[0x2000] = w1cov::coverage_buffer_entry{1, 8, 1};
  store.merge(buffer);
  store.record(0x1000, 4, 0, 3);

  if (store.unit_count() != 2) {
    std::cerr << "unexpected unit count\n";
    return 1;
  }

  auto snapshot = store.snapshot();
  if (snapshot.total_hits != 6) {
    std::cerr << "unexpected total hits\n";
    return 1;
  }

  std::vector<w1::runtime::module_info> modules;
  w1::runtime::module_info mod0{};
  mod0.name = "mod0";
  mod0.path = "/fake/mod0";
  mod0.base_address = 0x1000;
  mod0.size = 0x1000;
  modules.push_back(mod0);

  w1::runtime::module_info mod1{};
  mod1.name = "mod1";
  mod1.path = "/fake/mod1";
  mod1.base_address = 0x2000;
  mod1.size = 0x1000;
  modules.push_back(mod1);

  w1cov::coverage_exporter exporter;
  auto data = exporter.to_drcov(snapshot, modules);
  if (data.basic_blocks.empty()) {
    std::cerr << "no basic blocks exported\n";
    return 1;
  }
  if (!data.has_hitcounts()) {
    std::cerr << "missing hitcounts\n";
    return 1;
  }
  if (data.modules.size() != 2) {
    std::cerr << "unexpected module count\n";
    return 1;
  }
  if (data.basic_blocks.size() != data.hitcounts.size()) {
    std::cerr << "hitcount size mismatch\n";
    return 1;
  }

  std::cout << "w1cov component test completed\n";
  return 0;
}

```

`tests/harness/test_w1cov_module_filtering.cpp`:

```cpp
#include <cstdint>
#include <iostream>
#include <string>

#include "w1formats/drcov.hpp"
#include "runtime/coverage_runtime.hpp"

#include "w1cov_demo_lib.hpp"

int main() {
  using w1::test_helpers::demo_library;
  using w1::test_helpers::load_demo_library;
  using w1::test_helpers::unload_demo_library;

  std::cout << "\n=== testing w1cov module filtering ===\n";

  w1cov::coverage_config config;
  config.output_file = "test_w1cov_module_filtering.drcov";
  config.common.instrumentation.include_modules = {"w1cov_demo_lib"};

  using process_runtime = w1cov::coverage_process_runtime<w1cov::coverage_mode::basic_block>;
  process_runtime runtime(config);

  auto main_session = runtime.session().attach_current_thread("main");
  if (!main_session) {
    std::cerr << "failed to attach main session\n";
    return 1;
  }

  demo_library lib{};
  if (!load_demo_library(lib)) {
    std::cerr << "failed to load demo library\n";
    return 1;
  }

  runtime.refresh_modules();

  uint64_t result = 0;
  if (!main_session->call(reinterpret_cast<uint64_t>(lib.add), {4, 7}, &result)) {
    std::cerr << "failed to trace demo add\n";
    return 1;
  }
  if (!main_session->call(reinterpret_cast<uint64_t>(lib.branch), {9}, &result)) {
    std::cerr << "failed to trace demo branch\n";
    return 1;
  }

  main_session.reset();
  runtime.stop();
  unload_demo_library(lib);

  if (!runtime.export_output()) {
    std::cerr << "coverage export produced no output\n";
    return 1;
  }

  auto data = drcov::read(config.output_file);
  if (data.basic_blocks.empty()) {
    std::cerr << "no basic blocks recorded\n";
    return 1;
  }

  bool has_module = false;
  for (const auto& module : data.modules) {
    if (module.path.find("w1cov_demo_lib") != std::string::npos) {
      has_module = true;
      break;
    }
  }
  if (!has_module) {
    std::cerr << "demo module missing from drcov output\n";
    return 1;
  }

  if (runtime.engine().module_count() == 0 || runtime.engine().coverage_unit_count() == 0) {
    std::cerr << "engine did not record filtered module coverage\n";
    return 1;
  }

  std::cout << "w1cov module filtering test completed\n";
  return 0;
}

```

`tests/harness/test_w1cov_multithread_demo.cpp`:

```cpp
#include <cstdint>
#include <iostream>
#include <string>

#include "runtime/coverage_runtime.hpp"
#include "w1formats/drcov.hpp"

#include "w1cov_demo_lib.hpp"

int main() {
  using w1::test_helpers::demo_library;
  using w1::test_helpers::load_demo_library;
  using w1::test_helpers::run_demo_thread;
  using w1::test_helpers::unload_demo_library;

  w1cov::coverage_config config;
  config.output_file = "test_w1cov_multithread.drcov";
  config.common.instrumentation.include_modules = {"w1cov_demo_lib"};

  using process_runtime = w1cov::coverage_process_runtime<w1cov::coverage_mode::basic_block>;
  process_runtime runtime(config);

  auto main_session = runtime.session().attach_current_thread("main");
  if (!main_session) {
    std::cerr << "failed to attach main session\n";
    return 1;
  }

  demo_library lib{};
  if (!load_demo_library(lib)) {
    std::cerr << "failed to load demo library\n";
    return 1;
  }

  runtime.refresh_modules();

  uint64_t result = 0;
  if (!main_session->call(reinterpret_cast<uint64_t>(lib.add), {1, 2}, &result)) {
    std::cerr << "failed to trace demo add\n";
    return 1;
  }
  if (!main_session->call(reinterpret_cast<uint64_t>(lib.branch), {42}, &result)) {
    std::cerr << "failed to trace demo branch\n";
    return 1;
  }

  if (!run_demo_thread(lib.thread_proc, 25)) {
    std::cerr << "failed to run demo thread\n";
    return 1;
  }

  main_session.reset();
  runtime.stop();
  unload_demo_library(lib);

  if (!runtime.export_output()) {
    std::cerr << "coverage export produced no output\n";
    return 1;
  }

  auto data = drcov::read(config.output_file);
  if (data.basic_blocks.empty()) {
    std::cerr << "no basic blocks recorded\n";
    return 1;
  }

  bool has_module = false;
  for (const auto& module : data.modules) {
    if (module.path.find("w1cov_demo_lib") != std::string::npos) {
      has_module = true;
      break;
    }
  }
  if (!has_module) {
    std::cerr << "demo module missing from drcov output\n";
    return 1;
  }

  std::cout << "w1cov multithread demo completed\n";
  return 0;
}

```

`tests/harness/test_w1cov_single_thread.cpp`:

```cpp
#include <cstdint>
#include <iostream>
#include <memory>
#include <string>
#include <vector>

#include "engine/coverage_engine.hpp"
#include "thread/coverage_thread_tracer.hpp"
#include "w1base/thread_utils.hpp"
#include "w1formats/drcov.hpp"
#include "w1instrument/trace/thread_session.hpp"
#include "w1runtime/module_catalog.hpp"

extern "C" uint64_t test_coverage_control_flow(uint64_t value);

int main() {
  std::cout << "\n=== testing w1cov single-thread ===\n";

  w1cov::coverage_config config;
  config.output_file = "test_w1cov_single_thread.drcov";
  config.common.instrumentation.include_modules = {"test_w1cov_single_thread"};

  w1::runtime::module_catalog modules;
  modules.refresh();

  auto engine = std::make_shared<w1cov::coverage_engine>(config);
  engine->configure(modules);

  using tracer_t = w1cov::coverage_thread_tracer<w1cov::coverage_mode::basic_block>;

  w1::instrument::thread_session_config session_config;
  session_config.instrumentation = config.common.instrumentation;
  session_config.thread_id = w1::util::current_thread_id();
  session_config.thread_name = "main";
  session_config.shared_modules = &modules;

  w1::instrument::thread_session<tracer_t> session(session_config, tracer_t(engine, config.buffer_flush_threshold));

  if (!session.initialize()) {
    std::cout << "failed to initialize w1cov tracer\n";
    return 1;
  }

  uint64_t result1 = 0;
  uint64_t result2 = 0;
  uint64_t result3 = 0;
  uint64_t result4 = 0;

  if (!session.call(reinterpret_cast<uint64_t>(test_coverage_control_flow), {5}, &result1)) {
    std::cout << "failed to trace function (value < 10)\n";
    return 1;
  }
  if (!session.call(reinterpret_cast<uint64_t>(test_coverage_control_flow), {15}, &result2)) {
    std::cout << "failed to trace function (10 <= value < 20)\n";
    return 1;
  }
  if (!session.call(reinterpret_cast<uint64_t>(test_coverage_control_flow), {30}, &result3)) {
    std::cout << "failed to trace function (20 <= value < 50)\n";
    return 1;
  }
  if (!session.call(reinterpret_cast<uint64_t>(test_coverage_control_flow), {100}, &result4)) {
    std::cout << "failed to trace function (value >= 50)\n";
    return 1;
  }

  session.shutdown();

  if (engine->coverage_unit_count() == 0 || engine->total_hits() == 0) {
    std::cout << "coverage engine reported no activity\n";
    return 1;
  }

  if (!engine->export_coverage()) {
    std::cout << "coverage export produced no output\n";
    return 1;
  }

  auto data = drcov::read(config.output_file);
  if (data.basic_blocks.empty()) {
    std::cout << "no basic blocks recorded\n";
    return 1;
  }
  if (!data.has_hitcounts()) {
    std::cout << "missing hitcounts in drcov output\n";
    return 1;
  }

  bool has_module = false;
  for (const auto& module : data.modules) {
    if (module.path.find("test_w1cov_single_thread") != std::string::npos) {
      has_module = true;
      break;
    }
  }
  if (!has_module) {
    std::cout << "self module missing from drcov output\n";
    return 1;
  }

  std::cout << "w1cov single-thread test completed\n";
  std::cout << "function results: " << result1 << ", " << result2 << ", " << result3 << ", " << result4 << "\n";
  std::cout << "unique blocks: " << engine->coverage_unit_count() << "\n";
  std::cout << "total hits: " << engine->total_hits() << "\n";
  std::cout << "coverage output: " << config.output_file << "\n";

  return 0;
}

```

`tests/harness/test_w1script.cpp`:

```cpp
#include <cstdint>
#include <cstdio>
#include <fstream>
#include <iostream>
#include <string>
#include <utility>
#include <vector>

#include "w1base/cli/verbosity.hpp"
#include "tracers/w1script/script.hpp"

namespace {

int parse_verbosity(int argc, char* argv[]) {
  int verbose = 0;
  for (int i = 1; i < argc; ++i) {
    if (argv[i][0] != '-') {
      continue;
    }
    for (const char* p = argv[i]; *p; ++p) {
      if (*p == 'v') {
        ++verbose;
      }
    }
  }
  return verbose;
}

} // namespace

// minimal lua script embedded as string - instruction tracer
static const char* minimal_script = R"lua(
-- instruction tracer with disassembly
-- logs every instruction with address and assembly code

local instruction_count = 0
local max_instructions = 50  -- limit output for demo

local tracer = {}

local function on_instruction(vm, gpr, fpr)
    instruction_count = instruction_count + 1

    -- only log first N instructions to avoid spam
    if instruction_count <= max_instructions then
        local pc = w1.reg.pc(gpr) or 0
        local disasm = w1.inst.disasm(vm) or "<unknown>"

        w1.log.info(w1.util.format_address(pc) .. ": " .. disasm)
    end

    -- at truncation point say we're truncating
    if instruction_count == max_instructions then
        w1.log.info("... silencing further instruction logs ...")
    end

    return w1.enum.vm_action.CONTINUE
end

function tracer.init()
    w1.on(w1.event.INSTRUCTION_PRE, on_instruction)
end

function tracer.shutdown()
    w1.log.info("traced " .. instruction_count .. " instructions total")
end

return tracer
)lua";

// test function for w1script - demonstrates scripted tracing
extern "C" int test_script_fibonacci(int n) {
  if (n <= 1) {
    return n;
  }
  return test_script_fibonacci(n - 1) + test_script_fibonacci(n - 2);
}

int main(int argc, char* argv[]) {
  const int verbose = parse_verbosity(argc, argv);
  w1::cli::apply_verbosity(verbose);

  const std::string script_path = "test_minimal_script.lua";
  std::ofstream script_file(script_path);
  script_file << minimal_script;
  script_file.close();

  w1::tracers::script::script_config config;
  config.script_path = script_path;
  config.common.verbose = verbose;
  config.common.instrumentation.include_modules = {"test_w1script"};

  auto runtime = w1::tracers::script::make_script_runtime(config);
  if (!runtime.session) {
    std::cerr << "failed to initialize w1script runtime\n";
    std::remove(script_path.c_str());
    return 1;
  }

  uint64_t result = 0;
  if (!runtime.session->call(reinterpret_cast<uint64_t>(test_script_fibonacci), {10}, &result, "main")) {
    std::cerr << "failed to trace function\n";
    std::remove(script_path.c_str());
    return 1;
  }

  runtime.session->export_output();
  std::remove(script_path.c_str());

  std::cout << "w1script test completed (fibonacci(10) = " << result << ")\n";
  return 0;
}

```

`tests/harness/test_w1xfer.cpp`:

```cpp
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <iostream>
#include <string>
#include <utility>
#include <vector>

#include <redlog.hpp>
#include "w1base/cli/verbosity.hpp"

#include "tracers/w1xfer/transfer.hpp"

namespace {

int parse_verbosity(int argc, char* argv[]) {
  int verbose = 0;
  for (int i = 1; i < argc; ++i) {
    if (argv[i][0] != '-') {
      continue;
    }
    for (const char* p = argv[i]; *p; ++p) {
      if (*p == 'v') {
        ++verbose;
      }
    }
  }
  return verbose;
}

bool ensure_output_file(const std::string& path) {
  std::ifstream input(path);
  if (!input.is_open()) {
    return false;
  }
  std::string first_line;
  std::getline(input, first_line);
  return !first_line.empty();
}

} // namespace

// test function for w1xfer
extern "C" void* test_xfer_library_calls(void* arg) {
  size_t size = reinterpret_cast<size_t>(arg);

  void* buffer = malloc(size);
  if (!buffer) {
    printf("malloc failed for size %zu\n", size);
    return nullptr;
  }

  memset(buffer, 0x42, size);

  char message[256];
  snprintf(message, sizeof(message), "allocated and initialized %zu bytes at %p", size, buffer);
  printf("%s\n", message);

  FILE* fp = fopen("nonexistent_test_file_12345.txt", "r");
  if (fp) {
    printf("unexpectedly opened file\n");
    fclose(fp);
  } else {
    printf("expected file open failure\n");
  }

  free(buffer);
  return reinterpret_cast<void*>(size);
}

int main(int argc, char* argv[]) {
  const int verbose = parse_verbosity(argc, argv);
  w1::cli::apply_verbosity(verbose);

  w1xfer::transfer_config config;
  config.output.path = "test_w1xfer.jsonl";
  config.capture.registers = true;
  config.capture.stack = true;
  config.enrich.modules = true;
  config.enrich.symbols = true;
  config.enrich.analyze_apis = true;
  config.common.verbose = verbose;
  config.common.instrumentation.include_modules = {"test_w1xfer"};

  auto runtime = w1xfer::make_transfer_runtime(config);
  if (!runtime.session) {
    std::cerr << "failed to initialize w1xfer runtime\n";
    return 1;
  }

  uint64_t result = 0;
  if (!runtime.session->call_current_thread(reinterpret_cast<uint64_t>(test_xfer_library_calls), {1024}, &result)) {
    std::cerr << "failed to trace function\n";
    return 1;
  }

  runtime.session->export_output();

  const auto stats = runtime.session->engine().stats();
  if (stats.total_calls == 0 || stats.total_returns == 0) {
    std::cerr << "unexpected empty transfer stats\n";
    return 1;
  }

  if (!ensure_output_file(config.output.path)) {
    std::cerr << "output file missing or empty: " << config.output.path << "\n";
    return 1;
  }

  std::cout << "w1xfer test completed (output in " << config.output.path << ")\n";
  return 0;
}

```

`tests/harness/w1cov_demo_lib.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <iostream>
#include <string>

#if defined(_WIN32) || defined(WIN32)
#include <windows.h>
#else
#include <dlfcn.h>
#include <pthread.h>
#endif

#include "test_paths.hpp"

namespace w1::test_helpers {

#if defined(_WIN32) || defined(WIN32)
constexpr const char* demo_library_name = "w1cov_demo_lib.dll";
using demo_library_handle = HMODULE;
using demo_thread_fn = DWORD(WINAPI*)(LPVOID);
#elif defined(__APPLE__)
constexpr const char* demo_library_name = "w1cov_demo_lib.dylib";
using demo_library_handle = void*;
using demo_thread_fn = void* (*) (void*);
#else
constexpr const char* demo_library_name = "w1cov_demo_lib.so";
using demo_library_handle = void*;
using demo_thread_fn = void* (*) (void*);
#endif

using demo_add_fn = int (*)(int, int);
using demo_branch_fn = int (*)(int);

struct demo_library {
  demo_library_handle handle = nullptr;
  demo_add_fn add = nullptr;
  demo_branch_fn branch = nullptr;
  demo_thread_fn thread_proc = nullptr;
};

#if defined(_WIN32) || defined(WIN32)
inline FARPROC load_demo_proc(HMODULE handle, std::initializer_list<const char*> names) {
  for (const char* name : names) {
    if (auto proc = GetProcAddress(handle, name)) {
      return proc;
    }
  }
  return nullptr;
}
#endif

inline bool load_demo_library(demo_library& out) {
  const std::string path = w1::test_paths::test_library_path(demo_library_name);

#if defined(_WIN32) || defined(WIN32)
  HMODULE handle = LoadLibraryA(path.c_str());
  if (!handle) {
    std::cerr << "LoadLibrary failed for " << path << "\n";
    return false;
  }
  auto add = reinterpret_cast<demo_add_fn>(load_demo_proc(handle, {"w1cov_demo_add", "_w1cov_demo_add"}));
  auto branch = reinterpret_cast<demo_branch_fn>(load_demo_proc(handle, {"w1cov_demo_branch", "_w1cov_demo_branch"}));
  auto thread_proc =
      reinterpret_cast<demo_thread_fn>(load_demo_proc(handle, {"w1cov_demo_thread_proc", "_w1cov_demo_thread_proc@4"}));
  if (!add || !branch || !thread_proc) {
    std::cerr << "GetProcAddress failed for demo library exports\n";
    FreeLibrary(handle);
    return false;
  }
  out.handle = handle;
  out.add = add;
  out.branch = branch;
  out.thread_proc = thread_proc;
  return true;
#else
  void* handle = dlopen(path.c_str(), RTLD_NOW);
  if (!handle) {
    std::cerr << "dlopen failed for " << path << ": " << dlerror() << "\n";
    return false;
  }
  dlerror();
  auto add = reinterpret_cast<demo_add_fn>(dlsym(handle, "w1cov_demo_add"));
  auto branch = reinterpret_cast<demo_branch_fn>(dlsym(handle, "w1cov_demo_branch"));
  auto thread_proc = reinterpret_cast<demo_thread_fn>(dlsym(handle, "w1cov_demo_thread_proc"));
  if (!add || !branch || !thread_proc) {
    std::cerr << "dlsym failed for demo library exports\n";
    dlclose(handle);
    return false;
  }
  out.handle = handle;
  out.add = add;
  out.branch = branch;
  out.thread_proc = thread_proc;
  return true;
#endif
}

inline void unload_demo_library(demo_library& lib) {
  if (!lib.handle) {
    return;
  }
#if defined(_WIN32) || defined(WIN32)
  FreeLibrary(lib.handle);
#else
  dlclose(lib.handle);
#endif
  lib.handle = nullptr;
}

inline bool run_demo_thread(demo_thread_fn thread_proc, intptr_t value) {
#if defined(_WIN32) || defined(WIN32)
  HANDLE thread = CreateThread(nullptr, 0, thread_proc, reinterpret_cast<void*>(value), 0, nullptr);
  if (!thread) {
    return false;
  }
  WaitForSingleObject(thread, INFINITE);
  CloseHandle(thread);
  return true;
#else
  pthread_t thread{};
  if (pthread_create(&thread, nullptr, thread_proc, reinterpret_cast<void*>(value)) != 0) {
    return false;
  }
  pthread_join(thread, nullptr);
  return true;
#endif
}

} // namespace w1::test_helpers

```

`tests/harness/w1cov_test_targets.cpp`:

```cpp
#include <cstdint>

extern "C" uint64_t test_coverage_control_flow(uint64_t value) {
  uint64_t result = 0;

  if (value < 10) {
    result = value * 2;
  } else if (value < 20) {
    result = value * 3;
    if (value % 2 == 0) {
      result += 5;
    } else {
      result -= 3;
    }
  } else if (value < 50) {
    for (int i = 0; i < 10; i++) {
      result += i;
      if (result > 100) {
        break;
      }
    }
  } else {
    switch (value % 4) {
    case 0:
      result = value / 2;
      break;
    case 1:
      result = value * value;
      break;
    case 2:
      result = value + 100;
      break;
    default:
      result = value - 50;
      break;
    }
  }

  if (result > 0) {
    if (result % 2 == 0) {
      result = result / 2;
    } else {
      result = result * 3 + 1;
    }
  }

  return result;
}

```

`tests/libraries/CMakeLists.txt`:

```txt
# test injection libraries

include(${W1_SOURCE_DIR}/cmake/TestConfig.cmake)

set(TEST_LIBRARY_OUTPUT_SUBDIR libraries)

function(w1_add_test_library target source)
    add_library(${target} SHARED ${source})
    set_target_properties(${target} PROPERTIES PREFIX "")
    w1_set_test_output_dirs(${target} ${TEST_LIBRARY_OUTPUT_SUBDIR})
    w1_disable_sanitizers(${target})
endfunction()

w1_add_test_library(tracer_lib tracer_lib.c)
w1_add_test_library(counter_lib counter_lib.c)
w1_add_test_library(memory_lib memory_lib.c)
w1_add_test_library(w1h00k_interpose_lib w1h00k_interpose_lib.c)
w1_add_test_library(w1cov_demo_lib w1cov_demo_lib.c)

if(UNIX AND NOT APPLE)
    find_package(Threads REQUIRED)
    w1_add_test_library(linux_test_lib linux_test_lib.c)
    target_link_libraries(linux_test_lib PRIVATE ${CMAKE_DL_LIBS})

    w1_add_test_library(w1monitor_thread_lib w1monitor_thread_lib.c)
    target_link_libraries(w1monitor_thread_lib PRIVATE Threads::Threads)
endif()

# platform-specific linking and suffixes
if(WIN32)
    target_link_libraries(memory_lib PRIVATE psapi)
    set(TEST_LIBRARY_SUFFIX ".dll")
elseif(APPLE)
    set(TEST_LIBRARY_SUFFIX ".dylib")
else()
    set(TEST_LIBRARY_SUFFIX ".so")
endif()

set(TEST_LIBRARY_TARGETS tracer_lib counter_lib memory_lib w1h00k_interpose_lib w1cov_demo_lib)
if(TARGET linux_test_lib)
    list(APPEND TEST_LIBRARY_TARGETS linux_test_lib)
endif()
if(TARGET w1monitor_thread_lib)
    list(APPEND TEST_LIBRARY_TARGETS w1monitor_thread_lib)
endif()

foreach(target IN LISTS TEST_LIBRARY_TARGETS)
    set_target_properties(${target} PROPERTIES SUFFIX "${TEST_LIBRARY_SUFFIX}")
endforeach()

if(TARGET w1h00k_tests)
    add_dependencies(w1h00k_tests w1h00k_interpose_lib)
endif()
if(TARGET w1monitor_tests)
    add_dependencies(w1monitor_tests w1h00k_interpose_lib)
endif()
if(TARGET w1monitor_tests AND TARGET w1monitor_thread_lib)
    add_dependencies(w1monitor_tests w1monitor_thread_lib)
endif()
if(TARGET test_monitor_demo)
    add_dependencies(test_monitor_demo w1h00k_interpose_lib)
endif()

install(TARGETS ${TEST_LIBRARY_TARGETS}
    LIBRARY DESTINATION test/libraries
    RUNTIME DESTINATION test/libraries
    COMPONENT ${W1_TESTS_COMPONENT}
)

```

`tests/libraries/counter_lib.c`:

```c
#include <stdio.h>
#include <time.h>

#ifdef _WIN32
#include <windows.h>
#include <process.h>
#define getpid _getpid
static volatile LONG call_count = 0;

// Forward declarations
void counter_init();
void counter_cleanup();
void increment_counter();
int get_counter();

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
  switch (fdwReason) {
  case DLL_PROCESS_ATTACH:
    counter_init();
    break;
  case DLL_PROCESS_DETACH:
    counter_cleanup();
    break;
  }
  return TRUE;
}

void counter_init() {
  printf("COUNTER: library loaded into PID %d\n", getpid());
  printf("COUNTER: call count initialized to 0\n");
}

void counter_cleanup() { printf("COUNTER: library unloaded, final call count: %ld\n", call_count); }

void increment_counter() {
  LONG count = InterlockedIncrement(&call_count);
  printf("COUNTER: call count = %ld\n", count);
}

#else
#include <unistd.h>

#ifdef __GNUC__
#include <stdatomic.h>
static atomic_int call_count = 0;
#else
static volatile int call_count = 0;
#endif

__attribute__((constructor)) void counter_init() {
  printf("COUNTER: library loaded into PID %d\n", getpid());
  printf("COUNTER: call count initialized to 0\n");
}

__attribute__((destructor)) void counter_cleanup() {
  printf("COUNTER: library unloaded, final call count: %d\n", call_count);
}

void increment_counter() {
#ifdef __GNUC__
  int count = atomic_fetch_add(&call_count, 1) + 1;
#else
  int count = ++call_count; // not thread-safe fallback
#endif
  printf("COUNTER: call count = %d\n", count);
}

#endif

// get current count without incrementing
int get_counter() { return call_count; }
```

`tests/libraries/linux_test_lib.c`:

```c
/*
 * Linux-specific test library for injection testing
 * Tests Linux-specific hooking and injection functionality
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>
#include <syslog.h>
#include <errno.h>
#include <stdarg.h>

static int initialized = 0;
static FILE* log_file = NULL;

// Function pointers for original functions
static int (*orig_open)(const char* pathname, int flags, ...) = NULL;
static int (*orig_close)(int fd) = NULL;
static void* (*orig_malloc)(size_t size) = NULL;
static void (*orig_free)(void* ptr) = NULL;
static pid_t (*orig_getpid)(void) = NULL;

void log_message(const char* format, ...) {
  if (!log_file) {
    return;
  }

  va_list args;
  va_start(args, format);

  time_t now = time(NULL);
  struct tm* tm_info = localtime(&now);

  fprintf(log_file, "[%02d:%02d:%02d] ", tm_info->tm_hour, tm_info->tm_min, tm_info->tm_sec);
  vfprintf(log_file, format, args);
  fprintf(log_file, "\n");
  fflush(log_file);

  va_end(args);
}

void initialize_library() {
  if (initialized) {
    return;
  }

  // Open log file
  log_file = fopen("/tmp/linux_test_lib.log", "a");
  if (!log_file) {
    // Fallback to syslog
    openlog("linux_test_lib", LOG_PID, LOG_USER);
    syslog(LOG_INFO, "linux_test_lib: initialized (no log file)");
  } else {
    log_message("linux_test_lib: initialized (PID: %d)", getpid());
  }

  // Get original function pointers
  orig_open = dlsym(RTLD_NEXT, "open");
  orig_close = dlsym(RTLD_NEXT, "close");
  orig_malloc = dlsym(RTLD_NEXT, "malloc");
  orig_free = dlsym(RTLD_NEXT, "free");
  orig_getpid = dlsym(RTLD_NEXT, "getpid");

  initialized = 1;

  if (log_file) {
    log_message("linux_test_lib: function pointers resolved");
  }
}

void cleanup_library() {
  if (log_file) {
    log_message("linux_test_lib: cleaning up");
    fclose(log_file);
    log_file = NULL;
  }
  closelog();
}

// Constructor/destructor
__attribute__((constructor)) void library_init() { initialize_library(); }

__attribute__((destructor)) void library_cleanup() { cleanup_library(); }

// Hooked functions
int open(const char* pathname, int flags, ...) {
  initialize_library();

  if (!orig_open) {
    errno = ENOSYS;
    return -1;
  }

  mode_t mode = 0;
  if (flags & O_CREAT) {
    va_list args;
    va_start(args, flags);
    mode = va_arg(args, mode_t);
    va_end(args);
  }

  int result = orig_open(pathname, flags, mode);

  log_message("open(%s, %d) = %d", pathname, flags, result);

  return result;
}

int close(int fd) {
  initialize_library();

  if (!orig_close) {
    errno = ENOSYS;
    return -1;
  }

  int result = orig_close(fd);

  log_message("close(%d) = %d", fd, result);

  return result;
}

void* malloc(size_t size) {
  initialize_library();

  if (!orig_malloc) {
    return NULL;
  }

  void* result = orig_malloc(size);

  // Be careful with logging in malloc to avoid recursion
  if (log_file && size > 1024) { // Only log large allocations
    log_message("malloc(%zu) = %p", size, result);
  }

  return result;
}

void free(void* ptr) {
  initialize_library();

  if (!orig_free) {
    return;
  }

  if (log_file && ptr) {
    log_message("free(%p)", ptr);
  }

  orig_free(ptr);
}

pid_t getpid(void) {
  initialize_library();

  if (!orig_getpid) {
    return syscall(SYS_getpid);
  }

  pid_t result = orig_getpid();

  // Log occasionally to avoid spam
  static int call_count = 0;
  if (++call_count % 10 == 1) {
    log_message("getpid() = %d (call #%d)", result, call_count);
  }

  return result;
}

// Test function that can be called from injected code
void linux_test_function() {
  initialize_library();
  log_message("linux_test_function called");
}

// Export symbol for testing
int linux_test_lib_version() { return 1; }
```

`tests/libraries/memory_lib.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// forward declarations
void report_memory_usage();
void memory_init();
void memory_cleanup();

#ifdef _WIN32
#include <windows.h>

#include <process.h>
#include <psapi.h>
#define getpid _getpid

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
  switch (fdwReason) {
  case DLL_PROCESS_ATTACH:
    memory_init();
    break;
  case DLL_PROCESS_DETACH:
    memory_cleanup();
    break;
  }
  return TRUE;
}

void memory_init() {
  printf("MEMORY: library loaded into PID %d\n", getpid());
  report_memory_usage();
}

void memory_cleanup() {
  printf("MEMORY: library unloaded\n");
  report_memory_usage();
}

void report_memory_usage() {
  PROCESS_MEMORY_COUNTERS pmc;
  if (GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc))) {
    printf("MEMORY: working set: %zu KB\n", pmc.WorkingSetSize / 1024);
    printf("MEMORY: page file usage: %zu KB\n", pmc.PagefileUsage / 1024);
    printf("MEMORY: peak working set: %zu KB\n", pmc.PeakWorkingSetSize / 1024);
  } else {
    printf("MEMORY: unable to get memory info\n");
  }
}

#else
#include <unistd.h>
#include <sys/resource.h>

#ifdef __APPLE__
#include <mach/mach.h>
#include <mach/task.h>
#endif

#ifdef __linux__
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#endif

__attribute__((constructor)) void memory_init() {
  printf("MEMORY: library loaded into PID %d\n", getpid());
  report_memory_usage();
}

__attribute__((destructor)) void memory_cleanup() {
  printf("MEMORY: library unloaded\n");
  report_memory_usage();
}

void report_memory_usage() {
  struct rusage usage;
  if (getrusage(RUSAGE_SELF, &usage) == 0) {
    printf("MEMORY: max resident set size: %ld KB\n", usage.ru_maxrss);
#ifdef __APPLE__
    // macOS reports in bytes
    printf("MEMORY: current RSS: %ld KB\n", usage.ru_maxrss / 1024);
#else
    // Linux reports in KB
    printf("MEMORY: current RSS: %ld KB\n", usage.ru_maxrss);
#endif
  }

#ifdef __APPLE__
  // get more detailed memory info on macOS
  struct task_basic_info info;
  mach_msg_type_number_t size = TASK_BASIC_INFO_COUNT;
  if (task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t) &info, &size) == KERN_SUCCESS) {
    printf("MEMORY: virtual size: %lu KB\n", (unsigned long) (info.virtual_size / 1024));
    printf("MEMORY: resident size: %lu KB\n", (unsigned long) (info.resident_size / 1024));
  }
#endif

#ifdef __linux__
  // read from /proc/self/status on Linux
  FILE* status = fopen("/proc/self/status", "r");
  if (status) {
    char line[256];
    while (fgets(line, sizeof(line), status)) {
      if (strncmp(line, "VmRSS:", 6) == 0) {
        printf("MEMORY: %s", line);
      } else if (strncmp(line, "VmSize:", 7) == 0) {
        printf("MEMORY: %s", line);
      }
    }
    fclose(status);
  }
#endif
}

#endif

// allocate some memory for testing
void* allocate_test_memory(size_t size) {
  void* ptr = malloc(size);
  if (ptr) {
    memset(ptr, 0xAA, size); // fill with pattern
    printf("MEMORY: allocated %zu bytes at %p\n", size, ptr);
    report_memory_usage();
  }
  return ptr;
}

void free_test_memory(void* ptr) {
  if (ptr) {
    printf("MEMORY: freeing memory at %p\n", ptr);
    free(ptr);
    report_memory_usage();
  }
}
```

`tests/libraries/tracer_lib.c`:

```c
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

// Forward declarations
void tracer_init();
void tracer_cleanup();

#ifdef _WIN32
#include <windows.h>
#include <process.h>
#define getpid _getpid

// DLL entry point for Windows
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
  switch (fdwReason) {
  case DLL_PROCESS_ATTACH:
    tracer_init();
    break;
  case DLL_PROCESS_DETACH:
    tracer_cleanup();
    break;
  }
  return TRUE;
}

void tracer_init() {
  time_t now = time(NULL);
  char time_str[26];
  ctime_s(time_str, sizeof(time_str), &now);
  time_str[24] = '\0'; // remove newline

  printf("TRACER: *** INJECTION SUCCESSFUL ***\n");
  printf("TRACER: library loaded at %s\n", time_str);
  printf("TRACER: target process PID: %d\n", getpid());

  // get module name on Windows
  char module_name[MAX_PATH];
  if (GetModuleFileNameA(NULL, module_name, MAX_PATH)) {
    printf("TRACER: target process image: %s\n", module_name);
  }

  printf("TRACER: initialization complete\n");
}

void tracer_cleanup() {
  time_t now = time(NULL);
  char time_str[26];
  ctime_s(time_str, sizeof(time_str), &now);
  time_str[24] = '\0'; // remove newline

  printf("TRACER: library unloaded at %s\n", time_str);
  printf("TRACER: cleanup complete\n");
}

#else
#include <unistd.h>

#ifdef __APPLE__
#include <mach-o/dyld.h>
#endif

// constructor function - called when library is loaded
__attribute__((constructor)) void tracer_init() {
  time_t now = time(NULL);
  char* time_str = ctime(&now);
  time_str[24] = '\0'; // remove newline

  printf("TRACER: *** INJECTION SUCCESSFUL ***\n");
  printf("TRACER: library loaded at %s\n", time_str);
  printf("TRACER: target process PID: %d\n", getpid());

#ifdef __APPLE__
  // get image name on macOS
  const char* image_name = _dyld_get_image_name(0);
  if (image_name) {
    printf("TRACER: target process image: %s\n", image_name);
  }
#elif defined(__linux__)
  // get process name on Linux
  char proc_path[256];
  snprintf(proc_path, sizeof(proc_path), "/proc/%d/exe", getpid());
  char exe_path[1024];
  ssize_t len = readlink(proc_path, exe_path, sizeof(exe_path) - 1);
  if (len != -1) {
    exe_path[len] = '\0';
    printf("TRACER: target process image: %s\n", exe_path);
  }
#endif

  printf("TRACER: initialization complete\n");
}

// destructor function - called when library is unloaded
__attribute__((destructor)) void tracer_cleanup() {
  time_t now = time(NULL);
  char* time_str = ctime(&now);
  time_str[24] = '\0'; // remove newline

  printf("TRACER: library unloaded at %s\n", time_str);
  printf("TRACER: cleanup complete\n");
}

#endif

// exported function that can be called from the target process
void tracer_report() {
  static int call_count = 0;
  call_count++;

  printf("TRACER: tracer_report() called %d times\n", call_count);
}
```

`tests/libraries/w1cov_demo_lib.c`:

```c
#include <stdint.h>

#if defined(_WIN32) || defined(WIN32)
#include <windows.h>
#define W1COV_EXPORT __declspec(dllexport)
#define W1COV_CALL WINAPI
#else
#define W1COV_EXPORT __attribute__((visibility("default")))
#define W1COV_CALL
#endif

W1COV_EXPORT int w1cov_demo_add(int a, int b) {
  int result = a + b;
  if (result & 1) {
    result += 3;
  } else {
    result -= 2;
  }
  return result;
}

W1COV_EXPORT int w1cov_demo_branch(int value) {
  int out = 0;
  if (value < 0) {
    out = -value;
  } else if (value < 10) {
    out = value * 2;
  } else if (value < 100) {
    out = value * 3;
    if (value % 2 == 0) {
      out += 5;
    } else {
      out -= 7;
    }
  } else {
    out = value / 4;
  }
  return out;
}

#if defined(_WIN32) || defined(WIN32)
W1COV_EXPORT DWORD W1COV_CALL w1cov_demo_thread_proc(LPVOID param) {
  int value = (int) (intptr_t) param;
  int sum = 0;
  for (int i = 0; i < value; ++i) {
    sum += w1cov_demo_add(i, value);
    if ((sum & 1) == 0) {
      sum ^= 0x55;
    }
  }
  sum += w1cov_demo_branch(value);
  return (DWORD) sum;
}
#else
W1COV_EXPORT void* W1COV_CALL w1cov_demo_thread_proc(void* param) {
  int value = (int) (intptr_t) param;
  int sum = 0;
  for (int i = 0; i < value; ++i) {
    sum += w1cov_demo_add(i, value);
    if ((sum & 1) == 0) {
      sum ^= 0x55;
    }
  }
  sum += w1cov_demo_branch(value);
  return (void*) (intptr_t) sum;
}
#endif

```

`tests/libraries/w1h00k_interpose_lib.c`:

```c
#if defined(_WIN32)
#include <stdint.h>
#include <windows.h>

#define W1H00K_EXPORT __declspec(dllexport)

W1H00K_EXPORT HMODULE w1h00k_interpose_get_module_handle(void) { return GetModuleHandleA(NULL); }

// Keep a non-trivial prologue so inline hooks have enough bytes to patch.
static volatile uintptr_t g_inline_sink = 0;

__declspec(noinline) W1H00K_EXPORT HMODULE w1h00k_interpose_get_module_handle_inline(void) {
  HMODULE handle = GetModuleHandleA(NULL);
  volatile uintptr_t sink = (uintptr_t) handle;
  sink ^= 0x1234u;
  sink += 0x10u;
  g_inline_sink = sink;
  return handle;
}
#else
#include <stdint.h>
#include <unistd.h>

#define W1H00K_EXPORT __attribute__((visibility("default")))

W1H00K_EXPORT pid_t w1h00k_interpose_getpid(void) { return getpid(); }

// Keep a non-trivial prologue so inline hooks have enough bytes to patch.
static volatile uintptr_t g_inline_sink = 0;

__attribute__((noinline)) W1H00K_EXPORT pid_t w1h00k_interpose_getpid_inline(void) {
  pid_t pid = getpid();
  volatile uintptr_t sink = (uintptr_t) pid;
  sink ^= 0x1234u;
  sink += 0x10u;
  g_inline_sink = sink;
  return pid;
}
#endif

```

`tests/libraries/w1monitor_thread_lib.c`:

```c
#if defined(__linux__)
#define _GNU_SOURCE
#endif

#include <errno.h>
#include <pthread.h>
#include <sched.h>
#include <stdint.h>
#include <stdatomic.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

#if defined(__linux__)
#include <sys/syscall.h>
#endif

#if defined(_WIN32)
#define W1MONITOR_EXPORT __declspec(dllexport)
#elif defined(__APPLE__)
#define W1MONITOR_EXPORT __attribute__((visibility("default")))
#else
#define W1MONITOR_EXPORT __attribute__((visibility("default")))
#endif

struct thread_payload {
  atomic_uint_fast64_t* tid_out;
  const char* name;
};

static void* w1monitor_thread_proc(void* arg) {
  struct thread_payload* payload = (struct thread_payload*) arg;
  uint64_t tid = 0;
#if defined(__linux__)
  tid = (uint64_t) syscall(SYS_gettid);
#endif
  if (payload && payload->tid_out) {
    atomic_store_explicit(payload->tid_out, tid, memory_order_release);
  }
  if (payload && payload->name) {
    (void) pthread_setname_np(pthread_self(), payload->name);
  }
  free(payload);

  struct timespec ts;
  ts.tv_sec = 0;
  ts.tv_nsec = 50 * 1000 * 1000;
  (void) nanosleep(&ts, NULL);

  return NULL;
}

W1MONITOR_EXPORT int w1monitor_spawn_thread(pthread_t* thread_out, uint64_t* tid_out, const char* name) {
  if (!thread_out || !tid_out) {
    return EINVAL;
  }

  atomic_uint_fast64_t tid_storage;
  atomic_init(&tid_storage, 0);

  struct thread_payload* payload = (struct thread_payload*) malloc(sizeof(*payload));
  if (!payload) {
    return ENOMEM;
  }
  payload->tid_out = &tid_storage;
  payload->name = name;

  const int result = pthread_create(thread_out, NULL, w1monitor_thread_proc, payload);
  if (result != 0) {
    free(payload);
    return result;
  }

  while (atomic_load_explicit(&tid_storage, memory_order_acquire) == 0) {
    sched_yield();
  }

  *tid_out = (uint64_t) atomic_load_explicit(&tid_storage, memory_order_acquire);
  return 0;
}

W1MONITOR_EXPORT int w1monitor_join_thread(pthread_t thread) { return pthread_join(thread, NULL); }

```

`tools/README.md`:

```md
# tools

utilities for working with w1tn3ss.

## macos_signing

code signing tools for injection on macos.

### files

- `genkey.sh` - generates code signing certificate
- `sign.sh` - signs executables with debugger entitlements  
- `entitlement.xml` - debugger privilege entitlements

### setup

generate certificate:
```sh
./tools/macos_signing/genkey.sh "w1tn3ss-dev"
```

sign w1tool:
```sh
./tools/macos_signing/sign.sh "w1tn3ss-dev" ./build-macos/w1tool
```

### notes

- installing the certificate requires sudo
- each build of the binary must be signed with the entitlements
- you can't inject as a non-root user on macos without the `com.apple.security.cs.debugger` entitlement

```

`tools/macos_signing/entitlement.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.cs.debugger</key>
    <true/>
</dict>
</plist>
</pre>
```

`tools/macos_signing/genkey.sh`:

```sh
#!/bin/bash

###
# this script generates a code signing certificate and installs it in the system keychain.
# based on: https://github.com/llvm/llvm-project/blob/main/lldb/scripts/macos-setup-codesign.sh
###

# require a certificate name
if [ -z "$1" ]; then
    echo "usage: $0 <certificate name>"
    exit 1
fi

CERT="$1"

function error() {
    echo error: "$@" 1>&2
    exit 1
}

function cleanup {
    # Remove generated files
    rm -f "$TMPDIR/$CERT.tmpl" "$TMPDIR/$CERT.cer" "$TMPDIR/$CERT.key" > /dev/null 2>&1
}

trap cleanup EXIT

# Check if the certificate is already present in the system keychain
security find-certificate -Z -p -c "$CERT" /Library/Keychains/System.keychain > /dev/null 2>&1
if [ $? -eq 0 ]; then
    printf "certificate [%s] has already been generated and installed\n" "$CERT"
    exit 0
fi

# Create the certificate template
cat <<EOF >$TMPDIR/$CERT.tmpl
[ req ]
default_bits       = 2048        # RSA key size
encrypt_key        = no          # Protect private key
default_md         = sha512      # MD to use
prompt             = no          # Prompt for DN
distinguished_name = codesign_dn # DN template
[ codesign_dn ]
commonName         = "$CERT"
[ codesign_reqext ]
keyUsage           = critical,digitalSignature
extendedKeyUsage   = critical,codeSigning
EOF

printf "generating and installing certificate [%s]\n" "$CERT"

# generate a new certificate
openssl req -new -newkey rsa:2048 -x509 -days 3650 -nodes -config "$TMPDIR/$CERT.tmpl" -extensions codesign_reqext -batch -out "$TMPDIR/$CERT.cer" -keyout "$TMPDIR/$CERT.key" > /dev/null 2>&1
# [ $? -eq 0 ] || error something went wrong when generating the certificate
[ $? -eq 0 ] || error openssl failed to generate the certificate

# Install the certificate in the system keychain
sudo security authorizationdb read com.apple.trust-settings.admin > "$TMPDIR/rights"
sudo security authorizationdb write com.apple.trust-settings.admin allow
sudo security add-trusted-cert -d -r trustRoot -p codeSign -k /Library/Keychains/System.keychain "$TMPDIR/$CERT.cer" > /dev/null 2>&1
result=$?
sudo security authorizationdb write com.apple.trust-settings.admin < "$TMPDIR/rights"
# [ $result -eq 0 ] || error something went wrong when installing the certificate
[ $result -eq 0 ] || error security authorizationdb failed to install the certificate

# Install the key for the certificate in the system keychain
sudo security import "$TMPDIR/$CERT.key" -A -k /Library/Keychains/System.keychain > /dev/null 2>&1
# [ $? -eq 0 ] || error something went wrong when installing the key
[ $? -eq 0 ] || error security import failed to install the key

# Kill task_for_pid access control daemon
sudo pkill -f /usr/libexec/taskgated > /dev/null 2>&1

# Exit indicating the certificate is now generated and installed
printf "certificate [%s] has been generated and installed\n" "$CERT"
exit 0
```

`tools/macos_signing/sign.sh`:

```sh
#!/bin/bash

###
# this script signs an executable with a code signing certificate and entitlements.
###

if [ -z "$1" ] || [ -z "$2" ]; then
    echo "usage: $0 <key> <executable> [<entitlements>]"
    exit 1
fi

key="$1"
executable="$2"

if [ -z "$3" ]; then
    # get entitlement.xml from the same directory as this script
    entitlements=$(dirname "$0")/entitlement.xml
else
    entitlements="$3"
fi

printf "signing [%s] with key [%s], entitlements [%s]\n" "$executable" "$key" "$entitlements"

/usr/bin/codesign --entitlements "$entitlements" --force --sign "$key" "$executable"

```

`tools/setup_macos.sh`:

```sh
#!/bin/bash
# setup script for macos development

set -e

CERT_NAME="w1tn3ss-dev"
BUILD_DIR="build-macos"

echo "setting up macos development environment..."

# check if certificate already exists
if security find-certificate -c "$CERT_NAME" >/dev/null 2>&1; then
    echo "certificate '$CERT_NAME' already exists"
else
    echo "generating certificate '$CERT_NAME'..."
    ./tools/macos_signing/genkey.sh "$CERT_NAME"
fi

# check if w1tool exists
if [ -f "$BUILD_DIR/bin/w1tool" ]; then
    echo "signing w1tool..."
    ./tools/macos_signing/sign.sh "$CERT_NAME" "$BUILD_DIR/bin/w1tool"
    echo "w1tool signed successfully"
else
    echo "w1tool not found - build project first with:"
    echo "  cmake -B $BUILD_DIR && cmake --build $BUILD_DIR"
fi

echo "macos setup complete"

```

`tools/windows/run_cmd.py`:

```py
#!/usr/bin/env python3
"""
run_cmd.py: execute a command inside the VS dev shell.
"""
import argparse
import os
import subprocess
import sys
from typing import Iterable, Optional


def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        description="Run a command inside VS dev shell via run_dev_command.ps1"
    )
    p.add_argument(
        "--vs-path",
        help="Optional explicit VS install path (defaults to vswhere lookup)",
    )
    p.add_argument(
        "--devcmd-args",
        default=None,
        help="Arguments passed to Enter-VsDevShell (overrides --arch/--host-arch)",
    )
    p.add_argument(
        "--arch",
        choices=["x86", "x64", "amd64", "arm", "arm64"],
        help="Target architecture for DevShell (default: amd64)",
    )
    p.add_argument(
        "--host-arch",
        choices=["x86", "x64", "amd64", "arm", "arm64"],
        help="Host architecture for DevShell (optional)",
    )
    p.add_argument(
        "--no-cmd",
        action="store_true",
        help="Run via PowerShell Invoke-Expression instead of cmd /c (default uses cmd /c)",
    )
    p.add_argument(
        "--env",
        action="append",
        default=[],
        metavar="KEY=VALUE",
        help="Set an environment variable for the command (may be repeated)",
    )
    p.add_argument(
        "--prepend-path",
        action="append",
        default=[],
        metavar="PATH",
        help="Prepend entries to PATH for the command (may be repeated)",
    )
    p.add_argument(
        "--append-path",
        action="append",
        default=[],
        metavar="PATH",
        help="Append entries to PATH for the command (may be repeated)",
    )
    p.add_argument("--cwd", help="Working directory to run the command in")
    p.add_argument(
        "--print-command",
        action="store_true",
        help="Print the resolved command and DevShell args before running",
    )
    p.add_argument("cmd", nargs=argparse.REMAINDER, help="Command to run (after --)")
    return p


def normalize_arch(value: Optional[str]) -> Optional[str]:
    if value is None:
        return None
    mapping = {
        "x64": "amd64",
        "amd64": "amd64",
        "x86": "x86",
        "arm": "arm",
        "arm64": "arm64",
    }
    return mapping.get(value, value)


def build_devcmd_args(args: argparse.Namespace) -> str:
    if args.devcmd_args is not None:
        return args.devcmd_args
    arch = normalize_arch(args.arch) or "amd64"
    parts = [f"-arch={arch}"]
    host_arch = normalize_arch(args.host_arch)
    if host_arch:
        parts.append(f"-host_arch={host_arch}")
    return " ".join(parts)


def extend_ps_args(ps_args: list[str], flag: str, values: Iterable[str]) -> None:
    for value in values:
        ps_args.extend([flag, value])


def main(argv: list[str]) -> int:
    ap = build_parser()
    args = ap.parse_args(argv)

    if not args.cmd:
        ap.error("Please provide a command to run (after --)")

    # If the user included a leading "--", drop it
    cmd_tokens = args.cmd
    if cmd_tokens and cmd_tokens[0] == "--":
        cmd_tokens = cmd_tokens[1:]
    if not cmd_tokens:
        ap.error("Please provide a command to run (after --)")

    # Build a single command string using Windows list2cmdline for correct quoting under cmd.exe
    command_str = subprocess.list2cmdline(cmd_tokens)

    script_path = os.path.join(os.path.dirname(__file__), "run_dev_command.ps1")
    if not os.path.exists(script_path):
        print(f"error: run_dev_command.ps1 not found at {script_path}", file=sys.stderr)
        return 1

    devcmd_args = build_devcmd_args(args)

    ps_args = [
        "powershell",
        "-ExecutionPolicy",
        "Bypass",
        "-File",
        script_path,
        "-DevCmdArgs",
        devcmd_args,
    ]
    if args.vs_path:
        ps_args.extend(["-VsPath", args.vs_path])
    if args.no_cmd:
        ps_args.append("-UseCmd:$false")
    else:
        ps_args.append("-UseCmd")
    if args.cwd:
        ps_args.extend(["-WorkingDirectory", args.cwd])
    extend_ps_args(ps_args, "-Env", args.env)
    extend_ps_args(ps_args, "-PrependPath", args.prepend_path)
    extend_ps_args(ps_args, "-AppendPath", args.append_path)
    ps_args.extend(["-Command", command_str])

    if args.print_command:
        print("DevShell args:", devcmd_args)
        print("Command:", command_str)

    proc = subprocess.run(ps_args)
    return proc.returncode


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))

```

`tools/windows/run_dev_command.ps1`:

```ps1
param(
  [string]$Command = "",
  [string]$Program = "",
  [object[]]$ProgramArgs = @(),
  [string]$VsPath = "",
  [string]$DevCmdArgs = "-arch=amd64",
  [string[]]$Env = @(),
  [string[]]$PrependPath = @(),
  [string[]]$AppendPath = @(),
  [string]$WorkingDirectory = "",
  [switch]$UseCmd  # when set, run through cmd /c (default); otherwise Invoke-Expression in PowerShell
)

# Helper: enter a VS dev shell (MSVC) then run an arbitrary command. Nothing is hardcoded; VS is discovered via
# vswhere when not provided. Example:
#   powershell -ExecutionPolicy Bypass -File scripts/windows/run_dev_command.ps1 `
#     -Command "cmake --build build-windows-msvc --parallel"

function Resolve-VsPath {
  param([string]$Override)
  if ($Override -and (Test-Path $Override)) {
    return $Override
  }
  $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
  if (-not (Test-Path $vswhere)) {
    Write-Error "vswhere.exe not found and no VsPath provided. Install VS or supply -VsPath."
    exit 1
  }
  $path = & $vswhere -latest -products * -requires Microsoft.Component.MSBuild -property installationPath
  if (-not $path) {
    Write-Error "Unable to locate a Visual Studio installation via vswhere."
    exit 1
  }
  return $path.Trim()
}

function Apply-EnvPairs {
  param([string[]]$Pairs)
  foreach ($pair in $Pairs) {
    if ($pair -match '^(?<key>[^=]+)=(?<value>.*)$') {
      $key = $Matches['key']
      $value = $Matches['value']
      Set-Item -Path ("env:" + $key) -Value $value
    } else {
      Write-Error "Invalid env pair (expected KEY=VALUE): $pair"
      exit 1
    }
  }
}

function Update-Path {
  param(
    [string[]]$Prepend,
    [string[]]$Append
  )
  $prefix = @()
  foreach ($entry in $Prepend) {
    if ($entry -and $entry.Trim() -ne "") {
      $prefix += $entry
    }
  }
  $suffix = @()
  foreach ($entry in $Append) {
    if ($entry -and $entry.Trim() -ne "") {
      $suffix += $entry
    }
  }
  if ($prefix.Count -gt 0) {
    $env:PATH = ($prefix -join ";") + ";" + $env:PATH
  }
  if ($suffix.Count -gt 0) {
    $env:PATH = $env:PATH + ";" + ($suffix -join ";")
  }
}

$vsRoot = Resolve-VsPath -Override $VsPath
$devShellDll = Join-Path $vsRoot "Common7\Tools\Microsoft.VisualStudio.DevShell.dll"
if (-not (Test-Path $devShellDll)) {
  Write-Error "DevShell DLL not found at $devShellDll. Provide a valid -VsPath."
  exit 1
}

Import-Module $devShellDll
Enter-VsDevShell -VsInstallPath $vsRoot -SkipAutomaticLocation -DevCmdArguments $DevCmdArgs

if ($Env.Count -gt 0) {
  Apply-EnvPairs -Pairs $Env
}
if ($PrependPath.Count -gt 0 -or $AppendPath.Count -gt 0) {
  Update-Path -Prepend $PrependPath -Append $AppendPath
}
if ($WorkingDirectory -and $WorkingDirectory.Trim() -ne "") {
  Set-Location -Path $WorkingDirectory
}

if ($Command -and $Command.Trim() -ne "") {
  if ($UseCmd.IsPresent) {
    & cmd.exe /c $Command
  } else {
    Invoke-Expression $Command
  }
  exit $LASTEXITCODE
}

if ($Program -and $Program.Trim() -ne "") {
  & $Program @ProgramArgs
  exit $LASTEXITCODE
}

Write-Host "MSVC dev environment initialized. PATH is updated. Supply -Command or -Program/-ProgramArgs to run a command."

```