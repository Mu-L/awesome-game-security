Project Path: arc_DeNA_mempatch_x0lh7yns

Source Tree:

```txt
arc_DeNA_mempatch_x0lh7yns
├── CMakeLists.txt
├── Entitlements.plist
├── LICENSE
├── README.md
├── jni
│   ├── Address.cpp
│   ├── Address.h
│   ├── Android.mk
│   ├── Application.mk
│   ├── CMakeLists.txt
│   ├── ChangeString.cpp
│   ├── ChangeString.h
│   ├── Config.h
│   ├── Converter.cpp
│   ├── Converter.h
│   ├── FreezeThread.cpp
│   ├── FreezeThread.h
│   ├── LineReader.cpp
│   ├── LineReader.h
│   ├── LineReader_Windows.cpp
│   ├── Memory.h
│   ├── Memory_Darwin.mm
│   ├── Memory_Linux.cpp
│   ├── Memory_Windows.cpp
│   ├── Patcher.cpp
│   ├── Patcher.h
│   ├── SnappedRange.cpp
│   ├── SnappedRange.h
│   ├── Snapshot.h
│   ├── Utility.cpp
│   ├── Utility.h
│   ├── getopt.cpp
│   ├── getopt.h
│   ├── linenoise
│   │   ├── linenoise.cpp
│   │   ├── linenoise.h
│   │   └── linenoise.hpp
│   ├── main.cpp
│   └── test
│       ├── VictimJavaAscii.java
│       ├── victim_ascii.cpp
│       ├── victim_int.cpp
│       └── victim_mass.cpp
└── other-LICENSES
    ├── cpp-linenoise-LICENSE
    └── linenoise-LICENSE

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.15)

project(MemoryPatching VERSION 1.0)

# Android | iOS | Windows | Linux | Darwin
set(CMAKE_SYSTEM_NAME Android)

add_library(cxx_flags INTERFACE)
target_compile_features(cxx_flags INTERFACE cxx_std_14)
if (CMAKE_SYSTEM_NAME STREQUAL "Windows")
target_compile_definitions(cxx_flags INTERFACE
    _FILE_OFFSET_BITS=64
    NOMINMAX)
else()
target_compile_definitions(cxx_flags INTERFACE
    _FILE_OFFSET_BITS=64
    __IS_NDK_BUILD__=1)
endif()
add_subdirectory(jni)
```

`Entitlements.plist`:

```plist
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        <key>com.apple.springboard.debugapplications</key>
        <true/>
        <key>get-task-allow</key>
        <true/>
        <key>task_for_pid-allow</key>
        <true/>
    </dict>
</plist>
```

`LICENSE`:

```

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2024 DeNA Co., Ltd.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
mempatch
========

Android端末で動作しているアプリケーションのメモリデータを書き換えるツールです

注意
---

本プログラムは、脆弱性診断での利用や開発におけるサポートとしての利用を想定したものであるため**リリースされたアプリに対して実行しないでください**


ビルド方法
--------------

ビルドにAndroid NDKが必要となるので、あらかじめインストールしておきます。
インストールが完了したら、Android NDKのndk-buildまたはCMakeでビルドできます。

### ndk-buildを使用してビルドする

```
$ ~/Library/Android/sdk/ndk/VERSION/ndk-build
[arm64-v8a] Install        : mempatch => libs/arm64-v8a/mempatch
[arm64-v8a] Install        : victim_ascii => libs/arm64-v8a/victim_ascii
[arm64-v8a] Install        : victim_int => libs/arm64-v8a/victim_int
.. 略 ...
```

上記コマンドが成功すると、libs/arm64-v8a/mempatchという実行ファイルが生成されます。

### CMakeを使用してビルドする

buildディレクトリを作り、buildディレクトリの中でcmakeコマンドを以下のように実行します(Windows以外)。

```
$ mkdir build
$ cd build
$ cmake -DCMAKE_TOOLCHAIN_FILE=/path/to/ndk/build/cmake/android.toolchain.cmake -DANDROID_ABI=arm64-v8a ..
$ make -j8
```

Windowsの場合、[Ninja](https://github.com/ninja-build/ninja)をインストールしてビルドします。

```
$ mkdir build
$ cd build
$ cmake -G "Ninja" -DCMAKE_TOOLCHAIN_FILE=/path/to/ndk/build/cmake/android.toolchain.cmake -DANDROID_ABI=arm64-v8a ..
$ ninja
```

上記コマンドが成功すると、build/jni/mempatchという実行ファイルが生成されます。

Androidへの組み込み
-------------------

生成されたmempatchをadbコマンドでアプリのディレクトリにコピーしてください。

```
$ adb push libs/arm64-v8a/mempatch /data/local/tmp/mempatch
3381 KB/s (259644 bytes in 0.074s)
$ adb shell
$ run-as com.example.Sample
$ pwd
/data/data/com.example.Sample
$ cp /data/local/tmp/mempatch ./
```

root権限が無い場合、ターゲットアプリがdebugモードになっていないと使えません。
apktoolなどを使ってAndroidManifest.xmlでandroid:debuggable="true"としてインストールしてください。
cpが利用できない場合は、catとchmodを利用してください。

実行
----

ターゲットアプリを実行後、adb shellでAndroidのshellを立ち上げ、run-asでターゲットアプリのユーザになります。
次にターゲットアプリのプロセスIDを指定して、mempatchを起動します。
ターゲットアプリのパッケージ名・プロセスIDはps, pmコマンドなどで調べてください。

```
$ adb shell
$ run-as com.example.Sample

$ ps | grep com.example.Sample
u0_a195   31543 223   711240 136272 ffffffff 40183ab0 S com.example.Sample
$ /data/local/tmp/mempatch -w -p 31543
Without Ptrace Mode

Please Input Command
```

mempatchを起動した後はattach, detach, lookup, filterなどを使用して改竄したいデータのアドレスを見つけ、
changeで改竄を行います。
下記の実行例を参考にしてください。

```
> # 改竄したいデータがUI上で見える場所までアプリを動かす
> # UI上から確認可能な値が10000
> lookup int 10000
Starting memory patching... (mode: lookup)
Process Time: 1194 ms
Memory: 188.22 MB
Range Size: 506
Found Address: 32

Please Input Command
>
> # 何らかの方法で値を操作する
> # その結果、UI上から確認可能な値が9964になった
> filter int 9964
Starting memory patching... (mode: filter)
Process Time: 62 ms
Memory: 188.22 MB
Range Size: 506
Found Address: 1

Please Input Command
>
> # アドレスが十分に絞り込めたので改ざんをする
> change int 1
Starting memory patching... (mode: change)
Change: ec260000(9964) -> 01000000(1) ([anon:libc_malloc])
Dump: dc71ab88-dc71abac (36 byte, [anon:libc_malloc])
  dc71ab88 70ab 58de 70ab 58de 74ab 58de 00f1 4dde  p.X.p.X.t.X...M.
  dc71ab98 0100 0000 c201 0000 c201 0000 d900 0000  ................
  dc71aba8 0000 0000                                ....
Replace Count: 1 / 1
Process Time: 115 ms
Memory: 188.22 MB
Range Size: 506
Found Address: 1

Please Input Command
>
```

詳細なコマンドに関しては`mempatch -h`をするかソースコードを参照してください。

Permission denied(13) : Fail wait pid=5994と言われたら
------
root化端末でメモリ改ざんしようとして上記のエラーが出たらSELinuxのせいです。

```
>attach
...
  Attach 6907 thread
Permission denied(13) : Fail wait pid=5994
argument is invalid or failed to process
```

SELinuxを無効にすれば動きます。

```
root@angler:/data/local/tmp # setenforce 0
```


```

`jni/Address.cpp`:

```cpp
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "Address.h"
#include "Utility.h"

const std::string Address::GetComment(const std::set<Range> &range_set) const {
  for (auto it = range_set.begin(); it != range_set.end(); it++) {
    if (it->GetStart() <= *this && *this < it->GetEnd()) {
      return it->GetComment();
    }
  }
  return "";
}
void Address::Serialize(FILE *fp) const { fprintf(fp, "_%zd", addr_); }
Address Address::DeSerialize(FILE *fp) {
  size_t addr;
  fscanf(fp, "_%zd", &addr);
  return Address(addr);
}

Address Range::Fit(const std::set<Range> &range_set, const Address &address) {
  for (auto it = range_set.begin(); it != range_set.end(); it++) {
    if (it->GetStart() <= address && address < it->GetEnd()) {
      return address;
    }
  }
  return Address(0);
}

Range Range::Fit(const std::set<Range> &range_set, const Range &range) {
  for (auto it = range_set.begin(); it != range_set.end(); it++) {
    if ((it->GetStart() <= range.GetStart() && range.GetStart() < it->GetEnd()) ||
        (range.GetStart() <= it->GetStart() && it->GetStart() < range.GetEnd())) {
      return Range(std::max(it->GetStart().to_i(), range.GetStart().to_i()),
                   std::min(it->GetEnd().to_i(), range.GetEnd().to_i()), range.GetComment());
    }
  }
  return Range(0, 0, "");
}
void Range::Serialize(FILE *fp) const {
  start_.Serialize(fp);
  end_.Serialize(fp);
  Utility::StringSerialize(fp, comment_);
}
Range Range::DeSerialize(FILE *fp) {
  Address start = Address::DeSerialize(fp);
  Address end = Address::DeSerialize(fp);
  std::string comment = Utility::StringDeSerialize(fp);
  return Range(start, end, comment);
}

```

`jni/Address.h`:

```h
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once

#include <assert.h>
#include <set>
#include <stdlib.h>
#include <string>

#include "ChangeString.h"

class Range;
class Address {
public:
  Address() : addr_(0) { ; }
  explicit Address(size_t addr) : addr_(addr) {}

  size_t to_i() const { return addr_; }
  void Add(size_t rhs) { addr_ += rhs; }
  size_t Dist(const Address &rhs) const { return std::min(addr_ - rhs.addr_, rhs.addr_ - addr_); }

  bool operator<(const Address &a) const { return addr_ < a.addr_; }
  bool operator>(const Address &a) const { return addr_ > a.addr_; }
  bool operator<=(const Address &a) const { return addr_ <= a.addr_; }
  bool operator>=(const Address &a) const { return addr_ >= a.addr_; }
  bool operator==(const Address &a) const { return addr_ == a.addr_; }
  bool operator!=(const Address &a) const { return addr_ != a.addr_; }

  void Serialize(FILE *fp) const;
  static Address DeSerialize(FILE *fp);
  const std::string GetComment(const std::set<Range> &range_set) const;

private:
  size_t addr_;
};

// [start, end)
class Range {
public:
  Range() { ; }
  Range(const Address &start, const Address &end) : start_(start), end_(end) { assert(end >= start); }
  Range(const Address &start, const Address &end, const std::string &comment)
      : start_(start), end_(end), comment_(comment) {
    assert(end >= start);
  }
  Range(const size_t start, const size_t end, const std::string &comment)
      : start_(start), end_(end), comment_(comment) {
    assert(end >= start);
  }
  const Address &GetStart() const { return start_; }
  const Address &GetEnd() const { return end_; }
  size_t Size() const { return end_.to_i() - start_.to_i(); }
  const std::string &GetComment() const { return comment_; }

  bool operator<(const Range &rhs) const {
    if (start_ < rhs.start_ || rhs.start_ < start_) {
      return start_ < rhs.start_;
    }
    return end_ < rhs.end_;
  }

  bool IsSuperset(const Range &sub) const {
    return start_.to_i() <= sub.GetStart().to_i() && sub.GetEnd().to_i() <= end_.to_i();
  }
  bool isSubset(const Range &super) const { return super.IsSuperset(*this); }

  // addressやrangeがrange_setの内部に入る様にする
  // range_setの外にある場合はaddressを0にする
  static Address Fit(const std::set<Range> &range_set, const Address &address);
  static Range Fit(const std::set<Range> &range_set, const Range &range);

  void Serialize(FILE *fp) const;
  static Range DeSerialize(FILE *fp);

private:
  Address start_;
  Address end_;
  std::string comment_; // const指定するとデフォルトのコピーコンストラクタが使えなくなる
};
typedef std::set<Range> RangeSet;

class TargetAddress {
public:
  TargetAddress() { ; }
  TargetAddress(const Address &addr, const ChangeString &changestr) : addr_(addr), changestr_(changestr) { ; }
  const Address &GetAddress() const { return addr_; }
  const ChangeString &GetChangeString() const { return changestr_; }
  bool operator<(const TargetAddress &rhs) const {
    if (addr_ < rhs.addr_ || rhs.addr_ < addr_) {
      return addr_ < rhs.addr_;
    }
    return changestr_ < rhs.changestr_;
  }

  void Serialize(FILE *fp) const {
    addr_.Serialize(fp);
    changestr_.Serialize(fp);
  }
  static TargetAddress DeSerialize(FILE *fp) {
    Address addr = Address::DeSerialize(fp);
    ChangeString changestr = ChangeString::DeSerialize(fp);
    return TargetAddress(addr, changestr);
  }

private:
  Address addr_;
  ChangeString changestr_;
};

```

`jni/Android.mk`:

```mk
# Copyright (C) 2009 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_CFLAGS    := -std=c++14 -Wall -g -D_FILE_OFFSET_BITS=64 -D__IS_NDK_BUILD__=1 -O2 -fvisibility=hidden
LOCAL_MODULE    := mempatch
LOCAL_SRC_FILES := main.cpp Patcher.cpp ChangeString.cpp Memory_Linux.cpp Utility.cpp Converter.cpp Address.cpp LineReader.cpp linenoise/linenoise.cpp FreezeThread.cpp
LOCAL_SRC_FILES += SnappedRange.cpp
LOCAL_LDLIBS    := -llog -latomic
LOCAL_CFLAGS    += -fPIE
LOCAL_LDFLAGS   += -fPIE -pie -pthread
include $(BUILD_EXECUTABLE)

include $(CLEAR_VARS)
LOCAL_CFLAGS    := -std=c++14 -Wall -g -D__IS_NDK_BUILD__=1 -O0 -fvisibility=hidden
LOCAL_MODULE    := victim_int
LOCAL_SRC_FILES := test/victim_int.cpp
LOCAL_LDLIBS    := -llog
LOCAL_CFLAGS    += -fPIE
LOCAL_LDFLAGS   += -fPIE -pie
include $(BUILD_EXECUTABLE)

include $(CLEAR_VARS)
LOCAL_CFLAGS    := -std=c++14 -Wall -g -D__IS_NDK_BUILD__=1 -O0 -fvisibility=hidden
LOCAL_MODULE    := victim_ascii
LOCAL_SRC_FILES := test/victim_ascii.cpp
LOCAL_LDLIBS    := -llog
LOCAL_CFLAGS    += -fPIE
LOCAL_LDFLAGS   += -fPIE -pie
include $(BUILD_EXECUTABLE)


```

`jni/Application.mk`:

```mk
APP_STL := c++_static

```

`jni/CMakeLists.txt`:

```txt
set(SOURCE_FILES
    main.cpp
    Patcher.cpp
    ChangeString.cpp
    Utility.cpp
    Converter.cpp
    Address.cpp
    FreezeThread.cpp
    SnappedRange.cpp
)

if (CMAKE_SYSTEM_NAME STREQUAL "Android")
    list(APPEND SOURCE_FILES
        Memory_Linux.cpp
        linenoise/linenoise.cpp
        LineReader.cpp
    )
elseif (CMAKE_SYSTEM_NAME STREQUAL "iOS")
    list(APPEND SOURCE_FILES
        Memory_Darwin.mm
        linenoise/linenoise.cpp
        LineReader.cpp
    )
elseif (CMAKE_SYSTEM_NAME STREQUAL "Windows")
    list(APPEND SOURCE_FILES
        getopt.cpp
        Memory_Windows.cpp
        LineReader_Windows.cpp
    )
elseif (CMAKE_SYSTEM_NAME STREQUAL "Linux")
    list(APPEND SOURCE_FILES
        Memory_Linux.cpp
        linenoise/linenoise.cpp
        LineReader.cpp
    )
elseif (CMAKE_SYSTEM_NAME STREQUAL "Darwin")
    list(APPEND SOURCE_FILES
        Memory_Darwin.mm
        linenoise/linenoise.cpp
        LineReader.cpp
    )
endif()

add_executable(mempatch ${SOURCE_FILES})

set_target_properties(mempatch PROPERTIES
    CXX_VISIBILITY_PRESET hidden
    POSITION_INDEPENDENT_CODE ON)

find_package(Threads REQUIRED)
if (CMAKE_SYSTEM_NAME STREQUAL "Windows")
target_link_libraries(mempatch PUBLIC
    cxx_flags
    Threads::Threads
    psapi)
else()
target_link_libraries(mempatch PUBLIC
    cxx_flags
    Threads::Threads)
endif()

```

`jni/ChangeString.cpp`:

```cpp
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <algorithm>
#include <assert.h>

#include "ChangeString.h"
#include "Utility.h"

ChangeString::ChangeString(const std::string &type, const std::string &value) {
  if (!Init(type, value)) {
    if (type_ == Converter::Type::INVALID) {
      Utility::DebugLog("type '%s' is wrong. Run time error may occur.", type.c_str());
    } else {
      Utility::DebugLog("value's size is different. Run time error may occur.");
    }
  }
}

bool ChangeString::Init(const std::string &type, const std::string &value) {
  type_ = Converter::GetType(type);
  value_ = Converter::GetByte(type_, value);
  if (type_ == Converter::Type::INVALID) {
    return false;
  }
  return true;
}

bool ChangeString::Init(int value) {
  type_ = Converter::Type::INT_LITTLE_ENDIAN;
  value_ = Converter::IntToByte(value);
  return true;
}

void ChangeString::Serialize(FILE *fp) const {
  Utility::StringSerialize(fp, GetTypeString());
  Utility::ByteSerialize(fp, value_);
}

ChangeString ChangeString::DeSerialize(FILE *fp) {
  std::string type = Utility::StringDeSerialize(fp);
  std::vector<uint8_t> value = Utility::ByteDeSerialize(fp);
  return ChangeString(Converter::GetType(type), value);
}

```

`jni/ChangeString.h`:

```h
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once

#include <set>
#include <stdint.h>
#include <string>

#include "Converter.h"

class ChangeString {
public:
  ChangeString() : type_(Converter::Type::INVALID) { ; }
  ChangeString(const Converter::Type &type, const std::vector<uint8_t> &value) : type_(type), value_(value) { ; }
  ChangeString(const std::string &type, const std::string &value);
  ChangeString(int value) { Init(value); }
  bool Init(const std::string &type, const std::string &value);
  bool Init(int value);
  virtual ~ChangeString() { ; }
  const std::vector<uint8_t> &GetRawValue() const { return value_; }
  std::string GetHexValue() const { return Converter::ByteToHex(value_); }
  std::string GetValue() const { return Converter::GetString(type_, value_); }

  size_t Size() const { return value_.size(); }
  const Converter::Type GetType() const { return type_; }
  const std::string GetTypeString() const { return Converter::GetTypeString(type_); }

  static void PrintCommandUsage() {
    fprintf(stderr, "Replace Rule\n");
    fprintf(stderr, "  ascii [value]\n");
    fprintf(stderr, "  utf16 [value]\n");
    fprintf(stderr, "  utf32 [value]\n");
    fprintf(stderr, "  hex [value]\n");
    fprintf(stderr, "  int [value]\n");
    fprintf(stderr, "  int_big [value]\n");
    fprintf(stderr, "  long [value]\n");
    fprintf(stderr, "  long_big [value]\n");
    fprintf(stderr, "  double [value]\n");
    fprintf(stderr, "  double_big [value]\n");
    fprintf(stderr, "  float [value]\n");
    fprintf(stderr, "  float_big [value]\n");
    fprintf(stderr, "  float_fuzzy [value]\n");
  }

  bool operator<(const ChangeString &rhs) const { return value_ < rhs.value_; }
  bool operator>(const ChangeString &rhs) const { return value_ > rhs.value_; }
  bool operator<=(const ChangeString &rhs) const { return value_ <= rhs.value_; }
  bool operator>=(const ChangeString &rhs) const { return value_ >= rhs.value_; }
  bool operator==(const ChangeString &rhs) const { return value_ == rhs.value_; }
  bool operator!=(const ChangeString &rhs) const { return value_ != rhs.value_; }
  void Serialize(FILE *fp) const;
  static ChangeString DeSerialize(FILE *fp);

private:
  Converter::Type type_;
  std::vector<uint8_t> value_; // lookup, filter,
                               // changeなどの処理が終わった後にメモリに入っている値

  std::string GetString(const std::string &str) const;
};

```

`jni/Config.h`:

```h
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#if defined(_WIN32) || defined(_WIN64)
#define STORAGE_PATH "."
#elif defined(__ANDROID__)
#define STORAGE_PATH "/sdcard"
#elif defined(__linux__)
#define STORAGE_PATH "."
#elif defined(__APPLE__)
#define STORAGE_PATH "."
#endif

```

`jni/Converter.cpp`:

```cpp
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <algorithm>
#include <assert.h>
#include <map>

#include "Converter.h"
#include "Utility.h"

namespace Converter {
Type GetType(const std::string &str) {
  std::map<std::string, Type> temp = {
      {"ascii", Type::ASCII},
      {"utf16", Type::UTF16},
      {"utf32", Type::UTF32},
      {"hex", Type::HEX},
      {"int", Type::INT_LITTLE_ENDIAN},
      {"int_big", Type::INT_BIG_ENDIAN},
      {"long", Type::LONG_LITTLE_ENDIAN},
      {"long_big", Type::LONG_BIG_ENDIAN},
      {"double", Type::DOUBLE_LITTLE_ENDIAN},
      {"double_big", Type::DOUBLE_BIG_ENDIAN},
      {"float", Type::FLOAT_LITTLE_ENDIAN},
      {"float_big", Type::FLOAT_BIG_ENDIAN},
      {"float_fuzzy", Type::FLOAT_FUZZY_LITTLE_ENDIAN},
  };
  if (!temp.count(str)) {
    return Type::INVALID;
  }
  return temp[str];
}
std::string GetTypeString(const Type &type) {
  std::map<Type, std::string> temp = {
      {Type::ASCII, "ascii"},
      {Type::UTF16, "utf16"},
      {Type::UTF32, "utf32"},
      {Type::HEX, "hex"},
      {Type::INT_LITTLE_ENDIAN, "int"},
      {Type::INT_BIG_ENDIAN, "int_big"},
      {Type::LONG_LITTLE_ENDIAN, "long"},
      {Type::LONG_BIG_ENDIAN, "long_big"},
      {Type::DOUBLE_LITTLE_ENDIAN, "double"},
      {Type::DOUBLE_BIG_ENDIAN, "double_big"},
      {Type::FLOAT_LITTLE_ENDIAN, "float"},
      {Type::FLOAT_BIG_ENDIAN, "float_big"},
      {Type::FLOAT_FUZZY_LITTLE_ENDIAN, "float_fuzzy"},
  };
  if (!temp.count(type)) {
    return "INVALID";
  }
  return temp[type];
}
std::string GetString(const Type &type, const std::vector<uint8_t> &byte) {
  switch (type) {
  case Type::ASCII:
    return ByteToAscii(byte);
  case Type::UTF16:
    return Utf16ToAscii(byte);
  case Type::UTF32:
    return Utf32ToAscii(byte);
  case Type::HEX:
    return ByteToHex(byte);
  case Type::INT_LITTLE_ENDIAN:
    return ByteToIntstr(byte);
  case Type::INT_BIG_ENDIAN: {
    std::vector<uint8_t> temp_byte = byte;
    std::reverse(temp_byte.begin(), temp_byte.end());
    return ByteToIntstr(temp_byte);
  }
  case Type::LONG_LITTLE_ENDIAN:
    return ByteToLongstr(byte);
  case Type::LONG_BIG_ENDIAN: {
    std::vector<uint8_t> temp_byte = byte;
    std::reverse(temp_byte.begin(), temp_byte.end());
    return ByteToLongstr(temp_byte);
  }
  case Type::DOUBLE_LITTLE_ENDIAN:
    return ByteToDoublestr(byte);
  case Type::DOUBLE_BIG_ENDIAN: {
    std::vector<uint8_t> temp_byte = byte;
    std::reverse(temp_byte.begin(), temp_byte.end());
    return ByteToDoublestr(temp_byte);
  }
  case Type::FLOAT_LITTLE_ENDIAN:
    return ByteToFloatstr(byte);
  case Type::FLOAT_BIG_ENDIAN: {
    std::vector<uint8_t> temp_byte = byte;
    std::reverse(temp_byte.begin(), temp_byte.end());
    return ByteToFloatstr(temp_byte);
  }
  case Type::FLOAT_FUZZY_LITTLE_ENDIAN:
    return ByteToFloatstr(byte);
  default:
    assert(false);
  }
  return "INVALID_TYPE";
}
std::vector<uint8_t> GetByte(const Type &type, const std::string &str) {
  switch (type) {
  case Type::ASCII:
    return AsciiToByte(str);
  case Type::UTF16:
    return AsciiToUtf16(str);
  case Type::UTF32:
    return AsciiToUtf32(str);
  case Type::HEX:
    return HexToByte(str);
  case Type::INT_LITTLE_ENDIAN:
    return IntToByte(atoi(str.c_str()));
  case Type::INT_BIG_ENDIAN: {
    std::vector<uint8_t> ret = IntToByte(atoi(str.c_str()));
    std::reverse(ret.begin(), ret.end());
    return ret;
  }
  case Type::LONG_LITTLE_ENDIAN:
    return LongToByte(atol(str.c_str()));
  case Type::LONG_BIG_ENDIAN: {
    std::vector<uint8_t> ret = LongToByte(atol(str.c_str()));
    std::reverse(ret.begin(), ret.end());
    return ret;
  }
  case Type::DOUBLE_LITTLE_ENDIAN:
    return DoubleToByte(atof(str.c_str()));
  case Type::DOUBLE_BIG_ENDIAN: {
    std::vector<uint8_t> ret = DoubleToByte(atof(str.c_str()));
    std::reverse(ret.begin(), ret.end());
    return ret;
  }
  case Type::FLOAT_LITTLE_ENDIAN:
    return FloatToByte(atof(str.c_str()));
  case Type::FLOAT_BIG_ENDIAN: {
    std::vector<uint8_t> ret = FloatToByte(atof(str.c_str()));
    std::reverse(ret.begin(), ret.end());
    return ret;
  }
  case Type::FLOAT_FUZZY_LITTLE_ENDIAN:
    return FloatToByte(atof(str.c_str()));
  default:
    break;
  }
  return AsciiToByte("INVALID_TYPE");
}

std::vector<uint8_t> AsciiToByte(const std::string &str) {
  return std::vector<uint8_t>(str.data(), str.data() + str.size());
}
std::string ByteToAscii(const std::vector<uint8_t> &byte) {
  return std::string(byte.data(), byte.data() + byte.size());
}

std::vector<uint8_t> HexToByte(const std::string &hex) {
  std::vector<uint8_t> ret;
  int v = 0;
  int cnt = 0;
  for (auto it = hex.begin(); it != hex.end(); it++) {
    int c = tolower(*it);
    if (isspace(c)) {
      continue;
    }
    if (('0' <= c && c <= '9') && ('a' <= c && c <= 'f')) {
      Utility::DebugLog("'%s' is not hex string", hex.c_str());
      return AsciiToByte("");
    }
    v = v * 16 + (isdigit(c) ? c - '0' : c - 'a' + 10);
    cnt++;
    if (cnt % 2 == 0) {
      ret.emplace_back(v);
      v = 0;
    }
  }
  return ret;
}

std::string ByteToHex(const std::vector<uint8_t> &byte) {
  std::string ret;
  for (auto it = byte.begin(); it != byte.end(); it++) {
    int b = (*it & 0x000000ff);
    int vs[2] = {b / 16, b % 16};
    for (int i = 0; i < 2; i++) {
      int c = (vs[i] < 10 ? vs[i] + '0' : vs[i] + 'a' - 10);
      ret.push_back(c);
    }
  }
  return ret;
}

// little endianで返す
std::vector<uint8_t> IntToByte(int v) { return std::vector<uint8_t>((uint8_t *)&v, ((uint8_t *)&v) + 4); }

// little endianを想定
int ByteToInt(const std::vector<uint8_t> &byte) { return *(int *)byte.data(); }

// little endianを想定
std::string ByteToIntstr(const std::vector<uint8_t> &byte) {
  int v = ByteToInt(byte);
  char str[20];
  snprintf(str, 19, "%d", v);
  std::string ret = str;
  return ret;
}

std::vector<uint8_t> LongToByte(long v) {
  std::vector<uint8_t> ret;
  for (int i = 0; i < (int)sizeof(long); i++) {
    ret.emplace_back(v & 0x000000ff);
    v >>= 8;
  }
  return ret;
}

// little endianを想定
long ByteToLong(const std::vector<uint8_t> &byte) {
  long ret = 0;
  for (int i = 0; i < (int)sizeof(long); i++) {
    ret |= (byte[i] & 0xff) << (i * 8);
  }
  return ret;
}

// little endianを想定
std::string ByteToLongstr(const std::vector<uint8_t> &byte) {
  long v = ByteToLong(byte);
  char str[20];
  snprintf(str, 19, "%ld", v);
  std::string ret = str;
  return ret;
}

// little endianで返す
std::vector<uint8_t> DoubleToByte(double v) {
  union DoubleByte {
    double d;
    uint8_t cs[sizeof(double)];
  };
  DoubleByte x;
  x.d = v;
  std::vector<uint8_t> ret;
  for (int i = 0; i < (int)sizeof(double); i++) {
    ret.emplace_back(x.cs[i] & 0xff);
  }
  return ret;
}

// little endianを想定
double ByteToDouble(const std::vector<uint8_t> &byte) {
  union DoubleByte {
    double d;
    uint8_t cs[sizeof(double)];
  };
  DoubleByte x;
  for (int i = 0; i < (int)sizeof(double); i++) {
    x.cs[i] = byte[i] & 0x000000ff;
  }
  return x.d;
}

// little endianを想定
std::string ByteToDoublestr(const std::vector<uint8_t> &byte) {
  double v = ByteToDouble(byte);
  char str[50];
  snprintf(str, 49, "%.8f", v);
  std::string ret = str;
  return ret;
}

// little endianで返す
std::vector<uint8_t> FloatToByte(float v) {
  union FloatByte {
    float d;
    uint8_t cs[sizeof(float)];
  };
  FloatByte x;
  x.d = v;
  std::vector<uint8_t> ret;
  for (int i = 0; i < (int)sizeof(float); i++) {
    ret.emplace_back(x.cs[i] & 0xff);
  }
  return ret;
}

// little endianを想定
float ByteToFloat(const std::vector<uint8_t> &byte) {
  union FloatByte {
    float d;
    uint8_t cs[sizeof(float)];
  };
  FloatByte x;
  for (int i = 0; i < (int)sizeof(float); i++) {
    x.cs[i] = byte[i] & 0x000000ff;
  }
  return x.d;
}

// little endianを想定
std::string ByteToFloatstr(const std::vector<uint8_t> &byte) {
  float v = ByteToFloat(byte);
  char str[50];
  snprintf(str, 49, "%.8f", v);
  std::string ret = str;
  return ret;
}

// big endianを想定
std::vector<uint8_t> AsciiToUtf16(const std::string &str) {
  std::vector<uint8_t> ret;
  for (auto it = str.begin(); it != str.end(); it++) {
    ret.emplace_back('\0');
    ret.emplace_back(*it);
  }
  return ret;
}

// big endianを想定
std::string Utf16ToAscii(const std::vector<uint8_t> &byte) {
  std::string ret;
  int cnt = 0;
  for (auto it = byte.begin(); it != byte.end(); it++) {
    cnt++;
    if (cnt % 2 == 0) {
      ret.push_back(*it);
    }
  }
  return ret;
}

// big endianを想定
std::vector<uint8_t> AsciiToUtf32(const std::string &str) {
  std::vector<uint8_t> ret;
  for (auto it = str.begin(); it != str.end(); it++) {
    ret.emplace_back('\0');
    ret.emplace_back('\0');
    ret.emplace_back('\0');
    ret.emplace_back(*it);
  }
  return ret;
}

// big endianを想定
std::string Utf32ToAscii(const std::vector<uint8_t> &byte) {
  std::string ret;
  int cnt = 0;
  for (auto it = byte.begin(); it != byte.end(); it++) {
    cnt++;
    if (cnt % 4 == 0) {
      ret.push_back(*it);
    }
  }
  return ret;
}

std::vector<uint8_t> RawByteToByte(const uint8_t *byte, size_t len) { return std::vector<uint8_t>(byte, byte + len); }
}; // namespace Converter

// #include <iostream>
// int main() {
//     // double hoge = 1.1;
//     int hoge = 123456789;
//     std::vector<uint8_t> byte = Converter::IntToByte(hoge);
//     for (int i = 0; i < sizeof(hoge); i++) {
//         printf("%02xd", byte[i] & 0xff);
//     }
//     puts("");
//     std::cout << Converter::ByteToIntstr(byte) << std::endl;
//     std::cout << Converter::ByteToInt(byte) << std::endl;
// }

// #include <iostream>
// int main() {
// 	std::string abcd = "abcd";
// 	std::string utf16_abcd, utf16, rev_utf16;
//     ChangeString str;
//     str.HexToByte("0061006200630064", utf16, 0x00);
// 	str.AsciiToUtf16(abcd, utf16_abcd, 0x00);
// 	str.Utf16ToAscii(utf16, rev_utf16, 0x00);
//     ChangeString str2("utf16", abcd, abcd);
//     std::cout << str2.Compare(utf16_abcd.c_str()) << std::endl;
//     std::cout << str2.before_ << std::endl;
//
// 	assert(utf16_abcd == utf16);
// 	assert(rev_utf16 == abcd);
//
// 	std::string hex_abcd = "61626364";
// 	std::string abcd = "abcd";
// 	int int_abcd = 1684234849;
// 	std::cout << HexToByte(hex_abcd) << std::endl;
// 	std::cout << ByteToHex(abcd) << std::endl;
// 	std::cout << int_to_byte(int_abcd) << std::endl;
// 	std::cout << byte_to_int(abcd) << std::endl;
//
// 	std::string sample1 = "00102030405060708090ff";
// 	std::string str = hex_to_byte(sample1);
// 	int anss[11] = { 0, 16, 32, 48, 64, 80, 96, 112, 128, 144, 255 };
// 	for (int i = 0; i < 11; i++) {
// 		printf("%d %d\n", (unsigned char)str[i], anss[i]);
// 		assert((str[i] & 0x000000ff) == anss[i]);
// 	}
// 	std::string sample2 = byte_to_hex(str);
// 	std::cout << sample1 << " " << sample2 << std::endl;
// 	assert(sample1 == sample2);
//
// 	int large1 = 1e+9 + 7;
// 	std::string converted = int_to_byte(large1);
// 	int large2 = byte_to_int(converted);
// 	std::cout << large1 << " " << large2 << std::endl;
// 	assert(large1 == large2);
//
// 	std::string utf16_abcd = hex_to_byte("0061006200630064");
// 	std::string utf16 = ascii_to_utf16(abcd);
// 	std::string rev_utf16 = utf16_to_ascii(utf16);
// 	assert(utf16_abcd == utf16);
// 	assert(rev_utf16 == abcd);
//
// 	std::string utf32_abcd =
// hex_to_byte("00000061000000620000006300000064"); 	std::string utf32 =
// ascii_to_utf32(abcd); 	std::string rev_utf32 = utf32_to_ascii(utf32);
// 	assert(utf32_abcd == utf32);
// 	assert(rev_utf32 == abcd);
// }

```

`jni/Converter.h`:

```h
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once

#include <stdint.h>
#include <string>
#include <vector>

namespace Converter {
enum class Type {
  ASCII,
  UTF16,
  UTF32,
  HEX,
  INT_LITTLE_ENDIAN,
  INT_BIG_ENDIAN,
  LONG_LITTLE_ENDIAN,
  LONG_BIG_ENDIAN,
  DOUBLE_LITTLE_ENDIAN,
  DOUBLE_BIG_ENDIAN,
  FLOAT_LITTLE_ENDIAN,
  FLOAT_BIG_ENDIAN,
  FLOAT_FUZZY_LITTLE_ENDIAN,
  INVALID,
};
Type GetType(const std::string &str);
std::string GetTypeString(const Type &type);

std::string GetString(const Type &type, const std::vector<uint8_t> &byte);
std::vector<uint8_t> GetByte(const Type &type, const std::string &str);

std::vector<uint8_t> AsciiToByte(const std::string &str);
std::string ByteToAscii(const std::vector<uint8_t> &byte);

std::vector<uint8_t> HexToByte(const std::string &hex);
std::string ByteToHex(const std::vector<uint8_t> &byte);

// little endianで返す
std::vector<uint8_t> IntToByte(int v);
int ByteToInt(const std::vector<uint8_t> &byte);
int HexToInt(const std::string &str);
std::string ByteToIntstr(const std::vector<uint8_t> &byte);

// little endianを想定
std::vector<uint8_t> LongToByte(long v);
long ByteToLong(const std::vector<uint8_t> &byte);
std::string ByteToLongstr(const std::vector<uint8_t> &byte);

// little endianを想定
std::vector<uint8_t> DoubleToByte(double v);
double ByteToDouble(const std::vector<uint8_t> &byte);
std::string ByteToDoublestr(const std::vector<uint8_t> &byte);

// little endianを想定
std::vector<uint8_t> FloatToByte(float v);
float ByteToFloat(const std::vector<uint8_t> &byte);
std::string ByteToFloatstr(const std::vector<uint8_t> &byte);

// big endianを想定
std::vector<uint8_t> AsciiToUtf16(const std::string &str);
std::string Utf16ToAscii(const std::vector<uint8_t> &byte);
std::vector<uint8_t> AsciiToUtf32(const std::string &str);
std::string Utf32ToAscii(const std::vector<uint8_t> &byte);

// Readとかから取ったやつの変換
std::vector<uint8_t> RawByteToByte(const uint8_t *byte, size_t len);
}; // namespace Converter

```

`jni/FreezeThread.cpp`:

```cpp
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#if defined(_WIN32) || defined(_WIN64)
#include <windows.h>
#define usleep(usec) Sleep((usec) / 1000) // 1ミリ秒以上のスリープをサポート
#else
#include <unistd.h>
#endif
#include "FreezeThread.h"
#include "Memory.h"
#include "Utility.h"

void FreezeThread::Start() {
  assert(!terminate_flag_.load());
  freeze_thread_ = std::thread(&FreezeThread::ThreadFunction, this);
  // プロンプトの>よりもStart Freezeの表示をを先にしたいので少し待つ
  usleep(10 * 1000);
}

void FreezeThread::Terminate() {
  if (terminate_flag_.load()) {
    return;
  }
  terminate_flag_.store(true);
  freeze_thread_.join();
}

void FreezeThread::ThreadFunction() const {
  const Address address = target_.GetAddress();
  const ChangeString change_string = target_.GetChangeString();
  const size_t start = address.to_i();
  const size_t end = address.to_i() + change_string.Size();
  Range range = Range(start, end, "");
  std::vector<uint8_t> value_ = change_string.GetRawValue();
  Utility::DebugLog("Start Freeze Thread\n    %zx : %s (%s)", start, change_string.GetValue().c_str(),
                    change_string.GetTypeString().c_str());
  // teminateするか書き込みに失敗するまで実行する
  while (!terminate_flag_.load()) {
    size_t size = ptrace_->Write(range, value_.data(), true);
    if (size != change_string.Size()) {
      break;
    }
    usleep(1000);
  }
  Utility::DebugLog("Terminate Freeze Thread\n    %zx : %s (%s)", start, change_string.GetValue().c_str(),
                    change_string.GetTypeString().c_str());
}

```

`jni/FreezeThread.h`:

```h
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once

#include <atomic>
#include <future>
#include <memory>

#include "Address.h"
#include "Memory.h"

class FreezeThread {
public:
  FreezeThread() = delete;
  FreezeThread(FreezeThread const &) = delete;
  FreezeThread &operator=(FreezeThread const &) = delete;
  FreezeThread(std::shared_ptr<Memory> &ptrace, const TargetAddress &target)
      : ptrace_(ptrace), target_(target), terminate_flag_(false) {
    ;
  }
  ~FreezeThread() { Terminate(); }
  void Start();
  void Terminate();

private:
  void ThreadFunction() const;

  const std::shared_ptr<const Memory> ptrace_;
  std::thread freeze_thread_;
  const TargetAddress target_;
  std::atomic<bool> terminate_flag_;
};

```

`jni/LineReader.cpp`:

```cpp
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <string.h>

#include "Config.h"
#include "LineReader.h"
#include "Utility.h"
#include "linenoise/linenoise.h"
std::map<std::string, LineReader::PatcherCommandFunc> LineReader::commands;

void completion(const char *buf, linenoiseCompletions *lc) {
  // TODO
  // if (buf[0] == 'h') {
  //     linenoiseAddCompletion(lc,"hello");
  //     linenoiseAddCompletion(lc,"hello there");
  // }
}

void LineReader::InitCommandMap() {
  commands.clear();

  commands["attach"] = &Patcher::Attach;
  commands["detach"] = &Patcher::Detach;

  commands["clear"] = &Patcher::Clear;
  commands["lookup"] = &Patcher::Process;
  commands["filter"] = &Patcher::Process;
  commands["pair_filter"] = &Patcher::PairFilter;
  commands["change"] = &Patcher::Process;
  commands["replace"] = &Patcher::Replace;
  commands["freeze"] = &Patcher::Freeze;
  commands["freeze_terminate"] = &Patcher::FreezeTerminate;
  commands["diff"] = &Patcher::Diff;

  commands["scope"] = &Patcher::Scope;
  commands["save"] = &Patcher::Save;
  commands["load"] = &Patcher::Load;
  commands["result"] = &Patcher::Result;
  commands["dump"] = &Patcher::Dump;
  commands["dumpall"] = &Patcher::DumpAll;
  commands["help"] = &Patcher::Help;
  commands["exit"] = &Patcher::Exit;
  commands["quit"] = &Patcher::Exit;

  commands["l"] = commands["lookup"];
  commands["f"] = commands["filter"];
  commands["c"] = commands["change"];
}

bool LineReader::Dispatch(Patcher &patcher, bool windows) {
  InitCommandMap();

  /* Set the completion callback. This will be called every time the
   * user uses the <tab> key. */
  linenoiseSetCompletionCallback(completion);

  /* Load history from file. The history file is just a plain text file
   * where entries are separated by newlines. */
  std::string history_path = std::string(STORAGE_PATH) + "/mempatch_history.txt";

  linenoiseHistoryLoad(history_path.c_str()); /* Load the history at startup */

  printf("\nPlease Input Command\n");

  char *buffer = nullptr;
  while ((buffer = GetLine(windows)) != nullptr) {
    linenoiseHistoryAdd(buffer);                /* Add to the history. */
    linenoiseHistorySave(history_path.c_str()); /* Save the history on disk. */
    std::stringstream sin(buffer);
    free(buffer);
    buffer = nullptr;

    // コマンドを取得
    std::string command;
    if (!(sin >> command)) {
      continue;
    }

    // コマンドを確認して処理を実行
    for (auto it = command.begin(); it != command.end(); it++) {
      *it = tolower(*it);
    } // range based forが使えない
    if (command.size() == 0 || command[0] == '#' || command[0] == '/') {
      continue;
    } else if (!commands.count(command)) {
      Utility::DebugLog("command '%s' is invalid", command.c_str());
      continue;
    } else {
      if (!(patcher.*commands[command])(command, sin)) {
        Utility::DebugLog("argument is invalid or failed to process");
      }
      if (commands[command] == commands["exit"]) {
        break;
      }
    }
  }
  return true;
}

char *LineReader::GetLine(bool windows) {
  if (!windows) {
    return linenoise("> ");
  }
  printf("> ");
  fflush(stdout);
  const int MAX_BUFFER = 4096;
  char buf[MAX_BUFFER];
  if (fgets(buf, MAX_BUFFER, stdin) == nullptr) {
    return nullptr;
  }
  int len = strlen(buf);
  while (len && (buf[len - 1] == '\n' || buf[len - 1] == '\r')) {
    len--;
    buf[len] = '\0';
  }
  return strdup(buf);
}

```

`jni/LineReader.h`:

```h
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once

#include <map>
#include <sstream>
#include <string>

#include "Patcher.h"

class LineReader {
public:
  static bool Dispatch(Patcher &patcher, bool windows);

private:
  static void InitCommandMap();
  static char *GetLine(bool windows);

  // Patcherのコマンドを実行するメンバ関数への関数ポインタの定義
  typedef bool (Patcher::*PatcherCommandFunc)(const std::string &, std::stringstream &);
  static std::map<std::string, PatcherCommandFunc> commands;
};

```

`jni/LineReader_Windows.cpp`:

```cpp
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "Config.h"
#include "LineReader.h"
#include "Utility.h"
#include "linenoise/linenoise.hpp"
#include <iostream>
#include <string.h>


std::map<std::string, LineReader::PatcherCommandFunc> LineReader::commands;

void completion(const std::string &buf, std::vector<std::string> &completions) {
  // TODO
}

void LineReader::InitCommandMap() {
  commands.clear();

  commands["attach"] = &Patcher::Attach;
  commands["detach"] = &Patcher::Detach;

  commands["clear"] = &Patcher::Clear;
  commands["lookup"] = &Patcher::Process;
  commands["filter"] = &Patcher::Process;
  commands["pair_filter"] = &Patcher::PairFilter;
  commands["change"] = &Patcher::Process;
  commands["replace"] = &Patcher::Replace;
  commands["freeze"] = &Patcher::Freeze;
  commands["freeze_terminate"] = &Patcher::FreezeTerminate;
  commands["diff"] = &Patcher::Diff;

  commands["scope"] = &Patcher::Scope;
  commands["save"] = &Patcher::Save;
  commands["load"] = &Patcher::Load;
  commands["result"] = &Patcher::Result;
  commands["dump"] = &Patcher::Dump;
  commands["dumpall"] = &Patcher::DumpAll;
  commands["help"] = &Patcher::Help;
  commands["exit"] = &Patcher::Exit;
  commands["quit"] = &Patcher::Exit;

  commands["l"] = commands["lookup"];
  commands["f"] = commands["filter"];
  commands["c"] = commands["change"];
}

bool LineReader::Dispatch(Patcher &patcher, bool windows) {
  InitCommandMap();

  // Set the completion callback
  linenoise::SetCompletionCallback(completion);

  // Load history from file
  std::string history_path = std::string(STORAGE_PATH) + "/mempatch_history.txt";
  linenoise::LoadHistory(history_path.c_str());

  std::cout << "\nPlease Input Command\n";

  while (true) {
    std::string line;
    if (!windows) {
      if (!linenoise::Readline("> ", line)) {
        break;
      }
    } else {
      std::cout << "> ";
      std::getline(std::cin, line);
      if (line.empty()) {
        continue;
      }
    }

    linenoise::AddHistory(line.c_str());
    linenoise::SaveHistory(history_path.c_str());
    std::stringstream sin(line);

    // コマンドを取得
    std::string command;
    if (!(sin >> command)) {
      continue;
    }

    // コマンドを確認して処理を実行
    for (auto &c : command) {
      c = tolower(c);
    }

    if (command.empty() || command[0] == '#' || command[0] == '/') {
      continue;
    } else if (!commands.count(command)) {
      Utility::DebugLog("command '%s' is invalid", command.c_str());
      continue;
    } else {
      if (!(patcher.*commands[command])(command, sin)) {
        Utility::DebugLog("argument is invalid or failed to process");
      }
      if (commands[command] == commands["exit"]) {
        break;
      }
    }
  }
  return true;
}

char *LineReader::GetLine(bool windows) {
  std::string line;
  if (!windows) {
    if (linenoise::Readline("> ", line)) {
      return strdup(line.c_str());
    }
  } else {
    std::cout << "> ";
    std::getline(std::cin, line);
    return strdup(line.c_str());
  }
  return nullptr;
}

```

`jni/Memory.h`:

```h
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once

#include <memory>
#include <set>
#include <stdint.h>

#include "Address.h"

class Memory {
public:
  Memory() : pid_(-1), attached_(false) { ; }
  explicit Memory(int pid, bool without_ptrace) : pid_(pid), attached_(false), without_ptrace_(without_ptrace) { ; }
  virtual ~Memory() {
    if (pid_ != -1) {
      Detach();
    }
    cache_.reset();
  }

  int GetPid() const { return pid_; }
  bool IsAttached() const { return attached_; }
  bool Attach();
  bool Detach();
  // size_t ReadByPeekData(uint8_t *dest, const Address &src) const;
  // size_t ReadByPeekData(uint8_t *dest, const Range &src) const;
  size_t Read(uint8_t *dest, const Range &src) const;
  size_t ReadWithCache(uint8_t *dest, const Range &src, const Range &parent_range) const;
  size_t WriteByPokeData(const Address &dest, long value) const;
  size_t WriteByPokeData(const Range &dest, const uint8_t *src, bool freeze_request) const;
  size_t Write(const Range &dest, const uint8_t *src, bool freeze_request) const;
  void Dump(const Range &src) const;
  bool GenerateMaps(std::stringstream &ss);

private:
  int pid_;
  bool attached_;
  bool without_ptrace_;
  std::set<int> thread_ids_;

  // cacheはAttachした際にclearされる
  mutable Range cache_range_;
  mutable std::unique_ptr<uint8_t[]> cache_;

  void LoadThreadIDs();
  void ClearCache();
};

```

`jni/Memory_Darwin.mm`:

```mm
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#define _LARGEFILE64_SOURCE

#include "Memory.h"
#include "Utility.h"
#include <assert.h>
#include <dirent.h> // opendir用
#include <dlfcn.h>
#include <errno.h>
#include <fcntl.h>
#include <fstream>
#include <mach-o/dyld_images.h>
#include <mach/mach.h>
#include <mach/vm_map.h>
#include <mach/vm_region.h>
#include <memory>
#include <sstream>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

extern "C" kern_return_t mach_vm_read_overwrite(vm_map_t, mach_vm_address_t, mach_vm_size_t, mach_vm_address_t,
                                                mach_vm_size_t *);

extern "C" kern_return_t mach_vm_write(vm_map_t, mach_vm_address_t, vm_offset_t, mach_msg_type_number_t);

bool Memory::Attach() {
  assert(pid_ >= 0);
  ClearCache();
  attached_ = true;
  return true;
}

bool Memory::Detach() {
  attached_ = false;
  return true;
}

size_t Memory::Read(uint8_t *dest, const Range &src) const {
  assert(pid_ >= 0);
  assert(attached_);
  size_t n = src.Size();
  kern_return_t kr;
  mach_port_t task;

  kr = task_for_pid(mach_task_self(), pid_, &task);
  if (kr != KERN_SUCCESS) {
    Utility::DebugLog("*** Error: task_for_pid failed ***\nPID: %d\n%s (errno=%d)\n", pid_, strerror(errno), errno);
    return false;
  }
  mach_vm_size_t out_size;
  kr = mach_vm_read_overwrite(task, src.GetStart().to_i(), n, (mach_vm_size_t)dest, &out_size);
  if (kr != KERN_SUCCESS) {
    Utility::DebugLog("*** Error : Memory Read is failed ***\nAddress: %zx\n%s (errno=%d)\n", src.GetStart().to_i(),
                      strerror(errno), errno);
    return 0;
  } else if (out_size != n) {
    Utility::DebugLog("*** Error : Memory Read is failed ***\nExpected length: "
                      "%zu\nRead length: %zu\nAddress: %zx\n",
                      n, out_size, src.GetStart().to_i());
  }

  return out_size;
}

size_t Memory::ReadWithCache(uint8_t *dest, const Range &src, const Range &parent_range) const {
  assert(pid_ >= 0);
  assert(attached_);
  assert(parent_range.IsSuperset(src));
  if (parent_range.GetStart().to_i() != cache_range_.GetStart().to_i() ||
      parent_range.GetEnd().to_i() != cache_range_.GetEnd().to_i()) {
    cache_range_ = parent_range;
    cache_ = std::make_unique<uint8_t[]>(cache_range_.Size());
    Read(cache_.get(), parent_range);
  }

  size_t offset = src.GetStart().to_i() - cache_range_.GetStart().to_i();
  memcpy(dest, cache_.get() + offset, src.Size());

  return src.Size();
}

size_t Memory::WriteByPokeData(const Address &dest, long value) const { return 0; }

size_t Memory::WriteByPokeData(const Range &dest, const uint8_t *src, bool freeze_request) const { return 0; }

size_t Memory::Write(const Range &dest, const uint8_t *src, bool freeze_request) const {
  assert(pid_ >= 0);
  assert(attached_ || freeze_request);
  mach_port_t task;
  kern_return_t kr;
  size_t n = dest.GetEnd().to_i() - dest.GetStart().to_i();

  kr = task_for_pid(mach_task_self(), pid_, &task);
  if (kr != KERN_SUCCESS) {
    Utility::DebugLog("*** Error: task_for_pid failed ***\nPID: %d\n%s (errno=%d)\n", pid_, strerror(errno), errno);
    return false;
  }
  kr = mach_vm_write(task, dest.GetStart().to_i(), (vm_offset_t)src, n);
  if (kr != KERN_SUCCESS) {
    Utility::DebugLog("*** Error : Memory Write is failed ***\nAddress: %zx\n%s (errno=%d)\n", dest.GetStart().to_i(),
                      strerror(errno), errno);
    return 0;
  }

  return n;
}

void Memory::Dump(const Range &src) const {
  assert(pid_ >= 0);
  assert(attached_);
  size_t n = src.GetEnd().to_i() - src.GetStart().to_i();
  if (n == 0) {
    Utility::DebugLog("Dump 0-0 length:0(NaN%%)");
    return;
  }
  const std::unique_ptr<uint8_t[]> temp_p = std::make_unique<uint8_t[]>(n);
  size_t l = Read(temp_p.get(), src);
  Utility::DebugLog("%s",
                    Utility::HexDump(src.GetStart().to_i(), src.GetComment().c_str(), temp_p.get(), l, 2).c_str());
}

void Memory::LoadThreadIDs() {}

void Memory::ClearCache() {
  cache_range_ = Range();
  cache_.reset();
}

bool Memory::GenerateMaps(std::stringstream &ss) {
  assert(pid_ >= 0);
  mach_port_t task;
  vm_address_t address = 0;
  vm_size_t size = 0;
  kern_return_t kr;
  natural_t depth = 0;

  kr = task_for_pid(mach_task_self(), pid_, &task);
  if (kr != KERN_SUCCESS) {
    Utility::DebugLog("*** Error: task_for_pid failed ***\nPID: %d\n%s (errno=%d)\n", pid_, strerror(errno), errno);
    return false;
  }

  while (true) {
    vm_region_submap_info_64 info;
    mach_msg_type_number_t info_count = VM_REGION_SUBMAP_INFO_COUNT_64;

    // メモリリージョン情報を取得
    kr = vm_region_recurse_64(task, &address, &size, &depth, (vm_region_info_64_t)&info, &info_count);
    if (kr != KERN_SUCCESS) {
      break; // エラーが発生した場合はbreak
    }

    // /proc/pid/maps形式で出力をフォーマット
    ss << std::hex << address << "-" << (address + size) << " " << ((info.protection & VM_PROT_READ) ? 'r' : '-')
       << ((info.protection & VM_PROT_WRITE) ? 'w' : '-') << ((info.protection & VM_PROT_EXECUTE) ? 'x' : '-') << " "
       << std::setw(8) << std::setfill('0') << info.offset << " " // オフセット
       << "00:00 "                                                // デバイス
       << "0 ";                                                   // inode

    if (info.is_submap) {
      depth += 1; // サブマップの場合はdepthを増加
    } else {
      address += size; // 次のリージョンに移動
    }

    ss << "" << std::endl;
  }

  return true;
}

```

`jni/Memory_Linux.cpp`:

```cpp
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#define _LARGEFILE64_SOURCE

#include "Memory.h"
#include "Utility.h"
#include <assert.h>
#include <dirent.h> // opendir用
#include <errno.h>
#include <fcntl.h>
#include <memory>
#include <sstream>
#include <stdlib.h>
#include <string.h>
#include <sys/ptrace.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

// 全スレッドをATTACHしてからwaitする
// 使い方が合っているかどうかは不明
bool Memory::Attach() {
  assert(pid_ >= 0);
  ClearCache();
  if (without_ptrace_ || attached_) {
    attached_ = true;
    return true;
  }
  LoadThreadIDs();
  Utility::DebugLog("Start Attach %d", pid_);
  for (auto it = thread_ids_.begin(); it != thread_ids_.end(); it++) {
    if (ptrace(PTRACE_ATTACH, *it, nullptr, nullptr)) {
      Utility::PrintErrnoString("Can't attach pid=%d tid=%d", pid_, *it);
      Detach();
      return false;
    }
    Utility::DebugLog("  Attach %d thread", *it);
  }
  int status = 0;
  if (waitpid(-1, &status, __WALL) == -1) {
    Utility::PrintErrnoString("Fail wait pid=%d", pid_);
    return false;
  }
  attached_ = true;
  Utility::DebugLog("Attach  %d", pid_);
  return true;
}

bool Memory::Detach() {
  if (without_ptrace_ || !attached_) {
    attached_ = false;
    return true;
  }
  for (auto it = thread_ids_.begin(); it != thread_ids_.end(); it++) {
    if (ptrace(PTRACE_DETACH, *it, nullptr, nullptr)) {
      Utility::PrintErrnoString("Can't detach pid=%d, tid=%d", pid_, *it);
    }
  }
  attached_ = false;
  Utility::DebugLog("Detach %d", pid_);
  return true;
}

size_t Memory::Read(uint8_t *dest, const Range &src) const {
  assert(pid_ >= 0);
  assert(attached_);
  size_t n = src.Size();
  char path[100];
  snprintf(path, 99, "/proc/%d/mem", pid_);

  int fd = open(path, O_RDONLY);
  lseek64(fd, (unsigned long)src.GetStart().to_i(), SEEK_SET);
  size_t ret = read(fd, dest, n);
  close(fd);
  if (ret == -1) {
    Utility::DebugLog("*** Error : Memory Read is failed ***\nAddress: %zx\n%s (errno=%d)\n", src.GetStart().to_i(),
                      strerror(errno), errno);
    return 0;
  } else if (ret != n) {
    Utility::DebugLog("*** Error : Memory Read is failed ***\nExpected length: "
                      "%zu\nRead length: %zu\nAddress: %zx\n",
                      n, ret, src.GetStart().to_i());
  }

  return ret;
}

size_t Memory::ReadWithCache(uint8_t *dest, const Range &src, const Range &parent_range) const {
  assert(pid_ >= 0);
  assert(attached_);
  assert(parent_range.IsSuperset(src));
  if (parent_range.GetStart().to_i() != cache_range_.GetStart().to_i() ||
      parent_range.GetEnd().to_i() != cache_range_.GetEnd().to_i()) {
    cache_range_ = parent_range;
    cache_ = std::make_unique<uint8_t[]>(cache_range_.Size());
    Read(cache_.get(), parent_range);
  }

  size_t offset = src.GetStart().to_i() - cache_range_.GetStart().to_i();
  memcpy(dest, cache_.get() + offset, src.Size());

  return src.Size();
}

// size_t Ptrace::ReadByPeekData(uint8_t *dest, const Address &src) const {
//     // if (src.to_i() % sizeof(size_t) != 0) {
//     //     Utility::DebugLog("Alignment is illegal addr=%zx (fix me)",
//     src.to_i());
//     // }
//     assert(pid_ >= 0);
//     assert(attached_);
//     errno = 0;
//     long word = ptrace(PTRACE_PEEKDATA, pid_, src.to_i(), nullptr);
//     if (errno != 0) {
//         Utility::PrintErrnoString("Can't pokedata pid=%d addr=%zx", pid_,
//         src.to_i()); return 0;
//     }
//     memcpy(dest, &word, sizeof(long));
//     return sizeof(long);
// }
//
// size_t Ptrace::ReadByPeekData(uint8_t *dest, const Range &src) const {
//     assert(pid_ >= 0);
//     assert(attached_);
//     size_t n = src.GetEnd().to_i() - src.GetStart().to_i();
//     Address p = src.GetStart();
//     Utility::DebugLog("%zx-%zx (%s)", src.GetStart().to_i(),
//     src.GetEnd().to_i(), src.GetComment().c_str()); for (size_t i = 0; i < n;
//     i += sizeof(long)) {
//         size_t s = std::min(sizeof(long), n - i);
//         if (s != sizeof(long)) {
//             uint8_t temp[sizeof(long)];
//             if (!ReadByPeekData(temp, p)) { return i; }
//             for (size_t j = 0; j < s; j++) { dest[j] = temp[j]; }
//         } else {
//             if (!ReadByPeekData(dest, p)) { return i; }
//         }
//         dest += sizeof(long);
//         p.Add(sizeof(long));
//     }
//     return n;
// }

size_t Memory::WriteByPokeData(const Address &dest, long value) const {
  assert(pid_ >= 0);
  assert(attached_);
  assert(!without_ptrace_);
  // ptraceのPOKEDATAの第4引数はlongの値が入ったvoid*型（アドレスではない）
  if (ptrace(PTRACE_POKEDATA, pid_, (void *)dest.to_i(), (void *)value)) {
    Utility::PrintErrnoString("Can't pokedata pid=%d addr=%zx value=%zx", pid_, dest.to_i(), value);
    return 0;
  }
  return sizeof(long);
}

size_t Memory::WriteByPokeData(const Range &dest, const uint8_t *src, bool freeze_request) const {
  Utility::DebugLog("Using Poke");
  assert(pid_ >= 0);
  assert(attached_);
  assert(!without_ptrace_);
  if (freeze_request) {
    Utility::DebugLog("*** Error : Can't use freeze mode with ptrace");
    return 0;
  }
  size_t n = dest.GetEnd().to_i() - dest.GetStart().to_i();
  Address p = dest.GetStart();
  for (size_t i = 0; i < n; i += sizeof(long)) {
    size_t s = std::min(sizeof(long), n - i);
    uint8_t temp[sizeof(long)];
    memcpy(temp, src, s);
    if (s != sizeof(long)) {
      // longのサイズでしか書き込めないので後ろの部分をReadで読み込んでメモリ上にあるデータと同じにする
      Range rest = Range(dest.GetEnd().to_i(), dest.GetEnd().to_i() + sizeof(long) - s, dest.GetComment());
      if (!Read(temp + s, rest)) {
        return i;
      }
      if (!WriteByPokeData(p, *(long *)temp)) {
        return i;
      }
    } else {
      if (!WriteByPokeData(p, *(long *)temp)) {
        return i;
      }
    }
    src += sizeof(long);
    p.Add(sizeof(long));
  }
  return dest.Size();
}

size_t Memory::Write(const Range &dest, const uint8_t *src, bool freeze_request) const {
  if (!without_ptrace_) {
    return WriteByPokeData(dest, src, freeze_request);
  }
  assert(pid_ >= 0);
  assert(attached_ || freeze_request);
  size_t n = dest.GetEnd().to_i() - dest.GetStart().to_i();

  char path[100];
  snprintf(path, 99, "/proc/%d/mem", pid_);

  int fd = open(path, O_WRONLY);
  lseek64(fd, (unsigned long)dest.GetStart().to_i(), SEEK_SET);
  size_t ret = write(fd, src, n);
  close(fd);
  if (ret == -1) {
    Utility::DebugLog("*** Error : Memory Write is failed ***\nAddress: %zx\n%s (errno=%d)\n", dest.GetStart().to_i(),
                      strerror(errno), errno);
    return 0;
  } else if (ret != n) {
    Utility::DebugLog("*** Error : Memory Write is failed ***\nExpected "
                      "length: %zu\nWrite length: %zu\nAddress: %zx\n",
                      n, ret, dest.GetStart().to_i());
  }

  return ret;

  // Address p = dest.GetStart();
  // for (size_t i = 0; i < n; i += sizeof(long)) {
  //     size_t s = std::min(sizeof(long), n - i);
  //     if (s != sizeof(long)) {
  //         uint8_t temp[sizeof(long)];
  //         if (!Read(temp, Range(p.to_i(), p.to_i() + sizeof(long),
  //         p.GetComment()))) { return i; } for (size_t j = 0; j < s; j++) {
  //         temp[j] = src[j]; } if (!Write(p, temp)) { return i; }
  //     } else {
  //         if (!Write(p, src)) { return i; }
  //     }
  //     p.Add(s);
  //     src += s;
  // }
  // return n;
}

void Memory::Dump(const Range &src) const {
  assert(pid_ >= 0);
  assert(attached_);
  size_t n = src.GetEnd().to_i() - src.GetStart().to_i();
  if (n == 0) {
    Utility::DebugLog("Dump 0-0 length:0(NaN%%)");
    return;
  }
  const std::unique_ptr<uint8_t[]> temp_p = std::make_unique<uint8_t[]>(n);
  size_t l = Read(temp_p.get(), src);
  Utility::DebugLog("%s",
                    Utility::HexDump(src.GetStart().to_i(), src.GetComment().c_str(), temp_p.get(), l, 2).c_str());
}

// /proc/[pid]/task/* からThread IDを引っ張ってくる
void Memory::LoadThreadIDs() {
  assert(pid_ != -1);
  char path[100];
  snprintf(path, 99, "/proc/%d/task", pid_);

  DIR *dp = opendir(path);
  if (dp == nullptr) {
    fprintf(stderr, "Can't open %s\n", path);
    return;
  }
  thread_ids_.clear();
  struct dirent *directory = nullptr;
  while ((directory = readdir(dp)) != nullptr) {
    int tid = atoi(directory->d_name);
    if (tid != 0) {
      thread_ids_.insert(tid);
    }
  }
  closedir(dp);
}

void Memory::ClearCache() {
  cache_range_ = Range();
  cache_.reset();
}

/**
 * /proc/[pid]/maps からマッピングされている読み書き可能なメモリ領域を列挙する
 *
 * @param rset 読み書き可能なメモリ領域
 */
bool Memory::GenerateMaps(std::stringstream &ss) {
  assert(pid_ >= 0);

  FILE *fp = nullptr;
  char mmap_path[64];
  char mmap_line[4096];

  sprintf(mmap_path, "/proc/%d/maps", GetPid());
  fp = fopen(mmap_path, "r");
  if (fp == nullptr) {
    Utility::DebugLog("process maps file '%s' can't be opend", mmap_path);
    return false;
  }

  for (int i = 0; fgets(mmap_line, sizeof(mmap_line), fp) != nullptr; i++) {
    ss << mmap_line << "\n";
  }
  fclose(fp);
  return true;
}
```

`jni/Memory_Windows.cpp`:

```cpp
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#define _LARGEFILE64_SOURCE

#include "Memory.h"
#include "Utility.h"
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <memory>
#include <windows.h> // psapi.hより必ず上に配置
#include <psapi.h>
#include <sstream>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

bool Memory::Attach() {
  assert(pid_ >= 0);
  ClearCache();
  attached_ = true;
  return true;
}

bool Memory::Detach() {
  attached_ = false;
  return true;
}

size_t Memory::Read(uint8_t *dest, const Range &src) const {
  assert(pid_ >= 0);
  assert(attached_);

  size_t n = src.Size();

  HANDLE hProcess = OpenProcess(PROCESS_VM_READ, false, pid_);
  if (hProcess == NULL) {
    Utility::DebugLog("*** Error : OpenProcess failed ***\nPID: %d\n%s (errno=%d)\n", pid_, strerror(errno), errno);
    return 0;
  }

  SIZE_T bytesRead;
  BOOL result = ReadProcessMemory(hProcess, (LPCVOID)src.GetStart().to_i(), dest, n, &bytesRead);
  CloseHandle(hProcess);

  if (!result) {
    Utility::DebugLog("*** Error : Memory Read failed ***\nAddress: %zx\n%s (errno=%d)\n", src.GetStart().to_i(),
                      strerror(errno), errno);
    return 0;
  } else if (bytesRead != n) {
    Utility::DebugLog("*** Error : Memory Read failed ***\nExpected length: "
                      "%zu\nRead length: %zu\nAddress: %zx\n",
                      n, bytesRead, src.GetStart().to_i());
  }

  return bytesRead;
}

size_t Memory::ReadWithCache(uint8_t *dest, const Range &src, const Range &parent_range) const {
  assert(pid_ >= 0);
  assert(attached_);
  assert(parent_range.IsSuperset(src));
  if (parent_range.GetStart().to_i() != cache_range_.GetStart().to_i() ||
      parent_range.GetEnd().to_i() != cache_range_.GetEnd().to_i()) {
    cache_range_ = parent_range;
    cache_ = std::make_unique<uint8_t[]>(cache_range_.Size());
    Read(cache_.get(), parent_range);
  }

  size_t offset = src.GetStart().to_i() - cache_range_.GetStart().to_i();
  memcpy(dest, cache_.get() + offset, src.Size());

  return src.Size();
}

size_t Memory::WriteByPokeData(const Address &dest, long value) const { return 0; }

size_t Memory::WriteByPokeData(const Range &dest, const uint8_t *src, bool freeze_request) const { return 0; }

size_t Memory::Write(const Range &dest, const uint8_t *src, bool freeze_request) const {
  assert(pid_ >= 0);
  assert(attached_ || freeze_request);

  size_t n = dest.GetEnd().to_i() - dest.GetStart().to_i();

  HANDLE hProcess = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION, false, pid_);
  if (hProcess == NULL) {
    Utility::DebugLog("*** Error : OpenProcess failed ***\nPID: %d\n%s (errno=%d)\n", pid_, strerror(errno), errno);
    return 0;
  }

  SIZE_T bytesWritten;
  BOOL result = WriteProcessMemory(hProcess, (LPVOID)dest.GetStart().to_i(), src, n, &bytesWritten);
  CloseHandle(hProcess);

  if (!result) {
    Utility::DebugLog("*** Error : Memory Write failed ***\nAddress: %zx\n%s (errno=%d)\n", dest.GetStart().to_i(),
                      strerror(errno), errno);
    return 0;
  } else if (bytesWritten != n) {
    Utility::DebugLog("*** Error : Memory Write failed ***\nExpected length: "
                      "%zu\nWrite length: %zu\nAddress: %zx\n",
                      n, bytesWritten, dest.GetStart().to_i());
  }

  return bytesWritten;
}

void Memory::Dump(const Range &src) const {
  assert(pid_ >= 0);
  assert(attached_);
  size_t n = src.GetEnd().to_i() - src.GetStart().to_i();
  if (n == 0) {
    Utility::DebugLog("Dump 0-0 length:0(NaN%%)");
    return;
  }
  const std::unique_ptr<uint8_t[]> temp_p = std::make_unique<uint8_t[]>(n);
  size_t l = Read(temp_p.get(), src);
  Utility::DebugLog("%s",
                    Utility::HexDump(src.GetStart().to_i(), src.GetComment().c_str(), temp_p.get(), l, 2).c_str());
}

void Memory::LoadThreadIDs() {}

void Memory::ClearCache() {
  cache_range_ = Range();
  cache_.reset();
}

bool Memory::GenerateMaps(std::stringstream &ss) {
  assert(pid_ >= 0);

  HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid_);
  if (hProcess == NULL) {
    Utility::DebugLog("Can't open process with PID %d", pid_);
    return false;
  }

  MEMORY_BASIC_INFORMATION mbi;
  DWORD64 address = 0;
  char module_name[MAX_PATH] = "";
  char dev[6] = "00:00";
  unsigned long inode = 0;
  SIZE_T offset = 0;

  while (VirtualQueryEx(hProcess, (LPCVOID)address, &mbi, sizeof(mbi)) == sizeof(mbi)) {
    if (mbi.State == MEM_COMMIT) {
      HMODULE hMod;
      if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
                            (LPCTSTR)mbi.BaseAddress, &hMod)) {
        GetModuleFileNameEx(hProcess, hMod, module_name, sizeof(module_name));
      } else {
        strcpy(module_name, "");
      }

      ss << std::hex << (DWORD64)mbi.BaseAddress << "-" << (DWORD64)mbi.BaseAddress + mbi.RegionSize << " ";

      char permissions[4] = "---";
      permissions[3] = '\0';

      // Windowsのメモリ属性をrwx形式にマッピングする
      if (mbi.Protect & (PAGE_READONLY | PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE |
                         PAGE_EXECUTE_WRITECOPY)) {
        permissions[0] = 'r';
      }
      if (mbi.Protect & (PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)) {
        permissions[1] = 'w';
      }
      if (mbi.Protect & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)) {
        permissions[2] = 'x';
      }

      ss << permissions << " " << std::hex << offset << " " << dev << " " << inode << " " << module_name << "\n";
    }
    address += mbi.RegionSize;
  }

  CloseHandle(hProcess);
  return true;
}
```

`jni/Patcher.cpp`:

```cpp
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <algorithm>
#include <assert.h>
#include <map>
#include <memory>
#include <sstream>
#include <string.h>
#include <time.h>
#include <vector>

#include "Config.h"
#include "Converter.h"
#include "Patcher.h"
#include "Snapshot.h"
#include "Utility.h"

std::string Patcher::GetModeString(Mode mode) {
  std::map<Mode, std::string> temp = {
      {Mode::NOP, "nop"},
      {Mode::LOOKUP, "lookup"},
      {Mode::FILTER, "filter"},
      {Mode::CHANGE, "change"},
  };
  assert(temp.count(mode));
  return temp[mode];
}
Patcher::Mode Patcher::GetMode(const std::string &str) {
  std::map<std::string, Mode> temp = {
      {"nop", Mode::NOP},  {"lookup", Mode::LOOKUP}, {"filter", Mode::FILTER}, {"change", Mode::CHANGE},
      {"l", Mode::LOOKUP}, {"f", Mode::FILTER},      {"c", Mode::CHANGE},
  };
  assert(temp.count(str));
  return temp[str];
}

//================================================================================
// Command
//================================================================================

bool Patcher::Attach(const std::string &command, std::stringstream &sin) { return memory_->Attach(); }

bool Patcher::Detach(const std::string &command, std::stringstream &sin) { return memory_->Detach(); }

bool Patcher::Clear(const std::string &command, std::stringstream &sin) {
  addr_set_.clear();
  return true;
}

bool Patcher::Process(const std::string &command, std::stringstream &sin) {
  std::string type, str;
  if (!(sin >> type >> str)) {
    return false;
  }
  ChangeString change_str;
  if (!change_str.Init(type, str)) {
    Utility::DebugLog("%s is wrong type", type.c_str());
    return false;
  }
  if (!Process(GetMode(command), change_str)) {
    return false;
  }
  Utility::DebugLog("Please Input Command");
  return true;
}

bool Patcher::PairFilter(const std::string &command, std::stringstream &sin) {
  std::string type, str;
  int store_size;
  if (!(sin >> type >> str >> store_size)) {
    return false;
  }

  std::vector<TargetAddress> prev_addr_set = addr_set_;
  ChangeString change_str;
  if (!change_str.Init(type, str)) {
    Utility::DebugLog("%s is wrong type", type.c_str());
    return false;
  }
  if (!Process(Mode::LOOKUP, change_str)) {
    return false;
  }

  std::vector<std::pair<size_t, TargetAddress>> addr_dists;
  sort(prev_addr_set.begin(), prev_addr_set.end());
  sort(addr_set_.begin(), addr_set_.end());
  {
    // 尺取りメソッドでアドレス間の一番近い距離を求める
    auto it2 = addr_set_.begin();
    for (auto it1 = prev_addr_set.begin(); it1 != prev_addr_set.end(); it1++) {
      size_t dist = 1e+9;
      while (true) {
        auto nit2 = it2 + 1;
        if (nit2 == addr_set_.end()) {
          break;
        }
        size_t ndist = it1->GetAddress().Dist(nit2->GetAddress());
        if (ndist >= dist) {
          break;
        }
        dist = ndist;
        it2 = nit2;
      }
      addr_dists.emplace_back(dist, *it1);
    }
  }
  std::sort(addr_dists.begin(), addr_dists.end());

  addr_set_.clear();
  const int MAX_OUTPUT_SIZE = store_size + 10;
  int output_cnt = 0;
  for (auto it = addr_dists.begin(); it != addr_dists.end() && output_cnt < MAX_OUTPUT_SIZE; it++, output_cnt++) {
    size_t dist = it->first;
    const TargetAddress &addr = it->second;
    if ((int)addr_set_.size() < store_size) {
      addr_set_.emplace_back(addr);
    }
    Utility::DebugLog("Dist: %zd, Address: %zx", dist, addr.GetAddress().to_i());
  }
  Utility::DebugLog("Result Address: %d", (int)addr_set_.size());

  Utility::DebugLog("");
  Utility::DebugLog("Please Input Command");
  return true;
}

bool Patcher::Replace(const std::string &command, std::stringstream &sin) {
  std::string hex_start, string_type, after;
  size_t start;
  if (!(sin >> hex_start >> string_type >> after) || sscanf(hex_start.c_str(), "%zx", &start) != 1) {
    return false;
  }
  // TODO
  ChangeString change_str;
  if (!change_str.Init(string_type, after)) {
    Utility::DebugLog("%s %s is not same length or wrong type", string_type.c_str(), after.c_str());
    return false;
  }

  if (!memory_->Attach() || !CreateRangeSet()) {
    return false;
  }
  TargetAddress address(Range::Fit(range_set_, Address(start)), change_str);
  if (address.GetAddress().to_i() == 0) {
    Utility::DebugLog("Target Address is over the memory range");
    return false;
  }
  Replace(address, change_str);
  return true;
}

bool Patcher::Freeze(const std::string &command, std::stringstream &sin) {
  std::string hex_start, string_type, after;
  size_t start;
  if (!(sin >> hex_start >> string_type >> after) || sscanf(hex_start.c_str(), "%zx", &start) != 1) {
    return false;
  }
  ChangeString change_str;
  if (!change_str.Init(string_type, after)) {
    Utility::DebugLog("%s %s is not same length or wrong type", string_type.c_str(), after.c_str());
    return false;
  }

  if (!memory_->Attach() || !CreateRangeSet()) {
    return false;
  }
  TargetAddress address(Range::Fit(range_set_, Address(start)), change_str);
  if (address.GetAddress().to_i() == 0) {
    Utility::DebugLog("Target Address is over the memory range");
    return false;
  }
  freeze_set_.push_back(std::make_unique<FreezeThread>(memory_, address));
  freeze_set_.back()->Start();
  return true;
}

bool Patcher::FreezeTerminate(const std::string &command, std::stringstream &sin) {
  FreezeTerminate();
  return true;
}

bool Patcher::Diff(const std::string &command, std::stringstream &sin) {
  std::string mode_str;
  sin >> mode_str;

  const auto start_time = std::chrono::steady_clock::now();
  Utility::DebugLog("Starting memory patching... (mode: diff)");
  enum class DiffMode {
    NOP,
    START,
    UPPER,
    LOWER,
    SAME,
    CHANGE,
    END,
  };
  std::map<std::string, DiffMode> temp = {
      {"nop", DiffMode::NOP},   {"start", DiffMode::START},   {"upper", DiffMode::UPPER}, {"lower", DiffMode::LOWER},
      {"same", DiffMode::SAME}, {"change", DiffMode::CHANGE}, {"end", DiffMode::END},
  };
  DiffMode mode = temp[mode_str];
  if (mode == DiffMode::LOWER || mode == DiffMode::UPPER || mode == DiffMode::SAME || mode == DiffMode::CHANGE) {
    range_set_.clear();
    if (!memory_->Attach() || !CreateRangeSet()) {
      return false;
    }

    if (snapshot_) {
      addr_set_.clear();
      for (SnappedRange sr : *snapshot_) {
        Range range = Range::Fit(range_set_, sr.range());
        if (range.GetStart().to_i() == 0)
          continue;

        size_t start = range.GetStart().to_i();
        // size_t end = range.GetEnd().to_i();
        size_t n = range.Size();

        const std::unique_ptr<uint8_t[]> old_memory = sr.data();
        const std::unique_ptr<uint8_t[]> new_memory = std::make_unique<uint8_t[]>(n);
        memory_->Read(new_memory.get(), range);

        for (size_t i = 0; i < n; i += 4) {
          int old_value = *(int *)(old_memory.get() + i);
          int new_value = *(int *)(new_memory.get() + i);
          // ChangeStringを中で作ってるのは数倍くらい速度が変わるため
          if (mode == DiffMode::UPPER && old_value < new_value) {
            ChangeString change_str(new_value);
            addr_set_.emplace_back(Address(start + i), change_str);
          } else if (mode == DiffMode::LOWER && old_value > new_value) {
            ChangeString change_str(new_value);
            addr_set_.emplace_back(Address(start + i), change_str);
          } else if (mode == DiffMode::SAME && old_value == new_value) {
            ChangeString change_str(new_value);
            addr_set_.emplace_back(Address(start + i), change_str);
          } else if (mode == DiffMode::CHANGE && old_value != new_value) {
            ChangeString change_str(new_value);
            addr_set_.emplace_back(Address(start + i), change_str);
          } else {
            // nop
          }
        }
      }
      snapshot_.reset();
    } else {
      const std::unique_ptr<uint8_t[]> temp_p = std::make_unique<uint8_t[]>(4);
      int cnt = 0;
      auto parent_range_it = range_set_.begin();
      for (auto it = addr_set_.begin(); it != addr_set_.end(); it++) {
        // TODO 関数化してFilterと合わせる
        ChangeString change_str = it->GetChangeString();
        size_t start = it->GetAddress().to_i();
        size_t end = it->GetAddress().to_i() + change_str.Size();
        if (end - start != 4) {
          Utility::DebugLog("Target Rage is not 4: %zx-%zx (%d)", start, end, end - start);
          continue;
        }

        while (parent_range_it != range_set_.end() && parent_range_it->GetEnd().to_i() < start) {
          parent_range_it++;
        }
        if (parent_range_it == range_set_.end() || !parent_range_it->IsSuperset(Range(start, end, ""))) {
          continue;
        }
        size_t s = -1;
        if (addr_set_.size() < 10000) {
          s = memory_->Read(temp_p.get(), Range(start, end, parent_range_it->GetComment()));
        } else {
          // open, readのsyscallが重いので、個数が多い場合はキャッシュ付きでやる
          s = memory_->ReadWithCache(temp_p.get(), Range(start, end, parent_range_it->GetComment()), *parent_range_it);
        }
        if (s != end - start) {
          continue;
        }

        int old_value = *(int *)change_str.GetRawValue().data();
        int new_value = *(int *)temp_p.get();
        TargetAddress target_address(it->GetAddress(), ChangeString(new_value));
        if (mode == DiffMode::UPPER && old_value < new_value) {
          addr_set_[cnt++] = target_address;
        } else if (mode == DiffMode::LOWER && old_value > new_value) {
          addr_set_[cnt++] = target_address;
        } else if (mode == DiffMode::SAME && old_value == new_value) {
          addr_set_[cnt++] = target_address;
        } else if (mode == DiffMode::CHANGE && old_value != new_value) {
          addr_set_[cnt++] = target_address;
        } else {
          // nop
        }
      }
      addr_set_.resize(cnt);
    }
    Utility::DebugLog("Found! %zd address", addr_set_.size());
  } else if (mode == DiffMode::START) {
    snapshot_ = std::make_unique<Snapshot>();
    if (!memory_->Attach() || !CreateRangeSet()) {
      return false;
    }

    for (RangeSet::const_iterator it = range_set_.begin(); it != range_set_.end(); ++it) {
      size_t n = it->Size();
      const std::unique_ptr<uint8_t[]> temp_p = std::make_unique<uint8_t[]>(n);
      memory_->Read(temp_p.get(), *it);
      snapshot_->push_back(*it, temp_p.get());
    }
    Utility::DebugLog("snapshot created!");
  } else if (mode == DiffMode::END) {
    Utility::DebugLog("snapshot done! Use change command.");
    snapshot_.reset();
  } else {
    Utility::DebugLog("usage: diff [start|end|upper|lower|same|change]");
  }

  const auto end_time = std::chrono::steady_clock::now();
  double duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count();
  Utility::DebugLog("Process Time: %.0lf ms", duration);

  return true;
}

bool Patcher::Result(const std::string &command, std::stringstream &sin) { return OutputResult(stdout); }
bool Patcher::Scope(const std::string &command, std::stringstream &sin) {
  std::string scope;
  if (!(sin >> scope)) {
    range_scope_ = "";
  } else {
    range_scope_ = scope;
  }
  Utility::DebugLog("Now scope is '%s'", range_scope_.c_str());
  return true;
}
bool Patcher::Save(const std::string &command, std::stringstream &sin) {
  std::string filename;
  std::string state_path = std::string(STORAGE_PATH) + "/mempatch_state.txt";
  if (!(sin >> filename)) {
    filename = state_path;
  }
  FILE *fp = fopen(filename.c_str(), "wb");
  if (fp == nullptr) {
    return false;
  }
  Serialize(fp);
  fclose(fp);
  return true;
}
bool Patcher::Load(const std::string &command, std::stringstream &sin) {
  std::string filename;
  std::string state_path = std::string(STORAGE_PATH) + "/mempatch_state.txt";
  if (!(sin >> filename)) {
    filename = state_path;
  }
  FILE *fp = fopen(filename.c_str(), "rb");
  if (fp == nullptr) {
    return false;
  }
  DeSerialize(fp);
  fclose(fp);
  return true;
}

bool Patcher::Dump(const std::string &command, std::stringstream &sin) {
  std::string hex_start, hex_len;
  size_t start, len;
  if (!(sin >> hex_start >> hex_len) || sscanf(hex_start.c_str(), "%zx", &start) != 1 ||
      sscanf(hex_len.c_str(), "%zx", &len) != 1 || start > start + len) {
    return false;
  }
  if (memory_->Attach() && CreateRangeSet()) {
    memory_->Dump(Range::Fit(range_set_, Range(start, start + len, "")));
  } else {
    Utility::DebugLog("Failed Dumping");
  }
  return true;
}

bool Patcher::DumpAll(const std::string &command, std::stringstream &sin) {
  std::string filename;
  std::string dump_path = std::string(STORAGE_PATH) + "/mempatch_dump.dat";
  if (!(sin >> filename)) {
    filename = dump_path;
  }
  return DumpAll(filename);
}

bool Patcher::Help(const std::string &command, std::stringstream &sin) {
  PrintCommandUsage();
  return true;
}

bool Patcher::Exit(const std::string &command, std::stringstream &sin) {
  Exit();
  return true;
}

//================================================================================
// misc
//================================================================================

bool Patcher::SaveResult(const std::string &filename) const {
  FILE *fp = nullptr;
  fp = fopen(filename.c_str(), "w");
  if (fp == nullptr) {
    Utility::DebugLog("result file '%s' can't open", filename.c_str());
    return false;
  }
  bool ret = OutputResult(fp);
  fclose(fp);
  return ret;
}

bool Patcher::OutputResult(FILE *fp) const {
  fprintf(fp, "Last PorcessTime %d\n", last_process_time_);

  fprintf(fp, "Target Address : %d\n", (int)range_set_.size());
  for (auto it = range_set_.begin(); it != range_set_.end(); it++) {
    if (sizeof(size_t) == 4) {
      fprintf(fp, "    %08zx-%08zx (%s, %zd Byte)\n", it->GetStart().to_i(), it->GetEnd().to_i(),
              it->GetComment().c_str(), it->Size());
    } else if (sizeof(size_t) == 8) {
      fprintf(fp, "    %016zx-%016zx (%s, %zd Byte)\n", it->GetStart().to_i(), it->GetEnd().to_i(),
              it->GetComment().c_str(), it->Size());
    } else {
      assert(false);
    }
  }

  fprintf(fp, "Address Set : %d\n", (int)addr_set_.size());
  for (auto it = addr_set_.begin(); it != addr_set_.end(); it++) {
    if (sizeof(size_t) == 4) {
      fprintf(fp, "    %08zx : ", it->GetAddress().to_i());
    } else {
      fprintf(fp, "    %016zx : ", it->GetAddress().to_i());
    }
    fprintf(fp, "%s", it->GetChangeString().GetValue().c_str());
    fprintf(fp, " (%s)", it->GetChangeString().GetTypeString().c_str());
    fprintf(fp, " (%s)\n", it->GetAddress().GetComment(range_set_).c_str());
  }

  return true;
}

void Patcher::FreezeTerminate() {
  for (auto &freeze_ : freeze_set_) {
    freeze_->Terminate();
  }
  freeze_set_.clear();
}
void Patcher::Exit() {
  FreezeTerminate();
  memory_->Detach();
}

//================================================================================
// private
//================================================================================

/**
 * 各OS毎にマッピングされている読み書き可能なメモリ領域を列挙する
 *
 * @param rset 読み書き可能なメモリ領域
 */
bool Patcher::CreateRangeSet() {
  assert(memory_->IsAttached());
  char mmap_line[4096];
  const std::vector<std::string> ignore_list = {
  // 対象外のディレクトリ
#if defined(_WIN32) || defined(_WIN64)
#elif defined(__ANDROID__)
      "/system/lib/", "/lib/x86_64-linux-gnu/", "/usr/lib/"
#elif defined(__linux__)
#elif defined(__APPLE__)
#endif
  };

  std::stringstream ss;
  if (!memory_->GenerateMaps(ss)) {
    Utility::DebugLog("process maps for pid '%d' can't be generated", memory_->GetPid());
    return false;
  }

  std::string maps_content = ss.str();
  std::istringstream iss(maps_content);

  RangeSet prev_rset = range_set_;
  range_set_.clear();

  for (int i = 0; iss.getline(mmap_line, sizeof(mmap_line)); i++) {
    std::stringstream sin(mmap_line);
    std::string address, permission, offset, dev, inode, pathname;
    pathname = "";
    sin >> address >> permission >> offset >> dev >> inode >> pathname;
    // 読み込み権限・書き込み権限があり、sharedでもファイルでない物のみ対象
    for (auto it = ignore_list.begin(); it != ignore_list.end(); it++) {
      if (pathname.find(*it) != std::string::npos) {
        goto next;
      }
    }
    if (!range_scope_.empty() && pathname.find(range_scope_) == std::string::npos) {
      goto next;
    }
    if (permission[0] == 'r' && permission[1] == 'w' && permission[3] != 's') {
      size_t start, end;
      sscanf(mmap_line, "%zx-%zx", &start, &end);
      range_set_.insert(Range(start, end, pathname));
    }
  next:;
  }
  return true;
}

/**
 * LookUp, Filter, Changeのどれかを行い、計算結果のサマリーを表示する
 */
bool Patcher::Process(const Mode mode, const ChangeString &change_str) {
  bool ret = true;

  const auto start_time = std::chrono::steady_clock::now();
  Utility::DebugLog("Starting memory patching... (mode: %s)", GetModeString(mode).c_str());
  if (mode == Patcher::Mode::NOP) {
  } else if (mode == Patcher::Mode::LOOKUP) {
    ret &= LookUp(change_str);
  } else if (mode == Patcher::Mode::FILTER) {
    ret &= Filter(change_str);
  } else if (mode == Patcher::Mode::CHANGE) {
    ret &= ReplaceAll(change_str);
  } else {
    ret = false;
    Utility::DebugLog("mode is invalid");
  }
  last_process_time_ = time(nullptr);
  const auto end_time = std::chrono::steady_clock::now();
  double duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count();

  if (ret) {
    Utility::DebugLog("Process Time: %.0lf ms", duration);
    Utility::DebugLog("Memory: %.2lf MB", (double)GetMemorySize() / 1024.0 / 1024.0);
    Utility::DebugLog("Range Size: %d", GetRangeSetSize());
    Utility::DebugLog("Found Address: %d", GetTargetAddressSetSize());
  }
  Utility::DebugLog("");

  return ret;
}

/**
 * change_strで指定された文字列を含むメモリアドレスを列挙する
 */
bool Patcher::LookUp(const ChangeString &change_str) {
  if (!memory_->Attach() || !CreateRangeSet()) {
    return false;
  }
  addr_set_.clear();

  for (RangeSet::const_iterator it = range_set_.begin(); it != range_set_.end(); ++it) {
    size_t start = it->GetStart().to_i();
    size_t end = it->GetEnd().to_i();
    size_t n = end - start;
    const std::unique_ptr<uint8_t[]> temp_p = std::make_unique<uint8_t[]>(n);
    memory_->Read(temp_p.get(), *it);
    size_t chstring_len = change_str.Size();
    if (n < chstring_len) {
      continue;
    }
    const uint8_t *raw_before = change_str.GetRawValue().data();
    const uint8_t *str = temp_p.get();

    std::vector<size_t> find_index;
    if (change_str.GetType() == Converter::Type::FLOAT_FUZZY_LITTLE_ENDIAN) {
      find_index = Utility::StrstrByFloatFuzzyLookup(str, raw_before, n, chstring_len);
    } else {
      find_index = Utility::StrstrByRollingHash(str, raw_before, n, chstring_len);
    }

    for (auto it = find_index.begin(); it != find_index.end(); it++) {
      addr_set_.emplace_back(Address(*it + start), change_str);
    }
  }

  return true;
}

/**
 * addrsetのアドレスの値でchange_strに入ってないアドレスを除去する
 */
bool Patcher::Filter(const ChangeString &change_str) {
  if (!memory_->Attach() || !CreateRangeSet()) {
    return false;
  }
  auto parent_range_it = range_set_.begin();
  int cnt = 0;
  for (auto it = addr_set_.begin(); it != addr_set_.end(); it++) {
    size_t start = it->GetAddress().to_i();
    size_t end = it->GetAddress().to_i() + change_str.Size();
    // キャッシュ付きでやるために元々あったRangeを探す
    while (parent_range_it != range_set_.end() && parent_range_it->GetEnd().to_i() < start) {
      parent_range_it++;
    }
    if (parent_range_it == range_set_.end() || !parent_range_it->IsSuperset(Range(start, end, ""))) {
      continue;
    }

    const std::unique_ptr<uint8_t[]> temp_p = std::make_unique<uint8_t[]>(change_str.Size());
    size_t s = -1;
    if (addr_set_.size() < 10000) {
      s = memory_->Read(temp_p.get(), Range(start, end, parent_range_it->GetComment()));
    } else {
      // open, readのsyscallが重いので、個数が多い場合はキャッシュ付きでやる
      s = memory_->ReadWithCache(temp_p.get(), Range(start, end, parent_range_it->GetComment()), *parent_range_it);
    }
    if (change_str.GetType() == Converter::Type::FLOAT_FUZZY_LITTLE_ENDIAN) {
      float min = 0.0f;
      memcpy((char *)&min, change_str.GetRawValue().data(), 4);
      float max = min + 1.05f;
      min = min - 0.55f; // 四捨五入のケース対応
      float v = 0.0f;
      memcpy((uint8_t *)&v, temp_p.get(), 4);

      if (v >= min && v <= max) {
        if (cnt < 20)
          Utility::DebugLog("From:%f, To:%f, Value:%f", min, max, v);
        if (cnt == 20)
          Utility::DebugLog(" and more...");
        addr_set_[cnt++] = TargetAddress(it->GetAddress(), change_str);
      }
    } else {
      if (s == change_str.Size() && memcmp(temp_p.get(), change_str.GetRawValue().data(), change_str.Size()) == 0) {
        addr_set_[cnt++] = TargetAddress(it->GetAddress(), change_str);
      }
    }
  }
  addr_set_.resize(cnt);
  return true;
}

/**
 * addrsetのアドレスの値を置換する
 */
bool Patcher::ReplaceAll(const ChangeString &change_str) {
  if (!memory_->Attach() || !CreateRangeSet()) {
    return false;
  }
  size_t cnt = 0;
  for (auto it = addr_set_.begin(); it != addr_set_.end(); it++) {
    if (Replace(*it, change_str)) {
      cnt++;
    }
  }
  Utility::DebugLog("Replace Count: %d / %d", (int)cnt, (int)addr_set_.size());
  return cnt == addr_set_.size();
}

/**
 * 一つのアドレスの内容をcahnge_strで書き換える
 * 中身の整合性のチェックとかはしない
 */
bool Patcher::Replace(const TargetAddress &target_address, const ChangeString &change_str) {
  if (!memory_->Attach() || !CreateRangeSet()) {
    return false;
  }
  const Address &address = target_address.GetAddress();
  const size_t start = address.to_i();
  const size_t end = address.to_i() + change_str.Size();
  const std::string &comment = address.GetComment(range_set_);
  const size_t n = end - start;
  const std::unique_ptr<uint8_t[]> temp_p = std::make_unique<uint8_t[]>(n);

  // Debug Log
  memory_->Read(temp_p.get(), Range(start, end, comment));
  std::vector<uint8_t> byte = Converter::RawByteToByte(temp_p.get(), n);
  Utility::DebugLog("Change: %s(%s) -> %s(%s) (%s)", Converter::ByteToHex(byte).c_str(),
                    Converter::GetString(change_str.GetType(), byte).c_str(), change_str.GetHexValue().c_str(),
                    change_str.GetValue().c_str(), comment.c_str());

  // Replace
  memory_->Write(Range(start, end, comment), change_str.GetRawValue().data(), false);

  // Debug Log & Error Check
  memory_->Dump(Range::Fit(range_set_, Range(start - 16, end + 16, comment)));
  memory_->Read(temp_p.get(), Range(start, end, comment));
  if (memcmp(temp_p.get(), change_str.GetRawValue().data(), n) != 0) {
    // 指定した値に書き換わってなかった場合はエラーを出力
    Utility::DebugLog("*** Error ***\n*** Replace is failed!!! ***\n*** Please "
                      "Change a device ***\n\n");
    return false;
  }
  return true;
}

bool Patcher::DumpAll(const std::string &filename) {
  if (memory_->Attach() && CreateRangeSet()) {
    FILE *fp = fopen(filename.c_str(), "wb");
    if (fp == nullptr) {
      return false;
    }
    fprintf(fp, "_%d", memory_->GetPid());
    Utility::SetSerialize(fp, range_set_);
    for (RangeSet::const_iterator it = range_set_.begin(); it != range_set_.end(); ++it) {
      DumpRange(fp, *it);
    }
    fclose(fp);
  } else {
    Utility::DebugLog("Failed Dumping");
    return false;
  }
  return true;
}
bool Patcher::DumpRange(FILE *fp, const Range &range) {
  size_t n = range.Size();
  const std::unique_ptr<uint8_t[]> temp_p = std::make_unique<uint8_t[]>(n);
  memory_->Read(temp_p.get(), range);

  if (fwrite(temp_p.get(), sizeof(uint8_t), n, fp) != n) {
    return false;
  }

  return true;
}
std::unique_ptr<uint8_t[]> Patcher::LoadDumpRange(FILE *fp, const Range &range) {
  size_t n = range.Size();
  std::unique_ptr<uint8_t[]> ret = std::make_unique<uint8_t[]>(n);
  for (size_t i = 0; i < n; i++) {
    fscanf(fp, "%c", &ret[i]);
  }
  return ret;
}

void Patcher::Serialize(FILE *fp) const {
  fprintf(fp, "_%d", memory_->GetPid());
  fprintf(fp, "_%d", last_process_time_);
  Utility::SetSerialize(fp, range_set_);
  Utility::VectorSerialize(fp, addr_set_);
  fprintf(stdout, "Success\n");
}
void Patcher::DeSerialize(FILE *fp) {
  int pid;
  if (fscanf(fp, "_%d", &pid) != 1 || pid != memory_->GetPid()) {
    fprintf(stderr, "Error: Process ID is different\n");
    return;
  }
  fscanf(fp, "_%d", &last_process_time_);
  range_set_ = Utility::SetDeSerialize<class Range>(fp);
  addr_set_ = Utility::VectorDeSerialize<class TargetAddress>(fp);
  fprintf(stdout, "Success\n");
}

```

`jni/Patcher.h`:

```h
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once

#include <memory>
#include <sstream>
#include <stdint.h>
#include <string>
#include <vector>

#include "Address.h"
#include "ChangeString.h"
#include "FreezeThread.h"
#include "Memory.h"
#include "Snapshot.h"

class Patcher {
public:
  enum class Mode {
    NOP,
    LOOKUP,
    FILTER,
    CHANGE,
    DIFF,
  };
  static std::string GetModeString(Mode mode); // string -> Mode
  static Mode GetMode(const std::string &str); // Mode -> string

  Patcher() { Init(-1, false); }
  explicit Patcher(int pid, bool without_ptrace) { Init(pid, without_ptrace); }
  ~Patcher() {
    Exit();
    memory_.reset();
    snapshot_.reset();
  }

  // Command
  bool Attach(const std::string &command, std::stringstream &sin);
  bool Detach(const std::string &command, std::stringstream &sin);

  bool Clear(const std::string &command, std::stringstream &sin);
  bool Process(const std::string &command, std::stringstream &sin);
  bool PairFilter(const std::string &command, std::stringstream &sin);
  bool Replace(const std::string &command, std::stringstream &sin);
  bool Diff(const std::string &command, std::stringstream &sin);
  bool Freeze(const std::string &command, std::stringstream &sin);
  bool FreezeTerminate(const std::string &command, std::stringstream &sin);

  bool Result(const std::string &command, std::stringstream &sin);
  bool Dump(const std::string &command, std::stringstream &sin);
  bool Exit(const std::string &command, std::stringstream &sin);

  bool Scope(const std::string &command, std::stringstream &sin);
  bool Save(const std::string &command, std::stringstream &sin);
  bool Load(const std::string &command, std::stringstream &sin);
  bool DumpAll(const std::string &command, std::stringstream &sin);
  bool Help(const std::string &command, std::stringstream &sin);
  bool SaveResult(const std::string &filename) const;
  bool OutputResult(FILE *fp) const;

  void FreezeTerminate();
  void Exit(); // プログラムの終了時の処理、detachする

  // Getter
  size_t GetMemorySize() const {
    size_t ret = 0;
    for (auto it = range_set_.begin(); it != range_set_.end(); it++) {
      ret += it->Size();
    }
    return ret;
  }
  int GetRangeSetSize() const { return range_set_.size(); }
  int GetTargetAddressSetSize() const { return addr_set_.size(); }

  static void PrintCommandUsage() {
    fprintf(stderr, "PatcherCommand:\n");

    fprintf(stderr, "  attach                   attach process\n");
    fprintf(stderr, "  detach                   detach process\n");
    fprintf(stderr, "  clear                    clear detection rule & found address\n");

    fprintf(stderr, "  lookup [rule]            lookup memory under the rule\n");
    fprintf(stderr, "  filter [rule]            filter found address under the rule\n");
    fprintf(stderr, "  pair_filter [rule] cnt   filter by nearest another "
                    "value (e.g. lookup HP and filter by MP)\n");
    fprintf(stderr, "  change [rule]            replace found address under the rule\n");
    fprintf(stderr, "  replace [hex] [rule]     replace specific address under the rule\n");
    fprintf(stderr, "  freeze  [hex] [rule]     freeze target address\n");
    fprintf(stderr, "  freeze_terminate         stop & kill all freeze request\n");

    fprintf(stderr, "  scope [ascii]            set range scope (e.g. scope "
                    "[anon:libc_malloc])\n");
    fprintf(stderr, "  result                   output Lookup result\n");
    fprintf(stderr, "  dump [hexint] [hexint]   dump memory (e.g. dump "
                    "7f33f6963005 20) \n");
    fprintf(stderr, "  diff [start|lower|upper|same|change]\n");
    fprintf(stderr, "                           memory diff filter\n");
    fprintf(stderr, "  exit(quit)               exit mempatch\n");
    fprintf(stderr, "  save [path]              save current state to a file\n");
    fprintf(stderr, "  load [path]              load previous state to a file\n");
    fprintf(stderr, "  dumpall [path]           dump all memory data to a file\n");
    fprintf(stderr, "  help                     print this message\n");
    fprintf(stderr, "  #  comment\n");
    fprintf(stderr, "  // comment\n");
    ChangeString::PrintCommandUsage();
  }

private:
  void Init(int pid, bool without_ptrace) {
    last_process_time_ = -1;
    memory_ = std::make_shared<Memory>(pid, without_ptrace);
  }
  bool CreateRangeSet();
  bool Process(const Mode mode, const ChangeString &change_str);
  bool LookUp(const ChangeString &change_str);
  bool Filter(const ChangeString &change_str);
  bool ReplaceAll(const ChangeString &change_str);
  bool Replace(const TargetAddress &target_address, const ChangeString &change_str);

  int last_process_time_;
  RangeSet range_set_;
  std::vector<TargetAddress> addr_set_;
  std::vector<std::unique_ptr<FreezeThread>> freeze_set_;
  std::shared_ptr<Memory> memory_;
  std::unique_ptr<Snapshot> snapshot_;
  std::string range_scope_;

  bool DumpAll(const std::string &filename);
  bool DumpRange(FILE *fp, const Range &range);
  std::unique_ptr<uint8_t[]> LoadDumpRange(FILE *fp, const Range &range);
  void Serialize(FILE *fp) const;
  void DeSerialize(FILE *fp);
};

```

`jni/SnappedRange.cpp`:

```cpp
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "Snapshot.h"

std::unique_ptr<uint8_t[]> SnappedRange::data() const { return _parent->pull(_fileoff, _range.Size()); }

```

`jni/SnappedRange.h`:

```h
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once

#include <memory>
#include <stdint.h>
#include <stdlib.h>

#include "Address.h"

class Snapshot;

class SnappedRange {
public:
  SnappedRange(const Snapshot *snapshot, const Range &range, off_t fileoff)
      : _parent(snapshot), _range(range), _fileoff(fileoff) {}
  Range range() const { return _range; }
  std::unique_ptr<uint8_t[]> data() const;

private:
  const Snapshot *_parent;
  Range _range;
  off_t _fileoff;
};

```

`jni/Snapshot.h`:

```h
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once

#include <memory>
#include <stdio.h>
#include <sys/stat.h>
#include <vector>

#include "Address.h"
#include "Config.h"
#include "SnappedRange.h"

class Snapshot {
public:
  typedef std::vector<SnappedRange>::iterator iterator;

public:
  Snapshot() {}
  Snapshot(const char *filename) : _filename(filename) {}
  ~Snapshot() { ::remove(_filename.c_str()); }

  void clear() { ::remove(_filename.c_str()); }

  iterator begin() { return _saved.begin(); }
  iterator end() { return _saved.end(); }

  void push_back(const Range &range, const void *data) {
    size_t size = range.Size();
    off_t offset = push(data, size);
    _saved.push_back(SnappedRange(this, range, offset));
  }
  off_t push(const void *data, size_t size) {
    struct stat stbuf;
    off_t offset = stat(_filename.c_str(), &stbuf) != -1 ? stbuf.st_size : 0;
    FILE *file = fopen(_filename.c_str(), "ab+");
    ::fwrite((const char *)data, size, 1, file);
    fclose(file);
    return offset;
  }
  std::unique_ptr<uint8_t[]> pull(off_t offset, size_t size) const {
    std::unique_ptr<uint8_t[]> buf = std::make_unique<uint8_t[]>(size);
    FILE *file = fopen(_filename.c_str(), "rb");
    fseek(file, offset, SEEK_SET);
    ::fread(buf.get(), size, 1, file);
    fclose(file);
    return buf;
  }

private:
  std::string _filename = std::string(STORAGE_PATH) + "/mempatch_memory-snapshot";
  std::vector<SnappedRange> _saved;
};

```

`jni/Utility.cpp`:

```cpp
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <assert.h>
#include <errno.h>
#include <math.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "Utility.h"

namespace Utility {

// #ifdef __IS_NDK_BUILD__
// #include <android/log.h>
//     // Android用
//     void DebugLog(const char* format, ...)
//     {
//         char msg[65536]; // it may be buffer over flow
//         va_list args;
//
//         va_start( args, format );
//         vsnprintf(msg, sizeof(msg), format, args);
//         va_end( args );
//         __android_log_write(ANDROID_LOG_DEBUG, "mempatch", msg);
//         fprintf(stderr, "%s\n", msg);
//     }
// #else
// Linux用
void DebugLog(const char *format, ...) {
  va_list args;
  va_start(args, format);
  vfprintf(stderr, format, args);
  va_end(args);
  fprintf(stderr, "\n");
}
// #endif

void PrintErrnoString(const char *format, ...) {
  int errsv = errno;
  char msg[512];
  va_list args;

  va_start(args, format);
  vsnprintf(msg, sizeof(msg), format, args);
  va_end(args);
  DebugLog("%s(%d) : %s", strerror(errsv), errsv, msg);
}

std::string HexDump(size_t address, const char *comment, const uint8_t *data, size_t n, int indent) {
  std::string ret;
  char buffer[300];
  snprintf(buffer, 299, "Dump: %zx-%zx (%zd byte, %s)", address, address + n, n, comment);
  ret += buffer;
  for (size_t i = 0; i < n; i += 16) {
    ret += "\n";
    int index = 0;
    for (int j = 0; j < indent; j++) {
      buffer[index++] = ' ';
    }
    int s = std::min((size_t)16, n - i);
    snprintf(buffer + index, 299 - index, "%zx", address + i);
    index = strlen(buffer);
    for (int j = 0; j < 16; j++) {
      if (j % 2 == 0) {
        buffer[index++] = ' ';
      }
      if (j < s) {
        snprintf(buffer + index, 299 - index, "%02x", ((int)data[i + j] & 0xff));
        index += 2;
      } else {
        buffer[index++] = ' ';
        buffer[index++] = ' ';
      }
    }
    buffer[index++] = ' ';
    buffer[index++] = ' ';
    for (int j = 0; j < s; j++) {
      char c = data[i + j];
      if (c < 0x20 || 0x7f <= c) {
        c = '.';
      }
      buffer[index++] = c;
    }
    buffer[index] = 0;
    ret += buffer;
  }
  return ret;
}

std::vector<size_t> StrstrByRollingHash(const uint8_t *src, const uint8_t *str, size_t n, size_t l) {
  const uint32_t BASE = 1e+9 + 7;
  assert(src != nullptr);
  assert(str != nullptr);
  if (n < l || n == 0 || l == 0) {
    return std::vector<size_t>();
  }

  // strのローリングハッシュ作成
  uint32_t rolling_hash = 0;
  for (size_t i = 0; i < l; i++) {
    uint32_t v = str[i];
    rolling_hash = rolling_hash * BASE + v;
  }

  // ローリングハッシュのキャンセル用の値を作成
  uint32_t BASE_len = 1;
  for (size_t i = 0; i < l; i++) {
    BASE_len *= BASE;
  }

  // ローリングハッシュを使って出現位置を求める
  uint32_t hash = 0;
  std::vector<size_t> ret;
  if (memcmp(src, str, l) == 0) {
    ret.emplace_back(0);
  }
  for (size_t i = 0; i < l; i++) {
    uint32_t v = src[i];
    hash = hash * BASE + v;
  }
  for (size_t i = l; i < n; i++) {
    // 1文字ごとに処理
    uint32_t v = src[i];
    uint32_t prev_v = src[i - l];
    hash = hash * BASE + v - prev_v * BASE_len;
    if (hash != rolling_hash) {
      continue;
    }
    // 文字列が見つかった
    // 誤検知が発生する可能性があるので実際に比較して確認する
    size_t find_index = i - l + 1;
    if (memcmp(src + find_index, str, l) == 0) {
      ret.emplace_back(find_index);
    }
  }
  return ret;
}

std::vector<size_t> StrstrByFloatFuzzyLookup(const uint8_t *src, const uint8_t *str_from, size_t n, size_t l) {

  assert(src != nullptr);
  assert(str_from != nullptr);
  if (n < l || n == 0 || l == 0) {
    return std::vector<size_t>();
  }

  // 検索文字列を数字に戻す
  float min = 0.0f;
  float max = 0.0f;
  memcpy((uint8_t *)&min, str_from, 4);
  max = min + 1.05f;
  min = min - 0.55f; // 四捨五入のケース対応

  std::vector<size_t> ret;
  for (size_t i = 0; i < n - l; i++) {
    float v = 0.0f;
    memcpy((uint8_t *)&v, src + i, 4);

    if (v < min || v > max || isnan(v)) {
      continue;
    }

    // 文字列が見つかった
    // 誤検知が発生する可能性があるので実際に比較して確認する
    size_t find_index = i;
    ret.emplace_back(find_index);
  }
  return ret;
}

void ByteSerialize(FILE *fp, const std::vector<uint8_t> &byte) {
  fprintf(fp, "_%zd", byte.size());
  fprintf(fp, "_");
  for (size_t i = 0; i < byte.size(); i++) {
    fprintf(fp, "%c", byte[i]);
  }
}
std::vector<uint8_t> ByteDeSerialize(FILE *fp) {
  std::vector<uint8_t> byte;
  size_t length;
  fscanf(fp, "_%zd", &length);
  fscanf(fp, "_");
  byte.resize(length);
  for (size_t i = 0; i < length; i++) {
    fscanf(fp, "%c", &byte[i]);
  }
  return byte;
}
void StringSerialize(FILE *fp, const std::string &str) {
  fprintf(fp, "_%zd", str.size());
  fprintf(fp, "_");
  for (size_t i = 0; i < str.size(); i++) {
    fprintf(fp, "%c", str[i]);
  }
}
std::string StringDeSerialize(FILE *fp) {
  std::string str;
  size_t length;
  fscanf(fp, "_%zd", &length);
  fscanf(fp, "_");
  str.resize(length);
  for (size_t i = 0; i < length; i++) {
    fscanf(fp, "%c", &str[i]);
  }
  return str;
}
} // namespace Utility

```

`jni/Utility.h`:

```h
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once

#include <set>
#include <stdint.h>
#include <stdlib.h>
#include <string>
#include <vector>

#include "Converter.h"

namespace Utility {
void DebugLog(const char *format, ...);
void PrintErrnoString(const char *format, ...);
std::vector<size_t> StrstrByRollingHash(const uint8_t *src, const uint8_t *str, size_t n, size_t l);
std::vector<size_t> StrstrByFloatFuzzyLookup(const uint8_t *src, const uint8_t *str_from, size_t n, size_t l);
std::string HexDump(size_t address, const char *comment, const uint8_t *data, size_t n, int indent);

void ByteSerialize(FILE *fp, const std::vector<uint8_t> &byte);
std::vector<uint8_t> ByteDeSerialize(FILE *fp);
void StringSerialize(FILE *fp, const std::string &str);
std::string StringDeSerialize(FILE *fp);
template <class T> void SetSerialize(FILE *fp, const std::set<T> &items) {
  fprintf(fp, "_%zd", items.size());
  for (auto it = items.begin(); it != items.end(); it++) {
    it->Serialize(fp);
  }
}
template <class T> void VectorSerialize(FILE *fp, const std::vector<T> &items) {
  fprintf(fp, "_%zd", items.size());
  for (auto it = items.begin(); it != items.end(); it++) {
    it->Serialize(fp);
  }
}
template <class T> std::set<T> SetDeSerialize(FILE *fp) {
  std::set<T> ret;
  size_t length;
  fscanf(fp, "_%zd", &length);
  for (size_t i = 0; i < length; i++) {
    ret.insert(T::DeSerialize(fp));
  }
  return ret;
}
template <class T> std::vector<T> VectorDeSerialize(FILE *fp) {
  std::vector<T> ret;
  size_t length;
  fscanf(fp, "_%zd", &length);
  for (size_t i = 0; i < length; i++) {
    ret.emplace_back(T::DeSerialize(fp));
  }
  return ret;
}
} // namespace Utility

```

`jni/getopt.cpp`:

```cpp
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "getopt.h"
#include <cstring>
#include <cstdio>

char *optarg = nullptr;
int optind = 1, opterr = 1, optopt = '?';

int getopt(int argc, char *const argv[], const char *optstring) {
    static char *next = nullptr;
    if (optind == 1) {
        next = nullptr;
    }

    optarg = nullptr;

    if (next == nullptr || *next == '\0') {
        if (optind >= argc || argv[optind][0] != '-' || argv[optind][1] == '\0') {
            return -1;
        }

        if (strcmp(argv[optind], "--") == 0) {
            optind++;
            return -1;
        }

        next = argv[optind] + 1;
        optind++;
    }

    char c = *next++;
    const char *opt = strchr(optstring, c);

    if (opt == nullptr || c == ':') {
        optopt = c;
        if (opterr) {
            fprintf(stderr, "Unknown option `-%c'.\n", c);
        }
        return '?';
    }

    if (opt[1] == ':') {
        if (*next != '\0') {
            optarg = next;
            next = nullptr;
        } else if (optind < argc) {
            optarg = argv[optind];
            optind++;
        } else {
            optopt = c;
            if (opterr) {
                fprintf(stderr, "Option `-%c' requires an argument.\n", c);
            }
            return '?';
        }
    }

    return c;
}

```

`jni/getopt.h`:

```h
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once
extern char *optarg;
extern int optind, opterr, optopt;

int getopt(int argc, char *const argv[], const char *optstring);
```

`jni/linenoise/linenoise.cpp`:

```cpp
/* linenoise.c -- guerrilla line editing library against the idea that a
 * line editing lib needs to be 20,000 lines of C code.
 *
 * You can find the latest source code at:
 *
 *   http://github.com/antirez/linenoise
 *
 * Does a number of crazy assumptions that happen to be true in 99.9999% of
 * the 2010 UNIX computers around.
 *
 * ------------------------------------------------------------------------
 *
 * Copyright (c) 2010-2014, Salvatore Sanfilippo <antirez at gmail dot com>
 * Copyright (c) 2010-2013, Pieter Noordhuis <pcnoordhuis at gmail dot com>
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  *  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *  *  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ------------------------------------------------------------------------
 *
 * References:
 * - http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
 * - http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html
 *
 * Todo list:
 * - Filter bogus Ctrl+<char> combinations.
 * - Win32 support
 *
 * Bloat:
 * - History search like Ctrl+r in readline?
 *
 * List of escape sequences used by this program, we do everything just
 * with three sequences. In order to be so cheap we may have some
 * flickering effect with some slow terminal, but the lesser sequences
 * the more compatible.
 *
 * EL (Erase Line)
 *    Sequence: ESC [ n K
 *    Effect: if n is 0 or missing, clear from cursor to end of line
 *    Effect: if n is 1, clear from beginning of line to cursor
 *    Effect: if n is 2, clear entire line
 *
 * CUF (CUrsor Forward)
 *    Sequence: ESC [ n C
 *    Effect: moves cursor forward n chars
 *
 * CUB (CUrsor Backward)
 *    Sequence: ESC [ n D
 *    Effect: moves cursor backward n chars
 *
 * The following is used to get the terminal width if getting
 * the width with the TIOCGWINSZ ioctl fails
 *
 * DSR (Device Status Report)
 *    Sequence: ESC [ 6 n
 *    Effect: reports the current cusor position as ESC [ n ; m R
 *            where n is the row and m is the column
 *
 * When multi line mode is enabled, we also use an additional escape
 * sequence. However multi line editing is disabled by default.
 *
 * CUU (Cursor Up)
 *    Sequence: ESC [ n A
 *    Effect: moves cursor up of n chars.
 *
 * CUD (Cursor Down)
 *    Sequence: ESC [ n B
 *    Effect: moves cursor down of n chars.
 *
 * When linenoiseClearScreen() is called, two additional escape sequences
 * are used in order to clear the screen and position the cursor at home
 * position.
 *
 * CUP (Cursor position)
 *    Sequence: ESC [ H
 *    Effect: moves the cursor to upper left corner
 *
 * ED (Erase display)
 *    Sequence: ESC [ 2 J
 *    Effect: clear the whole screen
 *
 */

#include <termios.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include "linenoise.h"

#define LINENOISE_DEFAULT_HISTORY_MAX_LEN 100
#define LINENOISE_MAX_LINE 4096
/* static char *unsupported_term[] = {"dumb","cons25","emacs",NULL}; */
static linenoiseCompletionCallback *completionCallback = NULL;

static struct termios orig_termios; /* In order to restore at exit.*/
static int rawmode = 0; /* For atexit() function to check if restore is needed*/
static int mlmode = 0;  /* Multi line mode. Default is single line. */
static int atexit_registered = 0; /* Register atexit just 1 time. */
static int history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;
static int history_len = 0;
static char **history = NULL;

/* The linenoiseState structure represents the state during line editing.
 * We pass this state to functions implementing specific editing
 * functionalities. */
struct linenoiseState {
    int ifd;            /* Terminal stdin file descriptor. */
    int ofd;            /* Terminal stdout file descriptor. */
    char *buf;          /* Edited line buffer. */
    size_t buflen;      /* Edited line buffer size. */
    const char *prompt; /* Prompt to display. */
    size_t plen;        /* Prompt length. */
    size_t pos;         /* Current cursor position. */
    size_t oldpos;      /* Previous refresh cursor position. */
    size_t len;         /* Current edited line length. */
    size_t cols;        /* Number of columns in terminal. */
    size_t maxrows;     /* Maximum num of rows used so far (multiline mode) */
    int history_index;  /* The history index we are currently editing. */
};

enum KEY_ACTION{
	KEY_NULL = 0,	    /* NULL */
	CTRL_A = 1,         /* Ctrl+a */
	CTRL_B = 2,         /* Ctrl-b */
	CTRL_C = 3,         /* Ctrl-c */
	CTRL_D = 4,         /* Ctrl-d */
	CTRL_E = 5,         /* Ctrl-e */
	CTRL_F = 6,         /* Ctrl-f */
	CTRL_H = 8,         /* Ctrl-h */
	TAB = 9,            /* Tab */
    ENTER1 = 10,        /* Enter (\n) */
	CTRL_K = 11,        /* Ctrl+k */
	CTRL_L = 12,        /* Ctrl+l */
	ENTER2 = 13,         /* Enter (\r) */
	CTRL_N = 14,        /* Ctrl-n */
	CTRL_P = 16,        /* Ctrl-p */
	CTRL_T = 20,        /* Ctrl-t */
	CTRL_U = 21,        /* Ctrl+u */
	CTRL_W = 23,        /* Ctrl+w */
	ESC = 27,           /* Escape */
	BACKSPACE =  127    /* Backspace */
};

static void linenoiseAtExit(void);
int linenoiseHistoryAdd(const char *line);
static void refreshLine(struct linenoiseState *l);

/* Debugging macro. */
#if 0
FILE *lndebug_fp = NULL;
#define lndebug(...) \
    do { \
        if (lndebug_fp == NULL) { \
            lndebug_fp = fopen("/tmp/lndebug.txt","a"); \
            fprintf(lndebug_fp, \
            "[%d %d %d] p: %d, rows: %d, rpos: %d, max: %d, oldmax: %d\n", \
            (int)l->len,(int)l->pos,(int)l->oldpos,plen,rows,rpos, \
            (int)l->maxrows,old_rows); \
        } \
        fprintf(lndebug_fp, ", " __VA_ARGS__); \
        fflush(lndebug_fp); \
    } while (0)
#else
#define lndebug(fmt, ...)
#endif

/* ======================= Low level terminal handling ====================== */

/* Set if to use or not the multi line mode. */
void linenoiseSetMultiLine(int ml) {
    mlmode = ml;
}

/* Return true if the terminal name is in the list of terminals we know are
 * not able to understand basic escape sequences. */
static int isUnsupportedTerm(void) {
    /* char *term = getenv("TERM"); */
    /* int j; */

    /* if (term == NULL) return 0; */
    /* for (j = 0; unsupported_term[j]; j++) */
    /*     if (!strcasecmp(term,unsupported_term[j])) return 1; */
    return 0;
}

/* Raw mode: 1960 magic shit. */
static int enableRawMode(int fd) {
    struct termios raw;

    if (!isatty(STDIN_FILENO)) goto fatal;
    if (!atexit_registered) {
        atexit(linenoiseAtExit);
        atexit_registered = 1;
    }
    if (tcgetattr(fd,&orig_termios) == -1) goto fatal;

    raw = orig_termios;  /* modify the original mode */
    /* input modes: no break, no CR to NL, no parity check, no strip char,
     * no start/stop output control. */
    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
    /* output modes - disable post processing */
    raw.c_oflag &= ~(OPOST);
    /* control modes - set 8 bit chars */
    raw.c_cflag |= (CS8);
    /* local modes - choing off, canonical off, no extended functions,
     * no signal chars (^Z,^C) */
    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
    /* control chars - set return condition: min number of bytes and timer.
     * We want read to return every single byte, without timeout. */
    raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /* 1 byte, no timer */

    /* put terminal in raw mode after flushing */
    if (tcsetattr(fd,TCSANOW,&raw) < 0) goto fatal;
    rawmode = 1;
    return 0;

fatal:
    errno = ENOTTY;
    return -1;
}

static void disableRawMode(int fd) {
    /* Don't even check the return value as it's too late. */
    if (rawmode && tcsetattr(fd,TCSANOW,&orig_termios) != -1)
        rawmode = 0;
}

/* Use the ESC [6n escape sequence to query the horizontal cursor position
 * and return it. On error -1 is returned, on success the position of the
 * cursor. */
static int getCursorPosition(int ifd, int ofd) {
    char buf[32];
    int cols, rows;
    unsigned int i = 0;

    /* Report cursor location */
    if (write(ofd, "\x1b[6n", 4) != 4) return -1;

    /* Read the response: ESC [ rows ; cols R */
    while (i < sizeof(buf)-1) {
        if (read(ifd,buf+i,1) != 1) break;
        if (buf[i] == 'R') break;
        i++;
    }
    buf[i] = '\0';

    /* Parse it. */
    if (buf[0] != ESC || buf[1] != '[') return -1;
    if (sscanf(buf+2,"%d;%d",&rows,&cols) != 2) return -1;
    return cols;
}

/* Try to get the number of columns in the current terminal, or assume 80
 * if it fails. */
static int getColumns(int ifd, int ofd) {
    struct winsize ws;

    if (ioctl(1, TIOCGWINSZ, &ws) == -1 || ws.ws_col == 0) {
        /* ioctl() failed. Try to query the terminal itself. */
        int start, cols;

        /* Get the initial position so we can restore it later. */
        start = getCursorPosition(ifd,ofd);
        if (start == -1) goto failed;

        /* Go to right margin and get position. */
        if (write(ofd,"\x1b[999C",6) != 6) goto failed;
        cols = getCursorPosition(ifd,ofd);
        if (cols == -1) goto failed;

        /* Restore position. */
        if (cols > start) {
            char seq[32];
            snprintf(seq,32,"\x1b[%dD",cols-start);
            if (write(ofd,seq,strlen(seq)) == -1) {
                /* Can't recover... */
            }
        }
        return cols;
    } else {
        return ws.ws_col;
    }

failed:
    return 80;
}

/* Clear the screen. Used to handle ctrl+l */
void linenoiseClearScreen(void) {
    if (write(STDOUT_FILENO,"\x1b[H\x1b[2J",7) <= 0) {
        /* nothing to do, just to avoid warning. */
    }
}

/* Beep, used for completion when there is nothing to complete or when all
 * the choices were already shown. */
static void linenoiseBeep(void) {
    fprintf(stderr, "\x7");
    fflush(stderr);
}

/* ============================== Completion ================================ */

/* Free a list of completion option populated by linenoiseAddCompletion(). */
static void freeCompletions(linenoiseCompletions *lc) {
    size_t i;
    for (i = 0; i < lc->len; i++)
        free(lc->cvec[i]);
    if (lc->cvec != NULL)
        free(lc->cvec);
}

/* This is an helper function for linenoiseEdit() and is called when the
 * user types the <tab> key in order to complete the string currently in the
 * input.
 *
 * The state of the editing is encapsulated into the pointed linenoiseState
 * structure as described in the structure definition. */
static int completeLine(struct linenoiseState *ls) {
    linenoiseCompletions lc = { 0, NULL };
    int nread, nwritten;
    char c = 0;

    completionCallback(ls->buf,&lc);
    if (lc.len == 0) {
        linenoiseBeep();
    } else {
        size_t stop = 0, i = 0;

        while(!stop) {
            /* Show completion or original buffer */
            if (i < lc.len) {
                struct linenoiseState saved = *ls;

                ls->len = ls->pos = strlen(lc.cvec[i]);
                ls->buf = lc.cvec[i];
                refreshLine(ls);
                ls->len = saved.len;
                ls->pos = saved.pos;
                ls->buf = saved.buf;
            } else {
                refreshLine(ls);
            }

            nread = read(ls->ifd,&c,1);
            if (nread <= 0) {
                freeCompletions(&lc);
                return -1;
            }

            switch(c) {
                case 9: /* tab */
                    i = (i+1) % (lc.len+1);
                    if (i == lc.len) linenoiseBeep();
                    break;
                case 27: /* escape */
                    /* Re-show original buffer */
                    if (i < lc.len) refreshLine(ls);
                    stop = 1;
                    break;
                default:
                    /* Update buffer and return */
                    if (i < lc.len) {
                        nwritten = snprintf(ls->buf,ls->buflen,"%s",lc.cvec[i]);
                        ls->len = ls->pos = nwritten;
                    }
                    stop = 1;
                    break;
            }
        }
    }

    freeCompletions(&lc);
    return c; /* Return last read character */
}

/* Register a callback function to be called for tab-completion. */
void linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn) {
    completionCallback = fn;
}

/* This function is used by the callback function registered by the user
 * in order to add completion options given the input string when the
 * user typed <tab>. See the example.c source code for a very easy to
 * understand example. */
void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {
    size_t len = strlen(str);
    char *copy, **cvec;

    copy = (char *)malloc(len+1);
    if (copy == NULL) return;
    memcpy(copy,str,len+1);
    cvec = (char **)realloc(lc->cvec,sizeof(char*)*(lc->len+1));
    if (cvec == NULL) {
        free(copy);
        return;
    }
    lc->cvec = cvec;
    lc->cvec[lc->len++] = copy;
}

/* =========================== Line editing ================================= */

/* We define a very simple "append buffer" structure, that is an heap
 * allocated string where we can append to. This is useful in order to
 * write all the escape sequences in a buffer and flush them to the standard
 * output in a single call, to avoid flickering effects. */
struct abuf {
    char *b;
    int len;
};

static void abInit(struct abuf *ab) {
    ab->b = NULL;
    ab->len = 0;
}

static void abAppend(struct abuf *ab, const char *s, int len) {
    char *t_new = (char *)realloc(ab->b,ab->len+len);

    if (t_new == NULL) return;
    memcpy(t_new+ab->len,s,len);
    ab->b = t_new;
    ab->len += len;
}

static void abFree(struct abuf *ab) {
    free(ab->b);
}

/* Single line low level line refresh.
 *
 * Rewrite the currently edited line accordingly to the buffer content,
 * cursor position, and number of columns of the terminal. */
static void refreshSingleLine(struct linenoiseState *l) {
    char seq[64];
    size_t plen = strlen(l->prompt);
    int fd = l->ofd;
    char *buf = l->buf;
    size_t len = l->len;
    size_t pos = l->pos;
    struct abuf ab;

    while((plen+pos) >= l->cols) {
        buf++;
        len--;
        pos--;
    }
    while (plen+len > l->cols) {
        len--;
    }

    abInit(&ab);
    /* Cursor to left edge */
    snprintf(seq,64,"\r");
    abAppend(&ab,seq,strlen(seq));
    /* Write the prompt and the current buffer content */
    abAppend(&ab,l->prompt,strlen(l->prompt));
    abAppend(&ab,buf,len);
    /* Erase to right */
    snprintf(seq,64,"\x1b[0K");
    abAppend(&ab,seq,strlen(seq));
    /* Move cursor to original position. */
    snprintf(seq,64,"\r\x1b[%dC", (int)(pos+plen));
    abAppend(&ab,seq,strlen(seq));
    if (write(fd,ab.b,ab.len) == -1) {} /* Can't recover from write error. */
    abFree(&ab);
}

/* Multi line low level line refresh.
 *
 * Rewrite the currently edited line accordingly to the buffer content,
 * cursor position, and number of columns of the terminal. */
static void refreshMultiLine(struct linenoiseState *l) {
    char seq[64];
    int plen = strlen(l->prompt);
    int rows = (plen+l->len+l->cols-1)/l->cols; /* rows used by current buf. */
    int rpos = (plen+l->oldpos+l->cols)/l->cols; /* cursor relative row. */
    int rpos2; /* rpos after refresh. */
    int col; /* colum position, zero-based. */
    int old_rows = l->maxrows;
    int fd = l->ofd, j;
    struct abuf ab;

    /* Update maxrows if needed. */
    if (rows > (int)l->maxrows) l->maxrows = rows;

    /* First step: clear all the lines used before. To do so start by
     * going to the last row. */
    abInit(&ab);
    if (old_rows-rpos > 0) {
        lndebug("go down %d", old_rows-rpos);
        snprintf(seq,64,"\x1b[%dB", old_rows-rpos);
        abAppend(&ab,seq,strlen(seq));
    }

    /* Now for every row clear it, go up. */
    for (j = 0; j < old_rows-1; j++) {
        lndebug("clear+up");
        snprintf(seq,64,"\r\x1b[0K\x1b[1A");
        abAppend(&ab,seq,strlen(seq));
    }

    /* Clean the top line. */
    lndebug("clear");
    snprintf(seq,64,"\r\x1b[0K");
    abAppend(&ab,seq,strlen(seq));

    /* Write the prompt and the current buffer content */
    abAppend(&ab,l->prompt,strlen(l->prompt));
    abAppend(&ab,l->buf,l->len);

    /* If we are at the very end of the screen with our prompt, we need to
     * emit a newline and move the prompt to the first column. */
    if (l->pos &&
        l->pos == l->len &&
        (l->pos+plen) % l->cols == 0)
    {
        lndebug("<newline>");
        abAppend(&ab,"\n",1);
        snprintf(seq,64,"\r");
        abAppend(&ab,seq,strlen(seq));
        rows++;
        if (rows > (int)l->maxrows) l->maxrows = rows;
    }

    /* Move cursor to right position. */
    rpos2 = (plen+l->pos+l->cols)/l->cols; /* current cursor relative row. */
    lndebug("rpos2 %d", rpos2);

    /* Go up till we reach the expected positon. */
    if (rows-rpos2 > 0) {
        lndebug("go-up %d", rows-rpos2);
        snprintf(seq,64,"\x1b[%dA", rows-rpos2);
        abAppend(&ab,seq,strlen(seq));
    }

    /* Set column. */
    col = (plen+(int)l->pos) % (int)l->cols;
    lndebug("set col %d", 1+col);
    if (col)
        snprintf(seq,64,"\r\x1b[%dC", col);
    else
        snprintf(seq,64,"\r");
    abAppend(&ab,seq,strlen(seq));

    lndebug("\n");
    l->oldpos = l->pos;

    if (write(fd,ab.b,ab.len) == -1) {} /* Can't recover from write error. */
    abFree(&ab);
}

/* Calls the two low level functions refreshSingleLine() or
 * refreshMultiLine() according to the selected mode. */
static void refreshLine(struct linenoiseState *l) {
    if (mlmode)
        refreshMultiLine(l);
    else
        refreshSingleLine(l);
}

/* Insert the character 'c' at cursor current position.
 *
 * On error writing to the terminal -1 is returned, otherwise 0. */
int linenoiseEditInsert(struct linenoiseState *l, char c) {
    if (l->len < l->buflen) {
        if (l->len == l->pos) {
            l->buf[l->pos] = c;
            l->pos++;
            l->len++;
            l->buf[l->len] = '\0';
            if ((!mlmode && l->plen+l->len < l->cols) /* || mlmode */) {
                /* Avoid a full update of the line in the
                 * trivial case. */
                if (write(l->ofd,&c,1) == -1) return -1;
            } else {
                refreshLine(l);
            }
        } else {
            memmove(l->buf+l->pos+1,l->buf+l->pos,l->len-l->pos);
            l->buf[l->pos] = c;
            l->len++;
            l->pos++;
            l->buf[l->len] = '\0';
            refreshLine(l);
        }
    }
    return 0;
}

/* Move cursor on the left. */
void linenoiseEditMoveLeft(struct linenoiseState *l) {
    if (l->pos > 0) {
        l->pos--;
        refreshLine(l);
    }
}

/* Move cursor on the right. */
void linenoiseEditMoveRight(struct linenoiseState *l) {
    if (l->pos != l->len) {
        l->pos++;
        refreshLine(l);
    }
}

/* Move cursor to the start of the line. */
void linenoiseEditMoveHome(struct linenoiseState *l) {
    if (l->pos != 0) {
        l->pos = 0;
        refreshLine(l);
    }
}

/* Move cursor to the end of the line. */
void linenoiseEditMoveEnd(struct linenoiseState *l) {
    if (l->pos != l->len) {
        l->pos = l->len;
        refreshLine(l);
    }
}

/* Substitute the currently edited line with the next or previous history
 * entry as specified by 'dir'. */
#define LINENOISE_HISTORY_NEXT 0
#define LINENOISE_HISTORY_PREV 1
void linenoiseEditHistoryNext(struct linenoiseState *l, int dir) {
    if (history_len > 1) {
        /* Update the current history entry before to
         * overwrite it with the next one. */
        free(history[history_len - 1 - l->history_index]);
        history[history_len - 1 - l->history_index] = strdup(l->buf);
        /* Show the new entry */
        l->history_index += (dir == LINENOISE_HISTORY_PREV) ? 1 : -1;
        if (l->history_index < 0) {
            l->history_index = 0;
            return;
        } else if (l->history_index >= history_len) {
            l->history_index = history_len-1;
            return;
        }
        strncpy(l->buf,history[history_len - 1 - l->history_index],l->buflen);
        l->buf[l->buflen-1] = '\0';
        l->len = l->pos = strlen(l->buf);
        refreshLine(l);
    }
}

/* Delete the character at the right of the cursor without altering the cursor
 * position. Basically this is what happens with the "Delete" keyboard key. */
void linenoiseEditDelete(struct linenoiseState *l) {
    if (l->len > 0 && l->pos < l->len) {
        memmove(l->buf+l->pos,l->buf+l->pos+1,l->len-l->pos-1);
        l->len--;
        l->buf[l->len] = '\0';
        refreshLine(l);
    }
}

/* Backspace implementation. */
void linenoiseEditBackspace(struct linenoiseState *l) {
    if (l->pos > 0 && l->len > 0) {
        memmove(l->buf+l->pos-1,l->buf+l->pos,l->len-l->pos);
        l->pos--;
        l->len--;
        l->buf[l->len] = '\0';
        refreshLine(l);
    }
}

/* Delete the previosu word, maintaining the cursor at the start of the
 * current word. */
void linenoiseEditDeletePrevWord(struct linenoiseState *l) {
    size_t old_pos = l->pos;
    size_t diff;

    while (l->pos > 0 && l->buf[l->pos-1] == ' ')
        l->pos--;
    while (l->pos > 0 && l->buf[l->pos-1] != ' ')
        l->pos--;
    diff = old_pos - l->pos;
    memmove(l->buf+l->pos,l->buf+old_pos,l->len-old_pos+1);
    l->len -= diff;
    refreshLine(l);
}

/* This function is the core of the line editing capability of linenoise.
 * It expects 'fd' to be already in "raw mode" so that every key pressed
 * will be returned ASAP to read().
 *
 * The resulting string is put into 'buf' when the user type enter, or
 * when ctrl+d is typed.
 *
 * The function returns the length of the current buffer. */
static int linenoiseEdit(int stdin_fd, int stdout_fd, char *buf, size_t buflen, const char *prompt)
{
    struct linenoiseState l;

    /* Populate the linenoise state that we pass to functions implementing
     * specific editing functionalities. */
    l.ifd = stdin_fd;
    l.ofd = stdout_fd;
    l.buf = buf;
    l.buflen = buflen;
    l.prompt = prompt;
    l.plen = strlen(prompt);
    l.oldpos = l.pos = 0;
    l.len = 0;
    l.cols = getColumns(stdin_fd, stdout_fd);
    l.maxrows = 0;
    l.history_index = 0;

    /* Buffer starts empty. */
    l.buf[0] = '\0';
    l.buflen--; /* Make sure there is always space for the nulterm */

    /* The latest history entry is always our current buffer, that
     * initially is just an empty string. */
    linenoiseHistoryAdd("");

    if (write(l.ofd,prompt,l.plen) == -1) return -1;
    while(1) {
        char c;
        int nread;
        char seq[3];

        nread = read(l.ifd,&c,1);
        if (nread <= 0) return l.len;

        /* Only autocomplete when the callback is set. It returns < 0 when
         * there was an error reading from fd. Otherwise it will return the
         * character that should be handled next. */
        if (c == 9 && completionCallback != NULL) {
            c = completeLine(&l);
            /* Return on errors */
            if (c < 0) return l.len;
            /* Read next character when 0 */
            if (c == 0) continue;
        }

        switch(c) {
        case ENTER1:    /* enter */
        case ENTER2:    /* enter */
            history_len--;
            free(history[history_len]);
            if (mlmode) linenoiseEditMoveEnd(&l);
            return (int)l.len;
        case CTRL_C:     /* ctrl-c */
            errno = EAGAIN;
            return -1;
        case BACKSPACE:   /* backspace */
        case 8:     /* ctrl-h */
            linenoiseEditBackspace(&l);
            break;
        case CTRL_D:     /* ctrl-d, remove char at right of cursor, or if the
                            line is empty, act as end-of-file. */
            if (l.len > 0) {
                linenoiseEditDelete(&l);
            } else {
                history_len--;
                free(history[history_len]);
                return -1;
            }
            break;
        case CTRL_T:    /* ctrl-t, swaps current character with previous. */
            if (l.pos > 0 && l.pos < l.len) {
                int aux = buf[l.pos-1];
                buf[l.pos-1] = buf[l.pos];
                buf[l.pos] = aux;
                if (l.pos != l.len-1) l.pos++;
                refreshLine(&l);
            }
            break;
        case CTRL_B:     /* ctrl-b */
            linenoiseEditMoveLeft(&l);
            break;
        case CTRL_F:     /* ctrl-f */
            linenoiseEditMoveRight(&l);
            break;
        case CTRL_P:    /* ctrl-p */
            linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_PREV);
            break;
        case CTRL_N:    /* ctrl-n */
            linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_NEXT);
            break;
        case ESC:    /* escape sequence */
            /* Read the next two bytes representing the escape sequence.
             * Use two calls to handle slow terminals returning the two
             * chars at different times. */
            if (read(l.ifd,seq,1) == -1) break;
            if (read(l.ifd,seq+1,1) == -1) break;

            /* ESC [ sequences. */
            if (seq[0] == '[') {
                if (seq[1] >= '0' && seq[1] <= '9') {
                    /* Extended escape, read additional byte. */
                    if (read(l.ifd,seq+2,1) == -1) break;
                    if (seq[2] == '~') {
                        switch(seq[1]) {
                        case '3': /* Delete key. */
                            linenoiseEditDelete(&l);
                            break;
                        }
                    }
                } else {
                    switch(seq[1]) {
                    case 'A': /* Up */
                        linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_PREV);
                        break;
                    case 'B': /* Down */
                        linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_NEXT);
                        break;
                    case 'C': /* Right */
                        linenoiseEditMoveRight(&l);
                        break;
                    case 'D': /* Left */
                        linenoiseEditMoveLeft(&l);
                        break;
                    case 'H': /* Home */
                        linenoiseEditMoveHome(&l);
                        break;
                    case 'F': /* End*/
                        linenoiseEditMoveEnd(&l);
                        break;
                    }
                }
            }

            /* ESC O sequences. */
            else if (seq[0] == 'O') {
                switch(seq[1]) {
                case 'H': /* Home */
                    linenoiseEditMoveHome(&l);
                    break;
                case 'F': /* End*/
                    linenoiseEditMoveEnd(&l);
                    break;
                }
            }
            break;
        default:
            if (linenoiseEditInsert(&l,c)) return -1;
            break;
        case CTRL_U: /* Ctrl+u, delete the whole line. */
            buf[0] = '\0';
            l.pos = l.len = 0;
            refreshLine(&l);
            break;
        case CTRL_K: /* Ctrl+k, delete from current to end of line. */
            buf[l.pos] = '\0';
            l.len = l.pos;
            refreshLine(&l);
            break;
        case CTRL_A: /* Ctrl+a, go to the start of the line */
            linenoiseEditMoveHome(&l);
            break;
        case CTRL_E: /* ctrl+e, go to the end of the line */
            linenoiseEditMoveEnd(&l);
            break;
        case CTRL_L: /* ctrl+l, clear screen */
            linenoiseClearScreen();
            refreshLine(&l);
            break;
        case CTRL_W: /* ctrl+w, delete previous word */
            linenoiseEditDeletePrevWord(&l);
            break;
        }
    }
    return l.len;
}

/* This special mode is used by linenoise in order to print scan codes
 * on screen for debugging / development purposes. It is implemented
 * by the linenoise_example program using the --keycodes option. */
void linenoisePrintKeyCodes(void) {
    char quit[4];

    printf("Linenoise key codes debugging mode.\n"
            "Press keys to see scan codes. Type 'quit' at any time to exit.\n");
    if (enableRawMode(STDIN_FILENO) == -1) return;
    memset(quit,' ',4);
    while(1) {
        char c;
        int nread;

        nread = read(STDIN_FILENO,&c,1);
        if (nread <= 0) continue;
        memmove(quit,quit+1,sizeof(quit)-1); /* shift string to left. */
        quit[sizeof(quit)-1] = c; /* Insert current char on the right. */
        if (memcmp(quit,"quit",sizeof(quit)) == 0) break;

        printf("'%c' %02x (%d) (type quit to exit)\n",
            isprint(c) ? c : '?', (int)c, (int)c);
        printf("\r"); /* Go left edge manually, we are in raw mode. */
        fflush(stdout);
    }
    disableRawMode(STDIN_FILENO);
}

/* This function calls the line editing function linenoiseEdit() using
 * the STDIN file descriptor set in raw mode. */
static int linenoiseRaw(char *buf, size_t buflen, const char *prompt) {
    int count;

    if (buflen == 0) {
        errno = EINVAL;
        return -1;
    }
    if (!isatty(STDIN_FILENO)) {
        /* Not a tty: read from file / pipe. */
        if (fgets(buf, buflen, stdin) == NULL) return -1;
        count = strlen(buf);
        if (count && buf[count-1] == '\n') {
            count--;
            buf[count] = '\0';
        }
    } else {
        /* Interactive editing. */
        if (enableRawMode(STDIN_FILENO) == -1) return -1;
        count = linenoiseEdit(STDIN_FILENO, STDOUT_FILENO, buf, buflen, prompt);
        disableRawMode(STDIN_FILENO);
        printf("\n");
    }
    return count;
}

/* The high level function that is the main API of the linenoise library.
 * This function checks if the terminal has basic capabilities, just checking
 * for a blacklist of stupid terminals, and later either calls the line
 * editing function or uses dummy fgets() so that you will be able to type
 * something even in the most desperate of the conditions. */
char *linenoise(const char *prompt) {
    char buf[LINENOISE_MAX_LINE];
    int count;

    if (isUnsupportedTerm()) {
        size_t len;

        printf("%s",prompt);
        fflush(stdout);
        if (fgets(buf,LINENOISE_MAX_LINE,stdin) == NULL) return NULL;
        len = strlen(buf);
        while(len && (buf[len-1] == '\n' || buf[len-1] == '\r')) {
            len--;
            buf[len] = '\0';
        }
        return strdup(buf);
    } else {
        count = linenoiseRaw(buf,LINENOISE_MAX_LINE,prompt);
        if (count == -1) return NULL;
        return strdup(buf);
    }
}

/* ================================ History ================================= */

/* Free the history, but does not reset it. Only used when we have to
 * exit() to avoid memory leaks are reported by valgrind & co. */
static void freeHistory(void) {
    if (history) {
        int j;

        for (j = 0; j < history_len; j++)
            free(history[j]);
        free(history);
    }
}

/* At exit we'll try to fix the terminal to the initial conditions. */
static void linenoiseAtExit(void) {
    disableRawMode(STDIN_FILENO);
    freeHistory();
}

/* This is the API call to add a new entry in the linenoise history.
 * It uses a fixed array of char pointers that are shifted (memmoved)
 * when the history max length is reached in order to remove the older
 * entry and make room for the new one, so it is not exactly suitable for huge
 * histories, but will work well for a few hundred of entries.
 *
 * Using a circular buffer is smarter, but a bit more complex to handle. */
int linenoiseHistoryAdd(const char *line) {
    char *linecopy;

    if (history_max_len == 0) return 0;

    /* Initialization on first call. */
    if (history == NULL) {
        history = (char **)malloc(sizeof(char*)*history_max_len);
        if (history == NULL) return 0;
        memset(history,0,(sizeof(char*)*history_max_len));
    }

    /* Don't add duplicated lines. */
    if (history_len && !strcmp(history[history_len-1], line)) return 0;

    /* Add an heap allocated copy of the line in the history.
     * If we reached the max length, remove the older line. */
    linecopy = strdup(line);
    if (!linecopy) return 0;
    if (history_len == history_max_len) {
        free(history[0]);
        memmove(history,history+1,sizeof(char*)*(history_max_len-1));
        history_len--;
    }
    history[history_len] = linecopy;
    history_len++;
    return 1;
}

/* Set the maximum length for the history. This function can be called even
 * if there is already some history, the function will make sure to retain
 * just the latest 'len' elements if the new history length value is smaller
 * than the amount of items already inside the history. */
int linenoiseHistorySetMaxLen(int len) {
    char **t_new;

    if (len < 1) return 0;
    if (history) {
        int tocopy = history_len;

        t_new = (char **)malloc(sizeof(char*)*len);
        if (t_new == NULL) return 0;

        /* If we can't copy everything, free the elements we'll not use. */
        if (len < tocopy) {
            int j;

            for (j = 0; j < tocopy-len; j++) free(history[j]);
            tocopy = len;
        }
        memset(t_new,0,sizeof(char*)*len);
        memcpy(t_new,history+(history_len-tocopy), sizeof(char*)*tocopy);
        free(history);
        history = t_new;
    }
    history_max_len = len;
    if (history_len > history_max_len)
        history_len = history_max_len;
    return 1;
}

/* Save the history in the specified file. On success 0 is returned
 * otherwise -1 is returned. */
int linenoiseHistorySave(const char *filename) {
    FILE *fp = fopen(filename,"w");
    int j;

    if (fp == NULL) return -1;
    for (j = 0; j < history_len; j++)
        fprintf(fp,"%s\n",history[j]);
    fclose(fp);
    return 0;
}

/* Load the history from the specified file. If the file does not exist
 * zero is returned and no operation is performed.
 *
 * If the file exists and the operation succeeded 0 is returned, otherwise
 * on error -1 is returned. */
int linenoiseHistoryLoad(const char *filename) {
    FILE *fp = fopen(filename,"r");
    char buf[LINENOISE_MAX_LINE];

    if (fp == NULL) return -1;

    while (fgets(buf,LINENOISE_MAX_LINE,fp) != NULL) {
        char *p;

        p = strchr(buf,'\r');
        if (!p) p = strchr(buf,'\n');
        if (p) *p = '\0';
        linenoiseHistoryAdd(buf);
    }
    fclose(fp);
    return 0;
}

```

`jni/linenoise/linenoise.h`:

```h
/* linenoise.h -- guerrilla line editing library against the idea that a
 * line editing lib needs to be 20,000 lines of C code.
 *
 * See linenoise.c for more information.
 *
 * ------------------------------------------------------------------------
 *
 * Copyright (c) 2010-2014, Salvatore Sanfilippo <antirez at gmail dot com>
 * Copyright (c) 2010-2013, Pieter Noordhuis <pcnoordhuis at gmail dot com>
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  *  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *  *  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef __LINENOISE_H
#define __LINENOISE_H

#ifdef __cplusplus
extern "C" {
#endif

typedef struct linenoiseCompletions {
  size_t len;
  char **cvec;
} linenoiseCompletions;

typedef void(linenoiseCompletionCallback)(const char *, linenoiseCompletions *);
void linenoiseSetCompletionCallback(linenoiseCompletionCallback *);
void linenoiseAddCompletion(linenoiseCompletions *, const char *);

char *linenoise(const char *prompt);
int linenoiseHistoryAdd(const char *line);
int linenoiseHistorySetMaxLen(int len);
int linenoiseHistorySave(const char *filename);
int linenoiseHistoryLoad(const char *filename);
void linenoiseClearScreen(void);
void linenoiseSetMultiLine(int ml);
void linenoisePrintKeyCodes(void);

#ifdef __cplusplus
}
#endif

#endif /* __LINENOISE_H */

```

`jni/linenoise/linenoise.hpp`:

```hpp
/*
 *  linenoise.hpp -- Multi-platform C++ header-only linenoise library.
 *
 *  All credits and commendations have to go to the authors of the
 *  following excellent libraries.
 *
 *  - linenoise.h and linenoise.c (https://github.com/antirez/linenoise)
 *  - ANSI.c (https://github.com/adoxa/ansicon)
 *  - Win32_ANSI.h and Win32_ANSI.c (https://github.com/MSOpenTech/redis)
 *
 * ------------------------------------------------------------------------
 *
 *  Copyright (c) 2015 yhirose
 *  All rights reserved.
 *  
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *  
 *  1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *  
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* linenoise.h -- guerrilla line editing library against the idea that a
 * line editing lib needs to be 20,000 lines of C code.
 *
 * See linenoise.c for more information.
 *
 * ------------------------------------------------------------------------
 *
 * Copyright (c) 2010, Salvatore Sanfilippo <antirez at gmail dot com>
 * Copyright (c) 2010, Pieter Noordhuis <pcnoordhuis at gmail dot com>
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  *  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *  *  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * ANSI.c - ANSI escape sequence console driver.
 *
 * Copyright (C) 2005-2014 Jason Hood
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the author be held liable for any damages
 * arising from the use of this software.
 * 
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 * 
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 * 
 * Jason Hood
 * jadoxa@yahoo.com.au
 */

/*
 * Win32_ANSI.h and Win32_ANSI.c
 *
 * Derived from ANSI.c by Jason Hood, from his ansicon project (https://github.com/adoxa/ansicon), with modifications.
 *
 * Copyright (c), Microsoft Open Technologies, Inc.
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *  - Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  - Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef LINENOISE_HPP
#define LINENOISE_HPP

#ifndef _WIN32
#include <termios.h>
#include <unistd.h>
#include <sys/ioctl.h>
#else
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <Windows.h>
#include <io.h>
#ifndef STDIN_FILENO
#define STDIN_FILENO (_fileno(stdin))
#endif
#ifndef STDOUT_FILENO
#define STDOUT_FILENO 1
#endif
#define isatty _isatty
#define write win32_write
#define read _read
#pragma warning(push)
#pragma warning(disable : 4996)
#endif
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <ctype.h>
#include <sys/types.h>
#include <string>
#include <fstream>
#include <functional>
#include <vector>
#include <iostream>

namespace linenoise {

typedef std::function<void (const char*, std::vector<std::string>&)> CompletionCallback;

#ifdef _WIN32

namespace ansi {

#define lenof(array) (sizeof(array)/sizeof(*(array)))

typedef struct
{
    BYTE foreground;    // ANSI base color (0 to 7; add 30)
    BYTE background;    // ANSI base color (0 to 7; add 40)
    BYTE bold;  // console FOREGROUND_INTENSITY bit
    BYTE underline; // console BACKGROUND_INTENSITY bit
    BYTE rvideo;    // swap foreground/bold & background/underline
    BYTE concealed; // set foreground/bold to background/underline
    BYTE reverse; // swap console foreground & background attributes
} GRM, *PGRM;   // Graphic Rendition Mode


inline bool is_digit(char c) { return '0' <= c && c <= '9'; }

// ========== Global variables and constants

HANDLE    hConOut;      // handle to CONOUT$

const char ESC = '\x1B'; // ESCape character
const char BEL = '\x07';
const char SO = '\x0E';  // Shift Out
const char SI = '\x0F';  // Shift In

const int MAX_ARG = 16;     // max number of args in an escape sequence
int   state;                // automata state
WCHAR prefix;               // escape sequence prefix ( '[', ']' or '(' );
WCHAR prefix2;              // secondary prefix ( '?' or '>' );
WCHAR suffix;               // escape sequence suffix
int   es_argc;              // escape sequence args count
int   es_argv[MAX_ARG];     // escape sequence args
WCHAR Pt_arg[MAX_PATH * 2]; // text parameter for Operating System Command
int   Pt_len;
BOOL  shifted;


// DEC Special Graphics Character Set from
// http://vt100.net/docs/vt220-rm/table2-4.html
// Some of these may not look right, depending on the font and code page (in
// particular, the Control Pictures probably won't work at all).
const WCHAR G1[] =
{
    ' ',          // _ - blank
    L'\x2666',    // ` - Black Diamond Suit
    L'\x2592',    // a - Medium Shade
    L'\x2409',    // b - HT
    L'\x240c',    // c - FF
    L'\x240d',    // d - CR
    L'\x240a',    // e - LF
    L'\x00b0',    // f - Degree Sign
    L'\x00b1',    // g - Plus-Minus Sign
    L'\x2424',    // h - NL
    L'\x240b',    // i - VT
    L'\x2518',    // j - Box Drawings Light Up And Left
    L'\x2510',    // k - Box Drawings Light Down And Left
    L'\x250c',    // l - Box Drawings Light Down And Right
    L'\x2514',    // m - Box Drawings Light Up And Right
    L'\x253c',    // n - Box Drawings Light Vertical And Horizontal
    L'\x00af',    // o - SCAN 1 - Macron
    L'\x25ac',    // p - SCAN 3 - Black Rectangle
    L'\x2500',    // q - SCAN 5 - Box Drawings Light Horizontal
    L'_',         // r - SCAN 7 - Low Line
    L'_',         // s - SCAN 9 - Low Line
    L'\x251c',    // t - Box Drawings Light Vertical And Right
    L'\x2524',    // u - Box Drawings Light Vertical And Left
    L'\x2534',    // v - Box Drawings Light Up And Horizontal
    L'\x252c',    // w - Box Drawings Light Down And Horizontal
    L'\x2502',    // x - Box Drawings Light Vertical
    L'\x2264',    // y - Less-Than Or Equal To
    L'\x2265',    // z - Greater-Than Or Equal To
    L'\x03c0',    // { - Greek Small Letter Pi
    L'\x2260',    // | - Not Equal To
    L'\x00a3',    // } - Pound Sign
    L'\x00b7',    // ~ - Middle Dot
};

#define FIRST_G1 '_'
#define LAST_G1  '~'


// color constants

#define FOREGROUND_BLACK 0
#define FOREGROUND_WHITE FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE

#define BACKGROUND_BLACK 0
#define BACKGROUND_WHITE BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE

const BYTE foregroundcolor[8] =
    {
    FOREGROUND_BLACK,                   // black foreground
    FOREGROUND_RED,                     // red foreground
    FOREGROUND_GREEN,                   // green foreground
    FOREGROUND_RED | FOREGROUND_GREEN,  // yellow foreground
    FOREGROUND_BLUE,                    // blue foreground
    FOREGROUND_BLUE | FOREGROUND_RED,   // magenta foreground
    FOREGROUND_BLUE | FOREGROUND_GREEN, // cyan foreground
    FOREGROUND_WHITE                    // white foreground
    };

const BYTE backgroundcolor[8] =
    {
    BACKGROUND_BLACK,           // black background
    BACKGROUND_RED,         // red background
    BACKGROUND_GREEN,           // green background
    BACKGROUND_RED | BACKGROUND_GREEN,  // yellow background
    BACKGROUND_BLUE,            // blue background
    BACKGROUND_BLUE | BACKGROUND_RED,   // magenta background
    BACKGROUND_BLUE | BACKGROUND_GREEN, // cyan background
    BACKGROUND_WHITE,           // white background
    };

const BYTE attr2ansi[8] =       // map console attribute to ANSI number
{
    0,                  // black
    4,                  // blue
    2,                  // green
    6,                  // cyan
    1,                  // red
    5,                  // magenta
    3,                  // yellow
    7                   // white
};

GRM grm;

// saved cursor position
COORD SavePos;

// ========== Print Buffer functions

#define BUFFER_SIZE 2048

int   nCharInBuffer;
WCHAR ChBuffer[BUFFER_SIZE];

//-----------------------------------------------------------------------------
//   FlushBuffer()
// Writes the buffer to the console and empties it.
//-----------------------------------------------------------------------------

inline void FlushBuffer(void)
{
    DWORD nWritten;
    if (nCharInBuffer <= 0) return;
    WriteConsoleW(hConOut, ChBuffer, nCharInBuffer, &nWritten, NULL);
    nCharInBuffer = 0;
}

//-----------------------------------------------------------------------------
//   PushBuffer( WCHAR c )
// Adds a character in the buffer.
//-----------------------------------------------------------------------------

inline void PushBuffer(WCHAR c)
{
    if (shifted && c >= FIRST_G1 && c <= LAST_G1)
        c = G1[c - FIRST_G1];
    ChBuffer[nCharInBuffer] = c;
    if (++nCharInBuffer == BUFFER_SIZE)
        FlushBuffer();
}

//-----------------------------------------------------------------------------
//   SendSequence( LPCWSTR seq )
// Send the string to the input buffer.
//-----------------------------------------------------------------------------

inline void SendSequence(LPCWSTR seq)
{
    DWORD out;
    INPUT_RECORD in;
    HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);

    in.EventType = KEY_EVENT;
    in.Event.KeyEvent.bKeyDown = TRUE;
    in.Event.KeyEvent.wRepeatCount = 1;
    in.Event.KeyEvent.wVirtualKeyCode = 0;
    in.Event.KeyEvent.wVirtualScanCode = 0;
    in.Event.KeyEvent.dwControlKeyState = 0;
    for (; *seq; ++seq)
        {
        in.Event.KeyEvent.uChar.UnicodeChar = *seq;
        WriteConsoleInput(hStdIn, &in, 1, &out);
        }
}

// ========== Print functions

//-----------------------------------------------------------------------------
//   InterpretEscSeq()
// Interprets the last escape sequence scanned by ParseAndPrintANSIString
//   prefix             escape sequence prefix
//   es_argc            escape sequence args count
//   es_argv[]          escape sequence args array
//   suffix             escape sequence suffix
//
// for instance, with \e[33;45;1m we have
// prefix = '[',
// es_argc = 3, es_argv[0] = 33, es_argv[1] = 45, es_argv[2] = 1
// suffix = 'm'
//-----------------------------------------------------------------------------

inline void InterpretEscSeq(void)
{
    int  i;
    WORD attribute;
    CONSOLE_SCREEN_BUFFER_INFO Info;
    CONSOLE_CURSOR_INFO CursInfo;
    DWORD len, NumberOfCharsWritten;
    COORD Pos;
    SMALL_RECT Rect;
    CHAR_INFO  CharInfo;

    if (prefix == '[')
        {
        if (prefix2 == '?' && (suffix == 'h' || suffix == 'l'))
            {
            if (es_argc == 1 && es_argv[0] == 25)
                {
                GetConsoleCursorInfo(hConOut, &CursInfo);
                CursInfo.bVisible = (suffix == 'h');
                SetConsoleCursorInfo(hConOut, &CursInfo);
                return;
                }
            }
        // Ignore any other \e[? or \e[> sequences.
        if (prefix2 != 0)
            return;

        GetConsoleScreenBufferInfo(hConOut, &Info);
        switch (suffix)
            {
                case 'm':
                    if (es_argc == 0) es_argv[es_argc++] = 0;
                    for (i = 0; i < es_argc; i++)
                        {
                        if (30 <= es_argv[i] && es_argv[i] <= 37)
                            grm.foreground = es_argv[i] - 30;
                        else if (40 <= es_argv[i] && es_argv[i] <= 47)
                            grm.background = es_argv[i] - 40;
                        else switch (es_argv[i])
                            {
                                case 0:
                                case 39:
                                case 49:
                                        {
                                        WCHAR def[4];
                                        int   a;
                                        *def = '7'; def[1] = '\0';
                                        GetEnvironmentVariableW(L"ANSICON_DEF", def, lenof(def));
                                        a = wcstol(def, NULL, 16);
                                        grm.reverse = FALSE;
                                        if (a < 0)
                                            {
                                            grm.reverse = TRUE;
                                            a = -a;
                                            }
                                        if (es_argv[i] != 49)
                                            grm.foreground = attr2ansi[a & 7];
                                        if (es_argv[i] != 39)
                                            grm.background = attr2ansi[(a >> 4) & 7];
                                        if (es_argv[i] == 0)
                                            {
                                            if (es_argc == 1)
                                                {
                                                grm.bold = a & FOREGROUND_INTENSITY;
                                                grm.underline = a & BACKGROUND_INTENSITY;
                                                }
                                            else
                                                {
                                                grm.bold = 0;
                                                grm.underline = 0;
                                                }
                                            grm.rvideo = 0;
                                            grm.concealed = 0;
                                            }
                                        }
                                        break;

                                case  1: grm.bold = FOREGROUND_INTENSITY; break;
                                case  5: // blink
                                case  4: grm.underline = BACKGROUND_INTENSITY; break;
                                case  7: grm.rvideo = 1; break;
                                case  8: grm.concealed = 1; break;
                                case 21: // oops, this actually turns on double underline
                                case 22: grm.bold = 0; break;
                                case 25:
                                case 24: grm.underline = 0; break;
                                case 27: grm.rvideo = 0; break;
                                case 28: grm.concealed = 0; break;
                            }
                        }
                    if (grm.concealed)
                        {
                        if (grm.rvideo)
                            {
                            attribute = foregroundcolor[grm.foreground]
                                | backgroundcolor[grm.foreground];
                            if (grm.bold)
                                attribute |= FOREGROUND_INTENSITY | BACKGROUND_INTENSITY;
                            }
                        else
                            {
                            attribute = foregroundcolor[grm.background]
                                | backgroundcolor[grm.background];
                            if (grm.underline)
                                attribute |= FOREGROUND_INTENSITY | BACKGROUND_INTENSITY;
                            }
                        }
                    else if (grm.rvideo)
                        {
                        attribute = foregroundcolor[grm.background]
                            | backgroundcolor[grm.foreground];
                        if (grm.bold)
                            attribute |= BACKGROUND_INTENSITY;
                        if (grm.underline)
                            attribute |= FOREGROUND_INTENSITY;
                        }
                    else
                        attribute = foregroundcolor[grm.foreground] | grm.bold
                        | backgroundcolor[grm.background] | grm.underline;
                    if (grm.reverse)
                        attribute = ((attribute >> 4) & 15) | ((attribute & 15) << 4);
                    SetConsoleTextAttribute(hConOut, attribute);
                    return;

                case 'J':
                    if (es_argc == 0) es_argv[es_argc++] = 0; // ESC[J == ESC[0J
                    if (es_argc != 1) return;
                    switch (es_argv[0])
                        {
                            case 0:     // ESC[0J erase from cursor to end of display
                                len = (Info.dwSize.Y - Info.dwCursorPosition.Y - 1) * Info.dwSize.X
                                    + Info.dwSize.X - Info.dwCursorPosition.X - 1;
                                FillConsoleOutputCharacter(hConOut, ' ', len,
                                    Info.dwCursorPosition,
                                    &NumberOfCharsWritten);
                                FillConsoleOutputAttribute(hConOut, Info.wAttributes, len,
                                    Info.dwCursorPosition,
                                    &NumberOfCharsWritten);
                                return;

                            case 1:     // ESC[1J erase from start to cursor.
                                Pos.X = 0;
                                Pos.Y = 0;
                                len = Info.dwCursorPosition.Y * Info.dwSize.X
                                    + Info.dwCursorPosition.X + 1;
                                FillConsoleOutputCharacter(hConOut, ' ', len, Pos,
                                    &NumberOfCharsWritten);
                                FillConsoleOutputAttribute(hConOut, Info.wAttributes, len, Pos,
                                    &NumberOfCharsWritten);
                                return;

                            case 2:     // ESC[2J Clear screen and home cursor
                                Pos.X = 0;
                                Pos.Y = 0;
                                len = Info.dwSize.X * Info.dwSize.Y;
                                FillConsoleOutputCharacter(hConOut, ' ', len, Pos,
                                    &NumberOfCharsWritten);
                                FillConsoleOutputAttribute(hConOut, Info.wAttributes, len, Pos,
                                    &NumberOfCharsWritten);
                                SetConsoleCursorPosition(hConOut, Pos);
                                return;

                            default:
                                return;
                        }

                case 'K':
                    if (es_argc == 0) es_argv[es_argc++] = 0; // ESC[K == ESC[0K
                    if (es_argc != 1) return;
                    switch (es_argv[0])
                        {
                            case 0:     // ESC[0K Clear to end of line
                                len = Info.dwSize.X - Info.dwCursorPosition.X + 1;
                                FillConsoleOutputCharacter(hConOut, ' ', len,
                                    Info.dwCursorPosition,
                                    &NumberOfCharsWritten);
                                FillConsoleOutputAttribute(hConOut, Info.wAttributes, len,
                                    Info.dwCursorPosition,
                                    &NumberOfCharsWritten);
                                return;

                            case 1:     // ESC[1K Clear from start of line to cursor
                                Pos.X = 0;
                                Pos.Y = Info.dwCursorPosition.Y;
                                FillConsoleOutputCharacter(hConOut, ' ',
                                    Info.dwCursorPosition.X + 1, Pos,
                                    &NumberOfCharsWritten);
                                FillConsoleOutputAttribute(hConOut, Info.wAttributes,
                                    Info.dwCursorPosition.X + 1, Pos,
                                    &NumberOfCharsWritten);
                                return;

                            case 2:     // ESC[2K Clear whole line.
                                Pos.X = 0;
                                Pos.Y = Info.dwCursorPosition.Y;
                                FillConsoleOutputCharacter(hConOut, ' ', Info.dwSize.X, Pos,
                                    &NumberOfCharsWritten);
                                FillConsoleOutputAttribute(hConOut, Info.wAttributes,
                                    Info.dwSize.X, Pos,
                                    &NumberOfCharsWritten);
                                return;

                            default:
                                return;
                        }

                case 'X':                 // ESC[#X Erase # characters.
                    if (es_argc == 0) es_argv[es_argc++] = 1; // ESC[X == ESC[1X
                    if (es_argc != 1) return;
                    FillConsoleOutputCharacter(hConOut, ' ', es_argv[0],
                        Info.dwCursorPosition,
                        &NumberOfCharsWritten);
                    FillConsoleOutputAttribute(hConOut, Info.wAttributes, es_argv[0],
                        Info.dwCursorPosition,
                        &NumberOfCharsWritten);
                    return;

                case 'L':                 // ESC[#L Insert # blank lines.
                    if (es_argc == 0) es_argv[es_argc++] = 1; // ESC[L == ESC[1L
                    if (es_argc != 1) return;
                    Rect.Left = 0;
                    Rect.Top = Info.dwCursorPosition.Y;
                    Rect.Right = Info.dwSize.X - 1;
                    Rect.Bottom = Info.dwSize.Y - 1;
                    Pos.X = 0;
                    Pos.Y = Info.dwCursorPosition.Y + es_argv[0];
                    CharInfo.Char.UnicodeChar = ' ';
                    CharInfo.Attributes = Info.wAttributes;
                    ScrollConsoleScreenBuffer(hConOut, &Rect, NULL, Pos, &CharInfo);
                    return;

                case 'M':                 // ESC[#M Delete # lines.
                    if (es_argc == 0) es_argv[es_argc++] = 1; // ESC[M == ESC[1M
                    if (es_argc != 1) return;
                    if (es_argv[0] > Info.dwSize.Y - Info.dwCursorPosition.Y)
                        es_argv[0] = Info.dwSize.Y - Info.dwCursorPosition.Y;
                    Rect.Left = 0;
                    Rect.Top = Info.dwCursorPosition.Y + es_argv[0];
                    Rect.Right = Info.dwSize.X - 1;
                    Rect.Bottom = Info.dwSize.Y - 1;
                    Pos.X = 0;
                    Pos.Y = Info.dwCursorPosition.Y;
                    CharInfo.Char.UnicodeChar = ' ';
                    CharInfo.Attributes = Info.wAttributes;
                    ScrollConsoleScreenBuffer(hConOut, &Rect, NULL, Pos, &CharInfo);
                    return;

                case 'P':                 // ESC[#P Delete # characters.
                    if (es_argc == 0) es_argv[es_argc++] = 1; // ESC[P == ESC[1P
                    if (es_argc != 1) return;
                    if (Info.dwCursorPosition.X + es_argv[0] > Info.dwSize.X - 1)
                        es_argv[0] = Info.dwSize.X - Info.dwCursorPosition.X;
                    Rect.Left = Info.dwCursorPosition.X + es_argv[0];
                    Rect.Top = Info.dwCursorPosition.Y;
                    Rect.Right = Info.dwSize.X - 1;
                    Rect.Bottom = Info.dwCursorPosition.Y;
                    CharInfo.Char.UnicodeChar = ' ';
                    CharInfo.Attributes = Info.wAttributes;
                    ScrollConsoleScreenBuffer(hConOut, &Rect, NULL, Info.dwCursorPosition,
                        &CharInfo);
                    return;

                case '@':                 // ESC[#@ Insert # blank characters.
                    if (es_argc == 0) es_argv[es_argc++] = 1; // ESC[@ == ESC[1@
                    if (es_argc != 1) return;
                    if (Info.dwCursorPosition.X + es_argv[0] > Info.dwSize.X - 1)
                        es_argv[0] = Info.dwSize.X - Info.dwCursorPosition.X;
                    Rect.Left = Info.dwCursorPosition.X;
                    Rect.Top = Info.dwCursorPosition.Y;
                    Rect.Right = Info.dwSize.X - 1 - es_argv[0];
                    Rect.Bottom = Info.dwCursorPosition.Y;
                    Pos.X = Info.dwCursorPosition.X + es_argv[0];
                    Pos.Y = Info.dwCursorPosition.Y;
                    CharInfo.Char.UnicodeChar = ' ';
                    CharInfo.Attributes = Info.wAttributes;
                    ScrollConsoleScreenBuffer(hConOut, &Rect, NULL, Pos, &CharInfo);
                    return;

                case 'k':                 // ESC[#k
                case 'A':                 // ESC[#A Moves cursor up # lines
                    if (es_argc == 0) es_argv[es_argc++] = 1; // ESC[A == ESC[1A
                    if (es_argc != 1) return;
                    Pos.Y = Info.dwCursorPosition.Y - es_argv[0];
                    if (Pos.Y < 0) Pos.Y = 0;
                    Pos.X = Info.dwCursorPosition.X;
                    SetConsoleCursorPosition(hConOut, Pos);
                    return;

                case 'e':                 // ESC[#e
                case 'B':                 // ESC[#B Moves cursor down # lines
                    if (es_argc == 0) es_argv[es_argc++] = 1; // ESC[B == ESC[1B
                    if (es_argc != 1) return;
                    Pos.Y = Info.dwCursorPosition.Y + es_argv[0];
                    if (Pos.Y >= Info.dwSize.Y) Pos.Y = Info.dwSize.Y - 1;
                    Pos.X = Info.dwCursorPosition.X;
                    SetConsoleCursorPosition(hConOut, Pos);
                    return;

                case 'a':                 // ESC[#a
                case 'C':                 // ESC[#C Moves cursor forward # spaces
                    if (es_argc == 0) es_argv[es_argc++] = 1; // ESC[C == ESC[1C
                    if (es_argc != 1) return;
                    Pos.X = Info.dwCursorPosition.X + es_argv[0];
                    if (Pos.X >= Info.dwSize.X) Pos.X = Info.dwSize.X - 1;
                    Pos.Y = Info.dwCursorPosition.Y;
                    SetConsoleCursorPosition(hConOut, Pos);
                    return;

                case 'j':                 // ESC[#j
                case 'D':                 // ESC[#D Moves cursor back # spaces
                    if (es_argc == 0) es_argv[es_argc++] = 1; // ESC[D == ESC[1D
                    if (es_argc != 1) return;
                    Pos.X = Info.dwCursorPosition.X - es_argv[0];
                    if (Pos.X < 0) Pos.X = 0;
                    Pos.Y = Info.dwCursorPosition.Y;
                    SetConsoleCursorPosition(hConOut, Pos);
                    return;

                case 'E':                 // ESC[#E Moves cursor down # lines, column 1.
                    if (es_argc == 0) es_argv[es_argc++] = 1; // ESC[E == ESC[1E
                    if (es_argc != 1) return;
                    Pos.Y = Info.dwCursorPosition.Y + es_argv[0];
                    if (Pos.Y >= Info.dwSize.Y) Pos.Y = Info.dwSize.Y - 1;
                    Pos.X = 0;
                    SetConsoleCursorPosition(hConOut, Pos);
                    return;

                case 'F':                 // ESC[#F Moves cursor up # lines, column 1.
                    if (es_argc == 0) es_argv[es_argc++] = 1; // ESC[F == ESC[1F
                    if (es_argc != 1) return;
                    Pos.Y = Info.dwCursorPosition.Y - es_argv[0];
                    if (Pos.Y < 0) Pos.Y = 0;
                    Pos.X = 0;
                    SetConsoleCursorPosition(hConOut, Pos);
                    return;

                case '`':                 // ESC[#`
                case 'G':                 // ESC[#G Moves cursor column # in current row.
                    if (es_argc == 0) es_argv[es_argc++] = 1; // ESC[G == ESC[1G
                    if (es_argc != 1) return;
                    Pos.X = es_argv[0] - 1;
                    if (Pos.X >= Info.dwSize.X) Pos.X = Info.dwSize.X - 1;
                    if (Pos.X < 0) Pos.X = 0;
                    Pos.Y = Info.dwCursorPosition.Y;
                    SetConsoleCursorPosition(hConOut, Pos);
                    return;

                case 'd':                 // ESC[#d Moves cursor row #, current column.
                    if (es_argc == 0) es_argv[es_argc++] = 1; // ESC[d == ESC[1d
                    if (es_argc != 1) return;
                    Pos.Y = es_argv[0] - 1;
                    if (Pos.Y < 0) Pos.Y = 0;
                    if (Pos.Y >= Info.dwSize.Y) Pos.Y = Info.dwSize.Y - 1;
                    SetConsoleCursorPosition(hConOut, Pos);
                    return;

                case 'f':                 // ESC[#;#f
                case 'H':                 // ESC[#;#H Moves cursor to line #, column #
                    if (es_argc == 0)
                        es_argv[es_argc++] = 1; // ESC[H == ESC[1;1H
                    if (es_argc == 1)
                        es_argv[es_argc++] = 1; // ESC[#H == ESC[#;1H
                    if (es_argc > 2) return;
                    Pos.X = es_argv[1] - 1;
                    if (Pos.X < 0) Pos.X = 0;
                    if (Pos.X >= Info.dwSize.X) Pos.X = Info.dwSize.X - 1;
                    Pos.Y = es_argv[0] - 1;
                    if (Pos.Y < 0) Pos.Y = 0;
                    if (Pos.Y >= Info.dwSize.Y) Pos.Y = Info.dwSize.Y - 1;
                    SetConsoleCursorPosition(hConOut, Pos);
                    return;

                case 's':                 // ESC[s Saves cursor position for recall later
                    if (es_argc != 0) return;
                    SavePos = Info.dwCursorPosition;
                    return;

                case 'u':                 // ESC[u Return to saved cursor position
                    if (es_argc != 0) return;
                    SetConsoleCursorPosition(hConOut, SavePos);
                    return;

                case 'n':                 // ESC[#n Device status report
                    if (es_argc != 1) return; // ESC[n == ESC[0n -> ignored
                    switch (es_argv[0])
                        {
                            case 5:     // ESC[5n Report status
                                SendSequence(L"\33[0n"); // "OK"
                                return;

                            case 6:     // ESC[6n Report cursor position
                                    {
                                    WCHAR buf[32];
                                    swprintf(buf, 32, L"\33[%d;%dR", Info.dwCursorPosition.Y + 1,
                                        Info.dwCursorPosition.X + 1);
                                    SendSequence(buf);
                                    }
                                    return;

                            default:
                                return;
                        }

                case 't':                 // ESC[#t Window manipulation
                    if (es_argc != 1) return;
                    if (es_argv[0] == 21)   // ESC[21t Report xterm window's title
                        {
                        WCHAR buf[MAX_PATH * 2];
                        len = GetConsoleTitleW(buf + 3, lenof(buf) - 3 - 2);
                        // Too bad if it's too big or fails.
                        buf[0] = ESC;
                        buf[1] = ']';
                        buf[2] = 'l';
                        buf[3 + len] = ESC;
                        buf[3 + len + 1] = '\\';
                        buf[3 + len + 2] = '\0';
                        SendSequence(buf);
                        }
                    return;

                default:
                    return;
            }
        }
    else // (prefix == ']')
        {
        // Ignore any \e]? or \e]> sequences.
        if (prefix2 != 0)
            return;

        if (es_argc == 1 && es_argv[0] == 0) // ESC]0;titleST
            {
            SetConsoleTitleW(Pt_arg);
            }
        }
}

//-----------------------------------------------------------------------------
//   ParseAndPrintANSIString(hDev, lpBuffer, nNumberOfBytesToWrite)
// Parses the string lpBuffer, interprets the escapes sequences and prints the
// characters in the device hDev (console).
// The lexer is a three states automata.
// If the number of arguments es_argc > MAX_ARG, only the MAX_ARG-1 firsts and
// the last arguments are processed (no es_argv[] overflow).
//-----------------------------------------------------------------------------

inline BOOL ParseAndPrintANSIString(HANDLE hDev, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten)
{
    DWORD   i;
    LPCSTR s;

    if (hDev != hConOut)    // reinit if device has changed
        {
        hConOut = hDev;
        state = 1;
        shifted = FALSE;
        }
    for (i = nNumberOfBytesToWrite, s = (LPCSTR)lpBuffer; i > 0; i--, s++)
        {
        if (state == 1)
            {
            if (*s == ESC) state = 2;
            else if (*s == SO) shifted = TRUE;
            else if (*s == SI) shifted = FALSE;
            else PushBuffer(*s);
            }
        else if (state == 2)
            {
            if (*s == ESC); // \e\e...\e == \e
            else if ((*s == '[') || (*s == ']'))
                {
                FlushBuffer();
                prefix = *s;
                prefix2 = 0;
                state = 3;
                Pt_len = 0;
                *Pt_arg = '\0';
                }
            else if (*s == ')' || *s == '(') state = 6;
            else state = 1;
            }
        else if (state == 3)
            {
            if (is_digit(*s))
                {
                es_argc = 0;
                es_argv[0] = *s - '0';
                state = 4;
                }
            else if (*s == ';')
                {
                es_argc = 1;
                es_argv[0] = 0;
                es_argv[1] = 0;
                state = 4;
                }
            else if (*s == '?' || *s == '>')
                {
                prefix2 = *s;
                }
            else
                {
                es_argc = 0;
                suffix = *s;
                InterpretEscSeq();
                state = 1;
                }
            }
        else if (state == 4)
            {
            if (is_digit(*s))
                {
                es_argv[es_argc] = 10 * es_argv[es_argc] + (*s - '0');
                }
            else if (*s == ';')
                {
                if (es_argc < MAX_ARG - 1) es_argc++;
                es_argv[es_argc] = 0;
                if (prefix == ']')
                    state = 5;
                }
            else
                {
                es_argc++;
                suffix = *s;
                InterpretEscSeq();
                state = 1;
                }
            }
        else if (state == 5)
            {
            if (*s == BEL)
                {
                Pt_arg[Pt_len] = '\0';
                InterpretEscSeq();
                state = 1;
                }
            else if (*s == '\\' && Pt_len > 0 && Pt_arg[Pt_len - 1] == ESC)
                {
                Pt_arg[--Pt_len] = '\0';
                InterpretEscSeq();
                state = 1;
                }
            else if (Pt_len < lenof(Pt_arg) - 1)
                Pt_arg[Pt_len++] = *s;
            }
        else if (state == 6)
            {
            // Ignore it (ESC ) 0 is implicit; nothing else is supported).
            state = 1;
            }
        }
    FlushBuffer();
    if (lpNumberOfBytesWritten != NULL)
        *lpNumberOfBytesWritten = nNumberOfBytesToWrite - i;
    return (i == 0);
}

} // namespace ansi

HANDLE hOut;
HANDLE hIn;
DWORD consolemodeIn = 0;

inline int win32read(int *c) {
    DWORD foo;
    INPUT_RECORD b;
    KEY_EVENT_RECORD e;
    BOOL altgr;

    while (1) {
        if (!ReadConsoleInput(hIn, &b, 1, &foo)) return 0;
        if (!foo) return 0;

        if (b.EventType == KEY_EVENT && b.Event.KeyEvent.bKeyDown) {

            e = b.Event.KeyEvent;
            *c = b.Event.KeyEvent.uChar.AsciiChar;

            altgr = e.dwControlKeyState & (LEFT_CTRL_PRESSED | RIGHT_ALT_PRESSED);

            if (e.dwControlKeyState & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED) && !altgr) {

                /* Ctrl+Key */
                switch (*c) {
                    case 'D':
                        *c = 4;
                        return 1;
                    case 'C':
                        *c = 3;
                        return 1;
                    case 'H':
                        *c = 8;
                        return 1;
                    case 'T':
                        *c = 20;
                        return 1;
                    case 'B': /* ctrl-b, left_arrow */
                        *c = 2;
                        return 1;
                    case 'F': /* ctrl-f right_arrow*/
                        *c = 6;
                        return 1;
                    case 'P': /* ctrl-p up_arrow*/
                        *c = 16;
                        return 1;
                    case 'N': /* ctrl-n down_arrow*/
                        *c = 14;
                        return 1;
                    case 'U': /* Ctrl+u, delete the whole line. */
                        *c = 21;
                        return 1;
                    case 'K': /* Ctrl+k, delete from current to end of line. */
                        *c = 11;
                        return 1;
                    case 'A': /* Ctrl+a, go to the start of the line */
                        *c = 1;
                        return 1;
                    case 'E': /* ctrl+e, go to the end of the line */
                        *c = 5;
                        return 1;
                }

                /* Other Ctrl+KEYs ignored */
            } else {

                switch (e.wVirtualKeyCode) {

                    case VK_ESCAPE: /* ignore - send ctrl-c, will return -1 */
                        *c = 3;
                        return 1;
                    case VK_RETURN:  /* enter */
                        *c = 13;
                        return 1;
                    case VK_LEFT:   /* left */
                        *c = 2;
                        return 1;
                    case VK_RIGHT: /* right */
                        *c = 6;
                        return 1;
                    case VK_UP:   /* up */
                        *c = 16;
                        return 1;
                    case VK_DOWN:  /* down */
                        *c = 14;
                        return 1;
                    case VK_HOME:
                        *c = 1;
                        return 1;
                    case VK_END:
                        *c = 5;
                        return 1;
                    case VK_BACK:
                        *c = 8;
                        return 1;
                    case VK_DELETE:
                        *c = 4; /* same as Ctrl+D above */
                        return 1;
                    default:
                        if (*c) return 1;
                }
            }
        }
    }

    return -1; /* Makes compiler happy */
}

inline int win32_write(int fd, const void *buffer, unsigned int count) {
    if (fd == _fileno(stdout)) {
        DWORD bytesWritten = 0;
        if (FALSE != ansi::ParseAndPrintANSIString(GetStdHandle(STD_OUTPUT_HANDLE), buffer, (DWORD)count, &bytesWritten)) {
            return (int)bytesWritten;
        } else {
            errno = GetLastError();
            return 0;
        }
    } else if (fd == _fileno(stderr)) {
        DWORD bytesWritten = 0;
        if (FALSE != ansi::ParseAndPrintANSIString(GetStdHandle(STD_ERROR_HANDLE), buffer, (DWORD)count, &bytesWritten)) {
            return (int)bytesWritten;
        } else {
            errno = GetLastError();
            return 0;
        }
    } else {
        return _write(fd, buffer, count);
    }
}
#endif // _WIN32

#define LINENOISE_DEFAULT_HISTORY_MAX_LEN 100
#define LINENOISE_MAX_LINE 4096
static const char *unsupported_term[] = {"dumb","cons25","emacs",NULL};
static CompletionCallback completionCallback;

#ifndef _WIN32
static struct termios orig_termios; /* In order to restore at exit.*/
#endif
static bool rawmode = false; /* For atexit() function to check if restore is needed*/
static bool mlmode = false;  /* Multi line mode. Default is single line. */
static bool atexit_registered = false; /* Register atexit just 1 time. */
static size_t history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;
static std::vector<std::string> history;

/* The linenoiseState structure represents the state during line editing.
 * We pass this state to functions implementing specific editing
 * functionalities. */
struct linenoiseState {
    int ifd;            /* Terminal stdin file descriptor. */
    int ofd;            /* Terminal stdout file descriptor. */
    char *buf;          /* Edited line buffer. */
    int buflen;         /* Edited line buffer size. */
    std::string prompt; /* Prompt to display. */
    int pos;            /* Current cursor position. */
    int oldcolpos;      /* Previous refresh cursor column position. */
    int len;            /* Current edited line length. */
    int cols;           /* Number of columns in terminal. */
    int maxrows;        /* Maximum num of rows used so far (multiline mode) */
    int history_index;  /* The history index we are currently editing. */
};

enum KEY_ACTION {
    KEY_NULL = 0,       /* NULL */
    CTRL_A = 1,         /* Ctrl+a */
    CTRL_B = 2,         /* Ctrl-b */
    CTRL_C = 3,         /* Ctrl-c */
    CTRL_D = 4,         /* Ctrl-d */
    CTRL_E = 5,         /* Ctrl-e */
    CTRL_F = 6,         /* Ctrl-f */
    CTRL_H = 8,         /* Ctrl-h */
    TAB = 9,            /* Tab */
    CTRL_K = 11,        /* Ctrl+k */
    CTRL_L = 12,        /* Ctrl+l */
    ENTER = 13,         /* Enter */
    CTRL_N = 14,        /* Ctrl-n */
    CTRL_P = 16,        /* Ctrl-p */
    CTRL_T = 20,        /* Ctrl-t */
    CTRL_U = 21,        /* Ctrl+u */
    CTRL_W = 23,        /* Ctrl+w */
    ESC = 27,           /* Escape */
    BACKSPACE =  127    /* Backspace */
};

void linenoiseAtExit(void);
bool AddHistory(const char *line);
void refreshLine(struct linenoiseState *l);

/* ============================ UTF8 utilities ============================== */

static unsigned long unicodeWideCharTable[][2] = {
    { 0x1100, 0x115F }, { 0x2329, 0x232A }, { 0x2E80, 0x2E99, }, { 0x2E9B, 0x2EF3, },
    { 0x2F00, 0x2FD5, }, { 0x2FF0, 0x2FFB, }, { 0x3000, 0x303E, }, { 0x3041, 0x3096, },
    { 0x3099, 0x30FF, }, { 0x3105, 0x312D, }, { 0x3131, 0x318E, }, { 0x3190, 0x31BA, },
    { 0x31C0, 0x31E3, }, { 0x31F0, 0x321E, }, { 0x3220, 0x3247, }, { 0x3250, 0x4DBF, },
    { 0x4E00, 0xA48C, }, { 0xA490, 0xA4C6, }, { 0xA960, 0xA97C, }, { 0xAC00, 0xD7A3, },
    { 0xF900, 0xFAFF, }, { 0xFE10, 0xFE19, }, { 0xFE30, 0xFE52, }, { 0xFE54, 0xFE66, },
    { 0xFE68, 0xFE6B, }, { 0xFF01, 0xFFE6, },
    { 0x1B000, 0x1B001, }, { 0x1F200, 0x1F202, }, { 0x1F210, 0x1F23A, },
    { 0x1F240, 0x1F248, }, { 0x1F250, 0x1F251, }, { 0x20000, 0x3FFFD, },
};

static int unicodeWideCharTableSize = sizeof(unicodeWideCharTable) / sizeof(unicodeWideCharTable[0]);

static int unicodeIsWideChar(unsigned long cp)
{
    int i;
    for (i = 0; i < unicodeWideCharTableSize; i++) {
        if (unicodeWideCharTable[i][0] <= cp && cp <= unicodeWideCharTable[i][1]) {
            return 1;
        }
    }
    return 0;
}

static unsigned long unicodeCombiningCharTable[] = {
    0x0300,0x0301,0x0302,0x0303,0x0304,0x0305,0x0306,0x0307,
    0x0308,0x0309,0x030A,0x030B,0x030C,0x030D,0x030E,0x030F,
    0x0310,0x0311,0x0312,0x0313,0x0314,0x0315,0x0316,0x0317,
    0x0318,0x0319,0x031A,0x031B,0x031C,0x031D,0x031E,0x031F,
    0x0320,0x0321,0x0322,0x0323,0x0324,0x0325,0x0326,0x0327,
    0x0328,0x0329,0x032A,0x032B,0x032C,0x032D,0x032E,0x032F,
    0x0330,0x0331,0x0332,0x0333,0x0334,0x0335,0x0336,0x0337,
    0x0338,0x0339,0x033A,0x033B,0x033C,0x033D,0x033E,0x033F,
    0x0340,0x0341,0x0342,0x0343,0x0344,0x0345,0x0346,0x0347,
    0x0348,0x0349,0x034A,0x034B,0x034C,0x034D,0x034E,0x034F,
    0x0350,0x0351,0x0352,0x0353,0x0354,0x0355,0x0356,0x0357,
    0x0358,0x0359,0x035A,0x035B,0x035C,0x035D,0x035E,0x035F,
    0x0360,0x0361,0x0362,0x0363,0x0364,0x0365,0x0366,0x0367,
    0x0368,0x0369,0x036A,0x036B,0x036C,0x036D,0x036E,0x036F,
    0x0483,0x0484,0x0485,0x0486,0x0487,0x0591,0x0592,0x0593,
    0x0594,0x0595,0x0596,0x0597,0x0598,0x0599,0x059A,0x059B,
    0x059C,0x059D,0x059E,0x059F,0x05A0,0x05A1,0x05A2,0x05A3,
    0x05A4,0x05A5,0x05A6,0x05A7,0x05A8,0x05A9,0x05AA,0x05AB,
    0x05AC,0x05AD,0x05AE,0x05AF,0x05B0,0x05B1,0x05B2,0x05B3,
    0x05B4,0x05B5,0x05B6,0x05B7,0x05B8,0x05B9,0x05BA,0x05BB,
    0x05BC,0x05BD,0x05BF,0x05C1,0x05C2,0x05C4,0x05C5,0x05C7,
    0x0610,0x0611,0x0612,0x0613,0x0614,0x0615,0x0616,0x0617,
    0x0618,0x0619,0x061A,0x064B,0x064C,0x064D,0x064E,0x064F,
    0x0650,0x0651,0x0652,0x0653,0x0654,0x0655,0x0656,0x0657,
    0x0658,0x0659,0x065A,0x065B,0x065C,0x065D,0x065E,0x065F,
    0x0670,0x06D6,0x06D7,0x06D8,0x06D9,0x06DA,0x06DB,0x06DC,
    0x06DF,0x06E0,0x06E1,0x06E2,0x06E3,0x06E4,0x06E7,0x06E8,
    0x06EA,0x06EB,0x06EC,0x06ED,0x0711,0x0730,0x0731,0x0732,
    0x0733,0x0734,0x0735,0x0736,0x0737,0x0738,0x0739,0x073A,
    0x073B,0x073C,0x073D,0x073E,0x073F,0x0740,0x0741,0x0742,
    0x0743,0x0744,0x0745,0x0746,0x0747,0x0748,0x0749,0x074A,
    0x07A6,0x07A7,0x07A8,0x07A9,0x07AA,0x07AB,0x07AC,0x07AD,
    0x07AE,0x07AF,0x07B0,0x07EB,0x07EC,0x07ED,0x07EE,0x07EF,
    0x07F0,0x07F1,0x07F2,0x07F3,0x0816,0x0817,0x0818,0x0819,
    0x081B,0x081C,0x081D,0x081E,0x081F,0x0820,0x0821,0x0822,
    0x0823,0x0825,0x0826,0x0827,0x0829,0x082A,0x082B,0x082C,
    0x082D,0x0859,0x085A,0x085B,0x08E3,0x08E4,0x08E5,0x08E6,
    0x08E7,0x08E8,0x08E9,0x08EA,0x08EB,0x08EC,0x08ED,0x08EE,
    0x08EF,0x08F0,0x08F1,0x08F2,0x08F3,0x08F4,0x08F5,0x08F6,
    0x08F7,0x08F8,0x08F9,0x08FA,0x08FB,0x08FC,0x08FD,0x08FE,
    0x08FF,0x0900,0x0901,0x0902,0x093A,0x093C,0x0941,0x0942,
    0x0943,0x0944,0x0945,0x0946,0x0947,0x0948,0x094D,0x0951,
    0x0952,0x0953,0x0954,0x0955,0x0956,0x0957,0x0962,0x0963,
    0x0981,0x09BC,0x09C1,0x09C2,0x09C3,0x09C4,0x09CD,0x09E2,
    0x09E3,0x0A01,0x0A02,0x0A3C,0x0A41,0x0A42,0x0A47,0x0A48,
    0x0A4B,0x0A4C,0x0A4D,0x0A51,0x0A70,0x0A71,0x0A75,0x0A81,
    0x0A82,0x0ABC,0x0AC1,0x0AC2,0x0AC3,0x0AC4,0x0AC5,0x0AC7,
    0x0AC8,0x0ACD,0x0AE2,0x0AE3,0x0B01,0x0B3C,0x0B3F,0x0B41,
    0x0B42,0x0B43,0x0B44,0x0B4D,0x0B56,0x0B62,0x0B63,0x0B82,
    0x0BC0,0x0BCD,0x0C00,0x0C3E,0x0C3F,0x0C40,0x0C46,0x0C47,
    0x0C48,0x0C4A,0x0C4B,0x0C4C,0x0C4D,0x0C55,0x0C56,0x0C62,
    0x0C63,0x0C81,0x0CBC,0x0CBF,0x0CC6,0x0CCC,0x0CCD,0x0CE2,
    0x0CE3,0x0D01,0x0D41,0x0D42,0x0D43,0x0D44,0x0D4D,0x0D62,
    0x0D63,0x0DCA,0x0DD2,0x0DD3,0x0DD4,0x0DD6,0x0E31,0x0E34,
    0x0E35,0x0E36,0x0E37,0x0E38,0x0E39,0x0E3A,0x0E47,0x0E48,
    0x0E49,0x0E4A,0x0E4B,0x0E4C,0x0E4D,0x0E4E,0x0EB1,0x0EB4,
    0x0EB5,0x0EB6,0x0EB7,0x0EB8,0x0EB9,0x0EBB,0x0EBC,0x0EC8,
    0x0EC9,0x0ECA,0x0ECB,0x0ECC,0x0ECD,0x0F18,0x0F19,0x0F35,
    0x0F37,0x0F39,0x0F71,0x0F72,0x0F73,0x0F74,0x0F75,0x0F76,
    0x0F77,0x0F78,0x0F79,0x0F7A,0x0F7B,0x0F7C,0x0F7D,0x0F7E,
    0x0F80,0x0F81,0x0F82,0x0F83,0x0F84,0x0F86,0x0F87,0x0F8D,
    0x0F8E,0x0F8F,0x0F90,0x0F91,0x0F92,0x0F93,0x0F94,0x0F95,
    0x0F96,0x0F97,0x0F99,0x0F9A,0x0F9B,0x0F9C,0x0F9D,0x0F9E,
    0x0F9F,0x0FA0,0x0FA1,0x0FA2,0x0FA3,0x0FA4,0x0FA5,0x0FA6,
    0x0FA7,0x0FA8,0x0FA9,0x0FAA,0x0FAB,0x0FAC,0x0FAD,0x0FAE,
    0x0FAF,0x0FB0,0x0FB1,0x0FB2,0x0FB3,0x0FB4,0x0FB5,0x0FB6,
    0x0FB7,0x0FB8,0x0FB9,0x0FBA,0x0FBB,0x0FBC,0x0FC6,0x102D,
    0x102E,0x102F,0x1030,0x1032,0x1033,0x1034,0x1035,0x1036,
    0x1037,0x1039,0x103A,0x103D,0x103E,0x1058,0x1059,0x105E,
    0x105F,0x1060,0x1071,0x1072,0x1073,0x1074,0x1082,0x1085,
    0x1086,0x108D,0x109D,0x135D,0x135E,0x135F,0x1712,0x1713,
    0x1714,0x1732,0x1733,0x1734,0x1752,0x1753,0x1772,0x1773,
    0x17B4,0x17B5,0x17B7,0x17B8,0x17B9,0x17BA,0x17BB,0x17BC,
    0x17BD,0x17C6,0x17C9,0x17CA,0x17CB,0x17CC,0x17CD,0x17CE,
    0x17CF,0x17D0,0x17D1,0x17D2,0x17D3,0x17DD,0x180B,0x180C,
    0x180D,0x18A9,0x1920,0x1921,0x1922,0x1927,0x1928,0x1932,
    0x1939,0x193A,0x193B,0x1A17,0x1A18,0x1A1B,0x1A56,0x1A58,
    0x1A59,0x1A5A,0x1A5B,0x1A5C,0x1A5D,0x1A5E,0x1A60,0x1A62,
    0x1A65,0x1A66,0x1A67,0x1A68,0x1A69,0x1A6A,0x1A6B,0x1A6C,
    0x1A73,0x1A74,0x1A75,0x1A76,0x1A77,0x1A78,0x1A79,0x1A7A,
    0x1A7B,0x1A7C,0x1A7F,0x1AB0,0x1AB1,0x1AB2,0x1AB3,0x1AB4,
    0x1AB5,0x1AB6,0x1AB7,0x1AB8,0x1AB9,0x1ABA,0x1ABB,0x1ABC,
    0x1ABD,0x1B00,0x1B01,0x1B02,0x1B03,0x1B34,0x1B36,0x1B37,
    0x1B38,0x1B39,0x1B3A,0x1B3C,0x1B42,0x1B6B,0x1B6C,0x1B6D,
    0x1B6E,0x1B6F,0x1B70,0x1B71,0x1B72,0x1B73,0x1B80,0x1B81,
    0x1BA2,0x1BA3,0x1BA4,0x1BA5,0x1BA8,0x1BA9,0x1BAB,0x1BAC,
    0x1BAD,0x1BE6,0x1BE8,0x1BE9,0x1BED,0x1BEF,0x1BF0,0x1BF1,
    0x1C2C,0x1C2D,0x1C2E,0x1C2F,0x1C30,0x1C31,0x1C32,0x1C33,
    0x1C36,0x1C37,0x1CD0,0x1CD1,0x1CD2,0x1CD4,0x1CD5,0x1CD6,
    0x1CD7,0x1CD8,0x1CD9,0x1CDA,0x1CDB,0x1CDC,0x1CDD,0x1CDE,
    0x1CDF,0x1CE0,0x1CE2,0x1CE3,0x1CE4,0x1CE5,0x1CE6,0x1CE7,
    0x1CE8,0x1CED,0x1CF4,0x1CF8,0x1CF9,0x1DC0,0x1DC1,0x1DC2,
    0x1DC3,0x1DC4,0x1DC5,0x1DC6,0x1DC7,0x1DC8,0x1DC9,0x1DCA,
    0x1DCB,0x1DCC,0x1DCD,0x1DCE,0x1DCF,0x1DD0,0x1DD1,0x1DD2,
    0x1DD3,0x1DD4,0x1DD5,0x1DD6,0x1DD7,0x1DD8,0x1DD9,0x1DDA,
    0x1DDB,0x1DDC,0x1DDD,0x1DDE,0x1DDF,0x1DE0,0x1DE1,0x1DE2,
    0x1DE3,0x1DE4,0x1DE5,0x1DE6,0x1DE7,0x1DE8,0x1DE9,0x1DEA,
    0x1DEB,0x1DEC,0x1DED,0x1DEE,0x1DEF,0x1DF0,0x1DF1,0x1DF2,
    0x1DF3,0x1DF4,0x1DF5,0x1DFC,0x1DFD,0x1DFE,0x1DFF,0x20D0,
    0x20D1,0x20D2,0x20D3,0x20D4,0x20D5,0x20D6,0x20D7,0x20D8,
    0x20D9,0x20DA,0x20DB,0x20DC,0x20E1,0x20E5,0x20E6,0x20E7,
    0x20E8,0x20E9,0x20EA,0x20EB,0x20EC,0x20ED,0x20EE,0x20EF,
    0x20F0,0x2CEF,0x2CF0,0x2CF1,0x2D7F,0x2DE0,0x2DE1,0x2DE2,
    0x2DE3,0x2DE4,0x2DE5,0x2DE6,0x2DE7,0x2DE8,0x2DE9,0x2DEA,
    0x2DEB,0x2DEC,0x2DED,0x2DEE,0x2DEF,0x2DF0,0x2DF1,0x2DF2,
    0x2DF3,0x2DF4,0x2DF5,0x2DF6,0x2DF7,0x2DF8,0x2DF9,0x2DFA,
    0x2DFB,0x2DFC,0x2DFD,0x2DFE,0x2DFF,0x302A,0x302B,0x302C,
    0x302D,0x3099,0x309A,0xA66F,0xA674,0xA675,0xA676,0xA677,
    0xA678,0xA679,0xA67A,0xA67B,0xA67C,0xA67D,0xA69E,0xA69F,
    0xA6F0,0xA6F1,0xA802,0xA806,0xA80B,0xA825,0xA826,0xA8C4,
    0xA8E0,0xA8E1,0xA8E2,0xA8E3,0xA8E4,0xA8E5,0xA8E6,0xA8E7,
    0xA8E8,0xA8E9,0xA8EA,0xA8EB,0xA8EC,0xA8ED,0xA8EE,0xA8EF,
    0xA8F0,0xA8F1,0xA926,0xA927,0xA928,0xA929,0xA92A,0xA92B,
    0xA92C,0xA92D,0xA947,0xA948,0xA949,0xA94A,0xA94B,0xA94C,
    0xA94D,0xA94E,0xA94F,0xA950,0xA951,0xA980,0xA981,0xA982,
    0xA9B3,0xA9B6,0xA9B7,0xA9B8,0xA9B9,0xA9BC,0xA9E5,0xAA29,
    0xAA2A,0xAA2B,0xAA2C,0xAA2D,0xAA2E,0xAA31,0xAA32,0xAA35,
    0xAA36,0xAA43,0xAA4C,0xAA7C,0xAAB0,0xAAB2,0xAAB3,0xAAB4,
    0xAAB7,0xAAB8,0xAABE,0xAABF,0xAAC1,0xAAEC,0xAAED,0xAAF6,
    0xABE5,0xABE8,0xABED,0xFB1E,0xFE00,0xFE01,0xFE02,0xFE03,
    0xFE04,0xFE05,0xFE06,0xFE07,0xFE08,0xFE09,0xFE0A,0xFE0B,
    0xFE0C,0xFE0D,0xFE0E,0xFE0F,0xFE20,0xFE21,0xFE22,0xFE23,
    0xFE24,0xFE25,0xFE26,0xFE27,0xFE28,0xFE29,0xFE2A,0xFE2B,
    0xFE2C,0xFE2D,0xFE2E,0xFE2F,
    0x101FD,0x102E0,0x10376,0x10377,0x10378,0x10379,0x1037A,0x10A01,
    0x10A02,0x10A03,0x10A05,0x10A06,0x10A0C,0x10A0D,0x10A0E,0x10A0F,
    0x10A38,0x10A39,0x10A3A,0x10A3F,0x10AE5,0x10AE6,0x11001,0x11038,
    0x11039,0x1103A,0x1103B,0x1103C,0x1103D,0x1103E,0x1103F,0x11040,
    0x11041,0x11042,0x11043,0x11044,0x11045,0x11046,0x1107F,0x11080,
    0x11081,0x110B3,0x110B4,0x110B5,0x110B6,0x110B9,0x110BA,0x11100,
    0x11101,0x11102,0x11127,0x11128,0x11129,0x1112A,0x1112B,0x1112D,
    0x1112E,0x1112F,0x11130,0x11131,0x11132,0x11133,0x11134,0x11173,
    0x11180,0x11181,0x111B6,0x111B7,0x111B8,0x111B9,0x111BA,0x111BB,
    0x111BC,0x111BD,0x111BE,0x111CA,0x111CB,0x111CC,0x1122F,0x11230,
    0x11231,0x11234,0x11236,0x11237,0x112DF,0x112E3,0x112E4,0x112E5,
    0x112E6,0x112E7,0x112E8,0x112E9,0x112EA,0x11300,0x11301,0x1133C,
    0x11340,0x11366,0x11367,0x11368,0x11369,0x1136A,0x1136B,0x1136C,
    0x11370,0x11371,0x11372,0x11373,0x11374,0x114B3,0x114B4,0x114B5,
    0x114B6,0x114B7,0x114B8,0x114BA,0x114BF,0x114C0,0x114C2,0x114C3,
    0x115B2,0x115B3,0x115B4,0x115B5,0x115BC,0x115BD,0x115BF,0x115C0,
    0x115DC,0x115DD,0x11633,0x11634,0x11635,0x11636,0x11637,0x11638,
    0x11639,0x1163A,0x1163D,0x1163F,0x11640,0x116AB,0x116AD,0x116B0,
    0x116B1,0x116B2,0x116B3,0x116B4,0x116B5,0x116B7,0x1171D,0x1171E,
    0x1171F,0x11722,0x11723,0x11724,0x11725,0x11727,0x11728,0x11729,
    0x1172A,0x1172B,0x16AF0,0x16AF1,0x16AF2,0x16AF3,0x16AF4,0x16B30,
    0x16B31,0x16B32,0x16B33,0x16B34,0x16B35,0x16B36,0x16F8F,0x16F90,
    0x16F91,0x16F92,0x1BC9D,0x1BC9E,0x1D167,0x1D168,0x1D169,0x1D17B,
    0x1D17C,0x1D17D,0x1D17E,0x1D17F,0x1D180,0x1D181,0x1D182,0x1D185,
    0x1D186,0x1D187,0x1D188,0x1D189,0x1D18A,0x1D18B,0x1D1AA,0x1D1AB,
    0x1D1AC,0x1D1AD,0x1D242,0x1D243,0x1D244,0x1DA00,0x1DA01,0x1DA02,
    0x1DA03,0x1DA04,0x1DA05,0x1DA06,0x1DA07,0x1DA08,0x1DA09,0x1DA0A,
    0x1DA0B,0x1DA0C,0x1DA0D,0x1DA0E,0x1DA0F,0x1DA10,0x1DA11,0x1DA12,
    0x1DA13,0x1DA14,0x1DA15,0x1DA16,0x1DA17,0x1DA18,0x1DA19,0x1DA1A,
    0x1DA1B,0x1DA1C,0x1DA1D,0x1DA1E,0x1DA1F,0x1DA20,0x1DA21,0x1DA22,
    0x1DA23,0x1DA24,0x1DA25,0x1DA26,0x1DA27,0x1DA28,0x1DA29,0x1DA2A,
    0x1DA2B,0x1DA2C,0x1DA2D,0x1DA2E,0x1DA2F,0x1DA30,0x1DA31,0x1DA32,
    0x1DA33,0x1DA34,0x1DA35,0x1DA36,0x1DA3B,0x1DA3C,0x1DA3D,0x1DA3E,
    0x1DA3F,0x1DA40,0x1DA41,0x1DA42,0x1DA43,0x1DA44,0x1DA45,0x1DA46,
    0x1DA47,0x1DA48,0x1DA49,0x1DA4A,0x1DA4B,0x1DA4C,0x1DA4D,0x1DA4E,
    0x1DA4F,0x1DA50,0x1DA51,0x1DA52,0x1DA53,0x1DA54,0x1DA55,0x1DA56,
    0x1DA57,0x1DA58,0x1DA59,0x1DA5A,0x1DA5B,0x1DA5C,0x1DA5D,0x1DA5E,
    0x1DA5F,0x1DA60,0x1DA61,0x1DA62,0x1DA63,0x1DA64,0x1DA65,0x1DA66,
    0x1DA67,0x1DA68,0x1DA69,0x1DA6A,0x1DA6B,0x1DA6C,0x1DA75,0x1DA84,
    0x1DA9B,0x1DA9C,0x1DA9D,0x1DA9E,0x1DA9F,0x1DAA1,0x1DAA2,0x1DAA3,
    0x1DAA4,0x1DAA5,0x1DAA6,0x1DAA7,0x1DAA8,0x1DAA9,0x1DAAA,0x1DAAB,
    0x1DAAC,0x1DAAD,0x1DAAE,0x1DAAF,0x1E8D0,0x1E8D1,0x1E8D2,0x1E8D3,
    0x1E8D4,0x1E8D5,0x1E8D6,0xE0100,0xE0101,0xE0102,0xE0103,0xE0104,
    0xE0105,0xE0106,0xE0107,0xE0108,0xE0109,0xE010A,0xE010B,0xE010C,
    0xE010D,0xE010E,0xE010F,0xE0110,0xE0111,0xE0112,0xE0113,0xE0114,
    0xE0115,0xE0116,0xE0117,0xE0118,0xE0119,0xE011A,0xE011B,0xE011C,
    0xE011D,0xE011E,0xE011F,0xE0120,0xE0121,0xE0122,0xE0123,0xE0124,
    0xE0125,0xE0126,0xE0127,0xE0128,0xE0129,0xE012A,0xE012B,0xE012C,
    0xE012D,0xE012E,0xE012F,0xE0130,0xE0131,0xE0132,0xE0133,0xE0134,
    0xE0135,0xE0136,0xE0137,0xE0138,0xE0139,0xE013A,0xE013B,0xE013C,
    0xE013D,0xE013E,0xE013F,0xE0140,0xE0141,0xE0142,0xE0143,0xE0144,
    0xE0145,0xE0146,0xE0147,0xE0148,0xE0149,0xE014A,0xE014B,0xE014C,
    0xE014D,0xE014E,0xE014F,0xE0150,0xE0151,0xE0152,0xE0153,0xE0154,
    0xE0155,0xE0156,0xE0157,0xE0158,0xE0159,0xE015A,0xE015B,0xE015C,
    0xE015D,0xE015E,0xE015F,0xE0160,0xE0161,0xE0162,0xE0163,0xE0164,
    0xE0165,0xE0166,0xE0167,0xE0168,0xE0169,0xE016A,0xE016B,0xE016C,
    0xE016D,0xE016E,0xE016F,0xE0170,0xE0171,0xE0172,0xE0173,0xE0174,
    0xE0175,0xE0176,0xE0177,0xE0178,0xE0179,0xE017A,0xE017B,0xE017C,
    0xE017D,0xE017E,0xE017F,0xE0180,0xE0181,0xE0182,0xE0183,0xE0184,
    0xE0185,0xE0186,0xE0187,0xE0188,0xE0189,0xE018A,0xE018B,0xE018C,
    0xE018D,0xE018E,0xE018F,0xE0190,0xE0191,0xE0192,0xE0193,0xE0194,
    0xE0195,0xE0196,0xE0197,0xE0198,0xE0199,0xE019A,0xE019B,0xE019C,
    0xE019D,0xE019E,0xE019F,0xE01A0,0xE01A1,0xE01A2,0xE01A3,0xE01A4,
    0xE01A5,0xE01A6,0xE01A7,0xE01A8,0xE01A9,0xE01AA,0xE01AB,0xE01AC,
    0xE01AD,0xE01AE,0xE01AF,0xE01B0,0xE01B1,0xE01B2,0xE01B3,0xE01B4,
    0xE01B5,0xE01B6,0xE01B7,0xE01B8,0xE01B9,0xE01BA,0xE01BB,0xE01BC,
    0xE01BD,0xE01BE,0xE01BF,0xE01C0,0xE01C1,0xE01C2,0xE01C3,0xE01C4,
    0xE01C5,0xE01C6,0xE01C7,0xE01C8,0xE01C9,0xE01CA,0xE01CB,0xE01CC,
    0xE01CD,0xE01CE,0xE01CF,0xE01D0,0xE01D1,0xE01D2,0xE01D3,0xE01D4,
    0xE01D5,0xE01D6,0xE01D7,0xE01D8,0xE01D9,0xE01DA,0xE01DB,0xE01DC,
    0xE01DD,0xE01DE,0xE01DF,0xE01E0,0xE01E1,0xE01E2,0xE01E3,0xE01E4,
    0xE01E5,0xE01E6,0xE01E7,0xE01E8,0xE01E9,0xE01EA,0xE01EB,0xE01EC,
    0xE01ED,0xE01EE,0xE01EF,
};

static int unicodeCombiningCharTableSize = sizeof(unicodeCombiningCharTable) / sizeof(unicodeCombiningCharTable[0]);

inline int unicodeIsCombiningChar(unsigned long cp)
{
    int i;
    for (i = 0; i < unicodeCombiningCharTableSize; i++) {
        if (unicodeCombiningCharTable[i] == cp) {
            return 1;
        }
    }
    return 0;
}

/* Get length of previous UTF8 character
 */
inline int unicodePrevUTF8CharLen(char* buf, int pos)
{
    int end = pos--;
    while (pos >= 0 && ((unsigned char)buf[pos] & 0xC0) == 0x80) {
        pos--;
    }
    return end - pos;
}

/* Get length of previous UTF8 character
 */
inline int unicodeUTF8CharLen(char* buf, int buf_len, int pos)
{
    if (pos == buf_len) { return 0; }
    unsigned char ch = buf[pos];
    if (ch < 0x80) { return 1; }
    else if (ch < 0xE0) { return 2; }
    else if (ch < 0xF0) { return 3; }
    else { return 4; }
}

/* Convert UTF8 to Unicode code point
 */
inline int unicodeUTF8CharToCodePoint(
   const char* buf,
   int         len,
   int*        cp)
{
    if (len) {
        unsigned char byte = buf[0];
        if ((byte & 0x80) == 0) {
            *cp = byte;
            return 1;
        } else if ((byte & 0xE0) == 0xC0) {
            if (len >= 2) {
                *cp = (((unsigned long)(buf[0] & 0x1F)) << 6) |
                       ((unsigned long)(buf[1] & 0x3F));
                return 2;
            }
        } else if ((byte & 0xF0) == 0xE0) {
            if (len >= 3) {
                *cp = (((unsigned long)(buf[0] & 0x0F)) << 12) |
                      (((unsigned long)(buf[1] & 0x3F)) << 6) |
                       ((unsigned long)(buf[2] & 0x3F));
                return 3;
            }
        } else if ((byte & 0xF8) == 0xF0) {
            if (len >= 4) {
                *cp = (((unsigned long)(buf[0] & 0x07)) << 18) |
                      (((unsigned long)(buf[1] & 0x3F)) << 12) |
                      (((unsigned long)(buf[2] & 0x3F)) << 6) |
                       ((unsigned long)(buf[3] & 0x3F));
                return 4;
            }
        }
    }
    return 0;
}

/* Get length of grapheme
 */
inline int unicodeGraphemeLen(char* buf, int buf_len, int pos)
{
    if (pos == buf_len) {
        return 0;
    }
    int beg = pos;
    pos += unicodeUTF8CharLen(buf, buf_len, pos);
    while (pos < buf_len) {
        int len = unicodeUTF8CharLen(buf, buf_len, pos);
        int cp = 0;
        unicodeUTF8CharToCodePoint(buf + pos, len, &cp);
        if (!unicodeIsCombiningChar(cp)) {
            return pos - beg;
        }
        pos += len;
    }
    return pos - beg;
}

/* Get length of previous grapheme
 */
inline int unicodePrevGraphemeLen(char* buf, int pos)
{
    if (pos == 0) {
        return 0;
    }
    int end = pos;
    while (pos > 0) {
        int len = unicodePrevUTF8CharLen(buf, pos);
        pos -= len;
        int cp = 0;
        unicodeUTF8CharToCodePoint(buf + pos, len, &cp);
        if (!unicodeIsCombiningChar(cp)) {
            return end - pos;
        }
    }
    return 0;
}

inline int isAnsiEscape(const char* buf, int buf_len, int* len)
{
    if (buf_len > 2 && !memcmp("\033[", buf, 2)) {
        int off = 2;
        while (off < buf_len) {
            switch (buf[off++]) {
            case 'A': case 'B': case 'C': case 'D':
            case 'E': case 'F': case 'G': case 'H':
            case 'J': case 'K': case 'S': case 'T':
            case 'f': case 'm':
                *len = off;
                return 1;
            }
        }
    }
    return 0;
}

/* Get column position for the single line mode.
 */
inline int unicodeColumnPos(const char* buf, int buf_len)
{
    int ret = 0;

    int off = 0;
    while (off < buf_len) {
        int len;
        if (isAnsiEscape(buf + off, buf_len - off, &len)) {
            off += len;
            continue;
        }

        int cp = 0;
        len = unicodeUTF8CharToCodePoint(buf + off, buf_len - off, &cp);

        if (!unicodeIsCombiningChar(cp)) {
            ret += unicodeIsWideChar(cp) ? 2 : 1;
        }

        off += len;
    }

    return ret;
}

/* Get column position for the multi line mode.
 */
inline int unicodeColumnPosForMultiLine(char* buf, int buf_len, int pos, int cols, int ini_pos)
{
    int ret = 0;
    int colwid = ini_pos;

    int off = 0;
    while (off < buf_len) {
        int cp = 0;
        int len = unicodeUTF8CharToCodePoint(buf + off, buf_len - off, &cp);

        int wid = 0;
        if (!unicodeIsCombiningChar(cp)) {
            wid = unicodeIsWideChar(cp) ? 2 : 1;
        }

        int dif = (int)(colwid + wid) - (int)cols;
        if (dif > 0) {
            ret += dif;
            colwid = wid;
        } else if (dif == 0) {
            colwid = 0;
        } else {
            colwid += wid;
        }

        if (off >= pos) {
            break;
        }

        off += len;
        ret += wid;
    }

    return ret;
}

/* Read UTF8 character from file.
 */
inline int unicodeReadUTF8Char(int fd, char* buf, int* cp)
{
    int nread = read(fd,&buf[0],1);

    if (nread <= 0) { return nread; }

    unsigned char byte = buf[0];

    if ((byte & 0x80) == 0) {
        ;
    } else if ((byte & 0xE0) == 0xC0) {
        nread = read(fd,&buf[1],1);
        if (nread <= 0) { return nread; }
    } else if ((byte & 0xF0) == 0xE0) {
        nread = read(fd,&buf[1],2);
        if (nread <= 0) { return nread; }
    } else if ((byte & 0xF8) == 0xF0) {
        nread = read(fd,&buf[1],3);
        if (nread <= 0) { return nread; }
    } else {
        return -1;
    }

    return unicodeUTF8CharToCodePoint(buf, 4, cp);
}

/* ======================= Low level terminal handling ====================== */

/* Set if to use or not the multi line mode. */
inline void SetMultiLine(bool ml) {
    mlmode = ml;
}

/* Return true if the terminal name is in the list of terminals we know are
 * not able to understand basic escape sequences. */
inline bool isUnsupportedTerm(void) {
#ifndef _WIN32
    char *term = getenv("TERM");
    int j;

    if (term == NULL) return false;
    for (j = 0; unsupported_term[j]; j++)
        if (!strcasecmp(term,unsupported_term[j])) return true;
#endif
    return false;
}

/* Raw mode: 1960 magic shit. */
inline bool enableRawMode(int fd) {
#ifndef _WIN32
    struct termios raw;

    if (!isatty(STDIN_FILENO)) goto fatal;
    if (!atexit_registered) {
        atexit(linenoiseAtExit);
        atexit_registered = true;
    }
    if (tcgetattr(fd,&orig_termios) == -1) goto fatal;

    raw = orig_termios;  /* modify the original mode */
    /* input modes: no break, no CR to NL, no parity check, no strip char,
     * no start/stop output control. */
    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
    /* output modes - disable post processing */
    // NOTE: Multithreaded issue #20 (https://github.com/yhirose/cpp-linenoise/issues/20)
    // raw.c_oflag &= ~(OPOST);
    /* control modes - set 8 bit chars */
    raw.c_cflag |= (CS8);
    /* local modes - echoing off, canonical off, no extended functions,
     * no signal chars (^Z,^C) */
    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);
    /* control chars - set return condition: min number of bytes and timer.
     * We want read to return every single byte, without timeout. */
    raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /* 1 byte, no timer */

    /* put terminal in raw mode after flushing */
    if (tcsetattr(fd,TCSAFLUSH,&raw) < 0) goto fatal;
    rawmode = true;
#else
    if (!atexit_registered) {
        /* Cleanup them at exit */
        atexit(linenoiseAtExit);
        atexit_registered = true;

        /* Init windows console handles only once */
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
        if (hOut==INVALID_HANDLE_VALUE) goto fatal;
    }

    DWORD consolemodeOut;
    if (!GetConsoleMode(hOut, &consolemodeOut)) {
        CloseHandle(hOut);
        errno = ENOTTY;
        return false;
    };

    hIn = GetStdHandle(STD_INPUT_HANDLE);
    if (hIn == INVALID_HANDLE_VALUE) {
        CloseHandle(hOut);
        errno = ENOTTY;
        return false;
    }

    GetConsoleMode(hIn, &consolemodeIn);
    /* Enable raw mode */
    SetConsoleMode(hIn, consolemodeIn & ~ENABLE_PROCESSED_INPUT);

    rawmode = true;
#endif
    return true;

fatal:
    errno = ENOTTY;
    return false;
}

inline void disableRawMode(int fd) {
#ifdef _WIN32
    if (consolemodeIn) {
      SetConsoleMode(hIn, consolemodeIn);
      consolemodeIn = 0;
    }
    rawmode = false;
#else
    /* Don't even check the return value as it's too late. */
    if (rawmode && tcsetattr(fd,TCSAFLUSH,&orig_termios) != -1)
        rawmode = false;
#endif
}

/* Use the ESC [6n escape sequence to query the horizontal cursor position
 * and return it. On error -1 is returned, on success the position of the
 * cursor. */
inline int getCursorPosition(int ifd, int ofd) {
    char buf[32];
    int cols, rows;
    unsigned int i = 0;

    /* Report cursor location */
    if (write(ofd, "\x1b[6n", 4) != 4) return -1;

    /* Read the response: ESC [ rows ; cols R */
    while (i < sizeof(buf)-1) {
        if (read(ifd,buf+i,1) != 1) break;
        if (buf[i] == 'R') break;
        i++;
    }
    buf[i] = '\0';

    /* Parse it. */
    if (buf[0] != ESC || buf[1] != '[') return -1;
    if (sscanf(buf+2,"%d;%d",&rows,&cols) != 2) return -1;
    return cols;
}

/* Try to get the number of columns in the current terminal, or assume 80
 * if it fails. */
inline int getColumns(int ifd, int ofd) {
#ifdef _WIN32
    CONSOLE_SCREEN_BUFFER_INFO b;

    if (!GetConsoleScreenBufferInfo(hOut, &b)) return 80;
    return b.srWindow.Right - b.srWindow.Left;
#else
    struct winsize ws;

    if (ioctl(1, TIOCGWINSZ, &ws) == -1 || ws.ws_col == 0) {
        /* ioctl() failed. Try to query the terminal itself. */
        int start, cols;

        /* Get the initial position so we can restore it later. */
        start = getCursorPosition(ifd,ofd);
        if (start == -1) goto failed;

        /* Go to right margin and get position. */
        if (write(ofd,"\x1b[999C",6) != 6) goto failed;
        cols = getCursorPosition(ifd,ofd);
        if (cols == -1) goto failed;

        /* Restore position. */
        if (cols > start) {
            char seq[32];
            snprintf(seq,32,"\x1b[%dD",cols-start);
            if (write(ofd,seq,strlen(seq)) == -1) {
                /* Can't recover... */
            }
        }
        return cols;
    } else {
        return ws.ws_col;
    }

failed:
    return 80;
#endif
}

/* Clear the screen. Used to handle ctrl+l */
inline void linenoiseClearScreen(void) {
    if (write(STDOUT_FILENO,"\x1b[H\x1b[2J",7) <= 0) {
        /* nothing to do, just to avoid warning. */
    }
}

/* Beep, used for completion when there is nothing to complete or when all
 * the choices were already shown. */
inline void linenoiseBeep(void) {
    fprintf(stderr, "\x7");
    fflush(stderr);
}

/* ============================== Completion ================================ */

/* This is an helper function for linenoiseEdit() and is called when the
 * user types the <tab> key in order to complete the string currently in the
 * input.
 *
 * The state of the editing is encapsulated into the pointed linenoiseState
 * structure as described in the structure definition. */
inline int completeLine(struct linenoiseState *ls, char *cbuf, int *c) {
    std::vector<std::string> lc;
    int nread = 0, nwritten;
    *c = 0;

    completionCallback(ls->buf,lc);
    if (lc.empty()) {
        linenoiseBeep();
    } else {
        int stop = 0, i = 0;

        while(!stop) {
            /* Show completion or original buffer */
            if (i < static_cast<int>(lc.size())) {
                struct linenoiseState saved = *ls;

                ls->len = ls->pos = static_cast<int>(lc[i].size());
                ls->buf = &lc[i][0];
                refreshLine(ls);
                ls->len = saved.len;
                ls->pos = saved.pos;
                ls->buf = saved.buf;
            } else {
                refreshLine(ls);
            }

            //nread = read(ls->ifd,&c,1);
#ifdef _WIN32
            nread = win32read(c);
            if (nread == 1) {
                cbuf[0] = *c;
            }
#else
            nread = unicodeReadUTF8Char(ls->ifd,cbuf,c);
#endif
            if (nread <= 0) {
                *c = -1;
                return nread;
            }

            switch(*c) {
                case 9: /* tab */
                    i = (i+1) % (lc.size()+1);
                    if (i == static_cast<int>(lc.size())) linenoiseBeep();
                    break;
                case 27: /* escape */
                    /* Re-show original buffer */
                    if (i < static_cast<int>(lc.size())) refreshLine(ls);
                    stop = 1;
                    break;
                default:
                    /* Update buffer and return */
                    if (i < static_cast<int>(lc.size())) {
                        nwritten = snprintf(ls->buf,ls->buflen,"%s",&lc[i][0]);
                        ls->len = ls->pos = nwritten;
                    }
                    stop = 1;
                    break;
            }
        }
    }

    return nread;
}

/* Register a callback function to be called for tab-completion. */
inline void SetCompletionCallback(CompletionCallback fn) {
    completionCallback = fn;
}

/* =========================== Line editing ================================= */

/* Single line low level line refresh.
 *
 * Rewrite the currently edited line accordingly to the buffer content,
 * cursor position, and number of columns of the terminal. */
inline void refreshSingleLine(struct linenoiseState *l) {
    char seq[64];
    int pcolwid = unicodeColumnPos(l->prompt.c_str(), static_cast<int>(l->prompt.length()));
    int fd = l->ofd;
    char *buf = l->buf;
    int len = l->len;
    int pos = l->pos;
    std::string ab;

    while((pcolwid+unicodeColumnPos(buf, pos)) >= l->cols) {
        int glen = unicodeGraphemeLen(buf, len, 0);
        buf += glen;
        len -= glen;
        pos -= glen;
    }
    while (pcolwid+unicodeColumnPos(buf, len) > l->cols) {
        len -= unicodePrevGraphemeLen(buf, len);
    }

    /* Cursor to left edge */
    snprintf(seq,64,"\r");
    ab += seq;
    /* Write the prompt and the current buffer content */
    ab += l->prompt;
    ab.append(buf, len);
    /* Erase to right */
    snprintf(seq,64,"\x1b[0K");
    ab += seq;
    /* Move cursor to original position. */
    snprintf(seq,64,"\r\x1b[%dC", (int)(unicodeColumnPos(buf, pos)+pcolwid));
    ab += seq;
    if (write(fd,ab.c_str(), static_cast<int>(ab.length())) == -1) {} /* Can't recover from write error. */
}

/* Multi line low level line refresh.
 *
 * Rewrite the currently edited line accordingly to the buffer content,
 * cursor position, and number of columns of the terminal. */
inline void refreshMultiLine(struct linenoiseState *l) {
    char seq[64];
    int pcolwid = unicodeColumnPos(l->prompt.c_str(), static_cast<int>(l->prompt.length()));
    int colpos = unicodeColumnPosForMultiLine(l->buf, l->len, l->len, l->cols, pcolwid);
    int colpos2; /* cursor column position. */
    int rows = (pcolwid+colpos+l->cols-1)/l->cols; /* rows used by current buf. */
    int rpos = (pcolwid+l->oldcolpos+l->cols)/l->cols; /* cursor relative row. */
    int rpos2; /* rpos after refresh. */
    int col; /* column position, zero-based. */
    int old_rows = (int)l->maxrows;
    int fd = l->ofd, j;
    std::string ab;

    /* Update maxrows if needed. */
    if (rows > (int)l->maxrows) l->maxrows = rows;

    /* First step: clear all the lines used before. To do so start by
     * going to the last row. */
    if (old_rows-rpos > 0) {
        snprintf(seq,64,"\x1b[%dB", old_rows-rpos);
        ab += seq;
    }

    /* Now for every row clear it, go up. */
    for (j = 0; j < old_rows-1; j++) {
        snprintf(seq,64,"\r\x1b[0K\x1b[1A");
        ab += seq;
    }

    /* Clean the top line. */
    snprintf(seq,64,"\r\x1b[0K");
    ab += seq;

    /* Write the prompt and the current buffer content */
    ab += l->prompt;
    ab.append(l->buf, l->len);

    /* Get text width to cursor position */
    colpos2 = unicodeColumnPosForMultiLine(l->buf, l->len, l->pos, l->cols, pcolwid);

    /* If we are at the very end of the screen with our prompt, we need to
     * emit a newline and move the prompt to the first column. */
    if (l->pos &&
        l->pos == l->len &&
        (colpos2+pcolwid) % l->cols == 0)
    {
        ab += "\n";
        snprintf(seq,64,"\r");
        ab += seq;
        rows++;
        if (rows > (int)l->maxrows) l->maxrows = rows;
    }

    /* Move cursor to right position. */
    rpos2 = (pcolwid+colpos2+l->cols)/l->cols; /* current cursor relative row. */

    /* Go up till we reach the expected position. */
    if (rows-rpos2 > 0) {
        snprintf(seq,64,"\x1b[%dA", rows-rpos2);
        ab += seq;
    }

    /* Set column. */
    col = (pcolwid + colpos2) % l->cols;
    if (col)
        snprintf(seq,64,"\r\x1b[%dC", col);
    else
        snprintf(seq,64,"\r");
    ab += seq;

    l->oldcolpos = colpos2;

    if (write(fd,ab.c_str(), static_cast<int>(ab.length())) == -1) {} /* Can't recover from write error. */
}

/* Calls the two low level functions refreshSingleLine() or
 * refreshMultiLine() according to the selected mode. */
inline void refreshLine(struct linenoiseState *l) {
    if (mlmode)
        refreshMultiLine(l);
    else
        refreshSingleLine(l);
}

/* Insert the character 'c' at cursor current position.
 *
 * On error writing to the terminal -1 is returned, otherwise 0. */
inline int linenoiseEditInsert(struct linenoiseState *l, const char* cbuf, int clen) {
    if (l->len < l->buflen) {
        if (l->len == l->pos) {
            memcpy(&l->buf[l->pos],cbuf,clen);
            l->pos+=clen;
            l->len+=clen;;
            l->buf[l->len] = '\0';
            if ((!mlmode && unicodeColumnPos(l->prompt.c_str(), static_cast<int>(l->prompt.length()))+unicodeColumnPos(l->buf,l->len) < l->cols) /* || mlmode */) {
                /* Avoid a full update of the line in the
                 * trivial case. */
                if (write(l->ofd,cbuf,clen) == -1) return -1;
            } else {
                refreshLine(l);
            }
        } else {
            memmove(l->buf+l->pos+clen,l->buf+l->pos,l->len-l->pos);
            memcpy(&l->buf[l->pos],cbuf,clen);
            l->pos+=clen;
            l->len+=clen;
            l->buf[l->len] = '\0';
            refreshLine(l);
        }
    }
    return 0;
}

/* Move cursor on the left. */
inline void linenoiseEditMoveLeft(struct linenoiseState *l) {
    if (l->pos > 0) {
        l->pos -= unicodePrevGraphemeLen(l->buf, l->pos);
        refreshLine(l);
    }
}

/* Move cursor on the right. */
inline void linenoiseEditMoveRight(struct linenoiseState *l) {
    if (l->pos != l->len) {
        l->pos += unicodeGraphemeLen(l->buf, l->len, l->pos);
        refreshLine(l);
    }
}

/* Move cursor to the start of the line. */
inline void linenoiseEditMoveHome(struct linenoiseState *l) {
    if (l->pos != 0) {
        l->pos = 0;
        refreshLine(l);
    }
}

/* Move cursor to the end of the line. */
inline void linenoiseEditMoveEnd(struct linenoiseState *l) {
    if (l->pos != l->len) {
        l->pos = l->len;
        refreshLine(l);
    }
}

/* Substitute the currently edited line with the next or previous history
 * entry as specified by 'dir'. */
#define LINENOISE_HISTORY_NEXT 0
#define LINENOISE_HISTORY_PREV 1
inline void linenoiseEditHistoryNext(struct linenoiseState *l, int dir) {
    if (history.size() > 1) {
        /* Update the current history entry before to
         * overwrite it with the next one. */
        history[history.size() - 1 - l->history_index] = l->buf;
        /* Show the new entry */
        l->history_index += (dir == LINENOISE_HISTORY_PREV) ? 1 : -1;
        if (l->history_index < 0) {
            l->history_index = 0;
            return;
        } else if (l->history_index >= (int)history.size()) {
            l->history_index = static_cast<int>(history.size())-1;
            return;
        }
        memset(l->buf, 0, l->buflen);
        strcpy(l->buf,history[history.size() - 1 - l->history_index].c_str());
        l->len = l->pos = static_cast<int>(strlen(l->buf));
        refreshLine(l);
    }
}

/* Delete the character at the right of the cursor without altering the cursor
 * position. Basically this is what happens with the "Delete" keyboard key. */
inline void linenoiseEditDelete(struct linenoiseState *l) {
    if (l->len > 0 && l->pos < l->len) {
        int glen = unicodeGraphemeLen(l->buf,l->len,l->pos);
        memmove(l->buf+l->pos,l->buf+l->pos+glen,l->len-l->pos-glen);
        l->len-=glen;
        l->buf[l->len] = '\0';
        refreshLine(l);
    }
}

/* Backspace implementation. */
inline void linenoiseEditBackspace(struct linenoiseState *l) {
    if (l->pos > 0 && l->len > 0) {
        int glen = unicodePrevGraphemeLen(l->buf,l->pos);
        memmove(l->buf+l->pos-glen,l->buf+l->pos,l->len-l->pos);
        l->pos-=glen;
        l->len-=glen;
        l->buf[l->len] = '\0';
        refreshLine(l);
    }
}

/* Delete the previous word, maintaining the cursor at the start of the
 * current word. */
inline void linenoiseEditDeletePrevWord(struct linenoiseState *l) {
    int old_pos = l->pos;
    int diff;

    while (l->pos > 0 && l->buf[l->pos-1] == ' ')
        l->pos--;
    while (l->pos > 0 && l->buf[l->pos-1] != ' ')
        l->pos--;
    diff = old_pos - l->pos;
    memmove(l->buf+l->pos,l->buf+old_pos,l->len-old_pos+1);
    l->len -= diff;
    refreshLine(l);
}

/* This function is the core of the line editing capability of linenoise.
 * It expects 'fd' to be already in "raw mode" so that every key pressed
 * will be returned ASAP to read().
 *
 * The resulting string is put into 'buf' when the user type enter, or
 * when ctrl+d is typed.
 *
 * The function returns the length of the current buffer. */
inline int linenoiseEdit(int stdin_fd, int stdout_fd, char *buf, int buflen, const char *prompt)
{
    struct linenoiseState l;

    /* Populate the linenoise state that we pass to functions implementing
     * specific editing functionalities. */
    l.ifd = stdin_fd;
    l.ofd = stdout_fd;
    l.buf = buf;
    l.buflen = buflen;
    l.prompt = prompt;
    l.oldcolpos = l.pos = 0;
    l.len = 0;
    l.cols = getColumns(stdin_fd, stdout_fd);
    l.maxrows = 0;
    l.history_index = 0;

    /* Buffer starts empty. */
    l.buf[0] = '\0';
    l.buflen--; /* Make sure there is always space for the nulterm */

    /* The latest history entry is always our current buffer, that
     * initially is just an empty string. */
    AddHistory("");

    if (write(l.ofd,prompt, static_cast<int>(l.prompt.length())) == -1) return -1;
    while(1) {
        int c;
        char cbuf[4];
        int nread;
        char seq[3];

#ifdef _WIN32
        nread = win32read(&c);
        if (nread == 1) {
            cbuf[0] = c;
        }
#else
        nread = unicodeReadUTF8Char(l.ifd,cbuf,&c);
#endif
        if (nread <= 0) return (int)l.len;

        /* Only autocomplete when the callback is set. It returns < 0 when
         * there was an error reading from fd. Otherwise it will return the
         * character that should be handled next. */
        if (c == 9 && completionCallback != NULL) {
            nread = completeLine(&l,cbuf,&c);
            /* Return on errors */
            if (c < 0) return l.len;
            /* Read next character when 0 */
            if (c == 0) continue;
        }

        switch(c) {
        case ENTER:    /* enter */
            if (!history.empty()) history.pop_back();
            if (mlmode) linenoiseEditMoveEnd(&l);
            return (int)l.len;
        case CTRL_C:     /* ctrl-c */
            errno = EAGAIN;
            return -1;
        case BACKSPACE:   /* backspace */
        case 8:     /* ctrl-h */
            linenoiseEditBackspace(&l);
            break;
        case CTRL_D:     /* ctrl-d, remove char at right of cursor, or if the
                            line is empty, act as end-of-file. */
            if (l.len > 0) {
                linenoiseEditDelete(&l);
            } else {
                history.pop_back();
                return -1;
            }
            break;
        case CTRL_T:    /* ctrl-t, swaps current character with previous. */
            if (l.pos > 0 && l.pos < l.len) {
                char aux = buf[l.pos-1];
                buf[l.pos-1] = buf[l.pos];
                buf[l.pos] = aux;
                if (l.pos != l.len-1) l.pos++;
                refreshLine(&l);
            }
            break;
        case CTRL_B:     /* ctrl-b */
            linenoiseEditMoveLeft(&l);
            break;
        case CTRL_F:     /* ctrl-f */
            linenoiseEditMoveRight(&l);
            break;
        case CTRL_P:    /* ctrl-p */
            linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_PREV);
            break;
        case CTRL_N:    /* ctrl-n */
            linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_NEXT);
            break;
        case ESC:    /* escape sequence */
            /* Read the next two bytes representing the escape sequence.
             * Use two calls to handle slow terminals returning the two
             * chars at different times. */
            if (read(l.ifd,seq,1) == -1) break;
            if (read(l.ifd,seq+1,1) == -1) break;

            /* ESC [ sequences. */
            if (seq[0] == '[') {
                if (seq[1] >= '0' && seq[1] <= '9') {
                    /* Extended escape, read additional byte. */
                    if (read(l.ifd,seq+2,1) == -1) break;
                    if (seq[2] == '~') {
                        switch(seq[1]) {
                        case '3': /* Delete key. */
                            linenoiseEditDelete(&l);
                            break;
                        }
                    }
                } else {
                    switch(seq[1]) {
                    case 'A': /* Up */
                        linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_PREV);
                        break;
                    case 'B': /* Down */
                        linenoiseEditHistoryNext(&l, LINENOISE_HISTORY_NEXT);
                        break;
                    case 'C': /* Right */
                        linenoiseEditMoveRight(&l);
                        break;
                    case 'D': /* Left */
                        linenoiseEditMoveLeft(&l);
                        break;
                    case 'H': /* Home */
                        linenoiseEditMoveHome(&l);
                        break;
                    case 'F': /* End*/
                        linenoiseEditMoveEnd(&l);
                        break;
                    }
                }
            }

            /* ESC O sequences. */
            else if (seq[0] == 'O') {
                switch(seq[1]) {
                case 'H': /* Home */
                    linenoiseEditMoveHome(&l);
                    break;
                case 'F': /* End*/
                    linenoiseEditMoveEnd(&l);
                    break;
                }
            }
            break;
        default:
            if (linenoiseEditInsert(&l,cbuf,nread)) return -1;
            break;
        case CTRL_U: /* Ctrl+u, delete the whole line. */
            buf[0] = '\0';
            l.pos = l.len = 0;
            refreshLine(&l);
            break;
        case CTRL_K: /* Ctrl+k, delete from current to end of line. */
            buf[l.pos] = '\0';
            l.len = l.pos;
            refreshLine(&l);
            break;
        case CTRL_A: /* Ctrl+a, go to the start of the line */
            linenoiseEditMoveHome(&l);
            break;
        case CTRL_E: /* ctrl+e, go to the end of the line */
            linenoiseEditMoveEnd(&l);
            break;
        case CTRL_L: /* ctrl+l, clear screen */
            linenoiseClearScreen();
            refreshLine(&l);
            break;
        case CTRL_W: /* ctrl+w, delete previous word */
            linenoiseEditDeletePrevWord(&l);
            break;
        }
    }
    return l.len;
}

/* This function calls the line editing function linenoiseEdit() using
 * the STDIN file descriptor set in raw mode. */
inline bool linenoiseRaw(const char *prompt, std::string& line) {
    bool quit = false;

    if (!isatty(STDIN_FILENO)) {
        /* Not a tty: read from file / pipe. */
        std::getline(std::cin, line);
    } else {
        /* Interactive editing. */
        if (enableRawMode(STDIN_FILENO) == false) {
            return quit;
        }

        char buf[LINENOISE_MAX_LINE];
        auto count = linenoiseEdit(STDIN_FILENO, STDOUT_FILENO, buf, LINENOISE_MAX_LINE, prompt);
        if (count == -1) {
            quit = true;
        } else {
            line.assign(buf, count);
        }

        disableRawMode(STDIN_FILENO);
        printf("\n");
    }
    return quit;
}

/* The high level function that is the main API of the linenoise library.
 * This function checks if the terminal has basic capabilities, just checking
 * for a blacklist of stupid terminals, and later either calls the line
 * editing function or uses dummy fgets() so that you will be able to type
 * something even in the most desperate of the conditions. */
inline bool Readline(const char *prompt, std::string& line) {
    if (isUnsupportedTerm()) {
        printf("%s",prompt);
        fflush(stdout);
        std::getline(std::cin, line);
        return false;
    } else {
        return linenoiseRaw(prompt, line);
    }
}

inline std::string Readline(const char *prompt, bool& quit) {
    std::string line;
    quit = Readline(prompt, line);
    return line;
}

inline std::string Readline(const char *prompt) {
    bool quit; // dummy
    return Readline(prompt, quit);
}

/* ================================ History ================================= */

/* At exit we'll try to fix the terminal to the initial conditions. */
inline void linenoiseAtExit(void) {
    disableRawMode(STDIN_FILENO);
}

/* This is the API call to add a new entry in the linenoise history.
 * It uses a fixed array of char pointers that are shifted (memmoved)
 * when the history max length is reached in order to remove the older
 * entry and make room for the new one, so it is not exactly suitable for huge
 * histories, but will work well for a few hundred of entries.
 *
 * Using a circular buffer is smarter, but a bit more complex to handle. */
inline bool AddHistory(const char* line) {
    if (history_max_len == 0) return false;

    /* Don't add duplicated lines. */
    if (!history.empty() && history.back() == line) return false;

    /* If we reached the max length, remove the older line. */
    if (history.size() == history_max_len) {
        history.erase(history.begin());
    }
    history.push_back(line);

    return true;
}

/* Set the maximum length for the history. This function can be called even
 * if there is already some history, the function will make sure to retain
 * just the latest 'len' elements if the new history length value is smaller
 * than the amount of items already inside the history. */
inline bool SetHistoryMaxLen(size_t len) {
    if (len < 1) return false;
    history_max_len = len;
    if (len < history.size()) {
        history.resize(len);
    }
    return true;
}

/* Save the history in the specified file. On success *true* is returned
 * otherwise *false* is returned. */
inline bool SaveHistory(const char* path) {
    std::ofstream f(path); // TODO: need 'std::ios::binary'?
    if (!f) return false;
    for (const auto& h: history) {
        f << h << std::endl;
    }
    return true;
}

/* Load the history from the specified file. If the file does not exist
 * zero is returned and no operation is performed.
 *
 * If the file exists and the operation succeeded *true* is returned, otherwise
 * on error *false* is returned. */
inline bool LoadHistory(const char* path) {
    std::ifstream f(path);
    if (!f) return false;
    std::string line;
    while (std::getline(f, line)) {
        AddHistory(line.c_str());
    }
    return true;
}

inline const std::vector<std::string>& GetHistory() {
    return history;
}

} // namespace linenoise

#ifdef _WIN32
#undef isatty
#undef write
#undef read
#pragma warning(pop)
#endif

#endif /* __LINENOISE_HPP */
```

`jni/main.cpp`:

```cpp
/*
 * Copyright 2024 DeNA Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <memory>
#include <signal.h>
#include <stdlib.h>
#include <string>
#if !defined(_WIN32) && !defined(_WIN64)
#include <unistd.h>
#else
#include "getopt.h"
#endif
#include "Config.h"
#include "LineReader.h"
#include "Patcher.h"
const char *VERSION = "1.3.1";

void Usage(const char *exepath) {
  fprintf(stderr, "Usage: %s -p pid\n", exepath);
  fprintf(stderr, "Version: mempatch v%s\n", VERSION);
  fprintf(stderr, "Options:\n");
  fprintf(stderr, "  -h        Print this message\n");
#ifdef __linux__
  fprintf(stderr, "  -w        Without ptrace\n");
#endif
  fprintf(stderr, "  -l        Windows mode\n");
  fprintf(stderr, "  -p pid    Set process ID to attach\n");
  fprintf(stderr, "\n");
  Patcher::PrintCommandUsage();
  exit(1);
}

static std::unique_ptr<Patcher> patcher; // signal用

void sigcatch(int sig) {
  static bool first = true;
  if (first) {
    first = false;
    fprintf(stderr, "catch signal %d & Exit mempach\n", sig);
    patcher->Exit();
  }
  exit(1);
}

int main(int argc, char *argv[]) {
  const char *exepath = argv[0];
  bool without_ptrace = false;
  bool windows = false;
  int pid = -1;
  int result;
  while ((result = getopt(argc, argv, "hwlp:")) != -1) {
    switch (result) {
    case 'p':
      pid = atoi(optarg);
      break;
    case 'w':
      without_ptrace = true;
      break;
    case 'l':
      windows = true;
      break;
    case 'h':
    default:
      Usage(exepath);
      break;
    }
  }
  if (pid == -1) {
    Usage(exepath);
  }

  if (without_ptrace) {
    fprintf(stdout, "Without Ptrace Mode\n");
  }
  if (windows) {
    fprintf(stdout, "Windows Mode\n");
  }
  patcher = std::make_unique<Patcher>(pid, without_ptrace);

#if !defined(_WIN32) && !defined(_WIN64)
  if (SIG_ERR == signal(SIGHUP, sigcatch) || SIG_ERR == signal(SIGINT, sigcatch) ||
      SIG_ERR == signal(SIGQUIT, sigcatch) || SIG_ERR == signal(SIGSEGV, sigcatch)) {
    fprintf(stderr, "failed to set signal handler\n");
    exit(1);
  }
#endif
  // const std::string change_filename("/sdcard/changeset");
  // const std::string result_filename("/sdcard/changeresult");

  LineReader::Dispatch(*patcher, windows);
  patcher->Exit();

  return 0;
}

```

`jni/test/VictimJavaAscii.java`:

```java
/*
 * Copyright 2024 DeNA Co., Ltd.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import java.lang.*;
import java.util.Random;

public class VictimJavaAscii {
    public static void main(String[] args) {
        Random rnd = new Random();
        String str = "dfac";
        while (true) {
            System.out.println(str);
            str += (char)('a' + rnd.nextInt(26));
            if (str.length() > 20) { str = "dfac"; }
            try {
                Thread.sleep(1000);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}

```

`jni/test/victim_ascii.cpp`:

```cpp
/*
 * Copyright 2024 DeNA Co., Ltd.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

char str[50] = "https://www.example.com/";
int main() {
    for (int i = 0; i < 10; i++) {
        str[i] = rand() % 26 + 'a';
    }
    while (true) {
        for (int i = 10; i < 30; i++) {
            str[i] = rand() % 26 + 'a';
            str[i + 1] = 0;
            fprintf(stdout, "str=%s\n", str);
            sleep(3);
        }
    }
}

```

`jni/test/victim_int.cpp`:

```cpp
/*
 * Copyright 2024 DeNA Co., Ltd.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <unistd.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    int32_t sum = 0;
    int32_t step = 123456789;
    int32_t sleep_time = 5 * 1000 * 1000;
    if (argc > 1) {
        step = atoi(argv[1]);
    }
    if (argc > 2) {
        sleep_time = atoi(argv[2]);
    }
    while (true) {
        sum += step;
        fprintf(stdout, "step=%d, sleep=%d(micro sec), sum=%d\n", step, sleep_time, sum);
        usleep(sleep_time);
    }
}

```

`jni/test/victim_mass.cpp`:

```cpp
/*
 * Copyright 2024 DeNA Co., Ltd.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
 * either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <unistd.h>
#include <stdio.h>
#include <time.h>
#include <vector>

struct Random {
  unsigned int x;
  unsigned int y;
  unsigned int z;
  unsigned int w;
  Random() : x(0x34fb2383), y(0x327328fa), z(0xabd4b54a), w(0xa9dba8d1) {;}
  Random(int s) : x(0x34fb2383), y(0x327328fa), z(0xabd4b54a), w(s) {
    for (int i = 0; i < 100; i++) { Xor128(); }
  }
  void Seed(int s) {
    *this = Random(s);
  }
  unsigned int Xor128() {
    unsigned int t;
    t = x ^ (x << 11);
    x = y; y = z; z = w;
    return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
  }
  int next(int r) { return Xor128() % r; }
  int next(int l, int r) { return next(r - l + 1) + l; }
};
Random rnd;

int main() {
  const int SIZE1 = 1024 * 100;
  const int SIZE2 = 1024;
  Random rnd(time(nullptr));
  std::vector<std::vector<int>> mass(SIZE1, std::vector<int>(SIZE2, 0));
  int iter = 0;
  while (true) {
    iter++;
    for (int i = 0; i < 20; i++) {
      int r = rnd.next(SIZE1);
      for (int i = 0; i < SIZE2; i++) {
        mass[r][i] = rnd.next(0, 100000);
      }
    }
    printf("iter:%d\n", iter);
    sleep(1);
  }
}

```

`other-LICENSES/cpp-linenoise-LICENSE`:

```
Copyright (c) 2015 yhirose
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

`other-LICENSES/linenoise-LICENSE`:

```
Copyright (c) 2010-2014, Salvatore Sanfilippo <antirez at gmail dot com>
Copyright (c) 2010-2013, Pieter Noordhuis <pcnoordhuis at gmail dot com>

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```