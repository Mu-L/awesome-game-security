Project Path: arc_MKXJun_Rubik-Cube_icjq90cn

Source Tree:

```txt
arc_MKXJun_Rubik-Cube_icjq90cn
├── Direct3D11-Source
│   ├── BasicEffect.cpp
│   ├── Camera.cpp
│   ├── Camera.h
│   ├── Collision.cpp
│   ├── Collision.h
│   ├── DDSTextureLoader.cpp
│   ├── DDSTextureLoader.h
│   ├── DXTrace.cpp
│   ├── DXTrace.h
│   ├── EffectHelper.h
│   ├── Effects.h
│   ├── GameApp.cpp
│   ├── GameApp.h
│   ├── GameTimer.cpp
│   ├── GameTimer.h
│   ├── HLSL
│   │   ├── Basic.hlsli
│   │   ├── Basic_PS.hlsl
│   │   └── Basic_VS.hlsl
│   ├── Keyboard.cpp
│   ├── Keyboard.h
│   ├── Main.cpp
│   ├── Mouse.cpp
│   ├── Mouse.h
│   ├── Resource
│   │   ├── Black.dds
│   │   ├── Blue.dds
│   │   ├── Green.dds
│   │   ├── Orange.dds
│   │   ├── Red.dds
│   │   ├── White.dds
│   │   └── Yellow.dds
│   ├── Rubik.cpp
│   ├── Rubik.h
│   ├── ScreenGrab.cpp
│   ├── ScreenGrab.h
│   ├── Vertex.cpp
│   ├── Vertex.h
│   ├── WICTextureLoader.cpp
│   ├── WICTextureLoader.h
│   ├── d3dApp.cpp
│   ├── d3dApp.h
│   ├── d3dUtil.cpp
│   ├── d3dUtil.h
│   ├── 魔方.sln
│   ├── 魔方.vcxproj
│   └── 魔方.vcxproj.filters
├── Direct3D9-Source
│   ├── DirectX.cpp
│   ├── DirectX.h
│   ├── MyGame.cpp
│   ├── Rubik.cpp
│   ├── Rubik.h
│   ├── WinMain.cpp
│   ├── 魔方.sln
│   ├── 魔方.vcxproj
│   └── 魔方.vcxproj.filters
├── README.md
├── Rubik-Cube-Direct3D11-Release
│   ├── Resource
│   │   ├── Black.dds
│   │   ├── Blue.dds
│   │   ├── Green.dds
│   │   ├── Orange.dds
│   │   ├── Red.dds
│   │   ├── White.dds
│   │   └── Yellow.dds
│   ├── 魔方(Win7).exe
│   └── 魔方.exe
├── Rubik-Cube-Direct3D9-Release
│   ├── Resource
│   │   ├── Black.png
│   │   ├── Blue.png
│   │   ├── Green.png
│   │   ├── Orange.png
│   │   ├── Red.png
│   │   ├── White.png
│   │   └── Yellow.png
│   ├── user.dat
│   └── 魔方.exe
└── replay.gif

```

`Direct3D11-Source/BasicEffect.cpp`:

```cpp
#include "Effects.h"
#include "d3dUtil.h"
#include "EffectHelper.h"	// 必须晚于Effects.h和d3dUtil.h包含
#include "Vertex.h"
using namespace DirectX;

// 着色器字节码，编译后产生
#include "HLSL/Basic_VS.inc"
#include "HLSL/Basic_PS.inc"


//
// BasicEffect::Impl 需要先于BasicEffect的定义
//

class BasicEffect::Impl : public AlignedType<BasicEffect::Impl>
{
public:

	//
	// 这些结构体对应HLSL的结构体。需要按16字节对齐
	//

	struct CBChangesEveryDrawing
	{
		int texIndex;
		XMFLOAT3 gPad;
	};

	struct CBChangesEveryCube
	{
		XMMATRIX world;
	};

	struct CBChangesEveryFrame
	{
		XMMATRIX view;
	};

	struct CBChangesOnResize
	{
		XMMATRIX proj;
	};

public:
	// 必须显式指定
	Impl() = default;
	~Impl() = default;

public:
	// 需要16字节对齐的优先放在前面
	CBufferObject<0, CBChangesEveryDrawing> cbDrawing;		// 每次对象绘制的常量缓冲区
	CBufferObject<1, CBChangesEveryCube>    cbCube;			// 每个立方体绘制的常量缓冲区
	CBufferObject<2, CBChangesEveryFrame>   cbFrame;		// 每帧绘制的常量缓冲区
	CBufferObject<3, CBChangesOnResize>     cbOnResize;		// 每次窗口大小变更的常量缓冲区
	BOOL isDirty;											// 是否有值变更
	std::vector<CBufferBase*> cBufferPtrs;					// 统一管理上面所有的常量缓冲区


	ComPtr<ID3D11VertexShader> basicVS;						// 顶点着色器
	ComPtr<ID3D11PixelShader>  basicPS;						// 像素着色器

	ComPtr<ID3D11SamplerState> ssLinearWrap;				// 线性采样器状态

	ComPtr<ID3D11InputLayout>  vertexLayout;				// 顶点输入布局

	ComPtr<ID3D11ShaderResourceView> textureArray;			// 用于绘制的纹理数组

};

//
// BasicEffect
//

namespace
{
	// BasicEffect单例
	static BasicEffect * pInstance = nullptr;
}

BasicEffect::BasicEffect()
{
	if (pInstance)
		throw std::exception("BasicEffect is a singleton!");
	pInstance = this;
	pImpl = std::make_unique<BasicEffect::Impl>();
}

BasicEffect::~BasicEffect()
{
}

BasicEffect::BasicEffect(BasicEffect && moveFrom)
{
	pImpl.swap(moveFrom.pImpl);
}

BasicEffect & BasicEffect::operator=(BasicEffect && moveFrom)
{
	pImpl.swap(moveFrom.pImpl);
	return *this;
}

BasicEffect & BasicEffect::Get()
{
	if (!pInstance)
		throw std::exception("BasicEffect needs an instance!");
	return *pInstance;
}


bool BasicEffect::InitAll(ComPtr<ID3D11Device> device)
{
	if (!device)
		return false;

	if (!pImpl->cBufferPtrs.empty())
		return true;

	// 创建顶点着色器
	HR(device->CreateVertexShader(g_Basic_VS, sizeof(g_Basic_VS), nullptr, pImpl->basicVS.GetAddressOf()));
	// 创建顶点布局
	HR(device->CreateInputLayout(VertexPosTex::inputLayout, ARRAYSIZE(VertexPosTex::inputLayout),
		g_Basic_VS, sizeof(g_Basic_VS), pImpl->vertexLayout.GetAddressOf()));

	// 创建像素着色器
	HR(device->CreatePixelShader(g_Basic_PS, sizeof(g_Basic_PS), nullptr, pImpl->basicPS.GetAddressOf()));

	// 创建采样器状态
	D3D11_SAMPLER_DESC sd;
	ZeroMemory(&sd, sizeof sd);
	sd.AddressU = sd.AddressV = sd.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
	sd.ComparisonFunc = D3D11_COMPARISON_NEVER;
	sd.Filter = D3D11_FILTER_ANISOTROPIC;
	sd.MinLOD = 0;
	sd.MaxLOD = D3D11_FLOAT32_MAX;
	HR(device->CreateSamplerState(&sd, pImpl->ssLinearWrap.GetAddressOf()));

	pImpl->cBufferPtrs.assign({
		&pImpl->cbDrawing, 
		&pImpl->cbCube,
		&pImpl->cbFrame, 
		&pImpl->cbOnResize});

	// 创建常量缓冲区
	for (auto& pBuffer : pImpl->cBufferPtrs)
	{
		pBuffer->CreateBuffer(device);
	}

	return true;
}

void BasicEffect::SetRenderDefault(ComPtr<ID3D11DeviceContext> deviceContext)
{
	deviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	deviceContext->IASetInputLayout(pImpl->vertexLayout.Get());
	deviceContext->VSSetShader(pImpl->basicVS.Get(), nullptr, 0);
	deviceContext->RSSetState(nullptr);
	deviceContext->PSSetShader(pImpl->basicPS.Get(), nullptr, 0);
	deviceContext->PSSetSamplers(0, 1, pImpl->ssLinearWrap.GetAddressOf());
	deviceContext->OMSetDepthStencilState(nullptr, 0);
	deviceContext->OMSetBlendState(nullptr, nullptr, 0xFFFFFFFF);
}

void XM_CALLCONV BasicEffect::SetWorldMatrix(DirectX::FXMMATRIX W)
{
	auto& cBuffer = pImpl->cbCube;
	cBuffer.data.world = XMMatrixTranspose(W);
	pImpl->isDirty = cBuffer.isDirty = true;
}

void XM_CALLCONV BasicEffect::SetViewMatrix(FXMMATRIX V)
{
	auto& cBuffer = pImpl->cbFrame;
	cBuffer.data.view = XMMatrixTranspose(V);
	pImpl->isDirty = cBuffer.isDirty = true;
}

void XM_CALLCONV BasicEffect::SetProjMatrix(FXMMATRIX P)
{
	auto& cBuffer = pImpl->cbOnResize;
	cBuffer.data.proj = XMMatrixTranspose(P);
	pImpl->isDirty = cBuffer.isDirty = true;
}

void XM_CALLCONV BasicEffect::SetWorldViewProjMatrix(FXMMATRIX W, CXMMATRIX V, CXMMATRIX P)
{
	pImpl->cbCube.data.world = XMMatrixTranspose(W);
	pImpl->cbFrame.data.view = XMMatrixTranspose(V);
	pImpl->cbOnResize.data.proj = XMMatrixTranspose(P);

	auto& pCBuffers = pImpl->cBufferPtrs;
	pCBuffers[1]->isDirty = pCBuffers[2]->isDirty = pCBuffers[3]->isDirty = true;
	pImpl->isDirty = true;
}

void BasicEffect::SetTextureArray(ComPtr<ID3D11ShaderResourceView> textureArray)
{
	pImpl->textureArray = textureArray;
}

void BasicEffect::SetTexIndex(int index)
{
	auto& cBuffer = pImpl->cbDrawing;
	cBuffer.data.texIndex = index;
	pImpl->isDirty = cBuffer.isDirty = true;
}

void BasicEffect::Apply(ComPtr<ID3D11DeviceContext> deviceContext)
{
	auto& pCBuffers = pImpl->cBufferPtrs;
	// 将缓冲区绑定到渲染管线上
	pCBuffers[1]->BindVS(deviceContext);
	pCBuffers[2]->BindVS(deviceContext);
	pCBuffers[3]->BindVS(deviceContext);

	pCBuffers[0]->BindPS(deviceContext);

	// 设置纹理
	deviceContext->PSSetShaderResources(0, 1, pImpl->textureArray.GetAddressOf());

	if (pImpl->isDirty)
	{
		pImpl->isDirty = false;
		for (auto& pCBuffer : pCBuffers)
		{
			pCBuffer->UpdateBuffer(deviceContext);
		}
	}
}





```

`Direct3D11-Source/Camera.cpp`:

```cpp
#include "Camera.h"
using namespace DirectX;

Camera::Camera()
{
}

Camera::~Camera()
{
}

DirectX::XMVECTOR Camera::GetPositionXM() const
{
	return XMLoadFloat3(&mPosition);
}

DirectX::XMFLOAT3 Camera::GetPosition() const
{
	return mPosition;
}

DirectX::XMVECTOR Camera::GetRightXM() const
{
	return XMLoadFloat3(&mRight);
}

DirectX::XMFLOAT3 Camera::GetRight() const
{
	return mRight;
}

DirectX::XMVECTOR Camera::GetUpXM() const
{
	return XMLoadFloat3(&mUp);
}

DirectX::XMFLOAT3 Camera::GetUp() const
{
	return mUp;
}

DirectX::XMVECTOR Camera::GetLookXM() const
{
	return XMLoadFloat3(&mLook);
}

DirectX::XMFLOAT3 Camera::GetLook() const
{
	return mLook;
}

float Camera::GetNearWindowWidth() const
{
	return mAspect * mNearWindowHeight;
}

float Camera::GetNearWindowHeight() const
{
	return mNearWindowHeight;
}

float Camera::GetFarWindowWidth() const
{
	return mAspect * mFarWindowHeight;
}

float Camera::GetFarWindowHeight() const
{
	return mFarWindowHeight;
}

DirectX::XMMATRIX Camera::GetViewXM() const
{
	return XMLoadFloat4x4(&mView);
}

DirectX::XMMATRIX Camera::GetProjXM() const
{
	return XMLoadFloat4x4(&mProj);
}

DirectX::XMMATRIX Camera::GetViewProjXM() const
{
	return XMLoadFloat4x4(&mView) * XMLoadFloat4x4(&mProj);
}

D3D11_VIEWPORT Camera::GetViewPort() const
{
	return mViewPort;
}

void Camera::SetFrustum(float fovY, float aspect, float nearZ, float farZ)
{
	mFovY = fovY;
	mAspect = aspect;
	mNearZ = nearZ;
	mFarZ = farZ;

	mNearWindowHeight = 2.0f * mNearZ * tanf(0.5f * mFovY);
	mFarWindowHeight = 2.0f * mFarZ * tanf(0.5f * mFovY);

	XMStoreFloat4x4(&mProj, XMMatrixPerspectiveFovLH(mFovY, mAspect, mNearZ, mFarZ));
}

void Camera::SetViewPort(const D3D11_VIEWPORT & viewPort)
{
	mViewPort = viewPort;
}

void Camera::SetViewPort(float topLeftX, float topLeftY, float width, float height, float minDepth, float maxDepth)
{
	mViewPort.TopLeftX = topLeftX;
	mViewPort.TopLeftY = topLeftY;
	mViewPort.Width = width;
	mViewPort.Height = height;
	mViewPort.MinDepth = minDepth;
	mViewPort.MaxDepth = maxDepth;
}


// ********************
// 第一人称/自由视角摄像机
//

FirstPersonCamera::FirstPersonCamera()
	: Camera()
{
}

FirstPersonCamera::~FirstPersonCamera()
{
}

void FirstPersonCamera::SetPosition(float x, float y, float z)
{
	SetPosition(XMFLOAT3(x, y, z));
}

void FirstPersonCamera::SetPosition(const DirectX::XMFLOAT3 & v)
{
	mPosition = v;
}

void XM_CALLCONV FirstPersonCamera::LookAt(DirectX::FXMVECTOR pos, DirectX::FXMVECTOR target, DirectX::FXMVECTOR up)
{
	LookTo(pos, target - pos, up);
}

void FirstPersonCamera::LookAt(const DirectX::XMFLOAT3 & pos, const DirectX::XMFLOAT3 & target,const DirectX::XMFLOAT3 & up)
{
	LookAt(XMLoadFloat3(&pos), XMLoadFloat3(&target), XMLoadFloat3(&up));
}

void XM_CALLCONV FirstPersonCamera::LookTo(DirectX::FXMVECTOR pos, DirectX::FXMVECTOR to, DirectX::FXMVECTOR up)
{
	XMVECTOR L = XMVector3Normalize(to);
	XMVECTOR R = XMVector3Normalize(XMVector3Cross(up, L));
	XMVECTOR U = XMVector3Cross(L, R);

	XMStoreFloat3(&mPosition, pos);
	XMStoreFloat3(&mLook, L);
	XMStoreFloat3(&mRight, R);
	XMStoreFloat3(&mUp, U);
}

void FirstPersonCamera::LookTo(const DirectX::XMFLOAT3 & pos, const DirectX::XMFLOAT3 & to, const DirectX::XMFLOAT3 & up)
{
	LookTo(XMLoadFloat3(&pos), XMLoadFloat3(&to), XMLoadFloat3(&up));
}

void FirstPersonCamera::Strafe(float d)
{
	XMVECTOR Pos = XMLoadFloat3(&mPosition);
	XMVECTOR Right = XMLoadFloat3(&mRight);
	XMVECTOR Dist = XMVectorReplicate(d);
	// DestPos = Dist * Right + SrcPos
	XMStoreFloat3(&mPosition, XMVectorMultiplyAdd(Dist, Right, Pos));
}

void FirstPersonCamera::Walk(float d)
{
	XMVECTOR Pos = XMLoadFloat3(&mPosition);
	XMVECTOR Right = XMLoadFloat3(&mRight);
	XMVECTOR Up = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f);
	XMVECTOR Front = XMVector3Normalize(XMVector3Cross(Right, Up));
	XMVECTOR Dist = XMVectorReplicate(d);
	// DestPos = Dist * Front + SrcPos
	XMStoreFloat3(&mPosition, XMVectorMultiplyAdd(Dist, Front, Pos));
}

void FirstPersonCamera::MoveForward(float d)
{
	XMVECTOR Pos = XMLoadFloat3(&mPosition);
	XMVECTOR Look = XMLoadFloat3(&mLook);
	XMVECTOR Dist = XMVectorReplicate(d);
	// DestPos = Dist * Look + SrcPos
	XMStoreFloat3(&mPosition, XMVectorMultiplyAdd(Dist, Look, Pos));
}

void FirstPersonCamera::Pitch(float rad)
{
	XMMATRIX R = XMMatrixRotationAxis(XMLoadFloat3(&mRight), rad);
	XMVECTOR Up = XMVector3TransformNormal(XMLoadFloat3(&mUp), R);
	XMVECTOR Look = XMVector3TransformNormal(XMLoadFloat3(&mLook), R);
	float cosPhi = XMVectorGetY(Look);
	// 将上下视野角度Phi限制在[2pi/9, 7pi/9]，
	// 即余弦值[-cos(2pi/9), cos(2pi/9)]之间
	if (fabs(cosPhi) > cosf(XM_2PI / 9))
		return;
	
	XMStoreFloat3(&mUp, Up);
	XMStoreFloat3(&mLook, Look);
}

void FirstPersonCamera::RotateY(float rad)
{
	XMMATRIX R = XMMatrixRotationY(rad);

	XMStoreFloat3(&mRight, XMVector3TransformNormal(XMLoadFloat3(&mRight), R));
	XMStoreFloat3(&mUp, XMVector3TransformNormal(XMLoadFloat3(&mUp), R));
	XMStoreFloat3(&mLook, XMVector3TransformNormal(XMLoadFloat3(&mLook), R));
}

void FirstPersonCamera::UpdateViewMatrix()
{
	XMVECTOR R = XMLoadFloat3(&mRight);
	XMVECTOR U = XMLoadFloat3(&mUp);
	XMVECTOR L = XMLoadFloat3(&mLook);
	XMVECTOR P = XMLoadFloat3(&mPosition);

	// 保持摄像机的轴互为正交，且长度都为1
	L = XMVector3Normalize(L);
	U = XMVector3Normalize(XMVector3Cross(L, R));

	// U, L已经正交化，需要计算对应叉乘得到R
	R = XMVector3Cross(U, L);

	// 填充观察矩阵
	float x = -XMVectorGetX(XMVector3Dot(P, R));
	float y = -XMVectorGetX(XMVector3Dot(P, U));
	float z = -XMVectorGetX(XMVector3Dot(P, L));

	XMStoreFloat3(&mRight, R);
	XMStoreFloat3(&mUp, U);
	XMStoreFloat3(&mLook, L);

	mView = {
		mRight.x, mUp.x, mLook.x, 0.0f,
		mRight.y, mUp.y, mLook.y, 0.0f,
		mRight.z, mUp.z, mLook.z, 0.0f,
		x, y, z, 1.0f
	};
}

// ********************
// 第三人称摄像机
//

ThirdPersonCamera::ThirdPersonCamera()
	: Camera(), mTheta(), mPhi(), mDistance(), mTarget()
{
}

ThirdPersonCamera::~ThirdPersonCamera()
{
}

DirectX::XMFLOAT3 ThirdPersonCamera::GetTargetPosition() const
{
	return mTarget;
}

float ThirdPersonCamera::GetDistance() const
{
	return mDistance;
}

float ThirdPersonCamera::GetRotationX() const
{
	return mPhi;
}

float ThirdPersonCamera::GetRotationY() const
{
	return mTheta;
}

void ThirdPersonCamera::RotateX(float rad)
{
	mPhi -= rad;
	// 将上下视野角度Phi限制在[pi/6, pi/2]，
	// 即余弦值[0, cos(pi/6)]之间
	if (mPhi < XM_PI / 6)
		mPhi = XM_PI / 6;
	else if (mPhi > XM_PIDIV2)
		mPhi = XM_PIDIV2;
}

void ThirdPersonCamera::RotateY(float rad)
{
	mTheta = XMScalarModAngle(mTheta - rad);
}

void ThirdPersonCamera::Approach(float dist)
{
	mDistance += dist;
	// 限制距离在[mMinDist, mMaxDist]之间
	if (mDistance < mMinDist)
		mDistance = mMinDist;
	else if (mDistance > mMaxDist)
		mDistance = mMaxDist;
}

void ThirdPersonCamera::SetRotationX(float phi)
{
	mPhi = XMScalarModAngle(phi);
	// 将上下视野角度Phi限制在[pi/6, pi/2]，
	// 即余弦值[0, cos(pi/6)]之间
	if (mPhi < XM_PI / 6)
		mPhi = XM_PI / 6;
	else if (mPhi > XM_PIDIV2)
		mPhi = XM_PIDIV2;
}

void ThirdPersonCamera::SetRotationY(float theta)
{
	mTheta = XMScalarModAngle(theta);
}

void ThirdPersonCamera::SetTarget(const DirectX::XMFLOAT3 & target)
{
	mTarget = target;
}

void ThirdPersonCamera::SetDistance(float dist)
{
	mDistance = dist;
}

void ThirdPersonCamera::SetDistanceMinMax(float minDist, float maxDist)
{
	mMinDist = minDist;
	mMaxDist = maxDist;
}

void ThirdPersonCamera::UpdateViewMatrix()
{
	// 球面坐标系
	float x = mTarget.x + mDistance * sinf(mPhi) * cosf(mTheta);
	float z = mTarget.z + mDistance * sinf(mPhi) * sinf(mTheta);
	float y = mTarget.y + mDistance * cosf(mPhi);
	mPosition = { x, y, z };
	XMVECTOR P = XMLoadFloat3(&mPosition);
	XMVECTOR L = XMVector3Normalize(XMLoadFloat3(&mTarget) - P);
	XMVECTOR R = XMVector3Normalize(XMVector3Cross(XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f), L));
	XMVECTOR U = XMVector3Cross(L, R);
	
	// 更新向量
	XMStoreFloat3(&mRight, R);
	XMStoreFloat3(&mUp, U);
	XMStoreFloat3(&mLook, L);

	mView = {
		mRight.x, mUp.x, mLook.x, 0.0f,
		mRight.y, mUp.y, mLook.y, 0.0f,
		mRight.z, mUp.z, mLook.z, 0.0f,
		-XMVectorGetX(XMVector3Dot(P, R)), -XMVectorGetX(XMVector3Dot(P, U)), -XMVectorGetX(XMVector3Dot(P, L)), 1.0f
	};
}


```

`Direct3D11-Source/Camera.h`:

```h
//***************************************************************************************
// Camera.h by X_Jun(MKXJun) (C) 2018-2019 All Rights Reserved.
// Licensed under the MIT License.
//
// 提供第一人称(自由视角)和第三人称摄像机
// Provide 1st person(free view) and 3rd person cameras.
//***************************************************************************************

#ifndef CAMERA_H
#define CAMERA_H

#include <d3d11_1.h>
#include <DirectXMath.h>

class Camera
{
public:
	Camera();
	virtual ~Camera() = 0;

	// 获取摄像机位置
	DirectX::XMVECTOR GetPositionXM() const;
	DirectX::XMFLOAT3 GetPosition() const;

	// 获取摄像机的坐标轴向量
	DirectX::XMVECTOR GetRightXM() const;
	DirectX::XMFLOAT3 GetRight() const;
	DirectX::XMVECTOR GetUpXM() const;
	DirectX::XMFLOAT3 GetUp() const;
	DirectX::XMVECTOR GetLookXM() const;
	DirectX::XMFLOAT3 GetLook() const;

	// 获取视锥体信息
	float GetNearWindowWidth() const;
	float GetNearWindowHeight() const;
	float GetFarWindowWidth() const;
	float GetFarWindowHeight() const;

	// 获取矩阵
	DirectX::XMMATRIX GetViewXM() const;
	DirectX::XMMATRIX GetProjXM() const;
	DirectX::XMMATRIX GetViewProjXM() const;

	// 获取视口
	D3D11_VIEWPORT GetViewPort() const;


	// 设置视锥体
	void SetFrustum(float fovY, float aspect, float nearZ, float farZ);

	// 设置视口
	void SetViewPort(const D3D11_VIEWPORT& viewPort);
	void SetViewPort(float topLeftX, float topLeftY, float width, float height, float minDepth = 0.0f, float maxDepth = 1.0f);

	// 更新观察矩阵
	virtual void UpdateViewMatrix() = 0;
protected:
	// 摄像机的观察空间坐标系对应在世界坐标系中的表示
	DirectX::XMFLOAT3 mPosition;
	DirectX::XMFLOAT3 mRight;
	DirectX::XMFLOAT3 mUp;
	DirectX::XMFLOAT3 mLook;
	
	// 视锥体属性
	float mNearZ;
	float mFarZ;
	float mAspect;
	float mFovY;
	float mNearWindowHeight;
	float mFarWindowHeight;

	// 观察矩阵和透视投影矩阵
	DirectX::XMFLOAT4X4 mView;
	DirectX::XMFLOAT4X4 mProj;

	// 当前视口
	D3D11_VIEWPORT mViewPort;

};

class FirstPersonCamera : public Camera
{
public:
	FirstPersonCamera();
	~FirstPersonCamera() override;

	// 设置摄像机位置
	void SetPosition(float x, float y, float z);
	void SetPosition(const DirectX::XMFLOAT3& v);
	// 设置摄像机的朝向
	void XM_CALLCONV LookAt(DirectX::FXMVECTOR pos, DirectX::FXMVECTOR target, DirectX::FXMVECTOR up);
	void LookAt(const DirectX::XMFLOAT3& pos, const DirectX::XMFLOAT3& target,const DirectX::XMFLOAT3& up);
	void XM_CALLCONV LookTo(DirectX::FXMVECTOR pos, DirectX::FXMVECTOR to, DirectX::FXMVECTOR up);
	void LookTo(const DirectX::XMFLOAT3& pos, const DirectX::XMFLOAT3& to, const DirectX::XMFLOAT3& up);
	// 平移
	void Strafe(float d);
	// 直行(平面移动)
	void Walk(float d);
	// 前进(朝前向移动)
	void MoveForward(float d);
	// 上下观察
	void Pitch(float rad);
	// 左右观察
	void RotateY(float rad);


	// 更新观察矩阵
	void UpdateViewMatrix() override;
};

class ThirdPersonCamera : public Camera
{
public:
	ThirdPersonCamera();
	~ThirdPersonCamera() override;

	// 获取当前跟踪物体的位置
	DirectX::XMFLOAT3 GetTargetPosition() const;
	// 获取与物体的距离
	float GetDistance() const;
	// 获取绕X轴的旋转方向
	float GetRotationX() const;
	// 获取绕Y轴的旋转方向
	float GetRotationY() const;
	// 绕物体垂直旋转(注意上下视野角度Phi限制在[pi/6, pi/2])
	void RotateX(float rad);
	// 绕物体水平旋转
	void RotateY(float rad);
	// 拉近物体
	void Approach(float dist);
	// 设置初始绕X轴的弧度(注意上下视野角度Phi限制在[pi/6, pi/2])
	void SetRotationX(float phi);
	// 设置初始绕Y轴的弧度
	void SetRotationY(float theta);
	// 设置并绑定待跟踪物体的位置
	void SetTarget(const DirectX::XMFLOAT3& target);
	// 设置初始距离
	void SetDistance(float dist);
	// 设置最小最大允许距离
	void SetDistanceMinMax(float minDist, float maxDist);
	// 更新观察矩阵
	void UpdateViewMatrix() override;

private:
	DirectX::XMFLOAT3 mTarget;
	float mDistance;
	// 最小允许距离，最大允许距离
	float mMinDist, mMaxDist;
	// 以世界坐标系为基准，当前的旋转角度
	float mTheta;
	float mPhi;
};


#endif

```

`Direct3D11-Source/Collision.cpp`:

```cpp
#include "Collision.h"

using namespace DirectX;

Ray::Ray()
	: origin(), direction(0.0f, 0.0f, 1.0f)
{
}

Ray::Ray(const DirectX::XMFLOAT3 & origin, const DirectX::XMFLOAT3 & direction)
	: origin(origin)
{
	// 射线的direction长度必须为1.0f，误差在1e-5f内
	XMVECTOR dirLength = XMVector3Length(XMLoadFloat3(&direction));
	XMVECTOR error = XMVectorAbs(dirLength - XMVectorSplatOne());
	assert(XMVector3Less(error, XMVectorReplicate(1e-5f)));

	XMStoreFloat3(&this->direction, XMVector3Normalize(XMLoadFloat3(&direction)));
}

Ray Ray::ScreenToRay(const Camera & camera, float screenX, float screenY)
{
	// ******************
	// 节选自DirectX::XMVector3Unproject函数，并省略了从世界坐标系到局部坐标系的变换
	//
	
	// 将屏幕坐标点从视口变换回NDC坐标系
	static const XMVECTORF32 D = { { { -1.0f, 1.0f, 0.0f, 0.0f } } };
	XMVECTOR V = XMVectorSet(screenX, screenY, 0.0f, 1.0f);
	D3D11_VIEWPORT viewPort = camera.GetViewPort();

	XMVECTOR Scale = XMVectorSet(viewPort.Width * 0.5f, -viewPort.Height * 0.5f, viewPort.MaxDepth - viewPort.MinDepth, 1.0f);
	Scale = XMVectorReciprocal(Scale);

	XMVECTOR Offset = XMVectorSet(-viewPort.TopLeftX, -viewPort.TopLeftY, -viewPort.MinDepth, 0.0f);
	Offset = XMVectorMultiplyAdd(Scale, Offset, D.v);

	// 从NDC坐标系变换回世界坐标系
	XMMATRIX Transform = XMMatrixMultiply(camera.GetViewXM(), camera.GetProjXM());
	Transform = XMMatrixInverse(nullptr, Transform);

	XMVECTOR Target = XMVectorMultiplyAdd(V, Scale, Offset);
	Target = XMVector3TransformCoord(Target, Transform);

	// 求出射线
	XMFLOAT3 direction;
	XMStoreFloat3(&direction, XMVector3Normalize(Target - camera.GetPositionXM()));
	return Ray(camera.GetPosition(), direction);
}

bool Ray::Hit(const DirectX::BoundingBox & box, float * pOutDist, float maxDist)
{
	
	float dist;
	bool res = box.Intersects(XMLoadFloat3(&origin), XMLoadFloat3(&direction), dist);
	if (pOutDist)
		*pOutDist = dist;
	return dist > maxDist ? false : res;
}

bool Ray::Hit(const DirectX::BoundingOrientedBox & box, float * pOutDist, float maxDist)
{
	float dist;
	bool res = box.Intersects(XMLoadFloat3(&origin), XMLoadFloat3(&direction), dist);
	if (pOutDist)
		*pOutDist = dist;
	return dist > maxDist ? false : res;
}

bool Ray::Hit(const DirectX::BoundingSphere & sphere, float * pOutDist, float maxDist)
{
	float dist;
	bool res = sphere.Intersects(XMLoadFloat3(&origin), XMLoadFloat3(&direction), dist);
	if (pOutDist)
		*pOutDist = dist;
	return dist > maxDist ? false : res;
}

bool XM_CALLCONV Ray::Hit(FXMVECTOR V0, FXMVECTOR V1, FXMVECTOR V2, float * pOutDist, float maxDist)
{
	float dist;
	bool res = TriangleTests::Intersects(XMLoadFloat3(&origin), XMLoadFloat3(&direction), V0, V1, V2, dist);
	if (pOutDist)
		*pOutDist = dist;
	return dist > maxDist ? false : res;
}



Collision::WireFrameData Collision::CreateBoundingBox(const DirectX::BoundingBox & box, const DirectX::XMFLOAT4 & color)
{
	XMFLOAT3 corners[8];
	box.GetCorners(corners);
	return CreateFromCorners(corners, color);
}

Collision::WireFrameData Collision::CreateBoundingOrientedBox(const DirectX::BoundingOrientedBox & box, const DirectX::XMFLOAT4 & color)
{
	XMFLOAT3 corners[8];
	box.GetCorners(corners);
	return CreateFromCorners(corners, color);
}

Collision::WireFrameData Collision::CreateBoundingSphere(const DirectX::BoundingSphere & sphere, const DirectX::XMFLOAT4 & color, int slices)
{
	WireFrameData data;
	XMVECTOR center = XMLoadFloat3(&sphere.Center), posVec;
	XMFLOAT3 pos;
	float theta = 0.0f;
	for (int i = 0; i < slices; ++i)
	{
		posVec = XMVector3Transform(center + XMVectorSet(1.0f, 0.0f, 0.0f, 1.0f), XMMatrixRotationY(theta));
		XMStoreFloat3(&pos, posVec);
		data.vertexVec.push_back({ pos, color });
		posVec = XMVector3Transform(center + XMVectorSet(0.0f, 1.0f, 0.0f, 1.0f), XMMatrixRotationZ(theta));
		XMStoreFloat3(&pos, posVec);
		data.vertexVec.push_back({ pos, color });
		posVec = XMVector3Transform(center + XMVectorSet(0.0f, 0.0f, 1.0f, 1.0f), XMMatrixRotationX(theta));
		XMStoreFloat3(&pos, posVec);
		data.vertexVec.push_back({ pos, color });
		theta += XM_2PI / slices;
	}
	for (int i = 0; i < slices; ++i)
	{
		data.indexVec.push_back(i * 3);
		data.indexVec.push_back((i + 1) % slices * 3);

		data.indexVec.push_back(i * 3 + 1);
		data.indexVec.push_back((i + 1) % slices * 3 + 1);

		data.indexVec.push_back(i * 3 + 2);
		data.indexVec.push_back((i + 1) % slices * 3 + 2);
	}


	return data;
}

Collision::WireFrameData Collision::CreateBoundingFrustum(const DirectX::BoundingFrustum & frustum, const DirectX::XMFLOAT4 & color)
{
	XMFLOAT3 corners[8];
	frustum.GetCorners(corners);
	return CreateFromCorners(corners, color);
}

std::vector<XMMATRIX> XM_CALLCONV Collision::FrustumCulling(
	const std::vector<XMMATRIX>& Matrices,const BoundingBox& localBox, FXMMATRIX View, CXMMATRIX Proj)
{
	std::vector<DirectX::XMMATRIX> acceptedData;

	BoundingFrustum frustum;
	BoundingFrustum::CreateFromMatrix(frustum, Proj);
	XMMATRIX InvView = XMMatrixInverse(nullptr, View);
	// 将视锥体从局部坐标系变换到世界坐标系中
	frustum.Transform(frustum, InvView);

	BoundingOrientedBox localOrientedBox, orientedBox;
	BoundingOrientedBox::CreateFromBoundingBox(localOrientedBox, localBox);
	for (auto& mat : Matrices)
	{
		// 将有向包围盒从局部坐标系变换到世界坐标系中
		localOrientedBox.Transform(orientedBox, mat);
		// 相交检测
		if (frustum.Intersects(orientedBox))
			acceptedData.push_back(mat);
	}

	return acceptedData;
}

std::vector<DirectX::XMMATRIX> XM_CALLCONV Collision::FrustumCulling2(
	const std::vector<DirectX::XMMATRIX>& Matrices,const DirectX::BoundingBox& localBox, DirectX::FXMMATRIX View, DirectX::CXMMATRIX Proj)
{
	std::vector<DirectX::XMMATRIX> acceptedData;

	BoundingFrustum frustum, localFrustum;
	BoundingFrustum::CreateFromMatrix(frustum, Proj);
	XMMATRIX InvView = XMMatrixInverse(nullptr, View);
	for (auto& mat : Matrices)
	{
		XMMATRIX InvWorld = XMMatrixInverse(nullptr, mat);

		// 将视锥体从观察坐标系(或局部坐标系)变换到物体所在的局部坐标系中
		frustum.Transform(localFrustum, InvView * InvWorld);
		// 相交检测
		if (localFrustum.Intersects(localBox))
			acceptedData.push_back(mat);
	}

	return acceptedData;
}

std::vector<DirectX::XMMATRIX> XM_CALLCONV Collision::FrustumCulling3(
	const std::vector<DirectX::XMMATRIX>& Matrices,const DirectX::BoundingBox& localBox, DirectX::FXMMATRIX View, DirectX::CXMMATRIX Proj)
{
	std::vector<DirectX::XMMATRIX> acceptedData;

	BoundingFrustum frustum;
	BoundingFrustum::CreateFromMatrix(frustum, Proj);

	BoundingOrientedBox localOrientedBox, orientedBox;
	BoundingOrientedBox::CreateFromBoundingBox(localOrientedBox, localBox);
	for (auto& mat : Matrices)
	{
		// 将有向包围盒从局部坐标系变换到视锥体所在的局部坐标系(观察坐标系)中
		localOrientedBox.Transform(orientedBox, mat * View);
		// 相交检测
		if (frustum.Intersects(orientedBox))
			acceptedData.push_back(mat);
	}

	return acceptedData;
}

Collision::WireFrameData Collision::CreateFromCorners(const DirectX::XMFLOAT3(&corners)[8], const DirectX::XMFLOAT4 & color)
{
	WireFrameData data;
	// AABB/OBB顶点索引如下    视锥体顶点索引如下
	//     3_______2             4__________5
	//    /|      /|             |\        /|
	//  7/_|____6/ |             | \      / |
	//  |  |____|__|            7|_0\____/1_|6
	//  | /0    | /1              \ |    | /
	//  |/______|/                 \|____|/
	//  4       5                   3     2
	for (int i = 0; i < 8; ++i)
		data.vertexVec.push_back({ corners[i], color });
	for (int i = 0; i < 4; ++i)
	{
		data.indexVec.push_back(i);
		data.indexVec.push_back(i);

		data.indexVec.push_back(i);
		data.indexVec.push_back((i + 1) % 4);

		data.indexVec.push_back(i + 4);
		data.indexVec.push_back((i + 1) % 4 + 4);
	}
	return data;
}


```

`Direct3D11-Source/Collision.h`:

```h
//***************************************************************************************
// Collision.h by X_Jun(MKXJun) (C) 2018-2019 All Rights Reserved.
// Licensed under the MIT License.
//
// 提供一些封装好的对象和碰撞检测方法
// 注意：WireFrameData目前仍未经过稳定测试，未来有可能会移植到Geometry.h中
// Provide encapsulated collision classes and detection method.
//***************************************************************************************

#ifndef COLLISION_H
#define COLLISION_H

#include <DirectXCollision.h>
#include <vector>
#include "Vertex.h"
#include "Camera.h"


struct Ray
{
	Ray();
	Ray(const DirectX::XMFLOAT3& origin, const DirectX::XMFLOAT3& direction);

	static Ray ScreenToRay(const Camera& camera, float screenX, float screenY);

	bool Hit(const DirectX::BoundingBox& box, float* pOutDist = nullptr, float maxDist = FLT_MAX);
	bool Hit(const DirectX::BoundingOrientedBox& box, float* pOutDist = nullptr, float maxDist = FLT_MAX);
	bool Hit(const DirectX::BoundingSphere& sphere, float* pOutDist = nullptr, float maxDist = FLT_MAX);
	bool XM_CALLCONV Hit(DirectX::FXMVECTOR V0, DirectX::FXMVECTOR V1, DirectX::FXMVECTOR V2, float* pOutDist = nullptr, float maxDist = FLT_MAX);

	DirectX::XMFLOAT3 origin;		// 射线原点
	DirectX::XMFLOAT3 direction;	// 单位方向向量
};


class Collision
{
public:

	// 线框顶点/索引数组
	struct WireFrameData
	{
		std::vector<VertexPosColor> vertexVec;		// 顶点数组
		std::vector<WORD> indexVec;					// 索引数组
	};

	//
	// 包围盒线框的创建
	//

	// 创建AABB盒线框
	static WireFrameData CreateBoundingBox(const DirectX::BoundingBox& box, const DirectX::XMFLOAT4& color);
	// 创建OBB盒线框
	static WireFrameData CreateBoundingOrientedBox(const DirectX::BoundingOrientedBox& box, const DirectX::XMFLOAT4& color);
	// 创建包围球线框
	static WireFrameData CreateBoundingSphere(const DirectX::BoundingSphere& sphere, const DirectX::XMFLOAT4& color, int slices = 20);
	// 创建视锥体线框
	static WireFrameData CreateBoundingFrustum(const DirectX::BoundingFrustum& frustum, const DirectX::XMFLOAT4& color);

	//
	// 三种等价的测试视锥体裁剪的方法，获取所有与视锥体碰撞的碰撞体对应的世界矩阵数组
	//

	// 视锥体裁剪
	static std::vector<DirectX::XMMATRIX> XM_CALLCONV FrustumCulling(
		const std::vector<DirectX::XMMATRIX>& Matrices, const DirectX::BoundingBox& localBox, DirectX::FXMMATRIX View, DirectX::CXMMATRIX Proj);
	// 视锥体裁剪2
	static std::vector<DirectX::XMMATRIX> XM_CALLCONV FrustumCulling2(
		const std::vector<DirectX::XMMATRIX>& Matrices, const DirectX::BoundingBox& localBox, DirectX::FXMMATRIX View, DirectX::CXMMATRIX Proj);
	// 视锥体裁剪3
	static std::vector<DirectX::XMMATRIX> XM_CALLCONV FrustumCulling3(
		const std::vector<DirectX::XMMATRIX>& Matrices, const DirectX::BoundingBox& localBox, DirectX::FXMMATRIX View, DirectX::CXMMATRIX Proj);

private:
	static WireFrameData CreateFromCorners(const DirectX::XMFLOAT3(&corners)[8], const DirectX::XMFLOAT4& color);
};





#endif

```

`Direct3D11-Source/DDSTextureLoader.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// File: DDSTextureLoader.cpp
//
// Functions for loading a DDS texture and creating a Direct3D runtime resource for it
//
// Note these functions are useful as a light-weight runtime loader for DDS files. For
// a full-featured DDS file reader, writer, and texture processing pipeline see
// the 'Texconv' sample and the 'DirectXTex' library.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
// http://go.microsoft.com/fwlink/?LinkId=248926
// http://go.microsoft.com/fwlink/?LinkId=248929
//--------------------------------------------------------------------------------------

#include "DDSTextureLoader.h"

#include <assert.h>
#include <algorithm>
#include <memory>

#if !defined(NO_D3D11_DEBUG_NAME) && ( defined(_DEBUG) || defined(PROFILE) )
#pragma comment(lib,"dxguid.lib")
#endif

using namespace DirectX;

//--------------------------------------------------------------------------------------
// Macros
//--------------------------------------------------------------------------------------
#ifndef MAKEFOURCC
    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((uint32_t)(uint8_t)(ch0) | ((uint32_t)(uint8_t)(ch1) << 8) |       \
                ((uint32_t)(uint8_t)(ch2) << 16) | ((uint32_t)(uint8_t)(ch3) << 24 ))
#endif /* defined(MAKEFOURCC) */

//--------------------------------------------------------------------------------------
// DDS file structure definitions
//
// See DDS.h in the 'Texconv' sample and the 'DirectXTex' library
//--------------------------------------------------------------------------------------
#pragma pack(push,1)

const uint32_t DDS_MAGIC = 0x20534444; // "DDS "

struct DDS_PIXELFORMAT
{
    uint32_t    size;
    uint32_t    flags;
    uint32_t    fourCC;
    uint32_t    RGBBitCount;
    uint32_t    RBitMask;
    uint32_t    GBitMask;
    uint32_t    BBitMask;
    uint32_t    ABitMask;
};

#define DDS_FOURCC      0x00000004  // DDPF_FOURCC
#define DDS_RGB         0x00000040  // DDPF_RGB
#define DDS_LUMINANCE   0x00020000  // DDPF_LUMINANCE
#define DDS_ALPHA       0x00000002  // DDPF_ALPHA
#define DDS_BUMPDUDV    0x00080000  // DDPF_BUMPDUDV

#define DDS_HEADER_FLAGS_VOLUME         0x00800000  // DDSD_DEPTH

#define DDS_HEIGHT 0x00000002 // DDSD_HEIGHT
#define DDS_WIDTH  0x00000004 // DDSD_WIDTH

#define DDS_CUBEMAP_POSITIVEX 0x00000600 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX
#define DDS_CUBEMAP_NEGATIVEX 0x00000a00 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEX
#define DDS_CUBEMAP_POSITIVEY 0x00001200 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEY
#define DDS_CUBEMAP_NEGATIVEY 0x00002200 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEY
#define DDS_CUBEMAP_POSITIVEZ 0x00004200 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEZ
#define DDS_CUBEMAP_NEGATIVEZ 0x00008200 // DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEZ

#define DDS_CUBEMAP_ALLFACES ( DDS_CUBEMAP_POSITIVEX | DDS_CUBEMAP_NEGATIVEX |\
                               DDS_CUBEMAP_POSITIVEY | DDS_CUBEMAP_NEGATIVEY |\
                               DDS_CUBEMAP_POSITIVEZ | DDS_CUBEMAP_NEGATIVEZ )

#define DDS_CUBEMAP 0x00000200 // DDSCAPS2_CUBEMAP

enum DDS_MISC_FLAGS2
{
    DDS_MISC_FLAGS2_ALPHA_MODE_MASK = 0x7L,
};

struct DDS_HEADER
{
    uint32_t        size;
    uint32_t        flags;
    uint32_t        height;
    uint32_t        width;
    uint32_t        pitchOrLinearSize;
    uint32_t        depth; // only if DDS_HEADER_FLAGS_VOLUME is set in flags
    uint32_t        mipMapCount;
    uint32_t        reserved1[11];
    DDS_PIXELFORMAT ddspf;
    uint32_t        caps;
    uint32_t        caps2;
    uint32_t        caps3;
    uint32_t        caps4;
    uint32_t        reserved2;
};

struct DDS_HEADER_DXT10
{
    DXGI_FORMAT     dxgiFormat;
    uint32_t        resourceDimension;
    uint32_t        miscFlag; // see D3D11_RESOURCE_MISC_FLAG
    uint32_t        arraySize;
    uint32_t        miscFlags2;
};

#pragma pack(pop)

//--------------------------------------------------------------------------------------
namespace
{
    struct handle_closer { void operator()(HANDLE h) { if (h) CloseHandle(h); } };

    typedef std::unique_ptr<void, handle_closer> ScopedHandle;

    inline HANDLE safe_handle( HANDLE h ) { return (h == INVALID_HANDLE_VALUE) ? nullptr : h; }

    template<UINT TNameLength>
    inline void SetDebugObjectName(_In_ ID3D11DeviceChild* resource, _In_ const char (&name)[TNameLength])
    {
    #if defined(_DEBUG) || defined(PROFILE)
        resource->SetPrivateData(WKPDID_D3DDebugObjectName, TNameLength - 1, name);
    #else
        UNREFERENCED_PARAMETER(resource);
        UNREFERENCED_PARAMETER(name);
    #endif
    }

    //--------------------------------------------------------------------------------------
    HRESULT LoadTextureDataFromFile(
        _In_z_ const wchar_t* fileName,
        std::unique_ptr<uint8_t[]>& ddsData,
        const DDS_HEADER** header,
        const uint8_t** bitData,
        size_t* bitSize)
    {
        if (!header || !bitData || !bitSize)
        {
            return E_POINTER;
        }

        // open the file
#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)
        ScopedHandle hFile(safe_handle(CreateFile2(fileName,
            GENERIC_READ,
            FILE_SHARE_READ,
            OPEN_EXISTING,
            nullptr)));
#else
        ScopedHandle hFile(safe_handle(CreateFileW(fileName,
            GENERIC_READ,
            FILE_SHARE_READ,
            nullptr,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            nullptr)));
#endif

        if (!hFile)
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        // Get the file size
        FILE_STANDARD_INFO fileInfo;
        if (!GetFileInformationByHandleEx(hFile.get(), FileStandardInfo, &fileInfo, sizeof(fileInfo)))
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        // File is too big for 32-bit allocation, so reject read
        if (fileInfo.EndOfFile.HighPart > 0)
        {
            return E_FAIL;
        }

        // Need at least enough data to fill the header and magic number to be a valid DDS
        if (fileInfo.EndOfFile.LowPart < (sizeof(DDS_HEADER) + sizeof(uint32_t)))
        {
            return E_FAIL;
        }

        // create enough space for the file data
        ddsData.reset(new (std::nothrow) uint8_t[fileInfo.EndOfFile.LowPart]);
        if (!ddsData)
        {
            return E_OUTOFMEMORY;
        }

        // read the data in
        DWORD BytesRead = 0;
        if (!ReadFile(hFile.get(),
            ddsData.get(),
            fileInfo.EndOfFile.LowPart,
            &BytesRead,
            nullptr
        ))
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        if (BytesRead < fileInfo.EndOfFile.LowPart)
        {
            return E_FAIL;
        }

        // DDS files always start with the same magic number ("DDS ")
        uint32_t dwMagicNumber = *reinterpret_cast<const uint32_t*>(ddsData.get());
        if (dwMagicNumber != DDS_MAGIC)
        {
            return E_FAIL;
        }

        auto hdr = reinterpret_cast<const DDS_HEADER*>(ddsData.get() + sizeof(uint32_t));

        // Verify header to validate DDS file
        if (hdr->size != sizeof(DDS_HEADER) ||
            hdr->ddspf.size != sizeof(DDS_PIXELFORMAT))
        {
            return E_FAIL;
        }

        // Check for DX10 extension
        bool bDXT10Header = false;
        if ((hdr->ddspf.flags & DDS_FOURCC) &&
            (MAKEFOURCC('D', 'X', '1', '0') == hdr->ddspf.fourCC))
        {
            // Must be long enough for both headers and magic value
            if (fileInfo.EndOfFile.LowPart < (sizeof(DDS_HEADER) + sizeof(uint32_t) + sizeof(DDS_HEADER_DXT10)))
            {
                return E_FAIL;
            }

            bDXT10Header = true;
        }

        // setup the pointers in the process request
        *header = hdr;
        ptrdiff_t offset = sizeof(uint32_t) + sizeof(DDS_HEADER)
            + (bDXT10Header ? sizeof(DDS_HEADER_DXT10) : 0);
        *bitData = ddsData.get() + offset;
        *bitSize = fileInfo.EndOfFile.LowPart - offset;

        return S_OK;
    }


    //--------------------------------------------------------------------------------------
    // Return the BPP for a particular format
    //--------------------------------------------------------------------------------------
    size_t BitsPerPixel(_In_ DXGI_FORMAT fmt)
    {
        switch (fmt)
        {
        case DXGI_FORMAT_R32G32B32A32_TYPELESS:
        case DXGI_FORMAT_R32G32B32A32_FLOAT:
        case DXGI_FORMAT_R32G32B32A32_UINT:
        case DXGI_FORMAT_R32G32B32A32_SINT:
            return 128;

        case DXGI_FORMAT_R32G32B32_TYPELESS:
        case DXGI_FORMAT_R32G32B32_FLOAT:
        case DXGI_FORMAT_R32G32B32_UINT:
        case DXGI_FORMAT_R32G32B32_SINT:
            return 96;

        case DXGI_FORMAT_R16G16B16A16_TYPELESS:
        case DXGI_FORMAT_R16G16B16A16_FLOAT:
        case DXGI_FORMAT_R16G16B16A16_UNORM:
        case DXGI_FORMAT_R16G16B16A16_UINT:
        case DXGI_FORMAT_R16G16B16A16_SNORM:
        case DXGI_FORMAT_R16G16B16A16_SINT:
        case DXGI_FORMAT_R32G32_TYPELESS:
        case DXGI_FORMAT_R32G32_FLOAT:
        case DXGI_FORMAT_R32G32_UINT:
        case DXGI_FORMAT_R32G32_SINT:
        case DXGI_FORMAT_R32G8X24_TYPELESS:
        case DXGI_FORMAT_D32_FLOAT_S8X24_UINT:
        case DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS:
        case DXGI_FORMAT_X32_TYPELESS_G8X24_UINT:
        case DXGI_FORMAT_Y416:
        case DXGI_FORMAT_Y210:
        case DXGI_FORMAT_Y216:
            return 64;

        case DXGI_FORMAT_R10G10B10A2_TYPELESS:
        case DXGI_FORMAT_R10G10B10A2_UNORM:
        case DXGI_FORMAT_R10G10B10A2_UINT:
        case DXGI_FORMAT_R11G11B10_FLOAT:
        case DXGI_FORMAT_R8G8B8A8_TYPELESS:
        case DXGI_FORMAT_R8G8B8A8_UNORM:
        case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
        case DXGI_FORMAT_R8G8B8A8_UINT:
        case DXGI_FORMAT_R8G8B8A8_SNORM:
        case DXGI_FORMAT_R8G8B8A8_SINT:
        case DXGI_FORMAT_R16G16_TYPELESS:
        case DXGI_FORMAT_R16G16_FLOAT:
        case DXGI_FORMAT_R16G16_UNORM:
        case DXGI_FORMAT_R16G16_UINT:
        case DXGI_FORMAT_R16G16_SNORM:
        case DXGI_FORMAT_R16G16_SINT:
        case DXGI_FORMAT_R32_TYPELESS:
        case DXGI_FORMAT_D32_FLOAT:
        case DXGI_FORMAT_R32_FLOAT:
        case DXGI_FORMAT_R32_UINT:
        case DXGI_FORMAT_R32_SINT:
        case DXGI_FORMAT_R24G8_TYPELESS:
        case DXGI_FORMAT_D24_UNORM_S8_UINT:
        case DXGI_FORMAT_R24_UNORM_X8_TYPELESS:
        case DXGI_FORMAT_X24_TYPELESS_G8_UINT:
        case DXGI_FORMAT_R9G9B9E5_SHAREDEXP:
        case DXGI_FORMAT_R8G8_B8G8_UNORM:
        case DXGI_FORMAT_G8R8_G8B8_UNORM:
        case DXGI_FORMAT_B8G8R8A8_UNORM:
        case DXGI_FORMAT_B8G8R8X8_UNORM:
        case DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM:
        case DXGI_FORMAT_B8G8R8A8_TYPELESS:
        case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
        case DXGI_FORMAT_B8G8R8X8_TYPELESS:
        case DXGI_FORMAT_B8G8R8X8_UNORM_SRGB:
        case DXGI_FORMAT_AYUV:
        case DXGI_FORMAT_Y410:
        case DXGI_FORMAT_YUY2:
            return 32;

        case DXGI_FORMAT_P010:
        case DXGI_FORMAT_P016:
            return 24;

        case DXGI_FORMAT_R8G8_TYPELESS:
        case DXGI_FORMAT_R8G8_UNORM:
        case DXGI_FORMAT_R8G8_UINT:
        case DXGI_FORMAT_R8G8_SNORM:
        case DXGI_FORMAT_R8G8_SINT:
        case DXGI_FORMAT_R16_TYPELESS:
        case DXGI_FORMAT_R16_FLOAT:
        case DXGI_FORMAT_D16_UNORM:
        case DXGI_FORMAT_R16_UNORM:
        case DXGI_FORMAT_R16_UINT:
        case DXGI_FORMAT_R16_SNORM:
        case DXGI_FORMAT_R16_SINT:
        case DXGI_FORMAT_B5G6R5_UNORM:
        case DXGI_FORMAT_B5G5R5A1_UNORM:
        case DXGI_FORMAT_A8P8:
        case DXGI_FORMAT_B4G4R4A4_UNORM:
            return 16;

        case DXGI_FORMAT_NV12:
        case DXGI_FORMAT_420_OPAQUE:
        case DXGI_FORMAT_NV11:
            return 12;

        case DXGI_FORMAT_R8_TYPELESS:
        case DXGI_FORMAT_R8_UNORM:
        case DXGI_FORMAT_R8_UINT:
        case DXGI_FORMAT_R8_SNORM:
        case DXGI_FORMAT_R8_SINT:
        case DXGI_FORMAT_A8_UNORM:
        case DXGI_FORMAT_AI44:
        case DXGI_FORMAT_IA44:
        case DXGI_FORMAT_P8:
            return 8;

        case DXGI_FORMAT_R1_UNORM:
            return 1;

        case DXGI_FORMAT_BC1_TYPELESS:
        case DXGI_FORMAT_BC1_UNORM:
        case DXGI_FORMAT_BC1_UNORM_SRGB:
        case DXGI_FORMAT_BC4_TYPELESS:
        case DXGI_FORMAT_BC4_UNORM:
        case DXGI_FORMAT_BC4_SNORM:
            return 4;

        case DXGI_FORMAT_BC2_TYPELESS:
        case DXGI_FORMAT_BC2_UNORM:
        case DXGI_FORMAT_BC2_UNORM_SRGB:
        case DXGI_FORMAT_BC3_TYPELESS:
        case DXGI_FORMAT_BC3_UNORM:
        case DXGI_FORMAT_BC3_UNORM_SRGB:
        case DXGI_FORMAT_BC5_TYPELESS:
        case DXGI_FORMAT_BC5_UNORM:
        case DXGI_FORMAT_BC5_SNORM:
        case DXGI_FORMAT_BC6H_TYPELESS:
        case DXGI_FORMAT_BC6H_UF16:
        case DXGI_FORMAT_BC6H_SF16:
        case DXGI_FORMAT_BC7_TYPELESS:
        case DXGI_FORMAT_BC7_UNORM:
        case DXGI_FORMAT_BC7_UNORM_SRGB:
            return 8;

        default:
            return 0;
        }
    }


    //--------------------------------------------------------------------------------------
    // Get surface information for a particular format
    //--------------------------------------------------------------------------------------
    HRESULT GetSurfaceInfo(
        _In_ size_t width,
        _In_ size_t height,
        _In_ DXGI_FORMAT fmt,
        size_t* outNumBytes,
        _Out_opt_ size_t* outRowBytes,
        _Out_opt_ size_t* outNumRows)
    {
        uint64_t numBytes = 0;
        uint64_t rowBytes = 0;
        uint64_t numRows = 0;

        bool bc = false;
        bool packed = false;
        bool planar = false;
        size_t bpe = 0;
        switch (fmt)
        {
        case DXGI_FORMAT_BC1_TYPELESS:
        case DXGI_FORMAT_BC1_UNORM:
        case DXGI_FORMAT_BC1_UNORM_SRGB:
        case DXGI_FORMAT_BC4_TYPELESS:
        case DXGI_FORMAT_BC4_UNORM:
        case DXGI_FORMAT_BC4_SNORM:
            bc = true;
            bpe = 8;
            break;

        case DXGI_FORMAT_BC2_TYPELESS:
        case DXGI_FORMAT_BC2_UNORM:
        case DXGI_FORMAT_BC2_UNORM_SRGB:
        case DXGI_FORMAT_BC3_TYPELESS:
        case DXGI_FORMAT_BC3_UNORM:
        case DXGI_FORMAT_BC3_UNORM_SRGB:
        case DXGI_FORMAT_BC5_TYPELESS:
        case DXGI_FORMAT_BC5_UNORM:
        case DXGI_FORMAT_BC5_SNORM:
        case DXGI_FORMAT_BC6H_TYPELESS:
        case DXGI_FORMAT_BC6H_UF16:
        case DXGI_FORMAT_BC6H_SF16:
        case DXGI_FORMAT_BC7_TYPELESS:
        case DXGI_FORMAT_BC7_UNORM:
        case DXGI_FORMAT_BC7_UNORM_SRGB:
            bc = true;
            bpe = 16;
            break;

        case DXGI_FORMAT_R8G8_B8G8_UNORM:
        case DXGI_FORMAT_G8R8_G8B8_UNORM:
        case DXGI_FORMAT_YUY2:
            packed = true;
            bpe = 4;
            break;

        case DXGI_FORMAT_Y210:
        case DXGI_FORMAT_Y216:
            packed = true;
            bpe = 8;
            break;

        case DXGI_FORMAT_NV12:
        case DXGI_FORMAT_420_OPAQUE:
            planar = true;
            bpe = 2;
            break;

        case DXGI_FORMAT_P010:
        case DXGI_FORMAT_P016:
            planar = true;
            bpe = 4;
            break;

        default:
            break;
        }

        if (bc)
        {
            uint64_t numBlocksWide = 0;
            if (width > 0)
            {
                numBlocksWide = std::max<uint64_t>(1u, (uint64_t(width) + 3u) / 4u);
            }
            uint64_t numBlocksHigh = 0;
            if (height > 0)
            {
                numBlocksHigh = std::max<uint64_t>(1u, (uint64_t(height) + 3u) / 4u);
            }
            rowBytes = numBlocksWide * bpe;
            numRows = numBlocksHigh;
            numBytes = rowBytes * numBlocksHigh;
        }
        else if (packed)
        {
            rowBytes = ((uint64_t(width) + 1u) >> 1) * bpe;
            numRows = uint64_t(height);
            numBytes = rowBytes * height;
        }
        else if (fmt == DXGI_FORMAT_NV11)
        {
            rowBytes = ((uint64_t(width) + 3u) >> 2) * 4u;
            numRows = uint64_t(height) * 2u; // Direct3D makes this simplifying assumption, although it is larger than the 4:1:1 data
            numBytes = rowBytes * numRows;
        }
        else if (planar)
        {
            rowBytes = ((uint64_t(width) + 1u) >> 1) * bpe;
            numBytes = (rowBytes * uint64_t(height)) + ((rowBytes * uint64_t(height) + 1u) >> 1);
            numRows = height + ((uint64_t(height) + 1u) >> 1);
        }
        else
        {
            size_t bpp = BitsPerPixel(fmt);
            if (!bpp)
                return E_INVALIDARG;

            rowBytes = (uint64_t(width) * bpp + 7u) / 8u; // round up to nearest byte
            numRows = uint64_t(height);
            numBytes = rowBytes * height;
        }

#if defined(_M_IX86) || defined(_M_ARM) || defined(_M_HYBRID_X86_ARM64)
        static_assert(sizeof(size_t) == 4, "Not a 32-bit platform!");
        if (numBytes > UINT32_MAX || rowBytes > UINT32_MAX || numRows > UINT32_MAX)
            return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);
#else
        static_assert(sizeof(size_t) == 8, "Not a 64-bit platform!");
#endif

        if (outNumBytes)
        {
            *outNumBytes = static_cast<size_t>(numBytes);
        }
        if (outRowBytes)
        {
            *outRowBytes = static_cast<size_t>(rowBytes);
        }
        if (outNumRows)
        {
            *outNumRows = static_cast<size_t>(numRows);
        }

        return S_OK;
    }


    //--------------------------------------------------------------------------------------
    #define ISBITMASK( r,g,b,a ) ( ddpf.RBitMask == r && ddpf.GBitMask == g && ddpf.BBitMask == b && ddpf.ABitMask == a )

    DXGI_FORMAT GetDXGIFormat(const DDS_PIXELFORMAT& ddpf)
    {
        if (ddpf.flags & DDS_RGB)
        {
            // Note that sRGB formats are written using the "DX10" extended header

            switch (ddpf.RGBBitCount)
            {
            case 32:
                if (ISBITMASK(0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000))
                {
                    return DXGI_FORMAT_R8G8B8A8_UNORM;
                }

                if (ISBITMASK(0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000))
                {
                    return DXGI_FORMAT_B8G8R8A8_UNORM;
                }

                if (ISBITMASK(0x00ff0000, 0x0000ff00, 0x000000ff, 0x00000000))
                {
                    return DXGI_FORMAT_B8G8R8X8_UNORM;
                }

                // No DXGI format maps to ISBITMASK(0x000000ff,0x0000ff00,0x00ff0000,0x00000000) aka D3DFMT_X8B8G8R8

                // Note that many common DDS reader/writers (including D3DX) swap the
                // the RED/BLUE masks for 10:10:10:2 formats. We assume
                // below that the 'backwards' header mask is being used since it is most
                // likely written by D3DX. The more robust solution is to use the 'DX10'
                // header extension and specify the DXGI_FORMAT_R10G10B10A2_UNORM format directly

                // For 'correct' writers, this should be 0x000003ff,0x000ffc00,0x3ff00000 for RGB data
                if (ISBITMASK(0x3ff00000, 0x000ffc00, 0x000003ff, 0xc0000000))
                {
                    return DXGI_FORMAT_R10G10B10A2_UNORM;
                }

                // No DXGI format maps to ISBITMASK(0x000003ff,0x000ffc00,0x3ff00000,0xc0000000) aka D3DFMT_A2R10G10B10

                if (ISBITMASK(0x0000ffff, 0xffff0000, 0x00000000, 0x00000000))
                {
                    return DXGI_FORMAT_R16G16_UNORM;
                }

                if (ISBITMASK(0xffffffff, 0x00000000, 0x00000000, 0x00000000))
                {
                    // Only 32-bit color channel format in D3D9 was R32F
                    return DXGI_FORMAT_R32_FLOAT; // D3DX writes this out as a FourCC of 114
                }
                break;

            case 24:
                // No 24bpp DXGI formats aka D3DFMT_R8G8B8
                break;

            case 16:
                if (ISBITMASK(0x7c00, 0x03e0, 0x001f, 0x8000))
                {
                    return DXGI_FORMAT_B5G5R5A1_UNORM;
                }
                if (ISBITMASK(0xf800, 0x07e0, 0x001f, 0x0000))
                {
                    return DXGI_FORMAT_B5G6R5_UNORM;
                }

                // No DXGI format maps to ISBITMASK(0x7c00,0x03e0,0x001f,0x0000) aka D3DFMT_X1R5G5B5

                if (ISBITMASK(0x0f00, 0x00f0, 0x000f, 0xf000))
                {
                    return DXGI_FORMAT_B4G4R4A4_UNORM;
                }

                // No DXGI format maps to ISBITMASK(0x0f00,0x00f0,0x000f,0x0000) aka D3DFMT_X4R4G4B4

                // No 3:3:2, 3:3:2:8, or paletted DXGI formats aka D3DFMT_A8R3G3B2, D3DFMT_R3G3B2, D3DFMT_P8, D3DFMT_A8P8, etc.
                break;
            }
        }
        else if (ddpf.flags & DDS_LUMINANCE)
        {
            if (8 == ddpf.RGBBitCount)
            {
                if (ISBITMASK(0x000000ff, 0x00000000, 0x00000000, 0x00000000))
                {
                    return DXGI_FORMAT_R8_UNORM; // D3DX10/11 writes this out as DX10 extension
                }

                // No DXGI format maps to ISBITMASK(0x0f,0x00,0x00,0xf0) aka D3DFMT_A4L4

                if (ISBITMASK(0x000000ff, 0x00000000, 0x00000000, 0x0000ff00))
                {
                    return DXGI_FORMAT_R8G8_UNORM; // Some DDS writers assume the bitcount should be 8 instead of 16
                }
            }

            if (16 == ddpf.RGBBitCount)
            {
                if (ISBITMASK(0x0000ffff, 0x00000000, 0x00000000, 0x00000000))
                {
                    return DXGI_FORMAT_R16_UNORM; // D3DX10/11 writes this out as DX10 extension
                }
                if (ISBITMASK(0x000000ff, 0x00000000, 0x00000000, 0x0000ff00))
                {
                    return DXGI_FORMAT_R8G8_UNORM; // D3DX10/11 writes this out as DX10 extension
                }
            }
        }
        else if (ddpf.flags & DDS_ALPHA)
        {
            if (8 == ddpf.RGBBitCount)
            {
                return DXGI_FORMAT_A8_UNORM;
            }
        }
        else if (ddpf.flags & DDS_BUMPDUDV)
        {
            if (16 == ddpf.RGBBitCount)
            {
                if (ISBITMASK(0x00ff, 0xff00, 0x0000, 0x0000))
                {
                    return DXGI_FORMAT_R8G8_SNORM; // D3DX10/11 writes this out as DX10 extension
                }
            }

            if (32 == ddpf.RGBBitCount)
            {
                if (ISBITMASK(0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000))
                {
                    return DXGI_FORMAT_R8G8B8A8_SNORM; // D3DX10/11 writes this out as DX10 extension
                }
                if (ISBITMASK(0x0000ffff, 0xffff0000, 0x00000000, 0x00000000))
                {
                    return DXGI_FORMAT_R16G16_SNORM; // D3DX10/11 writes this out as DX10 extension
                }

                // No DXGI format maps to ISBITMASK(0x3ff00000, 0x000ffc00, 0x000003ff, 0xc0000000) aka D3DFMT_A2W10V10U10
            }
        }
        else if (ddpf.flags & DDS_FOURCC)
        {
            if (MAKEFOURCC('D', 'X', 'T', '1') == ddpf.fourCC)
            {
                return DXGI_FORMAT_BC1_UNORM;
            }
            if (MAKEFOURCC('D', 'X', 'T', '3') == ddpf.fourCC)
            {
                return DXGI_FORMAT_BC2_UNORM;
            }
            if (MAKEFOURCC('D', 'X', 'T', '5') == ddpf.fourCC)
            {
                return DXGI_FORMAT_BC3_UNORM;
            }

            // While pre-multiplied alpha isn't directly supported by the DXGI formats,
            // they are basically the same as these BC formats so they can be mapped
            if (MAKEFOURCC('D', 'X', 'T', '2') == ddpf.fourCC)
            {
                return DXGI_FORMAT_BC2_UNORM;
            }
            if (MAKEFOURCC('D', 'X', 'T', '4') == ddpf.fourCC)
            {
                return DXGI_FORMAT_BC3_UNORM;
            }

            if (MAKEFOURCC('A', 'T', 'I', '1') == ddpf.fourCC)
            {
                return DXGI_FORMAT_BC4_UNORM;
            }
            if (MAKEFOURCC('B', 'C', '4', 'U') == ddpf.fourCC)
            {
                return DXGI_FORMAT_BC4_UNORM;
            }
            if (MAKEFOURCC('B', 'C', '4', 'S') == ddpf.fourCC)
            {
                return DXGI_FORMAT_BC4_SNORM;
            }

            if (MAKEFOURCC('A', 'T', 'I', '2') == ddpf.fourCC)
            {
                return DXGI_FORMAT_BC5_UNORM;
            }
            if (MAKEFOURCC('B', 'C', '5', 'U') == ddpf.fourCC)
            {
                return DXGI_FORMAT_BC5_UNORM;
            }
            if (MAKEFOURCC('B', 'C', '5', 'S') == ddpf.fourCC)
            {
                return DXGI_FORMAT_BC5_SNORM;
            }

            // BC6H and BC7 are written using the "DX10" extended header

            if (MAKEFOURCC('R', 'G', 'B', 'G') == ddpf.fourCC)
            {
                return DXGI_FORMAT_R8G8_B8G8_UNORM;
            }
            if (MAKEFOURCC('G', 'R', 'G', 'B') == ddpf.fourCC)
            {
                return DXGI_FORMAT_G8R8_G8B8_UNORM;
            }

            if (MAKEFOURCC('Y', 'U', 'Y', '2') == ddpf.fourCC)
            {
                return DXGI_FORMAT_YUY2;
            }

            // Check for D3DFORMAT enums being set here
            switch (ddpf.fourCC)
            {
            case 36: // D3DFMT_A16B16G16R16
                return DXGI_FORMAT_R16G16B16A16_UNORM;

            case 110: // D3DFMT_Q16W16V16U16
                return DXGI_FORMAT_R16G16B16A16_SNORM;

            case 111: // D3DFMT_R16F
                return DXGI_FORMAT_R16_FLOAT;

            case 112: // D3DFMT_G16R16F
                return DXGI_FORMAT_R16G16_FLOAT;

            case 113: // D3DFMT_A16B16G16R16F
                return DXGI_FORMAT_R16G16B16A16_FLOAT;

            case 114: // D3DFMT_R32F
                return DXGI_FORMAT_R32_FLOAT;

            case 115: // D3DFMT_G32R32F
                return DXGI_FORMAT_R32G32_FLOAT;

            case 116: // D3DFMT_A32B32G32R32F
                return DXGI_FORMAT_R32G32B32A32_FLOAT;
            }
        }

        return DXGI_FORMAT_UNKNOWN;
    }


    //--------------------------------------------------------------------------------------
    DXGI_FORMAT MakeSRGB(_In_ DXGI_FORMAT format)
    {
        switch (format)
        {
        case DXGI_FORMAT_R8G8B8A8_UNORM:
            return DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;

        case DXGI_FORMAT_BC1_UNORM:
            return DXGI_FORMAT_BC1_UNORM_SRGB;

        case DXGI_FORMAT_BC2_UNORM:
            return DXGI_FORMAT_BC2_UNORM_SRGB;

        case DXGI_FORMAT_BC3_UNORM:
            return DXGI_FORMAT_BC3_UNORM_SRGB;

        case DXGI_FORMAT_B8G8R8A8_UNORM:
            return DXGI_FORMAT_B8G8R8A8_UNORM_SRGB;

        case DXGI_FORMAT_B8G8R8X8_UNORM:
            return DXGI_FORMAT_B8G8R8X8_UNORM_SRGB;

        case DXGI_FORMAT_BC7_UNORM:
            return DXGI_FORMAT_BC7_UNORM_SRGB;

        default:
            return format;
        }
    }


    //--------------------------------------------------------------------------------------
    HRESULT FillInitData(
        _In_ size_t width,
        _In_ size_t height,
        _In_ size_t depth,
        _In_ size_t mipCount,
        _In_ size_t arraySize,
        _In_ DXGI_FORMAT format,
        _In_ size_t maxsize,
        _In_ size_t bitSize,
        _In_reads_bytes_(bitSize) const uint8_t* bitData,
        _Out_ size_t& twidth,
        _Out_ size_t& theight,
        _Out_ size_t& tdepth,
        _Out_ size_t& skipMip,
        _Out_writes_(mipCount*arraySize) D3D11_SUBRESOURCE_DATA* initData)
    {
        if (!bitData || !initData)
        {
            return E_POINTER;
        }

        skipMip = 0;
        twidth = 0;
        theight = 0;
        tdepth = 0;

        size_t NumBytes = 0;
        size_t RowBytes = 0;
        const uint8_t* pSrcBits = bitData;
        const uint8_t* pEndBits = bitData + bitSize;

        size_t index = 0;
        for (size_t j = 0; j < arraySize; j++)
        {
            size_t w = width;
            size_t h = height;
            size_t d = depth;
            for (size_t i = 0; i < mipCount; i++)
            {
                HRESULT hr = GetSurfaceInfo(w, h, format, &NumBytes, &RowBytes, nullptr);
                if (FAILED(hr))
                    return hr;

                if (NumBytes > UINT32_MAX || RowBytes > UINT32_MAX)
                    return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

                if ((mipCount <= 1) || !maxsize || (w <= maxsize && h <= maxsize && d <= maxsize))
                {
                    if (!twidth)
                    {
                        twidth = w;
                        theight = h;
                        tdepth = d;
                    }

                    assert(index < mipCount * arraySize);
                    _Analysis_assume_(index < mipCount * arraySize);
                    initData[index].pSysMem = (const void*)pSrcBits;
                    initData[index].SysMemPitch = static_cast<UINT>(RowBytes);
                    initData[index].SysMemSlicePitch = static_cast<UINT>(NumBytes);
                    ++index;
                }
                else if (!j)
                {
                    // Count number of skipped mipmaps (first item only)
                    ++skipMip;
                }

                if (pSrcBits + (NumBytes*d) > pEndBits)
                {
                    return HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
                }

                pSrcBits += NumBytes * d;

                w = w >> 1;
                h = h >> 1;
                d = d >> 1;
                if (w == 0)
                {
                    w = 1;
                }
                if (h == 0)
                {
                    h = 1;
                }
                if (d == 0)
                {
                    d = 1;
                }
            }
        }

        return (index > 0) ? S_OK : E_FAIL;
    }


    //--------------------------------------------------------------------------------------
    HRESULT CreateD3DResources(
        _In_ ID3D11Device* d3dDevice,
        _In_ uint32_t resDim,
        _In_ size_t width,
        _In_ size_t height,
        _In_ size_t depth,
        _In_ size_t mipCount,
        _In_ size_t arraySize,
        _In_ DXGI_FORMAT format,
        _In_ D3D11_USAGE usage,
        _In_ unsigned int bindFlags,
        _In_ unsigned int cpuAccessFlags,
        _In_ unsigned int miscFlags,
        _In_ bool forceSRGB,
        _In_ bool isCubeMap,
        _In_reads_opt_(mipCount*arraySize) D3D11_SUBRESOURCE_DATA* initData,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView)
    {
        if (!d3dDevice)
            return E_POINTER;

        HRESULT hr = E_FAIL;

        if (forceSRGB)
        {
            format = MakeSRGB(format);
        }

        switch (resDim)
        {
        case D3D11_RESOURCE_DIMENSION_TEXTURE1D:
        {
            D3D11_TEXTURE1D_DESC desc;
            desc.Width = static_cast<UINT>(width);
            desc.MipLevels = static_cast<UINT>(mipCount);
            desc.ArraySize = static_cast<UINT>(arraySize);
            desc.Format = format;
            desc.Usage = usage;
            desc.BindFlags = bindFlags;
            desc.CPUAccessFlags = cpuAccessFlags;
            desc.MiscFlags = miscFlags & ~D3D11_RESOURCE_MISC_TEXTURECUBE;

            ID3D11Texture1D* tex = nullptr;
            hr = d3dDevice->CreateTexture1D(&desc,
                initData,
                &tex
            );
            if (SUCCEEDED(hr) && tex)
            {
                if (textureView)
                {
                    D3D11_SHADER_RESOURCE_VIEW_DESC SRVDesc = {};
                    SRVDesc.Format = format;

                    if (arraySize > 1)
                    {
                        SRVDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE1DARRAY;
                        SRVDesc.Texture1DArray.MipLevels = (!mipCount) ? -1 : desc.MipLevels;
                        SRVDesc.Texture1DArray.ArraySize = static_cast<UINT>(arraySize);
                    }
                    else
                    {
                        SRVDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE1D;
                        SRVDesc.Texture1D.MipLevels = (!mipCount) ? -1 : desc.MipLevels;
                    }

                    hr = d3dDevice->CreateShaderResourceView(tex,
                        &SRVDesc,
                        textureView
                    );
                    if (FAILED(hr))
                    {
                        tex->Release();
                        return hr;
                    }
                }

                if (texture)
                {
                    *texture = tex;
                }
                else
                {
                    SetDebugObjectName(tex, "DDSTextureLoader");
                    tex->Release();
                }
            }
        }
        break;

        case D3D11_RESOURCE_DIMENSION_TEXTURE2D:
        {
            D3D11_TEXTURE2D_DESC desc;
            desc.Width = static_cast<UINT>(width);
            desc.Height = static_cast<UINT>(height);
            desc.MipLevels = static_cast<UINT>(mipCount);
            desc.ArraySize = static_cast<UINT>(arraySize);
            desc.Format = format;
            desc.SampleDesc.Count = 1;
            desc.SampleDesc.Quality = 0;
            desc.Usage = usage;
            desc.BindFlags = bindFlags;
            desc.CPUAccessFlags = cpuAccessFlags;
            if (isCubeMap)
            {
                desc.MiscFlags = miscFlags | D3D11_RESOURCE_MISC_TEXTURECUBE;
            }
            else
            {
                desc.MiscFlags = miscFlags & ~D3D11_RESOURCE_MISC_TEXTURECUBE;
            }

            ID3D11Texture2D* tex = nullptr;
            hr = d3dDevice->CreateTexture2D(&desc,
                initData,
                &tex
            );
            if (SUCCEEDED(hr) && tex)
            {
                if (textureView)
                {
                    D3D11_SHADER_RESOURCE_VIEW_DESC SRVDesc = {};
                    SRVDesc.Format = format;

                    if (isCubeMap)
                    {
                        if (arraySize > 6)
                        {
                            SRVDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURECUBEARRAY;
                            SRVDesc.TextureCubeArray.MipLevels = (!mipCount) ? -1 : desc.MipLevels;

                            // Earlier we set arraySize to (Num_Cubess * 6)
                            SRVDesc.TextureCubeArray.NumCubes = static_cast<UINT>(arraySize / 6);
                        }
                        else
                        {
                            SRVDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURECUBE;
                            SRVDesc.TextureCube.MipLevels = (!mipCount) ? -1 : desc.MipLevels;
                        }
                    }
                    else if (arraySize > 1)
                    {
                        SRVDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2DARRAY;
                        SRVDesc.Texture2DArray.MipLevels = (!mipCount) ? -1 : desc.MipLevels;
                        SRVDesc.Texture2DArray.ArraySize = static_cast<UINT>(arraySize);
                    }
                    else
                    {
                        SRVDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
                        SRVDesc.Texture2D.MipLevels = (!mipCount) ? -1 : desc.MipLevels;
                    }

                    hr = d3dDevice->CreateShaderResourceView(tex,
                        &SRVDesc,
                        textureView
                    );
                    if (FAILED(hr))
                    {
                        tex->Release();
                        return hr;
                    }
                }

                if (texture)
                {
                    *texture = tex;
                }
                else
                {
                    SetDebugObjectName(tex, "DDSTextureLoader");
                    tex->Release();
                }
            }
        }
        break;

        case D3D11_RESOURCE_DIMENSION_TEXTURE3D:
        {
            D3D11_TEXTURE3D_DESC desc;
            desc.Width = static_cast<UINT>(width);
            desc.Height = static_cast<UINT>(height);
            desc.Depth = static_cast<UINT>(depth);
            desc.MipLevels = static_cast<UINT>(mipCount);
            desc.Format = format;
            desc.Usage = usage;
            desc.BindFlags = bindFlags;
            desc.CPUAccessFlags = cpuAccessFlags;
            desc.MiscFlags = miscFlags & ~D3D11_RESOURCE_MISC_TEXTURECUBE;

            ID3D11Texture3D* tex = nullptr;
            hr = d3dDevice->CreateTexture3D(&desc,
                initData,
                &tex
            );
            if (SUCCEEDED(hr) && tex)
            {
                if (textureView)
                {
                    D3D11_SHADER_RESOURCE_VIEW_DESC SRVDesc = {};
                    SRVDesc.Format = format;

                    SRVDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE3D;
                    SRVDesc.Texture3D.MipLevels = (!mipCount) ? -1 : desc.MipLevels;

                    hr = d3dDevice->CreateShaderResourceView(tex,
                        &SRVDesc,
                        textureView
                    );
                    if (FAILED(hr))
                    {
                        tex->Release();
                        return hr;
                    }
                }

                if (texture)
                {
                    *texture = tex;
                }
                else
                {
                    SetDebugObjectName(tex, "DDSTextureLoader");
                    tex->Release();
                }
            }
        }
        break;
        }

        return hr;
    }


    //--------------------------------------------------------------------------------------
    HRESULT CreateTextureFromDDS(
        _In_ ID3D11Device* d3dDevice,
        _In_opt_ ID3D11DeviceContext* d3dContext,
        _In_ const DDS_HEADER* header,
        _In_reads_bytes_(bitSize) const uint8_t* bitData,
        _In_ size_t bitSize,
        _In_ size_t maxsize,
        _In_ D3D11_USAGE usage,
        _In_ unsigned int bindFlags,
        _In_ unsigned int cpuAccessFlags,
        _In_ unsigned int miscFlags,
        _In_ bool forceSRGB,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView)
    {
        HRESULT hr = S_OK;

        UINT width = header->width;
        UINT height = header->height;
        UINT depth = header->depth;

        uint32_t resDim = D3D11_RESOURCE_DIMENSION_UNKNOWN;
        UINT arraySize = 1;
        DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN;
        bool isCubeMap = false;

        size_t mipCount = header->mipMapCount;
        if (0 == mipCount)
        {
            mipCount = 1;
        }

        if ((header->ddspf.flags & DDS_FOURCC) &&
            (MAKEFOURCC('D', 'X', '1', '0') == header->ddspf.fourCC))
        {
            auto d3d10ext = reinterpret_cast<const DDS_HEADER_DXT10*>((const char*)header + sizeof(DDS_HEADER));

            arraySize = d3d10ext->arraySize;
            if (arraySize == 0)
            {
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            switch (d3d10ext->dxgiFormat)
            {
            case DXGI_FORMAT_AI44:
            case DXGI_FORMAT_IA44:
            case DXGI_FORMAT_P8:
            case DXGI_FORMAT_A8P8:
                return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);

            default:
                if (BitsPerPixel(d3d10ext->dxgiFormat) == 0)
                {
                    return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
                }
            }

            format = d3d10ext->dxgiFormat;

            switch (d3d10ext->resourceDimension)
            {
            case D3D11_RESOURCE_DIMENSION_TEXTURE1D:
                // D3DX writes 1D textures with a fixed Height of 1
                if ((header->flags & DDS_HEIGHT) && height != 1)
                {
                    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }
                height = depth = 1;
                break;

            case D3D11_RESOURCE_DIMENSION_TEXTURE2D:
                if (d3d10ext->miscFlag & D3D11_RESOURCE_MISC_TEXTURECUBE)
                {
                    arraySize *= 6;
                    isCubeMap = true;
                }
                depth = 1;
                break;

            case D3D11_RESOURCE_DIMENSION_TEXTURE3D:
                if (!(header->flags & DDS_HEADER_FLAGS_VOLUME))
                {
                    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }

                if (arraySize > 1)
                {
                    return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
                }
                break;

            default:
                return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            }

            resDim = d3d10ext->resourceDimension;
        }
        else
        {
            format = GetDXGIFormat(header->ddspf);

            if (format == DXGI_FORMAT_UNKNOWN)
            {
                return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            }

            if (header->flags & DDS_HEADER_FLAGS_VOLUME)
            {
                resDim = D3D11_RESOURCE_DIMENSION_TEXTURE3D;
            }
            else
            {
                if (header->caps2 & DDS_CUBEMAP)
                {
                    // We require all six faces to be defined
                    if ((header->caps2 & DDS_CUBEMAP_ALLFACES) != DDS_CUBEMAP_ALLFACES)
                    {
                        return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
                    }

                    arraySize = 6;
                    isCubeMap = true;
                }

                depth = 1;
                resDim = D3D11_RESOURCE_DIMENSION_TEXTURE2D;

                // Note there's no way for a legacy Direct3D 9 DDS to express a '1D' texture
            }

            assert(BitsPerPixel(format) != 0);
        }

        // Bound sizes (for security purposes we don't trust DDS file metadata larger than the D3D 11.x hardware requirements)
        if (mipCount > D3D11_REQ_MIP_LEVELS)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        }

        switch (resDim)
        {
        case D3D11_RESOURCE_DIMENSION_TEXTURE1D:
            if ((arraySize > D3D11_REQ_TEXTURE1D_ARRAY_AXIS_DIMENSION) ||
                (width > D3D11_REQ_TEXTURE1D_U_DIMENSION))
            {
                return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            }
            break;

        case D3D11_RESOURCE_DIMENSION_TEXTURE2D:
            if (isCubeMap)
            {
                // This is the right bound because we set arraySize to (Num_Cubess*6) above
                if ((arraySize > D3D11_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION) ||
                    (width > D3D11_REQ_TEXTURECUBE_DIMENSION) ||
                    (height > D3D11_REQ_TEXTURECUBE_DIMENSION))
                {
                    return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
                }
            }
            else if ((arraySize > D3D11_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION) ||
                     (width > D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION) ||
                     (height > D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION))
            {
                return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            }
            break;

        case D3D11_RESOURCE_DIMENSION_TEXTURE3D:
            if ((arraySize > 1) ||
                (width > D3D11_REQ_TEXTURE3D_U_V_OR_W_DIMENSION) ||
                (height > D3D11_REQ_TEXTURE3D_U_V_OR_W_DIMENSION) ||
                (depth > D3D11_REQ_TEXTURE3D_U_V_OR_W_DIMENSION))
            {
                return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            }
            break;

        default:
            return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        }

        bool autogen = false;
        if (mipCount == 1 && d3dContext && textureView) // Must have context and shader-view to auto generate mipmaps
        {
            // See if format is supported for auto-gen mipmaps (varies by feature level)
            UINT fmtSupport = 0;
            hr = d3dDevice->CheckFormatSupport(format, &fmtSupport);
            if (SUCCEEDED(hr) && (fmtSupport & D3D11_FORMAT_SUPPORT_MIP_AUTOGEN))
            {
                // 10level9 feature levels do not support auto-gen mipgen for volume textures
                if ((resDim != D3D11_RESOURCE_DIMENSION_TEXTURE3D)
                    || (d3dDevice->GetFeatureLevel() >= D3D_FEATURE_LEVEL_10_0))
                {
                    autogen = true;
                }
            }
        }

        if (autogen)
        {
            // Create texture with auto-generated mipmaps
            ID3D11Resource* tex = nullptr;
            hr = CreateD3DResources(d3dDevice, resDim, width, height, depth, 0, arraySize,
                format, usage,
                bindFlags | D3D11_BIND_RENDER_TARGET,
                cpuAccessFlags,
                miscFlags | D3D11_RESOURCE_MISC_GENERATE_MIPS, forceSRGB,
                isCubeMap, nullptr, &tex, textureView);
            if (SUCCEEDED(hr))
            {
                size_t numBytes = 0;
                size_t rowBytes = 0;
                hr = GetSurfaceInfo(width, height, format, &numBytes, &rowBytes, nullptr);
                if (FAILED(hr))
                    return hr;

                if (numBytes > bitSize)
                {
                    (*textureView)->Release();
                    *textureView = nullptr;
                    tex->Release();
                    return HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
                }

                if (numBytes > UINT32_MAX || rowBytes > UINT32_MAX)
                    return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

                D3D11_SHADER_RESOURCE_VIEW_DESC desc;
                (*textureView)->GetDesc(&desc);

                UINT mipLevels = 1;

                switch (desc.ViewDimension)
                {
                case D3D_SRV_DIMENSION_TEXTURE1D:       mipLevels = desc.Texture1D.MipLevels; break;
                case D3D_SRV_DIMENSION_TEXTURE1DARRAY:  mipLevels = desc.Texture1DArray.MipLevels; break;
                case D3D_SRV_DIMENSION_TEXTURE2D:       mipLevels = desc.Texture2D.MipLevels; break;
                case D3D_SRV_DIMENSION_TEXTURE2DARRAY:  mipLevels = desc.Texture2DArray.MipLevels; break;
                case D3D_SRV_DIMENSION_TEXTURECUBE:     mipLevels = desc.TextureCube.MipLevels; break;
                case D3D_SRV_DIMENSION_TEXTURECUBEARRAY:mipLevels = desc.TextureCubeArray.MipLevels; break;
                case D3D_SRV_DIMENSION_TEXTURE3D:       mipLevels = desc.Texture3D.MipLevels; break;
                default:
                    (*textureView)->Release();
                    *textureView = nullptr;
                    tex->Release();
                    return E_UNEXPECTED;
                }

                if (arraySize > 1)
                {
                    const uint8_t* pSrcBits = bitData;
                    const uint8_t* pEndBits = bitData + bitSize;
                    for (UINT item = 0; item < arraySize; ++item)
                    {
                        if ((pSrcBits + numBytes) > pEndBits)
                        {
                            (*textureView)->Release();
                            *textureView = nullptr;
                            tex->Release();
                            return HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
                        }

                        UINT res = D3D11CalcSubresource(0, item, mipLevels);
                        d3dContext->UpdateSubresource(tex, res, nullptr, pSrcBits, static_cast<UINT>(rowBytes), static_cast<UINT>(numBytes));
                        pSrcBits += numBytes;
                    }
                }
                else
                {
                    d3dContext->UpdateSubresource(tex, 0, nullptr, bitData, static_cast<UINT>(rowBytes), static_cast<UINT>(numBytes));
                }

                d3dContext->GenerateMips(*textureView);

                if (texture)
                {
                    *texture = tex;
                }
                else
                {
                    tex->Release();
                }
            }
        }
        else
        {
            // Create the texture
            std::unique_ptr<D3D11_SUBRESOURCE_DATA[]> initData(new (std::nothrow) D3D11_SUBRESOURCE_DATA[mipCount * arraySize]);
            if (!initData)
            {
                return E_OUTOFMEMORY;
            }

            size_t skipMip = 0;
            size_t twidth = 0;
            size_t theight = 0;
            size_t tdepth = 0;
            hr = FillInitData(width, height, depth, mipCount, arraySize, format, maxsize, bitSize, bitData,
                twidth, theight, tdepth, skipMip, initData.get());

            if (SUCCEEDED(hr))
            {
                hr = CreateD3DResources(d3dDevice, resDim, twidth, theight, tdepth, mipCount - skipMip, arraySize,
                    format, usage, bindFlags, cpuAccessFlags, miscFlags, forceSRGB,
                    isCubeMap, initData.get(), texture, textureView);

                if (FAILED(hr) && !maxsize && (mipCount > 1))
                {
                    // Retry with a maxsize determined by feature level
                    switch (d3dDevice->GetFeatureLevel())
                    {
                    case D3D_FEATURE_LEVEL_9_1:
                    case D3D_FEATURE_LEVEL_9_2:
                        if (isCubeMap)
                        {
                            maxsize = 512 /*D3D_FL9_1_REQ_TEXTURECUBE_DIMENSION*/;
                        }
                        else
                        {
                            maxsize = (resDim == D3D11_RESOURCE_DIMENSION_TEXTURE3D)
                                ? 256 /*D3D_FL9_1_REQ_TEXTURE3D_U_V_OR_W_DIMENSION*/
                                : 2048 /*D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION*/;
                        }
                        break;

                    case D3D_FEATURE_LEVEL_9_3:
                        maxsize = (resDim == D3D11_RESOURCE_DIMENSION_TEXTURE3D)
                            ? 256 /*D3D_FL9_1_REQ_TEXTURE3D_U_V_OR_W_DIMENSION*/
                            : 4096 /*D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION*/;
                        break;

                    default: // D3D_FEATURE_LEVEL_10_0 & D3D_FEATURE_LEVEL_10_1
                        maxsize = (resDim == D3D11_RESOURCE_DIMENSION_TEXTURE3D)
                            ? 2048 /*D3D10_REQ_TEXTURE3D_U_V_OR_W_DIMENSION*/
                            : 8192 /*D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION*/;
                        break;
                    }

                    hr = FillInitData(width, height, depth, mipCount, arraySize, format, maxsize, bitSize, bitData,
                        twidth, theight, tdepth, skipMip, initData.get());
                    if (SUCCEEDED(hr))
                    {
                        hr = CreateD3DResources(d3dDevice, resDim, twidth, theight, tdepth, mipCount - skipMip, arraySize,
                            format, usage, bindFlags, cpuAccessFlags, miscFlags, forceSRGB,
                            isCubeMap, initData.get(), texture, textureView);
                    }
                }
            }
        }

        return hr;
    }


    //--------------------------------------------------------------------------------------
    DDS_ALPHA_MODE GetAlphaMode(_In_ const DDS_HEADER* header)
    {
        if (header->ddspf.flags & DDS_FOURCC)
        {
            if (MAKEFOURCC('D', 'X', '1', '0') == header->ddspf.fourCC)
            {
                auto d3d10ext = reinterpret_cast<const DDS_HEADER_DXT10*>((const char*)header + sizeof(DDS_HEADER));
                auto mode = static_cast<DDS_ALPHA_MODE>(d3d10ext->miscFlags2 & DDS_MISC_FLAGS2_ALPHA_MODE_MASK);
                switch (mode)
                {
                case DDS_ALPHA_MODE_STRAIGHT:
                case DDS_ALPHA_MODE_PREMULTIPLIED:
                case DDS_ALPHA_MODE_OPAQUE:
                case DDS_ALPHA_MODE_CUSTOM:
                    return mode;
                }
            }
            else if ((MAKEFOURCC('D', 'X', 'T', '2') == header->ddspf.fourCC)
                || (MAKEFOURCC('D', 'X', 'T', '4') == header->ddspf.fourCC))
            {
                return DDS_ALPHA_MODE_PREMULTIPLIED;
            }
        }

        return DDS_ALPHA_MODE_UNKNOWN;
    }
} // anonymous namespace

//--------------------------------------------------------------------------------------
_Use_decl_annotations_
HRESULT DirectX::CreateDDSTextureFromMemory(ID3D11Device* d3dDevice,
    const uint8_t* ddsData,
    size_t ddsDataSize,
    ID3D11Resource** texture,
    ID3D11ShaderResourceView** textureView,
    size_t maxsize,
    DDS_ALPHA_MODE* alphaMode)
{
    return CreateDDSTextureFromMemoryEx(d3dDevice, nullptr, ddsData, ddsDataSize, maxsize,
        D3D11_USAGE_DEFAULT, D3D11_BIND_SHADER_RESOURCE, 0, 0, false,
        texture, textureView, alphaMode);
}

_Use_decl_annotations_
HRESULT DirectX::CreateDDSTextureFromMemory(ID3D11Device* d3dDevice,
    ID3D11DeviceContext* d3dContext,
    const uint8_t* ddsData,
    size_t ddsDataSize,
    ID3D11Resource** texture,
    ID3D11ShaderResourceView** textureView,
    size_t maxsize,
    DDS_ALPHA_MODE* alphaMode)
{
    return CreateDDSTextureFromMemoryEx(d3dDevice, d3dContext, ddsData, ddsDataSize, maxsize,
        D3D11_USAGE_DEFAULT, D3D11_BIND_SHADER_RESOURCE, 0, 0, false,
        texture, textureView, alphaMode);
}

_Use_decl_annotations_
HRESULT DirectX::CreateDDSTextureFromMemoryEx(ID3D11Device* d3dDevice,
    const uint8_t* ddsData,
    size_t ddsDataSize,
    size_t maxsize,
    D3D11_USAGE usage,
    unsigned int bindFlags,
    unsigned int cpuAccessFlags,
    unsigned int miscFlags,
    bool forceSRGB,
    ID3D11Resource** texture,
    ID3D11ShaderResourceView** textureView,
    DDS_ALPHA_MODE* alphaMode)
{
    return CreateDDSTextureFromMemoryEx(d3dDevice, nullptr, ddsData, ddsDataSize, maxsize,
        usage, bindFlags, cpuAccessFlags, miscFlags, forceSRGB,
        texture, textureView, alphaMode);
}

_Use_decl_annotations_
HRESULT DirectX::CreateDDSTextureFromMemoryEx(ID3D11Device* d3dDevice,
    ID3D11DeviceContext* d3dContext,
    const uint8_t* ddsData,
    size_t ddsDataSize,
    size_t maxsize,
    D3D11_USAGE usage,
    unsigned int bindFlags,
    unsigned int cpuAccessFlags,
    unsigned int miscFlags,
    bool forceSRGB,
    ID3D11Resource** texture,
    ID3D11ShaderResourceView** textureView,
    DDS_ALPHA_MODE* alphaMode)
{
    if (texture)
    {
        *texture = nullptr;
    }
    if (textureView)
    {
        *textureView = nullptr;
    }
    if (alphaMode)
    {
        *alphaMode = DDS_ALPHA_MODE_UNKNOWN;
    }

    if (!d3dDevice || !ddsData || (!texture && !textureView))
    {
        return E_INVALIDARG;
    }

    // Validate DDS file in memory
    if (ddsDataSize < (sizeof(uint32_t) + sizeof(DDS_HEADER)))
    {
        return E_FAIL;
    }

    uint32_t dwMagicNumber = *(const uint32_t*)(ddsData);
    if (dwMagicNumber != DDS_MAGIC)
    {
        return E_FAIL;
    }

    auto header = reinterpret_cast<const DDS_HEADER*>(ddsData + sizeof(uint32_t));

    // Verify header to validate DDS file
    if (header->size != sizeof(DDS_HEADER) ||
        header->ddspf.size != sizeof(DDS_PIXELFORMAT))
    {
        return E_FAIL;
    }

    // Check for DX10 extension
    bool bDXT10Header = false;
    if ((header->ddspf.flags & DDS_FOURCC) &&
        (MAKEFOURCC('D', 'X', '1', '0') == header->ddspf.fourCC))
    {
        // Must be long enough for both headers and magic value
        if (ddsDataSize < (sizeof(DDS_HEADER) + sizeof(uint32_t) + sizeof(DDS_HEADER_DXT10)))
        {
            return E_FAIL;
        }

        bDXT10Header = true;
    }

    ptrdiff_t offset = sizeof(uint32_t)
        + sizeof(DDS_HEADER)
        + (bDXT10Header ? sizeof(DDS_HEADER_DXT10) : 0);

    HRESULT hr = CreateTextureFromDDS(d3dDevice, d3dContext, header,
        ddsData + offset, ddsDataSize - offset, maxsize,
        usage, bindFlags, cpuAccessFlags, miscFlags, forceSRGB,
        texture, textureView);
    if (SUCCEEDED(hr))
    {
        if (texture && *texture)
        {
            SetDebugObjectName(*texture, "DDSTextureLoader");
        }

        if (textureView && *textureView)
        {
            SetDebugObjectName(*textureView, "DDSTextureLoader");
        }

        if (alphaMode)
            *alphaMode = GetAlphaMode(header);
    }

    return hr;
}

//--------------------------------------------------------------------------------------
_Use_decl_annotations_
HRESULT DirectX::CreateDDSTextureFromFile(ID3D11Device* d3dDevice,
    const wchar_t* fileName,
    ID3D11Resource** texture,
    ID3D11ShaderResourceView** textureView,
    size_t maxsize,
    DDS_ALPHA_MODE* alphaMode)
{
    return CreateDDSTextureFromFileEx(d3dDevice, nullptr, fileName, maxsize,
        D3D11_USAGE_DEFAULT, D3D11_BIND_SHADER_RESOURCE, 0, 0, false,
        texture, textureView, alphaMode);
}

_Use_decl_annotations_
HRESULT DirectX::CreateDDSTextureFromFile(ID3D11Device* d3dDevice,
    ID3D11DeviceContext* d3dContext,
    const wchar_t* fileName,
    ID3D11Resource** texture,
    ID3D11ShaderResourceView** textureView,
    size_t maxsize,
    DDS_ALPHA_MODE* alphaMode)
{
    return CreateDDSTextureFromFileEx(d3dDevice, d3dContext, fileName, maxsize,
        D3D11_USAGE_DEFAULT, D3D11_BIND_SHADER_RESOURCE, 0, 0, false,
        texture, textureView, alphaMode);
}

_Use_decl_annotations_
HRESULT DirectX::CreateDDSTextureFromFileEx(ID3D11Device* d3dDevice,
    const wchar_t* fileName,
    size_t maxsize,
    D3D11_USAGE usage,
    unsigned int bindFlags,
    unsigned int cpuAccessFlags,
    unsigned int miscFlags,
    bool forceSRGB,
    ID3D11Resource** texture,
    ID3D11ShaderResourceView** textureView,
    DDS_ALPHA_MODE* alphaMode)
{
    return CreateDDSTextureFromFileEx(d3dDevice, nullptr, fileName, maxsize,
        usage, bindFlags, cpuAccessFlags, miscFlags, forceSRGB,
        texture, textureView, alphaMode);
}

_Use_decl_annotations_
HRESULT DirectX::CreateDDSTextureFromFileEx(ID3D11Device* d3dDevice,
    ID3D11DeviceContext* d3dContext,
    const wchar_t* fileName,
    size_t maxsize,
    D3D11_USAGE usage,
    unsigned int bindFlags,
    unsigned int cpuAccessFlags,
    unsigned int miscFlags,
    bool forceSRGB,
    ID3D11Resource** texture,
    ID3D11ShaderResourceView** textureView,
    DDS_ALPHA_MODE* alphaMode)
{
    if (texture)
    {
        *texture = nullptr;
    }
    if (textureView)
    {
        *textureView = nullptr;
    }
    if (alphaMode)
    {
        *alphaMode = DDS_ALPHA_MODE_UNKNOWN;
    }

    if (!d3dDevice || !fileName || (!texture && !textureView))
    {
        return E_INVALIDARG;
    }

    const DDS_HEADER* header = nullptr;
    const uint8_t* bitData = nullptr;
    size_t bitSize = 0;

    std::unique_ptr<uint8_t[]> ddsData;
    HRESULT hr = LoadTextureDataFromFile(fileName,
        ddsData,
        &header,
        &bitData,
        &bitSize
    );
    if (FAILED(hr))
    {
        return hr;
    }

    hr = CreateTextureFromDDS(d3dDevice, d3dContext, header,
        bitData, bitSize, maxsize,
        usage, bindFlags, cpuAccessFlags, miscFlags, forceSRGB,
        texture, textureView);

    if (SUCCEEDED(hr))
    {
#if !defined(NO_D3D11_DEBUG_NAME) && ( defined(_DEBUG) || defined(PROFILE) )
        if (texture || textureView)
        {
            CHAR strFileA[MAX_PATH];
            int result = WideCharToMultiByte(CP_UTF8,
                WC_NO_BEST_FIT_CHARS,
                fileName,
                -1,
                strFileA,
                MAX_PATH,
                nullptr,
                FALSE
            );
            if (result > 0)
            {
                const CHAR* pstrName = strrchr(strFileA, '\\');
                if (!pstrName)
                {
                    pstrName = strFileA;
                }
                else
                {
                    pstrName++;
                }

                if (texture && *texture)
                {
                    (*texture)->SetPrivateData(WKPDID_D3DDebugObjectName,
                        static_cast<UINT>(strnlen_s(pstrName, MAX_PATH)),
                        pstrName
                    );
                }

                if (textureView && *textureView)
                {
                    (*textureView)->SetPrivateData(WKPDID_D3DDebugObjectName,
                        static_cast<UINT>(strnlen_s(pstrName, MAX_PATH)),
                        pstrName
                    );
                }
            }
        }
#endif

        if (alphaMode)
            *alphaMode = GetAlphaMode(header);
    }

    return hr;
}

```

`Direct3D11-Source/DDSTextureLoader.h`:

```h
//--------------------------------------------------------------------------------------
// File: DDSTextureLoader.h
//
// Functions for loading a DDS texture and creating a Direct3D runtime resource for it
//
// Note these functions are useful as a light-weight runtime loader for DDS files. For
// a full-featured DDS file reader, writer, and texture processing pipeline see
// the 'Texconv' sample and the 'DirectXTex' library.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
// http://go.microsoft.com/fwlink/?LinkId=248926
// http://go.microsoft.com/fwlink/?LinkId=248929
//--------------------------------------------------------------------------------------

#pragma once

#include <d3d11_1.h>
#include <stdint.h>


namespace DirectX
{
    enum DDS_ALPHA_MODE
    {
        DDS_ALPHA_MODE_UNKNOWN       = 0,
        DDS_ALPHA_MODE_STRAIGHT      = 1,
        DDS_ALPHA_MODE_PREMULTIPLIED = 2,
        DDS_ALPHA_MODE_OPAQUE        = 3,
        DDS_ALPHA_MODE_CUSTOM        = 4,
    };

    // Standard version
    HRESULT CreateDDSTextureFromMemory(
        _In_ ID3D11Device* d3dDevice,
        _In_reads_bytes_(ddsDataSize) const uint8_t* ddsData,
        _In_ size_t ddsDataSize,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView,
        _In_ size_t maxsize = 0,
        _Out_opt_ DDS_ALPHA_MODE* alphaMode = nullptr);

    HRESULT CreateDDSTextureFromFile(
        _In_ ID3D11Device* d3dDevice,
        _In_z_ const wchar_t* szFileName,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView,
        _In_ size_t maxsize = 0,
        _Out_opt_ DDS_ALPHA_MODE* alphaMode = nullptr);

    // Standard version with optional auto-gen mipmap support
    HRESULT CreateDDSTextureFromMemory(
        _In_ ID3D11Device* d3dDevice,
        _In_opt_ ID3D11DeviceContext* d3dContext,
        _In_reads_bytes_(ddsDataSize) const uint8_t* ddsData,
        _In_ size_t ddsDataSize,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView,
        _In_ size_t maxsize = 0,
        _Out_opt_ DDS_ALPHA_MODE* alphaMode = nullptr);

    HRESULT CreateDDSTextureFromFile(
        _In_ ID3D11Device* d3dDevice,
        _In_opt_ ID3D11DeviceContext* d3dContext,
        _In_z_ const wchar_t* szFileName,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView,
        _In_ size_t maxsize = 0,
        _Out_opt_ DDS_ALPHA_MODE* alphaMode = nullptr);

    // Extended version
    HRESULT CreateDDSTextureFromMemoryEx(
        _In_ ID3D11Device* d3dDevice,
        _In_reads_bytes_(ddsDataSize) const uint8_t* ddsData,
        _In_ size_t ddsDataSize,
        _In_ size_t maxsize,
        _In_ D3D11_USAGE usage,
        _In_ unsigned int bindFlags,
        _In_ unsigned int cpuAccessFlags,
        _In_ unsigned int miscFlags,
        _In_ bool forceSRGB,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView,
        _Out_opt_ DDS_ALPHA_MODE* alphaMode = nullptr);

    HRESULT CreateDDSTextureFromFileEx(
        _In_ ID3D11Device* d3dDevice,
        _In_z_ const wchar_t* szFileName,
        _In_ size_t maxsize,
        _In_ D3D11_USAGE usage,
        _In_ unsigned int bindFlags,
        _In_ unsigned int cpuAccessFlags,
        _In_ unsigned int miscFlags,
        _In_ bool forceSRGB,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView,
        _Out_opt_ DDS_ALPHA_MODE* alphaMode = nullptr);

    // Extended version with optional auto-gen mipmap support
    HRESULT CreateDDSTextureFromMemoryEx(
        _In_ ID3D11Device* d3dDevice,
        _In_opt_ ID3D11DeviceContext* d3dContext,
        _In_reads_bytes_(ddsDataSize) const uint8_t* ddsData,
        _In_ size_t ddsDataSize,
        _In_ size_t maxsize,
        _In_ D3D11_USAGE usage,
        _In_ unsigned int bindFlags,
        _In_ unsigned int cpuAccessFlags,
        _In_ unsigned int miscFlags,
        _In_ bool forceSRGB,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView,
        _Out_opt_ DDS_ALPHA_MODE* alphaMode = nullptr);

    HRESULT CreateDDSTextureFromFileEx(
        _In_ ID3D11Device* d3dDevice,
        _In_opt_ ID3D11DeviceContext* d3dContext,
        _In_z_ const wchar_t* szFileName,
        _In_ size_t maxsize,
        _In_ D3D11_USAGE usage,
        _In_ unsigned int bindFlags,
        _In_ unsigned int cpuAccessFlags,
        _In_ unsigned int miscFlags,
        _In_ bool forceSRGB,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView,
        _Out_opt_ DDS_ALPHA_MODE* alphaMode = nullptr);
}
```

`Direct3D11-Source/DXTrace.cpp`:

```cpp
#include "DXTrace.h"
#include <cstdio>

HRESULT WINAPI DXTraceW(_In_z_ const WCHAR* strFile, _In_ DWORD dwLine, _In_ HRESULT hr,
	_In_opt_ const WCHAR* strMsg, _In_ bool bPopMsgBox)
{
	WCHAR strBufferFile[MAX_PATH];
	WCHAR strBufferLine[128];
	WCHAR strBufferError[300];
	WCHAR strBufferMsg[1024];
	WCHAR strBufferHR[40];
	WCHAR strBuffer[3000];

	swprintf_s(strBufferLine, 128, L"%lu", dwLine);
	if (strFile)
	{
		swprintf_s(strBuffer, 3000, L"%ls(%ls): ", strFile, strBufferLine);
		OutputDebugStringW(strBuffer);
	}

	size_t nMsgLen = (strMsg) ? wcsnlen_s(strMsg, 1024) : 0;
	if (nMsgLen > 0)
	{
		OutputDebugStringW(strMsg);
		OutputDebugStringW(L" ");
	}
	// Windows SDK 8.0起DirectX的错误信息已经集成进错误码中，可以通过FormatMessageW获取错误信息字符串
	// 不需要分配字符串内存
	FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
		nullptr, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		strBufferError, 256, nullptr);

	WCHAR* errorStr = wcsrchr(strBufferError, L'\r');
	if (errorStr)
	{
		errorStr[0] = L'\0';	// 擦除FormatMessageW带来的换行符(把\r\n的\r置换为\0即可)
	}

	swprintf_s(strBufferHR, 40, L" (0x%0.8x)", hr);
	wcscat_s(strBufferError, strBufferHR);
	swprintf_s(strBuffer, 3000, L"错误码含义：%ls", strBufferError);
	OutputDebugStringW(strBuffer);

	OutputDebugStringW(L"\n");

	if (bPopMsgBox)
	{
		wcscpy_s(strBufferFile, MAX_PATH, L"");
		if (strFile)
			wcscpy_s(strBufferFile, MAX_PATH, strFile);

		wcscpy_s(strBufferMsg, 1024, L"");
		if (nMsgLen > 0)
			swprintf_s(strBufferMsg, 1024, L"当前调用：%ls\n", strMsg);

		swprintf_s(strBuffer, 3000, L"文件名：%ls\n行号：%ls\n错误码含义：%ls\n%ls您需要调试当前应用程序吗？",
			strBufferFile, strBufferLine, strBufferError, strBufferMsg);

		int nResult = MessageBoxW(GetForegroundWindow(), strBuffer, L"错误", MB_YESNO | MB_ICONERROR);
		if (nResult == IDYES)
			DebugBreak();
	}

	return hr;
}
```

`Direct3D11-Source/DXTrace.h`:

```h
//***************************************************************************************
// DXTrace.h by X_Jun(MKXJun) (C) 2018-2019 All Rights Reserved.
// Licensed under the MIT License.
//
// DirectX错误追踪 
// DirectX Error Tracing. 
//***************************************************************************************

#ifndef DXTRACE_H
#define DXTRACE_H

#include <Windows.h>

// ------------------------------
// DXTraceW函数
// ------------------------------
// 在调试输出窗口中输出格式化错误信息，可选的错误窗口弹出(已汉化)
// [In]strFile			当前文件名，通常传递宏__FILEW__
// [In]hlslFileName     当前行号，通常传递宏__LINE__
// [In]hr				函数执行出现问题时返回的HRESULT值
// [In]strMsg			用于帮助调试定位的字符串，通常传递L#x(可能为NULL)
// [In]bPopMsgBox       如果为TRUE，则弹出一个消息弹窗告知错误信息
// 返回值: 形参hr
HRESULT WINAPI DXTraceW(_In_z_ const WCHAR* strFile, _In_ DWORD dwLine, _In_ HRESULT hr, _In_opt_ const WCHAR* strMsg, _In_ bool bPopMsgBox);


// ------------------------------
// HR宏
// ------------------------------
// Debug模式下的错误提醒与追踪
#if defined(DEBUG) | defined(_DEBUG)
	#ifndef HR
	#define HR(x)												\
	{															\
		HRESULT hr = (x);										\
		if(FAILED(hr))											\
		{														\
			DXTraceW(__FILEW__, (DWORD)__LINE__, hr, L#x, true);\
		}														\
	}
	#endif
#else
	#ifndef HR
	#define HR(x) (x)
	#endif 
#endif



#endif

```

`Direct3D11-Source/EffectHelper.h`:

```h
//***************************************************************************************
// EffectsHelper.h by X_Jun(MKXJun) (C) 2018-2019 All Rights Reserved.
// Licensed under the MIT License.
//
// 定义一些实用的特效类
// Define utility effect classes.
//***************************************************************************************

//
// 该头文件需要在包含特效类实现的源文件中使用，且必须晚于Effects.h和d3dUtil.h包含
// 

#ifndef EFFECTHELPER_H
#define EFFECTHELPER_H


// 若类需要内存对齐，从该类派生
template<class DerivedType>
struct AlignedType
{
	static void* operator new(size_t size)
	{
		const size_t alignedSize = __alignof(DerivedType);

		static_assert(alignedSize > 8, "AlignedNew is only useful for types with > 8 byte alignment! Did you forget a __declspec(align) on DerivedType?");

		void* ptr = _aligned_malloc(size, alignedSize);

		if (!ptr)
			throw std::bad_alloc();

		return ptr;
	}

	static void operator delete(void * ptr)
	{
		_aligned_free(ptr);
	}
};

struct CBufferBase
{
	template<class T>
	using ComPtr = Microsoft::WRL::ComPtr<T>;

	bool isDirty;
	ComPtr<ID3D11Buffer> cBuffer;

	virtual void CreateBuffer(ComPtr<ID3D11Device> device) = 0;
	virtual void UpdateBuffer(ComPtr<ID3D11DeviceContext> deviceContext) = 0;
	virtual void BindVS(ComPtr<ID3D11DeviceContext> deviceContext) = 0;
	virtual void BindHS(ComPtr<ID3D11DeviceContext> deviceContext) = 0;
	virtual void BindDS(ComPtr<ID3D11DeviceContext> deviceContext) = 0;
	virtual void BindGS(ComPtr<ID3D11DeviceContext> deviceContext) = 0;
	virtual void BindCS(ComPtr<ID3D11DeviceContext> deviceContext) = 0;
	virtual void BindPS(ComPtr<ID3D11DeviceContext> deviceContext) = 0;
};

template<UINT startSlot, class T>
struct CBufferObject : CBufferBase
{
	T data;

	void CreateBuffer(ComPtr<ID3D11Device> device) override
	{
		if (cBuffer != nullptr)
			return;
		D3D11_BUFFER_DESC cbd;
		ZeroMemory(&cbd, sizeof(cbd));
		cbd.Usage = D3D11_USAGE_DEFAULT;
		cbd.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
		cbd.CPUAccessFlags = 0;
		cbd.ByteWidth = sizeof(T);
		HR(device->CreateBuffer(&cbd, nullptr, cBuffer.GetAddressOf()));
	}

	void UpdateBuffer(ComPtr<ID3D11DeviceContext> deviceContext) override
	{
		if (isDirty)
		{
			isDirty = false;
			deviceContext->UpdateSubresource(cBuffer.Get(), 0, nullptr, &data, 0, 0);
		}
	}

	void BindVS(ComPtr<ID3D11DeviceContext> deviceContext) override
	{
		deviceContext->VSSetConstantBuffers(startSlot, 1, cBuffer.GetAddressOf());
	}

	void BindHS(ComPtr<ID3D11DeviceContext> deviceContext) override
	{
		deviceContext->HSSetConstantBuffers(startSlot, 1, cBuffer.GetAddressOf());
	}

	void BindDS(ComPtr<ID3D11DeviceContext> deviceContext) override
	{
		deviceContext->DSSetConstantBuffers(startSlot, 1, cBuffer.GetAddressOf());
	}

	void BindGS(ComPtr<ID3D11DeviceContext> deviceContext) override
	{
		deviceContext->GSSetConstantBuffers(startSlot, 1, cBuffer.GetAddressOf());
	}

	void BindCS(ComPtr<ID3D11DeviceContext> deviceContext) override
	{
		deviceContext->CSSetConstantBuffers(startSlot, 1, cBuffer.GetAddressOf());
	}

	void BindPS(ComPtr<ID3D11DeviceContext> deviceContext) override
	{
		deviceContext->PSSetConstantBuffers(startSlot, 1, cBuffer.GetAddressOf());
	}
};



#endif
```

`Direct3D11-Source/Effects.h`:

```h
//***************************************************************************************
// Effects.h by X_Jun(MKXJun) (C) 2018-2019 All Rights Reserved.
// Licensed under the MIT License.
//
// 简易特效管理框架
// Simple effect management framework.
//***************************************************************************************

#ifndef EFFECTS_H
#define EFFECTS_H

#include <memory>
#include <wrl/client.h>
#include <DirectXMath.h>
#include <d3d11_1.h>


class IEffect
{
public:
	// 使用模板别名(C++11)简化类型名
	template <class T>
	using ComPtr = Microsoft::WRL::ComPtr<T>;

	IEffect() = default;

	// 不支持复制构造
	IEffect(const IEffect&) = delete;
	IEffect& operator=(const IEffect&) = delete;

	// 允许转移
	IEffect(IEffect&& moveFrom) = default;
	IEffect& operator=(IEffect&& moveFrom) = default;

	virtual ~IEffect() = default;

	// 更新并绑定常量缓冲区
	virtual void Apply(ComPtr<ID3D11DeviceContext> deviceContext) = 0;
};


class BasicEffect : public IEffect
{
public:

	BasicEffect();
	virtual ~BasicEffect() override;

	BasicEffect(BasicEffect&& moveFrom);
	BasicEffect& operator=(BasicEffect&& moveFrom);

	// 获取单例
	static BasicEffect& Get();

	

	// 初始化Basic.hlsli所需资源并初始化渲染状态
	bool InitAll(ComPtr<ID3D11Device> device);


	//
	// 渲染模式的变更
	//

	// 默认状态来绘制
	void SetRenderDefault(ComPtr<ID3D11DeviceContext> deviceContext);


	

	//
	// 矩阵设置
	//

	void XM_CALLCONV SetWorldMatrix(DirectX::FXMMATRIX W);
	void XM_CALLCONV SetViewMatrix(DirectX::FXMMATRIX V);
	void XM_CALLCONV SetProjMatrix(DirectX::FXMMATRIX P);
	void XM_CALLCONV SetWorldViewProjMatrix(DirectX::FXMMATRIX W, DirectX::CXMMATRIX V, DirectX::CXMMATRIX P);

	
	//
	// 纹理相关设置
	//

	void SetTextureArray(ComPtr<ID3D11ShaderResourceView> textureArray);
	void SetTexIndex(int index);

	// 应用常量缓冲区和纹理资源的变更
	void Apply(ComPtr<ID3D11DeviceContext> deviceContext);
	
private:
	class Impl;
	std::unique_ptr<Impl> pImpl;
};










#endif
```

`Direct3D11-Source/GameApp.cpp`:

```cpp
#include "GameApp.h"
#include "d3dUtil.h"
using namespace DirectX;

GameApp::GameApp(HINSTANCE hInstance)
	: D3DApp(hInstance)
{
}

GameApp::~GameApp()
{
}

bool GameApp::Init()
{
	if (!D3DApp::Init())
		return false;

	if (!mBasicEffect.InitAll(md3dDevice))
		return false;

	if (!InitResource())
		return false;

	// 初始化鼠标，键盘不需要
	mMouse->SetWindow(mhMainWnd);
	mMouse->SetMode(DirectX::Mouse::MODE_ABSOLUTE);

	// 初始化滑动延迟时间和点击位置
	mSlideDelay = 0.05f;
	mClickPosX = mClickPosY = -1;
	// 初始化计时器
	mGameTimer.Reset();
	mGameTimer.Stop();
	// 初始化游戏状态
	mGameStatus = GameStatus::Preparing;
	mCurrRotationRecord.dTheta = 0.0f;
	return true;
}

void GameApp::OnResize()
{
	assert(md2dFactory);
	assert(mdwriteFactory);
	// 释放D2D的相关资源
	mColorBrush.Reset();
	md2dRenderTarget.Reset();

	D3DApp::OnResize();

	// 为D2D创建DXGI表面渲染目标
	ComPtr<IDXGISurface> surface;
	HR(mSwapChain->GetBuffer(0, __uuidof(IDXGISurface), reinterpret_cast<void**>(surface.GetAddressOf())));
	D2D1_RENDER_TARGET_PROPERTIES props = D2D1::RenderTargetProperties(
		D2D1_RENDER_TARGET_TYPE_DEFAULT,
		D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED));
	HRESULT hr = md2dFactory->CreateDxgiSurfaceRenderTarget(surface.Get(), &props, md2dRenderTarget.GetAddressOf());
	surface.Reset();

	if (hr == E_NOINTERFACE)
	{
		OutputDebugString(L"\n警告：Direct2D与Direct3D互操作性功能受限，你将无法看到文本信息。现提供下述可选方法：\n"
			"1. 对于Win7系统，需要更新至Win7 SP1，并安装KB2670838补丁以支持Direct2D显示。\n"
			"2. 自行完成Direct3D 10.1与Direct2D的交互。详情参阅："
			"https://docs.microsoft.com/zh-cn/windows/desktop/Direct2D/direct2d-and-direct3d-interoperation-overview""\n"
			"3. 使用别的字体库，比如FreeType。\n\n");
	}
	else if (hr == S_OK)
	{
		// 创建固定颜色刷和文本格式
		HR(md2dRenderTarget->CreateSolidColorBrush(
			D2D1::ColorF(D2D1::ColorF::White),
			mColorBrush.GetAddressOf()));
		HR(mdwriteFactory->CreateTextFormat(L"宋体", nullptr, DWRITE_FONT_WEIGHT_NORMAL,
			DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL, 20, L"zh-cn",
			mTextFormat.GetAddressOf()));
	}
	else
	{
		// 报告异常问题
		assert(md2dRenderTarget);
	}

	// 摄像机变更显示
	if (mCamera != nullptr)
	{
		mCamera->SetFrustum(XM_PI * 0.4f, AspectRatio(), 1.0f, 1000.0f);
		mCamera->SetViewPort(0.0f, 0.0f, (float)mClientWidth, (float)mClientHeight);
		mBasicEffect.SetProjMatrix(mCamera->GetProjXM());
	}
}

void GameApp::UpdateScene(float dt)
{
	// 键鼠更新
	if (mGameStatus == GameStatus::Preparing)
	{
		// 播放摄像机动画
		bool animComplete = PlayCameraAnimation(dt);

		if (!mRubik.IsLocked())
		{
			if (!mRotationRecordStack.empty())
			{
				// 打乱
				auto record = mRotationRecordStack.top();
				switch (record.axis)
				{
				case RubikRotationAxis_X: mRubik.RotateX(record.pos, -record.dTheta); break;
				case RubikRotationAxis_Y: mRubik.RotateY(record.pos, -record.dTheta); break;
				case RubikRotationAxis_Z: mRubik.RotateZ(record.pos, -record.dTheta); break;
				}
				mRotationRecordStack.pop();
			}
			else if (animComplete)
			{
				mGameStatus = GameStatus::Ready;
			}
		}
	}
	else
	{
		KeyInput();
		MouseInput(dt);
	}

	// 仅实质性旋转才会计时
	if (mGameStatus == GameStatus::Ready && !mRotationRecordStack.empty())
	{
		// 开始游戏，计时
		mGameTimer.Start();
		mGameStatus = GameStatus::Playing;
	}
	else if (mGameStatus == GameStatus::Playing)
	{
		if (mRubik.IsCompleted() && !mRubik.IsLocked())
		{
			// 完成魔方，停止计时
			mGameTimer.Stop();
			mGameStatus = GameStatus::Finished;
			mIsCompleted = true;
			std::wstring wstr = L"最终用时：" + floating_to_wstring(mGameTimer.TotalTime(), 3) + L"秒。";
			MessageBox(nullptr, wstr.c_str(), L"完成", MB_OK);
		}
		else
		{
			mGameTimer.Tick();
		}
	}

	// 更新魔方
	mRubik.Update(dt);

}

void GameApp::DrawScene()
{
	assert(md3dImmediateContext);
	assert(mSwapChain);

	// 使用偏紫色的纯色背景
	float backgroundColor[4] = { 0.45882352f, 0.42745098f, 0.51372549f, 1.0f };
	md3dImmediateContext->ClearRenderTargetView(mRenderTargetView.Get(), backgroundColor);
	md3dImmediateContext->ClearDepthStencilView(mDepthStencilView.Get(), D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);
	
	// 绘制魔方
	mRubik.Draw(md3dImmediateContext, mBasicEffect);


	//
	// 绘制Direct2D部分
	//
	if (md2dRenderTarget != nullptr)
	{
		md2dRenderTarget->BeginDraw();

		// 用于Debug输出
		Mouse::State mouseState = mMouse->GetState();
		std::wstring wstr = L"F10(一键还原) F11(重置游戏) F12(关于作者)\n用时：" 
			+ floating_to_wstring(mGameTimer.TotalTime(), 3) + L"s";
		md2dRenderTarget->DrawTextW(wstr.c_str(), (UINT)wstr.size(), mTextFormat.Get(),
			D2D1_RECT_F{ 0.0f, 0.0f, 600.0f, 200.0f }, mColorBrush.Get());
		HR(md2dRenderTarget->EndDraw());
	}

	HR(mSwapChain->Present(0, 0));
}



void GameApp::Shuffle()
{
	// 清栈
	while (!mRotationRecordStack.empty())
		mRotationRecordStack.pop();
	// 往栈上塞30个随机旋转操作用于打乱
	RubikRotationRecord record;
	srand(static_cast<unsigned>(time(nullptr)));
	for (int i = 0; i < 30; ++i)
	{
		record.axis = static_cast<RubikRotationAxis>(rand() % 3);
		record.pos = rand() % 4;
		record.dTheta = XM_PIDIV2 * (rand() % 2 ? 1 : -1);
		mRotationRecordStack.push(record);
	}
}

bool GameApp::PlayCameraAnimation(float dt)
{
	// 获取子类
	auto cam3rd = dynamic_cast<ThirdPersonCamera*>(mCamera.get());

	// ******************
	// 第三人称摄像机的操作
	//
	mAnimationTime += dt;
	float theta, dist;

	theta = -XM_PIDIV2 + XM_PIDIV4 * mAnimationTime * 0.2f;
	dist = 20.0f - mAnimationTime * 2.0f;
	if (theta > -XM_PIDIV4)
		theta = -XM_PIDIV4;
	if (dist < 10.0f)
		dist = 10.0f;

	cam3rd->SetRotationY(theta);
	cam3rd->SetDistance(dist);

	// 更新观察矩阵
	mCamera->UpdateViewMatrix();
	mBasicEffect.SetViewMatrix(mCamera->GetViewXM());

	if (fabs(theta + XM_PIDIV4) < 1e-5f && fabs(dist - 10.0f) < 1e-5f)
		return true;
	return false;
}


bool GameApp::InitResource()
{
	// 产生用于打乱魔方的记录
	Shuffle();
	// 初始化魔方
	mRubik.InitResources(md3dDevice, md3dImmediateContext);
	mRubik.SetRotationSpeed(XM_2PI * 1.5f);
	// 初始化特效
	mBasicEffect.SetRenderDefault(md3dImmediateContext);
	// 初始化摄像机
	mCamera.reset(new ThirdPersonCamera);
	auto cam3rd = dynamic_cast<ThirdPersonCamera*>(mCamera.get());
	cam3rd->SetDistance(10.0f);
	cam3rd->SetDistanceMinMax(10.0f, 200.0f);
	cam3rd->SetFrustum(XM_PI * 0.4f, AspectRatio(), 1.0f, 1000.0f);
	cam3rd->SetViewPort(0.0f, 0.0f, (float)mClientWidth, (float)mClientHeight);
	cam3rd->SetTarget(XMFLOAT3(0.0f, 0.0f, 0.0f));
	cam3rd->SetRotationX(XM_PIDIV2 * 0.6f);
	mBasicEffect.SetProjMatrix(cam3rd->GetProjXM());
	mBasicEffect.SetTextureArray(mRubik.GetTexArray());
	

	return true;
}

void GameApp::KeyInput()
{
	Keyboard::State keyState = mKeyboard->GetState();
	mKeyboardTracker.Update(keyState);

	//
	// 特殊操作
	//

	// 立即复原，但不算成绩
	if (mKeyboardTracker.IsKeyPressed(Keyboard::F10))
	{
		
		mGameTimer.Reset();
		mGameTimer.Stop();
		mRubik.Reset();
		mGameStatus = GameStatus::Finished;
	}
	// 重置游戏
	else if (mKeyboardTracker.IsKeyPressed(Keyboard::F11))
	{
		mGameTimer.Reset();
		mGameTimer.Stop();
		mRubik.Reset();
		mGameStatus = GameStatus::Preparing;
		Shuffle();
		mAnimationTime = 0.0f;
	}
	else if (mKeyboardTracker.IsKeyPressed(Keyboard::F12))
	{
		std::wstring wstr = L"作者：X_Jun\n"
			"版本：v1.0\n"
			"本魔方可供学习和游玩\n";
		MessageBox(nullptr, wstr.c_str(), L"关于作者", MB_OK);
	}

	//
	// 撤销操作
	//
	if (keyState.IsKeyDown(Keyboard::LeftControl) &&
		mKeyboardTracker.IsKeyPressed(Keyboard::Z) &&
		!mRubik.IsLocked() && !mRotationRecordStack.empty())
	{
		auto record = mRotationRecordStack.top();
		switch (record.axis)
		{
		case RubikRotationAxis_X: mRubik.RotateX(record.pos, -record.dTheta); break;
		case RubikRotationAxis_Y: mRubik.RotateY(record.pos, -record.dTheta); break;
		case RubikRotationAxis_Z: mRubik.RotateZ(record.pos, -record.dTheta); break;
		}
		mRotationRecordStack.pop();
	}

	//
	// 整个魔方旋转
	//

	// 此时正在旋转的话则提前结束
	if (mRubik.IsLocked())
		return;

	// 公式x
	if (mKeyboardTracker.IsKeyPressed(Keyboard::Up))
	{
		mRubik.RotateX(3, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_X, 3, XM_PIDIV2 });
		return;
	}
	// 公式x'
	if (mKeyboardTracker.IsKeyPressed(Keyboard::Down))
	{
		mRubik.RotateX(3, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_X, 3, -XM_PIDIV2 });
		return;
	}
	// 公式y
	if (mKeyboardTracker.IsKeyPressed(Keyboard::Left))
	{
		mRubik.RotateY(3, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Y, 3, XM_PIDIV2 });
		return;
	}
	// 公式y'
	if (mKeyboardTracker.IsKeyPressed(Keyboard::Right))
	{
		mRubik.RotateY(3, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Y, 3, -XM_PIDIV2 });
		return;
	}
	// 公式z'
	if (mKeyboardTracker.IsKeyPressed(Keyboard::PageUp))
	{
		mRubik.RotateZ(3, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Z, 3, XM_PIDIV2 });
		return;
	}
	// 公式z
	if (mKeyboardTracker.IsKeyPressed(Keyboard::PageDown))
	{
		mRubik.RotateZ(3, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Z, 3, -XM_PIDIV2 });
		return;
	}

	//
	// 双层旋转
	//

	// 公式r
	if (keyState.IsKeyDown(Keyboard::LeftControl) && mKeyboardTracker.IsKeyPressed(Keyboard::I))
	{
		mRubik.RotateX(-2, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_X, -2, XM_PIDIV2 });
		return;
	}
	// 公式r'
	if (keyState.IsKeyDown(Keyboard::LeftControl) && mKeyboardTracker.IsKeyPressed(Keyboard::K))
	{
		mRubik.RotateX(-2, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_X, -2, -XM_PIDIV2 });
		return;
	}
	// 公式u
	if (keyState.IsKeyDown(Keyboard::LeftControl) && mKeyboardTracker.IsKeyPressed(Keyboard::J))
	{
		mRubik.RotateY(-2, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Y, -2, XM_PIDIV2 });
		return;
	}
	// 公式u'
	if (keyState.IsKeyDown(Keyboard::LeftControl) && mKeyboardTracker.IsKeyPressed(Keyboard::L))
	{
		mRubik.RotateY(-2, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Y, -2, -XM_PIDIV2 });
		return;
	}
	// 公式f'
	if (keyState.IsKeyDown(Keyboard::LeftControl) && mKeyboardTracker.IsKeyPressed(Keyboard::U))
	{
		mRubik.RotateZ(-1, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Z, -1, XM_PIDIV2 });
		return;
	}
	// 公式f
	if (keyState.IsKeyDown(Keyboard::LeftControl) && mKeyboardTracker.IsKeyPressed(Keyboard::O))
	{
		mRubik.RotateZ(-1, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Z, -1, -XM_PIDIV2 });
		return;
	}

	// 公式l'
	if (keyState.IsKeyDown(Keyboard::LeftControl) && mKeyboardTracker.IsKeyPressed(Keyboard::W))
	{
		mRubik.RotateX(-1, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_X, -1, XM_PIDIV2 });
		return;
	}
	// 公式l
	if (keyState.IsKeyDown(Keyboard::LeftControl) && mKeyboardTracker.IsKeyPressed(Keyboard::S))
	{
		mRubik.RotateX(-1, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_X, -1, -XM_PIDIV2 });
		return;
	}
	// 公式d'
	if (keyState.IsKeyDown(Keyboard::LeftControl) && mKeyboardTracker.IsKeyPressed(Keyboard::A))
	{
		mRubik.RotateY(-1, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Y, -1, XM_PIDIV2 });
		return;
	}
	// 公式d
	if (keyState.IsKeyDown(Keyboard::LeftControl) && mKeyboardTracker.IsKeyPressed(Keyboard::D))
	{
		mRubik.RotateY(-1, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Y, -1, -XM_PIDIV2 });
		return;
	}
	// 公式b
	if (keyState.IsKeyDown(Keyboard::LeftControl) && mKeyboardTracker.IsKeyPressed(Keyboard::Q))
	{
		mRubik.RotateZ(-2, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Z, -2, XM_PIDIV2 });
		return;
	}
	// 公式b'
	if (keyState.IsKeyDown(Keyboard::LeftControl) && mKeyboardTracker.IsKeyPressed(Keyboard::E))
	{
		mRubik.RotateZ(-2, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Z, -2, -XM_PIDIV2 });
		return;
	}


	//
	// 单层旋转
	//

	// 公式R
	if (mKeyboardTracker.IsKeyPressed(Keyboard::I))
	{
		mRubik.RotateX(2, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_X, 2, XM_PIDIV2 });
		return;
	}
	// 公式R'
	if (mKeyboardTracker.IsKeyPressed(Keyboard::K))
	{
		mRubik.RotateX(2, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_X, 2, -XM_PIDIV2 });
		return;
	}
	// 公式U
	if (mKeyboardTracker.IsKeyPressed(Keyboard::J))
	{
		mRubik.RotateY(2, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Y, 2, XM_PIDIV2 });
		return;
	}
	// 公式U'
	if (mKeyboardTracker.IsKeyPressed(Keyboard::L))
	{
		mRubik.RotateY(2, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Y, 2, -XM_PIDIV2 });
		return;
	}
	// 公式F'
	if (mKeyboardTracker.IsKeyPressed(Keyboard::U))
	{
		mRubik.RotateZ(0, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Z, 0, XM_PIDIV2 });
		return;
	}
	// 公式F
	if (mKeyboardTracker.IsKeyPressed(Keyboard::O))
	{
		mRubik.RotateZ(0, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Z, 0, -XM_PIDIV2 });
		return;
	}

	// 公式L'
	if (mKeyboardTracker.IsKeyPressed(Keyboard::W))
	{
		mRubik.RotateX(0, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_X, 0, XM_PIDIV2 });
		return;
	}
	// 公式L
	if (mKeyboardTracker.IsKeyPressed(Keyboard::S))
	{
		mRubik.RotateX(0, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_X, 0, -XM_PIDIV2 });
		return;
	}
	// 公式D'
	if (mKeyboardTracker.IsKeyPressed(Keyboard::A))
	{
		mRubik.RotateY(0, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Y, 0, XM_PIDIV2 });
		return;
	}
	// 公式D
	if (mKeyboardTracker.IsKeyPressed(Keyboard::D))
	{
		mRubik.RotateY(0, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Y, 0, -XM_PIDIV2 });
		return;
	}
	// 公式B
	if (mKeyboardTracker.IsKeyPressed(Keyboard::Q))
	{
		mRubik.RotateZ(2, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Z, 2, XM_PIDIV2 });
		return;
	}
	// 公式B'
	if (mKeyboardTracker.IsKeyPressed(Keyboard::E))
	{
		mRubik.RotateZ(2, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Z, 2, -XM_PIDIV2 });
		return;
	}

	// 公式M
	if (mKeyboardTracker.IsKeyPressed(Keyboard::T))
	{
		mRubik.RotateX(1, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_X, 1, XM_PIDIV2 });
		return;
	}
	// 公式M'
	if (mKeyboardTracker.IsKeyPressed(Keyboard::G))
	{
		mRubik.RotateX(1, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_X, 1, -XM_PIDIV2 });
		return;
	}
	// 公式E
	if (mKeyboardTracker.IsKeyPressed(Keyboard::F))
	{
		mRubik.RotateY(1, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Y, 1, XM_PIDIV2 });
		return;
	}
	// 公式E'
	if (mKeyboardTracker.IsKeyPressed(Keyboard::H))
	{
		mRubik.RotateY(1, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Y, 1, -XM_PIDIV2 });
		return;
	}
	// 公式S'
	if (mKeyboardTracker.IsKeyPressed(Keyboard::R))
	{
		mRubik.RotateZ(1, XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Z, 1, XM_PIDIV2 });
		return;
	}
	// 公式S
	if (mKeyboardTracker.IsKeyPressed(Keyboard::Y))
	{
		mRubik.RotateZ(1, -XM_PIDIV2);
		mRotationRecordStack.push(RubikRotationRecord{ RubikRotationAxis_Z, 1, -XM_PIDIV2 });
		return;
	}
	
}

void GameApp::MouseInput(float dt)
{
	Mouse::State mouseState = mMouse->GetState();
	Mouse::State lastState = mMouseTracker.GetLastState();
	mMouseTracker.Update(mouseState);
	

	int dx = mouseState.x - lastState.x;
	int dy = mouseState.y - lastState.y;
	// 获取子类
	auto cam3rd = dynamic_cast<ThirdPersonCamera*>(mCamera.get());

	// ******************
	// 第三人称摄像机的操作
	//

	// 绕物体旋转，添加轻微抖动
	cam3rd->SetRotationX(XM_PIDIV2 * 0.6f + (mouseState.y - mClientHeight / 2) *  0.0001f);
	cam3rd->SetRotationY(-XM_PIDIV4 + (mouseState.x - mClientWidth / 2) * 0.0001f);
	cam3rd->Approach(-mouseState.scrollWheelValue / 120 * 1.0f);

	// 更新观察矩阵
	mCamera->UpdateViewMatrix();
	mBasicEffect.SetViewMatrix(mCamera->GetViewXM());

	// 重置滚轮值
	mMouse->ResetScrollWheelValue();

	// ******************
	// 魔方操作
	//

	// 鼠标左键是否点击
	if (mouseState.leftButton)
	{
		// 此时未确定旋转方向
		if (!mDirectionLocked)
		{
			// 此时未记录点击位置
			if (mClickPosX == -1 && mClickPosY == -1)
			{
				// 初次点击
				if (mMouseTracker.leftButton == Mouse::ButtonStateTracker::PRESSED)
				{
					// 记录点击位置
					mClickPosX = mouseState.x;
					mClickPosY = mouseState.y;
				}
			}
			
			// 仅当记录了点击位置才进行更新
			if (mClickPosX != -1 && mClickPosY != -1)
				mCurrDelay += dt;
			// 未到达滑动延迟时间则结束
			if (mCurrDelay < mSlideDelay)
				return;

			// 未产生运动则不上锁
			if (abs(dx) == abs(dy))
				return;

			// 开始上方向锁
			mDirectionLocked = true;
			// 更新累积的位移变化量
			dx = mouseState.x - mClickPosX;
			dy = mouseState.y - mClickPosY;

			// 找到当前鼠标点击的方块索引
			Ray ray = Ray::ScreenToRay(*mCamera, (float)mouseState.x, (float)mouseState.y);
			float dist;
			XMINT3 pos = mRubik.HitCube(ray, &dist);

			// 判断当前主要是垂直操作还是水平操作
			bool isVertical = abs(dx) < abs(dy);
			// 当前鼠标操纵的是-Z面，根据操作类型决定旋转轴
			if (pos.z == 0 && fabs((ray.origin.z + dist * ray.direction.z) - (-3.0f)) < 1e-5f)
			{
				mCurrRotationRecord.pos = isVertical ? pos.x : pos.y;
				mCurrRotationRecord.axis = isVertical ? RubikRotationAxis_X : RubikRotationAxis_Y;
			}
			// 当前鼠标操纵的是+X面，根据操作类型决定旋转轴
			else if (pos.x == 2 && fabs((ray.origin.x + dist * ray.direction.x) - 3.0f) < 1e-5f)
			{
				mCurrRotationRecord.pos = isVertical ? pos.z : pos.y;
				mCurrRotationRecord.axis = isVertical ? RubikRotationAxis_Z : RubikRotationAxis_Y;
			}
			// 当前鼠标操纵的是+Y面，要判断平移变化量dx和dy的符号来决定旋转方向
			else if (pos.y == 2 && fabs((ray.origin.y + dist * ray.direction.y) - 3.0f) < 1e-5f)
			{
				// 判断异号
				bool diffSign = ((dx & 0x80000000) != (dy & 0x80000000));
				mCurrRotationRecord.pos = diffSign ? pos.x : pos.z;
				mCurrRotationRecord.axis = diffSign ? RubikRotationAxis_X : RubikRotationAxis_Z;
			}
			// 当前鼠标操纵的是空白地区，则对整个魔方旋转
			else
			{
				mCurrRotationRecord.pos = 3;
				// 水平操作是Y轴旋转
				if (!isVertical)
				{
					mCurrRotationRecord.axis = RubikRotationAxis_Y;
				}
				// 屏幕左半部分的垂直操作是X轴旋转
				else if (mouseState.x < mClientWidth / 2)
				{
					mCurrRotationRecord.axis = RubikRotationAxis_X;
				}
				// 屏幕右半部分的垂直操作是Z轴旋转
				else
				{
					mCurrRotationRecord.axis = RubikRotationAxis_Z;
				}
			}
		}

		// 上了方向锁才能进行旋转
		if (mDirectionLocked)
		{
			// 进行旋转
			switch (mCurrRotationRecord.axis)
			{
			case RubikRotationAxis_X: mRubik.RotateX(mCurrRotationRecord.pos, (dx - dy) * 0.008f, true);
				mCurrRotationRecord.dTheta += (dx - dy) * 0.008f;
				break;
			case RubikRotationAxis_Y: mRubik.RotateY(mCurrRotationRecord.pos, -dx * 0.008f, true);
				mCurrRotationRecord.dTheta += (-dx * 0.008f);
				break;
			case RubikRotationAxis_Z: mRubik.RotateZ(mCurrRotationRecord.pos, (-dx - dy) * 0.008f, true);
				mCurrRotationRecord.dTheta += (-dx - dy) * 0.008f;
				break;
			}
		}
	}
	// 鼠标刚释放
	else if (mMouseTracker.leftButton == Mouse::ButtonStateTracker::RELEASED)
	{
		// 释放方向锁
		mDirectionLocked = false;
		// 滑动延迟归零
		mCurrDelay = 0.0f;
		// 坐标移出屏幕
		mClickPosX = mClickPosY = -1;

		// 发送完成指令，进行预旋转
		switch (mCurrRotationRecord.axis)
		{
		case RubikRotationAxis_X: mRubik.RotateX(mCurrRotationRecord.pos, 0.0f); break;
		case RubikRotationAxis_Y: mRubik.RotateY(mCurrRotationRecord.pos, 0.0f); break;
		case RubikRotationAxis_Z: mRubik.RotateZ(mCurrRotationRecord.pos, 0.0f); break;
		}

		// 若这次旋转有意义，记录到栈中
		int times = static_cast<int>(round(mCurrRotationRecord.dTheta / XM_PIDIV2)) % 4;
		if (times != 0)
		{
			mCurrRotationRecord.dTheta = times * XM_PIDIV2;
			mRotationRecordStack.push(mCurrRotationRecord);
		}
		// 旋转值归零
		mCurrRotationRecord.dTheta = 0.0f;
	}
}

std::wstring GameApp::floating_to_wstring(float val, int precision)
{
	std::wostringstream oss;
	oss.setf(std::ios::fixed);
	oss.precision(precision);
	oss << val;
	return oss.str();
}


```

`Direct3D11-Source/GameApp.h`:

```h
#ifndef GAMEAPP_H
#define GAMEAPP_H

#include "d3dApp.h"
#include "Rubik.h"
#include "Camera.h"
#include <ctime>
#include <sstream>

class GameApp : public D3DApp
{
public:
	enum class GameStatus {
		Preparing,	// 准备中
		Ready,		// 就绪
		Playing,	// 游玩中
		Finished,	// 已完成
	};

public:
	GameApp(HINSTANCE hInstance);
	~GameApp();

	bool Init();
	void OnResize();
	void UpdateScene(float dt);
	void DrawScene();


private:

	// 用于产生打乱魔方的序列
	void Shuffle();
	// 播放摄像机动画，完成动画将返回true
	bool PlayCameraAnimation(float dt);

	bool InitResource();

	void KeyInput();
	void MouseInput(float dt);

	std::wstring floating_to_wstring(float val, int precision);

private:
	ComPtr<ID2D1SolidColorBrush> mColorBrush;	// 单色笔刷
	ComPtr<IDWriteFont> mFont;					// 字体
	ComPtr<IDWriteTextFormat> mTextFormat;		// 文本格式

	Rubik mRubik;								// 魔方
	
	std::unique_ptr<Camera> mCamera;			// 第三人称摄像机

	BasicEffect mBasicEffect;					// 基础特效管理类

	GameTimer mGameTimer;						// 游戏计时器
	GameStatus mGameStatus;						// 游戏状态
	bool mIsCompleted;							// 是否完成

	float mAnimationTime;						// 动画经过时间

	//
	// 鼠标操作控制
	//
	
	int mClickPosX, mClickPosY;					// 初次点击时鼠标位置
	float mSlideDelay;							// 拖动延迟响应时间 
	float mCurrDelay;							// 当前延迟时间
	bool mDirectionLocked;						// 方向锁

	RubikRotationRecord mCurrRotationRecord;	// 当前旋转记录

	std::stack<RubikRotationRecord> mRotationRecordStack;	// 旋转记录栈
};


#endif
```

`Direct3D11-Source/GameTimer.cpp`:

```cpp
//***************************************************************************************
// GameTimer.cpp by Frank Luna (C) 2011 All Rights Reserved.
//***************************************************************************************

#include <windows.h>
#include "GameTimer.h"

GameTimer::GameTimer()
: mSecondsPerCount(0.0), mDeltaTime(-1.0), mBaseTime(0), 
  mPausedTime(0), mPrevTime(0), mCurrTime(0), mStopped(false)
{
	__int64 countsPerSec;
	QueryPerformanceFrequency((LARGE_INTEGER*)&countsPerSec);
	mSecondsPerCount = 1.0 / (double)countsPerSec;
}

// Returns the total time elapsed since Reset() was called, NOT counting any
// time when the clock is stopped.
float GameTimer::TotalTime()const
{
	// If we are stopped, do not count the time that has passed since we stopped.
	// Moreover, if we previously already had a pause, the distance 
	// mStopTime - mBaseTime includes paused time, which we do not want to count.
	// To correct this, we can subtract the paused time from mStopTime:  
	//
	//                     |<--paused time-->|
	// ----*---------------*-----------------*------------*------------*------> time
	//  mBaseTime       mStopTime        startTime     mStopTime    mCurrTime

	if( mStopped )
	{
		return (float)(((mStopTime - mPausedTime)-mBaseTime)*mSecondsPerCount);
	}

	// The distance mCurrTime - mBaseTime includes paused time,
	// which we do not want to count.  To correct this, we can subtract 
	// the paused time from mCurrTime:  
	//
	//  (mCurrTime - mPausedTime) - mBaseTime 
	//
	//                     |<--paused time-->|
	// ----*---------------*-----------------*------------*------> time
	//  mBaseTime       mStopTime        startTime     mCurrTime
	
	else
	{
		return (float)(((mCurrTime-mPausedTime)-mBaseTime)*mSecondsPerCount);
	}
}

float GameTimer::DeltaTime()const
{
	return (float)mDeltaTime;
}

void GameTimer::Reset()
{
	__int64 currTime;
	QueryPerformanceCounter((LARGE_INTEGER*)&currTime);

	mBaseTime = currTime;
	mPrevTime = currTime;
	mStopTime = 0;
	mPausedTime = 0;	// 涉及到多次Reset的话需要将其归0
	mStopped  = false;
}

void GameTimer::Start()
{
	__int64 startTime;
	QueryPerformanceCounter((LARGE_INTEGER*)&startTime);


	// Accumulate the time elapsed between stop and start pairs.
	//
	//                     |<-------d------->|
	// ----*---------------*-----------------*------------> time
	//  mBaseTime       mStopTime        startTime     

	if( mStopped )
	{
		mPausedTime += (startTime - mStopTime);	

		mPrevTime = startTime;
		mStopTime = 0;
		mStopped  = false;
	}
}

void GameTimer::Stop()
{
	if( !mStopped )
	{
		__int64 currTime;
		QueryPerformanceCounter((LARGE_INTEGER*)&currTime);

		mStopTime = currTime;
		mStopped  = true;
	}
}

void GameTimer::Tick()
{
	if( mStopped )
	{
		mDeltaTime = 0.0;
		return;
	}

	__int64 currTime;
	QueryPerformanceCounter((LARGE_INTEGER*)&currTime);
	mCurrTime = currTime;

	// Time difference between this frame and the previous.
	mDeltaTime = (mCurrTime - mPrevTime)*mSecondsPerCount;

	// Prepare for next frame.
	mPrevTime = mCurrTime;

	if(mDeltaTime < 0.0)
	{
		mDeltaTime = 0.0;
	}
}


```

`Direct3D11-Source/GameTimer.h`:

```h
//***************************************************************************************
// GameTimer.h by Frank Luna (C) 2011 All Rights Reserved.
//***************************************************************************************

#ifndef GAMETIMER_H
#define GAMETIMER_H

class GameTimer
{
public:
	GameTimer();

	float TotalTime()const;		// 总游戏时间
	float DeltaTime()const;		// 帧间隔时间

	void Reset(); // 在消息循环之前调用
	void Start(); // 在取消暂停的时候调用
	void Stop();  // 在暂停的时候调用
	void Tick();  // 在每一帧的时候调用

private:
	double mSecondsPerCount;
	double mDeltaTime;

	__int64 mBaseTime;
	__int64 mPausedTime;
	__int64 mStopTime;
	__int64 mPrevTime;
	__int64 mCurrTime;

	bool mStopped;
};

#endif // GAMETIMER_H
```

`Direct3D11-Source/HLSL/Basic.hlsli`:

```hlsli
Texture2DArray gTexArray : register(t0);
SamplerState gSam : register(s0);

cbuffer CBChangesEveryDrawing : register(b0)
{
    int gTexIndex;
    float3 gPad;
}

cbuffer CBChangesEveryCube : register(b1)
{
    matrix gWorld;
}

cbuffer CBChangesEveryFrame : register(b2)
{
	matrix gView;
}

cbuffer CBChangesOnResize : register(b3)
{
	matrix gProj;
}


struct VertexPosTex
{
    float3 PosL : POSITION;
    float2 Tex : TEXCOORD;
};

struct VertexPosHTex
{
    float4 PosH : SV_POSITION;
    float2 Tex : TEXCOORD;
};







```

`Direct3D11-Source/HLSL/Basic_PS.hlsl`:

```hlsl
#include "Basic.hlsli"

// 像素着色器
float4 PS(VertexPosHTex pIn) : SV_Target
{
    float4 texColor = gTexArray.Sample(gSam, float3(pIn.Tex, gTexIndex));
    return texColor;
}

```

`Direct3D11-Source/HLSL/Basic_VS.hlsl`:

```hlsl
#include "Basic.hlsli"

// 顶点着色器
VertexPosHTex VS(VertexPosTex pIn)
{
    VertexPosHTex pOut;
    
    matrix worldViewProj = mul(gWorld, mul(gView, gProj));
   
    pOut.PosH = mul(float4(pIn.PosL, 1.0f), worldViewProj);
    pOut.Tex = pIn.Tex;
    return pOut;
}
```

`Direct3D11-Source/Keyboard.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// File: Keyboard.cpp
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
// http://go.microsoft.com/fwlink/?LinkId=248929
// http://go.microsoft.com/fwlink/?LinkID=615561
//--------------------------------------------------------------------------------------

#include <cassert>
#include <exception>
#include <wrl/client.h>
#include "Keyboard.h"



using namespace DirectX;
using Microsoft::WRL::ComPtr;

struct handle_closer { void operator()(HANDLE h) { if (h) CloseHandle(h); } };

typedef std::unique_ptr<void, handle_closer> ScopedHandle;

static_assert(sizeof(Keyboard::State) == (256 / 8), "Size mismatch for State");

namespace
{
	void KeyDown(int key, Keyboard::State& state)
	{
		if (key < 0 || key > 0xfe)
			return;

		auto ptr = reinterpret_cast<uint32_t*>(&state);

		unsigned int bf = 1u << (key & 0x1f);
		ptr[(key >> 5)] |= bf;
	}

	void KeyUp(int key, Keyboard::State& state)
	{
		if (key < 0 || key > 0xfe)
			return;

		auto ptr = reinterpret_cast<uint32_t*>(&state);

		unsigned int bf = 1u << (key & 0x1f);
		ptr[(key >> 5)] &= ~bf;
	}
}


#if !defined(WINAPI_FAMILY) || (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP)

//======================================================================================
// Win32 desktop implementation
//======================================================================================

//
// For a Win32 desktop application, call this function from your Window Message Procedure
//
// LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
// {
//     switch (message)
//     {
//
//     case WM_ACTIVATEAPP:
//         Keyboard::ProcessMessage(message, wParam, lParam);
//         break;
//
//     case WM_KEYDOWN:
//     case WM_SYSKEYDOWN:
//     case WM_KEYUP:
//     case WM_SYSKEYUP:
//         Keyboard::ProcessMessage(message, wParam, lParam);
//         break;
//
//     }
// }
//

class Keyboard::Impl
{
public:
	Impl(Keyboard* owner) :
		mState{},
		mOwner(owner)
	{
		if (s_keyboard)
		{
			throw std::exception("Keyboard is a singleton");
		}

		s_keyboard = this;
	}

	~Impl()
	{
		s_keyboard = nullptr;
	}

	void GetState(State& state) const
	{
		memcpy(&state, &mState, sizeof(State));
	}

	void Reset()
	{
		memset(&mState, 0, sizeof(State));
	}

	bool IsConnected() const
	{
		return true;
	}

	State           mState;
	Keyboard*       mOwner;

	static Keyboard::Impl* s_keyboard;
};


Keyboard::Impl* Keyboard::Impl::s_keyboard = nullptr;


void Keyboard::ProcessMessage(UINT message, WPARAM wParam, LPARAM lParam)
{
	auto pImpl = Impl::s_keyboard;

	if (!pImpl)
		return;

	bool down = false;

	switch (message)
	{
	case WM_ACTIVATEAPP:
		pImpl->Reset();
		return;

	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		down = true;
		break;

	case WM_KEYUP:
	case WM_SYSKEYUP:
		break;

	default:
		return;
	}

	int vk = static_cast<int>(wParam);
	switch (vk)
	{
	case VK_SHIFT:
		vk = MapVirtualKey((lParam & 0x00ff0000) >> 16, MAPVK_VSC_TO_VK_EX);
		if (!down)
		{
			// Workaround to ensure left vs. right shift get cleared when both were pressed at same time
			KeyUp(VK_LSHIFT, pImpl->mState);
			KeyUp(VK_RSHIFT, pImpl->mState);
		}
		break;

	case VK_CONTROL:
		vk = (lParam & 0x01000000) ? VK_RCONTROL : VK_LCONTROL;
		break;

	case VK_MENU:
		vk = (lParam & 0x01000000) ? VK_RMENU : VK_LMENU;
		break;
	}

	if (down)
	{
		KeyDown(vk, pImpl->mState);
	}
	else
	{
		KeyUp(vk, pImpl->mState);
	}
}

#endif



#pragma warning( disable : 4355 )

// Public constructor.
Keyboard::Keyboard() noexcept(false)
	: pImpl(std::make_unique<Impl>(this))
{
}


// Move constructor.
Keyboard::Keyboard(Keyboard&& moveFrom) noexcept
	: pImpl(std::move(moveFrom.pImpl))
{
	pImpl->mOwner = this;
}


// Move assignment.
Keyboard& Keyboard::operator= (Keyboard&& moveFrom) noexcept
{
	pImpl = std::move(moveFrom.pImpl);
	pImpl->mOwner = this;
	return *this;
}


// Public destructor.
Keyboard::~Keyboard()
{
}


Keyboard::State Keyboard::GetState() const
{
	State state;
	pImpl->GetState(state);
	return state;
}


void Keyboard::Reset()
{
	pImpl->Reset();
}


bool Keyboard::IsConnected() const
{
	return pImpl->IsConnected();
}

Keyboard& Keyboard::Get()
{
	if (!Impl::s_keyboard || !Impl::s_keyboard->mOwner)
		throw std::exception("Keyboard is a singleton");

	return *Impl::s_keyboard->mOwner;
}



//======================================================================================
// KeyboardStateTracker
//======================================================================================

void Keyboard::KeyboardStateTracker::Update(const State& state)
{
	auto currPtr = reinterpret_cast<const uint32_t*>(&state);
	auto prevPtr = reinterpret_cast<const uint32_t*>(&lastState);
	auto releasedPtr = reinterpret_cast<uint32_t*>(&released);
	auto pressedPtr = reinterpret_cast<uint32_t*>(&pressed);
	for (size_t j = 0; j < (256 / 32); ++j)
	{
		*pressedPtr = *currPtr & ~(*prevPtr);
		*releasedPtr = ~(*currPtr) & *prevPtr;

		++currPtr;
		++prevPtr;
		++releasedPtr;
		++pressedPtr;
	}

	lastState = state;
}


void Keyboard::KeyboardStateTracker::Reset() noexcept
{
	memset(this, 0, sizeof(KeyboardStateTracker));
}

```

`Direct3D11-Source/Keyboard.h`:

```h
//--------------------------------------------------------------------------------------
// File: Keyboard.h
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
// http://go.microsoft.com/fwlink/?LinkId=248929
// http://go.microsoft.com/fwlink/?LinkID=615561
//--------------------------------------------------------------------------------------

#pragma once

#include <memory>
#include <stdint.h>

namespace DirectX
{
	class Keyboard
	{
	public:
		Keyboard() noexcept(false);
		Keyboard(Keyboard&& moveFrom) noexcept;
		Keyboard& operator= (Keyboard&& moveFrom) noexcept;

		Keyboard(Keyboard const&) = delete;
		Keyboard& operator=(Keyboard const&) = delete;

		virtual ~Keyboard();

		enum Keys
		{
			None = 0,

			Back = 0x8,
			Tab = 0x9,

			Enter = 0xd,

			Pause = 0x13,
			CapsLock = 0x14,
			Kana = 0x15,

			Kanji = 0x19,

			Escape = 0x1b,
			ImeConvert = 0x1c,
			ImeNoConvert = 0x1d,

			Space = 0x20,
			PageUp = 0x21,
			PageDown = 0x22,
			End = 0x23,
			Home = 0x24,
			Left = 0x25,
			Up = 0x26,
			Right = 0x27,
			Down = 0x28,
			Select = 0x29,
			Print = 0x2a,
			Execute = 0x2b,
			PrintScreen = 0x2c,
			Insert = 0x2d,
			Delete = 0x2e,
			Help = 0x2f,
			D0 = 0x30,
			D1 = 0x31,
			D2 = 0x32,
			D3 = 0x33,
			D4 = 0x34,
			D5 = 0x35,
			D6 = 0x36,
			D7 = 0x37,
			D8 = 0x38,
			D9 = 0x39,

			A = 0x41,
			B = 0x42,
			C = 0x43,
			D = 0x44,
			E = 0x45,
			F = 0x46,
			G = 0x47,
			H = 0x48,
			I = 0x49,
			J = 0x4a,
			K = 0x4b,
			L = 0x4c,
			M = 0x4d,
			N = 0x4e,
			O = 0x4f,
			P = 0x50,
			Q = 0x51,
			R = 0x52,
			S = 0x53,
			T = 0x54,
			U = 0x55,
			V = 0x56,
			W = 0x57,
			X = 0x58,
			Y = 0x59,
			Z = 0x5a,
			LeftWindows = 0x5b,
			RightWindows = 0x5c,
			Apps = 0x5d,

			Sleep = 0x5f,
			NumPad0 = 0x60,
			NumPad1 = 0x61,
			NumPad2 = 0x62,
			NumPad3 = 0x63,
			NumPad4 = 0x64,
			NumPad5 = 0x65,
			NumPad6 = 0x66,
			NumPad7 = 0x67,
			NumPad8 = 0x68,
			NumPad9 = 0x69,
			Multiply = 0x6a,
			Add = 0x6b,
			Separator = 0x6c,
			Subtract = 0x6d,

			Decimal = 0x6e,
			Divide = 0x6f,
			F1 = 0x70,
			F2 = 0x71,
			F3 = 0x72,
			F4 = 0x73,
			F5 = 0x74,
			F6 = 0x75,
			F7 = 0x76,
			F8 = 0x77,
			F9 = 0x78,
			F10 = 0x79,
			F11 = 0x7a,
			F12 = 0x7b,
			F13 = 0x7c,
			F14 = 0x7d,
			F15 = 0x7e,
			F16 = 0x7f,
			F17 = 0x80,
			F18 = 0x81,
			F19 = 0x82,
			F20 = 0x83,
			F21 = 0x84,
			F22 = 0x85,
			F23 = 0x86,
			F24 = 0x87,

			NumLock = 0x90,
			Scroll = 0x91,

			LeftShift = 0xa0,
			RightShift = 0xa1,
			LeftControl = 0xa2,
			RightControl = 0xa3,
			LeftAlt = 0xa4,
			RightAlt = 0xa5,
			BrowserBack = 0xa6,
			BrowserForward = 0xa7,
			BrowserRefresh = 0xa8,
			BrowserStop = 0xa9,
			BrowserSearch = 0xaa,
			BrowserFavorites = 0xab,
			BrowserHome = 0xac,
			VolumeMute = 0xad,
			VolumeDown = 0xae,
			VolumeUp = 0xaf,
			MediaNextTrack = 0xb0,
			MediaPreviousTrack = 0xb1,
			MediaStop = 0xb2,
			MediaPlayPause = 0xb3,
			LaunchMail = 0xb4,
			SelectMedia = 0xb5,
			LaunchApplication1 = 0xb6,
			LaunchApplication2 = 0xb7,

			OemSemicolon = 0xba,
			OemPlus = 0xbb,
			OemComma = 0xbc,
			OemMinus = 0xbd,
			OemPeriod = 0xbe,
			OemQuestion = 0xbf,
			OemTilde = 0xc0,

			OemOpenBrackets = 0xdb,
			OemPipe = 0xdc,
			OemCloseBrackets = 0xdd,
			OemQuotes = 0xde,
			Oem8 = 0xdf,

			OemBackslash = 0xe2,

			ProcessKey = 0xe5,

			OemCopy = 0xf2,
			OemAuto = 0xf3,
			OemEnlW = 0xf4,

			Attn = 0xf6,
			Crsel = 0xf7,
			Exsel = 0xf8,
			EraseEof = 0xf9,
			Play = 0xfa,
			Zoom = 0xfb,

			Pa1 = 0xfd,
			OemClear = 0xfe,
		};

		struct State
		{
			bool Reserved0 : 8;
			bool Back : 1;              // VK_BACK, 0x8
			bool Tab : 1;               // VK_TAB, 0x9
			bool Reserved1 : 3;
			bool Enter : 1;             // VK_RETURN, 0xD
			bool Reserved2 : 2;
			bool Reserved3 : 3;
			bool Pause : 1;             // VK_PAUSE, 0x13
			bool CapsLock : 1;          // VK_CAPITAL, 0x14
			bool Kana : 1;              // VK_KANA, 0x15
			bool Reserved4 : 2;
			bool Reserved5 : 1;
			bool Kanji : 1;             // VK_KANJI, 0x19
			bool Reserved6 : 1;
			bool Escape : 1;            // VK_ESCAPE, 0x1B
			bool ImeConvert : 1;        // VK_CONVERT, 0x1C
			bool ImeNoConvert : 1;      // VK_NONCONVERT, 0x1D
			bool Reserved7 : 2;
			bool Space : 1;             // VK_SPACE, 0x20
			bool PageUp : 1;            // VK_PRIOR, 0x21
			bool PageDown : 1;          // VK_NEXT, 0x22
			bool End : 1;               // VK_END, 0x23
			bool Home : 1;              // VK_HOME, 0x24
			bool Left : 1;              // VK_LEFT, 0x25
			bool Up : 1;                // VK_UP, 0x26
			bool Right : 1;             // VK_RIGHT, 0x27
			bool Down : 1;              // VK_DOWN, 0x28
			bool Select : 1;            // VK_SELECT, 0x29
			bool Print : 1;             // VK_PRINT, 0x2A
			bool Execute : 1;           // VK_EXECUTE, 0x2B
			bool PrintScreen : 1;       // VK_SNAPSHOT, 0x2C
			bool Insert : 1;            // VK_INSERT, 0x2D
			bool Delete : 1;            // VK_DELETE, 0x2E
			bool Help : 1;              // VK_HELP, 0x2F
			bool D0 : 1;                // 0x30
			bool D1 : 1;                // 0x31
			bool D2 : 1;                // 0x32
			bool D3 : 1;                // 0x33
			bool D4 : 1;                // 0x34
			bool D5 : 1;                // 0x35
			bool D6 : 1;                // 0x36
			bool D7 : 1;                // 0x37
			bool D8 : 1;                // 0x38
			bool D9 : 1;                // 0x39
			bool Reserved8 : 6;
			bool Reserved9 : 1;
			bool A : 1;                 // 0x41
			bool B : 1;                 // 0x42
			bool C : 1;                 // 0x43
			bool D : 1;                 // 0x44
			bool E : 1;                 // 0x45
			bool F : 1;                 // 0x46
			bool G : 1;                 // 0x47
			bool H : 1;                 // 0x48
			bool I : 1;                 // 0x49
			bool J : 1;                 // 0x4A
			bool K : 1;                 // 0x4B
			bool L : 1;                 // 0x4C
			bool M : 1;                 // 0x4D
			bool N : 1;                 // 0x4E
			bool O : 1;                 // 0x4F
			bool P : 1;                 // 0x50
			bool Q : 1;                 // 0x51
			bool R : 1;                 // 0x52
			bool S : 1;                 // 0x53
			bool T : 1;                 // 0x54
			bool U : 1;                 // 0x55
			bool V : 1;                 // 0x56
			bool W : 1;                 // 0x57
			bool X : 1;                 // 0x58
			bool Y : 1;                 // 0x59
			bool Z : 1;                 // 0x5A
			bool LeftWindows : 1;       // VK_LWIN, 0x5B
			bool RightWindows : 1;      // VK_RWIN, 0x5C
			bool Apps : 1;              // VK_APPS, 0x5D
			bool Reserved10 : 1;
			bool Sleep : 1;             // VK_SLEEP, 0x5F
			bool NumPad0 : 1;           // VK_NUMPAD0, 0x60
			bool NumPad1 : 1;           // VK_NUMPAD1, 0x61
			bool NumPad2 : 1;           // VK_NUMPAD2, 0x62
			bool NumPad3 : 1;           // VK_NUMPAD3, 0x63
			bool NumPad4 : 1;           // VK_NUMPAD4, 0x64
			bool NumPad5 : 1;           // VK_NUMPAD5, 0x65
			bool NumPad6 : 1;           // VK_NUMPAD6, 0x66
			bool NumPad7 : 1;           // VK_NUMPAD7, 0x67
			bool NumPad8 : 1;           // VK_NUMPAD8, 0x68
			bool NumPad9 : 1;           // VK_NUMPAD9, 0x69
			bool Multiply : 1;          // VK_MULTIPLY, 0x6A
			bool Add : 1;               // VK_ADD, 0x6B
			bool Separator : 1;         // VK_SEPARATOR, 0x6C
			bool Subtract : 1;          // VK_SUBTRACT, 0x6D
			bool Decimal : 1;           // VK_DECIMANL, 0x6E
			bool Divide : 1;            // VK_DIVIDE, 0x6F
			bool F1 : 1;                // VK_F1, 0x70
			bool F2 : 1;                // VK_F2, 0x71
			bool F3 : 1;                // VK_F3, 0x72
			bool F4 : 1;                // VK_F4, 0x73
			bool F5 : 1;                // VK_F5, 0x74
			bool F6 : 1;                // VK_F6, 0x75
			bool F7 : 1;                // VK_F7, 0x76
			bool F8 : 1;                // VK_F8, 0x77
			bool F9 : 1;                // VK_F9, 0x78
			bool F10 : 1;               // VK_F10, 0x79
			bool F11 : 1;               // VK_F11, 0x7A
			bool F12 : 1;               // VK_F12, 0x7B
			bool F13 : 1;               // VK_F13, 0x7C
			bool F14 : 1;               // VK_F14, 0x7D
			bool F15 : 1;               // VK_F15, 0x7E
			bool F16 : 1;               // VK_F16, 0x7F
			bool F17 : 1;               // VK_F17, 0x80
			bool F18 : 1;               // VK_F18, 0x81
			bool F19 : 1;               // VK_F19, 0x82
			bool F20 : 1;               // VK_F20, 0x83
			bool F21 : 1;               // VK_F21, 0x84
			bool F22 : 1;               // VK_F22, 0x85
			bool F23 : 1;               // VK_F23, 0x86
			bool F24 : 1;               // VK_F24, 0x87
			bool Reserved11 : 8;
			bool NumLock : 1;           // VK_NUMLOCK, 0x90
			bool Scroll : 1;            // VK_SCROLL, 0x91
			bool Reserved12 : 6;
			bool Reserved13 : 8;
			bool LeftShift : 1;         // VK_LSHIFT, 0xA0
			bool RightShift : 1;        // VK_RSHIFT, 0xA1
			bool LeftControl : 1;       // VK_LCONTROL, 0xA2
			bool RightControl : 1;      // VK_RCONTROL, 0xA3
			bool LeftAlt : 1;           // VK_LMENU, 0xA4
			bool RightAlt : 1;          // VK_RMENU, 0xA5
			bool BrowserBack : 1;       // VK_BROWSER_BACK, 0xA6
			bool BrowserForward : 1;    // VK_BROWSER_FORWARD, 0xA7
			bool BrowserRefresh : 1;    // VK_BROWSER_REFRESH, 0xA8
			bool BrowserStop : 1;       // VK_BROWSER_STOP, 0xA9
			bool BrowserSearch : 1;     // VK_BROWSER_SEARCH, 0xAA
			bool BrowserFavorites : 1;  // VK_BROWSER_FAVORITES, 0xAB
			bool BrowserHome : 1;       // VK_BROWSER_HOME, 0xAC
			bool VolumeMute : 1;        // VK_VOLUME_MUTE, 0xAD
			bool VolumeDown : 1;        // VK_VOLUME_DOWN, 0xAE
			bool VolumeUp : 1;          // VK_VOLUME_UP, 0xAF
			bool MediaNextTrack : 1;    // VK_MEDIA_NEXT_TRACK, 0xB0
			bool MediaPreviousTrack : 1;// VK_MEDIA_PREV_TRACK, 0xB1
			bool MediaStop : 1;         // VK_MEDIA_STOP, 0xB2
			bool MediaPlayPause : 1;    // VK_MEDIA_PLAY_PAUSE, 0xB3
			bool LaunchMail : 1;        // VK_LAUNCH_MAIL, 0xB4
			bool SelectMedia : 1;       // VK_LAUNCH_MEDIA_SELECT, 0xB5
			bool LaunchApplication1 : 1;// VK_LAUNCH_APP1, 0xB6
			bool LaunchApplication2 : 1;// VK_LAUNCH_APP2, 0xB7
			bool Reserved14 : 2;
			bool OemSemicolon : 1;      // VK_OEM_1, 0xBA
			bool OemPlus : 1;           // VK_OEM_PLUS, 0xBB
			bool OemComma : 1;          // VK_OEM_COMMA, 0xBC
			bool OemMinus : 1;          // VK_OEM_MINUS, 0xBD
			bool OemPeriod : 1;         // VK_OEM_PERIOD, 0xBE
			bool OemQuestion : 1;       // VK_OEM_2, 0xBF
			bool OemTilde : 1;          // VK_OEM_3, 0xC0
			bool Reserved15 : 7;
			bool Reserved16 : 8;
			bool Reserved17 : 8;
			bool Reserved18 : 3;
			bool OemOpenBrackets : 1;   // VK_OEM_4, 0xDB
			bool OemPipe : 1;           // VK_OEM_5, 0xDC
			bool OemCloseBrackets : 1;  // VK_OEM_6, 0xDD
			bool OemQuotes : 1;         // VK_OEM_7, 0xDE
			bool Oem8 : 1;              // VK_OEM_8, 0xDF
			bool Reserved19 : 2;
			bool OemBackslash : 1;      // VK_OEM_102, 0xE2
			bool Reserved20 : 2;
			bool ProcessKey : 1;        // VK_PROCESSKEY, 0xE5
			bool Reserved21 : 2;
			bool Reserved22 : 8;
			bool Reserved23 : 2;
			bool OemCopy : 1;           // 0XF2
			bool OemAuto : 1;           // 0xF3
			bool OemEnlW : 1;           // 0xF4
			bool Reserved24 : 1;
			bool Attn : 1;              // VK_ATTN, 0xF6
			bool Crsel : 1;             // VK_CRSEL, 0xF7
			bool Exsel : 1;             // VK_EXSEL, 0xF8
			bool EraseEof : 1;          // VK_EREOF, 0xF9
			bool Play : 1;              // VK_PLAY, 0xFA
			bool Zoom : 1;              // VK_ZOOM, 0xFB
			bool Reserved25 : 1;
			bool Pa1 : 1;               // VK_PA1, 0xFD
			bool OemClear : 1;          // VK_OEM_CLEAR, 0xFE
			bool Reserved26 : 1;

			bool __cdecl IsKeyDown(Keys key) const
			{
				if (key >= 0 && key <= 0xfe)
				{
					auto ptr = reinterpret_cast<const uint32_t*>(this);
					unsigned int bf = 1u << (key & 0x1f);
					return (ptr[(key >> 5)] & bf) != 0;
				}
				return false;
			}

			bool __cdecl IsKeyUp(Keys key) const
			{
				if (key >= 0 && key <= 0xfe)
				{
					auto ptr = reinterpret_cast<const uint32_t*>(this);
					unsigned int bf = 1u << (key & 0x1f);
					return (ptr[(key >> 5)] & bf) == 0;
				}
				return false;
			}
		};

		class KeyboardStateTracker
		{
		public:
			State released;
			State pressed;

#pragma prefast(suppress: 26495, "Reset() performs the initialization")
			KeyboardStateTracker() noexcept { Reset(); }

			void __cdecl Update(const State& state);

			void __cdecl Reset() noexcept;

			bool __cdecl IsKeyPressed(Keys key) const { return pressed.IsKeyDown(key); }
			bool __cdecl IsKeyReleased(Keys key) const { return released.IsKeyDown(key); }

			State __cdecl GetLastState() const { return lastState; }

		public:
			State lastState;
		};

		// Retrieve the current state of the keyboard
		State __cdecl GetState() const;

		// Reset the keyboard state
		void __cdecl Reset();

		// Feature detection
		bool __cdecl IsConnected() const;

#if !defined(WINAPI_FAMILY) || (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP) && defined(WM_USER)
		static void __cdecl ProcessMessage(UINT message, WPARAM wParam, LPARAM lParam);
#endif

		// Singleton
		static Keyboard& __cdecl Get();

	private:
		// Private implementation.
		class Impl;

		std::unique_ptr<Impl> pImpl;
	};
}

```

`Direct3D11-Source/Main.cpp`:

```cpp
#include "GameApp.h"
 


int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE prevInstance,
				   PSTR cmdLine, int showCmd)
{
	// 这些参数不使用
	UNREFERENCED_PARAMETER(prevInstance);
	UNREFERENCED_PARAMETER(cmdLine);
	UNREFERENCED_PARAMETER(showCmd);
	// 允许在Debug版本进行运行时内存分配和泄漏检测
#if defined(DEBUG) | defined(_DEBUG)
	_CrtSetDbgFlag( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
#endif

	GameApp theApp(hInstance);
	
	if( !theApp.Init() )
		return 0;
	
	return theApp.Run();
}





```

`Direct3D11-Source/Mouse.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// File: Mouse.cpp
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
// http://go.microsoft.com/fwlink/?LinkId=248929
// http://go.microsoft.com/fwlink/?LinkID=615561
//--------------------------------------------------------------------------------------

#include <cassert>
#include <exception>
#include <wrl/client.h>
#include "Mouse.h"


using namespace DirectX;
using Microsoft::WRL::ComPtr;

struct handle_closer { void operator()(HANDLE h) { if (h) CloseHandle(h); } };

typedef std::unique_ptr<void, handle_closer> ScopedHandle;

#if !defined(WINAPI_FAMILY) || (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP)

//======================================================================================
// Win32 desktop implementation
//======================================================================================

//
// For a Win32 desktop application, in your window setup be sure to call this method:
//
// m_mouse->SetWindow(hwnd);
//
// And call this static function from your Window Message Procedure
//
// LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
// {
//     switch (message)
//     {
//     case WM_ACTIVATEAPP:
//     case WM_INPUT:
//     case WM_MOUSEMOVE:
//     case WM_LBUTTONDOWN:
//     case WM_LBUTTONUP:
//     case WM_RBUTTONDOWN:
//     case WM_RBUTTONUP:
//     case WM_MBUTTONDOWN:
//     case WM_MBUTTONUP:
//     case WM_MOUSEWHEEL:
//     case WM_XBUTTONDOWN:
//     case WM_XBUTTONUP:
//     case WM_MOUSEHOVER:
//         Mouse::ProcessMessage(message, wParam, lParam);
//         break;
//
//     }
// }
//

class Mouse::Impl
{
public:
	Impl(Mouse* owner) :
		mState{},
		mOwner(owner),
		mWindow(nullptr),
		mMode(MODE_ABSOLUTE),
		mLastX(0),
		mLastY(0),
		mRelativeX(INT32_MAX),
		mRelativeY(INT32_MAX),
		mInFocus(true)
	{
		if (s_mouse)
		{
			throw std::exception("Mouse is a singleton");
		}

		s_mouse = this;

		mScrollWheelValue.reset(CreateEventEx(nullptr, nullptr, CREATE_EVENT_MANUAL_RESET, EVENT_MODIFY_STATE | SYNCHRONIZE));
		mRelativeRead.reset(CreateEventEx(nullptr, nullptr, CREATE_EVENT_MANUAL_RESET, EVENT_MODIFY_STATE | SYNCHRONIZE));
		mAbsoluteMode.reset(CreateEventEx(nullptr, nullptr, 0, EVENT_MODIFY_STATE | SYNCHRONIZE));
		mRelativeMode.reset(CreateEventEx(nullptr, nullptr, 0, EVENT_MODIFY_STATE | SYNCHRONIZE));
		if (!mScrollWheelValue
			|| !mRelativeRead
			|| !mAbsoluteMode
			|| !mRelativeMode)
		{
			throw std::exception("CreateEventEx");
		}
	}

	~Impl()
	{
		s_mouse = nullptr;
	}

	void GetState(State& state) const
	{
		memcpy(&state, &mState, sizeof(State));
		state.positionMode = mMode;

		DWORD result = WaitForSingleObjectEx(mScrollWheelValue.get(), 0, FALSE);
		if (result == WAIT_FAILED)
			throw std::exception("WaitForSingleObjectEx");

		if (result == WAIT_OBJECT_0)
		{
			state.scrollWheelValue = 0;
		}

		if (state.positionMode == MODE_RELATIVE)
		{
			result = WaitForSingleObjectEx(mRelativeRead.get(), 0, FALSE);

			if (result == WAIT_FAILED)
				throw std::exception("WaitForSingleObjectEx");

			if (result == WAIT_OBJECT_0)
			{
				state.x = 0;
				state.y = 0;
			}
			else
			{
				SetEvent(mRelativeRead.get());
			}
		}
	}

	void ResetScrollWheelValue()
	{
		SetEvent(mScrollWheelValue.get());
	}

	void SetMode(Mode mode)
	{
		if (mMode == mode)
			return;

		SetEvent((mode == MODE_ABSOLUTE) ? mAbsoluteMode.get() : mRelativeMode.get());

		assert(mWindow != nullptr);

		TRACKMOUSEEVENT tme;
		tme.cbSize = sizeof(tme);
		tme.dwFlags = TME_HOVER;
		tme.hwndTrack = mWindow;
		tme.dwHoverTime = 1;
		if (!TrackMouseEvent(&tme))
		{
			throw std::exception("TrackMouseEvent");
		}
	}

	bool IsConnected() const
	{
		return GetSystemMetrics(SM_MOUSEPRESENT) != 0;
	}

	bool IsVisible() const
	{
		if (mMode == MODE_RELATIVE)
			return false;

		CURSORINFO info = { sizeof(CURSORINFO), 0, nullptr, {} };
		if (!GetCursorInfo(&info))
		{
			throw std::exception("GetCursorInfo");
		}

		return (info.flags & CURSOR_SHOWING) != 0;
	}

	void SetVisible(bool visible)
	{
		if (mMode == MODE_RELATIVE)
			return;

		CURSORINFO info = { sizeof(CURSORINFO), 0, nullptr, {} };
		if (!GetCursorInfo(&info))
		{
			throw std::exception("GetCursorInfo");
		}

		bool isvisible = (info.flags & CURSOR_SHOWING) != 0;
		if (isvisible != visible)
		{
			ShowCursor(visible);
		}
	}

	void SetWindow(HWND window)
	{
		if (mWindow == window)
			return;

		assert(window != nullptr);

		RAWINPUTDEVICE Rid;
		Rid.usUsagePage = 0x1 /* HID_USAGE_PAGE_GENERIC */;
		Rid.usUsage = 0x2 /* HID_USAGE_GENERIC_MOUSE */;
		Rid.dwFlags = RIDEV_INPUTSINK;
		Rid.hwndTarget = window;
		if (!RegisterRawInputDevices(&Rid, 1, sizeof(RAWINPUTDEVICE)))
		{
			throw std::exception("RegisterRawInputDevices");
		}

		mWindow = window;
	}

	State           mState;

	Mouse*          mOwner;

	static Mouse::Impl* s_mouse;

private:
	HWND            mWindow;
	Mode            mMode;

	ScopedHandle    mScrollWheelValue;
	ScopedHandle    mRelativeRead;
	ScopedHandle    mAbsoluteMode;
	ScopedHandle    mRelativeMode;

	int             mLastX;
	int             mLastY;
	int             mRelativeX;
	int             mRelativeY;

	bool            mInFocus;

	friend void Mouse::ProcessMessage(UINT message, WPARAM wParam, LPARAM lParam);

	void ClipToWindow()
	{
		assert(mWindow != nullptr);

		RECT rect;
		GetClientRect(mWindow, &rect);

		POINT ul;
		ul.x = rect.left;
		ul.y = rect.top;

		POINT lr;
		lr.x = rect.right;
		lr.y = rect.bottom;

		MapWindowPoints(mWindow, nullptr, &ul, 1);
		MapWindowPoints(mWindow, nullptr, &lr, 1);

		rect.left = ul.x;
		rect.top = ul.y;

		rect.right = lr.x;
		rect.bottom = lr.y;

		ClipCursor(&rect);
	}
};


Mouse::Impl* Mouse::Impl::s_mouse = nullptr;


void Mouse::SetWindow(HWND window)
{
	pImpl->SetWindow(window);
}


void Mouse::ProcessMessage(UINT message, WPARAM wParam, LPARAM lParam)
{
	auto pImpl = Impl::s_mouse;

	if (!pImpl)
		return;

	HANDLE evts[3];
	evts[0] = pImpl->mScrollWheelValue.get();
	evts[1] = pImpl->mAbsoluteMode.get();
	evts[2] = pImpl->mRelativeMode.get();
	switch (WaitForMultipleObjectsEx(_countof(evts), evts, FALSE, 0, FALSE))
	{
	case WAIT_OBJECT_0:
		pImpl->mState.scrollWheelValue = 0;
		ResetEvent(evts[0]);
		break;

	case (WAIT_OBJECT_0 + 1):
	{
		pImpl->mMode = MODE_ABSOLUTE;
		ClipCursor(nullptr);

		POINT point;
		point.x = pImpl->mLastX;
		point.y = pImpl->mLastY;

		// We show the cursor before moving it to support Remote Desktop
		ShowCursor(TRUE);

		if (MapWindowPoints(pImpl->mWindow, nullptr, &point, 1))
		{
			SetCursorPos(point.x, point.y);
		}
		pImpl->mState.x = pImpl->mLastX;
		pImpl->mState.y = pImpl->mLastY;
	}
	break;

	case (WAIT_OBJECT_0 + 2):
	{
		ResetEvent(pImpl->mRelativeRead.get());

		pImpl->mMode = MODE_RELATIVE;
		pImpl->mState.x = pImpl->mState.y = 0;
		pImpl->mRelativeX = INT32_MAX;
		pImpl->mRelativeY = INT32_MAX;

		ShowCursor(FALSE);

		pImpl->ClipToWindow();
	}
	break;

	case WAIT_FAILED:
		throw std::exception("WaitForMultipleObjectsEx");
	}

	switch (message)
	{
	case WM_ACTIVATEAPP:
		if (wParam)
		{
			pImpl->mInFocus = true;

			if (pImpl->mMode == MODE_RELATIVE)
			{
				pImpl->mState.x = pImpl->mState.y = 0;

				ShowCursor(FALSE);

				pImpl->ClipToWindow();
			}
		}
		else
		{
			int scrollWheel = pImpl->mState.scrollWheelValue;
			memset(&pImpl->mState, 0, sizeof(State));
			pImpl->mState.scrollWheelValue = scrollWheel;

			pImpl->mInFocus = false;
		}
		return;

	case WM_INPUT:
		if (pImpl->mInFocus && pImpl->mMode == MODE_RELATIVE)
		{
			RAWINPUT raw;
			UINT rawSize = sizeof(raw);

			UINT resultData = GetRawInputData(reinterpret_cast<HRAWINPUT>(lParam), RID_INPUT, &raw, &rawSize, sizeof(RAWINPUTHEADER));
			if (resultData == UINT(-1))
			{
				throw std::exception("GetRawInputData");
			}

			if (raw.header.dwType == RIM_TYPEMOUSE)
			{
				if (!(raw.data.mouse.usFlags & MOUSE_MOVE_ABSOLUTE))
				{
					pImpl->mState.x = raw.data.mouse.lLastX;
					pImpl->mState.y = raw.data.mouse.lLastY;

					ResetEvent(pImpl->mRelativeRead.get());
				}
				else if (raw.data.mouse.usFlags & MOUSE_VIRTUAL_DESKTOP)
				{
					// This is used to make Remote Desktop sessons work
					const int width = GetSystemMetrics(SM_CXVIRTUALSCREEN);
					const int height = GetSystemMetrics(SM_CYVIRTUALSCREEN);

					int x = static_cast<int>((float(raw.data.mouse.lLastX) / 65535.0f) * width);
					int y = static_cast<int>((float(raw.data.mouse.lLastY) / 65535.0f) * height);

					if (pImpl->mRelativeX == INT32_MAX)
					{
						pImpl->mState.x = pImpl->mState.y = 0;
					}
					else
					{
						pImpl->mState.x = x - pImpl->mRelativeX;
						pImpl->mState.y = y - pImpl->mRelativeY;
					}

					pImpl->mRelativeX = x;
					pImpl->mRelativeY = y;

					ResetEvent(pImpl->mRelativeRead.get());
				}
			}
		}
		return;

	case WM_MOUSEMOVE:
		break;

	case WM_LBUTTONDOWN:
		pImpl->mState.leftButton = true;
		break;

	case WM_LBUTTONUP:
		pImpl->mState.leftButton = false;
		break;

	case WM_RBUTTONDOWN:
		pImpl->mState.rightButton = true;
		break;

	case WM_RBUTTONUP:
		pImpl->mState.rightButton = false;
		break;

	case WM_MBUTTONDOWN:
		pImpl->mState.middleButton = true;
		break;

	case WM_MBUTTONUP:
		pImpl->mState.middleButton = false;
		break;

	case WM_MOUSEWHEEL:
		pImpl->mState.scrollWheelValue += GET_WHEEL_DELTA_WPARAM(wParam);
		return;

	case WM_XBUTTONDOWN:
		switch (GET_XBUTTON_WPARAM(wParam))
		{
		case XBUTTON1:
			pImpl->mState.xButton1 = true;
			break;

		case XBUTTON2:
			pImpl->mState.xButton2 = true;
			break;
		}
		break;

	case WM_XBUTTONUP:
		switch (GET_XBUTTON_WPARAM(wParam))
		{
		case XBUTTON1:
			pImpl->mState.xButton1 = false;
			break;

		case XBUTTON2:
			pImpl->mState.xButton2 = false;
			break;
		}
		break;

	case WM_MOUSEHOVER:
		break;

	default:
		// Not a mouse message, so exit
		return;
	}

	if (pImpl->mMode == MODE_ABSOLUTE)
	{
		// All mouse messages provide a new pointer position
		int xPos = static_cast<short>(LOWORD(lParam)); // GET_X_LPARAM(lParam);
		int yPos = static_cast<short>(HIWORD(lParam)); // GET_Y_LPARAM(lParam);

		pImpl->mState.x = pImpl->mLastX = xPos;
		pImpl->mState.y = pImpl->mLastY = yPos;
	}
}

#endif

#pragma warning( disable : 4355 )

// Public constructor.
Mouse::Mouse() noexcept(false)
	: pImpl(std::make_unique<Impl>(this))
{
}


// Move constructor.
Mouse::Mouse(Mouse&& moveFrom) noexcept
	: pImpl(std::move(moveFrom.pImpl))
{
	pImpl->mOwner = this;
}


// Move assignment.
Mouse& Mouse::operator= (Mouse&& moveFrom) noexcept
{
	pImpl = std::move(moveFrom.pImpl);
	pImpl->mOwner = this;
	return *this;
}


// Public destructor.
Mouse::~Mouse()
{
}


Mouse::State Mouse::GetState() const
{
	State state;
	pImpl->GetState(state);
	return state;
}


void Mouse::ResetScrollWheelValue()
{
	pImpl->ResetScrollWheelValue();
}


void Mouse::SetMode(Mode mode)
{
	pImpl->SetMode(mode);
}


bool Mouse::IsConnected() const
{
	return pImpl->IsConnected();
}

bool Mouse::IsVisible() const
{
	return pImpl->IsVisible();
}

void Mouse::SetVisible(bool visible)
{
	pImpl->SetVisible(visible);
}

Mouse& Mouse::Get()
{
	if (!Impl::s_mouse || !Impl::s_mouse->mOwner)
		throw std::exception("Mouse is a singleton");

	return *Impl::s_mouse->mOwner;
}



//======================================================================================
// ButtonStateTracker
//======================================================================================

#define UPDATE_BUTTON_STATE(field) field = static_cast<ButtonState>( ( !!state.field ) | ( ( !!state.field ^ !!lastState.field ) << 1 ) );

void Mouse::ButtonStateTracker::Update(const Mouse::State& state)
{
	UPDATE_BUTTON_STATE(leftButton);

	assert((!state.leftButton && !lastState.leftButton) == (leftButton == UP));
	assert((state.leftButton && lastState.leftButton) == (leftButton == HELD));
	assert((!state.leftButton && lastState.leftButton) == (leftButton == RELEASED));
	assert((state.leftButton && !lastState.leftButton) == (leftButton == PRESSED));

	UPDATE_BUTTON_STATE(middleButton);
	UPDATE_BUTTON_STATE(rightButton);
	UPDATE_BUTTON_STATE(xButton1);
	UPDATE_BUTTON_STATE(xButton2);

	lastState = state;
}

#undef UPDATE_BUTTON_STATE


void Mouse::ButtonStateTracker::Reset() noexcept
{
	memset(this, 0, sizeof(ButtonStateTracker));
}

```

`Direct3D11-Source/Mouse.h`:

```h
//--------------------------------------------------------------------------------------
// File: Mouse.h
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
// http://go.microsoft.com/fwlink/?LinkId=248929
// http://go.microsoft.com/fwlink/?LinkID=615561
//--------------------------------------------------------------------------------------

#pragma once

#include <memory>

namespace DirectX
{
	class Mouse
	{
	public:
		Mouse() noexcept(false);
		Mouse(Mouse&& moveFrom) noexcept;
		Mouse& operator= (Mouse&& moveFrom) noexcept;

		Mouse(Mouse const&) = delete;
		Mouse& operator=(Mouse const&) = delete;

		virtual ~Mouse();

		enum Mode
		{
			MODE_ABSOLUTE = 0,
			MODE_RELATIVE,
		};

		struct State
		{
			bool    leftButton;
			bool    middleButton;
			bool    rightButton;
			bool    xButton1;
			bool    xButton2;
			int     x;
			int     y;
			int     scrollWheelValue;
			Mode    positionMode;
		};

		class ButtonStateTracker
		{
		public:
			enum ButtonState
			{
				UP = 0,         // Button is up
				HELD = 1,       // Button is held down
				RELEASED = 2,   // Button was just released
				PRESSED = 3,    // Buton was just pressed
			};

			ButtonState leftButton;
			ButtonState middleButton;
			ButtonState rightButton;
			ButtonState xButton1;
			ButtonState xButton2;

#pragma prefast(suppress: 26495, "Reset() performs the initialization")
			ButtonStateTracker() noexcept { Reset(); }

			void __cdecl Update(const State& state);

			void __cdecl Reset() noexcept;

			State __cdecl GetLastState() const { return lastState; }

		private:
			State lastState;
		};

		// Retrieve the current state of the mouse
		State __cdecl GetState() const;

		// Resets the accumulated scroll wheel value
		void __cdecl ResetScrollWheelValue();

		// Sets mouse mode (defaults to absolute)
		void __cdecl SetMode(Mode mode);

		// Feature detection
		bool __cdecl IsConnected() const;

		// Cursor visibility
		bool __cdecl IsVisible() const;
		void __cdecl SetVisible(bool visible);

#if !defined(WINAPI_FAMILY) || (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP) && defined(WM_USER)
		void __cdecl SetWindow(HWND window);
		static void __cdecl ProcessMessage(UINT message, WPARAM wParam, LPARAM lParam);
#endif
		// Singleton
		static Mouse& __cdecl Get();

	private:
		// Private implementation.
		class Impl;

		std::unique_ptr<Impl> pImpl;
	};
}
```

`Direct3D11-Source/Rubik.cpp`:

```cpp
#include "Rubik.h"
#include "d3dUtil.h"
#include "Vertex.h"
#include <fstream>
using namespace DirectX;
using namespace Microsoft::WRL;

DirectX::XMMATRIX Cube::GetWorldMatrix() const
{
	XMVECTOR posVec = XMLoadFloat3(&pos);
	// rotation必然最多只有一个分量是非0，保证其只会绕其中一个轴进行旋转
	XMMATRIX R = XMMatrixRotationRollPitchYaw(rotation.x, rotation.y, rotation.z);
	posVec = XMVector3TransformCoord(posVec, R);
	// 立方体转动后最终的位置
	XMFLOAT3 finalPos;
	XMStoreFloat3(&finalPos, posVec);

	return XMMatrixRotationRollPitchYaw(rotation.x, rotation.y, rotation.z) *
		XMMatrixTranslation(finalPos.x, finalPos.y, finalPos.z);
}

Rubik::Rubik()
	: mRotationSpeed(XM_2PI)
{
}

void Rubik::InitResources(ComPtr<ID3D11Device> device, ComPtr<ID3D11DeviceContext> deviceContext)
{

	std::vector<std::wstring> filenames {
		L"Resource/Black.dds",
		L"Resource/Orange.dds",
		L"Resource/Red.dds",
		L"Resource/Green.dds",
		L"Resource/Blue.dds",
		L"Resource/Yellow.dds",
		L"Resource/White.dds",
	};

	// 检验所有文件是否存在
	bool fileExists = true;
	for (const std::wstring& filename : filenames)
	{
		std::wifstream wfin(filename);
		if (!wfin.is_open())
		{
			fileExists = false;
			wfin.close();
			break;
		}
		wfin.close();
	}
	if (fileExists)
	{
		// 从文件读取
		mTexArray = CreateDDSTexture2DArrayFromFile(device, deviceContext, filenames);
	}
	else
	{
		// 从内存读取
		// 后续可能会写专门的通用函数
		mTexArray = CreateRubikCubeTextureArrayFromMemory(device, deviceContext);
	}

	//
	// 初始化立方体网格模型
	//

	VertexPosTex vertices[] = {
		// +X面
		{ XMFLOAT3(1.0f, -1.0f, -1.0f), XMFLOAT2(1.0f, 0.0f) },
		{ XMFLOAT3(1.0f, 1.0f, -1.0f), XMFLOAT2(0.0f, 0.0f) },
		{ XMFLOAT3(1.0f, 1.0f, 1.0f), XMFLOAT2(0.0f, 1.0f) },
		{ XMFLOAT3(1.0f, -1.0f, 1.0f), XMFLOAT2(1.0f, 1.0f) },
		// -X面
		{ XMFLOAT3(-1.0f, -1.0f, 1.0f), XMFLOAT2(1.0f, 0.0f) },
		{ XMFLOAT3(-1.0f, 1.0f, 1.0f), XMFLOAT2(0.0f, 0.0f) },
		{ XMFLOAT3(-1.0f, 1.0f, -1.0f), XMFLOAT2(0.0f, 1.0f) },
		{ XMFLOAT3(-1.0f, -1.0f, -1.0f), XMFLOAT2(1.0f, 1.0f) },
		// +Y面
		{ XMFLOAT3(-1.0f, 1.0f, -1.0f), XMFLOAT2(1.0f, 0.0f) },
		{ XMFLOAT3(-1.0f, 1.0f, 1.0f), XMFLOAT2(0.0f, 0.0f) },
		{ XMFLOAT3(1.0f, 1.0f, 1.0f), XMFLOAT2(0.0f, 1.0f) },
		{ XMFLOAT3(1.0f, 1.0f, -1.0f), XMFLOAT2(1.0f, 1.0f) },
		// -Y面
		{ XMFLOAT3(-1.0f, -1.0f, 1.0f), XMFLOAT2(1.0f, 0.0f) },
		{ XMFLOAT3(-1.0f, -1.0f, -1.0f), XMFLOAT2(0.0f, 0.0f) },
		{ XMFLOAT3(1.0f, -1.0f, -1.0f), XMFLOAT2(0.0f, 1.0f) },
		{ XMFLOAT3(1.0f, -1.0f, 1.0f), XMFLOAT2(1.0f, 1.0f) },
		// +Z面
		{ XMFLOAT3(1.0f, -1.0f, 1.0f), XMFLOAT2(1.0f, 0.0f) },
		{ XMFLOAT3(1.0f, 1.0f, 1.0f), XMFLOAT2(0.0f, 0.0f) },
		{ XMFLOAT3(-1.0f, 1.0f, 1.0f), XMFLOAT2(0.0f, 1.0f) },
		{ XMFLOAT3(-1.0f, -1.0f, 1.0f), XMFLOAT2(1.0f, 1.0f) },
		// -Z面
		{ XMFLOAT3(-1.0f, -1.0f, -1.0f), XMFLOAT2(1.0f, 0.0f) },
		{ XMFLOAT3(-1.0f, 1.0f, -1.0f), XMFLOAT2(0.0f, 0.0f) },
		{ XMFLOAT3(1.0f, 1.0f, -1.0f), XMFLOAT2(0.0f, 1.0f) },
		{ XMFLOAT3(1.0f, -1.0f, -1.0f), XMFLOAT2(1.0f, 1.0f) },
	};

	// 设置顶点缓冲区描述
	D3D11_BUFFER_DESC vbd;
	ZeroMemory(&vbd, sizeof(vbd));
	vbd.Usage = D3D11_USAGE_IMMUTABLE;
	vbd.ByteWidth = sizeof vertices;
	vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	vbd.CPUAccessFlags = 0;
	// 新建顶点缓冲区
	D3D11_SUBRESOURCE_DATA initData;
	ZeroMemory(&initData, sizeof(initData));
	initData.pSysMem = vertices;
	HR(device->CreateBuffer(&vbd, &initData, mVertexBuffer.ReleaseAndGetAddressOf()));
	

	WORD indices[] = { 0, 1, 2, 2, 3, 0 };
	// 设置索引缓冲区描述
	D3D11_BUFFER_DESC ibd;
	ZeroMemory(&ibd, sizeof(ibd));
	ibd.Usage = D3D11_USAGE_IMMUTABLE;
	ibd.ByteWidth = sizeof indices;
	ibd.BindFlags = D3D11_BIND_INDEX_BUFFER;
	ibd.CPUAccessFlags = 0;
	// 新建索引缓冲区
	initData.pSysMem = indices;
	HR(device->CreateBuffer(&ibd, &initData, mIndexBuffer.ReleaseAndGetAddressOf()));

	// 初始化魔方所有面
	Reset();

	// 预先绑定顶点/索引缓冲区到渲染管线
	UINT strides[1] = { sizeof(VertexPosTex) };
	UINT offsets[1] = { 0 };
	deviceContext->IASetVertexBuffers(0, 1, mVertexBuffer.GetAddressOf(), strides, offsets);
	deviceContext->IASetIndexBuffer(mIndexBuffer.Get(), DXGI_FORMAT_R16_UINT, 0);

}

void Rubik::Reset()
{
	mIsLocked = false;
	mIsPressed = false;

	// 初始化魔方中心位置，用六个面默认填充黑色
	for (int i = 0; i < 3; ++i)
		for (int j = 0; j < 3; ++j)
			for (int k = 0; k < 3; ++k)
			{
				mCubes[i][j][k].pos = XMFLOAT3(-2.0f + 2.0f * i,
					-2.0f + 2.0f * j, -2.0f + 2.0f * k);
				mCubes[i][j][k].rotation = XMFLOAT3(0.0f, 0.0f, 0.0f);
				memset(mCubes[i][j][k].faceColors, 0, 
					sizeof mCubes[i][j][k].faceColors);
			}
	
	// +X面为橙色，-X面为红色
	// +Y面为绿色，-Y面为蓝色
	// +Z面为黄色，-Z面为白色
	for (int i = 0; i < 3; ++i)
		for (int j = 0; j < 3; ++j)
		{
			mCubes[2][i][j].faceColors[RubikFace_PosX] = RubikFaceColor_Orange;
			mCubes[0][i][j].faceColors[RubikFace_NegX] = RubikFaceColor_Red;

			mCubes[j][2][i].faceColors[RubikFace_PosY] = RubikFaceColor_Green;
			mCubes[j][0][i].faceColors[RubikFace_NegY] = RubikFaceColor_Blue;

			mCubes[i][j][2].faceColors[RubikFace_PosZ] = RubikFaceColor_Yellow;
			mCubes[i][j][0].faceColors[RubikFace_NegZ] = RubikFaceColor_White;
		}	


}

void Rubik::Update(float dt)
{
	if (mIsLocked)
	{
		int finishCount = 0;
		for (int i = 0; i < 3; ++i)
		{
			for (int j = 0; j < 3; ++j)
			{
				for (int k = 0; k < 3; ++k)
				{
					// 令x，y, z轴向旋转角度逐渐归0
					// x轴
					float dTheta = (signbit(mCubes[i][j][k].rotation.x) ? -1.0f : 1.0f) * dt * mRotationSpeed;
					if (fabs(mCubes[i][j][k].rotation.x) < fabs(dTheta))
					{
						mCubes[i][j][k].rotation.x = 0.0f;
						finishCount++;
					}
					else
					{
						mCubes[i][j][k].rotation.x -= dTheta;
					}
					// y轴
					dTheta = (signbit(mCubes[i][j][k].rotation.y) ? -1.0f : 1.0f) * dt * mRotationSpeed;
					if (fabs(mCubes[i][j][k].rotation.y) < fabs(dTheta))
					{
						mCubes[i][j][k].rotation.y = 0.0f;
						finishCount++;
					}
					else
					{
						mCubes[i][j][k].rotation.y -= dTheta;
					}
					// z轴
					dTheta = (signbit(mCubes[i][j][k].rotation.z) ? -1.0f : 1.0f) * dt * mRotationSpeed;
					if (fabs(mCubes[i][j][k].rotation.z) < fabs(dTheta))
					{
						mCubes[i][j][k].rotation.z = 0.0f;
						finishCount++;
					}
					else
					{
						mCubes[i][j][k].rotation.z -= dTheta;
					}
				}
			}
		}

		// 所有方块都结束动画才能解锁
		if (finishCount == 81)
			mIsLocked = false;
	}
}

void Rubik::Draw(ComPtr<ID3D11DeviceContext> deviceContext, BasicEffect& effect)
{
	for (int i = 0; i < 3; ++i)
	{
		for (int j = 0; j < 3; ++j)
		{
			for (int k = 0; k < 3; ++k)
			{
				effect.SetWorldMatrix(mCubes[i][j][k].GetWorldMatrix());
				for (int face = 0; face < 6; ++face)
				{
					effect.SetTexIndex(mCubes[i][j][k].faceColors[face]);
					effect.Apply(deviceContext);
					deviceContext->DrawIndexed(6, 0, 4 * face);
				}
			}
		}
	}	
}

bool Rubik::IsLocked() const
{
	return mIsLocked;
}

bool Rubik::IsCompleted() const
{
	RubikFaceColor posX, negX, posY, negY, posZ, negZ;
	posX = mCubes[2][0][0].faceColors[0];
	negX = mCubes[0][0][0].faceColors[1];
	posY = mCubes[0][2][0].faceColors[2];
	negY = mCubes[0][0][0].faceColors[3];
	posZ = mCubes[0][0][2].faceColors[4];
	negZ = mCubes[0][0][0].faceColors[5];

	for (int j = 0; j < 3; ++j)
		for (int k = 0; k < 3; ++k)
			if (mCubes[2][j][k].faceColors[0] != posX || mCubes[0][j][k].faceColors[1] != negX)
				return false;

	for (int k = 0; k < 3; ++k)
		for (int i = 0; i < 3; ++i)
			if (mCubes[i][2][k].faceColors[2] != posY || mCubes[i][0][k].faceColors[3] != negY)
				return false;

	for (int i = 0; i < 3; ++i)
		for (int j = 0; j < 3; ++j)
			if (mCubes[i][j][2].faceColors[4] != posZ || mCubes[i][j][0].faceColors[5] != negZ)
				return false;

	return true;
}

DirectX::XMINT3 Rubik::HitCube(Ray ray, float * pDist) const
{
	BoundingOrientedBox box(XMFLOAT3(0.0f, 0.0f, 0.0f), XMFLOAT3(1.0f, 1.0f, 1.0f), XMFLOAT4(0.0f, 0.0f, 0.0f, 1.0f));
	BoundingOrientedBox transformedBox;
	XMINT3 res = XMINT3(-1, -1, -1);
	float dist, minDist = FLT_MAX;

	// 优先拾取暴露在外的立方体(同时也是距离摄像机最近的)
	for (int i = 0; i < 3; ++i)
	{
		for (int j = 0; j < 3; ++j)
		{
			for (int k = 0; k < 3; ++k)
			{
				box.Transform(transformedBox, mCubes[i][j][k].GetWorldMatrix());
				if (ray.Hit(transformedBox, &dist) && dist < minDist)
				{
					minDist = dist;
					res = XMINT3(i, j, k);
				}
			}
		}
	}
	if (pDist)
		*pDist = (minDist == FLT_MAX ? 0.0f : minDist);
		
	return res;
}

void Rubik::RotateX(int pos, float dTheta, bool isPressed)
{
	if (!mIsLocked)
	{
		// 检验当前是否为键盘操作
		// 可以认为仅当键盘操作时才会产生绝对值为pi/2的倍数(不包括0)的瞬时值
		bool isKeyOp =  static_cast<int>(round(dTheta / XM_PIDIV2)) != 0 &&
			(fabs(fmod(dTheta, XM_PIDIV2) < 1e-5f));
		// 键盘输入和鼠标操作互斥，拒绝键盘的操作
		if (mIsPressed && isKeyOp)
		{
			return;
		}

		mIsPressed = isPressed;

		// 更新旋转状态
		for (int j = 0; j < 3; ++j)
			for (int k = 0; k < 3; ++k)
			{
				switch (pos)
				{
				case 3: mCubes[0][j][k].rotation.x += dTheta;
				case -2: mCubes[1][j][k].rotation.x += dTheta;
					mCubes[2][j][k].rotation.x += dTheta;
					break;
				case -1: mCubes[0][j][k].rotation.x += dTheta; 
					mCubes[1][j][k].rotation.x += dTheta; 
					break;
				
				default: mCubes[pos][j][k].rotation.x += dTheta;
				}
				
			}
				

		// 鼠标或键盘操作完成
		if (!mIsPressed)
		{
			// 开始动画演示状态
			mIsLocked = true;

			// 进行预旋转
			PreRotateX(isKeyOp);
		}
	}
}

void Rubik::RotateY(int pos, float dTheta, bool isPressed)
{
	if (!mIsLocked)
	{
		// 检验当前是否为键盘操作
		// 可以认为仅当键盘操作时才会产生绝对值为pi/2的倍数(不包括0)的瞬时值
		bool isKeyOp = static_cast<int>(round(dTheta / XM_PIDIV2)) != 0 &&
			(fabs(fmod(dTheta, XM_PIDIV2) < 1e-5f));
		// 键盘输入和鼠标操作互斥，拒绝键盘的操作
		if (mIsPressed && isKeyOp)
		{
			return;
		}

		

		for (int k = 0; k < 3; ++k)
			for (int i = 0; i < 3; ++i)
			{
				switch (pos)
				{
				case 3: mCubes[i][0][k].rotation.y += dTheta;
				case -2: mCubes[i][1][k].rotation.y += dTheta;
					mCubes[i][2][k].rotation.y += dTheta;
					break;
				case -1: mCubes[i][0][k].rotation.y += dTheta;
					mCubes[i][1][k].rotation.y += dTheta;
					break;
				
				default: mCubes[i][pos][k].rotation.y += dTheta;
				}
			}

		mIsPressed = isPressed;

		// 鼠标或键盘操作完成
		if (!mIsPressed)
		{
			// 开始动画演示状态
			mIsLocked = true;

			// 进行预旋转
			PreRotateY(isKeyOp);
		}
	}
}

void Rubik::RotateZ(int pos, float dTheta, bool isPressed)
{
	if (!mIsLocked)
	{
		// 检验当前是否为键盘操作
		// 可以认为仅当键盘操作时才会产生绝对值为pi/2的倍数(不包括0)的瞬时值
		bool isKeyOp = static_cast<int>(round(dTheta / XM_PIDIV2)) != 0 &&
			(fabs(fmod(dTheta, XM_PIDIV2) < 1e-5f));
		// 键盘输入和鼠标操作互斥，拒绝键盘的操作
		if (mIsPressed && isKeyOp)
		{
			return;
		}

		mIsPressed = isPressed;

		for (int i = 0; i < 3; ++i)
			for (int j = 0; j < 3; ++j)
			{
				switch (pos)
				{
				case 3: mCubes[i][j][0].rotation.z += dTheta;
				case -2: mCubes[i][j][1].rotation.z += dTheta;
					mCubes[i][j][2].rotation.z += dTheta;
					break;
				case -1: mCubes[i][j][0].rotation.z += dTheta;
					mCubes[i][j][1].rotation.z += dTheta;
					break;
				
				default: mCubes[i][j][pos].rotation.z += dTheta;
				}
			}

				

		// 鼠标或键盘操作完成
		if (!mIsPressed)
		{
			// 开始动画演示状态
			mIsLocked = true;

			// 进行预旋转
			PreRotateZ(isKeyOp);
		}
	}
}

void Rubik::SetRotationSpeed(float rad)
{
	assert(rad > 0.0f);
	mRotationSpeed = rad;
}

ComPtr<ID3D11ShaderResourceView> Rubik::GetTexArray() const
{
	return mTexArray;
}

ComPtr<ID3D11ShaderResourceView> Rubik::CreateRubikCubeTextureArrayFromMemory(
	ComPtr<ID3D11Device> device,
	ComPtr<ID3D11DeviceContext> deviceContext)
{
	// 只有文件缺失的情况才会来到这里
	// 从内存创建

	// 创建纹理数组
	D3D11_TEXTURE2D_DESC texArrayDesc;
	texArrayDesc.Width = 128;
	texArrayDesc.Height = 128;
	texArrayDesc.MipLevels = 0;	// 指定后将生成完整mipmap链
	texArrayDesc.ArraySize = 7;
	texArrayDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	texArrayDesc.SampleDesc.Count = 1;		// 不使用多重采样
	texArrayDesc.SampleDesc.Quality = 0;
	texArrayDesc.Usage = D3D11_USAGE_DEFAULT;
	texArrayDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;	// 生成mipmap需要绑定渲染目标
	texArrayDesc.CPUAccessFlags = 0;
	texArrayDesc.MiscFlags = D3D11_RESOURCE_MISC_GENERATE_MIPS;	// 指定需要生成mipmap

	ComPtr<ID3D11Texture2D> texArray;
	HR(device->CreateTexture2D(&texArrayDesc, nullptr, texArray.GetAddressOf()));
	// 创建后立马获取纹理数组描述以获取生成的mipLevel
	texArray->GetDesc(&texArrayDesc);

	// (r, g, b, a)
	unsigned colors[7] = {
		'\x0\x0\x0\xff',		// 黑色
		'\xff\x6c\x0\xff',		// 橙色
		'\xdc\x42\x2f\xff',		// 红色
		'\x0\x9d\x54\xff',		// 绿色
		'\x3d\x81\xf6\xff',		// 蓝色
		'\xfd\xcc\x9\xff',		// 黄色
		'\xff\xff\xff\xff'		// 白色
	};


	uint32_t textureMap[128][128];
	// 默认先创建黑色
	for (int i = 0; i < 128; ++i)
		for (int j = 0; j < 128; ++j)
			textureMap[i][j] = colors[0];

	deviceContext->UpdateSubresource(texArray.Get(),
		D3D11CalcSubresource(0, 0, texArrayDesc.MipLevels),
		nullptr,
		textureMap, 
		128 * 4,
		128 * 128 * 4
	);
	// 创建其它颜色的纹理
	for (int i = 1; i <= 6; ++i)
	{
		for (int y = 7; y <= 17; ++y)
			for (int x = 25 - y; x <= 102 + y; ++x)
				textureMap[y][x] = textureMap[127 - y][x] = colors[i];

		for (int y = 18; y <= 109; ++y)
			for (int x = 7; x <= 120; ++x)
				textureMap[y][x] = colors[i];


		// 更新数据
		deviceContext->UpdateSubresource(texArray.Get(),
			D3D11CalcSubresource(0, i, texArrayDesc.MipLevels),
			nullptr,
			textureMap,
			128 * 4,
			128 * 128 * 4
		);

	}
	// 创建纹理数组的SRV
	D3D11_SHADER_RESOURCE_VIEW_DESC viewDesc;
	viewDesc.Format = texArrayDesc.Format;
	viewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2DARRAY;
	viewDesc.Texture2DArray.MostDetailedMip = 0;
	viewDesc.Texture2DArray.MipLevels = -1;	// 生成mipamp
	viewDesc.Texture2DArray.FirstArraySlice = 0;
	viewDesc.Texture2DArray.ArraySize = 7;

	ComPtr<ID3D11ShaderResourceView> texArraySRV;
	HR(device->CreateShaderResourceView(texArray.Get(), &viewDesc, texArraySRV.GetAddressOf()));
	// 生成mipmap
	deviceContext->GenerateMips(texArraySRV.Get());
	return texArraySRV;
}

void Rubik::PreRotateX(bool isKeyOp)
{
	for (int i = 0; i < 3; ++i)
	{
		// 当前层没有旋转则直接跳过
		if (fabs(mCubes[i][0][0].rotation.x) < 1e-5f)
			continue;
		// 由于此时被旋转面的所有方块旋转角度都是一样的，可以从中取一个来计算。
		// 计算归位回[-pi/4, pi/4)区间需要顺时针旋转90度的次数
		int times = static_cast<int>(round(mCubes[i][0][0].rotation.x / XM_PIDIV2));
		// 将归位次数映射到[0, 3]，以计算最小所需顺时针旋转90度的次数
		int minTimes = (times % 4 + 4) % 4;

		// 调整所有被旋转方块的初始角度
		for (int j = 0; j < 3; ++j)
		{
			for (int k = 0; k < 3; ++k)
			{
				// 键盘按下后的变化
				if (isKeyOp)
				{
					// 顺时针旋转90度--->实际演算从-90度加到0度
					// 逆时针旋转90度--->实际演算从90度减到0度
					mCubes[i][j][k].rotation.x *= -1.0f;
				}
				// 鼠标释放后的变化
				else
				{
					// 归位回[-pi/4, pi/4)的区间
					mCubes[i][j][k].rotation.x -= times * XM_PIDIV2;
				}
			}
		}

		std::vector<XMINT2> indices1, indices2;
		GetSwapIndexArray(minTimes, indices1, indices2);
		size_t swapTimes = indices1.size();
		for (size_t idx = 0; idx < swapTimes; ++idx)
		{
			// 对这两个立方体按规则进行面的交换
			XMINT2 srcIndex = indices1[idx];
			XMINT2 targetIndex = indices2[idx];
			// 若为2次顺时针旋转，则只需4次对角调换
			// 否则，需要6次邻角(棱)对换
			for (int face = 0; face < 6; ++face)
			{
				std::swap(mCubes[i][srcIndex.x][srcIndex.y].faceColors[face],
					mCubes[i][targetIndex.x][targetIndex.y].faceColors[
						GetTargetSwapFaceRotationX(static_cast<RubikFace>(face), minTimes)]);
			}
		}
	}
}

void Rubik::PreRotateY(bool isKeyOp)
{
	for (int j = 0; j < 3; ++j)
	{
		// 当前层没有旋转则直接跳过
		if (fabs(mCubes[0][j][0].rotation.y) < 1e-5f)
			continue;
		// 由于此时被旋转面的所有方块旋转角度都是一样的，可以从中取一个来计算。
		// 计算归位回[-pi/4, pi/4)区间需要顺时针旋转90度的次数
		int times = static_cast<int>(round(mCubes[0][j][0].rotation.y / XM_PIDIV2));
		// 将归位次数映射到[0, 3]，以计算最小所需顺时针旋转90度的次数
		int minTimes = (times % 4 + 4) % 4;

		// 调整所有被旋转方块的初始角度
		for (int k = 0; k < 3; ++k)
		{
			for (int i = 0; i < 3; ++i)
			{
				// 可以认为仅当键盘操作时才会产生绝对值为pi/2的瞬时值
				// 键盘按下后的变化
				if (isKeyOp)
				{
					// 顺时针旋转90度--->实际演算从-90度加到0度
					// 逆时针旋转90度--->实际演算从90度减到0度
					mCubes[i][j][k].rotation.y *= -1.0f;
				}
				// 鼠标释放后的变化
				else
				{
					// 归位回[-pi/4, pi/4)的区间
					mCubes[i][j][k].rotation.y -= times * XM_PIDIV2;
				}
			}
		}

		std::vector<XMINT2> indices1, indices2;
		GetSwapIndexArray(minTimes, indices1, indices2);
		size_t swapTimes = indices1.size();
		for (size_t idx = 0; idx < swapTimes; ++idx)
		{
			// 对这两个立方体按规则进行面的交换
			XMINT2 srcIndex = indices1[idx];
			XMINT2 targetIndex = indices2[idx];
			// 若为2次顺时针旋转，则只需4次对角调换
			// 否则，需要6次邻角(棱)对换
			for (int face = 0; face < 6; ++face)
			{
				std::swap(mCubes[srcIndex.y][j][srcIndex.x].faceColors[face],
					mCubes[targetIndex.y][j][targetIndex.x].faceColors[
						GetTargetSwapFaceRotationY(static_cast<RubikFace>(face), minTimes)]);
			}
		}
	}
}

void Rubik::PreRotateZ(bool isKeyOp)
{
	for (int k = 0; k < 3; ++k)
	{
		// 当前层没有旋转则直接跳过
		if (fabs(mCubes[0][0][k].rotation.z) < 1e-5f)
			continue;

		// 由于此时被旋转面的所有方块旋转角度都是一样的，可以从中取一个来计算。
		// 计算归位回[-pi/4, pi/4)区间需要顺时针旋转90度的次数
		int times = static_cast<int>(round(mCubes[0][0][k].rotation.z / XM_PIDIV2));
		// 将归位次数映射到[0, 3]，以计算最小所需顺时针旋转90度的次数
		int minTimes = (times % 4 + 4) % 4;

		// 调整所有被旋转方块的初始角度
		for (int i = 0; i < 3; ++i)
		{
			for (int j = 0; j < 3; ++j)
			{
				// 可以认为仅当键盘操作时才会产生绝对值为pi/2的瞬时值
				// 键盘按下后的变化
				if (isKeyOp)
				{
					// 顺时针旋转90度--->实际演算从-90度加到0度
					// 逆时针旋转90度--->实际演算从90度减到0度
					mCubes[i][j][k].rotation.z *= -1.0f;
				}
				// 鼠标释放后的变化
				else
				{
					// 归位回[-pi/4, pi/4)的区间
					mCubes[i][j][k].rotation.z -= times * XM_PIDIV2;
				}
			}
		}

		std::vector<XMINT2> indices1, indices2;
		GetSwapIndexArray(minTimes, indices1, indices2);
		size_t swapTimes = indices1.size();
		for (size_t idx = 0; idx < swapTimes; ++idx)
		{
			// 对这两个立方体按规则进行面的交换
			XMINT2 srcIndex = indices1[idx];
			XMINT2 targetIndex = indices2[idx];
			// 若为2次顺时针旋转，则只需4次对角调换
			// 否则，需要6次邻角(棱)对换
			for (int face = 0; face < 6; ++face)
			{
				std::swap(mCubes[srcIndex.x][srcIndex.y][k].faceColors[face],
					mCubes[targetIndex.x][targetIndex.y][k].faceColors[
						GetTargetSwapFaceRotationZ(static_cast<RubikFace>(face), minTimes)]);
			}
		}
	}
}

void Rubik::GetSwapIndexArray(int minTimes, std::vector<DirectX::XMINT2>& outArr1, std::vector<DirectX::XMINT2>& outArr2) const
{
	// 进行一次顺时针90度旋转相当逆时针交换6次(顶角和棱各3次)
	// 1   2   4   2   4   2   4   1
	//   *   ->  *   ->  *   ->  *
	// 4   3   1   3   3   1   3   2
	if (minTimes == 1)
	{
		outArr1 = { XMINT2(0, 0), XMINT2(0, 1), XMINT2(0, 2), XMINT2(1, 2), XMINT2(2, 2), XMINT2(2, 1) };
		outArr2 = { XMINT2(0, 2), XMINT2(1, 2), XMINT2(2, 2), XMINT2(2, 1), XMINT2(2, 0), XMINT2(1, 0) };
	}
	// 进行一次顺时针90度旋转相当逆时针交换4次(顶角和棱各2次)
	// 1   2   3   2   3   4
	//   *   ->  *   ->  *  
	// 4   3   4   1   2   1
	else if (minTimes == 2)
	{
		outArr1 = { XMINT2(0, 0), XMINT2(0, 1), XMINT2(0, 2), XMINT2(1, 2) };
		outArr2 = { XMINT2(2, 2), XMINT2(2, 1), XMINT2(2, 0), XMINT2(1, 0) };
	}
	// 进行一次顺时针90度旋转相当逆时针交换6次(顶角和棱各3次)
	// 1   2   4   2   4   2   4   1
	//   *   ->  *   ->  *   ->  *
	// 4   3   1   3   3   1   3   2
	else if (minTimes == 3)
	{
		outArr1 = { XMINT2(0, 0), XMINT2(1, 0), XMINT2(2, 0), XMINT2(2, 1), XMINT2(2, 2), XMINT2(1, 2) };
		outArr2 = { XMINT2(2, 0), XMINT2(2, 1), XMINT2(2, 2), XMINT2(1, 2), XMINT2(0, 2), XMINT2(0, 1) };
	}
	// 0次顺时针旋转不变，其余异常数值也不变
	else
	{
		outArr1.clear();
		outArr2.clear();
	}
	
}

RubikFace Rubik::GetTargetSwapFaceRotationX(RubikFace face, int times) const
{
	if (face == RubikFace_PosX || face == RubikFace_NegX)
		return face;
	while (times--)
	{
		switch (face)
		{
		case RubikFace_PosY: face = RubikFace_NegZ; break;
		case RubikFace_PosZ: face = RubikFace_PosY; break;
		case RubikFace_NegY: face = RubikFace_PosZ; break;
		case RubikFace_NegZ: face = RubikFace_NegY; break;
		}
	}
	return face;
}

RubikFace Rubik::GetTargetSwapFaceRotationY(RubikFace face, int times) const
{
	if (face == RubikFace_PosY || face == RubikFace_NegY)
		return face;
	while (times--)
	{
		switch (face)
		{
		case RubikFace_PosZ: face = RubikFace_NegX; break;
		case RubikFace_PosX: face = RubikFace_PosZ; break;
		case RubikFace_NegZ: face = RubikFace_PosX; break;
		case RubikFace_NegX: face = RubikFace_NegZ; break;
		}
	}
	return face;
}

RubikFace Rubik::GetTargetSwapFaceRotationZ(RubikFace face, int times) const
{
	if (face == RubikFace_PosZ || face == RubikFace_NegZ)
		return face;
	while (times--)
	{
		switch (face)
		{
		case RubikFace_PosX: face = RubikFace_NegY; break;
		case RubikFace_PosY: face = RubikFace_PosX; break;
		case RubikFace_NegX: face = RubikFace_PosY; break;
		case RubikFace_NegY: face = RubikFace_NegX; break;
		}
	}
	return face;
}

```

`Direct3D11-Source/Rubik.h`:

```h
#ifndef RUBIK_H
#define RUBIK_H

#include <wrl/client.h>
#include "Effects.h"
#include "Collision.h"
#include <vector>
#include <stack>

enum RubikFaceColor {
	RubikFaceColor_Black,		// 黑色
	RubikFaceColor_Orange,		// 橙色
	RubikFaceColor_Red,			// 红色
	RubikFaceColor_Green,		// 绿色
	RubikFaceColor_Blue,		// 蓝色
	RubikFaceColor_Yellow,		// 黄色
	RubikFaceColor_White		// 白色
};

enum RubikFace {
	RubikFace_PosX,		// +X面
	RubikFace_NegX,		// -X面
	RubikFace_PosY,		// +Y面
	RubikFace_NegY,		// -Y面
	RubikFace_PosZ,		// +Z面
	RubikFace_NegZ,		// -Z面
};

enum RubikRotationAxis {
	RubikRotationAxis_X,	// 绕X轴旋转
	RubikRotationAxis_Y,	// 绕Y轴旋转
	RubikRotationAxis_Z,	// 绕Z轴旋转
};

struct RubikRotationRecord
{
	RubikRotationAxis axis;	// 当前旋转轴
	int pos;				// 当前旋转层的索引
	float dTheta;			// 当前旋转的弧度
};

struct Cube
{
	// 获取当前立方体的世界矩阵
	DirectX::XMMATRIX GetWorldMatrix() const;

	RubikFaceColor faceColors[6];	// 六个面的颜色，索引0-5分别对应+X, -X, +Y, -Y, +Z, -Z面
	DirectX::XMFLOAT3 pos;			// 旋转结束后中心所处位置
	DirectX::XMFLOAT3 rotation;		// 仅允许存在单轴旋转，记录当前分别绕x轴, y轴, z轴旋转的弧度

};


class Rubik
{
public:
	template<class T>
	using ComPtr = Microsoft::WRL::ComPtr<T>;

	Rubik();

	// 初始化资源
	void InitResources(ComPtr<ID3D11Device> device, ComPtr<ID3D11DeviceContext> deviceContext);
	// 立即复原魔方
	void Reset();
	// 更新魔方状态
	void Update(float dt);
	// 绘制魔方
	void Draw(ComPtr<ID3D11DeviceContext> deviceContext, BasicEffect& effect);
	// 当前是否在进行动画中
	bool IsLocked() const;
	// 当前魔方是否还原
	bool IsCompleted() const;


	// 当前射线拾取到哪个立方体(只考虑可见立方体)的对应索引，未找到则返回(-1, -1, -1)
	DirectX::XMINT3 HitCube(Ray ray, float * pDist = nullptr) const;



	// pos的取值为0-2时，绕X轴旋转魔方指定层 
	// pos的取值为-1时，绕X轴旋转魔方pos为0和1的两层
	// pos的取值为-2时，绕X轴旋转魔方pos为1和2的两层
	// pos的取值为3时，绕X轴旋转整个魔方
	void RotateX(int pos, float dTheta, bool isPressed = false);

	// pos的取值为3时，绕Y轴旋转魔方指定层 
	// pos的取值为-1时，绕Y轴旋转魔方pos为0和1的两层
	// pos的取值为-2时，绕Y轴旋转魔方pos为1和2的两层
	// pos的取值为3时，绕Y轴旋转整个魔方
	void RotateY(int pos, float dTheta, bool isPressed = false);

	// pos的取值为0-2时，绕Z轴旋转魔方指定层 
	// pos的取值为-1时，绕Z轴旋转魔方pos为0和1的两层
	// pos的取值为-2时，绕Z轴旋转魔方pos为1和2的两层
	// pos的取值为3时，绕Z轴旋转整个魔方
	void RotateZ(int pos, float dTheta, bool isPressed = false);
	
	
	

	// 设置旋转速度(rad/s)
	void SetRotationSpeed(float rad);

	// 获取纹理数组
	ComPtr<ID3D11ShaderResourceView> GetTexArray() const;

private:
	// 从内存中创建纹理
	ComPtr<ID3D11ShaderResourceView> CreateRubikCubeTextureArrayFromMemory(ComPtr<ID3D11Device> device,
		ComPtr<ID3D11DeviceContext> deviceContext);

	// 绕X轴的预旋转
	void PreRotateX(bool isKeyOp);
	// 绕Y轴的预旋转
	void PreRotateY(bool isKeyOp);
	// 绕Z轴的预旋转
	void PreRotateZ(bool isKeyOp);

	// 获取需要与当前索引的值进行交换的索引，用于模拟旋转
	// outArr1 { [X1][Y1] [X2][Y2] ... }
	//              ||       ||
	// outArr2 { [X1][Y1] [X2][Y2] ... }
	void GetSwapIndexArray(int times, std::vector<DirectX::XMINT2>& outArr1, 
		std::vector<DirectX::XMINT2>& outArr2) const;

	// 获取绕X轴旋转的情况下需要与目标索引块交换的面，用于模拟旋转
	// cube[][Y][Z].face1 <--> cube[][Y][Z].face2
	RubikFace GetTargetSwapFaceRotationX(RubikFace face, int times) const;
	// 获取绕Y轴旋转的情况下需要与目标索引块交换的面，用于模拟旋转
	// cube[X][][Z].face1 <--> cube[X][][Z].face2
	RubikFace GetTargetSwapFaceRotationY(RubikFace face, int times) const;
	// 获取绕Z轴旋转的情况下需要与目标索引块交换的面，用于模拟旋转
	// cube[X][Y][].face1 <--> cube[X][Y][].face2
	RubikFace GetTargetSwapFaceRotationZ(RubikFace face, int times) const;

private:
	// 魔方 [X][Y][Z]
	Cube mCubes[3][3][3];

	// 当前是否鼠标正在拖动
	bool mIsPressed;
	// 当前是否有动画在播放
	bool mIsLocked;
	// 当前自动旋转的速度
	float mRotationSpeed;

	// 顶点缓冲区，包含6个面的24个顶点
	// 索引0-3对应+X面
	// 索引4-7对应-X面
	// 索引8-11对应+Y面
	// 索引12-15对应-Y面
	// 索引16-19对应+Z面
	// 索引20-23对应-Z面
	ComPtr<ID3D11Buffer> mVertexBuffer;	

	// 索引缓冲区，仅6个索引
	ComPtr<ID3D11Buffer> mIndexBuffer;
	
	// 实例缓冲区，

	// 纹理数组，包含7张纹理
	ComPtr<ID3D11ShaderResourceView> mTexArray;
};




#endif
```

`Direct3D11-Source/ScreenGrab.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// File: ScreenGrab.cpp
//
// Function for capturing a 2D texture and saving it to a file (aka a 'screenshot'
// when used on a Direct3D 11 Render Target).
//
// Note these functions are useful as a light-weight runtime screen grabber. For
// full-featured texture capture, DDS writer, and texture processing pipeline,
// see the 'Texconv' sample and the 'DirectXTex' library.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
// http://go.microsoft.com/fwlink/?LinkId=248926
// http://go.microsoft.com/fwlink/?LinkId=248929
//--------------------------------------------------------------------------------------

// Does not capture 1D textures or 3D textures (volume maps)

// Does not capture mipmap chains, only the top-most texture level is saved

// For 2D array textures and cubemaps, it captures only the first image in the array

#include "ScreenGrab.h"

#include <dxgiformat.h>
#include <assert.h>

#include <wincodec.h>

#include <wrl\client.h>

#include <algorithm>
#include <memory>

using Microsoft::WRL::ComPtr;

//--------------------------------------------------------------------------------------
// Macros
//--------------------------------------------------------------------------------------
#ifndef MAKEFOURCC
    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((uint32_t)(uint8_t)(ch0) | ((uint32_t)(uint8_t)(ch1) << 8) |       \
                ((uint32_t)(uint8_t)(ch2) << 16) | ((uint32_t)(uint8_t)(ch3) << 24 ))
#endif /* defined(MAKEFOURCC) */

//--------------------------------------------------------------------------------------
// DDS file structure definitions
//
// See DDS.h in the 'Texconv' sample and the 'DirectXTex' library
//--------------------------------------------------------------------------------------
namespace
{
    #pragma pack(push,1)

    #define DDS_MAGIC 0x20534444 // "DDS "

    struct DDS_PIXELFORMAT
    {
        uint32_t    size;
        uint32_t    flags;
        uint32_t    fourCC;
        uint32_t    RGBBitCount;
        uint32_t    RBitMask;
        uint32_t    GBitMask;
        uint32_t    BBitMask;
        uint32_t    ABitMask;
    };

    #define DDS_FOURCC      0x00000004  // DDPF_FOURCC
    #define DDS_RGB         0x00000040  // DDPF_RGB
    #define DDS_RGBA        0x00000041  // DDPF_RGB | DDPF_ALPHAPIXELS
    #define DDS_LUMINANCE   0x00020000  // DDPF_LUMINANCE
    #define DDS_LUMINANCEA  0x00020001  // DDPF_LUMINANCE | DDPF_ALPHAPIXELS
    #define DDS_ALPHA       0x00000002  // DDPF_ALPHA
    #define DDS_BUMPDUDV    0x00080000  // DDPF_BUMPDUDV

    #define DDS_HEADER_FLAGS_TEXTURE        0x00001007  // DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT 
    #define DDS_HEADER_FLAGS_MIPMAP         0x00020000  // DDSD_MIPMAPCOUNT
    #define DDS_HEADER_FLAGS_PITCH          0x00000008  // DDSD_PITCH
    #define DDS_HEADER_FLAGS_LINEARSIZE     0x00080000  // DDSD_LINEARSIZE

    #define DDS_HEIGHT 0x00000002 // DDSD_HEIGHT
    #define DDS_WIDTH  0x00000004 // DDSD_WIDTH

    #define DDS_SURFACE_FLAGS_TEXTURE 0x00001000 // DDSCAPS_TEXTURE

    typedef struct
    {
        uint32_t        size;
        uint32_t        flags;
        uint32_t        height;
        uint32_t        width;
        uint32_t        pitchOrLinearSize;
        uint32_t        depth; // only if DDS_HEADER_FLAGS_VOLUME is set in flags
        uint32_t        mipMapCount;
        uint32_t        reserved1[11];
        DDS_PIXELFORMAT ddspf;
        uint32_t        caps;
        uint32_t        caps2;
        uint32_t        caps3;
        uint32_t        caps4;
        uint32_t        reserved2;
    } DDS_HEADER;

    typedef struct
    {
        DXGI_FORMAT     dxgiFormat;
        uint32_t        resourceDimension;
        uint32_t        miscFlag; // see D3D11_RESOURCE_MISC_FLAG
        uint32_t        arraySize;
        uint32_t        reserved;
    } DDS_HEADER_DXT10;

    #pragma pack(pop)

    const DDS_PIXELFORMAT DDSPF_DXT1 =
        { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('D','X','T','1'), 0, 0, 0, 0, 0 };

    const DDS_PIXELFORMAT DDSPF_DXT3 =
        { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('D','X','T','3'), 0, 0, 0, 0, 0 };

    const DDS_PIXELFORMAT DDSPF_DXT5 =
        { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('D','X','T','5'), 0, 0, 0, 0, 0 };

    const DDS_PIXELFORMAT DDSPF_BC4_UNORM =
        { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('B','C','4','U'), 0, 0, 0, 0, 0 };

    const DDS_PIXELFORMAT DDSPF_BC4_SNORM =
        { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('B','C','4','S'), 0, 0, 0, 0, 0 };

    const DDS_PIXELFORMAT DDSPF_BC5_UNORM =
        { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('B','C','5','U'), 0, 0, 0, 0, 0 };

    const DDS_PIXELFORMAT DDSPF_BC5_SNORM =
        { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('B','C','5','S'), 0, 0, 0, 0, 0 };

    const DDS_PIXELFORMAT DDSPF_R8G8_B8G8 =
        { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('R','G','B','G'), 0, 0, 0, 0, 0 };

    const DDS_PIXELFORMAT DDSPF_G8R8_G8B8 =
        { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('G','R','G','B'), 0, 0, 0, 0, 0 };

    const DDS_PIXELFORMAT DDSPF_YUY2 =
        { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('Y','U','Y','2'), 0, 0, 0, 0, 0 };

    const DDS_PIXELFORMAT DDSPF_A8R8G8B8 =
        { sizeof(DDS_PIXELFORMAT), DDS_RGBA, 0, 32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000 };

    const DDS_PIXELFORMAT DDSPF_X8R8G8B8 =
        { sizeof(DDS_PIXELFORMAT), DDS_RGB,  0, 32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0x00000000 };

    const DDS_PIXELFORMAT DDSPF_A8B8G8R8 =
        { sizeof(DDS_PIXELFORMAT), DDS_RGBA, 0, 32, 0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000 };

    const DDS_PIXELFORMAT DDSPF_G16R16 =
        { sizeof(DDS_PIXELFORMAT), DDS_RGB,  0, 32, 0x0000ffff, 0xffff0000, 0x00000000, 0x00000000 };

    const DDS_PIXELFORMAT DDSPF_R5G6B5 =
        { sizeof(DDS_PIXELFORMAT), DDS_RGB, 0, 16, 0x0000f800, 0x000007e0, 0x0000001f, 0x00000000 };

    const DDS_PIXELFORMAT DDSPF_A1R5G5B5 =
        { sizeof(DDS_PIXELFORMAT), DDS_RGBA, 0, 16, 0x00007c00, 0x000003e0, 0x0000001f, 0x00008000 };

    const DDS_PIXELFORMAT DDSPF_A4R4G4B4 =
        { sizeof(DDS_PIXELFORMAT), DDS_RGBA, 0, 16, 0x00000f00, 0x000000f0, 0x0000000f, 0x0000f000 };

    const DDS_PIXELFORMAT DDSPF_L8 =
        { sizeof(DDS_PIXELFORMAT), DDS_LUMINANCE, 0,  8, 0xff, 0x00, 0x00, 0x00 };

    const DDS_PIXELFORMAT DDSPF_L16 =
        { sizeof(DDS_PIXELFORMAT), DDS_LUMINANCE, 0, 16, 0xffff, 0x0000, 0x0000, 0x0000 };

    const DDS_PIXELFORMAT DDSPF_A8L8 =
        { sizeof(DDS_PIXELFORMAT), DDS_LUMINANCEA, 0, 16, 0x00ff, 0x0000, 0x0000, 0xff00 };

    const DDS_PIXELFORMAT DDSPF_A8 =
        { sizeof(DDS_PIXELFORMAT), DDS_ALPHA, 0, 8, 0x00, 0x00, 0x00, 0xff };

    const DDS_PIXELFORMAT DDSPF_V8U8 = 
        { sizeof(DDS_PIXELFORMAT), DDS_BUMPDUDV, 0, 16, 0x00ff, 0xff00, 0x0000, 0x0000 };

    const DDS_PIXELFORMAT DDSPF_Q8W8V8U8 = 
        { sizeof(DDS_PIXELFORMAT), DDS_BUMPDUDV, 0, 32, 0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000 };

    const DDS_PIXELFORMAT DDSPF_V16U16 = 
        { sizeof(DDS_PIXELFORMAT), DDS_BUMPDUDV, 0, 32, 0x0000ffff, 0xffff0000, 0x00000000, 0x00000000 };

    // DXGI_FORMAT_R10G10B10A2_UNORM should be written using DX10 extension to avoid D3DX 10:10:10:2 reversal issue

    // This indicates the DDS_HEADER_DXT10 extension is present (the format is in dxgiFormat)
    const DDS_PIXELFORMAT DDSPF_DX10 =
        { sizeof(DDS_PIXELFORMAT), DDS_FOURCC, MAKEFOURCC('D','X','1','0'), 0, 0, 0, 0, 0 };

    //-----------------------------------------------------------------------------
    struct handle_closer { void operator()(HANDLE h) { if (h) CloseHandle(h); } };

    typedef std::unique_ptr<void, handle_closer> ScopedHandle;

    inline HANDLE safe_handle( HANDLE h ) { return (h == INVALID_HANDLE_VALUE) ? nullptr : h; }

    class auto_delete_file
    {
    public:
        auto_delete_file(HANDLE hFile) : m_handle(hFile) {}
        ~auto_delete_file()
        {
            if (m_handle)
            {
                FILE_DISPOSITION_INFO info = {};
                info.DeleteFile = TRUE;
                (void)SetFileInformationByHandle(m_handle, FileDispositionInfo, &info, sizeof(info));
            }
        }

        void clear() { m_handle = 0; }

    private:
        HANDLE m_handle;

        auto_delete_file(const auto_delete_file&) = delete;
        auto_delete_file& operator=(const auto_delete_file&) = delete;
    };

    class auto_delete_file_wic
    {
    public:
        auto_delete_file_wic(ComPtr<IWICStream>& hFile, const wchar_t* szFile) : m_handle(hFile), m_filename(szFile) {}
        ~auto_delete_file_wic()
        {
            if (m_filename)
            {
                m_handle.Reset();
                DeleteFileW(m_filename);
            }
        }

        void clear() { m_filename = 0; }

    private:
        const wchar_t* m_filename;
        ComPtr<IWICStream>& m_handle;

        auto_delete_file_wic(const auto_delete_file_wic&) = delete;
        auto_delete_file_wic& operator=(const auto_delete_file_wic&) = delete;
    };

    //--------------------------------------------------------------------------------------
    // Return the BPP for a particular format
    //--------------------------------------------------------------------------------------
    size_t BitsPerPixel( _In_ DXGI_FORMAT fmt )
    {
        switch( fmt )
        {
        case DXGI_FORMAT_R32G32B32A32_TYPELESS:
        case DXGI_FORMAT_R32G32B32A32_FLOAT:
        case DXGI_FORMAT_R32G32B32A32_UINT:
        case DXGI_FORMAT_R32G32B32A32_SINT:
            return 128;

        case DXGI_FORMAT_R32G32B32_TYPELESS:
        case DXGI_FORMAT_R32G32B32_FLOAT:
        case DXGI_FORMAT_R32G32B32_UINT:
        case DXGI_FORMAT_R32G32B32_SINT:
            return 96;

        case DXGI_FORMAT_R16G16B16A16_TYPELESS:
        case DXGI_FORMAT_R16G16B16A16_FLOAT:
        case DXGI_FORMAT_R16G16B16A16_UNORM:
        case DXGI_FORMAT_R16G16B16A16_UINT:
        case DXGI_FORMAT_R16G16B16A16_SNORM:
        case DXGI_FORMAT_R16G16B16A16_SINT:
        case DXGI_FORMAT_R32G32_TYPELESS:
        case DXGI_FORMAT_R32G32_FLOAT:
        case DXGI_FORMAT_R32G32_UINT:
        case DXGI_FORMAT_R32G32_SINT:
        case DXGI_FORMAT_R32G8X24_TYPELESS:
        case DXGI_FORMAT_D32_FLOAT_S8X24_UINT:
        case DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS:
        case DXGI_FORMAT_X32_TYPELESS_G8X24_UINT:
        case DXGI_FORMAT_Y416:
        case DXGI_FORMAT_Y210:
        case DXGI_FORMAT_Y216:
            return 64;

        case DXGI_FORMAT_R10G10B10A2_TYPELESS:
        case DXGI_FORMAT_R10G10B10A2_UNORM:
        case DXGI_FORMAT_R10G10B10A2_UINT:
        case DXGI_FORMAT_R11G11B10_FLOAT:
        case DXGI_FORMAT_R8G8B8A8_TYPELESS:
        case DXGI_FORMAT_R8G8B8A8_UNORM:
        case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
        case DXGI_FORMAT_R8G8B8A8_UINT:
        case DXGI_FORMAT_R8G8B8A8_SNORM:
        case DXGI_FORMAT_R8G8B8A8_SINT:
        case DXGI_FORMAT_R16G16_TYPELESS:
        case DXGI_FORMAT_R16G16_FLOAT:
        case DXGI_FORMAT_R16G16_UNORM:
        case DXGI_FORMAT_R16G16_UINT:
        case DXGI_FORMAT_R16G16_SNORM:
        case DXGI_FORMAT_R16G16_SINT:
        case DXGI_FORMAT_R32_TYPELESS:
        case DXGI_FORMAT_D32_FLOAT:
        case DXGI_FORMAT_R32_FLOAT:
        case DXGI_FORMAT_R32_UINT:
        case DXGI_FORMAT_R32_SINT:
        case DXGI_FORMAT_R24G8_TYPELESS:
        case DXGI_FORMAT_D24_UNORM_S8_UINT:
        case DXGI_FORMAT_R24_UNORM_X8_TYPELESS:
        case DXGI_FORMAT_X24_TYPELESS_G8_UINT:
        case DXGI_FORMAT_R9G9B9E5_SHAREDEXP:
        case DXGI_FORMAT_R8G8_B8G8_UNORM:
        case DXGI_FORMAT_G8R8_G8B8_UNORM:
        case DXGI_FORMAT_B8G8R8A8_UNORM:
        case DXGI_FORMAT_B8G8R8X8_UNORM:
        case DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM:
        case DXGI_FORMAT_B8G8R8A8_TYPELESS:
        case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
        case DXGI_FORMAT_B8G8R8X8_TYPELESS:
        case DXGI_FORMAT_B8G8R8X8_UNORM_SRGB:
        case DXGI_FORMAT_AYUV:
        case DXGI_FORMAT_Y410:
        case DXGI_FORMAT_YUY2:
            return 32;

        case DXGI_FORMAT_P010:
        case DXGI_FORMAT_P016:
            return 24;

        case DXGI_FORMAT_R8G8_TYPELESS:
        case DXGI_FORMAT_R8G8_UNORM:
        case DXGI_FORMAT_R8G8_UINT:
        case DXGI_FORMAT_R8G8_SNORM:
        case DXGI_FORMAT_R8G8_SINT:
        case DXGI_FORMAT_R16_TYPELESS:
        case DXGI_FORMAT_R16_FLOAT:
        case DXGI_FORMAT_D16_UNORM:
        case DXGI_FORMAT_R16_UNORM:
        case DXGI_FORMAT_R16_UINT:
        case DXGI_FORMAT_R16_SNORM:
        case DXGI_FORMAT_R16_SINT:
        case DXGI_FORMAT_B5G6R5_UNORM:
        case DXGI_FORMAT_B5G5R5A1_UNORM:
        case DXGI_FORMAT_A8P8:
        case DXGI_FORMAT_B4G4R4A4_UNORM:
            return 16;

        case DXGI_FORMAT_NV12:
        case DXGI_FORMAT_420_OPAQUE:
        case DXGI_FORMAT_NV11:
            return 12;

        case DXGI_FORMAT_R8_TYPELESS:
        case DXGI_FORMAT_R8_UNORM:
        case DXGI_FORMAT_R8_UINT:
        case DXGI_FORMAT_R8_SNORM:
        case DXGI_FORMAT_R8_SINT:
        case DXGI_FORMAT_A8_UNORM:
        case DXGI_FORMAT_AI44:
        case DXGI_FORMAT_IA44:
        case DXGI_FORMAT_P8:
            return 8;

        case DXGI_FORMAT_R1_UNORM:
            return 1;

        case DXGI_FORMAT_BC1_TYPELESS:
        case DXGI_FORMAT_BC1_UNORM:
        case DXGI_FORMAT_BC1_UNORM_SRGB:
        case DXGI_FORMAT_BC4_TYPELESS:
        case DXGI_FORMAT_BC4_UNORM:
        case DXGI_FORMAT_BC4_SNORM:
            return 4;

        case DXGI_FORMAT_BC2_TYPELESS:
        case DXGI_FORMAT_BC2_UNORM:
        case DXGI_FORMAT_BC2_UNORM_SRGB:
        case DXGI_FORMAT_BC3_TYPELESS:
        case DXGI_FORMAT_BC3_UNORM:
        case DXGI_FORMAT_BC3_UNORM_SRGB:
        case DXGI_FORMAT_BC5_TYPELESS:
        case DXGI_FORMAT_BC5_UNORM:
        case DXGI_FORMAT_BC5_SNORM:
        case DXGI_FORMAT_BC6H_TYPELESS:
        case DXGI_FORMAT_BC6H_UF16:
        case DXGI_FORMAT_BC6H_SF16:
        case DXGI_FORMAT_BC7_TYPELESS:
        case DXGI_FORMAT_BC7_UNORM:
        case DXGI_FORMAT_BC7_UNORM_SRGB:
            return 8;

        default:
            return 0;
        }
    }


    //--------------------------------------------------------------------------------------
    // Determines if the format is block compressed
    //--------------------------------------------------------------------------------------
    bool IsCompressed( _In_ DXGI_FORMAT fmt )
    {
        switch ( fmt )
        {
        case DXGI_FORMAT_BC1_TYPELESS:
        case DXGI_FORMAT_BC1_UNORM:
        case DXGI_FORMAT_BC1_UNORM_SRGB:
        case DXGI_FORMAT_BC2_TYPELESS:
        case DXGI_FORMAT_BC2_UNORM:
        case DXGI_FORMAT_BC2_UNORM_SRGB:
        case DXGI_FORMAT_BC3_TYPELESS:
        case DXGI_FORMAT_BC3_UNORM:
        case DXGI_FORMAT_BC3_UNORM_SRGB:
        case DXGI_FORMAT_BC4_TYPELESS:
        case DXGI_FORMAT_BC4_UNORM:
        case DXGI_FORMAT_BC4_SNORM:
        case DXGI_FORMAT_BC5_TYPELESS:
        case DXGI_FORMAT_BC5_UNORM:
        case DXGI_FORMAT_BC5_SNORM:
        case DXGI_FORMAT_BC6H_TYPELESS:
        case DXGI_FORMAT_BC6H_UF16:
        case DXGI_FORMAT_BC6H_SF16:
        case DXGI_FORMAT_BC7_TYPELESS:
        case DXGI_FORMAT_BC7_UNORM:
        case DXGI_FORMAT_BC7_UNORM_SRGB:
            return true;

        default:
            return false;
        }
    }


    //--------------------------------------------------------------------------------------
    // Get surface information for a particular format
    //--------------------------------------------------------------------------------------
    HRESULT GetSurfaceInfo(
        _In_ size_t width,
        _In_ size_t height,
        _In_ DXGI_FORMAT fmt,
        _Out_opt_ size_t* outNumBytes,
        _Out_opt_ size_t* outRowBytes,
        _Out_opt_ size_t* outNumRows)
    {
        uint64_t numBytes = 0;
        uint64_t rowBytes = 0;
        uint64_t numRows = 0;

        bool bc = false;
        bool packed = false;
        bool planar = false;
        size_t bpe = 0;
        switch (fmt)
        {
        case DXGI_FORMAT_BC1_TYPELESS:
        case DXGI_FORMAT_BC1_UNORM:
        case DXGI_FORMAT_BC1_UNORM_SRGB:
        case DXGI_FORMAT_BC4_TYPELESS:
        case DXGI_FORMAT_BC4_UNORM:
        case DXGI_FORMAT_BC4_SNORM:
            bc = true;
            bpe = 8;
            break;

        case DXGI_FORMAT_BC2_TYPELESS:
        case DXGI_FORMAT_BC2_UNORM:
        case DXGI_FORMAT_BC2_UNORM_SRGB:
        case DXGI_FORMAT_BC3_TYPELESS:
        case DXGI_FORMAT_BC3_UNORM:
        case DXGI_FORMAT_BC3_UNORM_SRGB:
        case DXGI_FORMAT_BC5_TYPELESS:
        case DXGI_FORMAT_BC5_UNORM:
        case DXGI_FORMAT_BC5_SNORM:
        case DXGI_FORMAT_BC6H_TYPELESS:
        case DXGI_FORMAT_BC6H_UF16:
        case DXGI_FORMAT_BC6H_SF16:
        case DXGI_FORMAT_BC7_TYPELESS:
        case DXGI_FORMAT_BC7_UNORM:
        case DXGI_FORMAT_BC7_UNORM_SRGB:
            bc = true;
            bpe = 16;
            break;

        case DXGI_FORMAT_R8G8_B8G8_UNORM:
        case DXGI_FORMAT_G8R8_G8B8_UNORM:
        case DXGI_FORMAT_YUY2:
            packed = true;
            bpe = 4;
            break;

        case DXGI_FORMAT_Y210:
        case DXGI_FORMAT_Y216:
            packed = true;
            bpe = 8;
            break;

        case DXGI_FORMAT_NV12:
        case DXGI_FORMAT_420_OPAQUE:
            planar = true;
            bpe = 2;
            break;

        case DXGI_FORMAT_P010:
        case DXGI_FORMAT_P016:
            planar = true;
            bpe = 4;
            break;

        default:
            break;
        }

        if (bc)
        {
            uint64_t numBlocksWide = 0;
            if (width > 0)
            {
                numBlocksWide = std::max<uint64_t>(1u, (uint64_t(width) + 3u) / 4u);
            }
            uint64_t numBlocksHigh = 0;
            if (height > 0)
            {
                numBlocksHigh = std::max<uint64_t>(1u, (uint64_t(height) + 3u) / 4u);
            }
            rowBytes = numBlocksWide * bpe;
            numRows = numBlocksHigh;
            numBytes = rowBytes * numBlocksHigh;
        }
        else if (packed)
        {
            rowBytes = ((uint64_t(width) + 1u) >> 1) * bpe;
            numRows = uint64_t(height);
            numBytes = rowBytes * height;
        }
        else if (fmt == DXGI_FORMAT_NV11)
        {
            rowBytes = ((uint64_t(width) + 3u) >> 2) * 4u;
            numRows = uint64_t(height) * 2u; // Direct3D makes this simplifying assumption, although it is larger than the 4:1:1 data
            numBytes = rowBytes * numRows;
        }
        else if (planar)
        {
            rowBytes = ((uint64_t(width) + 1u) >> 1) * bpe;
            numBytes = (rowBytes * uint64_t(height)) + ((rowBytes * uint64_t(height) + 1u) >> 1);
            numRows = height + ((uint64_t(height) + 1u) >> 1);
        }
        else
        {
            size_t bpp = BitsPerPixel(fmt);
            if (!bpp)
                return E_INVALIDARG;

            rowBytes = (uint64_t(width) * bpp + 7u) / 8u; // round up to nearest byte
            numRows = uint64_t(height);
            numBytes = rowBytes * height;
        }

#if defined(_M_IX86) || defined(_M_ARM) || defined(_M_HYBRID_X86_ARM64)
        static_assert(sizeof(size_t) == 4, "Not a 32-bit platform!");
        if (numBytes > UINT32_MAX || rowBytes > UINT32_MAX || numRows > UINT32_MAX)
            return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);
#else
        static_assert(sizeof(size_t) == 8, "Not a 64-bit platform!");
#endif

        if (outNumBytes)
        {
            *outNumBytes = static_cast<size_t>(numBytes);
        }
        if (outRowBytes)
        {
            *outRowBytes = static_cast<size_t>(rowBytes);
        }
        if (outNumRows)
        {
            *outNumRows = static_cast<size_t>(numRows);
        }

        return S_OK;
    }


    //--------------------------------------------------------------------------------------
    DXGI_FORMAT EnsureNotTypeless( DXGI_FORMAT fmt )
    {
        // Assumes UNORM or FLOAT; doesn't use UINT or SINT
        switch( fmt )
        {
        case DXGI_FORMAT_R32G32B32A32_TYPELESS: return DXGI_FORMAT_R32G32B32A32_FLOAT;
        case DXGI_FORMAT_R32G32B32_TYPELESS:    return DXGI_FORMAT_R32G32B32_FLOAT;
        case DXGI_FORMAT_R16G16B16A16_TYPELESS: return DXGI_FORMAT_R16G16B16A16_UNORM;
        case DXGI_FORMAT_R32G32_TYPELESS:       return DXGI_FORMAT_R32G32_FLOAT;
        case DXGI_FORMAT_R10G10B10A2_TYPELESS:  return DXGI_FORMAT_R10G10B10A2_UNORM;
        case DXGI_FORMAT_R8G8B8A8_TYPELESS:     return DXGI_FORMAT_R8G8B8A8_UNORM;
        case DXGI_FORMAT_R16G16_TYPELESS:       return DXGI_FORMAT_R16G16_UNORM;
        case DXGI_FORMAT_R32_TYPELESS:          return DXGI_FORMAT_R32_FLOAT;
        case DXGI_FORMAT_R8G8_TYPELESS:         return DXGI_FORMAT_R8G8_UNORM;
        case DXGI_FORMAT_R16_TYPELESS:          return DXGI_FORMAT_R16_UNORM;
        case DXGI_FORMAT_R8_TYPELESS:           return DXGI_FORMAT_R8_UNORM;
        case DXGI_FORMAT_BC1_TYPELESS:          return DXGI_FORMAT_BC1_UNORM;
        case DXGI_FORMAT_BC2_TYPELESS:          return DXGI_FORMAT_BC2_UNORM;
        case DXGI_FORMAT_BC3_TYPELESS:          return DXGI_FORMAT_BC3_UNORM;
        case DXGI_FORMAT_BC4_TYPELESS:          return DXGI_FORMAT_BC4_UNORM;
        case DXGI_FORMAT_BC5_TYPELESS:          return DXGI_FORMAT_BC5_UNORM;
        case DXGI_FORMAT_B8G8R8A8_TYPELESS:     return DXGI_FORMAT_B8G8R8A8_UNORM;
        case DXGI_FORMAT_B8G8R8X8_TYPELESS:     return DXGI_FORMAT_B8G8R8X8_UNORM;
        case DXGI_FORMAT_BC7_TYPELESS:          return DXGI_FORMAT_BC7_UNORM;
        default:                                return fmt;
        }
    }


    //--------------------------------------------------------------------------------------
    HRESULT CaptureTexture(
        _In_ ID3D11DeviceContext* pContext,
        _In_ ID3D11Resource* pSource,
        D3D11_TEXTURE2D_DESC& desc,
        ComPtr<ID3D11Texture2D>& pStaging )
    {
        if ( !pContext || !pSource )
            return E_INVALIDARG;

        D3D11_RESOURCE_DIMENSION resType = D3D11_RESOURCE_DIMENSION_UNKNOWN;
        pSource->GetType( &resType );

        if ( resType != D3D11_RESOURCE_DIMENSION_TEXTURE2D )
            return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );

        ComPtr<ID3D11Texture2D> pTexture;
        HRESULT hr = pSource->QueryInterface(IID_PPV_ARGS(pTexture.GetAddressOf()));
        if ( FAILED(hr) )
            return hr;

        assert( pTexture );

        pTexture->GetDesc( &desc );

        ComPtr<ID3D11Device> d3dDevice;
        pContext->GetDevice( d3dDevice.GetAddressOf() );

        if ( desc.SampleDesc.Count > 1 )
        {
            // MSAA content must be resolved before being copied to a staging texture
            desc.SampleDesc.Count = 1;
            desc.SampleDesc.Quality = 0;

            ComPtr<ID3D11Texture2D> pTemp;
            hr = d3dDevice->CreateTexture2D( &desc, nullptr, pTemp.GetAddressOf() );
            if ( FAILED(hr) )
                return hr;

            assert( pTemp );

            DXGI_FORMAT fmt = EnsureNotTypeless( desc.Format );

            UINT support = 0;
            hr = d3dDevice->CheckFormatSupport( fmt, &support );
            if ( FAILED(hr) )
                return hr;

            if ( !(support & D3D11_FORMAT_SUPPORT_MULTISAMPLE_RESOLVE) )
                return E_FAIL;

            for( UINT item = 0; item < desc.ArraySize; ++item )
            {
                for( UINT level = 0; level < desc.MipLevels; ++level )
                {
                    UINT index = D3D11CalcSubresource( level, item, desc.MipLevels );
                    pContext->ResolveSubresource( pTemp.Get(), index, pSource, index, fmt );
                }
            }

            desc.BindFlags = 0;
            desc.MiscFlags &= D3D11_RESOURCE_MISC_TEXTURECUBE;
            desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
            desc.Usage = D3D11_USAGE_STAGING;

            hr = d3dDevice->CreateTexture2D(&desc, nullptr, pStaging.ReleaseAndGetAddressOf());
            if ( FAILED(hr) )
                return hr;

            assert( pStaging );

            pContext->CopyResource( pStaging.Get(), pTemp.Get() );
        }
        else if ( (desc.Usage == D3D11_USAGE_STAGING) && (desc.CPUAccessFlags & D3D11_CPU_ACCESS_READ) )
        {
            // Handle case where the source is already a staging texture we can use directly
            pStaging = pTexture;
        }
        else
        {
            // Otherwise, create a staging texture from the non-MSAA source
            desc.BindFlags = 0;
            desc.MiscFlags &= D3D11_RESOURCE_MISC_TEXTURECUBE;
            desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
            desc.Usage = D3D11_USAGE_STAGING;

            hr = d3dDevice->CreateTexture2D(&desc, nullptr, pStaging.ReleaseAndGetAddressOf());
            if ( FAILED(hr) )
                return hr;

            assert( pStaging );

            pContext->CopyResource( pStaging.Get(), pSource );
        }

        return S_OK;
    }

    //--------------------------------------------------------------------------------------
    bool g_WIC2 = false;

    IWICImagingFactory* _GetWIC()
    {
        static INIT_ONCE s_initOnce = INIT_ONCE_STATIC_INIT;

        IWICImagingFactory* factory = nullptr;
        InitOnceExecuteOnce(&s_initOnce,
            [](PINIT_ONCE, PVOID, LPVOID *ifactory) -> BOOL
            {
            #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8) || defined(_WIN7_PLATFORM_UPDATE)
                HRESULT hr = CoCreateInstance(
                    CLSID_WICImagingFactory2,
                    nullptr,
                    CLSCTX_INPROC_SERVER,
                    __uuidof(IWICImagingFactory2),
                    ifactory
                    );

                if ( SUCCEEDED(hr) )
                {
                    // WIC2 is available on Windows 10, Windows 8.x, and Windows 7 SP1 with KB 2670838 installed
                    g_WIC2 = true;
                    return TRUE;
                }
                else
                {
                    hr = CoCreateInstance(
                        CLSID_WICImagingFactory1,
                        nullptr,
                        CLSCTX_INPROC_SERVER,
                        __uuidof(IWICImagingFactory),
                        ifactory
                        );
                    return SUCCEEDED(hr) ? TRUE : FALSE;
                }
            #else
                return SUCCEEDED( CoCreateInstance(
                    CLSID_WICImagingFactory,
                    nullptr,
                    CLSCTX_INPROC_SERVER,
                    __uuidof(IWICImagingFactory),
                    ifactory) ) ? TRUE : FALSE;
            #endif
            }, nullptr, reinterpret_cast<LPVOID*>(&factory));

        return factory;
    }
} // anonymous namespace


//--------------------------------------------------------------------------------------
_Use_decl_annotations_
HRESULT DirectX::SaveDDSTextureToFile(
    ID3D11DeviceContext* pContext,
    ID3D11Resource* pSource,
    const wchar_t* fileName )
{
    if ( !fileName )
        return E_INVALIDARG;

    D3D11_TEXTURE2D_DESC desc = {};
    ComPtr<ID3D11Texture2D> pStaging;
    HRESULT hr = CaptureTexture( pContext, pSource, desc, pStaging );
    if ( FAILED(hr) )
        return hr;

    // Create file
#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)
    ScopedHandle hFile( safe_handle( CreateFile2( fileName, GENERIC_WRITE | DELETE, 0, CREATE_ALWAYS, nullptr ) ) );
#else
    ScopedHandle hFile( safe_handle( CreateFileW( fileName, GENERIC_WRITE | DELETE, 0, nullptr, CREATE_ALWAYS, 0, nullptr ) ) );
#endif
    if ( !hFile )
        return HRESULT_FROM_WIN32( GetLastError() );

    auto_delete_file delonfail(hFile.get());

    // Setup header
    const size_t MAX_HEADER_SIZE = sizeof(uint32_t) + sizeof(DDS_HEADER) + sizeof(DDS_HEADER_DXT10);
    uint8_t fileHeader[ MAX_HEADER_SIZE ];

    *reinterpret_cast<uint32_t*>(&fileHeader[0]) = DDS_MAGIC;

    auto header = reinterpret_cast<DDS_HEADER*>( &fileHeader[0] + sizeof(uint32_t) );
    size_t headerSize = sizeof(uint32_t) + sizeof(DDS_HEADER);
    memset( header, 0, sizeof(DDS_HEADER) );
    header->size = sizeof( DDS_HEADER );
    header->flags = DDS_HEADER_FLAGS_TEXTURE | DDS_HEADER_FLAGS_MIPMAP;
    header->height = desc.Height;
    header->width = desc.Width;
    header->mipMapCount = 1;
    header->caps = DDS_SURFACE_FLAGS_TEXTURE;

    // Try to use a legacy .DDS pixel format for better tools support, otherwise fallback to 'DX10' header extension
    DDS_HEADER_DXT10* extHeader = nullptr;
    switch( desc.Format )
    {
    case DXGI_FORMAT_R8G8B8A8_UNORM:        memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_A8B8G8R8, sizeof(DDS_PIXELFORMAT) );    break;
    case DXGI_FORMAT_R16G16_UNORM:          memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_G16R16, sizeof(DDS_PIXELFORMAT) );      break;
    case DXGI_FORMAT_R8G8_UNORM:            memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_A8L8, sizeof(DDS_PIXELFORMAT) );        break;
    case DXGI_FORMAT_R16_UNORM:             memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_L16, sizeof(DDS_PIXELFORMAT) );         break;
    case DXGI_FORMAT_R8_UNORM:              memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_L8, sizeof(DDS_PIXELFORMAT) );          break;
    case DXGI_FORMAT_A8_UNORM:              memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_A8, sizeof(DDS_PIXELFORMAT) );          break;
    case DXGI_FORMAT_R8G8_B8G8_UNORM:       memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_R8G8_B8G8, sizeof(DDS_PIXELFORMAT) );   break;
    case DXGI_FORMAT_G8R8_G8B8_UNORM:       memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_G8R8_G8B8, sizeof(DDS_PIXELFORMAT) );   break;
    case DXGI_FORMAT_BC1_UNORM:             memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_DXT1, sizeof(DDS_PIXELFORMAT) );        break;
    case DXGI_FORMAT_BC2_UNORM:             memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_DXT3, sizeof(DDS_PIXELFORMAT) );        break;
    case DXGI_FORMAT_BC3_UNORM:             memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_DXT5, sizeof(DDS_PIXELFORMAT) );        break;
    case DXGI_FORMAT_BC4_UNORM:             memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_BC4_UNORM, sizeof(DDS_PIXELFORMAT) );   break;
    case DXGI_FORMAT_BC4_SNORM:             memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_BC4_SNORM, sizeof(DDS_PIXELFORMAT) );   break;
    case DXGI_FORMAT_BC5_UNORM:             memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_BC5_UNORM, sizeof(DDS_PIXELFORMAT) );   break;
    case DXGI_FORMAT_BC5_SNORM:             memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_BC5_SNORM, sizeof(DDS_PIXELFORMAT) );   break;
    case DXGI_FORMAT_B5G6R5_UNORM:          memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_R5G6B5, sizeof(DDS_PIXELFORMAT) );      break;
    case DXGI_FORMAT_B5G5R5A1_UNORM:        memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_A1R5G5B5, sizeof(DDS_PIXELFORMAT) );    break;
    case DXGI_FORMAT_R8G8_SNORM:            memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_V8U8, sizeof(DDS_PIXELFORMAT) );        break;
    case DXGI_FORMAT_R8G8B8A8_SNORM:        memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_Q8W8V8U8, sizeof(DDS_PIXELFORMAT) );    break;
    case DXGI_FORMAT_R16G16_SNORM:          memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_V16U16, sizeof(DDS_PIXELFORMAT) );      break;
    case DXGI_FORMAT_B8G8R8A8_UNORM:        memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_A8R8G8B8, sizeof(DDS_PIXELFORMAT) );    break; // DXGI 1.1
    case DXGI_FORMAT_B8G8R8X8_UNORM:        memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_X8R8G8B8, sizeof(DDS_PIXELFORMAT) );    break; // DXGI 1.1
    case DXGI_FORMAT_YUY2:                  memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_YUY2, sizeof(DDS_PIXELFORMAT) );        break; // DXGI 1.2
    case DXGI_FORMAT_B4G4R4A4_UNORM:        memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_A4R4G4B4, sizeof(DDS_PIXELFORMAT) );    break; // DXGI 1.2

    // Legacy D3DX formats using D3DFMT enum value as FourCC
    case DXGI_FORMAT_R32G32B32A32_FLOAT:    header->ddspf.size = sizeof(DDS_PIXELFORMAT); header->ddspf.flags = DDS_FOURCC; header->ddspf.fourCC = 116; break; // D3DFMT_A32B32G32R32F
    case DXGI_FORMAT_R16G16B16A16_FLOAT:    header->ddspf.size = sizeof(DDS_PIXELFORMAT); header->ddspf.flags = DDS_FOURCC; header->ddspf.fourCC = 113; break; // D3DFMT_A16B16G16R16F
    case DXGI_FORMAT_R16G16B16A16_UNORM:    header->ddspf.size = sizeof(DDS_PIXELFORMAT); header->ddspf.flags = DDS_FOURCC; header->ddspf.fourCC = 36;  break; // D3DFMT_A16B16G16R16
    case DXGI_FORMAT_R16G16B16A16_SNORM:    header->ddspf.size = sizeof(DDS_PIXELFORMAT); header->ddspf.flags = DDS_FOURCC; header->ddspf.fourCC = 110; break; // D3DFMT_Q16W16V16U16
    case DXGI_FORMAT_R32G32_FLOAT:          header->ddspf.size = sizeof(DDS_PIXELFORMAT); header->ddspf.flags = DDS_FOURCC; header->ddspf.fourCC = 115; break; // D3DFMT_G32R32F
    case DXGI_FORMAT_R16G16_FLOAT:          header->ddspf.size = sizeof(DDS_PIXELFORMAT); header->ddspf.flags = DDS_FOURCC; header->ddspf.fourCC = 112; break; // D3DFMT_G16R16F
    case DXGI_FORMAT_R32_FLOAT:             header->ddspf.size = sizeof(DDS_PIXELFORMAT); header->ddspf.flags = DDS_FOURCC; header->ddspf.fourCC = 114; break; // D3DFMT_R32F
    case DXGI_FORMAT_R16_FLOAT:             header->ddspf.size = sizeof(DDS_PIXELFORMAT); header->ddspf.flags = DDS_FOURCC; header->ddspf.fourCC = 111; break; // D3DFMT_R16F

    case DXGI_FORMAT_AI44:
    case DXGI_FORMAT_IA44:
    case DXGI_FORMAT_P8:
    case DXGI_FORMAT_A8P8:
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );

    default:
        memcpy_s( &header->ddspf, sizeof(header->ddspf), &DDSPF_DX10, sizeof(DDS_PIXELFORMAT) );

        headerSize += sizeof(DDS_HEADER_DXT10);
        extHeader = reinterpret_cast<DDS_HEADER_DXT10*>( fileHeader + sizeof(uint32_t) + sizeof(DDS_HEADER) );
        memset( extHeader, 0, sizeof(DDS_HEADER_DXT10) );
        extHeader->dxgiFormat = desc.Format;
        extHeader->resourceDimension = D3D11_RESOURCE_DIMENSION_TEXTURE2D;
        extHeader->arraySize = 1;
        break;
    }

    size_t rowPitch, slicePitch, rowCount;
    hr = GetSurfaceInfo( desc.Width, desc.Height, desc.Format, &slicePitch, &rowPitch, &rowCount );
    if (FAILED(hr))
        return hr;

    if (rowPitch > UINT32_MAX || slicePitch > UINT32_MAX)
        return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

    if ( IsCompressed( desc.Format ) )
    {
        header->flags |= DDS_HEADER_FLAGS_LINEARSIZE;
        header->pitchOrLinearSize = static_cast<uint32_t>( slicePitch );
    }
    else
    {
        header->flags |= DDS_HEADER_FLAGS_PITCH;
        header->pitchOrLinearSize = static_cast<uint32_t>( rowPitch );
    }

    // Setup pixels
    std::unique_ptr<uint8_t[]> pixels( new (std::nothrow) uint8_t[ slicePitch ] );
    if (!pixels)
        return E_OUTOFMEMORY;

    D3D11_MAPPED_SUBRESOURCE mapped;
    hr = pContext->Map( pStaging.Get(), 0, D3D11_MAP_READ, 0, &mapped );
    if ( FAILED(hr) )
        return hr;

    auto sptr = static_cast<const uint8_t*>( mapped.pData );
    if ( !sptr )
    {
        pContext->Unmap( pStaging.Get(), 0 );
        return E_POINTER;
    }

    uint8_t* dptr = pixels.get();

    size_t msize = std::min<size_t>( rowPitch, mapped.RowPitch );
    for( size_t h = 0; h < rowCount; ++h )
    {
        memcpy_s( dptr, rowPitch, sptr, msize );
        sptr += mapped.RowPitch;
        dptr += rowPitch;
    }

    pContext->Unmap( pStaging.Get(), 0 );

    // Write header & pixels
    DWORD bytesWritten;
    if ( !WriteFile( hFile.get(), fileHeader, static_cast<DWORD>( headerSize ), &bytesWritten, nullptr ) )
        return HRESULT_FROM_WIN32( GetLastError() );

    if ( bytesWritten != headerSize )
        return E_FAIL;

    if ( !WriteFile( hFile.get(), pixels.get(), static_cast<DWORD>( slicePitch ), &bytesWritten, nullptr ) )
        return HRESULT_FROM_WIN32( GetLastError() );

    if ( bytesWritten != slicePitch )
        return E_FAIL;

    delonfail.clear();

    return S_OK;
}

//--------------------------------------------------------------------------------------
_Use_decl_annotations_
HRESULT DirectX::SaveWICTextureToFile(
    ID3D11DeviceContext* pContext,
    ID3D11Resource* pSource,
    REFGUID guidContainerFormat,
    const wchar_t* fileName,
    const GUID* targetFormat,
    std::function<void(IPropertyBag2*)> setCustomProps )
{
    if ( !fileName )
        return E_INVALIDARG;

    D3D11_TEXTURE2D_DESC desc = {};
    ComPtr<ID3D11Texture2D> pStaging;
    HRESULT hr = CaptureTexture( pContext, pSource, desc, pStaging );
    if ( FAILED(hr) )
        return hr;

    // Determine source format's WIC equivalent
    WICPixelFormatGUID pfGuid;
    bool sRGB = false;
    switch ( desc.Format )
    {
    case DXGI_FORMAT_R32G32B32A32_FLOAT:            pfGuid = GUID_WICPixelFormat128bppRGBAFloat; break;
    case DXGI_FORMAT_R16G16B16A16_FLOAT:            pfGuid = GUID_WICPixelFormat64bppRGBAHalf; break;
    case DXGI_FORMAT_R16G16B16A16_UNORM:            pfGuid = GUID_WICPixelFormat64bppRGBA; break;
    case DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM:    pfGuid = GUID_WICPixelFormat32bppRGBA1010102XR; break; // DXGI 1.1
    case DXGI_FORMAT_R10G10B10A2_UNORM:             pfGuid = GUID_WICPixelFormat32bppRGBA1010102; break;
    case DXGI_FORMAT_B5G5R5A1_UNORM:                pfGuid = GUID_WICPixelFormat16bppBGRA5551; break;
    case DXGI_FORMAT_B5G6R5_UNORM:                  pfGuid = GUID_WICPixelFormat16bppBGR565; break;
    case DXGI_FORMAT_R32_FLOAT:                     pfGuid = GUID_WICPixelFormat32bppGrayFloat; break;
    case DXGI_FORMAT_R16_FLOAT:                     pfGuid = GUID_WICPixelFormat16bppGrayHalf; break;
    case DXGI_FORMAT_R16_UNORM:                     pfGuid = GUID_WICPixelFormat16bppGray; break;
    case DXGI_FORMAT_R8_UNORM:                      pfGuid = GUID_WICPixelFormat8bppGray; break;
    case DXGI_FORMAT_A8_UNORM:                      pfGuid = GUID_WICPixelFormat8bppAlpha; break;

    case DXGI_FORMAT_R8G8B8A8_UNORM:
        pfGuid = GUID_WICPixelFormat32bppRGBA;
        break;

    case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
        pfGuid = GUID_WICPixelFormat32bppRGBA;
        sRGB = true;
        break;

    case DXGI_FORMAT_B8G8R8A8_UNORM: // DXGI 1.1
        pfGuid = GUID_WICPixelFormat32bppBGRA;
        break;

    case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB: // DXGI 1.1
        pfGuid = GUID_WICPixelFormat32bppBGRA;
        sRGB = true;
        break;

    case DXGI_FORMAT_B8G8R8X8_UNORM: // DXGI 1.1
        pfGuid = GUID_WICPixelFormat32bppBGR;
        break; 

    case DXGI_FORMAT_B8G8R8X8_UNORM_SRGB: // DXGI 1.1
        pfGuid = GUID_WICPixelFormat32bppBGR;
        sRGB = true;
        break; 

    default:
        return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }

    auto pWIC = _GetWIC();
    if ( !pWIC )
        return E_NOINTERFACE;

    ComPtr<IWICStream> stream;
    hr = pWIC->CreateStream( stream.GetAddressOf() );
    if ( FAILED(hr) )
        return hr;

    hr = stream->InitializeFromFilename( fileName, GENERIC_WRITE );
    if ( FAILED(hr) )
        return hr;

    auto_delete_file_wic delonfail(stream, fileName);

    ComPtr<IWICBitmapEncoder> encoder;
    hr = pWIC->CreateEncoder( guidContainerFormat, nullptr, encoder.GetAddressOf() );
    if ( FAILED(hr) )
        return hr;

    hr = encoder->Initialize( stream.Get(), WICBitmapEncoderNoCache );
    if ( FAILED(hr) )
        return hr;

    ComPtr<IWICBitmapFrameEncode> frame;
    ComPtr<IPropertyBag2> props;
    hr = encoder->CreateNewFrame( frame.GetAddressOf(), props.GetAddressOf() );
    if ( FAILED(hr) )
        return hr;

    if ( targetFormat && memcmp( &guidContainerFormat, &GUID_ContainerFormatBmp, sizeof(WICPixelFormatGUID) ) == 0 && g_WIC2 )
    {
        // Opt-in to the WIC2 support for writing 32-bit Windows BMP files with an alpha channel
        PROPBAG2 option = {};
        option.pstrName = const_cast<wchar_t*>(L"EnableV5Header32bppBGRA");

        VARIANT varValue;    
        varValue.vt = VT_BOOL;
        varValue.boolVal = VARIANT_TRUE;      
        (void)props->Write( 1, &option, &varValue ); 
    }

    if ( setCustomProps )
    {
        setCustomProps( props.Get() );
    }

    hr = frame->Initialize( props.Get() );
    if ( FAILED(hr) )
        return hr;

    hr = frame->SetSize( desc.Width , desc.Height );
    if ( FAILED(hr) )
        return hr;

    hr = frame->SetResolution( 72, 72 );
    if ( FAILED(hr) )
        return hr;

    // Pick a target format
    WICPixelFormatGUID targetGuid;
    if ( targetFormat )
    {
        targetGuid = *targetFormat;
    }
    else
    {
        // Screenshots don't typically include the alpha channel of the render target
        switch ( desc.Format )
        {
#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8) || defined(_WIN7_PLATFORM_UPDATE)
        case DXGI_FORMAT_R32G32B32A32_FLOAT:            
        case DXGI_FORMAT_R16G16B16A16_FLOAT:
            if ( g_WIC2 )
            {
                targetGuid = GUID_WICPixelFormat96bppRGBFloat;
            }
            else
            {
                targetGuid = GUID_WICPixelFormat24bppBGR;
            }
            break;
#endif

        case DXGI_FORMAT_R16G16B16A16_UNORM: targetGuid = GUID_WICPixelFormat48bppBGR; break;
        case DXGI_FORMAT_B5G5R5A1_UNORM:     targetGuid = GUID_WICPixelFormat16bppBGR555; break;
        case DXGI_FORMAT_B5G6R5_UNORM:       targetGuid = GUID_WICPixelFormat16bppBGR565; break;

        case DXGI_FORMAT_R32_FLOAT:
        case DXGI_FORMAT_R16_FLOAT:
        case DXGI_FORMAT_R16_UNORM:
        case DXGI_FORMAT_R8_UNORM:
        case DXGI_FORMAT_A8_UNORM:
            targetGuid = GUID_WICPixelFormat8bppGray;
            break;

        default:
            targetGuid = GUID_WICPixelFormat24bppBGR;
            break;
        }
    }

    hr = frame->SetPixelFormat( &targetGuid );
    if ( FAILED(hr) )
        return hr;

    if ( targetFormat && memcmp( targetFormat, &targetGuid, sizeof(WICPixelFormatGUID) ) != 0 )
    {
        // Requested output pixel format is not supported by the WIC codec
        return E_FAIL;
    }

    // Encode WIC metadata
    ComPtr<IWICMetadataQueryWriter> metawriter;
    if ( SUCCEEDED( frame->GetMetadataQueryWriter( metawriter.GetAddressOf() ) ) )
    {
        PROPVARIANT value;
        PropVariantInit( &value );

        value.vt = VT_LPSTR;
        value.pszVal = const_cast<char*>("DirectXTK");

        if ( memcmp( &guidContainerFormat, &GUID_ContainerFormatPng, sizeof(GUID) ) == 0 )
        {
            // Set Software name
            (void)metawriter->SetMetadataByName( L"/tEXt/{str=Software}", &value );

            // Set sRGB chunk
            if (sRGB)
            {
                value.vt = VT_UI1;
                value.bVal = 0;
                (void)metawriter->SetMetadataByName(L"/sRGB/RenderingIntent", &value);
            }
            else
            {
                // add gAMA chunk with gamma 1.0
                value.vt = VT_UI4;
                value.uintVal = 100000; // gama value * 100,000 -- i.e. gamma 1.0
                (void)metawriter->SetMetadataByName(L"/gAMA/ImageGamma", &value);

                // remove sRGB chunk which is added by default.
                (void)metawriter->RemoveMetadataByName(L"/sRGB/RenderingIntent");
            }
        }
        else
        {
            // Set Software name
            (void)metawriter->SetMetadataByName( L"System.ApplicationName", &value );

            if ( sRGB )
            {
                // Set EXIF Colorspace of sRGB
                value.vt = VT_UI2;
                value.uiVal = 1;
                (void)metawriter->SetMetadataByName( L"System.Image.ColorSpace", &value );
            }
        }
    }

    D3D11_MAPPED_SUBRESOURCE mapped;
    hr = pContext->Map( pStaging.Get(), 0, D3D11_MAP_READ, 0, &mapped );
    if ( FAILED(hr) )
        return hr;

    if ( memcmp( &targetGuid, &pfGuid, sizeof(WICPixelFormatGUID) ) != 0 )
    {
        // Conversion required to write
        ComPtr<IWICBitmap> source;
        hr = pWIC->CreateBitmapFromMemory( desc.Width, desc.Height, pfGuid,
                                           mapped.RowPitch, mapped.RowPitch * desc.Height,
                                           static_cast<BYTE*>( mapped.pData ), source.GetAddressOf() );
        if ( FAILED(hr) )
        {
            pContext->Unmap( pStaging.Get(), 0 );
            return hr;
        }

        ComPtr<IWICFormatConverter> FC;
        hr = pWIC->CreateFormatConverter( FC.GetAddressOf() );
        if ( FAILED(hr) )
        {
            pContext->Unmap( pStaging.Get(), 0 );
            return hr;
        }

        BOOL canConvert = FALSE;
        hr = FC->CanConvert( pfGuid, targetGuid, &canConvert );
        if ( FAILED(hr) || !canConvert )
        {
            return E_UNEXPECTED;
        }

        hr = FC->Initialize( source.Get(), targetGuid, WICBitmapDitherTypeNone, nullptr, 0, WICBitmapPaletteTypeMedianCut );
        if ( FAILED(hr) )
        {
            pContext->Unmap( pStaging.Get(), 0 );
            return hr;
        }

        WICRect rect = { 0, 0, static_cast<INT>( desc.Width ), static_cast<INT>( desc.Height ) };
        hr = frame->WriteSource( FC.Get(), &rect );
        if ( FAILED(hr) )
        {
            pContext->Unmap( pStaging.Get(), 0 );
            return hr;
        }
    }
    else
    {
        // No conversion required
        hr = frame->WritePixels( desc.Height, mapped.RowPitch, mapped.RowPitch * desc.Height, static_cast<BYTE*>( mapped.pData ) );
        if ( FAILED(hr) )
            return hr;
    }

    pContext->Unmap( pStaging.Get(), 0 );

    hr = frame->Commit();
    if ( FAILED(hr) )
        return hr;

    hr = encoder->Commit();
    if ( FAILED(hr) )
        return hr;

    delonfail.clear();

    return S_OK;
}

```

`Direct3D11-Source/ScreenGrab.h`:

```h
//--------------------------------------------------------------------------------------
// File: ScreenGrab.h
//
// Function for capturing a 2D texture and saving it to a file (aka a 'screenshot'
// when used on a Direct3D 11 Render Target).
//
// Note these functions are useful as a light-weight runtime screen grabber. For
// full-featured texture capture, DDS writer, and texture processing pipeline,
// see the 'Texconv' sample and the 'DirectXTex' library.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
// http://go.microsoft.com/fwlink/?LinkId=248926
// http://go.microsoft.com/fwlink/?LinkId=248929
//--------------------------------------------------------------------------------------

#pragma once

#include <d3d11_1.h>

#include <ocidl.h>
#include <stdint.h>
#include <functional>


namespace DirectX
{
    HRESULT SaveDDSTextureToFile( _In_ ID3D11DeviceContext* pContext,
                                  _In_ ID3D11Resource* pSource,
                                  _In_z_ const wchar_t* fileName );

    HRESULT SaveWICTextureToFile( _In_ ID3D11DeviceContext* pContext,
                                  _In_ ID3D11Resource* pSource,
                                  _In_ REFGUID guidContainerFormat, 
                                  _In_z_ const wchar_t* fileName,
                                  _In_opt_ const GUID* targetFormat = nullptr,
                                  _In_opt_ std::function<void(IPropertyBag2*)> setCustomProps = nullptr );
}
```

`Direct3D11-Source/Vertex.cpp`:

```cpp
#include "Vertex.h"

const D3D11_INPUT_ELEMENT_DESC VertexPos::inputLayout[1] = {
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 }
};

const D3D11_INPUT_ELEMENT_DESC VertexPosColor::inputLayout[2] = {
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
	{ "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 }
};

const D3D11_INPUT_ELEMENT_DESC VertexPosTex::inputLayout[2] = {
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
	{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 }
};

const D3D11_INPUT_ELEMENT_DESC VertexPosSize::inputLayout[2] = {
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
	{ "SIZE", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 }
};

const D3D11_INPUT_ELEMENT_DESC VertexPosNormalColor::inputLayout[3] = {
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
	{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
	{ "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0 }
};

const D3D11_INPUT_ELEMENT_DESC VertexPosNormalTex::inputLayout[3] = {
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
	{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
	{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0 }
};

const D3D11_INPUT_ELEMENT_DESC VertexPosNormalTangentTex::inputLayout[4] = {
	{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
	{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
	{ "TANGENT", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0 },
	{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 40, D3D11_INPUT_PER_VERTEX_DATA, 0 }
};
```

`Direct3D11-Source/Vertex.h`:

```h
//***************************************************************************************
// Vertex.h by X_Jun(MKXJun) (C) 2018-2019 All Rights Reserved.
// Licensed under the MIT License.
//
// 定义了一些顶点结构体和输入布局
// Defines vertex structures and input layouts.
//***************************************************************************************

#ifndef VERTEX_H
#define VERTEX_H

#include <d3d11_1.h>
#include <DirectXMath.h>

struct VertexPos
{
	DirectX::XMFLOAT3 pos;
	static const D3D11_INPUT_ELEMENT_DESC inputLayout[1];
};

struct VertexPosColor
{
	DirectX::XMFLOAT3 pos;
	DirectX::XMFLOAT4 color;
	static const D3D11_INPUT_ELEMENT_DESC inputLayout[2];
};

struct VertexPosTex
{
	DirectX::XMFLOAT3 pos;
	DirectX::XMFLOAT2 tex;
	static const D3D11_INPUT_ELEMENT_DESC inputLayout[2];
};

struct VertexPosSize
{
	DirectX::XMFLOAT3 pos;
	DirectX::XMFLOAT2 size;
	static const D3D11_INPUT_ELEMENT_DESC inputLayout[2];
};

struct VertexPosNormalColor
{
	DirectX::XMFLOAT3 pos;
	DirectX::XMFLOAT3 normal;
	DirectX::XMFLOAT4 color;
	static const D3D11_INPUT_ELEMENT_DESC inputLayout[3];
};


struct VertexPosNormalTex
{
	DirectX::XMFLOAT3 pos;
	DirectX::XMFLOAT3 normal;
	DirectX::XMFLOAT2 tex;
	static const D3D11_INPUT_ELEMENT_DESC inputLayout[3];
};

struct VertexPosNormalTangentTex
{
	DirectX::XMFLOAT3 pos;
	DirectX::XMFLOAT3 normal;
	DirectX::XMFLOAT4 tangent;
	DirectX::XMFLOAT2 tex;
	static const D3D11_INPUT_ELEMENT_DESC inputLayout[4];
};

#endif
```

`Direct3D11-Source/WICTextureLoader.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// File: WICTextureLoader.cpp
//
// Function for loading a WIC image and creating a Direct3D runtime texture for it
// (auto-generating mipmaps if possible)
//
// Note: Assumes application has already called CoInitializeEx
//
// Warning: CreateWICTexture* functions are not thread-safe if given a d3dContext instance for
//          auto-gen mipmap support.
//
// Note these functions are useful for images created as simple 2D textures. For
// more complex resources, DDSTextureLoader is an excellent light-weight runtime loader.
// For a full-featured DDS file reader, writer, and texture processing pipeline see
// the 'Texconv' sample and the 'DirectXTex' library.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
// http://go.microsoft.com/fwlink/?LinkId=248926
// http://go.microsoft.com/fwlink/?LinkId=248929
//--------------------------------------------------------------------------------------

// We could load multi-frame images (TIFF/GIF) into a texture array.
// For now, we just load the first frame (note: DirectXTex supports multi-frame images)

#include "WICTextureLoader.h"

#include <dxgiformat.h>
#include <assert.h>

#include <wincodec.h>

#include <wrl\client.h>

#include <algorithm>
#include <memory>

#if !defined(NO_D3D11_DEBUG_NAME) && ( defined(_DEBUG) || defined(PROFILE) )
#pragma comment(lib,"dxguid.lib")
#endif

using namespace DirectX;
using Microsoft::WRL::ComPtr;

namespace
{
    //--------------------------------------------------------------------------------------
    template<UINT TNameLength>
    inline void SetDebugObjectName(_In_ ID3D11DeviceChild* resource, _In_ const char(&name)[TNameLength])
    {
#if !defined(NO_D3D11_DEBUG_NAME) && ( defined(_DEBUG) || defined(PROFILE) )
        resource->SetPrivateData(WKPDID_D3DDebugObjectName, TNameLength - 1, name);
#else
        UNREFERENCED_PARAMETER(resource);
        UNREFERENCED_PARAMETER(name);
#endif
    }

    //-------------------------------------------------------------------------------------
    // WIC Pixel Format Translation Data
    //-------------------------------------------------------------------------------------
    struct WICTranslate
    {
        GUID                wic;
        DXGI_FORMAT         format;
    };

    const WICTranslate g_WICFormats[] =
    {
        { GUID_WICPixelFormat128bppRGBAFloat,       DXGI_FORMAT_R32G32B32A32_FLOAT },

        { GUID_WICPixelFormat64bppRGBAHalf,         DXGI_FORMAT_R16G16B16A16_FLOAT },
        { GUID_WICPixelFormat64bppRGBA,             DXGI_FORMAT_R16G16B16A16_UNORM },

        { GUID_WICPixelFormat32bppRGBA,             DXGI_FORMAT_R8G8B8A8_UNORM },
        { GUID_WICPixelFormat32bppBGRA,             DXGI_FORMAT_B8G8R8A8_UNORM }, // DXGI 1.1
        { GUID_WICPixelFormat32bppBGR,              DXGI_FORMAT_B8G8R8X8_UNORM }, // DXGI 1.1

        { GUID_WICPixelFormat32bppRGBA1010102XR,    DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM }, // DXGI 1.1
        { GUID_WICPixelFormat32bppRGBA1010102,      DXGI_FORMAT_R10G10B10A2_UNORM },

        { GUID_WICPixelFormat16bppBGRA5551,         DXGI_FORMAT_B5G5R5A1_UNORM },
        { GUID_WICPixelFormat16bppBGR565,           DXGI_FORMAT_B5G6R5_UNORM },

        { GUID_WICPixelFormat32bppGrayFloat,        DXGI_FORMAT_R32_FLOAT },
        { GUID_WICPixelFormat16bppGrayHalf,         DXGI_FORMAT_R16_FLOAT },
        { GUID_WICPixelFormat16bppGray,             DXGI_FORMAT_R16_UNORM },
        { GUID_WICPixelFormat8bppGray,              DXGI_FORMAT_R8_UNORM },

        { GUID_WICPixelFormat8bppAlpha,             DXGI_FORMAT_A8_UNORM },
    };

    //-------------------------------------------------------------------------------------
    // WIC Pixel Format nearest conversion table
    //-------------------------------------------------------------------------------------

    struct WICConvert
    {
        GUID        source;
        GUID        target;
    };

    const WICConvert g_WICConvert[] =
    {
        // Note target GUID in this conversion table must be one of those directly supported formats (above).

        { GUID_WICPixelFormatBlackWhite,            GUID_WICPixelFormat8bppGray }, // DXGI_FORMAT_R8_UNORM

        { GUID_WICPixelFormat1bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
        { GUID_WICPixelFormat2bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
        { GUID_WICPixelFormat4bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
        { GUID_WICPixelFormat8bppIndexed,           GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 

        { GUID_WICPixelFormat2bppGray,              GUID_WICPixelFormat8bppGray }, // DXGI_FORMAT_R8_UNORM 
        { GUID_WICPixelFormat4bppGray,              GUID_WICPixelFormat8bppGray }, // DXGI_FORMAT_R8_UNORM 

        { GUID_WICPixelFormat16bppGrayFixedPoint,   GUID_WICPixelFormat16bppGrayHalf }, // DXGI_FORMAT_R16_FLOAT 
        { GUID_WICPixelFormat32bppGrayFixedPoint,   GUID_WICPixelFormat32bppGrayFloat }, // DXGI_FORMAT_R32_FLOAT 

        { GUID_WICPixelFormat16bppBGR555,           GUID_WICPixelFormat16bppBGRA5551 }, // DXGI_FORMAT_B5G5R5A1_UNORM

        { GUID_WICPixelFormat32bppBGR101010,        GUID_WICPixelFormat32bppRGBA1010102 }, // DXGI_FORMAT_R10G10B10A2_UNORM

        { GUID_WICPixelFormat24bppBGR,              GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
        { GUID_WICPixelFormat24bppRGB,              GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
        { GUID_WICPixelFormat32bppPBGRA,            GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 
        { GUID_WICPixelFormat32bppPRGBA,            GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM 

        { GUID_WICPixelFormat48bppRGB,              GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
        { GUID_WICPixelFormat48bppBGR,              GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
        { GUID_WICPixelFormat64bppBGRA,             GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
        { GUID_WICPixelFormat64bppPRGBA,            GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
        { GUID_WICPixelFormat64bppPBGRA,            GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM

        { GUID_WICPixelFormat48bppRGBFixedPoint,    GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
        { GUID_WICPixelFormat48bppBGRFixedPoint,    GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
        { GUID_WICPixelFormat64bppRGBAFixedPoint,   GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
        { GUID_WICPixelFormat64bppBGRAFixedPoint,   GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
        { GUID_WICPixelFormat64bppRGBFixedPoint,    GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
        { GUID_WICPixelFormat64bppRGBHalf,          GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
        { GUID_WICPixelFormat48bppRGBHalf,          GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 

        { GUID_WICPixelFormat128bppPRGBAFloat,      GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT 
        { GUID_WICPixelFormat128bppRGBFloat,        GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT 
        { GUID_WICPixelFormat128bppRGBAFixedPoint,  GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT 
        { GUID_WICPixelFormat128bppRGBFixedPoint,   GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT 
        { GUID_WICPixelFormat32bppRGBE,             GUID_WICPixelFormat128bppRGBAFloat }, // DXGI_FORMAT_R32G32B32A32_FLOAT 

        { GUID_WICPixelFormat32bppCMYK,             GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
        { GUID_WICPixelFormat64bppCMYK,             GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
        { GUID_WICPixelFormat40bppCMYKAlpha,        GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
        { GUID_WICPixelFormat80bppCMYKAlpha,        GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM

    #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8) || defined(_WIN7_PLATFORM_UPDATE)
        { GUID_WICPixelFormat32bppRGB,              GUID_WICPixelFormat32bppRGBA }, // DXGI_FORMAT_R8G8B8A8_UNORM
        { GUID_WICPixelFormat64bppRGB,              GUID_WICPixelFormat64bppRGBA }, // DXGI_FORMAT_R16G16B16A16_UNORM
        { GUID_WICPixelFormat64bppPRGBAHalf,        GUID_WICPixelFormat64bppRGBAHalf }, // DXGI_FORMAT_R16G16B16A16_FLOAT 
    #endif

        // We don't support n-channel formats
    };

    bool g_WIC2 = false;

    //--------------------------------------------------------------------------------------
    IWICImagingFactory* _GetWIC()
    {
        static INIT_ONCE s_initOnce = INIT_ONCE_STATIC_INIT;

        IWICImagingFactory* factory = nullptr;
        InitOnceExecuteOnce(&s_initOnce,
            [](PINIT_ONCE, PVOID, PVOID *ifactory) -> BOOL
        {
#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8) || defined(_WIN7_PLATFORM_UPDATE)
            HRESULT hr = CoCreateInstance(
                CLSID_WICImagingFactory2,
                nullptr,
                CLSCTX_INPROC_SERVER,
                __uuidof(IWICImagingFactory2),
                ifactory
            );

            if (SUCCEEDED(hr))
            {
                // WIC2 is available on Windows 10, Windows 8.x, and Windows 7 SP1 with KB 2670838 installed
                g_WIC2 = true;
                return TRUE;
            }
            else
            {
                hr = CoCreateInstance(
                    CLSID_WICImagingFactory1,
                    nullptr,
                    CLSCTX_INPROC_SERVER,
                    __uuidof(IWICImagingFactory),
                    ifactory
                );
                return SUCCEEDED(hr) ? TRUE : FALSE;
            }
#else
            return SUCCEEDED(CoCreateInstance(
                CLSID_WICImagingFactory,
                nullptr,
                CLSCTX_INPROC_SERVER,
                __uuidof(IWICImagingFactory),
                ifactory)) ? TRUE : FALSE;
#endif
        }, nullptr, reinterpret_cast<LPVOID*>(&factory));

        return factory;
    }

    //---------------------------------------------------------------------------------
    DXGI_FORMAT _WICToDXGI(const GUID& guid)
    {
        for (size_t i = 0; i < _countof(g_WICFormats); ++i)
        {
            if (memcmp(&g_WICFormats[i].wic, &guid, sizeof(GUID)) == 0)
                return g_WICFormats[i].format;
        }

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8) || defined(_WIN7_PLATFORM_UPDATE)
        if (g_WIC2)
        {
            if (memcmp(&GUID_WICPixelFormat96bppRGBFloat, &guid, sizeof(GUID)) == 0)
                return DXGI_FORMAT_R32G32B32_FLOAT;
        }
#endif

        return DXGI_FORMAT_UNKNOWN;
    }

    //---------------------------------------------------------------------------------
    size_t _WICBitsPerPixel(REFGUID targetGuid)
    {
        auto pWIC = _GetWIC();
        if (!pWIC)
            return 0;

        ComPtr<IWICComponentInfo> cinfo;
        if (FAILED(pWIC->CreateComponentInfo(targetGuid, cinfo.GetAddressOf())))
            return 0;

        WICComponentType type;
        if (FAILED(cinfo->GetComponentType(&type)))
            return 0;

        if (type != WICPixelFormat)
            return 0;

        ComPtr<IWICPixelFormatInfo> pfinfo;
        if (FAILED(cinfo.As(&pfinfo)))
            return 0;

        UINT bpp;
        if (FAILED(pfinfo->GetBitsPerPixel(&bpp)))
            return 0;

        return bpp;
    }


    //--------------------------------------------------------------------------------------
    DXGI_FORMAT MakeSRGB(_In_ DXGI_FORMAT format)
    {
        switch (format)
        {
        case DXGI_FORMAT_R8G8B8A8_UNORM:
            return DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;

        case DXGI_FORMAT_BC1_UNORM:
            return DXGI_FORMAT_BC1_UNORM_SRGB;

        case DXGI_FORMAT_BC2_UNORM:
            return DXGI_FORMAT_BC2_UNORM_SRGB;

        case DXGI_FORMAT_BC3_UNORM:
            return DXGI_FORMAT_BC3_UNORM_SRGB;

        case DXGI_FORMAT_B8G8R8A8_UNORM:
            return DXGI_FORMAT_B8G8R8A8_UNORM_SRGB;

        case DXGI_FORMAT_B8G8R8X8_UNORM:
            return DXGI_FORMAT_B8G8R8X8_UNORM_SRGB;

        case DXGI_FORMAT_BC7_UNORM:
            return DXGI_FORMAT_BC7_UNORM_SRGB;

        default:
            return format;
        }
    }


    //---------------------------------------------------------------------------------
    HRESULT CreateTextureFromWIC(_In_ ID3D11Device* d3dDevice,
        _In_opt_ ID3D11DeviceContext* d3dContext,
        _In_ IWICBitmapFrameDecode *frame,
        _In_ size_t maxsize,
        _In_ D3D11_USAGE usage,
        _In_ unsigned int bindFlags,
        _In_ unsigned int cpuAccessFlags,
        _In_ unsigned int miscFlags,
        _In_ unsigned int loadFlags,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView)
    {
        UINT width, height;
        HRESULT hr = frame->GetSize(&width, &height);
        if (FAILED(hr))
            return hr;

        if (maxsize > UINT32_MAX)
            return E_INVALIDARG;

        assert(width > 0 && height > 0);

        if (!maxsize)
        {
            // This is a bit conservative because the hardware could support larger textures than
            // the Feature Level defined minimums, but doing it this way is much easier and more
            // performant for WIC than the 'fail and retry' model used by DDSTextureLoader

            switch (d3dDevice->GetFeatureLevel())
            {
            case D3D_FEATURE_LEVEL_9_1:
            case D3D_FEATURE_LEVEL_9_2:
                maxsize = 2048 /*D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION*/;
                break;

            case D3D_FEATURE_LEVEL_9_3:
                maxsize = 4096 /*D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION*/;
                break;

            case D3D_FEATURE_LEVEL_10_0:
            case D3D_FEATURE_LEVEL_10_1:
                maxsize = 8192 /*D3D10_REQ_TEXTURE2D_U_OR_V_DIMENSION*/;
                break;

            default:
                maxsize = D3D11_REQ_TEXTURE2D_U_OR_V_DIMENSION;
                break;
            }
        }

        assert(maxsize > 0);

        UINT twidth, theight;
        if (width > maxsize || height > maxsize)
        {
            float ar = static_cast<float>(height) / static_cast<float>(width);
            if (width > height)
            {
                twidth = static_cast<UINT>(maxsize);
                theight = std::max<UINT>(1, static_cast<UINT>(static_cast<float>(maxsize) * ar));
            }
            else
            {
                theight = static_cast<UINT>(maxsize);
                twidth = std::max<UINT>(1, static_cast<UINT>(static_cast<float>(maxsize) / ar));
            }
            assert(twidth <= maxsize && theight <= maxsize);
        }
        else
        {
            twidth = width;
            theight = height;
        }

        // Determine format
        WICPixelFormatGUID pixelFormat;
        hr = frame->GetPixelFormat(&pixelFormat);
        if (FAILED(hr))
            return hr;

        WICPixelFormatGUID convertGUID;
        memcpy_s(&convertGUID, sizeof(WICPixelFormatGUID), &pixelFormat, sizeof(GUID));

        size_t bpp = 0;

        DXGI_FORMAT format = _WICToDXGI(pixelFormat);
        if (format == DXGI_FORMAT_UNKNOWN)
        {
            if (memcmp(&GUID_WICPixelFormat96bppRGBFixedPoint, &pixelFormat, sizeof(WICPixelFormatGUID)) == 0)
            {
#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8) || defined(_WIN7_PLATFORM_UPDATE)
                if (g_WIC2)
                {
                    memcpy_s(&convertGUID, sizeof(WICPixelFormatGUID), &GUID_WICPixelFormat96bppRGBFloat, sizeof(GUID));
                    format = DXGI_FORMAT_R32G32B32_FLOAT;
                    bpp = 96;
                }
                else
#endif
                {
                    memcpy_s(&convertGUID, sizeof(WICPixelFormatGUID), &GUID_WICPixelFormat128bppRGBAFloat, sizeof(GUID));
                    format = DXGI_FORMAT_R32G32B32A32_FLOAT;
                    bpp = 128;
                }
            }
            else
            {
                for (size_t i = 0; i < _countof(g_WICConvert); ++i)
                {
                    if (memcmp(&g_WICConvert[i].source, &pixelFormat, sizeof(WICPixelFormatGUID)) == 0)
                    {
                        memcpy_s(&convertGUID, sizeof(WICPixelFormatGUID), &g_WICConvert[i].target, sizeof(GUID));

                        format = _WICToDXGI(g_WICConvert[i].target);
                        assert(format != DXGI_FORMAT_UNKNOWN);
                        bpp = _WICBitsPerPixel(convertGUID);
                        break;
                    }
                }
            }

            if (format == DXGI_FORMAT_UNKNOWN)
                return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        }
        else
        {
            bpp = _WICBitsPerPixel(pixelFormat);
        }

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8) || defined(_WIN7_PLATFORM_UPDATE)
        if ((format == DXGI_FORMAT_R32G32B32_FLOAT) && d3dContext && textureView)
        {
            // Special case test for optional device support for autogen mipchains for R32G32B32_FLOAT 
            UINT fmtSupport = 0;
            hr = d3dDevice->CheckFormatSupport(DXGI_FORMAT_R32G32B32_FLOAT, &fmtSupport);
            if (FAILED(hr) || !(fmtSupport & D3D11_FORMAT_SUPPORT_MIP_AUTOGEN))
            {
                // Use R32G32B32A32_FLOAT instead which is required for Feature Level 10.0 and up
                memcpy_s(&convertGUID, sizeof(WICPixelFormatGUID), &GUID_WICPixelFormat128bppRGBAFloat, sizeof(GUID));
                format = DXGI_FORMAT_R32G32B32A32_FLOAT;
                bpp = 128;
            }
        }
#endif

        if (!bpp)
            return E_FAIL;

        // Handle sRGB formats
        if (loadFlags & WIC_LOADER_FORCE_SRGB)
        {
            format = MakeSRGB(format);
        }
        else if (!(loadFlags & WIC_LOADER_IGNORE_SRGB))
        {
            ComPtr<IWICMetadataQueryReader> metareader;
            if (SUCCEEDED(frame->GetMetadataQueryReader(metareader.GetAddressOf())))
            {
                GUID containerFormat;
                if (SUCCEEDED(metareader->GetContainerFormat(&containerFormat)))
                {
                    // Check for sRGB colorspace metadata
                    bool sRGB = false;

                    PROPVARIANT value;
                    PropVariantInit(&value);

                    if (memcmp(&containerFormat, &GUID_ContainerFormatPng, sizeof(GUID)) == 0)
                    {
                        // Check for sRGB chunk
                        if (SUCCEEDED(metareader->GetMetadataByName(L"/sRGB/RenderingIntent", &value)) && value.vt == VT_UI1)
                        {
                            sRGB = true;
                        }
                    }
                    else if (SUCCEEDED(metareader->GetMetadataByName(L"System.Image.ColorSpace", &value)) && value.vt == VT_UI2 && value.uiVal == 1)
                    {
                        sRGB = true;
                    }

                    (void)PropVariantClear(&value);

                    if (sRGB)
                        format = MakeSRGB(format);
                }
            }
        }

        // Verify our target format is supported by the current device
        // (handles WDDM 1.0 or WDDM 1.1 device driver cases as well as DirectX 11.0 Runtime without 16bpp format support)
        UINT support = 0;
        hr = d3dDevice->CheckFormatSupport(format, &support);
        if (FAILED(hr) || !(support & D3D11_FORMAT_SUPPORT_TEXTURE2D))
        {
            // Fallback to RGBA 32-bit format which is supported by all devices
            memcpy_s(&convertGUID, sizeof(WICPixelFormatGUID), &GUID_WICPixelFormat32bppRGBA, sizeof(GUID));
            format = DXGI_FORMAT_R8G8B8A8_UNORM;
            bpp = 32;
        }

        // Allocate temporary memory for image
        uint64_t rowBytes = (uint64_t(twidth) * uint64_t(bpp) + 7u) / 8u;
        uint64_t numBytes = rowBytes * uint64_t(height);

        if (rowBytes > UINT32_MAX || numBytes > UINT32_MAX)
            return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

        auto rowPitch = static_cast<size_t>(rowBytes);
        auto imageSize = static_cast<size_t>(numBytes);

        std::unique_ptr<uint8_t[]> temp(new (std::nothrow) uint8_t[imageSize]);
        if (!temp)
            return E_OUTOFMEMORY;

        // Load image data
        if (memcmp(&convertGUID, &pixelFormat, sizeof(GUID)) == 0
            && twidth == width
            && theight == height)
        {
            // No format conversion or resize needed
            hr = frame->CopyPixels(nullptr, static_cast<UINT>(rowPitch), static_cast<UINT>(imageSize), temp.get());
            if (FAILED(hr))
                return hr;
        }
        else if (twidth != width || theight != height)
        {
            // Resize
            auto pWIC = _GetWIC();
            if (!pWIC)
                return E_NOINTERFACE;

            ComPtr<IWICBitmapScaler> scaler;
            hr = pWIC->CreateBitmapScaler(scaler.GetAddressOf());
            if (FAILED(hr))
                return hr;

            hr = scaler->Initialize(frame, twidth, theight, WICBitmapInterpolationModeFant);
            if (FAILED(hr))
                return hr;

            WICPixelFormatGUID pfScaler;
            hr = scaler->GetPixelFormat(&pfScaler);
            if (FAILED(hr))
                return hr;

            if (memcmp(&convertGUID, &pfScaler, sizeof(GUID)) == 0)
            {
                // No format conversion needed
                hr = scaler->CopyPixels(nullptr, static_cast<UINT>(rowPitch), static_cast<UINT>(imageSize), temp.get());
                if (FAILED(hr))
                    return hr;
            }
            else
            {
                ComPtr<IWICFormatConverter> FC;
                hr = pWIC->CreateFormatConverter(FC.GetAddressOf());
                if (FAILED(hr))
                    return hr;

                BOOL canConvert = FALSE;
                hr = FC->CanConvert(pfScaler, convertGUID, &canConvert);
                if (FAILED(hr) || !canConvert)
                {
                    return E_UNEXPECTED;
                }

                hr = FC->Initialize(scaler.Get(), convertGUID, WICBitmapDitherTypeErrorDiffusion, nullptr, 0, WICBitmapPaletteTypeMedianCut);
                if (FAILED(hr))
                    return hr;

                hr = FC->CopyPixels(nullptr, static_cast<UINT>(rowPitch), static_cast<UINT>(imageSize), temp.get());
                if (FAILED(hr))
                    return hr;
            }
        }
        else
        {
            // Format conversion but no resize
            auto pWIC = _GetWIC();
            if (!pWIC)
                return E_NOINTERFACE;

            ComPtr<IWICFormatConverter> FC;
            hr = pWIC->CreateFormatConverter(FC.GetAddressOf());
            if (FAILED(hr))
                return hr;

            BOOL canConvert = FALSE;
            hr = FC->CanConvert(pixelFormat, convertGUID, &canConvert);
            if (FAILED(hr) || !canConvert)
            {
                return E_UNEXPECTED;
            }

            hr = FC->Initialize(frame, convertGUID, WICBitmapDitherTypeErrorDiffusion, nullptr, 0, WICBitmapPaletteTypeMedianCut);
            if (FAILED(hr))
                return hr;

            hr = FC->CopyPixels(nullptr, static_cast<UINT>(rowPitch), static_cast<UINT>(imageSize), temp.get());
            if (FAILED(hr))
                return hr;
        }

        // See if format is supported for auto-gen mipmaps (varies by feature level)
        bool autogen = false;
        if (d3dContext && textureView) // Must have context and shader-view to auto generate mipmaps
        {
            UINT fmtSupport = 0;
            hr = d3dDevice->CheckFormatSupport(format, &fmtSupport);
            if (SUCCEEDED(hr) && (fmtSupport & D3D11_FORMAT_SUPPORT_MIP_AUTOGEN))
            {
                autogen = true;
            }
        }

        // Create texture
        D3D11_TEXTURE2D_DESC desc;
        desc.Width = twidth;
        desc.Height = theight;
        desc.MipLevels = (autogen) ? 0 : 1;
        desc.ArraySize = 1;
        desc.Format = format;
        desc.SampleDesc.Count = 1;
        desc.SampleDesc.Quality = 0;
        desc.Usage = usage;
        desc.CPUAccessFlags = cpuAccessFlags;

        if (autogen)
        {
            desc.BindFlags = bindFlags | D3D11_BIND_RENDER_TARGET;
            desc.MiscFlags = miscFlags | D3D11_RESOURCE_MISC_GENERATE_MIPS;
        }
        else
        {
            desc.BindFlags = bindFlags;
            desc.MiscFlags = miscFlags;
        }

        D3D11_SUBRESOURCE_DATA initData;
        initData.pSysMem = temp.get();
        initData.SysMemPitch = static_cast<UINT>(rowPitch);
        initData.SysMemSlicePitch = static_cast<UINT>(imageSize);

        ID3D11Texture2D* tex = nullptr;
        hr = d3dDevice->CreateTexture2D(&desc, (autogen) ? nullptr : &initData, &tex);
        if (SUCCEEDED(hr) && tex)
        {
            if (textureView)
            {
                D3D11_SHADER_RESOURCE_VIEW_DESC SRVDesc = {};
                SRVDesc.Format = desc.Format;

                SRVDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
                SRVDesc.Texture2D.MipLevels = (autogen) ? -1 : 1;

                hr = d3dDevice->CreateShaderResourceView(tex, &SRVDesc, textureView);
                if (FAILED(hr))
                {
                    tex->Release();
                    return hr;
                }

                if (autogen)
                {
                    assert(d3dContext != nullptr);
                    d3dContext->UpdateSubresource(tex, 0, nullptr, temp.get(), static_cast<UINT>(rowPitch), static_cast<UINT>(imageSize));
                    d3dContext->GenerateMips(*textureView);
                }
            }

            if (texture)
            {
                *texture = tex;
            }
            else
            {
                SetDebugObjectName(tex, "WICTextureLoader");
                tex->Release();
            }
        }

        return hr;
    }
} // anonymous namespace

//--------------------------------------------------------------------------------------
_Use_decl_annotations_
HRESULT DirectX::CreateWICTextureFromMemory(ID3D11Device* d3dDevice,
    const uint8_t* wicData,
    size_t wicDataSize,
    ID3D11Resource** texture,
    ID3D11ShaderResourceView** textureView,
    size_t maxsize)
{
    return CreateWICTextureFromMemoryEx(d3dDevice, nullptr, wicData, wicDataSize, maxsize,
        D3D11_USAGE_DEFAULT, D3D11_BIND_SHADER_RESOURCE, 0, 0, WIC_LOADER_DEFAULT,
        texture, textureView);
}

_Use_decl_annotations_
HRESULT DirectX::CreateWICTextureFromMemory(ID3D11Device* d3dDevice,
    ID3D11DeviceContext* d3dContext,
    const uint8_t* wicData,
    size_t wicDataSize,
    ID3D11Resource** texture,
    ID3D11ShaderResourceView** textureView,
    size_t maxsize)
{
    return CreateWICTextureFromMemoryEx(d3dDevice, d3dContext, wicData, wicDataSize, maxsize,
        D3D11_USAGE_DEFAULT, D3D11_BIND_SHADER_RESOURCE, 0, 0, WIC_LOADER_DEFAULT,
        texture, textureView);
}

_Use_decl_annotations_
HRESULT DirectX::CreateWICTextureFromMemoryEx(ID3D11Device* d3dDevice,
    const uint8_t* wicData,
    size_t wicDataSize,
    size_t maxsize,
    D3D11_USAGE usage,
    unsigned int bindFlags,
    unsigned int cpuAccessFlags,
    unsigned int miscFlags,
    unsigned int loadFlags,
    ID3D11Resource** texture,
    ID3D11ShaderResourceView** textureView)
{
    return CreateWICTextureFromMemoryEx(d3dDevice, nullptr, wicData, wicDataSize, maxsize,
        usage, bindFlags, cpuAccessFlags, miscFlags, loadFlags,
        texture, textureView);
}

_Use_decl_annotations_
HRESULT DirectX::CreateWICTextureFromMemoryEx(ID3D11Device* d3dDevice,
    ID3D11DeviceContext* d3dContext,
    const uint8_t* wicData,
    size_t wicDataSize,
    size_t maxsize,
    D3D11_USAGE usage,
    unsigned int bindFlags,
    unsigned int cpuAccessFlags,
    unsigned int miscFlags,
    unsigned int loadFlags,
    ID3D11Resource** texture,
    ID3D11ShaderResourceView** textureView)
{
    if (texture)
    {
        *texture = nullptr;
    }
    if (textureView)
    {
        *textureView = nullptr;
    }

    if (!d3dDevice || !wicData || (!texture && !textureView))
        return E_INVALIDARG;

    if (!wicDataSize)
        return E_FAIL;

    if (wicDataSize > UINT32_MAX)
        return HRESULT_FROM_WIN32(ERROR_FILE_TOO_LARGE);

    auto pWIC = _GetWIC();
    if (!pWIC)
        return E_NOINTERFACE;

    // Create input stream for memory
    ComPtr<IWICStream> stream;
    HRESULT hr = pWIC->CreateStream(stream.GetAddressOf());
    if (FAILED(hr))
        return hr;

    hr = stream->InitializeFromMemory(const_cast<uint8_t*>(wicData), static_cast<DWORD>(wicDataSize));
    if (FAILED(hr))
        return hr;

    // Initialize WIC
    ComPtr<IWICBitmapDecoder> decoder;
    hr = pWIC->CreateDecoderFromStream(stream.Get(), nullptr, WICDecodeMetadataCacheOnDemand, decoder.GetAddressOf());
    if (FAILED(hr))
        return hr;

    ComPtr<IWICBitmapFrameDecode> frame;
    hr = decoder->GetFrame(0, frame.GetAddressOf());
    if (FAILED(hr))
        return hr;

    hr = CreateTextureFromWIC(d3dDevice, d3dContext, frame.Get(), maxsize,
        usage, bindFlags, cpuAccessFlags, miscFlags, loadFlags,
        texture, textureView);
    if (FAILED(hr))
        return hr;

    if (texture && *texture)
    {
        SetDebugObjectName(*texture, "WICTextureLoader");
    }

    if (textureView && *textureView)
    {
        SetDebugObjectName(*textureView, "WICTextureLoader");
    }

    return hr;
}

//--------------------------------------------------------------------------------------
_Use_decl_annotations_
HRESULT DirectX::CreateWICTextureFromFile(ID3D11Device* d3dDevice,
    const wchar_t* fileName,
    ID3D11Resource** texture,
    ID3D11ShaderResourceView** textureView,
    size_t maxsize)
{
    return CreateWICTextureFromFileEx(d3dDevice, nullptr, fileName, maxsize,
        D3D11_USAGE_DEFAULT, D3D11_BIND_SHADER_RESOURCE, 0, 0, WIC_LOADER_DEFAULT,
        texture, textureView);
}

_Use_decl_annotations_
HRESULT DirectX::CreateWICTextureFromFile(ID3D11Device* d3dDevice,
    ID3D11DeviceContext* d3dContext,
    const wchar_t* fileName,
    ID3D11Resource** texture,
    ID3D11ShaderResourceView** textureView,
    size_t maxsize)
{
    return CreateWICTextureFromFileEx(d3dDevice, d3dContext, fileName, maxsize,
        D3D11_USAGE_DEFAULT, D3D11_BIND_SHADER_RESOURCE, 0, 0, WIC_LOADER_DEFAULT,
        texture, textureView);
}

_Use_decl_annotations_
HRESULT DirectX::CreateWICTextureFromFileEx(ID3D11Device* d3dDevice,
    const wchar_t* fileName,
    size_t maxsize,
    D3D11_USAGE usage,
    unsigned int bindFlags,
    unsigned int cpuAccessFlags,
    unsigned int miscFlags,
    unsigned int loadFlags,
    ID3D11Resource** texture,
    ID3D11ShaderResourceView** textureView)
{
    return CreateWICTextureFromFileEx(d3dDevice, nullptr, fileName, maxsize,
        usage, bindFlags, cpuAccessFlags, miscFlags, loadFlags,
        texture, textureView);
}

_Use_decl_annotations_
HRESULT DirectX::CreateWICTextureFromFileEx(ID3D11Device* d3dDevice,
    ID3D11DeviceContext* d3dContext,
    const wchar_t* fileName,
    size_t maxsize,
    D3D11_USAGE usage,
    unsigned int bindFlags,
    unsigned int cpuAccessFlags,
    unsigned int miscFlags,
    unsigned int loadFlags,
    ID3D11Resource** texture,
    ID3D11ShaderResourceView** textureView)
{
    if (texture)
    {
        *texture = nullptr;
    }
    if (textureView)
    {
        *textureView = nullptr;
    }

    if (!d3dDevice || !fileName || (!texture && !textureView))
        return E_INVALIDARG;

    auto pWIC = _GetWIC();
    if (!pWIC)
        return E_NOINTERFACE;

    // Initialize WIC
    ComPtr<IWICBitmapDecoder> decoder;
    HRESULT hr = pWIC->CreateDecoderFromFilename(fileName, nullptr, GENERIC_READ, WICDecodeMetadataCacheOnDemand, decoder.GetAddressOf());
    if (FAILED(hr))
        return hr;

    ComPtr<IWICBitmapFrameDecode> frame;
    hr = decoder->GetFrame(0, frame.GetAddressOf());
    if (FAILED(hr))
        return hr;

    hr = CreateTextureFromWIC(d3dDevice, d3dContext, frame.Get(), maxsize,
        usage, bindFlags, cpuAccessFlags, miscFlags, loadFlags,
        texture, textureView);

#if !defined(NO_D3D11_DEBUG_NAME) && ( defined(_DEBUG) || defined(PROFILE) )
    if (SUCCEEDED(hr))
    {
        if (texture || textureView)
        {
            char strFileA[MAX_PATH];
            int result = WideCharToMultiByte(CP_UTF8,
                WC_NO_BEST_FIT_CHARS,
                fileName,
                -1,
                strFileA,
                MAX_PATH,
                nullptr,
                FALSE
            );
            if (result > 0)
            {
                const char* pstrName = strrchr(strFileA, '\\');
                if (!pstrName)
                {
                    pstrName = strFileA;
                }
                else
                {
                    pstrName++;
                }

                if (texture && *texture)
                {
                    (*texture)->SetPrivateData(WKPDID_D3DDebugObjectName,
                        static_cast<UINT>(strnlen_s(pstrName, MAX_PATH)),
                        pstrName
                    );
                }

                if (textureView && *textureView)
                {
                    (*textureView)->SetPrivateData(WKPDID_D3DDebugObjectName,
                        static_cast<UINT>(strnlen_s(pstrName, MAX_PATH)),
                        pstrName
                    );
                }
            }
        }
    }
#endif

    return hr;
}

```

`Direct3D11-Source/WICTextureLoader.h`:

```h
//--------------------------------------------------------------------------------------
// File: WICTextureLoader.h
//
// Function for loading a WIC image and creating a Direct3D runtime texture for it
// (auto-generating mipmaps if possible)
//
// Note: Assumes application has already called CoInitializeEx
//
// Warning: CreateWICTexture* functions are not thread-safe if given a d3dContext instance for
//          auto-gen mipmap support.
//
// Note these functions are useful for images created as simple 2D textures. For
// more complex resources, DDSTextureLoader is an excellent light-weight runtime loader.
// For a full-featured DDS file reader, writer, and texture processing pipeline see
// the 'Texconv' sample and the 'DirectXTex' library.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
//
// http://go.microsoft.com/fwlink/?LinkId=248926
// http://go.microsoft.com/fwlink/?LinkId=248929
//--------------------------------------------------------------------------------------

#pragma once

#include <d3d11_1.h>
#include <stdint.h>


namespace DirectX
{
    enum WIC_LOADER_FLAGS
    {
        WIC_LOADER_DEFAULT      = 0,
        WIC_LOADER_FORCE_SRGB   = 0x1,
        WIC_LOADER_IGNORE_SRGB  = 0x2,
    };

    // Standard version
    HRESULT CreateWICTextureFromMemory(
        _In_ ID3D11Device* d3dDevice,
        _In_reads_bytes_(wicDataSize) const uint8_t* wicData,
        _In_ size_t wicDataSize,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView,
        _In_ size_t maxsize = 0);

    HRESULT CreateWICTextureFromFile(
        _In_ ID3D11Device* d3dDevice,
        _In_z_ const wchar_t* szFileName,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView,
        _In_ size_t maxsize = 0);

    // Standard version with optional auto-gen mipmap support
    HRESULT CreateWICTextureFromMemory(
        _In_ ID3D11Device* d3dDevice,
        _In_opt_ ID3D11DeviceContext* d3dContext,
        _In_reads_bytes_(wicDataSize) const uint8_t* wicData,
        _In_ size_t wicDataSize,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView,
        _In_ size_t maxsize = 0);

    HRESULT CreateWICTextureFromFile(
        _In_ ID3D11Device* d3dDevice,
        _In_opt_ ID3D11DeviceContext* d3dContext,
        _In_z_ const wchar_t* szFileName,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView,
        _In_ size_t maxsize = 0);

    // Extended version
    HRESULT CreateWICTextureFromMemoryEx(
        _In_ ID3D11Device* d3dDevice,
        _In_reads_bytes_(wicDataSize) const uint8_t* wicData,
        _In_ size_t wicDataSize,
        _In_ size_t maxsize,
        _In_ D3D11_USAGE usage,
        _In_ unsigned int bindFlags,
        _In_ unsigned int cpuAccessFlags,
        _In_ unsigned int miscFlags,
        _In_ unsigned int loadFlags,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView);

    HRESULT CreateWICTextureFromFileEx(
        _In_ ID3D11Device* d3dDevice,
        _In_z_ const wchar_t* szFileName,
        _In_ size_t maxsize,
        _In_ D3D11_USAGE usage,
        _In_ unsigned int bindFlags,
        _In_ unsigned int cpuAccessFlags,
        _In_ unsigned int miscFlags,
        _In_ unsigned int loadFlags,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView);

    // Extended version with optional auto-gen mipmap support
    HRESULT CreateWICTextureFromMemoryEx(
        _In_ ID3D11Device* d3dDevice,
        _In_opt_ ID3D11DeviceContext* d3dContext,
        _In_reads_bytes_(wicDataSize) const uint8_t* wicData,
        _In_ size_t wicDataSize,
        _In_ size_t maxsize,
        _In_ D3D11_USAGE usage,
        _In_ unsigned int bindFlags,
        _In_ unsigned int cpuAccessFlags,
        _In_ unsigned int miscFlags,
        _In_ unsigned int loadFlags,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView);

    HRESULT CreateWICTextureFromFileEx(
        _In_ ID3D11Device* d3dDevice,
        _In_opt_ ID3D11DeviceContext* d3dContext,
        _In_z_ const wchar_t* szFileName,
        _In_ size_t maxsize,
        _In_ D3D11_USAGE usage,
        _In_ unsigned int bindFlags,
        _In_ unsigned int cpuAccessFlags,
        _In_ unsigned int miscFlags,
        _In_ unsigned int loadFlags,
        _Outptr_opt_ ID3D11Resource** texture,
        _Outptr_opt_ ID3D11ShaderResourceView** textureView);
}
```

`Direct3D11-Source/d3dApp.cpp`:

```cpp
#include "d3dApp.h"
#include "d3dUtil.h"
#include <sstream>

namespace
{
	// This is just used to forward Windows messages from a global window
	// procedure to our member function window procedure because we cannot
	// assign a member function to WNDCLASS::lpfnWndProc.
	D3DApp* gd3dApp = 0;
}

LRESULT CALLBACK
MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	// Forward hwnd on because we can get messages (e.g., WM_CREATE)
	// before CreateWindow returns, and thus before mhMainWnd is valid.
	return gd3dApp->MsgProc(hwnd, msg, wParam, lParam);
}

D3DApp::D3DApp(HINSTANCE hInstance)
	: mhAppInst(hInstance),
	mMainWndCaption(L"魔方"),
	mClientWidth(600),
	mClientHeight(600),
	mhMainWnd(nullptr),
	mAppPaused(false),
	mMinimized(false),
	mMaximized(false),
	mResizing(false),
	mEnable4xMsaa(true),
	m4xMsaaQuality(0),
	md3dDevice(nullptr),
	md3dImmediateContext(nullptr),
	mSwapChain(nullptr),
	mDepthStencilBuffer(nullptr),
	mRenderTargetView(nullptr),
	mDepthStencilView(nullptr)
{
	ZeroMemory(&mScreenViewport, sizeof(D3D11_VIEWPORT));


	// 让一个全局指针获取这个类，这样我们就可以在Windows消息处理的回调函数
	// 让这个类调用内部的回调函数了
	gd3dApp = this;
}

D3DApp::~D3DApp()
{
	// 恢复所有默认设定
	if (md3dImmediateContext)
		md3dImmediateContext->ClearState();
}

HINSTANCE D3DApp::AppInst()const
{
	return mhAppInst;
}

HWND D3DApp::MainWnd()const
{
	return mhMainWnd;
}

float D3DApp::AspectRatio()const
{
	return static_cast<float>(mClientWidth) / mClientHeight;
}

int D3DApp::Run()
{
	MSG msg = { 0 };

	mTimer.Reset();

	while (msg.message != WM_QUIT)
	{
		if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		else
		{
			mTimer.Tick();

			if (!mAppPaused)
			{
				CalculateFrameStats();
				UpdateScene(mTimer.DeltaTime());
				DrawScene();
			}
			else
			{
				Sleep(100);
			}
		}
	}

	return (int)msg.wParam;
}

bool D3DApp::Init()
{
	mMouse = std::make_unique<DirectX::Mouse>();
	mKeyboard = std::make_unique<DirectX::Keyboard>();

	if (!InitMainWindow())
		return false;

	if (!InitDirect2D())
		return false;

	if (!InitDirect3D())
		return false;

	return true;
}

void D3DApp::OnResize()
{
	assert(md3dImmediateContext);
	assert(md3dDevice);
	assert(mSwapChain);
	
	if (md3dDevice1 != nullptr)
	{
		assert(md3dImmediateContext1);
		assert(md3dDevice1);
		assert(mSwapChain1);
	}

	// 释放交换链的相关资源
	mRenderTargetView.Reset();
	mDepthStencilView.Reset();
	mDepthStencilBuffer.Reset();

	// 重设交换链并且重新创建渲染目标视图
	ComPtr<ID3D11Texture2D> backBuffer;
	HR(mSwapChain->ResizeBuffers(1, mClientWidth, mClientHeight, DXGI_FORMAT_B8G8R8A8_UNORM, 0));	// 注意此处DXGI_FORMAT_B8G8R8A8_UNORM
	HR(mSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<void**>(backBuffer.GetAddressOf())));
	HR(md3dDevice->CreateRenderTargetView(backBuffer.Get(), nullptr, mRenderTargetView.GetAddressOf()));
	backBuffer.Reset();


	D3D11_TEXTURE2D_DESC depthStencilDesc;

	depthStencilDesc.Width = mClientWidth;
	depthStencilDesc.Height = mClientHeight;
	depthStencilDesc.MipLevels = 1;
	depthStencilDesc.ArraySize = 1;
	depthStencilDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;

	// 要使用 4X MSAA?
	if (mEnable4xMsaa)
	{
		depthStencilDesc.SampleDesc.Count = 4;
		depthStencilDesc.SampleDesc.Quality = m4xMsaaQuality - 1;
	}
	else
	{
		depthStencilDesc.SampleDesc.Count = 1;
		depthStencilDesc.SampleDesc.Quality = 0;
	}


	depthStencilDesc.Usage = D3D11_USAGE_DEFAULT;
	depthStencilDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
	depthStencilDesc.CPUAccessFlags = 0;
	depthStencilDesc.MiscFlags = 0;

	// 创建深度缓冲区以及深度模板视图
	HR(md3dDevice->CreateTexture2D(&depthStencilDesc, nullptr, mDepthStencilBuffer.GetAddressOf()));
	HR(md3dDevice->CreateDepthStencilView(mDepthStencilBuffer.Get(), nullptr, mDepthStencilView.GetAddressOf()));


	// 将渲染目标视图和深度/模板缓冲区结合到管线
	md3dImmediateContext->OMSetRenderTargets(1, mRenderTargetView.GetAddressOf(), mDepthStencilView.Get());

	// 设置视口变换
	mScreenViewport.TopLeftX = 0;
	mScreenViewport.TopLeftY = 0;
	mScreenViewport.Width = static_cast<float>(mClientWidth);
	mScreenViewport.Height = static_cast<float>(mClientHeight);
	mScreenViewport.MinDepth = 0.0f;
	mScreenViewport.MaxDepth = 1.0f;

	md3dImmediateContext->RSSetViewports(1, &mScreenViewport);
}

LRESULT D3DApp::MsgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg)
	{
		// WM_ACTIVATE is sent when the window is activated or deactivated.  
		// We pause the game when the window is deactivated and unpause it 
		// when it becomes active.  
	case WM_ACTIVATE:
		if (LOWORD(wParam) == WA_INACTIVE)
		{
			mAppPaused = true;
			mTimer.Stop();
		}
		else
		{
			mAppPaused = false;
			mTimer.Start();
		}
		return 0;

		// WM_SIZE is sent when the user resizes the window.  
	case WM_SIZE:
		// Save the new client area dimensions.
		mClientWidth = LOWORD(lParam);
		mClientHeight = HIWORD(lParam);
		if (md3dDevice)
		{
			if (wParam == SIZE_MINIMIZED)
			{
				mAppPaused = true;
				mMinimized = true;
				mMaximized = false;
			}
			else if (wParam == SIZE_MAXIMIZED)
			{
				mAppPaused = false;
				mMinimized = false;
				mMaximized = true;
				OnResize();
			}
			else if (wParam == SIZE_RESTORED)
			{

				// Restoring from minimized state?
				if (mMinimized)
				{
					mAppPaused = false;
					mMinimized = false;
					OnResize();
				}

				// Restoring from maximized state?
				else if (mMaximized)
				{
					mAppPaused = false;
					mMaximized = false;
					OnResize();
				}
				else if (mResizing)
				{
					// If user is dragging the resize bars, we do not resize 
					// the buffers here because as the user continuously 
					// drags the resize bars, a stream of WM_SIZE messages are
					// sent to the window, and it would be pointless (and slow)
					// to resize for each WM_SIZE message received from dragging
					// the resize bars.  So instead, we reset after the user is 
					// done resizing the window and releases the resize bars, which 
					// sends a WM_EXITSIZEMOVE message.
				}
				else // API call such as SetWindowPos or mSwapChain->SetFullscreenState.
				{
					OnResize();
				}
			}
		}
		return 0;

		// WM_EXITSIZEMOVE is sent when the user grabs the resize bars.
	case WM_ENTERSIZEMOVE:
		mAppPaused = true;
		mResizing = true;
		mTimer.Stop();
		return 0;

		// WM_EXITSIZEMOVE is sent when the user releases the resize bars.
		// Here we reset everything based on the new window dimensions.
	case WM_EXITSIZEMOVE:
		mAppPaused = false;
		mResizing = false;
		mTimer.Start();
		OnResize();
		return 0;

		// WM_DESTROY is sent when the window is being destroyed.
	case WM_DESTROY:
		PostQuitMessage(0);
		return 0;

		// The WM_MENUCHAR message is sent when a menu is active and the user presses 
		// a key that does not correspond to any mnemonic or accelerator key. 
	case WM_MENUCHAR:
		// Don't beep when we alt-enter.
		return MAKELRESULT(0, MNC_CLOSE);

		// Catch this message so to prevent the window from becoming too small.
	case WM_GETMINMAXINFO:
		((MINMAXINFO*)lParam)->ptMinTrackSize.x = 200;
		((MINMAXINFO*)lParam)->ptMinTrackSize.y = 200;
		return 0;
	
		// 监测这些键盘/鼠标事件
	case WM_INPUT:

	case WM_LBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_XBUTTONDOWN:

	case WM_LBUTTONUP:
	case WM_MBUTTONUP:
	case WM_RBUTTONUP:
	case WM_XBUTTONUP:

	case WM_MOUSEWHEEL:
	case WM_MOUSEHOVER:
	case WM_MOUSEMOVE:
		mMouse->ProcessMessage(msg, wParam, lParam);
		return 0;

	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
	case WM_KEYUP:
	case WM_SYSKEYUP:
		mKeyboard->ProcessMessage(msg, wParam, lParam);
		return 0;

	case WM_ACTIVATEAPP:
		mMouse->ProcessMessage(msg, wParam, lParam);
		mKeyboard->ProcessMessage(msg, wParam, lParam);
		return 0;
	}

	return DefWindowProc(hwnd, msg, wParam, lParam);
}


bool D3DApp::InitMainWindow()
{
	WNDCLASS wc;
	wc.style = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc = MainWndProc;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	wc.hInstance = mhAppInst;
	wc.hIcon = LoadIcon(0, IDI_APPLICATION);
	wc.hCursor = LoadCursor(0, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)GetStockObject(NULL_BRUSH);
	wc.lpszMenuName = 0;
	wc.lpszClassName = L"D3DWndClassName";

	if (!RegisterClass(&wc))
	{
		MessageBox(0, L"RegisterClass Failed.", 0, 0);
		return false;
	}

	// 将窗口调整到中心
	int screenWidth = GetSystemMetrics(SM_CXSCREEN);
	int screenHeight = GetSystemMetrics(SM_CYSCREEN);

	// Compute window rectangle dimensions based on requested client area dimensions.
	RECT R = { 0, 0, mClientWidth, mClientHeight };
	AdjustWindowRect(&R, WS_OVERLAPPEDWINDOW, false);
	int width = R.right - R.left;
	int height = R.bottom - R.top;

	mhMainWnd = CreateWindow(L"D3DWndClassName", mMainWndCaption.c_str(),
		WS_OVERLAPPED | WS_SYSMENU, (screenWidth - width) / 2, (screenHeight - height) / 2, width, height, 0, 0, mhAppInst, 0);
	if (!mhMainWnd)
	{
		MessageBox(0, L"CreateWindow Failed.", 0, 0);
		return false;
	}

	ShowWindow(mhMainWnd, SW_SHOW);
	UpdateWindow(mhMainWnd);
	
	return true;
}

bool D3DApp::InitDirect2D()
{
	HR(D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, md2dFactory.GetAddressOf()));
	HR(DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
		reinterpret_cast<IUnknown**>(mdwriteFactory.GetAddressOf())));

	return true;
}

bool D3DApp::InitDirect3D()
{
	HRESULT hr = S_OK;

	// 创建D3D设备 和 D3D设备上下文
	UINT createDeviceFlags = D3D11_CREATE_DEVICE_BGRA_SUPPORT;	// Direct2D需要支持BGRA格式
#if defined(DEBUG) || defined(_DEBUG)  
	createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
#endif
	// 驱动类型数组
	D3D_DRIVER_TYPE driverTypes[] =
	{
		D3D_DRIVER_TYPE_HARDWARE,
		D3D_DRIVER_TYPE_WARP,
		D3D_DRIVER_TYPE_REFERENCE,
	};
	UINT numDriverTypes = ARRAYSIZE(driverTypes);

	// 特性等级数组
	D3D_FEATURE_LEVEL featureLevels[] =
	{
		D3D_FEATURE_LEVEL_11_1,
		D3D_FEATURE_LEVEL_11_0,
	};
	UINT numFeatureLevels = ARRAYSIZE(featureLevels);

	D3D_FEATURE_LEVEL featureLevel;
	D3D_DRIVER_TYPE d3dDriverType;
	for (UINT driverTypeIndex = 0; driverTypeIndex < numDriverTypes; driverTypeIndex++)
	{
		d3dDriverType = driverTypes[driverTypeIndex];
		hr = D3D11CreateDevice(nullptr, d3dDriverType, nullptr, createDeviceFlags, featureLevels, numFeatureLevels,
			D3D11_SDK_VERSION, md3dDevice.GetAddressOf(), &featureLevel, md3dImmediateContext.GetAddressOf());
		
		if (hr == E_INVALIDARG)
		{
			// DirectX 11.0 平台不承认D3D_FEATURE_LEVEL_11_1所以我们需要尝试特性等级11.0以及以下的版本
			hr = D3D11CreateDevice(nullptr, d3dDriverType, nullptr, createDeviceFlags, &featureLevels[1], numFeatureLevels - 1,
				D3D11_SDK_VERSION, md3dDevice.GetAddressOf(), &featureLevel, md3dImmediateContext.GetAddressOf());
		}

		if (SUCCEEDED(hr))
			break;
	}

	if (FAILED(hr))
	{
		MessageBox(0, L"D3D11CreateDevice Failed.", 0, 0);
		return false;
	}

	// 检测是否支持特性等级11.0或11.1
	if (featureLevel != D3D_FEATURE_LEVEL_11_0 && featureLevel != D3D_FEATURE_LEVEL_11_1)
	{
		MessageBox(0, L"Direct3D Feature Level 11 unsupported.", 0, 0);
		return false;
	}

	// 检测 MSAA支持的质量等级
	md3dDevice->CheckMultisampleQualityLevels(
		DXGI_FORMAT_B8G8R8A8_UNORM, 4, &m4xMsaaQuality);	// 注意此处DXGI_FORMAT_B8G8R8A8_UNORM
	assert(m4xMsaaQuality > 0);

	
	

	ComPtr<IDXGIDevice> dxgiDevice = nullptr;
	ComPtr<IDXGIAdapter> dxgiAdapter = nullptr;
	ComPtr<IDXGIFactory1> dxgiFactory1 = nullptr;	// DX11.0(包含DXGI1.1)的接口类
	ComPtr<IDXGIFactory2> dxgiFactory2 = nullptr;	// DX11.1(包含DXGI1.2)特有的接口类
	
	// 为了正确创建 DXGI交换链，首先我们需要获取创建 D3D设备 的 DXGI工厂，否则会引发报错：
	// "IDXGIFactory::CreateSwapChain: This function is being called with a device from a different IDXGIFactory."
	// 从属关系为 DXGI工厂-> DXGI适配器 -> DXGI设备 {D3D11设备}
	HR(md3dDevice.As(&dxgiDevice));
	HR(dxgiDevice->GetAdapter(dxgiAdapter.GetAddressOf()));
	HR(dxgiAdapter->GetParent(__uuidof(IDXGIFactory1), reinterpret_cast<void**>(dxgiFactory1.GetAddressOf())));
	
	// 查看该对象是否包含IDXGIFactory2接口
	hr = dxgiFactory1.As(&dxgiFactory2);
	// 如果包含，则说明支持DX11.1
	if (dxgiFactory2 != nullptr)
	{
		HR(md3dDevice.As(&md3dDevice1));
		HR(md3dImmediateContext.As(&md3dImmediateContext1));
		// 填充各种结构体用以描述交换链
		DXGI_SWAP_CHAIN_DESC1 sd;
		ZeroMemory(&sd, sizeof(sd));
		sd.Width = mClientWidth;
		sd.Height = mClientHeight;
		sd.Format = DXGI_FORMAT_B8G8R8A8_UNORM;		// 注意此处DXGI_FORMAT_B8G8R8A8_UNORM
		// 是否开启4倍多重采样？
		if (mEnable4xMsaa)
		{
			sd.SampleDesc.Count = 4;
			sd.SampleDesc.Quality = m4xMsaaQuality - 1;
		}
		else
		{
			sd.SampleDesc.Count = 1;
			sd.SampleDesc.Quality = 0;
		}
		sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
		sd.BufferCount = 1;
		sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
		sd.Flags = 0;

		DXGI_SWAP_CHAIN_FULLSCREEN_DESC fd;
		fd.RefreshRate.Numerator = 60;
		fd.RefreshRate.Denominator = 1;
		fd.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
		fd.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
		fd.Windowed = TRUE;
		// 为当前窗口创建交换链
		HR(dxgiFactory2->CreateSwapChainForHwnd(md3dDevice.Get(), mhMainWnd, &sd, &fd, nullptr, mSwapChain1.GetAddressOf()));
		HR(mSwapChain1.As(&mSwapChain));
	}
	else
	{
		// 填充DXGI_SWAP_CHAIN_DESC用以描述交换链
		DXGI_SWAP_CHAIN_DESC sd;
		ZeroMemory(&sd, sizeof(sd));
		sd.BufferDesc.Width = mClientWidth;
		sd.BufferDesc.Height = mClientHeight;
		sd.BufferDesc.RefreshRate.Numerator = 60;
		sd.BufferDesc.RefreshRate.Denominator = 1;
		sd.BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;	// 注意此处DXGI_FORMAT_B8G8R8A8_UNORM
		sd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
		sd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
		// 是否开启4倍多重采样？
		if (mEnable4xMsaa)
		{
			sd.SampleDesc.Count = 4;
			sd.SampleDesc.Quality = m4xMsaaQuality - 1;
		}
		else
		{
			sd.SampleDesc.Count = 1;
			sd.SampleDesc.Quality = 0;
		}
		sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
		sd.BufferCount = 1;
		sd.OutputWindow = mhMainWnd;
		sd.Windowed = TRUE;
		sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
		sd.Flags = 0;
		HR(dxgiFactory1->CreateSwapChain(md3dDevice.Get(), &sd, mSwapChain.GetAddressOf()));
	}
	
	

	// 可以禁止alt+enter全屏
	dxgiFactory1->MakeWindowAssociation(mhMainWnd, DXGI_MWA_NO_ALT_ENTER | DXGI_MWA_NO_WINDOW_CHANGES);


	// 每当窗口被重新调整大小的时候，都需要调用这个OnResize函数。现在调用
	// 以避免代码重复
	OnResize();

	return true;
}




void D3DApp::CalculateFrameStats()
{
	// 该代码计算每秒帧速，并计算每一帧渲染需要的时间，显示在窗口标题
	static int frameCnt = 0;
	static float timeElapsed = 0.0f;

	frameCnt++;

	if ((mTimer.TotalTime() - timeElapsed) >= 1.0f)
	{
		float fps = (float)frameCnt; // fps = frameCnt / 1
		float mspf = 1000.0f / fps;

		std::wostringstream outs;
		outs.precision(6);
		outs << mMainWndCaption << L"    "
			<< L"FPS: " << fps << L"    "
			<< L"Frame Time: " << mspf << L" (ms)";
		SetWindowText(mhMainWnd, outs.str().c_str());

		// Reset for next average.
		frameCnt = 0;
		timeElapsed += 1.0f;
	}
}



```

`Direct3D11-Source/d3dApp.h`:

```h
#ifndef D3DAPP_H
#define D3DAPP_H

#include <wrl/client.h>
#include <string>
#include <d2d1.h>
#include <dwrite.h>
#include <d3d11_1.h>
#include <DirectXMath.h>
#include "Mouse.h"		// Mouse.h和Keyboard.h需要预先包含Windows.h
#include "Keyboard.h"
#include "GameTimer.h"

// 添加所有要引用的库
#pragma comment(lib, "d2d1.lib")
#pragma comment(lib, "dwrite.lib")
#pragma comment(lib, "d3d11.lib")
#pragma comment(lib, "dxgi.lib")
#pragma comment(lib, "dxguid.lib")
#pragma comment(lib, "D3DCompiler.lib")
#pragma comment(lib, "winmm.lib")

class D3DApp
{
public:
	D3DApp(HINSTANCE hInstance);    // 在构造函数的初始化列表应当设置好初始参数
	virtual ~D3DApp();

	HINSTANCE AppInst()const;       // 获取应用实例的句柄
	HWND      MainWnd()const;       // 获取主窗口句柄
	float     AspectRatio()const;   // 获取屏幕宽高比

	int Run();                      // 运行程序，执行消息事件的循环

	// 框架方法。客户派生类需要重载这些方法以实现特定的应用需求
	virtual bool Init();            // 该父类方法需要初始化窗口、Direct2D和Direct3D部分
	virtual void OnResize();        // 该父类方法需要在窗口大小变动的时候调用
	virtual void UpdateScene(float dt) = 0;   // 子类需要实现该方法，完成每一帧的更新
	virtual void DrawScene() = 0;             // 子类需要实现该方法，完成每一帧的绘制
	virtual LRESULT MsgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
	// 窗口的消息回调函数
protected:
	bool InitMainWindow();      // 窗口初始化
	bool InitDirect2D();		// Direct2D初始化
	bool InitDirect3D();        // Direct3D初始化
	

	void CalculateFrameStats(); // 计算每秒帧数并在窗口显示

protected:

	HINSTANCE mhAppInst;        // 应用实例句柄
	HWND      mhMainWnd;        // 主窗口句柄
	bool      mAppPaused;       // 应用是否暂停
	bool      mMinimized;       // 应用是否最小化
	bool      mMaximized;       // 应用是否最大化
	bool      mResizing;        // 窗口大小是否变化
	bool	  mEnable4xMsaa;	// 是否开启4倍多重采样
	UINT      m4xMsaaQuality;   // MSAA支持的质量等级

	GameTimer mTimer;           // 计时器


	// 使用模板别名(C++11)简化类型名
	template <class T>
	using ComPtr = Microsoft::WRL::ComPtr<T>;
	// Direct2D
	ComPtr<ID2D1Factory> md2dFactory;							// D2D工厂
	ComPtr<ID2D1RenderTarget> md2dRenderTarget;					// D2D渲染目标
	ComPtr<IDWriteFactory> mdwriteFactory;						// DWrite工厂
	// Direct3D 11
	ComPtr<ID3D11Device> md3dDevice;							// D3D11设备
	ComPtr<ID3D11DeviceContext> md3dImmediateContext;			// D3D11设备上下文
	ComPtr<IDXGISwapChain> mSwapChain;							// D3D11交换链
	// Direct3D 11.1
	ComPtr<ID3D11Device1> md3dDevice1;							// D3D11.1设备
	ComPtr<ID3D11DeviceContext1> md3dImmediateContext1;			// D3D11.1设备上下文
	ComPtr<IDXGISwapChain1> mSwapChain1;						// D3D11.1交换链
	// 常用资源
	ComPtr<ID3D11Texture2D> mDepthStencilBuffer;				// 深度模板缓冲区
	ComPtr<ID3D11RenderTargetView> mRenderTargetView;			// 渲染目标视图
	ComPtr<ID3D11DepthStencilView> mDepthStencilView;			// 深度模板视图
	D3D11_VIEWPORT mScreenViewport;                             // 视口
	// 键鼠输入
	std::unique_ptr<DirectX::Mouse> mMouse;						// 鼠标
	DirectX::Mouse::ButtonStateTracker mMouseTracker;			// 鼠标状态追踪器
	std::unique_ptr<DirectX::Keyboard> mKeyboard;				// 键盘
	DirectX::Keyboard::KeyboardStateTracker mKeyboardTracker;	// 键盘状态追踪器
	// 派生类应该在构造函数设置好这些自定义的初始参数
	std::wstring mMainWndCaption;                               // 主窗口标题
	int mClientWidth;                                           // 视口宽度
	int mClientHeight;                                          // 视口高度
};

#endif // D3DAPP_H
```

`Direct3D11-Source/d3dUtil.cpp`:

```cpp
#include "d3dUtil.h"

using namespace Microsoft::WRL;
using namespace DirectX;

HRESULT CreateShaderFromFile(const WCHAR * csoFileNameInOut, const WCHAR * hlslFileName,
	LPCSTR entryPoint, LPCSTR shaderModel, ID3DBlob ** ppBlobOut)
{
	HRESULT hr = S_OK;

	// 寻找是否有已经编译好的顶点着色器
	if (csoFileNameInOut && D3DReadFileToBlob(csoFileNameInOut, ppBlobOut) == S_OK)
	{
		return S_OK;
	}
	else
	{
		DWORD dwShaderFlags = D3DCOMPILE_ENABLE_STRICTNESS;
#ifdef _DEBUG
		// 设置 D3DCOMPILE_DEBUG 标志用于获取着色器调试信息。该标志可以提升调试体验，
		// 但仍然允许着色器进行优化操作
		dwShaderFlags |= D3DCOMPILE_DEBUG;

		// 在Debug环境下禁用优化以避免出现一些不合理的情况
		dwShaderFlags |= D3DCOMPILE_SKIP_OPTIMIZATION;
#endif
		ComPtr<ID3DBlob> errorBlob = nullptr;
		hr = D3DCompileFromFile(hlslFileName, nullptr, D3D_COMPILE_STANDARD_FILE_INCLUDE, entryPoint, shaderModel,
			dwShaderFlags, 0, ppBlobOut, errorBlob.GetAddressOf());
		if (FAILED(hr))
		{
			if (errorBlob != nullptr)
			{
				OutputDebugStringA(reinterpret_cast<const char*>(errorBlob->GetBufferPointer()));
			}
			return hr;
		}

		// 若指定了输出文件名，则将着色器二进制信息输出
		if (csoFileNameInOut)
		{
			HR(D3DWriteBlobToFile(*ppBlobOut, csoFileNameInOut, FALSE));
		}
	}

	return hr;
}

ComPtr<ID3D11ShaderResourceView> CreateDDSTexture2DArrayFromFile(
	ComPtr<ID3D11Device> device,
	ComPtr<ID3D11DeviceContext> deviceContext,
	const std::vector<std::wstring>& filenames,
	UINT maxMipMapSize)
{
	// 检查设备与设备上下文是否非空
	if (!device || !deviceContext)
		return nullptr;

	// ******************
	// 1. 读取所有纹理
	//
	UINT size = (UINT)filenames.size();
	UINT mipLevel = maxMipMapSize;
	std::vector<ComPtr<ID3D11Texture2D>> srcTex(size);
	UINT width, height;
	DXGI_FORMAT format;
	for (size_t i = 0; i < size; ++i)
	{
		// 由于这些纹理并不会被GPU使用，我们使用D3D11_USAGE_STAGING枚举值
		// 使得CPU可以读取资源
		HR(CreateDDSTextureFromFileEx(device.Get(),
			deviceContext.Get(),
			filenames[i].c_str(),
			maxMipMapSize,
			D3D11_USAGE_STAGING,							// Usage
			0,												// BindFlags
			D3D11_CPU_ACCESS_WRITE | D3D11_CPU_ACCESS_READ,	// CpuAccessFlags
			0,												// MiscFlags
			false,
			(ID3D11Resource**)srcTex[i].GetAddressOf(),
			nullptr));

		// 读取创建好的纹理Mipmap等级, 宽度和高度
		D3D11_TEXTURE2D_DESC texDesc;
		srcTex[i]->GetDesc(&texDesc);
		if (i == 0)
		{
			mipLevel = texDesc.MipLevels;
			width = texDesc.Width;
			height = texDesc.Height;
			format = texDesc.Format;
		}
		// 这里断言所有纹理的MipMap等级，宽度和高度应当一致
		assert(mipLevel == texDesc.MipLevels);
		assert(texDesc.Width == width && texDesc.Height == height);
		// 这里要求所有提供的图片数据格式应当是一致的，若存在不一致的情况，请
		// 使用dxtex.exe(DirectX Texture Tool)将所有的图片转成一致的数据格式
		assert(texDesc.Format == format);

	}

	// ******************
	// 2.创建纹理数组
	//
	D3D11_TEXTURE2D_DESC texDesc, texArrayDesc;
	srcTex[0]->GetDesc(&texDesc);
	texArrayDesc.Width = texDesc.Width;
	texArrayDesc.Height = texDesc.Height;
	texArrayDesc.MipLevels = texDesc.MipLevels;
	texArrayDesc.ArraySize = size;
	texArrayDesc.Format = texDesc.Format;
	texArrayDesc.SampleDesc.Count = 1;		// 不能使用多重采样
	texArrayDesc.SampleDesc.Quality = 0;
	texArrayDesc.Usage = D3D11_USAGE_DEFAULT;
	texArrayDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	texArrayDesc.CPUAccessFlags = 0;
	texArrayDesc.MiscFlags = 0;

	ComPtr<ID3D11Texture2D> texArray;
	HR(device->CreateTexture2D(&texArrayDesc, nullptr, texArray.GetAddressOf()));

	// ******************
	// 3.将所有的纹理子资源赋值到纹理数组中
	//

	// 每个纹理元素
	for (UINT i = 0; i < size; ++i)
	{
		// 纹理中的每个mipmap等级
		for (UINT j = 0; j < mipLevel; ++j)
		{
			D3D11_MAPPED_SUBRESOURCE mappedTex2D;
			// 允许映射索引i纹理中，索引j的mipmap等级的2D纹理
			HR(deviceContext->Map(srcTex[i].Get(),
				j, D3D11_MAP_READ, 0, &mappedTex2D));

			deviceContext->UpdateSubresource(
				texArray.Get(),
				D3D11CalcSubresource(j, i, mipLevel),	// i * mipLevel + j
				nullptr,
				mappedTex2D.pData,
				mappedTex2D.RowPitch,
				mappedTex2D.DepthPitch);
			// 停止映射
			deviceContext->Unmap(srcTex[i].Get(), j);
		}
	}

	// ******************
	// 4.创建纹理数组的SRV
	//
	D3D11_SHADER_RESOURCE_VIEW_DESC viewDesc;
	viewDesc.Format = texArrayDesc.Format;
	viewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2DARRAY;
	viewDesc.Texture2DArray.MostDetailedMip = 0;
	viewDesc.Texture2DArray.MipLevels = texArrayDesc.MipLevels;
	viewDesc.Texture2DArray.FirstArraySlice = 0;
	viewDesc.Texture2DArray.ArraySize = size;

	ComPtr<ID3D11ShaderResourceView> texArraySRV;
	HR(device->CreateShaderResourceView(texArray.Get(), &viewDesc, texArraySRV.GetAddressOf()));


	// 已经确保所有资源由ComPtr管理，无需手动释放

	return texArraySRV;
}

ComPtr<ID3D11ShaderResourceView> CreateWICTextureCubeFromFile(
	ComPtr<ID3D11Device> device, 
	ComPtr<ID3D11DeviceContext> deviceContext, 
	std::wstring cubemapFileName,
	bool generateMips)
{
	// 检查设备与设备上下文是否非空
	if (!device || !deviceContext)
		return nullptr;

	// ******************
	// 1.读取天空盒纹理
	//

	ComPtr<ID3D11Texture2D> srcTex;
	ComPtr<ID3D11ShaderResourceView> srcTexSRV;

	// 该资源用于GPU复制
	HR(CreateWICTextureFromFileEx(device.Get(),
		deviceContext.Get(),
		cubemapFileName.c_str(),
		0,
		D3D11_USAGE_DEFAULT,
		D3D11_BIND_SHADER_RESOURCE | (generateMips ? D3D11_BIND_RENDER_TARGET : 0),
		0,
		(generateMips ? D3D11_RESOURCE_MISC_GENERATE_MIPS : 0),
		WIC_LOADER_DEFAULT,
		(ID3D11Resource**)srcTex.GetAddressOf(),
		(generateMips ? srcTexSRV.GetAddressOf() : nullptr)));
	// (可选)生成mipmap链
	if (generateMips)
	{
		deviceContext->GenerateMips(srcTexSRV.Get());
	}

	
	// ******************
	// 2.创建包含6个纹理的数组
	//

	D3D11_TEXTURE2D_DESC texDesc, texCubeDesc;
	srcTex->GetDesc(&texDesc);
	
	// 确保宽高比4:3
	assert(texDesc.Width * 3 == texDesc.Height * 4);

	UINT squareLength = texDesc.Width / 4;

	texCubeDesc.Width = squareLength;
	texCubeDesc.Height = squareLength;
	texCubeDesc.MipLevels = (generateMips ? 0 : 1);	// 指定0的情况下将生成完整mipmap链
	texCubeDesc.ArraySize = 6;
	texCubeDesc.Format = texDesc.Format;
	texCubeDesc.SampleDesc.Count = 1;
	texCubeDesc.SampleDesc.Quality = 0;
	texCubeDesc.Usage = D3D11_USAGE_DEFAULT;
	texCubeDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	texCubeDesc.CPUAccessFlags = 0;
	texCubeDesc.MiscFlags = D3D11_RESOURCE_MISC_TEXTURECUBE;	// 标记为TextureCube

	ComPtr<ID3D11Texture2D> texCube;
	HR(device->CreateTexture2D(&texCubeDesc, nullptr, texCube.GetAddressOf()));

	// ******************
	// 3.选取原天空盒纹理的6个子正方形区域，拷贝到该数组中
	//
	
	D3D11_BOX box;
	// box坐标轴如下: 
	//    front
	//   / 
	//  /_____right
	//  |
	//  |
	//  bottom
	box.front = 0;
	box.back = 1;

	for (UINT i = 0; i < texCubeDesc.MipLevels; ++i)
	{
		// +X面拷贝
		box.left = squareLength * 2;
		box.top = squareLength;
		box.right = squareLength * 3;
		box.bottom = squareLength * 2;
		deviceContext->CopySubresourceRegion(
			texCube.Get(),
			D3D11CalcSubresource(i, D3D11_TEXTURECUBE_FACE_POSITIVE_X, texCubeDesc.MipLevels),
			0, 0, 0,
			srcTex.Get(),
			i,
			&box);

		// -X面拷贝
		box.left = 0;
		box.top = squareLength;
		box.right = squareLength;
		box.bottom = squareLength * 2;
		deviceContext->CopySubresourceRegion(
			texCube.Get(),
			D3D11CalcSubresource(i, D3D11_TEXTURECUBE_FACE_NEGATIVE_X, texCubeDesc.MipLevels),
			0, 0, 0,
			srcTex.Get(),
			i,
			&box);

		// +Y面拷贝
		box.left = squareLength;
		box.top = 0;
		box.right = squareLength * 2;
		box.bottom = squareLength;
		deviceContext->CopySubresourceRegion(
			texCube.Get(),
			D3D11CalcSubresource(i, D3D11_TEXTURECUBE_FACE_POSITIVE_Y, texCubeDesc.MipLevels),
			0, 0, 0,
			srcTex.Get(),
			i,
			&box);


		// -Y面拷贝
		box.left = squareLength;
		box.top = squareLength * 2;
		box.right = squareLength * 2;
		box.bottom = squareLength * 3;
		deviceContext->CopySubresourceRegion(
			texCube.Get(),
			D3D11CalcSubresource(i, D3D11_TEXTURECUBE_FACE_NEGATIVE_Y, texCubeDesc.MipLevels),
			0, 0, 0,
			srcTex.Get(),
			i,
			&box);

		// +Z面拷贝
		box.left = squareLength;
		box.top = squareLength;
		box.right = squareLength * 2;
		box.bottom = squareLength * 2;
		deviceContext->CopySubresourceRegion(
			texCube.Get(),
			D3D11CalcSubresource(i, D3D11_TEXTURECUBE_FACE_POSITIVE_Z, texCubeDesc.MipLevels),
			0, 0, 0,
			srcTex.Get(),
			i,
			&box);

		// -Z面拷贝
		box.left = squareLength * 3;
		box.top = squareLength;
		box.right = squareLength * 4;
		box.bottom = squareLength * 2;
		deviceContext->CopySubresourceRegion(
			texCube.Get(),
			D3D11CalcSubresource(i, D3D11_TEXTURECUBE_FACE_NEGATIVE_Z, texCubeDesc.MipLevels),
			0, 0, 0,
			srcTex.Get(),
			i,
			&box);

		// 下一个mipLevel的纹理宽高都是原来的1/2
		squareLength /= 2;
	}
	

	// ******************
	// 4.创建立方体纹理的SRV
	//

	D3D11_SHADER_RESOURCE_VIEW_DESC viewDesc;
	viewDesc.Format = texCubeDesc.Format;
	viewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURECUBE;
	viewDesc.TextureCube.MostDetailedMip = 0;
	viewDesc.TextureCube.MipLevels = texCubeDesc.MipLevels;

	ComPtr<ID3D11ShaderResourceView> texCubeSRV;
	HR(device->CreateShaderResourceView(texCube.Get(), &viewDesc, texCubeSRV.GetAddressOf()));

	return texCubeSRV;
}

Microsoft::WRL::ComPtr<ID3D11ShaderResourceView> CreateWICTextureCubeFromFile(
	Microsoft::WRL::ComPtr<ID3D11Device> device, 
	Microsoft::WRL::ComPtr<ID3D11DeviceContext> deviceContext, 
	std::vector<std::wstring> cubemapFileNames, 
	bool generateMips)
{
	// 检查设备与设备上下文是否非空
	if (!device || !deviceContext)
		return nullptr;

	// 立方体纹理需要6个正方形贴图文件
	assert(cubemapFileNames.size() == 6);

	// ******************
	// 1.读取纹理
	//
	
	std::vector<ComPtr<ID3D11Texture2D>> srcTex(6);
	std::vector<ComPtr<ID3D11ShaderResourceView>> srcTexSRV(6);
	UINT width, height;
	DXGI_FORMAT format;

	for (int i = 0; i < 6; ++i)
	{
		// 该资源用于GPU复制
		HR(CreateWICTextureFromFileEx(device.Get(),
			deviceContext.Get(),
			cubemapFileNames[i].c_str(),
			0,
			D3D11_USAGE_DEFAULT,
			D3D11_BIND_SHADER_RESOURCE | (generateMips ? D3D11_BIND_RENDER_TARGET : 0),
			0,
			(generateMips ? D3D11_RESOURCE_MISC_GENERATE_MIPS : 0),
			WIC_LOADER_DEFAULT,
			(ID3D11Resource**)srcTex[i].GetAddressOf(),
			(generateMips ? srcTexSRV[i].GetAddressOf() : nullptr)));
		// (可选)生成mipmap链
		if (generateMips)
		{
			deviceContext->GenerateMips(srcTexSRV[i].Get());
		}

		D3D11_TEXTURE2D_DESC texDesc;
		srcTex[i]->GetDesc(&texDesc);
		if (i == 0)
		{
			width = texDesc.Width;
			height = texDesc.Height;
			format = texDesc.Format;
		}
		// 这里断言所有纹理的宽度和高度应当一致
		assert(texDesc.Width == width && texDesc.Height == height);
		// 这里要求所有提供的图片数据格式应当是一致的，若存在不一致的情况，请
		// 使用dxtex.exe(DirectX Texture Tool)将所有的图片转成一致的数据格式
		assert(texDesc.Format == format);
	}
	
	// ******************
	// 2.创建包含6个纹理的数组
	//

	D3D11_TEXTURE2D_DESC texDesc, texCubeDesc;
	srcTex[0]->GetDesc(&texDesc);

	texCubeDesc.Width = texDesc.Width;
	texCubeDesc.Height = texDesc.Height;
	texCubeDesc.MipLevels = (generateMips ? 0 : 1); // 指定0的情况下将生成完整mipmap链
	texCubeDesc.ArraySize = 6;
	texCubeDesc.Format = texDesc.Format;
	texCubeDesc.SampleDesc.Count = 1;
	texCubeDesc.SampleDesc.Quality = 0;
	texCubeDesc.Usage = D3D11_USAGE_DEFAULT;
	texCubeDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
	texCubeDesc.CPUAccessFlags = 0;
	texCubeDesc.MiscFlags = D3D11_RESOURCE_MISC_TEXTURECUBE;	// 标记为TextureCube

	ComPtr<ID3D11Texture2D> texCube;
	HR(device->CreateTexture2D(&texCubeDesc, nullptr, texCube.GetAddressOf()));

	// ******************
	// 3.选取原位图的6个子正方形区域，拷贝到该数组中
	//
	for (int i = 0; i < 6; ++i)
	{
		for (UINT j = 0; j < texCubeDesc.MipLevels; ++j)
		{
			deviceContext->CopySubresourceRegion(
				texCube.Get(),
				D3D11CalcSubresource(j, i, texCubeDesc.MipLevels),
				0, 0, 0,
				srcTex[i].Get(),
				j,
				nullptr);
		}
	}
	
	// ******************
	// 4.创建立方体纹理的SRV
	//

	D3D11_SHADER_RESOURCE_VIEW_DESC viewDesc;
	viewDesc.Format = texCubeDesc.Format;
	viewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURECUBE;
	viewDesc.TextureCube.MostDetailedMip = 0;
	viewDesc.TextureCube.MipLevels = texCubeDesc.MipLevels;

	ComPtr<ID3D11ShaderResourceView> texCubeSRV;
	HR(device->CreateShaderResourceView(texCube.Get(), &viewDesc, texCubeSRV.GetAddressOf()));

	return texCubeSRV;
}



```

`Direct3D11-Source/d3dUtil.h`:

```h
//***************************************************************************************
// d3dUtil.h by X_Jun(MKXJun) (C) 2018-2019 All Rights Reserved.
// Licensed under the MIT License.
//
// D3D实用工具集
// Direct3D utility tools.
//***************************************************************************************

#ifndef D3DUTIL_H
#define D3DUTIL_H

#include <d3d11_1.h>			// 已包含Windows.h
#include <DirectXCollision.h>	// 已包含DirectXMath.h
#include <DirectXColors.h>
#include <d3dcompiler.h>
#include <wrl/client.h>
#include <wincodec.h>
#include <vector>
#include <string>
#include "DXTrace.h"
#include "ScreenGrab.h"
#include "DDSTextureLoader.h"	
#include "WICTextureLoader.h"

//
// 着色器编译相关函数
//

// ------------------------------
// CreateShaderFromFile函数
// ------------------------------
// [In]csoFileNameInOut 编译好的着色器二进制文件(.cso)，若有指定则优先寻找该文件并读取
// [In]hlslFileName     着色器代码，若未找到着色器二进制文件则编译着色器代码
// [In]entryPoint       入口点(指定开始的函数)
// [In]shaderModel      着色器模型，格式为"*s_5_0"，*可以为c,d,g,h,p,v之一
// [Out]ppBlobOut       输出着色器二进制信息
HRESULT CreateShaderFromFile(const WCHAR * csoFileNameInOut, const WCHAR * hlslFileName, LPCSTR entryPoint, LPCSTR shaderModel, ID3DBlob ** ppBlobOut);


//
// 纹理数组相关函数
//

// 根据给定的DDS纹理文件集合，创建2D纹理数组
// 要求所有纹理的宽度和高度都一致
// 若maxMipMapSize为0，使用默认mipmap等级
// 否则，mipmap等级将不会超过maxMipMapSize
Microsoft::WRL::ComPtr<ID3D11ShaderResourceView> CreateDDSTexture2DArrayFromFile(
	Microsoft::WRL::ComPtr<ID3D11Device> device,
	Microsoft::WRL::ComPtr<ID3D11DeviceContext> deviceContext,
	const std::vector<std::wstring>& filenames,
	UINT maxMipMapSize = 0);



//
// 纹理立方体相关函数
//

// 根据给定的一张包含立方体六个面的纹理，创建纹理立方体
// 要求纹理宽高比为4:3，且按下面形式布局:
// .  +Y .  .
// -X +Z +X -Z 
// .  -Y .  .
// 该函数默认不生成mipmap(即等级仅为1)，若需要则设置generateMips为true
Microsoft::WRL::ComPtr<ID3D11ShaderResourceView> CreateWICTextureCubeFromFile(
	Microsoft::WRL::ComPtr<ID3D11Device> device,
	Microsoft::WRL::ComPtr<ID3D11DeviceContext> deviceContext,
	std::wstring cubemapFileName,
	bool generateMips = false);

// 根据按D3D11_TEXTURECUBE_FACE索引顺序给定的六张纹理，创建纹理立方体
// 要求纹理是同样大小的正方形
// 该函数默认不生成mipmap(即等级仅为1)，若需要则设置generateMips为true
Microsoft::WRL::ComPtr<ID3D11ShaderResourceView> CreateWICTextureCubeFromFile(
	Microsoft::WRL::ComPtr<ID3D11Device> device,
	Microsoft::WRL::ComPtr<ID3D11DeviceContext> deviceContext,
	std::vector<std::wstring> cubemapFileNames,
	bool generateMips = false);

#endif

```

`Direct3D11-Source/魔方.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.26403.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "魔方", "魔方.vcxproj", "{1B3A14D1-B957-4729-8C23-FF2919CB0B94}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1B3A14D1-B957-4729-8C23-FF2919CB0B94}.Debug|x64.ActiveCfg = Debug|x64
		{1B3A14D1-B957-4729-8C23-FF2919CB0B94}.Debug|x64.Build.0 = Debug|x64
		{1B3A14D1-B957-4729-8C23-FF2919CB0B94}.Debug|x86.ActiveCfg = Debug|Win32
		{1B3A14D1-B957-4729-8C23-FF2919CB0B94}.Debug|x86.Build.0 = Debug|Win32
		{1B3A14D1-B957-4729-8C23-FF2919CB0B94}.Release|x64.ActiveCfg = Release|x64
		{1B3A14D1-B957-4729-8C23-FF2919CB0B94}.Release|x64.Build.0 = Release|x64
		{1B3A14D1-B957-4729-8C23-FF2919CB0B94}.Release|x86.ActiveCfg = Release|Win32
		{1B3A14D1-B957-4729-8C23-FF2919CB0B94}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D81F0103-0F65-4D12-9E0D-7F7055D89D22}
	EndGlobalSection
	GlobalSection(Performance) = preSolution
		HasPerformanceSessions = true
	EndGlobalSection
EndGlobal

```

`Direct3D11-Source/魔方.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{1B3A14D1-B957-4729-8C23-FF2919CB0B94}</ProjectGuid>
    <RootNamespace>魔方</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Camera.h" />
    <ClInclude Include="Collision.h" />
    <ClInclude Include="d3dApp.h" />
    <ClInclude Include="d3dUtil.h" />
    <ClInclude Include="DDSTextureLoader.h" />
    <ClInclude Include="DXTrace.h" />
    <ClInclude Include="EffectHelper.h" />
    <ClInclude Include="Effects.h" />
    <ClInclude Include="GameApp.h" />
    <ClInclude Include="GameTimer.h" />
    <ClInclude Include="Keyboard.h" />
    <ClInclude Include="Mouse.h" />
    <ClInclude Include="Rubik.h" />
    <ClInclude Include="ScreenGrab.h" />
    <ClInclude Include="Vertex.h" />
    <ClInclude Include="WICTextureLoader.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="BasicEffect.cpp" />
    <ClCompile Include="Camera.cpp" />
    <ClCompile Include="Collision.cpp" />
    <ClCompile Include="d3dApp.cpp" />
    <ClCompile Include="d3dUtil.cpp" />
    <ClCompile Include="DDSTextureLoader.cpp" />
    <ClCompile Include="DXTrace.cpp" />
    <ClCompile Include="GameApp.cpp" />
    <ClCompile Include="GameTimer.cpp" />
    <ClCompile Include="Keyboard.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="Mouse.cpp" />
    <ClCompile Include="Rubik.cpp" />
    <ClCompile Include="ScreenGrab.cpp" />
    <ClCompile Include="Vertex.cpp" />
    <ClCompile Include="WICTextureLoader.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="HLSL\Basic.hlsli" />
    <None Include="HLSL\Basic_PS.inc">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
    <None Include="HLSL\Basic_VS.inc">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="HLSL\Basic_PS.hlsl">
      <EntryPointName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">PS</EntryPointName>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">5.0</ShaderModel>
      <VariableName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">g_%(Filename)</VariableName>
      <HeaderFileOutput Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">HLSL/%(Filename).inc</HeaderFileOutput>
      <ObjectFileOutput Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
      </ObjectFileOutput>
      <EntryPointName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">PS</EntryPointName>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">5.0</ShaderModel>
      <VariableName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">g_%(Filename)</VariableName>
      <HeaderFileOutput Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">HLSL/%(Filename).inc</HeaderFileOutput>
      <ObjectFileOutput Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
      </ObjectFileOutput>
      <EntryPointName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">PS</EntryPointName>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <VariableName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">g_%(Filename)</VariableName>
      <HeaderFileOutput Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">HLSL/%(Filename).inc</HeaderFileOutput>
      <ObjectFileOutput Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
      </ObjectFileOutput>
      <EntryPointName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">PS</EntryPointName>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <VariableName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">g_%(Filename)</VariableName>
      <HeaderFileOutput Condition="'$(Configuration)|$(Platform)'=='Release|x64'">HLSL/%(Filename).inc</HeaderFileOutput>
      <ObjectFileOutput Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
      </ObjectFileOutput>
    </FxCompile>
    <FxCompile Include="HLSL\Basic_VS.hlsl">
      <EntryPointName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">VS</EntryPointName>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">5.0</ShaderModel>
      <HeaderFileOutput Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">HLSL/%(Filename).inc</HeaderFileOutput>
      <ObjectFileOutput Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
      </ObjectFileOutput>
      <EntryPointName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">VS</EntryPointName>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">5.0</ShaderModel>
      <HeaderFileOutput Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">HLSL/%(Filename).inc</HeaderFileOutput>
      <ObjectFileOutput Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
      </ObjectFileOutput>
      <EntryPointName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">VS</EntryPointName>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">5.0</ShaderModel>
      <HeaderFileOutput Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">HLSL/%(Filename).inc</HeaderFileOutput>
      <ObjectFileOutput Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
      </ObjectFileOutput>
      <EntryPointName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">VS</EntryPointName>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">5.0</ShaderModel>
      <HeaderFileOutput Condition="'$(Configuration)|$(Platform)'=='Release|x64'">HLSL/%(Filename).inc</HeaderFileOutput>
      <ObjectFileOutput Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
      </ObjectFileOutput>
      <VariableName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">g_%(Filename)</VariableName>
      <VariableName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">g_%(Filename)</VariableName>
      <VariableName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">g_%(Filename)</VariableName>
      <VariableName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">g_%(Filename)</VariableName>
    </FxCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Direct3D11-Source/魔方.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="通用文件">
      <UniqueIdentifier>{cda24276-6181-420b-9ef3-05587ee7fab7}</UniqueIdentifier>
    </Filter>
    <Filter Include="着色器">
      <UniqueIdentifier>{57f814e6-929f-4552-9c90-b8431267acd7}</UniqueIdentifier>
    </Filter>
    <Filter Include="特效文件">
      <UniqueIdentifier>{82e6dd67-6430-4acd-be37-288bee8aa5f2}</UniqueIdentifier>
    </Filter>
    <Filter Include="模块文件">
      <UniqueIdentifier>{2dd40398-10a7-4846-9388-093879ad7e2b}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DDSTextureLoader.h">
      <Filter>通用文件</Filter>
    </ClInclude>
    <ClInclude Include="WICTextureLoader.h">
      <Filter>通用文件</Filter>
    </ClInclude>
    <ClInclude Include="ScreenGrab.h">
      <Filter>通用文件</Filter>
    </ClInclude>
    <ClInclude Include="Mouse.h">
      <Filter>通用文件</Filter>
    </ClInclude>
    <ClInclude Include="Keyboard.h">
      <Filter>通用文件</Filter>
    </ClInclude>
    <ClInclude Include="d3dApp.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="GameApp.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Rubik.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="EffectHelper.h">
      <Filter>特效文件</Filter>
    </ClInclude>
    <ClInclude Include="Effects.h">
      <Filter>特效文件</Filter>
    </ClInclude>
    <ClInclude Include="Camera.h">
      <Filter>模块文件</Filter>
    </ClInclude>
    <ClInclude Include="d3dUtil.h">
      <Filter>模块文件</Filter>
    </ClInclude>
    <ClInclude Include="DXTrace.h">
      <Filter>模块文件</Filter>
    </ClInclude>
    <ClInclude Include="Vertex.h">
      <Filter>模块文件</Filter>
    </ClInclude>
    <ClInclude Include="GameTimer.h">
      <Filter>模块文件</Filter>
    </ClInclude>
    <ClInclude Include="Collision.h">
      <Filter>模块文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="WICTextureLoader.cpp">
      <Filter>通用文件</Filter>
    </ClCompile>
    <ClCompile Include="DDSTextureLoader.cpp">
      <Filter>通用文件</Filter>
    </ClCompile>
    <ClCompile Include="ScreenGrab.cpp">
      <Filter>通用文件</Filter>
    </ClCompile>
    <ClCompile Include="Keyboard.cpp">
      <Filter>通用文件</Filter>
    </ClCompile>
    <ClCompile Include="Mouse.cpp">
      <Filter>通用文件</Filter>
    </ClCompile>
    <ClCompile Include="d3dApp.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="GameApp.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="Rubik.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="BasicEffect.cpp">
      <Filter>特效文件</Filter>
    </ClCompile>
    <ClCompile Include="Camera.cpp">
      <Filter>模块文件</Filter>
    </ClCompile>
    <ClCompile Include="DXTrace.cpp">
      <Filter>模块文件</Filter>
    </ClCompile>
    <ClCompile Include="d3dUtil.cpp">
      <Filter>模块文件</Filter>
    </ClCompile>
    <ClCompile Include="Vertex.cpp">
      <Filter>模块文件</Filter>
    </ClCompile>
    <ClCompile Include="GameTimer.cpp">
      <Filter>模块文件</Filter>
    </ClCompile>
    <ClCompile Include="Main.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="Collision.cpp">
      <Filter>模块文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="HLSL\Basic.hlsli">
      <Filter>着色器</Filter>
    </None>
    <None Include="HLSL\Basic_PS.inc">
      <Filter>着色器</Filter>
    </None>
    <None Include="HLSL\Basic_VS.inc">
      <Filter>着色器</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="HLSL\Basic_PS.hlsl">
      <Filter>着色器</Filter>
    </FxCompile>
    <FxCompile Include="HLSL\Basic_VS.hlsl">
      <Filter>着色器</Filter>
    </FxCompile>
  </ItemGroup>
</Project>
```

`Direct3D9-Source/DirectX.cpp`:

```cpp
#include "DirectX.h"
//变量声明区
LPDIRECT3D9 d3d;													
LPDIRECT3DDEVICE9 d3ddev;											
D3DPRESENT_PARAMETERS d3dpp;

LPDIRECTINPUT8 dinput;												
LPDIRECTINPUTDEVICE8 dikeyboard;									
char keys[256];
LPDIRECTINPUTDEVICE8 dimouse;										
DIMOUSESTATE mouse_state;		
bool slide = false;

LPDIRECT3DTEXTURE9 red, yellow, blue, green, white, orange, black;	

LPDIRECT3DVERTEXBUFFER9 vb;											
LPDIRECT3DINDEXBUFFER9 ib;											

LPD3DXFONT font;													
RECT font_rect = { 400, 0, 600, 50 };								
RECT window_rect;													
POINT mouse_pos;
POINT click_pos;

DWORD start_time;
DWORD finish_time;
DWORD current_time = timeGetTime();									
DWORD frameCnt = 0;
DWORD fps = 0;
DWORD delay = 8;													
DWORD frame_timer = timeGetTime();									
DWORD key_down_counter;												
DWORD slide_delay = 0;

float preview_rotation = 0.0f;


bool use_pick = true;

D3DXVECTOR3 pos(12.0f, 12.0f, -12.0f);
D3DXVECTOR3 target(0.0f, 0.0f, 0.0f);
D3DXVECTOR3 up(-1.0f, 8.0f, 1.0f);

D3DMATERIAL9 material;

D3DLIGHT9 light;

stack<function<void()>> func_stk;

//创建纹理
LPDIRECT3DTEXTURE9 LoadTexture(const char * filename)
{
	LPDIRECT3DTEXTURE9 texture = nullptr;
	D3DXCreateTextureFromFile(d3ddev, filename, &texture);
	if (!texture)
		return nullptr;
	return texture;
}

// 世界变换
void WorldTransform()
{
	D3DXMATRIX matWorld;
	D3DXMatrixTranslation(&matWorld, 0.0f, 0.0f, 0.0f);
	d3ddev->SetTransform(D3DTS_WORLD, &matWorld);
}

// 取景变换，eye为摄影机位置，lookAt为摄影机朝向，up为摄影机上方向
void ViewTransform(const D3DXVECTOR3& eye,const D3DXVECTOR3& lookAt,const D3DXVECTOR3& up)
{
	D3DXMATRIX View;
	D3DXMatrixLookAtLH(&View, &eye, &lookAt, &up);
	d3ddev->SetTransform(D3DTS_VIEW, &View);
}

// 投影变换，fieldOfView为垂直视野角度，aspectRatio为宽高比，nearRange为前裁减面距离，farRange为后裁减面距离
void PerspectiveTransform(float fieldOfView, float aspectRatio, float nearRange, float farRange)
{
	D3DXMATRIX proj;
	D3DXMatrixPerspectiveFovLH(&proj, fieldOfView, aspectRatio, nearRange, farRange);
	d3ddev->SetTransform(D3DTS_PROJECTION, &proj);
}

//Direct3D接口与设备初始化
bool Direct3D_Init(HWND window)
{
	//创建D3D9对象
	d3d = Direct3DCreate9(D3D_SDK_VERSION);
	if (!d3d)
		return false;
	//初始化输入设备
	if (!DirectInput_Init(window))
		return false;

	D3DDISPLAYMODE displaymode;
	if (FAILED(d3d->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &displaymode)))
		return false;

	//填充D3D参数
	
	ZeroMemory(&d3dpp, sizeof(d3dpp));
	d3dpp.BackBufferWidth = SCREENW;		//后备缓冲区宽度
	d3dpp.BackBufferHeight = SCREENH;		//后备缓冲区高度
	d3dpp.BackBufferFormat = D3DFMT_X8R8G8B8;
	d3dpp.BackBufferCount = 1;				//后备缓冲区数目
	d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
	d3dpp.Windowed = true;		//窗口化
	d3dpp.hDeviceWindow = window;
	d3dpp.EnableAutoDepthStencil = 1;
	d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
	d3dpp.Flags = D3DPRESENTFLAG_DISCARD_DEPTHSTENCIL;
	d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
	d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE;
	d3dpp.MultiSampleQuality = 0;

	//检测硬件是否支持4倍抗锯齿，支持的话直接使用
	if (d3d->CheckDeviceMultiSampleType(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, displaymode.Format, true, D3DMULTISAMPLE_4_SAMPLES, nullptr) == D3D_OK)
		d3dpp.MultiSampleType = D3DMULTISAMPLE_4_SAMPLES;
	
	//创建设备
	d3d->CreateDevice(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL,window,D3DCREATE_HARDWARE_VERTEXPROCESSING,&d3dpp,&d3ddev);
	
	if (!d3ddev)
		return false;

	

	//顶点和索引缓冲区初始化，由于顶点索引是固定的，在此一并初始化
	d3ddev->CreateVertexBuffer(648 * sizeof(Vetrex),D3DUSAGE_WRITEONLY,D3DFVF_MYVETREX,D3DPOOL_MANAGED,&vb,0);
	d3ddev->CreateIndexBuffer(972 * sizeof(WORD),D3DUSAGE_WRITEONLY,D3DFMT_INDEX16,D3DPOOL_MANAGED,&ib,0);

	WORD* indices;
	ib->Lock(0, 0, (void**)&indices, 0);

	for (int i = 0; i < 162; ++i)
	{
		indices[i * 6 + 0] = 4 * i + 0;
		indices[i * 6 + 1] = 4 * i + 1;
		indices[i * 6 + 2] = 4 * i + 2;
		indices[i * 6 + 3] = 4 * i + 2;
		indices[i * 6 + 4] = 4 * i + 3;
		indices[i * 6 + 5] = 4 * i + 0;
	}
	ib->Unlock();


	//设置过滤器
	d3ddev->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
	d3ddev->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
	d3ddev->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);

	//初始化字体
	D3DXFONT_DESC desc = { 30,0,0,0,false,DEFAULT_CHARSET,OUT_TT_PRECIS,CLIP_DEFAULT_PRECIS,DEFAULT_PITCH,"Arial" };
	D3DXCreateFontIndirect(d3ddev, &desc, &font);

	//纹理读取
	red = LoadTexture("Resource/Red.png");
	green = LoadTexture("Resource/Green.png");
	yellow = LoadTexture("Resource/Yellow.png");
	blue = LoadTexture("Resource/Blue.png");
	white = LoadTexture("Resource/White.png");
	orange = LoadTexture("Resource/Orange.png");
	black = LoadTexture("Resource/Black.png");
	
	//纹理材质
	ZeroMemory(&material, sizeof(material));
	material.Diffuse = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);
	material.Ambient = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);
	material.Specular = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);
	material.Emissive = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);
	material.Power = 5.0f;

	d3ddev->SetMaterial(&material);

	//灯光初始化
	ZeroMemory(&light, sizeof(light));
	light.Type = D3DLIGHT_DIRECTIONAL;
	light.Ambient = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);
	light.Diffuse = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);
	light.Specular = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);
	light.Direction = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
	d3ddev->SetLight(0, &light);
	d3ddev->LightEnable(0, true);
	d3ddev->SetRenderState(D3DRS_LIGHTING, true);
	d3ddev->SetRenderState(D3DRS_NORMALIZENORMALS, true);


	return true;
}

void Direct3D_Reset(HWND window)
{
	if (d3ddev->TestCooperativeLevel() == D3DERR_DEVICENOTRESET)
	{
		font->OnLostDevice();
		d3ddev->Reset(&d3dpp);
		font->OnResetDevice();
		WorldTransform();
		ViewTransform(pos, target, up);
		PerspectiveTransform(D3DX_PI * 0.4f, (float)SCREENW / (float)SCREENH, 1.0f, 1000.0f);

		d3ddev->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
		d3ddev->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
		d3ddev->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);

		d3ddev->SetMaterial(&material);

		d3ddev->SetLight(0, &light);
		d3ddev->LightEnable(0, true);
		d3ddev->SetRenderState(D3DRS_LIGHTING, true);
		d3ddev->SetRenderState(D3DRS_NORMALIZENORMALS, true);
	}
}

//释放Direct3D相关
void Direct3D_Shutdown()
{
	if (d3ddev) d3ddev->Release();
	if (d3d) d3d->Release();
	if (vb) vb->Release();

	if (red) red->Release();
	if (green) green->Release();
	if (blue) blue->Release();
	if (white) white->Release();
	if (yellow) yellow->Release();
	if (orange) orange->Release();
	if (black) black->Release();

	if (font) font->Release();

	DirectInput_Shutdown();
}

//DirectInput初始化
bool DirectInput_Init(HWND window)
{
	//Direct输入对象创建
	DirectInput8Create(GetModuleHandle(nullptr), DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&dinput, nullptr);

	//初始化键盘
	dinput->CreateDevice(GUID_SysKeyboard, &dikeyboard, nullptr);
	dikeyboard->SetDataFormat(&c_dfDIKeyboard);
	dikeyboard->SetCooperativeLevel(window, DISCL_NONEXCLUSIVE | DISCL_FOREGROUND);
	dikeyboard->Acquire();

	//初始化鼠标
	dinput->CreateDevice(GUID_SysMouse, &dimouse, nullptr);
	dimouse->SetDataFormat(&c_dfDIMouse);
	dimouse->SetCooperativeLevel(window, DISCL_NONEXCLUSIVE | DISCL_FOREGROUND);
	dimouse->Acquire();
	return true;
}

//DirectInput更新
void DirectInput_Update()
{
	//更新键盘
	dikeyboard->Poll();
	if (!SUCCEEDED(dikeyboard->GetDeviceState(256, (LPVOID)&keys)))
	{
		//键盘设备丢失，尝试重新获取
		dikeyboard->Acquire();
	}

	//更新鼠标
	dimouse->Poll();
	if (!SUCCEEDED(dimouse->GetDeviceState(sizeof(DIMOUSESTATE), &mouse_state)))
	{
		//鼠标设备丢失，尝试重新获取
		dimouse->Acquire();
	}
}

//DirectInput释放
void DirectInput_Shutdown()
{
	if (dikeyboard)
	{
		dikeyboard->Unacquire();
		dikeyboard->Release();
		dikeyboard = nullptr;
	}
	if (dimouse)
	{
		dimouse->Unacquire();
		dimouse->Release();
		dimouse = nullptr;
	}
	dinput->Release();
}

//检测键盘按键
bool Key_Down(int key)
{
	return (bool)(keys[key] & 0x80);
}

//检测鼠标按键，0为鼠标左键
bool Mouse_Click(int button)
{
	return mouse_state.rgbButtons[button] & 0x80;
}

//处理sin(D3DX_PI)结果不为0的情况
double MySin(double _X)
{
	double res = sin(_X);
	return fabs(res) < 10e-5 ? 0.0 : res;
}

//处理cos(D3DX_PI / 2)结果不为0的情况
double MyCos(double _X)
{
	double res = cos(_X);
	return fabs(res) < 10e-5 ? 0.0 : res;
}



```

`Direct3D9-Source/DirectX.h`:

```h
#pragma once
#define WIN32_EXTRA_LEAN
#define DIRECTINPUT_VERSION 0x0800
#include <d3dx9.h>
#include <d3d9.h>
#include <ctime>
#include <Windows.h>
#include <string>
#include <dinput.h>
#include <cstdlib>
#include <fstream>
#include <algorithm>
#include <stack>
#include <functional>

#pragma comment(lib, "winmm.lib")
#pragma comment(lib, "d3dx9.lib")
#pragma comment(lib, "d3d9.lib")
#pragma comment(lib,"dinput8.lib")
#pragma comment(lib,"user32.lib")
#pragma comment(lib,"gdi32.lib")
#pragma comment(lib,"dxguid.lib")

//定义区
#define D3DFVF_MYVETREX (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1)
#define KEY_DOWN(vk_code) ((GetAsyncKeyState(vk_code) & 0x8000) ? 1 : 0)
#define SCREENW 600		//屏幕宽度
#define SCREENH 600		//屏幕高度

using std::stack;
using std::function;

struct Vetrex
{
	D3DXVECTOR3 pos;		//位置坐标
	D3DXVECTOR3 normal;		//法线
	float u, v;				//纹理坐标
	Vetrex()
		: pos{}, normal{}, u{}, v{}
	{
	}

	Vetrex(float x, float y, float z, float nx, float ny, float nz, float u, float v)
		: pos(x,y,z), normal(nx, ny, nz), u(u), v(v)
	{
	}
};

extern LPDIRECT3D9 d3d;							//D3D9接口
extern LPDIRECT3DDEVICE9 d3ddev;				//D3D9设备
extern D3DPRESENT_PARAMETERS d3dpp;				//D3D参数


extern LPDIRECTINPUT8 dinput;					//输入接口
extern LPDIRECTINPUTDEVICE8 dikeyboard;			//键盘接口
extern char keys[256];							//记录按键状态
extern LPDIRECTINPUTDEVICE8 dimouse;			//鼠标接口
extern DIMOUSESTATE mouse_state;				//鼠标状态
extern bool slide;								//鼠标滑动中


extern LPDIRECT3DTEXTURE9 red, yellow, blue,
green, white, orange, black;		//魔方面颜色

extern LPDIRECT3DVERTEXBUFFER9 vb;				//D3D顶点缓存
extern LPDIRECT3DINDEXBUFFER9 ib;				//D3D顶点缓存

extern LPD3DXFONT font;							//字体
extern RECT font_rect;							//输出矩形
extern RECT window_rect;						//窗体矩形
extern POINT mouse_pos;							//鼠标位置
extern POINT click_pos;							//点击位置

extern DWORD start_time;						//游戏开始的时间
extern DWORD finish_time;						//完成魔方的时间
extern DWORD current_time;						//计时器
extern DWORD frameCnt;							//帧计数器
extern DWORD fps;								//帧每秒				
extern DWORD delay;								//一帧间隔
extern DWORD frame_timer;						//帧计时器
extern DWORD key_down_counter;					//按键间隔计数，18帧一按
extern DWORD slide_delay;						//滑动延迟

extern bool use_pick;							//为true时使用动态拾取，false时使用静态描点

//照相机初始位置，朝向目标，摄影机上视角
extern D3DXVECTOR3 pos;
extern D3DXVECTOR3 target;
extern D3DXVECTOR3 up;

extern D3DMATERIAL9 material;					//纹理材质

extern D3DLIGHT9 light;							//灯光

extern stack<function<void()>> func_stk;		//函数栈，保存了魔方逆操作

//函数区
// DirectX部分
LPDIRECT3DTEXTURE9 LoadTexture(const char * filename);


void WorldTransform();
void ViewTransform(const D3DXVECTOR3& eye, const D3DXVECTOR3& lookAt, const D3DXVECTOR3& up);
void PerspectiveTransform(float fieldOfView, float aspectRatio, float nearRange, float farRange);


bool Direct3D_Init(HWND window);
void Direct3D_Reset(HWND window);
void Direct3D_Shutdown();

//DirectInput部分
bool DirectInput_Init(HWND window);
void DirectInput_Update();
void DirectInput_Shutdown();
bool Key_Down(int key);
bool Mouse_Click(int button);

//数学部分
double MySin(double _X);
double MyCos(double _X);
//游戏部分
bool Game_Init(HWND window);
void Game_Run(HWND window);
void Game_End();
void PreView();


void Key_Update(HWND window);
void Mouse_Update(HWND window);

bool Click_Rect(const POINT& LeftBottom, const POINT& LeftTop, const POINT& RightTop, const POINT& RightBottom);
bool IsPick(HWND window, const Vetrex& LeftBottom, const Vetrex& LeftTop, const Vetrex& RightTop, const Vetrex& RightBottom);
//自定义带精度浮点数转换（只能在VS2017中使用）
_STD_BEGIN
std::string to_string(float _Val, int precision);
_STD_END
```

`Direct3D9-Source/MyGame.cpp`:

```cpp
#include "DirectX.h"
#include "Rubik.h"
extern Rubik rubik;
extern float preview_rotation;
//初始化
bool Game_Init(HWND window)
{
	Direct3D_Init(window);

	//魔方重置即初始化
	rubik.reset();

	//世界变换
	WorldTransform();

	//视角变换
	ViewTransform(pos, target, up);

	//投影变换
	PerspectiveTransform(D3DX_PI * 0.4f, (float)SCREENW / (float)SCREENH, 1.0f, 1000.0f);

	//视口变换使用默认

	return true;
}

void Game_Run(HWND window)
{
	DirectInput_Update();
	
	//控制每秒120帧左右
	if (timeGetTime() - current_time > delay)
	{
		PreView();		//开场视角旋转动画
		rubik.update();	
		Key_Update(window);		//键盘更新
		Mouse_Update(window);	//鼠标更新
		//清屏
		d3ddev->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, D3DCOLOR_XRGB(117, 108, 131), 1.0f, 0);

		if (d3ddev->BeginScene())									//开始渲染
		{
			rubik.show();
			

			d3ddev->EndScene();										//停止渲染

			HRESULT hresult = d3ddev->Present(nullptr, nullptr, nullptr, nullptr);	//前台后台交换
			

			if (hresult == D3DERR_DEVICELOST)						//处理设备丢失
				Direct3D_Reset(window);
		}

		frameCnt++;
		
		current_time = timeGetTime();
	}

	//调整帧数在120左右
	if (timeGetTime() - frame_timer > 1000)
	{
		if (frameCnt > 126)
			delay++;
		else if (frameCnt < 114)
			delay--;
		fps = frameCnt;
		frame_timer = timeGetTime();
		frameCnt = 0;
	}
	//检测魔方还原
	if (!rubik.shuffle_times)
		rubik.check_complete(window);

}

void Game_End()
{
	Direct3D_Shutdown();
}

void PreView()
{
	if (pos.x <= 6.0f)
	{
		pos = D3DXVECTOR3(6.0f, 6.0f, -6.0f);
		return;
	}
	pos.x -= 0.01f;
	pos.y -= 0.01f;
	pos.z += 0.01f;
	ViewTransform(pos, target, up);
}

void Key_Update(HWND window)
{
	//按键间隔内禁止操作（魔方在旋转中）
	if (key_down_counter)
	{
		key_down_counter--;
		return;
	}
	//打乱魔方时禁止操作
	if (rubik.shuffle_times)	
		return;
	//鼠标操作时静止键盘操作
	if (slide)	
		return;

	//撤销操作
	if (Key_Down(DIK_LCONTROL) && Key_Down(DIK_Z))
	{
		if (func_stk.size() > 0)
		{
			func_stk.top()();
			func_stk.pop();
		}
		else
			return;
	}
	////拧动魔方部分
	//双面拧动部分
	else if (Key_Down(DIK_LCONTROL) && Key_Down(DIK_I))
	{
		rubik.rotate_YZ(2, false);
		rubik.rotate_YZ(1, false);
		func_stk.push(std::bind(&Rubik::rotate_YZ, rubik, 2, true));
		func_stk.push(std::bind(&Rubik::rotate_YZ, rubik, 1, true));
	}
	else if (Key_Down(DIK_LCONTROL) && Key_Down(DIK_K))
	{
		rubik.rotate_YZ(2, true);
		rubik.rotate_YZ(1, true);
		func_stk.push(std::bind(&Rubik::rotate_YZ, rubik, 2, false));
		func_stk.push(std::bind(&Rubik::rotate_YZ, rubik, 1, false));
	}
	else if (Key_Down(DIK_LCONTROL) && Key_Down(DIK_J))
	{
		rubik.rotate_XZ(2, false);
		rubik.rotate_XZ(1, false);
		func_stk.push(std::bind(&Rubik::rotate_XZ, rubik, 2, true));
		func_stk.push(std::bind(&Rubik::rotate_XZ, rubik, 1, true));
	}
	else if (Key_Down(DIK_LCONTROL) && Key_Down(DIK_L))
	{
		rubik.rotate_XZ(2, true);
		rubik.rotate_XZ(1, true);
		func_stk.push(std::bind(&Rubik::rotate_XZ, rubik, 2, false));
		func_stk.push(std::bind(&Rubik::rotate_XZ, rubik, 1, false));
	}
	else if (Key_Down(DIK_LCONTROL) && Key_Down(DIK_U))
	{
		rubik.rotate_XY(0, true);
		rubik.rotate_XY(1, true);
		func_stk.push(std::bind(&Rubik::rotate_XY, rubik, 0, false));
		func_stk.push(std::bind(&Rubik::rotate_XY, rubik, 1, false));
	}
	else if (Key_Down(DIK_LCONTROL) && Key_Down(DIK_O))
	{
		rubik.rotate_XY(0, false);
		rubik.rotate_XY(1, false);
		func_stk.push(std::bind(&Rubik::rotate_XY, rubik, 0, true));
		func_stk.push(std::bind(&Rubik::rotate_XY, rubik, 1, true));
	}
	//单面拧动部分
	else if (Key_Down(DIK_I))
	{
		rubik.rotate_YZ(2, false);
		func_stk.push(std::bind(&Rubik::rotate_YZ, rubik, 2, true));
	}
	else if (Key_Down(DIK_K))
	{
		rubik.rotate_YZ(2, true);
		func_stk.push(std::bind(&Rubik::rotate_YZ, rubik, 2, false));
	}	
	else if (Key_Down(DIK_J))
	{
		rubik.rotate_XZ(2, false);
		func_stk.push(std::bind(&Rubik::rotate_XZ, rubik, 2, true));
	}
	else if (Key_Down(DIK_L))
	{
		rubik.rotate_XZ(2, true);
		func_stk.push(std::bind(&Rubik::rotate_XZ, rubik, 2, false));
	}
	else if (Key_Down(DIK_U))
	{
		rubik.rotate_XY(0, true);
		func_stk.push(std::bind(&Rubik::rotate_XY, rubik, 0, false));
	}
	else if (Key_Down(DIK_O))
	{
		rubik.rotate_XY(0, false);
		func_stk.push(std::bind(&Rubik::rotate_XY, rubik, 0, true));
	}
		

	else if (Key_Down(DIK_T))
	{
		rubik.rotate_YZ(1, false);
		func_stk.push(std::bind(&Rubik::rotate_YZ, rubik, 1, true));
	}
	else if (Key_Down(DIK_G))
	{
		rubik.rotate_YZ(1, true);
		func_stk.push(std::bind(&Rubik::rotate_YZ, rubik, 1, false));
	}
	else if (Key_Down(DIK_F))
	{
		rubik.rotate_XZ(1, false);
		func_stk.push(std::bind(&Rubik::rotate_XZ, rubik, 1, true));
	}
	else if (Key_Down(DIK_H))
	{
		rubik.rotate_XZ(1, true);
		func_stk.push(std::bind(&Rubik::rotate_XZ, rubik, 1, false));
	}
	else if (Key_Down(DIK_R))
	{
		rubik.rotate_XY(1, true);
		func_stk.push(std::bind(&Rubik::rotate_XY, rubik, 1, false));
	}
	else if (Key_Down(DIK_Y))
	{
		rubik.rotate_XY(1, false);
		func_stk.push(std::bind(&Rubik::rotate_XY, rubik, 1, true));
	}


	else if (Key_Down(DIK_W))
	{
		rubik.rotate_YZ(0, false);
		func_stk.push(std::bind(&Rubik::rotate_YZ, rubik, 0, true));
	}
	else if (Key_Down(DIK_S))
	{
		rubik.rotate_YZ(0, true);
		func_stk.push(std::bind(&Rubik::rotate_YZ, rubik, 0, false));
	}
	else if (Key_Down(DIK_A))
	{
		rubik.rotate_XZ(0, false);
		func_stk.push(std::bind(&Rubik::rotate_XZ, rubik, 0, true));
	}
	else if (Key_Down(DIK_D))
	{
		rubik.rotate_XZ(0, true);
		func_stk.push(std::bind(&Rubik::rotate_XZ, rubik, 0, false));
	}
	else if (Key_Down(DIK_Q))
	{
		rubik.rotate_XY(2, true);
		func_stk.push(std::bind(&Rubik::rotate_XY, rubik, 2, false));
	}
	else if (Key_Down(DIK_E))
	{
		rubik.rotate_XY(2, false);
		func_stk.push(std::bind(&Rubik::rotate_XY, rubik, 2, true));
	}
		

	//整个魔方旋转  部分
	else if (Key_Down(DIK_UP))
	{
		rubik.view_rotate_X(false);
		func_stk.push(std::bind(&Rubik::view_rotate_X, rubik, true));
	}
	else if (Key_Down(DIK_DOWN))
	{
		rubik.view_rotate_X(true);
		func_stk.push(std::bind(&Rubik::view_rotate_X, rubik, false));
	}
	else if (Key_Down(DIK_LEFT))
	{
		rubik.view_rotate_Y(false);
		func_stk.push(std::bind(&Rubik::view_rotate_Y, rubik, true));
	}
	else if (Key_Down(DIK_RIGHT))
	{
		rubik.view_rotate_Y(true);
		func_stk.push(std::bind(&Rubik::view_rotate_Y, rubik, false));
	}
	else if (Key_Down(DIK_PGUP))
	{
		rubik.view_rotate_Z(true);
		func_stk.push(std::bind(&Rubik::view_rotate_Z, rubik, false));
	}
	else if (Key_Down(DIK_PGDN))
	{
		rubik.view_rotate_Z(false);
		func_stk.push(std::bind(&Rubik::view_rotate_Z, rubik, true));
	}
		

	//切换模式判定
	else if (Key_Down(DIK_F9))
	{
		use_pick = !use_pick;
		std::string str = "当前模式为：";
		str += use_pick ? "动态拾取" : "静态描点";
		MessageBox(window, str.c_str(), "注意", MB_OK);
		if (!use_pick)
		{
			pos = D3DXVECTOR3(6.0f, 6.0f, -6.0f);
			ViewTransform(pos, target, up);
		}
		return;
	}
	//复原魔方
	else if (Key_Down(DIK_F10))
	{
		rubik.reset();
		
		rubik.shuffle_times = 0;
		rubik.complete = true;
		return;
	}
	//重置游戏
	else if (Key_Down(DIK_F11))
	{
		rubik.reset();
		pos = D3DXVECTOR3(12.0f, 12.0f, -12.0f);
		return;
	}
	//排行榜
	else if (Key_Down(DIK_F12))
	{
		std::ifstream fin("user.dat", std::ios::binary);
		float second;
		std::string str = "作者：X_Jun\n\n排名    用时\n";
		if (fin.is_open())
		{
			for (int i = 0; i < 5; ++i)
			{
				fin.read(reinterpret_cast<char*>(&second), sizeof(float));
				str += " " + std::to_string(i + 1) + "       " + std::to_string(second, 3) + "s\n";
			}
			fin.close();
		}
		else
		{
			for (int i = 0; i < 5; ++i)
				str += " " + std::to_string(i + 1) + "       9999.999s\n";
		}
		str += "\n";
		MessageBox(window, str.c_str(), "关于魔方", MB_OK);
		return;
	}
	//没检测到按键则提前结束
	else
		return;

	//实质性转动将开始计时
	if (!rubik.complete && !start_time) start_time = timeGetTime();
	key_down_counter = 20;
}

void Mouse_Update(HWND window)
{
	POINT prev_pos = { mouse_pos.x, mouse_pos.y };
	GetCursorPos(&mouse_pos);	//鼠标的全局坐标
	GetWindowRect(window, &window_rect);	//窗口的位置
	//求得鼠标在窗口内的绝对坐标
	mouse_pos.x -= window_rect.left;
	mouse_pos.y -= window_rect.top;

	
	if (rubik.shuffle_times)
		return;
	//增加滑动延迟让拖动效果理想些
	if (slide_delay)
	{
		slide_delay--;
		return;
	}

	//使用动态拾取时，视角可以随着鼠标移动带动魔方轻微旋转
	if (use_pick)
	{
		//水平方向
		D3DXVECTOR3 center{ 6.0f, 6.0f, -6.0f }, raw_up{ -1.0f, 8.0f, 1.0f };
		D3DXVECTOR4 vec4;
		D3DXMATRIX matrix;
		D3DXMatrixRotationY(&matrix, 0.0001f * (mouse_pos.x - 300));
		D3DXVec3Transform(&vec4, &center, &matrix);
		pos.x = vec4.x;
		pos.y = vec4.y;
		pos.z = vec4.z;
		
		D3DXVec3Transform(&vec4, &raw_up, &matrix);
		up.x = vec4.x;
		up.y = vec4.y;
		up.z = vec4.z;

		//竖直方向
		D3DXVECTOR3 axis{ 1.0f, 0.0f, 1.0f };
		D3DXVec3Transform(&vec4, &axis, &matrix);
		axis.x = vec4.x;
		axis.y = vec4.y;
		axis.z = vec4.z;

		D3DXMatrixRotationAxis(&matrix, &axis, 0.0001f * (mouse_pos.y - 300));
		D3DXVec3Transform(&vec4, &pos, &matrix);
		pos.x = vec4.x;
		pos.y = vec4.y;
		pos.z = vec4.z;

		D3DXVec3Transform(&vec4, &up, &matrix);
		up.x = vec4.x;
		up.y = vec4.y;
		up.z = vec4.z;


		ViewTransform(pos, target, up);
	}

	//未触发点击
	if (!Mouse_Click(0))
	{
		if (slide)
		{
			//停止滑动
			slide = false;
			if (rubik.XY || rubik.YZ || rubik.XZ)
			{
				//若滑动产生大幅度转动魔方，进行调整
				int current_degree = rubik.degree;

				//实质性转动将开始计时
				if ((current_degree > 45 || current_degree < -45) && !start_time && !rubik.complete)
					start_time = timeGetTime();

				while (current_degree > 45 || current_degree < -45)
				{
					if (rubik.XY)
					{
						for (int k = 0; k < 3; ++k)
							if (rubik.cube[0][0][k].rotating)
							{
								rubik.rotate_XY(k, current_degree > 45);
								func_stk.push(std::bind(&Rubik::rotate_XY, rubik, k, !(current_degree > 45)));
							}

						if (rubik.cube[0][0][0].rotating && rubik.cube[0][0][1].rotating && rubik.cube[0][0][2].rotating && func_stk.size() >= 3)
						{
							func_stk.pop();
							func_stk.pop();
							func_stk.pop();
							func_stk.push(std::bind(&Rubik::view_rotate_Z, rubik, !(current_degree > 45)));
						}
								
					}
					else if (rubik.YZ)
					{
						for (int i = 0; i < 3; ++i)
							if (rubik.cube[i][0][0].rotating)
							{
								rubik.rotate_YZ(i, current_degree < -45);
								func_stk.push(std::bind(&Rubik::rotate_YZ, rubik, i, !(current_degree < -45)));
							}

						if (rubik.cube[0][0][0].rotating && rubik.cube[1][0][0].rotating && rubik.cube[2][0][0].rotating && func_stk.size() >= 3)
						{
							func_stk.pop();
							func_stk.pop();
							func_stk.pop();
							func_stk.push(std::bind(&Rubik::view_rotate_X, rubik, !(current_degree < -45)));
						}

					}
					else
					{
						for (int j = 0; j < 3; ++j)
							if (rubik.cube[0][j][0].rotating)
							{
								rubik.rotate_XZ(j, current_degree < -45);
								func_stk.push(std::bind(&Rubik::rotate_XZ, rubik, j, !(current_degree < -45)));
							}

						if (rubik.cube[0][0][0].rotating && rubik.cube[0][1][0].rotating && rubik.cube[0][2][0].rotating && func_stk.size() >= 3)
						{
							func_stk.pop();
							func_stk.pop();
							func_stk.pop();
							func_stk.push(std::bind(&Rubik::view_rotate_Y, rubik, !(current_degree < -45)));
						}
								
					}
					current_degree -= current_degree > 45 ? 90 : -90;
					
				}
				rubik.degree = current_degree;
			}
		}
		
		return;
	}
	else if (!slide)
	{
		click_pos = mouse_pos;
		slide = true;
		slide_delay = 5;
		return;
	}
		

	//没有确定转动方向时
	if (!rubik.XY && !rubik.YZ && !rubik.XZ)
	{
		if (click_pos.x == mouse_pos.x && click_pos.y == mouse_pos.y)
			return;
		//判断顶面的点击和滑动方向
		if ((float)(mouse_pos.y - click_pos.y) / (float)(mouse_pos.x - click_pos.x) > 0.0f)
		{
			for (int k = 0; k < 3; ++k)
			{
				if (use_pick ? IsPick(window, rubik.cube[0][2][k].v[0], rubik.cube[0][2][k].v[1], rubik.cube[2][2][k].v[2], rubik.cube[2][2][k].v[3]) :
					Click_Rect(rubik.position[0][k][0], rubik.position[0][k + 1][0], rubik.position[0][k + 1][3], rubik.position[0][k][3]))
				{
					rubik.XY = true;
					for (int i = 0; i < 3; ++i)
						for (int j = 0; j < 3; ++j)
							rubik.cube[i][j][k].rotating = true;
					return;
				}
			}
		}
		else
		{
			for (int i = 0; i < 3; ++i)
			{
				if (use_pick ? IsPick(window, rubik.cube[i][2][0].v[0], rubik.cube[i][2][2].v[1], rubik.cube[i][2][2].v[2], rubik.cube[i][2][0].v[3]) :
					Click_Rect(rubik.position[0][0][i], rubik.position[0][3][i], rubik.position[0][3][i + 1], rubik.position[0][0][i + 1]))
				{
					rubik.YZ = true;
					for (int j = 0; j < 3; ++j)
						for (int k = 0; k < 3; ++k)
							rubik.cube[i][j][k].rotating = true;
					return;
				}
			}
		}

		//判断正面的点击和滑动方向
		if (fabs((float)(mouse_pos.y - click_pos.y) / (float)(mouse_pos.x - click_pos.x)) < 1.0f)
		{
			for (int j = 0; j < 3; ++j)
			{
				if (use_pick ? IsPick(window, rubik.cube[0][j][0].v[16], rubik.cube[0][j][0].v[17], rubik.cube[2][j][0].v[18], rubik.cube[2][j][0].v[19]) :
					Click_Rect(rubik.position[1][j][0], rubik.position[1][j + 1][0], rubik.position[1][j + 1][3], rubik.position[1][j][3]))
				{
					rubik.XZ = true;
					for (int i = 0; i < 3; ++i)
						for (int k = 0; k < 3; ++k)
							rubik.cube[i][j][k].rotating = true;
					return;
				}
			}
		}
		else
		{
			for (int i = 0; i < 3; ++i)
			{
				if (use_pick ? IsPick(window, rubik.cube[i][0][0].v[16], rubik.cube[i][2][0].v[17], rubik.cube[i][2][0].v[18], rubik.cube[i][0][0].v[19]) :
					Click_Rect(rubik.position[1][0][i], rubik.position[1][3][i], rubik.position[1][3][i + 1], rubik.position[1][0][i + 1]))
				{
					rubik.YZ = true;
					for (int j = 0; j < 3; ++j)
						for (int k = 0; k < 3; ++k)
							rubik.cube[i][j][k].rotating = true;
					return;
				}
			}
		}
		
		//判断右面的点击和滑动方向
		if (((mouse_pos.y - click_pos.y) && !(mouse_pos.x - click_pos.x)) || fabs((float)(mouse_pos.y - click_pos.y) / (float)(mouse_pos.x - click_pos.x)) > 1.0f)
		{
			for (int k = 0; k < 3; ++k)
			{
				if (use_pick ? IsPick(window, rubik.cube[2][0][k].v[12], rubik.cube[2][2][k].v[13], rubik.cube[2][2][k].v[14], rubik.cube[2][0][k].v[15]) :
					Click_Rect(rubik.position[2][0][k], rubik.position[2][3][k], rubik.position[2][3][k + 1], rubik.position[2][0][k + 1]))
				{
					rubik.XY = true;
					for (int i = 0; i < 3; ++i)
						for (int j = 0; j < 3; ++j)
							rubik.cube[i][j][k].rotating = true;
					return;
				}
			}
		}
		else
		{
			for (int j = 0; j < 3; ++j)
			{
				if (use_pick ? IsPick(window,rubik.cube[2][j][0].v[12], rubik.cube[2][j][0].v[13], rubik.cube[2][j][2].v[14], rubik.cube[2][j][2].v[15]) :
					Click_Rect(rubik.position[2][j][0], rubik.position[2][j + 1][0], rubik.position[2][j + 1][3], rubik.position[2][j][3]))
				{
					rubik.XZ = true;
					for (int i = 0; i < 3; ++i)
						for (int k = 0; k < 3; ++k)
							rubik.cube[i][j][k].rotating = true;
					return;
				}
			}
		}

		//若在魔方外拖动，旋转整个魔方
		if (Click_Rect(POINT{ 0,599 }, POINT{ 0,0 }, POINT{ 299,0 }, POINT{ 299,599 }))
		{
			if (fabs((float)(mouse_pos.y - click_pos.y) / (float)(mouse_pos.x - click_pos.x)) < 1.0f)
				rubik.XZ = true;
			else
				rubik.YZ = true;
			for (int i = 0; i < 3; ++i)
				for (int j = 0; j < 3; ++j)
					for (int k = 0; k < 3; ++k)
						rubik.cube[i][j][k].rotating = true;
		}
		else if (Click_Rect(POINT{ 300, 599 }, POINT{ 300, 0 }, POINT{ 599, 0 }, POINT{ 599, 599 }))
		{
			if (fabs((float)(mouse_pos.y - click_pos.y) / (float)(mouse_pos.x - click_pos.x)) < 1.0f)
				rubik.XZ = true;
			else
				rubik.XY = true;
			for (int i = 0; i < 3; ++i)
				for (int j = 0; j < 3; ++j)
					for (int k = 0; k < 3; ++k)
						rubik.cube[i][j][k].rotating = true;
		}
	}
	//此时已经确定拖动方向，鼠标拖动产生旋转
	else
	{
		if (rubik.YZ)
		{
			rubik.degree += (int)(-(mouse_pos.y - prev_pos.y) / 2.0f);
			rubik.degree += (int)((mouse_pos.x - prev_pos.x) / 3.0f);
		}
		else if (rubik.XZ)
		{
			rubik.degree += (int)(-(mouse_pos.x - prev_pos.x) / 2.0f);
		}
		else if (rubik.XY)
		{
			rubik.degree += (int)(-(mouse_pos.y - prev_pos.y) / 2.0f);
			rubik.degree += (int)(-(mouse_pos.x - prev_pos.x) / 3.0f);
		}
	}
}

//点击区域，适用于任何凸四边形，需要按顺时针提供
bool Click_Rect(const POINT& LeftBottom, const POINT& LeftTop, const POINT& RightTop, const POINT& RightBottom)
{
	D3DXVECTOR3 vec1, vec2, cross;
	
	vec1 = D3DXVECTOR3((float)(mouse_pos.x - LeftBottom.x), (float)(mouse_pos.y - LeftBottom.y), 0.0f);
	vec2 = D3DXVECTOR3((float)(RightBottom.x - LeftBottom.x), (float)(RightBottom.y - LeftBottom.y), 0.0f);
	D3DXVec3Cross(&cross, &vec1, &vec2);
	if (cross.z < 0.0f)
		return false;

	vec1 = D3DXVECTOR3((float)(mouse_pos.x - LeftTop.x), (float)(mouse_pos.y - LeftTop.y), 0.0f);
	vec2 = D3DXVECTOR3((float)(LeftBottom.x - LeftTop.x), (float)(LeftBottom.y - LeftTop.y), 0.0f);
	D3DXVec3Cross(&cross, &vec1, &vec2);
	if (cross.z < 0.0f)
		return false;

	vec1 = D3DXVECTOR3((float)(mouse_pos.x - RightTop.x), (float)(mouse_pos.y - RightTop.y), 0.0f);
	vec2 = D3DXVECTOR3((float)(LeftTop.x - RightTop.x), (float)(LeftTop.y - RightTop.y), 0.0f);
	D3DXVec3Cross(&cross, &vec1, &vec2);
	if (cross.z < 0.0f)
		return false;

	vec1 = D3DXVECTOR3((float)(mouse_pos.x - RightBottom.x), (float)(mouse_pos.y - RightBottom.y), 0.0f);
	vec2 = D3DXVECTOR3((float)(RightTop.x - RightBottom.x), (float)(RightTop.y - RightBottom.y), 0.0f);
	D3DXVec3Cross(&cross, &vec1, &vec2);
	if (cross.z < 0.0f)
		return false;


	return true;
}

//鼠标拾取
bool IsPick(HWND window, const Vetrex& LeftBottom, const Vetrex& LeftTop, const Vetrex& RightTop, const Vetrex& RightBottom)
{
	//获取世界矩阵、取景变换矩阵、投影矩阵、视口
	D3DXMATRIX matrixWorld, matrixView, matrixProj;
	D3DVIEWPORT9 viewPort;
	d3ddev->GetTransform(D3DTS_WORLD, &matrixWorld);
	d3ddev->GetTransform(D3DTS_VIEW, &matrixView);
	d3ddev->GetTransform(D3DTS_PROJECTION, &matrixProj);
	d3ddev->GetViewport(&viewPort);


	/*	视口到投影变换，获取投影到鼠标位置的向量。
		实际的视口是指窗口内部不含边框的部分，因此实际宽度为584，高度为554，而不是默认的600 * 600
		窗口的上边框高度为38，下左右边框宽度均为8
		如果做成无边框，则需要删去被减掉的边框宽度值
	*/
	float px = (float)(((2.0f * (mouse_pos.x - 8)) / (viewPort.Width - 16)) - 1.0f) / matrixProj(0, 0);
	float py = (float)(((-2.0f * (mouse_pos.y - 38)) / (viewPort.Height - 46)) + 1.0f) / matrixProj(1, 1);
	D3DXVECTOR3 direction(px, py, 1.0f);
	D3DXVECTOR3 start_pos(0.0f, 0.0f, 0.0f);	//必须设为全0.0f
	
	D3DXMatrixInverse(&matrixView, 0, &matrixView);
	//获得摄影机坐标
	D3DXVec3TransformCoord(&start_pos, &start_pos, &matrixView);
	//标准化法向量
	D3DXVec3TransformNormal(&direction, &direction, &matrixView);
	D3DXVec3Normalize(&direction, &direction);

	float u, v, dist;
	bool r1 = D3DXIntersectTri(&LeftBottom.pos, &LeftTop.pos, &RightTop.pos, &start_pos, &direction, &u, &v, &dist);
	bool r2 = D3DXIntersectTri(&RightTop.pos, &RightBottom.pos, &LeftBottom.pos, &start_pos, &direction, &u, &v, &dist);
	return r1 || r2;
}

//带精度浮点数转换
_STD_BEGIN
std::string to_string(float _Val, int precision)
{
	std::string str;
	str += "%." + std::to_string(precision) + "f";
	return (std::_Floating_to_string(str.c_str(), _Val));
	//使用微软VS内置函数
}
_STD_END


```

`Direct3D9-Source/Rubik.cpp`:

```cpp
#include "Rubik.h"


//魔方
Rubik rubik;


//重置魔方
void Rubik::reset()
{
	//初始化顶点的坐标、法向量和纹理坐标，方块所有面颜色先全涂黑
	for (int i = 0; i < 3; ++i)
	{
		for (int j = 0; j < 3; ++j)
		{
			for (int k = 0; k < 3; ++k)
			{
				//顶面
				cube[i][j][k].v[0] = Vetrex(-3.0f + 2.0f * i, -1.0f + 2.0f * j, -3.0f + 2.0f * k, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f);
				cube[i][j][k].v[1] = Vetrex(-3.0f + 2.0f * i, -1.0f + 2.0f * j, -1.0f + 2.0f * k, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f);
				cube[i][j][k].v[2] = Vetrex(-1.0f + 2.0f * i, -1.0f + 2.0f * j, -1.0f + 2.0f * k, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f);
				cube[i][j][k].v[3] = Vetrex(-1.0f + 2.0f * i, -1.0f + 2.0f * j, -3.0f + 2.0f * k, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f);
				cube[i][j][k].top = black;

				//底面
				cube[i][j][k].v[4] = Vetrex(-1.0f + 2.0f * i, -3.0f + 2.0f * j, -3.0f + 2.0f * k, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f);
				cube[i][j][k].v[5] = Vetrex(-1.0f + 2.0f * i, -3.0f + 2.0f * j, -1.0f + 2.0f * k, 0.0f, -1.0f, 0.0f, 0.0f, 0.0f);
				cube[i][j][k].v[6] = Vetrex(-3.0f + 2.0f * i, -3.0f + 2.0f * j, -1.0f + 2.0f * k, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f);
				cube[i][j][k].v[7] = Vetrex(-3.0f + 2.0f * i, -3.0f + 2.0f * j, -3.0f + 2.0f * k, 0.0f, -1.0f, 0.0f, 1.0f, 1.0f);
				cube[i][j][k].bottom = black;

				//左面
				cube[i][j][k].v[8] = Vetrex(-3.0f + 2.0f * i, -3.0f + 2.0f * j, -1.0f + 2.0f * k, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f);
				cube[i][j][k].v[9] = Vetrex(-3.0f + 2.0f * i, -1.0f + 2.0f * j, -1.0f + 2.0f * k, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f);
				cube[i][j][k].v[10] = Vetrex(-3.0f + 2.0f * i, -1.0f + 2.0f * j, -3.0f + 2.0f * k, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f);
				cube[i][j][k].v[11] = Vetrex(-3.0f + 2.0f * i, -3.0f + 2.0f * j, -3.0f + 2.0f * k, -1.0f, 0.0f, 0.0f, 1.0f, 1.0f);
				cube[i][j][k].left = black;

				//右面
				cube[i][j][k].v[12] = Vetrex(-1.0f + 2.0f * i, -3.0f + 2.0f * j, -3.0f + 2.0f * k, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f);
				cube[i][j][k].v[13] = Vetrex(-1.0f + 2.0f * i, -1.0f + 2.0f * j, -3.0f + 2.0f * k, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f);
				cube[i][j][k].v[14] = Vetrex(-1.0f + 2.0f * i, -1.0f + 2.0f * j, -1.0f + 2.0f * k, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f);
				cube[i][j][k].v[15] = Vetrex(-1.0f + 2.0f * i, -3.0f + 2.0f * j, -1.0f + 2.0f * k, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f);
				cube[i][j][k].right = black;

				//正面
				cube[i][j][k].v[16] = Vetrex(-3.0f + 2.0f * i, -3.0f + 2.0f * j, -3.0f + 2.0f * k, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f);
				cube[i][j][k].v[17] = Vetrex(-3.0f + 2.0f * i, -1.0f + 2.0f * j, -3.0f + 2.0f * k, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f);
				cube[i][j][k].v[18] = Vetrex(-1.0f + 2.0f * i, -1.0f + 2.0f * j, -3.0f + 2.0f * k, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f);
				cube[i][j][k].v[19] = Vetrex(-1.0f + 2.0f * i, -3.0f + 2.0f * j, -3.0f + 2.0f * k, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f);
				cube[i][j][k].front = black;

				//背面
				cube[i][j][k].v[20] = Vetrex(-1.0f + 2.0f * i, -3.0f + 2.0f * j, -1.0f + 2.0f * k, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f);
				cube[i][j][k].v[21] = Vetrex(-1.0f + 2.0f * i, -1.0f + 2.0f * j, -1.0f + 2.0f * k, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f);
				cube[i][j][k].v[22] = Vetrex(-3.0f + 2.0f * i, -1.0f + 2.0f * j, -1.0f + 2.0f * k, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f);
				cube[i][j][k].v[23] = Vetrex(-3.0f + 2.0f * i, -3.0f + 2.0f * j, -1.0f + 2.0f * k, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);
				cube[i][j][k].rear = black;

				//一开始是没旋转的状态
				cube[i][j][k].rotating = false;
			}
		}
	}
	//初始化面颜色
	for (int i = 0; i < 3; ++i)
		for (int k = 0; k < 3; ++k)
		{
			cube[i][2][k].top = green;
			cube[i][0][k].bottom = blue;
		}

	for (int j = 0; j < 3; ++j)
		for (int k = 0; k < 3; ++k)
		{
			cube[0][j][k].left = red;
			cube[2][j][k].right = orange;
		}

	for (int i = 0; i < 3; ++i)
		for (int j = 0; j < 3; ++j)
		{
			cube[i][j][0].front = white;
			cube[i][j][2].rear = yellow;
		}

	shuffle_times = 30;
	degree = 0;
	start_time = 0;
	key_down_counter = 0;
	XY = YZ = XZ = false;
	complete = false;
	
	while (func_stk.size() > 0)
		func_stk.pop();
}

//更新魔方
void Rubik::update()
{
	//发生鼠标左键点击事件时不要转动魔方
	if (Mouse_Click(0) && (XY || XZ || YZ) && !shuffle_times)
		return;
	else if (degree >= 5)
		degree -= 5;
	else if (degree <= -5)
		degree += 5;
	else if (degree)
		degree = 0;
	else if (!degree && (XY || XZ || YZ))
	{
		XY = XZ = YZ = false;
		for (int i = 0; i < 3; ++i)
			for (int j = 0; j < 3; ++j)
				for (int k = 0; k < 3; ++k)
					cube[i][j][k].rotating = false;
	}

	//开局随机打乱
	if (!degree && shuffle_times && !key_down_counter)
	{
		int func = rand() % 15;
		int index = rand() % 3;
		bool inverse = rand() % 2;
		if (func < 4)
			rotate_YZ(index, inverse);
		else if (func < 8)
			rotate_XZ(index, inverse);
		else if (func < 12)
			rotate_XY(index, inverse);
		else if (func < 13)
			view_rotate_X(inverse);
		else if (func < 14)
			view_rotate_Y(inverse);
		else
			view_rotate_Z(inverse);
		shuffle_times--;
		key_down_counter = 20;
	}
}

//显示魔方
void Rubik::show()
{
	D3DXVECTOR4 vec4;
	D3DXVECTOR3 vec3;
	D3DXMATRIX matrix;

	//显示游戏时间
	std::string str = std::string("用时：");
	if (!start_time)
		str += "0.000s";
	else if (!complete)
		str += std::to_string((timeGetTime() - start_time) / 1000.0f, 3) + "s";
	else
		str += std::to_string((finish_time - start_time) / 1000.0f, 3) + "s";
	font->DrawTextA(nullptr, str.c_str(), str.size(), &font_rect, DT_LEFT, D3DCOLOR_XRGB(255, 255, 255));



	//根据旋转的面来取用对应的旋转矩阵
	if (rubik.XY)
		D3DXMatrixRotationZ(&matrix, D3DX_PI * rubik.degree / 180);
	else if (rubik.YZ)
		D3DXMatrixRotationX(&matrix, D3DX_PI * rubik.degree / 180);
	else if (rubik.XZ)
		D3DXMatrixRotationY(&matrix, D3DX_PI * rubik.degree / 180);

	//顶点缓冲区部分
	int pos = 0;
	Vetrex* vetrices;
	vb->Lock(0, 0, (void**)&vetrices, 0);
	
	for (int i = 0; i < 3; ++i)
		for (int j = 0; j < 3; ++j)
			for (int k = 0; k < 3; ++k)
				for (int l = 0; l < 24; ++l)
				{
					//该方块有旋转的话，顶点做旋转处理
					if (rubik.cube[i][j][k].rotating)
					{	
						D3DXVec3Transform(&vec4, &rubik.cube[i][j][k].v[l].pos, &matrix);
						vec3.x = vec4.x; vec3.y = vec4.y; vec3.z = vec4.z;
						vetrices[pos] = rubik.cube[i][j][k].v[l];
						vetrices[pos++].pos = vec3;
					}
					else
						vetrices[pos++] = rubik.cube[i][j][k].v[l];
				}
	vb->Unlock();	

	//显示部分
	d3ddev->SetStreamSource(0, vb, 0, sizeof(Vetrex));
	d3ddev->SetFVF(D3DFVF_MYVETREX);
	d3ddev->SetIndices(ib);
	
	for (int i = 0; i < 3; ++i)
		for (int j = 0; j < 3; ++j)
			for (int k = 0; k < 3; ++k)
			{
				d3ddev->SetTexture(0, rubik.cube[i][j][k].top);
				d3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, (i * 3 * 3 + j * 3 + k) * 24, 4, (i * 3 * 3 + j * 3 + k) * 36, 2);

				d3ddev->SetTexture(0, rubik.cube[i][j][k].bottom);
				d3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, (i * 3 * 3 + j * 3 + k) * 24 + 4, 4, (i * 3 * 3 + j * 3 + k) * 36 + 6, 2);

				d3ddev->SetTexture(0, rubik.cube[i][j][k].left);
				d3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, (i * 3 * 3 + j * 3 + k) * 24 + 8, 4, (i * 3 * 3 + j * 3 + k) * 36 + 12, 2);

				d3ddev->SetTexture(0, rubik.cube[i][j][k].right);
				d3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, (i * 3 * 3 + j * 3 + k) * 24 + 12, 4, (i * 3 * 3 + j * 3 + k) * 36 + 18, 2);

				d3ddev->SetTexture(0, rubik.cube[i][j][k].front);
				d3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, (i * 3 * 3 + j * 3 + k) * 24 + 16, 4, (i * 3 * 3 + j * 3 + k) * 36 + 24, 2);

				d3ddev->SetTexture(0, rubik.cube[i][j][k].rear);
				d3ddev->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, (i * 3 * 3 + j * 3 + k) * 24 + 20, 4, (i * 3 * 3 + j * 3 + k) * 36 + 30, 2);
			}
}

//检测魔方是否完成，如果完成，输出完成用时的窗体
void Rubik::check_complete(HWND window)
{
	if (complete)
		return;
	if (degree)		//魔方得停止转动后才能检测
		return;

	LPDIRECT3DTEXTURE9 color1 = cube[0][2][0].top;
	LPDIRECT3DTEXTURE9 color2 = cube[0][0][0].bottom;
	//顶面底面检测
	for (int i = 0; i < 3; ++i)
		for (int k = 0; k < 3; ++k)
			if (cube[i][2][k].top != color1 || cube[i][0][k].bottom != color2)
				return;
	
	//左面右面检测
	color1 = cube[0][0][0].left;
	color2 = cube[2][0][0].right;
	for (int j = 0; j < 3; ++j)
		for (int k = 0; k < 3; ++k)
			if (cube[0][j][k].left != color1 || cube[2][j][k].right != color2)
				return;

	//正面背面检测
	color1 = cube[0][0][0].front;
	color2 = cube[0][0][2].rear;
	for (int i = 0; i < 3; ++i)
		for (int j = 0; j < 3; ++j)
			if (cube[i][j][0].front != color1 || cube[i][j][2].rear != color2)
				return;
	//记录完成时间
	finish_time = timeGetTime();
	//保存成绩
	float seconds[6]{ 9999.999f, 9999.999f, 9999.999f, 9999.999f, 9999.999f, 9999.999f };
	std::ifstream fin("user.dat", std::ios::binary);
	if (fin.is_open())
	{
		for (int i = 0; i < 5; ++i)
			fin.read(reinterpret_cast<char*>(&seconds[i]), sizeof(float));
		fin.close();
	}
	seconds[5] = (finish_time - start_time) / 1e3f;
	std::sort(seconds, seconds + 6);
	std::ofstream fout("user.dat", std::ios::binary);
	for (int i = 0; i < 5; ++i)
		fout.write(reinterpret_cast<char*>(&seconds[i]), sizeof(float));
	fout.close();
	MessageBox(window, (std::string("用时：") + std::to_string((float)(finish_time - start_time) / 1e3f, 3) + "s\n游戏界面按F11可重置").c_str(),
		"恭喜完成", MB_OK);
	

	complete = true;
}

//YZ面旋转，index为0时转动左面，1转动中间，2转动右面
void Rubik::rotate_YZ(int index, bool inverse)
{
	for (int i = inverse ? 7 : 0; inverse ? (i >= 2) : (i < 6); inverse ? --i : ++i)
	{
		std::swap(rubik.cube[index][(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))].front,
			rubik.cube[index][(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))].bottom);
		std::swap(rubik.cube[index][(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))].top,
			rubik.cube[index][(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))].front);
		std::swap(rubik.cube[index][(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))].rear,
			rubik.cube[index][(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))].top);
		std::swap(rubik.cube[index][(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))].bottom,
			rubik.cube[index][(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))].rear);

		std::swap(rubik.cube[index][(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))].left,
			rubik.cube[index][(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))].left);
		std::swap(rubik.cube[index][(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))].right,
			rubik.cube[index][(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))].right);
	}
	
	rubik.degree = inverse ? 90 : -90;
	rubik.YZ = true;
	for (int j = 0; j < 3; ++j)
		for (int k = 0; k < 3; ++k)
			rubik.cube[index][j][k].rotating = true;

}

//XZ面旋转，index为0时转动底面，1转动中间，2转动顶面
void Rubik::rotate_XZ(int index, bool inverse)
{
	for (int i = inverse ? 0 : 7; inverse ? (i < 6) : (i >= 2); inverse ? ++i : --i)
	{
		std::swap(rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][index][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))].front,
			rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][index][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))].left);
		std::swap(rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][index][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))].right,
			rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][index][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))].front);
		std::swap(rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][index][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))].rear,
			rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][index][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))].right);
		std::swap(rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][index][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))].left,
			rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][index][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))].rear);

		std::swap(rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][index][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))].top,
			rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][index][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))].top);
		std::swap(rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][index][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))].bottom,
			rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][index][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))].bottom);
	}

	rubik.degree = inverse ? 90 : -90;
	rubik.XZ = true;
	for (int i = 0; i < 3; ++i)
		for (int k = 0; k < 3; ++k)
			rubik.cube[i][index][k].rotating = true;
}

//YZ面旋转，index为0时转动正面，1转动中间，2转动背面
void Rubik::rotate_XY(int index, bool inverse)
{
	for (int i = inverse ? 0 : 7; inverse ? (i < 6) : (i >= 2); inverse ? ++i : --i)
	{
		std::swap(rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))][index].right,
			rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))][index].bottom);
		std::swap(rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))][index].bottom,
			rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))][index].left);
		std::swap(rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))][index].left,
			rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))][index].top);
		std::swap(rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))][index].top,
			rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))][index].right);

		std::swap(rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))][index].front,
			rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))][index].front);
		std::swap(rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * i))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * i))][index].rear,
			rubik.cube[(int)(1 + 1.5 * MySin(D3DX_PI / 4 * (2 + i)))][(int)(1 + 1.5 * MyCos(D3DX_PI / 4 * (2 + i)))][index].rear);
	}

	rubik.degree = inverse ? -90 : 90;
	rubik.XY = true;
	for (int i = 0; i < 3; ++i)
		for (int j = 0; j < 3; ++j)
			rubik.cube[i][j][index].rotating = true;
}

//绕X轴旋转
void Rubik::view_rotate_X(bool inverse)
{
	for (int i = 0; i < 3; ++i)
		rotate_YZ(i, inverse);
}

//绕Y轴旋转
void Rubik::view_rotate_Y(bool inverse)
{
	for (int i = 0; i < 3; ++i)
		rotate_XZ(i, inverse);
}

//绕Z轴旋转
void Rubik::view_rotate_Z(bool inverse)
{
	for (int i = 0; i < 3; ++i)
		rotate_XY(i, inverse);
}

//初始化静态描点模式下的魔方顶点在屏幕上的坐标
Rubik::Rubik()
{
	//顶面顶点
	position[0][0][0] = POINT{ 106,206 }; position[0][0][1] = POINT{ 154,232 };
	position[0][0][2] = POINT{ 214,266 }; position[0][0][3] = POINT{ 300,312 };

	position[0][1][0] = POINT{ 188,188 }; position[0][1][1] = POINT{ 234,206 };
	position[0][1][2] = POINT{ 300,232 }; position[0][1][3] = POINT{ 386,266 };

	position[0][2][0] = POINT{ 256,172 }; position[0][2][1] = POINT{ 300,188 };
	position[0][2][2] = POINT{ 366,206 }; position[0][2][3] = POINT{ 446,232 };

	position[0][3][0] = POINT{ 300,160 }; position[0][3][1] = POINT{ 344,172 };
	position[0][3][2] = POINT{ 412,188 }; position[0][3][3] = POINT{ 494,206 };


	//正面顶点
	position[1][0][0] = POINT{ 160,390 }; position[1][0][1] = POINT{ 196,424 };
	position[1][0][2] = POINT{ 242,468 }; position[1][0][3] = POINT{ 300,526 };

	position[1][1][0] = POINT{ 150,348 }; position[1][1][1] = POINT{ 184,376 };
	position[1][1][2] = POINT{ 234,420 }; position[1][1][3] = POINT{ 300,476 };

	position[1][2][0] = POINT{ 130,286 }; position[1][2][1] = POINT{ 168,312 };
	position[1][2][2] = POINT{ 222,352 }; position[1][2][3] = POINT{ 300,406 };

	position[1][3][0] = POINT{ 106,206 }; position[1][3][1] = POINT{ 154,232 };
	position[1][3][2] = POINT{ 214,266 }; position[1][3][3] = POINT{ 300,312 };

	//右面顶点
	position[2][0][0] = POINT{ 300,526 }; position[2][0][1] = POINT{ 358,468 };
	position[2][0][2] = POINT{ 404,424 }; position[2][0][3] = POINT{ 440,390 };

	position[2][1][0] = POINT{ 300,476 }; position[2][1][1] = POINT{ 366,420 };
	position[2][1][2] = POINT{ 416,376 }; position[2][1][3] = POINT{ 450,348 };

	position[2][2][0] = POINT{ 300,406 }; position[2][2][1] = POINT{ 378,352 };
	position[2][2][2] = POINT{ 432,312 }; position[2][2][3] = POINT{ 470,286 };

	position[2][3][0] = POINT{ 300,312 }; position[2][3][1] = POINT{ 386,266 };
	position[2][3][2] = POINT{ 446,232 }; position[2][3][3] = POINT{ 494,206 };
}


```

`Direct3D9-Source/Rubik.h`:

```h
#pragma once
#include "DirectX.h"

//魔方的一块小立方体
struct Cube
{
	Vetrex v[24];	//0-3顶面，4-7底面，8-11左面，12-15右面，16-19正面，20-23背面
	LPDIRECT3DTEXTURE9 top, bottom, left, right, front, rear;	//六个面的纹理
	bool rotating;	//该立方体是否在旋转
};

//魔方
struct Rubik
{
	Cube cube[3][3][3];

	POINT position[3][4][4];	//0为顶面 1为左面 2为右面
	int degree;			//旋转的角度
	int shuffle_times;	//初始化时打乱次数
	bool YZ, XZ, XY;	//旋转的面类型
	bool complete;		//魔方是否完成

	void reset();			//重置
	void update();			//更新
	void show();			//显示
	void check_complete(HWND window);		//检测是否完成

	void rotate_YZ(int index, bool inverse);	//YZ面旋转，index为0时转动左面，1转动中间，2转动右面
	void rotate_XZ(int index, bool inverse);	//XZ面旋转，index为0时转动底面，1转动中间，2转动顶面
	void rotate_XY(int index, bool inverse);	//YZ面旋转，index为0时转动正面，1转动中间，2转动背面

	
	void view_rotate_X(bool inverse);			//绕X轴旋转
	void view_rotate_Y(bool inverse);			//绕Y轴旋转
	void view_rotate_Z(bool inverse);			//绕Z轴旋转

	Rubik();	//设置视口顶点坐标

};




```

`Direct3D9-Source/WinMain.cpp`:

```cpp
#include "DirectX.h"
using namespace std;

string APPTITLE = "魔方";
bool gameover = false;


LRESULT WINAPI WinProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg)
	{
	case WM_DESTROY:
		gameover = true;
		PostQuitMessage(0);
		return 0;
	}
	return DefWindowProc(hWnd, msg, wParam, lParam);
}


int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
	srand((unsigned)time(0));
	//初始化窗口设定
	WNDCLASSEX wc;
	wc.cbSize = sizeof(WNDCLASSEX);
	wc.style = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc = (WNDPROC)WinProc;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	wc.hInstance = hInstance;
	wc.hIcon = nullptr;
	wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
	wc.lpszMenuName = nullptr;
	wc.lpszClassName = APPTITLE.c_str();
	wc.hIconSm = nullptr;
	RegisterClassEx(&wc);

	//新建窗口句柄，固定窗口大小方便鼠标定位
	HWND window = CreateWindow(APPTITLE.c_str(), APPTITLE.c_str(),
		WS_OVERLAPPED | WS_SYSMENU, 600, 200,
		SCREENW, SCREENH, nullptr, nullptr, hInstance, nullptr);
	if (window == nullptr) return 0;

	//显示窗口
	ShowWindow(window, nCmdShow);
	UpdateWindow(window);

	//Direct3D初始化
	if (!Game_Init(window))
	{
		MessageBox(nullptr, "Initializing Direct3D Failed.", "Error", MB_OK | MB_ICONEXCLAMATION);
		gameover = true;
	}

	//信息处理循环
	MSG message;
	while (!gameover)
	{
		Game_Run(window);
		if (PeekMessage(&message, nullptr, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&message);
			DispatchMessage(&message);
		}

	}

	//释放Direct3D相关
	Game_End();

	return message.wParam;
}

```

`Direct3D9-Source/魔方.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.26403.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "魔方", "魔方.vcxproj", "{0B9C36C4-49B5-439B-A682-46C5E6042466}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0B9C36C4-49B5-439B-A682-46C5E6042466}.Debug|x64.ActiveCfg = Debug|x64
		{0B9C36C4-49B5-439B-A682-46C5E6042466}.Debug|x64.Build.0 = Debug|x64
		{0B9C36C4-49B5-439B-A682-46C5E6042466}.Debug|x86.ActiveCfg = Debug|Win32
		{0B9C36C4-49B5-439B-A682-46C5E6042466}.Debug|x86.Build.0 = Debug|Win32
		{0B9C36C4-49B5-439B-A682-46C5E6042466}.Release|x64.ActiveCfg = Release|x64
		{0B9C36C4-49B5-439B-A682-46C5E6042466}.Release|x64.Build.0 = Release|x64
		{0B9C36C4-49B5-439B-A682-46C5E6042466}.Release|x86.ActiveCfg = Release|Win32
		{0B9C36C4-49B5-439B-A682-46C5E6042466}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D81F0103-0F65-4D12-9E0D-7F7055D89D22}
	EndGlobalSection
	GlobalSection(Performance) = preSolution
		HasPerformanceSessions = true
	EndGlobalSection
EndGlobal

```

`Direct3D9-Source/魔方.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DirectX.cpp" />
    <ClCompile Include="MyGame.cpp" />
    <ClCompile Include="Rubik.cpp" />
    <ClCompile Include="WinMain.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DirectX.h" />
    <ClInclude Include="Rubik.h" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="C:\Users\Administrator\Desktop\Resource\Black.png" />
    <Image Include="C:\Users\Administrator\Desktop\Resource\Blue.png" />
    <Image Include="C:\Users\Administrator\Desktop\Resource\Green.png" />
    <Image Include="C:\Users\Administrator\Desktop\Resource\Orange.png" />
    <Image Include="C:\Users\Administrator\Desktop\Resource\Red.png" />
    <Image Include="C:\Users\Administrator\Desktop\Resource\White.png" />
    <Image Include="C:\Users\Administrator\Desktop\Resource\Yellow.png" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{0B9C36C4-49B5-439B-A682-46C5E6042466}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>魔方</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <LibraryPath>$(DXSDK_DIR)Lib\x86;$(LibraryPath)</LibraryPath>
    <IncludePath>$(DXSDK_DIR)Include;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(DXSDK_DIR)Include\</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <AdditionalLibraryDirectories>$(DXSDK_DIR)Lib\x86\</AdditionalLibraryDirectories>
      <AdditionalDependencies>winmm.lib;d3dx9d.lib;d3d9.lib;dinput8.lib;user32.lib;gdi32.lib;dxguid.lib;kernel32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(DXSDK_DIR)Include\</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <AdditionalLibraryDirectories>$(DXSDK_DIR)Lib\x64\</AdditionalLibraryDirectories>
      <AdditionalDependencies>winmm.lib;d3dx9d.lib;d3d9.lib;dinput8.lib;user32.lib;gdi32.lib;dxguid.lib;kernel32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(DXSDK_DIR)Include\</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>$(DXSDK_DIR)Lib\x86\</AdditionalLibraryDirectories>
      <AdditionalDependencies>winmm.lib;d3dx9.lib;d3d9.lib;dinput8.lib;user32.lib;dxguid.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(DXSDK_DIR)Include\</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>$(DXSDK_DIR)Lib\x64\</AdditionalLibraryDirectories>
      <AdditionalDependencies>winmm.lib;d3dx9.lib;d3d9.lib;dinput8.lib;user32.lib;dxguid.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Direct3D9-Source/魔方.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="WinMain.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="DirectX.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="MyGame.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="Rubik.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DirectX.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Rubik.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Image Include="C:\Users\Administrator\Desktop\Resource\Black.png">
      <Filter>资源文件</Filter>
    </Image>
    <Image Include="C:\Users\Administrator\Desktop\Resource\Blue.png">
      <Filter>资源文件</Filter>
    </Image>
    <Image Include="C:\Users\Administrator\Desktop\Resource\Green.png">
      <Filter>资源文件</Filter>
    </Image>
    <Image Include="C:\Users\Administrator\Desktop\Resource\Orange.png">
      <Filter>资源文件</Filter>
    </Image>
    <Image Include="C:\Users\Administrator\Desktop\Resource\Red.png">
      <Filter>资源文件</Filter>
    </Image>
    <Image Include="C:\Users\Administrator\Desktop\Resource\White.png">
      <Filter>资源文件</Filter>
    </Image>
    <Image Include="C:\Users\Administrator\Desktop\Resource\Yellow.png">
      <Filter>资源文件</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`README.md`:

```md
# DirectX实现的3D魔方游戏

![](https://github.com/MKXJun/Rubik-Cube/blob/master/replay.gif)

**教程链接：[DirectX11--实现一个3D魔方](https://www.cnblogs.com/X-Jun/p/10230580.html)**

**[JavaScript(WebGL)版在线游玩，无教程](https://mkxjun.github.io/Rubik-Cube/)**

## Direct3D 11.x实现版本 V1.1

语言：C++11/14</br>
开发环境：Visual Studio 2017</br>
依赖项：无</br>
配置支持：Debug/Release支持</br>
平台支持：x86/x64</br>
最低Windows SDK版本要求：8.1</br>
最低Visual Studio版本要求：2015</br>
最低系统要求：Windows 7

**提醒：**</br>
-不支持Direct3D 11.1的系统将无法看到文本输出，但不影响游戏体验。</br>
-现在即便是移除Resource文件夹，程序也会自己生成一样的纹理。

## Direct3D 9实现版本 V1.0

**注意：由于本人的Win10系统已经无法打开DirectX 9的游戏，故不再维护**

语言：C++11</br>
开发环境：Visual Studio 2017</br>
依赖项：DirectX SDK</br>
配置支持: Debug/Release支持</br>
平台支持: x86/x64</br>
最低Windows SDK版本要求：8.1</br>
最低Visual Studio版本要求：2015</br>
最低系统要求：Windows 7

## 使用说明

打开魔方.exe，魔方开局将会自动打乱。

打乱结束后，玩家可以用键盘或者鼠标进行操作。当魔方发生实质性转动时，计时器将开始计时。当完成魔方后，游戏会弹出窗口告诉你完成用时。

如果你使用了一键还原，将不计入成绩。

## 键鼠操作说明

以下为键位操作(两个版本都不一定完全支持)

|键位    |对应公式|描述|键位   |对应公式|描述|
|--------|----|------------------------|--------|----|------------------------|
| Up     | x  | 整个魔方按x轴顺时针旋转|I       | R  | 右面两层按x轴顺时针旋转|
| Down   | x' | 整个魔方按x轴逆时针旋转|K       | R' | 右面两层按x轴逆时针旋转|
| Left   | y  | 整个魔方按y轴顺时针旋转|J       | U  | 顶面两层按y轴顺时针旋转|
| Right  | y' | 整个魔方按y轴逆时针旋转|L       | U' | 顶面两层按y轴逆时针旋转|
| Pg Up  | z' | 整个魔方按z轴逆时针旋转|U       | F' | 正面两层按z轴逆时针旋转|
| Pg Down| z  | 整个魔方按z轴顺时针旋转|O       | F  | 正面两层按z轴顺时针旋转|
|--------|----|------------------------|--------|----|------------------------|
|LCtrl+I | r  | 右面两层按x轴顺时针旋转|T       | M  | 右面两层按x轴顺时针旋转|
|LCtrl+K | r' | 右面两层按x轴逆时针旋转|G       | M' | 右面两层按x轴逆时针旋转|
|LCtrl+J | u  | 顶面两层按y轴顺时针旋转|F       | E  | 顶面两层按y轴顺时针旋转|
|LCtrl+L | u' | 顶面两层按y轴逆时针旋转|H       | E' | 顶面两层按y轴逆时针旋转|
|LCtrl+U | f' | 正面两层按z轴逆时针旋转|R       | S' | 正面两层按z轴逆时针旋转|
|LCtrl+O | f  | 正面两层按z轴顺时针旋转|Y       | S  | 正面两层按z轴顺时针旋转|
|--------|----|------------------------|--------|----|------------------------|
|LCtrl+W | l' | 左面两层按x轴逆时针旋转|W       | L' | 右面两层按x轴顺时针旋转|
|LCtrl+S | l  | 左面两层按x轴顺时针旋转|S       | L  | 右面两层按x轴逆时针旋转|
|LCtrl+A | d' | 底面两层按y轴逆时针旋转|A       | D' | 顶面两层按y轴顺时针旋转|
|LCtrl+D | d  | 底面两层按y轴顺时针旋转|D       | D  | 顶面两层按y轴逆时针旋转|
|LCtrl+Q | b  | 背面两层按z轴顺时针旋转|Q       | B  | 正面两层按z轴逆时针旋转|
|LCtrl+E | b' | 背面两层按z轴逆时针旋转|E       | B' | 正面两层按z轴顺时针旋转|
|--------|----|------------------------|--------|----|------------------------|
|F9      |    | 拾取模式(仅DirectX 9)  |F10     |    | 一键还原               |
|F11     |    | 重置游戏               |F12     |    | 关于作者(排行榜仅DX9)  |
|LCtrl+Z |    | 撤销操作               |        |    |                        |


鼠标左键拖动魔方块旋转一层魔方</br>
鼠标左键拖动空白区域旋转整个魔方</br>























```

`Rubik-Cube-Direct3D9-Release/user.dat`:

```dat
-FBmç\BÃ¥Bÿ?Fÿ?F
```