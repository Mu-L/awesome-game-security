Project Path: arc_MKXJun_Super-Fighter_bpeskscw

Source Tree:

```txt
arc_MKXJun_Super-Fighter_bpeskscw
├── README.md
├── Source Code
│   ├── Data
│   │   ├── EnemyInfo.txt
│   │   ├── EnemyLevel1.txt
│   │   ├── EnemyLevel2.txt
│   │   ├── EnemyLevel3.txt
│   │   ├── EnemyLevel4.txt
│   │   ├── EnemyLevel5.txt
│   │   ├── EnemyLevel6.txt
│   │   ├── EnemyLevel7.txt
│   │   ├── HighScore.dat
│   │   ├── README.txt
│   │   ├── Stage1.txt
│   │   ├── Stage2.txt
│   │   ├── Stage3.txt
│   │   ├── Stage4.txt
│   │   ├── Stage5.txt
│   │   ├── Stage6.txt
│   │   └── Stage7.txt
│   ├── DirectSound.cpp
│   ├── DirectSound.h
│   ├── Effects11
│   │   ├── Binary
│   │   │   ├── EffectBinaryFormat.h
│   │   │   ├── EffectStateBase11.h
│   │   │   ├── EffectStates11.h
│   │   │   └── SOParser.h
│   │   ├── Effect.h
│   │   ├── EffectAPI.cpp
│   │   ├── EffectLoad.cpp
│   │   ├── EffectLoad.h
│   │   ├── EffectNonRuntime.cpp
│   │   ├── EffectReflection.cpp
│   │   ├── EffectRuntime.cpp
│   │   ├── EffectVariable.inl
│   │   ├── Effects11_2010.vcxproj
│   │   ├── Effects11_2010.vcxproj.filters
│   │   ├── Effects11_2010.vcxproj.user
│   │   ├── Inc
│   │   │   ├── d3dx11dbg.h
│   │   │   ├── d3dx11effect.h
│   │   │   └── d3dxGlobal.h
│   │   ├── d3dx11dbg.cpp
│   │   ├── d3dxGlobal.cpp
│   │   └── pchfx.h
│   ├── GameApp.cpp
│   ├── GameApp.h
│   ├── GameTimer.cpp
│   ├── GameTimer.h
│   ├── HLSL
│   │   ├── Basic.hlsl
│   │   └── Basic.hlsli
│   ├── MKInput.cpp
│   ├── MKInput.h
│   ├── Main.cpp
│   ├── MathHelper.cpp
│   ├── MathHelper.h
│   ├── PlaneManager.cpp
│   ├── PlaneManager.h
│   ├── Replay
│   │   └── 全通丢3命.dat
│   ├── Sound
│   │   ├── 1UP.WAV
│   │   ├── BLAST1.WAV
│   │   ├── BLAST2.WAV
│   │   ├── BLAST3.WAV
│   │   ├── BLAST4.WAV
│   │   ├── BOMBER1.WAV
│   │   ├── CHARGE.WAV
│   │   ├── CWS.WAV
│   │   ├── DAMAGE.WAV
│   │   ├── ITEM0.WAV
│   │   ├── ITEM1.WAV
│   │   ├── ITEM2.WAV
│   │   ├── KASURI.WAV
│   │   ├── LASER.WAV
│   │   ├── MYBLAST.WAV
│   │   ├── SELECT.WAV
│   │   ├── SHOT.WAV
│   │   ├── SHOT2.WAV
│   │   ├── START.WAV
│   │   ├── VULCAN.WAV
│   │   └── WARNING.WAV
│   ├── Sprite.cpp
│   ├── Sprite.h
│   ├── Texture
│   │   ├── background.png
│   │   ├── bomb.png
│   │   ├── boss1.png
│   │   ├── boss2.png
│   │   ├── boss3.png
│   │   ├── boss4.png
│   │   ├── bullet.png
│   │   ├── enemy_plane1.png
│   │   ├── enemy_plane10.png
│   │   ├── enemy_plane2.png
│   │   ├── enemy_plane3.png
│   │   ├── enemy_plane4.png
│   │   ├── enemy_plane5.png
│   │   ├── enemy_plane6.png
│   │   ├── enemy_plane7.png
│   │   ├── enemy_plane8.png
│   │   ├── enemy_plane9.png
│   │   ├── fire.png
│   │   ├── flame1.png
│   │   ├── flame2.png
│   │   ├── health.png
│   │   ├── laser.png
│   │   ├── playerBlue.png
│   │   ├── playerRed.png
│   │   ├── power.png
│   │   └── shield.png
│   ├── XUtility.cpp
│   ├── XUtility.h
│   ├── d2dText.cpp
│   ├── d2dText.h
│   ├── d3dApp.cpp
│   ├── d3dApp.h
│   ├── d3dUtil.cpp
│   ├── d3dUtil.h
│   ├── 超级战机.sln
│   ├── 超级战机.vcxproj
│   ├── 超级战机.vcxproj.filters
│   └── 超级战机.vcxproj.user
├── pic.png
└── 超级战机 V1.1 Rebuild.zip

```

`README.md`:

```md
# Super-Fighter<br>
超级战机 重制版 1.1<br>
作者：X_Jun<br>
本作品仅用于学习用途，不允许用于商业用途。<br>

**注意：编译该游戏需要使用DirectX SDK，务必确认你的电脑已经安装该SDK。**


【更新内容】<br>
重置版 V1.1         2018/1/8<br>
-添加XBox手柄支持<br>

重制版 V1.0         2017/9/30<br>
-初步完成最终关（第七关）<br>
-音频调整<br>    

重制版 Beta V0.9    2017/9/28<br>
-完成了第六关（困难第三关）<br>
-修复了WARNING不会被暂停及BLAST3音量不受调整的问题<br>
-调整了某些BOSS的行动逻辑<br>

重制版 Beta V0.8    2017/9/6<br>
-完成了第五关（困难第二关）<br>

重制版 Beta V0.7     2017/9/5<br>
-完成了第四关（困难第一关）<br>
-现在录像不会录制人工退出的部分了<br>

重制版 Beta V0.6     2017/8/31<br>
-增加了全屏(缺背景中，有好的背景可以推荐给我)<br>

重制版 Beta V0.5     2017/8/30<br>
-增加了录像回放功能，每局游戏默认都会产生录像，且存放在Replay文件夹中。<br>
 播放需要在游戏内选择录像回放并打开里面的文件。<br>

重制版 Beta V0.4     2017/8/29<br>
-完成了第三关的布局<br>
-文本编辑器更新<br>
-添加了新的敌机子弹，实装在第三关BOSS上<br>
-修复了玩家死亡后仍进行碰撞检测的问题<br>

重制版 Beta V0.3     2017/8/27<br>
-完成了第二关的布局<br>
-重新调整了敌机的参数，第一关的布局<br>
-修复了碰撞测试的bug<br>
-对音频播放改进，可以调节音量了<br>
-文本编辑器更新<br>


重制版 Beta V0.2     2017/8/18<br>
-增加了反制型追踪弹和倍率系统，并且对第一关飞机布局重新设置<br>
-提供了两种初始机型<br>
-完成了第一关的布局<br>
-增加了真实的本地排行榜<br>
-可以使用文本编辑器来自定义飞机数据和关卡布局<br>
////////////////////////////////////////////////////////////<br>
////////////////////////////////////////////////////////////<br>
原版 版本V0.50       2016/6/2<br>
-完成第三关制作<br>
-修正bug<br>
-添加非自动排行榜，要修改排行榜请拿通关截图分数给作者<br>
-删减选项<br>
-降低三个BOSS部分弹幕的密集程度<br>


原版 版本V0.30       2016/5/20<br>
-完成第二关制作<br>
-注意己方飞机会与敌机发生碰撞<br>
-受伤后无敌时间两秒并且清屏<br>
-修正一堆bug<br>


原版 版本V0.25       2016/5/17<br>
-将火力三发射角度扩大2度<br>
-未完工的第二关<br>
-现可以选择开始的关卡有 1、1BOSS和2<br>


原版 版本V0.14       2016/5/16<br>
-修复重新开始新游戏的一些bug<br>


原版 版本V0.13       2016/5/15<br>
-Boss1第4攻击阶段的弹幕密度调整宽松1度<br>
-更换背景<br>


原版 版本V0.10       2016/5/14<br>
-完成第一关制作<br>
-目前飞机只有散射型<br>

//////////////////////////////////////////////////////////<br>

【基本参数】<br>
分辨率：750x900<br>
运行环境：Windows 7以上，安装了DirectX11运行库且含有VS2017运行库<br>

【控制】<br>
鼠标点击选项（鼠标移动至选项时会变色）<br>
↑：上/XBox 左摇杆 或 十字按钮↑<br>
↓：下/XBox 左摇杆 或 十字按钮↓<br>
←：左/XBox 左摇杆 或 十字按钮←<br>
→：右/XBox 左摇杆 或 十字按钮→<br>
Z：攻击/XBox 按钮X<br>
X：大招/XBox 按钮A<br>
ESC：暂停<br>
F2：暂停后按返回主界面<br>
Enter：暂停后按继续游戏<br>

【机种选择】
你可以操控的机型有两种：散射型和集火型<br>
散射型               集火型<br>
火力：较强           火力：较弱<br>
射速：较慢           射速：较快<br>
机动性：较弱         机动性：较强<br>
最大倍率：12x        最大倍率：16x<br>
追踪弹容量：8        追踪弹容量：12<br>
大招：超密集弹幕     大招：疯狂追踪弹<br>



【护盾】<br>
当战机吃到'S'标记的道具时，如果当前没有护盾，则获得3个护盾。若当
前护盾没满，则获得1个护盾。若当前护盾已满(3个)，获得30000分。1个
护盾可以阻挡一次攻击，当受到伤害时，立即相除当前弹幕。

【大招】<br>
当战机吃到'B'标记的道具时，如果当前大招数未满，获得1个大招。若大
招已满(5个)，获得30000分。使用大招在三秒钟内无敌，并且这段时间内
清除敌方的所有弹幕。

【火力】<br>
一个战机有三个火力等级。默认情况下火力等级为1，当战机吃到'P'标记
的道具时，若火力等级未满，增加一个火力等级；否则获得30000分。火力
决定子弹的数目。

【反制型追踪弹】<br>
当敌人的子弹与你的飞机擦肩而过的时候，会自动触发反制型追踪弹。
它将会追踪屏幕早期出现的敌人。但注意不要过于依赖它，因为追踪弹
在短期是有限的，每5秒钟会补充满一次追踪弹。

【倍率系统】<br>
倍率系统可以让你普通子弹和反制型追踪弹击中敌人的时候，享受当前
倍率得分的加成。反制型追踪弹击中敌方飞机的时候，当前倍率加1，但
不能超过当前机种的最大倍率。每当连续3秒时间内没有反制型追踪弹击
中敌机，当前倍率会减半。当你使用大招的时候，以及死亡重生时，当
前倍率都会强制归为1。

【奖励】<br>
当战机在当前游戏内获得100W/200W/300W/500W/800W分时，系统会自动赠
送一条命给你。努力赚取分数来保证自己的存活时间吧！

【最终得分统计】<br>
在完成一关后，影响最终得分的因素有：当前剩余生命数、护盾数、炸弹
数、当前关卡内是否死亡，以及最终击败BOSS时的倍率。奖励分的计算公
式为：
总分 = 当前分 + ((生命数+护盾数+炸弹数)*1000 + 无死亡奖励10000) * 最终倍率 

【排行榜】<br>
当你完成所有关卡/当前硬币所有生命用光时，若分数超过排行榜最后一位，
你可以选择自己的昵称(3个字符)保存成绩。

【选择关卡】<br>
一个关卡分为普通模式和BOSS模式。在BOSS模式下，你将会直接来到当前关
卡的BOSS战，系统会送你一个'P'和一个'S'。

【游戏UI布局】<br>
![image](https://github.com/MKXJun/Super-Fighter/blob/master/pic.png)

左下角的信息若不想显示可以在设置界面中关掉调试信息。<br>


【游戏中暂停】<br>
在游戏时按Esc键可以暂停

【文本编辑器】<br>
更多文本编辑器的内容请到Data文件夹中打开README.txt查阅。

【录像回放】<br>
选择录像回放后，会弹出文件选择框。来到游戏根目录然后找到Replay文件夹，
选择你的一个录像后就会自动播放。若当前币的生命耗光，按回车续币后会继续
播放。当然也可以按Esc退出。
注意：游戏录像的播放可能会有误差。

【全屏】<br>
按ALT+回车可以全屏/窗口化，你也可以在设置中进行修改。




文档修订于 2017年9月30日<br>
By X_Jun<br>

```

`Source Code/Data/EnemyInfo.txt`:

```txt
enemy_plane1
typeID:     1
HP:         4
score:      640
penalty:    2
minscore:   200
velX:       0.0
velY:       10.0
posY:       -200.0
width:      100
height:     100
follow:     0
inside:     0
isRotating: 0
deathsnd:   BLAST1
texName:    enemy_plane1
////////////////////////////
enemy_plane2
typeID:     2
HP:         50
score:      5400
penalty:    10
minscore:   2500
velX:       0.0
velY:       5.0
posY:       -200.0
width:      162
height:     180
follow:     1
inside:     0
isRotating: 0
deathsnd:   BLAST3
texName:    enemy_plane2
////////////////////////////
enemy_plane3
typeID:     3
HP:         80
score:      10000
penalty:    20
minscore:   4000
velX:       0.0
velY:       4.0
posY:       -200.0
width:      190
height:     180
follow:     1
inside:     0
isRotating: 0
deathsnd:   BLAST3
texName:    enemy_plane3
////////////////////////////
enemy_plane4
typeID:     4
HP:         4
score:      640
penalty:    2
minscore:   200
velX:       0.0
velY:       7.5
posY:       -150.0
width:      50
height:     100
follow:     0
inside:     0
isRotating: 0
deathsnd:   BLAST1
texName:    enemy_plane4
////////////////////////////
enemy_plane5
typeID:     5
HP:         4
score:      640
penalty:    2
minscore:   200
velX:       0.0
velY:       10.0
posY:       -200.0
width:      100
height:     100
follow:     0
inside:     0
isRotating: 0
deathsnd:   BLAST1
texName:    enemy_plane5
////////////////////////////
enemy_plane6
typeID:     6
HP:         50
score:      5200
penalty:    10
minscore:   2500
velX:       0.0
velY:       6.0
posY:       -120.0
width:      140
height:     196
follow:     0
inside:     0
isRotating: 0
deathsnd:   BLAST3
texName:    enemy_plane6
////////////////////////////
enemy_plane7
typeID:     7
HP:         20
score:      2400
penalty:    10
minscore:   1000
velX:       2.0
velY:       5.0
posY:       -150.0
width:      112
height:     100
follow:     1
inside:     0
isRotating: 1
deathsnd:   BLAST2
texName:    enemy_plane7
////////////////////////////
enemy_plane8
typeID:     8
HP:         4
score:      640
penalty:    2
minscore:   200
velX:       0.0
velY:       8.0
posY:       -160.0
width:      75
height:     100
follow:     0
inside:     0
isRotating: 0
deathsnd:   BLAST1
texName:    enemy_plane8
////////////////////////////
enemy_plane9
typeID:     9
HP:         100
score:      10600
penalty:    20
minscore:   6000
velX:       0.0
velY:       10.0
posY:       -300.0
width:      225
height:     250
follow:     0
inside:     0
isRotating: 0
deathsnd:   BLAST3
texName:    enemy_plane9
////////////////////////////
enemy_plane9
typeID:     10
HP:         125
score:      13100
penalty:    20
minscore:   6000
velX:       0.5
velY:       1.5
posY:       -240.0
width:      240
height:     205
follow:     1
inside:     0
isRotating: 0
deathsnd:   BLAST3
texName:    enemy_plane10
////////////////////////////
enemy_plane9_1
typeID:     11
HP:         90
score:      10600
penalty:    20
minscore:   6000
velX:       0.0
velY:       10.0
posY:       -300.0
width:      225
height:     250
follow:     0
inside:     0
isRotating: 0
deathsnd:   BLAST3
texName:    enemy_plane9
////////////////////////////
boss1
typeID:     12
HP:         2500
score:      310000
penalty:    25
minscore:   150000
velX:       0.0
velY:       4.0
posY:       -400.0
width:      250
height:     300
follow:     0
inside:     1
isRotating: 0
deathsnd:   BLAST4
texName:    boss1
////////////////////////////
boss2
typeID:     13
HP:         3750
score:      460000
penalty:    30
minscore:   225000
velX:       0.0
velY:       4.0
posY:       -400.0
width:      500
height:     225
follow:     0
inside:     1
isRotating: 0
deathsnd:   BLAST4
texName:    boss2
////////////////////////////
boss3
typeID:     14
HP:         6250
score:      610000
penalty:    35
minscore:   300000
velX:       0.0
velY:       4.0
posY:       -400.0
width:      320
height:     272
follow:     0
inside:     1
isRotating: 0
deathsnd:   BLAST4
texName:    boss3
////////////////////////////
boss4
typeID:     15
HP:         3000
score:      1010000
penalty:    25
minscore:   500000
velX:       0.0
velY:       0.0
posY:       -400.0
width:      80
height:     100
follow:     0
inside:     1
isRotating: 0
deathsnd:   BLAST4
texName:    boss4
////////////////////////////
```

`Source Code/Data/EnemyLevel1.txt`:

```txt
typeID: 1   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
35   SetVelY           0.0
35   ShootToPlayer     50 95 4.0 0.0
125  SetVelY           10.0
125  ShootToPlayer     50 95 4.0 0.0
/////////////////////////
typeID: 2   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
70   SetVelY           0.0
70   SetVelX           2.0
76   ShootToPlayerRand 56  175 5.0 8.0 1
76   ShootToPlayerRand 105 175 5.0 8.0 1
82   ShootToPlayerRand 56  175 5.0 8.0 1
82   ShootToPlayerRand 105 175 5.0 8.0 1
88   ShootToPlayerRand 56  175 5.0 8.0 1
88   ShootToPlayerRand 105 175 5.0 8.0 1
94   ShootToPlayerRand 56  175 5.0 8.0 1
94   ShootToPlayerRand 105 175 5.0 8.0 1
100  ShootToPlayerRand 56  175 5.0 8.0 1
100  ShootToPlayerRand 105 175 5.0 8.0 1
106  ShootToPlayerRand 56  175 5.0 8.0 1
106  ShootToPlayerRand 105 175 5.0 8.0 1
112  ShootToPlayerRand 56  175 5.0 8.0 1
112  ShootToPlayerRand 105 175 5.0 8.0 1
118  ShootToPlayerRand 56  175 5.0 8.0 1
118  ShootToPlayerRand 105 175 5.0 8.0 1
124  ShootToPlayerRand 56  175 5.0 8.0 1
124  ShootToPlayerRand 105 175 5.0 8.0 1
130  ShootToPlayerRand 56  175 5.0 8.0 1
130  ShootToPlayerRand 105 175 5.0 8.0 1
130  SetVelX           0.0
130  SetVelY           -2.0             
/////////////////////////
typeID: 3   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
90   SetVelY           -2.0
98   ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
106  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
114  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
122  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
130  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
140  SetVelY           4.0
140  SetVelX           2.0
200  SetVelY           -2.0
200  SetVelX           0.0
208  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
216  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
224  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
232  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
240  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
240  SetVelY           4.0
/////////////////////////
typeID: 4   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
30   ShootToPlayer     25  80  5.0 0.0
42   ShootToPlayer     25  80  5.2 0.0
/////////////////////////
typeID: 8   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
70   SetVelY           -3.0
70   SetAwayVelX       -4.5
90   ShootLaser        37  100 12.0
150  ShootLaser        37  100 12.0
/////////////////////////
typeID: 12  cmdCount: 1
MainCmd
0    SetCmd            0
1620 SetFrame          125
=========================
125  SetVelY           0.0
125  SetVelX           3.0
130  ShootToPlayer     78  200 8.0 -45.0 -22.5 0.0 22.5 45.0
130  ShootToPlayer     172 200 8.0 -45.0 -22.5 0.0 22.5 45.0
170  ShootToPlayer     78  200 8.0 -45.0 -22.5 0.0 22.5 45.0
170  ShootToPlayer     172 200 8.0 -45.0 -22.5 0.0 22.5 45.0
210  ShootToPlayer     78  200 8.0 -45.0 -22.5 0.0 22.5 45.0
210  ShootToPlayer     172 200 8.0 -45.0 -22.5 0.0 22.5 45.0
250  ShootToPlayer     78  200 8.0 -45.0 -22.5 0.0 22.5 45.0
250  ShootToPlayer     172 200 8.0 -45.0 -22.5 0.0 22.5 45.0
290  ShootToPlayer     78  200 8.0 -45.0 -22.5 0.0 22.5 45.0
290  ShootToPlayer     172 200 8.0 -45.0 -22.5 0.0 22.5 45.0
330  ShootToPlayer     78  200 8.0 -45.0 -22.5 0.0 22.5 45.0
330  ShootToPlayer     172 200 8.0 -45.0 -22.5 0.0 22.5 45.0
370  ShootToPlayer     78  200 8.0 -45.0 -22.5 0.0 22.5 45.0
370  ShootToPlayer     172 200 8.0 -45.0 -22.5 0.0 22.5 45.0
410  ShootToPlayer     78  200 8.0 -45.0 -22.5 0.0 22.5 45.0
410  ShootToPlayer     172 200 8.0 -45.0 -22.5 0.0 22.5 45.0
450  ShootToPlayer     78  200 8.0 -45.0 -22.5 0.0 22.5 45.0
450  ShootToPlayer     172 200 8.0 -45.0 -22.5 0.0 22.5 45.0
490  ShootToPlayer     78  200 8.0 -45.0 -22.5 0.0 22.5 45.0
490  ShootToPlayer     172 200 8.0 -45.0 -22.5 0.0 22.5 45.0

550  SetVelX           0.0

550  ShootToPlayerRand 25  250 10.0 22.5 3
554  ShootToPlayerRand 25  250 10.0 22.5 3
558  ShootToPlayerRand 25  250 10.0 22.5 3
562  ShootToPlayerRand 25  250 10.0 22.5 3
566  ShootToPlayerRand 25  250 10.0 22.5 3
570  ShootToPlayerRand 25  250 10.0 22.5 3
574  ShootToPlayerRand 25  250 10.0 22.5 3
578  ShootToPlayerRand 25  250 10.0 22.5 3
582  ShootToPlayerRand 25  250 10.0 22.5 3
586  ShootToPlayerRand 25  250 10.0 22.5 3


640  ShootToPlayerRand 234 250 10.0 22.5 3
644  ShootToPlayerRand 234 250 10.0 22.5 3
648  ShootToPlayerRand 234 250 10.0 22.5 3
652  ShootToPlayerRand 234 250 10.0 22.5 3
656  ShootToPlayerRand 234 250 10.0 22.5 3
660  ShootToPlayerRand 234 250 10.0 22.5 3
664  ShootToPlayerRand 234 250 10.0 22.5 3
668  ShootToPlayerRand 234 250 10.0 22.5 3
672  ShootToPlayerRand 234 250 10.0 22.5 3
676  ShootToPlayerRand 234 250 10.0 22.5 3


730  ShootToPlayerRand 25  250 10.0 22.5 3
734  ShootToPlayerRand 25  250 10.0 22.5 3
738  ShootToPlayerRand 25  250 10.0 22.5 3
742  ShootToPlayerRand 25  250 10.0 22.5 3
746  ShootToPlayerRand 25  250 10.0 22.5 3
750  ShootToPlayerRand 25  250 10.0 22.5 3
754  ShootToPlayerRand 25  250 10.0 22.5 3
758  ShootToPlayerRand 25  250 10.0 22.5 3
762  ShootToPlayerRand 25  250 10.0 22.5 3
766  ShootToPlayerRand 25  250 10.0 22.5 3

820  ShootToPlayerRand 234 250 10.0 22.5 3
824  ShootToPlayerRand 234 250 10.0 22.5 3
828  ShootToPlayerRand 234 250 10.0 22.5 3
832  ShootToPlayerRand 234 250 10.0 22.5 3
836  ShootToPlayerRand 234 250 10.0 22.5 3
840  ShootToPlayerRand 234 250 10.0 22.5 3
844  ShootToPlayerRand 234 250 10.0 22.5 3
848  ShootToPlayerRand 234 250 10.0 22.5 3
852  ShootToPlayerRand 234 250 10.0 22.5 3
856  ShootToPlayerRand 234 250 10.0 22.5 3

920  SetAwayVelX       3.0        

930  ShootLaser        40  185 12.0
930  ShootLaser        210 185 12.0
970  ShootLaser        40  185 12.0
970  ShootLaser        210 185 12.0
1010 ShootLaser        40  185 12.0
1010 ShootLaser        210 185 12.0
1050 ShootLaser        40  185 12.0
1050 ShootLaser        210 185 12.0
1090 ShootLaser        40  185 12.0
1090 ShootLaser        210 185 12.0
1130 ShootLaser        40  185 12.0
1130 ShootLaser        210 185 12.0
1170 ShootLaser        40  185 12.0
1170 ShootLaser        210 185 12.0
1210 ShootLaser        40  185 12.0
1210 ShootLaser        210 185 12.0

1280 SetVelX           0.0

1300 Shoot             125 188 8.0 38.0 
1304 Shoot             125 188 8.0 38.0 45.0 
1308 Shoot             125 188 8.0 38.0 45.0 52.0 
1312 Shoot             125 188 8.0 45.0 52.0 59.0 
1316 Shoot             125 188 8.0 52.0 59.0 66.0 
1320 Shoot             125 188 8.0 59.0 66.0 73.0 
1324 Shoot             125 188 8.0 66.0 73.0 80.0 
1328 Shoot             125 188 8.0 73.0 80.0 87.0 
1332 Shoot             125 188 8.0 80.0 87.0 94.0 
1336 Shoot             125 188 8.0 87.0 94.0 101.0 
1340 Shoot             125 188 8.0 94.0 101.0 108.0 
1344 Shoot             125 188 8.0 101.0 108.0 115.0 
1348 Shoot             125 188 8.0 108.0 115.0 122.0 
1352 Shoot             125 188 8.0 115.0 122.0 129.0 
1356 Shoot             125 188 8.0 122.0 129.0 136.0 
1360 Shoot             125 188 8.0 129.0 136.0 144.0 
1364 Shoot             125 188 8.0 136.0 144.0 137.0 
1368 Shoot             125 188 8.0 144.0 137.0 130.0 
1372 Shoot             125 188 8.0 137.0 130.0 123.0 
1376 Shoot             125 188 8.0 130.0 123.0 116.0 
1380 Shoot             125 188 8.0 123.0 116.0 109.0 
1384 Shoot             125 188 8.0 116.0 109.0 102.0 
1388 Shoot             125 188 8.0 109.0 102.0 95.0 
1392 Shoot             125 188 8.0 102.0 95.0 88.0 
1396 Shoot             125 188 8.0 95.0 88.0 81.0 
1400 Shoot             125 188 8.0 88.0 81.0 74.0 
1404 Shoot             125 188 8.0 81.0 74.0 67.0 
1408 Shoot             125 188 8.0 74.0 67.0 60.0 
1412 Shoot             125 188 8.0 67.0 60.0 53.0 
1416 Shoot             125 188 8.0 60.0 53.0 46.0 
1420 Shoot             125 188 8.0 36.0 53.0 46.0 
1424 Shoot             125 188 8.0 36.0 43.0 46.0 
1428 Shoot             125 188 8.0 36.0 43.0 50.0 
1432 Shoot             125 188 8.0 43.0 50.0 57.0 
1436 Shoot             125 188 8.0 50.0 57.0 64.0 
1440 Shoot             125 188 8.0 57.0 64.0 71.0 
1444 Shoot             125 188 8.0 64.0 71.0 78.0 
1448 Shoot             125 188 8.0 71.0 78.0 85.0 
1452 Shoot             125 188 8.0 78.0 85.0 92.0 
1456 Shoot             125 188 8.0 85.0 92.0 99.0 
1460 Shoot             125 188 8.0 92.0 99.0 106.0 
1464 Shoot             125 188 8.0 99.0 106.0 113.0 
1468 Shoot             125 188 8.0 106.0 113.0 120.0 
1472 Shoot             125 188 8.0 113.0 120.0 127.0 
1476 Shoot             125 188 8.0 120.0 127.0 134.0 
1480 Shoot             125 188 8.0 127.0 134.0 146.0 
1484 Shoot             125 188 8.0 134.0 146.0 139.0 
1488 Shoot             125 188 8.0 146.0 139.0 132.0 
1492 Shoot             125 188 8.0 139.0 132.0 125.0 
1496 Shoot             125 188 8.0 132.0 125.0 118.0 
1500 Shoot             125 188 8.0 125.0 118.0 111.0 
1504 Shoot             125 188 8.0 118.0 111.0 104.0 
1508 Shoot             125 188 8.0 111.0 104.0 97.0 
1512 Shoot             125 188 8.0 104.0 97.0 90.0 
1516 Shoot             125 188 8.0 97.0 90.0 83.0 
1520 Shoot             125 188 8.0 90.0 83.0 76.0 
1524 Shoot             125 188 8.0 83.0 76.0 69.0 
1528 Shoot             125 188 8.0 76.0 69.0 62.0 
1532 Shoot             125 188 8.0 69.0 62.0 55.0 
1536 Shoot             125 188 8.0 62.0 55.0 48.0 
1540 Shoot             125 188 8.0 55.0 48.0 
1544 Shoot             125 188 8.0 48.0 



///////////////////////////


```

`Source Code/Data/EnemyLevel2.txt`:

```txt
typeID: 1   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
35   SetVelY           0.0
35   ShootToPlayer     50 95 4.0 0.0
35   ShootToPlayer     50 95 6.0 0.0
125  SetVelY           10.0
125  ShootToPlayer     50 95 4.0 0.0
125  ShootToPlayer     50 95 6.0 0.0
/////////////////////////
typeID: 2   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
70   SetVelY           0.0
70   SetVelX           2.0
76   ShootToPlayerRand 56  175 5.0 8.0 1
76   ShootToPlayerRand 105 175 5.0 8.0 1
82   ShootToPlayerRand 56  175 5.0 8.0 1
82   ShootToPlayerRand 105 175 5.0 8.0 1
88   ShootToPlayerRand 56  175 5.0 8.0 1
88   ShootToPlayerRand 105 175 5.0 8.0 1
94   ShootToPlayerRand 56  175 5.0 8.0 1
94   ShootToPlayerRand 105 175 5.0 8.0 1
100  ShootToPlayerRand 56  175 5.0 8.0 1
100  ShootToPlayerRand 105 175 5.0 8.0 1
106  ShootToPlayerRand 56  175 5.0 8.0 1
106  ShootToPlayerRand 105 175 5.0 8.0 1
112  ShootToPlayerRand 56  175 5.0 8.0 1
112  ShootToPlayerRand 105 175 5.0 8.0 1
118  ShootToPlayerRand 56  175 5.0 8.0 1
118  ShootToPlayerRand 105 175 5.0 8.0 1
124  ShootToPlayerRand 56  175 5.0 8.0 1
124  ShootToPlayerRand 105 175 5.0 8.0 1
130  ShootToPlayerRand 56  175 5.0 8.0 1
130  ShootToPlayerRand 105 175 5.0 8.0 1
130  SetVelX           0.0
130  SetVelY           -2.0             
/////////////////////////
typeID: 3   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
90   SetVelY           -2.0
98   ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
106  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
114  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
122  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
130  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
140  SetVelY           4.0
140  SetVelX           2.0
200  SetVelY           -2.0
200  SetVelX           0.0
208  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
216  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
224  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
232  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
240  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
240  SetVelY           4.0
/////////////////////////
typeID: 4   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
30   ShootToPlayer     25  80 5.0 0.0
42   ShootToPlayer     25  80 5.2 0.0
54   ShootToPlayer     25  80 5.4 0.0
66   ShootToPlayer     25  80 5.6 0.0
/////////////////////////
typeID: 5   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
35   SetVelY           0.0
35   ShootToPlayer     50  95 6.0 -45.0 -22.5 0.0 22.5 45.0
125  SetVelY           -5.0
125  SetAwayVelX       2.5
125  ShootToPlayer     50  95 6.0 -45.0 -22.5 0.0 22.5 45.0
/////////////////////////
typeID: 6   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
40  SetVelY            0.0
40  Charge             0
80  ShootLaser         23  220 16.0
80  ShootLaser         115 220 16.0
86  ShootLaser         23  220 16.0
86  ShootLaser         115 220 16.0
92  ShootLaser         23  220 16.0
92  ShootLaser         115 220 16.0
98  ShootLaser         23  220 16.0
98  ShootLaser         115 220 16.0
104 ShootLaser         23  220 16.0
104 ShootLaser         115 220 16.0
110 ShootLaser         23  220 16.0
110 ShootLaser         115 220 16.0
116 ShootLaser         23  220 16.0
116 ShootLaser         115 220 16.0
122 ShootLaser         23  220 16.0
122 ShootLaser         115 220 16.0
128 ShootLaser         23  220 16.0
128 ShootLaser         115 220 16.0
134 ShootLaser         23  220 16.0
134 ShootLaser         115 220 16.0
140 SetVelY            -2.0
140 ShootToPlayerRand  23  190 6.0 20.0 1
140 ShootToPlayerRand  115 190 6.0 20.0 1
148 ShootToPlayerRand  23  190 6.0 20.0 1
148 ShootToPlayerRand  115 190 6.0 20.0 1
156 ShootToPlayerRand  23  190 6.0 20.0 1
156 ShootToPlayerRand  115 190 6.0 20.0 1
164 ShootToPlayerRand  23  190 6.0 20.0 1
164 ShootToPlayerRand  115 190 6.0 20.0 1
172 ShootToPlayerRand  23  190 6.0 20.0 1
172 ShootToPlayerRand  115 190 6.0 20.0 1
180 ShootToPlayerRand  23  190 6.0 20.0 1
180 ShootToPlayerRand  115 190 6.0 20.0 1
188 ShootToPlayerRand  23  190 6.0 20.0 1
188 ShootToPlayerRand  115 190 6.0 20.0 1
196 ShootToPlayerRand  23  190 6.0 20.0 1
196 ShootToPlayerRand  115 190 6.0 20.0 1
204 ShootToPlayerRand  23  190 6.0 20.0 1
204 ShootToPlayerRand  115 190 6.0 20.0 1
212 ShootToPlayerRand  23  190 6.0 20.0 1
212 ShootToPlayerRand  115 190 6.0 20.0 1
220 ShootToPlayerRand  23  190 6.0 20.0 1
220 ShootToPlayerRand  115 190 6.0 20.0 1
228 ShootToPlayerRand  23  190 6.0 20.0 1
228 ShootToPlayerRand  115 190 6.0 20.0 1
/////////////////////////
typeID: 7   cmdCount: 1
MainCmd
0    SetCmd            0
290  SetFrame          50
=========================
50  SetVelX             0.0
50  SetVelY             0.0
56  ShootToPlayerRand   55  40  4.0 20.0 2
62  ShootToPlayerRand   55  40  4.0 20.0 2
68  ShootToPlayerRand   55  40  4.0 20.0 2
74  ShootToPlayerRand   55  40  4.0 20.0 2
80  ShootToPlayerRand   55  40  4.0 20.0 2
86  ShootToPlayerRand   55  40  4.0 20.0 2
92  ShootToPlayerRand   55  40  4.0 20.0 2
98  ShootToPlayerRand   55  40  4.0 20.0 2
104 ShootToPlayerRand   55  40  4.0 20.0 2
110 ShootToPlayerRand   55  40  4.0 20.0 2
140 SetVelX             5.0
140 SetVelY             3.0
170 SetVelX             0.0
170 SetVelY             0.0
176 ShootToPlayerRand   55  40  4.0 20.0 2
182 ShootToPlayerRand   55  40  4.0 20.0 2
188 ShootToPlayerRand   55  40  4.0 20.0 2
194 ShootToPlayerRand   55  40  4.0 20.0 2
200 ShootToPlayerRand   55  40  4.0 20.0 2
206 ShootToPlayerRand   55  40  4.0 20.0 2
212 ShootToPlayerRand   55  40  4.0 20.0 2
218 ShootToPlayerRand   55  40  4.0 20.0 2
224 ShootToPlayerRand   55  40  4.0 20.0 2
230 ShootToPlayerRand   55  40  4.0 20.0 2
260 SetVelX             5.0
260 SetVelY             3.0
/////////////////////////
typeID: 8   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
70   SetVelY           -3.0
70   SetAwayVelX       -4.5
90   ShootLaser        37  100 12.0
150  ShootLaser        37  100 12.0
/////////////////////////
typeID: 9   cmdCount: 1
MainCmd
0   SetCmd             0
=========================
40  SetVelY            0.0
40  Charge             0
80  ShootRand          30  240 8.0 90.0 30.0 5
86  ShootRand          30  240 8.0 90.0 30.0 5
92  ShootRand          30  240 8.0 90.0 30.0 5
98  ShootRand          30  240 8.0 90.0 30.0 5
104 ShootRand          30  240 8.0 90.0 30.0 5
110 ShootRand          30  240 8.0 90.0 30.0 5
116 ShootRand          30  240 8.0 90.0 30.0 5
122 ShootRand          30  240 8.0 90.0 30.0 5
128 ShootRand          30  240 8.0 90.0 30.0 5
134 ShootRand          30  240 8.0 90.0 30.0 5
140 ShootRand          30  240 8.0 90.0 30.0 5
146 ShootRand          30  240 8.0 90.0 30.0 5
152 ShootRand          30  240 8.0 90.0 30.0 5
158 ShootRand          30  240 8.0 90.0 30.0 5
164 ShootRand          30  240 8.0 90.0 30.0 5
180 SetVelY            -3.0
/////////////////////////
typeID: 13  cmdCount: 2
MainCmd
0    SetCmd             0
1250 SetFrame           120

180  SetFrameIfHPLess   2000 1290
270  SetFrameIfHPLess   2000 1290
360  SetFrameIfHPLess   2000 1290
450  SetFrameIfHPLess   2000 1290
540  SetFrameIfHPLess   2000 1290
630  SetFrameIfHPLess   2000 1290
720  SetFrameIfHPLess   2000 1290
810  SetFrameIfHPLess   2000 1290
900  SetFrameIfHPLess   2000 1290
990  SetFrameIfHPLess   2000 1290
1080 SetFrameIfHPLess   2000 1290
1170 SetFrameIfHPLess   2000 1290

1300 SetCmd             1
2900 SetFrame           1490
=========================
115  SetVelY           0.0
115  SetVelX           0.25
120  ShootToPlayerRand 161 99  10.0 15.0 2
120  ShootToPlayerRand 338 99  10.0 15.0 2
123  ShootToPlayerRand 161 99  10.0 15.0 2
123  ShootToPlayerRand 338 99  10.0 15.0 2
126  ShootToPlayerRand 161 99  10.0 15.0 2
126  ShootToPlayerRand 338 99  10.0 15.0 2
129  ShootToPlayerRand 161 99  10.0 15.0 2
129  ShootToPlayerRand 338 99  10.0 15.0 2
132  ShootToPlayerRand 161 99  10.0 15.0 2
132  ShootToPlayerRand 338 99  10.0 15.0 2
135  ShootToPlayerRand 161 99  10.0 15.0 2
135  ShootToPlayerRand 338 99  10.0 15.0 2
138  ShootToPlayerRand 161 99  10.0 15.0 2
138  ShootToPlayerRand 338 99  10.0 15.0 2
141  ShootToPlayerRand 161 99  10.0 15.0 2
141  ShootToPlayerRand 338 99  10.0 15.0 2
144  ShootToPlayerRand 161 99  10.0 15.0 2
144  ShootToPlayerRand 338 99  10.0 15.0 2
147  ShootToPlayerRand 161 99  10.0 15.0 2
147  ShootToPlayerRand 338 99  10.0 15.0 2
150  ShootToPlayerRand 161 99  10.0 15.0 2
150  ShootToPlayerRand 338 99  10.0 15.0 2
153  ShootToPlayerRand 161 99  10.0 15.0 2
153  ShootToPlayerRand 338 99  10.0 15.0 2
156  ShootToPlayerRand 161 99  10.0 15.0 2
156  ShootToPlayerRand 338 99  10.0 15.0 2
159  ShootToPlayerRand 161 99  10.0 15.0 2
159  ShootToPlayerRand 338 99  10.0 15.0 2
162  ShootToPlayerRand 161 99  10.0 15.0 2
162  ShootToPlayerRand 338 99  10.0 15.0 2
165  ShootToPlayerRand 161 99  10.0 15.0 2
165  ShootToPlayerRand 338 99  10.0 15.0 2
168  ShootToPlayerRand 161 99  10.0 15.0 2
168  ShootToPlayerRand 338 99  10.0 15.0 2
171  ShootToPlayerRand 161 99  10.0 15.0 2
171  ShootToPlayerRand 338 99  10.0 15.0 2
174  ShootToPlayerRand 161 99  10.0 15.0 2
174  ShootToPlayerRand 338 99  10.0 15.0 2
177  ShootToPlayerRand 161 99  10.0 15.0 2
177  ShootToPlayerRand 338 99  10.0 15.0 2

210  ShootToPlayerRand 161 99  10.0 15.0 2
210  ShootToPlayerRand 338 99  10.0 15.0 2
213  ShootToPlayerRand 161 99  10.0 15.0 2
213  ShootToPlayerRand 338 99  10.0 15.0 2
216  ShootToPlayerRand 161 99  10.0 15.0 2
216  ShootToPlayerRand 338 99  10.0 15.0 2
219  ShootToPlayerRand 161 99  10.0 15.0 2
219  ShootToPlayerRand 338 99  10.0 15.0 2
222  ShootToPlayerRand 161 99  10.0 15.0 2
222  ShootToPlayerRand 338 99  10.0 15.0 2
225  ShootToPlayerRand 161 99  10.0 15.0 2
225  ShootToPlayerRand 338 99  10.0 15.0 2
228  ShootToPlayerRand 161 99  10.0 15.0 2
228  ShootToPlayerRand 338 99  10.0 15.0 2
231  ShootToPlayerRand 161 99  10.0 15.0 2
231  ShootToPlayerRand 338 99  10.0 15.0 2
234  ShootToPlayerRand 161 99  10.0 15.0 2
234  ShootToPlayerRand 338 99  10.0 15.0 2
237  ShootToPlayerRand 161 99  10.0 15.0 2
237  ShootToPlayerRand 338 99  10.0 15.0 2
240  ShootToPlayerRand 161 99  10.0 15.0 2
240  ShootToPlayerRand 338 99  10.0 15.0 2
243  ShootToPlayerRand 161 99  10.0 15.0 2
243  ShootToPlayerRand 338 99  10.0 15.0 2
246  ShootToPlayerRand 161 99  10.0 15.0 2
246  ShootToPlayerRand 338 99  10.0 15.0 2
249  ShootToPlayerRand 161 99  10.0 15.0 2
249  ShootToPlayerRand 338 99  10.0 15.0 2
252  ShootToPlayerRand 161 99  10.0 15.0 2
252  ShootToPlayerRand 338 99  10.0 15.0 2
255  ShootToPlayerRand 161 99  10.0 15.0 2
255  ShootToPlayerRand 338 99  10.0 15.0 2
258  ShootToPlayerRand 161 99  10.0 15.0 2
258  ShootToPlayerRand 338 99  10.0 15.0 2
261  ShootToPlayerRand 161 99  10.0 15.0 2
261  ShootToPlayerRand 338 99  10.0 15.0 2
264  ShootToPlayerRand 161 99  10.0 15.0 2
264  ShootToPlayerRand 338 99  10.0 15.0 2
267  ShootToPlayerRand 161 99  10.0 15.0 2
267  ShootToPlayerRand 338 99  10.0 15.0 2

300  ShootToPlayerRand 161 99  10.0 15.0 2
300  ShootToPlayerRand 338 99  10.0 15.0 2
303  ShootToPlayerRand 161 99  10.0 15.0 2
303  ShootToPlayerRand 338 99  10.0 15.0 2
306  ShootToPlayerRand 161 99  10.0 15.0 2
306  ShootToPlayerRand 338 99  10.0 15.0 2
309  ShootToPlayerRand 161 99  10.0 15.0 2
309  ShootToPlayerRand 338 99  10.0 15.0 2
312  ShootToPlayerRand 161 99  10.0 15.0 2
132  ShootToPlayerRand 338 99  10.0 15.0 2
315  ShootToPlayerRand 161 99  10.0 15.0 2
315  ShootToPlayerRand 338 99  10.0 15.0 2
318  ShootToPlayerRand 161 99  10.0 15.0 2
318  ShootToPlayerRand 338 99  10.0 15.0 2
321  ShootToPlayerRand 161 99  10.0 15.0 2
321  ShootToPlayerRand 338 99  10.0 15.0 2
324  ShootToPlayerRand 161 99  10.0 15.0 2
324  ShootToPlayerRand 338 99  10.0 15.0 2
327  ShootToPlayerRand 161 99  10.0 15.0 2
327  ShootToPlayerRand 338 99  10.0 15.0 2
330  ShootToPlayerRand 161 99  10.0 15.0 2
330  ShootToPlayerRand 338 99  10.0 15.0 2
333  ShootToPlayerRand 161 99  10.0 15.0 2
333  ShootToPlayerRand 338 99  10.0 15.0 2
336  ShootToPlayerRand 161 99  10.0 15.0 2
336  ShootToPlayerRand 338 99  10.0 15.0 2
339  ShootToPlayerRand 161 99  10.0 15.0 2
339  ShootToPlayerRand 338 99  10.0 15.0 2
342  ShootToPlayerRand 161 99  10.0 15.0 2
342  ShootToPlayerRand 338 99  10.0 15.0 2
345  ShootToPlayerRand 161 99  10.0 15.0 2
345  ShootToPlayerRand 338 99  10.0 15.0 2
348  ShootToPlayerRand 161 99  10.0 15.0 2
348  ShootToPlayerRand 338 99  10.0 15.0 2
351  ShootToPlayerRand 161 99  10.0 15.0 2
351  ShootToPlayerRand 338 99  10.0 15.0 2
354  ShootToPlayerRand 161 99  10.0 15.0 2
354  ShootToPlayerRand 338 99  10.0 15.0 2
357  ShootToPlayerRand 161 99  10.0 15.0 2
357  ShootToPlayerRand 338 99  10.0 15.0 2

390  ShootToPlayerRand 161 99  10.0 15.0 2
390  ShootToPlayerRand 338 99  10.0 15.0 2
393  ShootToPlayerRand 161 99  10.0 15.0 2
393  ShootToPlayerRand 338 99  10.0 15.0 2
396  ShootToPlayerRand 161 99  10.0 15.0 2
396  ShootToPlayerRand 338 99  10.0 15.0 2
399  ShootToPlayerRand 161 99  10.0 15.0 2
399  ShootToPlayerRand 338 99  10.0 15.0 2
402  ShootToPlayerRand 161 99  10.0 15.0 2
402  ShootToPlayerRand 338 99  10.0 15.0 2
405  ShootToPlayerRand 161 99  10.0 15.0 2
405  ShootToPlayerRand 338 99  10.0 15.0 2
408  ShootToPlayerRand 161 99  10.0 15.0 2
408  ShootToPlayerRand 338 99  10.0 15.0 2
411  ShootToPlayerRand 161 99  10.0 15.0 2
411  ShootToPlayerRand 338 99  10.0 15.0 2
414  ShootToPlayerRand 161 99  10.0 15.0 2
414  ShootToPlayerRand 338 99  10.0 15.0 2
417  ShootToPlayerRand 161 99  10.0 15.0 2
417  ShootToPlayerRand 338 99  10.0 15.0 2
420  ShootToPlayerRand 161 99  10.0 15.0 2
420  ShootToPlayerRand 338 99  10.0 15.0 2
423  ShootToPlayerRand 161 99  10.0 15.0 2
423  ShootToPlayerRand 338 99  10.0 15.0 2
426  ShootToPlayerRand 161 99  10.0 15.0 2
426  ShootToPlayerRand 338 99  10.0 15.0 2
429  ShootToPlayerRand 161 99  10.0 15.0 2
429  ShootToPlayerRand 338 99  10.0 15.0 2
432  ShootToPlayerRand 161 99  10.0 15.0 2
432  ShootToPlayerRand 338 99  10.0 15.0 2
435  ShootToPlayerRand 161 99  10.0 15.0 2
435  ShootToPlayerRand 338 99  10.0 15.0 2
438  ShootToPlayerRand 161 99  10.0 15.0 2
438  ShootToPlayerRand 338 99  10.0 15.0 2
441  ShootToPlayerRand 161 99  10.0 15.0 2
441  ShootToPlayerRand 338 99  10.0 15.0 2
444  ShootToPlayerRand 161 99  10.0 15.0 2
444  ShootToPlayerRand 338 99  10.0 15.0 2
447  ShootToPlayerRand 161 99  10.0 15.0 2
447  ShootToPlayerRand 338 99  10.0 15.0 2


510  ShootLaser        127 118 12.0
510  ShootLaser        372 118 12.0
510  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
522  ShootLaser        162 118 12.0
522  ShootLaser        337 118 12.0
522  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0
534  ShootLaser        127 118 12.0
534  ShootLaser        337 118 12.0
534  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
546  ShootLaser        162 118 12.0
546  ShootLaser        372 118 12.0
546  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0

558  ShootLaser        127 118 12.0
558  ShootLaser        372 118 12.0
558  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
570  ShootLaser        162 118 12.0
570  ShootLaser        337 118 12.0
570  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0
582  ShootLaser        127 118 12.0
582  ShootLaser        337 118 12.0
582  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
594  ShootLaser        162 118 12.0
594  ShootLaser        372 118 12.0
594  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0

606  ShootLaser        127 118 12.0
606  ShootLaser        372 118 12.0
606  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
618  ShootLaser        162 118 12.0
618  ShootLaser        337 118 12.0
618  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0
630  ShootLaser        127 118 12.0
630  ShootLaser        337 118 12.0
630  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
642  ShootLaser        162 118 12.0
642  ShootLaser        372 118 12.0
642  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0

654  ShootLaser        127 118 12.0
654  ShootLaser        372 118 12.0
654  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
666  ShootLaser        162 118 12.0
666  ShootLaser        337 118 12.0
666  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0
678  ShootLaser        127 118 12.0
678  ShootLaser        337 118 12.0
678  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
690  ShootLaser        162 118 12.0
690  ShootLaser        372 118 12.0
690  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0

702  ShootLaser        127 118 12.0
702  ShootLaser        372 118 12.0
702  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
714  ShootLaser        162 118 12.0
714  ShootLaser        337 118 12.0
714  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0
726  ShootLaser        127 118 12.0
726  ShootLaser        337 118 12.0
726  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
738  ShootLaser        162 118 12.0
738  ShootLaser        372 118 12.0
738  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0


800  Shoot             194 100 8.0 41.0
800  Shoot             305 100 8.0 139.0
805  Shoot             194 100 8.0 49.0
805  Shoot             305 100 8.0 131.0
810  Shoot             194 100 8.0 57.0
810  Shoot             305 100 8.0 123.0
815  Shoot             194 100 8.0 65.0
815  Shoot             305 100 8.0 115.0
820  Shoot             194 100 8.0 73.0
820  Shoot             305 100 8.0 107.0
825  Shoot             194 100 8.0 81.0
825  Shoot             305 100 8.0 99.0
830  Shoot             194 100 8.0 89.0
830  Shoot             305 100 8.0 91.0
835  Shoot             194 100 8.0 97.0
835  Shoot             305 100 8.0 83.0
840  Shoot             194 100 8.0 105.0
840  Shoot             305 100 8.0 75.0
845  Shoot             194 100 8.0 113.0
845  Shoot             305 100 8.0 67.0
850  Shoot             194 100 8.0 121.0
850  Shoot             305 100 8.0 59.0
855  Shoot             194 100 8.0 129.0
855  Shoot             305 100 8.0 51.0
860  Shoot             194 100 8.0 137.0
860  Shoot             305 100 8.0 43.0
865  Shoot             194 100 8.0 129.0
865  Shoot             305 100 8.0 51.0
870  Shoot             194 100 8.0 121.0
870  Shoot             305 100 8.0 59.0
875  Shoot             194 100 8.0 113.0
875  Shoot             305 100 8.0 67.0
880  Shoot             194 100 8.0 105.0
880  Shoot             305 100 8.0 75.0
885  Shoot             194 100 8.0 97.0
885  Shoot             305 100 8.0 83.0
890  Shoot             194 100 8.0 89.0
890  Shoot             305 100 8.0 91.0
895  Shoot             194 100 8.0 81.0
895  Shoot             305 100 8.0 99.0
900  Shoot             194 100 8.0 73.0
900  Shoot             305 100 8.0 107.0
905  Shoot             194 100 8.0 65.0
905  Shoot             305 100 8.0 115.0
910  Shoot             194 100 8.0 57.0
910  Shoot             305 100 8.0 123.0
915  Shoot             194 100 8.0 49.0
915  Shoot             305 100 8.0 131.0
 
920  Shoot             194 100 8.0 45.0
920  Shoot             305 100 8.0 135.0
925  Shoot             194 100 8.0 53.0
925  Shoot             305 100 8.0 127.0
930  Shoot             194 100 8.0 61.0
930  Shoot             305 100 8.0 119.0
935  Shoot             194 100 8.0 69.0
935  Shoot             305 100 8.0 111.0
940  Shoot             194 100 8.0 77.0
940  Shoot             305 100 8.0 103.0
945  Shoot             194 100 8.0 85.0
945  Shoot             305 100 8.0 95.0
950  Shoot             194 100 8.0 93.0
950  Shoot             305 100 8.0 87.0
955  Shoot             194 100 8.0 101.0
955  Shoot             305 100 8.0 79.0
960  Shoot             194 100 8.0 109.0
960  Shoot             305 100 8.0 71.0
965  Shoot             194 100 8.0 117.0
965  Shoot             305 100 8.0 63.0
970  Shoot             194 100 8.0 125.0
970  Shoot             305 100 8.0 55.0
975  Shoot             194 100 8.0 133.0
975  Shoot             305 100 8.0 47.0
980  Shoot             194 100 8.0 133.0
980  Shoot             305 100 8.0 47.0
985  Shoot             194 100 8.0 125.0
985  Shoot             305 100 8.0 55.0
990  Shoot             194 100 8.0 117.0
990  Shoot             305 100 8.0 63.0
995  Shoot             194 100 8.0 109.0
995  Shoot             305 100 8.0 71.0
1000 Shoot             194 100 8.0 101.0
1000 Shoot             305 100 8.0 79.0
1005 Shoot             194 100 8.0 93.0
1005 Shoot             305 100 8.0 87.0
1010 Shoot             194 100 8.0 85.0
1010 Shoot             305 100 8.0 95.0
1015 Shoot             194 100 8.0 77.0
1015 Shoot             305 100 8.0 103.0
1020 Shoot             194 100 8.0 69.0
1020 Shoot             305 100 8.0 111.0
1025 Shoot             194 100 8.0 61.0
1025 Shoot             305 100 8.0 119.0
1030 Shoot             194 100 8.0 53.0
1030 Shoot             305 100 8.0 127.0
1035 Shoot             194 100 8.0 45.0
1035 Shoot             305 100 8.0 135.0
1040 Shoot             194 100 8.0 49.0
1040 Shoot             305 100 8.0 131.0

1045 Shoot             194 100 8.0 57.0
1045 Shoot             305 100 8.0 123.0
1050 Shoot             194 100 8.0 65.0
1050 Shoot             305 100 8.0 115.0
1055 Shoot             194 100 8.0 73.0
1055 Shoot             305 100 8.0 107.0
1060 Shoot             194 100 8.0 81.0
1060 Shoot             305 100 8.0 99.0
1065 Shoot             194 100 8.0 89.0
1065 Shoot             305 100 8.0 91.0
1070 Shoot             194 100 8.0 97.0
1070 Shoot             305 100 8.0 83.0
1075 Shoot             194 100 8.0 105.0
1075 Shoot             305 100 8.0 75.0
1080 Shoot             194 100 8.0 113.0
1080 Shoot             305 100 8.0 67.0
1085 Shoot             194 100 8.0 121.0
1085 Shoot             305 100 8.0 59.0
1090 Shoot             194 100 8.0 129.0
1090 Shoot             305 100 8.0 51.0
1095 Shoot             194 100 8.0 137.0
1095 Shoot             305 100 8.0 43.0
1100 Shoot             194 100 8.0 129.0
1100 Shoot             305 100 8.0 51.0
1105 Shoot             194 100 8.0 121.0
1105 Shoot             305 100 8.0 59.0
1110 Shoot             194 100 8.0 113.0
1110 Shoot             305 100 8.0 67.0
1115 Shoot             194 100 8.0 105.0
1115 Shoot             305 100 8.0 75.0
1120 Shoot             194 100 8.0 97.0
1120 Shoot             305 100 8.0 83.0
1125 Shoot             194 100 8.0 89.0
1125 Shoot             305 100 8.0 91.0
1130 Shoot             194 100 8.0 81.0
1130 Shoot             305 100 8.0 99.0
1135 Shoot             194 100 8.0 73.0
1135 Shoot             305 100 8.0 107.0
1140 Shoot             194 100 8.0 65.0
1140 Shoot             305 100 8.0 115.0
1145 Shoot             194 100 8.0 57.0
1145 Shoot             305 100 8.0 123.0
1150 Shoot             194 100 8.0 49.0
1150 Shoot             305 100 8.0 131.0
1155 Shoot             194 100 8.0 41.0
1155 Shoot             305 100 8.0 139.0
=========================
1301 SetVelX           0.0
1480 SetAwayVelX       0.25

1500 Shoot             250 88  8.0 43.0 
1503 Shoot             250 88  8.0 43.6 49.4 
1506 Shoot             250 88  8.0 44.2 50.0 55.8 
1509 Shoot             250 88  8.0 50.6 56.4 62.2 
1512 Shoot             250 88  8.0 57.0 62.8 68.6 
1515 Shoot             250 88  8.0 63.4 69.2 75.0 
1518 Shoot             250 88  8.0 69.8 75.6 81.4 
1521 Shoot             250 88  8.0 76.2 82.0 87.8 
1524 Shoot             250 88  8.0 82.6 88.4 94.2 
1527 Shoot             250 88  8.0 89.0 94.8 100.6 
1530 Shoot             250 88  8.0 95.4 101.2 107.0 
1533 Shoot             250 88  8.0 101.8 107.6 113.4 
1536 Shoot             250 88  8.0 108.2 114.0 119.8 
1539 Shoot             250 88  8.0 114.6 120.4 126.2 
1542 Shoot             250 88  8.0 121.0 126.8 132.6 
1545 Shoot             250 88  8.0 127.4 133.2 137.0 
1548 Shoot             250 88  8.0 133.8 136.4 130.6 
1551 Shoot             250 88  8.0 135.8 130.0 124.2 
1554 Shoot             250 88  8.0 129.4 123.6 117.8 
1557 Shoot             250 88  8.0 123.0 117.2 111.4 
1560 Shoot             250 88  8.0 116.6 110.8 105.0 
1563 Shoot             250 88  8.0 110.2 104.4 98.6 
1566 Shoot             250 88  8.0 103.8 98.0 92.2 
1569 Shoot             250 88  8.0 97.4 91.6 85.8 
1572 Shoot             250 88  8.0 91.0 85.2 79.4 
1575 Shoot             250 88  8.0 84.6 78.8 73.0 
1578 Shoot             250 88  8.0 78.2 72.4 66.6 
1581 Shoot             250 88  8.0 71.8 66.0 60.2 
1584 Shoot             250 88  8.0 65.4 59.6 53.8 
1587 Shoot             250 88  8.0 59.0 53.2 47.4 
1590 Shoot             250 88  8.0 52.6 46.8 45.0 
1593 Shoot             250 88  8.0 46.2 45.6 51.4 
1596 Shoot             250 88  8.0 46.2 52.0 57.8 
1599 Shoot             250 88  8.0 52.6 58.4 64.2 
1602 Shoot             250 88  8.0 59.0 64.8 70.6 
1605 Shoot             250 88  8.0 65.4 71.2 77.0 
1608 Shoot             250 88  8.0 71.8 77.6 83.4 
1611 Shoot             250 88  8.0 78.2 84.0 89.8 
1614 Shoot             250 88  8.0 84.6 90.4 96.2 
1617 Shoot             250 88  8.0 91.0 96.8 102.6 
1620 Shoot             250 88  8.0 97.4 103.2 109.0 
1623 Shoot             250 88  8.0 103.8 109.6 115.4 
1626 Shoot             250 88  8.0 110.2 116.0 121.8 
1629 Shoot             250 88  8.0 116.6 122.4 128.2 
1632 Shoot             250 88  8.0 123.0 128.8 134.6 
1635 Shoot             250 88  8.0 129.4 135.2 135.0 
1638 Shoot             250 88  8.0 135.8 134.4 128.6 
1641 Shoot             250 88  8.0 133.8 128.0 122.2 
1644 Shoot             250 88  8.0 127.4 121.6 115.8 
1647 Shoot             250 88  8.0 121.0 115.2 109.4 
1650 Shoot             250 88  8.0 114.6 108.8 103.0 
1653 Shoot             250 88  8.0 108.2 102.4 96.6 
1656 Shoot             250 88  8.0 101.8 96.0 90.2 
1659 Shoot             250 88  8.0 95.4 89.6 83.8 
1662 Shoot             250 88  8.0 89.0 83.2 77.4 
1665 Shoot             250 88  8.0 82.6 76.8 71.0 
1668 Shoot             250 88  8.0 76.2 70.4 64.6 
1671 Shoot             250 88  8.0 69.8 64.0 58.2 
1674 Shoot             250 88  8.0 63.4 57.6 51.8 
1677 Shoot             250 88  8.0 57.0 51.2 45.4 
1680 Shoot             250 88  8.0 50.6 44.8 47.0 
1683 Shoot             250 88  8.0 44.2 47.6 53.4 
1686 Shoot             250 88  8.0 48.2 54.0 59.8 
1689 Shoot             250 88  8.0 54.6 60.4 66.2 
1692 Shoot             250 88  8.0 61.0 66.8 72.6 
1695 Shoot             250 88  8.0 67.4 73.2 79.0 
1698 Shoot             250 88  8.0 73.8 79.6 85.4 
1701 Shoot             250 88  8.0 80.2 86.0 91.8 
1704 Shoot             250 88  8.0 86.6 92.4 98.2 
1707 Shoot             250 88  8.0 93.0 98.8 104.6 
1710 Shoot             250 88  8.0 99.4 105.2 111.0 
1713 Shoot             250 88  8.0 105.8 111.6 117.4 
1716 Shoot             250 88  8.0 112.2 118.0 123.8 
1719 Shoot             250 88  8.0 118.6 124.4 130.2 
1722 Shoot             250 88  8.0 125.0 130.8 136.6 
1725 Shoot             250 88  8.0 131.4 137.2 133.0 
1728 Shoot             250 88  8.0 137.8 132.4 126.6 
1731 Shoot             250 88  8.0 131.8 126.0 120.2 
1734 Shoot             250 88  8.0 125.4 119.6 113.8 
1737 Shoot             250 88  8.0 119.0 113.2 107.4 
1740 Shoot             250 88  8.0 112.6 106.8 101.0 
1743 Shoot             250 88  8.0 106.2 100.4 94.6 
1746 Shoot             250 88  8.0 99.8 94.0 88.2 
1749 Shoot             250 88  8.0 93.4 87.6 81.8 
1752 Shoot             250 88  8.0 87.0 81.2 75.4 
1755 Shoot             250 88  8.0 80.6 74.8 69.0 
1758 Shoot             250 88  8.0 74.2 68.4 62.6 
1761 Shoot             250 88  8.0 67.8 62.0 56.2 
1764 Shoot             250 88  8.0 61.4 55.6 49.8 
1767 Shoot             250 88  8.0 55.0 49.2 43.4 
1770 Shoot             250 88  8.0 48.6 42.8 
1773 Shoot             250 88  8.0 42.2 

1850 SetVelX           0.0
1850 SetVelY           6.0
1950 SetVelY           0.0
2040 SetVelY           -3.0

2070 ShootToPlayerRand 161 99  4.0 60.0 2
2070 ShootToPlayerRand 338 99  4.0 60.0 2
2076 ShootToPlayerRand 161 99  4.0 60.0 2
2076 ShootToPlayerRand 338 99  4.0 60.0 2
2082 ShootToPlayerRand 161 99  4.0 60.0 2
2082 ShootToPlayerRand 338 99  4.0 60.0 2
2088 ShootToPlayerRand 161 99  4.0 60.0 2
2088 ShootToPlayerRand 338 99  4.0 60.0 2
2094 ShootToPlayerRand 161 99  4.0 60.0 2
2094 ShootToPlayerRand 338 99  4.0 60.0 2
2100 ShootToPlayerRand 161 99  4.0 60.0 2
2100 ShootToPlayerRand 338 99  4.0 60.0 2
2106 ShootToPlayerRand 161 99  4.0 60.0 2
2106 ShootToPlayerRand 338 99  4.0 60.0 2
2112 ShootToPlayerRand 161 99  4.0 60.0 2
2112 ShootToPlayerRand 338 99  4.0 60.0 2
2118 ShootToPlayerRand 161 99  4.0 60.0 2
2118 ShootToPlayerRand 338 99  4.0 60.0 2
2124 ShootToPlayerRand 161 99  4.0 60.0 2
2124 ShootToPlayerRand 338 99  4.0 60.0 2
2130 ShootToPlayerRand 161 99  4.0 60.0 2
2130 ShootToPlayerRand 338 99  4.0 60.0 2
2136 ShootToPlayerRand 161 99  4.0 60.0 2
2136 ShootToPlayerRand 338 99  4.0 60.0 2
2142 ShootToPlayerRand 161 99  4.0 60.0 2
2142 ShootToPlayerRand 338 99  4.0 60.0 2
2148 ShootToPlayerRand 161 99  4.0 60.0 2
2148 ShootToPlayerRand 338 99  4.0 60.0 2
2154 ShootToPlayerRand 161 99  4.0 60.0 2
2154 ShootToPlayerRand 338 99  4.0 60.0 2
2160 ShootToPlayerRand 161 99  4.0 60.0 2
2160 ShootToPlayerRand 338 99  4.0 60.0 2
2166 ShootToPlayerRand 161 99  4.0 60.0 2
2166 ShootToPlayerRand 338 99  4.0 60.0 2
2172 ShootToPlayerRand 161 99  4.0 60.0 2
2172 ShootToPlayerRand 338 99  4.0 60.0 2
2178 ShootToPlayerRand 161 99  4.0 60.0 2
2178 ShootToPlayerRand 338 99  4.0 60.0 2
2184 ShootToPlayerRand 161 99  4.0 60.0 2
2184 ShootToPlayerRand 338 99  4.0 60.0 2

2240 SetVelY           0.0
2310 SetAwayVelX       0.25


2310 Shoot             250 88   6.0  174.0 167.0 160.0 153.0 146.0 139.0 132.0 125.0 118.0 111.0 104.0 97.0 90.0 83.0 76.0 69.0 62.0 55.0 48.0 41.0 34.0 27.0 20.0 13.0 6.0 
2310 ShootToPlayer     250 88   8.0 0.0
2315 ShootToPlayer     250 88   8.0 0.0
2320 ShootToPlayer     250 88   8.0 0.0
2325 ShootToPlayer     250 88   8.0 0.0
2330 ShootToPlayer     250 88   8.0 0.0
2335 ShootToPlayer     250 88   8.0 0.0
2340 ShootToPlayer     250 88   8.0 0.0
2345 ShootToPlayer     250 88   8.0 0.0
2350 ShootToPlayer     250 88   8.0 0.0
2355 ShootToPlayer     250 88   8.0 0.0
2360 ShootToPlayer     250 88   8.0 0.0

2360 Shoot             250 88   6.0  174.0 167.0 160.0 153.0 146.0 139.0 132.0 125.0 118.0 111.0 104.0 97.0 90.0 83.0 76.0 69.0 62.0 55.0 48.0 41.0 34.0 27.0 20.0 13.0 6.0 
2365 ShootToPlayer     250 88   8.0 0.0
2370 ShootToPlayer     250 88   8.0 0.0
2375 ShootToPlayer     250 88   8.0 0.0
2380 ShootToPlayer     250 88   8.0 0.0
2385 ShootToPlayer     250 88   8.0 0.0
2390 ShootToPlayer     250 88   8.0 0.0
2395 ShootToPlayer     250 88   8.0 0.0
2400 ShootToPlayer     250 88   8.0 0.0
2405 ShootToPlayer     250 88   8.0 0.0

2410 Shoot             250 88   6.0  174.0 167.0 160.0 153.0 146.0 139.0 132.0 125.0 118.0 111.0 104.0 97.0 90.0 83.0 76.0 69.0 62.0 55.0 48.0 41.0 34.0 27.0 20.0 13.0 6.0 
2410 ShootToPlayer     250 88   8.0 0.0
2415 ShootToPlayer     250 88   8.0 0.0
2420 ShootToPlayer     250 88   8.0 0.0
2425 ShootToPlayer     250 88   8.0 0.0
2430 ShootToPlayer     250 88   8.0 0.0
2435 ShootToPlayer     250 88   8.0 0.0
2440 ShootToPlayer     250 88   8.0 0.0
2445 ShootToPlayer     250 88   8.0 0.0
2450 ShootToPlayer     250 88   8.0 0.0
2455 ShootToPlayer     250 88   8.0 0.0

2460 Shoot             250 88   6.0  174.0 167.0 160.0 153.0 146.0 139.0 132.0 125.0 118.0 111.0 104.0 97.0 90.0 83.0 76.0 69.0 62.0 55.0 48.0 41.0 34.0 27.0 20.0 13.0 6.0 
2460 ShootToPlayer     250 88   8.0 0.0
2465 ShootToPlayer     250 88   8.0 0.0
2470 ShootToPlayer     250 88   8.0 0.0
2475 ShootToPlayer     250 88   8.0 0.0
2480 ShootToPlayer     250 88   8.0 0.0
2485 ShootToPlayer     250 88   8.0 0.0
2490 ShootToPlayer     250 88   8.0 0.0
2495 ShootToPlayer     250 88   8.0 0.0
2500 ShootToPlayer     250 88   8.0 0.0
2505 ShootToPlayer     250 88   8.0 0.0

2510 Shoot             250 88   6.0  174.0 167.0 160.0 153.0 146.0 139.0 132.0 125.0 118.0 111.0 104.0 97.0 90.0 83.0 76.0 69.0 62.0 55.0 48.0 41.0 34.0 27.0 20.0 13.0 6.0 
2510 ShootToPlayer     250 88   8.0 0.0
2515 ShootToPlayer     250 88   8.0 0.0
2520 ShootToPlayer     250 88   8.0 0.0
2525 ShootToPlayer     250 88   8.0 0.0
2530 ShootToPlayer     250 88   8.0 0.0
2535 ShootToPlayer     250 88   8.0 0.0
2540 ShootToPlayer     250 88   8.0 0.0
2545 ShootToPlayer     250 88   8.0 0.0
2550 ShootToPlayer     250 88   8.0 0.0
2555 ShootToPlayer     250 88   8.0 0.0

2560 Shoot             250 88   6.0  174.0 167.0 160.0 153.0 146.0 139.0 132.0 125.0 118.0 111.0 104.0 97.0 90.0 83.0 76.0 69.0 62.0 55.0 48.0 41.0 34.0 27.0 20.0 13.0 6.0 
2560 ShootToPlayer     250 88   8.0 0.0
2565 ShootToPlayer     250 88   8.0 0.0
2570 ShootToPlayer     250 88   8.0 0.0
2575 ShootToPlayer     250 88   8.0 0.0
2580 ShootToPlayer     250 88   8.0 0.0
2585 ShootToPlayer     250 88   8.0 0.0
2590 ShootToPlayer     250 88   8.0 0.0
2595 ShootToPlayer     250 88   8.0 0.0
2600 ShootToPlayer     250 88   8.0 0.0
2605 ShootToPlayer     250 88   8.0 0.0

2610 Shoot             250 88   6.0  174.0 167.0 160.0 153.0 146.0 139.0 132.0 125.0 118.0 111.0 104.0 97.0 90.0 83.0 76.0 69.0 62.0 55.0 48.0 41.0 34.0 27.0 20.0 13.0 6.0 
2610 ShootToPlayer     250 88   8.0 0.0
2615 ShootToPlayer     250 88   8.0 0.0
2620 ShootToPlayer     250 88   8.0 0.0
2625 ShootToPlayer     250 88   8.0 0.0
2630 ShootToPlayer     250 88   8.0 0.0
2635 ShootToPlayer     250 88   8.0 0.0
2640 ShootToPlayer     250 88   8.0 0.0
2645 ShootToPlayer     250 88   8.0 0.0
2650 ShootToPlayer     250 88   8.0 0.0
2655 ShootToPlayer     250 88   8.0 0.0

2660 Shoot             250 88   6.0  174.0 167.0 160.0 153.0 146.0 139.0 132.0 125.0 118.0 111.0 104.0 97.0 90.0 83.0 76.0 69.0 62.0 55.0 48.0 41.0 34.0 27.0 20.0 13.0 6.0 
2660 ShootToPlayer     250 88   8.0 0.0
2665 ShootToPlayer     250 88   8.0 0.0
2670 ShootToPlayer     250 88   8.0 0.0
2675 ShootToPlayer     250 88   8.0 0.0
2680 ShootToPlayer     250 88   8.0 0.0
2685 ShootToPlayer     250 88   8.0 0.0
2690 ShootToPlayer     250 88   8.0 0.0
2695 ShootToPlayer     250 88   8.0 0.0
2700 ShootToPlayer     250 88   8.0 0.0
2705 ShootToPlayer     250 88   8.0 0.0

2710 Shoot             250 88   6.0  174.0 167.0 160.0 153.0 146.0 139.0 132.0 125.0 118.0 111.0 104.0 97.0 90.0 83.0 76.0 69.0 62.0 55.0 48.0 41.0 34.0 27.0 20.0 13.0 6.0 
2710 ShootToPlayer     250 88   8.0 0.0
2715 ShootToPlayer     250 88   8.0 0.0
2720 ShootToPlayer     250 88   8.0 0.0
2725 ShootToPlayer     250 88   8.0 0.0
2730 ShootToPlayer     250 88   8.0 0.0
2735 ShootToPlayer     250 88   8.0 0.0
2740 ShootToPlayer     250 88   8.0 0.0
2745 ShootToPlayer     250 88   8.0 0.0
2750 ShootToPlayer     250 88   8.0 0.0
2755 ShootToPlayer     250 88   8.0 0.0

2760 Shoot             250 88   6.0  174.0 167.0 160.0 153.0 146.0 139.0 132.0 125.0 118.0 111.0 104.0 97.0 90.0 83.0 76.0 69.0 62.0 55.0 48.0 41.0 34.0 27.0 20.0 13.0 6.0 
2760 ShootToPlayer     250 88   8.0 0.0
2765 ShootToPlayer     250 88   8.0 0.0
2770 ShootToPlayer     250 88   8.0 0.0
2775 ShootToPlayer     250 88   8.0 0.0
2780 ShootToPlayer     250 88   8.0 0.0
2785 ShootToPlayer     250 88   8.0 0.0

```

`Source Code/Data/EnemyLevel3.txt`:

```txt
typeID: 1   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
35   SetVelY           0.0
35   ShootToPlayer     50 95 4.0 0.0
35   ShootToPlayer     50 95 6.0 0.0
35   ShootToPlayer     50 95 8.0 0.0
125  SetVelY           10.0
125  ShootToPlayer     50 95 4.0 0.0
125  ShootToPlayer     50 95 6.0 0.0
125  ShootToPlayer     50 95 8.0 0.0
/////////////////////////
typeID: 2   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
70   SetVelY           0.0
70   SetVelX           2.0
76   ShootToPlayerRand 56  175 5.0 8.0 1
76   ShootToPlayerRand 105 175 5.0 8.0 1
82   ShootToPlayerRand 56  175 5.0 8.0 1
82   ShootToPlayerRand 105 175 5.0 8.0 1
88   ShootToPlayerRand 56  175 5.0 8.0 1
88   ShootToPlayerRand 105 175 5.0 8.0 1
94   ShootToPlayerRand 56  175 5.0 8.0 1
94   ShootToPlayerRand 105 175 5.0 8.0 1
100  ShootToPlayerRand 56  175 5.0 8.0 1
100  ShootToPlayerRand 105 175 5.0 8.0 1
106  ShootToPlayerRand 56  175 5.0 8.0 1
106  ShootToPlayerRand 105 175 5.0 8.0 1
112  ShootToPlayerRand 56  175 5.0 8.0 1
112  ShootToPlayerRand 105 175 5.0 8.0 1
118  ShootToPlayerRand 56  175 5.0 8.0 1
118  ShootToPlayerRand 105 175 5.0 8.0 1
124  ShootToPlayerRand 56  175 5.0 8.0 1
124  ShootToPlayerRand 105 175 5.0 8.0 1
130  ShootToPlayerRand 56  175 5.0 8.0 1
130  ShootToPlayerRand 105 175 5.0 8.0 1
130  SetVelX           0.0
130  SetVelY           -2.0             
/////////////////////////
typeID: 3   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
90   SetVelY           -2.0
98   ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
106  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
114  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
122  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
130  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
140  SetVelY           4.0
140  SetVelX           2.0
200  SetVelY           -2.0
200  SetVelX           0.0
208  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
216  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
224  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
232  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
240  ShootToPlayer     95  170 8.0 -45.0 -22.5 0.0 22.5 45.0
240  SetVelY           4.0
/////////////////////////
typeID: 4   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
30   ShootToPlayer     25  80 5.0 0.0
42   ShootToPlayer     25  80 5.2 0.0
54   ShootToPlayer     25  80 5.4 0.0
66   ShootToPlayer     25  80 5.6 0.0
78   ShootToPlayer     25  80 5.8 0.0
90   ShootToPlayer     25  80 6.0 0.0
/////////////////////////
typeID: 5   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
35   SetVelY           0.0
35   ShootToPlayer     50  95 6.0 -45.0 -22.5 0.0 22.5 45.0
125  SetVelY           -5.0
125  SetAwayVelX       2.5
125  ShootToPlayer     50  95 6.0 -45.0 -22.5 0.0 22.5 45.0
/////////////////////////
typeID: 6   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
40   SetVelY            0.0
40   Charge             0
80   ShootLaser         23  220 16.0
80   ShootLaser         115 220 16.0
86   ShootLaser         23  220 16.0
86   ShootLaser         115 220 16.0
92   ShootLaser         23  220 16.0
92   ShootLaser         115 220 16.0
98   ShootLaser         23  220 16.0
98   ShootLaser         115 220 16.0
104  ShootLaser         23  220 16.0
104  ShootLaser         115 220 16.0
110  ShootLaser         23  220 16.0
110  ShootLaser         115 220 16.0
116  ShootLaser         23  220 16.0
116  ShootLaser         115 220 16.0
122  ShootLaser         23  220 16.0
122  ShootLaser         115 220 16.0
128  ShootLaser         23  220 16.0
128  ShootLaser         115 220 16.0
134  ShootLaser         23  220 16.0
134  ShootLaser         115 220 16.0
140  SetVelY            -2.0
140  ShootToPlayerRand  23  190 6.0 20.0 1
140  ShootToPlayerRand  115 190 6.0 20.0 1
148  ShootToPlayerRand  23  190 6.0 20.0 1
148  ShootToPlayerRand  115 190 6.0 20.0 1
156  ShootToPlayerRand  23  190 6.0 20.0 1
156  ShootToPlayerRand  115 190 6.0 20.0 1
164  ShootToPlayerRand  23  190 6.0 20.0 1
164  ShootToPlayerRand  115 190 6.0 20.0 1
172  ShootToPlayerRand  23  190 6.0 20.0 1
172  ShootToPlayerRand  115 190 6.0 20.0 1
180  ShootToPlayerRand  23  190 6.0 20.0 1
180  ShootToPlayerRand  115 190 6.0 20.0 1
188  ShootToPlayerRand  23  190 6.0 20.0 1
188  ShootToPlayerRand  115 190 6.0 20.0 1
196  ShootToPlayerRand  23  190 6.0 20.0 1
196  ShootToPlayerRand  115 190 6.0 20.0 1
204  ShootToPlayerRand  23  190 6.0 20.0 1
204  ShootToPlayerRand  115 190 6.0 20.0 1
212  ShootToPlayerRand  23  190 6.0 20.0 1
212  ShootToPlayerRand  115 190 6.0 20.0 1
220  ShootToPlayerRand  23  190 6.0 20.0 1
220  ShootToPlayerRand  115 190 6.0 20.0 1
228  ShootToPlayerRand  23  190 6.0 20.0 1
228  ShootToPlayerRand  115 190 6.0 20.0 1
/////////////////////////
typeID: 7   cmdCount: 1
MainCmd
0    SetCmd            0
160  SetFrame          40
=========================
50   SetVelX             0.0
50   SetVelY             0.0
56   ShootToPlayerRand   55  40  5.0 20.0 2
62   ShootToPlayerRand   55  40  5.0 20.0 2
68   ShootToPlayerRand   55  40  5.0 20.0 2
74   ShootToPlayerRand   55  40  5.0 20.0 2
80   ShootToPlayerRand   55  40  5.0 20.0 2
86   ShootToPlayerRand   55  40  5.0 20.0 2
92   ShootToPlayerRand   55  40  5.0 20.0 2
98   ShootToPlayerRand   55  40  5.0 20.0 2
140  SetVelX             5.0
140  SetVelY             3.0
/////////////////////////
typeID: 8   cmdCount: 1
MainCmd
0    SetCmd             0
=========================
70   SetVelY            -3.0
70   SetAwayVelX        -4.5
90   ShootLaser         37  100 12.0
150  ShootLaser         37  100 12.0
/////////////////////////
typeID: 9   cmdCount: 1
MainCmd
0    SetCmd             0
=========================
40   SetVelY            0.0
40   Charge             0
80   ShootRand          30  240 8.0 90.0 30.0 5
86   ShootRand          30  240 8.0 90.0 30.0 5
92   ShootRand          30  240 8.0 90.0 30.0 5
98   ShootRand          30  240 8.0 90.0 30.0 5
104  ShootRand          30  240 8.0 90.0 30.0 5
110  ShootRand          30  240 8.0 90.0 30.0 5
116  ShootRand          30  240 8.0 90.0 30.0 5
122  ShootRand          30  240 8.0 90.0 30.0 5
128  ShootRand          30  240 8.0 90.0 30.0 5
134  ShootRand          30  240 8.0 90.0 30.0 5
140  ShootRand          30  240 8.0 90.0 30.0 5
146  ShootRand          30  240 8.0 90.0 30.0 5
152  ShootRand          30  240 8.0 90.0 30.0 5
158  ShootRand          30  240 8.0 90.0 30.0 5
164  ShootRand          30  240 8.0 90.0 30.0 5
180  SetVelY            -3.0
/////////////////////////
typeID: 10   cmdCount: 1
MainCmd
0   SetCmd              0
340 SetFrame            60
=========================
80   ShootRand          78  110 5.0  135.0 47.0 8
80   ShootRand          161 110 5.0  45.0  47.0 8
90   ShootRand          78  110 5.0  135.0 47.0 8
90   ShootRand          161 110 5.0  45.0  47.0 8
100  ShootRand          78  110 5.0  135.0 47.0 8
100  ShootRand          161 110 5.0  45.0  47.0 8
110  ShootRand          78  110 5.0  135.0 47.0 8
110  ShootRand          161 110 5.0  45.0  47.0 8
120  ShootRand          78  110 5.0  135.0 47.0 8
120  ShootRand          161 110 5.0  45.0  47.0 8
130  ShootRand          78  110 5.0  135.0 47.0 8
130  ShootRand          161 110 5.0  45.0  47.0 8
140  ShootRand          78  110 5.0  135.0 47.0 8
140  ShootRand          161 110 5.0  45.0  47.0 8
150  ShootRand          78  110 5.0  135.0 47.0 8
150  ShootRand          161 110 5.0  45.0  47.0 8

200  Charge             0
200  SetVelX            0.0
200  SetVelY            0.0
240  ShootLaser         119 200 16.0
246  ShootLaser         119 200 16.0
252  ShootLaser         119 200 16.0
258  ShootLaser         119 200 16.0
264  ShootLaser         119 200 16.0
270  ShootLaser         119 200 16.0
276  ShootLaser         119 200 16.0
282  ShootLaser         119 200 16.0
288  ShootLaser         119 200 16.0
294  ShootLaser         119 200 16.0
330  SetVelX            0.5
330  SetVelY            1.5
//////////////////////////
typeID: 11   cmdCount: 1
MainCmd
0    SetCmd             0
==========================
40   SetVelY            0.0
40   Charge             0

80   Shoot              30  240 8.0 17.0 20.0 23.0 
83   Shoot              30  240 8.0 31.0 34.0 37.0 
86   Shoot              30  240 8.0 45.0 48.0 51.0 
89   Shoot              30  240 8.0 59.0 62.0 65.0 
92   Shoot              30  240 8.0 73.0 76.0 79.0 
95   Shoot              30  240 8.0 87.0 90.0 93.0 
98   Shoot              30  240 8.0 101.0 104.0 107.0 
101  Shoot              30  240 8.0 115.0 118.0 121.0 
104  Shoot              30  240 8.0 129.0 132.0 135.0 
107  Shoot              30  240 8.0 143.0 146.0 149.0 
110  Shoot              30  240 8.0 163.0 160.0 157.0 
113  Shoot              30  240 8.0 149.0 146.0 143.0 
116  Shoot              30  240 8.0 135.0 132.0 129.0 
119  Shoot              30  240 8.0 121.0 118.0 115.0 
122  Shoot              30  240 8.0 107.0 104.0 101.0 
125  Shoot              30  240 8.0 93.0 90.0 87.0 
128  Shoot              30  240 8.0 79.0 76.0 73.0 
131  Shoot              30  240 8.0 65.0 62.0 59.0 
134  Shoot              30  240 8.0 51.0 48.0 45.0 
137  Shoot              30  240 8.0 37.0 34.0 31.0 
140  Shoot              30  240 8.0 17.0 20.0 23.0 
143  Shoot              30  240 8.0 31.0 34.0 37.0 
146  Shoot              30  240 8.0 45.0 48.0 51.0 
149  Shoot              30  240 8.0 59.0 62.0 65.0 
152  Shoot              30  240 8.0 73.0 76.0 79.0 
155  Shoot              30  240 8.0 87.0 90.0 93.0 
158  Shoot              30  240 8.0 101.0 104.0 107.0 
161  Shoot              30  240 8.0 115.0 118.0 121.0 
164  Shoot              30  240 8.0 129.0 132.0 135.0 
167  Shoot              30  240 8.0 143.0 146.0 149.0 

180  SetVelY            -3.0
///////////////////////////
typeID: 14   cmdCount: 18
MainCmd
0    SetCmd             0
115  SetCmd             1 2
598  SetCmd             3

180  SetFrameIfHPLess   4500 999
270  SetFrameIfHPLess   4500 999
360  SetFrameIfHPLess   4500 999
450  SetFrameIfHPLess   4500 999
540  SetFrameIfHPLess   4500 999
630  SetFrameIfHPLess   4500 999
720  SetFrameIfHPLess   4500 999
810  SetFrameIfHPLess   4500 999

900  SetFrame           110



1000 SetCmd             4
1180 SetCmd             5 6 7
1680 SetCmd             8

1200 SetFrameIfHPLess   2500 2199
1290 SetFrameIfHPLess   2500 2199
1380 SetFrameIfHPLess   2500 2199
1470 SetFrameIfHPLess   2500 2199
1560 SetFrameIfHPLess   2500 2199
1650 SetFrameIfHPLess   2500 2199
1740 SetFrameIfHPLess   2500 2199
1830 SetFrameIfHPLess   2500 2199
1920 SetFrameIfHPLess   2500 2199
2010 SetFrameIfHPLess   2500 2199
2100 SetFrameIfHPLess   2500 2199

2120 SetFrame           1170

2200 SetCmd             9
2375 SetCmd             10 11
2890 SetCmd             12
3600 SetCmd             13 14 15 16
4150 SetCmd             17 
4960 SetFrame           2370            

===========Cmd0===========
105  SetVelY            0.0
===========Cmd1===========
120  SetVelX            1.5

120  ShootToPlayer     160 123 6.0 -60.0 -58.0 -56.0 -50.0 -48.0 -46.0 -40.0 -38.0 -36.0 -30.0 -28.0 -26.0 -20.0 -18.0 -16.0 -10.0 -8.0 -6.0 0.0 2.0 4.0 10.0 12.0 14.0 45.0 30.0 22.0 24.0 30.0 32.0 34.0 40.0 42.0 44.0 50.0 52.0 54.0 60.0 62.0 64.0 
160  ShootToPlayer     160 123 6.0 -59.0 -57.0 -55.0 -49.0 -47.0 -45.0 -39.0 -37.0 -35.0 -29.0 -27.0 -25.0 -19.0 -17.0 -15.0 -9.0 -7.0 -5.0 1.0 3.0 5.0 11.0 13.0 15.0 21.0 23.0 25.0 31.0 33.0 35.0 41.0 43.0 45.0 51.0 53.0 55.0 61.0 63.0 65.0 
200  ShootToPlayer     160 123 6.0 -59.0 -57.0 -55.0 -49.0 -47.0 -45.0 -39.0 -37.0 -35.0 -29.0 -27.0 -25.0 -19.0 -17.0 -15.0 -9.0 -7.0 -5.0 1.0 3.0 5.0 11.0 13.0 15.0 21.0 23.0 25.0 31.0 33.0 35.0 41.0 43.0 45.0 51.0 53.0 55.0 61.0 63.0 65.0 
240  ShootToPlayer     160 123 6.0 -67.0 -65.0 -63.0 -57.0 -55.0 -53.0 -47.0 -45.0 -43.0 -37.0 -35.0 -33.0 -27.0 -25.0 -23.0 -17.0 -15.0 -13.0 -7.0 -5.0 -3.0 3.0 5.0 7.0 13.0 15.0 17.0 23.0 25.0 27.0 33.0 35.0 37.0 43.0 45.0 47.0 53.0 55.0 57.0 
280  ShootToPlayer     160 123 6.0 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 
320  ShootToPlayer     160 123 6.0 -63.0 -61.0 -59.0 -53.0 -51.0 -49.0 -43.0 -41.0 -39.0 -33.0 -31.0 -29.0 -23.0 -21.0 -19.0 -13.0 -11.0 -9.0 -3.0 -1.0 1.0 7.0 9.0 11.0 17.0 19.0 21.0 27.0 29.0 31.0 37.0 39.0 41.0 47.0 49.0 51.0 57.0 59.0 61.0 
360  ShootToPlayer     160 123 6.0 -63.0 -61.0 -59.0 -53.0 -51.0 -49.0 -43.0 -41.0 -39.0 -33.0 -31.0 -29.0 -23.0 -21.0 -19.0 -13.0 -11.0 -9.0 -3.0 -1.0 1.0 7.0 9.0 11.0 17.0 19.0 21.0 27.0 29.0 31.0 37.0 39.0 41.0 47.0 49.0 51.0 57.0 59.0 61.0 
400  ShootToPlayer     160 123 6.0 -58.0 -56.0 -54.0 -48.0 -46.0 -44.0 -38.0 -36.0 -34.0 -28.0 -26.0 -24.0 -18.0 -16.0 -14.0 -8.0 -6.0 -4.0 45.0 3.0 4.0 6.0 12.0 14.0 16.0 22.0 24.0 45.0 36.0 32.0 34.0 36.0 42.0 44.0 46.0 52.0 54.0 56.0 62.0 64.0 66.0 
440  ShootToPlayer     160 123 6.0 -67.0 -65.0 -63.0 -57.0 -55.0 -53.0 -47.0 -45.0 -43.0 -37.0 -35.0 -33.0 -27.0 -25.0 -23.0 -17.0 -15.0 -13.0 -7.0 -5.0 -3.0 3.0 5.0 7.0 13.0 15.0 17.0 23.0 25.0 27.0 33.0 35.0 37.0 43.0 45.0 47.0 53.0 55.0 57.0 
480  ShootToPlayer     160 123 6.0 -68.0 -66.0 -64.0 -58.0 -56.0 -54.0 -48.0 -46.0 -44.0 -38.0 -36.0 -34.0 -28.0 -26.0 -24.0 -18.0 -16.0 -14.0 -8.0 -6.0 -4.0 45.0 3.0 4.0 6.0 12.0 14.0 16.0 22.0 24.0 45.0 36.0 32.0 34.0 36.0 42.0 44.0 46.0 52.0 54.0 56.0 
520  ShootToPlayer     160 123 6.0 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 
560  ShootToPlayer     160 123 6.0 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 
===========Cmd2===========
120  SetVelX           1.5

120  ShootToPlayerRand 15  75 4.0 45.0 2
120  ShootToPlayerRand 304 75 4.0 45.0 2
129  ShootToPlayerRand 15  75 4.0 45.0 2
129  ShootToPlayerRand 304 75 4.0 45.0 2
138  ShootToPlayerRand 15  75 4.0 45.0 2
138  ShootToPlayerRand 304 75 4.0 45.0 2
147  ShootToPlayerRand 15  75 4.0 45.0 2
147  ShootToPlayerRand 304 75 4.0 45.0 2
156  ShootToPlayerRand 15  75 4.0 45.0 2
156  ShootToPlayerRand 304 75 4.0 45.0 2
165  ShootToPlayerRand 15  75 4.0 45.0 2
165  ShootToPlayerRand 304 75 4.0 45.0 2
174  ShootToPlayerRand 15  75 4.0 45.0 2
174  ShootToPlayerRand 304 75 4.0 45.0 2
183  ShootToPlayerRand 15  75 4.0 45.0 2
183  ShootToPlayerRand 304 75 4.0 45.0 2
192  ShootToPlayerRand 15  75 4.0 45.0 2
192  ShootToPlayerRand 304 75 4.0 45.0 2
201  ShootToPlayerRand 15  75 4.0 45.0 2
201  ShootToPlayerRand 304 75 4.0 45.0 2
210  ShootToPlayerRand 15  75 4.0 45.0 2
210  ShootToPlayerRand 304 75 4.0 45.0 2
219  ShootToPlayerRand 15  75 4.0 45.0 2
219  ShootToPlayerRand 304 75 4.0 45.0 2
228  ShootToPlayerRand 15  75 4.0 45.0 2
228  ShootToPlayerRand 304 75 4.0 45.0 2
237  ShootToPlayerRand 15  75 4.0 45.0 2
237  ShootToPlayerRand 304 75 4.0 45.0 2
246  ShootToPlayerRand 15  75 4.0 45.0 2
246  ShootToPlayerRand 304 75 4.0 45.0 2
255  ShootToPlayerRand 15  75 4.0 45.0 2
255  ShootToPlayerRand 304 75 4.0 45.0 2
264  ShootToPlayerRand 15  75 4.0 45.0 2
264  ShootToPlayerRand 304 75 4.0 45.0 2
273  ShootToPlayerRand 15  75 4.0 45.0 2
273  ShootToPlayerRand 304 75 4.0 45.0 2
282  ShootToPlayerRand 15  75 4.0 45.0 2
282  ShootToPlayerRand 304 75 4.0 45.0 2
291  ShootToPlayerRand 15  75 4.0 45.0 2
291  ShootToPlayerRand 304 75 4.0 45.0 2
300  ShootToPlayerRand 15  75 4.0 45.0 2
300  ShootToPlayerRand 304 75 4.0 45.0 2
309  ShootToPlayerRand 15  75 4.0 45.0 2
309  ShootToPlayerRand 304 75 4.0 45.0 2
318  ShootToPlayerRand 15  75 4.0 45.0 2
318  ShootToPlayerRand 304 75 4.0 45.0 2
327  ShootToPlayerRand 15  75 4.0 45.0 2
327  ShootToPlayerRand 304 75 4.0 45.0 2
336  ShootToPlayerRand 15  75 4.0 45.0 2
336  ShootToPlayerRand 304 75 4.0 45.0 2
345  ShootToPlayerRand 15  75 4.0 45.0 2
345  ShootToPlayerRand 304 75 4.0 45.0 2
354  ShootToPlayerRand 15  75 4.0 45.0 2
354  ShootToPlayerRand 304 75 4.0 45.0 2
363  ShootToPlayerRand 15  75 4.0 45.0 2
363  ShootToPlayerRand 304 75 4.0 45.0 2
372  ShootToPlayerRand 15  75 4.0 45.0 2
372  ShootToPlayerRand 304 75 4.0 45.0 2
381  ShootToPlayerRand 15  75 4.0 45.0 2
381  ShootToPlayerRand 304 75 4.0 45.0 2
390  ShootToPlayerRand 15  75 4.0 45.0 2
390  ShootToPlayerRand 304 75 4.0 45.0 2
399  ShootToPlayerRand 15  75 4.0 45.0 2
399  ShootToPlayerRand 304 75 4.0 45.0 2
408  ShootToPlayerRand 15  75 4.0 45.0 2
408  ShootToPlayerRand 304 75 4.0 45.0 2
417  ShootToPlayerRand 15  75 4.0 45.0 2
417  ShootToPlayerRand 304 75 4.0 45.0 2
426  ShootToPlayerRand 15  75 4.0 45.0 2
426  ShootToPlayerRand 304 75 4.0 45.0 2
435  ShootToPlayerRand 15  75 4.0 45.0 2
435  ShootToPlayerRand 304 75 4.0 45.0 2
444  ShootToPlayerRand 15  75 4.0 45.0 2
444  ShootToPlayerRand 304 75 4.0 45.0 2
453  ShootToPlayerRand 15  75 4.0 45.0 2
453  ShootToPlayerRand 304 75 4.0 45.0 2
462  ShootToPlayerRand 15  75 4.0 45.0 2
462  ShootToPlayerRand 304 75 4.0 45.0 2
471  ShootToPlayerRand 15  75 4.0 45.0 2
471  ShootToPlayerRand 304 75 4.0 45.0 2
480  ShootToPlayerRand 15  75 4.0 45.0 2
480  ShootToPlayerRand 304 75 4.0 45.0 2
489  ShootToPlayerRand 15  75 4.0 45.0 2
489  ShootToPlayerRand 304 75 4.0 45.0 2
498  ShootToPlayerRand 15  75 4.0 45.0 2
498  ShootToPlayerRand 304 75 4.0 45.0 2
507  ShootToPlayerRand 15  75 4.0 45.0 2
507  ShootToPlayerRand 304 75 4.0 45.0 2
516  ShootToPlayerRand 15  75 4.0 45.0 2
516  ShootToPlayerRand 304 75 4.0 45.0 2
525  ShootToPlayerRand 15  75 4.0 45.0 2
525  ShootToPlayerRand 304 75 4.0 45.0 2
534  ShootToPlayerRand 15  75 4.0 45.0 2
534  ShootToPlayerRand 304 75 4.0 45.0 2
543  ShootToPlayerRand 15  75 4.0 45.0 2
543  ShootToPlayerRand 304 75 4.0 45.0 2
552  ShootToPlayerRand 15  75 4.0 45.0 2
552  ShootToPlayerRand 304 75 4.0 45.0 2
============Cmd3==========
600  Charge            0
600  SetVelX           0.0
600  SetVelY           0.0

640  Shoot             15  75  6.0 182.0 180.0 178.0
640  Shoot             34  125 6.0 12.0 10.0 8.0
640  Shoot             285 125 6.0 172.0 170.0 168.0
640  Shoot             304 75  6.0 2.0 0.0 -2.0
650  Shoot             15  75  6.0 166.0 164.0 162.0
650  Shoot             34  125 6.0 28.0 26.0 24.0
650  Shoot             285 125 6.0 156.0 154.0 152.0
650  Shoot             304 75  6.0 18.0 16.0 14.0
660  Shoot             15  75  6.0 150.0 148.0 146.0
660  Shoot             34  125 6.0 44.0 42.0 40.0
660  Shoot             285 125 6.0 140.0 138.0 136.0
660  Shoot             304 75  6.0 34.0 32.0 30.0
670  Shoot             15  75  6.0 134.0 132.0 130.0
670  Shoot             34  125 6.0 60.0 58.0 56.0
670  Shoot             285 125 6.0 124.0 122.0 120.0
670  Shoot             304 75  6.0 50.0 48.0 46.0
680  Shoot             15  75  6.0 118.0 116.0 114.0
680  Shoot             34  125 6.0 76.0 74.0 72.0
680  Shoot             285 125 6.0 108.0 106.0 104.0
680  Shoot             304 75  6.0 66.0 64.0 62.0
690  Shoot             15  75  6.0 102.0 100.0 98.0
690  Shoot             34  125 6.0 92.0 90.0 88.0
690  Shoot             285 125 6.0 92.0 90.0 88.0
690  Shoot             304 75  6.0 82.0 80.0 78.0
700  Shoot             15  75  6.0 86.0 84.0 82.0
700  Shoot             34  125 6.0 108.0 106.0 104.0
700  Shoot             285 125 6.0 76.0 74.0 72.0
700  Shoot             304 75  6.0 98.0 96.0 94.0
710  Shoot             15  75  6.0 70.0 68.0 66.0
710  Shoot             34  125 6.0 124.0 122.0 120.0
710  Shoot             285 125 6.0 60.0 58.0 56.0
710  Shoot             304 75  6.0 114.0 112.0 110.0
720  Shoot             15  75  6.0 54.0 52.0 50.0
720  Shoot             34  125 6.0 140.0 138.0 136.0
720  Shoot             285 125 6.0 44.0 42.0 40.0
720  Shoot             304 75  6.0 130.0 128.0 126.0
730  Shoot             15  75  6.0 38.0 36.0 34.0
730  Shoot             34  125 6.0 156.0 154.0 152.0
730  Shoot             285 125 6.0 28.0 26.0 24.0
730  Shoot             304 75  6.0 146.0 144.0 142.0
740  Shoot             15  75  6.0 12.0 10.0 8.0
740  Shoot             34  125 6.0 182.0 180.0 178.0
740  Shoot             285 125 6.0 2.0 0.0 -2.0
740  Shoot             304 75  6.0 172.0 170.0 168.0
750  Shoot             15  75  6.0 28.0 26.0 24.0
750  Shoot             34  125 6.0 166.0 164.0 162.0
750  Shoot             285 125 6.0 18.0 16.0 14.0
750  Shoot             304 75  6.0 156.0 154.0 152.0
760  Shoot             15  75  6.0 44.0 42.0 40.0
760  Shoot             34  125 6.0 150.0 148.0 146.0
760  Shoot             285 125 6.0 34.0 32.0 30.0
760  Shoot             304 75  6.0 140.0 138.0 136.0
770  Shoot             15  75  6.0 60.0 58.0 56.0
770  Shoot             34  125 6.0 134.0 132.0 130.0
770  Shoot             285 125 6.0 50.0 48.0 46.0
770  Shoot             304 75  6.0 124.0 122.0 120.0
780  Shoot             15  75  6.0 76.0 74.0 72.0
780  Shoot             34  125 6.0 118.0 116.0 114.0
780  Shoot             285 125 6.0 66.0 64.0 62.0
780  Shoot             304 75  6.0 108.0 106.0 104.0
790  Shoot             15  75  6.0 92.0 90.0 88.0
790  Shoot             34  125 6.0 102.0 100.0 98.0
790  Shoot             285 125 6.0 82.0 80.0 78.0
790  Shoot             304 75  6.0 92.0 90.0 88.0
800  Shoot             15  75  6.0 108.0 106.0 104.0
800  Shoot             34  125 6.0 86.0 84.0 82.0
800  Shoot             285 125 6.0 98.0 96.0 94.0
800  Shoot             304 75  6.0 76.0 74.0 72.0
810  Shoot             15  75  6.0 124.0 122.0 120.0
810  Shoot             34  125 6.0 70.0 68.0 66.0
810  Shoot             285 125 6.0 114.0 112.0 110.0
810  Shoot             304 75  6.0 60.0 58.0 56.0
820  Shoot             15  75  6.0 140.0 138.0 136.0
820  Shoot             34  125 6.0 54.0 52.0 50.0
820  Shoot             285 125 6.0 130.0 128.0 126.0
820  Shoot             304 75  6.0 44.0 42.0 40.0
830  Shoot             15  75  6.0 156.0 154.0 152.0
830  Shoot             34  125 6.0 38.0 36.0 34.0
830  Shoot             285 125 6.0 146.0 144.0 142.0
830  Shoot             304 75  6.0 28.0 26.0 24.0
============Cmd4==========
1001 SetVelX           0.0
1001 SetVelY           0.0
============Cmd5==========
1190 SetVelX           2.0

1200 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1207 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1214 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1221 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1228 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1235 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1242 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1249 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1256 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1263 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 

1370 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1377 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1384 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1391 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1398 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1405 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1412 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1419 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1426 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1433 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 

1540 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1547 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1554 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1561 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1568 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1575 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1582 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1589 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1596 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1603 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 

===========Cmd6===========
1190 SetVelX           3.0
1200 ShootLaser        34  125 12.0
1200 ShootLaser        85  145 12.0
1200 ShootLaser        234 145 12.0
1200 ShootLaser        285 125 12.0
1224 ShootLaser        34  125 12.0
1224 ShootLaser        85  145 12.0
1224 ShootLaser        234 145 12.0
1224 ShootLaser        285 125 12.0
1248 ShootLaser        34  125 12.0
1248 ShootLaser        85  145 12.0
1248 ShootLaser        234 145 12.0
1248 ShootLaser        285 125 12.0
1272 ShootLaser        34  125 12.0
1272 ShootLaser        85  145 12.0
1272 ShootLaser        234 145 12.0
1272 ShootLaser        285 125 12.0
1296 ShootLaser        34  125 12.0
1296 ShootLaser        85  145 12.0
1296 ShootLaser        234 145 12.0
1296 ShootLaser        285 125 12.0
1320 ShootLaser        34  125 12.0
1320 ShootLaser        85  145 12.0
1320 ShootLaser        234 145 12.0
1320 ShootLaser        285 125 12.0
1344 ShootLaser        34  125 12.0
1344 ShootLaser        85  145 12.0
1344 ShootLaser        234 145 12.0
1344 ShootLaser        285 125 12.0
1368 ShootLaser        34  125 12.0
1368 ShootLaser        85  145 12.0
1368 ShootLaser        234 145 12.0
1368 ShootLaser        285 125 12.0
1392 ShootLaser        34  125 12.0
1392 ShootLaser        85  145 12.0
1392 ShootLaser        234 145 12.0
1392 ShootLaser        285 125 12.0
1416 ShootLaser        34  125 12.0
1416 ShootLaser        85  145 12.0
1416 ShootLaser        234 145 12.0
1416 ShootLaser        285 125 12.0
1440 ShootLaser        34  125 12.0
1440 ShootLaser        85  145 12.0
1440 ShootLaser        234 145 12.0
1440 ShootLaser        285 125 12.0
1464 ShootLaser        34  125 12.0
1464 ShootLaser        85  145 12.0
1464 ShootLaser        234 145 12.0
1464 ShootLaser        285 125 12.0
1488 ShootLaser        34  125 12.0
1488 ShootLaser        85  145 12.0
1488 ShootLaser        234 145 12.0
1488 ShootLaser        285 125 12.0
1512 ShootLaser        34  125 12.0
1512 ShootLaser        85  145 12.0
1512 ShootLaser        234 145 12.0
1512 ShootLaser        285 125 12.0
1536 ShootLaser        34  125 12.0
1536 ShootLaser        85  145 12.0
1536 ShootLaser        234 145 12.0
1536 ShootLaser        285 125 12.0
1560 ShootLaser        34  125 12.0
1560 ShootLaser        85  145 12.0
1560 ShootLaser        234 145 12.0
1560 ShootLaser        285 125 12.0
1584 ShootLaser        34  125 12.0
1584 ShootLaser        85  145 12.0
1584 ShootLaser        234 145 12.0
1584 ShootLaser        285 125 12.0
1608 ShootLaser        34  125 12.0
1608 ShootLaser        85  145 12.0
1608 ShootLaser        234 145 12.0
1608 ShootLaser        285 125 12.0
===========Cmd7===========
1190 SetVelX           2.0

1200 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1200 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1260 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1260 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1320 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1320 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1380 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1380 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1440 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1440 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1500 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1500 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1560 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1560 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1620 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1620 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0



===========Cmd8===========
1700 Charge            0
1700 SetVelX           0.0
1700 SetVelY           0.0

1740 ShootLaser        15  75  16.0
1740 ShootLaser        304 75  16.0
1746 ShootLaser        15  75  16.0
1746 ShootLaser        304 75  16.0
1752 ShootLaser        15  75  16.0
1752 ShootLaser        304 75  16.0
1758 ShootLaser        15  75  16.0
1758 ShootLaser        304 75  16.0
1764 ShootLaser        15  75  16.0
1764 ShootLaser        304 75  16.0
1770 ShootLaser        15  75  16.0
1770 ShootLaser        304 75  16.0
1776 ShootLaser        15  75  16.0
1776 ShootLaser        304 75  16.0
1782 ShootLaser        15  75  16.0
1782 ShootLaser        304 75  16.0
1788 ShootLaser        15  75  16.0
1788 ShootLaser        304 75  16.0
1794 ShootLaser        15  75  16.0
1794 ShootLaser        304 75  16.0
1800 ShootLaser        15  75  16.0
1800 ShootLaser        304 75  16.0
1806 ShootLaser        15  75  16.0
1806 ShootLaser        304 75  16.0
1812 ShootLaser        15  75  16.0
1812 ShootLaser        304 75  16.0
1818 ShootLaser        15  75  16.0
1818 ShootLaser        304 75  16.0
1824 ShootLaser        15  75  16.0
1824 ShootLaser        304 75  16.0
1830 ShootLaser        15  75  16.0
1830 ShootLaser        304 75  16.0
1836 ShootLaser        15  75  16.0
1836 ShootLaser        304 75  16.0
1842 ShootLaser        15  75  16.0
1842 ShootLaser        304 75  16.0
1848 ShootLaser        15  75  16.0
1848 ShootLaser        304 75  16.0
1854 ShootLaser        15  75  16.0
1854 ShootLaser        304 75  16.0
1860 ShootLaser        15  75  16.0
1860 ShootLaser        304 75  16.0
1866 ShootLaser        15  75  16.0
1866 ShootLaser        304 75  16.0
1872 ShootLaser        15  75  16.0
1872 ShootLaser        304 75  16.0
1878 ShootLaser        15  75  16.0
1878 ShootLaser        304 75  16.0
1884 ShootLaser        15  75  16.0
1884 ShootLaser        304 75  16.0
1890 ShootLaser        15  75  16.0
1890 ShootLaser        304 75  16.0
1896 ShootLaser        15  75  16.0
1896 ShootLaser        304 75  16.0
1902 ShootLaser        15  75  16.0
1902 ShootLaser        304 75  16.0
1908 ShootLaser        15  75  16.0
1908 ShootLaser        304 75  16.0
1914 ShootLaser        15  75  16.0
1914 ShootLaser        304 75  16.0
1920 ShootLaser        15  75  16.0
1920 ShootLaser        304 75  16.0
1926 ShootLaser        15  75  16.0
1926 ShootLaser        304 75  16.0
1932 ShootLaser        15  75  16.0
1932 ShootLaser        304 75  16.0
1938 ShootLaser        15  75  16.0
1938 ShootLaser        304 75  16.0
1944 ShootLaser        15  75  16.0
1944 ShootLaser        304 75  16.0
1950 ShootLaser        15  75  16.0
1950 ShootLaser        304 75  16.0
1956 ShootLaser        15  75  16.0
1956 ShootLaser        304 75  16.0
1962 ShootLaser        15  75  16.0
1962 ShootLaser        304 75  16.0
1968 ShootLaser        15  75  16.0
1968 ShootLaser        304 75  16.0
1974 ShootLaser        15  75  16.0
1974 ShootLaser        304 75  16.0
1980 ShootLaser        15  75  16.0
1980 ShootLaser        304 75  16.0
1986 ShootLaser        15  75  16.0
1986 ShootLaser        304 75  16.0
1992 ShootLaser        15  75  16.0
1992 ShootLaser        304 75  16.0
1998 ShootLaser        15  75  16.0
1998 ShootLaser        304 75  16.0
2004 ShootLaser        15  75  16.0
2004 ShootLaser        304 75  16.0
2010 ShootLaser        15  75  16.0
2010 ShootLaser        304 75  16.0
2016 ShootLaser        15  75  16.0
2016 ShootLaser        304 75  16.0
2022 ShootLaser        15  75  16.0
2022 ShootLaser        304 75  16.0
2028 ShootLaser        15  75  16.0
2028 ShootLaser        304 75  16.0
2034 ShootLaser        15  75  16.0
2034 ShootLaser        304 75  16.0

1740 ShootToPlayerRand 160 123 5.0 18.0 3
1750 ShootToPlayerRand 160 123 5.0 18.0 3
1760 ShootToPlayerRand 160 123 5.0 18.0 3
1770 ShootToPlayerRand 160 123 5.0 18.0 3
1780 ShootToPlayerRand 160 123 5.0 18.0 3
1790 ShootToPlayerRand 160 123 5.0 18.0 3
1800 ShootToPlayerRand 160 123 5.0 18.0 3
1810 ShootToPlayerRand 160 123 5.0 18.0 3
1820 ShootToPlayerRand 160 123 5.0 18.0 3
1830 ShootToPlayerRand 160 123 5.0 18.0 3
1840 ShootToPlayerRand 160 123 5.0 18.0 3
1850 ShootToPlayerRand 160 123 5.0 18.0 3
1860 ShootToPlayerRand 160 123 5.0 18.0 3
1870 ShootToPlayerRand 160 123 5.0 18.0 3
1880 ShootToPlayerRand 160 123 5.0 18.0 3
1890 ShootToPlayerRand 160 123 5.0 18.0 3
1900 ShootToPlayerRand 160 123 5.0 18.0 3
1910 ShootToPlayerRand 160 123 5.0 18.0 3
1920 ShootToPlayerRand 160 123 5.0 18.0 3
1930 ShootToPlayerRand 160 123 5.0 18.0 3
1940 ShootToPlayerRand 160 123 5.0 18.0 3
1950 ShootToPlayerRand 160 123 5.0 18.0 3
1960 ShootToPlayerRand 160 123 5.0 18.0 3
1970 ShootToPlayerRand 160 123 5.0 18.0 3
1980 ShootToPlayerRand 160 123 5.0 18.0 3
1990 ShootToPlayerRand 160 123 5.0 18.0 3
2000 ShootToPlayerRand 160 123 5.0 18.0 3
2010 ShootToPlayerRand 160 123 5.0 18.0 3
2020 ShootToPlayerRand 160 123 5.0 18.0 3
2030 ShootToPlayerRand 160 123 5.0 18.0 3
============Cmd9==========
2201 SetVelX           0.0
2201 SetVelY           0.0    
============Cmd10=========
2380 SetVelX            1.5

2380 ShootToPlayer     160 123 6.0 -60.0 -58.0 -56.0 -50.0 -48.0 -46.0 -40.0 -38.0 -36.0 -30.0 -28.0 -26.0 -20.0 -18.0 -16.0 -10.0 -8.0 -6.0 0.0 2.0 4.0 10.0 12.0 14.0 45.0 30.0 22.0 24.0 30.0 32.0 34.0 40.0 42.0 44.0 50.0 52.0 54.0 60.0 62.0 64.0 
2420 ShootToPlayer     160 123 6.0 -59.0 -57.0 -55.0 -49.0 -47.0 -45.0 -39.0 -37.0 -35.0 -29.0 -27.0 -25.0 -19.0 -17.0 -15.0 -9.0 -7.0 -5.0 1.0 3.0 5.0 11.0 13.0 15.0 21.0 23.0 25.0 31.0 33.0 35.0 41.0 43.0 45.0 51.0 53.0 55.0 61.0 63.0 65.0 
2460 ShootToPlayer     160 123 6.0 -59.0 -57.0 -55.0 -49.0 -47.0 -45.0 -39.0 -37.0 -35.0 -29.0 -27.0 -25.0 -19.0 -17.0 -15.0 -9.0 -7.0 -5.0 1.0 3.0 5.0 11.0 13.0 15.0 21.0 23.0 25.0 31.0 33.0 35.0 41.0 43.0 45.0 51.0 53.0 55.0 61.0 63.0 65.0 
2500 ShootToPlayer     160 123 6.0 -67.0 -65.0 -63.0 -57.0 -55.0 -53.0 -47.0 -45.0 -43.0 -37.0 -35.0 -33.0 -27.0 -25.0 -23.0 -17.0 -15.0 -13.0 -7.0 -5.0 -3.0 3.0 5.0 7.0 13.0 15.0 17.0 23.0 25.0 27.0 33.0 35.0 37.0 43.0 45.0 47.0 53.0 55.0 57.0 
2540 ShootToPlayer     160 123 6.0 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 
2580 ShootToPlayer     160 123 6.0 -63.0 -61.0 -59.0 -53.0 -51.0 -49.0 -43.0 -41.0 -39.0 -33.0 -31.0 -29.0 -23.0 -21.0 -19.0 -13.0 -11.0 -9.0 -3.0 -1.0 1.0 7.0 9.0 11.0 17.0 19.0 21.0 27.0 29.0 31.0 37.0 39.0 41.0 47.0 49.0 51.0 57.0 59.0 61.0 
2620 ShootToPlayer     160 123 6.0 -63.0 -61.0 -59.0 -53.0 -51.0 -49.0 -43.0 -41.0 -39.0 -33.0 -31.0 -29.0 -23.0 -21.0 -19.0 -13.0 -11.0 -9.0 -3.0 -1.0 1.0 7.0 9.0 11.0 17.0 19.0 21.0 27.0 29.0 31.0 37.0 39.0 41.0 47.0 49.0 51.0 57.0 59.0 61.0 
2660 ShootToPlayer     160 123 6.0 -58.0 -56.0 -54.0 -48.0 -46.0 -44.0 -38.0 -36.0 -34.0 -28.0 -26.0 -24.0 -18.0 -16.0 -14.0 -8.0 -6.0 -4.0 45.0 3.0 4.0 6.0 12.0 14.0 16.0 22.0 24.0 45.0 36.0 32.0 34.0 36.0 42.0 44.0 46.0 52.0 54.0 56.0 62.0 64.0 66.0 
2700 ShootToPlayer     160 123 6.0 -67.0 -65.0 -63.0 -57.0 -55.0 -53.0 -47.0 -45.0 -43.0 -37.0 -35.0 -33.0 -27.0 -25.0 -23.0 -17.0 -15.0 -13.0 -7.0 -5.0 -3.0 3.0 5.0 7.0 13.0 15.0 17.0 23.0 25.0 27.0 33.0 35.0 37.0 43.0 45.0 47.0 53.0 55.0 57.0 
2740 ShootToPlayer     160 123 6.0 -68.0 -66.0 -64.0 -58.0 -56.0 -54.0 -48.0 -46.0 -44.0 -38.0 -36.0 -34.0 -28.0 -26.0 -24.0 -18.0 -16.0 -14.0 -8.0 -6.0 -4.0 45.0 3.0 4.0 6.0 12.0 14.0 16.0 22.0 24.0 45.0 36.0 32.0 34.0 36.0 42.0 44.0 46.0 52.0 54.0 56.0 
2780 ShootToPlayer     160 123 6.0 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 
2820 ShootToPlayer     160 123 6.0 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 
============Cmd11=========
2380 SetVelX           1.5

2380 ShootToPlayerRand 15  75 4.0 45.0 2
2380 ShootToPlayerRand 304 75 4.0 45.0 2
2389 ShootToPlayerRand 15  75 4.0 45.0 2
2389 ShootToPlayerRand 304 75 4.0 45.0 2
2398 ShootToPlayerRand 15  75 4.0 45.0 2
2398 ShootToPlayerRand 304 75 4.0 45.0 2
2407 ShootToPlayerRand 15  75 4.0 45.0 2
2407 ShootToPlayerRand 304 75 4.0 45.0 2
2416 ShootToPlayerRand 15  75 4.0 45.0 2
2416 ShootToPlayerRand 304 75 4.0 45.0 2
2425  ShootToPlayerRand 15  75 4.0 45.0 2
2425  ShootToPlayerRand 304 75 4.0 45.0 2
2434  ShootToPlayerRand 15  75 4.0 45.0 2
2434  ShootToPlayerRand 304 75 4.0 45.0 2
2443  ShootToPlayerRand 15  75 4.0 45.0 2
2443  ShootToPlayerRand 304 75 4.0 45.0 2
2452  ShootToPlayerRand 15  75 4.0 45.0 2
2452  ShootToPlayerRand 304 75 4.0 45.0 2
2461  ShootToPlayerRand 15  75 4.0 45.0 2
2461  ShootToPlayerRand 304 75 4.0 45.0 2
2470  ShootToPlayerRand 15  75 4.0 45.0 2
2470  ShootToPlayerRand 304 75 4.0 45.0 2
2479  ShootToPlayerRand 15  75 4.0 45.0 2
2479  ShootToPlayerRand 304 75 4.0 45.0 2
2488  ShootToPlayerRand 15  75 4.0 45.0 2
2488  ShootToPlayerRand 304 75 4.0 45.0 2
2497  ShootToPlayerRand 15  75 4.0 45.0 2
2497  ShootToPlayerRand 304 75 4.0 45.0 2
2506  ShootToPlayerRand 15  75 4.0 45.0 2
2506  ShootToPlayerRand 304 75 4.0 45.0 2
2515  ShootToPlayerRand 15  75 4.0 45.0 2
2515  ShootToPlayerRand 304 75 4.0 45.0 2
2524  ShootToPlayerRand 15  75 4.0 45.0 2
2524  ShootToPlayerRand 304 75 4.0 45.0 2
2533  ShootToPlayerRand 15  75 4.0 45.0 2
2533  ShootToPlayerRand 304 75 4.0 45.0 2
2542  ShootToPlayerRand 15  75 4.0 45.0 2
2542  ShootToPlayerRand 304 75 4.0 45.0 2
2551  ShootToPlayerRand 15  75 4.0 45.0 2
2551  ShootToPlayerRand 304 75 4.0 45.0 2
2560  ShootToPlayerRand 15  75 4.0 45.0 2
2560  ShootToPlayerRand 304 75 4.0 45.0 2
2569  ShootToPlayerRand 15  75 4.0 45.0 2
2569  ShootToPlayerRand 304 75 4.0 45.0 2
2578  ShootToPlayerRand 15  75 4.0 45.0 2
2578  ShootToPlayerRand 304 75 4.0 45.0 2
2587  ShootToPlayerRand 15  75 4.0 45.0 2
2587  ShootToPlayerRand 304 75 4.0 45.0 2
2596  ShootToPlayerRand 15  75 4.0 45.0 2
2596  ShootToPlayerRand 304 75 4.0 45.0 2
2605  ShootToPlayerRand 15  75 4.0 45.0 2
2605  ShootToPlayerRand 304 75 4.0 45.0 2
2614  ShootToPlayerRand 15  75 4.0 45.0 2
2614  ShootToPlayerRand 304 75 4.0 45.0 2
2623  ShootToPlayerRand 15  75 4.0 45.0 2
2623  ShootToPlayerRand 304 75 4.0 45.0 2
2632  ShootToPlayerRand 15  75 4.0 45.0 2
2632  ShootToPlayerRand 304 75 4.0 45.0 2
2641  ShootToPlayerRand 15  75 4.0 45.0 2
2641  ShootToPlayerRand 304 75 4.0 45.0 2
2650  ShootToPlayerRand 15  75 4.0 45.0 2
2650  ShootToPlayerRand 304 75 4.0 45.0 2
2659  ShootToPlayerRand 15  75 4.0 45.0 2
2659  ShootToPlayerRand 304 75 4.0 45.0 2
2668  ShootToPlayerRand 15  75 4.0 45.0 2
2668  ShootToPlayerRand 304 75 4.0 45.0 2
2677  ShootToPlayerRand 15  75 4.0 45.0 2
2677  ShootToPlayerRand 304 75 4.0 45.0 2
2686  ShootToPlayerRand 15  75 4.0 45.0 2
2686  ShootToPlayerRand 304 75 4.0 45.0 2
2695  ShootToPlayerRand 15  75 4.0 45.0 2
2695  ShootToPlayerRand 304 75 4.0 45.0 2
2704  ShootToPlayerRand 15  75 4.0 45.0 2
2704  ShootToPlayerRand 304 75 4.0 45.0 2
2713  ShootToPlayerRand 15  75 4.0 45.0 2
2713  ShootToPlayerRand 304 75 4.0 45.0 2
2722  ShootToPlayerRand 15  75 4.0 45.0 2
2722  ShootToPlayerRand 304 75 4.0 45.0 2
2731  ShootToPlayerRand 15  75 4.0 45.0 2
2731  ShootToPlayerRand 304 75 4.0 45.0 2
2740  ShootToPlayerRand 15  75 4.0 45.0 2
2740  ShootToPlayerRand 304 75 4.0 45.0 2
2749  ShootToPlayerRand 15  75 4.0 45.0 2
2749  ShootToPlayerRand 304 75 4.0 45.0 2
2758  ShootToPlayerRand 15  75 4.0 45.0 2
2758  ShootToPlayerRand 304 75 4.0 45.0 2
2767  ShootToPlayerRand 15  75 4.0 45.0 2
2767  ShootToPlayerRand 304 75 4.0 45.0 2
2776  ShootToPlayerRand 15  75 4.0 45.0 2
2776  ShootToPlayerRand 304 75 4.0 45.0 2
2785  ShootToPlayerRand 15  75 4.0 45.0 2
2785  ShootToPlayerRand 304 75 4.0 45.0 2
2794  ShootToPlayerRand 15  75 4.0 45.0 2
2794  ShootToPlayerRand 304 75 4.0 45.0 2
2803  ShootToPlayerRand 15  75 4.0 45.0 2
2803  ShootToPlayerRand 304 75 4.0 45.0 2
2812  ShootToPlayerRand 15  75 4.0 45.0 2
2812  ShootToPlayerRand 304 75 4.0 45.0 2
============Cmd12=========
2900  SetVelX           0.0
2900  SetVelY           -2.0
2930  SetVelY           0.0
3000  SetVelY           6.0
3110  SetVelY           0.0  
3300  SetVelY           -6.0
3400  SetVelY           0.0

3010 Shoot             15  75 5.0 86.0 94.0
3010 Shoot             224 75 5.0 86.0 94.0
3013 Shoot             15  75 5.0 78.0 102.0
3013 Shoot             224 75 5.0 78.0 102.0
3016 Shoot             15  75 5.0 70.0 110.0
3016 Shoot             224 75 5.0 70.0 110.0
3019 Shoot             15  75 5.0 62.0 118.0
3019 Shoot             224 75 5.0 62.0 118.0
3022 Shoot             15  75 5.0 54.0 126.0
3022 Shoot             224 75 5.0 54.0 126.0
3025 Shoot             15  75 5.0 46.0 134.0
3025 Shoot             224 75 5.0 46.0 134.0
3028 Shoot             15  75 5.0 38.0 142.0
3028 Shoot             224 75 5.0 38.0 142.0
3031 Shoot             15  75 5.0 30.0 150.0
3031 Shoot             224 75 5.0 30.0 150.0
3034 Shoot             15  75 5.0 22.0 158.0
3034 Shoot             224 75 5.0 22.0 158.0
3037 Shoot             15  75 5.0 14.0 166.0
3037 Shoot             224 75 5.0 14.0 166.0
3040 Shoot             15  75 5.0 6.0 174.0
3040 Shoot             224 75 5.0 6.0 174.0
3043 Shoot             15  75 5.0 -2.0 182.0
3043 Shoot             224 75 5.0 -2.0 182.0
3046 Shoot             15  75 5.0 -10.0 190.0
3046 Shoot             224 75 5.0 -10.0 190.0
3049 Shoot             15  75 5.0 -18.0 198.0
3049 Shoot             224 75 5.0 -18.0 198.0
3052 Shoot             15  75 5.0 -26.0 206.0
3052 Shoot             224 75 5.0 -26.0 206.0
3055 Shoot             15  75 5.0 -34.0 214.0
3055 Shoot             224 75 5.0 -34.0 214.0
3058 Shoot             15  75 5.0 -42.0 222.0
3058 Shoot             224 75 5.0 -42.0 222.0
3061 Shoot             15  75 5.0 -50.0 230.0
3061 Shoot             224 75 5.0 -50.0 230.0
3064 Shoot             15  75 5.0 -58.0 238.0
3064 Shoot             224 75 5.0 -58.0 238.0
3067 Shoot             15  75 5.0 -66.0 246.0
3067 Shoot             224 75 5.0 -66.0 246.0
3070 Shoot             15  75 5.0 -74.0 254.0
3070 Shoot             224 75 5.0 -74.0 254.0
3073 Shoot             15  75 5.0 -82.0 262.0
3073 Shoot             224 75 5.0 -82.0 262.0
3076 Shoot             15  75 5.0 -90.0 270.0
3076 Shoot             224 75 5.0 -90.0 270.0

3016 Shoot             15  75 6.0 86.0 94.0
3016 Shoot             224 75 6.0 86.0 94.0
3019 Shoot             15  75 6.0 78.0 102.0
3019 Shoot             224 75 6.0 78.0 102.0
3022 Shoot             15  75 6.0 70.0 110.0
3022 Shoot             224 75 6.0 70.0 110.0
3025 Shoot             15  75 6.0 62.0 118.0
3025 Shoot             224 75 6.0 62.0 118.0
3028 Shoot             15  75 6.0 54.0 126.0
3028 Shoot             224 75 6.0 54.0 126.0
3031 Shoot             15  75 6.0 46.0 134.0
3031 Shoot             224 75 6.0 46.0 134.0
3034 Shoot             15  75 6.0 38.0 142.0
3034 Shoot             224 75 6.0 38.0 142.0
3037 Shoot             15  75 6.0 30.0 150.0
3037 Shoot             224 75 6.0 30.0 150.0
3040 Shoot             15  75 6.0 22.0 158.0
3040 Shoot             224 75 6.0 22.0 158.0
3043 Shoot             15  75 6.0 14.0 166.0
3043 Shoot             224 75 6.0 14.0 166.0
3046 Shoot             15  75 6.0 6.0 174.0
3046 Shoot             224 75 6.0 6.0 174.0
3049 Shoot             15  75 6.0 -2.0 182.0
3049 Shoot             224 75 6.0 -2.0 182.0
3052 Shoot             15  75 6.0 -10.0 190.0
3052 Shoot             224 75 6.0 -10.0 190.0
3055 Shoot             15  75 6.0 -18.0 198.0
3055 Shoot             224 75 6.0 -18.0 198.0
3058 Shoot             15  75 6.0 -26.0 206.0
3058 Shoot             224 75 6.0 -26.0 206.0
3061 Shoot             15  75 6.0 -34.0 214.0
3061 Shoot             224 75 6.0 -34.0 214.0
3064 Shoot             15  75 6.0 -42.0 222.0
3064 Shoot             224 75 6.0 -42.0 222.0
3067 Shoot             15  75 6.0 -50.0 230.0
3067 Shoot             224 75 6.0 -50.0 230.0
3070 Shoot             15  75 6.0 -58.0 238.0
3070 Shoot             224 75 6.0 -58.0 238.0
3073 Shoot             15  75 6.0 -66.0 246.0
3073 Shoot             224 75 6.0 -66.0 246.0
3076 Shoot             15  75 6.0 -74.0 254.0
3076 Shoot             224 75 6.0 -74.0 254.0
3079 Shoot             15  75 6.0 -82.0 262.0
3079 Shoot             224 75 6.0 -82.0 262.0
3082 Shoot             15  75 6.0 -90.0 270.0
3082 Shoot             224 75 6.0 -90.0 270.0


3300 Shoot             15  75 5.0 266.0 274.0
3300 Shoot             224 75 5.0 266.0 274.0
3303 Shoot             15  75 5.0 258.0 282.0
3303 Shoot             224 75 5.0 258.0 282.0
3306 Shoot             15  75 5.0 250.0 290.0
3306 Shoot             224 75 5.0 250.0 290.0
3309 Shoot             15  75 5.0 242.0 298.0
3309 Shoot             224 75 5.0 242.0 298.0
3312 Shoot             15  75 5.0 234.0 306.0
3312 Shoot             224 75 5.0 234.0 306.0
3315 Shoot             15  75 5.0 226.0 314.0
3315 Shoot             224 75 5.0 226.0 314.0
3318 Shoot             15  75 5.0 218.0 322.0
3318 Shoot             224 75 5.0 218.0 322.0
3321 Shoot             15  75 5.0 210.0 330.0
3321 Shoot             224 75 5.0 210.0 330.0
3324 Shoot             15  75 5.0 202.0 338.0
3324 Shoot             224 75 5.0 202.0 338.0
3327 Shoot             15  75 5.0 194.0 346.0
3327 Shoot             224 75 5.0 194.0 346.0
3330 Shoot             15  75 5.0 186.0 354.0
3330 Shoot             224 75 5.0 186.0 354.0
3333 Shoot             15  75 5.0 178.0 362.0
3333 Shoot             224 75 5.0 178.0 362.0
3336 Shoot             15  75 5.0 170.0 370.0
3336 Shoot             224 75 5.0 170.0 370.0
3339 Shoot             15  75 5.0 162.0 378.0
3339 Shoot             224 75 5.0 162.0 378.0
3342 Shoot             15  75 5.0 154.0 386.0
3342 Shoot             224 75 5.0 154.0 386.0
3345 Shoot             15  75 5.0 146.0 394.0
3345 Shoot             224 75 5.0 146.0 394.0
3348 Shoot             15  75 5.0 138.0 402.0
3348 Shoot             224 75 5.0 138.0 402.0
3351 Shoot             15  75 5.0 130.0 410.0
3351 Shoot             224 75 5.0 130.0 410.0
3354 Shoot             15  75 5.0 122.0 418.0
3354 Shoot             224 75 5.0 122.0 418.0
3357 Shoot             15  75 5.0 114.0 426.0
3357 Shoot             224 75 5.0 114.0 426.0
3360 Shoot             15  75 5.0 106.0 434.0
3360 Shoot             224 75 5.0 106.0 434.0
3363 Shoot             15  75 5.0 98.0 442.0
3363 Shoot             224 75 5.0 98.0 442.0
3366 Shoot             15  75 5.0 90.0 450.0
3366 Shoot             224 75 5.0 90.0 450.0

3306 Shoot             15  75 6.0 266.0 274.0
3306 Shoot             224 75 6.0 266.0 274.0
3309 Shoot             15  75 6.0 258.0 282.0
3309 Shoot             224 75 6.0 258.0 282.0
3312 Shoot             15  75 6.0 250.0 290.0
3312 Shoot             224 75 6.0 250.0 290.0
3315 Shoot             15  75 6.0 242.0 298.0
3315 Shoot             224 75 6.0 242.0 298.0
3318 Shoot             15  75 6.0 234.0 306.0
3318 Shoot             224 75 6.0 234.0 306.0
3321 Shoot             15  75 6.0 226.0 314.0
3321 Shoot             224 75 6.0 226.0 314.0
3324 Shoot             15  75 6.0 218.0 322.0
3324 Shoot             224 75 6.0 218.0 322.0
3327 Shoot             15  75 6.0 210.0 330.0
3327 Shoot             224 75 6.0 210.0 330.0
3330 Shoot             15  75 6.0 202.0 338.0
3330 Shoot             224 75 6.0 202.0 338.0
3333 Shoot             15  75 6.0 194.0 346.0
3333 Shoot             224 75 6.0 194.0 346.0
3336 Shoot             15  75 6.0 186.0 354.0
3336 Shoot             224 75 6.0 186.0 354.0
3339 Shoot             15  75 6.0 178.0 362.0
3339 Shoot             224 75 6.0 178.0 362.0
3342 Shoot             15  75 6.0 170.0 370.0
3342 Shoot             224 75 6.0 170.0 370.0
3345 Shoot             15  75 6.0 162.0 378.0
3345 Shoot             224 75 6.0 162.0 378.0
3348 Shoot             15  75 6.0 154.0 386.0
3348 Shoot             224 75 6.0 154.0 386.0
3351 Shoot             15  75 6.0 146.0 394.0
3351 Shoot             224 75 6.0 146.0 394.0
3354 Shoot             15  75 6.0 138.0 402.0
3354 Shoot             224 75 6.0 138.0 402.0
3357 Shoot             15  75 6.0 130.0 410.0
3357 Shoot             224 75 6.0 130.0 410.0
3360 Shoot             15  75 6.0 122.0 418.0
3360 Shoot             224 75 6.0 122.0 418.0
3363 Shoot             15  75 6.0 114.0 426.0
3363 Shoot             224 75 6.0 114.0 426.0
3366 Shoot             15  75 6.0 106.0 434.0
3366 Shoot             224 75 6.0 106.0 434.0
3369 Shoot             15  75 6.0 98.0 442.0
3369 Shoot             224 75 6.0 98.0 442.0
3372 Shoot             15  75 6.0 90.0 450.0
3372 Shoot             224 75 6.0 90.0 450.0


============Cmd13=========
3610 SetVelX           2.0

3620 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3627 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3634 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3641 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3648 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3655 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3662 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3669 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3676 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3683 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 

3790 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3797 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3804 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3811 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3818 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3825 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3832 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3839 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3846 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3853 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 

3960 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3967 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3974 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3981 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3988 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3995 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
4002 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
4009 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
4016 ShootToPlayer     160 123 8.0 -42.0 15-35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
4023 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 

===========Cmd14==========
3610 SetVelX           3.0
3620 ShootLaser        34  125 12.0
3620 ShootLaser        85  145 12.0
3620 ShootLaser        234 145 12.0
3620 ShootLaser        285 125 12.0
3644 ShootLaser        34  125 12.0
3644 ShootLaser        85  145 12.0
3644 ShootLaser        234 145 12.0
3644 ShootLaser        285 125 12.0
3668 ShootLaser        34  125 12.0
3668 ShootLaser        85  145 12.0
3668 ShootLaser        234 145 12.0
3668 ShootLaser        285 125 12.0
3692 ShootLaser        34  125 12.0
3692 ShootLaser        85  145 12.0
3692 ShootLaser        234 145 12.0
3692 ShootLaser        285 125 12.0
3716 ShootLaser        34  125 12.0
3716 ShootLaser        85  145 12.0
3716 ShootLaser        234 145 12.0
3716 ShootLaser        285 125 12.0
3740 ShootLaser        34  125 12.0
3740 ShootLaser        85  145 12.0
3740 ShootLaser        234 145 12.0
3740 ShootLaser        285 125 12.0
3764 ShootLaser        34  125 12.0
3764 ShootLaser        85  145 12.0
3764 ShootLaser        234 145 12.0
3764 ShootLaser        285 125 12.0
3788 ShootLaser        34  125 12.0
3788 ShootLaser        85  145 12.0
3788 ShootLaser        234 145 12.0
3788 ShootLaser        285 125 12.0
3812 ShootLaser        34  125 12.0
3812 ShootLaser        85  145 12.0
3812 ShootLaser        234 145 12.0
3812 ShootLaser        285 125 12.0
3836 ShootLaser        34  125 12.0
3836 ShootLaser        85  145 12.0
3836 ShootLaser        234 145 12.0
3836 ShootLaser        285 125 12.0
3860 ShootLaser        34  125 12.0
3860 ShootLaser        85  145 12.0
3860 ShootLaser        234 145 12.0
3860 ShootLaser        285 125 12.0
3884 ShootLaser        34  125 12.0
3884 ShootLaser        85  145 12.0
3884 ShootLaser        234 145 12.0
3884 ShootLaser        285 125 12.0
3908 ShootLaser        34  125 12.0
3908 ShootLaser        85  145 12.0
3908 ShootLaser        234 145 12.0
3908 ShootLaser        285 125 12.0
3932 ShootLaser        34  125 12.0
3932 ShootLaser        85  145 12.0
3932 ShootLaser        234 145 12.0
3932 ShootLaser        285 125 12.0
3956 ShootLaser        34  125 12.0
3956 ShootLaser        85  145 12.0
3956 ShootLaser        234 145 12.0
3956 ShootLaser        285 125 12.0
3980 ShootLaser        34  125 12.0
3980 ShootLaser        85  145 12.0
3980 ShootLaser        234 145 12.0
3980 ShootLaser        285 125 12.0
4004 ShootLaser        34  125 12.0
4004 ShootLaser        85  145 12.0
4004 ShootLaser        234 145 12.0
4004 ShootLaser        285 125 12.0
4028 ShootLaser        34  125 12.0
4028 ShootLaser        85  145 12.0
4028 ShootLaser        234 145 12.0
4028 ShootLaser        285 125 12.0
===========Cmd15==========
3610 SetVelX           2.0

3620 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3620 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3680 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3680 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3740 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3740 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3800 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3800 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3860 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3860 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3920 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3920 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3980 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3980 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
4040 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
4040 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0

===========Cmd16==========
3610 SetVelX           2.0

3620 ShootFlame        34  125 5.0 0.0
3620 ShootFlame        285 125 5.0 180.0
3623 ShootFlame        34  125 5.0 7.0
3623 ShootFlame        285 125 5.0 173.0
3626 ShootFlame        34  125 5.0 14.0
3626 ShootFlame        285 125 5.0 166.0
3629 ShootFlame        34  125 5.0 21.0
3629 ShootFlame        285 125 5.0 159.0
3632 ShootFlame        34  125 5.0 28.0
3632 ShootFlame        285 125 5.0 152.0
3635 ShootFlame        34  125 5.0 35.0
3635 ShootFlame        285 125 5.0 145.0
3638 ShootFlame        34  125 5.0 42.0
3638 ShootFlame        285 125 5.0 138.0
3641 ShootFlame        34  125 5.0 49.0
3641 ShootFlame        285 125 5.0 131.0
3644 ShootFlame        34  125 5.0 56.0
3644 ShootFlame        285 125 5.0 124.0
3647 ShootFlame        34  125 5.0 63.0
3647 ShootFlame        285 125 5.0 117.0
3650 ShootFlame        34  125 5.0 70.0
3650 ShootFlame        285 125 5.0 110.0
3653 ShootFlame        34  125 5.0 77.0
3653 ShootFlame        285 125 5.0 103.0
3656 ShootFlame        34  125 5.0 84.0
3656 ShootFlame        285 125 5.0 96.0
3659 ShootFlame        34  125 5.0 91.0
3659 ShootFlame        285 125 5.0 89.0
3662 ShootFlame        34  125 5.0 98.0
3662 ShootFlame        285 125 5.0 82.0
3665 ShootFlame        34  125 5.0 105.0
3665 ShootFlame        285 125 5.0 75.0
3668 ShootFlame        34  125 5.0 112.0
3668 ShootFlame        285 125 5.0 68.0
3671 ShootFlame        34  125 5.0 119.0
3671 ShootFlame        285 125 5.0 61.0
3674 ShootFlame        34  125 5.0 126.0
3674 ShootFlame        285 125 5.0 54.0
3677 ShootFlame        34  125 5.0 133.0
3677 ShootFlame        285 125 5.0 47.0
3680 ShootFlame        34  125 5.0 140.0
3680 ShootFlame        285 125 5.0 40.0
3683 ShootFlame        34  125 5.0 147.0
3683 ShootFlame        285 125 5.0 33.0
3686 ShootFlame        34  125 5.0 154.0
3686 ShootFlame        285 125 5.0 26.0
3689 ShootFlame        34  125 5.0 161.0
3689 ShootFlame        285 125 5.0 19.0
3692 ShootFlame        34  125 5.0 168.0
3692 ShootFlame        285 125 5.0 12.0
3695 ShootFlame        34  125 5.0 175.0
3695 ShootFlame        285 125 5.0 5.0
3698 ShootFlame        34  125 5.0 182.0
3698 ShootFlame        285 125 5.0 -2.0
3701 ShootFlame        34  125 5.0 189.0
3701 ShootFlame        285 125 5.0 -9.0
3704 ShootFlame        34  125 5.0 196.0
3704 ShootFlame        285 125 5.0 -16.0
3707 ShootFlame        34  125 5.0 203.0
3707 ShootFlame        285 125 5.0 -23.0
3710 ShootFlame        34  125 5.0 210.0
3710 ShootFlame        285 125 5.0 -30.0
3713 ShootFlame        34  125 5.0 217.0
3713 ShootFlame        285 125 5.0 -37.0
3716 ShootFlame        34  125 5.0 224.0
3716 ShootFlame        285 125 5.0 -44.0
3719 ShootFlame        34  125 5.0 231.0
3719 ShootFlame        285 125 5.0 -51.0
3722 ShootFlame        34  125 5.0 238.0
3722 ShootFlame        285 125 5.0 -58.0
3725 ShootFlame        34  125 5.0 245.0
3725 ShootFlame        285 125 5.0 -65.0
3728 ShootFlame        34  125 5.0 252.0
3728 ShootFlame        285 125 5.0 -72.0
3731 ShootFlame        34  125 5.0 259.0
3731 ShootFlame        285 125 5.0 -79.0
3734 ShootFlame        34  125 5.0 266.0
3734 ShootFlame        285 125 5.0 -86.0
3737 ShootFlame        34  125 5.0 273.0
3737 ShootFlame        285 125 5.0 -93.0
3740 ShootFlame        34  125 5.0 280.0
3740 ShootFlame        285 125 5.0 -100.0
3743 ShootFlame        34  125 5.0 287.0
3743 ShootFlame        285 125 5.0 -107.0
3746 ShootFlame        34  125 5.0 294.0
3746 ShootFlame        285 125 5.0 -114.0
3749 ShootFlame        34  125 5.0 301.0
3749 ShootFlame        285 125 5.0 -121.0
3752 ShootFlame        34  125 5.0 308.0
3752 ShootFlame        285 125 5.0 -128.0
3755 ShootFlame        34  125 5.0 315.0
3755 ShootFlame        285 125 5.0 -135.0
3758 ShootFlame        34  125 5.0 322.0
3758 ShootFlame        285 125 5.0 -142.0
3761 ShootFlame        34  125 5.0 329.0
3761 ShootFlame        285 125 5.0 -149.0
3764 ShootFlame        34  125 5.0 336.0
3764 ShootFlame        285 125 5.0 -156.0
3767 ShootFlame        34  125 5.0 343.0
3767 ShootFlame        285 125 5.0 -163.0
3770 ShootFlame        34  125 5.0 350.0
3770 ShootFlame        285 125 5.0 -170.0
3773 ShootFlame        34  125 5.0 357.0
3773 ShootFlame        285 125 5.0 -177.0
3776 ShootFlame        34  125 5.0 364.0
3776 ShootFlame        285 125 5.0 -184.0
3779 ShootFlame        34  125 5.0 371.0
3779 ShootFlame        285 125 5.0 -191.0
3782 ShootFlame        34  125 5.0 378.0
3782 ShootFlame        285 125 5.0 -198.0
3785 ShootFlame        34  125 5.0 385.0
3785 ShootFlame        285 125 5.0 -205.0
3788 ShootFlame        34  125 5.0 392.0
3788 ShootFlame        285 125 5.0 -212.0
3791 ShootFlame        34  125 5.0 399.0
3791 ShootFlame        285 125 5.0 -219.0
3794 ShootFlame        34  125 5.0 406.0
3794 ShootFlame        285 125 5.0 -226.0
3797 ShootFlame        34  125 5.0 413.0
3797 ShootFlame        285 125 5.0 -233.0
3800 ShootFlame        34  125 5.0 420.0
3800 ShootFlame        285 125 5.0 -240.0
3803 ShootFlame        34  125 5.0 427.0
3803 ShootFlame        285 125 5.0 -247.0
3806 ShootFlame        34  125 5.0 434.0
3806 ShootFlame        285 125 5.0 -254.0
3809 ShootFlame        34  125 5.0 441.0
3809 ShootFlame        285 125 5.0 -261.0
3812 ShootFlame        34  125 5.0 448.0
3812 ShootFlame        285 125 5.0 -268.0
3815 ShootFlame        34  125 5.0 455.0
3815 ShootFlame        285 125 5.0 -275.0
3818 ShootFlame        34  125 5.0 462.0
3818 ShootFlame        285 125 5.0 -282.0
3821 ShootFlame        34  125 5.0 469.0
3821 ShootFlame        285 125 5.0 -289.0
3824 ShootFlame        34  125 5.0 476.0
3824 ShootFlame        285 125 5.0 -296.0
3827 ShootFlame        34  125 5.0 483.0
3827 ShootFlame        285 125 5.0 -303.0
3830 ShootFlame        34  125 5.0 490.0
3830 ShootFlame        285 125 5.0 -310.0
3833 ShootFlame        34  125 5.0 497.0
3833 ShootFlame        285 125 5.0 -317.0
3836 ShootFlame        34  125 5.0 504.0
3836 ShootFlame        285 125 5.0 -324.0
3839 ShootFlame        34  125 5.0 511.0
3839 ShootFlame        285 125 5.0 -331.0
3842 ShootFlame        34  125 5.0 518.0
3842 ShootFlame        285 125 5.0 -338.0
3845 ShootFlame        34  125 5.0 525.0
3845 ShootFlame        285 125 5.0 -345.0
3848 ShootFlame        34  125 5.0 532.0
3848 ShootFlame        285 125 5.0 -352.0
3851 ShootFlame        34  125 5.0 539.0
3851 ShootFlame        285 125 5.0 -359.0
3854 ShootFlame        34  125 5.0 546.0
3854 ShootFlame        285 125 5.0 -366.0
3857 ShootFlame        34  125 5.0 553.0
3857 ShootFlame        285 125 5.0 -373.0
3860 ShootFlame        34  125 5.0 560.0
3860 ShootFlame        285 125 5.0 -380.0
3863 ShootFlame        34  125 5.0 567.0
3863 ShootFlame        285 125 5.0 -387.0
3866 ShootFlame        34  125 5.0 574.0
3866 ShootFlame        285 125 5.0 -394.0
3869 ShootFlame        34  125 5.0 581.0
3869 ShootFlame        285 125 5.0 -401.0
3872 ShootFlame        34  125 5.0 588.0
3872 ShootFlame        285 125 5.0 -408.0
3875 ShootFlame        34  125 5.0 595.0
3875 ShootFlame        285 125 5.0 -415.0
3878 ShootFlame        34  125 5.0 602.0
3878 ShootFlame        285 125 5.0 -422.0
3881 ShootFlame        34  125 5.0 609.0
3881 ShootFlame        285 125 5.0 -429.0
3884 ShootFlame        34  125 5.0 616.0
3884 ShootFlame        285 125 5.0 -436.0
3887 ShootFlame        34  125 5.0 623.0
3887 ShootFlame        285 125 5.0 -443.0
3890 ShootFlame        34  125 5.0 630.0
3890 ShootFlame        285 125 5.0 -450.0
3893 ShootFlame        34  125 5.0 637.0
3893 ShootFlame        285 125 5.0 -457.0
3896 ShootFlame        34  125 5.0 644.0
3896 ShootFlame        285 125 5.0 -464.0
3899 ShootFlame        34  125 5.0 651.0
3899 ShootFlame        285 125 5.0 -471.0
3902 ShootFlame        34  125 5.0 658.0
3902 ShootFlame        285 125 5.0 -478.0
3905 ShootFlame        34  125 5.0 665.0
3905 ShootFlame        285 125 5.0 -485.0
3908 ShootFlame        34  125 5.0 672.0
3908 ShootFlame        285 125 5.0 -492.0
3911 ShootFlame        34  125 5.0 679.0
3911 ShootFlame        285 125 5.0 -499.0
3914 ShootFlame        34  125 5.0 686.0
3914 ShootFlame        285 125 5.0 -506.0
3917 ShootFlame        34  125 5.0 693.0
3917 ShootFlame        285 125 5.0 -513.0
3920 ShootFlame        34  125 5.0 700.0
3920 ShootFlame        285 125 5.0 -520.0
3923 ShootFlame        34  125 5.0 707.0
3923 ShootFlame        285 125 5.0 -527.0
3926 ShootFlame        34  125 5.0 714.0
3926 ShootFlame        285 125 5.0 -534.0
3929 ShootFlame        34  125 5.0 721.0
3929 ShootFlame        285 125 5.0 -541.0
3932 ShootFlame        34  125 5.0 728.0
3932 ShootFlame        285 125 5.0 -548.0
3935 ShootFlame        34  125 5.0 735.0
3935 ShootFlame        285 125 5.0 -555.0
3938 ShootFlame        34  125 5.0 742.0
3938 ShootFlame        285 125 5.0 -562.0
3941 ShootFlame        34  125 5.0 749.0
3941 ShootFlame        285 125 5.0 -569.0
3944 ShootFlame        34  125 5.0 756.0
3944 ShootFlame        285 125 5.0 -576.0
3947 ShootFlame        34  125 5.0 763.0
3947 ShootFlame        285 125 5.0 -583.0
3950 ShootFlame        34  125 5.0 770.0
3950 ShootFlame        285 125 5.0 -590.0
3953 ShootFlame        34  125 5.0 777.0
3953 ShootFlame        285 125 5.0 -597.0
3956 ShootFlame        34  125 5.0 784.0
3956 ShootFlame        285 125 5.0 -604.0
3959 ShootFlame        34  125 5.0 791.0
3959 ShootFlame        285 125 5.0 -611.0
3962 ShootFlame        34  125 5.0 798.0
3962 ShootFlame        285 125 5.0 -618.0
3965 ShootFlame        34  125 5.0 805.0
3965 ShootFlame        285 125 5.0 -625.0
3968 ShootFlame        34  125 5.0 812.0
3968 ShootFlame        285 125 5.0 -632.0
3971 ShootFlame        34  125 5.0 819.0
3971 ShootFlame        285 125 5.0 -639.0
3974 ShootFlame        34  125 5.0 826.0
3974 ShootFlame        285 125 5.0 -646.0
3977 ShootFlame        34  125 5.0 833.0
3977 ShootFlame        285 125 5.0 -653.0
3980 ShootFlame        34  125 5.0 840.0
3980 ShootFlame        285 125 5.0 -660.0
3983 ShootFlame        34  125 5.0 847.0
3983 ShootFlame        285 125 5.0 -667.0
3986 ShootFlame        34  125 5.0 854.0
3986 ShootFlame        285 125 5.0 -674.0
3989 ShootFlame        34  125 5.0 861.0
3989 ShootFlame        285 125 5.0 -681.0
3992 ShootFlame        34  125 5.0 868.0
3992 ShootFlame        285 125 5.0 -688.0
3995 ShootFlame        34  125 5.0 875.0
3995 ShootFlame        285 125 5.0 -695.0
3998 ShootFlame        34  125 5.0 882.0
3998 ShootFlame        285 125 5.0 -702.0
4001 ShootFlame        34  125 5.0 889.0
4001 ShootFlame        285 125 5.0 -709.0
4004 ShootFlame        34  125 5.0 896.0
4004 ShootFlame        285 125 5.0 -716.0
4007 ShootFlame        34  125 5.0 903.0
4007 ShootFlame        285 125 5.0 -723.0
4010 ShootFlame        34  125 5.0 910.0
4010 ShootFlame        285 125 5.0 -730.0
4013 ShootFlame        34  125 5.0 917.0
4013 ShootFlame        285 125 5.0 -737.0
4016 ShootFlame        34  125 5.0 924.0
4016 ShootFlame        285 125 5.0 -744.0
4019 ShootFlame        34  125 5.0 931.0
4019 ShootFlame        285 125 5.0 -751.0
4022 ShootFlame        34  125 5.0 938.0
4022 ShootFlame        285 125 5.0 -758.0
4025 ShootFlame        34  125 5.0 945.0
4025 ShootFlame        285 125 5.0 -765.0
4028 ShootFlame        34  125 5.0 952.0
4028 ShootFlame        285 125 5.0 -772.0
4031 ShootFlame        34  125 5.0 959.0
4031 ShootFlame        285 125 5.0 -779.0
4034 ShootFlame        34  125 5.0 966.0
4034 ShootFlame        285 125 5.0 -786.0
4037 ShootFlame        34  125 5.0 973.0
4037 ShootFlame        285 125 5.0 -793.0

3620 ShootToPlayer     150 123 6.0 0.0
3620 ShootToPlayer     170 123 6.0 0.0
3620 ShootToPlayer     150 123 6.5 0.0
3620 ShootToPlayer     170 123 6.5 0.0
3620 ShootToPlayer     150 123 7.0 0.0
3620 ShootToPlayer     170 123 7.0 0.0

3670 ShootToPlayer     150 123 6.0 0.0
3670 ShootToPlayer     170 123 6.0 0.0
3670 ShootToPlayer     150 123 6.5 0.0
3670 ShootToPlayer     170 123 6.5 0.0
3670 ShootToPlayer     150 123 7.0 0.0
3670 ShootToPlayer     170 123 7.0 0.0

3720 ShootToPlayer     150 123 6.0 0.0
3720 ShootToPlayer     170 123 6.0 0.0
3720 ShootToPlayer     150 123 6.5 0.0
3720 ShootToPlayer     170 123 6.5 0.0
3720 ShootToPlayer     150 123 7.0 0.0
3720 ShootToPlayer     170 123 7.0 0.0

3770 ShootToPlayer     150 123 6.0 0.0
3770 ShootToPlayer     170 123 6.0 0.0
3770 ShootToPlayer     150 123 6.5 0.0
3770 ShootToPlayer     170 123 6.5 0.0
3770 ShootToPlayer     150 123 7.0 0.0
3770 ShootToPlayer     170 123 7.0 0.0

3820 ShootToPlayer     150 123 6.0 0.0
3820 ShootToPlayer     170 123 6.0 0.0
3820 ShootToPlayer     150 123 6.5 0.0
3820 ShootToPlayer     170 123 6.5 0.0
3820 ShootToPlayer     150 123 7.0 0.0
3820 ShootToPlayer     170 123 7.0 0.0

3870 ShootToPlayer     150 123 6.0 0.0
3870 ShootToPlayer     170 123 6.0 0.0
3870 ShootToPlayer     150 123 6.5 0.0
3870 ShootToPlayer     170 123 6.5 0.0
3870 ShootToPlayer     150 123 7.0 0.0
3870 ShootToPlayer     170 123 7.0 0.0

3920 ShootToPlayer     150 123 6.0 0.0
3920 ShootToPlayer     170 123 6.0 0.0
3920 ShootToPlayer     150 123 6.5 0.0
3920 ShootToPlayer     170 123 6.5 0.0
3920 ShootToPlayer     150 123 7.0 0.0
3920 ShootToPlayer     170 123 7.0 0.0

3970 ShootToPlayer     150 123 6.0 0.0
3970 ShootToPlayer     170 123 6.0 0.0
3970 ShootToPlayer     150 123 6.5 0.0
3970 ShootToPlayer     170 123 6.5 0.0
3970 ShootToPlayer     150 123 7.0 0.0
3970 ShootToPlayer     170 123 7.0 0.0
===========Cmd17==========
4160 SetVelX           0.0
4160 SetVelY           0.0
4160 Charge            0

4200 ShootToPlayer     15  75  16.0 68.0
4200 ShootToPlayer     34  125 16.0 -68.0
4200 ShootToPlayer     285 125 16.0 68.0
4200 ShootToPlayer     304 75  16.0 -68.0
4204 ShootToPlayer     15  75  16.0 66.0
4204 ShootToPlayer     34  125 16.0 -66.0
4204 ShootToPlayer     285 125 16.0 66.0
4204 ShootToPlayer     304 75  16.0 -66.0
4208 ShootToPlayer     15  75  16.0 64.0
4208 ShootToPlayer     34  125 16.0 -64.0
4208 ShootToPlayer     285 125 16.0 64.0
4208 ShootToPlayer     304 75  16.0 -64.0
4212 ShootToPlayer     15  75  16.0 62.0
4212 ShootToPlayer     34  125 16.0 -62.0
4212 ShootToPlayer     285 125 16.0 62.0
4212 ShootToPlayer     304 75  16.0 -62.0
4216 ShootToPlayer     15  75  16.0 60.0
4216 ShootToPlayer     34  125 16.0 -60.0
4216 ShootToPlayer     285 125 16.0 60.0
4216 ShootToPlayer     304 75  16.0 -60.0
4220 ShootToPlayer     15  75  16.0 58.0
4220 ShootToPlayer     34  125 16.0 -58.0
4220 ShootToPlayer     285 125 16.0 58.0
4220 ShootToPlayer     304 75  16.0 -58.0
4224 ShootToPlayer     15  75  16.0 56.0
4224 ShootToPlayer     34  125 16.0 -56.0
4224 ShootToPlayer     285 125 16.0 56.0
4224 ShootToPlayer     304 75  16.0 -56.0
4228 ShootToPlayer     15  75  16.0 54.0
4228 ShootToPlayer     34  125 16.0 -54.0
4228 ShootToPlayer     285 125 16.0 54.0
4228 ShootToPlayer     304 75  16.0 -54.0
4232 ShootToPlayer     15  75  16.0 52.0
4232 ShootToPlayer     34  125 16.0 -52.0
4232 ShootToPlayer     285 125 16.0 52.0
4232 ShootToPlayer     304 75  16.0 -52.0
4236 ShootToPlayer     15  75  16.0 50.0
4236 ShootToPlayer     34  125 16.0 -50.0
4236 ShootToPlayer     285 125 16.0 50.0
4236 ShootToPlayer     304 75  16.0 -50.0
4240 ShootToPlayer     15  75  16.0 48.0
4240 ShootToPlayer     34  125 16.0 -48.0
4240 ShootToPlayer     285 125 16.0 48.0
4240 ShootToPlayer     304 75  16.0 -48.0
4244 ShootToPlayer     15  75  16.0 46.0
4244 ShootToPlayer     34  125 16.0 -46.0
4244 ShootToPlayer     285 125 16.0 46.0
4244 ShootToPlayer     304 75  16.0 -46.0
4248 ShootToPlayer     15  75  16.0 44.0
4248 ShootToPlayer     34  125 16.0 -44.0
4248 ShootToPlayer     285 125 16.0 44.0
4248 ShootToPlayer     304 75  16.0 -44.0
4252 ShootToPlayer     15  75  16.0 42.0
4252 ShootToPlayer     34  125 16.0 -42.0
4252 ShootToPlayer     285 125 16.0 42.0
4252 ShootToPlayer     304 75  16.0 -42.0
4256 ShootToPlayer     15  75  16.0 40.0
4256 ShootToPlayer     34  125 16.0 -40.0
4256 ShootToPlayer     285 125 16.0 40.0
4256 ShootToPlayer     304 75  16.0 -40.0
4260 ShootToPlayer     15  75  16.0 38.0
4260 ShootToPlayer     34  125 16.0 -38.0
4260 ShootToPlayer     285 125 16.0 38.0
4260 ShootToPlayer     304 75  16.0 -38.0
4264 ShootToPlayer     15  75  16.0 36.0
4264 ShootToPlayer     34  125 16.0 -36.0
4264 ShootToPlayer     285 125 16.0 36.0
4264 ShootToPlayer     304 75  16.0 -36.0
4268 ShootToPlayer     15  75  16.0 34.0
4268 ShootToPlayer     34  125 16.0 -34.0
4268 ShootToPlayer     285 125 16.0 34.0
4268 ShootToPlayer     304 75  16.0 -34.0
4272 ShootToPlayer     15  75  16.0 32.0
4272 ShootToPlayer     34  125 16.0 -32.0
4272 ShootToPlayer     285 125 16.0 32.0
4272 ShootToPlayer     304 75  16.0 -32.0
4276 ShootToPlayer     15  75  16.0 30.0
4276 ShootToPlayer     34  125 16.0 -30.0
4276 ShootToPlayer     285 125 16.0 30.0
4276 ShootToPlayer     304 75  16.0 -30.0
4280 ShootToPlayer     15  75  16.0 28.0
4280 ShootToPlayer     34  125 16.0 -28.0
4280 ShootToPlayer     285 125 16.0 28.0
4280 ShootToPlayer     304 75  16.0 -28.0
4284 ShootToPlayer     15  75  16.0 26.0
4284 ShootToPlayer     34  125 16.0 -26.0
4284 ShootToPlayer     285 125 16.0 26.0
4284 ShootToPlayer     304 75  16.0 -26.0
4288 ShootToPlayer     15  75  16.0 24.0
4288 ShootToPlayer     34  125 16.0 -24.0
4288 ShootToPlayer     285 125 16.0 24.0
4288 ShootToPlayer     304 75  16.0 -24.0
4292 ShootToPlayer     15  75  16.0 22.0
4292 ShootToPlayer     34  125 16.0 -22.0
4292 ShootToPlayer     285 125 16.0 22.0
4292 ShootToPlayer     304 75  16.0 -22.0
4296 ShootToPlayer     15  75  16.0 20.0
4296 ShootToPlayer     34  125 16.0 -20.0
4296 ShootToPlayer     285 125 16.0 20.0
4296 ShootToPlayer     304 75  16.0 -20.0
4300 ShootToPlayer     15  75  16.0 18.0
4300 ShootToPlayer     34  125 16.0 -18.0
4300 ShootToPlayer     285 125 16.0 18.0
4300 ShootToPlayer     304 75  16.0 -18.0
4304 ShootToPlayer     15  75  16.0 16.0
4304 ShootToPlayer     34  125 16.0 -16.0
4304 ShootToPlayer     285 125 16.0 16.0
4304 ShootToPlayer     304 75  16.0 -16.0
4308 ShootToPlayer     15  75  16.0 14.0
4308 ShootToPlayer     34  125 16.0 -14.0
4308 ShootToPlayer     285 125 16.0 14.0
4308 ShootToPlayer     304 75  16.0 -14.0
4312 ShootToPlayer     15  75  16.0 12.0
4312 ShootToPlayer     34  125 16.0 -12.0
4312 ShootToPlayer     285 125 16.0 12.0
4312 ShootToPlayer     304 75  16.0 -12.0
4316 ShootToPlayer     15  75  16.0 10.0
4316 ShootToPlayer     34  125 16.0 -10.0
4316 ShootToPlayer     285 125 16.0 10.0
4316 ShootToPlayer     304 75  16.0 -10.0

4320 ShootToPlayer     15  75  16.0 8.0
4320 ShootToPlayer     34  125 16.0 -8.0
4320 ShootToPlayer     285 125 16.0 8.0
4320 ShootToPlayer     304 75  16.0 -8.0
4324 ShootToPlayer     15  75  16.0 8.0
4324 ShootToPlayer     34  125 16.0 -8.0
4324 ShootToPlayer     285 125 16.0 8.0
4324 ShootToPlayer     304 75  16.0 -8.0
4328 ShootToPlayer     15  75  16.0 8.0
4328 ShootToPlayer     34  125 16.0 -8.0
4328 ShootToPlayer     285 125 16.0 8.0
4328 ShootToPlayer     304 75  16.0 -8.0
4332 ShootToPlayer     15  75  16.0 8.0
4332 ShootToPlayer     34  125 16.0 -8.0
4332 ShootToPlayer     285 125 16.0 8.0
4332 ShootToPlayer     304 75  16.0 -8.0
4336 ShootToPlayer     15  75  16.0 8.0
4336 ShootToPlayer     34  125 16.0 -8.0
4336 ShootToPlayer     285 125 16.0 8.0
4336 ShootToPlayer     304 75  16.0 -8.0
4340 ShootToPlayer     15  75  16.0 8.0
4340 ShootToPlayer     34  125 16.0 -8.0
4340 ShootToPlayer     285 125 16.0 8.0
4340 ShootToPlayer     304 75  16.0 -8.0
4344 ShootToPlayer     15  75  16.0 8.0
4344 ShootToPlayer     34  125 16.0 -8.0
4344 ShootToPlayer     285 125 16.0 8.0
4344 ShootToPlayer     304 75  16.0 -8.0
4348 ShootToPlayer     15  75  16.0 8.0
4348 ShootToPlayer     34  125 16.0 -8.0
4348 ShootToPlayer     285 125 16.0 8.0
4348 ShootToPlayer     304 75  16.0 -8.0
4352 ShootToPlayer     15  75  16.0 8.0
4352 ShootToPlayer     34  125 16.0 -8.0
4352 ShootToPlayer     285 125 16.0 8.0
4352 ShootToPlayer     304 75  16.0 -8.0
4356 ShootToPlayer     15  75  16.0 8.0
4356 ShootToPlayer     34  125 16.0 -8.0
4356 ShootToPlayer     285 125 16.0 8.0
4356 ShootToPlayer     304 75  16.0 -8.0
4360 ShootToPlayer     15  75  16.0 8.0
4360 ShootToPlayer     34  125 16.0 -8.0
4360 ShootToPlayer     285 125 16.0 8.0
4360 ShootToPlayer     304 75  16.0 -8.0
4364 ShootToPlayer     15  75  16.0 8.0
4364 ShootToPlayer     34  125 16.0 -8.0
4364 ShootToPlayer     285 125 16.0 8.0
4364 ShootToPlayer     304 75  16.0 -8.0
4368 ShootToPlayer     15  75  16.0 8.0
4368 ShootToPlayer     34  125 16.0 -8.0
4368 ShootToPlayer     285 125 16.0 8.0
4368 ShootToPlayer     304 75  16.0 -8.0
4372 ShootToPlayer     15  75  16.0 8.0
4372 ShootToPlayer     34  125 16.0 -8.0
4372 ShootToPlayer     285 125 16.0 8.0
4372 ShootToPlayer     304 75  16.0 -8.0
4376 ShootToPlayer     15  75  16.0 8.0
4376 ShootToPlayer     34  125 16.0 -8.0
4376 ShootToPlayer     285 125 16.0 8.0
4376 ShootToPlayer     304 75  16.0 -8.0
4380 ShootToPlayer     15  75  16.0 8.0
4380 ShootToPlayer     34  125 16.0 -8.0
4380 ShootToPlayer     285 125 16.0 8.0
4380 ShootToPlayer     304 75  16.0 -8.0
4384 ShootToPlayer     15  75  16.0 8.0
4384 ShootToPlayer     34  125 16.0 -8.0
4384 ShootToPlayer     285 125 16.0 8.0
4384 ShootToPlayer     304 75  16.0 -8.0
4388 ShootToPlayer     15  75  16.0 8.0
4388 ShootToPlayer     34  125 16.0 -8.0
4388 ShootToPlayer     285 125 16.0 8.0
4388 ShootToPlayer     304 75  16.0 -8.0
4392 ShootToPlayer     15  75  16.0 8.0
4392 ShootToPlayer     34  125 16.0 -8.0
4392 ShootToPlayer     285 125 16.0 8.0
4392 ShootToPlayer     304 75  16.0 -8.0
4396 ShootToPlayer     15  75  16.0 8.0
4396 ShootToPlayer     34  125 16.0 -8.0
4396 ShootToPlayer     285 125 16.0 8.0
4396 ShootToPlayer     304 75  16.0 -8.0
4400 ShootToPlayer     15  75  16.0 8.0
4400 ShootToPlayer     34  125 16.0 -8.0
4400 ShootToPlayer     285 125 16.0 8.0
4400 ShootToPlayer     304 75  16.0 -8.0
4404 ShootToPlayer     15  75  16.0 8.0
4404 ShootToPlayer     34  125 16.0 -8.0
4404 ShootToPlayer     285 125 16.0 8.0
4404 ShootToPlayer     304 75  16.0 -8.0
4408 ShootToPlayer     15  75  16.0 8.0
4408 ShootToPlayer     34  125 16.0 -8.0
4408 ShootToPlayer     285 125 16.0 8.0
4408 ShootToPlayer     304 75  16.0 -8.0
4412 ShootToPlayer     15  75  16.0 8.0
4412 ShootToPlayer     34  125 16.0 -8.0
4412 ShootToPlayer     285 125 16.0 8.0
4412 ShootToPlayer     304 75  16.0 -8.0
4416 ShootToPlayer     15  75  16.0 8.0
4416 ShootToPlayer     34  125 16.0 -8.0
4416 ShootToPlayer     285 125 16.0 8.0
4416 ShootToPlayer     304 75  16.0 -8.0
4420 ShootToPlayer     15  75  16.0 8.0
4420 ShootToPlayer     34  125 16.0 -8.0
4420 ShootToPlayer     285 125 16.0 8.0
4420 ShootToPlayer     304 75  16.0 -8.0
4424 ShootToPlayer     15  75  16.0 8.0
4424 ShootToPlayer     34  125 16.0 -8.0
4424 ShootToPlayer     285 125 16.0 8.0
4424 ShootToPlayer     304 75  16.0 -8.0
4428 ShootToPlayer     15  75  16.0 8.0
4428 ShootToPlayer     34  125 16.0 -8.0
4428 ShootToPlayer     285 125 16.0 8.0
4428 ShootToPlayer     304 75  16.0 -8.0
4432 ShootToPlayer     15  75  16.0 8.0
4432 ShootToPlayer     34  125 16.0 -8.0
4432 ShootToPlayer     285 125 16.0 8.0
4432 ShootToPlayer     304 75  16.0 -8.0
4436 ShootToPlayer     15  75  16.0 8.0
4436 ShootToPlayer     34  125 16.0 -8.0
4436 ShootToPlayer     285 125 16.0 8.0
4436 ShootToPlayer     304 75  16.0 -8.0
4440 ShootToPlayer     15  75  16.0 8.0
4440 ShootToPlayer     34  125 16.0 -8.0
4440 ShootToPlayer     285 125 16.0 8.0
4440 ShootToPlayer     304 75  16.0 -8.0
4444 ShootToPlayer     15  75  16.0 8.0
4444 ShootToPlayer     34  125 16.0 -8.0
4444 ShootToPlayer     285 125 16.0 8.0
4444 ShootToPlayer     304 75  16.0 -8.0
4448 ShootToPlayer     15  75  16.0 8.0
4448 ShootToPlayer     34  125 16.0 -8.0
4448 ShootToPlayer     285 125 16.0 8.0
4448 ShootToPlayer     304 75  16.0 -8.0
4452 ShootToPlayer     15  75  16.0 8.0
4452 ShootToPlayer     34  125 16.0 -8.0
4452 ShootToPlayer     285 125 16.0 8.0
4452 ShootToPlayer     304 75  16.0 -8.0
4456 ShootToPlayer     15  75  16.0 8.0
4456 ShootToPlayer     34  125 16.0 -8.0
4456 ShootToPlayer     285 125 16.0 8.0
4456 ShootToPlayer     304 75  16.0 -8.0
4460 ShootToPlayer     15  75  16.0 8.0
4460 ShootToPlayer     34  125 16.0 -8.0
4460 ShootToPlayer     285 125 16.0 8.0
4460 ShootToPlayer     304 75  16.0 -8.0
4464 ShootToPlayer     15  75  16.0 8.0
4464 ShootToPlayer     34  125 16.0 -8.0
4464 ShootToPlayer     285 125 16.0 8.0
4464 ShootToPlayer     304 75  16.0 -8.0
4468 ShootToPlayer     15  75  16.0 8.0
4468 ShootToPlayer     34  125 16.0 -8.0
4468 ShootToPlayer     285 125 16.0 8.0
4468 ShootToPlayer     304 75  16.0 -8.0
4472 ShootToPlayer     15  75  16.0 8.0
4472 ShootToPlayer     34  125 16.0 -8.0
4472 ShootToPlayer     285 125 16.0 8.0
4472 ShootToPlayer     304 75  16.0 -8.0
4476 ShootToPlayer     15  75  16.0 8.0
4476 ShootToPlayer     34  125 16.0 -8.0
4476 ShootToPlayer     285 125 16.0 8.0
4476 ShootToPlayer     304 75  16.0 -8.0
4480 ShootToPlayer     15  75  16.0 8.0
4480 ShootToPlayer     34  125 16.0 -8.0
4480 ShootToPlayer     285 125 16.0 8.0
4480 ShootToPlayer     304 75  16.0 -8.0
4484 ShootToPlayer     15  75  16.0 8.0
4484 ShootToPlayer     34  125 16.0 -8.0
4484 ShootToPlayer     285 125 16.0 8.0
4484 ShootToPlayer     304 75  16.0 -8.0
4488 ShootToPlayer     15  75  16.0 8.0
4488 ShootToPlayer     34  125 16.0 -8.0
4488 ShootToPlayer     285 125 16.0 8.0
4488 ShootToPlayer     304 75  16.0 -8.0
4492 ShootToPlayer     15  75  16.0 8.0
4492 ShootToPlayer     34  125 16.0 -8.0
4492 ShootToPlayer     285 125 16.0 8.0
4492 ShootToPlayer     304 75  16.0 -8.0
4496 ShootToPlayer     15  75  16.0 8.0
4496 ShootToPlayer     34  125 16.0 -8.0
4496 ShootToPlayer     285 125 16.0 8.0
4496 ShootToPlayer     304 75  16.0 -8.0
4500 ShootToPlayer     15  75  16.0 8.0
4500 ShootToPlayer     34  125 16.0 -8.0
4500 ShootToPlayer     285 125 16.0 8.0
4500 ShootToPlayer     304 75  16.0 -8.0
4504 ShootToPlayer     15  75  16.0 8.0
4504 ShootToPlayer     34  125 16.0 -8.0
4504 ShootToPlayer     285 125 16.0 8.0
4504 ShootToPlayer     304 75  16.0 -8.0
4508 ShootToPlayer     15  75  16.0 8.0
4508 ShootToPlayer     34  125 16.0 -8.0
4508 ShootToPlayer     285 125 16.0 8.0
4508 ShootToPlayer     304 75  16.0 -8.0
4512 ShootToPlayer     15  75  16.0 8.0
4512 ShootToPlayer     34  125 16.0 -8.0
4512 ShootToPlayer     285 125 16.0 8.0
4512 ShootToPlayer     304 75  16.0 -8.0
4516 ShootToPlayer     15  75  16.0 8.0
4516 ShootToPlayer     34  125 16.0 -8.0
4516 ShootToPlayer     285 125 16.0 8.0
4516 ShootToPlayer     304 75  16.0 -8.0
4520 ShootToPlayer     15  75  16.0 8.0
4520 ShootToPlayer     34  125 16.0 -8.0
4520 ShootToPlayer     285 125 16.0 8.0
4520 ShootToPlayer     304 75  16.0 -8.0
4524 ShootToPlayer     15  75  16.0 8.0
4524 ShootToPlayer     34  125 16.0 -8.0
4524 ShootToPlayer     285 125 16.0 8.0
4524 ShootToPlayer     304 75  16.0 -8.0
4528 ShootToPlayer     15  75  16.0 8.0
4528 ShootToPlayer     34  125 16.0 -8.0
4528 ShootToPlayer     285 125 16.0 8.0
4528 ShootToPlayer     304 75  16.0 -8.0
4532 ShootToPlayer     15  75  16.0 8.0
4532 ShootToPlayer     34  125 16.0 -8.0
4532 ShootToPlayer     285 125 16.0 8.0
4532 ShootToPlayer     304 75  16.0 -8.0
4536 ShootToPlayer     15  75  16.0 8.0
4536 ShootToPlayer     34  125 16.0 -8.0
4536 ShootToPlayer     285 125 16.0 8.0
4536 ShootToPlayer     304 75  16.0 -8.0
4540 ShootToPlayer     15  75  16.0 8.0
4540 ShootToPlayer     34  125 16.0 -8.0
4540 ShootToPlayer     285 125 16.0 8.0
4540 ShootToPlayer     304 75  16.0 -8.0
4544 ShootToPlayer     15  75  16.0 8.0
4544 ShootToPlayer     34  125 16.0 -8.0
4544 ShootToPlayer     285 125 16.0 8.0
4544 ShootToPlayer     304 75  16.0 -8.0
4548 ShootToPlayer     15  75  16.0 8.0
4548 ShootToPlayer     34  125 16.0 -8.0
4548 ShootToPlayer     285 125 16.0 8.0
4548 ShootToPlayer     304 75  16.0 -8.0
4552 ShootToPlayer     15  75  16.0 8.0
4552 ShootToPlayer     34  125 16.0 -8.0
4552 ShootToPlayer     285 125 16.0 8.0
4552 ShootToPlayer     304 75  16.0 -8.0
4556 ShootToPlayer     15  75  16.0 8.0
4556 ShootToPlayer     34  125 16.0 -8.0
4556 ShootToPlayer     285 125 16.0 8.0
4556 ShootToPlayer     304 75  16.0 -8.0
4560 ShootToPlayer     15  75  16.0 8.0
4560 ShootToPlayer     34  125 16.0 -8.0
4560 ShootToPlayer     285 125 16.0 8.0
4560 ShootToPlayer     304 75  16.0 -8.0
4564 ShootToPlayer     15  75  16.0 8.0
4564 ShootToPlayer     34  125 16.0 -8.0
4564 ShootToPlayer     285 125 16.0 8.0
4564 ShootToPlayer     304 75  16.0 -8.0
4568 ShootToPlayer     15  75  16.0 8.0
4568 ShootToPlayer     34  125 16.0 -8.0
4568 ShootToPlayer     285 125 16.0 8.0
4568 ShootToPlayer     304 75  16.0 -8.0
4572 ShootToPlayer     15  75  16.0 8.0
4572 ShootToPlayer     34  125 16.0 -8.0
4572 ShootToPlayer     285 125 16.0 8.0
4572 ShootToPlayer     304 75  16.0 -8.0
4576 ShootToPlayer     15  75  16.0 8.0
4576 ShootToPlayer     34  125 16.0 -8.0
4576 ShootToPlayer     285 125 16.0 8.0
4576 ShootToPlayer     304 75  16.0 -8.0
4580 ShootToPlayer     15  75  16.0 8.0
4580 ShootToPlayer     34  125 16.0 -8.0
4580 ShootToPlayer     285 125 16.0 8.0
4580 ShootToPlayer     304 75  16.0 -8.0
4584 ShootToPlayer     15  75  16.0 8.0
4584 ShootToPlayer     34  125 16.0 -8.0
4584 ShootToPlayer     285 125 16.0 8.0
4584 ShootToPlayer     304 75  16.0 -8.0
4588 ShootToPlayer     15  75  16.0 8.0
4588 ShootToPlayer     34  125 16.0 -8.0
4588 ShootToPlayer     285 125 16.0 8.0
4588 ShootToPlayer     304 75  16.0 -8.0
4592 ShootToPlayer     15  75  16.0 8.0
4592 ShootToPlayer     34  125 16.0 -8.0
4592 ShootToPlayer     285 125 16.0 8.0
4592 ShootToPlayer     304 75  16.0 -8.0
4596 ShootToPlayer     15  75  16.0 8.0
4596 ShootToPlayer     34  125 16.0 -8.0
4596 ShootToPlayer     285 125 16.0 8.0
4596 ShootToPlayer     304 75  16.0 -8.0
4600 ShootToPlayer     15  75  16.0 8.0
4600 ShootToPlayer     34  125 16.0 -8.0
4600 ShootToPlayer     285 125 16.0 8.0
4600 ShootToPlayer     304 75  16.0 -8.0
4604 ShootToPlayer     15  75  16.0 8.0
4604 ShootToPlayer     34  125 16.0 -8.0
4604 ShootToPlayer     285 125 16.0 8.0
4604 ShootToPlayer     304 75  16.0 -8.0
4608 ShootToPlayer     15  75  16.0 8.0
4608 ShootToPlayer     34  125 16.0 -8.0
4608 ShootToPlayer     285 125 16.0 8.0
4608 ShootToPlayer     304 75  16.0 -8.0
4612 ShootToPlayer     15  75  16.0 8.0
4612 ShootToPlayer     34  125 16.0 -8.0
4612 ShootToPlayer     285 125 16.0 8.0
4612 ShootToPlayer     304 75  16.0 -8.0
4616 ShootToPlayer     15  75  16.0 8.0
4616 ShootToPlayer     34  125 16.0 -8.0
4616 ShootToPlayer     285 125 16.0 8.0
4616 ShootToPlayer     304 75  16.0 -8.0
4620 ShootToPlayer     15  75  16.0 8.0
4620 ShootToPlayer     34  125 16.0 -8.0
4620 ShootToPlayer     285 125 16.0 8.0
4620 ShootToPlayer     304 75  16.0 -8.0
4624 ShootToPlayer     15  75  16.0 8.0
4624 ShootToPlayer     34  125 16.0 -8.0
4624 ShootToPlayer     285 125 16.0 8.0
4624 ShootToPlayer     304 75  16.0 -8.0
4628 ShootToPlayer     15  75  16.0 8.0
4628 ShootToPlayer     34  125 16.0 -8.0
4628 ShootToPlayer     285 125 16.0 8.0
4628 ShootToPlayer     304 75  16.0 -8.0
4632 ShootToPlayer     15  75  16.0 8.0
4632 ShootToPlayer     34  125 16.0 -8.0
4632 ShootToPlayer     285 125 16.0 8.0
4632 ShootToPlayer     304 75  16.0 -8.0
4636 ShootToPlayer     15  75  16.0 8.0
4636 ShootToPlayer     34  125 16.0 -8.0
4636 ShootToPlayer     285 125 16.0 8.0
4636 ShootToPlayer     304 75  16.0 -8.0
4640 ShootToPlayer     15  75  16.0 8.0
4640 ShootToPlayer     34  125 16.0 -8.0
4640 ShootToPlayer     285 125 16.0 8.0
4640 ShootToPlayer     304 75  16.0 -8.0
4644 ShootToPlayer     15  75  16.0 8.0
4644 ShootToPlayer     34  125 16.0 -8.0
4644 ShootToPlayer     285 125 16.0 8.0
4644 ShootToPlayer     304 75  16.0 -8.0
4648 ShootToPlayer     15  75  16.0 8.0
4648 ShootToPlayer     34  125 16.0 -8.0
4648 ShootToPlayer     285 125 16.0 8.0
4648 ShootToPlayer     304 75  16.0 -8.0
4652 ShootToPlayer     15  75  16.0 8.0
4652 ShootToPlayer     34  125 16.0 -8.0
4652 ShootToPlayer     285 125 16.0 8.0
4652 ShootToPlayer     304 75  16.0 -8.0
4656 ShootToPlayer     15  75  16.0 8.0
4656 ShootToPlayer     34  125 16.0 -8.0
4656 ShootToPlayer     285 125 16.0 8.0
4656 ShootToPlayer     304 75  16.0 -8.0
4660 ShootToPlayer     15  75  16.0 8.0
4660 ShootToPlayer     34  125 16.0 -8.0
4660 ShootToPlayer     285 125 16.0 8.0
4660 ShootToPlayer     304 75  16.0 -8.0
4664 ShootToPlayer     15  75  16.0 8.0
4664 ShootToPlayer     34  125 16.0 -8.0
4664 ShootToPlayer     285 125 16.0 8.0
4664 ShootToPlayer     304 75  16.0 -8.0
4668 ShootToPlayer     15  75  16.0 8.0
4668 ShootToPlayer     34  125 16.0 -8.0
4668 ShootToPlayer     285 125 16.0 8.0
4668 ShootToPlayer     304 75  16.0 -8.0
4672 ShootToPlayer     15  75  16.0 8.0
4672 ShootToPlayer     34  125 16.0 -8.0
4672 ShootToPlayer     285 125 16.0 8.0
4672 ShootToPlayer     304 75  16.0 -8.0
4676 ShootToPlayer     15  75  16.0 8.0
4676 ShootToPlayer     34  125 16.0 -8.0
4676 ShootToPlayer     285 125 16.0 8.0
4676 ShootToPlayer     304 75  16.0 -8.0
4680 ShootToPlayer     15  75  16.0 8.0
4680 ShootToPlayer     34  125 16.0 -8.0
4680 ShootToPlayer     285 125 16.0 8.0
4680 ShootToPlayer     304 75  16.0 -8.0
4684 ShootToPlayer     15  75  16.0 8.0
4684 ShootToPlayer     34  125 16.0 -8.0
4684 ShootToPlayer     285 125 16.0 8.0
4684 ShootToPlayer     304 75  16.0 -8.0
4688 ShootToPlayer     15  75  16.0 8.0
4688 ShootToPlayer     34  125 16.0 -8.0
4688 ShootToPlayer     285 125 16.0 8.0
4688 ShootToPlayer     304 75  16.0 -8.0
4692 ShootToPlayer     15  75  16.0 8.0
4692 ShootToPlayer     34  125 16.0 -8.0
4692 ShootToPlayer     285 125 16.0 8.0
4692 ShootToPlayer     304 75  16.0 -8.0
4696 ShootToPlayer     15  75  16.0 8.0
4696 ShootToPlayer     34  125 16.0 -8.0
4696 ShootToPlayer     285 125 16.0 8.0
4696 ShootToPlayer     304 75  16.0 -8.0
4700 ShootToPlayer     15  75  16.0 8.0
4700 ShootToPlayer     34  125 16.0 -8.0
4700 ShootToPlayer     285 125 16.0 8.0
4700 ShootToPlayer     304 75  16.0 -8.0
4704 ShootToPlayer     15  75  16.0 8.0
4704 ShootToPlayer     34  125 16.0 -8.0
4704 ShootToPlayer     285 125 16.0 8.0
4704 ShootToPlayer     304 75  16.0 -8.0
4708 ShootToPlayer     15  75  16.0 8.0
4708 ShootToPlayer     34  125 16.0 -8.0
4708 ShootToPlayer     285 125 16.0 8.0
4708 ShootToPlayer     304 75  16.0 -8.0
4712 ShootToPlayer     15  75  16.0 8.0
4712 ShootToPlayer     34  125 16.0 -8.0
4712 ShootToPlayer     285 125 16.0 8.0
4712 ShootToPlayer     304 75  16.0 -8.0
4716 ShootToPlayer     15  75  16.0 8.0
4716 ShootToPlayer     34  125 16.0 -8.0
4716 ShootToPlayer     285 125 16.0 8.0
4716 ShootToPlayer     304 75  16.0 -8.0
4720 ShootToPlayer     15  75  16.0 8.0
4720 ShootToPlayer     34  125 16.0 -8.0
4720 ShootToPlayer     285 125 16.0 8.0
4720 ShootToPlayer     304 75  16.0 -8.0
4724 ShootToPlayer     15  75  16.0 8.0
4724 ShootToPlayer     34  125 16.0 -8.0
4724 ShootToPlayer     285 125 16.0 8.0
4724 ShootToPlayer     304 75  16.0 -8.0
4728 ShootToPlayer     15  75  16.0 8.0
4728 ShootToPlayer     34  125 16.0 -8.0
4728 ShootToPlayer     285 125 16.0 8.0
4728 ShootToPlayer     304 75  16.0 -8.0
4732 ShootToPlayer     15  75  16.0 8.0
4732 ShootToPlayer     34  125 16.0 -8.0
4732 ShootToPlayer     285 125 16.0 8.0
4732 ShootToPlayer     304 75  16.0 -8.0
4736 ShootToPlayer     15  75  16.0 8.0
4736 ShootToPlayer     34  125 16.0 -8.0
4736 ShootToPlayer     285 125 16.0 8.0
4736 ShootToPlayer     304 75  16.0 -8.0
4740 ShootToPlayer     15  75  16.0 8.0
4740 ShootToPlayer     34  125 16.0 -8.0
4740 ShootToPlayer     285 125 16.0 8.0
4740 ShootToPlayer     304 75  16.0 -8.0
4744 ShootToPlayer     15  75  16.0 8.0
4744 ShootToPlayer     34  125 16.0 -8.0
4744 ShootToPlayer     285 125 16.0 8.0
4744 ShootToPlayer     304 75  16.0 -8.0
4748 ShootToPlayer     15  75  16.0 8.0
4748 ShootToPlayer     34  125 16.0 -8.0
4748 ShootToPlayer     285 125 16.0 8.0
4748 ShootToPlayer     304 75  16.0 -8.0
4752 ShootToPlayer     15  75  16.0 8.0
4752 ShootToPlayer     34  125 16.0 -8.0
4752 ShootToPlayer     285 125 16.0 8.0
4752 ShootToPlayer     304 75  16.0 -8.0
4756 ShootToPlayer     15  75  16.0 8.0
4756 ShootToPlayer     34  125 16.0 -8.0
4756 ShootToPlayer     285 125 16.0 8.0
4756 ShootToPlayer     304 75  16.0 -8.0
4760 ShootToPlayer     15  75  16.0 8.0
4760 ShootToPlayer     34  125 16.0 -8.0
4760 ShootToPlayer     285 125 16.0 8.0
4760 ShootToPlayer     304 75  16.0 -8.0
4764 ShootToPlayer     15  75  16.0 8.0
4764 ShootToPlayer     34  125 16.0 -8.0
4764 ShootToPlayer     285 125 16.0 8.0
4764 ShootToPlayer     304 75  16.0 -8.0
4768 ShootToPlayer     15  75  16.0 8.0
4768 ShootToPlayer     34  125 16.0 -8.0
4768 ShootToPlayer     285 125 16.0 8.0
4768 ShootToPlayer     304 75  16.0 -8.0
4772 ShootToPlayer     15  75  16.0 8.0
4772 ShootToPlayer     34  125 16.0 -8.0
4772 ShootToPlayer     285 125 16.0 8.0
4772 ShootToPlayer     304 75  16.0 -8.0
4776 ShootToPlayer     15  75  16.0 8.0
4776 ShootToPlayer     34  125 16.0 -8.0
4776 ShootToPlayer     285 125 16.0 8.0
4776 ShootToPlayer     304 75  16.0 -8.0
4780 ShootToPlayer     15  75  16.0 8.0
4780 ShootToPlayer     34  125 16.0 -8.0
4780 ShootToPlayer     285 125 16.0 8.0
4780 ShootToPlayer     304 75  16.0 -8.0
4784 ShootToPlayer     15  75  16.0 8.0
4784 ShootToPlayer     34  125 16.0 -8.0
4784 ShootToPlayer     285 125 16.0 8.0
4784 ShootToPlayer     304 75  16.0 -8.0
4788 ShootToPlayer     15  75  16.0 8.0
4788 ShootToPlayer     34  125 16.0 -8.0
4788 ShootToPlayer     285 125 16.0 8.0
4788 ShootToPlayer     304 75  16.0 -8.0
4792 ShootToPlayer     15  75  16.0 8.0
4792 ShootToPlayer     34  125 16.0 -8.0
4792 ShootToPlayer     285 125 16.0 8.0
4792 ShootToPlayer     304 75  16.0 -8.0
4796 ShootToPlayer     15  75  16.0 8.0
4796 ShootToPlayer     34  125 16.0 -8.0
4796 ShootToPlayer     285 125 16.0 8.0
4796 ShootToPlayer     304 75  16.0 -8.0

4230 ShootToPlayer     160 123 6.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4270 ShootToPlayer     160 123 6.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4310 ShootToPlayer     160 123 6.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4350 ShootToPlayer     160 123 6.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4390 ShootToPlayer     160 123 6.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4430 ShootToPlayer     160 123 6.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4470 ShootToPlayer     160 123 6.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4510 ShootToPlayer     160 123 6.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4550 ShootToPlayer     160 123 6.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4590 ShootToPlayer     160 123 6.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4630 ShootToPlayer     160 123 6.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4670 ShootToPlayer     160 123 6.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4710 ShootToPlayer     160 123 6.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4750 ShootToPlayer     160 123 6.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4790 ShootToPlayer     160 123 6.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0



       
///////////////////////////////////////
```

`Source Code/Data/EnemyLevel4.txt`:

```txt
typeID: 1   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
35   SetVelY           0.0
35   ShootToPlayer     50 95 6.0 -20.0 0.0 20.0
125  SetVelY           10.0
125  ShootToPlayer     50 95 6.0 -20.0 0.0 20.0
/////////////////////////
typeID: 2   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
70   SetVelY           0.0
70   SetVelX           2.0
76   ShootToPlayerRand 56  175 5.0 8.0 1
76   ShootToPlayerRand 105 175 5.0 8.0 1
82   ShootToPlayerRand 56  175 5.0 8.0 1
82   ShootToPlayerRand 105 175 5.0 8.0 1
88   ShootToPlayerRand 56  175 5.0 8.0 1
88   ShootToPlayerRand 105 175 5.0 8.0 1
94   ShootToPlayerRand 56  175 5.0 8.0 1
94   ShootToPlayerRand 105 175 5.0 8.0 1
100  ShootToPlayerRand 56  175 5.0 8.0 1
100  ShootToPlayerRand 105 175 5.0 8.0 1
106  ShootToPlayerRand 56  175 5.0 8.0 1
106  ShootToPlayerRand 105 175 5.0 8.0 1
112  ShootToPlayerRand 56  175 5.0 8.0 1
112  ShootToPlayerRand 105 175 5.0 8.0 1
118  ShootToPlayerRand 56  175 5.0 8.0 1
118  ShootToPlayerRand 105 175 5.0 8.0 1
124  ShootToPlayerRand 56  175 5.0 8.0 1
124  ShootToPlayerRand 105 175 5.0 8.0 1
130  ShootToPlayerRand 56  175 5.0 8.0 1
130  ShootToPlayerRand 105 175 5.0 8.0 1

76   ShootToPlayerRand 56  175 7.5 8.0 1
76   ShootToPlayerRand 105 175 7.5 8.0 1
82   ShootToPlayerRand 56  175 7.5 8.0 1
82   ShootToPlayerRand 105 175 7.5 8.0 1
88   ShootToPlayerRand 56  175 7.5 8.0 1
88   ShootToPlayerRand 105 175 7.5 8.0 1
94   ShootToPlayerRand 56  175 7.5 8.0 1
94   ShootToPlayerRand 105 175 7.5 8.0 1
100  ShootToPlayerRand 56  175 7.5 8.0 1
100  ShootToPlayerRand 105 175 7.5 8.0 1
106  ShootToPlayerRand 56  175 7.5 8.0 1
106  ShootToPlayerRand 105 175 7.5 8.0 1
112  ShootToPlayerRand 56  175 7.5 8.0 1
112  ShootToPlayerRand 105 175 7.5 8.0 1
118  ShootToPlayerRand 56  175 7.5 8.0 1
118  ShootToPlayerRand 105 175 7.5 8.0 1
124  ShootToPlayerRand 56  175 7.5 8.0 1
124  ShootToPlayerRand 105 175 7.5 8.0 1
130  ShootToPlayerRand 56  175 7.5 8.0 1
130  ShootToPlayerRand 105 175 7.5 8.0 1

130  SetVelX           0.0
130  SetVelY           -2.0             
/////////////////////////
typeID: 3   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
90   SetVelY           -2.0
98   ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
106  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
114  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
122  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
130  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
140  SetVelY           4.0
140  SetVelX           2.0
200  SetVelY           -2.0
200  SetVelX           0.0
208  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
216  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
224  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
232  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
240  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
240  SetVelY           4.0
/////////////////////////
typeID: 4   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
30   ShootToPlayer     5   80  5.0 0.0
30   ShootToPlayer     45  80  5.0 0.0
42   ShootToPlayer     5   80  5.2 0.0
42   ShootToPlayer     45  80  5.2 0.0
/////////////////////////
typeID: 8   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
10   ShootToPlayer     37  100 6.0  -12.5 0.0 12.5
70   SetVelY           -3.0
70   SetAwayVelX       -4.5
90   ShootLaser        37  100 12.0
150  ShootLaser        37  100 12.0
/////////////////////////
typeID: 12  cmdCount: 1
MainCmd
0    SetCmd            0
1620 SetFrame          125
=========================
125  SetVelY           0.0
125  SetVelX           3.0
130  ShootToPlayer     78  200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
130  ShootToPlayer     172 200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
170  ShootToPlayer     78  200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
170  ShootToPlayer     172 200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
210  ShootToPlayer     78  200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
210  ShootToPlayer     172 200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
250  ShootToPlayer     78  200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
250  ShootToPlayer     172 200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
290  ShootToPlayer     78  200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
290  ShootToPlayer     172 200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
330  ShootToPlayer     78  200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
330  ShootToPlayer     172 200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
370  ShootToPlayer     78  200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
370  ShootToPlayer     172 200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
410  ShootToPlayer     78  200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
410  ShootToPlayer     172 200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
450  ShootToPlayer     78  200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
450  ShootToPlayer     172 200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
490  ShootToPlayer     78  200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
490  ShootToPlayer     172 200 8.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5

130  ShootToPlayer     78  200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
130  ShootToPlayer     172 200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
170  ShootToPlayer     78  200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
170  ShootToPlayer     172 200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
210  ShootToPlayer     78  200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
210  ShootToPlayer     172 200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
250  ShootToPlayer     78  200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
250  ShootToPlayer     172 200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
290  ShootToPlayer     78  200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
290  ShootToPlayer     172 200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
330  ShootToPlayer     78  200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
330  ShootToPlayer     172 200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
370  ShootToPlayer     78  200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
370  ShootToPlayer     172 200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
410  ShootToPlayer     78  200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
410  ShootToPlayer     172 200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
450  ShootToPlayer     78  200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
450  ShootToPlayer     172 200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
490  ShootToPlayer     78  200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
490  ShootToPlayer     172 200 9.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5

130  ShootToPlayer     78  200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
130  ShootToPlayer     172 200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
170  ShootToPlayer     78  200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
170  ShootToPlayer     172 200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
210  ShootToPlayer     78  200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
210  ShootToPlayer     172 200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
250  ShootToPlayer     78  200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
250  ShootToPlayer     172 200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
290  ShootToPlayer     78  200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
290  ShootToPlayer     172 200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
330  ShootToPlayer     78  200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
330  ShootToPlayer     172 200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
370  ShootToPlayer     78  200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
370  ShootToPlayer     172 200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
410  ShootToPlayer     78  200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
410  ShootToPlayer     172 200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
450  ShootToPlayer     78  200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
450  ShootToPlayer     172 200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
490  ShootToPlayer     78  200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5
490  ShootToPlayer     172 200 10.0 -67.5 -45.0 -22.5 0.0 22.5 45.0 67.5

550  SetVelX           0.0

550  ShootToPlayerRand 25  250 10.0 22.5 3
554  ShootToPlayerRand 25  250 10.0 22.5 3
558  ShootToPlayerRand 25  250 10.0 22.5 3
562  ShootToPlayerRand 25  250 10.0 22.5 3
566  ShootToPlayerRand 25  250 10.0 22.5 3
570  ShootToPlayerRand 25  250 10.0 22.5 3
574  ShootToPlayerRand 25  250 10.0 22.5 3
578  ShootToPlayerRand 25  250 10.0 22.5 3
582  ShootToPlayerRand 25  250 10.0 22.5 3
586  ShootToPlayerRand 25  250 10.0 22.5 3

550  ShootToPlayerRand 25  250 14.0 22.5 3
554  ShootToPlayerRand 25  250 14.0 22.5 3
558  ShootToPlayerRand 25  250 14.0 22.5 3
562  ShootToPlayerRand 25  250 14.0 22.5 3
566  ShootToPlayerRand 25  250 14.0 22.5 3
570  ShootToPlayerRand 25  250 14.0 22.5 3
574  ShootToPlayerRand 25  250 14.0 22.5 3
578  ShootToPlayerRand 25  250 14.0 22.5 3
582  ShootToPlayerRand 25  250 14.0 22.5 3
586  ShootToPlayerRand 25  250 14.0 22.5 3

640  ShootToPlayerRand 234 250 10.0 22.5 3
644  ShootToPlayerRand 234 250 10.0 22.5 3
648  ShootToPlayerRand 234 250 10.0 22.5 3
652  ShootToPlayerRand 234 250 10.0 22.5 3
656  ShootToPlayerRand 234 250 10.0 22.5 3
660  ShootToPlayerRand 234 250 10.0 22.5 3
664  ShootToPlayerRand 234 250 10.0 22.5 3
668  ShootToPlayerRand 234 250 10.0 22.5 3
672  ShootToPlayerRand 234 250 10.0 22.5 3
676  ShootToPlayerRand 234 250 10.0 22.5 3

640  ShootToPlayerRand 234 250 14.0 22.5 3
644  ShootToPlayerRand 234 250 14.0 22.5 3
648  ShootToPlayerRand 234 250 14.0 22.5 3
652  ShootToPlayerRand 234 250 14.0 22.5 3
656  ShootToPlayerRand 234 250 14.0 22.5 3
660  ShootToPlayerRand 234 250 14.0 22.5 3
664  ShootToPlayerRand 234 250 14.0 22.5 3
668  ShootToPlayerRand 234 250 14.0 22.5 3
672  ShootToPlayerRand 234 250 14.0 22.5 3
676  ShootToPlayerRand 234 250 14.0 22.5 3

730  ShootToPlayerRand 25  250 10.0 22.5 3
734  ShootToPlayerRand 25  250 10.0 22.5 3
738  ShootToPlayerRand 25  250 10.0 22.5 3
742  ShootToPlayerRand 25  250 10.0 22.5 3
746  ShootToPlayerRand 25  250 10.0 22.5 3
750  ShootToPlayerRand 25  250 10.0 22.5 3
754  ShootToPlayerRand 25  250 10.0 22.5 3
758  ShootToPlayerRand 25  250 10.0 22.5 3
762  ShootToPlayerRand 25  250 10.0 22.5 3
766  ShootToPlayerRand 25  250 10.0 22.5 3

730  ShootToPlayerRand 25  250 14.0 22.5 3
734  ShootToPlayerRand 25  250 14.0 22.5 3
738  ShootToPlayerRand 25  250 14.0 22.5 3
742  ShootToPlayerRand 25  250 14.0 22.5 3
746  ShootToPlayerRand 25  250 14.0 22.5 3
750  ShootToPlayerRand 25  250 14.0 22.5 3
754  ShootToPlayerRand 25  250 14.0 22.5 3
758  ShootToPlayerRand 25  250 14.0 22.5 3
762  ShootToPlayerRand 25  250 14.0 22.5 3
766  ShootToPlayerRand 25  250 14.0 22.5 3

820  ShootToPlayerRand 234 250 10.0 22.5 3
824  ShootToPlayerRand 234 250 10.0 22.5 3
828  ShootToPlayerRand 234 250 10.0 22.5 3
832  ShootToPlayerRand 234 250 10.0 22.5 3
836  ShootToPlayerRand 234 250 10.0 22.5 3
840  ShootToPlayerRand 234 250 10.0 22.5 3
844  ShootToPlayerRand 234 250 10.0 22.5 3
848  ShootToPlayerRand 234 250 10.0 22.5 3
852  ShootToPlayerRand 234 250 10.0 22.5 3
856  ShootToPlayerRand 234 250 10.0 22.5 3

820  ShootToPlayerRand 234 250 14.0 22.5 3
824  ShootToPlayerRand 234 250 14.0 22.5 3
828  ShootToPlayerRand 234 250 14.0 22.5 3
832  ShootToPlayerRand 234 250 14.0 22.5 3
836  ShootToPlayerRand 234 250 14.0 22.5 3
840  ShootToPlayerRand 234 250 14.0 22.5 3
844  ShootToPlayerRand 234 250 14.0 22.5 3
848  ShootToPlayerRand 234 250 14.0 22.5 3
852  ShootToPlayerRand 234 250 14.0 22.5 3
856  ShootToPlayerRand 234 250 14.0 22.5 3

920  SetAwayVelX       3.0        

930  ShootLaser        40  185 12.0
930  ShootLaser        210 185 12.0
930  ShootToPlayer     40  185 6.0  0.0
930  ShootToPlayer     210 185 6.0  0.0
950  ShootLaser        40  185 12.0
950  ShootLaser        210 185 12.0
950  ShootToPlayer     40  185 6.0  0.0
950  ShootToPlayer     210 185 6.0  0.0
970  ShootLaser        40  185 12.0
970  ShootLaser        210 185 12.0
970  ShootToPlayer     40  185 6.0  0.0
970  ShootToPlayer     210 185 6.0  0.0
990  ShootLaser        40  185 12.0
990  ShootLaser        210 185 12.0
990  ShootToPlayer     40  185 6.0  0.0
990  ShootToPlayer     210 185 6.0  0.0
1010 ShootLaser        40  185 12.0
1010 ShootLaser        210 185 12.0
1010 ShootToPlayer     40  185 6.0  0.0
1010 ShootToPlayer     210 185 6.0  0.0
1030 ShootLaser        40  185 12.0
1030 ShootLaser        210 185 12.0
1030 ShootToPlayer     40  185 6.0  0.0
1030 ShootToPlayer     210 185 6.0  0.0
1050 ShootLaser        40  185 12.0
1050 ShootLaser        210 185 12.0
1050 ShootToPlayer     40  185 6.0  0.0
1050 ShootToPlayer     210 185 6.0  0.0
1070 ShootLaser        40  185 12.0
1070 ShootLaser        210 185 12.0
1070 ShootToPlayer     40  185 6.0  0.0
1070 ShootToPlayer     210 185 6.0  0.0
1090 ShootLaser        40  185 12.0
1090 ShootLaser        210 185 12.0
1090 ShootToPlayer     40  185 6.0  0.0
1090 ShootToPlayer     210 185 6.0  0.0
1110 ShootLaser        40  185 12.0
1110 ShootLaser        210 185 12.0
1110 ShootToPlayer     40  185 6.0  0.0
1110 ShootToPlayer     210 185 6.0  0.0
1130 ShootLaser        40  185 12.0
1130 ShootLaser        210 185 12.0
1130 ShootToPlayer     40  185 6.0  0.0
1130 ShootToPlayer     210 185 6.0  0.0
1150 ShootLaser        40  185 12.0
1150 ShootLaser        210 185 12.0
1150 ShootToPlayer     40  185 6.0  0.0
1150 ShootToPlayer     210 185 6.0  0.0
1170 ShootLaser        40  185 12.0
1170 ShootLaser        210 185 12.0
1170 ShootToPlayer     40  185 6.0  0.0
1170 ShootToPlayer     210 185 6.0  0.0
1190 ShootLaser        40  185 12.0
1190 ShootLaser        210 185 12.0
1190 ShootToPlayer     40  185 6.0  0.0
1190 ShootToPlayer     210 185 6.0  0.0
1210 ShootLaser        40  185 12.0
1210 ShootLaser        210 185 12.0
1210 ShootToPlayer     40  185 6.0  0.0
1210 ShootToPlayer     210 185 6.0  0.0

1280 SetVelX           0.0

1300 Shoot             125 188 8.0 38.0 
1304 Shoot             125 188 8.0 38.0 45.0 
1308 Shoot             125 188 8.0 38.0 45.0 52.0 
1312 Shoot             125 188 8.0 38.0 45.0 52.0 59.0 
1316 Shoot             125 188 8.0 38.0 45.0 52.0 59.0 66.0 
1320 Shoot             125 188 8.0 45.0 52.0 59.0 66.0 73.0 
1324 Shoot             125 188 8.0 52.0 59.0 66.0 73.0 80.0 
1328 Shoot             125 188 8.0 59.0 66.0 73.0 80.0 87.0 
1332 Shoot             125 188 8.0 66.0 73.0 80.0 87.0 94.0 
1336 Shoot             125 188 8.0 73.0 80.0 87.0 94.0 101.0 
1340 Shoot             125 188 8.0 80.0 87.0 94.0 101.0 108.0 
1344 Shoot             125 188 8.0 87.0 94.0 101.0 108.0 115.0 
1348 Shoot             125 188 8.0 94.0 101.0 108.0 115.0 122.0 
1352 Shoot             125 188 8.0 101.0 108.0 115.0 122.0 129.0 
1356 Shoot             125 188 8.0 108.0 115.0 122.0 129.0 136.0 
1360 Shoot             125 188 8.0 115.0 122.0 129.0 136.0 144.0 
1364 Shoot             125 188 8.0 122.0 129.0 136.0 144.0 137.0 
1368 Shoot             125 188 8.0 129.0 136.0 144.0 137.0 130.0 
1372 Shoot             125 188 8.0 136.0 144.0 137.0 130.0 123.0 
1376 Shoot             125 188 8.0 144.0 137.0 130.0 123.0 116.0 
1380 Shoot             125 188 8.0 137.0 130.0 123.0 116.0 109.0 
1384 Shoot             125 188 8.0 130.0 123.0 116.0 109.0 102.0 
1388 Shoot             125 188 8.0 123.0 116.0 109.0 102.0 95.0 
1392 Shoot             125 188 8.0 116.0 109.0 102.0 95.0 88.0 
1396 Shoot             125 188 8.0 109.0 102.0 95.0 88.0 81.0 
1400 Shoot             125 188 8.0 102.0 95.0 88.0 81.0 74.0 
1404 Shoot             125 188 8.0 95.0 88.0 81.0 74.0 67.0 
1408 Shoot             125 188 8.0 88.0 81.0 74.0 67.0 60.0 
1412 Shoot             125 188 8.0 81.0 74.0 67.0 60.0 53.0 
1416 Shoot             125 188 8.0 74.0 67.0 60.0 53.0 46.0 
1420 Shoot             125 188 8.0 67.0 60.0 53.0 46.0 36.0 
1424 Shoot             125 188 8.0 60.0 53.0 46.0 36.0 43.0 
1428 Shoot             125 188 8.0 53.0 46.0 36.0 43.0 50.0 
1432 Shoot             125 188 8.0 46.0 36.0 43.0 50.0 57.0 
1436 Shoot             125 188 8.0 36.0 43.0 50.0 57.0 64.0 
1440 Shoot             125 188 8.0 43.0 50.0 57.0 64.0 71.0 
1444 Shoot             125 188 8.0 50.0 57.0 64.0 71.0 78.0 
1448 Shoot             125 188 8.0 57.0 64.0 71.0 78.0 85.0 
1452 Shoot             125 188 8.0 64.0 71.0 78.0 85.0 92.0 
1456 Shoot             125 188 8.0 71.0 78.0 85.0 92.0 99.0 
1460 Shoot             125 188 8.0 78.0 85.0 92.0 99.0 106.0 
1464 Shoot             125 188 8.0 85.0 92.0 99.0 106.0 113.0 
1468 Shoot             125 188 8.0 92.0 99.0 106.0 113.0 120.0 
1472 Shoot             125 188 8.0 99.0 106.0 113.0 120.0 127.0 
1476 Shoot             125 188 8.0 106.0 113.0 120.0 127.0 134.0 
1480 Shoot             125 188 8.0 113.0 120.0 127.0 134.0 146.0 
1484 Shoot             125 188 8.0 120.0 127.0 134.0 146.0 139.0 
1488 Shoot             125 188 8.0 127.0 134.0 146.0 139.0 132.0 
1492 Shoot             125 188 8.0 134.0 146.0 139.0 132.0 125.0 
1496 Shoot             125 188 8.0 146.0 139.0 132.0 125.0 118.0 
1500 Shoot             125 188 8.0 139.0 132.0 125.0 118.0 111.0 
1504 Shoot             125 188 8.0 132.0 125.0 118.0 111.0 104.0 
1508 Shoot             125 188 8.0 125.0 118.0 111.0 104.0 97.0 
1512 Shoot             125 188 8.0 118.0 111.0 104.0 97.0 90.0 
1516 Shoot             125 188 8.0 111.0 104.0 97.0 90.0 83.0 
1520 Shoot             125 188 8.0 104.0 97.0 90.0 83.0 76.0 
1524 Shoot             125 188 8.0 97.0 90.0 83.0 76.0 69.0 
1528 Shoot             125 188 8.0 90.0 83.0 76.0 69.0 62.0 
1532 Shoot             125 188 8.0 83.0 76.0 69.0 62.0 55.0 
1536 Shoot             125 188 8.0 76.0 69.0 62.0 55.0 48.0 
1540 Shoot             125 188 8.0 69.0 62.0 55.0 48.0 
1544 Shoot             125 188 8.0 62.0 55.0 48.0 
1548 Shoot             125 188 8.0 55.0 48.0 
1552 Shoot             125 188 8.0 48.0 




///////////////////////////


```

`Source Code/Data/EnemyLevel5.txt`:

```txt
typeID: 1   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
35   SetVelY           0.0
35   ShootToPlayer     50 95 6.0 -20.0 0.0 20.0
35   ShootToPlayer     50 95 8.0 -20.0 0.0 20.0
125  SetVelY           10.0
125  ShootToPlayer     50 95 6.0 -20.0 0.0 20.0
125  ShootToPlayer     50 95 8.0 -20.0 0.0 20.0
/////////////////////////
typeID: 2   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
70   SetVelY           0.0
70   SetVelX           2.0
76   ShootToPlayerRand 56  175 5.0 8.0 1
76   ShootToPlayerRand 105 175 5.0 8.0 1
82   ShootToPlayerRand 56  175 5.0 8.0 1
82   ShootToPlayerRand 105 175 5.0 8.0 1
88   ShootToPlayerRand 56  175 5.0 8.0 1
88   ShootToPlayerRand 105 175 5.0 8.0 1
94   ShootToPlayerRand 56  175 5.0 8.0 1
94   ShootToPlayerRand 105 175 5.0 8.0 1
100  ShootToPlayerRand 56  175 5.0 8.0 1
100  ShootToPlayerRand 105 175 5.0 8.0 1
106  ShootToPlayerRand 56  175 5.0 8.0 1
106  ShootToPlayerRand 105 175 5.0 8.0 1
112  ShootToPlayerRand 56  175 5.0 8.0 1
112  ShootToPlayerRand 105 175 5.0 8.0 1
118  ShootToPlayerRand 56  175 5.0 8.0 1
118  ShootToPlayerRand 105 175 5.0 8.0 1
124  ShootToPlayerRand 56  175 5.0 8.0 1
124  ShootToPlayerRand 105 175 5.0 8.0 1
130  ShootToPlayerRand 56  175 5.0 8.0 1
130  ShootToPlayerRand 105 175 5.0 8.0 1

76   ShootToPlayerRand 56  175 7.5 8.0 1
76   ShootToPlayerRand 105 175 7.5 8.0 1
82   ShootToPlayerRand 56  175 7.5 8.0 1
82   ShootToPlayerRand 105 175 7.5 8.0 1
88   ShootToPlayerRand 56  175 7.5 8.0 1
88   ShootToPlayerRand 105 175 7.5 8.0 1
94   ShootToPlayerRand 56  175 7.5 8.0 1
94   ShootToPlayerRand 105 175 7.5 8.0 1
100  ShootToPlayerRand 56  175 7.5 8.0 1
100  ShootToPlayerRand 105 175 7.5 8.0 1
106  ShootToPlayerRand 56  175 7.5 8.0 1
106  ShootToPlayerRand 105 175 7.5 8.0 1
112  ShootToPlayerRand 56  175 7.5 8.0 1
112  ShootToPlayerRand 105 175 7.5 8.0 1
118  ShootToPlayerRand 56  175 7.5 8.0 1
118  ShootToPlayerRand 105 175 7.5 8.0 1
124  ShootToPlayerRand 56  175 7.5 8.0 1
124  ShootToPlayerRand 105 175 7.5 8.0 1
130  ShootToPlayerRand 56  175 7.5 8.0 1
130  ShootToPlayerRand 105 175 7.5 8.0 1

130  SetVelX           0.0
130  SetVelY           -2.0             
/////////////////////////
typeID: 3   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
90   SetVelY           -2.0
98   ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
106  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
114  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
122  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
130  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
140  SetVelY           4.0
140  SetVelX           2.0
200  SetVelY           -2.0
200  SetVelX           0.0
208  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
216  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
224  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
232  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
240  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
240  SetVelY           4.0
/////////////////////////
typeID: 4   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
30   ShootToPlayer     5   80  5.0 0.0
30   ShootToPlayer     45  80  5.0 0.0
42   ShootToPlayer     5   80  5.2 0.0
42   ShootToPlayer     45  80  5.2 0.0
54   ShootToPlayer     5   80  5.4 0.0
54   ShootToPlayer     45  80  5.4 0.0
66   ShootToPlayer     5   80  5.6 0.0
66   ShootToPlayer     45  80  5.6 0.0
/////////////////////////
typeID: 5   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
20   ShootToPlayer     50  95 6.0 -60.0 -40.0 -20.0 0.0 20.0 40.0 60.0
20   ShootToPlayer     50  95 7.0 -60.0 -40.0 -20.0 0.0 20.0 40.0 60.0
35   SetVelY           0.0
35   ShootToPlayer     50  95 6.0 -60.0 -40.0 -20.0 0.0 20.0 40.0 60.0
35   ShootToPlayer     50  95 7.0 -60.0 -40.0 -20.0 0.0 20.0 40.0 60.0
125  SetVelY           -5.0
125  SetAwayVelX       2.5
125  ShootToPlayer     50  95 6.0 -60.0 -40.0 -20.0 0.0 20.0 40.0 60.0
125  ShootToPlayer     50  95 7.0 -60.0 -40.0 -20.0 0.0 20.0 40.0 60.0
/////////////////////////
typeID: 6   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
40   SetVelY            0.0
40   Charge             0
40   Shoot             70  55   8.0 -180.0 -168.0 -156.0 -144.0 -132.0 -120.0 -108.0 -96.0 -84.0 -72.0 -60.0 -48.0 -36.0 -24.0 -12.0 0.0 12.0 24.0 36.0 48.0 60.0 72.0 84.0 96.0 108.0 120.0 132.0 144.0 156.0 168.0 
40   Shoot             70  55   9.0 -180.0 -168.0 -156.0 -144.0 -132.0 -120.0 -108.0 -96.0 -84.0 -72.0 -60.0 -48.0 -36.0 -24.0 -12.0 0.0 12.0 24.0 36.0 48.0 60.0 72.0 84.0 96.0 108.0 120.0 132.0 144.0 156.0 168.0 



80   ShootLaser         23  220 16.0
80   ShootLaser         115 220 16.0
86   ShootLaser         23  220 16.0
86   ShootLaser         115 220 16.0
92   ShootLaser         23  220 16.0
92   ShootLaser         115 220 16.0
98   ShootLaser         23  220 16.0
98   ShootLaser         115 220 16.0
104  ShootLaser         23  220 16.0
104  ShootLaser         115 220 16.0
110  ShootLaser         23  220 16.0
110  ShootLaser         115 220 16.0
116  ShootLaser         23  220 16.0
116  ShootLaser         115 220 16.0
122  ShootLaser         23  220 16.0
122  ShootLaser         115 220 16.0
128  ShootLaser         23  220 16.0
128  ShootLaser         115 220 16.0
134  ShootLaser         23  220 16.0
134  ShootLaser         115 220 16.0
140  SetVelY            -2.0
140  ShootToPlayerRand  23  190 6.0 20.0 2
140  ShootToPlayerRand  115 190 6.0 20.0 2
148  ShootToPlayerRand  23  190 6.0 20.0 2
148  ShootToPlayerRand  115 190 6.0 20.0 2
156  ShootToPlayerRand  23  190 6.0 20.0 2
156  ShootToPlayerRand  115 190 6.0 20.0 2
164  ShootToPlayerRand  23  190 6.0 20.0 2
164  ShootToPlayerRand  115 190 6.0 20.0 2
172  ShootToPlayerRand  23  190 6.0 20.0 2
172  ShootToPlayerRand  115 190 6.0 20.0 2
180  ShootToPlayerRand  23  190 6.0 20.0 2
180  ShootToPlayerRand  115 190 6.0 20.0 2
188  ShootToPlayerRand  23  190 6.0 20.0 2
188  ShootToPlayerRand  115 190 6.0 20.0 2
196  ShootToPlayerRand  23  190 6.0 20.0 2
196  ShootToPlayerRand  115 190 6.0 20.0 2
204  ShootToPlayerRand  23  190 6.0 20.0 2
204  ShootToPlayerRand  115 190 6.0 20.0 2
212  ShootToPlayerRand  23  190 6.0 20.0 2
212  ShootToPlayerRand  115 190 6.0 20.0 2
220  ShootToPlayerRand  23  190 6.0 20.0 2
220  ShootToPlayerRand  115 190 6.0 20.0 2
228  ShootToPlayerRand  23  190 6.0 20.0 2
228  ShootToPlayerRand  115 190 6.0 20.0 2
/////////////////////////
typeID: 7   cmdCount: 1
MainCmd
0     SetCmd            0
290   SetFrame          50
=========================
50   SetVelX             0.0
50   SetVelY             0.0
56   ShootToPlayerRand   55  40  4.0 20.0 2
62   ShootToPlayerRand   55  40  4.0 20.0 2
68   ShootToPlayerRand   55  40  4.0 20.0 2
74   ShootToPlayerRand   55  40  4.0 20.0 2
80   ShootToPlayerRand   55  40  4.0 20.0 2
86   ShootToPlayerRand   55  40  4.0 20.0 2
92   ShootToPlayerRand   55  40  4.0 20.0 2
98   ShootToPlayerRand   55  40  4.0 20.0 2
104  ShootToPlayerRand   55  40  4.0 20.0 2
110  ShootToPlayerRand   55  40  4.0 20.0 2

56   ShootToPlayerRand   55  40  7.0 20.0 2
62   ShootToPlayerRand   55  40  7.0 20.0 2
68   ShootToPlayerRand   55  40  7.0 20.0 2
74   ShootToPlayerRand   55  40  7.0 20.0 2
80   ShootToPlayerRand   55  40  7.0 20.0 2
86   ShootToPlayerRand   55  40  7.0 20.0 2
92   ShootToPlayerRand   55  40  7.0 20.0 2
98   ShootToPlayerRand   55  40  7.0 20.0 2
104  ShootToPlayerRand   55  40  7.0 20.0 2
110  ShootToPlayerRand   55  40  7.0 20.0 2

140  SetVelX             5.0
140  SetVelY             3.0
170  SetVelX             0.0
170  SetVelY             0.0
176  ShootToPlayerRand   55  40  4.0 20.0 2
182  ShootToPlayerRand   55  40  4.0 20.0 2
188  ShootToPlayerRand   55  40  4.0 20.0 2
194  ShootToPlayerRand   55  40  4.0 20.0 2
200  ShootToPlayerRand   55  40  4.0 20.0 2
206  ShootToPlayerRand   55  40  4.0 20.0 2
212  ShootToPlayerRand   55  40  4.0 20.0 2
218  ShootToPlayerRand   55  40  4.0 20.0 2
224  ShootToPlayerRand   55  40  4.0 20.0 2
230  ShootToPlayerRand   55  40  4.0 20.0 2

176  ShootToPlayerRand   55  40  7.0 20.0 2
182  ShootToPlayerRand   55  40  7.0 20.0 2
188  ShootToPlayerRand   55  40  7.0 20.0 2
194  ShootToPlayerRand   55  40  7.0 20.0 2
200  ShootToPlayerRand   55  40  7.0 20.0 2
206  ShootToPlayerRand   55  40  7.0 20.0 2
212  ShootToPlayerRand   55  40  7.0 20.0 2
218  ShootToPlayerRand   55  40  7.0 20.0 2
224  ShootToPlayerRand   55  40  7.0 20.0 2
230  ShootToPlayerRand   55  40  7.0 20.0 2
260  SetVelX             5.0
260  SetVelY             3.0
/////////////////////////
typeID: 8   cmdCount: 1
MainCmd
0     SetCmd            0
=========================
10    ShootToPlayer     37  100 6.0  -12.5 0.0 12.5
70    SetVelY           -3.0
70    SetAwayVelX       -4.5
90    ShootLaser        37  100 12.0
150   ShootLaser        37  100 12.0
/////////////////////////
typeID: 9   cmdCount: 1
MainCmd
0    SetCmd             0
=========================
40   SetVelY            0.0
40  Charge             0
80   ShootRand          30  240 8.0 90.0 60.0 9
86   ShootRand          30  240 8.0 90.0 60.0 9
92   ShootRand          30  240 8.0 90.0 60.0 9
98   ShootRand          30  240 8.0 90.0 60.0 9
104  ShootRand          30  240 8.0 90.0 60.0 9
110  ShootRand          30  240 8.0 90.0 60.0 9
116  ShootRand          30  240 8.0 90.0 60.0 9
122  ShootRand          30  240 8.0 90.0 60.0 9
128  ShootRand          30  240 8.0 90.0 60.0 9
134  ShootRand          30  240 8.0 90.0 60.0 9
140  ShootRand          30  240 8.0 90.0 60.0 9
146  ShootRand          30  240 8.0 90.0 60.0 9
152  ShootRand          30  240 8.0 90.0 60.0 9
158  ShootRand          30  240 8.0 90.0 60.0 9
164  ShootRand          30  240 8.0 90.0 60.0 9
180  SetVelY            -3.0
/////////////////////////
typeID: 13  cmdCount: 2
MainCmd
0    SetCmd             0
1250 SetFrame           120

180  SetFrameIfHPLess   2000 1290
270  SetFrameIfHPLess   2000 1290
360  SetFrameIfHPLess   2000 1290
450  SetFrameIfHPLess   2000 1290
540  SetFrameIfHPLess   2000 1290
630  SetFrameIfHPLess   2000 1290
720  SetFrameIfHPLess   2000 1290
810  SetFrameIfHPLess   2000 1290
900  SetFrameIfHPLess   2000 1290
990  SetFrameIfHPLess   2000 1290
1080 SetFrameIfHPLess   2000 1290
1170 SetFrameIfHPLess   2000 1290

1300 SetCmd             1
2900 SetFrame           1490
=========================
115  SetVelY           0.0
115  SetVelX           0.25
120  ShootToPlayerRand 161 99  10.0 15.0 2
120  ShootToPlayerRand 338 99  10.0 15.0 2
123  ShootToPlayerRand 161 99  10.0 15.0 2
123  ShootToPlayerRand 338 99  10.0 15.0 2
126  ShootToPlayerRand 161 99  10.0 15.0 2
126  ShootToPlayerRand 338 99  10.0 15.0 2
129  ShootToPlayerRand 161 99  10.0 15.0 2
129  ShootToPlayerRand 338 99  10.0 15.0 2
132  ShootToPlayerRand 161 99  10.0 15.0 2
132  ShootToPlayerRand 338 99  10.0 15.0 2
135  ShootToPlayerRand 161 99  10.0 15.0 2
135  ShootToPlayerRand 338 99  10.0 15.0 2
138  ShootToPlayerRand 161 99  10.0 15.0 2
138  ShootToPlayerRand 338 99  10.0 15.0 2
141  ShootToPlayerRand 161 99  10.0 15.0 2
141  ShootToPlayerRand 338 99  10.0 15.0 2
144  ShootToPlayerRand 161 99  10.0 15.0 2
144  ShootToPlayerRand 338 99  10.0 15.0 2
147  ShootToPlayerRand 161 99  10.0 15.0 2
147  ShootToPlayerRand 338 99  10.0 15.0 2
150  ShootToPlayerRand 161 99  10.0 15.0 2
150  ShootToPlayerRand 338 99  10.0 15.0 2
153  ShootToPlayerRand 161 99  10.0 15.0 2
153  ShootToPlayerRand 338 99  10.0 15.0 2
156  ShootToPlayerRand 161 99  10.0 15.0 2
156  ShootToPlayerRand 338 99  10.0 15.0 2
159  ShootToPlayerRand 161 99  10.0 15.0 2
159  ShootToPlayerRand 338 99  10.0 15.0 2
162  ShootToPlayerRand 161 99  10.0 15.0 2
162  ShootToPlayerRand 338 99  10.0 15.0 2
165  ShootToPlayerRand 161 99  10.0 15.0 2
165  ShootToPlayerRand 338 99  10.0 15.0 2
168  ShootToPlayerRand 161 99  10.0 15.0 2
168  ShootToPlayerRand 338 99  10.0 15.0 2
171  ShootToPlayerRand 161 99  10.0 15.0 2
171  ShootToPlayerRand 338 99  10.0 15.0 2
174  ShootToPlayerRand 161 99  10.0 15.0 2
174  ShootToPlayerRand 338 99  10.0 15.0 2
177  ShootToPlayerRand 161 99  10.0 15.0 2
177  ShootToPlayerRand 338 99  10.0 15.0 2

120  ShootToPlayerRand 161 99  14.0 15.0 2
120  ShootToPlayerRand 338 99  14.0 15.0 2
123  ShootToPlayerRand 161 99  14.0 15.0 2
123  ShootToPlayerRand 338 99  14.0 15.0 2
126  ShootToPlayerRand 161 99  14.0 15.0 2
126  ShootToPlayerRand 338 99  14.0 15.0 2
129  ShootToPlayerRand 161 99  14.0 15.0 2
129  ShootToPlayerRand 338 99  14.0 15.0 2
132  ShootToPlayerRand 161 99  14.0 15.0 2
132  ShootToPlayerRand 338 99  14.0 15.0 2
135  ShootToPlayerRand 161 99  14.0 15.0 2
135  ShootToPlayerRand 338 99  14.0 15.0 2
138  ShootToPlayerRand 161 99  14.0 15.0 2
138  ShootToPlayerRand 338 99  14.0 15.0 2
141  ShootToPlayerRand 161 99  14.0 15.0 2
141  ShootToPlayerRand 338 99  14.0 15.0 2
144  ShootToPlayerRand 161 99  14.0 15.0 2
144  ShootToPlayerRand 338 99  14.0 15.0 2
147  ShootToPlayerRand 161 99  14.0 15.0 2
147  ShootToPlayerRand 338 99  14.0 15.0 2
150  ShootToPlayerRand 161 99  14.0 15.0 2
150  ShootToPlayerRand 338 99  14.0 15.0 2
153  ShootToPlayerRand 161 99  14.0 15.0 2
153  ShootToPlayerRand 338 99  14.0 15.0 2
156  ShootToPlayerRand 161 99  14.0 15.0 2
156  ShootToPlayerRand 338 99  14.0 15.0 2
159  ShootToPlayerRand 161 99  14.0 15.0 2
159  ShootToPlayerRand 338 99  14.0 15.0 2
162  ShootToPlayerRand 161 99  14.0 15.0 2
162  ShootToPlayerRand 338 99  14.0 15.0 2
165  ShootToPlayerRand 161 99  14.0 15.0 2
165  ShootToPlayerRand 338 99  14.0 15.0 2
168  ShootToPlayerRand 161 99  14.0 15.0 2
168  ShootToPlayerRand 338 99  14.0 15.0 2
171  ShootToPlayerRand 161 99  14.0 15.0 2
171  ShootToPlayerRand 338 99  14.0 15.0 2
174  ShootToPlayerRand 161 99  14.0 15.0 2
174  ShootToPlayerRand 338 99  14.0 15.0 2
177  ShootToPlayerRand 161 99  14.0 15.0 2
177  ShootToPlayerRand 338 99  14.0 15.0 2

210  ShootToPlayerRand 161 99  10.0 15.0 2
210  ShootToPlayerRand 338 99  10.0 15.0 2
213  ShootToPlayerRand 161 99  10.0 15.0 2
213  ShootToPlayerRand 338 99  10.0 15.0 2
216  ShootToPlayerRand 161 99  10.0 15.0 2
216  ShootToPlayerRand 338 99  10.0 15.0 2
219  ShootToPlayerRand 161 99  10.0 15.0 2
219  ShootToPlayerRand 338 99  10.0 15.0 2
222  ShootToPlayerRand 161 99  10.0 15.0 2
222  ShootToPlayerRand 338 99  10.0 15.0 2
225  ShootToPlayerRand 161 99  10.0 15.0 2
225  ShootToPlayerRand 338 99  10.0 15.0 2
228  ShootToPlayerRand 161 99  10.0 15.0 2
228  ShootToPlayerRand 338 99  10.0 15.0 2
231  ShootToPlayerRand 161 99  10.0 15.0 2
231  ShootToPlayerRand 338 99  10.0 15.0 2
234  ShootToPlayerRand 161 99  10.0 15.0 2
234  ShootToPlayerRand 338 99  10.0 15.0 2
237  ShootToPlayerRand 161 99  10.0 15.0 2
237  ShootToPlayerRand 338 99  10.0 15.0 2
240  ShootToPlayerRand 161 99  10.0 15.0 2
240  ShootToPlayerRand 338 99  10.0 15.0 2
243  ShootToPlayerRand 161 99  10.0 15.0 2
243  ShootToPlayerRand 338 99  10.0 15.0 2
246  ShootToPlayerRand 161 99  10.0 15.0 2
246  ShootToPlayerRand 338 99  10.0 15.0 2
249  ShootToPlayerRand 161 99  10.0 15.0 2
249  ShootToPlayerRand 338 99  10.0 15.0 2
252  ShootToPlayerRand 161 99  10.0 15.0 2
252  ShootToPlayerRand 338 99  10.0 15.0 2
255  ShootToPlayerRand 161 99  10.0 15.0 2
255  ShootToPlayerRand 338 99  10.0 15.0 2
258  ShootToPlayerRand 161 99  10.0 15.0 2
258  ShootToPlayerRand 338 99  10.0 15.0 2
261  ShootToPlayerRand 161 99  10.0 15.0 2
261  ShootToPlayerRand 338 99  10.0 15.0 2
264  ShootToPlayerRand 161 99  10.0 15.0 2
264  ShootToPlayerRand 338 99  10.0 15.0 2
267  ShootToPlayerRand 161 99  10.0 15.0 2
267  ShootToPlayerRand 338 99  10.0 15.0 2

210  ShootToPlayerRand 161 99  14.0 15.0 2
210  ShootToPlayerRand 338 99  14.0 15.0 2
213  ShootToPlayerRand 161 99  14.0 15.0 2
213  ShootToPlayerRand 338 99  14.0 15.0 2
216  ShootToPlayerRand 161 99  14.0 15.0 2
216  ShootToPlayerRand 338 99  14.0 15.0 2
219  ShootToPlayerRand 161 99  14.0 15.0 2
219  ShootToPlayerRand 338 99  14.0 15.0 2
222  ShootToPlayerRand 161 99  14.0 15.0 2
222  ShootToPlayerRand 338 99  14.0 15.0 2
225  ShootToPlayerRand 161 99  14.0 15.0 2
225  ShootToPlayerRand 338 99  14.0 15.0 2
228  ShootToPlayerRand 161 99  14.0 15.0 2
228  ShootToPlayerRand 338 99  14.0 15.0 2
231  ShootToPlayerRand 161 99  14.0 15.0 2
231  ShootToPlayerRand 338 99  14.0 15.0 2
234  ShootToPlayerRand 161 99  14.0 15.0 2
234  ShootToPlayerRand 338 99  14.0 15.0 2
237  ShootToPlayerRand 161 99  14.0 15.0 2
237  ShootToPlayerRand 338 99  14.0 15.0 2
240  ShootToPlayerRand 161 99  14.0 15.0 2
240  ShootToPlayerRand 338 99  14.0 15.0 2
243  ShootToPlayerRand 161 99  14.0 15.0 2
243  ShootToPlayerRand 338 99  14.0 15.0 2
246  ShootToPlayerRand 161 99  14.0 15.0 2
246  ShootToPlayerRand 338 99  14.0 15.0 2
249  ShootToPlayerRand 161 99  14.0 15.0 2
249  ShootToPlayerRand 338 99  14.0 15.0 2
252  ShootToPlayerRand 161 99  14.0 15.0 2
252  ShootToPlayerRand 338 99  14.0 15.0 2
255  ShootToPlayerRand 161 99  14.0 15.0 2
255  ShootToPlayerRand 338 99  14.0 15.0 2
258  ShootToPlayerRand 161 99  14.0 15.0 2
258  ShootToPlayerRand 338 99  14.0 15.0 2
261  ShootToPlayerRand 161 99  14.0 15.0 2
261  ShootToPlayerRand 338 99  14.0 15.0 2
264  ShootToPlayerRand 161 99  14.0 15.0 2
264  ShootToPlayerRand 338 99  14.0 15.0 2
267  ShootToPlayerRand 161 99  14.0 15.0 2
267  ShootToPlayerRand 338 99  14.0 15.0 2

300  ShootToPlayerRand 161 99  10.0 15.0 2
300  ShootToPlayerRand 338 99  10.0 15.0 2
303  ShootToPlayerRand 161 99  10.0 15.0 2
303  ShootToPlayerRand 338 99  10.0 15.0 2
306  ShootToPlayerRand 161 99  10.0 15.0 2
306  ShootToPlayerRand 338 99  10.0 15.0 2
309  ShootToPlayerRand 161 99  10.0 15.0 2
309  ShootToPlayerRand 338 99  10.0 15.0 2
312  ShootToPlayerRand 161 99  10.0 15.0 2
132  ShootToPlayerRand 338 99  10.0 15.0 2
315  ShootToPlayerRand 161 99  10.0 15.0 2
315  ShootToPlayerRand 338 99  10.0 15.0 2
318  ShootToPlayerRand 161 99  10.0 15.0 2
318  ShootToPlayerRand 338 99  10.0 15.0 2
321  ShootToPlayerRand 161 99  10.0 15.0 2
321  ShootToPlayerRand 338 99  10.0 15.0 2
324  ShootToPlayerRand 161 99  10.0 15.0 2
324  ShootToPlayerRand 338 99  10.0 15.0 2
327  ShootToPlayerRand 161 99  10.0 15.0 2
327  ShootToPlayerRand 338 99  10.0 15.0 2
330  ShootToPlayerRand 161 99  10.0 15.0 2
330  ShootToPlayerRand 338 99  10.0 15.0 2
333  ShootToPlayerRand 161 99  10.0 15.0 2
333  ShootToPlayerRand 338 99  10.0 15.0 2
336  ShootToPlayerRand 161 99  10.0 15.0 2
336  ShootToPlayerRand 338 99  10.0 15.0 2
339  ShootToPlayerRand 161 99  10.0 15.0 2
339  ShootToPlayerRand 338 99  10.0 15.0 2
342  ShootToPlayerRand 161 99  10.0 15.0 2
342  ShootToPlayerRand 338 99  10.0 15.0 2
345  ShootToPlayerRand 161 99  10.0 15.0 2
345  ShootToPlayerRand 338 99  10.0 15.0 2
348  ShootToPlayerRand 161 99  10.0 15.0 2
348  ShootToPlayerRand 338 99  10.0 15.0 2
351  ShootToPlayerRand 161 99  10.0 15.0 2
351  ShootToPlayerRand 338 99  10.0 15.0 2
354  ShootToPlayerRand 161 99  10.0 15.0 2
354  ShootToPlayerRand 338 99  10.0 15.0 2
357  ShootToPlayerRand 161 99  10.0 15.0 2
357  ShootToPlayerRand 338 99  10.0 15.0 2

300  ShootToPlayerRand 161 99  14.0 15.0 2
300  ShootToPlayerRand 338 99  14.0 15.0 2
303  ShootToPlayerRand 161 99  14.0 15.0 2
303  ShootToPlayerRand 338 99  14.0 15.0 2
306  ShootToPlayerRand 161 99  14.0 15.0 2
306  ShootToPlayerRand 338 99  14.0 15.0 2
309  ShootToPlayerRand 161 99  14.0 15.0 2
309  ShootToPlayerRand 338 99  14.0 15.0 2
312  ShootToPlayerRand 161 99  14.0 15.0 2
132  ShootToPlayerRand 338 99  14.0 15.0 2
315  ShootToPlayerRand 161 99  14.0 15.0 2
315  ShootToPlayerRand 338 99  14.0 15.0 2
318  ShootToPlayerRand 161 99  14.0 15.0 2
318  ShootToPlayerRand 338 99  14.0 15.0 2
321  ShootToPlayerRand 161 99  14.0 15.0 2
321  ShootToPlayerRand 338 99  14.0 15.0 2
324  ShootToPlayerRand 161 99  14.0 15.0 2
324  ShootToPlayerRand 338 99  14.0 15.0 2
327  ShootToPlayerRand 161 99  14.0 15.0 2
327  ShootToPlayerRand 338 99  14.0 15.0 2
330  ShootToPlayerRand 161 99  14.0 15.0 2
330  ShootToPlayerRand 338 99  14.0 15.0 2
333  ShootToPlayerRand 161 99  14.0 15.0 2
333  ShootToPlayerRand 338 99  14.0 15.0 2
336  ShootToPlayerRand 161 99  14.0 15.0 2
336  ShootToPlayerRand 338 99  14.0 15.0 2
339  ShootToPlayerRand 161 99  14.0 15.0 2
339  ShootToPlayerRand 338 99  14.0 15.0 2
342  ShootToPlayerRand 161 99  14.0 15.0 2
342  ShootToPlayerRand 338 99  14.0 15.0 2
345  ShootToPlayerRand 161 99  14.0 15.0 2
345  ShootToPlayerRand 338 99  14.0 15.0 2
348  ShootToPlayerRand 161 99  14.0 15.0 2
348  ShootToPlayerRand 338 99  14.0 15.0 2
351  ShootToPlayerRand 161 99  14.0 15.0 2
351  ShootToPlayerRand 338 99  14.0 15.0 2
354  ShootToPlayerRand 161 99  14.0 15.0 2
354  ShootToPlayerRand 338 99  14.0 15.0 2
357  ShootToPlayerRand 161 99  14.0 15.0 2
357  ShootToPlayerRand 338 99  14.0 15.0 2

390  ShootToPlayerRand 161 99  10.0 15.0 2
390  ShootToPlayerRand 338 99  10.0 15.0 2
393  ShootToPlayerRand 161 99  10.0 15.0 2
393  ShootToPlayerRand 338 99  10.0 15.0 2
396  ShootToPlayerRand 161 99  10.0 15.0 2
396  ShootToPlayerRand 338 99  10.0 15.0 2
399  ShootToPlayerRand 161 99  10.0 15.0 2
399  ShootToPlayerRand 338 99  10.0 15.0 2
402  ShootToPlayerRand 161 99  10.0 15.0 2
402  ShootToPlayerRand 338 99  10.0 15.0 2
405  ShootToPlayerRand 161 99  10.0 15.0 2
405  ShootToPlayerRand 338 99  10.0 15.0 2
408  ShootToPlayerRand 161 99  10.0 15.0 2
408  ShootToPlayerRand 338 99  10.0 15.0 2
411  ShootToPlayerRand 161 99  10.0 15.0 2
411  ShootToPlayerRand 338 99  10.0 15.0 2
414  ShootToPlayerRand 161 99  10.0 15.0 2
414  ShootToPlayerRand 338 99  10.0 15.0 2
417  ShootToPlayerRand 161 99  10.0 15.0 2
417  ShootToPlayerRand 338 99  10.0 15.0 2
420  ShootToPlayerRand 161 99  10.0 15.0 2
420  ShootToPlayerRand 338 99  10.0 15.0 2
423  ShootToPlayerRand 161 99  10.0 15.0 2
423  ShootToPlayerRand 338 99  10.0 15.0 2
426  ShootToPlayerRand 161 99  10.0 15.0 2
426  ShootToPlayerRand 338 99  10.0 15.0 2
429  ShootToPlayerRand 161 99  10.0 15.0 2
429  ShootToPlayerRand 338 99  10.0 15.0 2
432  ShootToPlayerRand 161 99  10.0 15.0 2
432  ShootToPlayerRand 338 99  10.0 15.0 2
435  ShootToPlayerRand 161 99  10.0 15.0 2
435  ShootToPlayerRand 338 99  10.0 15.0 2
438  ShootToPlayerRand 161 99  10.0 15.0 2
438  ShootToPlayerRand 338 99  10.0 15.0 2
441  ShootToPlayerRand 161 99  10.0 15.0 2
441  ShootToPlayerRand 338 99  10.0 15.0 2
444  ShootToPlayerRand 161 99  10.0 15.0 2
444  ShootToPlayerRand 338 99  10.0 15.0 2
447  ShootToPlayerRand 161 99  10.0 15.0 2
447  ShootToPlayerRand 338 99  10.0 15.0 2

390  ShootToPlayerRand 161 99  14.0 15.0 2
390  ShootToPlayerRand 338 99  14.0 15.0 2
393  ShootToPlayerRand 161 99  14.0 15.0 2
393  ShootToPlayerRand 338 99  14.0 15.0 2
396  ShootToPlayerRand 161 99  14.0 15.0 2
396  ShootToPlayerRand 338 99  14.0 15.0 2
399  ShootToPlayerRand 161 99  14.0 15.0 2
399  ShootToPlayerRand 338 99  14.0 15.0 2
402  ShootToPlayerRand 161 99  14.0 15.0 2
402  ShootToPlayerRand 338 99  14.0 15.0 2
405  ShootToPlayerRand 161 99  14.0 15.0 2
405  ShootToPlayerRand 338 99  14.0 15.0 2
408  ShootToPlayerRand 161 99  14.0 15.0 2
408  ShootToPlayerRand 338 99  14.0 15.0 2
411  ShootToPlayerRand 161 99  14.0 15.0 2
411  ShootToPlayerRand 338 99  14.0 15.0 2
414  ShootToPlayerRand 161 99  14.0 15.0 2
414  ShootToPlayerRand 338 99  14.0 15.0 2
417  ShootToPlayerRand 161 99  14.0 15.0 2
417  ShootToPlayerRand 338 99  14.0 15.0 2
420  ShootToPlayerRand 161 99  14.0 15.0 2
420  ShootToPlayerRand 338 99  14.0 15.0 2
423  ShootToPlayerRand 161 99  14.0 15.0 2
423  ShootToPlayerRand 338 99  14.0 15.0 2
426  ShootToPlayerRand 161 99  14.0 15.0 2
426  ShootToPlayerRand 338 99  14.0 15.0 2
429  ShootToPlayerRand 161 99  14.0 15.0 2
429  ShootToPlayerRand 338 99  14.0 15.0 2
432  ShootToPlayerRand 161 99  14.0 15.0 2
432  ShootToPlayerRand 338 99  14.0 15.0 2
435  ShootToPlayerRand 161 99  14.0 15.0 2
435  ShootToPlayerRand 338 99  14.0 15.0 2
438  ShootToPlayerRand 161 99  14.0 15.0 2
438  ShootToPlayerRand 338 99  14.0 15.0 2
441  ShootToPlayerRand 161 99  14.0 15.0 2
441  ShootToPlayerRand 338 99  14.0 15.0 2
444  ShootToPlayerRand 161 99  14.0 15.0 2
444  ShootToPlayerRand 338 99  14.0 15.0 2
447  ShootToPlayerRand 161 99  14.0 15.0 2
447  ShootToPlayerRand 338 99  14.0 15.0 2

510  ShootLaser        127 118 12.0
510  ShootLaser        372 118 12.0
510  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
510  ShootToPlayer     250 88  9.0  -16.0 -8.0 0.0 8.0 16.0
522  ShootLaser        162 118 12.0
522  ShootLaser        337 118 12.0
522  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0
522  ShootToPlayer     250 88  9.0  -12.0 -4.0 4.0 12.0
534  ShootLaser        127 118 12.0
534  ShootLaser        337 118 12.0
534  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
534  ShootToPlayer     250 88  9.0  -16.0 -8.0 0.0 8.0 16.0
546  ShootLaser        162 118 12.0
546  ShootLaser        372 118 12.0
546  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0
546  ShootToPlayer     250 88  9.0  -12.0 -4.0 4.0 12.0

558  ShootLaser        127 118 12.0
558  ShootLaser        372 118 12.0
558  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
558  ShootToPlayer     250 88  9.0  -16.0 -8.0 0.0 8.0 16.0
570  ShootLaser        162 118 12.0
570  ShootLaser        337 118 12.0
570  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0
570  ShootToPlayer     250 88  9.0  -12.0 -4.0 4.0 12.0
582  ShootLaser        127 118 12.0
582  ShootLaser        337 118 12.0
582  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
582  ShootToPlayer     250 88  9.0  -16.0 -8.0 0.0 8.0 16.0
594  ShootLaser        162 118 12.0
594  ShootLaser        372 118 12.0
594  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0
594  ShootToPlayer     250 88  9.0  -12.0 -4.0 4.0 12.0

606  ShootLaser        127 118 12.0
606  ShootLaser        372 118 12.0
606  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
606  ShootToPlayer     250 88  9.0  -16.0 -8.0 0.0 8.0 16.0
618  ShootLaser        162 118 12.0
618  ShootLaser        337 118 12.0
618  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0
618  ShootToPlayer     250 88  9.0  -12.0 -4.0 4.0 12.0
630  ShootLaser        127 118 12.0
630  ShootLaser        337 118 12.0
630  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
630  ShootToPlayer     250 88  9.0  -16.0 -8.0 0.0 8.0 16.0
642  ShootLaser        162 118 12.0
642  ShootLaser        372 118 12.0
642  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0
642  ShootToPlayer     250 88  9.0  -12.0 -4.0 4.0 12.0

654  ShootLaser        127 118 12.0
654  ShootLaser        372 118 12.0
654  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
654  ShootToPlayer     250 88  9.0  -16.0 -8.0 0.0 8.0 16.0
666  ShootLaser        162 118 12.0
666  ShootLaser        337 118 12.0
666  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0
666  ShootToPlayer     250 88  9.0  -12.0 -4.0 4.0 12.0
678  ShootLaser        127 118 12.0
678  ShootLaser        337 118 12.0
678  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
678  ShootToPlayer     250 88  9.0  -16.0 -8.0 0.0 8.0 16.0
690  ShootLaser        162 118 12.0
690  ShootLaser        372 118 12.0
690  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0
690  ShootToPlayer     250 88  9.0  -12.0 -4.0 4.0 12.0

702  ShootLaser        127 118 12.0
702  ShootLaser        372 118 12.0
702  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
702  ShootToPlayer     250 88  9.0  -16.0 -8.0 0.0 8.0 16.0
714  ShootLaser        162 118 12.0
714  ShootLaser        337 118 12.0
714  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0
714  ShootToPlayer     250 88  9.0  -12.0 -4.0 4.0 12.0
726  ShootLaser        127 118 12.0
726  ShootLaser        337 118 12.0
726  ShootToPlayer     250 88  8.0  -16.0 -8.0 0.0 8.0 16.0
726  ShootToPlayer     250 88  9.0  -16.0 -8.0 0.0 8.0 16.0
738  ShootLaser        162 118 12.0
738  ShootLaser        372 118 12.0
738  ShootToPlayer     250 88  8.0  -12.0 -4.0 4.0 12.0
738  ShootToPlayer     250 88  9.0  -12.0 -4.0 4.0 12.0

800  Shoot             194 100 8.0 41.0
800  Shoot             305 100 8.0 139.0
805  Shoot             194 100 8.0 49.0
805  Shoot             305 100 8.0 131.0
810  Shoot             194 100 8.0 57.0
810  Shoot             305 100 8.0 123.0
815  Shoot             194 100 8.0 65.0
815  Shoot             305 100 8.0 115.0
820  Shoot             194 100 8.0 73.0
820  Shoot             305 100 8.0 107.0
825  Shoot             194 100 8.0 81.0
825  Shoot             305 100 8.0 99.0
830  Shoot             194 100 8.0 89.0
830  Shoot             305 100 8.0 91.0
835  Shoot             194 100 8.0 97.0
835  Shoot             305 100 8.0 83.0
840  Shoot             194 100 8.0 105.0
840  Shoot             305 100 8.0 75.0
845  Shoot             194 100 8.0 113.0
845  Shoot             305 100 8.0 67.0
850  Shoot             194 100 8.0 121.0
850  Shoot             305 100 8.0 59.0
855  Shoot             194 100 8.0 129.0
855  Shoot             305 100 8.0 51.0
860  Shoot             194 100 8.0 137.0
860  Shoot             305 100 8.0 43.0
865  Shoot             194 100 8.0 129.0
865  Shoot             305 100 8.0 51.0
870  Shoot             194 100 8.0 121.0
870  Shoot             305 100 8.0 59.0
875  Shoot             194 100 8.0 113.0
875  Shoot             305 100 8.0 67.0
880  Shoot             194 100 8.0 105.0
880  Shoot             305 100 8.0 75.0
885  Shoot             194 100 8.0 97.0
885  Shoot             305 100 8.0 83.0
890  Shoot             194 100 8.0 89.0
890  Shoot             305 100 8.0 91.0
895  Shoot             194 100 8.0 81.0
895  Shoot             305 100 8.0 99.0
900  Shoot             194 100 8.0 73.0
900  Shoot             305 100 8.0 107.0
905  Shoot             194 100 8.0 65.0
905  Shoot             305 100 8.0 115.0
910  Shoot             194 100 8.0 57.0
910  Shoot             305 100 8.0 123.0
915  Shoot             194 100 8.0 49.0
915  Shoot             305 100 8.0 131.0

800  Shoot             194 100 9.0 41.0
800  Shoot             305 100 9.0 139.0
805  Shoot             194 100 9.0 49.0
805  Shoot             305 100 9.0 131.0
810  Shoot             194 100 9.0 57.0
810  Shoot             305 100 9.0 123.0
815  Shoot             194 100 9.0 65.0
815  Shoot             305 100 9.0 115.0
820  Shoot             194 100 9.0 73.0
820  Shoot             305 100 9.0 107.0
825  Shoot             194 100 9.0 81.0
825  Shoot             305 100 9.0 99.0
830  Shoot             194 100 9.0 89.0
830  Shoot             305 100 9.0 91.0
835  Shoot             194 100 9.0 97.0
835  Shoot             305 100 9.0 83.0
840  Shoot             194 100 9.0 105.0
840  Shoot             305 100 9.0 75.0
845  Shoot             194 100 9.0 113.0
845  Shoot             305 100 9.0 67.0
850  Shoot             194 100 9.0 121.0
850  Shoot             305 100 9.0 59.0
855  Shoot             194 100 9.0 129.0
855  Shoot             305 100 9.0 51.0
860  Shoot             194 100 9.0 137.0
860  Shoot             305 100 9.0 43.0
865  Shoot             194 100 9.0 129.0
865  Shoot             305 100 9.0 51.0
870  Shoot             194 100 9.0 121.0
870  Shoot             305 100 9.0 59.0
875  Shoot             194 100 9.0 113.0
875  Shoot             305 100 9.0 67.0
880  Shoot             194 100 9.0 105.0
880  Shoot             305 100 9.0 75.0
885  Shoot             194 100 9.0 97.0
885  Shoot             305 100 9.0 83.0
890  Shoot             194 100 9.0 89.0
890  Shoot             305 100 9.0 91.0
895  Shoot             194 100 9.0 81.0
895  Shoot             305 100 9.0 99.0
900  Shoot             194 100 9.0 73.0
900  Shoot             305 100 9.0 107.0
905  Shoot             194 100 9.0 65.0
905  Shoot             305 100 9.0 115.0
910  Shoot             194 100 9.0 57.0
910  Shoot             305 100 9.0 123.0
915  Shoot             194 100 9.0 49.0
915  Shoot             305 100 9.0 131.0

800  Shoot             194 100 10.0 41.0
800  Shoot             305 100 10.0 139.0
805  Shoot             194 100 10.0 49.0
805  Shoot             305 100 10.0 131.0
810  Shoot             194 100 10.0 57.0
810  Shoot             305 100 10.0 123.0
815  Shoot             194 100 10.0 65.0
815  Shoot             305 100 10.0 115.0
820  Shoot             194 100 10.0 73.0
820  Shoot             305 100 10.0 107.0
825  Shoot             194 100 10.0 81.0
825  Shoot             305 100 10.0 99.0
830  Shoot             194 100 10.0 89.0
830  Shoot             305 100 10.0 91.0
835  Shoot             194 100 10.0 97.0
835  Shoot             305 100 10.0 83.0
840  Shoot             194 100 10.0 105.0
840  Shoot             305 100 10.0 75.0
845  Shoot             194 100 10.0 113.0
845  Shoot             305 100 10.0 67.0
850  Shoot             194 100 10.0 121.0
850  Shoot             305 100 10.0 59.0
855  Shoot             194 100 10.0 129.0
855  Shoot             305 100 10.0 51.0
860  Shoot             194 100 10.0 137.0
860  Shoot             305 100 10.0 43.0
865  Shoot             194 100 10.0 129.0
865  Shoot             305 100 10.0 51.0
870  Shoot             194 100 10.0 121.0
870  Shoot             305 100 10.0 59.0
875  Shoot             194 100 10.0 113.0
875  Shoot             305 100 10.0 67.0
880  Shoot             194 100 10.0 105.0
880  Shoot             305 100 10.0 75.0
885  Shoot             194 100 10.0 97.0
885  Shoot             305 100 10.0 83.0
890  Shoot             194 100 10.0 89.0
890  Shoot             305 100 10.0 91.0
895  Shoot             194 100 10.0 81.0
895  Shoot             305 100 10.0 99.0
900  Shoot             194 100 10.0 73.0
900  Shoot             305 100 10.0 107.0
905  Shoot             194 100 10.0 65.0
905  Shoot             305 100 10.0 115.0
910  Shoot             194 100 10.0 57.0
910  Shoot             305 100 10.0 123.0
915  Shoot             194 100 10.0 49.0
915  Shoot             305 100 10.0 131.0
 
920  Shoot             194 100 8.0 45.0
920  Shoot             305 100 8.0 135.0
925  Shoot             194 100 8.0 53.0
925  Shoot             305 100 8.0 127.0
930  Shoot             194 100 8.0 61.0
930  Shoot             305 100 8.0 119.0
935  Shoot             194 100 8.0 69.0
935  Shoot             305 100 8.0 111.0
940  Shoot             194 100 8.0 77.0
940  Shoot             305 100 8.0 103.0
945  Shoot             194 100 8.0 85.0
945  Shoot             305 100 8.0 95.0
950  Shoot             194 100 8.0 93.0
950  Shoot             305 100 8.0 87.0
955  Shoot             194 100 8.0 101.0
955  Shoot             305 100 8.0 79.0
960  Shoot             194 100 8.0 109.0
960  Shoot             305 100 8.0 71.0
965  Shoot             194 100 8.0 117.0
965  Shoot             305 100 8.0 63.0
970  Shoot             194 100 8.0 125.0
970  Shoot             305 100 8.0 55.0
975  Shoot             194 100 8.0 133.0
975  Shoot             305 100 8.0 47.0
980  Shoot             194 100 8.0 133.0
980  Shoot             305 100 8.0 47.0
985  Shoot             194 100 8.0 125.0
985  Shoot             305 100 8.0 55.0
990  Shoot             194 100 8.0 117.0
990  Shoot             305 100 8.0 63.0
995  Shoot             194 100 8.0 109.0
995  Shoot             305 100 8.0 71.0
1000 Shoot             194 100 8.0 101.0
1000 Shoot             305 100 8.0 79.0
1005 Shoot             194 100 8.0 93.0
1005 Shoot             305 100 8.0 87.0
1010 Shoot             194 100 8.0 85.0
1010 Shoot             305 100 8.0 95.0
1015 Shoot             194 100 8.0 77.0
1015 Shoot             305 100 8.0 103.0
1020 Shoot             194 100 8.0 69.0
1020 Shoot             305 100 8.0 111.0
1025 Shoot             194 100 8.0 61.0
1025 Shoot             305 100 8.0 119.0
1030 Shoot             194 100 8.0 53.0
1030 Shoot             305 100 8.0 127.0
1035 Shoot             194 100 8.0 45.0
1035 Shoot             305 100 8.0 135.0
1040 Shoot             194 100 8.0 49.0
1040 Shoot             305 100 8.0 131.0

920  Shoot             194 100 9.0 45.0
920  Shoot             305 100 9.0 135.0
925  Shoot             194 100 9.0 53.0
925  Shoot             305 100 9.0 127.0
930  Shoot             194 100 9.0 61.0
930  Shoot             305 100 9.0 119.0
935  Shoot             194 100 9.0 69.0
935  Shoot             305 100 9.0 111.0
940  Shoot             194 100 9.0 77.0
940  Shoot             305 100 9.0 103.0
945  Shoot             194 100 9.0 85.0
945  Shoot             305 100 9.0 95.0
950  Shoot             194 100 9.0 93.0
950  Shoot             305 100 9.0 87.0
955  Shoot             194 100 9.0 101.0
955  Shoot             305 100 9.0 79.0
960  Shoot             194 100 9.0 109.0
960  Shoot             305 100 9.0 71.0
965  Shoot             194 100 9.0 117.0
965  Shoot             305 100 9.0 63.0
970  Shoot             194 100 9.0 125.0
970  Shoot             305 100 9.0 55.0
975  Shoot             194 100 9.0 133.0
975  Shoot             305 100 9.0 47.0
980  Shoot             194 100 9.0 133.0
980  Shoot             305 100 9.0 47.0
985  Shoot             194 100 9.0 125.0
985  Shoot             305 100 9.0 55.0
990  Shoot             194 100 9.0 117.0
990  Shoot             305 100 9.0 63.0
995  Shoot             194 100 9.0 109.0
995  Shoot             305 100 9.0 71.0
1000 Shoot             194 100 9.0 101.0
1000 Shoot             305 100 9.0 79.0
1005 Shoot             194 100 9.0 93.0
1005 Shoot             305 100 9.0 87.0
1010 Shoot             194 100 9.0 85.0
1010 Shoot             305 100 9.0 95.0
1015 Shoot             194 100 9.0 77.0
1015 Shoot             305 100 9.0 103.0
1020 Shoot             194 100 9.0 69.0
1020 Shoot             305 100 9.0 111.0
1025 Shoot             194 100 9.0 61.0
1025 Shoot             305 100 9.0 119.0
1030 Shoot             194 100 9.0 53.0
1030 Shoot             305 100 9.0 127.0
1035 Shoot             194 100 9.0 45.0
1035 Shoot             305 100 9.0 135.0
1040 Shoot             194 100 9.0 49.0
1040 Shoot             305 100 9.0 131.0

920  Shoot             194 100 10.0 45.0
920  Shoot             305 100 10.0 135.0
925  Shoot             194 100 10.0 53.0
925  Shoot             305 100 10.0 127.0
930  Shoot             194 100 10.0 61.0
930  Shoot             305 100 10.0 119.0
935  Shoot             194 100 10.0 69.0
935  Shoot             305 100 10.0 111.0
940  Shoot             194 100 10.0 77.0
940  Shoot             305 100 10.0 103.0
945  Shoot             194 100 10.0 85.0
945  Shoot             305 100 10.0 95.0
950  Shoot             194 100 10.0 93.0
950  Shoot             305 100 10.0 87.0
955  Shoot             194 100 10.0 101.0
955  Shoot             305 100 10.0 79.0
960  Shoot             194 100 10.0 109.0
960  Shoot             305 100 10.0 71.0
965  Shoot             194 100 10.0 117.0
965  Shoot             305 100 10.0 63.0
970  Shoot             194 100 10.0 125.0
970  Shoot             305 100 10.0 55.0
975  Shoot             194 100 10.0 133.0
975  Shoot             305 100 10.0 47.0
980  Shoot             194 100 10.0 133.0
980  Shoot             305 100 10.0 47.0
985  Shoot             194 100 10.0 125.0
985  Shoot             305 100 10.0 55.0
990  Shoot             194 100 10.0 117.0
990  Shoot             305 100 10.0 63.0
995  Shoot             194 100 10.0 109.0
995  Shoot             305 100 10.0 71.0
1000 Shoot             194 100 10.0 101.0
1000 Shoot             305 100 10.0 79.0
1005 Shoot             194 100 10.0 93.0
1005 Shoot             305 100 10.0 87.0
1010 Shoot             194 100 10.0 85.0
1010 Shoot             305 100 10.0 95.0
1015 Shoot             194 100 10.0 77.0
1015 Shoot             305 100 10.0 103.0
1020 Shoot             194 100 10.0 69.0
1020 Shoot             305 100 10.0 111.0
1025 Shoot             194 100 10.0 61.0
1025 Shoot             305 100 10.0 119.0
1030 Shoot             194 100 10.0 53.0
1030 Shoot             305 100 10.0 127.0
1035 Shoot             194 100 10.0 45.0
1035 Shoot             305 100 10.0 135.0
1040 Shoot             194 100 10.0 49.0
1040 Shoot             305 100 10.0 131.0

1045 Shoot             194 100 8.0 57.0
1045 Shoot             305 100 8.0 123.0
1050 Shoot             194 100 8.0 65.0
1050 Shoot             305 100 8.0 115.0
1055 Shoot             194 100 8.0 73.0
1055 Shoot             305 100 8.0 107.0
1060 Shoot             194 100 8.0 81.0
1060 Shoot             305 100 8.0 99.0
1065 Shoot             194 100 8.0 89.0
1065 Shoot             305 100 8.0 91.0
1070 Shoot             194 100 8.0 97.0
1070 Shoot             305 100 8.0 83.0
1075 Shoot             194 100 8.0 105.0
1075 Shoot             305 100 8.0 75.0
1080 Shoot             194 100 8.0 113.0
1080 Shoot             305 100 8.0 67.0
1085 Shoot             194 100 8.0 121.0
1085 Shoot             305 100 8.0 59.0
1090 Shoot             194 100 8.0 129.0
1090 Shoot             305 100 8.0 51.0
1095 Shoot             194 100 8.0 137.0
1095 Shoot             305 100 8.0 43.0
1100 Shoot             194 100 8.0 129.0
1100 Shoot             305 100 8.0 51.0
1105 Shoot             194 100 8.0 121.0
1105 Shoot             305 100 8.0 59.0
1110 Shoot             194 100 8.0 113.0
1110 Shoot             305 100 8.0 67.0
1115 Shoot             194 100 8.0 105.0
1115 Shoot             305 100 8.0 75.0
1120 Shoot             194 100 8.0 97.0
1120 Shoot             305 100 8.0 83.0
1125 Shoot             194 100 8.0 89.0
1125 Shoot             305 100 8.0 91.0
1130 Shoot             194 100 8.0 81.0
1130 Shoot             305 100 8.0 99.0
1135 Shoot             194 100 8.0 73.0
1135 Shoot             305 100 8.0 107.0
1140 Shoot             194 100 8.0 65.0
1140 Shoot             305 100 8.0 115.0
1145 Shoot             194 100 8.0 57.0
1145 Shoot             305 100 8.0 123.0
1150 Shoot             194 100 8.0 49.0
1150 Shoot             305 100 8.0 131.0
1155 Shoot             194 100 8.0 41.0
1155 Shoot             305 100 8.0 139.0

1045 Shoot             194 100 9.0 57.0
1045 Shoot             305 100 9.0 123.0
1050 Shoot             194 100 9.0 65.0
1050 Shoot             305 100 9.0 115.0
1055 Shoot             194 100 9.0 73.0
1055 Shoot             305 100 9.0 107.0
1060 Shoot             194 100 9.0 81.0
1060 Shoot             305 100 9.0 99.0
1065 Shoot             194 100 9.0 89.0
1065 Shoot             305 100 9.0 91.0
1070 Shoot             194 100 9.0 97.0
1070 Shoot             305 100 9.0 83.0
1075 Shoot             194 100 9.0 105.0
1075 Shoot             305 100 9.0 75.0
1080 Shoot             194 100 9.0 113.0
1080 Shoot             305 100 9.0 67.0
1085 Shoot             194 100 9.0 121.0
1085 Shoot             305 100 9.0 59.0
1090 Shoot             194 100 9.0 129.0
1090 Shoot             305 100 9.0 51.0
1095 Shoot             194 100 9.0 137.0
1095 Shoot             305 100 9.0 43.0
1100 Shoot             194 100 9.0 129.0
1100 Shoot             305 100 9.0 51.0
1105 Shoot             194 100 9.0 121.0
1105 Shoot             305 100 9.0 59.0
1110 Shoot             194 100 9.0 113.0
1110 Shoot             305 100 9.0 67.0
1115 Shoot             194 100 9.0 105.0
1115 Shoot             305 100 9.0 75.0
1120 Shoot             194 100 9.0 97.0
1120 Shoot             305 100 9.0 83.0
1125 Shoot             194 100 9.0 89.0
1125 Shoot             305 100 9.0 91.0
1130 Shoot             194 100 9.0 81.0
1130 Shoot             305 100 9.0 99.0
1135 Shoot             194 100 9.0 73.0
1135 Shoot             305 100 9.0 107.0
1140 Shoot             194 100 9.0 65.0
1140 Shoot             305 100 9.0 115.0
1145 Shoot             194 100 9.0 57.0
1145 Shoot             305 100 9.0 123.0
1150 Shoot             194 100 9.0 49.0
1150 Shoot             305 100 9.0 131.0
1155 Shoot             194 100 9.0 41.0
1155 Shoot             305 100 9.0 139.0

1045 Shoot             194 100 10.0 57.0
1045 Shoot             305 100 10.0 123.0
1050 Shoot             194 100 10.0 65.0
1050 Shoot             305 100 10.0 115.0
1055 Shoot             194 100 10.0 73.0
1055 Shoot             305 100 10.0 107.0
1060 Shoot             194 100 10.0 81.0
1060 Shoot             305 100 10.0 99.0
1065 Shoot             194 100 10.0 89.0
1065 Shoot             305 100 10.0 91.0
1070 Shoot             194 100 10.0 97.0
1070 Shoot             305 100 10.0 83.0
1075 Shoot             194 100 10.0 105.0
1075 Shoot             305 100 10.0 75.0
1080 Shoot             194 100 10.0 113.0
1080 Shoot             305 100 10.0 67.0
1085 Shoot             194 100 10.0 121.0
1085 Shoot             305 100 10.0 59.0
1090 Shoot             194 100 10.0 129.0
1090 Shoot             305 100 10.0 51.0
1095 Shoot             194 100 10.0 137.0
1095 Shoot             305 100 10.0 43.0
1100 Shoot             194 100 10.0 129.0
1100 Shoot             305 100 10.0 51.0
1105 Shoot             194 100 10.0 121.0
1105 Shoot             305 100 10.0 59.0
1110 Shoot             194 100 10.0 113.0
1110 Shoot             305 100 10.0 67.0
1115 Shoot             194 100 10.0 105.0
1115 Shoot             305 100 10.0 75.0
1120 Shoot             194 100 10.0 97.0
1120 Shoot             305 100 10.0 83.0
1125 Shoot             194 100 10.0 89.0
1125 Shoot             305 100 10.0 91.0
1130 Shoot             194 100 10.0 81.0
1130 Shoot             305 100 10.0 99.0
1135 Shoot             194 100 10.0 73.0
1135 Shoot             305 100 10.0 107.0
1140 Shoot             194 100 10.0 65.0
1140 Shoot             305 100 10.0 115.0
1145 Shoot             194 100 10.0 57.0
1145 Shoot             305 100 10.0 123.0
1150 Shoot             194 100 10.0 49.0
1150 Shoot             305 100 10.0 131.0
1155 Shoot             194 100 10.0 41.0
1155 Shoot             305 100 10.0 139.0
=========================
1301 SetVelX           0.0
1480 SetAwayVelX       0.25

1500 Shoot             250 88  8.0 43.0 
1503 Shoot             250 88  8.0 43.6 49.4 
1506 Shoot             250 88  8.0 44.2 50.0 55.8 
1509 Shoot             250 88  8.0 44.8 50.6 56.4 62.2 
1512 Shoot             250 88  8.0 45.4 51.2 57.0 62.8 68.6 
1515 Shoot             250 88  8.0 51.8 57.6 63.4 69.2 75.0 
1518 Shoot             250 88  8.0 58.2 64.0 69.8 75.6 81.4 
1521 Shoot             250 88  8.0 64.6 70.4 76.2 82.0 87.8 
1524 Shoot             250 88  8.0 71.0 76.8 82.6 88.4 94.2 
1527 Shoot             250 88  8.0 77.4 83.2 89.0 94.8 100.6 
1530 Shoot             250 88  8.0 83.8 89.6 95.4 101.2 107.0 
1533 Shoot             250 88  8.0 90.2 96.0 101.8 107.6 113.4 
1536 Shoot             250 88  8.0 96.6 102.4 108.2 114.0 119.8 
1539 Shoot             250 88  8.0 103.0 108.8 114.6 120.4 126.2 
1542 Shoot             250 88  8.0 109.4 115.2 121.0 126.8 132.6 
1545 Shoot             250 88  8.0 115.8 121.6 127.4 133.2 137.0 
1548 Shoot             250 88  8.0 122.2 128.0 133.8 136.4 130.6 
1551 Shoot             250 88  8.0 128.6 134.4 135.8 130.0 124.2 
1554 Shoot             250 88  8.0 135.0 135.2 129.4 123.6 117.8 
1557 Shoot             250 88  8.0 134.6 128.8 123.0 117.2 111.4 
1560 Shoot             250 88  8.0 128.2 122.4 116.6 110.8 105.0 
1563 Shoot             250 88  8.0 121.8 116.0 110.2 104.4 98.6 
1566 Shoot             250 88  8.0 115.4 109.6 103.8 98.0 92.2 
1569 Shoot             250 88  8.0 109.0 103.2 97.4 91.6 85.8 
1572 Shoot             250 88  8.0 102.6 96.8 91.0 85.2 79.4 
1575 Shoot             250 88  8.0 96.2 90.4 84.6 78.8 73.0 
1578 Shoot             250 88  8.0 89.8 84.0 78.2 72.4 66.6 
1581 Shoot             250 88  8.0 83.4 77.6 71.8 66.0 60.2 
1584 Shoot             250 88  8.0 77.0 71.2 65.4 59.6 53.8 
1587 Shoot             250 88  8.0 70.6 64.8 59.0 53.2 47.4 
1590 Shoot             250 88  8.0 64.2 58.4 52.6 46.8 43.0 
1593 Shoot             250 88  8.0 57.8 52.0 46.2 43.6 49.4 
1596 Shoot             250 88  8.0 51.4 45.6 44.2 50.0 55.8 
1599 Shoot             250 88  8.0 45.0 44.8 50.6 56.4 62.2 
1602 Shoot             250 88  8.0 45.4 51.2 57.0 62.8 68.6 
1605 Shoot             250 88  8.0 51.8 57.6 63.4 69.2 75.0 
1608 Shoot             250 88  8.0 58.2 64.0 69.8 75.6 81.4 
1611 Shoot             250 88  8.0 64.6 70.4 76.2 82.0 87.8 
1614 Shoot             250 88  8.0 71.0 76.8 82.6 88.4 94.2 
1617 Shoot             250 88  8.0 77.4 83.2 89.0 94.8 100.6 
1620 Shoot             250 88  8.0 83.8 89.6 95.4 101.2 107.0 
1623 Shoot             250 88  8.0 90.2 96.0 101.8 107.6 113.4 
1626 Shoot             250 88  8.0 96.6 102.4 108.2 114.0 119.8 
1629 Shoot             250 88  8.0 103.0 108.8 114.6 120.4 126.2 
1632 Shoot             250 88  8.0 109.4 115.2 121.0 126.8 132.6 
1635 Shoot             250 88  8.0 115.8 121.6 127.4 133.2 137.0 
1638 Shoot             250 88  8.0 122.2 128.0 133.8 136.4 130.6 
1641 Shoot             250 88  8.0 128.6 134.4 135.8 130.0 124.2 
1644 Shoot             250 88  8.0 135.0 135.2 129.4 123.6 117.8 
1647 Shoot             250 88  8.0 134.6 128.8 123.0 117.2 111.4 
1650 Shoot             250 88  8.0 128.2 122.4 116.6 110.8 105.0 
1653 Shoot             250 88  8.0 121.8 116.0 110.2 104.4 98.6 
1656 Shoot             250 88  8.0 115.4 109.6 103.8 98.0 92.2 
1659 Shoot             250 88  8.0 109.0 103.2 97.4 91.6 85.8 
1662 Shoot             250 88  8.0 102.6 96.8 91.0 85.2 79.4 
1665 Shoot             250 88  8.0 96.2 90.4 84.6 78.8 73.0 
1668 Shoot             250 88  8.0 89.8 84.0 78.2 72.4 66.6 
1671 Shoot             250 88  8.0 83.4 77.6 71.8 66.0 60.2 
1674 Shoot             250 88  8.0 77.0 71.2 65.4 59.6 53.8 
1677 Shoot             250 88  8.0 70.6 64.8 59.0 53.2 47.4 
1680 Shoot             250 88  8.0 64.2 58.4 52.6 46.8 43.0 
1683 Shoot             250 88  8.0 57.8 52.0 46.2 43.6 49.4 
1686 Shoot             250 88  8.0 51.4 45.6 44.2 50.0 55.8 
1689 Shoot             250 88  8.0 45.0 44.8 50.6 56.4 62.2 
1692 Shoot             250 88  8.0 45.4 51.2 57.0 62.8 68.6 
1695 Shoot             250 88  8.0 51.8 57.6 63.4 69.2 75.0 
1698 Shoot             250 88  8.0 58.2 64.0 69.8 75.6 81.4 
1701 Shoot             250 88  8.0 64.6 70.4 76.2 82.0 87.8 
1704 Shoot             250 88  8.0 71.0 76.8 82.6 88.4 94.2 
1707 Shoot             250 88  8.0 77.4 83.2 89.0 94.8 100.6 
1710 Shoot             250 88  8.0 83.8 89.6 95.4 101.2 107.0 
1713 Shoot             250 88  8.0 90.2 96.0 101.8 107.6 113.4 
1716 Shoot             250 88  8.0 96.6 102.4 108.2 114.0 119.8 
1719 Shoot             250 88  8.0 103.0 108.8 114.6 120.4 126.2 
1722 Shoot             250 88  8.0 109.4 115.2 121.0 126.8 132.6 
1725 Shoot             250 88  8.0 115.8 121.6 127.4 133.2 137.0 
1728 Shoot             250 88  8.0 122.2 128.0 133.8 136.4 130.6 
1731 Shoot             250 88  8.0 128.6 134.4 135.8 130.0 124.2 
1734 Shoot             250 88  8.0 135.0 135.2 129.4 123.6 117.8 
1737 Shoot             250 88  8.0 134.6 128.8 123.0 117.2 111.4 
1740 Shoot             250 88  8.0 128.2 122.4 116.6 110.8 105.0 
1743 Shoot             250 88  8.0 121.8 116.0 110.2 104.4 98.6 
1746 Shoot             250 88  8.0 115.4 109.6 103.8 98.0 92.2 
1749 Shoot             250 88  8.0 109.0 103.2 97.4 91.6 85.8 
1752 Shoot             250 88  8.0 102.6 96.8 91.0 85.2 79.4 
1755 Shoot             250 88  8.0 96.2 90.4 84.6 78.8 73.0 
1758 Shoot             250 88  8.0 89.8 84.0 78.2 72.4 66.6 
1761 Shoot             250 88  8.0 83.4 77.6 71.8 66.0 60.2 
1764 Shoot             250 88  8.0 77.0 71.2 65.4 59.6 53.8 
1767 Shoot             250 88  8.0 70.6 64.8 59.0 53.2 47.4 
1770 Shoot             250 88  8.0 64.2 58.4 52.6 46.8 
1773 Shoot             250 88  8.0 57.8 52.0 46.2 
1776 Shoot             250 88  8.0 51.4 45.6 
1779 Shoot             250 88  8.0 45.0 


1850 SetVelX           0.0
1850 SetVelY           6.0
1950 SetVelY           0.0
2040 SetVelY           -3.0

2070 ShootToPlayerRand 161 99  4.0 60.0 4
2070 ShootToPlayerRand 338 99  4.0 60.0 4
2076 ShootToPlayerRand 161 99  4.0 60.0 4
2076 ShootToPlayerRand 338 99  4.0 60.0 4
2082 ShootToPlayerRand 161 99  4.0 60.0 4
2082 ShootToPlayerRand 338 99  4.0 60.0 4
2088 ShootToPlayerRand 161 99  4.0 60.0 4
2088 ShootToPlayerRand 338 99  4.0 60.0 4
2094 ShootToPlayerRand 161 99  4.0 60.0 4
2094 ShootToPlayerRand 338 99  4.0 60.0 4
2100 ShootToPlayerRand 161 99  4.0 60.0 4
2100 ShootToPlayerRand 338 99  4.0 60.0 4
2106 ShootToPlayerRand 161 99  4.0 60.0 4
2106 ShootToPlayerRand 338 99  4.0 60.0 4
2112 ShootToPlayerRand 161 99  4.0 60.0 4
2112 ShootToPlayerRand 338 99  4.0 60.0 4
2118 ShootToPlayerRand 161 99  4.0 60.0 4
2118 ShootToPlayerRand 338 99  4.0 60.0 4
2124 ShootToPlayerRand 161 99  4.0 60.0 4
2124 ShootToPlayerRand 338 99  4.0 60.0 4
2130 ShootToPlayerRand 161 99  4.0 60.0 4
2130 ShootToPlayerRand 338 99  4.0 60.0 4
2136 ShootToPlayerRand 161 99  4.0 60.0 4
2136 ShootToPlayerRand 338 99  4.0 60.0 4
2142 ShootToPlayerRand 161 99  4.0 60.0 4
2142 ShootToPlayerRand 338 99  4.0 60.0 4
2148 ShootToPlayerRand 161 99  4.0 60.0 4
2148 ShootToPlayerRand 338 99  4.0 60.0 4
2154 ShootToPlayerRand 161 99  4.0 60.0 4
2154 ShootToPlayerRand 338 99  4.0 60.0 4
2160 ShootToPlayerRand 161 99  4.0 60.0 4
2160 ShootToPlayerRand 338 99  4.0 60.0 4
2166 ShootToPlayerRand 161 99  4.0 60.0 4
2166 ShootToPlayerRand 338 99  4.0 60.0 4
2172 ShootToPlayerRand 161 99  4.0 60.0 4
2172 ShootToPlayerRand 338 99  4.0 60.0 4
2178 ShootToPlayerRand 161 99  4.0 60.0 4
2178 ShootToPlayerRand 338 99  4.0 60.0 4
2184 ShootToPlayerRand 161 99  4.0 60.0 4
2184 ShootToPlayerRand 338 99  4.0 60.0 4

2240 SetVelY           0.0
2310 SetAwayVelX       0.25


2310 ShootToPlayer     250 88   16.0 0.0
2312 ShootToPlayer     250 88   16.0 0.0
2314 ShootToPlayer     250 88   16.0 0.0
2316 ShootToPlayer     250 88   16.0 0.0
2318 ShootToPlayer     250 88   16.0 0.0
2320 ShootToPlayer     250 88   16.0 0.0
2322 ShootToPlayer     250 88   16.0 0.0
2324 ShootToPlayer     250 88   16.0 0.0
2326 ShootToPlayer     250 88   16.0 0.0
2328 ShootToPlayer     250 88   16.0 0.0
2330 ShootToPlayer     250 88   16.0 0.0
2332 ShootToPlayer     250 88   16.0 0.0
2334 ShootToPlayer     250 88   16.0 0.0
2336 ShootToPlayer     250 88   16.0 0.0
2338 ShootToPlayer     250 88   16.0 0.0
2340 ShootToPlayer     250 88   16.0 0.0
2342 ShootToPlayer     250 88   16.0 0.0
2344 ShootToPlayer     250 88   16.0 0.0
2346 ShootToPlayer     250 88   16.0 0.0
2348 ShootToPlayer     250 88   16.0 0.0
2350 ShootToPlayer     250 88   16.0 0.0
2352 ShootToPlayer     250 88   16.0 0.0
2354 ShootToPlayer     250 88   16.0 0.0
2356 ShootToPlayer     250 88   16.0 0.0
2358 ShootToPlayer     250 88   16.0 0.0
2360 ShootToPlayer     250 88   16.0 0.0
2362 ShootToPlayer     250 88   16.0 0.0
2364 ShootToPlayer     250 88   16.0 0.0
2366 ShootToPlayer     250 88   16.0 0.0
2368 ShootToPlayer     250 88   16.0 0.0
2370 ShootToPlayer     250 88   16.0 0.0
2372 ShootToPlayer     250 88   16.0 0.0
2374 ShootToPlayer     250 88   16.0 0.0
2376 ShootToPlayer     250 88   16.0 0.0
2378 ShootToPlayer     250 88   16.0 0.0
2380 ShootToPlayer     250 88   16.0 0.0
2382 ShootToPlayer     250 88   16.0 0.0
2384 ShootToPlayer     250 88   16.0 0.0
2386 ShootToPlayer     250 88   16.0 0.0
2388 ShootToPlayer     250 88   16.0 0.0
2390 ShootToPlayer     250 88   16.0 0.0
2392 ShootToPlayer     250 88   16.0 0.0
2394 ShootToPlayer     250 88   16.0 0.0
2396 ShootToPlayer     250 88   16.0 0.0
2398 ShootToPlayer     250 88   16.0 0.0
2400 ShootToPlayer     250 88   16.0 0.0
2402 ShootToPlayer     250 88   16.0 0.0
2404 ShootToPlayer     250 88   16.0 0.0
2406 ShootToPlayer     250 88   16.0 0.0
2408 ShootToPlayer     250 88   16.0 0.0
2410 ShootToPlayer     250 88   16.0 0.0
2412 ShootToPlayer     250 88   16.0 0.0
2414 ShootToPlayer     250 88   16.0 0.0
2416 ShootToPlayer     250 88   16.0 0.0
2418 ShootToPlayer     250 88   16.0 0.0
2420 ShootToPlayer     250 88   16.0 0.0
2422 ShootToPlayer     250 88   16.0 0.0
2424 ShootToPlayer     250 88   16.0 0.0
2426 ShootToPlayer     250 88   16.0 0.0
2428 ShootToPlayer     250 88   16.0 0.0
2430 ShootToPlayer     250 88   16.0 0.0
2432 ShootToPlayer     250 88   16.0 0.0
2434 ShootToPlayer     250 88   16.0 0.0
2436 ShootToPlayer     250 88   16.0 0.0
2438 ShootToPlayer     250 88   16.0 0.0
2440 ShootToPlayer     250 88   16.0 0.0
2442 ShootToPlayer     250 88   16.0 0.0
2444 ShootToPlayer     250 88   16.0 0.0
2446 ShootToPlayer     250 88   16.0 0.0
2448 ShootToPlayer     250 88   16.0 0.0
2450 ShootToPlayer     250 88   16.0 0.0
2452 ShootToPlayer     250 88   16.0 0.0
2454 ShootToPlayer     250 88   16.0 0.0
2456 ShootToPlayer     250 88   16.0 0.0
2458 ShootToPlayer     250 88   16.0 0.0
2460 ShootToPlayer     250 88   16.0 0.0
2462 ShootToPlayer     250 88   16.0 0.0
2464 ShootToPlayer     250 88   16.0 0.0
2466 ShootToPlayer     250 88   16.0 0.0
2468 ShootToPlayer     250 88   16.0 0.0
2470 ShootToPlayer     250 88   16.0 0.0
2472 ShootToPlayer     250 88   16.0 0.0
2474 ShootToPlayer     250 88   16.0 0.0
2476 ShootToPlayer     250 88   16.0 0.0
2478 ShootToPlayer     250 88   16.0 0.0
2480 ShootToPlayer     250 88   16.0 0.0
2482 ShootToPlayer     250 88   16.0 0.0
2484 ShootToPlayer     250 88   16.0 0.0
2486 ShootToPlayer     250 88   16.0 0.0
2488 ShootToPlayer     250 88   16.0 0.0
2490 ShootToPlayer     250 88   16.0 0.0
2492 ShootToPlayer     250 88   16.0 0.0
2494 ShootToPlayer     250 88   16.0 0.0
2496 ShootToPlayer     250 88   16.0 0.0
2498 ShootToPlayer     250 88   16.0 0.0
2500 ShootToPlayer     250 88   16.0 0.0
2502 ShootToPlayer     250 88   16.0 0.0
2504 ShootToPlayer     250 88   16.0 0.0
2506 ShootToPlayer     250 88   16.0 0.0
2508 ShootToPlayer     250 88   16.0 0.0
2510 ShootToPlayer     250 88   16.0 0.0
2512 ShootToPlayer     250 88   16.0 0.0
2514 ShootToPlayer     250 88   16.0 0.0
2516 ShootToPlayer     250 88   16.0 0.0
2518 ShootToPlayer     250 88   16.0 0.0
2520 ShootToPlayer     250 88   16.0 0.0
2522 ShootToPlayer     250 88   16.0 0.0
2524 ShootToPlayer     250 88   16.0 0.0
2526 ShootToPlayer     250 88   16.0 0.0
2528 ShootToPlayer     250 88   16.0 0.0
2530 ShootToPlayer     250 88   16.0 0.0
2532 ShootToPlayer     250 88   16.0 0.0
2534 ShootToPlayer     250 88   16.0 0.0
2536 ShootToPlayer     250 88   16.0 0.0
2538 ShootToPlayer     250 88   16.0 0.0
2540 ShootToPlayer     250 88   16.0 0.0
2542 ShootToPlayer     250 88   16.0 0.0
2544 ShootToPlayer     250 88   16.0 0.0
2546 ShootToPlayer     250 88   16.0 0.0
2548 ShootToPlayer     250 88   16.0 0.0
2550 ShootToPlayer     250 88   16.0 0.0
2552 ShootToPlayer     250 88   16.0 0.0
2554 ShootToPlayer     250 88   16.0 0.0
2556 ShootToPlayer     250 88   16.0 0.0
2558 ShootToPlayer     250 88   16.0 0.0
2560 ShootToPlayer     250 88   16.0 0.0
2562 ShootToPlayer     250 88   16.0 0.0
2564 ShootToPlayer     250 88   16.0 0.0
2566 ShootToPlayer     250 88   16.0 0.0
2568 ShootToPlayer     250 88   16.0 0.0
2570 ShootToPlayer     250 88   16.0 0.0
2572 ShootToPlayer     250 88   16.0 0.0
2574 ShootToPlayer     250 88   16.0 0.0
2576 ShootToPlayer     250 88   16.0 0.0
2578 ShootToPlayer     250 88   16.0 0.0
2580 ShootToPlayer     250 88   16.0 0.0
2582 ShootToPlayer     250 88   16.0 0.0
2584 ShootToPlayer     250 88   16.0 0.0
2586 ShootToPlayer     250 88   16.0 0.0
2588 ShootToPlayer     250 88   16.0 0.0
2590 ShootToPlayer     250 88   16.0 0.0
2592 ShootToPlayer     250 88   16.0 0.0
2594 ShootToPlayer     250 88   16.0 0.0
2596 ShootToPlayer     250 88   16.0 0.0
2598 ShootToPlayer     250 88   16.0 0.0
2600 ShootToPlayer     250 88   16.0 0.0
2602 ShootToPlayer     250 88   16.0 0.0
2604 ShootToPlayer     250 88   16.0 0.0
2606 ShootToPlayer     250 88   16.0 0.0
2608 ShootToPlayer     250 88   16.0 0.0
2610 ShootToPlayer     250 88   16.0 0.0
2612 ShootToPlayer     250 88   16.0 0.0
2614 ShootToPlayer     250 88   16.0 0.0
2616 ShootToPlayer     250 88   16.0 0.0
2618 ShootToPlayer     250 88   16.0 0.0
2620 ShootToPlayer     250 88   16.0 0.0
2622 ShootToPlayer     250 88   16.0 0.0
2624 ShootToPlayer     250 88   16.0 0.0
2626 ShootToPlayer     250 88   16.0 0.0
2628 ShootToPlayer     250 88   16.0 0.0
2630 ShootToPlayer     250 88   16.0 0.0
2632 ShootToPlayer     250 88   16.0 0.0
2634 ShootToPlayer     250 88   16.0 0.0
2636 ShootToPlayer     250 88   16.0 0.0
2638 ShootToPlayer     250 88   16.0 0.0
2640 ShootToPlayer     250 88   16.0 0.0
2642 ShootToPlayer     250 88   16.0 0.0
2644 ShootToPlayer     250 88   16.0 0.0
2646 ShootToPlayer     250 88   16.0 0.0
2648 ShootToPlayer     250 88   16.0 0.0
2650 ShootToPlayer     250 88   16.0 0.0
2652 ShootToPlayer     250 88   16.0 0.0
2654 ShootToPlayer     250 88   16.0 0.0
2656 ShootToPlayer     250 88   16.0 0.0
2658 ShootToPlayer     250 88   16.0 0.0
2660 ShootToPlayer     250 88   16.0 0.0
2662 ShootToPlayer     250 88   16.0 0.0
2664 ShootToPlayer     250 88   16.0 0.0
2666 ShootToPlayer     250 88   16.0 0.0
2668 ShootToPlayer     250 88   16.0 0.0
2670 ShootToPlayer     250 88   16.0 0.0
2672 ShootToPlayer     250 88   16.0 0.0
2674 ShootToPlayer     250 88   16.0 0.0
2676 ShootToPlayer     250 88   16.0 0.0
2678 ShootToPlayer     250 88   16.0 0.0
2680 ShootToPlayer     250 88   16.0 0.0
2682 ShootToPlayer     250 88   16.0 0.0
2684 ShootToPlayer     250 88   16.0 0.0
2686 ShootToPlayer     250 88   16.0 0.0
2688 ShootToPlayer     250 88   16.0 0.0
2690 ShootToPlayer     250 88   16.0 0.0
2692 ShootToPlayer     250 88   16.0 0.0
2694 ShootToPlayer     250 88   16.0 0.0
2696 ShootToPlayer     250 88   16.0 0.0
2698 ShootToPlayer     250 88   16.0 0.0
2700 ShootToPlayer     250 88   16.0 0.0
2702 ShootToPlayer     250 88   16.0 0.0
2704 ShootToPlayer     250 88   16.0 0.0
2706 ShootToPlayer     250 88   16.0 0.0
2708 ShootToPlayer     250 88   16.0 0.0
2710 ShootToPlayer     250 88   16.0 0.0
2712 ShootToPlayer     250 88   16.0 0.0
2714 ShootToPlayer     250 88   16.0 0.0
2716 ShootToPlayer     250 88   16.0 0.0
2718 ShootToPlayer     250 88   16.0 0.0
2720 ShootToPlayer     250 88   16.0 0.0
2722 ShootToPlayer     250 88   16.0 0.0
2724 ShootToPlayer     250 88   16.0 0.0
2726 ShootToPlayer     250 88   16.0 0.0
2728 ShootToPlayer     250 88   16.0 0.0
2730 ShootToPlayer     250 88   16.0 0.0
2732 ShootToPlayer     250 88   16.0 0.0
2734 ShootToPlayer     250 88   16.0 0.0
2736 ShootToPlayer     250 88   16.0 0.0
2738 ShootToPlayer     250 88   16.0 0.0
2740 ShootToPlayer     250 88   16.0 0.0
2742 ShootToPlayer     250 88   16.0 0.0
2744 ShootToPlayer     250 88   16.0 0.0
2746 ShootToPlayer     250 88   16.0 0.0
2748 ShootToPlayer     250 88   16.0 0.0
2750 ShootToPlayer     250 88   16.0 0.0
2752 ShootToPlayer     250 88   16.0 0.0
2754 ShootToPlayer     250 88   16.0 0.0
2756 ShootToPlayer     250 88   16.0 0.0
2758 ShootToPlayer     250 88   16.0 0.0
2760 ShootToPlayer     250 88   16.0 0.0
2762 ShootToPlayer     250 88   16.0 0.0
2764 ShootToPlayer     250 88   16.0 0.0
2766 ShootToPlayer     250 88   16.0 0.0
2768 ShootToPlayer     250 88   16.0 0.0
2770 ShootToPlayer     250 88   16.0 0.0
2772 ShootToPlayer     250 88   16.0 0.0
2774 ShootToPlayer     250 88   16.0 0.0
2776 ShootToPlayer     250 88   16.0 0.0
2778 ShootToPlayer     250 88   16.0 0.0
2780 ShootToPlayer     250 88   16.0 0.0
2782 ShootToPlayer     250 88   16.0 0.0
2784 ShootToPlayer     250 88   16.0 0.0
2786 ShootToPlayer     250 88   16.0 0.0
2788 ShootToPlayer     250 88   16.0 0.0

```

`Source Code/Data/EnemyLevel6.txt`:

```txt
typeID: 1   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
35   SetVelY           0.0
35   ShootToPlayer     50 95 6.0  -20.0 0.0 20.0
35   ShootToPlayer     50 95 8.0  -20.0 0.0 20.0
35   ShootToPlayer     50 95 10.0 -20.0 0.0 20.0
125  SetVelY           10.0
125  ShootToPlayer     50 95 6.0  -20.0 0.0 20.0
125  ShootToPlayer     50 95 8.0  -20.0 0.0 20.0
125   ShootToPlayer     50 95 10.0 -20.0 0.0 20.0
/////////////////////////
typeID: 2   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
70   SetVelY           0.0
70   SetVelX           2.0
76   ShootToPlayerRand 56  175 5.0 8.0 1
76   ShootToPlayerRand 105 175 5.0 8.0 1
82   ShootToPlayerRand 56  175 5.0 8.0 1
82   ShootToPlayerRand 105 175 5.0 8.0 1
88   ShootToPlayerRand 56  175 5.0 8.0 1
88   ShootToPlayerRand 105 175 5.0 8.0 1
94   ShootToPlayerRand 56  175 5.0 8.0 1
94   ShootToPlayerRand 105 175 5.0 8.0 1
100  ShootToPlayerRand 56  175 5.0 8.0 1
100  ShootToPlayerRand 105 175 5.0 8.0 1
106  ShootToPlayerRand 56  175 5.0 8.0 1
106  ShootToPlayerRand 105 175 5.0 8.0 1
112  ShootToPlayerRand 56  175 5.0 8.0 1
112  ShootToPlayerRand 105 175 5.0 8.0 1
118  ShootToPlayerRand 56  175 5.0 8.0 1
118  ShootToPlayerRand 105 175 5.0 8.0 1
124  ShootToPlayerRand 56  175 5.0 8.0 1
124  ShootToPlayerRand 105 175 5.0 8.0 1
130  ShootToPlayerRand 56  175 5.0 8.0 1
130  ShootToPlayerRand 105 175 5.0 8.0 1

76   ShootToPlayerRand 56  175 7.5 8.0 1
76   ShootToPlayerRand 105 175 7.5 8.0 1
82   ShootToPlayerRand 56  175 7.5 8.0 1
82   ShootToPlayerRand 105 175 7.5 8.0 1
88   ShootToPlayerRand 56  175 7.5 8.0 1
88   ShootToPlayerRand 105 175 7.5 8.0 1
94   ShootToPlayerRand 56  175 7.5 8.0 1
94   ShootToPlayerRand 105 175 7.5 8.0 1
100  ShootToPlayerRand 56  175 7.5 8.0 1
100  ShootToPlayerRand 105 175 7.5 8.0 1
106  ShootToPlayerRand 56  175 7.5 8.0 1
106  ShootToPlayerRand 105 175 7.5 8.0 1
112  ShootToPlayerRand 56  175 7.5 8.0 1
112  ShootToPlayerRand 105 175 7.5 8.0 1
118  ShootToPlayerRand 56  175 7.5 8.0 1
118  ShootToPlayerRand 105 175 7.5 8.0 1
124  ShootToPlayerRand 56  175 7.5 8.0 1
124  ShootToPlayerRand 105 175 7.5 8.0 1
130  ShootToPlayerRand 56  175 7.5 8.0 1
130  ShootToPlayerRand 105 175 7.5 8.0 1

130  SetVelX           0.0
130  SetVelY           -2.0             
/////////////////////////
typeID: 3   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
90   SetVelY           -2.0
98   ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
106  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
114  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
122  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
130  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
140  SetVelY           4.0
140  SetVelX           2.0
200  SetVelY           -2.0
200  SetVelX           0.0
208  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
216  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
224  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
232  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
240  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
240  SetVelY           4.0
/////////////////////////
typeID: 4   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
30   ShootToPlayer     5   80  5.0 0.0
30   ShootToPlayer     45  80  5.0 0.0
42   ShootToPlayer     5   80  5.2 0.0
42   ShootToPlayer     45  80  5.2 0.0
54   ShootToPlayer     5   80  5.4 0.0
54   ShootToPlayer     45  80  5.4 0.0
66   ShootToPlayer     5   80  5.6 0.0
66   ShootToPlayer     45  80  5.6 0.0
78   ShootToPlayer     5   80  5.8 0.0
78   ShootToPlayer     45  80  5.8 0.0
90   ShootToPlayer     5   80  6.0 0.0
90   ShootToPlayer     45  80  6.0 0.0

/////////////////////////
typeID: 5   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
20   ShootToPlayer     50  95 6.0 -60.0 -40.0 -20.0 0.0 20.0 40.0 60.0
20   ShootToPlayer     50  95 7.0 -60.0 -40.0 -20.0 0.0 20.0 40.0 60.0
35   SetVelY           0.0
35   ShootToPlayer     50  95 6.0 -60.0 -40.0 -20.0 0.0 20.0 40.0 60.0
35   ShootToPlayer     50  95 7.0 -60.0 -40.0 -20.0 0.0 20.0 40.0 60.0
125  SetVelY           -5.0
125  SetAwayVelX       2.5
125  ShootToPlayer     50  95 6.0 -60.0 -40.0 -20.0 0.0 20.0 40.0 60.0
125  ShootToPlayer     50  95 7.0 -60.0 -40.0 -20.0 0.0 20.0 40.0 60.0
/////////////////////////
typeID: 6   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
40   SetVelY            0.0
40   Charge             0
40   Shoot             70  55   8.0 -180.0 -168.0 -156.0 -144.0 -132.0 -120.0 -108.0 -96.0 -84.0 -72.0 -60.0 -48.0 -36.0 -24.0 -12.0 0.0 12.0 24.0 36.0 48.0 60.0 72.0 84.0 96.0 108.0 120.0 132.0 144.0 156.0 168.0 
40   Shoot             70  55   9.0 -180.0 -168.0 -156.0 -144.0 -132.0 -120.0 -108.0 -96.0 -84.0 -72.0 -60.0 -48.0 -36.0 -24.0 -12.0 0.0 12.0 24.0 36.0 48.0 60.0 72.0 84.0 96.0 108.0 120.0 132.0 144.0 156.0 168.0 



80   ShootLaser         23  220 16.0
80   ShootLaser         115 220 16.0
86   ShootLaser         23  220 16.0
86   ShootLaser         115 220 16.0
92   ShootLaser         23  220 16.0
92   ShootLaser         115 220 16.0
98   ShootLaser         23  220 16.0
98   ShootLaser         115 220 16.0
104  ShootLaser         23  220 16.0
104  ShootLaser         115 220 16.0
110  ShootLaser         23  220 16.0
110  ShootLaser         115 220 16.0
116  ShootLaser         23  220 16.0
116  ShootLaser         115 220 16.0
122  ShootLaser         23  220 16.0
122  ShootLaser         115 220 16.0
128  ShootLaser         23  220 16.0
128  ShootLaser         115 220 16.0
134  ShootLaser         23  220 16.0
134  ShootLaser         115 220 16.0
140  SetVelY            -2.0
140  ShootToPlayerRand  23  190 6.0 20.0 2
140  ShootToPlayerRand  115 190 6.0 20.0 2
148  ShootToPlayerRand  23  190 6.0 20.0 2
148  ShootToPlayerRand  115 190 6.0 20.0 2
156  ShootToPlayerRand  23  190 6.0 20.0 2
156  ShootToPlayerRand  115 190 6.0 20.0 2
164  ShootToPlayerRand  23  190 6.0 20.0 2
164  ShootToPlayerRand  115 190 6.0 20.0 2
172  ShootToPlayerRand  23  190 6.0 20.0 2
172  ShootToPlayerRand  115 190 6.0 20.0 2
180  ShootToPlayerRand  23  190 6.0 20.0 2
180  ShootToPlayerRand  115 190 6.0 20.0 2
188  ShootToPlayerRand  23  190 6.0 20.0 2
188  ShootToPlayerRand  115 190 6.0 20.0 2
196  ShootToPlayerRand  23  190 6.0 20.0 2
196  ShootToPlayerRand  115 190 6.0 20.0 2
204  ShootToPlayerRand  23  190 6.0 20.0 2
204  ShootToPlayerRand  115 190 6.0 20.0 2
212  ShootToPlayerRand  23  190 6.0 20.0 2
212  ShootToPlayerRand  115 190 6.0 20.0 2
220  ShootToPlayerRand  23  190 6.0 20.0 2
220  ShootToPlayerRand  115 190 6.0 20.0 2
228  ShootToPlayerRand  23  190 6.0 20.0 2
228  ShootToPlayerRand  115 190 6.0 20.0 2
/////////////////////////
typeID: 7   cmdCount: 1
MainCmd
0     SetCmd            0
290   SetFrame          50
=========================
50   SetVelX             0.0
50   SetVelY             0.0
56   ShootToPlayerRand   55  40  4.0 20.0 2
62   ShootToPlayerRand   55  40  4.0 20.0 2
68   ShootToPlayerRand   55  40  4.0 20.0 2
74   ShootToPlayerRand   55  40  4.0 20.0 2
80   ShootToPlayerRand   55  40  4.0 20.0 2
86   ShootToPlayerRand   55  40  4.0 20.0 2
92   ShootToPlayerRand   55  40  4.0 20.0 2
98   ShootToPlayerRand   55  40  4.0 20.0 2
104  ShootToPlayerRand   55  40  4.0 20.0 2
110  ShootToPlayerRand   55  40  4.0 20.0 2

56   ShootToPlayerRand   55  40  7.0 20.0 2
62   ShootToPlayerRand   55  40  7.0 20.0 2
68   ShootToPlayerRand   55  40  7.0 20.0 2
74   ShootToPlayerRand   55  40  7.0 20.0 2
80   ShootToPlayerRand   55  40  7.0 20.0 2
86   ShootToPlayerRand   55  40  7.0 20.0 2
92   ShootToPlayerRand   55  40  7.0 20.0 2
98   ShootToPlayerRand   55  40  7.0 20.0 2
104  ShootToPlayerRand   55  40  7.0 20.0 2
110  ShootToPlayerRand   55  40  7.0 20.0 2

140  SetVelX             5.0
140  SetVelY             3.0
170  SetVelX             0.0
170  SetVelY             0.0
176  ShootToPlayerRand   55  40  4.0 20.0 2
182  ShootToPlayerRand   55  40  4.0 20.0 2
188  ShootToPlayerRand   55  40  4.0 20.0 2
194  ShootToPlayerRand   55  40  4.0 20.0 2
200  ShootToPlayerRand   55  40  4.0 20.0 2
206  ShootToPlayerRand   55  40  4.0 20.0 2
212  ShootToPlayerRand   55  40  4.0 20.0 2
218  ShootToPlayerRand   55  40  4.0 20.0 2
224  ShootToPlayerRand   55  40  4.0 20.0 2
230  ShootToPlayerRand   55  40  4.0 20.0 2

176  ShootToPlayerRand   55  40  7.0 20.0 2
182  ShootToPlayerRand   55  40  7.0 20.0 2
188  ShootToPlayerRand   55  40  7.0 20.0 2
194  ShootToPlayerRand   55  40  7.0 20.0 2
200  ShootToPlayerRand   55  40  7.0 20.0 2
206  ShootToPlayerRand   55  40  7.0 20.0 2
212  ShootToPlayerRand   55  40  7.0 20.0 2
218  ShootToPlayerRand   55  40  7.0 20.0 2
224  ShootToPlayerRand   55  40  7.0 20.0 2
230  ShootToPlayerRand   55  40  7.0 20.0 2
260  SetVelX             5.0
260  SetVelY             3.0
/////////////////////////
typeID: 8   cmdCount: 1
MainCmd
0     SetCmd            0
=========================
10    ShootToPlayer     37  100 6.0  -12.5 0.0 12.5
70    SetVelY           -3.0
70    SetAwayVelX       -4.5
90    ShootLaser        37  100 12.0
150   ShootLaser        37  100 12.0
/////////////////////////
typeID: 9   cmdCount: 1
MainCmd
0    SetCmd             0
=========================
40   SetVelY            0.0
40  Charge             0
80   ShootRand          30  240 8.0 90.0 60.0 9
86   ShootRand          30  240 8.0 90.0 60.0 9
92   ShootRand          30  240 8.0 90.0 60.0 9
98   ShootRand          30  240 8.0 90.0 60.0 9
104  ShootRand          30  240 8.0 90.0 60.0 9
110  ShootRand          30  240 8.0 90.0 60.0 9
116  ShootRand          30  240 8.0 90.0 60.0 9
122  ShootRand          30  240 8.0 90.0 60.0 9
128  ShootRand          30  240 8.0 90.0 60.0 9
134  ShootRand          30  240 8.0 90.0 60.0 9
140  ShootRand          30  240 8.0 90.0 60.0 9
146  ShootRand          30  240 8.0 90.0 60.0 9
152  ShootRand          30  240 8.0 90.0 60.0 9
158  ShootRand          30  240 8.0 90.0 60.0 9
164  ShootRand          30  240 8.0 90.0 60.0 9
180  SetVelY            -3.0
/////////////////////////
typeID: 10   cmdCount: 1
MainCmd
0   SetCmd              0
340 SetFrame            60
=========================
80   ShootRand          78  110 4.0  135.0 47.0 8
80   ShootRand          161 110 4.0  45.0  47.0 8
90   ShootRand          78  110 4.0  135.0 47.0 8
90   ShootRand          161 110 4.0  45.0  47.0 8
100  ShootRand          78  110 4.0  135.0 47.0 8
100  ShootRand          161 110 4.0  45.0  47.0 8
110  ShootRand          78  110 4.0  135.0 47.0 8
110  ShootRand          161 110 4.0  45.0  47.0 8
120  ShootRand          78  110 4.0  135.0 47.0 8
120  ShootRand          161 110 4.0  45.0  47.0 8
130  ShootRand          78  110 4.0  135.0 47.0 8
130  ShootRand          161 110 4.0  45.0  47.0 8
140  ShootRand          78  110 4.0  135.0 47.0 8
140  ShootRand          161 110 4.0  45.0  47.0 8
150  ShootRand          78  110 4.0  135.0 47.0 8
150  ShootRand          161 110 4.0  45.0  47.0 8

80   ShootRand          78  110 7.0  135.0 47.0 8
80   ShootRand          161 110 7.0  45.0  47.0 8
90   ShootRand          78  110 7.0  135.0 47.0 8
90   ShootRand          161 110 7.0  45.0  47.0 8
100  ShootRand          78  110 7.0  135.0 47.0 8
100  ShootRand          161 110 7.0  45.0  47.0 8
110  ShootRand          78  110 7.0  135.0 47.0 8
110  ShootRand          161 110 7.0  45.0  47.0 8
120  ShootRand          78  110 7.0  135.0 47.0 8
120  ShootRand          161 110 7.0  45.0  47.0 8
130  ShootRand          78  110 7.0  135.0 47.0 8
130  ShootRand          161 110 7.0  45.0  47.0 8
140  ShootRand          78  110 7.0  135.0 47.0 8
140  ShootRand          161 110 7.0  45.0  47.0 8
150  ShootRand          78  110 7.0  135.0 47.0 8
150  ShootRand          161 110 7.0  45.0  47.0 8

200  Charge             0
200  SetVelX            0.0
200  SetVelY            0.0
240  ShootLaser         119 200 16.0
246  ShootLaser         119 200 16.0
252  ShootLaser         119 200 16.0
258  ShootLaser         119 200 16.0
264  ShootLaser         119 200 16.0
270  ShootLaser         119 200 16.0
276  ShootLaser         119 200 16.0
282  ShootLaser         119 200 16.0
288  ShootLaser         119 200 16.0
294  ShootLaser         119 200 16.0
330  SetVelX            0.5
330  SetVelY            1.5
/////////////////////////
typeID: 11   cmdCount: 1
MainCmd
0    SetCmd             0
==========================
40   SetVelY            0.0
40   Charge             0

80   Shoot              30  240 7.0 17.0 20.0 23.0 
83   Shoot              30  240 7.0 31.0 34.0 37.0 
86   Shoot              30  240 7.0 45.0 48.0 51.0 
89   Shoot              30  240 7.0 59.0 62.0 65.0 
92   Shoot              30  240 7.0 73.0 76.0 79.0 
95   Shoot              30  240 7.0 87.0 90.0 93.0 
98   Shoot              30  240 7.0 101.0 104.0 107.0 
101  Shoot              30  240 7.0 115.0 118.0 121.0 
104  Shoot              30  240 7.0 129.0 132.0 135.0 
107  Shoot              30  240 7.0 143.0 146.0 149.0 
110  Shoot              30  240 7.0 163.0 160.0 157.0 
113  Shoot              30  240 7.0 149.0 146.0 143.0 
116  Shoot              30  240 7.0 135.0 132.0 129.0 
119  Shoot              30  240 7.0 121.0 118.0 115.0 
122  Shoot              30  240 7.0 107.0 104.0 101.0 
125  Shoot              30  240 7.0 93.0 90.0 87.0 
128  Shoot              30  240 7.0 79.0 76.0 73.0 
131  Shoot              30  240 7.0 65.0 62.0 59.0 
134  Shoot              30  240 7.0 51.0 48.0 45.0 
137  Shoot              30  240 7.0 37.0 34.0 31.0 
140  Shoot              30  240 7.0 17.0 20.0 23.0 
143  Shoot              30  240 7.0 31.0 34.0 37.0 
146  Shoot              30  240 7.0 45.0 48.0 51.0 
149  Shoot              30  240 7.0 59.0 62.0 65.0 
152  Shoot              30  240 7.0 73.0 76.0 79.0 
155  Shoot              30  240 7.0 87.0 90.0 93.0 
158  Shoot              30  240 7.0 101.0 104.0 107.0 
161  Shoot              30  240 7.0 115.0 118.0 121.0 
164  Shoot              30  240 7.0 129.0 132.0 135.0 
167  Shoot              30  240 7.0 143.0 146.0 149.0

80   Shoot              30  240 8.0 17.0 20.0 23.0 
83   Shoot              30  240 8.0 31.0 34.0 37.0 
86   Shoot              30  240 8.0 45.0 48.0 51.0 
89   Shoot              30  240 8.0 59.0 62.0 65.0 
92   Shoot              30  240 8.0 73.0 76.0 79.0 
95   Shoot              30  240 8.0 87.0 90.0 93.0 
98   Shoot              30  240 8.0 101.0 104.0 107.0 
101  Shoot              30  240 8.0 115.0 118.0 121.0 
104  Shoot              30  240 8.0 129.0 132.0 135.0 
107  Shoot              30  240 8.0 143.0 146.0 149.0 
110  Shoot              30  240 8.0 163.0 160.0 157.0 
113  Shoot              30  240 8.0 149.0 146.0 143.0 
116  Shoot              30  240 8.0 135.0 132.0 129.0 
119  Shoot              30  240 8.0 121.0 118.0 115.0 
122  Shoot              30  240 8.0 107.0 104.0 101.0 
125  Shoot              30  240 8.0 93.0 90.0 87.0 
128  Shoot              30  240 8.0 79.0 76.0 73.0 
131  Shoot              30  240 8.0 65.0 62.0 59.0 
134  Shoot              30  240 8.0 51.0 48.0 45.0 
137  Shoot              30  240 8.0 37.0 34.0 31.0 
140  Shoot              30  240 8.0 17.0 20.0 23.0 
143  Shoot              30  240 8.0 31.0 34.0 37.0 
146  Shoot              30  240 8.0 45.0 48.0 51.0 
149  Shoot              30  240 8.0 59.0 62.0 65.0 
152  Shoot              30  240 8.0 73.0 76.0 79.0 
155  Shoot              30  240 8.0 87.0 90.0 93.0 
158  Shoot              30  240 8.0 101.0 104.0 107.0 
161  Shoot              30  240 8.0 115.0 118.0 121.0 
164  Shoot              30  240 8.0 129.0 132.0 135.0 
167  Shoot              30  240 8.0 143.0 146.0 149.0 

80   Shoot              30  240 9.0 17.0 20.0 23.0 
83   Shoot              30  240 9.0 31.0 34.0 37.0 
86   Shoot              30  240 9.0 45.0 48.0 51.0 
89   Shoot              30  240 9.0 59.0 62.0 65.0 
92   Shoot              30  240 9.0 73.0 76.0 79.0 
95   Shoot              30  240 9.0 87.0 90.0 93.0 
98   Shoot              30  240 9.0 101.0 104.0 107.0 
101  Shoot              30  240 9.0 115.0 118.0 121.0 
104  Shoot              30  240 9.0 129.0 132.0 135.0 
107  Shoot              30  240 9.0 143.0 146.0 149.0 
110  Shoot              30  240 9.0 163.0 160.0 157.0 
113  Shoot              30  240 9.0 149.0 146.0 143.0 
116  Shoot              30  240 9.0 135.0 132.0 129.0 
119  Shoot              30  240 9.0 121.0 118.0 115.0 
122  Shoot              30  240 9.0 107.0 104.0 101.0 
125  Shoot              30  240 9.0 93.0 90.0 87.0 
128  Shoot              30  240 9.0 79.0 76.0 73.0 
131  Shoot              30  240 9.0 65.0 62.0 59.0 
134  Shoot              30  240 9.0 51.0 48.0 45.0 
137  Shoot              30  240 9.0 37.0 34.0 31.0 
140  Shoot              30  240 9.0 17.0 20.0 23.0 
143  Shoot              30  240 9.0 31.0 34.0 37.0 
146  Shoot              30  240 9.0 45.0 48.0 51.0 
149  Shoot              30  240 9.0 59.0 62.0 65.0 
152  Shoot              30  240 9.0 73.0 76.0 79.0 
155  Shoot              30  240 9.0 87.0 90.0 93.0 
158  Shoot              30  240 9.0 101.0 104.0 107.0 
161  Shoot              30  240 9.0 115.0 118.0 121.0 
164  Shoot              30  240 9.0 129.0 132.0 135.0 
167  Shoot              30  240 9.0 143.0 146.0 149.0

180  SetVelY            -3.0
///////////////////////////
typeID: 14   cmdCount: 18
MainCmd
0    SetCmd             0
115  SetCmd             1 2
598  SetCmd             3

180  SetFrameIfHPLess   4500 999
270  SetFrameIfHPLess   4500 999
360  SetFrameIfHPLess   4500 999
450  SetFrameIfHPLess   4500 999
540  SetFrameIfHPLess   4500 999
630  SetFrameIfHPLess   4500 999
720  SetFrameIfHPLess   4500 999
810  SetFrameIfHPLess   4500 999

900  SetFrame           110



1000 SetCmd             4
1180 SetCmd             5 6 7
1680 SetCmd             8

1200 SetFrameIfHPLess   2500 2199
1290 SetFrameIfHPLess   2500 2199
1380 SetFrameIfHPLess   2500 2199
1470 SetFrameIfHPLess   2500 2199
1560 SetFrameIfHPLess   2500 2199
1650 SetFrameIfHPLess   2500 2199
1740 SetFrameIfHPLess   2500 2199
1830 SetFrameIfHPLess   2500 2199
1920 SetFrameIfHPLess   2500 2199
2010 SetFrameIfHPLess   2500 2199
2100 SetFrameIfHPLess   2500 2199

2120 SetFrame           1170

2200 SetCmd             9
2375 SetCmd             10 11
2890 SetCmd             12
3600 SetCmd             13 14 15 16
4150 SetCmd             17 
4960 SetFrame           2370            

===========Cmd0===========
105  SetVelY            0.0
===========Cmd1===========
120  SetVelX            1.5

120  ShootToPlayer     160 123 6.0 -60.0 -58.0 -56.0 -50.0 -48.0 -46.0 -40.0 -38.0 -36.0 -30.0 -28.0 -26.0 -20.0 -18.0 -16.0 -10.0 -8.0 -6.0 0.0 2.0 4.0 10.0 12.0 14.0 45.0 30.0 22.0 24.0 30.0 32.0 34.0 40.0 42.0 44.0 50.0 52.0 54.0 60.0 62.0 64.0 
160  ShootToPlayer     160 123 6.0 -59.0 -57.0 -55.0 -49.0 -47.0 -45.0 -39.0 -37.0 -35.0 -29.0 -27.0 -25.0 -19.0 -17.0 -15.0 -9.0 -7.0 -5.0 1.0 3.0 5.0 11.0 13.0 15.0 21.0 23.0 25.0 31.0 33.0 35.0 41.0 43.0 45.0 51.0 53.0 55.0 61.0 63.0 65.0 
200  ShootToPlayer     160 123 6.0 -59.0 -57.0 -55.0 -49.0 -47.0 -45.0 -39.0 -37.0 -35.0 -29.0 -27.0 -25.0 -19.0 -17.0 -15.0 -9.0 -7.0 -5.0 1.0 3.0 5.0 11.0 13.0 15.0 21.0 23.0 25.0 31.0 33.0 35.0 41.0 43.0 45.0 51.0 53.0 55.0 61.0 63.0 65.0 
240  ShootToPlayer     160 123 6.0 -67.0 -65.0 -63.0 -57.0 -55.0 -53.0 -47.0 -45.0 -43.0 -37.0 -35.0 -33.0 -27.0 -25.0 -23.0 -17.0 -15.0 -13.0 -7.0 -5.0 -3.0 3.0 5.0 7.0 13.0 15.0 17.0 23.0 25.0 27.0 33.0 35.0 37.0 43.0 45.0 47.0 53.0 55.0 57.0 
280  ShootToPlayer     160 123 6.0 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 
320  ShootToPlayer     160 123 6.0 -63.0 -61.0 -59.0 -53.0 -51.0 -49.0 -43.0 -41.0 -39.0 -33.0 -31.0 -29.0 -23.0 -21.0 -19.0 -13.0 -11.0 -9.0 -3.0 -1.0 1.0 7.0 9.0 11.0 17.0 19.0 21.0 27.0 29.0 31.0 37.0 39.0 41.0 47.0 49.0 51.0 57.0 59.0 61.0 
360  ShootToPlayer     160 123 6.0 -63.0 -61.0 -59.0 -53.0 -51.0 -49.0 -43.0 -41.0 -39.0 -33.0 -31.0 -29.0 -23.0 -21.0 -19.0 -13.0 -11.0 -9.0 -3.0 -1.0 1.0 7.0 9.0 11.0 17.0 19.0 21.0 27.0 29.0 31.0 37.0 39.0 41.0 47.0 49.0 51.0 57.0 59.0 61.0 
400  ShootToPlayer     160 123 6.0 -58.0 -56.0 -54.0 -48.0 -46.0 -44.0 -38.0 -36.0 -34.0 -28.0 -26.0 -24.0 -18.0 -16.0 -14.0 -8.0 -6.0 -4.0 45.0 3.0 4.0 6.0 12.0 14.0 16.0 22.0 24.0 45.0 36.0 32.0 34.0 36.0 42.0 44.0 46.0 52.0 54.0 56.0 62.0 64.0 66.0 
440  ShootToPlayer     160 123 6.0 -67.0 -65.0 -63.0 -57.0 -55.0 -53.0 -47.0 -45.0 -43.0 -37.0 -35.0 -33.0 -27.0 -25.0 -23.0 -17.0 -15.0 -13.0 -7.0 -5.0 -3.0 3.0 5.0 7.0 13.0 15.0 17.0 23.0 25.0 27.0 33.0 35.0 37.0 43.0 45.0 47.0 53.0 55.0 57.0 
480  ShootToPlayer     160 123 6.0 -68.0 -66.0 -64.0 -58.0 -56.0 -54.0 -48.0 -46.0 -44.0 -38.0 -36.0 -34.0 -28.0 -26.0 -24.0 -18.0 -16.0 -14.0 -8.0 -6.0 -4.0 45.0 3.0 4.0 6.0 12.0 14.0 16.0 22.0 24.0 45.0 36.0 32.0 34.0 36.0 42.0 44.0 46.0 52.0 54.0 56.0 
520  ShootToPlayer     160 123 6.0 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 
560  ShootToPlayer     160 123 6.0 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 

120  ShootToPlayer     160 123 7.7 -60.0 -58.0 -56.0 -50.0 -48.0 -46.0 -40.0 -38.0 -36.0 -30.0 -28.0 -26.0 -20.0 -18.0 -16.0 -10.0 -8.0 -6.0 0.0 2.0 4.0 10.0 12.0 14.0 45.0 30.0 22.0 24.0 30.0 32.0 34.0 40.0 42.0 44.0 50.0 52.0 54.0 60.0 62.0 64.0 
160  ShootToPlayer     160 123 7.7 -59.0 -57.0 -55.0 -49.0 -47.0 -45.0 -39.0 -37.0 -35.0 -29.0 -27.0 -25.0 -19.0 -17.0 -15.0 -9.0 -7.0 -5.0 1.0 3.0 5.0 11.0 13.0 15.0 21.0 23.0 25.0 31.0 33.0 35.0 41.0 43.0 45.0 51.0 53.0 55.0 61.0 63.0 65.0 
200  ShootToPlayer     160 123 7.7 -59.0 -57.0 -55.0 -49.0 -47.0 -45.0 -39.0 -37.0 -35.0 -29.0 -27.0 -25.0 -19.0 -17.0 -15.0 -9.0 -7.0 -5.0 1.0 3.0 5.0 11.0 13.0 15.0 21.0 23.0 25.0 31.0 33.0 35.0 41.0 43.0 45.0 51.0 53.0 55.0 61.0 63.0 65.0 
240  ShootToPlayer     160 123 7.7 -67.0 -65.0 -63.0 -57.0 -55.0 -53.0 -47.0 -45.0 -43.0 -37.0 -35.0 -33.0 -27.0 -25.0 -23.0 -17.0 -15.0 -13.0 -7.0 -5.0 -3.0 3.0 5.0 7.0 13.0 15.0 17.0 23.0 25.0 27.0 33.0 35.0 37.0 43.0 45.0 47.0 53.0 55.0 57.0 
280  ShootToPlayer     160 123 7.7 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 
320  ShootToPlayer     160 123 7.7 -63.0 -61.0 -59.0 -53.0 -51.0 -49.0 -43.0 -41.0 -39.0 -33.0 -31.0 -29.0 -23.0 -21.0 -19.0 -13.0 -11.0 -9.0 -3.0 -1.0 1.0 7.0 9.0 11.0 17.0 19.0 21.0 27.0 29.0 31.0 37.0 39.0 41.0 47.0 49.0 51.0 57.0 59.0 61.0 
360  ShootToPlayer     160 123 7.7 -63.0 -61.0 -59.0 -53.0 -51.0 -49.0 -43.0 -41.0 -39.0 -33.0 -31.0 -29.0 -23.0 -21.0 -19.0 -13.0 -11.0 -9.0 -3.0 -1.0 1.0 7.0 9.0 11.0 17.0 19.0 21.0 27.0 29.0 31.0 37.0 39.0 41.0 47.0 49.0 51.0 57.0 59.0 61.0 
400  ShootToPlayer     160 123 7.7 -58.0 -56.0 -54.0 -48.0 -46.0 -44.0 -38.0 -36.0 -34.0 -28.0 -26.0 -24.0 -18.0 -16.0 -14.0 -8.0 -6.0 -4.0 45.0 3.0 4.0 6.0 12.0 14.0 16.0 22.0 24.0 45.0 36.0 32.0 34.0 36.0 42.0 44.0 46.0 52.0 54.0 56.0 62.0 64.0 66.0 
440  ShootToPlayer     160 123 7.7 -67.0 -65.0 -63.0 -57.0 -55.0 -53.0 -47.0 -45.0 -43.0 -37.0 -35.0 -33.0 -27.0 -25.0 -23.0 -17.0 -15.0 -13.0 -7.0 -5.0 -3.0 3.0 5.0 7.0 13.0 15.0 17.0 23.0 25.0 27.0 33.0 35.0 37.0 43.0 45.0 47.0 53.0 55.0 57.0 
480  ShootToPlayer     160 123 7.7 -68.0 -66.0 -64.0 -58.0 -56.0 -54.0 -48.0 -46.0 -44.0 -38.0 -36.0 -34.0 -28.0 -26.0 -24.0 -18.0 -16.0 -14.0 -8.0 -6.0 -4.0 45.0 3.0 4.0 6.0 12.0 14.0 16.0 22.0 24.0 45.0 36.0 32.0 34.0 36.0 42.0 44.0 46.0 52.0 54.0 56.0 
520  ShootToPlayer     160 123 7.7 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 
560  ShootToPlayer     160 123 7.7 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 

===========Cmd2===========
120  SetVelX           1.5

120  ShootToPlayerRand 15  75 4.0 45.0 4
120  ShootToPlayerRand 304 75 4.0 45.0 4
129  ShootToPlayerRand 15  75 4.0 45.0 4
129  ShootToPlayerRand 304 75 4.0 45.0 4
138  ShootToPlayerRand 15  75 4.0 45.0 4
138  ShootToPlayerRand 304 75 4.0 45.0 4
147  ShootToPlayerRand 15  75 4.0 45.0 4
147  ShootToPlayerRand 304 75 4.0 45.0 4
156  ShootToPlayerRand 15  75 4.0 45.0 4
156  ShootToPlayerRand 304 75 4.0 45.0 4
165  ShootToPlayerRand 15  75 4.0 45.0 4
165  ShootToPlayerRand 304 75 4.0 45.0 4
174  ShootToPlayerRand 15  75 4.0 45.0 4
174  ShootToPlayerRand 304 75 4.0 45.0 4
183  ShootToPlayerRand 15  75 4.0 45.0 4
183  ShootToPlayerRand 304 75 4.0 45.0 4
192  ShootToPlayerRand 15  75 4.0 45.0 4
192  ShootToPlayerRand 304 75 4.0 45.0 4
201  ShootToPlayerRand 15  75 4.0 45.0 4
201  ShootToPlayerRand 304 75 4.0 45.0 4
210  ShootToPlayerRand 15  75 4.0 45.0 4
210  ShootToPlayerRand 304 75 4.0 45.0 4
219  ShootToPlayerRand 15  75 4.0 45.0 4
219  ShootToPlayerRand 304 75 4.0 45.0 4
228  ShootToPlayerRand 15  75 4.0 45.0 4
228  ShootToPlayerRand 304 75 4.0 45.0 4
237  ShootToPlayerRand 15  75 4.0 45.0 4
237  ShootToPlayerRand 304 75 4.0 45.0 4
246  ShootToPlayerRand 15  75 4.0 45.0 4
246  ShootToPlayerRand 304 75 4.0 45.0 4
255  ShootToPlayerRand 15  75 4.0 45.0 4
255  ShootToPlayerRand 304 75 4.0 45.0 4
264  ShootToPlayerRand 15  75 4.0 45.0 4
264  ShootToPlayerRand 304 75 4.0 45.0 4
273  ShootToPlayerRand 15  75 4.0 45.0 4
273  ShootToPlayerRand 304 75 4.0 45.0 4
282  ShootToPlayerRand 15  75 4.0 45.0 4
282  ShootToPlayerRand 304 75 4.0 45.0 4
291  ShootToPlayerRand 15  75 4.0 45.0 4
291  ShootToPlayerRand 304 75 4.0 45.0 4
300  ShootToPlayerRand 15  75 4.0 45.0 4
300  ShootToPlayerRand 304 75 4.0 45.0 4
309  ShootToPlayerRand 15  75 4.0 45.0 4
309  ShootToPlayerRand 304 75 4.0 45.0 4
318  ShootToPlayerRand 15  75 4.0 45.0 4
318  ShootToPlayerRand 304 75 4.0 45.0 4
327  ShootToPlayerRand 15  75 4.0 45.0 4
327  ShootToPlayerRand 304 75 4.0 45.0 4
336  ShootToPlayerRand 15  75 4.0 45.0 4
336  ShootToPlayerRand 304 75 4.0 45.0 4
345  ShootToPlayerRand 15  75 4.0 45.0 4
345  ShootToPlayerRand 304 75 4.0 45.0 4
354  ShootToPlayerRand 15  75 4.0 45.0 4
354  ShootToPlayerRand 304 75 4.0 45.0 4
363  ShootToPlayerRand 15  75 4.0 45.0 4
363  ShootToPlayerRand 304 75 4.0 45.0 4
372  ShootToPlayerRand 15  75 4.0 45.0 4
372  ShootToPlayerRand 304 75 4.0 45.0 4
381  ShootToPlayerRand 15  75 4.0 45.0 4
381  ShootToPlayerRand 304 75 4.0 45.0 4
390  ShootToPlayerRand 15  75 4.0 45.0 4
390  ShootToPlayerRand 304 75 4.0 45.0 4
399  ShootToPlayerRand 15  75 4.0 45.0 4
399  ShootToPlayerRand 304 75 4.0 45.0 4
408  ShootToPlayerRand 15  75 4.0 45.0 4
408  ShootToPlayerRand 304 75 4.0 45.0 4
417  ShootToPlayerRand 15  75 4.0 45.0 4
417  ShootToPlayerRand 304 75 4.0 45.0 4
426  ShootToPlayerRand 15  75 4.0 45.0 4
426  ShootToPlayerRand 304 75 4.0 45.0 4
435  ShootToPlayerRand 15  75 4.0 45.0 4
435  ShootToPlayerRand 304 75 4.0 45.0 4
444  ShootToPlayerRand 15  75 4.0 45.0 4
444  ShootToPlayerRand 304 75 4.0 45.0 4
453  ShootToPlayerRand 15  75 4.0 45.0 4
453  ShootToPlayerRand 304 75 4.0 45.0 4
462  ShootToPlayerRand 15  75 4.0 45.0 4
462  ShootToPlayerRand 304 75 4.0 45.0 4
471  ShootToPlayerRand 15  75 4.0 45.0 4
471  ShootToPlayerRand 304 75 4.0 45.0 4
480  ShootToPlayerRand 15  75 4.0 45.0 4
480  ShootToPlayerRand 304 75 4.0 45.0 4
489  ShootToPlayerRand 15  75 4.0 45.0 4
489  ShootToPlayerRand 304 75 4.0 45.0 4
498  ShootToPlayerRand 15  75 4.0 45.0 4
498  ShootToPlayerRand 304 75 4.0 45.0 4
507  ShootToPlayerRand 15  75 4.0 45.0 4
507  ShootToPlayerRand 304 75 4.0 45.0 4
516  ShootToPlayerRand 15  75 4.0 45.0 4
516  ShootToPlayerRand 304 75 4.0 45.0 4
525  ShootToPlayerRand 15  75 4.0 45.0 4
525  ShootToPlayerRand 304 75 4.0 45.0 4
534  ShootToPlayerRand 15  75 4.0 45.0 4
534  ShootToPlayerRand 304 75 4.0 45.0 4
543  ShootToPlayerRand 15  75 4.0 45.0 4
543  ShootToPlayerRand 304 75 4.0 45.0 4
552  ShootToPlayerRand 15  75 4.0 45.0 4
552  ShootToPlayerRand 304 75 4.0 45.0 4
============Cmd3==========
600  Charge            0
600  SetVelX           0.0
600  SetVelY           0.0

640  Shoot             15  75  6.0 182.0 180.0 178.0
640  Shoot             34  125 6.0 12.0 10.0 8.0
640  Shoot             285 125 6.0 172.0 170.0 168.0
640  Shoot             304 75  6.0 2.0 0.0 -2.0
650  Shoot             15  75  6.0 166.0 164.0 162.0
650  Shoot             34  125 6.0 28.0 26.0 24.0
650  Shoot             285 125 6.0 156.0 154.0 152.0
650  Shoot             304 75  6.0 18.0 16.0 14.0
660  Shoot             15  75  6.0 150.0 148.0 146.0
660  Shoot             34  125 6.0 44.0 42.0 40.0
660  Shoot             285 125 6.0 140.0 138.0 136.0
660  Shoot             304 75  6.0 34.0 32.0 30.0
670  Shoot             15  75  6.0 134.0 132.0 130.0
670  Shoot             34  125 6.0 60.0 58.0 56.0
670  Shoot             285 125 6.0 124.0 122.0 120.0
670  Shoot             304 75  6.0 50.0 48.0 46.0
680  Shoot             15  75  6.0 118.0 116.0 114.0
680  Shoot             34  125 6.0 76.0 74.0 72.0
680  Shoot             285 125 6.0 108.0 106.0 104.0
680  Shoot             304 75  6.0 66.0 64.0 62.0
690  Shoot             15  75  6.0 102.0 100.0 98.0
690  Shoot             34  125 6.0 92.0 90.0 88.0
690  Shoot             285 125 6.0 92.0 90.0 88.0
690  Shoot             304 75  6.0 82.0 80.0 78.0
700  Shoot             15  75  6.0 86.0 84.0 82.0
700  Shoot             34  125 6.0 108.0 106.0 104.0
700  Shoot             285 125 6.0 76.0 74.0 72.0
700  Shoot             304 75  6.0 98.0 96.0 94.0
710  Shoot             15  75  6.0 70.0 68.0 66.0
710  Shoot             34  125 6.0 124.0 122.0 120.0
710  Shoot             285 125 6.0 60.0 58.0 56.0
710  Shoot             304 75  6.0 114.0 112.0 110.0
720  Shoot             15  75  6.0 54.0 52.0 50.0
720  Shoot             34  125 6.0 140.0 138.0 136.0
720  Shoot             285 125 6.0 44.0 42.0 40.0
720  Shoot             304 75  6.0 130.0 128.0 126.0
730  Shoot             15  75  6.0 38.0 36.0 34.0
730  Shoot             34  125 6.0 156.0 154.0 152.0
730  Shoot             285 125 6.0 28.0 26.0 24.0
730  Shoot             304 75  6.0 146.0 144.0 142.0
740  Shoot             15  75  6.0 12.0 10.0 8.0
740  Shoot             34  125 6.0 182.0 180.0 178.0
740  Shoot             285 125 6.0 2.0 0.0 -2.0
740  Shoot             304 75  6.0 172.0 170.0 168.0
750  Shoot             15  75  6.0 28.0 26.0 24.0
750  Shoot             34  125 6.0 166.0 164.0 162.0
750  Shoot             285 125 6.0 18.0 16.0 14.0
750  Shoot             304 75  6.0 156.0 154.0 152.0
760  Shoot             15  75  6.0 44.0 42.0 40.0
760  Shoot             34  125 6.0 150.0 148.0 146.0
760  Shoot             285 125 6.0 34.0 32.0 30.0
760  Shoot             304 75  6.0 140.0 138.0 136.0
770  Shoot             15  75  6.0 60.0 58.0 56.0
770  Shoot             34  125 6.0 134.0 132.0 130.0
770  Shoot             285 125 6.0 50.0 48.0 46.0
770  Shoot             304 75  6.0 124.0 122.0 120.0
780  Shoot             15  75  6.0 76.0 74.0 72.0
780  Shoot             34  125 6.0 118.0 116.0 114.0
780  Shoot             285 125 6.0 66.0 64.0 62.0
780  Shoot             304 75  6.0 108.0 106.0 104.0
790  Shoot             15  75  6.0 92.0 90.0 88.0
790  Shoot             34  125 6.0 102.0 100.0 98.0
790  Shoot             285 125 6.0 82.0 80.0 78.0
790  Shoot             304 75  6.0 92.0 90.0 88.0
800  Shoot             15  75  6.0 108.0 106.0 104.0
800  Shoot             34  125 6.0 86.0 84.0 82.0
800  Shoot             285 125 6.0 98.0 96.0 94.0
800  Shoot             304 75  6.0 76.0 74.0 72.0
810  Shoot             15  75  6.0 124.0 122.0 120.0
810  Shoot             34  125 6.0 70.0 68.0 66.0
810  Shoot             285 125 6.0 114.0 112.0 110.0
810  Shoot             304 75  6.0 60.0 58.0 56.0
820  Shoot             15  75  6.0 140.0 138.0 136.0
820  Shoot             34  125 6.0 54.0 52.0 50.0
820  Shoot             285 125 6.0 130.0 128.0 126.0
820  Shoot             304 75  6.0 44.0 42.0 40.0
830  Shoot             15  75  6.0 156.0 154.0 152.0
830  Shoot             34  125 6.0 38.0 36.0 34.0
830  Shoot             285 125 6.0 146.0 144.0 142.0
830  Shoot             304 75  6.0 28.0 26.0 24.0

640  Shoot             15  75  6.6 182.0 180.0 178.0
640  Shoot             34  125 6.6 12.0 10.0 8.0
640  Shoot             285 125 6.6 172.0 170.0 168.0
640  Shoot             304 75  6.6 2.0 0.0 -2.0
650  Shoot             15  75  6.6 166.0 164.0 162.0
650  Shoot             34  125 6.6 28.0 26.0 24.0
650  Shoot             285 125 6.6 156.0 154.0 152.0
650  Shoot             304 75  6.6 18.0 16.0 14.0
660  Shoot             15  75  6.6 150.0 148.0 146.0
660  Shoot             34  125 6.6 44.0 42.0 40.0
660  Shoot             285 125 6.6 140.0 138.0 136.0
660  Shoot             304 75  6.6 34.0 32.0 30.0
670  Shoot             15  75  6.6 134.0 132.0 130.0
670  Shoot             34  125 6.6 60.0 58.0 56.0
670  Shoot             285 125 6.6 124.0 122.0 120.0
670  Shoot             304 75  6.6 50.0 48.0 46.0
680  Shoot             15  75  6.6 118.0 116.0 114.0
680  Shoot             34  125 6.6 76.0 74.0 72.0
680  Shoot             285 125 6.6 108.0 106.0 104.0
680  Shoot             304 75  6.6 66.0 64.0 62.0
690  Shoot             15  75  6.6 102.0 100.0 98.0
690  Shoot             34  125 6.6 92.0 90.0 88.0
690  Shoot             285 125 6.6 92.0 90.0 88.0
690  Shoot             304 75  6.6 82.0 80.0 78.0
700  Shoot             15  75  6.6 86.0 84.0 82.0
700  Shoot             34  125 6.6 108.0 106.0 104.0
700  Shoot             285 125 6.6 76.0 74.0 72.0
700  Shoot             304 75  6.6 98.0 96.0 94.0
710  Shoot             15  75  6.6 70.0 68.0 66.0
710  Shoot             34  125 6.6 124.0 122.0 120.0
710  Shoot             285 125 6.6 60.0 58.0 56.0
710  Shoot             304 75  6.6 114.0 112.0 110.0
720  Shoot             15  75  6.6 54.0 52.0 50.0
720  Shoot             34  125 6.6 140.0 138.0 136.0
720  Shoot             285 125 6.6 44.0 42.0 40.0
720  Shoot             304 75  6.6 130.0 128.0 126.0
730  Shoot             15  75  6.6 38.0 36.0 34.0
730  Shoot             34  125 6.6 156.0 154.0 152.0
730  Shoot             285 125 6.6 28.0 26.0 24.0
730  Shoot             304 75  6.6 146.0 144.0 142.0
740  Shoot             15  75  6.6 12.0 10.0 8.0
740  Shoot             34  125 6.6 182.0 180.0 178.0
740  Shoot             285 125 6.6 2.0 0.0 -2.0
740  Shoot             304 75  6.6 172.0 170.0 168.0
750  Shoot             15  75  6.6 28.0 26.0 24.0
750  Shoot             34  125 6.6 166.0 164.0 162.0
750  Shoot             285 125 6.6 18.0 16.0 14.0
750  Shoot             304 75  6.6 156.0 154.0 152.0
760  Shoot             15  75  6.6 44.0 42.0 40.0
760  Shoot             34  125 6.6 150.0 148.0 146.0
760  Shoot             285 125 6.6 34.0 32.0 30.0
760  Shoot             304 75  6.6 140.0 138.0 136.0
770  Shoot             15  75  6.6 60.0 58.0 56.0
770  Shoot             34  125 6.6 134.0 132.0 130.0
770  Shoot             285 125 6.6 50.0 48.0 46.0
770  Shoot             304 75  6.6 124.0 122.0 120.0
780  Shoot             15  75  6.6 76.0 74.0 72.0
780  Shoot             34  125 6.6 118.0 116.0 114.0
780  Shoot             285 125 6.6 66.0 64.0 62.0
780  Shoot             304 75  6.6 108.0 106.0 104.0
790  Shoot             15  75  6.6 92.0 90.0 88.0
790  Shoot             34  125 6.6 102.0 100.0 98.0
790  Shoot             285 125 6.6 82.0 80.0 78.0
790  Shoot             304 75  6.6 92.0 90.0 88.0
800  Shoot             15  75  6.6 108.0 106.0 104.0
800  Shoot             34  125 6.6 86.0 84.0 82.0
800  Shoot             285 125 6.6 98.0 96.0 94.0
800  Shoot             304 75  6.6 76.0 74.0 72.0
810  Shoot             15  75  6.6 124.0 122.0 120.0
810  Shoot             34  125 6.6 70.0 68.0 66.0
810  Shoot             285 125 6.6 114.0 112.0 110.0
810  Shoot             304 75  6.6 60.0 58.0 56.0
820  Shoot             15  75  6.6 140.0 138.0 136.0
820  Shoot             34  125 6.6 54.0 52.0 50.0
820  Shoot             285 125 6.6 130.0 128.0 126.0
820  Shoot             304 75  6.6 44.0 42.0 40.0
830  Shoot             15  75  6.6 156.0 154.0 152.0
830  Shoot             34  125 6.6 38.0 36.0 34.0
830  Shoot             285 125 6.6 146.0 144.0 142.0
830  Shoot             304 75  6.6 28.0 26.0 24.0
============Cmd4==========
1001 SetVelX           0.0
1001 SetVelY           0.0
============Cmd5==========
1190 SetVelX           2.0

1200 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1207 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1214 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1221 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1228 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1235 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1242 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1249 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1256 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1263 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 

1214 ShootToPlayer     160 123 4.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1221 ShootToPlayer     160 123 4.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1228 ShootToPlayer     160 123 5.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1235 ShootToPlayer     160 123 5.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1242 ShootToPlayer     160 123 6.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1249 ShootToPlayer     160 123 6.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1256 ShootToPlayer     160 123 7.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1263 ShootToPlayer     160 123 7.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1270 ShootToPlayer     160 123 8.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1277 ShootToPlayer     160 123 8.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 



1370 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1377 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1384 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1391 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1398 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1405 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1412 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1419 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1426 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1433 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 

1384 ShootToPlayer     160 123 4.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1391 ShootToPlayer     160 123 4.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1398 ShootToPlayer     160 123 5.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1405 ShootToPlayer     160 123 5.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1412 ShootToPlayer     160 123 6.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1419 ShootToPlayer     160 123 6.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1426 ShootToPlayer     160 123 7.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1433 ShootToPlayer     160 123 7.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1440 ShootToPlayer     160 123 8.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1447 ShootToPlayer     160 123 8.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 


1540 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1547 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1554 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1561 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1568 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1575 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1582 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1589 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1596 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
1603 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 

1554 ShootToPlayer     160 123 4.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1561 ShootToPlayer     160 123 4.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1568 ShootToPlayer     160 123 5.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1575 ShootToPlayer     160 123 5.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1582 ShootToPlayer     160 123 6.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1589 ShootToPlayer     160 123 6.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1596 ShootToPlayer     160 123 7.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1603 ShootToPlayer     160 123 7.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1610 ShootToPlayer     160 123 8.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
1617 ShootToPlayer     160 123 8.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 

===========Cmd6===========
1190 SetVelX           3.0
1200 ShootLaser        34  125 12.0
1200 ShootLaser        85  145 12.0
1200 ShootLaser        234 145 12.0
1200 ShootLaser        285 125 12.0
1224 ShootLaser        34  125 12.0
1224 ShootLaser        85  145 12.0
1224 ShootLaser        234 145 12.0
1224 ShootLaser        285 125 12.0
1248 ShootLaser        34  125 12.0
1248 ShootLaser        85  145 12.0
1248 ShootLaser        234 145 12.0
1248 ShootLaser        285 125 12.0
1272 ShootLaser        34  125 12.0
1272 ShootLaser        85  145 12.0
1272 ShootLaser        234 145 12.0
1272 ShootLaser        285 125 12.0
1296 ShootLaser        34  125 12.0
1296 ShootLaser        85  145 12.0
1296 ShootLaser        234 145 12.0
1296 ShootLaser        285 125 12.0
1320 ShootLaser        34  125 12.0
1320 ShootLaser        85  145 12.0
1320 ShootLaser        234 145 12.0
1320 ShootLaser        285 125 12.0
1344 ShootLaser        34  125 12.0
1344 ShootLaser        85  145 12.0
1344 ShootLaser        234 145 12.0
1344 ShootLaser        285 125 12.0
1368 ShootLaser        34  125 12.0
1368 ShootLaser        85  145 12.0
1368 ShootLaser        234 145 12.0
1368 ShootLaser        285 125 12.0
1392 ShootLaser        34  125 12.0
1392 ShootLaser        85  145 12.0
1392 ShootLaser        234 145 12.0
1392 ShootLaser        285 125 12.0
1416 ShootLaser        34  125 12.0
1416 ShootLaser        85  145 12.0
1416 ShootLaser        234 145 12.0
1416 ShootLaser        285 125 12.0
1440 ShootLaser        34  125 12.0
1440 ShootLaser        85  145 12.0
1440 ShootLaser        234 145 12.0
1440 ShootLaser        285 125 12.0
1464 ShootLaser        34  125 12.0
1464 ShootLaser        85  145 12.0
1464 ShootLaser        234 145 12.0
1464 ShootLaser        285 125 12.0
1488 ShootLaser        34  125 12.0
1488 ShootLaser        85  145 12.0
1488 ShootLaser        234 145 12.0
1488 ShootLaser        285 125 12.0
1512 ShootLaser        34  125 12.0
1512 ShootLaser        85  145 12.0
1512 ShootLaser        234 145 12.0
1512 ShootLaser        285 125 12.0
1536 ShootLaser        34  125 12.0
1536 ShootLaser        85  145 12.0
1536 ShootLaser        234 145 12.0
1536 ShootLaser        285 125 12.0
1560 ShootLaser        34  125 12.0
1560 ShootLaser        85  145 12.0
1560 ShootLaser        234 145 12.0
1560 ShootLaser        285 125 12.0
1584 ShootLaser        34  125 12.0
1584 ShootLaser        85  145 12.0
1584 ShootLaser        234 145 12.0
1584 ShootLaser        285 125 12.0
1608 ShootLaser        34  125 12.0
1608 ShootLaser        85  145 12.0
1608 ShootLaser        234 145 12.0
1608 ShootLaser        285 125 12.0

1200 ShootFlame        15  75  8.0 110.0 90.0 70.0
1200 ShootFlame        304 75  8.0 110.0 90.0 70.0
1224 ShootFlame        15  75  8.0 110.0 90.0 70.0
1224 ShootFlame        304 75  8.0 110.0 90.0 70.0
1248 ShootFlame        15  75  8.0 110.0 90.0 70.0
1248 ShootFlame        304 75  8.0 110.0 90.0 70.0
1272 ShootFlame        15  75  8.0 110.0 90.0 70.0
1272 ShootFlame        304 75  8.0 110.0 90.0 70.0
1296 ShootFlame        15  75  8.0 110.0 90.0 70.0
1296 ShootFlame        304 75  8.0 110.0 90.0 70.0
1320 ShootFlame        15  75  8.0 110.0 90.0 70.0
1320 ShootFlame        304 75  8.0 110.0 90.0 70.0
1344 ShootFlame        15  75  8.0 110.0 90.0 70.0
1344 ShootFlame        304 75  8.0 110.0 90.0 70.0
1368 ShootFlame        15  75  8.0 110.0 90.0 70.0
1368 ShootFlame        304 75  8.0 110.0 90.0 70.0
1392 ShootFlame        15  75  8.0 110.0 90.0 70.0
1392 ShootFlame        304 75  8.0 110.0 90.0 70.0
1416 ShootFlame        15  75  8.0 110.0 90.0 70.0
1416 ShootFlame        304 75  8.0 110.0 90.0 70.0
1440 ShootFlame        15  75  8.0 110.0 90.0 70.0
1440 ShootFlame        304 75  8.0 110.0 90.0 70.0
1464 ShootFlame        15  75  8.0 110.0 90.0 70.0
1464 ShootFlame        304 75  8.0 110.0 90.0 70.0
1488 ShootFlame        15  75  8.0 110.0 90.0 70.0
1488 ShootFlame        304 75  8.0 110.0 90.0 70.0
1512 ShootFlame        15  75  8.0 110.0 90.0 70.0
1512 ShootFlame        304 75  8.0 110.0 90.0 70.0
1536 ShootFlame        15  75  8.0 110.0 90.0 70.0
1536 ShootFlame        304 75  8.0 110.0 90.0 70.0
1560 ShootFlame        15  75  8.0 110.0 90.0 70.0
1560 ShootFlame        304 75  8.0 110.0 90.0 70.0
1584 ShootFlame        15  75  8.0 110.0 90.0 70.0
1584 ShootFlame        304 75  8.0 110.0 90.0 70.0
1608 ShootFlame        15  75  8.0 110.0 90.0 70.0
1608 ShootFlame        304 75  8.0 110.0 90.0 70.0

===========Cmd7===========
1190 SetVelX           2.0

1200 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1200 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1230 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1230 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1260 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1260 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1290 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1290 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1320 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1320 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1350 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1350 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1380 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1380 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1410 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1410 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1440 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1440 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1470 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1470 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1500 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1500 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1530 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1530 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1560 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1560 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1590 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1590 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1620 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1620 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
1650 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
1650 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0



===========Cmd8===========
1700 Charge            0
1700 SetVelX           0.0
1700 SetVelY           0.0

1740 ShootLaser        15  75  16.0
1740 ShootLaser        304 75  16.0
1746 ShootLaser        15  75  16.0
1746 ShootLaser        304 75  16.0
1752 ShootLaser        15  75  16.0
1752 ShootLaser        304 75  16.0
1758 ShootLaser        15  75  16.0
1758 ShootLaser        304 75  16.0
1764 ShootLaser        15  75  16.0
1764 ShootLaser        304 75  16.0
1770 ShootLaser        15  75  16.0
1770 ShootLaser        304 75  16.0
1776 ShootLaser        15  75  16.0
1776 ShootLaser        304 75  16.0
1782 ShootLaser        15  75  16.0
1782 ShootLaser        304 75  16.0
1788 ShootLaser        15  75  16.0
1788 ShootLaser        304 75  16.0
1794 ShootLaser        15  75  16.0
1794 ShootLaser        304 75  16.0
1800 ShootLaser        15  75  16.0
1800 ShootLaser        304 75  16.0
1806 ShootLaser        15  75  16.0
1806 ShootLaser        304 75  16.0
1812 ShootLaser        15  75  16.0
1812 ShootLaser        304 75  16.0
1818 ShootLaser        15  75  16.0
1818 ShootLaser        304 75  16.0
1824 ShootLaser        15  75  16.0
1824 ShootLaser        304 75  16.0
1830 ShootLaser        15  75  16.0
1830 ShootLaser        304 75  16.0
1836 ShootLaser        15  75  16.0
1836 ShootLaser        304 75  16.0
1842 ShootLaser        15  75  16.0
1842 ShootLaser        304 75  16.0
1848 ShootLaser        15  75  16.0
1848 ShootLaser        304 75  16.0
1854 ShootLaser        15  75  16.0
1854 ShootLaser        304 75  16.0
1860 ShootLaser        15  75  16.0
1860 ShootLaser        304 75  16.0
1866 ShootLaser        15  75  16.0
1866 ShootLaser        304 75  16.0
1872 ShootLaser        15  75  16.0
1872 ShootLaser        304 75  16.0
1878 ShootLaser        15  75  16.0
1878 ShootLaser        304 75  16.0
1884 ShootLaser        15  75  16.0
1884 ShootLaser        304 75  16.0
1890 ShootLaser        15  75  16.0
1890 ShootLaser        304 75  16.0
1896 ShootLaser        15  75  16.0
1896 ShootLaser        304 75  16.0
1902 ShootLaser        15  75  16.0
1902 ShootLaser        304 75  16.0
1908 ShootLaser        15  75  16.0
1908 ShootLaser        304 75  16.0
1914 ShootLaser        15  75  16.0
1914 ShootLaser        304 75  16.0
1920 ShootLaser        15  75  16.0
1920 ShootLaser        304 75  16.0
1926 ShootLaser        15  75  16.0
1926 ShootLaser        304 75  16.0
1932 ShootLaser        15  75  16.0
1932 ShootLaser        304 75  16.0
1938 ShootLaser        15  75  16.0
1938 ShootLaser        304 75  16.0
1944 ShootLaser        15  75  16.0
1944 ShootLaser        304 75  16.0
1950 ShootLaser        15  75  16.0
1950 ShootLaser        304 75  16.0
1956 ShootLaser        15  75  16.0
1956 ShootLaser        304 75  16.0
1962 ShootLaser        15  75  16.0
1962 ShootLaser        304 75  16.0
1968 ShootLaser        15  75  16.0
1968 ShootLaser        304 75  16.0
1974 ShootLaser        15  75  16.0
1974 ShootLaser        304 75  16.0
1980 ShootLaser        15  75  16.0
1980 ShootLaser        304 75  16.0
1986 ShootLaser        15  75  16.0
1986 ShootLaser        304 75  16.0
1992 ShootLaser        15  75  16.0
1992 ShootLaser        304 75  16.0
1998 ShootLaser        15  75  16.0
1998 ShootLaser        304 75  16.0
2004 ShootLaser        15  75  16.0
2004 ShootLaser        304 75  16.0
2010 ShootLaser        15  75  16.0
2010 ShootLaser        304 75  16.0
2016 ShootLaser        15  75  16.0
2016 ShootLaser        304 75  16.0
2022 ShootLaser        15  75  16.0
2022 ShootLaser        304 75  16.0
2028 ShootLaser        15  75  16.0
2028 ShootLaser        304 75  16.0
2034 ShootLaser        15  75  16.0
2034 ShootLaser        304 75  16.0

1740 ShootToPlayerRand 160 123 5.0 18.0 3
1750 ShootToPlayerRand 160 123 5.0 18.0 3
1760 ShootToPlayerRand 160 123 5.0 18.0 3
1770 ShootToPlayerRand 160 123 5.0 18.0 3
1780 ShootToPlayerRand 160 123 5.0 18.0 3
1790 ShootToPlayerRand 160 123 5.0 18.0 3
1800 ShootToPlayerRand 160 123 5.0 18.0 3
1810 ShootToPlayerRand 160 123 5.0 18.0 3
1820 ShootToPlayerRand 160 123 5.0 18.0 3
1830 ShootToPlayerRand 160 123 5.0 18.0 3
1840 ShootToPlayerRand 160 123 5.0 18.0 3
1850 ShootToPlayerRand 160 123 5.0 18.0 3
1860 ShootToPlayerRand 160 123 5.0 18.0 3
1870 ShootToPlayerRand 160 123 5.0 18.0 3
1880 ShootToPlayerRand 160 123 5.0 18.0 3
1890 ShootToPlayerRand 160 123 5.0 18.0 3
1900 ShootToPlayerRand 160 123 5.0 18.0 3
1910 ShootToPlayerRand 160 123 5.0 18.0 3
1920 ShootToPlayerRand 160 123 5.0 18.0 3
1930 ShootToPlayerRand 160 123 5.0 18.0 3
1940 ShootToPlayerRand 160 123 5.0 18.0 3
1950 ShootToPlayerRand 160 123 5.0 18.0 3
1960 ShootToPlayerRand 160 123 5.0 18.0 3
1970 ShootToPlayerRand 160 123 5.0 18.0 3
1980 ShootToPlayerRand 160 123 5.0 18.0 3
1990 ShootToPlayerRand 160 123 5.0 18.0 3
2000 ShootToPlayerRand 160 123 5.0 18.0 3
2010 ShootToPlayerRand 160 123 5.0 18.0 3
2020 ShootToPlayerRand 160 123 5.0 18.0 3
2030 ShootToPlayerRand 160 123 5.0 18.0 3

1740 ShootToPlayerRand 160 123 8.0 18.0 3
1750 ShootToPlayerRand 160 123 8.0 18.0 3
1760 ShootToPlayerRand 160 123 8.0 18.0 3
1770 ShootToPlayerRand 160 123 8.0 18.0 3
1780 ShootToPlayerRand 160 123 8.0 18.0 3
1790 ShootToPlayerRand 160 123 8.0 18.0 3
1800 ShootToPlayerRand 160 123 8.0 18.0 3
1810 ShootToPlayerRand 160 123 8.0 18.0 3
1820 ShootToPlayerRand 160 123 8.0 18.0 3
1830 ShootToPlayerRand 160 123 8.0 18.0 3
1840 ShootToPlayerRand 160 123 8.0 18.0 3
1850 ShootToPlayerRand 160 123 8.0 18.0 3
1860 ShootToPlayerRand 160 123 8.0 18.0 3
1870 ShootToPlayerRand 160 123 8.0 18.0 3
1880 ShootToPlayerRand 160 123 8.0 18.0 3
1890 ShootToPlayerRand 160 123 8.0 18.0 3
1900 ShootToPlayerRand 160 123 8.0 18.0 3
1910 ShootToPlayerRand 160 123 8.0 18.0 3
1920 ShootToPlayerRand 160 123 8.0 18.0 3
1930 ShootToPlayerRand 160 123 8.0 18.0 3
1940 ShootToPlayerRand 160 123 8.0 18.0 3
1950 ShootToPlayerRand 160 123 8.0 18.0 3
1960 ShootToPlayerRand 160 123 8.0 18.0 3
1970 ShootToPlayerRand 160 123 8.0 18.0 3
1980 ShootToPlayerRand 160 123 8.0 18.0 3
1990 ShootToPlayerRand 160 123 8.0 18.0 3
2000 ShootToPlayerRand 160 123 8.0 18.0 3
2010 ShootToPlayerRand 160 123 8.0 18.0 3
2020 ShootToPlayerRand 160 123 8.0 18.0 3
2030 ShootToPlayerRand 160 123 8.0 18.0 3
============Cmd9==========
2201 SetVelX           0.0
2201 SetVelY           0.0    
============Cmd10=========
2380 SetVelX            1.5

2380 ShootToPlayer     160 123 6.0 -60.0 -58.0 -56.0 -50.0 -48.0 -46.0 -40.0 -38.0 -36.0 -30.0 -28.0 -26.0 -20.0 -18.0 -16.0 -10.0 -8.0 -6.0 0.0 2.0 4.0 10.0 12.0 14.0 45.0 30.0 22.0 24.0 30.0 32.0 34.0 40.0 42.0 44.0 50.0 52.0 54.0 60.0 62.0 64.0 
2420 ShootToPlayer     160 123 6.0 -59.0 -57.0 -55.0 -49.0 -47.0 -45.0 -39.0 -37.0 -35.0 -29.0 -27.0 -25.0 -19.0 -17.0 -15.0 -9.0 -7.0 -5.0 1.0 3.0 5.0 11.0 13.0 15.0 21.0 23.0 25.0 31.0 33.0 35.0 41.0 43.0 45.0 51.0 53.0 55.0 61.0 63.0 65.0 
2460 ShootToPlayer     160 123 6.0 -59.0 -57.0 -55.0 -49.0 -47.0 -45.0 -39.0 -37.0 -35.0 -29.0 -27.0 -25.0 -19.0 -17.0 -15.0 -9.0 -7.0 -5.0 1.0 3.0 5.0 11.0 13.0 15.0 21.0 23.0 25.0 31.0 33.0 35.0 41.0 43.0 45.0 51.0 53.0 55.0 61.0 63.0 65.0 
2500 ShootToPlayer     160 123 6.0 -67.0 -65.0 -63.0 -57.0 -55.0 -53.0 -47.0 -45.0 -43.0 -37.0 -35.0 -33.0 -27.0 -25.0 -23.0 -17.0 -15.0 -13.0 -7.0 -5.0 -3.0 3.0 5.0 7.0 13.0 15.0 17.0 23.0 25.0 27.0 33.0 35.0 37.0 43.0 45.0 47.0 53.0 55.0 57.0 
2540 ShootToPlayer     160 123 6.0 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 
2580 ShootToPlayer     160 123 6.0 -63.0 -61.0 -59.0 -53.0 -51.0 -49.0 -43.0 -41.0 -39.0 -33.0 -31.0 -29.0 -23.0 -21.0 -19.0 -13.0 -11.0 -9.0 -3.0 -1.0 1.0 7.0 9.0 11.0 17.0 19.0 21.0 27.0 29.0 31.0 37.0 39.0 41.0 47.0 49.0 51.0 57.0 59.0 61.0 
2620 ShootToPlayer     160 123 6.0 -63.0 -61.0 -59.0 -53.0 -51.0 -49.0 -43.0 -41.0 -39.0 -33.0 -31.0 -29.0 -23.0 -21.0 -19.0 -13.0 -11.0 -9.0 -3.0 -1.0 1.0 7.0 9.0 11.0 17.0 19.0 21.0 27.0 29.0 31.0 37.0 39.0 41.0 47.0 49.0 51.0 57.0 59.0 61.0 
2660 ShootToPlayer     160 123 6.0 -58.0 -56.0 -54.0 -48.0 -46.0 -44.0 -38.0 -36.0 -34.0 -28.0 -26.0 -24.0 -18.0 -16.0 -14.0 -8.0 -6.0 -4.0 45.0 3.0 4.0 6.0 12.0 14.0 16.0 22.0 24.0 45.0 36.0 32.0 34.0 36.0 42.0 44.0 46.0 52.0 54.0 56.0 62.0 64.0 66.0 
2700 ShootToPlayer     160 123 6.0 -67.0 -65.0 -63.0 -57.0 -55.0 -53.0 -47.0 -45.0 -43.0 -37.0 -35.0 -33.0 -27.0 -25.0 -23.0 -17.0 -15.0 -13.0 -7.0 -5.0 -3.0 3.0 5.0 7.0 13.0 15.0 17.0 23.0 25.0 27.0 33.0 35.0 37.0 43.0 45.0 47.0 53.0 55.0 57.0 
2740 ShootToPlayer     160 123 6.0 -68.0 -66.0 -64.0 -58.0 -56.0 -54.0 -48.0 -46.0 -44.0 -38.0 -36.0 -34.0 -28.0 -26.0 -24.0 -18.0 -16.0 -14.0 -8.0 -6.0 -4.0 45.0 3.0 4.0 6.0 12.0 14.0 16.0 22.0 24.0 45.0 36.0 32.0 34.0 36.0 42.0 44.0 46.0 52.0 54.0 56.0 
2780 ShootToPlayer     160 123 6.0 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 
2820 ShootToPlayer     160 123 6.0 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 

2380 ShootToPlayer     160 123 7.7 -60.0 -58.0 -56.0 -50.0 -48.0 -46.0 -40.0 -38.0 -36.0 -30.0 -28.0 -26.0 -20.0 -18.0 -16.0 -10.0 -8.0 -6.0 0.0 2.0 4.0 10.0 12.0 14.0 45.0 30.0 22.0 24.0 30.0 32.0 34.0 40.0 42.0 44.0 50.0 52.0 54.0 60.0 62.0 64.0 
2420 ShootToPlayer     160 123 7.7 -59.0 -57.0 -55.0 -49.0 -47.0 -45.0 -39.0 -37.0 -35.0 -29.0 -27.0 -25.0 -19.0 -17.0 -15.0 -9.0 -7.0 -5.0 1.0 3.0 5.0 11.0 13.0 15.0 21.0 23.0 25.0 31.0 33.0 35.0 41.0 43.0 45.0 51.0 53.0 55.0 61.0 63.0 65.0 
2460 ShootToPlayer     160 123 7.7 -59.0 -57.0 -55.0 -49.0 -47.0 -45.0 -39.0 -37.0 -35.0 -29.0 -27.0 -25.0 -19.0 -17.0 -15.0 -9.0 -7.0 -5.0 1.0 3.0 5.0 11.0 13.0 15.0 21.0 23.0 25.0 31.0 33.0 35.0 41.0 43.0 45.0 51.0 53.0 55.0 61.0 63.0 65.0 
2500 ShootToPlayer     160 123 7.7 -67.0 -65.0 -63.0 -57.0 -55.0 -53.0 -47.0 -45.0 -43.0 -37.0 -35.0 -33.0 -27.0 -25.0 -23.0 -17.0 -15.0 -13.0 -7.0 -5.0 -3.0 3.0 5.0 7.0 13.0 15.0 17.0 23.0 25.0 27.0 33.0 35.0 37.0 43.0 45.0 47.0 53.0 55.0 57.0 
2540 ShootToPlayer     160 123 7.7 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 
2580 ShootToPlayer     160 123 7.7 -63.0 -61.0 -59.0 -53.0 -51.0 -49.0 -43.0 -41.0 -39.0 -33.0 -31.0 -29.0 -23.0 -21.0 -19.0 -13.0 -11.0 -9.0 -3.0 -1.0 1.0 7.0 9.0 11.0 17.0 19.0 21.0 27.0 29.0 31.0 37.0 39.0 41.0 47.0 49.0 51.0 57.0 59.0 61.0 
2620 ShootToPlayer     160 123 7.7 -63.0 -61.0 -59.0 -53.0 -51.0 -49.0 -43.0 -41.0 -39.0 -33.0 -31.0 -29.0 -23.0 -21.0 -19.0 -13.0 -11.0 -9.0 -3.0 -1.0 1.0 7.0 9.0 11.0 17.0 19.0 21.0 27.0 29.0 31.0 37.0 39.0 41.0 47.0 49.0 51.0 57.0 59.0 61.0 
2660 ShootToPlayer     160 123 7.7 -58.0 -56.0 -54.0 -48.0 -46.0 -44.0 -38.0 -36.0 -34.0 -28.0 -26.0 -24.0 -18.0 -16.0 -14.0 -8.0 -6.0 -4.0 45.0 3.0 4.0 6.0 12.0 14.0 16.0 22.0 24.0 45.0 36.0 32.0 34.0 36.0 42.0 44.0 46.0 52.0 54.0 56.0 62.0 64.0 66.0 
2700 ShootToPlayer     160 123 7.7 -67.0 -65.0 -63.0 -57.0 -55.0 -53.0 -47.0 -45.0 -43.0 -37.0 -35.0 -33.0 -27.0 -25.0 -23.0 -17.0 -15.0 -13.0 -7.0 -5.0 -3.0 3.0 5.0 7.0 13.0 15.0 17.0 23.0 25.0 27.0 33.0 35.0 37.0 43.0 45.0 47.0 53.0 55.0 57.0 
2740 ShootToPlayer     160 123 7.7 -68.0 -66.0 -64.0 -58.0 -56.0 -54.0 -48.0 -46.0 -44.0 -38.0 -36.0 -34.0 -28.0 -26.0 -24.0 -18.0 -16.0 -14.0 -8.0 -6.0 -4.0 45.0 3.0 4.0 6.0 12.0 14.0 16.0 22.0 24.0 45.0 36.0 32.0 34.0 36.0 42.0 44.0 46.0 52.0 54.0 56.0 
2780 ShootToPlayer     160 123 7.7 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 
2820 ShootToPlayer     160 123 7.7 -61.0 -59.0 -57.0 -51.0 -49.0 -47.0 -41.0 -39.0 -37.0 -31.0 -29.0 -27.0 -21.0 -19.0 -17.0 -11.0 -9.0 -7.0 -1.0 1.0 3.0 9.0 11.0 13.0 19.0 21.0 23.0 29.0 31.0 33.0 39.0 41.0 43.0 49.0 51.0 53.0 59.0 61.0 63.0 


============Cmd11=========
2380 SetVelX           1.5

2380 ShootToPlayerRand 15  75 4.0 45.0 4
2380 ShootToPlayerRand 304 75 4.0 45.0 4
2389 ShootToPlayerRand 15  75 4.0 45.0 4
2389 ShootToPlayerRand 304 75 4.0 45.0 4
2398 ShootToPlayerRand 15  75 4.0 45.0 4
2398 ShootToPlayerRand 304 75 4.0 45.0 4
2407 ShootToPlayerRand 15  75 4.0 45.0 4
2407 ShootToPlayerRand 304 75 4.0 45.0 4
2416 ShootToPlayerRand 15  75 4.0 45.0 4
2416 ShootToPlayerRand 304 75 4.0 45.0 4
2425 ShootToPlayerRand 15  75 4.0 45.0 4
2425 ShootToPlayerRand 304 75 4.0 45.0 4
2434 ShootToPlayerRand 15  75 4.0 45.0 4
2434 ShootToPlayerRand 304 75 4.0 45.0 4
2443 ShootToPlayerRand 15  75 4.0 45.0 4
2443 ShootToPlayerRand 304 75 4.0 45.0 4
2452 ShootToPlayerRand 15  75 4.0 45.0 4
2452 ShootToPlayerRand 304 75 4.0 45.0 4
2461 ShootToPlayerRand 15  75 4.0 45.0 4
2461 ShootToPlayerRand 304 75 4.0 45.0 4
2470 ShootToPlayerRand 15  75 4.0 45.0 4
2470 ShootToPlayerRand 304 75 4.0 45.0 4
2479 ShootToPlayerRand 15  75 4.0 45.0 4
2479 ShootToPlayerRand 304 75 4.0 45.0 4
2488 ShootToPlayerRand 15  75 4.0 45.0 4
2488 ShootToPlayerRand 304 75 4.0 45.0 4
2497 ShootToPlayerRand 15  75 4.0 45.0 4
2497 ShootToPlayerRand 304 75 4.0 45.0 4
2506 ShootToPlayerRand 15  75 4.0 45.0 4
2506 ShootToPlayerRand 304 75 4.0 45.0 4
2515 ShootToPlayerRand 15  75 4.0 45.0 4
2515 ShootToPlayerRand 304 75 4.0 45.0 4
2524 ShootToPlayerRand 15  75 4.0 45.0 4
2524 ShootToPlayerRand 304 75 4.0 45.0 4
2533 ShootToPlayerRand 15  75 4.0 45.0 4
2533 ShootToPlayerRand 304 75 4.0 45.0 4
2542 ShootToPlayerRand 15  75 4.0 45.0 4
2542 ShootToPlayerRand 304 75 4.0 45.0 4
2551 ShootToPlayerRand 15  75 4.0 45.0 4
2551 ShootToPlayerRand 304 75 4.0 45.0 4
2560 ShootToPlayerRand 15  75 4.0 45.0 4
2560 ShootToPlayerRand 304 75 4.0 45.0 4
2569 ShootToPlayerRand 15  75 4.0 45.0 4
2569 ShootToPlayerRand 304 75 4.0 45.0 4
2578 ShootToPlayerRand 15  75 4.0 45.0 4
2578 ShootToPlayerRand 304 75 4.0 45.0 4
2587 ShootToPlayerRand 15  75 4.0 45.0 4
2587 ShootToPlayerRand 304 75 4.0 45.0 4
2596 ShootToPlayerRand 15  75 4.0 45.0 4
2596 ShootToPlayerRand 304 75 4.0 45.0 4
2605 ShootToPlayerRand 15  75 4.0 45.0 4
2605 ShootToPlayerRand 304 75 4.0 45.0 4
2614 ShootToPlayerRand 15  75 4.0 45.0 4
2614 ShootToPlayerRand 304 75 4.0 45.0 4
2623 ShootToPlayerRand 15  75 4.0 45.0 4
2623 ShootToPlayerRand 304 75 4.0 45.0 4
2632 ShootToPlayerRand 15  75 4.0 45.0 4
2632 ShootToPlayerRand 304 75 4.0 45.0 4
2641 ShootToPlayerRand 15  75 4.0 45.0 4
2641 ShootToPlayerRand 304 75 4.0 45.0 4
2650 ShootToPlayerRand 15  75 4.0 45.0 4
2650 ShootToPlayerRand 304 75 4.0 45.0 4
2659 ShootToPlayerRand 15  75 4.0 45.0 4
2659 ShootToPlayerRand 304 75 4.0 45.0 4
2668 ShootToPlayerRand 15  75 4.0 45.0 4
2668 ShootToPlayerRand 304 75 4.0 45.0 4
2677 ShootToPlayerRand 15  75 4.0 45.0 4
2677 ShootToPlayerRand 304 75 4.0 45.0 4
2686 ShootToPlayerRand 15  75 4.0 45.0 4
2686 ShootToPlayerRand 304 75 4.0 45.0 4
2695 ShootToPlayerRand 15  75 4.0 45.0 4
2695 ShootToPlayerRand 304 75 4.0 45.0 4
2704 ShootToPlayerRand 15  75 4.0 45.0 4
2704 ShootToPlayerRand 304 75 4.0 45.0 4
2713 ShootToPlayerRand 15  75 4.0 45.0 4
2713 ShootToPlayerRand 304 75 4.0 45.0 4
2722 ShootToPlayerRand 15  75 4.0 45.0 4
2722 ShootToPlayerRand 304 75 4.0 45.0 4
2731 ShootToPlayerRand 15  75 4.0 45.0 4
2731 ShootToPlayerRand 304 75 4.0 45.0 4
2740 ShootToPlayerRand 15  75 4.0 45.0 4
2740 ShootToPlayerRand 304 75 4.0 45.0 4
2749 ShootToPlayerRand 15  75 4.0 45.0 4
2749 ShootToPlayerRand 304 75 4.0 45.0 4
2758 ShootToPlayerRand 15  75 4.0 45.0 4
2758 ShootToPlayerRand 304 75 4.0 45.0 4
2767 ShootToPlayerRand 15  75 4.0 45.0 4
2767 ShootToPlayerRand 304 75 4.0 45.0 4
2776 ShootToPlayerRand 15  75 4.0 45.0 4
2776 ShootToPlayerRand 304 75 4.0 45.0 4
2785 ShootToPlayerRand 15  75 4.0 45.0 4
2785 ShootToPlayerRand 304 75 4.0 45.0 4
2794 ShootToPlayerRand 15  75 4.0 45.0 4
2794 ShootToPlayerRand 304 75 4.0 45.0 4
2803 ShootToPlayerRand 15  75 4.0 45.0 4
2803 ShootToPlayerRand 304 75 4.0 45.0 4
2812 ShootToPlayerRand 15  75 4.0 45.0 4
2812 ShootToPlayerRand 304 75 4.0 45.0 4
============Cmd12=========
2900  SetVelX           0.0
2900  SetVelY           -2.0
2930  SetVelY           0.0
3000  SetVelY           6.0
3110  SetVelY           0.0  
3300  SetVelY           -6.0
3400  SetVelY           0.0

3010 Shoot             15  75 5.0 86.0 94.0
3010 Shoot             224 75 5.0 86.0 94.0
3013 Shoot             15  75 5.0 78.0 102.0
3013 Shoot             224 75 5.0 78.0 102.0
3016 Shoot             15  75 5.0 70.0 110.0
3016 Shoot             224 75 5.0 70.0 110.0
3019 Shoot             15  75 5.0 62.0 118.0
3019 Shoot             224 75 5.0 62.0 118.0
3022 Shoot             15  75 5.0 54.0 126.0
3022 Shoot             224 75 5.0 54.0 126.0
3025 Shoot             15  75 5.0 46.0 134.0
3025 Shoot             224 75 5.0 46.0 134.0
3028 Shoot             15  75 5.0 38.0 142.0
3028 Shoot             224 75 5.0 38.0 142.0
3031 Shoot             15  75 5.0 30.0 150.0
3031 Shoot             224 75 5.0 30.0 150.0
3034 Shoot             15  75 5.0 22.0 158.0
3034 Shoot             224 75 5.0 22.0 158.0
3037 Shoot             15  75 5.0 14.0 166.0
3037 Shoot             224 75 5.0 14.0 166.0
3040 Shoot             15  75 5.0 6.0 174.0
3040 Shoot             224 75 5.0 6.0 174.0
3043 Shoot             15  75 5.0 -2.0 182.0
3043 Shoot             224 75 5.0 -2.0 182.0
3046 Shoot             15  75 5.0 -10.0 190.0
3046 Shoot             224 75 5.0 -10.0 190.0
3049 Shoot             15  75 5.0 -18.0 198.0
3049 Shoot             224 75 5.0 -18.0 198.0
3052 Shoot             15  75 5.0 -26.0 206.0
3052 Shoot             224 75 5.0 -26.0 206.0
3055 Shoot             15  75 5.0 -34.0 214.0
3055 Shoot             224 75 5.0 -34.0 214.0
3058 Shoot             15  75 5.0 -42.0 222.0
3058 Shoot             224 75 5.0 -42.0 222.0
3061 Shoot             15  75 5.0 -50.0 230.0
3061 Shoot             224 75 5.0 -50.0 230.0
3064 Shoot             15  75 5.0 -58.0 238.0
3064 Shoot             224 75 5.0 -58.0 238.0
3067 Shoot             15  75 5.0 -66.0 246.0
3067 Shoot             224 75 5.0 -66.0 246.0
3070 Shoot             15  75 5.0 -74.0 254.0
3070 Shoot             224 75 5.0 -74.0 254.0
3073 Shoot             15  75 5.0 -82.0 262.0
3073 Shoot             224 75 5.0 -82.0 262.0
3076 Shoot             15  75 5.0 -90.0 270.0
3076 Shoot             224 75 5.0 -90.0 270.0

3013 Shoot             15  75 5.5 86.0 94.0
3013 Shoot             224 75 5.5 86.0 94.0
3016 Shoot             15  75 5.5 78.0 102.0
3016 Shoot             224 75 5.5 78.0 102.0
3019 Shoot             15  75 5.5 70.0 110.0
3019 Shoot             224 75 5.5 70.0 110.0
3022 Shoot             15  75 5.5 62.0 118.0
3022 Shoot             224 75 5.5 62.0 118.0
3025 Shoot             15  75 5.5 54.0 126.0
3025 Shoot             224 75 5.5 54.0 126.0
3028 Shoot             15  75 5.5 46.0 134.0
3028 Shoot             224 75 5.5 46.0 134.0
3031 Shoot             15  75 5.5 38.0 142.0
3031 Shoot             224 75 5.5 38.0 142.0
3034 Shoot             15  75 5.5 30.0 150.0
3034 Shoot             224 75 5.5 30.0 150.0
3037 Shoot             15  75 5.5 22.0 158.0
3037 Shoot             224 75 5.5 22.0 158.0
3040 Shoot             15  75 5.5 14.0 166.0
3040 Shoot             224 75 5.5 14.0 166.0
3043 Shoot             15  75 5.5 6.0 174.0
3043 Shoot             224 75 5.5 6.0 174.0
3046 Shoot             15  75 5.5 -2.0 182.0
3046 Shoot             224 75 5.5 -2.0 182.0
3049 Shoot             15  75 5.5 -10.0 190.0
3049 Shoot             224 75 5.5 -10.0 190.0
3052 Shoot             15  75 5.5 -18.0 198.0
3052 Shoot             224 75 5.5 -18.0 198.0
3055 Shoot             15  75 5.5 -26.0 206.0
3055 Shoot             224 75 5.5 -26.0 206.0
3058 Shoot             15  75 5.5 -34.0 214.0
3058 Shoot             224 75 5.5 -34.0 214.0
3061 Shoot             15  75 5.5 -42.0 222.0
3061 Shoot             224 75 5.5 -42.0 222.0
3064 Shoot             15  75 5.5 -50.0 230.0
3064 Shoot             224 75 5.5 -50.0 230.0
3067 Shoot             15  75 5.5 -58.0 238.0
3067 Shoot             224 75 5.5 -58.0 238.0
3070 Shoot             15  75 5.5 -66.0 246.0
3070 Shoot             224 75 5.5 -66.0 246.0
3073 Shoot             15  75 5.5 -74.0 254.0
3073 Shoot             224 75 5.5 -74.0 254.0
3076 Shoot             15  75 5.5 -82.0 262.0
3076 Shoot             224 75 5.5 -82.0 262.0
3079 Shoot             15  75 5.5 -90.0 270.0
3079 Shoot             224 75 5.5 -90.0 270.0

3016 Shoot             15  75 6.0 86.0 94.0
3016 Shoot             224 75 6.0 86.0 94.0
3019 Shoot             15  75 6.0 78.0 102.0
3019 Shoot             224 75 6.0 78.0 102.0
3022 Shoot             15  75 6.0 70.0 110.0
3022 Shoot             224 75 6.0 70.0 110.0
3025 Shoot             15  75 6.0 62.0 118.0
3025 Shoot             224 75 6.0 62.0 118.0
3028 Shoot             15  75 6.0 54.0 126.0
3028 Shoot             224 75 6.0 54.0 126.0
3031 Shoot             15  75 6.0 46.0 134.0
3031 Shoot             224 75 6.0 46.0 134.0
3034 Shoot             15  75 6.0 38.0 142.0
3034 Shoot             224 75 6.0 38.0 142.0
3037 Shoot             15  75 6.0 30.0 150.0
3037 Shoot             224 75 6.0 30.0 150.0
3040 Shoot             15  75 6.0 22.0 158.0
3040 Shoot             224 75 6.0 22.0 158.0
3043 Shoot             15  75 6.0 14.0 166.0
3043 Shoot             224 75 6.0 14.0 166.0
3046 Shoot             15  75 6.0 6.0 174.0
3046 Shoot             224 75 6.0 6.0 174.0
3049 Shoot             15  75 6.0 -2.0 182.0
3049 Shoot             224 75 6.0 -2.0 182.0
3052 Shoot             15  75 6.0 -10.0 190.0
3052 Shoot             224 75 6.0 -10.0 190.0
3055 Shoot             15  75 6.0 -18.0 198.0
3055 Shoot             224 75 6.0 -18.0 198.0
3058 Shoot             15  75 6.0 -26.0 206.0
3058 Shoot             224 75 6.0 -26.0 206.0
3061 Shoot             15  75 6.0 -34.0 214.0
3061 Shoot             224 75 6.0 -34.0 214.0
3064 Shoot             15  75 6.0 -42.0 222.0
3064 Shoot             224 75 6.0 -42.0 222.0
3067 Shoot             15  75 6.0 -50.0 230.0
3067 Shoot             224 75 6.0 -50.0 230.0
3070 Shoot             15  75 6.0 -58.0 238.0
3070 Shoot             224 75 6.0 -58.0 238.0
3073 Shoot             15  75 6.0 -66.0 246.0
3073 Shoot             224 75 6.0 -66.0 246.0
3076 Shoot             15  75 6.0 -74.0 254.0
3076 Shoot             224 75 6.0 -74.0 254.0
3079 Shoot             15  75 6.0 -82.0 262.0
3079 Shoot             224 75 6.0 -82.0 262.0
3082 Shoot             15  75 6.0 -90.0 270.0
3082 Shoot             224 75 6.0 -90.0 270.0


3300 Shoot             15  75 5.0 266.0 274.0
3300 Shoot             224 75 5.0 266.0 274.0
3303 Shoot             15  75 5.0 258.0 282.0
3303 Shoot             224 75 5.0 258.0 282.0
3306 Shoot             15  75 5.0 250.0 290.0
3306 Shoot             224 75 5.0 250.0 290.0
3309 Shoot             15  75 5.0 242.0 298.0
3309 Shoot             224 75 5.0 242.0 298.0
3312 Shoot             15  75 5.0 234.0 306.0
3312 Shoot             224 75 5.0 234.0 306.0
3315 Shoot             15  75 5.0 226.0 314.0
3315 Shoot             224 75 5.0 226.0 314.0
3318 Shoot             15  75 5.0 218.0 322.0
3318 Shoot             224 75 5.0 218.0 322.0
3321 Shoot             15  75 5.0 210.0 330.0
3321 Shoot             224 75 5.0 210.0 330.0
3324 Shoot             15  75 5.0 202.0 338.0
3324 Shoot             224 75 5.0 202.0 338.0
3327 Shoot             15  75 5.0 194.0 346.0
3327 Shoot             224 75 5.0 194.0 346.0
3330 Shoot             15  75 5.0 186.0 354.0
3330 Shoot             224 75 5.0 186.0 354.0
3333 Shoot             15  75 5.0 178.0 362.0
3333 Shoot             224 75 5.0 178.0 362.0
3336 Shoot             15  75 5.0 170.0 370.0
3336 Shoot             224 75 5.0 170.0 370.0
3339 Shoot             15  75 5.0 162.0 378.0
3339 Shoot             224 75 5.0 162.0 378.0
3342 Shoot             15  75 5.0 154.0 386.0
3342 Shoot             224 75 5.0 154.0 386.0
3345 Shoot             15  75 5.0 146.0 394.0
3345 Shoot             224 75 5.0 146.0 394.0
3348 Shoot             15  75 5.0 138.0 402.0
3348 Shoot             224 75 5.0 138.0 402.0
3351 Shoot             15  75 5.0 130.0 410.0
3351 Shoot             224 75 5.0 130.0 410.0
3354 Shoot             15  75 5.0 122.0 418.0
3354 Shoot             224 75 5.0 122.0 418.0
3357 Shoot             15  75 5.0 114.0 426.0
3357 Shoot             224 75 5.0 114.0 426.0
3360 Shoot             15  75 5.0 106.0 434.0
3360 Shoot             224 75 5.0 106.0 434.0
3363 Shoot             15  75 5.0 98.0 442.0
3363 Shoot             224 75 5.0 98.0 442.0
3366 Shoot             15  75 5.0 90.0 450.0
3366 Shoot             224 75 5.0 90.0 450.0

3303 Shoot             15  75 5.5 266.0 274.0
3303 Shoot             224 75 5.5 266.0 274.0
3306 Shoot             15  75 5.5 258.0 282.0
3306 Shoot             224 75 5.5 258.0 282.0
3309 Shoot             15  75 5.5 250.0 290.0
3309 Shoot             224 75 5.5 250.0 290.0
3312 Shoot             15  75 5.5 242.0 298.0
3312 Shoot             224 75 5.5 242.0 298.0
3315 Shoot             15  75 5.5 234.0 306.0
3315 Shoot             224 75 5.5 234.0 306.0
3318 Shoot             15  75 5.5 226.0 314.0
3318 Shoot             224 75 5.5 226.0 314.0
3321 Shoot             15  75 5.5 218.0 322.0
3321 Shoot             224 75 5.5 218.0 322.0
3324 Shoot             15  75 5.5 210.0 330.0
3324 Shoot             224 75 5.5 210.0 330.0
3327 Shoot             15  75 5.5 202.0 338.0
3327 Shoot             224 75 5.5 202.0 338.0
3330 Shoot             15  75 5.5 194.0 346.0
3330 Shoot             224 75 5.5 194.0 346.0
3333 Shoot             15  75 5.5 186.0 354.0
3333 Shoot             224 75 5.5 186.0 354.0
3336 Shoot             15  75 5.5 178.0 362.0
3336 Shoot             224 75 5.5 178.0 362.0
3339 Shoot             15  75 5.5 170.0 370.0
3339 Shoot             224 75 5.5 170.0 370.0
3342 Shoot             15  75 5.5 162.0 378.0
3342 Shoot             224 75 5.5 162.0 378.0
3345 Shoot             15  75 5.5 154.0 386.0
3345 Shoot             224 75 5.5 154.0 386.0
3348 Shoot             15  75 5.5 146.0 394.0
3348 Shoot             224 75 5.5 146.0 394.0
3351 Shoot             15  75 5.5 138.0 402.0
3351 Shoot             224 75 5.5 138.0 402.0
3354 Shoot             15  75 5.5 130.0 410.0
3354 Shoot             224 75 5.5 130.0 410.0
3357 Shoot             15  75 5.5 122.0 418.0
3357 Shoot             224 75 5.5 122.0 418.0
3360 Shoot             15  75 5.5 114.0 426.0
3360 Shoot             224 75 5.5 114.0 426.0
3363 Shoot             15  75 5.5 106.0 434.0
3363 Shoot             224 75 5.5 106.0 434.0
3366 Shoot             15  75 5.5 98.0 442.0
3366 Shoot             224 75 5.5 98.0 442.0
3369 Shoot             15  75 5.5 90.0 450.0
3369 Shoot             224 75 5.5 90.0 450.0

3306 Shoot             15  75 6.0 266.0 274.0
3306 Shoot             224 75 6.0 266.0 274.0
3309 Shoot             15  75 6.0 258.0 282.0
3309 Shoot             224 75 6.0 258.0 282.0
3312 Shoot             15  75 6.0 250.0 290.0
3312 Shoot             224 75 6.0 250.0 290.0
3315 Shoot             15  75 6.0 242.0 298.0
3315 Shoot             224 75 6.0 242.0 298.0
3318 Shoot             15  75 6.0 234.0 306.0
3318 Shoot             224 75 6.0 234.0 306.0
3321 Shoot             15  75 6.0 226.0 314.0
3321 Shoot             224 75 6.0 226.0 314.0
3324 Shoot             15  75 6.0 218.0 322.0
3324 Shoot             224 75 6.0 218.0 322.0
3327 Shoot             15  75 6.0 210.0 330.0
3327 Shoot             224 75 6.0 210.0 330.0
3330 Shoot             15  75 6.0 202.0 338.0
3330 Shoot             224 75 6.0 202.0 338.0
3333 Shoot             15  75 6.0 194.0 346.0
3333 Shoot             224 75 6.0 194.0 346.0
3336 Shoot             15  75 6.0 186.0 354.0
3336 Shoot             224 75 6.0 186.0 354.0
3339 Shoot             15  75 6.0 178.0 362.0
3339 Shoot             224 75 6.0 178.0 362.0
3342 Shoot             15  75 6.0 170.0 370.0
3342 Shoot             224 75 6.0 170.0 370.0
3345 Shoot             15  75 6.0 162.0 378.0
3345 Shoot             224 75 6.0 162.0 378.0
3348 Shoot             15  75 6.0 154.0 386.0
3348 Shoot             224 75 6.0 154.0 386.0
3351 Shoot             15  75 6.0 146.0 394.0
3351 Shoot             224 75 6.0 146.0 394.0
3354 Shoot             15  75 6.0 138.0 402.0
3354 Shoot             224 75 6.0 138.0 402.0
3357 Shoot             15  75 6.0 130.0 410.0
3357 Shoot             224 75 6.0 130.0 410.0
3360 Shoot             15  75 6.0 122.0 418.0
3360 Shoot             224 75 6.0 122.0 418.0
3363 Shoot             15  75 6.0 114.0 426.0
3363 Shoot             224 75 6.0 114.0 426.0
3366 Shoot             15  75 6.0 106.0 434.0
3366 Shoot             224 75 6.0 106.0 434.0
3369 Shoot             15  75 6.0 98.0 442.0
3369 Shoot             224 75 6.0 98.0 442.0
3372 Shoot             15  75 6.0 90.0 450.0
3372 Shoot             224 75 6.0 90.0 450.0


============Cmd13=========
3610 SetVelX           2.0

3620 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3627 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3634 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3641 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3648 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3655 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3662 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3669 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3676 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3683 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 

3634 ShootToPlayer     160 123 4.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3641 ShootToPlayer     160 123 4.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3648 ShootToPlayer     160 123 5.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3655 ShootToPlayer     160 123 5.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3662 ShootToPlayer     160 123 6.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3669 ShootToPlayer     160 123 6.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3676 ShootToPlayer     160 123 7.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3683 ShootToPlayer     160 123 7.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3690 ShootToPlayer     160 123 8.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3697 ShootToPlayer     160 123 8.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 


3790 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3797 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3804 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3811 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3818 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3825 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3832 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3839 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3846 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3853 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 

3804 ShootToPlayer     160 123 4.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3811 ShootToPlayer     160 123 4.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3818 ShootToPlayer     160 123 5.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3825 ShootToPlayer     160 123 5.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3832 ShootToPlayer     160 123 6.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3839 ShootToPlayer     160 123 6.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3846 ShootToPlayer     160 123 7.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3853 ShootToPlayer     160 123 7.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3860 ShootToPlayer     160 123 8.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3867 ShootToPlayer     160 123 8.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 


3960 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3967 ShootToPlayer     160 123 4.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3974 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3981 ShootToPlayer     160 123 5.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3988 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
3995 ShootToPlayer     160 123 6.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
4002 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
4009 ShootToPlayer     160 123 7.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
4016 ShootToPlayer     160 123 8.0 -42.0 15-35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 
4023 ShootToPlayer     160 123 8.0 -42.0 -35.0 -28.0 -21.0 -14.0 -7.0 0.0 7.0 14.0 21.0 28.0 35.0 42.0 

3974 ShootToPlayer     160 123 4.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3981 ShootToPlayer     160 123 4.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3988 ShootToPlayer     160 123 5.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
3995 ShootToPlayer     160 123 5.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
4002 ShootToPlayer     160 123 6.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
4009 ShootToPlayer     160 123 6.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
4016 ShootToPlayer     160 123 7.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
4023 ShootToPlayer     160 123 7.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
4030 ShootToPlayer     160 123 8.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
4037 ShootToPlayer     160 123 8.0 -45.0 -38.0 -31.0 -24.0 -17.0 -10.0 -3.0 4.0 11.0 18.0 25.0 32.0 39.0 
===========Cmd14==========
3610 SetVelX           3.0
3620 ShootLaser        34  125 12.0
3620 ShootLaser        85  145 12.0
3620 ShootLaser        234 145 12.0
3620 ShootLaser        285 125 12.0
3644 ShootLaser        34  125 12.0
3644 ShootLaser        85  145 12.0
3644 ShootLaser        234 145 12.0
3644 ShootLaser        285 125 12.0
3668 ShootLaser        34  125 12.0
3668 ShootLaser        85  145 12.0
3668 ShootLaser        234 145 12.0
3668 ShootLaser        285 125 12.0
3692 ShootLaser        34  125 12.0
3692 ShootLaser        85  145 12.0
3692 ShootLaser        234 145 12.0
3692 ShootLaser        285 125 12.0
3716 ShootLaser        34  125 12.0
3716 ShootLaser        85  145 12.0
3716 ShootLaser        234 145 12.0
3716 ShootLaser        285 125 12.0
3740 ShootLaser        34  125 12.0
3740 ShootLaser        85  145 12.0
3740 ShootLaser        234 145 12.0
3740 ShootLaser        285 125 12.0
3764 ShootLaser        34  125 12.0
3764 ShootLaser        85  145 12.0
3764 ShootLaser        234 145 12.0
3764 ShootLaser        285 125 12.0
3788 ShootLaser        34  125 12.0
3788 ShootLaser        85  145 12.0
3788 ShootLaser        234 145 12.0
3788 ShootLaser        285 125 12.0
3812 ShootLaser        34  125 12.0
3812 ShootLaser        85  145 12.0
3812 ShootLaser        234 145 12.0
3812 ShootLaser        285 125 12.0
3836 ShootLaser        34  125 12.0
3836 ShootLaser        85  145 12.0
3836 ShootLaser        234 145 12.0
3836 ShootLaser        285 125 12.0
3860 ShootLaser        34  125 12.0
3860 ShootLaser        85  145 12.0
3860 ShootLaser        234 145 12.0
3860 ShootLaser        285 125 12.0
3884 ShootLaser        34  125 12.0
3884 ShootLaser        85  145 12.0
3884 ShootLaser        234 145 12.0
3884 ShootLaser        285 125 12.0
3908 ShootLaser        34  125 12.0
3908 ShootLaser        85  145 12.0
3908 ShootLaser        234 145 12.0
3908 ShootLaser        285 125 12.0
3932 ShootLaser        34  125 12.0
3932 ShootLaser        85  145 12.0
3932 ShootLaser        234 145 12.0
3932 ShootLaser        285 125 12.0
3956 ShootLaser        34  125 12.0
3956 ShootLaser        85  145 12.0
3956 ShootLaser        234 145 12.0
3956 ShootLaser        285 125 12.0
3980 ShootLaser        34  125 12.0
3980 ShootLaser        85  145 12.0
3980 ShootLaser        234 145 12.0
3980 ShootLaser        285 125 12.0
4004 ShootLaser        34  125 12.0
4004 ShootLaser        85  145 12.0
4004 ShootLaser        234 145 12.0
4004 ShootLaser        285 125 12.0
4028 ShootLaser        34  125 12.0
4028 ShootLaser        85  145 12.0
4028 ShootLaser        234 145 12.0
4028 ShootLaser        285 125 12.0

3620 ShootFlame        15  75  8.0 110.0 90.0 70.0
3620 ShootFlame        304 75  8.0 110.0 90.0 70.0
3644 ShootFlame        15  75  8.0 110.0 90.0 70.0
3644 ShootFlame        304 75  8.0 110.0 90.0 70.0
3668 ShootFlame        15  75  8.0 110.0 90.0 70.0
3668 ShootFlame        304 75  8.0 110.0 90.0 70.0
3692 ShootFlame        15  75  8.0 110.0 90.0 70.0
3692 ShootFlame        304 75  8.0 110.0 90.0 70.0
3716 ShootFlame        15  75  8.0 110.0 90.0 70.0
3716 ShootFlame        304 75  8.0 110.0 90.0 70.0
3740 ShootFlame        15  75  8.0 110.0 90.0 70.0
3740 ShootFlame        304 75  8.0 110.0 90.0 70.0
3764 ShootFlame        15  75  8.0 110.0 90.0 70.0
3764 ShootFlame        304 75  8.0 110.0 90.0 70.0
3788 ShootFlame        15  75  8.0 110.0 90.0 70.0
3788 ShootFlame        304 75  8.0 110.0 90.0 70.0
3812 ShootFlame        15  75  8.0 110.0 90.0 70.0
3812 ShootFlame        304 75  8.0 110.0 90.0 70.0
3836 ShootFlame        15  75  8.0 110.0 90.0 70.0
3836 ShootFlame        304 75  8.0 110.0 90.0 70.0
3860 ShootFlame        15  75  8.0 110.0 90.0 70.0
3860 ShootFlame        304 75  8.0 110.0 90.0 70.0
3884 ShootFlame        15  75  8.0 110.0 90.0 70.0
3884 ShootFlame        304 75  8.0 110.0 90.0 70.0
3908 ShootFlame        15  75  8.0 110.0 90.0 70.0
3908 ShootFlame        304 75  8.0 110.0 90.0 70.0
3932 ShootFlame        15  75  8.0 110.0 90.0 70.0
3932 ShootFlame        304 75  8.0 110.0 90.0 70.0
3956 ShootFlame        15  75  8.0 110.0 90.0 70.0
3956 ShootFlame        304 75  8.0 110.0 90.0 70.0
3980 ShootFlame        15  75  8.0 110.0 90.0 70.0
3980 ShootFlame        304 75  8.0 110.0 90.0 70.0
4004 ShootFlame        15  75  8.0 110.0 90.0 70.0
4004 ShootFlame        304 75  8.0 110.0 90.0 70.0
4028 ShootFlame        15  75  8.0 110.0 90.0 70.0
4028 ShootFlame        304 75  8.0 110.0 90.0 70.0
===========Cmd15==========
3610 SetVelX           2.0

3620 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3620 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0 
3650 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3650 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3680 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3680 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3710 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3710 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3740 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3740 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3770 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3770 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3800 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3800 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3830 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3830 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3860 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3860 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3890 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3890 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3920 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3920 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3950 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3950 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
3980 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
3980 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
4010 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
4010 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
4040 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
4040 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0
4070 ShootToPlayer     160 123 5.0 -48.0 -40.0 -32.0 -24.0 -16.0 -8.0 0.0 8.0 16.0 24.0 32.0 40.0 48.0
4070 ShootToPlayer     160 123 6.0 -44.0 -36.0 -28.0 -20.0 -12.0 -4.0 4.0 12.0 20.0 28.0 36.0 44.0

===========Cmd16==========
3610 SetVelX           2.0

3620 ShootFlame        34  125 5.0 0.0
3620 ShootFlame        285 125 5.0 180.0
3623 ShootFlame        34  125 5.0 7.0
3623 ShootFlame        285 125 5.0 173.0
3626 ShootFlame        34  125 5.0 14.0
3626 ShootFlame        285 125 5.0 166.0
3629 ShootFlame        34  125 5.0 21.0
3629 ShootFlame        285 125 5.0 159.0
3632 ShootFlame        34  125 5.0 28.0
3632 ShootFlame        285 125 5.0 152.0
3635 ShootFlame        34  125 5.0 35.0
3635 ShootFlame        285 125 5.0 145.0
3638 ShootFlame        34  125 5.0 42.0
3638 ShootFlame        285 125 5.0 138.0
3641 ShootFlame        34  125 5.0 49.0
3641 ShootFlame        285 125 5.0 131.0
3644 ShootFlame        34  125 5.0 56.0
3644 ShootFlame        285 125 5.0 124.0
3647 ShootFlame        34  125 5.0 63.0
3647 ShootFlame        285 125 5.0 117.0
3650 ShootFlame        34  125 5.0 70.0
3650 ShootFlame        285 125 5.0 110.0
3653 ShootFlame        34  125 5.0 77.0
3653 ShootFlame        285 125 5.0 103.0
3656 ShootFlame        34  125 5.0 84.0
3656 ShootFlame        285 125 5.0 96.0
3659 ShootFlame        34  125 5.0 91.0
3659 ShootFlame        285 125 5.0 89.0
3662 ShootFlame        34  125 5.0 98.0
3662 ShootFlame        285 125 5.0 82.0
3665 ShootFlame        34  125 5.0 105.0
3665 ShootFlame        285 125 5.0 75.0
3668 ShootFlame        34  125 5.0 112.0
3668 ShootFlame        285 125 5.0 68.0
3671 ShootFlame        34  125 5.0 119.0
3671 ShootFlame        285 125 5.0 61.0
3674 ShootFlame        34  125 5.0 126.0
3674 ShootFlame        285 125 5.0 54.0
3677 ShootFlame        34  125 5.0 133.0
3677 ShootFlame        285 125 5.0 47.0
3680 ShootFlame        34  125 5.0 140.0
3680 ShootFlame        285 125 5.0 40.0
3683 ShootFlame        34  125 5.0 147.0
3683 ShootFlame        285 125 5.0 33.0
3686 ShootFlame        34  125 5.0 154.0
3686 ShootFlame        285 125 5.0 26.0
3689 ShootFlame        34  125 5.0 161.0
3689 ShootFlame        285 125 5.0 19.0
3692 ShootFlame        34  125 5.0 168.0
3692 ShootFlame        285 125 5.0 12.0
3695 ShootFlame        34  125 5.0 175.0
3695 ShootFlame        285 125 5.0 5.0
3698 ShootFlame        34  125 5.0 182.0
3698 ShootFlame        285 125 5.0 -2.0
3701 ShootFlame        34  125 5.0 189.0
3701 ShootFlame        285 125 5.0 -9.0
3704 ShootFlame        34  125 5.0 196.0
3704 ShootFlame        285 125 5.0 -16.0
3707 ShootFlame        34  125 5.0 203.0
3707 ShootFlame        285 125 5.0 -23.0
3710 ShootFlame        34  125 5.0 210.0
3710 ShootFlame        285 125 5.0 -30.0
3713 ShootFlame        34  125 5.0 217.0
3713 ShootFlame        285 125 5.0 -37.0
3716 ShootFlame        34  125 5.0 224.0
3716 ShootFlame        285 125 5.0 -44.0
3719 ShootFlame        34  125 5.0 231.0
3719 ShootFlame        285 125 5.0 -51.0
3722 ShootFlame        34  125 5.0 238.0
3722 ShootFlame        285 125 5.0 -58.0
3725 ShootFlame        34  125 5.0 245.0
3725 ShootFlame        285 125 5.0 -65.0
3728 ShootFlame        34  125 5.0 252.0
3728 ShootFlame        285 125 5.0 -72.0
3731 ShootFlame        34  125 5.0 259.0
3731 ShootFlame        285 125 5.0 -79.0
3734 ShootFlame        34  125 5.0 266.0
3734 ShootFlame        285 125 5.0 -86.0
3737 ShootFlame        34  125 5.0 273.0
3737 ShootFlame        285 125 5.0 -93.0
3740 ShootFlame        34  125 5.0 280.0
3740 ShootFlame        285 125 5.0 -100.0
3743 ShootFlame        34  125 5.0 287.0
3743 ShootFlame        285 125 5.0 -107.0
3746 ShootFlame        34  125 5.0 294.0
3746 ShootFlame        285 125 5.0 -114.0
3749 ShootFlame        34  125 5.0 301.0
3749 ShootFlame        285 125 5.0 -121.0
3752 ShootFlame        34  125 5.0 308.0
3752 ShootFlame        285 125 5.0 -128.0
3755 ShootFlame        34  125 5.0 315.0
3755 ShootFlame        285 125 5.0 -135.0
3758 ShootFlame        34  125 5.0 322.0
3758 ShootFlame        285 125 5.0 -142.0
3761 ShootFlame        34  125 5.0 329.0
3761 ShootFlame        285 125 5.0 -149.0
3764 ShootFlame        34  125 5.0 336.0
3764 ShootFlame        285 125 5.0 -156.0
3767 ShootFlame        34  125 5.0 343.0
3767 ShootFlame        285 125 5.0 -163.0
3770 ShootFlame        34  125 5.0 350.0
3770 ShootFlame        285 125 5.0 -170.0
3773 ShootFlame        34  125 5.0 357.0
3773 ShootFlame        285 125 5.0 -177.0
3776 ShootFlame        34  125 5.0 364.0
3776 ShootFlame        285 125 5.0 -184.0
3779 ShootFlame        34  125 5.0 371.0
3779 ShootFlame        285 125 5.0 -191.0
3782 ShootFlame        34  125 5.0 378.0
3782 ShootFlame        285 125 5.0 -198.0
3785 ShootFlame        34  125 5.0 385.0
3785 ShootFlame        285 125 5.0 -205.0
3788 ShootFlame        34  125 5.0 392.0
3788 ShootFlame        285 125 5.0 -212.0
3791 ShootFlame        34  125 5.0 399.0
3791 ShootFlame        285 125 5.0 -219.0
3794 ShootFlame        34  125 5.0 406.0
3794 ShootFlame        285 125 5.0 -226.0
3797 ShootFlame        34  125 5.0 413.0
3797 ShootFlame        285 125 5.0 -233.0
3800 ShootFlame        34  125 5.0 420.0
3800 ShootFlame        285 125 5.0 -240.0
3803 ShootFlame        34  125 5.0 427.0
3803 ShootFlame        285 125 5.0 -247.0
3806 ShootFlame        34  125 5.0 434.0
3806 ShootFlame        285 125 5.0 -254.0
3809 ShootFlame        34  125 5.0 441.0
3809 ShootFlame        285 125 5.0 -261.0
3812 ShootFlame        34  125 5.0 448.0
3812 ShootFlame        285 125 5.0 -268.0
3815 ShootFlame        34  125 5.0 455.0
3815 ShootFlame        285 125 5.0 -275.0
3818 ShootFlame        34  125 5.0 462.0
3818 ShootFlame        285 125 5.0 -282.0
3821 ShootFlame        34  125 5.0 469.0
3821 ShootFlame        285 125 5.0 -289.0
3824 ShootFlame        34  125 5.0 476.0
3824 ShootFlame        285 125 5.0 -296.0
3827 ShootFlame        34  125 5.0 483.0
3827 ShootFlame        285 125 5.0 -303.0
3830 ShootFlame        34  125 5.0 490.0
3830 ShootFlame        285 125 5.0 -310.0
3833 ShootFlame        34  125 5.0 497.0
3833 ShootFlame        285 125 5.0 -317.0
3836 ShootFlame        34  125 5.0 504.0
3836 ShootFlame        285 125 5.0 -324.0
3839 ShootFlame        34  125 5.0 511.0
3839 ShootFlame        285 125 5.0 -331.0
3842 ShootFlame        34  125 5.0 518.0
3842 ShootFlame        285 125 5.0 -338.0
3845 ShootFlame        34  125 5.0 525.0
3845 ShootFlame        285 125 5.0 -345.0
3848 ShootFlame        34  125 5.0 532.0
3848 ShootFlame        285 125 5.0 -352.0
3851 ShootFlame        34  125 5.0 539.0
3851 ShootFlame        285 125 5.0 -359.0
3854 ShootFlame        34  125 5.0 546.0
3854 ShootFlame        285 125 5.0 -366.0
3857 ShootFlame        34  125 5.0 553.0
3857 ShootFlame        285 125 5.0 -373.0
3860 ShootFlame        34  125 5.0 560.0
3860 ShootFlame        285 125 5.0 -380.0
3863 ShootFlame        34  125 5.0 567.0
3863 ShootFlame        285 125 5.0 -387.0
3866 ShootFlame        34  125 5.0 574.0
3866 ShootFlame        285 125 5.0 -394.0
3869 ShootFlame        34  125 5.0 581.0
3869 ShootFlame        285 125 5.0 -401.0
3872 ShootFlame        34  125 5.0 588.0
3872 ShootFlame        285 125 5.0 -408.0
3875 ShootFlame        34  125 5.0 595.0
3875 ShootFlame        285 125 5.0 -415.0
3878 ShootFlame        34  125 5.0 602.0
3878 ShootFlame        285 125 5.0 -422.0
3881 ShootFlame        34  125 5.0 609.0
3881 ShootFlame        285 125 5.0 -429.0
3884 ShootFlame        34  125 5.0 616.0
3884 ShootFlame        285 125 5.0 -436.0
3887 ShootFlame        34  125 5.0 623.0
3887 ShootFlame        285 125 5.0 -443.0
3890 ShootFlame        34  125 5.0 630.0
3890 ShootFlame        285 125 5.0 -450.0
3893 ShootFlame        34  125 5.0 637.0
3893 ShootFlame        285 125 5.0 -457.0
3896 ShootFlame        34  125 5.0 644.0
3896 ShootFlame        285 125 5.0 -464.0
3899 ShootFlame        34  125 5.0 651.0
3899 ShootFlame        285 125 5.0 -471.0
3902 ShootFlame        34  125 5.0 658.0
3902 ShootFlame        285 125 5.0 -478.0
3905 ShootFlame        34  125 5.0 665.0
3905 ShootFlame        285 125 5.0 -485.0
3908 ShootFlame        34  125 5.0 672.0
3908 ShootFlame        285 125 5.0 -492.0
3911 ShootFlame        34  125 5.0 679.0
3911 ShootFlame        285 125 5.0 -499.0
3914 ShootFlame        34  125 5.0 686.0
3914 ShootFlame        285 125 5.0 -506.0
3917 ShootFlame        34  125 5.0 693.0
3917 ShootFlame        285 125 5.0 -513.0
3920 ShootFlame        34  125 5.0 700.0
3920 ShootFlame        285 125 5.0 -520.0
3923 ShootFlame        34  125 5.0 707.0
3923 ShootFlame        285 125 5.0 -527.0
3926 ShootFlame        34  125 5.0 714.0
3926 ShootFlame        285 125 5.0 -534.0
3929 ShootFlame        34  125 5.0 721.0
3929 ShootFlame        285 125 5.0 -541.0
3932 ShootFlame        34  125 5.0 728.0
3932 ShootFlame        285 125 5.0 -548.0
3935 ShootFlame        34  125 5.0 735.0
3935 ShootFlame        285 125 5.0 -555.0
3938 ShootFlame        34  125 5.0 742.0
3938 ShootFlame        285 125 5.0 -562.0
3941 ShootFlame        34  125 5.0 749.0
3941 ShootFlame        285 125 5.0 -569.0
3944 ShootFlame        34  125 5.0 756.0
3944 ShootFlame        285 125 5.0 -576.0
3947 ShootFlame        34  125 5.0 763.0
3947 ShootFlame        285 125 5.0 -583.0
3950 ShootFlame        34  125 5.0 770.0
3950 ShootFlame        285 125 5.0 -590.0
3953 ShootFlame        34  125 5.0 777.0
3953 ShootFlame        285 125 5.0 -597.0
3956 ShootFlame        34  125 5.0 784.0
3956 ShootFlame        285 125 5.0 -604.0
3959 ShootFlame        34  125 5.0 791.0
3959 ShootFlame        285 125 5.0 -611.0
3962 ShootFlame        34  125 5.0 798.0
3962 ShootFlame        285 125 5.0 -618.0
3965 ShootFlame        34  125 5.0 805.0
3965 ShootFlame        285 125 5.0 -625.0
3968 ShootFlame        34  125 5.0 812.0
3968 ShootFlame        285 125 5.0 -632.0
3971 ShootFlame        34  125 5.0 819.0
3971 ShootFlame        285 125 5.0 -639.0
3974 ShootFlame        34  125 5.0 826.0
3974 ShootFlame        285 125 5.0 -646.0
3977 ShootFlame        34  125 5.0 833.0
3977 ShootFlame        285 125 5.0 -653.0
3980 ShootFlame        34  125 5.0 840.0
3980 ShootFlame        285 125 5.0 -660.0
3983 ShootFlame        34  125 5.0 847.0
3983 ShootFlame        285 125 5.0 -667.0
3986 ShootFlame        34  125 5.0 854.0
3986 ShootFlame        285 125 5.0 -674.0
3989 ShootFlame        34  125 5.0 861.0
3989 ShootFlame        285 125 5.0 -681.0
3992 ShootFlame        34  125 5.0 868.0
3992 ShootFlame        285 125 5.0 -688.0
3995 ShootFlame        34  125 5.0 875.0
3995 ShootFlame        285 125 5.0 -695.0
3998 ShootFlame        34  125 5.0 882.0
3998 ShootFlame        285 125 5.0 -702.0
4001 ShootFlame        34  125 5.0 889.0
4001 ShootFlame        285 125 5.0 -709.0
4004 ShootFlame        34  125 5.0 896.0
4004 ShootFlame        285 125 5.0 -716.0
4007 ShootFlame        34  125 5.0 903.0
4007 ShootFlame        285 125 5.0 -723.0
4010 ShootFlame        34  125 5.0 910.0
4010 ShootFlame        285 125 5.0 -730.0
4013 ShootFlame        34  125 5.0 917.0
4013 ShootFlame        285 125 5.0 -737.0
4016 ShootFlame        34  125 5.0 924.0
4016 ShootFlame        285 125 5.0 -744.0
4019 ShootFlame        34  125 5.0 931.0
4019 ShootFlame        285 125 5.0 -751.0
4022 ShootFlame        34  125 5.0 938.0
4022 ShootFlame        285 125 5.0 -758.0
4025 ShootFlame        34  125 5.0 945.0
4025 ShootFlame        285 125 5.0 -765.0
4028 ShootFlame        34  125 5.0 952.0
4028 ShootFlame        285 125 5.0 -772.0
4031 ShootFlame        34  125 5.0 959.0
4031 ShootFlame        285 125 5.0 -779.0
4034 ShootFlame        34  125 5.0 966.0
4034 ShootFlame        285 125 5.0 -786.0
4037 ShootFlame        34  125 5.0 973.0
4037 ShootFlame        285 125 5.0 -793.0

3620 ShootToPlayer     150 123 8.0 0.0
3620 ShootToPlayer     170 123 8.0 0.0
3620 ShootToPlayer     150 123 8.5 0.0
3620 ShootToPlayer     170 123 8.5 0.0
3620 ShootToPlayer     150 123 9.0 0.0
3620 ShootToPlayer     170 123 9.0 0.0

3655 ShootToPlayer     150 123 8.0 0.0
3655 ShootToPlayer     170 123 8.0 0.0
3655 ShootToPlayer     150 123 8.5 0.0
3655 ShootToPlayer     170 123 8.5 0.0
3655 ShootToPlayer     150 123 9.0 0.0
3655 ShootToPlayer     170 123 9.0 0.0

3670 ShootToPlayer     150 123 8.0 0.0
3670 ShootToPlayer     170 123 8.0 0.0
3670 ShootToPlayer     150 123 8.5 0.0
3670 ShootToPlayer     170 123 8.5 0.0
3670 ShootToPlayer     150 123 9.0 0.0
3670 ShootToPlayer     170 123 9.0 0.0

3695 ShootToPlayer     150 123 8.0 0.0
3695 ShootToPlayer     170 123 8.0 0.0
3695 ShootToPlayer     150 123 8.5 0.0
3695 ShootToPlayer     170 123 8.5 0.0
3695 ShootToPlayer     150 123 9.0 0.0
3695 ShootToPlayer     170 123 9.0 0.0

3720 ShootToPlayer     150 123 8.0 0.0
3720 ShootToPlayer     170 123 8.0 0.0
3720 ShootToPlayer     150 123 8.5 0.0
3720 ShootToPlayer     170 123 8.5 0.0
3720 ShootToPlayer     150 123 9.0 0.0
3720 ShootToPlayer     170 123 9.0 0.0

3745 ShootToPlayer     150 123 8.0 0.0
3745 ShootToPlayer     170 123 8.0 0.0
3745 ShootToPlayer     150 123 8.5 0.0
3745 ShootToPlayer     170 123 8.5 0.0
3745 ShootToPlayer     150 123 9.0 0.0
3745 ShootToPlayer     170 123 9.0 0.0

3770 ShootToPlayer     150 123 8.0 0.0
3770 ShootToPlayer     170 123 8.0 0.0
3770 ShootToPlayer     150 123 8.5 0.0
3770 ShootToPlayer     170 123 8.5 0.0
3770 ShootToPlayer     150 123 9.0 0.0
3770 ShootToPlayer     170 123 9.0 0.0

3795 ShootToPlayer     150 123 8.0 0.0
3795 ShootToPlayer     170 123 8.0 0.0
3795 ShootToPlayer     150 123 8.5 0.0
3795 ShootToPlayer     170 123 8.5 0.0
3795 ShootToPlayer     150 123 9.0 0.0
3795 ShootToPlayer     170 123 9.0 0.0

3820 ShootToPlayer     150 123 8.0 0.0
3820 ShootToPlayer     170 123 8.0 0.0
3820 ShootToPlayer     150 123 8.5 0.0
3820 ShootToPlayer     170 123 8.5 0.0
3820 ShootToPlayer     150 123 9.0 0.0
3820 ShootToPlayer     170 123 9.0 0.0

3845 ShootToPlayer     150 123 8.0 0.0
3845 ShootToPlayer     170 123 8.0 0.0
3845 ShootToPlayer     150 123 8.5 0.0
3845 ShootToPlayer     170 123 8.5 0.0
3845 ShootToPlayer     150 123 9.0 0.0
3845 ShootToPlayer     170 123 9.0 0.0

3870 ShootToPlayer     150 123 8.0 0.0
3870 ShootToPlayer     170 123 8.0 0.0
3870 ShootToPlayer     150 123 8.5 0.0
3870 ShootToPlayer     170 123 8.5 0.0
3870 ShootToPlayer     150 123 9.0 0.0
3870 ShootToPlayer     170 123 9.0 0.0

3895 ShootToPlayer     150 123 8.0 0.0
3895 ShootToPlayer     170 123 8.0 0.0
3895 ShootToPlayer     150 123 8.5 0.0
3895 ShootToPlayer     170 123 8.5 0.0
3895 ShootToPlayer     150 123 9.0 0.0
3895 ShootToPlayer     170 123 9.0 0.0

3920 ShootToPlayer     150 123 8.0 0.0
3920 ShootToPlayer     170 123 8.0 0.0
3920 ShootToPlayer     150 123 8.5 0.0
3920 ShootToPlayer     170 123 8.5 0.0
3920 ShootToPlayer     150 123 9.0 0.0
3920 ShootToPlayer     170 123 9.0 0.0

3945 ShootToPlayer     150 123 8.0 0.0
3945 ShootToPlayer     170 123 8.0 0.0
3945 ShootToPlayer     150 123 8.5 0.0
3945 ShootToPlayer     170 123 8.5 0.0
3945 ShootToPlayer     150 123 9.0 0.0
3945 ShootToPlayer     170 123 9.0 0.0

3970 ShootToPlayer     150 123 8.0 0.0
3970 ShootToPlayer     170 123 8.0 0.0
3970 ShootToPlayer     150 123 8.5 0.0
3970 ShootToPlayer     170 123 8.5 0.0
3970 ShootToPlayer     150 123 9.0 0.0
3970 ShootToPlayer     170 123 9.0 0.0

3970 ShootToPlayer     150 123 8.0 0.0
3970 ShootToPlayer     170 123 8.0 0.0
3970 ShootToPlayer     150 123 8.5 0.0
3970 ShootToPlayer     170 123 8.5 0.0
3970 ShootToPlayer     150 123 9.0 0.0
3970 ShootToPlayer     170 123 9.0 0.0
===========Cmd17==========
4160 SetVelX           0.0
4160 SetVelY           0.0
4160 Charge            0

4200 ShootToPlayer     15  75  16.0 68.0
4200 ShootToPlayer     34  125 16.0 -68.0
4200 ShootToPlayer     285 125 16.0 68.0
4200 ShootToPlayer     304 75  16.0 -68.0
4204 ShootToPlayer     15  75  16.0 66.0
4204 ShootToPlayer     34  125 16.0 -66.0
4204 ShootToPlayer     285 125 16.0 66.0
4204 ShootToPlayer     304 75  16.0 -66.0
4208 ShootToPlayer     15  75  16.0 64.0
4208 ShootToPlayer     34  125 16.0 -64.0
4208 ShootToPlayer     285 125 16.0 64.0
4208 ShootToPlayer     304 75  16.0 -64.0
4212 ShootToPlayer     15  75  16.0 62.0
4212 ShootToPlayer     34  125 16.0 -62.0
4212 ShootToPlayer     285 125 16.0 62.0
4212 ShootToPlayer     304 75  16.0 -62.0
4216 ShootToPlayer     15  75  16.0 60.0
4216 ShootToPlayer     34  125 16.0 -60.0
4216 ShootToPlayer     285 125 16.0 60.0
4216 ShootToPlayer     304 75  16.0 -60.0
4220 ShootToPlayer     15  75  16.0 58.0
4220 ShootToPlayer     34  125 16.0 -58.0
4220 ShootToPlayer     285 125 16.0 58.0
4220 ShootToPlayer     304 75  16.0 -58.0
4224 ShootToPlayer     15  75  16.0 56.0
4224 ShootToPlayer     34  125 16.0 -56.0
4224 ShootToPlayer     285 125 16.0 56.0
4224 ShootToPlayer     304 75  16.0 -56.0
4228 ShootToPlayer     15  75  16.0 54.0
4228 ShootToPlayer     34  125 16.0 -54.0
4228 ShootToPlayer     285 125 16.0 54.0
4228 ShootToPlayer     304 75  16.0 -54.0
4232 ShootToPlayer     15  75  16.0 52.0
4232 ShootToPlayer     34  125 16.0 -52.0
4232 ShootToPlayer     285 125 16.0 52.0
4232 ShootToPlayer     304 75  16.0 -52.0
4236 ShootToPlayer     15  75  16.0 50.0
4236 ShootToPlayer     34  125 16.0 -50.0
4236 ShootToPlayer     285 125 16.0 50.0
4236 ShootToPlayer     304 75  16.0 -50.0
4240 ShootToPlayer     15  75  16.0 48.0
4240 ShootToPlayer     34  125 16.0 -48.0
4240 ShootToPlayer     285 125 16.0 48.0
4240 ShootToPlayer     304 75  16.0 -48.0
4244 ShootToPlayer     15  75  16.0 46.0
4244 ShootToPlayer     34  125 16.0 -46.0
4244 ShootToPlayer     285 125 16.0 46.0
4244 ShootToPlayer     304 75  16.0 -46.0
4248 ShootToPlayer     15  75  16.0 44.0
4248 ShootToPlayer     34  125 16.0 -44.0
4248 ShootToPlayer     285 125 16.0 44.0
4248 ShootToPlayer     304 75  16.0 -44.0
4252 ShootToPlayer     15  75  16.0 42.0
4252 ShootToPlayer     34  125 16.0 -42.0
4252 ShootToPlayer     285 125 16.0 42.0
4252 ShootToPlayer     304 75  16.0 -42.0
4256 ShootToPlayer     15  75  16.0 40.0
4256 ShootToPlayer     34  125 16.0 -40.0
4256 ShootToPlayer     285 125 16.0 40.0
4256 ShootToPlayer     304 75  16.0 -40.0
4260 ShootToPlayer     15  75  16.0 38.0
4260 ShootToPlayer     34  125 16.0 -38.0
4260 ShootToPlayer     285 125 16.0 38.0
4260 ShootToPlayer     304 75  16.0 -38.0
4264 ShootToPlayer     15  75  16.0 36.0
4264 ShootToPlayer     34  125 16.0 -36.0
4264 ShootToPlayer     285 125 16.0 36.0
4264 ShootToPlayer     304 75  16.0 -36.0
4268 ShootToPlayer     15  75  16.0 34.0
4268 ShootToPlayer     34  125 16.0 -34.0
4268 ShootToPlayer     285 125 16.0 34.0
4268 ShootToPlayer     304 75  16.0 -34.0
4272 ShootToPlayer     15  75  16.0 32.0
4272 ShootToPlayer     34  125 16.0 -32.0
4272 ShootToPlayer     285 125 16.0 32.0
4272 ShootToPlayer     304 75  16.0 -32.0
4276 ShootToPlayer     15  75  16.0 30.0
4276 ShootToPlayer     34  125 16.0 -30.0
4276 ShootToPlayer     285 125 16.0 30.0
4276 ShootToPlayer     304 75  16.0 -30.0
4280 ShootToPlayer     15  75  16.0 28.0
4280 ShootToPlayer     34  125 16.0 -28.0
4280 ShootToPlayer     285 125 16.0 28.0
4280 ShootToPlayer     304 75  16.0 -28.0
4284 ShootToPlayer     15  75  16.0 26.0
4284 ShootToPlayer     34  125 16.0 -26.0
4284 ShootToPlayer     285 125 16.0 26.0
4284 ShootToPlayer     304 75  16.0 -26.0
4288 ShootToPlayer     15  75  16.0 24.0
4288 ShootToPlayer     34  125 16.0 -24.0
4288 ShootToPlayer     285 125 16.0 24.0
4288 ShootToPlayer     304 75  16.0 -24.0
4292 ShootToPlayer     15  75  16.0 22.0
4292 ShootToPlayer     34  125 16.0 -22.0
4292 ShootToPlayer     285 125 16.0 22.0
4292 ShootToPlayer     304 75  16.0 -22.0
4296 ShootToPlayer     15  75  16.0 20.0
4296 ShootToPlayer     34  125 16.0 -20.0
4296 ShootToPlayer     285 125 16.0 20.0
4296 ShootToPlayer     304 75  16.0 -20.0
4300 ShootToPlayer     15  75  16.0 18.0
4300 ShootToPlayer     34  125 16.0 -18.0
4300 ShootToPlayer     285 125 16.0 18.0
4300 ShootToPlayer     304 75  16.0 -18.0
4304 ShootToPlayer     15  75  16.0 16.0
4304 ShootToPlayer     34  125 16.0 -16.0
4304 ShootToPlayer     285 125 16.0 16.0
4304 ShootToPlayer     304 75  16.0 -16.0
4308 ShootToPlayer     15  75  16.0 14.0
4308 ShootToPlayer     34  125 16.0 -14.0
4308 ShootToPlayer     285 125 16.0 14.0
4308 ShootToPlayer     304 75  16.0 -14.0
4312 ShootToPlayer     15  75  16.0 12.0
4312 ShootToPlayer     34  125 16.0 -12.0
4312 ShootToPlayer     285 125 16.0 12.0
4312 ShootToPlayer     304 75  16.0 -12.0
4316 ShootToPlayer     15  75  16.0 10.0
4316 ShootToPlayer     34  125 16.0 -10.0
4316 ShootToPlayer     285 125 16.0 10.0
4316 ShootToPlayer     304 75  16.0 -10.0

4320 ShootToPlayer     15  75  16.0 8.0
4320 ShootToPlayer     34  125 16.0 -8.0
4320 ShootToPlayer     285 125 16.0 8.0
4320 ShootToPlayer     304 75  16.0 -8.0
4324 ShootToPlayer     15  75  16.0 8.0
4324 ShootToPlayer     34  125 16.0 -8.0
4324 ShootToPlayer     285 125 16.0 8.0
4324 ShootToPlayer     304 75  16.0 -8.0
4328 ShootToPlayer     15  75  16.0 8.0
4328 ShootToPlayer     34  125 16.0 -8.0
4328 ShootToPlayer     285 125 16.0 8.0
4328 ShootToPlayer     304 75  16.0 -8.0
4332 ShootToPlayer     15  75  16.0 8.0
4332 ShootToPlayer     34  125 16.0 -8.0
4332 ShootToPlayer     285 125 16.0 8.0
4332 ShootToPlayer     304 75  16.0 -8.0
4336 ShootToPlayer     15  75  16.0 8.0
4336 ShootToPlayer     34  125 16.0 -8.0
4336 ShootToPlayer     285 125 16.0 8.0
4336 ShootToPlayer     304 75  16.0 -8.0
4340 ShootToPlayer     15  75  16.0 8.0
4340 ShootToPlayer     34  125 16.0 -8.0
4340 ShootToPlayer     285 125 16.0 8.0
4340 ShootToPlayer     304 75  16.0 -8.0
4344 ShootToPlayer     15  75  16.0 8.0
4344 ShootToPlayer     34  125 16.0 -8.0
4344 ShootToPlayer     285 125 16.0 8.0
4344 ShootToPlayer     304 75  16.0 -8.0
4348 ShootToPlayer     15  75  16.0 8.0
4348 ShootToPlayer     34  125 16.0 -8.0
4348 ShootToPlayer     285 125 16.0 8.0
4348 ShootToPlayer     304 75  16.0 -8.0
4352 ShootToPlayer     15  75  16.0 8.0
4352 ShootToPlayer     34  125 16.0 -8.0
4352 ShootToPlayer     285 125 16.0 8.0
4352 ShootToPlayer     304 75  16.0 -8.0
4356 ShootToPlayer     15  75  16.0 8.0
4356 ShootToPlayer     34  125 16.0 -8.0
4356 ShootToPlayer     285 125 16.0 8.0
4356 ShootToPlayer     304 75  16.0 -8.0
4360 ShootToPlayer     15  75  16.0 8.0
4360 ShootToPlayer     34  125 16.0 -8.0
4360 ShootToPlayer     285 125 16.0 8.0
4360 ShootToPlayer     304 75  16.0 -8.0
4364 ShootToPlayer     15  75  16.0 8.0
4364 ShootToPlayer     34  125 16.0 -8.0
4364 ShootToPlayer     285 125 16.0 8.0
4364 ShootToPlayer     304 75  16.0 -8.0
4368 ShootToPlayer     15  75  16.0 8.0
4368 ShootToPlayer     34  125 16.0 -8.0
4368 ShootToPlayer     285 125 16.0 8.0
4368 ShootToPlayer     304 75  16.0 -8.0
4372 ShootToPlayer     15  75  16.0 8.0
4372 ShootToPlayer     34  125 16.0 -8.0
4372 ShootToPlayer     285 125 16.0 8.0
4372 ShootToPlayer     304 75  16.0 -8.0
4376 ShootToPlayer     15  75  16.0 8.0
4376 ShootToPlayer     34  125 16.0 -8.0
4376 ShootToPlayer     285 125 16.0 8.0
4376 ShootToPlayer     304 75  16.0 -8.0
4380 ShootToPlayer     15  75  16.0 8.0
4380 ShootToPlayer     34  125 16.0 -8.0
4380 ShootToPlayer     285 125 16.0 8.0
4380 ShootToPlayer     304 75  16.0 -8.0
4384 ShootToPlayer     15  75  16.0 8.0
4384 ShootToPlayer     34  125 16.0 -8.0
4384 ShootToPlayer     285 125 16.0 8.0
4384 ShootToPlayer     304 75  16.0 -8.0
4388 ShootToPlayer     15  75  16.0 8.0
4388 ShootToPlayer     34  125 16.0 -8.0
4388 ShootToPlayer     285 125 16.0 8.0
4388 ShootToPlayer     304 75  16.0 -8.0
4392 ShootToPlayer     15  75  16.0 8.0
4392 ShootToPlayer     34  125 16.0 -8.0
4392 ShootToPlayer     285 125 16.0 8.0
4392 ShootToPlayer     304 75  16.0 -8.0
4396 ShootToPlayer     15  75  16.0 8.0
4396 ShootToPlayer     34  125 16.0 -8.0
4396 ShootToPlayer     285 125 16.0 8.0
4396 ShootToPlayer     304 75  16.0 -8.0
4400 ShootToPlayer     15  75  16.0 8.0
4400 ShootToPlayer     34  125 16.0 -8.0
4400 ShootToPlayer     285 125 16.0 8.0
4400 ShootToPlayer     304 75  16.0 -8.0
4404 ShootToPlayer     15  75  16.0 8.0
4404 ShootToPlayer     34  125 16.0 -8.0
4404 ShootToPlayer     285 125 16.0 8.0
4404 ShootToPlayer     304 75  16.0 -8.0
4408 ShootToPlayer     15  75  16.0 8.0
4408 ShootToPlayer     34  125 16.0 -8.0
4408 ShootToPlayer     285 125 16.0 8.0
4408 ShootToPlayer     304 75  16.0 -8.0
4412 ShootToPlayer     15  75  16.0 8.0
4412 ShootToPlayer     34  125 16.0 -8.0
4412 ShootToPlayer     285 125 16.0 8.0
4412 ShootToPlayer     304 75  16.0 -8.0
4416 ShootToPlayer     15  75  16.0 8.0
4416 ShootToPlayer     34  125 16.0 -8.0
4416 ShootToPlayer     285 125 16.0 8.0
4416 ShootToPlayer     304 75  16.0 -8.0
4420 ShootToPlayer     15  75  16.0 8.0
4420 ShootToPlayer     34  125 16.0 -8.0
4420 ShootToPlayer     285 125 16.0 8.0
4420 ShootToPlayer     304 75  16.0 -8.0
4424 ShootToPlayer     15  75  16.0 8.0
4424 ShootToPlayer     34  125 16.0 -8.0
4424 ShootToPlayer     285 125 16.0 8.0
4424 ShootToPlayer     304 75  16.0 -8.0
4428 ShootToPlayer     15  75  16.0 8.0
4428 ShootToPlayer     34  125 16.0 -8.0
4428 ShootToPlayer     285 125 16.0 8.0
4428 ShootToPlayer     304 75  16.0 -8.0
4432 ShootToPlayer     15  75  16.0 8.0
4432 ShootToPlayer     34  125 16.0 -8.0
4432 ShootToPlayer     285 125 16.0 8.0
4432 ShootToPlayer     304 75  16.0 -8.0
4436 ShootToPlayer     15  75  16.0 8.0
4436 ShootToPlayer     34  125 16.0 -8.0
4436 ShootToPlayer     285 125 16.0 8.0
4436 ShootToPlayer     304 75  16.0 -8.0
4440 ShootToPlayer     15  75  16.0 8.0
4440 ShootToPlayer     34  125 16.0 -8.0
4440 ShootToPlayer     285 125 16.0 8.0
4440 ShootToPlayer     304 75  16.0 -8.0
4444 ShootToPlayer     15  75  16.0 8.0
4444 ShootToPlayer     34  125 16.0 -8.0
4444 ShootToPlayer     285 125 16.0 8.0
4444 ShootToPlayer     304 75  16.0 -8.0
4448 ShootToPlayer     15  75  16.0 8.0
4448 ShootToPlayer     34  125 16.0 -8.0
4448 ShootToPlayer     285 125 16.0 8.0
4448 ShootToPlayer     304 75  16.0 -8.0
4452 ShootToPlayer     15  75  16.0 8.0
4452 ShootToPlayer     34  125 16.0 -8.0
4452 ShootToPlayer     285 125 16.0 8.0
4452 ShootToPlayer     304 75  16.0 -8.0
4456 ShootToPlayer     15  75  16.0 8.0
4456 ShootToPlayer     34  125 16.0 -8.0
4456 ShootToPlayer     285 125 16.0 8.0
4456 ShootToPlayer     304 75  16.0 -8.0
4460 ShootToPlayer     15  75  16.0 8.0
4460 ShootToPlayer     34  125 16.0 -8.0
4460 ShootToPlayer     285 125 16.0 8.0
4460 ShootToPlayer     304 75  16.0 -8.0
4464 ShootToPlayer     15  75  16.0 8.0
4464 ShootToPlayer     34  125 16.0 -8.0
4464 ShootToPlayer     285 125 16.0 8.0
4464 ShootToPlayer     304 75  16.0 -8.0
4468 ShootToPlayer     15  75  16.0 8.0
4468 ShootToPlayer     34  125 16.0 -8.0
4468 ShootToPlayer     285 125 16.0 8.0
4468 ShootToPlayer     304 75  16.0 -8.0
4472 ShootToPlayer     15  75  16.0 8.0
4472 ShootToPlayer     34  125 16.0 -8.0
4472 ShootToPlayer     285 125 16.0 8.0
4472 ShootToPlayer     304 75  16.0 -8.0
4476 ShootToPlayer     15  75  16.0 8.0
4476 ShootToPlayer     34  125 16.0 -8.0
4476 ShootToPlayer     285 125 16.0 8.0
4476 ShootToPlayer     304 75  16.0 -8.0
4480 ShootToPlayer     15  75  16.0 8.0
4480 ShootToPlayer     34  125 16.0 -8.0
4480 ShootToPlayer     285 125 16.0 8.0
4480 ShootToPlayer     304 75  16.0 -8.0
4484 ShootToPlayer     15  75  16.0 8.0
4484 ShootToPlayer     34  125 16.0 -8.0
4484 ShootToPlayer     285 125 16.0 8.0
4484 ShootToPlayer     304 75  16.0 -8.0
4488 ShootToPlayer     15  75  16.0 8.0
4488 ShootToPlayer     34  125 16.0 -8.0
4488 ShootToPlayer     285 125 16.0 8.0
4488 ShootToPlayer     304 75  16.0 -8.0
4492 ShootToPlayer     15  75  16.0 8.0
4492 ShootToPlayer     34  125 16.0 -8.0
4492 ShootToPlayer     285 125 16.0 8.0
4492 ShootToPlayer     304 75  16.0 -8.0
4496 ShootToPlayer     15  75  16.0 8.0
4496 ShootToPlayer     34  125 16.0 -8.0
4496 ShootToPlayer     285 125 16.0 8.0
4496 ShootToPlayer     304 75  16.0 -8.0
4500 ShootToPlayer     15  75  16.0 8.0
4500 ShootToPlayer     34  125 16.0 -8.0
4500 ShootToPlayer     285 125 16.0 8.0
4500 ShootToPlayer     304 75  16.0 -8.0
4504 ShootToPlayer     15  75  16.0 8.0
4504 ShootToPlayer     34  125 16.0 -8.0
4504 ShootToPlayer     285 125 16.0 8.0
4504 ShootToPlayer     304 75  16.0 -8.0
4508 ShootToPlayer     15  75  16.0 8.0
4508 ShootToPlayer     34  125 16.0 -8.0
4508 ShootToPlayer     285 125 16.0 8.0
4508 ShootToPlayer     304 75  16.0 -8.0
4512 ShootToPlayer     15  75  16.0 8.0
4512 ShootToPlayer     34  125 16.0 -8.0
4512 ShootToPlayer     285 125 16.0 8.0
4512 ShootToPlayer     304 75  16.0 -8.0
4516 ShootToPlayer     15  75  16.0 8.0
4516 ShootToPlayer     34  125 16.0 -8.0
4516 ShootToPlayer     285 125 16.0 8.0
4516 ShootToPlayer     304 75  16.0 -8.0
4520 ShootToPlayer     15  75  16.0 8.0
4520 ShootToPlayer     34  125 16.0 -8.0
4520 ShootToPlayer     285 125 16.0 8.0
4520 ShootToPlayer     304 75  16.0 -8.0
4524 ShootToPlayer     15  75  16.0 8.0
4524 ShootToPlayer     34  125 16.0 -8.0
4524 ShootToPlayer     285 125 16.0 8.0
4524 ShootToPlayer     304 75  16.0 -8.0
4528 ShootToPlayer     15  75  16.0 8.0
4528 ShootToPlayer     34  125 16.0 -8.0
4528 ShootToPlayer     285 125 16.0 8.0
4528 ShootToPlayer     304 75  16.0 -8.0
4532 ShootToPlayer     15  75  16.0 8.0
4532 ShootToPlayer     34  125 16.0 -8.0
4532 ShootToPlayer     285 125 16.0 8.0
4532 ShootToPlayer     304 75  16.0 -8.0
4536 ShootToPlayer     15  75  16.0 8.0
4536 ShootToPlayer     34  125 16.0 -8.0
4536 ShootToPlayer     285 125 16.0 8.0
4536 ShootToPlayer     304 75  16.0 -8.0
4540 ShootToPlayer     15  75  16.0 8.0
4540 ShootToPlayer     34  125 16.0 -8.0
4540 ShootToPlayer     285 125 16.0 8.0
4540 ShootToPlayer     304 75  16.0 -8.0
4544 ShootToPlayer     15  75  16.0 8.0
4544 ShootToPlayer     34  125 16.0 -8.0
4544 ShootToPlayer     285 125 16.0 8.0
4544 ShootToPlayer     304 75  16.0 -8.0
4548 ShootToPlayer     15  75  16.0 8.0
4548 ShootToPlayer     34  125 16.0 -8.0
4548 ShootToPlayer     285 125 16.0 8.0
4548 ShootToPlayer     304 75  16.0 -8.0
4552 ShootToPlayer     15  75  16.0 8.0
4552 ShootToPlayer     34  125 16.0 -8.0
4552 ShootToPlayer     285 125 16.0 8.0
4552 ShootToPlayer     304 75  16.0 -8.0
4556 ShootToPlayer     15  75  16.0 8.0
4556 ShootToPlayer     34  125 16.0 -8.0
4556 ShootToPlayer     285 125 16.0 8.0
4556 ShootToPlayer     304 75  16.0 -8.0
4560 ShootToPlayer     15  75  16.0 8.0
4560 ShootToPlayer     34  125 16.0 -8.0
4560 ShootToPlayer     285 125 16.0 8.0
4560 ShootToPlayer     304 75  16.0 -8.0
4564 ShootToPlayer     15  75  16.0 8.0
4564 ShootToPlayer     34  125 16.0 -8.0
4564 ShootToPlayer     285 125 16.0 8.0
4564 ShootToPlayer     304 75  16.0 -8.0
4568 ShootToPlayer     15  75  16.0 8.0
4568 ShootToPlayer     34  125 16.0 -8.0
4568 ShootToPlayer     285 125 16.0 8.0
4568 ShootToPlayer     304 75  16.0 -8.0
4572 ShootToPlayer     15  75  16.0 8.0
4572 ShootToPlayer     34  125 16.0 -8.0
4572 ShootToPlayer     285 125 16.0 8.0
4572 ShootToPlayer     304 75  16.0 -8.0
4576 ShootToPlayer     15  75  16.0 8.0
4576 ShootToPlayer     34  125 16.0 -8.0
4576 ShootToPlayer     285 125 16.0 8.0
4576 ShootToPlayer     304 75  16.0 -8.0
4580 ShootToPlayer     15  75  16.0 8.0
4580 ShootToPlayer     34  125 16.0 -8.0
4580 ShootToPlayer     285 125 16.0 8.0
4580 ShootToPlayer     304 75  16.0 -8.0
4584 ShootToPlayer     15  75  16.0 8.0
4584 ShootToPlayer     34  125 16.0 -8.0
4584 ShootToPlayer     285 125 16.0 8.0
4584 ShootToPlayer     304 75  16.0 -8.0
4588 ShootToPlayer     15  75  16.0 8.0
4588 ShootToPlayer     34  125 16.0 -8.0
4588 ShootToPlayer     285 125 16.0 8.0
4588 ShootToPlayer     304 75  16.0 -8.0
4592 ShootToPlayer     15  75  16.0 8.0
4592 ShootToPlayer     34  125 16.0 -8.0
4592 ShootToPlayer     285 125 16.0 8.0
4592 ShootToPlayer     304 75  16.0 -8.0
4596 ShootToPlayer     15  75  16.0 8.0
4596 ShootToPlayer     34  125 16.0 -8.0
4596 ShootToPlayer     285 125 16.0 8.0
4596 ShootToPlayer     304 75  16.0 -8.0
4600 ShootToPlayer     15  75  16.0 8.0
4600 ShootToPlayer     34  125 16.0 -8.0
4600 ShootToPlayer     285 125 16.0 8.0
4600 ShootToPlayer     304 75  16.0 -8.0
4604 ShootToPlayer     15  75  16.0 8.0
4604 ShootToPlayer     34  125 16.0 -8.0
4604 ShootToPlayer     285 125 16.0 8.0
4604 ShootToPlayer     304 75  16.0 -8.0
4608 ShootToPlayer     15  75  16.0 8.0
4608 ShootToPlayer     34  125 16.0 -8.0
4608 ShootToPlayer     285 125 16.0 8.0
4608 ShootToPlayer     304 75  16.0 -8.0
4612 ShootToPlayer     15  75  16.0 8.0
4612 ShootToPlayer     34  125 16.0 -8.0
4612 ShootToPlayer     285 125 16.0 8.0
4612 ShootToPlayer     304 75  16.0 -8.0
4616 ShootToPlayer     15  75  16.0 8.0
4616 ShootToPlayer     34  125 16.0 -8.0
4616 ShootToPlayer     285 125 16.0 8.0
4616 ShootToPlayer     304 75  16.0 -8.0
4620 ShootToPlayer     15  75  16.0 8.0
4620 ShootToPlayer     34  125 16.0 -8.0
4620 ShootToPlayer     285 125 16.0 8.0
4620 ShootToPlayer     304 75  16.0 -8.0
4624 ShootToPlayer     15  75  16.0 8.0
4624 ShootToPlayer     34  125 16.0 -8.0
4624 ShootToPlayer     285 125 16.0 8.0
4624 ShootToPlayer     304 75  16.0 -8.0
4628 ShootToPlayer     15  75  16.0 8.0
4628 ShootToPlayer     34  125 16.0 -8.0
4628 ShootToPlayer     285 125 16.0 8.0
4628 ShootToPlayer     304 75  16.0 -8.0
4632 ShootToPlayer     15  75  16.0 8.0
4632 ShootToPlayer     34  125 16.0 -8.0
4632 ShootToPlayer     285 125 16.0 8.0
4632 ShootToPlayer     304 75  16.0 -8.0
4636 ShootToPlayer     15  75  16.0 8.0
4636 ShootToPlayer     34  125 16.0 -8.0
4636 ShootToPlayer     285 125 16.0 8.0
4636 ShootToPlayer     304 75  16.0 -8.0
4640 ShootToPlayer     15  75  16.0 8.0
4640 ShootToPlayer     34  125 16.0 -8.0
4640 ShootToPlayer     285 125 16.0 8.0
4640 ShootToPlayer     304 75  16.0 -8.0
4644 ShootToPlayer     15  75  16.0 8.0
4644 ShootToPlayer     34  125 16.0 -8.0
4644 ShootToPlayer     285 125 16.0 8.0
4644 ShootToPlayer     304 75  16.0 -8.0
4648 ShootToPlayer     15  75  16.0 8.0
4648 ShootToPlayer     34  125 16.0 -8.0
4648 ShootToPlayer     285 125 16.0 8.0
4648 ShootToPlayer     304 75  16.0 -8.0
4652 ShootToPlayer     15  75  16.0 8.0
4652 ShootToPlayer     34  125 16.0 -8.0
4652 ShootToPlayer     285 125 16.0 8.0
4652 ShootToPlayer     304 75  16.0 -8.0
4656 ShootToPlayer     15  75  16.0 8.0
4656 ShootToPlayer     34  125 16.0 -8.0
4656 ShootToPlayer     285 125 16.0 8.0
4656 ShootToPlayer     304 75  16.0 -8.0
4660 ShootToPlayer     15  75  16.0 8.0
4660 ShootToPlayer     34  125 16.0 -8.0
4660 ShootToPlayer     285 125 16.0 8.0
4660 ShootToPlayer     304 75  16.0 -8.0
4664 ShootToPlayer     15  75  16.0 8.0
4664 ShootToPlayer     34  125 16.0 -8.0
4664 ShootToPlayer     285 125 16.0 8.0
4664 ShootToPlayer     304 75  16.0 -8.0
4668 ShootToPlayer     15  75  16.0 8.0
4668 ShootToPlayer     34  125 16.0 -8.0
4668 ShootToPlayer     285 125 16.0 8.0
4668 ShootToPlayer     304 75  16.0 -8.0
4672 ShootToPlayer     15  75  16.0 8.0
4672 ShootToPlayer     34  125 16.0 -8.0
4672 ShootToPlayer     285 125 16.0 8.0
4672 ShootToPlayer     304 75  16.0 -8.0
4676 ShootToPlayer     15  75  16.0 8.0
4676 ShootToPlayer     34  125 16.0 -8.0
4676 ShootToPlayer     285 125 16.0 8.0
4676 ShootToPlayer     304 75  16.0 -8.0
4680 ShootToPlayer     15  75  16.0 8.0
4680 ShootToPlayer     34  125 16.0 -8.0
4680 ShootToPlayer     285 125 16.0 8.0
4680 ShootToPlayer     304 75  16.0 -8.0
4684 ShootToPlayer     15  75  16.0 8.0
4684 ShootToPlayer     34  125 16.0 -8.0
4684 ShootToPlayer     285 125 16.0 8.0
4684 ShootToPlayer     304 75  16.0 -8.0
4688 ShootToPlayer     15  75  16.0 8.0
4688 ShootToPlayer     34  125 16.0 -8.0
4688 ShootToPlayer     285 125 16.0 8.0
4688 ShootToPlayer     304 75  16.0 -8.0
4692 ShootToPlayer     15  75  16.0 8.0
4692 ShootToPlayer     34  125 16.0 -8.0
4692 ShootToPlayer     285 125 16.0 8.0
4692 ShootToPlayer     304 75  16.0 -8.0
4696 ShootToPlayer     15  75  16.0 8.0
4696 ShootToPlayer     34  125 16.0 -8.0
4696 ShootToPlayer     285 125 16.0 8.0
4696 ShootToPlayer     304 75  16.0 -8.0
4700 ShootToPlayer     15  75  16.0 8.0
4700 ShootToPlayer     34  125 16.0 -8.0
4700 ShootToPlayer     285 125 16.0 8.0
4700 ShootToPlayer     304 75  16.0 -8.0
4704 ShootToPlayer     15  75  16.0 8.0
4704 ShootToPlayer     34  125 16.0 -8.0
4704 ShootToPlayer     285 125 16.0 8.0
4704 ShootToPlayer     304 75  16.0 -8.0
4708 ShootToPlayer     15  75  16.0 8.0
4708 ShootToPlayer     34  125 16.0 -8.0
4708 ShootToPlayer     285 125 16.0 8.0
4708 ShootToPlayer     304 75  16.0 -8.0
4712 ShootToPlayer     15  75  16.0 8.0
4712 ShootToPlayer     34  125 16.0 -8.0
4712 ShootToPlayer     285 125 16.0 8.0
4712 ShootToPlayer     304 75  16.0 -8.0
4716 ShootToPlayer     15  75  16.0 8.0
4716 ShootToPlayer     34  125 16.0 -8.0
4716 ShootToPlayer     285 125 16.0 8.0
4716 ShootToPlayer     304 75  16.0 -8.0
4720 ShootToPlayer     15  75  16.0 8.0
4720 ShootToPlayer     34  125 16.0 -8.0
4720 ShootToPlayer     285 125 16.0 8.0
4720 ShootToPlayer     304 75  16.0 -8.0
4724 ShootToPlayer     15  75  16.0 8.0
4724 ShootToPlayer     34  125 16.0 -8.0
4724 ShootToPlayer     285 125 16.0 8.0
4724 ShootToPlayer     304 75  16.0 -8.0
4728 ShootToPlayer     15  75  16.0 8.0
4728 ShootToPlayer     34  125 16.0 -8.0
4728 ShootToPlayer     285 125 16.0 8.0
4728 ShootToPlayer     304 75  16.0 -8.0
4732 ShootToPlayer     15  75  16.0 8.0
4732 ShootToPlayer     34  125 16.0 -8.0
4732 ShootToPlayer     285 125 16.0 8.0
4732 ShootToPlayer     304 75  16.0 -8.0
4736 ShootToPlayer     15  75  16.0 8.0
4736 ShootToPlayer     34  125 16.0 -8.0
4736 ShootToPlayer     285 125 16.0 8.0
4736 ShootToPlayer     304 75  16.0 -8.0
4740 ShootToPlayer     15  75  16.0 8.0
4740 ShootToPlayer     34  125 16.0 -8.0
4740 ShootToPlayer     285 125 16.0 8.0
4740 ShootToPlayer     304 75  16.0 -8.0
4744 ShootToPlayer     15  75  16.0 8.0
4744 ShootToPlayer     34  125 16.0 -8.0
4744 ShootToPlayer     285 125 16.0 8.0
4744 ShootToPlayer     304 75  16.0 -8.0
4748 ShootToPlayer     15  75  16.0 8.0
4748 ShootToPlayer     34  125 16.0 -8.0
4748 ShootToPlayer     285 125 16.0 8.0
4748 ShootToPlayer     304 75  16.0 -8.0
4752 ShootToPlayer     15  75  16.0 8.0
4752 ShootToPlayer     34  125 16.0 -8.0
4752 ShootToPlayer     285 125 16.0 8.0
4752 ShootToPlayer     304 75  16.0 -8.0
4756 ShootToPlayer     15  75  16.0 8.0
4756 ShootToPlayer     34  125 16.0 -8.0
4756 ShootToPlayer     285 125 16.0 8.0
4756 ShootToPlayer     304 75  16.0 -8.0
4760 ShootToPlayer     15  75  16.0 8.0
4760 ShootToPlayer     34  125 16.0 -8.0
4760 ShootToPlayer     285 125 16.0 8.0
4760 ShootToPlayer     304 75  16.0 -8.0
4764 ShootToPlayer     15  75  16.0 8.0
4764 ShootToPlayer     34  125 16.0 -8.0
4764 ShootToPlayer     285 125 16.0 8.0
4764 ShootToPlayer     304 75  16.0 -8.0
4768 ShootToPlayer     15  75  16.0 8.0
4768 ShootToPlayer     34  125 16.0 -8.0
4768 ShootToPlayer     285 125 16.0 8.0
4768 ShootToPlayer     304 75  16.0 -8.0
4772 ShootToPlayer     15  75  16.0 8.0
4772 ShootToPlayer     34  125 16.0 -8.0
4772 ShootToPlayer     285 125 16.0 8.0
4772 ShootToPlayer     304 75  16.0 -8.0
4776 ShootToPlayer     15  75  16.0 8.0
4776 ShootToPlayer     34  125 16.0 -8.0
4776 ShootToPlayer     285 125 16.0 8.0
4776 ShootToPlayer     304 75  16.0 -8.0
4780 ShootToPlayer     15  75  16.0 8.0
4780 ShootToPlayer     34  125 16.0 -8.0
4780 ShootToPlayer     285 125 16.0 8.0
4780 ShootToPlayer     304 75  16.0 -8.0
4784 ShootToPlayer     15  75  16.0 8.0
4784 ShootToPlayer     34  125 16.0 -8.0
4784 ShootToPlayer     285 125 16.0 8.0
4784 ShootToPlayer     304 75  16.0 -8.0
4788 ShootToPlayer     15  75  16.0 8.0
4788 ShootToPlayer     34  125 16.0 -8.0
4788 ShootToPlayer     285 125 16.0 8.0
4788 ShootToPlayer     304 75  16.0 -8.0
4792 ShootToPlayer     15  75  16.0 8.0
4792 ShootToPlayer     34  125 16.0 -8.0
4792 ShootToPlayer     285 125 16.0 8.0
4792 ShootToPlayer     304 75  16.0 -8.0
4796 ShootToPlayer     15  75  16.0 8.0
4796 ShootToPlayer     34  125 16.0 -8.0
4796 ShootToPlayer     285 125 16.0 8.0
4796 ShootToPlayer     304 75  16.0 -8.0

4230 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4250 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4270 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4290 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4310 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4330 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4350 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4370 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4390 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4410 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4430 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4450 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4470 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4490 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4510 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4530 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4550 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4570 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4590 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4610 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4630 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4650 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4670 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4690 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4710 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4730 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0
4750 ShootToPlayer     160 123 15.0 -60.0 -52.5 -45.0 -37.5 -30.0 -22.5 -15.0 -7.5 0.0 7.5 15.0 22.5 30.0 37.5 45.0 52.5 60.0



       
///////////////////////////////////////
```

`Source Code/Data/EnemyLevel7.txt`:

```txt
typeID: 3   cmdCount: 1
MainCmd
0    SetCmd            0
=========================
90   SetVelY           -2.0
98   ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
106  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
114  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
122  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
130  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
140  SetVelY           4.0
140  SetVelX           2.0
200  SetVelY           -2.0
200  SetVelX           0.0
208  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
216  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
224  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
232  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
240  ShootToPlayer     95  170 8.0 -70.5 -67.5 -64.5  -48.0 -45.0 -42.0  -25.5 -22.5 -19.5  -3.0 0.0 3.0  19.5 22.5 25.5  42.0 45.0 48.0  64.5 67.5 70.5
240  SetVelY           4.0
/////////////////////////
typeID: 15  cmdCount: 9
MainCmd
0    SetCmd            0
401  SetCmd            1 2 3 4 5 6 7
850  SetFrame          400 

420  SetFrameIfHPLess  1000 860
510  SetFrameIfHPLess  1000 860
600  SetFrameIfHPLess  1000 860
690  SetFrameIfHPLess  1000 860
780  SetFrameIfHPLess  1000 860

861  SetCmd            8
1005 SetFrame          999
===========Cmd0==========
0    SetVelX           0.0
0    SetVelY           0.0

6    MakeLaserRand     0   740 12.0 4
12   MakeLaserRand     0   740 12.0 4
18   MakeLaserRand     0   740 12.0 4
24   MakeLaserRand     0   740 12.0 4
30   MakeLaserRand     0   740 12.0 4
36   MakeLaserRand     0   740 12.0 4
42   MakeLaserRand     0   740 12.0 4
48   MakeLaserRand     0   740 12.0 4
54   MakeLaserRand     0   740 12.0 4
60   MakeLaserRand     0   740 12.0 4
66   MakeLaserRand     0   740 12.0 4
72   MakeLaserRand     0   740 12.0 4
78   MakeLaserRand     0   740 12.0 4
84   MakeLaserRand     0   740 12.0 4
90   MakeLaserRand     0   740 12.0 4
96   MakeLaserRand     0   740 12.0 4
102  MakeLaserRand     0   740 12.0 4
108  MakeLaserRand     0   740 12.0 4
114  MakeLaserRand     0   740 12.0 4
120  MakeLaserRand     0   740 12.0 4
126  MakeLaserRand     0   740 12.0 4
132  MakeLaserRand     0   740 12.0 4
138  MakeLaserRand     0   740 12.0 4
144  MakeLaserRand     0   740 12.0 4
150  MakeLaserRand     0   740 12.0 4
156  MakeLaserRand     0   740 12.0 4
162  MakeLaserRand     0   740 12.0 4
168  MakeLaserRand     0   740 12.0 4
174  MakeLaserRand     0   740 12.0 4
180  MakeLaserRand     0   740 12.0 4
186  MakeLaserRand     0   740 12.0 4
192  MakeLaserRand     0   740 12.0 4
198  MakeLaserRand     0   740 12.0 4
204  MakeLaserRand     0   740 12.0 4
210  MakeLaserRand     0   740 12.0 4
216  MakeLaserRand     0   740 12.0 4
222  MakeLaserRand     0   740 12.0 4
228  MakeLaserRand     0   740 12.0 4
234  MakeLaserRand     0   740 12.0 4
240  MakeLaserRand     0   740 12.0 4
246  MakeLaserRand     0   740 12.0 4
252  MakeLaserRand     0   740 12.0 4
258  MakeLaserRand     0   740 12.0 4
264  MakeLaserRand     0   740 12.0 4
270  MakeLaserRand     0   740 12.0 4
276  MakeLaserRand     0   740 12.0 4
282  MakeLaserRand     0   740 12.0 4
288  MakeLaserRand     0   740 12.0 4
294  MakeLaserRand     0   740 12.0 4
300  MakeLaserRand     0   740 12.0 4
306  MakeLaserRand     0   740 12.0 4
312  MakeLaserRand     0   740 12.0 4
318  MakeLaserRand     0   740 12.0 4
324  MakeLaserRand     0   740 12.0 4


344  SetVelY           10.0
394  SetVelY           0.0
399  SetVelX           8.0
==========Cmd1===========
410  Charge            0
450  ShootLaser        32  70  40.0
450  ShootLaser        47  70  40.0
453  ShootLaser        32  70  40.0
453  ShootLaser        47  70  40.0
456  ShootLaser        32  70  40.0
456  ShootLaser        47  70  40.0
459  ShootLaser        32  70  40.0
459  ShootLaser        47  70  40.0
462  ShootLaser        32  70  40.0
462  ShootLaser        47  70  40.0
465  ShootLaser        32  70  40.0
465  ShootLaser        47  70  40.0
468  ShootLaser        32  70  40.0
468  ShootLaser        47  70  40.0
471  ShootLaser        32  70  40.0
471  ShootLaser        47  70  40.0
474  ShootLaser        32  70  40.0
474  ShootLaser        47  70  40.0
477  ShootLaser        32  70  40.0
477  ShootLaser        47  70  40.0
480  ShootToPlayer     39  60  6.0 -60.0 -50.0 -40.0 -30.0 -20.0 -10.0 0.0 10.0 20.0 30.0 40.0 50.0 60.0
480  ShootToPlayer     39  60  7.0 -57.0 -47.0 -37.0 -27.0 -17.0 -7.0 3.0 13.0 23.0 33.0 43.0 53.0 63.0
480  ShootToPlayer     39  60  8.0 -54.0 -44.0 -34.0 -24.0 -14.0 -4.0 6.0 16.0 26.0 36.0 46.0 56.0 66.0

510  ShootLaser        32  70  40.0
510  ShootLaser        47  70  40.0
513  ShootLaser        32  70  40.0
513  ShootLaser        47  70  40.0
516  ShootLaser        32  70  40.0
516  ShootLaser        47  70  40.0
519  ShootLaser        32  70  40.0
519  ShootLaser        47  70  40.0
522  ShootLaser        32  70  40.0
522  ShootLaser        47  70  40.0
525  ShootLaser        32  70  40.0
525  ShootLaser        47  70  40.0
528  ShootLaser        32  70  40.0
528  ShootLaser        47  70  40.0
531  ShootLaser        32  70  40.0
531  ShootLaser        47  70  40.0
534  ShootLaser        32  70  40.0
534  ShootLaser        47  70  40.0
537  ShootLaser        32  70  40.0
537  ShootLaser        47  70  40.0
540  ShootToPlayer     39  60  6.0 -60.0 -50.0 -40.0 -30.0 -20.0 -10.0 0.0 10.0 20.0 30.0 40.0 50.0 60.0
540  ShootToPlayer     39  60  7.0 -57.0 -47.0 -37.0 -27.0 -17.0 -7.0 3.0 13.0 23.0 33.0 43.0 53.0 63.0
540  ShootToPlayer     39  60  8.0 -54.0 -44.0 -34.0 -24.0 -14.0 -4.0 6.0 16.0 26.0 36.0 46.0 56.0 66.0

570  ShootLaser        32  70  40.0
570  ShootLaser        47  70  40.0
573  ShootLaser        32  70  40.0
573  ShootLaser        47  70  40.0
576  ShootLaser        32  70  40.0
576  ShootLaser        47  70  40.0
579  ShootLaser        32  70  40.0
579  ShootLaser        47  70  40.0
582  ShootLaser        32  70  40.0
582  ShootLaser        47  70  40.0
585  ShootLaser        32  70  40.0
585  ShootLaser        47  70  40.0
588  ShootLaser        32  70  40.0
588  ShootLaser        47  70  40.0
591  ShootLaser        32  70  40.0
591  ShootLaser        47  70  40.0
594  ShootLaser        32  70  40.0
594  ShootLaser        47  70  40.0
597  ShootLaser        32  70  40.0
597  ShootLaser        47  70  40.0
600  ShootToPlayer     39  60  6.0 -60.0 -50.0 -40.0 -30.0 -20.0 -10.0 0.0 10.0 20.0 30.0 40.0 50.0 60.0
600  ShootToPlayer     39  60  7.0 -57.0 -47.0 -37.0 -27.0 -17.0 -7.0 3.0 13.0 23.0 33.0 43.0 53.0 63.0
600  ShootToPlayer     39  60  8.0 -54.0 -44.0 -34.0 -24.0 -14.0 -4.0 6.0 16.0 26.0 36.0 46.0 56.0 66.0

630  ShootLaser        32  70  40.0
630  ShootLaser        47  70  40.0
633  ShootLaser        32  70  40.0
633  ShootLaser        47  70  40.0
636  ShootLaser        32  70  40.0
636  ShootLaser        47  70  40.0
639  ShootLaser        32  70  40.0
639  ShootLaser        47  70  40.0
642  ShootLaser        32  70  40.0
642  ShootLaser        47  70  40.0
645  ShootLaser        32  70  40.0
645  ShootLaser        47  70  40.0
648  ShootLaser        32  70  40.0
648  ShootLaser        47  70  40.0
651  ShootLaser        32  70  40.0
651  ShootLaser        47  70  40.0
654  ShootLaser        32  70  40.0
654  ShootLaser        47  70  40.0
657  ShootLaser        32  70  40.0
657  ShootLaser        47  70  40.0
660  ShootToPlayer     39  60  6.0 -60.0 -50.0 -40.0 -30.0 -20.0 -10.0 0.0 10.0 20.0 30.0 40.0 50.0 60.0
660  ShootToPlayer     39  60  7.0 -57.0 -47.0 -37.0 -27.0 -17.0 -7.0 3.0 13.0 23.0 33.0 43.0 53.0 63.0
660  ShootToPlayer     39  60  8.0 -54.0 -44.0 -34.0 -24.0 -14.0 -4.0 6.0 16.0 26.0 36.0 46.0 56.0 66.0

690  ShootLaser        32  70  40.0
690  ShootLaser        47  70  40.0
693  ShootLaser        32  70  40.0
693  ShootLaser        47  70  40.0
696  ShootLaser        32  70  40.0
696  ShootLaser        47  70  40.0
699  ShootLaser        32  70  40.0
699  ShootLaser        47  70  40.0
702  ShootLaser        32  70  40.0
702  ShootLaser        47  70  40.0
705  ShootLaser        32  70  40.0
705  ShootLaser        47  70  40.0
708  ShootLaser        32  70  40.0
708  ShootLaser        47  70  40.0
711  ShootLaser        32  70  40.0
711  ShootLaser        47  70  40.0
714  ShootLaser        32  70  40.0
714  ShootLaser        47  70  40.0
717  ShootLaser        32  70  40.0
717  ShootLaser        47  70  40.0
720  ShootToPlayer     39  60  6.0 -60.0 -50.0 -40.0 -30.0 -20.0 -10.0 0.0 10.0 20.0 30.0 40.0 50.0 60.0
720  ShootToPlayer     39  60  7.0 -57.0 -47.0 -37.0 -27.0 -17.0 -7.0 3.0 13.0 23.0 33.0 43.0 53.0 63.0
720  ShootToPlayer     39  60  8.0 -54.0 -44.0 -34.0 -24.0 -14.0 -4.0 6.0 16.0 26.0 36.0 46.0 56.0 66.0

750  ShootLaser        32  70  40.0
750  ShootLaser        47  70  40.0
753  ShootLaser        32  70  40.0
753  ShootLaser        47  70  40.0
756  ShootLaser        32  70  40.0
756  ShootLaser        47  70  40.0
759  ShootLaser        32  70  40.0
759  ShootLaser        47  70  40.0
762  ShootLaser        32  70  40.0
762  ShootLaser        47  70  40.0
765  ShootLaser        32  70  40.0
765  ShootLaser        47  70  40.0
768  ShootLaser        32  70  40.0
768  ShootLaser        47  70  40.0
771  ShootLaser        32  70  40.0
771  ShootLaser        47  70  40.0
774  ShootLaser        32  70  40.0
774  ShootLaser        47  70  40.0
777  ShootLaser        32  70  40.0
777  ShootLaser        47  70  40.0
780  ShootToPlayer     39  60  6.0 -60.0 -50.0 -40.0 -30.0 -20.0 -10.0 0.0 10.0 20.0 30.0 40.0 50.0 60.0
780  ShootToPlayer     39  60  7.0 -57.0 -47.0 -37.0 -27.0 -17.0 -7.0 3.0 13.0 23.0 33.0 43.0 53.0 63.0
780  ShootToPlayer     39  60  8.0 -54.0 -44.0 -34.0 -24.0 -14.0 -4.0 6.0 16.0 26.0 36.0 46.0 56.0 66.0
=========Cmd2============
410  ShootFlameToPlayerRand    39  60  4.0 75.0 3
410  ShootFlameToPlayerRand    39  60  6.0 75.0 2
410  ShootFlameToPlayerRand    39  60  8.0 75.0 2
416  ShootFlameToPlayerRand    39  60  4.0 75.0 3
416  ShootFlameToPlayerRand    39  60  6.0 75.0 2
416  ShootFlameToPlayerRand    39  60  8.0 75.0 2
422  ShootFlameToPlayerRand    39  60  4.0 75.0 3
422  ShootFlameToPlayerRand    39  60  6.0 75.0 2
422  ShootFlameToPlayerRand    39  60  8.0 75.0 2
428  ShootFlameToPlayerRand    39  60  4.0 75.0 3
428  ShootFlameToPlayerRand    39  60  6.0 75.0 2
428  ShootFlameToPlayerRand    39  60  8.0 75.0 2
434  ShootFlameToPlayerRand    39  60  4.0 75.0 3
434  ShootFlameToPlayerRand    39  60  6.0 75.0 2
434  ShootFlameToPlayerRand    39  60  8.0 75.0 2
440  ShootFlameToPlayerRand    39  60  4.0 75.0 3
440  ShootFlameToPlayerRand    39  60  6.0 75.0 2
440  ShootFlameToPlayerRand    39  60  8.0 75.0 2
446  ShootFlameToPlayerRand    39  60  4.0 75.0 3
446  ShootFlameToPlayerRand    39  60  6.0 75.0 2
446  ShootFlameToPlayerRand    39  60  8.0 75.0 2
452  ShootFlameToPlayerRand    39  60  4.0 75.0 3
452  ShootFlameToPlayerRand    39  60  6.0 75.0 2
452  ShootFlameToPlayerRand    39  60  8.0 75.0 2
458  ShootFlameToPlayerRand    39  60  4.0 75.0 3
458  ShootFlameToPlayerRand    39  60  6.0 75.0 2
458  ShootFlameToPlayerRand    39  60  8.0 75.0 2
464  ShootFlameToPlayerRand    39  60  4.0 75.0 3
464  ShootFlameToPlayerRand    39  60  6.0 75.0 2
464  ShootFlameToPlayerRand    39  60  8.0 75.0 2
470  ShootFlameToPlayerRand    39  60  4.0 75.0 3
470  ShootFlameToPlayerRand    39  60  6.0 75.0 2
470  ShootFlameToPlayerRand    39  60  8.0 75.0 2
476  ShootFlameToPlayerRand    39  60  4.0 75.0 3
476  ShootFlameToPlayerRand    39  60  6.0 75.0 2
476  ShootFlameToPlayerRand    39  60  8.0 75.0 2
482  ShootFlameToPlayerRand    39  60  4.0 75.0 3
482  ShootFlameToPlayerRand    39  60  6.0 75.0 2
482  ShootFlameToPlayerRand    39  60  8.0 75.0 2
488  ShootFlameToPlayerRand    39  60  4.0 75.0 3
488  ShootFlameToPlayerRand    39  60  6.0 75.0 2
488  ShootFlameToPlayerRand    39  60  8.0 75.0 2
494  ShootFlameToPlayerRand    39  60  4.0 75.0 3
494  ShootFlameToPlayerRand    39  60  6.0 75.0 2
494  ShootFlameToPlayerRand    39  60  8.0 75.0 2
500  ShootFlameToPlayerRand    39  60  4.0 75.0 3
500  ShootFlameToPlayerRand    39  60  6.0 75.0 2
500  ShootFlameToPlayerRand    39  60  8.0 75.0 2
506  ShootFlameToPlayerRand    39  60  4.0 75.0 3
506  ShootFlameToPlayerRand    39  60  6.0 75.0 2
506  ShootFlameToPlayerRand    39  60  8.0 75.0 2
512  ShootFlameToPlayerRand    39  60  4.0 75.0 3
512  ShootFlameToPlayerRand    39  60  6.0 75.0 2
512  ShootFlameToPlayerRand    39  60  8.0 75.0 2
518  ShootFlameToPlayerRand    39  60  4.0 75.0 3
518  ShootFlameToPlayerRand    39  60  6.0 75.0 2
518  ShootFlameToPlayerRand    39  60  8.0 75.0 2
524  ShootFlameToPlayerRand    39  60  4.0 75.0 3
524  ShootFlameToPlayerRand    39  60  6.0 75.0 2
524  ShootFlameToPlayerRand    39  60  8.0 75.0 2
530  ShootFlameToPlayerRand    39  60  4.0 75.0 3
530  ShootFlameToPlayerRand    39  60  6.0 75.0 2
530  ShootFlameToPlayerRand    39  60  8.0 75.0 2
536  ShootFlameToPlayerRand    39  60  4.0 75.0 3
536  ShootFlameToPlayerRand    39  60  6.0 75.0 2
536  ShootFlameToPlayerRand    39  60  8.0 75.0 2
542  ShootFlameToPlayerRand    39  60  4.0 75.0 3
542  ShootFlameToPlayerRand    39  60  6.0 75.0 2
542  ShootFlameToPlayerRand    39  60  8.0 75.0 2
548  ShootFlameToPlayerRand    39  60  4.0 75.0 3
548  ShootFlameToPlayerRand    39  60  6.0 75.0 2
548  ShootFlameToPlayerRand    39  60  8.0 75.0 2
554  ShootFlameToPlayerRand    39  60  4.0 75.0 3
554  ShootFlameToPlayerRand    39  60  6.0 75.0 2
554  ShootFlameToPlayerRand    39  60  8.0 75.0 2
560  ShootFlameToPlayerRand    39  60  4.0 75.0 3
560  ShootFlameToPlayerRand    39  60  6.0 75.0 2
560  ShootFlameToPlayerRand    39  60  8.0 75.0 2
566  ShootFlameToPlayerRand    39  60  4.0 75.0 3
566  ShootFlameToPlayerRand    39  60  6.0 75.0 2
566  ShootFlameToPlayerRand    39  60  8.0 75.0 2
572  ShootFlameToPlayerRand    39  60  4.0 75.0 3
572  ShootFlameToPlayerRand    39  60  6.0 75.0 2
572  ShootFlameToPlayerRand    39  60  8.0 75.0 2
578  ShootFlameToPlayerRand    39  60  4.0 75.0 3
578  ShootFlameToPlayerRand    39  60  6.0 75.0 2
578  ShootFlameToPlayerRand    39  60  8.0 75.0 2
584  ShootFlameToPlayerRand    39  60  4.0 75.0 3
584  ShootFlameToPlayerRand    39  60  6.0 75.0 2
584  ShootFlameToPlayerRand    39  60  8.0 75.0 2
590  ShootFlameToPlayerRand    39  60  4.0 75.0 3
590  ShootFlameToPlayerRand    39  60  6.0 75.0 2
590  ShootFlameToPlayerRand    39  60  8.0 75.0 2
596  ShootFlameToPlayerRand    39  60  4.0 75.0 3
596  ShootFlameToPlayerRand    39  60  6.0 75.0 2
596  ShootFlameToPlayerRand    39  60  8.0 75.0 2
602  ShootFlameToPlayerRand    39  60  4.0 75.0 3
602  ShootFlameToPlayerRand    39  60  6.0 75.0 2
602  ShootFlameToPlayerRand    39  60  8.0 75.0 2
608  ShootFlameToPlayerRand    39  60  4.0 75.0 3
608  ShootFlameToPlayerRand    39  60  6.0 75.0 2
608  ShootFlameToPlayerRand    39  60  8.0 75.0 2
614  ShootFlameToPlayerRand    39  60  4.0 75.0 3
614  ShootFlameToPlayerRand    39  60  6.0 75.0 2
614  ShootFlameToPlayerRand    39  60  8.0 75.0 2
620  ShootFlameToPlayerRand    39  60  4.0 75.0 3
620  ShootFlameToPlayerRand    39  60  6.0 75.0 2
620  ShootFlameToPlayerRand    39  60  8.0 75.0 2
626  ShootFlameToPlayerRand    39  60  4.0 75.0 3
626  ShootFlameToPlayerRand    39  60  6.0 75.0 2
626  ShootFlameToPlayerRand    39  60  8.0 75.0 2
632  ShootFlameToPlayerRand    39  60  4.0 75.0 3
632  ShootFlameToPlayerRand    39  60  6.0 75.0 2
632  ShootFlameToPlayerRand    39  60  8.0 75.0 2
638  ShootFlameToPlayerRand    39  60  4.0 75.0 3
638  ShootFlameToPlayerRand    39  60  6.0 75.0 2
638  ShootFlameToPlayerRand    39  60  8.0 75.0 2
644  ShootFlameToPlayerRand    39  60  4.0 75.0 3
644  ShootFlameToPlayerRand    39  60  6.0 75.0 2
644  ShootFlameToPlayerRand    39  60  8.0 75.0 2
650  ShootFlameToPlayerRand    39  60  4.0 75.0 3
650  ShootFlameToPlayerRand    39  60  6.0 75.0 2
650  ShootFlameToPlayerRand    39  60  8.0 75.0 2
656  ShootFlameToPlayerRand    39  60  4.0 75.0 3
656  ShootFlameToPlayerRand    39  60  6.0 75.0 2
656  ShootFlameToPlayerRand    39  60  8.0 75.0 2
662  ShootFlameToPlayerRand    39  60  4.0 75.0 3
662  ShootFlameToPlayerRand    39  60  6.0 75.0 2
662  ShootFlameToPlayerRand    39  60  8.0 75.0 2
668  ShootFlameToPlayerRand    39  60  4.0 75.0 3
668  ShootFlameToPlayerRand    39  60  6.0 75.0 2
668  ShootFlameToPlayerRand    39  60  8.0 75.0 2
674  ShootFlameToPlayerRand    39  60  4.0 75.0 3
674  ShootFlameToPlayerRand    39  60  6.0 75.0 2
674  ShootFlameToPlayerRand    39  60  8.0 75.0 2
680  ShootFlameToPlayerRand    39  60  4.0 75.0 3
680  ShootFlameToPlayerRand    39  60  6.0 75.0 2
680  ShootFlameToPlayerRand    39  60  8.0 75.0 2
686  ShootFlameToPlayerRand    39  60  4.0 75.0 3
686  ShootFlameToPlayerRand    39  60  6.0 75.0 2
686  ShootFlameToPlayerRand    39  60  8.0 75.0 2
692  ShootFlameToPlayerRand    39  60  4.0 75.0 3
692  ShootFlameToPlayerRand    39  60  6.0 75.0 2
692  ShootFlameToPlayerRand    39  60  8.0 75.0 2
698  ShootFlameToPlayerRand    39  60  4.0 75.0 3
698  ShootFlameToPlayerRand    39  60  6.0 75.0 2
698  ShootFlameToPlayerRand    39  60  8.0 75.0 2
704  ShootFlameToPlayerRand    39  60  4.0 75.0 3
704  ShootFlameToPlayerRand    39  60  6.0 75.0 2
704  ShootFlameToPlayerRand    39  60  8.0 75.0 2
710  ShootFlameToPlayerRand    39  60  4.0 75.0 3
710  ShootFlameToPlayerRand    39  60  6.0 75.0 2
710  ShootFlameToPlayerRand    39  60  8.0 75.0 2
716  ShootFlameToPlayerRand    39  60  4.0 75.0 3
716  ShootFlameToPlayerRand    39  60  6.0 75.0 2
716  ShootFlameToPlayerRand    39  60  8.0 75.0 2
722  ShootFlameToPlayerRand    39  60  4.0 75.0 3
722  ShootFlameToPlayerRand    39  60  6.0 75.0 2
722  ShootFlameToPlayerRand    39  60  8.0 75.0 2
728  ShootFlameToPlayerRand    39  60  4.0 75.0 3
728  ShootFlameToPlayerRand    39  60  6.0 75.0 2
728  ShootFlameToPlayerRand    39  60  8.0 75.0 2
734  ShootFlameToPlayerRand    39  60  4.0 75.0 3
734  ShootFlameToPlayerRand    39  60  6.0 75.0 2
734  ShootFlameToPlayerRand    39  60  8.0 75.0 2
740  ShootFlameToPlayerRand    39  60  4.0 75.0 3
740  ShootFlameToPlayerRand    39  60  6.0 75.0 2
740  ShootFlameToPlayerRand    39  60  8.0 75.0 2
746  ShootFlameToPlayerRand    39  60  4.0 75.0 3
746  ShootFlameToPlayerRand    39  60  6.0 75.0 2
746  ShootFlameToPlayerRand    39  60  8.0 75.0 2
752  ShootFlameToPlayerRand    39  60  4.0 75.0 3
752  ShootFlameToPlayerRand    39  60  6.0 75.0 2
752  ShootFlameToPlayerRand    39  60  8.0 75.0 2
758  ShootFlameToPlayerRand    39  60  4.0 75.0 3
758  ShootFlameToPlayerRand    39  60  6.0 75.0 2
758  ShootFlameToPlayerRand    39  60  8.0 75.0 2
764  ShootFlameToPlayerRand    39  60  4.0 75.0 3
764  ShootFlameToPlayerRand    39  60  6.0 75.0 2
764  ShootFlameToPlayerRand    39  60  8.0 75.0 2
========Cmd3============
401  SetVelX           0.0
849  SetVelX           8.0

420  ShootFlame        39  60   5.6 180.0 0.0
423  ShootFlame        39  60   5.6 169.0 11.0
426  ShootFlame        39  60   5.6 158.0 22.0
429  ShootFlame        39  60   5.6 147.0 33.0
432  ShootFlame        39  60   5.6 136.0 44.0
435  ShootFlame        39  60   5.6 125.0 55.0
438  ShootFlame        39  60   5.6 114.0 66.0
441  ShootFlame        39  60   5.6 103.0 77.0
444  ShootFlame        39  60   5.6 92.0 88.0
447  ShootFlame        39  60   5.6 81.0 99.0
450  ShootFlame        39  60   5.6 70.0 110.0
453  ShootFlame        39  60   5.6 59.0 121.0
456  ShootFlame        39  60   5.6 48.0 132.0
459  ShootFlame        39  60   5.6 37.0 143.0
462  ShootFlame        39  60   5.6 26.0 154.0
465  ShootFlame        39  60   5.6 15.0 165.0
468  ShootFlame        39  60   5.6 4.0 176.0
471  ShootFlame        39  60   5.6 -7.0 187.0
474  ShootFlame        39  60   5.6 -18.0 198.0
477  ShootFlame        39  60   5.6 -29.0 209.0
480  ShootFlame        39  60   5.6 -40.0 220.0
483  ShootFlame        39  60   5.6 -51.0 231.0
486  ShootFlame        39  60   5.6 -62.0 242.0
489  ShootFlame        39  60   5.6 -73.0 253.0
492  ShootFlame        39  60   5.6 -84.0 264.0
495  ShootFlame        39  60   5.6 -95.0 275.0
498  ShootFlame        39  60   5.6 -106.0 286.0
501  ShootFlame        39  60   5.6 -117.0 297.0
504  ShootFlame        39  60   5.6 -128.0 308.0
507  ShootFlame        39  60   5.6 -139.0 319.0
510  ShootFlame        39  60   5.6 -150.0 330.0
513  ShootFlame        39  60   5.6 -161.0 341.0
516  ShootFlame        39  60   5.6 -172.0 352.0
519  ShootFlame        39  60   5.6 -183.0 363.0
522  ShootFlame        39  60   5.6 -194.0 374.0
525  ShootFlame        39  60   5.6 -205.0 385.0
528  ShootFlame        39  60   5.6 -216.0 396.0
531  ShootFlame        39  60   5.6 -227.0 407.0
534  ShootFlame        39  60   5.6 -238.0 418.0
537  ShootFlame        39  60   5.6 -249.0 429.0
540  ShootFlame        39  60   5.6 -260.0 440.0
543  ShootFlame        39  60   5.6 -271.0 451.0
546  ShootFlame        39  60   5.6 -282.0 462.0
549  ShootFlame        39  60   5.6 -293.0 473.0
552  ShootFlame        39  60   5.6 -304.0 484.0
555  ShootFlame        39  60   5.6 -315.0 495.0
558  ShootFlame        39  60   5.6 -326.0 506.0
561  ShootFlame        39  60   5.6 -337.0 517.0
564  ShootFlame        39  60   5.6 -348.0 528.0
567  ShootFlame        39  60   5.6 -359.0 539.0
570  ShootFlame        39  60   5.6 -370.0 550.0
573  ShootFlame        39  60   5.6 -381.0 561.0
576  ShootFlame        39  60   5.6 -392.0 572.0
579  ShootFlame        39  60   5.6 -403.0 583.0
582  ShootFlame        39  60   5.6 -414.0 594.0
585  ShootFlame        39  60   5.6 -425.0 605.0
588  ShootFlame        39  60   5.6 -436.0 616.0
591  ShootFlame        39  60   5.6 -447.0 627.0
594  ShootFlame        39  60   5.6 -458.0 638.0
597  ShootFlame        39  60   5.6 -469.0 649.0
600  ShootFlame        39  60   5.6 -480.0 660.0
603  ShootFlame        39  60   5.6 -491.0 671.0
606  ShootFlame        39  60   5.6 -502.0 682.0
609  ShootFlame        39  60   5.6 -513.0 693.0
612  ShootFlame        39  60   5.6 -524.0 704.0
615  ShootFlame        39  60   5.6 -535.0 715.0
618  ShootFlame        39  60   5.6 -546.0 726.0
621  ShootFlame        39  60   5.6 -557.0 737.0
624  ShootFlame        39  60   5.6 -568.0 748.0
627  ShootFlame        39  60   5.6 -579.0 759.0
630  ShootFlame        39  60   5.6 -590.0 770.0
633  ShootFlame        39  60   5.6 -601.0 781.0
636  ShootFlame        39  60   5.6 -612.0 792.0
639  ShootFlame        39  60   5.6 -623.0 803.0
642  ShootFlame        39  60   5.6 -634.0 814.0
645  ShootFlame        39  60   5.6 -645.0 825.0
648  ShootFlame        39  60   5.6 -656.0 836.0
651  ShootFlame        39  60   5.6 -667.0 847.0
654  ShootFlame        39  60   5.6 -678.0 858.0
657  ShootFlame        39  60   5.6 -689.0 869.0
660  ShootFlame        39  60   5.6 -700.0 880.0
663  ShootFlame        39  60   5.6 -711.0 891.0
666  ShootFlame        39  60   5.6 -722.0 902.0
669  ShootFlame        39  60   5.6 -733.0 913.0
672  ShootFlame        39  60   5.6 -744.0 924.0
675  ShootFlame        39  60   5.6 -755.0 935.0
678  ShootFlame        39  60   5.6 -766.0 946.0
681  ShootFlame        39  60   5.6 -777.0 957.0
684  ShootFlame        39  60   5.6 -788.0 968.0
687  ShootFlame        39  60   5.6 -799.0 979.0
690  ShootFlame        39  60   5.6 -810.0 990.0
693  ShootFlame        39  60   5.6 -821.0 1001.0
696  ShootFlame        39  60   5.6 -832.0 1012.0
699  ShootFlame        39  60   5.6 -843.0 1023.0
702  ShootFlame        39  60   5.6 -854.0 1034.0
705  ShootFlame        39  60   5.6 -865.0 1045.0
708  ShootFlame        39  60   5.6 -876.0 1056.0
711  ShootFlame        39  60   5.6 -887.0 1067.0
714  ShootFlame        39  60   5.6 -898.0 1078.0
717  ShootFlame        39  60   5.6 -909.0 1089.0
720  ShootFlame        39  60   5.6 -920.0 1100.0
723  ShootFlame        39  60   5.6 -931.0 1111.0
726  ShootFlame        39  60   5.6 -942.0 1122.0
729  ShootFlame        39  60   5.6 -953.0 1133.0
732  ShootFlame        39  60   5.6 -964.0 1144.0
735  ShootFlame        39  60   5.6 -975.0 1155.0
738  ShootFlame        39  60   5.6 -986.0 1166.0
741  ShootFlame        39  60   5.6 -997.0 1177.0
744  ShootFlame        39  60   5.6 -1008.0 1188.0
747  ShootFlame        39  60   5.6 -1019.0 1199.0
750  ShootFlame        39  60   5.6 -1030.0 1210.0
753  ShootFlame        39  60   5.6 -1041.0 1221.0
756  ShootFlame        39  60   5.6 -1052.0 1232.0
759  ShootFlame        39  60   5.6 -1063.0 1243.0
762  ShootFlame        39  60   5.6 -1074.0 1254.0
765  ShootFlame        39  60   5.6 -1085.0 1265.0
768  ShootFlame        39  60   5.6 -1096.0 1276.0
771  ShootFlame        39  60   5.6 -1107.0 1287.0
774  ShootFlame        39  60   5.6 -1118.0 1298.0
777  ShootFlame        39  60   5.6 -1129.0 1309.0
780  ShootFlame        39  60   5.6 -1140.0 1320.0
783  ShootFlame        39  60   5.6 -1151.0 1331.0
786  ShootFlame        39  60   5.6 -1162.0 1342.0
789  ShootFlame        39  60   5.6 -1173.0 1353.0
792  ShootFlame        39  60   5.6 -1184.0 1364.0
795  ShootFlame        39  60   5.6 -1195.0 1375.0
420  ShootFlame        39  60   5.4 178.5 1.5
423  ShootFlame        39  60   5.4 167.5 12.5
426  ShootFlame        39  60   5.4 156.5 23.5
429  ShootFlame        39  60   5.4 145.5 34.5
432  ShootFlame        39  60   5.4 134.5 45.5
435  ShootFlame        39  60   5.4 123.5 56.5
438  ShootFlame        39  60   5.4 112.5 67.5
441  ShootFlame        39  60   5.4 101.5 78.5
444  ShootFlame        39  60   5.4 90.5 89.5
447  ShootFlame        39  60   5.4 79.5 100.5
450  ShootFlame        39  60   5.4 68.5 111.5
453  ShootFlame        39  60   5.4 57.5 122.5
456  ShootFlame        39  60   5.4 46.5 133.5
459  ShootFlame        39  60   5.4 35.5 144.5
462  ShootFlame        39  60   5.4 24.5 155.5
465  ShootFlame        39  60   5.4 13.5 166.5
468  ShootFlame        39  60   5.4 2.5 177.5
471  ShootFlame        39  60   5.4 -8.5 188.5
474  ShootFlame        39  60   5.4 -19.5 199.5
477  ShootFlame        39  60   5.4 -30.5 210.5
480  ShootFlame        39  60   5.4 -41.5 221.5
483  ShootFlame        39  60   5.4 -52.5 232.5
486  ShootFlame        39  60   5.4 -63.5 243.5
489  ShootFlame        39  60   5.4 -74.5 254.5
492  ShootFlame        39  60   5.4 -85.5 265.5
495  ShootFlame        39  60   5.4 -96.5 276.5
498  ShootFlame        39  60   5.4 -107.5 287.5
501  ShootFlame        39  60   5.4 -118.5 298.5
504  ShootFlame        39  60   5.4 -129.5 309.5
507  ShootFlame        39  60   5.4 -140.5 320.5
510  ShootFlame        39  60   5.4 -151.5 331.5
513  ShootFlame        39  60   5.4 -162.5 342.5
516  ShootFlame        39  60   5.4 -173.5 353.5
519  ShootFlame        39  60   5.4 -184.5 364.5
522  ShootFlame        39  60   5.4 -195.5 375.5
525  ShootFlame        39  60   5.4 -206.5 386.5
528  ShootFlame        39  60   5.4 -217.5 397.5
531  ShootFlame        39  60   5.4 -228.5 408.5
534  ShootFlame        39  60   5.4 -239.5 419.5
537  ShootFlame        39  60   5.4 -250.5 430.5
540  ShootFlame        39  60   5.4 -261.5 441.5
543  ShootFlame        39  60   5.4 -272.5 452.5
546  ShootFlame        39  60   5.4 -283.5 463.5
549  ShootFlame        39  60   5.4 -294.5 474.5
552  ShootFlame        39  60   5.4 -305.5 485.5
555  ShootFlame        39  60   5.4 -316.5 496.5
558  ShootFlame        39  60   5.4 -327.5 507.5
561  ShootFlame        39  60   5.4 -338.5 518.5
564  ShootFlame        39  60   5.4 -349.5 529.5
567  ShootFlame        39  60   5.4 -360.5 540.5
570  ShootFlame        39  60   5.4 -371.5 551.5
573  ShootFlame        39  60   5.4 -382.5 562.5
576  ShootFlame        39  60   5.4 -393.5 573.5
579  ShootFlame        39  60   5.4 -404.5 584.5
582  ShootFlame        39  60   5.4 -415.5 595.5
585  ShootFlame        39  60   5.4 -426.5 606.5
588  ShootFlame        39  60   5.4 -437.5 617.5
591  ShootFlame        39  60   5.4 -448.5 628.5
594  ShootFlame        39  60   5.4 -459.5 639.5
597  ShootFlame        39  60   5.4 -470.5 650.5
600  ShootFlame        39  60   5.4 -481.5 661.5
603  ShootFlame        39  60   5.4 -492.5 672.5
606  ShootFlame        39  60   5.4 -503.5 683.5
609  ShootFlame        39  60   5.4 -514.5 694.5
612  ShootFlame        39  60   5.4 -525.5 705.5
615  ShootFlame        39  60   5.4 -536.5 716.5
618  ShootFlame        39  60   5.4 -547.5 727.5
621  ShootFlame        39  60   5.4 -558.5 738.5
624  ShootFlame        39  60   5.4 -569.5 749.5
627  ShootFlame        39  60   5.4 -580.5 760.5
630  ShootFlame        39  60   5.4 -591.5 771.5
633  ShootFlame        39  60   5.4 -602.5 782.5
636  ShootFlame        39  60   5.4 -613.5 793.5
639  ShootFlame        39  60   5.4 -624.5 804.5
642  ShootFlame        39  60   5.4 -635.5 815.5
645  ShootFlame        39  60   5.4 -646.5 826.5
648  ShootFlame        39  60   5.4 -657.5 837.5
651  ShootFlame        39  60   5.4 -668.5 848.5
654  ShootFlame        39  60   5.4 -679.5 859.5
657  ShootFlame        39  60   5.4 -690.5 870.5
660  ShootFlame        39  60   5.4 -701.5 881.5
663  ShootFlame        39  60   5.4 -712.5 892.5
666  ShootFlame        39  60   5.4 -723.5 903.5
669  ShootFlame        39  60   5.4 -734.5 914.5
672  ShootFlame        39  60   5.4 -745.5 925.5
675  ShootFlame        39  60   5.4 -756.5 936.5
678  ShootFlame        39  60   5.4 -767.5 947.5
681  ShootFlame        39  60   5.4 -778.5 958.5
684  ShootFlame        39  60   5.4 -789.5 969.5
687  ShootFlame        39  60   5.4 -800.5 980.5
690  ShootFlame        39  60   5.4 -811.5 991.5
693  ShootFlame        39  60   5.4 -822.5 1002.5
696  ShootFlame        39  60   5.4 -833.5 1013.5
699  ShootFlame        39  60   5.4 -844.5 1024.5
702  ShootFlame        39  60   5.4 -855.5 1035.5
705  ShootFlame        39  60   5.4 -866.5 1046.5
708  ShootFlame        39  60   5.4 -877.5 1057.5
711  ShootFlame        39  60   5.4 -888.5 1068.5
714  ShootFlame        39  60   5.4 -899.5 1079.5
717  ShootFlame        39  60   5.4 -910.5 1090.5
720  ShootFlame        39  60   5.4 -921.5 1101.5
723  ShootFlame        39  60   5.4 -932.5 1112.5
726  ShootFlame        39  60   5.4 -943.5 1123.5
729  ShootFlame        39  60   5.4 -954.5 1134.5
732  ShootFlame        39  60   5.4 -965.5 1145.5
735  ShootFlame        39  60   5.4 -976.5 1156.5
738  ShootFlame        39  60   5.4 -987.5 1167.5
741  ShootFlame        39  60   5.4 -998.5 1178.5
744  ShootFlame        39  60   5.4 -1009.5 1189.5
747  ShootFlame        39  60   5.4 -1020.5 1200.5
750  ShootFlame        39  60   5.4 -1031.5 1211.5
753  ShootFlame        39  60   5.4 -1042.5 1222.5
756  ShootFlame        39  60   5.4 -1053.5 1233.5
759  ShootFlame        39  60   5.4 -1064.5 1244.5
762  ShootFlame        39  60   5.4 -1075.5 1255.5
765  ShootFlame        39  60   5.4 -1086.5 1266.5
768  ShootFlame        39  60   5.4 -1097.5 1277.5
771  ShootFlame        39  60   5.4 -1108.5 1288.5
774  ShootFlame        39  60   5.4 -1119.5 1299.5
777  ShootFlame        39  60   5.4 -1130.5 1310.5
780  ShootFlame        39  60   5.4 -1141.5 1321.5
783  ShootFlame        39  60   5.4 -1152.5 1332.5
786  ShootFlame        39  60   5.4 -1163.5 1343.5
789  ShootFlame        39  60   5.4 -1174.5 1354.5
792  ShootFlame        39  60   5.4 -1185.5 1365.5
795  ShootFlame        39  60   5.4 -1196.5 1376.5
420  ShootFlame        39  60   5.2 177.0 3.0
423  ShootFlame        39  60   5.2 166.0 14.0
426  ShootFlame        39  60   5.2 155.0 25.0
429  ShootFlame        39  60   5.2 144.0 36.0
432  ShootFlame        39  60   5.2 133.0 47.0
435  ShootFlame        39  60   5.2 122.0 58.0
438  ShootFlame        39  60   5.2 111.0 69.0
441  ShootFlame        39  60   5.2 100.0 80.0
444  ShootFlame        39  60   5.2 89.0 91.0
447  ShootFlame        39  60   5.2 78.0 102.0
450  ShootFlame        39  60   5.2 67.0 113.0
453  ShootFlame        39  60   5.2 56.0 124.0
456  ShootFlame        39  60   5.2 45.0 135.0
459  ShootFlame        39  60   5.2 34.0 146.0
462  ShootFlame        39  60   5.2 23.0 157.0
465  ShootFlame        39  60   5.2 12.0 168.0
468  ShootFlame        39  60   5.2 1.0 179.0
471  ShootFlame        39  60   5.2 -10.0 190.0
474  ShootFlame        39  60   5.2 -21.0 201.0
477  ShootFlame        39  60   5.2 -32.0 212.0
480  ShootFlame        39  60   5.2 -43.0 223.0
483  ShootFlame        39  60   5.2 -54.0 234.0
486  ShootFlame        39  60   5.2 -65.0 245.0
489  ShootFlame        39  60   5.2 -76.0 256.0
492  ShootFlame        39  60   5.2 -87.0 267.0
495  ShootFlame        39  60   5.2 -98.0 278.0
498  ShootFlame        39  60   5.2 -109.0 289.0
501  ShootFlame        39  60   5.2 -120.0 300.0
504  ShootFlame        39  60   5.2 -131.0 311.0
507  ShootFlame        39  60   5.2 -142.0 322.0
510  ShootFlame        39  60   5.2 -153.0 333.0
513  ShootFlame        39  60   5.2 -164.0 344.0
516  ShootFlame        39  60   5.2 -175.0 355.0
519  ShootFlame        39  60   5.2 -186.0 366.0
522  ShootFlame        39  60   5.2 -197.0 377.0
525  ShootFlame        39  60   5.2 -208.0 388.0
528  ShootFlame        39  60   5.2 -219.0 399.0
531  ShootFlame        39  60   5.2 -230.0 410.0
534  ShootFlame        39  60   5.2 -241.0 421.0
537  ShootFlame        39  60   5.2 -252.0 432.0
540  ShootFlame        39  60   5.2 -263.0 443.0
543  ShootFlame        39  60   5.2 -274.0 454.0
546  ShootFlame        39  60   5.2 -285.0 465.0
549  ShootFlame        39  60   5.2 -296.0 476.0
552  ShootFlame        39  60   5.2 -307.0 487.0
555  ShootFlame        39  60   5.2 -318.0 498.0
558  ShootFlame        39  60   5.2 -329.0 509.0
561  ShootFlame        39  60   5.2 -340.0 520.0
564  ShootFlame        39  60   5.2 -351.0 531.0
567  ShootFlame        39  60   5.2 -362.0 542.0
570  ShootFlame        39  60   5.2 -373.0 553.0
573  ShootFlame        39  60   5.2 -384.0 564.0
576  ShootFlame        39  60   5.2 -395.0 575.0
579  ShootFlame        39  60   5.2 -406.0 586.0
582  ShootFlame        39  60   5.2 -417.0 597.0
585  ShootFlame        39  60   5.2 -428.0 608.0
588  ShootFlame        39  60   5.2 -439.0 619.0
591  ShootFlame        39  60   5.2 -450.0 630.0
594  ShootFlame        39  60   5.2 -461.0 641.0
597  ShootFlame        39  60   5.2 -472.0 652.0
600  ShootFlame        39  60   5.2 -483.0 663.0
603  ShootFlame        39  60   5.2 -494.0 674.0
606  ShootFlame        39  60   5.2 -505.0 685.0
609  ShootFlame        39  60   5.2 -516.0 696.0
612  ShootFlame        39  60   5.2 -527.0 707.0
615  ShootFlame        39  60   5.2 -538.0 718.0
618  ShootFlame        39  60   5.2 -549.0 729.0
621  ShootFlame        39  60   5.2 -560.0 740.0
624  ShootFlame        39  60   5.2 -571.0 751.0
627  ShootFlame        39  60   5.2 -582.0 762.0
630  ShootFlame        39  60   5.2 -593.0 773.0
633  ShootFlame        39  60   5.2 -604.0 784.0
636  ShootFlame        39  60   5.2 -615.0 795.0
639  ShootFlame        39  60   5.2 -626.0 806.0
642  ShootFlame        39  60   5.2 -637.0 817.0
645  ShootFlame        39  60   5.2 -648.0 828.0
648  ShootFlame        39  60   5.2 -659.0 839.0
651  ShootFlame        39  60   5.2 -670.0 850.0
654  ShootFlame        39  60   5.2 -681.0 861.0
657  ShootFlame        39  60   5.2 -692.0 872.0
660  ShootFlame        39  60   5.2 -703.0 883.0
663  ShootFlame        39  60   5.2 -714.0 894.0
666  ShootFlame        39  60   5.2 -725.0 905.0
669  ShootFlame        39  60   5.2 -736.0 916.0
672  ShootFlame        39  60   5.2 -747.0 927.0
675  ShootFlame        39  60   5.2 -758.0 938.0
678  ShootFlame        39  60   5.2 -769.0 949.0
681  ShootFlame        39  60   5.2 -780.0 960.0
684  ShootFlame        39  60   5.2 -791.0 971.0
687  ShootFlame        39  60   5.2 -802.0 982.0
690  ShootFlame        39  60   5.2 -813.0 993.0
693  ShootFlame        39  60   5.2 -824.0 1004.0
696  ShootFlame        39  60   5.2 -835.0 1015.0
699  ShootFlame        39  60   5.2 -846.0 1026.0
702  ShootFlame        39  60   5.2 -857.0 1037.0
705  ShootFlame        39  60   5.2 -868.0 1048.0
708  ShootFlame        39  60   5.2 -879.0 1059.0
711  ShootFlame        39  60   5.2 -890.0 1070.0
714  ShootFlame        39  60   5.2 -901.0 1081.0
717  ShootFlame        39  60   5.2 -912.0 1092.0
720  ShootFlame        39  60   5.2 -923.0 1103.0
723  ShootFlame        39  60   5.2 -934.0 1114.0
726  ShootFlame        39  60   5.2 -945.0 1125.0
729  ShootFlame        39  60   5.2 -956.0 1136.0
732  ShootFlame        39  60   5.2 -967.0 1147.0
735  ShootFlame        39  60   5.2 -978.0 1158.0
738  ShootFlame        39  60   5.2 -989.0 1169.0
741  ShootFlame        39  60   5.2 -1000.0 1180.0
744  ShootFlame        39  60   5.2 -1011.0 1191.0
747  ShootFlame        39  60   5.2 -1022.0 1202.0
750  ShootFlame        39  60   5.2 -1033.0 1213.0
753  ShootFlame        39  60   5.2 -1044.0 1224.0
756  ShootFlame        39  60   5.2 -1055.0 1235.0
759  ShootFlame        39  60   5.2 -1066.0 1246.0
762  ShootFlame        39  60   5.2 -1077.0 1257.0
765  ShootFlame        39  60   5.2 -1088.0 1268.0
768  ShootFlame        39  60   5.2 -1099.0 1279.0
771  ShootFlame        39  60   5.2 -1110.0 1290.0
774  ShootFlame        39  60   5.2 -1121.0 1301.0
777  ShootFlame        39  60   5.2 -1132.0 1312.0
780  ShootFlame        39  60   5.2 -1143.0 1323.0
783  ShootFlame        39  60   5.2 -1154.0 1334.0
786  ShootFlame        39  60   5.2 -1165.0 1345.0
789  ShootFlame        39  60   5.2 -1176.0 1356.0
792  ShootFlame        39  60   5.2 -1187.0 1367.0
795  ShootFlame        39  60   5.2 -1198.0 1378.0
420  ShootFlame        39  60   5.0 175.5 4.5
423  ShootFlame        39  60   5.0 164.5 15.5
426  ShootFlame        39  60   5.0 153.5 26.5
429  ShootFlame        39  60   5.0 142.5 37.5
432  ShootFlame        39  60   5.0 131.5 48.5
435  ShootFlame        39  60   5.0 120.5 59.5
438  ShootFlame        39  60   5.0 109.5 70.5
441  ShootFlame        39  60   5.0 98.5 81.5
444  ShootFlame        39  60   5.0 87.5 92.5
447  ShootFlame        39  60   5.0 76.5 103.5
450  ShootFlame        39  60   5.0 65.5 114.5
453  ShootFlame        39  60   5.0 54.5 125.5
456  ShootFlame        39  60   5.0 43.5 136.5
459  ShootFlame        39  60   5.0 32.5 147.5
462  ShootFlame        39  60   5.0 21.5 158.5
465  ShootFlame        39  60   5.0 10.5 169.5
468  ShootFlame        39  60   5.0 -0.5 180.5
471  ShootFlame        39  60   5.0 -11.5 191.5
474  ShootFlame        39  60   5.0 -22.5 202.5
477  ShootFlame        39  60   5.0 -33.5 213.5
480  ShootFlame        39  60   5.0 -44.5 224.5
483  ShootFlame        39  60   5.0 -55.5 235.5
486  ShootFlame        39  60   5.0 -66.5 246.5
489  ShootFlame        39  60   5.0 -77.5 257.5
492  ShootFlame        39  60   5.0 -88.5 268.5
495  ShootFlame        39  60   5.0 -99.5 279.5
498  ShootFlame        39  60   5.0 -110.5 290.5
501  ShootFlame        39  60   5.0 -121.5 301.5
504  ShootFlame        39  60   5.0 -132.5 312.5
507  ShootFlame        39  60   5.0 -143.5 323.5
510  ShootFlame        39  60   5.0 -154.5 334.5
513  ShootFlame        39  60   5.0 -165.5 345.5
516  ShootFlame        39  60   5.0 -176.5 356.5
519  ShootFlame        39  60   5.0 -187.5 367.5
522  ShootFlame        39  60   5.0 -198.5 378.5
525  ShootFlame        39  60   5.0 -209.5 389.5
528  ShootFlame        39  60   5.0 -220.5 400.5
531  ShootFlame        39  60   5.0 -231.5 411.5
534  ShootFlame        39  60   5.0 -242.5 422.5
537  ShootFlame        39  60   5.0 -253.5 433.5
540  ShootFlame        39  60   5.0 -264.5 444.5
543  ShootFlame        39  60   5.0 -275.5 455.5
546  ShootFlame        39  60   5.0 -286.5 466.5
549  ShootFlame        39  60   5.0 -297.5 477.5
552  ShootFlame        39  60   5.0 -308.5 488.5
555  ShootFlame        39  60   5.0 -319.5 499.5
558  ShootFlame        39  60   5.0 -330.5 510.5
561  ShootFlame        39  60   5.0 -341.5 521.5
564  ShootFlame        39  60   5.0 -352.5 532.5
567  ShootFlame        39  60   5.0 -363.5 543.5
570  ShootFlame        39  60   5.0 -374.5 554.5
573  ShootFlame        39  60   5.0 -385.5 565.5
576  ShootFlame        39  60   5.0 -396.5 576.5
579  ShootFlame        39  60   5.0 -407.5 587.5
582  ShootFlame        39  60   5.0 -418.5 598.5
585  ShootFlame        39  60   5.0 -429.5 609.5
588  ShootFlame        39  60   5.0 -440.5 620.5
591  ShootFlame        39  60   5.0 -451.5 631.5
594  ShootFlame        39  60   5.0 -462.5 642.5
597  ShootFlame        39  60   5.0 -473.5 653.5
600  ShootFlame        39  60   5.0 -484.5 664.5
603  ShootFlame        39  60   5.0 -495.5 675.5
606  ShootFlame        39  60   5.0 -506.5 686.5
609  ShootFlame        39  60   5.0 -517.5 697.5
612  ShootFlame        39  60   5.0 -528.5 708.5
615  ShootFlame        39  60   5.0 -539.5 719.5
618  ShootFlame        39  60   5.0 -550.5 730.5
621  ShootFlame        39  60   5.0 -561.5 741.5
624  ShootFlame        39  60   5.0 -572.5 752.5
627  ShootFlame        39  60   5.0 -583.5 763.5
630  ShootFlame        39  60   5.0 -594.5 774.5
633  ShootFlame        39  60   5.0 -605.5 785.5
636  ShootFlame        39  60   5.0 -616.5 796.5
639  ShootFlame        39  60   5.0 -627.5 807.5
642  ShootFlame        39  60   5.0 -638.5 818.5
645  ShootFlame        39  60   5.0 -649.5 829.5
648  ShootFlame        39  60   5.0 -660.5 840.5
651  ShootFlame        39  60   5.0 -671.5 851.5
654  ShootFlame        39  60   5.0 -682.5 862.5
657  ShootFlame        39  60   5.0 -693.5 873.5
660  ShootFlame        39  60   5.0 -704.5 884.5
663  ShootFlame        39  60   5.0 -715.5 895.5
666  ShootFlame        39  60   5.0 -726.5 906.5
669  ShootFlame        39  60   5.0 -737.5 917.5
672  ShootFlame        39  60   5.0 -748.5 928.5
675  ShootFlame        39  60   5.0 -759.5 939.5
678  ShootFlame        39  60   5.0 -770.5 950.5
681  ShootFlame        39  60   5.0 -781.5 961.5
684  ShootFlame        39  60   5.0 -792.5 972.5
687  ShootFlame        39  60   5.0 -803.5 983.5
690  ShootFlame        39  60   5.0 -814.5 994.5
693  ShootFlame        39  60   5.0 -825.5 1005.5
696  ShootFlame        39  60   5.0 -836.5 1016.5
699  ShootFlame        39  60   5.0 -847.5 1027.5
702  ShootFlame        39  60   5.0 -858.5 1038.5
705  ShootFlame        39  60   5.0 -869.5 1049.5
708  ShootFlame        39  60   5.0 -880.5 1060.5
711  ShootFlame        39  60   5.0 -891.5 1071.5
714  ShootFlame        39  60   5.0 -902.5 1082.5
717  ShootFlame        39  60   5.0 -913.5 1093.5
720  ShootFlame        39  60   5.0 -924.5 1104.5
723  ShootFlame        39  60   5.0 -935.5 1115.5
726  ShootFlame        39  60   5.0 -946.5 1126.5
729  ShootFlame        39  60   5.0 -957.5 1137.5
732  ShootFlame        39  60   5.0 -968.5 1148.5
735  ShootFlame        39  60   5.0 -979.5 1159.5
738  ShootFlame        39  60   5.0 -990.5 1170.5
741  ShootFlame        39  60   5.0 -1001.5 1181.5
744  ShootFlame        39  60   5.0 -1012.5 1192.5
747  ShootFlame        39  60   5.0 -1023.5 1203.5
750  ShootFlame        39  60   5.0 -1034.5 1214.5
753  ShootFlame        39  60   5.0 -1045.5 1225.5
756  ShootFlame        39  60   5.0 -1056.5 1236.5
759  ShootFlame        39  60   5.0 -1067.5 1247.5
762  ShootFlame        39  60   5.0 -1078.5 1258.5
765  ShootFlame        39  60   5.0 -1089.5 1269.5
768  ShootFlame        39  60   5.0 -1100.5 1280.5
771  ShootFlame        39  60   5.0 -1111.5 1291.5
774  ShootFlame        39  60   5.0 -1122.5 1302.5
777  ShootFlame        39  60   5.0 -1133.5 1313.5
780  ShootFlame        39  60   5.0 -1144.5 1324.5
783  ShootFlame        39  60   5.0 -1155.5 1335.5
786  ShootFlame        39  60   5.0 -1166.5 1346.5
789  ShootFlame        39  60   5.0 -1177.5 1357.5
792  ShootFlame        39  60   5.0 -1188.5 1368.5
795  ShootFlame        39  60   5.0 -1199.5 1379.5

========Cmd4=============

420  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
435  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
450  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
465  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
480  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
495  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
510  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
525  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
540  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
555  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
570  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
585  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
600  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
615  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
630  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
645  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
660  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
675  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
690  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
705  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
720  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
735  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
750  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
765  ShootToPlayer     39  60  8.0 8.0 14.0 20.0 26.0 32.0 38.0 44.0 50.0 56.0 62.0 68.0 74.0 80.0 86.0 -8.0 -14.0 -20.0 -26.0 -32.0 -38.0 -44.0 -50.0 -56.0 -62.0 -68.0 -74.0 -80.0 -86.0 
420  MakeFlameRand     0   740 5.0 3
420  MakeFlameRand     0   740 7.0 3
420  MakeFlameRand     0   740 9.0 3
435  MakeFlameRand     0   740 5.0 3
435  MakeFlameRand     0   740 7.0 3
435  MakeFlameRand     0   740 9.0 3
450  MakeFlameRand     0   740 5.0 3
450  MakeFlameRand     0   740 7.0 3
450  MakeFlameRand     0   740 9.0 3
465  MakeFlameRand     0   740 5.0 3
465  MakeFlameRand     0   740 7.0 3
465  MakeFlameRand     0   740 9.0 3
480  MakeFlameRand     0   740 5.0 3
480  MakeFlameRand     0   740 7.0 3
480  MakeFlameRand     0   740 9.0 3
495  MakeFlameRand     0   740 5.0 3
495  MakeFlameRand     0   740 7.0 3
495  MakeFlameRand     0   740 9.0 3
510  MakeFlameRand     0   740 5.0 3
510  MakeFlameRand     0   740 7.0 3
510  MakeFlameRand     0   740 9.0 3
525  MakeFlameRand     0   740 5.0 3
525  MakeFlameRand     0   740 7.0 3
525  MakeFlameRand     0   740 9.0 3
540  MakeFlameRand     0   740 5.0 3
540  MakeFlameRand     0   740 7.0 3
540  MakeFlameRand     0   740 9.0 3
555  MakeFlameRand     0   740 5.0 3
555  MakeFlameRand     0   740 7.0 3
555  MakeFlameRand     0   740 9.0 3
570  MakeFlameRand     0   740 5.0 3
570  MakeFlameRand     0   740 7.0 3
570  MakeFlameRand     0   740 9.0 3
585  MakeFlameRand     0   740 5.0 3
585  MakeFlameRand     0   740 7.0 3
585  MakeFlameRand     0   740 9.0 3
600  MakeFlameRand     0   740 5.0 3
600  MakeFlameRand     0   740 7.0 3
600  MakeFlameRand     0   740 9.0 3
615  MakeFlameRand     0   740 5.0 3
615  MakeFlameRand     0   740 7.0 3
615  MakeFlameRand     0   740 9.0 3
630  MakeFlameRand     0   740 5.0 3
630  MakeFlameRand     0   740 7.0 3
630  MakeFlameRand     0   740 9.0 3
645  MakeFlameRand     0   740 5.0 3
645  MakeFlameRand     0   740 7.0 3
645  MakeFlameRand     0   740 9.0 3
660  MakeFlameRand     0   740 5.0 3
660  MakeFlameRand     0   740 7.0 3
660  MakeFlameRand     0   740 9.0 3
675  MakeFlameRand     0   740 5.0 3
675  MakeFlameRand     0   740 7.0 3
675  MakeFlameRand     0   740 9.0 3
690  MakeFlameRand     0   740 5.0 3
690  MakeFlameRand     0   740 7.0 3
690  MakeFlameRand     0   740 9.0 3
705  MakeFlameRand     0   740 5.0 3
705  MakeFlameRand     0   740 7.0 3
705  MakeFlameRand     0   740 9.0 3
720  MakeFlameRand     0   740 5.0 3
720  MakeFlameRand     0   740 7.0 3
720  MakeFlameRand     0   740 9.0 3
735  MakeFlameRand     0   740 5.0 3
735  MakeFlameRand     0   740 7.0 3
735  MakeFlameRand     0   740 9.0 3
750  MakeFlameRand     0   740 5.0 3
750  MakeFlameRand     0   740 7.0 3
750  MakeFlameRand     0   740 9.0 3
765  MakeFlameRand     0   740 5.0 3
765  MakeFlameRand     0   740 7.0 3
765  MakeFlameRand     0   740 9.0 3


=======Cmd5==============
420  Shoot             39  60   4.0 180.0 0.0
420  Shoot             39  60   5.0 180.0 0.0
420  Shoot             39  60   6.0 180.0 0.0
420  Shoot             39  60   7.0 180.0 0.0
420  Shoot             39  60   8.0 180.0 0.0
423  Shoot             39  60   4.0 173.0 7.0
423  Shoot             39  60   5.0 173.0 7.0
423  Shoot             39  60   6.0 173.0 7.0
423  Shoot             39  60   7.0 173.0 7.0
423  Shoot             39  60   8.0 173.0 7.0
426  Shoot             39  60   4.0 166.0 14.0
426  Shoot             39  60   5.0 166.0 14.0
426  Shoot             39  60   6.0 166.0 14.0
426  Shoot             39  60   7.0 166.0 14.0
426  Shoot             39  60   8.0 166.0 14.0
429  Shoot             39  60   4.0 159.0 21.0
429  Shoot             39  60   5.0 159.0 21.0
429  Shoot             39  60   6.0 159.0 21.0
429  Shoot             39  60   7.0 159.0 21.0
429  Shoot             39  60   8.0 159.0 21.0
432  Shoot             39  60   4.0 152.0 28.0
432  Shoot             39  60   5.0 152.0 28.0
432  Shoot             39  60   6.0 152.0 28.0
432  Shoot             39  60   7.0 152.0 28.0
432  Shoot             39  60   8.0 152.0 28.0
435  Shoot             39  60   4.0 145.0 35.0
435  Shoot             39  60   5.0 145.0 35.0
435  Shoot             39  60   6.0 145.0 35.0
435  Shoot             39  60   7.0 145.0 35.0
435  Shoot             39  60   8.0 145.0 35.0
438  Shoot             39  60   4.0 138.0 42.0
438  Shoot             39  60   5.0 138.0 42.0
438  Shoot             39  60   6.0 138.0 42.0
438  Shoot             39  60   7.0 138.0 42.0
438  Shoot             39  60   8.0 138.0 42.0
441  Shoot             39  60   4.0 131.0 49.0
441  Shoot             39  60   5.0 131.0 49.0
441  Shoot             39  60   6.0 131.0 49.0
441  Shoot             39  60   7.0 131.0 49.0
441  Shoot             39  60   8.0 131.0 49.0
444  Shoot             39  60   4.0 124.0 56.0
444  Shoot             39  60   5.0 124.0 56.0
444  Shoot             39  60   6.0 124.0 56.0
444  Shoot             39  60   7.0 124.0 56.0
444  Shoot             39  60   8.0 124.0 56.0
447  Shoot             39  60   4.0 117.0 63.0
447  Shoot             39  60   5.0 117.0 63.0
447  Shoot             39  60   6.0 117.0 63.0
447  Shoot             39  60   7.0 117.0 63.0
447  Shoot             39  60   8.0 117.0 63.0
450  Shoot             39  60   4.0 110.0 70.0
450  Shoot             39  60   5.0 110.0 70.0
450  Shoot             39  60   6.0 110.0 70.0
450  Shoot             39  60   7.0 110.0 70.0
450  Shoot             39  60   8.0 110.0 70.0
453  Shoot             39  60   4.0 103.0 77.0
453  Shoot             39  60   5.0 103.0 77.0
453  Shoot             39  60   6.0 103.0 77.0
453  Shoot             39  60   7.0 103.0 77.0
453  Shoot             39  60   8.0 103.0 77.0
456  Shoot             39  60   4.0 96.0 84.0
456  Shoot             39  60   5.0 96.0 84.0
456  Shoot             39  60   6.0 96.0 84.0
456  Shoot             39  60   7.0 96.0 84.0
456  Shoot             39  60   8.0 96.0 84.0
459  Shoot             39  60   4.0 89.0 91.0
459  Shoot             39  60   5.0 89.0 91.0
459  Shoot             39  60   6.0 89.0 91.0
459  Shoot             39  60   7.0 89.0 91.0
459  Shoot             39  60   8.0 89.0 91.0
462  Shoot             39  60   4.0 82.0 98.0
462  Shoot             39  60   5.0 82.0 98.0
462  Shoot             39  60   6.0 82.0 98.0
462  Shoot             39  60   7.0 82.0 98.0
462  Shoot             39  60   8.0 82.0 98.0
465  Shoot             39  60   4.0 75.0 105.0
465  Shoot             39  60   5.0 75.0 105.0
465  Shoot             39  60   6.0 75.0 105.0
465  Shoot             39  60   7.0 75.0 105.0
465  Shoot             39  60   8.0 75.0 105.0
468  Shoot             39  60   4.0 68.0 112.0
468  Shoot             39  60   5.0 68.0 112.0
468  Shoot             39  60   6.0 68.0 112.0
468  Shoot             39  60   7.0 68.0 112.0
468  Shoot             39  60   8.0 68.0 112.0
471  Shoot             39  60   4.0 61.0 119.0
471  Shoot             39  60   5.0 61.0 119.0
471  Shoot             39  60   6.0 61.0 119.0
471  Shoot             39  60   7.0 61.0 119.0
471  Shoot             39  60   8.0 61.0 119.0
474  Shoot             39  60   4.0 54.0 126.0
474  Shoot             39  60   5.0 54.0 126.0
474  Shoot             39  60   6.0 54.0 126.0
474  Shoot             39  60   7.0 54.0 126.0
474  Shoot             39  60   8.0 54.0 126.0
477  Shoot             39  60   4.0 47.0 133.0
477  Shoot             39  60   5.0 47.0 133.0
477  Shoot             39  60   6.0 47.0 133.0
477  Shoot             39  60   7.0 47.0 133.0
477  Shoot             39  60   8.0 47.0 133.0
480  Shoot             39  60   4.0 40.0 140.0
480  Shoot             39  60   5.0 40.0 140.0
480  Shoot             39  60   6.0 40.0 140.0
480  Shoot             39  60   7.0 40.0 140.0
480  Shoot             39  60   8.0 40.0 140.0
483  Shoot             39  60   4.0 33.0 147.0
483  Shoot             39  60   5.0 33.0 147.0
483  Shoot             39  60   6.0 33.0 147.0
483  Shoot             39  60   7.0 33.0 147.0
483  Shoot             39  60   8.0 33.0 147.0
486  Shoot             39  60   4.0 26.0 154.0
486  Shoot             39  60   5.0 26.0 154.0
486  Shoot             39  60   6.0 26.0 154.0
486  Shoot             39  60   7.0 26.0 154.0
486  Shoot             39  60   8.0 26.0 154.0
489  Shoot             39  60   4.0 19.0 161.0
489  Shoot             39  60   5.0 19.0 161.0
489  Shoot             39  60   6.0 19.0 161.0
489  Shoot             39  60   7.0 19.0 161.0
489  Shoot             39  60   8.0 19.0 161.0
492  Shoot             39  60   4.0 12.0 168.0
492  Shoot             39  60   5.0 12.0 168.0
492  Shoot             39  60   6.0 12.0 168.0
492  Shoot             39  60   7.0 12.0 168.0
492  Shoot             39  60   8.0 12.0 168.0
495  Shoot             39  60   4.0 5.0 175.0
495  Shoot             39  60   5.0 5.0 175.0
495  Shoot             39  60   6.0 5.0 175.0
495  Shoot             39  60   7.0 5.0 175.0
495  Shoot             39  60   8.0 5.0 175.0
498  Shoot             39  60   4.0 -2.0 182.0
498  Shoot             39  60   5.0 -2.0 182.0
498  Shoot             39  60   6.0 -2.0 182.0
498  Shoot             39  60   7.0 -2.0 182.0
498  Shoot             39  60   8.0 -2.0 182.0
501  Shoot             39  60   4.0 -9.0 189.0
501  Shoot             39  60   5.0 -9.0 189.0
501  Shoot             39  60   6.0 -9.0 189.0
501  Shoot             39  60   7.0 -9.0 189.0
501  Shoot             39  60   8.0 -9.0 189.0
504  Shoot             39  60   4.0 -16.0 196.0
504  Shoot             39  60   5.0 -16.0 196.0
504  Shoot             39  60   6.0 -16.0 196.0
504  Shoot             39  60   7.0 -16.0 196.0
504  Shoot             39  60   8.0 -16.0 196.0
507  Shoot             39  60   4.0 -23.0 203.0
507  Shoot             39  60   5.0 -23.0 203.0
507  Shoot             39  60   6.0 -23.0 203.0
507  Shoot             39  60   7.0 -23.0 203.0
507  Shoot             39  60   8.0 -23.0 203.0
510  Shoot             39  60   4.0 -30.0 210.0
510  Shoot             39  60   5.0 -30.0 210.0
510  Shoot             39  60   6.0 -30.0 210.0
510  Shoot             39  60   7.0 -30.0 210.0
510  Shoot             39  60   8.0 -30.0 210.0
513  Shoot             39  60   4.0 -37.0 217.0
513  Shoot             39  60   5.0 -37.0 217.0
513  Shoot             39  60   6.0 -37.0 217.0
513  Shoot             39  60   7.0 -37.0 217.0
513  Shoot             39  60   8.0 -37.0 217.0
516  Shoot             39  60   4.0 -44.0 224.0
516  Shoot             39  60   5.0 -44.0 224.0
516  Shoot             39  60   6.0 -44.0 224.0
516  Shoot             39  60   7.0 -44.0 224.0
516  Shoot             39  60   8.0 -44.0 224.0
519  Shoot             39  60   4.0 -51.0 231.0
519  Shoot             39  60   5.0 -51.0 231.0
519  Shoot             39  60   6.0 -51.0 231.0
519  Shoot             39  60   7.0 -51.0 231.0
519  Shoot             39  60   8.0 -51.0 231.0
522  Shoot             39  60   4.0 -58.0 238.0
522  Shoot             39  60   5.0 -58.0 238.0
522  Shoot             39  60   6.0 -58.0 238.0
522  Shoot             39  60   7.0 -58.0 238.0
522  Shoot             39  60   8.0 -58.0 238.0
525  Shoot             39  60   4.0 -65.0 245.0
525  Shoot             39  60   5.0 -65.0 245.0
525  Shoot             39  60   6.0 -65.0 245.0
525  Shoot             39  60   7.0 -65.0 245.0
525  Shoot             39  60   8.0 -65.0 245.0
528  Shoot             39  60   4.0 -72.0 252.0
528  Shoot             39  60   5.0 -72.0 252.0
528  Shoot             39  60   6.0 -72.0 252.0
528  Shoot             39  60   7.0 -72.0 252.0
528  Shoot             39  60   8.0 -72.0 252.0
531  Shoot             39  60   4.0 -79.0 259.0
531  Shoot             39  60   5.0 -79.0 259.0
531  Shoot             39  60   6.0 -79.0 259.0
531  Shoot             39  60   7.0 -79.0 259.0
531  Shoot             39  60   8.0 -79.0 259.0
534  Shoot             39  60   4.0 -86.0 266.0
534  Shoot             39  60   5.0 -86.0 266.0
534  Shoot             39  60   6.0 -86.0 266.0
534  Shoot             39  60   7.0 -86.0 266.0
534  Shoot             39  60   8.0 -86.0 266.0
537  Shoot             39  60   4.0 -93.0 273.0
537  Shoot             39  60   5.0 -93.0 273.0
537  Shoot             39  60   6.0 -93.0 273.0
537  Shoot             39  60   7.0 -93.0 273.0
537  Shoot             39  60   8.0 -93.0 273.0
540  Shoot             39  60   4.0 -100.0 280.0
540  Shoot             39  60   5.0 -100.0 280.0
540  Shoot             39  60   6.0 -100.0 280.0
540  Shoot             39  60   7.0 -100.0 280.0
540  Shoot             39  60   8.0 -100.0 280.0
543  Shoot             39  60   4.0 -107.0 287.0
543  Shoot             39  60   5.0 -107.0 287.0
543  Shoot             39  60   6.0 -107.0 287.0
543  Shoot             39  60   7.0 -107.0 287.0
543  Shoot             39  60   8.0 -107.0 287.0
546  Shoot             39  60   4.0 -114.0 294.0
546  Shoot             39  60   5.0 -114.0 294.0
546  Shoot             39  60   6.0 -114.0 294.0
546  Shoot             39  60   7.0 -114.0 294.0
546  Shoot             39  60   8.0 -114.0 294.0
549  Shoot             39  60   4.0 -121.0 301.0
549  Shoot             39  60   5.0 -121.0 301.0
549  Shoot             39  60   6.0 -121.0 301.0
549  Shoot             39  60   7.0 -121.0 301.0
549  Shoot             39  60   8.0 -121.0 301.0
552  Shoot             39  60   4.0 -128.0 308.0
552  Shoot             39  60   5.0 -128.0 308.0
552  Shoot             39  60   6.0 -128.0 308.0
552  Shoot             39  60   7.0 -128.0 308.0
552  Shoot             39  60   8.0 -128.0 308.0
555  Shoot             39  60   4.0 -135.0 315.0
555  Shoot             39  60   5.0 -135.0 315.0
555  Shoot             39  60   6.0 -135.0 315.0
555  Shoot             39  60   7.0 -135.0 315.0
555  Shoot             39  60   8.0 -135.0 315.0
558  Shoot             39  60   4.0 -142.0 322.0
558  Shoot             39  60   5.0 -142.0 322.0
558  Shoot             39  60   6.0 -142.0 322.0
558  Shoot             39  60   7.0 -142.0 322.0
558  Shoot             39  60   8.0 -142.0 322.0
561  Shoot             39  60   4.0 -149.0 329.0
561  Shoot             39  60   5.0 -149.0 329.0
561  Shoot             39  60   6.0 -149.0 329.0
561  Shoot             39  60   7.0 -149.0 329.0
561  Shoot             39  60   8.0 -149.0 329.0
564  Shoot             39  60   4.0 -156.0 336.0
564  Shoot             39  60   5.0 -156.0 336.0
564  Shoot             39  60   6.0 -156.0 336.0
564  Shoot             39  60   7.0 -156.0 336.0
564  Shoot             39  60   8.0 -156.0 336.0
567  Shoot             39  60   4.0 -163.0 343.0
567  Shoot             39  60   5.0 -163.0 343.0
567  Shoot             39  60   6.0 -163.0 343.0
567  Shoot             39  60   7.0 -163.0 343.0
567  Shoot             39  60   8.0 -163.0 343.0
570  Shoot             39  60   4.0 -170.0 350.0
570  Shoot             39  60   5.0 -170.0 350.0
570  Shoot             39  60   6.0 -170.0 350.0
570  Shoot             39  60   7.0 -170.0 350.0
570  Shoot             39  60   8.0 -170.0 350.0
573  Shoot             39  60   4.0 -177.0 357.0
573  Shoot             39  60   5.0 -177.0 357.0
573  Shoot             39  60   6.0 -177.0 357.0
573  Shoot             39  60   7.0 -177.0 357.0
573  Shoot             39  60   8.0 -177.0 357.0
576  Shoot             39  60   4.0 -184.0 364.0
576  Shoot             39  60   5.0 -184.0 364.0
576  Shoot             39  60   6.0 -184.0 364.0
576  Shoot             39  60   7.0 -184.0 364.0
576  Shoot             39  60   8.0 -184.0 364.0
579  Shoot             39  60   4.0 -191.0 371.0
579  Shoot             39  60   5.0 -191.0 371.0
579  Shoot             39  60   6.0 -191.0 371.0
579  Shoot             39  60   7.0 -191.0 371.0
579  Shoot             39  60   8.0 -191.0 371.0
582  Shoot             39  60   4.0 -198.0 378.0
582  Shoot             39  60   5.0 -198.0 378.0
582  Shoot             39  60   6.0 -198.0 378.0
582  Shoot             39  60   7.0 -198.0 378.0
582  Shoot             39  60   8.0 -198.0 378.0
585  Shoot             39  60   4.0 -205.0 385.0
585  Shoot             39  60   5.0 -205.0 385.0
585  Shoot             39  60   6.0 -205.0 385.0
585  Shoot             39  60   7.0 -205.0 385.0
585  Shoot             39  60   8.0 -205.0 385.0
588  Shoot             39  60   4.0 -212.0 392.0
588  Shoot             39  60   5.0 -212.0 392.0
588  Shoot             39  60   6.0 -212.0 392.0
588  Shoot             39  60   7.0 -212.0 392.0
588  Shoot             39  60   8.0 -212.0 392.0
591  Shoot             39  60   4.0 -219.0 399.0
591  Shoot             39  60   5.0 -219.0 399.0
591  Shoot             39  60   6.0 -219.0 399.0
591  Shoot             39  60   7.0 -219.0 399.0
591  Shoot             39  60   8.0 -219.0 399.0
594  Shoot             39  60   4.0 -226.0 406.0
594  Shoot             39  60   5.0 -226.0 406.0
594  Shoot             39  60   6.0 -226.0 406.0
594  Shoot             39  60   7.0 -226.0 406.0
594  Shoot             39  60   8.0 -226.0 406.0
597  Shoot             39  60   4.0 -233.0 413.0
597  Shoot             39  60   5.0 -233.0 413.0
597  Shoot             39  60   6.0 -233.0 413.0
597  Shoot             39  60   7.0 -233.0 413.0
597  Shoot             39  60   8.0 -233.0 413.0
600  Shoot             39  60   4.0 -240.0 420.0
600  Shoot             39  60   5.0 -240.0 420.0
600  Shoot             39  60   6.0 -240.0 420.0
600  Shoot             39  60   7.0 -240.0 420.0
600  Shoot             39  60   8.0 -240.0 420.0
603  Shoot             39  60   4.0 -247.0 427.0
603  Shoot             39  60   5.0 -247.0 427.0
603  Shoot             39  60   6.0 -247.0 427.0
603  Shoot             39  60   7.0 -247.0 427.0
603  Shoot             39  60   8.0 -247.0 427.0
606  Shoot             39  60   4.0 -254.0 434.0
606  Shoot             39  60   5.0 -254.0 434.0
606  Shoot             39  60   6.0 -254.0 434.0
606  Shoot             39  60   7.0 -254.0 434.0
606  Shoot             39  60   8.0 -254.0 434.0
609  Shoot             39  60   4.0 -261.0 441.0
609  Shoot             39  60   5.0 -261.0 441.0
609  Shoot             39  60   6.0 -261.0 441.0
609  Shoot             39  60   7.0 -261.0 441.0
609  Shoot             39  60   8.0 -261.0 441.0
612  Shoot             39  60   4.0 -268.0 448.0
612  Shoot             39  60   5.0 -268.0 448.0
612  Shoot             39  60   6.0 -268.0 448.0
612  Shoot             39  60   7.0 -268.0 448.0
612  Shoot             39  60   8.0 -268.0 448.0
615  Shoot             39  60   4.0 -275.0 455.0
615  Shoot             39  60   5.0 -275.0 455.0
615  Shoot             39  60   6.0 -275.0 455.0
615  Shoot             39  60   7.0 -275.0 455.0
615  Shoot             39  60   8.0 -275.0 455.0
618  Shoot             39  60   4.0 -282.0 462.0
618  Shoot             39  60   5.0 -282.0 462.0
618  Shoot             39  60   6.0 -282.0 462.0
618  Shoot             39  60   7.0 -282.0 462.0
618  Shoot             39  60   8.0 -282.0 462.0
621  Shoot             39  60   4.0 -289.0 469.0
621  Shoot             39  60   5.0 -289.0 469.0
621  Shoot             39  60   6.0 -289.0 469.0
621  Shoot             39  60   7.0 -289.0 469.0
621  Shoot             39  60   8.0 -289.0 469.0
624  Shoot             39  60   4.0 -296.0 476.0
624  Shoot             39  60   5.0 -296.0 476.0
624  Shoot             39  60   6.0 -296.0 476.0
624  Shoot             39  60   7.0 -296.0 476.0
624  Shoot             39  60   8.0 -296.0 476.0
627  Shoot             39  60   4.0 -303.0 483.0
627  Shoot             39  60   5.0 -303.0 483.0
627  Shoot             39  60   6.0 -303.0 483.0
627  Shoot             39  60   7.0 -303.0 483.0
627  Shoot             39  60   8.0 -303.0 483.0
630  Shoot             39  60   4.0 -310.0 490.0
630  Shoot             39  60   5.0 -310.0 490.0
630  Shoot             39  60   6.0 -310.0 490.0
630  Shoot             39  60   7.0 -310.0 490.0
630  Shoot             39  60   8.0 -310.0 490.0
633  Shoot             39  60   4.0 -317.0 497.0
633  Shoot             39  60   5.0 -317.0 497.0
633  Shoot             39  60   6.0 -317.0 497.0
633  Shoot             39  60   7.0 -317.0 497.0
633  Shoot             39  60   8.0 -317.0 497.0
636  Shoot             39  60   4.0 -324.0 504.0
636  Shoot             39  60   5.0 -324.0 504.0
636  Shoot             39  60   6.0 -324.0 504.0
636  Shoot             39  60   7.0 -324.0 504.0
636  Shoot             39  60   8.0 -324.0 504.0
639  Shoot             39  60   4.0 -331.0 511.0
639  Shoot             39  60   5.0 -331.0 511.0
639  Shoot             39  60   6.0 -331.0 511.0
639  Shoot             39  60   7.0 -331.0 511.0
639  Shoot             39  60   8.0 -331.0 511.0
642  Shoot             39  60   4.0 -338.0 518.0
642  Shoot             39  60   5.0 -338.0 518.0
642  Shoot             39  60   6.0 -338.0 518.0
642  Shoot             39  60   7.0 -338.0 518.0
642  Shoot             39  60   8.0 -338.0 518.0
645  Shoot             39  60   4.0 -345.0 525.0
645  Shoot             39  60   5.0 -345.0 525.0
645  Shoot             39  60   6.0 -345.0 525.0
645  Shoot             39  60   7.0 -345.0 525.0
645  Shoot             39  60   8.0 -345.0 525.0
648  Shoot             39  60   4.0 -352.0 532.0
648  Shoot             39  60   5.0 -352.0 532.0
648  Shoot             39  60   6.0 -352.0 532.0
648  Shoot             39  60   7.0 -352.0 532.0
648  Shoot             39  60   8.0 -352.0 532.0
651  Shoot             39  60   4.0 -359.0 539.0
651  Shoot             39  60   5.0 -359.0 539.0
651  Shoot             39  60   6.0 -359.0 539.0
651  Shoot             39  60   7.0 -359.0 539.0
651  Shoot             39  60   8.0 -359.0 539.0
654  Shoot             39  60   4.0 -366.0 546.0
654  Shoot             39  60   5.0 -366.0 546.0
654  Shoot             39  60   6.0 -366.0 546.0
654  Shoot             39  60   7.0 -366.0 546.0
654  Shoot             39  60   8.0 -366.0 546.0
657  Shoot             39  60   4.0 -373.0 553.0
657  Shoot             39  60   5.0 -373.0 553.0
657  Shoot             39  60   6.0 -373.0 553.0
657  Shoot             39  60   7.0 -373.0 553.0
657  Shoot             39  60   8.0 -373.0 553.0
660  Shoot             39  60   4.0 -380.0 560.0
660  Shoot             39  60   5.0 -380.0 560.0
660  Shoot             39  60   6.0 -380.0 560.0
660  Shoot             39  60   7.0 -380.0 560.0
660  Shoot             39  60   8.0 -380.0 560.0
663  Shoot             39  60   4.0 -387.0 567.0
663  Shoot             39  60   5.0 -387.0 567.0
663  Shoot             39  60   6.0 -387.0 567.0
663  Shoot             39  60   7.0 -387.0 567.0
663  Shoot             39  60   8.0 -387.0 567.0
666  Shoot             39  60   4.0 -394.0 574.0
666  Shoot             39  60   5.0 -394.0 574.0
666  Shoot             39  60   6.0 -394.0 574.0
666  Shoot             39  60   7.0 -394.0 574.0
666  Shoot             39  60   8.0 -394.0 574.0
669  Shoot             39  60   4.0 -401.0 581.0
669  Shoot             39  60   5.0 -401.0 581.0
669  Shoot             39  60   6.0 -401.0 581.0
669  Shoot             39  60   7.0 -401.0 581.0
669  Shoot             39  60   8.0 -401.0 581.0
672  Shoot             39  60   4.0 -408.0 588.0
672  Shoot             39  60   5.0 -408.0 588.0
672  Shoot             39  60   6.0 -408.0 588.0
672  Shoot             39  60   7.0 -408.0 588.0
672  Shoot             39  60   8.0 -408.0 588.0
675  Shoot             39  60   4.0 -415.0 595.0
675  Shoot             39  60   5.0 -415.0 595.0
675  Shoot             39  60   6.0 -415.0 595.0
675  Shoot             39  60   7.0 -415.0 595.0
675  Shoot             39  60   8.0 -415.0 595.0
678  Shoot             39  60   4.0 -422.0 602.0
678  Shoot             39  60   5.0 -422.0 602.0
678  Shoot             39  60   6.0 -422.0 602.0
678  Shoot             39  60   7.0 -422.0 602.0
678  Shoot             39  60   8.0 -422.0 602.0
681  Shoot             39  60   4.0 -429.0 609.0
681  Shoot             39  60   5.0 -429.0 609.0
681  Shoot             39  60   6.0 -429.0 609.0
681  Shoot             39  60   7.0 -429.0 609.0
681  Shoot             39  60   8.0 -429.0 609.0
684  Shoot             39  60   4.0 -436.0 616.0
684  Shoot             39  60   5.0 -436.0 616.0
684  Shoot             39  60   6.0 -436.0 616.0
684  Shoot             39  60   7.0 -436.0 616.0
684  Shoot             39  60   8.0 -436.0 616.0
687  Shoot             39  60   4.0 -443.0 623.0
687  Shoot             39  60   5.0 -443.0 623.0
687  Shoot             39  60   6.0 -443.0 623.0
687  Shoot             39  60   7.0 -443.0 623.0
687  Shoot             39  60   8.0 -443.0 623.0
690  Shoot             39  60   4.0 -450.0 630.0
690  Shoot             39  60   5.0 -450.0 630.0
690  Shoot             39  60   6.0 -450.0 630.0
690  Shoot             39  60   7.0 -450.0 630.0
690  Shoot             39  60   8.0 -450.0 630.0
693  Shoot             39  60   4.0 -457.0 637.0
693  Shoot             39  60   5.0 -457.0 637.0
693  Shoot             39  60   6.0 -457.0 637.0
693  Shoot             39  60   7.0 -457.0 637.0
693  Shoot             39  60   8.0 -457.0 637.0
696  Shoot             39  60   4.0 -464.0 644.0
696  Shoot             39  60   5.0 -464.0 644.0
696  Shoot             39  60   6.0 -464.0 644.0
696  Shoot             39  60   7.0 -464.0 644.0
696  Shoot             39  60   8.0 -464.0 644.0
699  Shoot             39  60   4.0 -471.0 651.0
699  Shoot             39  60   5.0 -471.0 651.0
699  Shoot             39  60   6.0 -471.0 651.0
699  Shoot             39  60   7.0 -471.0 651.0
699  Shoot             39  60   8.0 -471.0 651.0
702  Shoot             39  60   4.0 -478.0 658.0
702  Shoot             39  60   5.0 -478.0 658.0
702  Shoot             39  60   6.0 -478.0 658.0
702  Shoot             39  60   7.0 -478.0 658.0
702  Shoot             39  60   8.0 -478.0 658.0
705  Shoot             39  60   4.0 -485.0 665.0
705  Shoot             39  60   5.0 -485.0 665.0
705  Shoot             39  60   6.0 -485.0 665.0
705  Shoot             39  60   7.0 -485.0 665.0
705  Shoot             39  60   8.0 -485.0 665.0
708  Shoot             39  60   4.0 -492.0 672.0
708  Shoot             39  60   5.0 -492.0 672.0
708  Shoot             39  60   6.0 -492.0 672.0
708  Shoot             39  60   7.0 -492.0 672.0
708  Shoot             39  60   8.0 -492.0 672.0
711  Shoot             39  60   4.0 -499.0 679.0
711  Shoot             39  60   5.0 -499.0 679.0
711  Shoot             39  60   6.0 -499.0 679.0
711  Shoot             39  60   7.0 -499.0 679.0
711  Shoot             39  60   8.0 -499.0 679.0
714  Shoot             39  60   4.0 -506.0 686.0
714  Shoot             39  60   5.0 -506.0 686.0
714  Shoot             39  60   6.0 -506.0 686.0
714  Shoot             39  60   7.0 -506.0 686.0
714  Shoot             39  60   8.0 -506.0 686.0
717  Shoot             39  60   4.0 -513.0 693.0
717  Shoot             39  60   5.0 -513.0 693.0
717  Shoot             39  60   6.0 -513.0 693.0
717  Shoot             39  60   7.0 -513.0 693.0
717  Shoot             39  60   8.0 -513.0 693.0
720  Shoot             39  60   4.0 -520.0 700.0
720  Shoot             39  60   5.0 -520.0 700.0
720  Shoot             39  60   6.0 -520.0 700.0
720  Shoot             39  60   7.0 -520.0 700.0
720  Shoot             39  60   8.0 -520.0 700.0
723  Shoot             39  60   4.0 -527.0 707.0
723  Shoot             39  60   5.0 -527.0 707.0
723  Shoot             39  60   6.0 -527.0 707.0
723  Shoot             39  60   7.0 -527.0 707.0
723  Shoot             39  60   8.0 -527.0 707.0
726  Shoot             39  60   4.0 -534.0 714.0
726  Shoot             39  60   5.0 -534.0 714.0
726  Shoot             39  60   6.0 -534.0 714.0
726  Shoot             39  60   7.0 -534.0 714.0
726  Shoot             39  60   8.0 -534.0 714.0
729  Shoot             39  60   4.0 -541.0 721.0
729  Shoot             39  60   5.0 -541.0 721.0
729  Shoot             39  60   6.0 -541.0 721.0
729  Shoot             39  60   7.0 -541.0 721.0
729  Shoot             39  60   8.0 -541.0 721.0
732  Shoot             39  60   4.0 -548.0 728.0
732  Shoot             39  60   5.0 -548.0 728.0
732  Shoot             39  60   6.0 -548.0 728.0
732  Shoot             39  60   7.0 -548.0 728.0
732  Shoot             39  60   8.0 -548.0 728.0
735  Shoot             39  60   4.0 -555.0 735.0
735  Shoot             39  60   5.0 -555.0 735.0
735  Shoot             39  60   6.0 -555.0 735.0
735  Shoot             39  60   7.0 -555.0 735.0
735  Shoot             39  60   8.0 -555.0 735.0
738  Shoot             39  60   4.0 -562.0 742.0
738  Shoot             39  60   5.0 -562.0 742.0
738  Shoot             39  60   6.0 -562.0 742.0
738  Shoot             39  60   7.0 -562.0 742.0
738  Shoot             39  60   8.0 -562.0 742.0
741  Shoot             39  60   4.0 -569.0 749.0
741  Shoot             39  60   5.0 -569.0 749.0
741  Shoot             39  60   6.0 -569.0 749.0
741  Shoot             39  60   7.0 -569.0 749.0
741  Shoot             39  60   8.0 -569.0 749.0
744  Shoot             39  60   4.0 -576.0 756.0
744  Shoot             39  60   5.0 -576.0 756.0
744  Shoot             39  60   6.0 -576.0 756.0
744  Shoot             39  60   7.0 -576.0 756.0
744  Shoot             39  60   8.0 -576.0 756.0
747  Shoot             39  60   4.0 -583.0 763.0
747  Shoot             39  60   5.0 -583.0 763.0
747  Shoot             39  60   6.0 -583.0 763.0
747  Shoot             39  60   7.0 -583.0 763.0
747  Shoot             39  60   8.0 -583.0 763.0
750  Shoot             39  60   4.0 -590.0 770.0
750  Shoot             39  60   5.0 -590.0 770.0
750  Shoot             39  60   6.0 -590.0 770.0
750  Shoot             39  60   7.0 -590.0 770.0
750  Shoot             39  60   8.0 -590.0 770.0
753  Shoot             39  60   4.0 -597.0 777.0
753  Shoot             39  60   5.0 -597.0 777.0
753  Shoot             39  60   6.0 -597.0 777.0
753  Shoot             39  60   7.0 -597.0 777.0
753  Shoot             39  60   8.0 -597.0 777.0
756  Shoot             39  60   4.0 -604.0 784.0
756  Shoot             39  60   5.0 -604.0 784.0
756  Shoot             39  60   6.0 -604.0 784.0
756  Shoot             39  60   7.0 -604.0 784.0
756  Shoot             39  60   8.0 -604.0 784.0
759  Shoot             39  60   4.0 -611.0 791.0
759  Shoot             39  60   5.0 -611.0 791.0
759  Shoot             39  60   6.0 -611.0 791.0
759  Shoot             39  60   7.0 -611.0 791.0
759  Shoot             39  60   8.0 -611.0 791.0
762  Shoot             39  60   4.0 -618.0 798.0
762  Shoot             39  60   5.0 -618.0 798.0
762  Shoot             39  60   6.0 -618.0 798.0
762  Shoot             39  60   7.0 -618.0 798.0
762  Shoot             39  60   8.0 -618.0 798.0
765  Shoot             39  60   4.0 -625.0 805.0
765  Shoot             39  60   5.0 -625.0 805.0
765  Shoot             39  60   6.0 -625.0 805.0
765  Shoot             39  60   7.0 -625.0 805.0
765  Shoot             39  60   8.0 -625.0 805.0
768  Shoot             39  60   4.0 -632.0 812.0
768  Shoot             39  60   5.0 -632.0 812.0
768  Shoot             39  60   6.0 -632.0 812.0
768  Shoot             39  60   7.0 -632.0 812.0
768  Shoot             39  60   8.0 -632.0 812.0
771  Shoot             39  60   4.0 -639.0 819.0
771  Shoot             39  60   5.0 -639.0 819.0
771  Shoot             39  60   6.0 -639.0 819.0
771  Shoot             39  60   7.0 -639.0 819.0
771  Shoot             39  60   8.0 -639.0 819.0
774  Shoot             39  60   4.0 -646.0 826.0
774  Shoot             39  60   5.0 -646.0 826.0
774  Shoot             39  60   6.0 -646.0 826.0
774  Shoot             39  60   7.0 -646.0 826.0
774  Shoot             39  60   8.0 -646.0 826.0
777  Shoot             39  60   4.0 -653.0 833.0
777  Shoot             39  60   5.0 -653.0 833.0
777  Shoot             39  60   6.0 -653.0 833.0
777  Shoot             39  60   7.0 -653.0 833.0
777  Shoot             39  60   8.0 -653.0 833.0
780  Shoot             39  60   4.0 -660.0 840.0
780  Shoot             39  60   5.0 -660.0 840.0
780  Shoot             39  60   6.0 -660.0 840.0
780  Shoot             39  60   7.0 -660.0 840.0
780  Shoot             39  60   8.0 -660.0 840.0
783  Shoot             39  60   4.0 -667.0 847.0
783  Shoot             39  60   5.0 -667.0 847.0
783  Shoot             39  60   6.0 -667.0 847.0
783  Shoot             39  60   7.0 -667.0 847.0
783  Shoot             39  60   8.0 -667.0 847.0
786  Shoot             39  60   4.0 -674.0 854.0
786  Shoot             39  60   5.0 -674.0 854.0
786  Shoot             39  60   6.0 -674.0 854.0
786  Shoot             39  60   7.0 -674.0 854.0
786  Shoot             39  60   8.0 -674.0 854.0
789  Shoot             39  60   4.0 -681.0 861.0
789  Shoot             39  60   5.0 -681.0 861.0
789  Shoot             39  60   6.0 -681.0 861.0
789  Shoot             39  60   7.0 -681.0 861.0
789  Shoot             39  60   8.0 -681.0 861.0
792  Shoot             39  60   4.0 -688.0 868.0
792  Shoot             39  60   5.0 -688.0 868.0
792  Shoot             39  60   6.0 -688.0 868.0
792  Shoot             39  60   7.0 -688.0 868.0
792  Shoot             39  60   8.0 -688.0 868.0
795  Shoot             39  60   4.0 -695.0 875.0
795  Shoot             39  60   5.0 -695.0 875.0
795  Shoot             39  60   6.0 -695.0 875.0
795  Shoot             39  60   7.0 -695.0 875.0
795  Shoot             39  60   8.0 -695.0 875.0
========Cmd6============
401  SetVelX           0.0
420  ShootFlameRand    39  60   4.0 0 180 6
420  ShootFlameRand    39  60   6.0 0 180 6
420  ShootFlameRand    39  60   8.0 0 180 6
426  ShootFlameRand    39  60   4.0 0 180 6
426  ShootFlameRand    39  60   6.0 0 180 6
426  ShootFlameRand    39  60   8.0 0 180 6
432  ShootFlameRand    39  60   4.0 0 180 6
432  ShootFlameRand    39  60   6.0 0 180 6
432  ShootFlameRand    39  60   8.0 0 180 6
438  ShootFlameRand    39  60   4.0 0 180 6
438  ShootFlameRand    39  60   6.0 0 180 6
438  ShootFlameRand    39  60   8.0 0 180 6
444  ShootFlameRand    39  60   4.0 0 180 6
444  ShootFlameRand    39  60   6.0 0 180 6
444  ShootFlameRand    39  60   8.0 0 180 6
450  ShootFlameRand    39  60   4.0 0 180 6
450  ShootFlameRand    39  60   6.0 0 180 6
450  ShootFlameRand    39  60   8.0 0 180 6
456  ShootFlameRand    39  60   4.0 0 180 6
456  ShootFlameRand    39  60   6.0 0 180 6
456  ShootFlameRand    39  60   8.0 0 180 6
462  ShootFlameRand    39  60   4.0 0 180 6
462  ShootFlameRand    39  60   6.0 0 180 6
462  ShootFlameRand    39  60   8.0 0 180 6
468  ShootFlameRand    39  60   4.0 0 180 6
468  ShootFlameRand    39  60   6.0 0 180 6
468  ShootFlameRand    39  60   8.0 0 180 6
474  ShootFlameRand    39  60   4.0 0 180 6
474  ShootFlameRand    39  60   6.0 0 180 6
474  ShootFlameRand    39  60   8.0 0 180 6
480  ShootFlameRand    39  60   4.0 0 180 6
480  ShootFlameRand    39  60   6.0 0 180 6
480  ShootFlameRand    39  60   8.0 0 180 6
486  ShootFlameRand    39  60   4.0 0 180 6
486  ShootFlameRand    39  60   6.0 0 180 6
486  ShootFlameRand    39  60   8.0 0 180 6
492  ShootFlameRand    39  60   4.0 0 180 6
492  ShootFlameRand    39  60   6.0 0 180 6
492  ShootFlameRand    39  60   8.0 0 180 6
498  ShootFlameRand    39  60   4.0 0 180 6
498  ShootFlameRand    39  60   6.0 0 180 6
498  ShootFlameRand    39  60   8.0 0 180 6
504  ShootFlameRand    39  60   4.0 0 180 6
504  ShootFlameRand    39  60   6.0 0 180 6
504  ShootFlameRand    39  60   8.0 0 180 6
510  ShootFlameRand    39  60   4.0 0 180 6
510  ShootFlameRand    39  60   6.0 0 180 6
510  ShootFlameRand    39  60   8.0 0 180 6
516  ShootFlameRand    39  60   4.0 0 180 6
516  ShootFlameRand    39  60   6.0 0 180 6
516  ShootFlameRand    39  60   8.0 0 180 6
522  ShootFlameRand    39  60   4.0 0 180 6
522  ShootFlameRand    39  60   6.0 0 180 6
522  ShootFlameRand    39  60   8.0 0 180 6
528  ShootFlameRand    39  60   4.0 0 180 6
528  ShootFlameRand    39  60   6.0 0 180 6
528  ShootFlameRand    39  60   8.0 0 180 6
534  ShootFlameRand    39  60   4.0 0 180 6
534  ShootFlameRand    39  60   6.0 0 180 6
534  ShootFlameRand    39  60   8.0 0 180 6
540  ShootFlameRand    39  60   4.0 0 180 6
540  ShootFlameRand    39  60   6.0 0 180 6
540  ShootFlameRand    39  60   8.0 0 180 6
546  ShootFlameRand    39  60   4.0 0 180 6
546  ShootFlameRand    39  60   6.0 0 180 6
546  ShootFlameRand    39  60   8.0 0 180 6
552  ShootFlameRand    39  60   4.0 0 180 6
552  ShootFlameRand    39  60   6.0 0 180 6
552  ShootFlameRand    39  60   8.0 0 180 6
558  ShootFlameRand    39  60   4.0 0 180 6
558  ShootFlameRand    39  60   6.0 0 180 6
558  ShootFlameRand    39  60   8.0 0 180 6
564  ShootFlameRand    39  60   4.0 0 180 6
564  ShootFlameRand    39  60   6.0 0 180 6
564  ShootFlameRand    39  60   8.0 0 180 6
570  ShootFlameRand    39  60   4.0 0 180 6
570  ShootFlameRand    39  60   6.0 0 180 6
570  ShootFlameRand    39  60   8.0 0 180 6
576  ShootFlameRand    39  60   4.0 0 180 6
576  ShootFlameRand    39  60   6.0 0 180 6
576  ShootFlameRand    39  60   8.0 0 180 6
582  ShootFlameRand    39  60   4.0 0 180 6
582  ShootFlameRand    39  60   6.0 0 180 6
582  ShootFlameRand    39  60   8.0 0 180 6
588  ShootFlameRand    39  60   4.0 0 180 6
588  ShootFlameRand    39  60   6.0 0 180 6
588  ShootFlameRand    39  60   8.0 0 180 6
594  ShootFlameRand    39  60   4.0 0 180 6
594  ShootFlameRand    39  60   6.0 0 180 6
594  ShootFlameRand    39  60   8.0 0 180 6
600  ShootFlameRand    39  60   4.0 0 180 6
600  ShootFlameRand    39  60   6.0 0 180 6
600  ShootFlameRand    39  60   8.0 0 180 6
606  ShootFlameRand    39  60   4.0 0 180 6
606  ShootFlameRand    39  60   6.0 0 180 6
606  ShootFlameRand    39  60   8.0 0 180 6
612  ShootFlameRand    39  60   4.0 0 180 6
612  ShootFlameRand    39  60   6.0 0 180 6
612  ShootFlameRand    39  60   8.0 0 180 6
618  ShootFlameRand    39  60   4.0 0 180 6
618  ShootFlameRand    39  60   6.0 0 180 6
618  ShootFlameRand    39  60   8.0 0 180 6
624  ShootFlameRand    39  60   4.0 0 180 6
624  ShootFlameRand    39  60   6.0 0 180 6
624  ShootFlameRand    39  60   8.0 0 180 6
630  ShootFlameRand    39  60   4.0 0 180 6
630  ShootFlameRand    39  60   6.0 0 180 6
630  ShootFlameRand    39  60   8.0 0 180 6
636  ShootFlameRand    39  60   4.0 0 180 6
636  ShootFlameRand    39  60   6.0 0 180 6
636  ShootFlameRand    39  60   8.0 0 180 6
642  ShootFlameRand    39  60   4.0 0 180 6
642  ShootFlameRand    39  60   6.0 0 180 6
642  ShootFlameRand    39  60   8.0 0 180 6
648  ShootFlameRand    39  60   4.0 0 180 6
648  ShootFlameRand    39  60   6.0 0 180 6
648  ShootFlameRand    39  60   8.0 0 180 6
654  ShootFlameRand    39  60   4.0 0 180 6
654  ShootFlameRand    39  60   6.0 0 180 6
654  ShootFlameRand    39  60   8.0 0 180 6
660  ShootFlameRand    39  60   4.0 0 180 6
660  ShootFlameRand    39  60   6.0 0 180 6
660  ShootFlameRand    39  60   8.0 0 180 6
666  ShootFlameRand    39  60   4.0 0 180 6
666  ShootFlameRand    39  60   6.0 0 180 6
666  ShootFlameRand    39  60   8.0 0 180 6
672  ShootFlameRand    39  60   4.0 0 180 6
672  ShootFlameRand    39  60   6.0 0 180 6
672  ShootFlameRand    39  60   8.0 0 180 6
678  ShootFlameRand    39  60   4.0 0 180 6
678  ShootFlameRand    39  60   6.0 0 180 6
678  ShootFlameRand    39  60   8.0 0 180 6
684  ShootFlameRand    39  60   4.0 0 180 6
684  ShootFlameRand    39  60   6.0 0 180 6
684  ShootFlameRand    39  60   8.0 0 180 6
690  ShootFlameRand    39  60   4.0 0 180 6
690  ShootFlameRand    39  60   6.0 0 180 6
690  ShootFlameRand    39  60   8.0 0 180 6
696  ShootFlameRand    39  60   4.0 0 180 6
696  ShootFlameRand    39  60   6.0 0 180 6
696  ShootFlameRand    39  60   8.0 0 180 6
702  ShootFlameRand    39  60   4.0 0 180 6
702  ShootFlameRand    39  60   6.0 0 180 6
702  ShootFlameRand    39  60   8.0 0 180 6
708  ShootFlameRand    39  60   4.0 0 180 6
708  ShootFlameRand    39  60   6.0 0 180 6
708  ShootFlameRand    39  60   8.0 0 180 6
714  ShootFlameRand    39  60   4.0 0 180 6
714  ShootFlameRand    39  60   6.0 0 180 6
714  ShootFlameRand    39  60   8.0 0 180 6
720  ShootFlameRand    39  60   4.0 0 180 6
720  ShootFlameRand    39  60   6.0 0 180 6
720  ShootFlameRand    39  60   8.0 0 180 6
726  ShootFlameRand    39  60   4.0 0 180 6
726  ShootFlameRand    39  60   6.0 0 180 6
726  ShootFlameRand    39  60   8.0 0 180 6
732  ShootFlameRand    39  60   4.0 0 180 6
732  ShootFlameRand    39  60   6.0 0 180 6
732  ShootFlameRand    39  60   8.0 0 180 6
738  ShootFlameRand    39  60   4.0 0 180 6
738  ShootFlameRand    39  60   6.0 0 180 6
738  ShootFlameRand    39  60   8.0 0 180 6
744  ShootFlameRand    39  60   4.0 0 180 6
744  ShootFlameRand    39  60   6.0 0 180 6
744  ShootFlameRand    39  60   8.0 0 180 6
750  ShootFlameRand    39  60   4.0 0 180 6
750  ShootFlameRand    39  60   6.0 0 180 6
750  ShootFlameRand    39  60   8.0 0 180 6
756  ShootFlameRand    39  60   4.0 0 180 6
756  ShootFlameRand    39  60   6.0 0 180 6
756  ShootFlameRand    39  60   8.0 0 180 6
762  ShootFlameRand    39  60   4.0 0 180 6
762  ShootFlameRand    39  60   6.0 0 180 6
762  ShootFlameRand    39  60   8.0 0 180 6
768  ShootFlameRand    39  60   4.0 0 180 6
768  ShootFlameRand    39  60   6.0 0 180 6
768  ShootFlameRand    39  60   8.0 0 180 6
774  ShootFlameRand    39  60   4.0 0 180 6
774  ShootFlameRand    39  60   6.0 0 180 6
774  ShootFlameRand    39  60   8.0 0 180 6


849  SetVelX           8.0
========Cmd7============
420  MakeLaserRand    0  740 12.0 4
426  MakeLaserRand    0  740 12.0 4
432  MakeLaserRand    0  740 12.0 4
438  MakeLaserRand    0  740 12.0 4
444  MakeLaserRand    0  740 12.0 4
450  MakeLaserRand    0  740 12.0 4
456  MakeLaserRand    0  740 12.0 4
462  MakeLaserRand    0  740 12.0 4
468  MakeLaserRand    0  740 12.0 4
474  MakeLaserRand    0  740 12.0 4
480  MakeLaserRand    0  740 12.0 4
486  MakeLaserRand    0  740 12.0 4
492  MakeLaserRand    0  740 12.0 4
498  MakeLaserRand    0  740 12.0 4
504  MakeLaserRand    0  740 12.0 4
510  MakeLaserRand    0  740 12.0 4
516  MakeLaserRand    0  740 12.0 4
522  MakeLaserRand    0  740 12.0 4
528  MakeLaserRand    0  740 12.0 4
534  MakeLaserRand    0  740 12.0 4
540  MakeLaserRand    0  740 12.0 4
546  MakeLaserRand    0  740 12.0 4
552  MakeLaserRand    0  740 12.0 4
558  MakeLaserRand    0  740 12.0 4
564  MakeLaserRand    0  740 12.0 4
570  MakeLaserRand    0  740 12.0 4
576  MakeLaserRand    0  740 12.0 4
582  MakeLaserRand    0  740 12.0 4
588  MakeLaserRand    0  740 12.0 4
594  MakeLaserRand    0  740 12.0 4
600  MakeLaserRand    0  740 12.0 4
606  MakeLaserRand    0  740 12.0 4
612  MakeLaserRand    0  740 12.0 4
618  MakeLaserRand    0  740 12.0 4
624  MakeLaserRand    0  740 12.0 4
630  MakeLaserRand    0  740 12.0 4
636  MakeLaserRand    0  740 12.0 4
642  MakeLaserRand    0  740 12.0 4
648  MakeLaserRand    0  740 12.0 4
654  MakeLaserRand    0  740 12.0 4
660  MakeLaserRand    0  740 12.0 4
666  MakeLaserRand    0  740 12.0 4
672  MakeLaserRand    0  740 12.0 4
678  MakeLaserRand    0  740 12.0 4
684  MakeLaserRand    0  740 12.0 4
690  MakeLaserRand    0  740 12.0 4
696  MakeLaserRand    0  740 12.0 4
702  MakeLaserRand    0  740 12.0 4
708  MakeLaserRand    0  740 12.0 4
714  MakeLaserRand    0  740 12.0 4
720  MakeLaserRand    0  740 12.0 4
726  MakeLaserRand    0  740 12.0 4
732  MakeLaserRand    0  740 12.0 4
738  MakeLaserRand    0  740 12.0 4
744  MakeLaserRand    0  740 12.0 4
750  MakeLaserRand    0  740 12.0 4
756  MakeLaserRand    0  740 12.0 4
762  MakeLaserRand    0  740 12.0 4
768  MakeLaserRand    0  740 12.0 4
774  MakeLaserRand    0  740 12.0 4
=======Cmd8=============
870  SetVelX          0.0
998  SetVelX          2.0
1000 ShootFlameRand    39  60  12.0 0 18 3
1000 ShootFlameRand    39  60  12.0 36 18 3
1000 ShootFlameRand    39  60  12.0 72 18 3
1000 ShootFlameRand    39  60  12.0 108 18 3
1000 ShootFlameRand    39  60  12.0 144 18 3
1000 ShootFlameRand    39  60  12.0 180 18 3
1000 ShootFlameRand    39  60  12.0 216 18 3
1000 ShootFlameRand    39  60  12.0 252 18 3
1000 ShootFlameRand    39  60  12.0 288 18 3
1000 ShootFlameRand    39  60  12.0 324 18 3

========================
```

`Source Code/Data/README.txt`:

```txt
文本编辑器  V1.2
作者       X_Jun

文本编辑器的初衷是为了简化游戏关卡的设计，将其从程序代码中分离。只要稍加学习，
并理解其中的参数设置，你也可以创建属于自己的关卡。


游戏的运行依赖三个部分的文档组成：
EnemyInfo.txt     存储了所有飞机的属性
EnemyLevelX.txt   X指的是关卡号，用于设置该关卡所有飞机的AI
StageX.txt        X指的是关卡号，用于设置该关卡所有飞机的布置顺序
注意：1.关卡的编写必须是连续的，例如要创建第5关得确保前4关的文件都要存在
      2.游戏限定在60帧。
      3.文件名不能是EnemyLevel01.txt，必须为EnemyLevel1.txt

************************* EnemyInfo.txt文件编写 *******************************
每个飞机的编写参数和顺序要求如下：
enemy_plane1                        注释：第一行描述飞机类型，不会被读入
typeID:     1                       注释：该类型飞机占用的ID
HP:         5                       注释：血量，1发普通子弹1伤害，1发追踪弹5伤害
score:      640                     注释：初始得分
penalty:    -2                      注释：每一帧的惩罚分
minscore:   200                     注释：最低保证得分
velX:       0.0                     注释：初始横向速度（向右）
velY:       10.0                    注释：初始纵向速度（向下）
posY:       -200.0                  注释：初始纵向位置
width:      100                     注释：纹理宽度/飞机宽度
height:     100                     注释：纹理高度/飞机高度
follow:     0                       注释：0表示不跟随玩家，1表示跟随
inside:     0                       注释：0表示默认行动下会飞出界面，1表示不会飞出界面
isRotating: 0                       注释：飞机时候会旋转
deathsnd:   BLAST1                  注释：指定死亡音效，可选范围BLAST1到BLAST4
texName:    enemy_plane1            注释：指定使用的纹理贴图(存储在Texture文件夹内) 
////////////////////////////        注释：用于结束标记

注意：
1. 冒号和数字间必须要有空格，否则会联通数字被忽略导致读取出错
2. 该文件不支持注释
3. 数字左边的描述不区分大小写，你可以写TYPEID
4. 不能缺写，不能多写，不能调换顺序
********************************************************************************
************************** EnemyLevelX.txt文件编写 *****************************
一个飞机同时执行两套指令集：主指令(MainCmd)和副指令。
主指令只能有一套，但副指令可以有多套，通过指定cmdCount的值来确定有多少套副指令
以下是支持的函数：

============================= MainCmd中可用函数 ================================
函数名    SetCmd  
参数      Pos...
用法      设置当前副指令为Pos里面的其中一个，范围为[0, cmdCount - 1]
使用展示  SetCmd 4 5 6


函数名    SetFrameIfHPLess
参数      HP, FrameVal
用法      若血量值小于等于HP，将当前帧设为FrameVal
使用展示  SetFrameIfHPLess 1200 600


函数名    SetFrame 
参数      FrameVal
用法      当前帧设为FrameVal
使用展示  SetFrame 500

============================= 指令集中可用函数 =================================
函数名    SetVelX
参数      VelX
用法      设置X方向速度
使用展示  SetVelX 4.0


函数名    SetVelY
参数      VelY
用法      设置Y方向速度
使用展示  SetVelY 4.0


函数名    SetAwayVelX
参数      VelX
用法      当飞机在屏幕左半侧的时候，VelX取负值作为X方向速度
          当飞机在屏幕右半侧的时候，VelX取正值作为X方向速度
使用展示  SetAwayVelX 4.0


函数名    Shoot
参数      PosX PosY Vel Angles... 
用法          在飞机贴图坐标系中，X轴向右，Y轴向下，且飞机贴图左上角   ┏━━→
          作为原点，(PosX, PosY)为该贴图坐标系的一点，表示子弹中心的   ┃
          起始发射坐标。                                               ┃  ·(PosX,PosY)
              Vel为发射速度                                            ↓
              Angle为发射的角度，其中屏幕XY坐标系及角度规定如下：
                      -90°
                       ↑
                       ┃
           -180°      ┃
                 ←━━╋━━→ 0°X
            180°      ┃
                       ┃
                       ↓
                       90°
                        Y
              可以一次性指定多个Angle，即一个函数可以发射多个子弹。
使用展示  Shoot 30 50 5.0 90
          Shoot 40 50 8.0 60 70 80 90 100 110 120 130


函数名    ShootToPlayer
参数      PosX PosY Vel Angles...
用法          以飞机贴图坐标系中的位置(PosX, PosY)作为子弹的发射起点，
          发射速度为Vel，Angle为0.0时子弹会攻击玩家
              若Angle越大，子弹偏移玩家的角度也越大
              可以一次性指定多个Angle，即一个函数可以发射多个子弹。
使用展示  ShootToPlayer     50 95 4.0 0.0
          ShootToPlayer     50 95 4.0 -6.0 -3.0 0.0 3.0 6.0


函数名    ShootRand
参数      PosX PosY Vel Angle OffsetAngle nums
用法          以飞机贴图坐标系中的位置(PosX, PosY)作为子弹的发射起点，
          发射速度为Vel，子弹发射角度是随机的，区间为
              [Angle - OffsetAngle, Angle + OffsetAngle]
              nums为发射的子弹数目
使用展示  ShootRand         50 100 90.0 5.0 3


函数名    ShootToPlayerRand  
参数      PosX PosY Vel AngleOffset nums
用法          以飞机贴图坐标系中的位置(PosX, PosY)作为子弹的发射起点，
          发射速度为Vel，子弹的偏移角度为AngleOffset
              nums为发射的子弹数目
使用展示  ShootToPlayerRand 56  175 5.0 12.0 1


函数名    ShootLaser
参数      PosX PosY Vel
用法          以飞机贴图坐标系中的位置(PosX, PosY)作为子弹的发射起点，
          发射速度为Vel，发射角度固定为90°
使用展示  ShootLaser 50 100 12.0


函数名    ShootFlame
参数      PosX PosY Vel Angles...
用法          Vel为发射速度
              Angle为发射角度
              可以一次性指定多个Angle，即一个函数可以发射多个火焰弹。
使用展示  ShootFlame     30 50 5.0 90
          ShootFlame     40 50 8.0 60 70 80 90 100 110 120 130


函数名    ShootFlameRand
参数      PosX PosY Vel Angle OffsetAngle nums
用法          以飞机贴图坐标系中的位置(PosX, PosY)作为火焰弹的发射起点，
          发射速度为Vel，火焰弹发射角度是随机的，区间为
              [Angle - OffsetAngle, Angle + OffsetAngle]
              nums为发射的火焰弹数目
使用展示  ShootFlameRand      50 100 90.0 5.0 3



函数名    Charge
参数      0
用法      播放CHARGE.WAV音效
使用展示  Charge 0
====================================================================

每个飞机的编写参数和顺序要求参照如下格式：
typeID: 1    cmdCount: 1                 | typeID为飞机ID，cmdCount为副指令数目
MainCmd                                  | 主指令开始的标记
0    SetCmd            0                 | 第一个数为相对帧数，当相对帧数到达该值时，执行该函数 
=============================            | 副指令开始的标记，对应的是副指令0
35   SetVelY           0.0               | 同样首先需要提供相对帧数
35   ShootToPlayer     50 95 4.0 0.0     | 
125  SetVelY           10.0              |
125  ShootToPlayer     50 95 4.0 0.0     |
/////////////////////////                | 结束标记


注意：
1. 函数指令区分大小写
2. 必须严格使用=====分界线和////分界线
3. 冒号和数字之间必须要有空格
4. 两个函数之间可以有空格，但最后一个函数必须紧挨分界线

********************************************************************************
***************************** StageX.txt文件编写 *******************************
开头可以有注释，但必须以//为首
首先需要提供BossFrameCnt，作为标记Boss出场的对应帧
在默认关卡，游戏从第0帧开始
而在Boss关卡，游戏从BossFrameCnt - 1000开始

飞机的布置：
每一行需要提供四个参数： Frame TypeID MinPosX MaxPosX
Frame对应出场的帧数
TypeID对应出场的飞机ID
MinPosX和MaxPosX对应飞机出场的位置是随机的，范围在[MinPosX, MaxPosX]。
注意游戏的分辨率为750x900

由于作者将TypeID 3设置为带奖励Item的飞机，若TypeID为3，这一行需要提供五个参数：
              Frame TypeID MinPosX MaxPosX DropItem
若DropItem为1，该飞机被击杀后奖励Bomb，2为Power，3为Shield

注意：行与行之间可以有空格

以下是样例：
BossFrameCnt: 6000

300   1  600 600
320   1  570 570
340   1  540 540
360   1  510 510
380   1  480 480
400   1  450 450
420   1  420 420
440   1  390 390

*********************************************************************************
******************************    实际测试      *********************************
在编写好三个文档后，打开 超级战机.exe,若未能显示正常界面，说明文件编写的格式有误，
需要核对修改。只有编写格式正确时才会正常显示界面。那么赶快体验一下吧！

版本     V1.0
更新日期 2017-8-18
作者     X_Jun



```

`Source Code/Data/Stage1.txt`:

```txt
//Frame TypeID MinPosX MaxPosX (DropItem)
//预留1000帧，Boss模式从BossFrameCnt - 1000帧开始
//下面开始不能有注释，但可以有空行
BossFrameCnt: 6000



300   1  600 600
320   1  570 570
340   1  540 540
360   1  510 510
380   1  480 480
400   1  450 450
420   1  420 420
440   1  390 390

500   1  50  50
520   1  80  80
540   1  110 110
560   1  140 140
580   1  170 170
600   1  200 200
620   1  230 230
640   1  260 260

700   1  600 600
720   1  570 570
740   1  540 540
760   1  510 510
780   1  480 480
800   1  450 450
820   1  420 420
840   1  390 390

900   1  50  50
920   1  80  80
940   1  110 110
960   1  140 140
980   1  170 170
1000  1  200 200
1020  1  230 230
1040  1  260 260


1100  3  275 275 2


1400  1  50  50
1400  1  390 390
1430  1  80  80
1430  1  420 420
1460  1  110 110
1460  1  450 450
1490  1  140 140
1490  1  480 480
1520  1  170 170
1520  1  510 510
1550  1  200 200
1550  1  540 540
1580  1  230 230
1580  1  570 570
1610  1  260 260
1610  1  600 600


1670  1  50  50
1670  8  600 600
1700  1  80  80
1700  8  570 570
1730  1  110 110
1730  8  540 540
1760  1  140 140
1760  8  510 510
1790  1  170 170
1790  8  480 480
1820  1  200 200
1820  8  450 450
1850  1  230 230
1850  8  420 420
1880  1  260 260
1880  8  390 390

1940  8  50  50
1940  1  600 600
1970  8  80  80
1970  1  570 570
2000  8  110 110
2000  1  540 540
2030  8  140 140
2030  1  510 510
2060  8  170 170
2060  1  480 480
2090  8  200 200
2090  1  450 450
2120  8  230 230
2120  1  420 420
2150  8  260 260
2150  1  390 390

2250  2  50  50
2370  2  200 200
2490  2  350 350
2610  2  500 500

2730  2  50  50
2730  2  350 350

2880  2  200 200
2880  2  500 500

3030  3  275 275 3

3330  4  390 390
3330  4  260 260
3360  4  420 420
3360  4  230 230
3390  4  450 450
3390  4  200 200
3420  4  480 480
3420  4  170 170
3450  4  510 510
3450  4  140 140
3480  4  540 540
3480  4  110 110
3510  4  570 570
3510  4  80  80
3540  4  600 600
3540  4  50  50

3630  8  50  260
3630  8  390 600
3660  8  50  260
3660  8  390 600
3690  8  50  260
3690  8  390 600
3720  8  50  260
3720  8  390 600
3750  8  50  260
3750  8  390 600
3780  8  50  260
3780  8  390 600
3810  8  50  260
3810  8  390 600
3840  8  50  260
3840  8  390 600

3930  3  275 275 1

4230  2  50  50
4230  1  600 600
4250  1  570 570
4270  1  540 540
4290  1  510 510
4310  1  480 480
4330  1  450 450
4350  1  420 420
4370  1  390 390

4430  2  500 500
4430  1  50  50
4450  1  80  80
4470  1  110 110
4490  1  140 140
4510  1  170 170
4530  1  200 200
4550  1  230 230
4570  1  260 260

4630  2  275 275
4700  2  275 275
4770  2  275 275
4840  2  275 275
4910  2  275 275
4980  2  275 275

5300  3  275 275 1

6000  12 250 250

```

`Source Code/Data/Stage2.txt`:

```txt
//Frame TypeID MinPosX MaxPosX (DropItem)
//预留1000帧，Boss模式从BossFrameCnt - 1000帧开始
//下面开始不能有注释，但可以有空行
BossFrameCnt: 8000


300   4  100 600
320   4  100 600
340   4  100 600
360   4  100 600
380   4  100 600
400   4  100 600
420   4  100 600
440   4  100 600
440   4  100 600
460   4  100 600
480   4  100 600
500   4  100 600
520   4  100 600
540   4  100 600
560   4  100 600
580   4  100 600
600   4  100 600
620   4  100 600
640   4  100 600
660   4  100 600
680   4  100 600

750   3  275 275 3

1050  5  100 550
1070  5  100 550
1090  5  100 550
1110  5  100 550
1130  5  100 550
1150  5  100 550
1170  5  100 550
1190  5  100 550
1210  5  100 550
1230  5  100 550
1250  5  100 550
1270  5  100 550
1290  5  100 550
1310  5  100 550
1330  5  100 550

1390  4  50  325
1390  8  600 600
1410  4  50  325
1410  8  570 570
1430  4  50  325
1430  8  540 540
1450  4  50  325
1450  8  510 510
1470  4  50  325
1470  8  480 480
1490  4  50  325
1490  8  450 450
1510  4  50  325
1510  8  420 420
1530  4  50  325
1530  8  390 390

1590  4  325 600
1590  8  50  50
1610  4  325 600
1610  8  80  80
1630  4  325 600
1630  8  110 110
1650  4  325 600
1650  8  140 140
1670  4  325 600
1670  8  170 170
1690  4  325 600
1690  8  200 200
1710  4  325 600
1710  8  230 230
1730  4  325 600
1730  8  260 260

1820  6  100 100
1940  6  250 250
2060  6  400 400
2180  6  550 550 

2300  3  275 275 2

2600  1  50  325
2600  1  325 600
2620  1  50  325
2620  1  325 600
2640  1  50  325
2640  1  325 600
2660  1  50  325
2660  1  325 600
2680  1  50  325
2680  1  325 600
2700  1  50  325
2700  1  325 600
2720  1  50  325
2720  1  325 600
2740  1  50  325
2740  1  325 600
2760  1  50  325
2760  1  325 600
2780  1  50  325
2780  1  325 600

2900  5  100 325
2900  5  325 550
2920  5  100 325
2920  5  325 550
2940  5  100 325
2940  5  325 550
2960  5  100 325
2960  5  325 550
2980  5  100 325
2980  5  325 550
3000  5  100 325
3000  5  325 550
3020  5  100 325
3020  5  325 550
3040  5  100 325
3040  5  325 550
3060  5  100 325
3060  5  325 550
3080  5  100 325
3080  5  325 550

3200  2  100 100
3200  4  325 600
3230  4  325 600
3260  4  325 600
3290  4  325 600
3320  4  325 600
3350  4  325 600
3380  4  325 600
3410  4  325 600

3440  2  400 400
3440  4  50  325
3470  4  50  325
3500  4  50  325
3530  4  50  325
3560  4  50  325
3590  4  50  325
3620  4  50  325
3650  4  50  325

3680  2  250 250
3680  4  325 600
3710  4  325 600
3740  4  325 600
3770  4  325 600
3800  4  325 600
3830  4  325 600
3860  4  325 600
3890  4  325 600

3920  2  550 550
3920  4  50  325
3950  4  50  325
3980  4  50  325
4010  4  50  325
4040  4  50  325
4070  4  50  325
4100  4  50  325
4130  4  50  325


4210  3  100 100 1
4270  3  450 450 2


4570  6  100 100
4570  1  325 600
4600  1  325 600
4630  1  325 600
4660  1  325 600
4690  1  325 600
4720  1  325 600
4750  1  325 600
4780  1  325 600

4810  6  250 250
4810  1  325 600
4840  1  325 600
4870  1  325 600
4900  1  325 600
4930  1  325 600
4960  1  325 600
4990  1  325 600
5020  1  325 600

5020  6  400 400
5020  1  50  325
5050  1  50  325
5080  1  50  325
5110  1  50  325
5140  1  50  325
5170  1  50  325
5200  1  50  325
5230  1  50  325

5260  6  550 550
5260  1  50  325
5290  1  50  325
5320  1  50  325
5350  1  50  325
5380  1  50  325
5410  1  50  325
5440  1  50  325
5470  1  50  325

5550  9  100 100
5750  9  400 400
5950  9  250 250

6200  7  100 250
6250  7  250 400
6300  7  400 550

6420  7  100 250
6470  7  250 400
6520  7  400 550

6640  7  100 250
6690  7  250 400
6740  7  400 550

6860  7  100 250
6910  7  250 400
6960  7  400 550

7300  3  100 100 1
7360  3  450 450 3

8000  13 125 125


```

`Source Code/Data/Stage3.txt`:

```txt
//Frame TypeID MinPosX MaxPosX (DropItem)
//预留1000帧，Boss模式从BossFrameCnt 420 600 1000帧开始
//下面开始不能有注释，但可以有空行
BossFrameCnt: 10000


300   3  100 100 3
420   3  450 450 2

720   8  50  325
720   8  230 420
750   8  50  325
750   8  230 420
780   8  50  50 
780   8  230 420
810   8  50  325
810   8  230 420
840   8  50  50 
840   8  230 420
870   8  50  325
870   8  230 420
900   8  50  50 
900   8  230 420
930   8  50  325
930   8  230 420
960   8  50  50 
960   8  230 420
990   8  50  325
990   8  230 420
1020  8  50  50 
1020  8  230 420
1050  8  50  325
1050  8  230 420

1170  4  100 600
1185  4  100 600
1200  4  100 600
1215  4  100 600
1230  4  100 600
1245  4  100 600
1260  4  100 600
1275  4  100 600
1290  4  100 600
1305  4  100 600
1320  4  100 600
1335  4  100 600
1350  4  100 600
1365  4  100 600
1380  4  100 600
1395  4  100 600
1410  4  100 600
1425  4  100 600
1440  4  100 600
1455  4  100 600
1470  4  100 600
1485  4  100 600
1500  4  100 600
1515  4  100 600


1650  1  50  230
1650  1  230 420
1650  1  420 600
1680  1  50  230
1680  1  230 420
1680  1  420 600
1710  1  50  230
1710  1  230 420
1710  1  420 600
1740  1  50  230
1740  1  230 420
1740  1  420 600
1770  1  50  230
1770  1  230 420
1770  1  420 600
1800  1  50  230
1800  1  230 420
1800  1  420 600
1830  1  50  230
1830  1  230 420
1830  1  420 600
1860  1  50  230
1860  1  230 420
1860  1  420 600
1890  1  50  325
1890  1  230 420
1920  1  50  230
1920  1  230 420
1920  1  420 600

2040  9  50  50
2040  9  400 400

2280  11 250 250

2520  7  100 600
2570  7  100 600
2620  7  100 600
2670  7  100 600
2720  7  100 600
2770  7  100 600
2820  7  100 600
2870  7  100 600
2920  7  100 600
2970  7  100 600
3020  7  100 600
3070  7  100 600
3120  7  100 600
3170  7  100 600
3220  7  100 600
3270  7  100 600

3340  3  100 100 1
3460  3  450 450 2

3760  5  50  325
3760  5  230 420
3760  5  420 600
3790  5  50  325
3790  5  230 420
3790  5  420 600
3820  5  50  325
3820  5  230 420
3820  5  420 600
3850  5  50  325
3850  5  230 420
3850  5  420 600
3880  5  50  325
3880  5  230 420
3880  5  420 600
3910  5  50  325
3910  5  230 420
3910  5  420 600
3940  5  50  325
3940  5  230 420
3940  5  420 600
3970  5  50  325
3970  5  230 420
3970  5  420 600
4000  5  50  325
4000  5  230 420
4000  5  420 600
4030  5  50  325
4030  5  230 420
4030  5  420 600
4060  5  50  325
4060  5  230 420
4060  5  420 600
4090  5  50  325
4090  5  230 420
4090  5  420 600

4210  10 100 100
4360  10 400 400
4510  10 250 250

4870  2  50  50
4870  7  350 600
4920  7  350 600
4970  7  350 600
5020  7  350 600

5120  2  500 500
5120  7  100 350
5170  7  100 350
5220  7  100 350
5270  7  100 350

5420  3  100 100 1
5540  3  450 450 3

5840  6  220 220
5840  6  380 380

6040  6  50  50
6040  6  550 550

6240  2  200 200
6240  2  350 350

6440  11 50  50
6640  11 400 400

6840  10 250 250
7000  6  50  50
7000  6  550 550

7250  10 100 100
7250  10 400 400
7410  6  50  50
7410  6  550 550

7710  7  50  600
7710  7  50  600
7810  7  50  600
7810  7  50  600
7910  7  50  600
7910  7  50  600

8060  7  50  600
8060  7  50  600
8160  7  50  600
8160  7  50  600
8260  7  50  600
8260  7  50  600

8410  7  50  600
8410  7  50  600
8510  7  50  600
8510  7  50  600
8610  7  50  600
8610  7  50  600

8760  7  50  600
8760  7  50  600
8860  7  50  600
8860  7  50  600
8960  7  50  600
8960  7  50  600

9200  3  100 100 1
9200  3  450 450 3

9500  3  100 100 1
9500  3  450 450 2

10000 14 200 200

```

`Source Code/Data/Stage4.txt`:

```txt
//Frame TypeID MinPosX MaxPosX (DropItem)
//预留1000帧，Boss模式从BossFrameCnt - 1000帧开始
//下面开始不能有注释，但可以有空行
BossFrameCnt: 6000



300   1  600 600
320   1  570 570
340   1  540 540
360   1  510 510
380   1  480 480
400   1  450 450
420   1  420 420
440   1  390 390

500   1  50  50
520   1  80  80
540   1  110 110
560   1  140 140
580   1  170 170
600   1  200 200
620   1  230 230
640   1  260 260

700   1  600 600
720   1  570 570
740   1  540 540
760   1  510 510
780   1  480 480
800   1  450 450
820   1  420 420
840   1  390 390

900   1  50  50
920   1  80  80
940   1  110 110
960   1  140 140
980   1  170 170
1000  1  200 200
1020  1  230 230
1040  1  260 260


1100  3  275 275 2


1400  1  50  50
1400  1  390 390
1430  1  80  80
1430  1  420 420
1460  1  110 110
1460  1  450 450
1490  1  140 140
1490  1  480 480
1520  1  170 170
1520  1  510 510
1550  1  200 200
1550  1  540 540
1580  1  230 230
1580  1  570 570
1610  1  260 260
1610  1  600 600


1670  1  50  50
1670  8  600 600
1700  1  80  80
1700  8  570 570
1730  1  110 110
1730  8  540 540
1760  1  140 140
1760  8  510 510
1790  1  170 170
1790  8  480 480
1820  1  200 200
1820  8  450 450
1850  1  230 230
1850  8  420 420
1880  1  260 260
1880  8  390 390

1940  8  50  50
1940  1  600 600
1970  8  80  80
1970  1  570 570
2000  8  110 110
2000  1  540 540
2030  8  140 140
2030  1  510 510
2060  8  170 170
2060  1  480 480
2090  8  200 200
2090  1  450 450
2120  8  230 230
2120  1  420 420
2150  8  260 260
2150  1  390 390

2250  2  50  50
2370  2  200 200
2490  2  350 350
2610  2  500 500

2730  2  50  50
2730  2  350 350

2880  2  200 200
2880  2  500 500

3030  3  275 275 3

3330  4  390 390
3330  4  260 260
3360  4  420 420
3360  4  230 230
3390  4  450 450
3390  4  200 200
3420  4  480 480
3420  4  170 170
3450  4  510 510
3450  4  140 140
3480  4  540 540
3480  4  110 110
3510  4  570 570
3510  4  80  80
3540  4  600 600
3540  4  50  50

3630  8  50  260
3630  8  390 600
3660  8  50  260
3660  8  390 600
3690  8  50  260
3690  8  390 600
3720  8  50  260
3720  8  390 600
3750  8  50  260
3750  8  390 600
3780  8  50  260
3780  8  390 600
3810  8  50  260
3810  8  390 600
3840  8  50  260
3840  8  390 600

3930  3  275 275 1

4230  2  50  50
4230  1  600 600
4250  1  570 570
4270  1  540 540
4290  1  510 510
4310  1  480 480
4330  1  450 450
4350  1  420 420
4370  1  390 390

4430  2  500 500
4430  1  50  50
4450  1  80  80
4470  1  110 110
4490  1  140 140
4510  1  170 170
4530  1  200 200
4550  1  230 230
4570  1  260 260

4630  2  275 275
4700  2  275 275
4770  2  275 275
4840  2  275 275
4910  2  275 275
4980  2  275 275

5300  3  275 275 1

6000  12 250 250

```

`Source Code/Data/Stage5.txt`:

```txt
//Frame TypeID MinPosX MaxPosX (DropItem)
//预留1000帧，Boss模式从BossFrameCnt - 1000帧开始
//下面开始不能有注释，但可以有空行
BossFrameCnt: 8000


300   4  100 600
320   4  100 600
340   4  100 600
360   4  100 600
380   4  100 600
400   4  100 600
420   4  100 600
440   4  100 600
440   4  100 600
460   4  100 600
480   4  100 600
500   4  100 600
520   4  100 600
540   4  100 600
560   4  100 600
580   4  100 600
600   4  100 600
620   4  100 600
640   4  100 600
660   4  100 600
680   4  100 600

750   3  275 275 3

1050  5  100 550
1070  5  100 550
1090  5  100 550
1110  5  100 550
1130  5  100 550
1150  5  100 550
1170  5  100 550
1190  5  100 550
1210  5  100 550
1230  5  100 550
1250  5  100 550
1270  5  100 550
1290  5  100 550
1310  5  100 550
1330  5  100 550

1390  4  50  325
1390  8  600 600
1410  4  50  325
1410  8  570 570
1430  4  50  325
1430  8  540 540
1450  4  50  325
1450  8  510 510
1470  4  50  325
1470  8  480 480
1490  4  50  325
1490  8  450 450
1510  4  50  325
1510  8  420 420
1530  4  50  325
1530  8  390 390

1590  4  325 600
1590  8  50  50
1610  4  325 600
1610  8  80  80
1630  4  325 600
1630  8  110 110
1650  4  325 600
1650  8  140 140
1670  4  325 600
1670  8  170 170
1690  4  325 600
1690  8  200 200
1710  4  325 600
1710  8  230 230
1730  4  325 600
1730  8  260 260

1820  6  100 100
1940  6  250 250
2060  6  400 400
2180  6  550 550 

2300  3  275 275 2

2600  1  50  325
2600  1  325 600
2620  1  50  325
2620  1  325 600
2640  1  50  325
2640  1  325 600
2660  1  50  325
2660  1  325 600
2680  1  50  325
2680  1  325 600
2700  1  50  325
2700  1  325 600
2720  1  50  325
2720  1  325 600
2740  1  50  325
2740  1  325 600
2760  1  50  325
2760  1  325 600
2780  1  50  325
2780  1  325 600

2900  5  100 325
2900  5  325 550
2920  5  100 325
2920  5  325 550
2940  5  100 325
2940  5  325 550
2960  5  100 325
2960  5  325 550
2980  5  100 325
2980  5  325 550
3000  5  100 325
3000  5  325 550
3020  5  100 325
3020  5  325 550
3040  5  100 325
3040  5  325 550
3060  5  100 325
3060  5  325 550
3080  5  100 325
3080  5  325 550

3200  2  100 100
3200  4  325 600
3230  4  325 600
3260  4  325 600
3290  4  325 600
3320  4  325 600
3350  4  325 600
3380  4  325 600
3410  4  325 600

3440  2  400 400
3440  4  50  325
3470  4  50  325
3500  4  50  325
3530  4  50  325
3560  4  50  325
3590  4  50  325
3620  4  50  325
3650  4  50  325

3680  2  250 250
3680  4  325 600
3710  4  325 600
3740  4  325 600
3770  4  325 600
3800  4  325 600
3830  4  325 600
3860  4  325 600
3890  4  325 600

3920  2  550 550
3920  4  50  325
3950  4  50  325
3980  4  50  325
4010  4  50  325
4040  4  50  325
4070  4  50  325
4100  4  50  325
4130  4  50  325


4210  3  100 100 1
4270  3  450 450 2


4570  6  100 100
4570  1  325 600
4600  1  325 600
4630  1  325 600
4660  1  325 600
4690  1  325 600
4720  1  325 600
4750  1  325 600
4780  1  325 600

4810  6  250 250
4810  1  325 600
4840  1  325 600
4870  1  325 600
4900  1  325 600
4930  1  325 600
4960  1  325 600
4990  1  325 600
5020  1  325 600

5020  6  400 400
5020  1  50  325
5050  1  50  325
5080  1  50  325
5110  1  50  325
5140  1  50  325
5170  1  50  325
5200  1  50  325
5230  1  50  325

5260  6  550 550
5260  1  50  325
5290  1  50  325
5320  1  50  325
5350  1  50  325
5380  1  50  325
5410  1  50  325
5440  1  50  325
5470  1  50  325

5550  9  100 100
5750  9  400 400
5950  9  250 250

6200  7  100 250
6250  7  250 400
6300  7  400 550

6420  7  100 250
6470  7  250 400
6520  7  400 550

6640  7  100 250
6690  7  250 400
6740  7  400 550

6860  7  100 250
6910  7  250 400
6960  7  400 550

7300  3  100 100 1
7360  3  450 450 3

8000  13 125 125


```

`Source Code/Data/Stage6.txt`:

```txt
//Frame TypeID MinPosX MaxPosX (DropItem)
//预留1000帧，Boss模式从BossFrameCnt 420 600 1000帧开始
//下面开始不能有注释，但可以有空行
BossFrameCnt: 10000


300   3  100 100 3
420   3  450 450 2

720   8  50  325
720   8  230 420
750   8  50  325
750   8  230 420
780   8  50  50 
780   8  230 420
810   8  50  325
810   8  230 420
840   8  50  50 
840   8  230 420
870   8  50  325
870   8  230 420
900   8  50  50 
900   8  230 420
930   8  50  325
930   8  230 420
960   8  50  50 
960   8  230 420
990   8  50  325
990   8  230 420
1020  8  50  50 
1020  8  230 420
1050  8  50  325
1050  8  230 420

1170  4  100 600
1185  4  100 600
1200  4  100 600
1215  4  100 600
1230  4  100 600
1245  4  100 600
1260  4  100 600
1275  4  100 600
1290  4  100 600
1305  4  100 600
1320  4  100 600
1335  4  100 600
1350  4  100 600
1365  4  100 600
1380  4  100 600
1395  4  100 600
1410  4  100 600
1425  4  100 600
1440  4  100 600
1455  4  100 600
1470  4  100 600
1485  4  100 600
1500  4  100 600
1515  4  100 600


1650  1  50  230
1650  1  230 420
1650  1  420 600
1680  1  50  230
1680  1  230 420
1680  1  420 600
1710  1  50  230
1710  1  230 420
1710  1  420 600
1740  1  50  230
1740  1  230 420
1740  1  420 600
1770  1  50  230
1770  1  230 420
1770  1  420 600
1800  1  50  230
1800  1  230 420
1800  1  420 600
1830  1  50  230
1830  1  230 420
1830  1  420 600
1860  1  50  230
1860  1  230 420
1860  1  420 600
1890  1  50  325
1890  1  230 420
1920  1  50  230
1920  1  230 420
1920  1  420 600

2040  9  50  50
2040  9  400 400

2280  11 250 250

2520  7  100 600
2570  7  100 600
2620  7  100 600
2670  7  100 600
2720  7  100 600
2770  7  100 600
2820  7  100 600
2870  7  100 600
2920  7  100 600
2970  7  100 600
3020  7  100 600
3070  7  100 600
3120  7  100 600
3170  7  100 600
3220  7  100 600
3270  7  100 600

3340  3  100 100 1
3460  3  450 450 2

3760  5  50  325
3760  5  230 420
3760  5  420 600
3790  5  50  325
3790  5  230 420
3790  5  420 600
3820  5  50  325
3820  5  230 420
3820  5  420 600
3850  5  50  325
3850  5  230 420
3850  5  420 600
3880  5  50  325
3880  5  230 420
3880  5  420 600
3910  5  50  325
3910  5  230 420
3910  5  420 600
3940  5  50  325
3940  5  230 420
3940  5  420 600
3970  5  50  325
3970  5  230 420
3970  5  420 600
4000  5  50  325
4000  5  230 420
4000  5  420 600
4030  5  50  325
4030  5  230 420
4030  5  420 600
4060  5  50  325
4060  5  230 420
4060  5  420 600
4090  5  50  325
4090  5  230 420
4090  5  420 600

4210  10 100 100
4360  10 400 400
4510  10 250 250

4870  2  50  50
4870  7  350 600
4920  7  350 600
4970  7  350 600
5020  7  350 600

5120  2  500 500
5120  7  100 350
5170  7  100 350
5220  7  100 350
5270  7  100 350

5420  3  100 100 1
5540  3  450 450 3

5840  6  220 220
5840  6  380 380

6040  6  50  50
6040  6  550 550

6240  2  200 200
6240  2  350 350

6440  11 50  50
6640  11 400 400

6840  10 250 250
7000  6  50  50
7000  6  550 550

7250  10 100 100
7250  10 400 400
7410  6  50  50
7410  6  550 550

7710  7  50  600
7710  7  50  600
7810  7  50  600
7810  7  50  600
7910  7  50  600
7910  7  50  600

8060  7  50  600
8060  7  50  600
8160  7  50  600
8160  7  50  600
8260  7  50  600
8260  7  50  600

8410  7  50  600
8410  7  50  600
8510  7  50  600
8510  7  50  600
8610  7  50  600
8610  7  50  600

8760  7  50  600
8760  7  50  600
8860  7  50  600
8860  7  50  600
8960  7  50  600
8960  7  50  600

9200  3  100 100 1
9200  3  450 450 3

9500  3  100 100 1
9500  3  450 450 2

10000 14 200 200

```

`Source Code/Data/Stage7.txt`:

```txt
//Frame TypeID MinPosX MaxPosX (DropItem)
//预留1000帧，Boss模式从BossFrameCnt 420 600 1000帧开始
//下面开始不能有注释，但可以有空行
BossFrameCnt: 1500

300   3  100 100 2
300   3  450 450 3

600   3  100 100 1
600   3  450 450 2

900   3  50  50  1
900   3  250 250 2
900   3  450 450 3

1500  15 325 325

 
```

`Source Code/DirectSound.cpp`:

```cpp
//-----------------------------------------------------------------------------
// File: DSUtil.cpp
//
// Desc: DirectSound framework classes for reading and writing wav files and
//       playing them in DirectSound buffers. Feel free to use this class 
//       as a starting point for adding extra functionality.
//
// Copyright (c) Microsoft Corp. All rights reserved.
//-----------------------------------------------------------------------------
//
// Note: This file has been edited for use in Beginning Game Programming, Third Edition,
// originally distributed with a 2004 release of DirectX 9.0c SDK.
//

#define STRICT
#include <windows.h>
#include <mmsystem.h>
#include <dxerr.h>
#include <dsound.h>
#include "DirectSound.h"


//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------
#define SAFE_DELETE(p)       { if(p) { delete (p);     (p)=NULL; } }
#define SAFE_DELETE_ARRAY(p) { if(p) { delete[] (p);   (p)=NULL; } }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }


//-----------------------------------------------------------------------------
// Name: CSoundManager::CSoundManager()
// Desc: Constructs the class
//-----------------------------------------------------------------------------
CSoundManager::CSoundManager()
{
    m_pDS = NULL;
}

//-----------------------------------------------------------------------------
// Name: CSoundManager::~CSoundManager()
// Desc: Destroys the class
//-----------------------------------------------------------------------------
CSoundManager::~CSoundManager()
{
    SAFE_RELEASE( m_pDS ); 
}

//-----------------------------------------------------------------------------
// Name: CSoundManager::Initialize()
// Desc: Initializes the IDirectSound object and also sets the primary buffer
//       format.  This function must be called before any others.
//-----------------------------------------------------------------------------
HRESULT CSoundManager::Initialize( HWND  hWnd, 
                                   DWORD dwCoopLevel )
{
    HRESULT             hr;

    SAFE_RELEASE( m_pDS );

    // Create IDirectSound using the primary sound device
    if( FAILED( hr = DirectSoundCreate8( NULL, &m_pDS, NULL ) ) )
        return DXTRACE_ERR( TEXT("DirectSoundCreate8"), hr );

    // Set DirectSound coop level 
    if( FAILED( hr = m_pDS->SetCooperativeLevel( hWnd, dwCoopLevel ) ) )
        return DXTRACE_ERR( TEXT("SetCooperativeLevel"), hr );   

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CSoundManager::SetPrimaryBufferFormat()
// Desc: Set primary buffer to a specified format 
//       !WARNING! - Setting the primary buffer format and then using this
//                   same dsound object for DirectMusic messes up DirectMusic! 
//       For example, to set the primary buffer format to 22kHz stereo, 16-bit
//       then:   dwPrimaryChannels = 2
//               dwPrimaryFreq     = 22050, 
//               dwPrimaryBitRate  = 16
//-----------------------------------------------------------------------------
HRESULT CSoundManager::SetPrimaryBufferFormat( DWORD dwPrimaryChannels, 
                                               DWORD dwPrimaryFreq, 
                                               DWORD dwPrimaryBitRate )
{
    HRESULT             hr;
    LPDIRECTSOUNDBUFFER pDSBPrimary = NULL;

    if( m_pDS == NULL )
        return CO_E_NOTINITIALIZED;

    // Get the primary buffer 
    DSBUFFERDESC dsbd;
    ZeroMemory( &dsbd, sizeof(DSBUFFERDESC) );
    dsbd.dwSize        = sizeof(DSBUFFERDESC);
    dsbd.dwFlags       = DSBCAPS_PRIMARYBUFFER;
    dsbd.dwBufferBytes = 0;
    dsbd.lpwfxFormat   = NULL;
       
    if( FAILED( hr = m_pDS->CreateSoundBuffer( &dsbd, &pDSBPrimary, NULL ) ) )
        return DXTRACE_ERR( TEXT("CreateSoundBuffer"), hr );

    WAVEFORMATEX wfx;
    ZeroMemory( &wfx, sizeof(WAVEFORMATEX) ); 
    wfx.wFormatTag      = (WORD) WAVE_FORMAT_PCM; 
    wfx.nChannels       = (WORD) dwPrimaryChannels; 
    wfx.nSamplesPerSec  = (DWORD) dwPrimaryFreq; 
    wfx.wBitsPerSample  = (WORD) dwPrimaryBitRate; 
    wfx.nBlockAlign     = (WORD) (wfx.wBitsPerSample / 8 * wfx.nChannels);
    wfx.nAvgBytesPerSec = (DWORD) (wfx.nSamplesPerSec * wfx.nBlockAlign);

    if( FAILED( hr = pDSBPrimary->SetFormat(&wfx) ) )
        return DXTRACE_ERR( TEXT("SetFormat"), hr );

    SAFE_RELEASE( pDSBPrimary );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: CSoundManager::Create()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CSoundManager::Create( CSound** ppSound, 
                               LPTSTR strWaveFileName, 
                               DWORD dwCreationFlags, 
                               GUID guid3DAlgorithm,
                               DWORD dwNumBuffers )
{
    HRESULT hr;
    HRESULT hrRet = S_OK;
    DWORD   i;
    LPDIRECTSOUNDBUFFER* apDSBuffer     = NULL;
    DWORD                dwDSBufferSize = NULL;
    CWaveFile*           pWaveFile      = NULL;

    if( m_pDS == NULL )
        return CO_E_NOTINITIALIZED;
    if( strWaveFileName == NULL || ppSound == NULL || dwNumBuffers < 1 )
        return E_INVALIDARG;

    apDSBuffer = new LPDIRECTSOUNDBUFFER[dwNumBuffers];
    if( apDSBuffer == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto LFail;
    }

    pWaveFile = new CWaveFile();
    if( pWaveFile == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto LFail;
    }

    pWaveFile->Open( strWaveFileName, NULL, WAVEFILE_READ );

    if( pWaveFile->GetSize() == 0 )
    {
        // Wave is blank, so don't create it.
        hr = E_FAIL;
        goto LFail;
    }

    // Make the DirectSound buffer the same size as the wav file
    dwDSBufferSize = pWaveFile->GetSize();

    // Create the direct sound buffer, and only request the flags needed
    // since each requires some overhead and limits if the buffer can 
    // be hardware accelerated
    DSBUFFERDESC dsbd;
    ZeroMemory( &dsbd, sizeof(DSBUFFERDESC) );
    dsbd.dwSize          = sizeof(DSBUFFERDESC);
    dsbd.dwFlags         = dwCreationFlags;
    dsbd.dwBufferBytes   = dwDSBufferSize;
    dsbd.guid3DAlgorithm = guid3DAlgorithm;
    dsbd.lpwfxFormat     = pWaveFile->m_pwfx;
    
    // DirectSound is only guarenteed to play PCM data.  Other
    // formats may or may not work depending the sound card driver.
    hr = m_pDS->CreateSoundBuffer( &dsbd, &apDSBuffer[0], NULL );

    // Be sure to return this error code if it occurs so the
    // callers knows this happened.
    if( hr == DS_NO_VIRTUALIZATION )
        hrRet = DS_NO_VIRTUALIZATION;
            
    if( FAILED(hr) )
    {
        // DSERR_BUFFERTOOSMALL will be returned if the buffer is
        // less than DSBSIZE_FX_MIN and the buffer is created
        // with DSBCAPS_CTRLFX.
        
        // It might also fail if hardware buffer mixing was requested
        // on a device that doesn't support it.
        DXTRACE_ERR( TEXT("CreateSoundBuffer"), hr );
                    
        goto LFail;
    }

    // Default to use DuplicateSoundBuffer() when created extra buffers since always 
    // create a buffer that uses the same memory however DuplicateSoundBuffer() will fail if 
    // DSBCAPS_CTRLFX is used, so use CreateSoundBuffer() instead in this case.
    if( (dwCreationFlags & DSBCAPS_CTRLFX) == 0 )
    {
        for( i=1; i<dwNumBuffers; i++ )
        {
            if( FAILED( hr = m_pDS->DuplicateSoundBuffer( apDSBuffer[0], &apDSBuffer[i] ) ) )
            {
                DXTRACE_ERR( TEXT("DuplicateSoundBuffer"), hr );
                goto LFail;
            }
        }
    }
    else
    {
        for( i=1; i<dwNumBuffers; i++ )
        {
            hr = m_pDS->CreateSoundBuffer( &dsbd, &apDSBuffer[i], NULL );
            if( FAILED(hr) )
            {
                DXTRACE_ERR( TEXT("CreateSoundBuffer"), hr );
                goto LFail;
            }
        }
   }
    
    // Create the sound
    *ppSound = new CSound( apDSBuffer, dwDSBufferSize, dwNumBuffers, pWaveFile, dwCreationFlags );
    
    SAFE_DELETE_ARRAY( apDSBuffer );
    return hrRet;

LFail:
    // Cleanup
    SAFE_DELETE( pWaveFile );
    SAFE_DELETE_ARRAY( apDSBuffer );
    return hr;
}



//-----------------------------------------------------------------------------
// Name: CSound::CSound()
// Desc: Constructs the class
//-----------------------------------------------------------------------------
CSound::CSound( LPDIRECTSOUNDBUFFER* apDSBuffer, DWORD dwDSBufferSize, 
                DWORD dwNumBuffers, CWaveFile* pWaveFile, DWORD dwCreationFlags )
{
    DWORD i;

    m_apDSBuffer = new LPDIRECTSOUNDBUFFER[dwNumBuffers];
    if( NULL != m_apDSBuffer )
    {
        for( i=0; i<dwNumBuffers; i++ )
            m_apDSBuffer[i] = apDSBuffer[i];
    
        m_dwDSBufferSize = dwDSBufferSize;
        m_dwNumBuffers   = dwNumBuffers;
        m_pWaveFile      = pWaveFile;
        m_dwCreationFlags = dwCreationFlags;
        
        FillBufferWithSound( m_apDSBuffer[0], FALSE );
    }
}




//-----------------------------------------------------------------------------
// Name: CSound::~CSound()
// Desc: Destroys the class
//-----------------------------------------------------------------------------
CSound::~CSound()
{
    for( DWORD i=0; i<m_dwNumBuffers; i++ )
    {
        SAFE_RELEASE( m_apDSBuffer[i] ); 
    }

    SAFE_DELETE_ARRAY( m_apDSBuffer ); 
    SAFE_DELETE( m_pWaveFile );
}




//-----------------------------------------------------------------------------
// Name: CSound::FillBufferWithSound()
// Desc: Fills a DirectSound buffer with a sound file 
//-----------------------------------------------------------------------------
HRESULT CSound::FillBufferWithSound( LPDIRECTSOUNDBUFFER pDSB, BOOL bRepeatWavIfBufferLarger )
{
    HRESULT hr; 
    VOID*   pDSLockedBuffer      = NULL; // Pointer to locked buffer memory
    DWORD   dwDSLockedBufferSize = 0;    // Size of the locked DirectSound buffer
    DWORD   dwWavDataRead        = 0;    // Amount of data read from the wav file 

    if( pDSB == NULL )
        return CO_E_NOTINITIALIZED;

    // Make sure we have focus, and we didn't just switch in from
    // an app which had a DirectSound device
    if( FAILED( hr = RestoreBuffer( pDSB, NULL ) ) ) 
        return DXTRACE_ERR( TEXT("RestoreBuffer"), hr );

    // Lock the buffer down
    if( FAILED( hr = pDSB->Lock( 0, m_dwDSBufferSize, 
                                 &pDSLockedBuffer, &dwDSLockedBufferSize, 
                                 NULL, NULL, 0L ) ) )
        return DXTRACE_ERR( TEXT("Lock"), hr );

    // Reset the wave file to the beginning 
    m_pWaveFile->ResetFile();

    if( FAILED( hr = m_pWaveFile->Read( (BYTE*) pDSLockedBuffer,
                                        dwDSLockedBufferSize, 
                                        &dwWavDataRead ) ) )           
        return DXTRACE_ERR( TEXT("Read"), hr );

    if( dwWavDataRead == 0 )
    {
        // Wav is blank, so just fill with silence
        FillMemory( (BYTE*) pDSLockedBuffer, 
                    dwDSLockedBufferSize, 
                    (BYTE)(m_pWaveFile->m_pwfx->wBitsPerSample == 8 ? 128 : 0 ) );
    }
    else if( dwWavDataRead < dwDSLockedBufferSize )
    {
        // If the wav file was smaller than the DirectSound buffer, 
        // we need to fill the remainder of the buffer with data 
        if( bRepeatWavIfBufferLarger )
        {       
            // Reset the file and fill the buffer with wav data
            DWORD dwReadSoFar = dwWavDataRead;    // From previous call above.
            while( dwReadSoFar < dwDSLockedBufferSize )
            {  
                // This will keep reading in until the buffer is full 
                // for very short files
                if( FAILED( hr = m_pWaveFile->ResetFile() ) )
                    return DXTRACE_ERR( TEXT("ResetFile"), hr );

                hr = m_pWaveFile->Read( (BYTE*)pDSLockedBuffer + dwReadSoFar,
                                        dwDSLockedBufferSize - dwReadSoFar,
                                        &dwWavDataRead );
                if( FAILED(hr) )
                    return DXTRACE_ERR( TEXT("Read"), hr );

                dwReadSoFar += dwWavDataRead;
            } 
        }
        else
        {
            // Don't repeat the wav file, just fill in silence 
            FillMemory( (BYTE*) pDSLockedBuffer + dwWavDataRead, 
                        dwDSLockedBufferSize - dwWavDataRead, 
                        (BYTE)(m_pWaveFile->m_pwfx->wBitsPerSample == 8 ? 128 : 0 ) );
        }
    }

    // Unlock the buffer, we don't need it anymore.
    pDSB->Unlock( pDSLockedBuffer, dwDSLockedBufferSize, NULL, 0 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CSound::RestoreBuffer()
// Desc: Restores the lost buffer. *pbWasRestored returns TRUE if the buffer was 
//       restored.  It can also NULL if the information is not needed.
//-----------------------------------------------------------------------------
HRESULT CSound::RestoreBuffer( LPDIRECTSOUNDBUFFER pDSB, BOOL* pbWasRestored )
{
    HRESULT hr;

    if( pDSB == NULL )
        return CO_E_NOTINITIALIZED;
    if( pbWasRestored )
        *pbWasRestored = FALSE;

    DWORD dwStatus;
    if( FAILED( hr = pDSB->GetStatus( &dwStatus ) ) )
        return DXTRACE_ERR( TEXT("GetStatus"), hr );

    if( dwStatus & DSBSTATUS_BUFFERLOST )
    {
        // Since the app could have just been activated, then
        // DirectSound may not be giving us control yet, so 
        // the restoring the buffer may fail.  
        // If it does, sleep until DirectSound gives us control.
        do 
        {
            hr = pDSB->Restore();
            if( hr == DSERR_BUFFERLOST )
                Sleep( 10 );
        }
        while( ( hr = pDSB->Restore() ) == DSERR_BUFFERLOST );

        if( pbWasRestored != NULL )
            *pbWasRestored = TRUE;

        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}




//-----------------------------------------------------------------------------
// Name: CSound::GetFreeBuffer()
// Desc: Finding the first buffer that is not playing and return a pointer to 
//       it, or if all are playing return a pointer to a randomly selected buffer.
//-----------------------------------------------------------------------------
LPDIRECTSOUNDBUFFER CSound::GetFreeBuffer()
{
    if( m_apDSBuffer == NULL )
        return FALSE; 
    DWORD i;
    for( i=0; i<m_dwNumBuffers; i++ )
    {
        if( m_apDSBuffer[i] )
        {  
            DWORD dwStatus = 0;
            m_apDSBuffer[i]->GetStatus( &dwStatus );
            if ( ( dwStatus & DSBSTATUS_PLAYING ) == 0 )
                break;
        }
    }

    if( i != m_dwNumBuffers )
        return m_apDSBuffer[ i ];
    else
        return m_apDSBuffer[ rand() % m_dwNumBuffers ];
}



//-----------------------------------------------------------------------------
// Name: CSound::Play()
// Desc: Plays the sound using voice management flags.  Pass in DSBPLAY_LOOPING
//       in the dwFlags to loop the sound
//-----------------------------------------------------------------------------
HRESULT CSound::Play( DWORD dwPriority, DWORD dwFlags, LONG lVolume, LONG lFrequency, LONG lPan )
{
    HRESULT hr;
    BOOL    bRestored;

    if( m_apDSBuffer == NULL )
        return CO_E_NOTINITIALIZED;

    LPDIRECTSOUNDBUFFER pDSB = GetFreeBuffer();

    if( pDSB == NULL )
        return DXTRACE_ERR( TEXT("GetFreeBuffer"), E_FAIL );

    // Restore the buffer if it was lost
    if( FAILED( hr = RestoreBuffer( pDSB, &bRestored ) ) )
        return DXTRACE_ERR( TEXT("RestoreBuffer"), hr );

    if( bRestored )
    {
        // The buffer was restored, so we need to fill it with new data
        if( FAILED( hr = FillBufferWithSound( pDSB, FALSE ) ) )
            return DXTRACE_ERR( TEXT("FillBufferWithSound"), hr );
    }

    if( m_dwCreationFlags & DSBCAPS_CTRLVOLUME )
    {
        pDSB->SetVolume( lVolume );
    }

    if( lFrequency != -1 && 
        (m_dwCreationFlags & DSBCAPS_CTRLFREQUENCY) )
    {
        pDSB->SetFrequency( lFrequency );
    }
    
    if( m_dwCreationFlags & DSBCAPS_CTRLPAN )
    {
        pDSB->SetPan( lPan );
    }
    
    return pDSB->Play( 0, dwPriority, dwFlags );
}



//-----------------------------------------------------------------------------
// Name: CSound::Stop()
// Desc: Stops the sound from playing
//-----------------------------------------------------------------------------
HRESULT CSound::Stop()
{
    if( m_apDSBuffer == NULL )
        return CO_E_NOTINITIALIZED;

    HRESULT hr = 0;

    for( DWORD i=0; i<m_dwNumBuffers; i++ )
        hr |= m_apDSBuffer[i]->Stop();

    return hr;
}




//-----------------------------------------------------------------------------
// Name: CSound::Reset()
// Desc: Reset all of the sound buffers
//-----------------------------------------------------------------------------
HRESULT CSound::Reset()
{
    if( m_apDSBuffer == NULL )
        return CO_E_NOTINITIALIZED;

    HRESULT hr = 0;

    for( DWORD i=0; i<m_dwNumBuffers; i++ )
        hr |= m_apDSBuffer[i]->SetCurrentPosition( 0 );

    return hr;
}




//-----------------------------------------------------------------------------
// Name: CSound::IsSoundPlaying()
// Desc: Checks to see if a buffer is playing and returns TRUE if it is.
//-----------------------------------------------------------------------------
BOOL CSound::IsSoundPlaying()
{
    BOOL bIsPlaying = FALSE;

    if( m_apDSBuffer == NULL )
        return FALSE; 

    for( DWORD i=0; i<m_dwNumBuffers; i++ )
    {
        if( m_apDSBuffer[i] )
        {  
            DWORD dwStatus = 0;
            m_apDSBuffer[i]->GetStatus( &dwStatus );
            bIsPlaying |= ( ( dwStatus & DSBSTATUS_PLAYING ) != 0 );
        }
    }

    return bIsPlaying;
}



//-----------------------------------------------------------------------------
// Name: CWaveFile::CWaveFile()
// Desc: Constructs the class.  Call Open() to open a wave file for reading.  
//       Then call Read() as needed.  Calling the destructor or Close() 
//       will close the file.  
//-----------------------------------------------------------------------------
CWaveFile::CWaveFile()
{
    m_pwfx    = NULL;
    m_hmmio   = NULL;
    m_pResourceBuffer = NULL;
    m_dwSize  = 0;
    m_bIsReadingFromMemory = FALSE;
}




//-----------------------------------------------------------------------------
// Name: CWaveFile::~CWaveFile()
// Desc: Destructs the class
//-----------------------------------------------------------------------------
CWaveFile::~CWaveFile()
{
    Close();

    if( !m_bIsReadingFromMemory )
        SAFE_DELETE_ARRAY( m_pwfx );
}




//-----------------------------------------------------------------------------
// Name: CWaveFile::Open()
// Desc: Opens a wave file for reading
//-----------------------------------------------------------------------------
HRESULT CWaveFile::Open( LPTSTR strFileName, WAVEFORMATEX* pwfx, DWORD dwFlags )
{
    HRESULT hr;

    m_dwFlags = dwFlags;
    m_bIsReadingFromMemory = FALSE;

    if( m_dwFlags == WAVEFILE_READ )
    {
        if( strFileName == NULL )
            return E_INVALIDARG;
        SAFE_DELETE_ARRAY( m_pwfx );

        m_hmmio = mmioOpen( strFileName, NULL, MMIO_ALLOCBUF | MMIO_READ );

        if( NULL == m_hmmio )
        {
            HRSRC   hResInfo;
            HGLOBAL hResData;
            DWORD   dwSize;
            VOID*   pvRes;

            // Loading it as a file failed, so try it as a resource
            if( NULL == ( hResInfo = FindResource( NULL, strFileName, TEXT("WAVE") ) ) )
            {
                if( NULL == ( hResInfo = FindResource( NULL, strFileName, TEXT("WAV") ) ) )
                    return DXTRACE_ERR( TEXT("FindResource"), E_FAIL );
            }

            if( NULL == ( hResData = LoadResource( NULL, hResInfo ) ) )
                return DXTRACE_ERR( TEXT("LoadResource"), E_FAIL );

            if( 0 == ( dwSize = SizeofResource( NULL, hResInfo ) ) ) 
                return DXTRACE_ERR( TEXT("SizeofResource"), E_FAIL );

            if( NULL == ( pvRes = LockResource( hResData ) ) )
                return DXTRACE_ERR( TEXT("LockResource"), E_FAIL );

            m_pResourceBuffer = new CHAR[ dwSize ];
            memcpy( m_pResourceBuffer, pvRes, dwSize );

            MMIOINFO mmioInfo;
            ZeroMemory( &mmioInfo, sizeof(mmioInfo) );
            mmioInfo.fccIOProc = FOURCC_MEM;
            mmioInfo.cchBuffer = dwSize;
            mmioInfo.pchBuffer = (CHAR*) m_pResourceBuffer;

            m_hmmio = mmioOpen( NULL, &mmioInfo, MMIO_ALLOCBUF | MMIO_READ );
        }

        if( FAILED( hr = ReadMMIO() ) )
        {
            // ReadMMIO will fail if its an not a wave file
            mmioClose( m_hmmio, 0 );
            return DXTRACE_ERR( TEXT("ReadMMIO"), hr );
        }

        if( FAILED( hr = ResetFile() ) )
            return DXTRACE_ERR( TEXT("ResetFile"), hr );

        // After the reset, the size of the wav file is m_ck.cksize so store it now
        m_dwSize = m_ck.cksize;
    }
    else
    {
        m_hmmio = mmioOpen( strFileName, NULL, MMIO_ALLOCBUF  | 
                                                  MMIO_READWRITE | 
                                                  MMIO_CREATE );
        if( NULL == m_hmmio )
            return DXTRACE_ERR( TEXT("mmioOpen"), E_FAIL );

        if( FAILED( hr = WriteMMIO( pwfx ) ) )
        {
            mmioClose( m_hmmio, 0 );
            return DXTRACE_ERR( TEXT("WriteMMIO"), hr );
        }
                        
        if( FAILED( hr = ResetFile() ) )
            return DXTRACE_ERR( TEXT("ResetFile"), hr );
    }

    return hr;
}



//-----------------------------------------------------------------------------
// Name: CWaveFile::ReadMMIO()
// Desc: Support function for reading from a multimedia I/O stream.
//       m_hmmio must be valid before calling.  This function uses it to
//       update m_ckRiff, and m_pwfx. 
//-----------------------------------------------------------------------------
HRESULT CWaveFile::ReadMMIO()
{
    MMCKINFO        ckIn;           // chunk info. for general use.
    PCMWAVEFORMAT   pcmWaveFormat;  // Temp PCM structure to load in.       

    m_pwfx = NULL;

    if( ( 0 != mmioDescend( m_hmmio, &m_ckRiff, NULL, 0 ) ) )
        return DXTRACE_ERR( TEXT("mmioDescend"), E_FAIL );

    // Check to make sure this is a valid wave file
    if( (m_ckRiff.ckid != FOURCC_RIFF) ||
        (m_ckRiff.fccType != mmioFOURCC('W', 'A', 'V', 'E') ) )
        return DXTRACE_ERR( TEXT("mmioFOURCC"), E_FAIL ); 

    // Search the input file for for the 'fmt ' chunk.
    ckIn.ckid = mmioFOURCC('f', 'm', 't', ' ');
    if( 0 != mmioDescend( m_hmmio, &ckIn, &m_ckRiff, MMIO_FINDCHUNK ) )
        return DXTRACE_ERR( TEXT("mmioDescend"), E_FAIL );

    // Expect the 'fmt' chunk to be at least as large as <PCMWAVEFORMAT>;
    // if there are extra parameters at the end, we'll ignore them
       if( ckIn.cksize < (LONG) sizeof(PCMWAVEFORMAT) )
           return DXTRACE_ERR( TEXT("sizeof(PCMWAVEFORMAT)"), E_FAIL );

    // Read the 'fmt ' chunk into <pcmWaveFormat>.
    if( mmioRead( m_hmmio, (HPSTR) &pcmWaveFormat, 
                  sizeof(pcmWaveFormat)) != sizeof(pcmWaveFormat) )
        return DXTRACE_ERR( TEXT("mmioRead"), E_FAIL );

    // Allocate the waveformatex, but if its not pcm format, read the next
    // word, and thats how many extra bytes to allocate.
    if( pcmWaveFormat.wf.wFormatTag == WAVE_FORMAT_PCM )
    {
        m_pwfx = (WAVEFORMATEX*)new CHAR[ sizeof(WAVEFORMATEX) ];
        if( NULL == m_pwfx )
            return DXTRACE_ERR( TEXT("m_pwfx"), E_FAIL );

        // Copy the bytes from the pcm structure to the waveformatex structure
        memcpy( m_pwfx, &pcmWaveFormat, sizeof(pcmWaveFormat) );
        m_pwfx->cbSize = 0;
    }
    else
    {
        // Read in length of extra bytes.
        WORD cbExtraBytes = 0L;
        if( mmioRead( m_hmmio, (CHAR*)&cbExtraBytes, sizeof(WORD)) != sizeof(WORD) )
            return DXTRACE_ERR( TEXT("mmioRead"), E_FAIL );

        m_pwfx = (WAVEFORMATEX*)new CHAR[ sizeof(WAVEFORMATEX) + cbExtraBytes ];
        if( NULL == m_pwfx )
            return DXTRACE_ERR( TEXT("new"), E_FAIL );

        // Copy the bytes from the pcm structure to the waveformatex structure
        memcpy( m_pwfx, &pcmWaveFormat, sizeof(pcmWaveFormat) );
        m_pwfx->cbSize = cbExtraBytes;

        // Now, read those extra bytes into the structure, if cbExtraAlloc != 0.
        if( mmioRead( m_hmmio, (CHAR*)(((BYTE*)&(m_pwfx->cbSize))+sizeof(WORD)),
                      cbExtraBytes ) != cbExtraBytes )
        {
            SAFE_DELETE( m_pwfx );
            return DXTRACE_ERR( TEXT("mmioRead"), E_FAIL );
        }
    }

    // Ascend the input file out of the 'fmt ' chunk.
    if( 0 != mmioAscend( m_hmmio, &ckIn, 0 ) )
    {
        SAFE_DELETE( m_pwfx );
        return DXTRACE_ERR( TEXT("mmioAscend"), E_FAIL );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CWaveFile::GetSize()
// Desc: Retuns the size of the read access wave file 
//-----------------------------------------------------------------------------
DWORD CWaveFile::GetSize()
{
    return m_dwSize;
}




//-----------------------------------------------------------------------------
// Name: CWaveFile::ResetFile()
// Desc: Resets the internal m_ck pointer so reading starts from the 
//       beginning of the file again 
//-----------------------------------------------------------------------------
HRESULT CWaveFile::ResetFile()
{
    if( m_bIsReadingFromMemory )
    {
        m_pbDataCur = m_pbData;
    }
    else 
    {
        if( m_hmmio == NULL )
            return CO_E_NOTINITIALIZED;

        if( m_dwFlags == WAVEFILE_READ )
        {
            // Seek to the data
            if( -1 == mmioSeek( m_hmmio, m_ckRiff.dwDataOffset + sizeof(FOURCC),
                            SEEK_SET ) )
                return DXTRACE_ERR( TEXT("mmioSeek"), E_FAIL );

            // Search the input file for the 'data' chunk.
            m_ck.ckid = mmioFOURCC('d', 'a', 't', 'a');
            if( 0 != mmioDescend( m_hmmio, &m_ck, &m_ckRiff, MMIO_FINDCHUNK ) )
              return DXTRACE_ERR( TEXT("mmioDescend"), E_FAIL );
        }
        else
        {
            // Create the 'data' chunk that holds the waveform samples.  
            m_ck.ckid = mmioFOURCC('d', 'a', 't', 'a');
            m_ck.cksize = 0;

            if( 0 != mmioCreateChunk( m_hmmio, &m_ck, 0 ) ) 
                return DXTRACE_ERR( TEXT("mmioCreateChunk"), E_FAIL );

            if( 0 != mmioGetInfo( m_hmmio, &m_mmioinfoOut, 0 ) )
                return DXTRACE_ERR( TEXT("mmioGetInfo"), E_FAIL );
        }
    }
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CWaveFile::Read()
// Desc: Reads section of data from a wave file into pBuffer and returns 
//       how much read in pdwSizeRead, reading not more than dwSizeToRead.
//       This uses m_ck to determine where to start reading from.  So 
//       subsequent calls will be continue where the last left off unless 
//       Reset() is called.
//-----------------------------------------------------------------------------
HRESULT CWaveFile::Read( BYTE* pBuffer, DWORD dwSizeToRead, DWORD* pdwSizeRead )
{
    if( m_bIsReadingFromMemory )
    {
        if( m_pbDataCur == NULL )
            return CO_E_NOTINITIALIZED;
        if( pdwSizeRead != NULL )
            *pdwSizeRead = 0;

        if( (BYTE*)(m_pbDataCur + dwSizeToRead) > 
            (BYTE*)(m_pbData + m_ulDataSize) )
        {
            dwSizeToRead = m_ulDataSize - (DWORD)(m_pbDataCur - m_pbData);
        }
        
        CopyMemory( pBuffer, m_pbDataCur, dwSizeToRead );
        
        if( pdwSizeRead != NULL )
            *pdwSizeRead = dwSizeToRead;

        return S_OK;
    }
    else 
    {
        MMIOINFO mmioinfoIn; // current status of m_hmmio

        if( m_hmmio == NULL )
            return CO_E_NOTINITIALIZED;
        if( pBuffer == NULL || pdwSizeRead == NULL )
            return E_INVALIDARG;

        if( pdwSizeRead != NULL )
            *pdwSizeRead = 0;

        if( 0 != mmioGetInfo( m_hmmio, &mmioinfoIn, 0 ) )
            return DXTRACE_ERR( TEXT("mmioGetInfo"), E_FAIL );
                
        UINT cbDataIn = dwSizeToRead;
        if( cbDataIn > m_ck.cksize ) 
            cbDataIn = m_ck.cksize;       

        m_ck.cksize -= cbDataIn;
    
        for( DWORD cT = 0; cT < cbDataIn; cT++ )
        {
            // Copy the bytes from the io to the buffer.
            if( mmioinfoIn.pchNext == mmioinfoIn.pchEndRead )
            {
                if( 0 != mmioAdvance( m_hmmio, &mmioinfoIn, MMIO_READ ) )
                    return DXTRACE_ERR( TEXT("mmioAdvance"), E_FAIL );

                if( mmioinfoIn.pchNext == mmioinfoIn.pchEndRead )
                    return DXTRACE_ERR( TEXT("mmioinfoIn.pchNext"), E_FAIL );
            }

            // Actual copy.
            *((BYTE*)pBuffer+cT) = *((BYTE*)mmioinfoIn.pchNext);
            mmioinfoIn.pchNext++;
        }

        if( 0 != mmioSetInfo( m_hmmio, &mmioinfoIn, 0 ) )
            return DXTRACE_ERR( TEXT("mmioSetInfo"), E_FAIL );

        if( pdwSizeRead != NULL )
            *pdwSizeRead = cbDataIn;

        return S_OK;
    }
}




//-----------------------------------------------------------------------------
// Name: CWaveFile::Close()
// Desc: Closes the wave file 
//-----------------------------------------------------------------------------
HRESULT CWaveFile::Close()
{
    if( m_dwFlags == WAVEFILE_READ )
    {
        mmioClose( m_hmmio, 0 );
        m_hmmio = NULL;
        SAFE_DELETE_ARRAY( m_pResourceBuffer );
    }
    else
    {
        m_mmioinfoOut.dwFlags |= MMIO_DIRTY;

        if( m_hmmio == NULL )
            return CO_E_NOTINITIALIZED;

        if( 0 != mmioSetInfo( m_hmmio, &m_mmioinfoOut, 0 ) )
            return DXTRACE_ERR( TEXT("mmioSetInfo"), E_FAIL );
    
        // Ascend the output file out of the 'data' chunk -- this will cause
        // the chunk size of the 'data' chunk to be written.
        if( 0 != mmioAscend( m_hmmio, &m_ck, 0 ) )
            return DXTRACE_ERR( TEXT("mmioAscend"), E_FAIL );
    
        // Do this here instead...
        if( 0 != mmioAscend( m_hmmio, &m_ckRiff, 0 ) )
            return DXTRACE_ERR( TEXT("mmioAscend"), E_FAIL );
        
        mmioSeek( m_hmmio, 0, SEEK_SET );

        if( 0 != (INT)mmioDescend( m_hmmio, &m_ckRiff, NULL, 0 ) )
            return DXTRACE_ERR( TEXT("mmioDescend"), E_FAIL );
    
        m_ck.ckid = mmioFOURCC('f', 'a', 'c', 't');

        if( 0 == mmioDescend( m_hmmio, &m_ck, &m_ckRiff, MMIO_FINDCHUNK ) ) 
        {
            DWORD dwSamples = 0;
            mmioWrite( m_hmmio, (HPSTR)&dwSamples, sizeof(DWORD) );
            mmioAscend( m_hmmio, &m_ck, 0 ); 
        }
    
        // Ascend the output file out of the 'RIFF' chunk -- this will cause
        // the chunk size of the 'RIFF' chunk to be written.
        if( 0 != mmioAscend( m_hmmio, &m_ckRiff, 0 ) )
            return DXTRACE_ERR( TEXT("mmioAscend"), E_FAIL );
    
        mmioClose( m_hmmio, 0 );
        m_hmmio = NULL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CWaveFile::WriteMMIO()
// Desc: Support function for reading from a multimedia I/O stream
//       pwfxDest is the WAVEFORMATEX for this new wave file.  
//       m_hmmio must be valid before calling.  This function uses it to
//       update m_ckRiff, and m_ck.  
//-----------------------------------------------------------------------------
HRESULT CWaveFile::WriteMMIO( WAVEFORMATEX *pwfxDest )
{
    DWORD    dwFactChunk; // Contains the actual fact chunk. Garbage until WaveCloseWriteFile.
    MMCKINFO ckOut1;
    
    dwFactChunk = (DWORD)-1;

    // Create the output file RIFF chunk of form type 'WAVE'.
    m_ckRiff.fccType = mmioFOURCC('W', 'A', 'V', 'E');       
    m_ckRiff.cksize = 0;

    if( 0 != mmioCreateChunk( m_hmmio, &m_ckRiff, MMIO_CREATERIFF ) )
        return DXTRACE_ERR( TEXT("mmioCreateChunk"), E_FAIL );
    
    // We are now descended into the 'RIFF' chunk we just created.
    // Now create the 'fmt ' chunk. Since we know the size of this chunk,
    // specify it in the MMCKINFO structure so MMIO doesn't have to seek
    // back and set the chunk size after ascending from the chunk.
    m_ck.ckid = mmioFOURCC('f', 'm', 't', ' ');
    m_ck.cksize = sizeof(PCMWAVEFORMAT);   

    if( 0 != mmioCreateChunk( m_hmmio, &m_ck, 0 ) )
        return DXTRACE_ERR( TEXT("mmioCreateChunk"), E_FAIL );
    
    // Write the PCMWAVEFORMAT structure to the 'fmt ' chunk if its that type. 
    if( pwfxDest->wFormatTag == WAVE_FORMAT_PCM )
    {
        if( mmioWrite( m_hmmio, (HPSTR) pwfxDest, 
                       sizeof(PCMWAVEFORMAT)) != sizeof(PCMWAVEFORMAT))
            return DXTRACE_ERR( TEXT("mmioWrite"), E_FAIL );
    }   
    else 
    {
        // Write the variable length size.
        if( (UINT)mmioWrite( m_hmmio, (HPSTR) pwfxDest, 
                             sizeof(*pwfxDest) + pwfxDest->cbSize ) != 
                             ( sizeof(*pwfxDest) + pwfxDest->cbSize ) )
            return DXTRACE_ERR( TEXT("mmioWrite"), E_FAIL );
    }  
    
    // Ascend out of the 'fmt ' chunk, back into the 'RIFF' chunk.
    if( 0 != mmioAscend( m_hmmio, &m_ck, 0 ) )
        return DXTRACE_ERR( TEXT("mmioAscend"), E_FAIL );
    
    // Now create the fact chunk, not required for PCM but nice to have.  This is filled
    // in when the close routine is called.
    ckOut1.ckid = mmioFOURCC('f', 'a', 'c', 't');
    ckOut1.cksize = 0;

    if( 0 != mmioCreateChunk( m_hmmio, &ckOut1, 0 ) )
        return DXTRACE_ERR( TEXT("mmioCreateChunk"), E_FAIL );
    
    if( mmioWrite( m_hmmio, (HPSTR)&dwFactChunk, sizeof(dwFactChunk)) != 
                    sizeof(dwFactChunk) )
         return DXTRACE_ERR( TEXT("mmioWrite"), E_FAIL );
    
    // Now ascend out of the fact chunk...
    if( 0 != mmioAscend( m_hmmio, &ckOut1, 0 ) )
        return DXTRACE_ERR( TEXT("mmioAscend"), E_FAIL );
       
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CWaveFile::Write()
// Desc: Writes data to the open wave file
//-----------------------------------------------------------------------------
HRESULT CWaveFile::Write( UINT nSizeToWrite, BYTE* pbSrcData, UINT* pnSizeWrote )
{
    UINT cT;

    if( m_bIsReadingFromMemory )
        return E_NOTIMPL;
    if( m_hmmio == NULL )
        return CO_E_NOTINITIALIZED;
    if( pnSizeWrote == NULL || pbSrcData == NULL )
        return E_INVALIDARG;

    *pnSizeWrote = 0;
    
    for( cT = 0; cT < nSizeToWrite; cT++ )
    {       
        if( m_mmioinfoOut.pchNext == m_mmioinfoOut.pchEndWrite )
        {
            m_mmioinfoOut.dwFlags |= MMIO_DIRTY;
            if( 0 != mmioAdvance( m_hmmio, &m_mmioinfoOut, MMIO_WRITE ) )
                return DXTRACE_ERR( TEXT("mmioAdvance"), E_FAIL );
        }

        *((BYTE*)m_mmioinfoOut.pchNext) = *((BYTE*)pbSrcData+cT);
        (BYTE*)m_mmioinfoOut.pchNext++;

        (*pnSizeWrote)++;
    }

    return S_OK;
}





```

`Source Code/DirectSound.h`:

```h
//-----------------------------------------------------------------------------
// File: DSUtil.h
//
// Desc: 
//
// Copyright (c) Microsoft Corp. All rights reserved.
//-----------------------------------------------------------------------------
//
// Note: This file has been edited for use in Beginning Game Programming, Third Edition,
// originally distributed with a 2004 release of DirectX 9.0c SDK.
//

#ifndef DSUTIL_H
#define DSUTIL_H

#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <dsound.h>


//-----------------------------------------------------------------------------
// Classes used by this header
//-----------------------------------------------------------------------------
class CSoundManager;
class CSound;
class CStreamingSound;
class CWaveFile;




//-----------------------------------------------------------------------------
// Typing macros 
//-----------------------------------------------------------------------------
#define WAVEFILE_READ   1
#define WAVEFILE_WRITE  2

#define DSUtil_StopSound(s)         { if(s) s->Stop(); }
#define DSUtil_PlaySound(s)         { if(s) s->Play( 0, 0 ); }
#define DSUtil_PlaySoundLooping(s)  { if(s) s->Play( 0, DSBPLAY_LOOPING ); }




//-----------------------------------------------------------------------------
// Name: class CSoundManager
// Desc: 
//-----------------------------------------------------------------------------
class CSoundManager
{
protected:
    LPDIRECTSOUND8 m_pDS;

public:
    CSoundManager();
    ~CSoundManager();

    HRESULT Initialize( HWND hWnd, DWORD dwCoopLevel );
    inline  LPDIRECTSOUND8 GetDirectSound() { return m_pDS; }
    HRESULT SetPrimaryBufferFormat( DWORD dwPrimaryChannels, DWORD dwPrimaryFreq, DWORD dwPrimaryBitRate );

    HRESULT Create( CSound** ppSound, LPTSTR strWaveFileName, DWORD dwCreationFlags = 0, GUID guid3DAlgorithm = GUID_NULL, DWORD dwNumBuffers = 1 );
};




//-----------------------------------------------------------------------------
// Name: class CSound
// Desc: Encapsulates functionality of a DirectSound buffer.
//-----------------------------------------------------------------------------
class CSound
{
protected:
    LPDIRECTSOUNDBUFFER* m_apDSBuffer;
    DWORD                m_dwDSBufferSize;
    CWaveFile*           m_pWaveFile;
    DWORD                m_dwNumBuffers;
    DWORD                m_dwCreationFlags;

    HRESULT RestoreBuffer( LPDIRECTSOUNDBUFFER pDSB, BOOL* pbWasRestored );

public:
    CSound( LPDIRECTSOUNDBUFFER* apDSBuffer, DWORD dwDSBufferSize, DWORD dwNumBuffers, CWaveFile* pWaveFile, DWORD dwCreationFlags );
    virtual ~CSound();

    HRESULT FillBufferWithSound( LPDIRECTSOUNDBUFFER pDSB, BOOL bRepeatWavIfBufferLarger );
    LPDIRECTSOUNDBUFFER GetFreeBuffer();

    HRESULT Play( DWORD dwPriority = 0, DWORD dwFlags = 0, LONG lVolume = 0, LONG lFrequency = -1, LONG lPan = 0 );
    HRESULT Stop();
    HRESULT Reset();
    BOOL    IsSoundPlaying();
};


//-----------------------------------------------------------------------------
// Name: class CWaveFile
// Desc: Encapsulates reading or writing sound data to or from a wave file
//-----------------------------------------------------------------------------
class CWaveFile
{
public:
    WAVEFORMATEX* m_pwfx;        // Pointer to WAVEFORMATEX structure
    HMMIO         m_hmmio;       // MM I/O handle for the WAVE
    MMCKINFO      m_ck;          // Multimedia RIFF chunk
    MMCKINFO      m_ckRiff;      // Use in opening a WAVE file
    DWORD         m_dwSize;      // The size of the wave file
    MMIOINFO      m_mmioinfoOut;
    DWORD         m_dwFlags;
    BOOL          m_bIsReadingFromMemory;
    BYTE*         m_pbData;
    BYTE*         m_pbDataCur;
    ULONG         m_ulDataSize;
    CHAR*         m_pResourceBuffer;

protected:
    HRESULT ReadMMIO();
    HRESULT WriteMMIO( WAVEFORMATEX *pwfxDest );

public:
    CWaveFile();
    ~CWaveFile();

    HRESULT Open( LPTSTR strFileName, WAVEFORMATEX* pwfx, DWORD dwFlags );
    HRESULT Close();

    HRESULT Read( BYTE* pBuffer, DWORD dwSizeToRead, DWORD* pdwSizeRead );
    HRESULT Write( UINT nSizeToWrite, BYTE* pbData, UINT* pnSizeWrote );

    DWORD   GetSize();
    HRESULT ResetFile();
    WAVEFORMATEX* GetFormat() { return m_pwfx; };
};




#endif // DSUTIL_H

```

`Source Code/Effects11/Binary/EffectBinaryFormat.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       Effect.h
//  Content:    D3DX11 Effects Binary Format
//              This is the binary file interface shared between the Effects 
//              compiler and runtime.
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

namespace D3DX11Effects
{


//////////////////////////////////////////////////////////////////////////
// Version Control
//////////////////////////////////////////////////////////////////////////

#define D3D10_FXL_VERSION(_Major,_Minor) (('F' << 24) | ('X' << 16) | ((_Major) << 8) | (_Minor))

struct EVersionTag
{
    const char* m_pName;
    DWORD       m_Version;
    UINT        m_Tag;
};

// versions must be listed in ascending order
static CONST EVersionTag g_EffectVersions[] = 
{
    { "fx_4_0", D3D10_FXL_VERSION(4,0),   0xFEFF1001 },
    { "fx_4_1", D3D10_FXL_VERSION(4,1),   0xFEFF1011 },
    { "fx_5_0", D3D10_FXL_VERSION(5,0),   0xFEFF2001 },
};
#define NUM_EFFECT10_VERSIONS ( sizeof(g_EffectVersions) / sizeof(EVersionTag) )


//////////////////////////////////////////////////////////////////////////
// Reflection & Type structures
//////////////////////////////////////////////////////////////////////////

// Enumeration of the possible left-hand side values of an assignment,
// divided up categorically by the type of block they may appear in
enum ELhsType
{
    ELHS_Invalid,

    // Pass block assignment types

    ELHS_PixelShaderBlock,          // SBlock *pValue points to the block to apply
    ELHS_VertexShaderBlock,
    ELHS_GeometryShaderBlock,
    ELHS_RenderTargetView,
    ELHS_DepthStencilView,

    ELHS_RasterizerBlock,
    ELHS_DepthStencilBlock,
    ELHS_BlendBlock,

    ELHS_GenerateMips,              // This is really a call to D3D::GenerateMips

    // Various SAssignment.Value.*

    ELHS_DS_StencilRef,             // SAssignment.Value.pdValue
    ELHS_B_BlendFactor,             // D3D10_BLEND_CONFIG.BlendFactor, points to a float4
    ELHS_B_SampleMask,              // D3D10_BLEND_CONFIG.SampleMask

    ELHS_GeometryShaderSO,          // When setting SO assignments, GeometryShaderSO precedes the actual GeometryShader assn

    ELHS_ComputeShaderBlock,   
    ELHS_HullShaderBlock,
    ELHS_DomainShaderBlock,

    // Rasterizer

    ELHS_FillMode = 0x20000,
    ELHS_CullMode,
    ELHS_FrontCC,
    ELHS_DepthBias,
    ELHS_DepthBiasClamp,
    ELHS_SlopeScaledDepthBias,
    ELHS_DepthClipEnable,
    ELHS_ScissorEnable,
    ELHS_MultisampleEnable,
    ELHS_AntialiasedLineEnable,

    // Sampler

    ELHS_Filter = 0x30000,
    ELHS_AddressU,
    ELHS_AddressV,
    ELHS_AddressW,
    ELHS_MipLODBias,
    ELHS_MaxAnisotropy,
    ELHS_ComparisonFunc,
    ELHS_BorderColor,
    ELHS_MinLOD,
    ELHS_MaxLOD,
    ELHS_Texture,

    // DepthStencil

    ELHS_DepthEnable = 0x40000,
    ELHS_DepthWriteMask,
    ELHS_DepthFunc,
    ELHS_StencilEnable,
    ELHS_StencilReadMask,
    ELHS_StencilWriteMask,
    ELHS_FrontFaceStencilFailOp,
    ELHS_FrontFaceStencilDepthFailOp,
    ELHS_FrontFaceStencilPassOp,
    ELHS_FrontFaceStencilFunc,
    ELHS_BackFaceStencilFailOp,
    ELHS_BackFaceStencilDepthFailOp,
    ELHS_BackFaceStencilPassOp,
    ELHS_BackFaceStencilFunc,

    // BlendState

    ELHS_AlphaToCoverage = 0x50000,
    ELHS_BlendEnable,
    ELHS_SrcBlend,
    ELHS_DestBlend,
    ELHS_BlendOp,
    ELHS_SrcBlendAlpha,
    ELHS_DestBlendAlpha,
    ELHS_BlendOpAlpha,
    ELHS_RenderTargetWriteMask,
};



enum EBlockType
{
    EBT_Invalid,
    EBT_DepthStencil,
    EBT_Blend,
    EBT_Rasterizer,
    EBT_Sampler,
    EBT_Pass
};

enum EVarType
{
    EVT_Invalid,
    EVT_Numeric,
    EVT_Object,
    EVT_Struct,
    EVT_Interface,
};

enum EScalarType
{
    EST_Invalid,
    EST_Float,
    EST_Int,
    EST_UInt,
    EST_Bool,
    EST_Count
};

enum ENumericLayout
{
    ENL_Invalid,
    ENL_Scalar,
    ENL_Vector,
    ENL_Matrix,
    ENL_Count
};

enum EObjectType
{
    EOT_Invalid,
    EOT_String,
    EOT_Blend,
    EOT_DepthStencil,
    EOT_Rasterizer,
    EOT_PixelShader,
    EOT_VertexShader,
    EOT_GeometryShader,              // Regular geometry shader
    EOT_GeometryShaderSO,            // Geometry shader with a attached StreamOut decl
    EOT_Texture,
    EOT_Texture1D,
    EOT_Texture1DArray,
    EOT_Texture2D,
    EOT_Texture2DArray,
    EOT_Texture2DMS,
    EOT_Texture2DMSArray,
    EOT_Texture3D,
    EOT_TextureCube,
    EOT_ConstantBuffer,
    EOT_RenderTargetView,
    EOT_DepthStencilView,
    EOT_Sampler,
    EOT_Buffer,
    EOT_TextureCubeArray,
    EOT_Count,
    EOT_PixelShader5,
    EOT_VertexShader5,
    EOT_GeometryShader5,
    EOT_ComputeShader5,
    EOT_HullShader5,
    EOT_DomainShader5,
    EOT_RWTexture1D,
    EOT_RWTexture1DArray,
    EOT_RWTexture2D,
    EOT_RWTexture2DArray,
    EOT_RWTexture3D,
    EOT_RWBuffer,
    EOT_ByteAddressBuffer,
    EOT_RWByteAddressBuffer,
    EOT_StructuredBuffer,
    EOT_RWStructuredBuffer,
    EOT_RWStructuredBufferAlloc,
    EOT_RWStructuredBufferConsume,
    EOT_AppendStructuredBuffer,
    EOT_ConsumeStructuredBuffer,
};

D3DX11INLINE BOOL IsObjectTypeHelper(EVarType InVarType,
                                     EObjectType InObjType,
                                     EObjectType TargetObjType)
{
    return (InVarType == EVT_Object) && (InObjType == TargetObjType);
}

D3DX11INLINE BOOL IsSamplerHelper(EVarType InVarType,
                                  EObjectType InObjType)
{
    return (InVarType == EVT_Object) && (InObjType == EOT_Sampler);
}

D3DX11INLINE BOOL IsStateBlockObjectHelper(EVarType InVarType,
                                           EObjectType InObjType)
{
    return (InVarType == EVT_Object) && ((InObjType == EOT_Blend) || (InObjType == EOT_DepthStencil) || (InObjType == EOT_Rasterizer) || IsSamplerHelper(InVarType, InObjType));
}

D3DX11INLINE BOOL IsShaderHelper(EVarType InVarType,
                                 EObjectType InObjType)
{
    return (InVarType == EVT_Object) && ((InObjType == EOT_VertexShader) ||
                                         (InObjType == EOT_VertexShader5) ||
                                         (InObjType == EOT_HullShader5) ||
                                         (InObjType == EOT_DomainShader5) ||
                                         (InObjType == EOT_ComputeShader5) ||
                                         (InObjType == EOT_GeometryShader) ||
                                         (InObjType == EOT_GeometryShaderSO) ||
                                         (InObjType == EOT_GeometryShader5) ||
                                         (InObjType == EOT_PixelShader) ||
                                         (InObjType == EOT_PixelShader5));
}

D3DX11INLINE BOOL IsShader5Helper(EVarType InVarType,
                                  EObjectType InObjType)
{
    return (InVarType == EVT_Object) && ((InObjType == EOT_VertexShader5) ||
                                         (InObjType == EOT_HullShader5) ||
                                         (InObjType == EOT_DomainShader5) ||
                                         (InObjType == EOT_ComputeShader5) ||
                                         (InObjType == EOT_GeometryShader5) ||
                                         (InObjType == EOT_PixelShader5));
}

D3DX11INLINE BOOL IsInterfaceHelper(EVarType InVarType,
                                         EObjectType InObjType)
{
    return (InVarType == EVT_Interface);
}

D3DX11INLINE BOOL IsShaderResourceHelper(EVarType InVarType,
                                         EObjectType InObjType)
{
    return (InVarType == EVT_Object) && ((InObjType == EOT_Texture) ||
                                         (InObjType == EOT_Texture1D) || 
                                         (InObjType == EOT_Texture1DArray) ||
                                         (InObjType == EOT_Texture2D) || 
                                         (InObjType == EOT_Texture2DArray) ||
                                         (InObjType == EOT_Texture2DMS) || 
                                         (InObjType == EOT_Texture2DMSArray) ||
                                         (InObjType == EOT_Texture3D) || 
                                         (InObjType == EOT_TextureCube) ||
                                         (InObjType == EOT_TextureCubeArray) || 
                                         (InObjType == EOT_Buffer) ||
                                         (InObjType == EOT_StructuredBuffer) ||
                                         (InObjType == EOT_ByteAddressBuffer));
}

D3DX11INLINE BOOL IsUnorderedAccessViewHelper(EVarType InVarType,
                                              EObjectType InObjType)
{
    return (InVarType == EVT_Object) &&
        ((InObjType == EOT_RWTexture1D) ||
         (InObjType == EOT_RWTexture1DArray) ||
         (InObjType == EOT_RWTexture2D) ||
         (InObjType == EOT_RWTexture2DArray) ||
         (InObjType == EOT_RWTexture3D) ||
         (InObjType == EOT_RWBuffer) ||
         (InObjType == EOT_RWByteAddressBuffer) ||
         (InObjType == EOT_RWStructuredBuffer) ||
         (InObjType == EOT_RWStructuredBufferAlloc) ||
         (InObjType == EOT_RWStructuredBufferConsume) ||
         (InObjType == EOT_AppendStructuredBuffer) ||
         (InObjType == EOT_ConsumeStructuredBuffer));
}

D3DX11INLINE BOOL IsRenderTargetViewHelper(EVarType InVarType,
                                           EObjectType InObjType)
{
    return (InVarType == EVT_Object) && (InObjType == EOT_RenderTargetView);
}

D3DX11INLINE BOOL IsDepthStencilViewHelper(EVarType InVarType,
                                           EObjectType InObjType)
{
    return (InVarType == EVT_Object) && (InObjType == EOT_DepthStencilView);
}

D3DX11INLINE BOOL IsObjectAssignmentHelper(ELhsType LhsType)
{
    switch(LhsType)
    {
    case ELHS_VertexShaderBlock:
    case ELHS_HullShaderBlock:
    case ELHS_DepthStencilView:
    case ELHS_GeometryShaderBlock:
    case ELHS_PixelShaderBlock:
    case ELHS_ComputeShaderBlock:
    case ELHS_DepthStencilBlock:
    case ELHS_RasterizerBlock:
    case ELHS_BlendBlock:
    case ELHS_Texture:
    case ELHS_RenderTargetView:
    case ELHS_DomainShaderBlock:
        return TRUE;
    }
    return FALSE;
}




// Effect file format structures /////////////////////////////////////////////
// File format:
//   File header (SBinaryHeader Header)
//   Unstructured data block (BYTE[Header.cbUnstructured))
//   Structured data block
//     ConstantBuffer (SBinaryConstantBuffer CB) * Header.Effect.cCBs
//       UINT  NumAnnotations
//       Annotation data (SBinaryAnnotation) * (NumAnnotations) *this structure is variable sized
//       Variable data (SBinaryNumericVariable Var) * (CB.cVariables)
//         UINT  NumAnnotations
//         Annotation data (SBinaryAnnotation) * (NumAnnotations) *this structure is variable sized
//     Object variables (SBinaryObjectVariable Var) * (Header.cObjectVariables) *this structure is variable sized
//       UINT  NumAnnotations
//       Annotation data (SBinaryAnnotation) * (NumAnnotations) *this structure is variable sized
//     Interface variables (SBinaryInterfaceVariable Var) * (Header.cInterfaceVariables) *this structure is variable sized
//       UINT  NumAnnotations
//       Annotation data (SBinaryAnnotation) * (NumAnnotations) *this structure is variable sized
//     Groups (SBinaryGroup Group) * Header.cGroups
//       UINT  NumAnnotations
//       Annotation data (SBinaryAnnotation) * (NumAnnotations) *this structure is variable sized
//       Techniques (SBinaryTechnique Technique) * Group.cTechniques
//         UINT  NumAnnotations
//         Annotation data (SBinaryAnnotation) * (NumAnnotations) *this structure is variable sized
//         Pass (SBinaryPass Pass) * Technique.cPasses
//           UINT  NumAnnotations
//           Annotation data (SBinaryAnnotation) * (NumAnnotations) *this structure is variable sized
//           Pass assignments (SBinaryAssignment) * Pass.cAssignments

struct SBinaryHeader
{
    struct SVarCounts
    {
        UINT  cCBs;
        UINT  cNumericVariables;
        UINT  cObjectVariables;
    };

    UINT        Tag;    // should be equal to c_EffectFileTag
                        // this is used to identify ASCII vs Binary files

    SVarCounts  Effect;
    SVarCounts  Pool;
    
    UINT        cTechniques;
    UINT        cbUnstructured;

    UINT        cStrings;
    UINT        cShaderResources;

    UINT        cDepthStencilBlocks;
    UINT        cBlendStateBlocks;
    UINT        cRasterizerStateBlocks;
    UINT        cSamplers;
    UINT        cRenderTargetViews;
    UINT        cDepthStencilViews;

    UINT        cTotalShaders;
    UINT        cInlineShaders; // of the aforementioned shaders, the number that are defined inline within pass blocks

    D3DX11INLINE bool RequiresPool() const
    {
        return (Pool.cCBs != 0) ||
               (Pool.cNumericVariables != 0) ||
               (Pool.cObjectVariables != 0);
    }
};

struct SBinaryHeader5 : public SBinaryHeader
{
    UINT  cGroups;
    UINT  cUnorderedAccessViews;
    UINT  cInterfaceVariables;
    UINT  cInterfaceVariableElements;
    UINT  cClassInstanceElements;
};

// Constant buffer definition
struct SBinaryConstantBuffer
{
    // private flags
    static const UINT   c_IsTBuffer = (1 << 0);
    static const UINT   c_IsSingle = (1 << 1);

    UINT                oName;                // Offset to constant buffer name
    UINT                Size;                 // Size, in bytes
    UINT                Flags;
    UINT                cVariables;           // # of variables inside this buffer
    UINT                ExplicitBindPoint;    // Defined if the effect file specifies a bind point using the register keyword
                                              // otherwise, -1
};

struct SBinaryAnnotation
{
    UINT  oName;                // Offset to variable name
    UINT  oType;                // Offset to type information (SBinaryType)

    // For numeric annotations:
    // UINT  oDefaultValue;     // Offset to default initializer value
    //
    // For string annotations:
    // UINT  oStringOffsets[Elements]; // Elements comes from the type data at oType
};

struct SBinaryNumericVariable
{
    UINT  oName;                // Offset to variable name
    UINT  oType;                // Offset to type information (SBinaryType)
    UINT  oSemantic;            // Offset to semantic information
    UINT  Offset;               // Offset in parent constant buffer
    UINT  oDefaultValue;        // Offset to default initializer value
    UINT  Flags;                // Explicit bind point
};

struct SBinaryInterfaceVariable
{
    UINT  oName;                // Offset to variable name
    UINT  oType;                // Offset to type information (SBinaryType)
    UINT  oDefaultValue;        // Offset to default initializer array (SBinaryInterfaceInitializer[Elements])
    UINT  Flags;
};

struct SBinaryInterfaceInitializer
{
    UINT  oInstanceName;
    UINT  ArrayIndex;
};

struct SBinaryObjectVariable
{
    UINT  oName;                // Offset to variable name
    UINT  oType;                // Offset to type information (SBinaryType)
    UINT  oSemantic;            // Offset to semantic information
    UINT  ExplicitBindPoint;    // Used when a variable has been explicitly bound (register(XX)). -1 if not

    // Initializer data:
    //
    // The type structure pointed to by oType gives you Elements, 
    // VarType (must be EVT_Object), and ObjectType
    //
    // For ObjectType == EOT_Blend, EOT_DepthStencil, EOT_Rasterizer, EOT_Sampler
    // struct 
    // {
    //   UINT  cAssignments;
    //   SBinaryAssignment Assignments[cAssignments];
    // } Blocks[Elements]
    //
    // For EObjectType == EOT_Texture*, EOT_Buffer
    // <nothing>
    //
    // For EObjectType == EOT_*Shader, EOT_String
    // UINT  oData[Elements]; // offsets to a shader data block or a NULL-terminated string
    //
    // For EObjectType == EOT_GeometryShaderSO
    //   SBinaryGSSOInitializer[Elements]
    //
    // For EObjectType == EOT_*Shader5
    //   SBinaryShaderData5[Elements]
};

struct SBinaryGSSOInitializer
{
    UINT  oShader;              // Offset to shader bytecode data block
    UINT  oSODecl;              // Offset to StreamOutput decl string
};

struct SBinaryShaderData5
{
    UINT  oShader;              // Offset to shader bytecode data block
    UINT  oSODecls[4];          // Offset to StreamOutput decl strings
    UINT  cSODecls;             // Count of valid oSODecls entries.
    UINT  RasterizedStream;     // Which stream is used for rasterization
    UINT  cInterfaceBindings;   // Count of interface bindings.
    UINT  oInterfaceBindings;   // Offset to SBinaryInterfaceInitializer[cInterfaceBindings].
};

struct SBinaryType
{
    UINT        oTypeName;      // Offset to friendly type name ("float4", "VS_OUTPUT")
    EVarType    VarType;        // Numeric, Object, or Struct
    UINT        Elements;       // # of array elements (0 for non-arrays)
    UINT        TotalSize;      // Size in bytes; not necessarily Stride * Elements for arrays 
                                // because of possible gap left in final register
    UINT        Stride;         // If an array, this is the spacing between elements.
                                // For unpacked arrays, always divisible by 16-bytes (1 register).
                                // No support for packed arrays    
    UINT        PackedSize;     // Size, in bytes, of this data typed when fully packed

    struct SBinaryMember
    {
        UINT    oName;          // Offset to structure member name ("m_pFoo")
        UINT    oSemantic;      // Offset to semantic ("POSITION0")
        UINT    Offset;         // Offset, in bytes, relative to start of parent structure
        UINT    oType;          // Offset to member's type descriptor
    };

    // the data that follows depends on the VarType:
    // Numeric: SType::SNumericType
    // Object:  EObjectType
    // Struct:  
    //   struct
    //   {
    //        UINT              cMembers;
    //        SBinaryMembers    Members[cMembers];
    //   } MemberInfo
    //   struct
    //   {
    //        UINT              oBaseClassType;  // Offset to type information (SBinaryType)
    //        UINT              cInterfaces;
    //        UINT              oInterfaceTypes[cInterfaces];
    //   } SBinaryTypeInheritance
    // Interface: (nothing)
};

struct SBinaryNumericType
{
    ENumericLayout  NumericLayout   : 3;    // scalar (1x1), vector (1xN), matrix (NxN)
    EScalarType     ScalarType      : 5;    // float32, int32, int8, etc.
    UINT            Rows            : 3;    // 1 <= Rows <= 4
    UINT            Columns         : 3;    // 1 <= Columns <= 4
    UINT            IsColumnMajor   : 1;    // applies only to matrices
    UINT            IsPackedArray   : 1;    // if this is an array, indicates whether elements should be greedily packed
};

struct SBinaryTypeInheritance
{
    UINT oBaseClass;            // Offset to base class type info or 0 if no base class.
    UINT cInterfaces;

    // Followed by UINT[cInterfaces] with offsets to the type
    // info of each interface.
};

struct SBinaryGroup
{
    UINT  oName;
    UINT  cTechniques;
};

struct SBinaryTechnique
{
    UINT  oName;
    UINT  cPasses;
};

struct SBinaryPass
{
    UINT  oName;
    UINT  cAssignments;
};

enum ECompilerAssignmentType
{
    ECAT_Invalid,                   // Assignment-specific data (always in the unstructured blob)
    ECAT_Constant,                  // -N SConstant structures
    ECAT_Variable,                  // -NULL terminated string with variable name ("foo")
    ECAT_ConstIndex,                // -SConstantIndex structure
    ECAT_VariableIndex,             // -SVariableIndex structure
    ECAT_ExpressionIndex,           // -SIndexedObjectExpression structure
    ECAT_Expression,                // -Data block containing FXLVM code
    ECAT_InlineShader,              // -Data block containing shader
    ECAT_InlineShader5,             // -Data block containing shader with extended 5.0 data (SBinaryShaderData5)
};

struct SBinaryAssignment
{
    UINT  iState;                   // index into g_lvGeneral
    UINT  Index;                    // the particular index to assign to (see g_lvGeneral to find the # of valid indices)
    ECompilerAssignmentType AssignmentType;
    UINT  oInitializer;             // Offset of assignment-specific data

    //struct SConstantAssignment
    //{
    //    UINT  NumConstants;         // number of constants to follow
    //    SCompilerConstant Constants[NumConstants];
    //};

    struct SConstantIndex
    {
        UINT  oArrayName;
        UINT  Index;
    };

    struct SVariableIndex
    {
        UINT  oArrayName;
        UINT  oIndexVarName;
    };

    struct SIndexedObjectExpression
    {   
        UINT  oArrayName;
        UINT  oCode;
    };

    struct SInlineShader
    {
        UINT  oShader;
        UINT  oSODecl;
    };

    //struct SExpression or SInlineShader
    //{
    //    UINT  DataSize;
    //    BYTE Data[DataSize];
    //}

};

struct SBinaryConstant
{
    EScalarType Type;
    union
    {
        BOOL    bValue;
        INT     iValue;
        float   fValue;
    };
};


} // end namespace D3DX11Effects

```

`Source Code/Effects11/Binary/EffectStateBase11.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       EffectStateBase11.h
//  Content:    D3DX11 Effects States Header
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

namespace D3DX11Effects
{

//////////////////////////////////////////////////////////////////////////
// Effect HLSL states and late resolve lists
//////////////////////////////////////////////////////////////////////////

struct RValue
{
    const char  *m_pName;
    UINT        m_Value;
};

#define RVALUE_END()    { NULL, 0U }
#define RVALUE_ENTRY(prefix, x)         { #x, (UINT)prefix##x }

enum ELhsType;

struct LValue
{
    const char      *m_pName;           // name of the LHS side of expression
    EBlockType      m_BlockType;        // type of block it can appear in
    D3D10_SHADER_VARIABLE_TYPE m_Type;  // data type allows
    UINT            m_Cols;             // number of [m_Type]'s required (1 for a scalar, 4 for a vector)
    UINT            m_Indices;          // max index allowable (if LHS is an array; otherwise this is 1)
    BOOL            m_VectorScalar;     // can be both vector and scalar (setting as a scalar sets all m_Indices values simultaneously)
    CONST RValue    *m_pRValue;         // pointer to table of allowable RHS "late resolve" values
    ELhsType        m_LhsType;          // ELHS_* enum value that corresponds to this entry
    UINT            m_Offset;           // offset into the given block type where this value should be written
    UINT            m_Stride;           // for vectors, byte stride between two consecutive values. if 0, m_Type's size is used
};

#define LVALUE_END()    { NULL, D3D10_SVT_UINT, 0, 0, 0, NULL }

extern CONST LValue g_lvGeneral[];
extern CONST UINT   g_lvGeneralCount;

} // end namespace D3DX11Effects

```

`Source Code/Effects11/Binary/EffectStates11.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       EffectStates11.h
//  Content:    D3DX11 Effects States Header
//              This file defines properties of states which can appear in
//              state blocks and pass blocks.
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include <EffectStateBase11.h>

namespace D3DX11Effects
{

//////////////////////////////////////////////////////////////////////////
// Effect HLSL late resolve lists (state values)
//////////////////////////////////////////////////////////////////////////

static CONST RValue g_rvNULL[] =
{
    { "NULL",  0 },
    RVALUE_END()
};


static CONST RValue g_rvBOOL[] =
{
    { "FALSE",  0 },
    { "TRUE",   1 },
    RVALUE_END()
};

static CONST RValue g_rvDEPTH_WRITE_MASK[] =
{
    { "ZERO",   D3D10_DEPTH_WRITE_MASK_ZERO     },
    { "ALL",    D3D10_DEPTH_WRITE_MASK_ALL      },
    RVALUE_END()
};

static CONST RValue g_rvFILL[] =
{
    { "WIREFRAME",  D3D10_FILL_WIREFRAME },
    { "SOLID",      D3D10_FILL_SOLID     },
    RVALUE_END()
};

static CONST RValue g_rvFILTER[] =
{
    RVALUE_ENTRY(D3D10_FILTER_,     MIN_MAG_MIP_POINT                           ),
    RVALUE_ENTRY(D3D10_FILTER_,     MIN_MAG_POINT_MIP_LINEAR                    ),
    RVALUE_ENTRY(D3D10_FILTER_,     MIN_POINT_MAG_LINEAR_MIP_POINT              ),
    RVALUE_ENTRY(D3D10_FILTER_,     MIN_POINT_MAG_MIP_LINEAR                    ),
    RVALUE_ENTRY(D3D10_FILTER_,     MIN_LINEAR_MAG_MIP_POINT                    ),
    RVALUE_ENTRY(D3D10_FILTER_,     MIN_LINEAR_MAG_POINT_MIP_LINEAR             ),
    RVALUE_ENTRY(D3D10_FILTER_,     MIN_MAG_LINEAR_MIP_POINT                    ),
    RVALUE_ENTRY(D3D10_FILTER_,     MIN_MAG_MIP_LINEAR                          ),
    RVALUE_ENTRY(D3D10_FILTER_,     ANISOTROPIC                                 ),
    RVALUE_ENTRY(D3D10_FILTER_,     COMPARISON_MIN_MAG_MIP_POINT                ),
    RVALUE_ENTRY(D3D10_FILTER_,     COMPARISON_MIN_MAG_POINT_MIP_LINEAR         ),
    RVALUE_ENTRY(D3D10_FILTER_,     COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT   ),
    RVALUE_ENTRY(D3D10_FILTER_,     COMPARISON_MIN_POINT_MAG_MIP_LINEAR         ),
    RVALUE_ENTRY(D3D10_FILTER_,     COMPARISON_MIN_LINEAR_MAG_MIP_POINT         ),
    RVALUE_ENTRY(D3D10_FILTER_,     COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR  ),
    RVALUE_ENTRY(D3D10_FILTER_,     COMPARISON_MIN_MAG_LINEAR_MIP_POINT         ),
    RVALUE_ENTRY(D3D10_FILTER_,     COMPARISON_MIN_MAG_MIP_LINEAR               ),
    RVALUE_ENTRY(D3D10_FILTER_,     COMPARISON_ANISOTROPIC                      ),
    RVALUE_ENTRY(D3D10_FILTER_,     TEXT_1BIT                                   ),
    RVALUE_END()
};

static CONST RValue g_rvBLEND[] =
{
    { "ZERO",               D3D10_BLEND_ZERO            },
    { "ONE",                D3D10_BLEND_ONE             },
    { "SRC_COLOR",          D3D10_BLEND_SRC_COLOR        },
    { "INV_SRC_COLOR",      D3D10_BLEND_INV_SRC_COLOR     },
    { "SRC_ALPHA",          D3D10_BLEND_SRC_ALPHA        },
    { "INV_SRC_ALPHA",      D3D10_BLEND_INV_SRC_ALPHA     },
    { "DEST_ALPHA",         D3D10_BLEND_DEST_ALPHA       },
    { "INV_DEST_ALPHA",     D3D10_BLEND_INV_DEST_ALPHA    },
    { "DEST_COLOR",         D3D10_BLEND_DEST_COLOR       },
    { "INV_DEST_COLOR",     D3D10_BLEND_INV_DEST_COLOR    },
    { "SRC_ALPHA_SAT",      D3D10_BLEND_SRC_ALPHA_SAT     },
    { "BLEND_FACTOR",       D3D10_BLEND_BLEND_FACTOR     },
    { "INV_BLEND_FACTOR",   D3D10_BLEND_INV_BLEND_FACTOR  },
    { "SRC1_COLOR",         D3D10_BLEND_SRC1_COLOR        },
    { "INV_SRC1_COLOR",     D3D10_BLEND_INV_SRC1_COLOR    },
    { "SRC1_ALPHA",         D3D10_BLEND_SRC1_ALPHA       },
    { "INV_SRC1_ALPHA",     D3D10_BLEND_INV_SRC1_ALPHA    },

    RVALUE_END()
};

static CONST RValue g_rvTADDRESS[] =
{
    { "CLAMP",          D3D10_TEXTURE_ADDRESS_CLAMP      },
    { "WRAP",           D3D10_TEXTURE_ADDRESS_WRAP       },
    { "MIRROR",         D3D10_TEXTURE_ADDRESS_MIRROR     },
    { "BORDER",         D3D10_TEXTURE_ADDRESS_BORDER     },
    { "MIRROR_ONCE",    D3D10_TEXTURE_ADDRESS_MIRROR_ONCE },
    RVALUE_END()
};

static CONST RValue g_rvCULL[] =
{
    { "NONE",           D3D10_CULL_NONE     },
    { "FRONT",          D3D10_CULL_FRONT    },
    { "BACK",           D3D10_CULL_BACK     },
    RVALUE_END()
};

static CONST RValue g_rvCMP[] =
{
    { "NEVER",          D3D10_COMPARISON_NEVER        },
    { "LESS",           D3D10_COMPARISON_LESS         },
    { "EQUAL",          D3D10_COMPARISON_EQUAL        },
    { "LESS_EQUAL",     D3D10_COMPARISON_LESS_EQUAL    },
    { "GREATER",        D3D10_COMPARISON_GREATER      },
    { "NOT_EQUAL",      D3D10_COMPARISON_NOT_EQUAL     },
    { "GREATER_EQUAL",  D3D10_COMPARISON_GREATER_EQUAL },
    { "ALWAYS",         D3D10_COMPARISON_ALWAYS       },
    RVALUE_END()
};

static CONST RValue g_rvSTENCILOP[] =
{
    { "KEEP",       D3D10_STENCIL_OP_KEEP    },
    { "ZERO",       D3D10_STENCIL_OP_ZERO    },
    { "REPLACE",    D3D10_STENCIL_OP_REPLACE },
    { "INCR_SAT",   D3D10_STENCIL_OP_INCR_SAT },
    { "DECR_SAT",   D3D10_STENCIL_OP_DECR_SAT },
    { "INVERT",     D3D10_STENCIL_OP_INVERT  },
    { "INCR",       D3D10_STENCIL_OP_INCR    },
    { "DECR",       D3D10_STENCIL_OP_DECR    },
    RVALUE_END()
};

static CONST RValue g_rvBLENDOP[] =
{
    { "ADD",            D3D10_BLEND_OP_ADD         },
    { "SUBTRACT",       D3D10_BLEND_OP_SUBTRACT    },
    { "REV_SUBTRACT",   D3D10_BLEND_OP_REV_SUBTRACT },
    { "MIN",            D3D10_BLEND_OP_MIN         },
    { "MAX",            D3D10_BLEND_OP_MAX         },
    RVALUE_END()
};


//////////////////////////////////////////////////////////////////////////
// Effect HLSL states
//////////////////////////////////////////////////////////////////////////

#define strideof( s, m ) offsetof_fx(s,m[1]) - offsetof_fx(s,m[0])

CONST LValue g_lvGeneral[] =
{
    // RObjects
    { "RasterizerState",            EBT_Pass,           D3D10_SVT_RASTERIZER,         1, 1, FALSE, NULL,                    ELHS_RasterizerBlock,           offsetof_fx(SPassBlock, BackingStore.pRasterizerBlock),                        0 },
    { "DepthStencilState",          EBT_Pass,           D3D10_SVT_DEPTHSTENCIL,       1, 1, FALSE, NULL,                    ELHS_DepthStencilBlock,         offsetof_fx(SPassBlock, BackingStore.pDepthStencilBlock),                      0 },
    { "BlendState",                 EBT_Pass,           D3D10_SVT_BLEND,              1, 1, FALSE, NULL,                    ELHS_BlendBlock,                offsetof_fx(SPassBlock, BackingStore.pBlendBlock),                             0 },
    { "RenderTargetView",           EBT_Pass,           D3D10_SVT_RENDERTARGETVIEW,   1, 8, FALSE, NULL,                    ELHS_RenderTargetView,          offsetof_fx(SPassBlock, BackingStore.pRenderTargetViews),                      0 },
    { "DepthStencilView",           EBT_Pass,           D3D10_SVT_DEPTHSTENCILVIEW,   1, 8, FALSE, NULL,                    ELHS_DepthStencilView,          offsetof_fx(SPassBlock, BackingStore.pDepthStencilView),                       0 },
    { "GenerateMips",               EBT_Pass,           D3D10_SVT_TEXTURE,            1, 1, FALSE, NULL,                    ELHS_GenerateMips,              0,                                                                          0 },
    // Shaders
    { "VertexShader",               EBT_Pass,           D3D10_SVT_VERTEXSHADER,       1, 1, FALSE, g_rvNULL,                ELHS_VertexShaderBlock,         offsetof_fx(SPassBlock, BackingStore.pVertexShaderBlock),                      0 },
    { "PixelShader",                EBT_Pass,           D3D10_SVT_PIXELSHADER,        1, 1, FALSE, g_rvNULL,                ELHS_PixelShaderBlock,          offsetof_fx(SPassBlock, BackingStore.pPixelShaderBlock),                       0 },
    { "GeometryShader",             EBT_Pass,           D3D10_SVT_GEOMETRYSHADER,     1, 1, FALSE, g_rvNULL,                ELHS_GeometryShaderBlock,       offsetof_fx(SPassBlock, BackingStore.pGeometryShaderBlock),                    0 },
    // RObject config assignments
    { "DS_StencilRef",              EBT_Pass,           D3D10_SVT_UINT,               1, 1, FALSE, NULL,                    ELHS_DS_StencilRef,             offsetof_fx(SPassBlock, BackingStore.StencilRef),                              0 },
    { "AB_BlendFactor",             EBT_Pass,           D3D10_SVT_FLOAT,              4, 1, FALSE, NULL,                    ELHS_B_BlendFactor,             offsetof_fx(SPassBlock, BackingStore.BlendFactor),                             0 },
    { "AB_SampleMask",              EBT_Pass,           D3D10_SVT_UINT,               1, 1, FALSE, NULL,                    ELHS_B_SampleMask,              offsetof_fx(SPassBlock, BackingStore.SampleMask),                              0 },

    { "FillMode",                   EBT_Rasterizer,     D3D10_SVT_UINT,               1, 1, FALSE, g_rvFILL,                ELHS_FillMode,                  offsetof_fx(SRasterizerBlock, BackingStore.FillMode),                          0 },
    { "CullMode",                   EBT_Rasterizer,     D3D10_SVT_UINT,               1, 1, FALSE, g_rvCULL,                ELHS_CullMode,                  offsetof_fx(SRasterizerBlock, BackingStore.CullMode),                          0 },
    { "FrontCounterClockwise",      EBT_Rasterizer,     D3D10_SVT_BOOL,               1, 1, FALSE, g_rvBOOL,                ELHS_FrontCC,                   offsetof_fx(SRasterizerBlock, BackingStore.FrontCounterClockwise),             0 },
    { "DepthBias",                  EBT_Rasterizer,     D3D10_SVT_UINT,               1, 1, FALSE, NULL,                    ELHS_DepthBias,                 offsetof_fx(SRasterizerBlock, BackingStore.DepthBias),                         0 },
    { "DepthBiasClamp",             EBT_Rasterizer,     D3D10_SVT_FLOAT,              1, 1, FALSE, NULL,                    ELHS_DepthBiasClamp,            offsetof_fx(SRasterizerBlock, BackingStore.DepthBiasClamp),                    0 },
    { "SlopeScaledDepthBias",       EBT_Rasterizer,     D3D10_SVT_FLOAT,              1, 1, FALSE, NULL,                    ELHS_SlopeScaledDepthBias,      offsetof_fx(SRasterizerBlock, BackingStore.SlopeScaledDepthBias),              0 },
    { "DepthClipEnable",            EBT_Rasterizer,     D3D10_SVT_BOOL,               1, 1, FALSE, g_rvBOOL,                ELHS_DepthClipEnable,           offsetof_fx(SRasterizerBlock, BackingStore.DepthClipEnable),                   0 },
    { "ScissorEnable",              EBT_Rasterizer,     D3D10_SVT_BOOL,               1, 1, FALSE, g_rvBOOL,                ELHS_ScissorEnable,             offsetof_fx(SRasterizerBlock, BackingStore.ScissorEnable),                     0 },
    { "MultisampleEnable",          EBT_Rasterizer,     D3D10_SVT_BOOL,               1, 1, FALSE, g_rvBOOL,                ELHS_MultisampleEnable,         offsetof_fx(SRasterizerBlock, BackingStore.MultisampleEnable),                 0 },
    { "AntialiasedLineEnable",      EBT_Rasterizer,     D3D10_SVT_BOOL,               1, 1, FALSE, g_rvBOOL,                ELHS_AntialiasedLineEnable,     offsetof_fx(SRasterizerBlock, BackingStore.AntialiasedLineEnable),             0 },
    
    { "DepthEnable",                EBT_DepthStencil,   D3D10_SVT_BOOL,               1, 1, FALSE, g_rvBOOL,                ELHS_DepthEnable,               offsetof_fx(SDepthStencilBlock, BackingStore.DepthEnable),                     0 },
    { "DepthWriteMask",             EBT_DepthStencil,   D3D10_SVT_UINT,               1, 1, FALSE, g_rvDEPTH_WRITE_MASK,    ELHS_DepthWriteMask,            offsetof_fx(SDepthStencilBlock, BackingStore.DepthWriteMask),                  0 },
    { "DepthFunc",                  EBT_DepthStencil,   D3D10_SVT_UINT,               1, 1, FALSE, g_rvCMP,                 ELHS_DepthFunc,                 offsetof_fx(SDepthStencilBlock, BackingStore.DepthFunc),                       0 },
    { "StencilEnable",              EBT_DepthStencil,   D3D10_SVT_BOOL,               1, 1, FALSE, g_rvBOOL,                ELHS_StencilEnable,             offsetof_fx(SDepthStencilBlock, BackingStore.StencilEnable),                   0 },
    { "StencilReadMask",            EBT_DepthStencil,   D3D10_SVT_UINT8,              1, 1, FALSE, NULL,                    ELHS_StencilReadMask,           offsetof_fx(SDepthStencilBlock, BackingStore.StencilReadMask),                 0 },
    { "StencilWriteMask",           EBT_DepthStencil,   D3D10_SVT_UINT8,              1, 1, FALSE, NULL,                    ELHS_StencilWriteMask,          offsetof_fx(SDepthStencilBlock, BackingStore.StencilWriteMask),                0 },
    { "FrontFaceStencilFail",       EBT_DepthStencil,   D3D10_SVT_UINT,               1, 1, FALSE, g_rvSTENCILOP,           ELHS_FrontFaceStencilFailOp,    offsetof_fx(SDepthStencilBlock, BackingStore.FrontFace.StencilFailOp),         0 },
    { "FrontFaceStencilDepthFail",  EBT_DepthStencil,   D3D10_SVT_UINT,               1, 1, FALSE, g_rvSTENCILOP,           ELHS_FrontFaceStencilDepthFailOp,offsetof_fx(SDepthStencilBlock, BackingStore.FrontFace.StencilDepthFailOp),   0 },
    { "FrontFaceStencilPass",       EBT_DepthStencil,   D3D10_SVT_UINT,               1, 1, FALSE, g_rvSTENCILOP,           ELHS_FrontFaceStencilPassOp,    offsetof_fx(SDepthStencilBlock, BackingStore.FrontFace.StencilPassOp),         0 },
    { "FrontFaceStencilFunc",       EBT_DepthStencil,   D3D10_SVT_UINT,               1, 1, FALSE, g_rvCMP,                 ELHS_FrontFaceStencilFunc,      offsetof_fx(SDepthStencilBlock, BackingStore.FrontFace.StencilFunc),           0 },
    { "BackFaceStencilFail",        EBT_DepthStencil,   D3D10_SVT_UINT,               1, 1, FALSE, g_rvSTENCILOP,           ELHS_BackFaceStencilFailOp,     offsetof_fx(SDepthStencilBlock, BackingStore.BackFace.StencilFailOp),          0 },
    { "BackFaceStencilDepthFail",   EBT_DepthStencil,   D3D10_SVT_UINT,               1, 1, FALSE, g_rvSTENCILOP,           ELHS_BackFaceStencilDepthFailOp,offsetof_fx(SDepthStencilBlock, BackingStore.BackFace.StencilDepthFailOp),     0 },
    { "BackFaceStencilPass",        EBT_DepthStencil,   D3D10_SVT_UINT,               1, 1, FALSE, g_rvSTENCILOP,           ELHS_BackFaceStencilPassOp,     offsetof_fx(SDepthStencilBlock, BackingStore.BackFace.StencilPassOp),          0 },
    { "BackFaceStencilFunc",        EBT_DepthStencil,   D3D10_SVT_UINT,               1, 1, FALSE, g_rvCMP,                 ELHS_BackFaceStencilFunc,       offsetof_fx(SDepthStencilBlock, BackingStore.BackFace.StencilFunc),            0 },

    { "AlphaToCoverageEnable",      EBT_Blend,          D3D10_SVT_BOOL,               1, 1, FALSE, g_rvBOOL,                ELHS_AlphaToCoverage,           offsetof_fx(SBlendBlock, BackingStore.AlphaToCoverageEnable),                  0 },
    { "BlendEnable",                EBT_Blend,          D3D10_SVT_BOOL,               1, 8, FALSE, g_rvBOOL,                ELHS_BlendEnable,               offsetof_fx(SBlendBlock, BackingStore.RenderTarget[0].BlendEnable),            strideof(SBlendBlock, BackingStore.RenderTarget) },
    { "SrcBlend",                   EBT_Blend,          D3D10_SVT_UINT,               1, 8, TRUE,  g_rvBLEND,               ELHS_SrcBlend,                  offsetof_fx(SBlendBlock, BackingStore.RenderTarget[0].SrcBlend),               strideof(SBlendBlock, BackingStore.RenderTarget) },
    { "DestBlend",                  EBT_Blend,          D3D10_SVT_UINT,               1, 8, TRUE,  g_rvBLEND,               ELHS_DestBlend,                 offsetof_fx(SBlendBlock, BackingStore.RenderTarget[0].DestBlend),              strideof(SBlendBlock, BackingStore.RenderTarget) },
    { "BlendOp",                    EBT_Blend,          D3D10_SVT_UINT,               1, 8, TRUE,  g_rvBLENDOP,             ELHS_BlendOp,                   offsetof_fx(SBlendBlock, BackingStore.RenderTarget[0].BlendOp),                strideof(SBlendBlock, BackingStore.RenderTarget) },
    { "SrcBlendAlpha",              EBT_Blend,          D3D10_SVT_UINT,               1, 8, TRUE,  g_rvBLEND,               ELHS_SrcBlendAlpha,             offsetof_fx(SBlendBlock, BackingStore.RenderTarget[0].SrcBlendAlpha),          strideof(SBlendBlock, BackingStore.RenderTarget) },
    { "DestBlendAlpha",             EBT_Blend,          D3D10_SVT_UINT,               1, 8, TRUE,  g_rvBLEND,               ELHS_DestBlendAlpha,            offsetof_fx(SBlendBlock, BackingStore.RenderTarget[0].DestBlendAlpha),         strideof(SBlendBlock, BackingStore.RenderTarget) },
    { "BlendOpAlpha",               EBT_Blend,          D3D10_SVT_UINT,               1, 8, TRUE,  g_rvBLENDOP,             ELHS_BlendOpAlpha,              offsetof_fx(SBlendBlock, BackingStore.RenderTarget[0].BlendOpAlpha),           strideof(SBlendBlock, BackingStore.RenderTarget) },
    { "RenderTargetWriteMask",      EBT_Blend,          D3D10_SVT_UINT8,              1, 8, FALSE, NULL,                    ELHS_RenderTargetWriteMask,     offsetof_fx(SBlendBlock, BackingStore.RenderTarget[0].RenderTargetWriteMask),  strideof(SBlendBlock, BackingStore.RenderTarget) },

    { "Filter",                     EBT_Sampler,        D3D10_SVT_UINT,               1, 1, FALSE, g_rvFILTER,              ELHS_Filter,                    offsetof_fx(SSamplerBlock, BackingStore.SamplerDesc.Filter),                   0 },
    { "AddressU",                   EBT_Sampler,        D3D10_SVT_UINT,               1, 1, FALSE, g_rvTADDRESS,            ELHS_AddressU,                  offsetof_fx(SSamplerBlock, BackingStore.SamplerDesc.AddressU),                 0 },
    { "AddressV",                   EBT_Sampler,        D3D10_SVT_UINT,               1, 1, FALSE, g_rvTADDRESS,            ELHS_AddressV,                  offsetof_fx(SSamplerBlock, BackingStore.SamplerDesc.AddressV),                 0 },
    { "AddressW",                   EBT_Sampler,        D3D10_SVT_UINT,               1, 1, FALSE, g_rvTADDRESS,            ELHS_AddressW,                  offsetof_fx(SSamplerBlock, BackingStore.SamplerDesc.AddressW),                 0 },
    { "MipLODBias",                 EBT_Sampler,        D3D10_SVT_FLOAT,              1, 1, FALSE, NULL,                    ELHS_MipLODBias,                offsetof_fx(SSamplerBlock, BackingStore.SamplerDesc.MipLODBias),               0 },
    { "MaxAnisotropy",              EBT_Sampler,        D3D10_SVT_UINT,               1, 1, FALSE, NULL,                    ELHS_MaxAnisotropy,             offsetof_fx(SSamplerBlock, BackingStore.SamplerDesc.MaxAnisotropy),            0 },
    { "ComparisonFunc",             EBT_Sampler,        D3D10_SVT_UINT,               1, 1, FALSE, g_rvCMP,                 ELHS_ComparisonFunc,            offsetof_fx(SSamplerBlock, BackingStore.SamplerDesc.ComparisonFunc),           0 },
    { "BorderColor",                EBT_Sampler,        D3D10_SVT_FLOAT,              4, 1, FALSE, NULL,                    ELHS_BorderColor,               offsetof_fx(SSamplerBlock, BackingStore.SamplerDesc.BorderColor),              0 },
    { "MinLOD",                     EBT_Sampler,        D3D10_SVT_FLOAT,              1, 1, FALSE, NULL,                    ELHS_MinLOD,                    offsetof_fx(SSamplerBlock, BackingStore.SamplerDesc.MinLOD),                   0 },
    { "MaxLOD",                     EBT_Sampler,        D3D10_SVT_FLOAT,              1, 1, FALSE, NULL,                    ELHS_MaxLOD,                    offsetof_fx(SSamplerBlock, BackingStore.SamplerDesc.MaxLOD),                   0 },
    { "Texture",                    EBT_Sampler,        D3D10_SVT_TEXTURE,            1, 1, FALSE, g_rvNULL,                ELHS_Texture,                   offsetof_fx(SSamplerBlock, BackingStore.pTexture),                             0 },

    // D3D11 
    { "HullShader",                 EBT_Pass,           D3D11_SVT_HULLSHADER,         1, 1, FALSE, g_rvNULL,                ELHS_HullShaderBlock,           offsetof_fx(SPassBlock, BackingStore.pHullShaderBlock),                       0 },
    { "DomainShader",               EBT_Pass,           D3D11_SVT_DOMAINSHADER,       1, 1, FALSE, g_rvNULL,                ELHS_DomainShaderBlock,         offsetof_fx(SPassBlock, BackingStore.pDomainShaderBlock),                       0 },
    { "ComputeShader",              EBT_Pass,           D3D11_SVT_COMPUTESHADER,      1, 1, FALSE, g_rvNULL,                ELHS_ComputeShaderBlock,        offsetof_fx(SPassBlock, BackingStore.pComputeShaderBlock),                       0 },
};

#define NUM_STATES (sizeof(g_lvGeneral) / sizeof(LValue))
#define MAX_VECTOR_SCALAR_INDEX 8

CONST UINT g_lvGeneralCount = NUM_STATES;

} // end namespace D3DX11Effects

```

`Source Code/Effects11/Binary/SOParser.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       SOParser.h
//  Content:    D3DX11 Effects Stream Out Decl Parser
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

namespace D3DX11Effects
{


//////////////////////////////////////////////////////////////////////////
// CSOParser
//////////////////////////////////////////////////////////////////////////

class CSOParser
{

    CEffectVector<D3D11_SO_DECLARATION_ENTRY>   m_vDecls;                                       // Set of parsed decl entries
    D3D11_SO_DECLARATION_ENTRY                  m_newEntry;                                     // Currently parsing entry
    LPSTR                                       m_SemanticString[D3D11_SO_BUFFER_SLOT_COUNT];   // Copy of strings

    static const UINT MAX_ERROR_SIZE = 254;
    char                                        m_pError[ MAX_ERROR_SIZE + 1 ];                 // Error buffer

public:
    CSOParser()
    {
        ZeroMemory(&m_newEntry, sizeof(m_newEntry));
        ZeroMemory(m_SemanticString, sizeof(m_SemanticString));
        m_pError[0] = 0;
    }

    ~CSOParser()
    {
        for( UINT Stream = 0; Stream < D3D11_SO_STREAM_COUNT; Stream++ )
        {
            SAFE_DELETE_ARRAY( m_SemanticString[Stream] );
        }
    }

    // Parse a single string, assuming stream 0
    HRESULT Parse( __in_z LPCSTR pString )
    {
        m_vDecls.Clear();
        return Parse( 0, pString );
    }

    // Parse all 4 streams
    HRESULT Parse( __in_z LPSTR pStreams[D3D11_SO_STREAM_COUNT] )
    {
        HRESULT hr = S_OK;
        m_vDecls.Clear();
        for( UINT iDecl=0; iDecl < D3D11_SO_STREAM_COUNT; ++iDecl )
        {
            hr = Parse( iDecl, pStreams[iDecl] );
            if( FAILED(hr) )
            {
                char pStream[16];
                StringCchPrintfA( pStream, 16, " in stream %d.", iDecl );
                pStream[15] = 0;
                StringCchCatA( m_pError, MAX_ERROR_SIZE, pStream );
                return hr;
            }
        }
        return hr;
    }

    // Return resulting declarations
    D3D11_SO_DECLARATION_ENTRY *GetDeclArray()
    {
        return &m_vDecls[0];
    }

    char* GetErrorString()
    {
        return m_pError;
    }

    UINT GetDeclCount() const
    {
        return m_vDecls.GetSize();
    }

    // Return resulting buffer strides
    void GetStrides( UINT strides[4] )
    {
        UINT len = GetDeclCount();
        strides[0] = strides[1] = strides[2] = strides[3] = 0;

        for( UINT i=0; i < len; i++ )
        {
            strides[m_vDecls[i].OutputSlot] += m_vDecls[i].ComponentCount * sizeof(float);
        }
    }

protected:

    // Parse a single string "[<slot> :] <semantic>[<index>][.<mask>]; [[<slot> :] <semantic>[<index>][.<mask>][;]]"
    HRESULT Parse( UINT Stream, __in_z LPCSTR pString )
    {
        HRESULT hr = S_OK;

        m_pError[0] = 0;

        if( pString == NULL )
            return S_OK;

        UINT len = (UINT)strlen( pString );
        if( len == 0 )
            return S_OK;

        SAFE_DELETE_ARRAY( m_SemanticString[Stream] );
        VN( m_SemanticString[Stream] = NEW char[len + 1] );
        StringCchCopyA( m_SemanticString[Stream], len + 1, pString );

        LPSTR pSemantic = m_SemanticString[Stream];

        while( TRUE )
        {
            // Each decl entry is delimited by a semi-colon
            LPSTR pSemi = strchr( pSemantic, ';' );

            // strip leading and trailing spaces
            LPSTR pEnd;
            if( pSemi != NULL )
            {
                *pSemi = '\0';
                pEnd = pSemi - 1;
            }
            else
            {
                pEnd = pSemantic + strlen( pSemantic );
            }
            while( isspace( (unsigned char)*pSemantic ) )
                pSemantic++;
            while( pEnd > pSemantic && isspace( (unsigned char)*pEnd ) )
            {
                *pEnd = '\0';
                pEnd--;
            }

            if( *pSemantic != '\0' )
            {
                VH( AddSemantic( pSemantic ) );
                m_newEntry.Stream = Stream;

                VH( m_vDecls.Add( m_newEntry ) );
            }
            if( pSemi == NULL )
                break;
            pSemantic = pSemi + 1;
        }

lExit:
        return hr;
    }

    // Parse a single decl  "[<slot> :] <semantic>[<index>][.<mask>]"
    HRESULT AddSemantic( __inout_z LPSTR pSemantic )
    {
        HRESULT hr = S_OK;

        D3DXASSERT( pSemantic );

        ZeroMemory( &m_newEntry, sizeof(m_newEntry) );
        VH( ConsumeOutputSlot( &pSemantic ) );
        VH( ConsumeRegisterMask( pSemantic ) );
        VH( ConsumeSemanticIndex( pSemantic ) );

        // pSenantic now contains only the SemanticName (all other fields were consumed)
        if( strcmp( "$SKIP", pSemantic ) != 0 )
        {
            m_newEntry.SemanticName = pSemantic;
        }

lExit:
        return hr;
    }

    // Parse optional mask "[.<mask>]"
    HRESULT ConsumeRegisterMask( __inout_z LPSTR pSemantic )
    {
        HRESULT hr = S_OK;
        const char *pFullMask1 = "xyzw";
        const char *pFullMask2 = "rgba";
        SIZE_T stringLength;
        SIZE_T startComponent = 0;
        LPCSTR p;

        D3DXASSERT( pSemantic );

        pSemantic = strchr( pSemantic, '.' ); 

        if( pSemantic == NULL )
        {
            m_newEntry.ComponentCount = 4;
            return S_OK;
        }

        *pSemantic = '\0';
        pSemantic++;

        stringLength = strlen( pSemantic );
        p = strstr(pFullMask1, pSemantic );
        if( p )
        {
            startComponent = (UINT)( p - pFullMask1 );
        }
        else
        {
            p = strstr( pFullMask2, pSemantic );
            if( p )
                startComponent = (UINT)( p - pFullMask2 );
            else
            {
                StringCchPrintfA( m_pError, MAX_ERROR_SIZE, "ID3D11Effect::ParseSODecl - invalid mask declaration '%s'", pSemantic );
                VH( E_FAIL );
            }

        }

        if( stringLength == 0 )
            stringLength = 4;

        m_newEntry.StartComponent = (BYTE)startComponent;
        m_newEntry.ComponentCount = (BYTE)stringLength;

lExit:
        return hr;
    }

    // Parse optional output slot "[<slot> :]"
    HRESULT ConsumeOutputSlot( __deref_inout_z LPSTR* ppSemantic )
    {
        D3DXASSERT( ppSemantic && *ppSemantic );

        HRESULT hr = S_OK;
        LPSTR pColon = strchr( *ppSemantic, ':' ); 

        if( pColon == NULL )
            return S_OK;

        if( pColon == *ppSemantic )
        {
            StringCchCopyA( m_pError, MAX_ERROR_SIZE,
                           "ID3D11Effect::ParseSODecl - Invalid output slot" );
            VH( E_FAIL );
        }

        *pColon = '\0';
        int outputSlot = atoi( *ppSemantic );
        if( outputSlot < 0 || outputSlot > 255 )
        {
            StringCchCopyA( m_pError, MAX_ERROR_SIZE,
                           "ID3D11Effect::ParseSODecl - Invalid output slot" );
            VH( E_FAIL );
        }
        m_newEntry.OutputSlot = (BYTE)outputSlot;

        while( *ppSemantic < pColon )
        {
            if( !isdigit( (unsigned char)**ppSemantic ) )
            {
                StringCchPrintfA( m_pError, MAX_ERROR_SIZE, "ID3D11Effect::ParseSODecl - Non-digit '%c' in output slot", **ppSemantic );
                VH( E_FAIL );
            }
            (*ppSemantic)++;
        }

        // skip the colon (which is now '\0')
        (*ppSemantic)++;

        while( isspace( (unsigned char)**ppSemantic ) )
            (*ppSemantic)++;

lExit:
        return hr;
    }

    // Parse optional index "[<index>]"
    HRESULT ConsumeSemanticIndex( __inout_z LPSTR pSemantic )
    {
        D3DXASSERT( pSemantic );

        UINT uLen = (UINT)strlen( pSemantic );

        // Grab semantic index
        while( uLen > 0 && isdigit( (unsigned char)pSemantic[uLen - 1] ) )
            uLen--;

        if( isdigit( (unsigned char)pSemantic[uLen] ) )
        {
            m_newEntry.SemanticIndex = atoi( pSemantic + uLen );
            pSemantic[uLen] = '\0';
        } 
        else
        {
            m_newEntry.SemanticIndex = 0;
        }

        return S_OK;
    }
};


} // end namespace D3DX11Effects

```

`Source Code/Effects11/Effect.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       Effect.h
//  Content:    D3DX11 Effects Header for ID3DX11Effect Implementation
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include "EffectBinaryFormat.h"

using namespace D3DX11Core;

namespace D3DX11Effects
{

//////////////////////////////////////////////////////////////////////////
// Forward defines
//////////////////////////////////////////////////////////////////////////

struct SBaseBlock;
struct SShaderBlock;
struct SPassBlock;
struct SClassInstance;
struct SInterface;
struct SShaderResource;
struct SUnorderedAccessView;
struct SRenderTargetView;
struct SDepthStencilView;
struct SSamplerBlock;
struct SDepthStencilBlock;
struct SBlendBlock;
struct SRasterizerBlock;
struct SString;
struct SD3DShaderVTable;
struct SClassInstanceGlobalVariable;

struct SAssignment;
struct SVariable;
struct SGlobalVariable;
struct SAnnotation;
struct SConstantBuffer;

class CEffect;
class CEffectLoader;

enum ELhsType;

// Allows the use of 32-bit and 64-bit timers depending on platform type
typedef SIZE_T Timer;

//////////////////////////////////////////////////////////////////////////
// Reflection & Type structures
//////////////////////////////////////////////////////////////////////////

// CEffectMatrix is used internally instead of float arrays
struct CEffectMatrix 
{
    union 
    {
        struct 
        {
            float        _11, _12, _13, _14;
            float        _21, _22, _23, _24;
            float        _31, _32, _33, _34;
            float        _41, _42, _43, _44;

        };
        float m[4][4];
    };
};

struct CEffectVector4 
{
    float x;
    float y;
    float z;
    float w;
};

union UDataPointer
{
    void                    *pGeneric;
    BYTE                    *pNumeric; 
    float                   *pNumericFloat;
    UINT                    *pNumericDword;
    int                     *pNumericInt;
    BOOL                    *pNumericBool;
    SString                 *pString;
    SShaderBlock            *pShader;
    SBaseBlock              *pBlock;
    SBlendBlock             *pBlend;
    SDepthStencilBlock      *pDepthStencil;
    SRasterizerBlock        *pRasterizer;
    SInterface              *pInterface;
    SShaderResource         *pShaderResource;
    SUnorderedAccessView    *pUnorderedAccessView;
    SRenderTargetView       *pRenderTargetView;
    SDepthStencilView       *pDepthStencilView;
    SSamplerBlock           *pSampler;
    CEffectVector4          *pVector;
    CEffectMatrix           *pMatrix;
    UINT_PTR                Offset;
};

enum EMemberDataType
{
    MDT_ClassInstance,
    MDT_BlendState,
    MDT_DepthStencilState,
    MDT_RasterizerState,
    MDT_SamplerState,
    MDT_Buffer,
    MDT_ShaderResourceView,
};

struct SMemberDataPointer
{
    EMemberDataType             Type;
    union
    {
        IUnknown                *pGeneric;
        ID3D11ClassInstance     *pD3DClassInstance;
        ID3D11BlendState        *pD3DEffectsManagedBlendState;
        ID3D11DepthStencilState *pD3DEffectsManagedDepthStencilState;
        ID3D11RasterizerState   *pD3DEffectsManagedRasterizerState;
        ID3D11SamplerState      *pD3DEffectsManagedSamplerState;
        ID3D11Buffer            *pD3DEffectsManagedConstantBuffer;
        ID3D11ShaderResourceView*pD3DEffectsManagedTextureBuffer;
    } Data;
};

struct SType : public ID3DX11EffectType
{   
    static const UINT_PTR c_InvalidIndex = (UINT) -1;
    static const UINT c_ScalarSize = sizeof(UINT);

    // packing rule constants
    static const UINT c_ScalarsPerRegister = 4;
    static const UINT c_RegisterSize = c_ScalarsPerRegister * c_ScalarSize; // must be a power of 2!!    
    
    EVarType    VarType;        // numeric, object, struct
    UINT        Elements;       // # of array elements (0 for non-arrays)
    char        *pTypeName;     // friendly name of the type: "VS_OUTPUT", "float4", etc.

    // *Size and stride values are always 0 for object types
    // *Annotations adhere to packing rules (even though they do not reside in constant buffers)
    //      for consistency's sake
    //
    // Packing rules:
    // *Structures and array elements are always register aligned
    // *Single-row values (or, for column major matrices, single-column) are greedily
    //  packed unless doing so would span a register boundary, in which case they are
    //  register aligned

    UINT        TotalSize;      // Total size of this data type in a constant buffer from
                                // start to finish (padding in between elements is included,
                                // but padding at the end is not since that would require
                                // knowledge of the following data type).

    UINT        Stride;         // Number of bytes to advance between elements.
                                // Typically a multiple of 16 for arrays, vectors, matrices.
                                // For scalars and small vectors/matrices, this can be 4 or 8.    

    UINT        PackedSize;     // Size, in bytes, of this data typed when fully packed

    union
    {        
        SBinaryNumericType  NumericType;
        EObjectType         ObjectType;         // not all values of EObjectType are valid here (e.g. constant buffer)
        struct
        {
            SVariable   *pMembers;              // array of type instances describing structure members
            UINT        Members;
            bool        ImplementsInterface;    // true if this type implements an interface
            bool        HasSuperClass;          // true if this type has a parent class
        }                   StructType;
        void*               InterfaceType;      // nothing for interfaces
    };


    SType() :
       VarType(EVT_Invalid),
       Elements(0),
       pTypeName(NULL),
       TotalSize(0),
       Stride(0),
       PackedSize(0)
    {
        C_ASSERT( sizeof(NumericType) <= sizeof(StructType) );
        C_ASSERT( sizeof(ObjectType) <= sizeof(StructType) );
        C_ASSERT( sizeof(InterfaceType) <= sizeof(StructType) );
        ZeroMemory( &StructType, sizeof(StructType) );
    }

    BOOL IsEqual(SType *pOtherType) const;
    
    BOOL IsObjectType(EObjectType ObjType) const
    {
        return IsObjectTypeHelper(VarType, ObjectType, ObjType);
    }
    BOOL IsShader() const
    {
        return IsShaderHelper(VarType, ObjectType);
    }
    BOOL BelongsInConstantBuffer() const
    {
        return (VarType == EVT_Numeric) || (VarType == EVT_Struct);
    }
    BOOL IsStateBlockObject() const
    {
        return IsStateBlockObjectHelper(VarType, ObjectType);
    }
    BOOL IsClassInstance() const
    {
        return (VarType == EVT_Struct) && StructType.ImplementsInterface;
    }
    BOOL IsInterface() const
    {
        return IsInterfaceHelper(VarType, ObjectType);
    }
    BOOL IsShaderResource() const
    {
        return IsShaderResourceHelper(VarType, ObjectType);
    }
    BOOL IsUnorderedAccessView() const
    {
        return IsUnorderedAccessViewHelper(VarType, ObjectType);
    }
    BOOL IsSampler() const
    {
        return IsSamplerHelper(VarType, ObjectType);
    }
    BOOL IsRenderTargetView() const
    {
        return IsRenderTargetViewHelper(VarType, ObjectType);
    }
    BOOL IsDepthStencilView() const
    {
        return IsDepthStencilViewHelper(VarType, ObjectType);
    }

    UINT GetTotalUnpackedSize(BOOL IsSingleElement) const; 
    UINT GetTotalPackedSize(BOOL IsSingleElement) const; 
    HRESULT GetDescHelper(D3DX11_EFFECT_TYPE_DESC *pDesc, BOOL IsSingleElement) const;

    STDMETHOD_(BOOL, IsValid)() { return TRUE; }
    STDMETHOD(GetDesc)(D3DX11_EFFECT_TYPE_DESC *pDesc) { return GetDescHelper(pDesc, FALSE); }
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeByIndex)(UINT Index);
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeByName)(LPCSTR Name);
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeBySemantic)(LPCSTR Semantic);
    STDMETHOD_(LPCSTR, GetMemberName)(UINT Index);
    STDMETHOD_(LPCSTR, GetMemberSemantic)(UINT Index);
};

// Represents a type structure for a single element.
// It seems pretty trivial, but it has a different virtual table which enables
// us to accurately represent a type that consists of a single element
struct SSingleElementType : public ID3DX11EffectType
{
    SType *pType;

    STDMETHOD_(BOOL, IsValid)() { return TRUE; }
    STDMETHOD(GetDesc)(D3DX11_EFFECT_TYPE_DESC *pDesc) { return ((SType*)pType)->GetDescHelper(pDesc, TRUE); }
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeByIndex)(UINT Index) { return ((SType*)pType)->GetMemberTypeByIndex(Index); }
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeByName)(LPCSTR Name) { return ((SType*)pType)->GetMemberTypeByName(Name); }
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeBySemantic)(LPCSTR Semantic) { return ((SType*)pType)->GetMemberTypeBySemantic(Semantic); }
    STDMETHOD_(LPCSTR, GetMemberName)(UINT Index) { return ((SType*)pType)->GetMemberName(Index); }
    STDMETHOD_(LPCSTR, GetMemberSemantic)(UINT Index) { return ((SType*)pType)->GetMemberSemantic(Index); }
};

//////////////////////////////////////////////////////////////////////////
// Block definitions
//////////////////////////////////////////////////////////////////////////

void * GetBlockByIndex(EVarType VarType, EObjectType ObjectType, void *pBaseBlock, UINT Index);

struct SBaseBlock
{
    EBlockType      BlockType;

    BOOL            IsUserManaged:1;

    UINT            AssignmentCount;
    SAssignment     *pAssignments;

    SBaseBlock();

    BOOL ApplyAssignments(CEffect *pEffect);

    D3DX11INLINE SSamplerBlock *AsSampler() const
    {
        D3DXASSERT( BlockType == EBT_Sampler );
        return (SSamplerBlock*) this;
    }

    D3DX11INLINE SDepthStencilBlock *AsDepthStencil() const
    {
        D3DXASSERT( BlockType == EBT_DepthStencil );
        return (SDepthStencilBlock*) this;
    }

    D3DX11INLINE SBlendBlock *AsBlend() const
    {
        D3DXASSERT( BlockType == EBT_Blend );
        return (SBlendBlock*) this;
    }

    D3DX11INLINE SRasterizerBlock *AsRasterizer() const
    {
        D3DXASSERT( BlockType == EBT_Rasterizer );
        return (SRasterizerBlock*) this;
    }

    D3DX11INLINE SPassBlock *AsPass() const
    {
        D3DXASSERT( BlockType == EBT_Pass );
        return (SPassBlock*) this;
    }
};

struct STechnique : public ID3DX11EffectTechnique
{
    char        *pName;

    UINT        PassCount;
    SPassBlock  *pPasses;

    UINT        AnnotationCount;
    SAnnotation *pAnnotations;

    BOOL        InitiallyValid;
    BOOL        HasDependencies;

    STechnique();

    STDMETHOD_(BOOL, IsValid)();
    STDMETHOD(GetDesc)(D3DX11_TECHNIQUE_DESC *pDesc);

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(UINT Index);
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(LPCSTR Name);

    STDMETHOD_(ID3DX11EffectPass*, GetPassByIndex)(UINT Index);
    STDMETHOD_(ID3DX11EffectPass*, GetPassByName)(LPCSTR Name);

    STDMETHOD(ComputeStateBlockMask)(D3DX11_STATE_BLOCK_MASK *pStateBlockMask);
};

struct SGroup : public ID3DX11EffectGroup
{
    char        *pName;

    UINT        TechniqueCount;
    STechnique  *pTechniques;

    UINT        AnnotationCount;
    SAnnotation *pAnnotations;

    BOOL        InitiallyValid;
    BOOL        HasDependencies;

    SGroup();

    STDMETHOD_(BOOL, IsValid)();
    STDMETHOD(GetDesc)(D3DX11_GROUP_DESC *pDesc);

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(UINT Index);
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(LPCSTR Name);

    STDMETHOD_(ID3DX11EffectTechnique*, GetTechniqueByIndex)(UINT Index);
    STDMETHOD_(ID3DX11EffectTechnique*, GetTechniqueByName)(LPCSTR Name);
};

struct SPassBlock : SBaseBlock, public ID3DX11EffectPass
{
    struct
    {
        ID3D11BlendState*       pBlendState;
        FLOAT                   BlendFactor[4];
        UINT                    SampleMask;
        ID3D11DepthStencilState *pDepthStencilState;
        UINT                    StencilRef;
        union
        {
            D3D11_SO_DECLARATION_ENTRY  *pEntry;
            char                        *pEntryDesc;
        }                       GSSODesc;

        // Pass assignments can write directly into these
        SBlendBlock             *pBlendBlock;
        SDepthStencilBlock      *pDepthStencilBlock;
        SRasterizerBlock        *pRasterizerBlock;
        UINT                    RenderTargetViewCount;
        SRenderTargetView       *pRenderTargetViews[D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT];
        SDepthStencilView       *pDepthStencilView;
        SShaderBlock            *pVertexShaderBlock;
        SShaderBlock            *pPixelShaderBlock;
        SShaderBlock            *pGeometryShaderBlock;
        SShaderBlock            *pComputeShaderBlock;
        SShaderBlock            *pDomainShaderBlock;
        SShaderBlock            *pHullShaderBlock;
    }           BackingStore;

    char        *pName;

    UINT        AnnotationCount;
    SAnnotation *pAnnotations;

    CEffect     *pEffect;

    BOOL        InitiallyValid;         // validity of all state objects and shaders in pass upon BindToDevice
    BOOL        HasDependencies;        // if pass expressions or pass state blocks have dependencies on variables (if true, IsValid != InitiallyValid possibly)

    SPassBlock();

    void ApplyPassAssignments();
    BOOL CheckShaderDependencies( SShaderBlock* pBlock );
    BOOL CheckDependencies();

    template<EObjectType EShaderType>
    HRESULT GetShaderDescHelper(D3DX11_PASS_SHADER_DESC *pDesc);

    STDMETHOD_(BOOL, IsValid)();
    STDMETHOD(GetDesc)(D3DX11_PASS_DESC *pDesc);

    STDMETHOD(GetVertexShaderDesc)(D3DX11_PASS_SHADER_DESC *pDesc);
    STDMETHOD(GetGeometryShaderDesc)(D3DX11_PASS_SHADER_DESC *pDesc);
    STDMETHOD(GetPixelShaderDesc)(D3DX11_PASS_SHADER_DESC *pDesc);
    STDMETHOD(GetHullShaderDesc)(D3DX11_PASS_SHADER_DESC *pDesc);
    STDMETHOD(GetDomainShaderDesc)(D3DX11_PASS_SHADER_DESC *pDesc);
    STDMETHOD(GetComputeShaderDesc)(D3DX11_PASS_SHADER_DESC *pDesc);

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(UINT Index);
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(LPCSTR Name);

    STDMETHOD(Apply)(UINT Flags, ID3D11DeviceContext* pContext);
    
    STDMETHOD(ComputeStateBlockMask)(D3DX11_STATE_BLOCK_MASK *pStateBlockMask);
};

struct SDepthStencilBlock : SBaseBlock
{
    ID3D11DepthStencilState *pDSObject;
    D3D11_DEPTH_STENCIL_DESC BackingStore;
    BOOL                     IsValid;

    SDepthStencilBlock();
};

struct SBlendBlock : SBaseBlock
{
    ID3D11BlendState        *pBlendObject;
    D3D11_BLEND_DESC        BackingStore;
    BOOL                    IsValid;

    SBlendBlock();
};

struct SRasterizerBlock : SBaseBlock
{
    ID3D11RasterizerState   *pRasterizerObject;
    D3D11_RASTERIZER_DESC   BackingStore;
    BOOL                    IsValid;

    SRasterizerBlock();
};

struct SSamplerBlock : SBaseBlock
{
    ID3D11SamplerState      *pD3DObject;
    struct
    {
        D3D11_SAMPLER_DESC  SamplerDesc;
        // Sampler "TEXTURE" assignments can write directly into this
        SShaderResource     *pTexture;
    } BackingStore;

    SSamplerBlock();
};

struct SInterface
{
    SClassInstanceGlobalVariable* pClassInstance;

    SInterface()
    {
        pClassInstance = NULL;
    }
};

struct SShaderResource
{
    ID3D11ShaderResourceView *pShaderResource;

    SShaderResource() 
    {
        pShaderResource = NULL;
    }

};

struct SUnorderedAccessView
{
    ID3D11UnorderedAccessView *pUnorderedAccessView;

    SUnorderedAccessView() 
    {
        pUnorderedAccessView = NULL;
    }

};

struct SRenderTargetView
{
    ID3D11RenderTargetView *pRenderTargetView;

    SRenderTargetView();
};

struct SDepthStencilView
{
    ID3D11DepthStencilView *pDepthStencilView;

    SDepthStencilView();
};


template<class T, class D3DTYPE> struct SShaderDependency
{
    UINT    StartIndex;
    UINT    Count;

    T       *ppFXPointers;              // Array of ptrs to FX objects (CBs, SShaderResources, etc)
    D3DTYPE *ppD3DObjects;              // Array of ptrs to matching D3D objects

    SShaderDependency()
    {
        StartIndex = Count = 0;

        ppD3DObjects = NULL;
        ppFXPointers = NULL;
    }
};

typedef SShaderDependency<SConstantBuffer*, ID3D11Buffer*> SShaderCBDependency;
typedef SShaderDependency<SSamplerBlock*, ID3D11SamplerState*> SShaderSamplerDependency;
typedef SShaderDependency<SShaderResource*, ID3D11ShaderResourceView*> SShaderResourceDependency;
typedef SShaderDependency<SUnorderedAccessView*, ID3D11UnorderedAccessView*> SUnorderedAccessViewDependency;
typedef SShaderDependency<SInterface*, ID3D11ClassInstance*> SInterfaceDependency;

// Shader VTables are used to eliminate branching in ApplyShaderBlock.
// The effect owns three D3DShaderVTables, one for PS, one for VS, and one for GS.
struct SD3DShaderVTable
{
    void ( __stdcall ID3D11DeviceContext::*pSetShader)(ID3D11DeviceChild* pShader, ID3D11ClassInstance*const* ppClassInstances, UINT NumClassInstances);
    void ( __stdcall ID3D11DeviceContext::*pSetConstantBuffers)(UINT StartConstantSlot, UINT NumBuffers, ID3D11Buffer *const *pBuffers);
    void ( __stdcall ID3D11DeviceContext::*pSetSamplers)(UINT Offset, UINT NumSamplers, ID3D11SamplerState*const* pSamplers);
    void ( __stdcall ID3D11DeviceContext::*pSetShaderResources)(UINT Offset, UINT NumResources, ID3D11ShaderResourceView *const *pResources);
    HRESULT ( __stdcall ID3D11Device::*pCreateShader)(const void *pShaderBlob, SIZE_T ShaderBlobSize, ID3D11ClassLinkage* pClassLinkage, ID3D11DeviceChild **ppShader);
};


struct SShaderBlock
{
    enum ESigType
    {
        ST_Input,
        ST_Output,
        ST_PatchConstant,
    };

    struct SInterfaceParameter
    {
        char                        *pName;
        UINT                        Index;
    };

    // this data is classified as reflection-only and will all be discarded at runtime
    struct SReflectionData
    {
        BYTE                        *pBytecode;
        UINT                        BytecodeLength;
        char                        *pStreamOutDecls[4];        // set with ConstructGSWithSO
        UINT                        RasterizedStream;           // set with ConstructGSWithSO
        BOOL                        IsNullGS;
        ID3D11ShaderReflection      *pReflection;
        UINT                        InterfaceParameterCount;    // set with BindInterfaces (used for function interface parameters)
        SInterfaceParameter         *pInterfaceParameters;      // set with BindInterfaces (used for function interface parameters)
    };

    BOOL                            IsValid;
    SD3DShaderVTable                *pVT;                

    // This value is NULL if the shader is NULL or was never initialized
    SReflectionData                 *pReflectionData;

    ID3D11DeviceChild               *pD3DObject;

    UINT                            CBDepCount;
    SShaderCBDependency             *pCBDeps;

    UINT                            SampDepCount;
    SShaderSamplerDependency        *pSampDeps;

    UINT                            InterfaceDepCount;
    SInterfaceDependency            *pInterfaceDeps;

    UINT                            ResourceDepCount;
    SShaderResourceDependency       *pResourceDeps;

    UINT                            UAVDepCount;
    SUnorderedAccessViewDependency  *pUAVDeps;

    UINT                            TBufferDepCount;
    SConstantBuffer                 **ppTbufDeps;

    ID3DBlob                        *pInputSignatureBlob;   // The input signature is separated from the bytecode because it 
                                                            // is always available, even after Optimize() has been called.

    SShaderBlock(SD3DShaderVTable *pVirtualTable = NULL);

    EObjectType GetShaderType();

    HRESULT OnDeviceBind();

    // Public API helpers
    HRESULT ComputeStateBlockMask(D3DX11_STATE_BLOCK_MASK *pStateBlockMask);

    HRESULT GetShaderDesc(D3DX11_EFFECT_SHADER_DESC *pDesc, BOOL IsInline);

    HRESULT GetVertexShader(ID3D11VertexShader **ppVS);
    HRESULT GetGeometryShader(ID3D11GeometryShader **ppGS);
    HRESULT GetPixelShader(ID3D11PixelShader **ppPS);
    HRESULT GetHullShader(ID3D11HullShader **ppPS);
    HRESULT GetDomainShader(ID3D11DomainShader **ppPS);
    HRESULT GetComputeShader(ID3D11ComputeShader **ppPS);

    HRESULT GetSignatureElementDesc(ESigType SigType, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc);
};



struct SString
{
    char *pString;

    SString();
};



//////////////////////////////////////////////////////////////////////////
// Global Variable & Annotation structure/interface definitions
//////////////////////////////////////////////////////////////////////////

//
// This is a general structure that can describe
// annotations, variables, and structure members
//
struct SVariable
{
    // For annotations/variables/variable members:
    // 1) If numeric, pointer to data (for variables: points into backing store,
    //      for annotations, points into reflection heap)
    // OR
    // 2) If object, pointer to the block. If object array, subsequent array elements are found in
    //      contiguous blocks; the Nth block is found by ((<SpecificBlockType> *) pBlock) + N
    //      (this is because variables that are arrays of objects have their blocks allocated contiguously)
    //
    // For structure members:
    //    Offset of this member (in bytes) from parent structure (structure members must be numeric/struct)
    UDataPointer            Data;
    union
    {
        UINT                MemberDataOffsetPlus4;  // 4 added so that 0 == NULL can represent "unused"
        SMemberDataPointer  *pMemberData;
    };

    SType                   *pType;
    char                    *pName;
    char                    *pSemantic;
    UINT                    ExplicitBindPoint;

    SVariable()
    {
        ZeroMemory(this, sizeof(*this));
        ExplicitBindPoint = -1;
    }
};

// Template definitions for all of the various ID3DX11EffectVariable specializations
#include "EffectVariable.inl"


////////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectShaderVariable (SAnonymousShader implementation)
////////////////////////////////////////////////////////////////////////////////

struct SAnonymousShader : public TUncastableVariable<ID3DX11EffectShaderVariable>, public ID3DX11EffectType
{
    SShaderBlock    *pShaderBlock;

    SAnonymousShader(SShaderBlock *pBlock = NULL);

    // ID3DX11EffectShaderVariable interface
    STDMETHOD_(BOOL, IsValid)();
    STDMETHOD_(ID3DX11EffectType*, GetType)();
    STDMETHOD(GetDesc)(D3DX11_EFFECT_VARIABLE_DESC *pDesc);

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(UINT Index);
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(LPCSTR Name);

    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(UINT Index);
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(LPCSTR Name);
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(LPCSTR Semantic);

    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(UINT Index);

    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)();

    // other casts are handled by TUncastableVariable
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)();

    STDMETHOD(SetRawValue)(CONST void *pData, UINT Offset, UINT Count);
    STDMETHOD(GetRawValue)(__out_bcount(Count) void *pData, UINT Offset, UINT Count);

    STDMETHOD(GetShaderDesc)(UINT ShaderIndex, D3DX11_EFFECT_SHADER_DESC *pDesc);

    STDMETHOD(GetVertexShader)(UINT ShaderIndex, ID3D11VertexShader **ppVS);
    STDMETHOD(GetGeometryShader)(UINT ShaderIndex, ID3D11GeometryShader **ppGS);
    STDMETHOD(GetPixelShader)(UINT ShaderIndex, ID3D11PixelShader **ppPS);
    STDMETHOD(GetHullShader)(UINT ShaderIndex, ID3D11HullShader **ppPS);
    STDMETHOD(GetDomainShader)(UINT ShaderIndex, ID3D11DomainShader **ppPS);
    STDMETHOD(GetComputeShader)(UINT ShaderIndex, ID3D11ComputeShader **ppPS);

    STDMETHOD(GetInputSignatureElementDesc)(UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc);
    STDMETHOD(GetOutputSignatureElementDesc)(UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc);
    STDMETHOD(GetPatchConstantSignatureElementDesc)(UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc);

    // ID3DX11EffectType interface
    STDMETHOD(GetDesc)(D3DX11_EFFECT_TYPE_DESC *pDesc);
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeByIndex)(UINT Index);
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeByName)(LPCSTR Name);
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeBySemantic)(LPCSTR Semantic);

    STDMETHOD_(LPCSTR, GetMemberName)(UINT Index);
    STDMETHOD_(LPCSTR, GetMemberSemantic)(UINT Index);
};

////////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectConstantBuffer (SConstantBuffer implementation)
////////////////////////////////////////////////////////////////////////////////

struct SConstantBuffer : public TUncastableVariable<ID3DX11EffectConstantBuffer>, public ID3DX11EffectType
{
    ID3D11Buffer            *pD3DObject;
    SShaderResource         TBuffer;            // NULL iff IsTbuffer == FALSE

    BYTE                    *pBackingStore;
    UINT                    Size;               // in bytes

    char                    *pName;

    UINT                    AnnotationCount;
    SAnnotation             *pAnnotations;

    UINT                    VariableCount;      // # of variables contained in this cbuffer
    SGlobalVariable         *pVariables;        // array of size [VariableCount], points into effect's contiguous variable list
    UINT                    ExplicitBindPoint;  // Used when a CB has been explicitly bound (register(bXX)). -1 if not

    BOOL                    IsDirty:1;          // Set when any member is updated; cleared on CB apply    
    BOOL                    IsTBuffer:1;        // TRUE iff TBuffer.pShaderResource != NULL
    BOOL                    IsUserManaged:1;    // Set if you don't want effects to update this buffer
    BOOL                    IsEffectOptimized:1;// Set if the effect has been optimized
    BOOL                    IsUsedByExpression:1;// Set if used by any expressions
    BOOL                    IsUserPacked:1;     // Set if the elements have user-specified offsets
    BOOL                    IsSingle:1;         // Set to true if you want to share this CB with cloned Effects
    BOOL                    IsNonUpdatable:1;   // Set to true if you want to share this CB with cloned Effects

    union
    {
        // These are used to store the original ID3D11Buffer* for use in UndoSetConstantBuffer
        UINT                MemberDataOffsetPlus4;  // 4 added so that 0 == NULL can represent "unused"
        SMemberDataPointer  *pMemberData;
    };

    CEffect                 *pEffect;

    SConstantBuffer()
    {
        pD3DObject = NULL;
        ZeroMemory(&TBuffer, sizeof(TBuffer));
        ExplicitBindPoint = -1;
        pBackingStore = NULL;
        Size = 0;
        pName = NULL;
        VariableCount = 0;
        pVariables = NULL;
        AnnotationCount = 0;
        pAnnotations = NULL;
        IsDirty = FALSE;
        IsTBuffer = FALSE;
        IsUserManaged = FALSE;
        IsEffectOptimized = FALSE;
        IsUsedByExpression = FALSE;
        IsUserPacked = FALSE;
        IsSingle = FALSE;
        IsNonUpdatable = FALSE;
        pEffect = NULL;
    }

    bool ClonedSingle() const;

    // ID3DX11EffectConstantBuffer interface
    STDMETHOD_(BOOL, IsValid)();
    STDMETHOD_(ID3DX11EffectType*, GetType)();
    STDMETHOD(GetDesc)(D3DX11_EFFECT_VARIABLE_DESC *pDesc);

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(UINT Index);
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(LPCSTR Name);

    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(UINT Index);
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(LPCSTR Name);
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(LPCSTR Semantic);

    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(UINT Index);

    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)();

    // other casts are handled by TUncastableVariable
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)();

    STDMETHOD(SetRawValue)(CONST void *pData, UINT Offset, UINT Count);
    STDMETHOD(GetRawValue)(__out_bcount(Count) void *pData, UINT Offset, UINT Count);

    STDMETHOD(SetConstantBuffer)(ID3D11Buffer *pConstantBuffer);
    STDMETHOD(GetConstantBuffer)(ID3D11Buffer **ppConstantBuffer);
    STDMETHOD(UndoSetConstantBuffer)();

    STDMETHOD(SetTextureBuffer)(ID3D11ShaderResourceView *pTextureBuffer);
    STDMETHOD(GetTextureBuffer)(ID3D11ShaderResourceView **ppTextureBuffer);
    STDMETHOD(UndoSetTextureBuffer)();

    // ID3DX11EffectType interface
    STDMETHOD(GetDesc)(D3DX11_EFFECT_TYPE_DESC *pDesc);
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeByIndex)(UINT Index);
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeByName)(LPCSTR Name);
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeBySemantic)(LPCSTR Semantic);

    STDMETHOD_(LPCSTR, GetMemberName)(UINT Index);
    STDMETHOD_(LPCSTR, GetMemberSemantic)(UINT Index);
};


//////////////////////////////////////////////////////////////////////////
// Assignments
//////////////////////////////////////////////////////////////////////////

enum ERuntimeAssignmentType
{
    ERAT_Invalid,
    // [Destination] refers to the destination location, which is always the backing store of the pass/state block. 
    // [Source] refers to the current source of data, always coming from either a constant buffer's 
    //  backing store (for numeric assignments), an object variable's block array, or an anonymous (unowned) block

    // Numeric variables:
    ERAT_Constant,                  // Source is unused.
                                    // No dependencies; this assignment can be safely removed after load.
    ERAT_NumericVariable,           // Source points to the CB's backing store where the value lives.
                                    // 1 dependency: the variable itself.
    ERAT_NumericConstIndex,         // Source points to the CB's backing store where the value lives, offset by N.
                                    // 1 dependency: the variable array being indexed.
    ERAT_NumericVariableIndex,      // Source points to the last used element of the variable in the CB's backing store.
                                    // 2 dependencies: the index variable followed by the array variable.

    // Object variables:
    ERAT_ObjectInlineShader,        // An anonymous, immutable shader block pointer is copied to the destination immediately.
                                    // No dependencies; this assignment can be safely removed after load.
    ERAT_ObjectVariable,            // A pointer to the block owned by the object variable is copied to the destination immediately.
                                    // No dependencies; this assignment can be safely removed after load.
    ERAT_ObjectConstIndex,          // A pointer to the Nth block owned by an object variable is copied to the destination immediately.
                                    // No dependencies; this assignment can be safely removed after load.
    ERAT_ObjectVariableIndex,       // Source points to the first block owned by an object variable array
                                    // (the offset from this, N, is taken from another variable).
                                    // 1 dependency: the variable being used to index the array.
};

struct SAssignment
{
    struct SDependency
    {
        SGlobalVariable *pVariable;

        SDependency()
        {
            pVariable = NULL;
        }
    };

    ELhsType                LhsType;            // PS, VS, DepthStencil etc.

    // The value of SAssignment.AssignmentType determines how the other fields behave
    // (DependencyCount, pDependencies, Destination, and Source)
    ERuntimeAssignmentType  AssignmentType;      

    Timer                   LastRecomputedTime;

    // see comments in ERuntimeAssignmentType for how dependencies and data pointers are handled
    UINT                    DependencyCount;
    SDependency             *pDependencies;

    UDataPointer            Destination;        // This value never changes after load, and always refers to the backing store
    UDataPointer            Source;             // This value, on the other hand, can change if variable- or expression- driven

    UINT                    DataSize : 16;      // Size of the data element to be copied in bytes (if numeric) or
                                                // stride of the block type (if object)
    UINT                    MaxElements : 16;   // Max allowable index (needed because we don't store object arrays as dependencies,
                                                // and therefore have no way of getting their Element count)

    BOOL IsObjectAssignment()                   // True for Shader and RObject assignments (the type that appear in pass blocks)
    {
        return IsObjectAssignmentHelper(LhsType);
    }

    SAssignment()
    {
        LhsType = ELHS_Invalid;
        AssignmentType = ERAT_Invalid;

        Destination.pGeneric = NULL;
        Source.pGeneric = NULL;

        LastRecomputedTime = 0;
        DependencyCount = 0;
        pDependencies = NULL;

        DataSize = 0;
    }
};

//////////////////////////////////////////////////////////////////////////
// Private effect heaps
//////////////////////////////////////////////////////////////////////////

// Used to efficiently reallocate data
// 1) For every piece of data that needs reallocation, move it to its new location
// and add an entry into the table
// 2) For everyone that references one of these data blocks, do a quick table lookup
// to find the old pointer and then replace it with the new one
struct SPointerMapping
{
    void *pOld;
    void *pNew;

    static BOOL AreMappingsEqual(const SPointerMapping &pMap1, const SPointerMapping &pMap2)
    {
        return (pMap1.pOld == pMap2.pOld);
    }

    UINT Hash()
    {
        // hash the pointer itself 
        // (using the pointer as a hash would be very bad)
        return ComputeHash((BYTE*)&pOld, sizeof(pOld));
    }
};

typedef CEffectHashTableWithPrivateHeap<SPointerMapping, SPointerMapping::AreMappingsEqual> CPointerMappingTable;

// Assist adding data to a block of memory
class CEffectHeap
{
protected:
    BYTE    *m_pData;
    UINT    m_dwBufferSize;
    UINT    m_dwSize;

    template <bool bCopyData>
    HRESULT AddDataInternal(const void *pData, UINT dwSize, void **ppPointer);

public:
    HRESULT ReserveMemory(UINT dwSize);
    UINT GetSize();
    BYTE* GetDataStart() { return m_pData; }

    // AddData and AddString append existing data to the buffer - they change m_dwSize. Users are 
    //   not expected to modify the data pointed to by the return pointer
    HRESULT AddString(const char *pString, __deref_out_z char **ppPointer);
    HRESULT AddData(const void *pData, UINT  dwSize, void **ppPointer);

    // Allocate behaves like a standard new - it will allocate memory, move m_dwSize. The caller is 
    //   expected to use the returned pointer
    void* Allocate(UINT dwSize);

    // Move data from the general heap and optional free memory
    HRESULT MoveData(void **ppData, UINT size);
    HRESULT MoveString(__deref_inout_z char **ppStringData);
    HRESULT MoveInterfaceParameters(UINT InterfaceCount, __in_ecount(1) SShaderBlock::SInterfaceParameter **ppInterfaces);
    HRESULT MoveEmptyDataBlock(void **ppData, UINT size);

    BOOL IsInHeap(void *pData) const
    {
        return (pData >= m_pData && pData < (m_pData + m_dwBufferSize));
    }

    CEffectHeap();
    ~CEffectHeap();
};

class CEffectReflection
{
public:
    // Single memory block support
    CEffectHeap m_Heap;
};


class CEffect : public ID3DX11Effect
{
    friend struct SBaseBlock;
    friend struct SPassBlock;
    friend class CEffectLoader;
    friend struct SConstantBuffer;
    friend struct TSamplerVariable<TGlobalVariable<ID3DX11EffectSamplerVariable>>;
    friend struct TSamplerVariable<TVariable<TMember<ID3DX11EffectSamplerVariable>>>;
    
protected:

    UINT                    m_RefCount;
    UINT                    m_Flags;

    // Private heap - all pointers should point into here
    CEffectHeap             m_Heap;

    // Reflection object
    CEffectReflection       *m_pReflection;

    // global variables in the effect (aka parameters)
    UINT                    m_VariableCount;
    SGlobalVariable         *m_pVariables;

    // anonymous shader variables (one for every inline shader assignment)
    UINT                    m_AnonymousShaderCount;
    SAnonymousShader        *m_pAnonymousShaders;

    // techniques within this effect (the actual data is located in each group)
    UINT                    m_TechniqueCount;

    // groups within this effect
    UINT                    m_GroupCount;
    SGroup                  *m_pGroups;
    SGroup                  *m_pNullGroup;

    UINT                    m_ShaderBlockCount;
    SShaderBlock            *m_pShaderBlocks;

    UINT                    m_DepthStencilBlockCount;
    SDepthStencilBlock      *m_pDepthStencilBlocks;

    UINT                    m_BlendBlockCount;
    SBlendBlock             *m_pBlendBlocks;

    UINT                    m_RasterizerBlockCount;
    SRasterizerBlock        *m_pRasterizerBlocks;

    UINT                    m_SamplerBlockCount;
    SSamplerBlock           *m_pSamplerBlocks;

    UINT                    m_MemberDataCount;
    SMemberDataPointer      *m_pMemberDataBlocks;

    UINT                    m_InterfaceCount;
    SInterface              *m_pInterfaces;

    UINT                    m_CBCount;
    SConstantBuffer         *m_pCBs;

    UINT                    m_StringCount;
    SString                 *m_pStrings;

    UINT                    m_ShaderResourceCount;
    SShaderResource         *m_pShaderResources;

    UINT                    m_UnorderedAccessViewCount;
    SUnorderedAccessView    *m_pUnorderedAccessViews;

    UINT                    m_RenderTargetViewCount;
    SRenderTargetView       *m_pRenderTargetViews;

    UINT                    m_DepthStencilViewCount;
    SDepthStencilView       *m_pDepthStencilViews; 

    Timer                   m_LocalTimer;
    
    // temporary index variable for assignment evaluation
    UINT                    m_FXLIndex;

    ID3D11Device            *m_pDevice;
    ID3D11DeviceContext     *m_pContext;
    ID3D11ClassLinkage      *m_pClassLinkage;

    // Master lists of reflection interfaces
    CEffectVectorOwner<SSingleElementType> m_pTypeInterfaces;
    CEffectVectorOwner<SMember>            m_pMemberInterfaces;

    //////////////////////////////////////////////////////////////////////////    
    // String & Type pooling

    typedef SType *LPSRUNTIMETYPE;
    static BOOL AreTypesEqual(const LPSRUNTIMETYPE &pType1, const LPSRUNTIMETYPE &pType2) { return (pType1->IsEqual(pType2)); }
    static BOOL AreStringsEqual(__in const LPCSTR &pStr1, __in const LPCSTR &pStr2) { return strcmp(pStr1, pStr2) == 0; }

    typedef CEffectHashTableWithPrivateHeap<SType *, AreTypesEqual> CTypeHashTable;
    typedef CEffectHashTableWithPrivateHeap<LPCSTR, AreStringsEqual> CStringHashTable;

    // These are used to pool types & type-related strings
    // until Optimize() is called
    CTypeHashTable          *m_pTypePool;
    CStringHashTable        *m_pStringPool;
    CDataBlockStore         *m_pPooledHeap;
    // After Optimize() is called, the type/string pools should be deleted and all
    // remaining data should be migrated into the optimized type heap
    CEffectHeap             *m_pOptimizedTypeHeap;

    // Pools a string or type and modifies the pointer
    void AddStringToPool(const char **ppString);
    void AddTypeToPool(SType **ppType);

    HRESULT OptimizeTypes(CPointerMappingTable *pMappingTable, bool Cloning = false);


    //////////////////////////////////////////////////////////////////////////    
    // Runtime (performance critical)
    
    void ApplyShaderBlock(SShaderBlock *pBlock);
    BOOL ApplyRenderStateBlock(SBaseBlock *pBlock);
    BOOL ApplySamplerBlock(SSamplerBlock *pBlock);
    void ApplyPassBlock(SPassBlock *pBlock);
    BOOL EvaluateAssignment(SAssignment *pAssignment);
    BOOL ValidateShaderBlock( SShaderBlock* pBlock );
    BOOL ValidatePassBlock( SPassBlock* pBlock );
    
    //////////////////////////////////////////////////////////////////////////    
    // Non-runtime functions (not performance critical)    

    SGlobalVariable *FindLocalVariableByName(LPCSTR pVarName);      // Looks in the current effect only
    SGlobalVariable *FindVariableByName(LPCSTR pVarName);
    SVariable *FindVariableByNameWithParsing(LPCSTR pVarName);
    SConstantBuffer *FindCB(LPCSTR pName);
    void ReplaceCBReference(SConstantBuffer *pOldBufferBlock, ID3D11Buffer *pNewBuffer);            // Used by user-managed CBs
    void ReplaceSamplerReference(SSamplerBlock *pOldSamplerBlock, ID3D11SamplerState *pNewSampler);
    void AddRefAllForCloning( CEffect* pEffectSource );
    HRESULT CopyMemberInterfaces( CEffect* pEffectSource );
    HRESULT CopyStringPool( CEffect* pEffectSource, CPointerMappingTable& mappingTable );
    HRESULT CopyTypePool( CEffect* pEffectSource, CPointerMappingTable& mappingTableTypes, CPointerMappingTable& mappingTableStrings );
    HRESULT CopyOptimizedTypePool( CEffect* pEffectSource, CPointerMappingTable& mappingTableTypes );
    HRESULT RecreateCBs();
    HRESULT FixupMemberInterface( SMember* pMember, CEffect* pEffectSource, CPointerMappingTable& mappingTableStrings );

    void ValidateIndex(UINT Elements);

    void IncrementTimer();    
    void HandleLocalTimerRollover();

    friend struct SConstantBuffer;

public:
    CEffect( UINT Flags = 0 );
    virtual ~CEffect();
    void ReleaseShaderRefection();

    // Initialize must be called after the effect is created
    HRESULT LoadEffect(CONST void *pEffectBuffer, UINT cbEffectBuffer);

    // Once the effect is fully loaded, call BindToDevice to attach it to a device
    HRESULT BindToDevice(ID3D11Device *pDevice);

    Timer GetCurrentTime() const { return m_LocalTimer; }
    
    BOOL IsReflectionData(void *pData) const { return m_pReflection->m_Heap.IsInHeap(pData); }
    BOOL IsRuntimeData(void *pData) const { return m_Heap.IsInHeap(pData); }

    //////////////////////////////////////////////////////////////////////////    
    // Public interface

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    STDMETHOD_(BOOL, IsValid)() { return TRUE; }

    STDMETHOD(GetDevice)(ID3D11Device** ppDevice);    

    STDMETHOD(GetDesc)(D3DX11_EFFECT_DESC *pDesc);

    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetConstantBufferByIndex)(UINT Index);
    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetConstantBufferByName)(LPCSTR Name);

    STDMETHOD_(ID3DX11EffectVariable*, GetVariableByIndex)(UINT Index);
    STDMETHOD_(ID3DX11EffectVariable*, GetVariableByName)(LPCSTR Name);
    STDMETHOD_(ID3DX11EffectVariable*, GetVariableBySemantic)(LPCSTR Semantic);

    STDMETHOD_(ID3DX11EffectTechnique*, GetTechniqueByIndex)(UINT Index);
    STDMETHOD_(ID3DX11EffectTechnique*, GetTechniqueByName)(LPCSTR Name);

    STDMETHOD_(ID3DX11EffectGroup*, GetGroupByIndex)(UINT Index);
    STDMETHOD_(ID3DX11EffectGroup*, GetGroupByName)(LPCSTR Name);

    STDMETHOD_(ID3D11ClassLinkage*, GetClassLinkage)();

    STDMETHOD(CloneEffect)(UINT Flags, ID3DX11Effect** ppClonedEffect);
    STDMETHOD(Optimize)();
    STDMETHOD_(BOOL, IsOptimized)();

    //////////////////////////////////////////////////////////////////////////    
    // New reflection helpers

    ID3DX11EffectType * CreatePooledSingleElementTypeInterface(SType *pType);
    ID3DX11EffectVariable * CreatePooledVariableMemberInterface(TTopLevelVariable<ID3DX11EffectVariable> *pTopLevelEntity, SVariable *pMember, UDataPointer Data, BOOL IsSingleElement, UINT Index);

};

}

```

`Source Code/Effects11/EffectAPI.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       EffectAPI.cpp
//  Content:    D3DX11 Effect DLL entry points
//
//////////////////////////////////////////////////////////////////////////////

#include "pchfx.h"

using namespace D3DX11Effects;

HRESULT WINAPI D3DX11CreateEffectFromMemory(CONST void *pData, SIZE_T DataLength, UINT FXFlags, ID3D11Device *pDevice, ID3DX11Effect **ppEffect)
{
    HRESULT hr = S_OK;

    // Note that pData must point to a compiled effect, not HLSL
    VN( *ppEffect = NEW CEffect( FXFlags & D3DX11_EFFECT_RUNTIME_VALID_FLAGS) );
    VH( ((CEffect*)(*ppEffect))->LoadEffect(pData, static_cast<UINT>(DataLength)) );
    VH( ((CEffect*)(*ppEffect))->BindToDevice(pDevice) );

lExit:
    if (FAILED(hr))
    {
        SAFE_RELEASE(*ppEffect);
    }
    return hr;
}

```

`Source Code/Effects11/EffectLoad.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       EffectLoad.cpp
//  Content:    D3DX11 Effects file loading code
//
//////////////////////////////////////////////////////////////////////////////

#include "pchfx.h"

#include <EffectStates11.h>

#define PRIVATENEW new(m_BulkHeap)

namespace D3DX11Effects
{

LPCSTR g_szEffectLoadArea = "D3D11EffectLoader";

SRasterizerBlock g_NullRasterizer;
SDepthStencilBlock g_NullDepthStencil;
SBlendBlock g_NullBlend;
SShaderResource g_NullTexture;
SInterface g_NullInterface;
SUnorderedAccessView g_NullUnorderedAccessView;
SRenderTargetView g_NullRenderTargetView;
SDepthStencilView g_NullDepthStencilView;

// these VTables must be setup in the proper order:
// 1) SetShader
// 2) SetConstantBuffers
// 3) SetSamplers
// 4) SetShaderResources
// 5) CreateShader
SD3DShaderVTable g_vtPS = {
    (void (__stdcall ID3D11DeviceContext::*)(ID3D11DeviceChild*, ID3D11ClassInstance*const*, UINT)) &ID3D11DeviceContext::PSSetShader,
    &ID3D11DeviceContext::PSSetConstantBuffers,
    &ID3D11DeviceContext::PSSetSamplers,
    &ID3D11DeviceContext::PSSetShaderResources,
    (HRESULT (__stdcall ID3D11Device::*)(const void *, SIZE_T, ID3D11ClassLinkage*, ID3D11DeviceChild **)) &ID3D11Device::CreatePixelShader
};

SD3DShaderVTable g_vtVS = {
    (void (__stdcall ID3D11DeviceContext::*)(ID3D11DeviceChild*, ID3D11ClassInstance*const*, UINT)) &ID3D11DeviceContext::VSSetShader,
    &ID3D11DeviceContext::VSSetConstantBuffers,
    &ID3D11DeviceContext::VSSetSamplers,
    &ID3D11DeviceContext::VSSetShaderResources,
    (HRESULT (__stdcall ID3D11Device::*)(const void *, SIZE_T, ID3D11ClassLinkage*, ID3D11DeviceChild **)) &ID3D11Device::CreateVertexShader
};

SD3DShaderVTable g_vtGS = {
    (void (__stdcall ID3D11DeviceContext::*)(ID3D11DeviceChild*, ID3D11ClassInstance*const*, UINT)) &ID3D11DeviceContext::GSSetShader,
    &ID3D11DeviceContext::GSSetConstantBuffers,
    &ID3D11DeviceContext::GSSetSamplers,
    &ID3D11DeviceContext::GSSetShaderResources,
    (HRESULT (__stdcall ID3D11Device::*)(const void *, SIZE_T, ID3D11ClassLinkage*, ID3D11DeviceChild **)) &ID3D11Device::CreateGeometryShader
};

SD3DShaderVTable g_vtHS = {
    (void (__stdcall ID3D11DeviceContext::*)(ID3D11DeviceChild*, ID3D11ClassInstance*const*, UINT)) &ID3D11DeviceContext::HSSetShader,
    &ID3D11DeviceContext::HSSetConstantBuffers,
    &ID3D11DeviceContext::HSSetSamplers,
    &ID3D11DeviceContext::HSSetShaderResources,
    (HRESULT (__stdcall ID3D11Device::*)(const void *, SIZE_T, ID3D11ClassLinkage*, ID3D11DeviceChild **)) &ID3D11Device::CreateHullShader
};

SD3DShaderVTable g_vtDS = {
    (void (__stdcall ID3D11DeviceContext::*)(ID3D11DeviceChild*, ID3D11ClassInstance*const*, UINT)) &ID3D11DeviceContext::DSSetShader,
    &ID3D11DeviceContext::DSSetConstantBuffers,
    &ID3D11DeviceContext::DSSetSamplers,
    &ID3D11DeviceContext::DSSetShaderResources,
    (HRESULT (__stdcall ID3D11Device::*)(const void *, SIZE_T, ID3D11ClassLinkage*, ID3D11DeviceChild **)) &ID3D11Device::CreateDomainShader
};

SD3DShaderVTable g_vtCS = {
    (void (__stdcall ID3D11DeviceContext::*)(ID3D11DeviceChild*, ID3D11ClassInstance*const*, UINT)) &ID3D11DeviceContext::CSSetShader,
    &ID3D11DeviceContext::CSSetConstantBuffers,
    &ID3D11DeviceContext::CSSetSamplers,
    &ID3D11DeviceContext::CSSetShaderResources,
    (HRESULT (__stdcall ID3D11Device::*)(const void *, SIZE_T, ID3D11ClassLinkage*, ID3D11DeviceChild **)) &ID3D11Device::CreateComputeShader
};

SShaderBlock g_NullVS(&g_vtVS);
SShaderBlock g_NullGS(&g_vtGS);
SShaderBlock g_NullPS(&g_vtPS);
SShaderBlock g_NullHS(&g_vtHS);
SShaderBlock g_NullDS(&g_vtDS);
SShaderBlock g_NullCS(&g_vtCS);

D3D10_SHADER_VARIABLE_TYPE GetSimpleParameterTypeFromObjectType(EObjectType ObjectType)
{
    switch (ObjectType)
    {
    case EOT_String:
        return D3D10_SVT_STRING;
    case EOT_Blend:
        return D3D10_SVT_BLEND;        
    case EOT_DepthStencil:
        return D3D10_SVT_DEPTHSTENCIL;        
    case EOT_Rasterizer:
        return D3D10_SVT_RASTERIZER;        
    case EOT_PixelShader:
    case EOT_PixelShader5:
        return D3D10_SVT_PIXELSHADER;        
    case EOT_VertexShader:
    case EOT_VertexShader5:
        return D3D10_SVT_VERTEXSHADER;        
    case EOT_GeometryShader:
    case EOT_GeometryShaderSO:
    case EOT_GeometryShader5:
        return D3D10_SVT_GEOMETRYSHADER;    
    case EOT_HullShader5:
        return D3D11_SVT_HULLSHADER;        
    case EOT_DomainShader5:
        return D3D11_SVT_DOMAINSHADER;        
    case EOT_ComputeShader5:
        return D3D11_SVT_COMPUTESHADER;        
    case EOT_RenderTargetView:
        return D3D10_SVT_RENDERTARGETVIEW;
    case EOT_DepthStencilView:
        return D3D10_SVT_DEPTHSTENCILVIEW;
    case EOT_Texture:
    case EOT_Texture1D:
    case EOT_Texture1DArray:
    case EOT_Texture2D:
    case EOT_Texture2DArray:
    case EOT_Texture2DMS:
    case EOT_Texture2DMSArray:
    case EOT_Texture3D:
    case EOT_TextureCube:
    case EOT_TextureCubeArray:
        return D3D10_SVT_TEXTURE;
    case EOT_Buffer:
        return D3D10_SVT_BUFFER;        
    case EOT_Sampler:
        return D3D10_SVT_SAMPLER;
    case EOT_ByteAddressBuffer:
        return D3D11_SVT_BYTEADDRESS_BUFFER;
    case EOT_StructuredBuffer:
        return D3D11_SVT_STRUCTURED_BUFFER;
    case EOT_RWTexture1D:
        return D3D11_SVT_RWTEXTURE1D;
    case EOT_RWTexture1DArray:
        return D3D11_SVT_RWTEXTURE1DARRAY;
    case EOT_RWTexture2D:
        return D3D11_SVT_RWTEXTURE2D;
    case EOT_RWTexture2DArray:
        return D3D11_SVT_RWTEXTURE2DARRAY;
    case EOT_RWTexture3D:
        return D3D11_SVT_RWTEXTURE3D;
    case EOT_RWBuffer:
        return D3D11_SVT_RWBUFFER;
    case EOT_RWByteAddressBuffer:
        return D3D11_SVT_RWBYTEADDRESS_BUFFER;
    case EOT_RWStructuredBuffer:
    case EOT_RWStructuredBufferAlloc:
    case EOT_RWStructuredBufferConsume:
        return D3D11_SVT_RWSTRUCTURED_BUFFER;
    case EOT_AppendStructuredBuffer:
        return D3D11_SVT_APPEND_STRUCTURED_BUFFER;
    case EOT_ConsumeStructuredBuffer:
        return D3D11_SVT_CONSUME_STRUCTURED_BUFFER;
    default:
        D3DXASSERT(0);
    }
    return D3D10_SVT_VOID;
}

inline HRESULT VerifyPointer(UINT  oBase, UINT  dwSize, UINT  dwMaxSize)
{
    UINT  dwAdd = oBase + dwSize;
    if (dwAdd < oBase || dwAdd > dwMaxSize)
        return E_FAIL;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
// EffectHeap 
// A simple class which assists in adding data to a block of memory
//////////////////////////////////////////////////////////////////////////

CEffectHeap::CEffectHeap()
{
    m_pData = NULL;
    m_dwSize = m_dwBufferSize = 0;
}

CEffectHeap::~CEffectHeap()
{
    SAFE_DELETE_ARRAY(m_pData);
}

UINT  CEffectHeap::GetSize()
{
    return m_dwSize;
}

HRESULT CEffectHeap::ReserveMemory(UINT  dwSize)
{
    HRESULT hr = S_OK;

    D3DXASSERT(!m_pData);
    D3DXASSERT(dwSize == AlignToPowerOf2(dwSize, c_DataAlignment));

    m_dwBufferSize = dwSize;

    VN( m_pData = NEW BYTE[m_dwBufferSize] );
    
    // make sure that we have machine word alignment
    D3DXASSERT(m_pData == AlignToPowerOf2(m_pData, c_DataAlignment));

lExit:
    return hr;
}

HRESULT CEffectHeap::AddString(const char *pString, __deref_out_z char **ppPointer)
{
    size_t size = strlen(pString) + 1;
    D3DXASSERT( size <= 0xffffffff );
    return AddData(pString, (UINT)size, (void**) ppPointer);
}

// This data is forcibly aligned, so make sure you account for that in calculating heap size
template <bool bCopyData>
HRESULT CEffectHeap::AddDataInternal(const void *pData, UINT  dwSize, void **ppPointer)
{
    CCheckedDword chkFinalSize( m_dwSize );
    UINT  finalSize;
    HRESULT hr = S_OK;

    chkFinalSize += dwSize;
    chkFinalSize += c_DataAlignment; // account for alignment

    VHD( chkFinalSize.GetValue(&finalSize), "Overflow while adding data to Effect heap."  );
    
    // align original value
    finalSize = AlignToPowerOf2(finalSize - c_DataAlignment, c_DataAlignment);
    VBD( finalSize <= m_dwBufferSize, "Overflow adding data to Effect heap." );

    *ppPointer = m_pData + m_dwSize;
    D3DXASSERT(*ppPointer == AlignToPowerOf2(*ppPointer, c_DataAlignment));

    if( bCopyData )
    {
        memcpy(*ppPointer, pData, dwSize);
    }
    m_dwSize = finalSize;

lExit:
    if (FAILED(hr))
        *ppPointer = NULL;

    return hr;
}

HRESULT CEffectHeap::AddData(const void *pData, UINT  dwSize, void **ppPointer)
{
    return AddDataInternal<true>( pData, dwSize, ppPointer );
}

// Moves a string from the general heap to the private heap and modifies the pointer to
//   point to the new memory block.
// The general heap is freed as a whole, so we don't worry about leaking the given string pointer.
// This data is forcibly aligned, so make sure you account for that in calculating heap size
HRESULT CEffectHeap::MoveString(__deref_inout_z char **ppString)
{
    HRESULT hr;
    char *pNewPointer;

    if (*ppString == NULL)
        return S_OK;

    hr = AddString(*ppString, &pNewPointer);
    *ppString = pNewPointer;

    return hr;
}

// Allocates space but does not move data
// The general heap is freed as a whole, so we don't worry about leaking the given string pointer.
// This data is forcibly aligned, so make sure you account for that in calculating heap size
HRESULT CEffectHeap::MoveEmptyDataBlock(void **ppData, UINT  size)
{
    HRESULT hr;
    void *pNewPointer;

    hr = AddDataInternal<false>(*ppData, size, &pNewPointer);

    *ppData = pNewPointer;
    if (size == 0)
    {
        // To help catch bugs, set zero-byte blocks to null. There's no real reason to do this
        *ppData = NULL;
    }

    return hr;
}

// Moves an array of SInterfaceParameters from the general heap to the private heap and modifies the pointer to
//   point to the new memory block.
// The general heap is freed as a whole, so we don't worry about leaking the given string pointer.
// This data is forcibly aligned, so make sure you account for that in calculating heap size
HRESULT CEffectHeap::MoveInterfaceParameters(UINT InterfaceCount, __in_ecount(1) SShaderBlock::SInterfaceParameter **ppInterfaces)
{
    HRESULT hr;
    SShaderBlock::SInterfaceParameter *pNewPointer;

    if (*ppInterfaces == NULL)
        return S_OK;

    VBD( InterfaceCount <= D3D11_SHADER_MAX_INTERFACES, "Internal loading error: InterfaceCount > D3D11_SHADER_MAX_INTERFACES." );
    VH( AddData(*ppInterfaces, InterfaceCount * sizeof(SShaderBlock::SInterfaceParameter), (void**)&pNewPointer) );

    for( UINT i=0; i < InterfaceCount; i++ )
    {
        VH( MoveString( &pNewPointer[i].pName ) );
    }

    *ppInterfaces = pNewPointer;

lExit:
    return hr;
}


// Moves data from the general heap to the private heap and modifies the pointer to
//   point to the new memory block 
// The general heap is freed as a whole, so we don't worry about leaking the given pointer.
// This data is forcibly aligned, so make sure you account for that in calculating heap size
HRESULT CEffectHeap::MoveData(void **ppData, UINT  size)
{
    HRESULT hr;
    void *pNewPointer;

    hr = AddData(*ppData, size, &pNewPointer);
    
    *ppData = pNewPointer;
    if (size == 0)
    {
        // To help catch bugs, set zero-byte blocks to null. There's no real reason to do this
        *ppData = NULL;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////
// Load API 
//////////////////////////////////////////////////////////////////////////

HRESULT CEffect::LoadEffect(CONST void *pEffectBuffer, UINT  cbEffectBuffer)
{
    HRESULT hr = S_OK;
    CEffectLoader loader;

    if (!pEffectBuffer)
    {
        DPF(0, "%s: pEffectBuffer is NULL.", g_szEffectLoadArea);
        VH( E_INVALIDARG );
    }
    
    VH( loader.LoadEffect(this, pEffectBuffer, cbEffectBuffer) );

lExit:
    if( FAILED( hr ) )
    {
        // Release here because m_pShaderBlocks may still be in loader.m_BulkHeap if loading failed before we reallocated the memory
        ReleaseShaderRefection();
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////
// CEffectLoader
// A helper class which loads an effect
//////////////////////////////////////////////////////////////////////////

HRESULT CEffectLoader::GetUnstructuredDataBlock(UINT offset, UINT  *pdwSize, void **ppData)
{
    HRESULT hr = S_OK;
    UINT  *pBlockSize;

    VH( m_msUnstructured.ReadAtOffset(offset, sizeof(*pBlockSize), (void**) &pBlockSize ) );
    *pdwSize = *pBlockSize;

    VH( m_msUnstructured.Read(ppData, *pdwSize) );

lExit:
    return hr;
}

// position in buffer is lost on error
//
// This function should be used in 1:1 conjunction with CEffectHeap::MoveString;
// that is, any string added to the reflection heap with this function
// must be relocated with MoveString at some point later on.
HRESULT CEffectLoader::GetStringAndAddToReflection(UINT offset, __out_ecount_full(1) char **ppString)
{
    HRESULT hr = S_OK;
    LPCSTR pName;
    SIZE_T oldPos;
    
    if (offset == 0)
    {
        *ppString = NULL;
        goto lExit;
    }

    oldPos = m_msUnstructured.GetPosition();

    VH( m_msUnstructured.ReadAtOffset(offset, &pName) );
    m_ReflectionMemory += AlignToPowerOf2( (UINT)strlen(pName) + 1, c_DataAlignment);
    *ppString = const_cast<char*>(pName);
    
    m_msUnstructured.Seek(oldPos);

lExit:
    return hr;
}

// position in buffer is lost on error
//
// This function should be used in 1:1 conjunction with CEffectHeap::MoveInterfaceParameters;
// that is, any array of parameters added to the reflection heap with this function
// must be relocated with MoveInterfaceParameters at some point later on.
HRESULT CEffectLoader::GetInterfaceParametersAndAddToReflection( UINT InterfaceCount, UINT offset, __out_ecount_full(1) SShaderBlock::SInterfaceParameter **ppInterfaces )
{
    HRESULT hr = S_OK;
    SBinaryInterfaceInitializer* pInterfaceInitializer;
    SIZE_T oldPos;

    if (offset == 0)
    {
        *ppInterfaces = NULL;
        goto lExit;
    }

    oldPos = m_msUnstructured.GetPosition();

    VBD( InterfaceCount <= D3D11_SHADER_MAX_INTERFACES, "Internal loading error: InterfaceCount > D3D11_SHADER_MAX_INTERFACES." );
    m_ReflectionMemory += AlignToPowerOf2(InterfaceCount * sizeof(SShaderBlock::SInterfaceParameter), c_DataAlignment);
    D3DXASSERT( ppInterfaces );
    (*ppInterfaces) = PRIVATENEW SShaderBlock::SInterfaceParameter[InterfaceCount];
    VN( *ppInterfaces );

    VHD( m_msUnstructured.ReadAtOffset(offset, sizeof(SBinaryInterfaceInitializer) * InterfaceCount, (void**)&pInterfaceInitializer),
         "Invalid pEffectBuffer: cannot read interface initializer." );

    for( UINT i=0; i < InterfaceCount; i++ )
    {
        (*ppInterfaces)[i].Index = pInterfaceInitializer[i].ArrayIndex;
        VHD( m_msUnstructured.ReadAtOffset(pInterfaceInitializer[i].oInstanceName, const_cast<LPCSTR*>(&(*ppInterfaces)[i].pName)),
             "Invalid pEffectBuffer: cannot read interface initializer." );
        m_ReflectionMemory += AlignToPowerOf2( (UINT)strlen((*ppInterfaces)[i].pName) + 1, c_DataAlignment);
    }

    m_msUnstructured.Seek(oldPos);

lExit:
    return hr;
}

HRESULT CEffectLoader::FixupCBPointer(SConstantBuffer **ppCB)
{
    HRESULT hr = S_OK;
    
    SIZE_T index = (SConstantBuffer*)*ppCB - m_pOldCBs;
    D3DXASSERT( index * sizeof(SConstantBuffer) == ((size_t)(SConstantBuffer*)*ppCB - (size_t)m_pOldCBs) );
    VBD( index < m_pEffect->m_CBCount, "Internal loading error: invalid constant buffer index." );
    *ppCB = (SConstantBuffer*)(m_pEffect->m_pCBs + index);
    
lExit:
    return hr;
}

HRESULT CEffectLoader::FixupShaderPointer(SShaderBlock **ppShaderBlock)
{
    HRESULT hr = S_OK;
    if (*ppShaderBlock != &g_NullVS && *ppShaderBlock != &g_NullGS && *ppShaderBlock != &g_NullPS &&
        *ppShaderBlock != &g_NullHS && *ppShaderBlock != &g_NullDS && *ppShaderBlock != &g_NullCS && 
        *ppShaderBlock != NULL)
    {
        SIZE_T index = *ppShaderBlock - m_pOldShaders;
        D3DXASSERT( index * sizeof(SShaderBlock) == ((size_t)*ppShaderBlock - (size_t)m_pOldShaders) );
        VBD( index < m_pEffect->m_ShaderBlockCount, "Internal loading error: invalid shader index."  );
        *ppShaderBlock = m_pEffect->m_pShaderBlocks + index;
    }
lExit:
    return hr;
}

HRESULT CEffectLoader::FixupDSPointer(SDepthStencilBlock **ppDSBlock)
{
    HRESULT hr = S_OK;
    if (*ppDSBlock != &g_NullDepthStencil && *ppDSBlock != NULL)
    {
        SIZE_T index = *ppDSBlock - m_pOldDS;
        D3DXASSERT( index * sizeof(SDepthStencilBlock) == ((size_t)*ppDSBlock - (size_t)m_pOldDS) );
        VBD( index < m_pEffect->m_DepthStencilBlockCount, "Internal loading error: invalid depth-stencil state index." );
        *ppDSBlock = m_pEffect->m_pDepthStencilBlocks + index;
    }
lExit:
    return hr;
}

HRESULT CEffectLoader::FixupABPointer(SBlendBlock **ppABBlock)
{
    HRESULT hr = S_OK;
    if (*ppABBlock != &g_NullBlend && *ppABBlock != NULL)
    {
        SIZE_T index = *ppABBlock - m_pOldAB;
        D3DXASSERT( index * sizeof(SBlendBlock) == ((size_t)*ppABBlock - (size_t)m_pOldAB) );
        VBD( index < m_pEffect->m_BlendBlockCount, "Internal loading error: invalid blend state index." );
        *ppABBlock = m_pEffect->m_pBlendBlocks + index;
    }
lExit:
    return hr;
}

HRESULT CEffectLoader::FixupRSPointer(SRasterizerBlock **ppRSBlock)
{
    HRESULT hr = S_OK;
    if (*ppRSBlock != &g_NullRasterizer && *ppRSBlock != NULL)
    {
        SIZE_T index = *ppRSBlock - m_pOldRS;
        D3DXASSERT( index * sizeof(SRasterizerBlock) == ((size_t)*ppRSBlock - (size_t)m_pOldRS) );
        VBD( index < m_pEffect->m_RasterizerBlockCount, "Internal loading error: invalid rasterizer state index." );
        *ppRSBlock = m_pEffect->m_pRasterizerBlocks + index;
    }
lExit:
    return hr;
}

HRESULT CEffectLoader::FixupSamplerPointer(SSamplerBlock **ppSampler)
{
    HRESULT hr = S_OK;
    SIZE_T index = *ppSampler - m_pOldSamplers;
    D3DXASSERT( index * sizeof(SSamplerBlock) == ((size_t)*ppSampler - (size_t)m_pOldSamplers) );
    VBD( index < m_pEffect->m_SamplerBlockCount, "Internal loading error: invalid sampler index." );
    *ppSampler = m_pEffect->m_pSamplerBlocks + index;

lExit:
    return hr;
}

HRESULT CEffectLoader::FixupInterfacePointer(SInterface **ppInterface, bool CheckBackgroundInterfaces)
{
    HRESULT hr = S_OK;
    if (*ppInterface != &g_NullInterface && *ppInterface != NULL)
    {
        SIZE_T index = *ppInterface - m_pOldInterfaces;
        if(index < m_OldInterfaceCount)
        {
            D3DXASSERT( index * sizeof(SInterface) == ((size_t)*ppInterface - (size_t)m_pOldInterfaces) );
            *ppInterface = m_pEffect->m_pInterfaces + index;
        }
        else
        {
            VBD( CheckBackgroundInterfaces, "Internal loading error: invalid interface pointer." );
            for( index=0; index < m_BackgroundInterfaces.GetSize(); index++ )
            {
                if( *ppInterface == m_BackgroundInterfaces[ (UINT)index ] )
                {
                    // The interfaces m_BackgroundInterfaces were concatenated to the original ones in m_pEffect->m_pInterfaces
                    *ppInterface = m_pEffect->m_pInterfaces + (m_OldInterfaceCount + index);
                    break;
                }
            }
            VBD( index < m_BackgroundInterfaces.GetSize(), "Internal loading error: invalid interface pointer." );
        }
    }

lExit:
    return hr;
}

HRESULT CEffectLoader::FixupShaderResourcePointer(SShaderResource **ppResource)
{
    HRESULT hr = S_OK;
    if (*ppResource != &g_NullTexture && *ppResource != NULL)
    {
        SIZE_T index = *ppResource - m_pOldShaderResources;
        D3DXASSERT( index * sizeof(SShaderResource) == ((size_t)*ppResource - (size_t)m_pOldShaderResources) );
        
        // could be a TBuffer or a texture; better check first
        if (index < m_pEffect->m_ShaderResourceCount)
        {
            *ppResource = m_pEffect->m_pShaderResources + index;
        }
        else
        {
            // if this is a TBuffer, then the shader resource pointer
            // actually points into a SConstantBuffer's TBuffer field
            index = (SConstantBuffer*)*ppResource - (SConstantBuffer*)&m_pOldCBs->TBuffer;
            D3DXASSERT( index * sizeof(SConstantBuffer) == ((size_t)(SConstantBuffer*)*ppResource - (size_t)(SConstantBuffer*)&m_pOldCBs->TBuffer) );
            VBD( index < m_pEffect->m_CBCount, "Internal loading error: invalid SRV index." );
            *ppResource = &m_pEffect->m_pCBs[index].TBuffer;
        }
    }
    
lExit:
    return hr;
}

HRESULT CEffectLoader::FixupUnorderedAccessViewPointer(SUnorderedAccessView **ppUnorderedAccessView)
{
    HRESULT hr = S_OK;
    if (*ppUnorderedAccessView != &g_NullUnorderedAccessView && *ppUnorderedAccessView != NULL)
    {
        SIZE_T index = *ppUnorderedAccessView - m_pOldUnorderedAccessViews;
        D3DXASSERT( index * sizeof(SUnorderedAccessView) == ((size_t)*ppUnorderedAccessView - (size_t)m_pOldUnorderedAccessViews) );

        VBD( index < m_pEffect->m_UnorderedAccessViewCount, "Internal loading error: invalid UAV index." );
        *ppUnorderedAccessView = m_pEffect->m_pUnorderedAccessViews + index;
    }

lExit:
    return hr;
}

HRESULT CEffectLoader::FixupRenderTargetViewPointer(SRenderTargetView **ppRenderTargetView)
{
    HRESULT hr = S_OK;
    if (*ppRenderTargetView != &g_NullRenderTargetView && *ppRenderTargetView != NULL)
    {
        SIZE_T index = *ppRenderTargetView - m_pOldRenderTargetViews;
        D3DXASSERT( index * sizeof(SRenderTargetView) == ((size_t)*ppRenderTargetView - (size_t)m_pOldRenderTargetViews) );
        VBD( index < m_pEffect->m_RenderTargetViewCount, "Internal loading error: invalid RTV index." );
        *ppRenderTargetView = m_pEffect->m_pRenderTargetViews + index;
    }

lExit:
    return hr;
}

HRESULT CEffectLoader::FixupDepthStencilViewPointer(SDepthStencilView **ppDepthStencilView)
{
    HRESULT hr = S_OK;
    if (*ppDepthStencilView != &g_NullDepthStencilView && *ppDepthStencilView != NULL)
    {
        SIZE_T index = *ppDepthStencilView - m_pOldDepthStencilViews;
        D3DXASSERT( index * sizeof(SDepthStencilView) == ((size_t)*ppDepthStencilView - (size_t)m_pOldDepthStencilViews) );
        VBD( index < m_pEffect->m_DepthStencilViewCount, "Internal loading error: invalid DSV index." );
        *ppDepthStencilView = m_pEffect->m_pDepthStencilViews + index;
    }

lExit:
    return hr;
}

HRESULT CEffectLoader::FixupStringPointer(SString **ppString)
{
    HRESULT hr = S_OK;
    SIZE_T index = *ppString - m_pOldStrings;
    D3DXASSERT( index * sizeof(SString) == ((size_t)*ppString - (size_t)m_pOldStrings) );
    VBD(index < m_pEffect->m_StringCount, "Internal loading error: invalid string index." );
    *ppString = m_pEffect->m_pStrings + index;
lExit:
    return hr;
}

HRESULT CEffectLoader::FixupMemberDataPointer(SMemberDataPointer **ppMemberData)
{
    HRESULT hr = S_OK;
    SIZE_T index = *ppMemberData - m_pOldMemberDataBlocks;
    D3DXASSERT( index * sizeof(SMemberDataPointer) == ((size_t)*ppMemberData - (size_t)m_pOldMemberDataBlocks) );
    VBD( index < m_pEffect->m_MemberDataCount, "Internal loading error: invalid member block index." );
    *ppMemberData = m_pEffect->m_pMemberDataBlocks + index;
lExit:
    return hr;
}

HRESULT CEffectLoader::FixupVariablePointer(SGlobalVariable **ppVar)
{
    HRESULT hr = S_OK;
    SIZE_T index = *ppVar - m_pOldVars;

    if( index < m_pEffect->m_VariableCount )
    {
        D3DXASSERT( index * sizeof(SGlobalVariable) == ((size_t)*ppVar - (size_t)m_pOldVars) );
        *ppVar = m_pEffect->m_pVariables + index;
    }
    else if( m_pvOldMemberInterfaces )
    {
        // When cloning, m_pvOldMemberInterfaces may be non-NULL, and *ppVar may point to a variable in it.
        const SIZE_T Members = m_pvOldMemberInterfaces->GetSize();
        for( index=0; index < Members; index++ )
        {
            if( (ID3DX11EffectVariable*)(*m_pvOldMemberInterfaces)[ (UINT)index] == (ID3DX11EffectVariable*)*ppVar )
            {
                break;
            }
        }
        VBD( index < Members, "Internal loading error: invalid member pointer." );
        *ppVar = (SGlobalVariable*)m_pEffect->m_pMemberInterfaces[ (UINT)index];
    }
lExit:
    return hr;
}

HRESULT CEffectLoader::FixupGroupPointer(SGroup **ppGroup)
{
    HRESULT hr = S_OK;
    if( *ppGroup != NULL )
    {
        SIZE_T index = *ppGroup - m_pOldGroups;
        D3DXASSERT( index * sizeof(SGroup) == ((size_t)*ppGroup - (size_t)m_pOldGroups) );
        VBD( index < m_pEffect->m_GroupCount, "Internal loading error: invalid group index." );
        *ppGroup = m_pEffect->m_pGroups + index;
    }
lExit:
    return hr;
}

HRESULT GetEffectVersion( UINT effectFileTag, DWORD* pVersion )
{
    D3DXASSERT( pVersion != NULL );
    if( !pVersion )
        return E_FAIL;

    for( UINT i = 0; i < NUM_EFFECT10_VERSIONS; i++ )
    {
        if( g_EffectVersions[i].m_Tag == effectFileTag )
        {
            *pVersion = g_EffectVersions[i].m_Version;
            return S_OK;
        }
    }

    return E_FAIL;
}

HRESULT CEffectLoader::LoadEffect(CEffect *pEffect, CONST void *pEffectBuffer, UINT  cbEffectBuffer)
{
    HRESULT hr = S_OK;
    UINT  i, varSize, cMemberDataBlocks;
    CCheckedDword chkVariables = 0;

    // Used for cloning
    m_pvOldMemberInterfaces = NULL;

    m_BulkHeap.EnableAlignment();

    D3DXASSERT(pEffect && pEffectBuffer);
    m_pEffect = pEffect;
    m_EffectMemory = m_ReflectionMemory = 0;

    VN( m_pEffect->m_pReflection = NEW CEffectReflection() );
    m_pReflection = m_pEffect->m_pReflection;

    // Begin effect load
    VN( m_pEffect->m_pTypePool = NEW CEffect::CTypeHashTable );
    VN( m_pEffect->m_pStringPool = NEW CEffect::CStringHashTable );
    VN( m_pEffect->m_pPooledHeap = NEW CDataBlockStore );
    m_pEffect->m_pPooledHeap->EnableAlignment();
    m_pEffect->m_pTypePool->SetPrivateHeap(m_pEffect->m_pPooledHeap);
    m_pEffect->m_pStringPool->SetPrivateHeap(m_pEffect->m_pPooledHeap);

    VH( m_pEffect->m_pTypePool->AutoGrow() );
    VH( m_pEffect->m_pStringPool->AutoGrow() );

    // Load from blob
    m_pData = (BYTE*)pEffectBuffer;
    m_dwBufferSize = cbEffectBuffer;

    VH( m_msStructured.SetData(m_pData, m_dwBufferSize) );

    // At this point, we assume that the blob is valid
    VHD( m_msStructured.Read((void**) &m_pHeader, sizeof(*m_pHeader)), "pEffectBuffer is too small." );

    // Verify the version
    if( FAILED( hr = GetEffectVersion( m_pHeader->Tag, &m_Version ) ) )
    {
        DPF(0, "Effect version is unrecognized.  This runtime supports fx_5_0 to %s.", g_EffectVersions[NUM_EFFECT10_VERSIONS-1].m_pName );
        VH( hr );
    }

    if( m_pHeader->RequiresPool() || m_pHeader->Pool.cObjectVariables > 0 || m_pHeader->Pool.cNumericVariables > 0 )
    {
        DPF(0, "Effect11 does not support EffectPools." );
        VH( E_FAIL );
    }

    // Get shader block count
    VBD( m_pHeader->cInlineShaders <= m_pHeader->cTotalShaders, "Invalid Effect header: cInlineShaders > cTotalShaders." );

    // Make sure the counts for the Effect don't overflow
    chkVariables = m_pHeader->Effect.cObjectVariables;
    chkVariables += m_pHeader->Effect.cNumericVariables;
    chkVariables += m_pHeader->cInterfaceVariables;
    chkVariables *= sizeof(SGlobalVariable);
    VH( chkVariables.GetValue(&varSize) );

    // Make sure the counts for the SMemberDataPointers don't overflow
    chkVariables = m_pHeader->cClassInstanceElements;
    chkVariables += m_pHeader->cBlendStateBlocks;
    chkVariables += m_pHeader->cRasterizerStateBlocks;
    chkVariables += m_pHeader->cDepthStencilBlocks;
    chkVariables += m_pHeader->cSamplers;
    chkVariables += m_pHeader->Effect.cCBs; // Buffer (for CBuffers and TBuffers)
    chkVariables += m_pHeader->Effect.cCBs; // SRV (for TBuffers)
    VHD( chkVariables.GetValue(&cMemberDataBlocks), "Overflow: too many Effect variables." );

    // Allocate effect resources
    VN( m_pEffect->m_pCBs = PRIVATENEW SConstantBuffer[m_pHeader->Effect.cCBs] );
    VN( m_pEffect->m_pDepthStencilBlocks = PRIVATENEW SDepthStencilBlock[m_pHeader->cDepthStencilBlocks] );
    VN( m_pEffect->m_pRasterizerBlocks = PRIVATENEW SRasterizerBlock[m_pHeader->cRasterizerStateBlocks] );
    VN( m_pEffect->m_pBlendBlocks = PRIVATENEW SBlendBlock[m_pHeader->cBlendStateBlocks] );
    VN( m_pEffect->m_pSamplerBlocks = PRIVATENEW SSamplerBlock[m_pHeader->cSamplers] );
    
    // we allocate raw bytes for variables because they are polymorphic types that need to be placement new'ed
    VN( m_pEffect->m_pVariables = (SGlobalVariable *)PRIVATENEW BYTE[varSize] );
    VN( m_pEffect->m_pAnonymousShaders = PRIVATENEW SAnonymousShader[m_pHeader->cInlineShaders] );

    VN( m_pEffect->m_pGroups = PRIVATENEW SGroup[m_pHeader->cGroups] );
    VN( m_pEffect->m_pShaderBlocks = PRIVATENEW SShaderBlock[m_pHeader->cTotalShaders] );
    VN( m_pEffect->m_pStrings = PRIVATENEW SString[m_pHeader->cStrings] );
    VN( m_pEffect->m_pShaderResources = PRIVATENEW SShaderResource[m_pHeader->cShaderResources] );
    VN( m_pEffect->m_pUnorderedAccessViews = PRIVATENEW SUnorderedAccessView[m_pHeader->cUnorderedAccessViews] );
    VN( m_pEffect->m_pInterfaces = PRIVATENEW SInterface[m_pHeader->cInterfaceVariableElements] );
    VN( m_pEffect->m_pMemberDataBlocks = PRIVATENEW SMemberDataPointer[cMemberDataBlocks] );
    VN( m_pEffect->m_pRenderTargetViews = PRIVATENEW SRenderTargetView[m_pHeader->cRenderTargetViews] );
    VN( m_pEffect->m_pDepthStencilViews = PRIVATENEW SDepthStencilView[m_pHeader->cDepthStencilViews] );

    UINT oStructured = m_pHeader->cbUnstructured + sizeof(SBinaryHeader5);
    VHD( m_msStructured.Seek(oStructured), "Invalid pEffectBuffer: Missing structured data block." );
    VH( m_msUnstructured.SetData(m_pData + sizeof(SBinaryHeader5), oStructured - sizeof(SBinaryHeader5)) );

    VH( LoadCBs() );
    VH( LoadObjectVariables() );
    VH( LoadInterfaceVariables() );
    VH( LoadGroups() );

    // Build shader dependencies
    for (i=0; i<m_pEffect->m_ShaderBlockCount; i++)
    {
        VH( BuildShaderBlock(&m_pEffect->m_pShaderBlocks[i]) );
    }
    
    for( UINT iGroup=0; iGroup<m_pHeader->cGroups; iGroup++ )
    {
        SGroup *pGroup = &m_pEffect->m_pGroups[iGroup];
        pGroup->HasDependencies = FALSE;

        for( UINT iTechnique=0; iTechnique < pGroup->TechniqueCount; iTechnique++ )
        {
            STechnique* pTech = &pGroup->pTechniques[iTechnique];
            pTech->HasDependencies = FALSE;

            for( UINT iPass=0; iPass < pTech->PassCount; iPass++ )
            {
                SPassBlock *pPass = &pTech->pPasses[iPass];

                pTech->HasDependencies |= pPass->CheckDependencies();
            }
            pGroup->HasDependencies |= pTech->HasDependencies;
        }
    }

    VH( InitializeReflectionDataAndMoveStrings() );
    VH( ReallocateReflectionData() );
    VH( ReallocateEffectData() );

    VB( m_pReflection->m_Heap.GetSize() == m_ReflectionMemory );
    
    // Verify that all of the various block/variable types were loaded
    VBD( m_pEffect->m_VariableCount == (m_pHeader->Effect.cObjectVariables + m_pHeader->Effect.cNumericVariables + m_pHeader->cInterfaceVariables), "Internal loading error: mismatched variable count." );
    VBD( m_pEffect->m_ShaderBlockCount == m_pHeader->cTotalShaders, "Internal loading error: mismatched shader block count." );
    VBD( m_pEffect->m_AnonymousShaderCount == m_pHeader->cInlineShaders, "Internal loading error: mismatched anonymous variable count." );
    VBD( m_pEffect->m_ShaderResourceCount == m_pHeader->cShaderResources, "Internal loading error: mismatched SRV count." );
    VBD( m_pEffect->m_InterfaceCount == m_pHeader->cInterfaceVariableElements + m_BackgroundInterfaces.GetSize(), "Internal loading error: mismatched interface count." );
    VBD( m_pEffect->m_UnorderedAccessViewCount == m_pHeader->cUnorderedAccessViews, "Internal loading error: mismatched UAV count." );
    VBD( m_pEffect->m_MemberDataCount == cMemberDataBlocks, "Internal loading error: mismatched member data block count." );
    VBD( m_pEffect->m_RenderTargetViewCount == m_pHeader->cRenderTargetViews, "Internal loading error: mismatched RTV count." );
    VBD( m_pEffect->m_DepthStencilViewCount == m_pHeader->cDepthStencilViews, "Internal loading error: mismatched DSV count." );
    VBD( m_pEffect->m_DepthStencilBlockCount == m_pHeader->cDepthStencilBlocks, "Internal loading error: mismatched depth-stencil state count." );
    VBD( m_pEffect->m_BlendBlockCount == m_pHeader->cBlendStateBlocks, "Internal loading error: mismatched blend state count." );
    VBD( m_pEffect->m_RasterizerBlockCount == m_pHeader->cRasterizerStateBlocks, "Internal loading error: mismatched rasterizer state count." );
    VBD( m_pEffect->m_SamplerBlockCount == m_pHeader->cSamplers, "Internal loading error: mismatched sampler count." );
    VBD( m_pEffect->m_StringCount == m_pHeader->cStrings, "Internal loading error: mismatched string count." );

    // Uncomment if you really need this information
    // DPF(0, "Effect heap size: %d, reflection heap size: %d, allocations avoided: %d", m_EffectMemory, m_ReflectionMemory, m_BulkHeap.m_cAllocations);
    
lExit:
    return hr;
}

// position in buffer is lost on error
HRESULT CEffectLoader::LoadStringAndAddToPool(__out_ecount_full(1) char **ppString, UINT  dwOffset)
{
    HRESULT hr = S_OK;
    char *pName;
    UINT  hash;
    SIZE_T oldPos;
    CEffect::CStringHashTable::CIterator iter;
    UINT  len;

    if (dwOffset == 0)
    {
        *ppString = NULL;
        goto lExit;
    }

    oldPos = m_msUnstructured.GetPosition();

    VHD( m_msUnstructured.ReadAtOffset(dwOffset, (LPCSTR *) &pName), "Invalid pEffectBuffer: cannot read string." );
    len = (UINT)strlen(pName);
    hash = ComputeHash((BYTE *)pName, len);
    if (FAILED(m_pEffect->m_pStringPool->FindValueWithHash(pName, hash, &iter)))
    {
        D3DXASSERT( m_pEffect->m_pPooledHeap != NULL );
        VN( (*ppString) = new(*m_pEffect->m_pPooledHeap) char[len + 1] );
        memcpy(*ppString, pName, len + 1);
        VHD( m_pEffect->m_pStringPool->AddValueWithHash(*ppString, hash), "Internal loading error: failed to add string to pool." );
    }
    else
    {
        *ppString = const_cast<LPSTR>(iter.GetData());
    }

    m_msUnstructured.Seek(oldPos);

lExit:
    return hr;
}

HRESULT CEffectLoader::LoadTypeAndAddToPool(SType **ppType, UINT  dwOffset)
{
    HRESULT hr = S_OK;
    SBinaryType *psType;
    SBinaryNumericType *pNumericType;
    EObjectType *pObjectType;
    UINT  cMembers, iMember, cInterfaces;
    UINT  oBaseClassType;
    SType temporaryType;
    CEffect::CTypeHashTable::CIterator iter;
    BYTE *pHashBuffer;
    UINT  hash;
    SVariable *pTempMembers = NULL;
    
    m_HashBuffer.Empty();

    VHD( m_msUnstructured.ReadAtOffset(dwOffset, sizeof(SBinaryType), (void**) &psType), "Invalid pEffectBuffer: cannot read type." );
    VHD( LoadStringAndAddToPool(&temporaryType.pTypeName, psType->oTypeName), "Invalid pEffectBuffer: cannot read type name." );
    temporaryType.VarType = psType->VarType;
    temporaryType.Elements = psType->Elements;
    temporaryType.TotalSize = psType->TotalSize;
    temporaryType.Stride = psType->Stride;
    temporaryType.PackedSize = psType->PackedSize;

    // sanity check elements, size, stride, etc.
    UINT  cElements = max(1, temporaryType.Elements);
    VBD( cElements * temporaryType.Stride == AlignToPowerOf2(temporaryType.TotalSize, SType::c_RegisterSize), "Invalid pEffectBuffer: invalid type size." );
    VBD( temporaryType.Stride % SType::c_RegisterSize == 0, "Invalid pEffectBuffer: invalid type stride." );
    VBD( temporaryType.PackedSize <= temporaryType.TotalSize && temporaryType.PackedSize % cElements == 0, "Invalid pEffectBuffer: invalid type packed size." );

    switch(temporaryType.VarType)
    {
    case EVT_Object:
        VHD( m_msUnstructured.Read((void**) &pObjectType, sizeof(UINT)), "Invalid pEffectBuffer: cannot read object type." );
        temporaryType.ObjectType = *pObjectType;
        VBD( temporaryType.VarType > EOT_Invalid && temporaryType.VarType < EOT_Count, "Invalid pEffectBuffer: invalid object type." );
        
        VN( pHashBuffer = m_HashBuffer.AddRange(sizeof(temporaryType.VarType) + sizeof(temporaryType.Elements) + 
            sizeof(temporaryType.pTypeName) + sizeof(temporaryType.ObjectType)) );
        memcpy(pHashBuffer, &temporaryType.VarType, sizeof(temporaryType.VarType)); 
        pHashBuffer += sizeof(temporaryType.VarType);
        memcpy(pHashBuffer, &temporaryType.Elements, sizeof(temporaryType.Elements)); 
        pHashBuffer += sizeof(temporaryType.Elements);
        memcpy(pHashBuffer, &temporaryType.pTypeName, sizeof(temporaryType.pTypeName)); 
        pHashBuffer += sizeof(temporaryType.pTypeName);
        memcpy(pHashBuffer, &temporaryType.ObjectType, sizeof(temporaryType.ObjectType)); 
        break;

    case EVT_Interface:
        temporaryType.InterfaceType = NULL; 

        VN( pHashBuffer = m_HashBuffer.AddRange(sizeof(temporaryType.VarType) + sizeof(temporaryType.Elements) + 
            sizeof(temporaryType.pTypeName) + sizeof(temporaryType.ObjectType)) );
        memcpy(pHashBuffer, &temporaryType.VarType, sizeof(temporaryType.VarType)); 
        pHashBuffer += sizeof(temporaryType.VarType);
        memcpy(pHashBuffer, &temporaryType.Elements, sizeof(temporaryType.Elements)); 
        pHashBuffer += sizeof(temporaryType.Elements);
        memcpy(pHashBuffer, &temporaryType.pTypeName, sizeof(temporaryType.pTypeName)); 
        pHashBuffer += sizeof(temporaryType.pTypeName);
        memcpy(pHashBuffer, &temporaryType.ObjectType, sizeof(temporaryType.ObjectType)); 
        break;

    case EVT_Numeric:
        VHD( m_msUnstructured.Read((void**) &pNumericType, sizeof(SBinaryNumericType)), "Invalid pEffectBuffer: cannot read numeric type." );
        temporaryType.NumericType = *pNumericType;
        VBD( temporaryType.NumericType.Rows >= 1 && temporaryType.NumericType.Rows <= 4 &&
             temporaryType.NumericType.Columns >= 1 && temporaryType.NumericType.Columns <= 4 &&
             temporaryType.NumericType.NumericLayout != ENL_Invalid && temporaryType.NumericType.NumericLayout < ENL_Count &&
             temporaryType.NumericType.ScalarType > EST_Invalid && temporaryType.NumericType.ScalarType < EST_Count,
             "Invalid pEffectBuffer: invalid numeric type.");

        if (temporaryType.NumericType.NumericLayout != ENL_Matrix)
        {
            VBD( temporaryType.NumericType.IsColumnMajor == FALSE, "Invalid pEffectBuffer: only matricies can be column major." );
        }

        VN( pHashBuffer = m_HashBuffer.AddRange(sizeof(temporaryType.VarType) + sizeof(temporaryType.Elements) + 
            sizeof(temporaryType.pTypeName) + sizeof(temporaryType.NumericType)) );
        memcpy(pHashBuffer, &temporaryType.VarType, sizeof(temporaryType.VarType)); 
        pHashBuffer += sizeof(temporaryType.VarType);
        memcpy(pHashBuffer, &temporaryType.Elements, sizeof(temporaryType.Elements)); 
        pHashBuffer += sizeof(temporaryType.Elements);
        memcpy(pHashBuffer, &temporaryType.pTypeName, sizeof(temporaryType.pTypeName)); 
        pHashBuffer += sizeof(temporaryType.pTypeName);
        memcpy(pHashBuffer, &temporaryType.NumericType, sizeof(temporaryType.NumericType)); 
        break;

    case EVT_Struct:
        VHD( m_msUnstructured.Read(&cMembers), "Invalid pEffectBuffer: cannot read struct." );

        temporaryType.StructType.Members = cMembers;

        VN( pTempMembers = NEW SVariable[cMembers] );
        temporaryType.StructType.pMembers = pTempMembers;
        
        // read up all of the member descriptors at once
        SBinaryType::SBinaryMember *psMember;
        VHD( m_msUnstructured.Read((void**) &psMember, cMembers * sizeof(*psMember)), "Invalid pEffectBuffer: cannot read struct members." );

        {
            // Determine if this type implements an interface
            VHD( m_msUnstructured.Read(&oBaseClassType), "Invalid pEffectBuffer: cannot read base class type." );
            VHD( m_msUnstructured.Read(&cInterfaces), "Invalid pEffectBuffer: cannot read interfaces." );
            if( cInterfaces > 0 )
            {
                temporaryType.StructType.ImplementsInterface = 1;
                temporaryType.StructType.HasSuperClass = ( oBaseClassType > 0 ) ? 1 : 0;
            }
            else if( oBaseClassType > 0 )
            {
                // Get parent type and copy its ImplementsInterface
                SType* pBaseClassType;
                VH( LoadTypeAndAddToPool(&pBaseClassType, oBaseClassType) );
                temporaryType.StructType.ImplementsInterface = pBaseClassType->StructType.ImplementsInterface;
                temporaryType.StructType.HasSuperClass = 1;
            }
            // Read (and ignore) the interface types
            UINT *poInterface;
            VHD( m_msUnstructured.Read((void**) &poInterface, cInterfaces * sizeof(poInterface)), "Invalid pEffectBuffer: cannot read interface types." );
        }

        UINT  totalSize;
        totalSize = 0;
        for (iMember=0; iMember<cMembers; iMember++)
        {   
            SVariable *pMember;
            
            pMember = temporaryType.StructType.pMembers + iMember;

            VBD( psMember[iMember].Offset == totalSize || 
                 psMember[iMember].Offset == AlignToPowerOf2(totalSize, SType::c_RegisterSize),
                 "Internal loading error: invalid member offset." );

            pMember->Data.Offset = psMember[iMember].Offset;

            VH( LoadTypeAndAddToPool(&pMember->pType, psMember[iMember].oType) );
            VH( LoadStringAndAddToPool(&pMember->pName, psMember[iMember].oName) );
            VH( LoadStringAndAddToPool(&pMember->pSemantic, psMember[iMember].oSemantic) );
            
            totalSize = psMember[iMember].Offset + pMember->pType->TotalSize;
        }
        VBD( AlignToPowerOf2(totalSize, SType::c_RegisterSize) == temporaryType.Stride, "Internal loading error: invlid type size." );

        VN( pHashBuffer = m_HashBuffer.AddRange(sizeof(temporaryType.VarType) + sizeof(temporaryType.Elements) + 
            sizeof(temporaryType.pTypeName) + sizeof(temporaryType.StructType.Members) + cMembers * sizeof(SVariable)) );

        memcpy(pHashBuffer, &temporaryType.VarType, sizeof(temporaryType.VarType)); 
        pHashBuffer += sizeof(temporaryType.VarType);
        memcpy(pHashBuffer, &temporaryType.Elements, sizeof(temporaryType.Elements)); 
        pHashBuffer += sizeof(temporaryType.Elements);
        memcpy(pHashBuffer, &temporaryType.pTypeName, sizeof(temporaryType.pTypeName)); 
        pHashBuffer += sizeof(temporaryType.pTypeName);
        memcpy(pHashBuffer, &temporaryType.StructType.Members, sizeof(temporaryType.StructType.Members)); 
        pHashBuffer += sizeof(temporaryType.StructType.Members);
        memcpy(pHashBuffer, temporaryType.StructType.pMembers, cMembers * sizeof(SVariable));
        break;

    default:
        D3DXASSERT(0);
        VHD( E_FAIL, "Internal loading error: invalid variable type." );
    }

    hash = ComputeHash(&m_HashBuffer[0], m_HashBuffer.GetSize());
    if (FAILED(m_pEffect->m_pTypePool->FindValueWithHash(&temporaryType, hash, &iter)))
    {
        D3DXASSERT( m_pEffect->m_pPooledHeap != NULL );

        // allocate real member array, if necessary
        if (temporaryType.VarType == EVT_Struct)
        {
            VN( temporaryType.StructType.pMembers = new(*m_pEffect->m_pPooledHeap) SVariable[temporaryType.StructType.Members] );
            memcpy(temporaryType.StructType.pMembers, pTempMembers, temporaryType.StructType.Members * sizeof(SVariable));
        }

        // allocate real type
        VN( (*ppType) = new(*m_pEffect->m_pPooledHeap) SType );
        memcpy(*ppType, &temporaryType, sizeof(temporaryType));
        ZeroMemory(&temporaryType, sizeof(temporaryType));
        VH( m_pEffect->m_pTypePool->AddValueWithHash(*ppType, hash) );
    }
    else
    {
        *ppType = iter.GetData();
    }

lExit:
    SAFE_DELETE_ARRAY(pTempMembers);
    return hr;
}

// Numeric data in annotations are tightly packed (unlike in CBs which follow D3D11 packing rules).  This unpacks them.
UINT CEffectLoader::UnpackData(BYTE *pDestData, BYTE *pSrcData, UINT  PackedDataSize, SType *pType, UINT  *pBytesRead)
{
    UINT  bytesRead = 0;
    UINT  i, j, k;
    UINT  registers, entries;
    HRESULT hr = S_OK;
    UINT  elementsToCopy = max(pType->Elements, 1);

    switch (pType->VarType)
    {
    case EVT_Struct:
        for (i = 0; i < elementsToCopy; ++ i)
        {
            for (j = 0; j < pType->StructType.Members; ++ j)
            {
                UINT  br;
                D3DXASSERT((UINT_PTR)pType->StructType.pMembers[j].pType == (UINT)(UINT_PTR)pType->StructType.pMembers[j].pType);
                D3DXASSERT(PackedDataSize > bytesRead);                    

                VH( UnpackData(pDestData + pType->StructType.pMembers[j].Data.Offset, 
                    pSrcData + bytesRead, PackedDataSize - bytesRead, 
                    pType->StructType.pMembers[j].pType, &br) );
                
                bytesRead += br;
            }
            pDestData += pType->Stride;
        }
        break;

    case EVT_Numeric:
        if (pType->NumericType.IsPackedArray)
        {
            // No support for packed arrays
            D3DXASSERT(0);
            VHD(E_FAIL, "Internal loading error: packed arrays are not supported." );
        }
        else
        {
            UINT  bytesToCopy;

            if (pType->NumericType.IsColumnMajor)
            {
                registers = pType->NumericType.Columns;
                entries = pType->NumericType.Rows;
                bytesToCopy = entries * registers * SType::c_ScalarSize;

                for (i = 0; i < elementsToCopy; ++ i)
                {
                    for (j = 0; j < registers; ++ j)
                    {
                        for (k = 0; k < entries; ++ k)
                        {
                            // type cast to an arbitrary scalar
                            ((UINT*)pDestData)[k] = ((UINT*)pSrcData)[k * registers + j];
                        }
                        pDestData += SType::c_RegisterSize; // advance to next register
                    }
                    pSrcData += bytesToCopy;
                    bytesRead += bytesToCopy;
                }
            }
            else
            {
                registers = pType->NumericType.Rows;
                entries = pType->NumericType.Columns;
                bytesToCopy = entries * SType::c_ScalarSize;

                for (i = 0; i < elementsToCopy; ++ i)
                {
                    for (j = 0; j < registers; ++ j)
                    {
                        memcpy(pDestData, pSrcData, bytesToCopy);

                        pDestData += SType::c_RegisterSize; // advance to next register
                        pSrcData += bytesToCopy;
                        bytesRead += bytesToCopy;
                    }
                }
            }
        }
        break;

    default:
        // shouldn't be called on non-struct/numeric types
        D3DXASSERT(0);
        VHD(E_FAIL, "Internal loading error: UnpackData should not be called on non-struct, non-numeric types." );
    }  

lExit:
    *pBytesRead = bytesRead;
    return hr;
}

// Read info from the compiled blob and initialize a numeric variable
HRESULT CEffectLoader::LoadNumericVariable(SConstantBuffer *pParentCB)
{
    HRESULT hr = S_OK;
    SBinaryNumericVariable *psVar;
    SGlobalVariable *pVar;
    SType *pType;
    void *pDefaultValue;

    // Read variable info
    VHD( m_msStructured.Read((void**) &psVar, sizeof(*psVar)), "Invalid pEffectBuffer: cannot read numeric variable." );
    VBD( m_pEffect->m_VariableCount < (m_pHeader->Effect.cObjectVariables + m_pHeader->Effect.cNumericVariables + m_pHeader->cInterfaceVariables),
        "Internal loading error: invalid variable counts.");
    pVar = &m_pEffect->m_pVariables[m_pEffect->m_VariableCount];
    
    // Get type
    VH( LoadTypeAndAddToPool(&pType, psVar->oType) );
    
    // Make sure the right polymorphic type is created
    VH( PlacementNewVariable(pVar, pType, FALSE) );

    if (psVar->Flags & D3DX11_EFFECT_VARIABLE_EXPLICIT_BIND_POINT)
    {
        pVar->ExplicitBindPoint = psVar->Offset;
    }
    else
    {
        pVar->ExplicitBindPoint = -1;
    }

    pVar->pEffect = m_pEffect;
    pVar->pType = pType;
    pVar->pCB = pParentCB;
    pVar->Data.pGeneric = pParentCB->pBackingStore + psVar->Offset;
    VBD( psVar->Offset + pVar->pType->TotalSize <= pVar->pCB->Size, "Invalid pEffectBuffer: invalid variable offset." );

    if (pType->VarType == EVT_Struct && pType->StructType.ImplementsInterface && !pParentCB->IsTBuffer)
    {
        pVar->MemberDataOffsetPlus4 = m_pEffect->m_MemberDataCount * sizeof(SMemberDataPointer) + 4;
        m_pEffect->m_MemberDataCount += max(pType->Elements,1);
    }

    // Get name & semantic
    VHD( GetStringAndAddToReflection(psVar->oName, &pVar->pName), "Invalid pEffectBuffer: cannot read variable name." );
    VHD( GetStringAndAddToReflection(psVar->oSemantic, &pVar->pSemantic), "Invalid pEffectBuffer: cannot read variable semantic." );

    // Ensure the variable fits in the CBuffer and doesn't overflow
    VBD( pType->TotalSize + psVar->Offset <= pParentCB->Size &&
         pType->TotalSize + psVar->Offset >= pType->TotalSize, "Invalid pEffectBuffer: variable does not fit in CB." );

    ZeroMemory(pVar->Data.pGeneric, pType->TotalSize);

    // Get default value
    if (0 != psVar->oDefaultValue)
    {
        UINT  bytesUnpacked;
        VHD( m_msUnstructured.ReadAtOffset(psVar->oDefaultValue, pType->PackedSize, &pDefaultValue), "Invalid pEffectBuffer: cannot read default value." );
        VH( UnpackData((BYTE*) pVar->Data.pGeneric, (BYTE*) pDefaultValue, pType->PackedSize, pType, &bytesUnpacked) );
        VBD( bytesUnpacked == pType->PackedSize, "Invalid pEffectBuffer: invalid type packed size.");
    }
    
    // We need to use offsets until we fixup
    pVar->Data.Offset = psVar->Offset;

    // Read annotations
    VH( LoadAnnotations(&pVar->AnnotationCount, &pVar->pAnnotations) );

    m_pEffect->m_VariableCount++;

lExit:
    return hr;
}

// Read info from the compiled blob and initialize a constant buffer
HRESULT CEffectLoader::LoadCBs()
{
    HRESULT hr = S_OK;
    UINT  iCB, iVar;

    for (iCB=0; iCB<m_pHeader->Effect.cCBs; iCB++)
    {
        SBinaryConstantBuffer *psCB;
        SConstantBuffer *pCB;

        VHD( m_msStructured.Read((void**) &psCB, sizeof(*psCB)), "Invalid pEffectBuffer: cannot read CB." );
        pCB = &m_pEffect->m_pCBs[iCB];

        VHD( GetStringAndAddToReflection(psCB->oName, &pCB->pName), "Invalid pEffectBuffer: cannot read CB name." );

        pCB->IsTBuffer = (psCB->Flags & SBinaryConstantBuffer::c_IsTBuffer) != 0 ? TRUE : FALSE;
        pCB->IsSingle = (psCB->Flags & SBinaryConstantBuffer::c_IsSingle) != 0 ? TRUE : FALSE;
        pCB->Size = psCB->Size;
        pCB->ExplicitBindPoint = psCB->ExplicitBindPoint;
        VBD( pCB->Size == AlignToPowerOf2(pCB->Size, SType::c_RegisterSize), "Invalid pEffectBuffer: CB size not a power of 2." );
        VN( pCB->pBackingStore = PRIVATENEW BYTE[pCB->Size] );
        
        pCB->MemberDataOffsetPlus4 = m_pEffect->m_MemberDataCount * sizeof(SMemberDataPointer) + 4;
        m_pEffect->m_MemberDataCount += 2;

        // point this CB to variables that it owns
        pCB->VariableCount = psCB->cVariables;
        if (pCB->VariableCount > 0)
        {
            pCB->pVariables = &m_pEffect->m_pVariables[m_pEffect->m_VariableCount];
        }
        else
        {
            pCB->pVariables = NULL;
        }

        // Read annotations
        VH( LoadAnnotations(&pCB->AnnotationCount, &pCB->pAnnotations) );

        for (iVar=0; iVar<psCB->cVariables; iVar++)
        {
            VH( LoadNumericVariable(pCB) );
        }
    }

    m_pEffect->m_CBCount = m_pHeader->Effect.cCBs;

lExit:
    return hr;
}

// Used by LoadAssignment to initialize members on load
HRESULT CEffectLoader::ExecuteConstantAssignment(SBinaryConstant *pConstant, void *pLHS, D3D10_SHADER_VARIABLE_TYPE lhsType)
{
    HRESULT hr = S_OK;

    switch(pConstant->Type)
    {
    case EST_UInt:
    case EST_Int:
    case EST_Bool:
        switch(lhsType)
        {
        case D3D10_SVT_BOOL:
        case D3D10_SVT_INT:
        case D3D10_SVT_UINT:
            *(UINT*) pLHS = pConstant->iValue;
            break;

        case D3D10_SVT_UINT8:
            *(BYTE*) pLHS = (BYTE) pConstant->iValue;
            break;

        case D3D10_SVT_FLOAT:
            *(float*) pLHS = (float) pConstant->iValue;
            break;

        default:
            VHD( E_FAIL, "Internal loading error: invalid left-hand assignment type." );
        }
        break;

    case EST_Float:
        switch(lhsType)
        {
        case D3D10_SVT_BOOL:
        case D3D10_SVT_INT:
        case D3D10_SVT_UINT:
            *(UINT*) pLHS = (UINT) pConstant->fValue;
            break;

        case D3D10_SVT_UINT8:
            *(BYTE*) pLHS = (BYTE) pConstant->fValue;
            break;

        case D3D10_SVT_FLOAT:
            *(float*) pLHS = pConstant->fValue;
            break;

        default:
            VHD( E_FAIL, "Internal loading error: invalid left-hand assignment type." );
        }
        break;

    default:
        VHD( E_FAIL, "Internal loading error: invalid left-hand assignment type." );
    }

lExit:
    return hr;
}


// Read info from the compiled blob and initialize a set of assignments
HRESULT CEffectLoader::LoadAssignments( UINT Assignments, SAssignment **ppAssignments, BYTE *pBackingStore, UINT *pRTVAssignments, UINT *pFinalAssignments )
{
    HRESULT hr = S_OK;
    UINT  i, j;

    SBinaryAssignment *psAssignments;
    UINT  finalAssignments = 0;             // the number of assignments worth keeping    
    UINT  renderTargetViewAssns = 0;        // Number of render target view assns, used by passes since SetRTV is a vararg call

    *pFinalAssignments = 0;
    if (pRTVAssignments)
        *pRTVAssignments = 0;

    VHD( m_msStructured.Read((void**) &psAssignments, sizeof(*psAssignments) * Assignments), "Invalid pEffectBuffer: cannot read assignments." );

    // allocate enough room to store all of the assignments (even though some may go unused)
    VN( (*ppAssignments) = PRIVATENEW SAssignment[Assignments] )
    
    //
    // In this loop, we read assignments 1-by-1, keeping some and discarding others.
    // We write to the "next" assignment which is given by &(*ppAssignments)[finalAssignments];
    // if an assignment is worth keeping, we increment finalAssignments.
    // This means that if you want to keep an assignment, you must be careful to initialize
    // all members of SAssignment because old values from preceding discarded assignments might remain.
    //
    for (i = 0; i < Assignments; ++ i)
    {
        SGlobalVariable *pVarArray, *pVarIndex, *pVar;
        const char *pGlobalVarName;
        SAssignment *pAssignment = &(*ppAssignments)[finalAssignments];
        BYTE *pLHS;

        VBD( psAssignments[i].iState < NUM_STATES, "Invalid pEffectBuffer: invalid assignment state." );
        VBD( psAssignments[i].Index < g_lvGeneral[psAssignments[i].iState].m_Indices, "Invalid pEffectBuffer: invalid assignment index." );

        pAssignment->LhsType = g_lvGeneral[psAssignments[i].iState].m_LhsType;

        // Count RenderTargetView assignments
        if (pAssignment->LhsType == ELHS_RenderTargetView)
            renderTargetViewAssns++;

        switch (g_lvGeneral[psAssignments[i].iState].m_Type)
        {
        case D3D10_SVT_UINT8:
            D3DXASSERT(g_lvGeneral[psAssignments[i].iState].m_Cols == 1); // BYTE arrays not supported
            pAssignment->DataSize = sizeof(BYTE);
            // Store an offset for destination instead of a pointer so that it's easy to relocate it later
            
            break;

        case D3D10_SVT_BOOL:
        case D3D10_SVT_INT:
        case D3D10_SVT_UINT:
        case D3D10_SVT_FLOAT:
            pAssignment->DataSize = SType::c_ScalarSize * g_lvGeneral[psAssignments[i].iState].m_Cols;
            break;

        case D3D10_SVT_RASTERIZER:
            pAssignment->DataSize = sizeof(SRasterizerBlock);
            break;

        case D3D10_SVT_DEPTHSTENCIL:
            pAssignment->DataSize = sizeof(SDepthStencilBlock);
            break;

        case D3D10_SVT_BLEND:
            pAssignment->DataSize = sizeof(SBlendBlock);
            break;

        case D3D10_SVT_VERTEXSHADER:
        case D3D10_SVT_GEOMETRYSHADER:
        case D3D10_SVT_PIXELSHADER:
        case D3D11_SVT_HULLSHADER:
        case D3D11_SVT_DOMAINSHADER:
        case D3D11_SVT_COMPUTESHADER:
            pAssignment->DataSize = sizeof(SShaderBlock);
            break;

        case D3D10_SVT_TEXTURE:
        case D3D10_SVT_TEXTURE1D:
        case D3D10_SVT_TEXTURE2D:
        case D3D10_SVT_TEXTURE2DMS:
        case D3D10_SVT_TEXTURE3D:
        case D3D10_SVT_TEXTURECUBE:
        case D3D10_SVT_TEXTURECUBEARRAY:
        case D3D11_SVT_BYTEADDRESS_BUFFER:
        case D3D11_SVT_STRUCTURED_BUFFER:
            pAssignment->DataSize = sizeof(SShaderResource);
            break;

        case D3D10_SVT_RENDERTARGETVIEW:
            pAssignment->DataSize = sizeof(SRenderTargetView);
            break;

        case D3D10_SVT_DEPTHSTENCILVIEW:
            pAssignment->DataSize = sizeof(SDepthStencilView);
            break;

        case D3D11_SVT_RWTEXTURE1D:
        case D3D11_SVT_RWTEXTURE1DARRAY:
        case D3D11_SVT_RWTEXTURE2D:
        case D3D11_SVT_RWTEXTURE2DARRAY:
        case D3D11_SVT_RWTEXTURE3D:
        case D3D11_SVT_RWBUFFER:
        case D3D11_SVT_RWBYTEADDRESS_BUFFER:
        case D3D11_SVT_RWSTRUCTURED_BUFFER:
        case D3D11_SVT_APPEND_STRUCTURED_BUFFER:
        case D3D11_SVT_CONSUME_STRUCTURED_BUFFER:
            pAssignment->DataSize = sizeof(SUnorderedAccessView);
            break;

        case D3D11_SVT_INTERFACE_POINTER:
            pAssignment->DataSize = sizeof(SInterface);
            break;

        default:
            D3DXASSERT(0);
            VHD( E_FAIL, "Internal loading error: invalid assignment type.");
        }

        UINT lhsStride;
        if( g_lvGeneral[psAssignments[i].iState].m_Stride > 0 )
            lhsStride = g_lvGeneral[psAssignments[i].iState].m_Stride;
        else
            lhsStride = pAssignment->DataSize;

        // Store only the destination offset so that the backing store pointers can be easily fixed up later
        pAssignment->Destination.Offset = g_lvGeneral[psAssignments[i].iState].m_Offset + lhsStride * psAssignments[i].Index;

        // As a result, you should use pLHS in this function instead of the destination pointer
        pLHS = pBackingStore + pAssignment->Destination.Offset;

        switch (psAssignments[i].AssignmentType)
        {
        case ECAT_Constant: // e.g. LHS = 1; or LHS = NULL;
            UINT  *pNumConstants;
            SBinaryConstant *pConstants;

            VHD( m_msUnstructured.ReadAtOffset(psAssignments[i].oInitializer, sizeof(UINT), (void**) &pNumConstants), "Invalid pEffectBuffer: cannot read NumConstants." );
            VHD( m_msUnstructured.Read((void **)&pConstants, sizeof(SBinaryConstant) * (*pNumConstants)), "Invalid pEffectBuffer: cannot read constants." );

            if(pAssignment->IsObjectAssignment())
            {
                // make sure this is a NULL assignment
                VBD( *pNumConstants == 1 && (pConstants[0].Type == EST_Int || pConstants[0].Type == EST_UInt) && pConstants[0].iValue == 0,
                    "Invalid pEffectBuffer: non-NULL constant assignment to object.");

                switch (pAssignment->LhsType)
                {
                case ELHS_DepthStencilBlock:
                    *((void **)pLHS) = &g_NullDepthStencil;
                    break;
                case ELHS_BlendBlock:
                    *((void **)pLHS) = &g_NullBlend;
                    break;
                case ELHS_RasterizerBlock:
                    *((void **)pLHS) = &g_NullRasterizer;
                    break;
                case ELHS_VertexShaderBlock:
                    *((void **)pLHS) = &g_NullVS;
                    break;
                case ELHS_PixelShaderBlock:
                    *((void **)pLHS) = &g_NullPS;
                    break;
                case ELHS_GeometryShaderBlock:
                    *((void **)pLHS) = &g_NullGS;
                    break;
                case ELHS_HullShaderBlock:
                    *((void **)pLHS) = &g_NullHS;
                    break;
                case ELHS_DomainShaderBlock:
                    *((void **)pLHS) = &g_NullDS;
                    break;
                case ELHS_ComputeShaderBlock:
                    *((void **)pLHS) = &g_NullCS;
                    break;
                case ELHS_Texture:
                    *((void **)pLHS) = &g_NullTexture;
                    break;
                case ELHS_DepthStencilView:
                    *((void **)pLHS) = &g_NullDepthStencilView;
                    break;
                case ELHS_RenderTargetView:
                    *((void **)pLHS) = &g_NullRenderTargetView;
                    break;
                default:
                    D3DXASSERT(0);
                }
            }
            else
            {
                VBD( *pNumConstants == g_lvGeneral[psAssignments[i].iState].m_Cols, "Internal loading error: mismatch constant count." );
                for (j = 0; j < *pNumConstants; ++ j)
                {
                    VH( ExecuteConstantAssignment(pConstants + j, pLHS, g_lvGeneral[psAssignments[i].iState].m_Type) );
                    pLHS += SType::c_ScalarSize; // arrays of constants will always be regular scalar sized, never byte-sized
                }
            }

            // Can get rid of this assignment
            break;

        case ECAT_Variable: // e.g. LHS = myVar;
            VHD( m_msUnstructured.ReadAtOffset(psAssignments[i].oInitializer, &pGlobalVarName), "Invalid pEffectBuffer: cannot read variable name." );

            VBD( pVar = m_pEffect->FindVariableByName(pGlobalVarName), "Loading error: cannot find variable name." );

            if (pAssignment->IsObjectAssignment())
            {
                VBD( pVar->pType->VarType == EVT_Object && 
                     GetSimpleParameterTypeFromObjectType(pVar->pType->ObjectType) == g_lvGeneral[psAssignments[i].iState].m_Type,
                     "Loading error: invalid variable type or object type." );

                // Write directly into the state block's backing store
                *((void **)pLHS) = pVar->Data.pGeneric;

                // Now we can get rid of this assignment
            }
            else
            {
                VBD( pVar->pType->BelongsInConstantBuffer(), "Invalid pEffectBuffer: assignment type mismatch." );

                pAssignment->DependencyCount = 1;
                VN( pAssignment->pDependencies = PRIVATENEW SAssignment::SDependency[pAssignment->DependencyCount] );
                pAssignment->pDependencies->pVariable = pVar;

                // Store an offset for numeric values instead of a pointer so that it's easy to relocate it later
                pAssignment->Source.Offset = pVar->Data.Offset;
                pAssignment->AssignmentType = ERAT_NumericVariable;

                // Can't get rid of this assignment
                ++ finalAssignments;
            }
            break;

        case ECAT_ConstIndex: // e.g. LHS = myGS[1]
            SBinaryAssignment::SConstantIndex *psConstIndex;

            VHD( m_msUnstructured.ReadAtOffset(psAssignments[i].oInitializer, sizeof(*psConstIndex), (void**) &psConstIndex),
                "Invalid pEffectBuffer: cannot read assignment initializer." );
            VHD( m_msUnstructured.ReadAtOffset(psConstIndex->oArrayName, &pGlobalVarName), "Invalid pEffectBuffer: cannot read array name." );

            VBD( pVarArray = m_pEffect->FindVariableByName(pGlobalVarName), "Loading error: cannot find array name." );

            if (pAssignment->IsObjectAssignment())
            {
                VBD( psConstIndex->Index < pVarArray->pType->Elements, "Invalid pEffectBuffer: out of bounds array index." );
                VBD( pVarArray->pType->VarType == EVT_Object && 
                     GetSimpleParameterTypeFromObjectType(pVarArray->pType->ObjectType) == g_lvGeneral[psAssignments[i].iState].m_Type,
                     "Loading error: invalid variable type or object type." );

                // Write directly into the state block's backing store
                *((void **)pLHS) = GetBlockByIndex(pVarArray->pType->VarType, pVarArray->pType->ObjectType, pVarArray->Data.pGeneric, psConstIndex->Index);
                VBD( NULL != *((void **)pLHS), "Internal loading error: invalid block." );

                // Now we can get rid of this assignment
            }
            else
            {
                VBD( pVarArray->pType->BelongsInConstantBuffer(), "Invalid pEffectBuffer: assignment type mismatch." );

                pAssignment->DependencyCount = 1;
                VN( pAssignment->pDependencies = PRIVATENEW SAssignment::SDependency[pAssignment->DependencyCount] );
                pAssignment->pDependencies->pVariable = pVarArray;

                CCheckedDword chkDataLen = psConstIndex->Index;
                UINT  dataLen;
                chkDataLen *= SType::c_ScalarSize;
                chkDataLen += pAssignment->DataSize;
                VHD( chkDataLen.GetValue(&dataLen), "Overflow: assignment size." );
                VBD( dataLen <= pVarArray->pType->TotalSize, "Internal loading error: assignment size mismatch" );

                pAssignment->Source.Offset = pVarArray->Data.Offset + psConstIndex->Index * SType::c_ScalarSize;

                // _NumericConstIndex is not used here because _NumericVariable 
                // does the same stuff in a more general fashion with no perf hit.  
                pAssignment->AssignmentType = ERAT_NumericVariable;

                // Can't get rid of this assignment
                ++ finalAssignments;
            }
            break;

        case ECAT_VariableIndex: // e.g. LHS = myVar[numLights];
            SBinaryAssignment::SVariableIndex *psVarIndex;

            VHD( m_msUnstructured.ReadAtOffset(psAssignments[i].oInitializer, sizeof(*psVarIndex), (void**) &psVarIndex),
                 "Invalid pEffectBuffer: cannot read assignment initializer." );
            VHD( m_msUnstructured.ReadAtOffset(psVarIndex->oArrayName, &pGlobalVarName), "Invalid pEffectBuffer: cannot read variable name." );
            VBD( pVarArray = m_pEffect->FindVariableByName(pGlobalVarName), "Loading error: cannot find variable name." );

            VHD( m_msUnstructured.ReadAtOffset(psVarIndex->oIndexVarName, &pGlobalVarName), "Invalid pEffectBuffer: cannot read index variable name." );
            VBD( pVarIndex = m_pEffect->FindVariableByName(pGlobalVarName), "Loading error: cannot find index variable name." );

            // Only support integer indices
            VBD( pVarIndex->pType->VarType == EVT_Numeric && (pVarIndex->pType->NumericType.ScalarType == EST_Int || pVarIndex->pType->NumericType.ScalarType == EST_UInt),
                 "Invalid pEffectBuffer: invalid index variable type.");
            VBD( pVarArray->pType->Elements > 0, "Invalid pEffectBuffer: array variable is not an array." );

            pVarIndex->pCB->IsUsedByExpression = TRUE;

            if (pAssignment->IsObjectAssignment())
            {
                VBD( pVarArray->pType->VarType == EVT_Object && 
                     GetSimpleParameterTypeFromObjectType(pVarArray->pType->ObjectType) == g_lvGeneral[psAssignments[i].iState].m_Type,
                     "Loading error: invalid variable type or object type." );

                // MaxElements is only 16-bits wide
                VBD( pVarArray->pType->Elements <= 0xFFFF, "Internal error: array size is too large." ); 
                pAssignment->MaxElements = pVarArray->pType->Elements;

                pAssignment->DependencyCount = 1;
                VN( pAssignment->pDependencies = PRIVATENEW SAssignment::SDependency[pAssignment->DependencyCount] );
                pAssignment->pDependencies[0].pVariable = pVarIndex;

                // Point this assignment to the start of the variable's object array.
                // When this assignment is dirty, we write the value of this pointer plus
                // the index given by its one dependency directly into the destination
                pAssignment->Source = pVarArray->Data;
                pAssignment->AssignmentType = ERAT_ObjectVariableIndex;
            }
            else
            {
                VBD( pVarArray->pType->BelongsInConstantBuffer(), "Invalid pEffectBuffer: assignment type mismatch." );

                pAssignment->DependencyCount = 2;
                VN( pAssignment->pDependencies = PRIVATENEW SAssignment::SDependency[pAssignment->DependencyCount] );
                pAssignment->pDependencies[0].pVariable = pVarIndex;
                pAssignment->pDependencies[1].pVariable = pVarArray;

                // When pVarIndex is updated, we update the source pointer.
                // When pVarArray is updated, we copy data from the source to the destination.
                pAssignment->Source.pGeneric = NULL;
                pAssignment->AssignmentType = ERAT_NumericVariableIndex;
            }

            // Can't get rid of this assignment
            ++ finalAssignments;

            break;

        case ECAT_ExpressionIndex:// e.g. LHS = myVar[a + b * c];
        case ECAT_Expression: // e.g. LHS = a + b * c;
            // we do not support FXLVM
            VHD( E_NOTIMPL, "FXLVM Expressions (complex assignments like myVar[i*2]) are not supported in Effects11." );
            break;

        case ECAT_InlineShader:
        case ECAT_InlineShader5:
            UINT  cbShaderBin;
            BYTE *pShaderBin;
            SShaderBlock *pShaderBlock;
            SAnonymousShader *pAnonShader;
            union
            {
                SBinaryAssignment::SInlineShader *psInlineShader;
                SBinaryShaderData5 *psInlineShader5;
            };

            // Inline shader assignments must be object types
            D3DXASSERT(pAssignment->IsObjectAssignment());

            C_ASSERT( offsetof(SBinaryAssignment::SInlineShader,oShader) == offsetof(SBinaryShaderData5,oShader) );
            C_ASSERT( offsetof(SBinaryAssignment::SInlineShader,oSODecl) == offsetof(SBinaryShaderData5,oSODecls) );
            if( psAssignments[i].AssignmentType == ECAT_InlineShader )
            {
                VHD( m_msUnstructured.ReadAtOffset(psAssignments[i].oInitializer, sizeof(*psInlineShader), (void**) &psInlineShader),
                     "Invalid pEffectBuffer: cannot read inline shader." );
            }
            else
            {
                VHD( m_msUnstructured.ReadAtOffset(psAssignments[i].oInitializer, sizeof(*psInlineShader5), (void**) &psInlineShader5),
                    "Invalid pEffectBuffer: cannot read inline shader." );
            }
            
            VBD( m_pEffect->m_ShaderBlockCount < m_pHeader->cTotalShaders, "Internal loading error: shader count is out incorrect." );
            VBD( m_pEffect->m_AnonymousShaderCount < m_pHeader->cInlineShaders, "Internal loading error: anonymous shader count is out incorrect." );

            pShaderBlock = &m_pEffect->m_pShaderBlocks[m_pEffect->m_ShaderBlockCount];
            pAnonShader = &m_pEffect->m_pAnonymousShaders[m_pEffect->m_AnonymousShaderCount];
            pAnonShader->pShaderBlock = pShaderBlock;

            ++ m_pEffect->m_ShaderBlockCount;
            ++ m_pEffect->m_AnonymousShaderCount;

            // Write directly into the state block's backing store
            *((void **)pLHS) = pShaderBlock;

            VHD( GetUnstructuredDataBlock(psInlineShader->oShader, &cbShaderBin, (void **) &pShaderBin), "Invalid pEffectBuffer: cannot read inline shader block." );

            if (cbShaderBin > 0)
            {
                VN( pShaderBlock->pReflectionData = PRIVATENEW SShaderBlock::SReflectionData );

                pShaderBlock->pReflectionData->BytecodeLength = cbShaderBin;
                pShaderBlock->pReflectionData->pBytecode = (BYTE*) pShaderBin;
                pShaderBlock->pReflectionData->pStreamOutDecls[0] =
                pShaderBlock->pReflectionData->pStreamOutDecls[1] =
                pShaderBlock->pReflectionData->pStreamOutDecls[2] =
                pShaderBlock->pReflectionData->pStreamOutDecls[3] = NULL;
                pShaderBlock->pReflectionData->RasterizedStream = 0;
                pShaderBlock->pReflectionData->IsNullGS = FALSE;
                pShaderBlock->pReflectionData->pReflection = NULL;
                pShaderBlock->pReflectionData->InterfaceParameterCount = 0;
                pShaderBlock->pReflectionData->pInterfaceParameters = NULL;
            }

            switch (pAssignment->LhsType)
            {
            case ELHS_PixelShaderBlock:
                pShaderBlock->pVT = &g_vtPS;
                VBD( psInlineShader->oSODecl == NULL, "Internal loading error: pixel shaders cannot have stream out decls." );
                break;
            
            case ELHS_GeometryShaderBlock:
                pShaderBlock->pVT = &g_vtGS;
                if( psAssignments[i].AssignmentType == ECAT_InlineShader )
                {
                    if (psInlineShader->oSODecl)
                    {
                        // This is a GS with SO
                        VHD( GetStringAndAddToReflection(psInlineShader->oSODecl, &pShaderBlock->pReflectionData->pStreamOutDecls[0]),
                             "Invalid pEffectBuffer: cannot read SO decl." );
                    }
                }
                else
                {
                    // This is a GS with addressable stream out
                    for( UINT iDecl=0; iDecl < psInlineShader5->cSODecls; ++iDecl )
                    {
                        if (psInlineShader5->oSODecls[iDecl])
                        {
                            VHD( GetStringAndAddToReflection(psInlineShader5->oSODecls[iDecl], &pShaderBlock->pReflectionData->pStreamOutDecls[iDecl]),
                                "Invalid pEffectBuffer: cannot read SO decl." );
                        }
                    }
                    pShaderBlock->pReflectionData->RasterizedStream = psInlineShader5->RasterizedStream;
                }
                break;

            case ELHS_VertexShaderBlock:
                pShaderBlock->pVT = &g_vtVS;
                VBD( psInlineShader->oSODecl == NULL, "Internal loading error: vertex shaders cannot have stream out decls." );
                break;

            case ELHS_HullShaderBlock:
                pShaderBlock->pVT = &g_vtHS;
                VBD( psInlineShader->oSODecl == NULL, "Internal loading error: hull shaders cannot have stream out decls." );
                break;

            case ELHS_DomainShaderBlock:
                pShaderBlock->pVT = &g_vtDS;
                VBD( psInlineShader->oSODecl == NULL, "Internal loading error: domain shaders cannot have stream out decls." );
                break;

            case ELHS_ComputeShaderBlock:
                pShaderBlock->pVT = &g_vtCS;
                VBD( psInlineShader->oSODecl == NULL, "Internal loading error: compute shaders cannot have stream out decls." );
                break;

            case ELHS_GeometryShaderSO:
                D3DXASSERT(0); // Should never happen

            default:
                VHD( E_FAIL, "Internal loading error: invalid shader type."  );
            }

            if( psAssignments[i].AssignmentType == ECAT_InlineShader5 )
            {
                pShaderBlock->pReflectionData->InterfaceParameterCount = psInlineShader5->cInterfaceBindings;
                VH( GetInterfaceParametersAndAddToReflection( psInlineShader5->cInterfaceBindings, psInlineShader5->oInterfaceBindings, &pShaderBlock->pReflectionData->pInterfaceParameters ) );
            }

            // Now we can get rid of this assignment
            break;

        default:
            D3DXASSERT(0);

        }
    }

    *pFinalAssignments = finalAssignments;
    if (pRTVAssignments)
        *pRTVAssignments = renderTargetViewAssns;

lExit:
    return hr;
}


// Read info from the compiled blob and initialize an object variable
HRESULT CEffectLoader::LoadObjectVariables()
{
    HRESULT hr = S_OK;
    UINT  iBlock;
    UINT  cBlocks;

    cBlocks = m_pHeader->Effect.cObjectVariables;

    for (iBlock=0; iBlock<cBlocks; iBlock++)
    {
        SBinaryObjectVariable *psBlock;
        SGlobalVariable *pVar;
        SType *pType;
        UINT  iElement;
        UINT  elementsToRead;
        CCheckedDword chkElementsTotal;
        UINT  elementsTotal;

        // Read variable info
        VHD( m_msStructured.Read((void**) &psBlock, sizeof(*psBlock)), "Invalid pEffectBuffer: cannot read object variable." );
        VBD( m_pEffect->m_VariableCount < (m_pHeader->Effect.cObjectVariables + m_pHeader->Effect.cNumericVariables + m_pHeader->cInterfaceVariables),
             "Internal loading error: variable count mismatch." );
        pVar = &m_pEffect->m_pVariables[m_pEffect->m_VariableCount];
        
        // Get type
        VH( LoadTypeAndAddToPool(&pType, psBlock->oType) );

        // Make sure the right polymorphic type is created
        VH( PlacementNewVariable(pVar, pType, FALSE) );

        pVar->pEffect = m_pEffect;
        pVar->pType = pType;
        pVar->pCB = NULL;
        pVar->ExplicitBindPoint = psBlock->ExplicitBindPoint;

        if( pType->IsStateBlockObject() )
        {
            pVar->MemberDataOffsetPlus4 = m_pEffect->m_MemberDataCount * sizeof(SMemberDataPointer) + 4;
            m_pEffect->m_MemberDataCount += max(pType->Elements,1);
        }

        // Get name
        VHD( GetStringAndAddToReflection(psBlock->oName, &pVar->pName), "Invalid pEffectBuffer: cannot read object variable name." );
        VHD( GetStringAndAddToReflection(psBlock->oSemantic, &pVar->pSemantic), "Invalid pEffectBuffer: cannot read object variable semantic." );

        m_pEffect->m_VariableCount++;
        elementsToRead = max(1, pType->Elements);
        chkElementsTotal = elementsToRead;

        if (pType->IsStateBlockObject())
        {
            // State blocks
            EBlockType blockType;
            UINT  *maxBlockCount;
            UINT  *currentBlockCount;

            switch (pType->ObjectType)
            {
            case EOT_Blend:
                pVar->Data.pBlock = &m_pEffect->m_pBlendBlocks[m_pEffect->m_BlendBlockCount];
                maxBlockCount = &m_pHeader->cBlendStateBlocks;
                currentBlockCount = &m_pEffect->m_BlendBlockCount;
                blockType = EBT_Blend;
                break;

            case EOT_DepthStencil:
                pVar->Data.pBlock = &m_pEffect->m_pDepthStencilBlocks[m_pEffect->m_DepthStencilBlockCount];
                maxBlockCount = &m_pHeader->cDepthStencilBlocks;
                currentBlockCount = &m_pEffect->m_DepthStencilBlockCount;
                blockType = EBT_DepthStencil;
                break;

            case EOT_Rasterizer:
                pVar->Data.pBlock = &m_pEffect->m_pRasterizerBlocks[m_pEffect->m_RasterizerBlockCount];
                maxBlockCount = &m_pHeader->cRasterizerStateBlocks;
                currentBlockCount = &m_pEffect->m_RasterizerBlockCount;
                blockType = EBT_Rasterizer;
                break;

            default:
                VB(pType->IsSampler());
                pVar->Data.pBlock = &m_pEffect->m_pSamplerBlocks[m_pEffect->m_SamplerBlockCount];
                maxBlockCount = &m_pHeader->cSamplers;
                currentBlockCount = &m_pEffect->m_SamplerBlockCount;
                blockType = EBT_Sampler;
            }

            chkElementsTotal += *currentBlockCount;
            VHD( chkElementsTotal.GetValue(&elementsTotal), "Overflow: vaiable elements." );
            VBD( elementsTotal <= *maxBlockCount, "Internal loading error: element count overflow." );
            
            *currentBlockCount += elementsToRead;

            for (iElement = 0; iElement < elementsToRead; ++ iElement)
            {
                SBaseBlock *pCurrentBlock;
                UINT  cAssignments;
                
                pCurrentBlock = (SBaseBlock *) GetBlockByIndex(pVar->pType->VarType, pVar->pType->ObjectType, pVar->Data.pGeneric, iElement);
                VBD( NULL != pCurrentBlock, "Internal loading error: find state block." );

                pCurrentBlock->BlockType = blockType;

                VHD( m_msStructured.Read(&cAssignments), "Invalid pEffectBuffer: cannot read state block assignments." );

                VH( LoadAssignments( cAssignments, &pCurrentBlock->pAssignments, (BYTE*)pCurrentBlock, NULL, &pCurrentBlock->AssignmentCount ) );
            }
        }
        else if (pType->IsShader())
        {
            // Shaders

            chkElementsTotal += m_pEffect->m_ShaderBlockCount;
            VHD( chkElementsTotal.GetValue(&elementsTotal), "Overflow: shader block count." );
            VBD( elementsTotal <= m_pHeader->cTotalShaders, "Invalid pEffectBuffer: shader count mismatch." );

            pVar->Data.pShader = &m_pEffect->m_pShaderBlocks[m_pEffect->m_ShaderBlockCount];

            for (iElement=0; iElement<elementsToRead; iElement++)
            {
                UINT  cbShaderBin;
                void *pShaderBin;
                SShaderBlock *pShaderBlock;

                union
                {
                    UINT *pOffset;
                    SBinaryGSSOInitializer *psInlineGSSO4;
                    SBinaryShaderData5 *psInlineShader5;
                };

                C_ASSERT( offsetof(SBinaryGSSOInitializer,oShader) == 0 );
                C_ASSERT( offsetof(SBinaryShaderData5,oShader) == 0 );


                pShaderBlock = &m_pEffect->m_pShaderBlocks[m_pEffect->m_ShaderBlockCount];
                m_pEffect->m_ShaderBlockCount++;

                // Get shader binary
                switch (pType->ObjectType)
                {
                case EOT_VertexShader:
                case EOT_GeometryShader:
                case EOT_PixelShader:
                    VHD( m_msStructured.Read((void**)&pOffset, sizeof(*pOffset)), "Invalid pEffectBuffer: cannot read shader block." );
                    break;

                case EOT_GeometryShaderSO:
                    VHD( m_msStructured.Read((void**)&psInlineGSSO4, sizeof(*psInlineGSSO4)), "Invalid pEffectBuffer: cannot read inline GS with SO." );
                    break;

                case EOT_VertexShader5:
                case EOT_GeometryShader5:
                case EOT_HullShader5:
                case EOT_DomainShader5:
                case EOT_PixelShader5:
                case EOT_ComputeShader5:
                    VHD( m_msStructured.Read((void**)&psInlineShader5, sizeof(*psInlineShader5)), "Invalid pEffectBuffer: cannot read inline shader." );
                    break;

                default:
                    VH( E_FAIL );
                }

                VHD( GetUnstructuredDataBlock(*pOffset, &cbShaderBin, &pShaderBin), "Invalid pEffectBuffer: cannot read shader byte code." );

                if (cbShaderBin > 0)
                {
                    VN( pShaderBlock->pReflectionData = PRIVATENEW SShaderBlock::SReflectionData );

                    pShaderBlock->pReflectionData->BytecodeLength = cbShaderBin;
                    pShaderBlock->pReflectionData->pBytecode = (BYTE*) pShaderBin;
                    pShaderBlock->pReflectionData->pStreamOutDecls[0] =
                    pShaderBlock->pReflectionData->pStreamOutDecls[1] =
                    pShaderBlock->pReflectionData->pStreamOutDecls[2] =
                    pShaderBlock->pReflectionData->pStreamOutDecls[3] = NULL;
                    pShaderBlock->pReflectionData->RasterizedStream = 0;
                    pShaderBlock->pReflectionData->IsNullGS = FALSE;
                    pShaderBlock->pReflectionData->pReflection = NULL;
                    pShaderBlock->pReflectionData->InterfaceParameterCount = 0;
                    pShaderBlock->pReflectionData->pInterfaceParameters = NULL;
                }

                switch (pType->ObjectType)
                {
                case EOT_PixelShader:
                    pShaderBlock->pVT = &g_vtPS;
                    break;

                case EOT_GeometryShaderSO:
                    // Get StreamOut decl
                    //VH( m_msStructured.Read(&dwOffset) );
                    if (cbShaderBin > 0)
                    {
                        VHD( GetStringAndAddToReflection(psInlineGSSO4->oSODecl, &pShaderBlock->pReflectionData->pStreamOutDecls[0]),
                             "Invalid pEffectBuffer: cannot read stream out decl." );
                    }
                    pShaderBlock->pVT = &g_vtGS;
                    break;

                case EOT_VertexShader5:
                case EOT_GeometryShader5:
                case EOT_HullShader5:
                case EOT_DomainShader5:
                case EOT_PixelShader5:
                case EOT_ComputeShader5:
                    // Get StreamOut decls
                    if (cbShaderBin > 0)
                    {
                        for( UINT iDecl=0; iDecl < psInlineShader5->cSODecls; ++iDecl )
                        {
                            VHD( GetStringAndAddToReflection(psInlineShader5->oSODecls[iDecl], &pShaderBlock->pReflectionData->pStreamOutDecls[iDecl]),
                                 "Invalid pEffectBuffer: cannot read stream out decls." );
                        }
                        pShaderBlock->pReflectionData->RasterizedStream = psInlineShader5->RasterizedStream;
                        pShaderBlock->pReflectionData->InterfaceParameterCount = psInlineShader5->cInterfaceBindings;
                        VH( GetInterfaceParametersAndAddToReflection( psInlineShader5->cInterfaceBindings, psInlineShader5->oInterfaceBindings, &pShaderBlock->pReflectionData->pInterfaceParameters ) );
                    }
                    switch (pType->ObjectType)
                    {
                    case EOT_VertexShader5:
                        pShaderBlock->pVT = &g_vtVS;
                        break;
                    case EOT_GeometryShader5:
                        pShaderBlock->pVT = &g_vtGS;
                        break;
                    case EOT_HullShader5:
                        pShaderBlock->pVT = &g_vtHS;
                        break;
                    case EOT_DomainShader5:
                        pShaderBlock->pVT = &g_vtDS;
                        break;
                    case EOT_PixelShader5:
                        pShaderBlock->pVT = &g_vtPS;
                        break;
                    case EOT_ComputeShader5:
                        pShaderBlock->pVT = &g_vtCS;
                        break;
                    default:
                        VH( E_FAIL );
                    }
                    break;

                case EOT_GeometryShader:
                    pShaderBlock->pVT = &g_vtGS;
                    break;

                case EOT_VertexShader:
                    pShaderBlock->pVT = &g_vtVS;
                    break;

                default:
                    VHD( E_FAIL, "Invalid pEffectBuffer: invalid shader type." );
                }
            }
        }
        else if (pType->IsObjectType(EOT_String))
        {
            // Strings
            
            chkElementsTotal += m_pEffect->m_StringCount;
            VHD( chkElementsTotal.GetValue(&elementsTotal), "Overflow: string object count." );
            VBD( elementsTotal <= m_pHeader->cStrings, "Invalid pEffectBuffer: string count mismatch." );

            pVar->Data.pString = &m_pEffect->m_pStrings[m_pEffect->m_StringCount];

            for (iElement=0; iElement<elementsToRead; iElement++)
            {
                UINT  dwOffset;
                SString *pString;

                pString = &m_pEffect->m_pStrings[m_pEffect->m_StringCount];
                m_pEffect->m_StringCount++;

                // Get string
                VHD( m_msStructured.Read(&dwOffset), "Invalid pEffectBuffer: cannot read string offset." );
                VHD( GetStringAndAddToReflection(dwOffset, &pString->pString), "Invalid pEffectBuffer: cannot read string." );
            }
        }
        else if (pType->IsShaderResource())
        {   
            // Textures/buffers
            
            chkElementsTotal += m_pEffect->m_ShaderResourceCount;
            VHD( chkElementsTotal.GetValue(&elementsTotal), "Overflow: SRV object count." );
            VBD( elementsTotal <= m_pHeader->cShaderResources, "Invalid pEffectBuffer: SRV count mismatch." );

            pVar->Data.pShaderResource = &m_pEffect->m_pShaderResources[m_pEffect->m_ShaderResourceCount];
            m_pEffect->m_ShaderResourceCount += elementsToRead;
        }
        else if (pType->IsUnorderedAccessView())
        {   
            // UnorderedAccessViews

            chkElementsTotal += m_pEffect->m_UnorderedAccessViewCount;
            VHD( chkElementsTotal.GetValue(&elementsTotal), "Overflow: UAV object count." );
            VBD( elementsTotal <= m_pHeader->cUnorderedAccessViews, "Invalid pEffectBuffer: UAV count mismatch." );

            pVar->Data.pUnorderedAccessView = &m_pEffect->m_pUnorderedAccessViews[m_pEffect->m_UnorderedAccessViewCount];
            m_pEffect->m_UnorderedAccessViewCount += elementsToRead;
        }
        else if (pType->IsRenderTargetView())
        {            
            // RenderTargets

            chkElementsTotal += m_pEffect->m_RenderTargetViewCount;
            VHD( chkElementsTotal.GetValue(&elementsTotal), "Overflow: RTV object count." );
            VBD( elementsTotal <= m_pHeader->cRenderTargetViews, "Invalid pEffectBuffer: RTV count mismatch." );

            pVar->Data.pRenderTargetView = &m_pEffect->m_pRenderTargetViews[m_pEffect->m_RenderTargetViewCount];
            m_pEffect->m_RenderTargetViewCount += elementsToRead;
        }
        else if (pType->IsDepthStencilView())
        {            
            // DepthStencilViews

            chkElementsTotal += m_pEffect->m_DepthStencilViewCount;
            VHD( chkElementsTotal.GetValue(&elementsTotal), "Overflow: DSV object count." );
            VBD( elementsTotal <= m_pHeader->cDepthStencilViews, "Invalid pEffectBuffer: DSV count mismatch." );

            pVar->Data.pDepthStencilView = &m_pEffect->m_pDepthStencilViews[m_pEffect->m_DepthStencilViewCount];
            m_pEffect->m_DepthStencilViewCount += elementsToRead;
        }
        else
        {
            VHD( E_FAIL, "Invalid pEffectBuffer: DSV count mismatch." );
        }

        // Read annotations
        VH( LoadAnnotations(&pVar->AnnotationCount, &pVar->pAnnotations) );
    }
lExit:
    return hr;
}


// Read info from the compiled blob and initialize an interface variable
HRESULT CEffectLoader::LoadInterfaceVariables()
{
    HRESULT hr = S_OK;
    UINT  iBlock;
    UINT  cBlocks;

    cBlocks = m_pHeader->cInterfaceVariables;

    for (iBlock=0; iBlock<cBlocks; iBlock++)
    {
        SBinaryInterfaceVariable *psBlock;
        SGlobalVariable *pVar;
        SType *pType;
        UINT  elementsToRead;
        CCheckedDword chkElementsTotal;
        UINT  elementsTotal;
        void *pDefaultValue;

        // Read variable info
        VHD( m_msStructured.Read((void**) &psBlock, sizeof(*psBlock)), "Invalid pEffectBuffer: cannot read interface block." );
        VBD( m_pEffect->m_VariableCount < (m_pHeader->Effect.cObjectVariables + m_pHeader->Effect.cNumericVariables + m_pHeader->cInterfaceVariables),
             "Internal loading error: variable count mismatch." );
        pVar = &m_pEffect->m_pVariables[m_pEffect->m_VariableCount];

        // Get type
        VH( LoadTypeAndAddToPool(&pType, psBlock->oType) );

        // Make sure the right polymorphic type is created
        VH( PlacementNewVariable(pVar, pType, FALSE) );

        pVar->pEffect = m_pEffect;
        pVar->pType = pType;
        pVar->pCB = NULL;
        pVar->ExplicitBindPoint = (UINT)-1;
        pVar->pSemantic = NULL;

        // Get name
        VHD( GetStringAndAddToReflection(psBlock->oName, &pVar->pName), "Invalid pEffectBuffer: cannot read interface name." );

        m_pEffect->m_VariableCount++;
        elementsToRead = max(1, pType->Elements);
        chkElementsTotal = elementsToRead;

        VBD( pType->IsInterface(), "Internal loading error: invlaid type for interface." );

        chkElementsTotal += m_pEffect->m_InterfaceCount;
        VHD( chkElementsTotal.GetValue(&elementsTotal), "Overflow: interface count." );
        VBD( elementsTotal <= m_pHeader->cInterfaceVariableElements, "Invalid pEffectBuffer: interface count mismatch." );

        pVar->Data.pInterface = &m_pEffect->m_pInterfaces[m_pEffect->m_InterfaceCount];
        m_pEffect->m_InterfaceCount += elementsToRead;

        // Get default value
        if (0 != psBlock->oDefaultValue)
        {
            VHD( m_msUnstructured.ReadAtOffset(psBlock->oDefaultValue, elementsToRead * sizeof(SBinaryInterfaceInitializer), &pDefaultValue),
                 "Invalid pEffectBuffer: cannot read interface initializer offset." );
            for( UINT i=0; i < elementsToRead; i++ )
            {
                SBinaryInterfaceInitializer* pInterfaceInit = &((SBinaryInterfaceInitializer*)pDefaultValue)[i];
                LPCSTR pClassInstanceName;
                VHD( m_msUnstructured.ReadAtOffset(pInterfaceInit->oInstanceName, &pClassInstanceName), "Invalid pEffectBuffer: cannot read interface initializer." );

                SGlobalVariable *pCIVariable = m_pEffect->FindVariableByName(pClassInstanceName);
                VBD( pCIVariable != NULL, "Loading error: cannot find class instance for interface initializer." );
                VBD( pCIVariable->pType->IsClassInstance(), "Loading error: variable type mismatch for interface initializer." );
                if( pInterfaceInit->ArrayIndex == (UINT)-1 )
                {
                    VBD( pCIVariable->pType->Elements == 0, "Loading error: array mismatch for interface initializer." );
                    pVar->Data.pInterface[i].pClassInstance = (SClassInstanceGlobalVariable*)pCIVariable;
                }
                else
                {
                    VBD( pCIVariable->pType->Elements > 0, "Loading error: array mismatch for interface initializer." );
                    VBD( pInterfaceInit->ArrayIndex < pCIVariable->pType->Elements, "Loading error: array index out of range." );

                    SMember* pMember = (SMember*)pCIVariable->GetElement( pInterfaceInit->ArrayIndex );
                    VBD( pMember->IsValid(), "Loading error: cannot find member by name." );
                    VBD( pMember->pType->IsClassInstance(), "Loading error: member type mismatch for interface initializer." );
                    pVar->Data.pInterface[i].pClassInstance = (SClassInstanceGlobalVariable*)pMember;
                }
            }
        }


        // Read annotations
        VH( LoadAnnotations(&pVar->AnnotationCount, &pVar->pAnnotations) );
    }
lExit:
    return hr;
}


// Read info from the compiled blob and initialize a group (and contained techniques and passes)
HRESULT CEffectLoader::LoadGroups()
{
    HRESULT hr = S_OK;
    UINT iGroup;
    UINT TechniquesInEffect = 0;

    for( iGroup=0; iGroup<m_pHeader->cGroups; iGroup++ )
    {
        SGroup *pGroup = &m_pEffect->m_pGroups[iGroup];
        SBinaryGroup *psGroup;

        // Read group info
        VHD( m_msStructured.Read((void**) &psGroup, sizeof(*psGroup)), "Invalid pEffectBuffer: cannot read group." );
        pGroup->TechniqueCount = psGroup->cTechniques;
        VN( pGroup->pTechniques = PRIVATENEW STechnique[pGroup->TechniqueCount] );
        VHD( GetStringAndAddToReflection(psGroup->oName, &pGroup->pName), "Invalid pEffectBuffer: cannot read group name." );

        if( pGroup->pName == NULL )
        {
            VBD( m_pEffect->m_pNullGroup == NULL, "Internal loading error: multiple NULL groups." );
            m_pEffect->m_pNullGroup = pGroup;
        }

        // Read annotations
        VH( LoadAnnotations(&pGroup->AnnotationCount, &pGroup->pAnnotations) );

        UINT iTechnique;
        for( iTechnique=0; iTechnique < psGroup->cTechniques; iTechnique++ )
        {
            VH( LoadTechnique( &pGroup->pTechniques[iTechnique] ) );
        }
        TechniquesInEffect += psGroup->cTechniques;
    }

    VBD( TechniquesInEffect == m_pHeader->cTechniques, "Loading error: technique count mismatch." );
    m_pEffect->m_TechniqueCount = m_pHeader->cTechniques;
    m_pEffect->m_GroupCount = m_pHeader->cGroups;

lExit:
    return hr;
}


// Read info from the compiled blob and initialize a technique (and contained passes)
HRESULT CEffectLoader::LoadTechnique( STechnique* pTech )
{
    HRESULT hr = S_OK;
    UINT  iPass;

    SBinaryTechnique *psTech;

    // Read technique info
    VHD( m_msStructured.Read((void**) &psTech, sizeof(*psTech)), "Invalid pEffectBuffer: cannot read technique." );
    pTech->PassCount = psTech->cPasses;
    VN( pTech->pPasses = PRIVATENEW SPassBlock[pTech->PassCount] );
    VHD( GetStringAndAddToReflection(psTech->oName, &pTech->pName), "Invalid pEffectBuffer: cannot read technique name." );

    // Read annotations
    VH( LoadAnnotations(&pTech->AnnotationCount, &pTech->pAnnotations) );

    for (iPass=0; iPass<psTech->cPasses; iPass++)
    {
        SBinaryPass *psPass;
        SPassBlock *pPass = &pTech->pPasses[iPass];

        // Read pass info
        VHD( m_msStructured.Read((void**) &psPass, sizeof(SBinaryPass)), "Invalid pEffectBuffer: cannot read pass." );
        VHD( GetStringAndAddToReflection(psPass->oName, &pPass->pName), "Invalid pEffectBuffer: cannot read pass name." );
        
        // Read annotations
        VH( LoadAnnotations(&pPass->AnnotationCount, &pPass->pAnnotations) );

        VH( LoadAssignments( psPass->cAssignments, &pPass->pAssignments, (BYTE*)pPass, &pPass->BackingStore.RenderTargetViewCount, &pPass->AssignmentCount ) );
        VBD( pPass->BackingStore.RenderTargetViewCount <= D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT, "Invalid pEffectBuffer: too many RTVs in pass." );

        // Initialize other pass information
        pPass->pEffect = m_pEffect;
        pPass->BlockType = EBT_Pass;
    }

lExit:
    return hr;
}


// Read info from the compiled blob and initialize a set of annotations
HRESULT CEffectLoader::LoadAnnotations(UINT  *pcAnnotations, SAnnotation **ppAnnotations)
{
    HRESULT hr = S_OK;
    UINT  cAnnotations, i, oData;
    SAnnotation *pAnnotations = NULL;

    VHD( m_msStructured.Read(&cAnnotations), "Invalid pEffectBuffer: cannot read anootation count." );

    if (cAnnotations)
    {
        UINT  annotationsSize;
        CCheckedDword chkAnnotationsSize;

        chkAnnotationsSize = cAnnotations;
        chkAnnotationsSize *= sizeof(SAnnotation);
        VHD( chkAnnotationsSize.GetValue(&annotationsSize), "Overflow in annotations."  );
        
        // we allocate raw bytes for annotations because they are polymorphic types that need to be placement new'ed
        VN( pAnnotations = (SAnnotation *) PRIVATENEW BYTE[annotationsSize] );
        
        for (i=0; i<cAnnotations; i++)
        {
            SBinaryAnnotation *psAnnotation;
            SAnnotation *pAn = &pAnnotations[i];
            SType *pType;

            VHD( m_msStructured.Read((void**) &psAnnotation, sizeof(SBinaryAnnotation)), "Invalid pEffectBuffer: cannot read annotation."  );

            VH( LoadTypeAndAddToPool(&pType, psAnnotation->oType) );

            // Make sure the right polymorphic type is created
            VH( PlacementNewVariable(pAn, pType, TRUE) );

            pAn->pEffect = m_pEffect;
            pAn->pType = pType;

            VHD( GetStringAndAddToReflection(psAnnotation->oName, &pAn->pName), "Invalid pEffectBuffer: cannot read annotation name."  );

            if (pType->IsObjectType(EOT_String))
            {
                UINT  cElements = max(1, pType->Elements);
                UINT  j;
                VN( pAn->Data.pString = PRIVATENEW SString[cElements] );
                for (j = 0; j < cElements; ++ j)
                {
                    // Read initializer offset
                    VHD( m_msStructured.Read(&oData), "Invalid pEffectBuffer: cannot read string."  );
                    VHD( GetStringAndAddToReflection(oData, &pAn->Data.pString[j].pString), "Invalid pEffectBuffer: cannot read string initializer."  );
                }
            }
            else if (pType->BelongsInConstantBuffer())
            {
                void *pDefaultValue;
                UINT  bytesUnpacked;
                
                // Read initializer offset
                VHD( m_msStructured.Read(&oData), "Invalid pEffectBuffer: cannot read annotation."  );

                VBD( oData != 0, "Invalid pEffectBuffer: invalid anotation offset." );

                VN( pAn->Data.pGeneric = PRIVATENEW BYTE[pType->TotalSize] );
                ZeroMemory(pAn->Data.pGeneric, pType->TotalSize);
                VHD( m_msUnstructured.ReadAtOffset(oData, pType->PackedSize, &pDefaultValue), "Invalid pEffectBuffer: cannot read variable default value."  );
                VH( UnpackData((BYTE*) pAn->Data.pGeneric, (BYTE*) pDefaultValue, pType->PackedSize, pType, &bytesUnpacked) );
                VBD( bytesUnpacked == pType->PackedSize, "Invalid pEffectBuffer: packed sizes to not match." );
            }
            else
            {
                VHD( E_FAIL, "Invalid pEffectBuffer: invalid annotation type." );
            }
        }
    }

    *pcAnnotations = cAnnotations;
    *ppAnnotations = pAnnotations;
lExit:

    return hr;
}

//////////////////////////////////////////////////////////////////////////
// Build shader block dependencies from shader metadata
//////////////////////////////////////////////////////////////////////////

//
// Grabs shader resource dependency information from the bytecode of the shader
// (cbuffer, tbuffer, texture, buffer, sampler, and UAV dependencies),
// and sets up the given SShaderBlock to point to the dependencies within the effect
//
HRESULT CEffectLoader::GrabShaderData(SShaderBlock *pShaderBlock)
{
    HRESULT hr = S_OK;
    UINT  i, j;
    CEffectVector<SRange> vRanges[ER_Count], *pvRange;
    SRange *pRange = NULL;
    CEffectVector<SConstantBuffer*> vTBuffers;
    
    //////////////////////////////////////////////////////////////////////////
    // Step 1: iterate through the resource binding structures and build
    // an "optimized" list of all of the dependencies

    D3D11_SHADER_DESC ShaderDesc;
    pShaderBlock->pReflectionData->pReflection->GetDesc( &ShaderDesc );

    // Since we have the shader desc, let's find out if this is a NULL GS
    if( D3D11_SHVER_GET_TYPE( ShaderDesc.Version ) == D3D11_SHVER_VERTEX_SHADER && pShaderBlock->GetShaderType() == EOT_GeometryShader )
    {
        pShaderBlock->pReflectionData->IsNullGS = TRUE;
    }

    pShaderBlock->CBDepCount = pShaderBlock->ResourceDepCount = pShaderBlock->TBufferDepCount = pShaderBlock->SampDepCount = 0;
    pShaderBlock->UAVDepCount = pShaderBlock->InterfaceDepCount = 0;

    for(i = 0; i < ShaderDesc.BoundResources; i++)
    {
        LPCSTR pName;
        UINT bindPoint, size;
        ERanges eRange;
        SShaderResource *pShaderResource = NULL;
        SUnorderedAccessView *pUnorderedAccessView = NULL;
        SSamplerBlock *pSampler = NULL;
        SConstantBuffer *pCB = NULL;
        SVariable *pVariable = NULL;
        BOOL isFX9TextureLoad = FALSE;
        D3D11_SHADER_INPUT_BIND_DESC ResourceDesc;

        pShaderBlock->pReflectionData->pReflection->GetResourceBindingDesc( i, &ResourceDesc );

        // HUGE ASSUMPTION: the bindpoints we read in the shader metadata are sorted;
        // i.e. bindpoints are steadily increasing
        // If this assumption is not met, then we will hit an assert below

        pName = ResourceDesc.Name;
        bindPoint = ResourceDesc.BindPoint;
        size = ResourceDesc.BindCount;

        switch( ResourceDesc.Type )
        {
        case D3D10_SIT_CBUFFER:
            eRange = ER_CBuffer;
            
            pCB = m_pEffect->FindCB(pName);
            VBD( NULL != pCB, "Loading error: cannot find cbuffer." );
            VBD( size == 1, "Loading error: cbuffer arrays are not supported." );
            break;

        case D3D10_SIT_TBUFFER:
            eRange = ER_Texture;
            
            pCB = m_pEffect->FindCB(pName);
            VBD( NULL != pCB, "Loading error: cannot find tbuffer." );
            VBD( FALSE != pCB->IsTBuffer, "Loading error: cbuffer found where tbuffer is expected." );
            VBD( size == 1, "Loading error: tbuffer arrays are not supported." );
            pShaderResource = &pCB->TBuffer;
            break;

        case D3D10_SIT_TEXTURE: 
        case D3D11_SIT_STRUCTURED:
        case D3D11_SIT_BYTEADDRESS:
            eRange = ER_Texture;

            pVariable = m_pEffect->FindVariableByNameWithParsing(pName);
            VBD( pVariable != NULL, "Loading error: cannot find SRV variable." );
            UINT elements;
            elements = max(1, pVariable->pType->Elements);
            VBD( size <= elements, "Loading error: SRV array size mismatch." );

            if (pVariable->pType->IsShaderResource())
            {
                // this is just a straight texture assignment
                pShaderResource = pVariable->Data.pShaderResource;
            }
            else
            {
                // This is a FX9/HLSL9-style texture load instruction that specifies only a sampler
                VBD( pVariable->pType->IsSampler(), "Loading error: shader dependency is neither an SRV nor sampler.");
                isFX9TextureLoad = TRUE;
                pSampler = pVariable->Data.pSampler;
                // validate that all samplers actually used (i.e. based on size, not elements) in this variable have a valid TEXTURE assignment
                for (j = 0; j < size; ++ j)
                {
                    if (NULL == pSampler[j].BackingStore.pTexture)
                    {
                        // print spew appropriately for samplers vs sampler arrays
                        if (0 == pVariable->pType->Elements)
                        {
                            DPF(0, "%s: Sampler %s does not have a texture bound to it, even though the sampler is used in a DX9-style texture load instruction", g_szEffectLoadArea, pName);
                        }
                        else
                        {
                            DPF(0, "%s: Sampler %s[%d] does not have a texture bound to it, even though the sampler array is used in a DX9-style texture load instruction", g_szEffectLoadArea, pName, j);
                        }
                        
                        VH( E_FAIL );
                    }
                }
            }
            break;

        case D3D11_SIT_UAV_RWTYPED:
        case D3D11_SIT_UAV_RWSTRUCTURED:
        case D3D11_SIT_UAV_RWBYTEADDRESS:
        case D3D11_SIT_UAV_APPEND_STRUCTURED:
        case D3D11_SIT_UAV_CONSUME_STRUCTURED:
        case D3D11_SIT_UAV_RWSTRUCTURED_WITH_COUNTER:
            eRange = ER_UnorderedAccessView;

            pVariable = m_pEffect->FindVariableByNameWithParsing(pName);
            VBD( pVariable != NULL, "Loading error: cannot find UAV variable." );
            VBD( size <= max(1, pVariable->pType->Elements), "Loading error: UAV array index out of range." );
            VBD( pVariable->pType->IsUnorderedAccessView(), "Loading error: UAV variable expected." );
            pUnorderedAccessView = pVariable->Data.pUnorderedAccessView;
            break;

        case D3D10_SIT_SAMPLER:
            eRange = ER_Sampler;

            pVariable = m_pEffect->FindVariableByNameWithParsing(pName);
            VBD( pVariable != NULL, "Loading error: cannot find sampler variable." );
            VBD( size <= max(1, pVariable->pType->Elements), "Loading error: sampler array index out of range." );
            VBD( pVariable->pType->IsSampler(), "Loading error: sampler variable expected." );
            pSampler = pVariable->Data.pSampler;
            break;

        default:
            VHD( E_FAIL, "Internal loading error: unexpected shader dependency type." );
        };

        //
        // Here's where the "optimized" part comes in; whenever there's
        // a resource dependency, see if it's located contiguous to
        // an existing resource dependency and merge them together
        // if possible
        //
        UINT  rangeCount;
        pvRange = &vRanges[eRange];
        rangeCount = pvRange->GetSize();

        if ( rangeCount > 0 )
        {
            // Can we continue an existing range?
            pRange = &( (*pvRange)[rangeCount - 1] );

            // Make sure that bind points are strictly increasing,
            // otherwise this algorithm breaks and we'd get worse runtime performance
            D3DXASSERT(pRange->last <= bindPoint);

            if ( pRange->last != bindPoint )
            {
                if( eRange != ER_UnorderedAccessView )
                {
                    // No we can't. Begin a new range by setting rangeCount to 0 and triggering the next IF
                    rangeCount = 0;
                }
                else
                {
                    // UAVs will always be located in one range, as they are more expensive to set
                    while(pRange->last < bindPoint)
                    {
                        VHD( pRange->vResources.Add(&g_NullUnorderedAccessView), "Internal loading error: cannot add UAV to range." );
                        pRange->last++;
                    }
                }
            }
        }

        if ( rangeCount == 0 )
        {
            VN( pRange = pvRange->Add() );
            pRange->start = bindPoint;
        }

        pRange->last = bindPoint + size;

        switch( ResourceDesc.Type )
        {
        case D3D10_SIT_CBUFFER:
            VHD( pRange->vResources.Add(pCB), "Internal loading error: cannot add cbuffer to range." );
            break;
        case D3D10_SIT_TBUFFER:
            VHD( pRange->vResources.Add(pShaderResource), "Internal loading error: cannot add tbuffer to range." );
            VHD( vTBuffers.Add( (SConstantBuffer*)pCB ), "Internal loading error: cannot add tbuffer to vector." );
            break;
        case D3D10_SIT_TEXTURE:
        case D3D11_SIT_STRUCTURED:
        case D3D11_SIT_BYTEADDRESS:
            if (isFX9TextureLoad)
            {
                // grab all of the textures from each sampler
                for (j = 0; j < size; ++ j)
                {
                    VHD( pRange->vResources.Add(pSampler[j].BackingStore.pTexture), "Internal loading error: cannot add SRV to range." );
                }
            }
            else
            {
                // add the whole array
                for (j = 0; j < size; ++ j)
                {
                    VHD( pRange->vResources.Add(pShaderResource + j), "Internal loading error: cannot add SRV to range." );
                }
            }
            break;
        case D3D11_SIT_UAV_RWTYPED:
        case D3D11_SIT_UAV_RWSTRUCTURED:
        case D3D11_SIT_UAV_RWBYTEADDRESS:
        case D3D11_SIT_UAV_APPEND_STRUCTURED:
        case D3D11_SIT_UAV_CONSUME_STRUCTURED:
        case D3D11_SIT_UAV_RWSTRUCTURED_WITH_COUNTER:
            // add the whole array
            for (j = 0; j < size; ++ j)
            {
                VHD( pRange->vResources.Add(pUnorderedAccessView + j), "Internal loading error: cannot add UAV to range." );
            }
            break;
        case D3D10_SIT_SAMPLER:
            // add the whole array
            for (j = 0; j < size; ++ j)
            {
                VHD( pRange->vResources.Add(pSampler + j), "Internal loading error: cannot add sampler to range." );
            }
            break;
        default:
            VHD( E_FAIL, "Internal loading error: unexpected shader dependency type." );
        }
    }


    //////////////////////////////////////////////////////////////////////////
    // Step 2: iterate through the interfaces and build
    // an "optimized" list of all of the dependencies

    UINT NumInterfaces = pShaderBlock->pReflectionData->pReflection->GetNumInterfaceSlots();
    UINT CurInterfaceParameter = 0;
    if( NumInterfaces > 0 )
    {
        D3DXASSERT( ShaderDesc.ConstantBuffers > 0 );

        for( i=0; i < ShaderDesc.ConstantBuffers; i++ )
        {
            ID3D11ShaderReflectionConstantBuffer* pCB = pShaderBlock->pReflectionData->pReflection->GetConstantBufferByIndex(i);
            VN( pCB );
            D3D11_SHADER_BUFFER_DESC CBDesc;
            VHD( pCB->GetDesc( &CBDesc ), "Internal loading error: cannot get CB desc." );
            if( CBDesc.Type != D3D11_CT_INTERFACE_POINTERS )
            {
                continue;
            }

            for( UINT iVar=0; iVar < CBDesc.Variables; iVar++ )
            {
                ID3D11ShaderReflectionVariable* pInterfaceVar = pCB->GetVariableByIndex( iVar );
                VN( pInterfaceVar );
                D3D11_SHADER_VARIABLE_DESC InterfaceDesc;
                pInterfaceVar->GetDesc( &InterfaceDesc );

                LPCSTR pName;
                UINT bindPoint, size;
                SGlobalVariable *pVariable = NULL;
                SInterface *pInterface = NULL;
                UINT VariableElements;

                pName = InterfaceDesc.Name;
                bindPoint = InterfaceDesc.StartOffset;
                size = InterfaceDesc.Size;

                if( bindPoint == (UINT)-1 )
                {
                    continue;
                }

                D3DXASSERT( InterfaceDesc.uFlags & D3D11_SVF_INTERFACE_POINTER );
                if( InterfaceDesc.uFlags & D3D11_SVF_INTERFACE_PARAMETER )
                {
                    // This interface pointer is a parameter to the shader
                    if( pShaderBlock->pReflectionData->InterfaceParameterCount == 0 )
                    {
                        // There may be no interface parameters in this shader if it was compiled but had no interfaced bound to it.
                        // The shader cannot be set (correctly) in any pass.
                        continue;
                    }
                    else
                    {
                        VBD( CurInterfaceParameter < pShaderBlock->pReflectionData->InterfaceParameterCount,
                             "Internal loading error: interface count mismatch.");
                        SShaderBlock::SInterfaceParameter* pInterfaceInfo;
                        pInterfaceInfo = &pShaderBlock->pReflectionData->pInterfaceParameters[CurInterfaceParameter];
                        ++CurInterfaceParameter;
                        SGlobalVariable *pParent = m_pEffect->FindVariableByName(pInterfaceInfo->pName);
                        VBD( pParent != NULL, "Loading error: cannot find parent type." );
                        if( pInterfaceInfo->Index == (UINT)-1 )
                        {
                            pVariable = pParent;
                            VariableElements = pVariable->pType->Elements;
                        }
                        else
                        {
                            // We want a specific index of the variable (ex. "MyVar[2]")
                            VBD( size == 1, "Loading error: interface array type mismatch." );
                            pVariable = (SGlobalVariable*)pParent->GetElement( pInterfaceInfo->Index );
                            VBD( pVariable->IsValid(), "Loading error: interface array index out of range." );
                            VariableElements = 0;
                        }
                    }
                }
                else
                {
                    // This interface pointer is a global interface used in the shader
                    pVariable = m_pEffect->FindVariableByName(pName);
                    VBD( pVariable != NULL, "Loading error: cannot find interface variable." );
                    VariableElements = pVariable->pType->Elements;
                }
                VBD( size <= max(1, VariableElements), "Loading error: interface array size mismatch." );
                if( pVariable->pType->IsInterface() )
                {
                    pInterface = pVariable->Data.pInterface;
                }
                else if( pVariable->pType->IsClassInstance() )
                {
                    // For class instances, we create background interfaces which point to the class instance.  This is done so
                    // the shader can always expect SInterface dependencies, rather than a mix of SInterfaces and class instances
                    VN( pInterface = PRIVATENEW SInterface[size] );
                    if( VariableElements == 0 )
                    {
                        D3DXASSERT( size == 1 );
                        pInterface[0].pClassInstance = (SClassInstanceGlobalVariable*)pVariable;
                        m_BackgroundInterfaces.Add( &pInterface[0] );
                    }
                    else
                    {
                        // Fill each element of the SInstance array individually
                        VBD( size == VariableElements, "Loading error: class instance array size mismatch." );
                        for( UINT iElement=0; iElement < size; iElement++ )
                        {
                            SGlobalVariable *pElement = (SGlobalVariable*)pVariable->GetElement( iElement );
                            VBD( pElement->IsValid(), "Internal loading error: class instance array index out of range." );
                            pInterface[iElement].pClassInstance = (SClassInstanceGlobalVariable*)pElement;
                            m_BackgroundInterfaces.Add( &pInterface[iElement] );
                        }
                    }
                }
                else
                {
                    VHD( E_FAIL, "Loading error: invalid interface initializer variable type.");
                }

                //
                // Here's where the "optimized" part comes in; whenever there's
                // a resource dependency, see if it's located contiguous to
                // an existing resource dependency and merge them together
                // if possible
                //
                UINT  rangeCount;
                pvRange = &vRanges[ER_Interfaces];
                rangeCount = pvRange->GetSize();

                VBD( rangeCount <= 1, "Internal loading error: invalid range count." );

                if ( rangeCount == 0 )
                {
                    VN( pRange = pvRange->Add() );
                    pRange->start = pRange->last = 0;
                }
                else
                {
                    pRange = &( (*pvRange)[0] );
                }

                if( bindPoint < pRange->last )
                {
                    // add interfaces into the range that already exists
                    VBD( bindPoint + size < pRange->last, "Internal loading error: range overlap." );
                    for( j = 0; j < size; ++ j )
                    {
                        pRange->vResources[j + bindPoint] = pInterface + j;
                    }
                }
                else
                {
                    // add interfaces to the end of the range

                    // add missing interface slots, if necessary
                    while(pRange->last < bindPoint)
                    {
                        VHD( pRange->vResources.Add(&g_NullInterface), "Internal loading error: cannot add NULL interface to range." );
                        pRange->last++;
                    }

                    D3DXASSERT( bindPoint == pRange->last );
                    for( j=0; j < size; ++ j )
                    {
                        VHD( pRange->vResources.Add(pInterface + j), "Internal loading error: cannot at interface to range." );
                    }
                    pRange->last = bindPoint + size;
                }
            }

            // There is only one interface cbuffer
            break;
        }
    }

    //////////////////////////////////////////////////////////////////////////
    // Step 3: allocate room in pShaderBlock for all of the dependency 
    // pointers and then hook them up

    pShaderBlock->SampDepCount = vRanges[ ER_Sampler ].GetSize();
    pShaderBlock->CBDepCount = vRanges[ ER_CBuffer ].GetSize();
    pShaderBlock->InterfaceDepCount = vRanges[ ER_Interfaces ].GetSize();
    pShaderBlock->ResourceDepCount = vRanges[ ER_Texture ].GetSize();
    pShaderBlock->UAVDepCount = vRanges[ ER_UnorderedAccessView ].GetSize();
    pShaderBlock->TBufferDepCount = vTBuffers.GetSize();

    VN( pShaderBlock->pSampDeps = PRIVATENEW SShaderSamplerDependency[pShaderBlock->SampDepCount] );
    VN( pShaderBlock->pCBDeps = PRIVATENEW SShaderCBDependency[pShaderBlock->CBDepCount] );
    VN( pShaderBlock->pInterfaceDeps = PRIVATENEW SInterfaceDependency[pShaderBlock->InterfaceDepCount] );
    VN( pShaderBlock->pResourceDeps = PRIVATENEW SShaderResourceDependency[pShaderBlock->ResourceDepCount] );
    VN( pShaderBlock->pUAVDeps = PRIVATENEW SUnorderedAccessViewDependency[pShaderBlock->UAVDepCount] );
    VN( pShaderBlock->ppTbufDeps = PRIVATENEW SConstantBuffer*[pShaderBlock->TBufferDepCount] );

    for (i=0; i<pShaderBlock->CBDepCount; ++i)
    {
        SShaderCBDependency *pDep = &pShaderBlock->pCBDeps[i];

        pRange = &vRanges[ER_CBuffer][i];

        pDep->StartIndex = pRange->start;
        pDep->Count = pRange->last - pDep->StartIndex;
        pDep->ppFXPointers = PRIVATENEW SConstantBuffer*[ pDep->Count ];
        pDep->ppD3DObjects = PRIVATENEW ID3D11Buffer*[ pDep->Count ];

        D3DXASSERT(pDep->Count == pRange->vResources.GetSize());
        for (j=0; j<pDep->Count; ++j)
        {
            pDep->ppFXPointers[j] = (SConstantBuffer *)pRange->vResources[j];
            pDep->ppD3DObjects[j] = NULL;
        }
    }

    for (i=0; i<pShaderBlock->SampDepCount; ++i)
    {
        SShaderSamplerDependency *pDep = &pShaderBlock->pSampDeps[i];

        pRange = &vRanges[ER_Sampler][i];

        pDep->StartIndex = pRange->start;
        pDep->Count = pRange->last - pDep->StartIndex;
        pDep->ppFXPointers = PRIVATENEW SSamplerBlock*[ pDep->Count ];
        pDep->ppD3DObjects = PRIVATENEW ID3D11SamplerState*[ pDep->Count ];

        D3DXASSERT(pDep->Count == pRange->vResources.GetSize());
        for (j=0; j<pDep->Count; ++j)
        {
            pDep->ppFXPointers[j] = (SSamplerBlock *) pRange->vResources[j];
            pDep->ppD3DObjects[j] = NULL;
        }
    }

    for (i=0; i<pShaderBlock->InterfaceDepCount; ++i)
    {
        SInterfaceDependency *pDep = &pShaderBlock->pInterfaceDeps[i];

        pRange = &vRanges[ER_Interfaces][i];

        pDep->StartIndex = pRange->start;
        pDep->Count = pRange->last - pDep->StartIndex;
        pDep->ppFXPointers = PRIVATENEW SInterface*[ pDep->Count ];
        pDep->ppD3DObjects = PRIVATENEW ID3D11ClassInstance*[ pDep->Count ];

        D3DXASSERT(pDep->Count == pRange->vResources.GetSize());
        for (j=0; j<pDep->Count; ++j)
        {
            pDep->ppFXPointers[j] = (SInterface *) pRange->vResources[j];
            pDep->ppD3DObjects[j] = NULL;
        }
    }

    for (i=0; i<pShaderBlock->ResourceDepCount; ++i)
    {
        SShaderResourceDependency *pDep = &pShaderBlock->pResourceDeps[i];

        pRange = &vRanges[ER_Texture][i];

        pDep->StartIndex = pRange->start;
        pDep->Count = pRange->last - pDep->StartIndex;
        pDep->ppFXPointers = PRIVATENEW SShaderResource*[ pDep->Count ];
        pDep->ppD3DObjects = PRIVATENEW ID3D11ShaderResourceView*[ pDep->Count ];

        D3DXASSERT(pDep->Count == pRange->vResources.GetSize());
        for (j=0; j<pDep->Count; ++j)
        {
            pDep->ppFXPointers[j] = (SShaderResource *) pRange->vResources[j];
            pDep->ppD3DObjects[j] = NULL;
        }
    }

    for (i=0; i<pShaderBlock->UAVDepCount; ++i)
    {
        SUnorderedAccessViewDependency *pDep = &pShaderBlock->pUAVDeps[i];

        pRange = &vRanges[ER_UnorderedAccessView][i];

        pDep->StartIndex = pRange->start;
        pDep->Count = pRange->last - pDep->StartIndex;
        pDep->ppFXPointers = PRIVATENEW SUnorderedAccessView*[ pDep->Count ];
        pDep->ppD3DObjects = PRIVATENEW ID3D11UnorderedAccessView*[ pDep->Count ];

        D3DXASSERT(pDep->Count == pRange->vResources.GetSize());
        for (j=0; j<pDep->Count; ++j)
        {
            pDep->ppFXPointers[j] = (SUnorderedAccessView *) pRange->vResources[j];
            pDep->ppD3DObjects[j] = NULL;
        }
    }

    if (pShaderBlock->TBufferDepCount > 0)
    {
        memcpy(pShaderBlock->ppTbufDeps, &vTBuffers[0], pShaderBlock->TBufferDepCount * sizeof(SConstantBuffer*));
    }

lExit:
    return hr;
}

// Create shader reflection interface and grab dependency info
HRESULT CEffectLoader::BuildShaderBlock(SShaderBlock *pShaderBlock)
{
    HRESULT hr = S_OK;

    // unused shader block? that's not right
    VBD( pShaderBlock->pVT != NULL, "Internal loading error: NULL shader vtable." );

    D3DXASSERT(pShaderBlock->pD3DObject == NULL);

    if (NULL == pShaderBlock->pReflectionData)
    {
        // File contains a shader variable without an assigned shader, or this is a null assignment.
        // Usually, this is called by one of these guys:
        // SetVertexShader( NULL );
        // or 
        // vertexshader g_VS = NULL;
        return S_OK;
    }

    // Initialize the reflection interface
    VHD( D3DReflect( pShaderBlock->pReflectionData->pBytecode, pShaderBlock->pReflectionData->BytecodeLength, IID_ID3D11ShaderReflection, (void**)&pShaderBlock->pReflectionData->pReflection ),
         "Internal loading error: cannot create shader reflection object." );

    // Get dependencies
    VH( GrabShaderData( pShaderBlock ) );

    // Grab input signatures for VS
    if( EOT_VertexShader == pShaderBlock->GetShaderType() )
    {
        D3DXASSERT( pShaderBlock->pInputSignatureBlob == NULL );
        VHD( D3DGetInputSignatureBlob( pShaderBlock->pReflectionData->pBytecode, pShaderBlock->pReflectionData->BytecodeLength, &pShaderBlock->pInputSignatureBlob ),
             "Internal loading error: cannot get input signature." );
    }

lExit:
    return hr;
}

#undef PRIVATENEW


//////////////////////////////////////////////////////////////////////////
// Code to relocate data to private heaps (reflection & runtime effect)
//
// Important note about alignment: all reasonable chunks of data are 
// machine word aligned (that is, any piece of data moved as a whole is 
// aligned as a whole.  This means that when computing m_ReflectionMemory
// or m_EffectMemory, each addition is aligned.  This also means 
// that, when later relocating that same memory, you must call MoveData
// or MoveString on the same chunks that were aligned.  This is 
// because:   Align(a * b) != a * Align(b).
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// Reflection reallocation code
//////////////////////////////////////////////////////////////////////////

HRESULT CEffectLoader::CalculateAnnotationSize(UINT  cAnnotations, SAnnotation *pAnnotations)
{
    HRESULT hr = S_OK;
    UINT  i;

    m_ReflectionMemory += AlignToPowerOf2(cAnnotations * sizeof(SAnnotation), c_DataAlignment);
    for (i=0; i<cAnnotations; i++)
    {
        if (pAnnotations[i].pType->BelongsInConstantBuffer())
        {
            m_ReflectionMemory += AlignToPowerOf2(pAnnotations[i].pType->TotalSize, c_DataAlignment);
        }
        else
        {
            VBD( pAnnotations[i].pType->IsObjectType(EOT_String), "Invalid pEffectBuffer: invalid annotation type." );

            UINT  cElements;
            cElements = max(1, pAnnotations[i].pType->Elements);
            
            m_ReflectionMemory += AlignToPowerOf2(cElements * sizeof(SString), c_DataAlignment);
            
        }
    }

lExit:
    return hr;
}

HRESULT CEffectLoader::ReallocateAnnotationData(UINT  cAnnotations, SAnnotation **ppAnnotations)
{
    HRESULT hr = S_OK;
    UINT  i;
    SAnnotation *pAnnotations;

    VHD( m_pReflection->m_Heap.MoveData((void**) ppAnnotations, cAnnotations * sizeof(SAnnotation)),
         "Internal loading error: cannot move annotation data." );
    pAnnotations = *ppAnnotations;

    for (i=0; i<cAnnotations; i++)
    {
        SAnnotation *pAn = &pAnnotations[i];
        pAn->pEffect = m_pEffect;

        VHD( m_pReflection->m_Heap.MoveString(&pAn->pName), "Internal loading error: cannot move annotation name." );

        // Reallocate type later
        if (pAn->pType->BelongsInConstantBuffer())
        {
            VHD( m_pReflection->m_Heap.MoveData( &pAn->Data.pGeneric, pAn->pType->TotalSize ), "Internal loading error: cannot move annotation data." );
        }
        else if (pAnnotations[i].pType->IsObjectType(EOT_String))
        {
            UINT  j;
            UINT  cElements = max(1, pAn->pType->Elements);
                        
            VHD( m_pReflection->m_Heap.MoveData((void**) &pAn->Data.pString, cElements * sizeof(SString)), "Internal loading error: cannot move annotation string." );
            for (j = 0; j < cElements; ++ j)
            {
                VHD( m_pReflection->m_Heap.MoveString(&pAn->Data.pString[j].pString), "Internal loading error: cannot move annotation string element." );
            }
        }
        else
        {
            VHD( E_FAIL, "Invalid pEffectBuffer: invalid annotation type." );
        }
    }

lExit:
    return hr;
}

HRESULT CEffectLoader::InitializeReflectionDataAndMoveStrings( UINT KnownSize )
{
    HRESULT hr = S_OK;
    UINT  i, j, k;
    UINT  cbStrings;
    CEffectHeap *pHeap = &m_pReflection->m_Heap;

    // Get byte counts
    cbStrings = m_pEffect->m_StringCount * sizeof( SString );

    if( KnownSize )
    {
        m_ReflectionMemory = KnownSize;
    }
    else
    {
        m_ReflectionMemory += AlignToPowerOf2(cbStrings, c_DataAlignment);

        for (i=0; i<m_pEffect->m_CBCount; i++)
        {
            VH( CalculateAnnotationSize(m_pEffect->m_pCBs[i].AnnotationCount, m_pEffect->m_pCBs[i].pAnnotations) );
        }

        for (i=0; i<m_pEffect->m_VariableCount; i++)
        {
            VH( CalculateAnnotationSize(m_pEffect->m_pVariables[i].AnnotationCount, m_pEffect->m_pVariables[i].pAnnotations) );
        }

        for (i=0; i<m_pEffect->m_GroupCount; i++)
        {
            VH( CalculateAnnotationSize(m_pEffect->m_pGroups[i].AnnotationCount, m_pEffect->m_pGroups[i].pAnnotations) );

            for (j=0; j<m_pEffect->m_pGroups[i].TechniqueCount; j++)
            {
                VH( CalculateAnnotationSize(m_pEffect->m_pGroups[i].pTechniques[j].AnnotationCount, m_pEffect->m_pGroups[i].pTechniques[j].pAnnotations) );

                for (k=0; k<m_pEffect->m_pGroups[i].pTechniques[j].PassCount; k++)
                {
                    VH( CalculateAnnotationSize(m_pEffect->m_pGroups[i].pTechniques[j].pPasses[k].AnnotationCount, m_pEffect->m_pGroups[i].pTechniques[j].pPasses[k].pAnnotations) );
                }
            }
        }

        // Calculate shader reflection data size
        for (i=0; i<m_pEffect->m_ShaderBlockCount; i++)
        {
            if (NULL != m_pEffect->m_pShaderBlocks[i].pReflectionData)
            {
                m_ReflectionMemory += AlignToPowerOf2(sizeof(SShaderBlock::SReflectionData), c_DataAlignment);
                m_ReflectionMemory += AlignToPowerOf2(m_pEffect->m_pShaderBlocks[i].pReflectionData->BytecodeLength, c_DataAlignment);
                // stream out decl is handled as a string, and thus its size is already factored because of GetStringAndAddToReflection
            }
        }
    }

    VHD( pHeap->ReserveMemory(m_ReflectionMemory), "Internal loading error: failed to reserve reflection memory." );

    // Strings are handled separately because we are moving them to reflection
    m_pOldStrings = m_pEffect->m_pStrings;
    VHD( pHeap->MoveData((void**) &m_pEffect->m_pStrings, cbStrings), "Internal loading error: cannot move string data." );
    for(i=0; i<m_pEffect->m_StringCount; i++)
    {
        VHD( pHeap->MoveString( &m_pEffect->m_pStrings[i].pString), "Internal loading error: cannot move string pointer." );
    }

lExit:
    return hr;
}

// Move all reflection data to private heap
HRESULT CEffectLoader::ReallocateReflectionData( bool Cloning )
{
    HRESULT hr = S_OK;
    UINT  i, j, k;
    CEffectHeap *pHeap = &m_pReflection->m_Heap;

    for(i=0; i<m_pEffect->m_CBCount; i++)
    {
        VHD( pHeap->MoveString( &m_pEffect->m_pCBs[i].pName ), "Internal loading error: cannot move CB name." );
        VH( ReallocateAnnotationData(m_pEffect->m_pCBs[i].AnnotationCount, &m_pEffect->m_pCBs[i].pAnnotations) );
    }

    for(i=0; i<m_pEffect->m_VariableCount; i++)
    {
        VHD( pHeap->MoveString( &m_pEffect->m_pVariables[i].pName ), "Internal loading error: cannot move variable name." );
        VHD( pHeap->MoveString( &m_pEffect->m_pVariables[i].pSemantic ), "Internal loading error: cannot move variable semantic." );
        VH( ReallocateAnnotationData(m_pEffect->m_pVariables[i].AnnotationCount, &m_pEffect->m_pVariables[i].pAnnotations) );
    }

    for(i=0; i<m_pEffect->m_GroupCount; i++)
    {
        VHD( pHeap->MoveString( &m_pEffect->m_pGroups[i].pName ), "Internal loading error: cannot move group name." );
        VH( ReallocateAnnotationData(m_pEffect->m_pGroups[i].AnnotationCount, &m_pEffect->m_pGroups[i].pAnnotations) );

        for(j=0; j<m_pEffect->m_pGroups[i].TechniqueCount; j++)
        {
            VHD( pHeap->MoveString( &m_pEffect->m_pGroups[i].pTechniques[j].pName ), "Internal loading error: cannot move technique name." );
            VH( ReallocateAnnotationData(m_pEffect->m_pGroups[i].pTechniques[j].AnnotationCount, &m_pEffect->m_pGroups[i].pTechniques[j].pAnnotations) );
            
            for(k=0; k<m_pEffect->m_pGroups[i].pTechniques[j].PassCount; k++)
            {
                VHD( pHeap->MoveString( &m_pEffect->m_pGroups[i].pTechniques[j].pPasses[k].pName ), "Internal loading error: cannot move pass name." );
                VH( ReallocateAnnotationData(m_pEffect->m_pGroups[i].pTechniques[j].pPasses[k].AnnotationCount, &m_pEffect->m_pGroups[i].pTechniques[j].pPasses[k].pAnnotations) );
            }
        }
    }

    if( !Cloning )
    {
        // When not cloning, every member in m_pMemberInterfaces is from a global variable, so we can take pName and pSemantic
        // from the parent variable, which were updated above
        for (i = 0; i < m_pEffect->m_pMemberInterfaces.GetSize(); ++ i)
        {
            SMember* pMember = m_pEffect->m_pMemberInterfaces[i];
            SGlobalVariable* pTopLevelEntity = (SGlobalVariable*)pMember->pTopLevelEntity;
            VH( FixupVariablePointer( &pTopLevelEntity ) );
            pMember->pName = pTopLevelEntity->pName;
            pMember->pSemantic = pTopLevelEntity->pSemantic;
        }
    }

    // Move shader bytecode
    for (i=0; i<m_pEffect->m_ShaderBlockCount; i++)
    {
        if (NULL != m_pEffect->m_pShaderBlocks[i].pReflectionData)
        {
            VHD( pHeap->MoveData((void**)&m_pEffect->m_pShaderBlocks[i].pReflectionData, sizeof(SShaderBlock::SReflectionData)),
                 "Internal loading error: cannot move shader reflection block." );
            VHD( pHeap->MoveData((void**)&m_pEffect->m_pShaderBlocks[i].pReflectionData->pBytecode, m_pEffect->m_pShaderBlocks[i].pReflectionData->BytecodeLength),
                 "Internal loading error: cannot move shader bytecode.");
            for( UINT iDecl=0; iDecl < D3D11_SO_STREAM_COUNT; ++iDecl )
            {
                VHD( pHeap->MoveString(&m_pEffect->m_pShaderBlocks[i].pReflectionData->pStreamOutDecls[iDecl]), "Internal loading error: cannot move SO decl." );
            }
            VH( pHeap->MoveInterfaceParameters(m_pEffect->m_pShaderBlocks[i].pReflectionData->InterfaceParameterCount, &m_pEffect->m_pShaderBlocks[i].pReflectionData->pInterfaceParameters ) );
        }
        
    }

lExit:
    return hr;
}

//////////////////////////////////////////////////////////////////////////
// Runtime effect reallocation code
//////////////////////////////////////////////////////////////////////////

template<class T> HRESULT CEffectLoader::ReallocateBlockAssignments(T* &pBlocks, UINT  cBlocks, T* pOldBlocks)
{
    HRESULT hr = S_OK;
    CEffectHeap *pHeap = &m_pEffect->m_Heap;
    UINT  i, j;

    for(i=0; i<cBlocks; i++)
    {
        T *pBlock = &pBlocks[i];
        VHD( pHeap->MoveData((void**) &pBlock->pAssignments, sizeof(SAssignment)*pBlock->AssignmentCount), "Internal loading error: cannot move assignment count." );

        for (j=0; j<pBlock->AssignmentCount; j++)
        {
            SAssignment *pAssignment = &pBlock->pAssignments[j];
            UINT  cbDeps;

            // When cloning, convert pointers back into offsets
            if( pOldBlocks )
            {
                T *pOldBlock = &pOldBlocks[i];
                pAssignment->Destination.Offset = (UINT)( (UINT_PTR)pAssignment->Destination.pGeneric - (UINT_PTR)pOldBlock ) ;
            }

            // Convert destination pointers from offset to real pointer
            pAssignment->Destination.pGeneric = (BYTE*) pBlock + pAssignment->Destination.Offset;

            // Make sure the data pointer points into the backing store
            VBD( pAssignment->Destination.pGeneric >= &pBlock->BackingStore && 
                 pAssignment->Destination.pGeneric < (BYTE*) &pBlock->BackingStore + sizeof(pBlock->BackingStore), 
                 "Internal loading error: assignment destination out of range." );

            // Fixup dependencies
            cbDeps = pAssignment->DependencyCount * sizeof(SAssignment::SDependency);
            VHD( pHeap->MoveData((void**) &pAssignment->pDependencies, cbDeps), "Internal loading error: cannot move assignment dependencies." );

            SGlobalVariable *pOldVariable = NULL;
            for(UINT  iDep=0; iDep<pAssignment->DependencyCount; iDep++)
            {
                SAssignment::SDependency *pDep = &pAssignment->pDependencies[iDep];
                // We ignore all but the last variable because below, we only use the last dependency
                pOldVariable = pDep->pVariable;
                VH( FixupVariablePointer(&pDep->pVariable) );
            }

            // Fixup source pointers
            switch(pAssignment->LhsType)
            {
            case ELHS_VertexShaderBlock:
            case ELHS_PixelShaderBlock:
            case ELHS_GeometryShaderBlock:
            case ELHS_HullShaderBlock:
            case ELHS_DomainShaderBlock:
            case ELHS_ComputeShaderBlock:
                VH( FixupShaderPointer(&pAssignment->Source.pShader) );
                break;

            case ELHS_DepthStencilBlock:
                VH( FixupDSPointer((SDepthStencilBlock**)&pAssignment->Source.pBlock) );
                break;
            case ELHS_BlendBlock:
                VH( FixupABPointer((SBlendBlock**) &pAssignment->Source.pBlock) );
                break;
            case ELHS_RasterizerBlock:
                VH( FixupRSPointer((SRasterizerBlock**) &pAssignment->Source.pBlock) );
                break;

            case ELHS_Texture:
                VH( FixupShaderResourcePointer((SShaderResource**) &pAssignment->Source.pShaderResource) );
                break;

            default:
                // Non-object assignment (must have at least one dependency or it would have been pruned by now)
                D3DXASSERT( !pAssignment->IsObjectAssignment() && pAssignment->DependencyCount > 0 );

                // Numeric variables must be relocated before this function is called
                
                switch (pAssignment->AssignmentType)
                {
                case ERAT_NumericVariable:
                case ERAT_NumericVariableIndex:
                    // the variable or variable array is always the last dependency in the chain
                    SGlobalVariable *pVariable;
                    pVariable = pAssignment->pDependencies[pAssignment->DependencyCount - 1].pVariable;
                    D3DXASSERT( pVariable->pType->BelongsInConstantBuffer() && NULL != pVariable->pCB );

                    // When cloning, convert pointers back into offsets
                    if( pOldBlocks )
                    {
                        VBD( pOldVariable != NULL, "Internal loading error: pOldVariable is NULL." );
                        pAssignment->Source.Offset = pAssignment->Source.pNumeric - pOldVariable->pCB->pBackingStore;
                    }

                    // Convert from offset to pointer
                    pAssignment->Source.pNumeric = pVariable->pCB->pBackingStore + pAssignment->Source.Offset;
                    break;

                default:
                    // Shouldn't be able to get here
                    D3DXASSERT(0);
                    VHD( E_FAIL, "Loading error: invalid assignment type." );
                }
                break;

            case ELHS_Invalid:
                VHD( E_FAIL, "Loading error: invalid assignment type." );
            }

            D3DXASSERT(m_pEffect->m_LocalTimer > 0);
            m_pEffect->EvaluateAssignment(pAssignment);
        }
    }

lExit:
    return hr;
}

template<class T> UINT  CEffectLoader::CalculateBlockAssignmentSize(T* &pBlocks, UINT  cBlocks)
{
    UINT  dwSize = 0;
    UINT  i, j;

    for(i=0; i<cBlocks; i++)
    {
        SBaseBlock *pBlock = &pBlocks[i];
        dwSize += AlignToPowerOf2(pBlock->AssignmentCount * sizeof(SAssignment), c_DataAlignment);
        
        for (j=0; j<pBlock->AssignmentCount; j++)
        {
            SAssignment *pAssignment = &pBlock->pAssignments[j];
            
            dwSize += AlignToPowerOf2(pAssignment->DependencyCount * sizeof(SAssignment::SDependency), c_DataAlignment);
        }
    }

    return dwSize;
}

HRESULT CEffectLoader::ReallocateShaderBlocks()
{
    HRESULT hr = S_OK;
    UINT  i, j, k;
    CEffectHeap *pHeap = &m_pEffect->m_Heap;
    const char* pError = "Internal loading error: cannot move shader data.";
    
    for (i=0; i<m_pEffect->m_ShaderBlockCount; i++)
    {
        SShaderBlock *pShader = &m_pEffect->m_pShaderBlocks[i];

        // pShader->pReflection data and all of its members (bytecode, SO decl, etc.) are handled by ReallocateReflectionData()
        VHD( pHeap->MoveData((void**) &pShader->pCBDeps, pShader->CBDepCount * sizeof(SShaderCBDependency)), pError );
        VHD( pHeap->MoveData((void**) &pShader->pSampDeps, pShader->SampDepCount * sizeof(SShaderSamplerDependency)), pError );
        VHD( pHeap->MoveData((void**) &pShader->pInterfaceDeps, pShader->InterfaceDepCount * sizeof(SInterfaceDependency)), pError );
        VHD( pHeap->MoveData((void**) &pShader->pResourceDeps, pShader->ResourceDepCount * sizeof(SShaderResourceDependency)), pError );
        VHD( pHeap->MoveData((void**) &pShader->pUAVDeps, pShader->UAVDepCount * sizeof(SUnorderedAccessViewDependency)), pError );
        VHD( pHeap->MoveData((void**) &pShader->ppTbufDeps, pShader->TBufferDepCount * sizeof(SConstantBuffer*)), pError );
        
        for (j=0; j<pShader->CBDepCount; j++)
        {
            SShaderCBDependency *pCBDeps = &pShader->pCBDeps[j];
            VHD( pHeap->MoveData((void**) &pCBDeps->ppD3DObjects, pCBDeps->Count * sizeof(ID3D11Buffer*)), pError );
            VHD( pHeap->MoveData((void**) &pCBDeps->ppFXPointers, pCBDeps->Count * sizeof(SConstantBuffer*)), pError );

            for (k=0; k<pCBDeps->Count; k++)
            {
                VH( FixupCBPointer( &pCBDeps->ppFXPointers[k] ) );
            }
        }

        for (j=0; j<pShader->SampDepCount; j++)
        {
            SShaderSamplerDependency *pSampDeps = &pShader->pSampDeps[j];
            VHD( pHeap->MoveData((void**) &pSampDeps->ppD3DObjects, pSampDeps->Count * sizeof(ID3D11SamplerState*)), pError );
            VHD( pHeap->MoveData((void**) &pSampDeps->ppFXPointers, pSampDeps->Count * sizeof(SSamplerBlock*)), pError );

            for (k=0; k<pSampDeps->Count; k++)
            {
                VH( FixupSamplerPointer(&pSampDeps->ppFXPointers[k]) );
            }
        }

        for (j=0; j<pShader->InterfaceDepCount; j++)
        {
            SInterfaceDependency *pInterfaceDeps = &pShader->pInterfaceDeps[j];
            VHD( pHeap->MoveData((void**) &pInterfaceDeps->ppD3DObjects, pInterfaceDeps->Count * sizeof(ID3D11ClassInstance*)), pError );
            VHD( pHeap->MoveData((void**) &pInterfaceDeps->ppFXPointers, pInterfaceDeps->Count * sizeof(SInterface*)), pError );

            for (k=0; k<pInterfaceDeps->Count; k++)
            {
                VH( FixupInterfacePointer(&pInterfaceDeps->ppFXPointers[k], true) );
            }
        }

        for (j=0; j<pShader->ResourceDepCount; j++)
        {
            SShaderResourceDependency *pResourceDeps = &pShader->pResourceDeps[j];
            VHD( pHeap->MoveData((void**) &pResourceDeps->ppD3DObjects, pResourceDeps->Count * sizeof(ID3D11ShaderResourceView*)), pError );
            VHD( pHeap->MoveData((void**) &pResourceDeps->ppFXPointers, pResourceDeps->Count * sizeof(SShaderResource*)), pError );

            for (k=0; k<pResourceDeps->Count; k++)
            {
                VH( FixupShaderResourcePointer(&pResourceDeps->ppFXPointers[k]) );
            }
        }

        for (j=0; j<pShader->UAVDepCount; j++)
        {
            SUnorderedAccessViewDependency *pUAVDeps = &pShader->pUAVDeps[j];
            VHD( pHeap->MoveData((void**) &pUAVDeps->ppD3DObjects, pUAVDeps->Count * sizeof(ID3D11UnorderedAccessView*)), pError );
            VHD( pHeap->MoveData((void**) &pUAVDeps->ppFXPointers, pUAVDeps->Count * sizeof(SUnorderedAccessView*)), pError );

            for (k=0; k<pUAVDeps->Count; k++)
            {
                VH( FixupUnorderedAccessViewPointer(&pUAVDeps->ppFXPointers[k]) );
            }
        }

        for (j=0; j<pShader->TBufferDepCount; j++)
        {
            VH( FixupCBPointer( &pShader->ppTbufDeps[j] ) );
        }
    }

lExit:
    return hr;
}


UINT  CEffectLoader::CalculateShaderBlockSize()
{
    UINT  dwSize = 0;
    UINT  i, j;
    
    for (i=0; i<m_pEffect->m_ShaderBlockCount; i++)
    {
        SShaderBlock *pShader = &m_pEffect->m_pShaderBlocks[i];

        dwSize += AlignToPowerOf2(pShader->CBDepCount * sizeof(SShaderCBDependency), c_DataAlignment);
        dwSize += AlignToPowerOf2(pShader->SampDepCount * sizeof(SShaderSamplerDependency), c_DataAlignment);
        dwSize += AlignToPowerOf2(pShader->InterfaceDepCount * sizeof(SInterfaceDependency), c_DataAlignment);
        dwSize += AlignToPowerOf2(pShader->ResourceDepCount * sizeof(SShaderResourceDependency), c_DataAlignment);
        dwSize += AlignToPowerOf2(pShader->UAVDepCount * sizeof(SUnorderedAccessViewDependency), c_DataAlignment);
        dwSize += AlignToPowerOf2(pShader->TBufferDepCount * sizeof(SConstantBuffer*), c_DataAlignment);

        for (j=0; j<pShader->CBDepCount; j++)
        {
            SShaderCBDependency *pCBDeps = &pShader->pCBDeps[j];
            dwSize += AlignToPowerOf2(pCBDeps->Count * sizeof(ID3D11Buffer*), c_DataAlignment);
            dwSize += AlignToPowerOf2(pCBDeps->Count * sizeof(SConstantBuffer*), c_DataAlignment);
        }

        for (j=0; j<pShader->SampDepCount; j++)
        {
            SShaderSamplerDependency *pSampDeps = &pShader->pSampDeps[j];
            dwSize += AlignToPowerOf2(pSampDeps->Count * sizeof(ID3D11SamplerState*), c_DataAlignment);
            dwSize += AlignToPowerOf2(pSampDeps->Count * sizeof(SSamplerBlock*), c_DataAlignment);
        }

        for (j=0; j<pShader->InterfaceDepCount; j++)
        {
            SInterfaceDependency *pInterfaceDeps = &pShader->pInterfaceDeps[j];
            dwSize += AlignToPowerOf2(pInterfaceDeps->Count * sizeof(ID3D11ClassInstance*), c_DataAlignment);
            dwSize += AlignToPowerOf2(pInterfaceDeps->Count * sizeof(SInterface*), c_DataAlignment);
        }

        for (j=0; j<pShader->ResourceDepCount; j++)
        {
            SShaderResourceDependency *pResourceDeps = &pShader->pResourceDeps[j];
            dwSize += AlignToPowerOf2(pResourceDeps->Count * sizeof(ID3D11ShaderResourceView*), c_DataAlignment);
            dwSize += AlignToPowerOf2(pResourceDeps->Count * sizeof(SShaderResource*), c_DataAlignment);
        }

        for (j=0; j<pShader->UAVDepCount; j++)
        {
            SUnorderedAccessViewDependency *pUAVDeps = &pShader->pUAVDeps[j];
            dwSize += AlignToPowerOf2(pUAVDeps->Count * sizeof(ID3D11UnorderedAccessView*), c_DataAlignment);
            dwSize += AlignToPowerOf2(pUAVDeps->Count * sizeof(SUnorderedAccessView*), c_DataAlignment);
        }
    }

    return dwSize;
}

// Move all (non-reflection) effect data to private heap
HRESULT CEffectLoader::ReallocateEffectData( bool Cloning )
{
    HRESULT hr = S_OK;
    UINT i, j;
    CEffectHeap *pHeap = &m_pEffect->m_Heap;
    UINT cbCBs = sizeof(SConstantBuffer) * m_pEffect->m_CBCount;
    UINT cbVariables = sizeof(SGlobalVariable) * m_pEffect->m_VariableCount;
    UINT cbGroups = sizeof(STechnique) * m_pEffect->m_GroupCount;
    UINT cbShaders = sizeof(SShaderBlock) * m_pEffect->m_ShaderBlockCount;
    UINT cbDS = sizeof(SDepthStencilBlock) * m_pEffect->m_DepthStencilBlockCount;
    UINT cbAB = sizeof(SBlendBlock) * m_pEffect->m_BlendBlockCount;
    UINT cbRS = sizeof(SRasterizerBlock) * m_pEffect->m_RasterizerBlockCount;
    UINT cbSamplers = sizeof(SSamplerBlock) * m_pEffect->m_SamplerBlockCount;
    UINT cbMemberDatas = sizeof(SMemberDataPointer) * m_pEffect->m_MemberDataCount;
    UINT cbInterfaces = sizeof(SInterface) * m_pEffect->m_InterfaceCount;
    UINT cbBackgroundInterfaces = sizeof(SInterface) * m_BackgroundInterfaces.GetSize();
    UINT cbShaderResources = sizeof(SShaderResource) * m_pEffect->m_ShaderResourceCount;
    UINT cbUnorderedAccessViews = sizeof(SUnorderedAccessView) * m_pEffect->m_UnorderedAccessViewCount;
    UINT cbRenderTargetViews = sizeof(SRenderTargetView) * m_pEffect->m_RenderTargetViewCount;
    UINT cbDepthStencilViews = sizeof(SDepthStencilView) * m_pEffect->m_DepthStencilViewCount;
    UINT cbAnonymousShaders = sizeof(SAnonymousShader) * m_pEffect->m_AnonymousShaderCount;

    // Calculate memory needed
    m_EffectMemory += AlignToPowerOf2(cbCBs, c_DataAlignment);
    m_EffectMemory += AlignToPowerOf2(cbVariables, c_DataAlignment);
    m_EffectMemory += AlignToPowerOf2(cbGroups, c_DataAlignment);
    m_EffectMemory += AlignToPowerOf2(cbShaders, c_DataAlignment);
    m_EffectMemory += AlignToPowerOf2(cbMemberDatas, c_DataAlignment);
    m_EffectMemory += AlignToPowerOf2(cbInterfaces + cbBackgroundInterfaces, c_DataAlignment);
    m_EffectMemory += AlignToPowerOf2(cbShaderResources, c_DataAlignment);
    m_EffectMemory += AlignToPowerOf2(cbUnorderedAccessViews, c_DataAlignment);
    m_EffectMemory += AlignToPowerOf2(cbRenderTargetViews, c_DataAlignment);
    m_EffectMemory += AlignToPowerOf2(cbDepthStencilViews, c_DataAlignment);
    m_EffectMemory += AlignToPowerOf2(cbDS, c_DataAlignment);
    m_EffectMemory += AlignToPowerOf2(cbAB, c_DataAlignment);
    m_EffectMemory += AlignToPowerOf2(cbRS, c_DataAlignment);
    m_EffectMemory += AlignToPowerOf2(cbSamplers, c_DataAlignment);
    m_EffectMemory += AlignToPowerOf2(cbAnonymousShaders, c_DataAlignment);

    m_EffectMemory += CalculateShaderBlockSize();

    for (i=0; i<m_pEffect->m_CBCount; i++)
    {
        SConstantBuffer *pCB = &m_pEffect->m_pCBs[i];

        m_EffectMemory += AlignToPowerOf2(pCB->Size, c_DataAlignment);
    }

    for (i=0; i<m_pEffect->m_GroupCount; i++)
    {
        SGroup *pGroup = &m_pEffect->m_pGroups[i];

        m_EffectMemory += AlignToPowerOf2(pGroup->TechniqueCount * sizeof(STechnique), c_DataAlignment);

        for (j=0; j<pGroup->TechniqueCount; j++)
        {
            STechnique *pTech = &pGroup->pTechniques[j];

            m_EffectMemory += AlignToPowerOf2(pTech->PassCount * sizeof(SPassBlock), c_DataAlignment);
            m_EffectMemory += CalculateBlockAssignmentSize(pTech->pPasses, pTech->PassCount);
        }
    };

    m_EffectMemory += CalculateBlockAssignmentSize(m_pEffect->m_pBlendBlocks, m_pEffect->m_BlendBlockCount);
    m_EffectMemory += CalculateBlockAssignmentSize(m_pEffect->m_pDepthStencilBlocks, m_pEffect->m_DepthStencilBlockCount);
    m_EffectMemory += CalculateBlockAssignmentSize(m_pEffect->m_pRasterizerBlocks, m_pEffect->m_RasterizerBlockCount);
    m_EffectMemory += CalculateBlockAssignmentSize(m_pEffect->m_pSamplerBlocks, m_pEffect->m_SamplerBlockCount);

    // Reserve memory
    VHD( pHeap->ReserveMemory(m_EffectMemory), "Internal loading error: cannot reserve effect memory." );

    // Move DataMemberPointer blocks
    m_pOldMemberDataBlocks = m_pEffect->m_pMemberDataBlocks;
    VHD( pHeap->MoveData((void**) &m_pEffect->m_pMemberDataBlocks, cbMemberDatas), "Internal loading error: cannot move member data blocks." );

    // Move CBs
    m_pOldCBs = m_pEffect->m_pCBs;
    VHD( pHeap->MoveData((void**) &m_pEffect->m_pCBs, cbCBs), "Internal loading error: cannot move CB count." );
    for (i=0; i<m_pEffect->m_CBCount; i++)
    {
        SConstantBuffer *pCB = &m_pEffect->m_pCBs[i];

        VHD( pHeap->MoveData((void**) &pCB->pBackingStore, pCB->Size), "Internal loading error: cannot move CB backing store." );

        if( !Cloning )
        {
            // When creating the effect, MemberDataOffsetPlus4 is used, not pMemberData
            if( pCB->MemberDataOffsetPlus4 )
            {
                pCB->pMemberData = (SMemberDataPointer*)( (BYTE*)m_pEffect->m_pMemberDataBlocks + ( pCB->MemberDataOffsetPlus4 - 4 ) );
            }
        }
        else if (pCB->pMemberData)
        {
            // When cloning an effect, pMemberData points to valid data in the original effect
            VH( FixupMemberDataPointer( &pCB->pMemberData ) );
        }
    }

    // Move numeric variables; move all variable types
    m_pOldVars = m_pEffect->m_pVariables;
    VHD( pHeap->MoveData((void**) &m_pEffect->m_pVariables, cbVariables), "Internal loading error: cannot move variable count." );
    for (i=0; i<m_pEffect->m_VariableCount; i++)
    {
        SGlobalVariable *pVar = &m_pEffect->m_pVariables[i];
        pVar->pEffect = m_pEffect;

        if( Cloning && pVar->pType->BelongsInConstantBuffer())
        {
            // Convert pointer back to offset
            // pVar->pCB refers to the old CB
            pVar->Data.Offset = (UINT_PTR)pVar->Data.pGeneric - (UINT_PTR)pVar->pCB->pBackingStore;
        }

        if (pVar->pCB)
        {
            VH( FixupCBPointer( &pVar->pCB ) );
        }

        if( !Cloning )
        {
            // When creating the effect, MemberDataOffsetPlus4 is used, not pMemberData
            if( pVar->MemberDataOffsetPlus4 )
            {
                pVar->pMemberData = (SMemberDataPointer*)( (BYTE*)m_pEffect->m_pMemberDataBlocks + ( pVar->MemberDataOffsetPlus4 - 4 ) );
            }
        }
        else if (pVar->pMemberData)
        {
            // When cloning an effect, pMemberData points to valid data in the original effect
            VH( FixupMemberDataPointer( &pVar->pMemberData ) );
        }

        if (pVar->pType->BelongsInConstantBuffer())
        {
            // Convert from offsets to pointers
            pVar->Data.pGeneric = pVar->pCB->pBackingStore + pVar->Data.Offset;
        }
    }

    // Fixup each CB's array of child variable pointers
    for (i=0; i<m_pEffect->m_CBCount; i++)
    {
        SConstantBuffer *pCB = &m_pEffect->m_pCBs[i];
        pCB->pEffect = m_pEffect;

        if (pCB->pVariables != NULL)
        {
            VH( FixupVariablePointer(&pCB->pVariables) );
        }
    }

    // Move shaders
    m_pOldShaders = m_pEffect->m_pShaderBlocks;
    VHD( pHeap->MoveData((void**) &m_pEffect->m_pShaderBlocks, cbShaders), "Internal loading error: cannot move shader count." );

    // Move interfaces, combining global interfaces and those that were created during shader initialization
    m_pOldInterfaces = m_pEffect->m_pInterfaces;
    m_OldInterfaceCount = m_pEffect->m_InterfaceCount;
    VHD( pHeap->MoveEmptyDataBlock((void**) &m_pEffect->m_pInterfaces, cbInterfaces + cbBackgroundInterfaces), "Internal loading error: cannot move shader." );
    memcpy( m_pEffect->m_pInterfaces, m_pOldInterfaces, cbInterfaces );
    for( i=0; i < m_BackgroundInterfaces.GetSize(); i++ )
    {
        D3DXASSERT( m_BackgroundInterfaces[i] != NULL );
        BYTE* pDst = (BYTE*)m_pEffect->m_pInterfaces  + ( m_pEffect->m_InterfaceCount * sizeof(SInterface) );
        memcpy( pDst, m_BackgroundInterfaces[i], sizeof(SInterface) );
        m_pEffect->m_InterfaceCount++;
    }

    m_pOldShaderResources = m_pEffect->m_pShaderResources;
    VHD( pHeap->MoveData((void**) &m_pEffect->m_pShaderResources, cbShaderResources), "Internal loading error: cannot move SRVs." );

    m_pOldUnorderedAccessViews = m_pEffect->m_pUnorderedAccessViews;
    VHD( pHeap->MoveData((void**) &m_pEffect->m_pUnorderedAccessViews, cbUnorderedAccessViews), "Internal loading error: cannot move UAVS." );

    m_pOldRenderTargetViews = m_pEffect->m_pRenderTargetViews;
    VHD( pHeap->MoveData((void**) &m_pEffect->m_pRenderTargetViews, cbRenderTargetViews), "Internal loading error: cannot move RTVs." );

    m_pOldDepthStencilViews = m_pEffect->m_pDepthStencilViews;
    VHD( pHeap->MoveData((void**) &m_pEffect->m_pDepthStencilViews, cbDepthStencilViews), "Internal loading error: cannot move DSVs." );

    m_pOldDS = m_pEffect->m_pDepthStencilBlocks;
    VHD( pHeap->MoveData((void**) &m_pEffect->m_pDepthStencilBlocks, cbDS), "Internal loading error: cannot move depth-stencil state blocks." );
    VH( ReallocateBlockAssignments(m_pEffect->m_pDepthStencilBlocks, m_pEffect->m_DepthStencilBlockCount, Cloning ? m_pOldDS : NULL) );
    
    m_pOldAB = m_pEffect->m_pBlendBlocks;
    VHD( pHeap->MoveData((void**) &m_pEffect->m_pBlendBlocks, cbAB), "Internal loading error: cannot move blend state blocks." );
    VH( ReallocateBlockAssignments(m_pEffect->m_pBlendBlocks, m_pEffect->m_BlendBlockCount, Cloning ? m_pOldAB : NULL) );

    m_pOldRS = m_pEffect->m_pRasterizerBlocks;
    VHD( pHeap->MoveData((void**) &m_pEffect->m_pRasterizerBlocks, cbRS), "Internal loading error: cannot move rasterizer state blocks." );
    VH( ReallocateBlockAssignments(m_pEffect->m_pRasterizerBlocks, m_pEffect->m_RasterizerBlockCount, Cloning ? m_pOldRS : NULL) );

    m_pOldSamplers = m_pEffect->m_pSamplerBlocks;
    VHD( pHeap->MoveData((void**) &m_pEffect->m_pSamplerBlocks, cbSamplers), "Internal loading error: cannot move samplers." );
    VH( ReallocateBlockAssignments(m_pEffect->m_pSamplerBlocks, m_pEffect->m_SamplerBlockCount, Cloning ? m_pOldSamplers : NULL) );
    
    // Fixup sampler backing stores
    for (i=0; i<m_pEffect->m_SamplerBlockCount; ++i)
    {
        VH( FixupShaderResourcePointer(&m_pEffect->m_pSamplerBlocks[i].BackingStore.pTexture) );
    }

    // Fixup each interface's class instance variable pointer
    for (i=0; i<m_pEffect->m_InterfaceCount; i++)
    {
        SInterface *pInterface = &m_pEffect->m_pInterfaces[i];

        if (pInterface->pClassInstance != NULL)
        {
            VH( FixupVariablePointer( (SGlobalVariable**)&pInterface->pClassInstance ) );
        }
    }

    // Fixup pointers for non-numeric variables
    for (i=0; i<m_pEffect->m_VariableCount; i++)
    {
        SGlobalVariable *pVar = &m_pEffect->m_pVariables[i];

        if (pVar->pType->IsShader())
        {
            VH( FixupShaderPointer(&pVar->Data.pShader) );
        }
        else if (pVar->pType->IsShaderResource())
        {
            VH( FixupShaderResourcePointer(&pVar->Data.pShaderResource) );
        }
        else if (pVar->pType->IsUnorderedAccessView())
        {
            VH( FixupUnorderedAccessViewPointer(&pVar->Data.pUnorderedAccessView) );
        }
        else if (pVar->pType->IsInterface())
        {
            VH( FixupInterfacePointer(&pVar->Data.pInterface, false) );
        }
        else if (pVar->pType->IsObjectType(EOT_String))
        {
            if( !m_pEffect->IsOptimized() )
            {
                VH( FixupStringPointer(&pVar->Data.pString) );
            }
        }
        else if (pVar->pType->IsStateBlockObject())
        {
            switch(pVar->pType->ObjectType)
            {
                case EOT_DepthStencil:
                    VH( FixupDSPointer((SDepthStencilBlock**) &pVar->Data.pBlock) );
                    break;
                case EOT_Blend:
                    VH( FixupABPointer((SBlendBlock**) &pVar->Data.pBlock) );
                    break;
                case EOT_Rasterizer:
                    VH( FixupRSPointer((SRasterizerBlock**) &pVar->Data.pBlock) );
                    break;
                case EOT_Sampler:
                    VB(pVar->pType->IsSampler());
                    VH( FixupSamplerPointer((SSamplerBlock**) &pVar->Data.pBlock) );
                    break;
                default:
                    VH( E_FAIL );
            }
        }
        else if (pVar->pType->VarType == EVT_Struct || pVar->pType->VarType == EVT_Numeric)
        {
            if( pVar->pType->IsClassInstance() )
            {
                // do nothing
            }
            else
            {
                // do nothing
            }
        }
        else if (pVar->pType->IsRenderTargetView())
        {
            VH( FixupRenderTargetViewPointer(&pVar->Data.pRenderTargetView) );
        } 
        else if (pVar->pType->IsDepthStencilView())
        {
            VH( FixupDepthStencilViewPointer(&pVar->Data.pDepthStencilView) );
        }
        else
        {
            VHD( E_FAIL, "Internal loading error: Invalid variable type." );
        }
    }

    // Fixup created members
    for (i = 0; i < m_pEffect->m_pMemberInterfaces.GetSize(); ++ i)
    {
        SMember* pMember = m_pEffect->m_pMemberInterfaces[i];
        SGlobalVariable** ppTopLevelEntity = (SGlobalVariable**)&pMember->pTopLevelEntity;
        VN( *ppTopLevelEntity );

        // This might be set to false later, for supporting textures inside classes
        const bool bGlobalMemberDataBlock = true;

        if( Cloning )
        {
            if( pMember->pType->BelongsInConstantBuffer() )
            {
                D3DXASSERT( pMember->Data.pGeneric == NULL || (*ppTopLevelEntity)->pEffect->m_Heap.IsInHeap(pMember->Data.pGeneric) );
                pMember->Data.Offset = (UINT)( (BYTE*)pMember->Data.pGeneric - (BYTE*)(*ppTopLevelEntity)->pCB->pBackingStore );
            }
            if( bGlobalMemberDataBlock && pMember->pMemberData )
            {
                pMember->MemberDataOffsetPlus4 = (UINT)( (BYTE*)pMember->pMemberData - (BYTE*)(*ppTopLevelEntity)->pEffect->m_pMemberDataBlocks ) + 4;
            }
        }

        VH( FixupVariablePointer( ppTopLevelEntity ) );

        if (pMember->pType->BelongsInConstantBuffer())
        {
            // Convert from offsets to pointers
            pMember->Data.pGeneric = (*ppTopLevelEntity)->pCB->pBackingStore + pMember->Data.Offset;
        }
        if( bGlobalMemberDataBlock && pMember->MemberDataOffsetPlus4 )
        {
            pMember->pMemberData = (SMemberDataPointer*)( (BYTE*)m_pEffect->m_pMemberDataBlocks + ( pMember->MemberDataOffsetPlus4 - 4 ) );
        }
    }

    // Fixup shader data
    VH( ReallocateShaderBlocks() );

    // Move groups, techniques, and passes
    m_pOldGroups = m_pEffect->m_pGroups;
    VHD( pHeap->MoveData((void**) &m_pEffect->m_pGroups, cbGroups), "Internal loading error: cannot move groups." );
    for (i=0; i<m_pEffect->m_GroupCount; i++)
    {
        SGroup *pGroup = &m_pEffect->m_pGroups[i];
        UINT  cbTechniques;

        cbTechniques = pGroup->TechniqueCount * sizeof(STechnique);
        VHD( pHeap->MoveData((void**) &pGroup->pTechniques, cbTechniques), "Internal loading error: cannot move techniques." );

        for (j=0; j<pGroup->TechniqueCount; j++)
        {
            STechnique *pTech = &pGroup->pTechniques[j];
            UINT  cbPass;
            UINT  iPass;

            cbPass = pTech->PassCount * sizeof(SPassBlock);
            SPassBlock* pOldPasses = Cloning ? pTech->pPasses : NULL;
            VHD( pHeap->MoveData((void**) &pTech->pPasses, cbPass), "Internal loading error: cannot move passes." );

            for (iPass = 0; iPass < pTech->PassCount; ++ iPass)
            {
                pTech->pPasses[iPass].pEffect = m_pEffect;

                // Fixup backing store pointers in passes
                VH( FixupABPointer((SBlendBlock**) &pTech->pPasses[iPass].BackingStore.pBlendBlock) );
                VH( FixupDSPointer((SDepthStencilBlock**) &pTech->pPasses[iPass].BackingStore.pDepthStencilBlock) );
                VH( FixupRSPointer((SRasterizerBlock**) &pTech->pPasses[iPass].BackingStore.pRasterizerBlock) );
                VH( FixupShaderPointer((SShaderBlock**) &pTech->pPasses[iPass].BackingStore.pVertexShaderBlock) );
                VH( FixupShaderPointer((SShaderBlock**) &pTech->pPasses[iPass].BackingStore.pPixelShaderBlock) );
                VH( FixupShaderPointer((SShaderBlock**) &pTech->pPasses[iPass].BackingStore.pGeometryShaderBlock) );
                VH( FixupShaderPointer((SShaderBlock**) &pTech->pPasses[iPass].BackingStore.pHullShaderBlock) );
                VH( FixupShaderPointer((SShaderBlock**) &pTech->pPasses[iPass].BackingStore.pDomainShaderBlock) );
                VH( FixupShaderPointer((SShaderBlock**) &pTech->pPasses[iPass].BackingStore.pComputeShaderBlock) );
                VH( FixupDepthStencilViewPointer( &pTech->pPasses[iPass].BackingStore.pDepthStencilView) );
                for (UINT iRT = 0; iRT < D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT; iRT++)
                {
                    VH( FixupRenderTargetViewPointer( &pTech->pPasses[iPass].BackingStore.pRenderTargetViews[iRT] ) );
                }
            }        

            VH( ReallocateBlockAssignments( pTech->pPasses, pTech->PassCount, pOldPasses ) );
        }
    }
    VH( FixupGroupPointer( &m_pEffect->m_pNullGroup ) );

    // Move anonymous shader variables
    VHD( pHeap->MoveData((void **) &m_pEffect->m_pAnonymousShaders, cbAnonymousShaders), "Internal loading error: cannot move anonymous shaders." );
    for (i=0; i<m_pEffect->m_AnonymousShaderCount; ++i)
    {
        SAnonymousShader *pAnonymousShader = m_pEffect->m_pAnonymousShaders + i;
        VH( FixupShaderPointer((SShaderBlock**) &pAnonymousShader->pShaderBlock) );
    }

    VBD( pHeap->GetSize() == m_EffectMemory, "Loading error: effect size mismatch." );

lExit:
    return hr;
}

}

```

`Source Code/Effects11/EffectLoad.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       EffectLoad.h
//  Content:    D3DX11 Effects header for the FX file loader 
//              A CEffectLoader is created at load time to facilitate loading
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

namespace D3DX11Effects
{

// Ranges are used for dependency checking during load

enum ERanges
{
    ER_CBuffer = 0,
    ER_Texture,     // Includes TBuffers
    ER_Sampler,
    ER_UnorderedAccessView,
    ER_Interfaces,
    ER_Count        // This should be the size of the enum
};

struct SRange
{
    UINT                    start;
    UINT                    last;
    CEffectVector<void *>   vResources; // should be (last - start) in length, resource type depends on the range type
};

// Used during load to validate assignments
D3D10_SHADER_VARIABLE_TYPE GetSimpleParameterTypeFromObjectType(EObjectType ObjectType);


// A class to facilitate loading an Effect.  This class is a friend of CEffect.
class CEffectLoader
{
    friend HRESULT CEffect::CloneEffect(UINT Flags, ID3DX11Effect** ppClonedEffect );

protected:
    // Load-time allocations that eventually get moved happen out of the TempHeap. This heap will grow as needed
    CDataBlockStore             m_BulkHeap;

    BYTE                        *m_pData;
    SBinaryHeader5              *m_pHeader;
    DWORD                       m_Version;

    CEffect                     *m_pEffect;
    CEffectReflection           *m_pReflection;

    D3DX11Core::CMemoryStream   m_msStructured;
    D3DX11Core::CMemoryStream   m_msUnstructured;
    
    // used to avoid repeated hash buffer allocations in LoadTypeAndAddToPool
    CEffectVector<BYTE>         m_HashBuffer;

    UINT                        m_dwBufferSize;     // Size of data buffer in bytes

    // List of SInterface blocks created to back class instances bound to shaders
    CEffectVector<SInterface*>  m_BackgroundInterfaces;

    // Pointers to pre-reallocation data
    SGlobalVariable             *m_pOldVars;
    SShaderBlock                *m_pOldShaders;
    SDepthStencilBlock          *m_pOldDS;
    SBlendBlock                 *m_pOldAB;
    SRasterizerBlock            *m_pOldRS;
    SConstantBuffer             *m_pOldCBs;
    SSamplerBlock               *m_pOldSamplers;
    UINT                        m_OldInterfaceCount;
    SInterface                  *m_pOldInterfaces;
    SShaderResource             *m_pOldShaderResources;
    SUnorderedAccessView        *m_pOldUnorderedAccessViews;
    SRenderTargetView           *m_pOldRenderTargetViews;
    SDepthStencilView           *m_pOldDepthStencilViews;
    SString                     *m_pOldStrings;
    SMemberDataPointer          *m_pOldMemberDataBlocks;
    CEffectVectorOwner<SMember> *m_pvOldMemberInterfaces;
    SGroup                      *m_pOldGroups;

    UINT                        m_EffectMemory;     // Effect private heap
    UINT                        m_ReflectionMemory; // Reflection private heap

    // Loader helpers
    HRESULT LoadCBs();
    HRESULT LoadNumericVariable(SConstantBuffer *pParentCB);
    HRESULT LoadObjectVariables();
    HRESULT LoadInterfaceVariables();

    HRESULT LoadTypeAndAddToPool(SType **ppType, UINT  dwOffset);
    HRESULT LoadStringAndAddToPool(__out_ecount_full(1) char **ppString, UINT  dwOffset);
    HRESULT LoadAssignments( UINT Assignments, SAssignment **pAssignments, BYTE *pBackingStore, UINT *pRTVAssignments, UINT *pFinalAssignments );
    HRESULT LoadGroups();
    HRESULT LoadTechnique( STechnique* pTech );
    HRESULT LoadAnnotations(UINT  *pcAnnotations, SAnnotation **ppAnnotations);

    HRESULT ExecuteConstantAssignment(SBinaryConstant *pConstant, void *pLHS, D3D10_SHADER_VARIABLE_TYPE lhsType);
    UINT    UnpackData(BYTE *pDestData, BYTE *pSrcData, UINT  PackedDataSize, SType *pType, UINT  *pBytesRead);

    // Build shader blocks
    HRESULT ConvertRangesToBindings(SShaderBlock *pShaderBlock, CEffectVector<SRange> *pvRanges );
    HRESULT GrabShaderData(SShaderBlock *pShaderBlock);
    HRESULT BuildShaderBlock(SShaderBlock *pShaderBlock);

    // Memory compactors
    HRESULT InitializeReflectionDataAndMoveStrings( UINT KnownSize = 0 );
    HRESULT ReallocateReflectionData( bool Cloning = false );
    HRESULT ReallocateEffectData( bool Cloning = false );
    HRESULT ReallocateShaderBlocks();
    template<class T> HRESULT ReallocateBlockAssignments(T* &pBlocks, UINT  cBlocks, T* pOldBlocks = NULL);
    HRESULT ReallocateAnnotationData(UINT  cAnnotations, SAnnotation **ppAnnotations);

    HRESULT CalculateAnnotationSize(UINT  cAnnotations, SAnnotation *pAnnotations);
    UINT  CalculateShaderBlockSize();
    template<class T> UINT  CalculateBlockAssignmentSize(T* &pBlocks, UINT  cBlocks);

    HRESULT FixupCBPointer(SConstantBuffer **ppCB);
    HRESULT FixupShaderPointer(SShaderBlock **ppShaderBlock);
    HRESULT FixupDSPointer(SDepthStencilBlock **ppDSBlock);
    HRESULT FixupABPointer(SBlendBlock **ppABBlock);
    HRESULT FixupRSPointer(SRasterizerBlock **ppRSBlock);
    HRESULT FixupInterfacePointer(SInterface **ppInterface, bool CheckBackgroundInterfaces);
    HRESULT FixupShaderResourcePointer(SShaderResource **ppResource);
    HRESULT FixupUnorderedAccessViewPointer(SUnorderedAccessView **ppResource);
    HRESULT FixupRenderTargetViewPointer(SRenderTargetView **ppRenderTargetView);
    HRESULT FixupDepthStencilViewPointer(SDepthStencilView **ppDepthStencilView);
    HRESULT FixupSamplerPointer(SSamplerBlock **ppSampler);
    HRESULT FixupVariablePointer(SGlobalVariable **ppVar);
    HRESULT FixupStringPointer(SString **ppString);
    HRESULT FixupMemberDataPointer(SMemberDataPointer **ppMemberData);
    HRESULT FixupGroupPointer(SGroup **ppGroup);

    // Methods to retrieve data from the unstructured block
    // (these do not make copies; they simply return pointers into the block)
    HRESULT GetStringAndAddToReflection(UINT  offset, __out_ecount_full(1) char **ppPointer);  // Returns a string from the file string block, updates m_EffectMemory
    HRESULT GetUnstructuredDataBlock(UINT  offset, UINT  *pdwSize, void **ppData);
    // This function makes a copy of the array of SInterfaceParameters, but not a copy of the strings
    HRESULT GetInterfaceParametersAndAddToReflection( UINT InterfaceCount, UINT offset, __out_ecount_full(1) SShaderBlock::SInterfaceParameter **ppInterfaces );
public:

    HRESULT LoadEffect(CEffect *pEffect, CONST void *pEffectBuffer, UINT  cbEffectBuffer);
};


}
```

`Source Code/Effects11/EffectNonRuntime.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       EffectNonRuntime.cpp
//  Content:    D3DX11 Effect low-frequency utility functions
//              These functions are not intended to be called regularly.  They
//              are typically called when creating, cloning, or optimizing an 
//              Effect, or reflecting a variable.
//
//////////////////////////////////////////////////////////////////////////////

#include "pchfx.h"
#include "SOParser.h"

namespace D3DX11Effects
{

extern SUnorderedAccessView g_NullUnorderedAccessView;

SBaseBlock::SBaseBlock()
: BlockType(EBT_Invalid)
, IsUserManaged(FALSE)
, AssignmentCount(0)
, pAssignments(NULL)
{

}

SPassBlock::SPassBlock()
{
    pName = NULL;
    AnnotationCount = 0;
    pAnnotations = NULL;
    InitiallyValid = TRUE;
    HasDependencies = FALSE;
    ZeroMemory(&BackingStore, sizeof(BackingStore));
}

STechnique::STechnique()
: pName(NULL)
, PassCount(0)
, pPasses(NULL)
, AnnotationCount(0)
, pAnnotations(NULL)
, InitiallyValid( TRUE )
, HasDependencies( FALSE )
{
}

SGroup::SGroup()
: pName(NULL)
, TechniqueCount(0)
, pTechniques(NULL)
, AnnotationCount(0)
, pAnnotations(NULL)
, InitiallyValid( TRUE )
, HasDependencies( FALSE )
{
}

SDepthStencilBlock::SDepthStencilBlock()
{
    pDSObject = NULL;
    ZeroMemory(&BackingStore, sizeof(BackingStore));
    IsValid = TRUE;

    BackingStore.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
    BackingStore.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
    BackingStore.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
    BackingStore.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
    BackingStore.DepthEnable = TRUE;
    BackingStore.DepthFunc = D3D11_COMPARISON_LESS;
    BackingStore.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
    BackingStore.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
    BackingStore.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
    BackingStore.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
    BackingStore.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
    BackingStore.StencilEnable = FALSE;
    BackingStore.StencilReadMask = D3D11_DEFAULT_STENCIL_READ_MASK;
    BackingStore.StencilWriteMask = D3D11_DEFAULT_STENCIL_WRITE_MASK;
}

SBlendBlock::SBlendBlock()
{
    pBlendObject = NULL;
    ZeroMemory(&BackingStore, sizeof(BackingStore));
    IsValid = TRUE;

    BackingStore.AlphaToCoverageEnable = FALSE;
    BackingStore.IndependentBlendEnable = TRUE;
    for( UINT i=0; i < D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT; i++ )
    {
        BackingStore.RenderTarget[i].SrcBlend = D3D11_BLEND_ONE;
        BackingStore.RenderTarget[i].DestBlend = D3D11_BLEND_ZERO;
        BackingStore.RenderTarget[i].BlendOp = D3D11_BLEND_OP_ADD;
        BackingStore.RenderTarget[i].SrcBlendAlpha = D3D11_BLEND_ONE;
        BackingStore.RenderTarget[i].DestBlendAlpha = D3D11_BLEND_ZERO;
        BackingStore.RenderTarget[i].BlendOpAlpha = D3D11_BLEND_OP_ADD;
        memset(&BackingStore.RenderTarget[i].RenderTargetWriteMask, 0x0F, sizeof(BackingStore.RenderTarget[i].RenderTargetWriteMask));
    }
}

SRasterizerBlock::SRasterizerBlock()
{
    pRasterizerObject = NULL;
    ZeroMemory(&BackingStore, sizeof(BackingStore));
    IsValid = TRUE;

    BackingStore.AntialiasedLineEnable = FALSE;
    BackingStore.CullMode = D3D11_CULL_BACK;
    BackingStore.DepthBias = D3D11_DEFAULT_DEPTH_BIAS;
    BackingStore.DepthBiasClamp = D3D11_DEFAULT_DEPTH_BIAS_CLAMP;
    BackingStore.FillMode = D3D11_FILL_SOLID;
    BackingStore.FrontCounterClockwise = FALSE;
    BackingStore.MultisampleEnable = FALSE;
    BackingStore.ScissorEnable = FALSE;
    BackingStore.SlopeScaledDepthBias = D3D11_DEFAULT_SLOPE_SCALED_DEPTH_BIAS;
    BackingStore.DepthClipEnable = TRUE;
}

SSamplerBlock::SSamplerBlock()
{
    pD3DObject = NULL;
    ZeroMemory(&BackingStore, sizeof(BackingStore));

    BackingStore.SamplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
    BackingStore.SamplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
    BackingStore.SamplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
    BackingStore.SamplerDesc.BorderColor[3] = D3D11_DEFAULT_BORDER_COLOR_COMPONENT;
    BackingStore.SamplerDesc.BorderColor[2] = D3D11_DEFAULT_BORDER_COLOR_COMPONENT;
    BackingStore.SamplerDesc.BorderColor[1] = D3D11_DEFAULT_BORDER_COLOR_COMPONENT;
    BackingStore.SamplerDesc.BorderColor[0] = D3D11_DEFAULT_BORDER_COLOR_COMPONENT;
    BackingStore.SamplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
    BackingStore.SamplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
    BackingStore.SamplerDesc.MaxAnisotropy = (UINT32) D3D11_DEFAULT_MAX_ANISOTROPY;
    BackingStore.SamplerDesc.MipLODBias = D3D11_DEFAULT_MIP_LOD_BIAS;
    BackingStore.SamplerDesc.MinLOD = -FLT_MAX;
    BackingStore.SamplerDesc.MaxLOD = FLT_MAX;
}

SShaderBlock::SShaderBlock(SD3DShaderVTable *pVirtualTable)
{
    IsValid = TRUE;

    pVT = pVirtualTable;

    pReflectionData = NULL;
    
    pD3DObject = NULL;

    CBDepCount = 0;
    pCBDeps = NULL;

    SampDepCount = 0;
    pSampDeps = NULL;

    InterfaceDepCount = 0;
    pInterfaceDeps = NULL;

    ResourceDepCount = 0;
    pResourceDeps = NULL;

    UAVDepCount = 0;
    pUAVDeps = NULL;

    TBufferDepCount = 0;
    ppTbufDeps = NULL;

    pInputSignatureBlob = NULL;
}

HRESULT SShaderBlock::OnDeviceBind()
{
    HRESULT hr = S_OK;
    UINT  i, j;

    // Update all CB deps
    for (i=0; i<CBDepCount; i++)
    {
        D3DXASSERT(pCBDeps[i].Count);

        for (j=0; j<pCBDeps[i].Count; j++)
        {
            pCBDeps[i].ppD3DObjects[j] = pCBDeps[i].ppFXPointers[j]->pD3DObject;

            if ( !pCBDeps[i].ppD3DObjects[j] )
                VH( E_FAIL );
        }
    }

    // Update all sampler deps
    for (i=0; i<SampDepCount; i++)
    {
        D3DXASSERT(pSampDeps[i].Count);

        for (j=0; j<pSampDeps[i].Count; j++)
        {
            pSampDeps[i].ppD3DObjects[j] = pSampDeps[i].ppFXPointers[j]->pD3DObject;

            if ( !pSampDeps[i].ppD3DObjects[j] )
                VH( E_FAIL );
        }
    }

    // Texture deps will be set automatically on use since they are initially marked dirty.

lExit:
    return hr;
}

extern SD3DShaderVTable g_vtVS;
extern SD3DShaderVTable g_vtGS;
extern SD3DShaderVTable g_vtPS;
extern SD3DShaderVTable g_vtHS;
extern SD3DShaderVTable g_vtDS;
extern SD3DShaderVTable g_vtCS;

EObjectType SShaderBlock::GetShaderType()
{
    if (&g_vtVS == pVT)
        return EOT_VertexShader;
    else if (&g_vtGS == pVT)
        return EOT_GeometryShader;
    else if (&g_vtPS == pVT)
        return EOT_PixelShader;
    else if (&g_vtHS == pVT)
        return EOT_HullShader5;
    else if (&g_vtDS == pVT)
        return EOT_DomainShader5;
    else if (&g_vtCS == pVT)
        return EOT_ComputeShader5;
    
    return EOT_Invalid;
}

#define _SET_BIT(bytes, x) (bytes[x / 8] |= (1 << (x % 8)))

HRESULT SShaderBlock::ComputeStateBlockMask(D3DX11_STATE_BLOCK_MASK *pStateBlockMask)
{
    HRESULT hr = S_OK;
    UINT i, j;
    BYTE *pSamplerMask = NULL, *pShaderResourceMask = NULL, *pConstantBufferMask = NULL, *pUnorderedAccessViewMask = NULL, *pInterfaceMask = NULL;

    switch (GetShaderType())
    {
    case EOT_VertexShader:
    case EOT_VertexShader5:
        pStateBlockMask->VS = 1;
        pSamplerMask = pStateBlockMask->VSSamplers;
        pShaderResourceMask = pStateBlockMask->VSShaderResources;
        pConstantBufferMask = pStateBlockMask->VSConstantBuffers;
        pInterfaceMask = pStateBlockMask->VSInterfaces;
        pUnorderedAccessViewMask = NULL;
        break;

    case EOT_GeometryShader:
    case EOT_GeometryShader5:
        pStateBlockMask->GS = 1;
        pSamplerMask = pStateBlockMask->GSSamplers;
        pShaderResourceMask = pStateBlockMask->GSShaderResources;
        pConstantBufferMask = pStateBlockMask->GSConstantBuffers;
        pInterfaceMask = pStateBlockMask->GSInterfaces;
        pUnorderedAccessViewMask = NULL;
        break;

    case EOT_PixelShader:
    case EOT_PixelShader5:
        pStateBlockMask->PS = 1;
        pSamplerMask = pStateBlockMask->PSSamplers;
        pShaderResourceMask = pStateBlockMask->PSShaderResources;
        pConstantBufferMask = pStateBlockMask->PSConstantBuffers;
        pInterfaceMask = pStateBlockMask->PSInterfaces;
        pUnorderedAccessViewMask = &pStateBlockMask->PSUnorderedAccessViews;
        break;

    case EOT_HullShader5:
        pStateBlockMask->HS = 1;
        pSamplerMask = pStateBlockMask->HSSamplers;
        pShaderResourceMask = pStateBlockMask->HSShaderResources;
        pConstantBufferMask = pStateBlockMask->HSConstantBuffers;
        pInterfaceMask = pStateBlockMask->HSInterfaces;
        pUnorderedAccessViewMask = NULL;
        break;

    case EOT_DomainShader5:
        pStateBlockMask->DS = 1;
        pSamplerMask = pStateBlockMask->DSSamplers;
        pShaderResourceMask = pStateBlockMask->DSShaderResources;
        pConstantBufferMask = pStateBlockMask->DSConstantBuffers;
        pInterfaceMask = pStateBlockMask->DSInterfaces;
        pUnorderedAccessViewMask = NULL;
        break;

    case EOT_ComputeShader5:
        pStateBlockMask->CS = 1;
        pSamplerMask = pStateBlockMask->CSSamplers;
        pShaderResourceMask = pStateBlockMask->CSShaderResources;
        pConstantBufferMask = pStateBlockMask->CSConstantBuffers;
        pInterfaceMask = pStateBlockMask->CSInterfaces;
        pUnorderedAccessViewMask = &pStateBlockMask->CSUnorderedAccessViews;
        break;

    default:
        D3DXASSERT(0);
        VH(E_FAIL);
    }

    for (i = 0; i < SampDepCount; ++ i)
    {
        for (j = 0; j < pSampDeps[i].Count; ++ j)
        {
            _SET_BIT(pSamplerMask, (pSampDeps[i].StartIndex + j));
        }
    }

    for (i = 0; i < InterfaceDepCount; ++ i)
    {
        for (j = 0; j < pInterfaceDeps[i].Count; ++ j)
        {
            _SET_BIT(pInterfaceMask, (pInterfaceDeps[i].StartIndex + j));
        }
    }

    for (i = 0; i < ResourceDepCount; ++ i)
    {
        for (j = 0; j < pResourceDeps[i].Count; ++ j)
        {
            _SET_BIT(pShaderResourceMask, (pResourceDeps[i].StartIndex + j));
        }
    }

    for (i = 0; i < CBDepCount; ++ i)
    {
        for (j = 0; j < pCBDeps[i].Count; ++ j)
        {
            _SET_BIT(pConstantBufferMask, (pCBDeps[i].StartIndex + j));
        }
    }

    for (i = 0; i < UAVDepCount; ++ i)
    {
        D3DXASSERT( pUnorderedAccessViewMask != NULL );
        for (j = 0; j < pUAVDeps[i].Count; ++ j)
        {
            if( pUAVDeps[i].ppFXPointers[j] != &g_NullUnorderedAccessView )
                _SET_BIT(pUnorderedAccessViewMask, (pUAVDeps[i].StartIndex + j));
        }
    }

lExit:
    return hr;
}

#undef _SET_BIT

HRESULT SShaderBlock::GetShaderDesc(D3DX11_EFFECT_SHADER_DESC *pDesc, BOOL IsInline)
{
    HRESULT hr = S_OK;
    
    ZeroMemory(pDesc, sizeof(*pDesc));

    pDesc->pInputSignature = pInputSignatureBlob ? (const BYTE*)pInputSignatureBlob->GetBufferPointer() : NULL;
    pDesc->IsInline = IsInline;

    if (NULL != pReflectionData)
    {
        // initialize these only if present; otherwise leave them NULL or 0
        pDesc->pBytecode = pReflectionData->pBytecode;
        pDesc->BytecodeLength = pReflectionData->BytecodeLength;
        for( UINT iDecl=0; iDecl < D3D11_SO_STREAM_COUNT; ++iDecl )
        {
            pDesc->SODecls[iDecl] = pReflectionData->pStreamOutDecls[iDecl];
        }
        pDesc->RasterizedStream = pReflectionData->RasterizedStream;

        // get # of input & output signature entries
        D3DXASSERT( pReflectionData->pReflection != NULL );

        D3D11_SHADER_DESC ShaderDesc;
        pReflectionData->pReflection->GetDesc( &ShaderDesc );
        pDesc->NumInputSignatureEntries = ShaderDesc.InputParameters;
        pDesc->NumOutputSignatureEntries = ShaderDesc.OutputParameters;
        pDesc->NumPatchConstantSignatureEntries = ShaderDesc.PatchConstantParameters;
    }
lExit:
    return hr;
}

HRESULT SShaderBlock::GetVertexShader(ID3D11VertexShader **ppVS)
{
    if (EOT_VertexShader == GetShaderType() ||
        EOT_VertexShader5 == GetShaderType())
    {
        *ppVS = (ID3D11VertexShader *) pD3DObject;
        SAFE_ADDREF(*ppVS);
        return S_OK;
    }
    else
    {
        *ppVS = NULL;
        DPF(0, "ID3DX11EffectShaderVariable::GetVertexShader: This shader variable is not a vertex shader");
        return D3DERR_INVALIDCALL;
    }
}

HRESULT SShaderBlock::GetGeometryShader(ID3D11GeometryShader **ppGS)
{
    if (EOT_GeometryShader == GetShaderType() ||
        EOT_GeometryShaderSO == GetShaderType() ||
        EOT_GeometryShader5 == GetShaderType())
    {
        *ppGS = (ID3D11GeometryShader *) pD3DObject;
        SAFE_ADDREF(*ppGS);
        return S_OK;
    }
    else
    {
        *ppGS = NULL;
        DPF(0, "ID3DX11EffectShaderVariable::GetGeometryShader: This shader variable is not a geometry shader");
        return D3DERR_INVALIDCALL;
    }
}

HRESULT SShaderBlock::GetPixelShader(ID3D11PixelShader **ppPS)
{
    if (EOT_PixelShader == GetShaderType() ||
        EOT_PixelShader5 == GetShaderType())
    {
        *ppPS = (ID3D11PixelShader *) pD3DObject;
        SAFE_ADDREF(*ppPS);
        return S_OK;
    }
    else
    {
        *ppPS = NULL;
        DPF(0, "ID3DX11EffectShaderVariable::GetPixelShader: This shader variable is not a pixel shader");
        return D3DERR_INVALIDCALL;
    }
}

HRESULT SShaderBlock::GetHullShader(ID3D11HullShader **ppHS)
{
    if (EOT_HullShader5 == GetShaderType())
    {
        *ppHS = (ID3D11HullShader *) pD3DObject;
        SAFE_ADDREF(*ppHS);
        return S_OK;
    }
    else
    {
        *ppHS = NULL;
        DPF(0, "ID3DX11EffectShaderVariable::GetHullShader: This shader variable is not a hull shader");
        return D3DERR_INVALIDCALL;
    }
}

HRESULT SShaderBlock::GetDomainShader(ID3D11DomainShader **ppDS)
{
    if (EOT_DomainShader5 == GetShaderType())
    {
        *ppDS = (ID3D11DomainShader *) pD3DObject;
        SAFE_ADDREF(*ppDS);
        return S_OK;
    }
    else
    {
        *ppDS = NULL;
        DPF(0, "ID3DX11EffectShaderVariable::GetDomainShader: This shader variable is not a domain shader");
        return D3DERR_INVALIDCALL;
    }
}

HRESULT SShaderBlock::GetComputeShader(ID3D11ComputeShader **ppCS)
{
    if (EOT_ComputeShader5 == GetShaderType())
    {
        *ppCS = (ID3D11ComputeShader *) pD3DObject;
        SAFE_ADDREF(*ppCS);
        return S_OK;
    }
    else
    {
        *ppCS = NULL;
        DPF(0, "ID3DX11EffectShaderVariable::GetComputeShader: This shader variable is not a compute shader");
        return D3DERR_INVALIDCALL;
    }
}

HRESULT SShaderBlock::GetSignatureElementDesc(ESigType SigType, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName;
    switch( SigType )
    {
    case ST_Input:
#pragma prefast(suppress:__WARNING_UNUSED_POINTER_ASSIGNMENT, "pFuncName used in DPF")
        pFuncName = "ID3DX11EffectShaderVariable::GetInputSignatureElementDesc";
        break;
    case ST_Output:
#pragma prefast(suppress:__WARNING_UNUSED_POINTER_ASSIGNMENT, "pFuncName used in DPF")
        pFuncName = "ID3DX11EffectShaderVariable::GetOutputSignatureElementDesc";
        break;
    case ST_PatchConstant:
#pragma prefast(suppress:__WARNING_UNUSED_POINTER_ASSIGNMENT, "pFuncName used in DPF")
        pFuncName = "ID3DX11EffectShaderVariable::GetPatchConstantSignatureElementDesc";
        break;
    default:
        D3DXASSERT( false );
        return E_FAIL;
    };

    if (NULL != pReflectionData)
    {
        // get # of signature entries
        D3DXASSERT( pReflectionData->pReflection != NULL );

        D3D11_SHADER_DESC ShaderDesc;
        VH( pReflectionData->pReflection->GetDesc( &ShaderDesc ) );

        D3D11_SIGNATURE_PARAMETER_DESC ParamDesc;
        if( pReflectionData->IsNullGS )
        {
            switch( SigType )
            {
            case ST_Input:
                // The input signature for a null-GS is the output signature of the previous VS
                SigType = ST_Output;
                break;
            case ST_PatchConstant:
                // GeometryShaders cannot have patch constant signatures
                return E_INVALIDARG;
            };
        }

        switch( SigType )
        {
        case ST_Input:
            if( Element >= ShaderDesc.InputParameters )
            {
                DPF( 0, "%s: Invalid Element index (%d) specified", pFuncName, Element );
                VH( E_INVALIDARG );
            }
            VH( pReflectionData->pReflection->GetInputParameterDesc( Element, &ParamDesc ) );
            break;
        case ST_Output:
            if( Element >= ShaderDesc.OutputParameters )
            {
                DPF( 0, "%s: Invalid Element index (%d) specified", pFuncName, Element );
                VH( E_INVALIDARG );
            }
            VH( pReflectionData->pReflection->GetOutputParameterDesc( Element, &ParamDesc ) );
            break;
        case ST_PatchConstant:
            if( Element >= ShaderDesc.PatchConstantParameters )
            {
                DPF( 0, "%s: Invalid Element index (%d) specified", pFuncName, Element );
                VH( E_INVALIDARG );
            }
            VH( pReflectionData->pReflection->GetPatchConstantParameterDesc( Element, &ParamDesc ) );
            break;
        };

        pDesc->SemanticName = ParamDesc.SemanticName;
        pDesc->SystemValueType = ParamDesc.SystemValueType;

        // Pixel shaders need to be special-cased as they don't technically output SVs
        if( pDesc->SystemValueType == D3D10_NAME_UNDEFINED && GetShaderType() == EOT_PixelShader )
        {
            if( _stricmp(pDesc->SemanticName, "SV_TARGET") == 0 )
            {
                pDesc->SystemValueType = D3D10_NAME_TARGET;
            } 
            else if( _stricmp(pDesc->SemanticName, "SV_DEPTH") == 0 )
            {
                pDesc->SystemValueType = D3D10_NAME_DEPTH;
            } 
            else if( _stricmp(pDesc->SemanticName, "SV_COVERAGE") == 0 )
            {
                pDesc->SystemValueType = D3D10_NAME_COVERAGE;
            }
        }

        pDesc->SemanticIndex = ParamDesc.SemanticIndex;
        pDesc->Register = ParamDesc.Register;
        pDesc->Mask = ParamDesc.Mask;
        pDesc->ComponentType = ParamDesc.ComponentType;
        pDesc->ReadWriteMask = ParamDesc.ReadWriteMask;
    }
    else
    {
        DPF(0, "%s: Cannot get signatures; shader bytecode is not present", pFuncName);
        VH( D3DERR_INVALIDCALL );
    }
    
lExit:
    return hr;
}

SString::SString()
{
    pString = NULL;
}

SRenderTargetView::SRenderTargetView()
{
    pRenderTargetView = NULL;
}

SDepthStencilView::SDepthStencilView()
{
    pDepthStencilView = NULL;
}

void * GetBlockByIndex(EVarType VarType, EObjectType ObjectType, void *pBaseBlock, UINT  Index)
{
    switch( VarType )
    {
    case EVT_Interface:
        return (SInterface *)pBaseBlock + Index;
    case EVT_Object:
        switch (ObjectType)
        {
        case EOT_Blend:
            return (SBlendBlock *)pBaseBlock + Index;
        case EOT_DepthStencil:
            return (SDepthStencilBlock *)pBaseBlock + Index;
        case EOT_Rasterizer:
            return (SRasterizerBlock *)pBaseBlock + Index;
        case EOT_PixelShader:
        case EOT_PixelShader5:
        case EOT_GeometryShader:
        case EOT_GeometryShaderSO:
        case EOT_GeometryShader5:
        case EOT_VertexShader:
        case EOT_VertexShader5:
        case EOT_HullShader5:
        case EOT_DomainShader5:
        case EOT_ComputeShader5:
            return (SShaderBlock *)pBaseBlock + Index;
        case EOT_String:
            return (SString *)pBaseBlock + Index;
        case EOT_Sampler:
            return (SSamplerBlock *)pBaseBlock + Index;
        case EOT_Buffer:
        case EOT_Texture:
        case EOT_Texture1D:
        case EOT_Texture1DArray:
        case EOT_Texture2D:
        case EOT_Texture2DArray:
        case EOT_Texture2DMS:
        case EOT_Texture2DMSArray:
        case EOT_Texture3D:
        case EOT_TextureCube:
        case EOT_TextureCubeArray:
        case EOT_ByteAddressBuffer:
        case EOT_StructuredBuffer:
            return (SShaderResource *)pBaseBlock + Index;
        case EOT_DepthStencilView:
            return (SDepthStencilView *)pBaseBlock + Index;
        case EOT_RenderTargetView:
            return (SRenderTargetView *)pBaseBlock + Index;
        case EOT_RWTexture1D:
        case EOT_RWTexture1DArray:
        case EOT_RWTexture2D:
        case EOT_RWTexture2DArray:
        case EOT_RWTexture3D:
        case EOT_RWBuffer:
        case EOT_RWByteAddressBuffer:
        case EOT_RWStructuredBuffer:
        case EOT_RWStructuredBufferAlloc:
        case EOT_RWStructuredBufferConsume:
        case EOT_AppendStructuredBuffer:
        case EOT_ConsumeStructuredBuffer:    
            return (SUnorderedAccessView *)pBaseBlock + Index;
        default:
            D3DXASSERT(0);
            return NULL;
        }
    default:
        D3DXASSERT(0);
        return NULL;
    }
}

CEffect::CEffect( UINT Flags )
{
    m_RefCount = 1;

    m_pVariables = NULL;
    m_pAnonymousShaders = NULL;
    m_pGroups = NULL;
    m_pNullGroup = NULL;
    m_pShaderBlocks = NULL;
    m_pDepthStencilBlocks = NULL;
    m_pBlendBlocks = NULL;
    m_pRasterizerBlocks = NULL;
    m_pSamplerBlocks = NULL;
    m_pCBs = NULL;
    m_pStrings = NULL;
    m_pMemberDataBlocks = NULL;
    m_pInterfaces = NULL;
    m_pShaderResources = NULL;
    m_pUnorderedAccessViews = NULL;
    m_pRenderTargetViews = NULL;
    m_pDepthStencilViews = NULL;
    m_pDevice = NULL;
    m_pClassLinkage = NULL;
    m_pContext = NULL;

    m_VariableCount = 0;
    m_AnonymousShaderCount = 0;
    m_ShaderBlockCount = 0;
    m_DepthStencilBlockCount = 0;
    m_BlendBlockCount = 0;
    m_RasterizerBlockCount = 0;
    m_SamplerBlockCount = 0;
    m_StringCount = 0;
    m_MemberDataCount = 0;
    m_InterfaceCount = 0;
    m_ShaderResourceCount = 0;
    m_UnorderedAccessViewCount = 0;
    m_RenderTargetViewCount = 0;
    m_DepthStencilViewCount = 0;
    m_CBCount = 0;
    m_TechniqueCount = 0;
    m_GroupCount = 0;

    m_pReflection = NULL;
    m_LocalTimer = 1;
    m_Flags = Flags;
    m_FXLIndex = 0;

    m_pTypePool = NULL;
    m_pStringPool = NULL;
    m_pPooledHeap = NULL;
    m_pOptimizedTypeHeap = NULL;
}

void CEffect::ReleaseShaderRefection()
{
    for( UINT i = 0; i < m_ShaderBlockCount; ++ i )
    {
        SAFE_RELEASE( m_pShaderBlocks[i].pInputSignatureBlob );
        if( m_pShaderBlocks[i].pReflectionData )
        {
            SAFE_RELEASE( m_pShaderBlocks[i].pReflectionData->pReflection );
        }
    }
}

CEffect::~CEffect()
{
    ID3D11InfoQueue *pInfoQueue = NULL;

    // Mute debug spew
    if (m_pDevice)
        m_pDevice->QueryInterface(__uuidof(ID3D11InfoQueue), (void**) &pInfoQueue);

    if (pInfoQueue)
    {
        D3D11_INFO_QUEUE_FILTER filter;
        D3D11_MESSAGE_CATEGORY messageCategory = D3D11_MESSAGE_CATEGORY_STATE_SETTING;
        ZeroMemory(&filter, sizeof(filter));

        filter.DenyList.NumCategories = 1;
        filter.DenyList.pCategoryList = &messageCategory;
        pInfoQueue->PushStorageFilter(&filter);
    }

    UINT  i;

    if( NULL != m_pDevice )
    {
        // if m_pDevice == NULL, then we failed LoadEffect(), which means ReleaseShaderReflection was already called.

        // Release the shader reflection info, as it was not created on the private heap
        // This must be called before we delete m_pReflection
        ReleaseShaderRefection();
    }

    SAFE_DELETE( m_pReflection );
    SAFE_DELETE( m_pTypePool );
    SAFE_DELETE( m_pStringPool );
    SAFE_DELETE( m_pPooledHeap );
    SAFE_DELETE( m_pOptimizedTypeHeap );

    // this code assumes the effect has been loaded & relocated,
    // so check for that before freeing the resources

    if (NULL != m_pDevice)
    {
        // Keep the following in line with AddRefAllForCloning

        D3DXASSERT(NULL == m_pRasterizerBlocks || m_Heap.IsInHeap(m_pRasterizerBlocks));
        for (i = 0; i < m_RasterizerBlockCount; ++ i)
        {
            SAFE_RELEASE(m_pRasterizerBlocks[i].pRasterizerObject);
        }

        D3DXASSERT(NULL == m_pBlendBlocks || m_Heap.IsInHeap(m_pBlendBlocks));
        for (i = 0; i < m_BlendBlockCount; ++ i)
        {
            SAFE_RELEASE(m_pBlendBlocks[i].pBlendObject);
        }

        D3DXASSERT(NULL == m_pDepthStencilBlocks || m_Heap.IsInHeap(m_pDepthStencilBlocks));
        for (i = 0; i < m_DepthStencilBlockCount; ++ i)
        {
            SAFE_RELEASE(m_pDepthStencilBlocks[i].pDSObject);
        }

        D3DXASSERT(NULL == m_pSamplerBlocks || m_Heap.IsInHeap(m_pSamplerBlocks));
        for (i = 0; i < m_SamplerBlockCount; ++ i)
        {
            SAFE_RELEASE(m_pSamplerBlocks[i].pD3DObject);
        }

        D3DXASSERT(NULL == m_pShaderResources || m_Heap.IsInHeap(m_pShaderResources));
        for (i = 0; i < m_ShaderResourceCount; ++ i)
        {
            SAFE_RELEASE(m_pShaderResources[i].pShaderResource);
        }

        D3DXASSERT(NULL == m_pUnorderedAccessViews || m_Heap.IsInHeap(m_pUnorderedAccessViews));
        for (i = 0; i < m_UnorderedAccessViewCount; ++ i)
        {
            SAFE_RELEASE(m_pUnorderedAccessViews[i].pUnorderedAccessView);
        }

        D3DXASSERT(NULL == m_pRenderTargetViews || m_Heap.IsInHeap(m_pRenderTargetViews));
        for (i = 0; i < m_RenderTargetViewCount; ++ i)
        {
            SAFE_RELEASE(m_pRenderTargetViews[i].pRenderTargetView);
        }

        D3DXASSERT(NULL == m_pDepthStencilViews || m_Heap.IsInHeap(m_pDepthStencilViews));
        for (i = 0; i < m_DepthStencilViewCount; ++ i)
        {
            SAFE_RELEASE(m_pDepthStencilViews[i].pDepthStencilView);
        }

        D3DXASSERT(NULL == m_pMemberDataBlocks || m_Heap.IsInHeap(m_pMemberDataBlocks));
        for (i = 0; i < m_MemberDataCount; ++ i)
        {
            switch( m_pMemberDataBlocks[i].Type )
            {
            case MDT_ClassInstance:
                SAFE_RELEASE(m_pMemberDataBlocks[i].Data.pD3DClassInstance);
                break;
            case MDT_BlendState:
                SAFE_RELEASE(m_pMemberDataBlocks[i].Data.pD3DEffectsManagedBlendState);
                break;
            case MDT_DepthStencilState:
                SAFE_RELEASE(m_pMemberDataBlocks[i].Data.pD3DEffectsManagedDepthStencilState);
                break;
            case MDT_RasterizerState:
                SAFE_RELEASE(m_pMemberDataBlocks[i].Data.pD3DEffectsManagedRasterizerState);
                break;
            case MDT_SamplerState:
                SAFE_RELEASE(m_pMemberDataBlocks[i].Data.pD3DEffectsManagedSamplerState);
                break;
            case MDT_Buffer:
                SAFE_RELEASE(m_pMemberDataBlocks[i].Data.pD3DEffectsManagedConstantBuffer);
                break;
            case MDT_ShaderResourceView:
                SAFE_RELEASE(m_pMemberDataBlocks[i].Data.pD3DEffectsManagedTextureBuffer);
                break;
            default:
                D3DXASSERT( false );
            }
        }

        D3DXASSERT(NULL == m_pCBs || m_Heap.IsInHeap(m_pCBs));
        for (i = 0; i < m_CBCount; ++ i)
        {
            SAFE_RELEASE(m_pCBs[i].TBuffer.pShaderResource);
            SAFE_RELEASE(m_pCBs[i].pD3DObject);
        }

        D3DXASSERT(NULL == m_pShaderBlocks || m_Heap.IsInHeap(m_pShaderBlocks));
        for (i = 0; i < m_ShaderBlockCount; ++ i)
        {
            SAFE_RELEASE(m_pShaderBlocks[i].pD3DObject);
        }

        SAFE_RELEASE( m_pDevice );
    }
    SAFE_RELEASE( m_pClassLinkage );
    D3DXASSERT( m_pContext == NULL );

    // Restore debug spew
    if (pInfoQueue)
    {
        pInfoQueue->PopStorageFilter();
        SAFE_RELEASE(pInfoQueue);
    }
}

// AddRef all D3D object when cloning
void CEffect::AddRefAllForCloning( CEffect* pEffectSource )
{
    UINT  i;

    // Keep the following in line with ~CEffect

    D3DXASSERT( m_pDevice != NULL );

    for( UINT i = 0; i < m_ShaderBlockCount; ++ i )
    {
        SAFE_ADDREF( m_pShaderBlocks[i].pInputSignatureBlob );
        if( m_pShaderBlocks[i].pReflectionData )
        {
            SAFE_ADDREF( m_pShaderBlocks[i].pReflectionData->pReflection );
        }
    }

    D3DXASSERT(NULL == m_pRasterizerBlocks || pEffectSource->m_Heap.IsInHeap(m_pRasterizerBlocks));
    for (i = 0; i < m_RasterizerBlockCount; ++ i)
    {
        SAFE_ADDREF(m_pRasterizerBlocks[i].pRasterizerObject);
    }

    D3DXASSERT(NULL == m_pBlendBlocks || pEffectSource->m_Heap.IsInHeap(m_pBlendBlocks));
    for (i = 0; i < m_BlendBlockCount; ++ i)
    {
        SAFE_ADDREF(m_pBlendBlocks[i].pBlendObject);
    }

    D3DXASSERT(NULL == m_pDepthStencilBlocks || pEffectSource->m_Heap.IsInHeap(m_pDepthStencilBlocks));
    for (i = 0; i < m_DepthStencilBlockCount; ++ i)
    {
        SAFE_ADDREF(m_pDepthStencilBlocks[i].pDSObject);
    }

    D3DXASSERT(NULL == m_pSamplerBlocks || pEffectSource->m_Heap.IsInHeap(m_pSamplerBlocks));
    for (i = 0; i < m_SamplerBlockCount; ++ i)
    {
        SAFE_ADDREF(m_pSamplerBlocks[i].pD3DObject);
    }

    D3DXASSERT(NULL == m_pShaderResources || pEffectSource->m_Heap.IsInHeap(m_pShaderResources));
    for (i = 0; i < m_ShaderResourceCount; ++ i)
    {
        SAFE_ADDREF(m_pShaderResources[i].pShaderResource);
    }

    D3DXASSERT(NULL == m_pUnorderedAccessViews || pEffectSource->m_Heap.IsInHeap(m_pUnorderedAccessViews));
    for (i = 0; i < m_UnorderedAccessViewCount; ++ i)
    {
        SAFE_ADDREF(m_pUnorderedAccessViews[i].pUnorderedAccessView);
    }

    D3DXASSERT(NULL == m_pRenderTargetViews || pEffectSource->m_Heap.IsInHeap(m_pRenderTargetViews));
    for (i = 0; i < m_RenderTargetViewCount; ++ i)
    {
        SAFE_ADDREF(m_pRenderTargetViews[i].pRenderTargetView);
    }

    D3DXASSERT(NULL == m_pDepthStencilViews || pEffectSource->m_Heap.IsInHeap(m_pDepthStencilViews));
    for (i = 0; i < m_DepthStencilViewCount; ++ i)
    {
        SAFE_ADDREF(m_pDepthStencilViews[i].pDepthStencilView);
    }

    D3DXASSERT(NULL == m_pMemberDataBlocks || pEffectSource->m_Heap.IsInHeap(m_pMemberDataBlocks));
    for (i = 0; i < m_MemberDataCount; ++ i)
    {
        switch( m_pMemberDataBlocks[i].Type )
        {
        case MDT_ClassInstance:
            SAFE_ADDREF(m_pMemberDataBlocks[i].Data.pD3DClassInstance);
            break;
        case MDT_BlendState:
            SAFE_ADDREF(m_pMemberDataBlocks[i].Data.pD3DEffectsManagedBlendState);
            break;
        case MDT_DepthStencilState:
            SAFE_ADDREF(m_pMemberDataBlocks[i].Data.pD3DEffectsManagedDepthStencilState);
            break;
        case MDT_RasterizerState:
            SAFE_ADDREF(m_pMemberDataBlocks[i].Data.pD3DEffectsManagedRasterizerState);
            break;
        case MDT_SamplerState:
            SAFE_ADDREF(m_pMemberDataBlocks[i].Data.pD3DEffectsManagedSamplerState);
            break;
        case MDT_Buffer:
            SAFE_ADDREF(m_pMemberDataBlocks[i].Data.pD3DEffectsManagedConstantBuffer);
            break;
        case MDT_ShaderResourceView:
            SAFE_ADDREF(m_pMemberDataBlocks[i].Data.pD3DEffectsManagedTextureBuffer);
            break;
        default:
            D3DXASSERT( false );
        }
    }

    // There's no need to AddRef CBs, since they are recreated
    D3DXASSERT(NULL == m_pCBs || pEffectSource->m_Heap.IsInHeap(m_pCBs));
    for (i = 0; i < m_CBCount; ++ i)
    {
        SAFE_ADDREF(m_pCBs[i].TBuffer.pShaderResource);
        SAFE_ADDREF(m_pCBs[i].pD3DObject);
    }

    D3DXASSERT(NULL == m_pShaderBlocks || pEffectSource->m_Heap.IsInHeap(m_pShaderBlocks));
    for (i = 0; i < m_ShaderBlockCount; ++ i)
    {
        SAFE_ADDREF(m_pShaderBlocks[i].pD3DObject);
    }

    SAFE_ADDREF( m_pDevice );

    SAFE_ADDREF( m_pClassLinkage );
    D3DXASSERT( m_pContext == NULL );
}

HRESULT CEffect::QueryInterface(REFIID iid, LPVOID *ppv)
{
    HRESULT hr = S_OK;

    if(NULL == ppv)
    {
        DPF(0, "ID3DX11Effect::QueryInterface: NULL parameter");
        hr = E_INVALIDARG;
        goto EXIT;
    }

    *ppv = NULL;
    if(IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IUnknown *) this;
    }
    else if(IsEqualIID(iid, IID_ID3DX11Effect))
    {
        *ppv = (ID3DX11Effect *) this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();

EXIT:
    return hr;
}

ULONG CEffect::AddRef()
{
    return ++ m_RefCount;
}

ULONG CEffect::Release()
{
    if (-- m_RefCount > 0)
    {
        return m_RefCount;
    }
    else
    {
        delete this;
    }

    return 0;
}

// In all shaders, replace pOldBufferBlock with pNewBuffer, if pOldBufferBlock is a dependency
void CEffect::ReplaceCBReference(SConstantBuffer *pOldBufferBlock, ID3D11Buffer *pNewBuffer)
{
    UINT iShaderBlock;

    for (iShaderBlock=0; iShaderBlock<m_ShaderBlockCount; iShaderBlock++)
    {
        for (UINT iCBDep = 0; iCBDep < m_pShaderBlocks[iShaderBlock].CBDepCount; iCBDep++)
        {
            for (UINT iCB = 0; iCB < m_pShaderBlocks[iShaderBlock].pCBDeps[iCBDep].Count; iCB++)
            {
                if (m_pShaderBlocks[iShaderBlock].pCBDeps[iCBDep].ppFXPointers[iCB] == pOldBufferBlock)
                    m_pShaderBlocks[iShaderBlock].pCBDeps[iCBDep].ppD3DObjects[iCB] = pNewBuffer;
            }
        }
    }
}

// In all shaders, replace pOldSamplerBlock with pNewSampler, if pOldSamplerBlock is a dependency
void CEffect::ReplaceSamplerReference(SSamplerBlock *pOldSamplerBlock, ID3D11SamplerState *pNewSampler)
{
    UINT iShaderBlock;

    for (iShaderBlock=0; iShaderBlock<m_ShaderBlockCount; iShaderBlock++)
    {
        for (UINT iSamplerDep = 0; iSamplerDep < m_pShaderBlocks[iShaderBlock].SampDepCount; iSamplerDep++)
        {
            for (UINT iSampler = 0; iSampler < m_pShaderBlocks[iShaderBlock].pSampDeps[iSamplerDep].Count; iSampler++)
            {
                if (m_pShaderBlocks[iShaderBlock].pSampDeps[iSamplerDep].ppFXPointers[iSampler] == pOldSamplerBlock)
                    m_pShaderBlocks[iShaderBlock].pSampDeps[iSamplerDep].ppD3DObjects[iSampler] = pNewSampler;
            }
        }
    }
}

// Call BindToDevice after the effect has been fully loaded.
// BindToDevice will release all D3D11 objects and create new ones on the new device
HRESULT CEffect::BindToDevice(ID3D11Device *pDevice)
{
    HRESULT hr = S_OK;

    // Set new device
    if (pDevice == NULL)
    {
        DPF(0, "ID3DX11Effect: pDevice must point to a valid D3D11 device");
        return D3DERR_INVALIDCALL;
    }

    if (m_pDevice != NULL)
    {
        DPF(0, "ID3DX11Effect: Internal error, rebinding effects to a new device is not supported");
        return D3DERR_INVALIDCALL;
    }

    bool featureLevelGE11 = ( pDevice->GetFeatureLevel() >= D3D_FEATURE_LEVEL_11_0 );

    pDevice->AddRef();
    SAFE_RELEASE(m_pDevice);
    m_pDevice = pDevice;
    VH( m_pDevice->CreateClassLinkage( &m_pClassLinkage ) );

    // Create all constant buffers
    SConstantBuffer *pCB = m_pCBs;
    SConstantBuffer *pCBLast = m_pCBs + m_CBCount;
    for(; pCB != pCBLast; pCB++)
    {
        SAFE_RELEASE(pCB->pD3DObject);
        SAFE_RELEASE(pCB->TBuffer.pShaderResource);

        // This is a CBuffer
        if (pCB->Size > 0)
        {
            if (pCB->IsTBuffer)
            {
                D3D11_BUFFER_DESC bufDesc;
                // size is always register aligned
                bufDesc.ByteWidth = pCB->Size;
                bufDesc.Usage = D3D11_USAGE_DEFAULT;
                bufDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
                bufDesc.CPUAccessFlags = 0;
                bufDesc.MiscFlags = 0;

                VH( pDevice->CreateBuffer( &bufDesc, NULL, &pCB->pD3DObject) );
                
                D3D11_SHADER_RESOURCE_VIEW_DESC viewDesc;
                viewDesc.Format = DXGI_FORMAT_R32G32B32A32_UINT;
                viewDesc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
                viewDesc.Buffer.ElementOffset = 0;
                viewDesc.Buffer.ElementWidth = pCB->Size / SType::c_RegisterSize;

                VH( pDevice->CreateShaderResourceView( pCB->pD3DObject, &viewDesc, &pCB->TBuffer.pShaderResource) );
            }
            else
            {
                D3D11_BUFFER_DESC bufDesc;
                // size is always register aligned
                bufDesc.ByteWidth = pCB->Size;
                bufDesc.Usage = D3D11_USAGE_DEFAULT;
                bufDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
                bufDesc.CPUAccessFlags = 0;
                bufDesc.MiscFlags = 0;

                VH( pDevice->CreateBuffer( &bufDesc, NULL, &pCB->pD3DObject) );
                pCB->TBuffer.pShaderResource = NULL;
            }

            pCB->IsDirty = TRUE;
        }
        else
        {
            pCB->IsDirty = FALSE;
        }
    }

    // Create all RasterizerStates
    SRasterizerBlock *pRB = m_pRasterizerBlocks;
    SRasterizerBlock *pRBLast = m_pRasterizerBlocks + m_RasterizerBlockCount;
    for(; pRB != pRBLast; pRB++)
    {
        SAFE_RELEASE(pRB->pRasterizerObject);
        if( SUCCEEDED( m_pDevice->CreateRasterizerState( &pRB->BackingStore, &pRB->pRasterizerObject) ) )
            pRB->IsValid = TRUE;
        else
            pRB->IsValid = FALSE;
    }

    // Create all DepthStencils
    SDepthStencilBlock *pDS = m_pDepthStencilBlocks;
    SDepthStencilBlock *pDSLast = m_pDepthStencilBlocks + m_DepthStencilBlockCount;
    for(; pDS != pDSLast; pDS++)
    {
        SAFE_RELEASE(pDS->pDSObject);
        if( SUCCEEDED( m_pDevice->CreateDepthStencilState( &pDS->BackingStore, &pDS->pDSObject) ) )
            pDS->IsValid = TRUE;
        else
            pDS->IsValid = FALSE;
    }

    // Create all BlendStates
    SBlendBlock *pBlend = m_pBlendBlocks;
    SBlendBlock *pBlendLast = m_pBlendBlocks + m_BlendBlockCount;
    for(; pBlend != pBlendLast; pBlend++)
    {
        SAFE_RELEASE(pBlend->pBlendObject);
        if( SUCCEEDED( m_pDevice->CreateBlendState( &pBlend->BackingStore, &pBlend->pBlendObject ) ) )
            pBlend->IsValid = TRUE;
        else
            pBlend->IsValid = FALSE;
    }

    // Create all Samplers
    SSamplerBlock *pSampler = m_pSamplerBlocks;
    SSamplerBlock *pSamplerLast = m_pSamplerBlocks + m_SamplerBlockCount;
    for(; pSampler != pSamplerLast; pSampler++)
    {
        SAFE_RELEASE(pSampler->pD3DObject);

        VH( m_pDevice->CreateSamplerState( &pSampler->BackingStore.SamplerDesc, &pSampler->pD3DObject) );
    }

    // Create all shaders
    ID3D11ClassLinkage* neededClassLinkage = featureLevelGE11 ? m_pClassLinkage : NULL;
    SShaderBlock *pShader = m_pShaderBlocks;
    SShaderBlock *pShaderLast = m_pShaderBlocks + m_ShaderBlockCount;
    for(; pShader != pShaderLast; pShader++)
    {
        SAFE_RELEASE(pShader->pD3DObject);

        if (NULL == pShader->pReflectionData)
        {
            // NULL shader. It's one of these:
            // PixelShader ps;
            // or
            // SetPixelShader( NULL );
            continue;
        }
        
        if (pShader->pReflectionData->pStreamOutDecls[0] || pShader->pReflectionData->pStreamOutDecls[1] || 
            pShader->pReflectionData->pStreamOutDecls[2] || pShader->pReflectionData->pStreamOutDecls[3] )
        {
            // This is a geometry shader, process it's data
            CSOParser soParser;
            VH( soParser.Parse(pShader->pReflectionData->pStreamOutDecls) );
            UINT strides[4];
            soParser.GetStrides( strides );
            hr = m_pDevice->CreateGeometryShaderWithStreamOutput((UINT*) pShader->pReflectionData->pBytecode,
                                                                pShader->pReflectionData->BytecodeLength,
                                                                soParser.GetDeclArray(),
                                                                soParser.GetDeclCount(),
                                                                strides,
                                                                featureLevelGE11 ? 4 : 1,
                                                                pShader->pReflectionData->RasterizedStream,
                                                                neededClassLinkage,
                                                                (ID3D11GeometryShader**) &pShader->pD3DObject);
            if (FAILED(hr))
            {
                DPF(1, "ID3DX11Effect::Load - failed to create GeometryShader with StreamOutput decl: \"%s\"", soParser.GetErrorString() );
                pShader->IsValid = FALSE;
                hr = S_OK;
            }
        }
        else
        {
            // This is a regular shader
            if( pShader->pReflectionData->RasterizedStream == D3D11_SO_NO_RASTERIZED_STREAM )
                pShader->IsValid = FALSE;
            else 
            {
                if( FAILED( (m_pDevice->*(pShader->pVT->pCreateShader))( (UINT *) pShader->pReflectionData->pBytecode, pShader->pReflectionData->BytecodeLength, neededClassLinkage, &pShader->pD3DObject) ) )
                {
                    DPF(1, "ID3DX11Effect::Load - failed to create shader" );
                    pShader->IsValid = FALSE;
                }
            }
        }

        // Update all dependency pointers
        VH( pShader->OnDeviceBind() );
    }

    // Initialize the member data pointers for all variables
    UINT CurMemberData = 0;
    for (UINT i = 0; i < m_VariableCount; ++ i)
    {
        if( m_pVariables[i].pMemberData )
        {
            if( m_pVariables[i].pType->IsClassInstance() )
            {
                for (UINT j = 0; j < max(m_pVariables[i].pType->Elements,1); ++j)
                {
                    D3DXASSERT( CurMemberData < m_MemberDataCount );
                    ID3D11ClassInstance** ppCI = &(m_pVariables[i].pMemberData + j)->Data.pD3DClassInstance;
                    (m_pVariables[i].pMemberData + j)->Type = MDT_ClassInstance;
                    (m_pVariables[i].pMemberData + j)->Data.pD3DClassInstance = NULL;
                    if( m_pVariables[i].pType->TotalSize > 0 )
                    {
                        // ignore failures in GetClassInstance;
                        m_pClassLinkage->GetClassInstance( m_pVariables[i].pName, j, ppCI );
                    }
                    else
                    {
                        // The HLSL compiler optimizes out zero-sized classes, so we have to create class instances from scratch
                        if( FAILED( m_pClassLinkage->CreateClassInstance( m_pVariables[i].pType->pTypeName, 0, 0, 0, 0, ppCI ) ) )
                        {
                            DPF(0, "ID3DX11Effect: Out of memory while trying to create new class instance interface");
                        }
                    }
                    CurMemberData++;
                }
            }
            else if( m_pVariables[i].pType->IsStateBlockObject() )
            {
                for (UINT j = 0; j < max(m_pVariables[i].pType->Elements,1); ++j)
                {
                    switch( m_pVariables[i].pType->ObjectType )
                    {
                    case EOT_Blend:
                        (m_pVariables[i].pMemberData + j)->Type = MDT_BlendState;
                        (m_pVariables[i].pMemberData + j)->Data.pD3DEffectsManagedBlendState = NULL;
                        break;
                    case EOT_Rasterizer:
                        (m_pVariables[i].pMemberData + j)->Type = MDT_RasterizerState;
                        (m_pVariables[i].pMemberData + j)->Data.pD3DEffectsManagedRasterizerState = NULL;
                        break;
                    case EOT_DepthStencil:
                        (m_pVariables[i].pMemberData + j)->Type = MDT_DepthStencilState;
                        (m_pVariables[i].pMemberData + j)->Data.pD3DEffectsManagedDepthStencilState = NULL;
                        break;
                    case EOT_Sampler:
                        (m_pVariables[i].pMemberData + j)->Type = MDT_SamplerState;
                        (m_pVariables[i].pMemberData + j)->Data.pD3DEffectsManagedSamplerState = NULL;
                        break;
                    default:
                        VB( FALSE );
                    }
                    CurMemberData++;
                }
            }
            else
            {
                VB( FALSE );
            }
        }
    }
    for(pCB = m_pCBs; pCB != pCBLast; pCB++)
    {
        (pCB->pMemberData + 0)->Type = MDT_Buffer;
        (pCB->pMemberData + 0)->Data.pD3DEffectsManagedConstantBuffer = NULL;
        CurMemberData++;
        (pCB->pMemberData + 1)->Type = MDT_ShaderResourceView;
        (pCB->pMemberData + 1)->Data.pD3DEffectsManagedTextureBuffer = NULL;
        CurMemberData++;
    }


    // Determine which techniques and passes are known to be invalid
    for( UINT iGroup=0; iGroup < m_GroupCount; iGroup++ )
    {
        SGroup* pGroup = &m_pGroups[iGroup];
        pGroup->InitiallyValid = TRUE;

        for( UINT iTech=0; iTech < pGroup->TechniqueCount; iTech++ )
        {
            STechnique* pTechnique = &pGroup->pTechniques[iTech];
            pTechnique->InitiallyValid = TRUE;
           
            for( UINT iPass = 0; iPass < pTechnique->PassCount; iPass++ )
            {
                SPassBlock* pPass = &pTechnique->pPasses[iPass];
                pPass->InitiallyValid = TRUE;

                if( pPass->BackingStore.pBlendBlock != NULL && !pPass->BackingStore.pBlendBlock->IsValid )
                    pPass->InitiallyValid = FALSE;
                if( pPass->BackingStore.pDepthStencilBlock != NULL && !pPass->BackingStore.pDepthStencilBlock->IsValid )
                    pPass->InitiallyValid = FALSE;
                if( pPass->BackingStore.pRasterizerBlock != NULL && !pPass->BackingStore.pRasterizerBlock->IsValid )
                    pPass->InitiallyValid = FALSE;
                if( pPass->BackingStore.pVertexShaderBlock != NULL && !pPass->BackingStore.pVertexShaderBlock->IsValid )
                    pPass->InitiallyValid = FALSE;
                if( pPass->BackingStore.pPixelShaderBlock != NULL && !pPass->BackingStore.pPixelShaderBlock->IsValid )
                    pPass->InitiallyValid = FALSE;
                if( pPass->BackingStore.pGeometryShaderBlock != NULL && !pPass->BackingStore.pGeometryShaderBlock->IsValid )
                    pPass->InitiallyValid = FALSE;
                if( pPass->BackingStore.pHullShaderBlock != NULL && !pPass->BackingStore.pHullShaderBlock->IsValid )
                    pPass->InitiallyValid = FALSE;
                if( pPass->BackingStore.pDomainShaderBlock != NULL && !pPass->BackingStore.pDomainShaderBlock->IsValid )
                    pPass->InitiallyValid = FALSE;
                if( pPass->BackingStore.pComputeShaderBlock != NULL && !pPass->BackingStore.pComputeShaderBlock->IsValid )
                    pPass->InitiallyValid = FALSE;

                pTechnique->InitiallyValid &= pPass->InitiallyValid;
            }
            pGroup->InitiallyValid &= pTechnique->InitiallyValid;
        }
    }

lExit:
    return hr;
}

// FindVariableByName, plus an understanding of literal indices
// This code handles A[i].
// It does not handle anything else, like A.B, A[B[i]], A[B]
SVariable * CEffect::FindVariableByNameWithParsing(LPCSTR pName)
{
    SGlobalVariable *pVariable;
    const UINT MAX_PARSABLE_NAME_LENGTH = 256;
    char pScratchString[MAX_PARSABLE_NAME_LENGTH];

    const char* pSource = pName;
    char* pDest = pScratchString;
    char* pEnd = pScratchString + MAX_PARSABLE_NAME_LENGTH;

    pVariable = NULL;

    while( *pSource != 0 )
    {
        if( pDest == pEnd )
        {
            pVariable = FindLocalVariableByName(pName);
            if( pVariable == NULL )
            {
                DPF( 0, "Name %s is too long to parse", &pName );
            }
            return pVariable;
        }

        if( *pSource == '[' )
        {
            // parse previous variable name
            *pDest = 0;
            D3DXASSERT( pVariable == NULL );
            pVariable = FindLocalVariableByName(pScratchString);
            if( pVariable == NULL )
            {
                return NULL;
            }
            pDest = pScratchString;
        }
        else if( *pSource == ']' )
        {
            // parse integer
            *pDest = 0;
            UINT index = atoi(pScratchString);
            D3DXASSERT( pVariable != NULL );
            pVariable = (SGlobalVariable*)pVariable->GetElement(index);
            if( pVariable && !pVariable->IsValid() )
            {
                pVariable = NULL;
            }
            return pVariable;
        }
        else
        {
            // add character
            *pDest = *pSource;
            pDest++;
        }
        pSource++;
    }

    if( pDest != pScratchString )
    {
        // parse the variable name (there was no [i])
        *pDest = 0;
        D3DXASSERT( pVariable == NULL );
        pVariable = FindLocalVariableByName(pScratchString);
    }

    return pVariable;
}

SGlobalVariable * CEffect::FindVariableByName(LPCSTR pName)
{
    SGlobalVariable *pVariable;

    pVariable = FindLocalVariableByName(pName);

    return pVariable;
}

SGlobalVariable * CEffect::FindLocalVariableByName(LPCSTR pName)
{
    SGlobalVariable *pVariable, *pVariableEnd;

    pVariableEnd = m_pVariables + m_VariableCount;
    for (pVariable = m_pVariables; pVariable != pVariableEnd; pVariable++)
    {
        if (strcmp( pVariable->pName, pName) == 0)
        {
            return pVariable;
        }
    }

    return NULL;
}


//
// Checks to see if two types are equivalent (either at runtime
// or during the type-pooling load process)
//
// Major assumption: if both types are structures, then their
// member types & names should already have been added to the pool,
// in which case their member type & name pointers should be equal.
//
// This is true because complex data types (structures) have all
// sub-types translated before the containing type is translated,
// which means that simple sub-types (numeric types) have already
// been pooled.
//
BOOL SType::IsEqual(SType *pOtherType) CONST
{
    if (VarType != pOtherType->VarType || Elements != pOtherType->Elements
        || strcmp(pTypeName, pOtherType->pTypeName) != 0)
    {
        return FALSE;
    }

    switch (VarType)
    {
    case EVT_Struct:
        {
            if (StructType.Members != pOtherType->StructType.Members)
            {
                return FALSE;
            }
            D3DXASSERT(StructType.pMembers != NULL && pOtherType->StructType.pMembers != NULL);

            UINT  i;
            for (i = 0; i < StructType.Members; ++ i)
            {
                // names for types must exist (not true for semantics)
                D3DXASSERT(StructType.pMembers[i].pName != NULL && pOtherType->StructType.pMembers[i].pName != NULL);

                if (StructType.pMembers[i].pType != pOtherType->StructType.pMembers[i].pType ||
                    StructType.pMembers[i].Data.Offset != pOtherType->StructType.pMembers[i].Data.Offset ||
                    StructType.pMembers[i].pName != pOtherType->StructType.pMembers[i].pName ||
                    StructType.pMembers[i].pSemantic != pOtherType->StructType.pMembers[i].pSemantic)
                {
                    return FALSE;
                }
            }
        }
        break;

    case EVT_Object:
        {
            if (ObjectType != pOtherType->ObjectType)
            {
                return FALSE;
            }
        }
        break;

    case EVT_Numeric:
        {
            if (NumericType.Rows != pOtherType->NumericType.Rows ||
                NumericType.Columns != pOtherType->NumericType.Columns ||
                NumericType.ScalarType != pOtherType->NumericType.ScalarType ||
                NumericType.NumericLayout != pOtherType->NumericType.NumericLayout ||
                NumericType.IsColumnMajor != pOtherType->NumericType.IsColumnMajor ||
                NumericType.IsPackedArray != pOtherType->NumericType.IsPackedArray)
            {
                return FALSE;
            }
        }
        break;

    case EVT_Interface:
        {
            // VarType and pTypeName handled above
        }
        break;

    default:
        {
            D3DXASSERT(0);
            return FALSE;
        }
        break;
    }

    D3DXASSERT(TotalSize == pOtherType->TotalSize && Stride == pOtherType->Stride && PackedSize == pOtherType->PackedSize);

    return TRUE;
}

UINT SType::GetTotalUnpackedSize(BOOL IsSingleElement) CONST
{
    if (VarType == EVT_Object)
    {
        return 0;
    }
    else if (VarType == EVT_Interface)
    {
        return 0;
    }
    else if (Elements > 0 && IsSingleElement)
    {
        D3DXASSERT( ( TotalSize == 0 && Stride == 0 ) ||
                    ( (TotalSize > (Stride * (Elements - 1))) && (TotalSize <= (Stride * Elements)) ) );
        return TotalSize - Stride * (Elements - 1);
    }
    else
    {
        return TotalSize;
    }
}

UINT SType::GetTotalPackedSize(BOOL IsSingleElement) CONST
{
    if (Elements > 0 && IsSingleElement)
    {
        D3DXASSERT(PackedSize % Elements == 0);
        return PackedSize / Elements;
    }
    else
    {
        return PackedSize;
    }
}

SConstantBuffer *CEffect::FindCB(LPCSTR pName)
{
    UINT  i;

    for (i=0; i<m_CBCount; i++)
    {
        if (!strcmp(m_pCBs[i].pName, pName))
        {
            return &m_pCBs[i];
        }
    }

    return NULL;
}

inline UINT  PtrToDword(void *pPtr)
{
    return (UINT)(UINT_PTR) pPtr;
}

BOOL CEffect::IsOptimized()
{
    if ((m_Flags & D3DX11_EFFECT_OPTIMIZED) != 0)
    {
        D3DXASSERT(NULL == m_pReflection);
        return TRUE;
    }
    else
    {
        D3DXASSERT(NULL != m_pReflection);
        return FALSE;
    }
}

// Replace *ppType with the corresponding value in pMappingTable
// pMappingTable table describes how to map old type pointers to new type pointers
static HRESULT RemapType(SType **ppType, CPointerMappingTable *pMappingTable)
{
    HRESULT hr = S_OK;

    SPointerMapping ptrMapping;
    CPointerMappingTable::CIterator iter;
    ptrMapping.pOld = *ppType;
    VH( pMappingTable->FindValueWithHash(ptrMapping, ptrMapping.Hash(), &iter) );
    *ppType = (SType *) iter.GetData().pNew;

lExit:
    return hr;
}

// Replace *ppString with the corresponding value in pMappingTable
// pMappingTable table describes how to map old string pointers to new string pointers
static HRESULT RemapString(__in char **ppString, CPointerMappingTable *pMappingTable)
{
    HRESULT hr = S_OK;

    SPointerMapping ptrMapping;
    CPointerMappingTable::CIterator iter;
    ptrMapping.pOld = *ppString;
    VH( pMappingTable->FindValueWithHash(ptrMapping, ptrMapping.Hash(), &iter) );
    *ppString = (char *) iter.GetData().pNew;

lExit:
    return hr;
}

// Used in cloning, copy m_pMemberInterfaces from pEffectSource to this
HRESULT CEffect::CopyMemberInterfaces( CEffect* pEffectSource )
{
    HRESULT hr = S_OK;
    UINT i; // after a failure, this holds the failing index

    UINT Members = pEffectSource->m_pMemberInterfaces.GetSize();
    m_pMemberInterfaces.AddRange(Members);
    for( i=0; i < Members; i++ )
    {
        SMember* pOldMember = pEffectSource->m_pMemberInterfaces[i];
        if( pOldMember == NULL )
        {
            // During Optimization, m_pMemberInterfaces[i] was set to NULL because it was an annotation
            m_pMemberInterfaces[i] = NULL;
            continue;
        }

        SMember *pNewMember;
        D3DXASSERT( pOldMember->pTopLevelEntity != NULL );

        if (NULL == (pNewMember = CreateNewMember((SType*)pOldMember->pType, FALSE)))
        {
            DPF(0, "ID3DX11Effect: Out of memory while trying to create new member variable interface");
            VN( pNewMember );
        }

        pNewMember->pType = pOldMember->pType;
        pNewMember->pName = pOldMember->pName;
        pNewMember->pSemantic = pOldMember->pSemantic;
        pNewMember->Data.pGeneric = pOldMember->Data.pGeneric;
        pNewMember->IsSingleElement = pOldMember->IsSingleElement;
        pNewMember->pTopLevelEntity = pOldMember->pTopLevelEntity;
        pNewMember->pMemberData = pOldMember->pMemberData;

        m_pMemberInterfaces[i] = pNewMember;
    }

lExit:
    if( FAILED(hr) )
    {
        D3DXASSERT( i < Members );
        ZeroMemory( &m_pMemberInterfaces[i], sizeof(SMember) * ( Members - i ) );
    }
    return hr;
}

// Used in cloning, copy the string pool from pEffectSource to this and build mappingTable
// for use in RemapString
HRESULT CEffect::CopyStringPool( CEffect* pEffectSource, CPointerMappingTable& mappingTable )
{
    HRESULT hr = S_OK;
    D3DXASSERT( m_pPooledHeap != NULL );
    VN( m_pStringPool = NEW CEffect::CStringHashTable );
    m_pStringPool->SetPrivateHeap(m_pPooledHeap);
    VH( m_pStringPool->AutoGrow() );

    CStringHashTable::CIterator stringIter;

    // move strings over, build mapping table
    for (pEffectSource->m_pStringPool->GetFirstEntry(&stringIter); !pEffectSource->m_pStringPool->PastEnd(&stringIter); pEffectSource->m_pStringPool->GetNextEntry(&stringIter))
    {
        SPointerMapping ptrMapping;
        char *pString;

        const char* pOldString = stringIter.GetData();
        ptrMapping.pOld = (void*)pOldString;
        UINT len = (UINT)strlen(pOldString);
        UINT hash = ptrMapping.Hash();
        VN( pString = new(*m_pPooledHeap) char[len + 1] );
        ptrMapping.pNew = (void*)pString;
        memcpy(ptrMapping.pNew, ptrMapping.pOld, len + 1);
        VH( m_pStringPool->AddValueWithHash(pString, hash) );

        VH( mappingTable.AddValueWithHash(ptrMapping, hash) );
    }

    // Uncomment to print string mapping
    /*
    CPointerMappingTable::CIterator mapIter;
    for (mappingTable.GetFirstEntry(&mapIter); !mappingTable.PastEnd(&mapIter); mappingTable.GetNextEntry(&mapIter))
    {
    SPointerMapping ptrMapping = mapIter.GetData();
    DPF(0, "string: 0x%x : 0x%x  %s", (UINT_PTR)ptrMapping.pOld, (UINT_PTR)ptrMapping.pNew, (char*)ptrMapping.pNew );
    }*/

lExit:
    return hr;
}

// Used in cloning, copy the unoptimized type pool from pEffectSource to this and build mappingTableTypes
// for use in RemapType.  mappingTableStrings is the mapping table previously filled when copying strings.
HRESULT CEffect::CopyTypePool( CEffect* pEffectSource, CPointerMappingTable& mappingTableTypes, CPointerMappingTable& mappingTableStrings )
{
    HRESULT hr = S_OK;
    D3DXASSERT( m_pPooledHeap != NULL );
    VN( m_pTypePool = NEW CEffect::CTypeHashTable );
    m_pTypePool->SetPrivateHeap(m_pPooledHeap);
    VH( m_pTypePool->AutoGrow() );

    CTypeHashTable::CIterator typeIter;
    CPointerMappingTable::CIterator mapIter;

    // first pass: move types over, build mapping table
    for (pEffectSource->m_pTypePool->GetFirstEntry(&typeIter); !pEffectSource->m_pTypePool->PastEnd(&typeIter); pEffectSource->m_pTypePool->GetNextEntry(&typeIter))
    {
        SPointerMapping ptrMapping;
        SType *pType;

        ptrMapping.pOld = typeIter.GetData();
        UINT hash = ptrMapping.Hash();
        VN( (ptrMapping.pNew) = new(*m_pPooledHeap) SType );
        memcpy(ptrMapping.pNew, ptrMapping.pOld, sizeof(SType));

        pType = (SType *) ptrMapping.pNew;

        // if this is a struct, move its members to the newly allocated space
        if (EVT_Struct == pType->VarType)
        {
            SVariable* pOldMembers = pType->StructType.pMembers;
            VN( pType->StructType.pMembers = new(*m_pPooledHeap) SVariable[pType->StructType.Members] );
            memcpy(pType->StructType.pMembers, pOldMembers, pType->StructType.Members * sizeof(SVariable));
        }

        VH( m_pTypePool->AddValueWithHash(pType, hash) );
        VH( mappingTableTypes.AddValueWithHash(ptrMapping, hash) );
    }

    // second pass: fixup structure member & name pointers
    for (mappingTableTypes.GetFirstEntry(&mapIter); !mappingTableTypes.PastEnd(&mapIter); mappingTableTypes.GetNextEntry(&mapIter))
    {
        SPointerMapping ptrMapping = mapIter.GetData();

        // Uncomment to print type mapping
        //DPF(0, "type: 0x%x : 0x%x", (UINT_PTR)ptrMapping.pOld, (UINT_PTR)ptrMapping.pNew );

        SType *pType = (SType *) ptrMapping.pNew;

        if( pType->pTypeName )
        {
            VH( RemapString(&pType->pTypeName, &mappingTableStrings) );
        }

        // if this is a struct, fix up its members' pointers
        if (EVT_Struct == pType->VarType)
        {
            for (UINT i = 0; i < pType->StructType.Members; ++ i)
            {
                VH( RemapType((SType**)&pType->StructType.pMembers[i].pType, &mappingTableTypes) );
                if( pType->StructType.pMembers[i].pName )
                {
                    VH( RemapString(&pType->StructType.pMembers[i].pName, &mappingTableStrings) );
                }
                if( pType->StructType.pMembers[i].pSemantic )
                {
                    VH( RemapString(&pType->StructType.pMembers[i].pSemantic, &mappingTableStrings) );
                }
            }
        }
    } 

lExit:
    return hr;
}

// Used in cloning, copy the unoptimized type pool from pEffectSource to this and build mappingTableTypes
// for use in RemapType.  mappingTableStrings is the mapping table previously filled when copying strings.
HRESULT CEffect::CopyOptimizedTypePool( CEffect* pEffectSource, CPointerMappingTable& mappingTableTypes )
{
    HRESULT hr = S_OK;
    CEffectHeap* pOptimizedTypeHeap = NULL;

    D3DXASSERT( pEffectSource->m_pOptimizedTypeHeap != NULL );
    D3DXASSERT( m_pTypePool == NULL );
    D3DXASSERT( m_pStringPool == NULL );
    D3DXASSERT( m_pPooledHeap == NULL );

    VN( pOptimizedTypeHeap = NEW CEffectHeap );
    VH( pOptimizedTypeHeap->ReserveMemory( pEffectSource->m_pOptimizedTypeHeap->GetSize() ) );
    CPointerMappingTable::CIterator mapIter;

    // first pass: move types over, build mapping table
    BYTE* pReadTypes = pEffectSource->m_pOptimizedTypeHeap->GetDataStart();
    while( pEffectSource->m_pOptimizedTypeHeap->IsInHeap( pReadTypes ) )
    {
        SPointerMapping ptrMapping;
        SType *pType;
        UINT moveSize;

        ptrMapping.pOld = ptrMapping.pNew = pReadTypes;
        moveSize = sizeof(SType);
        VH( pOptimizedTypeHeap->MoveData(&ptrMapping.pNew, moveSize) );
        pReadTypes += moveSize;

        pType = (SType *) ptrMapping.pNew;

        // if this is a struct, move its members to the newly allocated space
        if (EVT_Struct == pType->VarType)
        {
            moveSize = pType->StructType.Members * sizeof(SVariable);
            VH( pOptimizedTypeHeap->MoveData((void **)&pType->StructType.pMembers, moveSize) );
            pReadTypes += moveSize;
        }

        VH( mappingTableTypes.AddValueWithHash(ptrMapping, ptrMapping.Hash()) );
    }

    // second pass: fixup structure member & name pointers
    for (mappingTableTypes.GetFirstEntry(&mapIter); !mappingTableTypes.PastEnd(&mapIter); mappingTableTypes.GetNextEntry(&mapIter))
    {
        SPointerMapping ptrMapping = mapIter.GetData();

        // Uncomment to print type mapping
        //DPF(0, "type: 0x%x : 0x%x", (UINT_PTR)ptrMapping.pOld, (UINT_PTR)ptrMapping.pNew );

        SType *pType = (SType *) ptrMapping.pNew;

        // if this is a struct, fix up its members' pointers
        if (EVT_Struct == pType->VarType)
        {
            for (UINT i = 0; i < pType->StructType.Members; ++ i)
            {
                VH( RemapType((SType**)&pType->StructType.pMembers[i].pType, &mappingTableTypes) );
            }
        }
    }  

lExit:
    return hr;
}

// Used in cloning, create new ID3D11ConstantBuffers for each non-single CB
HRESULT CEffect::RecreateCBs()
{
    HRESULT hr = S_OK;
    UINT i; // after a failure, this holds the failing index

    for (i = 0; i < m_CBCount; ++ i)
    {
        SConstantBuffer* pCB = &m_pCBs[i];

        pCB->IsNonUpdatable = pCB->IsUserManaged || pCB->ClonedSingle();

        if( pCB->Size > 0 && !pCB->ClonedSingle() )
        {
            ID3D11Buffer** ppOriginalBuffer;
            ID3D11ShaderResourceView** ppOriginalTBufferView;

            if( pCB->IsUserManaged )
            {
                ppOriginalBuffer = &pCB->pMemberData[0].Data.pD3DEffectsManagedConstantBuffer;
                ppOriginalTBufferView = &pCB->pMemberData[1].Data.pD3DEffectsManagedTextureBuffer;
            }
            else
            {
                ppOriginalBuffer = &pCB->pD3DObject;
                ppOriginalTBufferView = &pCB->TBuffer.pShaderResource;
            }

            VN( *ppOriginalBuffer );
            D3D11_BUFFER_DESC bufDesc;
            (*ppOriginalBuffer)->GetDesc( &bufDesc );
            ID3D11Buffer* pNewBuffer = NULL;
            VH( m_pDevice->CreateBuffer( &bufDesc, NULL, &pNewBuffer ) );
            (*ppOriginalBuffer)->Release();
            (*ppOriginalBuffer) = pNewBuffer;
            pNewBuffer = NULL;

            if( pCB->IsTBuffer )
            {
                VN( *ppOriginalTBufferView );
                D3D11_SHADER_RESOURCE_VIEW_DESC viewDesc;
                (*ppOriginalTBufferView)->GetDesc( &viewDesc );
                ID3D11ShaderResourceView* pNewView = NULL;
                VH( m_pDevice->CreateShaderResourceView( (*ppOriginalBuffer), &viewDesc, &pNewView) );
                (*ppOriginalTBufferView)->Release();
                (*ppOriginalTBufferView) = pNewView;
                pNewView = NULL;
            }
            else
            {
                D3DXASSERT( *ppOriginalTBufferView == NULL );
                ReplaceCBReference( pCB, (*ppOriginalBuffer) );
            }

            pCB->IsDirty = TRUE;
        }
    }

lExit:
    return hr;
}

// Move Name and Semantic strings using mappingTableStrings
HRESULT CEffect::FixupMemberInterface( SMember* pMember, CEffect* pEffectSource, CPointerMappingTable& mappingTableStrings )
{
    HRESULT hr = S_OK;

    if( pMember->pName )
    {
        if( pEffectSource->m_pReflection && pEffectSource->m_pReflection->m_Heap.IsInHeap(pMember->pName) )
        {
            pMember->pName = (char*)((UINT_PTR)pMember->pName - (UINT_PTR)pEffectSource->m_pReflection->m_Heap.GetDataStart() + (UINT_PTR)m_pReflection->m_Heap.GetDataStart());
        }
        else
        {
            VH( RemapString(&pMember->pName, &mappingTableStrings) );
        }
    }
    if( pMember->pSemantic )
    {
        if( pEffectSource->m_pReflection && pEffectSource->m_pReflection->m_Heap.IsInHeap(pMember->pSemantic) )
        {
            pMember->pSemantic = (char*)((UINT_PTR)pMember->pSemantic - (UINT_PTR)pEffectSource->m_pReflection->m_Heap.GetDataStart() + (UINT_PTR)m_pReflection->m_Heap.GetDataStart());
        }
        else
        {
            VH( RemapString(&pMember->pSemantic, &mappingTableStrings) );
        }
    }

lExit:
    return hr;
}

//////////////////////////////////////////////////////////////////////////
// Public API to create a copy of this effect
HRESULT CEffect::CloneEffect(UINT Flags, ID3DX11Effect** ppClonedEffect )
{
    HRESULT hr = S_OK;
    CPointerMappingTable mappingTableTypes;
    CPointerMappingTable mappingTableStrings;

    CEffectLoader loader;
    CEffect* pNewEffect = NULL;    
    CDataBlockStore* pTempHeap = NULL;


    VN( pNewEffect = NEW CEffect( m_Flags ) );
    if( Flags & D3DX11_EFFECT_CLONE_FORCE_NONSINGLE )
    {
        // The effect is cloned as if there was no original, so don't mark it as cloned
        pNewEffect->m_Flags &= ~(UINT)D3DX11_EFFECT_CLONE;
    }
    else
    {
        pNewEffect->m_Flags |= D3DX11_EFFECT_CLONE;
    }

    pNewEffect->m_VariableCount = m_VariableCount;
    pNewEffect->m_pVariables = m_pVariables;
    pNewEffect->m_AnonymousShaderCount = m_AnonymousShaderCount;
    pNewEffect->m_pAnonymousShaders = m_pAnonymousShaders;
    pNewEffect->m_TechniqueCount = m_TechniqueCount;
    pNewEffect->m_GroupCount = m_GroupCount;
    pNewEffect->m_pGroups = m_pGroups;
    pNewEffect->m_pNullGroup = m_pNullGroup;
    pNewEffect->m_ShaderBlockCount = m_ShaderBlockCount;
    pNewEffect->m_pShaderBlocks = m_pShaderBlocks;
    pNewEffect->m_DepthStencilBlockCount = m_DepthStencilBlockCount;
    pNewEffect->m_pDepthStencilBlocks = m_pDepthStencilBlocks;
    pNewEffect->m_BlendBlockCount = m_BlendBlockCount;
    pNewEffect->m_pBlendBlocks = m_pBlendBlocks;
    pNewEffect->m_RasterizerBlockCount = m_RasterizerBlockCount;
    pNewEffect->m_pRasterizerBlocks = m_pRasterizerBlocks;
    pNewEffect->m_SamplerBlockCount = m_SamplerBlockCount;
    pNewEffect->m_pSamplerBlocks = m_pSamplerBlocks;
    pNewEffect->m_MemberDataCount = m_MemberDataCount;
    pNewEffect->m_pMemberDataBlocks = m_pMemberDataBlocks;
    pNewEffect->m_InterfaceCount = m_InterfaceCount;
    pNewEffect->m_pInterfaces = m_pInterfaces;
    pNewEffect->m_CBCount = m_CBCount;
    pNewEffect->m_pCBs = m_pCBs;
    pNewEffect->m_StringCount = m_StringCount;
    pNewEffect->m_pStrings = m_pStrings;
    pNewEffect->m_ShaderResourceCount = m_ShaderResourceCount;
    pNewEffect->m_pShaderResources = m_pShaderResources;
    pNewEffect->m_UnorderedAccessViewCount = m_UnorderedAccessViewCount;
    pNewEffect->m_pUnorderedAccessViews = m_pUnorderedAccessViews;
    pNewEffect->m_RenderTargetViewCount = m_RenderTargetViewCount;
    pNewEffect->m_pRenderTargetViews = m_pRenderTargetViews;
    pNewEffect->m_DepthStencilViewCount = m_DepthStencilViewCount;
    pNewEffect->m_pDepthStencilViews = m_pDepthStencilViews; 
    pNewEffect->m_LocalTimer = m_LocalTimer;
    pNewEffect->m_FXLIndex = m_FXLIndex;
    pNewEffect->m_pDevice = m_pDevice;
    pNewEffect->m_pClassLinkage = m_pClassLinkage;

    pNewEffect->AddRefAllForCloning( this );


    // m_pMemberInterfaces is a vector of cbuffer members that were created when the user called GetMemberBy* or GetElement
    // or during Effect loading when an interface is initialized to a global class variable elment.
    VH( pNewEffect->CopyMemberInterfaces( this ) );

    loader.m_pvOldMemberInterfaces = &m_pMemberInterfaces;
    loader.m_pEffect = pNewEffect;
    loader.m_EffectMemory = loader.m_ReflectionMemory = 0;


    // Move data from current effect to new effect
    if( !IsOptimized() )
    {
        VN( pNewEffect->m_pReflection = NEW CEffectReflection() );
        loader.m_pReflection = pNewEffect->m_pReflection;

        // make sure strings are moved before ReallocateEffectData
        VH( loader.InitializeReflectionDataAndMoveStrings( m_pReflection->m_Heap.GetSize() ) );
    }
    VH( loader.ReallocateEffectData( true ) );
    if( !IsOptimized() )
    {
        VH( loader.ReallocateReflectionData( true ) );
    }


    // Data structures for remapping type pointers and string pointers
    VN( pTempHeap = NEW CDataBlockStore );
    pTempHeap->EnableAlignment();
    mappingTableTypes.SetPrivateHeap(pTempHeap);
    mappingTableStrings.SetPrivateHeap(pTempHeap);
    VH( mappingTableTypes.AutoGrow() );
    VH( mappingTableStrings.AutoGrow() );

    if( !IsOptimized() )
    {
        // Let's re-create the type pool and string pool
        VN( pNewEffect->m_pPooledHeap = NEW CDataBlockStore );
        pNewEffect->m_pPooledHeap->EnableAlignment();

        VH( pNewEffect->CopyStringPool( this, mappingTableStrings ) );
        VH( pNewEffect->CopyTypePool( this, mappingTableTypes, mappingTableStrings ) );
    }
    else
    {
        // There's no string pool after optimizing.  Let's re-create the type pool
        VH( pNewEffect->CopyOptimizedTypePool( this, mappingTableTypes ) );
    }

    // fixup this effect's variable's types
    VH( pNewEffect->OptimizeTypes(&mappingTableTypes, true) );
    VH( pNewEffect->RecreateCBs() );


    for (UINT i = 0; i < pNewEffect->m_pMemberInterfaces.GetSize(); ++ i)
    {
        SMember* pMember = pNewEffect->m_pMemberInterfaces[i];
        VH( pNewEffect->FixupMemberInterface( pMember, this, mappingTableStrings ) );
    }


lExit:
    SAFE_DELETE( pTempHeap );
    if( FAILED( hr ) )
    {
        SAFE_DELETE( pNewEffect );
    }
    *ppClonedEffect = pNewEffect;
    return hr;
}

// Move all type pointers using pMappingTable.
// This is called after creating the optimized type pool or during cloning.
HRESULT CEffect::OptimizeTypes(CPointerMappingTable *pMappingTable, bool Cloning)
{
    HRESULT hr = S_OK;
    UINT  i;

    // find all child types, point them to the new location
    for (i = 0; i < m_VariableCount; ++ i)
    {
        VH( RemapType((SType**)&m_pVariables[i].pType, pMappingTable) );
    }

    UINT Members = m_pMemberInterfaces.GetSize();
    for( i=0; i < Members; i++ )
    {
        if( m_pMemberInterfaces[i] != NULL )
        {
            VH( RemapType((SType**)&m_pMemberInterfaces[i]->pType, pMappingTable) );
        }
    }

    // when cloning, there may be annotations
    if( Cloning )
    {
        for (UINT iVar = 0; iVar < m_VariableCount; ++ iVar)
        {
            for(i = 0; i < m_pVariables[iVar].AnnotationCount; ++ i )
            {
                VH( RemapType((SType**)&m_pVariables[iVar].pAnnotations[i].pType, pMappingTable) );
            }
        }
        for (UINT iCB = 0; iCB < m_CBCount; ++ iCB)
        {
            for(i = 0; i < m_pCBs[iCB].AnnotationCount; ++ i )
            {
                VH( RemapType((SType**)&m_pCBs[iCB].pAnnotations[i].pType, pMappingTable) );
            }
        }
        for (UINT iGroup = 0; iGroup < m_GroupCount; ++ iGroup)
        {
            for(i = 0; i < m_pGroups[iGroup].AnnotationCount; ++ i )
            {
                VH( RemapType((SType**)&m_pGroups[iGroup].pAnnotations[i].pType, pMappingTable) );
            }
            for(UINT iTech = 0; iTech < m_pGroups[iGroup].TechniqueCount; ++ iTech )
            {
                for(i = 0; i < m_pGroups[iGroup].pTechniques[iTech].AnnotationCount; ++ i )
                {
                    VH( RemapType((SType**)&m_pGroups[iGroup].pTechniques[iTech].pAnnotations[i].pType, pMappingTable) );
                }
                for(UINT iPass = 0; iPass < m_pGroups[iGroup].pTechniques[iTech].PassCount; ++ iPass )
                {
                    for(i = 0; i < m_pGroups[iGroup].pTechniques[iTech].pPasses[iPass].AnnotationCount; ++ i )
                    {
                        VH( RemapType((SType**)&m_pGroups[iGroup].pTechniques[iTech].pPasses[iPass].pAnnotations[i].pType, pMappingTable) );
                    }
                }
            }
        }
    }
lExit:
    return hr;
}

//////////////////////////////////////////////////////////////////////////
// Public API to shed this effect of its reflection data
HRESULT CEffect::Optimize()
{
    HRESULT hr = S_OK;
    UINT  i, j, k;
    CEffectHeap *pOptimizedTypeHeap = NULL;
    
    if (IsOptimized())
    {
        DPF(0, "ID3DX11Effect::Optimize: Effect has already been Optimize()'ed");
        return S_OK;
    }

    // Delete annotations, names, semantics, and string data on variables
    
    for (i = 0; i < m_VariableCount; ++ i)
    {
        m_pVariables[i].AnnotationCount = 0;
        m_pVariables[i].pAnnotations = NULL;
        m_pVariables[i].pName = NULL;
        m_pVariables[i].pSemantic = NULL;

        // 2) Point string variables to NULL
        if (m_pVariables[i].pType->IsObjectType(EOT_String))
        {
            D3DXASSERT(NULL != m_pVariables[i].Data.pString);
            m_pVariables[i].Data.pString = NULL;
        }
    }

    // Delete annotations and names on CBs

    for (i = 0; i < m_CBCount; ++ i)
    {
        m_pCBs[i].AnnotationCount = 0;
        m_pCBs[i].pAnnotations = NULL;
        m_pCBs[i].pName = NULL;
        m_pCBs[i].IsEffectOptimized = TRUE;
    }

    // Delete annotations and names on techniques and passes

    for (i = 0; i < m_GroupCount; ++ i)
    {
        m_pGroups[i].AnnotationCount = 0;
        m_pGroups[i].pAnnotations = NULL;
        m_pGroups[i].pName = NULL;

        for (j = 0; j < m_pGroups[i].TechniqueCount; ++ j)
        {
            m_pGroups[i].pTechniques[j].AnnotationCount = 0;
            m_pGroups[i].pTechniques[j].pAnnotations = NULL;
            m_pGroups[i].pTechniques[j].pName = NULL;

            for (k = 0; k < m_pGroups[i].pTechniques[j].PassCount; ++ k)
            {
                m_pGroups[i].pTechniques[j].pPasses[k].AnnotationCount = 0;
                m_pGroups[i].pTechniques[j].pPasses[k].pAnnotations = NULL;
                m_pGroups[i].pTechniques[j].pPasses[k].pName = NULL;
            }
        }
    };

    // 2) Remove shader bytecode & stream out decls
    //    (all are contained within pReflectionData)

    for (i = 0; i < m_ShaderBlockCount; ++ i)
    {
        if( m_pShaderBlocks[i].pReflectionData )
        {
            // pReflection was not created with PRIVATENEW
            SAFE_RELEASE( m_pShaderBlocks[i].pReflectionData->pReflection );

            m_pShaderBlocks[i].pReflectionData = NULL;
        }
    }

    UINT Members = m_pMemberInterfaces.GetSize();
    for( i=0; i < Members; i++ )
    {
        D3DXASSERT( m_pMemberInterfaces[i] != NULL );
        if( IsReflectionData(m_pMemberInterfaces[i]->pTopLevelEntity) )
        {
            D3DXASSERT( IsReflectionData(m_pMemberInterfaces[i]->Data.pGeneric) );

            // This is checked when cloning (so we don't clone Optimized-out member variables)
            m_pMemberInterfaces[i] = NULL;
        }
        else
        {
            m_pMemberInterfaces[i]->pName = NULL;
            m_pMemberInterfaces[i]->pSemantic = NULL;
        }
    }



    // get rid of the name/type hash tables and string data, 
    // then reallocate the type data and fix up this effect
    CPointerMappingTable mappingTable;
    CTypeHashTable::CIterator typeIter;
    CPointerMappingTable::CIterator mapIter;
    CCheckedDword chkSpaceNeeded = 0;
    UINT  spaceNeeded;

    // first pass: compute needed space
    for (m_pTypePool->GetFirstEntry(&typeIter); !m_pTypePool->PastEnd(&typeIter); m_pTypePool->GetNextEntry(&typeIter))
    {
        SType *pType = typeIter.GetData();
        
        chkSpaceNeeded += AlignToPowerOf2(sizeof(SType), c_DataAlignment);

        // if this is a struct, allocate room for its members
        if (EVT_Struct == pType->VarType)
        {
            chkSpaceNeeded += AlignToPowerOf2(pType->StructType.Members * sizeof(SVariable), c_DataAlignment);
        }
    }

    VH( chkSpaceNeeded.GetValue(&spaceNeeded) );

    D3DXASSERT(NULL == m_pOptimizedTypeHeap);
    VN( pOptimizedTypeHeap = NEW CEffectHeap );
    VH( pOptimizedTypeHeap->ReserveMemory(spaceNeeded));

    // use the private heap that we're about to destroy as scratch space for the mapping table
    mappingTable.SetPrivateHeap(m_pPooledHeap);
    VH( mappingTable.AutoGrow() );

    // second pass: move types over, build mapping table
    for (m_pTypePool->GetFirstEntry(&typeIter); !m_pTypePool->PastEnd(&typeIter); m_pTypePool->GetNextEntry(&typeIter))
    {
        SPointerMapping ptrMapping;
        SType *pType;

        ptrMapping.pOld = ptrMapping.pNew = typeIter.GetData();
        VH( pOptimizedTypeHeap->MoveData(&ptrMapping.pNew, sizeof(SType)) );

        pType = (SType *) ptrMapping.pNew;

        // if this is a struct, move its members to the newly allocated space
        if (EVT_Struct == pType->VarType)
        {
            VH( pOptimizedTypeHeap->MoveData((void **)&pType->StructType.pMembers, pType->StructType.Members * sizeof(SVariable)) );
        }

        VH( mappingTable.AddValueWithHash(ptrMapping, ptrMapping.Hash()) );
    }
    
    // third pass: fixup structure member & name pointers
    for (mappingTable.GetFirstEntry(&mapIter); !mappingTable.PastEnd(&mapIter); mappingTable.GetNextEntry(&mapIter))
    {
        SPointerMapping ptrMapping = mapIter.GetData();
        SType *pType = (SType *) ptrMapping.pNew;

        pType->pTypeName = NULL;

        // if this is a struct, fix up its members' pointers
        if (EVT_Struct == pType->VarType)
        {
            for (i = 0; i < pType->StructType.Members; ++ i)
            {
                VH( RemapType((SType**)&pType->StructType.pMembers[i].pType, &mappingTable) );
                pType->StructType.pMembers[i].pName = NULL;
                pType->StructType.pMembers[i].pSemantic = NULL;
            }
        }
    }        

    // fixup this effect's variable's types
    VH( OptimizeTypes(&mappingTable) );

    m_pOptimizedTypeHeap = pOptimizedTypeHeap;
    pOptimizedTypeHeap = NULL;

#ifdef D3DX11_FX_PRINT_HASH_STATS
    DPF(0, "Compiler string pool hash table statistics:");
    m_pTypePool->PrintHashTableStats();
    DPF(0, "Compiler type pool hash table statistics:");
    m_pStringPool->PrintHashTableStats();
#endif // D3DX11_FX_PRINT_HASH_STATS

    SAFE_DELETE(m_pTypePool);
    SAFE_DELETE(m_pStringPool);
    SAFE_DELETE(m_pPooledHeap);

    DPF(0, "ID3DX11Effect::Optimize: %d bytes of reflection data freed.", m_pReflection->m_Heap.GetSize());
    SAFE_DELETE(m_pReflection);
    m_Flags |= D3DX11_EFFECT_OPTIMIZED;

lExit:
    SAFE_DELETE(pOptimizedTypeHeap);
    return hr;
}

SMember * CreateNewMember(SType *pType, BOOL IsAnnotation)
{
    switch (pType->VarType)
    {
    case EVT_Struct:
        if (IsAnnotation)
        {
            D3DXASSERT(sizeof(SNumericAnnotationMember) == sizeof(SMember));
            return (SMember*) NEW SNumericAnnotationMember;
        }
        else if (pType->StructType.ImplementsInterface)
        {
            D3DXASSERT(sizeof(SClassInstanceGlobalVariableMember) == sizeof(SMember));
            return (SMember*) NEW SClassInstanceGlobalVariableMember;
        }
        else
        {
            D3DXASSERT(sizeof(SNumericGlobalVariableMember) == sizeof(SMember));
            return (SMember*) NEW SNumericGlobalVariableMember;
        }
        break;
    case EVT_Interface:
        D3DXASSERT(sizeof(SInterfaceGlobalVariableMember) == sizeof(SMember));
        return (SMember*) NEW SInterfaceGlobalVariableMember;
        break;
    case EVT_Object:
        switch (pType->ObjectType)
        {
        case EOT_String:
            if (IsAnnotation)
            {
                D3DXASSERT(sizeof(SStringAnnotationMember) == sizeof(SMember));
                return (SMember*) NEW SStringAnnotationMember;
            }
            else
            {
                D3DXASSERT(sizeof(SStringGlobalVariableMember) == sizeof(SMember));
                return (SMember*) NEW SStringGlobalVariableMember;
            }

            break;
        case EOT_Texture:
        case EOT_Texture1D:
        case EOT_Texture1DArray:
        case EOT_Texture2D:
        case EOT_Texture2DArray:
        case EOT_Texture2DMS:
        case EOT_Texture2DMSArray:
        case EOT_Texture3D:
        case EOT_TextureCube:
        case EOT_TextureCubeArray:
        case EOT_Buffer:
        case EOT_ByteAddressBuffer:
        case EOT_StructuredBuffer:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SShaderResourceGlobalVariableMember) == sizeof(SMember));
            return (SMember*) NEW SShaderResourceGlobalVariableMember;
            break;
        case EOT_RWTexture1D:
        case EOT_RWTexture1DArray:
        case EOT_RWTexture2D:
        case EOT_RWTexture2DArray:
        case EOT_RWTexture3D:
        case EOT_RWBuffer:
        case EOT_RWByteAddressBuffer:
        case EOT_RWStructuredBuffer:
        case EOT_RWStructuredBufferAlloc:
        case EOT_RWStructuredBufferConsume:
        case EOT_AppendStructuredBuffer:
        case EOT_ConsumeStructuredBuffer:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SUnorderedAccessViewGlobalVariableMember) == sizeof(SMember));
            return (SMember*) NEW SUnorderedAccessViewGlobalVariableMember;
            break;
        case EOT_VertexShader:
        case EOT_VertexShader5:
        case EOT_GeometryShader:
        case EOT_GeometryShaderSO:
        case EOT_GeometryShader5:
        case EOT_PixelShader:
        case EOT_PixelShader5:
        case EOT_HullShader5:
        case EOT_DomainShader5:
        case EOT_ComputeShader5:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SShaderGlobalVariableMember) == sizeof(SMember));
            return (SMember*) NEW SShaderGlobalVariableMember;
            break;
        case EOT_Blend:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SBlendGlobalVariableMember) == sizeof(SMember));
            return (SMember*) NEW SBlendGlobalVariableMember;
            break;
        case EOT_Rasterizer:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SRasterizerGlobalVariableMember) == sizeof(SMember));
            return (SMember*) NEW SRasterizerGlobalVariableMember;
            break;
        case EOT_DepthStencil:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SDepthStencilGlobalVariableMember) == sizeof(SMember));
            return (SMember*) NEW SDepthStencilGlobalVariableMember;
            break;
        case EOT_Sampler:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SSamplerGlobalVariableMember) == sizeof(SMember));
            return (SMember*) NEW SSamplerGlobalVariableMember;
            break;
        case EOT_DepthStencilView:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SDepthStencilViewGlobalVariableMember) == sizeof(SMember));
            return (SMember*) NEW SDepthStencilViewGlobalVariableMember;
            break;
        case EOT_RenderTargetView:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SRenderTargetViewGlobalVariableMember) == sizeof(SMember));
            return (SMember*) NEW SRenderTargetViewGlobalVariableMember;
            break;
        default:
            D3DXASSERT(0);
            DPF( 0, "Internal error: invalid object type." );
            return NULL;
            break;
        }
        break;
    case EVT_Numeric:
        switch (pType->NumericType.NumericLayout)
        {
        case ENL_Matrix:
            if (IsAnnotation)
            {
                D3DXASSERT(sizeof(SMatrixAnnotationMember) == sizeof(SMember));
                return (SMember*) NEW SMatrixAnnotationMember;
            }
            else
            {
                D3DXASSERT(sizeof(SMatrixGlobalVariableMember) == sizeof(SMember));
                D3DXASSERT(sizeof(SMatrix4x4ColumnMajorGlobalVariableMember) == sizeof(SMember));
                D3DXASSERT(sizeof(SMatrix4x4RowMajorGlobalVariableMember) == sizeof(SMember));

                if (pType->NumericType.Rows == 4 && pType->NumericType.Columns == 4)
                {
                    if (pType->NumericType.IsColumnMajor)
                    {
                        return (SMember*) NEW SMatrix4x4ColumnMajorGlobalVariableMember;
                    }
                    else
                    {
                        return (SMember*) NEW SMatrix4x4RowMajorGlobalVariableMember;
                    }
                }
                else
                {
                    return (SMember*) NEW SMatrixGlobalVariableMember;
                }
            }
            break;
        case ENL_Vector:
            switch (pType->NumericType.ScalarType)
            {
            case EST_Float:
                if (IsAnnotation)
                {
                    D3DXASSERT(sizeof(SFloatVectorAnnotationMember) == sizeof(SMember));
                    return (SMember*) NEW SFloatVectorAnnotationMember;
                }
                else
                {
                    D3DXASSERT(sizeof(SFloatVectorGlobalVariableMember) == sizeof(SMember));
                    D3DXASSERT(sizeof(SFloatVector4GlobalVariableMember) == sizeof(SMember));

                    if (pType->NumericType.Columns == 4)
                    {
                        return (SMember*) NEW SFloatVector4GlobalVariableMember;
                    }
                    else
                    {
                        return (SMember*) NEW SFloatVectorGlobalVariableMember;
                    }
                }
                break;
            case EST_Bool:
                if (IsAnnotation)
                {
                    D3DXASSERT(sizeof(SBoolVectorAnnotationMember) == sizeof(SMember));
                    return (SMember*) NEW SBoolVectorAnnotationMember;
                }
                else
                {
                    D3DXASSERT(sizeof(SBoolVectorGlobalVariableMember) == sizeof(SMember));
                    return (SMember*) NEW SBoolVectorGlobalVariableMember;
                }
                break;
            case EST_UInt:
            case EST_Int:
                if (IsAnnotation)
                {
                    D3DXASSERT(sizeof(SIntVectorAnnotationMember) == sizeof(SMember));
                    return (SMember*) NEW SIntVectorAnnotationMember;
                }
                else
                {
                    D3DXASSERT(sizeof(SIntVectorGlobalVariableMember) == sizeof(SMember));
                    return (SMember*) NEW SIntVectorGlobalVariableMember;
                }
                break;
            default:
                D3DXASSERT(0);
                DPF( 0, "Internal loading error: invalid vector type." );
                break;
            }
            break;
        case ENL_Scalar:
            switch (pType->NumericType.ScalarType)
            {
            case EST_Float:
                if (IsAnnotation)
                {
                    D3DXASSERT(sizeof(SFloatScalarAnnotationMember) == sizeof(SMember));
                    return (SMember*) NEW SFloatScalarAnnotationMember;
                }
                else
                {
                    D3DXASSERT(sizeof(SFloatScalarGlobalVariableMember) == sizeof(SMember));
                    return (SMember*) NEW SFloatScalarGlobalVariableMember;
                }
                break;
            case EST_UInt:
            case EST_Int:
                if (IsAnnotation)
                {
                    D3DXASSERT(sizeof(SIntScalarAnnotationMember) == sizeof(SMember));
                    return (SMember*) NEW SIntScalarAnnotationMember;
                }
                else
                {
                    D3DXASSERT(sizeof(SIntScalarGlobalVariableMember) == sizeof(SMember));
                    return (SMember*) NEW SIntScalarGlobalVariableMember;
                }
                break;
            case EST_Bool:
                if (IsAnnotation)
                {
                    D3DXASSERT(sizeof(SBoolScalarAnnotationMember) == sizeof(SMember));
                    return (SMember*) NEW SBoolScalarAnnotationMember;
                }
                else
                {
                    D3DXASSERT(sizeof(SBoolScalarGlobalVariableMember) == sizeof(SMember));
                    return (SMember*) NEW SBoolScalarGlobalVariableMember;
                }
                break;
            default:
                DPF( 0, "Internal loading error: invalid scalar type." );
                D3DXASSERT(0);
                break;
            }            
            break;
        default:
            D3DXASSERT(0);
            DPF( 0, "Internal loading error: invalid numeric type." );
            break;
        }
        break;
    default:
        D3DXASSERT(0);
        DPF( 0, "Internal loading error: invalid variable type." );
        break;
    }
    return NULL;
}

// Global variables are created in place because storage for them was allocated during LoadEffect
HRESULT PlacementNewVariable(void *pVar, SType *pType, BOOL IsAnnotation)
{
    switch (pType->VarType)
    {
    case EVT_Struct:
        if (IsAnnotation)
        {
            D3DXASSERT(sizeof(SNumericAnnotation) == sizeof(SAnnotation));
            new(pVar) SNumericAnnotation();
        }
        else if (pType->StructType.ImplementsInterface)
        {
            D3DXASSERT(sizeof(SClassInstanceGlobalVariable) == sizeof(SGlobalVariable));
            new(pVar) SClassInstanceGlobalVariable;
        }
        else 
        {
            D3DXASSERT(sizeof(SNumericGlobalVariable) == sizeof(SGlobalVariable));
            new(pVar) SNumericGlobalVariable;
        }
        break;
    case EVT_Interface:
        D3DXASSERT(sizeof(SInterfaceGlobalVariable) == sizeof(SGlobalVariable));
        new(pVar) SInterfaceGlobalVariable;
        break;
    case EVT_Object:
        switch (pType->ObjectType)
        {
        case EOT_String:
            if (IsAnnotation)
            {
                D3DXASSERT(sizeof(SStringAnnotation) == sizeof(SAnnotation));
                new(pVar) SStringAnnotation;
            }
            else
            {
                D3DXASSERT(sizeof(SStringGlobalVariable) == sizeof(SGlobalVariable));
                new(pVar) SStringGlobalVariable;
            }
            
            break;
        case EOT_Texture:
        case EOT_Texture1D:
        case EOT_Texture1DArray:
        case EOT_Texture2D:
        case EOT_Texture2DArray:
        case EOT_Texture2DMS:
        case EOT_Texture2DMSArray:
        case EOT_Texture3D:
        case EOT_TextureCube:
        case EOT_TextureCubeArray:
        case EOT_Buffer:
        case EOT_ByteAddressBuffer:
        case EOT_StructuredBuffer:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SShaderResourceGlobalVariable) == sizeof(SGlobalVariable));
            new(pVar) SShaderResourceGlobalVariable;
            break;
        case EOT_RWTexture1D:
        case EOT_RWTexture1DArray:
        case EOT_RWTexture2D:
        case EOT_RWTexture2DArray:
        case EOT_RWTexture3D:
        case EOT_RWBuffer:
        case EOT_RWByteAddressBuffer:
        case EOT_RWStructuredBuffer:
        case EOT_RWStructuredBufferAlloc:
        case EOT_RWStructuredBufferConsume:
        case EOT_AppendStructuredBuffer:
        case EOT_ConsumeStructuredBuffer:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SUnorderedAccessViewGlobalVariable) == sizeof(SGlobalVariable));
            new(pVar) SUnorderedAccessViewGlobalVariable;
            break;
        case EOT_VertexShader:
        case EOT_VertexShader5:
        case EOT_GeometryShader:
        case EOT_GeometryShaderSO:
        case EOT_GeometryShader5:
        case EOT_PixelShader:
        case EOT_PixelShader5:
        case EOT_HullShader5:
        case EOT_DomainShader5:
        case EOT_ComputeShader5:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SShaderGlobalVariable) == sizeof(SGlobalVariable));
            new(pVar) SShaderGlobalVariable;
            break;
        case EOT_Blend:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SBlendGlobalVariable) == sizeof(SGlobalVariable));
            new(pVar) SBlendGlobalVariable;
            break;
        case EOT_Rasterizer:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SRasterizerGlobalVariable) == sizeof(SGlobalVariable));
            new(pVar) SRasterizerGlobalVariable;
            break;
        case EOT_DepthStencil:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SDepthStencilGlobalVariable) == sizeof(SGlobalVariable));
            new(pVar) SDepthStencilGlobalVariable;
            break;
        case EOT_Sampler:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SSamplerGlobalVariable) == sizeof(SGlobalVariable));
            new(pVar) SSamplerGlobalVariable;
            break;
        case EOT_RenderTargetView:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SRenderTargetViewGlobalVariable) == sizeof(SGlobalVariable));
            new(pVar) SRenderTargetViewGlobalVariable;
            break;
        case EOT_DepthStencilView:
            D3DXASSERT(!IsAnnotation);
            D3DXASSERT(sizeof(SDepthStencilViewGlobalVariable) == sizeof(SGlobalVariable));
            new(pVar) SDepthStencilViewGlobalVariable;
            break;
        default:
            D3DXASSERT(0);
            DPF( 0, "Internal loading error: invalid object type." );
            return E_FAIL;
            break;
        }
        break;
    case EVT_Numeric:
        switch (pType->NumericType.NumericLayout)
        {
        case ENL_Matrix:
            if (IsAnnotation)
            {
                D3DXASSERT(sizeof(SMatrixAnnotation) == sizeof(SAnnotation));
                new(pVar) SMatrixAnnotation;
            }
            else
            {
                D3DXASSERT(sizeof(SMatrixGlobalVariable) == sizeof(SGlobalVariable));
                D3DXASSERT(sizeof(SMatrix4x4ColumnMajorGlobalVariable) == sizeof(SGlobalVariable));
                D3DXASSERT(sizeof(SMatrix4x4RowMajorGlobalVariable) == sizeof(SGlobalVariable));
                
                if (pType->NumericType.Rows == 4 && pType->NumericType.Columns == 4)
                {
                    if (pType->NumericType.IsColumnMajor)
                    {
                        new(pVar) SMatrix4x4ColumnMajorGlobalVariable;
                    }
                    else
                    {
                        new(pVar) SMatrix4x4RowMajorGlobalVariable;
                    }
                }
                else
                {
                    new(pVar) SMatrixGlobalVariable;
                }
            }
            break;
        case ENL_Vector:
            switch (pType->NumericType.ScalarType)
            {
            case EST_Float:
                if (IsAnnotation)
                {
                    D3DXASSERT(sizeof(SFloatVectorAnnotation) == sizeof(SAnnotation));
                    new(pVar) SFloatVectorAnnotation;
                }
                else
                {
                    D3DXASSERT(sizeof(SFloatVectorGlobalVariable) == sizeof(SGlobalVariable));
                    D3DXASSERT(sizeof(SFloatVector4GlobalVariable) == sizeof(SGlobalVariable));

                    if (pType->NumericType.Columns == 4)
                    {
                        new(pVar) SFloatVector4GlobalVariable;
                    }
                    else
                    {
                        new(pVar) SFloatVectorGlobalVariable;
                    }
                }
                break;
            case EST_Bool:
                if (IsAnnotation)
                {
                    D3DXASSERT(sizeof(SBoolVectorAnnotation) == sizeof(SAnnotation));
                    new(pVar) SBoolVectorAnnotation;
                }
                else
                {
                    D3DXASSERT(sizeof(SBoolVectorGlobalVariable) == sizeof(SGlobalVariable));
                    new(pVar) SBoolVectorGlobalVariable;
                }
                break;
            case EST_UInt:
            case EST_Int:
                if (IsAnnotation)
                {
                    D3DXASSERT(sizeof(SIntVectorAnnotation) == sizeof(SAnnotation));
                    new(pVar) SIntVectorAnnotation;
                }
                else
                {
                    D3DXASSERT(sizeof(SIntVectorGlobalVariable) == sizeof(SGlobalVariable));
                    new(pVar) SIntVectorGlobalVariable;
                }
                break;
            }
            break;
        case ENL_Scalar:
            switch (pType->NumericType.ScalarType)
            {
            case EST_Float:
                if (IsAnnotation)
                {
                    D3DXASSERT(sizeof(SFloatScalarAnnotation) == sizeof(SAnnotation));
                    new(pVar) SFloatScalarAnnotation;
                }
                else
                {
                    D3DXASSERT(sizeof(SFloatScalarGlobalVariable) == sizeof(SGlobalVariable));
                    new(pVar) SFloatScalarGlobalVariable;
                }
                break;
            case EST_UInt:
            case EST_Int:
                if (IsAnnotation)
                {
                    D3DXASSERT(sizeof(SIntScalarAnnotation) == sizeof(SAnnotation));
                    new(pVar) SIntScalarAnnotation;
                }
                else
                {
                    D3DXASSERT(sizeof(SIntScalarGlobalVariable) == sizeof(SGlobalVariable));
                    new(pVar) SIntScalarGlobalVariable;
                }
                break;
            case EST_Bool:
                if (IsAnnotation)
                {
                    D3DXASSERT(sizeof(SBoolScalarAnnotation) == sizeof(SAnnotation));
                    new(pVar) SBoolScalarAnnotation;
                }
                else
                {
                    D3DXASSERT(sizeof(SBoolScalarGlobalVariable) == sizeof(SGlobalVariable));
                    new(pVar) SBoolScalarGlobalVariable;
                }
                break;
            default:
                D3DXASSERT(0);
                DPF( 0, "Internal loading error: invalid scalar type." );
                return E_FAIL;
                break;
            }            
            break;
        default:
            D3DXASSERT(0);
            DPF( 0, "Internal loading error: invalid numeric type." );
            return E_FAIL;
            break;
        }
        break;
    default:
        D3DXASSERT(0);
        DPF( 0, "Internal loading error: invalid variable type." );
        return E_FAIL;
        break;
    }
    return S_OK;
}

}

```

`Source Code/Effects11/EffectReflection.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       EffectReflection.cpp
//  Content:    D3DX11 Effects public reflection APIs
//
//////////////////////////////////////////////////////////////////////////////

#include "pchfx.h"

namespace D3DX11Effects
{

SEffectInvalidType g_InvalidType;

SEffectInvalidScalarVariable g_InvalidScalarVariable;
SEffectInvalidVectorVariable g_InvalidVectorVariable;
SEffectInvalidMatrixVariable g_InvalidMatrixVariable;
SEffectInvalidStringVariable g_InvalidStringVariable;
SEffectInvalidClassInstanceVariable g_InvalidClassInstanceVariable;
SEffectInvalidInterfaceVariable g_InvalidInterfaceVariable;
SEffectInvalidShaderResourceVariable g_InvalidShaderResourceVariable;
SEffectInvalidUnorderedAccessViewVariable g_InvalidUnorderedAccessViewVariable;
SEffectInvalidRenderTargetViewVariable g_InvalidRenderTargetViewVariable;
SEffectInvalidDepthStencilViewVariable g_InvalidDepthStencilViewVariable;
SEffectInvalidConstantBuffer g_InvalidConstantBuffer;
SEffectInvalidShaderVariable g_InvalidShaderVariable;
SEffectInvalidBlendVariable g_InvalidBlendVariable;
SEffectInvalidDepthStencilVariable g_InvalidDepthStencilVariable;
SEffectInvalidRasterizerVariable g_InvalidRasterizerVariable;
SEffectInvalidSamplerVariable g_InvalidSamplerVariable;

SEffectInvalidPass g_InvalidPass;
SEffectInvalidTechnique g_InvalidTechnique;
SEffectInvalidGroup g_InvalidGroup;


//////////////////////////////////////////////////////////////////////////
// Helper routine implementations
//////////////////////////////////////////////////////////////////////////

ID3DX11EffectConstantBuffer * NoParentCB()
{
    DPF(0, "ID3DX11EffectVariable::GetParentConstantBuffer: Variable does not have a parent constant buffer");
    // have to typecast because the type of g_InvalidScalarVariable has not been declared yet
    return &g_InvalidConstantBuffer;
}

ID3DX11EffectVariable * GetAnnotationByIndexHelper(const char *pClassName, UINT  Index, UINT  AnnotationCount, SAnnotation *pAnnotations)
{
    if (Index >= AnnotationCount)
    {
        DPF(0, "%s::GetAnnotationByIndex: Invalid index (%d, total: %d)", pClassName, Index, AnnotationCount);
        return &g_InvalidScalarVariable;
    }

    return pAnnotations + Index;
}

ID3DX11EffectVariable * GetAnnotationByNameHelper(const char *pClassName, LPCSTR Name, UINT  AnnotationCount, SAnnotation *pAnnotations)
{
    UINT  i;
    for (i = 0; i < AnnotationCount; ++ i)
    {
        if (strcmp(pAnnotations[i].pName, Name) == 0)
        {
            return pAnnotations + i;
        }
    }

    DPF(0, "%s::GetAnnotationByName: Annotation [%s] not found", pClassName, Name);
    return &g_InvalidScalarVariable;
}

//////////////////////////////////////////////////////////////////////////
// Effect routines to pool interfaces
//////////////////////////////////////////////////////////////////////////

ID3DX11EffectType * CEffect::CreatePooledSingleElementTypeInterface(SType *pType)
{
    UINT  i;

    if (IsOptimized())
    {
        DPF(0, "ID3DX11Effect: Cannot create new type interfaces since the effect has been Optimize()'ed");
        return &g_InvalidType;
    }

    for (i = 0; i < m_pTypeInterfaces.GetSize(); ++ i)
    {
        if (m_pTypeInterfaces[i]->pType == pType)
        {
            return (SSingleElementType*)m_pTypeInterfaces[i];
        }
    }
    SSingleElementType *pNewType;
    if (NULL == (pNewType = NEW SSingleElementType))
    {
        DPF(0, "ID3DX11Effect: Out of memory while trying to create new type interface");
        return &g_InvalidType;
    }

    pNewType->pType = pType;
    m_pTypeInterfaces.Add(pNewType);

    return pNewType;
}

// Create a member variable (via GetMemberBy* or GetElement)
ID3DX11EffectVariable * CEffect::CreatePooledVariableMemberInterface(TTopLevelVariable<ID3DX11EffectVariable> *pTopLevelEntity, SVariable *pMember, UDataPointer Data, BOOL IsSingleElement, UINT Index)
{
    BOOL IsAnnotation;
    UINT  i;

    if (IsOptimized())
    {
        DPF(0, "ID3DX11Effect: Cannot create new variable interfaces since the effect has been Optimize()'ed");
        return &g_InvalidScalarVariable;
    }

    for (i = 0; i < m_pMemberInterfaces.GetSize(); ++ i)
    {
        if (m_pMemberInterfaces[i]->pType == pMember->pType && 
            m_pMemberInterfaces[i]->pName == pMember->pName &&
            m_pMemberInterfaces[i]->pSemantic == pMember->pSemantic &&
            m_pMemberInterfaces[i]->Data.pGeneric == Data.pGeneric &&
            m_pMemberInterfaces[i]->IsSingleElement == IsSingleElement &&
            ((SMember*)m_pMemberInterfaces[i])->pTopLevelEntity == pTopLevelEntity)
        {
            return (ID3DX11EffectVariable *) m_pMemberInterfaces[i];
        }
    }

    // is this annotation or runtime data?
    if( pTopLevelEntity->pEffect->IsReflectionData(pTopLevelEntity) )
    {
        D3DXASSERT( pTopLevelEntity->pEffect->IsReflectionData(Data.pGeneric) );
        IsAnnotation = TRUE;
    }
    else
    {
        // if the heap is empty, we are still loading the Effect, and thus creating a member for a variable initializer
        // ex. Interface myInt = myClassArray[2];
        if( pTopLevelEntity->pEffect->m_Heap.GetSize() > 0 )
        {
            D3DXASSERT( pTopLevelEntity->pEffect->IsRuntimeData(pTopLevelEntity) );
            if (!pTopLevelEntity->pType->IsObjectType(EOT_String))
            {
                // strings are funny; their data is reflection data, so ignore those
                D3DXASSERT( pTopLevelEntity->pEffect->IsRuntimeData(Data.pGeneric) );
            }
        }
        IsAnnotation = FALSE;
    }

    SMember *pNewMember;

    if (NULL == (pNewMember = CreateNewMember((SType*)pMember->pType, IsAnnotation)))
    {
        DPF(0, "ID3DX11Effect: Out of memory while trying to create new member variable interface");
        return &g_InvalidScalarVariable;
    }
    
    pNewMember->pType = pMember->pType;
    pNewMember->pName = pMember->pName;
    pNewMember->pSemantic = pMember->pSemantic;
    pNewMember->Data.pGeneric = Data.pGeneric;
    pNewMember->IsSingleElement = IsSingleElement;
    pNewMember->pTopLevelEntity = pTopLevelEntity;

    if( IsSingleElement && pMember->pMemberData )
    {
        D3DXASSERT( !IsAnnotation );
        // This is an element of a global variable array
        pNewMember->pMemberData = pMember->pMemberData + Index;
    }

    if (FAILED(m_pMemberInterfaces.Add(pNewMember)))
    {
        SAFE_DELETE(pNewMember);
        DPF(0, "ID3DX11Effect: Out of memory while trying to create new member variable interface");
        return &g_InvalidScalarVariable;
    }

    return (ID3DX11EffectVariable *) pNewMember;
}

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectType (SType, SSingleElementType implementations)
//////////////////////////////////////////////////////////////////////////

static ID3DX11EffectType * GetTypeByIndexHelper(UINT Index, UINT  VariableCount, 
                                               SVariable *pVariables, UINT  SizeOfVariableType)
{
    LPCSTR pFuncName = "ID3DX11EffectType::GetMemberTypeByIndex";

    if (Index >= VariableCount)
    {
        DPF(0, "%s: Invalid index (%d, total: %d)", pFuncName, Index, VariableCount);
        return &g_InvalidType;
    }

    SVariable *pVariable = (SVariable *)((BYTE *)pVariables + Index * SizeOfVariableType);
    if (NULL == pVariable->pName)
    {
        DPF(0, "%s: Cannot get member types; Effect has been Optimize()'ed", pFuncName);
        return &g_InvalidType;
    }

    return (ID3DX11EffectType *) pVariable->pType;
}

static ID3DX11EffectType * GetTypeByNameHelper(LPCSTR Name, UINT  VariableCount, 
                                              SVariable *pVariables, UINT  SizeOfVariableType)
{
    LPCSTR pFuncName = "ID3DX11EffectType::GetMemberTypeByName";

    if (NULL == Name)
    {
        DPF(0, "%s: Parameter Name was NULL.", pFuncName);
        return &g_InvalidType;
    }

    UINT  i;
    SVariable *pVariable;

    for (i = 0; i < VariableCount; ++ i)
    {
        pVariable = (SVariable *)((BYTE *)pVariables + i * SizeOfVariableType);
        if (NULL == pVariable->pName)
        {
            DPF(0, "%s: Cannot get member types; Effect has been Optimize()'ed", pFuncName);
            return &g_InvalidType;
        }
        if (strcmp(pVariable->pName, Name) == 0)
        {
            return (ID3DX11EffectType *) pVariable->pType;
        }
    }

    DPF(0, "%s: Member type [%s] not found", pFuncName, Name);
    return &g_InvalidType;
}


static ID3DX11EffectType * GetTypeBySemanticHelper(LPCSTR Semantic, UINT  VariableCount, 
                                                  SVariable *pVariables, UINT  SizeOfVariableType)
{
    LPCSTR pFuncName = "ID3DX11EffectType::GetMemberTypeBySemantic";

    if (NULL == Semantic)
    {
        DPF(0, "%s: Parameter Semantic was NULL.", pFuncName);
        return &g_InvalidType;
    }

    UINT  i;
    SVariable *pVariable;

    for (i = 0; i < VariableCount; ++ i)
    {
        pVariable = (SVariable *)((BYTE *)pVariables + i * SizeOfVariableType);
        if (NULL == pVariable->pName)
        {
            DPF(0, "%s: Cannot get member types; Effect has been Optimize()'ed", pFuncName);
            return &g_InvalidType;
        }
        if (NULL != pVariable->pSemantic &&
            _stricmp(pVariable->pSemantic, Semantic) == 0)
        {
            return (ID3DX11EffectType *) pVariable->pType;
        }
    }

    DPF(0, "%s: Member type with semantic [%s] not found", pFuncName, Semantic);
    return &g_InvalidType;
}

ID3DX11EffectType * SType::GetMemberTypeByIndex(UINT Index)
{
    if (VarType != EVT_Struct)
    {
        DPF(0, "ID3DX11EffectType::GetMemberTypeByIndex: This interface does not refer to a structure");
        return &g_InvalidType;
    }

    return GetTypeByIndexHelper(Index, StructType.Members, StructType.pMembers, sizeof(SVariable));
}

ID3DX11EffectType * SType::GetMemberTypeByName(LPCSTR Name)
{
    if (VarType != EVT_Struct)
    {
        DPF(0, "ID3DX11EffectType::GetMemberTypeByName: This interface does not refer to a structure");
        return &g_InvalidType;
    }

    return GetTypeByNameHelper(Name, StructType.Members, StructType.pMembers, sizeof(SVariable));
}

ID3DX11EffectType * SType::GetMemberTypeBySemantic(LPCSTR Semantic)
{
    if (VarType != EVT_Struct)
    {
        DPF(0, "ID3DX11EffectType::GetMemberTypeBySemantic: This interface does not refer to a structure");
        return &g_InvalidType;
    }

    return GetTypeBySemanticHelper(Semantic, StructType.Members, StructType.pMembers, sizeof(SVariable));
}

LPCSTR SType::GetMemberName(UINT Index)
{
    LPCSTR pFuncName = "ID3DX11EffectType::GetMemberName";

    if (VarType != EVT_Struct)
    {
        DPF(0, "%s: This interface does not refer to a structure", pFuncName);
        return NULL;
    }

    if (Index >= StructType.Members)
    {
        DPF(0, "%s: Invalid index (%d, total: %d)", pFuncName, Index, StructType.Members);
        return NULL;
    }

    SVariable *pVariable = StructType.pMembers + Index;

    if (NULL == pVariable->pName)
    {
        DPF(0, "%s: Cannot get member names; Effect has been Optimize()'ed", pFuncName);
        return NULL;
    }

    return pVariable->pName;
}

LPCSTR SType::GetMemberSemantic(UINT Index)
{
    LPCSTR pFuncName = "ID3DX11EffectType::GetMemberSemantic";

    if (VarType != EVT_Struct)
    {
        DPF(0, "%s: This interface does not refer to a structure", pFuncName);
        return NULL;
    }

    if (Index >= StructType.Members)
    {
        DPF(0, "%s: Invalid index (%d, total: %d)", pFuncName, Index, StructType.Members);
        return NULL;
    }

    SVariable *pVariable = StructType.pMembers + Index;

    if (NULL == pVariable->pName)
    {
        DPF(0, "%s: Cannot get member semantics; Effect has been Optimize()'ed", pFuncName);
        return NULL;
    }

    return pVariable->pSemantic;
}

HRESULT SType::GetDescHelper(D3DX11_EFFECT_TYPE_DESC *pDesc, BOOL IsSingleElement) const
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectType::GetDesc";

    VERIFYPARAMETER(pDesc);
    
    pDesc->TypeName = pTypeName;

    // intentionally return 0 so they know it's not a single element array
    pDesc->Elements = IsSingleElement ? 0 : Elements;
    pDesc->PackedSize = GetTotalPackedSize(IsSingleElement);
    pDesc->UnpackedSize = GetTotalUnpackedSize(IsSingleElement);
    pDesc->Stride = Stride;

    switch (VarType)
    {
    case EVT_Numeric:
        switch (NumericType.NumericLayout)
        {
        case ENL_Matrix:
            if (NumericType.IsColumnMajor)
            {
                pDesc->Class = D3D10_SVC_MATRIX_COLUMNS;
            }
            else
            {
                pDesc->Class = D3D10_SVC_MATRIX_ROWS;
            }
            break;
        case ENL_Vector:
            pDesc->Class = D3D10_SVC_VECTOR;
            break;
        case ENL_Scalar:
            pDesc->Class = D3D10_SVC_SCALAR;
            break;
        default:
            D3DXASSERT(0);
        }

        switch (NumericType.ScalarType)
        {
        case EST_Bool:
            pDesc->Type = D3D10_SVT_BOOL;
            break;
        case EST_Int:
            pDesc->Type = D3D10_SVT_INT;
            break;
        case EST_UInt:
            pDesc->Type = D3D10_SVT_UINT;
            break;
        case EST_Float:
            pDesc->Type = D3D10_SVT_FLOAT;
            break;
        default:
            D3DXASSERT(0);
        }

        pDesc->Rows = NumericType.Rows;
        pDesc->Columns = NumericType.Columns;
        pDesc->Members = 0;

        break;

    case EVT_Struct:
        pDesc->Rows = 0;
        pDesc->Columns = 0;
        pDesc->Members = StructType.Members;
        if( StructType.ImplementsInterface )
        {
            pDesc->Class = D3D11_SVC_INTERFACE_CLASS;
        }
        else
        {
            pDesc->Class = D3D10_SVC_STRUCT;
        }
        pDesc->Type = D3D10_SVT_VOID;
        break;

    case EVT_Interface:
        pDesc->Rows = 0;
        pDesc->Columns = 0;
        pDesc->Members = 0;
        pDesc->Class = D3D11_SVC_INTERFACE_POINTER;
        pDesc->Type = D3D11_SVT_INTERFACE_POINTER;
        break;

    case EVT_Object:
        pDesc->Rows = 0;
        pDesc->Columns = 0;
        pDesc->Members = 0;
        pDesc->Class = D3D10_SVC_OBJECT;            

        switch (ObjectType)
        {
        case EOT_String:
            pDesc->Type = D3D10_SVT_STRING;
            break;
        case EOT_Blend:
            pDesc->Type = D3D10_SVT_BLEND; 
            break;
        case EOT_DepthStencil:
            pDesc->Type = D3D10_SVT_DEPTHSTENCIL;
            break;
        case EOT_Rasterizer:
            pDesc->Type = D3D10_SVT_RASTERIZER;
            break;
        case EOT_PixelShader:
        case EOT_PixelShader5:
            pDesc->Type = D3D10_SVT_PIXELSHADER;
            break;
        case EOT_VertexShader:
        case EOT_VertexShader5:
            pDesc->Type = D3D10_SVT_VERTEXSHADER;
            break;
        case EOT_GeometryShader:
        case EOT_GeometryShaderSO:
        case EOT_GeometryShader5:
            pDesc->Type = D3D10_SVT_GEOMETRYSHADER;
            break;
        case EOT_HullShader5:
            pDesc->Type = D3D11_SVT_HULLSHADER;
            break;
        case EOT_DomainShader5:
            pDesc->Type = D3D11_SVT_DOMAINSHADER;
            break;
        case EOT_ComputeShader5:
            pDesc->Type = D3D11_SVT_COMPUTESHADER;
            break;
        case EOT_Texture:
            pDesc->Type = D3D10_SVT_TEXTURE;
            break;
        case EOT_Texture1D:
            pDesc->Type = D3D10_SVT_TEXTURE1D;
            break;
        case EOT_Texture1DArray:
            pDesc->Type = D3D10_SVT_TEXTURE1DARRAY;
            break;
        case EOT_Texture2D:
            pDesc->Type = D3D10_SVT_TEXTURE2D;
            break;
        case EOT_Texture2DArray:
            pDesc->Type = D3D10_SVT_TEXTURE2DARRAY;
            break;
        case EOT_Texture2DMS:
            pDesc->Type = D3D10_SVT_TEXTURE2DMS;
            break;
        case EOT_Texture2DMSArray:
            pDesc->Type = D3D10_SVT_TEXTURE2DMSARRAY;
            break;
        case EOT_Texture3D:
            pDesc->Type = D3D10_SVT_TEXTURE3D;
            break;
        case EOT_TextureCube:
            pDesc->Type = D3D10_SVT_TEXTURECUBE;
            break;
        case EOT_TextureCubeArray:
            pDesc->Type = D3D10_SVT_TEXTURECUBEARRAY;
            break;
        case EOT_Buffer:
            pDesc->Type = D3D10_SVT_BUFFER;
            break;
        case EOT_Sampler:
            pDesc->Type = D3D10_SVT_SAMPLER;
            break;
        case EOT_RenderTargetView:
            pDesc->Type = D3D10_SVT_RENDERTARGETVIEW;
            break;
        case EOT_DepthStencilView:
            pDesc->Type = D3D10_SVT_DEPTHSTENCILVIEW;
            break;
        case EOT_RWTexture1D:
            pDesc->Type = D3D11_SVT_RWTEXTURE1D;
            break;
        case EOT_RWTexture1DArray:
            pDesc->Type = D3D11_SVT_RWTEXTURE1DARRAY;
            break;
        case EOT_RWTexture2D:
            pDesc->Type = D3D11_SVT_RWTEXTURE2D;
            break;
        case EOT_RWTexture2DArray:
            pDesc->Type = D3D11_SVT_RWTEXTURE2DARRAY;
            break;
        case EOT_RWTexture3D:
            pDesc->Type = D3D11_SVT_RWTEXTURE3D;
            break;
        case EOT_RWBuffer:
            pDesc->Type = D3D11_SVT_RWBUFFER;
            break;
        case EOT_ByteAddressBuffer:
            pDesc->Type = D3D11_SVT_BYTEADDRESS_BUFFER;
            break;
        case EOT_RWByteAddressBuffer:
            pDesc->Type = D3D11_SVT_RWBYTEADDRESS_BUFFER;
            break;
        case EOT_StructuredBuffer:
            pDesc->Type = D3D11_SVT_STRUCTURED_BUFFER;
            break;
        case EOT_RWStructuredBuffer:
        case EOT_RWStructuredBufferAlloc:
        case EOT_RWStructuredBufferConsume:
            pDesc->Type = D3D11_SVT_RWSTRUCTURED_BUFFER;
            break;
        case EOT_AppendStructuredBuffer:
            pDesc->Type = D3D11_SVT_APPEND_STRUCTURED_BUFFER;
            break;
        case EOT_ConsumeStructuredBuffer:
            pDesc->Type = D3D11_SVT_CONSUME_STRUCTURED_BUFFER;
            break;

        default:
            D3DXASSERT(0);
        }
        break;

    default:
        D3DXASSERT(0);
    }

lExit:
    return hr;

}

////////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectShaderVariable (SAnonymousShader implementation)
////////////////////////////////////////////////////////////////////////////////

SAnonymousShader::SAnonymousShader(SShaderBlock *pBlock)
{
    pShaderBlock = pBlock;
}

BOOL SAnonymousShader::IsValid()
{
    return pShaderBlock && pShaderBlock->IsValid;
}

ID3DX11EffectType * SAnonymousShader::GetType()
{
    return (ID3DX11EffectType *) this;
}

HRESULT SAnonymousShader::GetDesc(D3DX11_EFFECT_VARIABLE_DESC *pDesc)
{
    pDesc->Annotations = 0;
    pDesc->Flags = 0;

    pDesc->Name = "$Anonymous";
    pDesc->Semantic = NULL;
    pDesc->BufferOffset = 0;

    return S_OK;
}

ID3DX11EffectVariable * SAnonymousShader::GetAnnotationByIndex(UINT Index)
{
    DPF(0, "ID3DX11EffectVariable::GetAnnotationByIndex: Anonymous shaders cannot have annotations");
    return &g_InvalidScalarVariable;
}

ID3DX11EffectVariable * SAnonymousShader::GetAnnotationByName(LPCSTR Name)
{
    DPF(0, "ID3DX11EffectVariable::GetAnnotationByName: Anonymous shaders cannot have annotations");
    return &g_InvalidScalarVariable;
}

ID3DX11EffectVariable * SAnonymousShader::GetMemberByIndex(UINT  Index)
{
    DPF(0, "ID3DX11EffectVariable::GetMemberByIndex: Variable is not a structure");
    return &g_InvalidScalarVariable;
}

ID3DX11EffectVariable * SAnonymousShader::GetMemberByName(LPCSTR Name)
{
    DPF(0, "ID3DX11EffectVariable::GetMemberByName: Variable is not a structure");
    return &g_InvalidScalarVariable;
}

ID3DX11EffectVariable * SAnonymousShader::GetMemberBySemantic(LPCSTR Semantic)
{
    DPF(0, "ID3DX11EffectVariable::GetMemberBySemantic: Variable is not a structure");
    return &g_InvalidScalarVariable;
}

ID3DX11EffectVariable * SAnonymousShader::GetElement(UINT Index)
{
    DPF(0, "ID3DX11EffectVariable::GetElement: Anonymous shaders cannot have elements");
    return &g_InvalidScalarVariable;
}

ID3DX11EffectConstantBuffer * SAnonymousShader::GetParentConstantBuffer()
{
    return NoParentCB();
}

ID3DX11EffectShaderVariable * SAnonymousShader::AsShader()
{
    return (ID3DX11EffectShaderVariable *) this;
}

HRESULT SAnonymousShader::SetRawValue(CONST void *pData, UINT Offset, UINT Count) 
{ 
    return ObjectSetRawValue(); 
}

HRESULT SAnonymousShader::GetRawValue(__out_bcount(Count) void *pData, UINT Offset, UINT Count) 
{ 
    return ObjectGetRawValue(); 
}

#define ANONYMOUS_SHADER_INDEX_CHECK() \
    HRESULT hr = S_OK; \
    if (0 != ShaderIndex) \
    { \
        DPF(0, "%s: Invalid index specified", pFuncName); \
        VH(E_INVALIDARG); \
    } \

HRESULT SAnonymousShader::GetShaderDesc(UINT ShaderIndex, D3DX11_EFFECT_SHADER_DESC *pDesc)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetShaderDesc";

    ANONYMOUS_SHADER_INDEX_CHECK();

    pShaderBlock->GetShaderDesc(pDesc, TRUE);

lExit:
    return hr;
}

HRESULT SAnonymousShader::GetVertexShader(UINT ShaderIndex, ID3D11VertexShader **ppVS)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetVertexShader";

    ANONYMOUS_SHADER_INDEX_CHECK();

    VH( pShaderBlock->GetVertexShader(ppVS) );

lExit:
    return hr;
}

HRESULT SAnonymousShader::GetGeometryShader(UINT ShaderIndex, ID3D11GeometryShader **ppGS)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetGeometryShader";

    ANONYMOUS_SHADER_INDEX_CHECK();

    VH( pShaderBlock->GetGeometryShader(ppGS) );

lExit:
    return hr;
}

HRESULT SAnonymousShader::GetPixelShader(UINT ShaderIndex, ID3D11PixelShader **ppPS)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetPixelShader";

    ANONYMOUS_SHADER_INDEX_CHECK();

    VH( pShaderBlock->GetPixelShader(ppPS) );

lExit:
    return hr;
}

HRESULT SAnonymousShader::GetHullShader(UINT ShaderIndex, ID3D11HullShader **ppHS)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetHullShader";

    ANONYMOUS_SHADER_INDEX_CHECK();

    VH( pShaderBlock->GetHullShader(ppHS) );

lExit:
    return hr;
}

HRESULT SAnonymousShader::GetDomainShader(UINT ShaderIndex, ID3D11DomainShader **ppCS)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetDomainShader";

    ANONYMOUS_SHADER_INDEX_CHECK();

    VH( pShaderBlock->GetDomainShader(ppCS) );

lExit:
    return hr;
}

HRESULT SAnonymousShader::GetComputeShader(UINT ShaderIndex, ID3D11ComputeShader **ppCS)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetComputeShader";

    ANONYMOUS_SHADER_INDEX_CHECK();

    VH( pShaderBlock->GetComputeShader(ppCS) );

lExit:
    return hr;
}

HRESULT SAnonymousShader::GetInputSignatureElementDesc(UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetInputSignatureElementDesc";

    ANONYMOUS_SHADER_INDEX_CHECK();

    VH( pShaderBlock->GetSignatureElementDesc(SShaderBlock::ST_Input, Element, pDesc) );

lExit:
    return hr;
}

HRESULT SAnonymousShader::GetOutputSignatureElementDesc(UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetOutputSignatureElementDesc";

    ANONYMOUS_SHADER_INDEX_CHECK();

    VH( pShaderBlock->GetSignatureElementDesc(SShaderBlock::ST_Output, Element, pDesc) );

lExit:
    return hr;
}

HRESULT SAnonymousShader::GetPatchConstantSignatureElementDesc(UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetPatchConstantSignatureElementDesc";

    ANONYMOUS_SHADER_INDEX_CHECK();

    VH( pShaderBlock->GetSignatureElementDesc(SShaderBlock::ST_PatchConstant, Element, pDesc) );

lExit:
    return hr;
}

HRESULT SAnonymousShader::GetDesc(D3DX11_EFFECT_TYPE_DESC *pDesc)
{
    pDesc->Class = D3D10_SVC_OBJECT;

    switch (pShaderBlock->GetShaderType())
    {
    case EOT_VertexShader:
    case EOT_VertexShader5:
        pDesc->TypeName = "vertexshader";
        pDesc->Type = D3D10_SVT_VERTEXSHADER;
        break;
    case EOT_GeometryShader:
    case EOT_GeometryShader5:
        pDesc->TypeName = "geometryshader";
        pDesc->Type = D3D10_SVT_GEOMETRYSHADER;
        break;
    case EOT_PixelShader:
    case EOT_PixelShader5:
        pDesc->TypeName = "pixelshader";
        pDesc->Type = D3D10_SVT_PIXELSHADER;
        break;
    case EOT_HullShader5:
        pDesc->TypeName = "Hullshader";
        pDesc->Type = D3D11_SVT_HULLSHADER;
        break;
    case EOT_DomainShader5:
        pDesc->TypeName = "Domainshader";
        pDesc->Type = D3D11_SVT_DOMAINSHADER;
        break;
    case EOT_ComputeShader5:
        pDesc->TypeName = "Computeshader";
        pDesc->Type = D3D11_SVT_COMPUTESHADER;
        break;
    }

    pDesc->Elements = 0;
    pDesc->Members = 0;
    pDesc->Rows = 0;
    pDesc->Columns = 0;
    pDesc->PackedSize = 0;
    pDesc->UnpackedSize = 0;
    pDesc->Stride = 0;

    return S_OK;
}

ID3DX11EffectType * SAnonymousShader::GetMemberTypeByIndex(UINT  Index)
{
    DPF(0, "ID3DX11EffectType::GetMemberTypeByIndex: This interface does not refer to a structure");
    return &g_InvalidType;
}

ID3DX11EffectType * SAnonymousShader::GetMemberTypeByName(LPCSTR Name)
{
    DPF(0, "ID3DX11EffectType::GetMemberTypeByName: This interface does not refer to a structure");
    return &g_InvalidType;
}

ID3DX11EffectType * SAnonymousShader::GetMemberTypeBySemantic(LPCSTR Semantic)
{
    DPF(0, "ID3DX11EffectType::GetMemberTypeBySemantic: This interface does not refer to a structure");
    return &g_InvalidType;
}

LPCSTR SAnonymousShader::GetMemberName(UINT Index)
{
    DPF(0, "ID3DX11EffectType::GetMemberName: This interface does not refer to a structure");
    return NULL;
}

LPCSTR SAnonymousShader::GetMemberSemantic(UINT Index)
{
    DPF(0, "ID3DX11EffectType::GetMemberSemantic: This interface does not refer to a structure");
    return NULL;
}

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectConstantBuffer (SConstantBuffer implementation)
//////////////////////////////////////////////////////////////////////////

BOOL SConstantBuffer::IsValid()
{
    return TRUE;
}

ID3DX11EffectType * SConstantBuffer::GetType()
{
    return (ID3DX11EffectType *) this;
}

HRESULT SConstantBuffer::GetDesc(D3DX11_EFFECT_VARIABLE_DESC *pDesc)
{
    pDesc->Annotations = AnnotationCount;
    pDesc->Flags = 0;

    pDesc->Name = pName;
    pDesc->Semantic = NULL;
    pDesc->BufferOffset = 0;

    if (ExplicitBindPoint != -1)
    {
        pDesc->ExplicitBindPoint = ExplicitBindPoint;
        pDesc->Flags |= D3DX11_EFFECT_VARIABLE_EXPLICIT_BIND_POINT;
    }
    else
    {
        pDesc->ExplicitBindPoint = 0;
    }

    return S_OK;
}

ID3DX11EffectVariable * SConstantBuffer::GetAnnotationByIndex(UINT  Index)
{
    return GetAnnotationByIndexHelper("ID3DX11EffectVariable", Index, AnnotationCount, pAnnotations);
}

ID3DX11EffectVariable * SConstantBuffer::GetAnnotationByName(LPCSTR Name)
{
    return GetAnnotationByNameHelper("ID3DX11EffectVariable", Name, AnnotationCount, pAnnotations);
}

ID3DX11EffectVariable * SConstantBuffer::GetMemberByIndex(UINT  Index)
{
    SGlobalVariable *pMember;
    UDataPointer dataPtr;

    if (IsEffectOptimized)
    {
        DPF(0, "ID3DX11EffectVariable::GetMemberByIndex: Cannot get members; effect has been Optimize()'ed");
        return &g_InvalidScalarVariable;
    }

    if (!GetVariableByIndexHelper<SGlobalVariable>(Index, VariableCount, (SGlobalVariable*)pVariables, 
        NULL, &pMember, &dataPtr.pGeneric))
    {
        return &g_InvalidScalarVariable;
    }

    return (ID3DX11EffectVariable *) pMember;
}

ID3DX11EffectVariable * SConstantBuffer::GetMemberByName(LPCSTR Name)
{
    SGlobalVariable *pMember;
    UDataPointer dataPtr;
    UINT index;

    if (IsEffectOptimized)
    {
        DPF(0, "ID3DX11EffectVariable::GetMemberByName: Cannot get members; effect has been Optimize()'ed");
        return &g_InvalidScalarVariable;
    }

    if (!GetVariableByNameHelper<SGlobalVariable>(Name, VariableCount, (SGlobalVariable*)pVariables, 
        NULL, &pMember, &dataPtr.pGeneric, &index))
    {
        return &g_InvalidScalarVariable;
    }

    return (ID3DX11EffectVariable *) pMember;
}

ID3DX11EffectVariable * SConstantBuffer::GetMemberBySemantic(LPCSTR Semantic)
{
    SGlobalVariable *pMember;
    UDataPointer dataPtr;
    UINT index;

    if (IsEffectOptimized)
    {
        DPF(0, "ID3DX11EffectVariable::GetMemberBySemantic: Cannot get members; effect has been Optimize()'ed");
        return &g_InvalidScalarVariable;
    }

    if (!GetVariableBySemanticHelper<SGlobalVariable>(Semantic, VariableCount, (SGlobalVariable*)pVariables, 
        NULL, &pMember, &dataPtr.pGeneric, &index))
    {
        return &g_InvalidScalarVariable;
    }

    return (ID3DX11EffectVariable *) pMember;
}

ID3DX11EffectVariable * SConstantBuffer::GetElement(UINT  Index)
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::GetElement";
    DPF(0, "%s: This interface does not refer to an array", pFuncName);
    return &g_InvalidScalarVariable;
}

ID3DX11EffectConstantBuffer * SConstantBuffer::GetParentConstantBuffer()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::GetParentConstantBuffer";
    DPF(0, "%s: Constant buffers do not have parent constant buffers", pFuncName);
    return &g_InvalidConstantBuffer;
}

ID3DX11EffectConstantBuffer * SConstantBuffer::AsConstantBuffer()
{
    return (ID3DX11EffectConstantBuffer *) this;
}

HRESULT SConstantBuffer::GetDesc(D3DX11_EFFECT_TYPE_DESC *pDesc)
{
    pDesc->TypeName = IsTBuffer ? "tbuffer" : "cbuffer";
    pDesc->Class = D3D10_SVC_OBJECT;
    pDesc->Type = IsTBuffer ? D3D10_SVT_TBUFFER : D3D10_SVT_CBUFFER;

    pDesc->Elements = 0;
    pDesc->Members = VariableCount;
    pDesc->Rows = 0;
    pDesc->Columns = 0;

    UINT  i;
    pDesc->PackedSize = 0;
    for (i = 0; i < VariableCount; ++ i)
    {
        pDesc->PackedSize += pVariables[i].pType->PackedSize;
    }

    pDesc->UnpackedSize = Size;
    D3DXASSERT(pDesc->UnpackedSize >= pDesc->PackedSize);

    pDesc->Stride = AlignToPowerOf2(pDesc->UnpackedSize, SType::c_RegisterSize);

    return S_OK;
}

ID3DX11EffectType * SConstantBuffer::GetMemberTypeByIndex(UINT  Index)
{
    return GetTypeByIndexHelper(Index, VariableCount, pVariables, sizeof (SGlobalVariable));
}

ID3DX11EffectType * SConstantBuffer::GetMemberTypeByName(LPCSTR Name)
{
    return GetTypeByNameHelper(Name, VariableCount, pVariables, sizeof (SGlobalVariable));
}

ID3DX11EffectType * SConstantBuffer::GetMemberTypeBySemantic(LPCSTR Semantic)
{
    return GetTypeBySemanticHelper(Semantic, VariableCount, pVariables, sizeof (SGlobalVariable));
}

LPCSTR SConstantBuffer::GetMemberName(UINT Index)
{
    LPCSTR pFuncName = "ID3DX11EffectType::GetMemberName";

    if (IsEffectOptimized)
    {
        DPF(0, "%s: Cannot get member names; Effect has been Optimize()'ed", pFuncName);
        return NULL;
    }

    if (Index >= VariableCount)
    {
        DPF(0, "%s: Invalid index (%d, total: %d)", pFuncName, Index, VariableCount);
        return NULL;
    }

    return pVariables[Index].pName;
}

LPCSTR SConstantBuffer::GetMemberSemantic(UINT Index)
{
    LPCSTR pFuncName = "ID3DX11EffectType::GetMemberSemantic";

    if (IsEffectOptimized)
    {
        DPF(0, "%s: Cannot get member semantics; Effect has been Optimize()'ed", pFuncName);
        return NULL;
    }

    if (Index >= VariableCount)
    {
        DPF(0, "%s: Invalid index (%d, total: %d)", pFuncName, Index, VariableCount);
        return NULL;
    }

    return pVariables[Index].pSemantic;
}

HRESULT SConstantBuffer::SetRawValue(CONST void *pData, UINT  Offset, UINT  Count)
{
    HRESULT hr = S_OK;    

#ifdef _DEBUG
    LPCSTR pFuncName = "ID3DX11EffectVariable::SetRawValue";

    VERIFYPARAMETER(pData);

    if ((Offset + Count < Offset) ||
        (Count + (BYTE*)pData < (BYTE*)pData) ||
        ((Offset + Count) > Size))
    {
        // overflow of some kind
        DPF(0, "%s: Invalid range specified", pFuncName);
        VH(E_INVALIDARG);
    }
#endif

    if (IsUsedByExpression)
    {
        UINT  i;
        for (i = 0; i < VariableCount; ++ i)
        {
            ((SGlobalVariable*)pVariables)[i].DirtyVariable();
        }
    }
    else
    {
        IsDirty = TRUE;
    }

    memcpy(pBackingStore + Offset, pData, Count);

lExit:
    return hr;
}

HRESULT SConstantBuffer::GetRawValue(__out_bcount(Count) void *pData, UINT  Offset, UINT  Count)
{
    HRESULT hr = S_OK;    

#ifdef _DEBUG
    LPCSTR pFuncName = "ID3DX11EffectVariable::GetRawValue";

    VERIFYPARAMETER(pData);

    if ((Offset + Count < Offset) ||
        (Count + (BYTE*)pData < (BYTE*)pData) ||
        ((Offset + Count) > Size))
    {
        // overflow of some kind
        DPF(0, "%s: Invalid range specified", pFuncName);
        VH(E_INVALIDARG);
    }
#endif

    memcpy(pData, pBackingStore + Offset, Count);

lExit:
    return hr;
}

bool SConstantBuffer::ClonedSingle() const
{
    return IsSingle && ( pEffect->m_Flags & D3DX11_EFFECT_CLONE );
}

HRESULT SConstantBuffer::SetConstantBuffer(ID3D11Buffer *pConstantBuffer)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectConstantBuffer::SetConstantBuffer";

    if (IsTBuffer)
    {
        DPF(0, "%s: This is a texture buffer; use SetTextureBuffer instead", pFuncName);
        VH(D3DERR_INVALIDCALL);
    }

    // Replace all references to the old shader block with this one
    pEffect->ReplaceCBReference(this, pConstantBuffer);

    if( !IsUserManaged )
    {
        // Save original cbuffer in case we UndoSet
        D3DXASSERT( pMemberData[0].Type == MDT_Buffer );
        VB( pMemberData[0].Data.pD3DEffectsManagedConstantBuffer == NULL );
        pMemberData[0].Data.pD3DEffectsManagedConstantBuffer = pD3DObject;
        pD3DObject = NULL;
        IsUserManaged = TRUE;
        IsNonUpdatable = TRUE;
    }

    SAFE_ADDREF( pConstantBuffer );
    SAFE_RELEASE( pD3DObject );
    pD3DObject = pConstantBuffer;

lExit:
    return hr;
}

HRESULT SConstantBuffer::GetConstantBuffer(ID3D11Buffer **ppConstantBuffer)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectConstantBuffer::GetConstantBuffer";

    VERIFYPARAMETER(ppConstantBuffer);

    if (IsTBuffer)
    {
        DPF(0, "%s: This is a texture buffer; use GetTextureBuffer instead", pFuncName);
        VH(D3DERR_INVALIDCALL);
    }

    *ppConstantBuffer = pD3DObject;
    SAFE_ADDREF(*ppConstantBuffer);

lExit:
    return hr;
}

HRESULT SConstantBuffer::UndoSetConstantBuffer() 
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectConstantBuffer::UndoSetConstantBuffer";

    if (IsTBuffer)
    {
        DPF(0, "%s: This is a texture buffer; use UndoSetTextureBuffer instead", pFuncName);
        VH(D3DERR_INVALIDCALL);
    }

    if( !IsUserManaged )
    {
        return S_FALSE;
    }

    // Replace all references to the old shader block with this one
    pEffect->ReplaceCBReference(this, pMemberData[0].Data.pD3DEffectsManagedConstantBuffer);

    // Revert to original cbuffer
    SAFE_RELEASE( pD3DObject );
    pD3DObject = pMemberData[0].Data.pD3DEffectsManagedConstantBuffer;
    pMemberData[0].Data.pD3DEffectsManagedConstantBuffer = NULL;
    IsUserManaged = FALSE;
    IsNonUpdatable = ClonedSingle();

lExit:
    return hr;
}

HRESULT SConstantBuffer::SetTextureBuffer(ID3D11ShaderResourceView *pTextureBuffer)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectConstantBuffer::SetTextureBuffer";

    if (!IsTBuffer)
    {
        DPF(0, "%s: This is a constant buffer; use SetConstantBuffer instead", pFuncName);
        VH(D3DERR_INVALIDCALL);
    }

    if( !IsUserManaged )
    {
        // Save original cbuffer and tbuffer in case we UndoSet
        D3DXASSERT( pMemberData[0].Type == MDT_Buffer );
        VB( pMemberData[0].Data.pD3DEffectsManagedConstantBuffer == NULL );
        pMemberData[0].Data.pD3DEffectsManagedConstantBuffer = pD3DObject;
        pD3DObject = NULL;
        D3DXASSERT( pMemberData[1].Type == MDT_ShaderResourceView );
        VB( pMemberData[1].Data.pD3DEffectsManagedTextureBuffer == NULL );
        pMemberData[1].Data.pD3DEffectsManagedTextureBuffer = TBuffer.pShaderResource;
        TBuffer.pShaderResource = NULL;
        IsUserManaged = TRUE;
        IsNonUpdatable = TRUE;
    }

    SAFE_ADDREF( pTextureBuffer );
    SAFE_RELEASE(pD3DObject); // won't be needing this anymore...
    SAFE_RELEASE( TBuffer.pShaderResource );
    TBuffer.pShaderResource = pTextureBuffer;

lExit:
    return hr;
}

HRESULT SConstantBuffer::GetTextureBuffer(ID3D11ShaderResourceView **ppTextureBuffer)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectConstantBuffer::GetTextureBuffer";

    VERIFYPARAMETER(ppTextureBuffer);

    if (!IsTBuffer)
    {
        DPF(0, "%s: This is a constant buffer; use GetConstantBuffer instead", pFuncName);
        VH(D3DERR_INVALIDCALL);
    }

    *ppTextureBuffer = TBuffer.pShaderResource;
    SAFE_ADDREF(*ppTextureBuffer);

lExit:
    return hr;
}

HRESULT SConstantBuffer::UndoSetTextureBuffer()
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectConstantBuffer::UndoSetTextureBuffer";

    if (!IsTBuffer)
    {
        DPF(0, "%s: This is a texture buffer; use UndoSetConstantBuffer instead", pFuncName);
        VH(D3DERR_INVALIDCALL);
    }

    if( !IsUserManaged )
    {
        return S_FALSE;
    }

    // Revert to original cbuffer
    SAFE_RELEASE( pD3DObject );
    pD3DObject = pMemberData[0].Data.pD3DEffectsManagedConstantBuffer;
    pMemberData[0].Data.pD3DEffectsManagedConstantBuffer = NULL;
    SAFE_RELEASE( TBuffer.pShaderResource );
    TBuffer.pShaderResource = pMemberData[1].Data.pD3DEffectsManagedTextureBuffer;
    pMemberData[1].Data.pD3DEffectsManagedTextureBuffer = NULL;
    IsUserManaged = FALSE;
    IsNonUpdatable = ClonedSingle();

lExit:
    return hr;
}

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectPass (CEffectPass implementation)
//////////////////////////////////////////////////////////////////////////

BOOL SPassBlock::IsValid()
{
    if( HasDependencies )
        return pEffect->ValidatePassBlock( this );
    return InitiallyValid;
}

HRESULT SPassBlock::GetDesc(D3DX11_PASS_DESC *pDesc)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectPass::GetDesc";

    VERIFYPARAMETER(pDesc);

    ZeroMemory(pDesc, sizeof(*pDesc));

    pDesc->Name = pName;
    pDesc->Annotations = AnnotationCount;
    
    SAssignment *pAssignment;
    SAssignment *pLastAssn;

    pEffect->IncrementTimer();

    pAssignment = pAssignments;
    pLastAssn = pAssignments + AssignmentCount;

    for(; pAssignment < pLastAssn; pAssignment++)
    {
        pEffect->EvaluateAssignment(pAssignment);
    }

    if( BackingStore.pVertexShaderBlock && BackingStore.pVertexShaderBlock->pInputSignatureBlob )
    {
        // pInputSignatureBlob can be null if we're setting a NULL VS "SetVertexShader( NULL )"
        pDesc->pIAInputSignature = (BYTE*)BackingStore.pVertexShaderBlock->pInputSignatureBlob->GetBufferPointer();
        pDesc->IAInputSignatureSize = BackingStore.pVertexShaderBlock->pInputSignatureBlob->GetBufferSize();
    }

    pDesc->StencilRef = BackingStore.StencilRef;
    pDesc->SampleMask = BackingStore.SampleMask;
    pDesc->BlendFactor[0] = BackingStore.BlendFactor[0];
    pDesc->BlendFactor[1] = BackingStore.BlendFactor[1];
    pDesc->BlendFactor[2] = BackingStore.BlendFactor[2];
    pDesc->BlendFactor[3] = BackingStore.BlendFactor[3];

lExit:
    return hr;
}

extern SShaderBlock g_NullVS;
extern SShaderBlock g_NullGS;
extern SShaderBlock g_NullPS;
extern SShaderBlock g_NullHS;
extern SShaderBlock g_NullDS;
extern SShaderBlock g_NullCS;

SAnonymousShader g_AnonymousNullVS(&g_NullVS);
SAnonymousShader g_AnonymousNullGS(&g_NullGS);
SAnonymousShader g_AnonymousNullPS(&g_NullPS);
SAnonymousShader g_AnonymousNullHS(&g_NullHS);
SAnonymousShader g_AnonymousNullDS(&g_NullDS);
SAnonymousShader g_AnonymousNullCS(&g_NullCS);

template<EObjectType EShaderType>
HRESULT SPassBlock::GetShaderDescHelper(D3DX11_PASS_SHADER_DESC *pDesc)
{
    HRESULT hr = S_OK;
    UINT  i;
    LPCSTR pFuncName = NULL;
    SShaderBlock *pShaderBlock = NULL;

    ApplyPassAssignments();

    switch (EShaderType)
    {
    case EOT_VertexShader:
    case EOT_VertexShader5:
#pragma prefast(suppress:__WARNING_UNUSED_POINTER_ASSIGNMENT, "pFuncName used in DPF")
        pFuncName = "ID3DX11EffectPass::GetVertexShaderDesc";
        pShaderBlock = BackingStore.pVertexShaderBlock;
        break;
    case EOT_PixelShader:
    case EOT_PixelShader5:
#pragma prefast(suppress:__WARNING_UNUSED_POINTER_ASSIGNMENT, "pFuncName used in DPF")
        pFuncName = "ID3DX11EffectPass::GetPixelShaderDesc";
        pShaderBlock = BackingStore.pPixelShaderBlock;
        break;
    case EOT_GeometryShader:
    case EOT_GeometryShader5:
#pragma prefast(suppress:__WARNING_UNUSED_POINTER_ASSIGNMENT, "pFuncName used in DPF")
        pFuncName = "ID3DX11EffectPass::GetGeometryShaderDesc";
        pShaderBlock = BackingStore.pGeometryShaderBlock;
        break;
    case EOT_HullShader5:
#pragma prefast(suppress:__WARNING_UNUSED_POINTER_ASSIGNMENT, "pFuncName used in DPF")
        pFuncName = "ID3DX11EffectPass::GetHullShaderDesc";
        pShaderBlock = BackingStore.pHullShaderBlock;
        break;
    case EOT_DomainShader5:
#pragma prefast(suppress:__WARNING_UNUSED_POINTER_ASSIGNMENT, "pFuncName used in DPF")
        pFuncName = "ID3DX11EffectPass::GetDomainShaderDesc";
        pShaderBlock = BackingStore.pDomainShaderBlock;
        break;
    case EOT_ComputeShader5:
#pragma prefast(suppress:__WARNING_UNUSED_POINTER_ASSIGNMENT, "pFuncName used in DPF")
        pFuncName = "ID3DX11EffectPass::GetComputeShaderDesc";
        pShaderBlock = BackingStore.pComputeShaderBlock;
        break;
    default:
        D3DXASSERT(0);
    }

    VERIFYPARAMETER(pDesc);

    // in case of error (or in case the assignment doesn't exist), return something reasonable
    pDesc->pShaderVariable = &g_InvalidShaderVariable;
    pDesc->ShaderIndex = 0;

    if (NULL != pShaderBlock)
    {
        UINT elements, varCount, anonymousShaderCount;
        SGlobalVariable *pVariables;
        SAnonymousShader *pAnonymousShaders;

        if (pShaderBlock == &g_NullVS)
        {
            pDesc->pShaderVariable = &g_AnonymousNullVS;
            pDesc->ShaderIndex = 0;
            // we're done
            goto lExit;
        }
        else if (pShaderBlock == &g_NullGS)
        {
            pDesc->pShaderVariable = &g_AnonymousNullGS;
            pDesc->ShaderIndex = 0;
            // we're done
            goto lExit;
        }
        else if (pShaderBlock == &g_NullPS)
        {
            pDesc->pShaderVariable = &g_AnonymousNullPS;
            pDesc->ShaderIndex = 0;
            // we're done
            goto lExit;
        }
        else if (pShaderBlock == &g_NullHS)
        {
            pDesc->pShaderVariable = &g_AnonymousNullHS;
            pDesc->ShaderIndex = 0;
            // we're done
            goto lExit;
        }
        else if (pShaderBlock == &g_NullDS)
        {
            pDesc->pShaderVariable = &g_AnonymousNullDS;
            pDesc->ShaderIndex = 0;
            // we're done
            goto lExit;
        }
        else if (pShaderBlock == &g_NullCS)
        {
            pDesc->pShaderVariable = &g_AnonymousNullCS;
            pDesc->ShaderIndex = 0;
            // we're done
            goto lExit;
        }
        else 
        {
            VB( pEffect->IsRuntimeData(pShaderBlock) );
            varCount = pEffect->m_VariableCount;
            pVariables = pEffect->m_pVariables;
            anonymousShaderCount = pEffect->m_AnonymousShaderCount;
            pAnonymousShaders = pEffect->m_pAnonymousShaders;
        }

        for (i = 0; i < varCount; ++ i)
        {
            elements = max(1, pVariables[i].pType->Elements);
            // make sure the variable type matches, and don't forget about GeometryShaderSO's
            if (pVariables[i].pType->IsShader())
            {
                if (pShaderBlock >= pVariables[i].Data.pShader && pShaderBlock < pVariables[i].Data.pShader + elements)
                {
                    pDesc->pShaderVariable = (ID3DX11EffectShaderVariable *)(pVariables + i);
                    pDesc->ShaderIndex = (UINT)(UINT_PTR)(pShaderBlock - pVariables[i].Data.pShader);
                    // we're done
                    goto lExit;
                }
            }
        }

        for (i = 0; i < anonymousShaderCount; ++ i)
        {
            if (pShaderBlock == pAnonymousShaders[i].pShaderBlock)
            {
                VB(EShaderType == pAnonymousShaders[i].pShaderBlock->GetShaderType())
                pDesc->pShaderVariable = (pAnonymousShaders + i);
                pDesc->ShaderIndex = 0;
                // we're done
                goto lExit;
            }
        }

        DPF(0, "%s: Internal error; shader not found", pFuncName);
        VH( E_FAIL );
    }

lExit:
    return hr;
}

HRESULT SPassBlock::GetVertexShaderDesc(D3DX11_PASS_SHADER_DESC *pDesc)
{
    return GetShaderDescHelper<EOT_VertexShader>(pDesc);
}

HRESULT SPassBlock::GetPixelShaderDesc(D3DX11_PASS_SHADER_DESC *pDesc)
{
    return GetShaderDescHelper<EOT_PixelShader>(pDesc);
}

HRESULT SPassBlock::GetGeometryShaderDesc(D3DX11_PASS_SHADER_DESC *pDesc)
{
    return GetShaderDescHelper<EOT_GeometryShader>(pDesc);
}

HRESULT SPassBlock::GetHullShaderDesc(D3DX11_PASS_SHADER_DESC *pDesc)
{
    return GetShaderDescHelper<EOT_HullShader5>(pDesc);
}

HRESULT SPassBlock::GetDomainShaderDesc(D3DX11_PASS_SHADER_DESC *pDesc)
{
    return GetShaderDescHelper<EOT_DomainShader5>(pDesc);
}

HRESULT SPassBlock::GetComputeShaderDesc(D3DX11_PASS_SHADER_DESC *pDesc)
{
    return GetShaderDescHelper<EOT_ComputeShader5>(pDesc);
}

ID3DX11EffectVariable * SPassBlock::GetAnnotationByIndex(UINT  Index)
{
    return GetAnnotationByIndexHelper("ID3DX11EffectPass", Index, AnnotationCount, pAnnotations);
}

ID3DX11EffectVariable * SPassBlock::GetAnnotationByName(LPCSTR Name)
{
    return GetAnnotationByNameHelper("ID3DX11EffectPass", Name, AnnotationCount, pAnnotations);
}

HRESULT SPassBlock::Apply(UINT  Flags, ID3D11DeviceContext* pContext)
{
    HRESULT hr = S_OK;

    // TODO: Flags are not yet implemented    

    D3DXASSERT( pEffect->m_pContext == NULL );
    pEffect->m_pContext = pContext;
    pEffect->ApplyPassBlock(this);
    pEffect->m_pContext = NULL;

lExit:
    return hr;
}

HRESULT SPassBlock::ComputeStateBlockMask(D3DX11_STATE_BLOCK_MASK *pStateBlockMask)
{
    HRESULT hr = S_OK;
    UINT i, j;
    
    // flags indicating whether the following shader types were caught by assignment checks or not
    BOOL bVS = FALSE, bGS = FALSE, bPS = FALSE, bHS = FALSE, bDS = FALSE, bCS = FALSE;

    for (i = 0; i < AssignmentCount; ++ i)
    {
        BOOL bShader = FALSE;
        
        switch (pAssignments[i].LhsType)
        {
        case ELHS_VertexShaderBlock:
            bVS = TRUE;
            bShader = TRUE;
            break;
        case ELHS_GeometryShaderBlock:
            bGS = TRUE;
            bShader = TRUE;
            break;
        case ELHS_PixelShaderBlock:
            bPS = TRUE;
            bShader = TRUE;
            break;
        case ELHS_HullShaderBlock:
            bHS = TRUE;
            bShader = TRUE;
            break;
        case ELHS_DomainShaderBlock:
            bDS = TRUE;
            bShader = TRUE;
            break;
        case ELHS_ComputeShaderBlock:
            bCS = TRUE;
            bShader = TRUE;
            break;

        case ELHS_RasterizerBlock:
            pStateBlockMask->RSRasterizerState = 1;
            break;
        case ELHS_BlendBlock:
            pStateBlockMask->OMBlendState = 1;
            break;
        case ELHS_DepthStencilBlock:
            pStateBlockMask->OMDepthStencilState = 1;
            break;

        default:            
            // ignore this assignment (must be a scalar/vector assignment associated with a state object)
            break;
        }

        if (bShader)
        {
            for (j = 0; j < pAssignments[i].MaxElements; ++ j)
            {
                // compute state block mask for the union of ALL shaders
                VH( pAssignments[i].Source.pShader[j].ComputeStateBlockMask(pStateBlockMask) );
            }
        }
    }

    // go over the state block objects in case there was no corresponding assignment
    if (NULL != BackingStore.pRasterizerBlock)
    {
        pStateBlockMask->RSRasterizerState = 1;
    }
    if (NULL != BackingStore.pBlendBlock)
    {
        pStateBlockMask->OMBlendState = 1;
    }
    if (NULL != BackingStore.pDepthStencilBlock)
    {
        pStateBlockMask->OMDepthStencilState = 1;
    }

    // go over the shaders only if an assignment didn't already catch them
    if (FALSE == bVS && NULL != BackingStore.pVertexShaderBlock)
    {
        VH( BackingStore.pVertexShaderBlock->ComputeStateBlockMask(pStateBlockMask) );
    }
    if (FALSE == bGS && NULL != BackingStore.pGeometryShaderBlock)
    {
        VH( BackingStore.pGeometryShaderBlock->ComputeStateBlockMask(pStateBlockMask) );
    }
    if (FALSE == bPS && NULL != BackingStore.pPixelShaderBlock)
    {
        VH( BackingStore.pPixelShaderBlock->ComputeStateBlockMask(pStateBlockMask) );
    }
    if (FALSE == bHS && NULL != BackingStore.pHullShaderBlock)
    {
        VH( BackingStore.pHullShaderBlock->ComputeStateBlockMask(pStateBlockMask) );
    }
    if (FALSE == bDS && NULL != BackingStore.pDomainShaderBlock)
    {
        VH( BackingStore.pDomainShaderBlock->ComputeStateBlockMask(pStateBlockMask) );
    }
    if (FALSE == bCS && NULL != BackingStore.pComputeShaderBlock)
    {
        VH( BackingStore.pComputeShaderBlock->ComputeStateBlockMask(pStateBlockMask) );
    }
    
lExit:
    return hr;
}

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectTechnique (STechnique implementation)
//////////////////////////////////////////////////////////////////////////

BOOL STechnique::IsValid()
{ 
    if( HasDependencies )
    {
        for( UINT i = 0; i < PassCount; i++ )
        {
            if( !((SPassBlock*)pPasses)[i].IsValid() )
                return FALSE;
        }
        return TRUE;
    }
    return InitiallyValid;
}

HRESULT STechnique::GetDesc(D3DX11_TECHNIQUE_DESC *pDesc)
{
    HRESULT hr = S_OK;

    LPCSTR pFuncName = "ID3DX11EffectTechnique::GetDesc";

    VERIFYPARAMETER(pDesc);

    pDesc->Name = pName;
    pDesc->Annotations = AnnotationCount;
    pDesc->Passes = PassCount;

lExit:
    return hr;
}

ID3DX11EffectVariable * STechnique::GetAnnotationByIndex(UINT  Index)
{
    return GetAnnotationByIndexHelper("ID3DX11EffectTechnique", Index, AnnotationCount, pAnnotations);
}

ID3DX11EffectVariable * STechnique::GetAnnotationByName(LPCSTR Name)
{
    return GetAnnotationByNameHelper("ID3DX11EffectTechnique", Name, AnnotationCount, pAnnotations);
}

ID3DX11EffectPass * STechnique::GetPassByIndex(UINT  Index)
{
    LPCSTR pFuncName = "ID3DX11EffectTechnique::GetPassByIndex";

    if (Index >= PassCount)
    {
        DPF(0, "%s: Invalid pass index (%d, total: %d)", pFuncName, Index, PassCount);
        return &g_InvalidPass;
    }

    return (ID3DX11EffectPass *)(pPasses + Index);
}

ID3DX11EffectPass * STechnique::GetPassByName(LPCSTR Name)
{
    LPCSTR pFuncName = "ID3DX11EffectTechnique::GetPassByName";

    UINT  i;

    for (i = 0; i < PassCount; ++ i)
    {
        if (NULL != pPasses[i].pName &&
            strcmp(pPasses[i].pName, Name) == 0)
        {
            break;
        }
    }

    if (i == PassCount)
    {
        DPF(0, "%s: Pass [%s] not found", pFuncName, Name);
        return &g_InvalidPass;
    }

    return (ID3DX11EffectPass *)(pPasses + i);
}

HRESULT STechnique::ComputeStateBlockMask(D3DX11_STATE_BLOCK_MASK *pStateBlockMask)
{
    HRESULT hr = S_OK;
    UINT i;

    for (i = 0; i < PassCount; ++ i)
    {
        VH( ((SPassBlock*)pPasses)[i].ComputeStateBlockMask(pStateBlockMask) );
    }

lExit:
    return hr;
}

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectGroup (SGroup implementation)
//////////////////////////////////////////////////////////////////////////

BOOL SGroup::IsValid()
{ 
    if( HasDependencies )
    {
        for( UINT i = 0; i < TechniqueCount; i++ )
        {
            if( !((STechnique*)pTechniques)[i].IsValid() )
                return FALSE;
        }
        return TRUE;
    }
    return InitiallyValid;
}

HRESULT SGroup::GetDesc(D3DX11_GROUP_DESC *pDesc)
{
    HRESULT hr = S_OK;

    LPCSTR pFuncName = "ID3DX11EffectGroup::GetDesc";

    VERIFYPARAMETER(pDesc);

    pDesc->Name = pName;
    pDesc->Annotations = AnnotationCount;
    pDesc->Techniques = TechniqueCount;

lExit:
    return hr;
}

ID3DX11EffectVariable * SGroup::GetAnnotationByIndex(UINT  Index)
{
    return GetAnnotationByIndexHelper("ID3DX11EffectGroup", Index, AnnotationCount, pAnnotations);
}

ID3DX11EffectVariable * SGroup::GetAnnotationByName(LPCSTR Name)
{
    return GetAnnotationByNameHelper("ID3DX11EffectGroup", Name, AnnotationCount, pAnnotations);
}

ID3DX11EffectTechnique * SGroup::GetTechniqueByIndex(UINT  Index)
{
    LPCSTR pFuncName = "ID3DX11EffectGroup::GetTechniqueByIndex";

    if (Index >= TechniqueCount)
    {
        DPF(0, "%s: Invalid pass index (%d, total: %d)", pFuncName, Index, TechniqueCount);
        return &g_InvalidTechnique;
    }

    return (ID3DX11EffectTechnique *)(pTechniques + Index);
}

ID3DX11EffectTechnique * SGroup::GetTechniqueByName(LPCSTR Name)
{
    LPCSTR pFuncName = "ID3DX11EffectGroup::GetTechniqueByName";

    UINT  i;

    for (i = 0; i < TechniqueCount; ++ i)
    {
        if (NULL != pTechniques[i].pName &&
            strcmp(pTechniques[i].pName, Name) == 0)
        {
            break;
        }
    }

    if (i == TechniqueCount)
    {
        DPF(0, "%s: Technique [%s] not found", pFuncName, Name);
        return &g_InvalidTechnique;
    }

    return (ID3DX11EffectTechnique *)(pTechniques + i);
}

//////////////////////////////////////////////////////////////////////////
// ID3DX11Effect Public Reflection APIs (CEffect)
//////////////////////////////////////////////////////////////////////////

HRESULT CEffect::GetDevice(ID3D11Device **ppDevice)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11Effect::GetDevice";
    VERIFYPARAMETER(ppDevice);

    m_pDevice->AddRef();
    *ppDevice = m_pDevice;

lExit:
    return hr;
}

HRESULT CEffect::GetDesc(D3DX11_EFFECT_DESC *pDesc)
{
    HRESULT hr = S_OK;

    LPCSTR pFuncName = "ID3DX11Effect::GetDesc";

    VERIFYPARAMETER(pDesc);

    pDesc->ConstantBuffers = m_CBCount;
    pDesc->GlobalVariables = m_VariableCount;
    pDesc->Techniques = m_TechniqueCount;
    pDesc->Groups = m_GroupCount;
    pDesc->InterfaceVariables = m_InterfaceCount;

lExit:
    return hr;    
}

ID3DX11EffectConstantBuffer * CEffect::GetConstantBufferByIndex(UINT  Index)
{
    LPCSTR pFuncName = "ID3DX11Effect::GetConstantBufferByIndex";

    if (Index < m_CBCount)
    {
        return m_pCBs + Index;
    }

    DPF(0, "%s: Invalid constant buffer index", pFuncName);
    return &g_InvalidConstantBuffer;
}

ID3DX11EffectConstantBuffer * CEffect::GetConstantBufferByName(LPCSTR Name)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11Effect::GetConstantBufferByName";

    if (IsOptimized())
    {
        DPF(0, "%s: Cannot get constant buffer interfaces by name since the effect has been Optimize()'ed", pFuncName);
        return &g_InvalidConstantBuffer;
    }

    if (NULL == Name)
    {
        DPF(0, "%s: Parameter Name was NULL.", pFuncName);
        return &g_InvalidConstantBuffer;
    }

    UINT  i;

    for (i = 0; i < m_CBCount; ++ i)
    {
        if (strcmp(m_pCBs[i].pName, Name) == 0)
        {
            return m_pCBs + i;
        }
    }

    DPF(0, "%s: Constant Buffer [%s] not found", pFuncName, Name);
    return &g_InvalidConstantBuffer;
}

ID3DX11EffectVariable * CEffect::GetVariableByIndex(UINT  Index)
{
    LPCSTR pFuncName = "ID3DX11Effect::GetVariableByIndex";

    if (Index < m_VariableCount)
    {
        return m_pVariables + Index;
    }

    DPF(0, "%s: Invalid variable index", pFuncName);
    return &g_InvalidScalarVariable;
}

ID3DX11EffectVariable * CEffect::GetVariableByName(LPCSTR Name)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11Effect::GetVariableByName";

    if (IsOptimized())
    {
        DPF(0, "%s: Cannot get variable interfaces by name since the effect has been Optimize()'ed", pFuncName);
        return &g_InvalidScalarVariable;
    }

    if (NULL == Name)
    {
        DPF(0, "%s: Parameter Name was NULL.", pFuncName);
        return &g_InvalidScalarVariable;
    }

    UINT  i;

    for (i = 0; i < m_VariableCount; ++ i)
    {
        if (strcmp(m_pVariables[i].pName, Name) == 0)
        {
            return m_pVariables + i;
        }
    }

    DPF(0, "%s: Variable [%s] not found", pFuncName, Name);
    return &g_InvalidScalarVariable;
}

ID3DX11EffectVariable * CEffect::GetVariableBySemantic(LPCSTR Semantic)
{    
    LPCSTR pFuncName = "ID3DX11Effect::GetVariableBySemantic";

    if (IsOptimized())
    {
        DPF(0, "%s: Cannot get variable interfaces by semantic since the effect has been Optimize()'ed", pFuncName);
        return &g_InvalidScalarVariable;
    }

    if (NULL == Semantic)
    {
        DPF(0, "%s: Parameter Semantic was NULL.", pFuncName);
        return &g_InvalidScalarVariable;
    }

    UINT  i;

    for (i = 0; i < m_VariableCount; ++ i)
    {
        if (NULL != m_pVariables[i].pSemantic && 
            _stricmp(m_pVariables[i].pSemantic, Semantic) == 0)
        {
            return (ID3DX11EffectVariable *)(m_pVariables + i);
        }
    }

    DPF(0, "%s: Variable with semantic [%s] not found", pFuncName, Semantic);
    return &g_InvalidScalarVariable;
}

ID3DX11EffectTechnique * CEffect::GetTechniqueByIndex(UINT  Index)
{
    LPCSTR pFuncName = "ID3DX11Effect::GetTechniqueByIndex";

    if( Index < m_TechniqueCount )
    {
        UINT i;
        for( i=0; i < m_GroupCount; i++ )
        {
            if( Index < m_pGroups[i].TechniqueCount )
            {
                return (ID3DX11EffectTechnique *)(m_pGroups[i].pTechniques + Index);
            }
            Index -= m_pGroups[i].TechniqueCount;
        }
        D3DXASSERT( FALSE );
    }
    DPF(0, "%s: Invalid technique index (%d)", pFuncName, Index);
    return &g_InvalidTechnique;
}

ID3DX11EffectTechnique * CEffect::GetTechniqueByName(LPCSTR Name)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11Effect::GetTechniqueByName";
    const UINT MAX_GROUP_TECHNIQUE_SIZE = 256;
    char NameCopy[MAX_GROUP_TECHNIQUE_SIZE];

    if (IsOptimized())
    {
        DPF(0, "ID3DX11Effect::GetTechniqueByName: Cannot get technique interfaces by name since the effect has been Optimize()'ed");
        return &g_InvalidTechnique;
    }

    if (NULL == Name)
    {
        DPF(0, "%s: Parameter Name was NULL.", pFuncName);
        return &g_InvalidTechnique;
    }

    if( FAILED( StringCchCopyA( NameCopy, MAX_GROUP_TECHNIQUE_SIZE, Name ) ) )
    {
        DPF( 0, "Group|Technique name has a length greater than %d.", MAX_GROUP_TECHNIQUE_SIZE );
        return &g_InvalidTechnique;
    }

    char* pDelimiter = strchr( NameCopy, '|' );
    if( pDelimiter == NULL )
    {
        if ( m_pNullGroup == NULL )
        {
            DPF( 0, "The effect contains no default group." );
            return &g_InvalidTechnique;
        }

        return m_pNullGroup->GetTechniqueByName( Name );
    }

    // separate group name and technique name
    *pDelimiter = 0; 

    return GetGroupByName( NameCopy )->GetTechniqueByName( pDelimiter + 1 );
}

ID3D11ClassLinkage * CEffect::GetClassLinkage()
{
    SAFE_ADDREF( m_pClassLinkage );
    return m_pClassLinkage;
}

ID3DX11EffectGroup * CEffect::GetGroupByIndex(UINT  Index)
{
    LPCSTR pFuncName = "ID3DX11Effect::GetGroupByIndex";

    if( Index < m_GroupCount )
    {
        return (ID3DX11EffectGroup *)(m_pGroups + Index);
    }
    DPF(0, "%s: Invalid group index (%d)", pFuncName, Index);
    return &g_InvalidGroup;
}

ID3DX11EffectGroup * CEffect::GetGroupByName(LPCSTR Name)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11Effect::GetGroupByName";

    if (IsOptimized())
    {
        DPF(0, "ID3DX11Effect::GetGroupByName: Cannot get group interfaces by name since the effect has been Optimize()'ed");
        return &g_InvalidGroup;
    }

    if (NULL == Name || Name[0] == 0 )
    {
        return m_pNullGroup ? (ID3DX11EffectGroup *)m_pNullGroup : &g_InvalidGroup;
    }

    UINT  i;

    for (i = 0; i < m_GroupCount; ++ i)
    {
        if (NULL != m_pGroups[i].pName && 
            strcmp(m_pGroups[i].pName, Name) == 0)
        {
            break;
        }
    }

    if (i == m_GroupCount)
    {
        DPF(0, "%s: Group [%s] not found", pFuncName, Name);
        return &g_InvalidGroup;
    }

    return (ID3DX11EffectGroup *)(m_pGroups + i);
}

}

```

`Source Code/Effects11/EffectRuntime.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       EffectRuntime.cpp
//  Content:    D3DX11 Effect runtime routines (performance critical)
//              These functions are expected to be called at high frequency
//              (when applying a pass).
//
//////////////////////////////////////////////////////////////////////////////

#include "pchfx.h"

namespace D3DX11Effects
{
    // D3D11_KEEP_UNORDERED_ACCESS_VIEWS == (UINT)-1
    UINT g_pNegativeOnes[8] = { D3D11_KEEP_UNORDERED_ACCESS_VIEWS, D3D11_KEEP_UNORDERED_ACCESS_VIEWS, D3D11_KEEP_UNORDERED_ACCESS_VIEWS,
                                D3D11_KEEP_UNORDERED_ACCESS_VIEWS, D3D11_KEEP_UNORDERED_ACCESS_VIEWS, D3D11_KEEP_UNORDERED_ACCESS_VIEWS,
                                D3D11_KEEP_UNORDERED_ACCESS_VIEWS, D3D11_KEEP_UNORDERED_ACCESS_VIEWS };

BOOL SBaseBlock::ApplyAssignments(CEffect *pEffect)
{
    SAssignment *pAssignment = pAssignments;
    SAssignment *pLastAssn = pAssignments + AssignmentCount;
    BOOL bRecreate = FALSE;

    for(; pAssignment < pLastAssn; pAssignment++)
    {
        bRecreate |= pEffect->EvaluateAssignment(pAssignment);
    }

    return bRecreate;
}

void SPassBlock::ApplyPassAssignments()
{
    SAssignment *pAssignment = pAssignments;
    SAssignment *pLastAssn = pAssignments + AssignmentCount;

    pEffect->IncrementTimer();

    for(; pAssignment < pLastAssn; pAssignment++)
    {
        pEffect->EvaluateAssignment(pAssignment);
    }
}

// Returns TRUE if the shader uses global interfaces (since these interfaces can be updated through SetClassInstance)
BOOL SPassBlock::CheckShaderDependencies( SShaderBlock* pBlock )
{
    if( pBlock->InterfaceDepCount > 0 )
    {
        D3DXASSERT( pBlock->InterfaceDepCount == 1 );
        for( UINT i=0; i < pBlock->pInterfaceDeps[0].Count; i++ )
        {
            SInterface* pInterfaceDep = pBlock->pInterfaceDeps[0].ppFXPointers[i];
            if( pInterfaceDep > pEffect->m_pInterfaces && pInterfaceDep < (pEffect->m_pInterfaces + pEffect->m_InterfaceCount) )
            {
                // This is a global interface pointer (as opposed to an SInterface created in a BindInterface call
                return TRUE;
            }
        }
    }
    return FALSE;
}

// Returns TRUE if the pass (and sets HasDependencies) if the pass sets objects whose backing stores can be updated
BOOL SPassBlock::CheckDependencies()
{
    if( HasDependencies )
        return TRUE;

    for( UINT i=0; i < AssignmentCount; i++ )
    {
        if( pAssignments[i].DependencyCount > 0 )
            return HasDependencies = TRUE;
    }
    if( BackingStore.pBlendBlock && BackingStore.pBlendBlock->AssignmentCount > 0 )
    {
        for( UINT i=0; i < BackingStore.pBlendBlock->AssignmentCount; i++ )
        {
            if( BackingStore.pBlendBlock->pAssignments[i].DependencyCount > 0 )
                return HasDependencies = TRUE;
        }
    }
    if( BackingStore.pDepthStencilBlock && BackingStore.pDepthStencilBlock->AssignmentCount > 0 )
    {
        for( UINT i=0; i < BackingStore.pDepthStencilBlock->AssignmentCount; i++ )
        {
            if( BackingStore.pDepthStencilBlock->pAssignments[i].DependencyCount > 0 )
                return HasDependencies = TRUE;
        }
    }
    if( BackingStore.pRasterizerBlock && BackingStore.pRasterizerBlock->AssignmentCount > 0 )
    {
        for( UINT i=0; i < BackingStore.pRasterizerBlock->AssignmentCount; i++ )
        {
            if( BackingStore.pRasterizerBlock->pAssignments[i].DependencyCount > 0 )
                return HasDependencies = TRUE;
        }
    }
    if( BackingStore.pVertexShaderBlock && CheckShaderDependencies( BackingStore.pVertexShaderBlock ) )
    {
        return HasDependencies = TRUE;
    }
    if( BackingStore.pGeometryShaderBlock && CheckShaderDependencies( BackingStore.pGeometryShaderBlock ) )
    {
        return HasDependencies = TRUE;
    }
    if( BackingStore.pPixelShaderBlock && CheckShaderDependencies( BackingStore.pPixelShaderBlock ) )
    {
        return HasDependencies = TRUE;
    }
    if( BackingStore.pHullShaderBlock && CheckShaderDependencies( BackingStore.pHullShaderBlock ) )
    {
        return HasDependencies = TRUE;
    }
    if( BackingStore.pDomainShaderBlock && CheckShaderDependencies( BackingStore.pDomainShaderBlock ) )
    {
        return HasDependencies = TRUE;
    }
    if( BackingStore.pComputeShaderBlock && CheckShaderDependencies( BackingStore.pComputeShaderBlock ) )
    {
        return HasDependencies = TRUE;
    }

    return HasDependencies;
}


// Update constant buffer contents if necessary
D3DX11INLINE void CheckAndUpdateCB_FX(ID3D11DeviceContext *pContext, SConstantBuffer *pCB)
{
    if (pCB->IsDirty && !pCB->IsNonUpdatable)
    {
        // CB out of date; rebuild it
        pContext->UpdateSubresource(pCB->pD3DObject, 0, NULL, pCB->pBackingStore, pCB->Size, pCB->Size);
        pCB->IsDirty = FALSE;
    }
}


// Set the shader and dependent state (SRVs, samplers, UAVs, interfaces)
void CEffect::ApplyShaderBlock(SShaderBlock *pBlock)
{
    UINT i;

    SD3DShaderVTable *pVT = pBlock->pVT;

    // Apply constant buffers first (tbuffers are done later)
    SShaderCBDependency *pCBDep = pBlock->pCBDeps;
    SShaderCBDependency *pLastCBDep = pBlock->pCBDeps + pBlock->CBDepCount;

    for (; pCBDep<pLastCBDep; pCBDep++)
    {
        D3DXASSERT(pCBDep->ppFXPointers);

        for (i = 0; i < pCBDep->Count; ++ i)
        {
            CheckAndUpdateCB_FX(m_pContext, (SConstantBuffer*)pCBDep->ppFXPointers[i]);
        }

        (m_pContext->*(pVT->pSetConstantBuffers))(pCBDep->StartIndex, pCBDep->Count, pCBDep->ppD3DObjects);
    }

    // Next, apply samplers
    SShaderSamplerDependency *pSampDep = pBlock->pSampDeps;
    SShaderSamplerDependency *pLastSampDep = pBlock->pSampDeps + pBlock->SampDepCount;

    for (; pSampDep<pLastSampDep; pSampDep++)
    {
        D3DXASSERT(pSampDep->ppFXPointers);

        for (i=0; i<pSampDep->Count; i++)
        {
            if ( ApplyRenderStateBlock(pSampDep->ppFXPointers[i]) )
            {
                // If the sampler was updated, its pointer will have changed
                pSampDep->ppD3DObjects[i] = pSampDep->ppFXPointers[i]->pD3DObject;
            }
        }
        (m_pContext->*(pVT->pSetSamplers))(pSampDep->StartIndex, pSampDep->Count, pSampDep->ppD3DObjects);
    }
 
    // Set the UAVs
    // UAV ranges were combined in EffectLoad.  This code remains unchanged, however, so that ranges can be easily split
    D3DXASSERT( pBlock->UAVDepCount < 2 );
    if( pBlock->UAVDepCount > 0 )
    {
        SUnorderedAccessViewDependency *pUAVDep = pBlock->pUAVDeps;
        D3DXASSERT(pUAVDep->ppFXPointers);

        for (i=0; i<pUAVDep->Count; i++)
        {
            pUAVDep->ppD3DObjects[i] = pUAVDep->ppFXPointers[i]->pUnorderedAccessView;
        }

        if( EOT_ComputeShader5 == pBlock->GetShaderType() )
        {
            m_pContext->CSSetUnorderedAccessViews( pUAVDep->StartIndex, pUAVDep->Count, pUAVDep->ppD3DObjects, g_pNegativeOnes );
        }
        else
        {
            // This call could be combined with the call to set render targets if both exist in the pass
            m_pContext->OMSetRenderTargetsAndUnorderedAccessViews( D3D11_KEEP_RENDER_TARGETS_AND_DEPTH_STENCIL, NULL, NULL, pUAVDep->StartIndex, pUAVDep->Count, pUAVDep->ppD3DObjects, g_pNegativeOnes );
        }
    }

    // TBuffers are funny:
    // We keep two references to them. One is in as a standard texture dep, and that gets used for all sets
    // The other is as a part of the TBufferDeps array, which tells us to rebuild the matching CBs.
    // These two refs could be rolled into one, but then we would have to predicate on each CB or each texture.
    SConstantBuffer **ppTB = pBlock->ppTbufDeps;
    SConstantBuffer **ppLastTB = ppTB + pBlock->TBufferDepCount;

    for (; ppTB<ppLastTB; ppTB++)
    {
        CheckAndUpdateCB_FX(m_pContext, (SConstantBuffer*)*ppTB);
    }

    // Set the textures
    SShaderResourceDependency *pResourceDep = pBlock->pResourceDeps;
    SShaderResourceDependency *pLastResourceDep = pBlock->pResourceDeps + pBlock->ResourceDepCount;

    for (; pResourceDep<pLastResourceDep; pResourceDep++)
    {
        D3DXASSERT(pResourceDep->ppFXPointers);

        for (i=0; i<pResourceDep->Count; i++)
        {
            pResourceDep->ppD3DObjects[i] = pResourceDep->ppFXPointers[i]->pShaderResource;
        }

        (m_pContext->*(pVT->pSetShaderResources))(pResourceDep->StartIndex, pResourceDep->Count, pResourceDep->ppD3DObjects);
    }

    // Update Interface dependencies
    UINT Interfaces = 0;
    ID3D11ClassInstance** ppClassInstances = NULL;
    D3DXASSERT( pBlock->InterfaceDepCount < 2 );
    if( pBlock->InterfaceDepCount > 0 )
    {
        SInterfaceDependency *pInterfaceDep = pBlock->pInterfaceDeps;
        D3DXASSERT(pInterfaceDep->ppFXPointers);

        ppClassInstances = pInterfaceDep->ppD3DObjects;
        Interfaces = pInterfaceDep->Count;
        for (i=0; i<pInterfaceDep->Count; i++)
        {
            SClassInstanceGlobalVariable* pCI = pInterfaceDep->ppFXPointers[i]->pClassInstance;
            if( pCI )
            {
                D3DXASSERT( pCI->pMemberData != NULL );
                pInterfaceDep->ppD3DObjects[i] = pCI->pMemberData->Data.pD3DClassInstance;
            }
            else
            {
                pInterfaceDep->ppD3DObjects[i] = NULL;
            }
        }
    }

    // Now set the shader
    (m_pContext->*(pVT->pSetShader))(pBlock->pD3DObject, ppClassInstances, Interfaces);
}

// Returns TRUE if the block D3D data was recreated
BOOL CEffect::ApplyRenderStateBlock(SBaseBlock *pBlock)
{
    if( pBlock->IsUserManaged )
    {
        return FALSE;
    }

    BOOL bRecreate = pBlock->ApplyAssignments(this);

    if (bRecreate)
    {
        switch (pBlock->BlockType)
        {
        case EBT_Sampler:
            {
                SSamplerBlock *pSBlock = pBlock->AsSampler();

                D3DXASSERT(NULL != pSBlock->pD3DObject);
                pSBlock->pD3DObject->Release();

                m_pDevice->CreateSamplerState( &pSBlock->BackingStore.SamplerDesc, &pSBlock->pD3DObject );

            }
            break;

        case EBT_DepthStencil:
            {
                SDepthStencilBlock *pDSBlock = pBlock->AsDepthStencil();

                D3DXASSERT(NULL != pDSBlock->pDSObject);
                SAFE_RELEASE( pDSBlock->pDSObject );
                if( SUCCEEDED( m_pDevice->CreateDepthStencilState( &pDSBlock->BackingStore, &pDSBlock->pDSObject ) ) )
                    pDSBlock->IsValid = TRUE;
                else
                    pDSBlock->IsValid = FALSE;
            }
            break;
        
        case EBT_Blend:
            {
                SBlendBlock *pBBlock = pBlock->AsBlend();

                D3DXASSERT(NULL != pBBlock->pBlendObject);
                SAFE_RELEASE( pBBlock->pBlendObject );
                if( SUCCEEDED( m_pDevice->CreateBlendState( &pBBlock->BackingStore, &pBBlock->pBlendObject ) ) )
                    pBBlock->IsValid = TRUE;
                else
                    pBBlock->IsValid = FALSE;
            }
            break;

        case EBT_Rasterizer:
            {
                SRasterizerBlock *pRBlock = pBlock->AsRasterizer();

                D3DXASSERT(NULL != pRBlock->pRasterizerObject);

                SAFE_RELEASE( pRBlock->pRasterizerObject );
                if( SUCCEEDED( m_pDevice->CreateRasterizerState( &pRBlock->BackingStore, &pRBlock->pRasterizerObject ) ) )
                    pRBlock->IsValid = TRUE;
                else
                    pRBlock->IsValid = FALSE;
            }
            break;
        
        default:
            D3DXASSERT(0);
        }
    }

    return bRecreate;
}

void CEffect::ValidateIndex(UINT  Elements)
{
    if (m_FXLIndex >= Elements)
    {
        DPF(0, "ID3DX11Effect: Overindexing variable array (size: %d, index: %d), using index = 0 instead", Elements, m_FXLIndex);
        m_FXLIndex = 0;
    }
}

// Returns TRUE if the assignment was changed
BOOL CEffect::EvaluateAssignment(SAssignment *pAssignment)
{
    BOOL bNeedUpdate = FALSE;
    SGlobalVariable *pVarDep0, *pVarDep1;
    
    switch (pAssignment->AssignmentType)
    {
    case ERAT_NumericVariable:
        D3DXASSERT(pAssignment->DependencyCount == 1);
        if (pAssignment->pDependencies[0].pVariable->LastModifiedTime >= pAssignment->LastRecomputedTime)
        {
            dwordMemcpy(pAssignment->Destination.pNumeric, pAssignment->Source.pNumeric, pAssignment->DataSize);
            bNeedUpdate = TRUE;
        }
        break;

    case ERAT_NumericVariableIndex:
        D3DXASSERT(pAssignment->DependencyCount == 2);
        pVarDep0 = pAssignment->pDependencies[0].pVariable;
        pVarDep1 = pAssignment->pDependencies[1].pVariable;

        if (pVarDep0->LastModifiedTime >= pAssignment->LastRecomputedTime)
        {
            m_FXLIndex = *pVarDep0->Data.pNumericDword;

            ValidateIndex(pVarDep1->pType->Elements);

            // Array index variable is dirty, update the pointer
            pAssignment->Source.pNumeric = pVarDep1->Data.pNumeric + pVarDep1->pType->Stride * m_FXLIndex;
            
            // Copy the new data
            dwordMemcpy(pAssignment->Destination.pNumeric, pAssignment->Source.pNumeric, pAssignment->DataSize);
            bNeedUpdate = TRUE;
        }
        else if (pVarDep1->LastModifiedTime >= pAssignment->LastRecomputedTime)
        {
            // Only the array variable is dirty, copy the new data
            dwordMemcpy(pAssignment->Destination.pNumeric, pAssignment->Source.pNumeric, pAssignment->DataSize);
            bNeedUpdate = TRUE;
        }
        break;

    case ERAT_ObjectVariableIndex:
        D3DXASSERT(pAssignment->DependencyCount == 1);
        pVarDep0 = pAssignment->pDependencies[0].pVariable;
        if (pVarDep0->LastModifiedTime >= pAssignment->LastRecomputedTime)
        {
            m_FXLIndex = *pVarDep0->Data.pNumericDword;
            ValidateIndex(pAssignment->MaxElements);

            // Array index variable is dirty, update the destination pointer
            *((void **)pAssignment->Destination.pGeneric) = pAssignment->Source.pNumeric +
                pAssignment->DataSize * m_FXLIndex;
            bNeedUpdate = TRUE;
        }
        break;

    default:
    //case ERAT_Constant:           -- These are consumed and discarded
    //case ERAT_ObjectVariable:     -- These are consumed and discarded
    //case ERAT_ObjectConstIndex:   -- These are consumed and discarded
    //case ERAT_ObjectInlineShader: -- These are consumed and discarded
    //case ERAT_NumericConstIndex:  -- ERAT_NumericVariable should be generated instead
        D3DXASSERT(0);
        break;
    }
    
    // Mark the assignment as not dirty
    pAssignment->LastRecomputedTime = m_LocalTimer;

    return bNeedUpdate;
}

// Returns FALSE if this shader has interface dependencies which are NULL (SetShader will fail).
BOOL CEffect::ValidateShaderBlock( SShaderBlock* pBlock )
{
    if( !pBlock->IsValid )
        return FALSE;
    if( pBlock->InterfaceDepCount > 0 )
    {
        D3DXASSERT( pBlock->InterfaceDepCount == 1 );
        for( UINT i=0; i < pBlock->pInterfaceDeps[0].Count; i++ )
        {
            SInterface* pInterfaceDep = pBlock->pInterfaceDeps[0].ppFXPointers[i];
            D3DXASSERT( pInterfaceDep != NULL );
            if( pInterfaceDep->pClassInstance == NULL )
            {
                return FALSE;
            }
        }
    }
    return TRUE;
}

// Returns FALSE if any state in the pass is invalid
BOOL CEffect::ValidatePassBlock( SPassBlock* pBlock )
{
    pBlock->ApplyPassAssignments();

    if (NULL != pBlock->BackingStore.pBlendBlock)
    {
        ApplyRenderStateBlock(pBlock->BackingStore.pBlendBlock);
        pBlock->BackingStore.pBlendState = pBlock->BackingStore.pBlendBlock->pBlendObject;
        if( !pBlock->BackingStore.pBlendBlock->IsValid )
            return FALSE;
    }

    if( NULL != pBlock->BackingStore.pDepthStencilBlock )
    {
        ApplyRenderStateBlock( pBlock->BackingStore.pDepthStencilBlock );
        pBlock->BackingStore.pDepthStencilState = pBlock->BackingStore.pDepthStencilBlock->pDSObject;
        if( !pBlock->BackingStore.pDepthStencilBlock->IsValid )
            return FALSE;
    }

    if( NULL != pBlock->BackingStore.pRasterizerBlock )
    {
        ApplyRenderStateBlock( pBlock->BackingStore.pRasterizerBlock );
        if( !pBlock->BackingStore.pRasterizerBlock->IsValid )
            return FALSE;
    }

    if( NULL != pBlock->BackingStore.pVertexShaderBlock && !ValidateShaderBlock(pBlock->BackingStore.pVertexShaderBlock) )
        return FALSE;

    if( NULL != pBlock->BackingStore.pGeometryShaderBlock && !ValidateShaderBlock(pBlock->BackingStore.pGeometryShaderBlock) )
        return FALSE;

    if( NULL != pBlock->BackingStore.pPixelShaderBlock )
    {
        if( !ValidateShaderBlock(pBlock->BackingStore.pPixelShaderBlock) )
            return FALSE;
        else if( pBlock->BackingStore.pPixelShaderBlock->UAVDepCount > 0 && 
                 pBlock->BackingStore.RenderTargetViewCount > pBlock->BackingStore.pPixelShaderBlock->pUAVDeps[0].StartIndex )
        {
            return FALSE;
        }
    }

    if( NULL != pBlock->BackingStore.pHullShaderBlock && !ValidateShaderBlock(pBlock->BackingStore.pHullShaderBlock) )
        return FALSE;

    if( NULL != pBlock->BackingStore.pDomainShaderBlock && !ValidateShaderBlock(pBlock->BackingStore.pDomainShaderBlock) )
        return FALSE;

    if( NULL != pBlock->BackingStore.pComputeShaderBlock && !ValidateShaderBlock(pBlock->BackingStore.pComputeShaderBlock) )
        return FALSE;

    return TRUE;
}

// Set all state defined in the pass
void CEffect::ApplyPassBlock(SPassBlock *pBlock)
{
    pBlock->ApplyPassAssignments();

    if (NULL != pBlock->BackingStore.pBlendBlock)
    {
        ApplyRenderStateBlock(pBlock->BackingStore.pBlendBlock);
#ifdef FXDEBUG
        if( !pBlock->BackingStore.pBlendBlock->IsValid )
            DPF( 0, "Pass::Apply - warning: applying invalid BlendState." );
#endif
        pBlock->BackingStore.pBlendState = pBlock->BackingStore.pBlendBlock->pBlendObject;
        m_pContext->OMSetBlendState(pBlock->BackingStore.pBlendState,
            pBlock->BackingStore.BlendFactor,
            pBlock->BackingStore.SampleMask);
    }

    if (NULL != pBlock->BackingStore.pDepthStencilBlock)
    {
        ApplyRenderStateBlock(pBlock->BackingStore.pDepthStencilBlock);
#ifdef FXDEBUG
        if( !pBlock->BackingStore.pDepthStencilBlock->IsValid )
            DPF( 0, "Pass::Apply - warning: applying invalid DepthStencilState." );
#endif
        pBlock->BackingStore.pDepthStencilState = pBlock->BackingStore.pDepthStencilBlock->pDSObject;
        m_pContext->OMSetDepthStencilState(pBlock->BackingStore.pDepthStencilState,
            pBlock->BackingStore.StencilRef);
    }

    if (NULL != pBlock->BackingStore.pRasterizerBlock)
    {
        ApplyRenderStateBlock(pBlock->BackingStore.pRasterizerBlock);
#ifdef FXDEBUG
        if( !pBlock->BackingStore.pRasterizerBlock->IsValid )
            DPF( 0, "Pass::Apply - warning: applying invalid RasterizerState." );
#endif
        m_pContext->RSSetState(pBlock->BackingStore.pRasterizerBlock->pRasterizerObject);
    }

    if (NULL != pBlock->BackingStore.pRenderTargetViews[0])
    {
        // Grab all render targets
        ID3D11RenderTargetView *pRTV[D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT];

        D3DXASSERT(pBlock->BackingStore.RenderTargetViewCount <= D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT);
        __analysis_assume(D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT >= pBlock->BackingStore.RenderTargetViewCount);

        for (UINT i=0; i<pBlock->BackingStore.RenderTargetViewCount; i++)
        {
            pRTV[i] = pBlock->BackingStore.pRenderTargetViews[i]->pRenderTargetView;
        }

        // This call could be combined with the call to set PS UAVs if both exist in the pass
        m_pContext->OMSetRenderTargetsAndUnorderedAccessViews( pBlock->BackingStore.RenderTargetViewCount, pRTV, pBlock->BackingStore.pDepthStencilView->pDepthStencilView, 7, D3D11_KEEP_UNORDERED_ACCESS_VIEWS, NULL, NULL );
    }

    if (NULL != pBlock->BackingStore.pVertexShaderBlock)
    {
#ifdef FXDEBUG
        if( !pBlock->BackingStore.pVertexShaderBlock->IsValid )
            DPF( 0, "Pass::Apply - warning: applying invalid vertex shader." );
#endif
        ApplyShaderBlock(pBlock->BackingStore.pVertexShaderBlock);
    }

    if (NULL != pBlock->BackingStore.pPixelShaderBlock)
    {
#ifdef FXDEBUG
        if( !pBlock->BackingStore.pPixelShaderBlock->IsValid )
            DPF( 0, "Pass::Apply - warning: applying invalid pixel shader." );
#endif
        ApplyShaderBlock(pBlock->BackingStore.pPixelShaderBlock);
    }

    if (NULL != pBlock->BackingStore.pGeometryShaderBlock)
    {
#ifdef FXDEBUG
        if( !pBlock->BackingStore.pGeometryShaderBlock->IsValid )
            DPF( 0, "Pass::Apply - warning: applying invalid geometry shader." );
#endif
        ApplyShaderBlock(pBlock->BackingStore.pGeometryShaderBlock);
    }

    if (NULL != pBlock->BackingStore.pHullShaderBlock)
    {
#ifdef FXDEBUG
        if( !pBlock->BackingStore.pHullShaderBlock->IsValid )
            DPF( 0, "Pass::Apply - warning: applying invalid hull shader." );
#endif
        ApplyShaderBlock(pBlock->BackingStore.pHullShaderBlock);
    }

    if (NULL != pBlock->BackingStore.pDomainShaderBlock)
    {
#ifdef FXDEBUG
        if( !pBlock->BackingStore.pDomainShaderBlock->IsValid )
            DPF( 0, "Pass::Apply - warning: applying invalid domain shader." );
#endif
        ApplyShaderBlock(pBlock->BackingStore.pDomainShaderBlock);
    }

    if (NULL != pBlock->BackingStore.pComputeShaderBlock)
    {
#ifdef FXDEBUG
        if( !pBlock->BackingStore.pComputeShaderBlock->IsValid )
            DPF( 0, "Pass::Apply - warning: applying invalid compute shader." );
#endif
        ApplyShaderBlock(pBlock->BackingStore.pComputeShaderBlock);
    }
}

void CEffect::IncrementTimer()
{
    m_LocalTimer++;

#ifndef _WIN64
#if _DEBUG && FXDEBUG
    if (m_LocalTimer > g_TimerRolloverCount)
    {
        DPF(0, "Rolling over timer (current time: %d, rollover cap: %d).", m_LocalTimer, g_TimerRolloverCount);
#else // else !(_DEBUG && FXDEBUG)
    if (m_LocalTimer >= 0x80000000) // check to see if we've exceeded ~2 billion
    {
#endif // _DEBUG && FXDEBUG
        HandleLocalTimerRollover();

        m_LocalTimer = 1;
    }
#endif // _WIN64
}

// This function resets all timers, rendering all assignments dirty
// This is clearly bad for performance, but should only happen every few billion ticks
void CEffect::HandleLocalTimerRollover()
{
    UINT  i, j, k;
    
    // step 1: update variables
    for (i = 0; i < m_VariableCount; ++ i)
    {
        m_pVariables[i].LastModifiedTime = 0;
    }

    // step 2: update assignments on all blocks (pass, depth stencil, rasterizer, blend, sampler)
    for (UINT iGroup = 0; iGroup < m_GroupCount; ++ iGroup)
    {
        for (i = 0; i < m_pGroups[iGroup].TechniqueCount; ++ i)
        {
            for (j = 0; j < m_pGroups[iGroup].pTechniques[i].PassCount; ++ j)
            {
                for (k = 0; k < m_pGroups[iGroup].pTechniques[i].pPasses[j].AssignmentCount; ++ k)
                {
                    m_pGroups[iGroup].pTechniques[i].pPasses[j].pAssignments[k].LastRecomputedTime = 0;
                }
            }
        }
    }

    for (i = 0; i < m_DepthStencilBlockCount; ++ i)
    {
        for (j = 0; j < m_pDepthStencilBlocks[i].AssignmentCount; ++ j)
        {
            m_pDepthStencilBlocks[i].pAssignments[j].LastRecomputedTime = 0;
        }
    }

    for (i = 0; i < m_RasterizerBlockCount; ++ i)
    {
        for (j = 0; j < m_pRasterizerBlocks[i].AssignmentCount; ++ j)
        {
            m_pRasterizerBlocks[i].pAssignments[j].LastRecomputedTime = 0;
        }
    }

    for (i = 0; i < m_BlendBlockCount; ++ i)
    {
        for (j = 0; j < m_pBlendBlocks[i].AssignmentCount; ++ j)
        {
            m_pBlendBlocks[i].pAssignments[j].LastRecomputedTime = 0;
        }
    }

    for (i = 0; i < m_SamplerBlockCount; ++ i)
    {
        for (j = 0; j < m_pSamplerBlocks[i].AssignmentCount; ++ j)
        {
            m_pSamplerBlocks[i].pAssignments[j].LastRecomputedTime = 0;
        }
    }
}

}

```

`Source Code/Effects11/EffectVariable.inl`:

```inl
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       EffectVariable.inl
//  Content:    D3DX11 Effects Variable reflection template
//              These templates define the many Effect variable types.
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// Invalid variable forward defines
//////////////////////////////////////////////////////////////////////////

struct SEffectInvalidScalarVariable;
struct SEffectInvalidVectorVariable;
struct SEffectInvalidMatrixVariable;
struct SEffectInvalidStringVariable;
struct SEffectInvalidClassInstanceVariable;
struct SEffectInvalidInterfaceVariable;
struct SEffectInvalidShaderResourceVariable;
struct SEffectInvalidUnorderedAccessViewVariable;
struct SEffectInvalidRenderTargetViewVariable;
struct SEffectInvalidDepthStencilViewVariable;
struct SEffectInvalidConstantBuffer;
struct SEffectInvalidShaderVariable;
struct SEffectInvalidBlendVariable;
struct SEffectInvalidDepthStencilVariable;
struct SEffectInvalidRasterizerVariable;
struct SEffectInvalidSamplerVariable;
struct SEffectInvalidTechnique;
struct SEffectInvalidPass;
struct SEffectInvalidType;

extern SEffectInvalidScalarVariable g_InvalidScalarVariable;
extern SEffectInvalidVectorVariable g_InvalidVectorVariable;
extern SEffectInvalidMatrixVariable g_InvalidMatrixVariable;
extern SEffectInvalidStringVariable g_InvalidStringVariable;
extern SEffectInvalidClassInstanceVariable g_InvalidClassInstanceVariable;
extern SEffectInvalidInterfaceVariable g_InvalidInterfaceVariable;
extern SEffectInvalidShaderResourceVariable g_InvalidShaderResourceVariable;
extern SEffectInvalidUnorderedAccessViewVariable g_InvalidUnorderedAccessViewVariable;
extern SEffectInvalidRenderTargetViewVariable g_InvalidRenderTargetViewVariable;
extern SEffectInvalidDepthStencilViewVariable g_InvalidDepthStencilViewVariable;
extern SEffectInvalidConstantBuffer g_InvalidConstantBuffer;
extern SEffectInvalidShaderVariable g_InvalidShaderVariable;
extern SEffectInvalidBlendVariable g_InvalidBlendVariable;
extern SEffectInvalidDepthStencilVariable g_InvalidDepthStencilVariable;
extern SEffectInvalidRasterizerVariable g_InvalidRasterizerVariable;
extern SEffectInvalidSamplerVariable g_InvalidSamplerVariable;
extern SEffectInvalidTechnique g_InvalidTechnique;
extern SEffectInvalidPass g_InvalidPass;
extern SEffectInvalidType g_InvalidType;

enum ETemplateVarType
{
    ETVT_Bool,
    ETVT_Int,
    ETVT_Float
};

//////////////////////////////////////////////////////////////////////////
// Invalid effect variable struct definitions
//////////////////////////////////////////////////////////////////////////

struct SEffectInvalidType : public ID3DX11EffectType
{
    STDMETHOD_(BOOL, IsValid)() { return FALSE; }
    STDMETHOD(GetDesc)(D3DX11_EFFECT_TYPE_DESC *pDesc) { return E_FAIL; }
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeByIndex)(UINT Index) { return &g_InvalidType; }
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeByName)(LPCSTR Name) { return &g_InvalidType; }
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeBySemantic)(LPCSTR Semanti) { return &g_InvalidType; }
    STDMETHOD_(LPCSTR, GetMemberName)(UINT Index) { return NULL; }
    STDMETHOD_(LPCSTR, GetMemberSemantic)(UINT Index) { return NULL; }
};

template<typename IBaseInterface>
struct TEffectInvalidVariable : public IBaseInterface
{
public:
    STDMETHOD_(BOOL, IsValid)() { return FALSE; }
    STDMETHOD_(ID3DX11EffectType*, GetType)() { return &g_InvalidType; }
    STDMETHOD(GetDesc)(D3DX11_EFFECT_VARIABLE_DESC *pDesc) { return E_FAIL; }

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(UINT Index) { return &g_InvalidScalarVariable; }
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(LPCSTR Name) { return &g_InvalidScalarVariable; }

    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(UINT Index) { return &g_InvalidScalarVariable; }
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(LPCSTR Name) { return &g_InvalidScalarVariable; }
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(LPCSTR Semantic) { return &g_InvalidScalarVariable; }

    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(UINT Index) { return &g_InvalidScalarVariable; }

    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)() { return &g_InvalidConstantBuffer; }

    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)() { return &g_InvalidScalarVariable; }
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)() { return &g_InvalidVectorVariable; }
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)() { return &g_InvalidMatrixVariable; }
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)() { return &g_InvalidStringVariable; }
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)() { return &g_InvalidClassInstanceVariable; }
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)() { return &g_InvalidInterfaceVariable; }
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)() { return &g_InvalidShaderResourceVariable; }
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)() { return &g_InvalidUnorderedAccessViewVariable; }
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)() { return &g_InvalidRenderTargetViewVariable; }
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)() { return &g_InvalidDepthStencilViewVariable; }
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)() { return &g_InvalidConstantBuffer; }
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)() { return &g_InvalidShaderVariable; }
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)() { return &g_InvalidBlendVariable; }
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)() { return &g_InvalidDepthStencilVariable; }
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)() { return &g_InvalidRasterizerVariable; }
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)() { return &g_InvalidSamplerVariable; }

    STDMETHOD(SetRawValue)(CONST void *pData, UINT  Offset, UINT  Count) { return E_FAIL; }
    STDMETHOD(GetRawValue)(void *pData, UINT  Offset, UINT  Count) { return E_FAIL; }
};

struct SEffectInvalidScalarVariable : public TEffectInvalidVariable<ID3DX11EffectScalarVariable>
{
public:

    STDMETHOD(SetFloat)(CONST float Value) { return E_FAIL; }
    STDMETHOD(GetFloat)(float *pValue) { return E_FAIL; }

    STDMETHOD(SetFloatArray)(CONST float *pData, UINT  Offset, UINT  Count) { return E_FAIL; }
    STDMETHOD(GetFloatArray)(float *pData, UINT  Offset, UINT  Count) { return E_FAIL; }

    STDMETHOD(SetInt)(CONST int Value) { return E_FAIL; }
    STDMETHOD(GetInt)(int *pValue) { return E_FAIL; }

    STDMETHOD(SetIntArray)(CONST int *pData, UINT  Offset, UINT  Count) { return E_FAIL; }
    STDMETHOD(GetIntArray)(int *pData, UINT  Offset, UINT  Count) { return E_FAIL; }

    STDMETHOD(SetBool)(CONST BOOL Value) { return E_FAIL; }
    STDMETHOD(GetBool)(BOOL *pValue) { return E_FAIL; }

    STDMETHOD(SetBoolArray)(CONST BOOL *pData, UINT  Offset, UINT  Count) { return E_FAIL; }
    STDMETHOD(GetBoolArray)(BOOL *pData, UINT  Offset, UINT  Count) { return E_FAIL; }
};


struct SEffectInvalidVectorVariable : public TEffectInvalidVariable<ID3DX11EffectVectorVariable>
{
public:
    STDMETHOD(SetFloatVector)(CONST float *pData) { return E_FAIL; };
    STDMETHOD(SetIntVector)(CONST int *pData) { return E_FAIL; };
    STDMETHOD(SetBoolVector)(CONST BOOL *pData) { return E_FAIL; };

    STDMETHOD(GetFloatVector)(float *pData) { return E_FAIL; };
    STDMETHOD(GetIntVector)(int *pData) { return E_FAIL; };
    STDMETHOD(GetBoolVector)(BOOL *pData) { return E_FAIL; };

    STDMETHOD(SetBoolVectorArray) (CONST BOOL *pData, UINT Offset, UINT Count) { return E_FAIL; };
    STDMETHOD(SetIntVectorArray)  (CONST int *pData, UINT Offset, UINT Count) { return E_FAIL; };
    STDMETHOD(SetFloatVectorArray)(CONST float *pData, UINT Offset, UINT Count) { return E_FAIL; };

    STDMETHOD(GetBoolVectorArray) (BOOL *pData, UINT Offset, UINT Count) { return E_FAIL; };
    STDMETHOD(GetIntVectorArray)  (int *pData, UINT Offset, UINT Count) { return E_FAIL; };
    STDMETHOD(GetFloatVectorArray)(float *pData, UINT Offset, UINT Count) { return E_FAIL; };

};

struct SEffectInvalidMatrixVariable : public TEffectInvalidVariable<ID3DX11EffectMatrixVariable>
{
public:

    STDMETHOD(SetMatrix)(CONST float *pData) { return E_FAIL; }
    STDMETHOD(GetMatrix)(float *pData) { return E_FAIL; }

    STDMETHOD(SetMatrixArray)(CONST float *pData, UINT  Offset, UINT  Count) { return E_FAIL; }
    STDMETHOD(GetMatrixArray)(float *pData, UINT  Offset, UINT  Count) { return E_FAIL; }

    STDMETHOD(SetMatrixPointerArray)(CONST float **ppData, UINT  Offset, UINT  Count) { return E_FAIL; }
    STDMETHOD(GetMatrixPointerArray)(float **ppData, UINT  Offset, UINT  Count) { return E_FAIL; }

    STDMETHOD(SetMatrixTranspose)(CONST float *pData) { return E_FAIL; }
    STDMETHOD(GetMatrixTranspose)(float *pData) { return E_FAIL; }

    STDMETHOD(SetMatrixTransposeArray)(CONST float *pData, UINT  Offset, UINT  Count) { return E_FAIL; }
    STDMETHOD(GetMatrixTransposeArray)(float *pData, UINT  Offset, UINT  Count) { return E_FAIL; }

    STDMETHOD(SetMatrixTransposePointerArray)(CONST float **ppData, UINT  Offset, UINT  Count) { return E_FAIL; }
    STDMETHOD(GetMatrixTransposePointerArray)(float **ppData, UINT  Offset, UINT  Count) { return E_FAIL; }
};

struct SEffectInvalidStringVariable : public TEffectInvalidVariable<ID3DX11EffectStringVariable>
{
public:

    STDMETHOD(GetString)(LPCSTR *ppString) { return E_FAIL; }
    STDMETHOD(GetStringArray)(LPCSTR *ppStrings, UINT  Offset, UINT  Count) { return E_FAIL; }
};

struct SEffectInvalidClassInstanceVariable : public TEffectInvalidVariable<ID3DX11EffectClassInstanceVariable>
{
public:

    STDMETHOD(GetClassInstance)(ID3D11ClassInstance **ppClassInstance) { return E_FAIL; }
};


struct SEffectInvalidInterfaceVariable : public TEffectInvalidVariable<ID3DX11EffectInterfaceVariable>
{
public:

    STDMETHOD(SetClassInstance)(ID3DX11EffectClassInstanceVariable *pEffectClassInstance) { return E_FAIL; }
    STDMETHOD(GetClassInstance)(ID3DX11EffectClassInstanceVariable **ppEffectClassInstance) { return E_FAIL; }
};


struct SEffectInvalidShaderResourceVariable : public TEffectInvalidVariable<ID3DX11EffectShaderResourceVariable>
{
public:

    STDMETHOD(SetResource)(ID3D11ShaderResourceView *pResource) { return E_FAIL; }
    STDMETHOD(GetResource)(ID3D11ShaderResourceView **ppResource) { return E_FAIL; }

    STDMETHOD(SetResourceArray)(ID3D11ShaderResourceView **ppResources, UINT  Offset, UINT  Count) { return E_FAIL; }
    STDMETHOD(GetResourceArray)(ID3D11ShaderResourceView **ppResources, UINT  Offset, UINT  Count) { return E_FAIL; }
};


struct SEffectInvalidUnorderedAccessViewVariable : public TEffectInvalidVariable<ID3DX11EffectUnorderedAccessViewVariable>
{
public:

    STDMETHOD(SetUnorderedAccessView)(ID3D11UnorderedAccessView *pResource) { return E_FAIL; }
    STDMETHOD(GetUnorderedAccessView)(ID3D11UnorderedAccessView **ppResource) { return E_FAIL; }

    STDMETHOD(SetUnorderedAccessViewArray)(ID3D11UnorderedAccessView **ppResources, UINT  Offset, UINT  Count) { return E_FAIL; }
    STDMETHOD(GetUnorderedAccessViewArray)(ID3D11UnorderedAccessView **ppResources, UINT  Offset, UINT  Count) { return E_FAIL; }
};


struct SEffectInvalidRenderTargetViewVariable : public TEffectInvalidVariable<ID3DX11EffectRenderTargetViewVariable>
{
public:

    STDMETHOD(SetRenderTarget)(ID3D11RenderTargetView *pResource) { return E_FAIL; }
    STDMETHOD(GetRenderTarget)(ID3D11RenderTargetView **ppResource) { return E_FAIL; }

    STDMETHOD(SetRenderTargetArray)(ID3D11RenderTargetView **ppResources, UINT  Offset, UINT  Count) { return E_FAIL; }
    STDMETHOD(GetRenderTargetArray)(ID3D11RenderTargetView **ppResources, UINT  Offset, UINT  Count) { return E_FAIL; }
};


struct SEffectInvalidDepthStencilViewVariable : public TEffectInvalidVariable<ID3DX11EffectDepthStencilViewVariable>
{
public:

    STDMETHOD(SetDepthStencil)(ID3D11DepthStencilView *pResource) { return E_FAIL; }
    STDMETHOD(GetDepthStencil)(ID3D11DepthStencilView **ppResource) { return E_FAIL; }

    STDMETHOD(SetDepthStencilArray)(ID3D11DepthStencilView **ppResources, UINT  Offset, UINT  Count) { return E_FAIL; }
    STDMETHOD(GetDepthStencilArray)(ID3D11DepthStencilView **ppResources, UINT  Offset, UINT  Count) { return E_FAIL; }
};


struct SEffectInvalidConstantBuffer : public TEffectInvalidVariable<ID3DX11EffectConstantBuffer>
{
public:

    STDMETHOD(SetConstantBuffer)(ID3D11Buffer *pConstantBuffer) { return E_FAIL; }
    STDMETHOD(GetConstantBuffer)(ID3D11Buffer **ppConstantBuffer) { return E_FAIL; }
    STDMETHOD(UndoSetConstantBuffer)() { return E_FAIL; }

    STDMETHOD(SetTextureBuffer)(ID3D11ShaderResourceView *pTextureBuffer) { return E_FAIL; }
    STDMETHOD(GetTextureBuffer)(ID3D11ShaderResourceView **ppTextureBuffer) { return E_FAIL; }
    STDMETHOD(UndoSetTextureBuffer)() { return E_FAIL; }
};

struct SEffectInvalidShaderVariable : public TEffectInvalidVariable<ID3DX11EffectShaderVariable>
{
public:

    STDMETHOD(GetShaderDesc)(UINT ShaderIndex, D3DX11_EFFECT_SHADER_DESC *pDesc) { return E_FAIL; }

    STDMETHOD(GetVertexShader)(UINT ShaderIndex, ID3D11VertexShader **ppVS) { return E_FAIL; }
    STDMETHOD(GetGeometryShader)(UINT ShaderIndex, ID3D11GeometryShader **ppGS) { return E_FAIL; }
    STDMETHOD(GetPixelShader)(UINT ShaderIndex, ID3D11PixelShader **ppPS) { return E_FAIL; }
    STDMETHOD(GetHullShader)(UINT ShaderIndex, ID3D11HullShader **ppPS) { return E_FAIL; }
    STDMETHOD(GetDomainShader)(UINT ShaderIndex, ID3D11DomainShader **ppPS) { return E_FAIL; }
    STDMETHOD(GetComputeShader)(UINT ShaderIndex, ID3D11ComputeShader **ppPS) { return E_FAIL; }

    STDMETHOD(GetInputSignatureElementDesc)(UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc) { return E_FAIL; }
    STDMETHOD(GetOutputSignatureElementDesc)(UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc) { return E_FAIL; }
    STDMETHOD(GetPatchConstantSignatureElementDesc)(UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc) { return E_FAIL; }
};

struct SEffectInvalidBlendVariable : public TEffectInvalidVariable<ID3DX11EffectBlendVariable>
{
public:

    STDMETHOD(GetBlendState)(UINT Index, ID3D11BlendState **ppBlendState) { return E_FAIL; }
    STDMETHOD(SetBlendState)(UINT Index, ID3D11BlendState *pBlendState) { return E_FAIL; }
    STDMETHOD(UndoSetBlendState)(UINT Index) { return E_FAIL; }
    STDMETHOD(GetBackingStore)(UINT Index, D3D11_BLEND_DESC *pBlendDesc) { return E_FAIL; }
};

struct SEffectInvalidDepthStencilVariable : public TEffectInvalidVariable<ID3DX11EffectDepthStencilVariable>
{
public:

    STDMETHOD(GetDepthStencilState)(UINT Index, ID3D11DepthStencilState **ppDepthStencilState) { return E_FAIL; }
    STDMETHOD(SetDepthStencilState)(UINT Index, ID3D11DepthStencilState *pDepthStencilState) { return E_FAIL; }
    STDMETHOD(UndoSetDepthStencilState)(UINT Index) { return E_FAIL; }
    STDMETHOD(GetBackingStore)(UINT Index, D3D11_DEPTH_STENCIL_DESC *pDepthStencilDesc) { return E_FAIL; }
};

struct SEffectInvalidRasterizerVariable : public TEffectInvalidVariable<ID3DX11EffectRasterizerVariable>
{
public:

    STDMETHOD(GetRasterizerState)(UINT Index, ID3D11RasterizerState **ppRasterizerState) { return E_FAIL; }
    STDMETHOD(SetRasterizerState)(UINT Index, ID3D11RasterizerState *pRasterizerState) { return E_FAIL; }
    STDMETHOD(UndoSetRasterizerState)(UINT Index) { return E_FAIL; }
    STDMETHOD(GetBackingStore)(UINT Index, D3D11_RASTERIZER_DESC *pRasterizerDesc) { return E_FAIL; }
};

struct SEffectInvalidSamplerVariable : public TEffectInvalidVariable<ID3DX11EffectSamplerVariable>
{
public:

    STDMETHOD(GetSampler)(UINT Index, ID3D11SamplerState **ppSampler) { return E_FAIL; }
    STDMETHOD(SetSampler)(UINT Index, ID3D11SamplerState *pSampler) { return E_FAIL; }
    STDMETHOD(UndoSetSampler)(UINT Index) { return E_FAIL; }
    STDMETHOD(GetBackingStore)(UINT Index, D3D11_SAMPLER_DESC *pSamplerDesc) { return E_FAIL; }
};

struct SEffectInvalidPass : public ID3DX11EffectPass
{
public:
    STDMETHOD_(BOOL, IsValid)() { return FALSE; }
    STDMETHOD(GetDesc)(D3DX11_PASS_DESC *pDesc) { return E_FAIL; }

    STDMETHOD(GetVertexShaderDesc)(D3DX11_PASS_SHADER_DESC *pDesc) { return E_FAIL; }
    STDMETHOD(GetGeometryShaderDesc)(D3DX11_PASS_SHADER_DESC *pDesc) { return E_FAIL; }
    STDMETHOD(GetPixelShaderDesc)(D3DX11_PASS_SHADER_DESC *pDesc) { return E_FAIL; }
    STDMETHOD(GetHullShaderDesc)(D3DX11_PASS_SHADER_DESC *pDesc) { return E_FAIL; }
    STDMETHOD(GetDomainShaderDesc)(D3DX11_PASS_SHADER_DESC *pDesc) { return E_FAIL; }
    STDMETHOD(GetComputeShaderDesc)(D3DX11_PASS_SHADER_DESC *pDesc) { return E_FAIL; }

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(UINT Index) { return &g_InvalidScalarVariable; }
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(LPCSTR Name) { return &g_InvalidScalarVariable; }

    STDMETHOD(Apply)(UINT Flags, ID3D11DeviceContext* pContext) { return E_FAIL; }
    STDMETHOD(ComputeStateBlockMask)(D3DX11_STATE_BLOCK_MASK *pStateBlockMask) { return E_FAIL; }
};

struct SEffectInvalidTechnique : public ID3DX11EffectTechnique
{
public:
    STDMETHOD_(BOOL, IsValid)() { return FALSE; }
    STDMETHOD(GetDesc)(D3DX11_TECHNIQUE_DESC *pDesc) { return E_FAIL; }

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(UINT Index) { return &g_InvalidScalarVariable; }
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(LPCSTR Name) { return &g_InvalidScalarVariable; }

    STDMETHOD_(ID3DX11EffectPass*, GetPassByIndex)(UINT Index) { return &g_InvalidPass; }
    STDMETHOD_(ID3DX11EffectPass*, GetPassByName)(LPCSTR Name) { return &g_InvalidPass; }

    STDMETHOD(ComputeStateBlockMask)(D3DX11_STATE_BLOCK_MASK *pStateBlockMask) { return E_FAIL; }
};

struct SEffectInvalidGroup : public ID3DX11EffectGroup
{
public:
    STDMETHOD_(BOOL, IsValid)() { return FALSE; }
    STDMETHOD(GetDesc)(D3DX11_GROUP_DESC *pDesc) { return E_FAIL; }

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(UINT Index) { return &g_InvalidScalarVariable; }
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(LPCSTR Name) { return &g_InvalidScalarVariable; }

    STDMETHOD_(ID3DX11EffectTechnique*, GetTechniqueByIndex)(UINT Index) { return &g_InvalidTechnique; }
    STDMETHOD_(ID3DX11EffectTechnique*, GetTechniqueByName)(LPCSTR Name) { return &g_InvalidTechnique; }
};

//////////////////////////////////////////////////////////////////////////
// Helper routines
//////////////////////////////////////////////////////////////////////////

// This is an annoying warning that pops up in retail builds because 
// the code that jumps to "lExit" is conditionally not compiled.
// The only alternative is more #ifdefs in every function
#pragma warning( disable : 4102 ) // 'label' : unreferenced label

#define VERIFYPARAMETER(x) \
{ if (!(x)) { DPF(0, "%s: Parameter " #x " was NULL.", pFuncName); \
    __BREAK_ON_FAIL; hr = E_INVALIDARG; goto lExit; } }

static HRESULT AnnotationInvalidSetCall(LPCSTR pFuncName)
{
    DPF(0, "%s: Annotations are readonly", pFuncName);
    return D3DERR_INVALIDCALL;
}

static HRESULT ObjectSetRawValue()
{
    DPF(0, "ID3DX11EffectVariable::SetRawValue: Objects do not support ths call; please use the specific object accessors instead.");
    return D3DERR_INVALIDCALL;
}

static HRESULT ObjectGetRawValue()
{
    DPF(0, "ID3DX11EffectVariable::GetRawValue: Objects do not support ths call; please use the specific object accessors instead.");
    return D3DERR_INVALIDCALL;
}

ID3DX11EffectConstantBuffer * NoParentCB();

ID3DX11EffectVariable * GetAnnotationByIndexHelper(const char *pClassName, UINT Index, UINT  AnnotationCount, SAnnotation *pAnnotations);

ID3DX11EffectVariable * GetAnnotationByNameHelper(const char *pClassName, LPCSTR Name, UINT  AnnotationCount, SAnnotation *pAnnotations);

template<typename SVarType>
BOOL GetVariableByIndexHelper(UINT Index, UINT  VariableCount, SVarType *pVariables, 
                              BYTE *pBaseAddress, SVarType **ppMember, void **ppDataPtr)
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::GetMemberByIndex";

    if (Index >= VariableCount)
    {
        DPF(0, "%s: Invalid index (%d, total: %d)", pFuncName, Index, VariableCount);
        return FALSE;
    }

    *ppMember = pVariables + Index;
    *ppDataPtr = pBaseAddress + (*ppMember)->Data.Offset;
    return TRUE;
}

template<typename SVarType>
BOOL GetVariableByNameHelper(LPCSTR Name, UINT  VariableCount, SVarType *pVariables, 
                             BYTE *pBaseAddress, SVarType **ppMember, void **ppDataPtr, UINT* pIndex)
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::GetMemberByName";

    if (NULL == Name)
    {
        DPF(0, "%s: Parameter Name was NULL.", pFuncName);
        return FALSE;
    }

    UINT i;
    bool bHasSuper = false;

    for (i = 0; i < VariableCount; ++ i)
    {
        *ppMember = pVariables + i;
        D3DXASSERT(NULL != (*ppMember)->pName);
        if (strcmp((*ppMember)->pName, Name) == 0)
        {
            *ppDataPtr = pBaseAddress + (*ppMember)->Data.Offset;
            *pIndex = i;
            return TRUE;
        }
	else if (i == 0 &&
                 (*ppMember)->pName[0] == '$' &&
                 strcmp((*ppMember)->pName, "$super") == 0)
        {
            bHasSuper = true;
        }
    }

    if (bHasSuper)
    {
        SVarType* pSuper = pVariables;

        return GetVariableByNameHelper<SVarType>(Name,
                                                 pSuper->pType->StructType.Members,
                                                 (SVarType*)pSuper->pType->StructType.pMembers,
                                                 pBaseAddress + pSuper->Data.Offset,
                                                 ppMember,
                                                 ppDataPtr,
                                                 pIndex);
    }

    DPF(0, "%s: Variable [%s] not found", pFuncName, Name);
    return FALSE;
}

template<typename SVarType>
BOOL GetVariableBySemanticHelper(LPCSTR Semantic, UINT  VariableCount, SVarType *pVariables, 
                                 BYTE *pBaseAddress, SVarType **ppMember, void **ppDataPtr, UINT* pIndex)
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::GetMemberBySemantic";

    if (NULL == Semantic)
    {
        DPF(0, "%s: Parameter Semantic was NULL.", pFuncName);
        return FALSE;
    }

    UINT i;

    for (i = 0; i < VariableCount; ++ i)
    {
        *ppMember = pVariables + i;
        if (NULL != (*ppMember)->pSemantic &&
            _stricmp((*ppMember)->pSemantic, Semantic) == 0)
        {
            *ppDataPtr = pBaseAddress + (*ppMember)->Data.Offset;
            *pIndex = i;
            return TRUE;
        }
    }

    DPF(0, "%s: Variable with semantic [%s] not found", pFuncName, Semantic);
    return FALSE;
}

D3DX11INLINE BOOL AreBoundsValid(UINT  Offset, UINT  Count, CONST void *pData, CONST SType *pType, UINT  TotalUnpackedSize)
{
    if (Count == 0) return TRUE;
    UINT  singleElementSize = pType->GetTotalUnpackedSize(TRUE);
    D3DXASSERT(singleElementSize <= pType->Stride);

    return ((Offset + Count >= Offset) &&
        ((Offset + Count) < ((UINT)-1) / pType->Stride) &&
        (Count * pType->Stride + (BYTE*)pData >= (BYTE*)pData) &&
        ((Offset + Count - 1) * pType->Stride + singleElementSize <= TotalUnpackedSize));
}

// Note that the branches in this code is based on template parameters and will be compiled out
template<ETemplateVarType SourceType, ETemplateVarType DestType, typename SRC_TYPE, BOOL ValidatePtr>
__forceinline HRESULT CopyScalarValue(SRC_TYPE SrcValue, void *pDest, const char *pFuncName)
{
    HRESULT hr = S_OK;
#ifdef _DEBUG
    if (ValidatePtr)
        VERIFYPARAMETER(pDest);
#endif

    switch (SourceType)
    {
    case ETVT_Bool:
        switch (DestType)
        {
        case ETVT_Bool:
            *(int*)pDest = (SrcValue != 0) ? -1 : 0;
            break;

        case ETVT_Int:
            *(int*)pDest = SrcValue ? 1 : 0;
            break;

        case ETVT_Float:
            *(float*)pDest = SrcValue ? 1.0f : 0.0f;
            break;

        default:
            D3DXASSERT(0);
        }
        break;


    case ETVT_Int:
        switch (DestType)
        {
        case ETVT_Bool:
            *(int*)pDest = (SrcValue != 0) ? -1 : 0;
            break;

        case ETVT_Int:
            *(int*)pDest = (int) SrcValue;
            break;

        case ETVT_Float:
            *(float*)pDest = (float)(SrcValue);
            break;

        default:
            D3DXASSERT(0);
        }
        break;

    case ETVT_Float:
        switch (DestType)
        {
        case ETVT_Bool:
            *(int*)pDest = (SrcValue != 0.0f) ? -1 : 0;
            break;

        case ETVT_Int:
            *(int*)pDest = (int) (SrcValue);
            break;

        case ETVT_Float:
            *(float*)pDest = (float) SrcValue;
            break;

        default:
            D3DXASSERT(0);
        }
        break;

    default:
        D3DXASSERT(0);
    }

lExit:
    return S_OK;
}

template<ETemplateVarType SourceType, ETemplateVarType DestType, typename SRC_TYPE, typename DEST_TYPE>
D3DX11INLINE HRESULT SetScalarArray(CONST SRC_TYPE *pSrcValues, DEST_TYPE *pDestValues, UINT  Offset, UINT  Count, 
                                    SType *pType, UINT  TotalUnpackedSize, const char *pFuncName)
{
    HRESULT hr = S_OK;

#ifdef _DEBUG    
    VERIFYPARAMETER(pSrcValues);

    if (!AreBoundsValid(Offset, Count, pSrcValues, pType, TotalUnpackedSize))
    {
        DPF(0, "%s: Invalid range specified", pFuncName);
        VH(E_INVALIDARG);
    }
#endif

    UINT i, j, delta = pType->NumericType.IsPackedArray ? 1 : SType::c_ScalarsPerRegister;
    pDestValues += Offset * delta;
    for (i = 0, j = 0; j < Count; i += delta, ++ j)
    {
        // pDestValues[i] = (DEST_TYPE)pSrcValues[j];
        CopyScalarValue<SourceType, DestType, SRC_TYPE, FALSE>(pSrcValues[j], &pDestValues[i], "SetScalarArray");
    }

lExit:
    return hr;
}

template<ETemplateVarType SourceType, ETemplateVarType DestType, typename SRC_TYPE, typename DEST_TYPE>
D3DX11INLINE HRESULT GetScalarArray(SRC_TYPE *pSrcValues, DEST_TYPE *pDestValues, UINT  Offset, UINT  Count, 
                                    SType *pType, UINT  TotalUnpackedSize, const char *pFuncName)
{
    HRESULT hr = S_OK;

#ifdef _DEBUG    
    VERIFYPARAMETER(pDestValues);

    if (!AreBoundsValid(Offset, Count, pDestValues, pType, TotalUnpackedSize))
    {
        DPF(0, "%s: Invalid range specified", pFuncName);
        VH(E_INVALIDARG);
    }
#endif

    UINT i, j, delta = pType->NumericType.IsPackedArray ? 1 : SType::c_ScalarsPerRegister;
    pSrcValues += Offset * delta;
    for (i = 0, j = 0; j < Count; i += delta, ++ j)
    {
        // pDestValues[j] = (DEST_TYPE)pSrcValues[i];
        CopyScalarValue<SourceType, DestType, SRC_TYPE, FALSE>(pSrcValues[i], &pDestValues[j], "GetScalarArray");
    }

lExit:
    return hr;
}


//////////////////////////////////////////////////////////////////////////
// TVariable - implements type casting and member/element retrieval
//////////////////////////////////////////////////////////////////////////

// requires that IBaseInterface contain SVariable's fields and support ID3DX11EffectVariable
template<typename IBaseInterface>
struct TVariable : public IBaseInterface
{
    STDMETHOD_(BOOL, IsValid)() { return TRUE; }

    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(UINT Index)
    {
        SVariable *pMember;
        UDataPointer dataPtr;
        TTopLevelVariable<ID3DX11EffectVariable> *pTopLevelEntity = GetTopLevelEntity();

        if (((ID3DX11Effect*)pTopLevelEntity->pEffect)->IsOptimized())
        {
            DPF(0, "ID3DX11EffectVariable::GetMemberByIndex: Cannot get members; effect has been Optimize()'ed");
            return &g_InvalidScalarVariable;
        }

        if (pType->VarType != EVT_Struct)
        {
            DPF(0, "ID3DX11EffectVariable::GetMemberByIndex: Variable is not a structure");
            return &g_InvalidScalarVariable;
        }

        if (!GetVariableByIndexHelper<SVariable>(Index, pType->StructType.Members, pType->StructType.pMembers, 
            Data.pNumeric, &pMember, &dataPtr.pGeneric))
        {
            return &g_InvalidScalarVariable;
        }

        return pTopLevelEntity->pEffect->CreatePooledVariableMemberInterface(pTopLevelEntity, pMember, dataPtr, FALSE, Index);
    }

    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(LPCSTR Name)
    {
        SVariable *pMember;
        UDataPointer dataPtr;
        UINT index;
        TTopLevelVariable<ID3DX11EffectVariable> *pTopLevelEntity = GetTopLevelEntity();

        if (pTopLevelEntity->pEffect->IsOptimized())
        {
            DPF(0, "ID3DX11EffectVariable::GetMemberByName: Cannot get members; effect has been Optimize()'ed");
            return &g_InvalidScalarVariable;
        }

        if (pType->VarType != EVT_Struct)
        {
            DPF(0, "ID3DX11EffectVariable::GetMemberByName: Variable is not a structure");
            return &g_InvalidScalarVariable;
        }

        if (!GetVariableByNameHelper<SVariable>(Name, pType->StructType.Members, pType->StructType.pMembers, 
            Data.pNumeric, &pMember, &dataPtr.pGeneric, &index))
        {
            return &g_InvalidScalarVariable;

        }

        return pTopLevelEntity->pEffect->CreatePooledVariableMemberInterface(pTopLevelEntity, pMember, dataPtr, FALSE, index);
    }

    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(LPCSTR Semantic)
    {
        SVariable *pMember;
        UDataPointer dataPtr;
        UINT index;
        TTopLevelVariable<ID3DX11EffectVariable> *pTopLevelEntity = GetTopLevelEntity();

        if (pTopLevelEntity->pEffect->IsOptimized())
        {
            DPF(0, "ID3DX11EffectVariable::GetMemberBySemantic: Cannot get members; effect has been Optimize()'ed");
            return &g_InvalidScalarVariable;
        }

        if (pType->VarType != EVT_Struct)
        {
            DPF(0, "ID3DX11EffectVariable::GetMemberBySemantic: Variable is not a structure");
            return &g_InvalidScalarVariable;
        }

        if (!GetVariableBySemanticHelper<SVariable>(Semantic, pType->StructType.Members, pType->StructType.pMembers, 
            Data.pNumeric, &pMember, &dataPtr.pGeneric, &index))
        {
            return &g_InvalidScalarVariable;

        }

        return pTopLevelEntity->pEffect->CreatePooledVariableMemberInterface(pTopLevelEntity, pMember, dataPtr, FALSE, index);
    }

    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(UINT Index)
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::GetElement";
        TTopLevelVariable<ID3DX11EffectVariable> *pTopLevelEntity = GetTopLevelEntity();
        UDataPointer dataPtr;

        if (pTopLevelEntity->pEffect->IsOptimized())
        {
            DPF(0, "ID3DX11EffectVariable::GetElement: Cannot get element; effect has been Optimize()'ed");
            return &g_InvalidScalarVariable;
        }

        if (!IsArray())
        {
            DPF(0, "%s: This interface does not refer to an array", pFuncName);
            return &g_InvalidScalarVariable;
        }

        if (Index >= pType->Elements)
        {
            DPF(0, "%s: Invalid element index (%d, total: %d)", pFuncName, Index, pType->Elements);
            return &g_InvalidScalarVariable;
        }

        if (pType->BelongsInConstantBuffer())
        {
            dataPtr.pGeneric = Data.pNumeric + pType->Stride * Index;
        }
        else
        {
            dataPtr.pGeneric = GetBlockByIndex(pType->VarType, pType->ObjectType, Data.pGeneric, Index);
            if (NULL == dataPtr.pGeneric)
            {
                DPF(0, "%s: Internal error", pFuncName);
                return &g_InvalidScalarVariable;
            }
        }

        return pTopLevelEntity->pEffect->CreatePooledVariableMemberInterface(pTopLevelEntity, (SVariable *) this, dataPtr, TRUE, Index);
    }

    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)()
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::AsScalar";

        if (pType->VarType != EVT_Numeric || 
            pType->NumericType.NumericLayout != ENL_Scalar)
        {
            DPF(0, "%s: Invalid typecast", pFuncName);
            return &g_InvalidScalarVariable;
        }

        return (ID3DX11EffectScalarVariable *) this;
    }

    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)()
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::AsVector";

        if (pType->VarType != EVT_Numeric || 
            pType->NumericType.NumericLayout != ENL_Vector)
        {
            DPF(0, "%s: Invalid typecast", pFuncName);
            return &g_InvalidVectorVariable;
        }

        return (ID3DX11EffectVectorVariable *) this;
    }

    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)()
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::AsMatrix";

        if (pType->VarType != EVT_Numeric || 
            pType->NumericType.NumericLayout != ENL_Matrix)
        {
            DPF(0, "%s: Invalid typecast", pFuncName);
            return &g_InvalidMatrixVariable;
        }

        return (ID3DX11EffectMatrixVariable *) this;
    }

    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)()
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::AsString";

        if (!pType->IsObjectType(EOT_String))
        {
            DPF(0, "%s: Invalid typecast", pFuncName);
            return &g_InvalidStringVariable;
        }

        return (ID3DX11EffectStringVariable *) this;
    }

    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)()
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::AsClassInstance";

        if (!pType->IsClassInstance() )
        {
            DPF(0, "%s: Invalid typecast", pFuncName);
            return &g_InvalidClassInstanceVariable;
        }
        else if( pMemberData == NULL )
        {
            DPF(0, "%s: Non-global class instance variables (members of structs or classes) and class instances "
                   "inside tbuffers are not supported.", pFuncName );
            return &g_InvalidClassInstanceVariable;
        }

        return (ID3DX11EffectClassInstanceVariable *) this;
    }

    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)()
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::AsInterface";

        if (!pType->IsInterface())
        {
            DPF(0, "%s: Invalid typecast", pFuncName);
            return &g_InvalidInterfaceVariable;
        }

        return (ID3DX11EffectInterfaceVariable *) this;
    }

    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)()
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::AsShaderResource";

        if (!pType->IsShaderResource())
        {
            DPF(0, "%s: Invalid typecast", pFuncName);
            return &g_InvalidShaderResourceVariable;
        }

        return (ID3DX11EffectShaderResourceVariable *) this;
    }

    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)()
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::AsUnorderedAccessView";

        if (!pType->IsUnorderedAccessView())
        {
            DPF(0, "%s: Invalid typecast", pFuncName);
            return &g_InvalidUnorderedAccessViewVariable;
        }

        return (ID3DX11EffectUnorderedAccessViewVariable *) this;
    }

    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)()
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::AsRenderTargetView";

        if (!pType->IsRenderTargetView())
        {
            DPF(0, "%s: Invalid typecast", pFuncName);
            return &g_InvalidRenderTargetViewVariable;
        }

        return (ID3DX11EffectRenderTargetViewVariable *) this;
    }

    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)()
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::AsDepthStencilView";

        if (!pType->IsDepthStencilView())
        {
            DPF(0, "%s: Invalid typecast", pFuncName);
            return &g_InvalidDepthStencilViewVariable;
        }

        return (ID3DX11EffectDepthStencilViewVariable *) this;
    }

    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)()
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::AsConstantBuffer";
        DPF(0, "%s: Invalid typecast", pFuncName);
        return &g_InvalidConstantBuffer;
    }

    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)()
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::AsShader";

        if (!pType->IsShader())
        {
            DPF(0, "%s: Invalid typecast", pFuncName);
            return &g_InvalidShaderVariable;
        }

        return (ID3DX11EffectShaderVariable *) this;
    }

    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)()
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::AsBlend";

        if (!pType->IsObjectType(EOT_Blend))
        {
            DPF(0, "%s: Invalid typecast", pFuncName);
            return &g_InvalidBlendVariable;
        }

        return (ID3DX11EffectBlendVariable *) this;
    }

    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)()
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::AsDepthStencil";

        if (!pType->IsObjectType(EOT_DepthStencil))
        {
            DPF(0, "%s: Invalid typecast", pFuncName);
            return &g_InvalidDepthStencilVariable;
        }

        return (ID3DX11EffectDepthStencilVariable *) this;
    }

    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)()
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::AsRasterizer";

        if (!pType->IsObjectType(EOT_Rasterizer))
        {
            DPF(0, "%s: Invalid typecast", pFuncName);
            return &g_InvalidRasterizerVariable;
        }

        return (ID3DX11EffectRasterizerVariable *) this;
    }

    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)()
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::AsSampler";

        if (!pType->IsSampler())
        {
            DPF(0, "%s: Invalid typecast", pFuncName);
            return &g_InvalidSamplerVariable;
        }

        return (ID3DX11EffectSamplerVariable *) this;
    }

    // Numeric variables should override this
    STDMETHOD(SetRawValue)(CONST void *pData, UINT  Offset, UINT  Count) { return ObjectSetRawValue(); }
    STDMETHOD(GetRawValue)(void *pData, UINT  Offset, UINT  Count) { return ObjectGetRawValue(); }
};

//////////////////////////////////////////////////////////////////////////
// TTopLevelVariable - functionality for annotations and global variables
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TTopLevelVariable : public SVariable, public IBaseInterface
{
    // Required to create member/element variable interfaces
    CEffect *pEffect;

    CEffect* GetEffect()
    {
        return pEffect;
    }

    TTopLevelVariable()
    {
        pEffect = NULL;
    }

    UINT  GetTotalUnpackedSize()
    {
        return ((SType*)pType)->GetTotalUnpackedSize(FALSE);
    }

    STDMETHOD_(ID3DX11EffectType*, GetType)()
    {
        return (ID3DX11EffectType*)(SType*)pType;
    }

    TTopLevelVariable<ID3DX11EffectVariable> * GetTopLevelEntity()
    {
        return (TTopLevelVariable<ID3DX11EffectVariable> *)this;
    }

    BOOL IsArray()
    {
        return (pType->Elements > 0);
    }

};

//////////////////////////////////////////////////////////////////////////
// TMember - functionality for structure/array members of other variables
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TMember : public SVariable, public IBaseInterface
{
    // Indicates that this is a single element of a containing array
    UINT                                        IsSingleElement : 1;

    // Required to create member/element variable interfaces
    TTopLevelVariable<ID3DX11EffectVariable>    *pTopLevelEntity;

    TMember()
    {
        IsSingleElement = FALSE;
        pTopLevelEntity = NULL;
    }

    CEffect* GetEffect()
    {
        return pTopLevelEntity->pEffect;
    }

    UINT  GetTotalUnpackedSize()
    {
        return pType->GetTotalUnpackedSize(IsSingleElement);
    }

    STDMETHOD_(ID3DX11EffectType*, GetType)()
    {
        if (IsSingleElement)
        {
            return pTopLevelEntity->pEffect->CreatePooledSingleElementTypeInterface( pType );
        }
        else
        {
            return (ID3DX11EffectType*) pType;
        }
    }

    STDMETHOD(GetDesc)(D3DX11_EFFECT_VARIABLE_DESC *pDesc)
    {
        HRESULT hr = S_OK;
        LPCSTR pFuncName = "ID3DX11EffectVariable::GetDesc";

        VERIFYPARAMETER(pDesc != NULL);

        pDesc->Name = pName;
        pDesc->Semantic = pSemantic;
        pDesc->Flags = 0;

        if (pTopLevelEntity->pEffect->IsReflectionData(pTopLevelEntity))
        {
            // Is part of an annotation
            D3DXASSERT(pTopLevelEntity->pEffect->IsReflectionData(Data.pGeneric));
            pDesc->Annotations = 0;
            pDesc->BufferOffset = 0;
            pDesc->Flags |= D3DX11_EFFECT_VARIABLE_ANNOTATION;
        }
        else
        {
            // Is part of a global variable
            D3DXASSERT(pTopLevelEntity->pEffect->IsRuntimeData(pTopLevelEntity));
            if (!pTopLevelEntity->pType->IsObjectType(EOT_String))
            {
                // strings are funny; their data is reflection data, so ignore those
                D3DXASSERT(pTopLevelEntity->pEffect->IsRuntimeData(Data.pGeneric));
            }
            
            pDesc->Annotations = ((TGlobalVariable<ID3DX11Effect>*)pTopLevelEntity)->AnnotationCount;

            SConstantBuffer *pCB = ((TGlobalVariable<ID3DX11Effect>*)pTopLevelEntity)->pCB;

            if (pType->BelongsInConstantBuffer())
            {   
                D3DXASSERT(pCB != NULL);
                UINT_PTR offset = Data.pNumeric - pCB->pBackingStore;
                D3DXASSERT(offset == (UINT)offset);
                pDesc->BufferOffset = (UINT)offset;
                D3DXASSERT(pDesc->BufferOffset >= 0 && pDesc->BufferOffset + GetTotalUnpackedSize() <= pCB->Size);
            }
            else
            {
                D3DXASSERT(pCB == NULL);
                pDesc->BufferOffset = 0;
            }
        }

lExit:
        return hr;
    }

    TTopLevelVariable<ID3DX11EffectVariable> * GetTopLevelEntity()
    {
        return pTopLevelEntity;
    }

    BOOL IsArray()
    {
        return (pType->Elements > 0 && !IsSingleElement);
    }

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(UINT Index)
    { return pTopLevelEntity->GetAnnotationByIndex(Index); }
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(LPCSTR Name)
    { return pTopLevelEntity->GetAnnotationByName(Name); }

    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)()
    { return pTopLevelEntity->GetParentConstantBuffer(); }

    // Annotations should never be able to go down this codepath
    void DirtyVariable()
    {
        // make sure to call the global variable's version of dirty variable
        ((TGlobalVariable<ID3DX11EffectVariable>*)pTopLevelEntity)->DirtyVariable();
    }
};

//////////////////////////////////////////////////////////////////////////
// TAnnotation - functionality for top level annotations
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TAnnotation : public TVariable<TTopLevelVariable<IBaseInterface> >
{
    STDMETHOD(GetDesc)(D3DX11_EFFECT_VARIABLE_DESC *pDesc)
    {
        HRESULT hr = S_OK;
        LPCSTR pFuncName = "ID3DX11EffectVariable::GetDesc";

        VERIFYPARAMETER(pDesc != NULL);

        pDesc->Name = pName;
        pDesc->Semantic = pSemantic;
        pDesc->Flags = D3DX11_EFFECT_VARIABLE_ANNOTATION;
        pDesc->Annotations = 0;
        pDesc->BufferOffset = 0;
        pDesc->ExplicitBindPoint = 0;

lExit:
        return hr;

    }

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(UINT Index)
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::GetAnnotationByIndex";
        DPF(0, "%s: Only variables may have annotations", pFuncName);
        return &g_InvalidScalarVariable;
    }

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(LPCSTR Name)
    {
        LPCSTR pFuncName = "ID3DX11EffectVariable::GetAnnotationByName";
        DPF(0, "%s: Only variables may have annotations", pFuncName);
        return &g_InvalidScalarVariable;
    }

    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)()
    { return NoParentCB(); }

    void DirtyVariable()
    {
        D3DXASSERT(0);
    }
};

//////////////////////////////////////////////////////////////////////////
// TGlobalVariable - functionality for top level global variables
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TGlobalVariable : public TVariable<TTopLevelVariable<IBaseInterface> >
{
    Timer           LastModifiedTime;

    // if numeric, pointer to the constant buffer where this variable lives
    SConstantBuffer *pCB;

    UINT            AnnotationCount;
    SAnnotation     *pAnnotations;

    TGlobalVariable()
    {
        LastModifiedTime = 0;
        pCB = NULL;
        AnnotationCount = 0;
        pAnnotations = NULL;
    }

    STDMETHOD(GetDesc)(D3DX11_EFFECT_VARIABLE_DESC *pDesc)
    {
        HRESULT hr = S_OK;
        LPCSTR pFuncName = "ID3DX11EffectVariable::GetDesc";

        VERIFYPARAMETER(pDesc != NULL);

        pDesc->Name = pName;
        pDesc->Semantic = pSemantic;
        pDesc->Flags = 0;
        pDesc->Annotations = AnnotationCount;

        if (pType->BelongsInConstantBuffer())
        {
            D3DXASSERT(pCB != NULL);
            UINT_PTR offset = Data.pNumeric - pCB->pBackingStore;
            D3DXASSERT(offset == (UINT)offset);
            pDesc->BufferOffset = (UINT)offset;
            D3DXASSERT(pDesc->BufferOffset >= 0 && pDesc->BufferOffset + GetTotalUnpackedSize() <= pCB->Size );
        }
        else
        {
            D3DXASSERT(pCB == NULL);
            pDesc->BufferOffset = 0;
        }

        if (ExplicitBindPoint != -1)
        {
            pDesc->ExplicitBindPoint = ExplicitBindPoint;
            pDesc->Flags |= D3DX11_EFFECT_VARIABLE_EXPLICIT_BIND_POINT;
        }
        else
        {
            pDesc->ExplicitBindPoint = 0;
        }

lExit:
        return hr;
    }

    // these are all well defined for global vars
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(UINT Index)
    {
        return GetAnnotationByIndexHelper("ID3DX11EffectVariable", Index, AnnotationCount, pAnnotations);
    }

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(LPCSTR Name)
    {
        return GetAnnotationByNameHelper("ID3DX11EffectVariable", Name, AnnotationCount, pAnnotations);
    }

    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)()
    { 
        if (NULL != pCB)
        {
            D3DXASSERT(pType->BelongsInConstantBuffer());
            return (ID3DX11EffectConstantBuffer*)pCB; 
        }
        else
        {
            D3DXASSERT(!pType->BelongsInConstantBuffer());
            return &g_InvalidConstantBuffer;
        }
    }

    D3DX11INLINE void DirtyVariable()
    {
        D3DXASSERT(NULL != pCB);
        pCB->IsDirty = TRUE;
        LastModifiedTime = pEffect->GetCurrentTime();
    }

};

//////////////////////////////////////////////////////////////////////////
// TNumericVariable - implements raw set/get functionality
//////////////////////////////////////////////////////////////////////////

// IMPORTANT NOTE: All of these numeric & object aspect classes MUST NOT
// add data members to the base variable classes.  Otherwise type sizes 
// will disagree between object & numeric variables and we cannot eaily 
// create arrays of global variables using SGlobalVariable

// Requires that IBaseInterface have SVariable's members, GetTotalUnpackedSize() and DirtyVariable()
template<typename IBaseInterface, BOOL IsAnnotation>
struct TNumericVariable : public IBaseInterface
{
    STDMETHOD(SetRawValue)(CONST void *pData, UINT  ByteOffset, UINT  ByteCount) 
    {
        if (IsAnnotation)
        {
            return AnnotationInvalidSetCall("ID3DX11EffectVariable::SetRawValue");
        }
        else
        {
            HRESULT hr = S_OK;    

#ifdef _DEBUG
            LPCSTR pFuncName = "ID3DX11EffectVariable::SetRawValue";

            VERIFYPARAMETER(pData);

            if ((ByteOffset + ByteCount < ByteOffset) ||
                (ByteCount + (BYTE*)pData < (BYTE*)pData) ||
                ((ByteOffset + ByteCount) > GetTotalUnpackedSize()))
            {
                // overflow of some kind
                DPF(0, "%s: Invalid range specified", pFuncName);
                VH(E_INVALIDARG);
            }
#endif

            DirtyVariable();
            memcpy(Data.pNumeric + ByteOffset, pData, ByteCount);

lExit:
            return hr;
        }
    }

    STDMETHOD(GetRawValue)(__out_bcount(ByteCount) void *pData, UINT  ByteOffset, UINT  ByteCount)
    {
        HRESULT hr = S_OK;    

#ifdef _DEBUG
        LPCSTR pFuncName = "ID3DX11EffectVariable::GetRawValue";

        VERIFYPARAMETER(pData);

        if ((ByteOffset + ByteCount < ByteOffset) ||
            (ByteCount + (BYTE*)pData < (BYTE*)pData) ||
            ((ByteOffset + ByteCount) > GetTotalUnpackedSize()))
        {
            // overflow of some kind
            DPF(0, "%s: Invalid range specified", pFuncName);
            VH(E_INVALIDARG);
        }
#endif

        memcpy(pData, Data.pNumeric + ByteOffset, ByteCount);

lExit:
        return hr;
    }
};

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectScalarVariable (TFloatScalarVariable implementation)
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface, BOOL IsAnnotation>
struct TFloatScalarVariable : public TNumericVariable<IBaseInterface, IsAnnotation>
{
    STDMETHOD(SetFloat)(CONST float Value);
    STDMETHOD(GetFloat)(float *pValue);

    STDMETHOD(SetFloatArray)(CONST float *pData, UINT  Offset, UINT  Count);
    STDMETHOD(GetFloatArray)(float *pData, UINT  Offset, UINT  Count);

    STDMETHOD(SetInt)(CONST int Value);
    STDMETHOD(GetInt)(int *pValue);

    STDMETHOD(SetIntArray)(CONST int *pData, UINT  Offset, UINT  Count);
    STDMETHOD(GetIntArray)(int *pData, UINT  Offset, UINT  Count);

    STDMETHOD(SetBool)(CONST BOOL Value);
    STDMETHOD(GetBool)(BOOL *pValue);

    STDMETHOD(SetBoolArray)(CONST BOOL *pData, UINT  Offset, UINT  Count);
    STDMETHOD(GetBoolArray)(BOOL *pData, UINT  Offset, UINT  Count);
};

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TFloatScalarVariable<IBaseInterface, IsAnnotation>::SetFloat(float Value)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetFloat";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return CopyScalarValue<ETVT_Float, ETVT_Float, float, FALSE>(Value, Data.pNumericFloat, pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TFloatScalarVariable<IBaseInterface, IsAnnotation>::GetFloat(float *pValue)
{
    return CopyScalarValue<ETVT_Float, ETVT_Float, float, TRUE>(*Data.pNumericFloat, pValue, "ID3DX11EffectScalarVariable::GetFloat");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TFloatScalarVariable<IBaseInterface, IsAnnotation>::SetFloatArray(CONST float *pData, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetFloatArray";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return SetScalarArray<ETVT_Float, ETVT_Float, float, float>(pData, Data.pNumericFloat, Offset, Count, 
        pType, GetTotalUnpackedSize(), pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TFloatScalarVariable<IBaseInterface, IsAnnotation>::GetFloatArray(float *pData, UINT  Offset, UINT  Count)
{
    return GetScalarArray<ETVT_Float, ETVT_Float, float, float>(Data.pNumericFloat, pData, Offset, Count, 
        pType, GetTotalUnpackedSize(), "ID3DX11EffectScalarVariable::GetFloatArray");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TFloatScalarVariable<IBaseInterface, IsAnnotation>::SetInt(CONST int Value)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetInt";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return CopyScalarValue<ETVT_Int, ETVT_Float, int, FALSE>(Value, Data.pNumericFloat, pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TFloatScalarVariable<IBaseInterface, IsAnnotation>::GetInt(int *pValue)
{
    return CopyScalarValue<ETVT_Float, ETVT_Int, float, TRUE>(*Data.pNumericFloat, pValue, "ID3DX11EffectScalarVariable::GetInt");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TFloatScalarVariable<IBaseInterface, IsAnnotation>::SetIntArray(CONST int *pData, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetIntArray";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return SetScalarArray<ETVT_Int, ETVT_Float, int, float>(pData, Data.pNumericFloat, Offset, Count, 
        pType, GetTotalUnpackedSize(), pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TFloatScalarVariable<IBaseInterface, IsAnnotation>::GetIntArray(int *pData, UINT  Offset, UINT  Count)
{
    return GetScalarArray<ETVT_Float, ETVT_Int, float, int>(Data.pNumericFloat, pData, Offset, Count, 
        pType, GetTotalUnpackedSize(), "ID3DX11EffectScalarVariable::GetIntArray");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TFloatScalarVariable<IBaseInterface, IsAnnotation>::SetBool(CONST BOOL Value)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetBool";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return CopyScalarValue<ETVT_Bool, ETVT_Float, BOOL, FALSE>(Value, Data.pNumericFloat, pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TFloatScalarVariable<IBaseInterface, IsAnnotation>::GetBool(BOOL *pValue)
{
    return CopyScalarValue<ETVT_Float, ETVT_Bool, float, TRUE>(*Data.pNumericFloat, pValue, "ID3DX11EffectScalarVariable::GetBool");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TFloatScalarVariable<IBaseInterface, IsAnnotation>::SetBoolArray(CONST BOOL *pData, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetBoolArray";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return SetScalarArray<ETVT_Bool, ETVT_Float, BOOL, float>(pData, Data.pNumericFloat, Offset, Count, 
        pType, GetTotalUnpackedSize(), pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TFloatScalarVariable<IBaseInterface, IsAnnotation>::GetBoolArray(BOOL *pData, UINT  Offset, UINT  Count)
{
    return GetScalarArray<ETVT_Float, ETVT_Bool, float, BOOL>(Data.pNumericFloat, pData, Offset, Count, 
        pType, GetTotalUnpackedSize(), "ID3DX11EffectScalarVariable::GetBoolArray");
}

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectScalarVariable (TIntScalarVariable implementation)
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface, BOOL IsAnnotation>
struct TIntScalarVariable : public TNumericVariable<IBaseInterface, IsAnnotation>
{
    STDMETHOD(SetFloat)(CONST float Value);
    STDMETHOD(GetFloat)(float *pValue);

    STDMETHOD(SetFloatArray)(CONST float *pData, UINT  Offset, UINT  Count);
    STDMETHOD(GetFloatArray)(float *pData, UINT  Offset, UINT  Count);

    STDMETHOD(SetInt)(CONST int Value);
    STDMETHOD(GetInt)(int *pValue);

    STDMETHOD(SetIntArray)(CONST int *pData, UINT  Offset, UINT  Count);
    STDMETHOD(GetIntArray)(int *pData, UINT  Offset, UINT  Count);

    STDMETHOD(SetBool)(CONST BOOL Value);
    STDMETHOD(GetBool)(BOOL *pValue);

    STDMETHOD(SetBoolArray)(CONST BOOL *pData, UINT  Offset, UINT  Count);
    STDMETHOD(GetBoolArray)(BOOL *pData, UINT  Offset, UINT  Count);
};

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TIntScalarVariable<IBaseInterface, IsAnnotation>::SetFloat(float Value)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetFloat";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return CopyScalarValue<ETVT_Float, ETVT_Int, float, FALSE>(Value, Data.pNumericInt, pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TIntScalarVariable<IBaseInterface, IsAnnotation>::GetFloat(float *pValue)
{
    return CopyScalarValue<ETVT_Int, ETVT_Float, int, TRUE>(*Data.pNumericInt, pValue, "ID3DX11EffectScalarVariable::GetFloat");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TIntScalarVariable<IBaseInterface, IsAnnotation>::SetFloatArray(CONST float *pData, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetFloatArray";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return SetScalarArray<ETVT_Float, ETVT_Int, float, int>(pData, Data.pNumericInt, Offset, Count, 
        pType, GetTotalUnpackedSize(), pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TIntScalarVariable<IBaseInterface, IsAnnotation>::GetFloatArray(float *pData, UINT  Offset, UINT  Count)
{
    return GetScalarArray<ETVT_Int, ETVT_Float, int, float>(Data.pNumericInt, pData, Offset, Count, 
        pType, GetTotalUnpackedSize(), "ID3DX11EffectScalarVariable::GetFloatArray");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TIntScalarVariable<IBaseInterface, IsAnnotation>::SetInt(CONST int Value)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetInt";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return CopyScalarValue<ETVT_Int, ETVT_Int, int, FALSE>(Value, Data.pNumericInt, pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TIntScalarVariable<IBaseInterface, IsAnnotation>::GetInt(int *pValue)
{
    return CopyScalarValue<ETVT_Int, ETVT_Int, int, TRUE>(*Data.pNumericInt, pValue, "ID3DX11EffectScalarVariable::GetInt");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TIntScalarVariable<IBaseInterface, IsAnnotation>::SetIntArray(CONST int *pData, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetIntArray";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return SetScalarArray<ETVT_Int, ETVT_Int, int, int>(pData, Data.pNumericInt, Offset, Count, 
        pType, GetTotalUnpackedSize(), pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TIntScalarVariable<IBaseInterface, IsAnnotation>::GetIntArray(int *pData, UINT  Offset, UINT  Count)
{
    return GetScalarArray<ETVT_Int, ETVT_Int, int, int>(Data.pNumericInt, pData, Offset, Count, 
        pType, GetTotalUnpackedSize(), "ID3DX11EffectScalarVariable::GetIntArray");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TIntScalarVariable<IBaseInterface, IsAnnotation>::SetBool(CONST BOOL Value)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetBool";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return CopyScalarValue<ETVT_Bool, ETVT_Int, BOOL, FALSE>(Value, Data.pNumericInt, pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TIntScalarVariable<IBaseInterface, IsAnnotation>::GetBool(BOOL *pValue)
{
    return CopyScalarValue<ETVT_Int, ETVT_Bool, int, TRUE>(*Data.pNumericInt, pValue, "ID3DX11EffectScalarVariable::GetBool");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TIntScalarVariable<IBaseInterface, IsAnnotation>::SetBoolArray(CONST BOOL *pData, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetBoolArray";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return SetScalarArray<ETVT_Bool, ETVT_Int, BOOL, int>(pData, Data.pNumericInt, Offset, Count, 
        pType, GetTotalUnpackedSize(), pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TIntScalarVariable<IBaseInterface, IsAnnotation>::GetBoolArray(BOOL *pData, UINT  Offset, UINT  Count)
{
    return GetScalarArray<ETVT_Int, ETVT_Bool, int, BOOL>(Data.pNumericInt, pData, Offset, Count, 
        pType, GetTotalUnpackedSize(), "ID3DX11EffectScalarVariable::GetBoolArray");
}

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectScalarVariable (TBoolScalarVariable implementation)
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface, BOOL IsAnnotation>
struct TBoolScalarVariable : public TNumericVariable<IBaseInterface, IsAnnotation>
{
    STDMETHOD(SetFloat)(CONST float Value);
    STDMETHOD(GetFloat)(float *pValue);

    STDMETHOD(SetFloatArray)(CONST float *pData, UINT  Offset, UINT  Count);
    STDMETHOD(GetFloatArray)(float *pData, UINT  Offset, UINT  Count);

    STDMETHOD(SetInt)(CONST int Value);
    STDMETHOD(GetInt)(int *pValue);

    STDMETHOD(SetIntArray)(CONST int *pData, UINT  Offset, UINT  Count);
    STDMETHOD(GetIntArray)(int *pData, UINT  Offset, UINT  Count);

    STDMETHOD(SetBool)(CONST BOOL Value);
    STDMETHOD(GetBool)(BOOL *pValue);

    STDMETHOD(SetBoolArray)(CONST BOOL *pData, UINT  Offset, UINT  Count);
    STDMETHOD(GetBoolArray)(BOOL *pData, UINT  Offset, UINT  Count);
};

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TBoolScalarVariable<IBaseInterface, IsAnnotation>::SetFloat(float Value)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetFloat";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return CopyScalarValue<ETVT_Float, ETVT_Bool, float, FALSE>(Value, Data.pNumericBool, pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TBoolScalarVariable<IBaseInterface, IsAnnotation>::GetFloat(float *pValue)
{
    return CopyScalarValue<ETVT_Bool, ETVT_Float, BOOL, TRUE>(*Data.pNumericBool, pValue, "ID3DX11EffectScalarVariable::GetFloat");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TBoolScalarVariable<IBaseInterface, IsAnnotation>::SetFloatArray(CONST float *pData, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetFloatArray";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return SetScalarArray<ETVT_Float, ETVT_Bool, float, BOOL>(pData, Data.pNumericBool, Offset, Count, 
        pType, GetTotalUnpackedSize(), pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TBoolScalarVariable<IBaseInterface, IsAnnotation>::GetFloatArray(float *pData, UINT  Offset, UINT  Count)
{
    return GetScalarArray<ETVT_Bool, ETVT_Float, BOOL, float>(Data.pNumericBool, pData, Offset, Count, 
        pType, GetTotalUnpackedSize(), "ID3DX11EffectScalarVariable::GetFloatArray");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TBoolScalarVariable<IBaseInterface, IsAnnotation>::SetInt(CONST int Value)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetInt";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return CopyScalarValue<ETVT_Int, ETVT_Bool, int, FALSE>(Value, Data.pNumericBool, pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TBoolScalarVariable<IBaseInterface, IsAnnotation>::GetInt(int *pValue)
{
    return CopyScalarValue<ETVT_Bool, ETVT_Int, BOOL, TRUE>(*Data.pNumericBool, pValue, "ID3DX11EffectScalarVariable::GetInt");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TBoolScalarVariable<IBaseInterface, IsAnnotation>::SetIntArray(CONST int *pData, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetIntArray";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return SetScalarArray<ETVT_Int, ETVT_Bool, int, BOOL>(pData, Data.pNumericBool, Offset, Count, 
        pType, GetTotalUnpackedSize(), pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TBoolScalarVariable<IBaseInterface, IsAnnotation>::GetIntArray(int *pData, UINT  Offset, UINT  Count)
{
    return GetScalarArray<ETVT_Bool, ETVT_Int, BOOL, int>(Data.pNumericBool, pData, Offset, Count, 
        pType, GetTotalUnpackedSize(), "ID3DX11EffectScalarVariable::GetIntArray");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TBoolScalarVariable<IBaseInterface, IsAnnotation>::SetBool(CONST BOOL Value)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetBool";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return CopyScalarValue<ETVT_Bool, ETVT_Bool, BOOL, FALSE>(Value, Data.pNumericBool, pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TBoolScalarVariable<IBaseInterface, IsAnnotation>::GetBool(BOOL *pValue)
{
    return CopyScalarValue<ETVT_Bool, ETVT_Bool, BOOL, TRUE>(*Data.pNumericBool, pValue, "ID3DX11EffectScalarVariable::GetBool");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TBoolScalarVariable<IBaseInterface, IsAnnotation>::SetBoolArray(CONST BOOL *pData, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectScalarVariable::SetBoolArray";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return SetScalarArray<ETVT_Bool, ETVT_Bool, BOOL, BOOL>(pData, Data.pNumericBool, Offset, Count, 
        pType, GetTotalUnpackedSize(), pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TBoolScalarVariable<IBaseInterface, IsAnnotation>::GetBoolArray(BOOL *pData, UINT  Offset, UINT  Count)
{
    return GetScalarArray<ETVT_Bool, ETVT_Bool, BOOL, BOOL>(Data.pNumericBool, pData, Offset, Count, 
        pType, GetTotalUnpackedSize(), "ID3DX11EffectScalarVariable::GetBoolArray");
}

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectVectorVariable (TVectorVariable implementation)
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface, BOOL IsAnnotation, ETemplateVarType BaseType >
struct TVectorVariable : public TNumericVariable<IBaseInterface, IsAnnotation>
{
    STDMETHOD(SetBoolVector) (CONST BOOL *pData); 
    STDMETHOD(SetIntVector)  (CONST int *pData);
    STDMETHOD(SetFloatVector)(CONST float *pData);

    STDMETHOD(GetBoolVector) (BOOL *pData); 
    STDMETHOD(GetIntVector)  (int *pData);
    STDMETHOD(GetFloatVector)(float *pData);


    STDMETHOD(SetBoolVectorArray) (CONST BOOL *pData, UINT Offset, UINT Count); 
    STDMETHOD(SetIntVectorArray)  (CONST int *pData, UINT Offset, UINT Count);
    STDMETHOD(SetFloatVectorArray)(CONST float *pData, UINT Offset, UINT Count);

    STDMETHOD(GetBoolVectorArray) (BOOL *pData, UINT Offset, UINT Count); 
    STDMETHOD(GetIntVectorArray)  (int *pData, UINT Offset, UINT Count);
    STDMETHOD(GetFloatVectorArray)(float *pData, UINT Offset, UINT Count);
};

// Note that branches in this code is based on template parameters and will be compiled out
template <ETemplateVarType DestType, ETemplateVarType SourceType>
void __forceinline CopyDataWithTypeConversion(__out_bcount(vecCount * dstVecSize * sizeof(UINT)) void *pDest, CONST void *pSource, UINT dstVecSize, UINT srcVecSize, UINT elementCount, UINT vecCount)
{
    UINT i, j;

    switch (SourceType)
    {
    case ETVT_Bool:
        switch (DestType)
        {
        case ETVT_Bool:
            for (j=0; j<vecCount; j++)
            {
                dwordMemcpy(pDest, pSource, elementCount * SType::c_ScalarSize);

                pDest = ((float*) pDest) + dstVecSize;
                pSource = ((float*) pSource) + srcVecSize;
            }
            break;

        case ETVT_Int:
            for (j=0; j<vecCount; j++)
            {
                for (i=0; i<elementCount; i++)
                    ((int*)pDest)[i] = ((BOOL*)pSource)[i] ? -1 : 0;

                pDest = ((float*) pDest) + dstVecSize;
                pSource = ((float*) pSource) + srcVecSize;
            }
            break;

        case ETVT_Float:
            for (j=0; j<vecCount; j++)
            {
                for (i=0; i<elementCount; i++)
                    ((float*)pDest)[i] = ((BOOL*)pSource)[i] ? -1.0f : 0.0f;

                pDest = ((float*) pDest) + dstVecSize;
                pSource = ((float*) pSource) + srcVecSize;
            }
            break;

        default:
            D3DXASSERT(0);
        }
        break;


    case ETVT_Int:
        switch (DestType)
        {
        case ETVT_Bool:
            for (j=0; j<vecCount; j++)
            {
                for (i=0; i<elementCount; i++)
                    ((int*)pDest)[i] = (((int*)pSource)[i] != 0) ? -1 : 0;

                pDest = ((float*) pDest) + dstVecSize;
                pSource = ((float*) pSource) + srcVecSize;
            }
            break;

        case ETVT_Int:
            for (j=0; j<vecCount; j++)
            {
                dwordMemcpy(pDest, pSource, elementCount * SType::c_ScalarSize);

                pDest = ((float*) pDest) + dstVecSize;
                pSource = ((float*) pSource) + srcVecSize;
            }
            break;

        case ETVT_Float:
            for (j=0; j<vecCount; j++)
            {
                for (i=0; i<elementCount; i++)
                    ((float*)pDest)[i] = (float)(((int*)pSource)[i]);

                pDest = ((float*) pDest) + dstVecSize;
                pSource = ((float*) pSource) + srcVecSize;
            }
            break;

        default:
            D3DXASSERT(0);
        }
        break;

    case ETVT_Float:
        switch (DestType)
        {
        case ETVT_Bool:
            for (j=0; j<vecCount; j++)
            {
                for (i=0; i<elementCount; i++)
                    ((int*)pDest)[i] = (((float*)pSource)[i] != 0.0f) ? -1 : 0;

                pDest = ((float*) pDest) + dstVecSize;
                pSource = ((float*) pSource) + srcVecSize;
            }
            break;

        case ETVT_Int:
            for (j=0; j<vecCount; j++)
            {
                for (i=0; i<elementCount; i++)
                    ((int*)pDest)[i] = (int)((float*)pSource)[i];

                pDest = ((float*) pDest) + dstVecSize;
                pSource = ((float*) pSource) + srcVecSize;
            }
            break;

        case ETVT_Float:
            for (i=0; i<vecCount; i++)
            {
                dwordMemcpy( pDest, pSource, elementCount * SType::c_ScalarSize);

                pDest = ((float*) pDest) + dstVecSize;
                pSource = ((float*) pSource) + srcVecSize;
            }
            break;

        default:
            D3DXASSERT(0);
        }
        break;

    default:
        D3DXASSERT(0);
    }
}

// Float Vector

template<typename IBaseInterface, BOOL IsAnnotation, ETemplateVarType BaseType>
HRESULT TVectorVariable<IBaseInterface, IsAnnotation, BaseType >::SetFloatVector(CONST float *pData)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectVectorVariable::SetFloatVector";

#ifdef _DEBUG
    VERIFYPARAMETER(pData);
#endif

    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    CopyDataWithTypeConversion<BaseType, ETVT_Float>(Data.pVector, pData, 4, pType->NumericType.Columns, pType->NumericType.Columns, 1);

lExit:
    return hr;
}

template<typename IBaseInterface, BOOL IsAnnotation, ETemplateVarType BaseType>
HRESULT TVectorVariable<IBaseInterface, IsAnnotation, BaseType>::GetFloatVector(float *pData)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectVectorVariable::GetFloatVector";

#ifdef _DEBUG
    VERIFYPARAMETER(pData);
#endif

    CopyDataWithTypeConversion<ETVT_Float, BaseType>(pData, Data.pVector, pType->NumericType.Columns, 4, pType->NumericType.Columns, 1);

lExit:
    return hr;
}

// Int Vector

template<typename IBaseInterface, BOOL IsAnnotation, ETemplateVarType BaseType>
HRESULT TVectorVariable<IBaseInterface, IsAnnotation, BaseType >::SetIntVector(CONST int *pData)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectVectorVariable::SetIntVector";

#ifdef _DEBUG
    VERIFYPARAMETER(pData);
#endif

    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    CopyDataWithTypeConversion<BaseType, ETVT_Int>(Data.pVector, pData, 4, pType->NumericType.Columns, pType->NumericType.Columns, 1);

lExit:
    return hr;
}

template<typename IBaseInterface, BOOL IsAnnotation, ETemplateVarType BaseType>
HRESULT TVectorVariable<IBaseInterface, IsAnnotation, BaseType>::GetIntVector(int *pData)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectVectorVariable::GetIntVector";

#ifdef _DEBUG
    VERIFYPARAMETER(pData);
#endif

    CopyDataWithTypeConversion<ETVT_Int, BaseType>(pData, Data.pVector, pType->NumericType.Columns, 4, pType->NumericType.Columns, 1);

lExit:
    return hr;
}

// Bool Vector

template<typename IBaseInterface, BOOL IsAnnotation, ETemplateVarType BaseType>
HRESULT TVectorVariable<IBaseInterface, IsAnnotation, BaseType >::SetBoolVector(CONST BOOL *pData)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectVectorVariable::SetBoolVector";

#ifdef _DEBUG
    VERIFYPARAMETER(pData);
#endif

    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    CopyDataWithTypeConversion<BaseType, ETVT_Bool>(Data.pVector, pData, 4, pType->NumericType.Columns, pType->NumericType.Columns, 1);

lExit:
    return hr;
}

template<typename IBaseInterface, BOOL IsAnnotation, ETemplateVarType BaseType>
HRESULT TVectorVariable<IBaseInterface, IsAnnotation, BaseType>::GetBoolVector(BOOL *pData)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectVectorVariable::GetBoolVector";

#ifdef _DEBUG
    VERIFYPARAMETER(pData);
#endif

    CopyDataWithTypeConversion<ETVT_Bool, BaseType>(pData, Data.pVector, pType->NumericType.Columns, 4, pType->NumericType.Columns, 1);

lExit:
    return hr;
}

// Vector Arrays /////////////////////////////////////////////////////////

template<typename IBaseInterface, BOOL IsAnnotation, ETemplateVarType BaseType>
HRESULT TVectorVariable<IBaseInterface, IsAnnotation, BaseType>::SetFloatVectorArray(CONST float *pData, UINT  Offset, UINT  Count)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectVectorVariable::SetFloatVectorArray";

#ifdef _DEBUG
    if (!AreBoundsValid(Offset, Count, pData, pType, GetTotalUnpackedSize()))
    {
        DPF(0, "%s: Invalid range specified", pFuncName);
        VH(E_INVALIDARG);
    }
#endif

    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    // ensure we don't write over the padding at the end of the vector array
    CopyDataWithTypeConversion<BaseType, ETVT_Float>(Data.pVector + Offset, pData, 4, pType->NumericType.Columns, pType->NumericType.Columns, max(min((int)Count, (int)pType->Elements - (int)Offset), 0));

lExit:
    return hr;
}

template<typename IBaseInterface, BOOL IsAnnotation, ETemplateVarType BaseType>
HRESULT TVectorVariable<IBaseInterface, IsAnnotation, BaseType>::GetFloatVectorArray(float *pData, UINT  Offset, UINT  Count)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectVectorVariable::GetFloatVectorArray";

#ifdef _DEBUG
    if (!AreBoundsValid(Offset, Count, pData, pType, GetTotalUnpackedSize()))
    {
        DPF(0, "%s: Invalid range specified", pFuncName);
        VH(E_INVALIDARG);
    }
#endif

    // ensure we don't read past the end of the vector array
    CopyDataWithTypeConversion<ETVT_Float, BaseType>(pData, Data.pVector + Offset, pType->NumericType.Columns, 4, pType->NumericType.Columns, max(min((int)Count, (int)pType->Elements - (int)Offset), 0));

lExit:
    return hr;
}

// int

template<typename IBaseInterface, BOOL IsAnnotation, ETemplateVarType BaseType>
HRESULT TVectorVariable<IBaseInterface, IsAnnotation, BaseType>::SetIntVectorArray(CONST int *pData, UINT  Offset, UINT  Count)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectVectorVariable::SetIntVectorArray";

#ifdef _DEBUG
    if (!AreBoundsValid(Offset, Count, pData, pType, GetTotalUnpackedSize()))
    {
        DPF(0, "%s: Invalid range specified", pFuncName);
        VH(E_INVALIDARG);
    }
#endif

    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    // ensure we don't write over the padding at the end of the vector array
    CopyDataWithTypeConversion<BaseType, ETVT_Int>(Data.pVector + Offset, pData, 4, pType->NumericType.Columns, pType->NumericType.Columns, max(min((int)Count, (int)pType->Elements - (int)Offset), 0));

lExit:
    return hr;
}

template<typename IBaseInterface, BOOL IsAnnotation, ETemplateVarType BaseType>
HRESULT TVectorVariable<IBaseInterface, IsAnnotation, BaseType>::GetIntVectorArray(int *pData, UINT  Offset, UINT  Count)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectVectorVariable::GetIntVectorArray";

#ifdef _DEBUG
    if (!AreBoundsValid(Offset, Count, pData, pType, GetTotalUnpackedSize()))
    {
        DPF(0, "%s: Invalid range specified", pFuncName);
        VH(E_INVALIDARG);
    }
#endif

    // ensure we don't read past the end of the vector array
    CopyDataWithTypeConversion<ETVT_Int, BaseType>(pData, Data.pVector + Offset, pType->NumericType.Columns, 4, pType->NumericType.Columns, max(min((int)Count, (int)pType->Elements - (int)Offset), 0));

lExit:
    return hr;
}

// bool

template<typename IBaseInterface, BOOL IsAnnotation, ETemplateVarType BaseType>
HRESULT TVectorVariable<IBaseInterface, IsAnnotation, BaseType>::SetBoolVectorArray(CONST BOOL *pData, UINT  Offset, UINT  Count)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectVectorVariable::SetBoolVectorArray";

#ifdef _DEBUG
    if (!AreBoundsValid(Offset, Count, pData, pType, GetTotalUnpackedSize()))
    {
        DPF(0, "%s: Invalid range specified", pFuncName);
        VH(E_INVALIDARG);
    }
#endif

    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    // ensure we don't write over the padding at the end of the vector array
    CopyDataWithTypeConversion<BaseType, ETVT_Bool>(Data.pVector + Offset, pData, 4, pType->NumericType.Columns, pType->NumericType.Columns, max(min((int)Count, (int)pType->Elements - (int)Offset), 0));

lExit:
    return hr;
}

template<typename IBaseInterface, BOOL IsAnnotation, ETemplateVarType BaseType>
HRESULT TVectorVariable<IBaseInterface, IsAnnotation, BaseType>::GetBoolVectorArray(BOOL *pData, UINT  Offset, UINT  Count)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectVectorVariable::GetBoolVectorArray";

#ifdef _DEBUG
    if (!AreBoundsValid(Offset, Count, pData, pType, GetTotalUnpackedSize()))
    {
        DPF(0, "%s: Invalid range specified", pFuncName);
        VH(E_INVALIDARG);
    }
#endif

    // ensure we don't read past the end of the vector array
    CopyDataWithTypeConversion<ETVT_Bool, BaseType>(pData, Data.pVector + Offset, pType->NumericType.Columns, 4, pType->NumericType.Columns, max(min((int)Count, (int)pType->Elements - (int)Offset), 0));

lExit:
    return hr;
}

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectVector4Variable (TVectorVariable implementation) [OPTIMIZED]
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TVector4Variable : public TVectorVariable<IBaseInterface, FALSE, ETVT_Float>
{
    STDMETHOD(SetFloatVector)(CONST float *pData);
    STDMETHOD(GetFloatVector)(float *pData);

    STDMETHOD(SetFloatVectorArray)(CONST float *pData, UINT Offset, UINT  Count);
    STDMETHOD(GetFloatVectorArray)(float *pData, UINT Offset, UINT  Count);
};

template<typename IBaseInterface>
HRESULT TVector4Variable<IBaseInterface>::SetFloatVector(CONST float *pData)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectVectorVariable::SetFloatVector";

#ifdef _DEBUG
    VERIFYPARAMETER(pData);
#endif

    DirtyVariable();
    Data.pVector[0] = ((CEffectVector4*) pData)[0];

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TVector4Variable<IBaseInterface>::GetFloatVector(float *pData)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectVectorVariable::GetFloatVector";

#ifdef _DEBUG
    VERIFYPARAMETER(pData);
#endif

    dwordMemcpy(pData, Data.pVector, pType->NumericType.Columns * SType::c_ScalarSize);

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TVector4Variable<IBaseInterface>::SetFloatVectorArray(CONST float *pData, UINT  Offset, UINT  Count)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectVectorVariable::SetFloatVectorArray";

#ifdef _DEBUG
    if (!AreBoundsValid(Offset, Count, pData, pType, GetTotalUnpackedSize()))
    {
        DPF(0, "%s: Invalid range specified", pFuncName);
        VH(E_INVALIDARG);
    }
#endif

    DirtyVariable();
    // ensure we don't write over the padding at the end of the vector array
    dwordMemcpy(Data.pVector + Offset, pData, min((Offset + Count) * sizeof(CEffectVector4), pType->TotalSize));

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TVector4Variable<IBaseInterface>::GetFloatVectorArray(float *pData, UINT  Offset, UINT  Count)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectVectorVariable::GetFloatVectorArray";

#ifdef _DEBUG
    if (!AreBoundsValid(Offset, Count, pData, pType, GetTotalUnpackedSize()))
    {
        DPF(0, "%s: Invalid range specified", pFuncName);
        VH(E_INVALIDARG);
    }
#endif

    // ensure we don't read past the end of the vector array
    dwordMemcpy(pData, Data.pVector + Offset, min((Offset + Count) * sizeof(CEffectVector4), pType->TotalSize));

lExit:
    return hr;
}


//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectMatrixVariable (TMatrixVariable implementation)
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface, BOOL IsAnnotation>
struct TMatrixVariable : public TNumericVariable<IBaseInterface, IsAnnotation>
{
    STDMETHOD(SetMatrix)(CONST float *pData);
    STDMETHOD(GetMatrix)(float *pData);

    STDMETHOD(SetMatrixArray)(CONST float *pData, UINT  Offset, UINT  Count);
    STDMETHOD(GetMatrixArray)(float *pData, UINT  Offset, UINT  Count);

    STDMETHOD(SetMatrixPointerArray)(CONST float **ppData, UINT  Offset, UINT  Count);
    STDMETHOD(GetMatrixPointerArray)(float **ppData, UINT  Offset, UINT  Count);

    STDMETHOD(SetMatrixTranspose)(CONST float *pData);
    STDMETHOD(GetMatrixTranspose)(float *pData);

    STDMETHOD(SetMatrixTransposeArray)(CONST float *pData, UINT  Offset, UINT  Count);
    STDMETHOD(GetMatrixTransposeArray)(float *pData, UINT  Offset, UINT  Count);

    STDMETHOD(SetMatrixTransposePointerArray)(CONST float **ppData, UINT  Offset, UINT  Count);
    STDMETHOD(GetMatrixTransposePointerArray)(float **ppData, UINT  Offset, UINT  Count);
};

template<BOOL Transpose>
static void SetMatrixTransposeHelper(SType *pType, __out_bcount(64) BYTE *pDestData, CONST float* pMatrix)
{
    UINT i, j;
    UINT registers, entries;
    
    if (Transpose)
    {
        // row major
        registers = pType->NumericType.Rows;
        entries = pType->NumericType.Columns;
    }
    else
    {
        // column major
        registers = pType->NumericType.Columns;
        entries = pType->NumericType.Rows;
    }
    __analysis_assume( registers <= 4 );
    __analysis_assume( entries <= 4 );

    for (i = 0; i < registers; ++ i)
    {
        for (j = 0; j < entries; ++ j)
        {
#pragma prefast(suppress:__WARNING_UNRELATED_LOOP_TERMINATION, "regs / entries <= 4")
            ((float*)pDestData)[j] = ((float*)pMatrix)[j * 4 + i];
        }
        pDestData += SType::c_RegisterSize;
    }
}

template<BOOL Transpose>
static void GetMatrixTransposeHelper(SType *pType, __in_bcount(64) BYTE *pSrcData, __out_ecount(16) float* pMatrix)
{
    UINT i, j;
    UINT registers, entries;

    if (Transpose)
    {
        // row major
        registers = pType->NumericType.Rows;
        entries = pType->NumericType.Columns;
    }
    else
    {
        // column major
        registers = pType->NumericType.Columns;
        entries = pType->NumericType.Rows;
    }
    __analysis_assume( registers <= 4 );
    __analysis_assume( entries <= 4 );

    for (i = 0; i < registers; ++ i)
    {
        for (j = 0; j < entries; ++ j)
        {
            ((float*)pMatrix)[j * 4 + i] = ((float*)pSrcData)[j];
        }
        pSrcData += SType::c_RegisterSize;
    }
}

template<BOOL Transpose, BOOL IsSetting, BOOL ExtraIndirection>
HRESULT DoMatrixArrayInternal(SType *pType, UINT  TotalUnpackedSize, BYTE *pEffectData, void *pMatrixData, UINT  Offset, UINT  Count, LPCSTR pFuncName)
{    
    HRESULT hr = S_OK;

#ifdef _DEBUG
    if (!AreBoundsValid(Offset, Count, pMatrixData, pType, TotalUnpackedSize))
    {
        DPF(0, "%s: Invalid range specified", pFuncName);
        VH(E_INVALIDARG);
    }
#endif

    UINT i;

    if ((pType->NumericType.IsColumnMajor && Transpose) || (!pType->NumericType.IsColumnMajor && !Transpose))
    {
        // fast path
        UINT  dataSize;
        if (Transpose)
        {
            dataSize = ((pType->NumericType.Columns - 1) * 4 + pType->NumericType.Rows) * SType::c_ScalarSize;
        }
        else
        {
            dataSize = ((pType->NumericType.Rows - 1) * 4 + pType->NumericType.Columns) * SType::c_ScalarSize;
        }

        for (i = 0; i < Count; ++ i)
        {
            CEffectMatrix *pMatrix;
            if (ExtraIndirection)
            {
                pMatrix = ((CEffectMatrix **)pMatrixData)[i];
                if (!pMatrix)
                {
                    continue;
                }
            }
            else
            {
                pMatrix = ((CEffectMatrix *)pMatrixData) + i;
            }

            if (IsSetting)
            {
                dwordMemcpy(pEffectData + pType->Stride * (i + Offset), pMatrix, dataSize);
            }
            else
            {
                dwordMemcpy(pMatrix, pEffectData + pType->Stride * (i + Offset), dataSize);
            }
        }
    }
    else
    {
        // slow path
        for (i = 0; i < Count; ++ i)
        {
            CEffectMatrix *pMatrix;
            if (ExtraIndirection)
            {
                pMatrix = ((CEffectMatrix **)pMatrixData)[i];
                if (!pMatrix)
                {
                    continue;
                }
            }
            else
            {
                pMatrix = ((CEffectMatrix *)pMatrixData) + i;
            }

            if (IsSetting)
            {
                SetMatrixTransposeHelper<Transpose>(pType, pEffectData + pType->Stride * (i + Offset), (float*) pMatrix);
            }
            else
            {
                GetMatrixTransposeHelper<Transpose>(pType, pEffectData + pType->Stride * (i + Offset), (float*) pMatrix);
            }
        }
    }

lExit:
    return hr;
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TMatrixVariable<IBaseInterface, IsAnnotation>::SetMatrix(CONST float *pData)
{
    LPCSTR pFuncName = "ID3DX11EffectMatrixVariable::SetMatrix";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return DoMatrixArrayInternal<FALSE, TRUE, FALSE>(pType, GetTotalUnpackedSize(), 
        Data.pNumeric, const_cast<float*>(pData), 0, 1, pFuncName);
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TMatrixVariable<IBaseInterface, IsAnnotation>::GetMatrix(float *pData)
{
    return DoMatrixArrayInternal<FALSE, FALSE, FALSE>(pType, GetTotalUnpackedSize(), 
        Data.pNumeric, pData, 0, 1, "ID3DX11EffectMatrixVariable::GetMatrix");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TMatrixVariable<IBaseInterface, IsAnnotation>::SetMatrixArray(CONST float *pData, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectMatrixVariable::SetMatrixArray";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return DoMatrixArrayInternal<FALSE, TRUE, FALSE>(pType, GetTotalUnpackedSize(), 
        Data.pNumeric, const_cast<float*>(pData), Offset, Count, "ID3DX11EffectMatrixVariable::SetMatrixArray");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TMatrixVariable<IBaseInterface, IsAnnotation>::GetMatrixArray(float *pData, UINT  Offset, UINT  Count)
{
    return DoMatrixArrayInternal<FALSE, FALSE, FALSE>(pType, GetTotalUnpackedSize(), 
        Data.pNumeric, pData, Offset, Count, "ID3DX11EffectMatrixVariable::GetMatrixArray");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TMatrixVariable<IBaseInterface, IsAnnotation>::SetMatrixPointerArray(CONST float **ppData, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectMatrixVariable::SetMatrixPointerArray";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return DoMatrixArrayInternal<FALSE, TRUE, TRUE>(pType, GetTotalUnpackedSize(), 
        Data.pNumeric, const_cast<float**>(ppData), Offset, Count, "ID3DX11EffectMatrixVariable::SetMatrixPointerArray");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TMatrixVariable<IBaseInterface, IsAnnotation>::GetMatrixPointerArray(float **ppData, UINT  Offset, UINT  Count)
{
    return DoMatrixArrayInternal<FALSE, FALSE, TRUE>(pType, GetTotalUnpackedSize(), 
        Data.pNumeric, ppData, Offset, Count, "ID3DX11EffectMatrixVariable::GetMatrixPointerArray");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TMatrixVariable<IBaseInterface, IsAnnotation>::SetMatrixTranspose(CONST float *pData)
{
    LPCSTR pFuncName = "ID3DX11EffectMatrixVariable::SetMatrixTranspose";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return DoMatrixArrayInternal<TRUE, TRUE, FALSE>(pType, GetTotalUnpackedSize(), 
        Data.pNumeric, const_cast<float*>(pData), 0, 1, "ID3DX11EffectMatrixVariable::SetMatrixTranspose");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TMatrixVariable<IBaseInterface, IsAnnotation>::GetMatrixTranspose(float *pData)
{
    return DoMatrixArrayInternal<TRUE, FALSE, FALSE>(pType, GetTotalUnpackedSize(), 
        Data.pNumeric, pData, 0, 1, "ID3DX11EffectMatrixVariable::GetMatrixTranspose");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TMatrixVariable<IBaseInterface, IsAnnotation>::SetMatrixTransposeArray(CONST float *pData, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectMatrixVariable::SetMatrixTransposeArray";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return DoMatrixArrayInternal<TRUE, TRUE, FALSE>(pType, GetTotalUnpackedSize(), 
        Data.pNumeric, const_cast<float*>(pData), Offset, Count, "ID3DX11EffectMatrixVariable::SetMatrixTransposeArray");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TMatrixVariable<IBaseInterface, IsAnnotation>::GetMatrixTransposeArray(float *pData, UINT  Offset, UINT  Count)
{
    return DoMatrixArrayInternal<TRUE, FALSE, FALSE>(pType, GetTotalUnpackedSize(), 
        Data.pNumeric, pData, Offset, Count, "ID3DX11EffectMatrixVariable::GetMatrixTransposeArray");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TMatrixVariable<IBaseInterface, IsAnnotation>::SetMatrixTransposePointerArray(CONST float **ppData, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectMatrixVariable::SetMatrixTransposePointerArray";
    if (IsAnnotation) return AnnotationInvalidSetCall(pFuncName);
    DirtyVariable();
    return DoMatrixArrayInternal<TRUE, TRUE, TRUE>(pType, GetTotalUnpackedSize(), 
        Data.pNumeric, const_cast<float**>(ppData), Offset, Count, "ID3DX11EffectMatrixVariable::SetMatrixTransposePointerArray");
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TMatrixVariable<IBaseInterface, IsAnnotation>::GetMatrixTransposePointerArray(float **ppData, UINT  Offset, UINT  Count)
{
    return DoMatrixArrayInternal<TRUE, FALSE, TRUE>(pType, GetTotalUnpackedSize(), 
        Data.pNumeric, ppData, Offset, Count, "ID3DX11EffectMatrixVariable::GetMatrixTransposePointerArray");
}

// Optimize commonly used fast paths
// (non-annotations only!)
template<typename IBaseInterface, BOOL IsColumnMajor>
struct TMatrix4x4Variable : public TMatrixVariable<IBaseInterface, FALSE>
{
    STDMETHOD(SetMatrix)(CONST float *pData);
    STDMETHOD(GetMatrix)(float *pData);

    STDMETHOD(SetMatrixArray)(CONST float *pData, UINT  Offset, UINT  Count);
    STDMETHOD(GetMatrixArray)(float *pData, UINT  Offset, UINT  Count);

    STDMETHOD(SetMatrixTranspose)(CONST float *pData);
    STDMETHOD(GetMatrixTranspose)(float *pData);

    STDMETHOD(SetMatrixTransposeArray)(CONST float *pData, UINT  Offset, UINT  Count);
    STDMETHOD(GetMatrixTransposeArray)(float *pData, UINT  Offset, UINT  Count);
};

D3DX11INLINE static void Matrix4x4TransposeHelper(CONST void *pSrc, void *pDst)
{
    BYTE *pDestData = (BYTE*)pDst;
    UINT *pMatrix = (UINT*)pSrc;

    ((UINT*)pDestData)[0 * 4 + 0] = pMatrix[0 * 4 + 0];
    ((UINT*)pDestData)[0 * 4 + 1] = pMatrix[1 * 4 + 0];
    ((UINT*)pDestData)[0 * 4 + 2] = pMatrix[2 * 4 + 0];
    ((UINT*)pDestData)[0 * 4 + 3] = pMatrix[3 * 4 + 0];

    ((UINT*)pDestData)[1 * 4 + 0] = pMatrix[0 * 4 + 1];
    ((UINT*)pDestData)[1 * 4 + 1] = pMatrix[1 * 4 + 1];
    ((UINT*)pDestData)[1 * 4 + 2] = pMatrix[2 * 4 + 1];
    ((UINT*)pDestData)[1 * 4 + 3] = pMatrix[3 * 4 + 1];

    ((UINT*)pDestData)[2 * 4 + 0] = pMatrix[0 * 4 + 2];
    ((UINT*)pDestData)[2 * 4 + 1] = pMatrix[1 * 4 + 2];
    ((UINT*)pDestData)[2 * 4 + 2] = pMatrix[2 * 4 + 2];
    ((UINT*)pDestData)[2 * 4 + 3] = pMatrix[3 * 4 + 2];

    ((UINT*)pDestData)[3 * 4 + 0] = pMatrix[0 * 4 + 3];
    ((UINT*)pDestData)[3 * 4 + 1] = pMatrix[1 * 4 + 3];
    ((UINT*)pDestData)[3 * 4 + 2] = pMatrix[2 * 4 + 3];
    ((UINT*)pDestData)[3 * 4 + 3] = pMatrix[3 * 4 + 3];
}

D3DX11INLINE static void Matrix4x4Copy(CONST void *pSrc, void *pDst)
{
#if 1
    // In tests, this path ended up generating faster code both on x86 and x64
    // T1 - Matrix4x4Copy - this path
    // T2 - Matrix4x4Transpose
    // T1: 1.88 T2: 1.92 - with 32 bit copies
    // T1: 1.85 T2: 1.80 - with 64 bit copies

    UINT64 *pDestData = (UINT64*)pDst;
    UINT64 *pMatrix = (UINT64*)pSrc;

    pDestData[0 * 4 + 0] = pMatrix[0 * 4 + 0];
    pDestData[0 * 4 + 1] = pMatrix[0 * 4 + 1];
    pDestData[0 * 4 + 2] = pMatrix[0 * 4 + 2];
    pDestData[0 * 4 + 3] = pMatrix[0 * 4 + 3];

    pDestData[1 * 4 + 0] = pMatrix[1 * 4 + 0];
    pDestData[1 * 4 + 1] = pMatrix[1 * 4 + 1];
    pDestData[1 * 4 + 2] = pMatrix[1 * 4 + 2];
    pDestData[1 * 4 + 3] = pMatrix[1 * 4 + 3];
#else
    UINT *pDestData = (UINT*)pDst;
    UINT *pMatrix = (UINT*)pSrc;

    pDestData[0 * 4 + 0] = pMatrix[0 * 4 + 0];
    pDestData[0 * 4 + 1] = pMatrix[0 * 4 + 1];
    pDestData[0 * 4 + 2] = pMatrix[0 * 4 + 2];
    pDestData[0 * 4 + 3] = pMatrix[0 * 4 + 3];

    pDestData[1 * 4 + 0] = pMatrix[1 * 4 + 0];
    pDestData[1 * 4 + 1] = pMatrix[1 * 4 + 1];
    pDestData[1 * 4 + 2] = pMatrix[1 * 4 + 2];
    pDestData[1 * 4 + 3] = pMatrix[1 * 4 + 3];

    pDestData[2 * 4 + 0] = pMatrix[2 * 4 + 0];
    pDestData[2 * 4 + 1] = pMatrix[2 * 4 + 1];
    pDestData[2 * 4 + 2] = pMatrix[2 * 4 + 2];
    pDestData[2 * 4 + 3] = pMatrix[2 * 4 + 3];

    pDestData[3 * 4 + 0] = pMatrix[3 * 4 + 0];
    pDestData[3 * 4 + 1] = pMatrix[3 * 4 + 1];
    pDestData[3 * 4 + 2] = pMatrix[3 * 4 + 2];
    pDestData[3 * 4 + 3] = pMatrix[3 * 4 + 3];
#endif
}


// Note that branches in this code is based on template parameters and will be compiled out
template<BOOL IsColumnMajor, BOOL Transpose, BOOL IsSetting>
D3DX11INLINE HRESULT DoMatrix4x4ArrayInternal(BYTE *pEffectData, void *pMatrixData, UINT  Offset, UINT  Count

#ifdef _DEBUG
                                              , SType *pType, UINT  TotalUnpackedSize, LPCSTR pFuncName)
#else
                                              )
#endif
{    
    HRESULT hr = S_OK;

#ifdef _DEBUG
    if (!AreBoundsValid(Offset, Count, pMatrixData, pType, TotalUnpackedSize))
    {
        DPF(0, "%s: Invalid range specified", pFuncName);
        VH(E_INVALIDARG);
    }

    D3DXASSERT(pType->NumericType.IsColumnMajor == IsColumnMajor && pType->Stride == (4 * SType::c_RegisterSize));
#endif

    UINT i;

    if ((IsColumnMajor && Transpose) || (!IsColumnMajor && !Transpose))
    {
        // fast path
        for (i = 0; i < Count; ++ i)
        {
            CEffectMatrix *pMatrix = ((CEffectMatrix *)pMatrixData) + i;

            if (IsSetting)
            {
                Matrix4x4Copy(pMatrix, pEffectData + 4 * SType::c_RegisterSize * (i + Offset));
            }
            else
            {
                Matrix4x4Copy(pEffectData + 4 * SType::c_RegisterSize * (i + Offset), pMatrix);
            }
        }
    }
    else
    {
        // slow path
        for (i = 0; i < Count; ++ i)
        {
            CEffectMatrix *pMatrix = ((CEffectMatrix *)pMatrixData) + i;

            if (IsSetting)
            {
                Matrix4x4TransposeHelper((float*) pMatrix, pEffectData + 4 * SType::c_RegisterSize * (i + Offset));
            }
            else
            {
                Matrix4x4TransposeHelper(pEffectData + 4 * SType::c_RegisterSize * (i + Offset), (float*) pMatrix);
            }
        }
    }

lExit:
    return hr;
}

template<typename IBaseInterface, BOOL IsColumnMajor>
HRESULT TMatrix4x4Variable<IBaseInterface, IsColumnMajor>::SetMatrix(CONST float *pData)
{
    DirtyVariable();
    return DoMatrix4x4ArrayInternal<IsColumnMajor, FALSE, TRUE>(Data.pNumeric, const_cast<float*>(pData), 0, 1
#ifdef _DEBUG 
        , pType, GetTotalUnpackedSize(), "ID3DX11EffectMatrixVariable::SetMatrix");
#else
        );
#endif
}

template<typename IBaseInterface, BOOL IsColumnMajor>
HRESULT TMatrix4x4Variable<IBaseInterface, IsColumnMajor>::GetMatrix(float *pData)
{
    return DoMatrix4x4ArrayInternal<IsColumnMajor, FALSE, FALSE>(Data.pNumeric, pData, 0, 1
#ifdef _DEBUG 
        , pType, GetTotalUnpackedSize(), "ID3DX11EffectMatrixVariable::GetMatrix");
#else
        );
#endif
}

template<typename IBaseInterface, BOOL IsColumnMajor>
HRESULT TMatrix4x4Variable<IBaseInterface, IsColumnMajor>::SetMatrixArray(CONST float *pData, UINT  Offset, UINT  Count)
{
    DirtyVariable();
    return DoMatrix4x4ArrayInternal<IsColumnMajor, FALSE, TRUE>(Data.pNumeric, const_cast<float*>(pData), Offset, Count
#ifdef _DEBUG 
        , pType, GetTotalUnpackedSize(), "ID3DX11EffectMatrixVariable::SetMatrixArray");
#else
        );
#endif
}

template<typename IBaseInterface, BOOL IsColumnMajor>
HRESULT TMatrix4x4Variable<IBaseInterface, IsColumnMajor>::GetMatrixArray(float *pData, UINT  Offset, UINT  Count)
{
    return DoMatrix4x4ArrayInternal<IsColumnMajor, FALSE, FALSE>(Data.pNumeric, pData, Offset, Count
#ifdef _DEBUG 
        , pType, GetTotalUnpackedSize(), "ID3DX11EffectMatrixVariable::GetMatrixArray");
#else
        );
#endif
}

template<typename IBaseInterface, BOOL IsColumnMajor>
HRESULT TMatrix4x4Variable<IBaseInterface, IsColumnMajor>::SetMatrixTranspose(CONST float *pData)
{
    DirtyVariable();
    return DoMatrix4x4ArrayInternal<IsColumnMajor, TRUE, TRUE>(Data.pNumeric, const_cast<float*>(pData), 0, 1
#ifdef _DEBUG 
        , pType, GetTotalUnpackedSize(), "ID3DX11EffectMatrixVariable::SetMatrixTranspose");
#else
        );
#endif
}

template<typename IBaseInterface, BOOL IsColumnMajor>
HRESULT TMatrix4x4Variable<IBaseInterface, IsColumnMajor>::GetMatrixTranspose(float *pData)
{
    return DoMatrix4x4ArrayInternal<IsColumnMajor, TRUE, FALSE>(Data.pNumeric, pData, 0, 1
#ifdef _DEBUG 
        , pType, GetTotalUnpackedSize(), "ID3DX11EffectMatrixVariable::GetMatrixTranspose");
#else
        );
#endif
}

template<typename IBaseInterface, BOOL IsColumnMajor>
HRESULT TMatrix4x4Variable<IBaseInterface, IsColumnMajor>::SetMatrixTransposeArray(CONST float *pData, UINT  Offset, UINT  Count)
{
    DirtyVariable();
    return DoMatrix4x4ArrayInternal<IsColumnMajor, TRUE, TRUE>(Data.pNumeric, const_cast<float*>(pData), Offset, Count
#ifdef _DEBUG 
        , pType, GetTotalUnpackedSize(), "ID3DX11EffectMatrixVariable::SetMatrixTransposeArray");
#else
        );
#endif
}

template<typename IBaseInterface, BOOL IsColumnMajor>
HRESULT TMatrix4x4Variable<IBaseInterface, IsColumnMajor>::GetMatrixTransposeArray(float *pData, UINT  Offset, UINT  Count)
{
    return DoMatrix4x4ArrayInternal<IsColumnMajor, TRUE, FALSE>(Data.pNumeric, pData, Offset, Count
#ifdef _DEBUG 
        , pType, GetTotalUnpackedSize(), "ID3DX11EffectMatrixVariable::GetMatrixTransposeArray");
#else
        );
#endif
}

#ifdef _DEBUG

// Useful object macro to check bounds and parameters
#define CHECK_OBJECT_ARRAY_BOUNDS(Offset, Count, Pointer) \
    HRESULT hr = S_OK; \
    VERIFYPARAMETER(Pointer) \
    UINT elements = IsArray() ? pType->Elements : 1; \
    \
    if ((Offset + Count < Offset) || (elements < Offset + Count)) \
    { \
        DPF(0, "%s: Invalid range specified", pFuncName); \
        VH(E_INVALIDARG); \
    } \

#define CHECK_OBJECT_SCALAR_BOUNDS(Index, Pointer) \
    HRESULT hr = S_OK; \
    VERIFYPARAMETER(Pointer) \
    UINT elements = IsArray() ? pType->Elements : 1; \
    \
    if (Index >= elements) \
    { \
        DPF(0, "%s: Invalid index specified", pFuncName); \
        VH(E_INVALIDARG); \
    } \

#define CHECK_SCALAR_BOUNDS(Index) \
    HRESULT hr = S_OK; \
    UINT elements = IsArray() ? pType->Elements : 1; \
    \
    if (Index >= elements) \
{ \
    DPF(0, "%s: Invalid index specified", pFuncName); \
    VH(E_INVALIDARG); \
} \

#else // _DEBUG

#define CHECK_OBJECT_ARRAY_BOUNDS(Offset, Count, Pointer) \
    HRESULT hr = S_OK; \

#define CHECK_OBJECT_SCALAR_BOUNDS(Index, Pointer) \
    HRESULT hr = S_OK; \

#define CHECK_SCALAR_BOUNDS(Index) \
    HRESULT hr = S_OK; \

#endif // _DEBUG

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectStringVariable (TStringVariable implementation)
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface, BOOL IsAnnotation>
struct TStringVariable : public IBaseInterface
{
    STDMETHOD(GetString)(LPCSTR *ppString);
    STDMETHOD(GetStringArray)( __out_ecount(Count) LPCSTR *ppStrings, UINT  Offset, UINT  Count );
};

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TStringVariable<IBaseInterface, IsAnnotation>::GetString(LPCSTR *ppString)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectStringVariable::GetString";

    VERIFYPARAMETER(ppString);

    if (GetTopLevelEntity()->pEffect->IsOptimized())
    {
        DPF(0, "%s: Effect has been Optimize()'ed; all string/reflection data has been deleted", pFuncName);
        return D3DERR_INVALIDCALL;
    }

    D3DXASSERT(NULL != Data.pString);

    *ppString = Data.pString->pString;

lExit:
    return hr;
}

template<typename IBaseInterface, BOOL IsAnnotation>
HRESULT TStringVariable<IBaseInterface, IsAnnotation>::GetStringArray( __out_ecount(Count) LPCSTR *ppStrings, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectStringVariable::GetStringArray";

    CHECK_OBJECT_ARRAY_BOUNDS(Offset, Count, ppStrings);

    if (GetTopLevelEntity()->pEffect->IsOptimized())
    {
        DPF(0, "%s: Effect has been Optimize()'ed; all string/reflection data has been deleted", pFuncName);
        return D3DERR_INVALIDCALL;
    }

    D3DXASSERT(NULL != Data.pString);

    UINT i;
    for (i = 0; i < Count; ++ i)
    {
        ppStrings[i] = (Data.pString + Offset + i)->pString;
    }

lExit:
    return hr;
}

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectClassInstanceVariable (TClassInstanceVariable implementation)
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TClassInstanceVariable : public IBaseInterface
{
    STDMETHOD(GetClassInstance)(ID3D11ClassInstance **ppClassInstance);
};

template<typename IBaseClassInstance>
HRESULT TClassInstanceVariable<IBaseClassInstance>::GetClassInstance(ID3D11ClassInstance** ppClassInstance)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectClassInstanceVariable::GetClassInstance";

    D3DXASSERT( pMemberData != NULL );
    *ppClassInstance = pMemberData->Data.pD3DClassInstance;
    SAFE_ADDREF(*ppClassInstance);

lExit:
    return hr;
}

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectInterfaceeVariable (TInterfaceVariable implementation)
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TInterfaceVariable : public IBaseInterface
{
    STDMETHOD(SetClassInstance)(ID3DX11EffectClassInstanceVariable *pEffectClassInstance);
    STDMETHOD(GetClassInstance)(ID3DX11EffectClassInstanceVariable **ppEffectClassInstance);
};

template<typename IBaseInterface>
HRESULT TInterfaceVariable<IBaseInterface>::SetClassInstance(ID3DX11EffectClassInstanceVariable *pEffectClassInstance)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectInterfaceVariable::SetClassInstance";

    // Note that we don't check if the types are compatible.  The debug layer will complain if it is.
    // IsValid() will not catch type mismatches.
    SClassInstanceGlobalVariable* pCI = (SClassInstanceGlobalVariable*)pEffectClassInstance;
    Data.pInterface->pClassInstance = pCI;

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TInterfaceVariable<IBaseInterface>::GetClassInstance(ID3DX11EffectClassInstanceVariable **ppEffectClassInstance)
{
    HRESULT hr = S_OK;
    LPCSTR pFuncName = "ID3DX11EffectInterfaceVariable::GetClassInstance";

#ifdef _DEBUG
    VERIFYPARAMETER(ppEffectClassInstance);
#endif

    *ppEffectClassInstance = Data.pInterface->pClassInstance;

lExit:
    return hr;
}

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectShaderResourceVariable (TShaderResourceVariable implementation)
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TShaderResourceVariable : public IBaseInterface
{
    STDMETHOD(SetResource)(ID3D11ShaderResourceView *pResource);
    STDMETHOD(GetResource)(ID3D11ShaderResourceView **ppResource);

    STDMETHOD(SetResourceArray)(ID3D11ShaderResourceView **ppResources, UINT  Offset, UINT  Count);
    STDMETHOD(GetResourceArray)(ID3D11ShaderResourceView **ppResources, UINT  Offset, UINT  Count);
};

static LPCSTR GetTextureTypeNameFromEnum(EObjectType ObjectType)
{
    switch (ObjectType)
    {
    case EOT_Buffer:
        return "Buffer";
    case EOT_Texture:
        return "texture";
    case EOT_Texture1D:
    case EOT_Texture1DArray:
        return "Texture1D";
    case EOT_Texture2DMS:
    case EOT_Texture2DMSArray:
        return "Texture2DMS";
    case EOT_Texture2D:
    case EOT_Texture2DArray:
        return "Texture2D";
    case EOT_Texture3D:
        return "Texture3D";
    case EOT_TextureCube:
        return "TextureCube";
    case EOT_TextureCubeArray:
        return "TextureCubeArray";
    case EOT_RWTexture1D:
    case EOT_RWTexture1DArray:
        return "RWTexture1D";
    case EOT_RWTexture2D:
    case EOT_RWTexture2DArray:
        return "RWTexture2D";
    case EOT_RWTexture3D:
        return "RWTexture3D";
    case EOT_RWBuffer:
        return "RWBuffer";
    case EOT_ByteAddressBuffer:
        return "ByteAddressBuffer";
    case EOT_RWByteAddressBuffer:
        return "RWByteAddressBuffer";
    case EOT_StructuredBuffer:
        return "StructuredBuffe";
    case EOT_RWStructuredBuffer:
        return "RWStructuredBuffer";
    case EOT_RWStructuredBufferAlloc:
        return "RWStructuredBufferAlloc";
    case EOT_RWStructuredBufferConsume:
        return "RWStructuredBufferConsume";
    case EOT_AppendStructuredBuffer:
        return "AppendStructuredBuffer";
    case EOT_ConsumeStructuredBuffer:
        return "ConsumeStructuredBuffer";
    }
    return "<unknown texture format>";
}

static LPCSTR GetResourceDimensionNameFromEnum(D3D11_RESOURCE_DIMENSION ResourceDimension)
{
    switch (ResourceDimension)
    {
    case D3D11_RESOURCE_DIMENSION_BUFFER:
        return "Buffer";
    case D3D11_RESOURCE_DIMENSION_TEXTURE1D:
        return "Texture1D";
    case D3D11_RESOURCE_DIMENSION_TEXTURE2D:
        return "Texture2D";
    case D3D11_RESOURCE_DIMENSION_TEXTURE3D:
        return "Texture3D";
    }
    return "<unknown texture format>";
}

static LPCSTR GetSRVDimensionNameFromEnum(D3D11_SRV_DIMENSION ViewDimension)
{
    switch (ViewDimension)
    {
    case D3D11_SRV_DIMENSION_BUFFER:
    case D3D11_SRV_DIMENSION_BUFFEREX:
        return "Buffer";
    case D3D11_SRV_DIMENSION_TEXTURE1D:
        return "Texture1D";
    case D3D11_SRV_DIMENSION_TEXTURE1DARRAY:
        return "Texture1DArray";
    case D3D11_SRV_DIMENSION_TEXTURE2D:
        return "Texture2D";
    case D3D11_SRV_DIMENSION_TEXTURE2DARRAY:
        return "Texture2DArray";
    case D3D11_SRV_DIMENSION_TEXTURE2DMS:
        return "Texture2DMS";
    case D3D11_SRV_DIMENSION_TEXTURE2DMSARRAY:
        return "Texture2DMSArray";
    case D3D11_SRV_DIMENSION_TEXTURE3D:
        return "Texture3D";
    case D3D11_SRV_DIMENSION_TEXTURECUBE:
        return "TextureCube";
    }
    return "<unknown texture format>";
}

static LPCSTR GetUAVDimensionNameFromEnum(D3D11_UAV_DIMENSION ViewDimension)
{
    switch (ViewDimension)
    {
    case D3D11_UAV_DIMENSION_BUFFER:
        return "Buffer";
    case D3D11_UAV_DIMENSION_TEXTURE1D:
        return "RWTexture1D";
    case D3D11_UAV_DIMENSION_TEXTURE1DARRAY:
        return "RWTexture1DArray";
    case D3D11_UAV_DIMENSION_TEXTURE2D:
        return "RWTexture2D";
    case D3D11_UAV_DIMENSION_TEXTURE2DARRAY:
        return "RWTexture2DArray";
    case D3D11_UAV_DIMENSION_TEXTURE3D:
        return "RWTexture3D";
    }
    return "<unknown texture format>";
}

static LPCSTR GetRTVDimensionNameFromEnum(D3D11_RTV_DIMENSION ViewDimension)
{
    switch (ViewDimension)
    {
    case D3D11_RTV_DIMENSION_BUFFER:
        return "Buffer";
    case D3D11_RTV_DIMENSION_TEXTURE1D:
        return "Texture1D";
    case D3D11_RTV_DIMENSION_TEXTURE1DARRAY:
        return "Texture1DArray";
    case D3D11_RTV_DIMENSION_TEXTURE2D:
        return "Texture2D";
    case D3D11_RTV_DIMENSION_TEXTURE2DARRAY:
        return "Texture2DArray";
    case D3D11_RTV_DIMENSION_TEXTURE2DMS:
        return "Texture2DMS";
    case D3D11_RTV_DIMENSION_TEXTURE2DMSARRAY:
        return "Texture2DMSArray";
    case D3D11_RTV_DIMENSION_TEXTURE3D:
        return "Texture3D";
    }
    return "<unknown texture format>";
}

static LPCSTR GetDSVDimensionNameFromEnum(D3D11_DSV_DIMENSION ViewDimension)
{
    switch (ViewDimension)
    {
    case D3D11_DSV_DIMENSION_TEXTURE1D:
        return "Texture1D";
    case D3D11_DSV_DIMENSION_TEXTURE1DARRAY:
        return "Texture1DArray";
    case D3D11_DSV_DIMENSION_TEXTURE2D:
        return "Texture2D";
    case D3D11_DSV_DIMENSION_TEXTURE2DARRAY:
        return "Texture2DArray";
    case D3D11_DSV_DIMENSION_TEXTURE2DMS:
        return "Texture2DMS";
    case D3D11_DSV_DIMENSION_TEXTURE2DMSARRAY:
        return "Texture2DMSArray";
    }
    return "<unknown texture format>";
}

static HRESULT ValidateTextureType(ID3D11ShaderResourceView *pView, EObjectType ObjectType, LPCSTR pFuncName)
{
    if (NULL != pView)
    {
        D3D11_SHADER_RESOURCE_VIEW_DESC desc;
        pView->GetDesc(&desc);
        switch (ObjectType)
        {
        case EOT_Texture:
            if (desc.ViewDimension != D3D11_SRV_DIMENSION_BUFFER && desc.ViewDimension != D3D11_SRV_DIMENSION_BUFFEREX)
                return S_OK;
            break;
        case EOT_Buffer:
            if (desc.ViewDimension != D3D11_SRV_DIMENSION_BUFFER && desc.ViewDimension != D3D11_SRV_DIMENSION_BUFFEREX)
                break;
            if (desc.ViewDimension == D3D11_SRV_DIMENSION_BUFFEREX && (desc.BufferEx.Flags & D3D11_BUFFEREX_SRV_FLAG_RAW))
            {
                DPF(0, "%s: Resource type mismatch; %s expected, ByteAddressBuffer provided.", pFuncName, GetTextureTypeNameFromEnum(ObjectType));
                return E_INVALIDARG;
            }
            else
            {
                ID3D11Buffer* pBuffer = NULL;
                pView->GetResource( (ID3D11Resource**)&pBuffer );
                D3DXASSERT( pBuffer != NULL );
                D3D11_BUFFER_DESC BufDesc;
                pBuffer->GetDesc( &BufDesc );
                SAFE_RELEASE( pBuffer );
                if( BufDesc.MiscFlags & D3D11_RESOURCE_MISC_BUFFER_STRUCTURED )
                {
                    DPF(0, "%s: Resource type mismatch; %s expected, StructuredBuffer provided.", pFuncName, GetTextureTypeNameFromEnum(ObjectType));
                    return E_INVALIDARG;
                }
                else
                {
                    return S_OK;
                }
            }
            break;
        case EOT_Texture1D:
        case EOT_Texture1DArray:
            if (desc.ViewDimension == D3D11_SRV_DIMENSION_TEXTURE1D || 
                desc.ViewDimension == D3D11_SRV_DIMENSION_TEXTURE1DARRAY)
                return S_OK;
            break;
        case EOT_Texture2D:
        case EOT_Texture2DArray:
            if (desc.ViewDimension == D3D11_SRV_DIMENSION_TEXTURE2D ||
                desc.ViewDimension == D3D11_SRV_DIMENSION_TEXTURE2DARRAY)
                return S_OK;
            break;
        case EOT_Texture2DMS:
        case EOT_Texture2DMSArray:
            if (desc.ViewDimension == D3D11_SRV_DIMENSION_TEXTURE2DMS ||
                desc.ViewDimension == D3D11_SRV_DIMENSION_TEXTURE2DMSARRAY)
                return S_OK;
            break;
        case EOT_Texture3D:
            if (desc.ViewDimension == D3D11_SRV_DIMENSION_TEXTURE3D)
                return S_OK;
            break;
        case EOT_TextureCube:
        case EOT_TextureCubeArray:
            if (desc.ViewDimension == D3D11_SRV_DIMENSION_TEXTURECUBE ||
                desc.ViewDimension == D3D11_SRV_DIMENSION_TEXTURECUBEARRAY)
                return S_OK;
            break;
        case EOT_ByteAddressBuffer:
            if (desc.ViewDimension == D3D11_SRV_DIMENSION_BUFFEREX && (desc.BufferEx.Flags & D3D11_BUFFEREX_SRV_FLAG_RAW))
                return S_OK;
            break;
        case EOT_StructuredBuffer:
            if (desc.ViewDimension == D3D11_SRV_DIMENSION_BUFFEREX || desc.ViewDimension == D3D11_SRV_DIMENSION_BUFFER)
            {
                ID3D11Buffer* pBuffer = NULL;
                pView->GetResource( (ID3D11Resource**)&pBuffer );
                D3DXASSERT( pBuffer != NULL );
                D3D11_BUFFER_DESC BufDesc;
                pBuffer->GetDesc( &BufDesc );
                SAFE_RELEASE( pBuffer );
                if( BufDesc.MiscFlags & D3D11_RESOURCE_MISC_BUFFER_STRUCTURED )
                {
                    return S_OK;
                }
                else
                {
                    DPF(0, "%s: Resource type mismatch; %s expected, non-structured Buffer provided.", pFuncName, GetTextureTypeNameFromEnum(ObjectType));
                    return E_INVALIDARG;
                }
            }
            break;
        default:
            D3DXASSERT(0); // internal error, should never get here
            return E_FAIL;
        }
        

        DPF(0, "%s: Resource type mismatch; %s expected, %s provided.", pFuncName, GetTextureTypeNameFromEnum(ObjectType), GetSRVDimensionNameFromEnum(desc.ViewDimension));
        return E_INVALIDARG;
    }
    return S_OK;
}

template<typename IBaseInterface>
HRESULT TShaderResourceVariable<IBaseInterface>::SetResource(ID3D11ShaderResourceView *pResource)
{
    HRESULT hr = S_OK;

#ifdef _DEBUG
    LPCSTR pFuncName = "ID3DX11EffectShaderResourceVariable::SetResource";

    VH(ValidateTextureType(pResource, pType->ObjectType, pFuncName));
#endif

    // Texture variables don't need to be dirtied.
    SAFE_ADDREF(pResource);
    SAFE_RELEASE(Data.pShaderResource->pShaderResource);
    Data.pShaderResource->pShaderResource = pResource;

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TShaderResourceVariable<IBaseInterface>::GetResource(ID3D11ShaderResourceView **ppResource)
{
    HRESULT hr = S_OK;

#ifdef _DEBUG
    LPCSTR pFuncName = "ID3DX11EffectShaderResourceVariable::GetResource";

    VERIFYPARAMETER(ppResource);
#endif

    *ppResource = Data.pShaderResource->pShaderResource;
    SAFE_ADDREF(*ppResource);

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TShaderResourceVariable<IBaseInterface>::SetResourceArray(ID3D11ShaderResourceView **ppResources, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderResourceVariable::SetResourceArray";
    UINT i;

    CHECK_OBJECT_ARRAY_BOUNDS(Offset, Count, ppResources);

#ifdef _DEBUG
    for (i = 0; i < Count; ++ i)
    {
        VH(ValidateTextureType(ppResources[i], pType->ObjectType, pFuncName));
    }
#endif

    // Texture variables don't need to be dirtied.
    for (i = 0; i < Count; ++ i)
    {
        SShaderResource *pResourceBlock = Data.pShaderResource + Offset + i;
        SAFE_ADDREF(ppResources[i]);
        SAFE_RELEASE(pResourceBlock->pShaderResource);
        pResourceBlock->pShaderResource = ppResources[i];
    }

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TShaderResourceVariable<IBaseInterface>::GetResourceArray(ID3D11ShaderResourceView **ppResources, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderResourceVariable::GetResourceArray";

    CHECK_OBJECT_ARRAY_BOUNDS(Offset, Count, ppResources);

    UINT i;
    for (i = 0; i < Count; ++ i)
    {
        ppResources[i] = (Data.pShaderResource + Offset + i)->pShaderResource;
        SAFE_ADDREF(ppResources[i]);
    }

lExit:
    return hr;
}

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectUnorderedAccessViewVariable (TUnorderedAccessViewVariable implementation)
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TUnorderedAccessViewVariable : public IBaseInterface
{
    STDMETHOD(SetUnorderedAccessView)(ID3D11UnorderedAccessView *pResource);
    STDMETHOD(GetUnorderedAccessView)(ID3D11UnorderedAccessView **ppResource);

    STDMETHOD(SetUnorderedAccessViewArray)(ID3D11UnorderedAccessView **ppResources, UINT  Offset, UINT  Count);
    STDMETHOD(GetUnorderedAccessViewArray)(ID3D11UnorderedAccessView **ppResources, UINT  Offset, UINT  Count);
};

static HRESULT ValidateTextureType(ID3D11UnorderedAccessView *pView, EObjectType ObjectType, LPCSTR pFuncName)
{
    if (NULL != pView)
    {
        D3D11_UNORDERED_ACCESS_VIEW_DESC desc;
        pView->GetDesc(&desc);
        switch (ObjectType)
        {
        case EOT_RWBuffer:
            if (desc.ViewDimension != D3D11_UAV_DIMENSION_BUFFER)
                break;
            if (desc.Buffer.Flags & D3D11_BUFFER_UAV_FLAG_RAW)
            {
                DPF(0, "%s: Resource type mismatch; %s expected, RWByteAddressBuffer provided.", pFuncName, GetTextureTypeNameFromEnum(ObjectType));
                return E_INVALIDARG;
            }
            else
            {
                ID3D11Buffer* pBuffer = NULL;
                pView->GetResource( (ID3D11Resource**)&pBuffer );
                D3DXASSERT( pBuffer != NULL );
                D3D11_BUFFER_DESC BufDesc;
                pBuffer->GetDesc( &BufDesc );
                SAFE_RELEASE( pBuffer );
                if( BufDesc.MiscFlags & D3D11_RESOURCE_MISC_BUFFER_STRUCTURED )
                {
                    DPF(0, "%s: Resource type mismatch; %s expected, an RWStructuredBuffer provided.", pFuncName, GetTextureTypeNameFromEnum(ObjectType));
                    return E_INVALIDARG;
                }
                else
                {
                    return S_OK;
                }
            }
            break;
        case EOT_RWTexture1D:
        case EOT_RWTexture1DArray:
            if (desc.ViewDimension == D3D11_UAV_DIMENSION_TEXTURE1D || 
                desc.ViewDimension == D3D11_UAV_DIMENSION_TEXTURE1DARRAY)
                return S_OK;
            break;
        case EOT_RWTexture2D:
        case EOT_RWTexture2DArray:
            if (desc.ViewDimension == D3D11_UAV_DIMENSION_TEXTURE2D ||
                desc.ViewDimension == D3D11_UAV_DIMENSION_TEXTURE2DARRAY)
                return S_OK;
            break;
        case EOT_RWTexture3D:
            if (desc.ViewDimension == D3D11_UAV_DIMENSION_TEXTURE3D)
                return S_OK;
            break;
        case EOT_RWByteAddressBuffer:
            if (desc.ViewDimension == D3D11_UAV_DIMENSION_BUFFER && (desc.Buffer.Flags & D3D11_BUFFER_UAV_FLAG_RAW))
                return S_OK;
            break;
        case EOT_RWStructuredBuffer:
            if (desc.ViewDimension == D3D11_UAV_DIMENSION_BUFFER)
            {
                ID3D11Buffer* pBuffer = NULL;
                pView->GetResource( (ID3D11Resource**)&pBuffer );
                D3DXASSERT( pBuffer != NULL );
                D3D11_BUFFER_DESC BufDesc;
                pBuffer->GetDesc( &BufDesc );
                SAFE_RELEASE( pBuffer );
                if( BufDesc.MiscFlags & D3D11_RESOURCE_MISC_BUFFER_STRUCTURED )
                {
                    return S_OK;
                }
                else
                {
                    DPF(0, "%s: Resource type mismatch; %s expected, non-structured Buffer provided.", pFuncName, GetTextureTypeNameFromEnum(ObjectType));
                    return E_INVALIDARG;
                }
            }
            break;
        case EOT_RWStructuredBufferAlloc:
        case EOT_RWStructuredBufferConsume:
            if (desc.ViewDimension != D3D11_UAV_DIMENSION_BUFFER)
                break;
            if (desc.Buffer.Flags & D3D11_BUFFER_UAV_FLAG_COUNTER)
            {
                return S_OK;
            }
            else
            {
                DPF(0, "%s: Resource type mismatch; %s expected, non-Counter buffer provided.", pFuncName, GetTextureTypeNameFromEnum(ObjectType));
                return E_INVALIDARG;
            }
            break;
        case EOT_AppendStructuredBuffer:
        case EOT_ConsumeStructuredBuffer:
            if (desc.ViewDimension != D3D11_UAV_DIMENSION_BUFFER)
                break;
            if (desc.Buffer.Flags & D3D11_BUFFER_UAV_FLAG_APPEND)
            {
                return S_OK;
            }
            else
            {
                DPF(0, "%s: Resource type mismatch; %s expected, non-Append buffer provided.", pFuncName, GetTextureTypeNameFromEnum(ObjectType));
                return E_INVALIDARG;
            }
            break;
        default:
            D3DXASSERT(0); // internal error, should never get here
            return E_FAIL;
        }


        DPF(0, "%s: Resource type mismatch; %s expected, %s provided.", pFuncName, GetTextureTypeNameFromEnum(ObjectType), GetUAVDimensionNameFromEnum(desc.ViewDimension));
        return E_INVALIDARG;
    }
    return S_OK;
}

template<typename IBaseInterface>
HRESULT TUnorderedAccessViewVariable<IBaseInterface>::SetUnorderedAccessView(ID3D11UnorderedAccessView *pResource)
{
    HRESULT hr = S_OK;

#ifdef _DEBUG
    LPCSTR pFuncName = "ID3DX11EffectUnorderedAccessViewVariable::SetUnorderedAccessView";

    VH(ValidateTextureType(pResource, pType->ObjectType, pFuncName));
#endif

    // UAV variables don't need to be dirtied.
    SAFE_ADDREF(pResource);
    SAFE_RELEASE(Data.pUnorderedAccessView->pUnorderedAccessView);
    Data.pUnorderedAccessView->pUnorderedAccessView = pResource;

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TUnorderedAccessViewVariable<IBaseInterface>::GetUnorderedAccessView(ID3D11UnorderedAccessView **ppResource)
{
    HRESULT hr = S_OK;

#ifdef _DEBUG
    LPCSTR pFuncName = "ID3DX11EffectUnorderedAccessViewVariable::GetUnorderedAccessView";

    VERIFYPARAMETER(ppResource);
#endif

    *ppResource = Data.pUnorderedAccessView->pUnorderedAccessView;
    SAFE_ADDREF(*ppResource);

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TUnorderedAccessViewVariable<IBaseInterface>::SetUnorderedAccessViewArray(ID3D11UnorderedAccessView **ppResources, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectUnorderedAccessViewVariable::SetUnorderedAccessViewArray";
    UINT i;

    CHECK_OBJECT_ARRAY_BOUNDS(Offset, Count, ppResources);

#ifdef _DEBUG
    for (i = 0; i < Count; ++ i)
    {
        VH(ValidateTextureType(ppResources[i], pType->ObjectType, pFuncName));
    }
#endif

    // Texture variables don't need to be dirtied.
    for (i = 0; i < Count; ++ i)
    {
        SUnorderedAccessView *pResourceBlock = Data.pUnorderedAccessView + Offset + i;
        SAFE_ADDREF(ppResources[i]);
        SAFE_RELEASE(pResourceBlock->pUnorderedAccessView);
        pResourceBlock->pUnorderedAccessView = ppResources[i];
    }

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TUnorderedAccessViewVariable<IBaseInterface>::GetUnorderedAccessViewArray(ID3D11UnorderedAccessView **ppResources, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectUnorderedAccessViewVariable::GetUnorderedAccessViewArray";

    CHECK_OBJECT_ARRAY_BOUNDS(Offset, Count, ppResources);

    UINT i;
    for (i = 0; i < Count; ++ i)
    {
        ppResources[i] = (Data.pUnorderedAccessView + Offset + i)->pUnorderedAccessView;
        SAFE_ADDREF(ppResources[i]);
    }

lExit:
    return hr;
}

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectRenderTargetViewVariable (TRenderTargetViewVariable implementation)
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TRenderTargetViewVariable : public IBaseInterface
{
    STDMETHOD(SetRenderTarget)(ID3D11RenderTargetView *pResource);
    STDMETHOD(GetRenderTarget)(ID3D11RenderTargetView **ppResource);

    STDMETHOD(SetRenderTargetArray)(ID3D11RenderTargetView **ppResources, UINT  Offset, UINT  Count);
    STDMETHOD(GetRenderTargetArray)(ID3D11RenderTargetView **ppResources, UINT  Offset, UINT  Count);
};


template<typename IBaseInterface>
HRESULT TRenderTargetViewVariable<IBaseInterface>::SetRenderTarget(ID3D11RenderTargetView *pResource)
{
    HRESULT hr = S_OK;

#ifdef _DEBUG
    LPCSTR pFuncName = "ID3DX11EffectRenderTargetVariable::SetRenderTarget";

#endif

    // Texture variables don't need to be dirtied.
    SAFE_ADDREF(pResource);
    SAFE_RELEASE(Data.pRenderTargetView->pRenderTargetView);
    Data.pRenderTargetView->pRenderTargetView = pResource;

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TRenderTargetViewVariable<IBaseInterface>::GetRenderTarget(ID3D11RenderTargetView **ppResource)
{
    HRESULT hr = S_OK;

    *ppResource = Data.pRenderTargetView->pRenderTargetView;
    SAFE_ADDREF(*ppResource);

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TRenderTargetViewVariable<IBaseInterface>::SetRenderTargetArray(ID3D11RenderTargetView **ppResources, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectRenderTargetVariable::SetRenderTargetArray";
    UINT i;

    CHECK_OBJECT_ARRAY_BOUNDS(Offset, Count, ppResources);

    // Texture variables don't need to be dirtied.
    for (i = 0; i < Count; ++ i)
    {
        SRenderTargetView *pResourceBlock = Data.pRenderTargetView + Offset + i;
        SAFE_ADDREF(ppResources[i]);
        SAFE_RELEASE(pResourceBlock->pRenderTargetView);
        pResourceBlock->pRenderTargetView = ppResources[i];
    }

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TRenderTargetViewVariable<IBaseInterface>::GetRenderTargetArray(ID3D11RenderTargetView **ppResources, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3DX11EffectRenderTargetVariable::GetRenderTargetArray";

    CHECK_OBJECT_ARRAY_BOUNDS(Offset, Count, ppResources);

    UINT i;
    for (i = 0; i < Count; ++ i)
    {
        ppResources[i] = (Data.pRenderTargetView + Offset + i)->pRenderTargetView;
        SAFE_ADDREF(ppResources[i]);
    }

lExit:
    return hr;
}

//////////////////////////////////////////////////////////////////////////
// ID3DX11EffectDepthStencilViewVariable (TDepthStencilViewVariable implementation)
//////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TDepthStencilViewVariable : public IBaseInterface
{
    STDMETHOD(SetDepthStencil)(ID3D11DepthStencilView *pResource);
    STDMETHOD(GetDepthStencil)(ID3D11DepthStencilView **ppResource);

    STDMETHOD(SetDepthStencilArray)(ID3D11DepthStencilView **ppResources, UINT  Offset, UINT  Count);
    STDMETHOD(GetDepthStencilArray)(ID3D11DepthStencilView **ppResources, UINT  Offset, UINT  Count);
};


template<typename IBaseInterface>
HRESULT TDepthStencilViewVariable<IBaseInterface>::SetDepthStencil(ID3D11DepthStencilView *pResource)
{
    HRESULT hr = S_OK;

#ifdef _DEBUG
    LPCSTR pFuncName = "ID3D11DepthStencilViewVariable::SetDepthStencil";

#endif

    // Texture variables don't need to be dirtied.
    SAFE_ADDREF(pResource);
    SAFE_RELEASE(Data.pDepthStencilView->pDepthStencilView);
    Data.pDepthStencilView->pDepthStencilView = pResource;

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TDepthStencilViewVariable<IBaseInterface>::GetDepthStencil(ID3D11DepthStencilView **ppResource)
{
    HRESULT hr = S_OK;

#ifdef _DEBUG
    LPCSTR pFuncName = "ID3D11DepthStencilViewVariable::GetDepthStencil";

    VERIFYPARAMETER(ppResource);
#endif

    *ppResource = Data.pDepthStencilView->pDepthStencilView;
    SAFE_ADDREF(*ppResource);

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TDepthStencilViewVariable<IBaseInterface>::SetDepthStencilArray(ID3D11DepthStencilView **ppResources, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3D11DepthStencilViewVariable::SetDepthStencilArray";
    UINT i;

    CHECK_OBJECT_ARRAY_BOUNDS(Offset, Count, ppResources);

    // Texture variables don't need to be dirtied.
    for (i = 0; i < Count; ++ i)
    {
        SDepthStencilView *pResourceBlock = Data.pDepthStencilView + Offset + i;
        SAFE_ADDREF(ppResources[i]);
        SAFE_RELEASE(pResourceBlock->pDepthStencilView);
        pResourceBlock->pDepthStencilView = ppResources[i];
    }

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TDepthStencilViewVariable<IBaseInterface>::GetDepthStencilArray(ID3D11DepthStencilView **ppResources, UINT  Offset, UINT  Count)
{
    LPCSTR pFuncName = "ID3D11DepthStencilViewVariable::GetDepthStencilArray";

    CHECK_OBJECT_ARRAY_BOUNDS(Offset, Count, ppResources);

    UINT i;
    for (i = 0; i < Count; ++ i)
    {
        ppResources[i] = (Data.pDepthStencilView + Offset + i)->pDepthStencilView;
        SAFE_ADDREF(ppResources[i]);
    }

lExit:
    return hr;
}



////////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectShaderVariable (TShaderVariable implementation)
////////////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TShaderVariable : public IBaseInterface
{
    STDMETHOD(GetShaderDesc)(UINT ShaderIndex, D3DX11_EFFECT_SHADER_DESC *pDesc);

    STDMETHOD(GetVertexShader)(UINT ShaderIndex, ID3D11VertexShader **ppVS);
    STDMETHOD(GetGeometryShader)(UINT ShaderIndex, ID3D11GeometryShader **ppGS);
    STDMETHOD(GetPixelShader)(UINT ShaderIndex, ID3D11PixelShader **ppPS);
    STDMETHOD(GetHullShader)(UINT ShaderIndex, ID3D11HullShader **ppPS);
    STDMETHOD(GetDomainShader)(UINT ShaderIndex, ID3D11DomainShader **ppPS);
    STDMETHOD(GetComputeShader)(UINT ShaderIndex, ID3D11ComputeShader **ppPS);

    STDMETHOD(GetInputSignatureElementDesc)(UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc);
    STDMETHOD(GetOutputSignatureElementDesc)(UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc);
    STDMETHOD(GetPatchConstantSignatureElementDesc)(UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc);

    STDMETHOD_(BOOL, IsValid)();
};

template<typename IBaseInterface>
HRESULT TShaderVariable<IBaseInterface>::GetShaderDesc(UINT ShaderIndex, D3DX11_EFFECT_SHADER_DESC *pDesc)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetShaderDesc";

    CHECK_OBJECT_SCALAR_BOUNDS(ShaderIndex, pDesc);

    Data.pShader[ShaderIndex].GetShaderDesc(pDesc, FALSE);

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TShaderVariable<IBaseInterface>::GetVertexShader(UINT ShaderIndex, ID3D11VertexShader **ppVS)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetVertexShader";

    CHECK_OBJECT_SCALAR_BOUNDS(ShaderIndex, ppVS);

    VH( Data.pShader[ShaderIndex].GetVertexShader(ppVS) );

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TShaderVariable<IBaseInterface>::GetGeometryShader(UINT ShaderIndex, ID3D11GeometryShader **ppGS)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetGeometryShader";

    CHECK_OBJECT_SCALAR_BOUNDS(ShaderIndex, ppGS);

    VH( Data.pShader[ShaderIndex].GetGeometryShader(ppGS) );

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TShaderVariable<IBaseInterface>::GetPixelShader(UINT ShaderIndex, ID3D11PixelShader **ppPS)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetPixelShader";

    CHECK_OBJECT_SCALAR_BOUNDS(ShaderIndex, ppPS);

    VH( Data.pShader[ShaderIndex].GetPixelShader(ppPS) );

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TShaderVariable<IBaseInterface>::GetHullShader(UINT ShaderIndex, ID3D11HullShader **ppHS)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetHullShader";

    CHECK_OBJECT_SCALAR_BOUNDS(ShaderIndex, ppHS);

    VH( Data.pShader[ShaderIndex].GetHullShader(ppHS) );

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TShaderVariable<IBaseInterface>::GetDomainShader(UINT ShaderIndex, ID3D11DomainShader **ppDS)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetDomainShader";

    CHECK_OBJECT_SCALAR_BOUNDS(ShaderIndex, ppDS);

    VH( Data.pShader[ShaderIndex].GetDomainShader(ppDS) );

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TShaderVariable<IBaseInterface>::GetComputeShader(UINT ShaderIndex, ID3D11ComputeShader **ppCS)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetComputeShader";

    CHECK_OBJECT_SCALAR_BOUNDS(ShaderIndex, ppCS);

    VH( Data.pShader[ShaderIndex].GetComputeShader(ppCS) );

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TShaderVariable<IBaseInterface>::GetInputSignatureElementDesc(UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetInputSignatureElementDesc";

    CHECK_OBJECT_SCALAR_BOUNDS(ShaderIndex, pDesc);

    VH( Data.pShader[ShaderIndex].GetSignatureElementDesc(SShaderBlock::ST_Input, Element, pDesc) );

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TShaderVariable<IBaseInterface>::GetOutputSignatureElementDesc(UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetOutputSignatureElementDesc";

    CHECK_OBJECT_SCALAR_BOUNDS(ShaderIndex, pDesc);

    VH( Data.pShader[ShaderIndex].GetSignatureElementDesc(SShaderBlock::ST_Output, Element, pDesc) );

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TShaderVariable<IBaseInterface>::GetPatchConstantSignatureElementDesc(UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc)
{
    LPCSTR pFuncName = "ID3DX11EffectShaderVariable::GetPatchConstantSignatureElementDesc";

    CHECK_OBJECT_SCALAR_BOUNDS(ShaderIndex, pDesc);

    VH( Data.pShader[ShaderIndex].GetSignatureElementDesc(SShaderBlock::ST_PatchConstant, Element, pDesc) );

lExit:
    return hr;
}

template<typename IBaseInterface>
BOOL TShaderVariable<IBaseInterface>::IsValid()
{
    UINT numElements = IsArray()? pType->Elements : 1;
    BOOL valid = TRUE;
    while( numElements > 0 && ( valid = Data.pShader[ numElements-1 ].IsValid ) )
        numElements--;
    return valid;
}

////////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectBlendVariable (TBlendVariable implementation)
////////////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TBlendVariable : public IBaseInterface
{
public:
    STDMETHOD(GetBlendState)(UINT Index, ID3D11BlendState **ppBlendState);
    STDMETHOD(SetBlendState)(UINT Index, ID3D11BlendState *pBlendState);
    STDMETHOD(UndoSetBlendState)(UINT Index);
    STDMETHOD(GetBackingStore)(UINT Index, D3D11_BLEND_DESC *pBlendDesc);
    STDMETHOD_(BOOL, IsValid)();
};

template<typename IBaseInterface>
HRESULT TBlendVariable<IBaseInterface>::GetBlendState(UINT Index, ID3D11BlendState **ppBlendState)
{
    LPCSTR pFuncName = "ID3DX11EffectBlendVariable::GetBlendState";

    CHECK_OBJECT_SCALAR_BOUNDS(Index, ppBlendState);

    *ppBlendState = Data.pBlend[Index].pBlendObject;
    SAFE_ADDREF(*ppBlendState);

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TBlendVariable<IBaseInterface>::SetBlendState(UINT Index, ID3D11BlendState *pBlendState)
{
    LPCSTR pFuncName = "ID3DX11EffectBlendState::SetBlendState";

    CHECK_SCALAR_BOUNDS(Index);

    if( !Data.pBlend[Index].IsUserManaged )
    {
        // Save original state object in case we UndoSet
        D3DXASSERT( pMemberData[Index].Type == MDT_BlendState );
        VB( pMemberData[Index].Data.pD3DEffectsManagedBlendState == NULL );
        pMemberData[Index].Data.pD3DEffectsManagedBlendState = Data.pBlend[Index].pBlendObject;
        Data.pBlend[Index].pBlendObject = NULL;
        Data.pBlend[Index].IsUserManaged = TRUE;
    }

    SAFE_ADDREF( pBlendState );
    SAFE_RELEASE( Data.pBlend[Index].pBlendObject );
    Data.pBlend[Index].pBlendObject = pBlendState;
    Data.pBlend[Index].IsValid = TRUE;
lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TBlendVariable<IBaseInterface>::UndoSetBlendState(UINT Index)
{
    LPCSTR pFuncName = "ID3DX11EffectBlendState::UndoSetBlendState";

    CHECK_SCALAR_BOUNDS(Index);

    if( !Data.pBlend[Index].IsUserManaged )
    {
        return S_FALSE;
    }

    // Revert to original state object
    SAFE_RELEASE( Data.pBlend[Index].pBlendObject );
    Data.pBlend[Index].pBlendObject = pMemberData[Index].Data.pD3DEffectsManagedBlendState;
    pMemberData[Index].Data.pD3DEffectsManagedBlendState = NULL;
    Data.pBlend[Index].IsUserManaged = FALSE;

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TBlendVariable<IBaseInterface>::GetBackingStore(UINT Index, D3D11_BLEND_DESC *pBlendDesc)
{
    LPCSTR pFuncName = "ID3DX11EffectBlendVariable::GetBackingStore";

    CHECK_OBJECT_SCALAR_BOUNDS(Index, pBlendDesc);

    if( Data.pBlend[Index].IsUserManaged )
    {
        if( Data.pBlend[Index].pBlendObject )
        {
            Data.pBlend[Index].pBlendObject->GetDesc( pBlendDesc );
        }
        else
        {
            *pBlendDesc = CD3D11_BLEND_DESC( D3D11_DEFAULT );
        }
    }
    else
    {
        SBlendBlock *pBlock = Data.pBlend + Index;
        if (pBlock->ApplyAssignments(GetTopLevelEntity()->pEffect))
        {
            pBlock->pAssignments[0].LastRecomputedTime = 0; // Force a recreate of this block the next time ApplyRenderStateBlock is called
        }

        memcpy( pBlendDesc, &pBlock->BackingStore, sizeof(D3D11_BLEND_DESC) );
    }

lExit:
    return hr;
}

template<typename IBaseInterface>
BOOL TBlendVariable<IBaseInterface>::IsValid()
{
    UINT numElements = IsArray()? pType->Elements : 1;
    BOOL valid = TRUE;
    while( numElements > 0 && ( valid = Data.pBlend[ numElements-1 ].IsValid ) )
        numElements--;
    return valid;
}


////////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectDepthStencilVariable (TDepthStencilVariable implementation)
////////////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TDepthStencilVariable : public IBaseInterface
{
public:
    STDMETHOD(GetDepthStencilState)(UINT Index, ID3D11DepthStencilState **ppDepthStencilState);
    STDMETHOD(SetDepthStencilState)(UINT Index, ID3D11DepthStencilState *pDepthStencilState);
    STDMETHOD(UndoSetDepthStencilState)(UINT Index);
    STDMETHOD(GetBackingStore)(UINT Index, D3D11_DEPTH_STENCIL_DESC *pDepthStencilDesc);
    STDMETHOD_(BOOL, IsValid)();
};

template<typename IBaseInterface>
HRESULT TDepthStencilVariable<IBaseInterface>::GetDepthStencilState(UINT Index, ID3D11DepthStencilState **ppDepthStencilState)
{
    LPCSTR pFuncName = "ID3DX11EffectDepthStencilVariable::GetDepthStencilState";

    CHECK_OBJECT_SCALAR_BOUNDS(Index, ppDepthStencilState);

    *ppDepthStencilState = Data.pDepthStencil[Index].pDSObject;
    SAFE_ADDREF(*ppDepthStencilState);

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TDepthStencilVariable<IBaseInterface>::SetDepthStencilState(UINT Index, ID3D11DepthStencilState *pDepthStencilState)
{
    LPCSTR pFuncName = "ID3DX11EffectDepthStencilState::SetDepthStencilState";

    CHECK_SCALAR_BOUNDS(Index);

    if( !Data.pDepthStencil[Index].IsUserManaged )
    {
        // Save original state object in case we UndoSet
        D3DXASSERT( pMemberData[Index].Type == MDT_DepthStencilState );
        VB( pMemberData[Index].Data.pD3DEffectsManagedDepthStencilState == NULL );
        pMemberData[Index].Data.pD3DEffectsManagedDepthStencilState = Data.pDepthStencil[Index].pDSObject;
        Data.pDepthStencil[Index].pDSObject = NULL;
        Data.pDepthStencil[Index].IsUserManaged = TRUE;
    }

    SAFE_ADDREF( pDepthStencilState );
    SAFE_RELEASE( Data.pDepthStencil[Index].pDSObject );
    Data.pDepthStencil[Index].pDSObject = pDepthStencilState;
    Data.pDepthStencil[Index].IsValid = TRUE;
lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TDepthStencilVariable<IBaseInterface>::UndoSetDepthStencilState(UINT Index)
{
    LPCSTR pFuncName = "ID3DX11EffectDepthStencilState::UndoSetDepthStencilState";

    CHECK_SCALAR_BOUNDS(Index);

    if( !Data.pDepthStencil[Index].IsUserManaged )
    {
        return S_FALSE;
    }

    // Revert to original state object
    SAFE_RELEASE( Data.pDepthStencil[Index].pDSObject );
    Data.pDepthStencil[Index].pDSObject = pMemberData[Index].Data.pD3DEffectsManagedDepthStencilState;
    pMemberData[Index].Data.pD3DEffectsManagedDepthStencilState = NULL;
    Data.pDepthStencil[Index].IsUserManaged = FALSE;

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TDepthStencilVariable<IBaseInterface>::GetBackingStore(UINT Index, D3D11_DEPTH_STENCIL_DESC *pDepthStencilDesc)
{
    LPCSTR pFuncName = "ID3DX11EffectDepthStencilVariable::GetBackingStore";

    CHECK_OBJECT_SCALAR_BOUNDS(Index, pDepthStencilDesc);

    if( Data.pDepthStencil[Index].IsUserManaged )
    {
        if( Data.pDepthStencil[Index].pDSObject )
        {
            Data.pDepthStencil[Index].pDSObject->GetDesc( pDepthStencilDesc );
        }
        else
        {
            *pDepthStencilDesc = CD3D11_DEPTH_STENCIL_DESC( D3D11_DEFAULT );
        }
    }
    else
    {
        SDepthStencilBlock *pBlock = Data.pDepthStencil + Index;
        if (pBlock->ApplyAssignments(GetTopLevelEntity()->pEffect))
        {
            pBlock->pAssignments[0].LastRecomputedTime = 0; // Force a recreate of this block the next time ApplyRenderStateBlock is called
        }

        memcpy(pDepthStencilDesc, &pBlock->BackingStore, sizeof(D3D11_DEPTH_STENCIL_DESC));
    }

lExit:
    return hr;
}

template<typename IBaseInterface>
BOOL TDepthStencilVariable<IBaseInterface>::IsValid()
{
    UINT numElements = IsArray()? pType->Elements : 1;
    BOOL valid = TRUE;
    while( numElements > 0 && ( valid = Data.pDepthStencil[ numElements-1 ].IsValid ) )
        numElements--;
    return valid;
}

////////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectRasterizerVariable (TRasterizerVariable implementation)
////////////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TRasterizerVariable : public IBaseInterface
{
public:

    STDMETHOD(GetRasterizerState)(UINT Index, ID3D11RasterizerState **ppRasterizerState);
    STDMETHOD(SetRasterizerState)(UINT Index, ID3D11RasterizerState *pRasterizerState);
    STDMETHOD(UndoSetRasterizerState)(UINT Index);
    STDMETHOD(GetBackingStore)(UINT Index, D3D11_RASTERIZER_DESC *pRasterizerDesc);
    STDMETHOD_(BOOL, IsValid)();
};

template<typename IBaseInterface>
HRESULT TRasterizerVariable<IBaseInterface>::GetRasterizerState(UINT Index, ID3D11RasterizerState **ppRasterizerState)
{
    LPCSTR pFuncName = "ID3DX11EffectRasterizerVariable::GetRasterizerState";

    CHECK_OBJECT_SCALAR_BOUNDS(Index, ppRasterizerState);

    *ppRasterizerState = Data.pRasterizer[Index].pRasterizerObject;
    SAFE_ADDREF(*ppRasterizerState);

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TRasterizerVariable<IBaseInterface>::SetRasterizerState(UINT Index, ID3D11RasterizerState *pRasterizerState)
{
    LPCSTR pFuncName = "ID3DX11EffectRasterizerState::SetRasterizerState";

    CHECK_SCALAR_BOUNDS(Index);

    if( !Data.pRasterizer[Index].IsUserManaged )
    {
        // Save original state object in case we UndoSet
        D3DXASSERT( pMemberData[Index].Type == MDT_RasterizerState );
        VB( pMemberData[Index].Data.pD3DEffectsManagedRasterizerState == NULL );
        pMemberData[Index].Data.pD3DEffectsManagedRasterizerState = Data.pRasterizer[Index].pRasterizerObject;
        Data.pRasterizer[Index].pRasterizerObject = NULL;
        Data.pRasterizer[Index].IsUserManaged = TRUE;
    }

    SAFE_ADDREF( pRasterizerState );
    SAFE_RELEASE( Data.pRasterizer[Index].pRasterizerObject );
    Data.pRasterizer[Index].pRasterizerObject = pRasterizerState;
    Data.pRasterizer[Index].IsValid = TRUE;
lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TRasterizerVariable<IBaseInterface>::UndoSetRasterizerState(UINT Index)
{
    LPCSTR pFuncName = "ID3DX11EffectRasterizerState::UndoSetRasterizerState";

    CHECK_SCALAR_BOUNDS(Index);

    if( !Data.pRasterizer[Index].IsUserManaged )
    {
        return S_FALSE;
    }

    // Revert to original state object
    SAFE_RELEASE( Data.pRasterizer[Index].pRasterizerObject );
    Data.pRasterizer[Index].pRasterizerObject = pMemberData[Index].Data.pD3DEffectsManagedRasterizerState;
    pMemberData[Index].Data.pD3DEffectsManagedRasterizerState = NULL;
    Data.pRasterizer[Index].IsUserManaged = FALSE;

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TRasterizerVariable<IBaseInterface>::GetBackingStore(UINT Index, D3D11_RASTERIZER_DESC *pRasterizerDesc)
{
    LPCSTR pFuncName = "ID3DX11EffectRasterizerVariable::GetBackingStore";

    CHECK_OBJECT_SCALAR_BOUNDS(Index, pRasterizerDesc);

    if( Data.pRasterizer[Index].IsUserManaged )
    {
        if( Data.pRasterizer[Index].pRasterizerObject )
        {
            Data.pRasterizer[Index].pRasterizerObject->GetDesc( pRasterizerDesc );
        }
        else
        {
            *pRasterizerDesc = CD3D11_RASTERIZER_DESC( D3D11_DEFAULT );
        }
    }
    else
    {
        SRasterizerBlock *pBlock = Data.pRasterizer + Index;
        if (pBlock->ApplyAssignments(GetTopLevelEntity()->pEffect))
        {
            pBlock->pAssignments[0].LastRecomputedTime = 0; // Force a recreate of this block the next time ApplyRenderStateBlock is called
        }

        memcpy(pRasterizerDesc, &pBlock->BackingStore, sizeof(D3D11_RASTERIZER_DESC));
    }

lExit:
    return hr;
}

template<typename IBaseInterface>
BOOL TRasterizerVariable<IBaseInterface>::IsValid()
{
    UINT numElements = IsArray()? pType->Elements : 1;
    BOOL valid = TRUE;
    while( numElements > 0 && ( valid = Data.pRasterizer[ numElements-1 ].IsValid ) )
        numElements--;
    return valid;
}

////////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectSamplerVariable (TSamplerVariable implementation)
////////////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TSamplerVariable : public IBaseInterface
{
public:

    STDMETHOD(GetSampler)(UINT Index, ID3D11SamplerState **ppSampler);
    STDMETHOD(SetSampler)(UINT Index, ID3D11SamplerState *pSampler);
    STDMETHOD(UndoSetSampler)(UINT Index);
    STDMETHOD(GetBackingStore)(UINT Index, D3D11_SAMPLER_DESC *pSamplerDesc);
};

template<typename IBaseInterface>
HRESULT TSamplerVariable<IBaseInterface>::GetSampler(UINT Index, ID3D11SamplerState **ppSampler)
{
    LPCSTR pFuncName = "ID3DX11EffectSamplerVariable::GetSampler";

    CHECK_OBJECT_SCALAR_BOUNDS(Index, ppSampler);

    *ppSampler = Data.pSampler[Index].pD3DObject;
    SAFE_ADDREF(*ppSampler);

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TSamplerVariable<IBaseInterface>::SetSampler(UINT Index, ID3D11SamplerState *pSampler)
{
    LPCSTR pFuncName = "ID3DX11EffectSamplerState::SetSampler";

    CHECK_SCALAR_BOUNDS(Index);

    // Replace all references to the old shader block with this one
    GetEffect()->ReplaceSamplerReference(&Data.pSampler[Index], pSampler);

    if( !Data.pSampler[Index].IsUserManaged )
    {
        // Save original state object in case we UndoSet
        D3DXASSERT( pMemberData[Index].Type == MDT_SamplerState );
        VB( pMemberData[Index].Data.pD3DEffectsManagedSamplerState == NULL );
        pMemberData[Index].Data.pD3DEffectsManagedSamplerState = Data.pSampler[Index].pD3DObject;
        Data.pSampler[Index].pD3DObject = NULL;
        Data.pSampler[Index].IsUserManaged = TRUE;
    }

    SAFE_ADDREF( pSampler );
    SAFE_RELEASE( Data.pSampler[Index].pD3DObject );
    Data.pSampler[Index].pD3DObject = pSampler;
lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TSamplerVariable<IBaseInterface>::UndoSetSampler(UINT Index)
{
    LPCSTR pFuncName = "ID3DX11EffectSamplerState::UndoSetSampler";

    CHECK_SCALAR_BOUNDS(Index);

    if( !Data.pSampler[Index].IsUserManaged )
    {
        return S_FALSE;
    }

    // Replace all references to the old shader block with this one
    GetEffect()->ReplaceSamplerReference(&Data.pSampler[Index], pMemberData[Index].Data.pD3DEffectsManagedSamplerState);

    // Revert to original state object
    SAFE_RELEASE( Data.pSampler[Index].pD3DObject );
    Data.pSampler[Index].pD3DObject = pMemberData[Index].Data.pD3DEffectsManagedSamplerState;
    pMemberData[Index].Data.pD3DEffectsManagedSamplerState = NULL;
    Data.pSampler[Index].IsUserManaged = FALSE;

lExit:
    return hr;
}

template<typename IBaseInterface>
HRESULT TSamplerVariable<IBaseInterface>::GetBackingStore(UINT Index, D3D11_SAMPLER_DESC *pSamplerDesc)
{
    LPCSTR pFuncName = "ID3DX11EffectSamplerVariable::GetBackingStore";

    CHECK_OBJECT_SCALAR_BOUNDS(Index, pSamplerDesc);

    if( Data.pSampler[Index].IsUserManaged )
    {
        if( Data.pSampler[Index].pD3DObject )
        {
            Data.pSampler[Index].pD3DObject->GetDesc( pSamplerDesc );
        }
        else
        {
            *pSamplerDesc = CD3D11_SAMPLER_DESC( D3D11_DEFAULT );
        }
    }
    else
    {
        SSamplerBlock *pBlock = Data.pSampler + Index;
        if (pBlock->ApplyAssignments(GetTopLevelEntity()->pEffect))
        {
            pBlock->pAssignments[0].LastRecomputedTime = 0; // Force a recreate of this block the next time ApplyRenderStateBlock is called
        }

        memcpy(pSamplerDesc, &pBlock->BackingStore.SamplerDesc, sizeof(D3D11_SAMPLER_DESC));
    }

lExit:
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
// TUncastableVariable
////////////////////////////////////////////////////////////////////////////////

template<typename IBaseInterface>
struct TUncastableVariable : public IBaseInterface
{
    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)();
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)();
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)();
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)();
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)();
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)();
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)();
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)();
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)();
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)();
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)();
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)();
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)();
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)();
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)();
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)();
};

template<typename IBaseInterface>
ID3DX11EffectScalarVariable * TUncastableVariable<IBaseInterface>::AsScalar()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::AsScalar";
    DPF(0, "%s: Invalid typecast", pFuncName);
    return &g_InvalidScalarVariable;
}

template<typename IBaseInterface>
ID3DX11EffectVectorVariable * TUncastableVariable<IBaseInterface>::AsVector()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::AsVector";
    DPF(0, "%s: Invalid typecast", pFuncName);
    return &g_InvalidVectorVariable;
}

template<typename IBaseInterface>
ID3DX11EffectMatrixVariable * TUncastableVariable<IBaseInterface>::AsMatrix()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::AsMatrix";
    DPF(0, "%s: Invalid typecast", pFuncName);
    return &g_InvalidMatrixVariable;
}

template<typename IBaseInterface>
ID3DX11EffectStringVariable * TUncastableVariable<IBaseInterface>::AsString()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::AsString";
    DPF(0, "%s: Invalid typecast", pFuncName);
    return &g_InvalidStringVariable;
}

template<typename IBaseClassInstance>
ID3DX11EffectClassInstanceVariable * TUncastableVariable<IBaseClassInstance>::AsClassInstance()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::AsClassInstance";
    DPF(0, "%s: Invalid typecast", pFuncName);
    return &g_InvalidClassInstanceVariable;
}

template<typename IBaseInterface>
ID3DX11EffectInterfaceVariable * TUncastableVariable<IBaseInterface>::AsInterface()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::AsInterface";
    DPF(0, "%s: Invalid typecast", pFuncName);
    return &g_InvalidInterfaceVariable;
}

template<typename IBaseInterface>
ID3DX11EffectShaderResourceVariable * TUncastableVariable<IBaseInterface>::AsShaderResource()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::AsShaderResource";
    DPF(0, "%s: Invalid typecast", pFuncName);
    return &g_InvalidShaderResourceVariable;
}

template<typename IBaseInterface>
ID3DX11EffectUnorderedAccessViewVariable * TUncastableVariable<IBaseInterface>::AsUnorderedAccessView()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::AsUnorderedAccessView";
    DPF(0, "%s: Invalid typecast", pFuncName);
    return &g_InvalidUnorderedAccessViewVariable;
}

template<typename IBaseInterface>
ID3DX11EffectRenderTargetViewVariable * TUncastableVariable<IBaseInterface>::AsRenderTargetView()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::AsRenderTargetView";
    DPF(0, "%s: Invalid typecast", pFuncName);
    return &g_InvalidRenderTargetViewVariable;
}

template<typename IBaseInterface>
ID3DX11EffectDepthStencilViewVariable * TUncastableVariable<IBaseInterface>::AsDepthStencilView()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::AsDepthStencilView";
    DPF(0, "%s: Invalid typecast", pFuncName);
    return &g_InvalidDepthStencilViewVariable;
}

template<typename IBaseInterface>
ID3DX11EffectConstantBuffer * TUncastableVariable<IBaseInterface>::AsConstantBuffer()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::AsConstantBuffer";
    DPF(0, "%s: Invalid typecast", pFuncName);
    return &g_InvalidConstantBuffer;
}

template<typename IBaseInterface>
ID3DX11EffectShaderVariable * TUncastableVariable<IBaseInterface>::AsShader()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::AsShader";
    DPF(0, "%s: Invalid typecast", pFuncName);
    return &g_InvalidShaderVariable;
}

template<typename IBaseInterface>
ID3DX11EffectBlendVariable * TUncastableVariable<IBaseInterface>::AsBlend()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::AsBlend";
    DPF(0, "%s: Invalid typecast", pFuncName);
    return &g_InvalidBlendVariable;
}

template<typename IBaseInterface>
ID3DX11EffectDepthStencilVariable * TUncastableVariable<IBaseInterface>::AsDepthStencil()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::AsDepthStencil";
    DPF(0, "%s: Invalid typecast", pFuncName);
    return &g_InvalidDepthStencilVariable;
}

template<typename IBaseInterface>
ID3DX11EffectRasterizerVariable * TUncastableVariable<IBaseInterface>::AsRasterizer()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::AsRasterizer";
    DPF(0, "%s: Invalid typecast", pFuncName);
    return &g_InvalidRasterizerVariable;
}

template<typename IBaseInterface>
ID3DX11EffectSamplerVariable * TUncastableVariable<IBaseInterface>::AsSampler()
{
    LPCSTR pFuncName = "ID3DX11EffectVariable::AsSampler";
    DPF(0, "%s: Invalid typecast", pFuncName);
    return &g_InvalidSamplerVariable;
}

////////////////////////////////////////////////////////////////////////////////
// Macros to instantiate the myriad templates
////////////////////////////////////////////////////////////////////////////////

// generates a global variable, annotation, global variable member, and annotation member of each struct type
#define GenerateReflectionClasses(Type, BaseInterface) \
struct S##Type##GlobalVariable : public T##Type##Variable<TGlobalVariable<BaseInterface>, FALSE> { }; \
struct S##Type##Annotation : public T##Type##Variable<TAnnotation<BaseInterface>, TRUE> { }; \
struct S##Type##GlobalVariableMember : public T##Type##Variable<TVariable<TMember<BaseInterface> >, FALSE> { }; \
struct S##Type##AnnotationMember : public T##Type##Variable<TVariable<TMember<BaseInterface> >, TRUE> { };

#define GenerateVectorReflectionClasses(Type, BaseType, BaseInterface) \
struct S##Type##GlobalVariable : public TVectorVariable<TGlobalVariable<BaseInterface>, FALSE, BaseType> { }; \
struct S##Type##Annotation : public TVectorVariable<TAnnotation<BaseInterface>, TRUE, BaseType> { }; \
struct S##Type##GlobalVariableMember : public TVectorVariable<TVariable<TMember<BaseInterface> >, FALSE, BaseType> { }; \
struct S##Type##AnnotationMember : public TVectorVariable<TVariable<TMember<BaseInterface> >, TRUE, BaseType> { };

#define GenerateReflectionGlobalOnlyClasses(Type) \
struct S##Type##GlobalVariable : public T##Type##Variable<TGlobalVariable<ID3DX11Effect##Type##Variable> > { }; \
struct S##Type##GlobalVariableMember : public T##Type##Variable<TVariable<TMember<ID3DX11Effect##Type##Variable> > > { }; \

GenerateReflectionClasses(Numeric, ID3DX11EffectVariable);
GenerateReflectionClasses(FloatScalar, ID3DX11EffectScalarVariable);
GenerateReflectionClasses(IntScalar, ID3DX11EffectScalarVariable);
GenerateReflectionClasses(BoolScalar, ID3DX11EffectScalarVariable);
GenerateVectorReflectionClasses(FloatVector, ETVT_Float, ID3DX11EffectVectorVariable);
GenerateVectorReflectionClasses(BoolVector, ETVT_Bool, ID3DX11EffectVectorVariable);
GenerateVectorReflectionClasses(IntVector, ETVT_Int, ID3DX11EffectVectorVariable);
GenerateReflectionClasses(Matrix, ID3DX11EffectMatrixVariable);
GenerateReflectionClasses(String, ID3DX11EffectStringVariable);
GenerateReflectionGlobalOnlyClasses(ClassInstance);
GenerateReflectionGlobalOnlyClasses(Interface);
GenerateReflectionGlobalOnlyClasses(ShaderResource);
GenerateReflectionGlobalOnlyClasses(UnorderedAccessView);
GenerateReflectionGlobalOnlyClasses(RenderTargetView);
GenerateReflectionGlobalOnlyClasses(DepthStencilView);
GenerateReflectionGlobalOnlyClasses(Shader);
GenerateReflectionGlobalOnlyClasses(Blend);
GenerateReflectionGlobalOnlyClasses(DepthStencil);
GenerateReflectionGlobalOnlyClasses(Rasterizer);
GenerateReflectionGlobalOnlyClasses(Sampler);

// Optimized matrix classes
struct SMatrix4x4ColumnMajorGlobalVariable : public TMatrix4x4Variable<TGlobalVariable<ID3DX11EffectMatrixVariable>, TRUE> { };
struct SMatrix4x4RowMajorGlobalVariable : public TMatrix4x4Variable<TGlobalVariable<ID3DX11EffectMatrixVariable>, FALSE> { };

struct SMatrix4x4ColumnMajorGlobalVariableMember : public TMatrix4x4Variable<TVariable<TMember<ID3DX11EffectMatrixVariable> >, TRUE> { };
struct SMatrix4x4RowMajorGlobalVariableMember : public TMatrix4x4Variable<TVariable<TMember<ID3DX11EffectMatrixVariable> >, FALSE> { };

// Optimized vector classes
struct SFloatVector4GlobalVariable : public TVector4Variable<TGlobalVariable<ID3DX11EffectVectorVariable> > { };
struct SFloatVector4GlobalVariableMember : public TVector4Variable<TVariable<TMember<ID3DX11EffectVectorVariable> > > { };

// These 3 classes should never be used directly

// The "base" global variable struct (all global variables should be the same size in bytes,
// but we pick this as the default).  
struct SGlobalVariable : public TGlobalVariable<ID3DX11EffectVariable>
{

};

// The "base" annotation struct (all annotations should be the same size in bytes,
// but we pick this as the default).
struct SAnnotation : public TAnnotation<ID3DX11EffectVariable>
{

};

// The "base" variable member struct (all annotation/global variable members should be the
// same size in bytes, but we pick this as the default).
struct SMember : public TVariable<TMember<ID3DX11EffectVariable> >
{

};

// creates a new variable of the appropriate polymorphic type where pVar was
HRESULT PlacementNewVariable(void *pVar, SType *pType, BOOL IsAnnotation);
SMember * CreateNewMember(SType *pType, BOOL IsAnnotation);



```

`Source Code/Effects11/Effects11_2010.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Profile|Win32">
      <Configuration>Profile</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Profile|x64">
      <Configuration>Profile</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectName>Effects11</ProjectName>
    <ProjectGuid>{DF460EAB-570D-4B50-9089-2E2FC801BF38}</ProjectGuid>
    <RootNamespace>Effects11</RootNamespace>
    <Keyword>Win32Proj</Keyword>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|X64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|X64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Profile|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Profile|X64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Profile|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Profile|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <GenerateManifest>true</GenerateManifest>
    <ExecutablePath>$(DXSDK_DIR)Utilities\bin\x86;$(ExecutablePath)</ExecutablePath>
    <OutDir>$(ProjectDir)Bin\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|X64'">
    <LinkIncremental>true</LinkIncremental>
    <GenerateManifest>true</GenerateManifest>
    <ExecutablePath>$(DXSDK_DIR)Utilities\bin\x64;$(DXSDK_DIR)Utilities\bin\x86;$(ExecutablePath)</ExecutablePath>
    <OutDir>$(ProjectDir)Bin\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>true</GenerateManifest>
    <ExecutablePath>$(DXSDK_DIR)Utilities\bin\x86;$(ExecutablePath)</ExecutablePath>
    <OutDir>$(ProjectDir)Bin\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|X64'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>true</GenerateManifest>
    <ExecutablePath>$(DXSDK_DIR)Utilities\bin\x64;$(DXSDK_DIR)Utilities\bin\x86;$(ExecutablePath)</ExecutablePath>
    <OutDir>$(ProjectDir)Bin\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Profile|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>true</GenerateManifest>
    <ExecutablePath>$(DXSDK_DIR)Utilities\bin\x86;$(ExecutablePath)</ExecutablePath>
    <OutDir>$(ProjectDir)Bin\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Profile|X64'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>true</GenerateManifest>
    <ExecutablePath>$(DXSDK_DIR)Utilities\bin\x64;$(DXSDK_DIR)Utilities\bin\x86;$(ExecutablePath)</ExecutablePath>
    <OutDir>$(ProjectDir)Bin\</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <OpenMPSupport>false</OpenMPSupport>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <ExceptionHandling>Sync</ExceptionHandling>
      <AdditionalIncludeDirectories>$(DXSDK_DIR)Include;.\Binary;.\Inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <AdditionalOptions> %(AdditionalOptions)</AdditionalOptions>
      <PreprocessorDefinitions>WIN32;_DEBUG;DEBUG;PROFILE;_WINDOWS;_LIB;D3DXFX_LARGEADDRESS_HANDLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
    </ClCompile>
    <Link>
      <AdditionalOptions> %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <LargeAddressAware>true</LargeAddressAware>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <TargetMachine>MachineX86</TargetMachine>
      <UACExecutionLevel>AsInvoker</UACExecutionLevel>
      <DelayLoadDLLs>%(DelayLoadDLLs)</DelayLoadDLLs>
    </Link>
    <Manifest>
      <EnableDPIAwareness>false</EnableDPIAwareness>
    </Manifest>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|X64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <OpenMPSupport>false</OpenMPSupport>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FloatingPointModel>Fast</FloatingPointModel>
      <ExceptionHandling>Sync</ExceptionHandling>
      <AdditionalIncludeDirectories>$(DXSDK_DIR)Include;.\Binary;.\Inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <AdditionalOptions> %(AdditionalOptions)</AdditionalOptions>
      <PreprocessorDefinitions>WIN32;_DEBUG;DEBUG;PROFILE;_WINDOWS;_LIB;D3DXFX_LARGEADDRESS_HANDLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
    </ClCompile>
    <Link>
      <AdditionalOptions> %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <LargeAddressAware>true</LargeAddressAware>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <TargetMachine>MachineX64</TargetMachine>
      <UACExecutionLevel>AsInvoker</UACExecutionLevel>
      <DelayLoadDLLs>%(DelayLoadDLLs)</DelayLoadDLLs>
    </Link>
    <Manifest>
      <EnableDPIAwareness>false</EnableDPIAwareness>
    </Manifest>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <OpenMPSupport>false</OpenMPSupport>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <ExceptionHandling>Sync</ExceptionHandling>
      <AdditionalIncludeDirectories>$(DXSDK_DIR)Include;.\Binary;.\Inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <AdditionalOptions> %(AdditionalOptions)</AdditionalOptions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_LIB;D3DXFX_LARGEADDRESS_HANDLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalOptions> %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <LargeAddressAware>true</LargeAddressAware>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <TargetMachine>MachineX86</TargetMachine>
      <UACExecutionLevel>AsInvoker</UACExecutionLevel>
      <DelayLoadDLLs>%(DelayLoadDLLs)</DelayLoadDLLs>
    </Link>
    <Manifest>
      <EnableDPIAwareness>false</EnableDPIAwareness>
    </Manifest>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|X64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <OpenMPSupport>false</OpenMPSupport>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FloatingPointModel>Fast</FloatingPointModel>
      <ExceptionHandling>Sync</ExceptionHandling>
      <AdditionalIncludeDirectories>$(DXSDK_DIR)Include;.\Binary;.\Inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <AdditionalOptions> %(AdditionalOptions)</AdditionalOptions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_LIB;D3DXFX_LARGEADDRESS_HANDLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalOptions> %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <LargeAddressAware>true</LargeAddressAware>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <TargetMachine>MachineX64</TargetMachine>
      <UACExecutionLevel>AsInvoker</UACExecutionLevel>
      <DelayLoadDLLs>%(DelayLoadDLLs)</DelayLoadDLLs>
    </Link>
    <Manifest>
      <EnableDPIAwareness>false</EnableDPIAwareness>
    </Manifest>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Profile|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <OpenMPSupport>false</OpenMPSupport>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <ExceptionHandling>Sync</ExceptionHandling>
      <AdditionalIncludeDirectories>$(DXSDK_DIR)Include;.\Binary;.\Inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <AdditionalOptions> %(AdditionalOptions)</AdditionalOptions>
      <PreprocessorDefinitions>WIN32;NDEBUG;PROFILE;_WINDOWS;_LIB;D3DXFX_LARGEADDRESS_HANDLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalOptions> %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <LargeAddressAware>true</LargeAddressAware>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <TargetMachine>MachineX86</TargetMachine>
      <UACExecutionLevel>AsInvoker</UACExecutionLevel>
      <DelayLoadDLLs>%(DelayLoadDLLs)</DelayLoadDLLs>
    </Link>
    <Manifest>
      <EnableDPIAwareness>false</EnableDPIAwareness>
    </Manifest>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Profile|X64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <OpenMPSupport>false</OpenMPSupport>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FloatingPointModel>Fast</FloatingPointModel>
      <ExceptionHandling>Sync</ExceptionHandling>
      <AdditionalIncludeDirectories>$(DXSDK_DIR)Include;.\Binary;.\Inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <AdditionalOptions> %(AdditionalOptions)</AdditionalOptions>
      <PreprocessorDefinitions>WIN32;NDEBUG;PROFILE;_WINDOWS;_LIB;D3DXFX_LARGEADDRESS_HANDLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalOptions> %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <LargeAddressAware>true</LargeAddressAware>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <TargetMachine>MachineX64</TargetMachine>
      <UACExecutionLevel>AsInvoker</UACExecutionLevel>
      <DelayLoadDLLs>%(DelayLoadDLLs)</DelayLoadDLLs>
    </Link>
    <Manifest>
      <EnableDPIAwareness>false</EnableDPIAwareness>
    </Manifest>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup />
  <ItemGroup>
    <CLInclude Include="pchfx.h" />
    <CLInclude Include=".\Inc\d3dx11dbg.h" />
    <CLInclude Include=".\Inc\d3dx11effect.h" />
    <CLInclude Include=".\Inc\d3dxglobal.h" />
    <CLInclude Include=".\Binary\EffectBinaryFormat.h" />
    <CLInclude Include=".\Binary\EffectStateBase11.h" />
    <CLInclude Include=".\Binary\EffectStates11.h" />
    <CLInclude Include=".\Binary\SOParser.h" />
    <ClCompile Include="d3dx11dbg.cpp" />
    <ClCompile Include="d3dxGlobal.cpp" />
    <CLInclude Include="Effect.h" />
    <ClCompile Include="EffectAPI.cpp" />
    <ClCompile Include="EffectLoad.cpp" />
    <CLInclude Include="EffectLoad.h" />
    <ClCompile Include="EffectNonRuntime.cpp" />
    <ClCompile Include="EffectReflection.cpp" />
    <ClCompile Include="EffectRuntime.cpp" />
    <None Include="EffectVariable.inl" />
  </ItemGroup>
  <ItemGroup>
  </ItemGroup>
  <ItemGroup>
  </ItemGroup>
  <ItemGroup>
  </ItemGroup>
  <ItemGroup>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`Source Code/Effects11/Effects11_2010.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns:atg="http://atg.xbox.com" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
<ItemGroup>
<Filter Include="Resource Files">
<UniqueIdentifier>{8e114980-c1a3-4ada-ad7c-83caadf5daeb}</UniqueIdentifier>
<Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
</Filter>
</ItemGroup>
<ItemGroup />
<ItemGroup>
      <CLInclude Include="pchfx.h" />
      <CLInclude Include=".\Inc\d3dx11dbg.h" />
      <CLInclude Include=".\Inc\d3dx11effect.h" />
      <CLInclude Include=".\Inc\d3dxglobal.h" />
      <CLInclude Include=".\Binary\EffectBinaryFormat.h" />
      <CLInclude Include=".\Binary\EffectStateBase11.h" />
      <CLInclude Include=".\Binary\EffectStates11.h" />
      <CLInclude Include=".\Binary\SOParser.h" />
      <ClCompile Include="d3dx11dbg.cpp" />
      <ClCompile Include="d3dxGlobal.cpp" />
      <CLInclude Include="Effect.h" />
      <ClCompile Include="EffectAPI.cpp" />
      <ClCompile Include="EffectLoad.cpp" />
      <CLInclude Include="EffectLoad.h" />
      <ClCompile Include="EffectNonRuntime.cpp" />
      <ClCompile Include="EffectReflection.cpp" />
      <ClCompile Include="EffectRuntime.cpp" />
      <None Include="EffectVariable.inl" />
  </ItemGroup>
<ItemGroup>
</ItemGroup>
<ItemGroup>
</ItemGroup>
<ItemGroup>
</ItemGroup>
</Project>

```

`Source Code/Effects11/Effects11_2010.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Source Code/Effects11/Inc/d3dx11dbg.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx11dbg.h
//  Content:    D3DX11 debugging functions
//
//////////////////////////////////////////////////////////////////////////////


#ifndef __D3DX11DBG_H__
#define __D3DX11DBG_H__

#ifndef _PREFAST_

#pragma warning( disable: 4068 )

#endif


#include <strsafe.h>
#include <new>

#undef NEW
#undef DELETE

#define NEW new (std::nothrow)
#define NEW_PROTO_ARGS size_t s, const std::nothrow_t& t



typedef signed char    INT8;
typedef signed short   INT16;
typedef unsigned char  UINT8;
typedef unsigned short UINT16;


//----------------------------------------------------------------------------
// DPF
//----------------------------------------------------------------------------

#ifdef FXDPF
void cdecl D3DXDebugPrintf(UINT lvl, LPCSTR szFormat, ...);
#define DPF D3DXDebugPrintf
#else // !FXDPF
#pragma warning(disable:4002)
#define DPF() 0
#endif // !FXDPF


//----------------------------------------------------------------------------
// D3DXASSERT
//----------------------------------------------------------------------------

#if _DEBUG
int WINAPI D3DXDebugAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);
#define D3DXASSERT(condition) \
    do { if(!(condition)) D3DXDebugAssert(__FILE__, __LINE__, #condition); } while(0)
#else // !_DEBUG
#define D3DXASSERT(condition) 0
#endif // !_DEBUG



#endif // __D3DX11DBG_H__


```

`Source Code/Effects11/Inc/d3dx11effect.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       D3DX11Effect.h
//  Content:    D3DX11 Effect Types & APIs Header
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __D3DX11EFFECT_H__
#define __D3DX11EFFECT_H__

#include "d3d11.h" 
#include "d3d11shader.h"

//////////////////////////////////////////////////////////////////////////////
// File contents:
//
// 1) Stateblock enums, structs, interfaces, flat APIs
// 2) Effect enums, structs, interfaces, flat APIs
//////////////////////////////////////////////////////////////////////////////

#ifndef D3DX11_BYTES_FROM_BITS
#define D3DX11_BYTES_FROM_BITS(x) (((x) + 7) / 8)
#endif // D3DX11_BYTES_FROM_BITS

typedef struct _D3DX11_STATE_BLOCK_MASK
{
    BYTE VS;
    BYTE VSSamplers[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT)];
    BYTE VSShaderResources[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT)];
    BYTE VSConstantBuffers[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT)];
    BYTE VSInterfaces[D3DX11_BYTES_FROM_BITS(D3D11_SHADER_MAX_INTERFACES)];
    
    BYTE HS;
    BYTE HSSamplers[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT)];
    BYTE HSShaderResources[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT)];
    BYTE HSConstantBuffers[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT)];
    BYTE HSInterfaces[D3DX11_BYTES_FROM_BITS(D3D11_SHADER_MAX_INTERFACES)];

    BYTE DS;
    BYTE DSSamplers[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT)];
    BYTE DSShaderResources[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT)];
    BYTE DSConstantBuffers[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT)];
    BYTE DSInterfaces[D3DX11_BYTES_FROM_BITS(D3D11_SHADER_MAX_INTERFACES)];

    BYTE GS;
    BYTE GSSamplers[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT)];
    BYTE GSShaderResources[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT)];
    BYTE GSConstantBuffers[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT)];
    BYTE GSInterfaces[D3DX11_BYTES_FROM_BITS(D3D11_SHADER_MAX_INTERFACES)];
    
    BYTE PS;
    BYTE PSSamplers[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT)];
    BYTE PSShaderResources[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT)];
    BYTE PSConstantBuffers[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT)];
    BYTE PSInterfaces[D3DX11_BYTES_FROM_BITS(D3D11_SHADER_MAX_INTERFACES)];
    BYTE PSUnorderedAccessViews;
    
    BYTE CS;
    BYTE CSSamplers[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT)];
    BYTE CSShaderResources[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT)];
    BYTE CSConstantBuffers[D3DX11_BYTES_FROM_BITS(D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT)];
    BYTE CSInterfaces[D3DX11_BYTES_FROM_BITS(D3D11_SHADER_MAX_INTERFACES)];
    BYTE CSUnorderedAccessViews;

    BYTE IAVertexBuffers[D3DX11_BYTES_FROM_BITS(D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT)];
    BYTE IAIndexBuffer;
    BYTE IAInputLayout;
    BYTE IAPrimitiveTopology;
    
    BYTE OMRenderTargets;
    BYTE OMDepthStencilState;
    BYTE OMBlendState;
    
    BYTE RSViewports;
    BYTE RSScissorRects;
    BYTE RSRasterizerState;
    
    BYTE SOBuffers;
    
    BYTE Predication;
} D3DX11_STATE_BLOCK_MASK;

//----------------------------------------------------------------------------
// D3DX11_EFFECT flags:
// -------------------------------------
//
// These flags are passed in when creating an effect, and affect
// the runtime effect behavior:
//
// (Currently none)
//
//
// These flags are set by the effect runtime:
//
// D3DX11_EFFECT_OPTIMIZED
//   This effect has been optimized. Reflection functions that rely on 
//   names/semantics/strings should fail. This is set when Optimize() is
//   called, but CEffect::IsOptimized() should be used to test for this.
//
// D3DX11_EFFECT_CLONE
//   This effect is a clone of another effect. Single CBs will never be 
//   updated when internal variable values are changed.
//   This flag is not set when the D3DX11_EFFECT_CLONE_FORCE_NONSINGLE flag 
//   is used in cloning.
//
//----------------------------------------------------------------------------

#define D3DX11_EFFECT_OPTIMIZED                         (1 << 21)
#define D3DX11_EFFECT_CLONE                             (1 << 22)

// These are the only valid parameter flags to D3DX11CreateEffect*
#define D3DX11_EFFECT_RUNTIME_VALID_FLAGS (0)

//----------------------------------------------------------------------------
// D3DX11_EFFECT_VARIABLE flags:
// ----------------------------
//
// These flags describe an effect variable (global or annotation),
// and are returned in D3DX11_EFFECT_VARIABLE_DESC::Flags.
//
// D3DX11_EFFECT_VARIABLE_ANNOTATION
//   Indicates that this is an annotation on a technique, pass, or global
//   variable. Otherwise, this is a global variable. Annotations cannot
//   be shared.
//
// D3DX11_EFFECT_VARIABLE_EXPLICIT_BIND_POINT
//   Indicates that the variable has been explicitly bound using the
//   register keyword.
//----------------------------------------------------------------------------

#define D3DX11_EFFECT_VARIABLE_ANNOTATION              (1 << 1)
#define D3DX11_EFFECT_VARIABLE_EXPLICIT_BIND_POINT     (1 << 2)

//----------------------------------------------------------------------------
// D3DX11_EFFECT_CLONE flags:
// ----------------------------
//
// These flags modify the effect cloning process and are passed into Clone.
//
// D3DX11_EFFECT_CLONE_FORCE_NONSINGLE
//   Ignore all "single" qualifiers on cbuffers.  All cbuffers will have their
//   own ID3D11Buffer's created in the cloned effect.
//----------------------------------------------------------------------------

#define D3DX11_EFFECT_CLONE_FORCE_NONSINGLE        	    (1 << 0)

//----------------------------------------------------------------------------
// D3DX11_EFFECT_PASS flags:
// ----------------------------
//
// These flags modify the effect cloning process and are passed into Clone.
//
// D3DX11_EFFECT_PASS_COMMIT_CHANGES
//   This flag tells the effect runtime to assume that the device state was 
//   not modified outside of effects, so that only updated state needs to
//   be set.
//
// D3DX11_EFFECT_PASS_OMIT_*
//   When applying a pass, do not set the state indicated in the flag name.
//----------------------------------------------------------------------------

#define D3DX11_EFFECT_PASS_COMMIT_CHANGES               (1 << 0)    // TODO: not yet implemented
#define D3DX11_EFFECT_PASS_OMIT_SHADERS_AND_INTERFACES  (1 << 1)    // TODO: not yet implemented
#define D3DX11_EFFECT_PASS_OMIT_STATE_OBJECTS           (1 << 2)    // TODO: not yet implemented
#define D3DX11_EFFECT_PASS_OMIT_RTVS_AND_DSVS           (1 << 3)    // TODO: not yet implemented
#define D3DX11_EFFECT_PASS_OMIT_SAMPLERS                (1 << 4)    // TODO: not yet implemented
#define D3DX11_EFFECT_PASS_OMIT_CBS                     (1 << 5)    // TODO: not yet implemented
#define D3DX11_EFFECT_PASS_OMIT_SRVS                    (1 << 6)    // TODO: not yet implemented
#define D3DX11_EFFECT_PASS_OMIT_UAVS                    (1 << 7)    // TODO: not yet implemented

#define D3DX11_EFFECT_PASS_ONLY_SET_SHADERS_AND_CBS   ( D3DX11_EFFECT_PASS_OMIT_STATE_OBJECTS | \
                                                        D3DX11_EFFECT_PASS_OMIT_RTVS_AND_DSVS | \
                                                        D3DX11_EFFECT_PASS_OMIT_SAMPLERS | \
                                                        D3DX11_EFFECT_PASS_OMIT_SRVS | \
                                                        D3DX11_EFFECT_PASS_OMIT_UAVS );

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectType //////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
// D3DX11_EFFECT_TYPE_DESC:
//
// Retrieved by ID3DX11EffectType::GetDesc()
//----------------------------------------------------------------------------

typedef struct _D3DX11_EFFECT_TYPE_DESC
{
    LPCSTR  TypeName;               // Name of the type 
                                    // (e.g. "float4" or "MyStruct")

    D3D10_SHADER_VARIABLE_CLASS    Class;  // (e.g. scalar, vector, object, etc.)
    D3D10_SHADER_VARIABLE_TYPE     Type;   // (e.g. float, texture, vertexshader, etc.)
    
    UINT    Elements;               // Number of elements in this type
                                    // (0 if not an array) 
    UINT    Members;                // Number of members
                                    // (0 if not a structure)
    UINT    Rows;                   // Number of rows in this type
                                    // (0 if not a numeric primitive)
    UINT    Columns;                // Number of columns in this type
                                    // (0 if not a numeric primitive)
    
    UINT    PackedSize;             // Number of bytes required to represent
                                    // this data type, when tightly packed
    UINT    UnpackedSize;           // Number of bytes occupied by this data
                                    // type, when laid out in a constant buffer
    UINT    Stride;                 // Number of bytes to seek between elements,
                                    // when laid out in a constant buffer
} D3DX11_EFFECT_TYPE_DESC;

typedef interface ID3DX11EffectType ID3DX11EffectType;
typedef interface ID3DX11EffectType *LPD3D11EFFECTTYPE;

// {4250D721-D5E5-491F-B62B-587C43186285}
DEFINE_GUID(IID_ID3DX11EffectType, 
            0x4250d721, 0xd5e5, 0x491f, 0xb6, 0x2b, 0x58, 0x7c, 0x43, 0x18, 0x62, 0x85);

#undef INTERFACE
#define INTERFACE ID3DX11EffectType

DECLARE_INTERFACE(ID3DX11EffectType)
{
    STDMETHOD_(BOOL, IsValid)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_TYPE_DESC *pDesc) PURE;
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectType*, GetMemberTypeBySemantic)(THIS_ LPCSTR Semantic) PURE;
    STDMETHOD_(LPCSTR, GetMemberName)(THIS_ UINT Index) PURE;
    STDMETHOD_(LPCSTR, GetMemberSemantic)(THIS_ UINT Index) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectVariable //////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
// D3DX11_EFFECT_VARIABLE_DESC:
//
// Retrieved by ID3DX11EffectVariable::GetDesc()
//----------------------------------------------------------------------------

typedef struct _D3DX11_EFFECT_VARIABLE_DESC
{
    LPCSTR  Name;                   // Name of this variable, annotation, 
                                    // or structure member
    LPCSTR  Semantic;               // Semantic string of this variable
                                    // or structure member (NULL for 
                                    // annotations or if not present)
    
    UINT    Flags;                  // D3DX11_EFFECT_VARIABLE_* flags
    UINT    Annotations;            // Number of annotations on this variable
                                    // (always 0 for annotations)

    UINT    BufferOffset;           // Offset into containing cbuffer or tbuffer
                                    // (always 0 for annotations or variables
                                    // not in constant buffers)

    UINT    ExplicitBindPoint;      // Used if the variable has been explicitly bound
                                    // using the register keyword. Check Flags for
                                    // D3DX11_EFFECT_VARIABLE_EXPLICIT_BIND_POINT;
} D3DX11_EFFECT_VARIABLE_DESC;

typedef interface ID3DX11EffectVariable ID3DX11EffectVariable;
typedef interface ID3DX11EffectVariable *LPD3D11EFFECTVARIABLE;

// {036A777D-B56E-4B25-B313-CC3DDAB71873}
DEFINE_GUID(IID_ID3DX11EffectVariable, 
            0x036a777d, 0xb56e, 0x4b25, 0xb3, 0x13, 0xcc, 0x3d, 0xda, 0xb7, 0x18, 0x73);

#undef INTERFACE
#define INTERFACE ID3DX11EffectVariable

// Forward defines
typedef interface ID3DX11EffectScalarVariable ID3DX11EffectScalarVariable;
typedef interface ID3DX11EffectVectorVariable ID3DX11EffectVectorVariable;
typedef interface ID3DX11EffectMatrixVariable ID3DX11EffectMatrixVariable;
typedef interface ID3DX11EffectStringVariable ID3DX11EffectStringVariable;
typedef interface ID3DX11EffectClassInstanceVariable ID3DX11EffectClassInstanceVariable;
typedef interface ID3DX11EffectInterfaceVariable ID3DX11EffectInterfaceVariable;
typedef interface ID3DX11EffectShaderResourceVariable ID3DX11EffectShaderResourceVariable;
typedef interface ID3DX11EffectUnorderedAccessViewVariable ID3DX11EffectUnorderedAccessViewVariable;
typedef interface ID3DX11EffectRenderTargetViewVariable ID3DX11EffectRenderTargetViewVariable;
typedef interface ID3DX11EffectDepthStencilViewVariable ID3DX11EffectDepthStencilViewVariable;
typedef interface ID3DX11EffectConstantBuffer ID3DX11EffectConstantBuffer;
typedef interface ID3DX11EffectShaderVariable ID3DX11EffectShaderVariable;
typedef interface ID3DX11EffectBlendVariable ID3DX11EffectBlendVariable;
typedef interface ID3DX11EffectDepthStencilVariable ID3DX11EffectDepthStencilVariable;
typedef interface ID3DX11EffectRasterizerVariable ID3DX11EffectRasterizerVariable;
typedef interface ID3DX11EffectSamplerVariable ID3DX11EffectSamplerVariable;

DECLARE_INTERFACE(ID3DX11EffectVariable)
{
    STDMETHOD_(BOOL, IsValid)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;

    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;
    
    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;
    
    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT Offset, UINT Count) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectScalarVariable ////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef interface ID3DX11EffectScalarVariable ID3DX11EffectScalarVariable;
typedef interface ID3DX11EffectScalarVariable *LPD3D11EFFECTSCALARVARIABLE;

// {921EF2E5-A65D-4E92-9FC6-4E9CC09A4ADE}
DEFINE_GUID(IID_ID3DX11EffectScalarVariable, 
            0x921ef2e5, 0xa65d, 0x4e92, 0x9f, 0xc6, 0x4e, 0x9c, 0xc0, 0x9a, 0x4a, 0xde);

#undef INTERFACE
#define INTERFACE ID3DX11EffectScalarVariable

DECLARE_INTERFACE_(ID3DX11EffectScalarVariable, ID3DX11EffectVariable)
{
    STDMETHOD_(BOOL, IsValid)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;
    
    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;
    
    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;
    
    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT ByteOffset, UINT ByteCount) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT ByteOffset, UINT ByteCount) PURE;
    
    STDMETHOD(SetFloat)(THIS_ CONST float Value) PURE;
    STDMETHOD(GetFloat)(THIS_ float *pValue) PURE;    
    
    STDMETHOD(SetFloatArray)(THIS_ CONST float *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetFloatArray)(THIS_ float *pData, UINT Offset, UINT Count) PURE;
    
    STDMETHOD(SetInt)(THIS_ CONST int Value) PURE;
    STDMETHOD(GetInt)(THIS_ int *pValue) PURE;
    
    STDMETHOD(SetIntArray)(THIS_ CONST int *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetIntArray)(THIS_ int *pData, UINT Offset, UINT Count) PURE;
    
    STDMETHOD(SetBool)(THIS_ CONST BOOL Value) PURE;
    STDMETHOD(GetBool)(THIS_ BOOL *pValue) PURE;
    
    STDMETHOD(SetBoolArray)(THIS_ CONST BOOL *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetBoolArray)(THIS_ BOOL *pData, UINT Offset, UINT Count) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectVectorVariable ////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef interface ID3DX11EffectVectorVariable ID3DX11EffectVectorVariable;
typedef interface ID3DX11EffectVectorVariable *LPD3D11EFFECTVECTORVARIABLE;

// {5E785D4A-D87B-48D8-B6E6-0F8CA7E7467A}
DEFINE_GUID(IID_ID3DX11EffectVectorVariable, 
            0x5e785d4a, 0xd87b, 0x48d8, 0xb6, 0xe6, 0x0f, 0x8c, 0xa7, 0xe7, 0x46, 0x7a);

#undef INTERFACE
#define INTERFACE ID3DX11EffectVectorVariable

DECLARE_INTERFACE_(ID3DX11EffectVectorVariable, ID3DX11EffectVariable)
{
    STDMETHOD_(BOOL, IsValid)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;
    
    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;
    
    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE; 
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;
    
    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT ByteOffset, UINT ByteCount) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT ByteOffset, UINT ByteCount) PURE;
    
    STDMETHOD(SetBoolVector) (THIS_ CONST BOOL *pData) PURE;
    STDMETHOD(SetIntVector)  (THIS_ CONST int *pData) PURE;
    STDMETHOD(SetFloatVector)(THIS_ CONST float *pData) PURE;

    STDMETHOD(GetBoolVector) (THIS_ BOOL *pData) PURE;
    STDMETHOD(GetIntVector)  (THIS_ int *pData) PURE;
    STDMETHOD(GetFloatVector)(THIS_ float *pData) PURE;

    STDMETHOD(SetBoolVectorArray) (THIS_ CONST BOOL *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(SetIntVectorArray)  (THIS_ CONST int *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(SetFloatVectorArray)(THIS_ CONST float *pData, UINT Offset, UINT Count) PURE;

    STDMETHOD(GetBoolVectorArray) (THIS_ BOOL *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetIntVectorArray)  (THIS_ int *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetFloatVectorArray)(THIS_ float *pData, UINT Offset, UINT Count) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectMatrixVariable ////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef interface ID3DX11EffectMatrixVariable ID3DX11EffectMatrixVariable;
typedef interface ID3DX11EffectMatrixVariable *LPD3D11EFFECTMATRIXVARIABLE;

// {E1096CF4-C027-419A-8D86-D29173DC803E}
DEFINE_GUID(IID_ID3DX11EffectMatrixVariable, 
            0xe1096cf4, 0xc027, 0x419a, 0x8d, 0x86, 0xd2, 0x91, 0x73, 0xdc, 0x80, 0x3e);

#undef INTERFACE
#define INTERFACE ID3DX11EffectMatrixVariable

DECLARE_INTERFACE_(ID3DX11EffectMatrixVariable, ID3DX11EffectVariable)
{
    STDMETHOD_(BOOL, IsValid)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;
    
    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;
    
    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;
    
    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT ByteOffset, UINT ByteCount) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT ByteOffset, UINT ByteCount) PURE;
    
    STDMETHOD(SetMatrix)(THIS_ CONST float *pData) PURE;
    STDMETHOD(GetMatrix)(THIS_ float *pData) PURE;
    
    STDMETHOD(SetMatrixArray)(THIS_ CONST float *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetMatrixArray)(THIS_ float *pData, UINT Offset, UINT Count) PURE;
    
    STDMETHOD(SetMatrixTranspose)(THIS_ CONST float *pData) PURE;
    STDMETHOD(GetMatrixTranspose)(THIS_ float *pData) PURE;
    
    STDMETHOD(SetMatrixTransposeArray)(THIS_ CONST float *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetMatrixTransposeArray)(THIS_ float *pData, UINT Offset, UINT Count) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectStringVariable ////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef interface ID3DX11EffectStringVariable ID3DX11EffectStringVariable;
typedef interface ID3DX11EffectStringVariable *LPD3D11EFFECTSTRINGVARIABLE;

// {F355C818-01BE-4653-A7CC-60FFFEDDC76D}
DEFINE_GUID(IID_ID3DX11EffectStringVariable, 
            0xf355c818, 0x01be, 0x4653, 0xa7, 0xcc, 0x60, 0xff, 0xfe, 0xdd, 0xc7, 0x6d);

#undef INTERFACE
#define INTERFACE ID3DX11EffectStringVariable

DECLARE_INTERFACE_(ID3DX11EffectStringVariable, ID3DX11EffectVariable)
{
    STDMETHOD_(BOOL, IsValid)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;
    
    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;
    
    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;
    
    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT Offset, UINT Count) PURE;
    
    STDMETHOD(GetString)(THIS_ LPCSTR *ppString) PURE;
    STDMETHOD(GetStringArray)(THIS_ LPCSTR *ppStrings, UINT Offset, UINT Count) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectClassInstanceVariable ////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef interface ID3DX11EffectClassInstanceVariable ID3DX11EffectClassInstanceVariable;
typedef interface ID3DX11EffectClassInstanceVariable *LPD3D11EFFECTCLASSINSTANCEVARIABLE;

// {926A8053-2A39-4DB4-9BDE-CF649ADEBDC1}
DEFINE_GUID(IID_ID3DX11EffectClassInstanceVariable, 
            0x926a8053, 0x2a39, 0x4db4, 0x9b, 0xde, 0xcf, 0x64, 0x9a, 0xde, 0xbd, 0xc1);

#undef INTERFACE
#define INTERFACE ID3DX11EffectClassInstanceVariable

DECLARE_INTERFACE_(ID3DX11EffectClassInstanceVariable, ID3DX11EffectVariable)
{
    STDMETHOD_(BOOL, IsValid)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;

    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;

    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;

    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;

    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;

    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT Offset, UINT Count) PURE;

    STDMETHOD(GetClassInstance)(ID3D11ClassInstance** ppClassInstance) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectInterfaceVariable ////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef interface ID3DX11EffectInterfaceVariable ID3DX11EffectInterfaceVariable;
typedef interface ID3DX11EffectInterfaceVariable *LPD3D11EFFECTINTERFACEVARIABLE;

// {516C8CD8-1C80-40A4-B19B-0688792F11A5}
DEFINE_GUID(IID_ID3DX11EffectInterfaceVariable, 
            0x516c8cd8, 0x1c80, 0x40a4, 0xb1, 0x9b, 0x06, 0x88, 0x79, 0x2f, 0x11, 0xa5);

#undef INTERFACE
#define INTERFACE ID3DX11EffectInterfaceVariable

DECLARE_INTERFACE_(ID3DX11EffectInterfaceVariable, ID3DX11EffectVariable)
{
    STDMETHOD_(BOOL, IsValid)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;

    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;

    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;

    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;

    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;

    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT Offset, UINT Count) PURE;

    STDMETHOD(SetClassInstance)(ID3DX11EffectClassInstanceVariable *pEffectClassInstance) PURE;
    STDMETHOD(GetClassInstance)(ID3DX11EffectClassInstanceVariable **ppEffectClassInstance) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectShaderResourceVariable ////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef interface ID3DX11EffectShaderResourceVariable ID3DX11EffectShaderResourceVariable;
typedef interface ID3DX11EffectShaderResourceVariable *LPD3D11EFFECTSHADERRESOURCEVARIABLE;

// {350DB233-BBE0-485C-9BFE-C0026B844F89}
DEFINE_GUID(IID_ID3DX11EffectShaderResourceVariable, 
            0x350db233, 0xbbe0, 0x485c, 0x9b, 0xfe, 0xc0, 0x02, 0x6b, 0x84, 0x4f, 0x89);

#undef INTERFACE
#define INTERFACE ID3DX11EffectShaderResourceVariable

DECLARE_INTERFACE_(ID3DX11EffectShaderResourceVariable, ID3DX11EffectVariable)
{
    STDMETHOD_(BOOL, IsValid)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;
    
    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;
    
    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;
    
    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT Offset, UINT Count) PURE;
    
    STDMETHOD(SetResource)(THIS_ ID3D11ShaderResourceView *pResource) PURE;
    STDMETHOD(GetResource)(THIS_ ID3D11ShaderResourceView **ppResource) PURE;
    
    STDMETHOD(SetResourceArray)(THIS_ ID3D11ShaderResourceView **ppResources, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetResourceArray)(THIS_ ID3D11ShaderResourceView **ppResources, UINT Offset, UINT Count) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectUnorderedAccessViewVariable ////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef interface ID3DX11EffectUnorderedAccessViewVariable ID3DX11EffectUnorderedAccessViewVariable;
typedef interface ID3DX11EffectUnorderedAccessViewVariable *LPD3D11EFFECTUNORDEREDACCESSVIEWVARIABLE;

// {79B4AC8C-870A-47D2-B05A-8BD5CC3EE6C9}
DEFINE_GUID(IID_ID3DX11EffectUnorderedAccessViewVariable, 
            0x79b4ac8c, 0x870a, 0x47d2, 0xb0, 0x5a, 0x8b, 0xd5, 0xcc, 0x3e, 0xe6, 0xc9);

#undef INTERFACE
#define INTERFACE ID3DX11EffectUnorderedAccessViewVariable

DECLARE_INTERFACE_(ID3DX11EffectUnorderedAccessViewVariable, ID3DX11EffectVariable)
{
    STDMETHOD_(BOOL, IsValid)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;

    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;

    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;

    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;

    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;

    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT Offset, UINT Count) PURE;

    STDMETHOD(SetUnorderedAccessView)(THIS_ ID3D11UnorderedAccessView *pResource) PURE;
    STDMETHOD(GetUnorderedAccessView)(THIS_ ID3D11UnorderedAccessView **ppResource) PURE;

    STDMETHOD(SetUnorderedAccessViewArray)(THIS_ ID3D11UnorderedAccessView **ppResources, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetUnorderedAccessViewArray)(THIS_ ID3D11UnorderedAccessView **ppResources, UINT Offset, UINT Count) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectRenderTargetViewVariable //////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef interface ID3DX11EffectRenderTargetViewVariable ID3DX11EffectRenderTargetViewVariable;
typedef interface ID3DX11EffectRenderTargetViewVariable *LPD3D11EFFECTRENDERTARGETVIEWVARIABLE;

// {D5066909-F40C-43F8-9DB5-057C2A208552}
DEFINE_GUID(IID_ID3DX11EffectRenderTargetViewVariable, 
            0xd5066909, 0xf40c, 0x43f8, 0x9d, 0xb5, 0x05, 0x7c, 0x2a, 0x20, 0x85, 0x52);

#undef INTERFACE
#define INTERFACE ID3DX11EffectRenderTargetViewVariable

DECLARE_INTERFACE_(ID3DX11EffectRenderTargetViewVariable, ID3DX11EffectVariable)
{
    STDMETHOD_(BOOL, IsValid)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;
    
    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;
    
    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;
    
    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT Offset, UINT Count) PURE;
    
    STDMETHOD(SetRenderTarget)(THIS_ ID3D11RenderTargetView *pResource) PURE;
    STDMETHOD(GetRenderTarget)(THIS_ ID3D11RenderTargetView **ppResource) PURE;
    
    STDMETHOD(SetRenderTargetArray)(THIS_ ID3D11RenderTargetView **ppResources, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetRenderTargetArray)(THIS_ ID3D11RenderTargetView **ppResources, UINT Offset, UINT Count) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectDepthStencilViewVariable //////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef interface ID3DX11EffectDepthStencilViewVariable ID3DX11EffectDepthStencilViewVariable;
typedef interface ID3DX11EffectDepthStencilViewVariable *LPD3D11EFFECTDEPTHSTENCILVIEWVARIABLE;

// {33C648AC-2E9E-4A2E-9CD6-DE31ACC5B347}
DEFINE_GUID(IID_ID3DX11EffectDepthStencilViewVariable, 
            0x33c648ac, 0x2e9e, 0x4a2e, 0x9c, 0xd6, 0xde, 0x31, 0xac, 0xc5, 0xb3, 0x47);

#undef INTERFACE
#define INTERFACE ID3DX11EffectDepthStencilViewVariable

DECLARE_INTERFACE_(ID3DX11EffectDepthStencilViewVariable, ID3DX11EffectVariable)
{
    STDMETHOD_(BOOL, IsValid)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;
    
    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;
    
    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;
    
    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT Offset, UINT Count) PURE;
    
    STDMETHOD(SetDepthStencil)(THIS_ ID3D11DepthStencilView *pResource) PURE;
    STDMETHOD(GetDepthStencil)(THIS_ ID3D11DepthStencilView **ppResource) PURE;
    
    STDMETHOD(SetDepthStencilArray)(THIS_ ID3D11DepthStencilView **ppResources, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetDepthStencilArray)(THIS_ ID3D11DepthStencilView **ppResources, UINT Offset, UINT Count) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectConstantBuffer ////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef interface ID3DX11EffectConstantBuffer ID3DX11EffectConstantBuffer;
typedef interface ID3DX11EffectConstantBuffer *LPD3D11EFFECTCONSTANTBUFFER;

// {2CB6C733-82D2-4000-B3DA-6219D9A99BF2}
DEFINE_GUID(IID_ID3DX11EffectConstantBuffer, 
            0x2cb6c733, 0x82d2, 0x4000, 0xb3, 0xda, 0x62, 0x19, 0xd9, 0xa9, 0x9b, 0xf2);

#undef INTERFACE
#define INTERFACE ID3DX11EffectConstantBuffer

DECLARE_INTERFACE_(ID3DX11EffectConstantBuffer, ID3DX11EffectVariable)
{
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;
    
    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;
    
    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;
    
    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT Offset, UINT Count) PURE;
    
    STDMETHOD(SetConstantBuffer)(THIS_ ID3D11Buffer *pConstantBuffer) PURE;
    STDMETHOD(UndoSetConstantBuffer)(THIS) PURE;
    STDMETHOD(GetConstantBuffer)(THIS_ ID3D11Buffer **ppConstantBuffer) PURE;
    
    STDMETHOD(SetTextureBuffer)(THIS_ ID3D11ShaderResourceView *pTextureBuffer) PURE;
    STDMETHOD(UndoSetTextureBuffer)(THIS) PURE;
    STDMETHOD(GetTextureBuffer)(THIS_ ID3D11ShaderResourceView **ppTextureBuffer) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectShaderVariable ////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
// D3DX11_EFFECT_SHADER_DESC:
//
// Retrieved by ID3DX11EffectShaderVariable::GetShaderDesc()
//----------------------------------------------------------------------------

typedef struct _D3DX11_EFFECT_SHADER_DESC
{
    CONST BYTE *pInputSignature;            // Passed into CreateInputLayout,
                                            // valid on VS and GS only
    
    BOOL IsInline;                          // Is this an anonymous shader variable
                                            // resulting from an inline shader assignment?
    
    
    // -- The following fields are not valid after Optimize() --
    CONST BYTE *pBytecode;                  // Shader bytecode
    UINT BytecodeLength;
    
    LPCSTR SODecls[D3D11_SO_STREAM_COUNT];  // Stream out declaration string (for GS with SO)
    UINT RasterizedStream;
    
    UINT NumInputSignatureEntries;          // Number of entries in the input signature
    UINT NumOutputSignatureEntries;         // Number of entries in the output signature
    UINT NumPatchConstantSignatureEntries;  // Number of entries in the patch constant signature
} D3DX11_EFFECT_SHADER_DESC;


typedef interface ID3DX11EffectShaderVariable ID3DX11EffectShaderVariable;
typedef interface ID3DX11EffectShaderVariable *LPD3D11EFFECTSHADERVARIABLE;

// {7508B344-020A-4EC7-9118-62CDD36C88D7}
DEFINE_GUID(IID_ID3DX11EffectShaderVariable, 
            0x7508b344, 0x020a, 0x4ec7, 0x91, 0x18, 0x62, 0xcd, 0xd3, 0x6c, 0x88, 0xd7);

#undef INTERFACE
#define INTERFACE ID3DX11EffectShaderVariable

DECLARE_INTERFACE_(ID3DX11EffectShaderVariable, ID3DX11EffectVariable)
{
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;
    
    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;
    
    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;
        
    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT Offset, UINT Count) PURE;
    
    STDMETHOD(GetShaderDesc)(THIS_ UINT ShaderIndex, D3DX11_EFFECT_SHADER_DESC *pDesc) PURE;
    
    STDMETHOD(GetVertexShader)(THIS_ UINT ShaderIndex, ID3D11VertexShader **ppVS) PURE;
    STDMETHOD(GetGeometryShader)(THIS_ UINT ShaderIndex, ID3D11GeometryShader **ppGS) PURE;
    STDMETHOD(GetPixelShader)(THIS_ UINT ShaderIndex, ID3D11PixelShader **ppPS) PURE;
    STDMETHOD(GetHullShader)(THIS_ UINT ShaderIndex, ID3D11HullShader **ppPS) PURE;
    STDMETHOD(GetDomainShader)(THIS_ UINT ShaderIndex, ID3D11DomainShader **ppPS) PURE;
    STDMETHOD(GetComputeShader)(THIS_ UINT ShaderIndex, ID3D11ComputeShader **ppPS) PURE;
    
    STDMETHOD(GetInputSignatureElementDesc)(THIS_ UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc) PURE;
    STDMETHOD(GetOutputSignatureElementDesc)(THIS_ UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc) PURE;
    STDMETHOD(GetPatchConstantSignatureElementDesc)(THIS_ UINT ShaderIndex, UINT Element, D3D11_SIGNATURE_PARAMETER_DESC *pDesc) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectBlendVariable /////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef interface ID3DX11EffectBlendVariable ID3DX11EffectBlendVariable;
typedef interface ID3DX11EffectBlendVariable *LPD3D11EFFECTBLENDVARIABLE;

// {D664F4D7-3B81-4805-B277-C1DF58C39F53}
DEFINE_GUID(IID_ID3DX11EffectBlendVariable, 
            0xd664f4d7, 0x3b81, 0x4805, 0xb2, 0x77, 0xc1, 0xdf, 0x58, 0xc3, 0x9f, 0x53);

#undef INTERFACE
#define INTERFACE ID3DX11EffectBlendVariable

DECLARE_INTERFACE_(ID3DX11EffectBlendVariable, ID3DX11EffectVariable)
{
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;
    
    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;
    
    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;
    
    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT Offset, UINT Count) PURE;
    
    STDMETHOD(GetBlendState)(THIS_ UINT Index, ID3D11BlendState **ppBlendState) PURE;
    STDMETHOD(SetBlendState)(THIS_ UINT Index, ID3D11BlendState *pBlendState) PURE;
    STDMETHOD(UndoSetBlendState)(THIS_ UINT Index) PURE; 
    STDMETHOD(GetBackingStore)(THIS_ UINT Index, D3D11_BLEND_DESC *pBlendDesc) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectDepthStencilVariable //////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef interface ID3DX11EffectDepthStencilVariable ID3DX11EffectDepthStencilVariable;
typedef interface ID3DX11EffectDepthStencilVariable *LPD3D11EFFECTDEPTHSTENCILVARIABLE;

// {69B5751B-61A5-48E5-BD41-D93988111563}
DEFINE_GUID(IID_ID3DX11EffectDepthStencilVariable, 
            0x69b5751b, 0x61a5, 0x48e5, 0xbd, 0x41, 0xd9, 0x39, 0x88, 0x11, 0x15, 0x63);

#undef INTERFACE
#define INTERFACE ID3DX11EffectDepthStencilVariable

DECLARE_INTERFACE_(ID3DX11EffectDepthStencilVariable, ID3DX11EffectVariable)
{
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;
    
    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;
    
    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;
    
    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT Offset, UINT Count) PURE;
    
    STDMETHOD(GetDepthStencilState)(THIS_ UINT Index, ID3D11DepthStencilState **ppDepthStencilState) PURE;
    STDMETHOD(SetDepthStencilState)(THIS_ UINT Index, ID3D11DepthStencilState *pDepthStencilState) PURE;
    STDMETHOD(UndoSetDepthStencilState)(THIS_ UINT Index) PURE;
    STDMETHOD(GetBackingStore)(THIS_ UINT Index, D3D11_DEPTH_STENCIL_DESC *pDepthStencilDesc) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectRasterizerVariable ////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef interface ID3DX11EffectRasterizerVariable ID3DX11EffectRasterizerVariable;
typedef interface ID3DX11EffectRasterizerVariable *LPD3D11EFFECTRASTERIZERVARIABLE;

// {53A262F6-5F74-4151-A132-E3DD19A62C9D}
DEFINE_GUID(IID_ID3DX11EffectRasterizerVariable, 
            0x53a262f6, 0x5f74, 0x4151, 0xa1, 0x32, 0xe3, 0xdd, 0x19, 0xa6, 0x2c, 0x9d);

#undef INTERFACE
#define INTERFACE ID3DX11EffectRasterizerVariable

DECLARE_INTERFACE_(ID3DX11EffectRasterizerVariable, ID3DX11EffectVariable)
{
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;
    
    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;
    
    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;
    
    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT Offset, UINT Count) PURE;
    
    STDMETHOD(GetRasterizerState)(THIS_ UINT Index, ID3D11RasterizerState **ppRasterizerState) PURE;
    STDMETHOD(SetRasterizerState)(THIS_ UINT Index, ID3D11RasterizerState *pRasterizerState) PURE;
    STDMETHOD(UndoSetRasterizerState)(THIS_ UINT Index) PURE;
    STDMETHOD(GetBackingStore)(THIS_ UINT Index, D3D11_RASTERIZER_DESC *pRasterizerDesc) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectSamplerVariable ///////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

typedef interface ID3DX11EffectSamplerVariable ID3DX11EffectSamplerVariable;
typedef interface ID3DX11EffectSamplerVariable *LPD3D11EFFECTSAMPLERVARIABLE;

// {C6402E55-1095-4D95-8931-F92660513DD9}
DEFINE_GUID(IID_ID3DX11EffectSamplerVariable, 
            0xc6402e55, 0x1095, 0x4d95, 0x89, 0x31, 0xf9, 0x26, 0x60, 0x51, 0x3d, 0xd9);

#undef INTERFACE
#define INTERFACE ID3DX11EffectSamplerVariable

DECLARE_INTERFACE_(ID3DX11EffectSamplerVariable, ID3DX11EffectVariable)
{
    STDMETHOD_(ID3DX11EffectType*, GetType)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_VARIABLE_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetMemberBySemantic)(THIS_ LPCSTR Semantic) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetElement)(THIS_ UINT Index) PURE;
    
    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetParentConstantBuffer)(THIS) PURE;
    
    STDMETHOD_(ID3DX11EffectScalarVariable*, AsScalar)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectVectorVariable*, AsVector)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectMatrixVariable*, AsMatrix)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectStringVariable*, AsString)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectClassInstanceVariable*, AsClassInstance)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectInterfaceVariable*, AsInterface)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderResourceVariable*, AsShaderResource)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectUnorderedAccessViewVariable*, AsUnorderedAccessView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRenderTargetViewVariable*, AsRenderTargetView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilViewVariable*, AsDepthStencilView)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, AsConstantBuffer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectShaderVariable*, AsShader)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectBlendVariable*, AsBlend)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectDepthStencilVariable*, AsDepthStencil)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectRasterizerVariable*, AsRasterizer)(THIS) PURE;
    STDMETHOD_(ID3DX11EffectSamplerVariable*, AsSampler)(THIS) PURE;
    
    STDMETHOD(SetRawValue)(THIS_ CONST void *pData, UINT Offset, UINT Count) PURE;
    STDMETHOD(GetRawValue)(THIS_ void *pData, UINT Offset, UINT Count) PURE;
    
    STDMETHOD(GetSampler)(THIS_ UINT Index, ID3D11SamplerState **ppSampler) PURE;
    STDMETHOD(SetSampler)(THIS_ UINT Index, ID3D11SamplerState *pSampler) PURE;
    STDMETHOD(UndoSetSampler)(THIS_ UINT Index) PURE;
    STDMETHOD(GetBackingStore)(THIS_ UINT Index, D3D11_SAMPLER_DESC *pSamplerDesc) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectPass //////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
// D3DX11_PASS_DESC:
//
// Retrieved by ID3DX11EffectPass::GetDesc()
//----------------------------------------------------------------------------

typedef struct _D3DX11_PASS_DESC
{
    LPCSTR Name;                    // Name of this pass (NULL if not anonymous)    
    UINT Annotations;               // Number of annotations on this pass
    
    BYTE *pIAInputSignature;        // Signature from VS or GS (if there is no VS)
                                    // or NULL if neither exists
    SIZE_T IAInputSignatureSize;    // Singature size in bytes                                
                                    
    UINT StencilRef;                // Specified in SetDepthStencilState()
    UINT SampleMask;                // Specified in SetBlendState()
    FLOAT BlendFactor[4];           // Specified in SetBlendState()
} D3DX11_PASS_DESC;

//----------------------------------------------------------------------------
// D3DX11_PASS_SHADER_DESC:
//
// Retrieved by ID3DX11EffectPass::Get**ShaderDesc()
//----------------------------------------------------------------------------

typedef struct _D3DX11_PASS_SHADER_DESC
{
    ID3DX11EffectShaderVariable *pShaderVariable;    // The variable that this shader came from.
                                                    // If this is an inline shader assignment,
                                                    //   the returned interface will be an 
                                                    //   anonymous shader variable, which is
                                                    //   not retrievable any other way.  It's
                                                    //   name in the variable description will
                                                    //   be "$Anonymous".
                                                    // If there is no assignment of this type in
                                                    //   the pass block, pShaderVariable != NULL,
                                                    //   but pShaderVariable->IsValid() == FALSE.
    
    UINT                        ShaderIndex;        // The element of pShaderVariable (if an array)
                                                    // or 0 if not applicable
} D3DX11_PASS_SHADER_DESC;

typedef interface ID3DX11EffectPass ID3DX11EffectPass;
typedef interface ID3DX11EffectPass *LPD3D11EFFECTPASS;

// {3437CEC4-4AC1-4D87-8916-F4BD5A41380C}
DEFINE_GUID(IID_ID3DX11EffectPass, 
            0x3437cec4, 0x4ac1, 0x4d87, 0x89, 0x16, 0xf4, 0xbd, 0x5a, 0x41, 0x38, 0x0c);

#undef INTERFACE
#define INTERFACE ID3DX11EffectPass

DECLARE_INTERFACE(ID3DX11EffectPass)
{
    STDMETHOD_(BOOL, IsValid)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_PASS_DESC *pDesc) PURE;
    
    STDMETHOD(GetVertexShaderDesc)(THIS_ D3DX11_PASS_SHADER_DESC *pDesc) PURE;
    STDMETHOD(GetGeometryShaderDesc)(THIS_ D3DX11_PASS_SHADER_DESC *pDesc) PURE;
    STDMETHOD(GetPixelShaderDesc)(THIS_ D3DX11_PASS_SHADER_DESC *pDesc) PURE;
    STDMETHOD(GetHullShaderDesc)(THIS_ D3DX11_PASS_SHADER_DESC *pDesc) PURE;
    STDMETHOD(GetDomainShaderDesc)(THIS_ D3DX11_PASS_SHADER_DESC *pDesc) PURE;
    STDMETHOD(GetComputeShaderDesc)(THIS_ D3DX11_PASS_SHADER_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD(Apply)(THIS_ UINT Flags, ID3D11DeviceContext* pContext) PURE;
    
    STDMETHOD(ComputeStateBlockMask)(THIS_ D3DX11_STATE_BLOCK_MASK *pStateBlockMask) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectTechnique /////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
// D3DX11_TECHNIQUE_DESC:
//
// Retrieved by ID3DX11EffectTechnique::GetDesc()
//----------------------------------------------------------------------------

typedef struct _D3DX11_TECHNIQUE_DESC
{
    LPCSTR  Name;                   // Name of this technique (NULL if not anonymous)
    UINT    Passes;                 // Number of passes contained within
    UINT    Annotations;            // Number of annotations on this technique
} D3DX11_TECHNIQUE_DESC;

typedef interface ID3DX11EffectTechnique ID3DX11EffectTechnique;
typedef interface ID3DX11EffectTechnique *LPD3D11EFFECTTECHNIQUE;

// {51198831-1F1D-4F47-BD76-41CB0835B1DE}
DEFINE_GUID(IID_ID3DX11EffectTechnique, 
            0x51198831, 0x1f1d, 0x4f47, 0xbd, 0x76, 0x41, 0xcb, 0x08, 0x35, 0xb1, 0xde);

#undef INTERFACE
#define INTERFACE ID3DX11EffectTechnique

DECLARE_INTERFACE(ID3DX11EffectTechnique)
{
    STDMETHOD_(BOOL, IsValid)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_TECHNIQUE_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3DX11EffectPass*, GetPassByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectPass*, GetPassByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD(ComputeStateBlockMask)(THIS_ D3DX11_STATE_BLOCK_MASK *pStateBlockMask) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11EffectTechnique /////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
// D3DX11_GROUP_DESC:
//
// Retrieved by ID3DX11EffectTechnique::GetDesc()
//----------------------------------------------------------------------------

typedef struct _D3DX11_GROUP_DESC
{
    LPCSTR  Name;                   // Name of this group (only NULL if global)
    UINT    Techniques;             // Number of techniques contained within
    UINT    Annotations;            // Number of annotations on this group
} D3DX11_GROUP_DESC;

typedef interface ID3DX11EffectGroup ID3DX11EffectGroup;
typedef interface ID3DX11EffectGroup *LPD3D11EFFECTGROUP;

// {03074acf-97de-485f-b201-cb775264afd6}
DEFINE_GUID(IID_ID3DX11EffectGroup, 
            0x03074acf, 0x97de, 0x485f, 0xb2, 0x01, 0xcb, 0x77, 0x52, 0x64, 0xaf, 0xd6);

#undef INTERFACE
#define INTERFACE ID3DX11EffectGroup

DECLARE_INTERFACE(ID3DX11EffectGroup) 
{
    STDMETHOD_(BOOL, IsValid)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DX11_GROUP_DESC *pDesc) PURE;

    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetAnnotationByName)(THIS_ LPCSTR Name) PURE;

    STDMETHOD_(ID3DX11EffectTechnique*, GetTechniqueByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectTechnique*, GetTechniqueByName)(THIS_ LPCSTR Name) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// ID3DX11Effect //////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
// D3DX11_EFFECT_DESC:
//
// Retrieved by ID3DX11Effect::GetDesc()
//----------------------------------------------------------------------------

typedef struct _D3DX11_EFFECT_DESC
{
    UINT    ConstantBuffers;        // Number of constant buffers in this effect
    UINT    GlobalVariables;        // Number of global variables in this effect
    UINT    InterfaceVariables;     // Number of global interfaces in this effect
    UINT    Techniques;             // Number of techniques in this effect
    UINT    Groups;                 // Number of groups in this effect
} D3DX11_EFFECT_DESC;

typedef interface ID3DX11Effect ID3DX11Effect;
typedef interface ID3DX11Effect *LPD3D11EFFECT;

// {FA61CA24-E4BA-4262-9DB8-B132E8CAE319}
DEFINE_GUID(IID_ID3DX11Effect, 
            0xfa61ca24, 0xe4ba, 0x4262, 0x9d, 0xb8, 0xb1, 0x32, 0xe8, 0xca, 0xe3, 0x19);

#undef INTERFACE
#define INTERFACE ID3DX11Effect

DECLARE_INTERFACE_(ID3DX11Effect, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID iid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
    
    STDMETHOD_(BOOL, IsValid)(THIS) PURE;

    // Managing D3D Device
    STDMETHOD(GetDevice)(THIS_ ID3D11Device** ppDevice) PURE;
    
    // New Reflection APIs
    STDMETHOD(GetDesc)(THIS_ D3DX11_EFFECT_DESC *pDesc) PURE;
    
    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetConstantBufferByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectConstantBuffer*, GetConstantBufferByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3DX11EffectVariable*, GetVariableByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetVariableByName)(THIS_ LPCSTR Name) PURE;
    STDMETHOD_(ID3DX11EffectVariable*, GetVariableBySemantic)(THIS_ LPCSTR Semantic) PURE;
    
    STDMETHOD_(ID3DX11EffectGroup*, GetGroupByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectGroup*, GetGroupByName)(THIS_ LPCSTR Name) PURE;

    STDMETHOD_(ID3DX11EffectTechnique*, GetTechniqueByIndex)(THIS_ UINT Index) PURE;
    STDMETHOD_(ID3DX11EffectTechnique*, GetTechniqueByName)(THIS_ LPCSTR Name) PURE;
    
    STDMETHOD_(ID3D11ClassLinkage*, GetClassLinkage)(THIS) PURE;

    STDMETHOD(CloneEffect)(THIS_ UINT Flags, ID3DX11Effect** ppClonedEffect ) PURE;
    STDMETHOD(Optimize)(THIS) PURE;
    STDMETHOD_(BOOL, IsOptimized)(THIS) PURE;
};

//////////////////////////////////////////////////////////////////////////////
// APIs //////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

//----------------------------------------------------------------------------
// D3DX11CreateEffectFromMemory:
// --------------------------
// Creates an effect from a binary effect or file
//
// Parameters:
//
// [in]
//
//
//  pData
//      Blob of compiled effect data
//  DataLength
//      Length of the data blob
//  FXFlags
//      Compilation flags pertaining to Effect compilation, honored
//      by the Effect compiler
//  pDevice
//      Pointer to the D3D11 device on which to create Effect resources
//
// [out]
//
//  ppEffect
//      Address of the newly created Effect interface
//
//----------------------------------------------------------------------------

HRESULT WINAPI D3DX11CreateEffectFromMemory(CONST void *pData, SIZE_T DataLength, UINT FXFlags, ID3D11Device *pDevice, ID3DX11Effect **ppEffect);

#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3DX11EFFECT_H__


```

`Source Code/Effects11/Inc/d3dxGlobal.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       D3DXGlobal.h
//  Content:    D3DX11 Effects helper defines and data structures
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#pragma warning(disable : 4100 4127 4189 4201 4245 4389 4505 4701 4706)

namespace D3DX11Debug
{
}

using namespace D3DX11Debug;

#include "d3dx11dbg.h"

#define SAFE_RELEASE(p)       { if (p) { (p)->Release();  (p) = NULL; } }
#define SAFE_ADDREF(p)        { if (p) { (p)->AddRef();               } }

#define SAFE_DELETE_ARRAY(p)  { delete [](p); p = NULL; }
#define SAFE_DELETE(p)        { delete (p); p = NULL;  }

#if FXDEBUG
#define __BREAK_ON_FAIL       { __debugbreak(); }
#else
#define __BREAK_ON_FAIL 
#endif

#define VA(x, action) { hr = (x); if (FAILED(hr)) { action; __BREAK_ON_FAIL;                     return hr;  } }
#define VNA(x,action) {           if (!(x))       { action; __BREAK_ON_FAIL; hr = E_OUTOFMEMORY; goto lExit; } }
#define VBA(x,action) {           if (!(x))       { action; __BREAK_ON_FAIL; hr = E_FAIL;        goto lExit; } }
#define VHA(x,action) { hr = (x); if (FAILED(hr)) { action; __BREAK_ON_FAIL;                     goto lExit; } }

#define V(x)          { VA (x, 0) }
#define VN(x)         { VNA(x, 0) }
#define VB(x)         { VBA(x, 0) }
#define VH(x)         { VHA(x, 0) }

#define VBD(x,str)         { VBA(x, DPF(1,str)) }
#define VHD(x,str)         { VHA(x, DPF(1,str)) }

#define VEASSERT(x)   { hr = (x); if (FAILED(hr)) { __BREAK_ON_FAIL; D3DXASSERT(!#x);                     goto lExit; } }
#define VNASSERT(x)   {           if (!(x))       { __BREAK_ON_FAIL; D3DXASSERT(!#x); hr = E_OUTOFMEMORY; goto lExit; } }

#define ANALYSIS_ASSUME(x)      { D3DXASSERT(x); __analysis_assume(x); __assume(x); }

#define D3DX11FLTASSIGN(a,b)    { *reinterpret_cast< UINT32* >(&(a)) = *reinterpret_cast< UINT32* >(&(b)); }

// Preferred data alignment -- must be a power of 2!
static const UINT c_DataAlignment = sizeof(UINT_PTR);

D3DX11INLINE UINT AlignToPowerOf2(UINT Value, UINT Alignment)
{
    D3DXASSERT((Alignment & (Alignment - 1)) == 0);
    // to align to 2^N, add 2^N - 1 and AND with all but lowest N bits set
    ANALYSIS_ASSUME(Alignment > 0 && Value < MAXDWORD - Alignment);
    return (Value + Alignment - 1) & (~(Alignment - 1));
}

D3DX11INLINE void * AlignToPowerOf2(void *pValue, UINT_PTR Alignment)
{
    D3DXASSERT((Alignment & (Alignment - 1)) == 0);
    // to align to 2^N, add 2^N - 1 and AND with all but lowest N bits set
    return (void *)(((UINT_PTR)pValue + Alignment - 1) & (~((UINT_PTR)Alignment - 1)));
}


// Fast memcpy
D3DX11INLINE void dwordMemcpy( __out_bcount(uByteCount) void * __restrict pDest, __in_bcount(uByteCount) CONST void * __restrict pSource, UINT uByteCount)
{
    UINT i;
    D3DXASSERT(uByteCount % 4 == 0);
#ifdef _AMD64_
    const UINT qwordCount = uByteCount >> 3;

    __int64* src64 = (__int64*) pSource;
    __int64* dst64 = (__int64*) pDest;

    for (i=0; i<(qwordCount & 0x3); i++)
    {
        *(dst64) = *(src64);
        dst64++;
        src64++;
    }

    for (; i<qwordCount; i+= 4)
    {
        *(dst64     ) = *(src64     );
        *(dst64 + 1 ) = *(src64 + 1 );
        *(dst64 + 2 ) = *(src64 + 2 );
        *(dst64 + 3 ) = *(src64 + 3 );
        dst64 += 4;
        src64 += 4;
    }

    ANALYSIS_ASSUME( dst64 - static_cast< __int64* >(pDest) <= uByteCount - 4 );
    ANALYSIS_ASSUME( src64 - static_cast< const __int64* >(pSource) <= uByteCount - 4 );
    if( uByteCount & 0x4 )
    {
        *((UINT*)dst64) = *((UINT*)src64);
    }
#else
    const UINT dwordCount = uByteCount >> 2;

    for (i=0; i<(dwordCount & 0x3); i++)
    {
#pragma prefast(suppress: __WARNING_UNRELATED_LOOP_TERMINATION, "(dwordCount & 03) < dwordCount")
        ((UINT*)pDest)[i  ] = ((UINT*)pSource)[i  ];
    }
    for (; i<dwordCount; i+= 4)
    {
        ((UINT*)pDest)[i  ] = ((UINT*)pSource)[i  ];
        ((UINT*)pDest)[i+1] = ((UINT*)pSource)[i+1];
        ((UINT*)pDest)[i+2] = ((UINT*)pSource)[i+2];
        ((UINT*)pDest)[i+3] = ((UINT*)pSource)[i+3];
    }
#endif
}


namespace D3DX11Core
{

//////////////////////////////////////////////////////////////////////////
// CMemoryStream - A class to simplify reading binary data
//////////////////////////////////////////////////////////////////////////
class CMemoryStream
{
    BYTE    *m_pData;
    SIZE_T  m_cbData;
    SIZE_T  m_readPtr;

public:
    HRESULT SetData(const void *pData, SIZE_T size);

    HRESULT Read(UINT *pUint);
    HRESULT Read(void **ppData, SIZE_T size);
    HRESULT Read(LPCSTR *ppString);

    HRESULT ReadAtOffset(SIZE_T offset, SIZE_T size, void **ppData);
    HRESULT ReadAtOffset(SIZE_T offset, LPCSTR *ppString);

    SIZE_T  GetPosition();
    HRESULT Seek(SIZE_T offset);

    CMemoryStream();
    ~CMemoryStream();
};

}

#if FXDEBUG

namespace D3DX11Debug
{

// This variable indicates how many ticks to go before rolling over
// all of the timer variables in the FX system.
// It is read from the system registry in debug builds; in retail the high bit is simply tested.

_declspec(selectany) unsigned int g_TimerRolloverCount = 0x80000000;
}

#endif // FXDEBUG


//////////////////////////////////////////////////////////////////////////
// CEffectVector - A vector implementation
//////////////////////////////////////////////////////////////////////////

template<class T> class CEffectVector
{
protected:
#if _DEBUG
    T       *m_pCastData; // makes debugging easier to have a casted version of the data
#endif // _DEBUG

    BYTE    *m_pData;
    UINT    m_MaxSize;
    UINT    m_CurSize;

    HRESULT Grow()
    {
        return Reserve(m_CurSize + 1);
    }

    HRESULT Reserve(UINT DesiredSize)
    {
        if (DesiredSize > m_MaxSize)
        {
            BYTE *pNewData;
            UINT newSize = max(m_MaxSize * 2, DesiredSize);

            if (newSize < 16)
                newSize = 16;

            if ((newSize < m_MaxSize) || (newSize < m_CurSize) || (newSize >= UINT_MAX / sizeof(T)))
            {
                m_hLastError = E_OUTOFMEMORY;
                return m_hLastError;
            }

            pNewData = NEW BYTE[newSize * sizeof(T)];
            if (pNewData == NULL)
            {
                m_hLastError = E_OUTOFMEMORY;
                return m_hLastError;
            }

            if (m_pData)
            {
                memcpy(pNewData, m_pData, m_CurSize * sizeof(T));
                delete []m_pData;
            }

            m_pData = pNewData;
            m_MaxSize = newSize;
        }
#if _DEBUG
        m_pCastData = (T*) m_pData;
#endif // _DEBUG
        return S_OK;
    }

public:
    HRESULT m_hLastError;

    CEffectVector<T>()
    {
        m_hLastError = S_OK;
#if _DEBUG
        m_pCastData = NULL;
#endif // _DEBUG
        m_pData = NULL;
        m_CurSize = m_MaxSize = 0;
    }

    ~CEffectVector<T>()
    {
        Clear();
    }

    // cleanly swaps two vectors -- useful for when you want
    // to reallocate a vector and copy data over, then swap them back
    void SwapVector(CEffectVector<T> &vOther)
    {
        BYTE tempData[sizeof(*this)];

        memcpy(tempData, this, sizeof(*this));
        memcpy(this, &vOther, sizeof(*this));
        memcpy(&vOther, tempData, sizeof(*this));
    }

    HRESULT CopyFrom(CEffectVector<T> &vOther)
    {
        HRESULT hr = S_OK;
        Clear();
        VN( m_pData = NEW BYTE[vOther.m_MaxSize * sizeof(T)] );
        
        m_CurSize = vOther.m_CurSize;
        m_MaxSize = vOther.m_MaxSize;
        m_hLastError = vOther.m_hLastError;

        UINT i;
        for (i = 0; i < m_CurSize; ++ i)
        {
            ((T*)m_pData)[i] = ((T*)vOther.m_pData)[i];
        }

lExit:

#if _DEBUG
        m_pCastData = (T*) m_pData;
#endif // _DEBUG

        return hr;
    }

    void Clear()
    {
        Empty();
        SAFE_DELETE_ARRAY(m_pData);
        m_MaxSize = 0;
#if _DEBUG
        m_pCastData = NULL;
#endif // _DEBUG
    }

    void ClearWithoutDestructor()
    {
        m_CurSize = 0;
        m_hLastError = S_OK;
        SAFE_DELETE_ARRAY(m_pData);
        m_MaxSize = 0;

#if _DEBUG
        m_pCastData = NULL;
#endif // _DEBUG
    }

    void Empty()
    {
        UINT i;
        
        // manually invoke destructor on all elements
        for (i = 0; i < m_CurSize; ++ i)
        {   
            ((T*)m_pData + i)->~T();
        }
        m_CurSize = 0;
        m_hLastError = S_OK;
    }

    T* Add()
    {
        if (FAILED(Grow()))
            return NULL;

        // placement new
        return new((T*)m_pData + (m_CurSize ++)) T;
    }

    T* AddRange(UINT count)
    {
        if (m_CurSize + count < m_CurSize)
        {
            m_hLastError = E_OUTOFMEMORY;
            return NULL;
        }

        if (FAILED(Reserve(m_CurSize + count)))
            return NULL;

        T *pData = (T*)m_pData + m_CurSize;
        UINT i;
        for (i = 0; i < count; ++ i)
        {
            new(pData + i) T;
        }
        m_CurSize += count;
        return pData;
    }

    HRESULT Add(const T& var)
    {
        if (FAILED(Grow()))
            return m_hLastError;

        memcpy((T*)m_pData + m_CurSize, &var, sizeof(T));
        m_CurSize++;

        return S_OK;
    }

    HRESULT AddRange(const T *pVar, UINT count)
    {
        if (m_CurSize + count < m_CurSize)
        {
            m_hLastError = E_OUTOFMEMORY;
            return m_hLastError;
        }

        if (FAILED(Reserve(m_CurSize + count)))
            return m_hLastError;

        memcpy((T*)m_pData + m_CurSize, pVar, count * sizeof(T));
        m_CurSize += count;

        return S_OK;
    }

    HRESULT Insert(const T& var, UINT index)
    {
        D3DXASSERT(index < m_CurSize);
        
        if (FAILED(Grow()))
            return m_hLastError;

        memmove((T*)m_pData + index + 1, (T*)m_pData + index, (m_CurSize - index) * sizeof(T));
        memcpy((T*)m_pData + index, &var, sizeof(T));
        m_CurSize++;

        return S_OK;
    }

    HRESULT InsertRange(const T *pVar, UINT index, UINT count)
    {
        D3DXASSERT(index < m_CurSize);
        
        if (m_CurSize + count < m_CurSize)
        {
            m_hLastError = E_OUTOFMEMORY;
            return m_hLastError;
        }

        if (FAILED(Reserve(m_CurSize + count)))
            return m_hLastError;

        memmove((T*)m_pData + index + count, (T*)m_pData + index, (m_CurSize - index) * sizeof(T));
        memcpy((T*)m_pData + index, pVar, count * sizeof(T));
        m_CurSize += count;

        return S_OK;
    }

    inline T& operator[](UINT index)
    {
        D3DXASSERT(index < m_CurSize);
        return ((T*)m_pData)[index];
    }

    // Deletes element at index and shifts all other values down
    void Delete(UINT index)
    {
        D3DXASSERT(index < m_CurSize);

        -- m_CurSize;
        memmove((T*)m_pData + index, (T*)m_pData + index + 1, (m_CurSize - index) * sizeof(T));
    }

    // Deletes element at index and moves the last element into its place
    void QuickDelete(UINT index)
    {
        D3DXASSERT(index < m_CurSize);

        -- m_CurSize;
        memcpy((T*)m_pData + index, (T*)m_pData + m_CurSize, sizeof(T));
    }

    inline UINT GetSize() const
    {
        return m_CurSize;
    }

    inline T* GetData() const
    {
        return (T*)m_pData;
    }

    UINT FindIndexOf(void *pEntry) const
    {
        UINT i;

        for (i = 0; i < m_CurSize; ++ i)
        {   
            if (((T*)m_pData + i) == pEntry)
                return i;
        }

        return -1;
    }

    void Sort(int (__cdecl *pfnCompare)(const void *pElem1, const void *pElem2))
    {
        qsort(m_pData, m_CurSize, sizeof(T), pfnCompare);
    }
};

//////////////////////////////////////////////////////////////////////////
// CEffectVectorOwner - implements a vector of ptrs to objects. The vector owns the objects.
//////////////////////////////////////////////////////////////////////////
template<class T> class CEffectVectorOwner : public CEffectVector<T*>
{
public:
    ~CEffectVectorOwner<T>()
    {
        Clear();
        UINT i;

        for (i=0; i<m_CurSize; i++)
            SAFE_DELETE(((T**)m_pData)[i]);

        SAFE_DELETE_ARRAY(m_pData);
    }

    void Clear()
    {
        Empty();
        SAFE_DELETE_ARRAY(m_pData);
        m_MaxSize = 0;
    }

    void Empty()
    {
        UINT i;

        // manually invoke destructor on all elements
        for (i = 0; i < m_CurSize; ++ i)
        {
            SAFE_DELETE(((T**)m_pData)[i]);
        }
        m_CurSize = 0;
        m_hLastError = S_OK;
    }

    void Delete(UINT index)
    {
        D3DXASSERT(index < m_CurSize);

        SAFE_DELETE(((T**)m_pData)[index]);

        CEffectVector<T*>::Delete(index);
    }
};


//////////////////////////////////////////////////////////////////////////
// Checked UINT, DWORD64
// Use CheckedNumber only with UINT and DWORD64
//////////////////////////////////////////////////////////////////////////
template <class T, T MaxValue> class CheckedNumber
{
    T       m_Value;
    BOOL    m_bValid;

public:
    CheckedNumber<T, MaxValue>()
    {
        m_Value = 0;
        m_bValid = TRUE;
    }

    CheckedNumber<T, MaxValue>(const T &value)
    {
        m_Value = value;
        m_bValid = TRUE;
    }

    CheckedNumber<T, MaxValue>(const CheckedNumber<T, MaxValue> &value)
    {
        m_bValid = value.m_bValid;
        m_Value = value.m_Value;
    }

    CheckedNumber<T, MaxValue> &operator+(const CheckedNumber<T, MaxValue> &other)
    {
        CheckedNumber<T, MaxValue> Res(*this);
        return Res+=other;
    }

    CheckedNumber<T, MaxValue> &operator+=(const CheckedNumber<T, MaxValue> &other)
    {
        if (!other.m_bValid)
        {
            m_bValid = FALSE;
        }
        else
        {
            m_Value += other.m_Value;

            if (m_Value < other.m_Value)
                m_bValid = FALSE;
        }

        return *this;
    }

    CheckedNumber<T, MaxValue> &operator*(const CheckedNumber<T, MaxValue> &other)
    {
        CheckedNumber<T, MaxValue> Res(*this);
        return Res*=other;
    }

    CheckedNumber<T, MaxValue> &operator*=(const CheckedNumber<T, MaxValue> &other)
    {
        if (!other.m_bValid)
        {
            m_bValid = FALSE;
        }
        else
        {
            if (other.m_Value != 0)
            {
                if (m_Value > MaxValue / other.m_Value)
                {
                    m_bValid = FALSE;
                }
            }
            m_Value *= other.m_Value;
        }

        return *this;
    }

    HRESULT GetValue(T *pValue)
    {
        if (!m_bValid)
        {
            *pValue = -1;
            return E_FAIL;
        }

        *pValue = m_Value;
        return S_OK;
    }
};

typedef CheckedNumber<UINT, _UI32_MAX> CCheckedDword;
typedef CheckedNumber<DWORD64, _UI64_MAX> CCheckedDword64;


//////////////////////////////////////////////////////////////////////////
// Data Block Store - A linked list of allocations
//////////////////////////////////////////////////////////////////////////

class CDataBlock
{
protected:
    UINT        m_size;
    UINT        m_maxSize;
    BYTE        *m_pData;
    CDataBlock  *m_pNext;

    BOOL        m_IsAligned;        // Whether or not to align the data to c_DataAlignment

public:
    // AddData appends an existing use buffer to the data block
    HRESULT AddData(const void *pNewData, UINT bufferSize, CDataBlock **ppBlock);

    // Allocate reserves bufferSize bytes of contiguous memory and returns a pointer to the user
    void*   Allocate(UINT bufferSize, CDataBlock **ppBlock);

    void    EnableAlignment();

    CDataBlock();
    ~CDataBlock();

    friend class CDataBlockStore;
};


class CDataBlockStore
{
protected:
    CDataBlock  *m_pFirst;
    CDataBlock  *m_pLast;
    UINT        m_Size;
    UINT        m_Offset;           // m_Offset gets added to offsets returned from AddData & AddString. Use this to set a global for the entire string block
    BOOL        m_IsAligned;        // Whether or not to align the data to c_DataAlignment

public:
#if _DEBUG
    UINT		m_cAllocations;
#endif

public:
    HRESULT AddString(LPCSTR pString, UINT *pOffset);                          // Writes a null-terminated string to buffer
    HRESULT AddData(const void *pNewData, UINT bufferSize, UINT *pOffset);     // Writes data block to buffer

    void*   Allocate(UINT buffferSize);                                        // Memory allocator support
    UINT    GetSize();
    void    EnableAlignment();

    CDataBlockStore();
    ~CDataBlockStore();
};

// Custom allocator that uses CDataBlockStore
// The trick is that we never free, so we don't have to keep as much state around
// Use PRIVATENEW in CEffectLoader

inline void* __cdecl operator new(size_t s, CDataBlockStore &pAllocator)
{
    D3DXASSERT( s <= 0xffffffff );
    return pAllocator.Allocate( (UINT)s );
}

inline void __cdecl operator delete(void* p, CDataBlockStore &pAllocator)
{
}


//////////////////////////////////////////////////////////////////////////
// Hash table
//////////////////////////////////////////////////////////////////////////

#define HASH_MIX(a,b,c) \
{ \
    a -= b; a -= c; a ^= (c>>13); \
    b -= c; b -= a; b ^= (a<<8); \
    c -= a; c -= b; c ^= (b>>13); \
    a -= b; a -= c; a ^= (c>>12);  \
    b -= c; b -= a; b ^= (a<<16); \
    c -= a; c -= b; c ^= (b>>5); \
    a -= b; a -= c; a ^= (c>>3);  \
    b -= c; b -= a; b ^= (a<<10); \
    c -= a; c -= b; c ^= (b>>15); \
}

static UINT ComputeHash(BYTE *pb, UINT cbToHash)
{
    UINT a;
    UINT b;
    UINT c;
    UINT cbLeft;

    cbLeft = cbToHash;

    a = b = 0x9e3779b9; // the golden ratio; an arbitrary value
    c = 0;

    while (cbLeft >= 12)
    {
        UINT *pdw = reinterpret_cast<UINT *>(pb);

        a += pdw[0];
        b += pdw[1];
        c += pdw[2];

        HASH_MIX(a,b,c);
        pb += 12; 
        cbLeft -= 12;
    }

    c += cbToHash;

    switch(cbLeft) // all the case statements fall through
    {
    case 11: c+=((UINT) pb[10] << 24);
    case 10: c+=((UINT) pb[9]  << 16);
    case 9 : c+=((UINT) pb[8]  <<  8);
        // the first byte of c is reserved for the length
    case 8 : b+=((UINT) pb[7]  << 24);
    case 7 : b+=((UINT) pb[6]  << 16);
    case 6 : b+=((UINT) pb[5]  <<  8);
    case 5 : b+=pb[4];
    case 4 : a+=((UINT) pb[3]  << 24);
    case 3 : a+=((UINT) pb[2]  << 16);
    case 2 : a+=((UINT) pb[1]  <<  8);
    case 1 : a+=pb[0];
    }

    HASH_MIX(a,b,c);

    return c;
}

static UINT ComputeHashLower(BYTE *pb, UINT cbToHash)
{
    UINT a;
    UINT b;
    UINT c;
    UINT cbLeft;

    cbLeft = cbToHash;

    a = b = 0x9e3779b9; // the golden ratio; an arbitrary value
    c = 0;

    while (cbLeft >= 12)
    {
        BYTE pbT[12];
        for( UINT i = 0; i < 12; i++ )
            pbT[i] = (BYTE)tolower(pb[i]);

        UINT *pdw = reinterpret_cast<UINT *>(pbT);

        a += pdw[0];
        b += pdw[1];
        c += pdw[2];

        HASH_MIX(a,b,c);
        pb += 12; 
        cbLeft -= 12;
    }

    c += cbToHash;

    BYTE pbT[12];
    for( UINT i = 0; i < cbLeft; i++ )
        pbT[i] = (BYTE)tolower(pb[i]);

    switch(cbLeft) // all the case statements fall through
    {
    case 11: c+=((UINT) pbT[10] << 24);
    case 10: c+=((UINT) pbT[9]  << 16);
    case 9 : c+=((UINT) pbT[8]  <<  8);
        // the first byte of c is reserved for the length
    case 8 : b+=((UINT) pbT[7]  << 24);
    case 7 : b+=((UINT) pbT[6]  << 16);
    case 6 : b+=((UINT) pbT[5]  <<  8);
    case 5 : b+=pbT[4];
    case 4 : a+=((UINT) pbT[3]  << 24);
    case 3 : a+=((UINT) pbT[2]  << 16);
    case 2 : a+=((UINT) pbT[1]  <<  8);
    case 1 : a+=pbT[0];
    }

    HASH_MIX(a,b,c);

    return c;
}


static UINT ComputeHash(LPCSTR pString)
{
    return ComputeHash((BYTE*) pString, (UINT)strlen(pString));
}


// 1) these numbers are prime
// 2) each is slightly less than double the last
// 4) each is roughly in between two powers of 2;
//    (2^n hash table sizes are VERY BAD; they effectively truncate your
//     precision down to the n least significant bits of the hash)
static const UINT c_PrimeSizes[] = 
{
    11,
    23,
    53,
    97,
    193,
    389,
    769,
    1543,
    3079,
    6151,
    12289,
    24593,
    49157,
    98317,
    196613,
    393241,
    786433,
    1572869,
    3145739,
    6291469,
    12582917,
    25165843,
    50331653,
    100663319,
    201326611,
    402653189,
    805306457,
    1610612741,
};

static const UINT c_NumPrimes = sizeof(c_PrimeSizes) / sizeof(UINT);

template<typename T, BOOL (*pfnIsEqual)(const T &Data1, const T &Data2)>
class CEffectHashTable
{
protected:

    struct SHashEntry
    {
        UINT        Hash;
        T           Data;
        SHashEntry  *pNext;
    };

    // Array of hash entries
    SHashEntry  **m_rgpHashEntries;
    UINT        m_NumHashSlots;
    UINT        m_NumEntries;
    bool        m_bOwnHashEntryArray;

public:
    class CIterator
    {
        friend class CEffectHashTable;

    protected:
        SHashEntry **ppHashSlot;
        SHashEntry *pHashEntry;

    public:
        T GetData()
        {
            D3DXASSERT(NULL != pHashEntry);
            return pHashEntry->Data;
        }

        UINT GetHash()
        {
            D3DXASSERT(NULL != pHashEntry);
            return pHashEntry->Hash;
        }
    };

    CEffectHashTable()
    {
        m_rgpHashEntries = NULL;
        m_NumHashSlots = 0;
        m_NumEntries = 0;
        m_bOwnHashEntryArray = false;
    }

    HRESULT Initialize(CEffectHashTable *pOther)
    {
        HRESULT hr = S_OK;
        SHashEntry **rgpNewHashEntries = NULL;
        SHashEntry ***rgppListEnds = NULL;
        UINT i;
        UINT valuesMigrated = 0;
        UINT actualSize;

        Cleanup();

        actualSize = pOther->m_NumHashSlots;
        VN( rgpNewHashEntries = NEW SHashEntry*[actualSize] );

        ZeroMemory(rgpNewHashEntries, sizeof(SHashEntry*) * actualSize);

        // Expensive operation: rebuild the hash table
        CIterator iter, nextIter;
        pOther->GetFirstEntry(&iter);
        while (!pOther->PastEnd(&iter))
        {
            UINT index = iter.GetHash() % actualSize;

            // we need to advance to the next element
            // before we seize control of this element and move
            // it to the new table
            nextIter = iter;
            pOther->GetNextEntry(&nextIter);

            // seize this hash entry, migrate it to the new table
            SHashEntry *pNewEntry;
            VN( pNewEntry = NEW SHashEntry );
            
            pNewEntry->pNext = rgpNewHashEntries[index];
            pNewEntry->Data = iter.pHashEntry->Data;
            pNewEntry->Hash = iter.pHashEntry->Hash;
            rgpNewHashEntries[index] = pNewEntry;

            iter = nextIter;
            ++ valuesMigrated;
        }

        D3DXASSERT(valuesMigrated == pOther->m_NumEntries);

        m_rgpHashEntries = rgpNewHashEntries;
        m_NumHashSlots = actualSize;
        m_NumEntries = pOther->m_NumEntries;
        m_bOwnHashEntryArray = true;
        rgpNewHashEntries = NULL;

lExit:
        SAFE_DELETE_ARRAY( rgpNewHashEntries );
        return hr;
    }

protected:
    void CleanArray()
    {
        if (m_bOwnHashEntryArray)
        {
            SAFE_DELETE_ARRAY(m_rgpHashEntries);
            m_bOwnHashEntryArray = false;
        }
    }

public:
    void Cleanup()
    {
        UINT i;
        for (i = 0; i < m_NumHashSlots; ++ i)
        {
            SHashEntry *pCurrentEntry = m_rgpHashEntries[i];
            SHashEntry *pTempEntry;
            while (NULL != pCurrentEntry)
            {
                pTempEntry = pCurrentEntry->pNext;
                SAFE_DELETE(pCurrentEntry);
                pCurrentEntry = pTempEntry;
                -- m_NumEntries;
            }
        }
        CleanArray();
        m_NumHashSlots = 0;
        D3DXASSERT(m_NumEntries == 0);
    }

    ~CEffectHashTable()
    {
        Cleanup();
    }

    static UINT GetNextHashTableSize(__in UINT DesiredSize)
    {
        // figure out the next logical size to use
        for (UINT i = 0; i < c_NumPrimes; ++ i)
        {
            if (c_PrimeSizes[i] >= DesiredSize)
            {
                return c_PrimeSizes[i];
            }
        }

        return DesiredSize;
    }
    
    // O(n) function
    // Grows to the next suitable size (based off of the prime number table)
    // DesiredSize is merely a suggestion
    HRESULT Grow(__in UINT DesiredSize,
                 __in UINT ProvidedArraySize = 0,
                 __in_ecount_opt(ProvidedArraySize)
                 void** ProvidedArray = NULL,
                 __in bool OwnProvidedArray = false)
    {
        HRESULT hr = S_OK;
        SHashEntry **rgpNewHashEntries = NULL;
        SHashEntry ***rgppListEnds = NULL;
        UINT valuesMigrated = 0;
        UINT actualSize;

        VB( DesiredSize > m_NumHashSlots );

        actualSize = GetNextHashTableSize(DesiredSize);

        if (ProvidedArray &&
            ProvidedArraySize >= actualSize)
        {
            rgpNewHashEntries = reinterpret_cast<SHashEntry**>(ProvidedArray);
        }
        else
        {
            OwnProvidedArray = true;
            
            VN( rgpNewHashEntries = NEW SHashEntry*[actualSize] );
        }
        
        ZeroMemory(rgpNewHashEntries, sizeof(SHashEntry*) * actualSize);

        // Expensive operation: rebuild the hash table
        CIterator iter, nextIter;
        GetFirstEntry(&iter);
        while (!PastEnd(&iter))
        {
            UINT index = iter.GetHash() % actualSize;

            // we need to advance to the next element
            // before we seize control of this element and move
            // it to the new table
            nextIter = iter;
            GetNextEntry(&nextIter);

            // seize this hash entry, migrate it to the new table
            iter.pHashEntry->pNext = rgpNewHashEntries[index];
            rgpNewHashEntries[index] = iter.pHashEntry;

            iter = nextIter;
            ++ valuesMigrated;
        }

        D3DXASSERT(valuesMigrated == m_NumEntries);

        CleanArray();
        m_rgpHashEntries = rgpNewHashEntries;
        m_NumHashSlots = actualSize;
        m_bOwnHashEntryArray = OwnProvidedArray;

lExit:
        return hr;
    }

    HRESULT AutoGrow()
    {
        // arbitrary heuristic -- grow if 1:1
        if (m_NumEntries >= m_NumHashSlots)
        {
            // grows this hash table so that it is roughly 50% full
            return Grow(m_NumEntries * 2 + 1);
        }
        return S_OK;
    }

#if _DEBUG
    void PrintHashTableStats()
    {
        if (m_NumHashSlots == 0)
        {
            DPF(0, "Uninitialized hash table!");
            return;
        }
        
        UINT i;
        float variance = 0.0f;
        float mean = (float)m_NumEntries / (float)m_NumHashSlots;
        UINT unusedSlots = 0;

        DPF(0, "Hash table slots: %d, Entries in table: %d", m_NumHashSlots, m_NumEntries);

        for (i = 0; i < m_NumHashSlots; ++ i)
        {
            UINT entries = 0;
            SHashEntry *pCurrentEntry = m_rgpHashEntries[i];

            while (NULL != pCurrentEntry)
            {
                SHashEntry *pCurrentEntry2 = m_rgpHashEntries[i];
                
                // check other hash entries in this slot for hash collisions or duplications
                while (pCurrentEntry2 != pCurrentEntry)
                {
                    if (pCurrentEntry->Hash == pCurrentEntry2->Hash)
                    {
                        if (pfnIsEqual(pCurrentEntry->Data, pCurrentEntry2->Data))
                        {
                            D3DXASSERT(0);
                            DPF(0, "Duplicate entry (identical hash, identical data) found!");
                        }
                        else
                        {
                            DPF(0, "Hash collision (hash: %d)", pCurrentEntry->Hash);
                        }
                    }
                    pCurrentEntry2 = pCurrentEntry2->pNext;
                }

                pCurrentEntry = pCurrentEntry->pNext;
                ++ entries;
            }

            if (0 == entries)
            {
                ++ unusedSlots;
            }
            
            // mean must be greater than 0 at this point
            variance += (float)entries * (float)entries / mean;
        }

        variance /= max(1.0f, (m_NumHashSlots - 1));
        variance -= (mean * mean);

        DPF(0, "Mean number of entries per slot: %f, Standard deviation: %f, Unused slots; %d", mean, variance, unusedSlots);
    }
#endif // _DEBUG

    // S_OK if element is found, E_FAIL otherwise
    HRESULT FindValueWithHash(T Data, UINT Hash, CIterator *pIterator)
    {
        D3DXASSERT(m_NumHashSlots > 0);

        UINT index = Hash % m_NumHashSlots;
        SHashEntry *pEntry = m_rgpHashEntries[index];
        while (NULL != pEntry)
        {
            if (Hash == pEntry->Hash && pfnIsEqual(pEntry->Data, Data))
            {
                pIterator->ppHashSlot = m_rgpHashEntries + index;
                pIterator->pHashEntry = pEntry;
                return S_OK;
            }
            pEntry = pEntry->pNext;
        }
        return E_FAIL;
    }

    // S_OK if element is found, E_FAIL otherwise
    HRESULT FindFirstMatchingValue(UINT Hash, CIterator *pIterator)
    {
        D3DXASSERT(m_NumHashSlots > 0);

        UINT index = Hash % m_NumHashSlots;
        SHashEntry *pEntry = m_rgpHashEntries[index];
        while (NULL != pEntry)
        {
            if (Hash == pEntry->Hash)
            {
                pIterator->ppHashSlot = m_rgpHashEntries + index;
                pIterator->pHashEntry = pEntry;
                return S_OK;
            }
            pEntry = pEntry->pNext;
        }
        return E_FAIL;
    }

    // Adds data at the specified hash slot without checking for existence
    HRESULT AddValueWithHash(T Data, UINT Hash)
    {
        HRESULT hr = S_OK;

        D3DXASSERT(m_NumHashSlots > 0);

        SHashEntry *pHashEntry;
        UINT index = Hash % m_NumHashSlots;

        VN( pHashEntry = NEW SHashEntry );
        pHashEntry->pNext = m_rgpHashEntries[index];
        pHashEntry->Data = Data;
        pHashEntry->Hash = Hash;
        m_rgpHashEntries[index] = pHashEntry;

        ++ m_NumEntries;

lExit:
        return hr;
    }

    // Iterator code:
    //
    // CMyHashTable::CIterator myIt;
    // for (myTable.GetFirstEntry(&myIt); !myTable.PastEnd(&myIt); myTable.GetNextEntry(&myIt)
    // { myTable.GetData(&myIt); }
    void GetFirstEntry(CIterator *pIterator)
    {
        SHashEntry **ppEnd = m_rgpHashEntries + m_NumHashSlots;
        pIterator->ppHashSlot = m_rgpHashEntries;
        while (pIterator->ppHashSlot < ppEnd)
        {
            if (NULL != *(pIterator->ppHashSlot))
            {
                pIterator->pHashEntry = *(pIterator->ppHashSlot);
                return;
            }
            ++ pIterator->ppHashSlot;
        }
    }

    BOOL PastEnd(CIterator *pIterator)
    {
        SHashEntry **ppEnd = m_rgpHashEntries + m_NumHashSlots;
        D3DXASSERT(pIterator->ppHashSlot >= m_rgpHashEntries && pIterator->ppHashSlot <= ppEnd);
        return (pIterator->ppHashSlot == ppEnd);
    }

    void GetNextEntry(CIterator *pIterator)
    {
        SHashEntry **ppEnd = m_rgpHashEntries + m_NumHashSlots;
        D3DXASSERT(pIterator->ppHashSlot >= m_rgpHashEntries && pIterator->ppHashSlot <= ppEnd);
        D3DXASSERT(NULL != pIterator->pHashEntry);

        pIterator->pHashEntry = pIterator->pHashEntry->pNext;
        if (NULL != pIterator->pHashEntry)
        {
            return;
        }

        ++ pIterator->ppHashSlot;
        while (pIterator->ppHashSlot < ppEnd)
        {
            pIterator->pHashEntry = *(pIterator->ppHashSlot);
            if (NULL != pIterator->pHashEntry)
            {
                return;
            }
            ++ pIterator->ppHashSlot;
        }
        // hit the end of the list, ppHashSlot == ppEnd
    }

    void RemoveEntry(CIterator *pIterator)
    {
        SHashEntry *pTemp;
        SHashEntry **ppPrev;
        SHashEntry **ppEnd = m_rgpHashEntries + m_NumHashSlots;

        D3DXASSERT(pIterator && !PastEnd(pIterator));
        ppPrev = pIterator->ppHashSlot;
        pTemp = *ppPrev;
        while (pTemp)
        {
            if (pTemp == pIterator->pHashEntry)
            {
                *ppPrev = pTemp->pNext;
                pIterator->ppHashSlot = ppEnd;
                delete pTemp;
                return;
            }
            ppPrev = &pTemp->pNext;
            pTemp = pTemp->pNext;
        }

        // Should never get here
        D3DXASSERT(0);
    }

};

// Allocates the hash slots on the regular heap (since the
// hash table can grow), but all hash entries are allocated on
// a private heap

template<typename T, BOOL (*pfnIsEqual)(const T &Data1, const T &Data2)>
class CEffectHashTableWithPrivateHeap : public CEffectHashTable<T, pfnIsEqual>
{
protected:
    CDataBlockStore *m_pPrivateHeap;

public:
    CEffectHashTableWithPrivateHeap()
    {
        m_pPrivateHeap = NULL;
    }

    void Cleanup()
    {
        CleanArray();
        m_NumHashSlots = 0;
        m_NumEntries = 0;
    }

    ~CEffectHashTableWithPrivateHeap()
    {
        Cleanup();
    }

    // Call this only once
    void SetPrivateHeap(CDataBlockStore *pPrivateHeap)
    {
        D3DXASSERT(NULL == m_pPrivateHeap);
        m_pPrivateHeap = pPrivateHeap;
    }

    // Adds data at the specified hash slot without checking for existence
    HRESULT AddValueWithHash(T Data, UINT Hash)
    {
        HRESULT hr = S_OK;

        D3DXASSERT(NULL != m_pPrivateHeap);
        D3DXASSERT(m_NumHashSlots > 0);

        SHashEntry *pHashEntry;
        UINT index = Hash % m_NumHashSlots;

        VN( pHashEntry = new(*m_pPrivateHeap) SHashEntry );
        pHashEntry->pNext = m_rgpHashEntries[index];
        pHashEntry->Data = Data;
        pHashEntry->Hash = Hash;
        m_rgpHashEntries[index] = pHashEntry;

        ++ m_NumEntries;

lExit:
        return hr;
    }
};

```

`Source Code/Effects11/d3dx11dbg.cpp`:

```cpp
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx11dbg.cpp
//  Content:    D3DX11 Effects debugging functions
//
///////////////////////////////////////////////////////////////////////////

#include "pchfx.h"


#ifdef FXDPF

//
// DPF
//

void cdecl D3DXDebugPrintf(UINT lvl, LPCSTR szFormat, ...)
{
    static UINT uDebugLevel = (UINT) -1;

    char strA[4096];
    char strB[4096];

    va_list ap;
    va_start(ap, szFormat);
    StringCchVPrintfA(strA, sizeof(strA), szFormat, ap);
    strA[4095] = '\0';
    va_end(ap);

    StringCchPrintfA(strB, sizeof(strB), "Effects11: %s\r\n", strA);

    strB[4095] = '\0';

    OutputDebugStringA(strB);
}
#else
// This is defined so warning LNK4211 is not generated (object file has no public symbols)
void cdecl D3DXDebugPrintf(UINT lvl, LPCSTR szFormat, ...) {}
#endif


//
// D3DXASSERT
//

#ifdef _DEBUG

int WINAPI D3DXDebugAssert(LPCSTR szFile, int nLine, LPCSTR szCondition)
{
    char str[512];

    // Print message to debug console
    StringCchPrintfA(str, sizeof(str), "Assertion failure! (%s %d): %s\r\n", szFile, nLine, szCondition);
    str[511] = 0;
    OutputDebugStringA(str);

    return 0;
}
#endif


```

`Source Code/Effects11/d3dxGlobal.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxGlobal.cpp
//  Content:    D3DX11 Effects implementation for helper data structures
//
//////////////////////////////////////////////////////////////////////////////

#include "pchfx.h"
#include <intsafe.h>

namespace D3DX11Core
{

//////////////////////////////////////////////////////////////////////////
// CMemoryStream - A class to simplify reading binary data
//////////////////////////////////////////////////////////////////////////

CMemoryStream::CMemoryStream()
{
    m_pData = NULL;
    m_cbData = 0;
    m_readPtr = 0;
}

CMemoryStream::~CMemoryStream()
{
}

HRESULT CMemoryStream::SetData(const void *pData, SIZE_T size)
{
    m_pData = (BYTE*) pData;
    m_cbData = size;
    m_readPtr = 0;

    return S_OK;
}

HRESULT CMemoryStream::ReadAtOffset(SIZE_T offset, SIZE_T size, void **ppData)
{
    if (offset >= m_cbData)
        return E_FAIL;

    m_readPtr = offset;
    return Read(ppData, size);
}

HRESULT CMemoryStream::ReadAtOffset(SIZE_T offset, LPCSTR *ppString)
{
    if (offset >= m_cbData)
        return E_FAIL;

    m_readPtr = offset;
    return Read(ppString);
}

HRESULT CMemoryStream::Read(void **ppData, SIZE_T size)
{
    SIZE_T temp = m_readPtr + size;

    if (temp < m_readPtr || temp > m_cbData)
        return E_FAIL;

    *ppData = m_pData + m_readPtr;
    m_readPtr = temp;
    return S_OK;
}

HRESULT CMemoryStream::Read(UINT *pDword)
{
    UINT *pTempDword;
    HRESULT hr;

    hr = Read((void**) &pTempDword, sizeof(UINT));
    if (FAILED(hr))
        return E_FAIL;

    *pDword = *pTempDword;
    return S_OK;
}

HRESULT CMemoryStream::Read(LPCSTR *ppString)
{
    SIZE_T iChar;

    for(iChar=m_readPtr; m_pData[iChar]; iChar++)
    {
        if (iChar > m_cbData)
            return E_FAIL;      
    }

    *ppString = (LPCSTR) (m_pData + m_readPtr);
    m_readPtr = iChar;

    return S_OK;
}

SIZE_T CMemoryStream::GetPosition()
{
    return m_readPtr;
}

HRESULT CMemoryStream::Seek(SIZE_T offset)
{
    if (offset > m_cbData)
        return E_FAIL;

    m_readPtr = offset;
    return S_OK;
}

}

//////////////////////////////////////////////////////////////////////////
// CDataBlock - used to dynamically build up the effect file in memory
//////////////////////////////////////////////////////////////////////////

CDataBlock::CDataBlock()
{
    m_size = 0;
    m_maxSize = 0;
    m_pData = NULL;
    m_pNext = NULL;
    m_IsAligned = FALSE;
}

CDataBlock::~CDataBlock()
{
    SAFE_DELETE_ARRAY(m_pData);
    SAFE_DELETE(m_pNext);
}

void CDataBlock::EnableAlignment()
{
    m_IsAligned = TRUE;
}

HRESULT CDataBlock::AddData(const void *pvNewData, UINT bufferSize, CDataBlock **ppBlock)
{
    HRESULT hr = S_OK;
    UINT bytesToCopy;
    const BYTE *pNewData = (const BYTE*) pvNewData;

    if (m_maxSize == 0)
    {
        // This is a brand new DataBlock, fill it up
        m_maxSize = max(8192, bufferSize);

        VN( m_pData = NEW BYTE[m_maxSize] );
    }

    D3DXASSERT(m_pData == AlignToPowerOf2(m_pData, c_DataAlignment));

    bytesToCopy = min(m_maxSize - m_size, bufferSize);
    memcpy(m_pData + m_size, pNewData, bytesToCopy);
    pNewData += bytesToCopy;
    
    if (m_IsAligned)
    {
        D3DXASSERT(m_size == AlignToPowerOf2(m_size, c_DataAlignment));
        m_size += AlignToPowerOf2(bytesToCopy, c_DataAlignment);
    }
    else
    {
        m_size += bytesToCopy;
    }
    
    bufferSize -= bytesToCopy;
    *ppBlock = this;

    if (bufferSize != 0)
    {
        D3DXASSERT(NULL == m_pNext); // make sure we're not overwriting anything

        // Couldn't fit all data into this block, spill over into next
        VN( m_pNext = NEW CDataBlock() );
        if (m_IsAligned)
        {
            m_pNext->EnableAlignment();
        }
        VH( m_pNext->AddData(pNewData, bufferSize, ppBlock) );
    }

lExit:
    return hr;
}

void* CDataBlock::Allocate(UINT bufferSize, CDataBlock **ppBlock)
{
    void *pRetValue;
    UINT temp = m_size + bufferSize;

    if (temp < m_size)
        return NULL;

    *ppBlock = this;

    if (m_maxSize == 0)
    {
        // This is a brand new DataBlock, fill it up
        m_maxSize = max(8192, bufferSize);

        m_pData = NEW BYTE[m_maxSize];
        if (!m_pData)
            return NULL;
        memset(m_pData, 0xDD, m_maxSize);
    }
    else if (temp > m_maxSize)
    {
        D3DXASSERT(NULL == m_pNext); // make sure we're not overwriting anything

        // Couldn't fit data into this block, spill over into next
        m_pNext = NEW CDataBlock();
        if (!m_pNext)
            return NULL;
        if (m_IsAligned)
        {
            m_pNext->EnableAlignment();
        }

        return m_pNext->Allocate(bufferSize, ppBlock);
    }

    D3DXASSERT(m_pData == AlignToPowerOf2(m_pData, c_DataAlignment));

    pRetValue = m_pData + m_size;
    if (m_IsAligned)
    {
        D3DXASSERT(m_size == AlignToPowerOf2(m_size, c_DataAlignment));
        m_size = AlignToPowerOf2(temp, c_DataAlignment);
    }
    else
    {
        m_size = temp;
    }

    return pRetValue;
}


//////////////////////////////////////////////////////////////////////////

CDataBlockStore::CDataBlockStore()
{
    m_pFirst = NULL;
    m_pLast = NULL;
    m_Size = 0;
    m_Offset = 0;
    m_IsAligned = FALSE;

#if _DEBUG
    m_cAllocations = 0;
#endif
}

CDataBlockStore::~CDataBlockStore()
{
    // Can't just do SAFE_DELETE(m_pFirst) since it blows the stack when deleting long chains of data
    CDataBlock* pData = m_pFirst;
    while(pData)
    {
        CDataBlock* pCurrent = pData;
        pData = pData->m_pNext;
        pCurrent->m_pNext = NULL;
        delete pCurrent;
    }

    // m_pLast will be deleted automatically
}

void CDataBlockStore::EnableAlignment()
{
    m_IsAligned = TRUE;
}

HRESULT CDataBlockStore::AddString(LPCSTR pString, UINT *pOffset)
{
    size_t strSize = strlen(pString) + 1;
    D3DXASSERT( strSize <= 0xffffffff );
    return AddData(pString, (UINT)strSize, pOffset);
}

HRESULT CDataBlockStore::AddData(const void *pNewData, UINT bufferSize, UINT *pCurOffset)
{
    HRESULT hr = S_OK;

    if (bufferSize == 0)
    {        
        if (pCurOffset)
        {
            *pCurOffset = 0;
        }
        goto lExit;
    }

    if (!m_pFirst)
    {
        VN( m_pFirst = NEW CDataBlock() );
        if (m_IsAligned)
        {
            m_pFirst->EnableAlignment();
        }
        m_pLast = m_pFirst;
    }

    if (pCurOffset)
        *pCurOffset = m_Size + m_Offset;

    VH( m_pLast->AddData(pNewData, bufferSize, &m_pLast) );
    m_Size += bufferSize;

lExit:
    return hr;
}

void* CDataBlockStore::Allocate(UINT bufferSize)
{
    void *pRetValue = NULL;

#if _DEBUG
    m_cAllocations++;
#endif

    if (!m_pFirst)
    {
        m_pFirst = NEW CDataBlock();
        if (!m_pFirst)
            return NULL;

        if (m_IsAligned)
        {
            m_pFirst->EnableAlignment();
        }
        m_pLast = m_pFirst;
    }

    if (FAILED(UIntAdd(m_Size, bufferSize, &m_Size)))
        return NULL;

    pRetValue = m_pLast->Allocate(bufferSize, &m_pLast);
    if (!pRetValue)
        return NULL;

    return pRetValue;
}

UINT CDataBlockStore::GetSize()
{
    return m_Size;
}

```

`Source Code/Effects11/pchfx.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       pchfx.h
//  Content:    D3D shader effects precompiled header
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __D3DX11_PCHFX_H__
#define __D3DX11_PCHFX_H__

#include "d3d11.h"
#include "d3dx11.h"
#undef DEFINE_GUID
#include "INITGUID.h"
#include "d3dx11effect.h"

#define UNUSED -1

//////////////////////////////////////////////////////////////////////////

#define offsetof_fx( a, b ) (UINT)offsetof( a, b )

#include "d3dxGlobal.h"

#include <stddef.h>
#include <strsafe.h>

#include "Effect.h"
#include "EffectStateBase11.h"
#include "EffectLoad.h"

#include "D3DCompiler.h"

//////////////////////////////////////////////////////////////////////////

namespace D3DX11Effects
{
} // end namespace D3DX11Effects

#endif // __D3DX11_PCHFX_H__

```

`Source Code/GameApp.cpp`:

```cpp
#include "GameApp.h"
#include "XUtility.h"


GameApp::GameApp(HINSTANCE hInstance)
	: D3DApp(hInstance), m_pFX(nullptr), m_pTech(nullptr), 
		m_pMKInput(nullptr)
{
	m_MainWndCaption = L"超级战机";
}

GameApp::~GameApp()
{
	ReleaseCOM(m_pFX);
	ReleaseStatic(Sprite2D);
	ReleaseStatic(D2DText);
	ReleaseStatic(MKInput);
	ReleaseStatic(PlaneManager);
}

bool GameApp::Init()
{
	if (!D3DApp::Init())
		return false;
	
	m_Mode = GameMode::MENU;
	InitFX();
	InitDInput();
	Init2D();
	InitText();
	LoadHighScore();
	CheckMaxStage();
	return true;
}

void GameApp::InitFX()
{
	m_pFX = nullptr;
	// 初始化Effect
	BuildFX(m_pD3DDevice, L"HLSL/Basic.hlsl", &m_pFX);
	assert(m_pFX);
	m_pTech = m_pFX->GetTechniqueByName("Sprite2D");
}



void GameApp::Init2D()
{

	Sprite2D::Initialize(m_hMainWnd, m_pD3DImmediateContext, m_pSwapChain, m_pFX, "Sprite2D");
	// 己方战机纹理初始化
	m_Sprite2D["playerRed"].InitTexture("Texture/playerRed.png");
	m_Sprite2D["playerBlue"].InitTexture("Texture/playerBlue.png");
	PlaneManager::player.Initialize(1);
	// 己方子弹初始化
	m_Sprite2D["fire"].InitTexture("Texture/fire.png");
	m_Sprite2D["flame1"].InitTexture("Texture/flame1.png");
	// 敌机子弹初始化
	m_Sprite2D["bullet"].InitTexture("Texture/bullet.png");
	m_Sprite2D["laser"].InitTexture("Texture/laser.png");
	m_Sprite2D["flame2"].InitTexture("Texture/flame2.png");
	// Item初始化
	m_Sprite2D["bomb"].InitTexture("Texture/bomb.png");
	m_Sprite2D["shield"].InitTexture("Texture/shield.png");
	m_Sprite2D["power"].InitTexture("Texture/power.png");
	// 血条
	m_Sprite2D["health"].InitTexture("Texture/health.png");
	// 背景初始化
	m_Sprite2D["background"].InitTexture("Texture/background.png");
	// 飞机管理者和敌机初始化
	PlaneManager::Initialize(MainWnd(), m_pMKInput);
	PlaneManager::InitEnemyPlanes();
	// 敌机纹理初始化
	std::string key;
	std::string path = "Texture/";
	for (const EnemyPlane& plane : PlaneManager::enemyPlaneInfo)
	{
		key = plane.GetTexName();
		m_Sprite2D[key].InitTexture((path + key + ".png").c_str());
	}
}

void GameApp::InitDInput()
{
	MKInput::Initialize(m_hMainWnd, m_pSwapChain);
	m_pMKInput = MKInput::GetMKInput();
}

void GameApp::InitText()
{
	D2DText::Initialize(m_hMainWnd, m_pSwapChain);
	m_SmallFont.Reset(L"宋体", 20, D2D1::ColorF::White, DWRITE_TEXT_ALIGNMENT_LEADING, DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
	m_MidFont.Reset(L"宋体", 30, D2D1::ColorF::White, DWRITE_TEXT_ALIGNMENT_LEADING, DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
	m_LargeFont.Reset(L"宋体", 60, D2D1::ColorF::White, DWRITE_TEXT_ALIGNMENT_CENTER, DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
	m_Name[0][0] = m_Name[1][0] = m_Name[2][0] = L'A';
	m_Name[0][1] = m_Name[1][1] = m_Name[2][1] = 0;
}



void GameApp::OnResize()
{
	D2DText::Discard();
	D3DApp::OnResize();
	D2DText::OnReset();

	m_pSwapChain->GetFullscreenState(&m_FullScreen, nullptr);
	
}

void GameApp::UpdateScene(float dt)
{
	m_pMKInput->Update();
	
	if (m_Mode == GameMode::PLAYING || m_Mode == GameMode::COMPLETE)
		PlaneManager::UpdateScene();
}



void GameApp::DrawScene()
{
	assert(m_pD3DImmediateContext);
	assert(m_pSwapChain);

	m_pD3DImmediateContext->ClearRenderTargetView(m_pRenderTargetView, reinterpret_cast<const float*>(&Colors::Silver));		//底色
	m_pD3DImmediateContext->ClearDepthStencilView(m_pDepthStencilView, D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);


	// 按图层顺序反向绘制
	DrawGameSence();
	DrawBackground();
	DrawUI();
	HR(m_pSwapChain->Present(0, 0));
}

void GameApp::DrawGameSence()
{
	// 游戏中、完成、暂停中绘制
	if (m_Mode == GameMode::PLAYING || m_Mode == GameMode::PAUSE || m_Mode == GameMode::COMPLETE)
	{
		RECT rc;
		std::vector<RECT> rcs;
		std::vector<float> radians;
		// 如果是boss模式，先绘制血条
		if (PlaneManager::bossFrameCnt <= PlaneManager::totalFrameCnt)
		{
			if (!PlaneManager::enemyPlanes.empty())
			{
				int nums = PlaneManager::enemyPlanes.front().GetHealthSlices();
				radians.resize(nums);
				rc = ToScreenRect({ 200, 100, 202, 130 });
				for (int i = 0; i < nums; ++i, rc.left += 4, rc.right += 4)
					rcs.push_back(rc);
				m_Sprite2D["health"].StretchRects(rcs, radians);
				m_Sprite2D["health"].Draw();
			}
		}

		// 绘制子弹
		rcs.clear();
		radians.clear();
		for (const Bullet& bullet : PlaneManager::enemyBullets)
		{
			rcs.push_back(ToScreenRect(bullet.GetRect()));
			radians.push_back(0.0f);
		}
		m_Sprite2D["bullet"].StretchRects(rcs, radians);
		m_Sprite2D["bullet"].Draw();

		rcs.clear();
		radians.clear();
		for (const Bullet& laser : PlaneManager::enemyLasers)
		{
			rcs.push_back(ToScreenRect(laser.GetRect()));
			radians.push_back(MathHelper::Pi / 2);
		}
		m_Sprite2D["laser"].StretchRects(rcs, radians);
		m_Sprite2D["laser"].Draw();

		rcs.clear();
		radians.clear();
		for (const Bullet& bullet : PlaneManager::enemyFlames)
		{
			rcs.push_back(ToScreenRect(bullet.GetRect()));
			radians.push_back(-bullet.GetRotation());
		}
		m_Sprite2D["flame2"].StretchRects(rcs, radians);
		m_Sprite2D["flame2"].Draw();

		rcs.clear();
		radians.clear();
		for (const Bullet& fire : PlaneManager::playerBullets)
		{
			rcs.push_back(ToScreenRect(fire.GetRect()));
			radians.push_back(-fire.GetRotation());
		}
		m_Sprite2D["fire"].StretchRects(rcs, radians);
		m_Sprite2D["fire"].Draw();

		rcs.clear();
		radians.clear();
		for (const Bullet& flame : PlaneManager::playerFlames)
		{
			rcs.push_back(ToScreenRect(flame.GetRect()));
			radians.push_back(-flame.GetRotation());
		}
		m_Sprite2D["flame1"].StretchRects(rcs, radians);
		m_Sprite2D["flame1"].Draw();
		// 然后绘制Item
		for (const Item& item : PlaneManager::items)
		{
			rc = ToScreenRect(item.GetRect());
			std::string str;
			switch (item.GetType())
			{
			case 1: str = "bomb";
				break;
			case 2: str = "power";
				break;
			case 3: str = "shield";
				break;
			default: break;
			}
			m_Sprite2D[str].StretchRect(nullptr, &rc, nullptr, 0.0f);
			m_Sprite2D[str].Draw();
		}
		// 然后绘制敌机
		for (const EnemyPlane& plane : PlaneManager::enemyPlanes)
		{
			rc = ToScreenRect(plane.GetRect());
			std::string str = plane.GetTexName();

			if (plane.IsRotating())
			{
				LONG width = rc.right - rc.left;
				LONG height = rc.bottom - rc.top;
				POINT center = { width / 2 + rc.left, height / 2 + rc.top };
				float rad = plane.GetCurrFrameCnt() / 10 % 2 * MathHelper::Pi;
				m_Sprite2D[str].StretchRect(nullptr, &rc, &center, rad);
			}
			else
				m_Sprite2D[str].StretchRect(nullptr, &rc, nullptr, 0.0f);
			m_Sprite2D[str].Draw();
		}
		// 绘制己方战机
		if (PlaneManager::player.IsAlive())
		{
			rc = ToScreenRect(PlaneManager::player.GetRect());
			if (PlaneManager::player.GetTypeID() == 1)
			{
				m_Sprite2D["playerRed"].StretchRect(nullptr, &rc, nullptr, 0.0f);
				m_Sprite2D["playerRed"].Draw();
			}
			else if (PlaneManager::player.GetTypeID() == 2)
			{
				m_Sprite2D["playerBlue"].StretchRect(nullptr, &rc, nullptr, 0.0f);
				m_Sprite2D["playerBlue"].Draw();
			}
		}
	}
}

void GameApp::DrawBackground()
{
	
	static RECT backgroundRect = ToScreenRect({ 0, 900, 750, 1800 });
	RECT destRect = ToScreenRect({ 0, 0, 750, 900 });
	if (backgroundRect.bottom < 0)
	{
		backgroundRect.top = 900;
		backgroundRect.bottom = 1800;
	}
	// 暂停时不更新
	if (m_Mode != GameMode::PAUSE)
	{
		backgroundRect.top -= 5;
		backgroundRect.bottom -= 5;
	}

	m_Sprite2D["background"].StretchRect(&backgroundRect, &destRect, nullptr, 0.0f);
	m_Sprite2D["background"].Draw();
}

void GameApp::DrawUI()
{
	std::wstring wstr;
	switch (m_Mode)
	{
	case GameMode::MENU: DrawMenu();
		break;
	case GameMode::CHOICE: DrawChoice();
		break;
	case GameMode::PLAYING: DrawPlaying();
		break;
	case GameMode::SETTING: DrawSetting();
		break;
	case GameMode::RANK: DrawRank();
		break;
	case GameMode::PAUSE: DrawPause();
		break;
	case GameMode::SCORE: DrawScore();
		break;
	case GameMode::COMPLETE: DrawComplete();
		break;
	}
}

void GameApp::DrawMenu()
{
	m_LargeFont.DrawString(L"超级战机", ToScreenRectF(D2D1_RECT_F{ 250.0f, 100.0f, 500.0f, 160.0f }));

	m_MidFont.SetTextAlign(DWRITE_TEXT_ALIGNMENT_CENTER);

	if (ClickBox(m_pMKInput, ToScreenRectF(D2D1_RECT_F{ 315.0f, 400.0f, 435.0f, 460.0f }), m_MidFont, L"开始游戏"))
	{
		m_Mode = GameMode::CHOICE;
		PlaneManager::snd["START"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
	}
	if (ClickBox(m_pMKInput, ToScreenRectF(D2D1_RECT_F{ 345.0f, 480.0f, 405.0f, 540.0f }), m_MidFont, L"设置"))
	{
		m_Mode = GameMode::SETTING;
		PlaneManager::snd["START"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
	}
	if (ClickBox(m_pMKInput, ToScreenRectF(D2D1_RECT_F{ 330.0f, 560.0f, 420.0f, 620.0f }), m_MidFont, L"排行榜"))
	{
		m_Mode = GameMode::RANK;
		PlaneManager::snd["START"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
	}
	if (ClickBox(m_pMKInput, ToScreenRectF(D2D1_RECT_F{ 315.0f, 640.0f, 435.0f, 700.0f }), m_MidFont, L"录像回放"))
	{
		PlaneManager::snd["START"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		char cwd[MAX_PATH];
		char filePath[MAX_PATH];
		GetCurrentDirectoryA(MAX_PATH, cwd);	// 保留默认工作路径
		//调用文件窗口
		OPENFILENAMEA ofn;
		ZeroMemory(&ofn, sizeof(OPENFILENAMEA));
		ofn.lStructSize = sizeof(OPENFILENAMEA);
		ofn.hwndOwner = m_hMainWnd;
		ofn.lpstrFile = filePath;
		ofn.lpstrFile[0] = '\0';
		ofn.nMaxFile = MAX_PATH;
		ofn.lpstrFilter = "Dat文件(*.dat)\0*.dat\0";
		ofn.nFilterIndex = 0;
		ofn.lpstrFileTitle = NULL;
		ofn.nMaxFileTitle = 0;
		ofn.lpstrInitialDir = "\\Replay";
		ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

		BOOL prevFullScreen = m_FullScreen;
		if (prevFullScreen)
			m_pSwapChain->SetFullscreenState(false, nullptr);

		if (GetOpenFileNameA(&ofn))
		{
			SetCurrentDirectoryA(cwd);
			PlaneManager::InitReplay(filePath);
			m_Mode = GameMode::PLAYING;
			PlaneManager::replayMode = true;
			PlaneManager::score = 0;

		}
		else
			SetCurrentDirectoryA(cwd);

		if (prevFullScreen)
			m_pSwapChain->SetFullscreenState(true, nullptr);
	}
	if (ClickBox(m_pMKInput, ToScreenRectF(D2D1_RECT_F{ 315.0f, 720.0f, 435.0f, 780.0f }), m_MidFont, L"结束游戏"))
	{
		// 退出
		PostQuitMessage(0);
	}

	std::wstring wstr = L"重制Ver1.1 X_Jun";
	m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 200.0f, 830.0f, 550.0f, 890.0f }));
	m_MidFont.SetTextAlign(DWRITE_TEXT_ALIGNMENT_LEADING);
}

void GameApp::DrawChoice()
{
	m_LargeFont.DrawString(L"选择战机", ToScreenRectF(D2D1_RECT_F{ 250.0f, 100.0f, 500.0f, 160.0f }));

	if (ClickBox(m_pMKInput, ToScreenRectF(D2D1_RECT_F{ 100.0f, 400.0f, 350.0f, 570.0f }), m_MidFont,
		L"散射型\n射速：B\n火力：A\n机动：B\n最大倍率：12x\n"))
	{
		PlaneManager::player.Initialize(1);
		PlaneManager::InitStage(PlaneManager::stage);
		PlaneManager::score = 0;
		m_Mode = GameMode::PLAYING; 
		PlaneManager::snd["START"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		PlaneManager::replayMode = false;
		// 生成随机数种子然后使用
		PlaneManager::randomSeed = time(nullptr);	
		srand((unsigned)PlaneManager::randomSeed);
		
		// 打开录像输出流，写入初始信息
		std::ostringstream oss;
		oss << "Replay/" << std::hex << PlaneManager::randomSeed << ".dat";
		std::string filePath = oss.str();
		std::ofstream& ofs = PlaneManager::replayOut;
		ofs.open(filePath, std::ios::out | std::ios::binary);
		ofs.write(reinterpret_cast<char *>(&PlaneManager::randomSeed), sizeof(time_t));
		ofs.write(reinterpret_cast<char *>(&PlaneManager::stage), sizeof(int));
		int bossMode = PlaneManager::bossMode;
		ofs.write(reinterpret_cast<char *>(&bossMode), sizeof(int));
		int planeType = 1;
		ofs.write(reinterpret_cast<char *>(&planeType), sizeof(int));
	}
	if (ClickBox(m_pMKInput, ToScreenRectF(D2D1_RECT_F{ 400.0f, 400.0f, 650.0f, 570.0f }), m_MidFont,
		L"集火型\n射速：A\n火力：B\n机动：A\n最大倍率：16x\n"))
	{
		PlaneManager::player.Initialize(2);
		PlaneManager::InitStage(PlaneManager::stage);
		PlaneManager::score = 0;
		m_Mode = GameMode::PLAYING;
		PlaneManager::snd["START"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		PlaneManager::replayMode = false;
		// 生成随机数种子然后使用
		PlaneManager::randomSeed = time(nullptr);
		srand((unsigned)PlaneManager::randomSeed);

		// 打开录像输出流，写入初始信息
		std::ostringstream oss;
		oss << "Replay/" << std::hex << PlaneManager::randomSeed << ".dat";
		std::string filePath = oss.str();
		std::ofstream& ofs = PlaneManager::replayOut;
		ofs.open(filePath, std::ios::out | std::ios::binary);
		ofs.write(reinterpret_cast<char *>(&PlaneManager::randomSeed), sizeof(time_t));
		ofs.write(reinterpret_cast<char *>(&PlaneManager::stage), sizeof(int));
		int bossMode = PlaneManager::bossMode;
		ofs.write(reinterpret_cast<char *>(&bossMode), sizeof(int));
		int planeType = 2;
		ofs.write(reinterpret_cast<char *>(&planeType), sizeof(int));
	}
}

void GameApp::DrawPlaying()
{
	// 绘制文本UI
	// 左上角
	std::wstring wstr;
	wstr = L"Lives: " + std::to_wstring(PlaneManager::player.GetLives());
	m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 10.0f, 10.0f, 190.0f, 40.0f }));
	wstr = L"Credits: " + std::to_wstring(PlaneManager::player.GetCredits());
	m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 10.0f, 40.0f, 190.0f, 70.0f }));
	wstr = L"Shields: " + std::to_wstring(PlaneManager::player.GetShields());
	m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 10.0f, 70.0f, 190.0f, 100.0f }));
	wstr = L"Bombs: " + std::to_wstring(PlaneManager::player.GetBombs());
	m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 10.0f, 100.0f, 190.0f, 130.0f }));

	// 左下角
	if (PlaneManager::debugMode)
	{
		wstr = L"FrameCount: " + std::to_wstring(PlaneManager::totalFrameCnt);
		m_SmallFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 10.0f, 810.0f, 180.0f, 830.0f }));
		wstr = L"EnemyPlanes: " + std::to_wstring(PlaneManager::enemyPlanes.size());
		m_SmallFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 10.0f, 830.0f, 180.0f, 850.0f }));
		wstr = L"EnemyBullets: " + std::to_wstring(
			PlaneManager::enemyBullets.size() + PlaneManager::enemyLasers.size() + PlaneManager::enemyFlames.size());
		m_SmallFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 10.0f, 850.0f, 180.0f, 870.0f }));
		wstr = L"PlayerBullets: " + std::to_wstring(PlaneManager::playerBullets.size() +
			PlaneManager::playerFlames.size());
		m_SmallFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 10.0f, 870.0f, 180.0f, 890.0f }));
	}
	// 右上角
	wstr = L"Score:   " + std::to_wstring(PlaneManager::score);
	m_MidFont.SetTextAlign(DWRITE_TEXT_ALIGNMENT_TRAILING);
	m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 600.0f, 10.0f, 740.0f, 70.0f }));
	wstr = L"Combo: " + std::to_wstring(PlaneManager::player.GetCurrRate()) + L'x';
	m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 570.0f, 70.0f, 740.0f, 100.0f }));
	m_MidFont.SetTextAlign(DWRITE_TEXT_ALIGNMENT_LEADING);



	// 右下角
	wstr = L"Stage" + std::to_wstring(PlaneManager::stage);
	m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 640.0f, 860.0f, 740.0f, 890.0f }));
	
	// 若检测到ESC键按下
	if (m_pMKInput->Key_Down(DIK_ESCAPE))
	{
		m_Mode = GameMode::PAUSE;
		// 把所有放着的音乐停下
		for (auto p : PlaneManager::snd)
			if (p.second->IsSoundPlaying())
				p.second->Stop();
	}

	// 回放模式
	if (PlaneManager::replayMode)
	{
		bool endReplay = PlaneManager::replayInfo[PlaneManager::stage].rbegin()->first < PlaneManager::totalFrameCnt;
		if (endReplay)
			m_MidFont.DrawString(L"Replay Finish", ToScreenRectF(D2D1_RECT_F{ 260.0f, 860.0f, 490.0f, 900.0f }));
		else
			m_MidFont.DrawString(L"Replay Mode", ToScreenRectF(D2D1_RECT_F{ 280.0f, 860.0f, 470.0f, 900.0f }));
	}
	

	// BOSS出现提醒5s
	if (PlaneManager::bossFrameCnt - 400 <= PlaneManager::totalFrameCnt &&
		PlaneManager::totalFrameCnt < PlaneManager::bossFrameCnt - 100)
	{
		if (PlaneManager::totalFrameCnt == PlaneManager::bossFrameCnt - 400)
			PlaneManager::snd["WARNING"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		m_LargeFont.DrawString(L"警告" , ToScreenRectF(D2D1_RECT_F{ 300.0f, 100.0f, 450.0f, 200.0f }));
		m_MidFont.DrawString(L"Boss来袭！！", ToScreenRectF(D2D1_RECT_F{ 285.0f, 200.0f, 465.0f, 300.0f }));
	}

	// 死亡2s后，如果Lives为0，暂停游戏
	if (PlaneManager::player.GetLives() == 0 && !PlaneManager::player.IsAlive()
		&& PlaneManager::totalFrameCnt - PlaneManager::player.GetCrashFrameCnt() >= 120)
	{
		// 拿到高分就去登记
		if (PlaneManager::score > m_HighScore[7].second)
			m_Mode = GameMode::SCORE;
		else
			m_Mode = GameMode::PAUSE;
	}

	// 打败boss后会来到结算得分界面
	if (PlaneManager::totalFrameCnt > PlaneManager::bossFrameCnt &&
		PlaneManager::enemyPlanes.empty() && !PlaneManager::bossKillFrameCnt)
	{
		PlaneManager::bossKillFrameCnt = PlaneManager::totalFrameCnt;
		PlaneManager::finalRate = PlaneManager::player.GetCurrRate();
		// 清空敌方子弹
		PlaneManager::enemyBullets.clear();
		PlaneManager::enemyLasers.clear();
	}
	if (PlaneManager::bossKillFrameCnt && PlaneManager::totalFrameCnt - 120 > 
		PlaneManager::bossKillFrameCnt)
	{
		m_Mode = GameMode::COMPLETE;
	}
}

void GameApp::DrawSetting()
{
	m_LargeFont.DrawString(L"设置", ToScreenRectF(D2D1_RECT_F{ 250.0f, 100.0f, 500.0f, 160.0f }));
	// 设置起始关卡
	std::wstring wstr = L"起始关卡: " + std::to_wstring(PlaneManager::stage);
	if (PlaneManager::bossMode)
		wstr += L"BOSS";
	if (ClickBox(m_pMKInput, ToScreenRectF(D2D1_RECT_F{ 250.0f, 400.0f, 500.0f, 460.0f }), m_MidFont, wstr.c_str()))
	{
		if (PlaneManager::stage < m_MaxStage)
			PlaneManager::stage++;
		else
		{
			PlaneManager::bossMode = !PlaneManager::bossMode;
			PlaneManager::stage = 1;
		}
		PlaneManager::snd["START"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
	}
	// 显示调试信息
	wstr = L"显示调试信息: ";
	wstr += PlaneManager::debugMode ? L"是" : L"否";
	if (ClickBox(m_pMKInput, ToScreenRectF(D2D1_RECT_F{ 250.0f, 480.0f, 500.0f, 540.0f }), m_MidFont, wstr.c_str()))
	{
		PlaneManager::debugMode = !PlaneManager::debugMode;
		PlaneManager::snd["START"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
	}

	// 设置游戏音量
	wstr = L"音量: ";
	wstr += std::to_wstring(PlaneManager::volume);
	if (ClickBox(m_pMKInput, ToScreenRectF(D2D1_RECT_F{ 250.0f, 560.0f, 400.0f, 620.0f }), m_MidFont, wstr.c_str()))
	{
		if (PlaneManager::volume == 10)
			PlaneManager::volume = 0;
		else
			PlaneManager::volume++;
		PlaneManager::snd["START"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
	}
	
	// 返回主界面ToScreenRect(ToScreenRectF(D2D1_RECT_F{\1}))
	wstr = L"全屏:";
	wstr += (m_FullScreen ? L"是" : L"否");
	if (ClickBox(m_pMKInput, ToScreenRectF(D2D1_RECT_F{ 250.0f, 640.0f, 500.0f, 700.0f }), m_MidFont, wstr.c_str()))
	{
		m_FullScreen = !m_FullScreen;
		m_pSwapChain->SetFullscreenState(m_FullScreen, nullptr);
	}

	// 返回主界面
	if (ClickBox(m_pMKInput, ToScreenRectF(D2D1_RECT_F{ 250.0f, 720.0f, 500.0f, 780.0f }), m_MidFont, L"返回主界面"))
	{
		m_Mode = GameMode::MENU;
		PlaneManager::snd["START"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
	}
}

void GameApp::DrawRank()
{
	m_LargeFont.DrawString(L"排行榜", ToScreenRectF(D2D1_RECT_F{ 200.0f, 100.0f, 500.0f, 160.0f }));
	m_MidFont.DrawString(L"名次 名称    得分", ToScreenRectF(D2D1_RECT_F{ 200.0f, 200.0f, 550.0f, 260.0f }));
	for (int i = 0; i < 8; ++i)
	{
		std::wstring wstr = std::to_wstring(i + 1) + L"     " + 
			m_HighScore[i].first + L"     " + std::to_wstring(m_HighScore[i].second);
		m_MidFont.DrawString(wstr.c_str(),
			ToScreenRectF(D2D1_RECT_F{ 200.0f, 300.0f + 60.0f * i, 550.0f, 360.0f + 60.0f * i }));
	}
	if (ClickBox(m_pMKInput, ToScreenRectF(D2D1_RECT_F{ 340.0f, 800.0f, 410.0f, 860.0f }), m_MidFont, L"返回"))
	{
		m_Mode = GameMode::MENU;
		PlaneManager::snd["START"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
	}
}

void GameApp::DrawPause()
{
	std::wstring wstr;
	m_MidFont.SetTextAlign(DWRITE_TEXT_ALIGNMENT_CENTER);
	// 如果玩家的所有命用光了
	if (PlaneManager::player.GetCredits() == 0 && PlaneManager::player.GetLives() == 0 &&
		!PlaneManager::player.IsAlive())
	{
		m_MidFont.DrawString(L"游戏结束", ToScreenRectF(D2D1_RECT_F{ 250.0f, 300.0f, 500.0f, 360.0f }));
		wstr = L"得分：" + std::to_wstring(PlaneManager::score);
		m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 250.0f, 400.0f, 500.0f, 460.0f }));
		m_MidFont.DrawString(L"按回车键返回", ToScreenRectF(D2D1_RECT_F{ 250.0f, 500.0f, 500.0f, 560.0f }));

		// 若检测到回车键按下
		if (m_pMKInput->Key_Down(DIK_RETURN))
		{
			m_Mode = GameMode::MENU;
			// 非录像模式下，结束文件输出
			if (!PlaneManager::replayMode)
			{
				PlaneManager::replayOut.close();
				PlaneManager::replayInfo.clear();
			}
		}
			
	}
	// 如果玩家还有币
	else if (PlaneManager::player.GetLives() == 0 && !PlaneManager::player.IsAlive())
	{
		wstr = L"得分：" + std::to_wstring(PlaneManager::score);
		m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 250.0f, 300.0f, 500.0f, 360.0f }));
		m_MidFont.DrawString(L"续币后得分清零", ToScreenRectF(D2D1_RECT_F{ 250.0f, 400.0f, 500.0f, 460.0f }));
		m_MidFont.DrawString(L"按回车续币", ToScreenRectF(D2D1_RECT_F{ 250.0f, 500.0f, 500.0f, 560.0f }));
		m_MidFont.DrawString(L"按Esc放弃", ToScreenRectF(D2D1_RECT_F{ 250.0f, 600.0f, 500.0f, 660.0f }));

		// 若检测到回车键按下
		if (m_pMKInput->Key_Down(DIK_RETURN))
		{
			m_Mode = GameMode::PLAYING;
			PlaneManager::player.Respawn();
			PlaneManager::score = 0;
		}
		// Esc键按下
		if (m_pMKInput->Key_Down(DIK_ESCAPE))
		{
			m_Mode = GameMode::MENU;
			// 非录像模式下，写入终止标记，结束文件输出
			if (!PlaneManager::replayMode)
			{
				PlaneManager::replayOut.close();
				PlaneManager::replayInfo.clear();
			}
		}
	}
	// 其余都是普通暂停
	else
	{
		m_MidFont.DrawString(L"游戏已暂停", ToScreenRectF(D2D1_RECT_F{ 250.0f, 300.0f, 500.0f, 360.0f }));
		m_MidFont.DrawString(L"按回车键继续", ToScreenRectF(D2D1_RECT_F{ 250.0f, 400.0f, 500.0f, 460.0f }));
		m_MidFont.DrawString(L"按F2回到主界面", ToScreenRectF(D2D1_RECT_F{ 250.0f, 500.0f, 500.0f, 560.0f }));
		// 若检测到回车键按下
		if (m_pMKInput->Key_Down(DIK_RETURN))
			m_Mode = GameMode::PLAYING;
		if (m_pMKInput->Key_Down(DIK_F2))
		{
			m_Mode = GameMode::MENU;
			// 非录像模式下，删除录像
			if (!PlaneManager::replayMode)
			{
				PlaneManager::replayOut.close();
				PlaneManager::replayInfo.clear();

				std::ostringstream oss;
				oss << "Replay/" << std::hex << PlaneManager::randomSeed << ".dat";
				std::string filePath = oss.str();
				remove(filePath.c_str());
			}
		}
			
	}
	m_MidFont.SetTextAlign(DWRITE_TEXT_ALIGNMENT_LEADING);
}

void GameApp::DrawScore()
{
	std::wstring wstr = L"得分：" + std::to_wstring(PlaneManager::score);
	m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 250.0f, 300.0f, 500.0f, 360.0f }));
	m_MidFont.DrawString(L"选择3字节昵称", ToScreenRectF(D2D1_RECT_F{ 250.0f, 400.0f, 500.0f, 460.0f }));
	for (int i = 0; i < 3; ++i)
	{
		if (ClickBox(m_pMKInput, ToScreenRectF(D2D1_RECT_F{ 250.0f + i * 30.0f, 500.0f, 280.0f + i * 30.0f, 560.0f }),
			m_MidFont, L"▲") && m_Name[i][0] > 0x20)
		{
			m_Name[i][0]--;
			PlaneManager::snd["START"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		}
		m_MidFont.DrawString(m_Name[i], ToScreenRectF(D2D1_RECT_F{ 250.0f + i * 30.0f, 560.0f, 280.0f + i * 30.0f, 620.0f }));
		if (ClickBox(m_pMKInput, ToScreenRectF(D2D1_RECT_F{ 250.0f + i * 30.0f, 620.0f, 280.0f + i * 30.0f, 680.0f }),
			m_MidFont, L"▼") && m_Name[i][0] < 0x7A)
		{
			m_Name[i][0]++;
			PlaneManager::snd["START"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		}
	}
	if (ClickBox(m_pMKInput, ToScreenRectF(D2D1_RECT_F{ 250.0f, 700.0f, 500.0f, 760.0f }), m_MidFont, L"确认"))
	{
		wstr.resize(3);
		for (int i = 0; i < 3; ++i)
			wstr[i] = m_Name[i][0];
		StoreHighScore(wstr, PlaneManager::score);
		// 如果关卡全部完成，回到主界面；反之回到暂停
		if (!PlaneManager::stageComplete)
			m_Mode = GameMode::MENU;
		else
			m_Mode = GameMode::PAUSE;

		m_Name[0][0] = m_Name[1][0] = m_Name[2][0] = L'A';
		PlaneManager::snd["START"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
	}
}

void GameApp::DrawComplete()
{
	int leftBombs = PlaneManager::player.GetBombs();
	int leftLives = PlaneManager::player.GetLives();
	int leftShields = PlaneManager::player.GetShields();
	int noMissScore = PlaneManager::noMiss ? 10000 * PlaneManager::stage : 0;
	std::wstring wstr = L"剩余炸弹得分  " + std::to_wstring(leftBombs) + L" x 1000";
	m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 150.0f, 200.0f, 600.0f, 260.0f }));
	wstr = L"剩余生命得分  " + std::to_wstring(leftLives) + L" x 1000";
	m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 150.0f, 260.0f, 600.0f, 320.0f }));
	wstr = L"剩余护盾得分  " + std::to_wstring(leftShields) + L" x 1000";
	m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 150.0f, 320.0f, 600.0f, 380.0f }));
	wstr = L"无死亡得分    " + std::to_wstring(noMissScore);
	m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 150.0f, 380.0f, 600.0f, 440.0f }));
	wstr = L"倍率           x " + std::to_wstring(PlaneManager::finalRate);
	m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 150.0f, 440.0f, 600.0f, 500.0f }));
	int getScore = ((leftBombs + leftLives + leftShields) * 1000 + noMissScore) * 
		PlaneManager::finalRate;
	wstr = L"结算得分      " + std::to_wstring(getScore);
	m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 150.0f, 500.0f, 600.0f, 560.0f }));
	int totalScore = PlaneManager::score + getScore;
	wstr = L"当前总分      " + std::to_wstring(totalScore);
	m_MidFont.DrawString(wstr.c_str(), ToScreenRectF(D2D1_RECT_F{ 150.0f, 600.0f, 600.0f, 760.0f }));

	if (PlaneManager::totalFrameCnt - 600 > PlaneManager::bossKillFrameCnt)
	{
		PlaneManager::score = totalScore;
		if (PlaneManager::stage == m_MaxStage)
		{
			// 录像模式下，直接返回
			if (PlaneManager::replayMode)
			{
				m_Mode = GameMode::MENU;
				return;
			}
				
			PlaneManager::replayOut.close();
			PlaneManager::replayInfo.clear();

			// 拿到高分就去登记
			if (PlaneManager::score > m_HighScore[7].second)
				m_Mode = GameMode::SCORE;
			else
				m_Mode = GameMode::MENU;
		}
		else
		{
			// 来到下一关
			PlaneManager::bossMode = false;
			PlaneManager::InitStage(PlaneManager::stage + 1);
			PlaneManager::player.Refresh();
			m_Mode = GameMode::PLAYING;
			// 非录像模式下，录像文件写入下一关的标记
			if (!PlaneManager::replayMode)
			{
				unsigned short nextStage[2] = { 0xffff, (unsigned short)(PlaneManager::stage) };
				PlaneManager::replayOut.write(reinterpret_cast<char *>(&nextStage), sizeof(short) * 2);
			}
			
		}
	}
}

void GameApp::LoadHighScore()
{
	std::ifstream fin("Data/HighScore.dat", std::ios::in | std::ios::binary);
	if (!fin.is_open())
	{
		std::ofstream fout("Data/HighScore.dat", std::ios::out | std::ios::binary);
		wchar_t name[4] = L"PL";
		int score;
		for (int i = 0; i < 8; ++i)
		{
			name[2] = L'1' + i;
			score = 4000000 - 500000 * i;
			fout.write(reinterpret_cast<char*>(name), sizeof(name));
			fout.write(reinterpret_cast<char*>(&score), sizeof(score));
		}
		fout.close();
		fin.open("Data/HighScore.dat", std::ios::in | std::ios::binary);
	}
	wchar_t name[4];
	int score;
	m_HighScore.clear();
	for (int i = 0; i < 8; ++i)
	{
		fin.read(reinterpret_cast<char*>(name), sizeof(name));
		fin.read(reinterpret_cast<char*>(&score), sizeof(score));
		m_HighScore.push_back(std::make_pair(name, score));
	}
	fin.close();
}

void GameApp::StoreHighScore(const std::wstring & wstr, int score)
{
	m_HighScore[7].first = wstr;
	m_HighScore[7].second = score;
	std::sort(m_HighScore.begin(), m_HighScore.end(), [](
		const std::pair<std::wstring, int>& lft, 
		const std::pair<std::wstring, int>& rht) {
		return lft.second > rht.second;
	});
	std::ofstream fout("Data/HighScore.dat", std::ios::out | std::ios::binary);
	wchar_t name[4] = L"";
	for (int i = 0; i < 8; ++i)
	{
		memcpy_s(name, sizeof(name), m_HighScore[i].first.data(), 
			m_HighScore[i].first.size() * sizeof(wchar_t));
		fout.write(reinterpret_cast<char*>(name), sizeof(name));
		fout.write(reinterpret_cast<char*>(&m_HighScore[i].second), sizeof(int));
	}
	fout.close();
}

void GameApp::CheckMaxStage()
{
	char level[30];
	char stage[30];
	FILE *fp1, *fp2;
	int i = 0;
	while (true)
	{
		sprintf(level, "Data/EnemyLevel%d.txt", i + 1);
		sprintf(stage, "Data/Stage%d.txt", i + 1);
		fp1 = fopen(level, "r");
		fp2 = fopen(stage, "r");
		if (fp1 && fp2)
			++i;
		else
			break;
		fclose(fp1);
		fclose(fp2);
	}
	m_MaxStage = i;
}

RECT GameApp::ToScreenRect(const RECT & rect)
{
	if (!m_FullScreen)
		return rect;
	else
	{
		RECT rc;
		rc.left = m_ClientWidth / 2 - 375 + rect.left;
		rc.top = rect.top;
		rc.right = m_ClientWidth / 2 - 375 + rect.right;
		rc.bottom = rect.bottom;
		return rc;
	}

}

D2D1_RECT_F GameApp::ToScreenRectF(const D2D1_RECT_F & rectF)
{
	if (!m_FullScreen)
		return rectF;
	else
	{
		D2D1_RECT_F rcF;
		rcF.left = m_ClientWidth / 2.0f - 375.0f + rectF.left;
		rcF.top = rectF.top;
		rcF.right = m_ClientWidth / 2.0f - 375.0f + rectF.right;
		rcF.bottom = rectF.bottom;
		return rcF;
	}
}





```

`Source Code/GameApp.h`:

```h
#ifndef _GAMEAPP_H_
#define _GAMEAPP_H_
#include "d3dApp.h"
#include "Sprite.h"
#include "MKInput.h"
#include "PlaneManager.h"




enum class GameMode { 
	MENU,		// 主菜单
	CHOICE,		// 选择飞机界面
	PLAYING,	// 游戏中
	SETTING,	// 设置页面
	RANK,		// 排行榜
	PAUSE,		// 暂停
	SCORE,		// 结算页面
	COMPLETE	// 完成一关页面
};

class GameApp : public D3DApp
{
public:
	GameApp(HINSTANCE hInstance);
	~GameApp();

	bool Init();

	void InitFX();
	void Init2D();
	void InitDInput();
	void InitText();

	void OnResize();
	void UpdateScene(float dt);
	void DrawScene();

	void DrawGameSence();
	void DrawBackground();
	void DrawUI();

	void DrawMenu();
	void DrawChoice();
	void DrawPlaying();
	void DrawSetting();
	void DrawRank();
	void DrawPause();
	void DrawScore();
	void DrawComplete();

	void LoadHighScore();
	void StoreHighScore(const std::wstring& name, int score);

	void CheckMaxStage();
private:
	RECT ToScreenRect(const RECT& rect);
	D2D1_RECT_F ToScreenRectF(const D2D1_RECT_F& rectF);
	MKInput*									m_pMKInput;				// 键鼠输入
	
	D2DText										m_SmallFont;			// 小字体
	D2DText										m_MidFont;				// 中等字体
	D2DText										m_LargeFont;			// 大字体

	ID3DX11Effect*								m_pFX;					// Effects
	ID3DX11EffectTechnique*						m_pTech;				// Technique
	GameMode									m_Mode;					// 游戏模式
	std::vector<std::pair<std::wstring, int>>	m_HighScore;			// 高分
	wchar_t										m_Name[3][2];			// 用于设置名字

	int											m_MaxStage;				// 当前支持的关卡数

	

	std::map<std::string, Sprite2D>				m_Sprite2D;				// 精灵集合

};

#endif
```

`Source Code/GameTimer.cpp`:

```cpp
//***************************************************************************************
// GameTimer.cpp by Frank Luna (C) 2011 All Rights Reserved.
//***************************************************************************************

#include <windows.h>
#include "GameTimer.h"

GameTimer::GameTimer()
: mSecondsPerCount(0.0), mDeltaTime(-1.0), mBaseTime(0), 
  mPausedTime(0), mPrevTime(0), mCurrTime(0), mStopped(false)
{
	__int64 countsPerSec;
	QueryPerformanceFrequency((LARGE_INTEGER*)&countsPerSec);
	mSecondsPerCount = 1.0 / (double)countsPerSec;
}

// Returns the total time elapsed since Reset() was called, NOT counting any
// time when the clock is stopped.
float GameTimer::TotalTime()const
{
	// If we are stopped, do not count the time that has passed since we stopped.
	// Moreover, if we previously already had a pause, the distance 
	// mStopTime - mBaseTime includes paused time, which we do not want to count.
	// To correct this, we can subtract the paused time from mStopTime:  
	//
	//                     |<--paused time-->|
	// ----*---------------*-----------------*------------*------------*------> time
	//  mBaseTime       mStopTime        startTime     mStopTime    mCurrTime

	if( mStopped )
	{
		return (float)(((mStopTime - mPausedTime)-mBaseTime)*mSecondsPerCount);
	}

	// The distance mCurrTime - mBaseTime includes paused time,
	// which we do not want to count.  To correct this, we can subtract 
	// the paused time from mCurrTime:  
	//
	//  (mCurrTime - mPausedTime) - mBaseTime 
	//
	//                     |<--paused time-->|
	// ----*---------------*-----------------*------------*------> time
	//  mBaseTime       mStopTime        startTime     mCurrTime
	
	else
	{
		return (float)(((mCurrTime-mPausedTime)-mBaseTime)*mSecondsPerCount);
	}
}

float GameTimer::DeltaTime()const
{
	return (float)mDeltaTime;
}

void GameTimer::Reset()
{
	__int64 currTime;
	QueryPerformanceCounter((LARGE_INTEGER*)&currTime);

	mBaseTime = currTime;
	mPrevTime = currTime;
	mStopTime = 0;
	mStopped  = false;
}

void GameTimer::Start()
{
	__int64 startTime;
	QueryPerformanceCounter((LARGE_INTEGER*)&startTime);


	// Accumulate the time elapsed between stop and start pairs.
	//
	//                     |<-------d------->|
	// ----*---------------*-----------------*------------> time
	//  mBaseTime       mStopTime        startTime     

	if( mStopped )
	{
		mPausedTime += (startTime - mStopTime);	

		mPrevTime = startTime;
		mStopTime = 0;
		mStopped  = false;
	}
}

void GameTimer::Stop()
{
	if( !mStopped )
	{
		__int64 currTime;
		QueryPerformanceCounter((LARGE_INTEGER*)&currTime);

		mStopTime = currTime;
		mStopped  = true;
	}
}

void GameTimer::Tick()
{
	if( mStopped )
	{
		mDeltaTime = 0.0;
		return;
	}

	__int64 currTime;
	QueryPerformanceCounter((LARGE_INTEGER*)&currTime);
	mCurrTime = currTime;

	// Time difference between this frame and the previous.
	mDeltaTime = (mCurrTime - mPrevTime)*mSecondsPerCount;

	// Prepare for next frame.
	mPrevTime = mCurrTime;

	// Force nonnegative.  The DXSDK's CDXUTTimer mentions that if the 
	// processor goes into a power save mode or we get shuffled to another
	// processor, then mDeltaTime can be negative.
	if(mDeltaTime < 0.0)
	{
		mDeltaTime = 0.0;
	}
}


```

`Source Code/GameTimer.h`:

```h
//***************************************************************************************
// GameTimer.h by Frank Luna (C) 2011 All Rights Reserved.
//***************************************************************************************

#ifndef GAMETIMER_H
#define GAMETIMER_H

class GameTimer
{
public:
	GameTimer();

	float TotalTime()const;  // in seconds
	float DeltaTime()const; // in seconds

	void Reset(); // Call before message loop.
	void Start(); // Call when unpaused.
	void Stop();  // Call when paused.
	void Tick();  // Call every frame.

private:
	double mSecondsPerCount;
	double mDeltaTime;

	__int64 mBaseTime;
	__int64 mPausedTime;
	__int64 mStopTime;
	__int64 mPrevTime;
	__int64 mCurrTime;

	bool mStopped;
};

#endif // GAMETIMER_H
```

`Source Code/HLSL/Basic.hlsl`:

```hlsl
//=============================================================================
// Lighting.fx by Frank Luna (C) 2011 All Rights Reserved.
//
// Transforms and lights geometry.
//=============================================================================

#include "Basic.hlsli"

Vertex2DOut VS_2D(Vertex2DIn vin)
{
	// 2D贴图的深度为0.0f，总是在最前。计算变换后的2D点坐标
    Vertex2DOut vout;
    vout.PosH = mul(float4(vin.PosH, 0.0f, 1.0f), vin.World2D);
    vout.Tex = mul(float4(vin.Tex, 1.0f, 1.0f), gTexTransform).xy;
    return vout;
}

float4 PS_2D(Vertex2DOut pin) : SV_Target
{
    float4 texColor = gTexture.Sample(samAnisotropic, pin.Tex);

    // 根据图片的alpha值适当进行裁剪
    clip(texColor.a - 0.1f);

    return texColor;
}

TECH(Sprite2D)
{
    pass P0
    {
        SetVertexShader(CompileShader(vs_4_0, VS_2D()));
        SetGeometryShader(NULL);
        SetPixelShader(CompileShader(ps_4_0, PS_2D()));
    }
}

```

`Source Code/HLSL/Basic.hlsli`:

```hlsli


#define TECH(name) technique11 name


cbuffer cbPerObject
{
    float4x4 gWorld2D;           // 对裁剪空间坐标点的变换矩阵
    float4x4 gTexTransform;      // 对纹理坐标点的世界变换矩阵
};
Texture2D gTexture;

SamplerState samAnisotropic
{
    Filter = ANISOTROPIC;
    MaxAnisotropy = 4;

    AddressU = WRAP;
    AddressV = WRAP;
};


struct Vertex2DIn
{
    float2 PosH : POSITION;
    float2 Tex : TEXCOORD;
    row_major float4x4 World2D : WORLD;
    uint InstanceId : SV_InstanceID;
};

struct Vertex2DOut
{
    float4 PosH : SV_POSITION;
    float2 Tex : TEXCOORD;
};
```

`Source Code/MKInput.cpp`:

```cpp
#include "MKInput.h"
#include "d3dUtil.h"
MKInput* MKInput::m_MKInput = nullptr;
LPDIRECTINPUT8 MKInput::m_DInput = nullptr;
LPDIRECTINPUTDEVICE8 MKInput::m_pKeyboard = nullptr;
LPDIRECTINPUTDEVICE8 MKInput::m_pMouse = nullptr;
HWND MKInput::m_hWnd = nullptr;
IDXGISwapChain*	MKInput::m_pSwapChain = nullptr;
XINPUT_STATE	MKInput::m_XinputState;

void MKInput::Initialize(HWND hWnd, IDXGISwapChain*	pSwapChain)
{
	if (hWnd && !m_hWnd)
	{
		m_hWnd = hWnd;

		HR(DirectInput8Create(GetModuleHandle(nullptr), DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&m_DInput, nullptr));

		//初始化键盘
		HR(m_DInput->CreateDevice(GUID_SysKeyboard, &m_pKeyboard, nullptr));
		HR(m_pKeyboard->SetDataFormat(&c_dfDIKeyboard));
		HR(m_pKeyboard->SetCooperativeLevel(m_hWnd, DISCL_NONEXCLUSIVE | DISCL_FOREGROUND));
		m_pKeyboard->Acquire();

		//初始化鼠标
		HR(m_DInput->CreateDevice(GUID_SysMouse, &m_pMouse, nullptr));
		HR(m_pMouse->SetDataFormat(&c_dfDIMouse));
		HR(m_pMouse->SetCooperativeLevel(m_hWnd, DISCL_NONEXCLUSIVE | DISCL_FOREGROUND));
		m_pMouse->Acquire();
	}
	if (pSwapChain && !m_pSwapChain)
		m_pSwapChain = pSwapChain;
	
}

void MKInput::Release()
{
	if (m_MKInput)
	{
		delete m_MKInput;
		if (m_pKeyboard)
		{
			HR(m_pKeyboard->Unacquire());
			ReleaseCOM(m_pKeyboard);
		}
		if (m_pMouse)
		{
			HR(m_pMouse->Unacquire());
			ReleaseCOM(m_pMouse);
		}
		ReleaseCOM(m_DInput);
	}
	
}

MKInput * MKInput::GetMKInput()
{
	if (!m_MKInput)
		m_MKInput = new MKInput;
	return m_MKInput;
}

void MKInput::Update()
{
	// 更新键盘
	m_pKeyboard->Poll();
	ZeroMemory(m_keys, 256);
	if (m_pKeyboard->GetDeviceState(256, (LPVOID)&m_keys) < 0)
	{
		// 键盘设备丢失，尝试重新获取
		m_pKeyboard->Acquire();
	}

	// 更新鼠标
	m_pMouse->Poll();
	ZeroMemory(&m_MouseState, sizeof(DIMOUSESTATE));
	if (m_pMouse->GetDeviceState(sizeof(DIMOUSESTATE), &m_MouseState) < 0)
	{
		//鼠标设备丢失，尝试重新获取
		m_pMouse->Acquire();
	}

	// 更新XBox手柄
	ZeroMemory(&m_XinputState, sizeof m_XinputState);
	XInputGetState(0, &m_XinputState);

	/*	
		更新鼠标位置和按键
		由于实际的视口是指窗口内部不含边框的部分，窗口的上边框高度为38，下左右边框宽度均为9
	如果做成无边框，则需要删去被减掉的边框宽度值。
	*/
	GetCursorPos(&m_MousePos);
	GetWindowRect(m_hWnd, &m_WndRect);
	BOOL fullscreen;
	m_pSwapChain->GetFullscreenState(&fullscreen, nullptr);
	if (!fullscreen)
	{
		m_MousePos.x -= (m_WndRect.left + 9);
		m_MousePos.y -= (m_WndRect.top + 38);
		m_MousePos.x = MathHelper::Clamp(m_MousePos.x, 0L, m_WndRect.right - m_WndRect.left - 18);
		m_MousePos.y = MathHelper::Clamp(m_MousePos.y, 0L, m_WndRect.bottom - m_WndRect.top - 47);
	}
	
	

	// 只有第一次点击有效
	if (m_SingleClickLeft && Mouse_LongClick(MKMouse::LEFT))
		m_SingleClickLeft = false;
	if (m_SingleClickRight && Mouse_LongClick(MKMouse::RIGHT))
		m_SingleClickRight = false;

	// 判断鼠标左键长按并更新鼠标左键按下的位置
	if ((m_MouseState.rgbButtons[0] & 0x80) && !Mouse_LongClick(MKMouse::LEFT))
	{
		m_OnClickLeftPos = m_MousePos;
		m_LongClickLeft = m_SingleClickLeft = true;
	}
	else if (!(m_MouseState.rgbButtons[0] & 0x80) && Mouse_LongClick(MKMouse::LEFT))
	{
		m_LongClickLeft = false;
		m_OnClickLeftPos = POINT{ -1, -1 };
	}
		

	// 判断鼠标右键长按并更新鼠标右键按下的位置
	if ((m_MouseState.rgbButtons[1] & 0x80) && !Mouse_LongClick(MKMouse::RIGHT))
	{
		m_OnClickRightPos = m_MousePos;
		m_LongClickRight = m_SingleClickRight = true;
	}
	else if (!(m_MouseState.rgbButtons[1] & 0x80) && Mouse_LongClick(MKMouse::RIGHT))
	{
		m_LongClickRight = false;
		m_OnClickRightPos = POINT{ -1, -1 };
	}
		
	
}

bool MKInput::Mouse_SingleClick(MKMouse mouseEvent) const
{
	if (mouseEvent == MKMouse::LEFT)
		return m_SingleClickLeft;
	else if (mouseEvent == MKMouse::RIGHT)
		return m_SingleClickRight;
	return false;
}

bool MKInput::Mouse_LongClick(MKMouse mouseEvent) const
{
	if (mouseEvent == MKMouse::LEFT)
		return m_LongClickLeft;
	else if (mouseEvent == MKMouse::RIGHT)
		return m_LongClickRight;
	return false;
}

POINT MKInput::GetMouseClickPos(MKMouse mouseEvent) const
{
	if (mouseEvent == MKMouse::LEFT)
		return m_OnClickLeftPos;
	else if (mouseEvent == MKMouse::RIGHT)
		return m_OnClickRightPos;
	return POINT();
}



```

`Source Code/MKInput.h`:

```h
#pragma once
#define DIRECTINPUT_VERSION 0x0800
#define CORRECT_THUMBY 256	// 左滚轮修正值
#include <d3d11.h>
#include <dinput.h>
#include <Xinput.h>
#pragma comment(lib, "dinput8.lib")
#pragma comment(lib, "Xinput.lib")
enum class MKMouse { 
	LEFT,	//鼠标右键
	RIGHT	//鼠标左键
};

class MKInput {
public:

	// 初始化键盘和鼠标
	static void Initialize(HWND hWnd, IDXGISwapChain* pSwapChain);
	// 释放键盘和鼠标
	static void Release();
	// 获取键鼠对象的指针
	static MKInput* GetMKInput();
	// 更新键鼠事件
	void Update();

	// 鼠标单击
	bool Mouse_SingleClick(MKMouse mouseEvent) const;
	// 检测鼠标按键是否按住
	bool Mouse_LongClick(MKMouse mouseEvent) const;
	// 输出鼠标按键坐标
	POINT GetMouseClickPos(MKMouse mouseEvent) const;
	// 输出鼠标坐标
	POINT GetMousePos() const { return m_MousePos; }
	// 获取鼠标相对坐标位移XY
	POINT GetMouseLXY() const 
	{ 
		return POINT{ m_MouseState.lX, m_MouseState.lY }; 
	}
	// 获取鼠标滚轮量（上方向为正）
	int GetMouseLRoll() const { return m_MouseState.lZ / 120; }
	// 检测键盘按键
	bool Key_Down(int key) const { return (bool)(m_keys[key] & 0x80); }
	// 检测Xbox手柄按键
	bool XBoxHandle_ButtonDown(int key) const { return (bool)(m_XinputState.Gamepad.wButtons & key); }
	// 检测Xbox手柄LX
	SHORT XBoxHandle_ThumbLX() const { return m_XinputState.Gamepad.sThumbLX; }
	// 检测Xbox手柄LY
	SHORT XBoxHandle_ThumbLY() const { return m_XinputState.Gamepad.sThumbLY + CORRECT_THUMBY; };
private:
	MKInput() {}
	~MKInput() {}

	static MKInput*					m_MKInput;
	static LPDIRECTINPUT8			m_DInput;
	static HWND						m_hWnd;
	static LPDIRECTINPUTDEVICE8		m_pKeyboard;
	static LPDIRECTINPUTDEVICE8		m_pMouse;
	static IDXGISwapChain*			m_pSwapChain;
	static XINPUT_STATE				m_XinputState;

	char							m_keys[256];

	RECT							m_WndRect;
	DIMOUSESTATE					m_MouseState;
	POINT							m_MousePos;
	POINT							m_OnClickLeftPos;
	POINT							m_OnClickRightPos;
	bool							m_SingleClickLeft;
	bool							m_SingleClickRight;
	bool							m_LongClickLeft;
	bool							m_LongClickRight;

};
```

`Source Code/Main.cpp`:

```cpp
#include "GameApp.h"



int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE prevInstance,
	PSTR cmdLine, int showCmd)
{
	// Enable run-time memory check for debug builds.
#if defined(DEBUG) | defined(_DEBUG)
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif

	GameApp theApp(hInstance);

	if (!theApp.Init())
		return 0;

	return theApp.Run();
}


```

`Source Code/MathHelper.cpp`:

```cpp
//***************************************************************************************
// MathHelper.cpp by Frank Luna (C) 2011 All Rights Reserved.
//***************************************************************************************

#include "MathHelper.h"
#include <float.h>
#include <cmath>

const float MathHelper::Infinity = FLT_MAX;
const float MathHelper::Pi       = 3.1415926535f;

float MathHelper::AngleFromXY(float x, float y)
{
	float theta = 0.0f;
 
	// Quadrant I or IV
	if(x >= 0.0f) 
	{
		// If x = 0, then atanf(y/x) = +pi/2 if y > 0
		//                atanf(y/x) = -pi/2 if y < 0
		theta = atanf(y / x); // in [-pi/2, +pi/2]

		if(theta < 0.0f)
			theta += 2.0f*Pi; // in [0, 2*pi).
	}

	// Quadrant II or III
	else      
		theta = atanf(y/x) + Pi; // in [0, 2*pi).

	return theta;
}

XMVECTOR MathHelper::RandUnitVec3()
{
	XMVECTOR One  = XMVectorSet(1.0f, 1.0f, 1.0f, 1.0f);
	XMVECTOR Zero = XMVectorZero();

	// Keep trying until we get a point on/in the hemisphere.
	while(true)
	{
		// Generate random point in the cube [-1,1]^3.
		XMVECTOR v = XMVectorSet(MathHelper::RandF(-1.0f, 1.0f), MathHelper::RandF(-1.0f, 1.0f), MathHelper::RandF(-1.0f, 1.0f), 0.0f);

		// Ignore points outside the unit sphere in order to get an even distribution 
		// over the unit sphere.  Otherwise points will clump more on the sphere near 
		// the corners of the cube.

		if( XMVector3Greater( XMVector3LengthSq(v), One) )
			continue;

		return XMVector3Normalize(v);
	}
}

XMVECTOR MathHelper::RandHemisphereUnitVec3(XMVECTOR n)
{
	XMVECTOR One  = XMVectorSet(1.0f, 1.0f, 1.0f, 1.0f);
	XMVECTOR Zero = XMVectorZero();

	// Keep trying until we get a point on/in the hemisphere.
	while(true)
	{
		// Generate random point in the cube [-1,1]^3.
		XMVECTOR v = XMVectorSet(MathHelper::RandF(-1.0f, 1.0f), MathHelper::RandF(-1.0f, 1.0f), MathHelper::RandF(-1.0f, 1.0f), 0.0f);

		// Ignore points outside the unit sphere in order to get an even distribution 
		// over the unit sphere.  Otherwise points will clump more on the sphere near 
		// the corners of the cube.
		
		if( XMVector3Greater( XMVector3LengthSq(v), One) )
			continue;

		// Ignore points in the bottom hemisphere.
		if( XMVector3Less( XMVector3Dot(n, v), Zero ) )
			continue;

		return XMVector3Normalize(v);
	}
}
```

`Source Code/MathHelper.h`:

```h
//***************************************************************************************
// MathHelper.h by Frank Luna (C) 2011 All Rights Reserved.
//
// Helper math class.
//***************************************************************************************

#ifndef MATHHELPER_H
#define MATHHELPER_H

#include <Windows.h>
#include <xnamath.h>

class MathHelper
{
public:
	// Returns random float in [0, 1).
	static float RandF()
	{
		return (float)(rand()) / (float)RAND_MAX;
	}

	// Returns random float in [a, b).
	static float RandF(float a, float b)
	{
		return a + RandF()*(b-a);
	}

	template<typename T>
	static T Min(const T& a, const T& b)
	{
		return a < b ? a : b;
	}

	template<typename T>
	static T Max(const T& a, const T& b)
	{
		return a > b ? a : b;
	}
	 
	template<typename T>
	static T Lerp(const T& a, const T& b, float t)
	{
		return a + (b-a)*t;
	}

	template<typename T>
	static T Clamp(const T& x, const T& low, const T& high)
	{
		return x < low ? low : (x > high ? high : x); 
	}

	// Returns the polar angle of the point (x,y) in [0, 2*PI).
	static float AngleFromXY(float x, float y);

	static XMMATRIX InverseTranspose(CXMMATRIX M)
	{
		// Inverse-transpose is just applied to normals.  So zero out 
		// translation row so that it doesn't get into our inverse-transpose
		// calculation--we don't want the inverse-transpose of the translation.
		XMMATRIX A = M;
		A.r[3] = XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f);

		XMVECTOR det = XMMatrixDeterminant(A);
		return XMMatrixTranspose(XMMatrixInverse(&det, A));
	}

	static XMVECTOR RandUnitVec3();
	static XMVECTOR RandHemisphereUnitVec3(XMVECTOR n);

	static const float Infinity;
	static const float Pi;


};

#endif // MATHHELPER_H
```

`Source Code/PlaneManager.cpp`:

```cpp
#include "PlaneManager.h"

UserPlane PlaneManager::player;
std::list<EnemyPlane> PlaneManager::enemyPlanes;
std::list<EnemyPlane> PlaneManager::enemyPlaneInfo;
std::list<Bullet> PlaneManager::enemyBullets;
std::list<Bullet> PlaneManager::enemyLasers;
std::list<Bullet> PlaneManager::enemyFlames;
std::list<Bullet> PlaneManager::playerBullets;
std::list<Bullet> PlaneManager::playerFlames;
std::list<Item> PlaneManager::items;
std::vector<CommandSet> PlaneManager::enemyCommands;
std::multimap<int, std::string> PlaneManager::stageInfo;
MKInput* PlaneManager::pIn = nullptr;
int PlaneManager::score = 0;
int PlaneManager::stage = 1;
int PlaneManager::finalRate = 1;
int PlaneManager::totalFrameCnt = 0;
int PlaneManager::bossFrameCnt = 0;
int PlaneManager::bossKillFrameCnt = 0;
bool PlaneManager::noMiss = true;
bool PlaneManager::bossMode = false;
bool PlaneManager::debugMode = true;
bool PlaneManager::oneMillion = true;									
bool PlaneManager::twoMillion = true;									
bool PlaneManager::threeMillion = true;								
bool PlaneManager::fiveMillion = true;								
bool PlaneManager::eightMillion = true;		
bool PlaneManager::stageComplete = false;

std::ofstream PlaneManager::replayOut;
bool PlaneManager::replayMode = false;
time_t PlaneManager::randomSeed = 0;
std::map<int, std::map<unsigned short, unsigned short>> PlaneManager::replayInfo;

CSoundManager PlaneManager::csound;
std::map<std::string, CSound*>  PlaneManager::snd;
int PlaneManager::volume = 5;

EnemyPlane::EnemyPlane(int typeID, int HP, int score, int penalty, int minScore, float velX, float velY,
	 float posY, float width, float height, bool follow, bool inside, bool isRotating, std::string deathSnd, std::string texName)
	: m_TypeID(typeID), m_HP(HP), m_MaxHP(HP), m_Score(score), m_Penalty(penalty), m_MinScore(minScore),
	m_VelX(velX), m_VelY(velY), m_PosX(0.0f), m_PosY(posY), m_Width(width), m_Height(height), m_Alive(true),
	m_CurrFrameCnt(0), m_CurrCmd(0), m_Follow(follow), m_Inside(inside), m_IsRotating(isRotating), 
	m_DeathSnd(deathSnd), m_TexName(texName)
{
}

void EnemyPlane::InitAI(CommandSet* commandSet)
{
	m_pCmd = commandSet;
}

void EnemyPlane::SetPosX(int minPosX, int maxPosX)
{
	if (minPosX == maxPosX)
	{
		m_PosX = minPosX;
	}
	else
	{
		m_PosX = minPosX + rand() % (maxPosX - minPosX);
	}
}

void EnemyPlane::Update()
{
	// 判定存活
	if (m_HP <= 0)
	{
		m_Alive = false;
		// 死亡音效播放
		PlaneManager::snd[m_DeathSnd]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		PlaneManager::score += m_Score;
		// 若ID为3，在其位置生成一个Item
		if (m_TypeID == 3)
		{
			PlaneManager::items.emplace_front(m_PosX + m_Width / 2,
				m_PosY + m_Height / 2, m_Item);
		}
		return;
	}
	else if (m_PosX < -m_Width || m_PosX > 750 || m_PosY > 900 || (m_PosY < -m_Height && m_VelY < 0.0f))
	{
		m_Alive = false;
		return;
	}

	// 先检测主指令
	auto BegEnd = m_pCmd->mainCmd.equal_range(m_CurrFrameCnt);
	auto Beg = BegEnd.first, End = BegEnd.second;
	for (; Beg != End; ++Beg)
	{
		std::string& funcName = Beg->second.funcName;
		std::istringstream iss(Beg->second.funcArgs);
		int arg;
		if (funcName == "SetCmd")
		{
			// 候选指令集
			std::vector<int> nums;
			while (iss >> arg)
				nums.push_back(arg);
			// 从里面抽一个指令
			m_CurrCmd = nums[rand() % nums.size()];

		}
		else if (funcName == "SetFrame")
		{
			iss >> m_CurrFrameCnt;
		}
		else if (funcName == "SetFrameIfHPLess")
		{
			// 若血量小于等于HP，跳转到某FrameVal，清空弹幕
			iss >> arg;
			if (m_HP <= arg)
			{
				iss >> m_CurrFrameCnt;
				PlaneManager::snd["BLAST3"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
				PlaneManager::enemyFlames.clear();
				PlaneManager::enemyBullets.clear();
				PlaneManager::enemyLasers.clear();
			}
				
		}
	}

	// 然后检测分指令
	auto BegEnd2 = m_pCmd->Cmds[m_CurrCmd].equal_range(m_CurrFrameCnt);
	auto Beg2 = BegEnd2.first, End2 = BegEnd2.second;
	for (; Beg2 != End2; ++Beg2)
	{
		std::string& funcName = Beg2->second.funcName;
		std::istringstream iss(Beg2->second.funcArgs);
		if (funcName == "SetVelX")
		{
			float velX;
			iss >> velX;
			SetVelX(velX);
		}
		else if (funcName == "SetVelY")
		{
			float velY;
			iss >> velY;
			SetVelY(velY);
		}
		else if (funcName == "SetAwayVelX")
		{
			float velX;
			iss >> velX;
			SetAwayVelX(velX);
		}
		else if (funcName == "Shoot" && !PlaneManager::player.GetCrashFrameCnt())
		{
			int offsetX, offsetY;
			float vel, angle;
			iss >> offsetX >> offsetY >> vel;
			std::vector<int> angles;
			while (iss >> angle)
				angles.push_back(angle);
			Shoot(offsetX, offsetY, vel, angles);
		}
		else if (funcName == "ShootToPlayer" && !PlaneManager::player.GetCrashFrameCnt())
		{
			int offsetX, offsetY;
			float vel, angle;
			iss >> offsetX >> offsetY >> vel;
			std::vector<int> angles;
			while (iss >> angle)
				angles.push_back(angle);
			ShootToPlayer(offsetX, offsetY, vel, angles);
		}
		else if (funcName == "ShootRand" && !PlaneManager::player.GetCrashFrameCnt())
		{
			int offsetX, offsetY, nums;
			float vel, angle, offsetAngle;
			iss >> offsetX >> offsetY >> vel >> angle >> offsetAngle >> nums;
			ShootRand(offsetX, offsetY, vel, angle, offsetAngle, nums);
		}
		else if (funcName == "ShootToPlayerRand" && !PlaneManager::player.GetCrashFrameCnt())
		{
			int offsetX, offsetY, nums;
			float vel, offsetAngle;
			iss >> offsetX >> offsetY >> vel >> offsetAngle >> nums;
			ShootToPlayerRand(offsetX, offsetY, vel, offsetAngle, nums);
		}
		else if (funcName == "ShootLaser" && !PlaneManager::player.GetCrashFrameCnt())
		{
			int offsetX, offsetY;
			float vel;
			iss >> offsetX >> offsetY >> vel;
			ShootLaser(offsetX, offsetY, vel);
		}
		else if (funcName == "MakeLaserRand" && !PlaneManager::player.GetCrashFrameCnt())
		{
			int minX, maxX, nums;
			float vel;
			iss >> minX >> maxX >> vel >> nums;
			MakeLaserRand(minX, maxX, vel, nums);
		}
		else if (funcName == "ShootFlame" && !PlaneManager::player.GetCrashFrameCnt())
		{
			int offsetX, offsetY;
			float vel, angle;
			iss >> offsetX >> offsetY >> vel;
			std::vector<int> angles;
			while (iss >> angle)
				angles.push_back(angle);
			ShootFlame(offsetX, offsetY, vel, angles);
		}
		else if (funcName == "ShootFlameRand" && !PlaneManager::player.GetCrashFrameCnt())
		{
			int offsetX, offsetY, nums;
			float vel, angle, offsetAngle;
			iss >> offsetX >> offsetY >> vel >> angle >> offsetAngle >> nums;
			ShootFlameRand(offsetX, offsetY, vel, angle, offsetAngle, nums);
		}
		else if (funcName == "ShootFlameToPlayerRand" && !PlaneManager::player.GetCrashFrameCnt())
		{
			int offsetX, offsetY, nums;
			float vel, offsetAngle;
			iss >> offsetX >> offsetY >> vel >> offsetAngle >> nums;
			ShootFlameToPlayerRand(offsetX, offsetY, vel, offsetAngle, nums);
		}
		else if (funcName == "MakeFlameRand" && !PlaneManager::player.GetCrashFrameCnt())
		{
			int minX, maxX, nums;
			float vel;
			iss >> minX >> maxX >> vel >> nums;
			MakeFlameRand(minX, maxX, vel, nums);
		}
		else if (funcName == "Charge")
			PlaneManager::snd["CHARGE"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
	}

	// 是否横向跟随玩家
	if (m_Follow)
	{
		RECT rc = PlaneManager::player.GetRect();
		if (m_PosX + m_Width / 2 - 50.0f > (rc.right + rc.left) / 2.0f && m_VelX > 0.0f)
			m_VelX *= -1;
		else if (m_PosX + m_Width / 2 + 50.0f < (rc.right + rc.left) / 2.0f && m_VelX < 0.0f)
			m_VelX *= -1;
	}

	// 是否不跑出边界
	if (m_Inside)
	{
		if (m_PosX < 50.0f)
		{
			m_PosX = 50.0f;
			m_VelX = fabs(m_VelX);
		}
		else if (m_PosX > 700.0f - m_Width)
		{
			m_PosX = 700.0f - m_Width;
			m_VelX = -fabs(m_VelX);
		}
	}

	// 更新敌机
	m_PosX += m_VelX;
	m_PosY += m_VelY;
	// 每次更新都会降低得分
	if (m_Score > m_MinScore)
		m_Score -= m_Penalty;
	m_CurrFrameCnt++;
}

RECT EnemyPlane::GetRect() const
{
	return RECT{
		static_cast<LONG>(m_PosX),
		static_cast<LONG>(m_PosY),
		static_cast<LONG>(m_PosX + m_Width),
		static_cast<LONG>(m_PosY + m_Height),
	};
}

void EnemyPlane::Hurt(int val)
{
	m_HP -= val;
}

void EnemyPlane::Shoot(int offsetX, int offsetY, float vel, const std::vector<int>& angles)
{
	RECT rc = GetRect();
	for (auto angle : angles)
	{
		PlaneManager::enemyBullets.emplace_front(rc.left + offsetX, rc.top + offsetY,
			vel, DegToRad(angle), 16, 16);
	}
}

void EnemyPlane::ShootToPlayer(int offsetX, int offsetY, float vel, const std::vector<int>& angles)
{
	RECT rc = GetRect();
	RECT urc = PlaneManager::player.GetHitRect();
	float shootX = (float)rc.left + offsetX;
	float shootY = (float)rc.top + offsetY;
	float targetX = (urc.left + urc.right) / 2.0f;
	float targetY = (urc.bottom + urc.top) / 2.0f;
	float rad = atan2f(targetY - shootY, targetX - shootX);
	for (auto angle : angles)
	{
		PlaneManager::enemyBullets.emplace_front(shootX, shootY,
			vel, rad + DegToRad(angle), 16, 16);
	}
}

void EnemyPlane::ShootRand(int offsetX, int offsetY, float vel, int angle, int offsetAngle, int nums)
{
	RECT rc = GetRect();
	for (int i = 0; i < nums; ++i)
	{
		int randAngle = rand() % (2 * offsetAngle + 1) - offsetAngle;
		PlaneManager::enemyBullets.emplace_front(rc.left + offsetX, rc.top + offsetY,
			vel, DegToRad(angle + randAngle),
			16, 16);
	}
}

void EnemyPlane::ShootToPlayerRand(int offsetX, int offsetY, float vel, int offsetAngle, int nums)
{
	RECT rc = GetRect();
	RECT urc = PlaneManager::player.GetHitRect();
	float shootX = rc.left + offsetX;
	float shootY = rc.top + offsetY;
	float targetX = (urc.left + urc.right) / 2.0f;
	float targetY = (urc.bottom + urc.top) / 2.0f;
	float rad = atan2f(targetY - shootY, targetX - shootX);
	for (int i = 0; i < nums; ++i)
	{
		int randAngle = rand() % (2 * offsetAngle + 1) - offsetAngle;
		PlaneManager::enemyBullets.emplace_front(shootX, shootY,
			vel, rad + DegToRad(randAngle), 16, 16);
	}
}

void EnemyPlane::ShootLaser(int offsetX, int offsetY, float vel)
{
	RECT rc = GetRect();
	PlaneManager::snd["LASER"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
	PlaneManager::enemyLasers.emplace_front(rc.left + offsetX,
		rc.top + offsetY, vel, MathHelper::Pi / 2, 100, 10);
}

void EnemyPlane::MakeLaserRand(int minX, int maxX, float vel, int nums)
{
	
	PlaneManager::snd["LASER"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
	for (int i = 0; i < nums; ++i)
	{
		int posX = minX + rand() % (maxX - minX);
		PlaneManager::enemyLasers.emplace_front(posX, 0, vel, MathHelper::Pi / 2, 100, 10);
	}
	
}

void EnemyPlane::ShootFlame(int offsetX, int offsetY, float vel, const std::vector<int>& angles)
{
	PlaneManager::snd["VULCAN"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
	RECT rc = GetRect();
	for (auto angle : angles)
	{
		PlaneManager::enemyFlames.emplace_front(rc.left + offsetX, rc.top + offsetY,
			vel, DegToRad(angle), 60, 12);
	}
}

void EnemyPlane::ShootFlameRand(int offsetX, int offsetY, float vel, int angle, int offsetAngle, int nums)
{
	PlaneManager::snd["VULCAN"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
	RECT rc = GetRect();
	for (int i = 0; i < nums; ++i)
	{
		int randAngle = rand() % (2 * offsetAngle + 1) - offsetAngle;
		PlaneManager::enemyFlames.emplace_front(rc.left + offsetX, rc.top + offsetY,
			vel, DegToRad(angle + randAngle),
			60, 12);
	}
}

void EnemyPlane::ShootFlameToPlayerRand(int offsetX, int offsetY, float vel, int offsetAngle, int nums)
{
	PlaneManager::snd["VULCAN"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
	RECT rc = GetRect();
	RECT urc = PlaneManager::player.GetHitRect();
	float shootX = rc.left + offsetX;
	float shootY = rc.top + offsetY;
	float targetX = (urc.left + urc.right) / 2.0f;
	float targetY = (urc.bottom + urc.top) / 2.0f;
	float rad = atan2f(targetY - shootY, targetX - shootX);
	for (int i = 0; i < nums; ++i)
	{
		int randAngle = rand() % (2 * offsetAngle + 1) - offsetAngle;
		PlaneManager::enemyFlames.emplace_front(shootX, shootY,
			vel, rad + DegToRad(randAngle), 60, 12);
	}
}

void EnemyPlane::MakeFlameRand(int minX, int maxX, float vel, int nums)
{
	PlaneManager::snd["VULCAN"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
	for (int i = 0; i < nums; ++i)
	{
		int posX = minX + rand() % (maxX - minX);
		PlaneManager::enemyFlames.emplace_front(posX, 0, vel, MathHelper::Pi / 2, 60, 12);
	}
}










void UserPlane::Initialize(int typeID)
{
	if (typeID == 1)
	{	
		m_ShootSpeed = 6;
		m_Vel = 6.0f;
		m_MaxRate = 12;
		m_MaxWipeCnt = 12;
	}
	else if (typeID == 2)
	{
		m_ShootSpeed = 5;
		m_Vel = 8.0f;
		m_MaxRate = 16;
		m_MaxWipeCnt = 16;
	}
	m_TypeID = typeID;

	m_PosX = 335.0f;
	m_PosY = 750.0f;
	m_Lives = 4;
	m_Credits = 4;
	m_FireLevel = 1;
	m_Bombs = 3;
	m_Shields = 0;
	m_IsUndead = false;
	m_UseBomb = false;

	m_ShootFrameCnt = 0;
	m_HitFrameCnt = 0;
	m_CrashFrameCnt = 0;
	m_ComboFrameCnt = 0;
	m_BombFrameCnt = 0;

	m_WipeCnt = 0;

	m_CurrRate = 1;
	m_Alive = true;

	PlaneManager::oneMillion = true;
	PlaneManager::twoMillion = true;
	PlaneManager::threeMillion = true;
	PlaneManager::fiveMillion = true;
	PlaneManager::eightMillion = true;
}

void UserPlane::Respawn()
{
	m_Lives = 5;
	m_Credits--;
	m_IsUndead = true;
	m_UseBomb = false;

	m_ShootFrameCnt = 0;
	m_HitFrameCnt = 0;
	m_CrashFrameCnt = PlaneManager::totalFrameCnt - 119;
	m_ComboFrameCnt = 0;

	PlaneManager::items.emplace_front(300.0f, 200.0f, 1);
	PlaneManager::items.emplace_front(400.0f, 200.0f, 2);
	PlaneManager::items.emplace_front(500.0f, 200.0f, 1);
}

void UserPlane::Move(int X, int Y)
{
	m_PosX += X * m_Vel;
	m_PosY += Y * m_Vel;
	if (m_PosX < 0.0f)
		m_PosX = 0.0f;
	else if (m_PosX > 670.0f)
		m_PosX = 670.0f;

	if (m_PosY < 0.0f)
		m_PosY = 0.0f;
	else if (m_PosY > 800.0f)
		m_PosY = 800.0f;
}

void UserPlane::Shoot()
{
	static int shootCnt = 0;
	shootCnt++;
	if (m_TypeID == 1)
	{
		PlaneManager::snd["SHOT"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		auto shoot = [&](float angle) {
			PlaneManager::playerBullets.emplace_front(m_PosX + 40.0f, m_PosY + 0.0f, 18.0f, angle, 60, 12);
		};
		if (m_FireLevel == 1)
		{
			if (shootCnt % 2 == 0)
			{
				shoot(DegToRad(-86.0f));
				shoot(DegToRad(-94.0f));
			}
			else
			{
				shoot(DegToRad(-80.0f));
				shoot(DegToRad(-90.0f));
				shoot(DegToRad(-100.0f));
			}	
		}
		else if (m_FireLevel == 2)
		{
			if (shootCnt % 2 == 0)
			{
				shoot(DegToRad(-78.0f));
				shoot(DegToRad(-86.0f));
				shoot(DegToRad(-94.0f));
				shoot(DegToRad(-102.0f));
			}
			else
			{
				shoot(DegToRad(-80.0f));
				shoot(DegToRad(-90.0f));
				shoot(DegToRad(-100.0f));
			}
		}
		else if (m_FireLevel == 3)
		{
			if (shootCnt % 2 == 0)
			{
				shoot(DegToRad(-90.0f));
				shoot(DegToRad(-78.0f));
				shoot(DegToRad(-72.0f));
				shoot(DegToRad(-102.0f));
				shoot(DegToRad(-108.0f));
			}
			else
			{
				shoot(DegToRad(-75.0f));
				shoot(DegToRad(-84.0f));
				shoot(DegToRad(-96.0f));
				shoot(DegToRad(-105.0f));
			}
				
		}
	}
	else if (m_TypeID == 2)
	{
		PlaneManager::snd["SHOT2"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		auto shoot = [&](float pos) {
			PlaneManager::playerBullets.emplace_front(m_PosX + pos, m_PosY + 0.0f, 
				21.0f, DegToRad(-90.0f), 60, 12);
		};
		if (m_FireLevel == 1)
		{
				shoot(30.0f);
				shoot(50.0f);
		}
		else if (m_FireLevel == 2)
		{
				shoot(20.0f);
				shoot(40.0f);
				shoot(60.0f);
		}
		else if (m_FireLevel == 3)
		{
			if (shootCnt % 2 == 0)
			{
				shoot(10.0f);
				shoot(30.0f);
				shoot(50.0f);
				shoot(70.0f);
			}
			else
			{
				shoot(20.0f);
				shoot(40.0f);
				shoot(60.0f);
			}
		}
	}
}

RECT UserPlane::GetRect() const
{
	return RECT{
		static_cast<LONG>(m_PosX),
		static_cast<LONG>(m_PosY),
		static_cast<LONG>(m_PosX + 80),
		static_cast<LONG>(m_PosY + 100),
	};
	
}

RECT UserPlane::GetHitRect() const
{
	return RECT{
		static_cast<LONG>(m_PosX + 38),
		static_cast<LONG>(m_PosY + 48),
		static_cast<LONG>(m_PosX + 42),
		static_cast<LONG>(m_PosY + 52),
	};
}

void UserPlane::RecvItem(int typeID)
{
	// Bomb
	if (typeID == 1)
	{
		PlaneManager::snd["ITEM1"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		if (m_Bombs < 5)
			m_Bombs++;
		else
			PlaneManager::score += 30000;
	}
	// Power
	else if (typeID == 2)
	{
		PlaneManager::snd["ITEM0"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		if (m_FireLevel < 3)
			m_FireLevel++;
		else
			PlaneManager::score += 30000;
	}
	// Shield
	else if (typeID == 3)
	{
		PlaneManager::snd["ITEM2"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		if (!m_Shields)
			m_Shields = 3;
		else if (m_Shields < 3)
			m_Shields++;
		else
			PlaneManager::score += 30000;
	}
}

void UserPlane::Update(MKInput * pIn)
{
	// 死亡时间2s后重置
	if (m_CrashFrameCnt && m_Lives && PlaneManager::totalFrameCnt - m_CrashFrameCnt == 120)
	{
		m_Alive = true;
		m_IsUndead = true;
		m_PosX = 335.0f;
		m_PosY = 750.0f;
		m_Lives--;
		m_Bombs = 3;
		m_Shields = 0;
		m_FireLevel = 1;
		m_CurrRate = 1;
		m_WipeCnt = 0;
		m_HitFrameCnt = 0;
		// 掉落两个Item，一个Power，一个Shield
		PlaneManager::items.emplace_front(200.0f, 200.0f, 3);
		PlaneManager::items.emplace_front(600.0f, 200.0f, 2);
	}
	// 出现后敌方2s内不发射子弹
	if (m_CrashFrameCnt && PlaneManager::totalFrameCnt - m_CrashFrameCnt >= 240)
	{
		m_CrashFrameCnt = 0;
		m_IsUndead = false;
	}
	// 被击中后玩家2s无敌
	if (m_HitFrameCnt && PlaneManager::totalFrameCnt - m_HitFrameCnt >= 120)
	{
		m_HitFrameCnt = 0;
		m_IsUndead = false;
	}
	// 每5s恢复所有擦边次数
	if (PlaneManager::totalFrameCnt % 300 == 0)
		m_WipeCnt = 0;
	// 更新键盘响应事件
	if (m_Alive)
	{
		// 如果是回放模式
		if (PlaneManager::replayMode)
		{
			auto& info = PlaneManager::replayInfo[PlaneManager::stage];
			auto it = info.find(PlaneManager::totalFrameCnt);
			if (it != info.end())
			{
				if (it->second & REPLAY_UP)
					Move(0, -1);
				if (it->second & REPLAY_DOWN)
					Move(0, 1);
				if (it->second & REPLAY_LEFT)
					Move(-1, 0);
				if (it->second & REPLAY_RIGHT)
					Move(1, 0);
				// 限速射击
				if (!m_BombFrameCnt && (it->second & REPLAY_Z) &&
					PlaneManager::totalFrameCnt - m_ShootFrameCnt > m_ShootSpeed)
				{
					Shoot();
					m_ShootFrameCnt = PlaneManager::totalFrameCnt;
				}
				// 使用炸弹
				if (!m_BombFrameCnt && (it->second & REPLAY_X) && m_Bombs)
				{
					m_BombFrameCnt = PlaneManager::totalFrameCnt;
					m_Bombs--;
					m_IsUndead = m_UseBomb = true;
				}
				info.erase(it);
			}
		}
		else
		{
			unsigned short record[2]{};		//帧记录
			if (pIn->Key_Down(DIK_UPARROW) || pIn->XBoxHandle_ThumbLY() > 10000 || pIn->XBoxHandle_ButtonDown(XINPUT_GAMEPAD_DPAD_UP))
			{
				Move(0, -1);
				record[1] |= REPLAY_UP;
			}
			if (pIn->Key_Down(DIK_DOWNARROW) || pIn->XBoxHandle_ThumbLY() < -10000 || pIn->XBoxHandle_ButtonDown(XINPUT_GAMEPAD_DPAD_DOWN))
			{
				Move(0, 1);
				record[1] |= REPLAY_DOWN;
			}
			if (pIn->Key_Down(DIK_LEFTARROW) || pIn->XBoxHandle_ThumbLX() < -10000 || pIn->XBoxHandle_ButtonDown(XINPUT_GAMEPAD_DPAD_LEFT))
			{
				Move(-1, 0);
				record[1] |= REPLAY_LEFT;
			}
			if (pIn->Key_Down(DIK_RIGHTARROW) || pIn->XBoxHandle_ThumbLX() > 10000 || pIn->XBoxHandle_ButtonDown(XINPUT_GAMEPAD_DPAD_RIGHT))
			{
				Move(1, 0);
				record[1] |= REPLAY_RIGHT;
			}

			// 限速射击
			if (!m_BombFrameCnt && (pIn->Key_Down(DIK_Z) || pIn->XBoxHandle_ButtonDown(XINPUT_GAMEPAD_X)) &&
				PlaneManager::totalFrameCnt - m_ShootFrameCnt > m_ShootSpeed)
			{
				Shoot();
				m_ShootFrameCnt = PlaneManager::totalFrameCnt;
				record[1] |= REPLAY_Z;
			}
			// 使用炸弹
			if (!m_BombFrameCnt && (pIn->Key_Down(DIK_X) || pIn->XBoxHandle_ButtonDown(XINPUT_GAMEPAD_A)) && m_Bombs)
			{
				m_BombFrameCnt = PlaneManager::totalFrameCnt;
				m_Bombs--;
				m_IsUndead = m_UseBomb = true;
				record[1] |= REPLAY_X;
			}

			// 如果这一帧有动作，写入录像文件
			if (record[1])
			{
				record[0] = (unsigned short)PlaneManager::totalFrameCnt;
				PlaneManager::replayOut.write(reinterpret_cast<char *>(&record), sizeof(record));
			}
		}
		
		

		
	}
	// 更新炸弹
	UpdateBomb();

	// 检测分数是否达到奖命要求
	if (PlaneManager::oneMillion && PlaneManager::score >= 1000000)
	{
		PlaneManager::snd["1UP"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		PlaneManager::oneMillion = false;
		m_Lives++;
	}
	if (PlaneManager::twoMillion && PlaneManager::score >= 2000000)
	{
		PlaneManager::snd["1UP"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		PlaneManager::twoMillion = false;
		m_Lives++;
	}
	if (PlaneManager::threeMillion && PlaneManager::score >= 3000000)
	{
		PlaneManager::snd["1UP"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		PlaneManager::threeMillion = false;
		m_Lives++;
	}
	if (PlaneManager::fiveMillion && PlaneManager::score >= 5000000)
	{
		PlaneManager::snd["1UP"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		PlaneManager::fiveMillion = false;
		m_Lives++;
	}
	if (PlaneManager::eightMillion && PlaneManager::score >= 8000000)
	{
		PlaneManager::snd["1UP"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
		PlaneManager::eightMillion = false;
		m_Lives++;
	}

	// 长时间(3s)没有倍率贡献，降低一半倍率
	if (m_CurrRate > 1 && (PlaneManager::totalFrameCnt - m_ComboFrameCnt) > 180)
	{
		m_CurrRate /= 2;
		m_ComboFrameCnt = PlaneManager::totalFrameCnt;
	}
}

void UserPlane::UpdateBomb()
{
	// 炸弹持续3s
	if (m_BombFrameCnt && PlaneManager::totalFrameCnt - m_BombFrameCnt > 180)
	{
		m_BombFrameCnt = 0;
		m_IsUndead = m_UseBomb = false;
		return;
	}

	if (m_BombFrameCnt)
	{
		m_CurrRate = 1;	// 倍率强制降到1
		if (m_TypeID == 1 && PlaneManager::totalFrameCnt - m_ShootFrameCnt > m_ShootSpeed)
		{
			PlaneManager::snd["BOMBER1"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
			auto shoot = [&](float angle) {
				PlaneManager::playerBullets.emplace_front(m_PosX + 40.0f, m_PosY + 0.0f,
					18.0f, angle, 60, 12);
			};
			for (int i = 0; i < 7; ++i)
				shoot(DegToRad(-120.0f + i * 10.0f));
			m_ShootFrameCnt = PlaneManager::totalFrameCnt;
		}
		else if (m_TypeID == 2 && PlaneManager::totalFrameCnt - m_ShootFrameCnt > m_ShootSpeed)
		{
			PlaneManager::snd["CWS"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
			RECT playerRect = GetRect();
			PlaneManager::playerFlames.emplace_front(40.0f + playerRect.left, 100.0f + playerRect.top,
				36.0f, DegToRad(90.0f), 60, 12);
			m_ShootFrameCnt = PlaneManager::totalFrameCnt;
		}
	}

}

void UserPlane::Refresh()
{
	m_FireLevel = 1;
	m_BombFrameCnt = 0;
	m_ComboFrameCnt = 0;
	m_CrashFrameCnt = 0;
	m_CurrRate = 1;
	m_HitFrameCnt = 0;
	m_IsUndead = false;
	m_ShootFrameCnt = 0;
}

void UserPlane::LiftRate()
{
	if (m_CurrRate < m_MaxRate)
	{
		m_CurrRate++;
	}
	m_ComboFrameCnt = PlaneManager::totalFrameCnt;
}

void UserPlane::Hurt()
{
	if (m_Alive && !m_IsUndead)
	{
		// 有盾优先破盾，两秒无敌时间
		if (m_Shields > 0)
		{
			PlaneManager::snd["DAMAGE"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
			m_Shields--;
			m_HitFrameCnt = PlaneManager::totalFrameCnt;
			m_IsUndead = true;
		}
		else
		{
			// 没盾则死亡
			PlaneManager::snd["MYBLAST"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
			m_Alive = false;
			PlaneManager::noMiss = false;
			m_HitFrameCnt = m_CrashFrameCnt = PlaneManager::totalFrameCnt;
		}
	}
}





Bullet::Bullet(float posX, float posY, float vel, float radian, float width, float height)
	: m_PosX(posX), m_PosY(posY), m_Vel(vel), m_Rotation(radian),
	m_Width(width), m_Height(height), m_Alive(true), m_SideWipe(false)
{
}

void Bullet::Update()
{
	m_PosX += m_Vel * cosf(m_Rotation);
	m_PosY += m_Vel * sinf(m_Rotation);
	if (m_PosX < 0.0f || m_PosX > 750.0f || m_PosY < 0.0f || m_PosY > 900.0f)
		m_Alive = false;
}

void Bullet::Follow(const RECT & rect)
{
	float centerX = (rect.right + rect.left) / 2.0f;
	float centerY = (rect.top + rect.bottom) / 2.0f;
	float rad = atan2f(centerY - m_PosY, centerX - m_PosX);
	// 跟踪敌人
	float diff = m_Rotation - rad;
	if (diff < 0.0f)
		diff += MathHelper::Pi * 2;
	if (fmod(diff, MathHelper::Pi * 2) < 0.4f)
		m_Rotation = rad;
	else if (diff < MathHelper::Pi)
		m_Rotation -= 0.4f;
	else if (diff > MathHelper::Pi)
		m_Rotation += 0.4f;
	
	m_PosX += m_Vel * cosf(m_Rotation);
	m_PosY += m_Vel * sinf(m_Rotation);
	if (m_PosX < 0.0f || m_PosX > 750.0f || m_PosY < 0.0f || m_PosY > 1000.0f)
		m_Alive = false;
}

RECT Bullet::GetRect() const
{
	return RECT{
		static_cast<LONG>(m_PosX - m_Width / 2),
		static_cast<LONG>(m_PosY - m_Height / 2),
		static_cast<LONG>(m_PosX + m_Width / 2),
		static_cast<LONG>(m_PosY + m_Height / 2)
	};
}

RECT Bullet::GetHitRect() const
{
	// 激光射击方向固定，在这里作为另外判定
	if (m_Width > 80.0f)
	{
		return RECT{
			static_cast<LONG>(m_PosX - 5),
			static_cast<LONG>(m_PosY - 50),
			static_cast<LONG>(m_PosX + 5),
			static_cast<LONG>(m_PosY + 50)
		};
	}
	// 其余都做中心正方形判定
	else
	{
		LONG minLen = min(m_Width, m_Height);
		return RECT{
			static_cast<LONG>(m_PosX - minLen / 2),
			static_cast<LONG>(m_PosY - minLen / 2),
			static_cast<LONG>(m_PosX + minLen / 2),
			static_cast<LONG>(m_PosY + minLen / 2)
		};
	}
	
}

void PlaneManager::Initialize(HWND hWnd, MKInput * pIn)
{
	PlaneManager::pIn = pIn;
	csound.Initialize(hWnd, DSSCL_PRIORITY);
	csound.SetPrimaryBufferFormat(2, 22050, 16);
	// DSBCAPS_CTRLVOLUME可以控制音量
	csound.Create(&snd["SHOT"], L"Sound/SHOT.WAV", DSBCAPS_CTRLVOLUME, GUID_NULL, 20UL);
	csound.Create(&snd["SHOT2"], L"Sound/SHOT2.WAV", DSBCAPS_CTRLVOLUME, GUID_NULL, 20UL);
	csound.Create(&snd["BLAST1"], L"Sound/BLAST1.WAV", DSBCAPS_CTRLVOLUME, GUID_NULL, 20UL);
	csound.Create(&snd["BLAST2"], L"Sound/BLAST2.WAV", DSBCAPS_CTRLVOLUME, GUID_NULL, 20UL);
	csound.Create(&snd["BLAST3"], L"Sound/BLAST3.WAV", DSBCAPS_CTRLVOLUME, GUID_NULL, 20UL);
	csound.Create(&snd["BLAST4"], L"Sound/BLAST4.WAV", DSBCAPS_CTRLVOLUME);
	csound.Create(&snd["BOMBER1"], L"Sound/BOMBER1.WAV", DSBCAPS_CTRLVOLUME, GUID_NULL, 20UL);
	csound.Create(&snd["ITEM0"], L"Sound/ITEM0.WAV", DSBCAPS_CTRLVOLUME);
	csound.Create(&snd["ITEM1"], L"Sound/ITEM1.WAV", DSBCAPS_CTRLVOLUME);
	csound.Create(&snd["ITEM2"], L"Sound/ITEM2.WAV", DSBCAPS_CTRLVOLUME);
	csound.Create(&snd["MYBLAST"], L"Sound/MYBLAST.WAV", DSBCAPS_CTRLVOLUME);
	csound.Create(&snd["CWS"], L"Sound/CWS.WAV", DSBCAPS_CTRLVOLUME, GUID_NULL, 20UL);
	csound.Create(&snd["DAMAGE"], L"Sound/DAMAGE.WAV", DSBCAPS_CTRLVOLUME);
	csound.Create(&snd["SELECT"], L"Sound/SELECT.WAV", DSBCAPS_CTRLVOLUME);
	csound.Create(&snd["WARNING"], L"Sound/WARNING.WAV", DSBCAPS_CTRLVOLUME);
	csound.Create(&snd["START"], L"Sound/START.WAV", DSBCAPS_CTRLVOLUME, GUID_NULL, 5UL);
	csound.Create(&snd["LASER"], L"Sound/LASER.WAV", DSBCAPS_CTRLVOLUME, GUID_NULL, 20UL);
	csound.Create(&snd["CHARGE"], L"Sound/CHARGE.WAV", DSBCAPS_CTRLVOLUME, GUID_NULL, 5UL);
	csound.Create(&snd["1UP"], L"Sound/1UP.WAV", DSBCAPS_CTRLVOLUME);
	csound.Create(&snd["KASURI"], L"Sound/KASURI.WAV", DSBCAPS_CTRLVOLUME, GUID_NULL, 20UL);
	csound.Create(&snd["VULCAN"], L"Sound/VULCAN.WAV", DSBCAPS_CTRLVOLUME, GUID_NULL, 50UL);
}

void PlaneManager::Release()
{
	for (auto& ptr : snd)
	{
		if (ptr.second)
			delete ptr.second;
	}
}

void PlaneManager::InitEnemyPlanes()
{
	FILE * fp = fopen("Data/EnemyInfo.txt", "r");
	if (!fp)
	{
		MessageBox(0, L"找不到敌机信息文件！", 0, 0);
		exit(EXIT_FAILURE);
	}
	else
	{
		char buffer1[256], buffer2[256];
		int typeID, HP, score, penalty, minscore;
		float velX, velY, posY;
		int width, height, follow, inside, isRotating;
		
		enemyPlaneInfo.clear();
		while (fgets(buffer1, sizeof(buffer1), fp))
		{
			if (buffer1[0] == buffer1[1] && buffer1[0] == '/')
				continue;
			fscanf_s(fp, "%*s%d%*s%d%*s%d%*s%d%*s%d%*s%f%*s%f%*s%f%*s%d%*s%d%*s%d%*s%d%*s%d%*s%s%*s%s",
				&typeID, &HP, &score, &penalty, &minscore, &velX, &velY, &posY, &width,
				&height, &follow, &inside, &isRotating, buffer1, 256, buffer2, 256);

			enemyPlaneInfo.emplace_front(typeID, HP, score, penalty, minscore, 
				velX, velY, posY, width, height, follow, inside, isRotating, buffer1, buffer2);
			while (fgetc(fp) != '\n')
			{
				continue;
			}
		}
		fclose(fp);
	}
}

void PlaneManager::InitStage(int stage)
{
	PlaneManager::stage = stage;
	// 清空当前帧
	totalFrameCnt = 0;
	bossKillFrameCnt = 0;
	// 回归倍数
	finalRate = 1;
	// 标记NoMiss
	noMiss = true;
	// 清空Complete状态
	stageComplete = false;
	// 清空敌机、子弹、Item
	enemyPlanes.clear();
	enemyBullets.clear();
	enemyFlames.clear();
	enemyCommands.clear();
	enemyLasers.clear();
	playerBullets.clear();
	playerFlames.clear();
	stageInfo.clear();
	items.clear();

	// Boss模式下掉落两个Item
	if (bossMode)
	{
		// 掉落两个Item，一个Power，一个Shield
		PlaneManager::items.emplace_front(200.0f, 200.0f, 3);
		PlaneManager::items.emplace_front(600.0f, 200.0f, 2);
	}

	char fileName[MAX_PATH];
	sprintf_s(fileName, "Data/EnemyLevel%d.txt", stage);
	std::ifstream fin(fileName);
	// 读取关卡敌机的攻击方式
	if (!fin.is_open())
	{
		MessageBox(0, L"找不到敌机AI文件！", 0, 0);
		exit(EXIT_FAILURE);
	}
	else
	{
		std::string str, ignore;
		int typeID, cmdCount, frameCnt;
		Command lineCmd;
		// 清空旧指令
		enemyCommands.clear();
		while (!fin.eof())
		{		
			if (!(fin >> ignore >> typeID >> ignore >> cmdCount >> ignore))
				break;
			// 插入新指令集
			enemyCommands.push_back(CommandSet());
			enemyCommands.back().typeID = typeID;
			enemyCommands.back().Cmds.resize(cmdCount);
			// 读取主命令
			while (fin >> frameCnt >> lineCmd.funcName &&
				std::getline(fin, lineCmd.funcArgs))
			{
				enemyCommands.back().mainCmd.insert(std::make_pair(frameCnt, lineCmd));
			}
			fin.clear();
			std::getline(fin, ignore);
			// 读取命令集
			for (int i = 0; i < cmdCount; ++i)
			{
				while (fin >> frameCnt >> lineCmd.funcName &&
					std::getline(fin, lineCmd.funcArgs))
				{
					enemyCommands.back().Cmds[i].insert(std::make_pair(frameCnt, lineCmd));
				}
				fin.clear();
				std::getline(fin, ignore);
			}
		}
		fin.close();
	}
	
	sprintf_s(fileName, "Data/Stage%d.txt", stage);
	fin.open(fileName);
	// 读取关卡敌机的出场方式
	std::multimap<int, std::string> emptyMap;
	stageInfo.swap(emptyMap);
	if (!fin.is_open())
	{
		MessageBox(0, L"找不到关卡信息文件！", 0, 0);
		exit(EXIT_FAILURE);
	}
	else
	{
		std::string str;
		int frame;
		// 跳过前面的注释
		while (fin.peek() == '/')
			std::getline(fin, str);
		fin >> str >> bossFrameCnt;

		while (fin >> frame && std::getline(fin, str))
		{
			stageInfo.insert(std::make_pair(frame, str));
		}
		fin.close();

		if (bossMode)
			totalFrameCnt = bossFrameCnt - 1000;
	}


}

void PlaneManager::UpdateScene()
{
	// 添加敌机
	auto BegEnd = stageInfo.equal_range(totalFrameCnt);
	auto Beg = BegEnd.first, End = BegEnd.second;
	for (; Beg != End; ++Beg)
	{
		std::istringstream iss(Beg->second);
		int typeID, minPosX, maxPosX, item;
		// 对应typeID, minPosX, maxPosX
		iss >> typeID >> minPosX >> maxPosX;
		// 找到ID号对应已经初始化好的飞机复制过去
		auto itPlane = std::find_if(enemyPlaneInfo.begin(), enemyPlaneInfo.end(), [typeID](const EnemyPlane& plane) {
			return plane.GetTypeID() == typeID;
		});
		enemyPlanes.push_front(*itPlane);
		// 若飞机ID号为3，它会掉落道具
		if (typeID == 3)
		{
			iss >> item;
			enemyPlanes.front().SetItem(item);
		}
		// 找到ID号对应的指令集并初始化
		auto itCmd = std::find_if(enemyCommands.begin(), enemyCommands.end(), [typeID](const CommandSet& cmdSet) {
			return cmdSet.typeID == typeID;
		});
		enemyPlanes.front().InitAI(&*itCmd);
		// 初始化飞机位置
		enemyPlanes.front().SetPosX(minPosX, maxPosX);
	}

	// 碰撞检测
	RECT playerHitRect = player.GetHitRect();
	RECT playerRect = player.GetRect();
	bool playerHurt = false;
	
	// 玩家是否无敌且存活
	if (!PlaneManager::player.IsUndead() && PlaneManager::player.IsAlive())
	{
		// 检测己方与敌机的碰撞
		if (!playerHurt)
		{
			for (auto& plane : enemyPlanes)
			{
				if (plane.IsAlive() && RectCollision(playerHitRect, plane.GetRect()))
				{
					player.Hurt();
					playerHurt = true;
					break;
				}
			}
		}


		// 检测己方与子弹的碰撞
		if (!playerHurt)
		{
			for (auto& bullet : enemyBullets)
			{
				if (bullet.IsAlive() && RectCollision(playerHitRect, bullet.GetHitRect()))
				{
					bullet.Destroy();
					player.Hurt();
					playerHurt = true;
					break;
				}
			}
		}

		// 检测己方与激光的碰撞
		if (!playerHurt)
		{
			for (auto& laser : enemyLasers)
			{
				if (laser.IsAlive() && RectCollision(playerHitRect, laser.GetHitRect()))
				{
					laser.Destroy();
					player.Hurt();
					playerHurt = true;
					break;
				}
			}
		}

		// 检测己方与火焰的碰撞
		if (!playerHurt)
		{
			for (auto& flame : enemyFlames)
			{
				if (flame.IsAlive() && RectCollision(playerHitRect, flame.GetHitRect()))
				{
					flame.Destroy();
					player.Hurt();
					playerHurt = true;
					break;
				}
			}
		}
	}
	
	// 玩家是否存活
	if (player.IsAlive())
	{
		// 检测己方与子弹的擦边
		for (auto& bullet : enemyBullets)
		{
			if (!bullet.IsSideWipe() && RectCollision(playerRect, bullet.GetHitRect()))
			{
				if (player.HasWipe())
				{
					snd["CWS"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
					bullet.SetWipe();
					player.UseWipe();
					playerFlames.emplace_back(40.0f + playerRect.left, 100.0f + playerRect.top,
						36.0f, DegToRad(90.0f), 60, 12);
				}
				else
					snd["KASURI"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
				break;
			}
		}
	
		// 检测己方与激光的擦边
		for (auto& laser : enemyLasers)
		{
			if (!laser.IsSideWipe() && RectCollision(playerRect, laser.GetHitRect()))
			{
				if (player.HasWipe())
				{
					snd["CWS"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
					laser.SetWipe();
					player.UseWipe();
					playerFlames.emplace_back(40.0f + playerRect.left, 100.0f + playerRect.top,
						36.0f, DegToRad(90.0f), 60, 12);
				}
				else
					snd["KASURI"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
				break;
			}
		}

		// 检测己方与子弹的擦边
		for (auto& flame : enemyFlames)
		{
			if (!flame.IsSideWipe() && RectCollision(playerRect, flame.GetHitRect()))
			{
				if (player.HasWipe())
				{
					snd["CWS"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
					flame.SetWipe();
					player.UseWipe();
					playerFlames.emplace_back(40.0f + playerRect.left, 100.0f + playerRect.top,
						36.0f, DegToRad(90.0f), 60, 12);
				}
				else
					snd["KASURI"]->Play(0UL, 0UL, LevelToVolume(PlaneManager::volume));
				break;
			}
		}

		// 检测己方与Item的碰撞
		for (auto& item : items)
		{
			if (item.IsAlive() && RectCollision(playerRect, item.GetRect()))
			{
				item.Destroy();
				player.RecvItem(item.GetType());
				break;
			}
		}
	}

	// 检测敌方与己方子弹的碰撞
	for (auto& bullet : playerBullets)
	{
		for (auto& plane : enemyPlanes)
		{
			if (bullet.IsAlive() && plane.IsAlive() && 
				RectCollision(bullet.GetHitRect(), plane.GetRect()))
			{
				bullet.Destroy();
				if (!(PlaneManager::player.GetCrashFrameCnt() || PlaneManager::player.IsUsingBomb()) || plane.GetTypeID() != 15)
				{
					plane.Hurt(1);
					score += 10 * player.GetCurrRate();
				}
				break;
			}
		}
	}

	// 检测敌方与己方跟踪弹的碰撞
	for (auto& flame : playerFlames)
	{
		for (auto& plane : enemyPlanes)
		{
			if (flame.IsAlive() && plane.IsAlive() &&
				RectCollision(flame.GetHitRect(), plane.GetRect()))
			{
				flame.Destroy();
				if (!(PlaneManager::player.GetCrashFrameCnt() || PlaneManager::player.IsUsingBomb()) || plane.GetTypeID() != 15)
				{
					plane.Hurt(4);
					score += 40 * player.GetCurrRate();

					// 提升倍率，开炸弹的时候不更新倍率
					if (!player.IsUsingBomb())
						player.LiftRate();
				}
				break;
			}
		}
	}

	
	auto UpdateFlame = [&](Bullet& flame) { 
		if (flame.IsAlive())
		{
			if (enemyPlanes.empty())
				flame.Update();
			else
			{
				if (enemyPlanes.back().IsAlive())
					flame.Follow(enemyPlanes.back().GetRect());
				else
					flame.Update();
			}
				
		}
	};
	auto UpdateBullet = [](Bullet& bullet) {  if (bullet.IsAlive()) bullet.Update(); };
	auto UpdatePlane = [](EnemyPlane& plane) { if (plane.IsAlive()) plane.Update(); };
	auto UpdateItem = [](Item& item) { if (item.IsAlive()) item.Update(); };
	// 玩家被破盾 或者 玩家被击毁后刚出生的2s内 或者 玩家在放炸弹，清光敌人弹幕
	if ((playerHurt || player.GetCrashFrameCnt() || player.IsUsingBomb()) 
		&& player.IsAlive())
	{
		enemyBullets.clear();
		enemyLasers.clear();
		enemyFlames.clear();
	}
	else
	{
		// 更新敌方子弹
		std::for_each(enemyBullets.begin(), enemyBullets.end(), UpdateBullet);
		std::for_each(enemyLasers.begin(), enemyLasers.end(), UpdateBullet);
		std::for_each(enemyFlames.begin(), enemyFlames.end(), UpdateBullet);
	}
	// 更新敌方飞机
	std::for_each(enemyPlanes.begin(), enemyPlanes.end(), UpdatePlane);
	// 更新我方子弹
	std::for_each(playerBullets.begin(), playerBullets.end(), UpdateBullet);
	std::for_each(playerFlames.begin(), playerFlames.end(), UpdateFlame);
	// 更新物体
	std::for_each(items.begin(), items.end(), UpdateItem);
	// 更新玩家
	player.Update(pIn);


	// 清理死亡或飞出边界的敌机、子弹、道具等
	auto BulletDead = [](const Bullet& bullet) {return !bullet.IsAlive(); };
	auto EnemyPlaneDead = [](const EnemyPlane& plane) { return !plane.IsAlive(); };
	auto ItemDead = [](const Item& item) { return !item.IsAlive(); };
	enemyBullets.remove_if(BulletDead);
	enemyLasers.remove_if(BulletDead);
	enemyFlames.remove_if(BulletDead);
	playerBullets.remove_if(BulletDead);
	playerFlames.remove_if(BulletDead);
	enemyPlanes.remove_if(EnemyPlaneDead);
	items.remove_if(ItemDead);
	// 总帧数加1
	++totalFrameCnt;
}

void PlaneManager::InitReplay(LPCSTR filePath)
{
	std::ifstream fin(filePath, std::ios::in | std::ios::binary);
	// 初始化随机数
	fin.read(reinterpret_cast<char*>(&randomSeed), sizeof(time_t));
	srand((unsigned)randomSeed);
	// 初始化关卡
	int rpStage;
	fin.read(reinterpret_cast<char *>(&rpStage), sizeof(int));
	// 初始化Boss模式
	int rpBossMode;
	fin.read(reinterpret_cast<char *>(&rpBossMode), sizeof(int));
	bossMode = rpBossMode;
	InitStage(rpStage);
	// 初始化飞机类型
	int rpPlaneType;
	fin.read(reinterpret_cast<char *>(&rpPlaneType), sizeof(int));
	player.Initialize(rpPlaneType);
	// 读取关卡信息
	unsigned short data[2];
	replayInfo.clear();
	while (!fin.eof())
	{
		fin.read(reinterpret_cast<char *>(&data), sizeof(data));
		if (data[0] == 0xffff)
			rpStage = data[1];
		else
			replayInfo[rpStage][data[0]] = data[1];
	}
	fin.close();
}

void Item::Update()
{
	m_PosY += 2.0f;
	if (m_PosY > 900.0f)
		m_Alive = false;
}

RECT Item::GetRect() const
{
	return RECT{
		static_cast<LONG>(m_PosX - 25),
		static_cast<LONG>(m_PosY - 25),
		static_cast<LONG>(m_PosX + 25),
		static_cast<LONG>(m_PosY + 25),
	};
}

```

`Source Code/PlaneManager.h`:

```h
#pragma once
#include "XUtility.h"
#include "GameTimer.h"
#include "MKInput.h"
#include <map>
#include <queue>
#include <functional>
#include <list>
#include "DirectSound.h"
enum {
	REPLAY_UP = 1,		// 回放上按键
	REPLAY_DOWN = 2,	// 回放下按键
	REPLAY_LEFT = 4,	// 回放左按键
	REPLAY_RIGHT = 8,	// 回放右按键
	REPLAY_Z = 16,		// 回放Z按键
	REPLAY_X = 32,		// 回放X按键
	REPLAY_EXIT = 65535	// 退出
};


struct Command
{
	std::string funcName;	// 函数名
	std::string funcArgs;	// 函数参数
};

struct CommandSet {
	int typeID;											// 敌机ID
	std::multimap<int, Command> mainCmd;				// 主指令集
	std::vector<std::multimap<int, Command>> Cmds;		// 分指令集
};

class EnemyPlane {
public:
	EnemyPlane(int typeID, int HP, int score, int penalty, int minScore,
		float velX, float velY, float posY, float width, float height,
		bool follow, bool inside, bool isRotating, std::string deathSnd, std::string texName);
	// 获取ID信息
	int GetTypeID() const { return m_TypeID; }
	// 按关卡来初始化敌机
	void InitAI(CommandSet* commandSet);
	// 设置初始位置
	void SetPosX(int minPosX, int maxPosX);
	// 设置道具
	void SetItem(int item) { m_Item = (m_TypeID == 3 && item > 0 && item < 4) ? item : 0; }
	// 更新敌机
	void Update();
	// 获取帧数
	int GetCurrFrameCnt() const { return m_CurrFrameCnt; }
	// 获取需要绘制的血条数
	int GetHealthSlices() const { return 100 * m_HP / m_MaxHP; }
	// 获取击中/绘制判定矩形
	RECT GetRect() const;
	// 获取纹理名
	std::string GetTexName() const { return m_TexName; }
	// 判断是否存活
	bool IsAlive() const { return m_Alive; }
	// 判断是否会旋转
	bool IsRotating() const { return m_IsRotating; }
	// 受到伤害
	void Hurt(int val);
private:
	// 朝一个或多个角度发射子弹，angle为朝向角度，vel为速度，offsetXY决定初射位置
	void Shoot(int offsetX, int offsetY, float vel, const std::vector<int>& angles);
	// 向玩家发射一个或多个子弹，angle为偏移角度，vel为速度，offsetXY决定初射位置
	void ShootToPlayer(int offsetX, int offsetY, float vel, const std::vector<int>& angles);
	// 沿着朝向角度angle偏移+-offsetAngle角度射出nums发子弹，vel为速度，offsetXY决定初射位置
	void ShootRand(int offsetX, int offsetY, float vel, int angle, int offsetAngle, int nums);
	// 向玩家偏移+-offsetAngle角度射出nums发子弹，vel为速度，offsetXY决定初射位置
	void ShootToPlayerRand(int offsetX, int offsetY, float vel, int offsetAngle, int nums);
	// 发射激光
	void ShootLaser(int offsetX, int offsetY, float vel);
	// 制造激光
	void MakeLaserRand(int minX, int maxX, float vel, int nums);
	// 朝一个或多个角度发射火焰，angle为朝向角度，vel为速度，offsetXY决定初射位置
	void ShootFlame(int offsetX, int offsetY, float vel, const std::vector<int>& angles);
	// 沿着朝向角度angle偏移+-offsetAngle角度射出nums发火焰，vel为速度，offsetXY决定初射位置
	void ShootFlameRand(int offsetX, int offsetY, float vel, int angle, int offsetAngle, int nums);
	// 向玩家偏移+-offsetAngle角度射出nums发火焰，vel为速度，offsetXY决定初射位置
	void ShootFlameToPlayerRand(int offsetX, int offsetY, float vel, int offsetAngle, int nums);
	// 制造火焰
	void MakeFlameRand(int minX, int maxX, float vel, int nums);
	// 修改速度X
	void SetVelX(float velX) { m_VelX = velX; }
	// 修改速度Y
	void SetVelY(float velY) { m_VelY = velY; }
	// 修改速度X，当velX > 0的时候，若此时飞机在屏幕左侧，速度向左；反之向右
	void SetAwayVelX(float velX) { m_VelX = (m_PosX <= 375.0 ? -1 : 1) * velX; }
private:
	int m_TypeID;			// 标识ID
	int m_HP;				// 血量
	int m_MaxHP;			// 最大血量
	int m_Score;			// 总得分
	int m_Penalty;			// 帧惩罚
	int m_MinScore;			// 最低得分
	float m_VelX;			// 横向速度
	float m_VelY;			// 纵向速度
	float m_PosX;			// 飞机左上角对应X位置
	float m_PosY;			// 飞机左上角对应Y位置
	int m_Width;			// 飞机宽度
	int m_Height;			// 飞机高度
	int m_Item;				// 加强包类型：0为无，1为Bomb，2为Shield，3为Power
	bool m_Follow;			// 是否追随玩家
	bool m_Inside;			// 是否不跑出边界
	bool m_Alive;			// 是否存活
	bool m_IsRotating;		// 运动时是否旋转
	std::string m_DeathSnd;	// 死亡音效
	std::string m_TexName;	// 纹理文件名（不需要包含后缀.png）

	CommandSet*	m_pCmd;		// 指令集		
	int m_CurrFrameCnt;		// 当前帧数
	int m_CurrCmd;			// 当前执行的分指令
};

class UserPlane {
public:
	// 初始化用户飞机
	void Initialize(int typeID);
	// 重生
	void Respawn();
	// 设置移动
	void Move(int X, int Y);
	// 射击
	void Shoot();
	// 使用擦边弹
	void UseWipe() { m_WipeCnt++; }
	// 获取typeID
	int GetTypeID() const { return m_TypeID; }
	// 获取绘制/擦边判定矩阵
	RECT GetRect() const;
	// 获取击中判定矩阵
	RECT GetHitRect() const;
	// 获取剩余生命数
	int GetLives() const { return m_Lives; }
	// 获取剩余硬币数
	int GetCredits() const { return m_Credits; }
	// 获取剩余护盾数
	int GetShields() const { return m_Shields; }
	// 获取剩余炸弹数
	int GetBombs() const { return m_Bombs; }
	// 获取被击中的帧
	int GetHitFrameCnt() const { return m_HitFrameCnt; }
	// 获取被击毁的帧
	int GetCrashFrameCnt() const { return m_CrashFrameCnt; }
	// 获取倍率
	int GetCurrRate() const { return m_CurrRate; }
	//  得到Item
	void RecvItem(int typeID);
	// 更新飞机
	void Update(MKInput* pIn);
	// 更新炸弹使用
	void UpdateBomb();
	// 刷新，完成一关后使用
	void Refresh();
	// 提升倍率
	void LiftRate();
	// 受伤
	void Hurt();

	// 是否存有擦边弹
	bool HasWipe() const { return m_WipeCnt < m_MaxWipeCnt; }
	// 是否存活
	bool IsAlive() const { return m_Alive; }
	// 是否无敌状态
	bool IsUndead() const { return m_IsUndead; }
	// 是否在放炸弹
	bool IsUsingBomb() const { return m_UseBomb; }
private:
	int m_TypeID;			// 标识ID
	int m_Lives;			// 剩余生命数
	int m_Credits;			// 剩余硬币
	int m_FireLevel;		// 火力等级
	int m_Bombs;			// 炸弹数
	int m_Shields;			// 护盾数
	float m_Vel;			// 移动速度
	
	bool m_IsUndead;		// 不死状态
	bool m_Alive;			// 存活
	bool m_UseBomb;			// 使用炸弹中

	int m_MaxRate;			// 最大倍率
	int m_CurrRate;			// 当前倍率

	int m_WipeCnt;			// 擦边次数
	int m_MaxWipeCnt;		// 最大擦边次数

	int m_HitFrameCnt;		// 被击中的时间帧
	int m_BombFrameCnt;		// X键按下的时间帧
	int m_CrashFrameCnt;	// 击坠的时间帧
	int m_ComboFrameCnt;	// 追踪弹连击时间帧
	int m_ShootFrameCnt;	// 发射子弹的时间帧
	int m_ShootSpeed;		// 射击帧间隔
	

	float m_PosX;			// 飞机左上角对应X位置
	float m_PosY;			// 飞机左上角对应Y位置

};

class Bullet
{
public:
	Bullet(float posX, float posY, float vel, float radian, float width, float height);
	void Update();
	void Follow(const RECT& rect);
	RECT GetRect() const;
	RECT GetHitRect() const;
	float GetRotation() const { return m_Rotation; }
	bool IsAlive() const { return m_Alive; }
	bool IsSideWipe() const { return m_SideWipe; }
	void Destroy() { m_Alive = false; }
	void SetWipe() { m_SideWipe = true; }
private:
	float m_PosX;		// 子弹中心对应X位置		
	float m_PosY;		// 子弹中心对应Y位置
	float m_Vel;		// 子弹速度
	float m_Rotation;	// 子弹旋转
	float m_Width;		// 子弹宽度
	float m_Height;		// 子弹高度
	bool m_Alive;		// 子弹存活
	bool m_SideWipe;	// 子弹擦边
};

class Item
{
public:
	Item(float posX, float posY, int type)
		: m_PosX(posX), m_PosY(posY), m_Type(type), m_Alive(true)
	{
	}
	void Update();
	int  GetType() const { return m_Type; }
	RECT GetRect() const;
	bool IsAlive() const { return m_Alive; }
	void Destroy() { m_Alive = false; }
private:
	float m_PosX;	// 位置X
	float m_PosY;	// 位置Y
	int   m_Type;	// 加强包类型
	bool  m_Alive;	// 存活
};

struct PlaneManager {

	static UserPlane player;									// 己方战机				
	static std::list<EnemyPlane> enemyPlanes;					// 敌方战机（存活在屏幕上的）
	static std::list<EnemyPlane> enemyPlaneInfo;				// 敌方战机信息
	static std::list<Bullet> enemyBullets;						// 敌方子弹（存活在屏幕上的）
	static std::list<Bullet> enemyLasers;						// 敌方激光（存活在屏幕上的）
	static std::list<Bullet> enemyFlames;						// 敌方火焰（存活在屏幕上的）
	static std::list<Bullet> playerBullets;						// 玩家子弹（存活在屏幕上的）
	static std::list<Bullet> playerFlames;						// 玩家跟踪弹（存活在屏幕上的）
	static std::list<Item> items;								// 物体
	static std::vector<CommandSet> enemyCommands;				// 敌方战机指令集
	static std::multimap<int, std::string> stageInfo;			// 当前关卡的灰机控制
	
	static int score;											// 得分
	static int stage;											// 当前关卡

	static bool replayMode;										// 回放模式
	static bool bossMode;										// boss模式
	static bool debugMode;										// debug模式

	static bool noMiss;											// 这场战斗没有死亡
	static bool oneMillion;										// 一百万分奖一条命
	static bool twoMillion;										// 两百万分奖一条命
	static bool threeMillion;									// 三百万分奖一条命
	static bool fiveMillion;									// 五百万分奖一条命
	static bool eightMillion;									// 八百万分奖一条命
	static bool stageComplete;									// 完成所有关卡
	static int finalRate;										// 最终倍率
	static int totalFrameCnt;									// 当前总帧
	static int bossFrameCnt;									// 当前关卡到boss出场前占用的帧数
	static int bossKillFrameCnt;								// boss被击杀的帧数
	static MKInput* pIn;										// 键鼠输入设备

	static CSoundManager csound;								// 声音管理者
	static std::map<std::string, CSound*> snd;					// 射击
	static int volume;											// 音量

	static std::map<int, std::map<unsigned short, unsigned short>> replayInfo;	// 回放内容
	static time_t randomSeed;									// 随机数种子					
	static std::ofstream replayOut;								// 输出录像文件流

	static void Initialize(HWND hWnd, MKInput* pIn);			// 初始化键鼠、声音设备
	static void Release();										// 释放声音
	static void InitEnemyPlanes();								// 初始化敌机
	static void InitStage(int stage);							// 初始化关卡敌机AI
	static void UpdateScene();									// 更新场景，清除非存活物

	static void InitReplay(LPCSTR filePath);					// 初始化回放									
};
```

`Source Code/Sprite.cpp`:

```cpp
#include "Sprite.h"
#include "XUtility.h"

ID3D11Device* SpriteManager::m_pDevice = nullptr;
ID3D11DeviceContext* SpriteManager::m_pDeviceContext = nullptr;
ID3DX11Effect* SpriteManager::m_pFX = nullptr;
IDXGISwapChain* SpriteManager::m_pSwapChain = nullptr;
HWND SpriteManager::m_hWnd = nullptr;


ID3DX11EffectTechnique* Sprite2D::m_pTech = nullptr;
ID3D11InputLayout* Sprite2D::m_pInputLayout = nullptr;
ID3D11Buffer* Sprite2D::m_pVertexBuffer = nullptr;
ID3D11Buffer* Sprite2D::m_pIndexBuffer = nullptr;
ID3D11Buffer* Sprite2D::m_pInstancedBuffer = nullptr;
ID3DX11EffectShaderResourceVariable* Sprite2D::m_pFXTexture = nullptr;	
ID3DX11EffectMatrixVariable* Sprite2D::m_pFXTexTransform = nullptr;	






SpriteManager::SpriteManager()
{
}

SpriteManager::~SpriteManager()
{
}

void SpriteManager::InitSprite(HWND hWnd, ID3D11DeviceContext * devContext, IDXGISwapChain* pSwapChain, ID3DX11Effect* pFX)
{
	if (!m_hWnd)
		m_hWnd = hWnd;
	if (!m_pDeviceContext)
	{
		m_pDeviceContext = devContext;
		m_pDeviceContext->GetDevice(&m_pDevice);
	}
	if (!m_pFX)
		m_pFX = pFX;
	if (!m_pSwapChain)
		m_pSwapChain = pSwapChain;
}




Sprite2D::Sprite2D()
	:  m_pTexture(nullptr), m_TexHeight(256), m_TexWidth(256)
{	
}

Sprite2D::~Sprite2D()
{
	ReleaseCOM(m_pTexture);
}

void Sprite2D::InitTexture(LPCSTR texFile)
{
	if (!m_pTexture)
	{
		// 获取图片信息
		GetPictureInfo(texFile, &m_TexWidth, &m_TexHeight);

		// 初始化纹理
		HR(D3DX11CreateShaderResourceViewFromFileA(GetDevice(),
			texFile, 0, 0, &m_pTexture, 0));

		// 初始化矩阵
		m_Instances.resize(1);
		XMStoreFloat4x4(&m_Instances[0], XMMatrixIdentity());
		XMStoreFloat4x4(&m_TexTransform, XMMatrixIdentity());
	}
}



void Sprite2D::Draw()
{
	if (m_Instances.empty())
		return;

	GetDeviceContext()->IASetInputLayout(m_pInputLayout);
	GetDeviceContext()->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);	//图元类型

	UINT stride[2] = { sizeof(Vertex), sizeof(XMFLOAT4X4) };
	UINT offset[2] = { 0, 0 };
	ID3D11Buffer* vbs[2] = { m_pVertexBuffer, m_pInstancedBuffer };

	GetDeviceContext()->IASetVertexBuffers(0, 2, vbs, stride, offset);
	GetDeviceContext()->IASetIndexBuffer(m_pIndexBuffer, DXGI_FORMAT_R32_UINT, 0);

	m_pFXTexture->SetResource(m_pTexture);
	m_pFXTexTransform->SetMatrix((const float *)&m_TexTransform);

	D3D11_MAPPED_SUBRESOURCE mappedData;
	GetDeviceContext()->Map(m_pInstancedBuffer, 0,
		D3D11_MAP_WRITE_DISCARD, 0, &mappedData);

	XMFLOAT4X4* dataView = reinterpret_cast<XMFLOAT4X4*>(mappedData.pData);
	memcpy(dataView, m_Instances.data(), sizeof(XMFLOAT4X4) * m_Instances.size());
	GetDeviceContext()->Unmap(m_pInstancedBuffer, 0);

	m_pTech->GetPassByIndex(0)->Apply(0, GetDeviceContext());
	GetDeviceContext()->DrawIndexedInstanced(4, m_Instances.size(), 0, 0, 0);
	
}

// 选取绘制区域和目标区域
void Sprite2D::StretchRect(const RECT* pSrcRect, const RECT* pDestRect, const POINT* pCenter, float radian)
{
	m_Instances.resize(1);
	XMStoreFloat4x4(&m_TexTransform, XMMatrixIdentity());
	if (pSrcRect)
	{
		// 算出源矩形的纹理坐标范围
		float texLeft = static_cast<float>(pSrcRect->left) / m_TexWidth;
		float texRight = static_cast<float>(pSrcRect->right) / m_TexWidth;
		float texTop = static_cast<float>(pSrcRect->top) / m_TexHeight;
		float texBottom = static_cast<float>(pSrcRect->bottom) / m_TexHeight;
		// 设置映射矩阵
		m_TexTransform(0, 0) = texRight - texLeft;
		m_TexTransform(1, 1) = texBottom - texTop;
		m_TexTransform(2, 0) = texLeft;
		m_TexTransform(2, 1) = texTop;
	}
	
	if (pDestRect)
	{
		// 目标矩形的宽高
		LONG destRectWidth = pDestRect->right - pDestRect->left;
		LONG destRectHeight = pDestRect->bottom - pDestRect->top;
		RECT wndRect;
		GetWindowRect(GetWindow(), &wndRect);
		// 视口宽高
		LONG vpWidth = wndRect.right - wndRect.left;
		LONG vpHeight = wndRect.bottom - wndRect.top;
		if (!IsFullScreen())
		{
			vpWidth -= 18;
			vpHeight -= 47;
		}
		// 目标矩形中心位置
		POINT center;
		if (pCenter)
			center = *pCenter;
		else
			center = { (pDestRect->right + pDestRect->left) / 2, (pDestRect->bottom + pDestRect->top) / 2 };
		// 缩放比例
		float scaleX = static_cast<float>(destRectWidth) / vpWidth;
		float scaleY = static_cast<float>(destRectHeight) / vpHeight;
		// 旋转矩阵
		XMMATRIX xmRotate;
		ZeroMemory(&xmRotate, sizeof(XMMATRIX));
		xmRotate(0, 0) = cos(radian);
		xmRotate(0, 1) = (float)vpWidth / vpHeight * sin(radian);
		xmRotate(1, 0) = -(float)vpHeight / vpWidth * sin(radian);
		xmRotate(1, 1) = cos(radian);
		xmRotate(2, 2) = 1.0f;
		xmRotate(3, 3) = 1.0f;
		// 平移偏移量
		float offsetX = static_cast<float>(center.x - vpWidth / 2) / vpWidth * 2;
		float offsetY = -(static_cast<float>(center.y - vpHeight / 2) / vpHeight * 2);

		XMStoreFloat4x4(&m_Instances[0], XMMatrixScaling(scaleX, scaleY, 1.0f) *
			xmRotate * XMMatrixTranslation(offsetX, offsetY, 0.0f));
	}
	else
		XMStoreFloat4x4(&m_Instances[0], XMMatrixIdentity());
}

void Sprite2D::StretchRects(const std::vector<RECT>& DestRects,const std::vector<float>& radians)
{
	XMStoreFloat4x4(&m_TexTransform, XMMatrixIdentity());
	int sz = DestRects.size();
	m_Instances.resize(sz);
	for (int i = 0; i < sz; ++i)
	{
		// 目标矩形的宽高
		LONG destRectWidth = DestRects[i].right - DestRects[i].left;
		LONG destRectHeight = DestRects[i].bottom - DestRects[i].top;
		RECT wndRect;
		GetWindowRect(GetWindow(), &wndRect);
		// 视口宽高
		LONG vpWidth = wndRect.right - wndRect.left;
		LONG vpHeight = wndRect.bottom - wndRect.top;
		if (!IsFullScreen())
		{
			vpWidth -= 18;
			vpHeight -= 47;
		}
		// 目标矩形中心位置
		POINT center = { (DestRects[i].right + DestRects[i].left) / 2,
			(DestRects[i].bottom + DestRects[i].top) / 2 };
		// 缩放比例
		float scaleX = static_cast<float>(destRectWidth) / vpWidth;
		float scaleY = static_cast<float>(destRectHeight) / vpHeight;
		// 旋转矩阵
		XMMATRIX xmRotate;
		ZeroMemory(&xmRotate, sizeof(XMMATRIX));
		xmRotate(0, 0) = cos(radians[i]);
		xmRotate(0, 1) = (float)vpWidth / vpHeight * sin(radians[i]);
		xmRotate(1, 0) = -(float)vpHeight / vpWidth * sin(radians[i]);
		xmRotate(1, 1) = cos(radians[i]);
		xmRotate(2, 2) = 1.0f;
		xmRotate(3, 3) = 1.0f;
		// 平移偏移量
		float offsetX = static_cast<float>(center.x - vpWidth / 2) / vpWidth * 2;
		float offsetY = -(static_cast<float>(center.y - vpHeight / 2) / vpHeight * 2);

		XMStoreFloat4x4(&m_Instances[i], XMMatrixScaling(scaleX, scaleY, 1.0f) *
			xmRotate * XMMatrixTranslation(offsetX, offsetY, 0.0f));
	}
}




// 初始化2D
void Sprite2D::Initialize(HWND hWnd, ID3D11DeviceContext* devContext, IDXGISwapChain* pSwapChain, ID3DX11Effect* pFX, LPCSTR techName)
{
	InitSprite(hWnd, devContext, pSwapChain, pFX);
	if (!m_pTech)
	{
		m_pTech = GetEffect()->GetTechniqueByName(techName);
		// 初始化Effects变量
		m_pFXTexture = GetEffect()->GetVariableByName("gTexture")->AsShaderResource();
		m_pFXTexTransform = GetEffect()->GetVariableByName("gTexTransform")->AsMatrix();
	}
	if (!m_pInputLayout)
	{
		D3D11_INPUT_ELEMENT_DESC inputLayoutDesc[] = {
			{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
			{ "WORLD", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 0, D3D11_INPUT_PER_INSTANCE_DATA, 1 },
			{ "WORLD", 1, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 16, D3D11_INPUT_PER_INSTANCE_DATA, 1 },
			{ "WORLD", 2, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 32, D3D11_INPUT_PER_INSTANCE_DATA, 1 },
			{ "WORLD", 3, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 48, D3D11_INPUT_PER_INSTANCE_DATA, 1 }
		};
		D3DX11_PASS_DESC passDesc;
		m_pTech->GetPassByIndex(0)->GetDesc(&passDesc);
		HR(GetDevice()->CreateInputLayout(inputLayoutDesc, 6, passDesc.pIAInputSignature,
			passDesc.IAInputSignatureSize, &m_pInputLayout));
	}

	// 顶点数组初始化
	std::vector<Vertex>	Vertexes{
		{ XMFLOAT3(-1.0f, -1.0f, 0.0f), XMFLOAT2(0.0f, 1.0f) },
		{ XMFLOAT3(-1.0f, 1.0f, 0.0f), XMFLOAT2(0.0f, 0.0f) },
		{ XMFLOAT3(1.0f, -1.0f, 0.0f), XMFLOAT2(1.0f, 1.0f) },
		{ XMFLOAT3(1.0f, 1.0f, 0.0f), XMFLOAT2(1.0f, 0.0f) }
	};

	// 初始化顶点描述
	D3D11_BUFFER_DESC vbd;
	vbd.Usage = D3D11_USAGE_IMMUTABLE;
	vbd.ByteWidth = sizeof(Vertex) * Vertexes.size();
	vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	vbd.CPUAccessFlags = 0;
	vbd.MiscFlags = 0;
	vbd.StructureByteStride = 0;

	// 创建顶点缓冲区
	D3D11_SUBRESOURCE_DATA vInitData;
	vInitData.pSysMem = Vertexes.data();
	HR(GetDevice()->CreateBuffer(&vbd, &vInitData, &m_pVertexBuffer));

	std::vector<DWORD> Indices{ 0,1,2,3 };


	// 初始化索引描述
	D3D11_BUFFER_DESC ibd;
	ibd.Usage = D3D11_USAGE_IMMUTABLE;
	ibd.ByteWidth = sizeof(UINT) * Indices.size();
	ibd.BindFlags = D3D11_BIND_INDEX_BUFFER;
	ibd.CPUAccessFlags = 0;
	ibd.MiscFlags = 0;
	ibd.StructureByteStride = 0;

	// 初始化顶点
	D3D11_SUBRESOURCE_DATA iInitData;
	iInitData.pSysMem = Indices.data();
	HR(GetDevice()->CreateBuffer(&ibd, &iInitData, &m_pIndexBuffer));

	// 初始化实例描述
	D3D11_BUFFER_DESC inbd;
	inbd.Usage = D3D11_USAGE_DYNAMIC;
	inbd.ByteWidth = sizeof(XMFLOAT4X4) * 500;
	inbd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	inbd.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	inbd.MiscFlags = 0;
	inbd.StructureByteStride = 0;

	HR(GetDevice()->CreateBuffer(&inbd, nullptr, &m_pInstancedBuffer));
}
// 释放
void Sprite2D::Release()
{
	ReleaseCOM(m_pInputLayout);
	ReleaseCOM(m_pInstancedBuffer);
	ReleaseCOM(m_pIndexBuffer);
	ReleaseCOM(m_pVertexBuffer);
	ReleaseStatic(SpriteManager);
}

Sprite2DBackGround::~Sprite2DBackGround()
{
}

```

`Source Code/Sprite.h`:

```h
#pragma once

#include "d3dUtil.h"

// 2D顶点信息
struct Vertex {
	XMFLOAT3 Pos;
	XMFLOAT2 Tex;
};


// Sprite管理者，负责全局初始化
class SpriteManager
{
public:
	SpriteManager();
	virtual ~SpriteManager();

protected:
	static ID3D11Device* GetDevice() { return m_pDevice; }
	static ID3D11DeviceContext* GetDeviceContext() { return m_pDeviceContext; }
	static ID3DX11Effect* GetEffect() { return m_pFX; }
	static IDXGISwapChain* GetSwapChain() { return m_pSwapChain; }
	static HWND GetWindow() { return m_hWnd; }
	static void InitSprite(HWND hWnd, ID3D11DeviceContext* devContext, IDXGISwapChain* pSwapChain, ID3DX11Effect* pFX);
	static void Release() { ReleaseCOM(m_pDevice); m_pDeviceContext = nullptr; }
	static bool IsFullScreen() { BOOL fullscreen; m_pSwapChain->GetFullscreenState(&fullscreen, nullptr); return fullscreen; }
private:
	static ID3D11Device*					m_pDevice;			// D3D设备
	static ID3D11DeviceContext*				m_pDeviceContext;	// D3D设备上下文
	static IDXGISwapChain*					m_pSwapChain;		// 交换链
	static ID3DX11Effect*					m_pFX;				// Effects(单文件)
	static HWND								m_hWnd;				// 窗口句柄
};

// 精灵2D
class Sprite2D : public SpriteManager
{	

public:
	Sprite2D();
	~Sprite2D() override;
	// 初始化纹理
	void InitTexture(LPCSTR texFile);
	
	// 进行绘制，当使用StretchRect的时候只绘制一个
	void Draw();
	/*
	 * 设置需要绘制的贴图区域(按像素)和到窗口上的矩形区域。
	 * .png和.bmp的纹理可以通过GetTexture系列函数获取正常的宽高
	 * 对于其余类型的纹理默认宽高都将为256
	 * 设置radian可以决定旋转弧度。
	 * 若pSrcRect为空，绘制完整贴图。
	 * 若pDestRect为空，在整个游戏屏幕绘制贴图。
	 * 若pCenter为空，使用默认纹理的中心进行旋转。
	 */
	void StretchRect(const RECT* pSrcRect, const RECT* pDestRect, const POINT* pCenter, float radian);
	// 对同一种纹理绘制多个不同的目标
	void StretchRects(const std::vector<RECT>& DestRects, const std::vector<float>& radians);
	// 获取纹理宽度
	LONG GetTexWidth() const { return m_TexWidth; }
	// 获取纹理高度
	LONG GetTexHeight() const { return m_TexHeight; }

	// 初始化Sprite2D必要组件
	static void Initialize(HWND hWnd, ID3D11DeviceContext* devContext, IDXGISwapChain* pSwapChain, ID3DX11Effect* pFX, LPCSTR techName);

	// 释放Sprite2D资源
	static void Release();

private:
	static ID3D11Buffer*						m_pVertexBuffer;			// 顶点缓冲区
	static ID3D11Buffer*						m_pIndexBuffer;				// 索引缓冲区	
	static ID3D11Buffer*						m_pInstancedBuffer;			// 实例缓冲区

	static ID3DX11EffectShaderResourceVariable*	m_pFXTexture;				// Effects纹理变量
	static ID3DX11EffectMatrixVariable*			m_pFXTexTransform;			// Effects纹理坐标点变换矩阵



	static ID3D11InputLayout*					m_pInputLayout;				// 输入布局
	static ID3DX11EffectTechnique*				m_pTech;					// Effect技术

	std::vector<XMFLOAT4X4>						m_Instances;				// 实例数据
	XMFLOAT4X4									m_TexTransform;				// 纹理变换

	ID3D11ShaderResourceView*					m_pTexture;					// 纹理
	LONG										m_TexWidth, m_TexHeight;	// 纹理宽度、高度
};

class Sprite2DBackGround : SpriteManager
{
private:
	Sprite2DBackGround();
	~Sprite2DBackGround() override;

	ID3D11Buffer*						m_pVertexBuffer;			// 顶点缓冲区
	ID3D11Buffer*						m_pIndexBuffer;				// 索引缓冲区	


};
```

`Source Code/XUtility.cpp`:

```cpp
#include "XUtility.h"
#include "PlaneManager.h"

void GetPictureInfo(LPCSTR fileName, LONG * pOutWidth, LONG * pOutHeight)
{
	//获取位图尺寸
	FILE* fp = fopen(fileName, "rb");
	if (!fp)
	{
		MessageBoxA(0, (std::string(fileName) + "打开失败!").c_str(), "错误", MB_OK);
		assert(fp != NULL);
	}

	unsigned char buf[4];
	unsigned char BMPHeader[] = { 0x42,0x4d,0xf6,0xb8,0x59 };				//BMP头文件
	unsigned char PNGHeader[] = {0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A};  //PNG头文件

	unsigned seek_pos = 0;
	fread_s(buf, 4, sizeof(char), 4, fp);
	if (!memcmp(buf, PNGHeader, 4))
	{

		fseek(fp, 16, SEEK_SET);
		fread_s(buf, 4, sizeof(char), 4, fp);
		*pOutWidth = BYTE_TO_UINT(buf[0], buf[1], buf[2], buf[3]);
		fread_s(buf, 4, sizeof(char), 4, fp);
		*pOutHeight = BYTE_TO_UINT(buf[0], buf[1], buf[2], buf[3]);
	}
	else if (!memcmp(buf, BMPHeader, 4))
	{
		fseek(fp, 18, SEEK_SET);
		fread_s(buf, 4, sizeof(char), 4, fp);
		*pOutWidth = BYTE_TO_UINT(buf[3], buf[2], buf[1], buf[0]);
		fread_s(buf, 4, sizeof(char), 4, fp);
		*pOutHeight = BYTE_TO_UINT(buf[3], buf[2], buf[1], buf[0]);
	}

	fclose(fp);
}




void BuildFX(ID3D11Device* dev, LPCWSTR fileName, ID3DX11Effect** ppEffect)
{
	DWORD shaderFlags = 0;
#if defined( DEBUG ) || defined( _DEBUG )
	shaderFlags |= D3D10_SHADER_DEBUG;
	shaderFlags |= D3D10_SHADER_SKIP_OPTIMIZATION;
#endif

	ID3D10Blob* compiledShader = 0;
	ID3D10Blob* compilationMsgs = 0;

	HRESULT hr = D3DX11CompileFromFile(fileName, 0, 0, 0, "fx_5_0", shaderFlags,
		0, 0, &compiledShader, &compilationMsgs, 0);

	// compilationMsgs可以获取警告或者错误信息
	if (compilationMsgs != 0)
	{
		MessageBoxA(0, (char*)compilationMsgs->GetBufferPointer(), 0, 0);
		ReleaseCOM(compilationMsgs);
	}

	// 如果没有编译信息，确保这里没有错误
	if (FAILED(hr))
	{
		DXTrace(__FILE__, (DWORD)__LINE__, hr, L"D3DX11CompileFromFile", true);
	}

	HR(D3DX11CreateEffectFromMemory(compiledShader->GetBufferPointer(), compiledShader->GetBufferSize(),
		0, dev, ppEffect));

	// 编译着色器完成，可以释放了
	ReleaseCOM(compiledShader);
}

bool RectCollision(const RECT& r1, const RECT& r2)
{
	// 矩形r1宽高的一半
	float halfWidth1 = (r1.right - r1.left) / 2.0f;
	float halfHeight1 = (r1.bottom - r1.top) / 2.0f;
	// 矩形r2宽高的一半
	float halfWidth2 = (r2.right - r2.left) / 2.0f;
	float halfHeight2 = (r2.bottom - r2.top) / 2.0f;
	// 中心r1坐标
	float centerX1 = (r1.right + r1.left) / 2.0f;
	float centerY1 = (r1.bottom + r1.top) / 2.0f;
	// 中心r2坐标
	float centerX2 = (r2.right + r2.left) / 2.0f;
	float centerY2 = (r2.bottom + r2.top) / 2.0f;

	// 判断两点XY间距是否分别小于等于两个矩形宽高的一半。
	return (fabs(centerX1 - centerX2) <= halfWidth1 + halfWidth2) &&
		(fabs(centerY1 - centerY2) <= halfHeight1 + halfHeight2);
}

float DegToRad(float degree)
{
	return degree * MathHelper::Pi / 180.0f;
}

bool ClickBox(const MKInput* pIn, const D2D1_RECT_F& rect, D2DText& d2dText, LPCWSTR wstr)
{
	POINT point = pIn->GetMousePos();
	// 判断鼠标是否在按钮内
	if (rect.left <= (float)point.x && rect.right >= (float)point.x &&
		rect.top <= (float)point.y && rect.bottom >= (float)point.y)
	{
		d2dText.SetTextColor(D2D1::ColorF::Gray);
		d2dText.DrawString(wstr, rect);
		d2dText.SetTextColor(D2D1::ColorF::White);
	}
	else
		d2dText.DrawString(wstr, rect);
	
	

	// 判断鼠标是否点击了按钮
	point = pIn->GetMouseClickPos(MKMouse::LEFT);
	if (rect.left <= (float)point.x && rect.right >= (float)point.x &&
		rect.top <= (float)point.y && rect.bottom >= (float)point.y &&
		pIn->Mouse_SingleClick(MKMouse::LEFT))
		return true;
	else
		return false;
}

LONG LevelToVolume(int level)
{
	if (level <= 0)
		return -10000;
	return (LONG)(2000 * log10f(level / 10.0f));
}


```

`Source Code/XUtility.h`:

```h
#pragma once

#include "d3dUtil.h"
#include "d2dText.h"
#include "MKInput.h"
#define BYTE_TO_UINT(a,b,c,d) (((unsigned)(a) << 24) | ((unsigned)(b) << 16) | ((unsigned)(c) << 8) | ((unsigned)(d)))
#define ReleaseStatic(Type) { Type::Release(); }

// 获取图片像素宽度和高度
void GetPictureInfo(LPCSTR fileName, LONG * pOutWidth, LONG * pOutHeight);

// 生成Effect
void BuildFX(ID3D11Device* dev, LPCWSTR fileName, ID3DX11Effect** ppEffect);

// 检测两个AABB矩形的碰撞
bool RectCollision(const RECT& r1, const RECT& r2);

// 角度转弧度
float DegToRad(float degree);

// 生成ClickBox，鼠标在移动到ClickBox时会高亮，点击它返回true，没点击返回false
bool ClickBox(const MKInput* pIn, const D2D1_RECT_F& rect, D2DText& d2dText, LPCWSTR wstr);

// 计算出音量值
LONG LevelToVolume(int level);
```

`Source Code/d2dText.cpp`:

```cpp
#include "d2dText.h"

//---------------------------------------------------------------------------------------
// Simple d3d error checker for book demos.
//---------------------------------------------------------------------------------------
#if defined(DEBUG) | defined(_DEBUG)
#ifndef HR
#define HR(x)                                              \
	{                                                          \
		HRESULT hr = (x);                                      \
		if(FAILED(hr))                                         \
		{                                                      \
			DXTrace(__FILE__, (DWORD)__LINE__, hr, L#x, true); \
		}                                                      \
	}
#endif

#else
#ifndef HR
#define HR(x) (x)
#endif
#endif 

//---------------------------------------------------------------------------------------
// Convenience macro for releasing COM objects.
//---------------------------------------------------------------------------------------

#define ReleaseCOM(x) { if(x){ x->Release(); x = 0; } }


ID2D1Factory*			D2DText::m_pD2DFactory = nullptr;
IDWriteFactory*			D2DText::m_pDWriteFactory = nullptr;
ID2D1RenderTarget*		D2DText::m_pD2DRenderTarget = nullptr;
IDXGISwapChain*			D2DText::m_pSwapChain = nullptr;
HWND					D2DText::m_hWnd = nullptr;

D2DText::D2DText()
	: m_pD2DColorBrush(nullptr), m_D2DRect(), m_pTextFormat(nullptr)
{
}


D2DText::D2DText(LPCWSTR fontName, FLOAT fontSize, D2D1::ColorF color,
	DWRITE_TEXT_ALIGNMENT textAlign, DWRITE_PARAGRAPH_ALIGNMENT paraAlign)
{
	Reset(fontName, fontSize, color, textAlign, paraAlign);
}


D2DText::D2DText(LPCWSTR fontName, FLOAT fontSize)
{
	Reset(fontName, fontSize, D2D1::ColorF::Black, 
		DWRITE_TEXT_ALIGNMENT_LEADING, DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
}


D2DText::~D2DText()
{
	ReleaseCOM(m_pD2DColorBrush);
	ReleaseCOM(m_pTextFormat);
}

// 在使用D2DText对象之前必须提供交换链进行初始化
HRESULT D2DText::Initialize(HWND hWnd, IDXGISwapChain* pDXGISwapChain)
{
	if (!m_hWnd)
		m_hWnd = hWnd;
	if (!m_pSwapChain)
		m_pSwapChain = pDXGISwapChain;
	if (!m_pD2DFactory)
	{
		// 创建D2D1工厂
		D2D1_FACTORY_OPTIONS options;
		options.debugLevel = D2D1_DEBUG_LEVEL_INFORMATION;
		HR(D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, 
			options, &m_pD2DFactory));
		// 这里创建渲染目标
		Discard();
		OnReset();
	}
	if (!m_pDWriteFactory)
	{
		// 创建DWrite工厂
		HR(DWriteCreateFactory(
			DWRITE_FACTORY_TYPE_SHARED,
			__uuidof(IDWriteFactory),
			reinterpret_cast<IUnknown**>(&m_pDWriteFactory)));
	}

	return S_OK;
}


// 重新设置文本参数
HRESULT D2DText::Reset(LPCWSTR fontName, FLOAT fontSize, D2D1::ColorF color, 
	DWRITE_TEXT_ALIGNMENT textAlign, DWRITE_PARAGRAPH_ALIGNMENT paraAlign)
{
	assert(m_pSwapChain);
	ReleaseCOM(m_pD2DColorBrush);
	ReleaseCOM(m_pTextFormat);
	// 设置默认的文本格式
	HR(m_pDWriteFactory->CreateTextFormat(fontName, 
		nullptr, 
		DWRITE_FONT_WEIGHT_REGULAR,
		DWRITE_FONT_STYLE_NORMAL, 
		DWRITE_FONT_STRETCH_NORMAL, 
		fontSize, L"zh-cn", 
		&m_pTextFormat));
	// 设置文本水平对齐
	HR(m_pTextFormat->SetTextAlignment(textAlign));
	// 设置文本段落对齐
	HR(m_pTextFormat->SetParagraphAlignment(paraAlign));
	// 设置颜色刷
	HR(m_pD2DRenderTarget->CreateSolidColorBrush(D2D1::ColorF(color), 
		&m_pD2DColorBrush));
	return S_OK;
}

// 设置文本字体类型和大小
HRESULT D2DText::SetFont(LPCWSTR fontName, FLOAT fontSize)
{
	// 取出之前设置的格式，然后释放
	DWRITE_TEXT_ALIGNMENT textAlign = m_pTextFormat->GetTextAlignment();
	DWRITE_PARAGRAPH_ALIGNMENT ParaAlign = m_pTextFormat->GetParagraphAlignment();
	ReleaseCOM(m_pTextFormat);

	// 设置默认的文本格式
	HR(m_pDWriteFactory->CreateTextFormat(fontName, 
		nullptr, 
		DWRITE_FONT_WEIGHT_REGULAR,
		DWRITE_FONT_STYLE_NORMAL, 
		DWRITE_FONT_STRETCH_NORMAL, 
		fontSize, 
		L"zh-cn", 
		&m_pTextFormat));
	// 设置文本水平对齐
	HR(m_pTextFormat->SetTextAlignment(textAlign));
	// 设置文本段落对齐
	HR(m_pTextFormat->SetParagraphAlignment(ParaAlign));

	return S_OK;
}

// 设置文本框
HRESULT D2DText::SetTextRect(D2D1_RECT_F drawRect)
{
	m_D2DRect = drawRect;
	return S_OK;
}

// 设置文本水平对齐
HRESULT D2DText::SetTextAlign(DWRITE_TEXT_ALIGNMENT textAlign)
{
	HR(m_pTextFormat->SetTextAlignment(textAlign));
	return S_OK;
}

// 设置文本段落对齐
HRESULT D2DText::SetParaAlign(DWRITE_PARAGRAPH_ALIGNMENT ParaAlign)
{
	HR(m_pTextFormat->SetParagraphAlignment(ParaAlign));
	return S_OK;
}

// 设置文本颜色
HRESULT D2DText::SetTextColor(D2D1::ColorF color)
{
	ReleaseCOM(m_pD2DColorBrush);
	HR(m_pD2DRenderTarget->CreateSolidColorBrush(D2D1::ColorF(color), &m_pD2DColorBrush));
	return S_OK;
}

// 三个重载函数= = 然而我想写默认参数的。迷之Google规范
// 直接绘制文本
HRESULT D2DText::DrawString(LPCWSTR wString)
{
	return DrawString(wString, m_D2DRect);
}

// 根据给定矩形区域绘制文本
HRESULT D2DText::DrawString(LPCWSTR wString,const D2D1_RECT_F& drawRect)
{
	return DrawString(wString, drawRect, 0.0f);
}

// 根据给定矩形区域，并设置字体旋转角度来绘制文本
HRESULT D2DText::DrawString(
	LPCWSTR wString, const D2D1_RECT_F& drawRect, FLOAT rotateAngle)
{
	m_pD2DRenderTarget->BeginDraw();

	D2D1_POINT_2F center = D2D1::Point2F((drawRect.right - drawRect.left) / 2, 
		(drawRect.bottom - drawRect.top) / 2);
	m_pD2DRenderTarget->SetTransform(D2D1::Matrix3x2F::Rotation(rotateAngle, center));
	m_pD2DRenderTarget->DrawText(wString, 
		wcslen(wString), 
		m_pTextFormat, 
		drawRect, 
		m_pD2DColorBrush);

	HR(m_pD2DRenderTarget->EndDraw());
	return S_OK;
}





// 在RenderTargetView被释放的时候必须调用该函数
void D2DText::Discard()
{
	ReleaseCOM(m_pD2DRenderTarget);
}

// 在构造好RenderTargetView后必须调用该函数
void D2DText::OnReset()
{
	if (m_pSwapChain)
	{

		IDXGISurface1 *m_pBackBuffer = nullptr;
		HR(m_pSwapChain->GetBuffer(0, __uuidof(IDXGISurface1), reinterpret_cast<void**>(&m_pBackBuffer)));
		D2D1_RENDER_TARGET_PROPERTIES props = D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE_DEFAULT,
			D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED));
		HR(m_pD2DFactory->CreateDxgiSurfaceRenderTarget(m_pBackBuffer, props, &m_pD2DRenderTarget));
		ReleaseCOM(m_pBackBuffer);
	}
	
}

void D2DText::Release()
{
	ReleaseCOM(m_pD2DRenderTarget);
	ReleaseCOM(m_pD2DFactory);
	ReleaseCOM(m_pDWriteFactory);
}


```

`Source Code/d2dText.h`:

```h
#ifndef _D2DTEXT_H_
#define _D2DTEXT_H_

#include <intsafe.h>
#include <D2d1.h>
#include <D2D1Helper.h>
#include <DWrite.h>
#include <dxerr.h>
#include <cassert>


class D2DText 
{
public:
	D2DText();
	D2DText::D2DText(LPCWSTR fontName, FLOAT fontSize);
	D2DText(LPCWSTR fontName, FLOAT fontSize, D2D1::ColorF color,
		DWRITE_TEXT_ALIGNMENT textAlign, DWRITE_PARAGRAPH_ALIGNMENT paraAlign);
	~D2DText();

	HRESULT Reset(LPCWSTR fontName, FLOAT fontSize, D2D1::ColorF color,
		DWRITE_TEXT_ALIGNMENT textAlign, DWRITE_PARAGRAPH_ALIGNMENT paraAlign);
	HRESULT SetFont(LPCWSTR fontName, FLOAT fontSize);
	HRESULT SetTextRect(D2D1_RECT_F drawRect);
	HRESULT SetTextAlign(DWRITE_TEXT_ALIGNMENT textAlign);
	HRESULT SetParaAlign(DWRITE_PARAGRAPH_ALIGNMENT ParaAlign);
	HRESULT SetTextColor(D2D1::ColorF color);
	
	HRESULT DrawString(LPCWSTR wString);
	HRESULT DrawString(LPCWSTR wString, const D2D1_RECT_F& drawRect);
	HRESULT DrawString(LPCWSTR wString, const D2D1_RECT_F& drawRect, FLOAT rotateAngle);

	static HRESULT Initialize(HWND hWnd, IDXGISwapChain* pDXGISwapChain);	
	static void Discard();
	static void OnReset();
	static void Release();
private:
	

	ID2D1SolidColorBrush*				m_pD2DColorBrush;
	IDWriteTextFormat*					m_pTextFormat;
	D2D1_RECT_F							m_D2DRect;

	static HWND							m_hWnd;
	static ID2D1Factory*				m_pD2DFactory;
	static IDWriteFactory*				m_pDWriteFactory;
	static ID2D1RenderTarget*			m_pD2DRenderTarget;
	static IDXGISwapChain*				m_pSwapChain;
};
#endif

```

`Source Code/d3dApp.cpp`:

```cpp
//***************************************************************************************
// d3dApp.cpp by Frank Luna (C) 2011 All Rights Reserved.
//***************************************************************************************

#include "d3dApp.h"
#include <WindowsX.h>
#include <sstream>

namespace
{
	// This is just used to forward Windows messages from a global window
	// procedure to our member function window procedure because we cannot
	// assign a member function to WNDCLASS::lpfnWndProc.
	D3DApp* gd3dApp = 0;
}

LRESULT CALLBACK
MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	// Forward hwnd on because we can get messages (e.g., WM_CREATE)
	// before CreateWindow returns, and thus before m_hMainWnd is valid.
	return gd3dApp->MsgProc(hwnd, msg, wParam, lParam);
}

D3DApp::D3DApp(HINSTANCE hInstance)
:	m_hAppInst(hInstance),
	m_MainWndCaption(L"D3D11 Application"),
	m_d3dDriverType(D3D_DRIVER_TYPE_HARDWARE),
	m_ClientWidth(750 + 18),
	m_ClientHeight(900 + 47),
	m_Enable4xMsaa(false),
	m_hMainWnd(0),
	m_AppPaused(false),
	m_Minimized(false),
	m_Maximized(false),
	m_Resizing(false),
	m_4xMsaaQuality(0),
	m_FullScreen(false),

	m_pD3DDevice(0),
	m_pD3DImmediateContext(0),
	m_pSwapChain(0),
	m_pDepthStencilBuffer(0),
	m_pRenderTargetView(0),
	m_pDepthStencilView(0)
{
	ZeroMemory(&m_ScreenViewport, sizeof(D3D11_VIEWPORT));

	// Get a pointer to the application object so we can forward 
	// Windows messages to the object's window procedure through
	// the global window procedure.
	gd3dApp = this;
}

D3DApp::~D3DApp()
{
	ReleaseCOM(m_pRenderTargetView);
	ReleaseCOM(m_pDepthStencilView);
	ReleaseCOM(m_pSwapChain);
	ReleaseCOM(m_pDepthStencilBuffer);

	// Restore all default settings.
	if( m_pD3DImmediateContext )
		m_pD3DImmediateContext->ClearState();

	ReleaseCOM(m_pD3DImmediateContext);

	// 此处用于内存泄漏检测
	 ReportLeakMemory();
	
	ReleaseCOM(m_pD3DDevice);
}

HINSTANCE D3DApp::AppInst()const
{
	return m_hAppInst;
}

HWND D3DApp::MainWnd()const
{
	return m_hMainWnd;
}

float D3DApp::AspectRatio()const
{
	return static_cast<float>(m_ClientWidth) / m_ClientHeight;
}

int D3DApp::Run()
{
	MSG msg = {0};
 
	m_Timer.Reset();

	while(msg.message != WM_QUIT)
	{
		// 有窗口消息则先处理它们
		if(PeekMessage( &msg, 0, 0, 0, PM_REMOVE ))
		{
            TranslateMessage( &msg );
            DispatchMessage( &msg );
		}
		// 否则，进行游戏部分
		else
        {	
			m_Timer.Tick();

			if( !m_AppPaused )
			{		
				// 限帧到60fps
				static float currTime = m_Timer.TotalTime();
				if (m_Timer.TotalTime() - currTime > 1.0f / 60)
				{
					CalculateFrameStats();
					currTime = m_Timer.TotalTime();
					UpdateScene(m_Timer.DeltaTime());
					DrawScene();
				}
				
			}
			else
			{
				Sleep(100);
			}
        }
    }

	return (int)msg.wParam;
}

bool D3DApp::Init()
{
	if(!InitMainWindow())
		return false;

	if(!InitDirect3D())
		return false;

	return true;
}
 
void D3DApp::OnResize()
{
	assert(m_pD3DImmediateContext);
	assert(m_pD3DDevice);
	assert(m_pSwapChain);


	// Release the old views, as they hold references to the buffers we
	// will be destroying.  Also release the old depth/stencil buffer.

	ReleaseCOM(m_pRenderTargetView);		// 释放渲染目标视图
	ReleaseCOM(m_pDepthStencilView);		// 释放深度/模板视图
	ReleaseCOM(m_pDepthStencilBuffer);	// 释放深度/模板缓冲区

	// 重设交换链并且重新创建渲染目标视图

	HR(m_pSwapChain->ResizeBuffers(1, m_ClientWidth, m_ClientHeight, DXGI_FORMAT_B8G8R8A8_UNORM, DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE));
	
	HR(m_pSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<void**>(&m_pBackBuffer)));
	HR(m_pD3DDevice->CreateRenderTargetView(m_pBackBuffer, 0, &m_pRenderTargetView));
	ReleaseCOM(m_pBackBuffer);


	// 创建深度/目标缓冲和视图

	D3D11_TEXTURE2D_DESC depthStencilDesc;
	
	depthStencilDesc.Width     = m_ClientWidth;
	depthStencilDesc.Height    = m_ClientHeight;
	depthStencilDesc.MipLevels = 1;
	depthStencilDesc.ArraySize = 1;
	depthStencilDesc.Format    = DXGI_FORMAT_D24_UNORM_S8_UINT;

	// Use 4X MSAA? --需要给交换链设置MASS参数
	if( m_Enable4xMsaa )
	{
		depthStencilDesc.SampleDesc.Count   = 4;
		depthStencilDesc.SampleDesc.Quality = m_4xMsaaQuality-1;
	}
	// No MSAA
	else
	{
		depthStencilDesc.SampleDesc.Count   = 1;
		depthStencilDesc.SampleDesc.Quality = 0;
	}

	depthStencilDesc.Usage          = D3D11_USAGE_DEFAULT;
	depthStencilDesc.BindFlags      = D3D11_BIND_DEPTH_STENCIL;
	depthStencilDesc.CPUAccessFlags = 0; 
	depthStencilDesc.MiscFlags      = 0;

	HR(m_pD3DDevice->CreateTexture2D(&depthStencilDesc, 0, &m_pDepthStencilBuffer));
	HR(m_pD3DDevice->CreateDepthStencilView(m_pDepthStencilBuffer, 0, &m_pDepthStencilView));


	// 将渲染目标视图和深度/模板缓冲区结合到管线

	m_pD3DImmediateContext->OMSetRenderTargets(1, &m_pRenderTargetView, m_pDepthStencilView);
	

	// 设置视口变换
	m_ScreenViewport.TopLeftX = 0;
	m_ScreenViewport.TopLeftY = 0;
	m_ScreenViewport.Width = static_cast<float>(m_ClientWidth);
	m_ScreenViewport.Height = static_cast<float>(m_ClientHeight);
	m_ScreenViewport.MinDepth = 0.0f;
	m_ScreenViewport.MaxDepth = 1.0f;

	

	m_pD3DImmediateContext->RSSetViewports(1, &m_ScreenViewport);
}
 
LRESULT D3DApp::MsgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch( msg )
	{
	// WM_ACTIVATE is sent when the window is activated or deactivated.  
	// We pause the game when the window is deactivated and unpause it 
	// when it becomes active.  
	case WM_ACTIVATE:
		if( LOWORD(wParam) == WA_INACTIVE )
		{
			m_AppPaused = true;
			m_Timer.Stop();
		}
		else
		{
			m_AppPaused = false;
			m_Timer.Start();
		}
		return 0;

	// WM_SIZE is sent when the user resizes the window.  
	case WM_SIZE:
		// Save the new client area dimensions.
		m_ClientWidth  = LOWORD(lParam);
		m_ClientHeight = HIWORD(lParam);
		if( m_pD3DDevice )
		{
			if( wParam == SIZE_MINIMIZED )
			{
				m_AppPaused = true;
				m_Minimized = true;
				m_Maximized = false;
			}
			else if( wParam == SIZE_MAXIMIZED )
			{
				m_AppPaused = false;
				m_Minimized = false;
				m_Maximized = true;
				OnResize();
			}
			else if( wParam == SIZE_RESTORED )
			{
				
				// Restoring from minimized state?
				if( m_Minimized )
				{
					m_AppPaused = false;
					m_Minimized = false;
					OnResize();
				}

				// Restoring from maximized state?
				else if( m_Maximized )
				{
					m_AppPaused = false;
					m_Maximized = false;
					OnResize();
				}
				else if( m_Resizing )
				{
					// If user is dragging the resize bars, we do not resize 
					// the buffers here because as the user continuously 
					// drags the resize bars, a stream of WM_SIZE messages are
					// sent to the window, and it would be pointless (and slow)
					// to resize for each WM_SIZE message received from dragging
					// the resize bars.  So instead, we reset after the user is 
					// done resizing the window and releases the resize bars, which 
					// sends a WM_EXITSIZEMOVE message.
				}
				else // API call such as SetWindowPos or m_pSwapChain->SetFullscreenState.
				{
					OnResize();
				}
			}
		}
		return 0;

	// WM_EXITSIZEMOVE is sent when the user grabs the resize bars.
	case WM_ENTERSIZEMOVE:
		m_AppPaused = true;
		m_Resizing  = true;
		m_Timer.Stop();
		return 0;

	// WM_EXITSIZEMOVE is sent when the user releases the resize bars.
	// Here we reset everything based on the new window dimensions.
	case WM_EXITSIZEMOVE:
		m_AppPaused = false;
		m_Resizing  = false;
		m_Timer.Start();
		OnResize();
		return 0;
 
	// WM_DESTROY is sent when the window is being destroyed.
	case WM_DESTROY:
		PostQuitMessage(0);
		return 0;

	// The WM_MENUCHAR message is sent when a menu is active and the user presses 
	// a key that does not correspond to any mnemonic or accelerator key. 
	case WM_MENUCHAR:
        // Don't beep when we alt-enter.
        return MAKELRESULT(0, MNC_CLOSE);
	}

	return DefWindowProc(hwnd, msg, wParam, lParam);
}

void D3DApp::ReportLeakMemory()
{
#if defined(DEBUG) || defined(_DEBUG)  
	ID3D11Debug *d3dDebug;
	HRESULT hr = m_pD3DDevice->QueryInterface(__uuidof(ID3D11Debug), reinterpret_cast<void**>(&d3dDebug));
	if (SUCCEEDED(hr))
	{
		hr = d3dDebug->ReportLiveDeviceObjects(D3D11_RLDO_DETAIL);
	}
	ReleaseCOM(d3dDebug);
#endif
}

bool D3DApp::InitMainWindow()
{
	WNDCLASS wc;
	wc.style         = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc   = MainWndProc; 
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	wc.hInstance     = m_hAppInst;
	wc.hIcon         = LoadIcon(0, IDI_APPLICATION);
	wc.hCursor       = LoadCursor(0, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)GetStockObject(NULL_BRUSH);
	wc.lpszMenuName  = 0;
	wc.lpszClassName = L"D3DWndClassName";

	if( !RegisterClass(&wc) )
	{
		MessageBox(0, L"RegisterClass Failed.", 0, 0);
		return false;
	}

	// Compute window rectangle dimensions based on requested client area dimensions.
	RECT R = { 0, 0, m_ClientWidth, m_ClientHeight };
    AdjustWindowRect(&R, WS_OVERLAPPED | WS_SYSMENU, false);
	int width  = R.right - R.left;
	int height = R.bottom - R.top;

	m_hMainWnd = CreateWindow(L"D3DWndClassName", m_MainWndCaption.c_str(), 
		WS_OVERLAPPED | WS_SYSMENU, 600, 50, width, height, 0, 0, m_hAppInst, 0);
	if( !m_hMainWnd )
	{
		MessageBox(0, L"CreateWindow Failed.", 0, 0);
		return false;
	}

	ShowWindow(m_hMainWnd, SW_SHOW);
	UpdateWindow(m_hMainWnd);

	return true;
}

bool D3DApp::InitDirect3D()
{
	// 创建D3D设备 和 D3D设备上下文

	UINT createDeviceFlags = 0;
#if defined(DEBUG) || defined(_DEBUG)  
    createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
#endif

	D3D_FEATURE_LEVEL featureLevels[] = {
		D3D_FEATURE_LEVEL_11_0,
		D3D_FEATURE_LEVEL_10_1,
		D3D_FEATURE_LEVEL_10_0
	};
	D3D_FEATURE_LEVEL featureLevel;

	HRESULT hr = D3D11CreateDevice(
			0,                 // 默认适配器
			m_d3dDriverType,
			0,                 // 无软件设备
			createDeviceFlags | D3D11_CREATE_DEVICE_BGRA_SUPPORT, 
			featureLevels, ARRAYSIZE(featureLevels),
			D3D11_SDK_VERSION,
			&m_pD3DDevice,
			&featureLevel,
			&m_pD3DImmediateContext);

	if( FAILED(hr) )
	{
		MessageBox(0, L"D3D11CreateDevice Failed.", 0, 0);
		return false;
	}

	// 填充DXGI_SWAP_CHAIN_DESC用以描述交换链

	DXGI_SWAP_CHAIN_DESC sd;
	sd.BufferDesc.Width  = m_ClientWidth;
	sd.BufferDesc.Height = m_ClientHeight;
	sd.BufferDesc.RefreshRate.Numerator = 60;				// 分子
	sd.BufferDesc.RefreshRate.Denominator = 1;				// 分母
	sd.BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;		// (r, g, b, a)
	sd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
	sd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
	// Use 4X MSAA? 
	if( m_Enable4xMsaa )
	{
		sd.SampleDesc.Count   = 4;
		sd.SampleDesc.Quality = m_4xMsaaQuality-1;
	}
	// No MSAA
	else
	{
		sd.SampleDesc.Count   = 1;
		sd.SampleDesc.Quality = 0;
	}

	sd.BufferUsage  = DXGI_USAGE_RENDER_TARGET_OUTPUT;
	sd.BufferCount  = 1;
	sd.OutputWindow = m_hMainWnd;
	sd.Windowed     = true;
	sd.SwapEffect   = DXGI_SWAP_EFFECT_DISCARD;
	sd.Flags        = 0;

	// To correctly create the swap chain, we must use the IDXGIFactory that was
	// used to create the device.  If we tried to use a different IDXGIFactory instance
	// (by calling CreateDXGIFactory), we get an error: "IDXGIFactory::CreateSwapChain: 
	// This function is being called with a device from a different IDXGIFactory."

	IDXGIDevice* dxgiDevice = 0;
	HR(m_pD3DDevice->QueryInterface(__uuidof(IDXGIDevice), (void**)&dxgiDevice));
	      
	IDXGIAdapter* dxgiAdapter = 0;
	HR(dxgiDevice->GetParent(__uuidof(IDXGIAdapter), (void**)&dxgiAdapter));

	IDXGIFactory* dxgiFactory = 0;
	HR(dxgiAdapter->GetParent(__uuidof(IDXGIFactory), (void**)&dxgiFactory));

	HR(dxgiFactory->CreateSwapChain(m_pD3DDevice, &sd, &m_pSwapChain));


	ReleaseCOM(dxgiDevice);
	ReleaseCOM(dxgiAdapter);
	ReleaseCOM(dxgiFactory);

	// The remaining steps that need to be carried out for d3d creation
	// also need to be executed every time the window is resized.  So
	// just call the OnResize method here to avoid code duplication.
	
	OnResize();

	

	return true;
}

void D3DApp::CalculateFrameStats()
{
	// 该代码计算每秒帧速，并计算每一帧渲染需要的时间，显示在窗口标题

	static int frameCnt = 0;
	static float timeElapsed = 0.0f;

	frameCnt++;

	// Compute averages over one second period.
	if( (m_Timer.TotalTime() - timeElapsed) >= 1.0f )
	{
		float fps = (float)frameCnt; // fps = frameCnt / 1
		float mspf = 1000.0f / fps;

		std::wostringstream outs;   
		outs.precision(6);
		outs << m_MainWndCaption << L"    "
			 << L"FPS: " << fps << L"    " 
			 << L"Frame Time: " << mspf << L" (ms)";
		SetWindowText(m_hMainWnd, outs.str().c_str());
		
		// Reset for next average.
		frameCnt = 0;
		timeElapsed += 1.0f;
	}
}



```

`Source Code/d3dApp.h`:

```h
//***************************************************************************************
// d3dApp.h by Frank Luna (C) 2011 All Rights Reserved.
//
// Simple Direct3D demo application class.  
// Make sure you link: d3d11.lib d3dx11d.lib D3DCompiler.lib D3DX11EffectsD.lib 
//                     dxerr.lib dxgi.lib dxguid.lib.
// Link d3dx11.lib and D3DX11Effects.lib for release mode builds instead
//   of d3dx11d.lib and D3DX11EffectsD.lib.
//***************************************************************************************

#ifndef D3DAPP_H
#define D3DAPP_H

#include <string>
#include "d2dText.h"
#include "d3dUtil.h"
#include "GameTimer.h"

#if defined(_DEBUG) | defined(DEBUG)
#pragma comment(lib, "d3dx11d.lib")
#else
#pragma comment(lib, "d3dx11.lib")
#endif

#pragma comment(lib, "dsound.lib")
#pragma comment(lib, "winmm.lib")
#pragma comment(lib, "d2d1.lib")
#pragma comment(lib, "dwrite.lib")
#pragma comment(lib, "d3d11.lib")
#pragma comment(lib, "D3DCompiler.lib")
#pragma comment(lib, "Effects11.lib")
#pragma comment(lib, "dxerr.lib")
#pragma comment(lib, "dxgi.lib")
#pragma comment(lib, "dxguid.lib")
#pragma comment(lib, "legacy_stdio_definitions.lib")

class D3DApp
{
public:
	D3DApp(HINSTANCE hInstance);
	virtual ~D3DApp();
	
	HINSTANCE AppInst()const;
	HWND      MainWnd()const;
	float     AspectRatio()const;
	
	int Run();
 
	// 框架方法。派生类应该重载这些方法来实现特定的应用需求

	virtual bool Init();
	virtual void OnResize(); 
	virtual void UpdateScene(float dt)=0;
	virtual void DrawScene()=0; 
	virtual LRESULT MsgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

	// 必要时可以调用以检测D3D设备的内存泄漏
	void ReportLeakMemory();

protected:
	bool InitMainWindow();
	bool InitDirect3D();

	void CalculateFrameStats();

protected:

	HINSTANCE m_hAppInst;
	HWND      m_hMainWnd;
	bool      m_AppPaused;
	bool      m_Minimized;
	bool      m_Maximized;
	bool      m_Resizing;
	UINT      m_4xMsaaQuality;
	BOOL	  m_FullScreen;			// 是否全屏
	GameTimer m_Timer;


	// Direct3D
	ID3D11Device*					m_pD3DDevice;				// D3D设备
	ID3D11DeviceContext*			m_pD3DImmediateContext;		// D3D设备上下文
	IDXGISwapChain*					m_pSwapChain;				// 交换链
	ID3D11Texture2D*				m_pBackBuffer;				// 后备缓冲区
	ID3D11Texture2D*				m_pDepthStencilBuffer;		// 深度/模板缓冲区
	ID3D11RenderTargetView*			m_pRenderTargetView;		// 渲染目标视图
	ID3D11DepthStencilView*			m_pDepthStencilView;		// 深度/模板视图
	D3D11_VIEWPORT					m_ScreenViewport;			// 屏幕视口
	
						
	

	// 派生类应该在构造函数内设置好这些自定义的初值
	std::wstring			m_MainWndCaption;
	D3D_DRIVER_TYPE			m_d3dDriverType;
	int						m_ClientWidth;
	int						m_ClientHeight;
	bool					m_Enable4xMsaa;
};

#endif // D3DAPP_H
```

`Source Code/d3dUtil.cpp`:

```cpp
//***************************************************************************************
// d3dUtil.cpp by Frank Luna (C) 2011 All Rights Reserved.
//***************************************************************************************

#include "d3dUtil.h"

ID3D11ShaderResourceView* d3dHelper::CreateTexture2DArraySRV(
		ID3D11Device* device, ID3D11DeviceContext* context,
		std::vector<std::wstring>& filenames,
		DXGI_FORMAT format,
		UINT filter, 
		UINT mipFilter)
{
	//
	// Load the texture elements individually from file.  These textures
	// won't be used by the GPU (0 bind flags), they are just used to 
	// load the image data from file.  We use the STAGING usage so the
	// CPU can read the resource.
	//

	UINT size = filenames.size();

	std::vector<ID3D11Texture2D*> srcTex(size);
	for(UINT i = 0; i < size; ++i)
	{
		D3DX11_IMAGE_LOAD_INFO loadInfo;

        loadInfo.Width  = D3DX11_FROM_FILE;
        loadInfo.Height = D3DX11_FROM_FILE;
        loadInfo.Depth  = D3DX11_FROM_FILE;
        loadInfo.FirstMipLevel = 0;
        loadInfo.MipLevels = D3DX11_FROM_FILE;
        loadInfo.Usage = D3D11_USAGE_STAGING;
        loadInfo.BindFlags = 0;
        loadInfo.CpuAccessFlags = D3D11_CPU_ACCESS_WRITE | D3D11_CPU_ACCESS_READ;
        loadInfo.MiscFlags = 0;
        loadInfo.Format = format;
        loadInfo.Filter = filter;
        loadInfo.MipFilter = mipFilter;
		loadInfo.pSrcInfo  = 0;

        HR(D3DX11CreateTextureFromFile(device, filenames[i].c_str(), 
			&loadInfo, 0, (ID3D11Resource**)&srcTex[i], 0));
	}

	//
	// Create the texture array.  Each element in the texture 
	// array has the same format/dimensions.
	//

	D3D11_TEXTURE2D_DESC texElementDesc;
	srcTex[0]->GetDesc(&texElementDesc);

	D3D11_TEXTURE2D_DESC texArrayDesc;
	texArrayDesc.Width              = texElementDesc.Width;
	texArrayDesc.Height             = texElementDesc.Height;
	texArrayDesc.MipLevels          = texElementDesc.MipLevels;
	texArrayDesc.ArraySize          = size;
	texArrayDesc.Format             = texElementDesc.Format;
	texArrayDesc.SampleDesc.Count   = 1;
	texArrayDesc.SampleDesc.Quality = 0;
	texArrayDesc.Usage              = D3D11_USAGE_DEFAULT;
	texArrayDesc.BindFlags          = D3D11_BIND_SHADER_RESOURCE;
	texArrayDesc.CPUAccessFlags     = 0;
	texArrayDesc.MiscFlags          = 0;

	ID3D11Texture2D* texArray = 0;
	HR(device->CreateTexture2D( &texArrayDesc, 0, &texArray));

	//
	// Copy individual texture elements into texture array.
	//

	// for each texture element...
	for(UINT texElement = 0; texElement < size; ++texElement)
	{
		// for each mipmap level...
		for(UINT mipLevel = 0; mipLevel < texElementDesc.MipLevels; ++mipLevel)
		{
			D3D11_MAPPED_SUBRESOURCE mappedTex2D;
			HR(context->Map(srcTex[texElement], mipLevel, D3D11_MAP_READ, 0, &mappedTex2D));

			context->UpdateSubresource(texArray, 
				D3D11CalcSubresource(mipLevel, texElement, texElementDesc.MipLevels),
				0, mappedTex2D.pData, mappedTex2D.RowPitch, mappedTex2D.DepthPitch);

			context->Unmap(srcTex[texElement], mipLevel);
		}
	}	

	//
	// Create a resource view to the texture array.
	//
	
	D3D11_SHADER_RESOURCE_VIEW_DESC viewDesc;
	viewDesc.Format = texArrayDesc.Format;
	viewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2DARRAY;
	viewDesc.Texture2DArray.MostDetailedMip = 0;
	viewDesc.Texture2DArray.MipLevels = texArrayDesc.MipLevels;
	viewDesc.Texture2DArray.FirstArraySlice = 0;
	viewDesc.Texture2DArray.ArraySize = size;

	ID3D11ShaderResourceView* texArraySRV = 0;
	HR(device->CreateShaderResourceView(texArray, &viewDesc, &texArraySRV));

	//
	// Cleanup--we only need the resource view.
	//

	ReleaseCOM(texArray);

	for(UINT i = 0; i < size; ++i)
		ReleaseCOM(srcTex[i]);

	return texArraySRV;
}

ID3D11ShaderResourceView* d3dHelper::CreateRandom_pTexture1DSRV(ID3D11Device* device)
{
	// 
	// Create the random data.
	//
	XMFLOAT4 randomValues[1024];

	for(int i = 0; i < 1024; ++i)
	{
		randomValues[i].x = MathHelper::RandF(-1.0f, 1.0f);
		randomValues[i].y = MathHelper::RandF(-1.0f, 1.0f);
		randomValues[i].z = MathHelper::RandF(-1.0f, 1.0f);
		randomValues[i].w = MathHelper::RandF(-1.0f, 1.0f);
	}

    D3D11_SUBRESOURCE_DATA initData;
    initData.pSysMem = randomValues;
	initData.SysMemPitch = 1024*sizeof(XMFLOAT4);
    initData.SysMemSlicePitch = 0;

	//
	// Create the texture.
	//
    D3D11_TEXTURE1D_DESC texDesc;
    texDesc.Width = 1024;
    texDesc.MipLevels = 1;
    texDesc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
    texDesc.Usage = D3D11_USAGE_IMMUTABLE;
    texDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
    texDesc.CPUAccessFlags = 0;
    texDesc.MiscFlags = 0;
    texDesc.ArraySize = 1;

	ID3D11Texture1D* randomTex = 0;
    HR(device->CreateTexture1D(&texDesc, &initData, &randomTex));

	//
	// Create the resource view.
	//
    D3D11_SHADER_RESOURCE_VIEW_DESC viewDesc;
	viewDesc.Format = texDesc.Format;
    viewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE1D;
    viewDesc.Texture1D.MipLevels = texDesc.MipLevels;
	viewDesc.Texture1D.MostDetailedMip = 0;
	
	ID3D11ShaderResourceView* randomTexSRV = 0;
    HR(device->CreateShaderResourceView(randomTex, &viewDesc, &randomTexSRV));

	ReleaseCOM(randomTex);

	return randomTexSRV;
}

void ExtractFrustumPlanes(XMFLOAT4 planes[6], CXMMATRIX M)
{
	//
	// Left
	//
	planes[0].x = M(0,3) + M(0,0);
	planes[0].y = M(1,3) + M(1,0);
	planes[0].z = M(2,3) + M(2,0);
	planes[0].w = M(3,3) + M(3,0);

	//
	// Right
	//
	planes[1].x = M(0,3) - M(0,0);
	planes[1].y = M(1,3) - M(1,0);
	planes[1].z = M(2,3) - M(2,0);
	planes[1].w = M(3,3) - M(3,0);

	//
	// Bottom
	//
	planes[2].x = M(0,3) + M(0,1);
	planes[2].y = M(1,3) + M(1,1);
	planes[2].z = M(2,3) + M(2,1);
	planes[2].w = M(3,3) + M(3,1);

	//
	// Top
	//
	planes[3].x = M(0,3) - M(0,1);
	planes[3].y = M(1,3) - M(1,1);
	planes[3].z = M(2,3) - M(2,1);
	planes[3].w = M(3,3) - M(3,1);

	//
	// Near
	//
	planes[4].x = M(0,2);
	planes[4].y = M(1,2);
	planes[4].z = M(2,2);
	planes[4].w = M(3,2);

	//
	// Far
	//
	planes[5].x = M(0,3) - M(0,2);
	planes[5].y = M(1,3) - M(1,2);
	planes[5].z = M(2,3) - M(2,2);
	planes[5].w = M(3,3) - M(3,2);

	// Normalize the plane equations.
	for(int i = 0; i < 6; ++i)
	{
		XMVECTOR v = XMPlaneNormalize(XMLoadFloat4(&planes[i]));
		XMStoreFloat4(&planes[i], v);
	}
}
```

`Source Code/d3dUtil.h`:

```h
//***************************************************************************************
// d3dUtil.h by Frank Luna (C) 2011 All Rights Reserved.
//***************************************************************************************

#ifndef D3DUTIL_H
#define D3DUTIL_H

#if defined(DEBUG) || defined(_DEBUG)
#define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>
#endif


#include <d3dx11.h>
#include "d3dx11Effect.h"
#include <xnamath.h>
#include <dxerr.h>
#include <cassert>
#include <ctime>
#include <algorithm>
#include <string>
#include <sstream>
#include <fstream>
#include <vector>
#include "MathHelper.h"

//---------------------------------------------------------------------------------------
// Simple d3d error checker for book demos.
//---------------------------------------------------------------------------------------

#if defined(DEBUG) | defined(_DEBUG)
	#ifndef HR
	#define HR(x)                                              \
	{                                                          \
		HRESULT hr = (x);                                      \
		if(FAILED(hr))                                         \
		{                                                      \
			DXTrace(__FILE__, (DWORD)__LINE__, hr, L#x, true); \
		}                                                      \
	}
	#endif

#else
	#ifndef HR
	#define HR(x) (x)
	#endif
#endif 


//---------------------------------------------------------------------------------------
// Convenience macro for releasing COM objects.
//---------------------------------------------------------------------------------------

#define ReleaseCOM(x) { if(x){ x->Release(); x = 0; } }

//---------------------------------------------------------------------------------------
// Convenience macro for deleting objects.
//---------------------------------------------------------------------------------------

#define SafeDelete(x) { delete x; x = 0; }

//---------------------------------------------------------------------------------------
// Utility classes.
//---------------------------------------------------------------------------------------

class d3dHelper
{
public:
	///<summary>
	/// 
	/// Does not work with compressed formats.
	///</summary>
	static ID3D11ShaderResourceView* CreateTexture2DArraySRV(
		ID3D11Device* device, ID3D11DeviceContext* context,
		std::vector<std::wstring>& filenames,
		DXGI_FORMAT format = DXGI_FORMAT_FROM_FILE,
		UINT filter = D3DX11_FILTER_NONE, 
		UINT mipFilter = D3DX11_FILTER_LINEAR);

	static ID3D11ShaderResourceView* CreateRandom_pTexture1DSRV(ID3D11Device* device);
};

class TextHelper
{
public:

	template<typename T>
	static D3DX11INLINE std::wstring ToString(const T& s)
	{
		std::wostringstream oss;
		oss << s;

		return oss.str();
	}

	template<typename T>
	static D3DX11INLINE T FromString(const std::wstring& s)
	{
		T x;
		std::wistringstream iss(s);
		iss >> x;

		return x;
	}
};

// Order: left, right, bottom, top, near, far.
void ExtractFrustumPlanes(XMFLOAT4 planes[6], CXMMATRIX M);


// #define XMGLOBALCONST extern CONST __declspec(selectany)
//   1. extern so there is only one copy of the variable, and not a separate
//      private copy in each .obj.
//   2. __declspec(selectany) so that the compiler does not complain about
//      multiple definitions in a .cpp file (it can pick anyone and discard 
//      the rest because they are constant--all the same).

namespace Colors
{
	XMGLOBALCONST XMVECTORF32 White     = {1.0f, 1.0f, 1.0f, 1.0f};
	XMGLOBALCONST XMVECTORF32 Black     = {0.0f, 0.0f, 0.0f, 1.0f};
	XMGLOBALCONST XMVECTORF32 Red       = {1.0f, 0.0f, 0.0f, 1.0f};
	XMGLOBALCONST XMVECTORF32 Green     = {0.0f, 1.0f, 0.0f, 1.0f};
	XMGLOBALCONST XMVECTORF32 Blue      = {0.0f, 0.0f, 1.0f, 1.0f};
	XMGLOBALCONST XMVECTORF32 Yellow    = {1.0f, 1.0f, 0.0f, 1.0f};
	XMGLOBALCONST XMVECTORF32 Cyan      = {0.0f, 1.0f, 1.0f, 1.0f};
	XMGLOBALCONST XMVECTORF32 Magenta   = {1.0f, 0.0f, 1.0f, 1.0f};

	XMGLOBALCONST XMVECTORF32 Silver    = {0.75f, 0.75f, 0.75f, 1.0f};
	XMGLOBALCONST XMVECTORF32 LightSteelBlue = {0.69f, 0.77f, 0.87f, 1.0f};
}

///<summary>
/// Utility class for converting between types and formats.
///</summary>
class Convert
{
public:
	///<summary>
	/// Converts XMVECTOR to XMCOLOR, where XMVECTOR represents a color.
	///</summary>
	static D3DX11INLINE XMCOLOR ToXmColor(FXMVECTOR v)
	{
		XMCOLOR dest;
		XMStoreColor(&dest, v);
		return dest;
	}

	///<summary>
	/// Converts XMVECTOR to XMFLOAT4, where XMVECTOR represents a color.
	///</summary>
	static D3DX11INLINE XMFLOAT4 ToXmFloat4(FXMVECTOR v)
	{
		XMFLOAT4 dest;
		XMStoreFloat4(&dest, v);
		return dest;
	}

	static D3DX11INLINE UINT ArgbToAbgr(UINT argb)
	{
		BYTE A = (argb >> 24) & 0xff;
		BYTE R = (argb >> 16) & 0xff;
		BYTE G = (argb >>  8) & 0xff;
		BYTE B = (argb >>  0) & 0xff;

		return (A << 24) | (B << 16) | (G << 8) | (R << 0);
	}

};

#endif // D3DUTIL_H
```

`Source Code/超级战机.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30320.27
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "超级战机", "超级战机.vcxproj", "{9397307D-73CF-4D08-9FFB-0A7E0331A8E3}"
	ProjectSection(ProjectDependencies) = postProject
		{DF460EAB-570D-4B50-9089-2E2FC801BF38} = {DF460EAB-570D-4B50-9089-2E2FC801BF38}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Effects11", "Effects11\Effects11_2010.vcxproj", "{DF460EAB-570D-4B50-9089-2E2FC801BF38}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Profile|x64 = Profile|x64
		Profile|x86 = Profile|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9397307D-73CF-4D08-9FFB-0A7E0331A8E3}.Debug|x64.ActiveCfg = Debug|x64
		{9397307D-73CF-4D08-9FFB-0A7E0331A8E3}.Debug|x64.Build.0 = Debug|x64
		{9397307D-73CF-4D08-9FFB-0A7E0331A8E3}.Debug|x86.ActiveCfg = Debug|Win32
		{9397307D-73CF-4D08-9FFB-0A7E0331A8E3}.Debug|x86.Build.0 = Debug|Win32
		{9397307D-73CF-4D08-9FFB-0A7E0331A8E3}.Profile|x64.ActiveCfg = Release|x64
		{9397307D-73CF-4D08-9FFB-0A7E0331A8E3}.Profile|x64.Build.0 = Release|x64
		{9397307D-73CF-4D08-9FFB-0A7E0331A8E3}.Profile|x86.ActiveCfg = Release|Win32
		{9397307D-73CF-4D08-9FFB-0A7E0331A8E3}.Profile|x86.Build.0 = Release|Win32
		{9397307D-73CF-4D08-9FFB-0A7E0331A8E3}.Release|x64.ActiveCfg = Release|x64
		{9397307D-73CF-4D08-9FFB-0A7E0331A8E3}.Release|x64.Build.0 = Release|x64
		{9397307D-73CF-4D08-9FFB-0A7E0331A8E3}.Release|x86.ActiveCfg = Release|Win32
		{9397307D-73CF-4D08-9FFB-0A7E0331A8E3}.Release|x86.Build.0 = Release|Win32
		{DF460EAB-570D-4B50-9089-2E2FC801BF38}.Debug|x64.ActiveCfg = Debug|x64
		{DF460EAB-570D-4B50-9089-2E2FC801BF38}.Debug|x64.Build.0 = Debug|x64
		{DF460EAB-570D-4B50-9089-2E2FC801BF38}.Debug|x86.ActiveCfg = Debug|Win32
		{DF460EAB-570D-4B50-9089-2E2FC801BF38}.Debug|x86.Build.0 = Debug|Win32
		{DF460EAB-570D-4B50-9089-2E2FC801BF38}.Profile|x64.ActiveCfg = Profile|x64
		{DF460EAB-570D-4B50-9089-2E2FC801BF38}.Profile|x64.Build.0 = Profile|x64
		{DF460EAB-570D-4B50-9089-2E2FC801BF38}.Profile|x86.ActiveCfg = Profile|Win32
		{DF460EAB-570D-4B50-9089-2E2FC801BF38}.Profile|x86.Build.0 = Profile|Win32
		{DF460EAB-570D-4B50-9089-2E2FC801BF38}.Release|x64.ActiveCfg = Release|x64
		{DF460EAB-570D-4B50-9089-2E2FC801BF38}.Release|x64.Build.0 = Release|x64
		{DF460EAB-570D-4B50-9089-2E2FC801BF38}.Release|x86.ActiveCfg = Release|Win32
		{DF460EAB-570D-4B50-9089-2E2FC801BF38}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7B385E6F-7E7C-4D1C-92D7-CA51773807E1}
	EndGlobalSection
EndGlobal

```

`Source Code/超级战机.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{9397307D-73CF-4D08-9FFB-0A7E0331A8E3}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>超级战机</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)</OutDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>Effects11\Inc;$(DXSDK_DIR)Include;</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <AdditionalLibraryDirectories>Effects11\Bin;$(DXSDK_DIR)Lib\x86;</AdditionalLibraryDirectories>
    </Link>
    <FxCompile>
      <ShaderModel>5.0</ShaderModel>
    </FxCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>Effects11\Inc;$(DXSDK_DIR)Include;</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <AdditionalLibraryDirectories>Effects11\Bin;$(DXSDK_DIR)Lib\x64</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>Effects11\Inc;$(DXSDK_DIR)Include;</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>Effects11\Bin;$(DXSDK_DIR)Lib\x86;</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>Effects11\Inc;$(DXSDK_DIR)Include;</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>Effects11\Bin;$(DXSDK_DIR)Lib\x64</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="d2dText.cpp" />
    <ClCompile Include="d3dApp.cpp" />
    <ClCompile Include="d3dUtil.cpp" />
    <ClCompile Include="DirectSound.cpp" />
    <ClCompile Include="GameApp.cpp" />
    <ClCompile Include="GameTimer.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="MathHelper.cpp" />
    <ClCompile Include="MKInput.cpp" />
    <ClCompile Include="PlaneManager.cpp" />
    <ClCompile Include="Sprite.cpp" />
    <ClCompile Include="XUtility.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="d2dText.h" />
    <ClInclude Include="d3dApp.h" />
    <ClInclude Include="d3dUtil.h" />
    <ClInclude Include="DirectSound.h" />
    <ClInclude Include="GameApp.h" />
    <ClInclude Include="GameTimer.h" />
    <ClInclude Include="MathHelper.h" />
    <ClInclude Include="MKInput.h" />
    <ClInclude Include="PlaneManager.h" />
    <ClInclude Include="Sprite.h" />
    <ClInclude Include="XUtility.h" />
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="HLSL\Basic.hlsl">
      <EntryPointName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">VS_2D</EntryPointName>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">5.0</ShaderModel>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="HLSL\Basic.hlsli">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Text Include="Data\EnemyInfo.txt" />
    <Text Include="Data\EnemyLevel1.txt" />
    <Text Include="Data\EnemyLevel2.txt" />
    <Text Include="Data\EnemyLevel3.txt" />
    <Text Include="Data\EnemyLevel4.txt" />
    <Text Include="Data\EnemyLevel5.txt" />
    <Text Include="Data\EnemyLevel6.txt" />
    <Text Include="Data\EnemyLevel7.txt" />
    <Text Include="Data\Parser.txt" />
    <Text Include="Data\Stage1.txt" />
    <Text Include="Data\Stage2.txt" />
    <Text Include="Data\Stage3.txt" />
    <Text Include="Data\Stage4.txt" />
    <Text Include="Data\Stage5.txt" />
    <Text Include="Data\Stage6.txt" />
    <Text Include="Data\Stage7.txt" />
    <Text Include="Data\Temp.txt" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="shield.png" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Source Code/超级战机.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="HLSL">
      <UniqueIdentifier>{40410326-894c-4e9d-908f-93b41af1d1cb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Data">
      <UniqueIdentifier>{453224ef-5410-4ead-a4ce-dcea635ef9fe}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="d2dText.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="XUtility.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="Sprite.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="MKInput.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="MathHelper.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="GameTimer.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="GameApp.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="d3dUtil.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="d3dApp.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="Main.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="PlaneManager.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="DirectSound.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="d2dText.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="d3dApp.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="d3dUtil.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="GameApp.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="GameTimer.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="MathHelper.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="MKInput.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Sprite.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="XUtility.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="DirectSound.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="PlaneManager.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="HLSL\Basic.hlsl">
      <Filter>HLSL</Filter>
    </FxCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="HLSL\Basic.hlsli">
      <Filter>HLSL</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Text Include="Data\EnemyInfo.txt">
      <Filter>Data</Filter>
    </Text>
    <Text Include="Data\EnemyLevel1.txt">
      <Filter>Data</Filter>
    </Text>
    <Text Include="Data\Parser.txt">
      <Filter>Data</Filter>
    </Text>
    <Text Include="Data\Stage1.txt">
      <Filter>Data</Filter>
    </Text>
    <Text Include="Data\Temp.txt">
      <Filter>Data</Filter>
    </Text>
    <Text Include="Data\EnemyLevel2.txt">
      <Filter>Data</Filter>
    </Text>
    <Text Include="Data\Stage2.txt">
      <Filter>Data</Filter>
    </Text>
    <Text Include="Data\EnemyLevel3.txt">
      <Filter>Data</Filter>
    </Text>
    <Text Include="Data\Stage3.txt">
      <Filter>Data</Filter>
    </Text>
    <Text Include="Data\EnemyLevel4.txt">
      <Filter>Data</Filter>
    </Text>
    <Text Include="Data\Stage4.txt">
      <Filter>Data</Filter>
    </Text>
    <Text Include="Data\EnemyLevel5.txt">
      <Filter>Data</Filter>
    </Text>
    <Text Include="Data\Stage5.txt">
      <Filter>Data</Filter>
    </Text>
    <Text Include="Data\EnemyLevel6.txt">
      <Filter>Data</Filter>
    </Text>
    <Text Include="Data\Stage6.txt">
      <Filter>Data</Filter>
    </Text>
    <Text Include="Data\EnemyLevel7.txt">
      <Filter>Data</Filter>
    </Text>
    <Text Include="Data\Stage7.txt">
      <Filter>Data</Filter>
    </Text>
  </ItemGroup>
  <ItemGroup>
    <Image Include="shield.png">
      <Filter>资源文件</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`Source Code/超级战机.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```