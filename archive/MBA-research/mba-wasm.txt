Project Path: arc_MBA-research_mba-wasm_jcdqyhv2

Source Tree:

```txt
arc_MBA-research_mba-wasm_jcdqyhv2
├── Cargo.toml
├── readme.md
├── src
│   ├── congruence_solver.rs
│   ├── expr.rs
│   ├── lib.rs
│   ├── matrix.rs
│   ├── numbers.rs
│   ├── pages
│   │   ├── linear_congruences.rs
│   │   ├── mod.rs
│   │   ├── obfuscate.rs
│   │   └── perm_poly.rs
│   ├── polynomial.rs
│   ├── printer.rs
│   ├── uniform_expr.rs
│   └── vector.rs
└── www
    ├── index.html
    ├── linear_congruences.html
    ├── linear_congruences.js
    ├── linear_mba.html
    ├── linear_mba.js
    ├── mathjax.js
    ├── obfuscate.js
    ├── perm_poly.html
    ├── perm_poly.js
    ├── prism.css
    └── wasm.js

```

`Cargo.toml`:

```toml
[package]
name = "mba-wasm"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = "0.2"
web-sys = { version = "0.3", features = ["Window", "Performance"] }
js-sys = "0.3"
num-traits = "0.2"
rand = "0.8"
getrandom = { version = "0.2", features = ["js"] }
```

`readme.md`:

```md
# Mixed Boolean-Arithmetic Obfuscation
The algorithm transforms expressions like `x+y` into things like this:
```c
-38*(x & y) - 83*(x ^ y) - 64*~(x ^ (y ^ z)) - 41*~x - 43*~y - 23*y - 44*z - 20*(y & z) - 21*(x | z) - 107*(~x & z) - 108*(y | ~z)
```
These kind of expressions involving both normal arithmetic as well as boolean operations are known as mixed boolean-arithmetic expressions.
This particular transformation is only valid when `x` and `y` (and `z`) are 8-bit integers and the usual rules of computer arithmetic apply (e.g. when adding/multiplying numbers and there is an overflow then the most significant bits that can not be represented are cut off).
In particular this will not work when the numbers are floating point numbers.
Rust itself will panic (at least in debug builds) when addition/multiplication overflows so in order to use this with rust you will have to use the [Wrapping](https://doc.rust-lang.org/std/num/struct.Wrapping.html) types.

### Usage
There is a [web interface](https://plzin.github.io/mba-wasm/).

Generating linear MBA expressions involves solving systems of linear congruences
which can be done [here](https://plzin.github.io/mba-wasm/linear_congruences.html).
This was mostly used during debugging but hopefully someone can find use for this.

### How it works
If you want to understand the algorithm, check out my [blog post](https://plzin.github.io/posts/mba) about it.
The algorithm is implemented in Rust and compiles to WebAssembly, that will be run in your browser.

### To Do
Currently only linear MBA expressions are implemented.
The permutation polynomial part is missing.
```

`src/congruence_solver.rs`:

```rs
use std::fmt::Display;
use crate::matrix::Matrix;
use crate::vector::Vector;
use crate::numbers::UnsignedInt;

pub struct AffineLattice<T> {
    pub offset: Vector<T>,
    pub basis: Vec<Vector<T>>,
}

impl<T> AffineLattice<T> {
    pub fn empty() -> Self {
        Self {
            offset: Vector::empty(),
            basis: Vec::new(),
        }
    }

    pub fn is_empty(&self) -> bool {
        self.offset.is_empty()
    }
}

impl<T: UnsignedInt> AffineLattice<T> {
    pub fn to_tex(&self) -> String {
        let mut s = self.offset.to_tex();
        for (i, b) in self.basis.iter().enumerate() {
            s += &std::format!("+a_{}{}", i + 1, b.to_tex());
        }
        s
    }

    pub fn to_tex_brace(&self) -> String {
        if self.basis.is_empty() {
            self.to_tex()
        } else {
            format!("\\left({}\\right)", self.to_tex())
        }
    }
}


/// Solves ax=b mod n where n = 2^8 for u8.
/// Returns None if there is no solution.
/// Otherwise returns all solutions in the form (c, d)
/// where c+di are all solutions.
pub fn solve_scalar_congruence<T: UnsignedInt>(
    a: T, b: T
) -> Option<(T, T)> {
    // Handle the case that a is zero, so we don't have to think about it.
    if a == T::zero() {
        return (b == T::zero()).then_some((T::zero(), T::one()));
    }

    // We are basically going to use the extended euclidean algorithm on
    // the diophantine equation ax+ny=b where n is the number of values
    // (2^8 for u8).
    // But n doesn't fit into T, so we have to do a hack in the first step.
    // Usually we'd divide n by a but instead we divide n-a by a and add 1.
    // This makes the code structurally uglier, but otherwise I'm pretty
    // much just following the pseudo code on wikipedia.
    
    let (mut old_r, mut r) = (T::zero(), a);
    let (mut old_t, mut t) = (T::zero(), T::one());
    let mut q = (T::zero() - a) / a + T::one();

    loop {
        (old_r, r) = (r, old_r - q * r);
        (old_t, t) = (t, old_t - q * t);
        if r == T::zero() {
            break;
        }
        q = old_r / r;
    }

    // old_r is gcd(a, n).
    let gcd = old_r;

    // There is a solution iff gcd divides b, but we can also just check ax=b.
    // old_t is the Bezout coefficient: a*old_t=gcd(a, n) mod n.
    let x = b / gcd * old_t;
    if a * x != b {
        return None;
    }

    // The kernel is n / gcd which happens to be in t.
    // If the kernel is greater than n/2 we can take -t
    // which is smaller.
    let kern = std::cmp::min(t, T::zero() - t);

    Some((x, t))
}

/// Solves a system of linear congruences Ax=b.
pub fn solve_congruences<T: UnsignedInt>(
    mut a: Matrix<T>, b: &Vector<T>
) -> AffineLattice<T> {
    debug_assert!(a.rows == b.dim, "Invalid system of congruences");

    // Diagonalize the system.
    let (s, t) = diagonalize(&mut a);
    
    // Transform the vector b.
    // We could already do this in diagonalize if we really wanted.
    let b = (&s * b);

    // If there is a non-zero entry in b at index >a.min_dim()
    // then the system has no solution, since the corresponding
    // row in a is zero, so we are solving 0=x.
    if b.iter().skip(a.min_dim()).any(|e| *e != T::zero()) {
        return AffineLattice::empty();
    }

    // Some solution to the system.
    let mut offset = Vector::zero(a.cols);

    // The basis of the kernel.
    let mut basis = Vec::new();

    // Solve the scalar linear congruences.
    for i in 0..a.min_dim() {
        let (x, kern) = match solve_scalar_congruence(a[(i, i)], b[i]) {
            // If there is no solution,
            // then the whole system does not have a solution.
            None => return AffineLattice::empty(),
            Some(s) => s,
        };

        // The particular solution is an entry is
        // the particular solution of the whole system.
        offset[i] = x;

        // If the kernel is zero, then the vector is zero for sure.
        if kern != T::zero() {
            let mut v = Vector::zero(a.cols);
            v[i] = kern;
            basis.push(v);
        }
    }

    // If there are more variables then equations
    // then there are no restrictions on the variables
    // from index d.rows
    for i in a.rows..a.cols {
        let mut v = Vector::zero(a.cols);
        v[i] = T::one();
        basis.push(v);
    }

    offset = (&t * &offset);
    for v in &mut basis {
        *v = (&t * &*v);
    }

    AffineLattice {
        offset,
        basis
    }
}

/// Computes a diagonal matrix D in-place
/// and returns matrices (S, T), such that D=SAT.
pub fn diagonalize<T: UnsignedInt>(
    a: &mut Matrix<T>
) -> (Matrix<T>, Matrix<T>) {
    // The matrices S and T are initialized to the identity.
    // S/T keeps track of the row/column operations.
    let mut s = Matrix::<T>::id(a.rows);
    let mut t = Matrix::<T>::id(a.cols);

    for i in 0..a.min_dim() {
        //
        // Eliminate row i and column i.
        //
        loop {
            // Is there a non-zero element in the column?
            let col_zero = a.col(i)
                .skip(i+1)
                .all(|e| *e == T::zero());

            if (!col_zero) {
                //
                // Eliminate the column.
                //

                // Find a pivot in the column.
                let pivot = a.col(i)
                    .enumerate()
                    .skip(i)
                    .filter(|e| *e.1 != T::zero())
                    .min_by_key(|e| e.1)
                    .map(|e| e.0)
                    .unwrap(); // We know there is a non-zero element.

                // Move the pivot to the beginning.
                a.swap_rows(i, pivot);
                s.swap_rows(i, pivot);

                // Try to eliminate every other entry in the column.
                for k in i+1..a.rows {
                    if a[(k, i)] != T::zero() {
                        let m = T::zero() - (a[(k, i)] / a[(i, i)]);
                        a.row_multiply_add(i, k, m);
                        s.row_multiply_add(i, k, m);
                    }
                }

                // Keep eliminating the column.
                continue;
            }

            // If we get here, the column is zero.

            // Is there a non-zero element in the row?
            let row_zero = a.row(i)
                .iter()
                .skip(i+1)
                .all(|e| *e == T::zero());
            
            // If the row is zero, then continue with the next row/column.
            if row_zero {
                break;
            }
            
            //
            // Eliminate the row.
            //

            // Find a pivot in the row.
            let pivot = a.row(i)
                .iter()
                .enumerate()
                .skip(i)
                .filter(|e| *e.1 != T::zero())
                .min_by_key(|e| e.1)
                .map(|e| e.0)
                .unwrap(); // We know there is a non-zero element.

            // Move the pivot to the beginning.
            a.swap_columns(i, pivot);
            t.swap_columns(i, pivot);

            // Try to eliminate every other entry in the row.
            for k in i+1..a.cols {
                if a[(i, k)] != T::zero() {
                    let m = T::zero() - (a[(i, k)] / a[(i, i)]);
                    a.col_multiply_add(i, k, m);
                    t.col_multiply_add(i, k, m);
                }
            }
        }
    }

    return (s, t);
}

/// Solves ax=b mod n.
/// Returns None if there is no solution.
/// Otherwise returns all solutions in the form (c, d)
/// where c+di are all solutions.
pub fn solve_scalar_congruence_mod<T: UnsignedInt>(
    a: T, b: T, n: T
) -> Option<(T, T)> {
    assert!(!n.is_zero());
    // Handle the case that a is zero, so we don't have to think about it.
    if a == T::zero() {
        return (b == T::zero()).then_some((T::zero(), T::one()));
    }

    let (mut old_r, mut r) = (a, n);
    let (mut old_t, mut t) = (T::zero(), T::one());
    while !r.is_zero() {
        let q = old_r / r;
        (old_r, r) = (r, old_r - q * r);
        (old_t, t) = (t, old_t - q * t);
    }

    // old_r is gcd(a, n).
    let gcd = old_r;

    // There is a solution iff gcd divides b, but we can also just check ax=b.
    // old_t is the Bezout coefficient: a*old_t=gcd(a, n) mod n.
    let x = b / gcd * old_t;
    if a * x != b {
        return None;
    }

    // The kernel is n / gcd which happens to be in t.
    // If the kernel is greater than n/2 we can take -t
    // which is smaller.
    let kern = std::cmp::min(t, T::zero() - t);

    Some((x, t))
}
```

`src/expr.rs`:

```rs
use std::rc::Rc;
use std::fmt::Write;
use std::collections::BTreeSet;
use crate::{numbers::{UnsignedInt, int_from_it}, printer::Printer};

#[derive(Debug, Clone)]
pub enum Expr<T> {
    Const(T),
    Var(String),

    // Arithmetic
    Add(Rc<Expr<T>>, Rc<Expr<T>>),
    Sub(Rc<Expr<T>>, Rc<Expr<T>>),
    Mul(Rc<Expr<T>>, Rc<Expr<T>>),
    Div(Rc<Expr<T>>, Rc<Expr<T>>),
    Mod(Rc<Expr<T>>, Rc<Expr<T>>),
    Neg(Rc<Expr<T>>),

    // Boolean
    And(Rc<Expr<T>>, Rc<Expr<T>>),
    Or(Rc<Expr<T>>, Rc<Expr<T>>),
    Xor(Rc<Expr<T>>, Rc<Expr<T>>),
    Shl(Rc<Expr<T>>, Rc<Expr<T>>),
    Shr(Rc<Expr<T>>, Rc<Expr<T>>),
    Not(Rc<Expr<T>>),
}

impl<T: UnsignedInt> Expr<T> {
    /// Returns the zero constant.
    pub fn zero() -> Self {
        Self::Const(T::zero())
    }

    /// Returns all variables in the expression.
    pub fn vars(&self) -> Vec<String> {
        let mut v = BTreeSet::new();
        self.vars_impl(&mut v);
        v.into_iter().collect()
    }

    fn vars_impl(&self, v: &mut BTreeSet<String>) {
        match self {
            Expr::Const(_) => {},
            Expr::Var(name) => drop(v.insert(name.clone())),
            Expr::Neg(e) | Expr::Not(e) => e.vars_impl(v),

            Expr::Add(l, r) | Expr::Sub(l, r) | Expr::Mul(l, r)
            | Expr::Div(l, r) | Expr::Mod(l, r) | Expr::And(l, r)
            | Expr::Or(l, r) | Expr::Xor(l, r) | Expr::Shl(l, r)
            | Expr::Shr(l, r) => {
                l.vars_impl(v);
                r.vars_impl(v);
            }
        }
    }

    /// Substitute and expression for a variable.
    pub fn substitute(&mut self, e: &mut Rc<Expr<T>>, var: &str) {
        let mut visited = Vec::new();
        match self {
            Expr::Const(_) => {},
            Expr::Var(v) => if v == var { *self = e.as_ref().clone() },
            Expr::Neg(i) | Expr::Not(i) => Self::substitute_impl(i, var, e, &mut visited),
            Expr::Add(l, r) | Expr::Sub(l, r) | Expr::Mul(l, r)
            | Expr::Div(l, r) | Expr::Mod(l, r) | Expr::And(l, r)
            | Expr::Or(l, r) | Expr::Xor(l, r) | Expr::Shl(l, r)
            | Expr::Shr(l, r) => {
                Self::substitute_impl(l, var, e, &mut visited);
                Self::substitute_impl(r, var, e, &mut visited);
            },
        }
    }

    fn substitute_impl(
        this: &mut Rc<Expr<T>>, var: &str,
        e: &mut Rc<Expr<T>>, visited: &mut Vec<*const Expr<T>>
    ) {
        let ptr = Rc::as_ptr(this);
        let recurse = if visited.contains(&ptr) {
            false
        } else {
            visited.push(ptr);
            true
        };


        use Expr::*;
        // SAFETY: This is okay because we make sure with extra logic
        // that this is never encountered twice.
        match unsafe { &mut *(ptr as *mut _) } {
            Const(_) => {},
            Var(v) => if v == var { *this = e.clone() },
            Add(l, r) | Sub(l, r) | Mul(l, r) | Div(l, r) | Mod(l, r)
            | And(l, r) | Or(l, r) | Xor(l, r) | Shl(l, r)
            | Shr(l, r) => if recurse {
                    Self::substitute_impl(l, var, e, visited);
                    Self::substitute_impl(r, var, e, visited);
            },
            Neg(i) | Not(i) => if recurse {
                Self::substitute_impl(i, var, e, visited)
            },
        }
    }

    /// Returns the precedence of a binary operator.
    /// All operators are treated as being left associative.
    fn precedence(&self) -> usize {
        use Expr::*;
        match self {
            Or(_, _) => 1,
            Xor(_, _) => 2,
            And(_, _) => 3,
            Shl(_, _) | Shr(_, _) => 4,
            Add(_, _) | Sub(_, _) => 5,
            Mul(_, _) | Div(_, _) | Mod(_, _) => 6,
            Neg(_) | Not(_) => 255,
            Const(_) | Var(_) => 256,
        }
    }

    /// Parse an expression from a string.
    /// Can't parse shifts at the moment.
    /// Closing brackets are a bit broken.
    pub fn from_string<U: ToString>(s: U) -> Result<Expr<T>, String> {
        let mut s = s.to_string();
        s.retain(|c| !c.is_whitespace());
        let mut it = s.chars().peekable();

        Self::parse(&mut it, 0)
    }

    // pre 0: parse as much as possible
    // ...
    // pre 15: parse as little as possible
    fn parse(
        it: &mut std::iter::Peekable<std::str::Chars>,
        pre: usize
    ) -> Result<Self, String> {
        use Expr::*;

        let mut c = *it.peek()
            .ok_or_else(|| "Unexpected end of input".to_owned())?;

        let mut e = if c == '(' {
            it.next();
            let e = Self::parse(it, 0)?;
            match it.next() {
                Some(')') => e,
                _ => return Err("Closing bracket missing".into()),
            }
        } else if c == '~' {
            it.next();
            let e = Self::parse(it, 15)?;
            Not(Rc::new(e))
        } else if c == '-' {
            it.next();
            let e = Self::parse(it, 15)?;
            Neg(Rc::new(e))
        } else if c.is_alphabetic() {
            it.next();
            let mut var = String::from(c);
            loop {
                let Some(c) = it.peek() else {
                    break
                };

                if !c.is_alphanumeric() {
                    break
                }

                var.push(*c);
                it.next();
            }
            
            Var(var)
        } else if c.is_ascii_digit() {
            // This can't panic because we check that
            // the character is an ascii digit.
            let num = int_from_it(it).unwrap();
            Const(num)
        } else {
            return Err("Unrecognized character".into());
        };

        loop {
            let c = match it.peek() {
                None => return Ok(e),
                Some(c) => *c,
            };

            let op_pre = match c {
                '|' => 1,
                '^' => 2,
                '&' => 3,
                '+' | '-' => 5,
                '*' | '/' | '%' => 6,
                ')' => return Ok(e),
                _ => return Err("Unknown operator".into()),
            };

            if op_pre <= pre {
                return Ok(e);
            }

            // If the current operators precedence is higher than
            // the one whose subexpression we are currently parsing
            // then we need to finish this operator first.
            it.next();
            let rhs = Rc::new(Self::parse(it, op_pre)?);
            let lhs = Rc::new(e);
            e = match c {
                '+' => Add(lhs, rhs),
                '-' => Sub(lhs, rhs),
                '*' => Mul(lhs, rhs),
                '/' => Div(lhs, rhs),
                '%' => Mod(lhs, rhs),
                '&' => And(lhs, rhs),
                '|' => Or(lhs, rhs),
                '^' => Xor(lhs, rhs),
                _ => unreachable!(),
            };
        };
    }

    /// Prints the expression while avoiding reprinting
    /// common subexpressions by assigning them to variables.
    /// This only works if the Rc's used in the expression
    /// are not shared with other expressions.
    pub fn print_as_fn(&self, printer: Printer) -> String {
        assert!(printer != Printer::Tex,
            "Tex printing is not supported for general expressions.");

        let mut input = self.vars();
        // This shouldn't really be done here,
        // but I can't be bothered.
        input.sort_by(|l, r| {
            if l.starts_with("aux") {
                if r.starts_with("aux") {
                    l.cmp(r)
                } else {
                    std::cmp::Ordering::Greater
                }
            } else if r.starts_with("aux") {
                std::cmp::Ordering::Less
            } else {
                l.cmp(r)
            }
        });

        // Stores a mapping of (sub)expressions to variables.
        let mut vars = Vec::new();

        let l = self.print_simple_impl(&mut vars, printer);

        let mut s = String::new();
        if printer == Printer::Default {
            for (_, var, init) in vars.iter().rev() {
                write!(&mut s, "{} = {}", var, init);
            }
        } else if printer == Printer::C {
            let ty = match std::mem::size_of::<T>() {
                1 => "uint8_t",
                2 => "uint16_t",
                4 => "uint32_t",
                8 => "uint64_t",
                16 => "uint128_t",
                _ => panic!("Unknown type."),
            };

            write!(&mut s, "{} f(", ty);
            for v in &input {
                write!(&mut s, "{} {}, ", ty, v);
            }
            s.pop();
            s.pop();
            write!(&mut s, ") {{\n");

            for (_, var, init) in vars.iter().rev() {
                write!(&mut s, "\t{} {} = {};\n", ty, var, init);
            }

            write!(&mut s, "\treturn {};\n}}", &l);
        } else if printer == Printer::Rust {
            let ty = match std::mem::size_of::<T>() {
                1 => "Wrapping<u8>",
                2 => "Wrapping<u16>",
                4 => "Wrapping<u32>",
                8 => "Wrapping<u64>",
                16 => "Wrapping<u128>",
                _ => panic!("Unknown type."),
            };

            write!(&mut s, "fn f(");
            for v in &input {
                write!(&mut s, "{}: {}, ", v, ty);
            }
            s.pop();
            s.pop();
            write!(&mut s, ") -> {} {{\n", ty);

            for (_, var, init) in vars.iter().rev() {
                write!(&mut s, "\tlet {} = {};\n", var, init);
            }

            write!(&mut s, "\t{}\n}}", &l);
        } else {
            assert!(false, "Unsupported printer.");
        }

        s
    }

    fn print_simple_rc(
        e: &Rc<Self>,
        vars: &mut Vec<(*const Self, String, String)>,
        printer: Printer
    ) -> String {
        // If there is only one reference then just print it.
        if Rc::strong_count(e) == 1 {
            return e.print_simple_impl(vars, printer);
        }

        // We don't want to assign a variable to a variable
        // so there is this shortcut here.
        if let Expr::Var(v) = &**e {
            return format!("{}", *v);
        }

        let ptr = Rc::as_ptr(e);

        // If the expression already has a variable then just print the variable.
        let var = vars.iter().find(|t| t.0 == ptr);
        if let Some(v) = var {
            v.1.clone()
        } else {
            let v = format!("var{}", vars.len());

            // Push everything.
            vars.push((ptr, v.clone(), String::new()));

            let idx = vars.len() - 1;

            // Get the initializer for the variable.
            vars[idx].2 = e.print_simple_impl(vars, printer);

            // Return just the variable name.
            v
        }
    }

    // Yes, this PERFORMANCE CRITICAL code could be more efficient...
    fn print_simple_impl(
        &self,
        vars: &mut Vec<(*const Self, String, String)>,
        printer: Printer
    ) -> String {
        // Print a binary operation.
        let bin_op = |
            op: &str, l: &Rc<Self>, r: &Rc<Self>,
            vars: &mut Vec<(*const Self, String, String)>
        | {
            let pred = self.precedence();

            let l = if pred > l.precedence() && Rc::strong_count(l) == 1 {
                format!("({})", Self::print_simple_rc(l, vars, printer))
            } else {
                format!("{}", Self::print_simple_rc(l, vars, printer))
            };

            let r = if pred > r.precedence() && Rc::strong_count(r) == 1 {
                format!("({})", Self::print_simple_rc(r, vars, printer))
            } else {
                format!("{}", Self::print_simple_rc(r, vars, printer))
            };

            format!("{} {} {}", l, op, r)
        };

        // Print a unary operation.
        let un_op = |
            op: &str, i: &Rc<Self>,
            vars: &mut Vec<(*const Self, String, String)>
        | {
            if self.precedence() > i.precedence() && Rc::strong_count(i) == 1 {
                format!("{}({})", op, Self::print_simple_rc(i, vars, printer))
            } else {
                format!("{}{}", op, Self::print_simple_rc(i, vars, printer))
            }
        };

        use Expr::*;
        match self {
            Const(i) if printer == Printer::Rust => format!("Wrapping({})", i),
            Const(i) => format!("{}", i),
            Var(n) => format!("{}", n),
            Add(l, r) => bin_op("+", l, r, vars),
            Sub(l, r) => bin_op("-", l, r, vars),
            Mul(l, r) => bin_op("*", l, r, vars),
            Div(l, r) => bin_op("/", l, r, vars),
            Mod(l, r) => bin_op("%", l, r, vars),
            Neg(i) => un_op("-", i, vars),
            And(l, r) => bin_op("&", l, r, vars),
            Or(l, r) => bin_op("|", l, r, vars),
            Xor(l, r) => bin_op("^", l, r, vars),
            Shl(l, r) => bin_op("<<", l, r, vars),
            Shr(l, r) => bin_op(">>", l, r, vars),
            Not(i) if printer == Printer::Rust => un_op("!", i, vars),
            Not(i) => un_op("~", i, vars),
        }
    }
}
```

`src/lib.rs`:

```rs
#![allow(unused)]

mod vector;
mod matrix;
mod numbers;
mod polynomial;
mod congruence_solver;
mod expr;
mod uniform_expr;
mod printer;
mod pages;

use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    pub fn log(s: &str);
}

```

`src/matrix.rs`:

```rs
use std::boxed::Box;
use std::marker::PhantomData;
use std::ops::{Index, IndexMut, Mul};
use std::fmt::Write;
use num_traits::{Num, NumAssign};
use crate::numbers::UnsignedInt;
use crate::vector::Vector;

#[derive(Clone)]
pub struct Matrix<T> {
    /// The number of rows.
    pub rows: usize,

    /// The number of column.
    pub cols: usize,

    /// Memory that holds the entries.
    pub(self) entries: Box<[T]>,
}

impl<T> Matrix<T> {
    /// Return an empty matrix.
    pub fn empty() -> Self {
        Self {
            rows: 0,
            cols: 0,
            entries: Box::new([]),
        }
    }

    /// Create a matrix from an array.
    pub fn from_array<U: Into<T>, const R: usize, const C: usize>(
        a: [[U; C]; R]
    ) -> Self {
        let entries = a.into_iter()
            .flatten()
            .map(|e| e.into())
            .collect::<Vec<_>>()
            .into_boxed_slice();

        Self {
            rows: R,
            cols: C,
            entries,
        }
    }

    /// Returns the minimum of the two dimension.
    pub fn min_dim(&self) -> usize {
        std::cmp::min(self.rows, self.cols)
    }

    /// Returns a reference to an entry.
    pub fn entry(&self, r: usize, c: usize) -> &T {
        &self.entries[r * self.cols + c]
    }

    /// Returns a mutable reference to an entry.
    pub fn entry_mut(&mut self, r: usize, c: usize) -> &mut T {
        &mut self.entries[r * self.cols + c]
    }

    /// Returns a pointer to an entry.
    pub fn entry_ptr(&mut self, r: usize, c: usize) -> *mut T {
        self.entry_mut(r, c) as *mut T
    }

    /// Returns a row as a slice.
    pub fn row(&self, r: usize) -> &[T] {
        let i = r * self.cols;
        &self.entries[i..i+self.cols]
    }

    /// Returns a row as a mutable slice.
    pub fn row_mut(&mut self, r: usize) -> &mut [T] {
        let i = r * self.cols;
        &mut self.entries[i..i+self.cols]
    }

    /// Returns an iterator over the column.
    pub fn col(&self, c: usize) -> Column<T> {
        Column::from_matrix(self, c)
    }

    /// Returns an iterator over mutable references to the elements in the column.
    pub fn col_mut(&mut self, c: usize) -> ColumnMut<T> {
        ColumnMut::from_matrix(self, c)
    }

    /// Apply a function to each entry.
    pub fn map<U, F>(&self, mut f: F) -> Matrix<U>
        where F: FnMut(&T) -> U
    {
        let mut v = Vec::with_capacity(self.entries.len());
        for e in self.entries.iter() {
            v.push(f(e));
        }
        
        Matrix::<U> {
            rows: self.rows,
            cols: self.cols,
            entries: v.into_boxed_slice()
        }
    }

    /// Apply a function to each entry that can fail.
    /// If the function for the first time, then that resulting error
    /// and the location of the entry is returned.
    pub fn try_map<U, E, F>(&self, mut f: F) -> Result<Matrix<U>, (usize, usize, E)>
        where F: FnMut(&T) -> Result<U, E>
    {
        let mut v = Vec::with_capacity(self.entries.len());
        for e in self.entries.iter() {
            match f(e) {
                Ok(e) => v.push(e),
                Err(e) => {
                    let row = v.len() / self.rows;
                    let col = v.len() % self.cols;
                    return Err((row, col, e));
                }
            }
        }
        
        Ok(Matrix::<U> {
            rows: self.rows,
            cols: self.cols,
            entries: v.into_boxed_slice()
        })
    }
}

impl<T: Clone> Matrix<T> {
    /// Creates a new matrix whose entries are initialized with `val`.
    pub fn uniform(r: usize, c: usize, val: T) -> Self {
        Self {
            rows: r,
            cols: c,
            entries: vec![val; r*c].into_boxed_slice(),
        }
    }
}

impl<T: NumAssign + Copy> Matrix<T> {
    /// Returns a r×c zero matrix.
    pub fn zero(r: usize, c: usize) -> Self {
        if r == 0 || c == 0 {
            return Self::empty();
        }

        Self {
            rows: r,
            cols: c,
            entries: vec![T::zero(); r*c].into_boxed_slice(),
        }
    }

    /// Returns an n×n identity matrix.
    pub fn id(n: usize) -> Self {
        let mut m = Self::zero(n, n);
        for i in 0..n {
            m[(i, i)] = T::one();
        }
        m
    }

    /// Swap two rows.
    pub fn swap_rows(&mut self, i: usize, j: usize) {
        if i == j { return }

        unsafe {
            core::ptr::swap_nonoverlapping(
                self.entry_ptr(i, 0),
                self.entry_ptr(j, 0), self.cols
            )
        }
    }

    /// Swap two columns.
    pub fn swap_columns(&mut self, i: usize, j: usize) {
        if i == j { return }

        for k in 0..self.rows {
            unsafe {
                core::ptr::swap_nonoverlapping(
                    self.entry_ptr(k, i), self.entry_ptr(k, j), 1
                );
            }
        }
    }

    /// Add a scaled row to another row. N = c * M.
    pub fn row_multiply_add(&mut self, n: usize, m: usize, c: T) {
        for i in 0..self.cols {
            let s = self[(n, i)] * c;
            self[(m, i)] += s;
        }
    }

    /// Add a scaled column to another column. N = c * M.
    pub fn col_multiply_add(&mut self, n: usize, m: usize, c: T) {
        for i in 0..self.rows {
            let s = self[(i, n)] * c;
            self[(i, m)] += s;
        }
    }
}

impl<T: UnsignedInt> Matrix<T> {
    /// Convert the matrix into a latex renderable string.
    pub fn to_tex(&self) -> String {
        let mut s = "\\left[\\begin{array}{}".to_owned();
        for r in 0..self.rows {
            for e in self.row(r).iter().cloned() {
                if (e.print_negative()) {
                    write!(&mut s, "-{} & ", T::zero() - e);
                } else {
                    write!(&mut s, "{} & ", e);
                }
            }

            // Remove the last " & ".
            s.truncate(s.len() - 3);
            s += "\\\\";
        }

        s += "\\end{array}\\right]";
        s
    }
}

impl<T> Index<(usize, usize)> for Matrix<T> {
    type Output = T;

    fn index(&self, (r, c): (usize, usize)) -> &Self::Output {
        self.entry(r, c)
    }
}

impl<T> IndexMut<(usize, usize)> for Matrix<T> {
    fn index_mut(&mut self, (r, c): (usize, usize)) -> &mut Self::Output {
        self.entry_mut(r, c)
    }
}

impl<T: NumAssign + Copy> Mul for &Matrix<T> {
    type Output = Matrix<T>;
    fn mul(self, rhs: Self) -> Self::Output {
        debug_assert!(self.cols == rhs.rows,
            "Can't multiply matrices because of incompatible dimensions");
        
        let mut m = Self::Output::zero(self.rows, rhs.cols);

        for i in 0..m.rows {
            for j in 0..m.cols {
                m[(i, j)] = self.row(i).iter()
                    .zip(rhs.col(j))
                    .map(|(l, r)| *l * *r)
                    .fold(T::zero(), T::add);
            }
        }

        m
    }
}

impl<T: NumAssign + Copy> Mul<&Vector<T>> for &Matrix<T> {
    type Output = Vector<T>;
    fn mul(self, rhs: &Vector<T>) -> Self::Output {
        debug_assert!(self.cols == rhs.dim,
            "Can't multiply matrix/vector because of incompatible dimensions");

        let mut m = Vector::<T>::zero(self.rows);
        for i in 0..m.dim {
            m[i] = self.row(i).iter()
                .zip(rhs.iter())
                .map(|(l, r)| *l * *r)
                .fold(T::zero(), T::add);
        }

        m
    }
}

impl<T: PartialEq> PartialEq for Matrix<T> {
    fn eq(&self, other: &Self) -> bool {
        self.rows == other.rows && self.cols == other.cols &&
        self.entries.iter()
            .zip(other.entries.iter())
            .all(|(e, f)| *e == *f)
    }
}

pub struct Column<'a, T> {
    ptr: *const T,
    end: *const T,
    off: usize,
    marker: PhantomData<&'a T>,
}

impl<'a, T> Column<'a, T> {
    pub fn from_matrix(mat: &'a Matrix<T>, c: usize) -> Self {
        debug_assert!(c < mat.cols);
        unsafe {
            Self {
                ptr: mat.entries.as_ptr().add(c),
                end: mat.entries.as_ptr().add(mat.entries.len()),
                off: mat.cols,
                marker: PhantomData,
            }
        }
    }
}

impl<'a, T> Iterator for Column<'a, T> {
    type Item = &'a T;
    fn next(&mut self) -> Option<Self::Item> {
        if self.ptr < self.end {
            unsafe {
                let e = &*self.ptr;
                self.ptr = self.ptr.add(self.off);
                Some(e)
            }
        } else {
            None
        }
    }
}

pub struct ColumnMut<'a, T> {
    ptr: *mut T,
    end: *mut T,
    off: usize,
    marker: PhantomData<&'a mut T>,
}

impl<'a, T> ColumnMut<'a, T> {
    pub fn from_matrix(mat: &'a mut Matrix<T>, c: usize) -> Self {
        debug_assert!(c < mat.cols);
        unsafe {
            Self {
                ptr: mat.entries.as_mut_ptr().add(c),
                end: mat.entries.as_mut_ptr().add(mat.entries.len()),
                off: mat.cols,
                marker: PhantomData,
            }
        }
    }
}

impl<'a, T> Iterator for ColumnMut<'a, T> {
    type Item = &'a mut T;
    fn next(&mut self) -> Option<Self::Item> {
        if self.ptr < self.end {
            unsafe {
                let e = &mut *self.ptr;
                self.ptr = self.ptr.add(self.off);
                Some(e)
            }
        } else {
            None
        }
    }
}
```

`src/numbers.rs`:

```rs
//! [Rings](https://en.wikipedia.org/wiki/Ring_(mathematics)) with additional structure.

use std::ops::{
    IndexMut, Index, BitAnd, BitOr, BitXor, Not,
    Shl, ShlAssign, Add, Sub, Mul, Div, Rem,
    AddAssign, DivAssign, RemAssign, MulAssign, SubAssign
};
use std::fmt::{self, Formatter, Display};
use num_traits::{Num, NumAssign, Unsigned, Signed, Zero, One};

/// The integers mod n.
/// Representatives in the range 0..n are stored.
pub trait UnsignedInt: NumAssign + Copy + Ord + Unsigned + Display {
    /// Should the number be printed as a negative number.
    fn print_negative(self) -> bool {
        false
    }

    /// Fast conversion from u8.
    fn from_u8(v: u8) -> Self;
}

/// Parses an integer in base ten from the iterator.
pub(crate) fn int_from_it<T: UnsignedInt>(
    it: &mut std::iter::Peekable<std::str::Chars>
) -> Option<T> {
    let neg = *it.peek()? == '-';
    if neg {
        it.next();
    }

    // Is the character an ascii digit?
    if !it.peek().map_or(false, |c| c.is_ascii_digit()) {
        return None;
    }

    let ten = T::from_u8(10);

    // Parse the number.
    let mut n = T::zero();
    loop {
        // Is this still a digit?
        let Some(d) = it.peek().and_then(|c| c.to_digit(10)) else {
            break
        };

        n *= ten;
        n += T::from_u8(d as u8);
        it.next();
    }

    if neg {
        n = T::zero() - n;        
    }

    Some(n)
}

/// N-bit integers basically.
pub trait UniformNum: UnsignedInt
    + BitAnd<Self, Output = Self>
    + BitOr<Self, Output = Self>
    + BitXor<Self, Output = Self>
    + Shl<usize>
    + ShlAssign<usize>
    + Not<Output = Self> {}

impl UniformNum for std::num::Wrapping<u8> {}
impl UniformNum for std::num::Wrapping<u16> {}
impl UniformNum for std::num::Wrapping<u32> {}
impl UniformNum for std::num::Wrapping<u64> {}
impl UniformNum for std::num::Wrapping<u128> {}

macro_rules! impl_uint {
    ($impl_ty:ty) => {
        impl UnsignedInt for std::num::Wrapping<$impl_ty> {
            fn print_negative(self) -> bool {
                self.0 > (1 << (<$impl_ty>::BITS - 1))
            }

            fn from_u8(v: u8) -> Self {
                std::num::Wrapping(v as $impl_ty)
            }
        }
    }
}

impl_uint!(u8);
impl_uint!(u16);
impl_uint!(u32);
impl_uint!(u64);
impl_uint!(u128);
impl_uint!(usize);
```

`src/pages/linear_congruences.rs`:

```rs
use wasm_bindgen::prelude::*;
use std::fmt::Display;
use std::num::Wrapping;
use crate::vector::Vector;
use crate::matrix::Matrix;
use super::{Width, bold, underbrace};
use crate::congruence_solver::{
    AffineLattice, diagonalize, solve_scalar_congruence
};
use crate::numbers::UnsignedInt;

/// Stores the intermediate results during the computation of the solution.
#[wasm_bindgen]
pub struct SolveTrace {
    /// The diagonalization of the matrix.
    diag: String,

    /// The resulting diagonal system.
    scalar_system: String,

    /// Linear congruences and solutions.
    linear_solutions: String,

    /// Vector form of the solution.
    vector_solution: String,

    /// The final solution.
    final_solution: String,
}

#[wasm_bindgen]
impl SolveTrace {
    #[wasm_bindgen(getter)]
    pub fn diag(&self) -> String {
        self.diag.clone()
    }

    #[wasm_bindgen(getter)]
    pub fn scalar_system(&self) -> String {
        self.scalar_system.clone()
    }

    #[wasm_bindgen(getter)]
    pub fn linear_solutions(&self) -> String {
        self.linear_solutions.clone()
    }

    #[wasm_bindgen(getter)]
    pub fn vector_solution(&self) -> String {
        self.vector_solution.clone()
    }

    #[wasm_bindgen(getter)]
    pub fn final_solution(&self) -> String {
        self.final_solution.clone()
    }
}

fn solve_congruences_impl<T: UnsignedInt + Display>(
    a: Matrix<&str>, b: Vector<&str>
) -> Result<SolveTrace, String> {
    let a = a.try_map(|&e| T::from_str_radix(e, 10))
        .map_err(|(r, c, _)| format!("Failed to parse entry ({}, {}).", r+1, c+1))?;

    let b = b.try_map(|&e| T::from_str_radix(e, 10))
        .map_err(|(r, _)| format!("Failed to parse entry ({}, {}).", r+1, a.cols+1))?;
    
    let mut d = a.clone();
    let (s, t) = diagonalize(&mut d);
    assert!(&(&s * &a) * &t == d);

    let diag = format!("{}={}{}{}",
        underbrace(d.to_tex(), bold("D")),
        underbrace(s.to_tex(), bold("S")),
        underbrace(a.to_tex(), bold("A")),
        underbrace(t.to_tex(), bold("T"))
    );

    // Transform the vector b.
    // We could already do this in diagonalize if we really wanted.
    let b_new = (&s * &b);

    let scalar_system = format!("{}\\mathbf{{x'}}={}{}={}",
        underbrace(d.to_tex(), bold("D")),
        underbrace(s.to_tex(), bold("S")),
        underbrace(b.to_tex(), bold("b")),
        b_new.to_tex()
    );

    let b = b_new;

    let min_dim = d.min_dim();

    if let Some(i) = b.iter()
        .skip(min_dim)
        .position(|e| *e != T::zero()) {
        let i = min_dim + i;
        let linear_solutions = format!(
            "\\text{{Row {}: }} 0={}\\implies \\text{{No solution}}",
            i + 1, b[i]
        );
        return Ok(SolveTrace {
            diag,
            scalar_system,
            linear_solutions,
            vector_solution: String::new(),
            final_solution: String::new()
        });
    }

    // Some solution to the system.
    let mut offset = Vector::zero(d.cols);

    // The basis of the kernel.
    let mut basis = Vec::new();

    let mut linear_solutions = "\\begin{align}".to_owned();
    
    // Variable index for basis.
    let mut j = 1;

    // Solve the scalar linear congruences.
    for i in 0..d.min_dim() {
        linear_solutions += &format!(
            "{}x'_{{{}}}&={} &\\implies ", d[(i, i)], i + 1, b[i]);
        let (x, kern) = match solve_scalar_congruence(d[(i, i)], b[i]) {
            // If there is no solution,
            // then the whole system does not have a solution.
            None => {
                linear_solutions += "\\text{No solution!}&\\end{align}";
                return Ok(SolveTrace {
                    diag,
                    scalar_system,
                    linear_solutions,
                    vector_solution: String::new(),
                    final_solution: String::new(),
                });
            },
            Some(s) => s,
        };

        if kern == T::zero() {
            linear_solutions += &format!("x'_{{{}}}&={}\\\\", i + 1, x);
        } else {
            linear_solutions += &format!(
                "x'_{{{}}}&={}+{}a_{{{}}}\\\\", i + 1, x, kern, j
            );
            j += 1;
        }

        // The particular solution is an entry is
        // the particular solution of the whole system.
        offset[i] = x;

        // If the kernel is zero, then the vector is zero for sure.
        if kern != T::zero() {
            let mut v = Vector::zero(d.cols);
            v[i] = kern;
            basis.push(v);
        }
    }

    // If there are more variables then equations
    // then there are no restrictions on the variables
    // from index d.rows
    for i in d.rows..d.cols {
        let mut v = Vector::zero(d.cols);
        v[i] = T::one();
        basis.push(v);

        linear_solutions += &format!(
            "&&x'_{{{}}}&=a_{{{}}}\\\\", i + 1, j
        );
        j += 1;
    }

    linear_solutions += "\\end{align}";

    let mut solution = AffineLattice {
        offset,
        basis,
    };

    let x_old = solution.to_tex_brace();
    let vector_solution = format!("\\mathbf{{x'}}={}", x_old);

    solution.offset = (&t * &solution.offset);
    for v in &mut solution.basis {
        *v = (&t * &*v);
    }

    let final_solution = format!("\\mathbf{{x}}={}{}={}",
        underbrace(t.to_tex(), bold("T")),
        underbrace(x_old, bold("x'")),
        solution.to_tex()
    );

    Ok(SolveTrace {
        diag,
        scalar_system,
        linear_solutions,
        vector_solution,
        final_solution,
    })
}

#[wasm_bindgen]
pub fn solve_congruences(matrix_str: String, bit: Width) -> Result<SolveTrace, String> {
    // The number of rows is the number of lines.
    let rows = matrix_str.lines().count();
    if rows == 0 {
        return Err("Empty matrix.".into());
    }

    // Get the number of columns from the first line.
    let cols = matrix_str.lines()
        .next()
        .unwrap()
        .split_ascii_whitespace()
        .count() - 1;
    if cols == 0 {
        return Err("Empty matrix.".into());
    }

    let mut a = Matrix::<&str>::uniform(rows, cols, "");
    let mut b = Vector::<&str>::uniform(rows, "");

    for (i, l) in matrix_str.lines().enumerate() {
        // Is the number of elements in this row the same as in the first.
        let mut ok = false;
        for (j, e) in l.split_ascii_whitespace().enumerate() {
            if (j < cols) {
                a[(i, j)] = e;
            } else if (j == cols) {
                b[i] = e;
                ok = true;
            } else {
                ok = false;
                break;
            }
        }

        if !ok {
            return Err(std::format!("Row {} has a different number of \
                entries than the first row.", i + 1));
        }
    }

    match bit {
        Width::U8 => solve_congruences_impl::<Wrapping<u8>>(a, b),
        Width::U16 => solve_congruences_impl::<Wrapping<u16>>(a, b),
        Width::U32 => solve_congruences_impl::<Wrapping<u32>>(a, b),
        Width::U64 => solve_congruences_impl::<Wrapping<u64>>(a, b),
        Width::U128 => solve_congruences_impl::<Wrapping<u128>>(a, b),
    }
}
```

`src/pages/mod.rs`:

```rs
//! API for webpages.

mod obfuscate;
mod linear_congruences;
mod perm_poly;

use wasm_bindgen::prelude::*;

#[wasm_bindgen]
#[derive(Clone, Copy, Debug)]
pub enum Width {
    U8,
    U16,
    U32,
    U64,
    U128,
}

pub fn underbrace<T: AsRef<str>, U: AsRef<str>>(inner: T, label: U) -> String {
    format!("\\underbrace{{{}}}_{{{}}}", inner.as_ref(), label.as_ref())
}

pub fn bold<T: AsRef<str>>(inner: T) -> String {
    format!("\\mathbf{{{}}}", inner.as_ref())
}
```

`src/pages/obfuscate.rs`:

```rs
use std::collections::BTreeSet;
use std::fmt::{self, Display, Formatter, Write};
use std::num::Wrapping;
use std::rc::Rc;
use rand::distributions::{Standard, Distribution};
use wasm_bindgen::prelude::*;
use super::Width;
use crate::congruence_solver::solve_congruences;
use crate::matrix::Matrix;
use crate::vector::Vector;
use crate::printer::Printer;
use crate::expr::Expr;
use crate::uniform_expr::{LUExpr, UExpr, Valuation};
use crate::numbers::{UnsignedInt, UniformNum};

#[wasm_bindgen]
pub fn obfuscate(
    expr: String, width: Width, out: Printer
) -> Result<String, String> {
    match width {
        Width::U8   => obfuscate_impl::<Wrapping<u8>>(expr, out),
        Width::U16  => obfuscate_impl::<Wrapping<u16>>(expr, out),
        Width::U32  => obfuscate_impl::<Wrapping<u32>>(expr, out),
        Width::U64  => obfuscate_impl::<Wrapping<u64>>(expr, out),
        Width::U128 => obfuscate_impl::<Wrapping<u128>>(expr, out),
    }
}

fn obfuscate_impl<T: UniformNum + std::fmt::Debug>(
    expr: String, out: Printer
) -> Result<String, String> 
    where Standard: Distribution<T>
{
    let mut e = Rc::new(Expr::<T>::from_string(expr)?);

    let mut vars = e.vars();
    for i in 0..(REWRITE_VARS - vars.len() as isize) {
        vars.push(format!("aux{}", i));
    }

    let mut v = Vec::new();
    obfuscate_expr(&mut e, &mut v, &vars);
    Ok(e.print_as_fn(out))
}

/// Tries to convert the expression to a uniform expression.
/// When part of the expression isn't a uniform expression,
/// it generates a variable and remembers what expression to
/// substitute for that variable.
fn expr_to_uexpr<T: UniformNum>(
    e: &Rc<Expr<T>>, subs: &mut Vec<(String, Rc<Expr<T>>)>
) -> UExpr {
    if Rc::strong_count(e) > 1 {
        let var = format!("_sub_{}", subs.len());
        subs.push((var.clone(), e.clone()));
        return UExpr::Var(var);
    }

    match e.as_ref() {
        Expr::Var(v) => UExpr::Var(v.clone()),
        Expr::And(l, r) => UExpr::and(expr_to_uexpr(l, subs), expr_to_uexpr(r, subs)),
        Expr::Or(l, r) => UExpr::or(expr_to_uexpr(l, subs), expr_to_uexpr(r, subs)),
        Expr::Xor(l, r) => UExpr::xor(expr_to_uexpr(l, subs), expr_to_uexpr(r, subs)),
        Expr::Not(i) => UExpr::not(expr_to_uexpr(i, subs)),
        // Otherwise generate a new variable and add the substitution.
        _ => {
            let var = format!("_sub_{}", subs.len());
            subs.push((var.clone(), e.clone()));
            UExpr::Var(var)
        }
    }
}

/// Tries to convert an expression
fn parse_term<T: UniformNum>(
    e: &Rc<Expr<T>>, subs: &mut Vec<(String, Rc<Expr<T>>)>
) -> (T, UExpr) {
    if let Expr::Mul(l, r) = e.as_ref() {
        if let Expr::Const(i) = l.as_ref() {
            return (*i, expr_to_uexpr(r, subs));
        } else if let Expr::Const(i) = r.as_ref() {
            return (*i, expr_to_uexpr(l, subs));
        }
    } else if let Expr::Const(c) = e.as_ref() {
        return (T::zero() - *c, UExpr::Ones);
    }

    (T::one(), expr_to_uexpr(e, subs))
}

fn expr_to_luexpr<T: UniformNum>(
    e: &Rc<Expr<T>>,
    lu: &mut LUExpr<T>,
    subs: &mut Vec<(String, Rc<Expr<T>>)>,
    sign: bool
) {
    // If this is an add the left and right hand side
    // can contribute to the linear combination.
    match e.as_ref() {
        Expr::Add(l, r) => {
            expr_to_luexpr(l, lu, subs, sign);
            expr_to_luexpr(r, lu, subs, sign);
        },

        Expr::Sub(l, r) => {
            expr_to_luexpr(l, lu, subs, sign);
            expr_to_luexpr(r, lu, subs, !sign);
        },

        Expr::Neg(i) => {
            // Theoretically we could allow another whole
            // LUExpr in here but hopefully not too important.

            // Flipped because of the Neg.
            let f = if sign { T::one() } else { T::zero() - T::one() };
            lu.0.push((f, expr_to_uexpr(i, subs)));
        },

        // Otherwise parse the term from this expression.
        _ => {
            let (mut f, u) = parse_term(e, subs);
            if sign {
                f = T::zero() - f;
            }
            lu.0.push((f, u));
        },
    }
}

fn obfuscate_expr<T: UniformNum>(er: &mut Rc<Expr<T>>, visited: &mut Vec<*const Expr<T>>, vars: &[String])
    where Standard: Distribution<T>
{
    let ptr = Rc::as_ptr(er);
    if Rc::strong_count(er) > 1 {
        if visited.contains(&ptr) {
            return;
        }
        visited.push(ptr);
    }

    let e = unsafe { &mut *(ptr as *mut _) };

    match e {
        Expr::Mul(l, r) => {
            obfuscate_expr(l, visited, vars);
            obfuscate_expr(r, visited, vars);
        },
        Expr::Div(l, r) | Expr::Mod(l, r) => {
            obfuscate_expr(l, visited, vars);
            obfuscate_expr(r, visited, vars);
        },
        Expr::Shl(l, r) | Expr::Shr(l, r) => {
            obfuscate_expr(l, visited, vars);
            obfuscate_expr(r, visited, vars);
        },
        _ => {
            // Try to find the largest subexpression that is linear MBA
            // and obfuscate it on its own.
            let mut lu = LUExpr(Vec::new());

            // Substitutions in the LUExpr.
            let mut subs: Vec<(String, Rc<Expr<T>>)> = Vec::new();

            expr_to_luexpr(er, &mut lu, &mut subs, false);
            *e = rewrite_random(&lu, vars).to_expr();
            for (var, sub) in &mut subs {
                // Obfuscate the substituted expressions.
                obfuscate_expr(sub, visited, vars);

                // Substitute them for the variables.
                e.substitute(sub, var);
            }
        }
    }
}

const REWRITE_VARS: isize = 4;
const REWRITE_EXPR_DEPTH: u8 = 3;
const REWRITE_EXPR_COUNT: usize = 24;
const REWRITE_TRIES: usize = 128;

fn rewrite_random<T: UniformNum>(e: &LUExpr<T>, vars: &[String]) -> LUExpr<T>
    where Standard: Distribution<T>
{
    let mut vars: Vec<_> = vars.iter().cloned().collect();
    for v in e.vars() {
        if !vars.contains(&v) {
            vars.push(v);
        }
    }
    for _ in 0..REWRITE_TRIES {
        let mut ops = Vec::new();
        for _ in 0..REWRITE_EXPR_COUNT {
            ops.push(LUExpr::from_uexpr(
                random_bool_expr(&vars, REWRITE_EXPR_DEPTH)
            ));
        }

        if let Some(r) = rewrite(e, &ops, true) {
            return r;
        }
    }

    panic!("Failed to rewrite uniform expression.");
}

/// Note that this never generates `Ones` or any expression containing it,
/// as those can be easily simplified to one that does not contain it.
fn random_bool_expr<T: AsRef<str>>(vars: &[T], max_depth: u8) -> UExpr {
    assert!(!vars.is_empty(), "There needs to be at least one variable for the random expression.");

    let rand_var = || UExpr::Var(vars[rand::random::<usize>() % vars.len()].as_ref().to_owned());

    if max_depth == 0 {
        return rand_var();
    }

    // Generate one of the four variants uniformly at random.
    let d = max_depth - 1;
    match rand::random::<usize>() % 5 {
        0 => rand_var(),
        1 => UExpr::Not(random_bool_expr(vars, d).into()),
        2 => UExpr::And(random_bool_expr(vars, d).into(), random_bool_expr(vars, d).into()),
        3 => UExpr::Or(random_bool_expr(vars, d).into(), random_bool_expr(vars, d).into()),
        4 => UExpr::Xor(random_bool_expr(vars, d).into(), random_bool_expr(vars, d).into()),
        _ => unreachable!(),
    }
}

#[wasm_bindgen]
pub fn obfuscate_linear(req: ObfLinReq) -> Result<String, String> {
    match req.bits {
        Width::U8   => obfuscate_linear_impl::<Wrapping<u8>>(req),
        Width::U16  => obfuscate_linear_impl::<Wrapping<u16>>(req),
        Width::U32  => obfuscate_linear_impl::<Wrapping<u32>>(req),
        Width::U64  => obfuscate_linear_impl::<Wrapping<u64>>(req),
        Width::U128 => obfuscate_linear_impl::<Wrapping<u128>>(req),
    }
}

#[wasm_bindgen]
pub fn normalize_op(expr: String, bits: Width) -> String {
    match bits {
        Width::U8 => LUExpr::<Wrapping<u8>>::from_string(expr)
            .map_or(String::new(), |s| s.to_string()),
        Width::U16 => LUExpr::<Wrapping<u16>>::from_string(expr)
            .map_or(String::new(), |s| s.to_string()),
        Width::U32 => LUExpr::<Wrapping<u32>>::from_string(expr)
            .map_or(String::new(), |s| s.to_string()),
        Width::U64 => LUExpr::<Wrapping<u64>>::from_string(expr)
            .map_or(String::new(), |s| s.to_string()),
        Width::U128 => LUExpr::<Wrapping<u128>>::from_string(expr)
            .map_or(String::new(), |s| s.to_string()),
    }
}

fn obfuscate_linear_impl<T: UniformNum + std::fmt::Display>(
    req: ObfLinReq
) -> Result<String, String>
    where 
        T: UniformNum + std::fmt::Display,
        Standard: Distribution<T>
{
    let expr = LUExpr::<T>::from_string(req.expr).ok_or(
        "Input is not a linear combination of uniform expressions".to_owned()
    )?;

    let ops: Vec<_> = req.ops.into_iter()
        .map(|s| LUExpr::<T>::from_string(s).unwrap())
        .collect();

    rewrite(&expr, &ops, req.randomize)
        .map(|e| req.printer.print_luexpr(&e))
        .ok_or("Operations can't be used to rewrite the input".to_owned())
}

fn rewrite<T: UniformNum + std::fmt::Display>(
    expr: &LUExpr<T>, ops: &[LUExpr<T>], randomize: bool
) -> Option<LUExpr<T>>
    where 
        T: UniformNum + std::fmt::Display,
        Standard: Distribution<T>
{
    // Find all variables.
    let mut v = BTreeSet::new();
    expr.vars_impl(&mut v);
    for op in ops {
        op.vars_impl(&mut v);
    }

    let v: Vec<_> = v.into_iter().collect();

    let mut val = Valuation::zero(v.clone());

    let rows = 1usize << v.len();
    let cols = ops.len();

    let mut a = Matrix::zero(rows, cols);
    let mut b = Vector::zero(rows);

    // Initialize the matrix.
    for i in 0..rows {
        let row = a.row_mut(i);

        // Initialize the valuation.
        for (j, c) in v.iter().enumerate() {
            if (i >> j) & 1 == 0 {
                val[c] = T::zero();
            } else {
                val[c] = T::zero() - T::one();
            }
        }

        // Write the values of the operations into this row of the matrix.
        for (j, e) in ops.iter().enumerate() {
            row[j] = e.eval(&val);
        }

        // Write the desired result into the vector.
        b[i] = expr.eval(&val);
    }

    // Solve the system.
    let l = solve_congruences(a, &b);

    // Does it have solutions?
    if l.is_empty() {
        return None;
    }

    // Sample a point from the lattice.
    let mut solution = l.offset;
    if randomize {
        for b in l.basis {
            solution += &(b * rand::random());
        }
    }

    // Put it in an LUExpr.
    // Currently, this simplifies the inner LUExprs into
    // sums of UExprs, such that the result is an LUExpr.
    // Once there is a more general Expr class, we need not do this.
    let mut v = Vec::new();
    for (c, o) in solution.iter().zip(ops.iter()) {
        for (d, e) in &o.0 {
            // Is the UExpr already in the linear combination?
            match v.iter_mut().find(|(_, f)| f == e) {
                Some((f, _)) => *f += *c * *d,
                None => v.push((*c * *d, e.clone())),
            }
        }
    }

    // Remove terms where the coefficient is zero.
    v.retain(|(f, u)| !f.is_zero());

    Some(LUExpr(v))
}

/// Obfuscation settings.
#[wasm_bindgen]
#[derive(Debug)]
pub struct ObfLinReq {
    /// The expression to obfuscate.
    #[wasm_bindgen(skip)]
    pub expr: String,

    /// The operations used for rewriting.
    /// There is currently an issue with this because we verify the ops
    /// with a certain bitness but the obfuscation may happen with another one.
    /// This is only really a problem with big constants though, so not that
    /// likely to happen to anyone.
    #[wasm_bindgen(skip)]
    pub ops: Vec<String>,

    /// The integer width.
    pub bits: Width,

    /// Should the solution be randomized.
    pub randomize: bool,

    /// How to print the result.
    pub printer: Printer,
}

#[wasm_bindgen]
impl ObfLinReq {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Self {
        Self {
            expr: String::new(),
            ops: Vec::new(),
            bits: Width::U8,
            randomize: true,
            printer: Printer::C,
        }
    }

    #[wasm_bindgen(setter)]
    pub fn set_expr(&mut self, expr: String) {
        self.expr = expr;
    }

    #[wasm_bindgen]
    pub fn add_op(&mut self, op: String) {
        self.ops.push(op);
    }

    //#[wasm_bindgen(setter)]
    //pub fn set_bits(&mut self, bits: Bitness) {
    //    self.bits = bits;
    //}

    //#[wasm_bindgen(setter)]
    //pub fn set_randomize(&mut self, randomize: bool) {
    //    self.randomize = randomize;
    //}

    //#[wasm_bindgen(setter)]
    //pub fn set_printer(&mut self, printer: Printer) {
    //    self.printer = printer;
    //}
}
```

`src/pages/perm_poly.rs`:

```rs
use std::num::Wrapping;
use std::ops::ShlAssign;

use num_traits::{Num, NumAssign};
use rand::Rng;
use rand::distributions::{Standard, Distribution, Uniform};
use wasm_bindgen::prelude::*;

use crate::congruence_solver;
use crate::vector::Vector;
use crate::matrix::Matrix;
use crate::polynomial::Polynomial;
use crate::numbers::UniformNum;

use super::Width;

#[wasm_bindgen]
pub fn invert_poly(
    poly: String, bits: Width, alg: String
) -> Result<String, String> {
    match bits {
        Width::U8 => invert_poly_impl::<Wrapping<u8>>(poly, alg),
        Width::U16 => invert_poly_impl::<Wrapping<u16>>(poly, alg),
        Width::U32 => invert_poly_impl::<Wrapping<u32>>(poly, alg),
        Width::U64 => invert_poly_impl::<Wrapping<u64>>(poly, alg),
        Width::U128 => invert_poly_impl::<Wrapping<u128>>(poly, alg),
    }
}

#[wasm_bindgen]
pub fn rand_poly(bits: Width) -> String {
    match bits {
        Width::U8     => rand_poly_impl::<Wrapping<u8>>(),
        Width::U16    => rand_poly_impl::<Wrapping<u16>>(),
        Width::U32    => rand_poly_impl::<Wrapping<u32>>(),
        Width::U64    => rand_poly_impl::<Wrapping<u64>>(),
        Width::U128   => rand_poly_impl::<Wrapping<u128>>(),
    }
}

fn invert_poly_impl<T: UniformNum>(
    poly: String, alg: String
) -> Result<String, String> {
    // Parse the polynomial and make sure it's a permutation.
    let p = parse_poly::<T>(poly)?;
    if !is_perm_poly(&p) {
        return Err("The input is not a permutation polynomial".into());
    }

    // Find the generators of the "zero ideal".
    let zi = ZeroIdeal::<T>::init();

    // Simplify the polynomial.
    let p = p.simplified(&zi);

    // Select the algorithm.
    let alg = match alg.as_str() {
        "Newton" => invert_newton,
        "Fermat" => invert_fermat,
        "Lagrange" => invert_lagrange,
        _ => return Err("Invalid algorithm.".into()),
    };

    // Set up timing.
    let perf = web_sys::window().unwrap().performance().unwrap();
    let now = perf.now();

    // Compute the inverse.
    let q = alg(&p, &zi);

    // Log the execution time.
    let dur = perf.now() - now;
    crate::log(&format!("Inverting took {} ms", dur as u64));

    // Check that we did indeed find the inverse.
    if !compose(&p, &q, &zi).simplified(&zi).is_id() {
        crate::log("Inverse is wrong!");
    }

    // Return the inverse's tex.
    Ok(q.to_tex())
}

/// Invert using p as a generator.
fn invert_fermat<T: UniformNum>(
    p: &Polynomial<T>, zi: &ZeroIdeal<T>
) -> Polynomial<T> {
    // p^(2^i-1)
    let mut f = p.clone();
    for i in 0..zi.n {
        // p^(2^i)
        let g = compose(&f, p, zi).simplified(zi);
        if g.is_id() {
            // This will incorrectly say ord(X)=2, but whatever.
            crate::log(&format!("log(ord(p)) = {}", i + 1));
            return f;
        }

        f = compose(&f, &g, zi).simplified(zi);
    }

    assert!(false, "Failed to invert {}", p);
    Polynomial::zero()
}

/// Invert using Newton's method.
fn invert_newton<T: UniformNum>(
    p: &Polynomial<T>, zi: &ZeroIdeal<T>
) -> Polynomial<T> {
    // Initialize g with the initial guess Q(X)=X.
    let mut q = Polynomial::from_coeffs(&[T::zero(), T::one()]);

    let mut it = 0;

    // Do the Newton iterations.
    loop {
        assert!(it <= zi.n * 2, "Failed to compute the inverse\
                in a reasonable number of iterations.");

        // Compute the composition.
        let mut comp = compose(p, &q, zi).simplified(zi);

        // Do we already have p(q(x)) = x?
        if comp.is_id() {
            crate::log(&format!("Inverted in {} iterations", it));
            return q;
        }

        // Subtract X.
        // This is the quantity we want to make 0.
        comp.coeffs[1] -= T::one();

        // Update the guess.
        let qd = q.derivative();
        q -= &(&qd * &comp);
        q.simplify(zi);

        it += 1;
    }
}

/// Invert using interpolation.
fn invert_lagrange<T: UniformNum>(
    p: &Polynomial<T>, zi: &ZeroIdeal<T>
) -> Polynomial<T> {
    // Construct a system of linear congruences.
    let rows = zi.gen.last().unwrap().len();
    let cols = zi.gen.last().unwrap().len();

    // Construct the Vandermonde matrix.
    let mut a = Matrix::<T>::zero(rows, cols);
    let mut i = T::zero();
    for r in 0..rows {
        let mut j = T::one();
        let x = p.eval(i);
        for c in 0..cols {
            a[(r, c)] = j;
            j *= x;
        }

        i += T::one();
    }

    // Construct the vector of values of the polynomial.
    let mut b = Vector::<T>::zero(rows);
    let mut i = T::zero();
    for r in 0..rows {
        b[r] = i;
        i += T::one();
    }

    let l = congruence_solver::solve_congruences(a, &b);
    //crate::log(&format!("The kernel has dimension {}.", l.basis.len()));
    for b in &l.basis {
        let k = Polynomial::from_coeffs(b.entries());
        //assert!(k.simplified(zi).is_zero(),
        //    "Polynomial in the kernel is non-null.");
        if !k.clone().simplified(zi).is_zero() {
            crate::log(&format!("Polynomial in kernel is not null: {}", k));
        }
    }

    Polynomial::from_coeffs(l.offset.entries()).simplified(zi)
}

/// Computes the composition of two polynomials.
fn compose<T: UniformNum>(
    p: &Polynomial<T>,
    q: &Polynomial<T>,
    zi: &ZeroIdeal<T>
) -> Polynomial<T> {
    // We are using Horner's method to evaluate the polynomial `p` at `q(x)`.

    // Iterate over the coefficients in reverse order.
    let mut iter = p.coeffs.iter().rev();

    // The last coefficient is the initial value.
    let mut r = Polynomial::constant(iter.next().map_or(T::zero(), |c| *c));

    for c in iter {
        r *= q;
        r += *c;
        r.reduce(zi);
    }

    r
}

/// Used internally as a function to Iterator::fold.
fn parity<T: UniformNum>(acc: bool, i: &T) -> bool {
    match *i & T::one() != T::zero() {
        true => !acc,
        false => acc,
    }
}

/// Is this a permutation polynomial?
fn is_perm_poly<T: UniformNum>(f: &Polynomial<T>) -> bool {
    f.coeffs.get(1).map_or(false, |i| *i & T::one() != T::zero())
        && f.coeffs.iter().skip(2).step_by(2).fold(true, parity)
        && f.coeffs.iter().skip(3).step_by(2).fold(true, parity)
}

fn rand_poly_impl<T>() -> String
    where 
        T: UniformNum + std::fmt::Display,
        Standard: Distribution<T>,
{
    let mut rng = rand::thread_rng();
    let zi = ZeroIdeal::<T>::init();
    // This is the smallest degree possible that can represent any permutation
    // that has a polynomial representation.
    let degree = zi.gen.last().unwrap().len() - 1;

    // Create the polynomial. 
    let mut p = Polynomial {
        coeffs: vec![T::zero(); degree + 1]
    };

    // Initialize the coefficients with random values.
    for c in &mut p.coeffs {
        *c = rng.gen();
    }

    // a_1 has to be odd.
    if p.coeffs[1] & T::one() == T::zero() {
        p.coeffs[1] += T::one();
    }

    // a_2 + a_4 + ... has to be even.
    if p.coeffs.iter().skip(2).step_by(2).fold(false, parity) {
        let dist = Uniform::from(1..=degree/2);
        let i = dist.sample(&mut rng);
        p.coeffs[2*i] += T::one();
    }

    // a_3 + a_5 + ... has to be even.
    if p.coeffs.iter().skip(3).step_by(2).fold(false, parity) {
        let dist = Uniform::from(1..=(degree-1)/2);
        let i = dist.sample(&mut rng);
        p.coeffs[2*i+1] += T::one();
    }

    p.simplify(&zi);
    p.to_string()
}


/// Parse a polynomial.
/// Either as a space-separated list of coefficients a_d ... a_0,
/// or as a polynomial expression 4x^2 + 3x + 2.
fn parse_poly<T: NumAssign + Copy>(
    mut poly: String
) -> Result<Polynomial<T>, String> {
    if !poly.is_ascii() {
        return Err("Non-ascii input.".into());
    }

    poly.make_ascii_lowercase();

    // If the polynomial contains x then it is an actual expression.
    // Otherwise, it is a list of coefficients.
    let mut coeffs = Vec::with_capacity(8);
    if poly.contains('x') {
        poly.retain(|c| c != ' ');
        let p = poly.as_bytes();
        let mut i = 0;
        let mut last_i = usize::MAX;
        while i < p.len() {
            if i == last_i {
                return Err("Got stuck while parsing polynomial. This is a bug.".into());
            }
            last_i = i;

            // Parse the sign.
            let sign = match p[i] {
                b'+' => { i += 1; false },
                b'-' => { i += 1; true },
                _ => false,
            };

            // Parse the coefficient.
            let mut c = T::one();
            if p[i].is_ascii_digit() {
                let start = i;
                while i < p.len() && p[i].is_ascii_digit() {
                    i += 1;
                }

                c = <T as Num>::from_str_radix(&poly[start..i], 10)
                    .map_err(|_|
                        "Failed to parse coefficient.".to_owned()
                    )?;

                if i < p.len() && p[i] == b'*' {
                    i += 1;
                }
            }

            if sign {
                c = T::zero() - c;
            }

            // Parse the exponent.
            let mut e = 0;

            // Skip past the `x`.
            if i < p.len() && p[i] == b'x' {
                i += 1;
                e = 1;

                // If there is an exponent, parse it.
                if i < p.len() && p[i] == b'^' {
                    i += 1;
                    if !p[i].is_ascii_digit() {
                        return Err("Failed to parse exponent.".into());
                    }
                    e = 0;
                    while i < p.len() {
                        if !p[i].is_ascii_digit() {
                            break;
                        }

                        e *= 10;
                        e += (p[i] - b'0') as usize;
                        i += 1;
                    }
                }
            }

            if e >= coeffs.len() {
                coeffs.resize(e + 1, T::zero());
            }

            coeffs[e] = c;
        }
    } else {
        for c in poly.split_ascii_whitespace() {
            let c = <T as Num>::from_str_radix(c, 10)
                .map_err(|_| "Failed to parse coefficient.".to_owned())?;
            coeffs.push(c);
        }
        coeffs.reverse();
    }

    let p = Polynomial { coeffs };

    Ok(p.truncated())
}

/// The ideal of all polynomial expressions that evaluate to 0.
pub struct ZeroIdeal<T> {
    /// Mod 2^n.
    n: usize,

    /// The generators of the ideal.
    gen: Vec<Polynomial<T>>,
}

impl<T: UniformNum> ZeroIdeal<T> {
    pub fn init() -> Self {
        let n = std::mem::size_of::<T>() * 8;

        let mut gen = Vec::new();

        // div stores how often 2 divides i!.
        // It is successively updated.
        let mut div = 0usize;
        for i in (2usize..).step_by(2) {
            div += i.trailing_zeros() as usize;

            // If the exponent would be negative
            // then add the last generator and stop.
            if n <= div {
                let mut p = Polynomial::<T>::one();

                let mut j = T::zero();
                for _ in 0..i {
                    // Multiply the current polynomial by (x-j).
                    p.mul_lin(j);
                    j += T::one();
                }

                p.truncate();

                gen.push(p);
                break;
            }

            // Compute the exponent.
            let e = n - div;

            // Let's build the polynomial.
            let mut p = Polynomial::<T>::one();

            let mut j = T::zero();
            for _ in 0..i {
                // Multiply the current polynomial by (x-j).
                p.mul_lin(j);
                j += T::one();
            }

            p <<= e;
            p.truncate();

            gen.push(p);
        }

        Self { n, gen }
    }
}

impl<T: UniformNum> Polynomial<T> {
    /// Returns a simplified polynomial.
    pub fn simplified(mut self, zi: &ZeroIdeal<T>) -> Self {
        self.simplify(zi);
        self
    }

    /// Simplifies a polynomial by adding a polynomial in the zero ideal.
    pub fn simplify(&mut self, zi: &ZeroIdeal<T>) {
        let mut coeff = self.len() - 1;

        for gen in zi.gen.iter().rev() {
            let gen_len = gen.len() - 1;

            while coeff >= gen_len {
                let m = self.coeffs[coeff] / gen.coeffs[gen_len];
                if m != T::zero() {
                    let iter = (&mut self.coeffs[coeff-gen_len..=coeff])
                        .iter_mut().zip(gen.coeffs.iter());

                    for (p, g) in iter {
                        *p -= m * *g;
                    }
                }
                coeff -= 1;
            }
        }

        self.truncate();
    }

    /// Reduce the degree of the polynomial as much as possible
    /// using the generator of the highest degree.
    pub fn reduce(&mut self, zi: &ZeroIdeal<T>) {
        let gen = zi.gen.last().unwrap();
        let gen_len = gen.len() - 1;
        while self.len() >= gen.len() {
            let c = self.coeffs.pop().unwrap();
            for i in 0..gen_len {
                let j = self.len() - gen_len + i;
                self.coeffs[j] -= c * gen.coeffs[i];
            }
        }

        self.truncate();
    }
}
```

`src/polynomial.rs`:

```rs
use std::ops::{Add, AddAssign, Sub, Mul, MulAssign, SubAssign, ShlAssign};
use std::fmt::{self, Write, Display, Formatter};
use num_traits::{Num, NumAssign};

#[derive(Debug, Clone)]
pub struct Polynomial<T> {
    pub coeffs: Vec<T>,
}

impl<T> Polynomial<T> {
    pub fn zero() -> Self {
        Self { coeffs: Vec::new() }
    }

    pub fn constant(c: T) -> Self {
        Self { coeffs: vec![c] }
    }

    pub fn from_coeffs<U: Into<T> + Clone>(v: &[U]) -> Self {
        Self {
            coeffs: v.iter().map(|e| e.clone().into()).collect()
        }
    }

    /// The number of coefficients.
    pub fn len(&self) -> usize {
        self.coeffs.len()
    }

    //
    // Most functions below only work when the polynomial is truncated.
    //

    /// Returns the degree of the polynomial.
    /// The degree of 0 is defined to be -1.
    pub fn degree(&self) -> isize {
        self.coeffs.len() as isize - 1
    }

    /// Is this the zero polynomial?
    pub fn is_zero(&self) -> bool {
        self.len() == 0
    }
}

impl<T: NumAssign + Copy> Polynomial<T> {
    /// The constant 1 function.
    pub fn one() -> Self {
        Self::constant(T::one())
    }

    /// Is this the identity polynomial P(X)=X?
    pub fn is_id(&self) -> bool {
        self.coeffs == &[T::zero(), T::one()]
    }

    /// Removes leading zero coefficients.
    pub fn truncate(&mut self) {
        let num_zero = self.coeffs
            .iter()
            .rev()
            .take_while(|c| **c == T::zero())
            .count();

        self.coeffs.truncate(self.len() - num_zero);
    }

    /// Returns the truncated polynomial.
    pub fn truncated(mut self) -> Self {
        self.truncate();
        self
    }

    /// Evaluate the polynomial at x.
    pub fn eval(&self, x: T) -> T {
        // This is Horner's method.
        
        // Iterate over the coefficients in reverse order.
        let mut iter = self.coeffs.iter().rev().cloned();

        // The last coefficient is the initial value.
        let mut r = iter.next().unwrap_or(T::zero());

        for c in iter {
            r *= x;
            r += c;
        }

        r
    }

    /// Multiplies the polynomial by (X-a).
    pub fn mul_lin(&mut self, a: T) {
        // p(x) * (x-a) = p(x) * x - p(x) * a

        // Shift every coefficient to the left
        // which corresponds to a multiplication by x.
        self.coeffs.insert(0, T::zero());

        // Now subtract `a` times the original polynomial.
        for i in 0..self.coeffs.len() - 1 {
            let m = a * self.coeffs[i+1];
            self.coeffs[i] -= m;
        }
    }

    /// Computes the formal derivative of the polynomial.
    pub fn derivative(&self) -> Self {
        if self.len() == 0 {
            return Self::zero();
        }

        let mut coeffs = Vec::with_capacity(self.len() - 1);
        let mut d = T::one();
        for c in self.coeffs[1..].iter() {
            coeffs.push(*c * d);
            d += T::one();
        }

        Self { coeffs }
    }
}

impl<T: Num + Copy + Display> Polynomial<T> {
    pub fn to_tex(&self) -> String {
        let mut s = String::new();

        // Iterator over the non-zero coefficients.
        let mut iter = self.coeffs
            .iter()
            .enumerate()
            .rev()
            .filter(|(e, c)| **c != T::zero());

        let write_term = |s: &mut String, e, c| {
            if e == 0 {
                write!(s, "{}", c);
            } else {
                if c != T::one() {
                    write!(s, "{}", c);
                }

                write!(s, "X");

                if e != 1 {
                    write!(s, "^{{{}}}", e);
                }
            }
        };

        match iter.next() {
            None => { write!(s, "0"); },
            Some((e, c)) => write_term(&mut s, e, *c),
        };

        for (e, c) in iter {
            s.push_str("+");
            write_term(&mut s, e, *c);
        }

        s
    }
}

impl<T: Num + Display> Display for Polynomial<T> {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        // Iterator over the non-zero coefficients.
        let mut iter = self.coeffs
            .iter()
            .enumerate()
            .rev()
            .filter(|(e, c)| **c != T::zero());

        match iter.next() {
            None => write!(f, "0")?,
            Some((e, c)) => if e == 0 {
                write!(f, "{}", c)?
            } else {
                write!(f, "{}x^{}", c, e)?
            },
        };

        for (e, c) in iter {
            if e == 0 {
                write!(f, " + {}", c)?;
            } else {
                write!(f, " + {}x^{}", c, e)?;
            }
        }

        Ok(())
    }
}

impl<T: Num + Copy> Add for &Polynomial<T> {
    type Output = Polynomial<T>;
    fn add(self, rhs: Self) -> Self::Output {
        // Order the polynomials by degree.
        let (min, max) = match self.len() >= rhs.len() {
            true => (rhs, self),
            false => (self, rhs),
        };

        let mut coeffs = Vec::with_capacity(max.len());

        // Add up all coefficients that exist in both.
        self.coeffs.iter()
            .zip(rhs.coeffs.iter())
            .for_each(|(l, r)| coeffs.push(*l + *r));

        // Push the remaining coefficients.
        for c in &max.coeffs[min.len()..] {
            coeffs.push(*c);
        }
        
        Polynomial { coeffs }
    }
}

impl<T: NumAssign + Copy> AddAssign<&Polynomial<T>> for Polynomial<T> {
    fn add_assign(&mut self, rhs: &Self) {
        // Add the coefficients that exist in both.
        self.coeffs.iter_mut()
            .zip(rhs.coeffs.iter())
            .for_each(|(l, r)| *l += *r);

        // Push the remaining coefficients should rhs have more.
        for c in &rhs.coeffs[self.len()..] {
            self.coeffs.push(*c);
        }
    }
}

impl<T: NumAssign + Copy> AddAssign<T> for Polynomial<T> {
    fn add_assign(&mut self, rhs: T) {
        if self.coeffs.is_empty() {
            self.coeffs.push(rhs);
        } else {
            self.coeffs[0] += rhs;
        }
    }
}

impl<T: Num + Copy> Sub for &Polynomial<T> {
    type Output = Polynomial<T>;
    fn sub(self, rhs: Self) -> Self::Output {
        // Order the polynomials by degree.
        let (min, max) = match self.len() >= rhs.len() {
            true => (rhs, self),
            false => (self, rhs),
        };

        let mut coeffs = Vec::with_capacity(max.len());

        // Add up all coefficients that exist in both.
        self.coeffs.iter()
            .zip(rhs.coeffs.iter())
            .for_each(|(l, r)| coeffs.push(*l - *r));

        // Push the remaining coefficients.
        for c in &max.coeffs[min.len()..] {
            coeffs.push(*c);
        }
        
        Polynomial { coeffs }
    }
}

impl<T: NumAssign + Copy> SubAssign<&Polynomial<T>> for Polynomial<T> {
    fn sub_assign(&mut self, rhs: &Self) {
        // Add the coefficients that exist in both.
        self.coeffs.iter_mut()
            .zip(rhs.coeffs.iter())
            .for_each(|(l, r)| *l -= *r);

        // Push the remaining coefficients should rhs have more.
        for c in &rhs.coeffs[self.len()..] {
            self.coeffs.push(T::zero() - *c);
        }
    }
}

impl<T: NumAssign + Copy> Mul for &Polynomial<T> {
    type Output = Polynomial<T>;
    fn mul(self, rhs: Self) -> Self::Output {
        let mut coeffs = vec![T::zero(); self.len() + rhs.len() - 1];
        for (i, c) in rhs.coeffs.iter().enumerate() {
            for (j, d) in self.coeffs.iter().enumerate() {
                coeffs[i + j] += *c * *d;
            }
        }

        Polynomial { coeffs }
    }
}

impl<T: NumAssign + Copy> MulAssign<&Polynomial<T>> for Polynomial<T> {
    fn mul_assign(&mut self, rhs: &Polynomial<T>) {
        *self = &*self * rhs;
    }
}

impl<T: ShlAssign<usize>> ShlAssign<usize> for Polynomial<T> {
    fn shl_assign(&mut self, m: usize) {
        for c in &mut self.coeffs {
            *c <<= m;
        }
    }
}
```

`src/printer.rs`:

```rs
//! Prints the expressions in different formats.
//! The implementation is a bit disgusting.

use std::fmt::{self, Display, Write, Formatter};
use crate::uniform_expr::{UExpr, LUExpr};
use crate::pages::Width;
use crate::numbers::UniformNum;

use wasm_bindgen::prelude::*;
use num_traits::{Zero, One};

/// Determines how the result will be printed.
#[wasm_bindgen]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Printer {
    /// Some default.
    Default,

    /// Print a C function.
    C,

    /// Print a rust function.
    Rust,

    /// Tex expression.
    Tex,
}

impl Printer {
    /// Abbreviation to turn a UExpr into something
    /// that is `Display`ed correctly.
    fn u(self, e: &'_ UExpr) -> UExprPrinter<'_> {
        UExprPrinter { p: self, e }
    }

    pub fn print_uexpr(self, e: &UExpr) -> String {
        self.u(e).to_string()
    }

    pub fn print_luexpr<T: UniformNum>(self, e: &LUExpr<T>) -> String {
        let mut s = String::with_capacity(e.0.len() * 8);
        match self {
            Printer::C | Printer::Default => {
                let ty = match std::mem::size_of::<T>() {
                    1 => "uint8_t",
                    2 => "uint16_t",
                    4 => "uint32_t",
                    8 => "uint64_t",
                    16 => "uint128_t",
                    _ => unreachable!(),
                };

                let vars = e.vars();
                write!(&mut s, "{} f(", ty);
                for v in &vars {
                    write!(&mut s, "{} {}, ", ty, v);
                }

                // Remove the last ', '.
                s.pop();
                s.pop();
                s += ") {\n\treturn ";
                self.print_luexpr_impl(&mut s, e, "");
                s += ";\n}"
            },
            Printer::Rust => {
                let (ty, const_suffix) = match std::mem::size_of::<T>() {
                    1   => ("Wrapping<u8>", "u8"),
                    2   => ("Wrapping<u16>", "u16"),
                    4   => ("Wrapping<u32>", "u32"),
                    8   => ("Wrapping<u64>", "u64"),
                    16  => ("Wrapping<u128>", "u128"),
                    _ => unreachable!(),
                };

                let vars = e.vars();
                s += "fn f(";
                for v in &vars {
                    write!(&mut s, "{}: {},", v, ty);
                }

                // Remove the last ', '.
                s.pop();
                s.pop();
                s += ") -> ";
                s += ty;
                s += " {\n\t";
                self.print_luexpr_impl(&mut s, e, const_suffix);
                s += "\n}"
            },
            Printer::Tex => self.print_luexpr_impl(&mut s, e, ""),
        }

        return s;
    }

    fn print_luexpr_impl<T: UniformNum>(
        self,
        s: &mut String,
        e: &LUExpr<T>,
        const_suffix: &str,
    ) {
        let mut iter = e.0.iter()
            .filter(|(i, _)| *i != T::zero())
            .map(|(i, e)| (*i, e));

        let (mut i, e) = match iter.next() {
            Some(t) => t,
            None => return *s += "0",
        };

        let fmt_term = |s: &mut String, mut i: T, e: &UExpr| {
            let unary = e.is_unary();
            let e = self.u(e);
            if i == T::one() {
                if unary {
                    write!(s, "{}", e);
                } else {
                    write!(s, "({})", e);
                }
            } else {
                if self == Self::Rust {
                    if unary {
                        write!(s, "Wrapping({}{})*{}", i, const_suffix, e);
                    } else {
                        write!(s, "Wrapping({}{})*({})", i, const_suffix, e);
                    }
                    return;
                }

                let op = match self {
                    Self::Default | Self::C | Self::Rust => "*",
                    Self::Tex => "\\cdot ",
                };

                if unary {
                    write!(s, "{}{}{}", i, op, e);
                } else {
                    write!(s, "{}{}({})", i, op, e);
                }
            }
        };

        if i.print_negative() {
            write!(s, "-");
            i = T::zero() - i
        }
        fmt_term(s, i, e);

        for (i, e) in iter {
            let j = if i.print_negative() {
                write!(s, " - ");
                T::zero() - i
            } else {
                write!(s, " + ");
                i
            };
            fmt_term(s, j, e);
        }
    }
}

struct UExprPrinter<'a> {
    p: Printer,
    e: &'a UExpr,
}

impl<'a> UExprPrinter<'a> {
    fn u<'b>(&self, e: &'b UExpr) -> UExprPrinter<'b> {
        UExprPrinter { p: self.p, e }
    }

    fn write_safe(
        &self, l: &UExpr, r: &UExpr, op: &str, f: &mut Formatter<'_>
    ) -> fmt::Result {
        let l = self.u(l);
        let r = self.u(r);
        if l.e.is_unary() {
            write!(f, "{} {}", l, op)?;
        } else {
            write!(f, "({}) {}", l, op)?;
        }

        if r.e.is_unary() {
            write!(f, " {}", r)
        } else {
            write!(f, " ({})", r)
        }
    }
}

impl<'a> Display for UExprPrinter<'a> {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        use UExpr::*;
        use Printer::*;
        match self.e {
            Ones => f.write_str("-1"),
            Var(c) => f.write_str(c),
            Not(i) => {
                let i = self.u(i);
                match self.p {
                    Default | C if i.e.is_unary() => write!(f, "~{}", i),
                    Default | C => write!(f, "~({})", i),
                    Rust if i.e.is_unary() => write!(f, "!{}", i),
                    Rust => write!(f, "!({})", i),
                    Tex => write!(f, "\\overline{{{}}}", i),
                }
            },
            And(l, r) => {
                match self.p {
                    Default | C | Rust => self.write_safe(l, r, "&", f),
                    Tex => self.write_safe(l, r, "\\land", f),
                }
            },
            Or(l, r) => {
                match self.p {
                    Default | C | Rust => self.write_safe(l, r, "|", f),
                    Tex => self.write_safe(l, r, "\\lor", f),
                }
            },
            Xor(l, r) => {
                match self.p {
                    Default | C | Rust => self.write_safe(l, r, "^", f),
                    Tex => self.write_safe(l, r, "\\oplus", f),
                }
            }
        }
    }
}
```

`src/uniform_expr.rs`:

```rs
use std::collections::BTreeSet;
use std::fmt::{self, Formatter, Display};
use std::ops::{Index, IndexMut};
use std::rc::Rc;
use num_traits::Num;

use crate::expr::Expr;
use crate::numbers::{UnsignedInt, UniformNum, int_from_it};

/// LUExpr is short for "Linear combination of Uniform Expressions"
/// These are the expressions for which rewrite rules can be efficiently
/// generated.
#[derive(Clone, Debug)]
pub struct LUExpr<T>(pub Vec<(T, UExpr)>);

impl<T: UniformNum> LUExpr<T> {
    /// Creates an expression that equals a constant.
    pub fn constant(c: T) -> Self {
        Self(vec![(T::zero() - c, UExpr::Ones)])
    }

    /// Create a uniform expression.
    pub fn from_uexpr(u: UExpr) -> Self {
        Self(vec![(T::one(), u)])
    }

    /// Creates an expression that equals a variable.
    pub fn var(name: String) -> Self {
        Self(vec![(T::one(), UExpr::Var(name))])
    }

    /// Returns all variables in the expression.
    /// This will include duplicates.
    pub fn vars(&self) -> Vec<String> {
        let mut v = BTreeSet::new();
        self.vars_impl(&mut v);
        v.into_iter().collect()
    }

    pub(crate) fn vars_impl(&self, v: &mut BTreeSet<String>) {
        for (_, e) in &self.0 {
            e.vars_impl(v);
        }
    }

    /// Evaluate an expression with a valuation for the occurring variables.
    pub fn eval(&self, v: &Valuation<T>) -> T {
        self.0.iter()
            .map(|(i, e)| *i * e.eval(v))
            .fold(T::zero(), T::add)
    }

    /// Parse a string to an expression.
    /// Note that this function is extremely limited
    /// and expects very specific syntax.
    /// It is used for convenience when testing things and
    /// not really meant to be used by something outside this crate.
    pub(crate) fn from_string(s: String) -> Option<Self> {
        let mut s = s.to_string();
        s.retain(|c| !c.is_whitespace());
        let mut it = s.chars().peekable();

        // This stores the current linear combination.
        let mut v = Vec::new();

        let mut neg = false;

        // Loop over the string/the summands.
        loop {
            // Are there still characters left?
            // If not then we're done.
            let mut c = match it.peek() {
                None => return Some(Self(v)),
                Some(c) => *c,
            };

            if c == '-' {
                neg = true;
                it.next();
                c = *it.peek()?;
            }

            // If this is a digit then we expect num*UExpr.
            if c.is_ascii_digit() {
                // Parse the number.
                let mut num = int_from_it(&mut it)?;

                // If the number is negative then negate it.
                if neg {
                    num = T::zero() - num;
                }

                // Is it the expected '*'?
                match it.peek() {
                    Some('*') => {
                        it.next();

                        // Parse the UExpr.
                        let e = UExpr::parse(&mut it, 0)?;

                        // Push it.
                        v.push((num, e));
                    },

                    // If this is a different character then we push -num*(-1).
                    _ => v.push((T::zero() - num, UExpr::Ones)),
                }
            } else {
                // We don't have a factor so just parse the UExpr.
                let e = UExpr::parse(&mut it, 0)?;

                let sign = match neg {
                    false => T::one(),
                    true => T::zero() - T::one(),
                };

                // Push sign*e.
                v.push((sign, e));
            }

            // If the next character is not a plus then we are done.
            match it.peek() {
                // Next part of the linear combination.
                Some('+') => { neg = false; it.next() }, // Skip the +.
                Some('-') => { neg = true; it.next() },

                // We consumed the whole input so we're good.
                None => return Some(Self(v)),

                // There is something left but we can't parse it.
                _ => return None,
            };
        }
    }

    pub fn to_expr(&self) -> Expr<T> {
        let mut it = self.0.iter()
            .filter(|(f, u)| !f.is_zero());

        // If the linear combination is empty,
        // then it always evaluates to 0.
        let Some((f, u)) = it.next() else {
            return Expr::zero()
        };

        // Lambda to convert the `coefficient * uexpr` into an expr.
        let term = |f: T, u: &UExpr| {
            if f.is_one() {
                u.to_expr()
            } else {
                Expr::Mul(Rc::new(Expr::Const(f)), Rc::new(u.to_expr()))
            }
        };

        // Iterate over the linear combination and update e.
        let mut e = term(*f, u);
        for (f, u) in it {
            e = Expr::Add(Rc::new(e), Rc::new(term(*f, u)));
        }

        e
    }
}

impl<T: UniformNum> From<UExpr> for LUExpr<T> {
    fn from(e: UExpr) -> Self {
        Self(vec![(T::one(), e)])
    }
}

impl<T: UniformNum> Display for LUExpr<T> {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        let mut iter = self.0.iter()
            .filter(|(i, _)| *i != T::zero())
            .map(|(i, e)| (*i, e));
        let (mut i, e) = match iter.next() {
            Some(t) => t,
            None => return write!(f, "0"),
        };

        let fmt_term = |f: &mut Formatter<'_>, i: T, e: &UExpr| {
            if i == T::one() {
                write!(f, "{}", e)
            } else {
                if e.is_unary() {
                    write!(f, "{}*{}", i, e)
                } else {
                    write!(f, "{}*({})", i, e)
                }
            }
        };

        if i.print_negative() {
            write!(f, "-")?;
            i = T::zero() - i
        }
        fmt_term(f, i, e)?;

        for (i, e) in iter {
            let j = if i.print_negative() {
                write!(f, " - ")?;
                T::zero() - i
            } else {
                write!(f, " + ")?;
                i
            };
            fmt_term(f, j, e);
        }

        Ok(())
    }
}

/// Represents an expression that is uniform on all bits.
/// Note that the variant 'Ones' does not equal 1, but a 1 in every bit,
/// which is -1 in two's complement.
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum UExpr {
    Ones,
    Var(String),
    Not(Box<Self>),
    And(Box<Self>, Box<Self>),
    Or(Box<Self>, Box<Self>),
    Xor(Box<Self>, Box<Self>),
}

impl UExpr {
    pub fn var(c: String) -> Self {
        Self::Var(c)
    }

    pub fn not(e: Self) -> Self {
        Self::Not(e.into())
    }

    pub fn and(l: Self, r: Self) -> Self {
        Self::And(l.into(), r.into())
    }

    pub fn or(l: Self, r: Self) -> Self {
        Self::Or(l.into(), r.into())
    }

    pub fn xor(l: Self, r: Self) -> Self {
        Self::Xor(l.into(), r.into())
    }

    /// Is the top-most operator unary.
    pub fn is_unary(&self) -> bool {
        use UExpr::*;
        match self {
            Ones | Var(_) | Not(_) => true,
            _ => false,
        }
    }

    /// Returns all variables in the expression.
    /// This will include duplicates.
    pub fn vars(&self) -> Vec<String> {
        let mut v = BTreeSet::new();
        self.vars_impl(&mut v);
        v.into_iter().collect()
    }

    // Should really be `pub(self)`.
    pub(crate) fn vars_impl(&self, v: &mut BTreeSet<String>) {
        use UExpr::*;
        match self {
            Ones            => {},
            Var(c)          => if !v.contains(c) { v.insert(c.clone()); },
            Not(e)          => e.vars_impl(v),
            And(e1, e2)     => { e1.vars_impl(v); e2.vars_impl(v) },
            Or(e1, e2)      => { e1.vars_impl(v); e2.vars_impl(v) },
            Xor(e1, e2)     => { e1.vars_impl(v); e2.vars_impl(v) },
        }
    }

    /// Evaluate an expression with a valuation for the occurring variables.
    pub fn eval<T: UniformNum>(&self, v: &Valuation<T>) -> T {
        use UExpr::*;
        match self {
            Ones            => T::zero() - T::one(), // -1
            Var(c)          => v[c],
            Not(e)          => !e.eval(v),
            And(e1, e2)     => e1.eval(v) & e2.eval(v),
            Or(e1, e2)      => e1.eval(v) | e2.eval(v),
            Xor(e1, e2)     => e1.eval(v) ^ e2.eval(v),
        }
    }

    /// Rename a variable.
    pub fn rename_var(&mut self, old: &str, new: &str) {
        use UExpr::*;
        match self {
            Ones        => (),
            Var(v)      => if v == old { v.clear(); v.push_str(new) },
            Not(e)      => e.rename_var(old, new),
            And(l, r)   => { l.rename_var(old, new); r.rename_var(old, new) },
            Or(l, r)    => { l.rename_var(old, new); r.rename_var(old, new) },
            Xor(l, r)   => { l.rename_var(old, new); r.rename_var(old, new) },
        }
    }

    pub(crate) fn write_safe(
        e1: &Self, e2: &Self, op: &str, f: &mut std::fmt::Formatter<'_>
    ) -> std::fmt::Result {
        if e1.is_unary() {
            write!(f, "{} {}", e1, op)?;
        } else {
            write!(f, "({}) {}", e1, op)?;
        }

        if e2.is_unary() {
            write!(f, " {}", e2)
        } else {
            write!(f, " ({})", e2)
        }
    }

    /// Parse a string to an expression.
    pub(crate) fn from_string<T: ToString>(s: T) -> Option<Self> {
        let mut s = s.to_string();
        s.retain(|c| !c.is_whitespace());
        let mut it = s.chars().peekable();

        Self::parse(&mut it, 0)
            .filter(|_| it.next().is_none())
    }

    pub(self) fn parse(
        it: &mut std::iter::Peekable<std::str::Chars>,
        pre: usize
    ) -> Option<Self> {
        use UExpr::*;

        let c = *it.peek()?;

        let mut e = if c == '(' {
            it.next();
            let e = Self::parse(it, 0)?;
            match it.next() {
                Some(')') => e,
                _ => return None,
            }
        } else if c == '~' || c == '!' {
            it.next();
            let e = Self::parse(it, 15)?;
            Not(Box::new(e))
        } else if c.is_alphabetic() {
            it.next();
            let mut var = String::from(c);
            loop {
                let Some(c) = it.peek() else {
                    break
                };

                if !c.is_alphanumeric() {
                    break
                }

                var.push(*c);
                it.next();
            }
            
            Var(var)
        } else if c == '-' {
            it.next();
            // Parse a -1.
            match it.next() {
                Some('1') => Ones,
                _ => return None,
            }
        } else {
            return None;
        };

        loop {
            let c = match it.peek() {
                None => return Some(e),
                Some(c) => *c,
            };

            let op_pre = match c {
                '|' => 1,
                '^' => 2,
                '&' => 3,
                _ => return Some(e),
            };

            if op_pre <= pre {
                return Some(e);
            }

            // If the current operators precedence is higher than
            // the one whose subexpressions we are currently parsing
            // then we need to finish this operator first.
            it.next();
            let rhs = Box::new(Self::parse(it, op_pre)?);
            let lhs = Box::new(e);
            e = match c {
                '&' => And(lhs, rhs),
                '|' => Or(lhs, rhs),
                '^' => Xor(lhs, rhs),
                _ => return None,
            };
        }
    }

    pub fn to_expr<T: UniformNum>(&self) -> Expr<T> {
        match self {
            UExpr::Ones => Expr::Const(T::zero() - T::one()),
            UExpr::Var(v) => Expr::Var(v.clone()),
            UExpr::Not(e) => Expr::Not(Rc::new(e.to_expr::<T>())),
            UExpr::And(l, r) => Expr::And(Rc::new(l.to_expr::<T>()), Rc::new(r.to_expr::<T>())),
            UExpr::Or(l, r) => Expr::Or(Rc::new(l.to_expr::<T>()), Rc::new(r.to_expr::<T>())),
            UExpr::Xor(l, r) => Expr::Xor(Rc::new(l.to_expr::<T>()), Rc::new(r.to_expr::<T>())),
        }
    }
}

impl std::fmt::Display for UExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use UExpr::*;
        match self {
            Ones => write!(f, "-1"),
            Var(c) => write!(f, "{}", c),
            And(e1, e2)   => Self::write_safe(e1, e2, "&", f),
            Or(e1, e2)    => Self::write_safe(e1, e2, "|", f),
            Xor(e1, e2)   => Self::write_safe(e1, e2, "^", f),
            Not(e) =>
                if e.is_unary() {
                    write!(f, "~{}", e)
                } else {
                    write!(f, "~({})", e)
                },
        }
    }
}

/// Stores values that should be substituted into variables.
#[derive(Debug)]
pub struct Valuation<T> {
    /// The key value pairs are stored as a Vector
    /// because I doubt a hashmap/tree would be faster
    /// when there are so few variables.
    vals: Vec<(String, T)>,
}

impl<T: Num> Valuation<T> {
    /// Initializes a valuation from a list of variables
    /// each of which will be Initialized to 0.
    pub fn zero(vars: Vec<String>) -> Self {
        let vals = vars.into_iter()
            .map(|c| (c, T::zero()))
            .collect();

        Self { vals }
    }
}

impl<T> Index<&str> for Valuation<T> {
    type Output = T;
    fn index(&self, index: &str) -> &Self::Output {
        &self.vals.iter()
            .find(|(name, _)| *name == index)
            .unwrap().1
    }
}

impl<T> IndexMut<&str> for Valuation<T> {
    fn index_mut(&mut self, index: &str) -> &mut Self::Output {
        &mut self.vals.iter_mut()
            .find(|(name, _)| *name == index)
            .unwrap().1
    }
}
```

`src/vector.rs`:

```rs
use std::boxed::Box;
use std::ops::{Index, IndexMut, AddAssign, Mul};
use std::fmt::Write;

use num_traits::Num;

use crate::numbers::UnsignedInt;

#[derive(Clone)]
pub struct Vector<T> {
    /// The number of entries in the vector.
    pub dim: usize,

    /// Memory that holds the entries.
    pub(self) entries: Box<[T]>,
}

impl<T> Vector<T> {
    /// Returns an empty vector.
    pub fn empty() -> Self {
        Self {
            dim: 0,
            entries: Box::new([]),
        }
    }

    /// Is the vector empty.
    pub fn is_empty(&self) -> bool {
        self.dim == 0
    }

    /// Creates a vector from a slice.
    pub fn from_slice<U: Clone>(s: &[U]) -> Self
        where T: From<U>,
     {
        Self {
            dim: s.len(),
            entries: s.iter()
                .map(|e| T::from(e.clone()))
                .collect::<Vec<_>>()
                .into_boxed_slice()
        }
    }

    /// Returns a slice of the entries.
    pub fn entries(&self) -> &[T] {
        &self.entries
    }

    /// Returns a mutable slice of the entries.
    pub fn entries_mut(&mut self) -> &mut [T] {
        &mut self.entries
    }

    /// Returns an iterator over the elements.
    pub fn iter(&self) -> std::slice::Iter<'_, T> {
        self.entries().iter()
    }

    /// Returns an iterator over mutable references to the elements.
    pub fn iter_mut(&mut self) -> std::slice::IterMut<'_, T> {
        self.entries_mut().iter_mut()
    }

    /// Returns an reference to an entry.
    pub fn entry(&self, i: usize) -> &T {
        &self.entries[i]
    }

    /// Returns a mutable reference to an entry.
    pub fn entry_mut(&mut self, i: usize) -> &mut T {
        &mut self.entries[i]
    }

    /// Apply a function to each entry.
    pub fn map<U, F>(&self, mut f: F) -> Vector<U>
        where F: FnMut(&T) -> U
    {
        let mut v = Vec::with_capacity(self.entries.len());
        for e in self.entries.iter() {
            v.push(f(e));
        }
        
        Vector::<U> {
            dim: self.dim,
            entries: v.into_boxed_slice()
        }
    }

    /// Apply a function to each entry that can fail.
    /// If the function for the first time, then that resulting error
    /// and the location of the entry is returned.
    pub fn try_map<U, E, F>(&self, mut f: F) -> Result<Vector<U>, (usize, E)>
        where F: FnMut(&T) -> Result<U, E>
    {
        let mut v = Vec::with_capacity(self.entries.len());
        for e in self.entries.iter() {
            match f(e) {
                Ok(e) => v.push(e),
                Err(e) => {
                    return Err((v.len(), e));
                }
            }
        }
        
        Ok(Vector::<U> {
            dim: self.dim,
            entries: v.into_boxed_slice()
        })
    }
}

impl<T: Clone> Vector<T> {
    /// Creates a new vector whose entries are initialized with `val`.
    pub fn uniform(dim: usize, val: T) -> Self {
        Self {
            dim,
            entries: vec![val; dim].into_boxed_slice(),
        }
    }
}

impl<T: Num + Clone> Vector<T> {
    /// Returns a zero vector.
    pub fn zero(dim: usize) -> Self {
        Self {
            dim,
            entries: vec![T::zero(); dim].into_boxed_slice(),
        }
    }

    /// Is this the zero vector?
    pub fn is_zero(&self) -> bool {
        self.iter().all(|e| *e == T::zero())
    }
}

impl<T: UnsignedInt> Vector<T> {
    pub fn to_tex(&self) -> String {
        let mut s = "\\left[\\begin{array}{}".to_owned();
        for e in self.iter().cloned() {
            if (e.print_negative()) {
                write!(&mut s, "-{}\\\\", T::zero() - e);
            } else {
                write!(&mut s, "{}\\\\", e);
            }
        }
        s += "\\end{array}\\right]";
        s
    }
}

impl<T> Index<usize> for Vector<T> {
    type Output = T;

    fn index(&self, index: usize) -> &Self::Output {
        self.entry(index)
    }
}

impl<T> IndexMut<usize> for Vector<T> {
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        self.entry_mut(index)
    }
}

impl<T: Num + Copy> Mul<T> for Vector<T> {
    type Output = Vector<T>;
    fn mul(mut self, rhs: T) -> Self::Output {
        for e in self.iter_mut() {
            *e = *e * rhs;
        }
        self
    }
}

impl<T: Num + Copy> AddAssign<&Vector<T>> for Vector<T> {
    fn add_assign(&mut self, rhs: &Vector<T>) {
        debug_assert!(self.dim == rhs.dim);
        for (e, f) in self.iter_mut().zip(rhs.iter()) {
            *e = *e + *f;
        }
    }
}
```

`www/index.html`:

```html
<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Mixed Boolean-Arithmetic</title>
        <link rel="icon" href="data:,">
        <style>
            .custom-popover {
                --bs-popover-max-width: 500px !important;
            }
        </style>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
        <link href="prism.css" rel="stylesheet" />
        <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" data-manual></script>
        <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-clike.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-c.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-cpp.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-rust.min.js"></script>
        <script type="module" src="obfuscate.js"></script>
    </head>
    <body class="container p-3 mx-auto" style="width: 37.5%">
        <h2 class="mx-auto">Mixed Boolean-Arithmetic Obfuscation</h2>
        <input id="input" type="text" class="form-control mx-auto" placeholder="Input expression" style="font-family: monospace;">
        <div id="input-error" class="invalid-feedback"></div>
        <div class="mb-2 mt-2">
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="bitness" id="bitness-8" value="U8" checked>
                <label class="form-check-label" for="bitness-8">8-bit</label>
            </div>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="bitness" id="bitness-16" value="U16">
                <label class="form-check-label" for="bitness-16">16-bit</label>
            </div>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="bitness" id="bitness-32" value="U32">
                <label class="form-check-label" for="bitness-32">32-bit</label>
            </div>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="bitness" id="bitness-64" value="U64">
                <label class="form-check-label" for="bitness-64">64-bit</label>
            </div>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="bitness" id="bitness-128" value="U128">
                <label class="form-check-label" for="bitness-128">128-bit</label>
            </div>
        </div>
        <div class="dropdown mb-3">
            Output type
            <button id="output-type" class="btn btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown">
                C
            </button>
            <ul class="dropdown-menu">
                <li><button name="output-type" class="dropdown-item active" type="button">C</button></li>
                <li><button name="output-type" class="dropdown-item" type="button">Rust</button></li>
            </ul>
        </div>
        <button id="obfuscate-btn" type="button" class="btn btn-primary mb-3">Obfuscate</button>
        <div id="output" style="overflow:scroll"></div>
        <hr>
        <div id="explanation" class="accordion">
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#acc-col-1">
                        <strong>What is Mixed Boolean-Arithmetic?</strong>
                    </button>
                </h2>
                <div id="acc-col-1" class="accordion-collapse collapse" data-bs-parent="#explanation">
                    <div class="accordion-body"></div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#acc-col-2">
                        <strong>How does it work?</strong>
                    </button>
                </h2>
                <div id="acc-col-2" class="accordion-collapse collapse" data-bs-parent="#explanation">
                    <div class="accordion-body">
                        Check out <a href="https://plzin.github.io/posts/mba" target="_blank">my series of blog posts</a>.
                        <br>
                        You can find the code for this page (including the algorithm) <a href="https://github.com/plzin/mba-wasm" target="_blank">here</a>.
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>
```

`www/linear_congruences.html`:

```html
<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8" />
        <title>Linear Congruence solver</title>
        <link rel="icon" href="data:,">
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
        <script type="module" src="linear_congruences.js"></script>
    </head>
    <body class="container p-3" style="width: 37.5%">
        <h2 class="mx-auto">System of Linear Congruences Solver</h2>
        <div class="row g-2">
            <div class="col-sm-8">
                <div class="form-floating mb-3">
                    <textarea id="matrix" class="form-control" placeholder="Augmented Matrix 'A'" style="height: 8em"></textarea>
                    <label for="matrix">Augmented matrix</label>
                </div>
            </div>
            <div class="col-sm-4">
                Bits
                <select id="modulus" class="form-select mb-3">
                    <option value="U8">8</option>
                    <option value="U16">16</option>
                    <option value="U32">32</option>
                    <option value="U64">64</option>
                    <option value="U128">128</option>
                </select>
                <button id="solve-btn" type="button" class="btn btn-primary w-100">Solve</button>
            </div>
        </div>
        <div id="err" style="color:red"></div>
        <div id="system"></div>
        <div id="math">
        </div>
    </body>
</html>
```

`www/linear_congruences.js`:

```js
import './mathjax.js'
import { solve_congruences, Width } from './wasm.js';

// Global tex render options.
let tex_options = { scale: 1.2 }

// Get a bunch of DOM elements we need.
const mat = document.getElementById('matrix')
const mod = document.getElementById('modulus')
const b = document.getElementById('solve-btn')
const error = document.getElementById('err')
const system = document.getElementById('system')
const math = document.getElementById('math')

// Changing the matrix text field updates the tex'd system.
const show_eqs = () => {
    MathJax.reset()
    let eqs = '\\begin{align}'
    for (let line of mat.value.split('\n')) {
        line = line.trim()
        if (line === '')
            continue;

        let elements = line.split(' ')
        let rhs = ''
        if (elements.length > 1) {
            rhs = elements.pop()
        }
        for (let i = 0; i < elements.length; ++i) {
            eqs += elements[i]
            eqs += `x_{${i+1}}&+`
        }

        eqs = eqs.slice(0, -1)
        eqs += `\\equiv ${rhs}&\\pmod{2^{${mod.options[mod.selectedIndex].label}}}\\\\`
    }
    eqs += '\\end{align}'

    system.replaceChildren()
    system.appendChild(MathJax.tex2chtml(eqs, tex_options))

    MathJax.set_css('mjx-system-styles')
}
    
// Draw the equations once.
show_eqs()

// Update when the matrix or the modulus changes.
mat.oninput = mod.oninput = show_eqs

// Clicking the button solves the system.
b.onclick = () => {
    try {
        error.textContent = ''

        let add_text = (str) => {
            math.appendChild(document.createTextNode(str))
        }
        let add_math = (str) => {
            math.appendChild(MathJax.tex2chtml(str, tex_options))
        }

        let s = solve_congruences(mat.value, Width[mod.value])

        MathJax.reset()
        math.replaceChildren()
        add_text('The diagonalization of the matrix A is')
        add_math(s.diag)

        add_text('The new system is')
        add_math(s.scalar_system)

        add_text('which results in the single variable linear congruences')
        add_math(s.linear_solutions)

        if (s.vector_solution.length === 0) {
            add_text('So overall the system has no solution.')
        } else {
            add_text('The vector form is')
            add_math(s.vector_solution)

            add_text('The final solution to the original system is')
            add_math(s.final_solution)
        }

        MathJax.set_css('mjx-solution-styles')
    } catch (err) {
        if (typeof err === "string") {
            error.textContent = err
        } else {
            console.log(err)
            error.textContent = 'Error. Check console.'
        }
    }
}
```

`www/linear_mba.html`:

```html
<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Linear Mixed Boolean-Arithmetic</title>
        <link rel="icon" href="data:,">
        <style>
            .custom-popover {
                --bs-popover-max-width: 500px !important;
            }
        </style>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
        <link href="prism.css" rel="stylesheet" />
        <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" data-manual></script>
        <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-clike.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-c.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-cpp.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-rust.min.js"></script>
        <script type="module" src="linear_mba.js"></script>
    </head>
    <body class="container p-3 mx-auto" style="width: 37.5%">
        <h2 class="mx-auto">Mixed Boolean-Arithmetic Obfuscation</h2>
        <input id="input" type="text" class="form-control mx-auto" placeholder="Input expression">
        <div id="input-error" class="invalid-feedback"></div>
        <div class="mb-2 mt-2">
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="bitness" id="bitness-8" value="U8" checked>
                <label class="form-check-label" for="bitness-8">8-bit</label>
            </div>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="bitness" id="bitness-16" value="U16">
                <label class="form-check-label" for="bitness-16">16-bit</label>
            </div>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="bitness" id="bitness-32" value="U32">
                <label class="form-check-label" for="bitness-32">32-bit</label>
            </div>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="bitness" id="bitness-64" value="U64">
                <label class="form-check-label" for="bitness-64">64-bit</label>
            </div>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="bitness" id="bitness-128" value="U128">
                <label class="form-check-label" for="bitness-128">128-bit</label>
            </div>
        </div>
        <div class="row mb-3">
            <div class="col-sm-8">
                <ul id="ops" class="list-group">
                    <li class="list-group-item active fw-bold">Rewrite operations:</li>
                    <li id="op-add-item" class="list-group-item">
                        <div class="d-flex justify-content-between align-items-start">
                            <input id="op-input" type="text" class="form-control me-auto" placeholder="Rewrite operation">
                            <button id="op-add" type="button" class="btn btn-primary ms-3">Add</button>
                        </div>
                        <div id="op-error" class="invalid-feedback">Invalid operation</div>
                    </li>
                </ul>
            </div>
            <div class="col-sm-4">
                <div id="randomize-div" class="form-check mb-1">
                    <input id="random" class="form-check-input" type="checkbox" checked>
                    <label class="form-checklabel" for="random">Random solution</label>
                </div>
                <div class="dropdown">
                    Output type
                    <button id="output-type" class="btn btn-secondary dropdown-toggle w-100" type="button" data-bs-toggle="dropdown">
                        C
                    </button>
                    <ul class="dropdown-menu w-100">
                        <li><button name="output-type" class="dropdown-item active" type="button">C</button></li>
                        <li><button name="output-type" class="dropdown-item" type="button">Rust</button></li>
                        <li><button name="output-type" class="dropdown-item" type="button">Tex</button></li>
                    </ul>
                </div>
            </div>
        </div>
        <button id="obfuscate-btn" type="button" class="btn btn-primary mb-3">Obfuscate</button>
        <div id="output" style="overflow:scroll"></div>
        <hr>
        <div id="explanation" class="accordion">
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#acc-col-1">
                        <strong>What is Mixed Boolean-Arithmetic?</strong>
                    </button>
                </h2>
                <div id="acc-col-1" class="accordion-collapse collapse" data-bs-parent="#explanation">
                    <div class="accordion-body"></div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#acc-col-2">
                        <strong>What operations are allowed?</strong>
                    </button>
                </h2>
                <div id="acc-col-2" class="accordion-collapse collapse" data-bs-parent="#explanation">
                    <div class="accordion-body"></div>
                </div>
            </div>
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#acc-col-3">
                        <strong>How does it work?</strong>
                    </button>
                </h2>
                <div id="acc-col-3" class="accordion-collapse collapse" data-bs-parent="#explanation">
                    <div class="accordion-body">
                        Check out <a href="https://plzin.github.io/posts/mba" target="_blank">my series of blog posts</a>.
                        <br>
                        You can find the code for this page (including the algorithm) <a href="https://github.com/plzin/mba-wasm" target="_blank">here</a>.
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>
```

`www/linear_mba.js`:

```js
import { obfuscate_linear, normalize_op, ObfLinReq, Width, Printer } from './wasm.js';
import './mathjax.js'

const btn = document.getElementById('obfuscate-btn')
const input = document.getElementById('input')
const output = document.getElementById('output')
const input_error = document.getElementById('input-error')
const ops = document.getElementById('ops')
const op_input = document.getElementById('op-input')
const op_add = document.getElementById('op-add')
const op_add_item = document.getElementById('op-add-item')
const randomize = document.getElementById('random')
const output_type = document.getElementById('output-type')
const output_types = document.getElementsByName('output-type')

// Highlights inline code.
function hi_in(code) {
    return `<code class="language-c">${Prism.highlight(code, Prism.languages.c, 'c')}</code>`
}

// Part of the popover config supplying default values.
const popover_config = {
    trigger: 'hover',
    delay: { show: 500, hide: 100 },
    html: true,
    customClass: 'custom-popover',
}

// Popover for the input box.
new bootstrap.Popover(input, {
    ...popover_config,
    title: 'Expression that will be obfuscated',
    content:
`
Currently, the expression has to be a linear combination of boolean expressions.
Check 'What operations are allowed?' at the bottom of the page.
<br>
E.g. ${hi_in('3*(x & ~y) + 4*(x | y) - 2*~x')}.
<br>
This limitation will be removed in the future and more general expression will be allowed.
More commonly, you will probably want to use things like ${hi_in('x + y')}, ${hi_in('x - y')}.
<br>
Constants (${hi_in('1312')}) are also allowed.
`
})

// Popover for the rewrite operation input.
new bootstrap.Popover(op_input, {
    ...popover_config,
    title: 'Operations used during rewriting',
    content:
`
These are the operations that are allowed to appear in the resulting linear combination.
Only linear combinations of boolean operations are allowed.
`
})

// Popover for the 'random solution' button.
new bootstrap.Popover(document.getElementById('randomize-div'), {
    ...popover_config,
    title: `Generate a random output`,
    content:
`
Rewriting the input using the operations involves solving a 'System of Linear Congruences',
which is very similar to 'Systems of Linear Equations' that are known from Linear Algebra.
In the same way the solution also is a particular solution plus any vector in the kernel. 
If randomize solution is disabled, the particular solution that the algorithm returns is used.
Since the algorithm is deterministic it will always be the same.
Note that changing the order of the rewrite operations can change the solution.
To get a canonical solution, we could define some sort of norm and try to find the smallest
solution according to that norm, but this is future work.
`
})

// 'What is Mixed Boolean-Arithmetic?'
document.getElementById('acc-col-1').children[0].innerHTML =
`
Mixed Boolean-Arithmetic (MBA) is a name for expressions which contain both the usual arithmetic operations
(${hi_in('+')}, ${hi_in('-')}, ${hi_in('*')}, ${hi_in('/')})
as well as boolean operations (${hi_in('&')}, ${hi_in('|')}, ${hi_in('^')}, ${hi_in('~')}).
A simple example is the expression ${hi_in('2 * (x & y) + (x ^ y)')} that computes ${hi_in('x + y')}.
This particular one works for integers of any number of bits but generally they can be specific to
a certain size, such as the following one, that also computes ${hi_in('x + y')} but only for 8-bit integers:
<pre class="language-c" style="font-size: .875rem">${Prism.highlight('-38*(x & y) - 83*(x ^ y) - 64*~(x ^ (y ^ z))\n - 41*~x - 43*~y - 23*y - 44*z - 20*(y & z)\n - 21*(x | z) - 107*(~x & z) - 108*(y | ~z)', Prism.languages.c, 'c')}</pre>
`

// 'What operations are allowed?'
document.getElementById('acc-col-2').children[0].innerHTML =
`
Currently, this site can only generate <strong>Linear</strong> MBA expressions, which are linear combinations of boolean operations,
such as ${hi_in('24*(x & y) - 22*(x | y) - 105*(x ^ y) + 128*~x + 128*~y')}.
The allowed boolean operations are ${hi_in('x & y')} (and), ${hi_in('x | y')} (or), ${hi_in('x ^ y')} (xor), ${hi_in('~x')} (equivalently ${hi_in('!x')}) (not) and ${hi_in('-1')}.
${hi_in('-1')} is the mnemonic for the constant 1 function on each bit, which (when interpreted in two's complement) has the value -1.
Note that ${hi_in('!')} is an alias for the logical NOT and the same as ${hi_in('~')} here, whereas this is not the case in C.
Of course the operations can also be nested: ${hi_in('x & (y | !z)')}.
Constants ${hi_in('1312')} are also allowed as part of the linear combination and are represented internally as ${hi_in('-1312*(-1)')}.
<br><br>
The rewrite operations are usually just the boolean operations that appear in the output linear combination,
but they can be linear combinations themselves, as using those is equivalent to restricting the coefficients
of the output.
<br><br>
Additionally, the input expression has to be a Linear MBA expression as well, but this will be relaxed in the future.
The idea is to obfuscate parts of a general expression that are Linear MBA and substitute those in, so often it will
just be something like ${hi_in('x+y')}.
The rewrite operations are usually the boolean operations that appear in the linear combination,
but can also be linear combinations of boolean operations as using those is equivalent to restricting
the coefficients in the output linear combination.
`

// Setup handling for the output type dropdown.
for (const li of output_types) {
    li.onclick = (e) => {
        for (const li of output_types) {
            li.classList.remove('active')
        }
        e.target.classList.add('active')
        output_type.textContent = e.target.textContent
    }
}

// Remove an operation from the op list.
const remove_op = (e) => {
    e.target.parentNode.remove()
}

// Add an operation to the list of operations used for rewriting.
const add_op = () => {
    // Normalize the operation and make sure it is valid.
    const bits = Width[document.querySelector('input[name=bitness]:checked').value]
    const s = normalize_op(op_input.value, bits)
    
    // If it isn't, indicate that.
    if (s === '') {
        op_input.classList.add('is-invalid')
        op_input.parentElement.classList.add('is-invalid')
        return
    }

    // Remove potential prior indication.
    op_input.classList.remove('is-invalid')
    op_input.parentElement.classList.remove('is-invalid')

    // Create a new list item.
    const list_item = document.createElement('li')
    list_item.classList.add('list-group-item', 'd-flex', 'justify-content-between', 'align-items-start')

    const op_text = document.createElement('div')
    op_text.classList.add('ms-2', 'me-auto')
    op_text.textContent = s
    op_text.setAttribute('name', 'op-value')
    list_item.appendChild(op_text)

    const remove_btn = document.createElement('button')
    remove_btn.classList.add('btn-close')
    remove_btn.type = 'button'
    remove_btn.onclick = remove_op
    list_item.appendChild(remove_btn)

    // Insert it before the last item, which is the one
    // that contains the textfield and button.
    ops.insertBefore(list_item, op_add_item)
}

op_add.onclick = add_op
op_input.onkeydown = (e) => {
    if (e.key == "Enter")
        add_op()
}

// Do the obfuscation.
btn.onclick = () => {
    let req = new ObfLinReq()
    req.expr = input.value
    req.randomize = randomize.checked

    const printer = Printer[output_type.innerText.trim()]
    req.printer = printer

    // Collect the rewrite ops.
    for (const e of document.getElementsByName('op-value')) {
        req.add_op(e.innerText)
    }

    // Get the number of bits we are obfuscating for.
    const bits = Width[document.querySelector('input[name=bitness]:checked').value]
    req.bits = bits

    try {
        // Do the rewriting.
        const s = obfuscate_linear(req)
        input.classList.remove('is-invalid')
        input_error.textContent = ''

        // Display the result.
        output.replaceChildren()
        if (printer == Printer.C) {
            const code = document.createElement('pre')
            code.classList.add('language-c')
            code.innerHTML = Prism.highlight(s, Prism.languages.c, 'c')
            output.appendChild(code)

            // Very hacky and requires the code to contain commas only for the arguments.
            const args = s.split(',').map(() => '0').join(', ')
            const ce_code = encodeURIComponent(`#include <cstdint>\n#include <iostream>\n\n${s}\n\nint main() {\n\tstd::cout << ${bits == Width.U8 ? '(uint32_t)' : ''}f(${args}) << "\\n";\n}`)
            const ce_btn = document.createElement('button')
            ce_btn.textContent = 'Open in Compiler Explorer'
            ce_btn.classList.add('btn', 'btn-secondary')
            ce_btn.onclick = () => {
                window.open(`https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'${ce_code}'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:clang_trunk,compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!(),options:'',source:1,stdinPanelShown:'1',tree:'1',wrap:'1'),l:'5',n:'0',o:'Executor+x86-64+clang+(trunk)+(C%2B%2B,+Editor+%231)',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4`)
            }
            output.appendChild(ce_btn)
        } else if (printer == Printer.Rust) {
            const code = document.createElement('pre')
            code.classList.add('language-rust')
            code.innerHTML = Prism.highlight(s, Prism.languages.rust, 'rust')
            output.appendChild(code)

            const pg_btn = document.createElement('button')
            pg_btn.textContent = 'Open in Rust Playground'
            pg_btn.classList.add('btn', 'btn-secondary')

            // Very hacky and requires the code to contain commas only for the arguments.
            const args = s.split(',').map(() => 'Wrapping(0)').join(', ')
            const pg_code = encodeURIComponent(`use std::num::Wrapping;\n\nfn main() {\n\tprintln!("{}", f(${args}));\n}\n\n${s}`)
            pg_btn.onclick = () => {
                window.open(`https://play.rust-lang.org/?version=stable&mode=release&edition=2021&code=${pg_code}`)
            }
            output.appendChild(pg_btn)
        } else if (printer == Printer.Tex) {
            MathJax.reset()
            output.appendChild(MathJax.tex2chtml(s, { scale: 1.3 }))
            MathJax.set_css('mathjax-styles')
        } else {
            output.textContent = s
        }
    } catch (err) {
        input.classList.add('is-invalid')
        output.textContent = ''
        if (typeof err === 'string') {
            input_error.textContent = err
        } else {
            console.log(err)
            input_error.textContent = 'Unknown error. Check console.'
        }
    }
}
```

`www/mathjax.js`:

```js
// This module synchronously loads mathjax on import with custom settings.

// This is using an XMLHttpRequest to fetch the js and execute it with window.eval.
// Since synchronous XMLHttpRequests in the main thread are deprecated, this is a bit hacky.
// We use a asynchronous request and in the listener we resolve a promise which we wait for.
await new Promise((resolve) => {
    window.MathJax = {
        startup: {
            typeset: false,
        },
        options: {
            enableMenu: false,
        },
        chtml: {
            fontURL: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2',
        },
    }

    const req = new XMLHttpRequest()
    req.open('GET', 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js')
    req.addEventListener('load', () => {
        // This stops styles for the (disabled) context menu from being loaded.
        // const code = req.responseText.replace(',y.CssStyles.addInfoStyles(this.document.document),y.CssStyles.addMenuStyles(this.document.document)', '')
        const code = req.responseText
        // Run the java script.
        window.eval(code)

        // Associate a function with MathJax that resets all state.
        window.MathJax.reset = () => {
            window.MathJax.typesetClear()
            window.MathJax.texReset()
            window.MathJax.startup.output.clearCache()
        }

        // Associate a function with MathJax that sets the css.
        window.MathJax.set_css = (id) => {
            let sheet = document.getElementById(id)
            if (sheet)
                sheet.remove()
            let css = window.MathJax.chtmlStylesheet()
            css.id = id
            // Remove some annoying css that gives me warnings.
            // css.innerText = css.innerText.replace(
            // '\n_::-webkit-full-page-media, _:future, :root mjx-container {\n  will-change: opacity;\n}',
            // '')
            document.head.appendChild(css)
        }
        resolve()
    })
    req.send()
})
```

`www/obfuscate.js`:

```js
import { obfuscate, Width, Printer } from './wasm.js';

const btn = document.getElementById('obfuscate-btn')
const input = document.getElementById('input')
const output = document.getElementById('output')
const input_error = document.getElementById('input-error')
const output_type = document.getElementById('output-type')
const output_types = document.getElementsByName('output-type')

// Highlights inline code.
function hi_in(code) {
    return `<code class="language-c">${Prism.highlight(code, Prism.languages.c, 'c')}</code>`
}

// Part of the popover config supplying default values.
const popover_config = {
    trigger: 'hover',
    delay: { show: 500, hide: 100 },
    html: true,
    customClass: 'custom-popover',
}

// Popover for the input box.
new bootstrap.Popover(input, {
    ...popover_config,
    title: 'Expression that will be obfuscated',
    content:
`
Currently, the expression has to be a linear combination of boolean expressions.
Check 'What operations are allowed?' at the bottom of the page.
<br>
E.g. ${hi_in('3*(x & ~y) + 4*(x | y) - 2*~x')}.
<br>
This limitation will be removed in the future and more general expression will be allowed.
More commonly, you will probably want to use things like ${hi_in('x + y')}, ${hi_in('x - y')}.
<br>
Constants (${hi_in('1312')}) are also allowed.
`
})

// 'What is Mixed Boolean-Arithmetic?'
document.getElementById('acc-col-1').children[0].innerHTML =
`
Mixed Boolean-Arithmetic (MBA) is a name for expressions which contain both the usual arithmetic operations
(${hi_in('+')}, ${hi_in('-')}, ${hi_in('*')}, ${hi_in('/')})
as well as boolean operations (${hi_in('&')}, ${hi_in('|')}, ${hi_in('^')}, ${hi_in('~')}).
A simple example is the expression ${hi_in('2 * (x & y) + (x ^ y)')} that computes ${hi_in('x + y')}.
This particular one works for integers of any number of bits but generally they can be specific to
a certain size, such as the following one, that also computes ${hi_in('x + y')} but only for 8-bit integers:
<pre class="language-c" style="font-size: .875rem">${Prism.highlight('-38*(x & y) - 83*(x ^ y) - 64*~(x ^ (y ^ z))\n - 41*~x - 43*~y - 23*y - 44*z - 20*(y & z)\n - 21*(x | z) - 107*(~x & z) - 108*(y | ~z)', Prism.languages.c, 'c')}</pre>
`

// Setup handling for the output type dropdown.
for (const li of output_types) {
    li.onclick = (e) => {
        for (const li of output_types) {
            li.classList.remove('active')
        }
        e.target.classList.add('active')
        output_type.textContent = e.target.textContent
    }
}

// Do the obfuscation.
btn.onclick = () => {
    const expr = input.value

    const printer = Printer[output_type.innerText.trim()]

    // Get the number of bits we are obfuscating for.
    const bits = Width[document.querySelector('input[name=bitness]:checked').value]

    try {
        // Do the rewriting.
        const s = postprocess_code(obfuscate(expr, bits, printer))
        input.classList.remove('is-invalid')
        input_error.textContent = ''

        // Display the result.
        output.replaceChildren()
        if (printer == Printer.C) {
            const code = document.createElement('pre')
            code.classList.add('language-c')
            code.innerHTML = Prism.highlight(s, Prism.languages.c, 'c')
            output.appendChild(code)

            // Very hacky and requires the code to contain commas only for the arguments.
            const args = s.split(',').map(() => '0').join(', ')
            const ce_code = encodeURIComponent(`#include <cstdint>\n#include <iostream>\n\n${s}\n\nint main() {\n\tstd::cout << ${bits == Width.U8 ? '(uint32_t)' : ''}f(${args}) << "\\n";\n}`)
            const ce_btn = document.createElement('button')
            ce_btn.textContent = 'Open in Compiler Explorer'
            ce_btn.classList.add('btn', 'btn-secondary')
            ce_btn.onclick = () => {
                window.open(`https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'${ce_code}'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:clang_trunk,compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!(),options:'',source:1,stdinPanelShown:'1',tree:'1',wrap:'1'),l:'5',n:'0',o:'Executor+x86-64+clang+(trunk)+(C%2B%2B,+Editor+%231)',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4`)
            }
            output.appendChild(ce_btn)
        } else if (printer == Printer.Rust) {
            const code = document.createElement('pre')
            code.classList.add('language-rust')
            code.innerHTML = Prism.highlight(s, Prism.languages.rust, 'rust')
            output.appendChild(code)

            const pg_btn = document.createElement('button')
            pg_btn.textContent = 'Open in Rust Playground'
            pg_btn.classList.add('btn', 'btn-secondary')

            // Very hacky and requires the code to contain commas only for the arguments.
            const args = s.split(',').map(() => 'Wrapping(0)').join(', ')
            const pg_code = encodeURIComponent(`use std::num::Wrapping;\n\nfn main() {\n\tprintln!("{}", f(${args}));\n}\n\n${s}`)
            pg_btn.onclick = () => {
                window.open(`https://play.rust-lang.org/?version=stable&mode=release&edition=2021&code=${pg_code}`)
            }
            output.appendChild(pg_btn)
        }
        else {
            output.textContent = s
        }
    } catch (err) {
        input.classList.add('is-invalid')
        output.textContent = ''
        if (typeof err === 'string') {
            input_error.textContent = err
        } else {
            console.log(err)
            input_error.textContent = 'Unknown error. Check console.'
        }
    }
}

// Hide this ugly code down here.
function postprocess_code(code) {
    let s = ''
    let lines = code.split('\n')
    //s += lines[0]
    //s += '\n'
    //lines = lines.slice(1)
    for (let l of lines) {
        let tabs = 0
        for (; tabs < l.length && l[tabs] == '\t'; tabs++) {}
        l = l.substring(tabs)

        inner: for (let j = 0; ; j++) {
            let max = 68 - 4 * tabs;
            if (j == 0) {
                s += '\t'.repeat(tabs)
            } else {
                s += '\t'.repeat(tabs+1)
                max -= 4;
            }

            if (l.length >= max) {
                for (let i = max; i >= 0; i--) {
                    if (l[i] == ' ') {
                        s += l.substring(0, i)
                        s += '\n'
                        l = l.substring(i+1)
                        continue inner
                    }
                }
            }

            // If we never found a space then just put the whole string into the line anyways.
            s += l
            s += '\n'
            break
        }
    }

    return s
}
```

`www/perm_poly.html`:

```html
<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8" />
        <title>Binary Permutation Polynomials</title>
        <link rel="icon" href="data:,">
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
        <script type="module" src="perm_poly.js"></script>
    </head>
    <body>
        <div class="container p-3" style="width: 37.5%">
            <h2 class="mx-auto">Binary Permutation Polynomials</h2>
            <input id="input" type="text" class="form-control mx-auto mb-2" placeholder="Input polynomial">
            <div id="input-error" class="invalid-feedback"></div>
            <div class="row mb-3">
                <div class="col-sm-8">
                    <div class="mb-2 mt-2">
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="width" id="width-8" value="U8" checked>
                            <label class="form-check-label" for="width-8">8-bit</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="width" id="width-16" value="U16">
                            <label class="form-check-label" for="width-16">16-bit</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="width" id="width-32" value="U32">
                            <label class="form-check-label" for="width-32">32-bit</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="width" id="width-64" value="U64">
                            <label class="form-check-label" for="width-64">64-bit</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="width" id="width-128" value="U128">
                            <label class="form-check-label" for="width-128">128-bit</label>
                        </div>
                    </div>
                    <button id="invert-btn" type="button" class="btn btn-primary mb-3">Invert</button>
                </div>
                <div class="col-sm-4">
                    <button id="rand-poly" type="button" class="btn btn-primary">Random polynomial</button>
                    <div class="dropdown">
                        Algorithm
                        <button id="algorithm" class="btn btn-secondary dropdown-toggle w-100" type="button" data-bs-toggle="dropdown">
                            Newton
                        </button>
                        <ul class="dropdown-menu w-100">
                            <li><button name="algorithm" class="dropdown-item active" type="button">Newton</button></li>
                            <li><button name="algorithm" class="dropdown-item" type="button">Fermat</button></li>
                            <li><button name="algorithm" class="dropdown-item" type="button">Lagrange</button></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div id="output" style="overflow: scroll"></div>
        </div>
    </body>
</html>
```

`www/perm_poly.js`:

```js
import './mathjax.js'
import { Width, invert_poly, rand_poly } from './wasm.js'

//console.clear()

const input = document.getElementById('input')
const input_error = document.getElementById('input-error')
const invert_btn = document.getElementById('invert-btn')
const rand = document.getElementById('rand-poly')
const algorithm = document.getElementById('algorithm')
const algorithms = document.getElementsByName('algorithm')
const output = document.getElementById('output')

// Setup handling for the algorithm dropdown.
for (const li of algorithms) {
    li.onclick = (e) => {
        for (const li of algorithms) {
            li.classList.remove('active')
        }
        e.target.classList.add('active')
        algorithm.textContent = e.target.textContent
    }
}

rand.onclick = () => {
    const bits = Width[document.querySelector('input[name=width]:checked').value]
    const p = rand_poly(bits)
    input.value = p
}

invert_btn.onclick = () => {
    const poly = input.value
    const bits = Width[document.querySelector('input[name=width]:checked').value]
    const alg = algorithm.innerText.trim()
    try {
        input.classList.remove('is-invalid')
        input_error.textContent = ''
        const inverse = invert_poly(poly, bits, alg)
        MathJax.reset()
        output.replaceChildren()
        output.appendChild(MathJax.tex2chtml(inverse, { scale: 1.3 }))
        MathJax.set_css('mathjax-styles')
    } catch (err) {
        output.replaceChildren()
        if (typeof err === 'string') {
            input.classList.add('is-invalid')
            input_error.textContent = err
        } else {
            console.log(err);
            input.classList.add('is-invalid')
            input_error.textContent = 'Check console.'
        }
    }
}
```

`www/prism.css`:

```css
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
    background: #fbfbfb;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	font-size: 1em;
	margin: .5em 0;
	overflow: auto;
    border-left: 4px solid var(--bs-primary);
    padding-left: 1em;
    padding-top: 0.5em;
    padding-bottom: 0.5em;
    border-radius: 0.3em;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.token.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #9a6e3a;
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function,
.token.class-name {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
```

`www/wasm.js`:

```js
// Re-exports everything from the wasm (except the init function)
// but calls init on import.

import init from './mba_wasm.js'

await init()

export * from './mba_wasm.js'
```