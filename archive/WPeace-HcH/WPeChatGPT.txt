Project Path: arc_WPeace-HcH_WPeChatGPT_54frjarc

Source Tree:

```txt
arc_WPeace-HcH_WPeChatGPT_54frjarc
├── Auto-WPeGPT_WPeace
│   └── Auto_WPeGPT.py
├── IMG
│   ├── auto-wpegpt_menu.png
│   ├── autogptExample.gif
│   ├── menuInEdit.png
│   ├── menuInPseudocode.png
│   ├── resultExample.gif
│   ├── useExample.gif
│   └── vulnExample.gif
├── README.ZH_CN.md
├── README.md
├── WPeChatGPT.py
└── requirements.txt

```

`Auto-WPeGPT_WPeace/Auto_WPeGPT.py`:

```py
import os
import idc
import idaapi
import idautils
import re
import ida_name
from collections import defaultdict
from anytree import Node, RenderTree
import sys
sys.setrecursionlimit(500)


def makeDir():
    cwd = os.getcwd()
    idb_path = idc.get_idb_path()
    idb_name = os.path.basename(idb_path)
    idb_name = 'WPe_' + idb_name
    folder_path = os.path.join(cwd, idb_name) + '\\'
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)
        print("Auto-WPeGPT have created the dir:", '"' + folder_path + '"', ":)@WPeace")
    else:
        print("Auto-WPeGPT have found the dir:", '"' + folder_path + '"', ":)@WPeace")
    return folder_path

def getEffectiveStrings(fileDir):
    startAddr = idc.get_name_ea_simple("_start")
    if startAddr == 0xffffffff or startAddr == 0xffffffffffffffff:
        startAddr = idc.get_name_ea_simple("__start")
        if startAddr == 0xffffffff or startAddr == 0xffffffffffffffff:
            startAddr = idc.get_name_ea_simple("start")
    if startAddr == 0xffffffff or startAddr == 0xffffffffffffffff:
        startAddr = idc.get_segm_by_sel(idc.selector_by_name(".text"))
    if startAddr == 0xffffffff or startAddr == 0xffffffffffffffff:
        print("Get startAddress failed. @WPeace")
        return 0
    textStartAddr = idc.get_segm_start(startAddr)
    textEndAddr = idc.get_segm_end(startAddr)
    strList = []
    for s in idautils.Strings():
        if str(s) in strList:
            continue
        sysFlag = 0
        xrefCount = len(list(idautils.XrefsTo(s.ea)))
        if xrefCount != 0:
            for xref in idautils.XrefsTo(s.ea):
                strUseAddr = xref.frm
                funcName = idc.get_func_name(strUseAddr)
                funcAddr = idc.get_name_ea_simple(funcName)
                if textStartAddr < funcAddr < textEndAddr:
                    sysFlag = 0
                    break
                elif len(re.findall("^_.*", funcName)) != 0:
                    sysFlag = 1
                else:
                    func_ea = idc.get_name_ea_simple(funcName)
                    for xcaller in idautils.XrefsTo(func_ea):
                        callerFuncName = idc.get_func_name(xcaller.frm)
                        callerFuncAddr = idc.get_name_ea_simple(callerFuncName)
                        if textStartAddr < callerFuncAddr < textEndAddr:
                            sysFlag = 0
                            break
                        elif len(re.findall("^_.*", callerFuncName)) != 0:
                            sysFlag = 1
                        else:
                            sysFlag = 1
            if sysFlag == 0:
                string = str(s).replace('\n', '').replace('\r', '').replace('\a', '').replace('\t', '').replace(' ', '')
                if 0 < len(string) < 50:
                    strList.append(string)
    filename = fileDir + "effectiveStrings.txt"
    with open(filename, 'w') as fp:
        for line in strList:
            print(line, file=fp)
    print("EffectiveStrings results are output to the file...")

def printTargetNode(node, name, filename, indent=0, level_printed=None):
    if level_printed is None:
        level_printed = {0: set()}
    if node.name == name and node.name not in level_printed[indent]:
        with open(filename, 'a') as fp:
            print(' ' * indent + node.name, file=fp)
        level_printed[indent].add(node.name)
        if indent + 4 not in level_printed:
            level_printed[indent + 4] = set()
        for child in node.children:
            printTargetNode(child, child.name, filename, indent + 4, level_printed)
    else:
        for child in node.children:
            printTargetNode(child, name, filename, indent, level_printed)

class MyNode:
    def __init__(self, name):
        self.name = name
        self.parents = []
        self.children = []

# 通过递归获取调用树，结果全面但是只适用于函数较少时。
def createRecursionTree(data, fileDir):
    try:
        root = MyNode('WPeace-HcH')
        nodes = {}
        for key in data.keys():
            if key not in nodes:
                nodes[key] = MyNode(key)
                nodes[key].parents.append(root)
                root.children.append(nodes[key])
            for value in data[key]:
                if value not in nodes:
                    nodes[value] = MyNode(value)
                if value not in [child.name for child in nodes[key].children]:
                    nodes[value].parents.append(nodes[key])
                    nodes[key].children.append(nodes[value])
                    if nodes[value] in root.children:
                        root.children.remove(nodes[value])
        funcTree_filename = fileDir + "funcTree.txt"
        with open(funcTree_filename, 'w') as fp:
            for pre, fill, node in RenderTree(root):
                print("%s%s" % (pre, node.name), file=fp)
        mainFuncTree_filename = fileDir + "mainFuncTree.txt"
        with open(mainFuncTree_filename, 'w') as fp:
            pass
        # 尝试遍历找寻main函数或WinMain
        mainFuncName = "main"   #默认main函数为主函数
        for segea in idautils.Segments():
            for function_ea in idautils.Functions(segea, idc.get_segm_end(segea)):
                funcName = idc.get_func_name(function_ea)
                if "winmain" in funcName.lower():
                    mainFuncName = funcName
        printTargetNode(root, mainFuncName, mainFuncTree_filename)
        return 1
    except:
        return -1

# 通过Anytree Node获取调用树，适用范围广，在函数数量高时使用。
def createAnyTree(data, fileDir):
    root = Node('WPeace-HcH')
    nodes = {}
    for key in data.keys():
        if key in nodes:
            parent_node = nodes[key]
        else:
            parent_node = Node(key, parent=root)
            nodes[key] = parent_node
        for value in data[key]:
            if value in nodes and nodes[value].parent is None:
                child_node = nodes[value]
                child_node.parent = parent_node
            else:
                child_node = Node(value, parent=parent_node)
                nodes[value] = child_node
    funcTree_filename = fileDir + "funcTree.txt"
    with open(funcTree_filename, 'w') as fp:
        for pre, fill, node in RenderTree(root):
            print("%s%s" % (pre, node.name), file=fp)
    mainFuncTree_filename = fileDir + "mainFuncTree.txt"
    with open(mainFuncTree_filename, 'w') as fp:
        pass
    # 尝试遍历找寻main函数或WinMain
    mainFuncName = "main"   #默认main函数为主函数
    for segea in idautils.Segments():
        for function_ea in idautils.Functions(segea, idc.get_segm_end(segea)):
            funcName = idc.get_func_name(function_ea)
            if "winmain" in funcName.lower():
                mainFuncName = funcName
    printTargetNode(root, mainFuncName, mainFuncTree_filename)

def getCallRelation(outputFileDir):
    # 获取代码段相关函数
    startAddr = idc.get_name_ea_simple("_start")
    if startAddr == 0xffffffff or startAddr == 0xffffffffffffffff:
        startAddr = idc.get_name_ea_simple("__start")
        if startAddr == 0xffffffff or startAddr == 0xffffffffffffffff:
            startAddr = idc.get_name_ea_simple("start")
    if startAddr == 0xffffffff or startAddr == 0xffffffffffffffff:
        startAddr = idc.get_segm_by_sel(idc.selector_by_name(".text"))
    if startAddr == 0xffffffff or startAddr == 0xffffffffffffffff:
        print("Get startAddress failed. @WPeace")
        return 0
    # 列表funcDict存放重要函数
    funcDict = defaultdict(list)
    for function_ea in idautils.Functions(idc.get_segm_start(startAddr), idc.get_segm_end(startAddr)):
        funcName = idc.get_func_name(function_ea)
        if len(re.findall("^__.*", funcName)) != 0 or funcName == "syscall" or funcName == "start" or '@' in funcName or '?' in funcName:
            if "WinMain" not in funcName:
                continue
        for ref_ea in idautils.CodeRefsTo(function_ea, 0):
            callerFunc = idc.get_func_name(ref_ea)
            if (len(re.findall("^__.*", callerFunc)) == 0 and callerFunc != "" and '@' not in callerFunc and '?' not in callerFunc) or "WinMain" in callerFunc:
                funcDict[callerFunc].append(funcName)
    for callerFunc in funcDict:
        funcDict[callerFunc] = list(set(funcDict[callerFunc]))
    # 尝试利用idata段获取相关导入函数
    idataStartAddr = idc.get_segm_by_sel(idc.selector_by_name(".idata"))
    idataEndAddr = idc.get_segm_end(idataStartAddr)
    for api_ea in idautils.Heads(idataStartAddr, idataEndAddr):
        funcName = ida_name.get_name(api_ea)
        for api_ref_ea in idautils.CodeRefsTo(api_ea, 0):
            callerFunc = idc.get_func_name(api_ref_ea)
            if len(re.findall("^__.*", callerFunc)) == 0 and callerFunc != "" and '@' not in callerFunc and '?' not in callerFunc:
                if len(re.findall("^__.*", funcName)) == 0:
                    funcDict[callerFunc].append(funcName)
    # 尝试利用不同方式创建树结构
    recursion_result = createRecursionTree(funcDict, outputFileDir)
    if recursion_result == 1:
        print("FuncTree results by recursion are output to the file...")
    else:
        createAnyTree(funcDict, outputFileDir)
        print("FuncTree results by anytree are output to the file...")

def main():
    outputFileDir = makeDir()
    getCallRelation(outputFileDir)
    getEffectiveStrings(outputFileDir)


if __name__ == "__main__":
    main()

```

`README.ZH_CN.md`:

```md
# WPeChatGPT
- 基于与 ChatGPT 相同模型的**IDA 插件**，使用 OpenAI 发布的 gpt-3.5-turbo 模型，可以有助于分析师们快速分析二进制文件。

- 当前 *WPeChatGPT* 支持的**功能**包括：
   - 分析函数的使用环境、预期目的、函数功能。
   - 重命名函数的变量。
   - 尝试用 python3 对函数进行还原，此功能主要是针对较小块的函数（如一个异或解密函数）。
   - 在当前函数中查找是否存在漏洞。
   - 尝试用 python 对漏洞函数生成对应的 EXP。
   - 利用 GPT **全自动分析二进制文件**，具体参考节 ***Auto-WPeGPT***。
- *WPeChatGPT* 插件使用的是 OpenAI 基于GPT训练的 **text-davinci-003** 模型。  
  *v2.0* 版本后使用 OpenAI 最新的 **gpt-3.5-turbo** 模型（The same as **ChatGPT**）。  

ChatGPT 的分析结果**仅供参考**，不然我们这些分析师就当场失业了。XD  
## 更新历史
|Version|Date|Comment|
|----|----|----|
|1.0|2023-02-28|Based on Gepetto.|
|1.1|2023-03-02|1. 删除分析加解密的功能。<br>2. 增加 python 还原函数的功能。<br>3. 修改了一些细节。|
|1.2|2023-03-03|1. 增加查找函数中二进制漏洞的功能。<br>2. 增加尝试自动生成对应 EXP 的功能。<br>3. 修改了一些细节。<br>（由于OpenAI服务器卡顿原因未测试上传）|
|2.0|2023-03-06|1. 完成测试 *v1.2* 版本漏洞相关功能。<br>2. 改用 OpenAI 最新发布的 **gpt-3.5-turbo** 模型。|
|2.1|2023-03-07|修复 OpenAI-API 的 timed out 问题。（详见节***关于 OpenAI-API 报错***）|
|2.3|2023-04-23|添加 **Auto-WPeGPT v0.1**，支持对二进制文件的自动分析功能。<br>（从此版本需要添加包 *anytree*，使用 *requirements.txt* 或 *pip install anytree*）|
|2.4|2023-11-10|1. 修改了一些显示细节。<br>2. 更新 **Auto-WPeGPT v0.2**。|
|2.5|2024-08-07|1. 添加了对其他模型的支持。@tpsnt<br> - 通过修改 *MODEL* 变量，可以支持其他模型<br> - 设置环境变量 *OPENAI_API_BASE* 为 "https://dashscope.aliyuncs.com/compatible-mode/v1" ，将 *MODEL* 设置为 qwen-max、qwen-long、qwen-plus 等，可以使用灵积API<br> - 将插件进行复制并修改 *PLUGIN_NAME*，可以允许多个模型同时存在<br>2. 修改代码适配最新的 python openai 包。（需要使用pip更新你的openai包）|
|2.6|2025-02-17|添加对DeepSeek的支持，你需要将变量*PLUGIN_NAME*设置为"WPeChat-DeepSeek"，同时将你的API KEY填入*model_api_key*变量。<br>（默认为DeepSeek-V3模型，如果希望调用R1模型，修改变量 **MODEL** = *'deepseek-reasoner'* 即可）|
## 安装
1. 运行如下命令安装所需包。
```
pip install -r ./requirements.txt
```
2. 修改脚本 `WPeChatGPT.py`，添加 API key 到变量 ***openai.api_key***。
3. 复制脚本文件 `WPeChatGPT.py` 及文件夹 `Auto-WPeGPT_WPeace` 到 IDA 的 plugins 文件夹, 最后重启 IDA 后即可使用。  

**`! NOTE`**：需要把 **IDA 的环境**设置为 **python3**，WPeChatGPT *2.0* 版本后需要使用**最新的 OpenAI Python 包**。
## 使用方法
支持在 IDA 中使用**右键、菜单栏或快捷键**任一。
- 快捷键：  
  `函数分析 = "Ctrl-Alt-G"`  
  `重命名函数变量 = "Ctrl-Alt-R"`  
  `二进制漏洞查找 = "Ctrl-Alt-E"`  

- 伪代码窗口右键：

&emsp;&emsp;<img src="https://github.com/WPeace-HcH/WPeChatGPT/blob/main/IMG/menuInPseudocode.png" width="788"/>

- 菜单栏：Edit $\Rightarrow$ WPeChatGPT

&emsp;&emsp;<img src="https://github.com/WPeace-HcH/WPeChatGPT/blob/main/IMG/menuInEdit.png" width="360"/>

## 示例
使用方式：

&emsp;&emsp;<img src="https://github.com/WPeace-HcH/WPeChatGPT/blob/main/IMG/useExample.gif" width="790"/>

函数分析效果展示：

&emsp;&emsp;<img src="https://github.com/WPeace-HcH/WPeChatGPT/blob/main/IMG/resultExample.gif" width="790"/>

二进制漏洞查找效果展示：

&emsp;&emsp;<img src="https://github.com/WPeace-HcH/WPeChatGPT/blob/main/IMG/vulnExample.gif" width="790"/>

## Auto-WPeGPT
**更新历史：**
|Version|Date|Comment|
|----|----|----|
|0.1|2023-04-23|初始版本。|
|0.2|2023-11-10|1. 改进对有效字符串的识别。<br>2. 改进对函数调用树的分析。<br>3. 增添对导入函数的识别。|

**使用方法：** 在菜单栏找到 Auto-WPeGPT 后点击即可，输出完成提示后可在对应文件夹（*"WPe_+IDB名称"*）中找到分析结果。  
- 菜单栏：Edit $\Rightarrow$ WPeChatGPT $\Rightarrow$ Auto-WPeGPT

&emsp;&emsp;<img src="https://github.com/WPeace-HcH/WPeChatGPT/blob/main/IMG/auto-wpegpt_menu.png" width="788"/>

输出文件夹中的每个文件含义：
```
GPT-Result.txt -> Auto-WPeGPT 分析结果
funcTree.txt -> 函数调用树形结构
mainFuncTree.txt -> 主函数树结构
effectiveStrings.txt -> 二进制文件中的可疑字符串
```

**效果展示：** 

&emsp;&emsp;<img src="https://github.com/WPeace-HcH/WPeChatGPT/blob/main/IMG/autogptExample.gif" width="788"/>

经过测试，v0.1 版本对函数较少的文件分析效果较好，如遇函数量大的二进制文件，会产生 tokens 超出范围的问题，在下个版本中将想办法进行改进。

## 关于 OpenAI-API 报错
&emsp;&emsp;从 2023.3.2 开始我经常遇到 API 报错，开始以为是服务器不稳定的问题（因为在我这里时好时坏），但是由于有太多反馈说都遇到了相关错误，所以我先去了 OpenAI 查看 API Status 之后发现其运行情况良好，因此发现可能并不是我所想的服务器问题，于是进行了相关问题的搜索及调试，以下是我对 OpenAI API 连接问题的处理方法：  

&emsp;&emsp;首先前提，插件已经在**科学上网**的条件下运行。
- 在科学上网的条件下，如果发现插件多次尝试都无法正常连接 API，那么需要查询一下 python 的 urllib3 版本（1.26 版本存在代理问题）。
   - 可以使用如下命令对 urllib3 进行回退修复：
   ```
   pip uninstall urllib3
   pip install urllib3==1.25.11
   ```
- 插件支持指定正向或反向代理：
   - 把代理地址及端口信息填入 ***proxy*** 变量可实现正向代理：  
   ```
   # Set your forward-proxy if necessary. (e.g. Clash = http://127.0.0.1:7890)
   proxy = ""
   ```
   - 把反向URL信息填入 ***proxy_address*** 变量可实现反向代理：
   ```
   # Set reverse-proxy URL if you need. (e.g. Azure OpenAI)
   proxy_address = ""
   ```
## 联系我
如果使用插件时遇到问题或有任何疑问，欢迎留言或发送邮件联系我。
## 致谢
受到 *Gepetto* 的启发，该项目地址为：https://github.com/JusticeRage/Gepetto 。

```

`README.md`:

```md
**English | [中文](./README.ZH_CN.md)**  

# WPeChatGPT
- **IDA plugin** based on the same model as ChatGPT, using the gpt-3.5-turbo model released by OpenAI, can help analysts quickly analyze binary files.

- **Features** currently supported by *WPeChatGPT* include:
    - Analyze the usage environment, intended purpose, and function of the function.
    - Rename variables of functions.
    - Attempt to restore the function with python3, this function is mainly for functions of smaller blocks (such as an XOR decryption function).
    - Look for vulnerabilities in the current function.
    - Try to use python to generate the corresponding EXP for the vulnerable function.
    - Utilize GPT **Automatically analyze binary files**, see section ***Auto-WPeGPT*** for details.
- The *WPeChatGPT* plugin uses OpenAI's **text-davinci-003** model trained on GPT.
   After *v2.0* use OpenAI's latest **gpt-3.5-turbo** model (The same as **ChatGPT**).

ChatGPT's analysis results **for reference only**, otherwise we analysts would be out of work on the spot. XD
## Update History
|Version|Date|Comment|
|----|----|----|
|1.0|2023-02-28|Based on Gepetto.|
|1.1|2023-03-02|1. Delete the function of analyzing encryption and decryption. <br>2. Increase the function of python restore function. <br>3. Modified some details.|
|1.2|2023-03-03|1. Added the function of finding binary vulnerabilities in functions. <br>2. Increase the function of trying to automatically generate the corresponding EXP. <br>3. Modified some details. <br>(The upload was not tested due to the OpenAI server lag)|
|2.0|2023-03-06|1. Complete the testing of *v1.2* version vulnerability related functions. <br>2. Switch to the latest **gpt-3.5-turbo** model released by OpenAI.|
|2.1|2023-03-07|Fix the timed out issue of OpenAI-API. (See section ***About OpenAI-API Error Reporting***)|
|2.3|2023-04-23|Add the **Auto-WPeGPT v0.1** to support automatic analysis of binary files.<br>(Package *anytree* needs to be added from this version, use *requirements.txt* or *pip install anytree*)|
|2.4|2023-11-10|1. Changed some display details.<br>2. Update **Auto-WPeGPT v0.2**.|
|2.5|2024-08-07|1. Add support for other models, you can set this using the *MODEL* variable. @tpsnt<br>2. Support for the new version of the python openai package. (Need to update your openai package)|
|2.6|2025-02-17|Add support for DeepSeek, you need to set the variable *PLUGIN_NAME* to WPeChat-DeepSeek and fill the API KEY into variable *model_api_key*.<br>(The default model is DeepSeek-V3. If you want to use the R1 model, modify variable **MODEL** = *'deepseek-reasoner'*.)|
## Install
1. Run the following command to install the required packages.
```
pip install -r ./requirements.txt
```
2. Modify the script `WPeChatGPT.py`, add your API key to the variable ***openai.api_key***, change the variable ***ZH_CN*** to False. (Default Chinese)
3. Copy the script file `WPeChatGPT.py` and the folder `Auto-WPeGPT_WPeace` to the plugins folder of IDA, and finally restart IDA to use it.

**`! NOTE`**: You need to set the **IDA environment** to **python3**, and you need to use the **latest OpenAI Python package** after WPeChatGPT *2.0* version.
## Usage
Supports using any of the **right click, menu bar or shortcut keys** in IDA.
- hot key:  
  `Function analysis = "Ctrl-Alt-G"`  
  `Rename function variables = "Ctrl-Alt-R"`  
  `Vulnerability finding = "Ctrl-Alt-E"`  

- Right click on the pseudocode window:

&emsp;&emsp;<img src="https://github.com/WPeace-HcH/WPeChatGPT/blob/main/IMG/menuInPseudocode.png" width="788"/>

- Menu bar: Edit $\Rightarrow$ WPeChatGPT

&emsp;&emsp;<img src="https://github.com/WPeace-HcH/WPeChatGPT/blob/main/IMG/menuInEdit.png" width="360"/>

## Example
How to use:

&emsp;&emsp;<img src="https://github.com/WPeace-HcH/WPeChatGPT/blob/main/IMG/useExample.gif" width="790"/>

Function analysis effect display:

&emsp;&emsp;<img src="https://github.com/WPeace-HcH/WPeChatGPT/blob/main/IMG/resultExample.gif" width="790"/>

Vulnerability finding effect display:

&emsp;&emsp;<img src="https://github.com/WPeace-HcH/WPeChatGPT/blob/main/IMG/vulnExample.gif" width="790"/>

## Auto-WPeGPT
**Update History:**
|Version|Date|Comment|
|----|----|----|
|0.1|2023-04-23|Initial release.|
|0.2|2023-11-10|1. Improve the recognition of valid strings.<br>2. Improve the analysis of function call trees.<br>3. Add recognition for import functions.|

**How to use:** Find Auto-WPeGPT in the menu bar and click it. After the output is complete, you can find the analysis results in the corresponding folder (*"WPe_+IDB name"*).
- Menu bar: Edit $\Rightarrow$ WPeChatGPT $\Rightarrow$ Auto-WPeGPT

&emsp;&emsp;<img src="https://github.com/WPeace-HcH/WPeChatGPT/blob/main/IMG/auto-wpegpt_menu.png" width="788"/>

The meaning of each file in the output folder:
```
GPT-Result.txt -> Auto-WPeGPT analysis results
funcTree.txt -> function call tree structure
mainFuncTree.txt -> main function tree structure
effectiveStrings.txt -> Suspicious strings in the binary
```

**Show results:** 

&emsp;&emsp;<img src="https://github.com/WPeace-HcH/WPeChatGPT/blob/main/IMG/autogptExample.gif" width="788"/>

After testing, the v0.1 version has a better analysis effect on files with fewer functions. In case of binary files with a large number of functions, tokens will exceed the range. We will try to improve it in the next version.

## About OpenAI-API error reporting
&emsp;&emsp;From March 2, 2023, I often encounter API errors, and I thought it was a problem of server instability (because I have ups and downs here), but because there are too many feedbacks that I have encountered related errors, so I I first went to OpenAI to check the API Status and found that it was running well, so I found that it might not be the server problem I thought, so I searched and debugged related problems. The following is how I dealt with the OpenAI API connection problem:

&emsp;&emsp;First of all, the plugin has been running under the conditions of **Scientific Online**.
- Under the condition of scientific Internet access, if you find that the plug-in fails to connect to the API after many attempts, you need to check the urllib3 version of python (version 1.26 has a proxy problem).
    - You can use the following commands to perform a fallback fix for urllib3:
    ```
    pip uninstall urllib3
    pip install urllib3==1.25.11
    ```
- You can set forward or reverse proxies for the plugin:
    - Fill in the proxy address and port information into the ***proxy*** variable (forward-proxy):
    ```
    # Set your forward-proxy if necessary. (e.g. Clash = http://127.0.0.1:7890)
    proxy = ""
    ```
    - Fill in the reverse-proxy-url into the ***proxy_address*** variable (reverse-proxy):
    ```
    # Set reverse-proxy URL if you need. (e.g. Azure OpenAI)
    proxy_address = ""
    ```
## Contact me
If you encounter problems or have any questions when using the plugin, please leave a message or send me an email.
## Acknowledgment
The project is based on *Gepetto* and inspired by it, you can visit https://github.com/JusticeRage/Gepetto to learn about the original method.

```

`WPeChatGPT.py`:

```py
import functools
import idaapi
import ida_hexrays
import ida_kernwin
import idc
import openai
import re
import threading
import json
import httpx
import sys, os
# 使用新的google-genai库
from google import genai

# Windows
path = os.path.dirname(os.path.abspath(__file__)) + "\\Auto-WPeGPT_WPeace\\"
# MacOS
# path = os.path.dirname(os.path.abspath(__file__)) + "/Auto-WPeGPT_WPeace/"
sys.path.append(path)
import Auto_WPeGPT

# Whether to use Chinese explanation code.
ZH_CN = True

# Use ChatGPT
# PLUGIN_NAME = 'WPeChat-GPT'
# Use DeepSeek
# PLUGIN_NAME = 'WPeChat-DeepSeek'
# Use DeepSeek-DouYin
# PLUGIN_NAME="WPeChat-DeepSeek-DouYin"
# Use GPTAPI.US
# PLUGIN_NAME='WPeChat-GPTAPI-US'
# Use Gemini
PLUGIN_NAME = 'WPeChat-Gemini'

# Set your API key here, or put in in the model_api_key environment variable.
model_api_key = "ENTER_API_KEY_HERE"

# Set your forward-proxy if necessary. (e.g. Clash = http://127.0.0.1:7890 Clash Verge = http://127.0.0.1:7897)
proxy = ""
# Set reverse-proxy-URL or custom-api-URL if you need. (e.g. Azure OpenAI)
proxy_address = ""

# Plugin information, you can change the model here.
if PLUGIN_NAME == "WPeChat-GPT":
    PROD_NAME = 'ChatGPT'
    MODEL = 'gpt-4'
    print("WPeChatGPT is using ChatGPT.")

elif PLUGIN_NAME == "WPeChat-DeepSeek":
    PROD_NAME = 'DeepSeek'
    MODEL = 'deepseek-chat'
    print("WPeChatGPT is using DeepSeek")

elif PLUGIN_NAME == "WPeChat-DeepSeek-DouYin":
    PROD_NAME = 'DeepSeek-DouYin'
    MODEL = 'ep-20250220112658-w954b'
    print("WPeChatGPT is using DeepSeek-DouYin")

elif PLUGIN_NAME == "WPeChat-GPTAPI-US":
    PROD_NAME = 'GPTAPI-US'
    MODEL = 'deepseek-r1'
    print("WPeChatGPT is using GPTAPI-US")

elif PLUGIN_NAME == "WPeChat-Gemini":
    PROD_NAME = 'Gemini'
    MODEL = 'gemini-2.5-flash'  # 推荐使用flash版本，更稳定
    print("WPeChatGPT is using Gemini")

# Create openai client (python openai package version > 1.2)
if PROD_NAME == "DeepSeek":
    client = openai.OpenAI(base_url="https://api.deepseek.com", api_key=model_api_key)
elif PROD_NAME == "DeepSeek-DouYin":
    client = openai.OpenAI(base_url="https://ark.cn-beijing.volces.com/api/v3", api_key=model_api_key)
elif PROD_NAME == "GPTAPI-US":
    client = openai.OpenAI(base_url="https://api.gptapi.us/v1/chat/completions", api_key=model_api_key)
elif PROD_NAME == "Gemini":
    # 使用新的google-genai库配置
    client = genai.Client(api_key=model_api_key)
elif proxy:
    client = openai.OpenAI(
        http_client=httpx.Client(proxies=proxy, transport=httpx.HTTPTransport(local_address="0.0.0.0")),
        api_key=model_api_key)
    print("WPeChatGPT has appointed the forward-proxy.")
elif proxy_address:
    client = openai.OpenAI(base_url=proxy_address, api_key=model_api_key)
    print("WPeChatGPT has appointed the reverse-proxy.")
else:
    client = openai.OpenAI(api_key=model_api_key)


# WPeChatGPT 分析解释函数
class ExplainHandler(idaapi.action_handler_t):
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        funcComment = getFuncComment(idaapi.get_screen_ea())
        if "---WPeChat_START---" in funcComment:
            if ZH_CN:
                print("当前函数已经完成过 %s:Explain 分析，请查看注释或删除注释重新分析。@WPeace" % (PLUGIN_NAME))
            else:
                print(
                    "The current function has been analyzed by %s:Explain, please check the comment or delete the comment to re-analyze. @WPeace" % (
                        PLUGIN_NAME))
            return 0
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        # 中文
        if ZH_CN:
            query_model_async(
                "下面是一个C语言伪代码函数，分别分析该函数的预期目的、参数的作用、详细功能，最后取一个新的函数名字。（用简体中文回答我，并且回答开始前加上'---WPeChat_START---'字符串结束后加上'---WPeChat_END---'字符串）\n"
                + str(decompiler_output),
                functools.partial(comment_callback, address=idaapi.get_screen_ea(), view=v, cmtFlag=0, printFlag=0),
                0)
        # English
        else:
            query_model_async(
                "Analyze the following C language pseudo-code function, respectively speculate on the use environment, expected purpose, and detailed function of the function, and finally choose a new name for this function. (add '---WPeChat_START---' string before the beginning of the answer and add '---WPeChat_END---' string after the end)\n" + str(
                    decompiler_output),
                functools.partial(comment_callback, address=idaapi.get_screen_ea(), view=v, cmtFlag=0, printFlag=0), 0)
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# WPeChatGPT 重命名变量函数
class RenameHandler(idaapi.action_handler_t):
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        query_model_async("Analyze the following C function:\n" + str(decompiler_output) +
                          "\nSuggest better variable names, reply with a JSON array where keys are the original names"
                          "and values are the proposed names. Do not explain anything, only print the JSON "
                          "dictionary.",
                          functools.partial(rename_callback, address=idaapi.get_screen_ea(), view=v),
                          0)
        return 1

    # This action is always available.
    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# WPeChatGPT 使用python3对函数进行还原
class PythonHandler(idaapi.action_handler_t):
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        # lastAddr 为函数的最后一行汇编代码地址
        lastAddr = idc.prev_head(idc.get_func_attr(idaapi.get_screen_ea(), idc.FUNCATTR_END))
        # 获取对应注释
        addrComment = getAddrComment(lastAddr)
        if "---WPeChat_Python_START---" in str(addrComment):
            if ZH_CN:
                print("当前函数已经完成过 %s:Python 分析，请查看注释或删除注释重新分析。@WPeace" % (PLUGIN_NAME))
            else:
                print(
                    "The current function has been analyzed by %s:Python, please check the comment or delete the comment to re-analyze. @WPeace" % (
                        PLUGIN_NAME))
            return 0
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        # 中文
        if ZH_CN:
            query_model_async(
                "分析下面的C语言伪代码并用python3代码进行还原。（回答开始前加上'---WPeChat_Python_START---'字符串结束后加上'---WPeChat_Python_END---'字符串）\n"
                + str(decompiler_output),
                functools.partial(comment_callback, address=lastAddr, view=v, cmtFlag=1, printFlag=1),
                0)
        # English
        else:
            query_model_async(
                "Analyze the following C language pseudocode and restore it with python3 code. (Add '---WPeChat_Python_START---' string before the beginning of the answer and add '---WPeChat_Python_END---' string after the end)\n"
                + str(decompiler_output),
                functools.partial(comment_callback, address=lastAddr, view=v, cmtFlag=1, printFlag=1),
                0)
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# WPeChatGPT 尝试寻找函数漏洞
class FindVulnHandler(idaapi.action_handler_t):
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        funcComment = getFuncComment(idaapi.get_screen_ea())
        if "---WPeChat_VulnFinder_START---" in funcComment:
            if ZH_CN:
                print("当前函数已经完成过 %s:VulnFinder 分析，请查看注释或删除注释重新分析。@WPeace" % (PLUGIN_NAME))
            else:
                print(
                    "The current function has been analyzed by %s:VulnFinder, please check the comment or delete the comment to re-analyze. @WPeace" % (
                        PLUGIN_NAME))
            return 0
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        # 中文
        if ZH_CN:
            query_model_async(
                "查找下面这个C语言伪代码函数的漏洞并提出可能的利用方法。（用简体中文回答我，并且回答开始前加上'---WPeChat_VulnFinder_START---'字符串结束后加上'---WPeChat_VulnFinder_END---'字符串）\n"
                + str(decompiler_output),
                functools.partial(comment_callback, address=idaapi.get_screen_ea(), view=v, cmtFlag=0, printFlag=2),
                0)
        # English
        else:
            query_model_async(
                "Find the following C function vulnerabilty and suggest a possible way to exploit it.(Use English to answer me, and answer before plus '---WPeChat_VulnFinder_START---' the end of the string plus '---WPeChat_VulnFinder_END---' string)\n"
                + str(decompiler_output),
                functools.partial(comment_callback, address=idaapi.get_screen_ea(), view=v, cmtFlag=0, printFlag=2),
                0)
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


# WPeChatGPT 尝试对漏洞函数生成EXP
class expCreateHandler(idaapi.action_handler_t):
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        funcComment = getFuncComment(idaapi.get_screen_ea())
        if "---WPeChat_VulnPython_START---" in funcComment:
            if ZH_CN:
                print("当前函数已经完成过 %s:ExpCreater 分析，请查看注释或删除注释重新分析。@WPeace" % (PLUGIN_NAME))
            else:
                print(
                    "The current function has been analyzed by %s:ExpCreater, please check the comment or delete the comment to re-analyze. @WPeace" % (
                        PLUGIN_NAME))
            return 0
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        # 中文
        if ZH_CN:
            query_model_async(
                "使用Python构造代码来利用下面函数中的漏洞。（用简体中文回答我，并且回答开始前加上'---WPeChat_VulnPython_START---'字符串结束后加上'---WPeChat_VulnPython_END---'字符串）\n"
                + str(decompiler_output),
                functools.partial(comment_callback, address=idaapi.get_screen_ea(), view=v, cmtFlag=0, printFlag=3),
                0)
        # English
        else:
            query_model_async(
                "Use Python to construct code to exploit the vulnerabilities in the following functions.(Answer before plus '---WPeChat_VulnPython_START---' the end of the string plus '---WPeChat_VulnPython_END---' string)\n"
                + str(decompiler_output),
                functools.partial(comment_callback, address=idaapi.get_screen_ea(), view=v, cmtFlag=0, printFlag=3),
                0)
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


def autoChatFunc(funcTree: str, strings: str, callback):
    messages = []
    input_funcTree = funcTree
    messages.append({"role": "user", "content": input_funcTree})
    input_strings = strings
    messages.append({"role": "user", "content": input_strings})
    if ZH_CN:
        messages.append({"role": "user", "content": "结合该程序的函数调用结构及其所包含的字符串，猜测其运行目的及功能。"})
        messages.append({"role": "user", "content": "请再仔细分析后告诉我该程序的运行目的及大概功能。"})
    else:
        messages.append({"role": "user",
                         "content": "Combining the function call structure of the program and the strings it contains, guess its purpose and function."})
        messages.append({"role": "user",
                         "content": "Please tell me the purpose and general function of the program after careful analysis."})
    t = threading.Thread(target=chat_api_worker, args=(messages, MODEL, callback))
    t.start()


def chat_api_worker(messages, model, callback):
    try:
        if PROD_NAME == "Gemini":
            # 将messages转换为单个prompt
            prompt = "\n".join([msg["content"] for msg in messages if msg["role"] == "user"])
            response = client.models.generate_content(
                model=model,
                contents=prompt
            )

            # 安全地处理响应
            if response.candidates and len(response.candidates) > 0:
                candidate = response.candidates[0]
                if candidate.content and candidate.content.parts:
                    # 创建兼容的响应对象
                    class GeminiResponse:
                        def __init__(self, text):
                            self.choices = [
                                type('obj', (object,), {'message': type('obj', (object,), {'content': text})})()]

                    callback(GeminiResponse(response.text))
                else:
                    print(f"Gemini响应被安全过滤器阻止，finish_reason: {candidate.finish_reason}")
                    return 0
            else:
                print("Gemini API没有返回有效的候选响应")
                return 0
        else:
            response = client.chat.completions.create(messages=messages, model=model)
            callback(response)
    except Exception as e:
        if "maximum context length" in str(e) or "context_length_exceeded" in str(e):
            print("此二进制文件的分析数据超过了API的最大长度！请期待后续版本 :)@WPeace")
            return 0
        elif "Cannot connect to proxy" in str(e):
            print("代理出现问题，请稍后重试或检查代理。@WPeace")
            return 0
        elif "SAFETY" in str(e).upper():
            print("Gemini安全过滤器阻止了请求，请尝试修改提示词。@WPeace")
            return 0
        else:
            print(f"General exception encountered while running the query: {str(e)}")
            return 0
    callback(response)


def handle_response(autoGptfolder, response):
    message = response.choices[0].message
    if ZH_CN:
        print("GPT 分析完毕，已将结果输出到文件夹：" + autoGptfolder + " 当中！")
    else:
        print("The GPT analysis is complete and the result has been output to the folder: " + autoGptfolder)
    fp = open(autoGptfolder + "GPT-Result.txt", "w")
    fp.write(message.content)
    fp.close()
    print("Auto-WPeGPT finished! :)@WPeace\n")


# Auto-WPeGPT 自动化分析
class autoHandler(idaapi.action_handler_t):
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        Auto_WPeGPT.main()
        idb_path = idc.get_idb_path()
        idb_name = 'WPe_' + os.path.basename(idb_path)
        autoGptfolder = os.path.join(os.getcwd(), idb_name) + '\\'
        functreeFilepath = autoGptfolder + "funcTree.txt"
        mainFunctreeFilepath = autoGptfolder + "mainFuncTree.txt"
        stringsFilepath = autoGptfolder + "effectiveStrings.txt"
        file = open(functreeFilepath, "r")
        functreeData = file.read()
        file.close()
        file = open(mainFunctreeFilepath, "r")
        mainFunctreeData = file.read()
        file.close()
        file = open(stringsFilepath, "r")
        stringsData = file.read()
        file.close()
        funcNumber = idaapi.get_func_qty()
        print("There are %d functions in total in this binary file." % funcNumber)
        if funcNumber < 150:
            callback_autogpt = functools.partial(handle_response, autoGptfolder)
            autoChatFunc(functreeData, stringsData, callback_autogpt)
        else:
            callback_autogpt = functools.partial(handle_response, autoGptfolder)
            autoChatFunc(mainFunctreeData, stringsData, callback_autogpt)
        print("Auto-WPeGPT v0.2 start to analysis...")
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


def query_model(query, cb, max_tokens=2500):
    """
    向AI模型发送查询的函数。
    :param query: The request to send to AI model
    :param cb: Tu function to which the response will be passed to.
    """
    try:
        if PROD_NAME == "Gemini":
            # 使用新的google-genai库API调用
            response = client.models.generate_content(
                model=MODEL,
                contents=query
            )
            # 安全地获取响应文本
            if response.candidates and len(response.candidates) > 0:
                candidate = response.candidates[0]
                if candidate.content and candidate.content.parts:
                    response_text = response.text
                    ida_kernwin.execute_sync(functools.partial(cb, response=response_text), ida_kernwin.MFF_WRITE)
                else:
                    # 处理被安全过滤器阻止的情况
                    error_msg = f"Gemini响应被安全过滤器阻止，finish_reason: {candidate.finish_reason}"
                    print(error_msg)
                    ida_kernwin.execute_sync(functools.partial(cb, response=error_msg), ida_kernwin.MFF_WRITE)
            else:
                print("Gemini API没有返回有效的候选响应")
        else:
            # OpenAI兼容API调用
            response = client.chat.completions.create(
                model=MODEL,
                messages=[
                    {"role": "user", "content": query}
                ]
            )
            ida_kernwin.execute_sync(functools.partial(cb, response=response.choices[0].message.content),
                                     ida_kernwin.MFF_WRITE)
    except Exception as e:
        if "maximum context length" in str(e) or "context_length_exceeded" in str(e):
            print(f"{PLUGIN_NAME}-Warning: Context length too long! @WPeace")
        elif "Cannot connect to proxy" in str(e):
            print("代理出现问题，请稍后重试或检查代理。@WPeace")
        elif "quota" in str(e).lower() or "rate" in str(e).lower():
            print(e)
            print(f"{PROD_NAME}-{MODEL} API 配额不足或请求过于频繁，请稍后重试。@WPeace")
        elif "SAFETY" in str(e).upper():
            print(f"Gemini安全过滤器阻止了请求，请尝试修改提示词。@WPeace")
        else:
            print(f"General exception encountered while running the query: {str(e)}")


# Gepetto query_model_async Method
def query_model_async(query, cb, time):
    """
    创建线程调用 query_model 函数。
    :param query: The request to send to gpt-3.5-turbo
    :param cb: Tu function to which the response will be passed to.
    :param time: whether it is a retry.
    """
    if time == 0:
        if ZH_CN:
            print(f"正在发送 {PROD_NAME}:{MODEL} API 请求，完成后将输出提示。@WPeace")
        else:
            print(f"Sending {PROD_NAME}-{MODEL} API request, will output a prompt when completed. @WPeace")
        print("Request to %s sent..." % (MODEL))
    else:
        if ZH_CN:
            print(f"正在重新发送 {PROD_NAME}-{MODEL} API 请求。@WPeace")
        else:
            print(f"Resending {PROD_NAME}-{MODEL} API request. @WPeace")
    t = threading.Thread(target=query_model, args=[query, cb])
    t.start()


# Gepetto comment_callback Method
def comment_callback(address, view, response, cmtFlag, printFlag):
    """
    在对应地址处设置注释的回调函数。
    :param address: The address of the function to comment
    :param view: A handle to the decompiler window
    :param response: The comment to add
    """
    # Add the response as a comment in IDA.
    # 通过参数控制不同形式添加注释
    if cmtFlag == 0:
        idc.set_func_cmt(address, response, 0)
    elif cmtFlag == 1:
        idc.set_cmt(address, response, 1)
    # Refresh the window so the comment is displayed properly
    if view:
        view.refresh_view(False)
    print("%s query finished!" % (MODEL))
    if printFlag == 0:
        if ZH_CN:
            print("%s:Explain 完成分析，已对函数 %s 进行注释。@WPeace" % (PLUGIN_NAME, idc.get_func_name(address)))
        else:
            print("%s:Explain finished analyzing, function %s has been commented. @WPeace" % (PLUGIN_NAME,
                                                                                              idc.get_func_name(
                                                                                                  address)))
    elif printFlag == 1:
        if ZH_CN:
            print("%s:Python 完成分析，已在函数末尾地址 %s 汇编处进行注释。@WPeace" % (PLUGIN_NAME, hex(address)))
        else:
            print("%s:Python finished parsing, commented at assembly at address %s at end of function. @WPeace" % (
                PLUGIN_NAME, hex(address)))
    elif printFlag == 2:
        if ZH_CN:
            print("%s:VulnFinder 完成分析，已对函数 %s 进行注释。@WPeace" % (PLUGIN_NAME, idc.get_func_name(address)))
        else:
            print("%s: VulnFinder finished analyzing, function %s has been annotated. @WPeace" % (PLUGIN_NAME,
                                                                                                  idc.get_func_name(
                                                                                                      address)))
    elif printFlag == 3:
        if ZH_CN:
            print("%s:ExpCreater 完成分析，已对函数 %s 进行注释。@WPeace" % (PLUGIN_NAME, idc.get_func_name(address)))
        else:
            print("%s:ExpCreater finished analyzing, commented on function %s. @WPeace" % (PLUGIN_NAME,
                                                                                           idc.get_func_name(address)))


# Gepetto rename_callback Method
def rename_callback(address, view, response, retries=0):
    """
    重命名函数变量的回调函数。
    :param address: The address of the function to work on
    :param view: A handle to the decompiler window
    :param response: The response from gpt-3.5-turbo
    :param retries: The number of times that we received invalid JSON
    """
    j = re.search(r"\{[^}]*?\}", response)
    if not j:
        if retries >= 3:  # Give up obtaining the JSON after 3 times.
            print(f"{PROD_NAME}-{MODEL} API has no valid response, please try again later. @WPeace")
            return
        print(f"Cannot extract valid JSON from the response. Asking the model to fix it...")
        query_model_async("The JSON document provided in this response is invalid. Can you fix it?\n" + response,
                          functools.partial(rename_callback,
                                            address=address,
                                            view=view,
                                            retries=retries + 1),
                          1)
        return
    try:
        names = json.loads(j.group(0))
    except json.decoder.JSONDecodeError:
        if retries >= 3:  # Give up fixing the JSON after 3 times.
            print(f"{PROD_NAME}-{MODEL} API has no valid response, please try again later. @WPeace")
            return
        print(f"The JSON document returned is invalid. Asking the model to fix it...")
        query_model_async("Please fix the following JSON document:\n" + j.group(0),
                          functools.partial(rename_callback,
                                            address=address,
                                            view=view,
                                            retries=retries + 1),
                          1)
        return
    # The rename function needs the start address of the function
    function_addr = idaapi.get_func(address).start_ea
    replaced = []
    for n in names:
        if ida_hexrays.rename_lvar(function_addr, n, names[n]):
            replaced.append(n)

    # Update possible names left in the function comment
    comment = idc.get_func_cmt(address, 0)
    if comment and len(replaced) > 0:
        for n in replaced:
            comment = re.sub(r'\b%s\b' % n, names[n], comment)
        idc.set_func_cmt(address, comment, 0)
    # Refresh the window to show the new names
    if view:
        view.refresh_view(True)
    print("%s query finished!" % (MODEL))
    if ZH_CN:
        print(f"{PLUGIN_NAME}:RenameVariable 完成分析，已重命名{len(replaced)}个变量。@WPeace")
    else:
        print(f"{PLUGIN_NAME}:RenameVariable Completed analysis, renamed {len(replaced)} variables. @WPeace")


# 获取函数注释
def getFuncComment(address):
    cmt = idc.get_func_cmt(address, 0)
    if not cmt:
        cmt = idc.get_func_cmt(address, 1)
    return cmt


# 获取地址注释
def getAddrComment(address):
    cmt = idc.get_cmt(address, 0)
    if not cmt:
        cmt = idc.get_cmt(address, 1)
    return cmt


# Add context menu actions
class ContextMenuHooks(idaapi.UI_Hooks):
    def finish_populating_widget_popup(self, form, popup):
        idaapi.attach_action_to_popup(form, popup, myplugin_WPeChatGPT.explain_action_name, "%s/" % (PLUGIN_NAME))
        idaapi.attach_action_to_popup(form, popup, myplugin_WPeChatGPT.rename_action_name, "%s/" % (PLUGIN_NAME))
        idaapi.attach_action_to_popup(form, popup, myplugin_WPeChatGPT.python_action_name, "%s/" % (PLUGIN_NAME))
        idaapi.attach_action_to_popup(form, popup, myplugin_WPeChatGPT.vulnFinder_action_name, "%s/" % (PLUGIN_NAME))
        idaapi.attach_action_to_popup(form, popup, myplugin_WPeChatGPT.expPython_action_name, "%s/" % (PLUGIN_NAME))


class myplugin_WPeChatGPT(idaapi.plugin_t):
    autoWPeGPT_action_name = "%s:Auto-WPeGPT" % (PLUGIN_NAME)
    autoWPeGPT_menu_path = "Edit/%s/Auto-WPeGPT/Auto-WPeGPT v0.2" % (PLUGIN_NAME)
    explain_action_name = "%s:Explain_Function" % (PLUGIN_NAME)
    explain_menu_path = "Edit/%s/函数分析" % (PLUGIN_NAME)
    rename_action_name = "%s:Rename_Function" % (PLUGIN_NAME)
    rename_menu_path = "Edit/%s/重命名函数变量" % (PLUGIN_NAME)
    python_action_name = "%s:Python_Function" % (PLUGIN_NAME)
    python_menu_path = "Edit/%s/Python还原此函数" % (PLUGIN_NAME)
    vulnFinder_action_name = "%s:VulnFinder_Function" % (PLUGIN_NAME)
    vulnFinder_menu_path = "Edit/%s/二进制漏洞查找" % (PLUGIN_NAME)
    expPython_action_name = "%s:VulnPython_Function" % (PLUGIN_NAME)
    expPython_menu_path = "Edit/%s/尝试生成Exploit" % (PLUGIN_NAME)
    wanted_name = PLUGIN_NAME
    wanted_hotkey = ''
    comment = "%s Plugin for IDA" % (PLUGIN_NAME)
    help = "Find more information at https://github.com/wpeace-hch"
    menu = None
    flags = 0

    def init(self):
        # Check whether the decompiler is available
        if not ida_hexrays.init_hexrays_plugin():
            return idaapi.PLUGIN_SKIP
        if ZH_CN:
            # create Auto-WPeGPT action
            autoWPeGPT_action = idaapi.action_desc_t(self.autoWPeGPT_action_name,
                                                     '二进制文件自动化分析 v0.2',
                                                     autoHandler(),
                                                     "",
                                                     "使用 %s 对二进制文件进行自动化分析" % (MODEL),
                                                     199)
            idaapi.register_action(autoWPeGPT_action)
            idaapi.attach_action_to_menu(self.autoWPeGPT_menu_path, self.autoWPeGPT_action_name, idaapi.SETMENU_APP)
            # Function explaining action
            explain_action = idaapi.action_desc_t(self.explain_action_name,
                                                  '函数分析',
                                                  ExplainHandler(),
                                                  "Ctrl+Alt+G",
                                                  "使用 %s 分析当前函数" % (MODEL),
                                                  199)
            idaapi.register_action(explain_action)
            idaapi.attach_action_to_menu(self.explain_menu_path, self.explain_action_name, idaapi.SETMENU_APP)
            # Variable renaming action
            rename_action = idaapi.action_desc_t(self.rename_action_name,
                                                 '重命名函数变量',
                                                 RenameHandler(),
                                                 "Ctrl+Alt+R",
                                                 "使用 %s 重命名当前函数的变量" % (MODEL),
                                                 199)
            idaapi.register_action(rename_action)
            idaapi.attach_action_to_menu(self.rename_menu_path, self.rename_action_name, idaapi.SETMENU_APP)
            # python function action
            python_action = idaapi.action_desc_t(self.python_action_name,
                                                 'Python还原此函数',
                                                 PythonHandler(),
                                                 "",
                                                 "使用 %s 分析当前函数并用python3还原" % (MODEL),
                                                 199)
            idaapi.register_action(python_action)
            idaapi.attach_action_to_menu(self.python_menu_path, self.python_action_name, idaapi.SETMENU_APP)
            # find vulnerabilty action
            vulnFinder_action = idaapi.action_desc_t(self.vulnFinder_action_name,
                                                     '二进制漏洞查找',
                                                     FindVulnHandler(),
                                                     "Ctrl+Alt+E",
                                                     "使用 %s 在当前函数中查找漏洞" % (MODEL),
                                                     199)
            idaapi.register_action(vulnFinder_action)
            idaapi.attach_action_to_menu(self.vulnFinder_menu_path, self.vulnFinder_action_name, idaapi.SETMENU_APP)
            # create exploit action
            expPython_action = idaapi.action_desc_t(self.expPython_action_name,
                                                    '尝试生成Exploit',
                                                    expCreateHandler(),
                                                    "",
                                                    "使用 %s 尝试对漏洞函数生成EXP" % (MODEL),
                                                    199)
            idaapi.register_action(expPython_action)
            idaapi.attach_action_to_menu(self.expPython_menu_path, self.expPython_action_name, idaapi.SETMENU_APP)
            # Register context menu actions
            self.menu = ContextMenuHooks()
            self.menu.hook()
            print("Auto-WPeGPT v0.2 is ready.")
            print("%s v2.6 works fine! :)@WPeace\n" % (PLUGIN_NAME))
        else:
            # create Auto-WPeGPT action
            autoWPeGPT_action = idaapi.action_desc_t(self.autoWPeGPT_action_name,
                                                     'Automated analysis v0.2',
                                                     autoHandler(),
                                                     "",
                                                     "使用 %s 对二进制文件进行自动化分析" % (MODEL),
                                                     199)
            idaapi.register_action(autoWPeGPT_action)
            idaapi.attach_action_to_menu(self.autoWPeGPT_menu_path, self.autoWPeGPT_action_name, idaapi.SETMENU_APP)
            # Function explaining action
            explain_action = idaapi.action_desc_t(self.explain_action_name,
                                                  'Function analysis',
                                                  ExplainHandler(),
                                                  "Ctrl+Alt+G",
                                                  "使用 %s 分析当前函数" % (MODEL),
                                                  199)
            idaapi.register_action(explain_action)
            idaapi.attach_action_to_menu(self.explain_menu_path, self.explain_action_name, idaapi.SETMENU_APP)
            # Variable renaming action
            rename_action = idaapi.action_desc_t(self.rename_action_name,
                                                 'Rename function variables',
                                                 RenameHandler(),
                                                 "Ctrl+Alt+R",
                                                 "使用 %s 重命名当前函数的变量" % (MODEL),
                                                 199)
            idaapi.register_action(rename_action)
            idaapi.attach_action_to_menu(self.rename_menu_path, self.rename_action_name, idaapi.SETMENU_APP)
            # python function action
            python_action = idaapi.action_desc_t(self.python_action_name,
                                                 'Python restores this function',
                                                 PythonHandler(),
                                                 "",
                                                 "使用 %s 分析当前函数并用python3还原" % (MODEL),
                                                 199)
            idaapi.register_action(python_action)
            idaapi.attach_action_to_menu(self.python_menu_path, self.python_action_name, idaapi.SETMENU_APP)
            # find vulnerabilty action
            vulnFinder_action = idaapi.action_desc_t(self.vulnFinder_action_name,
                                                     'Vulnerability finding',
                                                     FindVulnHandler(),
                                                     "Ctrl+Alt+E",
                                                     "使用 %s 在当前函数中查找漏洞" % (MODEL),
                                                     199)
            idaapi.register_action(vulnFinder_action)
            idaapi.attach_action_to_menu(self.vulnFinder_menu_path, self.vulnFinder_action_name, idaapi.SETMENU_APP)
            # create exploit action
            expPython_action = idaapi.action_desc_t(self.expPython_action_name,
                                                    'Try to generate Exploit',
                                                    expCreateHandler(),
                                                    "",
                                                    "使用 %s 尝试对漏洞函数生成EXP" % (MODEL),
                                                    199)
            idaapi.register_action(expPython_action)
            idaapi.attach_action_to_menu(self.expPython_menu_path, self.expPython_action_name, idaapi.SETMENU_APP)
            # Register context menu actions
            self.menu = ContextMenuHooks()
            self.menu.hook()
            print("Auto-WPeGPT v0.2 is ready.")
            print("%s v2.6 works fine! :)@WPeace\n" % (PLUGIN_NAME))
        return idaapi.PLUGIN_KEEP

    def run(self, arg):
        pass

    def term(self):
        idaapi.detach_action_from_menu(self.autoWPeGPT_menu_path, self.autoWPeGPT_action_name)
        idaapi.detach_action_from_menu(self.explain_menu_path, self.explain_action_name)
        idaapi.detach_action_from_menu(self.rename_menu_path, self.rename_action_name)
        idaapi.detach_action_from_menu(self.python_menu_path, self.python_action_name)
        idaapi.detach_action_from_menu(self.vulnFinder_menu_path, self.vulnFinder_action_name)
        idaapi.detach_action_from_menu(self.expPython_menu_path, self.expPython_action_name)
        if self.menu:
            self.menu.unhook()
        return


def PLUGIN_ENTRY():
    global model_api_key
    if model_api_key == "ENTER_API_KEY_HERE":
        model_api_key = os.getenv("model_api_key")
        if not model_api_key:
            print("未找到 API_KEY，请在脚本中填写 model_api_key! :(@WPeace")
            raise ValueError("No valid OpenAI API key found!")
    return type(f"myplugin_{PLUGIN_NAME}", (myplugin_WPeChatGPT,), dict())()
```

`requirements.txt`:

```txt
openai >= 0.27.0
anytree
httpx
google-genai

```