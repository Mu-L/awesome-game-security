Project Path: arc_za233_IDADeflat_38liktt5

Source Tree:

```txt
arc_za233_IDADeflat_38liktt5
├── README.md
├── idadeflat.py
└── idadeflat_cores
    ├── angr_core.py
    └── core_base.py

```

`README.md`:

```md
# IDADeflat
- 一个半自动化去除控制流平坦化混淆的插件
- 如果不了解真实块是什么，建议了解后再使用本插件
## 使用方式
- 1.下载后直接放入IDA Pro的plugins文件夹中
- 2.在菜单Edit/Plugins/IDADeflat启动插件
- 3.启动插件后，在反编译窗口即可右键找到对应插件菜单
- 4.选定需要去平坦化的函数，选定或者导入识别的基本块后，选择Deflat GOGOGO开始去平坦化。
- 5.能够通过读取相同目录下的blocks.json文件导入真实基本块的数据。

## 插件原理
- 插件能够进行修改和扩展，编写对应的处理Core。
- 用户选定的各种数据将传递给Core处理，Core将调用process进行具体处理。
- Core的process函数接收函数地址，以及选定的真实基本块列表进行处理。
- 目前仅编写了默认处理模块AngrCore，使用angr符号执行来获取基本块之间的关系，并进行Patch。
- 采用了收集基本块代码，反编译后再重新编译的方式进行Patch，可能会导致一些不可控的问题。

## 注意事项
- 默认模块AngrCore针对变种控制流平坦化效果较差，Patch出的代码容易出现问题，且条件跳转的条件可能会反转，因此不可运行。
- 后续考虑实现更多的Cores(例如基于动调Trace的)，但是Patch和判断条件识别依旧是一个问题。
- 下一步(可能)：考虑基于Angr的AIL实现真实基本块的识别，当然这个功能不包括在本插件中，但可用于生成blocks.json用于导入，配合本插件就不用繁琐的自己去寻找基本块了。

```

`idadeflat.py`:

```py
import idaapi
import idc
import json
from idadeflat_cores.core_base import DeflatCore
from idadeflat_cores.angr_core import AngrDeflatCore
ADD_BLOCK_ACTION = ('IDADeflat:add_block', 'Add Relevant Block', 'add_working_blocks')
SET_ENTRY_ACTION = ('IDADeflat:set_entry', 'Set Function Entry', 'set_entry_block')
DO_DEFLAT_ACTION = ('IDADeflat:do_deflat', 'Deflat GOGOGO', 'do_deflat')
RESET_ACTION = ('IDADeflat:reset', 'Reset Plugin State', 'reset_state')
SHOW_BLOCK_ACTION = ('IDADeflat:show', 'Show State Info', 'show_state')
REMOVE_BLOCK_ACTION = ('IDADeflat:del_block', 'Delete Relevant Block', 'del_working_blocks')
IMPORT_BLOCK_ACTION = ('IDADeflat:import_block', 'Import Blocks From File', 'import_blocks')
UNDO_PATCH_ACTION = ('IDADeflat:undo_patch', 'Undo Last Patching', 'undo_patch')
BASIC_ACTIONS = [SET_ENTRY_ACTION, ADD_BLOCK_ACTION, REMOVE_BLOCK_ACTION, DO_DEFLAT_ACTION, RESET_ACTION, UNDO_PATCH_ACTION, SHOW_BLOCK_ACTION, IMPORT_BLOCK_ACTION]
SWITCH_ACTIONS = []


def get_block_node(addr):
    func = idaapi.get_func(addr)
    if not func:
        return None
    graph = idaapi.FlowChart(func, flags=idaapi.FC_PREDS)
    for node in graph:
        if addr >= node.start_ea and addr < node.end_ea:
            return node
    return None

def set_color_to_block(node, color):
    ptr = node.start_ea
    while ptr < node.end_ea:
        idc.set_color(ptr, idc.CIC_ITEM, color)
        ptr = idaapi.next_head(ptr, node.end_ea)

class ActionHandler(idaapi.action_handler_t):

    def __init__(self, host, name, label, callback, metadata : dict=None, shortcut=None, tooltip=None, icon=-1, flags=0):
        idaapi.action_handler_t.__init__(self)
        self.callback = callback
        self.name = name
        self.host = host
        self.metadata =metadata
        self.action_desc = idaapi.action_desc_t(name, label, self, shortcut, tooltip, icon, flags)

    def unregister_action(self):
        idaapi.unregister_action(self.name)

    def register_action(self, menupath=None):
        if not idaapi.register_action(self.action_desc):
            return False
        if menupath and not idaapi.attach_action_to_menu(menupath, self.name, idaapi.SETMENU_APP):
            return False
        return True

    def activate(self, ctx):
        self.callback(host=self.host, meta=self.metadata, ctx=ctx)

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS
    

class UIHooks(idaapi.UI_Hooks):

    def finish_populating_widget_popup(self, widget, popup):
        if idaapi.get_widget_type(widget) == idaapi.BWN_DISASM:
            idx = 0
            for action in BASIC_ACTIONS:
                idaapi.attach_action_to_popup(widget, popup, action[0], "Deflat/")
                if idx == 2 or idx == 6:
                    idaapi.attach_action_to_popup(widget, popup, "-", 'Deflat/')
                idx += 1
            for action in SWITCH_ACTIONS:
                idaapi.attach_action_to_popup(widget, popup, action[0], "Deflat/Cores/")


class StateChoose(idaapi.Choose):
    
    def __init__(self, title, items, embedded=False):
        idaapi.Choose.__init__(self, title, [["Address", 20], ["Function", 30], ["Type", 30]], embedded=embedded)
        self.items = items
        self.icon = 46

    def GetItems(self):
        return self.items

    def SetItems(self, items):
        self.items = [] if items is None else items

    def OnClose(self):
        pass

    def OnGetLine(self, n):
        return self.items[n]

    def OnGetSize(self):
        return len(self.items)

    def OnSelectLine(self, n):
        idaapi.jumpto(int(self.items[n][0], 16))

class IDADeflatMain:
    
    def __init__(self):
        self.working_entry = -1
        self.working_blocks = []
        self.process_cores : list[DeflatCore] = []
        self.using_core :DeflatCore = None
        self.registered_actions = []
        self.ui_hook = None
        self.last_patch = []

    def add_core(self, core : DeflatCore):
        self.process_cores.append(core)

    def set_core(self, core_name):
        for core in self.process_cores:
            if core.get_name() == core_name:
                self.using_core = core
                return True
        return False


    @staticmethod
    def add_working_blocks(**kwargs):
        main_obj : IDADeflatMain = kwargs['host']
        if main_obj.working_entry < 0:
            print('[IDADeflat] please set function entry address first!')
            return
        ea = idaapi.get_screen_ea()
        block = get_block_node(ea)
        if not block:
            print('[IDADeflat] unable to locate basic block for %s' % hex(ea))
            return
        ea = block.start_ea
        func = idaapi.get_func(ea)
        if func is None or func.start_ea != main_obj.working_entry:
            print('[IDADeflat] invalid basic block address for Function: %s' % idaapi.get_func_name(main_obj.working_entry))
            return
        main_obj.working_blocks.append(ea)
        set_color_to_block(get_block_node(ea), 0xffcc33)
        print('[IDADeflat] relevant block at %s has been added to working list...' % hex(ea))
        
    @staticmethod
    def import_blocks(**kwargs):
        main_obj : IDADeflatMain = kwargs['host']
        IDADeflatMain.reset_state(host=main_obj)
        file = open('blocks.json', 'rb')
        blocks_info = json.load(file)
        main_obj.working_entry = blocks_info['entry_block']
        for addr in blocks_info['relevant_blocks']:
            main_obj.working_blocks.append(addr)
        file.close()


    @staticmethod
    def del_working_blocks(**kwargs):
        main_obj : IDADeflatMain = kwargs['host']
        ea = idaapi.get_screen_ea()
        block = get_block_node(ea)
        if not block:
            print('[IDADeflat] unable to locate basic block for %s' % hex(ea))
            return
        ea = block.start_ea
        if ea in main_obj.working_blocks:
            main_obj.working_blocks.remove(ea)
            set_color_to_block(get_block_node(ea), 0xffffff)
            print('[IDADeflat] remove relevant block successfully...')

    @staticmethod
    def set_entry_block(**kwargs):
        main_obj : IDADeflatMain = kwargs['host']
        ea = idaapi.get_screen_ea()
        func = idaapi.get_func(ea)
        if func is None:
            print('[IDADeflat] invalid entry point')
            return
        if main_obj.working_entry > 0:
            set_color_to_block(get_block_node(main_obj.working_entry), 0xffffff)
        main_obj.working_entry = func.start_ea
        set_color_to_block(get_block_node(func.start_ea), 0xffcc33)
        print('[IDADeflat] entry point set to %s in %s' % (hex(func.start_ea), idaapi.get_func_name(func.start_ea)))

    @staticmethod
    def do_deflat(**kwargs):
        main_obj : IDADeflatMain = kwargs['host']
        if main_obj.working_entry < 0 or len(main_obj.working_blocks) == 0:
            print('[IDADeflat] nothing to do, please specify a function and relevant blocks....')
            return
        target_func = idaapi.get_func(main_obj.working_entry)
        if not target_func:
            print('[IDADeflat] invalid function address...')
            return
        for block in main_obj.working_blocks:
            if idaapi.get_func(block) != target_func:
                print('[IDADeflat] blocks are not in the same function!...')
                return
        patches = main_obj.using_core.process(main_obj.working_entry, main_obj.working_blocks.copy())
        main_obj.reset_state(host=main_obj)
        graph = idaapi.FlowChart(target_func, flags=idaapi.FC_PREDS)
        for node in graph:
            main_obj.last_patch.append((node.start_ea, idaapi.get_bytes(node.start_ea, node.end_ea - node.start_ea)))
            idaapi.patch_bytes(node.start_ea, (node.end_ea - node.start_ea) * b'\x00')
        for patch_addr, patch_data in patches:
            idaapi.patch_bytes(patch_addr, patch_data)
            
    @staticmethod
    def undo_patch(**kwargs):
        main_obj : IDADeflatMain = kwargs['host']
        for patch_addr, patch_data in main_obj.last_patch:
            idaapi.patch_bytes(patch_addr, patch_data)
        main_obj.last_patch.clear()

    @staticmethod
    def switch_core(**kwargs):
        main_obj : IDADeflatMain = kwargs['host']
        metadata : dict = kwargs['meta']
        core_name = metadata['core_name']
        if main_obj.set_core(core_name):
            print('[IDADeflat] switch core to %s' % core_name)
        else:
            print('[IDADeflat] fail to set core....')

    @staticmethod
    def reset_state(**kwargs):
        main_obj : IDADeflatMain = kwargs['host']
        if main_obj.working_entry > 0:
            set_color_to_block(get_block_node(main_obj.working_entry), 0xffffff)
        for ea in main_obj.working_blocks:
            set_color_to_block(get_block_node(ea), 0xffffff)
        main_obj.working_entry = -1
        main_obj.working_blocks.clear()
        main_obj.last_patch.clear()
        print('[IDADeflat] reset state successfully..')
        

    @staticmethod
    def show_state(**kwargs):
        main_obj : IDADeflatMain = kwargs['host']
        if main_obj.working_entry > 0:
            items = []
            items.append((hex(main_obj.working_entry), idaapi.get_func_name(main_obj.working_entry), 'EntryBlock'))
            for addr in main_obj.working_blocks:
                func = idaapi.get_func(addr)
                items.append((hex(addr), idaapi.get_func_name(func.start_ea), 'RelevantBlock'))
            ch = StateChoose('Deflat Info', items)
            ch.Show()
        else:
            print('[IDADeflat] no state...')

    def init(self):
        self.add_core(AngrDeflatCore())
        self.using_core = self.process_cores[0]
        for action in BASIC_ACTIONS:
            handler = ActionHandler(self, action[0], action[1], getattr(IDADeflatMain, action[2]))
            handler.register_action()
            self.registered_actions.append(handler)
        for core in self.process_cores:
            core_name = core.get_name()
            name = 'IDADeflat:' + core_name
            label_name = 'Use ' + core_name
            handler = ActionHandler(self, name, label_name, 
                                    getattr(IDADeflatMain, 'switch_core'), 
                                    metadata={
                                        'core_name' : core_name
                                    })
            handler.register_action()
            SWITCH_ACTIONS.append((name, label_name))
            self.registered_actions.append(handler)

        self.ui_hook = UIHooks()
        self.ui_hook.hook()

    def term(self):
        if self.ui_hook:
            self.ui_hook.unhook()
        for action in self.registered_actions:
            action.unregister_action()
        self.registered_actions.clear()

    
def check_ida_version():
    if idaapi.IDA_SDK_VERSION < 700:
        print("[-] IDADeflat support 7.x IDA, please update your IDA version.")
        return False
    return True


class IDADeflat_t(idaapi.plugin_t):
    comment = "IDADeflat plugin for IDA Pro (using angr framework)"
    help = "todo"
    wanted_name = "IDADeflat"
    wanted_hotkey = ""
    flags = idaapi.PLUGIN_KEEP
    def init(self):
        if not check_ida_version():
             return idaapi.PLUGIN_SKIP
        self.main = IDADeflatMain()
        self.main.init()
        print('[IDADeflat] IDADeflat plugin initialized!')
        return idaapi.PLUGIN_OK

    def run(self, arg):
        pass

    def term(self):
        if self.main:
            self.main.term()
        pass

def PLUGIN_ENTRY():
    return IDADeflat_t()


```

`idadeflat_cores/angr_core.py`:

```py
import angr
import idaapi
import pyvex
import claripy
import capstone
import keystone 
from .core_base import DeflatCore



class RelocBlock:
    def __init__(self, cs : capstone.Cs, ks : keystone.Ks, addr : int, asm_data : bytes):
        self.cs = cs
        self.ks = ks
        self.addr = addr
        self.asm_data = asm_data
        self.disasm()

    def disasm(self):
        self.insns = [insn for insn in self.cs.disasm(self.asm_data, self.addr)]

    def size(self):
        return len(self.asm_data)

    def reloc_to(self, new_addr):
        self.disasm()
        new_code = b''
        ptr = new_addr
        offset = 0
        for insn in self.insns:
            try:
                encoding, _ = self.ks.asm(insn.mnemonic + " " + insn.op_str, ptr)
            except:
                print('[AngrCore] invalid instruction(%s) detected, unable to relocation...' % (insn.mnemonic + " " + insn.op_str))
                encoding = self.asm_data[offset:offset+insn.size]

            offset += len(encoding)
            ptr += len(encoding)
            new_code += bytes(encoding)
        self.addr = new_addr
        self.asm_data = new_code

ARCH_X86 = {"X86", "AMD64"}
ARCH_ARM = {"ARMEL", "ARMHF"}
ARCH_ARM64 = {'AARCH64'}

def is_jump(arch, name):
    if arch in ARCH_X86:
        return name in [
        "jmp", "jo", "jno", "js", "jns", "je", "jz", "jne", "jnz",
        "jb", "jnae", "jc", "jnb", "jae", "jnc", "jbe",
        "jna", "ja", "jnbe", "jl", "jnge", "jge", "jnl",
        "jle", "jng", "jg", "jnle", "jp", "jpe", "jnp",
        "jpo", "jcxz", "jecxz"
    ]
    elif arch in ARCH_ARM or arch in ARCH_ARM64:
        return name in [
        "b", "br", "beq", "bne", "bcs", "bhs",
        "bcc", "blo", "bmi", "bpl", "bvs", "bvc", "bhi",
        "bls", "bge", "blt", "bgt", "ble", "cbz", "cbnz",
        "tbb", "tbh"
    ]
    assert False, 'unsupported arch...'

def is_call(arch, name):
    if arch in ARCH_X86:
        return name == "call"
    elif arch in ARCH_ARM or arch in ARCH_ARM64:
        return name in [
            "bl", "blr", "blx"
        ]
    assert False, 'unsupported arch...'

def build_jump(arch, target, cond):
    if arch in ARCH_X86:
        if cond:
            return 'j' + cond + ' ' + hex(target)
        else:
            return 'jmp' + ' ' + hex(target)
    elif arch in ARCH_ARM or arch in ARCH_ARM64:
        if cond:
            return 'b' + cond + ' ' + hex(target)
        else:
            return 'b' + ' ' + hex(target)

def extract_cond_flag(arch, insn):
    arm_cond = ['eq', 'ne', 'hs', 'lo', 'mi', 'pl', 'vs', 'vc', 'hi', 'ls', 'ge', 'lt', 'gt', 'le']
    x86_cond = ['e', 'ne', 'g', 'ge', 'l', 'le', 'b', 'be', 'a', 'ae', 'o', 'no', 's', 'ns', 'p', 'np', 'cxz', 'ecxz', 'rcxz']
    if arch in ARCH_X86:
        for c in x86_cond:
            if insn.mnemonic == 'cmov' + c:
                return c
    if arch in ARCH_ARM or arch in ARCH_ARM64:
        for c in arm_cond:
            if c in insn.mnemonic + ' ' + insn.op_str:
                return c
    return None

    
class AngrDeflatCore(DeflatCore):
    def __init__(self):
        DeflatCore.__init__(self, 'AngrDeflatCore')
        self.graph = {}
        

    def get_block_node(self, addr):
        func = idaapi.get_func(addr)
        if not func:
            return None
        graph = idaapi.FlowChart(func, flags=idaapi.FC_PREDS)
        for node in graph:
            if addr >= node.start_ea and addr < node.end_ea:
                return node
        return None
    
    def execute(self, proj, init_block_start, init_block_end, process_block_start, process_block_end, other_blocks, apply_value):
        entry_state = proj.factory.blank_state(addr=init_block_start, remove_options={
                                        angr.sim_options.LAZY_SOLVES})
        sm = proj.factory.simulation_manager(entry_state)
        if init_block_start != process_block_start:
            while True:
                len(sm.active) == 1
                cur = sm.active[0]
                pc = cur.solver.eval(cur.regs.ip)
                if pc >= init_block_end:
                    break
                sm.step()
            
            entry_state = sm.active[0]
            entry_state.regs.ip = process_block_start
        apply_place = None
        def statement_inspect(state):
            nonlocal apply_place
            pc = state.solver.eval(state.regs.ip)
            if pc < process_block_start or pc >= process_block_end:
                return None
            expressions = list(
                state.scratch.irsb.statements[state.inspect.statement].expressions)
            if len(expressions) != 0 and isinstance(expressions[0], pyvex.expr.ITE):
                print('[AngrCore] apply value to address: ' + hex(state.scratch.ins_addr))
                apply_place = state.solver.eval(state.scratch.ins_addr)
                state.scratch.temps[expressions[0].cond.tmp] = apply_value
                # If the first ITE statement of the basic block is not related to the switchvar, will there be a problem?
                state.inspect._breakpoints['statement'] = []   
        entry_state.inspect.b('statement', when=angr.state_plugins.inspect.BP_BEFORE, action=statement_inspect)
        
        sm.step()
        while len(sm.active) > 0:
            for active_state in sm.active:
                if active_state.addr in other_blocks:
                    return apply_place, active_state.addr
            sm.step()
        return None
    

    def process(self, entry : int, blocks : list[int]):
        self.graph.clear()
        file_path = idaapi.get_input_file_path()
        load_base = idaapi.get_imagebase()
        graph = {}
        proj = angr.Project(file_path, main_opts={'base_addr': load_base})
        assert proj.arch.name in ARCH_X86 or proj.arch.name in ARCH_ARM or proj.arch.name in ARCH_ARM64, 'unsupported arch...'
        entry_node = self.get_block_node(entry)
        process_bb = [entry] + blocks

        def retn_procedure(state):
            ip = state.solver.eval(state.regs.ip)
            print('[AngrCore] call from ' + hex(ip))
            return
        for b in process_bb:
            node = self.get_block_node(b)
            block = proj.factory.block(b, size=node.end_ea - node.start_ea)
            for ins in block.capstone.insns:
                if is_call(proj.arch.name, ins.mnemonic):
                    print('[AngrCore] ignored call instruction at ' + hex(ins.address))
                    proj.hook(ins.address, retn_procedure, length=ins.size)
        
        cond_map = {}
        for b in process_bb:
            graph[b] = list()
            node = self.get_block_node(b)
            print(hex(b))
            bb0 = self.execute(proj, entry_node.start_ea, entry_node.end_ea, b, node.end_ea, process_bb, claripy.BVV(0, 1))
            bb1 = self.execute(proj, entry_node.start_ea, entry_node.end_ea, b, node.end_ea, process_bb, claripy.BVV(1, 1))
            
            print(bb0)
            print(bb1)
            if bb0 == bb1 and bb0:
                graph[b].append((bb0[1], None))
            elif bb0 and bb1:
                assert bb0[0] == bb1[0]
                cond_map[b] = bb0[0]
                graph[b].append((bb0[1], True))
                graph[b].append((bb1[1], False))
        print(graph)
        ## todo: do patch
        
        cs = proj.arch.capstone
        ks = proj.arch.keystone
        block_map = {}
        for b in process_bb:
            node = self.get_block_node(b)
            assert b == node.start_ea
            
            ptr = 0
            cond = None
            if len(graph[b]) == 1:
                block = proj.factory.block(b, size=node.end_ea - node.start_ea)
                last = block.capstone.insns[-1]
                if is_jump(proj.arch.name, last.mnemonic):
                    ptr = last.address
                else:
                    ptr = node.end_ea
            elif len(graph[b]) == 2:
                block = proj.factory.block(cond_map[b], size=node.end_ea - cond_map[b])
                ptr = cond_map[b]
                cond = None
                for insn in block.capstone.insns:
                    cond = extract_cond_flag(proj.arch.name, insn)
                    if cond:
                        break
                assert cond, 'fail to extract condition type...'
                cond_map[b] = cond
            else:
                ptr = node.end_ea
            raw_code = idaapi.get_bytes(node.start_ea, ptr - node.start_ea)
            reloc_block = RelocBlock(cs, ks, b, raw_code)
            block_map[b] = reloc_block
        #proj.factory.block(addr, size=parent.size)

        allocator = entry
        padding_size = 8
        allocate_map = {}
        visited = set()
        
        def realloc(cur_block):
            nonlocal allocator
            cur_addr = allocator
            block_map[cur_block].reloc_to(allocator)
            cur_size = block_map[cur_block].size() + padding_size
            allocator += cur_size
            for son, _ in graph[cur_block]:
                if son not in visited:
                    visited.add(son)
                    realloc(son)
            allocate_map[cur_block] = cur_addr
            
            
        visited.add(entry)
        realloc(entry)
        patches = []
        print(allocate_map)
        for b in process_bb:
            if b not in allocate_map.keys():
                print('[AngrCore] isolate block detected, the result maybe wrong...')
                continue
            raw_data = block_map[b].asm_data
            if len(graph[b]) == 1:
                succ = graph[b][0][0]
                data = bytes(ks.asm(build_jump(proj.arch.name, allocate_map[succ], None), allocate_map[b] + block_map[b].size())[0])
                data += b'\x00' * (padding_size - len(data))
                raw_data += data

            elif len(graph[b]) == 2:
                succ0 = graph[b][0][0]
                succ1 = graph[b][1][0]
                data = bytes(ks.asm(build_jump(proj.arch.name, allocate_map[succ0], cond_map[b]), allocate_map[b] + block_map[b].size())[0])
                data += bytes(ks.asm(build_jump(proj.arch.name, allocate_map[succ1], None), allocate_map[b] + block_map[b].size() + len(data))[0])
                data += b'\x00' * (padding_size - len(data))
                raw_data += data
            else:
                raw_data += b'\x00' * padding_size
            for insn in cs.disasm(raw_data, allocate_map[b]):
                print(insn)
            print()
            patches.append((allocate_map[b] ,raw_data))
        self.graph = graph
        return patches
            

        
        

    def get_result(self) -> dict[int, int]:
        return self.graph
```

`idadeflat_cores/core_base.py`:

```py
class DeflatCore:
    def __init__(self, name):
        self.name = name

    def get_name(self):
        return self.name

    def process(self, entry : int, blocks : list[int]):
        print('[%s] start processing' % self.name)

    def get_result(self) -> dict[int, int]:
        return {}

```